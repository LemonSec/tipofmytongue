1
00:00:00,120 --> 00:00:03,480
uh welcome everyone so we are about to

2
00:00:03,480 --> 00:00:04,319
start

3
00:00:04,319 --> 00:00:06,600
um the to this morning session on

4
00:00:06,600 --> 00:00:08,940
attribute-based encryption in France so

5
00:00:08,940 --> 00:00:11,639
we have uh three talks first then there

6
00:00:11,639 --> 00:00:14,700
is a track switch break and then two

7
00:00:14,700 --> 00:00:17,400
more talks so the first talk is on a

8
00:00:17,400 --> 00:00:18,900
fully adaptive decentralized

9
00:00:18,900 --> 00:00:20,699
multi-authority a b

10
00:00:20,699 --> 00:00:23,699
um and ilanco markowski is going to give

11
00:00:23,699 --> 00:00:25,199
the talk

12
00:00:25,199 --> 00:00:27,840
please okay hi everyone thanks for

13
00:00:27,840 --> 00:00:30,119
coming to my session I'll talk about

14
00:00:30,119 --> 00:00:31,619
fully adaptive decentralized

15
00:00:31,619 --> 00:00:33,719
multi-authority Abe this is based on

16
00:00:33,719 --> 00:00:36,059
joint work with Protege data and Brent

17
00:00:36,059 --> 00:00:37,500
Waters

18
00:00:37,500 --> 00:00:39,600
so I'll start by telling you what a b is

19
00:00:39,600 --> 00:00:42,239
a b is just a public encryption scheme

20
00:00:42,239 --> 00:00:45,780
but it is associated with a feature that

21
00:00:45,780 --> 00:00:48,480
allows you to generate keys for a

22
00:00:48,480 --> 00:00:50,640
restricted that can allow you to decrypt

23
00:00:50,640 --> 00:00:52,920
various ciphertext so it's restricted

24
00:00:52,920 --> 00:00:55,079
keys that can help you restrict only

25
00:00:55,079 --> 00:00:57,780
certain ciphertexts specifically we'll

26
00:00:57,780 --> 00:00:59,879
talk about the ciphertext policy variant

27
00:00:59,879 --> 00:01:02,699
where you can generate secret keys that

28
00:01:02,699 --> 00:01:04,619
are associated with a set of attributes

29
00:01:04,619 --> 00:01:07,200
and a ciphertext that are associated

30
00:01:07,200 --> 00:01:09,960
with functions and the ciphertext will

31
00:01:09,960 --> 00:01:12,720
allow you to decrypt a given a a secret

32
00:01:12,720 --> 00:01:14,760
key will allow you to decrypt a given

33
00:01:14,760 --> 00:01:17,400
Cipher text only if the function on the

34
00:01:17,400 --> 00:01:20,040
set of attributes is satisfied and if

35
00:01:20,040 --> 00:01:21,840
it's not you it should be like in the

36
00:01:21,840 --> 00:01:23,280
standard public encryption scheme where

37
00:01:23,280 --> 00:01:25,380
you download any key

38
00:01:25,380 --> 00:01:27,240
okay so this is attribute-based

39
00:01:27,240 --> 00:01:29,880
encryption uh we'll be talking about

40
00:01:29,880 --> 00:01:32,700
further generalization of Abe that's

41
00:01:32,700 --> 00:01:34,680
motivated by the following deficiency of

42
00:01:34,680 --> 00:01:35,939
standard a b

43
00:01:35,939 --> 00:01:39,659
so if you remember standard a b there's

44
00:01:39,659 --> 00:01:42,840
a one Authority or one entity that's in

45
00:01:42,840 --> 00:01:45,180
charge of generating secret keys

46
00:01:45,180 --> 00:01:47,759
this is the entity or organization that

47
00:01:47,759 --> 00:01:49,680
decides who gets a key for having some

48
00:01:49,680 --> 00:01:51,299
attribute and who doesn't get the key

49
00:01:51,299 --> 00:01:55,200
for having the same attribute but this

50
00:01:55,200 --> 00:01:57,119
is not necessarily the case when you

51
00:01:57,119 --> 00:02:00,360
want to use a b in a very in a larger

52
00:02:00,360 --> 00:02:02,759
context for example if you have a huge

53
00:02:02,759 --> 00:02:04,320
system that includes many different

54
00:02:04,320 --> 00:02:06,479
authorities it doesn't really make sense

55
00:02:06,479 --> 00:02:08,580
that one Authority will be in charge of

56
00:02:08,580 --> 00:02:10,500
generating all secret kids so imagine

57
00:02:10,500 --> 00:02:12,900
for instance you have a really large

58
00:02:12,900 --> 00:02:14,940
system where you have large

59
00:02:14,940 --> 00:02:17,520
organizations involved like the DMV the

60
00:02:17,520 --> 00:02:19,980
military maybe some University and each

61
00:02:19,980 --> 00:02:21,959
organization is should be in charge of

62
00:02:21,959 --> 00:02:24,360
generating their own keys right the DMV

63
00:02:24,360 --> 00:02:25,980
is the one telling people whether they

64
00:02:25,980 --> 00:02:28,200
have a driving license or not and the

65
00:02:28,200 --> 00:02:29,879
university is the one issuing PhD

66
00:02:29,879 --> 00:02:32,040
certificates and so on

67
00:02:32,040 --> 00:02:34,200
and this is what multi-authority a b

68
00:02:34,200 --> 00:02:36,900
comes to solve this is a an idea that

69
00:02:36,900 --> 00:02:39,360
was put forward by Chase about 15 years

70
00:02:39,360 --> 00:02:41,819
ago and has received quite a lot of

71
00:02:41,819 --> 00:02:44,760
attention since then

72
00:02:44,760 --> 00:02:47,760
what do we expect from an maab or what

73
00:02:47,760 --> 00:02:50,459
we think is the right definition of maab

74
00:02:50,459 --> 00:02:52,739
or multi-authority a B

75
00:02:52,739 --> 00:02:55,379
the system is set up and at that point

76
00:02:55,379 --> 00:02:57,900
anybody can just join the system I want

77
00:02:57,900 --> 00:03:00,060
to be an authority that generates tokens

78
00:03:00,060 --> 00:03:02,160
being for being my friend

79
00:03:02,160 --> 00:03:05,940
or some University can join like a new

80
00:03:05,940 --> 00:03:08,099
University can join and say okay I'm

81
00:03:08,099 --> 00:03:10,860
issuing new PhD certificates

82
00:03:10,860 --> 00:03:12,959
so authorities should be able to join

83
00:03:12,959 --> 00:03:14,700
the system without knowing who else is

84
00:03:14,700 --> 00:03:16,620
in the system without ever talking to

85
00:03:16,620 --> 00:03:18,959
them without even knowing that they

86
00:03:18,959 --> 00:03:19,920
exist

87
00:03:19,920 --> 00:03:22,680
and there should be no no bound the

88
00:03:22,680 --> 00:03:24,300
number of authorities all of the

89
00:03:24,300 --> 00:03:26,340
authorities like anybody can join at any

90
00:03:26,340 --> 00:03:27,659
point in time it doesn't matter who

91
00:03:27,659 --> 00:03:29,940
joined earlier and who joined later

92
00:03:29,940 --> 00:03:32,580
and whenever an authority joins the

93
00:03:32,580 --> 00:03:34,379
system you should also be able to

94
00:03:34,379 --> 00:03:37,080
generate keys for attributes that it

95
00:03:37,080 --> 00:03:38,940
possesses without ever talking to

96
00:03:38,940 --> 00:03:40,739
anybody else so it's completely

97
00:03:40,739 --> 00:03:42,720
completely distributed almost no

98
00:03:42,720 --> 00:03:44,159
coordination between the authorities

99
00:03:44,159 --> 00:03:46,260
except Perhaps Perhaps some Global

100
00:03:46,260 --> 00:03:48,720
parameters that are set up at the

101
00:03:48,720 --> 00:03:50,940
beginning of the system at the start

102
00:03:50,940 --> 00:03:52,019
okay

103
00:03:52,019 --> 00:03:55,440
so this is what we imagine a a real

104
00:03:55,440 --> 00:03:57,599
multi-authority a b system to look like

105
00:03:57,599 --> 00:03:59,760
and these are the features that it

106
00:03:59,760 --> 00:04:01,200
should possess

107
00:04:01,200 --> 00:04:03,780
so here's a concrete example imagine

108
00:04:03,780 --> 00:04:06,480
this is a three gentlemen each having

109
00:04:06,480 --> 00:04:08,700
some attributes so for example the first

110
00:04:08,700 --> 00:04:10,860
guy has a key for having a driving

111
00:04:10,860 --> 00:04:13,620
license the second guy has a key for be

112
00:04:13,620 --> 00:04:16,260
having a PhD and the third guy has a key

113
00:04:16,260 --> 00:04:18,839
for being for being a veteran and having

114
00:04:18,839 --> 00:04:20,279
a PhD

115
00:04:20,279 --> 00:04:23,759
and now imagine this lady generating two

116
00:04:23,759 --> 00:04:26,520
Cipher texts one says hi the other says

117
00:04:26,520 --> 00:04:29,360
bye but the first one is with respect to

118
00:04:29,360 --> 00:04:32,220
the conjunction of PhD and driving

119
00:04:32,220 --> 00:04:34,620
license and the second one is PhD and

120
00:04:34,620 --> 00:04:36,180
Veteran

121
00:04:36,180 --> 00:04:37,620
so if you

122
00:04:37,620 --> 00:04:40,560
if the system behaves as it should then

123
00:04:40,560 --> 00:04:43,080
the third gentleman should be able to

124
00:04:43,080 --> 00:04:46,320
decrypt ciphert X2 because he has two

125
00:04:46,320 --> 00:04:48,960
keys one for having 200 keys for two

126
00:04:48,960 --> 00:04:51,240
attributes one is being having a PhD and

127
00:04:51,240 --> 00:04:53,280
one is being a veteran but nobody else

128
00:04:53,280 --> 00:04:55,620
should be able to decrypt The Cypher

129
00:04:55,620 --> 00:04:57,360
text one because nobody

130
00:04:57,360 --> 00:05:02,160
has two keys that satisfy the relation

131
00:05:02,160 --> 00:05:04,740
okay but now you should ask yourselves

132
00:05:04,740 --> 00:05:06,540
okay but how does the system distinguish

133
00:05:06,540 --> 00:05:08,580
between different people if it's

134
00:05:08,580 --> 00:05:11,460
completely non-interactive and I didn't

135
00:05:11,460 --> 00:05:14,820
ever meet anybody so we assume the

136
00:05:14,820 --> 00:05:16,680
standard solution for this issue is to

137
00:05:16,680 --> 00:05:20,280
assume a model where parties have some

138
00:05:20,280 --> 00:05:22,560
identifier we call it the GID model a

139
00:05:22,560 --> 00:05:25,320
global identifier model it's some number

140
00:05:25,320 --> 00:05:27,660
that's associated with each party in the

141
00:05:27,660 --> 00:05:29,639
system it's something that's set up once

142
00:05:29,639 --> 00:05:31,199
and for all when the when the system

143
00:05:31,199 --> 00:05:34,259
setups and the user joins the system and

144
00:05:34,259 --> 00:05:35,820
it's something that shouldn't be chosen

145
00:05:35,820 --> 00:05:38,160
by the by the user it's like a number

146
00:05:38,160 --> 00:05:39,600
that's given to you so just imagine

147
00:05:39,600 --> 00:05:42,900
something like a social security number

148
00:05:42,900 --> 00:05:44,759
and this of course allows you to

149
00:05:44,759 --> 00:05:46,080
distinguish between different people

150
00:05:46,080 --> 00:05:47,400
right

151
00:05:47,400 --> 00:05:49,979
okay so this is the model so now that we

152
00:05:49,979 --> 00:05:51,240
understand the motivation and the model

153
00:05:51,240 --> 00:05:54,120
let's let me be more precise about the

154
00:05:54,120 --> 00:05:57,780
syntax so the syntax first run there's a

155
00:05:57,780 --> 00:06:00,240
global parameter setup so you first

156
00:06:00,240 --> 00:06:02,160
generate Global parameters then

157
00:06:02,160 --> 00:06:04,979
authorities can join the system generate

158
00:06:04,979 --> 00:06:06,720
the public key and the master secret key

159
00:06:06,720 --> 00:06:09,000
once they say they publish the public

160
00:06:09,000 --> 00:06:10,500
key and keep for themselves the master

161
00:06:10,500 --> 00:06:12,539
security of course then they can

162
00:06:12,539 --> 00:06:14,520
generate keys for parties for specific

163
00:06:14,520 --> 00:06:17,759
geds people can encrypt messages with

164
00:06:17,759 --> 00:06:19,440
respect with respect to functions

165
00:06:19,440 --> 00:06:22,020
associated with a set of public keys and

166
00:06:22,020 --> 00:06:23,460
if you have sufficiently many secret

167
00:06:23,460 --> 00:06:26,039
Keys you can also decrypt a given

168
00:06:26,039 --> 00:06:28,620
ciphertext and correctness is as in

169
00:06:28,620 --> 00:06:31,380
standard a b if the function is

170
00:06:31,380 --> 00:06:33,900
satisfied if the set of attributes that

171
00:06:33,900 --> 00:06:35,460
you own satisfies the function you can

172
00:06:35,460 --> 00:06:39,300
decrypt and if it's not then you cannot

173
00:06:39,300 --> 00:06:41,759
how do we Define security for this

174
00:06:41,759 --> 00:06:44,400
complicated distributed primitive so

175
00:06:44,400 --> 00:06:46,440
there's kind of quite a lot of

176
00:06:46,440 --> 00:06:48,419
definitions out there so I'll give you

177
00:06:48,419 --> 00:06:50,400
first an abstract definition and then

178
00:06:50,400 --> 00:06:52,500
I'll give specific details so an

179
00:06:52,500 --> 00:06:54,720
abstract definition is the the standard

180
00:06:54,720 --> 00:06:56,940
one that you see in every encryption

181
00:06:56,940 --> 00:06:59,580
scheme the Challenger first generates

182
00:06:59,580 --> 00:07:01,800
the public Keys the public parameters of

183
00:07:01,800 --> 00:07:03,240
the system the global parameters the

184
00:07:03,240 --> 00:07:06,680
adversary then issues a bunch of queries

185
00:07:06,680 --> 00:07:09,240
adaptively the challenge responds to

186
00:07:09,240 --> 00:07:11,280
these queries at some point the

187
00:07:11,280 --> 00:07:13,259
adversary says okay I'm ready to

188
00:07:13,259 --> 00:07:15,600
generate the challenge he chooses two

189
00:07:15,600 --> 00:07:17,759
messages says okay encrypt one of them

190
00:07:17,759 --> 00:07:19,919
at random he gets back the encryption of

191
00:07:19,919 --> 00:07:22,440
one of them then again it issues a

192
00:07:22,440 --> 00:07:24,560
sequence of queries it gets back

193
00:07:24,560 --> 00:07:27,539
responses and and then when it's ready

194
00:07:27,539 --> 00:07:29,699
it should try to guess which ciphertext

195
00:07:29,699 --> 00:07:32,220
was encrypted during the challenge phase

196
00:07:32,220 --> 00:07:34,440
and the scheme is set to be secure if

197
00:07:34,440 --> 00:07:36,660
the adversary cannot win this game with

198
00:07:36,660 --> 00:07:38,639
more than negligible probability

199
00:07:38,639 --> 00:07:40,620
so this is an abstract game let's see

200
00:07:40,620 --> 00:07:42,660
what kind of queries we can do so there

201
00:07:42,660 --> 00:07:44,520
are three kinds of queries the adversary

202
00:07:44,520 --> 00:07:46,979
can say Okay I want to generate the

203
00:07:46,979 --> 00:07:49,620
following Authority so set up the DMV

204
00:07:49,620 --> 00:07:51,960
Authority it gets back the public key

205
00:07:51,960 --> 00:07:54,060
the Challenger keeps for himself the

206
00:07:54,060 --> 00:07:55,440
master secret key

207
00:07:55,440 --> 00:07:58,919
a diversary code corrupt an authority so

208
00:07:58,919 --> 00:08:00,300
we could say okay give me this master

209
00:08:00,300 --> 00:08:02,340
secret cue of this Authority and it gets

210
00:08:02,340 --> 00:08:04,020
back the master secret key

211
00:08:04,020 --> 00:08:06,720
and it can just say okay give me a

212
00:08:06,720 --> 00:08:09,660
secret key for a particular GID with

213
00:08:09,660 --> 00:08:12,539
respect to a non-corrupted Authority

214
00:08:12,539 --> 00:08:14,340
and it gets back the secret key with

215
00:08:14,340 --> 00:08:17,699
respect to the authority and the Jad

216
00:08:17,699 --> 00:08:19,199
that it asked for

217
00:08:19,199 --> 00:08:20,819
and the challenge is what you would

218
00:08:20,819 --> 00:08:24,720
expect two messages and the policy and

219
00:08:24,720 --> 00:08:26,400
the policy should not be trivially

220
00:08:26,400 --> 00:08:28,139
satisfied by the keys the adversary

221
00:08:28,139 --> 00:08:30,000
holds of course and the Challenger

222
00:08:30,000 --> 00:08:32,458
chooses one of the messages messages at

223
00:08:32,458 --> 00:08:34,500
random and encrypts the message with

224
00:08:34,500 --> 00:08:36,599
respect to the policy along with the

225
00:08:36,599 --> 00:08:38,580
public kids

226
00:08:38,580 --> 00:08:40,559
so this is the strongest definition you

227
00:08:40,559 --> 00:08:42,479
can imagine we call it fully adaptive

228
00:08:42,479 --> 00:08:45,240
security it allows for all types of

229
00:08:45,240 --> 00:08:48,120
queries at any point in time

230
00:08:48,120 --> 00:08:49,680
this is the strongest definition you can

231
00:08:49,680 --> 00:08:51,899
imagine every sequence of adaptive

232
00:08:51,899 --> 00:08:53,940
queries the adversary does it could be

233
00:08:53,940 --> 00:08:55,519
any query

234
00:08:55,519 --> 00:08:58,140
from setup and Authority corruption

235
00:08:58,140 --> 00:09:00,240
Authority or generate the security key

236
00:09:00,240 --> 00:09:02,580
so this is the strongest definition a

237
00:09:02,580 --> 00:09:03,839
weaker definition that has been

238
00:09:03,839 --> 00:09:05,519
considered in the literature literature

239
00:09:05,519 --> 00:09:07,800
quite a lot is the one where you have an

240
00:09:07,800 --> 00:09:10,700
additional phase where the adversary

241
00:09:10,700 --> 00:09:12,660
commits on the set of crops with

242
00:09:12,660 --> 00:09:14,339
authorities at the beginning of the game

243
00:09:14,339 --> 00:09:16,140
right after seeing the public parameters

244
00:09:16,140 --> 00:09:18,360
he gets back the master secret keys for

245
00:09:18,360 --> 00:09:21,720
the corrupted authorities and also gives

246
00:09:21,720 --> 00:09:23,220
the public keys for the non-corrupted

247
00:09:23,220 --> 00:09:25,019
authorities and from that point on

248
00:09:25,019 --> 00:09:26,160
there's no point in corrupting

249
00:09:26,160 --> 00:09:27,839
authorities they're they're all

250
00:09:27,839 --> 00:09:29,580
committed to so these two kinds of

251
00:09:29,580 --> 00:09:31,380
queries are not allowed so this is the

252
00:09:31,380 --> 00:09:33,720
Adaptive security game

253
00:09:33,720 --> 00:09:35,279
and there's an even weaker security

254
00:09:35,279 --> 00:09:37,500
definition that we call static security

255
00:09:37,500 --> 00:09:40,380
where the adversary just makes all

256
00:09:40,380 --> 00:09:43,260
choices at one go he chooses everything

257
00:09:43,260 --> 00:09:45,720
once he gets the response and needs to

258
00:09:45,720 --> 00:09:47,820
decide what what happened

259
00:09:47,820 --> 00:09:50,519
he needs to design decide what was the

260
00:09:50,519 --> 00:09:52,019
The Challenge

261
00:09:52,019 --> 00:09:53,839
okay so this is the weakest definition

262
00:09:53,839 --> 00:09:56,220
these are the known results I won't get

263
00:09:56,220 --> 00:09:58,380
into to telling you what every paper

264
00:09:58,380 --> 00:10:00,240
achieved in comparison to the previous

265
00:10:00,240 --> 00:10:02,640
papers but I just want you to focus on

266
00:10:02,640 --> 00:10:05,220
the column the security column none of

267
00:10:05,220 --> 00:10:07,260
these Works achieve the full adaptive

268
00:10:07,260 --> 00:10:09,360
security definition and this is what we

269
00:10:09,360 --> 00:10:10,220
do

270
00:10:10,220 --> 00:10:13,440
our main result is the construction of a

271
00:10:13,440 --> 00:10:15,720
multi-authority a b system supporting

272
00:10:15,720 --> 00:10:18,720
nc-1 policy structures based on standard

273
00:10:18,720 --> 00:10:21,959
assumptions in in Prime order bilinear

274
00:10:21,959 --> 00:10:23,700
groups and we achieve the strongest

275
00:10:23,700 --> 00:10:26,399
possible as the notion of security that

276
00:10:26,399 --> 00:10:29,420
we call fully adaptive

277
00:10:29,940 --> 00:10:31,800
okay so

278
00:10:31,800 --> 00:10:34,620
um I have about the nine minutes so I

279
00:10:34,620 --> 00:10:35,880
won't have too much time to tell you

280
00:10:35,880 --> 00:10:38,580
what we do but I can sort of try to

281
00:10:38,580 --> 00:10:41,220
convince you why this problem was open

282
00:10:41,220 --> 00:10:43,440
for such a long time and why trivial

283
00:10:43,440 --> 00:10:44,700
things don't work and why previous

284
00:10:44,700 --> 00:10:47,300
schemes inherently didn't

285
00:10:47,300 --> 00:10:49,920
didn't manage to get this security

286
00:10:49,920 --> 00:10:51,420
notion it's not something that they just

287
00:10:51,420 --> 00:10:53,100
just didn't try

288
00:10:53,100 --> 00:10:54,779
okay so the first thing you should ask

289
00:10:54,779 --> 00:10:56,459
yourself why can't you just do the

290
00:10:56,459 --> 00:10:58,740
standard thing like complexity

291
00:10:58,740 --> 00:11:00,480
leveraging or just guess the set of

292
00:11:00,480 --> 00:11:02,940
corrupted authorities the answer is

293
00:11:02,940 --> 00:11:05,120
actually pretty easy for this question

294
00:11:05,120 --> 00:11:08,279
if you do a guessing style argument you

295
00:11:08,279 --> 00:11:10,019
sort of need to bound the number of

296
00:11:10,019 --> 00:11:11,339
corrupted authorities in the system

297
00:11:11,339 --> 00:11:13,320
which also bounds the number of

298
00:11:13,320 --> 00:11:15,240
authorities in the system

299
00:11:15,240 --> 00:11:17,220
and this is not what we would imagine

300
00:11:17,220 --> 00:11:18,660
from a fully decentralized

301
00:11:18,660 --> 00:11:20,880
multi-authority AB system

302
00:11:20,880 --> 00:11:24,500
so something trivial doesn't work

303
00:11:24,500 --> 00:11:26,820
in terms of techniques I'll try to con

304
00:11:26,820 --> 00:11:28,560
to tell you what previous Works did and

305
00:11:28,560 --> 00:11:30,120
why they failed to achieve this security

306
00:11:30,120 --> 00:11:34,079
notion so the first work that achieved

307
00:11:34,079 --> 00:11:36,180
the definition of multi-authority a b as

308
00:11:36,180 --> 00:11:38,220
I defined It Is by Lucan Waters from

309
00:11:38,220 --> 00:11:41,339
about a decade ago and they use the Dual

310
00:11:41,339 --> 00:11:43,079
systems framework which was introduced

311
00:11:43,079 --> 00:11:45,660
just a couple of years earlier and all

312
00:11:45,660 --> 00:11:48,079
follow-up Works without any exception

313
00:11:48,079 --> 00:11:50,459
basically follow the ideas of local

314
00:11:50,459 --> 00:11:53,480
Waters in some way

315
00:11:53,480 --> 00:11:57,240
so it's enough to focus on that scheme

316
00:11:57,240 --> 00:12:00,240
to see why all schemes fail to achieve

317
00:12:00,240 --> 00:12:02,160
the security definition

318
00:12:02,160 --> 00:12:04,019
um okay so I'll tell you in two words

319
00:12:04,019 --> 00:12:07,620
how dual systems work the main idea in

320
00:12:07,620 --> 00:12:11,220
dual systems framework is to allow each

321
00:12:11,220 --> 00:12:12,779
component in the system to have two

322
00:12:12,779 --> 00:12:14,339
modes a normal mode and a

323
00:12:14,339 --> 00:12:16,800
semi-functional mode and the cool thing

324
00:12:16,800 --> 00:12:18,360
about these two modes is that they can

325
00:12:18,360 --> 00:12:20,279
be mixed and matched so you can use the

326
00:12:20,279 --> 00:12:22,140
normal keys with semi-functional

327
00:12:22,140 --> 00:12:25,380
ciphertext and vice versa but once you

328
00:12:25,380 --> 00:12:27,060
try to use semi-functional keys with

329
00:12:27,060 --> 00:12:29,220
semi-functional ciphertext the system

330
00:12:29,220 --> 00:12:30,540
fails

331
00:12:30,540 --> 00:12:32,700
okay so this is the main idea in a dual

332
00:12:32,700 --> 00:12:35,160
systems framework and this construct

333
00:12:35,160 --> 00:12:37,380
this structure of building your system

334
00:12:37,380 --> 00:12:39,480
allows you to do the following style of

335
00:12:39,480 --> 00:12:43,380
proof it allows you to First Take Your

336
00:12:43,380 --> 00:12:44,519
ciphertext and change it to

337
00:12:44,519 --> 00:12:46,560
semi-functional this doesn't change

338
00:12:46,560 --> 00:12:47,940
anything in the system because you can

339
00:12:47,940 --> 00:12:49,680
mix and match semi-functional keys with

340
00:12:49,680 --> 00:12:51,480
semi-functional ciphertext

341
00:12:51,480 --> 00:12:54,000
and then you can do very small hybrids

342
00:12:54,000 --> 00:12:55,980
to change the keys one by one to

343
00:12:55,980 --> 00:12:57,300
semi-functional

344
00:12:57,300 --> 00:12:59,100
and when you're done

345
00:12:59,100 --> 00:13:00,779
you can just change the ciphertext to

346
00:13:00,779 --> 00:13:02,160
random right because it cannot mix and

347
00:13:02,160 --> 00:13:03,480
match them a functional keys with

348
00:13:03,480 --> 00:13:05,880
semi-functional ciphertext

349
00:13:05,880 --> 00:13:08,220
but in maab this doesn't work why

350
00:13:08,220 --> 00:13:10,620
because the adversary might hold Master

351
00:13:10,620 --> 00:13:12,720
secret keys for some authorities and it

352
00:13:12,720 --> 00:13:14,940
can generate secret keys by himself

353
00:13:14,940 --> 00:13:16,740
and you cannot change the secret Keys

354
00:13:16,740 --> 00:13:19,380
the adversary generates in his belly

355
00:13:19,380 --> 00:13:22,620
right so the maab setting is much more

356
00:13:22,620 --> 00:13:24,480
complicated and the Dual system

357
00:13:24,480 --> 00:13:26,519
framework at least in the most General

358
00:13:26,519 --> 00:13:29,820
sense that doesn't cannot be applied

359
00:13:29,820 --> 00:13:31,920
so here's what prior Works did This Is

360
00:13:31,920 --> 00:13:33,720
How They resolved the problem they

361
00:13:33,720 --> 00:13:35,700
assume that the adversary commits on the

362
00:13:35,700 --> 00:13:37,260
set of corrupted authorities at the

363
00:13:37,260 --> 00:13:38,519
beginning of the game

364
00:13:38,519 --> 00:13:40,680
and this allowed them to sort of take

365
00:13:40,680 --> 00:13:43,019
all the information from the corrupted

366
00:13:43,019 --> 00:13:44,940
authorities and sort of Route it around

367
00:13:44,940 --> 00:13:47,519
the proof so they they managed to

368
00:13:47,519 --> 00:13:49,200
somehow handle all of the corrupted

369
00:13:49,200 --> 00:13:51,240
authorities at one shot information

370
00:13:51,240 --> 00:13:53,760
theoretically by by just changing the

371
00:13:53,760 --> 00:13:57,120
way the access policy is defined and now

372
00:13:57,120 --> 00:13:58,800
the the rest of the proof didn't need to

373
00:13:58,800 --> 00:14:00,540
care about corrupted authorities at all

374
00:14:00,540 --> 00:14:02,579
and they just applied the Dual system

375
00:14:02,579 --> 00:14:04,260
framework on the non-corrupted

376
00:14:04,260 --> 00:14:05,339
authorities which are all the

377
00:14:05,339 --> 00:14:08,100
authorities that exist in the system

378
00:14:08,100 --> 00:14:11,639
and so this is maybe one syntactical

379
00:14:11,639 --> 00:14:14,180
problem or One A

380
00:14:14,180 --> 00:14:17,720
logical flaw in Prior works

381
00:14:17,720 --> 00:14:21,200
but actually there's a a

382
00:14:21,200 --> 00:14:23,639
technical reason why their scheme could

383
00:14:23,639 --> 00:14:25,800
not be made adaptively secure even if

384
00:14:25,800 --> 00:14:28,680
you ignore the fact that these corrupt

385
00:14:28,680 --> 00:14:31,200
authorities were routed around

386
00:14:31,200 --> 00:14:33,060
um if you look at how their skin works

387
00:14:33,060 --> 00:14:35,459
the authority keys are just scalars it's

388
00:14:35,459 --> 00:14:37,320
some number that they called Alpha in

389
00:14:37,320 --> 00:14:39,420
all of these works and this number is

390
00:14:39,420 --> 00:14:42,000
used to the randomness from this number

391
00:14:42,000 --> 00:14:43,699
is used to hide the payload of messages

392
00:14:43,699 --> 00:14:47,519
and in in a couple of more words you

393
00:14:47,519 --> 00:14:50,160
take the message you hash it you mask it

394
00:14:50,160 --> 00:14:52,800
with something like egg power s and then

395
00:14:52,800 --> 00:14:55,019
you also provide secret sharings of s

396
00:14:55,019 --> 00:14:57,240
masks with Alpha

397
00:14:57,240 --> 00:14:59,399
so if you know sufficiently many keys

398
00:14:59,399 --> 00:15:00,899
you know Alpha you can recover the

399
00:15:00,899 --> 00:15:02,220
shares and then you can recover the

400
00:15:02,220 --> 00:15:03,779
message if you don't know sufficiently

401
00:15:03,779 --> 00:15:05,639
many keys the randomness from alpha will

402
00:15:05,639 --> 00:15:08,040
hide the shares and you'll get security

403
00:15:08,040 --> 00:15:09,600
for your payload

404
00:15:09,600 --> 00:15:11,820
but when you try to corrupt an authority

405
00:15:11,820 --> 00:15:14,519
what does the simulator need to do it

406
00:15:14,519 --> 00:15:16,680
needs to give you Alpha that's what

407
00:15:16,680 --> 00:15:19,199
corrupting and Authority means but

408
00:15:19,199 --> 00:15:21,120
giving you Alpha is not something that

409
00:15:21,120 --> 00:15:23,220
is compatible with the Dual framework

410
00:15:23,220 --> 00:15:25,380
the Dual systems framework we don't have

411
00:15:25,380 --> 00:15:27,300
any security definition that involves

412
00:15:27,300 --> 00:15:29,880
scalars all of the security definitions

413
00:15:29,880 --> 00:15:32,880
involve a group elements or things in

414
00:15:32,880 --> 00:15:35,339
the exponents and not just scalars so

415
00:15:35,339 --> 00:15:37,680
there's really a technical barrier for a

416
00:15:37,680 --> 00:15:40,380
change for switching for making the

417
00:15:40,380 --> 00:15:42,240
existing schemes adaptively secure

418
00:15:42,240 --> 00:15:44,540
handling adaptive Corruptions

419
00:15:44,540 --> 00:15:47,760
so we managed to solve this issue

420
00:15:47,760 --> 00:15:49,800
and

421
00:15:49,800 --> 00:15:52,920
good so I'll just try to summarize in

422
00:15:52,920 --> 00:15:55,320
the minute I have left what we build is

423
00:15:55,320 --> 00:15:57,959
the first maabe system that achieves

424
00:15:57,959 --> 00:15:59,779
fully adaptive security

425
00:15:59,779 --> 00:16:02,639
we give schemes both in the composite

426
00:16:02,639 --> 00:16:04,680
order setting the prime order setting

427
00:16:04,680 --> 00:16:06,540
based on different assumptions depending

428
00:16:06,540 --> 00:16:08,639
on the setting our assumptions are

429
00:16:08,639 --> 00:16:10,560
standard by linear groups assumptions

430
00:16:10,560 --> 00:16:13,139
and the major open problems as at least

431
00:16:13,139 --> 00:16:15,060
as I see them is to get rid of the group

432
00:16:15,060 --> 00:16:17,579
of the random Oracle model is listed in

433
00:16:17,579 --> 00:16:20,339
the group based setting we have a

434
00:16:20,339 --> 00:16:22,380
examples in the lattice based setting

435
00:16:22,380 --> 00:16:25,019
where random oracles were not necessary

436
00:16:25,019 --> 00:16:27,660
and I think an important line of work is

437
00:16:27,660 --> 00:16:29,459
to get the concrete efficiency for

438
00:16:29,459 --> 00:16:31,380
multi-authority a b the kind of systems

439
00:16:31,380 --> 00:16:33,480
that we have are sort of

440
00:16:33,480 --> 00:16:35,339
um theoretically interesting and

441
00:16:35,339 --> 00:16:36,959
practically not very efficient they

442
00:16:36,959 --> 00:16:38,699
cannot really handle a very large number

443
00:16:38,699 --> 00:16:42,240
of entities or large number of

444
00:16:42,240 --> 00:16:45,000
authorities or attributes so it's an

445
00:16:45,000 --> 00:16:46,980
interesting line of work to maybe even

446
00:16:46,980 --> 00:16:48,899
relax the assumptions but get much more

447
00:16:48,899 --> 00:16:53,260
efficient schemes so thank you

448
00:16:53,260 --> 00:16:59,100
[Applause]

449
00:16:59,100 --> 00:17:02,279
so we have time for questions so if you

450
00:17:02,279 --> 00:17:05,660
have a question please come to the mic

451
00:17:08,760 --> 00:17:10,740
it's for a nice talk I have a question

452
00:17:10,740 --> 00:17:13,199
regarding the GID you've mentioned in a

453
00:17:13,199 --> 00:17:15,900
slice does does it have something to do

454
00:17:15,900 --> 00:17:18,240
with the security proof or do you have

455
00:17:18,240 --> 00:17:21,799
to embed something into that so yeah

456
00:17:21,799 --> 00:17:24,480
we use the random Oracle we apply a

457
00:17:24,480 --> 00:17:26,160
random Oracle on the GID

458
00:17:26,160 --> 00:17:28,980
and this is important for this is where

459
00:17:28,980 --> 00:17:31,559
we use the random Oracle we program the

460
00:17:31,559 --> 00:17:34,620
JD in the right way

461
00:17:34,620 --> 00:17:36,360
so yeah it's necessary for the security

462
00:17:36,360 --> 00:17:37,799
proof and this is where the random

463
00:17:37,799 --> 00:17:39,720
Oracle also plays a crucial part in our

464
00:17:39,720 --> 00:17:42,059
proof

465
00:17:42,059 --> 00:17:44,539
thank you

466
00:17:49,980 --> 00:17:53,640
so maybe a question just to touch on

467
00:17:53,640 --> 00:17:56,039
there we go on the on the efficiency

468
00:17:56,039 --> 00:17:58,320
which you mentioned at the uh well very

469
00:17:58,320 --> 00:18:00,840
end uh have you tried well let's say

470
00:18:00,840 --> 00:18:03,179
implementing a proof of concept and if

471
00:18:03,179 --> 00:18:07,200
so uh like do you have like much of an

472
00:18:07,200 --> 00:18:09,720
idea of like how well it was able to

473
00:18:09,720 --> 00:18:11,400
scale just as an indicator if nothing

474
00:18:11,400 --> 00:18:14,220
else like how large could you get it

475
00:18:14,220 --> 00:18:16,380
before it started to become unacceptably

476
00:18:16,380 --> 00:18:17,580
uh

477
00:18:17,580 --> 00:18:20,340
slow so we actually have implemented the

478
00:18:20,340 --> 00:18:22,919
variance of this scheme I don't have

479
00:18:22,919 --> 00:18:25,679
numbers on the top of my head but you

480
00:18:25,679 --> 00:18:28,200
can support very small numbers uh like

481
00:18:28,200 --> 00:18:30,840
10 attributes or like small numbers it's

482
00:18:30,840 --> 00:18:32,820
there's a polynomial somewhere inside

483
00:18:32,820 --> 00:18:37,080
and it grows rather quickly and I don't

484
00:18:37,080 --> 00:18:39,480
have numbers yeah I mean no or it's just

485
00:18:39,480 --> 00:18:41,460
like an indicator like tens or hundreds

486
00:18:41,460 --> 00:18:43,980
is okay do you remember like what sort

487
00:18:43,980 --> 00:18:45,660
of order of magnitude the number of

488
00:18:45,660 --> 00:18:49,380
authorities you managed to get was

489
00:18:49,380 --> 00:18:51,780
uh I I don't have the right answer no

490
00:18:51,780 --> 00:18:54,000
okay no worries at all but thank you

491
00:18:54,000 --> 00:18:56,900
thanks for the question

492
00:18:57,179 --> 00:18:59,340
so I have a another question related to

493
00:18:59,340 --> 00:19:01,440
efficiency can you say like more or less

494
00:19:01,440 --> 00:19:03,660
what's the price to pay compared to the

495
00:19:03,660 --> 00:19:05,880
standard dual system methodology and you

496
00:19:05,880 --> 00:19:08,340
know how does it compare with the uh

497
00:19:08,340 --> 00:19:11,520
solution with static security okay great

498
00:19:11,520 --> 00:19:12,840
question

499
00:19:12,840 --> 00:19:15,059
um so the right thing to compare to is

500
00:19:15,059 --> 00:19:17,220
the paper of local Waters that achieved

501
00:19:17,220 --> 00:19:18,539
the standard adaptive security

502
00:19:18,539 --> 00:19:20,340
definition our scheme is roughly like

503
00:19:20,340 --> 00:19:22,860
twice more expensive so we have sort of

504
00:19:22,860 --> 00:19:25,620
two copies of their scheme roughly two

505
00:19:25,620 --> 00:19:26,940
copies of their scheme and we do

506
00:19:26,940 --> 00:19:28,559
everything twice but other than that

507
00:19:28,559 --> 00:19:30,960
it's very close to the originals came

508
00:19:30,960 --> 00:19:34,860
from like 10 12 years ago thanks

509
00:19:34,860 --> 00:19:36,600
okay so if there are no more questions

510
00:19:36,600 --> 00:19:39,918
let's thank Elan again

511
00:19:44,760 --> 00:19:48,679
when we move to the next talk

512
00:20:01,260 --> 00:20:04,320
okay so the second talk is on the

513
00:20:04,320 --> 00:20:06,600
optimal succiness and efficiency of

514
00:20:06,600 --> 00:20:07,860
functional encryption and

515
00:20:07,860 --> 00:20:10,440
attribute-based encryption this is a

516
00:20:10,440 --> 00:20:14,580
word by ayush Jane ujalin and jilua

517
00:20:14,580 --> 00:20:16,260
and uh

518
00:20:16,260 --> 00:20:20,039
G is going to deliver the dog

519
00:20:20,039 --> 00:20:22,919
thanks for the introduction or the title

520
00:20:22,919 --> 00:20:25,320
of the talk is actually pretty shift

521
00:20:25,320 --> 00:20:27,600
Mount functional what's the price of

522
00:20:27,600 --> 00:20:29,760
functional encryption and this is a

523
00:20:29,760 --> 00:20:33,559
joint work with ayusha and Rachel

524
00:20:33,600 --> 00:20:36,600
so um just jumping right into the

525
00:20:36,600 --> 00:20:38,280
definition partially hiding functional

526
00:20:38,280 --> 00:20:40,559
encryption is a generalization that

527
00:20:40,559 --> 00:20:42,660
captures both functional encryption and

528
00:20:42,660 --> 00:20:44,640
attribute-based encryption in such a

529
00:20:44,640 --> 00:20:46,559
system you'll have an authority who sets

530
00:20:46,559 --> 00:20:48,240
up the system generating the mass

531
00:20:48,240 --> 00:20:50,220
Republican secret key

532
00:20:50,220 --> 00:20:53,340
and then using the map Master public key

533
00:20:53,340 --> 00:20:56,940
anyone can encrypt a private input y

534
00:20:56,940 --> 00:21:00,299
tied to a public input X

535
00:21:00,299 --> 00:21:03,240
and then for for any function The

536
00:21:03,240 --> 00:21:05,460
Authority can generate a secret key for

537
00:21:05,460 --> 00:21:07,200
that function

538
00:21:07,200 --> 00:21:10,260
and given the security for the function

539
00:21:10,260 --> 00:21:13,440
and the ciphertext you can compute the

540
00:21:13,440 --> 00:21:15,799
function applied on the private and

541
00:21:15,799 --> 00:21:19,080
public and private inputs

542
00:21:19,080 --> 00:21:22,160
and I want to mention that in in our

543
00:21:22,160 --> 00:21:25,080
formulation F and X are always provided

544
00:21:25,080 --> 00:21:27,480
in the clear because they are not hidden

545
00:21:27,480 --> 00:21:28,559
anyway

546
00:21:28,559 --> 00:21:29,880
and

547
00:21:29,880 --> 00:21:32,640
um in attribute-based encryption uh X is

548
00:21:32,640 --> 00:21:34,559
just is just going to be the attribute Y

549
00:21:34,559 --> 00:21:37,919
is going to be the message and and the

550
00:21:37,919 --> 00:21:42,480
function is Computing f p of x times Y

551
00:21:42,480 --> 00:21:44,580
and in functional encryption there's

552
00:21:44,580 --> 00:21:47,520
just no X

553
00:21:47,520 --> 00:21:50,460
and for security we want to ensure that

554
00:21:50,460 --> 00:21:53,400
any information about y Beyond f of x y

555
00:21:53,400 --> 00:21:56,100
is hidden given um

556
00:21:56,100 --> 00:21:57,960
the secret key

557
00:21:57,960 --> 00:21:59,760
and in fact this has to hold under

558
00:21:59,760 --> 00:22:02,340
collusion given arbitrarily many secret

559
00:22:02,340 --> 00:22:05,159
Keys information revealed about Y is

560
00:22:05,159 --> 00:22:08,520
exactly the computational results

561
00:22:08,520 --> 00:22:12,360
and formally this is defined by IND CPA

562
00:22:12,360 --> 00:22:14,700
security where the adversary first gets

563
00:22:14,700 --> 00:22:17,220
the master public key and then can query

564
00:22:17,220 --> 00:22:20,220
multiple functions and receive their

565
00:22:20,220 --> 00:22:24,720
secret keys and then choose one public

566
00:22:24,720 --> 00:22:27,720
input and two possible private inputs it

567
00:22:27,720 --> 00:22:29,880
gets back the ciphertext of one of them

568
00:22:29,880 --> 00:22:33,720
and then continue the key queries

569
00:22:33,720 --> 00:22:37,679
uh we require that the um the ciphertext

570
00:22:37,679 --> 00:22:40,260
of the two possible private inputs be

571
00:22:40,260 --> 00:22:42,240
indistinguishable if the private inputs

572
00:22:42,240 --> 00:22:45,659
are of the same length and their output

573
00:22:45,659 --> 00:22:49,200
are the same under those functions

574
00:22:49,200 --> 00:22:52,679
so uh what do we want for a phfe we want

575
00:22:52,679 --> 00:22:54,720
we wanted to support expressive

576
00:22:54,720 --> 00:22:58,200
functionality we want short keys and

577
00:22:58,200 --> 00:22:59,880
short ciphertext we also want fast

578
00:22:59,880 --> 00:23:02,520
encryption actually these goals are not

579
00:23:02,520 --> 00:23:05,340
disparate but closely connected you have

580
00:23:05,340 --> 00:23:08,220
to choose a correct way to express the

581
00:23:08,220 --> 00:23:09,740
functionality

582
00:23:09,740 --> 00:23:13,159
to provide the Baseline of the

583
00:23:13,159 --> 00:23:15,840
of the encoding size and the decryption

584
00:23:15,840 --> 00:23:16,620
time

585
00:23:16,620 --> 00:23:19,679
so here we aim for a ram computation

586
00:23:19,679 --> 00:23:22,020
with unbounded output length which means

587
00:23:22,020 --> 00:23:24,720
the output length could be as long as

588
00:23:24,720 --> 00:23:27,059
the computation time

589
00:23:27,059 --> 00:23:30,179
and for short keys and ciphertext I

590
00:23:30,179 --> 00:23:32,960
think the basic requirement is that

591
00:23:32,960 --> 00:23:36,419
anything is polynomial in the size that

592
00:23:36,419 --> 00:23:39,780
it encrypts or it encodes so here in in

593
00:23:39,780 --> 00:23:41,580
the poly I have augmented all

594
00:23:41,580 --> 00:23:44,340
appearances of security parameter but

595
00:23:44,340 --> 00:23:46,140
they're just there

596
00:23:46,140 --> 00:23:48,419
and for decryption we want the time to

597
00:23:48,419 --> 00:23:50,700
be polynomial in the description size as

598
00:23:50,700 --> 00:23:53,640
well as the random computation time

599
00:23:53,640 --> 00:23:55,860
however we know that polynomial

600
00:23:55,860 --> 00:23:57,600
efficiency is usually not very

601
00:23:57,600 --> 00:24:00,659
satisfactory and what we actually want

602
00:24:00,659 --> 00:24:02,460
is um

603
00:24:02,460 --> 00:24:04,440
basically as short as possible and as

604
00:24:04,440 --> 00:24:07,559
fast as as fast as possible so here the

605
00:24:07,559 --> 00:24:10,500
ideal efficiency uh that the ideal size

606
00:24:10,500 --> 00:24:12,419
efficiency is that you have constant

607
00:24:12,419 --> 00:24:16,020
size on keys and ciphertext that are

608
00:24:16,020 --> 00:24:18,120
rate one in the private input and

609
00:24:18,120 --> 00:24:21,000
constant size in public input

610
00:24:21,000 --> 00:24:24,299
so here uh recall that F and X are

611
00:24:24,299 --> 00:24:27,299
provided for free and the secret key and

612
00:24:27,299 --> 00:24:30,120
the server text do not hide F or X so

613
00:24:30,120 --> 00:24:31,799
this should be thought as a

614
00:24:31,799 --> 00:24:34,559
cryptographically binding hash of F and

615
00:24:34,559 --> 00:24:36,960
X thus they can be constant sized

616
00:24:36,960 --> 00:24:39,659
whereas for y since it's hidden it must

617
00:24:39,659 --> 00:24:42,659
be encoded directly in the ciphertext

618
00:24:42,659 --> 00:24:44,820
therefore the best we can hope for is

619
00:24:44,820 --> 00:24:46,440
rate one

620
00:24:46,440 --> 00:24:49,140
and for decryption we want it to be as

621
00:24:49,140 --> 00:24:51,299
fast as the computation itself with

622
00:24:51,299 --> 00:24:55,740
polynomial slowdown for each time step

623
00:24:55,740 --> 00:24:57,720
and in addition we also want adaptive

624
00:24:57,720 --> 00:24:59,520
security and we want to construct such

625
00:24:59,520 --> 00:25:03,559
schemes from minimal assumptions

626
00:25:03,840 --> 00:25:06,780
and in fact there has been a long line

627
00:25:06,780 --> 00:25:08,480
of research into

628
00:25:08,480 --> 00:25:13,200
each of those questions but they only

629
00:25:13,200 --> 00:25:15,360
achieve some of them but not not all of

630
00:25:15,360 --> 00:25:17,539
them

631
00:25:17,580 --> 00:25:21,240
so um the motivation or the questions of

632
00:25:21,240 --> 00:25:24,240
this work uh are the following what is

633
00:25:24,240 --> 00:25:27,419
the best possible efficiency of phev

634
00:25:27,419 --> 00:25:29,400
and are there trade-offs among different

635
00:25:29,400 --> 00:25:31,380
aspects of efficiency

636
00:25:31,380 --> 00:25:33,539
and from what assumptions can we

637
00:25:33,539 --> 00:25:37,559
construct optimally efficient phfe

638
00:25:37,559 --> 00:25:40,440
and we provide answers to all of them

639
00:25:40,440 --> 00:25:43,860
so positive results first we actually

640
00:25:43,860 --> 00:25:45,960
construct nearly optimal functional

641
00:25:45,960 --> 00:25:48,840
encryption from Ram from just functional

642
00:25:48,840 --> 00:25:51,360
encryption for circuits

643
00:25:51,360 --> 00:25:53,940
so here uh

644
00:25:53,940 --> 00:25:57,240
oh sorry no and a long line of previous

645
00:25:57,240 --> 00:26:00,299
Works shows that the so-called

646
00:26:00,299 --> 00:26:01,980
obfuscation minimum functional

647
00:26:01,980 --> 00:26:05,240
encryption which has a long

648
00:26:05,240 --> 00:26:08,340
qualifier actually implies polynomial

649
00:26:08,340 --> 00:26:09,900
and secure functional encryption for

650
00:26:09,900 --> 00:26:13,200
circuits so um if you combine our work

651
00:26:13,200 --> 00:26:15,840
with the previous works then you get the

652
00:26:15,840 --> 00:26:20,220
best phfe from any interesting Fe from

653
00:26:20,220 --> 00:26:21,600
circuits

654
00:26:21,600 --> 00:26:25,140
and here there are two little problems

655
00:26:25,140 --> 00:26:27,539
uh the first is that the ciphertext is

656
00:26:27,539 --> 00:26:30,360
rate 2 in the private input the second

657
00:26:30,360 --> 00:26:32,960
is that the decryption time additionally

658
00:26:32,960 --> 00:26:35,820
uh is linear in

659
00:26:35,820 --> 00:26:40,020
the the description size of f x and y

660
00:26:40,020 --> 00:26:42,480
and it turns out the second problem is

661
00:26:42,480 --> 00:26:45,240
either necessary or it contains a

662
00:26:45,240 --> 00:26:48,960
technical barrier let me elaborate

663
00:26:48,960 --> 00:26:52,320
oh sorry before I elaborate let me show

664
00:26:52,320 --> 00:26:56,220
some related works on Fe so the only

665
00:26:56,220 --> 00:26:58,980
previous were constructing Fe for Ram is

666
00:26:58,980 --> 00:27:01,760
this acfq in

667
00:27:01,760 --> 00:27:04,799
Asia Crypt

668
00:27:04,799 --> 00:27:07,919
and then there are a bunch of Fe for

669
00:27:07,919 --> 00:27:10,020
Turing machines and a bunch of Fe for

670
00:27:10,020 --> 00:27:13,080
circuits and

671
00:27:13,080 --> 00:27:15,480
for most of the schemes you can see that

672
00:27:15,480 --> 00:27:18,299
we improve from polynomial to nearly

673
00:27:18,299 --> 00:27:22,559
optimal efficiency and there are

674
00:27:22,559 --> 00:27:26,700
two clouds of our skin the first one is

675
00:27:26,700 --> 00:27:29,580
that the work by gwz actually is rate

676
00:27:29,580 --> 00:27:32,340
one in the private input and it turns

677
00:27:32,340 --> 00:27:34,919
out that if we abandon adaptive security

678
00:27:34,919 --> 00:27:37,799
and long output then we can also achieve

679
00:27:37,799 --> 00:27:39,000
rate one

680
00:27:39,000 --> 00:27:42,779
and the other one is um about the

681
00:27:42,779 --> 00:27:44,220
dependency on the description

682
00:27:44,220 --> 00:27:48,600
description size in the decryption time

683
00:27:48,600 --> 00:27:52,140
and here comes our first negative result

684
00:27:52,140 --> 00:27:55,620
is uh unconditional space-time

685
00:27:55,620 --> 00:27:58,980
trade-offs for phfe

686
00:27:58,980 --> 00:28:01,799
and it says that if you have a phf

687
00:28:01,799 --> 00:28:05,940
scheme whose secret key size is f to the

688
00:28:05,940 --> 00:28:08,940
a for some exponent a and the decision

689
00:28:08,940 --> 00:28:12,179
time is f to the B then either a is

690
00:28:12,179 --> 00:28:13,919
greater than or equal to 1 or B is

691
00:28:13,919 --> 00:28:15,600
greater than Uber to one

692
00:28:15,600 --> 00:28:19,679
and the similar thing holds for X the

693
00:28:19,679 --> 00:28:21,059
public input

694
00:28:21,059 --> 00:28:22,860
so the ciphertext and the decryption

695
00:28:22,860 --> 00:28:26,520
time cannot both be sub-linear in the

696
00:28:26,520 --> 00:28:29,820
description size of the public input

697
00:28:29,820 --> 00:28:31,860
and this just tells us that component

698
00:28:31,860 --> 00:28:34,559
size and decryption time cannot both be

699
00:28:34,559 --> 00:28:36,840
super linear in F and X

700
00:28:36,840 --> 00:28:39,720
and this results this result actually

701
00:28:39,720 --> 00:28:42,120
holds for very selective one key one

702
00:28:42,120 --> 00:28:46,620
ciphertext secret key scheme or garbling

703
00:28:46,620 --> 00:28:49,620
and the functionality used to prove

704
00:28:49,620 --> 00:28:51,779
these lower bounds are really simple so

705
00:28:51,779 --> 00:28:54,980
it's a very strong one

706
00:28:55,380 --> 00:28:58,200
uh now we have known that for f and X

707
00:28:58,200 --> 00:29:00,539
it's not possible to have both sublinear

708
00:29:00,539 --> 00:29:04,140
component sizes and decryption time we

709
00:29:04,140 --> 00:29:08,340
ask what about Y and what if we uh

710
00:29:08,340 --> 00:29:11,220
choose to have linear size components in

711
00:29:11,220 --> 00:29:13,860
exchange of optimal decryption time it

712
00:29:13,860 --> 00:29:15,659
turns out that there is a connection to

713
00:29:15,659 --> 00:29:17,880
a double efficient private information

714
00:29:17,880 --> 00:29:19,860
retrieval

715
00:29:19,860 --> 00:29:21,779
so let me first Define double efficient

716
00:29:21,779 --> 00:29:24,179
private information retrieval and you'll

717
00:29:24,179 --> 00:29:25,820
have a database

718
00:29:25,820 --> 00:29:29,220
and you can apply a pre-processing

719
00:29:29,220 --> 00:29:31,260
procedure to this database to obtain a

720
00:29:31,260 --> 00:29:34,260
preprocessed database detailed and a key

721
00:29:34,260 --> 00:29:35,820
k

722
00:29:35,820 --> 00:29:38,520
and then using the key you can issue a

723
00:29:38,520 --> 00:29:42,539
query to some index so the ciphertext

724
00:29:42,539 --> 00:29:44,640
should be thought as encrypting the

725
00:29:44,640 --> 00:29:46,380
index I

726
00:29:46,380 --> 00:29:49,700
and then using the ciphertext and the

727
00:29:49,700 --> 00:29:51,899
pre-processed database you can create a

728
00:29:51,899 --> 00:29:56,460
response which will review on d sub I

729
00:29:56,460 --> 00:29:59,520
so it's w efficient because there's

730
00:29:59,520 --> 00:30:02,340
client efficiency where the key size

731
00:30:02,340 --> 00:30:04,740
should be constant and the query time

732
00:30:04,740 --> 00:30:07,559
should be sub linear in the database

733
00:30:07,559 --> 00:30:11,159
size and server efficiency says that the

734
00:30:11,159 --> 00:30:13,320
responding the response time should be

735
00:30:13,320 --> 00:30:15,720
sub-linear in the

736
00:30:15,720 --> 00:30:18,480
uh in the database size

737
00:30:18,480 --> 00:30:20,399
and for security

738
00:30:20,399 --> 00:30:23,700
um we require that the process database

739
00:30:23,700 --> 00:30:26,940
and the ciphertext hides the indices of

740
00:30:26,940 --> 00:30:28,919
queries

741
00:30:28,919 --> 00:30:31,140
and of course the dream efficiency is

742
00:30:31,140 --> 00:30:35,399
that the detail that is linear has

743
00:30:35,399 --> 00:30:37,799
linear size in D and the query time and

744
00:30:37,799 --> 00:30:41,279
response time are constant

745
00:30:41,279 --> 00:30:44,640
and is such a depr known well it's

746
00:30:44,640 --> 00:30:47,880
complicated and I won't have time to go

747
00:30:47,880 --> 00:30:50,760
into this issue in this talk

748
00:30:50,760 --> 00:30:53,700
and so our second set of negative

749
00:30:53,700 --> 00:30:58,320
results or connections is that optimal

750
00:30:58,320 --> 00:31:00,600
decision time implies a double efficient

751
00:31:00,600 --> 00:31:03,299
private information retrieval

752
00:31:03,299 --> 00:31:05,520
so um

753
00:31:05,520 --> 00:31:08,580
suppose you have ciphertext that's

754
00:31:08,580 --> 00:31:09,960
um

755
00:31:09,960 --> 00:31:12,899
that's x to the a in the public input

756
00:31:12,899 --> 00:31:15,120
and the equivalent time is sublinear in

757
00:31:15,120 --> 00:31:19,140
X or you can exchange X for y then you

758
00:31:19,140 --> 00:31:22,159
can obtain secret key depir

759
00:31:22,159 --> 00:31:24,659
whose efficiency will depend on the

760
00:31:24,659 --> 00:31:27,179
exponent's A and B

761
00:31:27,179 --> 00:31:29,520
and the same result is essentially also

762
00:31:29,520 --> 00:31:32,100
proven in acfq and the new result in

763
00:31:32,100 --> 00:31:35,960
this work is that if you have

764
00:31:35,960 --> 00:31:39,600
schemes that are that have F to the a

765
00:31:39,600 --> 00:31:41,760
dependency in the secret key and

766
00:31:41,760 --> 00:31:44,940
sub-linear dependency in the decision

767
00:31:44,940 --> 00:31:47,520
time then you can obtain a public key

768
00:31:47,520 --> 00:31:50,120
DPR

769
00:31:51,120 --> 00:31:55,080
and in addition to the Fe result we also

770
00:31:55,080 --> 00:31:57,659
obtain constant overhead IO for Ram and

771
00:31:57,659 --> 00:32:00,600
attribute based encryption for Ram

772
00:32:00,600 --> 00:32:02,659
so basically sub linear

773
00:32:02,659 --> 00:32:04,440
sub-exponentially secure functional

774
00:32:04,440 --> 00:32:06,919
encryption for circuits will imply

775
00:32:06,919 --> 00:32:09,120
sub-exponentially secure i o for Ram

776
00:32:09,120 --> 00:32:10,740
with um

777
00:32:10,740 --> 00:32:14,580
the obfuscated program being rate 2 in

778
00:32:14,580 --> 00:32:17,279
the program itself

779
00:32:17,279 --> 00:32:20,399
and previously this was on so the rate 2

780
00:32:20,399 --> 00:32:22,080
authentication was only known for

781
00:32:22,080 --> 00:32:25,799
circuits or 20 machines

782
00:32:25,799 --> 00:32:29,279
and for Abe directly from thfe we have

783
00:32:29,279 --> 00:32:32,279
constant size keys and ciphertexts and

784
00:32:32,279 --> 00:32:34,500
the decryption time being linear in both

785
00:32:34,500 --> 00:32:37,919
the running time of the RAM and the

786
00:32:37,919 --> 00:32:40,460
description size of FNX

787
00:32:40,460 --> 00:32:42,779
and we can also tweak our construction

788
00:32:42,779 --> 00:32:47,340
to to move the dependency on F and x uh

789
00:32:47,340 --> 00:32:50,039
between the cipher between the sizes and

790
00:32:50,039 --> 00:32:51,419
the time

791
00:32:51,419 --> 00:32:54,539
and all of these results are unknown

792
00:32:54,539 --> 00:32:57,240
previously

793
00:32:57,240 --> 00:32:59,820
and it's thus natural to ask whether we

794
00:32:59,820 --> 00:33:02,340
can obtain the dream efficiency for Abe

795
00:33:02,340 --> 00:33:04,919
because the previous lower bound only

796
00:33:04,919 --> 00:33:09,659
holds for a phfe with functionality

797
00:33:09,659 --> 00:33:11,700
that's stronger than Abe

798
00:33:11,700 --> 00:33:14,539
it turns out the answer is no

799
00:33:14,539 --> 00:33:17,700
let me summarize where we stand now for

800
00:33:17,700 --> 00:33:19,980
the efficiency of partially hiding

801
00:33:19,980 --> 00:33:21,559
functional encryption

802
00:33:21,559 --> 00:33:24,960
we know that why independent decryption

803
00:33:24,960 --> 00:33:28,320
time is morally equivalent to depr

804
00:33:28,320 --> 00:33:31,500
and the dependency of F and X

805
00:33:31,500 --> 00:33:33,299
characterized by this work can be

806
00:33:33,299 --> 00:33:35,340
summarized in this uh

807
00:33:35,340 --> 00:33:37,980
little diagram where we have the time

808
00:33:37,980 --> 00:33:41,039
exponent and the size size exponent the

809
00:33:41,039 --> 00:33:43,620
negative result says that this square is

810
00:33:43,620 --> 00:33:45,000
impossible

811
00:33:45,000 --> 00:33:48,240
and we achieved the area where the time

812
00:33:48,240 --> 00:33:50,460
exponent is at least one

813
00:33:50,460 --> 00:33:52,500
and the

814
00:33:52,500 --> 00:33:55,320
um the area where the size exponent is

815
00:33:55,320 --> 00:33:57,980
at least one but has small time exponent

816
00:33:57,980 --> 00:34:02,580
uh is barrier by the epr

817
00:34:02,580 --> 00:34:04,320
and for Abe

818
00:34:04,320 --> 00:34:05,880
um

819
00:34:05,880 --> 00:34:10,139
uh the dependency on F and X is also can

820
00:34:10,139 --> 00:34:11,820
be characterized using this diagram

821
00:34:11,820 --> 00:34:14,760
where we have we have this triangle area

822
00:34:14,760 --> 00:34:18,300
that's shown to be impossible in another

823
00:34:18,300 --> 00:34:19,918
work of mine

824
00:34:19,918 --> 00:34:23,879
and then we achieve a the two extremes

825
00:34:23,879 --> 00:34:26,879
of this triangle where the size is uh

826
00:34:26,879 --> 00:34:29,399
one and time exponent is zero or the

827
00:34:29,399 --> 00:34:31,800
time is one and the size is zero and

828
00:34:31,800 --> 00:34:34,560
this other triangle area remains unknown

829
00:34:34,560 --> 00:34:36,918
to us

830
00:34:37,679 --> 00:34:40,020
okay so now come to the technical part

831
00:34:40,020 --> 00:34:43,320
let me sketch the unconditional lower

832
00:34:43,320 --> 00:34:46,440
bound proof for you so suppose now that

833
00:34:46,440 --> 00:34:49,619
the secret key size is f to the A and

834
00:34:49,619 --> 00:34:52,020
the decryption time is f to the B and A

835
00:34:52,020 --> 00:34:54,899
B are smaller than one

836
00:34:54,899 --> 00:34:57,960
and I will choose such functions so here

837
00:34:57,960 --> 00:35:00,240
the function is described by a very long

838
00:35:00,240 --> 00:35:03,420
random string r and there's no public

839
00:35:03,420 --> 00:35:06,480
input and there are two possible

840
00:35:06,480 --> 00:35:09,060
variants of private inputs the first one

841
00:35:09,060 --> 00:35:13,079
is you have an index set I and a

842
00:35:13,079 --> 00:35:14,700
one-time path w

843
00:35:14,700 --> 00:35:16,740
and the second case is that you have

844
00:35:16,740 --> 00:35:19,800
just output Z

845
00:35:19,800 --> 00:35:23,160
and the function applies to this private

846
00:35:23,160 --> 00:35:27,720
input is either R sub I xor with W or

847
00:35:27,720 --> 00:35:30,259
just Z

848
00:35:31,280 --> 00:35:35,280
now we choose a little n such that

849
00:35:35,280 --> 00:35:38,400
capital N to the A and capital N to the

850
00:35:38,400 --> 00:35:41,160
B is much smaller than a little n and n

851
00:35:41,160 --> 00:35:43,320
is much more than capital n

852
00:35:43,320 --> 00:35:46,140
so that the secret key size is much

853
00:35:46,140 --> 00:35:48,619
smaller than the

854
00:35:48,619 --> 00:35:50,700
basically the running time of the

855
00:35:50,700 --> 00:35:53,339
machine and then the decryption time is

856
00:35:53,339 --> 00:35:56,180
much smaller than the

857
00:35:56,180 --> 00:35:59,339
the description size of f which is the

858
00:35:59,339 --> 00:36:02,299
dominant Factor here

859
00:36:03,060 --> 00:36:06,180
and now the adversary will choose a

860
00:36:06,180 --> 00:36:10,020
random index set and random one-time pad

861
00:36:10,020 --> 00:36:12,599
and choose that to be the the right

862
00:36:12,599 --> 00:36:16,020
answer so that the its queries are

863
00:36:16,020 --> 00:36:18,000
admissible

864
00:36:18,000 --> 00:36:19,820
and the the

865
00:36:19,820 --> 00:36:22,800
adversary will try to decrypt the

866
00:36:22,800 --> 00:36:24,960
challenge ciphertext with the secret key

867
00:36:24,960 --> 00:36:28,500
it receives and see how much of R sub I

868
00:36:28,500 --> 00:36:31,980
will decryption read

869
00:36:31,980 --> 00:36:34,619
um from this um

870
00:36:34,619 --> 00:36:36,599
from this art that's given random access

871
00:36:36,599 --> 00:36:39,140
to it

872
00:36:40,020 --> 00:36:43,859
now let's analyze the two cases when Y

873
00:36:43,859 --> 00:36:46,500
is in the form of IW

874
00:36:46,500 --> 00:36:48,480
the secret key and the ciphertext

875
00:36:48,480 --> 00:36:50,700
contains much much less

876
00:36:50,700 --> 00:36:54,839
of nbits of R sub I which itself is

877
00:36:54,839 --> 00:36:58,560
embeds therefore the decision algorithm

878
00:36:58,560 --> 00:37:02,400
will have to read almost all of R sub I

879
00:37:02,400 --> 00:37:04,940
and this can be formalized using an

880
00:37:04,940 --> 00:37:08,040
incompressibility argument

881
00:37:08,040 --> 00:37:11,220
when Y is just z

882
00:37:11,220 --> 00:37:12,480
um

883
00:37:12,480 --> 00:37:16,140
the secret key and the ciphertext and R

884
00:37:16,140 --> 00:37:19,560
contains no information about I

885
00:37:19,560 --> 00:37:24,000
um because I only appears in Z as R sub

886
00:37:24,000 --> 00:37:28,460
I X or W and it's one time padded by w

887
00:37:28,460 --> 00:37:32,160
therefore it can only read a tiny

888
00:37:32,160 --> 00:37:33,960
portion of RI because you cannot guess

889
00:37:33,960 --> 00:37:36,320
where I is

890
00:37:36,320 --> 00:37:39,060
and this will give us a high Advantage

891
00:37:39,060 --> 00:37:41,099
graph does prove that the skin cannot be

892
00:37:41,099 --> 00:37:44,579
secure if it has both sub-linear size

893
00:37:44,579 --> 00:37:47,220
and sublinear time

894
00:37:47,220 --> 00:37:51,960
and the second thing I want to uh

895
00:37:51,960 --> 00:37:54,119
given this target is the proof sketch of

896
00:37:54,119 --> 00:37:57,200
the technical barrier of the PIR

897
00:37:57,200 --> 00:38:00,180
suppose the secret key is now F to the A

898
00:38:00,180 --> 00:38:02,940
and the decision time is f to the B with

899
00:38:02,940 --> 00:38:05,940
B less than one

900
00:38:05,940 --> 00:38:09,720
uh to implement a depr the simplest way

901
00:38:09,720 --> 00:38:12,180
is just to let the function be described

902
00:38:12,180 --> 00:38:15,660
by the database and the Y the private

903
00:38:15,660 --> 00:38:18,000
input is the index that I want to query

904
00:38:18,000 --> 00:38:22,680
and f of x y is just going to be d sub I

905
00:38:22,680 --> 00:38:26,220
and for the depr the pre-processed

906
00:38:26,220 --> 00:38:27,540
database is just going to be the

907
00:38:27,540 --> 00:38:29,880
database itself plus the functional

908
00:38:29,880 --> 00:38:31,440
encryption secret key

909
00:38:31,440 --> 00:38:33,720
and the key will be the functional

910
00:38:33,720 --> 00:38:37,819
encryption Master public key

911
00:38:37,859 --> 00:38:40,020
and to query we just generate a

912
00:38:40,020 --> 00:38:42,240
functional encryption secret key for the

913
00:38:42,240 --> 00:38:43,260
index

914
00:38:43,260 --> 00:38:47,339
and to respond we just do the decryption

915
00:38:47,339 --> 00:38:49,500
and I want to mention that this the

916
00:38:49,500 --> 00:38:50,940
scheme that we obtain from this

917
00:38:50,940 --> 00:38:53,099
transformation is indistinguishability

918
00:38:53,099 --> 00:38:55,619
based secure and is selective and is not

919
00:38:55,619 --> 00:38:58,440
output hiding and it's also not database

920
00:38:58,440 --> 00:39:02,220
hiding however we can

921
00:39:02,220 --> 00:39:05,040
apply generic efficiency preserving

922
00:39:05,040 --> 00:39:07,220
transformation to obtain the strongest

923
00:39:07,220 --> 00:39:11,299
version of security possible

924
00:39:11,520 --> 00:39:13,740
and lastly I want to

925
00:39:13,740 --> 00:39:17,640
um show you the core of our phfe which

926
00:39:17,640 --> 00:39:21,359
is a new notion of garbling for Ram

927
00:39:21,359 --> 00:39:23,460
you know to achieve something you have

928
00:39:23,460 --> 00:39:24,900
to first formulate the right definition

929
00:39:24,900 --> 00:39:26,940
and the second step is to achieve this

930
00:39:26,940 --> 00:39:28,980
definition but we won't have time to

931
00:39:28,980 --> 00:39:30,660
achieve it in this talk so I'll just

932
00:39:30,660 --> 00:39:32,220
show you the definition

933
00:39:32,220 --> 00:39:34,980
in our model of ram we have multiple

934
00:39:34,980 --> 00:39:38,760
tapes there's input tape for f for

935
00:39:38,760 --> 00:39:41,520
example and in input type for D where D

936
00:39:41,520 --> 00:39:44,760
can contain the public or private input

937
00:39:44,760 --> 00:39:47,880
and there's also a working tape

938
00:39:47,880 --> 00:39:51,599
the step circuit on will take in the old

939
00:39:51,599 --> 00:39:54,480
step State and the previous read and

940
00:39:54,480 --> 00:39:56,820
output the new state and next read write

941
00:39:56,820 --> 00:40:00,680
and the output for this time step

942
00:40:00,680 --> 00:40:04,800
and and the memory operation can happen

943
00:40:04,800 --> 00:40:08,280
over any tape and the new state will

944
00:40:08,280 --> 00:40:10,140
transfer to the Old State for the next

945
00:40:10,140 --> 00:40:12,300
step

946
00:40:12,300 --> 00:40:15,060
in our notion of laconic cardboard Ram

947
00:40:15,060 --> 00:40:18,300
we first the first step is to compress

948
00:40:18,300 --> 00:40:20,040
the the tapes

949
00:40:20,040 --> 00:40:22,619
to obtain a short digest which are of

950
00:40:22,619 --> 00:40:24,780
constant size

951
00:40:24,780 --> 00:40:28,020
and then we apply the goblin procedure

952
00:40:28,020 --> 00:40:30,839
to the Run step circuit to obtain a

953
00:40:30,839 --> 00:40:32,520
garbled Ram

954
00:40:32,520 --> 00:40:36,859
and lastly using the the tape content

955
00:40:36,859 --> 00:40:39,420
together with the cardboard Ram we can

956
00:40:39,420 --> 00:40:43,680
compute the output of this Ram

957
00:40:43,680 --> 00:40:47,579
in time does t plus and input tape sizes

958
00:40:47,579 --> 00:40:51,540
times the a polynomial in the Ram

959
00:40:51,540 --> 00:40:53,820
machine

960
00:40:53,820 --> 00:40:55,460
and

961
00:40:55,460 --> 00:40:58,380
those digests should be reusable and I

962
00:40:58,380 --> 00:41:00,119
want to mention that here security is

963
00:41:00,119 --> 00:41:02,040
indistinguishability base instead of

964
00:41:02,040 --> 00:41:04,619
simulation based which is very important

965
00:41:04,619 --> 00:41:08,220
for nearly optimal efficiency

966
00:41:08,220 --> 00:41:11,460
okay let me summarize uh with some open

967
00:41:11,460 --> 00:41:14,160
questions what's next for on functional

968
00:41:14,160 --> 00:41:15,480
encryption and attribute based

969
00:41:15,480 --> 00:41:18,420
encryption so on the concrete front we

970
00:41:18,420 --> 00:41:20,880
wonder whether we can construct phfe

971
00:41:20,880 --> 00:41:24,060
with optimal decryption time from or

972
00:41:24,060 --> 00:41:28,020
construct during the epir

973
00:41:28,020 --> 00:41:30,240
and also we wonder whether we can

974
00:41:30,240 --> 00:41:32,300
achieve rate one in the private input

975
00:41:32,300 --> 00:41:34,980
with either adaptive security or long

976
00:41:34,980 --> 00:41:36,960
output

977
00:41:36,960 --> 00:41:39,660
and on the more

978
00:41:39,660 --> 00:41:42,300
on conceptual level we wonder whether

979
00:41:42,300 --> 00:41:44,520
there's a tight relation between optimal

980
00:41:44,520 --> 00:41:46,940
decryption time and DPR

981
00:41:46,940 --> 00:41:49,440
the thing is that we know functional

982
00:41:49,440 --> 00:41:51,359
encryption for circuits plus public key

983
00:41:51,359 --> 00:41:54,780
DPR implies optimal decryption time

984
00:41:54,780 --> 00:41:58,440
but that only implies secret key dpir as

985
00:41:58,440 --> 00:41:59,579
far as We Know

986
00:41:59,579 --> 00:42:01,440
so the question is does whether we can

987
00:42:01,440 --> 00:42:03,619
achieve optimal decryption time on

988
00:42:03,619 --> 00:42:06,960
private and public input given just

989
00:42:06,960 --> 00:42:09,300
secret key DPR

990
00:42:09,300 --> 00:42:12,720
and then the next question is just

991
00:42:12,720 --> 00:42:15,359
pinning down the exact priority Frontier

992
00:42:15,359 --> 00:42:17,760
of efficiency efficiency for functional

993
00:42:17,760 --> 00:42:19,140
encryption and attribute-based

994
00:42:19,140 --> 00:42:22,020
encryption namely to resolve the stripe

995
00:42:22,020 --> 00:42:23,160
area

996
00:42:23,160 --> 00:42:25,740
and with that I'll

997
00:42:25,740 --> 00:42:28,380
handmade heart and I want to mention

998
00:42:28,380 --> 00:42:30,540
that the preceding version and the

999
00:42:30,540 --> 00:42:33,720
current e-print are kind of out of date

1000
00:42:33,720 --> 00:42:36,359
and will revise them soon

1001
00:42:36,359 --> 00:42:37,440
thank you

1002
00:42:37,440 --> 00:42:43,500
[Applause]

1003
00:42:43,500 --> 00:42:47,359
so we have time for one week question

1004
00:42:49,680 --> 00:42:51,480
okay if there is no question we'll

1005
00:42:51,480 --> 00:42:53,160
proceed to the next talk

1006
00:42:53,160 --> 00:42:56,570
and let's thank the speaker again

1007
00:42:56,570 --> 00:43:01,590
[Applause]

1008
00:43:24,480 --> 00:43:27,300
okay so the next paper of this session

1009
00:43:27,300 --> 00:43:29,700
is register attribute based encryption

1010
00:43:29,700 --> 00:43:32,280
uh it's a word by susano and Berger

1011
00:43:32,280 --> 00:43:35,700
George Liu brand Waters and David Wu and

1012
00:43:35,700 --> 00:43:37,980
George is going to keep the top

1013
00:43:37,980 --> 00:43:41,040
hello I'm George Lou and I I'll be

1014
00:43:41,040 --> 00:43:42,720
talking about our work on registered

1015
00:43:42,720 --> 00:43:44,700
attribute based encryption

1016
00:43:44,700 --> 00:43:47,880
so uh hopefully you guys aren't tired of

1017
00:43:47,880 --> 00:43:49,700
hearing about definition

1018
00:43:49,700 --> 00:43:52,020
the definition of attribute based

1019
00:43:52,020 --> 00:43:54,180
encryption because uh well you're about

1020
00:43:54,180 --> 00:43:56,300
to hear it again so

1021
00:43:56,300 --> 00:43:58,200
attribute-based encryption was you know

1022
00:43:58,200 --> 00:44:02,160
introduced in 2005 and the basic idea

1023
00:44:02,160 --> 00:44:04,140
here right is that you have

1024
00:44:04,140 --> 00:44:07,440
a central Authority which issues uh user

1025
00:44:07,440 --> 00:44:09,060
secret Keys which have which have

1026
00:44:09,060 --> 00:44:11,339
various attributes

1027
00:44:11,339 --> 00:44:14,520
and when the equip when an encryptor

1028
00:44:14,520 --> 00:44:16,200
wants to generate a cycle protect they

1029
00:44:16,200 --> 00:44:18,900
can encode a policy and

1030
00:44:18,900 --> 00:44:22,380
if a user has a has an attribute has

1031
00:44:22,380 --> 00:44:24,540
attribute key has an attribute key which

1032
00:44:24,540 --> 00:44:26,760
satisfies that policy they're able to

1033
00:44:26,760 --> 00:44:29,280
read the message but otherwise even if

1034
00:44:29,280 --> 00:44:31,680
you have multiple occluding users

1035
00:44:31,680 --> 00:44:32,760
um

1036
00:44:32,760 --> 00:44:34,920
which may like have in combination the

1037
00:44:34,920 --> 00:44:36,839
correct attributes they should not be

1038
00:44:36,839 --> 00:44:40,319
able to decrypt this message

1039
00:44:40,319 --> 00:44:42,060
now

1040
00:44:42,060 --> 00:44:43,920
attribute encryption is great there's

1041
00:44:43,920 --> 00:44:45,420
been like a lot of there's been many

1042
00:44:45,420 --> 00:44:46,800
many Works

1043
00:44:46,800 --> 00:44:48,540
um you know constructing attribute based

1044
00:44:48,540 --> 00:44:51,780
encryption in various settings but

1045
00:44:51,780 --> 00:44:53,640
one sort of

1046
00:44:53,640 --> 00:44:55,920
practical downside of attribute-based

1047
00:44:55,920 --> 00:44:57,780
encryption is this presence of this

1048
00:44:57,780 --> 00:45:00,720
Central Authority and in particular

1049
00:45:00,720 --> 00:45:03,060
it's the fact that the central Authority

1050
00:45:03,060 --> 00:45:05,880
needs to keep a master secret key around

1051
00:45:05,880 --> 00:45:08,220
and this persistent secret like you know

1052
00:45:08,220 --> 00:45:10,380
opens up a lot of

1053
00:45:10,380 --> 00:45:13,460
sort of downsides in terms of when

1054
00:45:13,460 --> 00:45:15,180
attribute-based encryption is actually

1055
00:45:15,180 --> 00:45:16,440
usable

1056
00:45:16,440 --> 00:45:20,339
so you know your people are often you

1057
00:45:20,339 --> 00:45:21,660
know you'd be the central Authority is

1058
00:45:21,660 --> 00:45:23,579
like the central point of failure

1059
00:45:23,579 --> 00:45:27,000
so there's always a fear that either you

1060
00:45:27,000 --> 00:45:29,460
know the Cur The Authority themselves is

1061
00:45:29,460 --> 00:45:33,480
corrupt or the the master secret key at

1062
00:45:33,480 --> 00:45:34,560
some point

1063
00:45:34,560 --> 00:45:37,560
um gets stolen which you know is which

1064
00:45:37,560 --> 00:45:39,960
happens many times in sort of like real

1065
00:45:39,960 --> 00:45:42,540
world security breaches I guess a

1066
00:45:42,540 --> 00:45:44,940
one-touch example it would be like the

1067
00:45:44,940 --> 00:45:47,400
RSA secure ID breach

1068
00:45:47,400 --> 00:45:49,680
and in this case you know you as a user

1069
00:45:49,680 --> 00:45:52,140
may have like done nothing wrong you you

1070
00:45:52,140 --> 00:45:55,440
know you keep your own like secret key

1071
00:45:55,440 --> 00:45:57,839
safe but like all of a sudden you're

1072
00:45:57,839 --> 00:45:59,640
like you're this entire system is now

1073
00:45:59,640 --> 00:46:01,560
broken right

1074
00:46:01,560 --> 00:46:04,859
so to

1075
00:46:04,859 --> 00:46:07,980
a workaround of this of this problem or

1076
00:46:07,980 --> 00:46:09,480
I guess like a solution to this problem

1077
00:46:09,480 --> 00:46:11,880
was this notion of registration based

1078
00:46:11,880 --> 00:46:13,260
encryption

1079
00:46:13,260 --> 00:46:16,680
where instead of having a central

1080
00:46:16,680 --> 00:46:18,960
authority issue the key there's instead

1081
00:46:18,960 --> 00:46:21,480
this key curator which

1082
00:46:21,480 --> 00:46:23,660
takes in the public keys of individuals

1083
00:46:23,660 --> 00:46:27,240
and sort of curates it into a master

1084
00:46:27,240 --> 00:46:29,940
public key and as more individuals join

1085
00:46:29,940 --> 00:46:32,819
the system they update the master public

1086
00:46:32,819 --> 00:46:34,079
key

1087
00:46:34,079 --> 00:46:38,099
and if a if any user wants to send a

1088
00:46:38,099 --> 00:46:40,020
message they can simply just look at the

1089
00:46:40,020 --> 00:46:43,500
master public key and use that to

1090
00:46:43,500 --> 00:46:46,380
send messages to the user

1091
00:46:46,380 --> 00:46:49,280
so

1092
00:46:49,500 --> 00:46:52,040
so because because this key is being

1093
00:46:52,040 --> 00:46:54,839
being sort of incrementally updated we

1094
00:46:54,839 --> 00:46:58,140
also require we also allow the

1095
00:46:58,140 --> 00:47:01,260
curator to send Dax some public helper

1096
00:47:01,260 --> 00:47:03,780
decryption information

1097
00:47:03,780 --> 00:47:06,660
and this sort of solves a problem of

1098
00:47:06,660 --> 00:47:09,119
this key exploitation or like Ki Escrow

1099
00:47:09,119 --> 00:47:10,680
because there isn't a master secret

1100
00:47:10,680 --> 00:47:13,980
right the key curator uh sort of in

1101
00:47:13,980 --> 00:47:16,319
contrast to the

1102
00:47:16,319 --> 00:47:18,720
to the central Authority is like

1103
00:47:18,720 --> 00:47:21,119
completely deterministic and has no like

1104
00:47:21,119 --> 00:47:23,880
keeps no secret State at all so they

1105
00:47:23,880 --> 00:47:27,500
could it's essentially a public function

1106
00:47:27,900 --> 00:47:29,640
based on just what I've told you so far

1107
00:47:29,640 --> 00:47:31,319
there's actually like a trivial way to

1108
00:47:31,319 --> 00:47:34,560
satisfy this right which is just to have

1109
00:47:34,560 --> 00:47:36,660
each individual generate their own

1110
00:47:36,660 --> 00:47:39,060
public key encryption public key

1111
00:47:39,060 --> 00:47:41,099
encryption key and just send that to the

1112
00:47:41,099 --> 00:47:43,680
key curator and the key curator can just

1113
00:47:43,680 --> 00:47:46,260
curate their keys by sort of adding them

1114
00:47:46,260 --> 00:47:48,300
to a list and

1115
00:47:48,300 --> 00:47:50,640
in some sense this is kind of like the

1116
00:47:50,640 --> 00:47:53,400
like trust model we want to

1117
00:47:53,400 --> 00:47:56,220
we want to achieve but you know to make

1118
00:47:56,220 --> 00:47:57,960
this sort of a interesting like

1119
00:47:57,960 --> 00:48:01,500
non-trivial concept for rbe we also we

1120
00:48:01,500 --> 00:48:05,099
require that the master public key

1121
00:48:05,099 --> 00:48:07,680
um is succinct so it's independent of

1122
00:48:07,680 --> 00:48:11,118
the number of users that join the system

1123
00:48:11,579 --> 00:48:15,420
just uh you know further explicitly

1124
00:48:15,420 --> 00:48:17,099
compare these two

1125
00:48:17,099 --> 00:48:20,700
uh the central Authority and key curator

1126
00:48:20,700 --> 00:48:23,420
sort of play both play the same role of

1127
00:48:23,420 --> 00:48:26,400
compress producing this compressed uh

1128
00:48:26,400 --> 00:48:28,920
public key

1129
00:48:28,920 --> 00:48:32,880
but the primary upside is that the your

1130
00:48:32,880 --> 00:48:34,440
key curator

1131
00:48:34,440 --> 00:48:36,540
has no secret state right as sort of as

1132
00:48:36,540 --> 00:48:39,900
I've said uh but a slight downside of

1133
00:48:39,900 --> 00:48:41,880
course is that they do require there

1134
00:48:41,880 --> 00:48:44,339
does when these are constructed there

1135
00:48:44,339 --> 00:48:46,079
there will be some interaction that's

1136
00:48:46,079 --> 00:48:48,480
required

1137
00:48:48,480 --> 00:48:51,960
so we Define registered attribute-based

1138
00:48:51,960 --> 00:48:54,359
encryption which

1139
00:48:54,359 --> 00:48:57,000
if you which is essentially what you'd

1140
00:48:57,000 --> 00:48:59,099
what you'd imagine it to be it's the

1141
00:48:59,099 --> 00:49:01,040
notion of registration based encryption

1142
00:49:01,040 --> 00:49:03,660
with the functionality of

1143
00:49:03,660 --> 00:49:06,300
attribute-based encryption right so in

1144
00:49:06,300 --> 00:49:07,740
traditional registration based

1145
00:49:07,740 --> 00:49:10,740
encryption the users just send an

1146
00:49:10,740 --> 00:49:14,760
identity to the key curator but in

1147
00:49:14,760 --> 00:49:16,339
registered attribute based encryption

1148
00:49:16,339 --> 00:49:19,859
they register with a set of attributes

1149
00:49:19,859 --> 00:49:22,380
instead

1150
00:49:22,380 --> 00:49:23,520
so

1151
00:49:23,520 --> 00:49:26,339
in terms of our results we have two

1152
00:49:26,339 --> 00:49:29,400
constructions the first one is we

1153
00:49:29,400 --> 00:49:32,819
construct registered Abe for an operator

1154
00:49:32,819 --> 00:49:35,460
rebounded number of users from composite

1155
00:49:35,460 --> 00:49:37,920
order bilinear groups and this supports

1156
00:49:37,920 --> 00:49:40,020
monotone Boolean formulas

1157
00:49:40,020 --> 00:49:43,680
and we also construct register unbounded

1158
00:49:43,680 --> 00:49:48,740
registered Abe from obfuscation

1159
00:49:49,500 --> 00:49:51,660
for the purpose of this talk I'll be

1160
00:49:51,660 --> 00:49:53,880
primarily focusing on the this first

1161
00:49:53,880 --> 00:49:55,380
result

1162
00:49:55,380 --> 00:49:58,380
and just sort of as a

1163
00:49:58,380 --> 00:50:00,359
just as sort of an overview of what we

1164
00:50:00,359 --> 00:50:01,700
achieve

1165
00:50:01,700 --> 00:50:05,040
we compared to these prior works on just

1166
00:50:05,040 --> 00:50:07,260
registration based encryption we sort of

1167
00:50:07,260 --> 00:50:09,720
expand the functionality to be more Abe

1168
00:50:09,720 --> 00:50:10,619
like

1169
00:50:10,619 --> 00:50:13,319
and I'd also like to point out that

1170
00:50:13,319 --> 00:50:16,680
are our construction is more concretely

1171
00:50:16,680 --> 00:50:19,500
efficient so some of these prior RB

1172
00:50:19,500 --> 00:50:22,140
constructions uh

1173
00:50:22,140 --> 00:50:24,599
have ciphertext that are in like many

1174
00:50:24,599 --> 00:50:27,300
like many terabytes lar many terabytes

1175
00:50:27,300 --> 00:50:30,599
in size and the reason for this is that

1176
00:50:30,599 --> 00:50:32,460
they rely on these non-black box

1177
00:50:32,460 --> 00:50:35,579
techniques of either obfuscation or some

1178
00:50:35,579 --> 00:50:38,339
sort of hash garbling whereas our we're

1179
00:50:38,339 --> 00:50:39,839
able to

1180
00:50:39,839 --> 00:50:43,380
sort of make black box use of crypto

1181
00:50:43,380 --> 00:50:45,660
of course there are some limitations to

1182
00:50:45,660 --> 00:50:48,480
this construction as as a sort of I

1183
00:50:48,480 --> 00:50:50,579
stated before we can only support a

1184
00:50:50,579 --> 00:50:52,680
bounded number of users so at setup time

1185
00:50:52,680 --> 00:50:55,920
there needs to be uh we need to specify

1186
00:50:55,920 --> 00:50:58,680
how many users the key curator can

1187
00:50:58,680 --> 00:51:00,900
curate into a single key

1188
00:51:00,900 --> 00:51:03,980
and in addition we have to use a

1189
00:51:03,980 --> 00:51:06,180
structured reference string rather than

1190
00:51:06,180 --> 00:51:09,119
just uniform randomness

1191
00:51:09,119 --> 00:51:12,960
and finally a little a slight downside

1192
00:51:12,960 --> 00:51:15,000
in terms of practicality is that we do

1193
00:51:15,000 --> 00:51:20,099
our CRS does grow quadratically with the

1194
00:51:20,099 --> 00:51:24,240
number of users we need to support

1195
00:51:24,240 --> 00:51:25,260
okay

1196
00:51:25,260 --> 00:51:26,640
so

1197
00:51:26,640 --> 00:51:29,099
I'll try to go over our construction now

1198
00:51:29,099 --> 00:51:30,660
so

1199
00:51:30,660 --> 00:51:33,059
first of all as I said before our

1200
00:51:33,059 --> 00:51:34,800
Construction

1201
00:51:34,800 --> 00:51:37,140
uses composite order by linear groups so

1202
00:51:37,140 --> 00:51:38,940
if you aren't familiar with with what

1203
00:51:38,940 --> 00:51:40,980
this means composite order in our

1204
00:51:40,980 --> 00:51:44,040
setting we use groups which are

1205
00:51:44,040 --> 00:51:46,140
which have a order which are the product

1206
00:51:46,140 --> 00:51:49,040
of three Primes

1207
00:51:49,680 --> 00:51:51,480
for the sake of this talk I'll primarily

1208
00:51:51,480 --> 00:51:53,339
just show what's going on in the G1

1209
00:51:53,339 --> 00:51:55,740
subgroup the other two subgroups are

1210
00:51:55,740 --> 00:51:58,319
mainly used for randomization for the

1211
00:51:58,319 --> 00:52:00,720
sake of proving security

1212
00:52:00,720 --> 00:52:02,880
and of course bilinear means that

1213
00:52:02,880 --> 00:52:05,040
there's an efficiently publicly

1214
00:52:05,040 --> 00:52:08,420
computable mapping which is

1215
00:52:08,420 --> 00:52:10,800
multiplicative in the exponent to some

1216
00:52:10,800 --> 00:52:13,520
Target group

1217
00:52:13,920 --> 00:52:16,140
another sort of uh I guess

1218
00:52:16,140 --> 00:52:18,420
simplification will make to the

1219
00:52:18,420 --> 00:52:20,640
traditional notion of RB of registration

1220
00:52:20,640 --> 00:52:23,579
based encryption is that make sure it's

1221
00:52:23,579 --> 00:52:26,760
sufficient to sort to only achieve this

1222
00:52:26,760 --> 00:52:29,280
notion of slotted aggregation So In

1223
00:52:29,280 --> 00:52:30,599
traditional registration-based

1224
00:52:30,599 --> 00:52:32,640
encryption right the key curator sees

1225
00:52:32,640 --> 00:52:34,859
one key at a time and sort of as the

1226
00:52:34,859 --> 00:52:36,660
keys come in they need to be able to

1227
00:52:36,660 --> 00:52:38,460
incrementally update their Master public

1228
00:52:38,460 --> 00:52:40,079
key

1229
00:52:40,079 --> 00:52:43,740
but in in the slotted version rather

1230
00:52:43,740 --> 00:52:45,839
than having to do sort of having to do

1231
00:52:45,839 --> 00:52:48,900
this as as things come in the key

1232
00:52:48,900 --> 00:52:50,660
curator can just look at all the keys

1233
00:52:50,660 --> 00:52:53,760
sort of save them up and once all the

1234
00:52:53,760 --> 00:52:55,500
slots have filled up

1235
00:52:55,500 --> 00:52:57,480
and just needs to produce this succinct

1236
00:52:57,480 --> 00:52:59,160
Master public key

1237
00:52:59,160 --> 00:53:00,660
and

1238
00:53:00,660 --> 00:53:03,000
this this turns out is sufficient to

1239
00:53:03,000 --> 00:53:06,059
construct the full notion of register

1240
00:53:06,059 --> 00:53:08,400
attribute based encryption using a

1241
00:53:08,400 --> 00:53:12,119
standard powers of two Tech trick

1242
00:53:12,119 --> 00:53:13,200
so

1243
00:53:13,200 --> 00:53:16,920
our starting point is going to be the

1244
00:53:16,920 --> 00:53:19,619
construction of just Abe and bilinear

1245
00:53:19,619 --> 00:53:20,940
groups

1246
00:53:20,940 --> 00:53:24,079
and for Simplicity we'll only consider

1247
00:53:24,079 --> 00:53:27,000
conjunction policies though

1248
00:53:27,000 --> 00:53:30,300
if this works for all monotone Boolean

1249
00:53:30,300 --> 00:53:33,180
formulas just by replacing the additive

1250
00:53:33,180 --> 00:53:34,859
secret sharing with like a linear secret

1251
00:53:34,859 --> 00:53:36,720
sharing scheme

1252
00:53:36,720 --> 00:53:40,020
and so in in these prior Abe schemes

1253
00:53:40,020 --> 00:53:42,180
you'll have the some a bunch of

1254
00:53:42,180 --> 00:53:44,040
encryption

1255
00:53:44,040 --> 00:53:45,420
sorry a bunch of encryption group

1256
00:53:45,420 --> 00:53:49,800
elements and when you want to so when

1257
00:53:49,800 --> 00:53:51,900
you want to encrypt a message what you

1258
00:53:51,900 --> 00:53:55,140
do is you embed this message into you

1259
00:53:55,140 --> 00:53:56,520
pick this Secret

1260
00:53:56,520 --> 00:54:01,500
exponent s you just blind the message by

1261
00:54:01,500 --> 00:54:03,780
this one group element and then you want

1262
00:54:03,780 --> 00:54:05,819
to encode the secret s in a couple more

1263
00:54:05,819 --> 00:54:09,119
places so that you know at decryption

1264
00:54:09,119 --> 00:54:11,040
time you can actually recover this

1265
00:54:11,040 --> 00:54:12,720
message

1266
00:54:12,720 --> 00:54:15,960
so how you know just how decryption

1267
00:54:15,960 --> 00:54:18,599
works is that you'll notice we have this

1268
00:54:18,599 --> 00:54:20,339
egg to the alpha s which is what we want

1269
00:54:20,339 --> 00:54:22,859
to compute and

1270
00:54:22,859 --> 00:54:25,559
you pay so you pair your G to the S with

1271
00:54:25,559 --> 00:54:28,740
this first decryption term and you get

1272
00:54:28,740 --> 00:54:30,839
you get the term you want but you also

1273
00:54:30,839 --> 00:54:32,339
have this additional binding Factor

1274
00:54:32,339 --> 00:54:34,680
right so

1275
00:54:34,680 --> 00:54:36,420
you'll notice that this blinding factor

1276
00:54:36,420 --> 00:54:38,339
is also present in

1277
00:54:38,339 --> 00:54:41,819
another part of the ciphertext so you

1278
00:54:41,819 --> 00:54:44,220
just pair this again and this cancels

1279
00:54:44,220 --> 00:54:46,680
out these two middle terms

1280
00:54:46,680 --> 00:54:49,619
and finally you'll have this third this

1281
00:54:49,619 --> 00:54:51,119
like final term which you also want to

1282
00:54:51,119 --> 00:54:53,339
cancel out and

1283
00:54:53,339 --> 00:54:55,500
again you could just pair this with G to

1284
00:54:55,500 --> 00:54:56,400
the s

1285
00:54:56,400 --> 00:54:57,839
and

1286
00:54:57,839 --> 00:55:00,359
if you if you have the attributes

1287
00:55:00,359 --> 00:55:02,040
available

1288
00:55:02,040 --> 00:55:04,559
and then cancel out and you can find you

1289
00:55:04,559 --> 00:55:06,300
can recover the message

1290
00:55:06,300 --> 00:55:07,680
so

1291
00:55:07,680 --> 00:55:11,058
it turns out that

1292
00:55:11,160 --> 00:55:14,760
uh for in for the for the for an Abe

1293
00:55:14,760 --> 00:55:17,520
scheme you can essentially make all of

1294
00:55:17,520 --> 00:55:18,900
these group elements the public key

1295
00:55:18,900 --> 00:55:21,960
other than this uh

1296
00:55:21,960 --> 00:55:25,500
these secret this one attribute group

1297
00:55:25,500 --> 00:55:27,359
element for the attributes that you

1298
00:55:27,359 --> 00:55:29,720
possess

1299
00:55:30,480 --> 00:55:31,859
so

1300
00:55:31,859 --> 00:55:34,380
that's the Abe scheme and now I'm going

1301
00:55:34,380 --> 00:55:37,920
to give like a sort of high level

1302
00:55:37,920 --> 00:55:41,160
overview of how we get from ABE all uh

1303
00:55:41,160 --> 00:55:44,579
to registered registered Abe

1304
00:55:44,579 --> 00:55:46,140
so

1305
00:55:46,140 --> 00:55:48,780
the first uh so sort of as like a first

1306
00:55:48,780 --> 00:55:50,280
intermediate

1307
00:55:50,280 --> 00:55:53,819
we get we we construct a one user

1308
00:55:53,819 --> 00:55:56,640
registered Abe scheme and the idea here

1309
00:55:56,640 --> 00:55:58,260
is actually pretty simple

1310
00:55:58,260 --> 00:55:59,819
it's that we're we're going to take our

1311
00:55:59,819 --> 00:56:01,680
Abe scheme and we're going to move

1312
00:56:01,680 --> 00:56:04,079
essentially all the group elements and

1313
00:56:04,079 --> 00:56:07,020
everything I described into the CRS of

1314
00:56:07,020 --> 00:56:09,599
our registered AB scheme

1315
00:56:09,599 --> 00:56:11,880
and so now all the group all the key

1316
00:56:11,880 --> 00:56:14,400
curator does is it just looks at CRS and

1317
00:56:14,400 --> 00:56:16,440
it says you know I'll take the I'll like

1318
00:56:16,440 --> 00:56:18,119
find the message with these group

1319
00:56:18,119 --> 00:56:20,940
elements only if the user doesn't

1320
00:56:20,940 --> 00:56:23,940
actually have that attribute

1321
00:56:23,940 --> 00:56:27,059
and of course the user still needs like

1322
00:56:27,059 --> 00:56:29,700
a little bit of secret information so we

1323
00:56:29,700 --> 00:56:31,859
essentially give them the ability to

1324
00:56:31,859 --> 00:56:35,220
have one additional attribute which

1325
00:56:35,220 --> 00:56:37,380
they know the discrete log of and so

1326
00:56:37,380 --> 00:56:41,160
they only they can decrypt the only they

1327
00:56:41,160 --> 00:56:42,839
can sort of deep line that part of the

1328
00:56:42,839 --> 00:56:45,059
ciphertext

1329
00:56:45,059 --> 00:56:48,300
so once we have this one user registered

1330
00:56:48,300 --> 00:56:49,980
Abe scheme

1331
00:56:49,980 --> 00:56:51,720
how do we move to multiple users right

1332
00:56:51,720 --> 00:56:55,980
well they're the very very simple thing

1333
00:56:55,980 --> 00:56:59,040
to do is just you know multiply the keys

1334
00:56:59,040 --> 00:57:01,859
multiply all these like make many copies

1335
00:57:01,859 --> 00:57:04,079
of your one user scheme and sort of just

1336
00:57:04,079 --> 00:57:07,020
multiply everything together and you

1337
00:57:07,020 --> 00:57:09,180
know this sort of satisfy like this

1338
00:57:09,180 --> 00:57:11,520
keeps your key curator as like this

1339
00:57:11,520 --> 00:57:14,099
deterministic process and it's and you

1340
00:57:14,099 --> 00:57:17,400
know it makes everything compact but

1341
00:57:17,400 --> 00:57:19,559
of course it's not quite that simple

1342
00:57:19,559 --> 00:57:21,780
because you run into a little bit of

1343
00:57:21,780 --> 00:57:24,359
some like correctness problems right

1344
00:57:24,359 --> 00:57:26,880
so if you remember from a couple slides

1345
00:57:26,880 --> 00:57:30,839
ago how the ab scheme works is you

1346
00:57:30,839 --> 00:57:33,059
you pair your ciphertext with this G to

1347
00:57:33,059 --> 00:57:36,720
the T exponent which is now in the CRS

1348
00:57:36,720 --> 00:57:38,700
and then this produces the message

1349
00:57:38,700 --> 00:57:41,579
blinded by this additional group element

1350
00:57:41,579 --> 00:57:43,200
term right

1351
00:57:43,200 --> 00:57:45,300
and this group element term you can

1352
00:57:45,300 --> 00:57:47,880
remove if you have the secret key you're

1353
00:57:47,880 --> 00:57:50,960
using another pairing

1354
00:57:51,599 --> 00:57:56,040
but when you when you multiply these uh

1355
00:57:56,040 --> 00:57:58,079
public Keys together and you just

1356
00:57:58,079 --> 00:58:01,559
encrypt normally what you end up with is

1357
00:58:01,559 --> 00:58:03,599
many different many of these like

1358
00:58:03,599 --> 00:58:06,180
blinding noise terms and it's not

1359
00:58:06,180 --> 00:58:08,099
immediately obvious how you'd remove

1360
00:58:08,099 --> 00:58:10,800
these other noise terms corresponding to

1361
00:58:10,800 --> 00:58:13,380
other users keys right because well

1362
00:58:13,380 --> 00:58:15,660
obviously you shouldn't have other users

1363
00:58:15,660 --> 00:58:17,700
secret keys

1364
00:58:17,700 --> 00:58:18,900
but

1365
00:58:18,900 --> 00:58:21,480
it turns out to fix this what we can do

1366
00:58:21,480 --> 00:58:22,500
is

1367
00:58:22,500 --> 00:58:25,440
also just like blow up the

1368
00:58:25,440 --> 00:58:29,280
blow up the CRS a bit more and produce a

1369
00:58:29,280 --> 00:58:31,800
separate G to the T randomness

1370
00:58:31,800 --> 00:58:34,859
for each user so that way when you do

1371
00:58:34,859 --> 00:58:37,980
this pairing you'll notice that the user

1372
00:58:37,980 --> 00:58:41,700
2's secret key is like U2 to the t2 but

1373
00:58:41,700 --> 00:58:43,079
the terms that you have to actually

1374
00:58:43,079 --> 00:58:46,260
de-blind is this like U1 to the t2 and

1375
00:58:46,260 --> 00:58:48,180
u3 to the t2

1376
00:58:48,180 --> 00:58:51,780
and it turns out that because when these

1377
00:58:51,780 --> 00:58:53,760
when you can just give out these group

1378
00:58:53,760 --> 00:58:55,799
elements when the indices don't match

1379
00:58:55,799 --> 00:58:58,740
and this doesn't harm security

1380
00:58:58,740 --> 00:59:00,480
and of course these group elements

1381
00:59:00,480 --> 00:59:03,720
depending on can be generated by the

1382
00:59:03,720 --> 00:59:05,940
other parties and in the CRS depending

1383
00:59:05,940 --> 00:59:08,819
on which ones they are

1384
00:59:08,819 --> 00:59:12,119
and I just like to point out I guess I'd

1385
00:59:12,119 --> 00:59:13,440
just like to note that this is pretty

1386
00:59:13,440 --> 00:59:15,900
this is similar to some techniques used

1387
00:59:15,900 --> 00:59:18,180
to construct a vector commitments

1388
00:59:18,180 --> 00:59:20,940
and batch arguments

1389
00:59:20,940 --> 00:59:24,920
so at this point we're almost done

1390
00:59:24,920 --> 00:59:27,420
there's one flight last flight

1391
00:59:27,420 --> 00:59:29,700
complication here is that

1392
00:59:29,700 --> 00:59:31,500
so we've solved this correct this issue

1393
00:59:31,500 --> 00:59:34,680
and we have we have an L user

1394
00:59:34,680 --> 00:59:38,520
a registered Abe scheme but it only

1395
00:59:38,520 --> 00:59:42,359
achieves a semi honest security as in

1396
00:59:42,359 --> 00:59:45,140
if if all the users do in fact register

1397
00:59:45,140 --> 00:59:47,700
register keys that are honestly

1398
00:59:47,700 --> 00:59:50,579
generated this would work but

1399
00:59:50,579 --> 00:59:53,460
security wouldn't hold for you know

1400
00:59:53,460 --> 00:59:56,940
people just arbitrarily registering keys

1401
00:59:56,940 --> 00:59:58,619
and

1402
00:59:58,619 --> 01:00:02,400
to fix this we just require that the

1403
01:00:02,400 --> 01:00:04,619
users attach a proof of well-formedness

1404
01:00:04,619 --> 01:00:06,480
to their keys

1405
01:00:06,480 --> 01:00:07,619
um

1406
01:00:07,619 --> 01:00:10,260
in this group setting we can this is

1407
01:00:10,260 --> 01:00:12,720
pretty simple in fact it just requires

1408
01:00:12,720 --> 01:00:14,819
like one additional group element and

1409
01:00:14,819 --> 01:00:16,440
from this we can achieve malicious

1410
01:00:16,440 --> 01:00:18,480
security or which is like the full

1411
01:00:18,480 --> 01:00:21,960
notion of registered AB security

1412
01:00:21,960 --> 01:00:25,859
so just to conclude in this in our work

1413
01:00:25,859 --> 01:00:28,500
we Define registered Abe

1414
01:00:28,500 --> 01:00:31,260
and we construct the first registered a

1415
01:00:31,260 --> 01:00:34,020
b schemes you know one from bilinear

1416
01:00:34,020 --> 01:00:36,420
groups which make which is the one which

1417
01:00:36,420 --> 01:00:39,420
I've been going over so far as well as a

1418
01:00:39,420 --> 01:00:42,059
general registered a b circuit

1419
01:00:42,059 --> 01:00:45,359
General registered AV from obfuscation

1420
01:00:45,359 --> 01:00:47,760
and I'd also like yeah I'd just like to

1421
01:00:47,760 --> 01:00:49,200
point out that they've already actually

1422
01:00:49,200 --> 01:00:51,720
been some interesting follow-ups on this

1423
01:00:51,720 --> 01:00:52,859
work

1424
01:00:52,859 --> 01:00:55,140
where the where some people have shown

1425
01:00:55,140 --> 01:00:56,640
that

1426
01:00:56,640 --> 01:00:59,220
are our second construction of

1427
01:00:59,220 --> 01:01:02,460
registered a B for circuits sort of can

1428
01:01:02,460 --> 01:01:04,559
readily generalize to registered

1429
01:01:04,559 --> 01:01:07,140
functional encryption uh

1430
01:01:07,140 --> 01:01:08,700
and then one of these works also

1431
01:01:08,700 --> 01:01:11,220
construct registered predicate

1432
01:01:11,220 --> 01:01:12,240
encryption

1433
01:01:12,240 --> 01:01:16,440
for inner product functionalities

1434
01:01:16,440 --> 01:01:18,420
and I just and I'd like to also leave

1435
01:01:18,420 --> 01:01:21,839
with some open questions so

1436
01:01:21,839 --> 01:01:24,359
you know there's for a b there's the pop

1437
01:01:24,359 --> 01:01:26,040
like maybe we could think about

1438
01:01:26,040 --> 01:01:29,339
constructing registered Abe like large

1439
01:01:29,339 --> 01:01:31,559
Universe registered a b

1440
01:01:31,559 --> 01:01:33,660
um or we can think about maybe is there

1441
01:01:33,660 --> 01:01:36,500
a more generic approach to constructing

1442
01:01:36,500 --> 01:01:39,660
a registered version of a primitive from

1443
01:01:39,660 --> 01:01:42,660
the plain version

1444
01:01:42,660 --> 01:01:46,079
and finally finally uh I'd just like to

1445
01:01:46,079 --> 01:01:47,579
mention that we also have an upcoming

1446
01:01:47,579 --> 01:01:49,619
work where we've

1447
01:01:49,619 --> 01:01:52,500
construct a more both more

1448
01:01:52,500 --> 01:01:56,180
asymptotically and concretely efficient

1449
01:01:56,180 --> 01:01:58,500
registered AB east bounded registered

1450
01:01:58,500 --> 01:02:01,500
Abe scheme and you know it's more

1451
01:02:01,500 --> 01:02:02,819
efficient in that we're able to do this

1452
01:02:02,819 --> 01:02:04,140
in Prime order groups instead of

1453
01:02:04,140 --> 01:02:07,440
composite and the CRS size rather than

1454
01:02:07,440 --> 01:02:10,920
being quadratic is nearly linear

1455
01:02:10,920 --> 01:02:12,860
thank you

1456
01:02:12,860 --> 01:02:18,839
[Applause]

1457
01:02:18,839 --> 01:02:21,359
so if there are questions please come to

1458
01:02:21,359 --> 01:02:23,720
the mic

1459
01:02:25,020 --> 01:02:26,819
okay if not I have a very quick question

1460
01:02:26,819 --> 01:02:30,540
so you mentioned that your structure you

1461
01:02:30,540 --> 01:02:32,220
have a structure reference string and I

1462
01:02:32,220 --> 01:02:34,140
wonder if this is because of the RSA

1463
01:02:34,140 --> 01:02:36,000
modulus of the group or if because of

1464
01:02:36,000 --> 01:02:39,299
additional structure uh it's not RSI

1465
01:02:39,299 --> 01:02:42,900
this is any like Pioneer Group but the

1466
01:02:42,900 --> 01:02:45,299
the structure and the structure in the

1467
01:02:45,299 --> 01:02:46,859
CRS comes from the fact that you need to

1468
01:02:46,859 --> 01:02:50,640
compute these cross terms uh so you need

1469
01:02:50,640 --> 01:02:52,680
to compute like you need to give out G

1470
01:02:52,680 --> 01:02:54,599
to the x d to the Y and G to the X Y

1471
01:02:54,599 --> 01:02:56,280
okay

1472
01:02:56,280 --> 01:02:58,079
thanks

1473
01:02:58,079 --> 01:03:00,900
so I have a question of curiosity uh so

1474
01:03:00,900 --> 01:03:03,480
you pointed out the uh that you've uh

1475
01:03:03,480 --> 01:03:06,599
well considered the um fret scenario

1476
01:03:06,599 --> 01:03:09,420
where users can be malicious uh in the

1477
01:03:09,420 --> 01:03:12,180
threat model where the curator can be

1478
01:03:12,180 --> 01:03:14,520
malicious for example can modify the uh

1479
01:03:14,520 --> 01:03:16,740
public master key uh in some way to get

1480
01:03:16,740 --> 01:03:19,160
users to let's say leak information

1481
01:03:19,160 --> 01:03:23,099
would is there a way for the users to

1482
01:03:23,099 --> 01:03:25,740
well verify that the curator is behaving

1483
01:03:25,740 --> 01:03:28,140
honestly or otherwise protect themselves

1484
01:03:28,140 --> 01:03:31,319
from a dishonest curator well I guess

1485
01:03:31,319 --> 01:03:33,299
that's sort of the point of this like

1486
01:03:33,299 --> 01:03:35,760
registered model where the the curator

1487
01:03:35,760 --> 01:03:39,000
is like entirely deterministic so if

1488
01:03:39,000 --> 01:03:39,900
you're

1489
01:03:39,900 --> 01:03:42,119
so you know if the user if the users

1490
01:03:42,119 --> 01:03:44,040
want they could say like okay like

1491
01:03:44,040 --> 01:03:46,020
here's like how how did you get to this

1492
01:03:46,020 --> 01:03:49,020
master public key right and so the the

1493
01:03:49,020 --> 01:03:50,520
curator should just be able to you know

1494
01:03:50,520 --> 01:03:52,559
produce like it's like hey here's all

1495
01:03:52,559 --> 01:03:53,700
the here's all the people that

1496
01:03:53,700 --> 01:03:55,980
registered and then you can just verify

1497
01:03:55,980 --> 01:03:57,839
that they indeed did generate everything

1498
01:03:57,839 --> 01:03:59,700
correctly and this doesn't compromise

1499
01:03:59,700 --> 01:04:03,119
security because you know the the in rbe

1500
01:04:03,119 --> 01:04:04,859
it doesn't matter like the curator's

1501
01:04:04,859 --> 01:04:06,900
sort of internal State can all be can

1502
01:04:06,900 --> 01:04:08,220
all be public

1503
01:04:08,220 --> 01:04:10,619
okay and just as a very quick follow-up

1504
01:04:10,619 --> 01:04:13,140
question because I think you probably

1505
01:04:13,140 --> 01:04:14,460
already know the answer but just in case

1506
01:04:14,460 --> 01:04:17,400
sir so in the scenario where D curator

1507
01:04:17,400 --> 01:04:20,099
let's say maliciously exclude certain

1508
01:04:20,099 --> 01:04:22,920
users public keys and then presents to

1509
01:04:22,920 --> 01:04:25,799
one user let's say um the master public

1510
01:04:25,799 --> 01:04:27,660
key version that excludes those public

1511
01:04:27,660 --> 01:04:30,000
keys that doesn't do anything that like

1512
01:04:30,000 --> 01:04:32,819
leads confidentiality does it

1513
01:04:32,819 --> 01:04:35,040
uh sorry what do you mean by leaks

1514
01:04:35,040 --> 01:04:38,339
confidentiality uh so okay so uh let's

1515
01:04:38,339 --> 01:04:41,040
so the curator still wouldn't be able to

1516
01:04:41,040 --> 01:04:43,380
do anything uh that would allow a

1517
01:04:43,380 --> 01:04:45,839
different user to decrypt a message that

1518
01:04:45,839 --> 01:04:48,599
they should not be able to decrypt right

1519
01:04:48,599 --> 01:04:51,000
the I mean the curator only has access

1520
01:04:51,000 --> 01:04:53,280
access to public information right yeah

1521
01:04:53,280 --> 01:04:56,400
but uh so they can they can't produce

1522
01:04:56,400 --> 01:04:59,700
yeah but if the users can't like if the

1523
01:04:59,700 --> 01:05:01,980
curator has access to more and as in if

1524
01:05:01,980 --> 01:05:03,660
the users don't know who all the users

1525
01:05:03,660 --> 01:05:06,240
are that sort of thing

1526
01:05:06,240 --> 01:05:08,160
or would they be able to verify who all

1527
01:05:08,160 --> 01:05:11,940
the users are or all their public keys

1528
01:05:11,940 --> 01:05:14,460
sorry I I don't quite know what you mean

1529
01:05:14,460 --> 01:05:17,819
by that uh we we can offline it uh but

1530
01:05:17,819 --> 01:05:20,480
uh yeah

1531
01:05:21,470 --> 01:05:26,880
[Applause]

1532
01:05:26,880 --> 01:05:29,099
so we have a five minutes break and

1533
01:05:29,099 --> 01:05:33,799
we'll be uh we'll start again at 11 40.

