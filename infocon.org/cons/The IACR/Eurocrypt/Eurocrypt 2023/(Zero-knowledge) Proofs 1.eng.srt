1
00:00:04,980 --> 00:00:07,160
foreign

2
00:00:24,300 --> 00:00:25,680
okay hi

3
00:00:25,680 --> 00:00:28,439
so I will be talking about

4
00:00:28,439 --> 00:00:30,720
witness accent universally composable

5
00:00:30,720 --> 00:00:33,000
snarks

6
00:00:33,000 --> 00:00:36,360
um so in this work we present the very

7
00:00:36,360 --> 00:00:38,300
first universally composable

8
00:00:38,300 --> 00:00:40,320
non-attractive zero knowledge argument

9
00:00:40,320 --> 00:00:43,760
of knowledge that has very short proofs

10
00:00:43,760 --> 00:00:46,620
it has constant size proofs in the

11
00:00:46,620 --> 00:00:49,020
global random Oracle model by constant

12
00:00:49,020 --> 00:00:51,480
size proofs I mean that these the proof

13
00:00:51,480 --> 00:00:53,120
size is independent of the witness size

14
00:00:53,120 --> 00:00:55,680
the witness land it's only dependent on

15
00:00:55,680 --> 00:00:57,480
the security parameter

16
00:00:57,480 --> 00:01:01,020
and the way we do this is we present a

17
00:01:01,020 --> 00:01:03,059
compiler that takes an existing

18
00:01:03,059 --> 00:01:05,640
simulation extractable music with its

19
00:01:05,640 --> 00:01:08,820
own setup and then compiles it to a uses

20
00:01:08,820 --> 00:01:11,460
a journalism by adding on the random

21
00:01:11,460 --> 00:01:13,979
Oracle assumption and what is important

22
00:01:13,979 --> 00:01:15,900
here is that the compiler is succiness

23
00:01:15,900 --> 00:01:18,720
preserving which means that the number

24
00:01:18,720 --> 00:01:21,060
of messages that it would add onto the

25
00:01:21,060 --> 00:01:23,100
original music is going to be

26
00:01:23,100 --> 00:01:26,460
independent of the witness size

27
00:01:26,460 --> 00:01:28,439
so if the original Lasik is constant

28
00:01:28,439 --> 00:01:31,200
sized the compiler only adds constant

29
00:01:31,200 --> 00:01:33,299
side constant number of messages in the

30
00:01:33,299 --> 00:01:35,880
security parameter and so you finally

31
00:01:35,880 --> 00:01:37,500
get UC secure anesthetic that is of

32
00:01:37,500 --> 00:01:40,020
constant size

33
00:01:40,020 --> 00:01:42,920
so in the stock I will first cover some

34
00:01:42,920 --> 00:01:45,540
important preliminaries and then talk

35
00:01:45,540 --> 00:01:47,280
about why it's so challenging to build

36
00:01:47,280 --> 00:01:50,340
UC secure snarks then present a warm-up

37
00:01:50,340 --> 00:01:51,960
compiler and finally present our

38
00:01:51,960 --> 00:01:54,180
compiler

39
00:01:54,180 --> 00:01:57,299
so Azure Outlet snark is a primitive

40
00:01:57,299 --> 00:02:00,860
that allows approver to make a claim

41
00:02:00,860 --> 00:02:03,720
and then present proof for it and then

42
00:02:03,720 --> 00:02:05,640
it allows the verifier to accept or

43
00:02:05,640 --> 00:02:08,580
reject the claim based on the proof it

44
00:02:08,580 --> 00:02:10,400
has properties such as succinctness

45
00:02:10,400 --> 00:02:13,739
non-interactive completeness zero

46
00:02:13,739 --> 00:02:15,660
knowledge and argument of knowledge

47
00:02:15,660 --> 00:02:17,760
I will only talk about the most relevant

48
00:02:17,760 --> 00:02:20,580
properties here and Skip not so relevant

49
00:02:20,580 --> 00:02:22,940
ones

50
00:02:24,980 --> 00:02:27,480
accent which means that the size of the

51
00:02:27,480 --> 00:02:29,819
proof is very short it's independent of

52
00:02:29,819 --> 00:02:31,500
the witness size it's only dependent on

53
00:02:31,500 --> 00:02:33,300
Lambda which is the security parameter

54
00:02:33,300 --> 00:02:35,819
and this and this is the setting the

55
00:02:35,819 --> 00:02:38,220
witness acceptance setting is it is what

56
00:02:38,220 --> 00:02:40,980
we are interested in in this paper

57
00:02:40,980 --> 00:02:42,840
it is zero knowledge which means that

58
00:02:42,840 --> 00:02:45,000
there's a simulator that can generate a

59
00:02:45,000 --> 00:02:47,700
indistinguishable looking proof from

60
00:02:47,700 --> 00:02:49,379
just a statement

61
00:02:49,379 --> 00:02:51,239
it is argument of knowledge which means

62
00:02:51,239 --> 00:02:53,099
that there is an extractor that can take

63
00:02:53,099 --> 00:02:55,319
a valid verifying proof and then extract

64
00:02:55,319 --> 00:02:58,200
a valid witness from it

65
00:02:58,200 --> 00:03:00,060
so we have all of these property-based

66
00:03:00,060 --> 00:03:01,980
definitions why do we need UC security

67
00:03:01,980 --> 00:03:04,080
well because it's the gold standard of

68
00:03:04,080 --> 00:03:06,120
security and it allows us to compose

69
00:03:06,120 --> 00:03:08,879
protocols together and in particular

70
00:03:08,879 --> 00:03:10,800
property-based definitions do not allow

71
00:03:10,800 --> 00:03:14,700
do not give us compositional guarantees

72
00:03:14,700 --> 00:03:17,459
so and you see security is defined in a

73
00:03:17,459 --> 00:03:18,720
very different way compared to

74
00:03:18,720 --> 00:03:21,360
property-based definitions it is defined

75
00:03:21,360 --> 00:03:23,940
as an indistinguishability game well

76
00:03:23,940 --> 00:03:25,500
indistinguishability between two

77
00:03:25,500 --> 00:03:27,480
experiments the real world and the ideal

78
00:03:27,480 --> 00:03:30,300
world in the real world and then there's

79
00:03:30,300 --> 00:03:31,860
this external distinguisher who's

80
00:03:31,860 --> 00:03:33,720
supposed to distinguish between the two

81
00:03:33,720 --> 00:03:34,620
words

82
00:03:34,620 --> 00:03:37,080
so in the real world there's the real

83
00:03:37,080 --> 00:03:39,780
priorities executing real protocol and

84
00:03:39,780 --> 00:03:42,900
this involves exchange of messages and

85
00:03:42,900 --> 00:03:44,819
in the ideal World there are dummy

86
00:03:44,819 --> 00:03:46,860
parties and the ideal World adversary

87
00:03:46,860 --> 00:03:48,780
called the simulator

88
00:03:48,780 --> 00:03:51,180
and then they receive the inputs from

89
00:03:51,180 --> 00:03:54,120
this environment e and they just send it

90
00:03:54,120 --> 00:03:55,739
to the functionality who computes the

91
00:03:55,739 --> 00:03:57,900
outputs and then they receive the output

92
00:03:57,900 --> 00:03:59,940
from this functionality and the point is

93
00:03:59,940 --> 00:04:01,560
that in the ideal World there is no

94
00:04:01,560 --> 00:04:03,239
interaction so it's secured by Design

95
00:04:03,239 --> 00:04:06,599
and if we can say that for all uh

96
00:04:06,599 --> 00:04:10,260
distinguishers e the real world looks

97
00:04:10,260 --> 00:04:12,720
exactly like are indistinguishable from

98
00:04:12,720 --> 00:04:15,060
the ideal world then the real world must

99
00:04:15,060 --> 00:04:16,040
be

100
00:04:16,040 --> 00:04:20,239
secure by importation

101
00:04:20,339 --> 00:04:23,699
so we can actually just starting from

102
00:04:23,699 --> 00:04:25,380
property based definitions we can

103
00:04:25,380 --> 00:04:28,139
already say something about UC security

104
00:04:28,139 --> 00:04:31,020
we can say that if the underlying music

105
00:04:31,020 --> 00:04:34,740
protocol is simulation extractable in a

106
00:04:34,740 --> 00:04:36,840
straight line and black box manner then

107
00:04:36,840 --> 00:04:38,940
that would imply Universal composable

108
00:04:38,940 --> 00:04:40,580
Music

109
00:04:40,580 --> 00:04:42,600
so what do we mean by simulation

110
00:04:42,600 --> 00:04:44,940
extractable music well it's just a

111
00:04:44,940 --> 00:04:46,320
combination of the zero knowledge

112
00:04:46,320 --> 00:04:48,060
property and argument of knowledge

113
00:04:48,060 --> 00:04:49,380
property

114
00:04:49,380 --> 00:04:52,259
so here the approver has the additional

115
00:04:52,259 --> 00:04:55,500
power to look at multiple proofs and

116
00:04:55,500 --> 00:04:58,199
this is via the simulation query it can

117
00:04:58,199 --> 00:05:00,120
ask the simulator for statements of his

118
00:05:00,120 --> 00:05:03,060
choice C Prime and receive valid proofs

119
00:05:03,060 --> 00:05:05,580
Pi Prime and after seeing a bunch of

120
00:05:05,580 --> 00:05:07,199
these proofs it gets to make its own

121
00:05:07,199 --> 00:05:10,919
forgery and even in this uh stronger

122
00:05:10,919 --> 00:05:14,479
case the extractor should be able to

123
00:05:14,479 --> 00:05:18,300
extract a valid witness from this proof

124
00:05:18,300 --> 00:05:20,400
what do we mean by straight line on

125
00:05:20,400 --> 00:05:22,979
Black Box way of extraction so in the

126
00:05:22,979 --> 00:05:25,620
property that we just saw uh the

127
00:05:25,620 --> 00:05:27,240
simulation extractable property that we

128
00:05:27,240 --> 00:05:29,400
just saw the extraction part should be

129
00:05:29,400 --> 00:05:31,320
done in a straight line way which means

130
00:05:31,320 --> 00:05:34,199
that the extractor extracts just looking

131
00:05:34,199 --> 00:05:37,139
at the proof uh for example it might not

132
00:05:37,139 --> 00:05:40,320
have powers of rewinding the proverb and

133
00:05:40,320 --> 00:05:42,180
it must extract in a black box manner

134
00:05:42,180 --> 00:05:45,060
which means that it only has Black Box

135
00:05:45,060 --> 00:05:47,460
access to the adversary and again like

136
00:05:47,460 --> 00:05:50,039
for example it cannot look into the

137
00:05:50,039 --> 00:05:52,020
internal state of the adversary and we

138
00:05:52,020 --> 00:05:53,639
cannot use things like knowledge

139
00:05:53,639 --> 00:05:55,860
assumptions

140
00:05:55,860 --> 00:05:58,680
so this is achieving both of these

141
00:05:58,680 --> 00:06:00,440
properties at the same time is

142
00:06:00,440 --> 00:06:04,080
impossible in just CRS alone and you

143
00:06:04,080 --> 00:06:05,960
would need some additional non

144
00:06:05,960 --> 00:06:08,340
non-falsifiable assumption and what we

145
00:06:08,340 --> 00:06:11,759
use in our case as the random Oracle

146
00:06:11,759 --> 00:06:15,060
and in fact uh so we already know a lot

147
00:06:15,060 --> 00:06:16,560
of snarks that are already simulation

148
00:06:16,560 --> 00:06:21,419
extractable but they they either are not

149
00:06:21,419 --> 00:06:23,039
straight line extractable or black box

150
00:06:23,039 --> 00:06:24,539
extractable

151
00:06:24,539 --> 00:06:26,639
and I'm just going to cover some of the

152
00:06:26,639 --> 00:06:29,819
prior works and like related works so

153
00:06:29,819 --> 00:06:31,620
there's this line of literature that

154
00:06:31,620 --> 00:06:32,819
tries to achieve straight line

155
00:06:32,819 --> 00:06:34,860
attraction and this involves a bunch of

156
00:06:34,860 --> 00:06:37,199
compilers like fishland pass

157
00:06:37,199 --> 00:06:39,380
uh but they are not

158
00:06:39,380 --> 00:06:42,660
uh yeah they're not succinct they're not

159
00:06:42,660 --> 00:06:44,580
protest accent and then there are a

160
00:06:44,580 --> 00:06:47,100
bunch of compilers that lift existing

161
00:06:47,100 --> 00:06:49,319
snarks to simulation extractable or you

162
00:06:49,319 --> 00:06:51,600
see secure snarks but then all of these

163
00:06:51,600 --> 00:06:53,340
works either miss out on straight line

164
00:06:53,340 --> 00:06:55,680
extraction or Black Box extraction or

165
00:06:55,680 --> 00:06:57,840
they are not witness accent and in this

166
00:06:57,840 --> 00:06:59,699
work we achieve all of these three

167
00:06:59,699 --> 00:07:01,139
things together

168
00:07:01,139 --> 00:07:04,139
uh in in the random Oracle model

169
00:07:04,139 --> 00:07:06,660
so we are using random Oracle but we

170
00:07:06,660 --> 00:07:09,060
want to use it in a very constrained way

171
00:07:09,060 --> 00:07:11,400
we would not program the random Oracle

172
00:07:11,400 --> 00:07:13,380
because we want to use a global random

173
00:07:13,380 --> 00:07:15,180
Oracle which means there's only a single

174
00:07:15,180 --> 00:07:18,960
random Oracle for all uh protocols

175
00:07:18,960 --> 00:07:21,300
and we would instead use observability

176
00:07:21,300 --> 00:07:23,520
of the random Oracle queries so the

177
00:07:23,520 --> 00:07:25,259
extractor would get to see all the

178
00:07:25,259 --> 00:07:26,880
queries that the adversary makes to the

179
00:07:26,880 --> 00:07:29,099
random Oracle and then this gives it

180
00:07:29,099 --> 00:07:31,199
enough information to be able to extract

181
00:07:31,199 --> 00:07:33,479
from a succinct proof

182
00:07:33,479 --> 00:07:36,240
so our extraction is going to be Black

183
00:07:36,240 --> 00:07:37,800
Box because you only look at random

184
00:07:37,800 --> 00:07:40,380
Oracle queries and you don't need the

185
00:07:40,380 --> 00:07:42,120
adversary and it's going to be straight

186
00:07:42,120 --> 00:07:43,979
line because again you only look at the

187
00:07:43,979 --> 00:07:46,940
random Oracle queries

188
00:07:47,220 --> 00:07:50,280
all right so now let me give a warm-up

189
00:07:50,280 --> 00:07:52,680
compiler that achieves both straight

190
00:07:52,680 --> 00:07:55,740
line and black box extraction but it's

191
00:07:55,740 --> 00:07:57,900
not witness accent

192
00:07:57,900 --> 00:08:00,960
so this is the cocoa framework which

193
00:08:00,960 --> 00:08:04,440
formalizes UC security which the ideas

194
00:08:04,440 --> 00:08:07,979
that were presented much earlier

195
00:08:07,979 --> 00:08:08,580
um

196
00:08:08,580 --> 00:08:12,120
so okay so this is the basic snark

197
00:08:12,120 --> 00:08:15,300
framework the idea here is that the

198
00:08:15,300 --> 00:08:17,759
proverb would be asked to make an

199
00:08:17,759 --> 00:08:20,940
extractable commitment to the witness

200
00:08:20,940 --> 00:08:22,800
now given this with extractable

201
00:08:22,800 --> 00:08:24,300
commitment the extractor could just

202
00:08:24,300 --> 00:08:25,560
extract from it

203
00:08:25,560 --> 00:08:27,360
a very simple way of doing this

204
00:08:27,360 --> 00:08:28,860
commitment is just encrypt to the

205
00:08:28,860 --> 00:08:30,660
witness so the prover encrypts the

206
00:08:30,660 --> 00:08:32,520
witness and sends that encryption along

207
00:08:32,520 --> 00:08:35,940
with the proof along with the proof I

208
00:08:35,940 --> 00:08:37,620
and now we also have to link this

209
00:08:37,620 --> 00:08:39,779
witness to the original one so we change

210
00:08:39,779 --> 00:08:42,000
it we we would change the statement and

211
00:08:42,000 --> 00:08:45,180
also do the proof for the new claim

212
00:08:45,180 --> 00:08:47,160
and finally we would include the public

213
00:08:47,160 --> 00:08:49,620
key under which this encryption should

214
00:08:49,620 --> 00:08:52,320
be made in the in the setup and in the

215
00:08:52,320 --> 00:08:54,540
ideal world the extractor would know the

216
00:08:54,540 --> 00:08:55,800
secret key

217
00:08:55,800 --> 00:08:58,380
and so when it sees this encryption it

218
00:08:58,380 --> 00:08:59,760
can just decrypt it and output the

219
00:08:59,760 --> 00:09:01,140
witness

220
00:09:01,140 --> 00:09:03,060
but of course the problem here is that

221
00:09:03,060 --> 00:09:06,540
we're using encryption uh so it's going

222
00:09:06,540 --> 00:09:07,980
to be as long as the witness and it's

223
00:09:07,980 --> 00:09:11,399
not witness accent and our idea here is

224
00:09:11,399 --> 00:09:12,959
to change the way this extractable

225
00:09:12,959 --> 00:09:15,959
commitment part is done and then and so

226
00:09:15,959 --> 00:09:18,300
that is a succinct and to be able to

227
00:09:18,300 --> 00:09:20,880
extract from the succinct uh sexing

228
00:09:20,880 --> 00:09:25,399
commitment we would use random Oracle

229
00:09:25,560 --> 00:09:27,720
all right so there are two important

230
00:09:27,720 --> 00:09:29,880
ingredients here the first is to how to

231
00:09:29,880 --> 00:09:32,040
do sex and commitments and for this we

232
00:09:32,040 --> 00:09:34,920
would use polynomial commitments uh

233
00:09:34,920 --> 00:09:36,060
polynomial commitments are just

234
00:09:36,060 --> 00:09:37,500
commitment schemes that allow you to

235
00:09:37,500 --> 00:09:39,720
commit to a polynomial F and then later

236
00:09:39,720 --> 00:09:43,320
open points uh for this polynomial so

237
00:09:43,320 --> 00:09:46,200
you can open z and y and also provide a

238
00:09:46,200 --> 00:09:49,019
proof Pi e that will verify only if this

239
00:09:49,019 --> 00:09:51,000
evaluation is correct

240
00:09:51,000 --> 00:09:53,100
and to be able to extract from this

241
00:09:53,100 --> 00:09:55,680
commitment we would use ideas from proof

242
00:09:55,680 --> 00:09:57,420
of work in the random Oracle literature

243
00:09:57,420 --> 00:10:00,660
very similar to the fashion compiler for

244
00:10:00,660 --> 00:10:04,140
which works for Sigma protocols

245
00:10:04,140 --> 00:10:07,920
so concretely to do the commitment uh

246
00:10:07,920 --> 00:10:09,779
the proverb would first be asked to

247
00:10:09,779 --> 00:10:12,720
encode the witness as a polynomial so

248
00:10:12,720 --> 00:10:14,459
here the

249
00:10:14,459 --> 00:10:17,700
Witnesses W1 to WN and one example of

250
00:10:17,700 --> 00:10:20,279
encoding the this as a polynomial is

251
00:10:20,279 --> 00:10:22,320
just using it as coefficients to a

252
00:10:22,320 --> 00:10:25,140
polynomial and then it would commit to

253
00:10:25,140 --> 00:10:26,880
it using some polynomial commitment

254
00:10:26,880 --> 00:10:29,339
scheme and this commitment would be

255
00:10:29,339 --> 00:10:30,779
succinct and independent of the witness

256
00:10:30,779 --> 00:10:33,240
uh witness size and degree of the

257
00:10:33,240 --> 00:10:35,220
polynomial

258
00:10:35,220 --> 00:10:37,920
okay and as before we would change the

259
00:10:37,920 --> 00:10:39,899
claim to uh

260
00:10:39,899 --> 00:10:42,000
link the two commitments uh sorry linked

261
00:10:42,000 --> 00:10:44,100
it to witness

262
00:10:44,100 --> 00:10:46,200
and to be able to extract from this

263
00:10:46,200 --> 00:10:49,620
commitment the key here is the way this

264
00:10:49,620 --> 00:10:52,380
valid proof is generated so this valid

265
00:10:52,380 --> 00:10:54,240
proof would consists of two parts the

266
00:10:54,240 --> 00:10:56,640
first one Pi would just be the proof of

267
00:10:56,640 --> 00:10:58,920
the modified claim and the second part

268
00:10:58,920 --> 00:11:02,160
which is pi e z and y would allow us to

269
00:11:02,160 --> 00:11:05,420
extract from the random Oracle

270
00:11:06,000 --> 00:11:08,760
um okay so we assume that random Oracle

271
00:11:08,760 --> 00:11:11,940
has some limits of output and now the

272
00:11:11,940 --> 00:11:14,700
prover would do our repetitions of the

273
00:11:14,700 --> 00:11:16,860
following procedure

274
00:11:16,860 --> 00:11:18,899
the proverb will have to find an

275
00:11:18,899 --> 00:11:21,420
evaluation point that such that the

276
00:11:21,420 --> 00:11:24,540
Tuple commitment Pi e which is the

277
00:11:24,540 --> 00:11:26,760
evaluation proof Z which is this point

278
00:11:26,760 --> 00:11:29,279
and Y is the evaluation this Tuple

279
00:11:29,279 --> 00:11:31,800
hashes to zero

280
00:11:31,800 --> 00:11:33,899
and the way the proverb would do this is

281
00:11:33,899 --> 00:11:36,660
it would just sample these points from

282
00:11:36,660 --> 00:11:38,240
the valid domain

283
00:11:38,240 --> 00:11:41,700
generate this proof by e asked around

284
00:11:41,700 --> 00:11:44,459
the miracle for this Tuple and check if

285
00:11:44,459 --> 00:11:47,880
the random Oracle output is zero bits

286
00:11:47,880 --> 00:11:50,579
and if and it would stop when it finds a

287
00:11:50,579 --> 00:11:53,040
stopper and the double that hashes to

288
00:11:53,040 --> 00:11:54,839
zero would form the part of the final

289
00:11:54,839 --> 00:11:57,680
output of would be the part of the final

290
00:11:57,680 --> 00:12:01,320
valid uh proof

291
00:12:01,320 --> 00:12:03,600
so because we have this constraint on

292
00:12:03,600 --> 00:12:05,640
the random Oracle output

293
00:12:05,640 --> 00:12:08,940
uh the point is that the proverb will be

294
00:12:08,940 --> 00:12:12,600
forced to make a more queries than would

295
00:12:12,600 --> 00:12:14,940
appear in the final proof

296
00:12:14,940 --> 00:12:17,279
in particular it would be forced to make

297
00:12:17,279 --> 00:12:19,500
at least D which is the degree of the

298
00:12:19,500 --> 00:12:21,060
polynomial number of random Oracle

299
00:12:21,060 --> 00:12:24,660
queries with different evaluation points

300
00:12:24,660 --> 00:12:26,579
and then in the ideal world the

301
00:12:26,579 --> 00:12:28,980
extractor can just query the random

302
00:12:28,980 --> 00:12:31,380
Oracle with observed query and the

303
00:12:31,380 --> 00:12:34,140
random Oracle would just send back the

304
00:12:34,140 --> 00:12:36,899
entire table of these tuples and the

305
00:12:36,899 --> 00:12:40,740
outputs to the extractor and here some

306
00:12:40,740 --> 00:12:42,480
of the some of these tuples that are

307
00:12:42,480 --> 00:12:44,820
marked in red are not part of the final

308
00:12:44,820 --> 00:12:46,860
output because they did not Hash a zero

309
00:12:46,860 --> 00:12:48,480
and then some of them which are marked

310
00:12:48,480 --> 00:12:51,839
as green are the part of the final final

311
00:12:51,839 --> 00:12:54,720
proof but the extractor gets to see

312
00:12:54,720 --> 00:12:56,940
uh many points

313
00:12:56,940 --> 00:12:58,740
and enough points that it can

314
00:12:58,740 --> 00:13:01,320
interpolate the polynomial decoded and

315
00:13:01,320 --> 00:13:03,300
output the witness

316
00:13:03,300 --> 00:13:06,240
when would this extraction fail it would

317
00:13:06,240 --> 00:13:08,639
fail when the prover manages to manages

318
00:13:08,639 --> 00:13:10,380
to find a good Tuple

319
00:13:10,380 --> 00:13:13,860
uh that hashes to zero before making the

320
00:13:13,860 --> 00:13:15,980
green number of queries

321
00:13:15,980 --> 00:13:19,560
and to assess this probability so the

322
00:13:19,560 --> 00:13:22,079
probability of getting a good string in

323
00:13:22,079 --> 00:13:23,940
any given try is 1 over 2 to the B

324
00:13:23,940 --> 00:13:26,339
because the random Oracle output are B

325
00:13:26,339 --> 00:13:27,839
bits

326
00:13:27,839 --> 00:13:30,600
uh the probability of getting this under

327
00:13:30,600 --> 00:13:33,660
D tries is D over 2 to the B

328
00:13:33,660 --> 00:13:36,420
and now if we can make this D over 2 to

329
00:13:36,420 --> 00:13:38,820
the B big enough sorry small enough then

330
00:13:38,820 --> 00:13:40,680
this extraction probability would be

331
00:13:40,680 --> 00:13:43,680
negligible but then that would also mean

332
00:13:43,680 --> 00:13:45,720
that 2 to the B is very big it's

333
00:13:45,720 --> 00:13:47,880
exponentially big and even an honest

334
00:13:47,880 --> 00:13:49,740
proverb would have to do a lot of price

335
00:13:49,740 --> 00:13:51,959
to find this Tuple

336
00:13:51,959 --> 00:13:53,880
so even an honest proverb might not

337
00:13:53,880 --> 00:13:56,760
finish in polynomial time

338
00:13:56,760 --> 00:14:00,000
to avoid that we make 2 to the B only

339
00:14:00,000 --> 00:14:02,579
polynomial a bit but then we repeat the

340
00:14:02,579 --> 00:14:05,040
whole procedure R times so that the

341
00:14:05,040 --> 00:14:07,440
probability of extraction failing is D

342
00:14:07,440 --> 00:14:08,279
over

343
00:14:08,279 --> 00:14:11,459
2 to the B to the r and by setting very

344
00:14:11,459 --> 00:14:15,180
naive parameters uh such as setting the

345
00:14:15,180 --> 00:14:17,220
number of repetitions as Lambda where

346
00:14:17,220 --> 00:14:19,440
Lambda is a security parameter we get

347
00:14:19,440 --> 00:14:21,660
the extraction failing uh the

348
00:14:21,660 --> 00:14:23,160
probability of extraction failing to be

349
00:14:23,160 --> 00:14:24,899
negligible

350
00:14:24,899 --> 00:14:27,060
and note that we can do much better than

351
00:14:27,060 --> 00:14:29,579
setting r as Lambda

352
00:14:29,579 --> 00:14:31,200
um okay so now

353
00:14:31,200 --> 00:14:34,139
B is small enough 2 to the B is

354
00:14:34,139 --> 00:14:36,600
polynomically Big so our honest proverb

355
00:14:36,600 --> 00:14:38,700
finishes in time so this protocol is

356
00:14:38,700 --> 00:14:42,180
complete and uh X probability of

357
00:14:42,180 --> 00:14:44,760
extraction is negligible and moreover

358
00:14:44,760 --> 00:14:47,220
the number of repetitions are

359
00:14:47,220 --> 00:14:49,199
independent of the witness size it's

360
00:14:49,199 --> 00:14:53,519
only in the naive case it's only Lambda

361
00:14:53,519 --> 00:14:56,600
so the final

362
00:14:56,639 --> 00:14:59,699
construction is as follows the prover

363
00:14:59,699 --> 00:15:03,180
commits to prover encodes the witness as

364
00:15:03,180 --> 00:15:08,399
some polynomial F commits to it proves

365
00:15:08,760 --> 00:15:10,740
proves the statement the modified claim

366
00:15:10,740 --> 00:15:13,860
pie and also does our repetitions of

367
00:15:13,860 --> 00:15:16,380
this Tuple Pi e z and y

368
00:15:16,380 --> 00:15:18,300
and the verifier checks all of these

369
00:15:18,300 --> 00:15:20,699
proofs checks Pi by E and also checks

370
00:15:20,699 --> 00:15:25,500
the random Oracle output for z and y

371
00:15:25,500 --> 00:15:28,260
and the expected amount of work that an

372
00:15:28,260 --> 00:15:31,620
honest prover has to do is our times to

373
00:15:31,620 --> 00:15:34,920
the B for each iteration and because we

374
00:15:34,920 --> 00:15:36,480
said two to the B to be small enough

375
00:15:36,480 --> 00:15:39,720
this would be an honest would finish in

376
00:15:39,720 --> 00:15:42,360
polynomial time

377
00:15:42,360 --> 00:15:45,240
um as we saw extraction would would fail

378
00:15:45,240 --> 00:15:47,339
with negligible probability by setting

379
00:15:47,339 --> 00:15:53,459
naive parameters where R is Lambda

380
00:15:53,459 --> 00:15:56,699
so here in the proof uh

381
00:15:56,699 --> 00:16:00,240
the the commitment as to the witness and

382
00:16:00,240 --> 00:16:02,519
we are actually revealing some points

383
00:16:02,519 --> 00:16:04,980
with respect to this Witness

384
00:16:04,980 --> 00:16:08,040
so in order to preserve zero knowledge

385
00:16:08,040 --> 00:16:10,380
we would when we can encode this uh

386
00:16:10,380 --> 00:16:13,019
witness as the polynomial f

387
00:16:13,019 --> 00:16:16,199
we would have to add enough Randomness

388
00:16:16,199 --> 00:16:18,540
to F so that revealing these additional

389
00:16:18,540 --> 00:16:20,220
points does not reveal anything about

390
00:16:20,220 --> 00:16:21,240
the witness

391
00:16:21,240 --> 00:16:25,019
so if the original proof pi

392
00:16:25,019 --> 00:16:27,779
is zero knowledge Pi e has zero

393
00:16:27,779 --> 00:16:30,779
knowledge and if the encoding of f has

394
00:16:30,779 --> 00:16:32,820
enough Randomness in it then the entire

395
00:16:32,820 --> 00:16:34,860
proof would be zero knowledge

396
00:16:34,860 --> 00:16:38,100
and finally what is the proof size if

397
00:16:38,100 --> 00:16:41,820
the original proof Pi has constant

398
00:16:41,820 --> 00:16:45,000
consist proof size Pi e is constant

399
00:16:45,000 --> 00:16:46,920
constant and because we are only doing

400
00:16:46,920 --> 00:16:48,899
our repetitions where R is only

401
00:16:48,899 --> 00:16:52,380
dependent on Lambda the entire proof uh

402
00:16:52,380 --> 00:16:55,339
is constant size

403
00:16:55,560 --> 00:16:58,320
okay so to conclude

404
00:16:58,320 --> 00:17:00,600
we present the compiler that lifts a

405
00:17:00,600 --> 00:17:02,639
simulation extractable snark till you

406
00:17:02,639 --> 00:17:05,400
see secure snark and this compiler

407
00:17:05,400 --> 00:17:08,119
preserves success

408
00:17:08,119 --> 00:17:10,919
by plugging in existing constant sized

409
00:17:10,919 --> 00:17:14,220
snarks into the compiler we we get the

410
00:17:14,220 --> 00:17:18,059
first constant size you see secure snark

411
00:17:18,059 --> 00:17:20,400
this this compiler can also be used to

412
00:17:20,400 --> 00:17:22,740
lift the security of other schemes that

413
00:17:22,740 --> 00:17:25,199
have improved simulation extractable for

414
00:17:25,199 --> 00:17:28,939
example bulletproof since Spartan Etc

415
00:17:29,340 --> 00:17:33,799
and finally the security proof of our

416
00:17:33,799 --> 00:17:37,919
the security proof does not cover models

417
00:17:37,919 --> 00:17:39,720
it does not cover snarks that are proof

418
00:17:39,720 --> 00:17:42,840
secure under models such as ADM gdm so

419
00:17:42,840 --> 00:17:45,360
it would be nice to know how to extend

420
00:17:45,360 --> 00:17:48,120
the proof to cover these models

421
00:17:48,120 --> 00:17:49,370
thank you

422
00:17:49,370 --> 00:17:55,830
[Applause]

423
00:17:56,220 --> 00:17:59,780
we have time for a quick question

424
00:18:04,440 --> 00:18:05,580
hi

425
00:18:05,580 --> 00:18:08,580
um I I really enjoy your talk so

426
00:18:08,580 --> 00:18:10,380
um the third point there you say you can

427
00:18:10,380 --> 00:18:12,059
lift some other protocols such as

428
00:18:12,059 --> 00:18:15,059
bulletproofs and sparring to EC security

429
00:18:15,059 --> 00:18:16,799
um like what is the strategy to do that

430
00:18:16,799 --> 00:18:19,020
don't you need something like a pro

431
00:18:19,020 --> 00:18:20,820
programming the random Oracle for

432
00:18:20,820 --> 00:18:23,880
spoilers inspiring in stimulating yeah

433
00:18:23,880 --> 00:18:25,919
yeah it's not very direct how you could

434
00:18:25,919 --> 00:18:28,740
do that but like for instance suppose

435
00:18:28,740 --> 00:18:30,059
bulletproof is already simulation

436
00:18:30,059 --> 00:18:32,580
extractable say in random Oracle with

437
00:18:32,580 --> 00:18:35,340
programming then you could use maybe an

438
00:18:35,340 --> 00:18:37,919
R trick like you can have an organ

439
00:18:37,919 --> 00:18:40,080
position and then you can have straight

440
00:18:40,080 --> 00:18:42,120
line simulation without programming the

441
00:18:42,120 --> 00:18:43,980
random Oracle okay

442
00:18:43,980 --> 00:18:46,520
thanks

443
00:18:48,299 --> 00:18:52,340
okay let's thank mahak again okay

444
00:18:57,050 --> 00:18:59,220
[Applause]

445
00:18:59,220 --> 00:19:01,400
foreign

446
00:19:17,059 --> 00:19:19,679
hardness from the decisional defi helmet

447
00:19:19,679 --> 00:19:22,260
assumption by Yale kalai Alex Lombardi

448
00:19:22,260 --> 00:19:24,120
and vinod by contanathan and Alex will

449
00:19:24,120 --> 00:19:25,200
give the talk

450
00:19:25,200 --> 00:19:27,299
hey everyone I'm Alex and yeah I'll be

451
00:19:27,299 --> 00:19:28,980
talking about joint work with yalakalai

452
00:19:28,980 --> 00:19:32,640
and vinod by kunzanathan on snarks and

453
00:19:32,640 --> 00:19:35,179
related objects from ddh

454
00:19:35,179 --> 00:19:38,760
so the setting for this talk is fairly

455
00:19:38,760 --> 00:19:40,440
similar to what you heard about in the

456
00:19:40,440 --> 00:19:42,720
last talk although we look at snarks

457
00:19:42,720 --> 00:19:44,220
from a bit of a different perspective so

458
00:19:44,220 --> 00:19:46,260
I'll go through the definitions again

459
00:19:46,260 --> 00:19:51,419
uh so uh snark is a one message uh

460
00:19:51,419 --> 00:19:53,940
succinct easy to verify computationally

461
00:19:53,940 --> 00:19:56,580
sound proof system and so what that

462
00:19:56,580 --> 00:19:57,720
means is you have a prover and a

463
00:19:57,720 --> 00:20:00,059
verifier the prover wants to prove some

464
00:20:00,059 --> 00:20:01,919
claim to the verifier the claim is

465
00:20:01,919 --> 00:20:04,980
represented as a string X which is

466
00:20:04,980 --> 00:20:06,780
supposed to be in some agreed upon

467
00:20:06,780 --> 00:20:09,780
language L uh and uh and there and there

468
00:20:09,780 --> 00:20:12,000
will be a common reference string for

469
00:20:12,000 --> 00:20:13,440
the purposes of this talk you can always

470
00:20:13,440 --> 00:20:15,660
think of that as a random string to help

471
00:20:15,660 --> 00:20:18,059
the prover generate the proof uh the so

472
00:20:18,059 --> 00:20:19,679
the prover generates a proof string Pi

473
00:20:19,679 --> 00:20:22,320
the verifier then takes the proof and

474
00:20:22,320 --> 00:20:23,880
the reference string and decides whether

475
00:20:23,880 --> 00:20:25,260
or not to accept

476
00:20:25,260 --> 00:20:27,299
and you want that if the claim is true

477
00:20:27,299 --> 00:20:29,460
and the prover acts honestly the

478
00:20:29,460 --> 00:20:32,520
verifier should always accept uh and if

479
00:20:32,520 --> 00:20:34,799
the claim is false and the prover is

480
00:20:34,799 --> 00:20:36,960
computationally efficient uh then the

481
00:20:36,960 --> 00:20:39,120
verifier should almost always reject

482
00:20:39,120 --> 00:20:41,460
and you want the proof length to be very

483
00:20:41,460 --> 00:20:43,140
short say like polynomial and the

484
00:20:43,140 --> 00:20:45,179
security parameter and verification to

485
00:20:45,179 --> 00:20:46,919
also be very fast say polynomial on the

486
00:20:46,919 --> 00:20:48,600
security parameter plus like reading the

487
00:20:48,600 --> 00:20:50,340
statement or something like that

488
00:20:50,340 --> 00:20:54,240
so this is the basic object uh and in uh

489
00:20:54,240 --> 00:20:56,400
in theoretical cryptography it's a like

490
00:20:56,400 --> 00:21:00,179
big open question to understand uh to

491
00:21:00,179 --> 00:21:02,340
what extent and when snargs exist like

492
00:21:02,340 --> 00:21:03,780
for Which languages do they exist and

493
00:21:03,780 --> 00:21:05,520
under what computational assumptions uh

494
00:21:05,520 --> 00:21:07,799
can we base them so a big difference

495
00:21:07,799 --> 00:21:10,080
from the last talk is that uh is that in

496
00:21:10,080 --> 00:21:12,419
in this work we're focused on

497
00:21:12,419 --> 00:21:14,460
constructing snarks from falsifiable

498
00:21:14,460 --> 00:21:15,900
assumptions and so we don't want to make

499
00:21:15,900 --> 00:21:17,940
use of things like random oracles or

500
00:21:17,940 --> 00:21:19,200
knowledge assumptions or anything like

501
00:21:19,200 --> 00:21:20,100
that

502
00:21:20,100 --> 00:21:22,620
uh so uh so that's the that's the focus

503
00:21:22,620 --> 00:21:26,700
for for today uh and uh and in like full

504
00:21:26,700 --> 00:21:28,020
generality this seems like a very

505
00:21:28,020 --> 00:21:30,059
difficult problem so uh so we're

506
00:21:30,059 --> 00:21:32,580
focusing on snarks for deterministic

507
00:21:32,580 --> 00:21:35,039
computations uh so the languages are all

508
00:21:35,039 --> 00:21:36,960
going to be uh in polynomial time and

509
00:21:36,960 --> 00:21:38,280
there's not going to be an NP witness

510
00:21:38,280 --> 00:21:41,400
that the approver has to take care of

511
00:21:41,400 --> 00:21:44,039
so uh so that's our setting

512
00:21:44,039 --> 00:21:47,880
uh so what do we do uh I'll give you our

513
00:21:47,880 --> 00:21:51,539
results uh so our main result is that uh

514
00:21:51,539 --> 00:21:54,900
assuming the sub-exponential hardness of

515
00:21:54,900 --> 00:21:57,659
decisional diffie-hellman so as uh as

516
00:21:57,659 --> 00:22:00,179
you're used to uh over nice enough

517
00:22:00,179 --> 00:22:02,820
cryptographic groups which

518
00:22:02,820 --> 00:22:05,700
you know for for your intuition just it

519
00:22:05,700 --> 00:22:07,679
includes you know subgroups of zp star

520
00:22:07,679 --> 00:22:10,200
and things like this uh you know under

521
00:22:10,200 --> 00:22:12,500
this assumption we can build snarks for

522
00:22:12,500 --> 00:22:15,240
bounded depth deterministic computations

523
00:22:15,240 --> 00:22:18,960
uh so the proof length is uh you know

524
00:22:18,960 --> 00:22:21,480
grows linearly with the depth uh and the

525
00:22:21,480 --> 00:22:23,220
verification time grows linearly with

526
00:22:23,220 --> 00:22:25,860
the depth to end with the input length

527
00:22:25,860 --> 00:22:28,200
uh so yeah so this is a snark when you

528
00:22:28,200 --> 00:22:30,419
restrict to bound to depth computations

529
00:22:30,419 --> 00:22:33,120
uh moreover uh the snargs we construct

530
00:22:33,120 --> 00:22:34,500
have some nice additional properties

531
00:22:34,500 --> 00:22:36,659
like unambiguity which means that

532
00:22:36,659 --> 00:22:38,520
basically not only can you not prove

533
00:22:38,520 --> 00:22:40,799
false claims but that there is a unique

534
00:22:40,799 --> 00:22:43,380
proof for uh for True claims and you

535
00:22:43,380 --> 00:22:44,940
cannot give any proof other than the

536
00:22:44,940 --> 00:22:48,059
prescribed one and moreover the proofs

537
00:22:48,059 --> 00:22:50,460
are are like uh appropriately like

538
00:22:50,460 --> 00:22:53,880
updatable and composable and uh and as a

539
00:22:53,880 --> 00:22:56,400
result uh due to Prior work studying

540
00:22:56,400 --> 00:23:00,419
this kind of thing we also uh obtain uh

541
00:23:00,419 --> 00:23:03,840
hard on average instances uh in the

542
00:23:03,840 --> 00:23:05,880
complexity class p-pad which which

543
00:23:05,880 --> 00:23:07,980
captures uh the problem of finding Nash

544
00:23:07,980 --> 00:23:09,120
equilibrium

545
00:23:09,120 --> 00:23:14,100
uh in uh in uh in biometric schemes uh

546
00:23:14,100 --> 00:23:16,080
so yeah we get hard instances and ppad

547
00:23:16,080 --> 00:23:18,120
uh assuming that uh that ddh is

548
00:23:18,120 --> 00:23:20,220
sub-exponentially hard and this this

549
00:23:20,220 --> 00:23:22,080
basically follows black box from prior

550
00:23:22,080 --> 00:23:24,120
work given the the snark that we write

551
00:23:24,120 --> 00:23:25,380
down

552
00:23:25,380 --> 00:23:28,740
so these are our uh two main results

553
00:23:28,740 --> 00:23:31,799
uh so uh I'll also mention there is a

554
00:23:31,799 --> 00:23:34,020
there's a concurrent work uh that's that

555
00:23:34,020 --> 00:23:35,760
collides with our our first result the

556
00:23:35,760 --> 00:23:37,559
bound to depth snarks so there's a

557
00:23:37,559 --> 00:23:39,480
there's a cool work of chaturi at all

558
00:23:39,480 --> 00:23:42,960
who that constructs uh snarks for all

559
00:23:42,960 --> 00:23:45,299
polynomial time computation so no no

560
00:23:45,299 --> 00:23:47,520
depth restriction at all uh from sub

561
00:23:47,520 --> 00:23:51,000
exponential ddh uh so uh so because they

562
00:23:51,000 --> 00:23:52,860
get snarks for p this is uh this is

563
00:23:52,860 --> 00:23:54,240
better than what we can do but the

564
00:23:54,240 --> 00:23:56,159
results are incomparable because uh

565
00:23:56,159 --> 00:23:58,860
because they're stuck with the the

566
00:23:58,860 --> 00:24:02,220
amount of security they can get is uh is

567
00:24:02,220 --> 00:24:04,380
below sub exponential so even though

568
00:24:04,380 --> 00:24:05,640
you're making a sub-exponential

569
00:24:05,640 --> 00:24:07,620
assumption the construction because of

570
00:24:07,620 --> 00:24:09,659
the complexity leveraging that happens

571
00:24:09,659 --> 00:24:12,120
can't get some exponential security so

572
00:24:12,120 --> 00:24:14,220
it's a cool open question I think to get

573
00:24:14,220 --> 00:24:16,140
the best of both worlds here to get uh

574
00:24:16,140 --> 00:24:19,320
snargs for all of p with the with the

575
00:24:19,320 --> 00:24:21,179
with the sort of best possible security

576
00:24:21,179 --> 00:24:24,419
level uh from uh from ddh

577
00:24:24,419 --> 00:24:26,100
uh

578
00:24:26,100 --> 00:24:28,559
so uh that's all I want to say on the

579
00:24:28,559 --> 00:24:30,240
results statements so now for the rest

580
00:24:30,240 --> 00:24:31,980
of the talk I'll tell you a bit about

581
00:24:31,980 --> 00:24:34,980
how we uh how we prove this uh so the

582
00:24:34,980 --> 00:24:38,460
idea uh is uh is to instantiate the

583
00:24:38,460 --> 00:24:41,159
theater heuristic under uh falsifiable

584
00:24:41,159 --> 00:24:42,900
assumptions in particular uh under

585
00:24:42,900 --> 00:24:46,380
sub-exponential ddh uh for uh for

586
00:24:46,380 --> 00:24:48,840
protocols that uh that give you snarks

587
00:24:48,840 --> 00:24:50,880
for bound to depth and hard p-pad

588
00:24:50,880 --> 00:24:53,580
instances so uh so for the Snorks result

589
00:24:53,580 --> 00:24:57,600
for example we uh we we focus on the the

590
00:24:57,600 --> 00:24:59,820
succinct interactive proof system of

591
00:24:59,820 --> 00:25:03,000
goldblaster kalai and rothbloom gkr uh

592
00:25:03,000 --> 00:25:04,559
which which works for bound to depth

593
00:25:04,559 --> 00:25:05,940
computations

594
00:25:05,940 --> 00:25:07,860
uh so yeah so we're focused on

595
00:25:07,860 --> 00:25:09,960
instantiating theater mirror for certain

596
00:25:09,960 --> 00:25:11,760
interactive proofs

597
00:25:11,760 --> 00:25:14,580
so I'll give a quick reminder on uh on

598
00:25:14,580 --> 00:25:17,640
fiatrimir uh so the feature transform is

599
00:25:17,640 --> 00:25:21,679
a very general Paradigm for converting

600
00:25:21,679 --> 00:25:24,840
interactive protocols into uh into

601
00:25:24,840 --> 00:25:27,000
non-interactive protocols so if you

602
00:25:27,000 --> 00:25:29,279
start with a interactive protocol that

603
00:25:29,279 --> 00:25:31,380
is public coin so you assume that every

604
00:25:31,380 --> 00:25:34,559
verifier message is just an IID random

605
00:25:34,559 --> 00:25:37,380
string then the theater transform will

606
00:25:37,380 --> 00:25:40,020
turn it into a non-interactive argument

607
00:25:40,020 --> 00:25:42,240
system for the at least that candidates

608
00:25:42,240 --> 00:25:44,640
non-interactive argument system for the

609
00:25:44,640 --> 00:25:47,820
same problem uh and uh and the way this

610
00:25:47,820 --> 00:25:49,679
is done is the proverb and verifier make

611
00:25:49,679 --> 00:25:51,360
use of some publicly known hash function

612
00:25:51,360 --> 00:25:52,140
h

613
00:25:52,140 --> 00:25:55,020
uh and the prover generates an entire

614
00:25:55,020 --> 00:25:56,760
transcript of the interactive protocol

615
00:25:56,760 --> 00:25:59,340
in one shot uh using the hash function

616
00:25:59,340 --> 00:26:02,640
to generate the verifiers messages so uh

617
00:26:02,640 --> 00:26:04,799
that is for each uh for each verifier

618
00:26:04,799 --> 00:26:08,640
message beta I uh that uh would normally

619
00:26:08,640 --> 00:26:10,620
be sampled by the verifier the prover

620
00:26:10,620 --> 00:26:12,539
just computes it as a hash of the

621
00:26:12,539 --> 00:26:14,220
transcript prefix everything that has

622
00:26:14,220 --> 00:26:16,919
happened so far in the protocol uh and

623
00:26:16,919 --> 00:26:19,500
by iteratively doing this the prover can

624
00:26:19,500 --> 00:26:22,020
generate all the verifier messages and

625
00:26:22,020 --> 00:26:24,659
all of its its own messages at once and

626
00:26:24,659 --> 00:26:26,460
send them all over to the verifier the

627
00:26:26,460 --> 00:26:29,039
verifier checks uh that the hashes were

628
00:26:29,039 --> 00:26:30,659
computed correctly and checks that the

629
00:26:30,659 --> 00:26:33,419
transcript would have been accepted in

630
00:26:33,419 --> 00:26:35,100
the interactive protocol

631
00:26:35,100 --> 00:26:37,919
uh so this is uh this is syntactically

632
00:26:37,919 --> 00:26:40,799
how the transformation Works uh and it's

633
00:26:40,799 --> 00:26:43,740
it's sort of uh like by inspection like

634
00:26:43,740 --> 00:26:46,200
preserves completeness uh the verifier

635
00:26:46,200 --> 00:26:47,640
will accept if the approver is being

636
00:26:47,640 --> 00:26:49,679
honest and the statement is true and

637
00:26:49,679 --> 00:26:52,799
heuristically uh the transformation also

638
00:26:52,799 --> 00:26:55,799
preserves soundness uh

639
00:26:55,799 --> 00:26:57,020
so so

640
00:26:57,020 --> 00:26:59,580
let me give a couple of more details on

641
00:26:59,580 --> 00:27:02,460
this so uh yeah so the big question is

642
00:27:02,460 --> 00:27:05,100
under what uh under what conditions is

643
00:27:05,100 --> 00:27:07,140
this transformation actually secure

644
00:27:07,140 --> 00:27:09,840
uh and uh and we've known for a long

645
00:27:09,840 --> 00:27:12,240
time that it's secure very very

646
00:27:12,240 --> 00:27:14,640
generally in the random Oracle model for

647
00:27:14,640 --> 00:27:16,620
example if you take any constant round

648
00:27:16,620 --> 00:27:19,440
public coin interactive protocol and you

649
00:27:19,440 --> 00:27:21,299
model the hash function as a random

650
00:27:21,299 --> 00:27:23,220
Oracle so you model the adversary is

651
00:27:23,220 --> 00:27:25,559
only having query access to this hash

652
00:27:25,559 --> 00:27:27,299
function and treat the hash function as

653
00:27:27,299 --> 00:27:30,059
a random function then uh then the

654
00:27:30,059 --> 00:27:31,679
theater mirror non-interactive protocol

655
00:27:31,679 --> 00:27:33,360
will will be sound

656
00:27:33,360 --> 00:27:37,440
uh so this is good uh and so uh and so

657
00:27:37,440 --> 00:27:39,779
in practice you can then instantiate uh

658
00:27:39,779 --> 00:27:41,640
the hash function with some complicated

659
00:27:41,640 --> 00:27:45,000
looking thing like uh like sha2 and uh

660
00:27:45,000 --> 00:27:47,640
and hope that the the random Oracle

661
00:27:47,640 --> 00:27:50,220
analysis uh

662
00:27:50,220 --> 00:27:53,159
like doesn't apply per se but it's at

663
00:27:53,159 --> 00:27:54,600
least uh it's at least a justification

664
00:27:54,600 --> 00:27:56,340
for the security and then you can hope

665
00:27:56,340 --> 00:27:58,320
that it's secure in practice and this is

666
00:27:58,320 --> 00:28:00,960
this is borne out quite frequently

667
00:28:00,960 --> 00:28:03,600
um on the other hand in theory we know

668
00:28:03,600 --> 00:28:05,820
that the transformation is insecure uh

669
00:28:05,820 --> 00:28:07,980
in the following sense uh we know that

670
00:28:07,980 --> 00:28:09,600
there are at least some interactive

671
00:28:09,600 --> 00:28:10,980
protocols where the random Oracle

672
00:28:10,980 --> 00:28:13,200
heuristic would predict Security in the

673
00:28:13,200 --> 00:28:16,380
non-interactive setting uh but uh but

674
00:28:16,380 --> 00:28:18,539
such that like unconditionally there is

675
00:28:18,539 --> 00:28:20,400
no efficiently computable hash function

676
00:28:20,400 --> 00:28:23,100
family that you can use uh resulting in

677
00:28:23,100 --> 00:28:24,840
a secure protocol so it will always be

678
00:28:24,840 --> 00:28:26,700
insecure no matter what hash function

679
00:28:26,700 --> 00:28:27,600
you use

680
00:28:27,600 --> 00:28:31,080
uh so that's uh that's bad but the uh

681
00:28:31,080 --> 00:28:33,779
but the examples are are very contrived

682
00:28:33,779 --> 00:28:35,700
and not things that you would like

683
00:28:35,700 --> 00:28:38,880
likely want to uh not protocols that you

684
00:28:38,880 --> 00:28:41,460
would come up with on your own to like

685
00:28:41,460 --> 00:28:43,320
like achieve some Positive Purpose

686
00:28:43,320 --> 00:28:45,179
they're they're yeah they're contrived

687
00:28:45,179 --> 00:28:47,279
examples demonstrating the insecurity of

688
00:28:47,279 --> 00:28:50,820
the Paradigm uh so it's uh we've been

689
00:28:50,820 --> 00:28:52,980
trying to understand for a long time you

690
00:28:52,980 --> 00:28:54,659
know under what conditions can we

691
00:28:54,659 --> 00:28:56,340
actually prove security of the

692
00:28:56,340 --> 00:28:59,039
transformation uh so yeah especially

693
00:28:59,039 --> 00:29:01,620
over the last say five years uh we spent

694
00:29:01,620 --> 00:29:03,960
a lot of time uh

695
00:29:03,960 --> 00:29:05,940
thinking about you know particular

696
00:29:05,940 --> 00:29:07,679
protocols that we care about and trying

697
00:29:07,679 --> 00:29:09,500
to argue security of the transformation

698
00:29:09,500 --> 00:29:12,240
for appropriately chosen hash function

699
00:29:12,240 --> 00:29:13,799
families based on falsifiable

700
00:29:13,799 --> 00:29:15,299
assumptions like learning with errors

701
00:29:15,299 --> 00:29:17,700
and decisional diffie-hellman

702
00:29:17,700 --> 00:29:20,520
uh so and and this uh work is uh is uh

703
00:29:20,520 --> 00:29:23,940
one in uh in a long line of such results

704
00:29:23,940 --> 00:29:27,120
uh so how did these results work well we

705
00:29:27,120 --> 00:29:29,399
make use of a

706
00:29:29,399 --> 00:29:32,039
specific security property or Family

707
00:29:32,039 --> 00:29:34,140
Security family of security properties

708
00:29:34,140 --> 00:29:37,200
of of the hash function family uh and

709
00:29:37,200 --> 00:29:39,000
the the prop the family of properties is

710
00:29:39,000 --> 00:29:41,279
called correlation intractability so for

711
00:29:41,279 --> 00:29:43,380
today uh we'll say that a hash function

712
00:29:43,380 --> 00:29:45,419
family is correlation and tractable for

713
00:29:45,419 --> 00:29:48,779
a function f if it is computationally

714
00:29:48,779 --> 00:29:51,720
hard to find an input x to the hash

715
00:29:51,720 --> 00:29:54,179
function such that hash of X is equal to

716
00:29:54,179 --> 00:29:56,460
f of x so it's finding an F correlation

717
00:29:56,460 --> 00:29:59,580
in in the hash function the inputs and

718
00:29:59,580 --> 00:30:00,960
output of the hash function are

719
00:30:00,960 --> 00:30:03,179
correlated by f

720
00:30:03,179 --> 00:30:06,360
uh so uh yeah so of course a random

721
00:30:06,360 --> 00:30:07,799
Oracle will will be correlation

722
00:30:07,799 --> 00:30:09,480
intractable because every time that you

723
00:30:09,480 --> 00:30:11,399
call the Oracle you're very unlikely to

724
00:30:11,399 --> 00:30:14,480
find any fixed correlation

725
00:30:14,480 --> 00:30:17,399
uh so uh so

726
00:30:17,399 --> 00:30:19,980
this family of security properties has

727
00:30:19,980 --> 00:30:21,419
been used to Great effects to

728
00:30:21,419 --> 00:30:23,279
instantiate fiatrimir in the plane model

729
00:30:23,279 --> 00:30:25,500
and the basic idea is that for many

730
00:30:25,500 --> 00:30:27,720
interactive protocols Pi that you care

731
00:30:27,720 --> 00:30:32,940
about you can uh phrase uh the soundness

732
00:30:32,940 --> 00:30:35,340
of the interactive protocol uh using

733
00:30:35,340 --> 00:30:37,320
what are called bad challenge functions

734
00:30:37,320 --> 00:30:39,240
so basically you want to say that uh

735
00:30:39,240 --> 00:30:42,840
whenever the prover is uh is uh when the

736
00:30:42,840 --> 00:30:45,539
approver sends some message uh the

737
00:30:45,539 --> 00:30:47,340
verifier in the interactive protocol is

738
00:30:47,340 --> 00:30:50,399
sending back a random string uh and uh

739
00:30:50,399 --> 00:30:52,740
and in the protocol the analysis will

740
00:30:52,740 --> 00:30:55,799
say that uh that's unless the verifier

741
00:30:55,799 --> 00:31:00,179
sends one of a very small set of bad

742
00:31:00,179 --> 00:31:02,700
challenges uh then the approver will be

743
00:31:02,700 --> 00:31:04,320
like even information theoretically

744
00:31:04,320 --> 00:31:06,840
unable to cheat uh so then you could

745
00:31:06,840 --> 00:31:08,460
hope to use correlation interactability

746
00:31:08,460 --> 00:31:10,740
to argue about fiatrimir by saying

747
00:31:10,740 --> 00:31:12,720
that's well what you really want out of

748
00:31:12,720 --> 00:31:14,340
the hash function is that the prover

749
00:31:14,340 --> 00:31:16,320
should be unable to find an input to the

750
00:31:16,320 --> 00:31:18,960
hash function that maps to one of these

751
00:31:18,960 --> 00:31:21,360
bad challenges if if you if you do not

752
00:31:21,360 --> 00:31:22,980
do that then the approval will be unable

753
00:31:22,980 --> 00:31:25,559
to uh unable to cheat in the protocol so

754
00:31:25,559 --> 00:31:27,299
that's Loosely how correlation

755
00:31:27,299 --> 00:31:29,760
attractability is related to fiatrimir

756
00:31:29,760 --> 00:31:34,260
uh and so uh and so for today uh the the

757
00:31:34,260 --> 00:31:36,240
main point is that we want to rely on as

758
00:31:36,240 --> 00:31:37,620
weak a form of correlation and

759
00:31:37,620 --> 00:31:39,600
tractability as possible in particular

760
00:31:39,600 --> 00:31:41,340
we'll assume correlation attractability

761
00:31:41,340 --> 00:31:43,500
for a you know restricted class of

762
00:31:43,500 --> 00:31:45,779
functions and the smaller the class of

763
00:31:45,779 --> 00:31:48,000
functions we can make use of uh the

764
00:31:48,000 --> 00:31:49,380
weaker the assumption that we're making

765
00:31:49,380 --> 00:31:51,360
and the more hope we have of building

766
00:31:51,360 --> 00:31:52,740
this object

767
00:31:52,740 --> 00:31:54,659
so in particular

768
00:31:54,659 --> 00:31:55,260
um

769
00:31:55,260 --> 00:31:57,960
we're going to use uh off-the-shelf uh

770
00:31:57,960 --> 00:32:00,120
hash function family of Jane and jyn uh

771
00:32:00,120 --> 00:32:02,640
based on sub-exponential ddh which is

772
00:32:02,640 --> 00:32:04,080
correlation intractable for all

773
00:32:04,080 --> 00:32:06,960
functions F that are computable in tc0

774
00:32:06,960 --> 00:32:09,360
that is computable by constant depth

775
00:32:09,360 --> 00:32:12,600
threshold circuits uh so that's the so

776
00:32:12,600 --> 00:32:15,360
we're not going to build a stronger hash

777
00:32:15,360 --> 00:32:16,679
function today we're going to we're

778
00:32:16,679 --> 00:32:18,179
going to make use of this this exact

779
00:32:18,179 --> 00:32:19,980
hash function and so the question is

780
00:32:19,980 --> 00:32:21,539
well can we make use of correlation and

781
00:32:21,539 --> 00:32:23,640
tractability for tc0 to reason about

782
00:32:23,640 --> 00:32:25,740
fiatrimir for protocols that we care

783
00:32:25,740 --> 00:32:26,700
about

784
00:32:26,700 --> 00:32:30,899
and uh so so for uh to give you an idea

785
00:32:30,899 --> 00:32:33,779
of how the how the results works I'm

786
00:32:33,779 --> 00:32:35,700
going to focus on the some check

787
00:32:35,700 --> 00:32:38,640
protocol which is a subroutine of the

788
00:32:38,640 --> 00:32:40,980
like the sort of a crucial subroutine of

789
00:32:40,980 --> 00:32:42,600
the of the protocols that we actually

790
00:32:42,600 --> 00:32:45,840
care about uh so uh in the subject

791
00:32:45,840 --> 00:32:48,000
protocol uh the proofer and verifier

792
00:32:48,000 --> 00:32:50,460
have the description of a polynomial G

793
00:32:50,460 --> 00:32:54,480
in N variables that has degree d uh and

794
00:32:54,480 --> 00:32:58,020
the claim is that if you uh sum G of X

795
00:32:58,020 --> 00:33:02,100
over all X in the Boolean hypercube uh

796
00:33:02,100 --> 00:33:04,500
that you get some particular output some

797
00:33:04,500 --> 00:33:07,080
or some particular field elements why so

798
00:33:07,080 --> 00:33:09,360
that's the that's the claim that uh in

799
00:33:09,360 --> 00:33:11,760
the subject protocol and as a quick

800
00:33:11,760 --> 00:33:12,960
reminder the way that the subject

801
00:33:12,960 --> 00:33:16,500
protocol works is uh is is uh is by a

802
00:33:16,500 --> 00:33:19,919
recursive procedure uh so uh the

803
00:33:19,919 --> 00:33:21,539
interactive protocol reduces the number

804
00:33:21,539 --> 00:33:23,640
of variables by one in each step

805
00:33:23,640 --> 00:33:25,980
uh and and so what what the prover does

806
00:33:25,980 --> 00:33:28,880
is it sends a univariate polynomial G1

807
00:33:28,880 --> 00:33:32,580
uh who's uh who's whose input variable

808
00:33:32,580 --> 00:33:34,260
is the first variable of the

809
00:33:34,260 --> 00:33:37,260
multivariate polynomial G uh where where

810
00:33:37,260 --> 00:33:39,779
G1 is supposed to uh be the polynomial

811
00:33:39,779 --> 00:33:42,000
that you get when you sum out all of the

812
00:33:42,000 --> 00:33:44,399
other variables uh over the hypercube so

813
00:33:44,399 --> 00:33:45,480
you just leave the first variable

814
00:33:45,480 --> 00:33:48,000
indeterminate and sum over all the other

815
00:33:48,000 --> 00:33:50,880
ones uh so if the prover sends the

816
00:33:50,880 --> 00:33:53,039
correct polynomial then the verifier

817
00:33:53,039 --> 00:33:55,019
would would be able to add up its

818
00:33:55,019 --> 00:33:58,080
evaluations on zero and one uh and they

819
00:33:58,080 --> 00:34:00,000
would get and the verifier would get the

820
00:34:00,000 --> 00:34:02,399
correct uh output Y unless the prover is

821
00:34:02,399 --> 00:34:05,039
lying somewhere so the verifier will

822
00:34:05,039 --> 00:34:06,779
check this condition and assuming it's

823
00:34:06,779 --> 00:34:09,119
met the verifier just samples a random

824
00:34:09,119 --> 00:34:12,119
uh field element uh that's uh the

825
00:34:12,119 --> 00:34:14,460
proverb and verifier then treat as uh

826
00:34:14,460 --> 00:34:16,980
the first in like substitute the first

827
00:34:16,980 --> 00:34:19,739
input variable uh they substitute this

828
00:34:19,739 --> 00:34:21,179
uh field element in for the first

829
00:34:21,179 --> 00:34:25,080
variable so now you have a polynomial in

830
00:34:25,080 --> 00:34:28,440
uh in N minus one variables uh and uh

831
00:34:28,440 --> 00:34:30,060
and there's a particular Claim about it

832
00:34:30,060 --> 00:34:31,980
of the same form that we started with

833
00:34:31,980 --> 00:34:35,119
and so we can recurse

834
00:34:35,280 --> 00:34:39,719
so uh so the the so how do you analyze

835
00:34:39,719 --> 00:34:42,119
the soundness of this protocol well so

836
00:34:42,119 --> 00:34:43,800
what can happen like the what can happen

837
00:34:43,800 --> 00:34:45,719
is that the prover can lie about what

838
00:34:45,719 --> 00:34:47,940
this polynomial G1 is like that's what

839
00:34:47,940 --> 00:34:49,918
can go wrong uh in particular if the

840
00:34:49,918 --> 00:34:51,359
claim is false and the prover doesn't

841
00:34:51,359 --> 00:34:53,219
lie then the verifier is just going to

842
00:34:53,219 --> 00:34:54,839
immediately reject because the sum is

843
00:34:54,839 --> 00:34:57,300
not correct uh so the thing you have to

844
00:34:57,300 --> 00:34:58,859
worry about is if the prover lies about

845
00:34:58,859 --> 00:35:02,520
about G1 uh and so it turns out that you

846
00:35:02,520 --> 00:35:05,640
can argue that the prover is uh unable

847
00:35:05,640 --> 00:35:10,099
to cheat uh as long as the challenge R1

848
00:35:10,099 --> 00:35:14,099
is not a root of the difference uh

849
00:35:14,099 --> 00:35:16,859
between the correct polynomial that the

850
00:35:16,859 --> 00:35:18,900
prover was supposed to send and the

851
00:35:18,900 --> 00:35:21,119
polynomial the prover actually sent so

852
00:35:21,119 --> 00:35:22,920
this is the this is the key point that

853
00:35:22,920 --> 00:35:24,839
the bad challenges for this protocol or

854
00:35:24,839 --> 00:35:27,480
for this one reduction step in the

855
00:35:27,480 --> 00:35:29,460
protocol are the roots of a particular

856
00:35:29,460 --> 00:35:31,980
polynomial that you can compute

857
00:35:31,980 --> 00:35:35,280
uh so so what we do in this work is we

858
00:35:35,280 --> 00:35:37,380
instantiate fiatrimir for variance of

859
00:35:37,380 --> 00:35:40,380
the subject protocol uh based on weak

860
00:35:40,380 --> 00:35:42,599
forms of correlation intractability and

861
00:35:42,599 --> 00:35:43,800
the main

862
00:35:43,800 --> 00:35:46,200
like uh main problem that we're dealing

863
00:35:46,200 --> 00:35:48,720
with is that root finding of polynomials

864
00:35:48,720 --> 00:35:50,760
in general is that is actually a pretty

865
00:35:50,760 --> 00:35:52,440
complex computation and can't be done in

866
00:35:52,440 --> 00:35:54,540
constant depth so the typical examples

867
00:35:54,540 --> 00:35:56,280
to have in mind is that even for degree

868
00:35:56,280 --> 00:35:58,920
one polynomials say over uh over a prime

869
00:35:58,920 --> 00:36:02,339
uh order Fields uh this is uh like the

870
00:36:02,339 --> 00:36:03,839
root finding problem is just like

871
00:36:03,839 --> 00:36:05,700
Computing modular inverses and when the

872
00:36:05,700 --> 00:36:07,740
prime is large we expect this to require

873
00:36:07,740 --> 00:36:10,800
High depth and in general like for any

874
00:36:10,800 --> 00:36:13,280
fields

875
00:36:13,800 --> 00:36:16,800
for any Fields uh for like for for

876
00:36:16,800 --> 00:36:19,320
General d uh all the algorithms that we

877
00:36:19,320 --> 00:36:21,300
know also also are high depth for sort

878
00:36:21,300 --> 00:36:23,339
of uh orthogonal reasons so so we we

879
00:36:23,339 --> 00:36:25,440
don't really have low depth algorithms

880
00:36:25,440 --> 00:36:28,020
for root finding and the way that we uh

881
00:36:28,020 --> 00:36:29,400
the way that we deal with this is we

882
00:36:29,400 --> 00:36:31,320
focus on a very very very special case

883
00:36:31,320 --> 00:36:35,400
we focus on degree three some checks and

884
00:36:35,400 --> 00:36:38,160
we pick a uh pick our Fields very

885
00:36:38,160 --> 00:36:40,500
carefully so the so the two main ideas

886
00:36:40,500 --> 00:36:42,660
in the results is that we have a T

887
00:36:42,660 --> 00:36:44,760
Series we write down a new tc0 algorithm

888
00:36:44,760 --> 00:36:46,440
for finding roots of degree three

889
00:36:46,440 --> 00:36:48,540
polynomials over a special family of

890
00:36:48,540 --> 00:36:50,520
fields due to helium viola

891
00:36:50,520 --> 00:36:53,339
and the idea is that instead of thinking

892
00:36:53,339 --> 00:36:55,140
about these like general purpose root

893
00:36:55,140 --> 00:36:57,839
finding algorithms uh we use the fact

894
00:36:57,839 --> 00:36:59,460
that in degree three there are actually

895
00:36:59,460 --> 00:37:01,680
explicit formulas for for roots of

896
00:37:01,680 --> 00:37:04,079
polynomials and you can view the

897
00:37:04,079 --> 00:37:06,480
characteristic to cubic formula as

898
00:37:06,480 --> 00:37:08,160
actually sort of a low depth Oracle

899
00:37:08,160 --> 00:37:10,920
algorithm that uh that will yeah you can

900
00:37:10,920 --> 00:37:12,960
view it algorithmically and turn this

901
00:37:12,960 --> 00:37:14,880
into a if you stare at it carefully

902
00:37:14,880 --> 00:37:16,680
enough turn it into a tc0 algorithm for

903
00:37:16,680 --> 00:37:18,180
for root finding

904
00:37:18,180 --> 00:37:21,119
uh and to do this we need to whatever

905
00:37:21,119 --> 00:37:23,579
construct some uh some field extension

906
00:37:23,579 --> 00:37:24,960
of the original fields to make this

907
00:37:24,960 --> 00:37:27,480
algorithm actually implementable

908
00:37:27,480 --> 00:37:29,119
and as a result we can do

909
00:37:29,119 --> 00:37:31,380
non-interactive sum checks for degree

910
00:37:31,380 --> 00:37:33,119
three polynomials from sub exponential

911
00:37:33,119 --> 00:37:34,020
dth

912
00:37:34,020 --> 00:37:36,839
and then we then like the the second

913
00:37:36,839 --> 00:37:38,700
thing that we have to do is reduce the

914
00:37:38,700 --> 00:37:40,680
you know the claims that we started with

915
00:37:40,680 --> 00:37:43,920
uh the the future mirror for protocols

916
00:37:43,920 --> 00:37:46,140
that we wanted to uh fiatrimir for

917
00:37:46,140 --> 00:37:47,940
degree three some checks and we do this

918
00:37:47,940 --> 00:37:50,160
with some like uh algebraic versions of

919
00:37:50,160 --> 00:37:52,500
cook left and style tricks basically uh

920
00:37:52,500 --> 00:37:54,540
you can ask me about it afterwards or

921
00:37:54,540 --> 00:37:56,940
check the paper for more details so

922
00:37:56,940 --> 00:37:58,800
that's uh that's all I wanted to say so

923
00:37:58,800 --> 00:38:00,359
we build snarks for bound to depth

924
00:38:00,359 --> 00:38:01,740
computations and we construct hard

925
00:38:01,740 --> 00:38:03,780
problems in p-pad based on weaker

926
00:38:03,780 --> 00:38:05,220
assumptions namely correlation

927
00:38:05,220 --> 00:38:07,280
attractability for a weak circuit class

928
00:38:07,280 --> 00:38:10,079
and uh and I think it's interesting to

929
00:38:10,079 --> 00:38:11,339
think about whether you can make a do

930
00:38:11,339 --> 00:38:13,320
with even weaker circuit classes than

931
00:38:13,320 --> 00:38:15,060
what we talk about in this paper and

932
00:38:15,060 --> 00:38:16,800
what like what you might be able to get

933
00:38:16,800 --> 00:38:19,560
out of that and uh and also think about

934
00:38:19,560 --> 00:38:21,839
like uh your favorite applications which

935
00:38:21,839 --> 00:38:23,640
of them like only care about degree

936
00:38:23,640 --> 00:38:26,280
three some checks and maybe you can find

937
00:38:26,280 --> 00:38:29,040
new instantiations as a result so thanks

938
00:38:29,040 --> 00:38:31,020
for listening

939
00:38:31,020 --> 00:38:33,980
thank you

940
00:38:36,480 --> 00:38:39,740
we have time for questions

941
00:38:44,339 --> 00:38:46,740
I will I will show my ignorance also

942
00:38:46,740 --> 00:38:48,240
sorry for arriving a bit late but very

943
00:38:48,240 --> 00:38:51,300
nice talk nice result so my question is

944
00:38:51,300 --> 00:38:52,980
kind of if you're willing to assume

945
00:38:52,980 --> 00:38:54,720
correlationary collectibility for much

946
00:38:54,720 --> 00:38:57,020
larger circuit classes does it work for

947
00:38:57,020 --> 00:38:59,760
like what do you what do you get

948
00:38:59,760 --> 00:39:02,640
um uh yeah so so for example uh theater

949
00:39:02,640 --> 00:39:05,760
for gkr was was uh and so snarks for

950
00:39:05,760 --> 00:39:07,380
band of depth were already known using

951
00:39:07,380 --> 00:39:09,540
correlation intractability for like

952
00:39:09,540 --> 00:39:12,000
polynomial time uh circuits and for in

953
00:39:12,000 --> 00:39:15,420
fact probably like some some NC was

954
00:39:15,420 --> 00:39:17,520
probably enough already and so that's

955
00:39:17,520 --> 00:39:20,579
how uh and so there's a previous result

956
00:39:20,579 --> 00:39:23,760
of uh juwale Karana kalai and Zhang that

957
00:39:23,760 --> 00:39:27,240
did it from lwe uh using more powerful

958
00:39:27,240 --> 00:39:29,820
correlation attractability uh and so

959
00:39:29,820 --> 00:39:32,099
yeah so the the question in this work

960
00:39:32,099 --> 00:39:34,680
was yeah trying to make do with as a

961
00:39:34,680 --> 00:39:35,579
weak a form of correlation

962
00:39:35,579 --> 00:39:37,740
interactability as possible

963
00:39:37,740 --> 00:39:39,480
yeah make a quick comment as well so I

964
00:39:39,480 --> 00:39:41,400
actually like Collision retractability

965
00:39:41,400 --> 00:39:44,040
also as an assumption for existing hash

966
00:39:44,040 --> 00:39:45,720
functions so that's why I'm interested

967
00:39:45,720 --> 00:39:48,720
but yeah yeah it makes sense

968
00:39:48,720 --> 00:39:50,610
Alex and move to the next talk

969
00:39:50,610 --> 00:39:58,239
[Applause]

970
00:40:05,820 --> 00:40:08,000
foreign

971
00:40:10,640 --> 00:40:13,020
carrying data from arithmetized random

972
00:40:13,020 --> 00:40:15,359
oracles by Megan Chen Alexandra ksr Tom

973
00:40:15,359 --> 00:40:17,579
Gore Jack O'Connor and Nicholas Spooner

974
00:40:17,579 --> 00:40:20,160
and Jack will give the talk

975
00:40:20,160 --> 00:40:22,560
hi everybody so my name is Jack and yeah

976
00:40:22,560 --> 00:40:23,400
I'm going to talk to you today about

977
00:40:23,400 --> 00:40:24,660
proof carrying data from mercantiles

978
00:40:24,660 --> 00:40:26,339
around the Miracles this is Joint work

979
00:40:26,339 --> 00:40:28,140
has been said with Megan Chen Alessandra

980
00:40:28,140 --> 00:40:30,540
case a Tom Gower and Nick Spooner

981
00:40:30,540 --> 00:40:32,099
so I'm going to start by introducing the

982
00:40:32,099 --> 00:40:34,800
setting and the problem that kind of PCD

983
00:40:34,800 --> 00:40:37,980
actually solves this primitive and so

984
00:40:37,980 --> 00:40:39,240
our setting is like streaming

985
00:40:39,240 --> 00:40:42,300
verification of a t step MP computations

986
00:40:42,300 --> 00:40:44,220
so in particular you're going to be

987
00:40:44,220 --> 00:40:47,160
given some some function f some initial

988
00:40:47,160 --> 00:40:49,619
States add zero and some final States at

989
00:40:49,619 --> 00:40:50,520
T

990
00:40:50,520 --> 00:40:53,460
and what we want to verify is that there

991
00:40:53,460 --> 00:40:56,099
exists oops and there exists a bunch of

992
00:40:56,099 --> 00:40:58,200
intermediate States said one to Z T

993
00:40:58,200 --> 00:41:00,240
minus one and a bunch of witnesses stop

994
00:41:00,240 --> 00:41:02,940
me zero to WT minus one such that if you

995
00:41:02,940 --> 00:41:05,220
apply the apply F kind of iteratively to

996
00:41:05,220 --> 00:41:06,839
your output every time you'll get from

997
00:41:06,839 --> 00:41:08,339
z0 to ZT

998
00:41:08,339 --> 00:41:12,180
okay so how do we actually do this and

999
00:41:12,180 --> 00:41:13,560
we can do this with I think a

1000
00:41:13,560 --> 00:41:14,820
construction called incrementally

1001
00:41:14,820 --> 00:41:18,359
verifiable computation or IVC and so it

1002
00:41:18,359 --> 00:41:19,920
looks like this picture

1003
00:41:19,920 --> 00:41:22,079
so the idea is you start off with your

1004
00:41:22,079 --> 00:41:24,180
States at zero your approver

1005
00:41:24,180 --> 00:41:25,800
is going to like compute the next day

1006
00:41:25,800 --> 00:41:27,720
said one and then I'll put a proof and

1007
00:41:27,720 --> 00:41:29,460
then in all future States the prover

1008
00:41:29,460 --> 00:41:31,859
will actually take as input the previous

1009
00:41:31,859 --> 00:41:34,200
state but also the previous proof

1010
00:41:34,200 --> 00:41:37,440
and then I put the next state and the

1011
00:41:37,440 --> 00:41:39,240
next proof okay and the next proof is

1012
00:41:39,240 --> 00:41:40,680
going to attest to the validity of two

1013
00:41:40,680 --> 00:41:43,680
things it will tell you that ZT was

1014
00:41:43,680 --> 00:41:45,780
calculated correctly from ZT minus one

1015
00:41:45,780 --> 00:41:49,380
and and also that the verifier would

1016
00:41:49,380 --> 00:41:51,180
have accepted the previous proof okay

1017
00:41:51,180 --> 00:41:53,940
the previous proof was valid okay

1018
00:41:53,940 --> 00:41:55,920
so you might be thinking this talk is

1019
00:41:55,920 --> 00:41:57,720
about proof carrying data why am I

1020
00:41:57,720 --> 00:42:00,540
talking about IVC PCD or proof carrying

1021
00:42:00,540 --> 00:42:02,520
data just generalizes this to direct to

1022
00:42:02,520 --> 00:42:06,300
basically graphs okay so

1023
00:42:06,300 --> 00:42:08,760
so now that I've introduced IVC how do

1024
00:42:08,760 --> 00:42:12,240
we actually obtain IVC so the main way

1025
00:42:12,240 --> 00:42:14,220
to get IVC is from snarks

1026
00:42:14,220 --> 00:42:17,339
and so in this the way we do this is the

1027
00:42:17,339 --> 00:42:18,960
IVC approver works as follows it's going

1028
00:42:18,960 --> 00:42:21,480
to basically run the snark prover and

1029
00:42:21,480 --> 00:42:22,800
I'm really going to simplify things here

1030
00:42:22,800 --> 00:42:24,240
for the purposes of the talk to kind of

1031
00:42:24,240 --> 00:42:25,380
get at the problem that we're trying to

1032
00:42:25,380 --> 00:42:27,420
solve but the main thing that the snack

1033
00:42:27,420 --> 00:42:29,940
prover that the IBC prover has to do is

1034
00:42:29,940 --> 00:42:32,880
run the snark prover and and the snark

1035
00:42:32,880 --> 00:42:35,760
prover has to basically like prove that

1036
00:42:35,760 --> 00:42:38,099
the snark verifier would have accepted

1037
00:42:38,099 --> 00:42:40,740
the previous proof okay this is the

1038
00:42:40,740 --> 00:42:44,420
important point Okay so

1039
00:42:44,420 --> 00:42:47,400
uh yeah so that we've kind of talked

1040
00:42:47,400 --> 00:42:48,359
about how we're actually going to get

1041
00:42:48,359 --> 00:42:50,760
like snarks or how we're going to get

1042
00:42:50,760 --> 00:42:52,320
how we're going to live you see and

1043
00:42:52,320 --> 00:42:54,060
where do we get our snarks from well to

1044
00:42:54,060 --> 00:42:56,339
get our snarks one approach is to kind

1045
00:42:56,339 --> 00:42:57,540
of do it in the common reference string

1046
00:42:57,540 --> 00:42:59,700
model but this required with some

1047
00:42:59,700 --> 00:43:01,619
knowledge assumptions but for the

1048
00:43:01,619 --> 00:43:03,240
purposes of our work we're going to work

1049
00:43:03,240 --> 00:43:05,220
in the random Oracle model and because

1050
00:43:05,220 --> 00:43:06,780
we get some nice things like some

1051
00:43:06,780 --> 00:43:08,220
efficiency improvements and like we get

1052
00:43:08,220 --> 00:43:11,939
transparent setup and

1053
00:43:12,440 --> 00:43:14,819
verifier have access to random Oracle

1054
00:43:14,819 --> 00:43:16,800
okay now this introduces some kind of

1055
00:43:16,800 --> 00:43:20,119
tension and the reason is because

1056
00:43:20,119 --> 00:43:23,040
snarks are designed to prove non-oracle

1057
00:43:23,040 --> 00:43:26,040
computations okay but now the snark

1058
00:43:26,040 --> 00:43:27,900
prover has to prove that the snaric

1059
00:43:27,900 --> 00:43:31,680
verifier would accept a proof okay

1060
00:43:31,680 --> 00:43:33,660
and the sonaric verifier accesses the

1061
00:43:33,660 --> 00:43:36,180
random Oracle so the snark prover now

1062
00:43:36,180 --> 00:43:37,980
has to prove a statement about the run

1063
00:43:37,980 --> 00:43:39,900
to Markle okay

1064
00:43:39,900 --> 00:43:41,520
which is the fundamental kind of

1065
00:43:41,520 --> 00:43:43,740
difficulty okay

1066
00:43:43,740 --> 00:43:45,960
so in particular like in general right

1067
00:43:45,960 --> 00:43:47,940
the verifier when so when the verifier

1068
00:43:47,940 --> 00:43:49,740
comes along to verify your the prover is

1069
00:43:49,740 --> 00:43:51,960
proof it might just have to check like

1070
00:43:51,960 --> 00:43:53,280
or you'll have to check all of the all

1071
00:43:53,280 --> 00:43:54,599
of the random queries that were made

1072
00:43:54,599 --> 00:43:56,460
okay so in general the computation can

1073
00:43:56,460 --> 00:43:58,680
be as long as the original computation

1074
00:43:58,680 --> 00:44:00,359
the prover is trying to prove

1075
00:44:00,359 --> 00:44:02,700
Okay so

1076
00:44:02,700 --> 00:44:04,800
to actually get IVC one thing we can do

1077
00:44:04,800 --> 00:44:06,300
is just heuristically instantiate this

1078
00:44:06,300 --> 00:44:07,920
random markup with some hash function

1079
00:44:07,920 --> 00:44:11,160
like sha2 okay and this has some issues

1080
00:44:11,160 --> 00:44:12,560
so

1081
00:44:12,560 --> 00:44:16,500
uh theoretically speaking one thing

1082
00:44:16,500 --> 00:44:17,819
that's not very attractive is the fact

1083
00:44:17,819 --> 00:44:19,200
that

1084
00:44:19,200 --> 00:44:20,640
um your snack is proved secure in the

1085
00:44:20,640 --> 00:44:22,020
random Oracle model

1086
00:44:22,020 --> 00:44:24,060
and now when you now you heuristically

1087
00:44:24,060 --> 00:44:25,920
instantiate your snark with some hash

1088
00:44:25,920 --> 00:44:29,040
function and then you build IVC and you

1089
00:44:29,040 --> 00:44:30,480
prove your security of IBC in the

1090
00:44:30,480 --> 00:44:32,099
standard model so you kind of like

1091
00:44:32,099 --> 00:44:33,780
switch models halfway through which

1092
00:44:33,780 --> 00:44:36,180
isn't very nice obviously

1093
00:44:36,180 --> 00:44:37,680
also whenever we actually do the

1094
00:44:37,680 --> 00:44:39,000
heuristic step as was mentioned in the

1095
00:44:39,000 --> 00:44:40,680
previous talk this can introduce some

1096
00:44:40,680 --> 00:44:42,680
security flaws and

1097
00:44:42,680 --> 00:44:45,000
then practically speaking we also have

1098
00:44:45,000 --> 00:44:47,280
some concerns so the only way we can

1099
00:44:47,280 --> 00:44:49,500
actually like instantiate this now is as

1100
00:44:49,500 --> 00:44:52,380
a circuit and also snarks about these

1101
00:44:52,380 --> 00:44:54,180
hash functions are quite expensive

1102
00:44:54,180 --> 00:44:57,000
and while there are some like uh there

1103
00:44:57,000 --> 00:44:59,160
are some kind of a snark friendly hash

1104
00:44:59,160 --> 00:45:00,359
functions that have been kind of

1105
00:45:00,359 --> 00:45:02,339
proposed recently we're still analyzing

1106
00:45:02,339 --> 00:45:03,540
these as a community and it would be

1107
00:45:03,540 --> 00:45:04,740
quite nice if we could make our results

1108
00:45:04,740 --> 00:45:07,800
hold for for widely used hash functions

1109
00:45:07,800 --> 00:45:08,940
so

1110
00:45:08,940 --> 00:45:10,920
the kind of first hope then might be can

1111
00:45:10,920 --> 00:45:13,020
we actually just get IVC in the random

1112
00:45:13,020 --> 00:45:14,099
Oracle model like straight through

1113
00:45:14,099 --> 00:45:16,500
security in the one model okay and

1114
00:45:16,500 --> 00:45:18,119
there's actually a talk later about this

1115
00:45:18,119 --> 00:45:20,880
but this seems quite difficult

1116
00:45:20,880 --> 00:45:24,060
um and uh yeah because there's kind of

1117
00:45:24,060 --> 00:45:25,319
like nothing really to help you like

1118
00:45:25,319 --> 00:45:26,760
when the verifier goes to check the

1119
00:45:26,760 --> 00:45:28,020
proof there's a bunch of Oracle queries

1120
00:45:28,020 --> 00:45:30,240
in the proof and how can you really hope

1121
00:45:30,240 --> 00:45:32,160
to verify them without just going and

1122
00:45:32,160 --> 00:45:33,660
checking every query individually right

1123
00:45:33,660 --> 00:45:35,880
so this makes us sad

1124
00:45:35,880 --> 00:45:39,000
so maybe we can add some additional

1125
00:45:39,000 --> 00:45:40,859
structure to the Oracle and hope to use

1126
00:45:40,859 --> 00:45:42,960
this structure to verify queries kind of

1127
00:45:42,960 --> 00:45:45,780
in in one go or kind of batch queries

1128
00:45:45,780 --> 00:45:47,940
so one model that does this is uh the

1129
00:45:47,940 --> 00:45:49,740
sign random American model from case

1130
00:45:49,740 --> 00:45:51,000
trauma 2010

1131
00:45:51,000 --> 00:45:53,099
and in this model the the Oracle kind of

1132
00:45:53,099 --> 00:45:54,960
has a signature scheme and it kind of

1133
00:45:54,960 --> 00:45:57,300
signs its its responses additionally so

1134
00:45:57,300 --> 00:45:59,220
when it when it responds to you it signs

1135
00:45:59,220 --> 00:46:00,599
the response and then when the verifier

1136
00:46:00,599 --> 00:46:01,859
wants to check a bunch of queries

1137
00:46:01,859 --> 00:46:03,480
instead of querying the Oracle again you

1138
00:46:03,480 --> 00:46:05,040
can just check and verify the signature

1139
00:46:05,040 --> 00:46:07,980
okay in this model we get IVC so we're

1140
00:46:07,980 --> 00:46:09,960
happy okay and the reason we get it is

1141
00:46:09,960 --> 00:46:10,980
because we can batch the queries like

1142
00:46:10,980 --> 00:46:11,819
this

1143
00:46:11,819 --> 00:46:14,339
and then in the load there's another

1144
00:46:14,339 --> 00:46:16,200
another option is rather than using some

1145
00:46:16,200 --> 00:46:18,000
cryptographic structure like a signature

1146
00:46:18,000 --> 00:46:20,339
scheme you can use a

1147
00:46:20,339 --> 00:46:22,200
like a kind of algebraic structure and

1148
00:46:22,200 --> 00:46:23,220
I'm going to talk with this model more

1149
00:46:23,220 --> 00:46:24,060
later

1150
00:46:24,060 --> 00:46:26,640
and but the idea in this model is you

1151
00:46:26,640 --> 00:46:28,560
kind of extend the random Oracle to now

1152
00:46:28,560 --> 00:46:30,599
be to be a low degree polynomial and

1153
00:46:30,599 --> 00:46:31,619
because you have this low degree

1154
00:46:31,619 --> 00:46:32,819
structure you can kind of batch queries

1155
00:46:32,819 --> 00:46:35,339
by considering curves basically okay so

1156
00:46:35,339 --> 00:46:36,480
again you just and then you kind of

1157
00:46:36,480 --> 00:46:38,220
query at one point and you check one go

1158
00:46:38,220 --> 00:46:42,000
and we get we're happy right we get IBC

1159
00:46:42,000 --> 00:46:44,060
so both of these models can be

1160
00:46:44,060 --> 00:46:46,680
instantiated with a hardware token but

1161
00:46:46,680 --> 00:46:48,060
we don't know of any kind of software

1162
00:46:48,060 --> 00:46:50,220
only instantiation of these models okay

1163
00:46:50,220 --> 00:46:53,640
so we're again sad right so that kind of

1164
00:46:53,640 --> 00:46:54,780
brings me on to the point of this work

1165
00:46:54,780 --> 00:46:56,579
which is to kind of get the best of both

1166
00:46:56,579 --> 00:46:59,339
worlds type thing so on the one hand we

1167
00:46:59,339 --> 00:47:01,200
have the random Oracle model where we

1168
00:47:01,200 --> 00:47:02,339
kind of know how to heuristically

1169
00:47:02,339 --> 00:47:04,319
instantiate what we use a hash function

1170
00:47:04,319 --> 00:47:06,839
but we can't get or it seems very

1171
00:47:06,839 --> 00:47:10,079
unlikely we can get IVC okay on the

1172
00:47:10,079 --> 00:47:13,079
other hand we have these kind of Oracle

1173
00:47:13,079 --> 00:47:14,760
models with additional structure where

1174
00:47:14,760 --> 00:47:17,640
we can get IVC but we don't know how to

1175
00:47:17,640 --> 00:47:20,099
hear screen instantiate them okay so can

1176
00:47:20,099 --> 00:47:22,140
we get both the same time that's the

1177
00:47:22,140 --> 00:47:23,339
point of this work

1178
00:47:23,339 --> 00:47:25,560
and the answer is yes

1179
00:47:25,560 --> 00:47:27,420
so we propose a new random Oracle or a

1180
00:47:27,420 --> 00:47:28,859
new Oracle model called the arithmetized

1181
00:47:28,859 --> 00:47:31,260
random Oracle model and we think it has

1182
00:47:31,260 --> 00:47:32,520
a plausible heuristic instantiation

1183
00:47:32,520 --> 00:47:33,660
which is kind of going to be what I talk

1184
00:47:33,660 --> 00:47:35,520
about for the remainder of the talk

1185
00:47:35,520 --> 00:47:39,480
and we get PCD or IVC and in the

1186
00:47:39,480 --> 00:47:41,160
arithmetized around the market model I

1187
00:47:41,160 --> 00:47:42,359
just assume the inflation rate is in

1188
00:47:42,359 --> 00:47:43,560
hash functions

1189
00:47:43,560 --> 00:47:45,599
and and it's also worth mentioning this

1190
00:47:45,599 --> 00:47:48,119
PCB construction is secured to arbitrary

1191
00:47:48,119 --> 00:47:49,920
depth T where you can think of T is like

1192
00:47:49,920 --> 00:47:51,839
in the picture there

1193
00:47:51,839 --> 00:47:54,240
um and this is quite good because the

1194
00:47:54,240 --> 00:47:55,740
only other PCD construction that has

1195
00:47:55,740 --> 00:47:58,560
this uh guarantee is the sign random

1196
00:47:58,560 --> 00:47:59,760
Oracle one that I mentioned on the

1197
00:47:59,760 --> 00:48:02,460
previous slide okay so for the remainder

1198
00:48:02,460 --> 00:48:03,780
of the talk I'm going to talk about the

1199
00:48:03,780 --> 00:48:05,280
actual model and how we how we kind of

1200
00:48:05,280 --> 00:48:06,180
motivate it

1201
00:48:06,180 --> 00:48:07,920
so as a starting point we can think

1202
00:48:07,920 --> 00:48:09,660
about the lower end Market model okay

1203
00:48:09,660 --> 00:48:11,640
which I'm going to refresh everybody on

1204
00:48:11,640 --> 00:48:13,140
or introduce for anyone who hasn't seen

1205
00:48:13,140 --> 00:48:15,359
before so the load degree around the

1206
00:48:15,359 --> 00:48:16,680
market model kind of works as follows

1207
00:48:16,680 --> 00:48:19,319
you start off with a random Oracle you

1208
00:48:19,319 --> 00:48:20,940
just pick some random Oracle and then

1209
00:48:20,940 --> 00:48:23,660
you consider all of the low degree

1210
00:48:23,660 --> 00:48:26,040
polynomials that agree with that random

1211
00:48:26,040 --> 00:48:28,319
Oracle on the hypercube like on its

1212
00:48:28,319 --> 00:48:31,140
inputs okay but these these polynomials

1213
00:48:31,140 --> 00:48:32,880
you can put input like you know they're

1214
00:48:32,880 --> 00:48:35,099
extended to some larger Fields rather

1215
00:48:35,099 --> 00:48:38,220
than just uh Boolean bit strings okay

1216
00:48:38,220 --> 00:48:39,540
and then you pick one of those

1217
00:48:39,540 --> 00:48:41,940
polynomials at random and that

1218
00:48:41,940 --> 00:48:44,760
polynomial now is your Oracle okay and

1219
00:48:44,760 --> 00:48:46,440
you can query it at any point in the

1220
00:48:46,440 --> 00:48:48,420
extended Fields okay so now you've kind

1221
00:48:48,420 --> 00:48:50,040
of got this this additional structure

1222
00:48:50,040 --> 00:48:51,420
basically

1223
00:48:51,420 --> 00:48:53,819
the reason that this is a good thing to

1224
00:48:53,819 --> 00:48:56,760
do is because in CCI 22 where this

1225
00:48:56,760 --> 00:48:58,500
article model is introduced they gave

1226
00:48:58,500 --> 00:49:00,000
this non-interactive query reduction

1227
00:49:00,000 --> 00:49:02,760
protocol where basically the prover is

1228
00:49:02,760 --> 00:49:04,920
trying to prove to you that you know

1229
00:49:04,920 --> 00:49:07,859
this these tuples of query answers X1 y1

1230
00:49:07,859 --> 00:49:10,260
to X and Y N are all actually Oracle

1231
00:49:10,260 --> 00:49:11,700
queries so if you if you query the

1232
00:49:11,700 --> 00:49:13,740
Oracle at X1 you'll get back y1 and and

1233
00:49:13,740 --> 00:49:16,140
so on and the proofer can send you a

1234
00:49:16,140 --> 00:49:18,480
proof and then you can query the Oracle

1235
00:49:18,480 --> 00:49:21,060
in one at one point and verify all these

1236
00:49:21,060 --> 00:49:22,800
queries in one go okay because of this

1237
00:49:22,800 --> 00:49:26,339
load restructure so this is this is how

1238
00:49:26,339 --> 00:49:27,540
we get IVC because we get this query

1239
00:49:27,540 --> 00:49:28,440
reduction

1240
00:49:28,440 --> 00:49:30,720
so the difficulty is now

1241
00:49:30,720 --> 00:49:32,280
can we actually instantiate this thing

1242
00:49:32,280 --> 00:49:34,140
right so as a starting point for for our

1243
00:49:34,140 --> 00:49:35,640
work we try to instantiate the load

1244
00:49:35,640 --> 00:49:38,160
degree random Oracle okay

1245
00:49:38,160 --> 00:49:41,040
so the loader you around the miracle is

1246
00:49:41,040 --> 00:49:43,260
you know a random Oracle extended so

1247
00:49:43,260 --> 00:49:44,760
maybe we can take a hash function which

1248
00:49:44,760 --> 00:49:45,660
is how we would kind of think about

1249
00:49:45,660 --> 00:49:48,540
instantiating a hash function or sorry a

1250
00:49:48,540 --> 00:49:49,980
random Oracle and then extend that

1251
00:49:49,980 --> 00:49:50,880
somehow

1252
00:49:50,880 --> 00:49:53,819
so we start with a hash function a hash

1253
00:49:53,819 --> 00:49:55,980
function is just some circus okay so

1254
00:49:55,980 --> 00:49:57,480
then we can arithmetize that circuit

1255
00:49:57,480 --> 00:49:58,980
gate by gate

1256
00:49:58,980 --> 00:50:01,380
and then this arithmetic circuit will

1257
00:50:01,380 --> 00:50:03,359
Define a polynomial for us

1258
00:50:03,359 --> 00:50:08,000
okay so and this polynomial would be uh

1259
00:50:08,000 --> 00:50:10,200
an instantiation of the low degree

1260
00:50:10,200 --> 00:50:13,200
random Markle okay it has a in a sense

1261
00:50:13,200 --> 00:50:15,480
I'll explain so

1262
00:50:15,480 --> 00:50:17,460
there's a difficulty and the difficulty

1263
00:50:17,460 --> 00:50:19,380
is that the load of your random Oracle

1264
00:50:19,380 --> 00:50:21,240
runs in time at least they go over 2 to

1265
00:50:21,240 --> 00:50:22,200
the D

1266
00:50:22,200 --> 00:50:24,359
and this this D by the way is the depth

1267
00:50:24,359 --> 00:50:25,740
of the circuit and it's and in

1268
00:50:25,740 --> 00:50:27,480
particular it's the multiplicative depth

1269
00:50:27,480 --> 00:50:30,000
of this arithmetic circuit

1270
00:50:30,000 --> 00:50:31,800
but for widely used hash functions D is

1271
00:50:31,800 --> 00:50:34,560
at least 25. so we're sad this this

1272
00:50:34,560 --> 00:50:35,579
won't work

1273
00:50:35,579 --> 00:50:37,980
okay so the next thing we can think

1274
00:50:37,980 --> 00:50:39,960
about trying to do is reducing the depth

1275
00:50:39,960 --> 00:50:41,160
of this circuit right so we're getting

1276
00:50:41,160 --> 00:50:42,839
killed by the step the depth is the

1277
00:50:42,839 --> 00:50:44,579
circus too deep so if we could kind of

1278
00:50:44,579 --> 00:50:46,619
squash the circuit down somehow we might

1279
00:50:46,619 --> 00:50:47,760
be able to instantiate it and actually

1280
00:50:47,760 --> 00:50:48,660
get something it's a little degree

1281
00:50:48,660 --> 00:50:50,520
enough to work with

1282
00:50:50,520 --> 00:50:52,140
so we start off with again the hash

1283
00:50:52,140 --> 00:50:54,960
function and we carry out the like

1284
00:50:54,960 --> 00:50:56,640
well-known kind of circuits after three

1285
00:50:56,640 --> 00:50:59,040
sat reduction to get a depth to formula

1286
00:50:59,040 --> 00:51:01,559
from this circuit okay and now we've got

1287
00:51:01,559 --> 00:51:03,780
this this this this like three sat style

1288
00:51:03,780 --> 00:51:06,180
circuit but and this thing is a bit

1289
00:51:06,180 --> 00:51:07,740
different so

1290
00:51:07,740 --> 00:51:09,839
basically we get this this kind of a

1291
00:51:09,839 --> 00:51:11,700
this three set reduced kind of formula

1292
00:51:11,700 --> 00:51:13,920
called I'm going to call it Phi H and

1293
00:51:13,920 --> 00:51:16,440
Phi H is this kind of verification type

1294
00:51:16,440 --> 00:51:19,920
type circuit so the way it works is if

1295
00:51:19,920 --> 00:51:22,380
you input X Y and Z it will it will now

1296
00:51:22,380 --> 00:51:25,680
put one or kind of yes if Y is an output

1297
00:51:25,680 --> 00:51:29,099
under the hash function of x and z

1298
00:51:29,099 --> 00:51:32,280
is a witness and specifically what this

1299
00:51:32,280 --> 00:51:34,319
witness will be is if you understand how

1300
00:51:34,319 --> 00:51:36,599
the reduction works it's the assignments

1301
00:51:36,599 --> 00:51:38,160
of the wires when you put when you so

1302
00:51:38,160 --> 00:51:39,720
when you input X to H

1303
00:51:39,720 --> 00:51:42,180
the the values of the wires that's kind

1304
00:51:42,180 --> 00:51:44,520
of your witness basically okay and and

1305
00:51:44,520 --> 00:51:46,559
because this reduction is efficient

1306
00:51:46,559 --> 00:51:48,900
and Computing wh which is like the

1307
00:51:48,900 --> 00:51:51,180
internal assignments the wires is also

1308
00:51:51,180 --> 00:51:53,700
efficient okay

1309
00:51:53,700 --> 00:51:55,500
um so now we have this Phi H thing we

1310
00:51:55,500 --> 00:51:58,380
can again arithmetize this and we can uh

1311
00:51:58,380 --> 00:51:59,700
get Gap again and we can get a

1312
00:51:59,700 --> 00:52:00,960
polynomial and now we have something

1313
00:52:00,960 --> 00:52:03,900
loaded green enough to work with okay

1314
00:52:03,900 --> 00:52:05,400
but this thing isn't a low degree

1315
00:52:05,400 --> 00:52:07,140
extension of the hash function like it's

1316
00:52:07,140 --> 00:52:09,119
like like it's not even got the same

1317
00:52:09,119 --> 00:52:10,980
input space okay it's something

1318
00:52:10,980 --> 00:52:11,880
different

1319
00:52:11,880 --> 00:52:15,359
so to kind of like touch base we started

1320
00:52:15,359 --> 00:52:17,099
off with the loading around the Markle

1321
00:52:17,099 --> 00:52:18,960
we try to instantiate it we weren't able

1322
00:52:18,960 --> 00:52:20,339
to so we were kind of in theory worlds

1323
00:52:20,339 --> 00:52:21,660
with the lawyer random Markle we try to

1324
00:52:21,660 --> 00:52:23,940
instantiate it we weren't able to

1325
00:52:23,940 --> 00:52:26,520
and we swashed our circuit down and then

1326
00:52:26,520 --> 00:52:28,680
we got some other kind of polynomial and

1327
00:52:28,680 --> 00:52:30,960
now we want a tank kind of what would

1328
00:52:30,960 --> 00:52:33,000
this be an instantiation of right what

1329
00:52:33,000 --> 00:52:34,380
model would this be an instantiation as

1330
00:52:34,380 --> 00:52:35,700
we're going to go back to kind of theory

1331
00:52:35,700 --> 00:52:36,480
world

1332
00:52:36,480 --> 00:52:38,160
so this brings me on to the actual the

1333
00:52:38,160 --> 00:52:39,540
Aram arithmetized around the market

1334
00:52:39,540 --> 00:52:41,099
model

1335
00:52:41,099 --> 00:52:43,440
so uh the three things in the previous

1336
00:52:43,440 --> 00:52:45,420
slide were the hash function this

1337
00:52:45,420 --> 00:52:48,059
witness function and the verification

1338
00:52:48,059 --> 00:52:50,220
the polynomial I mentioned

1339
00:52:50,220 --> 00:52:53,460
so the hash function we're just going to

1340
00:52:53,460 --> 00:52:55,319
model as a random Oracle this is I think

1341
00:52:55,319 --> 00:52:57,420
pretty straightforward the witness

1342
00:52:57,420 --> 00:52:59,040
function is going to be this witness

1343
00:52:59,040 --> 00:53:00,720
article and I'll explain in more detail

1344
00:53:00,720 --> 00:53:02,220
in the next slide what exactly I mean

1345
00:53:02,220 --> 00:53:03,420
with this but for now it's just some

1346
00:53:03,420 --> 00:53:04,680
function

1347
00:53:04,680 --> 00:53:07,859
and then the verification uh the

1348
00:53:07,859 --> 00:53:10,079
verification polynomial is is modeled as

1349
00:53:10,079 --> 00:53:13,559
this low degree extension of this vo

1350
00:53:13,559 --> 00:53:14,880
function

1351
00:53:14,880 --> 00:53:17,099
so vo if you see so V of x y z is equal

1352
00:53:17,099 --> 00:53:19,619
to one if and only if r o of X is equal

1353
00:53:19,619 --> 00:53:23,160
to Y and W of x equal to Z so this is a

1354
00:53:23,160 --> 00:53:25,140
bit this vo function like is defined in

1355
00:53:25,140 --> 00:53:27,480
the exact same way as Phi H was on the

1356
00:53:27,480 --> 00:53:29,460
previous slide just in terms of like the

1357
00:53:29,460 --> 00:53:30,960
random Oracle and the witness article

1358
00:53:30,960 --> 00:53:32,880
okay and then we take a low degree

1359
00:53:32,880 --> 00:53:34,680
extension of that thing and this is our

1360
00:53:34,680 --> 00:53:36,720
our model okay

1361
00:53:36,720 --> 00:53:39,240
so this this is like just to really hit

1362
00:53:39,240 --> 00:53:40,800
home like this this is how we see that

1363
00:53:40,800 --> 00:53:43,260
there's a heuristic instantiation for

1364
00:53:43,260 --> 00:53:45,240
this model okay

1365
00:53:45,240 --> 00:53:47,640
so uh to be more specific about some of

1366
00:53:47,640 --> 00:53:49,800
the like the actual modeling now and the

1367
00:53:49,800 --> 00:53:50,700
kind of two things I need to be more

1368
00:53:50,700 --> 00:53:51,960
specific on are the witness article and

1369
00:53:51,960 --> 00:53:54,420
the verification article so

1370
00:53:54,420 --> 00:53:56,520
the witness article is a bit difficult

1371
00:53:56,520 --> 00:54:01,619
because uh because the wh depends

1372
00:54:01,619 --> 00:54:03,300
explicitly on the structure of the hash

1373
00:54:03,300 --> 00:54:04,619
function right it's the internal values

1374
00:54:04,619 --> 00:54:06,960
of the wires and now we've only got a

1375
00:54:06,960 --> 00:54:08,880
random arc on that a hash function so

1376
00:54:08,880 --> 00:54:10,260
there's no circuit there anymore to

1377
00:54:10,260 --> 00:54:12,300
actually like tell you what this thing

1378
00:54:12,300 --> 00:54:15,300
should be so as we basically model it as

1379
00:54:15,300 --> 00:54:17,280
an adversarially chosen function

1380
00:54:17,280 --> 00:54:19,859
but we specify that it has to be PPT or

1381
00:54:19,859 --> 00:54:20,940
problem probability polynomial

1382
00:54:20,940 --> 00:54:22,859
computable because we don't want it to

1383
00:54:22,859 --> 00:54:24,420
break any standard crypto

1384
00:54:24,420 --> 00:54:26,460
okay

1385
00:54:26,460 --> 00:54:31,020
um then also the uh severe half the way

1386
00:54:31,020 --> 00:54:33,420
we Define this this is a bit trickier so

1387
00:54:33,420 --> 00:54:34,800
I kind of just said it was a low degree

1388
00:54:34,800 --> 00:54:36,660
extension on the previous slides so you

1389
00:54:36,660 --> 00:54:38,040
have to kind of specify what kind of

1390
00:54:38,040 --> 00:54:39,599
load degree extension you mean

1391
00:54:39,599 --> 00:54:42,000
so if we set the individual degree to be

1392
00:54:42,000 --> 00:54:43,079
one

1393
00:54:43,079 --> 00:54:45,720
then um an efficient adversary this is

1394
00:54:45,720 --> 00:54:46,920
actually like having the multilinear

1395
00:54:46,920 --> 00:54:48,420
extension is actually quite powerful

1396
00:54:48,420 --> 00:54:50,520
there's a lot you can do with it so as a

1397
00:54:50,520 --> 00:54:51,960
result the adversary will be able to

1398
00:54:51,960 --> 00:54:53,880
efficiently invert the random Oracle so

1399
00:54:53,880 --> 00:54:55,740
we don't want this so we have to specify

1400
00:54:55,740 --> 00:54:56,940
the degree is it the individual degrees

1401
00:54:56,940 --> 00:54:59,540
at least two

1402
00:55:00,059 --> 00:55:01,440
um then you might think right we'll make

1403
00:55:01,440 --> 00:55:03,000
it adversarially chosen right like like

1404
00:55:03,000 --> 00:55:04,859
the witness article to be as kind of as

1405
00:55:04,859 --> 00:55:07,380
strong as possible but again actually if

1406
00:55:07,380 --> 00:55:08,700
you do this this is still too much power

1407
00:55:08,700 --> 00:55:10,140
for the adversary they would still be

1408
00:55:10,140 --> 00:55:13,020
able to invert the random Oracle so as a

1409
00:55:13,020 --> 00:55:14,040
result

1410
00:55:14,040 --> 00:55:16,140
um we said it to be uniformly random law

1411
00:55:16,140 --> 00:55:17,339
degree extension

1412
00:55:17,339 --> 00:55:18,960
and we think maybe this can be

1413
00:55:18,960 --> 00:55:20,520
strengthened but we do think that it

1414
00:55:20,520 --> 00:55:22,920
kind of reflects and the fact that the

1415
00:55:22,920 --> 00:55:24,599
adversary shouldn't be able to use the

1416
00:55:24,599 --> 00:55:26,579
internal structure of the hash function

1417
00:55:26,579 --> 00:55:27,960
to break security

1418
00:55:27,960 --> 00:55:30,420
and but it's an open question to for

1419
00:55:30,420 --> 00:55:31,800
future work basically to decide if this

1420
00:55:31,800 --> 00:55:35,940
can be weakened and yeah so that's

1421
00:55:35,940 --> 00:55:38,579
that's the model and so we think we have

1422
00:55:38,579 --> 00:55:40,380
a heuristic instantiation of this model

1423
00:55:40,380 --> 00:55:41,819
in software

1424
00:55:41,819 --> 00:55:43,619
and and then the other the other thing I

1425
00:55:43,619 --> 00:55:44,940
mentioned which I have no time really to

1426
00:55:44,940 --> 00:55:48,240
go into uh is uh like getting PCD in the

1427
00:55:48,240 --> 00:55:49,680
model and we had to do loads of other

1428
00:55:49,680 --> 00:55:51,480
cool work in the paper apart from

1429
00:55:51,480 --> 00:55:54,599
justifying this model so quickly

1430
00:55:54,599 --> 00:55:56,280
um we want to get PCD in the

1431
00:55:56,280 --> 00:55:58,079
arithmetized around the market model how

1432
00:55:58,079 --> 00:55:59,640
do we get this well there's kind of two

1433
00:55:59,640 --> 00:56:02,640
components to it so one thing we do is

1434
00:56:02,640 --> 00:56:04,140
we show that security in the random

1435
00:56:04,140 --> 00:56:06,359
Oracle model implies Security in the

1436
00:56:06,359 --> 00:56:07,680
arithmetized random Market model so any

1437
00:56:07,680 --> 00:56:08,940
construction that's secure in the random

1438
00:56:08,940 --> 00:56:10,680
Oracle model is also going to be secure

1439
00:56:10,680 --> 00:56:11,940
in the arithmetized random Market model

1440
00:56:11,940 --> 00:56:13,619
and we do some nice things like the

1441
00:56:13,619 --> 00:56:15,300
combinatorial wheelchair on stats and

1442
00:56:15,300 --> 00:56:17,280
some algebraic query complexity results

1443
00:56:17,280 --> 00:56:19,559
to do this and then additionally

1444
00:56:19,559 --> 00:56:21,359
and we get query reduction in the

1445
00:56:21,359 --> 00:56:23,760
arithmetized random Oracle model so and

1446
00:56:23,760 --> 00:56:25,920
this follows very very similarly to the

1447
00:56:25,920 --> 00:56:27,540
to the load of your end Markle model and

1448
00:56:27,540 --> 00:56:28,980
the reason is because we still have this

1449
00:56:28,980 --> 00:56:31,740
nice load degree structure and and this

1450
00:56:31,740 --> 00:56:33,660
kind of slots into like a line of work

1451
00:56:33,660 --> 00:56:35,220
on accumulation schemes for anyone who's

1452
00:56:35,220 --> 00:56:38,579
familiar but um yeah so I'm

1453
00:56:38,579 --> 00:56:40,980
we get our other tick and uh that's

1454
00:56:40,980 --> 00:56:44,240
everything thank you very much

1455
00:56:49,079 --> 00:56:52,220
we have time for questions

1456
00:56:58,200 --> 00:56:59,940
thank you very much for your talk I've

1457
00:56:59,940 --> 00:57:02,280
taught the explanations were really good

1458
00:57:02,280 --> 00:57:03,839
um there's something I really didn't get

1459
00:57:03,839 --> 00:57:05,760
it was near justification of the witness

1460
00:57:05,760 --> 00:57:08,880
Oracle so on the one hand we have like

1461
00:57:08,880 --> 00:57:10,619
the random Oracle of which she adversary

1462
00:57:10,619 --> 00:57:13,079
has basically no control but then you

1463
00:57:13,079 --> 00:57:15,059
want to give you want the adversary to

1464
00:57:15,059 --> 00:57:17,460
choose to witness Oracle yes and in

1465
00:57:17,460 --> 00:57:18,660
particular you restrict the other three

1466
00:57:18,660 --> 00:57:22,440
to be PPT yes so I don't see how this to

1467
00:57:22,440 --> 00:57:24,119
go together because the others really

1468
00:57:24,119 --> 00:57:25,559
really doesn't know anything about

1469
00:57:25,559 --> 00:57:27,119
around the world called concurr it but

1470
00:57:27,119 --> 00:57:29,160
that's it yeah on the other hand you

1471
00:57:29,160 --> 00:57:30,540
want it to specify basically the

1472
00:57:30,540 --> 00:57:31,980
internal structure of the Circuit of the

1473
00:57:31,980 --> 00:57:35,220
random Oracle yeah well I guess like

1474
00:57:35,220 --> 00:57:36,480
so it's not really a specifying

1475
00:57:36,480 --> 00:57:38,819
structure of the random Oracle

1476
00:57:38,819 --> 00:57:41,880
it's it's this separate witness article

1477
00:57:41,880 --> 00:57:43,859
yeah but the witness Oracle basically

1478
00:57:43,859 --> 00:57:46,020
incurs yeah sure okay I guess you can

1479
00:57:46,020 --> 00:57:46,800
think about it as being like

1480
00:57:46,800 --> 00:57:48,599
extensionally qualified or Quantified

1481
00:57:48,599 --> 00:57:50,339
over like we're saying basically there's

1482
00:57:50,339 --> 00:57:52,079
security security holds for all choices

1483
00:57:52,079 --> 00:57:53,940
of witness article

1484
00:57:53,940 --> 00:57:56,940
okay but then you would figure to be PPT

1485
00:57:56,940 --> 00:57:59,880
is there like an impossibility if you at

1486
00:57:59,880 --> 00:58:01,380
least like well we were restricting the

1487
00:58:01,380 --> 00:58:02,880
witness Oracle to pppt because we don't

1488
00:58:02,880 --> 00:58:04,319
want to like encode anything like we

1489
00:58:04,319 --> 00:58:05,760
don't want to like encode like you don't

1490
00:58:05,760 --> 00:58:07,020
be able to break the random Oracle with

1491
00:58:07,020 --> 00:58:08,700
the witness article but the adversary

1492
00:58:08,700 --> 00:58:11,040
before you choose the PPT how much time

1493
00:58:11,040 --> 00:58:12,660
does it have to do that before he

1494
00:58:12,660 --> 00:58:14,400
chooses the witness Oracle how much time

1495
00:58:14,400 --> 00:58:17,400
can you do can you spend on it uh maybe

1496
00:58:17,400 --> 00:58:19,380
we should take it offline okay yeah yeah

1497
00:58:19,380 --> 00:58:20,940
that's okay thank you thank you for your

1498
00:58:20,940 --> 00:58:23,119
questions

1499
00:58:23,819 --> 00:58:26,700
thanks for the talk uh I was wondering I

1500
00:58:26,700 --> 00:58:29,160
guess they're already like schemes that

1501
00:58:29,160 --> 00:58:31,740
has like uh General proof composition

1502
00:58:31,740 --> 00:58:33,240
that they're approval in the random

1503
00:58:33,240 --> 00:58:34,680
Oracle model

1504
00:58:34,680 --> 00:58:36,599
uh

1505
00:58:36,599 --> 00:58:39,240
uh I think so and my question is like

1506
00:58:39,240 --> 00:58:41,099
what does talk imply that their son's

1507
00:58:41,099 --> 00:58:43,880
proofs are wrong

1508
00:58:43,940 --> 00:58:47,040
say that again sorry so like if we can't

1509
00:58:47,040 --> 00:58:50,040
like since like instantiating random

1510
00:58:50,040 --> 00:58:52,500
Oracle like as a verified circuit is

1511
00:58:52,500 --> 00:58:54,960
like does not really comply with the

1512
00:58:54,960 --> 00:58:56,599
idea of a random Oracle

1513
00:58:56,599 --> 00:58:59,579
uh like how do we like how do they

1514
00:58:59,579 --> 00:59:02,280
justify their son's proofs

1515
00:59:02,280 --> 00:59:04,859
what do you mean who's they uh like any

1516
00:59:04,859 --> 00:59:06,960
work that uh proves like proof

1517
00:59:06,960 --> 00:59:09,299
composition in the random Oracle model

1518
00:59:09,299 --> 00:59:12,240
uh I'm not sure so like in the setting

1519
00:59:12,240 --> 00:59:13,920
of IVC like you don't get the security

1520
00:59:13,920 --> 00:59:16,140
on Markle right

1521
00:59:16,140 --> 00:59:18,299
uh-huh like it could you like you have

1522
00:59:18,299 --> 00:59:19,740
to like do this heuristic instantiation

1523
00:59:19,740 --> 00:59:21,240
before you recursively compose the

1524
00:59:21,240 --> 00:59:23,819
proofs uh-huh so it's not actually

1525
00:59:23,819 --> 00:59:25,799
secure In the End Market model the

1526
00:59:25,799 --> 00:59:27,299
construction you start with securing the

1527
00:59:27,299 --> 00:59:28,319
random Arc model I think if I'm

1528
00:59:28,319 --> 00:59:31,079
following a question okay so like like

1529
00:59:31,079 --> 00:59:33,599
so like like say when when you build IVC

1530
00:59:33,599 --> 00:59:35,280
from snarks in the random Market model

1531
00:59:35,280 --> 00:59:36,900
the snark is securing around the market

1532
00:59:36,900 --> 00:59:40,140
model but then to actually get IVC you

1533
00:59:40,140 --> 00:59:42,660
need to like compose the snark and to do

1534
00:59:42,660 --> 00:59:44,940
this like you're going to have to if you

1535
00:59:44,940 --> 00:59:46,500
hear us against the snack First You're

1536
00:59:46,500 --> 00:59:48,420
Gonna you're gonna get security or IVC

1537
00:59:48,420 --> 00:59:49,680
in the standard model

1538
00:59:49,680 --> 00:59:51,540
but you've broken the abstraction now

1539
00:59:51,540 --> 00:59:52,680
before you get there right because

1540
00:59:52,680 --> 00:59:55,020
you've curiously instance here first

1541
00:59:55,020 --> 00:59:57,000
yeah if that makes sense yeah yeah yeah

1542
00:59:57,000 --> 00:59:59,339
yep thanks thanks

1543
00:59:59,339 --> 01:00:03,078
okay let's thank Jack again

1544
01:00:05,540 --> 01:00:07,859
we have a 10 minute track switch break

1545
01:00:07,859 --> 01:00:11,720
and we resume at 11 40.

1546
01:00:16,740 --> 01:00:19,339
you won't

