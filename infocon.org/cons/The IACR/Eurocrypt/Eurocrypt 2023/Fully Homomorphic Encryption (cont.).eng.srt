1
00:00:01,979 --> 00:00:04,799
so welcome again to the to the

2
00:00:04,799 --> 00:00:08,660
fullyomorphic encryption session

3
00:00:08,700 --> 00:00:13,019
so we have we have a single talk for for

4
00:00:13,019 --> 00:00:14,940
two papers

5
00:00:14,940 --> 00:00:17,640
so batch bootstrapping a new framework

6
00:00:17,640 --> 00:00:19,020
for

7
00:00:19,020 --> 00:00:21,359
s-i-md bootstrapping in polymerian

8
00:00:21,359 --> 00:00:24,180
modulus so that's the first paper and

9
00:00:24,180 --> 00:00:26,100
the second paper is bootstrapping in

10
00:00:26,100 --> 00:00:29,640
polymer modulus only requires a constant

11
00:00:29,640 --> 00:00:33,420
fhc multiplications in amortization

12
00:00:33,420 --> 00:00:37,140
all right and so bye and so the your

13
00:00:37,140 --> 00:00:41,960
toes are Fang are you and angbang and

14
00:00:41,960 --> 00:00:45,480
one will give the torque okay thank you

15
00:00:45,480 --> 00:00:47,520
for the introduction

16
00:00:47,520 --> 00:00:48,780
um

17
00:00:48,780 --> 00:00:49,920
so

18
00:00:49,920 --> 00:00:52,680
um I'm going to talk about batch boost

19
00:00:52,680 --> 00:00:56,280
trapping one and two so because I am a

20
00:00:56,280 --> 00:00:59,579
little bit lucky and so I have a slight

21
00:00:59,579 --> 00:01:03,420
advantage of like 40 minutes so I can

22
00:01:03,420 --> 00:01:05,880
give you a little bit more context so

23
00:01:05,880 --> 00:01:08,400
hopefully the talk will be a little bit

24
00:01:08,400 --> 00:01:11,100
less cryptic but anyway

25
00:01:11,100 --> 00:01:13,680
so we all know fully homomorphic

26
00:01:13,680 --> 00:01:16,680
encryption allows arbitrary computation

27
00:01:16,680 --> 00:01:19,140
on encrypted data without equipping

28
00:01:19,140 --> 00:01:21,900
first so pictorially it looks like this

29
00:01:21,900 --> 00:01:25,619
and there is a lot of pioneering

30
00:01:25,619 --> 00:01:28,799
research including today's three

31
00:01:28,799 --> 00:01:32,640
previous papers in the prior session and

32
00:01:32,640 --> 00:01:35,880
it has been identified as a Holy Grail

33
00:01:35,880 --> 00:01:37,860
of cryptography

34
00:01:37,860 --> 00:01:41,100
so we all know that fully homomorphic

35
00:01:41,100 --> 00:01:43,979
encryption current instantiations need

36
00:01:43,979 --> 00:01:47,220
noise which grows with computation and

37
00:01:47,220 --> 00:01:50,820
at some point the noise might become too

38
00:01:50,820 --> 00:01:54,119
large so there is no further computation

39
00:01:54,119 --> 00:01:57,119
so if you think of like a real world

40
00:01:57,119 --> 00:01:59,640
object you can think of like every cyber

41
00:01:59,640 --> 00:02:03,720
text is associated with some battery and

42
00:02:03,720 --> 00:02:06,180
during the computation the battery level

43
00:02:06,180 --> 00:02:09,060
decreases and at some point it

44
00:02:09,060 --> 00:02:12,720
completely say depletes the battery and

45
00:02:12,720 --> 00:02:14,940
this means decryption fail

46
00:02:14,940 --> 00:02:17,520
so at this moment you know like how to

47
00:02:17,520 --> 00:02:21,000
deal with this issue is you need you

48
00:02:21,000 --> 00:02:24,720
need a way to clean noise and this is

49
00:02:24,720 --> 00:02:28,200
just like to charge the car by using

50
00:02:28,200 --> 00:02:31,620
some method and hopefully at the end the

51
00:02:31,620 --> 00:02:33,959
battery level can increase

52
00:02:33,959 --> 00:02:37,080
so this Paradigm is called bootstrapping

53
00:02:37,080 --> 00:02:40,400
invented by Gentry and in the nutshell

54
00:02:40,400 --> 00:02:43,980
the idea is to use a bootstrapping key

55
00:02:43,980 --> 00:02:48,000
which is an fhe ciphertext that encrypts

56
00:02:48,000 --> 00:02:49,560
its secret key

57
00:02:49,560 --> 00:02:51,000
so

58
00:02:51,000 --> 00:02:51,780
um

59
00:02:51,780 --> 00:02:56,459
and on input a ciphertext which is which

60
00:02:56,459 --> 00:02:59,280
might be somewhat noisy and you define a

61
00:02:59,280 --> 00:03:01,739
decryption function like this and by

62
00:03:01,739 --> 00:03:04,620
homomorphically evaluate this function

63
00:03:04,620 --> 00:03:08,819
you would by correctness of the

64
00:03:08,819 --> 00:03:11,120
decryption you will get

65
00:03:11,120 --> 00:03:13,319
encryption of x

66
00:03:13,319 --> 00:03:16,560
so because this is a homomorphic

67
00:03:16,560 --> 00:03:20,159
computation it incurs noise as well so

68
00:03:20,159 --> 00:03:22,580
hopefully this procedure

69
00:03:22,580 --> 00:03:26,580
we require like it's more efficient in

70
00:03:26,580 --> 00:03:29,700
terms of incurs smaller noise so that we

71
00:03:29,700 --> 00:03:33,120
have better larger residual battery at

72
00:03:33,120 --> 00:03:34,860
this moment

73
00:03:34,860 --> 00:03:36,959
so let's talk a little bit about current

74
00:03:36,959 --> 00:03:39,360
state of the art we have four

75
00:03:39,360 --> 00:03:42,239
generations of a veggie and we all know

76
00:03:42,239 --> 00:03:43,920
that the first generation is

77
00:03:43,920 --> 00:03:46,739
theoretically feasible and which is a

78
00:03:46,739 --> 00:03:49,140
little bit slow and for the fourth

79
00:03:49,140 --> 00:03:51,180
generation this is an approximated

80
00:03:51,180 --> 00:03:54,299
version and for approximated bootstrap

81
00:03:54,299 --> 00:03:57,060
method uh this kind of does not reduce

82
00:03:57,060 --> 00:03:59,760
noise level but just increase the

83
00:03:59,760 --> 00:04:03,239
modulus for for further computation and

84
00:04:03,239 --> 00:04:06,480
of course so now this talk we will focus

85
00:04:06,480 --> 00:04:09,360
on second and third generation

86
00:04:09,360 --> 00:04:12,480
so now let's talk a little bit about

87
00:04:12,480 --> 00:04:16,798
their limitations and trade-off so now

88
00:04:16,798 --> 00:04:20,339
we know that for second generation

89
00:04:20,339 --> 00:04:23,040
um the bootstrapping is kind of a little

90
00:04:23,040 --> 00:04:26,460
bit slower roughly 20 seconds or 10

91
00:04:26,460 --> 00:04:30,360
seconds and it incurs a very large noise

92
00:04:30,360 --> 00:04:32,940
this means large fully homomorphic

93
00:04:32,940 --> 00:04:35,759
encryption parameters huge bootstrapping

94
00:04:35,759 --> 00:04:39,320
keys and third generation like is fast

95
00:04:39,320 --> 00:04:42,720
small noise and small bootstrapping key

96
00:04:42,720 --> 00:04:44,940
so at this moment like we might think

97
00:04:44,940 --> 00:04:48,180
about like okay so why not just using

98
00:04:48,180 --> 00:04:51,380
third generation because there is a very

99
00:04:51,380 --> 00:04:54,540
important thing about a important

100
00:04:54,540 --> 00:04:56,220
Advantage for the second generation

101
00:04:56,220 --> 00:04:57,620
which is

102
00:04:57,620 --> 00:05:02,880
simd single instruction multiple data so

103
00:05:02,880 --> 00:05:04,500
we don't know whether the third

104
00:05:04,500 --> 00:05:08,280
generation supports simd so pictorially

105
00:05:08,280 --> 00:05:10,500
you can think of the second generation

106
00:05:10,500 --> 00:05:13,440
you need a very huge infrastructure but

107
00:05:13,440 --> 00:05:15,419
you can bootstrap a lot of cyber attacks

108
00:05:15,419 --> 00:05:18,060
at the same time but for the third

109
00:05:18,060 --> 00:05:21,120
generation it's very small and fast but

110
00:05:21,120 --> 00:05:23,460
like supercharger but you can only work

111
00:05:23,460 --> 00:05:26,520
on one Cipher text per time

112
00:05:26,520 --> 00:05:30,660
so the fundamental question here is does

113
00:05:30,660 --> 00:05:33,660
more efficient bootstrapping inherently

114
00:05:33,660 --> 00:05:37,380
require large fhe parameters So in

115
00:05:37,380 --> 00:05:40,440
theory this can we can ask can fhe

116
00:05:40,440 --> 00:05:44,520
parameters match or be as small as those

117
00:05:44,520 --> 00:05:48,240
basic pkes and in practice also small

118
00:05:48,240 --> 00:05:49,979
parameters means a little bit more

119
00:05:49,979 --> 00:05:52,080
friendly to hardware and computation

120
00:05:52,080 --> 00:05:54,240
architectures

121
00:05:54,240 --> 00:05:57,780
so can we achieve best of both

122
00:05:57,780 --> 00:06:02,880
and so particularly we want simd and

123
00:06:02,880 --> 00:06:06,560
small parameters and by small I mean

124
00:06:06,560 --> 00:06:10,620
polynomial noise blow up or polynomial

125
00:06:10,620 --> 00:06:11,880
modulus

126
00:06:11,880 --> 00:06:16,500
so that's our question so in this work

127
00:06:16,500 --> 00:06:20,220
um or in these two works we developed

128
00:06:20,220 --> 00:06:23,400
some interesting ideas that can achieve

129
00:06:23,400 --> 00:06:27,180
best of both and um so first we will

130
00:06:27,180 --> 00:06:30,419
talk about the foundation which is batch

131
00:06:30,419 --> 00:06:33,300
bootstrapping one and I will spend more

132
00:06:33,300 --> 00:06:35,759
time talking about this foundation and

133
00:06:35,759 --> 00:06:38,300
later on for bootstrapping to the

134
00:06:38,300 --> 00:06:40,800
application I will talk more about the

135
00:06:40,800 --> 00:06:44,699
high level side okay so in order to talk

136
00:06:44,699 --> 00:06:47,400
about this Foundation we need to talk a

137
00:06:47,400 --> 00:06:50,400
little bit about what's fhew like

138
00:06:50,400 --> 00:06:52,580
bootstrapping which is third generation

139
00:06:52,580 --> 00:06:56,639
so we also like those are the basic um

140
00:06:56,639 --> 00:06:59,340
say tools we are using

141
00:06:59,340 --> 00:07:03,479
so we all know this lwe which is a very

142
00:07:03,479 --> 00:07:04,680
important

143
00:07:04,680 --> 00:07:07,500
um say foundation for lattice based

144
00:07:07,500 --> 00:07:09,720
cryptography and cryptography and fully

145
00:07:09,720 --> 00:07:12,720
homomorphic encryption and this is the

146
00:07:12,720 --> 00:07:15,960
structure and I hope most of us are

147
00:07:15,960 --> 00:07:18,600
familiar with this and in order to

148
00:07:18,600 --> 00:07:20,940
improve efficiency there is a very

149
00:07:20,940 --> 00:07:25,199
important version called ring lwe and

150
00:07:25,199 --> 00:07:28,319
the basic the fundamental is we need to

151
00:07:28,319 --> 00:07:32,520
work in the ring and the most common

152
00:07:32,520 --> 00:07:36,060
ring we are working on is Cyclone Atomic

153
00:07:36,060 --> 00:07:38,400
rings and this Cyclone harming Rings

154
00:07:38,400 --> 00:07:41,940
there are two in representations so one

155
00:07:41,940 --> 00:07:44,699
is polynomial representation and the

156
00:07:44,699 --> 00:07:46,500
other one is algebraic representation

157
00:07:46,500 --> 00:07:52,680
which is z z2n where 2N is and the two

158
00:07:52,680 --> 00:07:54,960
nth root of unity

159
00:07:54,960 --> 00:07:57,360
so anyway

160
00:07:57,360 --> 00:08:01,860
um one very critical Insight here is we

161
00:08:01,860 --> 00:08:05,940
need to think of this one x x squared r

162
00:08:05,940 --> 00:08:09,539
to X2 and minus 1 they form a cyclic

163
00:08:09,539 --> 00:08:12,300
group so when we take modular

164
00:08:12,300 --> 00:08:15,539
computation over the exponent modulo 2N

165
00:08:15,539 --> 00:08:18,000
is like is taken

166
00:08:18,000 --> 00:08:19,259
okay

167
00:08:19,259 --> 00:08:23,699
so ring LW works like this and uh there

168
00:08:23,699 --> 00:08:25,860
is another very important thing called

169
00:08:25,860 --> 00:08:30,060
ring GSW which is um like a very

170
00:08:30,060 --> 00:08:33,299
beautiful work okay so there is a

171
00:08:33,299 --> 00:08:34,679
important

172
00:08:34,679 --> 00:08:37,979
um thing called external product where

173
00:08:37,979 --> 00:08:41,458
you can multiply a ring a ring GSW cyber

174
00:08:41,458 --> 00:08:44,760
text with ring LW cyber text resulting

175
00:08:44,760 --> 00:08:48,180
in a ring LW ciphertext okay

176
00:08:48,180 --> 00:08:51,560
and so in for

177
00:08:51,560 --> 00:08:55,380
fhe that we like bootstrapping we kind

178
00:08:55,380 --> 00:08:59,100
of the input is an LW Cipher text and

179
00:08:59,100 --> 00:09:02,880
with it works in a a modulo little queue

180
00:09:02,880 --> 00:09:05,880
and because we can use module module

181
00:09:05,880 --> 00:09:07,860
switch techniques so this is without

182
00:09:07,860 --> 00:09:11,220
loss of generality so

183
00:09:11,220 --> 00:09:15,240
highly at a high level we compute x to

184
00:09:15,240 --> 00:09:18,720
the B minus a s so the linear part of

185
00:09:18,720 --> 00:09:22,560
the decryption of lwe and modulo Q

186
00:09:22,560 --> 00:09:26,940
because we work the LW is in Z little

187
00:09:26,940 --> 00:09:29,880
Cube and then from there we can do a

188
00:09:29,880 --> 00:09:31,920
simple extraction procedure and finish

189
00:09:31,920 --> 00:09:33,480
the bootstrap

190
00:09:33,480 --> 00:09:38,459
so now the goal is to compute this B

191
00:09:38,459 --> 00:09:41,580
minus a s modular Q over the exponent so

192
00:09:41,580 --> 00:09:46,620
the idea is to set Q equal or Q divided

193
00:09:46,620 --> 00:09:52,140
uh 2N divided by Q so in this way we can

194
00:09:52,140 --> 00:09:54,899
take modulo Q naturally over the

195
00:09:54,899 --> 00:09:59,700
exponent so now the idea is say the

196
00:09:59,700 --> 00:10:02,640
bootstrapping keys encrypts each bit of

197
00:10:02,640 --> 00:10:05,640
the secret key and then from there we

198
00:10:05,640 --> 00:10:07,800
can use several beautiful techniques

199
00:10:07,800 --> 00:10:11,399
including today's first first talk we

200
00:10:11,399 --> 00:10:14,640
can compute x to the minus a i s i and

201
00:10:14,640 --> 00:10:17,339
we multiply everything together and we

202
00:10:17,339 --> 00:10:19,740
will get what we want so this is called

203
00:10:19,740 --> 00:10:21,480
the blind rotate

204
00:10:21,480 --> 00:10:24,300
and the correctness easy to show and

205
00:10:24,300 --> 00:10:29,100
noise growth is like follows this this

206
00:10:29,100 --> 00:10:31,920
equation and this equation is

207
00:10:31,920 --> 00:10:34,380
particularly important because it's a

208
00:10:34,380 --> 00:10:37,800
little bit asymmetry and this by using

209
00:10:37,800 --> 00:10:42,060
this symmetry this is the key idea to to

210
00:10:42,060 --> 00:10:45,000
bond the noise in the polynomial vector

211
00:10:45,000 --> 00:10:49,380
and very importantly we need the norm of

212
00:10:49,380 --> 00:10:52,980
this x to the negative a k s k to be one

213
00:10:52,980 --> 00:10:56,339
okay so if this Norm is greater than one

214
00:10:56,339 --> 00:10:58,440
and then you by solving this equation

215
00:10:58,440 --> 00:11:01,019
you will easily get an exponential blow

216
00:11:01,019 --> 00:11:02,220
up

217
00:11:02,220 --> 00:11:03,600
okay

218
00:11:03,600 --> 00:11:07,560
so now for technical barrier why this

219
00:11:07,560 --> 00:11:11,300
method cannot be simd because say

220
00:11:11,300 --> 00:11:14,820
existing simd method required to use

221
00:11:14,820 --> 00:11:18,060
Chinese remainder theorem which is to

222
00:11:18,060 --> 00:11:20,760
say the ring modular Q can be decomposed

223
00:11:20,760 --> 00:11:23,820
by products of Z cubes for appropriately

224
00:11:23,820 --> 00:11:27,480
Chosen queues and the computation over

225
00:11:27,480 --> 00:11:30,240
slots is by some sort of ring embedding

226
00:11:30,240 --> 00:11:33,019
so kind of you in say suppose you have

227
00:11:33,019 --> 00:11:37,380
several vectors X I's and Y I's you map

228
00:11:37,380 --> 00:11:40,500
them to the ring elements and so that

229
00:11:40,500 --> 00:11:42,860
ring multiplication and ring addition

230
00:11:42,860 --> 00:11:46,440
correspond to element wise at addition

231
00:11:46,440 --> 00:11:48,720
and multiplication

232
00:11:48,720 --> 00:11:50,339
so

233
00:11:50,339 --> 00:11:53,399
um we can achieve this by choosing this

234
00:11:53,399 --> 00:11:56,700
Chinese remainder theorem basis or CRT

235
00:11:56,700 --> 00:11:59,760
basis and you just put every coefficient

236
00:11:59,760 --> 00:12:02,399
X I's into this h i

237
00:12:02,399 --> 00:12:05,760
so there are two issues for this

238
00:12:05,760 --> 00:12:09,000
approach so the first issue is if you

239
00:12:09,000 --> 00:12:12,360
decompose into Z Cube products of Z Cube

240
00:12:12,360 --> 00:12:15,540
then the Cyclone atomic structure over

241
00:12:15,540 --> 00:12:18,959
the exponent like disappeared and the

242
00:12:18,959 --> 00:12:20,399
second thing is

243
00:12:20,399 --> 00:12:23,100
usually or not usually the Chinese

244
00:12:23,100 --> 00:12:25,800
remainder theorem basis is kind of large

245
00:12:25,800 --> 00:12:30,360
so if you pack things like this the norm

246
00:12:30,360 --> 00:12:33,660
of X will be very large so if this is

247
00:12:33,660 --> 00:12:36,240
the case you remember like previously I

248
00:12:36,240 --> 00:12:39,540
said this x to the negative a i s i the

249
00:12:39,540 --> 00:12:43,019
norm must be one so if you replace by S

250
00:12:43,019 --> 00:12:45,120
and a Chinese remainder theorem

251
00:12:45,120 --> 00:12:47,940
technique then the noise will blow up

252
00:12:47,940 --> 00:12:51,000
because it's the norm of this one is

253
00:12:51,000 --> 00:12:52,079
very big

254
00:12:52,079 --> 00:12:55,440
so the high level question here is can

255
00:12:55,440 --> 00:12:59,459
we find a better framework and for on a

256
00:12:59,459 --> 00:13:01,880
particularly new basis for smaller

257
00:13:01,880 --> 00:13:04,740
polynomial noise growth

258
00:13:04,740 --> 00:13:07,920
so in order to do this we kind of this

259
00:13:07,920 --> 00:13:10,800
work introduce some interesting

260
00:13:10,800 --> 00:13:14,279
mathematical framework so the idea is

261
00:13:14,279 --> 00:13:18,300
still we want to map our Q versus like a

262
00:13:18,300 --> 00:13:22,380
s mode product of s where s means slot

263
00:13:22,380 --> 00:13:23,760
so

264
00:13:23,760 --> 00:13:28,760
now each slot should include this

265
00:13:28,760 --> 00:13:33,959
psychologic ring okay zq and

266
00:13:33,959 --> 00:13:38,160
so so that x x q equals one so this

267
00:13:38,160 --> 00:13:41,760
means you can do the modulo Q over the

268
00:13:41,760 --> 00:13:45,540
exponent and moreover we want uh

269
00:13:45,540 --> 00:13:48,720
homomorphic computation over the slots

270
00:13:48,720 --> 00:13:52,680
and so the idea is we can just find

271
00:13:52,680 --> 00:13:55,860
another basis okay so we pack everything

272
00:13:55,860 --> 00:14:00,360
like this and add it in homework is very

273
00:14:00,360 --> 00:14:03,779
trivial but how to find homomorphic

274
00:14:03,779 --> 00:14:05,820
multiplication This is highly

275
00:14:05,820 --> 00:14:08,820
non-trivial and also like it almost took

276
00:14:08,820 --> 00:14:12,300
us like five years to find such a a

277
00:14:12,300 --> 00:14:15,240
basis so because you know like there can

278
00:14:15,240 --> 00:14:19,139
be infinitely many bases so how to pick

279
00:14:19,139 --> 00:14:22,380
the right one or a right one this is

280
00:14:22,380 --> 00:14:25,139
highly non-trivial so in order to do

281
00:14:25,139 --> 00:14:27,540
this let me introduce a little bit

282
00:14:27,540 --> 00:14:30,660
further preliminaries so Cyclone hammock

283
00:14:30,660 --> 00:14:33,420
Fields algebraic extension and algebraic

284
00:14:33,420 --> 00:14:34,980
Trace duality

285
00:14:34,980 --> 00:14:37,560
so General Cyclone Atomic Rings or

286
00:14:37,560 --> 00:14:40,019
Fields can be stored as like this

287
00:14:40,019 --> 00:14:44,160
polynomial modulo this Phi X where this

288
00:14:44,160 --> 00:14:48,240
is the M's Cyclone Atomic polynomial and

289
00:14:48,240 --> 00:14:50,459
also you can it has the

290
00:14:50,459 --> 00:14:52,800
um say algebraic View

291
00:14:52,800 --> 00:14:54,360
so

292
00:14:54,360 --> 00:14:55,199
um

293
00:14:55,199 --> 00:14:59,300
say in this work we prove ring GSW ring

294
00:14:59,300 --> 00:15:03,180
lwe and external products over a general

295
00:15:03,180 --> 00:15:05,579
Cyclone harming field they just work

296
00:15:05,579 --> 00:15:08,699
like the two's power if we are using the

297
00:15:08,699 --> 00:15:12,180
correct error analysis of like this

298
00:15:12,180 --> 00:15:15,000
canonical embedding as intro not

299
00:15:15,000 --> 00:15:19,260
introduced but used by ledpr 10 and 13.

300
00:15:19,260 --> 00:15:22,560
and tens of rings this is another very

301
00:15:22,560 --> 00:15:25,019
important techniques so suppose you have

302
00:15:25,019 --> 00:15:29,279
R1 R2 to linearly disjoint rings and

303
00:15:29,279 --> 00:15:32,519
their tensor can be thought as a ring

304
00:15:32,519 --> 00:15:36,959
that includes both sub-rings r1r2 so if

305
00:15:36,959 --> 00:15:40,079
R1 has some bases R2 has some bases then

306
00:15:40,079 --> 00:15:43,560
the tensor has bases of their the tensor

307
00:15:43,560 --> 00:15:48,180
of their bases like this okay and each

308
00:15:48,180 --> 00:15:50,220
element in the tensor ring can be

309
00:15:50,220 --> 00:15:52,800
expressed as some mentioned x i where x

310
00:15:52,800 --> 00:15:56,160
i is in the R1 and the base is via

311
00:15:56,160 --> 00:15:57,899
something like this

312
00:15:57,899 --> 00:16:01,079
so for algebraic trace this is another

313
00:16:01,079 --> 00:16:03,660
very important thing is where we can use

314
00:16:03,660 --> 00:16:08,820
algebraic Trace to Define say a dual

315
00:16:08,820 --> 00:16:09,720
ring

316
00:16:09,720 --> 00:16:13,380
so there is a very nice property of

317
00:16:13,380 --> 00:16:16,199
algebraic Trace where

318
00:16:16,199 --> 00:16:19,740
say if you have a basis in the ring and

319
00:16:19,740 --> 00:16:23,100
you can define a unique dual basis over

320
00:16:23,100 --> 00:16:26,060
the Dual ring and the algebraic Trace

321
00:16:26,060 --> 00:16:31,079
works like this on UI UJ Duo works like

322
00:16:31,079 --> 00:16:34,440
this kernel Chronicle Delta which means

323
00:16:34,440 --> 00:16:37,079
if I equals J that's one otherwise

324
00:16:37,079 --> 00:16:38,880
that's zero

325
00:16:38,880 --> 00:16:43,560
okay so now let's try to use those ideas

326
00:16:43,560 --> 00:16:47,100
to build uh say plain text simd

327
00:16:47,100 --> 00:16:49,560
computation first okay

328
00:16:49,560 --> 00:16:53,820
so the first idea is we can use tensor

329
00:16:53,820 --> 00:16:57,899
of two rings because we want them to

330
00:16:57,899 --> 00:17:01,139
include the Cyclone Atomic ring so R1 is

331
00:17:01,139 --> 00:17:03,180
the Cyclone harming ring and R2 is some

332
00:17:03,180 --> 00:17:04,500
basis

333
00:17:04,500 --> 00:17:08,699
as some other ring okay so we can just

334
00:17:08,699 --> 00:17:10,799
use the

335
00:17:10,799 --> 00:17:13,919
simple way to uh to do the packing like

336
00:17:13,919 --> 00:17:15,240
the blue

337
00:17:15,240 --> 00:17:15,900
um

338
00:17:15,900 --> 00:17:20,280
blue equations in the middle and but the

339
00:17:20,280 --> 00:17:23,280
thing is if we try to multiply them we

340
00:17:23,280 --> 00:17:27,179
will get a lot of a lot of cross terms

341
00:17:27,179 --> 00:17:30,240
and this is not something what we want

342
00:17:30,240 --> 00:17:34,980
so how do we kill those cross terms we

343
00:17:34,980 --> 00:17:38,220
know we can use the trace and the deal

344
00:17:38,220 --> 00:17:42,539
because as I said Trace trace and deal

345
00:17:42,539 --> 00:17:45,780
they work like this chronicard deota so

346
00:17:45,780 --> 00:17:50,039
how about this we Inc um we pack X using

347
00:17:50,039 --> 00:17:54,660
UI and we pack y eyes using uido

348
00:17:54,660 --> 00:17:59,280
so homomorphic so if we try to multiply

349
00:17:59,280 --> 00:18:02,179
them together and we take trades okay

350
00:18:02,179 --> 00:18:06,059
then because of this Chronicle Delta

351
00:18:06,059 --> 00:18:08,700
this part is one and the other part is

352
00:18:08,700 --> 00:18:12,600
zero so we get x i or y i summation but

353
00:18:12,600 --> 00:18:14,880
this is still not very good because they

354
00:18:14,880 --> 00:18:16,320
are mixed

355
00:18:16,320 --> 00:18:20,400
so in order to solve this problem we

356
00:18:20,400 --> 00:18:23,460
kind of consider a third ring we use

357
00:18:23,460 --> 00:18:25,500
three rings okay

358
00:18:25,500 --> 00:18:31,200
so the idea now is we pack X using UI

359
00:18:31,200 --> 00:18:37,080
and we pack y using UI dual VI so the

360
00:18:37,080 --> 00:18:40,320
nice thing here is we x y and we use

361
00:18:40,320 --> 00:18:44,100
Trace computation here say the equation

362
00:18:44,100 --> 00:18:48,179
looks like this and we can kill the UI

363
00:18:48,179 --> 00:18:52,260
UI dual part by one and the cross terms

364
00:18:52,260 --> 00:18:56,460
are all cancel out so it is x y y i and

365
00:18:56,460 --> 00:19:00,539
with the base basis VI

366
00:19:00,539 --> 00:19:04,260
but there is a problem here is say

367
00:19:04,260 --> 00:19:09,000
initially we start with X as packing

368
00:19:09,000 --> 00:19:12,480
over uis and after the computation we

369
00:19:12,480 --> 00:19:15,419
move to packing over VIs

370
00:19:15,419 --> 00:19:18,440
so if we want to proceed the computation

371
00:19:18,440 --> 00:19:20,580
and then

372
00:19:20,580 --> 00:19:24,179
um so how do we proceed computation do

373
00:19:24,179 --> 00:19:28,320
we need more tensor rings so you yes if

374
00:19:28,320 --> 00:19:30,419
we have more tensor Rings we can proceed

375
00:19:30,419 --> 00:19:32,880
the computation but the ring Dimension

376
00:19:32,880 --> 00:19:35,400
blows up this that's very bad

377
00:19:35,400 --> 00:19:38,880
so our final idea is we can reuse rings

378
00:19:38,880 --> 00:19:42,179
so what does that mean so still three

379
00:19:42,179 --> 00:19:44,460
tensor rings and this is similar as

380
00:19:44,460 --> 00:19:47,940
before so now if we want to proceed

381
00:19:47,940 --> 00:19:53,940
computation we in we pack Z under u i v

382
00:19:53,940 --> 00:19:55,380
i D1

383
00:19:55,380 --> 00:19:59,460
okay so by multiplying everything

384
00:19:59,460 --> 00:20:03,720
together everything is back to UI so

385
00:20:03,720 --> 00:20:06,740
this means we can alternate

386
00:20:06,740 --> 00:20:12,120
space between R1 tensor R2 and R1 tensor

387
00:20:12,120 --> 00:20:13,620
R3

388
00:20:13,620 --> 00:20:17,100
okay so by

389
00:20:17,100 --> 00:20:22,200
by using this idea we can achieve our

390
00:20:22,200 --> 00:20:25,860
goal okay but in order to do this like

391
00:20:25,860 --> 00:20:28,740
we also need to understand like how do

392
00:20:28,740 --> 00:20:31,380
we choose instantiation of those tensor

393
00:20:31,380 --> 00:20:32,340
fields

394
00:20:32,340 --> 00:20:36,419
so one very beautiful algebra algebraic

395
00:20:36,419 --> 00:20:39,120
number theory is to use decomposition of

396
00:20:39,120 --> 00:20:42,299
cyclone Atomic rings so

397
00:20:42,299 --> 00:20:48,380
um this z n is isomorphic to CQ

398
00:20:48,380 --> 00:20:54,919
if qpt are relatively prime okay so this

399
00:20:54,919 --> 00:21:01,380
gives a very simple and effective way to

400
00:21:01,380 --> 00:21:04,799
choose our tensor rings

401
00:21:04,799 --> 00:21:06,480
and

402
00:21:06,480 --> 00:21:10,980
um so now how many slots can we batch is

403
00:21:10,980 --> 00:21:14,400
like the minimum of a row and a Tau

404
00:21:14,400 --> 00:21:18,480
where rho is the degree of Z zp and tau

405
00:21:18,480 --> 00:21:22,320
is the degree of Z calcity so this is

406
00:21:22,320 --> 00:21:26,120
like a we can batch our slots

407
00:21:26,120 --> 00:21:29,640
by using ring multiplication and

408
00:21:29,640 --> 00:21:31,679
algebraic Trace

409
00:21:31,679 --> 00:21:35,640
okay so in summary so tensor Rings plus

410
00:21:35,640 --> 00:21:39,000
algebraic Trace implies simd operation

411
00:21:39,000 --> 00:21:42,120
computation okay and this is compatible

412
00:21:42,120 --> 00:21:45,659
with fhew like bootstrapping so the next

413
00:21:45,659 --> 00:21:47,940
question is how do we compute things

414
00:21:47,940 --> 00:21:50,640
homomorphically and how do we handle

415
00:21:50,640 --> 00:21:52,080
noise growth

416
00:21:52,080 --> 00:21:55,500
so the homomorphic computation framework

417
00:21:55,500 --> 00:21:59,520
this is as this requires to use string

418
00:21:59,520 --> 00:22:03,059
GSW and lwe in the site General cycle

419
00:22:03,059 --> 00:22:06,240
how many green case and

420
00:22:06,240 --> 00:22:10,500
say this this work our work we analyze

421
00:22:10,500 --> 00:22:13,280
the general behavior of

422
00:22:13,280 --> 00:22:16,740
ring GSW and lwe

423
00:22:16,740 --> 00:22:21,000
so everything just works very similar in

424
00:22:21,000 --> 00:22:23,580
uh as the two's case

425
00:22:23,580 --> 00:22:26,400
so the next question is how do we handle

426
00:22:26,400 --> 00:22:30,740
homomorphic Trace how about noise so

427
00:22:30,740 --> 00:22:34,080
in order to do this there is a very like

428
00:22:34,080 --> 00:22:37,919
there are some previous works and also

429
00:22:37,919 --> 00:22:41,760
our work we can show that if you are

430
00:22:41,760 --> 00:22:45,059
field extension has this power structure

431
00:22:45,059 --> 00:22:47,580
so the tower structures means like

432
00:22:47,580 --> 00:22:51,240
something like this you have a q and u

433
00:22:51,240 --> 00:22:55,080
extension extension up to K so if you

434
00:22:55,080 --> 00:22:57,480
have a tower structure then there exists

435
00:22:57,480 --> 00:23:01,860
a and very efficient uh homomorphic

436
00:23:01,860 --> 00:23:05,159
Trace algorithm by using the power uh

437
00:23:05,159 --> 00:23:08,580
algebraic structure and if we don't have

438
00:23:08,580 --> 00:23:11,640
this power structure and I think this is

439
00:23:11,640 --> 00:23:13,980
an interesting open question whether you

440
00:23:13,980 --> 00:23:17,760
can compute homologic Trace efficiently

441
00:23:17,760 --> 00:23:21,419
okay anyway so um the overall

442
00:23:21,419 --> 00:23:23,340
computation structure would look like

443
00:23:23,340 --> 00:23:26,400
something like this so suppose we

444
00:23:26,400 --> 00:23:29,700
consider we are going to batch two slots

445
00:23:29,700 --> 00:23:33,440
just two slots for Simplicity so

446
00:23:33,440 --> 00:23:37,919
we have an orange ciphertext X1 X2

447
00:23:37,919 --> 00:23:42,740
and then we have another orange to Green

448
00:23:42,740 --> 00:23:45,179
ciphertext y1y2

449
00:23:45,179 --> 00:23:48,780
so by doing this external product and

450
00:23:48,780 --> 00:23:51,780
Trace and then we can get to a green

451
00:23:51,780 --> 00:23:56,460
Cipher text of their says component-wise

452
00:23:56,460 --> 00:23:57,720
multiplication

453
00:23:57,720 --> 00:24:01,740
so in order to proceed we need a green

454
00:24:01,740 --> 00:24:05,460
to Orange cyber text and by doing this

455
00:24:05,460 --> 00:24:08,400
we get an orange cyber text of their

456
00:24:08,400 --> 00:24:10,380
multiplications

457
00:24:10,380 --> 00:24:12,960
okay so

458
00:24:12,960 --> 00:24:16,740
um by using this structure we can apply

459
00:24:16,740 --> 00:24:20,840
this to the fhew so suppose we have two

460
00:24:20,840 --> 00:24:26,460
lwe cyber text as input and we can

461
00:24:26,460 --> 00:24:30,000
say initially we have some sort of a ACC

462
00:24:30,000 --> 00:24:34,260
which is accumulator zero okay and this

463
00:24:34,260 --> 00:24:37,860
is a green orange cyber text and from

464
00:24:37,860 --> 00:24:42,360
the bootstrapping key we can construct a

465
00:24:42,360 --> 00:24:46,799
pack bootstrapping P1 okay this is a red

466
00:24:46,799 --> 00:24:49,860
to Green cyber text and then after the

467
00:24:49,860 --> 00:24:53,220
computation it becomes green ACC

468
00:24:53,220 --> 00:24:58,080
and we can start uh we can work on the

469
00:24:58,080 --> 00:25:00,419
second bootstrapping key to get a pack

470
00:25:00,419 --> 00:25:04,400
boost wrapping key 2 using uh like a AP

471
00:25:04,400 --> 00:25:07,500
technique or this at the the first talk

472
00:25:07,500 --> 00:25:09,260
of this morning

473
00:25:09,260 --> 00:25:13,280
and then we can apply a homomorphic

474
00:25:13,280 --> 00:25:16,140
external product and Trace and then we

475
00:25:16,140 --> 00:25:20,640
get a an orange cyber attacks and this

476
00:25:20,640 --> 00:25:22,100
procedure can

477
00:25:22,100 --> 00:25:25,679
continues and we reach the end

478
00:25:25,679 --> 00:25:29,779
okay so the arrow growth of this batch

479
00:25:29,779 --> 00:25:31,400
fhew

480
00:25:31,400 --> 00:25:34,140
Paradigm is a little bit tricky and

481
00:25:34,140 --> 00:25:36,419
actually it took us like

482
00:25:36,419 --> 00:25:40,080
um say one or two uh crypto Euro quick

483
00:25:40,080 --> 00:25:43,020
rejections in order to get this right

484
00:25:43,020 --> 00:25:47,100
so the analysis uh is tricky so if we

485
00:25:47,100 --> 00:25:50,520
apply the direct analysis using the the

486
00:25:50,520 --> 00:25:53,940
uh the bond of natural the trace Bond

487
00:25:53,940 --> 00:25:57,960
and then we will get an exponential blow

488
00:25:57,960 --> 00:25:58,799
up

489
00:25:58,799 --> 00:26:01,380
so we need kind of some sort of

490
00:26:01,380 --> 00:26:04,679
fine-grain analysis and particularly at

491
00:26:04,679 --> 00:26:07,980
a very high level we show that each slot

492
00:26:07,980 --> 00:26:10,860
the noise increase is just like an

493
00:26:10,860 --> 00:26:16,279
unbetched regular fhew errors okay so if

494
00:26:16,279 --> 00:26:20,820
say if errors are also batch like fhc

495
00:26:20,820 --> 00:26:24,900
regular batching FH regular fhcw errors

496
00:26:24,900 --> 00:26:28,799
then we can show that overall arrows are

497
00:26:28,799 --> 00:26:32,340
is also bounded by polynomial and this

498
00:26:32,340 --> 00:26:34,559
part is a little bit tricky but if you

499
00:26:34,559 --> 00:26:37,559
really want to play with the math you

500
00:26:37,559 --> 00:26:38,940
can really get this

501
00:26:38,940 --> 00:26:41,279
yeah so

502
00:26:41,279 --> 00:26:42,140
um

503
00:26:42,140 --> 00:26:45,480
so the the only thing I can say here is

504
00:26:45,480 --> 00:26:49,320
uh please read our paper for details

505
00:26:49,320 --> 00:26:51,779
so how do we set parameters

506
00:26:51,779 --> 00:26:55,500
so first we need to uh three tensor

507
00:26:55,500 --> 00:26:56,880
rings

508
00:26:56,880 --> 00:27:01,980
and so in order to apply fhew we need to

509
00:27:01,980 --> 00:27:06,720
set Q to be at least say order tilde

510
00:27:06,720 --> 00:27:09,179
square root of Lambda where Lambda is

511
00:27:09,179 --> 00:27:11,760
the security parameter so this is a

512
00:27:11,760 --> 00:27:12,600
little bit

513
00:27:12,600 --> 00:27:18,120
um say for original fhew and tfhe and

514
00:27:18,120 --> 00:27:21,840
others roughly they said Q to be order

515
00:27:21,840 --> 00:27:24,659
Lambda but if we are using the

516
00:27:24,659 --> 00:27:27,840
randomized module module switching

517
00:27:27,840 --> 00:27:30,600
techniques uh sorry randomized rounding

518
00:27:30,600 --> 00:27:33,299
then we can actually like save a square

519
00:27:33,299 --> 00:27:35,460
root of Lambda

520
00:27:35,460 --> 00:27:38,700
so the overall batch parameter if we try

521
00:27:38,700 --> 00:27:40,799
to play with everything this would

522
00:27:40,799 --> 00:27:45,299
become roughly Lambda to the one quarter

523
00:27:45,299 --> 00:27:48,900
so at the high level take home message

524
00:27:48,900 --> 00:27:51,120
is here

525
00:27:51,120 --> 00:27:55,020
um we can batch fagw computation with

526
00:27:55,020 --> 00:27:59,520
Lambda to the zero one quarter slot

527
00:27:59,520 --> 00:28:01,260
so

528
00:28:01,260 --> 00:28:03,860
um if we put everything in comparison

529
00:28:03,860 --> 00:28:05,480
and

530
00:28:05,480 --> 00:28:09,779
so all the previous constructions are

531
00:28:09,779 --> 00:28:11,240
order

532
00:28:11,240 --> 00:28:14,340
Lambda and our because we can batch

533
00:28:14,340 --> 00:28:17,100
order say Lambda to the one quarter so

534
00:28:17,100 --> 00:28:20,400
our amortized complexity would be Lambda

535
00:28:20,400 --> 00:28:22,799
to the 0.75

536
00:28:22,799 --> 00:28:27,000
okay so here this is batch uh

537
00:28:27,000 --> 00:28:31,020
bootstrapping what our first result and

538
00:28:31,020 --> 00:28:34,080
if we only have this first result this

539
00:28:34,080 --> 00:28:37,320
is not sufficient to get into crypto and

540
00:28:37,320 --> 00:28:40,140
eurocrypt so the reason because we got

541
00:28:40,140 --> 00:28:42,600
rejected and because of the following

542
00:28:42,600 --> 00:28:45,139
reset

543
00:28:45,299 --> 00:28:48,299
um there is still a gap between the best

544
00:28:48,299 --> 00:28:50,400
theoretical results

545
00:28:50,400 --> 00:28:55,559
so if we look at our results into a more

546
00:28:55,559 --> 00:29:00,539
more detail over the table all the

547
00:29:00,539 --> 00:29:04,200
results list listed here are about

548
00:29:04,200 --> 00:29:08,580
straight line computation where the we

549
00:29:08,580 --> 00:29:11,220
are doing this fhe like bootstrapping

550
00:29:11,220 --> 00:29:14,159
and in a straight line way

551
00:29:14,159 --> 00:29:18,899
but if we are allowed recursive okay

552
00:29:18,899 --> 00:29:24,600
then there is a work Ms 18 Miss yancho

553
00:29:24,600 --> 00:29:27,960
and surreal they can achieve three to

554
00:29:27,960 --> 00:29:31,080
the row Lambda 1 overall for any

555
00:29:31,080 --> 00:29:35,220
tungsten row okay so in particular if

556
00:29:35,220 --> 00:29:38,760
this row is 100 and they're

557
00:29:38,760 --> 00:29:41,600
um they're a sympathetic complete

558
00:29:41,600 --> 00:29:43,159
asymptotic

559
00:29:43,159 --> 00:29:47,520
complexity is Lambda to the 0.01 which

560
00:29:47,520 --> 00:29:52,140
is much better than 0.75 in theory

561
00:29:52,140 --> 00:29:55,740
although they have three to the 100 like

562
00:29:55,740 --> 00:29:58,679
constant turn over there but in theory

563
00:29:58,679 --> 00:30:01,260
that's still much better than Lambda

564
00:30:01,260 --> 00:30:04,440
over like to the 0.75

565
00:30:04,440 --> 00:30:07,580
and there is like some other

566
00:30:07,580 --> 00:30:11,100
concurrent work or that improve the

567
00:30:11,100 --> 00:30:12,659
ms-18

568
00:30:12,659 --> 00:30:14,220
so

569
00:30:14,220 --> 00:30:17,279
in order to uh like uh

570
00:30:17,279 --> 00:30:21,299
say further improve our results we need

571
00:30:21,299 --> 00:30:23,460
to our uh go talk about our

572
00:30:23,460 --> 00:30:25,620
bootstrapping tool

573
00:30:25,620 --> 00:30:30,500
okay so the high level question here is

574
00:30:30,500 --> 00:30:34,140
ms-18 they showed a more efficient way

575
00:30:34,140 --> 00:30:36,480
or at least theoretically efficient way

576
00:30:36,480 --> 00:30:38,760
by using recursive

577
00:30:38,760 --> 00:30:43,820
so our question is can we apply our

578
00:30:43,820 --> 00:30:48,539
framework in bootstrapping one to their

579
00:30:48,539 --> 00:30:52,620
recursive method because their method is

580
00:30:52,620 --> 00:30:57,120
very compatible with fhew and our frame

581
00:30:57,120 --> 00:31:02,520
framework is also compatible with fhew

582
00:31:02,520 --> 00:31:05,580
so now in order to do this we kind of

583
00:31:05,580 --> 00:31:08,460
need to understand a little bit about

584
00:31:08,460 --> 00:31:13,559
like how ms-18 works so intuitively they

585
00:31:13,559 --> 00:31:18,120
have say input is nlwes and their output

586
00:31:18,120 --> 00:31:21,840
is nlws so this is really a a kind of

587
00:31:21,840 --> 00:31:23,120
like a

588
00:31:23,120 --> 00:31:26,460
multi-input lws and without multi-output

589
00:31:26,460 --> 00:31:29,760
LW is bootstrapping the high level idea

590
00:31:29,760 --> 00:31:34,200
is they first convert the N input lws

591
00:31:34,200 --> 00:31:37,140
into one ring lwes

592
00:31:37,140 --> 00:31:41,340
and then they compute ring LW decryption

593
00:31:41,340 --> 00:31:45,840
over the exponent and ring LW is kind of

594
00:31:45,840 --> 00:31:50,520
this B minus a s which is the most

595
00:31:50,520 --> 00:31:52,080
important part is the ring

596
00:31:52,080 --> 00:31:56,159
multiplication over the exponent

597
00:31:56,159 --> 00:32:00,140
and can we use so their idea is to use

598
00:32:00,140 --> 00:32:05,279
fft type of recursive technique over the

599
00:32:05,279 --> 00:32:07,080
exponent

600
00:32:07,080 --> 00:32:11,399
so now in order to do this let's we need

601
00:32:11,399 --> 00:32:13,980
to understand like one thing about their

602
00:32:13,980 --> 00:32:17,419
approach which is one ffp type of

603
00:32:17,419 --> 00:32:20,340
commutation which is called Nas bomber

604
00:32:20,340 --> 00:32:21,600
transform

605
00:32:21,600 --> 00:32:25,440
so in order to do this in order to do

606
00:32:25,440 --> 00:32:30,899
this DFT or fft we kind of the idea is

607
00:32:30,899 --> 00:32:33,740
we say suppose you have a ring element

608
00:32:33,740 --> 00:32:36,840
and or two ring elements in the

609
00:32:36,840 --> 00:32:39,179
coefficient form you first convert them

610
00:32:39,179 --> 00:32:43,679
into Vector forms right or DFT forms and

611
00:32:43,679 --> 00:32:46,740
multiply component wise and then do

612
00:32:46,740 --> 00:32:49,380
inverse DFT

613
00:32:49,380 --> 00:32:50,580
okay

614
00:32:50,580 --> 00:32:53,520
and then the challenge is how do you do

615
00:32:53,520 --> 00:32:54,559
this

616
00:32:54,559 --> 00:32:58,380
DFT type of things over the exponent so

617
00:32:58,380 --> 00:33:00,419
if you are using fft you need to deal

618
00:33:00,419 --> 00:33:03,960
with floating points and we know that

619
00:33:03,960 --> 00:33:07,140
fhdw you cannot do floating point

620
00:33:07,140 --> 00:33:10,500
and if you are doing entity yes you can

621
00:33:10,500 --> 00:33:13,200
do entity but with more a little bit

622
00:33:13,200 --> 00:33:15,960
more limited choice of Q because you

623
00:33:15,960 --> 00:33:20,460
need this Q QR or this ideal completely

624
00:33:20,460 --> 00:33:22,440
splits

625
00:33:22,440 --> 00:33:27,360
so ms-18 they found a way to use Nas

626
00:33:27,360 --> 00:33:30,539
bomber transform and it took me a lot of

627
00:33:30,539 --> 00:33:33,000
time to understand what they were

628
00:33:33,000 --> 00:33:35,880
writing about so I didn't present their

629
00:33:35,880 --> 00:33:39,240
presentation I present my own my own

630
00:33:39,240 --> 00:33:40,679
understanding

631
00:33:40,679 --> 00:33:44,159
so the idea is say if you want to

632
00:33:44,159 --> 00:33:45,480
compute

633
00:33:45,480 --> 00:33:49,760
two elements in this K extension field

634
00:33:49,760 --> 00:33:52,260
like multiplication

635
00:33:52,260 --> 00:33:56,159
you they find an intermediate field e

636
00:33:56,159 --> 00:34:00,779
and this e contains Cassie 2D so

637
00:34:00,779 --> 00:34:04,380
remember Casi 2D is to this root of

638
00:34:04,380 --> 00:34:06,000
unity

639
00:34:06,000 --> 00:34:10,679
okay so each element in K can be

640
00:34:10,679 --> 00:34:14,820
expressed as polynomials okay where

641
00:34:14,820 --> 00:34:17,159
coefficients are in e

642
00:34:17,159 --> 00:34:20,280
so now multiplication in K you can just

643
00:34:20,280 --> 00:34:24,179
can be reduced to multiplication in e x

644
00:34:24,179 --> 00:34:26,879
over f of x

645
00:34:26,879 --> 00:34:28,260
so now

646
00:34:28,260 --> 00:34:30,060
then we only need to deal with

647
00:34:30,060 --> 00:34:32,940
multiplications of two polynomials so

648
00:34:32,940 --> 00:34:35,699
how do we do multiplications of two

649
00:34:35,699 --> 00:34:39,060
polynomials we can use fft type of

650
00:34:39,060 --> 00:34:42,179
technique or DFD type of techniques is

651
00:34:42,179 --> 00:34:46,760
like we we plug in

652
00:34:46,760 --> 00:34:49,800
c2d to the ice power right so this is

653
00:34:49,800 --> 00:34:53,040
classical so usually in algorithm books

654
00:34:53,040 --> 00:34:56,639
you see this c2d to the I as Omega to

655
00:34:56,639 --> 00:34:58,320
the I

656
00:34:58,320 --> 00:35:01,260
so and then you do pointing wise

657
00:35:01,260 --> 00:35:03,660
multiplication and you convert that back

658
00:35:03,660 --> 00:35:07,380
so one beautiful thing about this uh

659
00:35:07,380 --> 00:35:11,579
nasma transform is because of Cassie two

660
00:35:11,579 --> 00:35:16,520
two D belongs to e so everything here

661
00:35:16,520 --> 00:35:22,260
has integer coefficients okay so if they

662
00:35:22,260 --> 00:35:25,320
have integer coefficients and then they

663
00:35:25,320 --> 00:35:28,260
can be computed over the exponent which

664
00:35:28,260 --> 00:35:32,040
is compatible with fhew

665
00:35:32,040 --> 00:35:34,320
Okay so

666
00:35:34,320 --> 00:35:36,320
we can further

667
00:35:36,320 --> 00:35:39,960
optimize this by recursion so the idea

668
00:35:39,960 --> 00:35:43,020
is we compute if we want to compute

669
00:35:43,020 --> 00:35:45,359
multiplication of K we reduce to

670
00:35:45,359 --> 00:35:49,500
Computing 2D points on 0 minus one zero

671
00:35:49,500 --> 00:35:52,380
minus two that are up to E1

672
00:35:52,380 --> 00:35:55,500
so after some computation this would

673
00:35:55,500 --> 00:35:58,440
require 2 to the row and the D to the

674
00:35:58,440 --> 00:36:00,180
row plus one

675
00:36:00,180 --> 00:36:02,160
say multiplications

676
00:36:02,160 --> 00:36:06,420
and to do inverse homomorphic inverse

677
00:36:06,420 --> 00:36:11,339
DFT recursively and we also roughly need

678
00:36:11,339 --> 00:36:15,359
order row times 2 to the Row D to the

679
00:36:15,359 --> 00:36:18,359
row plus one so this is because like I

680
00:36:18,359 --> 00:36:22,619
pre-calculated all the numbers and if if

681
00:36:22,619 --> 00:36:26,820
you are interested in like those details

682
00:36:26,820 --> 00:36:29,339
you you can just like analyze those

683
00:36:29,339 --> 00:36:33,900
algorithms okay so but the important

684
00:36:33,900 --> 00:36:37,020
thing is this fhew is not spammar

685
00:36:37,020 --> 00:36:40,740
transformed they had this conflict uh

686
00:36:40,740 --> 00:36:42,240
constraints

687
00:36:42,240 --> 00:36:45,420
so if you want to improve

688
00:36:45,420 --> 00:36:49,079
complexity you need to choose a deeper

689
00:36:49,079 --> 00:36:53,220
recursion depth okay recursive step

690
00:36:53,220 --> 00:36:57,060
but on the other hand the error also

691
00:36:57,060 --> 00:36:59,700
grows or noise grows with the

692
00:36:59,700 --> 00:37:02,660
computation depth row okay so

693
00:37:02,660 --> 00:37:06,780
particularly Lambda to a row so if you

694
00:37:06,780 --> 00:37:09,300
want polynomial modulus

695
00:37:09,300 --> 00:37:11,820
then you can only choose row to be

696
00:37:11,820 --> 00:37:13,920
constant

697
00:37:13,920 --> 00:37:15,859
so now

698
00:37:15,859 --> 00:37:20,339
the overall complexity would be Lambda 1

699
00:37:20,339 --> 00:37:22,740
plus 1 over row homomorphic

700
00:37:22,740 --> 00:37:26,599
multiplications or equivalently

701
00:37:26,599 --> 00:37:30,960
Lambda 1 over row in for amortized

702
00:37:30,960 --> 00:37:33,960
complexity so homophobic multiplications

703
00:37:33,960 --> 00:37:38,640
per input lwe so this is basically how

704
00:37:38,640 --> 00:37:40,380
they achieve it

705
00:37:40,380 --> 00:37:44,880
so now let's see by using our

706
00:37:44,880 --> 00:37:47,760
bootstrapping one where can we enjoy

707
00:37:47,760 --> 00:37:51,359
your free minutes okay minutes yeah two

708
00:37:51,359 --> 00:37:52,859
more slides

709
00:37:52,859 --> 00:37:56,099
so we can improve the basic

710
00:37:56,099 --> 00:37:59,760
multiplication here and then

711
00:37:59,760 --> 00:38:04,320
um because we have simd and then we can

712
00:38:04,320 --> 00:38:06,900
improve the overall to uh to something

713
00:38:06,900 --> 00:38:07,980
like this

714
00:38:07,980 --> 00:38:10,260
so overall

715
00:38:10,260 --> 00:38:15,119
because by we improve this to uh

716
00:38:15,119 --> 00:38:18,839
D to the row so the overall complexity

717
00:38:18,839 --> 00:38:22,200
would be overall amortized complexity

718
00:38:22,200 --> 00:38:25,079
will be ordered Toyota one

719
00:38:25,079 --> 00:38:27,839
so this is how we get the here

720
00:38:27,839 --> 00:38:31,520
so finally the results and computation

721
00:38:31,520 --> 00:38:35,640
comparison is we just add one more one

722
00:38:35,640 --> 00:38:38,940
more row to the table which is by using

723
00:38:38,940 --> 00:38:42,359
our bootstrapping one applied to ms-18

724
00:38:42,359 --> 00:38:44,160
and of course there are a lot of

725
00:38:44,160 --> 00:38:46,440
technical details

726
00:38:46,440 --> 00:38:50,820
so finally thank you for

727
00:38:50,820 --> 00:38:53,460
for listening and there is one more

728
00:38:53,460 --> 00:38:57,900
person I really like to thank who is

729
00:38:57,900 --> 00:38:59,579
this

730
00:38:59,579 --> 00:39:00,780
yeah

731
00:39:00,780 --> 00:39:03,599
yeah you know who this person is

732
00:39:03,599 --> 00:39:06,480
so yeah messy

733
00:39:06,480 --> 00:39:15,420
[Applause]

734
00:39:15,420 --> 00:39:18,140
any questions

735
00:39:26,460 --> 00:39:28,800
thank you for the talk and beautiful

736
00:39:28,800 --> 00:39:30,320
contribution

737
00:39:30,320 --> 00:39:34,980
to you have any actual parameter purpose

738
00:39:34,980 --> 00:39:39,839
or any um implementation opened

739
00:39:39,839 --> 00:39:43,680
um so the short answer is we want to

740
00:39:43,680 --> 00:39:47,240
write bootstrapping three

741
00:39:48,320 --> 00:39:51,000
thank you so currently we don't

742
00:39:51,000 --> 00:39:54,300
everything is asymptotic and we really

743
00:39:54,300 --> 00:39:57,480
look forward to determining whether how

744
00:39:57,480 --> 00:40:00,000
to make this really practical but

745
00:40:00,000 --> 00:40:02,400
currently there are several limitations

746
00:40:02,400 --> 00:40:05,339
so one limitation is uh

747
00:40:05,339 --> 00:40:09,599
I don't think we have a like a fast

748
00:40:09,599 --> 00:40:11,880
enough library for General Cyclone

749
00:40:11,880 --> 00:40:17,099
Atomic ring so this open fhe Library

750
00:40:17,099 --> 00:40:21,000
they said in future work they they want

751
00:40:21,000 --> 00:40:23,760
to build this and I hope they can build

752
00:40:23,760 --> 00:40:26,460
this as soon as possible so hopefully

753
00:40:26,460 --> 00:40:28,920
this work will give them a little bit

754
00:40:28,920 --> 00:40:32,940
more motivation to develop this

755
00:40:32,940 --> 00:40:37,500
or do you have any suggested parameters

756
00:40:37,500 --> 00:40:38,099
um

757
00:40:38,099 --> 00:40:40,440
for example LW dimension

758
00:40:40,440 --> 00:40:45,780
so I uh I I don't have the suggestive

759
00:40:45,780 --> 00:40:48,900
parameter now but this requires like a

760
00:40:48,900 --> 00:40:52,320
sitting down and running this a lot of

761
00:40:52,320 --> 00:40:55,500
very solvers and to to determine like

762
00:40:55,500 --> 00:40:59,220
the best parameters

763
00:41:05,160 --> 00:41:08,339
hello thank you for the presentation I

764
00:41:08,339 --> 00:41:09,900
was so if I understood everything

765
00:41:09,900 --> 00:41:12,240
correctly you try to use the framework

766
00:41:12,240 --> 00:41:14,760
from the first that you present in your

767
00:41:14,760 --> 00:41:16,020
first paper

768
00:41:16,020 --> 00:41:19,140
to optimize the quadratic step like you

769
00:41:19,140 --> 00:41:20,880
use these Lots you pack in a different

770
00:41:20,880 --> 00:41:22,320
way and you are trying to essentially

771
00:41:22,320 --> 00:41:24,240
optimize the quadratic step of the

772
00:41:24,240 --> 00:41:26,520
inverse fft the homework inverse fft

773
00:41:26,520 --> 00:41:28,560
right but I was

774
00:41:28,560 --> 00:41:31,740
wondering this looks like a complicated

775
00:41:31,740 --> 00:41:35,400
way of using these Lots because if the

776
00:41:35,400 --> 00:41:39,420
cost of ms-818 was already Lambda to the

777
00:41:39,420 --> 00:41:41,880
power of one over hope or ciphertext

778
00:41:41,880 --> 00:41:46,140
right maybe you could just try to have

779
00:41:46,140 --> 00:41:49,280
R the number of slots in your first work

780
00:41:49,280 --> 00:41:52,320
uh bigger than this and then just run

781
00:41:52,320 --> 00:41:54,900
mshing in parallel in all these lots and

782
00:41:54,900 --> 00:41:57,599
then amortized cost would already be a

783
00:41:57,599 --> 00:42:00,780
big oaf like poly log right as I showed

784
00:42:00,780 --> 00:42:02,820
I was just wondering if you consider

785
00:42:02,820 --> 00:42:07,380
this oh you you mean running MSR 18 like

786
00:42:07,380 --> 00:42:10,320
directly in parallel yes

787
00:42:10,320 --> 00:42:11,160
um

788
00:42:11,160 --> 00:42:14,300
I think basically I

789
00:42:14,300 --> 00:42:17,940
say we are presenting like uh

790
00:42:17,940 --> 00:42:21,119
um so in a nutshell our core approach is

791
00:42:21,119 --> 00:42:22,980
like this

792
00:42:22,980 --> 00:42:26,460
um running the the DFT everything in

793
00:42:26,460 --> 00:42:28,440
parallel and but

794
00:42:28,440 --> 00:42:33,720
um I I'm not sure if we can say run Ms

795
00:42:33,720 --> 00:42:39,480
at 18 say in a black box way say run run

796
00:42:39,480 --> 00:42:41,520
it in parallel in a black box away

797
00:42:41,520 --> 00:42:44,160
that's something I'm not sure

798
00:42:44,160 --> 00:42:47,339
but but I can do so what we are doing is

799
00:42:47,339 --> 00:42:49,740
like we open the black box and we run

800
00:42:49,740 --> 00:42:54,799
component every component in in parallel

801
00:42:56,820 --> 00:42:58,859
okay so let's thank the the speaker

802
00:42:58,859 --> 00:43:00,170
again

803
00:43:00,170 --> 00:43:06,420
[Applause]

804
00:43:06,420 --> 00:43:09,920
thank you we have the lunch break

