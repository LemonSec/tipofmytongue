1
00:00:00,240 --> 00:00:02,940
yeah so maybe let's continue with the

2
00:00:02,940 --> 00:00:06,240
second part of this session

3
00:00:06,240 --> 00:00:07,980
um

4
00:00:07,980 --> 00:00:12,540
the next paper is

5
00:00:12,540 --> 00:00:14,219
super puck

6
00:00:14,219 --> 00:00:17,520
dishonest majority NPC with constant

7
00:00:17,520 --> 00:00:19,500
online communication

8
00:00:19,500 --> 00:00:22,080
so the this is a work by Daniel escudero

9
00:00:22,080 --> 00:00:26,359
vipul goyal Antigone politics

10
00:00:27,080 --> 00:00:31,740
but none of them have come so then we

11
00:00:31,740 --> 00:00:33,020
have a guest star

12
00:00:33,020 --> 00:00:36,000
Peter Scholl who will present the the

13
00:00:36,000 --> 00:00:37,920
paper

14
00:00:37,920 --> 00:00:39,840
thanks very much for the introduction

15
00:00:39,840 --> 00:00:41,340
so yeah unfortunately none of the

16
00:00:41,340 --> 00:00:42,719
authors of the paper could make it to

17
00:00:42,719 --> 00:00:44,640
the conference so I'm presenting this

18
00:00:44,640 --> 00:00:45,600
instead

19
00:00:45,600 --> 00:00:48,600
so Super PAC is on a secure multi-party

20
00:00:48,600 --> 00:00:50,820
computation protocol where we have a set

21
00:00:50,820 --> 00:00:52,559
of parties who want to securely evaluate

22
00:00:52,559 --> 00:00:55,460
some function on their private inputs

23
00:00:55,460 --> 00:00:58,260
and the specific NPC setting in this

24
00:00:58,260 --> 00:01:01,500
talk is secure computation of arithmetic

25
00:01:01,500 --> 00:01:03,780
circuits over some finite field

26
00:01:03,780 --> 00:01:05,400
and it's in the dishonest majority

27
00:01:05,400 --> 00:01:06,320
setting

28
00:01:06,320 --> 00:01:08,880
so we have a constant fraction of the

29
00:01:08,880 --> 00:01:11,460
parties who may be corrupted so there's

30
00:01:11,460 --> 00:01:13,320
some parameter Epsilon Which is less

31
00:01:13,320 --> 00:01:15,240
than half and we assume that at least

32
00:01:15,240 --> 00:01:17,280
Epsilon n parties will be honest in the

33
00:01:17,280 --> 00:01:18,420
protocol

34
00:01:18,420 --> 00:01:20,520
and the goal is to achieve malicious

35
00:01:20,520 --> 00:01:23,580
security with abort

36
00:01:23,580 --> 00:01:27,000
and the main result in this work is a

37
00:01:27,000 --> 00:01:29,159
new protocol in this setting where the

38
00:01:29,159 --> 00:01:32,340
total communication cost is a constant

39
00:01:32,340 --> 00:01:33,720
number of field elements per

40
00:01:33,720 --> 00:01:35,759
multiplication gate across all of the

41
00:01:35,759 --> 00:01:36,840
parties

42
00:01:36,840 --> 00:01:39,540
and the constant in this work are pretty

43
00:01:39,540 --> 00:01:42,320
good it's it's quite practical and

44
00:01:42,320 --> 00:01:44,640
focused on being something you can

45
00:01:44,640 --> 00:01:45,979
implement

46
00:01:45,979 --> 00:01:48,960
and the nice feature about this constant

47
00:01:48,960 --> 00:01:51,780
communication cost is that if you fix

48
00:01:51,780 --> 00:01:54,899
the number of parties in and imagine the

49
00:01:54,899 --> 00:01:56,640
you know as the number of honest parties

50
00:01:56,640 --> 00:01:59,100
in this protocol increases as Epsilon

51
00:01:59,100 --> 00:02:01,020
increases then the communication cost

52
00:02:01,020 --> 00:02:03,119
actually decreases proportional to 1

53
00:02:03,119 --> 00:02:04,680
over Epsilon

54
00:02:04,680 --> 00:02:06,540
and the protocols divided into these

55
00:02:06,540 --> 00:02:09,720
three phases the online phase and two

56
00:02:09,720 --> 00:02:12,000
pre-processing phases where the first

57
00:02:12,000 --> 00:02:14,280
pre-processing phase is independent of

58
00:02:14,280 --> 00:02:16,560
both the inputs to the computation and

59
00:02:16,560 --> 00:02:18,720
the circuit being evaluated but this one

60
00:02:18,720 --> 00:02:20,099
has linear costs in the number of

61
00:02:20,099 --> 00:02:22,020
parties whereas the second

62
00:02:22,020 --> 00:02:23,700
pre-processing which only depends on the

63
00:02:23,700 --> 00:02:26,099
circuit has again constant communication

64
00:02:26,099 --> 00:02:29,359
like the online phase

65
00:02:29,640 --> 00:02:32,099
okay so in this dishonest majority

66
00:02:32,099 --> 00:02:35,280
setting of MPC I guess most protocols

67
00:02:35,280 --> 00:02:37,680
tend to focus on the harder case of n

68
00:02:37,680 --> 00:02:40,080
minus one out of n Corruptions uh but

69
00:02:40,080 --> 00:02:42,720
this also tends to be less efficient

70
00:02:42,720 --> 00:02:44,099
um so this is things like the speech

71
00:02:44,099 --> 00:02:46,440
protocol and in this case if you want to

72
00:02:46,440 --> 00:02:48,900
adapt these protocols to the less than

73
00:02:48,900 --> 00:02:51,780
full threshold setting and then it seems

74
00:02:51,780 --> 00:02:53,040
like the best thing you can do is just

75
00:02:53,040 --> 00:02:55,739
to remove n minus t minus one parties

76
00:02:55,739 --> 00:02:57,780
and run the protocol among the remaining

77
00:02:57,780 --> 00:03:00,239
t plus one parties

78
00:03:00,239 --> 00:03:02,540
but if you want to do better than that

79
00:03:02,540 --> 00:03:04,920
perhaps the most relevant work is this

80
00:03:04,920 --> 00:03:07,980
GPS 22 paper from last year which also

81
00:03:07,980 --> 00:03:10,080
gets a constant total communication per

82
00:03:10,080 --> 00:03:12,060
multiplication guide but with much worse

83
00:03:12,060 --> 00:03:13,560
constants so it's something that's not

84
00:03:13,560 --> 00:03:15,200
quite so practical

85
00:03:15,200 --> 00:03:17,700
one of the relevant line of work is

86
00:03:17,700 --> 00:03:20,760
there's tiny keys protocol in a similar

87
00:03:20,760 --> 00:03:23,340
setting but for Boolean circuits but

88
00:03:23,340 --> 00:03:25,080
they're the focus of optimization is

89
00:03:25,080 --> 00:03:27,120
more on the pre-processing protocol and

90
00:03:27,120 --> 00:03:28,620
the online phase still has linear

91
00:03:28,620 --> 00:03:29,879
communication

92
00:03:29,879 --> 00:03:32,400
and finally there's another paper last

93
00:03:32,400 --> 00:03:34,620
year called turbo pack which is in the

94
00:03:34,620 --> 00:03:36,599
honest majority setting but also has

95
00:03:36,599 --> 00:03:38,459
constant communication in the online

96
00:03:38,459 --> 00:03:41,879
phase and uses similar techniques

97
00:03:41,879 --> 00:03:44,700
uh so the most relevant work to compare

98
00:03:44,700 --> 00:03:45,480
with

99
00:03:45,480 --> 00:03:48,120
um out of all of these is the one of the

100
00:03:48,120 --> 00:03:49,680
latest incarnations of the speech

101
00:03:49,680 --> 00:03:52,379
protocol called turbo speeds and so here

102
00:03:52,379 --> 00:03:53,819
you can see how that compares with Super

103
00:03:53,819 --> 00:03:55,140
PAC

104
00:03:55,140 --> 00:03:57,959
and notice that for Turbo speeds each of

105
00:03:57,959 --> 00:03:59,400
the three phases have linear

106
00:03:59,400 --> 00:04:01,319
communication in the number of parties

107
00:04:01,319 --> 00:04:03,959
whereas Super PAC has this constant for

108
00:04:03,959 --> 00:04:05,959
the online and circuit dependent phases

109
00:04:05,959 --> 00:04:09,060
and in the circuit independent phase is

110
00:04:09,060 --> 00:04:11,939
pretty similar to how turbo speeds looks

111
00:04:11,939 --> 00:04:15,000
roughly 6n multiplication field elements

112
00:04:15,000 --> 00:04:16,260
per multiplication

113
00:04:16,260 --> 00:04:19,139
so you can see this a little more in

114
00:04:19,139 --> 00:04:21,839
detail on these graphs so here in the

115
00:04:21,839 --> 00:04:23,940
graph on the left you can fix a

116
00:04:23,940 --> 00:04:27,540
particular Epsilon for instance if you

117
00:04:27,540 --> 00:04:30,000
have 10 of the parties being honest

118
00:04:30,000 --> 00:04:34,020
and then you can see that if you have an

119
00:04:34,020 --> 00:04:37,199
NPC protocol with at least n is 34

120
00:04:37,199 --> 00:04:40,380
parties in total then Super PAC will be

121
00:04:40,380 --> 00:04:42,780
will outperform the best previous speeds

122
00:04:42,780 --> 00:04:45,600
protocol for all values then larger than

123
00:04:45,600 --> 00:04:47,940
this and for another data point if you

124
00:04:47,940 --> 00:04:50,040
increase the number of honest parties to

125
00:04:50,040 --> 00:04:52,979
30 then you only need 15 parties before

126
00:04:52,979 --> 00:04:54,840
superpac starts becoming worthwhile

127
00:04:54,840 --> 00:04:57,360
compared with other protocols

128
00:04:57,360 --> 00:04:59,280
and likewise you can look at the graph

129
00:04:59,280 --> 00:05:01,380
on the right where you fix the number of

130
00:05:01,380 --> 00:05:04,680
parties for instance to 32 and then you

131
00:05:04,680 --> 00:05:06,720
know look at what's the smallest Epsilon

132
00:05:06,720 --> 00:05:08,759
you can get away with such that this

133
00:05:08,759 --> 00:05:10,560
protocol is worthwhile and in this case

134
00:05:10,560 --> 00:05:13,880
it's uh 26 percent

135
00:05:14,940 --> 00:05:17,040
and so that those graphs were for the

136
00:05:17,040 --> 00:05:18,600
online phase if you look at the

137
00:05:18,600 --> 00:05:20,880
pre-processing phases then it's a bit

138
00:05:20,880 --> 00:05:22,440
different because here both of the

139
00:05:22,440 --> 00:05:24,320
protocols have linear communication cost

140
00:05:24,320 --> 00:05:26,340
reflected by the straight lines and the

141
00:05:26,340 --> 00:05:27,660
graphs

142
00:05:27,660 --> 00:05:29,880
um but the thing to look at is so the

143
00:05:29,880 --> 00:05:32,820
the blue lines here a Super Pac and

144
00:05:32,820 --> 00:05:34,680
notice that they're often a little bit

145
00:05:34,680 --> 00:05:36,780
worse than the communication costs for

146
00:05:36,780 --> 00:05:39,660
Turbo speeds but not by a huge amount in

147
00:05:39,660 --> 00:05:41,699
effect sometimes a little better when

148
00:05:41,699 --> 00:05:43,740
the number of parties is very large so

149
00:05:43,740 --> 00:05:45,479
you're not paying a huge cost in the

150
00:05:45,479 --> 00:05:47,639
pre-processing to get this benefit of a

151
00:05:47,639 --> 00:05:51,199
constant Communication online phase

152
00:05:51,479 --> 00:05:54,120
the authors also implemented most parts

153
00:05:54,120 --> 00:05:56,660
of the protocol and Ransom benchmarks

154
00:05:56,660 --> 00:05:59,460
which you can see in this table so the

155
00:05:59,460 --> 00:06:01,979
bottom two rows of the table are just

156
00:06:01,979 --> 00:06:03,740
the theoretical communication costs

157
00:06:03,740 --> 00:06:06,479
measured in terms of the Improvement

158
00:06:06,479 --> 00:06:09,419
Factor compared with turbo speeds and so

159
00:06:09,419 --> 00:06:11,340
here you can see that it has in practice

160
00:06:11,340 --> 00:06:13,080
around two to six times less

161
00:06:13,080 --> 00:06:15,840
communication than turbo speeds for say

162
00:06:15,840 --> 00:06:17,940
32 or 80 parties

163
00:06:17,940 --> 00:06:20,039
and then of course the question is how

164
00:06:20,039 --> 00:06:21,780
does this translate into a real world

165
00:06:21,780 --> 00:06:22,979
performance improvements for the

166
00:06:22,979 --> 00:06:24,300
implementation

167
00:06:24,300 --> 00:06:26,940
and if you first look at a high

168
00:06:26,940 --> 00:06:29,460
bandwidth network setting it's not so

169
00:06:29,460 --> 00:06:31,139
great it's sometimes a little bit slower

170
00:06:31,139 --> 00:06:33,600
than Super Pac and then turbo speeds

171
00:06:33,600 --> 00:06:35,940
sometimes a little bit faster that as

172
00:06:35,940 --> 00:06:38,340
you restrict the bandwidth to um to

173
00:06:38,340 --> 00:06:39,780
lower bandwidth settings say 100

174
00:06:39,780 --> 00:06:43,199
megabits or 10 megabits then you start

175
00:06:43,199 --> 00:06:44,460
to get much better performance

176
00:06:44,460 --> 00:06:46,620
improvements compared with turbo speeds

177
00:06:46,620 --> 00:06:48,900
so here in the 10 megabit setting you

178
00:06:48,900 --> 00:06:50,960
have around two to six times Improvement

179
00:06:50,960 --> 00:06:53,699
which pretty much much reflects what

180
00:06:53,699 --> 00:06:54,960
you'd expect from the theoretical

181
00:06:54,960 --> 00:06:57,360
communication costs showing that here

182
00:06:57,360 --> 00:07:00,860
communication is really the bottleneck

183
00:07:01,380 --> 00:07:03,660
okay so for the rest of the talk I want

184
00:07:03,660 --> 00:07:05,340
to give an overview of the main ideas in

185
00:07:05,340 --> 00:07:07,020
the protocol

186
00:07:07,020 --> 00:07:09,180
um so Super PAC is based on packed

187
00:07:09,180 --> 00:07:11,520
secret sharing which is a variant of

188
00:07:11,520 --> 00:07:14,400
Shamir secret sharing where instead of

189
00:07:14,400 --> 00:07:17,220
secret sharing a single field element at

190
00:07:17,220 --> 00:07:19,620
once will share a vector of K field

191
00:07:19,620 --> 00:07:22,620
elements V1 up to VK

192
00:07:22,620 --> 00:07:24,300
and we'll do this by sampling a

193
00:07:24,300 --> 00:07:27,060
polynomial of degree D and in practice

194
00:07:27,060 --> 00:07:29,280
the protocol uses different values of D

195
00:07:29,280 --> 00:07:32,099
at different places so this is a

196
00:07:32,099 --> 00:07:35,400
parameter and it does this based on some

197
00:07:35,400 --> 00:07:38,759
evaluation points first K evaluation

198
00:07:38,759 --> 00:07:42,240
points alpha 1 to Alpha k uh which which

199
00:07:42,240 --> 00:07:45,000
are used to encode the messages being

200
00:07:45,000 --> 00:07:48,419
shared VI as uh at the polynomial

201
00:07:48,419 --> 00:07:50,940
and then the polymerase sample to be to

202
00:07:50,940 --> 00:07:53,099
be of degree D random apart from these

203
00:07:53,099 --> 00:07:54,360
evaluations

204
00:07:54,360 --> 00:07:56,340
and then to define the shares you do

205
00:07:56,340 --> 00:07:57,900
exactly as you do in Shamir sharing

206
00:07:57,900 --> 00:08:00,360
where you define a n evaluation points

207
00:08:00,360 --> 00:08:03,539
beta 1 to Beta n and give to party I the

208
00:08:03,539 --> 00:08:06,240
value F of beta I

209
00:08:06,240 --> 00:08:07,919
and the nice thing about this packed

210
00:08:07,919 --> 00:08:10,259
Shamir SQL sharing scheme is that even

211
00:08:10,259 --> 00:08:12,720
though your secret sharing a vector of

212
00:08:12,720 --> 00:08:15,300
up to K field elements the size of each

213
00:08:15,300 --> 00:08:17,099
party's share is just a single field

214
00:08:17,099 --> 00:08:19,400
element

215
00:08:19,979 --> 00:08:22,259
so then in the protocol

216
00:08:22,259 --> 00:08:25,259
um the online phase has an invariant

217
00:08:25,259 --> 00:08:26,699
which is maintained throughout the

218
00:08:26,699 --> 00:08:28,199
circuit evaluation

219
00:08:28,199 --> 00:08:31,500
which is that at each wire say a y

220
00:08:31,500 --> 00:08:35,458
indexed by some some index Alpha uh if

221
00:08:35,458 --> 00:08:37,919
this wire has a the plain text value V

222
00:08:37,919 --> 00:08:40,380
which is the actual value of the

223
00:08:40,380 --> 00:08:41,940
computation at this point of the circuit

224
00:08:41,940 --> 00:08:45,420
then we associate with this wire a

225
00:08:45,420 --> 00:08:48,180
special random Mass called Lambda

226
00:08:48,180 --> 00:08:50,459
which is not known to any parties and

227
00:08:50,459 --> 00:08:52,380
will in fact be secret shared in some

228
00:08:52,380 --> 00:08:54,540
flavor of packed ticket sharing

229
00:08:54,540 --> 00:08:56,600
and we use this to define

230
00:08:56,600 --> 00:09:00,060
a masking of the plain text value v as

231
00:09:00,060 --> 00:09:02,820
Mu which is V minus Lambda so this could

232
00:09:02,820 --> 00:09:04,440
be given out in public look for

233
00:09:04,440 --> 00:09:08,040
efficiency mu is just given to party P1

234
00:09:08,040 --> 00:09:10,860
and note that at this point for each

235
00:09:10,860 --> 00:09:12,200
wire

236
00:09:12,200 --> 00:09:14,700
the plain tag value V is entirely

237
00:09:14,700 --> 00:09:18,140
determined by mu and Lambda

238
00:09:18,720 --> 00:09:22,019
okay so given this setup and the idea

239
00:09:22,019 --> 00:09:24,000
that we're using practical chairing the

240
00:09:24,000 --> 00:09:26,820
main challenge in any MPC protocol where

241
00:09:26,820 --> 00:09:29,580
you want to exploit pack to good sharing

242
00:09:29,580 --> 00:09:32,519
is that okay you naturally will want to

243
00:09:32,519 --> 00:09:35,100
evaluate say k multiplication gates in

244
00:09:35,100 --> 00:09:37,800
parallel unpacked secret shares but then

245
00:09:37,800 --> 00:09:40,260
as you go through the circuit from one

246
00:09:40,260 --> 00:09:42,240
layer to the next you often need to

247
00:09:42,240 --> 00:09:43,980
reorder these elements of packed secret

248
00:09:43,980 --> 00:09:46,620
sharings to match the wiring of the

249
00:09:46,620 --> 00:09:49,200
circuit which name which you know unless

250
00:09:49,200 --> 00:09:51,600
you're doing a pure simdi circuit will

251
00:09:51,600 --> 00:09:53,279
require some kind of routing or

252
00:09:53,279 --> 00:09:55,620
permutation protocol and that's kind of

253
00:09:55,620 --> 00:09:57,180
the traditional approach to doing this

254
00:09:57,180 --> 00:09:59,000
with many older works

255
00:09:59,000 --> 00:10:01,620
but the the nice idea of this this

256
00:10:01,620 --> 00:10:04,260
protocol is to follow some methods from

257
00:10:04,260 --> 00:10:05,820
the turbo pack protocol in the honest

258
00:10:05,820 --> 00:10:07,800
majority setting which gives you a way

259
00:10:07,800 --> 00:10:10,260
to maintain this wiring consistency with

260
00:10:10,260 --> 00:10:11,640
very little overhead and without having

261
00:10:11,640 --> 00:10:15,860
to do any complex permutation Networks

262
00:10:16,500 --> 00:10:18,959
um so to do this we'll rely on this

263
00:10:18,959 --> 00:10:20,899
circuit dependent pre-processing phase

264
00:10:20,899 --> 00:10:23,760
which will set up special sharings of

265
00:10:23,760 --> 00:10:26,779
the Lambda masks across the circuit

266
00:10:26,779 --> 00:10:29,700
and so you divide each layer of the

267
00:10:29,700 --> 00:10:31,440
circuit into a batches of K

268
00:10:31,440 --> 00:10:33,000
multiplication Gates

269
00:10:33,000 --> 00:10:35,519
which will be evaluated in parallel and

270
00:10:35,519 --> 00:10:37,500
then you take the batch of say left

271
00:10:37,500 --> 00:10:39,959
input wires and right input wires for

272
00:10:39,959 --> 00:10:41,940
each of these batch of multiplication

273
00:10:41,940 --> 00:10:44,220
Gates and then prepare them using packed

274
00:10:44,220 --> 00:10:45,660
SQL sharing so you take the vector of

275
00:10:45,660 --> 00:10:48,300
lambdas and distribute pack chairs to

276
00:10:48,300 --> 00:10:50,279
the parties for this random Lambda

277
00:10:50,279 --> 00:10:51,180
values

278
00:10:51,180 --> 00:10:53,579
so this requires a bit of interaction

279
00:10:53,579 --> 00:10:56,100
and then in the online phase when you

280
00:10:56,100 --> 00:10:57,740
have this setup

281
00:10:57,740 --> 00:11:00,360
you evaluate these gates in the same

282
00:11:00,360 --> 00:11:02,640
batch of K gates at once

283
00:11:02,640 --> 00:11:05,000
and by exploiting the fact that

284
00:11:05,000 --> 00:11:07,500
according to this invariant we defined

285
00:11:07,500 --> 00:11:11,700
P1 will always know these mu values in

286
00:11:11,700 --> 00:11:12,600
the clear

287
00:11:12,600 --> 00:11:15,720
for every wire Alpha then it can just

288
00:11:15,720 --> 00:11:17,399
kind of collect the right set of new

289
00:11:17,399 --> 00:11:19,019
values which are needed for this set of

290
00:11:19,019 --> 00:11:21,180
wires and use these to help with the

291
00:11:21,180 --> 00:11:23,160
multiplication protocol without any any

292
00:11:23,160 --> 00:11:26,579
fancy routing process

293
00:11:26,579 --> 00:11:27,959
um so going into this in a bit more

294
00:11:27,959 --> 00:11:29,579
detail

295
00:11:29,579 --> 00:11:31,980
um so if we have a batch of K

296
00:11:31,980 --> 00:11:33,660
multiplication Gates

297
00:11:33,660 --> 00:11:37,920
with inputs um that wires Alpha and beta

298
00:11:37,920 --> 00:11:40,339
we have these corresponding

299
00:11:40,339 --> 00:11:44,459
Mast values mu for Mu Alpha and mu beta

300
00:11:44,459 --> 00:11:47,160
which are known to party P1

301
00:11:47,160 --> 00:11:49,380
and in the first part of the protocol

302
00:11:49,380 --> 00:11:51,360
for the multiplication gate P1 will take

303
00:11:51,360 --> 00:11:54,060
these and distribute fresh Shamir

304
00:11:54,060 --> 00:11:56,279
sharings or pack Shamir sharings of

305
00:11:56,279 --> 00:11:59,700
degree K minus 1 to the other parties

306
00:11:59,700 --> 00:12:01,680
so note that this is a this is the pack

307
00:12:01,680 --> 00:12:04,380
chimney sharing of K elements of degree

308
00:12:04,380 --> 00:12:06,120
K minus one so there's actually no

309
00:12:06,120 --> 00:12:08,160
Randomness in this polynomial but it

310
00:12:08,160 --> 00:12:09,660
doesn't really matter because these new

311
00:12:09,660 --> 00:12:11,480
values are public anyway

312
00:12:11,480 --> 00:12:13,920
so the the idea of the Shamir sharing

313
00:12:13,920 --> 00:12:16,800
here is just to kind of optimize the

314
00:12:16,800 --> 00:12:19,079
communication

315
00:12:19,079 --> 00:12:19,920
um

316
00:12:19,920 --> 00:12:22,200
and then from the invariant for the

317
00:12:22,200 --> 00:12:23,820
input wise of the multiplications and

318
00:12:23,820 --> 00:12:25,920
also from the pre-processing we have

319
00:12:25,920 --> 00:12:28,560
these Lambda values all secret shared

320
00:12:28,560 --> 00:12:30,540
with packed sharings so the Lambda

321
00:12:30,540 --> 00:12:33,000
Alphas the Lambda betas which will be of

322
00:12:33,000 --> 00:12:35,760
degree n minus K and then the Lambda

323
00:12:35,760 --> 00:12:39,120
Gamma which will be a degree n minus one

324
00:12:39,120 --> 00:12:40,740
and then also their special value

325
00:12:40,740 --> 00:12:43,380
Capital gamma which is the product of

326
00:12:43,380 --> 00:12:46,019
the input lambdas which will be computed

327
00:12:46,019 --> 00:12:47,700
in the pre-processing using some packed

328
00:12:47,700 --> 00:12:50,160
multiplication triple

329
00:12:50,160 --> 00:12:53,100
and given all of these shared values

330
00:12:53,100 --> 00:12:55,260
um you can see that the parties can

331
00:12:55,260 --> 00:12:56,519
actually just take an appropriate

332
00:12:56,519 --> 00:12:58,260
combination of these by doing some local

333
00:12:58,260 --> 00:13:01,019
multiplications and summing them up and

334
00:13:01,019 --> 00:13:02,579
they will end up with a packed sharing

335
00:13:02,579 --> 00:13:05,940
of degree n minus 1 of the right Vector

336
00:13:05,940 --> 00:13:09,000
of the MU values for the output wire

337
00:13:09,000 --> 00:13:11,040
once all the parties have this they can

338
00:13:11,040 --> 00:13:13,380
just reconstruct it to P1 who will learn

339
00:13:13,380 --> 00:13:15,420
the MU value and then maintain the

340
00:13:15,420 --> 00:13:17,579
required invariant

341
00:13:17,579 --> 00:13:20,040
so this is the this is a kind of

342
00:13:20,040 --> 00:13:22,200
simplified version of the basic protocol

343
00:13:22,200 --> 00:13:24,240
which is at this point only passively

344
00:13:24,240 --> 00:13:25,700
secure

345
00:13:25,700 --> 00:13:28,920
there's one more change that is made in

346
00:13:28,920 --> 00:13:30,420
the final protocol

347
00:13:30,420 --> 00:13:32,399
which is an optimization to reduce

348
00:13:32,399 --> 00:13:35,160
communication that this this interaction

349
00:13:35,160 --> 00:13:37,680
in the basic multiplication protocol is

350
00:13:37,680 --> 00:13:39,720
combined with the interaction in the

351
00:13:39,720 --> 00:13:43,440
pre-processing used to create them the

352
00:13:43,440 --> 00:13:45,360
products of the secret shared values

353
00:13:45,360 --> 00:13:48,240
with Beaver multiplication so the

354
00:13:48,240 --> 00:13:49,680
details are important but that saves a

355
00:13:49,680 --> 00:13:51,120
bit of communication

356
00:13:51,120 --> 00:13:52,980
but now the main challenge at this point

357
00:13:52,980 --> 00:13:56,279
is to add active security

358
00:13:56,279 --> 00:13:58,680
um so if you recall there are these two

359
00:13:58,680 --> 00:14:01,139
openings in the protocol where I first

360
00:14:01,139 --> 00:14:03,000
um where P1 distributes shares of the MU

361
00:14:03,000 --> 00:14:05,700
values and then the output new value is

362
00:14:05,700 --> 00:14:08,459
open back to P1 and there was nothing in

363
00:14:08,459 --> 00:14:10,200
the passive protocol which ensures these

364
00:14:10,200 --> 00:14:11,639
things are done correctly

365
00:14:11,639 --> 00:14:13,860
and the solution the authors use in this

366
00:14:13,860 --> 00:14:16,200
work is to apply a secret shared

367
00:14:16,200 --> 00:14:18,540
information thoracic Max

368
00:14:18,540 --> 00:14:20,339
um to make sure that these sharings are

369
00:14:20,339 --> 00:14:22,860
generated and reconstructed correctly

370
00:14:22,860 --> 00:14:26,100
and so for this we use two types of two

371
00:14:26,100 --> 00:14:28,260
additional types of sharings one is

372
00:14:28,260 --> 00:14:30,540
standard additive secret sharing denoted

373
00:14:30,540 --> 00:14:32,399
using angle brackets here

374
00:14:32,399 --> 00:14:35,220
and another is a a special kind of

375
00:14:35,220 --> 00:14:37,680
package Shamir sharing where you just

376
00:14:37,680 --> 00:14:41,459
secret share a single scalar here V and

377
00:14:41,459 --> 00:14:43,019
then kind of pack it into the eighth

378
00:14:43,019 --> 00:14:46,260
slot of a packed secret chair where all

379
00:14:46,260 --> 00:14:48,180
the other slots can be just random and

380
00:14:48,180 --> 00:14:50,519
you don't really care about it

381
00:14:50,519 --> 00:14:51,420
um

382
00:14:51,420 --> 00:14:54,000
and these are used to extend the

383
00:14:54,000 --> 00:14:57,060
invariant in the passive protocol by

384
00:14:57,060 --> 00:14:58,100
adding on some additional

385
00:14:58,100 --> 00:15:00,060
authentications of the appropriate

386
00:15:00,060 --> 00:15:01,260
values

387
00:15:01,260 --> 00:15:03,779
so as well as the the MU value which is

388
00:15:03,779 --> 00:15:06,300
known to P1 and the lambdas which are

389
00:15:06,300 --> 00:15:08,160
secret shared with patch Sameer sharings

390
00:15:08,160 --> 00:15:11,279
we now have authentications of both the

391
00:15:11,279 --> 00:15:14,160
MU and the lambdas so these are additive

392
00:15:14,160 --> 00:15:16,620
shares of me each music mu component and

393
00:15:16,620 --> 00:15:19,079
additive shares of each Lambda component

394
00:15:19,079 --> 00:15:21,240
multiplied by Delta

395
00:15:21,240 --> 00:15:24,240
well Delta is a a random random field

396
00:15:24,240 --> 00:15:26,279
element which acts as a secret Mac key

397
00:15:26,279 --> 00:15:28,860
known to no one and also as a kind of

398
00:15:28,860 --> 00:15:30,720
one-time Global setup you have these

399
00:15:30,720 --> 00:15:33,360
special Shamir sharings of Delta you

400
00:15:33,360 --> 00:15:35,399
know packed into the ith coefficient of

401
00:15:35,399 --> 00:15:37,199
the slot which helps with the

402
00:15:37,199 --> 00:15:39,000
multiplication protocol

403
00:15:39,000 --> 00:15:40,620
and so this is the invariant which of

404
00:15:40,620 --> 00:15:41,699
course you want to be maintained after

405
00:15:41,699 --> 00:15:43,560
multiplication so you get the same

406
00:15:43,560 --> 00:15:46,579
property on the outputs

407
00:15:46,579 --> 00:15:48,360
and

408
00:15:48,360 --> 00:15:50,639
so quickly going through

409
00:15:50,639 --> 00:15:52,980
um so the the final protocol with active

410
00:15:52,980 --> 00:15:55,800
security turns out to be roughly the

411
00:15:55,800 --> 00:15:58,139
same as the passive secure one just with

412
00:15:58,139 --> 00:16:01,079
the addition of these mags

413
00:16:01,079 --> 00:16:03,120
um the idea is that when you when P1

414
00:16:03,120 --> 00:16:05,160
distributes the packed sharings of the

415
00:16:05,160 --> 00:16:06,480
MU values at the start of the

416
00:16:06,480 --> 00:16:08,820
multiplication gate the parties will use

417
00:16:08,820 --> 00:16:10,320
some Max which they have to be able to

418
00:16:10,320 --> 00:16:12,720
verify uh that these mues were

419
00:16:12,720 --> 00:16:14,639
distributed correctly

420
00:16:14,639 --> 00:16:16,380
and

421
00:16:16,380 --> 00:16:17,940
based on the invariant and the

422
00:16:17,940 --> 00:16:19,320
pre-processing we'll have these

423
00:16:19,320 --> 00:16:21,839
additional additional mags used to do

424
00:16:21,839 --> 00:16:24,000
the check and also use

425
00:16:24,000 --> 00:16:25,740
um by taking some appropriate

426
00:16:25,740 --> 00:16:27,540
combinations of them to ensure that we

427
00:16:27,540 --> 00:16:29,339
can get the Mac for the output mu value

428
00:16:29,339 --> 00:16:31,680
these to the next gate

429
00:16:31,680 --> 00:16:34,500
um so uh I think I'll skip over the

430
00:16:34,500 --> 00:16:36,720
technical details here

431
00:16:36,720 --> 00:16:39,600
um but basically there is some some like

432
00:16:39,600 --> 00:16:41,399
nice conversion tricks for conversion

433
00:16:41,399 --> 00:16:43,860
converting from special types of Shamir

434
00:16:43,860 --> 00:16:45,860
sharings to additive sharings

435
00:16:45,860 --> 00:16:48,839
which you can exploit to do to get this

436
00:16:48,839 --> 00:16:50,880
kind of multiplication and and get the

437
00:16:50,880 --> 00:16:54,380
max to work out in the output

438
00:16:55,079 --> 00:16:57,120
um so that's all I wanted to say for

439
00:16:57,120 --> 00:17:00,980
this talk uh thanks for your attention

440
00:17:05,220 --> 00:17:07,220
so if there are any questions

441
00:17:07,220 --> 00:17:10,380
Peter can try to answer them even though

442
00:17:10,380 --> 00:17:13,380
he's not an author

443
00:17:13,380 --> 00:17:14,520
I'm

444
00:17:14,520 --> 00:17:16,859
so I mean one thing I was wondering is

445
00:17:16,859 --> 00:17:19,859
is this for any field or is it like

446
00:17:19,859 --> 00:17:23,640
large enough fields or it should be a

447
00:17:23,640 --> 00:17:26,819
large field for the max to work out

448
00:17:26,819 --> 00:17:27,480
um

449
00:17:27,480 --> 00:17:30,360
it could be that you can you can make it

450
00:17:30,360 --> 00:17:32,220
work in small Fields with bigger Max but

451
00:17:32,220 --> 00:17:33,660
I I'm not sure if they do that in the

452
00:17:33,660 --> 00:17:35,640
paper but also there's some mirror

453
00:17:35,640 --> 00:17:37,559
Secrets Theory being used so are they

454
00:17:37,559 --> 00:17:38,940
like well it should be at least as large

455
00:17:38,940 --> 00:17:41,700
as um what n plus k or something

456
00:17:41,700 --> 00:17:43,799
yeah so not over

457
00:17:43,799 --> 00:17:46,260
um F2 for instance

458
00:17:46,260 --> 00:17:48,120
okay

459
00:17:48,120 --> 00:17:51,299
um yeah if there are no more questions

460
00:17:51,299 --> 00:17:55,520
then let's uh thank Peter again

461
00:17:58,860 --> 00:18:01,639
and

462
00:18:03,360 --> 00:18:07,200
the last talk is called detect pack and

463
00:18:07,200 --> 00:18:10,140
batch perfectly secure MPC with linear

464
00:18:10,140 --> 00:18:13,220
communication and constant expected time

465
00:18:13,220 --> 00:18:17,520
it's a work by itai Abraham

466
00:18:17,520 --> 00:18:19,440
um

467
00:18:19,440 --> 00:18:23,580
this is ravani patil and RP tapatra and

468
00:18:23,580 --> 00:18:27,139
ravani is going to give the dog

469
00:18:30,720 --> 00:18:32,880
complexity of perfectly secure MPC

470
00:18:32,880 --> 00:18:34,020
protocols

471
00:18:34,020 --> 00:18:36,900
so let me Begin by introducing MPC or

472
00:18:36,900 --> 00:18:38,640
multi-party computation

473
00:18:38,640 --> 00:18:40,980
MPC allows and mutually distrusting

474
00:18:40,980 --> 00:18:43,080
parties to compute a joint function of

475
00:18:43,080 --> 00:18:45,480
their private inputs now this distrust

476
00:18:45,480 --> 00:18:47,700
among parties is typically moderate as a

477
00:18:47,700 --> 00:18:49,860
centralized adversary which can corrupt

478
00:18:49,860 --> 00:18:51,960
up to T out of the end parties

479
00:18:51,960 --> 00:18:54,840
and the goals of any MPC protocol are

480
00:18:54,840 --> 00:18:57,840
correctness that is the protocol output

481
00:18:57,840 --> 00:18:59,640
should be equal to the function output

482
00:18:59,640 --> 00:19:02,640
and privacy that is nothing beyond the

483
00:19:02,640 --> 00:19:04,020
function output should be revealed to

484
00:19:04,020 --> 00:19:05,580
the adversary

485
00:19:05,580 --> 00:19:08,039
now based on various parameters such as

486
00:19:08,039 --> 00:19:09,720
the threshold of corruption the nature

487
00:19:09,720 --> 00:19:11,760
of the adversary and so on there are

488
00:19:11,760 --> 00:19:12,840
various settings which have been

489
00:19:12,840 --> 00:19:15,360
considered in the literature and in our

490
00:19:15,360 --> 00:19:17,580
work we focus on one such setting that

491
00:19:17,580 --> 00:19:19,440
is perfect security

492
00:19:19,440 --> 00:19:21,660
here a threshold of T less than n by 3

493
00:19:21,660 --> 00:19:23,460
is known to be necessary and sufficient

494
00:19:23,460 --> 00:19:26,820
the adversity is unbounded powerful and

495
00:19:26,820 --> 00:19:29,220
there is zero error probability in the

496
00:19:29,220 --> 00:19:30,660
output computed

497
00:19:30,660 --> 00:19:33,720
okay so in our work we focus on a

498
00:19:33,720 --> 00:19:35,460
perfectly secure protocols with

499
00:19:35,460 --> 00:19:38,160
malicious Corruptions and primarily we

500
00:19:38,160 --> 00:19:41,400
focus on the communication complexity

501
00:19:41,400 --> 00:19:43,620
so looking at already what exists in the

502
00:19:43,620 --> 00:19:45,179
literature first from the broadcast

503
00:19:45,179 --> 00:19:47,940
hybrid model we see that broadly there

504
00:19:47,940 --> 00:19:50,340
are two categories of protocols one

505
00:19:50,340 --> 00:19:52,380
which we refer to as efficient but slow

506
00:19:52,380 --> 00:19:55,020
and the other one which we call is fast

507
00:19:55,020 --> 00:19:57,600
but inefficient uh let me make this

508
00:19:57,600 --> 00:20:00,600
clear so the first category of protocols

509
00:20:00,600 --> 00:20:02,880
which we call as slow are the ones where

510
00:20:02,880 --> 00:20:04,919
the round complexity actually depends on

511
00:20:04,919 --> 00:20:07,679
the number of parties involved in

512
00:20:07,679 --> 00:20:10,200
and the second category which we call is

513
00:20:10,200 --> 00:20:12,299
fast is where the round complexity is

514
00:20:12,299 --> 00:20:14,160
independent of n

515
00:20:14,160 --> 00:20:16,679
now what we observe is that in the first

516
00:20:16,679 --> 00:20:19,140
class of protocols following a long line

517
00:20:19,140 --> 00:20:21,840
of work the state-of-the-art work of

518
00:20:21,840 --> 00:20:24,419
goyal Liu and song achieves a

519
00:20:24,419 --> 00:20:27,120
communication complexity that is linear

520
00:20:27,120 --> 00:20:30,360
in the number of parties per gate

521
00:20:30,360 --> 00:20:32,039
however the scenario in the second

522
00:20:32,039 --> 00:20:34,100
category of protocols is very different

523
00:20:34,100 --> 00:20:38,760
here to evaluate each gate there is a n

524
00:20:38,760 --> 00:20:41,340
Par 3 amount of communication over point

525
00:20:41,340 --> 00:20:43,400
to point as well as broadcast

526
00:20:43,400 --> 00:20:46,919
channels required just for a single gate

527
00:20:46,919 --> 00:20:50,580
so a natural question that we see is can

528
00:20:50,580 --> 00:20:52,500
we get the best of both these approaches

529
00:20:52,500 --> 00:20:54,900
that is can we get a linear

530
00:20:54,900 --> 00:20:57,240
communication complexity per gate while

531
00:20:57,240 --> 00:20:58,980
ensuring round complexity that is

532
00:20:58,980 --> 00:21:00,840
independent of n

533
00:21:00,840 --> 00:21:03,299
and in our work we answer this in the

534
00:21:03,299 --> 00:21:05,640
affirmative and give an efficient as

535
00:21:05,640 --> 00:21:08,820
well as a fast MPC as we call it

536
00:21:08,820 --> 00:21:11,520
so just to be more clear we look at this

537
00:21:11,520 --> 00:21:13,799
from the point-to-point model that is

538
00:21:13,799 --> 00:21:15,840
when the broadcast channels is

539
00:21:15,840 --> 00:21:18,480
instantiated with a broadcast protocol

540
00:21:18,480 --> 00:21:21,240
so we see that broadcast in itself can

541
00:21:21,240 --> 00:21:22,620
be instantiated with two different

542
00:21:22,620 --> 00:21:26,039
classes of protocols one is where the

543
00:21:26,039 --> 00:21:28,080
protocols are deterministic order of

544
00:21:28,080 --> 00:21:31,140
Enron protocols and the other one where

545
00:21:31,140 --> 00:21:33,780
the protocols are randomized and they

546
00:21:33,780 --> 00:21:36,780
give expected constant round complexity

547
00:21:36,780 --> 00:21:39,840
so we observe that using both the kinds

548
00:21:39,840 --> 00:21:43,020
of protocols for broadcast the work of

549
00:21:43,020 --> 00:21:45,659
goeltol has a communication complexity

550
00:21:45,659 --> 00:21:48,360
that is linear per gate

551
00:21:48,360 --> 00:21:51,140
whereas the work of

552
00:21:51,140 --> 00:21:55,760
the state of the artwork of Abraham

553
00:21:55,760 --> 00:21:59,700
ashero and eni has round complexity that

554
00:21:59,700 --> 00:22:03,360
is order of D that is independent of n

555
00:22:03,360 --> 00:22:05,520
the important point to note here is that

556
00:22:05,520 --> 00:22:07,919
none of the prior Works achieve both the

557
00:22:07,919 --> 00:22:10,020
good features as we call them together

558
00:22:10,020 --> 00:22:12,240
and our work is the first one to achieve

559
00:22:12,240 --> 00:22:14,880
this linear communication per complexity

560
00:22:14,880 --> 00:22:17,520
per gate and Order of depth around

561
00:22:17,520 --> 00:22:21,559
complexity for large enough circuits

562
00:22:21,600 --> 00:22:24,419
so coming to our main result we give an

563
00:22:24,419 --> 00:22:26,640
MPC protocol which has a communication

564
00:22:26,640 --> 00:22:29,280
complexity of order of c n plus D N

565
00:22:29,280 --> 00:22:31,380
squared plus n to the 4 over point to

566
00:22:31,380 --> 00:22:33,720
point channels for evaluating a circuit

567
00:22:33,720 --> 00:22:35,820
with C Gates and Deb d

568
00:22:35,820 --> 00:22:37,200
so looking at it from the broadcast

569
00:22:37,200 --> 00:22:40,200
hybrid model we have a point-to-point

570
00:22:40,200 --> 00:22:42,240
communication of the same order

571
00:22:42,240 --> 00:22:45,659
and broadcast communication of n Cube

572
00:22:45,659 --> 00:22:47,820
and each party design squared

573
00:22:47,820 --> 00:22:50,700
communication here and to instantiate

574
00:22:50,700 --> 00:22:53,240
this we use the broadcast protocol of

575
00:22:53,240 --> 00:22:56,700
Abraham Asher of patil and Patra

576
00:22:56,700 --> 00:22:59,460
which allows us to achieve expected

577
00:22:59,460 --> 00:23:03,559
order of depth round complexity

578
00:23:04,020 --> 00:23:08,100
coming to how we achieve our result

579
00:23:08,100 --> 00:23:11,039
so at a very high level we follow the

580
00:23:11,039 --> 00:23:13,020
Weaver circuit randomization trick to

581
00:23:13,020 --> 00:23:15,840
get our MPC but in particular we follow

582
00:23:15,840 --> 00:23:17,940
a framework which was formalized in the

583
00:23:17,940 --> 00:23:20,220
work of Chaudhary and Patra

584
00:23:20,220 --> 00:23:22,980
so here there are n parties and each

585
00:23:22,980 --> 00:23:25,679
party starts off by using a verifiable

586
00:23:25,679 --> 00:23:28,380
secret sharing VSS primitive to share

587
00:23:28,380 --> 00:23:31,260
random multiplication triplets

588
00:23:31,260 --> 00:23:34,320
so once this is done given that parties

589
00:23:34,320 --> 00:23:36,179
are malicious the multiplicative

590
00:23:36,179 --> 00:23:39,059
relation might not really hold and we

591
00:23:39,059 --> 00:23:40,679
need to verify this

592
00:23:40,679 --> 00:23:42,780
this is where the second component that

593
00:23:42,780 --> 00:23:44,460
is the verify by triple sharing comes

594
00:23:44,460 --> 00:23:45,720
into the picture

595
00:23:45,720 --> 00:23:48,059
and this does the verification of

596
00:23:48,059 --> 00:23:49,980
whether the multiplicative relation in

597
00:23:49,980 --> 00:23:52,260
the triple actually holds or not

598
00:23:52,260 --> 00:23:54,120
so the outcome of this primitive can

599
00:23:54,120 --> 00:23:55,740
either be a success that is the proof

600
00:23:55,740 --> 00:23:58,320
goes through or it fails and in case of

601
00:23:58,320 --> 00:24:00,419
failure we can simply discard the triple

602
00:24:00,419 --> 00:24:03,120
shared by that party

603
00:24:03,120 --> 00:24:05,220
following this a triple extraction

604
00:24:05,220 --> 00:24:07,679
primitive takes in the triple shared by

605
00:24:07,679 --> 00:24:10,020
all the parties and gives out random

606
00:24:10,020 --> 00:24:11,700
multiplication triples which are unknown

607
00:24:11,700 --> 00:24:13,320
to any party

608
00:24:13,320 --> 00:24:16,080
So This Together forms the beaver triple

609
00:24:16,080 --> 00:24:18,000
generation phase as we know it

610
00:24:18,000 --> 00:24:21,179
and following this we can have a beaver

611
00:24:21,179 --> 00:24:23,280
multiplication going on which will just

612
00:24:23,280 --> 00:24:24,600
consume this triples to actually

613
00:24:24,600 --> 00:24:27,059
evaluate the circuit

614
00:24:27,059 --> 00:24:29,820
so what we observe is that if we have an

615
00:24:29,820 --> 00:24:31,559
order of in communication complexity

616
00:24:31,559 --> 00:24:33,600
protocol for each of these Primitives

617
00:24:33,600 --> 00:24:36,120
then we can get an order of n complexity

618
00:24:36,120 --> 00:24:38,280
MPC protocol

619
00:24:38,280 --> 00:24:41,400
and from the literature we have that the

620
00:24:41,400 --> 00:24:43,260
triple extraction and the Beaver

621
00:24:43,260 --> 00:24:45,780
multiplication Protocols are viewer

622
00:24:45,780 --> 00:24:47,940
multiplication Primitives already have

623
00:24:47,940 --> 00:24:49,740
such protocols from the work of

624
00:24:49,740 --> 00:24:52,679
Chaudhary at all and time guard Nielsen

625
00:24:52,679 --> 00:24:55,380
so what remains is the VSS and the

626
00:24:55,380 --> 00:24:58,140
verifiable triple sharing primitive and

627
00:24:58,140 --> 00:25:00,120
this is exactly what the contribution of

628
00:25:00,120 --> 00:25:02,460
our work is

629
00:25:02,460 --> 00:25:04,860
so before moving on to the exact

630
00:25:04,860 --> 00:25:07,140
contributions I'll go over the key

631
00:25:07,140 --> 00:25:08,880
design principles that we follow in this

632
00:25:08,880 --> 00:25:09,840
work

633
00:25:09,840 --> 00:25:12,000
and they are as follows the first is

634
00:25:12,000 --> 00:25:15,000
packing so since we primarily deal with

635
00:25:15,000 --> 00:25:16,740
sharing of secrets in the form of

636
00:25:16,740 --> 00:25:17,940
triples

637
00:25:17,940 --> 00:25:21,059
in order to ensure a low cost we first

638
00:25:21,059 --> 00:25:23,340
pack secrets in a single instance of

639
00:25:23,340 --> 00:25:26,100
sharing so as to amortize the cost

640
00:25:26,100 --> 00:25:28,559
secondly we observed that broadcast

641
00:25:28,559 --> 00:25:31,440
communication is what causes the primary

642
00:25:31,440 --> 00:25:33,360
bottleneck in terms of the communication

643
00:25:33,360 --> 00:25:34,620
complexity

644
00:25:34,620 --> 00:25:36,720
and hence we use our second principle

645
00:25:36,720 --> 00:25:39,179
that is batching of the broadcast cost

646
00:25:39,179 --> 00:25:42,539
across multiple instances of the sharing

647
00:25:42,539 --> 00:25:44,760
and finally while designing these

648
00:25:44,760 --> 00:25:48,179
protocols it so happens that the corrupt

649
00:25:48,179 --> 00:25:51,539
parties can in some sense create failure

650
00:25:51,539 --> 00:25:53,760
I mean they cannot they let at some

651
00:25:53,760 --> 00:25:56,279
times do not allow the protocol to

652
00:25:56,279 --> 00:25:57,840
terminate successfully

653
00:25:57,840 --> 00:26:01,200
and in this case we use our third design

654
00:26:01,200 --> 00:26:03,779
principle that is detection wherein we

655
00:26:03,779 --> 00:26:06,240
identify corrupt parties and neutralize

656
00:26:06,240 --> 00:26:08,159
their power to further obstruct the

657
00:26:08,159 --> 00:26:11,539
successful completion of protocol

658
00:26:12,059 --> 00:26:14,340
so coming to the first primitive where

659
00:26:14,340 --> 00:26:16,380
we have a contribution that is

660
00:26:16,380 --> 00:26:19,980
verifiable secret sharing so VSS is a

661
00:26:19,980 --> 00:26:21,900
primitive which is a two-phase primitive

662
00:26:21,900 --> 00:26:24,240
consisting of a share and a reconstruct

663
00:26:24,240 --> 00:26:27,000
protocol that allows a dealer to share

664
00:26:27,000 --> 00:26:29,100
secrets amongst the parties with the

665
00:26:29,100 --> 00:26:30,840
following properties

666
00:26:30,840 --> 00:26:33,360
the first one is hiding that is at the

667
00:26:33,360 --> 00:26:35,640
end of the sharing phase the adversary

668
00:26:35,640 --> 00:26:37,860
will not gain any information regarding

669
00:26:37,860 --> 00:26:40,500
the secret of an honest dealer

670
00:26:40,500 --> 00:26:43,140
then we have binding that is at the end

671
00:26:43,140 --> 00:26:44,880
of the sharing phase there is some

672
00:26:44,880 --> 00:26:46,860
secret that is committed to

673
00:26:46,860 --> 00:26:48,720
and this is defined by the view of the

674
00:26:48,720 --> 00:26:50,220
honest parties

675
00:26:50,220 --> 00:26:52,140
and finally we have validity or

676
00:26:52,140 --> 00:26:54,240
correctness that means that at the end

677
00:26:54,240 --> 00:26:56,460
of the Reconstruction phase the secret

678
00:26:56,460 --> 00:26:58,500
that has been committed to will be the

679
00:26:58,500 --> 00:27:00,240
one which will be opened and when the

680
00:27:00,240 --> 00:27:02,520
dealer is honest we have that the secret

681
00:27:02,520 --> 00:27:04,140
is actually the one that the dealer

682
00:27:04,140 --> 00:27:06,419
shared

683
00:27:06,419 --> 00:27:09,539
so coming to our main result for the VSS

684
00:27:09,539 --> 00:27:11,700
we give a vs scheme with perfect

685
00:27:11,700 --> 00:27:14,340
security and optimal resilience which

686
00:27:14,340 --> 00:27:16,919
has a complexity of order of p n plus n

687
00:27:16,919 --> 00:27:19,440
power 4 over point to point channels for

688
00:27:19,440 --> 00:27:22,020
sharing P secrets in expected constant

689
00:27:22,020 --> 00:27:23,400
rounds

690
00:27:23,400 --> 00:27:25,559
so what this essentially means is that

691
00:27:25,559 --> 00:27:27,179
when we have large enough number of

692
00:27:27,179 --> 00:27:29,820
Secrets then we get a linear overhead

693
00:27:29,820 --> 00:27:32,760
per sharing of a secret and this exactly

694
00:27:32,760 --> 00:27:34,559
matches the semi honest secret sharing

695
00:27:34,559 --> 00:27:36,120
where a dealer would simply hand out

696
00:27:36,120 --> 00:27:39,139
shares to each party

697
00:27:39,179 --> 00:27:42,179
comparing with the existing prior best

698
00:27:42,179 --> 00:27:45,240
known VSS of Abraham at all

699
00:27:45,240 --> 00:27:48,299
what we see is both rvss as well as

700
00:27:48,299 --> 00:27:51,120
their BSS in a single instance shares

701
00:27:51,120 --> 00:27:53,460
order of n secrets and in fact at the

702
00:27:53,460 --> 00:27:56,640
same cost however we defer in the design

703
00:27:56,640 --> 00:27:59,100
principles that we use

704
00:27:59,100 --> 00:28:02,279
so the work of Abraham at all primarily

705
00:28:02,279 --> 00:28:04,860
uses the packing design principle so you

706
00:28:04,860 --> 00:28:07,500
can think of this as an array of order

707
00:28:07,500 --> 00:28:09,720
of n Secrets packed along the X

708
00:28:09,720 --> 00:28:11,400
dimension of a bivariate used for

709
00:28:11,400 --> 00:28:12,480
sharing

710
00:28:12,480 --> 00:28:15,539
whereas in artwork we use packing as

711
00:28:15,539 --> 00:28:18,120
well as detection of corrupt parties

712
00:28:18,120 --> 00:28:21,240
and this helps us in getting a better

713
00:28:21,240 --> 00:28:22,980
cost when we run multiple instances

714
00:28:22,980 --> 00:28:24,179
together

715
00:28:24,179 --> 00:28:26,760
so the key difference here lies in how

716
00:28:26,760 --> 00:28:29,039
we choose our bivariate polynomial

717
00:28:29,039 --> 00:28:32,400
we choose the degree in such a way that

718
00:28:32,400 --> 00:28:34,260
it allows us to balance the broadcast

719
00:28:34,260 --> 00:28:37,860
communication done by each party in

720
00:28:37,860 --> 00:28:39,900
contrast to the work of Abraham at all

721
00:28:39,900 --> 00:28:42,179
where the dealer used to communicate

722
00:28:42,179 --> 00:28:44,400
order of n Factor more than each other

723
00:28:44,400 --> 00:28:46,700
party

724
00:28:47,220 --> 00:28:49,799
so the way this helps us is when we run

725
00:28:49,799 --> 00:28:52,919
multiple instances of our VSS together

726
00:28:52,919 --> 00:28:55,200
so while the work of Abraham at all

727
00:28:55,200 --> 00:28:57,720
continues to use the principle of

728
00:28:57,720 --> 00:29:00,960
packing in our work we can use packing

729
00:29:00,960 --> 00:29:03,779
batching and detection

730
00:29:03,779 --> 00:29:07,740
so note that here we managed to get the

731
00:29:07,740 --> 00:29:09,960
same broadcast cost that is order of N

732
00:29:09,960 --> 00:29:12,360
squared as we required for one instance

733
00:29:12,360 --> 00:29:15,299
of our VSS whereas in the case of the

734
00:29:15,299 --> 00:29:18,120
prior VSS the broadcast cost depends on

735
00:29:18,120 --> 00:29:20,039
the number of instances that you are

736
00:29:20,039 --> 00:29:21,240
executing

737
00:29:21,240 --> 00:29:24,720
this shows up in the final complexity of

738
00:29:24,720 --> 00:29:26,880
the protocol wherein we get a linear

739
00:29:26,880 --> 00:29:28,919
communication complexity per secret

740
00:29:28,919 --> 00:29:31,140
whereas the prior work achieved a

741
00:29:31,140 --> 00:29:33,659
quadratic communication complexity

742
00:29:33,659 --> 00:29:35,880
so this summarizes our contribution in

743
00:29:35,880 --> 00:29:38,520
terms of the VSS

744
00:29:38,520 --> 00:29:41,039
so looking at the big picture again what

745
00:29:41,039 --> 00:29:43,740
now parties can do is share each secret

746
00:29:43,740 --> 00:29:46,140
using our secret sharing and this will

747
00:29:46,140 --> 00:29:48,240
be shared with a degree t as we require

748
00:29:48,240 --> 00:29:49,559
eventually

749
00:29:49,559 --> 00:29:52,559
and now the goal is to verify that the

750
00:29:52,559 --> 00:29:54,720
product relation of the triples that

751
00:29:54,720 --> 00:29:56,880
they've shared indeed holds

752
00:29:56,880 --> 00:29:59,820
and one way to view this requirement of

753
00:29:59,820 --> 00:30:01,200
the triple sharing

754
00:30:01,200 --> 00:30:04,200
is in the following way so a party

755
00:30:04,200 --> 00:30:06,480
trying to prove that its multiplication

756
00:30:06,480 --> 00:30:09,899
relation holds requires to share in some

757
00:30:09,899 --> 00:30:12,600
sense order of n secrets

758
00:30:12,600 --> 00:30:15,360
now even if we use the VSS that I just

759
00:30:15,360 --> 00:30:18,120
defined which has a linear cost this

760
00:30:18,120 --> 00:30:20,460
would amount to a quadratic cost just to

761
00:30:20,460 --> 00:30:23,100
verify a single secret and this is

762
00:30:23,100 --> 00:30:25,140
beyond what we can afford to get linear

763
00:30:25,140 --> 00:30:27,899
complexity uh MPC protocol

764
00:30:27,899 --> 00:30:29,460
and here is where our second

765
00:30:29,460 --> 00:30:31,620
contribution comes into the picture

766
00:30:31,620 --> 00:30:34,140
so we identify that we don't need a

767
00:30:34,140 --> 00:30:36,299
full-fledged VSS to prove the relation

768
00:30:36,299 --> 00:30:39,659
rather a weaker notion suffices and in

769
00:30:39,659 --> 00:30:41,640
our work we formalize this weak notion

770
00:30:41,640 --> 00:30:43,140
which we call as detectable secret

771
00:30:43,140 --> 00:30:44,640
sharing

772
00:30:44,640 --> 00:30:47,520
so detectable secret sharing similar to

773
00:30:47,520 --> 00:30:50,640
ESS is a two-phase protocol which has a

774
00:30:50,640 --> 00:30:52,919
sharing and a reconstruction phase and

775
00:30:52,919 --> 00:30:55,559
it allows a dealer to share secret with

776
00:30:55,559 --> 00:30:57,059
all the parties and with the following

777
00:30:57,059 --> 00:30:58,740
properties

778
00:30:58,740 --> 00:31:01,440
the hiding and binding are exactly the

779
00:31:01,440 --> 00:31:04,440
same as that what you get in VSS however

780
00:31:04,440 --> 00:31:05,880
there is a difference in the validity

781
00:31:05,880 --> 00:31:08,940
property while VSS allowed the

782
00:31:08,940 --> 00:31:11,580
Reconstruction to always succeed in our

783
00:31:11,580 --> 00:31:14,100
case it might not so be the case

784
00:31:14,100 --> 00:31:16,860
in fact for us one of the following two

785
00:31:16,860 --> 00:31:18,840
conditions holds for our validity

786
00:31:18,840 --> 00:31:20,399
property

787
00:31:20,399 --> 00:31:21,840
so the first one is that the

788
00:31:21,840 --> 00:31:24,299
Reconstruction indeed succeeds and in

789
00:31:24,299 --> 00:31:27,659
this case what we actually have is the

790
00:31:27,659 --> 00:31:30,720
properties of a VSS protocol if this

791
00:31:30,720 --> 00:31:32,340
case happens

792
00:31:32,340 --> 00:31:34,620
on the other hand it is possible that

793
00:31:34,620 --> 00:31:38,039
our reconstruction also fails

794
00:31:38,039 --> 00:31:40,740
and if it does so we make sure that our

795
00:31:40,740 --> 00:31:42,720
third design principle that is detection

796
00:31:42,720 --> 00:31:45,600
comes into the picture and we an honest

797
00:31:45,600 --> 00:31:47,039
dealer who is trying to share the

798
00:31:47,039 --> 00:31:49,860
secrets will identify at least order of

799
00:31:49,860 --> 00:31:52,559
n corrupt parties and make sure that

800
00:31:52,559 --> 00:31:55,020
they can cannot further obstruct the

801
00:31:55,020 --> 00:31:57,980
successful completion

802
00:31:58,380 --> 00:32:00,600
so coming to the result in detectable

803
00:32:00,600 --> 00:32:03,299
secret sharing we give a protocol with

804
00:32:03,299 --> 00:32:05,220
perfect security and optimal resilience

805
00:32:05,220 --> 00:32:08,100
which has order of p plus n to the four

806
00:32:08,100 --> 00:32:11,460
communication for sharing P secrets in

807
00:32:11,460 --> 00:32:13,559
expected constant number of rounds

808
00:32:13,559 --> 00:32:16,799
so note that this amounts to an a

809
00:32:16,799 --> 00:32:20,039
constant overhead per secret when p is

810
00:32:20,039 --> 00:32:22,679
large enough and this matches packed

811
00:32:22,679 --> 00:32:25,380
semi on a secret sharing in contrast to

812
00:32:25,380 --> 00:32:28,020
the standard semi honest secret sharing

813
00:32:28,020 --> 00:32:30,240
which are VSS watch matching

814
00:32:30,240 --> 00:32:32,220
so now if you think about the triple

815
00:32:32,220 --> 00:32:34,559
sharing which essentially required in

816
00:32:34,559 --> 00:32:37,080
secrets to be shared for the proof

817
00:32:37,080 --> 00:32:39,299
if we use our detectable secret sharing

818
00:32:39,299 --> 00:32:41,159
we are still within the bound of linear

819
00:32:41,159 --> 00:32:44,539
complexity which we aim for

820
00:32:45,059 --> 00:32:48,360
so contrasting our VSS with the

821
00:32:48,360 --> 00:32:51,360
detectable secret sharing we see that a

822
00:32:51,360 --> 00:32:53,760
single instance of our VSS as well as

823
00:32:53,760 --> 00:32:56,100
detectable secret sharing has the same

824
00:32:56,100 --> 00:32:59,539
complexity and in fact both use the

825
00:32:59,539 --> 00:33:02,520
principles of packing and detection

826
00:33:02,520 --> 00:33:04,440
but the difference is in the way the

827
00:33:04,440 --> 00:33:06,299
packing is done

828
00:33:06,299 --> 00:33:08,940
so while for VSS we were packing along

829
00:33:08,940 --> 00:33:10,919
just one dimension of the bivariate used

830
00:33:10,919 --> 00:33:13,500
for sharing in case of detectable secret

831
00:33:13,500 --> 00:33:16,500
sharing we pack order of n Secrets along

832
00:33:16,500 --> 00:33:18,539
both the dimensions so you can think of

833
00:33:18,539 --> 00:33:20,220
this as a matrix of values which is

834
00:33:20,220 --> 00:33:22,559
getting packed and this is what allows

835
00:33:22,559 --> 00:33:25,080
the detectable secret sharing to

836
00:33:25,080 --> 00:33:27,480
simultaneously share and squared values

837
00:33:27,480 --> 00:33:29,399
in contrast to order of n which was

838
00:33:29,399 --> 00:33:31,940
getting shared in the VSS

839
00:33:31,940 --> 00:33:34,980
analogously in the case of running M

840
00:33:34,980 --> 00:33:36,360
instances together

841
00:33:36,360 --> 00:33:38,519
we see that uh

842
00:33:38,519 --> 00:33:41,760
our VSS uses packing batching and

843
00:33:41,760 --> 00:33:44,340
detection and similarly the same

844
00:33:44,340 --> 00:33:46,200
principles are used by the detectable

845
00:33:46,200 --> 00:33:47,880
secret sharing as well

846
00:33:47,880 --> 00:33:50,460
and the important part to note here is

847
00:33:50,460 --> 00:33:54,000
that just like VSS our detectable secret

848
00:33:54,000 --> 00:33:57,720
sharing also has a broadcast cost that

849
00:33:57,720 --> 00:33:59,039
is independent of the number of

850
00:33:59,039 --> 00:34:02,240
instances that we are running

851
00:34:02,760 --> 00:34:04,200
so just to summarize the design

852
00:34:04,200 --> 00:34:07,019
principles in our work we have used

853
00:34:07,019 --> 00:34:09,300
packing batching and detection

854
00:34:09,300 --> 00:34:12,659
to get Primitives such as VSS and a new

855
00:34:12,659 --> 00:34:13,980
primitive called detectable secret

856
00:34:13,980 --> 00:34:15,119
sharing

857
00:34:15,119 --> 00:34:17,460
which finally allows us to get a linear

858
00:34:17,460 --> 00:34:19,739
complexity MPC protocol

859
00:34:19,739 --> 00:34:22,139
compared to the with respect to

860
00:34:22,139 --> 00:34:23,580
improvements compared to the state of

861
00:34:23,580 --> 00:34:26,820
the artworks for VSS we have an order of

862
00:34:26,820 --> 00:34:28,859
n Factor Improvement compared to the

863
00:34:28,859 --> 00:34:31,320
work of Abraham at all and for the

864
00:34:31,320 --> 00:34:33,119
Triple sharing primitive our work

865
00:34:33,119 --> 00:34:34,679
improves the state of the art by order

866
00:34:34,679 --> 00:34:37,139
of n Cube and this finally allows us to

867
00:34:37,139 --> 00:34:38,280
achieve the linear communication

868
00:34:38,280 --> 00:34:41,040
complexity that we aimed for

869
00:34:41,040 --> 00:34:43,330
thank you

870
00:34:43,330 --> 00:34:46,918
[Applause]

871
00:34:46,918 --> 00:34:49,940
are there any questions

872
00:34:52,379 --> 00:34:56,339
I was wondering where does this expected

873
00:34:56,339 --> 00:34:58,800
number of rounds come from and if there

874
00:34:58,800 --> 00:35:01,619
is any chance of like improving that or

875
00:35:01,619 --> 00:35:04,500
oh so uh the expected uh is coming out

876
00:35:04,500 --> 00:35:06,660
from the broadcast protocols so all the

877
00:35:06,660 --> 00:35:08,400
results I've described are mainly in the

878
00:35:08,400 --> 00:35:11,040
point-to-point model and uh getting

879
00:35:11,040 --> 00:35:12,900
broadcast with strict constant number of

880
00:35:12,900 --> 00:35:15,119
rounds is known to be impossible due to

881
00:35:15,119 --> 00:35:17,099
work so either you go for order of n

882
00:35:17,099 --> 00:35:20,220
Rams or expected constant point okay

883
00:35:20,220 --> 00:35:21,780
that's also for the detectable secret

884
00:35:21,780 --> 00:35:24,660
sharing you also need yes yes

885
00:35:24,660 --> 00:35:25,680
okay

886
00:35:25,680 --> 00:35:29,180
thank you any other questions

887
00:35:30,900 --> 00:35:33,720
okay so then let's uh thank the speaker

888
00:35:33,720 --> 00:35:35,579
and all the speakers of the session

889
00:35:35,579 --> 00:35:38,000
again

890
00:35:38,680 --> 00:35:41,879
[Applause]

