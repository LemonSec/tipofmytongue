1
00:00:01,800 --> 00:00:04,080
all right so welcome everyone to the

2
00:00:04,080 --> 00:00:05,819
pseudorandom function session so let's

3
00:00:05,819 --> 00:00:08,760
get started so we'll have two talks in

4
00:00:08,760 --> 00:00:10,440
this session and our first talk will be

5
00:00:10,440 --> 00:00:12,300
on privately puncturing prfs from

6
00:00:12,300 --> 00:00:14,519
lattices adaptive security and collusion

7
00:00:14,519 --> 00:00:16,800
resistance pseudor Randomness and rupon

8
00:00:16,800 --> 00:00:20,100
yang will be giving a talk yeah uh

9
00:00:20,100 --> 00:00:22,439
thanks for the introduction uh hello

10
00:00:22,439 --> 00:00:24,300
everyone I'm Ruben Young from the

11
00:00:24,300 --> 00:00:26,820
University of Oregon and today I'm glad

12
00:00:26,820 --> 00:00:28,500
to share our recent work on how to

13
00:00:28,500 --> 00:00:31,199
construct a private pancre prf with both

14
00:00:31,199 --> 00:00:33,420
adaptive security and crew resisting

15
00:00:33,420 --> 00:00:35,820
student names from standard lattice

16
00:00:35,820 --> 00:00:38,760
assumptions so apocryph is a special

17
00:00:38,760 --> 00:00:41,100
case of our constant Tif and roughly

18
00:00:41,100 --> 00:00:43,079
speaking a constant paf is a PR family

19
00:00:43,079 --> 00:00:46,020
that allows one to derive a custom key

20
00:00:46,020 --> 00:00:49,020
from a pfk the concerned key is

21
00:00:49,020 --> 00:00:52,260
associated with a construent and it can

22
00:00:52,260 --> 00:00:55,079
be used to evaluate the pif or any input

23
00:00:55,079 --> 00:00:58,440
X that satisfy this construent on the

24
00:00:58,440 --> 00:01:00,300
other hand if the input X doesn't

25
00:01:00,300 --> 00:01:02,640
specify the constraint then the pi

26
00:01:02,640 --> 00:01:04,860
evaluation or X will be heating from the

27
00:01:04,860 --> 00:01:08,479
constant key so sometimes we may need a

28
00:01:08,479 --> 00:01:11,400
personal optional or security property

29
00:01:11,400 --> 00:01:13,920
called previously that is the concerning

30
00:01:13,920 --> 00:01:19,080
K will hide the constraint and this

31
00:01:19,080 --> 00:01:22,140
control PF with this security property

32
00:01:22,140 --> 00:01:26,340
is called private constant prf

33
00:01:26,340 --> 00:01:28,439
so with the effect security our constant

34
00:01:28,439 --> 00:01:31,140
prf we already consider those three that

35
00:01:31,140 --> 00:01:34,020
can make some Oracle queries so to make

36
00:01:34,020 --> 00:01:36,000
things more concrete we will consider

37
00:01:36,000 --> 00:01:38,640
this very basic circuit definition for

38
00:01:38,640 --> 00:01:41,700
the student needs in this definition the

39
00:01:41,700 --> 00:01:44,640
Challenger will first sample a pfk and

40
00:01:44,640 --> 00:01:47,540
Sample a bit B and then the rosary

41
00:01:47,540 --> 00:01:51,420
should submit a challenge query X star

42
00:01:51,420 --> 00:01:55,799
which is an input and a key query C

43
00:01:55,799 --> 00:01:57,899
which is a constraint since the

44
00:01:57,899 --> 00:02:00,299
Challenger will generate a constraint

45
00:02:00,299 --> 00:02:04,500
key for the constraint C and it will set

46
00:02:04,500 --> 00:02:07,439
a string one star as either a random

47
00:02:07,439 --> 00:02:10,619
string or compute it as the prf

48
00:02:10,619 --> 00:02:12,840
evaluation on the change input X star

49
00:02:12,840 --> 00:02:15,480
and then it Returns the constraint key

50
00:02:15,480 --> 00:02:18,840
and the string was star 2.3 and then the

51
00:02:18,840 --> 00:02:21,180
auto three will make some erosion or

52
00:02:21,180 --> 00:02:24,060
queries that is those three Summit input

53
00:02:24,060 --> 00:02:26,640
X and gets the pr valuation on the input

54
00:02:26,640 --> 00:02:27,780
X

55
00:02:27,780 --> 00:02:30,540
and the other three is a family should

56
00:02:30,540 --> 00:02:33,239
submit a bit B Prime and it wins FB

57
00:02:33,239 --> 00:02:36,360
Prime is equal to B and it B count B

58
00:02:36,360 --> 00:02:39,780
truly learned from the Oracle queries so

59
00:02:39,780 --> 00:02:42,420
that is the trending input X star should

60
00:02:42,420 --> 00:02:45,300
not satisfy the constraint C and it

61
00:02:45,300 --> 00:02:48,120
should not be submitted as an evolution

62
00:02:48,120 --> 00:02:49,680
query

63
00:02:49,680 --> 00:02:52,340
so in this definition the rosary must

64
00:02:52,340 --> 00:02:55,860
make a key carry and a Chinese query

65
00:02:55,860 --> 00:02:59,580
before making any Evolution query so

66
00:02:59,580 --> 00:03:01,379
that is the

67
00:03:01,379 --> 00:03:04,379
order of the auto queries should be

68
00:03:04,379 --> 00:03:07,200
predefined and this is usually denoted

69
00:03:07,200 --> 00:03:09,000
as selective security

70
00:03:09,000 --> 00:03:11,400
also in this definition the dollar three

71
00:03:11,400 --> 00:03:14,640
can only get one constant key so this is

72
00:03:14,640 --> 00:03:17,040
already noted as one key security

73
00:03:17,040 --> 00:03:19,440
so this is the basic definition of

74
00:03:19,440 --> 00:03:22,319
selective one key student eliminates and

75
00:03:22,319 --> 00:03:24,480
in a similar way we can Define The

76
00:03:24,480 --> 00:03:26,640
Selective 1K privacy

77
00:03:26,640 --> 00:03:29,099
the two secret definitions are satisfied

78
00:03:29,099 --> 00:03:31,680
by all the circle constructions or

79
00:03:31,680 --> 00:03:35,040
control PFS or private content pafs

80
00:03:35,040 --> 00:03:38,099
however they may not be you will not be

81
00:03:38,099 --> 00:03:41,099
sufficient in many applications and we

82
00:03:41,099 --> 00:03:43,019
may need some stronger security

83
00:03:43,019 --> 00:03:44,159
properties

84
00:03:44,159 --> 00:03:47,280
one such strong security property is

85
00:03:47,280 --> 00:03:50,159
called a demonstrated that is it allows

86
00:03:50,159 --> 00:03:52,500
the Dollar Tree to make the Oracle

87
00:03:52,500 --> 00:03:55,140
queries in an aperture order rather than

88
00:03:55,140 --> 00:03:56,760
the predefined order

89
00:03:56,760 --> 00:03:59,099
so we have constructions our Deputy

90
00:03:59,099 --> 00:04:02,700
circuit constant prf for wireless

91
00:04:02,700 --> 00:04:05,159
constraints from indistinctive of

92
00:04:05,159 --> 00:04:08,519
execution but if you somehow don't want

93
00:04:08,519 --> 00:04:10,439
to use of a sketching for example if you

94
00:04:10,439 --> 00:04:12,659
hope to have post conduct security from

95
00:04:12,659 --> 00:04:15,500
standard late assumptions then the only

96
00:04:15,500 --> 00:04:18,660
constraints that you can support is the

97
00:04:18,660 --> 00:04:21,238
constraints that can be implemented by

98
00:04:21,238 --> 00:04:23,880
the end product predict

99
00:04:23,880 --> 00:04:25,560
also we can consider the Clone

100
00:04:25,560 --> 00:04:29,520
resistance for custom prf that is the

101
00:04:29,520 --> 00:04:31,380
user can get more than one constraint

102
00:04:31,380 --> 00:04:32,340
case

103
00:04:32,340 --> 00:04:34,380
so again you can have many many

104
00:04:34,380 --> 00:04:36,360
constructions or clone resistant control

105
00:04:36,360 --> 00:04:38,699
prfs operate constraint PRS from

106
00:04:38,699 --> 00:04:41,759
obfuscation or modeling Maps but if you

107
00:04:41,759 --> 00:04:43,440
restrict the Assumption to be

108
00:04:43,440 --> 00:04:46,139
standardized assumptions since only

109
00:04:46,139 --> 00:04:48,360
constraints that can be supported are

110
00:04:48,360 --> 00:04:50,699
those can be implemented by the inner

111
00:04:50,699 --> 00:04:52,080
product predict

112
00:04:52,080 --> 00:04:54,240
so the situation releases the question

113
00:04:54,240 --> 00:04:58,259
that can we can we achieve either

114
00:04:58,259 --> 00:05:01,220
adaptive security or clean resistance

115
00:05:01,220 --> 00:05:04,620
from standard lighting assumptions for

116
00:05:04,620 --> 00:05:07,800
beyond the inner product predicts

117
00:05:07,800 --> 00:05:11,280
so in this work we solve this problem or

118
00:05:11,280 --> 00:05:13,440
we narrow the Gap but provides the first

119
00:05:13,440 --> 00:05:16,560
construction operate function prf with

120
00:05:16,560 --> 00:05:18,360
Boost adaptive security and close

121
00:05:18,360 --> 00:05:21,000
listening instruments from the analytics

122
00:05:21,000 --> 00:05:23,520
assumptions so we don't shave a clue

123
00:05:23,520 --> 00:05:26,940
resistance privacy but we have map give

124
00:05:26,940 --> 00:05:28,680
the first step to achieve clue

125
00:05:28,680 --> 00:05:30,539
resistance insurance

126
00:05:30,539 --> 00:05:33,240
so apocryph is a special case of

127
00:05:33,240 --> 00:05:36,419
constraint pif that the constraint is

128
00:05:36,419 --> 00:05:40,199
associated with a control set p and an

129
00:05:40,199 --> 00:05:42,780
input X certifies this constraint if and

130
00:05:42,780 --> 00:05:45,060
only if X is not belong to this

131
00:05:45,060 --> 00:05:48,360
Progressive PE so if the function set p

132
00:05:48,360 --> 00:05:51,180
is our fixed size for example if it can

133
00:05:51,180 --> 00:05:53,940
only contain one input we will call it

134
00:05:53,940 --> 00:05:56,160
one pound prf

135
00:05:56,160 --> 00:05:58,740
so the next question is why we need to

136
00:05:58,740 --> 00:06:01,199
consider bunker prf because it seems

137
00:06:01,199 --> 00:06:02,580
very limited

138
00:06:02,580 --> 00:06:05,160
there are two two reasons for the first

139
00:06:05,160 --> 00:06:08,940
reason as shown by PT w20 is some

140
00:06:08,940 --> 00:06:11,940
scenarios it is possible to construct a

141
00:06:11,940 --> 00:06:14,100
customer PF for the inner product

142
00:06:14,100 --> 00:06:16,800
predict but it is not possible to

143
00:06:16,800 --> 00:06:19,380
construct a puncture pif that is the

144
00:06:19,380 --> 00:06:22,500
parking constraint can't be implemented

145
00:06:22,500 --> 00:06:25,020
by the end in a product predict

146
00:06:25,020 --> 00:06:28,380
so we need some new ideas to construct a

147
00:06:28,380 --> 00:06:30,860
puncture prf with

148
00:06:30,860 --> 00:06:34,740
the strongest group test and these new

149
00:06:34,740 --> 00:06:37,560
ideas may be useful to help us to

150
00:06:37,560 --> 00:06:40,819
construct construct PF for General

151
00:06:40,819 --> 00:06:42,840
predicts with stronger security

152
00:06:42,840 --> 00:06:45,539
properties the second reason is that

153
00:06:45,539 --> 00:06:48,479
pumped prf itself is already useful in

154
00:06:48,479 --> 00:06:51,060
some applications such as automarking

155
00:06:51,060 --> 00:06:54,360
okay so that is our main result and next

156
00:06:54,360 --> 00:06:56,639
we will talk about how to achieve the

157
00:06:56,639 --> 00:06:59,759
result so we proceed in two steps in the

158
00:06:59,759 --> 00:07:01,199
first step we give a generic

159
00:07:01,199 --> 00:07:03,780
construction that upgrade any one

160
00:07:03,780 --> 00:07:06,840
puncture prf to have adaptive security

161
00:07:06,840 --> 00:07:08,940
and in the second step we give a

162
00:07:08,940 --> 00:07:11,580
semi-generical construction that upgrade

163
00:07:11,580 --> 00:07:14,880
some uh one key one program pif to have

164
00:07:14,880 --> 00:07:17,759
clue resins students the construction

165
00:07:17,759 --> 00:07:20,880
kind preserves adaptive security of the

166
00:07:20,880 --> 00:07:22,560
underlying Construction

167
00:07:22,560 --> 00:07:25,139
so next we will see how the output step

168
00:07:25,139 --> 00:07:28,800
proceeds so the first step needs a new

169
00:07:28,800 --> 00:07:32,340
primitive called expandable hash in a

170
00:07:32,340 --> 00:07:34,919
nutshell an expandable hash is an

171
00:07:34,919 --> 00:07:37,259
interactive heart function that allows

172
00:07:37,259 --> 00:07:41,220
that allows one to reprogram the harsh

173
00:07:41,220 --> 00:07:43,880
evaluation on some Channel input X star

174
00:07:43,880 --> 00:07:45,979
after the

175
00:07:45,979 --> 00:07:49,199
after the tender has used the heart

176
00:07:49,199 --> 00:07:53,039
function to answer some erosion queries

177
00:07:53,039 --> 00:07:55,199
so this is a bit like the

178
00:07:55,199 --> 00:07:58,440
reprogrammability of the Run Oracle but

179
00:07:58,440 --> 00:08:01,979
here we will review the description of

180
00:08:01,979 --> 00:08:05,160
the heart function after seeing the

181
00:08:05,160 --> 00:08:08,639
tender input X star also will allow the

182
00:08:08,639 --> 00:08:10,560
Challenger to fill with some

183
00:08:10,560 --> 00:08:13,520
non-negligible probability so this

184
00:08:13,520 --> 00:08:16,259
restrictions makes the new primitive not

185
00:08:16,259 --> 00:08:18,840
as strong as a landmark code but it

186
00:08:18,840 --> 00:08:21,060
allowed us to construct it from the

187
00:08:21,060 --> 00:08:23,599
standard lattice assumptions from

188
00:08:23,599 --> 00:08:26,340
from cellulitis assumptions in the

189
00:08:26,340 --> 00:08:28,020
standard model

190
00:08:28,020 --> 00:08:30,979
so for some reason we are not able to

191
00:08:30,979 --> 00:08:34,440
cover the constructions of the example

192
00:08:34,440 --> 00:08:36,899
hash if you are interested please refer

193
00:08:36,899 --> 00:08:39,479
to our full paper for more details okay

194
00:08:39,479 --> 00:08:42,240
so now with our exponential harsh we are

195
00:08:42,240 --> 00:08:44,880
ready to upgrade any one punch pif to

196
00:08:44,880 --> 00:08:47,040
have a dental security for my

197
00:08:47,040 --> 00:08:49,500
photography if as the function set only

198
00:08:49,500 --> 00:08:52,500
contains one input and it must be the

199
00:08:52,500 --> 00:08:54,600
channel input due to the restriction for

200
00:08:54,600 --> 00:08:57,720
the definition of studentness

201
00:08:57,720 --> 00:09:00,360
so we can simplify the definitions like

202
00:09:00,360 --> 00:09:03,899
this okay so now to construct the

203
00:09:03,899 --> 00:09:07,140
Adaptive skill program pif we simply

204
00:09:07,140 --> 00:09:10,019
modifying the evolution algorithm of the

205
00:09:10,019 --> 00:09:13,700
underlying selective Circle function prf

206
00:09:13,700 --> 00:09:17,580
by evaluating the function of the prf on

207
00:09:17,580 --> 00:09:19,740
the hash of the input rather than the

208
00:09:19,740 --> 00:09:21,660
input itself

209
00:09:21,660 --> 00:09:25,459
so this multiple vacation allows us to

210
00:09:25,459 --> 00:09:29,160
sample the hash of the channel input by

211
00:09:29,160 --> 00:09:32,040
forcing the real tenant input

212
00:09:32,040 --> 00:09:34,500
and then after receiving the 10 input we

213
00:09:34,500 --> 00:09:37,140
can reprogram the hash evaluation to map

214
00:09:37,140 --> 00:09:40,019
the 10 input to the string we have

215
00:09:40,019 --> 00:09:42,660
selected in the beginning this allows us

216
00:09:42,660 --> 00:09:44,700
to reduce the Adaptive security to The

217
00:09:44,700 --> 00:09:46,620
Selective security

218
00:09:46,620 --> 00:09:49,940
and the security of the example hash

219
00:09:49,940 --> 00:09:52,860
guarantees that starts reprogramming

220
00:09:52,860 --> 00:09:54,360
can't be detected

221
00:09:54,360 --> 00:09:58,260
okay so in this way we can re we can

222
00:09:58,260 --> 00:10:01,019
prove the Adaptive security of the

223
00:10:01,019 --> 00:10:04,800
simple construction and you using a

224
00:10:04,800 --> 00:10:07,560
simple using a similar idea we can prove

225
00:10:07,560 --> 00:10:10,320
the Adaptive policy of the construction

226
00:10:10,320 --> 00:10:13,019
okay so that is the first step we rely

227
00:10:13,019 --> 00:10:15,300
on a new primitive called expand hash

228
00:10:15,300 --> 00:10:17,700
and with this primitive it is very easy

229
00:10:17,700 --> 00:10:19,980
to construct to achieve adaptive

230
00:10:19,980 --> 00:10:20,820
security

231
00:10:20,820 --> 00:10:23,339
so next we will talk about how to

232
00:10:23,339 --> 00:10:26,399
achieve clue resistance to run this so

233
00:10:26,399 --> 00:10:28,620
for glue resistance student is the

234
00:10:28,620 --> 00:10:31,080
toaster can get some constraint case and

235
00:10:31,080 --> 00:10:33,000
all of them will be functioned on the

236
00:10:33,000 --> 00:10:34,440
change input

237
00:10:34,440 --> 00:10:37,560
so our main idea is to split the pfk

238
00:10:37,560 --> 00:10:40,380
into sterile parts and punctures each

239
00:10:40,380 --> 00:10:42,480
part on one input

240
00:10:42,480 --> 00:10:46,860
and this if we can somehow function the

241
00:10:46,860 --> 00:10:50,040
same part of the channel input then it

242
00:10:50,040 --> 00:10:51,540
seems that we can reduce the clear

243
00:10:51,540 --> 00:10:53,339
resistance to strongness to the 1K

244
00:10:53,339 --> 00:10:56,779
student needs so that is how we

245
00:10:56,779 --> 00:11:00,899
construct how we make it in more detail

246
00:11:00,899 --> 00:11:04,980
so now giving any inputs X1 to x a so

247
00:11:04,980 --> 00:11:07,860
actually we can support any unbounded

248
00:11:07,860 --> 00:11:11,220
set as long as the set contains only

249
00:11:11,220 --> 00:11:15,779
polynomial uh input but here we make it

250
00:11:15,779 --> 00:11:19,079
an input to make things easier okay so

251
00:11:19,079 --> 00:11:21,240
now given any input we will first

252
00:11:21,240 --> 00:11:25,760
generate a PF case k x y to k x a

253
00:11:25,760 --> 00:11:30,000
and and each of them is derived from kxr

254
00:11:30,000 --> 00:11:32,640
from x i by using another pseudonym

255
00:11:32,640 --> 00:11:34,260
function G

256
00:11:34,260 --> 00:11:35,579
so

257
00:11:35,579 --> 00:11:39,480
really oh sorry we will also connect the

258
00:11:39,480 --> 00:11:44,600
key X1 to akx and with the original pfk

259
00:11:44,600 --> 00:11:50,480
by using a another pfk zero that is k0

260
00:11:50,480 --> 00:11:54,300
is equal to K minus the sum of all the

261
00:11:54,300 --> 00:11:55,500
kxis

262
00:11:55,500 --> 00:11:59,459
that is if we sum k0 and all the KSI

263
00:11:59,459 --> 00:12:02,279
then we get to the only pfk k

264
00:12:02,279 --> 00:12:06,959
so next we will puncture each kxi on the

265
00:12:06,959 --> 00:12:11,339
input x i and the constraint K includes

266
00:12:11,339 --> 00:12:13,860
k0 and all the constraint versions of

267
00:12:13,860 --> 00:12:15,779
the kxi

268
00:12:15,779 --> 00:12:19,380
so to evaluate the prf with the

269
00:12:19,380 --> 00:12:22,260
concerning K we will first compute the

270
00:12:22,260 --> 00:12:26,279
pif on the input using k0 and then we

271
00:12:26,279 --> 00:12:30,420
will compute uh the pif on the input

272
00:12:30,420 --> 00:12:32,640
using the constraint work chains of each

273
00:12:32,640 --> 00:12:37,040
kxi and then we sum of the result up

274
00:12:37,040 --> 00:12:40,620
X that is not punctured and assumes that

275
00:12:40,620 --> 00:12:44,220
the underlying pump prf is keyhomorphic

276
00:12:44,220 --> 00:12:45,800
then

277
00:12:45,800 --> 00:12:49,139
the sum of the PF evaluation on the

278
00:12:49,139 --> 00:12:52,500
input X will equal to the sum to the

279
00:12:52,500 --> 00:12:55,200
iteration of the PF using sum out case

280
00:12:55,200 --> 00:12:59,880
which is actually the original fkk and

281
00:12:59,880 --> 00:13:02,160
the incorrect list of the construction

282
00:13:02,160 --> 00:13:03,600
follows

283
00:13:03,600 --> 00:13:05,660
okay

284
00:13:05,660 --> 00:13:08,279
next we will see why the construction is

285
00:13:08,279 --> 00:13:11,760
secure for Simplicity we will consider

286
00:13:11,760 --> 00:13:13,860
the key set there are two constraint

287
00:13:13,860 --> 00:13:15,779
case and each of them are punctured on

288
00:13:15,779 --> 00:13:17,100
three points

289
00:13:17,100 --> 00:13:21,000
so because at the tender input X star

290
00:13:21,000 --> 00:13:23,279
will be punctured in both of the

291
00:13:23,279 --> 00:13:25,880
constraint case and without loss of

292
00:13:25,880 --> 00:13:30,899
alternative assumes that uh X star is

293
00:13:30,899 --> 00:13:34,260
equal to X1 is equal to X1 Prime that is

294
00:13:34,260 --> 00:13:37,620
k x y will be equal to ks1 Prime and

295
00:13:37,620 --> 00:13:39,720
both of them will be punctured on the

296
00:13:39,720 --> 00:13:41,519
same input x y

297
00:13:41,519 --> 00:13:45,660
uh so by the Y case security of the

298
00:13:45,660 --> 00:13:49,380
underlying counter prf we have that no

299
00:13:49,380 --> 00:13:52,500
one could learn the PF evaluation on the

300
00:13:52,500 --> 00:13:57,660
input X Y using the k k x y

301
00:13:57,660 --> 00:14:00,600
but we still have the remaining sixth

302
00:14:00,600 --> 00:14:03,480
part in the constant case but all of

303
00:14:03,480 --> 00:14:06,720
them can be stimulated given the given K

304
00:14:06,720 --> 00:14:09,720
minus k x y because we can sample kx2

305
00:14:09,720 --> 00:14:13,620
kx3 kx2 prime ks3 prime uniform at

306
00:14:13,620 --> 00:14:16,680
random and we can compute P0 and k0

307
00:14:16,680 --> 00:14:19,800
prime using K minus k x y

308
00:14:19,800 --> 00:14:22,980
so now if the prf keys are uniform then

309
00:14:22,980 --> 00:14:26,519
we can use key to mass ks1 and then we

310
00:14:26,519 --> 00:14:30,300
can we can ensure that uh no one could

311
00:14:30,300 --> 00:14:34,500
learn the PF evaluation on the input X1

312
00:14:34,500 --> 00:14:36,839
using k x y

313
00:14:36,839 --> 00:14:39,839
okay

314
00:14:41,639 --> 00:14:44,459
so unfortunately we can't uh use the

315
00:14:44,459 --> 00:14:47,100
idea to prove the clue resistance

316
00:14:47,100 --> 00:14:49,980
privacy of the construction because in

317
00:14:49,980 --> 00:14:52,320
the policy in the definition of policy

318
00:14:52,320 --> 00:14:54,240
we don't request a constraint case to

319
00:14:54,240 --> 00:14:57,740
pump down the same input but fortunately

320
00:14:57,740 --> 00:15:01,079
we can still prove the Y capability if

321
00:15:01,079 --> 00:15:03,600
if the underlying one popular pif has

322
00:15:03,600 --> 00:15:05,100
anti policy

323
00:15:05,100 --> 00:15:09,300
okay so to wrap up we'll kill our result

324
00:15:09,300 --> 00:15:12,480
by two steps in the first step uh we

325
00:15:12,480 --> 00:15:14,120
give a generic construction

326
00:15:14,120 --> 00:15:17,160
to upgrade a 1. PF to have other

327
00:15:17,160 --> 00:15:20,279
security and in a second step uh we

328
00:15:20,279 --> 00:15:22,920
achieve clear resistance student is if

329
00:15:22,920 --> 00:15:27,360
the input input scheme is keyhomorphic

330
00:15:27,360 --> 00:15:30,600
and it has uniform Keys now to

331
00:15:30,600 --> 00:15:33,360
instantiate the general construction we

332
00:15:33,360 --> 00:15:38,339
start from the pancre pif from ps20 the

333
00:15:38,339 --> 00:15:40,620
construction it can be constructed from

334
00:15:40,620 --> 00:15:43,380
the late assumptions and it is almost

335
00:15:43,380 --> 00:15:47,519
ketomorphic and it it's pfk is almost

336
00:15:47,519 --> 00:15:48,839
uniform

337
00:15:48,839 --> 00:15:52,260
so by the first step we can add adaptive

338
00:15:52,260 --> 00:15:54,240
security to this construction and due to

339
00:15:54,240 --> 00:15:57,600
the Simplicity of the first step first

340
00:15:57,600 --> 00:16:00,959
contraction uh the new scheme can

341
00:16:00,959 --> 00:16:04,260
roughly preserve the keyhomorphism and

342
00:16:04,260 --> 00:16:06,480
the key distribution of the original

343
00:16:06,480 --> 00:16:09,959
construction but the but the scheme

344
00:16:09,959 --> 00:16:12,480
still doesn't perfectly match the

345
00:16:12,480 --> 00:16:15,120
conditions we had in the Second Step but

346
00:16:15,120 --> 00:16:17,220
we can somehow open the construction and

347
00:16:17,220 --> 00:16:20,519
introduce some tweaks and finally we can

348
00:16:20,519 --> 00:16:23,880
get construction with clue resisting

349
00:16:23,880 --> 00:16:27,180
student needs all right so that is our

350
00:16:27,180 --> 00:16:29,639
method we give a construction our Purity

351
00:16:29,639 --> 00:16:31,800
punct prf from standardized assumptions

352
00:16:31,800 --> 00:16:35,880
that has boost adaptive glue resistance

353
00:16:35,880 --> 00:16:38,459
studentness and Adaptive One key privacy

354
00:16:38,459 --> 00:16:41,459
so the main open program is therefore

355
00:16:41,459 --> 00:16:46,259
how to extend the ideas to achieve clue

356
00:16:46,259 --> 00:16:49,740
resistance privacy or how to extend the

357
00:16:49,740 --> 00:16:51,899
construction to support more General

358
00:16:51,899 --> 00:16:54,839
functionalities all right that's all

359
00:16:54,839 --> 00:16:56,699
thanks for attention and are happy to

360
00:16:56,699 --> 00:16:58,580
take your questions

361
00:16:58,580 --> 00:17:02,759
[Applause]

362
00:17:02,759 --> 00:17:05,099
great if you have questions please come

363
00:17:05,099 --> 00:17:07,439
up to the microphones Shredder

364
00:17:07,439 --> 00:17:09,660
hi thanks for the

365
00:17:09,660 --> 00:17:13,380
very nice talk uh so with regards to

366
00:17:13,380 --> 00:17:16,140
your second open problem uh

367
00:17:16,140 --> 00:17:19,319
like even two key private constraint prf

368
00:17:19,319 --> 00:17:21,780
implies IO

369
00:17:21,780 --> 00:17:23,299
um

370
00:17:23,299 --> 00:17:24,919
oh

371
00:17:24,919 --> 00:17:28,500
uh yeah uh yeah 2K uh private customer

372
00:17:28,500 --> 00:17:32,220
Pi for General constraints but we can

373
00:17:32,220 --> 00:17:36,299
maybe uh achieve some uh yeah yeah so

374
00:17:36,299 --> 00:17:38,280
that was going to be my

375
00:17:38,280 --> 00:17:40,940
for General

376
00:17:44,820 --> 00:17:47,640
cons but maybe for restricted classes of

377
00:17:47,640 --> 00:17:50,039
constraints you can hope to achieve it

378
00:17:50,039 --> 00:17:53,160
so with your construction what do you

379
00:17:53,160 --> 00:17:55,440
feel so right now you're only looking at

380
00:17:55,440 --> 00:17:57,840
puncturing constraints what do you think

381
00:17:57,840 --> 00:18:02,059
are natural classes that uh you know

382
00:18:02,059 --> 00:18:05,820
your techniques could be generalized to

383
00:18:05,820 --> 00:18:09,059
uh uh yeah uh

384
00:18:09,059 --> 00:18:12,780
uh so uh okay so actually the PayPal has

385
00:18:12,780 --> 00:18:14,820
two main techniques the Adaptive

386
00:18:14,820 --> 00:18:17,220
security and the clear resistant

387
00:18:17,220 --> 00:18:19,980
yeah I think the clue resist technique

388
00:18:19,980 --> 00:18:22,700
may be applied for Gen more General

389
00:18:22,700 --> 00:18:26,160
constraints I guess it can be yeah but

390
00:18:26,160 --> 00:18:29,280
maybe it can't be used to achieve a glue

391
00:18:29,280 --> 00:18:31,440
resistant period to custom pif because

392
00:18:31,440 --> 00:18:34,200
uh the technique for color resistance

393
00:18:34,200 --> 00:18:37,460
and doesn't apply to the previously

394
00:18:37,460 --> 00:18:41,360
so for the Adaptive security uh so

395
00:18:41,360 --> 00:18:44,220
current techniques are currently I think

396
00:18:44,220 --> 00:18:46,799
the techniques can only deal with the

397
00:18:46,799 --> 00:18:50,240
function constraint yeah because it

398
00:18:50,240 --> 00:18:54,660
will map one input the illusion of one

399
00:18:54,660 --> 00:18:57,000
input to the to a pretty different

400
00:18:57,000 --> 00:19:00,120
volume so it seems only work for the

401
00:19:00,120 --> 00:19:04,620
function or the point function yeah okay

402
00:19:04,620 --> 00:19:07,280
thank you

403
00:19:10,559 --> 00:19:12,720
you mentioned the application to

404
00:19:12,720 --> 00:19:15,000
watermarking and such a variation so

405
00:19:15,000 --> 00:19:18,240
what kind of uh Improvement did you get

406
00:19:18,240 --> 00:19:20,340
for watermarking

407
00:19:20,340 --> 00:19:25,980
okay uh so the people can uh okay so the

408
00:19:25,980 --> 00:19:28,500
paper gives a closed resistance private

409
00:19:28,500 --> 00:19:32,100
function pif and we can upgrade it to be

410
00:19:32,100 --> 00:19:35,700
a clear resist fluid uh the program pif

411
00:19:35,700 --> 00:19:40,380
I think okay so uh also we can extend

412
00:19:40,380 --> 00:19:43,440
the techniques to be close to achieve

413
00:19:43,440 --> 00:19:47,400
clue resistance a travel pif and this

414
00:19:47,400 --> 00:19:50,340
will give rest to a new way to construct

415
00:19:50,340 --> 00:19:53,640
clue resistant uh what marking what Mark

416
00:19:53,640 --> 00:19:56,360
about prf and another

417
00:19:56,360 --> 00:19:59,280
potential application must to apply the

418
00:19:59,280 --> 00:20:03,539
Adaptive circuit period program PF or

419
00:20:03,539 --> 00:20:06,240
actual prf to construct what marking

420
00:20:06,240 --> 00:20:08,640
schemes with new properties that is

421
00:20:08,640 --> 00:20:12,260
adapted to create yeah

422
00:20:12,720 --> 00:20:15,080
great let's thank the speaker again

423
00:20:15,080 --> 00:20:20,929
[Applause]

424
00:20:38,960 --> 00:20:42,720
okay all right so our next talk uh in

425
00:20:42,720 --> 00:20:44,340
this session will be on constrained

426
00:20:44,340 --> 00:20:46,080
pseudorandom functions from homomorphic

427
00:20:46,080 --> 00:20:48,780
decrease sharing by jaffua kotu Pierre

428
00:20:48,780 --> 00:20:51,720
Meyer Alan pasogu and machine and

429
00:20:51,720 --> 00:20:53,880
machine will be giving a talk okay hi

430
00:20:53,880 --> 00:20:55,980
everyone I'm masheed and I'll talk about

431
00:20:55,980 --> 00:20:58,520
our paper con

432
00:20:58,679 --> 00:21:00,840
SE chain which is a joint work with

433
00:21:00,840 --> 00:21:04,020
jofra kutopia and alum haslik

434
00:21:04,020 --> 00:21:06,900
so as the title suggests in our work we

435
00:21:06,900 --> 00:21:09,480
construct constraints or random function

436
00:21:09,480 --> 00:21:12,120
and I start by recalling what the

437
00:21:12,120 --> 00:21:14,220
surrender function is so a student

438
00:21:14,220 --> 00:21:16,440
function by the by definition is a

439
00:21:16,440 --> 00:21:18,240
deterministic heat function that is

440
00:21:18,240 --> 00:21:20,100
computationally indistinguishable from a

441
00:21:20,100 --> 00:21:21,660
truly random function

442
00:21:21,660 --> 00:21:24,000
what it basically means is that the set

443
00:21:24,000 --> 00:21:25,620
of outputs of such a function is

444
00:21:25,620 --> 00:21:27,960
computed by a massive secret key

445
00:21:27,960 --> 00:21:29,940
and then from the point of view of an

446
00:21:29,940 --> 00:21:31,500
adversary who doesn't have access to

447
00:21:31,500 --> 00:21:33,900
this massive secret key it all looks

448
00:21:33,900 --> 00:21:35,760
random or blurry

449
00:21:35,760 --> 00:21:38,460
but then this adversary can issue some

450
00:21:38,460 --> 00:21:40,919
Oracle queries to the function to get

451
00:21:40,919 --> 00:21:43,140
the output of the function of on some

452
00:21:43,140 --> 00:21:44,820
inputs of its choice

453
00:21:44,820 --> 00:21:47,220
while learning nothing about the other

454
00:21:47,220 --> 00:21:48,900
points

455
00:21:48,900 --> 00:21:51,659
so a constraints to random function is

456
00:21:51,659 --> 00:21:53,940
again a surrender function so it has all

457
00:21:53,940 --> 00:21:55,500
of these properties

458
00:21:55,500 --> 00:21:57,740
but it has an additional functionality

459
00:21:57,740 --> 00:22:00,720
which is uh for a subset of inputs like

460
00:22:00,720 --> 00:22:04,380
s we can generate a constraint key CK of

461
00:22:04,380 --> 00:22:07,799
s from the master circuit key and that

462
00:22:07,799 --> 00:22:09,960
allows the adversary to compute the

463
00:22:09,960 --> 00:22:12,059
function correctly on this subset of

464
00:22:12,059 --> 00:22:14,400
inputs so suddenly a subset of outputs

465
00:22:14,400 --> 00:22:16,020
get revealed

466
00:22:16,020 --> 00:22:19,080
and then for the security we need the

467
00:22:19,080 --> 00:22:20,640
output of the function everywhere else

468
00:22:20,640 --> 00:22:23,039
so outside of this subset or outside of

469
00:22:23,039 --> 00:22:25,320
the queries that it has issued to still

470
00:22:25,320 --> 00:22:27,780
look random or blurry

471
00:22:27,780 --> 00:22:29,960
now just a final comment

472
00:22:29,960 --> 00:22:33,059
this constraint subset s is usually

473
00:22:33,059 --> 00:22:35,280
defined by a predicate so for predicate

474
00:22:35,280 --> 00:22:39,299
C on the set of inputs X we Define s of

475
00:22:39,299 --> 00:22:41,400
C the constraint set to be all of the

476
00:22:41,400 --> 00:22:43,799
inputs on which the constraint evaluates

477
00:22:43,799 --> 00:22:45,539
to zero so this is the inverse of the

478
00:22:45,539 --> 00:22:47,760
previous stock

479
00:22:47,760 --> 00:22:51,059
now in our work we construct these

480
00:22:51,059 --> 00:22:53,100
things so constraints random function

481
00:22:53,100 --> 00:22:55,799
for the class of inner product and nc1

482
00:22:55,799 --> 00:22:57,900
so log depth predicates

483
00:22:57,900 --> 00:23:00,600
and our construction allows for the

484
00:23:00,600 --> 00:23:03,059
generation of one constraint key so for

485
00:23:03,059 --> 00:23:06,179
one subset and it's selectively secure

486
00:23:06,179 --> 00:23:08,100
in the sense that in the security gain

487
00:23:08,100 --> 00:23:11,700
we need this subset s to be known before

488
00:23:11,700 --> 00:23:14,340
anything else

489
00:23:14,340 --> 00:23:16,380
we also have some cool MPC applications

490
00:23:16,380 --> 00:23:18,720
that I will mention later

491
00:23:18,720 --> 00:23:20,820
and so the way we construct our

492
00:23:20,820 --> 00:23:22,980
constraint prf is by using another

493
00:23:22,980 --> 00:23:26,280
protocol that's called homophy sharing

494
00:23:26,280 --> 00:23:29,159
so a homophysical change scheme is used

495
00:23:29,159 --> 00:23:31,980
to perform distributed evaluation on

496
00:23:31,980 --> 00:23:35,039
some secret so for instance let's take a

497
00:23:35,039 --> 00:23:38,159
program p in some family of programs and

498
00:23:38,159 --> 00:23:40,740
some secret s and the goal of homophisic

499
00:23:40,740 --> 00:23:44,220
catching skin is to evaluate povers

500
00:23:44,220 --> 00:23:47,659
and the way it does it is it first

501
00:23:47,659 --> 00:23:50,220
shares this secret between two parties

502
00:23:50,220 --> 00:23:53,220
so these shares can be some encoding not

503
00:23:53,220 --> 00:23:56,340
necessarily additive shares it also

504
00:23:56,340 --> 00:23:58,860
gives some evaluation key to each of

505
00:23:58,860 --> 00:24:01,320
them and then it has them run some

506
00:24:01,320 --> 00:24:03,539
evaluation algorithm on their inputs

507
00:24:03,539 --> 00:24:06,059
with respect to this program P to get

508
00:24:06,059 --> 00:24:07,320
some output

509
00:24:07,320 --> 00:24:09,600
and now for this protocol to be useful

510
00:24:09,600 --> 00:24:11,720
and meaningful we need two properties

511
00:24:11,720 --> 00:24:14,940
the first one is secrecy which roughly

512
00:24:14,940 --> 00:24:16,860
states that each of these shares that

513
00:24:16,860 --> 00:24:19,200
that is given to the parties should

514
00:24:19,200 --> 00:24:22,260
individually hide the original secret s

515
00:24:22,260 --> 00:24:24,539
and we need correctness

516
00:24:24,539 --> 00:24:26,880
so the goal of this protocol was to

517
00:24:26,880 --> 00:24:28,919
evaluate previous right and for the

518
00:24:28,919 --> 00:24:31,140
correctness we need the output of each

519
00:24:31,140 --> 00:24:32,760
of these two party to be actually a

520
00:24:32,760 --> 00:24:35,700
subtractive shares of this P of s

521
00:24:35,700 --> 00:24:37,980
so y0 which is the after the first party

522
00:24:37,980 --> 00:24:39,900
minus y1 which is the absolute second

523
00:24:39,900 --> 00:24:43,260
party should be equal to P of s

524
00:24:43,260 --> 00:24:45,960
and yeah as I mentioned in our work we

525
00:24:45,960 --> 00:24:49,140
show how to transform this protocol into

526
00:24:49,140 --> 00:24:51,539
a constraints random function which

527
00:24:51,539 --> 00:24:54,120
allows for one key uh constraint

528
00:24:54,120 --> 00:24:57,240
generation and so in order to do our

529
00:24:57,240 --> 00:24:59,760
transform we first recognize the useful

530
00:24:59,760 --> 00:25:01,620
properties of the underlying homophysics

531
00:25:01,620 --> 00:25:05,700
scheme and then we show that actually

532
00:25:05,700 --> 00:25:07,980
most of the existing homophysical change

533
00:25:07,980 --> 00:25:10,500
schemes already satisfy these properties

534
00:25:10,500 --> 00:25:12,600
and therefore we have a bunch of new

535
00:25:12,600 --> 00:25:15,240
constructions for such a constrained prf

536
00:25:15,240 --> 00:25:17,940
with these properties and then we

537
00:25:17,940 --> 00:25:20,100
revisit applications of homophysics

538
00:25:20,100 --> 00:25:22,200
scheme with these properties that we

539
00:25:22,200 --> 00:25:25,140
recognize to secure computation

540
00:25:25,140 --> 00:25:27,299
in particular to secure competition with

541
00:25:27,299 --> 00:25:29,159
silent pre-processing and secure

542
00:25:29,159 --> 00:25:32,340
computation with sublinear communication

543
00:25:32,340 --> 00:25:33,779
now let's see how we do our

544
00:25:33,779 --> 00:25:36,179
transformation and so let's consider

545
00:25:36,179 --> 00:25:37,620
constraint C

546
00:25:37,620 --> 00:25:41,340
and the constraints that is so we want

547
00:25:41,340 --> 00:25:43,500
the adversaries we want some constraints

548
00:25:43,500 --> 00:25:46,620
of prf which allows the adversary to

549
00:25:46,620 --> 00:25:48,960
evaluate the function on this constraint

550
00:25:48,960 --> 00:25:51,720
subset s of C without learning anything

551
00:25:51,720 --> 00:25:52,860
else

552
00:25:52,860 --> 00:25:55,380
now the idea here is to take a prf so a

553
00:25:55,380 --> 00:25:58,679
normal prf if with key k

554
00:25:58,679 --> 00:26:01,260
and then to use a homophysical change

555
00:26:01,260 --> 00:26:03,779
scheme to compute this special program

556
00:26:03,779 --> 00:26:06,299
so the program is parameterized by X by

557
00:26:06,299 --> 00:26:08,880
the input X and it takes as input the

558
00:26:08,880 --> 00:26:12,299
prfqk and the constraint predicate C and

559
00:26:12,299 --> 00:26:15,480
evaluates to C of x times F K of x

560
00:26:15,480 --> 00:26:17,100
so

561
00:26:17,100 --> 00:26:19,200
um what's it look like

562
00:26:19,200 --> 00:26:23,340
so in order to compute our program in a

563
00:26:23,340 --> 00:26:25,140
homophysical change scheme what we need

564
00:26:25,140 --> 00:26:28,500
to do is to First share these inputs

565
00:26:28,500 --> 00:26:30,779
between two parties so we share the

566
00:26:30,779 --> 00:26:33,299
constraint and the prf key between two

567
00:26:33,299 --> 00:26:36,600
parties and we give one share one part

568
00:26:36,600 --> 00:26:38,220
of the shares to the master secret key

569
00:26:38,220 --> 00:26:39,779
holder and the other part to the

570
00:26:39,779 --> 00:26:42,659
adversary or the constraint key holder

571
00:26:42,659 --> 00:26:44,880
and we give each of them also the

572
00:26:44,880 --> 00:26:47,100
corresponding evaluation key we have

573
00:26:47,100 --> 00:26:49,200
them run the evaluation algorithm of of

574
00:26:49,200 --> 00:26:51,240
the homographic secret chain scheme I

575
00:26:51,240 --> 00:26:53,340
with respect to our special program

576
00:26:53,340 --> 00:26:55,860
uh to generate some output and then we

577
00:26:55,860 --> 00:26:57,600
call the output of the first party so

578
00:26:57,600 --> 00:26:59,279
the output of the master security holder

579
00:26:59,279 --> 00:27:01,440
to be the output of our constraint to

580
00:27:01,440 --> 00:27:02,640
random function

581
00:27:02,640 --> 00:27:04,740
and the output of the addresser to be

582
00:27:04,740 --> 00:27:08,100
the output of the constraint evaluation

583
00:27:08,100 --> 00:27:13,380
now why is it working so uh since the

584
00:27:13,380 --> 00:27:16,799
HSS scheme provides correctness it means

585
00:27:16,799 --> 00:27:18,779
that these outputs are actually

586
00:27:18,779 --> 00:27:21,240
subtractive shares of our program

587
00:27:21,240 --> 00:27:25,020
now for an input X that is inside of the

588
00:27:25,020 --> 00:27:27,919
constraint set and this our program

589
00:27:27,919 --> 00:27:30,419
evaluates to zero because service is

590
00:27:30,419 --> 00:27:32,820
equal to zero so these two Shares are

591
00:27:32,820 --> 00:27:34,440
subtractive shares of zero which means

592
00:27:34,440 --> 00:27:37,620
that they are equal so in this case the

593
00:27:37,620 --> 00:27:40,020
adversary evaluates the same thing as

594
00:27:40,020 --> 00:27:42,240
the output of the function

595
00:27:42,240 --> 00:27:44,820
and for an input that is outside of this

596
00:27:44,820 --> 00:27:47,460
constraint set s our program evaluates

597
00:27:47,460 --> 00:27:49,500
to FK of X because service is equal to

598
00:27:49,500 --> 00:27:53,039
one and in this case

599
00:27:53,039 --> 00:27:56,700
y 0 minus y1 is equal to FK of X and in

600
00:27:56,700 --> 00:27:58,260
particular y 0

601
00:27:58,260 --> 00:28:01,860
is equal to y1 plus FK of a so y 0 is

602
00:28:01,860 --> 00:28:04,520
what the adversary evaluates

603
00:28:04,520 --> 00:28:09,720
and therefore sorry y1 is the what is

604
00:28:09,720 --> 00:28:11,640
what the adversary evaluates and Y 0 is

605
00:28:11,640 --> 00:28:13,860
the output out function so the output of

606
00:28:13,860 --> 00:28:15,419
the function looks random from the point

607
00:28:15,419 --> 00:28:17,279
of view of an adversary because K is

608
00:28:17,279 --> 00:28:19,260
hidden due to the security of the

609
00:28:19,260 --> 00:28:21,600
homophysics scheme

610
00:28:21,600 --> 00:28:23,580
so in this case the output of the

611
00:28:23,580 --> 00:28:25,380
function looks random from the point of

612
00:28:25,380 --> 00:28:27,539
view of the adversary so it looks like

613
00:28:27,539 --> 00:28:29,220
everything is working we are satisfying

614
00:28:29,220 --> 00:28:30,659
the properties of a constitutional

615
00:28:30,659 --> 00:28:33,120
random function by doing all this

616
00:28:33,120 --> 00:28:35,580
but as usual it's not the case so soon

617
00:28:35,580 --> 00:28:38,340
so here the message secret key depends

618
00:28:38,340 --> 00:28:41,400
on the constraint predicate C because of

619
00:28:41,400 --> 00:28:42,900
this first share that we are giving to

620
00:28:42,900 --> 00:28:45,179
the master circuit key holder

621
00:28:45,179 --> 00:28:47,039
and this shouldn't be the case right

622
00:28:47,039 --> 00:28:49,020
because the output of a constraints

623
00:28:49,020 --> 00:28:50,840
random function should be evaluated

624
00:28:50,840 --> 00:28:52,980
independently of whether the adversary

625
00:28:52,980 --> 00:28:55,559
is going to issue a constraint key query

626
00:28:55,559 --> 00:28:57,240
or not

627
00:28:57,240 --> 00:28:59,820
so now the question is how to generate

628
00:28:59,820 --> 00:29:01,620
this first share without knowing the

629
00:29:01,620 --> 00:29:03,419
consequent C

630
00:29:03,419 --> 00:29:06,299
and in order to answer that let's take a

631
00:29:06,299 --> 00:29:08,159
deeper look at what really happens when

632
00:29:08,159 --> 00:29:10,140
we do our transformation

633
00:29:10,140 --> 00:29:12,900
so in homomorphics you can change

634
00:29:12,900 --> 00:29:15,659
schemes that support our program or in

635
00:29:15,659 --> 00:29:17,700
general nc1 program so log depth

636
00:29:17,700 --> 00:29:19,500
circuits

637
00:29:19,500 --> 00:29:23,399
here is what happens so in order to

638
00:29:23,399 --> 00:29:27,059
compute a program we share the inputs

639
00:29:27,059 --> 00:29:28,740
but the way we share the inputs is

640
00:29:28,740 --> 00:29:32,100
actually giving identical ciphertext to

641
00:29:32,100 --> 00:29:35,460
both both of the parties okay

642
00:29:35,460 --> 00:29:38,640
so here the problem becomes more evident

643
00:29:38,640 --> 00:29:40,679
because here the encryption of the

644
00:29:40,679 --> 00:29:43,100
cipher test I mean the input of the

645
00:29:43,100 --> 00:29:46,559
constraint C depends on the constant C

646
00:29:46,559 --> 00:29:48,960
and cannot be faked

647
00:29:48,960 --> 00:29:52,500
so now let's take a deeper look at what

648
00:29:52,500 --> 00:29:54,179
happens in the evaluation algorithm of

649
00:29:54,179 --> 00:29:56,640
the homophysical change scheme

650
00:29:56,640 --> 00:29:59,520
so in the evaluation algorithm as

651
00:29:59,520 --> 00:30:00,840
mentioned

652
00:30:00,840 --> 00:30:04,260
the inputs are in form of ciphertext

653
00:30:04,260 --> 00:30:07,679
and we have also an evaluation key

654
00:30:07,679 --> 00:30:11,159
and we have some special operation

655
00:30:11,159 --> 00:30:13,679
which is conversion so you can convert

656
00:30:13,679 --> 00:30:16,919
an input which is a ciphertext into a

657
00:30:16,919 --> 00:30:19,679
memory value so you can view it as just

658
00:30:19,679 --> 00:30:21,740
loading an input into memory

659
00:30:21,740 --> 00:30:24,840
and it should be such that if you look

660
00:30:24,840 --> 00:30:27,600
at the memory values of the two parties

661
00:30:27,600 --> 00:30:31,260
they should form subtractive shares of

662
00:30:31,260 --> 00:30:33,720
what they represent so if you convert an

663
00:30:33,720 --> 00:30:35,399
input of C which is an encryption of C

664
00:30:35,399 --> 00:30:39,120
into memory shares they are actually

665
00:30:39,120 --> 00:30:42,360
subtractive shares of C

666
00:30:42,360 --> 00:30:44,460
and just a final note on how this

667
00:30:44,460 --> 00:30:46,260
conversion happens

668
00:30:46,260 --> 00:30:48,120
so we have a second algorithm that is

669
00:30:48,120 --> 00:30:49,440
multiplication

670
00:30:49,440 --> 00:30:52,500
and it can specifically only happen

671
00:30:52,500 --> 00:30:54,720
between an input value so an encryption

672
00:30:54,720 --> 00:30:58,260
and a memory value uh share a

673
00:30:58,260 --> 00:31:00,179
subtractive share and it outputs the

674
00:31:00,179 --> 00:31:01,799
subtractive share of the multiplication

675
00:31:01,799 --> 00:31:04,500
that these two value represent

676
00:31:04,500 --> 00:31:07,740
now it's easy to see that the conversion

677
00:31:07,740 --> 00:31:09,899
algorithm can be translated to

678
00:31:09,899 --> 00:31:12,539
multiplication between the input that we

679
00:31:12,539 --> 00:31:13,740
want to convert

680
00:31:13,740 --> 00:31:16,260
and the share of one

681
00:31:16,260 --> 00:31:18,779
okay now let's go back to the fact that

682
00:31:18,779 --> 00:31:21,720
uh memory values were subtractive shares

683
00:31:21,720 --> 00:31:23,880
of what they represent so here it's good

684
00:31:23,880 --> 00:31:26,820
news right because one of them can be

685
00:31:26,820 --> 00:31:27,779
faked

686
00:31:27,779 --> 00:31:31,440
in particular for the constraint C

687
00:31:31,440 --> 00:31:34,799
um in the master secret key shares we

688
00:31:34,799 --> 00:31:37,020
can generate some random value as the

689
00:31:37,020 --> 00:31:39,360
memory value of c and then after we know

690
00:31:39,360 --> 00:31:41,399
the constraint see we can set the memory

691
00:31:41,399 --> 00:31:44,340
value of this constraint in the

692
00:31:44,340 --> 00:31:46,740
constraint key to be the complementary

693
00:31:46,740 --> 00:31:48,240
share

694
00:31:48,240 --> 00:31:52,080
okay so there's some hope because now we

695
00:31:52,080 --> 00:31:53,880
just generated something that is related

696
00:31:53,880 --> 00:31:56,100
to the constraint in the master secret

697
00:31:56,100 --> 00:31:59,460
key part without knowing the constraint

698
00:31:59,460 --> 00:32:01,620
so it turns out that this simple

699
00:32:01,620 --> 00:32:04,620
observation is actually helping us to

700
00:32:04,620 --> 00:32:07,020
solve the problem of constraints random

701
00:32:07,020 --> 00:32:09,960
function for inner product constraints

702
00:32:09,960 --> 00:32:12,299
so for inner product constraints our

703
00:32:12,299 --> 00:32:15,059
program changes to this

704
00:32:15,059 --> 00:32:17,399
so we have a vector Z and the program

705
00:32:17,399 --> 00:32:20,100
evaluates to the inner product of Z and

706
00:32:20,100 --> 00:32:22,260
E times F K of x

707
00:32:22,260 --> 00:32:23,940
and the adversary should be able to

708
00:32:23,940 --> 00:32:27,779
compute the function on inputs that are

709
00:32:27,779 --> 00:32:30,360
also going on to this Vector Z

710
00:32:30,360 --> 00:32:33,179
now the way we do it based on what we

711
00:32:33,179 --> 00:32:34,500
just saw

712
00:32:34,500 --> 00:32:35,159
um

713
00:32:35,159 --> 00:32:37,620
we put shares of this constraint Vector

714
00:32:37,620 --> 00:32:40,080
Z into Master circuit key and the

715
00:32:40,080 --> 00:32:42,960
constraint key and so we can set the

716
00:32:42,960 --> 00:32:44,880
share that is inside of the massive

717
00:32:44,880 --> 00:32:46,860
security to be a random value

718
00:32:46,860 --> 00:32:50,220
and the part that is in the constraint

719
00:32:50,220 --> 00:32:52,380
key to be the complementary share

720
00:32:52,380 --> 00:32:55,220
we also give each of them the original

721
00:32:55,220 --> 00:32:59,880
homographic sharing inputs of the key k

722
00:32:59,880 --> 00:33:02,580
together with the evaluation Keys now

723
00:33:02,580 --> 00:33:04,799
why does it work because naturally we

724
00:33:04,799 --> 00:33:06,960
would need an encryption of Z

725
00:33:06,960 --> 00:33:09,779
so here we go back to the fact that the

726
00:33:09,779 --> 00:33:12,000
conversion of an input into memory value

727
00:33:12,000 --> 00:33:14,460
was actually multiplication between the

728
00:33:14,460 --> 00:33:17,340
inputs and the share of one

729
00:33:17,340 --> 00:33:20,220
and what we say is that if we extend our

730
00:33:20,220 --> 00:33:22,080
evaluation algorithm so the evaluation

731
00:33:22,080 --> 00:33:24,539
algorithm of the homophysical chain

732
00:33:24,539 --> 00:33:26,960
to be such that this conversion

733
00:33:26,960 --> 00:33:30,360
is defined to be the multiplication of

734
00:33:30,360 --> 00:33:31,980
the input that you want to convert with

735
00:33:31,980 --> 00:33:34,679
the share of this constraint Vector Z

736
00:33:34,679 --> 00:33:38,220
then if we convert a value so a server

737
00:33:38,220 --> 00:33:40,740
text like encryption of M

738
00:33:40,740 --> 00:33:43,559
we actually are multiplying it by a

739
00:33:43,559 --> 00:33:45,600
share of Z so what we get is the share

740
00:33:45,600 --> 00:33:47,580
of M times Z

741
00:33:47,580 --> 00:33:50,279
so it's like we already multiply every

742
00:33:50,279 --> 00:33:52,019
memory value by Z

743
00:33:52,019 --> 00:33:54,860
and in particular if we could

744
00:33:54,860 --> 00:33:57,419
compute a share of FK of x from an

745
00:33:57,419 --> 00:33:59,100
encryption of X which was the case

746
00:33:59,100 --> 00:34:00,779
because of the correctness of the

747
00:34:00,779 --> 00:34:03,659
homophysical sharing scheme Now by this

748
00:34:03,659 --> 00:34:06,360
new definition we can compute a share of

749
00:34:06,360 --> 00:34:09,239
Z times F K of x and by linearity we

750
00:34:09,239 --> 00:34:12,359
compute the share of Z times x times FK

751
00:34:12,359 --> 00:34:15,119
of X which was the our program

752
00:34:15,119 --> 00:34:17,760
so in this case everything is working

753
00:34:17,760 --> 00:34:19,679
this is the construction for constraint

754
00:34:19,679 --> 00:34:23,659
peer for inner product constraints

755
00:34:23,839 --> 00:34:26,639
yeah the finally the construction looks

756
00:34:26,639 --> 00:34:29,460
something like this and the shared that

757
00:34:29,460 --> 00:34:32,879
we give to the master security holder is

758
00:34:32,879 --> 00:34:34,800
was a random value as I said this was

759
00:34:34,800 --> 00:34:36,119
the point because we wanted to be

760
00:34:36,119 --> 00:34:38,460
independent of the constraint C

761
00:34:38,460 --> 00:34:41,699
and also the share that we give to the

762
00:34:41,699 --> 00:34:43,800
adversary as the part of the constraint

763
00:34:43,800 --> 00:34:46,619
key is also only a share of Z so it

764
00:34:46,619 --> 00:34:48,179
doesn't have to know the whole

765
00:34:48,179 --> 00:34:50,820
constraint Vector z

766
00:34:50,820 --> 00:34:53,760
um and therefore it satisfy the notion

767
00:34:53,760 --> 00:34:55,679
of constraint I think

768
00:34:55,679 --> 00:34:59,220
which is useful in some applications

769
00:34:59,220 --> 00:35:02,339
now let's just take a quick peek at what

770
00:35:02,339 --> 00:35:06,119
happens for nc1 predicate so for log

771
00:35:06,119 --> 00:35:08,280
depth circuits

772
00:35:08,280 --> 00:35:10,740
so the idea is exactly the same we have

773
00:35:10,740 --> 00:35:14,040
our program that I described before

774
00:35:14,040 --> 00:35:16,400
and the problem was how to generate this

775
00:35:16,400 --> 00:35:20,040
a share of the constraint C without

776
00:35:20,040 --> 00:35:21,960
knowing C because we couldn't put an

777
00:35:21,960 --> 00:35:24,480
encryption of C into the massive circuit

778
00:35:24,480 --> 00:35:25,500
key

779
00:35:25,500 --> 00:35:29,339
and here what we observe is that in some

780
00:35:29,339 --> 00:35:31,940
homophysical change schemes in the

781
00:35:31,940 --> 00:35:36,000
encryption algorithm that they use we

782
00:35:36,000 --> 00:35:37,980
can partition the ciphertates into two

783
00:35:37,980 --> 00:35:40,380
parts so a message independent part and

784
00:35:40,380 --> 00:35:43,680
the message dependent part and we give

785
00:35:43,680 --> 00:35:46,079
the message independent part to the

786
00:35:46,079 --> 00:35:48,660
address into the message circuit holder

787
00:35:48,660 --> 00:35:51,119
and the whole Cipher takes together with

788
00:35:51,119 --> 00:35:53,400
the constraint predicate C to the

789
00:35:53,400 --> 00:35:55,079
adversary as a part of the constraint

790
00:35:55,079 --> 00:35:57,420
key so here we are giving the whole

791
00:35:57,420 --> 00:35:59,820
constraint to the adversary and so it's

792
00:35:59,820 --> 00:36:03,420
not concentrate hiding anymore

793
00:36:03,420 --> 00:36:06,660
and then we have each of them to run

794
00:36:06,660 --> 00:36:09,420
some separate different evaluation

795
00:36:09,420 --> 00:36:10,859
algorithms

796
00:36:10,859 --> 00:36:15,300
on their special shares to get memory

797
00:36:15,300 --> 00:36:18,480
values so subtractive shares of C of x

798
00:36:18,480 --> 00:36:22,560
and then from these shares of cervix and

799
00:36:22,560 --> 00:36:25,560
an encryption of K so an input of K we

800
00:36:25,560 --> 00:36:27,720
use the same idea that I explained

801
00:36:27,720 --> 00:36:30,660
before to evaluate a share of C of X

802
00:36:30,660 --> 00:36:32,940
types of KFX

803
00:36:32,940 --> 00:36:36,359
so that was it to conclude my talk we

804
00:36:36,359 --> 00:36:37,940
showed that

805
00:36:37,940 --> 00:36:39,839
homophilicaturing skin with some level

806
00:36:39,839 --> 00:36:41,579
of programmability

807
00:36:41,579 --> 00:36:44,359
employs constraints or random function

808
00:36:44,359 --> 00:36:46,920
especially for I mean in particular for

809
00:36:46,920 --> 00:36:49,400
inner product and SC1 predicates

810
00:36:49,400 --> 00:36:52,140
and we therefore have some new

811
00:36:52,140 --> 00:36:54,420
constructions of constraints and random

812
00:36:54,420 --> 00:36:56,220
functions from these five assumptions

813
00:36:56,220 --> 00:36:58,099
that I will not read out loud

814
00:36:58,099 --> 00:37:00,960
and in the end we revisit applications

815
00:37:00,960 --> 00:37:02,820
of homomorphicycle chain to secure

816
00:37:02,820 --> 00:37:04,140
computation

817
00:37:04,140 --> 00:37:06,180
particular to secure competition with

818
00:37:06,180 --> 00:37:08,520
silent pre-processing where one party

819
00:37:08,520 --> 00:37:10,740
can do all the pre-processing even

820
00:37:10,740 --> 00:37:12,420
before it knows the identity of the

821
00:37:12,420 --> 00:37:16,320
other party and one-sided statistically

822
00:37:16,320 --> 00:37:18,440
secure competition

823
00:37:18,440 --> 00:37:20,820
with sublinear communication which

824
00:37:20,820 --> 00:37:24,240
wasn't known before without volumorphic

825
00:37:24,240 --> 00:37:25,380
encryption

826
00:37:25,380 --> 00:37:26,940
that's it thank you very much for your

827
00:37:26,940 --> 00:37:29,180
attention

828
00:37:31,570 --> 00:37:33,859
[Applause]

829
00:37:33,859 --> 00:37:36,000
great so we have time for a couple

830
00:37:36,000 --> 00:37:37,859
questions so if you have one please come

831
00:37:37,859 --> 00:37:40,260
up to the microphones

832
00:37:40,260 --> 00:37:42,119
yeah if you have a question please come

833
00:37:42,119 --> 00:37:44,720
up to that link

834
00:37:45,359 --> 00:37:47,160
because it's the interesting application

835
00:37:47,160 --> 00:37:50,579
or home office literary I want to ask if

836
00:37:50,579 --> 00:37:52,880
the if the

837
00:37:52,880 --> 00:37:56,460
assumption is based on TCR or LW that

838
00:37:56,460 --> 00:37:58,800
means uh underlying how the problem has

839
00:37:58,800 --> 00:38:00,920
a trapdoor and the

840
00:38:00,920 --> 00:38:03,660
evaluation key from the evaluation to

841
00:38:03,660 --> 00:38:06,180
the public keys there is a comprehensive

842
00:38:06,180 --> 00:38:09,780
MP then maybe your scheme can support

843
00:38:09,780 --> 00:38:12,720
multi constraint right

844
00:38:12,720 --> 00:38:15,060
so so I didn't get so from the

845
00:38:15,060 --> 00:38:17,220
evaluation key so if the evaluation key

846
00:38:17,220 --> 00:38:20,640
is it actually uh subtractive shares of

847
00:38:20,640 --> 00:38:22,800
the secret key of the encryption scheme

848
00:38:22,800 --> 00:38:24,420
that the homophysical change is using

849
00:38:24,420 --> 00:38:26,880
yeah yeah I mean if there is a trap door

850
00:38:26,880 --> 00:38:30,240
oh there and also the the mapping from

851
00:38:30,240 --> 00:38:32,460
the secret key to the public key is a

852
00:38:32,460 --> 00:38:35,160
compressor managing there are many

853
00:38:35,160 --> 00:38:37,560
secret keys for Van public key and then

854
00:38:37,560 --> 00:38:39,000
you can find the Visa chapter you can

855
00:38:39,000 --> 00:38:41,240
find many security key and the master

856
00:38:41,240 --> 00:38:44,099
key is given every time you constrain

857
00:38:44,099 --> 00:38:48,660
the prf you can generate uh one every

858
00:38:48,660 --> 00:38:50,400
time you concentrate the pi and every

859
00:38:50,400 --> 00:38:54,180
time they generate a different security

860
00:38:54,180 --> 00:38:56,460
for the whole home office charging

861
00:38:56,460 --> 00:38:58,680
scheme and then sharing for the sharing

862
00:38:58,680 --> 00:39:00,720
the most secret key is always the same

863
00:39:00,720 --> 00:39:02,880
and then you can constraint for each

864
00:39:02,880 --> 00:39:04,020
every time

865
00:39:04,020 --> 00:39:07,560
uh so so our construction only allows

866
00:39:07,560 --> 00:39:10,140
for one constraint key yeah so we can

867
00:39:10,140 --> 00:39:13,020
only generate one if we have two we can

868
00:39:13,020 --> 00:39:15,359
recover the secret key of the encryption

869
00:39:15,359 --> 00:39:16,440
scheme

870
00:39:16,440 --> 00:39:21,300
yeah yeah if that answers your question

871
00:39:21,300 --> 00:39:23,720
sure

872
00:39:29,540 --> 00:39:31,800
one kind of question I was a little

873
00:39:31,800 --> 00:39:34,140
confused over on the setup so for

874
00:39:34,140 --> 00:39:35,460
constraint peer off you want to be able

875
00:39:35,460 --> 00:39:37,740
to um invite on sorry evaluate on

876
00:39:37,740 --> 00:39:40,380
several different X's right yeah but it

877
00:39:40,380 --> 00:39:42,420
seemed to me that once this master

878
00:39:42,420 --> 00:39:44,400
Authority like going back to our very

879
00:39:44,400 --> 00:39:47,280
beginning slides yeah wasn't X sort of

880
00:39:47,280 --> 00:39:49,200
already

881
00:39:49,200 --> 00:39:51,839
plugged into it and hardwired into it oh

882
00:39:51,839 --> 00:39:53,579
no no no so

883
00:39:53,579 --> 00:39:56,520
um here for instance

884
00:39:56,520 --> 00:39:59,520
um the program p is parameterized by X

885
00:39:59,520 --> 00:40:01,920
so when you run the evaluation algorithm

886
00:40:01,920 --> 00:40:04,320
of the homomorphicycle chain you can

887
00:40:04,320 --> 00:40:09,060
give as input the input x that you want

888
00:40:09,060 --> 00:40:10,619
okay and

889
00:40:10,619 --> 00:40:12,660
the the person doing the valuation has

890
00:40:12,660 --> 00:40:15,140
both of these things

891
00:40:15,140 --> 00:40:18,599
both for the master and and for the the

892
00:40:18,599 --> 00:40:20,700
one below it and it can do the eval and

893
00:40:20,700 --> 00:40:22,320
it's still secure yeah yeah yeah yeah

894
00:40:22,320 --> 00:40:26,099
yeah so it I mean the input X is not

895
00:40:26,099 --> 00:40:28,440
fixed so the input text is a variable

896
00:40:28,440 --> 00:40:30,599
that I mean it's a function so you have

897
00:40:30,599 --> 00:40:32,640
to evaluate zero and I could run it on

898
00:40:32,640 --> 00:40:35,960
any yeah exactly exactly okay

899
00:40:36,240 --> 00:40:38,040
any further questions

900
00:40:38,040 --> 00:40:41,400
yeah one quick one so it use I guess you

901
00:40:41,400 --> 00:40:43,560
got a constrained prfs for nc1 because

902
00:40:43,560 --> 00:40:45,780
you used an HSS for NCAA if you had an

903
00:40:45,780 --> 00:40:47,760
HSS for p poly would you get constrained

904
00:40:47,760 --> 00:40:49,560
prfs for General circuits yeah I can

905
00:40:49,560 --> 00:40:51,740
imagine

906
00:40:51,900 --> 00:40:54,359
great any other questions

907
00:40:54,359 --> 00:40:56,520
not let's thank the speaker again thank

908
00:40:56,520 --> 00:40:58,700
you

909
00:41:01,680 --> 00:41:04,759
this concludes the session

