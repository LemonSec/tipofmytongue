1
00:00:01,020 --> 00:00:03,680
so welcome to the last session of today

2
00:00:03,680 --> 00:00:07,500
the first talk is about succinct Vector

3
00:00:07,500 --> 00:00:09,120
polynomial and functional commitments

4
00:00:09,120 --> 00:00:10,380
from lattices

5
00:00:10,380 --> 00:00:12,960
by hot degree and David Wu and David

6
00:00:12,960 --> 00:00:15,480
will give the talk all right so thanks a

7
00:00:15,480 --> 00:00:16,680
lot for the introduction and thanks

8
00:00:16,680 --> 00:00:18,539
everyone for coming to the final session

9
00:00:18,539 --> 00:00:20,340
of the conference so I'll be telling you

10
00:00:20,340 --> 00:00:21,900
about succinct functional commitments

11
00:00:21,900 --> 00:00:23,460
from badasses and this is Joint work

12
00:00:23,460 --> 00:00:24,720
with hotec

13
00:00:24,720 --> 00:00:27,180
so in a functional commitment a user can

14
00:00:27,180 --> 00:00:29,220
commit to some input X and produce some

15
00:00:29,220 --> 00:00:31,619
commitment Sigma and later on they can

16
00:00:31,619 --> 00:00:33,480
take their commitment Sigma and open it

17
00:00:33,480 --> 00:00:35,100
with respect to some arbitrary function

18
00:00:35,100 --> 00:00:38,100
f to the value f of x

19
00:00:38,100 --> 00:00:40,200
more formally and in this talk we're

20
00:00:40,200 --> 00:00:41,760
going to focus exclusively on

21
00:00:41,760 --> 00:00:43,620
non-interactive commitment schemes where

22
00:00:43,620 --> 00:00:45,540
the commitment algorithm and the opening

23
00:00:45,540 --> 00:00:47,219
algorithm will take as input and

24
00:00:47,219 --> 00:00:49,020
additional common reference string so

25
00:00:49,020 --> 00:00:50,100
the commitment will take the common

26
00:00:50,100 --> 00:00:52,440
reference string or the CRS takes in the

27
00:00:52,440 --> 00:00:54,960
input X and produces the commitment and

28
00:00:54,960 --> 00:00:57,660
sum commitment state

29
00:00:57,660 --> 00:00:59,760
later on when you want to open a

30
00:00:59,760 --> 00:01:02,160
commitment you specify a function f and

31
00:01:02,160 --> 00:01:04,080
this produces an opening which I will

32
00:01:04,080 --> 00:01:07,080
denote pi finally you can verify the

33
00:01:07,080 --> 00:01:08,460
commitment and the verification

34
00:01:08,460 --> 00:01:10,439
algorithm takes the commitment takes a

35
00:01:10,439 --> 00:01:12,479
function f and a purported value and

36
00:01:12,479 --> 00:01:14,580
checks that the value is actually F

37
00:01:14,580 --> 00:01:16,560
evaluated on the underlying commitment

38
00:01:16,560 --> 00:01:18,000
itself

39
00:01:18,000 --> 00:01:19,979
the main security of notion that we're

40
00:01:19,979 --> 00:01:21,659
going to consider in this talk is

41
00:01:21,659 --> 00:01:23,640
binding which essentially says that a

42
00:01:23,640 --> 00:01:25,380
computationally bounded or efficient

43
00:01:25,380 --> 00:01:27,720
adversary should not be able to open the

44
00:01:27,720 --> 00:01:30,000
same commitment with to two different

45
00:01:30,000 --> 00:01:31,860
values with respect to the same function

46
00:01:31,860 --> 00:01:34,380
so namely once I chosen a commitment and

47
00:01:34,380 --> 00:01:36,180
a function there's only one possible

48
00:01:36,180 --> 00:01:38,040
value that you can open to you should

49
00:01:38,040 --> 00:01:39,659
not be able to find two possible values

50
00:01:39,659 --> 00:01:42,900
for the same commitment function pair we

51
00:01:42,900 --> 00:01:44,880
can also require hiding properties which

52
00:01:44,880 --> 00:01:46,439
says that the commitment and the opening

53
00:01:46,439 --> 00:01:48,960
actually hides all information about X

54
00:01:48,960 --> 00:01:50,759
other than what is revealed by f of x

55
00:01:50,759 --> 00:01:52,320
I'm not going to dwell too much on this

56
00:01:52,320 --> 00:01:53,579
in this talk

57
00:01:53,579 --> 00:01:55,979
the main requirement in terms of for a

58
00:01:55,979 --> 00:01:57,479
functional commitment though is the

59
00:01:57,479 --> 00:01:59,820
efficiency requirement in particular we

60
00:01:59,820 --> 00:02:01,979
require that both the commitment and the

61
00:02:01,979 --> 00:02:04,860
openings be short or succinct in

62
00:02:04,860 --> 00:02:06,540
particular what succinctness means in

63
00:02:06,540 --> 00:02:08,220
the context of the commitment is that

64
00:02:08,220 --> 00:02:09,959
the length of the commitment should be

65
00:02:09,959 --> 00:02:11,700
poly logarithmic in the length of the

66
00:02:11,700 --> 00:02:14,099
input the commitment must compress the

67
00:02:14,099 --> 00:02:15,540
input itself it can also depend

68
00:02:15,540 --> 00:02:17,520
polynomially on the security parameter

69
00:02:17,520 --> 00:02:18,959
Lambda

70
00:02:18,959 --> 00:02:21,060
similarly we require that the openings

71
00:02:21,060 --> 00:02:23,040
also be short namely they should also be

72
00:02:23,040 --> 00:02:24,660
poly logarithmic in the links of the

73
00:02:24,660 --> 00:02:26,879
input but we do allow them to scale with

74
00:02:26,879 --> 00:02:29,520
the lengths of the output

75
00:02:29,520 --> 00:02:31,319
so functional commitments are

76
00:02:31,319 --> 00:02:34,080
generalizations of Notions that you may

77
00:02:34,080 --> 00:02:35,940
have encountered such as Vector

78
00:02:35,940 --> 00:02:37,500
commitments and polynomial commitments

79
00:02:37,500 --> 00:02:38,879
these are Notions that have received

80
00:02:38,879 --> 00:02:40,560
extensive study due to their

81
00:02:40,560 --> 00:02:42,060
implications and applications to

82
00:02:42,060 --> 00:02:44,220
constructing succinct arguments so in a

83
00:02:44,220 --> 00:02:45,660
vector commitment is basically a

84
00:02:45,660 --> 00:02:47,280
functional commitment where you open to

85
00:02:47,280 --> 00:02:49,379
a specific index of a committed vector

86
00:02:49,379 --> 00:02:51,300
and a polynomial commitment corresponds

87
00:02:51,300 --> 00:02:53,099
to the special case where you commit to

88
00:02:53,099 --> 00:02:54,900
the coefficients of a polynomial and

89
00:02:54,900 --> 00:02:56,519
then open to the evaluation of the

90
00:02:56,519 --> 00:02:59,480
polynomial at a particular point

91
00:02:59,480 --> 00:03:01,560
functional commitments and specifically

92
00:03:01,560 --> 00:03:03,120
its specializations to Vector

93
00:03:03,120 --> 00:03:04,860
commitments and polynomial commitments

94
00:03:04,860 --> 00:03:06,660
have received extensive study over the

95
00:03:06,660 --> 00:03:08,580
years starting from merkel's classic

96
00:03:08,580 --> 00:03:10,379
construction of a vector commitment from

97
00:03:10,379 --> 00:03:12,300
Collision resistant hash functions there

98
00:03:12,300 --> 00:03:13,860
has since been a long line of

99
00:03:13,860 --> 00:03:16,760
construction studying new

100
00:03:16,760 --> 00:03:18,959
instantiations based on algebraic

101
00:03:18,959 --> 00:03:20,580
assumptions either parent-based

102
00:03:20,580 --> 00:03:22,140
assumptions group based assumptions

103
00:03:22,140 --> 00:03:24,659
factoring based assumptions and even

104
00:03:24,659 --> 00:03:27,540
lattice based assumptions recently

105
00:03:27,540 --> 00:03:30,300
if we consider the generalization to

106
00:03:30,300 --> 00:03:31,920
functional commitments for arbitrary

107
00:03:31,920 --> 00:03:33,420
functions so name the any function

108
00:03:33,420 --> 00:03:35,159
computable by let's say a Boolean

109
00:03:35,159 --> 00:03:37,980
circuit essentially the feasibility

110
00:03:37,980 --> 00:03:40,379
result follows from any Collision

111
00:03:40,379 --> 00:03:42,420
resistant hash function and a succinct

112
00:03:42,420 --> 00:03:45,000
non-interactive argument however if you

113
00:03:45,000 --> 00:03:47,040
look at this construction it leaves more

114
00:03:47,040 --> 00:03:49,019
to be desired namely the Reliance on

115
00:03:49,019 --> 00:03:50,580
succinct non-interactive arguments

116
00:03:50,580 --> 00:03:52,799
typically for MP typically brings in

117
00:03:52,799 --> 00:03:54,959
non-falsifiable assumptions and also

118
00:03:54,959 --> 00:03:56,819
relies on non-black box use of

119
00:03:56,819 --> 00:03:58,860
cryptography so a natural question that

120
00:03:58,860 --> 00:04:00,720
you might ask is can we construct

121
00:04:00,720 --> 00:04:02,940
functional commitments for broad classes

122
00:04:02,940 --> 00:04:04,739
of functionalities without bringing in

123
00:04:04,739 --> 00:04:06,599
non-blackbox use of crypto and without

124
00:04:06,599 --> 00:04:09,480
needing non-falsifiable assumptions

125
00:04:09,480 --> 00:04:11,159
there has been recently been several

126
00:04:11,159 --> 00:04:13,500
works that have any progress on this for

127
00:04:13,500 --> 00:04:15,360
the case of linear functions in a very

128
00:04:15,360 --> 00:04:17,339
nice construction from by outbreak datao

129
00:04:17,339 --> 00:04:19,199
from crypto last year for constant

130
00:04:19,199 --> 00:04:21,358
degree polynomials the latter

131
00:04:21,358 --> 00:04:23,639
construction relies on new assumption on

132
00:04:23,639 --> 00:04:25,919
ideal lattices but importantly this is a

133
00:04:25,919 --> 00:04:28,139
falsifiable assumption

134
00:04:28,139 --> 00:04:30,600
what we focused on in this work is a new

135
00:04:30,600 --> 00:04:32,160
framework for constructing functional

136
00:04:32,160 --> 00:04:33,720
commitments from lattice based

137
00:04:33,720 --> 00:04:36,000
assumptions and as a starting point we

138
00:04:36,000 --> 00:04:37,620
show a new Vector commitment scheme

139
00:04:37,620 --> 00:04:39,240
based on a standard short integer

140
00:04:39,240 --> 00:04:42,360
Solutions assumption and notably our

141
00:04:42,360 --> 00:04:44,040
construction has several appealing

142
00:04:44,040 --> 00:04:45,780
properties that essentially follows for

143
00:04:45,780 --> 00:04:48,240
free from our framework itself so for

144
00:04:48,240 --> 00:04:50,580
instance we get hiding properties we can

145
00:04:50,580 --> 00:04:52,199
commit to large values this will become

146
00:04:52,199 --> 00:04:53,940
more apparent later on and similar to

147
00:04:53,940 --> 00:04:56,340
previous Works our construction also is

148
00:04:56,340 --> 00:04:57,900
linearly homomorphic

149
00:04:57,900 --> 00:04:59,820
but I think what is more interesting is

150
00:04:59,820 --> 00:05:01,860
that our framework readily generalizes

151
00:05:01,860 --> 00:05:03,840
Beyond Vector commitments and actually

152
00:05:03,840 --> 00:05:05,639
gives us functional commitments for all

153
00:05:05,639 --> 00:05:08,160
bound adapts Boolean circuits here the

154
00:05:08,160 --> 00:05:10,560
price that we pay however is we rely on

155
00:05:10,560 --> 00:05:11,940
a new kind of assumption a new

156
00:05:11,940 --> 00:05:13,800
falsifiable assumption I view it as

157
00:05:13,800 --> 00:05:16,020
acute type generalization of this sis

158
00:05:16,020 --> 00:05:17,820
assumption that this is something that

159
00:05:17,820 --> 00:05:19,680
we call the structured basis assumption

160
00:05:19,680 --> 00:05:21,540
which I will introduce later on in this

161
00:05:21,540 --> 00:05:23,720
work in this talk

162
00:05:23,720 --> 00:05:25,979
finally I'll remark that the structured

163
00:05:25,979 --> 00:05:27,479
basis assumption that we rely on

164
00:05:27,479 --> 00:05:29,639
actually is less structured than a

165
00:05:29,639 --> 00:05:31,380
previous assumption by outbreak ductile

166
00:05:31,380 --> 00:05:32,699
used for constructing functional

167
00:05:32,699 --> 00:05:34,020
commitments for constant degree

168
00:05:34,020 --> 00:05:35,820
polynomials

169
00:05:35,820 --> 00:05:37,620
I also mentioned that this is an area

170
00:05:37,620 --> 00:05:39,419
that has received a lot of growing

171
00:05:39,419 --> 00:05:40,979
interest in recent times and there are

172
00:05:40,979 --> 00:05:42,720
actually two concurrent works that I

173
00:05:42,720 --> 00:05:44,520
want to call out who also give lattice

174
00:05:44,520 --> 00:05:46,380
based functional commitments for Boolean

175
00:05:46,380 --> 00:05:49,560
circuits so a very nice construction by

176
00:05:49,560 --> 00:05:52,560
Babas Catalano Fiore and Lai show how to

177
00:05:52,560 --> 00:05:54,479
construct both pairing based and lattice

178
00:05:54,479 --> 00:05:55,979
based functional commitments for about

179
00:05:55,979 --> 00:05:58,740
for Boolean circuits which achieve short

180
00:05:58,740 --> 00:06:00,660
openings and also supports fast

181
00:06:00,660 --> 00:06:02,699
verification in a pre-processing model

182
00:06:02,699 --> 00:06:04,560
there are constructions at least in the

183
00:06:04,560 --> 00:06:06,060
lattice setting rely on a new

184
00:06:06,060 --> 00:06:08,280
falsifiable assumption on module

185
00:06:08,280 --> 00:06:10,620
lattices earlier in this conference we

186
00:06:10,620 --> 00:06:12,600
saw the work of de Castro and pikert who

187
00:06:12,600 --> 00:06:13,860
show how to construct a functional

188
00:06:13,860 --> 00:06:15,780
commitment for all circuits that has a

189
00:06:15,780 --> 00:06:18,419
transparent setup so a public coin setup

190
00:06:18,419 --> 00:06:20,400
and only relies on standard assumptions

191
00:06:20,400 --> 00:06:22,080
namely the short integer Solutions

192
00:06:22,080 --> 00:06:25,199
assumption the drawback of their work is

193
00:06:25,199 --> 00:06:27,180
that the openings are not succinct they

194
00:06:27,180 --> 00:06:28,680
do not satisfy the succinct opening

195
00:06:28,680 --> 00:06:31,380
property I defined earlier in this talk

196
00:06:31,380 --> 00:06:34,139
okay all right so what I want to focus

197
00:06:34,139 --> 00:06:37,020
on though today is introducing our

198
00:06:37,020 --> 00:06:39,060
framework for constructing lattice based

199
00:06:39,060 --> 00:06:40,440
functional commitments so I'll start

200
00:06:40,440 --> 00:06:41,699
with a framework that shows how to get

201
00:06:41,699 --> 00:06:43,199
Vector commitments and then how to

202
00:06:43,199 --> 00:06:44,940
extend it directly to get to functional

203
00:06:44,940 --> 00:06:47,220
commitments one nice property of our

204
00:06:47,220 --> 00:06:48,660
framework is it captures and also

205
00:06:48,660 --> 00:06:50,699
generalizes previous lattice based

206
00:06:50,699 --> 00:06:52,680
functional commitment schemes so what do

207
00:06:52,680 --> 00:06:54,180
these existing lattice based functional

208
00:06:54,180 --> 00:06:56,100
commitment schemes look like suppose I

209
00:06:56,100 --> 00:06:58,560
want to commit to an input of length l

210
00:06:58,560 --> 00:07:00,600
uh and you can think about these inputs

211
00:07:00,600 --> 00:07:02,460
as binary valued or they can be taken

212
00:07:02,460 --> 00:07:03,900
from a small field

213
00:07:03,900 --> 00:07:05,639
so the common reference string in all of

214
00:07:05,639 --> 00:07:07,319
these constructions is going to consist

215
00:07:07,319 --> 00:07:09,240
of a sequence of L matrices one

216
00:07:09,240 --> 00:07:11,699
associated with each bit of the input as

217
00:07:11,699 --> 00:07:13,740
well as L Target vectors again one

218
00:07:13,740 --> 00:07:15,539
associated with each bit of the input

219
00:07:15,539 --> 00:07:17,940
for the description here do not we don't

220
00:07:17,940 --> 00:07:19,380
need to worry about the distribution of

221
00:07:19,380 --> 00:07:21,660
these matrices or vectors this is just

222
00:07:21,660 --> 00:07:24,120
the structure that we care about

223
00:07:24,120 --> 00:07:25,919
the important component is this

224
00:07:25,919 --> 00:07:28,740
auxiliary data and the Zuri data is

225
00:07:28,740 --> 00:07:31,500
essentially a way to recode the ith

226
00:07:31,500 --> 00:07:34,020
Matrix to the JS Target Vector so in

227
00:07:34,020 --> 00:07:35,759
particular I'm going to give out short

228
00:07:35,759 --> 00:07:39,180
vectors uij that takes AI times uij is

229
00:07:39,180 --> 00:07:41,759
equal to TJ so it's a way to map sends

230
00:07:41,759 --> 00:07:43,500
something from the ith component onto

231
00:07:43,500 --> 00:07:45,300
the vector associated with the jth

232
00:07:45,300 --> 00:07:47,160
component and critically for these

233
00:07:47,160 --> 00:07:48,960
constructions I'm only going to give out

234
00:07:48,960 --> 00:07:51,240
these components for I not equal J so

235
00:07:51,240 --> 00:07:52,680
essentially you can view them as cross

236
00:07:52,680 --> 00:07:55,319
terms if you will

237
00:07:55,319 --> 00:07:57,240
so once I have this common reference

238
00:07:57,240 --> 00:07:58,979
string what is the structure of a

239
00:07:58,979 --> 00:08:00,900
commitment it's simply a linear

240
00:08:00,900 --> 00:08:03,300
combination of the target vectors I take

241
00:08:03,300 --> 00:08:04,800
a linear combination where the

242
00:08:04,800 --> 00:08:07,740
coefficients correspond to my input

243
00:08:07,740 --> 00:08:10,860
to open to a particular value Y at a

244
00:08:10,860 --> 00:08:12,419
particular index I so again I'm only

245
00:08:12,419 --> 00:08:13,979
talking about Vector commitments so I'm

246
00:08:13,979 --> 00:08:15,599
only interested in opening at a

247
00:08:15,599 --> 00:08:17,940
particular index what I do is I give you

248
00:08:17,940 --> 00:08:20,639
a short VI such that the commitment

249
00:08:20,639 --> 00:08:23,099
satisfies this verification invariant is

250
00:08:23,099 --> 00:08:24,780
the proported value times the I Target

251
00:08:24,780 --> 00:08:28,879
plus the ith Matrix times the opening so

252
00:08:28,879 --> 00:08:32,219
the which Target and which Matrix I use

253
00:08:32,219 --> 00:08:34,080
depends on the index that I am opening

254
00:08:34,080 --> 00:08:35,219
to

255
00:08:35,219 --> 00:08:37,020
so the question then is how do you

256
00:08:37,020 --> 00:08:39,539
construct such an opening here you are

257
00:08:39,539 --> 00:08:41,880
going to use this auxiliary data the

258
00:08:41,880 --> 00:08:44,039
opening to a particular index is going

259
00:08:44,039 --> 00:08:46,320
to be a linear combination of the

260
00:08:46,320 --> 00:08:49,740
recoding vectors uij basically I'm going

261
00:08:49,740 --> 00:08:51,540
to take a linear combination that allows

262
00:08:51,540 --> 00:08:54,480
me to recode AI to all of the tjs for

263
00:08:54,480 --> 00:08:56,279
the odd other components in my

264
00:08:56,279 --> 00:08:58,620
commitment so to verify that this is

265
00:08:58,620 --> 00:09:00,180
actually correct we can start with the

266
00:09:00,180 --> 00:09:01,920
main commitment relation which is the

267
00:09:01,920 --> 00:09:05,459
sum of the X itis for all I we have one

268
00:09:05,459 --> 00:09:07,380
component which is the component that I

269
00:09:07,380 --> 00:09:09,060
open into and then I have a bunch of

270
00:09:09,060 --> 00:09:11,279
these cross terms which are the form x i

271
00:09:11,279 --> 00:09:14,160
x j times TJ and I want to get this into

272
00:09:14,160 --> 00:09:15,839
the form of a i times something short

273
00:09:15,839 --> 00:09:18,240
well how do I do that that's exactly

274
00:09:18,240 --> 00:09:20,940
using the recoding components I'm giving

275
00:09:20,940 --> 00:09:22,980
out in a CRS

276
00:09:22,980 --> 00:09:25,380
uh so if this relation will hold as long

277
00:09:25,380 --> 00:09:27,779
as the input X is short

278
00:09:27,779 --> 00:09:30,000
so in previous instantiations uh the

279
00:09:30,000 --> 00:09:31,860
construction of Pi card paper and sharp

280
00:09:31,860 --> 00:09:34,080
uh consider Matrix B setting where the

281
00:09:34,080 --> 00:09:35,820
matrices a and the target vectors are

282
00:09:35,820 --> 00:09:37,680
uniformly random it turns out that this

283
00:09:37,680 --> 00:09:39,240
suffices to give you a vector commitment

284
00:09:39,240 --> 00:09:40,920
from the standard short integer

285
00:09:40,920 --> 00:09:43,080
Solutions assumption the outbreak

286
00:09:43,080 --> 00:09:44,640
detailed construction from crypto last

287
00:09:44,640 --> 00:09:46,620
year considered an instantiation where

288
00:09:46,620 --> 00:09:47,940
the Matrix and the targets are

289
00:09:47,940 --> 00:09:49,560
structured and this turns out to be

290
00:09:49,560 --> 00:09:50,940
sufficient to give a functional

291
00:09:50,940 --> 00:09:53,279
commitment that allows you to open to

292
00:09:53,279 --> 00:09:55,080
arbitrary constant degree polynomials

293
00:09:55,080 --> 00:09:58,800
based on an Ideal lattice assumption

294
00:09:58,800 --> 00:10:00,720
now let me tell you about our approach

295
00:10:00,720 --> 00:10:02,820
our approach actually starts at the very

296
00:10:02,820 --> 00:10:05,459
end of the previous description I'm

297
00:10:05,459 --> 00:10:07,200
going to instead take a look at the

298
00:10:07,200 --> 00:10:08,940
verification and variant the

299
00:10:08,940 --> 00:10:10,800
verification invariant allows says that

300
00:10:10,800 --> 00:10:13,140
for each index I this relation here

301
00:10:13,140 --> 00:10:15,180
should hold right the commitment is

302
00:10:15,180 --> 00:10:17,700
equal to AI times the opening VI plus x

303
00:10:17,700 --> 00:10:19,980
i times TI and this should hold for all

304
00:10:19,980 --> 00:10:23,940
of the indices in my vector so what I

305
00:10:23,940 --> 00:10:25,500
can do is I can rewrite these L

306
00:10:25,500 --> 00:10:27,480
equations as actually a single linear

307
00:10:27,480 --> 00:10:29,339
system where each row basically

308
00:10:29,339 --> 00:10:31,440
corresponds to one of these invariants

309
00:10:31,440 --> 00:10:33,500
Row one corresponds to opening for

310
00:10:33,500 --> 00:10:35,760
component one Row 2 corresponds to

311
00:10:35,760 --> 00:10:38,399
opening to component two and so on so

312
00:10:38,399 --> 00:10:40,500
why is this useful

313
00:10:40,500 --> 00:10:43,080
so before I need to do before I tell you

314
00:10:43,080 --> 00:10:44,279
why it's useful I need to do one more

315
00:10:44,279 --> 00:10:47,220
thing I need to rewrite the commitment C

316
00:10:47,220 --> 00:10:49,019
I'm going to actually decompose it into

317
00:10:49,019 --> 00:10:50,880
the gadget this is powers of two Matrix

318
00:10:50,880 --> 00:10:53,040
multiplied by the binary decomposition

319
00:10:53,040 --> 00:10:54,420
of C hat I'm just going to make a

320
00:10:54,420 --> 00:10:56,760
substitution I'm going to write c as G

321
00:10:56,760 --> 00:10:59,279
times C hat where G is a this gadget

322
00:10:59,279 --> 00:11:01,320
Matrix here and C hat is just a binary

323
00:11:01,320 --> 00:11:03,240
decomposition of what used to be my

324
00:11:03,240 --> 00:11:04,860
commitment so again I have done nothing

325
00:11:04,860 --> 00:11:06,660
fancy I've just Rewritten this linear

326
00:11:06,660 --> 00:11:09,480
relation I have a new linear system that

327
00:11:09,480 --> 00:11:11,940
describes what the commitment and all of

328
00:11:11,940 --> 00:11:14,160
the openings should satisfy

329
00:11:14,160 --> 00:11:15,420
so if we look at these previous

330
00:11:15,420 --> 00:11:17,880
constructions uh functional commitments

331
00:11:17,880 --> 00:11:19,860
basically what is given out are the

332
00:11:19,860 --> 00:11:22,079
matrices A1 up to a l and as well as

333
00:11:22,079 --> 00:11:24,540
these Target vectors T1 up to TL and

334
00:11:24,540 --> 00:11:26,339
then there's these cross terms auxiliary

335
00:11:26,339 --> 00:11:28,440
components this is where our framework

336
00:11:28,440 --> 00:11:31,440
differs from those of Prior work instead

337
00:11:31,440 --> 00:11:33,420
of giving you these auxiliary data we're

338
00:11:33,420 --> 00:11:35,160
going to actually replace it by giving

339
00:11:35,160 --> 00:11:37,620
out a full trapdoor for the Matrix B sub

340
00:11:37,620 --> 00:11:39,300
l so the Matrix defined on the right

341
00:11:39,300 --> 00:11:41,459
here what I mean when I say a full trap

342
00:11:41,459 --> 00:11:44,100
door I mean an algorithm a trapdoor that

343
00:11:44,100 --> 00:11:46,260
allows for an efficient algorithm to

344
00:11:46,260 --> 00:11:48,420
actually sample short solutions to a

345
00:11:48,420 --> 00:11:51,720
linear system defined by BL in

346
00:11:51,720 --> 00:11:53,220
particular what that means is for any

347
00:11:53,220 --> 00:11:55,140
Target for any Target Vector on the

348
00:11:55,140 --> 00:11:57,000
right here I can actually sample a short

349
00:11:57,000 --> 00:11:59,519
solution V1 of the VL and C hat that

350
00:11:59,519 --> 00:12:01,800
satisfies this linear system

351
00:12:01,800 --> 00:12:04,320
so what that means is now to commit to

352
00:12:04,320 --> 00:12:06,420
an input X I'm not going to use the

353
00:12:06,420 --> 00:12:08,339
deterministic algorithm of taking linear

354
00:12:08,339 --> 00:12:10,560
combinations as before I'm simply going

355
00:12:10,560 --> 00:12:12,779
to sample a solution to the linear

356
00:12:12,779 --> 00:12:14,579
system so instead of constructing the

357
00:12:14,579 --> 00:12:15,720
commitment and the openings

358
00:12:15,720 --> 00:12:17,880
independently now I'm going to do a

359
00:12:17,880 --> 00:12:20,700
joint sampling and compute them together

360
00:12:20,700 --> 00:12:23,160
so I'm going to specify the targets and

361
00:12:23,160 --> 00:12:24,899
then I'll use my trapdoor to jointly

362
00:12:24,899 --> 00:12:27,720
sample a V1 up to VL and a c hat that's

363
00:12:27,720 --> 00:12:30,120
simultaneously satisfies all of these

364
00:12:30,120 --> 00:12:32,880
verification and variants finally once I

365
00:12:32,880 --> 00:12:34,440
get the C hat I'll just use my

366
00:12:34,440 --> 00:12:36,180
substitution that c is equal to G times

367
00:12:36,180 --> 00:12:39,300
C hat that would be my new commitment

368
00:12:39,300 --> 00:12:41,100
so the advantage of this approach is

369
00:12:41,100 --> 00:12:42,899
twofold so the first thing that you

370
00:12:42,899 --> 00:12:44,940
might observe is that nowhere do we now

371
00:12:44,940 --> 00:12:47,220
require that the axis be small we're not

372
00:12:47,220 --> 00:12:48,720
taking linear combinations of Target

373
00:12:48,720 --> 00:12:51,959
vectors or matrices anymore or or linear

374
00:12:51,959 --> 00:12:53,760
combinations of short vectors we're just

375
00:12:53,760 --> 00:12:54,959
doing pre-image sampling and we can

376
00:12:54,959 --> 00:12:56,459
Target whatever we want on the right

377
00:12:56,459 --> 00:12:58,079
hand side so it doesn't matter the x is

378
00:12:58,079 --> 00:12:59,820
small we can commit to X is being large

379
00:12:59,820 --> 00:13:01,740
doesn't affect anything

380
00:13:01,740 --> 00:13:04,079
the second property is that we achieve

381
00:13:04,079 --> 00:13:06,000
basically for free is because we're

382
00:13:06,000 --> 00:13:07,800
jointly sampling the openings and the

383
00:13:07,800 --> 00:13:09,660
commitments together we can directly

384
00:13:09,660 --> 00:13:11,100
analyze and characterize the

385
00:13:11,100 --> 00:13:13,260
distribution of these three images and

386
00:13:13,260 --> 00:13:15,779
in fact you can actually show that these

387
00:13:15,779 --> 00:13:17,820
pre-images actually statistically hide

388
00:13:17,820 --> 00:13:20,160
the unopened values so we get hiding

389
00:13:20,160 --> 00:13:22,860
also for free as a corollary of our

390
00:13:22,860 --> 00:13:24,480
framework

391
00:13:24,480 --> 00:13:26,399
so the only remaining item I need to

392
00:13:26,399 --> 00:13:28,500
describe now is how do we argue that the

393
00:13:28,500 --> 00:13:31,079
scheme satisfies binding basically we

394
00:13:31,079 --> 00:13:33,120
want to show that an app well I guess I

395
00:13:33,120 --> 00:13:35,100
won't have time to show it here but what

396
00:13:35,100 --> 00:13:37,500
we can show I will argue is that an

397
00:13:37,500 --> 00:13:38,760
adversary that breaks The Binding

398
00:13:38,760 --> 00:13:40,440
property can actually solve the short

399
00:13:40,440 --> 00:13:42,420
integer Solutions problem with respect

400
00:13:42,420 --> 00:13:44,639
to one of these matrices a sub I so the

401
00:13:44,639 --> 00:13:46,079
short integer Solutions if you haven't

402
00:13:46,079 --> 00:13:47,940
encountered it before just as given a

403
00:13:47,940 --> 00:13:50,220
random Matrix a that's very wide find a

404
00:13:50,220 --> 00:13:52,079
short non-zero solution in the kernel of

405
00:13:52,079 --> 00:13:53,940
a

406
00:13:53,940 --> 00:13:55,500
so here what we're going to do is we're

407
00:13:55,500 --> 00:13:57,180
going to formulate our first state an

408
00:13:57,180 --> 00:13:58,860
assumption which we call the basis

409
00:13:58,860 --> 00:14:01,260
augmented CIS assumption or basic basis

410
00:14:01,260 --> 00:14:03,300
assumption for short which essentially

411
00:14:03,300 --> 00:14:05,760
asserts that the sis problem is hard

412
00:14:05,760 --> 00:14:08,399
with respect to a sub I even if I give

413
00:14:08,399 --> 00:14:10,680
you a trapdoor for this related Matrix B

414
00:14:10,680 --> 00:14:13,079
sub l so notice that if I assume that

415
00:14:13,079 --> 00:14:14,700
this assumption holds then the security

416
00:14:14,700 --> 00:14:16,139
of our construction basically follows

417
00:14:16,139 --> 00:14:18,839
for free because I can because an

418
00:14:18,839 --> 00:14:20,459
adversary that breaks binding solves CIS

419
00:14:20,459 --> 00:14:22,320
with respect to a sub I given the

420
00:14:22,320 --> 00:14:24,120
trapdoor information that I put in the

421
00:14:24,120 --> 00:14:27,660
CRS so at this point it looks like that

422
00:14:27,660 --> 00:14:29,279
we have basically stated an assumption

423
00:14:29,279 --> 00:14:31,320
that just allows our theme to be secure

424
00:14:31,320 --> 00:14:34,079
this is not super interesting it turns

425
00:14:34,079 --> 00:14:36,660
out though that when the matrices A1 or

426
00:14:36,660 --> 00:14:38,339
the AL are actually sampled in the

427
00:14:38,339 --> 00:14:39,899
uniformly and independently of each

428
00:14:39,899 --> 00:14:42,300
other the basis assumption for this for

429
00:14:42,300 --> 00:14:44,279
this particular configuration actually

430
00:14:44,279 --> 00:14:47,040
follows from the standard sis assumption

431
00:14:47,040 --> 00:14:49,440
this actually follows by standard Gladys

432
00:14:49,440 --> 00:14:51,000
trapdoor extension techniques which I

433
00:14:51,000 --> 00:14:52,800
won't have time to go into here but

434
00:14:52,800 --> 00:14:54,420
essentially there's a way to simulate

435
00:14:54,420 --> 00:14:56,279
the trapdoor for B sub L if you know the

436
00:14:56,279 --> 00:14:57,660
trapdoors for all but one of the

437
00:14:57,660 --> 00:14:59,519
components and the public trapdoor for

438
00:14:59,519 --> 00:15:01,620
the gadget Matrix

439
00:15:01,620 --> 00:15:04,500
so to summarize using our new framework

440
00:15:04,500 --> 00:15:06,420
we directly get Vector commitments that

441
00:15:06,420 --> 00:15:08,339
support committing to large values we

442
00:15:08,339 --> 00:15:10,800
get private openings for free and

443
00:15:10,800 --> 00:15:12,600
everything still follows from the

444
00:15:12,600 --> 00:15:15,540
standard sis assumption because the

445
00:15:15,540 --> 00:15:17,399
basis assumption we need here actually

446
00:15:17,399 --> 00:15:20,820
can be reduced to hard to Sis directly

447
00:15:20,820 --> 00:15:22,500
but the more interesting bit is how do

448
00:15:22,500 --> 00:15:24,180
we take this framework that I described

449
00:15:24,180 --> 00:15:25,800
and actually generalize it to get

450
00:15:25,800 --> 00:15:27,360
general purpose functional commitments

451
00:15:27,360 --> 00:15:29,100
not just opening to a single component

452
00:15:29,100 --> 00:15:31,079
now but opening to an arbitrary function

453
00:15:31,079 --> 00:15:33,300
evaluated on the input itself

454
00:15:33,300 --> 00:15:35,699
so let's take a look the starting point

455
00:15:35,699 --> 00:15:36,779
here will be the lattice space

456
00:15:36,779 --> 00:15:39,360
homomorphic commitment fry gorbanovic

457
00:15:39,360 --> 00:15:41,279
nothing in weeks so let me briefly

458
00:15:41,279 --> 00:15:43,260
remind you how that goes

459
00:15:43,260 --> 00:15:45,360
uh the construction here will take in a

460
00:15:45,360 --> 00:15:47,940
random Matrix an arbitrary Matrix a uh

461
00:15:47,940 --> 00:15:49,380
usually very wide

462
00:15:49,380 --> 00:15:51,660
and the commitment in a gorbanov I

463
00:15:51,660 --> 00:15:53,459
couldn't nothing Wix or GVW construction

464
00:15:53,459 --> 00:15:55,620
has the following structure we're going

465
00:15:55,620 --> 00:15:57,300
to commit to each bit of X individually

466
00:15:57,300 --> 00:15:59,579
and the invariant or the verification

467
00:15:59,579 --> 00:16:02,579
relation is that I'm going to take x i

468
00:16:02,579 --> 00:16:04,380
times G and I'm going to add to it a

469
00:16:04,380 --> 00:16:06,480
times v i so CI here will be a

470
00:16:06,480 --> 00:16:09,240
commitment to the bit x i and now using

471
00:16:09,240 --> 00:16:10,680
the magic of lattice homomorphic

472
00:16:10,680 --> 00:16:12,959
evaluation developed by Gentry so high

473
00:16:12,959 --> 00:16:15,240
in water sample meatel we can actually

474
00:16:15,240 --> 00:16:17,880
take the commitments to the bits of X

475
00:16:17,880 --> 00:16:20,160
and derive from it a commitment to f of

476
00:16:20,160 --> 00:16:21,779
x I'm not going to go into details of

477
00:16:21,779 --> 00:16:23,339
how this is done this is just the

478
00:16:23,339 --> 00:16:26,279
standard fhe Machinery that has been

479
00:16:26,279 --> 00:16:27,839
characteristic of many lattice based

480
00:16:27,839 --> 00:16:30,000
constructions but the takeaway is if I

481
00:16:30,000 --> 00:16:32,459
give you the commitments to X that

482
00:16:32,459 --> 00:16:34,440
satisfy this relation I can derive from

483
00:16:34,440 --> 00:16:37,259
it a commitment to f x

484
00:16:37,259 --> 00:16:40,139
so in a GVW construction the commitments

485
00:16:40,139 --> 00:16:42,180
themselves are actually not short namely

486
00:16:42,180 --> 00:16:44,720
I have one commitment for every bit of X

487
00:16:44,720 --> 00:16:46,800
and the commitments are basically

488
00:16:46,800 --> 00:16:49,500
independent and as such this is not

489
00:16:49,500 --> 00:16:51,720
quite a functional commitment so how do

490
00:16:51,720 --> 00:16:53,820
we get to a succinct commitment so the

491
00:16:53,820 --> 00:16:56,459
approach that we take in our work

492
00:16:56,459 --> 00:16:58,560
is we're going to compress all of these

493
00:16:58,560 --> 00:17:00,959
GVW commitments into a single Matrix

494
00:17:00,959 --> 00:17:03,180
c-hat the way that we're going to do

495
00:17:03,180 --> 00:17:05,880
that is we're going to just Define CI to

496
00:17:05,880 --> 00:17:09,359
be a simple relation on the C hats so

497
00:17:09,359 --> 00:17:11,459
namely it'll be w i inverse times G

498
00:17:11,459 --> 00:17:14,099
times C hat where the WIS are now part

499
00:17:14,099 --> 00:17:16,439
of the common reference string so why we

500
00:17:16,439 --> 00:17:18,000
do this will hopefully become clear very

501
00:17:18,000 --> 00:17:18,900
shortly

502
00:17:18,900 --> 00:17:20,339
so we're going to choose the commitment

503
00:17:20,339 --> 00:17:23,160
to BC hat which sets CI to be W inverse

504
00:17:23,160 --> 00:17:25,500
times G times C hat so let's just make

505
00:17:25,500 --> 00:17:27,720
the substitution to our main GVW

506
00:17:27,720 --> 00:17:30,000
homomorphic commitment all I've done is

507
00:17:30,000 --> 00:17:32,700
I substituted for the CIS and now I'm

508
00:17:32,700 --> 00:17:34,140
going to multiply both sides of these

509
00:17:34,140 --> 00:17:37,140
relations by wi so the wi inverses go

510
00:17:37,140 --> 00:17:39,419
cancel out and I end up with a linear

511
00:17:39,419 --> 00:17:41,580
system and this linear system if you

512
00:17:41,580 --> 00:17:43,679
stare at it looks remarkably similar to

513
00:17:43,679 --> 00:17:45,480
the linear system I wrote down for the

514
00:17:45,480 --> 00:17:47,760
vector commitment scheme except that

515
00:17:47,760 --> 00:17:50,039
matrices A1 of the AL are now not

516
00:17:50,039 --> 00:17:51,840
uniform random matrices they're now

517
00:17:51,840 --> 00:17:53,220
structured matrices

518
00:17:53,220 --> 00:17:54,900
so what do we do to construct a

519
00:17:54,900 --> 00:17:56,940
functional commitment we're going to do

520
00:17:56,940 --> 00:17:58,620
exactly as we did for our Vector

521
00:17:58,620 --> 00:18:00,240
commitments we're going to give out a

522
00:18:00,240 --> 00:18:02,820
trapdoor for the Matrix B sub L and

523
00:18:02,820 --> 00:18:06,179
publish that as part of the CRS now to

524
00:18:06,179 --> 00:18:08,220
commit you basically form the Target on

525
00:18:08,220 --> 00:18:10,200
the right use your trapdoor to jointly

526
00:18:10,200 --> 00:18:12,240
sample the openings and the commitment

527
00:18:12,240 --> 00:18:16,260
and now you have a jvw commitment to X

528
00:18:16,260 --> 00:18:18,660
and you can do homomorphic computation

529
00:18:18,660 --> 00:18:21,360
and openings exactly as before

530
00:18:21,360 --> 00:18:23,100
the security of this assumption now

531
00:18:23,100 --> 00:18:25,140
follows from the basis assumption except

532
00:18:25,140 --> 00:18:27,000
we have a structured Matrix rather than

533
00:18:27,000 --> 00:18:28,799
a random Matrix so this is a new

534
00:18:28,799 --> 00:18:30,360
assumption that we introduce in this

535
00:18:30,360 --> 00:18:32,700
work that sis is hard with respect to

536
00:18:32,700 --> 00:18:34,440
the Matrix a even if I give you a

537
00:18:34,440 --> 00:18:37,260
trapdoor for this related Matrix BL this

538
00:18:37,260 --> 00:18:39,059
is a new falsifiable assumption I view

539
00:18:39,059 --> 00:18:41,460
it as a q type generalization of the

540
00:18:41,460 --> 00:18:43,799
standard sis assumption as far as we

541
00:18:43,799 --> 00:18:46,020
know we this does not reduce the sis and

542
00:18:46,020 --> 00:18:47,820
this is a fascinating open question to

543
00:18:47,820 --> 00:18:49,200
try and understand whether this

544
00:18:49,200 --> 00:18:51,059
assumption holds under the standard sis

545
00:18:51,059 --> 00:18:52,919
assumption now note that the trivial

546
00:18:52,919 --> 00:18:55,080
case of L equals 1 does hold under sis

547
00:18:55,080 --> 00:18:57,600
but for more than for L bigger than one

548
00:18:57,600 --> 00:18:59,580
we don't know

549
00:18:59,580 --> 00:19:01,200
so there are several extensions that I

550
00:19:01,200 --> 00:19:03,360
won't have time to go into but basically

551
00:19:03,360 --> 00:19:04,679
our functional commitment has several

552
00:19:04,679 --> 00:19:06,000
appealing properties due to its

553
00:19:06,000 --> 00:19:08,160
algebraic structure for instance for

554
00:19:08,160 --> 00:19:09,660
linear functions you can actually

555
00:19:09,660 --> 00:19:12,419
support fast verification or pre-process

556
00:19:12,419 --> 00:19:14,760
verification and we can also aggregate

557
00:19:14,760 --> 00:19:16,740
so you can have commitments and openings

558
00:19:16,740 --> 00:19:18,539
to many different functions you can

559
00:19:18,539 --> 00:19:20,160
actually aggregate them into a single

560
00:19:20,160 --> 00:19:21,960
short commitment again this relies on

561
00:19:21,960 --> 00:19:23,280
the algebraic structure of our

562
00:19:23,280 --> 00:19:24,360
Construction

563
00:19:24,360 --> 00:19:26,760
so to summarize in this talk I presented

564
00:19:26,760 --> 00:19:28,620
a new methodology for building ladder

565
00:19:28,620 --> 00:19:30,660
space commitments essentially the

566
00:19:30,660 --> 00:19:32,460
framework that we Define is we start

567
00:19:32,460 --> 00:19:33,960
with the main verification relation

568
00:19:33,960 --> 00:19:36,120
write down the linear system and then

569
00:19:36,120 --> 00:19:38,340
publish a trapdoor defined by this

570
00:19:38,340 --> 00:19:39,539
linear system

571
00:19:39,539 --> 00:19:41,940
the security analysis in turn will rely

572
00:19:41,940 --> 00:19:43,919
on the hardness of the short integer

573
00:19:43,919 --> 00:19:45,840
Solutions problem even given this

574
00:19:45,840 --> 00:19:48,900
related trapdoor in some cases this this

575
00:19:48,900 --> 00:19:50,940
variant of the Assumption can be based

576
00:19:50,940 --> 00:19:52,980
on a standard sis assumption in other

577
00:19:52,980 --> 00:19:55,919
cases it doesn't but it gives us much

578
00:19:55,919 --> 00:19:58,440
stronger functionality namely functional

579
00:19:58,440 --> 00:20:01,080
commitments for General functions so I

580
00:20:01,080 --> 00:20:02,460
think I've ran out of time so let me

581
00:20:02,460 --> 00:20:04,440
just list a bunch of open questions so

582
00:20:04,440 --> 00:20:05,880
part of it is analyzing the basis

583
00:20:05,880 --> 00:20:07,980
assumptions formulating stronger

584
00:20:07,980 --> 00:20:09,360
versions of the assumptions that allow

585
00:20:09,360 --> 00:20:11,340
us to get better security or stronger

586
00:20:11,340 --> 00:20:14,580
properties can we get schemes with

587
00:20:14,580 --> 00:20:16,620
shorter CRS can we get schemes for

588
00:20:16,620 --> 00:20:18,780
opening to many different components of

589
00:20:18,780 --> 00:20:20,460
a vector with strong binding properties

590
00:20:20,460 --> 00:20:22,320
and with that I'll conclude thank you

591
00:20:22,320 --> 00:20:24,620
very much

592
00:20:30,419 --> 00:20:31,980
thank you very much for the great talk

593
00:20:31,980 --> 00:20:33,960
since there's only two talks in this

594
00:20:33,960 --> 00:20:35,280
session I think we can afford some

595
00:20:35,280 --> 00:20:38,299
questions if there are

596
00:20:42,419 --> 00:20:44,940
hello thank you for the very nice talk I

597
00:20:44,940 --> 00:20:47,400
see that uh one of the open question is

598
00:20:47,400 --> 00:20:49,380
actually one of the questions that I

599
00:20:49,380 --> 00:20:50,940
wanted to ask about subversial

600
00:20:50,940 --> 00:20:52,860
commitments

601
00:20:52,860 --> 00:20:55,559
um so if your functional commitments is

602
00:20:55,559 --> 00:20:58,620
like general purpose for a bound to

603
00:20:58,620 --> 00:21:00,600
death uh circuits

604
00:21:00,600 --> 00:21:03,299
could it be like applied to directly

605
00:21:03,299 --> 00:21:05,940
have sub Vector commitments uh based on

606
00:21:05,940 --> 00:21:09,059
this Basics this structured basis

607
00:21:09,059 --> 00:21:11,460
assumption or yeah that's a great

608
00:21:11,460 --> 00:21:14,280
question so the issue it actually comes

609
00:21:14,280 --> 00:21:15,660
up in a definition of security for

610
00:21:15,660 --> 00:21:17,400
subvector commitments so in subvector

611
00:21:17,400 --> 00:21:19,080
commitments there's actually a

612
00:21:19,080 --> 00:21:21,059
consistency requirement so for instance

613
00:21:21,059 --> 00:21:22,919
let's say I'm opening to two different

614
00:21:22,919 --> 00:21:25,500
subsets that both have an it that have a

615
00:21:25,500 --> 00:21:27,480
non-empty intersection it should be the

616
00:21:27,480 --> 00:21:29,100
case that the value for that those

617
00:21:29,100 --> 00:21:30,539
elements in the intersection are

618
00:21:30,539 --> 00:21:32,159
actually consistent in the two openings

619
00:21:32,159 --> 00:21:34,260
notice that for The Binding property for

620
00:21:34,260 --> 00:21:35,940
functional commitments just says that

621
00:21:35,940 --> 00:21:37,559
for each function there's only one value

622
00:21:37,559 --> 00:21:39,659
I can associate it with it but those

623
00:21:39,659 --> 00:21:41,340
values do not have to be consistent so

624
00:21:41,340 --> 00:21:42,659
because we don't have this consistency

625
00:21:42,659 --> 00:21:44,640
property the current functional

626
00:21:44,640 --> 00:21:46,799
commitments we have do not imply the

627
00:21:46,799 --> 00:21:47,880
stronger notion of sub Vector

628
00:21:47,880 --> 00:21:48,960
commitments at least as far as

629
00:21:48,960 --> 00:21:52,380
consistency is concerned I see thank you

630
00:21:52,380 --> 00:21:54,600
are there any other questions

631
00:21:54,600 --> 00:21:56,400
um yes I have a related questions I

632
00:21:56,400 --> 00:21:58,440
wanted to ask if you consider this

633
00:21:58,440 --> 00:22:01,080
stronger functional binding nobody what

634
00:22:01,080 --> 00:22:03,360
are the challenges and why you cannot

635
00:22:03,360 --> 00:22:05,280
achieve it right yeah that's also a

636
00:22:05,280 --> 00:22:06,659
great question so this goes down to the

637
00:22:06,659 --> 00:22:08,700
second open question I wrote down on a

638
00:22:08,700 --> 00:22:10,679
slide which is if you want a stronger

639
00:22:10,679 --> 00:22:13,200
version of binding which I usually refer

640
00:22:13,200 --> 00:22:15,200
to as soundness or knowledge extraction

641
00:22:15,200 --> 00:22:17,580
basically that would actually give you a

642
00:22:17,580 --> 00:22:19,380
snark so we would not be able to build

643
00:22:19,380 --> 00:22:21,120
it from falsifiable assumptions in light

644
00:22:21,120 --> 00:22:24,600
of the Gentry Wix separation but uh one

645
00:22:24,600 --> 00:22:26,700
thing that you can potentially do is you

646
00:22:26,700 --> 00:22:28,200
can try to formulate a stronger

647
00:22:28,200 --> 00:22:29,820
knowledge version of these assumptions

648
00:22:29,820 --> 00:22:31,860
this was done in the outbreak data work

649
00:22:31,860 --> 00:22:34,740
from crypto last year so you can you can

650
00:22:34,740 --> 00:22:36,240
write down these assumptions and try and

651
00:22:36,240 --> 00:22:38,880
analyze it and prove security it seems

652
00:22:38,880 --> 00:22:40,679
it turns out though that formulating a

653
00:22:40,679 --> 00:22:42,240
reasonable knowledge assumption that's

654
00:22:42,240 --> 00:22:44,700
not uh broken uh turns out to be

655
00:22:44,700 --> 00:22:47,039
challenging uh with uh with with the

656
00:22:47,039 --> 00:22:48,480
Machinery we have I think it's an

657
00:22:48,480 --> 00:22:50,039
excellent question and I think for the

658
00:22:50,039 --> 00:22:51,720
constructions that I described here it's

659
00:22:51,720 --> 00:22:53,340
not clear that there's an attack but we

660
00:22:53,340 --> 00:22:54,539
also don't have enough assumption that

661
00:22:54,539 --> 00:22:57,559
we can prove security from

662
00:22:59,340 --> 00:23:00,960
so one more question is

663
00:23:00,960 --> 00:23:03,299
yes sorry I just have a just a quick

664
00:23:03,299 --> 00:23:05,760
follow-up maybe more on your intuition

665
00:23:05,760 --> 00:23:08,340
whether we could have a lattice based

666
00:23:08,340 --> 00:23:10,500
sub Vector commitments based on like

667
00:23:10,500 --> 00:23:12,960
standard assumptions like sis like you

668
00:23:12,960 --> 00:23:15,120
have this Vector commitments with just

669
00:23:15,120 --> 00:23:19,140
uh one position opening and it relies on

670
00:23:19,140 --> 00:23:21,299
this basis assumption which you reduce

671
00:23:21,299 --> 00:23:25,740
from sis so is your intuition that we

672
00:23:25,740 --> 00:23:28,260
could have such a sub Vector commitments

673
00:23:28,260 --> 00:23:30,480
based on those standard assumption or do

674
00:23:30,480 --> 00:23:33,360
we need like more assumption and more uh

675
00:23:33,360 --> 00:23:36,900
complicated assumption uh like the Isis

676
00:23:36,900 --> 00:23:39,059
F that was presented yesterday or this

677
00:23:39,059 --> 00:23:41,760
structured basis uh yeah assumption

678
00:23:41,760 --> 00:23:43,260
that's a great question so I see no

679
00:23:43,260 --> 00:23:44,700
barriers so I don't think there's any

680
00:23:44,700 --> 00:23:46,799
reason why we cannot do it from just

681
00:23:46,799 --> 00:23:48,360
plain sis I think right now the

682
00:23:48,360 --> 00:23:50,039
techniques we have don't seem sufficient

683
00:23:50,039 --> 00:23:52,320
but there's always potentially new ideas

684
00:23:52,320 --> 00:23:54,299
or new approaches that would allow us to

685
00:23:54,299 --> 00:23:56,580
get a better sub Vector commitments and

686
00:23:56,580 --> 00:23:58,020
functional commitments from standard

687
00:23:58,020 --> 00:23:59,340
lattice assumptions

688
00:23:59,340 --> 00:24:01,020
okay thank you

689
00:24:01,020 --> 00:24:02,820
so let's have all further questions

690
00:24:02,820 --> 00:24:05,170
offline and thank the speaker again

691
00:24:05,170 --> 00:24:13,980
[Applause]

692
00:24:13,980 --> 00:24:16,260
so the second talk in this session on

693
00:24:16,260 --> 00:24:18,659
lattice constructions is called

694
00:24:18,659 --> 00:24:20,640
efficient laconic cryptography from

695
00:24:20,640 --> 00:24:23,039
learning with errors it is joint work by

696
00:24:23,039 --> 00:24:26,940
Nico dudling Dimitris colonelos Russell

697
00:24:26,940 --> 00:24:31,440
wfly John Wei Lin Julio malabolta and

698
00:24:31,440 --> 00:24:33,000
Ahmad

699
00:24:33,000 --> 00:24:35,460
and Russell will give the talk

700
00:24:35,460 --> 00:24:38,220
thank you for the introduction uh I

701
00:24:38,220 --> 00:24:40,679
would very like much like to talk about

702
00:24:40,679 --> 00:24:42,419
the functional commitments and Vector

703
00:24:42,419 --> 00:24:44,520
commitments here but yeah but I'm also

704
00:24:44,520 --> 00:24:47,039
happy to talk about laconic cryptography

705
00:24:47,039 --> 00:24:50,100
from learning repairs so maybe after

706
00:24:50,100 --> 00:24:52,020
this talk my goal is to convince you

707
00:24:52,020 --> 00:24:54,720
that laconic cryptography is not just

708
00:24:54,720 --> 00:24:56,520
something that you see in crypto and you

709
00:24:56,520 --> 00:24:59,220
recruit but maybe in one or two years or

710
00:24:59,220 --> 00:25:03,480
so in Practical venues like CCS Okay so

711
00:25:03,480 --> 00:25:05,640
yeah so I'm first going to explain what

712
00:25:05,640 --> 00:25:07,559
laconic cryptography is and then I'll

713
00:25:07,559 --> 00:25:09,659
talk about how we can build it

714
00:25:09,659 --> 00:25:12,360
efficiently from just in the standard

715
00:25:12,360 --> 00:25:16,100
standard LW assumption

716
00:25:16,140 --> 00:25:19,860
okay so less our context is the round

717
00:25:19,860 --> 00:25:22,620
optimal two-party computation so here we

718
00:25:22,620 --> 00:25:25,559
have two parties LS and Bob LS we will

719
00:25:25,559 --> 00:25:27,659
call as the receiver because she is the

720
00:25:27,659 --> 00:25:29,520
one who receives the final output of the

721
00:25:29,520 --> 00:25:32,279
computation and Bob is a standard so

722
00:25:32,279 --> 00:25:35,100
very generically Alice and Bob they both

723
00:25:35,100 --> 00:25:37,380
know some function f and LS has an input

724
00:25:37,380 --> 00:25:39,360
X Bob has an input y

725
00:25:39,360 --> 00:25:42,120
and Ella sends some kind of encoding of

726
00:25:42,120 --> 00:25:45,059
x to Bob and Bob replies with some kind

727
00:25:45,059 --> 00:25:48,659
of encoding to uh to of Y to Alice and

728
00:25:48,659 --> 00:25:50,760
then somehow errors can derive f of x

729
00:25:50,760 --> 00:25:54,120
okay so by some magic qpc protocol

730
00:25:54,120 --> 00:25:58,320
and for for security uh sometimes we

731
00:25:58,320 --> 00:26:00,000
require that LS should not learn

732
00:26:00,000 --> 00:26:02,880
anything about why so so she only learns

733
00:26:02,880 --> 00:26:06,000
about f of x x y but nothing else about

734
00:26:06,000 --> 00:26:08,760
Y and sometimes we want a bob to learn

735
00:26:08,760 --> 00:26:11,520
nothing about X or sometimes both

736
00:26:11,520 --> 00:26:14,820
and in general although here I talk

737
00:26:14,820 --> 00:26:17,159
about LS and Bob but LS could there

738
00:26:17,159 --> 00:26:19,620
could be many analysis so Alice could

739
00:26:19,620 --> 00:26:22,080
could be one member of a big group and

740
00:26:22,080 --> 00:26:24,539
Bob could also be one member of a of a

741
00:26:24,539 --> 00:26:25,860
big group

742
00:26:25,860 --> 00:26:28,679
all right so there are two

743
00:26:28,679 --> 00:26:31,860
so there is one very popular flavor of

744
00:26:31,860 --> 00:26:35,580
two PC which is informally known as LS

745
00:26:35,580 --> 00:26:40,220
optimized 2pc so so in this setting

746
00:26:40,220 --> 00:26:43,380
we want the work of Alice the

747
00:26:43,380 --> 00:26:46,500
computational cost of Ls to be very very

748
00:26:46,500 --> 00:26:48,659
small so only proportional to her input

749
00:26:48,659 --> 00:26:51,900
X and and Bob will do all the job and

750
00:26:51,900 --> 00:26:55,440
this is kind of canonically solved by

751
00:26:55,440 --> 00:26:57,179
fully homomorphic encryption which

752
00:26:57,179 --> 00:26:59,220
allows you to perform arbitrary

753
00:26:59,220 --> 00:27:02,279
computation over encrypted data so very

754
00:27:02,279 --> 00:27:05,700
briefly how would you do it so first LS

755
00:27:05,700 --> 00:27:08,760
samples some fhee keypad public PK and

756
00:27:08,760 --> 00:27:12,480
SK and she encrypts her input X and the

757
00:27:12,480 --> 00:27:15,539
PK and sends both the public key and

758
00:27:15,539 --> 00:27:17,760
ciphertext to Bob and then Bob just

759
00:27:17,760 --> 00:27:21,779
homomorphically evaluates F and get F of

760
00:27:21,779 --> 00:27:24,179
a ciphertext of f of x y and send this

761
00:27:24,179 --> 00:27:26,400
ciphertext back to Alice and then Alice

762
00:27:26,400 --> 00:27:28,860
just decrypts right so as you can see

763
00:27:28,860 --> 00:27:31,980
the work of Ls only depends on her input

764
00:27:31,980 --> 00:27:34,320
X but not the computation F and that's

765
00:27:34,320 --> 00:27:37,080
why we say that this kind of Protocols

766
00:27:37,080 --> 00:27:39,960
are LS optimized and this can be done

767
00:27:39,960 --> 00:27:42,539
nowadays with very efficient fhe thanks

768
00:27:42,539 --> 00:27:46,860
to all these recent advances from

769
00:27:46,860 --> 00:27:48,480
fairly standard lattice space

770
00:27:48,480 --> 00:27:50,460
assumptions so you may still need Super

771
00:27:50,460 --> 00:27:52,080
polynomial modulus or something like

772
00:27:52,080 --> 00:27:53,240
that but

773
00:27:53,240 --> 00:27:55,440
it's quite standard

774
00:27:55,440 --> 00:27:57,059
Okay so

775
00:27:57,059 --> 00:27:59,820
laconic cryptography is sort of a dual

776
00:27:59,820 --> 00:28:03,299
notion of Ls optimized 2pc and for this

777
00:28:03,299 --> 00:28:06,620
reason it is called bulb optimized to PC

778
00:28:06,620 --> 00:28:10,260
and it is an emerging Paradigm with

779
00:28:10,260 --> 00:28:13,260
numerous theoretical results but today I

780
00:28:13,260 --> 00:28:15,179
will show you that there will also be

781
00:28:15,179 --> 00:28:17,460
practical results as well in this domain

782
00:28:17,460 --> 00:28:18,900
so

783
00:28:18,900 --> 00:28:22,620
so the setting is as follows LS will as

784
00:28:22,620 --> 00:28:25,380
usual send some encoding of x to Bob but

785
00:28:25,380 --> 00:28:27,000
now Bob instead of doing some

786
00:28:27,000 --> 00:28:30,120
computation he just encodes his input Y

787
00:28:30,120 --> 00:28:32,760
and send this encoding y somehow to to

788
00:28:32,760 --> 00:28:35,520
LS and then LS will do all the work and

789
00:28:35,520 --> 00:28:37,620
compute f of x y

790
00:28:37,620 --> 00:28:40,559
so again we say that such Protocols are

791
00:28:40,559 --> 00:28:43,200
Bob optimized because Bob's work only

792
00:28:43,200 --> 00:28:45,840
depends on why and LS does all the

793
00:28:45,840 --> 00:28:48,120
computations

794
00:28:48,120 --> 00:28:50,159
so why is this challenging well because

795
00:28:50,159 --> 00:28:53,100
Bob doesn't even have time to read F of

796
00:28:53,100 --> 00:28:56,520
f o x info so I'm cheating a bit here

797
00:28:56,520 --> 00:29:00,539
because I say that Bob inputs F so like

798
00:29:00,539 --> 00:29:02,100
if you think of the circuit model then

799
00:29:02,100 --> 00:29:04,260
the pop should read F in full but let's

800
00:29:04,260 --> 00:29:07,260
say Bob gets some kind of digest or F or

801
00:29:07,260 --> 00:29:10,140
or Bob runs Bob is a random access

802
00:29:10,140 --> 00:29:12,299
machine so yeah let's not care about

803
00:29:12,299 --> 00:29:13,270
that too much

804
00:29:13,270 --> 00:29:14,400
[Music]

805
00:29:14,400 --> 00:29:17,220
but in short pop has not enough time to

806
00:29:17,220 --> 00:29:20,520
read text and then also Bob needs to

807
00:29:20,520 --> 00:29:22,620
come up with some encoding of Y so that

808
00:29:22,620 --> 00:29:25,380
it is just enough for Ellis to unpack f

809
00:29:25,380 --> 00:29:27,720
of x y but learn nothing else about y so

810
00:29:27,720 --> 00:29:31,500
this is why this setting is challenging

811
00:29:31,500 --> 00:29:33,539
so before telling you about the

812
00:29:33,539 --> 00:29:35,220
constructions let me tease you a bit

813
00:29:35,220 --> 00:29:38,419
about the applications of

814
00:29:38,419 --> 00:29:41,279
laconic cryptography to non-conic

815
00:29:41,279 --> 00:29:44,360
cryptography so so here applications

816
00:29:44,360 --> 00:29:47,159
for applications I mean it in quite a

817
00:29:47,159 --> 00:29:49,559
broad sense so it also covers the

818
00:29:49,559 --> 00:29:51,600
techniques that are used to construct

819
00:29:51,600 --> 00:29:54,080
the cryptography so

820
00:29:54,080 --> 00:29:56,600
basically it has implications to

821
00:29:56,600 --> 00:29:59,039
Primitives like identity based

822
00:29:59,039 --> 00:30:00,480
encryption multi-party computation

823
00:30:00,480 --> 00:30:03,240
Global circuits trapdoor functions IO

824
00:30:03,240 --> 00:30:07,039
and private information retrieval and

825
00:30:07,039 --> 00:30:10,200
generally generally speaking these

826
00:30:10,200 --> 00:30:12,299
techniques allow you to take some weak

827
00:30:12,299 --> 00:30:14,880
computational assumptions and let them

828
00:30:14,880 --> 00:30:17,340
punch above their weights and then allow

829
00:30:17,340 --> 00:30:19,559
you to construct something stronger

830
00:30:19,559 --> 00:30:20,539
which

831
00:30:20,539 --> 00:30:25,100
natural constructions wouldn't allow

832
00:30:25,260 --> 00:30:27,419
so let us look at a few examples of

833
00:30:27,419 --> 00:30:30,240
laconic cryptography the simplest

834
00:30:30,240 --> 00:30:33,919
setting a simplest primitive in in in

835
00:30:33,919 --> 00:30:37,260
this laconic family of Primitives is a

836
00:30:37,260 --> 00:30:38,580
laconic OT

837
00:30:38,580 --> 00:30:42,419
so here LS has a big database D consists

838
00:30:42,419 --> 00:30:45,659
of n Bits and Bob's input is an index I

839
00:30:45,659 --> 00:30:49,440
and two messages mu 0 and mu mu1 and

840
00:30:49,440 --> 00:30:52,200
what pop what bot wants LS to know is

841
00:30:52,200 --> 00:30:55,799
that if the if bit of D is zero then

842
00:30:55,799 --> 00:30:58,260
error should learn mu 0 and if the if

843
00:30:58,260 --> 00:31:00,840
bit of D is one then L should learn to

844
00:31:00,840 --> 00:31:03,240
mu1

845
00:31:03,240 --> 00:31:05,340
another example would be electronic

846
00:31:05,340 --> 00:31:07,980
private set intersection so here LS has

847
00:31:07,980 --> 00:31:10,860
a very big set maybe is the list of all

848
00:31:10,860 --> 00:31:13,440
her friends and Bob has quite a small

849
00:31:13,440 --> 00:31:16,620
set B and here Alice wants to learn the

850
00:31:16,620 --> 00:31:19,080
intersection between a and b

851
00:31:19,080 --> 00:31:21,179
more generally we have this notion of

852
00:31:21,179 --> 00:31:23,580
laconic function evaluation where ls's

853
00:31:23,580 --> 00:31:25,740
input is a very complicated function G

854
00:31:25,740 --> 00:31:29,880
and Bob's input is a short input Y and

855
00:31:29,880 --> 00:31:33,059
LS wants to learn G of Y

856
00:31:33,059 --> 00:31:36,419
so another example with more semantic

857
00:31:36,419 --> 00:31:39,179
meaning is that of registration based

858
00:31:39,179 --> 00:31:41,460
encryption so so here is an example

859
00:31:41,460 --> 00:31:43,799
where LS is actually a lot of alices

860
00:31:43,799 --> 00:31:46,140
instead of just one so imagine you have

861
00:31:46,140 --> 00:31:48,600
a lot of users each with their own ID

862
00:31:48,600 --> 00:31:52,620
and they are registered somehow uh to to

863
00:31:52,620 --> 00:31:55,320
a service and and we collect all these

864
00:31:55,320 --> 00:31:59,100
registered use IDs in the set R and and

865
00:31:59,100 --> 00:32:02,100
so LSS input conceptually consists of

866
00:32:02,100 --> 00:32:05,039
the secret key of one particular Alice

867
00:32:05,039 --> 00:32:08,820
SK of ID dagger and then the the

868
00:32:08,820 --> 00:32:11,220
collection of all the ID public key to

869
00:32:11,220 --> 00:32:12,299
both

870
00:32:12,299 --> 00:32:14,640
on the other hand Bob's input is a

871
00:32:14,640 --> 00:32:16,679
special identity ID star and a message

872
00:32:16,679 --> 00:32:19,860
mu and and the functionality is such

873
00:32:19,860 --> 00:32:23,460
that if if the two identities match so

874
00:32:23,460 --> 00:32:26,220
ID dagger is equal to ID star and also

875
00:32:26,220 --> 00:32:28,740
LSS know the corresponding secret key

876
00:32:28,740 --> 00:32:30,779
for ID deck then she can learn the

877
00:32:30,779 --> 00:32:33,659
message mu otherwise she learns nothing

878
00:32:33,659 --> 00:32:37,080
okay and this functionality also

879
00:32:37,080 --> 00:32:38,120
captures

880
00:32:38,120 --> 00:32:41,520
the so-called laconic encryption that we

881
00:32:41,520 --> 00:32:43,200
introduced in this work but more on that

882
00:32:43,200 --> 00:32:45,059
later

883
00:32:45,059 --> 00:32:48,779
so before our work all of the above

884
00:32:48,779 --> 00:32:51,179
the all the constructions of the above

885
00:32:51,179 --> 00:32:53,640
require so-called non-black box

886
00:32:53,640 --> 00:32:56,100
techniques so using cryptographic

887
00:32:56,100 --> 00:32:58,320
Primitives in a non-blackbox way so to

888
00:32:58,320 --> 00:33:01,380
give you a concrete example it involves

889
00:33:01,380 --> 00:33:03,179
something like a homomorphically

890
00:33:03,179 --> 00:33:05,940
evaluating a circuit implementing a

891
00:33:05,940 --> 00:33:08,580
public encryption scheme or running a

892
00:33:08,580 --> 00:33:11,340
Garbo circuit again with with a circuit

893
00:33:11,340 --> 00:33:12,840
that implements a public encryption

894
00:33:12,840 --> 00:33:15,240
scheme and as you may imagine this is

895
00:33:15,240 --> 00:33:18,120
completely impractical

896
00:33:18,120 --> 00:33:21,000
so here comes our result so in this work

897
00:33:21,000 --> 00:33:23,220
we introduced the notion of laconic

898
00:33:23,220 --> 00:33:26,700
encryption which we think is

899
00:33:26,700 --> 00:33:28,919
arguably the simplest building block

900
00:33:28,919 --> 00:33:30,600
that you can have in laconic

901
00:33:30,600 --> 00:33:32,880
cryptography and then it implies a lot

902
00:33:32,880 --> 00:33:35,399
of other laconic Primitives that we use

903
00:33:35,399 --> 00:33:38,159
as weoc so for those of you who know

904
00:33:38,159 --> 00:33:40,799
about registration based encryption then

905
00:33:40,799 --> 00:33:43,260
electronic encryption is basically the

906
00:33:43,260 --> 00:33:44,940
same as registration based encryption

907
00:33:44,940 --> 00:33:47,640
but without all those stringent update

908
00:33:47,640 --> 00:33:49,799
efficiency requirements so it's a

909
00:33:49,799 --> 00:33:52,140
simpler version than registration based

910
00:33:52,140 --> 00:33:53,460
encryption

911
00:33:53,460 --> 00:33:55,919
and in this work we after introducing

912
00:33:55,919 --> 00:33:57,779
the notion of the corner encryption we

913
00:33:57,779 --> 00:34:00,779
provide a an a fully algebraic

914
00:34:00,779 --> 00:34:02,820
construction of electronic encryption

915
00:34:02,820 --> 00:34:05,640
from the standard learning assumptions

916
00:34:05,640 --> 00:34:09,000
with polynomial modulus to noise ratio

917
00:34:09,000 --> 00:34:11,580
and then we show that there are Black

918
00:34:11,580 --> 00:34:13,679
Box Transformations from laconic

919
00:34:13,679 --> 00:34:15,780
encryption to most of the other

920
00:34:15,780 --> 00:34:17,339
electronic Primitives including

921
00:34:17,339 --> 00:34:19,800
electronic OT laconic PSI and

922
00:34:19,800 --> 00:34:21,899
registration based encryption but noted

923
00:34:21,899 --> 00:34:24,599
notably we cannot get a electronic

924
00:34:24,599 --> 00:34:26,699
function evaluation in a black box way

925
00:34:26,699 --> 00:34:28,918
so that's an open problem

926
00:34:28,918 --> 00:34:31,139
and also for the first time we

927
00:34:31,139 --> 00:34:33,960
implemented anything laconic at all so

928
00:34:33,960 --> 00:34:36,300
we provide an open source implementation

929
00:34:36,300 --> 00:34:40,260
of this laconic encryption primitive and

930
00:34:40,260 --> 00:34:43,560
so for a database size of at most 2 to

931
00:34:43,560 --> 00:34:45,780
the 50 identities that is just a fancy

932
00:34:45,780 --> 00:34:48,960
way of saying that the identities are 50

933
00:34:48,960 --> 00:34:52,080
bit strings so if we encrypt with

934
00:34:52,080 --> 00:34:53,820
respect to such a database then we

935
00:34:53,820 --> 00:34:56,580
managed to get encryption and decryption

936
00:34:56,580 --> 00:35:00,500
time at around 10 milliseconds

937
00:35:00,500 --> 00:35:03,720
microsecond okay and as a byproduct

938
00:35:03,720 --> 00:35:07,500
using our techniques we can also get a

939
00:35:07,500 --> 00:35:09,900
identity based encryption with unbounded

940
00:35:09,900 --> 00:35:12,480
identity space and height reduction from

941
00:35:12,480 --> 00:35:13,980
the negative errors

942
00:35:13,980 --> 00:35:17,700
so this might be of independent interest

943
00:35:17,700 --> 00:35:19,740
so for the interest of time today I'm

944
00:35:19,740 --> 00:35:21,599
only going to talk about the notion of

945
00:35:21,599 --> 00:35:23,280
laconic encryption and also the

946
00:35:23,280 --> 00:35:26,579
construction from lwe

947
00:35:26,579 --> 00:35:29,099
uh so first I must say that the notion

948
00:35:29,099 --> 00:35:31,380
of laconic encryption actually existed

949
00:35:31,380 --> 00:35:33,540
in the literature implicitly for example

950
00:35:33,540 --> 00:35:37,260
in existing laconic OT constructions

951
00:35:37,260 --> 00:35:39,540
so for Simplicity let's just consider

952
00:35:39,540 --> 00:35:41,940
the setting where we have a static array

953
00:35:41,940 --> 00:35:44,880
of public keys pk1 to pkn instead of

954
00:35:44,880 --> 00:35:48,380
with different identities

955
00:35:48,480 --> 00:35:49,560
so

956
00:35:49,560 --> 00:35:51,900
here imagine we have a lot of users with

957
00:35:51,900 --> 00:35:54,359
the respective public keys pk1 to pkn

958
00:35:54,359 --> 00:35:56,640
and they register at some service

959
00:35:56,640 --> 00:35:58,619
provider and this service provider will

960
00:35:58,619 --> 00:36:00,660
hash all the public Keys into a short

961
00:36:00,660 --> 00:36:03,540
digest which is available to anyone

962
00:36:03,540 --> 00:36:06,119
including Bob so Bob just looks as this

963
00:36:06,119 --> 00:36:09,540
digest and then using the electronic

964
00:36:09,540 --> 00:36:12,359
encryption he can encrypt with respect

965
00:36:12,359 --> 00:36:15,180
to a particularly particular ID of his

966
00:36:15,180 --> 00:36:18,859
choice and a message mu and send this

967
00:36:18,859 --> 00:36:21,720
ciphertext to Alice now on the other

968
00:36:21,720 --> 00:36:24,420
hand Alice can derive a membership

969
00:36:24,420 --> 00:36:27,480
witness of the statement that her public

970
00:36:27,480 --> 00:36:30,180
key is registered in this digest and

971
00:36:30,180 --> 00:36:33,119
then using both her secret key and the

972
00:36:33,119 --> 00:36:35,520
witness she can decrypt this Cyber

973
00:36:35,520 --> 00:36:37,380
attack sent by Bob and obtain the

974
00:36:37,380 --> 00:36:39,599
message

975
00:36:39,599 --> 00:36:42,780
for efficiency we require that both the

976
00:36:42,780 --> 00:36:45,060
encryption algorithm and the decryption

977
00:36:45,060 --> 00:36:48,119
algorithm run in time much much smaller

978
00:36:48,119 --> 00:36:50,579
than n so sublinear in n and actually we

979
00:36:50,579 --> 00:36:55,380
achieve a poly log and efficiency

980
00:36:55,380 --> 00:36:57,599
and for security we require that the

981
00:36:57,599 --> 00:37:00,300
ciphertext if you don't know the secret

982
00:37:00,300 --> 00:37:03,119
key for ID then the ciphertext hides

983
00:37:03,119 --> 00:37:06,119
both the identity and the message

984
00:37:06,119 --> 00:37:07,859
and actually we prove that it is

985
00:37:07,859 --> 00:37:09,900
pseudorandom if you don't know the

986
00:37:09,900 --> 00:37:12,240
secret key

987
00:37:12,240 --> 00:37:14,820
so our approach is very natural so first

988
00:37:14,820 --> 00:37:16,320
you pick your favorite public key

989
00:37:16,320 --> 00:37:19,380
encryption scheme and then you design an

990
00:37:19,380 --> 00:37:21,420
a so-called encryption friendly hash

991
00:37:21,420 --> 00:37:23,880
function so that you can encrypt with

992
00:37:23,880 --> 00:37:26,579
respect to the statement that the public

993
00:37:26,579 --> 00:37:30,720
key ID is a member of the digest so that

994
00:37:30,720 --> 00:37:32,460
and the corresponding weakness would be

995
00:37:32,460 --> 00:37:34,680
the secret key and the membership proof

996
00:37:34,680 --> 00:37:36,720
okay so but this is easier said than

997
00:37:36,720 --> 00:37:38,700
done and so so first we need to pick an

998
00:37:38,700 --> 00:37:40,560
encryption scheme and then next we need

999
00:37:40,560 --> 00:37:43,440
to design a an encryption friendly hash

1000
00:37:43,440 --> 00:37:44,700
function

1001
00:37:44,700 --> 00:37:47,040
so in Latin space crypto there are not

1002
00:37:47,040 --> 00:37:48,540
so many encryption schemes that one

1003
00:37:48,540 --> 00:37:51,480
could pick so the favorite choice of

1004
00:37:51,480 --> 00:37:53,339
everyone seems to be the Dual recf

1005
00:37:53,339 --> 00:37:55,920
encryption scheme so in short in the

1006
00:37:55,920 --> 00:37:58,380
Dual reactive encryption scheme you have

1007
00:37:58,380 --> 00:38:00,480
a public parameter which is the image XP

1008
00:38:00,480 --> 00:38:02,880
and then a public key and then secret

1009
00:38:02,880 --> 00:38:07,619
key are sis Solutions and sis pre-image

1010
00:38:07,619 --> 00:38:09,560
and image of with respect to B

1011
00:38:09,560 --> 00:38:12,720
respectively or in other words

1012
00:38:12,720 --> 00:38:16,740
the secret key X satisfies BX equals y

1013
00:38:16,740 --> 00:38:18,900
and x is short

1014
00:38:18,900 --> 00:38:22,560
so next we will like we will design an

1015
00:38:22,560 --> 00:38:24,540
encryption friendly hash function so

1016
00:38:24,540 --> 00:38:28,079
that the when you concatenate so so the

1017
00:38:28,079 --> 00:38:31,020
membership witness takes a form of the

1018
00:38:31,020 --> 00:38:33,660
vector and when you concatenate it with

1019
00:38:33,660 --> 00:38:36,839
a c solution which is the secret key of

1020
00:38:36,839 --> 00:38:39,540
the user then it satisfies a specially

1021
00:38:39,540 --> 00:38:43,280
craft assist relation where the Matrix B

1022
00:38:43,280 --> 00:38:46,920
corresponds to The Matrix B is induced

1023
00:38:46,920 --> 00:38:48,540
by the hash function and the identity

1024
00:38:48,540 --> 00:38:51,900
and the image is induced by the Digest

1025
00:38:51,900 --> 00:38:53,880
and then once we have this we can just

1026
00:38:53,880 --> 00:38:56,160
use the Dual requestion scheme to

1027
00:38:56,160 --> 00:38:58,020
encrypt your face back to this

1028
00:38:58,020 --> 00:39:00,720
particular assist instance

1029
00:39:00,720 --> 00:39:03,119
so for those of you that are not

1030
00:39:03,119 --> 00:39:04,920
familiar with do racket encryption let

1031
00:39:04,920 --> 00:39:07,560
me quickly recap what it is so again the

1032
00:39:07,560 --> 00:39:09,780
public parameters consists of a very

1033
00:39:09,780 --> 00:39:12,599
wide Matrix B uniformly random and the

1034
00:39:12,599 --> 00:39:15,540
public key is an image Factor Y and the

1035
00:39:15,540 --> 00:39:18,000
corresponding secret key is a vector x a

1036
00:39:18,000 --> 00:39:21,359
short Vector X satisfying BX equals y

1037
00:39:21,359 --> 00:39:23,940
now to encrypt with respect to encrypt

1038
00:39:23,940 --> 00:39:26,460
under this public key why what do you do

1039
00:39:26,460 --> 00:39:31,260
you sample a random LW secret s and you

1040
00:39:31,260 --> 00:39:34,200
compute SB plus noise that gives you the

1041
00:39:34,200 --> 00:39:36,540
first ciphertext component c0 and the

1042
00:39:36,540 --> 00:39:39,359
other component is s y plus some error

1043
00:39:39,359 --> 00:39:42,060
correcting code encoding of mu plus some

1044
00:39:42,060 --> 00:39:43,980
other noise

1045
00:39:43,980 --> 00:39:47,579
and using the C solution X you can

1046
00:39:47,579 --> 00:39:49,619
linearly combine the two ciphertext

1047
00:39:49,619 --> 00:39:52,980
components and recover recover the error

1048
00:39:52,980 --> 00:39:55,619
correct encoding encoding of mu plus

1049
00:39:55,619 --> 00:39:58,020
some noise but because it is an error

1050
00:39:58,020 --> 00:39:59,940
correcting code you can decode it and

1051
00:39:59,940 --> 00:40:02,520
recover mu

1052
00:40:02,520 --> 00:40:04,500
so the pseudo randomness of the

1053
00:40:04,500 --> 00:40:07,320
ciphertext comes almost immediately from

1054
00:40:07,320 --> 00:40:09,740
the elderly assumption after some

1055
00:40:09,740 --> 00:40:12,780
hybrids so essentially the Adobe

1056
00:40:12,780 --> 00:40:14,900
assumption says that

1057
00:40:14,900 --> 00:40:18,180
lwe with respect to the concatenation of

1058
00:40:18,180 --> 00:40:20,820
B and Y is through the random

1059
00:40:20,820 --> 00:40:23,640
and that immediately says that the

1060
00:40:23,640 --> 00:40:25,680
ciphertax is super random

1061
00:40:25,680 --> 00:40:27,660
so but the technical message is that

1062
00:40:27,660 --> 00:40:29,940
there exists an encryption scheme where

1063
00:40:29,940 --> 00:40:32,040
the public key together with the public

1064
00:40:32,040 --> 00:40:34,560
parameter is assist instance and the

1065
00:40:34,560 --> 00:40:36,480
corresponding decryption key is a c

1066
00:40:36,480 --> 00:40:38,880
solution so that's the most important

1067
00:40:38,880 --> 00:40:41,460
message

1068
00:40:41,460 --> 00:40:44,339
next I would like to design or tell you

1069
00:40:44,339 --> 00:40:46,740
our encryption friendly friendly hash

1070
00:40:46,740 --> 00:40:48,420
function and for this I need to record

1071
00:40:48,420 --> 00:40:51,839
the notion of Gadget Matrix which David

1072
00:40:51,839 --> 00:40:55,440
also introduced so the Matrix G is a

1073
00:40:55,440 --> 00:40:57,300
block diagonal matrix where each block

1074
00:40:57,300 --> 00:41:00,720
consists of powers of 2. and the nice

1075
00:41:00,720 --> 00:41:02,640
thing about this SketchUp Matrix is that

1076
00:41:02,640 --> 00:41:06,000
if you take any vector v and write down

1077
00:41:06,000 --> 00:41:08,579
this binary decomposition denoted by

1078
00:41:08,579 --> 00:41:11,339
this G inverse operator and then when

1079
00:41:11,339 --> 00:41:13,440
you multiply G to the binary

1080
00:41:13,440 --> 00:41:16,980
decomposition of V you get back V so so

1081
00:41:16,980 --> 00:41:19,500
how do we interpret this so one way to

1082
00:41:19,500 --> 00:41:22,619
interpret it is that although the bit

1083
00:41:22,619 --> 00:41:25,200
decomposition operator is highly

1084
00:41:25,200 --> 00:41:28,260
non-linear so like if you compute it in

1085
00:41:28,260 --> 00:41:29,700
the forward Direction it's highly

1086
00:41:29,700 --> 00:41:32,220
non-linear but when you just want to

1087
00:41:32,220 --> 00:41:34,380
verify it is actually a linear relation

1088
00:41:34,380 --> 00:41:36,140
because

1089
00:41:36,140 --> 00:41:39,839
G times G inverse of V is a linear

1090
00:41:39,839 --> 00:41:41,339
operation

1091
00:41:41,339 --> 00:41:43,560
so basically we will exploit this fact

1092
00:41:43,560 --> 00:41:46,200
and design our encryption friendly hash

1093
00:41:46,200 --> 00:41:47,339
function

1094
00:41:47,339 --> 00:41:49,680
so this is essentially the most

1095
00:41:49,680 --> 00:41:52,079
important equation in the entire paper

1096
00:41:52,079 --> 00:41:54,540
and also this talk so and and this is

1097
00:41:54,540 --> 00:41:56,220
our hash function so this hash function

1098
00:41:56,220 --> 00:42:00,420
takes as input two vectors v0 and V1 and

1099
00:42:00,420 --> 00:42:03,720
we first binary decompose the two

1100
00:42:03,720 --> 00:42:06,240
vectors into G inverse of v0 and G

1101
00:42:06,240 --> 00:42:08,280
inverse of V1 and then we take the

1102
00:42:08,280 --> 00:42:11,040
negative and then we perform a linear

1103
00:42:11,040 --> 00:42:14,760
combination with coefficients a0 and A1

1104
00:42:14,760 --> 00:42:18,540
so if you pack a0 and A1 together

1105
00:42:18,540 --> 00:42:20,700
horizontally you can write it in this

1106
00:42:20,700 --> 00:42:22,260
compact form

1107
00:42:22,260 --> 00:42:25,380
now let's look at what happens when we

1108
00:42:25,380 --> 00:42:27,240
use this particular hash function to

1109
00:42:27,240 --> 00:42:29,760
build a Merkel tree which hashes all our

1110
00:42:29,760 --> 00:42:32,220
public keys so here I'm doing nothing

1111
00:42:32,220 --> 00:42:35,280
fancy I basically pack all all the

1112
00:42:35,280 --> 00:42:37,079
public keys at the leaves and then I

1113
00:42:37,079 --> 00:42:39,780
compute the Merkel hash until I reach a

1114
00:42:39,780 --> 00:42:42,900
digest which is a vector denoted by a y

1115
00:42:42,900 --> 00:42:44,400
Epsilon

1116
00:42:44,400 --> 00:42:47,280
so as you may know uh if you have a

1117
00:42:47,280 --> 00:42:49,020
miracle tree hash then the membership

1118
00:42:49,020 --> 00:42:51,260
opening is just the route to leave path

1119
00:42:51,260 --> 00:42:54,300
of the labels together with its siblings

1120
00:42:54,300 --> 00:42:57,180
so similar things are happening here so

1121
00:42:57,180 --> 00:42:59,160
if we call so for example if we want to

1122
00:42:59,160 --> 00:43:01,220
verify that

1123
00:43:01,220 --> 00:43:05,040
pk01 is in the digest then we collect

1124
00:43:05,040 --> 00:43:06,740
all these

1125
00:43:06,740 --> 00:43:08,660
labels

1126
00:43:08,660 --> 00:43:11,940
w0w1 w00 and w01

1127
00:43:11,940 --> 00:43:14,099
and we concatenate it with the secret

1128
00:43:14,099 --> 00:43:15,560
key of

1129
00:43:15,560 --> 00:43:19,560
y01 and we notice that this Vector

1130
00:43:19,560 --> 00:43:22,920
satisfies this particular this relation

1131
00:43:22,920 --> 00:43:24,900
where on the left hand side we have a

1132
00:43:24,900 --> 00:43:26,940
matrix

1133
00:43:26,940 --> 00:43:30,240
which depends on the identity string 0 1

1134
00:43:30,240 --> 00:43:32,940
in a particular way and on the right

1135
00:43:32,940 --> 00:43:35,040
hand side we have this Vector consisting

1136
00:43:35,040 --> 00:43:38,220
of the root label y Epsilon concatenated

1137
00:43:38,220 --> 00:43:41,400
with all zeros so once we have this we

1138
00:43:41,400 --> 00:43:43,980
just use two bracket encryption to

1139
00:43:43,980 --> 00:43:46,619
encrypt with respect to this this

1140
00:43:46,619 --> 00:43:48,000
relation

1141
00:43:48,000 --> 00:43:50,180
now putting everything together

1142
00:43:50,180 --> 00:43:52,079
recall that

1143
00:43:52,079 --> 00:43:53,640
there are many users with their

1144
00:43:53,640 --> 00:43:55,980
respective public keys and when they

1145
00:43:55,980 --> 00:43:58,140
register you hash the the service

1146
00:43:58,140 --> 00:44:00,480
provider has all of them into a miracle

1147
00:44:00,480 --> 00:44:01,760
hash

1148
00:44:01,760 --> 00:44:04,440
digest why Epsilon

1149
00:44:04,440 --> 00:44:07,800
and then everyone in the everyone that

1150
00:44:07,800 --> 00:44:10,380
is registered can compute its own

1151
00:44:10,380 --> 00:44:12,599
membership proof by looking at the

1152
00:44:12,599 --> 00:44:14,819
labels of this local history so for

1153
00:44:14,819 --> 00:44:16,920
example the witness for the identity

1154
00:44:16,920 --> 00:44:20,960
string zero one is of this form

1155
00:44:21,300 --> 00:44:23,579
and to encrypt with respect to a

1156
00:44:23,579 --> 00:44:27,240
particular ID you craft a special CIS

1157
00:44:27,240 --> 00:44:30,119
relation where the Matrix B is

1158
00:44:30,119 --> 00:44:33,119
programmed like this so here ID bar

1159
00:44:33,119 --> 00:44:36,599
stands for the negation of the bit so

1160
00:44:36,599 --> 00:44:39,900
for example if the first bit of the ID

1161
00:44:39,900 --> 00:44:44,220
is one then you have one times G here

1162
00:44:44,220 --> 00:44:47,099
and 0 times G here so that means G is

1163
00:44:47,099 --> 00:44:51,180
put under A1 and 0 is put under a0 and

1164
00:44:51,180 --> 00:44:53,040
if the first bit is zero then it's the

1165
00:44:53,040 --> 00:44:54,780
other way around and you do this for

1166
00:44:54,780 --> 00:44:58,619
every bit in the identity string and as

1167
00:44:58,619 --> 00:45:01,800
I said the the image of this relation is

1168
00:45:01,800 --> 00:45:04,140
just a y Epsilon concatenated with all

1169
00:45:04,140 --> 00:45:05,460
civil

1170
00:45:05,460 --> 00:45:07,260
so now the encrypter just encrypt with

1171
00:45:07,260 --> 00:45:09,720
respects back to this this relation and

1172
00:45:09,720 --> 00:45:12,180
naturally the decrypter can use the

1173
00:45:12,180 --> 00:45:14,700
concatenation of the witness membership

1174
00:45:14,700 --> 00:45:16,859
witness and its own secret key to

1175
00:45:16,859 --> 00:45:18,420
decrypt

1176
00:45:18,420 --> 00:45:21,660
and correctness just follows naturally

1177
00:45:21,660 --> 00:45:24,180
so next let me talk about some key

1178
00:45:24,180 --> 00:45:26,640
points in the security proof so note

1179
00:45:26,640 --> 00:45:28,980
that we cannot use the security of do

1180
00:45:28,980 --> 00:45:31,859
recap encryption directly because this

1181
00:45:31,859 --> 00:45:34,260
specially crafted system relation is not

1182
00:45:34,260 --> 00:45:37,980
a properly distributed durage public key

1183
00:45:37,980 --> 00:45:40,740
so to argue security we actually need to

1184
00:45:40,740 --> 00:45:44,640
be very careful and analyze the the

1185
00:45:44,640 --> 00:45:47,160
hardness analyze lwe with respect to

1186
00:45:47,160 --> 00:45:49,619
this very structured Matrix but

1187
00:45:49,619 --> 00:45:53,280
nevertheless we can peel off this rows

1188
00:45:53,280 --> 00:45:56,280
of this Matrix one by one until we can

1189
00:45:56,280 --> 00:45:59,460
reduce everything from lwe

1190
00:45:59,460 --> 00:46:02,579
so but as usual like if you have done

1191
00:46:02,579 --> 00:46:05,220
this sort of proofs before you you

1192
00:46:05,220 --> 00:46:07,440
realize that somewhere in your proof

1193
00:46:07,440 --> 00:46:09,619
there will be so

1194
00:46:09,619 --> 00:46:13,319
you define some hybrid experiments and

1195
00:46:13,319 --> 00:46:16,380
then in some of these hybrids

1196
00:46:16,380 --> 00:46:19,680
you would have some linearly correlated

1197
00:46:19,680 --> 00:46:22,319
LW samples and then in the next hybrid

1198
00:46:22,319 --> 00:46:24,359
you will have a short linear

1199
00:46:24,359 --> 00:46:26,940
combinations of some fresh ldb samples

1200
00:46:26,940 --> 00:46:29,700
plus some fresh noise and you would like

1201
00:46:29,700 --> 00:46:31,680
to argue that these two hybrids are

1202
00:46:31,680 --> 00:46:34,740
indistinguishable and so traditionally

1203
00:46:34,740 --> 00:46:36,900
these sort of things are done in two

1204
00:46:36,900 --> 00:46:39,180
ways so either you assume a super

1205
00:46:39,180 --> 00:46:42,540
polynomial size modulus and then you use

1206
00:46:42,540 --> 00:46:44,760
this so-called noise flooding drowning

1207
00:46:44,760 --> 00:46:46,440
or smudging technique however you want

1208
00:46:46,440 --> 00:46:48,599
to call it uh

1209
00:46:48,599 --> 00:46:50,640
and then you can actually show that

1210
00:46:50,640 --> 00:46:52,380
these two distributions are closed

1211
00:46:52,380 --> 00:46:54,300
statistically but this would require

1212
00:46:54,300 --> 00:46:57,420
using a super polynomial modulus

1213
00:46:57,420 --> 00:47:01,140
another approach is to argue about the

1214
00:47:01,140 --> 00:47:02,880
range Divergence between these two

1215
00:47:02,880 --> 00:47:06,060
distributions but uh but this will incur

1216
00:47:06,060 --> 00:47:08,579
polynomial reduction loss so in this

1217
00:47:08,579 --> 00:47:10,740
paper we actually show that these two

1218
00:47:10,740 --> 00:47:13,200
distributions are computationally closed

1219
00:47:13,200 --> 00:47:16,920
by the ldb Assumption and we call this a

1220
00:47:16,920 --> 00:47:19,800
new assumption the error leakage Adobe

1221
00:47:19,800 --> 00:47:22,140
assumption and then we prove that this

1222
00:47:22,140 --> 00:47:24,300
assumption just holds from assuming

1223
00:47:24,300 --> 00:47:27,780
standard lwb so we believe that this

1224
00:47:27,780 --> 00:47:32,280
Lemma is of independent interest

1225
00:47:32,280 --> 00:47:35,760
so to conclude in this paper we provide

1226
00:47:35,760 --> 00:47:38,040
the first construct first fully

1227
00:47:38,040 --> 00:47:39,900
algebraic construction of electronic

1228
00:47:39,900 --> 00:47:43,319
encryption from standard lwe and we

1229
00:47:43,319 --> 00:47:45,839
provide a black box Transformations from

1230
00:47:45,839 --> 00:47:48,240
the corner encryption to

1231
00:47:48,240 --> 00:47:50,099
many other electronic Primitives

1232
00:47:50,099 --> 00:47:52,680
including laconic OT laconic PSI and

1233
00:47:52,680 --> 00:47:55,079
registration based encryption and for

1234
00:47:55,079 --> 00:47:56,700
the first time we have an implementation

1235
00:47:56,700 --> 00:47:59,420
of anything laconic and the decryption

1236
00:47:59,420 --> 00:48:01,440
encryption and decryption time are

1237
00:48:01,440 --> 00:48:03,900
fairly fast and we also have some

1238
00:48:03,900 --> 00:48:07,619
implications for identity identity based

1239
00:48:07,619 --> 00:48:09,000
encryption

1240
00:48:09,000 --> 00:48:12,800
So yeah thank you very much

1241
00:48:19,920 --> 00:48:21,480
thank you very much for the great talk

1242
00:48:21,480 --> 00:48:24,800
are there any questions

1243
00:48:27,359 --> 00:48:29,520
yeah otherwise maybe I would ask a very

1244
00:48:29,520 --> 00:48:30,660
brief one

1245
00:48:30,660 --> 00:48:32,460
um since it's the last one and maybe

1246
00:48:32,460 --> 00:48:34,260
have an outlooked future do you see

1247
00:48:34,260 --> 00:48:36,240
further applications of laconic

1248
00:48:36,240 --> 00:48:37,619
encryption

1249
00:48:37,619 --> 00:48:39,900
like so you mean further applications

1250
00:48:39,900 --> 00:48:42,960
other than what is implies it's an open

1251
00:48:42,960 --> 00:48:44,460
question I

1252
00:48:44,460 --> 00:48:47,339
uh okay to be honest I don't know I mean

1253
00:48:47,339 --> 00:48:49,079
so there

1254
00:48:49,079 --> 00:48:49,859
um

1255
00:48:49,859 --> 00:48:52,880
there are

1256
00:48:53,220 --> 00:48:55,280
there is a lot of space for tweaking

1257
00:48:55,280 --> 00:48:57,960
parameters and then they may fit

1258
00:48:57,960 --> 00:49:00,119
different practical applications because

1259
00:49:00,119 --> 00:49:03,060
all these current implications that we

1260
00:49:03,060 --> 00:49:05,880
have are at the Primitive level but for

1261
00:49:05,880 --> 00:49:07,400
applications so

1262
00:49:07,400 --> 00:49:10,440
so one primitive could could have

1263
00:49:10,440 --> 00:49:12,180
implications in many practical

1264
00:49:12,180 --> 00:49:14,640
applications so yeah it's not a

1265
00:49:14,640 --> 00:49:16,740
satisfactory answer sorry

1266
00:49:16,740 --> 00:49:19,140
but it thanks a lot

1267
00:49:19,140 --> 00:49:21,300
so thank you very much for attending

1268
00:49:21,300 --> 00:49:22,740
your Crypt and in particular this

1269
00:49:22,740 --> 00:49:27,319
session and have a safe travel back

1270
00:49:27,330 --> 00:49:37,049
[Applause]

1271
00:49:54,000 --> 00:49:56,540
hello hello

