1
00:00:00,000 --> 00:00:01,680
it is on right now okay hello everyone

2
00:00:01,680 --> 00:00:04,500
welcome to the last session of the Euro

3
00:00:04,500 --> 00:00:07,259
 one of the two last sessions

4
00:00:07,259 --> 00:00:09,240
uh non-mallevel commitments and

5
00:00:09,240 --> 00:00:12,420
obfuscation so we have the first paper

6
00:00:12,420 --> 00:00:15,540
and presentation on non-uniform security

7
00:00:15,540 --> 00:00:17,699
for Black Box non-interactive CCA

8
00:00:17,699 --> 00:00:21,180
commitments by Rashid Garcia Corona

9
00:00:21,180 --> 00:00:23,340
George Lu and Brent Waters and Rashid

10
00:00:23,340 --> 00:00:26,000
will give the talk

11
00:00:26,580 --> 00:00:28,980
hi everyone I am rajat Garg and today

12
00:00:28,980 --> 00:00:30,180
I'm going to present our work

13
00:00:30,180 --> 00:00:32,460
non-uniform security for Black Box

14
00:00:32,460 --> 00:00:35,100
non-interactive CCA commitments it's a

15
00:00:35,100 --> 00:00:36,960
lot of words and I'll break down each of

16
00:00:36,960 --> 00:00:38,820
them while I'm giving the talk and this

17
00:00:38,820 --> 00:00:40,379
is Joint work with dakshita Karana

18
00:00:40,379 --> 00:00:43,140
George Liu and Brent Waters

19
00:00:43,140 --> 00:00:44,820
let's start with what our commitments

20
00:00:44,820 --> 00:00:46,620
commitments are a two round protocol

21
00:00:46,620 --> 00:00:49,260
between a two-phase protocol between two

22
00:00:49,260 --> 00:00:51,480
parties Alice and Bob the first phase is

23
00:00:51,480 --> 00:00:53,100
called the commit phase where Alice has

24
00:00:53,100 --> 00:00:55,260
a message M that she wants to commit to

25
00:00:55,260 --> 00:00:57,899
Bob so she puts her message inside this

26
00:00:57,899 --> 00:00:59,460
lock box so it's a physical world

27
00:00:59,460 --> 00:01:01,680
analogy and she sends this message to

28
00:01:01,680 --> 00:01:03,719
Bob so Bob has this message but he

29
00:01:03,719 --> 00:01:05,159
cannot read it because it's inside this

30
00:01:05,159 --> 00:01:06,299
lock box

31
00:01:06,299 --> 00:01:08,159
so the second phase is called the open

32
00:01:08,159 --> 00:01:11,040
phase where Alice has this key and then

33
00:01:11,040 --> 00:01:13,740
she sends it to Bob and Bob opens the

34
00:01:13,740 --> 00:01:15,840
message and reads it so there are two

35
00:01:15,840 --> 00:01:18,659
guarantees that we want we want uh

36
00:01:18,659 --> 00:01:20,460
hiding we're in the commit phase the

37
00:01:20,460 --> 00:01:22,860
message should be hidden to Bob and

38
00:01:22,860 --> 00:01:24,960
binding which says that Alice should not

39
00:01:24,960 --> 00:01:26,340
be able to open to a different message

40
00:01:26,340 --> 00:01:29,159
than what she originally intended

41
00:01:29,159 --> 00:01:31,920
this is applicable this is useful in

42
00:01:31,920 --> 00:01:34,560
time flipping auctions and multi-party

43
00:01:34,560 --> 00:01:36,659
computation in general let's look at

44
00:01:36,659 --> 00:01:37,860
auctions

45
00:01:37,860 --> 00:01:40,259
so

46
00:01:40,259 --> 00:01:42,420
sorry yeah so imagine you have three

47
00:01:42,420 --> 00:01:44,100
parties and all want to bid for some

48
00:01:44,100 --> 00:01:46,140
options so in this setting all these

49
00:01:46,140 --> 00:01:48,600
parties commit to some art piece which

50
00:01:48,600 --> 00:01:50,159
is like fifty dollars hundred dollars

51
00:01:50,159 --> 00:01:51,659
seventy five dollars and let's say

52
00:01:51,659 --> 00:01:53,340
Mallory wants and she really wants to

53
00:01:53,340 --> 00:01:56,159
win the auction and she comes in and she

54
00:01:56,159 --> 00:01:57,720
knows that like the party in the middle

55
00:01:57,720 --> 00:02:00,000
might be the one who might be bidding

56
00:02:00,000 --> 00:02:02,040
highest so she does not know what the

57
00:02:02,040 --> 00:02:03,780
party in The Middle's commitment is but

58
00:02:03,780 --> 00:02:05,340
somehow if she is able to model the

59
00:02:05,340 --> 00:02:07,500
commitment into a related commitment in

60
00:02:07,500 --> 00:02:09,538
this case one more she'll be able to win

61
00:02:09,538 --> 00:02:11,220
the auction with more information that

62
00:02:11,220 --> 00:02:13,560
she should have so this is undesirable

63
00:02:13,560 --> 00:02:16,440
and we such adversaries we'll call

64
00:02:16,440 --> 00:02:18,660
non-milleable adversaries

65
00:02:18,660 --> 00:02:20,220
so there's been a lot of work in

66
00:02:20,220 --> 00:02:21,840
building non-mallevel commitments in

67
00:02:21,840 --> 00:02:23,760
literature and we started with

68
00:02:23,760 --> 00:02:25,440
logarithmic run protocol from the

69
00:02:25,440 --> 00:02:28,860
seminal work of ddn in 1991 and we built

70
00:02:28,860 --> 00:02:30,900
this from one-way functions and since

71
00:02:30,900 --> 00:02:33,900
then we've had plenty of results where

72
00:02:33,900 --> 00:02:36,300
we've gotten three run protocols two

73
00:02:36,300 --> 00:02:38,040
round protocols and eventually

74
00:02:38,040 --> 00:02:40,260
non-interactive protocols so in

75
00:02:40,260 --> 00:02:41,940
non-interactive protocols there is only

76
00:02:41,940 --> 00:02:43,860
a single message sent from Alice to Bob

77
00:02:43,860 --> 00:02:45,360
in the commit phase and even in the open

78
00:02:45,360 --> 00:02:47,340
phase so there is no setup and there's

79
00:02:47,340 --> 00:02:49,739
only a single round of interaction

80
00:02:49,739 --> 00:02:51,540
and this is going to be the focus of

81
00:02:51,540 --> 00:02:53,459
this particular talk

82
00:02:53,459 --> 00:02:55,319
so how do we build these non-malleable

83
00:02:55,319 --> 00:02:57,060
commitments in this non-interactive

84
00:02:57,060 --> 00:02:58,800
world we start with any set of favorite

85
00:02:58,800 --> 00:03:00,420
cryptographic assumptions that you might

86
00:03:00,420 --> 00:03:02,580
have and we built this intermediate

87
00:03:02,580 --> 00:03:04,200
primitive which I'll call Tag

88
00:03:04,200 --> 00:03:07,260
commitments so all these prior Works

89
00:03:07,260 --> 00:03:08,760
follow this template that they first

90
00:03:08,760 --> 00:03:10,560
build this intermediate primitive tag

91
00:03:10,560 --> 00:03:12,599
commitments and this captures most of

92
00:03:12,599 --> 00:03:15,239
the flavor of non-mallability and then

93
00:03:15,239 --> 00:03:17,159
once we've built the stack commitments

94
00:03:17,159 --> 00:03:19,379
we do a transformation to get the full

95
00:03:19,379 --> 00:03:22,200
notion of non-mallebel commitments

96
00:03:22,200 --> 00:03:24,959
so I have a asterisk here so the caveat

97
00:03:24,959 --> 00:03:26,879
is that you need a one-time signature

98
00:03:26,879 --> 00:03:28,620
scheme which exists from one-way

99
00:03:28,620 --> 00:03:30,360
function so it's not that bad but the

100
00:03:30,360 --> 00:03:32,159
caveat the one that I really want to

101
00:03:32,159 --> 00:03:34,260
point out is for the stack commitment

102
00:03:34,260 --> 00:03:36,480
scheme you need exponentially many tags

103
00:03:36,480 --> 00:03:39,120
for this transformation to work and let

104
00:03:39,120 --> 00:03:40,920
me tell you what these tag commitments

105
00:03:40,920 --> 00:03:44,400
are so these check in attack commitment

106
00:03:44,400 --> 00:03:45,959
your algorithm is slightly different

107
00:03:45,959 --> 00:03:47,760
than what I originally showed you so

108
00:03:47,760 --> 00:03:49,680
instead of a commit taking a message

109
00:03:49,680 --> 00:03:51,540
with some Randomness it also takes this

110
00:03:51,540 --> 00:03:55,440
tag and similarly open also takes a tag

111
00:03:55,440 --> 00:03:56,340
value

112
00:03:56,340 --> 00:04:00,239
and uh corrector says that once uh these

113
00:04:00,239 --> 00:04:01,500
two tags match you should be able to

114
00:04:01,500 --> 00:04:03,720
open the message and you have the same

115
00:04:03,720 --> 00:04:05,360
hiding and binding

116
00:04:05,360 --> 00:04:07,980
guarantees where commit says that it

117
00:04:07,980 --> 00:04:10,680
should hide the message M and binding

118
00:04:10,680 --> 00:04:12,599
says that you should not be able to open

119
00:04:12,599 --> 00:04:14,879
uh to a different message and in this

120
00:04:14,879 --> 00:04:16,620
chart we'll only focus on this notion of

121
00:04:16,620 --> 00:04:18,839
perfect binding which means that there

122
00:04:18,839 --> 00:04:21,959
will never exist another opening

123
00:04:21,959 --> 00:04:24,660
so the non malleable adversaries in this

124
00:04:24,660 --> 00:04:28,620
man in the middle uh in this scenario is

125
00:04:28,620 --> 00:04:30,479
a man in the Middle where it's reading

126
00:04:30,479 --> 00:04:31,740
messages on the left and trying to

127
00:04:31,740 --> 00:04:33,780
commit something on the right to Bob

128
00:04:33,780 --> 00:04:37,199
so because in the Stag notion now uh

129
00:04:37,199 --> 00:04:39,240
while they're committing Alice's tag is

130
00:04:39,240 --> 00:04:40,500
going to be attached in this commitment

131
00:04:40,500 --> 00:04:41,460
message

132
00:04:41,460 --> 00:04:43,500
and what we want is like we shouldn't be

133
00:04:43,500 --> 00:04:45,240
allow

134
00:04:45,240 --> 00:04:47,580
some party to commit 200 to like let's

135
00:04:47,580 --> 00:04:49,979
say 101. so basically the important

136
00:04:49,979 --> 00:04:51,900
thing is if we are committing on the

137
00:04:51,900 --> 00:04:53,580
left to a message M and committing on

138
00:04:53,580 --> 00:04:55,919
the right to a message M Dash then M

139
00:04:55,919 --> 00:04:58,080
Dash must not be related to M whenever

140
00:04:58,080 --> 00:04:59,820
this challenge tag is different so

141
00:04:59,820 --> 00:05:01,560
whenever tag is not equal to tag star

142
00:05:01,560 --> 00:05:03,720
which is important this guarantee should

143
00:05:03,720 --> 00:05:05,460
hold so it captures most of the non

144
00:05:05,460 --> 00:05:07,440
malleability property

145
00:05:07,440 --> 00:05:08,759
so how do you build these stack

146
00:05:08,759 --> 00:05:10,979
commitments you start with these

147
00:05:10,979 --> 00:05:13,259
assumptions and you end up building

148
00:05:13,259 --> 00:05:16,500
first a scheme for C log log Lambda many

149
00:05:16,500 --> 00:05:19,320
tags and then you do a tag amplification

150
00:05:19,320 --> 00:05:20,880
procedure and you build it for

151
00:05:20,880 --> 00:05:22,620
exponentially many tags which is true to

152
00:05:22,620 --> 00:05:24,660
the power Lambda many tags so the stack

153
00:05:24,660 --> 00:05:26,940
amplification procedure which exists for

154
00:05:26,940 --> 00:05:30,000
all these schemes is very important

155
00:05:30,000 --> 00:05:32,000
so how do you do this very important tag

156
00:05:32,000 --> 00:05:34,560
amplification procedure most of the

157
00:05:34,560 --> 00:05:36,419
prior Works they use either

158
00:05:36,419 --> 00:05:38,300
non-interactive witnessing

159
00:05:38,300 --> 00:05:40,440
indistinguishable proofs or

160
00:05:40,440 --> 00:05:43,320
sub-exponential i o so you don't know

161
00:05:43,320 --> 00:05:45,600
need to know what navies are but the

162
00:05:45,600 --> 00:05:48,180
point is that using Nevis and IO makes

163
00:05:48,180 --> 00:05:51,000
you use non-black box use of crypto and

164
00:05:51,000 --> 00:05:52,919
this leads to inefficiency because you

165
00:05:52,919 --> 00:05:54,780
actually need to write the code and it's

166
00:05:54,780 --> 00:05:57,000
much more complement complicated to

167
00:05:57,000 --> 00:05:59,880
implement and additionally Navy's and IO

168
00:05:59,880 --> 00:06:01,440
you only know from a very specific set

169
00:06:01,440 --> 00:06:04,380
of assumptions and navies you know from

170
00:06:04,380 --> 00:06:06,360
bilinear Maps or D randomization

171
00:06:06,360 --> 00:06:08,759
assumption and bilinear maps are broken

172
00:06:08,759 --> 00:06:12,479
are not secure post quantumly so you

173
00:06:12,479 --> 00:06:13,979
really want to expand on the number of

174
00:06:13,979 --> 00:06:15,720
assumptions you know while making Black

175
00:06:15,720 --> 00:06:18,740
Box use of crypto

176
00:06:18,960 --> 00:06:20,639
um in an earlier work we had in 2021

177
00:06:20,639 --> 00:06:22,580
with the same set of authors we actually

178
00:06:22,580 --> 00:06:25,740
showed how to remove nivi's and IO but

179
00:06:25,740 --> 00:06:27,780
the caveat there we was that we were

180
00:06:27,780 --> 00:06:30,180
only able to show security for uniform

181
00:06:30,180 --> 00:06:32,039
adversaries

182
00:06:32,039 --> 00:06:36,240
so uh let me just explain why in our

183
00:06:36,240 --> 00:06:37,620
work we're going to try to get security

184
00:06:37,620 --> 00:06:40,440
against non-uniform adversities and why

185
00:06:40,440 --> 00:06:42,780
do we want that non-uniform adversaries

186
00:06:42,780 --> 00:06:45,300
is a stronger model of computation of

187
00:06:45,300 --> 00:06:47,039
adversarial uh

188
00:06:47,039 --> 00:06:49,080
a security where the adversary might

189
00:06:49,080 --> 00:06:51,240
have access to some advice string and

190
00:06:51,240 --> 00:06:52,860
still it's required that the security

191
00:06:52,860 --> 00:06:55,199
should hold and if we prove security

192
00:06:55,199 --> 00:06:57,479
against uh non-uniform adversaries we'll

193
00:06:57,479 --> 00:06:58,979
get a stronger composition theorem

194
00:06:58,979 --> 00:07:00,180
because when you're going to use these

195
00:07:00,180 --> 00:07:01,740
non-allible commitments inside your

196
00:07:01,740 --> 00:07:03,660
favorite MPC protocol you're going to

197
00:07:03,660 --> 00:07:06,300
get a better guarantee on your schemes

198
00:07:06,300 --> 00:07:08,280
secondly sometimes when building these

199
00:07:08,280 --> 00:07:10,220
MPC protocols you might require

200
00:07:10,220 --> 00:07:12,660
non-malliability against non-uniform

201
00:07:12,660 --> 00:07:14,580
adversaries for the security proof to

202
00:07:14,580 --> 00:07:16,500
work out so just to build the scheme you

203
00:07:16,500 --> 00:07:18,780
might need a non uh security against

204
00:07:18,780 --> 00:07:20,819
non-uniform adversaries

205
00:07:20,819 --> 00:07:23,280
and just to reiterate so we are in this

206
00:07:23,280 --> 00:07:24,419
non-interactive setting where we're

207
00:07:24,419 --> 00:07:26,460
making black boxes of crypto and there

208
00:07:26,460 --> 00:07:29,639
is no setup no CRS no random Oracle

209
00:07:29,639 --> 00:07:33,300
okay so great now we're on our result so

210
00:07:33,300 --> 00:07:34,680
we built we show how to build

211
00:07:34,680 --> 00:07:35,940
non-interactive non-mallieable

212
00:07:35,940 --> 00:07:37,500
commitments specifically a tag

213
00:07:37,500 --> 00:07:39,539
amplification procedure where we start

214
00:07:39,539 --> 00:07:41,639
from like log log Lambda many tags and

215
00:07:41,639 --> 00:07:43,440
we amplify it to two total Lambda many

216
00:07:43,440 --> 00:07:45,180
tags and we prove security against

217
00:07:45,180 --> 00:07:47,280
non-uniform adversaries

218
00:07:47,280 --> 00:07:49,919
and we make black box use of crypto and

219
00:07:49,919 --> 00:07:51,960
we avoid navies and IO

220
00:07:51,960 --> 00:07:55,020
and you know you might ask me okay this

221
00:07:55,020 --> 00:07:56,699
is non-manual commitment I might not be

222
00:07:56,699 --> 00:07:58,380
familiar with it and there's a huge

223
00:07:58,380 --> 00:08:00,780
literature behind it so I additionally

224
00:08:00,780 --> 00:08:03,360
want you to see our result as a way of

225
00:08:03,360 --> 00:08:06,060
doing consistency checks so in like many

226
00:08:06,060 --> 00:08:08,819
MPC protocols you often require like

227
00:08:08,819 --> 00:08:10,199
when we're dealing with malicious

228
00:08:10,199 --> 00:08:12,479
adversaries that we prove some sort of

229
00:08:12,479 --> 00:08:14,639
computation check and make sure that the

230
00:08:14,639 --> 00:08:15,840
adversary is actually doing the

231
00:08:15,840 --> 00:08:18,419
computation correctly and I see as our

232
00:08:18,419 --> 00:08:20,039
technique being more applicable to even

233
00:08:20,039 --> 00:08:22,860
other scenarios where you can uh to and

234
00:08:22,860 --> 00:08:24,660
set up this sort of consistency checks

235
00:08:24,660 --> 00:08:26,759
and it might be applicable in other

236
00:08:26,759 --> 00:08:28,860
areas as well

237
00:08:28,860 --> 00:08:30,660
so great now that I've convinced you

238
00:08:30,660 --> 00:08:32,580
that you know even if you don't know not

239
00:08:32,580 --> 00:08:34,620
malleable commitments like you should be

240
00:08:34,620 --> 00:08:36,839
reading our paper let me make our your

241
00:08:36,839 --> 00:08:38,880
job easier and describe the main

242
00:08:38,880 --> 00:08:42,479
techniques so in our in our paper we're

243
00:08:42,479 --> 00:08:43,679
gonna when we're considering

244
00:08:43,679 --> 00:08:45,180
non-mallieable adversaries we're going

245
00:08:45,180 --> 00:08:48,300
to model them as CCA uh in the CC

246
00:08:48,300 --> 00:08:50,459
experiment CCA is chosen ciphertech

247
00:08:50,459 --> 00:08:52,440
security and if you're familiar with

248
00:08:52,440 --> 00:08:54,420
chosen ciphertext a security in the

249
00:08:54,420 --> 00:08:56,220
encryption setting this looks very

250
00:08:56,220 --> 00:08:57,959
similar

251
00:08:57,959 --> 00:09:00,240
so in this setting uh the adversary is

252
00:09:00,240 --> 00:09:01,560
going to have access to this

253
00:09:01,560 --> 00:09:02,940
decommitment article or I'm going to

254
00:09:02,940 --> 00:09:04,740
call this the Val Oracle which is

255
00:09:04,740 --> 00:09:06,240
basically functioning like a decryption

256
00:09:06,240 --> 00:09:08,279
Oracle so this Val Oracle gets a

257
00:09:08,279 --> 00:09:09,899
commitment C and then it gets the

258
00:09:09,899 --> 00:09:12,000
underlying message inside the commitment

259
00:09:12,000 --> 00:09:14,399
so in the experiment uh you can and this

260
00:09:14,399 --> 00:09:16,260
while article might be efficient so you

261
00:09:16,260 --> 00:09:17,760
can imagine underlying the underlying

262
00:09:17,760 --> 00:09:19,620
implementation of the file article might

263
00:09:19,620 --> 00:09:21,300
be like a very inefficient Brute Force

264
00:09:21,300 --> 00:09:23,339
opening

265
00:09:23,339 --> 00:09:25,980
so the experiment the Challenger uh the

266
00:09:25,980 --> 00:09:27,360
adversary sounds like a challenge tax

267
00:09:27,360 --> 00:09:29,399
star which it wants to when the security

268
00:09:29,399 --> 00:09:31,860
came on it gets you ask these Val Oracle

269
00:09:31,860 --> 00:09:33,899
queries and notice that you're only

270
00:09:33,899 --> 00:09:36,660
opening if the challenge commitment is

271
00:09:36,660 --> 00:09:38,760
different so if it asks the commitment

272
00:09:38,760 --> 00:09:41,820
if it asks you to open Brute Force open

273
00:09:41,820 --> 00:09:43,440
this Val Oracle on a different tag only

274
00:09:43,440 --> 00:09:45,540
then you open

275
00:09:45,540 --> 00:09:47,760
and then uh the adversary sends two

276
00:09:47,760 --> 00:09:50,640
messages M Star 0 m star one gets an uh

277
00:09:50,640 --> 00:09:52,980
commitment on one of them and again

278
00:09:52,980 --> 00:09:55,320
makes Oracle queries and in the end the

279
00:09:55,320 --> 00:09:57,120
adversary wins the game if it is able to

280
00:09:57,120 --> 00:09:59,279
guess correctly so it's the classic CC

281
00:09:59,279 --> 00:10:02,060
experiment game

282
00:10:02,279 --> 00:10:05,040
great now that we've uh sort of

283
00:10:05,040 --> 00:10:07,260
described what the main security game is

284
00:10:07,260 --> 00:10:10,260
let me show you the construction so

285
00:10:10,260 --> 00:10:12,300
there's a tag amplification procedure

286
00:10:12,300 --> 00:10:13,920
where you want to go from log log Lambda

287
00:10:13,920 --> 00:10:15,240
many tags to two to the power Lambda

288
00:10:15,240 --> 00:10:16,680
many tags and we're going to do it in

289
00:10:16,680 --> 00:10:18,120
stages we're going to do an

290
00:10:18,120 --> 00:10:20,519
exponentiation once and so we get to log

291
00:10:20,519 --> 00:10:21,959
Lambda and then we're going to do it two

292
00:10:21,959 --> 00:10:23,700
to two more times to get Lambda and

293
00:10:23,700 --> 00:10:26,100
finally two to the Lambda

294
00:10:26,100 --> 00:10:28,200
so how to do it so imagine for this

295
00:10:28,200 --> 00:10:29,820
Choice setting like let's say you have

296
00:10:29,820 --> 00:10:32,459
this big tag commitment uh where this

297
00:10:32,459 --> 00:10:35,640
tag is five bits so the space of your

298
00:10:35,640 --> 00:10:38,339
possible tax is 2 to the power 532 and

299
00:10:38,339 --> 00:10:40,019
you want to use a small attack scheme to

300
00:10:40,019 --> 00:10:43,380
build this so in this uh we I'm going to

301
00:10:43,380 --> 00:10:45,300
have 10 the smaller space is going to be

302
00:10:45,300 --> 00:10:46,740
10 many tags long where the first

303
00:10:46,740 --> 00:10:48,899
position is either a zero one and

304
00:10:48,899 --> 00:10:50,399
there's five possible values for the

305
00:10:50,399 --> 00:10:51,600
second

306
00:10:51,600 --> 00:10:53,579
so how to build this I'm going to do a

307
00:10:53,579 --> 00:10:55,500
standard bit uh decomposition thing

308
00:10:55,500 --> 00:10:58,380
where I'm going to encode my big tag

309
00:10:58,380 --> 00:11:00,839
into these small tags and so basically

310
00:11:00,839 --> 00:11:03,300
here the position one has bit one

311
00:11:03,300 --> 00:11:05,279
position two has bit one position three

312
00:11:05,279 --> 00:11:07,320
has Bit Zero and basically I'm encoding

313
00:11:07,320 --> 00:11:10,140
this in in the small tags

314
00:11:10,140 --> 00:11:12,660
so my amplification procedure is

315
00:11:12,660 --> 00:11:14,579
basically going to be all these

316
00:11:14,579 --> 00:11:17,160
commitments on these uh small tags but

317
00:11:17,160 --> 00:11:20,459
notice that I need to make sure that the

318
00:11:20,459 --> 00:11:22,740
adversary or the committer is not doing

319
00:11:22,740 --> 00:11:24,600
something funny so I actually need to

320
00:11:24,600 --> 00:11:26,940
introduce a proof of consistency to make

321
00:11:26,940 --> 00:11:29,160
sure that all these messages all these

322
00:11:29,160 --> 00:11:31,079
commitments are on the same underlying

323
00:11:31,079 --> 00:11:31,980
message

324
00:11:31,980 --> 00:11:35,160
and this you can use uh music proofs or

325
00:11:35,160 --> 00:11:37,260
any sort of proof of consistency but you

326
00:11:37,260 --> 00:11:38,940
don't want to use music to do this

327
00:11:38,940 --> 00:11:41,100
because musics don't exist without setup

328
00:11:41,100 --> 00:11:42,720
so and we're really in this

329
00:11:42,720 --> 00:11:44,220
non-interactive setting where we want no

330
00:11:44,220 --> 00:11:47,640
setup so prior Books use navies or which

331
00:11:47,640 --> 00:11:50,820
are weaker primitive or we use hinting

332
00:11:50,820 --> 00:11:53,700
prgs and other techniques

333
00:11:53,700 --> 00:11:57,060
but uh the exact details of uh how we do

334
00:11:57,060 --> 00:11:58,860
this consistency check is not important

335
00:11:58,860 --> 00:12:01,019
for this high level explanation of the

336
00:12:01,019 --> 00:12:03,360
talk but no only note that there is some

337
00:12:03,360 --> 00:12:06,420
sort of consistency check involved here

338
00:12:06,420 --> 00:12:08,399
so we have this challenge commitment and

339
00:12:08,399 --> 00:12:10,560
we have this proof of consistency how

340
00:12:10,560 --> 00:12:12,480
does the security proof look so the

341
00:12:12,480 --> 00:12:14,100
security proof to describe the security

342
00:12:14,100 --> 00:12:15,899
proof I have to describe to you what the

343
00:12:15,899 --> 00:12:18,180
vowel Oracle does so the Val Oracle is a

344
00:12:18,180 --> 00:12:19,980
brute force a sort of article which

345
00:12:19,980 --> 00:12:22,260
opens it so in this setting the while

346
00:12:22,260 --> 00:12:24,600
Oracle what it can do is it first checks

347
00:12:24,600 --> 00:12:26,700
if the proof is consistent and once it's

348
00:12:26,700 --> 00:12:28,560
checked that the proof is consistent it

349
00:12:28,560 --> 00:12:30,540
can sort of open the underlying

350
00:12:30,540 --> 00:12:31,920
commitment or any of the small Val

351
00:12:31,920 --> 00:12:34,200
oracles so I'm defining this Val Oracle

352
00:12:34,200 --> 00:12:37,680
based on this smaller well Oracle

353
00:12:37,680 --> 00:12:41,760
okay so uh my main step of the proof is

354
00:12:41,760 --> 00:12:44,820
would be to change how I set up my uh

355
00:12:44,820 --> 00:12:46,440
how to respond this while Oracle queries

356
00:12:46,440 --> 00:12:48,720
so earlier this value Oracle queries was

357
00:12:48,720 --> 00:12:51,060
opening it under the first stack tag one

358
00:12:51,060 --> 00:12:54,120
so when it gets this big tag it can it

359
00:12:54,120 --> 00:12:57,120
it's a bit decomposition so you're only

360
00:12:57,120 --> 00:12:58,800
going to pick the first small tag first

361
00:12:58,800 --> 00:13:00,420
position I'm going to open it under that

362
00:13:00,420 --> 00:13:02,399
but I can I could have chosen to open it

363
00:13:02,399 --> 00:13:05,579
under any any commitment that I wanted

364
00:13:05,579 --> 00:13:07,500
so that's going to be my first hybrid

365
00:13:07,500 --> 00:13:10,500
change I'm once I get a Val Oracle query

366
00:13:10,500 --> 00:13:12,660
I'm going to open it under a different

367
00:13:12,660 --> 00:13:16,139
tag tag J where that J is different from

368
00:13:16,139 --> 00:13:17,760
The Challenge commitment so notice that

369
00:13:17,760 --> 00:13:19,560
whenever adversary queries in the

370
00:13:19,560 --> 00:13:21,420
security game it's going to query on a

371
00:13:21,420 --> 00:13:22,860
tag which is different than the

372
00:13:22,860 --> 00:13:24,420
challenge tag and because it's different

373
00:13:24,420 --> 00:13:25,800
than a challenge stack there's always

374
00:13:25,800 --> 00:13:27,240
going to be one position which is going

375
00:13:27,240 --> 00:13:28,860
to be different and because there's one

376
00:13:28,860 --> 00:13:31,079
position which is different now I can go

377
00:13:31,079 --> 00:13:33,180
in a security game where whenever I'm

378
00:13:33,180 --> 00:13:35,459
opening using my Val Oracle I'm all like

379
00:13:35,459 --> 00:13:37,980
always differing at like one I'm never

380
00:13:37,980 --> 00:13:40,380
opening under the challenge tag so I'm

381
00:13:40,380 --> 00:13:42,660
never going to open on Tax star one tax

382
00:13:42,660 --> 00:13:44,639
star two textile three I'm always going

383
00:13:44,639 --> 00:13:46,740
to be opening on a different tags and

384
00:13:46,740 --> 00:13:48,899
once I've made this change then I can

385
00:13:48,899 --> 00:13:51,120
change the underlying messages to zero

386
00:13:51,120 --> 00:13:53,160
using the uh security of the underlying

387
00:13:53,160 --> 00:13:55,680
non-mallible scheme and once this is

388
00:13:55,680 --> 00:13:57,240
done I have removed all information

389
00:13:57,240 --> 00:13:59,160
about the message and my scheme is

390
00:13:59,160 --> 00:14:00,540
secure

391
00:14:00,540 --> 00:14:02,940
so this is the high level template uh

392
00:14:02,940 --> 00:14:04,680
which basically there's a CCA game on

393
00:14:04,680 --> 00:14:07,200
big tag then you do uh change the while

394
00:14:07,200 --> 00:14:09,000
Oracle to open to a different tag than

395
00:14:09,000 --> 00:14:10,740
the challenge tag and once you've

396
00:14:10,740 --> 00:14:13,260
different uh set it up so such in such a

397
00:14:13,260 --> 00:14:15,000
way you can use the security of the

398
00:14:15,000 --> 00:14:17,880
underlying non-allible commitment scheme

399
00:14:17,880 --> 00:14:22,500
so in our paper in 2021 we do the first

400
00:14:22,500 --> 00:14:23,940
hybrid change the main security

401
00:14:23,940 --> 00:14:26,339
component that we used was a collision

402
00:14:26,339 --> 00:14:29,399
resistant hash function and these

403
00:14:29,399 --> 00:14:31,019
Collision lists in hash function you can

404
00:14:31,019 --> 00:14:32,880
imagine them as like shot 256 or

405
00:14:32,880 --> 00:14:36,720
something so basically uh it is a

406
00:14:36,720 --> 00:14:38,700
compressing function and it's hard for

407
00:14:38,700 --> 00:14:40,320
an anniversary to find two inputs which

408
00:14:40,320 --> 00:14:42,600
hash to the same value and it's called

409
00:14:42,600 --> 00:14:44,220
keyless because we don't want any setup

410
00:14:44,220 --> 00:14:45,899
and there is no setup for like a shot

411
00:14:45,899 --> 00:14:47,940
256.

412
00:14:47,940 --> 00:14:49,800
but note that this sort of primitive

413
00:14:49,800 --> 00:14:51,360
only makes sense in the uniform setting

414
00:14:51,360 --> 00:14:52,980
in the neon uniform setting it does not

415
00:14:52,980 --> 00:14:54,360
really make sense because if you have

416
00:14:54,360 --> 00:14:56,399
advice and it is a compressing function

417
00:14:56,399 --> 00:14:58,740
you can always there always exists some

418
00:14:58,740 --> 00:15:00,420
two values which has to the same thing

419
00:15:00,420 --> 00:15:02,220
so if there exists two values that have

420
00:15:02,220 --> 00:15:04,079
to the same thing the adversary can

421
00:15:04,079 --> 00:15:06,779
always find them

422
00:15:06,779 --> 00:15:09,899
so uh there is a how to do this in this

423
00:15:09,899 --> 00:15:12,120
non-uniform setting so there was a

424
00:15:12,120 --> 00:15:13,440
reason there's a primitive of

425
00:15:13,440 --> 00:15:15,240
non-uniform keyless Collision resistant

426
00:15:15,240 --> 00:15:17,040
hash function which was introduced by

427
00:15:17,040 --> 00:15:19,500
bitansky client in 2018 and Baton scale

428
00:15:19,500 --> 00:15:22,380
in 2018. which is a very natural

429
00:15:22,380 --> 00:15:25,019
extension of this notion so imagine that

430
00:15:25,019 --> 00:15:27,360
now the adversary has this advice where

431
00:15:27,360 --> 00:15:30,540
it's uh where we want originally we said

432
00:15:30,540 --> 00:15:32,399
that it's hard to find X1 and X2 which

433
00:15:32,399 --> 00:15:34,199
has the same value

434
00:15:34,199 --> 00:15:36,000
now we can ask that let's say if the

435
00:15:36,000 --> 00:15:38,220
adversity has s bit sort of advice then

436
00:15:38,220 --> 00:15:40,019
it's hard to find polynomically of many

437
00:15:40,019 --> 00:15:42,720
escalations so like you can imagine uh s

438
00:15:42,720 --> 00:15:44,279
Square many collisions or 2s many

439
00:15:44,279 --> 00:15:45,660
collisions where the number of

440
00:15:45,660 --> 00:15:47,100
collisions that you want is more than

441
00:15:47,100 --> 00:15:49,019
the number of advice that you have and

442
00:15:49,019 --> 00:15:50,459
this sort of primitive sort of makes

443
00:15:50,459 --> 00:15:53,459
sense in this non-uniform setting

444
00:15:53,459 --> 00:15:55,980
now the question is can we use this new

445
00:15:55,980 --> 00:15:57,660
primitive to actually do the reduction

446
00:15:57,660 --> 00:16:00,240
from our old uh Old Tag amplification

447
00:16:00,240 --> 00:16:03,000
procedure and here I want to make note

448
00:16:03,000 --> 00:16:05,519
that the way the original introduction

449
00:16:05,519 --> 00:16:07,860
worked was if you if you make good find

450
00:16:07,860 --> 00:16:10,380
a special commitment C star where the

451
00:16:10,380 --> 00:16:12,959
two oracles were uh sort of outputting

452
00:16:12,959 --> 00:16:14,519
something different then you could use

453
00:16:14,519 --> 00:16:16,620
this to build a reduction to show a

454
00:16:16,620 --> 00:16:19,440
collision hash function Collision

455
00:16:19,440 --> 00:16:21,540
but this is not possible in the uniform

456
00:16:21,540 --> 00:16:23,100
setting because in the uniform setting

457
00:16:23,100 --> 00:16:24,720
given advice you'll always be able to

458
00:16:24,720 --> 00:16:27,000
find collisions so how to set up this

459
00:16:27,000 --> 00:16:31,320
reduction and the main idea here is to

460
00:16:31,320 --> 00:16:33,480
set up this reduction if you find some

461
00:16:33,480 --> 00:16:36,060
commitments which are different I want

462
00:16:36,060 --> 00:16:38,880
to sort of link them with the

463
00:16:38,880 --> 00:16:42,120
corresponding collisions in a one-to-one

464
00:16:42,120 --> 00:16:43,440
injective way

465
00:16:43,440 --> 00:16:45,360
and once I link them in a one-to-one

466
00:16:45,360 --> 00:16:47,100
injector way I'll be able to set up my

467
00:16:47,100 --> 00:16:50,399
reduction so that uh once I had these

468
00:16:50,399 --> 00:16:51,899
special commitments which are differing

469
00:16:51,899 --> 00:16:53,519
uh

470
00:16:53,519 --> 00:16:55,019
you can output the collisions

471
00:16:55,019 --> 00:16:58,019
correspondingly and this injectivity is

472
00:16:58,019 --> 00:16:59,639
important but because if this didn't

473
00:16:59,639 --> 00:17:01,980
exist then there could be exponentially

474
00:17:01,980 --> 00:17:03,540
many uh

475
00:17:03,540 --> 00:17:05,459
even given constant number of collisions

476
00:17:05,459 --> 00:17:07,020
it could be exponentially many of these

477
00:17:07,020 --> 00:17:09,599
uh bad commitments so to set up an

478
00:17:09,599 --> 00:17:11,699
efficient relationship between given and

479
00:17:11,699 --> 00:17:13,559
your advice and the number of collisions

480
00:17:13,559 --> 00:17:15,119
that you output you need this sort of

481
00:17:15,119 --> 00:17:16,559
injectivity property

482
00:17:16,559 --> 00:17:19,319
and this is the main uh core technique

483
00:17:19,319 --> 00:17:22,140
that we introduced in our paper so just

484
00:17:22,140 --> 00:17:24,419
a brief list of ingredients in our oil

485
00:17:24,419 --> 00:17:26,400
work we used hinting prg and keyless

486
00:17:26,400 --> 00:17:29,040
Collision hash function hinting prgs are

487
00:17:29,040 --> 00:17:31,980
like special prgs where you're expanding

488
00:17:31,980 --> 00:17:34,140
your number of bits so imagine you have

489
00:17:34,140 --> 00:17:35,760
a seat s and you're outputting a bigger

490
00:17:35,760 --> 00:17:38,160
string on the right you don't need to

491
00:17:38,160 --> 00:17:39,539
know what exact special property is

492
00:17:39,539 --> 00:17:41,700
there but in our work we use hinting

493
00:17:41,700 --> 00:17:44,220
prgs with injective extension where

494
00:17:44,220 --> 00:17:45,960
along with this big seed now you output

495
00:17:45,960 --> 00:17:47,940
some injective information and use this

496
00:17:47,940 --> 00:17:50,220
to link between the special bad

497
00:17:50,220 --> 00:17:52,380
commitments where valerical differs to

498
00:17:52,380 --> 00:17:54,240
the exact positions between the hash

499
00:17:54,240 --> 00:17:55,679
function

500
00:17:55,679 --> 00:17:59,039
and these you can build from CDH or lwa

501
00:17:59,039 --> 00:18:01,140
and the second primitive is the ski less

502
00:18:01,140 --> 00:18:02,820
Collision hash function which has this

503
00:18:02,820 --> 00:18:04,980
property that given s bits of advice you

504
00:18:04,980 --> 00:18:07,860
should not be output more collisions

505
00:18:07,860 --> 00:18:10,320
so I'll just leave the results side uh

506
00:18:10,320 --> 00:18:13,200
on the on the page where we build this

507
00:18:13,200 --> 00:18:14,880
non-interactive non-allible commitments

508
00:18:14,880 --> 00:18:16,140
where we did a tag amplification

509
00:18:16,140 --> 00:18:17,940
procedure and proved security against

510
00:18:17,940 --> 00:18:20,640
non-uniform adversaries using these two

511
00:18:20,640 --> 00:18:24,090
objects so thank you

512
00:18:24,090 --> 00:18:28,129
[Applause]

513
00:18:29,880 --> 00:18:32,220
we talk any questions we have time for a

514
00:18:32,220 --> 00:18:34,820
question or two

515
00:18:37,200 --> 00:18:40,200
so maybe I'll ask one so you eventually

516
00:18:40,200 --> 00:18:43,340
get your construction based on say lwe

517
00:18:43,340 --> 00:18:45,960
if you want to get it from simpler

518
00:18:45,960 --> 00:18:47,640
assumptions whether whether the

519
00:18:47,640 --> 00:18:49,860
strongest barriers there

520
00:18:49,860 --> 00:18:51,720
yeah so there are multiples I have like

521
00:18:51,720 --> 00:18:54,000
an open question slide let me

522
00:18:54,000 --> 00:18:55,500
um

523
00:18:55,500 --> 00:18:56,760
so

524
00:18:56,760 --> 00:18:59,340
there are different axes of like open

525
00:18:59,340 --> 00:19:02,160
like assumptions that you can remove so

526
00:19:02,160 --> 00:19:03,539
there's the keyless Collision which is a

527
00:19:03,539 --> 00:19:05,460
half function right now we have like an

528
00:19:05,460 --> 00:19:07,559
uh dependence where we are asking that

529
00:19:07,559 --> 00:19:09,059
if you have S advice you should not be

530
00:19:09,059 --> 00:19:10,799
able to Output two as many collisions

531
00:19:10,799 --> 00:19:12,660
you could ask for a stronger assumption

532
00:19:12,660 --> 00:19:14,039
where you're saying F advice and S

533
00:19:14,039 --> 00:19:15,419
Square menu Collision or sq many

534
00:19:15,419 --> 00:19:18,000
Collision you can improve on that and uh

535
00:19:18,000 --> 00:19:19,799
there was this work so this works line

536
00:19:19,799 --> 00:19:21,780
of chart like this line of work started

537
00:19:21,780 --> 00:19:24,539
in like Copeland Waters in 2019 where

538
00:19:24,539 --> 00:19:28,320
this first showed CCA security uh of

539
00:19:28,320 --> 00:19:30,240
public encryption and then they were

540
00:19:30,240 --> 00:19:33,240
able to get a security instead of this

541
00:19:33,240 --> 00:19:36,179
hinting prgs or this lwcdh from like

542
00:19:36,179 --> 00:19:37,679
injective chapter functions which were a

543
00:19:37,679 --> 00:19:39,840
vehicle perimeter so maybe even those

544
00:19:39,840 --> 00:19:41,760
techniques can be applicable so there's

545
00:19:41,760 --> 00:19:43,380
both lines of like ingredients which

546
00:19:43,380 --> 00:19:46,260
maybe you can improve on thank you for

547
00:19:46,260 --> 00:19:48,000
also using this like a nice thank you

548
00:19:48,000 --> 00:19:50,520
thank you any other questions or we can

549
00:19:50,520 --> 00:19:52,020
move to the next talk less thanks to

550
00:19:52,020 --> 00:19:53,380
speak again

551
00:19:53,380 --> 00:19:57,579
[Applause]

552
00:20:18,480 --> 00:20:21,200
same thing

553
00:20:24,380 --> 00:20:28,500
no but uh the first one was

554
00:20:28,500 --> 00:20:32,240
it was just on the bus oh okay

555
00:20:49,440 --> 00:20:52,340
sorry okay

556
00:20:52,340 --> 00:20:55,080
all right okay maybe like candy do you

557
00:20:55,080 --> 00:20:57,179
just quickly to talk his polynomial time

558
00:20:57,179 --> 00:20:59,520
Crypt analysis of the Subspace flooding

559
00:20:59,520 --> 00:21:02,220
assumption for post Quantum IO by ayush

560
00:21:02,220 --> 00:21:05,100
chain with Glenn paulu and Amit sahai

561
00:21:05,100 --> 00:21:07,440
and Paul will give the talk great all

562
00:21:07,440 --> 00:21:10,260
right hi I'm Paul Lou and this is Joint

563
00:21:10,260 --> 00:21:12,419
work with my co-authors ayush Jane

564
00:21:12,419 --> 00:21:16,080
Rachel Lynn in amidst the high and right

565
00:21:16,080 --> 00:21:17,460
okay

566
00:21:17,460 --> 00:21:22,020
so what is Io Io takes a circuit c0 and

567
00:21:22,020 --> 00:21:24,840
produces a obfuscated c0 hat with

568
00:21:24,840 --> 00:21:26,760
exactly the same input output

569
00:21:26,760 --> 00:21:28,980
functionality and a security guarantee

570
00:21:28,980 --> 00:21:31,140
you get from i o is if I take two

571
00:21:31,140 --> 00:21:33,780
circuits c0 C1 that are functionally

572
00:21:33,780 --> 00:21:36,780
equivalent and of the same size then the

573
00:21:36,780 --> 00:21:39,179
obfuscated i o obfuscated versions of

574
00:21:39,179 --> 00:21:41,640
the circuits c0 hat and C1 hat are

575
00:21:41,640 --> 00:21:44,400
computationally indistinguishable

576
00:21:44,400 --> 00:21:46,919
and IO sits as a central Hub in

577
00:21:46,919 --> 00:21:49,919
cryptography namely i o implies both

578
00:21:49,919 --> 00:21:51,419
core Primitives as you see on the left

579
00:21:51,419 --> 00:21:54,480
hand side and New World Primitives on

580
00:21:54,480 --> 00:21:56,159
the right hand side and for many of

581
00:21:56,159 --> 00:21:57,720
these new world Primitives we actually

582
00:21:57,720 --> 00:22:00,360
don't know how to achieve them without i

583
00:22:00,360 --> 00:22:02,760
o so iOS it's really as a as a central

584
00:22:02,760 --> 00:22:06,299
player in cryptography

585
00:22:06,299 --> 00:22:09,659
and more so recent work by Jane Lynn

586
00:22:09,659 --> 00:22:13,260
Lowe and Wix in 2022 show that in this

587
00:22:13,260 --> 00:22:15,780
pseudo-random Oracle model you can take

588
00:22:15,780 --> 00:22:18,360
IO and actually build ideal obfuscation

589
00:22:18,360 --> 00:22:20,039
in the pseudo-anomorical model so this

590
00:22:20,039 --> 00:22:22,559
is not in the plane model and in fact

591
00:22:22,559 --> 00:22:24,419
the pseudonym Oracle model can be

592
00:22:24,419 --> 00:22:26,039
heuristically instantiated by a hash

593
00:22:26,039 --> 00:22:27,059
function

594
00:22:27,059 --> 00:22:28,679
so in other words you get some security

595
00:22:28,679 --> 00:22:30,120
guarantees that you would expect from

596
00:22:30,120 --> 00:22:32,400
ideal obfuscation which is simply you

597
00:22:32,400 --> 00:22:34,520
imagine all the parties having Oracle

598
00:22:34,520 --> 00:22:37,919
input output query or Oracle access to

599
00:22:37,919 --> 00:22:39,539
this function so this is a very strong

600
00:22:39,539 --> 00:22:41,700
form of obfuscation

601
00:22:41,700 --> 00:22:43,559
and ideal obfuscation actually implies

602
00:22:43,559 --> 00:22:45,659
even more cryptographic Primitives

603
00:22:45,659 --> 00:22:47,340
I'm not going to list them but there's a

604
00:22:47,340 --> 00:22:48,120
lot

605
00:22:48,120 --> 00:22:50,640
and it provides meaningful security

606
00:22:50,640 --> 00:22:52,559
guarantees even for things such as

607
00:22:52,559 --> 00:22:54,720
machine learning models so as an example

608
00:22:54,720 --> 00:22:57,600
imagine we have chat gpt23 which is a

609
00:22:57,600 --> 00:22:58,799
personal assistant that you carry around

610
00:22:58,799 --> 00:23:01,200
in your pocket and you know it's your

611
00:23:01,200 --> 00:23:04,039
mental health it's your whatever advisor

612
00:23:04,039 --> 00:23:06,120
and it knows all your deepest and

613
00:23:06,120 --> 00:23:07,980
darkest Secrets if you were to lose it

614
00:23:07,980 --> 00:23:11,039
or someone were to take this device the

615
00:23:11,039 --> 00:23:12,480
ideal obfuscate version could be

616
00:23:12,480 --> 00:23:15,299
tortured and yet reveal nothing Beyond

617
00:23:15,299 --> 00:23:18,659
just the input output Behavior

618
00:23:18,659 --> 00:23:20,640
and there was a long line of Works

619
00:23:20,640 --> 00:23:22,860
attempting to put io on solid

620
00:23:22,860 --> 00:23:24,960
foundations and this really culminated

621
00:23:24,960 --> 00:23:27,840
in the work by Jane Lynn sahi in 2020

622
00:23:27,840 --> 00:23:30,900
where they show that using a long line

623
00:23:30,900 --> 00:23:33,539
of works you can actually get IO from

624
00:23:33,539 --> 00:23:35,460
these four assumptions and they later

625
00:23:35,460 --> 00:23:37,320
follow this up by removing the need for

626
00:23:37,320 --> 00:23:40,020
lwe unfortunately one of these

627
00:23:40,020 --> 00:23:41,880
assumptions dealing over bilinear groups

628
00:23:41,880 --> 00:23:43,919
plays a very Central role in the

629
00:23:43,919 --> 00:23:46,559
construction and it's Quantum broken by

630
00:23:46,559 --> 00:23:48,419
Shores algorithm

631
00:23:48,419 --> 00:23:50,940
and so we'd really like to get some sort

632
00:23:50,940 --> 00:23:53,940
of post Quantum IO and there's been a

633
00:23:53,940 --> 00:23:56,100
lot of work on plausibly post Quantum

634
00:23:56,100 --> 00:23:58,679
constructions there have been works from

635
00:23:58,679 --> 00:24:01,140
multilinear Maps tensor products noisy

636
00:24:01,140 --> 00:24:02,520
linear functional encryption I find

637
00:24:02,520 --> 00:24:04,620
determinant programs and the split fhe

638
00:24:04,620 --> 00:24:07,260
Paradigm and in many of these works the

639
00:24:07,260 --> 00:24:08,760
problem here is that there's no

640
00:24:08,760 --> 00:24:10,799
reduction to simple falsifiable

641
00:24:10,799 --> 00:24:13,380
assumptions and there's these two Works

642
00:24:13,380 --> 00:24:15,480
later that instantiated the split fhe

643
00:24:15,480 --> 00:24:17,880
Paradigm one was by gay in past 2020 and

644
00:24:17,880 --> 00:24:19,799
a follow-up by the same authors on the

645
00:24:19,799 --> 00:24:21,299
gay and past paper which was this

646
00:24:21,299 --> 00:24:23,400
shielded Randomness leakage assumption

647
00:24:23,400 --> 00:24:25,440
and here we have a circuit dependent

648
00:24:25,440 --> 00:24:27,600
hardness assumption so each circuit

649
00:24:27,600 --> 00:24:29,520
being obfuscated actually gives a

650
00:24:29,520 --> 00:24:30,960
different hardness assumption this makes

651
00:24:30,960 --> 00:24:33,360
it very difficult to crypto analyze and

652
00:24:33,360 --> 00:24:35,159
in fact this assumption has an explicit

653
00:24:35,159 --> 00:24:37,679
counter example given to it by Hopkins

654
00:24:37,679 --> 00:24:39,720
at all in 2021 and this is not an attack

655
00:24:39,720 --> 00:24:41,340
on the obfuscation scheme just an attack

656
00:24:41,340 --> 00:24:43,799
on the assumption

657
00:24:43,799 --> 00:24:47,700
similarly we Wix in 2020 introduced this

658
00:24:47,700 --> 00:24:49,799
homomorphic pseudo-random LW sample

659
00:24:49,799 --> 00:24:51,780
assumption and here in their assumption

660
00:24:51,780 --> 00:24:53,880
they had an unspecified circuit

661
00:24:53,880 --> 00:24:55,919
implementation of a prf and again this

662
00:24:55,919 --> 00:24:57,419
was exploited to give an attack by

663
00:24:57,419 --> 00:24:59,700
Hopkins Adele in 2021 and again this is

664
00:24:59,700 --> 00:25:01,140
not an attack on the obfuscation scheme

665
00:25:01,140 --> 00:25:04,080
they present just on the assumption and

666
00:25:04,080 --> 00:25:06,000
when you do specify such uh said

667
00:25:06,000 --> 00:25:08,220
circuits for the prf it becomes

668
00:25:08,220 --> 00:25:09,900
difficult to explicitly write down the

669
00:25:09,900 --> 00:25:12,360
error distribution and as a result it's

670
00:25:12,360 --> 00:25:14,640
very hard to encrypt to analyze

671
00:25:14,640 --> 00:25:16,260
so we have all these really beautiful

672
00:25:16,260 --> 00:25:18,480
post Quantum i o candidate constructions

673
00:25:18,480 --> 00:25:20,640
and what we would really like to do is

674
00:25:20,640 --> 00:25:24,240
use crypto analysis as a tool to refine

675
00:25:24,240 --> 00:25:25,799
our assumption and to understand this is

676
00:25:25,799 --> 00:25:27,840
the security of these assumptions and

677
00:25:27,840 --> 00:25:29,159
therefore when we construct these post

678
00:25:29,159 --> 00:25:31,440
Quantum i o candidates we actually need

679
00:25:31,440 --> 00:25:33,179
to make sure that we're able to

680
00:25:33,179 --> 00:25:35,640
facilitate cryptanalysis

681
00:25:35,640 --> 00:25:38,340
and a desiderata for such assumptions is

682
00:25:38,340 --> 00:25:42,240
one simple to state two falsifiable and

683
00:25:42,240 --> 00:25:43,919
three all parameters and circuits should

684
00:25:43,919 --> 00:25:45,900
be fully specified

685
00:25:45,900 --> 00:25:47,880
and towards this goal the work of

686
00:25:47,880 --> 00:25:50,220
davidus at all in 2021 presented a

687
00:25:50,220 --> 00:25:51,900
candidate construction for post Quantum

688
00:25:51,900 --> 00:25:54,299
IO whose security follows from something

689
00:25:54,299 --> 00:25:55,679
they introduced called the Subspace

690
00:25:55,679 --> 00:25:57,840
flooding assumption and this is the

691
00:25:57,840 --> 00:25:59,760
first fully specified and falsifiable

692
00:25:59,760 --> 00:26:01,380
assumption all the circuits and

693
00:26:01,380 --> 00:26:03,659
parameters are fully specified and and

694
00:26:03,659 --> 00:26:05,279
it's falsifiable

695
00:26:05,279 --> 00:26:07,380
the candidate construction is rather

696
00:26:07,380 --> 00:26:09,840
elegant and they also provide thorough

697
00:26:09,840 --> 00:26:12,480
crypto crypto analysis where they show

698
00:26:12,480 --> 00:26:14,159
that prior attacks such as rank attacks

699
00:26:14,159 --> 00:26:18,000
sum of square attacks these all fail

700
00:26:18,000 --> 00:26:20,159
and let me just flash the sub slice

701
00:26:20,159 --> 00:26:21,480
flooding assumption real quick you don't

702
00:26:21,480 --> 00:26:22,799
need to understand all the details I

703
00:26:22,799 --> 00:26:24,960
will just pick apart the parts that are

704
00:26:24,960 --> 00:26:27,360
important but you have effectively a

705
00:26:27,360 --> 00:26:29,100
bunch of matrices drawn from some

706
00:26:29,100 --> 00:26:31,799
distribution that hides this bit B which

707
00:26:31,799 --> 00:26:34,980
are highlight in green and the seed

708
00:26:34,980 --> 00:26:38,460
the seed B Star is a way of generating a

709
00:26:38,460 --> 00:26:41,640
pseudo-random lwe sample from a smaller

710
00:26:41,640 --> 00:26:43,980
expanding from a smaller number of bits

711
00:26:43,980 --> 00:26:46,980
to a larger uh or you can think of a

712
00:26:46,980 --> 00:26:49,320
smaller matrices to a larger lwe Matrix

713
00:26:49,320 --> 00:26:52,080
or pseudorandom LLB Matrix

714
00:26:52,080 --> 00:26:53,940
and critically the security property

715
00:26:53,940 --> 00:26:56,340
here is that this error that you get

716
00:26:56,340 --> 00:26:58,919
from expanding from a small seed to a

717
00:26:58,919 --> 00:27:01,320
pseudo-random lwe error should be able

718
00:27:01,320 --> 00:27:03,299
to drown out a specific error

719
00:27:03,299 --> 00:27:05,039
distribution so this is falsifiable

720
00:27:05,039 --> 00:27:06,299
because it's a specific error

721
00:27:06,299 --> 00:27:09,419
distribution and this is this uh

722
00:27:09,419 --> 00:27:11,100
specific error distribution you see here

723
00:27:11,100 --> 00:27:15,120
is eg inverse B hat of minus B times F

724
00:27:15,120 --> 00:27:17,460
where I'm not going to specify what any

725
00:27:17,460 --> 00:27:19,740
of these are but and I'm happy to answer

726
00:27:19,740 --> 00:27:21,779
any questions later

727
00:27:21,779 --> 00:27:24,480
so what does our work do our work shows

728
00:27:24,480 --> 00:27:27,059
the following theorem informally under

729
00:27:27,059 --> 00:27:28,980
reasonable conjecture when the bit is

730
00:27:28,980 --> 00:27:31,020
equal to zero there actually exists a

731
00:27:31,020 --> 00:27:33,419
full break where there's a PPT algorithm

732
00:27:33,419 --> 00:27:36,240
that recovers all the errors e i from

733
00:27:36,240 --> 00:27:37,620
the seat

734
00:27:37,620 --> 00:27:40,020
and as a corollary under heuristic

735
00:27:40,020 --> 00:27:42,299
argument we obtain a PPT distinguisher

736
00:27:42,299 --> 00:27:43,820
for the subsequence funding

737
00:27:43,820 --> 00:27:46,740
Subspace flooding assumption

738
00:27:46,740 --> 00:27:48,000
and let me describe to you what the

739
00:27:48,000 --> 00:27:50,820
conjecture is it's very mild suppose you

740
00:27:50,820 --> 00:27:53,400
have t many linearly independent vectors

741
00:27:53,400 --> 00:27:55,919
and I multiply left multiply all these

742
00:27:55,919 --> 00:27:59,400
vectors by some Matrix P whose height is

743
00:27:59,400 --> 00:28:01,799
much larger than the number of vectors

744
00:28:01,799 --> 00:28:03,840
then the conjecture is that these

745
00:28:03,840 --> 00:28:06,360
vectors remain linearly independent and

746
00:28:06,360 --> 00:28:08,760
what is these what is this Matrix P this

747
00:28:08,760 --> 00:28:11,520
Matrix P has entries drawn from some lwe

748
00:28:11,520 --> 00:28:12,840
error distribution say a discrete

749
00:28:12,840 --> 00:28:16,020
gaussian and this is in fact provable if

750
00:28:16,020 --> 00:28:18,059
you take the entries of P from a uniform

751
00:28:18,059 --> 00:28:21,179
distribution or a small bounded uniform

752
00:28:21,179 --> 00:28:23,460
distribution

753
00:28:23,460 --> 00:28:26,279
okay so let me motivate the dqvw21

754
00:28:26,279 --> 00:28:28,080
construction approach

755
00:28:28,080 --> 00:28:31,080
the work of Lynette Allen 2016 showed

756
00:28:31,080 --> 00:28:33,059
that any non-trivial compression of the

757
00:28:33,059 --> 00:28:35,700
truth table is enough to imply i o and

758
00:28:35,700 --> 00:28:37,799
that's what they called x i o and it's

759
00:28:37,799 --> 00:28:39,840
not hard to see that this that another

760
00:28:39,840 --> 00:28:41,400
notion named succinct randomizing

761
00:28:41,400 --> 00:28:44,640
codings implies x i o which implies IO

762
00:28:44,640 --> 00:28:46,980
therefore to build IO it suffices to

763
00:28:46,980 --> 00:28:48,840
build what we call succinct randomized

764
00:28:48,840 --> 00:28:50,880
encodings and what is this succinct

765
00:28:50,880 --> 00:28:53,220
randomizing coding it simply takes a

766
00:28:53,220 --> 00:28:55,440
function f from that takes L bits to

767
00:28:55,440 --> 00:28:57,779
capital n Bits and produces encoding

768
00:28:57,779 --> 00:29:00,360
that takes in the description of F and

769
00:29:00,360 --> 00:29:02,640
an input X and from this encoding you

770
00:29:02,640 --> 00:29:04,320
can recover f of x that's correctness

771
00:29:04,320 --> 00:29:06,600
and security says that if I take two

772
00:29:06,600 --> 00:29:09,480
inputs x0 and X1 who evaluate

773
00:29:09,480 --> 00:29:12,000
identically under F their encodings are

774
00:29:12,000 --> 00:29:13,860
computationally indistinguishable and

775
00:29:13,860 --> 00:29:15,240
for this notion to be non-trivial

776
00:29:15,240 --> 00:29:16,440
because otherwise you can make the

777
00:29:16,440 --> 00:29:18,779
encoding f of x itself you just need

778
00:29:18,779 --> 00:29:20,580
some compression on the encoding the

779
00:29:20,580 --> 00:29:22,799
length of the encoding better be smaller

780
00:29:22,799 --> 00:29:24,179
than the length of the output of the

781
00:29:24,179 --> 00:29:26,039
function

782
00:29:26,039 --> 00:29:28,799
and they construct this encoding scheme

783
00:29:28,799 --> 00:29:30,480
and you don't need to know the details

784
00:29:30,480 --> 00:29:33,000
here but I I I'm just going to highlight

785
00:29:33,000 --> 00:29:35,760
one part of this uh this encoding scheme

786
00:29:35,760 --> 00:29:37,620
so this encoding scheme takes the

787
00:29:37,620 --> 00:29:40,380
description of f an input X draws a

788
00:29:40,380 --> 00:29:43,260
random Matrix a produces a homomorphic

789
00:29:43,260 --> 00:29:46,200
commitment to X using this it's actually

790
00:29:46,200 --> 00:29:48,419
a pseudo-random h a pseudo random Matrix

791
00:29:48,419 --> 00:29:50,460
a but I'm going to gloss over this fact

792
00:29:50,460 --> 00:29:52,200
and you can think of this if you're

793
00:29:52,200 --> 00:29:54,960
familiar uh familiar with dual GSW this

794
00:29:54,960 --> 00:29:57,539
is some dual GSW based homomorphic

795
00:29:57,539 --> 00:29:59,460
commitment to X and then you're going to

796
00:29:59,460 --> 00:30:01,380
have some trapdoor this post evaluation

797
00:30:01,380 --> 00:30:02,760
Randomness that will allow you to

798
00:30:02,760 --> 00:30:07,140
recover f of x from the evaluation of

799
00:30:07,140 --> 00:30:09,120
the commitment and you're going to

800
00:30:09,120 --> 00:30:12,000
smudge this post value evaluation

801
00:30:12,000 --> 00:30:14,580
Randomness with some pseudo-random

802
00:30:14,580 --> 00:30:16,200
matrix it's not really a random Matrix

803
00:30:16,200 --> 00:30:19,320
this is some flooding Matrix and what is

804
00:30:19,320 --> 00:30:21,840
a and how are A and S star

805
00:30:21,840 --> 00:30:25,679
related to this CB star well seed B Star

806
00:30:25,679 --> 00:30:28,020
can be used to generate a pseudo-random

807
00:30:28,020 --> 00:30:31,020
lwa sample of the Form B Star equals a s

808
00:30:31,020 --> 00:30:33,600
Star Plus e star and a critical question

809
00:30:33,600 --> 00:30:36,720
that we ask is how do you generate a

810
00:30:36,720 --> 00:30:38,760
large pseudorandom lwe sample of this

811
00:30:38,760 --> 00:30:41,279
form from a small seed

812
00:30:41,279 --> 00:30:43,140
okay so you're going to take something

813
00:30:43,140 --> 00:30:45,120
that's rather short and you want to

814
00:30:45,120 --> 00:30:47,700
generate something that looks like a

815
00:30:47,700 --> 00:30:50,640
times s Star Plus e star where A and S

816
00:30:50,640 --> 00:30:54,299
star look random uniform random and E

817
00:30:54,299 --> 00:30:56,700
star has something that looks something

818
00:30:56,700 --> 00:30:58,559
like a discrete gaussian or some LW

819
00:30:58,559 --> 00:31:01,440
friendly error distribution

820
00:31:01,440 --> 00:31:04,440
and a natural approach that dqv ww21

821
00:31:04,440 --> 00:31:08,399
takes is tensoring suppose that the seed

822
00:31:08,399 --> 00:31:11,820
B Star just consists of two lwe matrices

823
00:31:11,820 --> 00:31:15,360
one is B1 and one is B2 and each of them

824
00:31:15,360 --> 00:31:18,720
of the form a i s i plus e i well a

825
00:31:18,720 --> 00:31:20,760
natural way to generate a larger LW

826
00:31:20,760 --> 00:31:23,039
sample is to just smash them together

827
00:31:23,039 --> 00:31:25,320
with a tensor and by the mixed product

828
00:31:25,320 --> 00:31:27,419
property of tensors you actually get

829
00:31:27,419 --> 00:31:29,940
this nice relation that we can have this

830
00:31:29,940 --> 00:31:32,279
block Matrix a star this block Matrix S

831
00:31:32,279 --> 00:31:34,500
star and the error the new error will

832
00:31:34,500 --> 00:31:37,940
just be E1 tensor E2

833
00:31:38,399 --> 00:31:41,580
and our attack critically exploits this

834
00:31:41,580 --> 00:31:44,039
tensoring operation and I'm going to

835
00:31:44,039 --> 00:31:46,080
provide you just some intuition about

836
00:31:46,080 --> 00:31:49,140
why tensor operations do not work well

837
00:31:49,140 --> 00:31:52,380
for producing larger lwe samples and

838
00:31:52,380 --> 00:31:53,880
this is a heavily watered down version

839
00:31:53,880 --> 00:31:55,620
of our attack but I think it will

840
00:31:55,620 --> 00:31:57,299
provide some intuition for the

841
00:31:57,299 --> 00:32:00,059
vulnerabilities that you uh you you

842
00:32:00,059 --> 00:32:03,659
incur when you use tensoring operations

843
00:32:03,659 --> 00:32:06,539
so suppose we knew a star times s star

844
00:32:06,539 --> 00:32:08,880
I'm going to call this y the question I

845
00:32:08,880 --> 00:32:11,100
ask is do the secrets in the seed remain

846
00:32:11,100 --> 00:32:13,260
hidden so S1 and S2

847
00:32:13,260 --> 00:32:15,539
and I'm going to highlight in in Orange

848
00:32:15,539 --> 00:32:18,559
the known values

849
00:32:18,779 --> 00:32:21,659
and suppose you know in any good lwe

850
00:32:21,659 --> 00:32:25,020
assumption you knew A1 and A2

851
00:32:25,020 --> 00:32:27,120
well then I claim that you can actually

852
00:32:27,120 --> 00:32:30,179
recover S1 and how do you do that well

853
00:32:30,179 --> 00:32:32,520
if you knew A1 and A2 you can just

854
00:32:32,520 --> 00:32:35,039
compute a left Annihilator of a192 think

855
00:32:35,039 --> 00:32:37,740
of a1a2 as tall matrices

856
00:32:37,740 --> 00:32:39,659
and what I can do is I can multiply both

857
00:32:39,659 --> 00:32:42,000
the left hand sides both the left hand

858
00:32:42,000 --> 00:32:44,460
and right hand side by the ident M by m

859
00:32:44,460 --> 00:32:46,940
identity Matrix don't worry about the M

860
00:32:46,940 --> 00:32:51,419
tensored A2 perp and what happens this

861
00:32:51,419 --> 00:32:53,700
A2 perp is going to kill off the second

862
00:32:53,700 --> 00:32:55,980
block so when I expand this block matrix

863
00:32:55,980 --> 00:32:58,080
multiplication I get the following

864
00:32:58,080 --> 00:32:58,980
equation

865
00:32:58,980 --> 00:33:01,320
I just get some known values as equal to

866
00:33:01,320 --> 00:33:04,799
some linear we basically just get an

867
00:33:04,799 --> 00:33:06,419
affine system of equations and the

868
00:33:06,419 --> 00:33:08,159
unknowns which are V1

869
00:33:08,159 --> 00:33:10,200
and we can actually recover S1 just by

870
00:33:10,200 --> 00:33:11,820
directly solving an affine system of

871
00:33:11,820 --> 00:33:12,960
equations

872
00:33:12,960 --> 00:33:14,940
so this is how you you would recover for

873
00:33:14,940 --> 00:33:16,980
example S1

874
00:33:16,980 --> 00:33:19,320
so let's say we know S1 now

875
00:33:19,320 --> 00:33:22,140
then since we know B1 and we knew A1 we

876
00:33:22,140 --> 00:33:23,940
can recover E1

877
00:33:23,940 --> 00:33:26,159
and if I know E1 I can go back to the

878
00:33:26,159 --> 00:33:29,279
top and now repeat for S2

879
00:33:29,279 --> 00:33:31,380
and the big question is if I knew all

880
00:33:31,380 --> 00:33:32,940
these values we'd be able to cover the

881
00:33:32,940 --> 00:33:35,340
error terms and the secrets in the seed

882
00:33:35,340 --> 00:33:37,559
but the the the construction they give

883
00:33:37,559 --> 00:33:40,440
actually does not give out A1 and A2 and

884
00:33:40,440 --> 00:33:42,120
it obviously doesn't give out a star s

885
00:33:42,120 --> 00:33:43,500
star because otherwise you would know e

886
00:33:43,500 --> 00:33:45,659
star

887
00:33:45,659 --> 00:33:48,059
so the question so here's an intended uh

888
00:33:48,059 --> 00:33:50,640
attack just a hypothetical outline

889
00:33:50,640 --> 00:33:52,980
we would like to recover A1 A2 somehow

890
00:33:52,980 --> 00:33:56,340
because we are given a star which is

891
00:33:56,340 --> 00:33:58,140
some Matrix that's a function of A1 and

892
00:33:58,140 --> 00:34:01,380
A2 a star is this thing that you see

893
00:34:01,380 --> 00:34:03,720
here A1 tensor identity identity tensor

894
00:34:03,720 --> 00:34:07,740
A2 and we would then like to compute

895
00:34:07,740 --> 00:34:09,599
somehow using the Givens in the in the

896
00:34:09,599 --> 00:34:11,339
subsequence funding assumption y equals

897
00:34:11,339 --> 00:34:13,199
a star times s star we won't be able to

898
00:34:13,199 --> 00:34:15,480
but that would be the ideal and then

899
00:34:15,480 --> 00:34:17,280
we'd recover S1 and then repeat for the

900
00:34:17,280 --> 00:34:20,940
next index so this is the the ideal

901
00:34:20,940 --> 00:34:22,980
approach to this attack

902
00:34:22,980 --> 00:34:26,159
and suppose you had a star and a star is

903
00:34:26,159 --> 00:34:29,040
equal to some U1 tensor identity some A1

904
00:34:29,040 --> 00:34:31,679
tensor identity identity tensor A2 I'm

905
00:34:31,679 --> 00:34:33,480
going to call the U I'm going to rename

906
00:34:33,480 --> 00:34:34,739
them use because they're going to be

907
00:34:34,739 --> 00:34:36,418
unknowns and the question I'm going to

908
00:34:36,418 --> 00:34:38,940
ask is can you recover the components A1

909
00:34:38,940 --> 00:34:40,800
and E2 from a star

910
00:34:40,800 --> 00:34:44,960
okay and this is your equation set

911
00:34:45,480 --> 00:34:47,099
and of course you have hypothetical

912
00:34:47,099 --> 00:34:48,839
constraints made by the seed but you

913
00:34:48,839 --> 00:34:50,339
don't know the errors so you don't

914
00:34:50,339 --> 00:34:51,899
really know these constraints

915
00:34:51,899 --> 00:34:53,639
and the first problem is that there are

916
00:34:53,639 --> 00:34:56,639
actually many possible solutions so and

917
00:34:56,639 --> 00:34:57,839
we actually need a unique solution

918
00:34:57,839 --> 00:35:00,480
enable in order for our attack to work

919
00:35:00,480 --> 00:35:02,580
what's a possible solution well a

920
00:35:02,580 --> 00:35:05,160
possible solution for U1 is just A1 and

921
00:35:05,160 --> 00:35:06,900
the corresponding V1 solution for the

922
00:35:06,900 --> 00:35:09,960
secret is just S1

923
00:35:09,960 --> 00:35:12,540
but obviously you could just multiply A1

924
00:35:12,540 --> 00:35:15,119
by any invertible transformation T and

925
00:35:15,119 --> 00:35:18,359
S1 by any by T inverse and this would

926
00:35:18,359 --> 00:35:20,160
also be a possible solution

927
00:35:20,160 --> 00:35:22,500
so you actually have tons of solutions

928
00:35:22,500 --> 00:35:24,060
and how do we make unique search

929
00:35:24,060 --> 00:35:26,339
possible we're going to break A1 into

930
00:35:26,339 --> 00:35:28,260
its top square Block in a bottom

931
00:35:28,260 --> 00:35:32,520
rectangular block and pick T to be the

932
00:35:32,520 --> 00:35:34,560
inverse of the top block so in other

933
00:35:34,560 --> 00:35:36,000
words for uniqueness we're going to

934
00:35:36,000 --> 00:35:37,619
insist on a solution of the form where

935
00:35:37,619 --> 00:35:39,599
the top block is the identity

936
00:35:39,599 --> 00:35:41,520
and actually this is the intended

937
00:35:41,520 --> 00:35:42,839
solution of course is the one I just

938
00:35:42,839 --> 00:35:44,099
showed you

939
00:35:44,099 --> 00:35:46,260
and in fact this is enough to prove

940
00:35:46,260 --> 00:35:47,820
uniqueness this enables a linear

941
00:35:47,820 --> 00:35:50,099
Independence argument made possible by

942
00:35:50,099 --> 00:35:52,140
both this form of the solution and by

943
00:35:52,140 --> 00:35:54,000
tensoring

944
00:35:54,000 --> 00:35:56,460
so suppose you recovered now a1a2 up to

945
00:35:56,460 --> 00:35:58,260
Unique representation the question is

946
00:35:58,260 --> 00:36:00,780
how do you get this why

947
00:36:00,780 --> 00:36:02,520
well from the Givens in the

948
00:36:02,520 --> 00:36:04,320
pseudo-random uh and the Subspace

949
00:36:04,320 --> 00:36:05,880
flooding assumption you can actually

950
00:36:05,880 --> 00:36:07,440
compute something that almost looks like

951
00:36:07,440 --> 00:36:10,260
a star s star it's this y Prime equals a

952
00:36:10,260 --> 00:36:13,200
Star Plus RG inverse B hat G is a gadget

953
00:36:13,200 --> 00:36:14,700
Matrix B hat you could just think of as

954
00:36:14,700 --> 00:36:17,160
a homomorphic commitment to zero

955
00:36:17,160 --> 00:36:19,920
and you know b-hat so since you know G

956
00:36:19,920 --> 00:36:21,420
inverse you know B hat you can actually

957
00:36:21,420 --> 00:36:23,160
compute a right Annihilator for G

958
00:36:23,160 --> 00:36:24,839
inverse B hat the shape of these

959
00:36:24,839 --> 00:36:26,220
matrices work out

960
00:36:26,220 --> 00:36:29,160
multiply by Q on both sides and you get

961
00:36:29,160 --> 00:36:30,960
something with a form y equals a star s

962
00:36:30,960 --> 00:36:33,180
tar times Q where you know Y and you

963
00:36:33,180 --> 00:36:36,359
know q and you know a star

964
00:36:36,359 --> 00:36:37,619
great

965
00:36:37,619 --> 00:36:40,079
and finally how do we recover S1 from

966
00:36:40,079 --> 00:36:42,720
this well here's the equation written up

967
00:36:42,720 --> 00:36:45,060
again here you have you know y you know

968
00:36:45,060 --> 00:36:48,480
a star which is this block Matrix and

969
00:36:48,480 --> 00:36:50,099
then you have S star and Z here I'm

970
00:36:50,099 --> 00:36:52,920
calling I'm just smashing S1 tensor E1

971
00:36:52,920 --> 00:36:54,839
together and you know Q

972
00:36:54,839 --> 00:36:56,760
so what are you going to do you're going

973
00:36:56,760 --> 00:36:59,160
to rewrite this equation simply as y

974
00:36:59,160 --> 00:37:01,380
double prime a double Prime Times X1

975
00:37:01,380 --> 00:37:03,540
where X1 is just V1 in a vector format

976
00:37:03,540 --> 00:37:06,780
plus b double Prime where X2 is z in a

977
00:37:06,780 --> 00:37:09,000
vector format and you would like to show

978
00:37:09,000 --> 00:37:11,040
uniqueness and to show uniqueness of

979
00:37:11,040 --> 00:37:13,920
this it suffices analyze the overlap and

980
00:37:13,920 --> 00:37:15,240
the column span between a double Prime

981
00:37:15,240 --> 00:37:17,400
and B Double Prime and it actually works

982
00:37:17,400 --> 00:37:19,339
out because of this tensoring operation

983
00:37:19,339 --> 00:37:21,480
that you can actually show uniqueness

984
00:37:21,480 --> 00:37:23,160
using this over column span overlap

985
00:37:23,160 --> 00:37:24,599
technique

986
00:37:24,599 --> 00:37:28,079
okay final remarks my last slide

987
00:37:28,079 --> 00:37:30,720
actually I heavily watered it down

988
00:37:30,720 --> 00:37:32,640
there's a lot of randomization tricks

989
00:37:32,640 --> 00:37:35,119
that are being used on this a star

990
00:37:35,119 --> 00:37:37,740
namely they include these matrices p and

991
00:37:37,740 --> 00:37:40,859
p Prime to randomize to help randomize a

992
00:37:40,859 --> 00:37:42,960
star as well as applying Killian

993
00:37:42,960 --> 00:37:44,940
randomization on this a star

994
00:37:44,940 --> 00:37:47,579
and actually this PNP Prime the

995
00:37:47,579 --> 00:37:50,460
conjecture I showed you uh makes our toy

996
00:37:50,460 --> 00:37:51,420
example

997
00:37:51,420 --> 00:37:54,300
a toy attack actually extend to to the

998
00:37:54,300 --> 00:37:56,400
presence of PNP Prime under this

999
00:37:56,400 --> 00:37:57,420
reasonable conjecture I showed you

1000
00:37:57,420 --> 00:37:58,200
earlier

1001
00:37:58,200 --> 00:38:00,180
and also using a column span argument

1002
00:38:00,180 --> 00:38:01,140
you can actually show that Killian

1003
00:38:01,140 --> 00:38:03,599
randomization on this a star and S star

1004
00:38:03,599 --> 00:38:05,700
do not hide the tensor structure so this

1005
00:38:05,700 --> 00:38:07,740
could be of independent interest and

1006
00:38:07,740 --> 00:38:09,300
finally we show that the attack extends

1007
00:38:09,300 --> 00:38:12,599
to a t sum candidate presented by dqvw

1008
00:38:12,599 --> 00:38:14,300
2021

1009
00:38:14,300 --> 00:38:16,619
namely if you sum up a bunch of these

1010
00:38:16,619 --> 00:38:18,900
tensor constructions it's no more secure

1011
00:38:18,900 --> 00:38:20,579
against this attack

1012
00:38:20,579 --> 00:38:24,320
and that's it thank you very much

1013
00:38:24,620 --> 00:38:29,040
[Applause]

1014
00:38:29,040 --> 00:38:32,000
time for questions

1015
00:38:34,320 --> 00:38:38,160
hi thanks for the nice talk so uh well

1016
00:38:38,160 --> 00:38:39,480
uh

1017
00:38:39,480 --> 00:38:42,119
I think what you showed is that this

1018
00:38:42,119 --> 00:38:45,960
operation of compressing uh you know lwe

1019
00:38:45,960 --> 00:38:48,900
samples using tensoring this does not

1020
00:38:48,900 --> 00:38:53,460
work right so uh does your work give

1021
00:38:53,460 --> 00:38:57,480
insight as to you know uh ways that are

1022
00:38:57,480 --> 00:38:59,339
less structured than tensoring that

1023
00:38:59,339 --> 00:39:01,619
could help out right so effectively what

1024
00:39:01,619 --> 00:39:03,480
you can think of this is an attack on

1025
00:39:03,480 --> 00:39:06,180
the secret of the tensoring and what you

1026
00:39:06,180 --> 00:39:08,520
really need is a way to somehow obscure

1027
00:39:08,520 --> 00:39:10,320
the secret so previous work for example

1028
00:39:10,320 --> 00:39:13,140
Hopkinsville 2021 actually attacked the

1029
00:39:13,140 --> 00:39:16,859
error E star directly and there

1030
00:39:16,859 --> 00:39:19,820
basically when dqvww 2021 came along

1031
00:39:19,820 --> 00:39:22,020
their construction ideas really

1032
00:39:22,020 --> 00:39:24,900
prevented against e-star and so when you

1033
00:39:24,900 --> 00:39:27,900
generate uh basically the takeaway is if

1034
00:39:27,900 --> 00:39:29,579
you want to have some sort of expansion

1035
00:39:29,579 --> 00:39:31,560
you need to also protect the secret

1036
00:39:31,560 --> 00:39:33,240
somehow

1037
00:39:33,240 --> 00:39:37,020
uh sure but I mean uh does your work

1038
00:39:37,020 --> 00:39:39,540
offer any insight as to no but we do

1039
00:39:39,540 --> 00:39:42,260
have an idea that we are working on too

1040
00:39:42,260 --> 00:39:45,420
I look forward to seeing that yes thank

1041
00:39:45,420 --> 00:39:48,839
you any other questions

1042
00:39:48,839 --> 00:39:53,520
I I have one so you had this conjecture

1043
00:39:53,520 --> 00:39:55,740
believable one which was simple to State

1044
00:39:55,740 --> 00:40:00,060
I guess using lwe noise yeah which you

1045
00:40:00,060 --> 00:40:03,480
did you actually try to test it yeah so

1046
00:40:03,480 --> 00:40:05,700
testing it even works on Square matrices

1047
00:40:05,700 --> 00:40:08,940
like it it and we have something that's

1048
00:40:08,940 --> 00:40:13,380
very very uh like wide so it's even it

1049
00:40:13,380 --> 00:40:15,060
should be even more believable we tested

1050
00:40:15,060 --> 00:40:17,400
magma we also have we also have code for

1051
00:40:17,400 --> 00:40:19,560
this attack in magma so this attack

1052
00:40:19,560 --> 00:40:21,960
actually is implementable for small

1053
00:40:21,960 --> 00:40:23,640
parameter settings the tensoring makes

1054
00:40:23,640 --> 00:40:28,079
it absolutely nuts to like actually for

1055
00:40:28,079 --> 00:40:29,760
an attack probably you won't even care

1056
00:40:29,760 --> 00:40:31,380
if it's really proof because it's

1057
00:40:31,380 --> 00:40:35,000
working anyway yes okay

1058
00:40:36,180 --> 00:40:38,880
okay any other questions

1059
00:40:38,880 --> 00:40:41,040
so let's thank the speaker and the other

1060
00:40:41,040 --> 00:40:43,920
speaker both of the session

1061
00:40:43,920 --> 00:40:47,280
[Applause]

1062
00:40:47,280 --> 00:40:51,380
for Krypton see you next year

