1
00:00:00,860 --> 00:00:03,419
and junichi is going to give the talk

2
00:00:03,419 --> 00:00:06,500
thank you for introduction so I will

3
00:00:06,500 --> 00:00:09,780
explain my new result on quadratic

4
00:00:09,780 --> 00:00:11,940
functional encryption

5
00:00:11,940 --> 00:00:15,780
so let's start with a briefly recording

6
00:00:15,780 --> 00:00:19,560
a functional encryption uh so in

7
00:00:19,560 --> 00:00:21,660
functional encryption uh there are four

8
00:00:21,660 --> 00:00:24,300
algorithms and setup algorithm generator

9
00:00:24,300 --> 00:00:26,519
public key and master secret key

10
00:00:26,519 --> 00:00:28,980
and encryption algorithm takes a power

11
00:00:28,980 --> 00:00:31,199
key and message and Generator Cipher

12
00:00:31,199 --> 00:00:34,980
text and in this talk we assume that the

13
00:00:34,980 --> 00:00:37,800
message consists of public part and a

14
00:00:37,800 --> 00:00:40,260
private part and psychotic story has a

15
00:00:40,260 --> 00:00:43,260
public part and private part

16
00:00:43,260 --> 00:00:46,260
and the one of the master secret key can

17
00:00:46,260 --> 00:00:49,079
generate a secret key that is associated

18
00:00:49,079 --> 00:00:52,440
some function if and the Syrian feature

19
00:00:52,440 --> 00:00:55,680
of the functional encryption is in

20
00:00:55,680 --> 00:00:59,100
decryption the psychotics to 4X and the

21
00:00:59,100 --> 00:01:02,460
secret key of f review is only a four by

22
00:01:02,460 --> 00:01:05,339
X and nothing else

23
00:01:05,339 --> 00:01:09,659
and in this work I will consider the

24
00:01:09,659 --> 00:01:13,220
notion of unbounded if it says that

25
00:01:13,220 --> 00:01:16,560
message size to be encrypted is not

26
00:01:16,560 --> 00:01:19,860
bounded by the public key

27
00:01:19,860 --> 00:01:22,560
and in this work we consider a

28
00:01:22,560 --> 00:01:25,860
simulation based security and its uh

29
00:01:25,860 --> 00:01:27,659
basically says that the actual

30
00:01:27,659 --> 00:01:30,659
psychotics and secret keys can be

31
00:01:30,659 --> 00:01:33,119
simulated by only using the information

32
00:01:33,119 --> 00:01:37,439
that the adversary is supposed to run

33
00:01:37,439 --> 00:01:40,200
so more precisely we consider the two

34
00:01:40,200 --> 00:01:42,900
words and in the real world first the

35
00:01:42,900 --> 00:01:46,259
adversary obtains that ciphertext for

36
00:01:46,259 --> 00:01:48,780
change message if it is generated

37
00:01:48,780 --> 00:01:51,259
honestly and then

38
00:01:51,259 --> 00:01:55,320
otherwise I can within the many secret

39
00:01:55,320 --> 00:01:59,759
Keys as we desire of the desires and in

40
00:01:59,759 --> 00:02:02,360
the simulated World The Challenge

41
00:02:02,360 --> 00:02:06,540
cyphaticist is generated only using a

42
00:02:06,540 --> 00:02:08,880
public part of the change message

43
00:02:08,880 --> 00:02:11,879
and the thing just simulated SQL keys

44
00:02:11,879 --> 00:02:15,780
are generated using the function f and f

45
00:02:15,780 --> 00:02:17,459
of x

46
00:02:17,459 --> 00:02:21,560
and if a scheme is said to be secure if

47
00:02:21,560 --> 00:02:24,599
efficient adversaries cannot distinguish

48
00:02:24,599 --> 00:02:27,239
these two words

49
00:02:27,239 --> 00:02:30,360
and next I will introduce a motivation

50
00:02:30,360 --> 00:02:32,940
of unbounded the functional encryption

51
00:02:32,940 --> 00:02:35,700
and the problem of the most if we

52
00:02:35,700 --> 00:02:37,860
schemes is that the message Rings is

53
00:02:37,860 --> 00:02:39,959
fixed by the public key in the setup

54
00:02:39,959 --> 00:02:41,459
phase

55
00:02:41,459 --> 00:02:45,599
but let us consider the system where we

56
00:02:45,599 --> 00:02:49,140
will encrypt the various sizes of data

57
00:02:49,140 --> 00:02:52,379
and assume that the fixed message Rings

58
00:02:52,379 --> 00:02:54,720
is as shown like this

59
00:02:54,720 --> 00:02:57,780
thing we can encrypt the message that is

60
00:02:57,780 --> 00:03:00,300
shorter than the fixed message rings but

61
00:03:00,300 --> 00:03:04,620
by putting up dummy data but we cannot

62
00:03:04,620 --> 00:03:07,080
encrypt the message that is longer than

63
00:03:07,080 --> 00:03:09,900
the fixed message ringus

64
00:03:09,900 --> 00:03:13,140
so how about settings are fixed message

65
00:03:13,140 --> 00:03:14,540
Rings

66
00:03:14,540 --> 00:03:17,220
sufficiently rise

67
00:03:17,220 --> 00:03:21,480
then we can encrypt the all messages by

68
00:03:21,480 --> 00:03:25,620
particle dummy data and are we happy of

69
00:03:25,620 --> 00:03:28,500
course not because the cyphatic

70
00:03:28,500 --> 00:03:30,360
exercises proportional to the message

71
00:03:30,360 --> 00:03:33,300
size so there's such a way of encryption

72
00:03:33,300 --> 00:03:34,580
is very

73
00:03:34,580 --> 00:03:37,800
wasteful and inefficient

74
00:03:37,800 --> 00:03:39,060
so

75
00:03:39,060 --> 00:03:42,680
ah in contrast amount

76
00:03:42,680 --> 00:03:46,260
in unbounded schemes there is no need to

77
00:03:46,260 --> 00:03:49,220
pass the damage in encryption because

78
00:03:49,220 --> 00:03:53,000
about data fee is inherently supports

79
00:03:53,000 --> 00:03:56,760
the variable links

80
00:03:56,760 --> 00:04:00,959
and also there are no bound on the

81
00:04:00,959 --> 00:04:03,720
message side so we do not care about the

82
00:04:03,720 --> 00:04:07,980
maximum ringus maximum data rings in the

83
00:04:07,980 --> 00:04:09,239
setup phase

84
00:04:09,239 --> 00:04:12,780
so about it is suitable for the system

85
00:04:12,780 --> 00:04:16,079
where we will encrypt a various size of

86
00:04:16,079 --> 00:04:18,620
data

87
00:04:18,839 --> 00:04:22,860
so uh let us review the previous works

88
00:04:22,860 --> 00:04:26,060
for unbounded fees

89
00:04:27,680 --> 00:04:30,660
focuses on the other function Cross of

90
00:04:30,660 --> 00:04:34,380
turing machine so fun functional key is

91
00:04:34,380 --> 00:04:37,199
associated with a turing machine on the

92
00:04:37,199 --> 00:04:40,080
decryption reviews uh computational

93
00:04:40,080 --> 00:04:43,400
result of turing machine or on the input

94
00:04:43,400 --> 00:04:45,840
input message X

95
00:04:45,840 --> 00:04:49,199
and the disadvantage of this box is the

96
00:04:49,199 --> 00:04:52,919
rely on the obfuscation

97
00:04:52,919 --> 00:04:56,460
and the first work that does not rely on

98
00:04:56,460 --> 00:04:58,620
obfuscation is a

99
00:04:58,620 --> 00:05:02,520
for unbounded visa on of the class of

100
00:05:02,520 --> 00:05:06,300
inner product so a function key is

101
00:05:06,300 --> 00:05:09,900
associated with a coefficients of linear

102
00:05:09,900 --> 00:05:12,080
function and the decryption device

103
00:05:12,080 --> 00:05:17,300
linear function about the message

104
00:05:17,639 --> 00:05:20,060
and recently uh

105
00:05:20,060 --> 00:05:23,660
a new crossover functional encryption

106
00:05:23,660 --> 00:05:27,539
for the cross attribute weighted sums is

107
00:05:27,539 --> 00:05:30,180
proposed from The Amity detail

108
00:05:30,180 --> 00:05:31,919
assumption

109
00:05:31,919 --> 00:05:34,740
and this is also a computer linear

110
00:05:34,740 --> 00:05:37,500
function about the private input but the

111
00:05:37,500 --> 00:05:40,919
coefficients is computed from arithmetic

112
00:05:40,919 --> 00:05:43,919
branching program which is associated

113
00:05:43,919 --> 00:05:47,340
with a functional key and the public

114
00:05:47,340 --> 00:05:52,219
part of a message U UI

115
00:05:52,919 --> 00:05:57,900
but this is the uh as far as I know this

116
00:05:57,900 --> 00:06:02,840
is all unbounded to his schemes but uh

117
00:06:02,840 --> 00:06:06,960
the old uh unbounded the fee schemes

118
00:06:06,960 --> 00:06:10,620
that does not rely on obfuscation is

119
00:06:10,620 --> 00:06:14,639
already in the private XI so the natural

120
00:06:14,639 --> 00:06:17,639
question is uh can we construct a

121
00:06:17,639 --> 00:06:21,419
unbounded traffic scheme for quadratic

122
00:06:21,419 --> 00:06:23,940
functions or higher degree functions

123
00:06:23,940 --> 00:06:26,100
without obfuscation

124
00:06:26,100 --> 00:06:30,840
and we give a apartment so to this

125
00:06:30,840 --> 00:06:32,400
question in this work

126
00:06:32,400 --> 00:06:35,400
so our first result is the construction

127
00:06:35,400 --> 00:06:37,319
of unbounded quadratic functional

128
00:06:37,319 --> 00:06:40,560
encryption and in this scheme a function

129
00:06:40,560 --> 00:06:42,600
functional keys are associated with

130
00:06:42,600 --> 00:06:45,840
coefficients for quadratic functions and

131
00:06:45,840 --> 00:06:47,819
the decryption review is the quadratic

132
00:06:47,819 --> 00:06:50,880
function over the message

133
00:06:50,880 --> 00:06:54,479
and our scheme is based on pairing

134
00:06:54,479 --> 00:06:58,139
groups and secure and as a mddh

135
00:06:58,139 --> 00:07:01,740
assumption and random Oracle model

136
00:07:01,740 --> 00:07:05,400
and our second result is extension to

137
00:07:05,400 --> 00:07:07,160
partially hiding

138
00:07:07,160 --> 00:07:11,479
functional encryption and in this scheme

139
00:07:11,479 --> 00:07:14,160
function is a functional key is

140
00:07:14,160 --> 00:07:16,620
associated with a set of arithmetic

141
00:07:16,620 --> 00:07:20,360
branching programs and coefficient of

142
00:07:20,360 --> 00:07:23,720
quadratic function is determined by

143
00:07:23,720 --> 00:07:27,060
these arithmetic branching programs and

144
00:07:27,060 --> 00:07:30,860
the probability part of the message

145
00:07:30,900 --> 00:07:34,080
and our second is our second result is

146
00:07:34,080 --> 00:07:37,220
basically obtained by applying

147
00:07:37,220 --> 00:07:40,440
technique developed by V which is

148
00:07:40,440 --> 00:07:44,520
presented in TCC in 2020 so I will focus

149
00:07:44,520 --> 00:07:47,819
on the the first result in the rest of

150
00:07:47,819 --> 00:07:50,180
the talk

151
00:07:50,520 --> 00:07:56,160
so let's take a let's take a more closer

152
00:07:56,160 --> 00:07:59,099
look on the functionality of unbounded

153
00:07:59,099 --> 00:08:00,979
quadratic functions

154
00:08:00,979 --> 00:08:04,080
the message of this functionality

155
00:08:04,080 --> 00:08:10,099
consists of a index set s and uh

156
00:08:10,099 --> 00:08:13,740
GPA elements XI which is associated

157
00:08:13,740 --> 00:08:16,340
which is indexed by the

158
00:08:16,340 --> 00:08:19,379
index set

159
00:08:19,379 --> 00:08:24,000
and the function consists of consists of

160
00:08:24,000 --> 00:08:27,660
the uh Target index set T which

161
00:08:27,660 --> 00:08:29,060
specifies

162
00:08:29,060 --> 00:08:33,719
which indices can be will be used to the

163
00:08:33,719 --> 00:08:36,479
decryption and the compute the quadratic

164
00:08:36,479 --> 00:08:38,659
function and

165
00:08:38,659 --> 00:08:43,320
coefficients cij which is uh which

166
00:08:43,320 --> 00:08:45,959
specifies the fat kind of quadratic

167
00:08:45,959 --> 00:08:48,180
function is computed

168
00:08:48,180 --> 00:08:51,260
and the outputs of the functionality is

169
00:08:51,260 --> 00:08:52,820
if

170
00:08:52,820 --> 00:08:57,360
index set is consider contains are all

171
00:08:57,360 --> 00:09:00,540
target index T then quadratic function

172
00:09:00,540 --> 00:09:05,399
is computed but it if it is not the case

173
00:09:05,399 --> 00:09:09,060
then nothing is revered

174
00:09:09,060 --> 00:09:12,660
so this functionality can be seeing a

175
00:09:12,660 --> 00:09:15,180
kind of attributes based functional

176
00:09:15,180 --> 00:09:18,360
encryption which is introduced by a

177
00:09:18,360 --> 00:09:23,580
operator and because we can see that is

178
00:09:23,580 --> 00:09:27,360
as a attribute set and the t is a policy

179
00:09:27,360 --> 00:09:32,300
and the valuation of s and t decides the

180
00:09:32,300 --> 00:09:35,599
decryption condition

181
00:09:37,040 --> 00:09:39,560
so

182
00:09:39,560 --> 00:09:44,220
I will next how to construct our

183
00:09:44,220 --> 00:09:46,740
quadratic functional encryption scheme

184
00:09:46,740 --> 00:09:51,180
and actually our starting point of our

185
00:09:51,180 --> 00:09:53,640
scheme is quadratic functional

186
00:09:53,640 --> 00:09:57,240
encryption scheme proposed by lean in

187
00:09:57,240 --> 00:09:58,980
2017.

188
00:09:58,980 --> 00:10:03,000
and which is a standard Quality Function

189
00:10:03,000 --> 00:10:06,560
and computation encryption scheme so the

190
00:10:06,560 --> 00:10:10,019
is fixed at the set of phase but in this

191
00:10:10,019 --> 00:10:12,980
talk we will start

192
00:10:12,980 --> 00:10:17,580
from quality kph proposed by default

193
00:10:17,580 --> 00:10:22,740
editor at 2019 because this is a

194
00:10:22,740 --> 00:10:26,700
simplest quadratic KFC scheme and it's

195
00:10:26,700 --> 00:10:29,820
easy to describe and also it is

196
00:10:29,820 --> 00:10:32,959
sufficient for explaining

197
00:10:32,959 --> 00:10:37,680
the ideas of our Construction

198
00:10:37,680 --> 00:10:39,180
so

199
00:10:39,180 --> 00:10:42,120
in their scheme

200
00:10:42,120 --> 00:10:46,860
if we set the message rings in then

201
00:10:46,860 --> 00:10:51,180
first we choose two vectors u and v that

202
00:10:51,180 --> 00:10:55,019
the rings of each are n

203
00:10:55,019 --> 00:10:58,860
and the public key is the group Vector U

204
00:10:58,860 --> 00:11:01,680
and three and this bracket bracket

205
00:11:01,680 --> 00:11:02,779
notation

206
00:11:02,779 --> 00:11:05,940
denotes the element wise exponentiation

207
00:11:05,940 --> 00:11:11,360
to the G1 group and G2 group or pairings

208
00:11:11,640 --> 00:11:15,440
and uh encryption of X

209
00:11:15,440 --> 00:11:20,459
is done as shown like this but the

210
00:11:20,459 --> 00:11:23,279
structure of these cyphatics is not

211
00:11:23,279 --> 00:11:25,200
important here

212
00:11:25,200 --> 00:11:28,380
so the important thing is that we can

213
00:11:28,380 --> 00:11:32,339
publicly compute the quadratic function

214
00:11:32,339 --> 00:11:36,180
value for coefficient Vector C plus

215
00:11:36,180 --> 00:11:40,800
masking term from uh C1 on the C2 and

216
00:11:40,800 --> 00:11:43,320
the coefficient Vector C

217
00:11:43,320 --> 00:11:48,120
and other than that uh C1 and C2

218
00:11:48,120 --> 00:11:50,700
statistics statistically has the

219
00:11:50,700 --> 00:11:54,680
information of vector X

220
00:11:55,019 --> 00:12:00,899
so ah if we generate a series key like

221
00:12:00,899 --> 00:12:05,399
this so we set the secret key as period

222
00:12:05,399 --> 00:12:09,779
time I think uh pairing over C3 and the

223
00:12:09,779 --> 00:12:13,440
Secret Key reviews masking term so by

224
00:12:13,440 --> 00:12:16,440
subtracting this masking term from the

225
00:12:16,440 --> 00:12:18,420
above

226
00:12:18,420 --> 00:12:22,320
thumb then we can recover the quadratic

227
00:12:22,320 --> 00:12:28,200
function of with respect to Vector C

228
00:12:28,200 --> 00:12:32,279
thing how to make this scheme unbounded

229
00:12:32,279 --> 00:12:36,180
so naive idea is generating Vector U and

230
00:12:36,180 --> 00:12:39,420
as a public key Vector U and three by a

231
00:12:39,420 --> 00:12:43,560
hash function model does a random Oracle

232
00:12:43,560 --> 00:12:48,180
but this idea does not work because if

233
00:12:48,180 --> 00:12:50,579
we generate to Vector U by a hash

234
00:12:50,579 --> 00:12:54,120
function then we cannot compute a secret

235
00:12:54,120 --> 00:12:57,060
key efficiently because in the secret

236
00:12:57,060 --> 00:13:01,260
key a vector U is uh in the group group

237
00:13:01,260 --> 00:13:03,720
two so G2 groups

238
00:13:03,720 --> 00:13:07,139
so we cannot generate this term

239
00:13:07,139 --> 00:13:10,079
and actually this problem is common in

240
00:13:10,079 --> 00:13:14,940
existing quadratic schemes so

241
00:13:14,940 --> 00:13:16,459
to

242
00:13:16,459 --> 00:13:20,600
circumvent this problem we modify the

243
00:13:20,600 --> 00:13:26,100
quadratic quality schemes so that it is

244
00:13:26,100 --> 00:13:29,160
a fashion has function friendly

245
00:13:29,160 --> 00:13:31,260
and the new quadratically if it is a

246
00:13:31,260 --> 00:13:34,920
scheme can be written as follows

247
00:13:34,920 --> 00:13:39,300
so now uh we remove the fixed IU from

248
00:13:39,300 --> 00:13:41,459
public key and master secret key because

249
00:13:41,459 --> 00:13:44,940
this term is programmatic if we generate

250
00:13:44,940 --> 00:13:47,519
it from a hash function

251
00:13:47,519 --> 00:13:49,560
and uh

252
00:13:49,560 --> 00:13:52,139
the structural cyphatic

253
00:13:52,139 --> 00:13:56,040
is also modified a little bit but again

254
00:13:56,040 --> 00:13:59,160
the structure actual structure is not

255
00:13:59,160 --> 00:14:01,980
important here the important thing is

256
00:14:01,980 --> 00:14:05,100
again we can compute a quadratic

257
00:14:05,100 --> 00:14:07,860
function Value Plus masking term from C1

258
00:14:07,860 --> 00:14:10,440
the C2 and the coefficient Vector C

259
00:14:10,440 --> 00:14:15,000
and C1 to C2 statistically hides Vector

260
00:14:15,000 --> 00:14:17,180
X

261
00:14:17,639 --> 00:14:21,420
and the masking tongue can be written as

262
00:14:21,420 --> 00:14:25,680
a direct Underside sorry right hand side

263
00:14:25,680 --> 00:14:32,339
so by setting a SQL key as per time the

264
00:14:32,339 --> 00:14:34,160
return thing

265
00:14:34,160 --> 00:14:37,980
pairing of C3 and Secret Key reviews are

266
00:14:37,980 --> 00:14:40,500
masking term and subducting this masking

267
00:14:40,500 --> 00:14:42,899
term we can obtain the quadratic

268
00:14:42,899 --> 00:14:48,240
function for coefficient Vector C

269
00:14:48,240 --> 00:14:50,519
and in this construction we can use a

270
00:14:50,519 --> 00:14:54,380
hash function to generate a vector v

271
00:14:54,380 --> 00:14:58,320
because even if we generate Vector very

272
00:14:58,320 --> 00:15:00,720
by a hash function the secret key can be

273
00:15:00,720 --> 00:15:02,519
generated efficiently

274
00:15:02,519 --> 00:15:07,019
but the problem here is that anyone can

275
00:15:07,019 --> 00:15:10,139
compute the SQL key because now secret

276
00:15:10,139 --> 00:15:11,880
key does not contain any secret

277
00:15:11,880 --> 00:15:13,320
information

278
00:15:13,320 --> 00:15:14,839
and

279
00:15:14,839 --> 00:15:20,639
as I State I mentioned previously we

280
00:15:20,639 --> 00:15:23,240
want to have some Access Control

281
00:15:23,240 --> 00:15:27,959
property by indices said a sound T but

282
00:15:27,959 --> 00:15:30,320
this construction does not

283
00:15:30,320 --> 00:15:34,740
serve the such functionality

284
00:15:36,720 --> 00:15:40,560
so to achieve so to solve these problems

285
00:15:40,560 --> 00:15:41,760
we

286
00:15:41,760 --> 00:15:44,760
introduce additional layer and first

287
00:15:44,760 --> 00:15:46,519
encrypt the

288
00:15:46,519 --> 00:15:51,000
vector s by the additional layer

289
00:15:51,000 --> 00:15:56,060
and to encrypt so by encrypting vectors

290
00:15:56,060 --> 00:15:57,720
now

291
00:15:57,720 --> 00:16:00,920
the other was already cannot

292
00:16:00,920 --> 00:16:04,560
compute the masking Time by itself by

293
00:16:04,560 --> 00:16:08,459
generating The Secret Key by itself

294
00:16:08,459 --> 00:16:12,420
and we also encode the blue term by

295
00:16:12,420 --> 00:16:16,560
additional layer so that to compute the

296
00:16:16,560 --> 00:16:20,160
covered Blue term needs a master sync

297
00:16:20,160 --> 00:16:24,300
Master secret key and decryption of this

298
00:16:24,300 --> 00:16:26,820
red covered summons blue cover term

299
00:16:26,820 --> 00:16:29,339
reviews masking term

300
00:16:29,339 --> 00:16:35,220
then we can solve the first problem

301
00:16:35,220 --> 00:16:38,279
and to solve the second problem we

302
00:16:38,279 --> 00:16:41,880
associate the proton to the indices set

303
00:16:41,880 --> 00:16:43,440
T and

304
00:16:43,440 --> 00:16:46,560
late covered Authority cover term with

305
00:16:46,560 --> 00:16:51,319
associate with us indices as

306
00:16:51,540 --> 00:16:54,720
and we also assume that the decryption

307
00:16:54,720 --> 00:16:58,860
is possible if and only if s and the T

308
00:16:58,860 --> 00:17:02,040
satisfies the condition

309
00:17:02,040 --> 00:17:07,199
thing we can solve the second program

310
00:17:07,199 --> 00:17:08,880
so

311
00:17:08,880 --> 00:17:13,199
the fact is that is the additional layer

312
00:17:13,199 --> 00:17:15,780
so this functionality is exactly

313
00:17:15,780 --> 00:17:18,240
corresponds to the unbounded inner

314
00:17:18,240 --> 00:17:20,459
product functional encryption

315
00:17:20,459 --> 00:17:25,079
so uh uh our final Choice scheme is like

316
00:17:25,079 --> 00:17:28,099
that so the setup bar will generate the

317
00:17:28,099 --> 00:17:30,660
public key and the mathematical key of

318
00:17:30,660 --> 00:17:34,260
unbounded ipfe scheme and now Vector is

319
00:17:34,260 --> 00:17:36,179
generated by a hash function

320
00:17:36,179 --> 00:17:38,400
and the encryption is the same as a

321
00:17:38,400 --> 00:17:40,860
previous scheme but the C3 is now

322
00:17:40,860 --> 00:17:44,400
generated using the unbounded ipfe and

323
00:17:44,400 --> 00:17:47,460
encrypting by encrypting big tires

324
00:17:47,460 --> 00:17:50,039
and the key generation algorithm is also

325
00:17:50,039 --> 00:17:53,460
the same as the previous scheme but now

326
00:17:53,460 --> 00:17:56,580
secret keys are a secret key for

327
00:17:56,580 --> 00:17:59,400
unbounded ipv scheme with respect to the

328
00:17:59,400 --> 00:18:00,660
proton

329
00:18:00,660 --> 00:18:05,400
then in decryption we can reveal the

330
00:18:05,400 --> 00:18:08,299
masking time if underneath is on the T

331
00:18:08,299 --> 00:18:11,100
satisfies the condition

332
00:18:11,100 --> 00:18:13,740
and this means that the quadratic

333
00:18:13,740 --> 00:18:16,080
function value is also elevated if they

334
00:18:16,080 --> 00:18:18,000
are satisfied is the condition is

335
00:18:18,000 --> 00:18:19,559
satisfied

336
00:18:19,559 --> 00:18:22,020
so in conclusion in this work we

337
00:18:22,020 --> 00:18:24,360
constructed the first unbounded color

338
00:18:24,360 --> 00:18:28,260
dkv scheme and we also extended to it to

339
00:18:28,260 --> 00:18:30,720
the partially hiding wave setting and

340
00:18:30,720 --> 00:18:32,940
our scheme is semi-adaptively simulation

341
00:18:32,940 --> 00:18:35,580
secure and as mvdh assumption and random

342
00:18:35,580 --> 00:18:38,280
the random Oracle model

343
00:18:38,280 --> 00:18:42,299
and I also mentioned some open problems

344
00:18:42,299 --> 00:18:44,480
and the most

345
00:18:44,480 --> 00:18:47,340
interesting open problem is that our

346
00:18:47,340 --> 00:18:50,340
scheme is since our scheme is relying on

347
00:18:50,340 --> 00:18:53,760
random Oracle so how to remove the

348
00:18:53,760 --> 00:18:56,220
random rockeries a very interesting open

349
00:18:56,220 --> 00:19:00,000
question and also our scheme satisfies

350
00:19:00,000 --> 00:19:04,140
only semi-adaptive security so achieving

351
00:19:04,140 --> 00:19:06,360
adaptive Securities in the standard

352
00:19:06,360 --> 00:19:10,020
model is also interesting open problem

353
00:19:10,020 --> 00:19:13,440
and even the standard for standard

354
00:19:13,440 --> 00:19:17,880
quadratic Fe adaptive Securities still a

355
00:19:17,880 --> 00:19:21,650
recipient thank you very much

356
00:19:21,650 --> 00:19:26,880
[Applause]

357
00:19:26,880 --> 00:19:30,059
so we have time for one quick question

358
00:19:30,059 --> 00:19:32,960
any question

359
00:19:36,419 --> 00:19:39,299
so I have one quick question is um so

360
00:19:39,299 --> 00:19:41,280
okay you mentioned the uh open problem

361
00:19:41,280 --> 00:19:43,440
of removing random oracles is this

362
00:19:43,440 --> 00:19:45,480
something inner end in all unbounded Fe

363
00:19:45,480 --> 00:19:47,580
constructions or there are constructions

364
00:19:47,580 --> 00:19:49,559
that don't need this assumption for

365
00:19:49,559 --> 00:19:52,940
example for inner products

366
00:19:58,039 --> 00:20:01,620
so do there exist unbounded functional

367
00:20:01,620 --> 00:20:03,419
encryption schemes without random

368
00:20:03,419 --> 00:20:09,179
oracles oh yes yes so uh unbounded so uh

369
00:20:09,179 --> 00:20:13,080
so unbounded ipfe scheme and the if we

370
00:20:13,080 --> 00:20:15,059
scheme for arithmetic branching program

371
00:20:15,059 --> 00:20:19,260
it does not use random workers so in our

372
00:20:19,260 --> 00:20:22,919
scheme we maybe use a random rocker for

373
00:20:22,919 --> 00:20:24,240
the first time

374
00:20:24,240 --> 00:20:27,480
for constructing among the ipv amounted

375
00:20:27,480 --> 00:20:28,679
to if we

376
00:20:28,679 --> 00:20:30,799
okay thanks okay

377
00:20:30,799 --> 00:20:34,200
let's thank unichi again

378
00:20:34,200 --> 00:20:36,860
thank you

379
00:20:39,960 --> 00:20:42,559
so

380
00:20:43,020 --> 00:20:45,200
foreign

381
00:20:46,320 --> 00:20:48,900
so the last talk of this session is

382
00:20:48,900 --> 00:20:51,120
multi-key and multi-input predicate

383
00:20:51,120 --> 00:20:53,880
encryption from learning with Errors By

384
00:20:53,880 --> 00:20:56,039
Danilo francati Daniela triolo Julio

385
00:20:56,039 --> 00:20:59,220
malavolta in Daniel leventuri and Danilo

386
00:20:59,220 --> 00:21:00,960
is going to give the talk

387
00:21:00,960 --> 00:21:02,640
please start thank you for the

388
00:21:02,640 --> 00:21:04,880
introduction so I'm gonna talk about

389
00:21:04,880 --> 00:21:07,380
predicate encryption in the MultiCare

390
00:21:07,380 --> 00:21:08,940
multiple setting

391
00:21:08,940 --> 00:21:13,260
but let's have a first overview so we

392
00:21:13,260 --> 00:21:14,880
all know functional encryption predicate

393
00:21:14,880 --> 00:21:17,340
encryption so if other in functional

394
00:21:17,340 --> 00:21:18,900
encryption there's a sender can encrypt

395
00:21:18,900 --> 00:21:20,820
a message and later you can decrypt a

396
00:21:20,820 --> 00:21:23,220
function of the message and in predicate

397
00:21:23,220 --> 00:21:24,960
encryption now you can create a message

398
00:21:24,960 --> 00:21:26,700
together with an info for the predicate

399
00:21:26,700 --> 00:21:28,980
and you can later decrypt a message if

400
00:21:28,980 --> 00:21:30,780
the previous satisfied

401
00:21:30,780 --> 00:21:32,940
so this Primitives belongs to the single

402
00:21:32,940 --> 00:21:34,919
input settings simply because uh there

403
00:21:34,919 --> 00:21:37,799
is a single standard that can choose the

404
00:21:37,799 --> 00:21:40,919
input of the function of or the message

405
00:21:40,919 --> 00:21:43,559
but for the functional encryption case

406
00:21:43,559 --> 00:21:46,740
we have the multi-input version so now

407
00:21:46,740 --> 00:21:49,080
we have multiple senders and we can

408
00:21:49,080 --> 00:21:51,240
encrypt multiple messages and you can

409
00:21:51,240 --> 00:21:53,400
later decrypt a function of the messages

410
00:21:53,400 --> 00:21:56,039
what we do in this work we extend an

411
00:21:56,039 --> 00:21:58,320
option of uh predicate encryption to the

412
00:21:58,320 --> 00:22:00,659
multi-input setting and while we do that

413
00:22:00,659 --> 00:22:02,460
we also Define an intermediate notion

414
00:22:02,460 --> 00:22:03,960
that is called multi-key that is

415
00:22:03,960 --> 00:22:05,820
essentially a single input predicate

416
00:22:05,820 --> 00:22:06,840
encryption

417
00:22:06,840 --> 00:22:08,700
but where the key is splitted among

418
00:22:08,700 --> 00:22:10,320
multiple keys

419
00:22:10,320 --> 00:22:12,659
uh I don't have much time so I'm going

420
00:22:12,659 --> 00:22:14,700
to focus only on multi-input and I want

421
00:22:14,700 --> 00:22:17,220
to stress that there is a recent work at

422
00:22:17,220 --> 00:22:20,460
PR crypto22 by Agave at all that study

423
00:22:20,460 --> 00:22:21,900
the same notion but we have incomparable

424
00:22:21,900 --> 00:22:24,179
salt system of construction predicates

425
00:22:24,179 --> 00:22:27,960
number of inputs and assumptions

426
00:22:27,960 --> 00:22:30,480
so predicate encryption very high level

427
00:22:30,480 --> 00:22:33,240
there is an authority that generates the

428
00:22:33,240 --> 00:22:35,460
master public key for the sender

429
00:22:35,460 --> 00:22:38,640
and you then use the secret the master

430
00:22:38,640 --> 00:22:40,320
secret key to generate the decryption

431
00:22:40,320 --> 00:22:42,120
key for the receiver

432
00:22:42,120 --> 00:22:44,940
then leader you can use the master

433
00:22:44,940 --> 00:22:46,860
public key to encrypt a message with an

434
00:22:46,860 --> 00:22:48,900
input text and you send the cipher text

435
00:22:48,900 --> 00:22:50,220
to the receiver

436
00:22:50,220 --> 00:22:51,659
and then the receiver is going to

437
00:22:51,659 --> 00:22:53,340
decrypt the message if the predicate

438
00:22:53,340 --> 00:22:56,600
with input text is satisfied

439
00:22:57,679 --> 00:23:00,360
we are interesting in this presentation

440
00:23:00,360 --> 00:23:03,240
uh it's CPA once are the security that

441
00:23:03,240 --> 00:23:06,240
available high level says that uh you

442
00:23:06,240 --> 00:23:07,380
don't reveal any information about

443
00:23:07,380 --> 00:23:09,360
encrypted message and the encrypted

444
00:23:09,360 --> 00:23:12,480
input under the condition that adversary

445
00:23:12,480 --> 00:23:16,220
do not decrypt the challenge ciphertext

446
00:23:16,440 --> 00:23:19,100
um so

447
00:23:19,200 --> 00:23:21,360
now let's see how does it work the

448
00:23:21,360 --> 00:23:23,520
multi-input case so this is the true

449
00:23:23,520 --> 00:23:25,020
input case

450
00:23:25,020 --> 00:23:27,179
we have an authority that generates two

451
00:23:27,179 --> 00:23:29,760
encryption keys and you send two the two

452
00:23:29,760 --> 00:23:31,380
keys to the sender to the corresponding

453
00:23:31,380 --> 00:23:32,400
senders

454
00:23:32,400 --> 00:23:35,400
and then you can uh as usual you can

455
00:23:35,400 --> 00:23:36,780
generate the different key for the

456
00:23:36,780 --> 00:23:38,039
predicate and you give it to the

457
00:23:38,039 --> 00:23:39,120
receiver

458
00:23:39,120 --> 00:23:41,340
but now the functional is that every

459
00:23:41,340 --> 00:23:43,200
sender can choose its own message and

460
00:23:43,200 --> 00:23:45,960
its own input and then you can send the

461
00:23:45,960 --> 00:23:48,419
Cyber text to the receiver and on

462
00:23:48,419 --> 00:23:49,919
decryption the functionality is the

463
00:23:49,919 --> 00:23:51,900
following so you decrypt both size

464
00:23:51,900 --> 00:23:53,820
attacks and you obtain the same messages

465
00:23:53,820 --> 00:23:56,940
the the the encrypted messages if the

466
00:23:56,940 --> 00:23:59,700
predicate satisfied and the bread again

467
00:23:59,700 --> 00:24:00,900
now is going to be a two input

468
00:24:00,900 --> 00:24:02,460
predicator evaluate over the input of

469
00:24:02,460 --> 00:24:04,200
the first sender and the input of the

470
00:24:04,200 --> 00:24:06,380
seconds

471
00:24:06,780 --> 00:24:08,940
so the power of the Primitive comes from

472
00:24:08,940 --> 00:24:10,559
the fact that you can interlive cyber

473
00:24:10,559 --> 00:24:13,020
text and also this is why the Primitive

474
00:24:13,020 --> 00:24:14,880
is hard to build so for example when you

475
00:24:14,880 --> 00:24:16,980
take C1 and C2 you evaluate depending on

476
00:24:16,980 --> 00:24:18,179
some inputs

477
00:24:18,179 --> 00:24:20,340
but if you change the second ciphertext

478
00:24:20,340 --> 00:24:21,720
you're going to change the input of the

479
00:24:21,720 --> 00:24:25,039
second the the second input of the print

480
00:24:25,039 --> 00:24:27,179
or in the

481
00:24:27,179 --> 00:24:30,000
in the paper we extend the notion of CPA

482
00:24:30,000 --> 00:24:32,100
one Sada to the multiple setting and the

483
00:24:32,100 --> 00:24:34,260
one that you see here is the secret key

484
00:24:34,260 --> 00:24:37,020
case that means that the adversary

485
00:24:37,020 --> 00:24:38,820
doesn't see the encryption keys of the

486
00:24:38,820 --> 00:24:41,280
senders but you only have encryption

487
00:24:41,280 --> 00:24:43,380
oracles to the to the corresponding

488
00:24:43,380 --> 00:24:45,480
encryption algorithm Oracle queries to

489
00:24:45,480 --> 00:24:47,700
the Oracle access to the encryption

490
00:24:47,700 --> 00:24:48,960
algorithms

491
00:24:48,960 --> 00:24:51,360
and the security is has very high level

492
00:24:51,360 --> 00:24:53,880
the same of the single input predicate

493
00:24:53,880 --> 00:24:56,159
encryption with that says that you don't

494
00:24:56,159 --> 00:24:58,320
reveal any anything about the encrypted

495
00:24:58,320 --> 00:25:00,480
messages and encrypt name inputs

496
00:25:00,480 --> 00:25:02,280
but here the definition is a little bit

497
00:25:02,280 --> 00:25:05,280
trickier because we have multiples uh

498
00:25:05,280 --> 00:25:06,600
the cipher the challenge server is

499
00:25:06,600 --> 00:25:09,120
composed by multiple ciphertext so we

500
00:25:09,120 --> 00:25:10,919
need to claim that that person do not

501
00:25:10,919 --> 00:25:12,840
decrypt any part of the challenge cyber

502
00:25:12,840 --> 00:25:15,059
text and this means that in the benefit

503
00:25:15,059 --> 00:25:18,179
of what you can interlive then any part

504
00:25:18,179 --> 00:25:20,340
of the challenge cyber takes you it's uh

505
00:25:20,340 --> 00:25:22,260
it's not decrypted and the stuff that

506
00:25:22,260 --> 00:25:24,299
you can combine are the one that you

507
00:25:24,299 --> 00:25:27,059
obtained from the encryption oracles or

508
00:25:27,059 --> 00:25:28,679
the one that you obtained during the

509
00:25:28,679 --> 00:25:31,340
challenge phase

510
00:25:31,860 --> 00:25:34,200
um so we have a construction for this

511
00:25:34,200 --> 00:25:37,620
setting we achieve adaptively secure CPA

512
00:25:37,620 --> 00:25:39,779
one-sided multi-input predicate

513
00:25:39,779 --> 00:25:43,679
encryption in the secret key setting the

514
00:25:43,679 --> 00:25:46,200
number of inputs can be any polynomial

515
00:25:46,200 --> 00:25:47,400
in the security parameter and the

516
00:25:47,400 --> 00:25:49,380
assumption is financial w

517
00:25:49,380 --> 00:25:51,299
and the class of prodigious dual support

518
00:25:51,299 --> 00:25:53,220
is the one that you see here so it's

519
00:25:53,220 --> 00:25:55,020
essentially a conjunction of arbitrary

520
00:25:55,020 --> 00:25:57,539
predicates where each predicate takes in

521
00:25:57,539 --> 00:25:59,760
input one input of the

522
00:25:59,760 --> 00:26:01,440
of the corresponding Center so for

523
00:26:01,440 --> 00:26:03,960
example P1 takes an input the

524
00:26:03,960 --> 00:26:07,200
the encrypted input from the first uh

525
00:26:07,200 --> 00:26:09,840
encrypted by the first sender

526
00:26:09,840 --> 00:26:12,659
we build it using these ingredients so

527
00:26:12,659 --> 00:26:14,240
we use symmetric key encryption

528
00:26:14,240 --> 00:26:17,340
adaptively CPA once added single input

529
00:26:17,340 --> 00:26:19,200
predicate encryption and lockable

530
00:26:19,200 --> 00:26:20,400
obfuscation

531
00:26:20,400 --> 00:26:21,900
and the reason why we need some

532
00:26:21,900 --> 00:26:24,779
exponential W is because from awe to get

533
00:26:24,779 --> 00:26:26,640
adaptive security we need complexity

534
00:26:26,640 --> 00:26:29,039
leveraging

535
00:26:29,039 --> 00:26:31,200
so I'm not going to talk about oh sorry

536
00:26:31,200 --> 00:26:33,419
this the construction is secured in the

537
00:26:33,419 --> 00:26:35,820
case of a single decryption key

538
00:26:35,820 --> 00:26:37,559
so that personality had a single

539
00:26:37,559 --> 00:26:39,900
decryption key for a predicate may seem

540
00:26:39,900 --> 00:26:41,940
like a very restricted case but

541
00:26:41,940 --> 00:26:44,400
technically speaking if you support very

542
00:26:44,400 --> 00:26:46,320
large class of predicates this notion

543
00:26:46,320 --> 00:26:48,360
implies strong Primitives like witness

544
00:26:48,360 --> 00:26:51,799
encryption and nalayo

545
00:26:52,380 --> 00:26:53,760
um I'm not going to talk about this

546
00:26:53,760 --> 00:26:55,500
construction and I'm going to move on in

547
00:26:55,500 --> 00:26:57,720
a much more challenging case of security

548
00:26:57,720 --> 00:27:00,059
so this is the corruption section now

549
00:27:00,059 --> 00:27:02,880
and there is an additional article that

550
00:27:02,880 --> 00:27:04,860
you can submit an index and you obtain

551
00:27:04,860 --> 00:27:06,480
the encryption key of the corresponding

552
00:27:06,480 --> 00:27:10,260
encryptor or the corresponding sender

553
00:27:10,260 --> 00:27:13,440
the definition is uh as before but the

554
00:27:13,440 --> 00:27:15,240
difference is that now since you can

555
00:27:15,240 --> 00:27:17,580
encrypt one of the you can corrupt one

556
00:27:17,580 --> 00:27:19,860
of the senders you can get the

557
00:27:19,860 --> 00:27:21,419
corresponding encryption key and you can

558
00:27:21,419 --> 00:27:23,220
try any possible input for recording

559
00:27:23,220 --> 00:27:25,080
corresponding slot so we need to claim

560
00:27:25,080 --> 00:27:26,640
that the predict is not satisfied even

561
00:27:26,640 --> 00:27:28,380
if you try any possible combination of

562
00:27:28,380 --> 00:27:31,559
the corrupted slots

563
00:27:31,559 --> 00:27:34,679
we have another construction uh for this

564
00:27:34,679 --> 00:27:37,200
case so we obtain an activity CPA once

565
00:27:37,200 --> 00:27:38,760
at a secure multimed predicate

566
00:27:38,760 --> 00:27:40,559
encryption but now the number of inputs

567
00:27:40,559 --> 00:27:42,840
must be constant

568
00:27:42,840 --> 00:27:44,820
and we tolerate up to n minus one

569
00:27:44,820 --> 00:27:46,320
Corruptions

570
00:27:46,320 --> 00:27:48,600
we still use of exponential w e the

571
00:27:48,600 --> 00:27:50,880
class of pretty is the usual one with a

572
00:27:50,880 --> 00:27:53,039
difference and the difference that each

573
00:27:53,039 --> 00:27:56,100
predicate of the of the of the

574
00:27:56,100 --> 00:27:58,799
conjunction presents a wildcard so there

575
00:27:58,799 --> 00:28:01,380
is an input that satisfies the the

576
00:28:01,380 --> 00:28:04,620
independent on which one you choose

577
00:28:04,620 --> 00:28:07,020
and I want to stress that the pre-walker

578
00:28:07,020 --> 00:28:09,720
is needed for both for functionality and

579
00:28:09,720 --> 00:28:11,880
security

580
00:28:11,880 --> 00:28:14,039
and these are the ingredients that are

581
00:28:14,039 --> 00:28:16,620
essentially this the like the one of the

582
00:28:16,620 --> 00:28:17,880
previous construction but we replace

583
00:28:17,880 --> 00:28:20,520
symmetric encryption with public key

584
00:28:20,520 --> 00:28:22,320
encryption but the construction is

585
00:28:22,320 --> 00:28:24,840
completely different

586
00:28:24,840 --> 00:28:26,820
and technically we don't even need

587
00:28:26,820 --> 00:28:28,260
predicate encryption in this case it's

588
00:28:28,260 --> 00:28:29,640
sufficient to use an active-based

589
00:28:29,640 --> 00:28:31,320
encryption scheme

590
00:28:31,320 --> 00:28:32,880
and the construction seals you in the

591
00:28:32,880 --> 00:28:35,700
single key case

592
00:28:35,700 --> 00:28:37,260
so I'm going to talk about the

593
00:28:37,260 --> 00:28:38,820
construction so let me introduce first

594
00:28:38,820 --> 00:28:41,100
lockable obfuscation uh you can

595
00:28:41,100 --> 00:28:42,720
obfuscate a circuit C

596
00:28:42,720 --> 00:28:46,200
using a log Y and a message

597
00:28:46,200 --> 00:28:48,480
European notification that has a

598
00:28:48,480 --> 00:28:50,279
slightly different functionality and the

599
00:28:50,279 --> 00:28:51,900
functionality is the following so on

600
00:28:51,900 --> 00:28:52,980
input text

601
00:28:52,980 --> 00:28:55,200
the obfuscation is going to Output the

602
00:28:55,200 --> 00:28:58,320
message if C on input text outputs the

603
00:28:58,320 --> 00:28:59,760
lock

604
00:28:59,760 --> 00:29:02,880
and the security says that very formally

605
00:29:02,880 --> 00:29:04,380
that when you don't know the lock and

606
00:29:04,380 --> 00:29:06,120
the lock is random then you can simulate

607
00:29:06,120 --> 00:29:08,418
the circle

608
00:29:09,179 --> 00:29:09,840
um

609
00:29:09,840 --> 00:29:11,940
how we can build the true input previous

610
00:29:11,940 --> 00:29:15,419
encryption using these tools well uh

611
00:29:15,419 --> 00:29:18,120
let's talk about the first sender or you

612
00:29:18,120 --> 00:29:19,620
have an encryption key that is composed

613
00:29:19,620 --> 00:29:23,279
by the master public key of a single

614
00:29:23,279 --> 00:29:25,140
input predicate encryption

615
00:29:25,140 --> 00:29:27,720
a public key one public key 2 of the

616
00:29:27,720 --> 00:29:29,520
public inclusion scheme and the secret

617
00:29:29,520 --> 00:29:32,700
key number one corresponding to pk1

618
00:29:32,700 --> 00:29:35,340
what you do you sample two logs and

619
00:29:35,340 --> 00:29:37,620
we're gonna call a outer lock and

620
00:29:37,620 --> 00:29:38,820
interlock

621
00:29:38,820 --> 00:29:42,240
we are gonna encrypt both of them

622
00:29:42,240 --> 00:29:43,980
using the predicate encryption scheme

623
00:29:43,980 --> 00:29:46,320
and since it's a single input predicate

624
00:29:46,320 --> 00:29:47,580
encryption scheme

625
00:29:47,580 --> 00:29:50,640
we need to choose the input this

626
00:29:50,640 --> 00:29:52,440
at the moment of the encryption but we

627
00:29:52,440 --> 00:29:53,760
assume that the input is composed by two

628
00:29:53,760 --> 00:29:55,740
parts so the first part we're gonna put

629
00:29:55,740 --> 00:29:58,200
the real input so X1 in the second part

630
00:29:58,200 --> 00:30:01,220
we're going to put wiser

631
00:30:01,380 --> 00:30:02,340
um

632
00:30:02,340 --> 00:30:04,679
then we I'm gonna encrypt the server

633
00:30:04,679 --> 00:30:06,899
taxi twice using the the public key

634
00:30:06,899 --> 00:30:10,140
encryption scheme using pk1 and pk2 we

635
00:30:10,140 --> 00:30:12,600
obtain W1 and then we start producing

636
00:30:12,600 --> 00:30:15,600
some obfuscation so the first is an

637
00:30:15,600 --> 00:30:17,760
obfuscation of an inner circuit with our

638
00:30:17,760 --> 00:30:20,820
coded W1 and sk1

639
00:30:20,820 --> 00:30:23,159
we're gonna use the inner lock and the

640
00:30:23,159 --> 00:30:25,799
message is going to be sk1

641
00:30:25,799 --> 00:30:27,539
and we also office create another

642
00:30:27,539 --> 00:30:28,980
circuit

643
00:30:28,980 --> 00:30:31,080
uh you have the same recorded

644
00:30:31,080 --> 00:30:32,159
informations

645
00:30:32,159 --> 00:30:33,899
but now we are going to use the outer

646
00:30:33,899 --> 00:30:35,820
lock and the message is the message you

647
00:30:35,820 --> 00:30:37,740
want to encrypt so M1

648
00:30:37,740 --> 00:30:40,080
and this is the ciphertext

649
00:30:40,080 --> 00:30:42,539
on the second scenario you essentially

650
00:30:42,539 --> 00:30:45,720
do the same with few differences so now

651
00:30:45,720 --> 00:30:47,460
you have the secret key number two

652
00:30:47,460 --> 00:30:48,960
because you are the first the second

653
00:30:48,960 --> 00:30:50,399
sender

654
00:30:50,399 --> 00:30:53,700
uh and then when you encrypt uh using

655
00:30:53,700 --> 00:30:55,320
the previous encryption scheme you're

656
00:30:55,320 --> 00:30:57,120
gonna put the wi-fi in the order slot so

657
00:30:57,120 --> 00:30:58,679
in the first slot

658
00:30:58,679 --> 00:31:02,880
and the real input in the second one

659
00:31:02,880 --> 00:31:05,580
on decryption you have a decryption key

660
00:31:05,580 --> 00:31:06,779
for a predicate that is simply the

661
00:31:06,779 --> 00:31:08,399
description key of the predicate

662
00:31:08,399 --> 00:31:09,720
encryption

663
00:31:09,720 --> 00:31:12,419
and the predicate is this one by in the

664
00:31:12,419 --> 00:31:14,820
single input case so you have an input

665
00:31:14,820 --> 00:31:16,860
composed by X1 and 2 and then it's a

666
00:31:16,860 --> 00:31:18,179
conjunction of two independent

667
00:31:18,179 --> 00:31:20,600
predicates

668
00:31:21,120 --> 00:31:22,080
um

669
00:31:22,080 --> 00:31:23,940
you can use this key to decrypt how you

670
00:31:23,940 --> 00:31:25,380
decrypt so we have a bunch of

671
00:31:25,380 --> 00:31:27,980
obfuscations what you do you to get M1

672
00:31:27,980 --> 00:31:31,380
you run the outer obfuscation with input

673
00:31:31,380 --> 00:31:33,899
the decryption key for the predicate and

674
00:31:33,899 --> 00:31:35,940
the obfuscation of the inner circuit but

675
00:31:35,940 --> 00:31:38,100
of the other sender so then notification

676
00:31:38,100 --> 00:31:39,659
number two

677
00:31:39,659 --> 00:31:41,100
and to get them through you do the

678
00:31:41,100 --> 00:31:42,899
symmetric case so you run the outer

679
00:31:42,899 --> 00:31:45,000
Circuit of the second sender

680
00:31:45,000 --> 00:31:46,860
on input the decryption for the

681
00:31:46,860 --> 00:31:48,659
predicate and the inner secret of the

682
00:31:48,659 --> 00:31:50,039
first sender

683
00:31:50,039 --> 00:31:53,100
you get both messages and of course I

684
00:31:53,100 --> 00:31:54,960
mean decryption Works depending on how

685
00:31:54,960 --> 00:31:57,659
you you you define these circuits

686
00:31:57,659 --> 00:32:00,899
uh The Fairly complex so I'm going to

687
00:32:00,899 --> 00:32:02,460
show you just a graphical representation

688
00:32:02,460 --> 00:32:05,100
of how to get M1 for example

689
00:32:05,100 --> 00:32:07,140
so this is what you execute to get them

690
00:32:07,140 --> 00:32:07,919
on

691
00:32:07,919 --> 00:32:10,919
remember that uh attached to this this

692
00:32:10,919 --> 00:32:12,779
sophistication you have the these

693
00:32:12,779 --> 00:32:13,980
informations

694
00:32:13,980 --> 00:32:16,080
and we we need to know that we we have

695
00:32:16,080 --> 00:32:18,840
sk1r coded into defuscation so what we

696
00:32:18,840 --> 00:32:21,240
can do we're gonna run the inner circuit

697
00:32:21,240 --> 00:32:23,159
with input the decryption key for the

698
00:32:23,159 --> 00:32:24,779
predicate and we pass the secret key

699
00:32:24,779 --> 00:32:26,940
number one

700
00:32:26,940 --> 00:32:29,880
these are the informational attached to

701
00:32:29,880 --> 00:32:32,520
the second the obfuscation of the index

702
00:32:32,520 --> 00:32:36,240
circuit and note that we have sk2 as the

703
00:32:36,240 --> 00:32:38,580
message and also are coded in the

704
00:32:38,580 --> 00:32:39,899
circuit

705
00:32:39,899 --> 00:32:42,960
so now we have both keys we can decrypt

706
00:32:42,960 --> 00:32:45,059
the two layers of public encryption and

707
00:32:45,059 --> 00:32:46,980
we can decrypt also the predicate

708
00:32:46,980 --> 00:32:49,559
encryption cycle text if you succeed we

709
00:32:49,559 --> 00:32:51,059
know that the second party is satisfied

710
00:32:51,059 --> 00:32:53,100
and we only know the second predicate

711
00:32:53,100 --> 00:32:54,899
because the second sender has put the Y

712
00:32:54,899 --> 00:32:57,179
car in the first slot

713
00:32:57,179 --> 00:32:58,980
but this is sufficient to return the

714
00:32:58,980 --> 00:33:00,480
correct lock and this is going to

715
00:33:00,480 --> 00:33:03,000
release sk2 to the end to other circuit

716
00:33:03,000 --> 00:33:05,159
now the other circuit has both keys

717
00:33:05,159 --> 00:33:07,020
again I can do the same computation

718
00:33:07,020 --> 00:33:08,640
but now when you succeed then you

719
00:33:08,640 --> 00:33:10,980
decrypt the uh

720
00:33:10,980 --> 00:33:13,140
the predicate encryption ciphertext you

721
00:33:13,140 --> 00:33:15,419
know that also P1 is satisfied

722
00:33:15,419 --> 00:33:17,940
I returned the message

723
00:33:17,940 --> 00:33:20,100
uh to get them true you do the same

724
00:33:20,100 --> 00:33:22,019
essentially the same computation but for

725
00:33:22,019 --> 00:33:24,480
the symmetic case

726
00:33:24,480 --> 00:33:26,519
so we can generalize the technique for

727
00:33:26,519 --> 00:33:30,000
Ang greater than two but it's

728
00:33:30,000 --> 00:33:33,600
some technicalities to some challenges

729
00:33:33,600 --> 00:33:35,700
so the high level it is that we're gonna

730
00:33:35,700 --> 00:33:37,140
have multiple layers of public

731
00:33:37,140 --> 00:33:39,419
encryption one for each sender so we're

732
00:33:39,419 --> 00:33:41,580
gonna have n layers

733
00:33:41,580 --> 00:33:43,679
and we're gonna have an inner circuits

734
00:33:43,679 --> 00:33:45,779
and during the description we're gonna

735
00:33:45,779 --> 00:33:47,580
start executing the Inner Circle one

736
00:33:47,580 --> 00:33:49,380
into the other and every time we pass a

737
00:33:49,380 --> 00:33:51,600
new secret key into the next one so the

738
00:33:51,600 --> 00:33:53,220
last one you execute has all the secret

739
00:33:53,220 --> 00:33:55,260
keys and you can decrypt every layer and

740
00:33:55,260 --> 00:33:57,659
then the project encryption ciphertext

741
00:33:57,659 --> 00:34:00,960
the problem is that you need to uh to

742
00:34:00,960 --> 00:34:02,760
check the conjunction is satisfied you

743
00:34:02,760 --> 00:34:05,159
need to give the secret keys to any net

744
00:34:05,159 --> 00:34:06,179
circuit

745
00:34:06,179 --> 00:34:08,040
and since lockable application is not

746
00:34:08,040 --> 00:34:09,780
strong enough we need to run the same in

747
00:34:09,780 --> 00:34:11,460
the circuit multiple times so the

748
00:34:11,460 --> 00:34:13,859
execution is like an energy of I10 and

749
00:34:13,859 --> 00:34:15,480
that's why we support the decryption

750
00:34:15,480 --> 00:34:17,460
size n over n and we support only

751
00:34:17,460 --> 00:34:19,199
constant inputs

752
00:34:19,199 --> 00:34:21,300
and I'm not going to talk about the

753
00:34:21,300 --> 00:34:23,760
security but I want just to say that we

754
00:34:23,760 --> 00:34:25,560
tolerate corruption because we have

755
00:34:25,560 --> 00:34:27,899
multiple layers of public key encryption

756
00:34:27,899 --> 00:34:30,418
and until if you have one on a standard

757
00:34:30,418 --> 00:34:32,879
there is one layer you cannot decrypt

758
00:34:32,879 --> 00:34:36,060
and the wild card is fundamental and

759
00:34:36,060 --> 00:34:37,980
it's not easy to remove because if you

760
00:34:37,980 --> 00:34:39,418
have the same construction for the same

761
00:34:39,418 --> 00:34:40,918
class of predicates in the corruption

762
00:34:40,918 --> 00:34:43,800
setting without the wild card then you

763
00:34:43,800 --> 00:34:45,239
the Consortium implies witness

764
00:34:45,239 --> 00:34:48,599
encryption and another you so it's not

765
00:34:48,599 --> 00:34:51,379
trivial to remove

766
00:34:51,480 --> 00:34:54,060
um some other considerations and we

767
00:34:54,060 --> 00:34:55,859
extend the results that we have to from

768
00:34:55,859 --> 00:34:58,080
the CPA once at the setting to the CPA

769
00:34:58,080 --> 00:35:00,420
two-sided but this is required to use as

770
00:35:00,420 --> 00:35:02,280
two-sided predicate encryption scheme

771
00:35:02,280 --> 00:35:03,540
already

772
00:35:03,540 --> 00:35:06,240
and we showed also that multi-key with

773
00:35:06,240 --> 00:35:09,000
cpa1 study security implies match my

774
00:35:09,000 --> 00:35:11,160
encryption with mismatched security

775
00:35:11,160 --> 00:35:13,980
and we can see a multi-input prediction

776
00:35:13,980 --> 00:35:17,700
with corruption like some form of weaker

777
00:35:17,700 --> 00:35:19,920
form of uh no interactive NPC for the

778
00:35:19,920 --> 00:35:22,820
function that you see here

779
00:35:23,160 --> 00:35:28,098
um yeah that's it thank you

780
00:35:28,450 --> 00:35:33,000
[Applause]

781
00:35:33,000 --> 00:35:35,700
so if you have a question please come

782
00:35:35,700 --> 00:35:38,720
you can come to the mic

783
00:35:43,500 --> 00:35:47,820
so I wanted to ask about the number of

784
00:35:47,820 --> 00:35:50,960
keys so you said that if you support

785
00:35:50,960 --> 00:35:53,640
multiple Keys then it has implications

786
00:35:53,640 --> 00:35:54,859
to

787
00:35:54,859 --> 00:35:58,260
hard things like witness encryption but

788
00:35:58,260 --> 00:36:00,839
that's only if you allow user corruption

789
00:36:00,839 --> 00:36:02,099
right

790
00:36:02,099 --> 00:36:05,040
so if I don't care about user corruption

791
00:36:05,040 --> 00:36:08,460
then there's no fundamental barrier to

792
00:36:08,460 --> 00:36:10,680
supporting many cases there

793
00:36:10,680 --> 00:36:13,619
so the situation is that if it's a

794
00:36:13,619 --> 00:36:17,099
popular action we just need uh assuming

795
00:36:17,099 --> 00:36:20,520
that we support arbitrary predicates so

796
00:36:20,520 --> 00:36:22,740
sorry sorry for the case of course I

797
00:36:22,740 --> 00:36:25,440
don't care about it okay I don't want

798
00:36:25,440 --> 00:36:27,740
in that case I I think that

799
00:36:27,740 --> 00:36:31,740
I mean one should be there's no barrier

800
00:36:31,740 --> 00:36:35,660
right to supporting many keys

801
00:36:35,940 --> 00:36:37,560
[Music]

802
00:36:37,560 --> 00:36:41,099
you mean decryption keys or encryption

803
00:36:41,099 --> 00:36:43,400
keys

804
00:36:46,040 --> 00:36:49,320
uh no I mean I I don't think there is a

805
00:36:49,320 --> 00:36:50,700
budget by all construction doesn't

806
00:36:50,700 --> 00:36:52,859
doesn't achieve that there's no that's

807
00:36:52,859 --> 00:36:54,320
what yeah

808
00:36:54,320 --> 00:36:57,180
your Construction question what goes

809
00:36:57,180 --> 00:36:59,400
wrong like if I if I ask for two yeah

810
00:36:59,400 --> 00:37:01,140
because we use the single input

811
00:37:01,140 --> 00:37:03,420
prediction as a black box and to start

812
00:37:03,420 --> 00:37:05,040
the proof we need to assume that there

813
00:37:05,040 --> 00:37:07,320
is one predicate of the conjunction that

814
00:37:07,320 --> 00:37:09,599
is never satisfied in depending from the

815
00:37:09,599 --> 00:37:11,640
interleeming of the ciphertext

816
00:37:11,640 --> 00:37:15,180
and we are sure about this this case

817
00:37:15,180 --> 00:37:16,859
only when you have one decryption key

818
00:37:16,859 --> 00:37:19,440
because otherwise think about you have

819
00:37:19,440 --> 00:37:21,800
like

820
00:37:22,880 --> 00:37:26,160
to a conjunction of two predicates it

821
00:37:26,160 --> 00:37:28,020
may be that the first is not satisfied

822
00:37:28,020 --> 00:37:31,140
and the first one is so the first is not

823
00:37:31,140 --> 00:37:34,320
satisfied and the second one it is but

824
00:37:34,320 --> 00:37:35,940
also the other way around so you may

825
00:37:35,940 --> 00:37:38,700
have another key in which now it's the

826
00:37:38,700 --> 00:37:41,099
symmetric case and we cannot do the

827
00:37:41,099 --> 00:37:42,720
proof in this case so we need that one

828
00:37:42,720 --> 00:37:45,799
is not satisfied always

829
00:37:51,300 --> 00:37:53,040
okay so if there are no more questions

830
00:37:53,040 --> 00:37:56,000
let's thank Daniel again

831
00:37:56,000 --> 00:37:59,150
[Applause]

