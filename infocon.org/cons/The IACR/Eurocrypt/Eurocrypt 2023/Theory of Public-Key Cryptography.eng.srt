1
00:00:01,740 --> 00:00:04,380
so uh welcome to this session on the

2
00:00:04,380 --> 00:00:07,319
theory of public key cryptography and uh

3
00:00:07,319 --> 00:00:10,019
we'll start with our first talk now I

4
00:00:10,019 --> 00:00:13,080
wanted to say to remind you all that the

5
00:00:13,080 --> 00:00:15,599
ramp session is tonight and if you want

6
00:00:15,599 --> 00:00:17,640
to present then please do send your

7
00:00:17,640 --> 00:00:21,080
slides by 1pm

8
00:00:21,359 --> 00:00:24,779
so we'll start with our first talk this

9
00:00:24,779 --> 00:00:27,180
is deniable authentication when signing

10
00:00:27,180 --> 00:00:29,400
Keys leak by subradeep chakraborty

11
00:00:29,400 --> 00:00:32,700
Dennis hoffines Oli Maurer and gear Rito

12
00:00:32,700 --> 00:00:36,920
and girme will give the talk thank you

13
00:00:39,840 --> 00:00:42,960
okay so uh hi uh welcome to this

14
00:00:42,960 --> 00:00:44,879
presentation on denial authentication

15
00:00:44,879 --> 00:00:48,000
when signing is leak this is trying to

16
00:00:48,000 --> 00:00:50,460
work with shivradeep chakraborty Tennis

17
00:00:50,460 --> 00:00:53,520
Hall finds and William Orr

18
00:00:53,520 --> 00:00:56,300
okay so let's start with some motivation

19
00:00:56,300 --> 00:00:59,160
the basic guarantee is that secure

20
00:00:59,160 --> 00:01:01,100
messaging applications should give are

21
00:01:01,100 --> 00:01:04,140
confidentiality and authenticity

22
00:01:04,140 --> 00:01:06,479
and because

23
00:01:06,479 --> 00:01:08,820
we tend to use tend to have like

24
00:01:08,820 --> 00:01:10,439
long-dist sessions on our phones on

25
00:01:10,439 --> 00:01:11,640
these applications

26
00:01:11,640 --> 00:01:14,100
Uh current messaging applications also

27
00:01:14,100 --> 00:01:16,380
try to give us guarantees like forward

28
00:01:16,380 --> 00:01:19,200
secrecy and backward secrecy

29
00:01:19,200 --> 00:01:21,900
Ford secrecy guarantees is that if all

30
00:01:21,900 --> 00:01:23,640
parties want to delete the chat history

31
00:01:23,640 --> 00:01:26,220
then they can do this

32
00:01:26,220 --> 00:01:29,280
and backward secrecy gives us guarantees

33
00:01:29,280 --> 00:01:32,580
that even after a party's uh phone is

34
00:01:32,580 --> 00:01:33,900
compromised

35
00:01:33,900 --> 00:01:35,759
it is possible to recover for example

36
00:01:35,759 --> 00:01:38,600
confidentiality

37
00:01:39,240 --> 00:01:40,500
so but then there are a few questions

38
00:01:40,500 --> 00:01:42,900
which is which are for example what if

39
00:01:42,900 --> 00:01:45,840
some parties want to keep a chat history

40
00:01:45,840 --> 00:01:49,079
in this case Ford secrecy gives us no

41
00:01:49,079 --> 00:01:51,000
guarantee

42
00:01:51,000 --> 00:01:53,759
and what if some parties are dishonest

43
00:01:53,759 --> 00:01:56,100
in this case neither Ford secrecy nor

44
00:01:56,100 --> 00:02:00,060
backward secrecy give an any guarantee

45
00:02:00,060 --> 00:02:01,860
so then what can we hope for in this

46
00:02:01,860 --> 00:02:03,899
case is

47
00:02:03,899 --> 00:02:06,299
well one guarantee is off the Record

48
00:02:06,299 --> 00:02:08,220
deniability

49
00:02:08,220 --> 00:02:10,739
so consider the following setting there

50
00:02:10,739 --> 00:02:12,959
are two parties who are setting logos

51
00:02:12,959 --> 00:02:15,900
and video buckles is dishonest is and is

52
00:02:15,900 --> 00:02:17,700
the owner of this phone

53
00:02:17,700 --> 00:02:19,800
and video is honest

54
00:02:19,800 --> 00:02:21,900
and is a killer

55
00:02:21,900 --> 00:02:24,120
there is also another party who is Judy

56
00:02:24,120 --> 00:02:29,340
and Judy is dishonest it's a judge

57
00:02:29,340 --> 00:02:31,560
so the thing is that Video Killed the

58
00:02:31,560 --> 00:02:33,959
Radio Star so boggles will try to

59
00:02:33,959 --> 00:02:35,819
convince Judy that Video Killed the

60
00:02:35,819 --> 00:02:38,160
Radio Star and off the Record guarantees

61
00:02:38,160 --> 00:02:39,000
that

62
00:02:39,000 --> 00:02:41,340
even if Buggles gives Judith's phone all

63
00:02:41,340 --> 00:02:43,980
its secret keys and co-ops cooperates in

64
00:02:43,980 --> 00:02:46,260
any way Judy should not be convinced

65
00:02:46,260 --> 00:02:50,299
that Video Killed radius are

66
00:02:50,640 --> 00:02:52,680
okay another guarantee that we may want

67
00:02:52,680 --> 00:02:55,140
is consistency

68
00:02:55,140 --> 00:02:57,599
so consider what if video now creates a

69
00:02:57,599 --> 00:03:00,120
chat group called killer confession

70
00:03:00,120 --> 00:03:01,920
and there are three parties in this

71
00:03:01,920 --> 00:03:02,760
group

72
00:03:02,760 --> 00:03:05,580
there is Buggles who now is honest the

73
00:03:05,580 --> 00:03:08,340
video who now is dishonest and the third

74
00:03:08,340 --> 00:03:10,080
party is Grace

75
00:03:10,080 --> 00:03:12,300
and Grace is honest and is an inspector

76
00:03:12,300 --> 00:03:16,620
who is looking for radio star's killer

77
00:03:16,620 --> 00:03:19,500
so now video's goal is going to be to

78
00:03:19,500 --> 00:03:22,080
try to somehow frame buckles and one

79
00:03:22,080 --> 00:03:23,819
thing it could try to do is to just send

80
00:03:23,819 --> 00:03:26,700
malfront Cipher texts that will decrypt

81
00:03:26,700 --> 00:03:30,120
differently in boggles and Grace's fonts

82
00:03:30,120 --> 00:03:31,879
for example the following could happen

83
00:03:31,879 --> 00:03:34,739
so a video comes up with some Cipher

84
00:03:34,739 --> 00:03:37,680
texts that in boggles phone which is

85
00:03:37,680 --> 00:03:39,780
here in dark mode on the left will show

86
00:03:39,780 --> 00:03:42,900
up as if it was asking did you know that

87
00:03:42,900 --> 00:03:44,640
I Killed the Radio Star

88
00:03:44,640 --> 00:03:46,980
and buckle should just reply yes finally

89
00:03:46,980 --> 00:03:48,959
are confessing or her confession yes I

90
00:03:48,959 --> 00:03:51,780
did but on Grace's phone it would show

91
00:03:51,780 --> 00:03:53,580
up as did you kill the Radio Star and

92
00:03:53,580 --> 00:03:56,400
then boggles message would look a bit

93
00:03:56,400 --> 00:03:58,580
bad

94
00:03:58,920 --> 00:04:02,640
okay so there is a type of schemes that

95
00:04:02,640 --> 00:04:05,040
essentially give us all these guarantees

96
00:04:05,040 --> 00:04:08,280
which was introduced by modern last year

97
00:04:08,280 --> 00:04:11,580
and this is MDR SPCA or multi-designated

98
00:04:11,580 --> 00:04:13,680
receiver signed public encryption

99
00:04:13,680 --> 00:04:14,640
schemes

100
00:04:14,640 --> 00:04:16,738
and actually they also give us anonymity

101
00:04:16,738 --> 00:04:19,820
I'm not going to explain why

102
00:04:19,820 --> 00:04:22,740
this is also useful for secure messaging

103
00:04:22,740 --> 00:04:24,840
but I am not going to explain you why in

104
00:04:24,840 --> 00:04:27,000
this presentation

105
00:04:27,000 --> 00:04:28,380
okay

106
00:04:28,380 --> 00:04:30,900
so let's have again another look at this

107
00:04:30,900 --> 00:04:33,479
off the records and ability

108
00:04:33,479 --> 00:04:35,699
so I was telling you that boggles was

109
00:04:35,699 --> 00:04:37,320
dishonest and was trying to convince

110
00:04:37,320 --> 00:04:40,500
Judy that video sent this message

111
00:04:40,500 --> 00:04:42,900
but it could also be that boggles is

112
00:04:42,900 --> 00:04:44,280
honest and that there is some other

113
00:04:44,280 --> 00:04:47,280
party imagine if we just looked up over

114
00:04:47,280 --> 00:04:50,100
boggles phones and saw in the phone a

115
00:04:50,100 --> 00:04:51,840
message from video saying that it Killed

116
00:04:51,840 --> 00:04:53,580
the Radio Star

117
00:04:53,580 --> 00:04:57,479
we want that in any way Judy will not be

118
00:04:57,479 --> 00:05:00,300
convinced that Video Killed Radio Star

119
00:05:00,300 --> 00:05:02,280
regardless of whether it's just if

120
00:05:02,280 --> 00:05:05,639
cooperating with Judy or if bugles is

121
00:05:05,639 --> 00:05:08,880
also cooperating with Judy

122
00:05:08,880 --> 00:05:10,740
so to summarize

123
00:05:10,740 --> 00:05:13,560
if boggles is honest if we'll be

124
00:05:13,560 --> 00:05:15,600
cooperating with Judy

125
00:05:15,600 --> 00:05:17,759
and in this case 2D Only Knows public

126
00:05:17,759 --> 00:05:19,259
information

127
00:05:19,259 --> 00:05:22,259
and if boggles is dishonest then Judy

128
00:05:22,259 --> 00:05:24,000
will know public information but now

129
00:05:24,000 --> 00:05:27,180
also battle secret keys

130
00:05:27,180 --> 00:05:29,160
but then there is a question so video is

131
00:05:29,160 --> 00:05:31,080
Under Suspicion so what if 2D maybe

132
00:05:31,080 --> 00:05:33,780
could get somehow video secret keys

133
00:05:33,780 --> 00:05:35,580
and this is the setting that we consider

134
00:05:35,580 --> 00:05:37,680
in this work

135
00:05:37,680 --> 00:05:40,620
for instance if boggles is honest and

136
00:05:40,620 --> 00:05:43,020
Judy will know public information and

137
00:05:43,020 --> 00:05:44,940
video secret keys

138
00:05:44,940 --> 00:05:47,639
and if boggles is dishonest then Judy

139
00:05:47,639 --> 00:05:49,919
will know all public information Boggle

140
00:05:49,919 --> 00:05:51,900
secret kids and now also video secret

141
00:05:51,900 --> 00:05:54,380
keys

142
00:05:54,960 --> 00:05:57,900
okay so another thing that's also very

143
00:05:57,900 --> 00:06:00,419
important for uh

144
00:06:00,419 --> 00:06:05,479
is the scalability of MDR SPCA schemes

145
00:06:05,520 --> 00:06:08,160
there are two types of scalability first

146
00:06:08,160 --> 00:06:10,020
there is scalability in terms of

147
00:06:10,020 --> 00:06:13,199
security so we want that security should

148
00:06:13,199 --> 00:06:15,240
be independent of the number of users

149
00:06:15,240 --> 00:06:17,520
and the number of messages and of course

150
00:06:17,520 --> 00:06:20,580
this is very important for messaging

151
00:06:20,580 --> 00:06:23,819
and another thing that we also want is

152
00:06:23,819 --> 00:06:25,620
that if you have a chat group with n

153
00:06:25,620 --> 00:06:26,940
participants

154
00:06:26,940 --> 00:06:29,819
the ciphertext size and the encryption

155
00:06:29,819 --> 00:06:32,220
and decryption times should be at most

156
00:06:32,220 --> 00:06:36,600
linear with the number of participants

157
00:06:37,080 --> 00:06:39,419
so the thing is that in Prior work

158
00:06:39,419 --> 00:06:43,080
the only existing mdrs pke Construction

159
00:06:43,080 --> 00:06:45,060
the security actually degrades with the

160
00:06:45,060 --> 00:06:46,259
number of users

161
00:06:46,259 --> 00:06:48,479
and on the other hand

162
00:06:48,479 --> 00:06:50,759
for a shot group within participants the

163
00:06:50,759 --> 00:06:52,860
server text size the encryption

164
00:06:52,860 --> 00:06:54,660
decryption times all grow quadratically

165
00:06:54,660 --> 00:06:57,000
with the number of users

166
00:06:57,000 --> 00:06:59,460
so what we do in our work is to give the

167
00:06:59,460 --> 00:07:01,500
first scalable Construction

168
00:07:01,500 --> 00:07:03,419
where security is actually independent

169
00:07:03,419 --> 00:07:05,220
of both the number of users and the

170
00:07:05,220 --> 00:07:07,440
number of messages and where for a group

171
00:07:07,440 --> 00:07:10,080
shot within participants the ciphertext

172
00:07:10,080 --> 00:07:12,120
size and the encryption decryption times

173
00:07:12,120 --> 00:07:13,860
only grow linearly with the number of

174
00:07:13,860 --> 00:07:16,460
participants

175
00:07:17,699 --> 00:07:19,560
okay so now let's just have a brief

176
00:07:19,560 --> 00:07:20,940
overview of

177
00:07:20,940 --> 00:07:24,419
how to construct an MDR SPCA scheme

178
00:07:24,419 --> 00:07:26,099
so there is a very simple way to

179
00:07:26,099 --> 00:07:28,020
construct such as Kim

180
00:07:28,020 --> 00:07:30,060
and as building blocks

181
00:07:30,060 --> 00:07:32,819
we use public encryption for broadcast

182
00:07:32,819 --> 00:07:35,280
and a multi-designated verifier

183
00:07:35,280 --> 00:07:38,059
signature scheme

184
00:07:38,520 --> 00:07:40,620
the main idea for this construction is

185
00:07:40,620 --> 00:07:43,500
to use the mdvs scheme to sign the

186
00:07:43,500 --> 00:07:45,840
receiver's PK BC public keys and the

187
00:07:45,840 --> 00:07:46,680
message

188
00:07:46,680 --> 00:07:48,780
and then encrypt everything using this

189
00:07:48,780 --> 00:07:50,819
big ABC scheme so we encrypt the senders

190
00:07:50,819 --> 00:07:52,680
and receivers mdvs public Keys the

191
00:07:52,680 --> 00:07:54,720
message and the signature

192
00:07:54,720 --> 00:07:57,180
the final ciphertext is just this PK EBC

193
00:07:57,180 --> 00:07:59,780
ciphertext

194
00:08:00,660 --> 00:08:02,639
so we have to make sure of a few things

195
00:08:02,639 --> 00:08:04,259
to make sure that the scheme is scalable

196
00:08:04,259 --> 00:08:07,080
in terms of security one of the things

197
00:08:07,080 --> 00:08:09,539
is that the security reductions to the

198
00:08:09,539 --> 00:08:12,419
underlying pick ABC schemes and mdvs

199
00:08:12,419 --> 00:08:13,860
scheme are tight

200
00:08:13,860 --> 00:08:16,440
and actually yes they are from the

201
00:08:16,440 --> 00:08:19,199
existing construction by Mario all

202
00:08:19,199 --> 00:08:21,240
another thing we have to ensure is that

203
00:08:21,240 --> 00:08:23,759
there is actually pkbc scheme with tight

204
00:08:23,759 --> 00:08:25,319
security reductions

205
00:08:25,319 --> 00:08:27,599
two standard assumptions and the answer

206
00:08:27,599 --> 00:08:30,060
to this is also yes

207
00:08:30,060 --> 00:08:33,899
however there is no mdvs scheme with

208
00:08:33,899 --> 00:08:35,580
tight security reductions to standard

209
00:08:35,580 --> 00:08:37,440
assumptions and this is the first

210
00:08:37,440 --> 00:08:40,700
problem we consider in the paper

211
00:08:40,979 --> 00:08:44,159
so another thing is about efficiency

212
00:08:44,159 --> 00:08:46,320
for example consider that we are sending

213
00:08:46,320 --> 00:08:48,720
a message to the receivers

214
00:08:48,720 --> 00:08:50,880
on one hand we already have an mdvs

215
00:08:50,880 --> 00:08:53,279
scheme by dumbartol which achieves

216
00:08:53,279 --> 00:08:55,500
signature size and both signing and

217
00:08:55,500 --> 00:08:57,240
verifying time which are linear in the

218
00:08:57,240 --> 00:08:59,100
number of receivers

219
00:08:59,100 --> 00:09:02,399
however we don't have any big ABC scheme

220
00:09:02,399 --> 00:09:04,800
where the ciphertext size encryption

221
00:09:04,800 --> 00:09:07,560
decryption times only grow linearly it's

222
00:09:07,560 --> 00:09:09,300
actually quadratic

223
00:09:09,300 --> 00:09:10,980
so this is the second thing we do in the

224
00:09:10,980 --> 00:09:12,480
piper

225
00:09:12,480 --> 00:09:14,760
and so to summarize we give the first

226
00:09:14,760 --> 00:09:17,640
mdvs scheme with tight reduction system

227
00:09:17,640 --> 00:09:19,080
under assumptions

228
00:09:19,080 --> 00:09:20,640
and our construction is actually

229
00:09:20,640 --> 00:09:22,440
conceptually simple

230
00:09:22,440 --> 00:09:25,320
design the signature size and both

231
00:09:25,320 --> 00:09:27,899
signing and verifying time only grow

232
00:09:27,899 --> 00:09:31,380
linearly with the number of verifiers

233
00:09:31,380 --> 00:09:34,620
we also give the first bkvc scheme

234
00:09:34,620 --> 00:09:37,200
whose ciphertext size encryption

235
00:09:37,200 --> 00:09:39,540
decryption time grow only linearly with

236
00:09:39,540 --> 00:09:42,060
the number of receivers

237
00:09:42,060 --> 00:09:44,760
just a small note that we actually prove

238
00:09:44,760 --> 00:09:46,440
both scheme speed title secure under

239
00:09:46,440 --> 00:09:49,399
adaptive Corruptions

240
00:09:50,160 --> 00:09:53,459
okay so now I'm going to give you like a

241
00:09:53,459 --> 00:09:57,779
brief overview of how to construct a

242
00:09:57,779 --> 00:10:00,360
simplified version of our mdvs so we

243
00:10:00,360 --> 00:10:03,720
only consider single verifier

244
00:10:03,720 --> 00:10:05,279
um and yeah we'll see how to make it

245
00:10:05,279 --> 00:10:07,860
totally secure

246
00:10:07,860 --> 00:10:10,019
Okay so

247
00:10:10,019 --> 00:10:13,019
first let's just have a brief recall of

248
00:10:13,019 --> 00:10:15,360
the idea of the security Notions for DVR

249
00:10:15,360 --> 00:10:16,440
schemes

250
00:10:16,440 --> 00:10:19,680
so for authenticity we want that an

251
00:10:19,680 --> 00:10:22,019
adversary cannot Forge signatures on

252
00:10:22,019 --> 00:10:24,300
messages that were never signed

253
00:10:24,300 --> 00:10:26,459
and here the adversary gets no secret

254
00:10:26,459 --> 00:10:28,560
keys

255
00:10:28,560 --> 00:10:31,080
the second property is off the Record

256
00:10:31,080 --> 00:10:32,700
and there are two cases for this

257
00:10:32,700 --> 00:10:34,500
property so

258
00:10:34,500 --> 00:10:37,019
either the verify is dishonest or the

259
00:10:37,019 --> 00:10:38,519
verifier is honest

260
00:10:38,519 --> 00:10:40,980
when the verifier is dishonest we want

261
00:10:40,980 --> 00:10:42,660
that real signatures are

262
00:10:42,660 --> 00:10:44,519
indistinguishable

263
00:10:44,519 --> 00:10:47,519
from Fortress created by the dishonest

264
00:10:47,519 --> 00:10:50,220
verifier using his own secret key and

265
00:10:50,220 --> 00:10:52,019
here the adversary gets both the

266
00:10:52,019 --> 00:10:54,000
standard secret key and the verifier

267
00:10:54,000 --> 00:10:56,459
secret key

268
00:10:56,459 --> 00:10:59,880
if the verify is honest however

269
00:10:59,880 --> 00:11:02,540
we still wanted real signatures are

270
00:11:02,540 --> 00:11:05,760
indistinguishable from forged signatures

271
00:11:05,760 --> 00:11:08,880
but this time these first signatures

272
00:11:08,880 --> 00:11:11,940
are generated without knowledge of any

273
00:11:11,940 --> 00:11:13,500
secret keys

274
00:11:13,500 --> 00:11:16,079
in this case adversary gets access to

275
00:11:16,079 --> 00:11:19,160
the designer secret key

276
00:11:19,800 --> 00:11:24,540
okay so let's try to construct this

277
00:11:24,540 --> 00:11:26,880
a first construction we will use a Nike

278
00:11:26,880 --> 00:11:30,120
scheme and a public encryption scheme

279
00:11:30,120 --> 00:11:32,399
so the key pair of assigner is just an

280
00:11:32,399 --> 00:11:33,660
ikey keeper

281
00:11:33,660 --> 00:11:36,120
the keeper of a verifier will be the

282
00:11:36,120 --> 00:11:39,959
Nike keeper plus a PK keeper

283
00:11:39,959 --> 00:11:41,760
to sign a message

284
00:11:41,760 --> 00:11:43,980
what designer does is it just computes

285
00:11:43,980 --> 00:11:46,920
the Nike shirt key with the receiver

286
00:11:46,920 --> 00:11:48,600
with the verifier

287
00:11:48,600 --> 00:11:50,519
and then it will encrypt this CRT

288
00:11:50,519 --> 00:11:52,980
concatenated with the message under the

289
00:11:52,980 --> 00:11:55,260
public key of the receiver

290
00:11:55,260 --> 00:11:58,920
the ciphertext is just the

291
00:11:58,920 --> 00:12:00,600
sorry the signature is just the

292
00:12:00,600 --> 00:12:03,000
ciphertext

293
00:12:03,000 --> 00:12:05,640
okay so I'm not going to explain you how

294
00:12:05,640 --> 00:12:08,339
the verification goes but I think it's

295
00:12:08,339 --> 00:12:10,860
clear that this scheme is authentic

296
00:12:10,860 --> 00:12:12,839
because I mean it no one can compute

297
00:12:12,839 --> 00:12:14,100
this shirt here unless they have at

298
00:12:14,100 --> 00:12:15,779
least one of the secret keys

299
00:12:15,779 --> 00:12:18,000
and on the other hand is also satisfies

300
00:12:18,000 --> 00:12:20,279
the software record guarantee even if

301
00:12:20,279 --> 00:12:21,839
designer's secret key leaks to the

302
00:12:21,839 --> 00:12:23,820
adversary because we are using this pke

303
00:12:23,820 --> 00:12:25,800
scheme

304
00:12:25,800 --> 00:12:28,040
there is one problem with this which is

305
00:12:28,040 --> 00:12:31,019
there are no known

306
00:12:31,019 --> 00:12:33,500
Nike schemes which are

307
00:12:33,500 --> 00:12:35,399
tightly secure under standard

308
00:12:35,399 --> 00:12:38,579
assumptions so we now try to fix this

309
00:12:38,579 --> 00:12:41,100
and to fix this we'll actually try to

310
00:12:41,100 --> 00:12:42,779
understand what is the role of the Nike

311
00:12:42,779 --> 00:12:45,300
in this previous Construction

312
00:12:45,300 --> 00:12:46,860
so

313
00:12:46,860 --> 00:12:48,779
we are using the Nike

314
00:12:48,779 --> 00:12:51,720
on one hand to get authenticity because

315
00:12:51,720 --> 00:12:54,360
only the signer and the verifier can

316
00:12:54,360 --> 00:12:56,040
compute the shared key

317
00:12:56,040 --> 00:12:57,959
and on the other hand we are also using

318
00:12:57,959 --> 00:13:00,420
it to get off the Record because the

319
00:13:00,420 --> 00:13:02,579
dishonest verifier can also compute this

320
00:13:02,579 --> 00:13:04,440
Nike share piece so it can also Forge

321
00:13:04,440 --> 00:13:06,120
signatures

322
00:13:06,120 --> 00:13:09,120
so if you think about it this Nike the

323
00:13:09,120 --> 00:13:11,220
role of it is actually to in a wayproof

324
00:13:11,220 --> 00:13:12,540
an R statement

325
00:13:12,540 --> 00:13:15,300
so it's being used to prove that either

326
00:13:15,300 --> 00:13:17,339
designer really signed this message or

327
00:13:17,339 --> 00:13:19,440
the verifier actually forged the

328
00:13:19,440 --> 00:13:22,339
signature on this message

329
00:13:22,920 --> 00:13:24,779
so not taking this into account let's

330
00:13:24,779 --> 00:13:27,180
try to come up with another scheme

331
00:13:27,180 --> 00:13:30,180
and now we will use a nisk a pke scheme

332
00:13:30,180 --> 00:13:31,740
as an under one-way function as building

333
00:13:31,740 --> 00:13:33,240
blocks

334
00:13:33,240 --> 00:13:35,940
and this time we will have public

335
00:13:35,940 --> 00:13:37,680
parameters

336
00:13:37,680 --> 00:13:41,100
so the public parameters are an easy

337
00:13:41,100 --> 00:13:44,220
uh sorry the CRS for an easy and a

338
00:13:44,220 --> 00:13:48,240
public key of this PKA scheme

339
00:13:48,240 --> 00:13:50,339
a sunny keeper is

340
00:13:50,339 --> 00:13:52,440
similar to before except that now it's a

341
00:13:52,440 --> 00:13:54,420
pre-image and the corresponding image of

342
00:13:54,420 --> 00:13:56,220
the one-way function

343
00:13:56,220 --> 00:13:59,660
and the verifier keeper is also a

344
00:13:59,660 --> 00:14:02,220
essentially a one-way function pair so

345
00:14:02,220 --> 00:14:04,560
it's a pretty much on the image of a

346
00:14:04,560 --> 00:14:06,060
one-way function

347
00:14:06,060 --> 00:14:10,860
and now also with the pke keeper

348
00:14:10,860 --> 00:14:13,980
okay so how does the signing work

349
00:14:13,980 --> 00:14:18,000
so to sign what designer does is it

350
00:14:18,000 --> 00:14:20,820
encrypts its own secret key so the free

351
00:14:20,820 --> 00:14:24,120
image of its one-way function

352
00:14:24,120 --> 00:14:26,459
publicly

353
00:14:26,459 --> 00:14:28,800
the message and a bit one that will

354
00:14:28,800 --> 00:14:30,300
ignore

355
00:14:30,300 --> 00:14:34,200
under the public key that is the public

356
00:14:34,200 --> 00:14:37,079
parameters public key

357
00:14:37,079 --> 00:14:39,300
then it will encrypt a bit one use under

358
00:14:39,300 --> 00:14:41,519
the verifiers public key

359
00:14:41,519 --> 00:14:44,279
and it will use the nisk to prove the

360
00:14:44,279 --> 00:14:46,680
following statement it will prove that

361
00:14:46,680 --> 00:14:49,320
if this ciphertext see that the verifier

362
00:14:49,320 --> 00:14:51,180
can decrypt

363
00:14:51,180 --> 00:14:53,459
is encrypting a bit one

364
00:14:53,459 --> 00:14:56,220
then the ciphertext CPP encrypted under

365
00:14:56,220 --> 00:14:58,560
the public parameters public key must

366
00:14:58,560 --> 00:15:01,380
contain a pre-image of either the

367
00:15:01,380 --> 00:15:04,260
signers public key or of the verifiers

368
00:15:04,260 --> 00:15:06,120
public key

369
00:15:06,120 --> 00:15:09,180
and it also encrypts some yeah

370
00:15:09,180 --> 00:15:11,639
so this signature will then be a triple

371
00:15:11,639 --> 00:15:14,040
consisting of the ciphertext in critique

372
00:15:14,040 --> 00:15:16,019
encrypted under the public parameters

373
00:15:16,019 --> 00:15:17,660
public key

374
00:15:17,660 --> 00:15:19,620
deciphertext encrypted under the

375
00:15:19,620 --> 00:15:24,199
receiver's public key and business proof

376
00:15:24,660 --> 00:15:27,600
okay so to verify signatures actually

377
00:15:27,600 --> 00:15:29,040
very simple

378
00:15:29,040 --> 00:15:33,000
we just need to First verify this nisk

379
00:15:33,000 --> 00:15:34,740
proof is valid

380
00:15:34,740 --> 00:15:37,740
and then if it is valid we will decrypt

381
00:15:37,740 --> 00:15:40,380
whatever is encrypted in this Cipher

382
00:15:40,380 --> 00:15:42,560
text

383
00:15:43,260 --> 00:15:45,839
Okay so

384
00:15:45,839 --> 00:15:50,279
now what about forging signatures

385
00:15:50,279 --> 00:15:52,920
so to forge a signature in case it

386
00:15:52,920 --> 00:15:55,740
verifier is dishonest this is really

387
00:15:55,740 --> 00:15:57,660
simple because we just do exactly the

388
00:15:57,660 --> 00:16:00,120
same that we did for

389
00:16:00,120 --> 00:16:01,800
in a normal signature the only

390
00:16:01,800 --> 00:16:03,660
difference now is that instead of

391
00:16:03,660 --> 00:16:05,760
encrypting the standard secret key

392
00:16:05,760 --> 00:16:08,160
we are encrypting the verifiers secret

393
00:16:08,160 --> 00:16:10,260
key

394
00:16:10,260 --> 00:16:13,800
what about public forgeries

395
00:16:13,800 --> 00:16:17,279
well essentially what we do is we

396
00:16:17,279 --> 00:16:20,579
encrypt just zeros because if you

397
00:16:20,579 --> 00:16:22,740
remember the statement from before

398
00:16:22,740 --> 00:16:25,019
we are just the statement was saying

399
00:16:25,019 --> 00:16:27,120
that if C encrypts are one then CPP

400
00:16:27,120 --> 00:16:30,720
encrypts a pre-image of either designers

401
00:16:30,720 --> 00:16:33,600
public key or of the verifiers public

402
00:16:33,600 --> 00:16:35,160
key

403
00:16:35,160 --> 00:16:38,759
however in this case we can just encrypt

404
00:16:38,759 --> 00:16:40,920
under these verifiers

405
00:16:40,920 --> 00:16:43,199
the public is a bit zero because the

406
00:16:43,199 --> 00:16:45,480
security of the verifier will not leak

407
00:16:45,480 --> 00:16:48,540
to in this case the adversary or 2D

408
00:16:48,540 --> 00:16:51,240
so this will be indistinguishable and

409
00:16:51,240 --> 00:16:53,339
because it is encrypting zero then this

410
00:16:53,339 --> 00:16:57,560
CPP does not have to include any secrets

411
00:16:57,839 --> 00:17:00,779
okay so then we can still generate a

412
00:17:00,779 --> 00:17:03,240
valid Niche proof

413
00:17:03,240 --> 00:17:05,699
and yes this is like the main idea of

414
00:17:05,699 --> 00:17:08,819
our construction so yeah I guess I'm

415
00:17:08,819 --> 00:17:10,740
ending a bit uh

416
00:17:10,740 --> 00:17:13,500
early but yeah so this is the the main

417
00:17:13,500 --> 00:17:15,419
idea for the presentation for the

418
00:17:15,419 --> 00:17:18,000
construction of these DVS

419
00:17:18,000 --> 00:17:23,280
um and yes so thank you and and thanks

420
00:17:28,020 --> 00:17:32,000
we have time for a quick question

421
00:17:36,660 --> 00:17:39,840
all right let's stand oh sorry I have a

422
00:17:39,840 --> 00:17:42,120
quick question because you in your

423
00:17:42,120 --> 00:17:44,760
encryption scheme you encrypt the

424
00:17:44,760 --> 00:17:48,960
private key of one of the parties yes uh

425
00:17:48,960 --> 00:17:52,020
regarding the uh interesting public

426
00:17:52,020 --> 00:17:53,480
infrastructure

427
00:17:53,480 --> 00:17:57,960
and intuitively this could cause a

428
00:17:57,960 --> 00:18:01,400
leakage of the uh of the secret key

429
00:18:01,400 --> 00:18:05,820
and why is this intuition wrong or isn't

430
00:18:05,820 --> 00:18:08,280
it so the the thing is that this public

431
00:18:08,280 --> 00:18:10,860
key should be uh we only Crypt Secrets

432
00:18:10,860 --> 00:18:13,440
under public parameters public key and

433
00:18:13,440 --> 00:18:15,960
we just assume that this public is

434
00:18:15,960 --> 00:18:17,820
sampled and no one actually knows the

435
00:18:17,820 --> 00:18:18,960
secret key

436
00:18:18,960 --> 00:18:21,360
yeah

437
00:18:21,360 --> 00:18:23,880
Does this answer your question okay

438
00:18:23,880 --> 00:18:27,780
from thanks for the question

439
00:18:27,780 --> 00:18:29,760
just a question I think it knows answer

440
00:18:29,760 --> 00:18:32,039
but I want to double check um so we had

441
00:18:32,039 --> 00:18:33,900
like an old paper only 15 years ago

442
00:18:33,900 --> 00:18:36,900
about the possibility of uh I guess

443
00:18:36,900 --> 00:18:39,600
deniable authentication I mean just for

444
00:18:39,600 --> 00:18:41,100
two parties again it's adaptive

445
00:18:41,100 --> 00:18:43,020
corruption since this juic framework but

446
00:18:43,020 --> 00:18:44,520
it was like under like online

447
00:18:44,520 --> 00:18:47,460
deniability I'm just curious uh Hey how

448
00:18:47,460 --> 00:18:49,919
do you result uh kind of reconcile with

449
00:18:49,919 --> 00:18:51,000
this and be in light of this

450
00:18:51,000 --> 00:18:52,559
impossibility do you really recommend

451
00:18:52,559 --> 00:18:55,799
using uh your scheme given I don't know

452
00:18:55,799 --> 00:18:57,660
that the most General thing is

453
00:18:57,660 --> 00:19:00,080
impossible

454
00:19:01,080 --> 00:19:03,000
so we have this online deniability again

455
00:19:03,000 --> 00:19:05,280
it's like if you kind of proven the

456
00:19:05,280 --> 00:19:06,780
judge while you know you're sending

457
00:19:06,780 --> 00:19:09,179
messages you're actually trying to you

458
00:19:09,179 --> 00:19:10,500
know prove to the judge that you're

459
00:19:10,500 --> 00:19:12,720
sending the message yes but I don't know

460
00:19:12,720 --> 00:19:14,460
if you're aware of this work if not I I

461
00:19:14,460 --> 00:19:15,960
am aware I don't just don't remember

462
00:19:15,960 --> 00:19:19,200
exactly the setting there I

463
00:19:19,200 --> 00:19:20,940
so the thing is that I also have like

464
00:19:20,940 --> 00:19:22,980
there is another paper studying

465
00:19:22,980 --> 00:19:25,440
composable motions not for MDR SPG but

466
00:19:25,440 --> 00:19:29,220
for uh mdvs and these are like the case

467
00:19:29,220 --> 00:19:31,080
of a single verifier would capture that

468
00:19:31,080 --> 00:19:33,720
and for that it is actually possible to

469
00:19:33,720 --> 00:19:36,720
achieve them so I I do not know exactly

470
00:19:36,720 --> 00:19:38,160
uh

471
00:19:38,160 --> 00:19:40,740
what was proven impossible so it's a bit

472
00:19:40,740 --> 00:19:47,240
hard for me to comments yes yeah okay

473
00:19:47,280 --> 00:19:49,440
no no it's

474
00:19:49,440 --> 00:19:51,299
here again is this adaptive crab I mean

475
00:19:51,299 --> 00:19:52,559
I can see the attacks why it doesn't

476
00:19:52,559 --> 00:19:55,919
satisfy our notion I just uh I'm just

477
00:19:55,919 --> 00:19:57,780
curious if this you know the notion is

478
00:19:57,780 --> 00:19:59,520
right for practice or not but yeah yes

479
00:19:59,520 --> 00:20:02,280
but maybe one thing that I can say is

480
00:20:02,280 --> 00:20:03,900
that

481
00:20:03,900 --> 00:20:05,280
um

482
00:20:05,280 --> 00:20:07,559
this is also captured in a way by the

483
00:20:07,559 --> 00:20:10,020
security Notions because

484
00:20:10,020 --> 00:20:12,360
you if you ask for example if you're

485
00:20:12,360 --> 00:20:14,340
playing the game of can I distinguish

486
00:20:14,340 --> 00:20:16,559
your signature from fraud students and

487
00:20:16,559 --> 00:20:20,460
if you set a party to be like if you ask

488
00:20:20,460 --> 00:20:22,380
you have an oracle right to get either

489
00:20:22,380 --> 00:20:25,020
real signatures or uh forged ones by

490
00:20:25,020 --> 00:20:27,919
some let's say public

491
00:20:27,919 --> 00:20:30,900
ly forged ones for in this case and the

492
00:20:30,900 --> 00:20:32,880
thing is that if you do this that you

493
00:20:32,880 --> 00:20:35,340
cannot later just ask for the secret key

494
00:20:35,340 --> 00:20:37,020
of the verifier because if you would do

495
00:20:37,020 --> 00:20:38,880
that then you would be able to verify it

496
00:20:38,880 --> 00:20:40,679
and this would contradict unfortability

497
00:20:40,679 --> 00:20:43,340
so you need to decide in advance

498
00:20:43,340 --> 00:20:44,900
yes

499
00:20:44,900 --> 00:20:47,400
I don't know if the impossible to result

500
00:20:47,400 --> 00:20:49,620
is related to that or not but if it is

501
00:20:49,620 --> 00:20:52,799
then yes yeah okay thank you thanks for

502
00:20:52,799 --> 00:20:54,600
the great discussion but let's move to

503
00:20:54,600 --> 00:20:56,700
the next talk let's thank the speaker

504
00:20:56,700 --> 00:20:59,059
again

505
00:21:00,990 --> 00:21:05,430
[Applause]

506
00:21:20,820 --> 00:21:23,659
foreign

507
00:21:27,799 --> 00:21:30,179
ideal models modularity and

508
00:21:30,179 --> 00:21:32,880
composibility for attractive compromise

509
00:21:32,880 --> 00:21:36,120
and this is by Joseph and he'll give the

510
00:21:36,120 --> 00:21:37,620
talk

511
00:21:37,620 --> 00:21:40,440
thanks for the introduction

512
00:21:40,440 --> 00:21:42,240
hello world

513
00:21:42,240 --> 00:21:44,640
hello Zoom

514
00:21:44,640 --> 00:21:46,860
so I'm going to talk to you about my

515
00:21:46,860 --> 00:21:49,200
paper who I really am trying to dig into

516
00:21:49,200 --> 00:21:51,720
how should I write these definitions in

517
00:21:51,720 --> 00:21:54,419
the Adaptive compromise setting

518
00:21:54,419 --> 00:21:56,640
first let me give you the quick two

519
00:21:56,640 --> 00:21:58,440
second summary in case that anyone needs

520
00:21:58,440 --> 00:22:00,659
to run to the hallway track

521
00:22:00,659 --> 00:22:03,059
I point at a previous definition of mine

522
00:22:03,059 --> 00:22:06,000
in a paper with Novant Yogi and I show

523
00:22:06,000 --> 00:22:08,460
some ways in which it makes me sad I

524
00:22:08,460 --> 00:22:10,620
can't prove everything I want to

525
00:22:10,620 --> 00:22:13,080
in this book I give a new version of the

526
00:22:13,080 --> 00:22:15,299
definition where I can prove all the old

527
00:22:15,299 --> 00:22:18,299
things and these new things so it makes

528
00:22:18,299 --> 00:22:20,580
me happy

529
00:22:20,580 --> 00:22:22,620
very quickly the changes that were

530
00:22:22,620 --> 00:22:24,360
needed for the definition

531
00:22:24,360 --> 00:22:26,280
firstly we need to force the simulator

532
00:22:26,280 --> 00:22:28,620
to be explicit in how it's going to

533
00:22:28,620 --> 00:22:30,840
program the ideal models

534
00:22:30,840 --> 00:22:33,780
the attacker weirdly enough is also

535
00:22:33,780 --> 00:22:35,340
being allowed to program the ideal

536
00:22:35,340 --> 00:22:38,280
models ideal model think random walk or

537
00:22:38,280 --> 00:22:41,100
model ideal Cipher model stuff like that

538
00:22:41,100 --> 00:22:43,140
and thirdly a point which I won't be

539
00:22:43,140 --> 00:22:45,419
touching much on in this talk is I need

540
00:22:45,419 --> 00:22:47,340
to be careful about how I quantify the

541
00:22:47,340 --> 00:22:49,320
simulator to require simulators that

542
00:22:49,320 --> 00:22:51,960
work for all attackers

543
00:22:51,960 --> 00:22:53,100
okay

544
00:22:53,100 --> 00:22:55,620
let's go for it in a bit more detail now

545
00:22:55,620 --> 00:22:57,360
firstly I'm talking about what I'm

546
00:22:57,360 --> 00:22:59,159
calling the Adaptive compromise setting

547
00:22:59,159 --> 00:23:01,919
you'll find it all across cryptography

548
00:23:01,919 --> 00:23:04,080
with a variety of different terms for

549
00:23:04,080 --> 00:23:06,900
this kind of broad idea

550
00:23:06,900 --> 00:23:08,640
we're thinking about a number of users

551
00:23:08,640 --> 00:23:10,140
that are doing some cryptography

552
00:23:10,140 --> 00:23:12,900
interacting with each other an attacker

553
00:23:12,900 --> 00:23:15,240
views their communication and then based

554
00:23:15,240 --> 00:23:18,000
on that decides to yoink some keys

555
00:23:18,000 --> 00:23:20,760
and see what it can learn

556
00:23:20,760 --> 00:23:22,919
as arises in many settings different

557
00:23:22,919 --> 00:23:24,900
types of Primitives tons of different

558
00:23:24,900 --> 00:23:27,659
definitional Frameworks and like I said

559
00:23:27,659 --> 00:23:29,820
I'll be kind of looking at a setting

560
00:23:29,820 --> 00:23:31,980
from a previous paper of mine

561
00:23:31,980 --> 00:23:34,080
broadly it was working in an online

562
00:23:34,080 --> 00:23:36,299
simulation setting there's a real world

563
00:23:36,299 --> 00:23:38,520
and an Ideal World the attackers trying

564
00:23:38,520 --> 00:23:40,440
to distinguish between them in the real

565
00:23:40,440 --> 00:23:42,120
world it interacts with the actual

566
00:23:42,120 --> 00:23:44,880
algorithms of the scheme in the ideal

567
00:23:44,880 --> 00:23:45,840
world

568
00:23:45,840 --> 00:23:47,520
which is parameterized by a particular

569
00:23:47,520 --> 00:23:49,020
cap leakage function

570
00:23:49,020 --> 00:23:51,059
it interacts with some simulator which

571
00:23:51,059 --> 00:23:53,580
tries to simulate the output of the real

572
00:23:53,580 --> 00:23:55,440
scheme given only leakage about the

573
00:23:55,440 --> 00:23:57,799
queries

574
00:23:58,559 --> 00:24:00,780
be slightly more concrete about this for

575
00:24:00,780 --> 00:24:02,340
the kind of CPA version of the

576
00:24:02,340 --> 00:24:04,740
definition you have two interfaces with

577
00:24:04,740 --> 00:24:06,240
which you can interact with the scheme

578
00:24:06,240 --> 00:24:08,640
first you can ask for encryptions of

579
00:24:08,640 --> 00:24:11,280
messages second you can ask to be given

580
00:24:11,280 --> 00:24:14,520
the secret decryption key

581
00:24:14,520 --> 00:24:16,559
and the ideal world the simulator has to

582
00:24:16,559 --> 00:24:18,299
simulate ciphertext given only the

583
00:24:18,299 --> 00:24:19,919
length of the message

584
00:24:19,919 --> 00:24:21,780
and then later when it's trying to fake

585
00:24:21,780 --> 00:24:24,480
Keys it's given all of the messages that

586
00:24:24,480 --> 00:24:27,500
were previously encrypted

587
00:24:27,900 --> 00:24:29,760
they also give definitions for pseudo

588
00:24:29,760 --> 00:24:31,919
random functions works very similar

589
00:24:31,919 --> 00:24:34,320
replacing encryption with evaluation of

590
00:24:34,320 --> 00:24:38,159
the prf in the ideal world the output in

591
00:24:38,159 --> 00:24:40,380
the evaluation case is forced to be

592
00:24:40,380 --> 00:24:42,659
uniformly random strings not known to

593
00:24:42,659 --> 00:24:44,700
the simulator they're given to the

594
00:24:44,700 --> 00:24:48,059
simulator later during exposures

595
00:24:48,059 --> 00:24:50,640
two things which are not shown so far

596
00:24:50,640 --> 00:24:52,320
which will become important later in the

597
00:24:52,320 --> 00:24:54,360
talk firstly a definition like this

598
00:24:54,360 --> 00:24:56,820
requires ideal models approved by

599
00:24:56,820 --> 00:25:00,000
Nielsen using the same techniques shows

600
00:25:00,000 --> 00:25:02,039
this fact and also the definitions in

601
00:25:02,039 --> 00:25:03,840
the previous paper are all multi-user

602
00:25:03,840 --> 00:25:05,100
definitions which I haven't really

603
00:25:05,100 --> 00:25:07,919
represented here

604
00:25:07,919 --> 00:25:09,240
okay

605
00:25:09,240 --> 00:25:11,460
so first let me just say what were the

606
00:25:11,460 --> 00:25:13,320
nice things about the old definition

607
00:25:13,320 --> 00:25:15,960
it allowed these nice modular proofs of

608
00:25:15,960 --> 00:25:18,240
kind of complicated Primitives which I

609
00:25:18,240 --> 00:25:20,820
break into kind of three levels of proof

610
00:25:20,820 --> 00:25:23,220
the higher level proofs were proving

611
00:25:23,220 --> 00:25:25,799
security of some complicated protocol or

612
00:25:25,799 --> 00:25:29,880
something based on a CMAC notion

613
00:25:29,880 --> 00:25:31,799
intermediate proofs are the ones I think

614
00:25:31,799 --> 00:25:34,559
of well use some simac definition to

615
00:25:34,559 --> 00:25:37,080
prove a different cmic notion for a

616
00:25:37,080 --> 00:25:38,700
related Construction

617
00:25:38,700 --> 00:25:40,559
the previous paper was mainly doing

618
00:25:40,559 --> 00:25:42,120
different kind of encryption schemes

619
00:25:42,120 --> 00:25:44,640
based on prfs

620
00:25:44,640 --> 00:25:47,039
and finally the kind of lowest level is

621
00:25:47,039 --> 00:25:49,320
where we do the actual analysis where we

622
00:25:49,320 --> 00:25:51,559
dig into ideal models and do these

623
00:25:51,559 --> 00:25:53,940
reprogramming proofs about random

624
00:25:53,940 --> 00:25:56,340
oracles being good prf's ideal ciphers

625
00:25:56,340 --> 00:25:58,980
being could PRS

626
00:25:58,980 --> 00:26:01,740
in my current book I show some kind of

627
00:26:01,740 --> 00:26:03,600
shortcomings with high level and

628
00:26:03,600 --> 00:26:05,460
intermediate level proofs where there

629
00:26:05,460 --> 00:26:06,900
are some examples here where I can't

630
00:26:06,900 --> 00:26:08,580
prove the thing which I really feel like

631
00:26:08,580 --> 00:26:11,539
I should be able to

632
00:26:11,820 --> 00:26:13,679
okay now that I've set that up I'll

633
00:26:13,679 --> 00:26:15,480
broadly give you an outline of both the

634
00:26:15,480 --> 00:26:17,400
rest of the talk and the contributions

635
00:26:17,400 --> 00:26:18,600
in my paper

636
00:26:18,600 --> 00:26:20,580
first of all dig into what the

637
00:26:20,580 --> 00:26:23,640
shortcomings of simac are like will show

638
00:26:23,640 --> 00:26:26,279
my new sim star AC definition which

639
00:26:26,279 --> 00:26:28,020
fixes these shortcomings

640
00:26:28,020 --> 00:26:29,640
and these are related to different

641
00:26:29,640 --> 00:26:31,799
settings where the same ideal primitive

642
00:26:31,799 --> 00:26:35,840
is getting used multiple times

643
00:26:37,740 --> 00:26:39,360
I don't want to have to restart from

644
00:26:39,360 --> 00:26:41,400
scratch luckily I can kind of show that

645
00:26:41,400 --> 00:26:43,559
all of the old results shown in the

646
00:26:43,559 --> 00:26:45,240
previous paper left over to this new

647
00:26:45,240 --> 00:26:47,220
paper

648
00:26:47,220 --> 00:26:49,980
and finally to kind of Link into the

649
00:26:49,980 --> 00:26:52,380
existing literature on adaptive

650
00:26:52,380 --> 00:26:54,779
compromise which has a lot of work has

651
00:26:54,779 --> 00:26:56,700
been done on public key encryption I

652
00:26:56,700 --> 00:26:58,580
give public key encryption definitions

653
00:26:58,580 --> 00:27:00,960
compared to previous definitions and

654
00:27:00,960 --> 00:27:03,240
show some nice results that

655
00:27:03,240 --> 00:27:06,120
natural Construction

656
00:27:06,120 --> 00:27:08,580
okay so let's start by talking about the

657
00:27:08,580 --> 00:27:09,720
shortcomings

658
00:27:09,720 --> 00:27:11,520
and to dig into this I'm going to start

659
00:27:11,520 --> 00:27:13,740
by kind of extending my definition to

660
00:27:13,740 --> 00:27:15,600
include those things I've omitted before

661
00:27:15,600 --> 00:27:18,240
first let's be explicit about how the

662
00:27:18,240 --> 00:27:20,760
ideal model is captured

663
00:27:20,760 --> 00:27:22,860
in the real world you just actually

664
00:27:22,860 --> 00:27:24,720
access this ideal model which is being

665
00:27:24,720 --> 00:27:26,820
used by the construction

666
00:27:26,820 --> 00:27:28,980
in the ideal world the simulator has

667
00:27:28,980 --> 00:27:32,220
complete control over the ideal model

668
00:27:32,220 --> 00:27:34,200
to make it multi-user and you just have

669
00:27:34,200 --> 00:27:36,480
multiple instances of the protocol in

670
00:27:36,480 --> 00:27:38,580
the real world and in the ideal World

671
00:27:38,580 --> 00:27:41,940
these are all emulated by the simulator

672
00:27:41,940 --> 00:27:44,480
here I'm showing it within

673
00:27:44,480 --> 00:27:47,279
acprf but kind of everything I say for

674
00:27:47,279 --> 00:27:49,140
the next couple of minutes holds with

675
00:27:49,140 --> 00:27:52,320
respect to any of the semic definitions

676
00:27:52,320 --> 00:27:55,140
except one but that's a weird Corner

677
00:27:55,140 --> 00:27:57,179
case

678
00:27:57,179 --> 00:27:58,080
so

679
00:27:58,080 --> 00:27:59,940
let's ask ourselves a natural question

680
00:27:59,940 --> 00:28:02,820
does single user security imply

681
00:28:02,820 --> 00:28:04,380
multi-user security with these

682
00:28:04,380 --> 00:28:06,539
definitions and to kind of help us

683
00:28:06,539 --> 00:28:08,820
remind what's happening I gave us the

684
00:28:08,820 --> 00:28:10,620
single user security definition in the

685
00:28:10,620 --> 00:28:12,779
upper right hand corner

686
00:28:12,779 --> 00:28:14,940
so we want to distinguish between a real

687
00:28:14,940 --> 00:28:16,500
world whether two instances of the

688
00:28:16,500 --> 00:28:18,779
protocol and the ideal world where we

689
00:28:18,779 --> 00:28:21,299
get to try to simulate this

690
00:28:21,299 --> 00:28:23,340
the natural way to simulate it is to

691
00:28:23,340 --> 00:28:25,080
just have two different copies of your

692
00:28:25,080 --> 00:28:29,580
single user simulator one for each user

693
00:28:29,580 --> 00:28:31,860
how do we want to put this a nice hybrid

694
00:28:31,860 --> 00:28:33,720
game hopping proof

695
00:28:33,720 --> 00:28:35,940
first we switch to a hybrid world where

696
00:28:35,940 --> 00:28:38,279
there's a single simulator

697
00:28:38,279 --> 00:28:40,020
if you have draw a box around the

698
00:28:40,020 --> 00:28:41,400
different you can say ah the difference

699
00:28:41,400 --> 00:28:43,919
here looks exactly what the single

700
00:28:43,919 --> 00:28:46,860
security was giving us

701
00:28:46,860 --> 00:28:48,600
then you can hop from the hybrid world

702
00:28:48,600 --> 00:28:51,179
to the ideal world again drawing a box

703
00:28:51,179 --> 00:28:52,620
around the difference you go ah yes

704
00:28:52,620 --> 00:28:54,720
that's exactly what single user security

705
00:28:54,720 --> 00:28:57,000
was given us

706
00:28:57,000 --> 00:28:58,860
but so far I've lied to you because

707
00:28:58,860 --> 00:29:01,980
that's not the single user security was

708
00:29:01,980 --> 00:29:04,140
this is what single user security was

709
00:29:04,140 --> 00:29:05,820
there's this ideal primitive floating

710
00:29:05,820 --> 00:29:07,679
round which gets completely replaced by

711
00:29:07,679 --> 00:29:09,600
the simulator

712
00:29:09,600 --> 00:29:11,760
so if we start trying to plug that into

713
00:29:11,760 --> 00:29:13,620
our pictorial proof here

714
00:29:13,620 --> 00:29:15,720
in our first hybrid step when we do our

715
00:29:15,720 --> 00:29:17,880
reduction the ideal primitive will be

716
00:29:17,880 --> 00:29:20,940
replaced by the first simulator

717
00:29:20,940 --> 00:29:23,399
now the second construction isn't

718
00:29:23,399 --> 00:29:24,720
querying the ideal primitive anymore

719
00:29:24,720 --> 00:29:26,880
it's querying this random simulator that

720
00:29:26,880 --> 00:29:29,340
we don't really know anything about

721
00:29:29,340 --> 00:29:31,020
but if there's no ideal primitive

722
00:29:31,020 --> 00:29:33,480
anymore I can't do the second step of

723
00:29:33,480 --> 00:29:35,340
the proof because my single user

724
00:29:35,340 --> 00:29:37,140
security definition required that to be

725
00:29:37,140 --> 00:29:39,419
this ideal primitive

726
00:29:39,419 --> 00:29:41,039
we could have also kind of noticed the

727
00:29:41,039 --> 00:29:42,480
issue if we tried to start from the

728
00:29:42,480 --> 00:29:44,460
other direction of when we're defining

729
00:29:44,460 --> 00:29:46,440
our simulator how is it going to respond

730
00:29:46,440 --> 00:29:49,080
to Ideal primitive queries and it's just

731
00:29:49,080 --> 00:29:50,460
completely unclear because we have these

732
00:29:50,460 --> 00:29:52,100
two different simulators Each of which

733
00:29:52,100 --> 00:29:54,659
expects complete control over the ideal

734
00:29:54,659 --> 00:29:57,080
simulator

735
00:29:57,360 --> 00:30:00,539
so kind of stepping back not just the

736
00:30:00,539 --> 00:30:02,700
multi-user it's a single user setting

737
00:30:02,700 --> 00:30:04,679
the issue here is that the simulator

738
00:30:04,679 --> 00:30:07,740
completely replaces the Primitive p

739
00:30:07,740 --> 00:30:09,720
and that prevents any sort of proof

740
00:30:09,720 --> 00:30:11,880
where we want to multiple times use

741
00:30:11,880 --> 00:30:14,279
security that's based on this primitive

742
00:30:14,279 --> 00:30:16,380
here's a variety of different examples

743
00:30:16,380 --> 00:30:18,720
where I identified this the ones with

744
00:30:18,720 --> 00:30:20,760
asterisks are kind of from the previous

745
00:30:20,760 --> 00:30:22,799
paper where the previous paper gave

746
00:30:22,799 --> 00:30:25,140
positive results just by assuming that

747
00:30:25,140 --> 00:30:26,700
different ideal Primitives were used in

748
00:30:26,700 --> 00:30:28,440
different places the ones without

749
00:30:28,440 --> 00:30:30,539
asterisk so new examples that I point

750
00:30:30,539 --> 00:30:32,840
out here

751
00:30:34,799 --> 00:30:36,480
position you might try

752
00:30:36,480 --> 00:30:39,539
is to just not use them not reuse the

753
00:30:39,539 --> 00:30:40,919
ideal primitive this is what the

754
00:30:40,919 --> 00:30:43,320
previous paper was assuming this is

755
00:30:43,320 --> 00:30:44,940
somewhat nice to do if you have random

756
00:30:44,940 --> 00:30:46,679
oracles we have this idea of domain

757
00:30:46,679 --> 00:30:49,559
separation polari Davis and Gunther gave

758
00:30:49,559 --> 00:30:51,360
a nice formalization of that and yeah

759
00:30:51,360 --> 00:30:54,360
it's fairly efficient you can do that

760
00:30:54,360 --> 00:30:56,220
and I have to have two issues one

761
00:30:56,220 --> 00:30:58,740
sometimes I'm using an ideal Cipher much

762
00:30:58,740 --> 00:31:01,200
less clear how to do it uh how do they

763
00:31:01,200 --> 00:31:03,840
do efficient domain separation two are

764
00:31:03,840 --> 00:31:06,000
just a kind of aesthetic theoretical

765
00:31:06,000 --> 00:31:07,620
level I find it very unsatisfying

766
00:31:07,620 --> 00:31:09,000
because these definitions really

767
00:31:09,000 --> 00:31:12,120
shouldn't require domain separation so I

768
00:31:12,120 --> 00:31:13,980
would like my proof and my definitions

769
00:31:13,980 --> 00:31:17,419
to somehow capture this fact

770
00:31:17,940 --> 00:31:19,860
so how are we going to resolve this

771
00:31:19,860 --> 00:31:21,299
tension what are the two different

772
00:31:21,299 --> 00:31:24,120
simulators want to both control the

773
00:31:24,120 --> 00:31:25,860
ideal primitive

774
00:31:25,860 --> 00:31:27,360
the idea is we're going to kind of

775
00:31:27,360 --> 00:31:28,740
slightly tweak how we're thinking about

776
00:31:28,740 --> 00:31:31,020
the ideal primitive we're always now

777
00:31:31,020 --> 00:31:32,700
going to think about it as being lazily

778
00:31:32,700 --> 00:31:35,279
sampled you only Define its output on

779
00:31:35,279 --> 00:31:37,020
input X when you actually need that

780
00:31:37,020 --> 00:31:39,059
output

781
00:31:39,059 --> 00:31:40,980
and secondly we're going to add this

782
00:31:40,980 --> 00:31:42,960
kind of backdoor interface into the

783
00:31:42,960 --> 00:31:45,120
ideal primitive where we let someone

784
00:31:45,120 --> 00:31:48,600
give it an X and Y and say please make p

785
00:31:48,600 --> 00:31:51,439
of x equal y

786
00:31:51,840 --> 00:31:54,299
so let's change our simac definitions to

787
00:31:54,299 --> 00:31:56,159
get SIM star AC

788
00:31:56,159 --> 00:31:59,360
where now both worlds use this

789
00:31:59,360 --> 00:32:02,880
modified ideal primitive and importantly

790
00:32:02,880 --> 00:32:06,179
in the ideal world the simulator is

791
00:32:06,179 --> 00:32:08,279
given access to this kind of backdoor

792
00:32:08,279 --> 00:32:09,899
interface

793
00:32:09,899 --> 00:32:12,840
now it's clear how our multi-user proves

794
00:32:12,840 --> 00:32:15,120
ideal watch we just still have the ideal

795
00:32:15,120 --> 00:32:16,980
primitive with both simulators accessing

796
00:32:16,980 --> 00:32:18,179
it

797
00:32:18,179 --> 00:32:20,039
let's try to kind of fill in the rest of

798
00:32:20,039 --> 00:32:21,960
the proof again

799
00:32:21,960 --> 00:32:23,580
I can draw my box

800
00:32:23,580 --> 00:32:26,159
things match again

801
00:32:26,159 --> 00:32:29,039
I can draw my second box

802
00:32:29,039 --> 00:32:31,559
the inside of the Box matches my single

803
00:32:31,559 --> 00:32:32,940
user definition

804
00:32:32,940 --> 00:32:35,159
so it feels like we should be happy

805
00:32:35,159 --> 00:32:37,200
but still we're not quite happy

806
00:32:37,200 --> 00:32:39,120
the issue here is that

807
00:32:39,120 --> 00:32:42,059
in this kind of pictorial proof

808
00:32:42,059 --> 00:32:44,520
the reduction is using its own oracles

809
00:32:44,520 --> 00:32:46,440
to simulate the things inside the Box

810
00:32:46,440 --> 00:32:48,419
and it's supposed to locally simulate

811
00:32:48,419 --> 00:32:50,340
the things outside the box

812
00:32:50,340 --> 00:32:52,740
however the thing outside the box is the

813
00:32:52,740 --> 00:32:54,899
first simulator who expects to be able

814
00:32:54,899 --> 00:32:58,879
to program the ideal model

815
00:32:59,220 --> 00:33:01,620
so I changed my definition slightly and

816
00:33:01,620 --> 00:33:03,899
in the real world I let the attacker do

817
00:33:03,899 --> 00:33:05,399
this really weird thing

818
00:33:05,399 --> 00:33:07,620
where I can just program it

819
00:33:07,620 --> 00:33:10,679
this doesn't really seem to correspond

820
00:33:10,679 --> 00:33:12,539
to anything that means anything in

821
00:33:12,539 --> 00:33:14,640
practice but makes all the proofs go

822
00:33:14,640 --> 00:33:16,440
together and gives us these nice kind of

823
00:33:16,440 --> 00:33:19,019
compositions

824
00:33:19,019 --> 00:33:21,419
this was actually proposed also in a

825
00:33:21,419 --> 00:33:23,220
kind of different UC setting to show

826
00:33:23,220 --> 00:33:25,860
that nice composition results hold

827
00:33:25,860 --> 00:33:27,840
and when you kind of really dig into the

828
00:33:27,840 --> 00:33:29,640
guts of what's happening the reasons why

829
00:33:29,640 --> 00:33:33,000
this works nicely first Mac and why it

830
00:33:33,000 --> 00:33:36,419
worked nicely for UC is the same kind of

831
00:33:36,419 --> 00:33:39,440
underlying ideas

832
00:33:39,480 --> 00:33:42,480
very briefly multi-user security Cascade

833
00:33:42,480 --> 00:33:45,480
prf I can write proofs for them now if

834
00:33:45,480 --> 00:33:47,700
we start with Sim star AC

835
00:33:47,700 --> 00:33:49,679
there's this other technical detail

836
00:33:49,679 --> 00:33:52,019
about the simulation needs to be a

837
00:33:52,019 --> 00:33:53,640
universal simulator if you want more

838
00:33:53,640 --> 00:33:55,799
than a constant number of rounds for

839
00:33:55,799 --> 00:33:57,779
example

840
00:33:57,779 --> 00:33:59,700
we also want the old result from the

841
00:33:59,700 --> 00:34:01,440
previous definition to hold

842
00:34:01,440 --> 00:34:03,539
and indeed they do the high level result

843
00:34:03,539 --> 00:34:05,399
are just kind of free because my new

844
00:34:05,399 --> 00:34:08,280
definition is stronger than the old one

845
00:34:08,280 --> 00:34:10,918
the intermediate results aren't quite as

846
00:34:10,918 --> 00:34:12,599
free but they're basically free because

847
00:34:12,599 --> 00:34:14,460
all of the proofs in the previous paper

848
00:34:14,460 --> 00:34:16,980
were sufficiently black box that we can

849
00:34:16,980 --> 00:34:18,179
kind of shove in the new definition

850
00:34:18,179 --> 00:34:21,119
without having to do anything fancy

851
00:34:21,119 --> 00:34:23,040
the low level proofs technically have to

852
00:34:23,040 --> 00:34:25,739
be Rewritten the main ideas are the same

853
00:34:25,739 --> 00:34:27,359
and you get essentially the same bound

854
00:34:27,359 --> 00:34:29,339
where we think of any programming

855
00:34:29,339 --> 00:34:30,839
queries as being

856
00:34:30,839 --> 00:34:34,020
I do a lot of queries

857
00:34:34,020 --> 00:34:37,379
I also gave definitions for Sim star AC

858
00:34:37,379 --> 00:34:40,199
with asymmetric encryption

859
00:34:40,199 --> 00:34:42,300
the definitions work very similar to

860
00:34:42,300 --> 00:34:43,739
symmetric encryption but now we're

861
00:34:43,739 --> 00:34:45,300
having the two different types of

862
00:34:45,300 --> 00:34:47,040
compromise that make sense

863
00:34:47,040 --> 00:34:49,800
with public key encryption which is

864
00:34:49,800 --> 00:34:51,839
sender exposure where you're given just

865
00:34:51,839 --> 00:34:53,639
the randomness that was used to encrypt

866
00:34:53,639 --> 00:34:54,780
some message

867
00:34:54,780 --> 00:34:57,000
and receiver exposure when you're given

868
00:34:57,000 --> 00:34:59,940
the actual decryption key

869
00:34:59,940 --> 00:35:02,400
in terms of simulation the encryption

870
00:35:02,400 --> 00:35:04,140
simulation and decryption simulation

871
00:35:04,140 --> 00:35:06,440
were kind of the same

872
00:35:06,440 --> 00:35:08,700
backwards on the bottom by the way but

873
00:35:08,700 --> 00:35:11,700
sender exposures you're given just the

874
00:35:11,700 --> 00:35:13,520
message to the simulator for that one

875
00:35:13,520 --> 00:35:16,500
encryption that's being compromised or

876
00:35:16,500 --> 00:35:18,660
receiver exposures is when we give this

877
00:35:18,660 --> 00:35:22,339
emulator all of the previous messages

878
00:35:24,660 --> 00:35:26,339
I also give definitions for key

879
00:35:26,339 --> 00:35:28,500
encapsulation mechanisms it's basically

880
00:35:28,500 --> 00:35:29,760
the same thing you just switch

881
00:35:29,760 --> 00:35:31,460
encryption and decryption with

882
00:35:31,460 --> 00:35:34,500
encapsulation and decapsulation and in

883
00:35:34,500 --> 00:35:37,079
the ideal world the response to

884
00:35:37,079 --> 00:35:39,180
encapsulation the key is chosen

885
00:35:39,180 --> 00:35:41,220
uniformly at random not known to the

886
00:35:41,220 --> 00:35:43,320
simulator it's given later to the

887
00:35:43,320 --> 00:35:46,460
simulator on exposures

888
00:35:47,339 --> 00:35:48,839
what are we able to prove this

889
00:35:48,839 --> 00:35:50,760
definition not the things that I think

890
00:35:50,760 --> 00:35:53,400
are nice chem Dam hybrid encryption just

891
00:35:53,400 --> 00:35:55,740
works the way you would want if the cam

892
00:35:55,740 --> 00:35:58,980
and Dem or a CPA or CCA secure then the

893
00:35:58,980 --> 00:36:03,359
hybrid PKA scheme is CCA or CPA secure

894
00:36:03,359 --> 00:36:05,579
and because of these nice composition

895
00:36:05,579 --> 00:36:07,140
properties

896
00:36:07,140 --> 00:36:09,300
the camera demo are able to use the same

897
00:36:09,300 --> 00:36:11,099
ideal Primitives if needed which would

898
00:36:11,099 --> 00:36:12,359
not have been the case with the old

899
00:36:12,359 --> 00:36:13,260
definition

900
00:36:13,260 --> 00:36:14,700
Style

901
00:36:14,700 --> 00:36:16,920
we can relate this to a result by horror

902
00:36:16,920 --> 00:36:19,380
and portering who also had looked at a

903
00:36:19,380 --> 00:36:22,440
kind of chem Dem in these

904
00:36:22,440 --> 00:36:24,540
selective opening settings

905
00:36:24,540 --> 00:36:26,820
they used slightly weaker assumptions

906
00:36:26,820 --> 00:36:29,220
for some piece of it slightly stronger

907
00:36:29,220 --> 00:36:31,140
assumptions for another piece and they

908
00:36:31,140 --> 00:36:33,540
proved a weaker selective opening CCA

909
00:36:33,540 --> 00:36:35,900
definition

910
00:36:37,680 --> 00:36:39,720
I also looked at different variants of

911
00:36:39,720 --> 00:36:41,880
what I'll call kind of hashed chem which

912
00:36:41,880 --> 00:36:43,200
is different things where you take some

913
00:36:43,200 --> 00:36:45,180
weaker chems achieving some sort of

914
00:36:45,180 --> 00:36:48,060
one-wayness notion you hash the output

915
00:36:48,060 --> 00:36:49,680
with the random Oracle and you hope that

916
00:36:49,680 --> 00:36:52,079
that gives you either CPA security or

917
00:36:52,079 --> 00:36:54,540
CCA security

918
00:36:54,540 --> 00:36:57,240
examples here include kinds of hashed

919
00:36:57,240 --> 00:36:59,700
out Gamal schemes as well as some

920
00:36:59,700 --> 00:37:02,520
variants of fujistaki yokomoto and

921
00:37:02,520 --> 00:37:03,480
basically

922
00:37:03,480 --> 00:37:05,280
I'm able to prove them secure with my

923
00:37:05,280 --> 00:37:08,220
definitions I generally expect that any

924
00:37:08,220 --> 00:37:10,140
kind of natural public encryption

925
00:37:10,140 --> 00:37:13,859
schemes based on random oracles will

926
00:37:13,859 --> 00:37:16,020
work with these new definitions I just

927
00:37:16,020 --> 00:37:19,940
selected some nice ones for my proofs

928
00:37:20,040 --> 00:37:21,420
funny

929
00:37:21,420 --> 00:37:24,119
I want to kind of understand how these

930
00:37:24,119 --> 00:37:26,339
simac definitions fit in with the

931
00:37:26,339 --> 00:37:28,380
framework of existing definitions

932
00:37:28,380 --> 00:37:29,700
first

933
00:37:29,700 --> 00:37:31,800
the Sim story definition you know you

934
00:37:31,800 --> 00:37:34,140
can write down a corresponding non-start

935
00:37:34,140 --> 00:37:36,660
version as you would expect the star one

936
00:37:36,660 --> 00:37:39,180
applies the non-start one

937
00:37:39,180 --> 00:37:42,119
the non-stud one is kind of morally very

938
00:37:42,119 --> 00:37:44,760
similar to this notion of four Sim that

939
00:37:44,760 --> 00:37:47,780
was introduced previously

940
00:37:47,820 --> 00:37:50,940
the small differences between them for

941
00:37:50,940 --> 00:37:53,160
Sim only considered random oracles and

942
00:37:53,160 --> 00:37:55,800
only considered single user security it

943
00:37:55,800 --> 00:37:57,660
will run into those same issues that you

944
00:37:57,660 --> 00:37:59,579
can't really prove multi-user security

945
00:37:59,579 --> 00:38:02,220
with it and they included labels in

946
00:38:02,220 --> 00:38:03,420
their public key encryption definition

947
00:38:03,420 --> 00:38:06,359
which I didn't choose two of those not

948
00:38:06,359 --> 00:38:09,720
essential to the definition either way

949
00:38:09,720 --> 00:38:12,540
as you would hope the simac definitions

950
00:38:12,540 --> 00:38:16,260
imply normal in CCA

951
00:38:16,260 --> 00:38:18,839
and the same AC definitions were really

952
00:38:18,839 --> 00:38:21,119
written intentionally to be super strong

953
00:38:21,119 --> 00:38:23,339
in some senses too strong

954
00:38:23,339 --> 00:38:25,020
and because of that basically any

955
00:38:25,020 --> 00:38:27,180
selective opening definition that I can

956
00:38:27,180 --> 00:38:29,579
find in the literature is indeed implied

957
00:38:29,579 --> 00:38:32,839
by simac

958
00:38:33,720 --> 00:38:35,400
so I've reached the end of my talk

959
00:38:35,400 --> 00:38:37,920
here's the summary of my contributions

960
00:38:37,920 --> 00:38:41,839
again happy to take any questions

961
00:38:48,300 --> 00:38:52,220
we have time for a quick question

962
00:38:53,760 --> 00:38:55,740
I was wondering in your picture with the

963
00:38:55,740 --> 00:38:58,260
boxes and when you had two simulators

964
00:38:58,260 --> 00:39:00,300
they're both allowed to program the say

965
00:39:00,300 --> 00:39:02,280
random Oracle for instance what happens

966
00:39:02,280 --> 00:39:04,380
if if they both want to define the

967
00:39:04,380 --> 00:39:06,000
output and the same input and they don't

968
00:39:06,000 --> 00:39:07,440
agree on what the output should be okay

969
00:39:07,440 --> 00:39:08,760
sure

970
00:39:08,760 --> 00:39:11,160
so the there's kind of two different

971
00:39:11,160 --> 00:39:14,280
ways you could consider defining it one

972
00:39:14,280 --> 00:39:16,020
would be that kind of the second person

973
00:39:16,020 --> 00:39:17,820
to try to do this programming their

974
00:39:17,820 --> 00:39:20,220
programming fails the other version

975
00:39:20,220 --> 00:39:21,599
would be

976
00:39:21,599 --> 00:39:22,140
um

977
00:39:22,140 --> 00:39:24,240
it succeeds and it just overwrites what

978
00:39:24,240 --> 00:39:26,820
was previously in the random Oracle

979
00:39:26,820 --> 00:39:28,859
I went with the weather version where if

980
00:39:28,859 --> 00:39:30,000
you try to program something that's

981
00:39:30,000 --> 00:39:32,839
already defined the programming fails

982
00:39:32,839 --> 00:39:35,880
my impression is that the same sort of

983
00:39:35,880 --> 00:39:37,500
results would imply with either version

984
00:39:37,500 --> 00:39:39,720
of the definition but when I was kind of

985
00:39:39,720 --> 00:39:41,220
playing around with it I think the

986
00:39:41,220 --> 00:39:43,440
version I used is easier to write proofs

987
00:39:43,440 --> 00:39:45,839
with though it also comes with these

988
00:39:45,839 --> 00:39:48,359
kind of annoying subtleties in some

989
00:39:48,359 --> 00:39:52,040
cases that one has to be careful about

990
00:39:52,740 --> 00:39:56,720
all right let's thank the speaker again

991
00:39:57,660 --> 00:40:00,200
thank you

992
00:40:13,260 --> 00:40:16,619
our next talk is almost tight multi-user

993
00:40:16,619 --> 00:40:19,260
security under adaptive Corruptions and

994
00:40:19,260 --> 00:40:21,780
leakages in the standard model this is

995
00:40:21,780 --> 00:40:26,460
by schwei Han shengli Liu and davugu and

996
00:40:26,460 --> 00:40:28,980
schwei will give the talk

997
00:40:28,980 --> 00:40:30,780
on thanks for the introduction good

998
00:40:30,780 --> 00:40:32,880
morning I'm shahan I'm going to talk

999
00:40:32,880 --> 00:40:34,920
about almost tights much user security

1000
00:40:34,920 --> 00:40:37,380
under adaptive Corruptions and leakages

1001
00:40:37,380 --> 00:40:39,720
in the standard model this is John's

1002
00:40:39,720 --> 00:40:42,119
work with shungivo and dawugu we are

1003
00:40:42,119 --> 00:40:45,000
from Shanghai University

1004
00:40:45,000 --> 00:40:47,460
in modern cryptography to prove the

1005
00:40:47,460 --> 00:40:50,099
security of a scheme a common way is to

1006
00:40:50,099 --> 00:40:52,380
base the scheme's security on a

1007
00:40:52,380 --> 00:40:54,960
well-studied problem through a security

1008
00:40:54,960 --> 00:40:56,700
reduction

1009
00:40:56,700 --> 00:40:59,280
and a security reduction turns any

1010
00:40:59,280 --> 00:41:02,520
adversary attacking the scheme in time

1011
00:41:02,520 --> 00:41:05,640
ta with Advantage Epsilon a into an

1012
00:41:05,640 --> 00:41:08,460
algorithm b solving the problem in time

1013
00:41:08,460 --> 00:41:12,060
TB with an advantage Epsilon B and it

1014
00:41:12,060 --> 00:41:14,820
establishes an inequality between TB

1015
00:41:14,820 --> 00:41:17,520
over Epsilon B and ta over Epsilon a

1016
00:41:17,520 --> 00:41:20,820
with a factor l

1017
00:41:20,820 --> 00:41:24,839
if the loss Factor L is a constant or at

1018
00:41:24,839 --> 00:41:26,520
most linear in the security parameter

1019
00:41:26,520 --> 00:41:29,700
Lambda then we call it tight security or

1020
00:41:29,700 --> 00:41:33,618
almost tight security respectively

1021
00:41:34,579 --> 00:41:37,740
in this work we consider the security of

1022
00:41:37,740 --> 00:41:39,960
cryptographic schemes in math user

1023
00:41:39,960 --> 00:41:41,940
settings under adaptive Corruptions

1024
00:41:41,940 --> 00:41:44,700
where the adversary can adaptively craft

1025
00:41:44,700 --> 00:41:47,760
some users and obtain their secret keys

1026
00:41:47,760 --> 00:41:50,400
this happens since some adversary May

1027
00:41:50,400 --> 00:41:53,280
snatch secrets from the users by System

1028
00:41:53,280 --> 00:41:56,400
hiking or from Key exposure due to the

1029
00:41:56,400 --> 00:41:58,740
user's band Key Management

1030
00:41:58,740 --> 00:42:00,960
and the way it denotes this as the muc

1031
00:42:00,960 --> 00:42:03,660
security which protects the security of

1032
00:42:03,660 --> 00:42:07,040
uncrafted users

1033
00:42:09,180 --> 00:42:12,379
yes I want to switch

1034
00:42:13,560 --> 00:42:16,560
this one

1035
00:42:17,339 --> 00:42:21,779
yeah this one goes okay

1036
00:42:22,200 --> 00:42:25,040
let's continue

1037
00:42:25,760 --> 00:42:29,220
it is desirable to achieve tight muc

1038
00:42:29,220 --> 00:42:30,859
security

1039
00:42:30,859 --> 00:42:34,800
however in standard in traditional

1040
00:42:34,800 --> 00:42:37,160
security models were usually considers

1041
00:42:37,160 --> 00:42:41,579
only a single user for example the for

1042
00:42:41,579 --> 00:42:44,400
public encryption schemes we consider

1043
00:42:44,400 --> 00:42:48,180
rndcp and CC security and for Signature

1044
00:42:48,180 --> 00:42:51,119
scheme we consider the strong euf SEMA

1045
00:42:51,119 --> 00:42:53,480
security

1046
00:42:54,020 --> 00:42:57,000
security counterparts considers much

1047
00:42:57,000 --> 00:42:59,819
multiple users multiple change server

1048
00:42:59,819 --> 00:43:02,339
tests and multiple signatures and are

1049
00:43:02,339 --> 00:43:06,420
denoted by the mumcc CPA and CC security

1050
00:43:06,420 --> 00:43:10,140
for pke and strong muccma security for

1051
00:43:10,140 --> 00:43:13,400
Signature schemes

1052
00:43:13,619 --> 00:43:16,920
single user security generally implies

1053
00:43:16,920 --> 00:43:20,220
or implies implies or muc security by

1054
00:43:20,220 --> 00:43:23,700
hybrid by hybrid arguments however the

1055
00:43:23,700 --> 00:43:26,700
hybrid arguments reduction incurs a very

1056
00:43:26,700 --> 00:43:30,060
large growth factor which is uh

1057
00:43:30,060 --> 00:43:32,760
at this linear in the number of users

1058
00:43:32,760 --> 00:43:34,680
the number of central tests or the

1059
00:43:34,680 --> 00:43:37,759
number of signatures

1060
00:43:39,000 --> 00:43:43,020
indeed a memory existing Works shows

1061
00:43:43,020 --> 00:43:45,839
impossibility results on achieving tax

1062
00:43:45,839 --> 00:43:49,380
muc security for pke budget and all

1063
00:43:49,380 --> 00:43:51,480
shows that it is impossible to achieve

1064
00:43:51,480 --> 00:43:53,819
tight muc security if the relation

1065
00:43:53,819 --> 00:43:56,339
between public and security is unique or

1066
00:43:56,339 --> 00:43:57,900
randomizable

1067
00:43:57,900 --> 00:44:00,359
for Signature scheme but error should

1068
00:44:00,359 --> 00:44:03,560
seem similar impossibility results

1069
00:44:03,560 --> 00:44:06,480
besides Morgan at all shows that it is

1070
00:44:06,480 --> 00:44:09,119
impossible to achieve tight material muc

1071
00:44:09,119 --> 00:44:10,980
security if the signing algorithm of

1072
00:44:10,980 --> 00:44:13,980
signature is deterministic

1073
00:44:13,980 --> 00:44:17,060
indeed there are very few construct

1074
00:44:17,060 --> 00:44:21,180
constructions with type muc Security in

1075
00:44:21,180 --> 00:44:23,339
the literature even in the random Oracle

1076
00:44:23,339 --> 00:44:26,400
model for pke there is only one PK

1077
00:44:26,400 --> 00:44:30,900
scheme is proved to be tightly mu MCC CC

1078
00:44:30,900 --> 00:44:35,099
secure secure secure and is proposed by

1079
00:44:35,099 --> 00:44:38,099
again at all but it relies on the random

1080
00:44:38,099 --> 00:44:39,180
Oracle model

1081
00:44:39,180 --> 00:44:41,880
and for Signature schemes there are only

1082
00:44:41,880 --> 00:44:44,640
five schemes proved to be tightly muc

1083
00:44:44,640 --> 00:44:48,900
CMA security secure and only one of them

1084
00:44:48,900 --> 00:44:52,380
is proved to be tightly strong muc CMA

1085
00:44:52,380 --> 00:44:55,040
secure here strong means strong

1086
00:44:55,040 --> 00:44:58,440
extensional unfoldibility and it is

1087
00:44:58,440 --> 00:45:01,140
crucial in many applications such as

1088
00:45:01,140 --> 00:45:03,839
encryption and the authenticated key

1089
00:45:03,839 --> 00:45:05,760
exchange Etc

1090
00:45:05,760 --> 00:45:07,920
the only scheme the only signature

1091
00:45:07,920 --> 00:45:10,260
scheme with tight strong immune system

1092
00:45:10,260 --> 00:45:14,940
CMA security is a proposed by timer at

1093
00:45:14,940 --> 00:45:18,240
all but it also relies on the random

1094
00:45:18,240 --> 00:45:19,980
Oracle model

1095
00:45:19,980 --> 00:45:22,920
so a natural and challenging question is

1096
00:45:22,920 --> 00:45:25,740
can we achieve tight or almost tight muc

1097
00:45:25,740 --> 00:45:28,440
security in the standard model

1098
00:45:28,440 --> 00:45:31,380
in this work we answer the question in

1099
00:45:31,380 --> 00:45:33,720
the in the affirmative and propose the

1100
00:45:33,720 --> 00:45:35,700
first public encryption schemes with

1101
00:45:35,700 --> 00:45:38,640
almost tight muccc including the

1102
00:45:38,640 --> 00:45:40,800
standard model as well as the first

1103
00:45:40,800 --> 00:45:43,260
signature scheme with almost tight

1104
00:45:43,260 --> 00:45:45,540
strong mu system and Security in the

1105
00:45:45,540 --> 00:45:48,680
standard model the security laws are

1106
00:45:48,680 --> 00:45:51,540
logarithmic in the security parameter

1107
00:45:51,540 --> 00:45:54,480
Lambda and the security is based on the

1108
00:45:54,480 --> 00:45:57,000
standard Matrix ddh assumptions which

1109
00:45:57,000 --> 00:46:00,000
covers the standard sxdh and the key

1110
00:46:00,000 --> 00:46:02,579
linear assumptions

1111
00:46:02,579 --> 00:46:05,099
and we do not stop here and about

1112
00:46:05,099 --> 00:46:07,680
further but to further consider uh

1113
00:46:07,680 --> 00:46:10,500
streets in the security notion

1114
00:46:10,500 --> 00:46:13,319
called muc and L security which

1115
00:46:13,319 --> 00:46:15,480
considers smart user security under not

1116
00:46:15,480 --> 00:46:17,220
only adaptive Corruptions but also

1117
00:46:17,220 --> 00:46:18,900
adaptive leakages

1118
00:46:18,900 --> 00:46:23,640
record that in the muc security only

1119
00:46:23,640 --> 00:46:27,180
considers two kinds of users the crafted

1120
00:46:27,180 --> 00:46:29,640
users whose secret keys are fully

1121
00:46:29,640 --> 00:46:31,920
exposed to the adversary and the

1122
00:46:31,920 --> 00:46:34,740
encrypted users whose secret keys are

1123
00:46:34,740 --> 00:46:37,319
completely hidden to the adversary

1124
00:46:37,319 --> 00:46:41,520
in realistic scenarios there are

1125
00:46:41,520 --> 00:46:43,859
users whose secretly are only partially

1126
00:46:43,859 --> 00:46:47,220
linked to the adversaries and these

1127
00:46:47,220 --> 00:46:49,560
users it into a situation which is

1128
00:46:49,560 --> 00:46:52,680
neither corrupted nor uncrafted and the

1129
00:46:52,680 --> 00:46:54,780
muc security does not consider such

1130
00:46:54,780 --> 00:46:57,300
users and does not protect their

1131
00:46:57,300 --> 00:47:00,180
Securities and the new muc and L

1132
00:47:00,180 --> 00:47:02,040
security uh

1133
00:47:02,040 --> 00:47:04,440
takes this takes additionally takes

1134
00:47:04,440 --> 00:47:06,240
these users into account and protects

1135
00:47:06,240 --> 00:47:08,099
their security

1136
00:47:08,099 --> 00:47:12,000
in fact all our schemes can be further

1137
00:47:12,000 --> 00:47:15,420
straightened to support key cages and

1138
00:47:15,420 --> 00:47:19,700
Achieve almost tight mu CNL security

1139
00:47:19,700 --> 00:47:23,579
uh our application scheme can tolerance

1140
00:47:23,579 --> 00:47:27,240
uh one third minus small o leakage rate

1141
00:47:27,240 --> 00:47:30,060
and our signature scheme can tolerance a

1142
00:47:30,060 --> 00:47:33,540
1 over 6 minus smaller one leakage rate

1143
00:47:33,540 --> 00:47:36,300
and our schemes are the first schemes

1144
00:47:36,300 --> 00:47:39,480
with almost type muc and L security no

1145
00:47:39,480 --> 00:47:41,280
matter in the standard model or in the

1146
00:47:41,280 --> 00:47:44,060
random molecule model

1147
00:47:44,280 --> 00:47:46,200
uh

1148
00:47:46,200 --> 00:47:49,260
moreover or in terms of efficiency all

1149
00:47:49,260 --> 00:47:52,319
our schemes are fully compact means that

1150
00:47:52,319 --> 00:47:55,260
all the parameters Keys signatures and

1151
00:47:55,260 --> 00:47:58,560
the ciphertext consists of only a

1152
00:47:58,560 --> 00:48:01,859
constant number of group elements

1153
00:48:01,859 --> 00:48:05,099
and next I will show how to construct

1154
00:48:05,099 --> 00:48:08,880
our signature and PK schemes

1155
00:48:08,880 --> 00:48:11,579
the at the core of our constructions is

1156
00:48:11,579 --> 00:48:13,560
a new technical tool called publicly

1157
00:48:13,560 --> 00:48:17,119
verifiable hash proof system

1158
00:48:17,119 --> 00:48:20,220
first we record the we all know hash Pro

1159
00:48:20,220 --> 00:48:23,400
System proposed by grammar and shoot

1160
00:48:23,400 --> 00:48:26,220
for hashinki SK it defines a hash

1161
00:48:26,220 --> 00:48:30,060
function m.sk overall domain X and

1162
00:48:30,060 --> 00:48:33,540
and for nvx we can compute the hash

1163
00:48:33,540 --> 00:48:36,240
value privately through a private

1164
00:48:36,240 --> 00:48:39,599
evaluation algorithm directly using SK

1165
00:48:39,599 --> 00:48:44,160
and the SK is also associated with the

1166
00:48:44,160 --> 00:48:47,819
projection key PK which equals Fisk and

1167
00:48:47,819 --> 00:48:52,260
for for X in a subset of X namely the

1168
00:48:52,260 --> 00:48:55,980
language L we can use another equivalent

1169
00:48:55,980 --> 00:48:58,380
public evaluation algorithm to compute

1170
00:48:58,380 --> 00:49:01,079
its hash value

1171
00:49:01,079 --> 00:49:04,500
in 2019 we

1172
00:49:04,500 --> 00:49:07,260
we proposed the concept of quantity

1173
00:49:07,260 --> 00:49:10,819
adaptive HPS in a previous work

1174
00:49:10,819 --> 00:49:15,780
in for QA HPS it's a considers multiple

1175
00:49:15,780 --> 00:49:19,260
languages and on each language aoi we

1176
00:49:19,260 --> 00:49:21,420
can compute a projection key on its

1177
00:49:21,420 --> 00:49:24,980
namely the pki which equals Alpha iosk

1178
00:49:24,980 --> 00:49:28,500
and with pki we can

1179
00:49:28,500 --> 00:49:33,440
and we can evaluate the hash value

1180
00:49:33,440 --> 00:49:36,000
also with the public evaluation

1181
00:49:36,000 --> 00:49:39,180
algorithm which takes pki as inputs

1182
00:49:39,180 --> 00:49:42,720
and in this work we further extend to Q

1183
00:49:42,720 --> 00:49:45,060
of we further extend the QA HPS to

1184
00:49:45,060 --> 00:49:48,900
publicly verifiable QA HPS which enables

1185
00:49:48,900 --> 00:49:52,020
the Public Public replication of hash

1186
00:49:52,020 --> 00:49:54,060
values with the with an extra

1187
00:49:54,060 --> 00:49:56,819
verification key we Define a

1188
00:49:56,819 --> 00:49:59,280
verification key generation algorithm mu

1189
00:49:59,280 --> 00:50:01,619
to compute 3K and the public

1190
00:50:01,619 --> 00:50:05,099
verification algorithm verify HPS to

1191
00:50:05,099 --> 00:50:07,680
check the correctness of hash value with

1192
00:50:07,680 --> 00:50:11,240
the help of VK

1193
00:50:11,460 --> 00:50:14,640
we defines a set of useful properties

1194
00:50:14,640 --> 00:50:18,980
for p1qa HPS verification company

1195
00:50:18,980 --> 00:50:21,900
requires that only honestly Computing

1196
00:50:21,900 --> 00:50:23,760
the hash values always pass the

1197
00:50:23,760 --> 00:50:25,740
verification and the verification sign

1198
00:50:25,740 --> 00:50:28,560
is ensures that it is computationally

1199
00:50:28,560 --> 00:50:31,319
hard to find an incorrect hash value but

1200
00:50:31,319 --> 00:50:33,599
pass the verification

1201
00:50:33,599 --> 00:50:36,060
we also Define statistical leakage

1202
00:50:36,060 --> 00:50:39,119
resilience l0l one-time extracting

1203
00:50:39,119 --> 00:50:42,060
property which is parameterized by two

1204
00:50:42,060 --> 00:50:44,880
languages l0 and L it requires that

1205
00:50:44,880 --> 00:50:47,880
conditioned on the projection key PK 0

1206
00:50:47,880 --> 00:50:51,180
on the first language l0 and the

1207
00:50:51,180 --> 00:50:54,660
conditional VK and some bonded leakage

1208
00:50:54,660 --> 00:50:57,000
information is SK

1209
00:50:57,000 --> 00:51:00,300
learn for any X in the second language L

1210
00:51:00,300 --> 00:51:03,300
is Hash value and should have a high

1211
00:51:03,300 --> 00:51:06,000
main entropy this High main entropy

1212
00:51:06,000 --> 00:51:09,240
ensures that for any unbounded adversary

1213
00:51:09,240 --> 00:51:12,300
it is hard to Output the correct hash

1214
00:51:12,300 --> 00:51:16,220
value for any X in l

1215
00:51:16,380 --> 00:51:18,380
and we also need another building block

1216
00:51:18,380 --> 00:51:21,020
namely the quality adaptive music

1217
00:51:21,020 --> 00:51:24,180
proposed by jutila Android

1218
00:51:24,180 --> 00:51:27,000
and the way consider we will use the

1219
00:51:27,000 --> 00:51:29,940
tank based variants which wears a proof

1220
00:51:29,940 --> 00:51:31,319
generation algorithm verification

1221
00:51:31,319 --> 00:51:34,260
algorithm and the simulator also takes a

1222
00:51:34,260 --> 00:51:37,079
tank as input and we require perfect

1223
00:51:37,079 --> 00:51:39,000
zero knowledge and unbounded simulation

1224
00:51:39,000 --> 00:51:41,220
soundness

1225
00:51:41,220 --> 00:51:43,740
now we will show how we build our

1226
00:51:43,740 --> 00:51:47,040
schemes from public variable hash proof

1227
00:51:47,040 --> 00:51:49,740
system and the QA music

1228
00:51:49,740 --> 00:51:52,200
our signature scheme is constructed as

1229
00:51:52,200 --> 00:51:55,319
follows the its verification key and the

1230
00:51:55,319 --> 00:51:57,300
signing key adjusts the verification key

1231
00:51:57,300 --> 00:52:01,680
and hashing key of the PV and qhps and

1232
00:52:01,680 --> 00:52:03,599
in the signing algorithm it first

1233
00:52:03,599 --> 00:52:05,819
samples an instance X from the language

1234
00:52:05,819 --> 00:52:11,099
L with witness W then it computes a hash

1235
00:52:11,099 --> 00:52:15,180
value of x and also proves and generates

1236
00:52:15,180 --> 00:52:19,020
a Mystic proof that X is in the is

1237
00:52:19,020 --> 00:52:22,559
chosen from the language L and where the

1238
00:52:22,559 --> 00:52:25,380
tank is a message to be signed and in

1239
00:52:25,380 --> 00:52:29,220
the verification algorithm we will check

1240
00:52:29,220 --> 00:52:31,260
check the correctness of the hash value

1241
00:52:31,260 --> 00:52:34,980
publicly by by invoking the public

1242
00:52:34,980 --> 00:52:37,380
verification algorithm of the hospital

1243
00:52:37,380 --> 00:52:40,500
system and we also check the validity of

1244
00:52:40,500 --> 00:52:43,740
the Music proof pi

1245
00:52:43,740 --> 00:52:46,079
and next I will give a higher level

1246
00:52:46,079 --> 00:52:49,380
overview of our tight strong muc and L

1247
00:52:49,380 --> 00:52:52,260
security proof of our signature scheme

1248
00:52:52,260 --> 00:52:55,260
and the adversary can obtain the

1249
00:52:55,260 --> 00:52:57,359
verification keys of all users and the

1250
00:52:57,359 --> 00:52:59,940
issue corruption queries leakage queries

1251
00:52:59,940 --> 00:53:02,400
and assigning queries finally the

1252
00:53:02,400 --> 00:53:05,280
adversary will output a forgery I start

1253
00:53:05,280 --> 00:53:07,859
Einstein in the sigma star and the

1254
00:53:07,859 --> 00:53:10,140
adversary succeeds if the forgery is

1255
00:53:10,140 --> 00:53:13,440
fresh and valid and the and the

1256
00:53:13,440 --> 00:53:16,980
adversary never crafts the user I start

1257
00:53:16,980 --> 00:53:20,040
our proof goes with two main steps in

1258
00:53:20,040 --> 00:53:22,740
the first step when we will change the

1259
00:53:22,740 --> 00:53:26,880
way we we answer the sending queries

1260
00:53:26,880 --> 00:53:30,240
in the for signing queries we will

1261
00:53:30,240 --> 00:53:32,660
generate the pi using the simulator

1262
00:53:32,660 --> 00:53:35,700
which is identically distributed by the

1263
00:53:35,700 --> 00:53:37,280
prefix their knowledge of the

1264
00:53:37,280 --> 00:53:39,180
quasi-adaptive music

1265
00:53:39,180 --> 00:53:42,720
then we change the sampling of x from

1266
00:53:42,720 --> 00:53:46,440
language L to the language l0 row which

1267
00:53:46,440 --> 00:53:48,420
is computationally indistinguishable by

1268
00:53:48,420 --> 00:53:50,700
the subset membership problem

1269
00:53:50,700 --> 00:53:53,220
in this way we switch the language from

1270
00:53:53,220 --> 00:53:56,160
L to l0 for sending queries

1271
00:53:56,160 --> 00:53:59,760
and now in fact we can compute the hash

1272
00:53:59,760 --> 00:54:02,400
value using the public evaluation

1273
00:54:02,400 --> 00:54:06,119
algorithm and by using the projection

1274
00:54:06,119 --> 00:54:11,040
key Alpha l0 ski which is projected on

1275
00:54:11,040 --> 00:54:11,880
the

1276
00:54:11,880 --> 00:54:14,960
language l0

1277
00:54:15,000 --> 00:54:17,540
in the second step

1278
00:54:17,540 --> 00:54:20,160
way way

1279
00:54:20,160 --> 00:54:24,300
Ward directory directly reject the

1280
00:54:24,300 --> 00:54:28,260
forgery if if the X star is not in L and

1281
00:54:28,260 --> 00:54:31,680
this is uh in this indistinguishable by

1282
00:54:31,680 --> 00:54:33,839
the unbounded simulation soundness of

1283
00:54:33,839 --> 00:54:36,480
quasi-adaptivenessic

1284
00:54:36,480 --> 00:54:41,640
then we will then we will directly check

1285
00:54:41,640 --> 00:54:44,760
the the correctness of the hash value by

1286
00:54:44,760 --> 00:54:46,980
using the secret key instead of using

1287
00:54:46,980 --> 00:54:50,040
the public verification algorithm of pvq

1288
00:54:50,040 --> 00:54:52,859
HPS and this is also indistinguishable

1289
00:54:52,859 --> 00:54:55,500
Because by the verification sounds of

1290
00:54:55,500 --> 00:54:58,559
poaq HPS because the adversary is hard

1291
00:54:58,559 --> 00:55:01,680
to output and incorrect hash value about

1292
00:55:01,680 --> 00:55:04,859
passenger verification

1293
00:55:04,859 --> 00:55:07,800
and the way stress that our all our

1294
00:55:07,800 --> 00:55:10,559
reductions are tight without resorting

1295
00:55:10,559 --> 00:55:13,619
to any guessing strategy because all our

1296
00:55:13,619 --> 00:55:16,140
reductions have all signing keys of all

1297
00:55:16,140 --> 00:55:18,599
users to have to handle the Adaptive

1298
00:55:18,599 --> 00:55:20,579
corruption and the leakage queries made

1299
00:55:20,579 --> 00:55:22,859
by the adversary

1300
00:55:22,859 --> 00:55:26,339
now we can show that the adversary can

1301
00:55:26,339 --> 00:55:29,640
hardly succeed and this is because now

1302
00:55:29,640 --> 00:55:31,500
the adversaries knowledge about the

1303
00:55:31,500 --> 00:55:34,319
secret key in its forgery is limited in

1304
00:55:34,319 --> 00:55:36,780
the following three parts and the weekly

1305
00:55:36,780 --> 00:55:38,819
star from the verification or in the

1306
00:55:38,819 --> 00:55:41,940
verification key and the bounded leakage

1307
00:55:41,940 --> 00:55:44,700
information L ski starts from leakage

1308
00:55:44,700 --> 00:55:47,880
queries and the projection key alpha l0

1309
00:55:47,880 --> 00:55:51,839
x ski star from the sending Keys which

1310
00:55:51,839 --> 00:55:54,900
is a projection key projected on the

1311
00:55:54,900 --> 00:55:58,140
second language l0 then by the weekly

1312
00:55:58,140 --> 00:55:59,880
resilience one one-time extracting

1313
00:55:59,880 --> 00:56:02,780
property of our pyqa HPS

1314
00:56:02,780 --> 00:56:05,880
for any extra in the first language L

1315
00:56:05,880 --> 00:56:09,839
and its hash value has high entropy so

1316
00:56:09,839 --> 00:56:13,559
it's a is is hard for the language to

1317
00:56:13,559 --> 00:56:16,079
add to Output the correct hash value for

1318
00:56:16,079 --> 00:56:19,260
any extra in the language

1319
00:56:19,260 --> 00:56:22,680
our apke scheme is constructed from

1320
00:56:22,680 --> 00:56:25,079
qahps with new properties defined in

1321
00:56:25,079 --> 00:56:28,559
this work and also from QA music

1322
00:56:28,559 --> 00:56:32,400
and it and our PK shares a similar

1323
00:56:32,400 --> 00:56:35,880
design with our signature but there are

1324
00:56:35,880 --> 00:56:38,940
zero type proofs are quite different

1325
00:56:38,940 --> 00:56:42,240
we refer to our paper imprints for the

1326
00:56:42,240 --> 00:56:44,899
more details

1327
00:56:45,140 --> 00:56:47,520
finally I

1328
00:56:47,520 --> 00:56:50,280
I will show the instantiations from

1329
00:56:50,280 --> 00:56:52,740
Matrix ddh

1330
00:56:52,740 --> 00:56:55,440
we instantiate the building blocks of

1331
00:56:55,440 --> 00:56:58,740
our behind behind the our generic

1332
00:56:58,740 --> 00:57:00,839
constructions more precisely we

1333
00:57:00,839 --> 00:57:05,000
instantiate pyqa HPS uh

1334
00:57:05,000 --> 00:57:08,339
by using using the asymmetric pairing

1335
00:57:08,339 --> 00:57:10,319
groups to accomplish the public

1336
00:57:10,319 --> 00:57:13,500
verification of hash values hash values

1337
00:57:13,500 --> 00:57:16,200
inspired by the Qs and we

1338
00:57:16,200 --> 00:57:19,859
and the way instantiates QA analytic by

1339
00:57:19,859 --> 00:57:22,980
the by the scheme proposed by MB at all

1340
00:57:22,980 --> 00:57:26,280
and we instantiate the QA HPS with new

1341
00:57:26,280 --> 00:57:29,339
Properties by adapting the scheme

1342
00:57:29,339 --> 00:57:31,680
proposed by Han at all

1343
00:57:31,680 --> 00:57:35,280
all the other instantiations have almost

1344
00:57:35,280 --> 00:57:36,559
tight security

1345
00:57:36,559 --> 00:57:39,900
from the standard Matrix ddh assumptions

1346
00:57:39,900 --> 00:57:44,400
and this finally this will gives us the

1347
00:57:44,400 --> 00:57:47,040
almost times with secure signature and

1348
00:57:47,040 --> 00:57:49,380
pke schemes

1349
00:57:49,380 --> 00:57:53,760
and moreover we based on the PK and

1350
00:57:53,760 --> 00:57:56,460
signature schemes we in fact construct

1351
00:57:56,460 --> 00:57:58,559
more Primitives with almost type I'm

1352
00:57:58,559 --> 00:58:02,119
using the L security and the way

1353
00:58:02,119 --> 00:58:04,680
including the sign encryption message

1354
00:58:04,680 --> 00:58:06,839
authentication code and authenticated

1355
00:58:06,839 --> 00:58:09,359
encryption and we optimize these

1356
00:58:09,359 --> 00:58:11,040
constructions to achieve better

1357
00:58:11,040 --> 00:58:12,260
efficiency

1358
00:58:12,260 --> 00:58:13,940
especially

1359
00:58:13,940 --> 00:58:17,220
to obtain the same encryption we use an

1360
00:58:17,220 --> 00:58:21,359
optimized encrypt Zen sign Paradigm by

1361
00:58:21,359 --> 00:58:24,059
by taking advantage of the similar

1362
00:58:24,059 --> 00:58:27,300
designs of our pke and signature schemes

1363
00:58:27,300 --> 00:58:30,540
and reusing some components

1364
00:58:30,540 --> 00:58:33,240
let me now conclude the talk in this

1365
00:58:33,240 --> 00:58:36,180
work we propose the first a bunch of

1366
00:58:36,180 --> 00:58:38,780
schemes including the signature

1367
00:58:38,780 --> 00:58:42,059
PK's encryption Mac and authenticated

1368
00:58:42,059 --> 00:58:43,980
encryption schemes which are the first

1369
00:58:43,980 --> 00:58:46,619
achieving almost tight muc security in

1370
00:58:46,619 --> 00:58:49,079
the standard model which are also the

1371
00:58:49,079 --> 00:58:52,020
first schemes with almost at muc and L

1372
00:58:52,020 --> 00:58:54,720
security our schemes are obtained

1373
00:58:54,720 --> 00:58:58,380
through generic constructions by using a

1374
00:58:58,380 --> 00:59:00,180
new technical tool called publicly

1375
00:59:00,180 --> 00:59:03,540
available QA HPS and we also give fully

1376
00:59:03,540 --> 00:59:07,079
compact installations from the mddh over

1377
00:59:07,079 --> 00:59:09,660
asymmetric pairing groups and that's

1378
00:59:09,660 --> 00:59:13,700
that's it thanks for your listening

1379
00:59:19,740 --> 00:59:23,040
we're out of time but maybe one quick

1380
00:59:23,040 --> 00:59:25,339
question

1381
00:59:27,660 --> 00:59:31,690
all right so let's thank the speaker

1382
00:59:31,690 --> 00:59:35,099
[Applause]

1383
00:59:35,099 --> 00:59:37,020
and that's the end of the session thank

1384
00:59:37,020 --> 00:59:39,140
you

