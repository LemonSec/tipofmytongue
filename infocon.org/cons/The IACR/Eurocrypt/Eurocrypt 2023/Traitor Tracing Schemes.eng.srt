1
00:00:00,000 --> 00:00:02,040
recent revoke with optimal parameters

2
00:00:02,040 --> 00:00:04,380
from polynomial hardness this is work by

3
00:00:04,380 --> 00:00:07,500
shweta agrawal simran Kumari anshu yadav

4
00:00:07,500 --> 00:00:09,840
ashota Yamada and simran will be giving

5
00:00:09,840 --> 00:00:11,519
a talk

6
00:00:11,519 --> 00:00:14,280
hi everyone today I'll be talking about

7
00:00:14,280 --> 00:00:16,199
broadcast trace and revoke with optimal

8
00:00:16,199 --> 00:00:18,720
parameters from polynomial hardness

9
00:00:18,720 --> 00:00:22,979
this is a joint work with Yamada

10
00:00:23,220 --> 00:00:25,859
let us begin with the motivation for our

11
00:00:25,859 --> 00:00:28,560
problem let us consider a Content

12
00:00:28,560 --> 00:00:30,779
distributors in Netflix that wants to

13
00:00:30,779 --> 00:00:34,260
share some movie with its users the

14
00:00:34,260 --> 00:00:35,940
guarantee that it would like to have is

15
00:00:35,940 --> 00:00:38,040
that only the subscribed user should be

16
00:00:38,040 --> 00:00:40,219
able to get access to this movie

17
00:00:40,219 --> 00:00:42,960
one trivial approach to do this would be

18
00:00:42,960 --> 00:00:45,780
using a public encryption scheme where

19
00:00:45,780 --> 00:00:46,980
it can

20
00:00:46,980 --> 00:00:49,320
use the public key of the subscribed

21
00:00:49,320 --> 00:00:51,780
users to encode this movie and share it

22
00:00:51,780 --> 00:00:56,039
with them but a trivial uh problem with

23
00:00:56,039 --> 00:00:58,320
this approach is that the size of the

24
00:00:58,320 --> 00:01:01,140
ciphertext will grow linearly with the

25
00:01:01,140 --> 00:01:02,100
number of

26
00:01:02,100 --> 00:01:04,319
subscribed users or number of the users

27
00:01:04,319 --> 00:01:06,600
involved in the system and in general

28
00:01:06,600 --> 00:01:08,100
there could be millions of users

29
00:01:08,100 --> 00:01:10,320
subscribed to the Netflix and Computing

30
00:01:10,320 --> 00:01:12,240
millions of Cipher text is obviously a

31
00:01:12,240 --> 00:01:13,560
problem

32
00:01:13,560 --> 00:01:16,140
so a question that we can ask here is uh

33
00:01:16,140 --> 00:01:18,720
can we have a better approach can we

34
00:01:18,720 --> 00:01:21,060
have a short common Cipher text that we

35
00:01:21,060 --> 00:01:24,240
can use to broadcast this data and by

36
00:01:24,240 --> 00:01:27,180
short I mean the size of the ciphertext

37
00:01:27,180 --> 00:01:29,180
could be sub linear in the number of

38
00:01:29,180 --> 00:01:32,880
users or even better logarithmic in the

39
00:01:32,880 --> 00:01:35,340
number of users

40
00:01:35,340 --> 00:01:37,920
along along with this it could so happen

41
00:01:37,920 --> 00:01:39,900
that some of the users in the system

42
00:01:39,900 --> 00:01:42,420
could turn out to be malicious so this

43
00:01:42,420 --> 00:01:45,360
users can come together and design a

44
00:01:45,360 --> 00:01:48,119
decoder box that decodes messages that

45
00:01:48,119 --> 00:01:50,460
were just meant to be learned by the

46
00:01:50,460 --> 00:01:52,920
valid users so here this users can

47
00:01:52,920 --> 00:01:55,560
cleverly pool their access key and

48
00:01:55,560 --> 00:01:57,659
Design This decoder box in such a way

49
00:01:57,659 --> 00:02:00,780
that you could just learn what you could

50
00:02:00,780 --> 00:02:02,579
learn from this decoder box is just the

51
00:02:02,579 --> 00:02:05,460
input output Behavior so another

52
00:02:05,460 --> 00:02:07,920
question that one could ask here is uh

53
00:02:07,920 --> 00:02:09,959
can we catch a valid malicious user here

54
00:02:09,959 --> 00:02:14,000
so by valid I mean a user with a

55
00:02:14,000 --> 00:02:17,400
valid access key who participated in

56
00:02:17,400 --> 00:02:19,440
designing this decoder

57
00:02:19,440 --> 00:02:21,840
so all these questions are answered

58
00:02:21,840 --> 00:02:23,459
affirmatively by the notion of broadcast

59
00:02:23,459 --> 00:02:26,220
race and revoke uh where there are

60
00:02:26,220 --> 00:02:28,319
multiple users in the system and each

61
00:02:28,319 --> 00:02:31,080
user has a user specific secret key

62
00:02:31,080 --> 00:02:34,319
and this Authority can broadcast a data

63
00:02:34,319 --> 00:02:36,360
by encrypting it with some common Master

64
00:02:36,360 --> 00:02:37,500
public key

65
00:02:37,500 --> 00:02:39,540
this notion has been studied under

66
00:02:39,540 --> 00:02:41,879
different names in the literature so if

67
00:02:41,879 --> 00:02:43,680
the encoding of data happens with

68
00:02:43,680 --> 00:02:46,440
respect to the set of authorized users

69
00:02:46,440 --> 00:02:48,900
we call it broadcast entries and the

70
00:02:48,900 --> 00:02:51,360
guarantee here is that any user in this

71
00:02:51,360 --> 00:02:53,099
valid set should be able to use their

72
00:02:53,099 --> 00:02:55,920
key and recover the message from this

73
00:02:55,920 --> 00:02:58,260
encoded data

74
00:02:58,260 --> 00:03:00,959
if the encoding happens with respect to

75
00:03:00,959 --> 00:03:04,680
the set of non-validated user or revoked

76
00:03:04,680 --> 00:03:06,959
user we call it trace and revoke and the

77
00:03:06,959 --> 00:03:08,700
guarantee here is similar but stated

78
00:03:08,700 --> 00:03:10,980
differently that any user outside this

79
00:03:10,980 --> 00:03:12,840
list L should be able to use their key

80
00:03:12,840 --> 00:03:15,659
to recover this data and from the

81
00:03:15,659 --> 00:03:17,720
ciphertext

82
00:03:17,720 --> 00:03:21,780
in our work we call if we achieve uh

83
00:03:21,780 --> 00:03:24,959
sorry so if this encoding happens with

84
00:03:24,959 --> 00:03:27,300
respect to the revoke list L and the

85
00:03:27,300 --> 00:03:28,920
ciphertext that we achieve is

86
00:03:28,920 --> 00:03:31,860
independent of the size of encoded list

87
00:03:31,860 --> 00:03:34,140
we prefer calling it broadcast race and

88
00:03:34,140 --> 00:03:35,220
revoke

89
00:03:35,220 --> 00:03:37,680
uh in this notion if some of the users

90
00:03:37,680 --> 00:03:39,959
turn out to be malicious and design a

91
00:03:39,959 --> 00:03:42,900
decoder uh then uh the guarantee we have

92
00:03:42,900 --> 00:03:44,640
here is that there exists a tracing

93
00:03:44,640 --> 00:03:46,980
algorithm which can help us Trace back

94
00:03:46,980 --> 00:03:50,340
to uh valid malicious user so in this

95
00:03:50,340 --> 00:03:53,580
draw example your uh user 3 has a valid

96
00:03:53,580 --> 00:03:55,860
key and he or she participated in

97
00:03:55,860 --> 00:03:58,440
designing this decoder so this tracing

98
00:03:58,440 --> 00:04:00,299
algorithm will output that user 3 is

99
00:04:00,299 --> 00:04:02,280
literature

100
00:04:02,280 --> 00:04:04,920
this notion provides us uh multiple

101
00:04:04,920 --> 00:04:06,659
guarantees the first one is of message

102
00:04:06,659 --> 00:04:08,940
hiding which says that no matter how

103
00:04:08,940 --> 00:04:11,099
many users in L come together and pull

104
00:04:11,099 --> 00:04:12,920
their keys they will not be able to

105
00:04:12,920 --> 00:04:17,940
learn uh the data from this ciphertext

106
00:04:17,940 --> 00:04:20,459
uh the second guarantee is of secure

107
00:04:20,459 --> 00:04:22,740
tracing which says that this tracing

108
00:04:22,740 --> 00:04:24,780
algorithm will output at least one valid

109
00:04:24,780 --> 00:04:26,520
malicious user that is it will output

110
00:04:26,520 --> 00:04:29,639
one malicious user outside l another

111
00:04:29,639 --> 00:04:32,639
guarantee we have is that no honest user

112
00:04:32,639 --> 00:04:35,759
will be falsely accused

113
00:04:35,759 --> 00:04:37,740
so uh we study this primitive of

114
00:04:37,740 --> 00:04:39,900
broadcast race and revoke uh in two

115
00:04:39,900 --> 00:04:42,060
Notions the first notion two notion of

116
00:04:42,060 --> 00:04:43,620
traceability the first notion is public

117
00:04:43,620 --> 00:04:46,080
traceability uh which says that the

118
00:04:46,080 --> 00:04:47,820
tracing algorithm uses the master public

119
00:04:47,820 --> 00:04:51,479
key to run so anyone in the system can

120
00:04:51,479 --> 00:04:53,280
use the master public key and run the

121
00:04:53,280 --> 00:04:56,220
tracing algorithm the other notion is of

122
00:04:56,220 --> 00:04:58,259
private traceability uh in which the

123
00:04:58,259 --> 00:04:59,940
tracing algorithm runs using the master

124
00:04:59,940 --> 00:05:02,520
secret key

125
00:05:02,520 --> 00:05:06,000
so okay now um once um let us say we

126
00:05:06,000 --> 00:05:07,860
have this tracing algorithm which is

127
00:05:07,860 --> 00:05:09,960
given this access to the decoder and it

128
00:05:09,960 --> 00:05:12,840
outputs a validator now as you can see

129
00:05:12,840 --> 00:05:15,180
uh this key is associated with an index

130
00:05:15,180 --> 00:05:17,160
and uh once this tracing algorithm

131
00:05:17,160 --> 00:05:19,680
outputs the index of the traitor The

132
00:05:19,680 --> 00:05:21,840
Authority would like to hold that user

133
00:05:21,840 --> 00:05:23,820
accountable and take some action against

134
00:05:23,820 --> 00:05:26,880
it so it needs to get back to this uh

135
00:05:26,880 --> 00:05:29,639
user index user identity mapping so it

136
00:05:29,639 --> 00:05:32,880
will store a table that says which user

137
00:05:32,880 --> 00:05:35,580
identity was mapped to that index and

138
00:05:35,580 --> 00:05:38,400
using this table it can get back to the

139
00:05:38,400 --> 00:05:40,860
identity of the traitor and you know

140
00:05:40,860 --> 00:05:45,020
maybe revoke itself access key

141
00:05:45,020 --> 00:05:47,340
in their work pointed out that this

142
00:05:47,340 --> 00:05:51,120
approach of going via mapping this

143
00:05:51,120 --> 00:05:54,060
identity to index and then using it to

144
00:05:54,060 --> 00:05:55,440
generate secret Keys has certain

145
00:05:55,440 --> 00:05:57,600
limitations uh the first one is obvious

146
00:05:57,600 --> 00:06:00,300
of maintaining this user index user

147
00:06:00,300 --> 00:06:02,940
identity table the second is that in the

148
00:06:02,940 --> 00:06:05,520
case of public traceability where anyone

149
00:06:05,520 --> 00:06:06,780
should be able to run the tracing

150
00:06:06,780 --> 00:06:08,699
algorithm this table needs to be made

151
00:06:08,699 --> 00:06:11,820
public and then it would compromise the

152
00:06:11,820 --> 00:06:15,060
identity of even the honest users so uh

153
00:06:15,060 --> 00:06:18,060
this method is certainly problematic and

154
00:06:18,060 --> 00:06:20,160
nishimaki vixen's entry in their work

155
00:06:20,160 --> 00:06:21,720
proposed resolution of embedding

156
00:06:21,720 --> 00:06:24,419
identities and they said we would rather

157
00:06:24,419 --> 00:06:26,580
want to embed the identity of the user

158
00:06:26,580 --> 00:06:28,259
directly in the secret key rather than

159
00:06:28,259 --> 00:06:30,060
going by the index path

160
00:06:30,060 --> 00:06:32,759
uh but achieving this notion of embedded

161
00:06:32,759 --> 00:06:35,400
identities was particularly challenging

162
00:06:35,400 --> 00:06:36,960
um in the traditional tracing method

163
00:06:36,960 --> 00:06:39,960
that existed uh we use a linear search

164
00:06:39,960 --> 00:06:42,660
method on the user space to get uh to

165
00:06:42,660 --> 00:06:45,720
the traitors now uh we note that even

166
00:06:45,720 --> 00:06:47,639
for polynomial number of users the

167
00:06:47,639 --> 00:06:49,860
identity space could be exponential and

168
00:06:49,860 --> 00:06:52,139
using this linear search method would

169
00:06:52,139 --> 00:06:54,840
lead us exponential time uh in getting

170
00:06:54,840 --> 00:06:57,840
to the traitors which is not desirable

171
00:06:57,840 --> 00:06:59,880
there were multiple Solutions proposed

172
00:06:59,880 --> 00:07:02,160
uh to this uh one of them is by

173
00:07:02,160 --> 00:07:04,740
nishimaki at all in the same work where

174
00:07:04,740 --> 00:07:07,680
they propose new techniques to do this

175
00:07:07,680 --> 00:07:10,500
tracing and also give constructions of

176
00:07:10,500 --> 00:07:12,180
Traitor tracing and Trace and revoke

177
00:07:12,180 --> 00:07:15,000
schemes with embedded identities another

178
00:07:15,000 --> 00:07:16,979
solution was proposed by Goyle koplin

179
00:07:16,979 --> 00:07:18,539
Waters where they come up with a

180
00:07:18,539 --> 00:07:21,840
different technique to do the tracing

181
00:07:21,840 --> 00:07:24,120
and also show a traitor tracing scheme

182
00:07:24,120 --> 00:07:27,259
with embedded identities

183
00:07:27,360 --> 00:07:29,340
um now we look at the goals the

184
00:07:29,340 --> 00:07:30,960
properties that we would want for our

185
00:07:30,960 --> 00:07:33,180
broadcast race and revoke scheme so the

186
00:07:33,180 --> 00:07:35,280
first goal uh property that we want is

187
00:07:35,280 --> 00:07:38,220
of optimal parameters where I would want

188
00:07:38,220 --> 00:07:39,780
that we would want that the size of

189
00:07:39,780 --> 00:07:42,000
ciphertext uh the public key and the

190
00:07:42,000 --> 00:07:43,740
secret key is independent of the number

191
00:07:43,740 --> 00:07:46,199
of users or more specifically uh the set

192
00:07:46,199 --> 00:07:48,479
of targeted users

193
00:07:48,479 --> 00:07:50,940
uh another guarantee uh that we want

194
00:07:50,940 --> 00:07:53,220
here is of adaptive security uh with

195
00:07:53,220 --> 00:07:55,259
respect to revocation lists so in our

196
00:07:55,259 --> 00:07:57,720
notion we see that the encryption

197
00:07:57,720 --> 00:07:59,880
happens with respect to a revocalist l

198
00:07:59,880 --> 00:08:02,400
and uh in the Adaptive version of the

199
00:08:02,400 --> 00:08:04,440
security that we Define uh we give the

200
00:08:04,440 --> 00:08:06,300
flexibility to the adversary to Output

201
00:08:06,300 --> 00:08:08,699
this list after he or she gets to see

202
00:08:08,699 --> 00:08:10,979
the public parameters and user secret

203
00:08:10,979 --> 00:08:14,039
keys and another property that we would

204
00:08:14,039 --> 00:08:15,300
like to achieve is of embedded

205
00:08:15,300 --> 00:08:17,039
identities

206
00:08:17,039 --> 00:08:18,960
and we would like to achieve all these

207
00:08:18,960 --> 00:08:20,879
three properties in both the public and

208
00:08:20,879 --> 00:08:22,680
secret Trace setting

209
00:08:22,680 --> 00:08:25,319
so now let us move on to the prior work

210
00:08:25,319 --> 00:08:26,940
in the public Trace settings so the work

211
00:08:26,940 --> 00:08:28,979
by Nishi Market all achieves optimal

212
00:08:28,979 --> 00:08:31,199
parameters uh along with embedded

213
00:08:31,199 --> 00:08:34,080
identities by relying on i o uh but they

214
00:08:34,080 --> 00:08:35,640
only managed to achieve selective

215
00:08:35,640 --> 00:08:36,919
security

216
00:08:36,919 --> 00:08:39,179
the work by Goyle at all achieves

217
00:08:39,179 --> 00:08:41,640
optimal parameters along with adaptive

218
00:08:41,640 --> 00:08:44,159
security by relying on sub-exponential

219
00:08:44,159 --> 00:08:46,920
positional witness encryption uh

220
00:08:46,920 --> 00:08:49,620
and they do not manage to achieve

221
00:08:49,620 --> 00:08:52,140
embedded identities in their work in our

222
00:08:52,140 --> 00:08:55,140
work we achieve optimal parameters along

223
00:08:55,140 --> 00:08:56,820
with adaptive security and embedded

224
00:08:56,820 --> 00:08:58,320
identities by relying just on

225
00:08:58,320 --> 00:09:00,540
polynomically hard assumptions

226
00:09:00,540 --> 00:09:02,399
so looking at these assumptions more

227
00:09:02,399 --> 00:09:04,080
closely in the public Trace setting the

228
00:09:04,080 --> 00:09:06,300
work by nishimaki at all uses identity

229
00:09:06,300 --> 00:09:08,220
uh indistinguishability obfuscation

230
00:09:08,220 --> 00:09:10,080
which is inherently a sub-exponential

231
00:09:10,080 --> 00:09:13,080
assumption the work by Goyle at all uh

232
00:09:13,080 --> 00:09:15,300
uses positional witness encryption and

233
00:09:15,300 --> 00:09:16,920
their security proof incurs and

234
00:09:16,920 --> 00:09:18,899
exponential loss which is why they need

235
00:09:18,899 --> 00:09:21,240
to rely on sub-exponential security of

236
00:09:21,240 --> 00:09:22,560
pwe

237
00:09:22,560 --> 00:09:25,500
and moreover we do not know of any

238
00:09:25,500 --> 00:09:27,839
construction of pwe from polynominally

239
00:09:27,839 --> 00:09:29,160
hard assumptions

240
00:09:29,160 --> 00:09:33,360
uh in our work uh we achieve we rely on

241
00:09:33,360 --> 00:09:35,220
polynominally hard assumptions of

242
00:09:35,220 --> 00:09:37,620
functional encryption and attribute

243
00:09:37,620 --> 00:09:41,100
based encryption so I'll briefly uh tell

244
00:09:41,100 --> 00:09:43,140
you what these Primitives are we already

245
00:09:43,140 --> 00:09:46,200
saw this in previous session so in a

246
00:09:46,200 --> 00:09:47,640
functional encryption scheme the secret

247
00:09:47,640 --> 00:09:49,980
key is associated with the circuit and

248
00:09:49,980 --> 00:09:52,620
when you decrypt an encoded data all you

249
00:09:52,620 --> 00:09:54,839
learn is the circuit value on the data

250
00:09:54,839 --> 00:09:56,580
and nothing else

251
00:09:56,580 --> 00:09:58,620
uh in an attribute based encryption

252
00:09:58,620 --> 00:10:01,019
scheme uh the input that is encoded it

253
00:10:01,019 --> 00:10:03,360
has two parts one is public and one is

254
00:10:03,360 --> 00:10:05,700
private and when we decrypt it using a

255
00:10:05,700 --> 00:10:07,760
secret key associated with a circuit C

256
00:10:07,760 --> 00:10:10,800
we learn the private part if and only if

257
00:10:10,800 --> 00:10:14,160
C of X is one so this variation where

258
00:10:14,160 --> 00:10:16,519
the secret key is associated with the

259
00:10:16,519 --> 00:10:19,500
policy we call it key policy attribute

260
00:10:19,500 --> 00:10:21,839
based encryption scheme uh there is

261
00:10:21,839 --> 00:10:23,700
another variation of it where

262
00:10:23,700 --> 00:10:26,519
sorry where the ciphertext is associated

263
00:10:26,519 --> 00:10:28,380
with the policy and we call it uh

264
00:10:28,380 --> 00:10:32,040
ciphertext policy Abe scheme so uh

265
00:10:32,040 --> 00:10:34,019
coming back to the assumptions of our

266
00:10:34,019 --> 00:10:36,480
public trade setting uh we get our

267
00:10:36,480 --> 00:10:38,519
construction uh relying on special Fe

268
00:10:38,519 --> 00:10:41,760
and special k p a b so by special I mean

269
00:10:41,760 --> 00:10:44,820
we use uh these uh Primitives with

270
00:10:44,820 --> 00:10:47,339
certain efficiency properties and both

271
00:10:47,339 --> 00:10:48,959
of which are known from polynomial hard

272
00:10:48,959 --> 00:10:50,940
assumptions so we achieve all the goals

273
00:10:50,940 --> 00:10:52,620
by relying on just polynomially hard

274
00:10:52,620 --> 00:10:54,000
assumptions

275
00:10:54,000 --> 00:10:56,339
coming to secret traceability uh the

276
00:10:56,339 --> 00:10:59,160
work by Goyle at all uses standard

277
00:10:59,160 --> 00:11:01,560
assumptions but it fails to achieve

278
00:11:01,560 --> 00:11:03,180
optimal parameters or embedded

279
00:11:03,180 --> 00:11:06,120
identities the work by xandry improves

280
00:11:06,120 --> 00:11:07,920
over the work of Goyle at all and he

281
00:11:07,920 --> 00:11:09,720
shows a trade-off between the size of

282
00:11:09,720 --> 00:11:12,779
ciphertext public key and secret key but

283
00:11:12,779 --> 00:11:14,820
by relying on a non-standard security

284
00:11:14,820 --> 00:11:18,200
model of a generic group model

285
00:11:18,200 --> 00:11:21,000
the work by zandry also does not achieve

286
00:11:21,000 --> 00:11:23,579
embedded identities in our work we show

287
00:11:23,579 --> 00:11:25,260
that by tweaking the construction of

288
00:11:25,260 --> 00:11:28,200
Goyle at all we can actually modify we

289
00:11:28,200 --> 00:11:30,620
can actually achieve a construction with

290
00:11:30,620 --> 00:11:34,279
optimal ciphertext

291
00:11:35,240 --> 00:11:38,160
they achieve optimal size secret key and

292
00:11:38,160 --> 00:11:40,380
optimal size public key they do achieve

293
00:11:40,380 --> 00:11:42,779
embedded identities uh by relying on the

294
00:11:42,779 --> 00:11:45,660
hardness of learning with errors but

295
00:11:45,660 --> 00:11:47,760
their ciphertext scales linearly in the

296
00:11:47,760 --> 00:11:49,320
size of the revocation list that they

297
00:11:49,320 --> 00:11:50,579
support

298
00:11:50,579 --> 00:11:52,560
in our work we achieve optimal

299
00:11:52,560 --> 00:11:57,240
parameters uh for this optimal size for

300
00:11:57,240 --> 00:11:59,760
all the parameters uh and we do achieve

301
00:11:59,760 --> 00:12:01,380
embedded identities by relying on

302
00:12:01,380 --> 00:12:03,240
polynomial heart assumptions

303
00:12:03,240 --> 00:12:05,279
so looking at the assumptions more

304
00:12:05,279 --> 00:12:07,380
closely in the secretary setting uh the

305
00:12:07,380 --> 00:12:09,120
work by Goyle at all and xandry both

306
00:12:09,120 --> 00:12:12,000
uses pairings which is insecure in the

307
00:12:12,000 --> 00:12:13,800
post Quantum regime

308
00:12:13,800 --> 00:12:16,440
uh the work by Kim and Wu does use a

309
00:12:16,440 --> 00:12:17,940
post Quantum secure Assumption of

310
00:12:17,940 --> 00:12:20,579
lattices but the security proof incurs

311
00:12:20,579 --> 00:12:22,200
and exponential loss which is why they

312
00:12:22,200 --> 00:12:24,240
need to rely on sub-exponentially secure

313
00:12:24,240 --> 00:12:27,300
lwe and moreover their ciphertext is not

314
00:12:27,300 --> 00:12:29,100
optimal

315
00:12:29,100 --> 00:12:32,279
in our work we rely on special ABS both

316
00:12:32,279 --> 00:12:33,899
of which are known from polynomially

317
00:12:33,899 --> 00:12:36,720
hard assumptions based on lattices which

318
00:12:36,720 --> 00:12:40,140
is constructed to be post Quantum safe

319
00:12:40,140 --> 00:12:42,899
uh I would also like to uh take a minute

320
00:12:42,899 --> 00:12:45,000
to compare the techniques of our public

321
00:12:45,000 --> 00:12:48,600
trace and secret Trace setting so uh to

322
00:12:48,600 --> 00:12:49,920
achieve the stronger notion of public

323
00:12:49,920 --> 00:12:52,320
traceability we rely on a primitive and

324
00:12:52,320 --> 00:12:54,180
of wystopia which is a compact

325
00:12:54,180 --> 00:12:56,940
functional encryption uh to achieve the

326
00:12:56,940 --> 00:12:59,339
weaker notion we just do it with special

327
00:12:59,339 --> 00:13:02,720
Abes and I would like to mention that

328
00:13:02,720 --> 00:13:05,100
attribute based encryption is much

329
00:13:05,100 --> 00:13:06,779
weaker than functional encryption since

330
00:13:06,779 --> 00:13:09,120
a b is an All or Nothing primitive as in

331
00:13:09,120 --> 00:13:11,820
contrast to Fe so we achieve our weaker

332
00:13:11,820 --> 00:13:15,740
notion by relying on weaker Primitives

333
00:13:16,079 --> 00:13:19,680
so uh now I give an outline of our of

334
00:13:19,680 --> 00:13:22,019
our construction so we reach embedded

335
00:13:22,019 --> 00:13:25,139
identity broadcast race and revoke from

336
00:13:25,139 --> 00:13:26,940
an intermediate notion of revocable

337
00:13:26,940 --> 00:13:28,560
predicate encryption

338
00:13:28,560 --> 00:13:30,240
so uh this revocable predicate

339
00:13:30,240 --> 00:13:32,339
encryption was introduced by Kim and Wu

340
00:13:32,339 --> 00:13:33,959
in their work in the secret Trace

341
00:13:33,959 --> 00:13:36,180
setting but we generalize it to the

342
00:13:36,180 --> 00:13:38,459
public in the secret key setting but we

343
00:13:38,459 --> 00:13:40,019
generalize it through the public key

344
00:13:40,019 --> 00:13:41,820
setting in our work so here I present

345
00:13:41,820 --> 00:13:43,200
the definition for the public key

346
00:13:43,200 --> 00:13:45,720
setting so in a revocable predicate

347
00:13:45,720 --> 00:13:47,760
encryption each secret key is associated

348
00:13:47,760 --> 00:13:50,579
with a label and an attribute and the

349
00:13:50,579 --> 00:13:54,360
authority maintains a list of labels

350
00:13:54,360 --> 00:13:56,820
to encode a data it is encoded with

351
00:13:56,820 --> 00:13:59,579
respect to a predicate F and a revoke

352
00:13:59,579 --> 00:14:02,220
list L and the guarantee here is that

353
00:14:02,220 --> 00:14:06,000
you can learn this M from the ciphertext

354
00:14:06,000 --> 00:14:08,880
uh using a secret key if

355
00:14:08,880 --> 00:14:10,680
the function associated with the

356
00:14:10,680 --> 00:14:12,480
ciphertext satisfies the attribute

357
00:14:12,480 --> 00:14:14,940
associated with your key and you are a

358
00:14:14,940 --> 00:14:16,620
non-devoked user that is the label

359
00:14:16,620 --> 00:14:19,980
should not be in the list l

360
00:14:19,980 --> 00:14:21,779
it also satisfies few security

361
00:14:21,779 --> 00:14:24,360
properties uh the first one is of

362
00:14:24,360 --> 00:14:27,779
message hiding security which says that

363
00:14:27,779 --> 00:14:29,639
the encryption of two different messages

364
00:14:29,639 --> 00:14:32,279
with respect to same function and the

365
00:14:32,279 --> 00:14:34,079
revocalist should be indistinguishable

366
00:14:34,079 --> 00:14:36,600
if you do not have a decrypting key

367
00:14:36,600 --> 00:14:37,579
query

368
00:14:37,579 --> 00:14:40,560
decrypting Keys which means that for all

369
00:14:40,560 --> 00:14:43,740
key queries f of x should be 0 or the

370
00:14:43,740 --> 00:14:45,899
label should be revoked another security

371
00:14:45,899 --> 00:14:47,760
guarantee that it satisfies is of

372
00:14:47,760 --> 00:14:49,740
function hiring security which says that

373
00:14:49,740 --> 00:14:51,360
encryption of two different functions

374
00:14:51,360 --> 00:14:53,279
with respect to the same message and

375
00:14:53,279 --> 00:14:55,079
revoke list L should be

376
00:14:55,079 --> 00:14:57,120
indistinguishable if for all key queries

377
00:14:57,120 --> 00:15:00,120
uh the function value both F 0 of X is

378
00:15:00,120 --> 00:15:04,680
equals to F1 of X or the label is in l

379
00:15:04,680 --> 00:15:07,620
so um at a very high level since I'm not

380
00:15:07,620 --> 00:15:09,300
going to go into the construction I

381
00:15:09,300 --> 00:15:11,399
would like to point out that this label

382
00:15:11,399 --> 00:15:14,820
uh check the membership check this helps

383
00:15:14,820 --> 00:15:16,980
us do the membership membership check in

384
00:15:16,980 --> 00:15:19,440
our broadcast race and revoke scheme and

385
00:15:19,440 --> 00:15:21,660
this uh function evaluation on this

386
00:15:21,660 --> 00:15:24,360
attribute helps us with the tracing in

387
00:15:24,360 --> 00:15:27,720
our broadcast race and revoke scheme

388
00:15:27,720 --> 00:15:30,060
so moving on I would like to point out

389
00:15:30,060 --> 00:15:31,699
that to get to

390
00:15:31,699 --> 00:15:34,019
embedded identity broadcast race and

391
00:15:34,019 --> 00:15:37,139
revoke from rpe we use uh techniques we

392
00:15:37,139 --> 00:15:38,880
adapt the techniques of Goyle at all

393
00:15:38,880 --> 00:15:40,440
that they introduced in context of

394
00:15:40,440 --> 00:15:44,100
Traitor tracing we adapted to include

395
00:15:44,100 --> 00:15:47,399
the revocation list in our setting

396
00:15:47,399 --> 00:15:49,920
so um I'd be giving a very brief outline

397
00:15:49,920 --> 00:15:53,399
of our publicly revocable predicate

398
00:15:53,399 --> 00:15:55,380
encryption scheme we get it using

399
00:15:55,380 --> 00:15:57,600
compact functional encryption scheme and

400
00:15:57,600 --> 00:16:01,079
key policy a b with succinct keys so by

401
00:16:01,079 --> 00:16:03,120
compact Fe I mean that the size of Fe

402
00:16:03,120 --> 00:16:05,279
ciphertext is independent of the size of

403
00:16:05,279 --> 00:16:08,120
function that this Fe scheme supports

404
00:16:08,120 --> 00:16:11,100
and in a key policy a b with succinct

405
00:16:11,100 --> 00:16:13,440
Keys uh bisecting keys I mean the size

406
00:16:13,440 --> 00:16:15,180
of the secret key is independent of the

407
00:16:15,180 --> 00:16:16,800
size of function and the attribute

408
00:16:16,800 --> 00:16:19,380
length supported by this Abe scheme so

409
00:16:19,380 --> 00:16:20,940
these properties let us achieve

410
00:16:20,940 --> 00:16:24,779
optimality in our public Erp scheme

411
00:16:24,779 --> 00:16:27,540
uh for the secret key RP scheme uh we

412
00:16:27,540 --> 00:16:29,639
introduce uh and construct the Primitive

413
00:16:29,639 --> 00:16:31,680
of revocable mixed Fe which I would not

414
00:16:31,680 --> 00:16:34,320
have the time to introduce right now so

415
00:16:34,320 --> 00:16:36,720
uh we construct this revocable mixed Fe

416
00:16:36,720 --> 00:16:40,259
and compile it with a cpab scheme to

417
00:16:40,259 --> 00:16:42,240
achieve our secret key revocable

418
00:16:42,240 --> 00:16:44,759
predicate encryption scheme uh this

419
00:16:44,759 --> 00:16:47,339
revocable MFE in turn is achieved for

420
00:16:47,339 --> 00:16:50,459
multiple other Primitives what I would

421
00:16:50,459 --> 00:16:52,440
like to mention here is how we get

422
00:16:52,440 --> 00:16:55,620
optimal parameter of our secret krp so

423
00:16:55,620 --> 00:16:58,320
here again key policy a b with succinct

424
00:16:58,320 --> 00:17:01,680
keys and ciphertext policy a b with

425
00:17:01,680 --> 00:17:03,540
compact ciphertext

426
00:17:03,540 --> 00:17:07,199
help us in achieving optimal parameters

427
00:17:07,199 --> 00:17:08,459
ah

428
00:17:08,459 --> 00:17:12,179
I would like to summarize our work now

429
00:17:12,179 --> 00:17:14,640
we introduce a unified framework for

430
00:17:14,640 --> 00:17:17,819
achieving secret key and public key

431
00:17:17,819 --> 00:17:19,679
embedded identity broadcast trace and

432
00:17:19,679 --> 00:17:22,140
revoke via the notion of revocable

433
00:17:22,140 --> 00:17:24,780
predicate encryption scheme in the

434
00:17:24,780 --> 00:17:27,000
public traceability we achieve optimal

435
00:17:27,000 --> 00:17:28,919
parameters we achieve embedded

436
00:17:28,919 --> 00:17:30,840
identities and adaptive security by

437
00:17:30,840 --> 00:17:32,760
relying on polynomial hard assumptions

438
00:17:32,760 --> 00:17:34,980
uh one open question that we would like

439
00:17:34,980 --> 00:17:37,020
to pose here is if we can come up with

440
00:17:37,020 --> 00:17:38,700
the construction that is secure in post

441
00:17:38,700 --> 00:17:40,860
Quantum regime using weaker version of

442
00:17:40,860 --> 00:17:43,140
functional encryption

443
00:17:43,140 --> 00:17:45,360
in the secret traceability we achieve

444
00:17:45,360 --> 00:17:47,400
optimal parameters and embedded

445
00:17:47,400 --> 00:17:48,960
identities you relying just on

446
00:17:48,960 --> 00:17:50,820
polynominally hard assumptions

447
00:17:50,820 --> 00:17:52,679
um we do not achieve adaptive Security

448
00:17:52,679 --> 00:17:54,539
in the secret traceability setting and

449
00:17:54,539 --> 00:17:56,780
leave it as an open question

450
00:17:56,780 --> 00:18:00,240
another question could be if we uh we

451
00:18:00,240 --> 00:18:02,700
rely on evasive and tensor lwe which is

452
00:18:02,700 --> 00:18:05,780
used to construct cpab

453
00:18:05,780 --> 00:18:09,360
this was recently constructed by V and

454
00:18:09,360 --> 00:18:12,059
Sabri in their independent works

455
00:18:12,059 --> 00:18:15,480
so ah this primitive sorry it was a

456
00:18:15,480 --> 00:18:17,220
misinformation so this primitive of

457
00:18:17,220 --> 00:18:20,160
evasive and tensor lwe was introduced by

458
00:18:20,160 --> 00:18:22,080
V and Sabri in their independent works

459
00:18:22,080 --> 00:18:24,900
so another open question could be if we

460
00:18:24,900 --> 00:18:26,640
could rely on more standard lattices

461
00:18:26,640 --> 00:18:28,860
assumptions uh to get

462
00:18:28,860 --> 00:18:29,460
um

463
00:18:29,460 --> 00:18:33,059
a construction in secret Trace setting

464
00:18:33,059 --> 00:18:34,440
um I would also like to point out that

465
00:18:34,440 --> 00:18:36,299
ours is the first work to support super

466
00:18:36,299 --> 00:18:39,660
polynomial size revocation list so as

467
00:18:39,660 --> 00:18:41,880
long as we can do this membership

468
00:18:41,880 --> 00:18:44,400
testing efficiently and represent this

469
00:18:44,400 --> 00:18:47,820
super poly revoke list efficiently we

470
00:18:47,820 --> 00:18:50,280
can support it in our Construction

471
00:18:50,280 --> 00:18:52,360
thank you

472
00:18:52,360 --> 00:18:55,530
[Applause]

473
00:18:56,220 --> 00:18:58,679
great so we have time for maybe one

474
00:18:58,679 --> 00:19:00,000
question so if you have a question

475
00:19:00,000 --> 00:19:03,120
please come up to the microphones

476
00:19:03,120 --> 00:19:04,919
so I guess maybe I will start could you

477
00:19:04,919 --> 00:19:07,080
comment on a little bit on where exactly

478
00:19:07,080 --> 00:19:09,419
you need the evasive slash tensor lwe so

479
00:19:09,419 --> 00:19:11,100
what is the exact synchronous property

480
00:19:11,100 --> 00:19:13,020
you need on the underlying Ade schemes

481
00:19:13,020 --> 00:19:16,860
so uh we use the ciphertext policy cpab

482
00:19:16,860 --> 00:19:20,100
to get independence of the revocation

483
00:19:20,100 --> 00:19:22,320
list in that we support in our scheme so

484
00:19:22,320 --> 00:19:24,840
this is why we rely on cpab from the

485
00:19:24,840 --> 00:19:27,539
work of V which has this property which

486
00:19:27,539 --> 00:19:29,760
has this compact site for text so this

487
00:19:29,760 --> 00:19:32,220
is how the and we use this evasive

488
00:19:32,220 --> 00:19:34,799
intensor lwe to get cpab which is how

489
00:19:34,799 --> 00:19:36,900
this evasive intensity comes in picture

490
00:19:36,900 --> 00:19:39,539
I see great are there any other

491
00:19:39,539 --> 00:19:41,840
questions

492
00:19:43,140 --> 00:19:46,650
if not let's think thing rather again

493
00:19:46,650 --> 00:19:49,759
[Applause]

494
00:20:01,640 --> 00:20:04,620
all right so our next talk will be on

495
00:20:04,620 --> 00:20:06,600
Trader tracing with n to the one-third

496
00:20:06,600 --> 00:20:09,900
size ciphertext and order one size keys

497
00:20:09,900 --> 00:20:12,780
from Kalin this is worked by Chun Ching

498
00:20:12,780 --> 00:20:15,720
gong gilo and hotec we NG will be giving

499
00:20:15,720 --> 00:20:18,720
a talk thanks for the introduction

500
00:20:18,720 --> 00:20:19,380
um

501
00:20:19,380 --> 00:20:22,200
so let's jump right into the definitions

502
00:20:22,200 --> 00:20:24,840
uh in trailer tracing

503
00:20:24,840 --> 00:20:26,820
um there's a

504
00:20:26,820 --> 00:20:30,240
there's a broadcast provider who wants

505
00:20:30,240 --> 00:20:32,220
to provide encrypted encrypted broadcast

506
00:20:32,220 --> 00:20:35,580
to multiple subscribers and the worry is

507
00:20:35,580 --> 00:20:37,860
that one of the subscribers might

508
00:20:37,860 --> 00:20:41,880
provide their key or provider key in

509
00:20:41,880 --> 00:20:44,520
in a black box to the

510
00:20:44,520 --> 00:20:48,539
to The Outsiders and and then the the

511
00:20:48,539 --> 00:20:51,960
mitigation from the broadcaster is to be

512
00:20:51,960 --> 00:20:54,539
able to trace

513
00:20:54,539 --> 00:20:57,360
the key that was used in creating this

514
00:20:57,360 --> 00:20:59,460
pirate decoder

515
00:20:59,460 --> 00:21:02,400
and the basic requirement is that you

516
00:21:02,400 --> 00:21:04,860
can find at least one Trader as long as

517
00:21:04,860 --> 00:21:07,380
the decoder breaks semantic security of

518
00:21:07,380 --> 00:21:10,220
the encryption and the

519
00:21:10,220 --> 00:21:13,380
tracing algorithm should never accuse an

520
00:21:13,380 --> 00:21:15,720
innocent user whose key was not using

521
00:21:15,720 --> 00:21:18,720
creating this decoder and moreover this

522
00:21:18,720 --> 00:21:21,000
actually should hold even if arbitrarily

523
00:21:21,000 --> 00:21:23,280
many users collude to construct this

524
00:21:23,280 --> 00:21:26,120
pirate decoder

525
00:21:26,460 --> 00:21:30,059
and the goal of this work or in general

526
00:21:30,059 --> 00:21:32,100
in trailer tracing is to minimize the

527
00:21:32,100 --> 00:21:33,919
communication or storage overhead

528
00:21:33,919 --> 00:21:36,360
meaning that we want to minimize the

529
00:21:36,360 --> 00:21:38,940
size of public Keys secret Keys as well

530
00:21:38,940 --> 00:21:41,960
as the ciphertext size

531
00:21:42,000 --> 00:21:45,539
so more formally the syntax of Trader

532
00:21:45,539 --> 00:21:48,299
phrasing is as follows the key the

533
00:21:48,299 --> 00:21:50,100
generation algorithm will produce the

534
00:21:50,100 --> 00:21:52,980
master uh will produce the public key

535
00:21:52,980 --> 00:21:55,320
and end secret keys and as well as a

536
00:21:55,320 --> 00:21:57,720
tracing key so um here we use our

537
00:21:57,720 --> 00:22:00,960
tracing key because it's private tracing

538
00:22:00,960 --> 00:22:03,240
and then the encryption algorithm will

539
00:22:03,240 --> 00:22:05,400
take as improve the public key and spit

540
00:22:05,400 --> 00:22:08,460
out a ciphertext and uh

541
00:22:08,460 --> 00:22:09,120
um

542
00:22:09,120 --> 00:22:11,340
a key that you will use to actually

543
00:22:11,340 --> 00:22:14,220
encrypt the payload so this syntax is

544
00:22:14,220 --> 00:22:16,919
the cap definition

545
00:22:16,919 --> 00:22:19,260
and the decryption algorithm will use

546
00:22:19,260 --> 00:22:21,179
the public key and one of the secret

547
00:22:21,179 --> 00:22:23,340
keys to decrypt the ciphertext to

548
00:22:23,340 --> 00:22:26,159
recover the encapsulated key and here

549
00:22:26,159 --> 00:22:28,380
it's important that we only uh we

550
00:22:28,380 --> 00:22:30,900
provide the public key for free so that

551
00:22:30,900 --> 00:22:32,940
the secret key size only counts the

552
00:22:32,940 --> 00:22:35,360
truly secret part in the secret key

553
00:22:35,360 --> 00:22:39,419
because many receivers in

554
00:22:39,419 --> 00:22:42,419
in encrypted broadcasts are limited

555
00:22:42,419 --> 00:22:44,340
power devices and we want to minimize

556
00:22:44,340 --> 00:22:47,940
the requirement of secret storage

557
00:22:47,940 --> 00:22:50,059
and then the tracing algorithm

558
00:22:50,059 --> 00:22:55,620
given access to a power decoder using

559
00:22:55,620 --> 00:22:57,780
the public key and the tracing key will

560
00:22:57,780 --> 00:23:02,059
be able to identify a potential Trader

561
00:23:02,159 --> 00:23:06,900
and the security is as for the adversary

562
00:23:06,900 --> 00:23:09,179
first gets the public key and then it

563
00:23:09,179 --> 00:23:11,640
gets to query Securities of arbitrary

564
00:23:11,640 --> 00:23:12,620
users

565
00:23:12,620 --> 00:23:16,080
adaptively and then it will provide a

566
00:23:16,080 --> 00:23:18,918
pirate decoder

567
00:23:18,960 --> 00:23:21,600
um when this power decoder is determined

568
00:23:21,600 --> 00:23:22,799
we can

569
00:23:22,799 --> 00:23:26,280
um we will run the tracing algorithm on

570
00:23:26,280 --> 00:23:28,760
this power decoder to obtain this I star

571
00:23:28,760 --> 00:23:31,740
and we'll also Define this quantity

572
00:23:31,740 --> 00:23:33,419
Epsilon star which is the actual

573
00:23:33,419 --> 00:23:36,780
advantage of the decoder

574
00:23:36,780 --> 00:23:39,840
and then we claim that the adversary

575
00:23:39,840 --> 00:23:43,200
wins if either I is not in one of the

576
00:23:43,200 --> 00:23:47,580
query keys or the bot or the claimed

577
00:23:47,580 --> 00:23:50,460
Advantage is uh at least some threshold

578
00:23:50,460 --> 00:23:54,179
and the identified Tracer is bought so

579
00:23:54,179 --> 00:23:55,919
the first condition just says an honest

580
00:23:55,919 --> 00:23:58,020
user was accused and the second

581
00:23:58,020 --> 00:24:00,480
condition says that the decoder is good

582
00:24:00,480 --> 00:24:03,360
but no Trader was found

583
00:24:03,360 --> 00:24:05,299
and we want this

584
00:24:05,299 --> 00:24:08,280
the probability that the adversary wins

585
00:24:08,280 --> 00:24:11,400
is negligible for all polynomial and and

586
00:24:11,400 --> 00:24:13,799
one over Epsilon where Epsilon is the

587
00:24:13,799 --> 00:24:17,879
threshold of the advantage

588
00:24:18,260 --> 00:24:20,880
and what do we know about trader tracing

589
00:24:20,880 --> 00:24:23,700
schemes we actually know optimal size uh

590
00:24:23,700 --> 00:24:26,520
optimal size Trader trading schemes from

591
00:24:26,520 --> 00:24:29,880
various constructions either from IO or

592
00:24:29,880 --> 00:24:31,320
from lwe

593
00:24:31,320 --> 00:24:34,679
so you might ask what are we here for

594
00:24:34,679 --> 00:24:36,059
um well

595
00:24:36,059 --> 00:24:38,700
first move on to obtaining Trader

596
00:24:38,700 --> 00:24:41,280
tracing from different assumptions and

597
00:24:41,280 --> 00:24:44,340
this is good for the

598
00:24:44,340 --> 00:24:47,039
intellectual joiness because you can

599
00:24:47,039 --> 00:24:49,260
explore different techniques but more

600
00:24:49,260 --> 00:24:50,659
practically

601
00:24:50,659 --> 00:24:53,100
you can also obtain deployment

602
00:24:53,100 --> 00:24:56,280
friendlier constructions in particular

603
00:24:56,280 --> 00:24:58,500
this work will be focused on pairing

604
00:24:58,500 --> 00:25:01,440
based Trader tracing schemes and for

605
00:25:01,440 --> 00:25:03,780
which the library support is better than

606
00:25:03,780 --> 00:25:07,980
LW or IO for which there's no

607
00:25:07,980 --> 00:25:10,700
okay so what do we know from pairing

608
00:25:10,700 --> 00:25:13,679
there are various constructions from

609
00:25:13,679 --> 00:25:15,140
pairing

610
00:25:15,140 --> 00:25:17,039
and

611
00:25:17,039 --> 00:25:19,380
then there's also this recent work by

612
00:25:19,380 --> 00:25:22,919
Gendry which achieved the by far best

613
00:25:22,919 --> 00:25:23,760
um

614
00:25:23,760 --> 00:25:27,559
total size of parameters

615
00:25:29,760 --> 00:25:34,200
uh however all of them have this um very

616
00:25:34,200 --> 00:25:36,720
curious inequality of the product of the

617
00:25:36,720 --> 00:25:40,400
three components are at least n

618
00:25:40,799 --> 00:25:43,679
let me bring you this um trade-off

619
00:25:43,679 --> 00:25:47,039
Simplex proposed by Gendry

620
00:25:47,039 --> 00:25:50,039
um so here this triangle says the three

621
00:25:50,039 --> 00:25:52,440
extremes of public key secretary

622
00:25:52,440 --> 00:25:55,140
ciphertext product being n and the

623
00:25:55,140 --> 00:25:57,659
screen part is what was achieved by

624
00:25:57,659 --> 00:26:00,960
Gentry and prior works

625
00:26:00,960 --> 00:26:03,480
from pairing so the first question we

626
00:26:03,480 --> 00:26:06,059
ask is whether this this particular

627
00:26:06,059 --> 00:26:08,900
point with question mark is achievable

628
00:26:08,900 --> 00:26:10,919
from pairing

629
00:26:10,919 --> 00:26:14,940
and more generally we consider another

630
00:26:14,940 --> 00:26:17,580
Simplex which we in which we allow the

631
00:26:17,580 --> 00:26:20,400
the product to be smaller than n and we

632
00:26:20,400 --> 00:26:22,860
ask whether any of those points below

633
00:26:22,860 --> 00:26:26,700
this triangle is achievable

634
00:26:26,700 --> 00:26:29,419
and our answer to this question is yes

635
00:26:29,419 --> 00:26:33,799
we achieve this point

636
00:26:33,960 --> 00:26:37,320
so in our results the public key size is

637
00:26:37,320 --> 00:26:40,260
cube root of N and the secret key size

638
00:26:40,260 --> 00:26:42,840
is constant and ciphertext size is also

639
00:26:42,840 --> 00:26:45,240
cube root of in

640
00:26:45,240 --> 00:26:47,220
um so compared to

641
00:26:47,220 --> 00:26:49,880
um the schemes by BSW

642
00:26:49,880 --> 00:26:51,960
we achieve

643
00:26:51,960 --> 00:26:55,380
um we we reduce the size of the public

644
00:26:55,380 --> 00:26:58,200
key and the ciphertext

645
00:26:58,200 --> 00:27:01,740
and compared to Gentry we we reduce the

646
00:27:01,740 --> 00:27:04,140
size of secret key and also remove the

647
00:27:04,140 --> 00:27:06,720
use of generic pairing groups

648
00:27:06,720 --> 00:27:10,520
which is a strong assumption

649
00:27:10,860 --> 00:27:14,159
so uh let me quickly recap how usually

650
00:27:14,159 --> 00:27:17,279
Trader tracing is constructed from uh A

651
00:27:17,279 --> 00:27:18,720
Primitive called private linear

652
00:27:18,720 --> 00:27:20,820
broadcast encryption so in private

653
00:27:20,820 --> 00:27:22,880
linear broadcast encryption

654
00:27:22,880 --> 00:27:26,159
each secret key is associated with an

655
00:27:26,159 --> 00:27:29,100
index and each ciphertext is associated

656
00:27:29,100 --> 00:27:32,460
with an index and a message and upon

657
00:27:32,460 --> 00:27:35,640
decryption you learn the message if the

658
00:27:35,640 --> 00:27:38,400
index is greater than well if the key

659
00:27:38,400 --> 00:27:40,260
index is greater than the ciphertext

660
00:27:40,260 --> 00:27:44,360
index and you'll learn nothing otherwise

661
00:27:44,580 --> 00:27:47,220
oh and here I want to mention that both

662
00:27:47,220 --> 00:27:50,580
the index and the message in the in the

663
00:27:50,580 --> 00:27:53,100
ciphertext is hidden

664
00:27:53,100 --> 00:27:56,539
so to construct trailer tracing from plb

665
00:27:56,539 --> 00:28:00,059
you make the plb secret key on the

666
00:28:00,059 --> 00:28:02,460
trader tracing secret key and then a

667
00:28:02,460 --> 00:28:04,620
Trader tracing ciphertext is just a plb

668
00:28:04,620 --> 00:28:07,080
cyber text with index being zero so that

669
00:28:07,080 --> 00:28:10,140
everyone can decrypt

670
00:28:10,140 --> 00:28:13,679
um now to trace you um test the decoder

671
00:28:13,679 --> 00:28:16,140
with various distributions of the

672
00:28:16,140 --> 00:28:19,679
ciphertext namely you change the um this

673
00:28:19,679 --> 00:28:21,960
is what I call the cutoff index in the

674
00:28:21,960 --> 00:28:23,100
ciphertext

675
00:28:23,100 --> 00:28:25,980
and from uh when the when the cutoff

676
00:28:25,980 --> 00:28:29,400
index is zero you get from the premise

677
00:28:29,400 --> 00:28:32,400
of this definition that the advanced

678
00:28:32,400 --> 00:28:35,520
Advantage is at least Epsilon

679
00:28:35,520 --> 00:28:38,340
and when the um

680
00:28:38,340 --> 00:28:42,299
when the index is n you get from the

681
00:28:42,299 --> 00:28:47,220
security of plb that the total Gap is at

682
00:28:47,220 --> 00:28:48,539
least Epsilon

683
00:28:48,539 --> 00:28:50,940
because the advantage will be negligible

684
00:28:50,940 --> 00:28:53,039
at that point

685
00:28:53,039 --> 00:28:57,360
and then you observe whether there's a

686
00:28:57,360 --> 00:29:00,419
big Advantage drop between neighboring

687
00:29:00,419 --> 00:29:02,940
distributions of the Cyber text because

688
00:29:02,940 --> 00:29:07,860
if uh user is honest and the decoder

689
00:29:07,860 --> 00:29:09,659
will not be able to distinguish between

690
00:29:09,659 --> 00:29:12,000
those two distributions of the Cyber

691
00:29:12,000 --> 00:29:13,980
text so the advantage drop will be

692
00:29:13,980 --> 00:29:15,179
negligible

693
00:29:15,179 --> 00:29:18,360
so taking the contrapositive if the drop

694
00:29:18,360 --> 00:29:19,679
is

695
00:29:19,679 --> 00:29:22,200
Omega Epsilon Over N then the user is a

696
00:29:22,200 --> 00:29:24,559
Trader

697
00:29:25,279 --> 00:29:28,440
uh okay now for our work how do we

698
00:29:28,440 --> 00:29:30,960
construct a Trader tracing

699
00:29:30,960 --> 00:29:33,659
um we start with the notion of revocable

700
00:29:33,659 --> 00:29:36,840
plbe for which there are two revocation

701
00:29:36,840 --> 00:29:39,179
mechanisms uh one is the index the other

702
00:29:39,179 --> 00:29:41,880
is the set so the index revocation is

703
00:29:41,880 --> 00:29:44,940
very similar to plb

704
00:29:44,940 --> 00:29:48,059
and the Cellular location is new so the

705
00:29:48,059 --> 00:29:51,779
identity space can be written as N1

706
00:29:51,779 --> 00:29:55,080
times N2 and each secret key is

707
00:29:55,080 --> 00:29:57,179
associated with two indices and each

708
00:29:57,179 --> 00:30:01,320
ciphertext is associated with a the

709
00:30:01,320 --> 00:30:04,140
first portion of the index and also an

710
00:30:04,140 --> 00:30:07,440
additional revocation set and a message

711
00:30:07,440 --> 00:30:11,340
so basically you can decrypt if the um

712
00:30:11,340 --> 00:30:14,580
if this plpe condition is satisfied

713
00:30:14,580 --> 00:30:17,700
and this particular identity is not in

714
00:30:17,700 --> 00:30:19,679
the revocation set otherwise you cannot

715
00:30:19,679 --> 00:30:20,820
decrypt

716
00:30:20,820 --> 00:30:24,360
and we also want hiding for both the

717
00:30:24,360 --> 00:30:28,020
index and the set of revocation

718
00:30:28,020 --> 00:30:30,000
and in particular the following three

719
00:30:30,000 --> 00:30:32,039
properties will be very useful in

720
00:30:32,039 --> 00:30:34,200
devising the um

721
00:30:34,200 --> 00:30:36,179
the trader tracing security of our

722
00:30:36,179 --> 00:30:38,340
scheme one is message hiding which says

723
00:30:38,340 --> 00:30:41,039
if you revoke all the keys uh maybe just

724
00:30:41,039 --> 00:30:44,820
by index then the um the Cyber text will

725
00:30:44,820 --> 00:30:46,860
hide the message

726
00:30:46,860 --> 00:30:49,799
and then the index hiding says that if

727
00:30:49,799 --> 00:30:54,059
you increase the cutoff index by one and

728
00:30:54,059 --> 00:30:56,220
you actually don't have any key that

729
00:30:56,220 --> 00:30:58,460
will distinguish

730
00:30:58,460 --> 00:31:00,840
these two kinds of ciphertext by the

731
00:31:00,840 --> 00:31:03,360
decryption result then they're

732
00:31:03,360 --> 00:31:07,020
indistinguishable and also set hiding if

733
00:31:07,020 --> 00:31:08,520
you have the same index and the same

734
00:31:08,520 --> 00:31:11,419
message but you don't have any key that

735
00:31:11,419 --> 00:31:14,279
distinguishes the ciphertext by the

736
00:31:14,279 --> 00:31:15,620
decryption result

737
00:31:15,620 --> 00:31:18,899
then you also get indistinguishable

738
00:31:18,899 --> 00:31:21,620
ciphertexts

739
00:31:22,140 --> 00:31:25,799
okay and then we show that from such a

740
00:31:25,799 --> 00:31:28,559
prb such a revocable pob we have a

741
00:31:28,559 --> 00:31:31,320
Trader tracing scheme for N1 times N2

742
00:31:31,320 --> 00:31:33,360
users

743
00:31:33,360 --> 00:31:36,720
and the tracing tracing strategy is very

744
00:31:36,720 --> 00:31:40,100
similar to the version in January

745
00:31:40,100 --> 00:31:44,100
basically to find the index the first

746
00:31:44,100 --> 00:31:46,140
portion of index of the trader you use

747
00:31:46,140 --> 00:31:49,320
the index hiding and to find the second

748
00:31:49,320 --> 00:31:53,000
portion you use the set hiding approach

749
00:31:53,039 --> 00:31:55,559
and in particular our construction of

750
00:31:55,559 --> 00:31:58,320
revocable plb has this power exercise

751
00:31:58,320 --> 00:32:01,080
the public key is square root of N1 plus

752
00:32:01,080 --> 00:32:04,020
N2 and the secret key is constant size

753
00:32:04,020 --> 00:32:07,799
and if we set N1 to be on

754
00:32:07,799 --> 00:32:11,640
n to the two-thirds and N2 to uh to cube

755
00:32:11,640 --> 00:32:13,260
root of n then we get the optimal

756
00:32:13,260 --> 00:32:16,799
balancing achieving the um the claimed

757
00:32:16,799 --> 00:32:19,460
efficiency

758
00:32:20,279 --> 00:32:24,899
and actually in order to implement those

759
00:32:24,899 --> 00:32:28,440
things from pairing we relax the notion

760
00:32:28,440 --> 00:32:31,440
of plb security a little bit and the

761
00:32:31,440 --> 00:32:33,360
first relaxation is that encryption

762
00:32:33,360 --> 00:32:36,179
encryption to any non-empty revocation

763
00:32:36,179 --> 00:32:38,840
set requires using the master secret key

764
00:32:38,840 --> 00:32:42,659
therefore the tracing is only secret key

765
00:32:42,659 --> 00:32:43,799
tracing

766
00:32:43,799 --> 00:32:46,820
the second relax relaxation is that

767
00:32:46,820 --> 00:32:49,620
encryption to actually non-empty

768
00:32:49,620 --> 00:32:54,199
revocation set is adversely dependent

769
00:32:55,380 --> 00:33:00,899
and our implementation of the revoke

770
00:33:00,899 --> 00:33:04,320
revocable plb is by combining plb and

771
00:33:04,320 --> 00:33:08,100
threshold broadcast in in January so the

772
00:33:08,100 --> 00:33:10,620
functionality is basically that in each

773
00:33:10,620 --> 00:33:13,080
secret key you also have a random string

774
00:33:13,080 --> 00:33:16,440
U and in each ciphertext you have a lot

775
00:33:16,440 --> 00:33:19,080
of random strings you will pick one of

776
00:33:19,080 --> 00:33:21,600
them and computer Hemingways to

777
00:33:21,600 --> 00:33:24,539
determine whether you can decrypt or not

778
00:33:24,539 --> 00:33:27,240
and the interesting thing here is that

779
00:33:27,240 --> 00:33:29,700
there's no need to hide R's in the

780
00:33:29,700 --> 00:33:32,960
secret in the ciphertext

781
00:33:33,779 --> 00:33:36,960
and this brings us to the next level of

782
00:33:36,960 --> 00:33:38,580
abstraction of attribute based

783
00:33:38,580 --> 00:33:40,980
functional encryption so in

784
00:33:40,980 --> 00:33:42,659
attribute-based functional encryption we

785
00:33:42,659 --> 00:33:45,360
have the secret key associated with a

786
00:33:45,360 --> 00:33:47,700
function and a predicate and the

787
00:33:47,700 --> 00:33:49,740
ciphertext is associated with an

788
00:33:49,740 --> 00:33:52,200
attribute and an input and you can

789
00:33:52,200 --> 00:33:54,120
decrypt to the function evaluation

790
00:33:54,120 --> 00:33:57,120
result if and only if the predicate

791
00:33:57,120 --> 00:33:59,640
evaluates to one

792
00:33:59,640 --> 00:34:01,919
and this can be obtained by combining

793
00:34:01,919 --> 00:34:03,899
pairing based functional encryption and

794
00:34:03,899 --> 00:34:06,059
attribute-based encryption techniques in

795
00:34:06,059 --> 00:34:08,339
particular we combine quadratic

796
00:34:08,339 --> 00:34:10,859
functional encryption and the so-called

797
00:34:10,859 --> 00:34:15,179
dual system Abe to obtain the hours our

798
00:34:15,179 --> 00:34:18,740
revocable plb scheme

799
00:34:19,560 --> 00:34:20,159
um

800
00:34:20,159 --> 00:34:24,119
now let me explain uh why the like the

801
00:34:24,119 --> 00:34:25,980
the component size coming from the

802
00:34:25,980 --> 00:34:28,760
functional encryption is square root

803
00:34:28,760 --> 00:34:32,040
this follows from uh functional

804
00:34:32,040 --> 00:34:35,179
encryption for quadratic functions by we

805
00:34:35,179 --> 00:34:38,879
and it has

806
00:34:38,879 --> 00:34:41,280
basically a linear size public key and

807
00:34:41,280 --> 00:34:44,159
ciphertext and constant size secret keys

808
00:34:44,159 --> 00:34:47,760
and then by using a reduction from BCF

809
00:34:47,760 --> 00:34:51,300
g17 we can construct a pob from qf

810
00:34:51,300 --> 00:34:53,219
basically you

811
00:34:53,219 --> 00:34:53,760
um

812
00:34:53,760 --> 00:34:57,119
make anyone you identify and one the set

813
00:34:57,119 --> 00:35:00,480
of one two and one as the product of n

814
00:35:00,480 --> 00:35:02,520
times n and then you use one hot

815
00:35:02,520 --> 00:35:04,920
encoding to determine who can recover

816
00:35:04,920 --> 00:35:07,500
the message or not

817
00:35:07,500 --> 00:35:11,760
and for the other part Abe part

818
00:35:11,760 --> 00:35:13,200
um

819
00:35:13,200 --> 00:35:15,660
the interesting part is how we achieve

820
00:35:15,660 --> 00:35:17,579
constant size secret key

821
00:35:17,579 --> 00:35:23,220
so um here we construct our scheme for

822
00:35:23,220 --> 00:35:26,480
read ones local read ones

823
00:35:26,480 --> 00:35:29,339
monotone spam program so read one is

824
00:35:29,339 --> 00:35:31,920
monotone program is just linear sacred

825
00:35:31,920 --> 00:35:35,280
sharing such that each party has at most

826
00:35:35,280 --> 00:35:36,599
one share

827
00:35:36,599 --> 00:35:41,820
and a local Ro MSP is such that only of

828
00:35:41,820 --> 00:35:46,079
only a few parties have a share at all

829
00:35:46,079 --> 00:35:49,140
and in in the ab the security is roughly

830
00:35:49,140 --> 00:35:51,000
encryptions of the possible shares

831
00:35:51,000 --> 00:35:54,240
therefore the size of the secret key is

832
00:35:54,240 --> 00:35:56,640
proportional to the locality and it

833
00:35:56,640 --> 00:35:58,980
turns out that to implement threshold

834
00:35:58,980 --> 00:36:01,800
broadcast Lambda local Ro MSP is

835
00:36:01,800 --> 00:36:04,400
sufficient

836
00:36:04,500 --> 00:36:08,460
and last I want to mention that we need

837
00:36:08,460 --> 00:36:11,339
adaptive security for X the attribute

838
00:36:11,339 --> 00:36:13,440
part but we only need selective security

839
00:36:13,440 --> 00:36:17,760
for Z part and this uh this actually

840
00:36:17,760 --> 00:36:20,280
requires a careful implementation of the

841
00:36:20,280 --> 00:36:23,520
hybrids the challenge is basically in in

842
00:36:23,520 --> 00:36:26,579
the definition of abfe you cannot

843
00:36:26,579 --> 00:36:29,280
predict P of X because P of X can be

844
00:36:29,280 --> 00:36:33,000
zero one and if P of X is one then the

845
00:36:33,000 --> 00:36:36,420
part coming from Abu will be difficult

846
00:36:36,420 --> 00:36:38,900
to hand

847
00:36:39,839 --> 00:36:43,380
and then the solution is to realize that

848
00:36:43,380 --> 00:36:46,380
there's no difficulty if the

849
00:36:46,380 --> 00:36:48,960
basically you you can because the Z part

850
00:36:48,960 --> 00:36:51,599
is selective you already know when P of

851
00:36:51,599 --> 00:36:56,160
X is zero uh it's when the function

852
00:36:56,160 --> 00:36:58,879
disagree

853
00:36:59,400 --> 00:37:01,619
okay and let me end my talk with the

854
00:37:01,619 --> 00:37:03,839
open questions uh the first question is

855
00:37:03,839 --> 00:37:05,880
the product correct measure of

856
00:37:05,880 --> 00:37:08,460
trade-offs for pairing if so can we

857
00:37:08,460 --> 00:37:10,800
rebalance among the public key security

858
00:37:10,800 --> 00:37:13,260
and ciphertext to achieve into the let's

859
00:37:13,260 --> 00:37:16,440
say two over nine size components for

860
00:37:16,440 --> 00:37:18,300
all of them

861
00:37:18,300 --> 00:37:21,000
and the second is how far can parents go

862
00:37:21,000 --> 00:37:24,260
can we actually achieve

863
00:37:25,280 --> 00:37:29,820
sub cubic root with constant size key

864
00:37:29,820 --> 00:37:32,760
and can we achieve such parameter sizes

865
00:37:32,760 --> 00:37:34,920
for broadcast and Trace or public

866
00:37:34,920 --> 00:37:36,540
tracing

867
00:37:36,540 --> 00:37:40,290
and with that Ln meta thank you

868
00:37:40,290 --> 00:37:44,400
[Applause]

869
00:37:44,400 --> 00:37:46,320
great we have time for a couple

870
00:37:46,320 --> 00:37:48,300
questions so if you have one please come

871
00:37:48,300 --> 00:37:51,079
up to the podium

872
00:37:52,440 --> 00:37:54,540
so I'll start with one so I think at the

873
00:37:54,540 --> 00:37:56,339
beginning of the talk you pointed out

874
00:37:56,339 --> 00:37:58,680
that in xandry they conjectured that the

875
00:37:58,680 --> 00:38:00,420
product of the secret key size

876
00:38:00,420 --> 00:38:02,760
ciphertext size and public key size is

877
00:38:02,760 --> 00:38:04,680
one and you show that that was not true

878
00:38:04,680 --> 00:38:06,000
do you have a conjecture for whether

879
00:38:06,000 --> 00:38:08,160
there is some Bound in the pairing-based

880
00:38:08,160 --> 00:38:09,660
world like if you had a conjecture what

881
00:38:09,660 --> 00:38:12,720
would you say the bound would be if any

882
00:38:12,720 --> 00:38:14,880
um I would say that there's no such

883
00:38:14,880 --> 00:38:18,540
bound unless you can prove it using like

884
00:38:18,540 --> 00:38:20,099
a black box

885
00:38:20,099 --> 00:38:22,560
separation techniques okay example

886
00:38:22,560 --> 00:38:24,780
because like the the new developments

887
00:38:24,780 --> 00:38:28,500
just challenges our intuition greatly

888
00:38:28,500 --> 00:38:30,000
great so in principle we can get

889
00:38:30,000 --> 00:38:31,859
constant for all three

890
00:38:31,859 --> 00:38:35,040
uh hopefully in a few years okay

891
00:38:35,040 --> 00:38:38,240
great other questions

892
00:38:39,119 --> 00:38:42,310
if not let's thank G again

893
00:38:42,310 --> 00:38:45,599
[Applause]

894
00:38:45,599 --> 00:38:47,760
all right so I think now we have a track

895
00:38:47,760 --> 00:38:49,380
switch break so we'll resume in 10

896
00:38:49,380 --> 00:38:50,700
minutes so let's thank all of the

897
00:38:50,700 --> 00:38:52,200
speakers both of the speakers in the

898
00:38:52,200 --> 00:38:54,980
trader tracing session

