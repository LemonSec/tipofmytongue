1
00:00:00,000 --> 00:00:02,879
encryption session

2
00:00:02,879 --> 00:00:06,560
the the first talk is

3
00:00:06,560 --> 00:00:09,420
strapping with small Evolution keys and

4
00:00:09,420 --> 00:00:11,760
applications to to threshold morphic

5
00:00:11,760 --> 00:00:13,019
encryption

6
00:00:13,019 --> 00:00:17,179
by junguli Daniel Mission

7
00:00:21,560 --> 00:00:25,698
will give the talk

8
00:00:28,740 --> 00:00:32,040
okay so um well thank you for the

9
00:00:32,040 --> 00:00:34,579
introduction and this is a great

10
00:00:34,579 --> 00:00:38,280
pleasure and pressure to be speaking at

11
00:00:38,280 --> 00:00:40,559
your crypt the first talk in the first

12
00:00:40,559 --> 00:00:42,180
session on the first day train number

13
00:00:42,180 --> 00:00:44,219
one but

14
00:00:44,219 --> 00:00:46,860
um let me try my best today I'm going to

15
00:00:46,860 --> 00:00:48,960
tell you about our paper entitled

16
00:00:48,960 --> 00:00:52,980
efficient fhw bootstrapping with small

17
00:00:52,980 --> 00:00:55,199
evaluation keys and application to

18
00:00:55,199 --> 00:00:57,600
Serious old home encryption this is a

19
00:00:57,600 --> 00:01:02,280
joint work with visanchio Kim on you and

20
00:01:02,280 --> 00:01:04,460
myself

21
00:01:04,979 --> 00:01:08,220
uh here's the outline and after a brief

22
00:01:08,220 --> 00:01:11,220
preliminaries I will tell you about our

23
00:01:11,220 --> 00:01:13,320
new plant rotation technique and then

24
00:01:13,320 --> 00:01:15,240
the analysis and implementation will be

25
00:01:15,240 --> 00:01:17,700
given after then we will see how to

26
00:01:17,700 --> 00:01:20,400
design the efficient fhw like threshold

27
00:01:20,400 --> 00:01:23,580
home encryption using our bootstrapping

28
00:01:23,580 --> 00:01:25,439
preliminaries

29
00:01:25,439 --> 00:01:28,619
two-time essential first proposed fhw

30
00:01:28,619 --> 00:01:30,900
scheme and after that there has been a

31
00:01:30,900 --> 00:01:32,759
series of work improving it and using

32
00:01:32,759 --> 00:01:34,860
the beautiful idea inside

33
00:01:34,860 --> 00:01:37,619
fhw like Skins are the best known bit

34
00:01:37,619 --> 00:01:40,259
level home encryption it has small

35
00:01:40,259 --> 00:01:42,479
parameter size and its bootstrapping is

36
00:01:42,479 --> 00:01:44,280
super fast

37
00:01:44,280 --> 00:01:45,920
there are two competing approaches

38
00:01:45,920 --> 00:01:48,720
bootstrapping it first one is called AP

39
00:01:48,720 --> 00:01:52,740
or also known as fhw or DM it supports

40
00:01:52,740 --> 00:01:55,740
arbitrary Secrets but it has large boot

41
00:01:55,740 --> 00:01:56,880
surfing case size

42
00:01:56,880 --> 00:01:58,860
and the other one is jinx named after

43
00:01:58,860 --> 00:02:01,799
comma at all also known as tfhe or cgl

44
00:02:01,799 --> 00:02:04,920
approach and it supports limited

45
00:02:04,920 --> 00:02:07,320
security distribution but it has more

46
00:02:07,320 --> 00:02:09,720
bootstrapping key size and quite

47
00:02:09,720 --> 00:02:11,400
efficient

48
00:02:11,400 --> 00:02:13,140
in this talk we propose the third

49
00:02:13,140 --> 00:02:15,360
bootstrapping offering the pastel both

50
00:02:15,360 --> 00:02:18,959
AP engines means that our technique

51
00:02:18,959 --> 00:02:22,140
naturally supports arbitrary secrets and

52
00:02:22,140 --> 00:02:24,120
it has smooth shipping key size at the

53
00:02:24,120 --> 00:02:25,620
same time

54
00:02:25,620 --> 00:02:28,620
as an additional benefit it has smaller

55
00:02:28,620 --> 00:02:29,819
noise girls

56
00:02:29,819 --> 00:02:33,720
and we can design efficient fhw lectures

57
00:02:33,720 --> 00:02:36,180
to move encryption because it supports

58
00:02:36,180 --> 00:02:38,580
arbitrary secret and it has simple key

59
00:02:38,580 --> 00:02:40,440
structure

60
00:02:40,440 --> 00:02:42,420
and the source code is also available at

61
00:02:42,420 --> 00:02:44,640
openfhg

62
00:02:44,640 --> 00:02:46,800
this is a brief sketch of fhw

63
00:02:46,800 --> 00:02:49,620
bootstrapping in fhw the input is

64
00:02:49,620 --> 00:02:52,319
audibly cyber text and to perform a

65
00:02:52,319 --> 00:02:54,840
binary gate using those two input out of

66
00:02:54,840 --> 00:02:57,420
the inputs we first add them up and and

67
00:02:57,420 --> 00:02:59,580
then the decryption on the added

68
00:02:59,580 --> 00:03:02,220
ciphertext is performed inside on RW

69
00:03:02,220 --> 00:03:04,739
cyber text and the decryption is done in

70
00:03:04,739 --> 00:03:06,720
the exponent here

71
00:03:06,720 --> 00:03:10,500
and then we extract one value encrypted

72
00:03:10,500 --> 00:03:14,099
in Adobe and to fit the parameters we do

73
00:03:14,099 --> 00:03:16,800
some more switching and key switchings

74
00:03:16,800 --> 00:03:19,920
here's the definition of plantation the

75
00:03:19,920 --> 00:03:23,940
input of line rotation is f and on LW

76
00:03:23,940 --> 00:03:27,599
cyber text the output is RW of f times x

77
00:03:27,599 --> 00:03:30,620
to the this green thing beta plus r plus

78
00:03:30,620 --> 00:03:33,780
this is a decryption of LW input

79
00:03:33,780 --> 00:03:36,720
ciphertext and this is the core part of

80
00:03:36,720 --> 00:03:39,060
fhw like bootstrapping

81
00:03:39,060 --> 00:03:41,519
and I'd like to note that the constant

82
00:03:41,519 --> 00:03:44,040
term of this F times something is f

83
00:03:44,040 --> 00:03:46,739
minus U and where U is the decrypted

84
00:03:46,739 --> 00:03:49,500
value of LW I'll be actually doing

85
00:03:49,500 --> 00:03:52,560
rotation we are actually rotating the

86
00:03:52,560 --> 00:03:55,500
equivalent of f without the knowledge of

87
00:03:55,500 --> 00:03:59,220
U so we call it blind notation

88
00:03:59,220 --> 00:04:01,980
uh usage of line rotation is not just

89
00:04:01,980 --> 00:04:04,440
limited to the bootstrapping of fhw like

90
00:04:04,440 --> 00:04:07,440
home encryption it is widely used in

91
00:04:07,440 --> 00:04:09,140
area of Home encryption for

92
00:04:09,140 --> 00:04:11,220
non-artheismatic operations for example

93
00:04:11,220 --> 00:04:12,599
we can use it for some machine learning

94
00:04:12,599 --> 00:04:16,560
algorithms or accurate sine function can

95
00:04:16,560 --> 00:04:18,779
be performed using Plantation

96
00:04:18,779 --> 00:04:21,238
and then a totally new approach of

97
00:04:21,238 --> 00:04:24,120
bootstrapping cks bgb pfp has been

98
00:04:24,120 --> 00:04:27,300
proposed using player rotation too

99
00:04:27,300 --> 00:04:30,000
obvious rjsw encryption as a building

100
00:04:30,000 --> 00:04:33,060
block of plant rotation as you can see

101
00:04:33,060 --> 00:04:36,240
in this equation when M2 is small the

102
00:04:36,240 --> 00:04:38,820
error E1 is not multiplied

103
00:04:38,820 --> 00:04:42,960
and let's see that multiplying monomial

104
00:04:42,960 --> 00:04:46,800
x to the K is equal to adding K in the

105
00:04:46,800 --> 00:04:48,300
exponent

106
00:04:48,300 --> 00:04:51,360
so we use it to add a partial

107
00:04:51,360 --> 00:04:53,220
information of secret key to the

108
00:04:53,220 --> 00:04:55,440
exponent again and again

109
00:04:55,440 --> 00:04:58,440
but as we only have addition in the

110
00:04:58,440 --> 00:05:01,199
exponent we need some workarounds for

111
00:05:01,199 --> 00:05:05,160
example in AP we decompose RPI and we

112
00:05:05,160 --> 00:05:07,919
need many rjsw key for all the possible

113
00:05:07,919 --> 00:05:10,320
decomposition of R Plus

114
00:05:10,320 --> 00:05:14,280
in genes we decompose s i instead and we

115
00:05:14,280 --> 00:05:17,040
can control the distribution of s i for

116
00:05:17,040 --> 00:05:19,800
efficient algorithm design but the

117
00:05:19,800 --> 00:05:23,340
distribution of s i is somehow Limited

118
00:05:23,340 --> 00:05:25,259
we propose another blind rotation

119
00:05:25,259 --> 00:05:27,479
algorithm without such workaround

120
00:05:27,479 --> 00:05:29,699
by introducing another building block in

121
00:05:29,699 --> 00:05:32,180
automation

122
00:05:33,180 --> 00:05:35,340
this ring automotism to perform constant

123
00:05:35,340 --> 00:05:37,860
multiplication on the exponent

124
00:05:37,860 --> 00:05:41,460
here's the definition of evaluative T it

125
00:05:41,460 --> 00:05:44,220
takes two inputs amount of V of M and an

126
00:05:44,220 --> 00:05:46,860
automation key AK and the result should

127
00:05:46,860 --> 00:05:51,060
be rwz of MX T and it inverse one case

128
00:05:51,060 --> 00:05:52,740
region

129
00:05:52,740 --> 00:05:54,010
let's see how we use

130
00:05:54,010 --> 00:05:55,259
[Music]

131
00:05:55,259 --> 00:05:57,600
we are given an initial cyber text of

132
00:05:57,600 --> 00:06:00,479
rwf prime something and then we can add

133
00:06:00,479 --> 00:06:03,479
s i to the exponent by performing rgsw

134
00:06:03,479 --> 00:06:05,100
multiplication

135
00:06:05,100 --> 00:06:09,300
and then we do the evil Auto by Alpha I

136
00:06:09,300 --> 00:06:12,360
we can multiply Alpha I to the exponent

137
00:06:12,360 --> 00:06:16,320
and by taking some proper F Prime we

138
00:06:16,320 --> 00:06:19,139
have F times x to the r Pi SI by

139
00:06:19,139 --> 00:06:20,759
repeating this process we can perform

140
00:06:20,759 --> 00:06:23,940
the decryption of outer base hypertext

141
00:06:23,940 --> 00:06:25,740
in the exponent which is plantation

142
00:06:25,740 --> 00:06:27,300
right

143
00:06:27,300 --> 00:06:30,360
so here's the toy example Alpha is given

144
00:06:30,360 --> 00:06:34,620
as 525 5m1 we have some initial cyber

145
00:06:34,620 --> 00:06:37,199
text at Prime and then we multiply x to

146
00:06:37,199 --> 00:06:39,120
the s i

147
00:06:39,120 --> 00:06:43,139
and then we perform either Auto by 5.

148
00:06:43,139 --> 00:06:46,080
and then we add s0 and S2 again using

149
00:06:46,080 --> 00:06:47,819
our just w

150
00:06:47,819 --> 00:06:50,160
and then we multiply 5 again

151
00:06:50,160 --> 00:06:52,440
and then we can see that as 0 and S2 is

152
00:06:52,440 --> 00:06:55,319
multiplied by 5 and S1 is multiplied by

153
00:06:55,319 --> 00:07:00,060
25 and finally we can add S3 and the

154
00:07:00,060 --> 00:07:02,580
inner product is done in the exponent

155
00:07:02,580 --> 00:07:05,880
and we can perform x to the beta

156
00:07:05,880 --> 00:07:08,819
and the decryption is done

157
00:07:08,819 --> 00:07:11,400
in this two example we can see that we

158
00:07:11,400 --> 00:07:14,520
used R justw of x to DSi to add s i in

159
00:07:14,520 --> 00:07:18,120
the exponent and we did Eva Auto for

160
00:07:18,120 --> 00:07:21,060
constant multiplication

161
00:07:21,060 --> 00:07:23,819
things to note is that we only need one

162
00:07:23,819 --> 00:07:27,360
Auto represent key ak5 because 1 5 and

163
00:07:27,360 --> 00:07:30,300
25 are all powers of 5.

164
00:07:30,300 --> 00:07:32,340
we can actually extend it to the full

165
00:07:32,340 --> 00:07:35,039
presentation it is well known then 5n

166
00:07:35,039 --> 00:07:38,280
minus 1 generates G Twin Star we don't

167
00:07:38,280 --> 00:07:39,900
have to use five and minus we can use

168
00:07:39,900 --> 00:07:42,539
other generator anyway

169
00:07:42,539 --> 00:07:46,020
so we only need automation key for AKG

170
00:07:46,020 --> 00:07:48,479
and AK minus one so we need constant

171
00:07:48,479 --> 00:07:51,599
number of automation Keys only

172
00:07:51,599 --> 00:07:54,060
and the total computation will be n

173
00:07:54,060 --> 00:07:57,900
multiplication of rjsw and at most n

174
00:07:57,900 --> 00:08:00,479
evil autos

175
00:08:00,479 --> 00:08:03,060
so um let me explain the core algorithm

176
00:08:03,060 --> 00:08:06,360
we Define a set of indices I sub L plus

177
00:08:06,360 --> 00:08:10,259
as the set of indexes where Alpha I is g

178
00:08:10,259 --> 00:08:13,560
to the L and we Define I sub L minus

179
00:08:13,560 --> 00:08:16,440
similarly to their set of indexes

180
00:08:16,440 --> 00:08:19,139
and then using the fact that g has

181
00:08:19,139 --> 00:08:22,199
degree n over 2 we can decompose the

182
00:08:22,199 --> 00:08:24,960
inner product of R pi and S as given

183
00:08:24,960 --> 00:08:26,520
here

184
00:08:26,520 --> 00:08:29,940
you can see that in the equation right

185
00:08:29,940 --> 00:08:32,520
hand side there is only addition and

186
00:08:32,520 --> 00:08:34,799
constant G and minus one no other

187
00:08:34,799 --> 00:08:37,500
constant appears in this equation

188
00:08:37,500 --> 00:08:40,320
so we can perform it using automotism by

189
00:08:40,320 --> 00:08:42,240
GM minus one only

190
00:08:42,240 --> 00:08:44,540
so for a given

191
00:08:44,540 --> 00:08:47,600
cypertext initial ciphertext we can add

192
00:08:47,600 --> 00:08:52,580
all the sjs J in isof and over 2 minus 1

193
00:08:52,580 --> 00:08:56,700
and then we multiply G by equal to G

194
00:08:56,700 --> 00:08:59,880
and then we again multiply

195
00:08:59,880 --> 00:09:03,600
JS and I sub n minus one and N over two

196
00:09:03,600 --> 00:09:06,600
minus two and then we multiply G again

197
00:09:06,600 --> 00:09:09,779
by repeating this process we are doing

198
00:09:09,779 --> 00:09:11,459
the decoration

199
00:09:11,459 --> 00:09:13,500
so you can find the full algorithm in

200
00:09:13,500 --> 00:09:14,940
the paper

201
00:09:14,940 --> 00:09:18,180
uh as you might catch

202
00:09:18,180 --> 00:09:19,860
there's a limitation

203
00:09:19,860 --> 00:09:22,500
the automobile exists only for old

204
00:09:22,500 --> 00:09:23,640
numbers

205
00:09:23,640 --> 00:09:25,980
so Alpha I should be old but it's not

206
00:09:25,980 --> 00:09:27,600
because it's a cyber text it

207
00:09:27,600 --> 00:09:30,300
distribution randomly so we propose

208
00:09:30,300 --> 00:09:32,519
several variants but um let me explain

209
00:09:32,519 --> 00:09:34,700
just one of it we call Round to Old

210
00:09:34,700 --> 00:09:37,980
recalling the fhw bootstrapping at the

211
00:09:37,980 --> 00:09:40,560
end we perform both switching bull

212
00:09:40,560 --> 00:09:42,720
switching is just rescaling the

213
00:09:42,720 --> 00:09:44,940
ciphertext and Performing surrounding

214
00:09:44,940 --> 00:09:47,820
operation instead of normal rounding we

215
00:09:47,820 --> 00:09:50,279
do round to old very round to Old finds

216
00:09:50,279 --> 00:09:52,380
the nearest Old integer

217
00:09:52,380 --> 00:09:55,019
by doing this process Alpha I and beta

218
00:09:55,019 --> 00:09:56,779
beta doesn't have to be old but anyway

219
00:09:56,779 --> 00:10:00,540
arpa will be all over the parliament

220
00:10:00,540 --> 00:10:03,060
and there is another optimization using

221
00:10:03,060 --> 00:10:06,660
multiple automation Keys assume that I

222
00:10:06,660 --> 00:10:09,899
sub L is empty it actually happens very

223
00:10:09,899 --> 00:10:12,660
often in rare cases and in this case

224
00:10:12,660 --> 00:10:16,680
once we add all the sjs in J in ISO L

225
00:10:16,680 --> 00:10:18,899
plus one we perform either Auto and we

226
00:10:18,899 --> 00:10:23,220
have to multiply J's x to the SJ where J

227
00:10:23,220 --> 00:10:25,860
is in I sub L but there is nothing so we

228
00:10:25,860 --> 00:10:27,540
have nothing to do and we perform two

229
00:10:27,540 --> 00:10:30,600
consecutive automobiles by G

230
00:10:30,600 --> 00:10:33,180
instead if we have automation by g-scare

231
00:10:33,180 --> 00:10:35,940
we can reduce it into one automobile by

232
00:10:35,940 --> 00:10:37,320
G Square

233
00:10:37,320 --> 00:10:42,060
here is a graph of performance

234
00:10:42,060 --> 00:10:43,980
following two number of electronics and

235
00:10:43,980 --> 00:10:46,320
keys and we can see that by using small

236
00:10:46,320 --> 00:10:49,620
constant number like 6 or 10 it

237
00:10:49,620 --> 00:10:52,200
outperforms existing algorithms it is

238
00:10:52,200 --> 00:10:55,680
even faster than binary genes

239
00:10:55,680 --> 00:10:57,600
here's the analysis and implementation

240
00:10:57,600 --> 00:11:00,839
here's a brief analysis about key and

241
00:11:00,839 --> 00:11:02,100
number of multiplication for

242
00:11:02,100 --> 00:11:03,899
bootstrapping and the error growth

243
00:11:03,899 --> 00:11:07,260
normalized and you can see that uh

244
00:11:07,260 --> 00:11:11,220
the best of previous approach is binary

245
00:11:11,220 --> 00:11:14,100
genes where U is equal to one and we can

246
00:11:14,100 --> 00:11:16,560
see the Dominate term and number of keys

247
00:11:16,560 --> 00:11:18,060
are similar here and the number of

248
00:11:18,060 --> 00:11:19,980
multiplication is also similar but we

249
00:11:19,980 --> 00:11:22,260
have smaller error girls

250
00:11:22,260 --> 00:11:25,079
and I think this slice is the most

251
00:11:25,079 --> 00:11:27,240
interesting part in this talk

252
00:11:27,240 --> 00:11:30,060
uh that we actually improved efficiency

253
00:11:30,060 --> 00:11:32,820
using calcium Secrets I in-home

254
00:11:32,820 --> 00:11:35,519
encryption it is very usual to use small

255
00:11:35,519 --> 00:11:38,459
keys for efficiency even though it has

256
00:11:38,459 --> 00:11:41,459
weaker backgrounds for security for

257
00:11:41,459 --> 00:11:46,140
example in Jinx we use binary key and in

258
00:11:46,140 --> 00:11:48,720
CK chaos we even use par secret for

259
00:11:48,720 --> 00:11:51,180
better bootstrapping or small error

260
00:11:51,180 --> 00:11:54,360
girls but by using gaussian secret here

261
00:11:54,360 --> 00:11:56,820
you can reduce the degree of autopry

262
00:11:56,820 --> 00:12:01,320
cyber text from 517 to 450 which

263
00:12:01,320 --> 00:12:04,079
directly affects its performance

264
00:12:04,079 --> 00:12:06,180
and we tried our best to find the new

265
00:12:06,180 --> 00:12:09,320
parameter for each skin with the

266
00:12:09,320 --> 00:12:11,180
with the

267
00:12:11,180 --> 00:12:14,220
newest version of LW estimator

268
00:12:14,220 --> 00:12:16,320
latest estimator and then you can see

269
00:12:16,320 --> 00:12:18,060
that we achieved

270
00:12:18,060 --> 00:12:22,160
runtime and key size the fastest

271
00:12:22,380 --> 00:12:24,779
so here is how the design fhw likes

272
00:12:24,779 --> 00:12:26,700
result home encryption scheme

273
00:12:26,700 --> 00:12:28,860
threshold home encryption scheme is a

274
00:12:28,860 --> 00:12:31,260
more compelling motivation to use larger

275
00:12:31,260 --> 00:12:32,459
secrets

276
00:12:32,459 --> 00:12:35,579
uh interesting the secret key is

277
00:12:35,579 --> 00:12:37,500
distributed among

278
00:12:37,500 --> 00:12:40,079
participants and the description is done

279
00:12:40,079 --> 00:12:42,779
collaboratively

280
00:12:42,779 --> 00:12:45,740
so let's say J is the set of

281
00:12:45,740 --> 00:12:49,500
participants and each of them generates

282
00:12:49,500 --> 00:12:52,260
SJ and DJ their own secret key

283
00:12:52,260 --> 00:12:54,899
this can be small but the common secret

284
00:12:54,899 --> 00:12:59,399
key should be the sum of sjs and ZJ and

285
00:12:59,399 --> 00:13:01,500
so as it is the summation of it we

286
00:13:01,500 --> 00:13:04,260
cannot make G star or a star

287
00:13:04,260 --> 00:13:07,200
maximum so we need the bootstrapping for

288
00:13:07,200 --> 00:13:09,300
larger secrets

289
00:13:09,300 --> 00:13:11,880
we can't make public even though nobody

290
00:13:11,880 --> 00:13:14,399
knows that G star or estar by using

291
00:13:14,399 --> 00:13:17,459
common reverse string and by generating

292
00:13:17,459 --> 00:13:20,459
BJ by party J summing up the BJ will

293
00:13:20,459 --> 00:13:22,139
give us the public key

294
00:13:22,139 --> 00:13:24,360
as we have public key each party can

295
00:13:24,360 --> 00:13:27,240
make an encryption of the any value they

296
00:13:27,240 --> 00:13:28,200
want

297
00:13:28,200 --> 00:13:29,579
so um

298
00:13:29,579 --> 00:13:34,260
party J generates rwe Prime of gjx to

299
00:13:34,260 --> 00:13:36,120
Decay and then it is sent to the

300
00:13:36,120 --> 00:13:37,860
Computing party and the Computing party

301
00:13:37,860 --> 00:13:40,019
is some of the key and then it will be

302
00:13:40,019 --> 00:13:43,800
RW Prime key of G star of under secret

303
00:13:43,800 --> 00:13:46,320
kg star and the message is G Star Extra

304
00:13:46,320 --> 00:13:49,339
Decay which can be used as automobile

305
00:13:49,339 --> 00:13:51,600
by K

306
00:13:51,600 --> 00:13:55,200
and then we also need rjsw key and the

307
00:13:55,200 --> 00:13:57,779
difference here from the previous slide

308
00:13:57,779 --> 00:14:01,019
is that the addition of sji should be

309
00:14:01,019 --> 00:14:02,579
done in the exponent

310
00:14:02,579 --> 00:14:04,680
so we need to use our system

311
00:14:04,680 --> 00:14:07,079
multiplication not the addition we have

312
00:14:07,079 --> 00:14:09,720
to use the product of cyber text

313
00:14:09,720 --> 00:14:12,660
so party J generates the encryption our

314
00:14:12,660 --> 00:14:16,019
jsw x to the sji and it is sent to the

315
00:14:16,019 --> 00:14:17,880
Computing party and the Computing party

316
00:14:17,880 --> 00:14:21,899
finds a product of the kids and it will

317
00:14:21,899 --> 00:14:25,680
be x to the star I so now we have all

318
00:14:25,680 --> 00:14:28,500
keys required for our bootstrapping so

319
00:14:28,500 --> 00:14:32,100
we have x to the s i rjsw key and we

320
00:14:32,100 --> 00:14:35,339
have Automotion key for G and minus 1.

321
00:14:35,339 --> 00:14:37,500
so we can make a few like stressful home

322
00:14:37,500 --> 00:14:40,040
encryption

323
00:14:40,199 --> 00:14:43,260
conclusion we proposed a new blind

324
00:14:43,260 --> 00:14:45,420
mutation technique which offers the best

325
00:14:45,420 --> 00:14:47,339
of AP and genes

326
00:14:47,339 --> 00:14:50,699
and we provided several variants in the

327
00:14:50,699 --> 00:14:51,959
paper

328
00:14:51,959 --> 00:14:56,420
and due to its simple key structure and

329
00:14:56,420 --> 00:14:59,459
as it provides the larger secrets we can

330
00:14:59,459 --> 00:15:01,440
design threshold home encryption using

331
00:15:01,440 --> 00:15:03,779
based on fhw

332
00:15:03,779 --> 00:15:05,940
it would be very interesting to apply

333
00:15:05,940 --> 00:15:08,220
our skin to other structures like entry

334
00:15:08,220 --> 00:15:11,120
water experience known as finer and cafe

335
00:15:11,120 --> 00:15:13,920
and I think it is also very important

336
00:15:13,920 --> 00:15:16,260
future work improving the vegetable

337
00:15:16,260 --> 00:15:19,260
stripping using our technique

338
00:15:19,260 --> 00:15:21,540
those are references

339
00:15:21,540 --> 00:15:25,339
thank you for your attention thank you

340
00:15:29,519 --> 00:15:32,660
so any questions

341
00:15:37,920 --> 00:15:41,100
so I have one question have you tried to

342
00:15:41,100 --> 00:15:43,560
to use your Technique to your improve

343
00:15:43,560 --> 00:15:46,440
bootstrapping for the ckks scheme for

344
00:15:46,440 --> 00:15:48,180
the bootstrapping of the modular

345
00:15:48,180 --> 00:15:49,620
reduction

346
00:15:49,620 --> 00:15:55,560
uh yes uh for the classical question was

347
00:15:55,560 --> 00:15:57,360
if we can improve the CK gas

348
00:15:57,360 --> 00:15:59,779
bootstrapping using this technique and

349
00:15:59,779 --> 00:16:04,199
for the usual classical we do not use

350
00:16:04,199 --> 00:16:06,240
blank rotation for it but there is a

351
00:16:06,240 --> 00:16:08,959
method uh performing ckks bootstrapping

352
00:16:08,959 --> 00:16:11,579
with plant rotation for that maybe we

353
00:16:11,579 --> 00:16:15,600
can apply this but um so far the classic

354
00:16:15,600 --> 00:16:17,220
currency kick is bootstrapping is way

355
00:16:17,220 --> 00:16:19,500
efficient than using player rotation so

356
00:16:19,500 --> 00:16:21,360
maybe it's not a good idea but we can do

357
00:16:21,360 --> 00:16:22,800
it

358
00:16:22,800 --> 00:16:25,339
thank you

359
00:16:26,220 --> 00:16:27,779
no questions

360
00:16:27,779 --> 00:16:29,490
so let's find the the speaker again

361
00:16:29,490 --> 00:16:37,970
[Applause]

362
00:16:51,360 --> 00:16:54,000
so the next tool is on polynomial

363
00:16:54,000 --> 00:16:56,519
functions modulo p2e and first double

364
00:16:56,519 --> 00:16:58,920
strapping to for homomorphic encryption

365
00:16:58,920 --> 00:17:01,500
by Robin Dylan Ilya

366
00:17:01,500 --> 00:17:03,800
is

367
00:17:05,240 --> 00:17:07,559
Rubin will give the torque

368
00:17:07,559 --> 00:17:10,020
thank you for the introduction

369
00:17:10,020 --> 00:17:12,959
so hi everyone my name is Robin hiela

370
00:17:12,959 --> 00:17:14,579
and I will present our work on

371
00:17:14,579 --> 00:17:17,160
polynomial functions modulo P to the e

372
00:17:17,160 --> 00:17:19,199
and its application to faster

373
00:17:19,199 --> 00:17:21,839
bootstrapping for homomorphic encryption

374
00:17:21,839 --> 00:17:24,299
so this is indeed a joint work with Ilya

375
00:17:24,299 --> 00:17:27,439
je and free

376
00:17:27,480 --> 00:17:29,760
so fully homomorphic encryption as in

377
00:17:29,760 --> 00:17:31,500
the previous stock is a crypto system

378
00:17:31,500 --> 00:17:32,880
that allows us to compute certain

379
00:17:32,880 --> 00:17:35,700
operations over the ciphertech space

380
00:17:35,700 --> 00:17:38,220
given an encryption of a number a and a

381
00:17:38,220 --> 00:17:41,039
number B we can compute an encryption of

382
00:17:41,039 --> 00:17:43,440
their sum and their product

383
00:17:43,440 --> 00:17:46,140
for the bgv and the BFE scheme which are

384
00:17:46,140 --> 00:17:48,419
the two schemes considered here these

385
00:17:48,419 --> 00:17:50,220
operations are computed over the

386
00:17:50,220 --> 00:17:52,380
integers mod b to the e

387
00:17:52,380 --> 00:17:54,539
where we will assume that b is a prime

388
00:17:54,539 --> 00:17:57,840
number and e is a positive integer so

389
00:17:57,840 --> 00:17:59,880
basically we will be working modular

390
00:17:59,880 --> 00:18:02,460
power of a prime number

391
00:18:02,460 --> 00:18:04,559
more complicated functions than just

392
00:18:04,559 --> 00:18:06,780
than this are typically evaluated by

393
00:18:06,780 --> 00:18:10,039
writing them as a polynomial

394
00:18:10,799 --> 00:18:13,440
all fhe schemes that we have today are

395
00:18:13,440 --> 00:18:15,240
based on lattice cryptography which

396
00:18:15,240 --> 00:18:18,120
means that ciphertexts are noisy this

397
00:18:18,120 --> 00:18:19,740
noise will grow with the homomorphic

398
00:18:19,740 --> 00:18:21,860
operations that we apply

399
00:18:21,860 --> 00:18:24,660
so you can see on the slide that the

400
00:18:24,660 --> 00:18:26,820
noise of the output ciphertext shown in

401
00:18:26,820 --> 00:18:28,860
yellow will be larger than the noise of

402
00:18:28,860 --> 00:18:31,919
the input ciphertext

403
00:18:31,919 --> 00:18:34,200
fortunately there exists this operation

404
00:18:34,200 --> 00:18:36,120
that can reduce the noise and this is

405
00:18:36,120 --> 00:18:39,439
what we call bootstrapping

406
00:18:40,080 --> 00:18:42,539
for the bgv and the BFE scheme

407
00:18:42,539 --> 00:18:44,460
bootstrapping consists of two main

408
00:18:44,460 --> 00:18:46,260
components which are called linear

409
00:18:46,260 --> 00:18:48,240
Transformations and the digit removal

410
00:18:48,240 --> 00:18:49,740
procedure

411
00:18:49,740 --> 00:18:52,260
however for practical parameter sets the

412
00:18:52,260 --> 00:18:54,720
digit removal procedure can be 3 to 50

413
00:18:54,720 --> 00:18:56,580
times more expensive than the linear

414
00:18:56,580 --> 00:18:59,160
Transformations and is therefore the two

415
00:18:59,160 --> 00:19:00,539
bottleneck

416
00:19:00,539 --> 00:19:02,520
so if you want to improve bootstrapping

417
00:19:02,520 --> 00:19:04,200
we should really focus on this digit

418
00:19:04,200 --> 00:19:06,120
removal step

419
00:19:06,120 --> 00:19:08,640
and internally digit removal also

420
00:19:08,640 --> 00:19:10,500
consists of a series of polynomial

421
00:19:10,500 --> 00:19:11,880
evaluations

422
00:19:11,880 --> 00:19:13,919
so yeah we can see that it is quite

423
00:19:13,919 --> 00:19:16,320
important to have a draw understanding

424
00:19:16,320 --> 00:19:18,539
of the properties of these polyfox these

425
00:19:18,539 --> 00:19:21,500
polynomial functions

426
00:19:21,840 --> 00:19:23,700
now I will introduce some of the

427
00:19:23,700 --> 00:19:25,799
required terminology

428
00:19:25,799 --> 00:19:28,380
we say that a function from the integers

429
00:19:28,380 --> 00:19:31,320
mod P to the E to itself is a polynomial

430
00:19:31,320 --> 00:19:34,380
function of poly function for short

431
00:19:34,380 --> 00:19:36,780
if it can be expressed as a polynomial

432
00:19:36,780 --> 00:19:38,940
with integer coefficients

433
00:19:38,940 --> 00:19:40,919
we call the polynomial itself a

434
00:19:40,919 --> 00:19:43,500
representation of the function

435
00:19:43,500 --> 00:19:45,600
during the stock we will always follow

436
00:19:45,600 --> 00:19:47,460
the convention of writing a function

437
00:19:47,460 --> 00:19:49,919
with lowercase letters and a polynomial

438
00:19:49,919 --> 00:19:52,980
with the corresponding uppercase letter

439
00:19:52,980 --> 00:19:55,220
foreign

440
00:19:56,059 --> 00:19:58,559
then we are actually working over a

441
00:19:58,559 --> 00:19:59,340
field

442
00:19:59,340 --> 00:20:01,440
and it is possible to show that every

443
00:20:01,440 --> 00:20:03,600
function is a poly function

444
00:20:03,600 --> 00:20:05,940
moreover the lowest degree

445
00:20:05,940 --> 00:20:08,460
representation will be unique and can

446
00:20:08,460 --> 00:20:10,440
simply be obtained via the interpolation

447
00:20:10,440 --> 00:20:12,240
methods

448
00:20:12,240 --> 00:20:14,700
however if e is greater than one then we

449
00:20:14,700 --> 00:20:16,679
are not working over the fields and the

450
00:20:16,679 --> 00:20:20,100
inverse properties of are true

451
00:20:20,100 --> 00:20:22,500
now the second case is greater than one

452
00:20:22,500 --> 00:20:24,299
is mathematically the most interesting

453
00:20:24,299 --> 00:20:26,820
one and also what we will focus on for

454
00:20:26,820 --> 00:20:29,700
the rest of the talk

455
00:20:29,700 --> 00:20:31,679
therefore the first objective of our

456
00:20:31,679 --> 00:20:33,780
work is to perform a systematic study of

457
00:20:33,780 --> 00:20:36,000
these poly functions and especially in

458
00:20:36,000 --> 00:20:37,919
the non-trivial case where e is greater

459
00:20:37,919 --> 00:20:39,240
than one

460
00:20:39,240 --> 00:20:41,580
we will try to answer questions such as

461
00:20:41,580 --> 00:20:43,679
how can we determine whether a given

462
00:20:43,679 --> 00:20:45,780
function is a poly function

463
00:20:45,780 --> 00:20:48,480
given a poly function how can we obtain

464
00:20:48,480 --> 00:20:50,280
a representation of it

465
00:20:50,280 --> 00:20:52,980
and also how to find fhe friendly

466
00:20:52,980 --> 00:20:54,539
representations

467
00:20:54,539 --> 00:20:57,240
with this we mean less noise growth and

468
00:20:57,240 --> 00:20:59,460
fewer scalar and non-scalar

469
00:20:59,460 --> 00:21:02,820
multiplications to evaluate it

470
00:21:02,820 --> 00:21:05,340
a second objective is then showing how

471
00:21:05,340 --> 00:21:07,679
to accelerate bootstrapping for the bgv

472
00:21:07,679 --> 00:21:11,240
and the bfv scheme

473
00:21:11,580 --> 00:21:14,460
okay so the digit removal procedure

474
00:21:14,460 --> 00:21:17,100
inside bootstrapping is built from a

475
00:21:17,100 --> 00:21:19,020
very simple function which we will call

476
00:21:19,020 --> 00:21:21,179
the digit extraction function

477
00:21:21,179 --> 00:21:23,460
and we will write it as G subscript e

478
00:21:23,460 --> 00:21:25,080
for this presentation

479
00:21:25,080 --> 00:21:27,840
digit extraction takes as inputs an

480
00:21:27,840 --> 00:21:30,360
e-digit number as shown by the colored

481
00:21:30,360 --> 00:21:32,100
squares on the slide

482
00:21:32,100 --> 00:21:34,260
and also the output is an e digit number

483
00:21:34,260 --> 00:21:36,840
where the least significant digit is the

484
00:21:36,840 --> 00:21:39,419
same as the input and all other digits

485
00:21:39,419 --> 00:21:41,460
are equal to zero

486
00:21:41,460 --> 00:21:43,559
so it's really extracting the least

487
00:21:43,559 --> 00:21:46,440
significant digits

488
00:21:46,440 --> 00:21:48,480
it has already been shown previously

489
00:21:48,480 --> 00:21:51,900
that digit extraction is a poly function

490
00:21:51,900 --> 00:21:54,240
and that exists at all ad hoc methods to

491
00:21:54,240 --> 00:21:56,760
obtain representations

492
00:21:56,760 --> 00:21:59,760
for example for p is equal to 2 and E is

493
00:21:59,760 --> 00:22:01,020
equal to 8

494
00:22:01,020 --> 00:22:02,880
allevi and Troop perform repeated

495
00:22:02,880 --> 00:22:04,799
squaring and find a very simple

496
00:22:04,799 --> 00:22:08,580
representation of degree 2 to the seven

497
00:22:08,580 --> 00:22:11,700
later Channel optimized the polynomial

498
00:22:11,700 --> 00:22:15,059
of a levian Shoop and finds a degree 8

499
00:22:15,059 --> 00:22:17,658
polynomial

500
00:22:17,820 --> 00:22:19,440
now how is it possible that two

501
00:22:19,440 --> 00:22:21,539
different polynomials evaluate the same

502
00:22:21,539 --> 00:22:24,539
function well this can only be true if

503
00:22:24,539 --> 00:22:25,740
the difference between these two

504
00:22:25,740 --> 00:22:28,260
polynomials evaluates to zero and every

505
00:22:28,260 --> 00:22:29,460
point

506
00:22:29,460 --> 00:22:31,860
such a polynomial is what we call a null

507
00:22:31,860 --> 00:22:34,459
polynomial

508
00:22:34,559 --> 00:22:36,780
in other words we say that a polynomial

509
00:22:36,780 --> 00:22:39,780
o of X is a null polynomial if it

510
00:22:39,780 --> 00:22:42,539
evaluates the zero function mod P to the

511
00:22:42,539 --> 00:22:44,039
e

512
00:22:44,039 --> 00:22:46,380
then the main observation from our work

513
00:22:46,380 --> 00:22:48,419
is that if we start from any

514
00:22:48,419 --> 00:22:51,240
representation of Digit extraction for

515
00:22:51,240 --> 00:22:53,940
example a levy Shoop or gen hum

516
00:22:53,940 --> 00:22:55,919
and if we add such a null polynomial

517
00:22:55,919 --> 00:22:58,260
then we are basically changing the

518
00:22:58,260 --> 00:22:59,760
polynomial itself

519
00:22:59,760 --> 00:23:02,039
without changing the function that we

520
00:23:02,039 --> 00:23:04,440
evaluate

521
00:23:04,440 --> 00:23:06,299
or in other words we can obtain

522
00:23:06,299 --> 00:23:08,460
equivalent representations of the same

523
00:23:08,460 --> 00:23:11,039
function by adding such a null

524
00:23:11,039 --> 00:23:12,480
polynomial

525
00:23:12,480 --> 00:23:15,059
this will allow us to select from these

526
00:23:15,059 --> 00:23:17,400
equivalent representations and fhe

527
00:23:17,400 --> 00:23:19,740
friendly one instead of just a random

528
00:23:19,740 --> 00:23:21,659
one

529
00:23:21,659 --> 00:23:23,700
now an interesting question which I will

530
00:23:23,700 --> 00:23:26,400
address next is how can we find these

531
00:23:26,400 --> 00:23:29,159
null polynomials

532
00:23:29,159 --> 00:23:31,799
and it turns out that again for e is

533
00:23:31,799 --> 00:23:34,620
equal to 1 this is a bit simple in that

534
00:23:34,620 --> 00:23:36,960
case we can just follow thermostatal

535
00:23:36,960 --> 00:23:39,780
theorem which states that x to the B

536
00:23:39,780 --> 00:23:42,240
minus X and all of its multiples are

537
00:23:42,240 --> 00:23:45,120
null polynomials

538
00:23:45,120 --> 00:23:47,580
it is a bit more complicated for e is

539
00:23:47,580 --> 00:23:48,960
greater than one

540
00:23:48,960 --> 00:23:51,000
in that case we need to define the

541
00:23:51,000 --> 00:23:53,280
so-called falling factorial polynomials

542
00:23:53,280 --> 00:23:55,740
which are basically just products of

543
00:23:55,740 --> 00:23:58,380
successive linear factors

544
00:23:58,380 --> 00:24:00,419
and we observe that evaluating such a

545
00:24:00,419 --> 00:24:03,240
polynomial at any integer will give us a

546
00:24:03,240 --> 00:24:07,520
result which is divisible by I factorial

547
00:24:07,860 --> 00:24:10,320
therefore if I factorial is divisible by

548
00:24:10,320 --> 00:24:12,960
P to the E then our polynomial will

549
00:24:12,960 --> 00:24:14,640
already be a null polynomial

550
00:24:14,640 --> 00:24:16,860
automatically

551
00:24:16,860 --> 00:24:18,840
on the other hand if this is not the

552
00:24:18,840 --> 00:24:21,000
case if I factorial is not divisible by

553
00:24:21,000 --> 00:24:23,820
P to the E then we need to multiply our

554
00:24:23,820 --> 00:24:26,760
polynomial by an appropriate power of B

555
00:24:26,760 --> 00:24:28,980
and only then we will obtain a null

556
00:24:28,980 --> 00:24:30,900
polynomial

557
00:24:30,900 --> 00:24:32,520
and it has already been proven and

558
00:24:32,520 --> 00:24:35,220
mathematical works that all null

559
00:24:35,220 --> 00:24:37,200
polynomials are in fact linear

560
00:24:37,200 --> 00:24:41,000
combinations of these two options

561
00:24:41,700 --> 00:24:43,620
now I will say something about the

562
00:24:43,620 --> 00:24:45,900
lowest Decay representation for poly

563
00:24:45,900 --> 00:24:47,220
functions

564
00:24:47,220 --> 00:24:50,640
and for this slide let o of X be a

565
00:24:50,640 --> 00:24:52,440
monoch null polynomial of the lowest

566
00:24:52,440 --> 00:24:54,240
degree

567
00:24:54,240 --> 00:24:56,940
then what we can do starting from any

568
00:24:56,940 --> 00:25:00,780
representation GE of Digit extraction

569
00:25:00,780 --> 00:25:04,080
we can apply euclidean division by this

570
00:25:04,080 --> 00:25:06,360
monoch null polynomial

571
00:25:06,360 --> 00:25:08,340
this will give us some remainder GE

572
00:25:08,340 --> 00:25:09,480
Prime

573
00:25:09,480 --> 00:25:11,760
which is guaranteed to represent the

574
00:25:11,760 --> 00:25:14,220
same function as GE so also the digit

575
00:25:14,220 --> 00:25:16,140
extraction function

576
00:25:16,140 --> 00:25:18,960
however our commander will always have a

577
00:25:18,960 --> 00:25:22,080
degree Which is less than b times e

578
00:25:22,080 --> 00:25:24,779
therefore B times e is really an upper

579
00:25:24,779 --> 00:25:26,760
bound on the degree of the polynomials

580
00:25:26,760 --> 00:25:29,779
which we should expect

581
00:25:30,240 --> 00:25:32,659
going back to the channel representation

582
00:25:32,659 --> 00:25:35,400
well it turns out that the polynomial

583
00:25:35,400 --> 00:25:38,039
already has minimal degree

584
00:25:38,039 --> 00:25:40,260
however this is not yet the end of the

585
00:25:40,260 --> 00:25:42,419
story since we can still search for even

586
00:25:42,419 --> 00:25:44,760
better representations in terms of

587
00:25:44,760 --> 00:25:48,679
scalar and non-scalar multiplications

588
00:25:49,500 --> 00:25:51,720
our first Improvement observes that

589
00:25:51,720 --> 00:25:54,120
digit extraction is in fact a symmetric

590
00:25:54,120 --> 00:25:57,000
function namely an even function when p

591
00:25:57,000 --> 00:25:59,400
is2 and an odd function and B is greater

592
00:25:59,400 --> 00:26:01,559
than two

593
00:26:01,559 --> 00:26:03,240
this allows us to choose a

594
00:26:03,240 --> 00:26:05,520
representation with either only even or

595
00:26:05,520 --> 00:26:07,440
odd exponent terms

596
00:26:07,440 --> 00:26:09,419
for example in the case b is greater

597
00:26:09,419 --> 00:26:11,820
than 2 we can evaluate the very simple

598
00:26:11,820 --> 00:26:14,760
formula from the slide which will cancel

599
00:26:14,760 --> 00:26:17,880
out the even exponent terms

600
00:26:17,880 --> 00:26:20,220
the case b is equal to 2 is a bit more

601
00:26:20,220 --> 00:26:22,380
complicated since we cannot directly

602
00:26:22,380 --> 00:26:24,900
divide by two in that case and we simply

603
00:26:24,900 --> 00:26:28,440
refer to the paper for more details

604
00:26:28,440 --> 00:26:30,720
compared to channel hum we save a factor

605
00:26:30,720 --> 00:26:32,640
of square root 2 and non-scalar

606
00:26:32,640 --> 00:26:34,980
multiplications and a vector of 2 in

607
00:26:34,980 --> 00:26:38,059
scalar multiplications

608
00:26:38,700 --> 00:26:40,679
our second Improvement is based on a

609
00:26:40,679 --> 00:26:42,299
lattice structure

610
00:26:42,299 --> 00:26:44,100
here the idea is to interpret

611
00:26:44,100 --> 00:26:46,919
polynomials as coefficient factors and

612
00:26:46,919 --> 00:26:49,080
in doing so we observe that the set of

613
00:26:49,080 --> 00:26:51,360
all null polynomials of a certain degree

614
00:26:51,360 --> 00:26:54,059
bound actually forms a lattice

615
00:26:54,059 --> 00:26:56,400
this is visualized on the slide for a

616
00:26:56,400 --> 00:26:58,380
two-dimensional lattice formed by the

617
00:26:58,380 --> 00:27:01,140
black dots so each of these black dots

618
00:27:01,140 --> 00:27:03,419
is a null polynomial

619
00:27:03,419 --> 00:27:05,220
then again starting from any

620
00:27:05,220 --> 00:27:07,620
representation GE of the digit

621
00:27:07,620 --> 00:27:09,179
extraction function

622
00:27:09,179 --> 00:27:11,100
we can solve the closest Factor problem

623
00:27:11,100 --> 00:27:12,840
on this lattice

624
00:27:12,840 --> 00:27:14,400
this will give us the closest null

625
00:27:14,400 --> 00:27:15,779
polynomial

626
00:27:15,779 --> 00:27:17,940
and we observe that if we compute the

627
00:27:17,940 --> 00:27:20,279
difference between GE and its closest

628
00:27:20,279 --> 00:27:21,720
null polynomial

629
00:27:21,720 --> 00:27:23,520
then we will obtain an equivalent

630
00:27:23,520 --> 00:27:25,679
representation with with significantly

631
00:27:25,679 --> 00:27:28,919
smaller coefficients

632
00:27:28,919 --> 00:27:31,440
coming back to our example so we already

633
00:27:31,440 --> 00:27:33,600
know that Jan and Han find a degree

634
00:27:33,600 --> 00:27:35,340
eight polynomial

635
00:27:35,340 --> 00:27:36,840
applying our first and second

636
00:27:36,840 --> 00:27:39,600
Improvement to their polynomial also

637
00:27:39,600 --> 00:27:42,480
gives us a degree 8 representation

638
00:27:42,480 --> 00:27:46,200
however our polynomial has a much

639
00:27:46,200 --> 00:27:49,100
smaller coefficients and also only even

640
00:27:49,100 --> 00:27:51,240
exponent terms

641
00:27:51,240 --> 00:27:53,460
and this will allow for a more efficient

642
00:27:53,460 --> 00:27:57,140
evaluation with less noise

643
00:27:58,260 --> 00:28:00,120
our third Improvement is a function

644
00:28:00,120 --> 00:28:01,980
composition approach and it works

645
00:28:01,980 --> 00:28:04,919
especially well for larger values of E

646
00:28:04,919 --> 00:28:07,440
here the idea is to decompose digital

647
00:28:07,440 --> 00:28:10,620
extraction into two steps

648
00:28:10,620 --> 00:28:12,659
in the first step we pick some parameter

649
00:28:12,659 --> 00:28:15,179
e Prime Which is less than e

650
00:28:15,179 --> 00:28:17,520
and you will already compute digit

651
00:28:17,520 --> 00:28:20,640
extraction with parameter e Prime

652
00:28:20,640 --> 00:28:23,340
after this first step as you can see the

653
00:28:23,340 --> 00:28:25,620
result will already be correct in the E

654
00:28:25,620 --> 00:28:27,840
Prime least significant digits

655
00:28:27,840 --> 00:28:29,940
but the upper digits will still contain

656
00:28:29,940 --> 00:28:32,460
garbage

657
00:28:32,460 --> 00:28:34,740
then in the second step we will evaluate

658
00:28:34,740 --> 00:28:36,779
another function to also remove the

659
00:28:36,779 --> 00:28:38,880
upper digits

660
00:28:38,880 --> 00:28:41,460
now the main observation here from the

661
00:28:41,460 --> 00:28:43,980
slide is that the relevant domain of the

662
00:28:43,980 --> 00:28:46,559
second step is only equal to the range

663
00:28:46,559 --> 00:28:48,419
of the first step

664
00:28:48,419 --> 00:28:50,520
but this range of the first step is

665
00:28:50,520 --> 00:28:52,860
going to be a very small subset of the

666
00:28:52,860 --> 00:28:55,919
integers mod b to the e

667
00:28:55,919 --> 00:28:57,779
and this Insight will allow us to

668
00:28:57,779 --> 00:28:59,460
alleviate the definition of null

669
00:28:59,460 --> 00:29:02,100
polynomials and the sense that we now

670
00:29:02,100 --> 00:29:04,860
only require that our null polynomials

671
00:29:04,860 --> 00:29:07,500
evaluated to zero over this restricted

672
00:29:07,500 --> 00:29:09,000
range

673
00:29:09,000 --> 00:29:10,740
and this will give us many monal

674
00:29:10,740 --> 00:29:13,620
polynomials in the general case

675
00:29:13,620 --> 00:29:15,659
these external polynomials can then be

676
00:29:15,659 --> 00:29:17,640
exploited to optimize the digit

677
00:29:17,640 --> 00:29:20,159
extraction function even further simply

678
00:29:20,159 --> 00:29:23,580
by repeating all previous strings

679
00:29:23,580 --> 00:29:25,500
compared to channel hum we bring down

680
00:29:25,500 --> 00:29:27,299
the number of non-scalar multiplications

681
00:29:27,299 --> 00:29:30,419
from square root e to fourth root of E

682
00:29:30,419 --> 00:29:32,220
and the number of scalar multiplications

683
00:29:32,220 --> 00:29:34,620
from E to square root e

684
00:29:34,620 --> 00:29:37,740
however this also comes at an extra cost

685
00:29:37,740 --> 00:29:39,659
and the total degree of digital

686
00:29:39,659 --> 00:29:41,520
extraction will increase with roughly

687
00:29:41,520 --> 00:29:43,020
effector of B

688
00:29:43,020 --> 00:29:44,760
so you can really see it as a trade-off

689
00:29:44,760 --> 00:29:47,580
between execution time and total

690
00:29:47,580 --> 00:29:50,460
polynomial degree

691
00:29:50,460 --> 00:29:52,919
I will give another example assume that

692
00:29:52,919 --> 00:29:55,380
you want to compute digit extraction mod

693
00:29:55,380 --> 00:29:57,539
2 to the 25.

694
00:29:57,539 --> 00:29:59,460
in the first step we could already

695
00:29:59,460 --> 00:30:02,880
compute the result mod 2 to the 8 using

696
00:30:02,880 --> 00:30:06,240
the polynomial we already found earlier

697
00:30:06,240 --> 00:30:08,159
then in the second step we can start

698
00:30:08,159 --> 00:30:10,080
from the result of the first step and

699
00:30:10,080 --> 00:30:12,659
evaluate another polynomial to complete

700
00:30:12,659 --> 00:30:14,640
the computation

701
00:30:14,640 --> 00:30:17,640
note that our second polynomial has very

702
00:30:17,640 --> 00:30:20,880
small degree only equal to 5. and very

703
00:30:20,880 --> 00:30:23,520
small coefficients compared to 2 to the

704
00:30:23,520 --> 00:30:26,159
25.

705
00:30:26,159 --> 00:30:28,559
having discussed all optimizations for

706
00:30:28,559 --> 00:30:31,080
digit extraction let's go to the digit

707
00:30:31,080 --> 00:30:33,120
removal procedure

708
00:30:33,120 --> 00:30:35,340
also here we start from an e-digit

709
00:30:35,340 --> 00:30:37,559
number and this time our goal is to

710
00:30:37,559 --> 00:30:41,720
remove the V least significant ones

711
00:30:42,059 --> 00:30:44,220
and this is done by extracting these

712
00:30:44,220 --> 00:30:46,140
fairly significant digits all separately

713
00:30:46,140 --> 00:30:50,100
using the digit extraction function

714
00:30:50,100 --> 00:30:52,260
however besides from extracting these

715
00:30:52,260 --> 00:30:54,240
fairly significant digits we also need

716
00:30:54,240 --> 00:30:56,640
to compute the same digits with a lower

717
00:30:56,640 --> 00:30:58,919
value of the position as shown at the

718
00:30:58,919 --> 00:31:00,419
bottom of the slide

719
00:31:00,419 --> 00:31:02,880
now in theory you can just substitute

720
00:31:02,880 --> 00:31:04,860
these numbers at the bottom by the one

721
00:31:04,860 --> 00:31:07,500
at the top when in practice this is not

722
00:31:07,500 --> 00:31:10,140
so clever because the ones at the bottom

723
00:31:10,140 --> 00:31:11,940
can be computed with lower degree

724
00:31:11,940 --> 00:31:14,659
polynomials

725
00:31:14,940 --> 00:31:16,500
our approach for dealing with this

726
00:31:16,500 --> 00:31:18,360
problem differs from the previous ones

727
00:31:18,360 --> 00:31:19,919
in three aspects

728
00:31:19,919 --> 00:31:22,380
first of all we only use our optimized

729
00:31:22,380 --> 00:31:23,940
polynomials

730
00:31:23,940 --> 00:31:26,460
secondly we try to reuse polynomial

731
00:31:26,460 --> 00:31:29,220
evaluations as much as possible without

732
00:31:29,220 --> 00:31:31,559
increasing the degree of the Chen Han

733
00:31:31,559 --> 00:31:32,760
version

734
00:31:32,760 --> 00:31:35,899
thirdly we evaluate multiple polynomials

735
00:31:35,899 --> 00:31:38,279
simultaneously in the same point using

736
00:31:38,279 --> 00:31:42,000
the baby step giant step technique

737
00:31:42,000 --> 00:31:43,919
to show the benefits of our method we

738
00:31:43,919 --> 00:31:45,720
have implemented it in the he-lab

739
00:31:45,720 --> 00:31:46,679
library

740
00:31:46,679 --> 00:31:48,600
this slide shows some experimental

741
00:31:48,600 --> 00:31:49,980
results

742
00:31:49,980 --> 00:31:52,799
so as you can see the speed up depends a

743
00:31:52,799 --> 00:31:54,960
bit on the parameter set but in general

744
00:31:54,960 --> 00:31:56,760
we were able to achieve a decent speed

745
00:31:56,760 --> 00:31:59,220
up of one and a half up to two and a

746
00:31:59,220 --> 00:32:00,600
half times

747
00:32:00,600 --> 00:32:02,880
for example in the First Column where we

748
00:32:02,880 --> 00:32:04,980
consider plain text space a power of two

749
00:32:04,980 --> 00:32:07,500
we bring down the total execution time

750
00:32:07,500 --> 00:32:10,080
from more than 2000 seconds to less than

751
00:32:10,080 --> 00:32:12,860
900 seconds

752
00:32:13,020 --> 00:32:15,120
we have also implemented our function

753
00:32:15,120 --> 00:32:17,279
composition approach and tested it for

754
00:32:17,279 --> 00:32:19,860
some higher values of e for example e is

755
00:32:19,860 --> 00:32:23,940
59 and E is 37 in the slide

756
00:32:23,940 --> 00:32:26,760
and as you can see from the slides by

757
00:32:26,760 --> 00:32:28,320
applying function composition we can

758
00:32:28,320 --> 00:32:31,679
even get a much larger speed up for

759
00:32:31,679 --> 00:32:34,320
these parameter sets for example 2.8

760
00:32:34,320 --> 00:32:37,080
times versus 1.8 times so the left

761
00:32:37,080 --> 00:32:38,700
number here is the speed up without

762
00:32:38,700 --> 00:32:41,159
function composition the right number is

763
00:32:41,159 --> 00:32:44,480
with function composition

764
00:32:44,640 --> 00:32:46,559
in conclusion we can speed up

765
00:32:46,559 --> 00:32:48,659
bootstrapping for the bgv and the BFE

766
00:32:48,659 --> 00:32:51,480
scheme up to 2.6 times

767
00:32:51,480 --> 00:32:53,520
this is only possible due to a better

768
00:32:53,520 --> 00:32:55,799
understanding of poly functions mod P to

769
00:32:55,799 --> 00:32:58,140
the E and in particular due to the

770
00:32:58,140 --> 00:33:01,559
existence of non-trivial nodalinomials

771
00:33:01,559 --> 00:33:03,960
and we believe that this theory of poly

772
00:33:03,960 --> 00:33:05,820
functions can also be of independent

773
00:33:05,820 --> 00:33:08,100
interest in cryptography and we are

774
00:33:08,100 --> 00:33:11,880
looking forward to see more applications

775
00:33:11,880 --> 00:33:15,260
I thank you for your attention

776
00:33:20,659 --> 00:33:23,899
any questions

777
00:33:30,539 --> 00:33:33,360
no question so I I have a small question

778
00:33:33,360 --> 00:33:35,700
can you apply your decomposition

779
00:33:35,700 --> 00:33:39,000
function recursively to uh yeah that's

780
00:33:39,000 --> 00:33:41,279
also possible however in practice we

781
00:33:41,279 --> 00:33:43,019
observe that it only still gives speed

782
00:33:43,019 --> 00:33:45,299
up if we apply it one time but it is

783
00:33:45,299 --> 00:33:47,519
possible in theory

784
00:33:47,519 --> 00:33:49,500
yeah not for practical parameters that

785
00:33:49,500 --> 00:33:53,419
it will not give you any more speed up

786
00:33:54,779 --> 00:33:57,120
no questions

787
00:33:57,120 --> 00:33:59,080
so let's find the the speaker again

788
00:33:59,080 --> 00:34:06,970
[Applause]

789
00:34:13,619 --> 00:34:16,159
okay

790
00:34:27,599 --> 00:34:30,300
so the the last Talk of the session is

791
00:34:30,300 --> 00:34:31,980
functional commitments to for all

792
00:34:31,980 --> 00:34:34,080
functions with transparent setup and

793
00:34:34,080 --> 00:34:36,799
from sis

794
00:34:37,099 --> 00:34:40,139
and Leo will give the talk

795
00:34:40,139 --> 00:34:41,339
thank you

796
00:34:41,339 --> 00:34:43,699
everyone this talk is on functional

797
00:34:43,699 --> 00:34:45,599
functional commitments for all functions

798
00:34:45,599 --> 00:34:47,879
from SAS with transparent setups joint

799
00:34:47,879 --> 00:34:49,339
work with Chris

800
00:34:49,339 --> 00:34:52,739
so just as a brief preview in this talk

801
00:34:52,739 --> 00:34:53,760
we're going to be building functional

802
00:34:53,760 --> 00:34:56,219
equipments for all functions uh our only

803
00:34:56,219 --> 00:34:58,320
assumption will be sis

804
00:34:58,320 --> 00:35:01,560
we'll have transparency set up our

805
00:35:01,560 --> 00:35:02,940
public parameters must be a single

806
00:35:02,940 --> 00:35:05,280
random Matrix and we're going to get

807
00:35:05,280 --> 00:35:08,099
fast and simple verification to verify

808
00:35:08,099 --> 00:35:10,440
an opening of this commitment scheme the

809
00:35:10,440 --> 00:35:11,940
verifier will just need to check one

810
00:35:11,940 --> 00:35:13,579
linear relation

811
00:35:13,579 --> 00:35:15,900
this talk is going to be split up into

812
00:35:15,900 --> 00:35:18,599
two parts uh the first we're going to go

813
00:35:18,599 --> 00:35:20,040
over the functional equipment

814
00:35:20,040 --> 00:35:22,740
construction and pre-sketch of the

815
00:35:22,740 --> 00:35:25,200
security proof and then in this the

816
00:35:25,200 --> 00:35:25,980
second part we're going to talk about

817
00:35:25,980 --> 00:35:29,579
how to use this can construction how to

818
00:35:29,579 --> 00:35:30,660
take advantage of some of the more

819
00:35:30,660 --> 00:35:32,420
attractive features

820
00:35:32,420 --> 00:35:35,040
and really how you can efficiently

821
00:35:35,040 --> 00:35:38,579
specialize this construction uh to some

822
00:35:38,579 --> 00:35:41,880
of the more common special cases

823
00:35:41,880 --> 00:35:44,820
okay so let's Jump Right In what is a

824
00:35:44,820 --> 00:35:47,040
functional commitment uh so we start

825
00:35:47,040 --> 00:35:49,320
with a function family capital f

826
00:35:49,320 --> 00:35:51,599
and then there's a setup algorithm that

827
00:35:51,599 --> 00:35:53,040
outputs public parameters about the

828
00:35:53,040 --> 00:35:54,960
prover and the verifier have the prover

829
00:35:54,960 --> 00:35:57,540
then picks some function in this family

830
00:35:57,540 --> 00:35:59,339
and commits to this

831
00:35:59,339 --> 00:36:01,020
commits to this function

832
00:36:01,020 --> 00:36:03,300
um with some equipment algorithm and

833
00:36:03,300 --> 00:36:04,079
we're not really going to be worried

834
00:36:04,079 --> 00:36:05,700
about hiding at all in this talk and so

835
00:36:05,700 --> 00:36:07,740
in order to get binding uh without just

836
00:36:07,740 --> 00:36:10,500
having a trivial construction we're

837
00:36:10,500 --> 00:36:13,579
going to be having some efficiency re

838
00:36:13,579 --> 00:36:16,560
requirements on the uh commitment in

839
00:36:16,560 --> 00:36:18,960
particular the length of the commitment

840
00:36:18,960 --> 00:36:20,760
will have to be less than the length of

841
00:36:20,760 --> 00:36:22,740
the function it's also worth noting that

842
00:36:22,740 --> 00:36:25,440
other works consider committing to

843
00:36:25,440 --> 00:36:28,260
inputs and opening to functions uh in

844
00:36:28,260 --> 00:36:29,940
this work we'll be really committing to

845
00:36:29,940 --> 00:36:32,520
functions and opening to inputs these

846
00:36:32,520 --> 00:36:34,859
Notions are equivalent using Universal

847
00:36:34,859 --> 00:36:38,779
circuits but this is just a

848
00:36:39,300 --> 00:36:42,119
conceptual model okay so the approver

849
00:36:42,119 --> 00:36:43,380
sends the commitment over to the

850
00:36:43,380 --> 00:36:45,359
verifier the verifier picks some input X

851
00:36:45,359 --> 00:36:48,660
to this function the approver then runs

852
00:36:48,660 --> 00:36:51,119
F on X to get Y and then produces some

853
00:36:51,119 --> 00:36:53,700
opening proof that this evaluation was

854
00:36:53,700 --> 00:36:56,760
performed correctly uh

855
00:36:56,760 --> 00:36:59,579
um again we need the proof to be less

856
00:36:59,579 --> 00:37:01,440
than the size of the function

857
00:37:01,440 --> 00:37:04,200
uh and so the verifier then gets the

858
00:37:04,200 --> 00:37:06,660
claimed output and the the proof runs

859
00:37:06,660 --> 00:37:08,520
the the verify algorithm

860
00:37:08,520 --> 00:37:11,700
um to either accept or reject this proof

861
00:37:11,700 --> 00:37:13,260
so

862
00:37:13,260 --> 00:37:15,200
because uh we have this efficiency

863
00:37:15,200 --> 00:37:17,280
requirement of the verifier really not

864
00:37:17,280 --> 00:37:19,560
getting this function

865
00:37:19,560 --> 00:37:21,359
um we need to think a little bit about

866
00:37:21,359 --> 00:37:23,339
what the uh security property is that

867
00:37:23,339 --> 00:37:25,079
makes the most sense here we really want

868
00:37:25,079 --> 00:37:26,579
to say that the proverb has committed to

869
00:37:26,579 --> 00:37:28,740
some function and what that is going to

870
00:37:28,740 --> 00:37:30,240
mean a little bit more formally is that

871
00:37:30,240 --> 00:37:32,579
for every in for every uh input X

872
00:37:32,579 --> 00:37:35,040
there's only going to be one y and proof

873
00:37:35,040 --> 00:37:37,320
that the prover can provide that will

874
00:37:37,320 --> 00:37:39,480
pass uh verification so with this

875
00:37:39,480 --> 00:37:41,820
motivation let's give a brief definition

876
00:37:41,820 --> 00:37:44,040
of the security

877
00:37:44,040 --> 00:37:45,540
uh the following game should be hard to

878
00:37:45,540 --> 00:37:46,800
win we're going to focus on the uh

879
00:37:46,800 --> 00:37:49,020
selective version of this game but the

880
00:37:49,020 --> 00:37:51,960
Adaptive version can be achieved via

881
00:37:51,960 --> 00:37:54,119
complexity leveraging uh right so

882
00:37:54,119 --> 00:37:55,320
because it's the selected version the

883
00:37:55,320 --> 00:37:56,760
adversary is going to give us the XR

884
00:37:56,760 --> 00:37:58,800
that it's going to break the evaluation

885
00:37:58,800 --> 00:37:59,940
binding on

886
00:37:59,940 --> 00:38:01,200
then we're going to run the setup

887
00:38:01,200 --> 00:38:02,700
algorithm to get the public parameters

888
00:38:02,700 --> 00:38:04,619
these public parameters will be fed back

889
00:38:04,619 --> 00:38:06,780
into the adversary who will produce some

890
00:38:06,780 --> 00:38:09,359
commitment and then two openings uh

891
00:38:09,359 --> 00:38:11,400
corresponding to two claimed outputs y

892
00:38:11,400 --> 00:38:13,380
one and Y two

893
00:38:13,380 --> 00:38:16,320
and the adversary wins this game if uh

894
00:38:16,320 --> 00:38:18,599
y1 and Y2 are not equal but the

895
00:38:18,599 --> 00:38:21,000
verification passes for both openings so

896
00:38:21,000 --> 00:38:22,500
this means that the adversary has

897
00:38:22,500 --> 00:38:26,040
successfully equivocated on the input X

898
00:38:26,040 --> 00:38:27,780
star

899
00:38:27,780 --> 00:38:29,760
okay so what are some applications of

900
00:38:29,760 --> 00:38:31,740
functional commitments uh you can see

901
00:38:31,740 --> 00:38:32,640
functional equipments as a

902
00:38:32,640 --> 00:38:34,260
generalization of many very useful

903
00:38:34,260 --> 00:38:35,880
special cases like vector equipments

904
00:38:35,880 --> 00:38:38,280
polynomial equipments uh

905
00:38:38,280 --> 00:38:40,980
Etc and because they have so many useful

906
00:38:40,980 --> 00:38:43,560
specializations they have lots and lots

907
00:38:43,560 --> 00:38:45,180
of applications way too many to go over

908
00:38:45,180 --> 00:38:47,460
here but I just want to highlight the

909
00:38:47,460 --> 00:38:49,560
second to the bottom one

910
00:38:49,560 --> 00:38:51,540
um which is proof caring data snogs and

911
00:38:51,540 --> 00:38:53,760
snarks uh we really see this primitive

912
00:38:53,760 --> 00:38:55,500
as a nice floating block to building

913
00:38:55,500 --> 00:38:58,380
more efficient lattice based snarks okay

914
00:38:58,380 --> 00:39:00,000
so what was known about functional

915
00:39:00,000 --> 00:39:01,859
equipments before this before this work

916
00:39:01,859 --> 00:39:04,859
well if um if you are fine with

917
00:39:04,859 --> 00:39:06,720
non-fossa with non-falsifiable

918
00:39:06,720 --> 00:39:08,820
assumptions you can build functional

919
00:39:08,820 --> 00:39:10,079
commitments somewhat generically from a

920
00:39:10,079 --> 00:39:11,460
short commitment and a snark for NP

921
00:39:11,460 --> 00:39:13,740
where the snarg witness is uh the

922
00:39:13,740 --> 00:39:15,720
opening of the short commitment to some

923
00:39:15,720 --> 00:39:17,280
function that evaluates to the claimed

924
00:39:17,280 --> 00:39:19,619
output on on the chosen input

925
00:39:19,619 --> 00:39:21,420
but if I'm Only Happy with falsifiable

926
00:39:21,420 --> 00:39:24,599
assumptions then all prior constructions

927
00:39:24,599 --> 00:39:27,480
were limited to linearizable functions

928
00:39:27,480 --> 00:39:29,880
um things like vectors and polynomials

929
00:39:29,880 --> 00:39:32,400
things that can be easily uh expressed

930
00:39:32,400 --> 00:39:34,140
as linear operations

931
00:39:34,140 --> 00:39:37,880
uh in 2021 uh pikard Pepin and sharp

932
00:39:37,880 --> 00:39:39,780
constructed functional commitments for

933
00:39:39,780 --> 00:39:41,220
all functions but they required this

934
00:39:41,220 --> 00:39:43,380
online Authority that releases like

935
00:39:43,380 --> 00:39:46,440
opening keys for all open inputs which

936
00:39:46,440 --> 00:39:48,839
is not not a very natural uh security

937
00:39:48,839 --> 00:39:51,000
model so the other problem from this

938
00:39:51,000 --> 00:39:53,220
work is okay can we construct functional

939
00:39:53,220 --> 00:39:55,200
equipments for all functions without any

940
00:39:55,200 --> 00:39:58,500
online Authority and this is the result

941
00:39:58,500 --> 00:39:59,520
of this work

942
00:39:59,520 --> 00:40:01,619
so as I said our only assumption is sis

943
00:40:01,619 --> 00:40:03,960
which gives us Post Quantum security or

944
00:40:03,960 --> 00:40:05,520
we have a transparent setup so our

945
00:40:05,520 --> 00:40:07,020
public parameters are just single random

946
00:40:07,020 --> 00:40:08,839
Matrix

947
00:40:08,839 --> 00:40:12,000
we have linear verification uh the

948
00:40:12,000 --> 00:40:13,260
verifier only ever checks a single

949
00:40:13,260 --> 00:40:15,720
linear relation to verify an opening we

950
00:40:15,720 --> 00:40:17,339
get more features that I'll talk about a

951
00:40:17,339 --> 00:40:20,820
little bit later and uh also mention how

952
00:40:20,820 --> 00:40:22,440
we can efficiently

953
00:40:22,440 --> 00:40:24,780
specialize before I move on though I

954
00:40:24,780 --> 00:40:26,640
want to briefly mention uh two can

955
00:40:26,640 --> 00:40:29,280
concurrent works the first is this work

956
00:40:29,280 --> 00:40:32,220
of uh about at all on chainable

957
00:40:32,220 --> 00:40:34,500
functional commitments and the second is

958
00:40:34,500 --> 00:40:36,000
the work of we and Wu that we'll hear

959
00:40:36,000 --> 00:40:37,619
about on Thursday

960
00:40:37,619 --> 00:40:39,920
all of these Works uh

961
00:40:39,920 --> 00:40:41,760
construct functional equipments for all

962
00:40:41,760 --> 00:40:42,839
functions based off of lattice

963
00:40:42,839 --> 00:40:45,420
assumptions but note that our work is

964
00:40:45,420 --> 00:40:48,060
the only of these three that uh uses a

965
00:40:48,060 --> 00:40:49,440
standard assumption both of these other

966
00:40:49,440 --> 00:40:52,079
works introduce new uh new assumptions

967
00:40:52,079 --> 00:40:54,119
in there in their work

968
00:40:54,119 --> 00:40:56,880
um to to build their primitive uh we're

969
00:40:56,880 --> 00:40:58,380
also the only of these three works that

970
00:40:58,380 --> 00:41:00,119
has transparent setup the other two

971
00:41:00,119 --> 00:41:01,619
works there's private Randomness in this

972
00:41:01,619 --> 00:41:03,420
in the setup algorithm that can't be

973
00:41:03,420 --> 00:41:06,960
known by the by the prover

974
00:41:06,960 --> 00:41:07,859
um

975
00:41:07,859 --> 00:41:09,900
this is sickness here when I say uh you

976
00:41:09,900 --> 00:41:11,000
know we all

977
00:41:11,000 --> 00:41:13,500
achieve a succinct commitments this is

978
00:41:13,500 --> 00:41:15,000
much more strict than the succinctness

979
00:41:15,000 --> 00:41:16,920
in the in the previous slide this is

980
00:41:16,920 --> 00:41:19,200
really like poly polylog

981
00:41:19,200 --> 00:41:22,160
so thickness we all get these short

982
00:41:22,160 --> 00:41:24,599
commitments but our openings are not as

983
00:41:24,599 --> 00:41:26,400
short as the other these other two Works

984
00:41:26,400 --> 00:41:27,900
in particular our openings will be

985
00:41:27,900 --> 00:41:30,480
linear in the length of the input and

986
00:41:30,480 --> 00:41:33,599
the length of the output however we are

987
00:41:33,599 --> 00:41:35,640
the only of these we are the only one of

988
00:41:35,640 --> 00:41:38,040
these Works to achieve fast verification

989
00:41:38,040 --> 00:41:39,480
and these other two works the verifier

990
00:41:39,480 --> 00:41:41,760
essentially has to run the function in

991
00:41:41,760 --> 00:41:43,619
order to verify the opening and if you

992
00:41:43,619 --> 00:41:44,520
think about an application like

993
00:41:44,520 --> 00:41:46,980
verifiable FH fhe if I'm forcing the

994
00:41:46,980 --> 00:41:49,020
verifier to run the the whole function

995
00:41:49,020 --> 00:41:50,820
just to verify the output the

996
00:41:50,820 --> 00:41:51,900
Outsourcing doesn't really make a whole

997
00:41:51,900 --> 00:41:53,460
lot of sense so it's really nice open

998
00:41:53,460 --> 00:41:55,400
question in this in this work to

999
00:41:55,400 --> 00:41:57,839
maintain a fast verification while

1000
00:41:57,839 --> 00:42:00,599
getting uh succinct opening still okay

1001
00:42:00,599 --> 00:42:02,700
so let's move on into the construction

1002
00:42:02,700 --> 00:42:05,339
brief background on the sis problem uh

1003
00:42:05,339 --> 00:42:07,020
the SAS problem says given a uniformly

1004
00:42:07,020 --> 00:42:09,900
random Matrix a find some short Vector X

1005
00:42:09,900 --> 00:42:12,359
such that a times x equals e where e is

1006
00:42:12,359 --> 00:42:14,339
also short this might be uh slightly

1007
00:42:14,339 --> 00:42:15,839
different than what you've seen where

1008
00:42:15,839 --> 00:42:17,579
like a times x equals zero but actually

1009
00:42:17,579 --> 00:42:20,099
this is the same problem and this is the

1010
00:42:20,099 --> 00:42:20,820
way that you should think about

1011
00:42:20,820 --> 00:42:22,980
parameters just as a brief brief

1012
00:42:22,980 --> 00:42:24,560
intuition is that a is a very wide

1013
00:42:24,560 --> 00:42:27,180
Matrix the the number of columns is way

1014
00:42:27,180 --> 00:42:29,760
bigger than the number of rows and that

1015
00:42:29,760 --> 00:42:33,119
the norm bound uh on our X and r e is

1016
00:42:33,119 --> 00:42:34,859
like roughly within a factor of n of the

1017
00:42:34,859 --> 00:42:36,240
module so really really quite quite

1018
00:42:36,240 --> 00:42:38,520
close to the modulus

1019
00:42:38,520 --> 00:42:40,619
uh so our our main technical tool to

1020
00:42:40,619 --> 00:42:42,359
build this these functional these

1021
00:42:42,359 --> 00:42:43,680
functional equipments is a homomorphic

1022
00:42:43,680 --> 00:42:46,560
computation scheme uh this if you're

1023
00:42:46,560 --> 00:42:48,000
wondering why this talk was in this

1024
00:42:48,000 --> 00:42:49,260
session

1025
00:42:49,260 --> 00:42:51,900
um so I'm going to briefly uh describe

1026
00:42:51,900 --> 00:42:52,740
this

1027
00:42:52,740 --> 00:42:54,960
um so we're going to fix some Matrix C

1028
00:42:54,960 --> 00:42:57,060
and we're going to let F be any any

1029
00:42:57,060 --> 00:42:58,980
function think of f as an arithmetic

1030
00:42:58,980 --> 00:43:02,099
circuit and let X be some input to f

1031
00:43:02,099 --> 00:43:04,680
and the key equation that we're going to

1032
00:43:04,680 --> 00:43:06,060
be staring at for the rest of this talk

1033
00:43:06,060 --> 00:43:09,420
is uh C minus encode of X where you

1034
00:43:09,420 --> 00:43:11,700
think of in code as just like a matrix

1035
00:43:11,700 --> 00:43:15,060
in in betting of of X in in code will

1036
00:43:15,060 --> 00:43:16,640
also need to be an additive

1037
00:43:16,640 --> 00:43:19,380
homomorphism but um I'll refer you to

1038
00:43:19,380 --> 00:43:22,260
the details for more uh uh sorry refer

1039
00:43:22,260 --> 00:43:24,119
you to the paper for more details on

1040
00:43:24,119 --> 00:43:26,579
this um the details of in code aren't

1041
00:43:26,579 --> 00:43:27,839
really necessary to get the scheme from

1042
00:43:27,839 --> 00:43:30,480
a high level as we have C minus in code

1043
00:43:30,480 --> 00:43:32,220
of x times

1044
00:43:32,220 --> 00:43:37,140
some some s equals uh C sub F minus in

1045
00:43:37,140 --> 00:43:40,380
encode of f of x and um

1046
00:43:40,380 --> 00:43:42,900
we really need two two properties here

1047
00:43:42,900 --> 00:43:45,359
uh the first that c sub f is efficiently

1048
00:43:45,359 --> 00:43:48,720
computable and that it depends only on C

1049
00:43:48,720 --> 00:43:51,780
and F so once I fix C and F C sub f is

1050
00:43:51,780 --> 00:43:53,579
the same for all X

1051
00:43:53,579 --> 00:43:57,420
and secondly we need S Sub F and X to be

1052
00:43:57,420 --> 00:44:00,920
short and also efficiently uh uh

1053
00:44:00,920 --> 00:44:02,460
computable

1054
00:44:02,460 --> 00:44:04,680
um you know if you if you've seen any of

1055
00:44:04,680 --> 00:44:06,240
these works that I've listed at the top

1056
00:44:06,240 --> 00:44:07,859
this equation probably looks quite

1057
00:44:07,859 --> 00:44:09,540
familiar

1058
00:44:09,540 --> 00:44:11,220
um but I just want to emphasize that

1059
00:44:11,220 --> 00:44:12,960
there's actually no Randomness here once

1060
00:44:12,960 --> 00:44:15,119
you fix C everything is determined is a

1061
00:44:15,119 --> 00:44:18,000
deterministic function of uh c f and

1062
00:44:18,000 --> 00:44:19,319
sometimes X

1063
00:44:19,319 --> 00:44:21,300
as opposed to these other works that you

1064
00:44:21,300 --> 00:44:22,680
know sometimes there's Randomness in the

1065
00:44:22,680 --> 00:44:24,000
sampling of the best sometimes the whole

1066
00:44:24,000 --> 00:44:26,099
thing is wrapped in a secret but this is

1067
00:44:26,099 --> 00:44:29,280
kind of a much uh simpler um conceptual

1068
00:44:29,280 --> 00:44:31,260
view of this very useful type of

1069
00:44:31,260 --> 00:44:33,780
equation okay so once we have this

1070
00:44:33,780 --> 00:44:36,000
equation in place the construction just

1071
00:44:36,000 --> 00:44:38,400
kind of follows the uh pattern pattern

1072
00:44:38,400 --> 00:44:39,420
matching

1073
00:44:39,420 --> 00:44:42,780
uh our setup algorithm is just the

1074
00:44:42,780 --> 00:44:44,700
Matrix C this is our transparent setup

1075
00:44:44,700 --> 00:44:47,160
uh uniformly random we need no no

1076
00:44:47,160 --> 00:44:50,760
structure from C so uh this is yeah this

1077
00:44:50,760 --> 00:44:52,800
is our setup algorithm uh the commit

1078
00:44:52,800 --> 00:44:55,980
algorithm is just uh C sub f it depends

1079
00:44:55,980 --> 00:45:00,240
only on C and F so um this is a natural

1080
00:45:00,240 --> 00:45:02,940
choice for the commitment the opening is

1081
00:45:02,940 --> 00:45:05,940
uh S Sub F and X again it's efficiently

1082
00:45:05,940 --> 00:45:07,980
computable from all of the inputs to

1083
00:45:07,980 --> 00:45:09,599
open

1084
00:45:09,599 --> 00:45:13,200
and finally verify just checks that the

1085
00:45:13,200 --> 00:45:16,619
proof is short and that the equation at

1086
00:45:16,619 --> 00:45:19,079
the top is true

1087
00:45:19,079 --> 00:45:22,500
okay so what is the security proof look

1088
00:45:22,500 --> 00:45:25,859
like just as a as a brief sketch we're

1089
00:45:25,859 --> 00:45:27,619
going to start with an SIS challenge C

1090
00:45:27,619 --> 00:45:30,540
uniformly random Matrix the adversary is

1091
00:45:30,540 --> 00:45:31,560
going to tell us what input it's going

1092
00:45:31,560 --> 00:45:33,300
to break

1093
00:45:33,300 --> 00:45:34,319
and we're going to set our public

1094
00:45:34,319 --> 00:45:36,480
parameters to be C Prime which is the

1095
00:45:36,480 --> 00:45:39,359
SAS challenge shifted by the encoding of

1096
00:45:39,359 --> 00:45:42,060
X star in the other direction as in the

1097
00:45:42,060 --> 00:45:44,700
verification e equation

1098
00:45:44,700 --> 00:45:46,579
now in the adversary

1099
00:45:46,579 --> 00:45:49,079
produces the commitment and the two

1100
00:45:49,079 --> 00:45:50,339
openings

1101
00:45:50,339 --> 00:45:54,780
when we shift the um the the public

1102
00:45:54,780 --> 00:45:56,520
parameters by The Chosen input we're

1103
00:45:56,520 --> 00:45:58,619
going to get our SAS challenge back and

1104
00:45:58,619 --> 00:46:03,060
because uh the um because the two proofs

1105
00:46:03,060 --> 00:46:06,000
are short and the left hand sides are

1106
00:46:06,000 --> 00:46:07,680
now or sorry the right hand sides are

1107
00:46:07,680 --> 00:46:11,700
now different we can sub subtract the

1108
00:46:11,700 --> 00:46:13,380
two left-hand sides to cancel out

1109
00:46:13,380 --> 00:46:14,880
whatever commitment the adversary gave

1110
00:46:14,880 --> 00:46:17,579
us and as long as some column of encode

1111
00:46:17,579 --> 00:46:19,740
is short then work then we're done I'll

1112
00:46:19,740 --> 00:46:21,300
refer you to the paper for more details

1113
00:46:21,300 --> 00:46:24,240
but this is really the uh high level

1114
00:46:24,240 --> 00:46:27,060
view of the security proof okay so that

1115
00:46:27,060 --> 00:46:29,579
concludes part one now let's talk a

1116
00:46:29,579 --> 00:46:31,500
little bit about features and how to

1117
00:46:31,500 --> 00:46:32,579
efficiently

1118
00:46:32,579 --> 00:46:35,880
specialize this construction okay so

1119
00:46:35,880 --> 00:46:37,800
let's uh talk about stateless updates

1120
00:46:37,800 --> 00:46:39,839
we're going to focus on the linear case

1121
00:46:39,839 --> 00:46:41,579
first because it's a lot simpler but

1122
00:46:41,579 --> 00:46:44,579
also uh really quite quite a useful

1123
00:46:44,579 --> 00:46:46,560
special case

1124
00:46:46,560 --> 00:46:47,099
um

1125
00:46:47,099 --> 00:46:48,780
so our goal here is going to be is going

1126
00:46:48,780 --> 00:46:50,700
to be to update a commitment to F to a

1127
00:46:50,700 --> 00:46:52,800
commitment to f plus G

1128
00:46:52,800 --> 00:46:54,839
and uh I'm going to generate my

1129
00:46:54,839 --> 00:46:56,880
commitment to G as I would without even

1130
00:46:56,880 --> 00:46:58,980
thinking about F and the observation

1131
00:46:58,980 --> 00:47:01,380
here is that because the uh verification

1132
00:47:01,380 --> 00:47:04,380
equation is linear and encode is an

1133
00:47:04,380 --> 00:47:05,359
additive

1134
00:47:05,359 --> 00:47:09,319
homomorphism uh the uh the verification

1135
00:47:09,319 --> 00:47:11,819
equation just uh

1136
00:47:11,819 --> 00:47:14,280
Still Still passes if I just add my

1137
00:47:14,280 --> 00:47:16,380
equipment to G to my commitment to F and

1138
00:47:16,380 --> 00:47:19,200
if I add my my opening to G at X to my

1139
00:47:19,200 --> 00:47:22,140
opening to F at X so really if I want to

1140
00:47:22,140 --> 00:47:24,540
update F I don't even need to know not

1141
00:47:24,540 --> 00:47:25,980
only do I need to know anything about F

1142
00:47:25,980 --> 00:47:27,060
I don't even know anything about the

1143
00:47:27,060 --> 00:47:30,119
commitment to to so this is really quite

1144
00:47:30,119 --> 00:47:32,400
quite nice that the verifier can update

1145
00:47:32,400 --> 00:47:35,060
the commitments totally locally

1146
00:47:35,060 --> 00:47:39,060
if I want arbitrary composition

1147
00:47:39,060 --> 00:47:41,160
um where you know my goal now is to

1148
00:47:41,160 --> 00:47:43,319
update proofs uh sorry

1149
00:47:43,319 --> 00:47:43,859
um

1150
00:47:43,859 --> 00:47:45,960
commitments and proofs to F to ones for

1151
00:47:45,960 --> 00:47:49,140
G composed with with f

1152
00:47:49,140 --> 00:47:50,460
uh

1153
00:47:50,460 --> 00:47:52,680
I'm going to you know let the the prover

1154
00:47:52,680 --> 00:47:55,200
know uh c c sub F but the approver still

1155
00:47:55,200 --> 00:47:57,900
will not know anything about f

1156
00:47:57,900 --> 00:47:59,880
um the key observation really is that

1157
00:47:59,880 --> 00:48:01,500
the right hand side looks an awful lot

1158
00:48:01,500 --> 00:48:03,300
like the inner parenthesis of the left

1159
00:48:03,300 --> 00:48:05,819
hand side so I can actually be because

1160
00:48:05,819 --> 00:48:08,220
we didn't really need any structure out

1161
00:48:08,220 --> 00:48:10,079
of our public parameter C we can just

1162
00:48:10,079 --> 00:48:12,780
treat C sub F now as our new C and just

1163
00:48:12,780 --> 00:48:15,960
keep Computing on the right hand side as

1164
00:48:15,960 --> 00:48:18,300
if it were the inner left hand side

1165
00:48:18,300 --> 00:48:21,119
so when we want to update uh the

1166
00:48:21,119 --> 00:48:24,540
commitment to uh C sub F2 G composed

1167
00:48:24,540 --> 00:48:27,619
with f we just keep uh

1168
00:48:27,619 --> 00:48:30,540
Computing on that right hand side

1169
00:48:30,540 --> 00:48:33,599
and we'll get this verification equation

1170
00:48:33,599 --> 00:48:36,780
that looks a bit like this where we have

1171
00:48:36,780 --> 00:48:40,260
G sorry we have C sub G composed with

1172
00:48:40,260 --> 00:48:42,480
with f

1173
00:48:42,480 --> 00:48:45,780
uh on the bottom there and then when we

1174
00:48:45,780 --> 00:48:47,819
want to update openings we can just send

1175
00:48:47,819 --> 00:48:50,940
the updated opening uh to the verifier

1176
00:48:50,940 --> 00:48:54,960
of S Sub G and f of x but if you want to

1177
00:48:54,960 --> 00:48:55,800
update all the way from the original

1178
00:48:55,800 --> 00:48:57,720
left hand side we do need that that

1179
00:48:57,720 --> 00:49:00,480
first Matrix S

1180
00:49:00,480 --> 00:49:04,099
um okay so how can we efficiently

1181
00:49:04,099 --> 00:49:08,880
specialize this uh construction if you

1182
00:49:08,880 --> 00:49:11,760
recall most of the efficient or rather

1183
00:49:11,760 --> 00:49:14,040
most of the useful special cases were

1184
00:49:14,040 --> 00:49:15,839
linearizable functions so we're going to

1185
00:49:15,839 --> 00:49:17,760
start thinking about point point

1186
00:49:17,760 --> 00:49:20,520
functions and how to use our efficient

1187
00:49:20,520 --> 00:49:23,460
linear updates to to efficiently

1188
00:49:23,460 --> 00:49:25,680
uh specialized so the point function

1189
00:49:25,680 --> 00:49:27,720
that I'm going to be talking about for

1190
00:49:27,720 --> 00:49:29,460
the rest of this talk

1191
00:49:29,460 --> 00:49:32,880
uh looks like this uh on the on the top

1192
00:49:32,880 --> 00:49:34,920
of the slide where you have a hard-coded

1193
00:49:34,920 --> 00:49:36,960
x x bar and your output one if your

1194
00:49:36,960 --> 00:49:38,160
input is equal to X bar and you're up

1195
00:49:38,160 --> 00:49:41,040
with zero other otherwise

1196
00:49:41,040 --> 00:49:43,800
uh right so we have some function f

1197
00:49:43,800 --> 00:49:46,680
mapping from a domain X to a range Y and

1198
00:49:46,680 --> 00:49:48,540
we're going to define the support of f

1199
00:49:48,540 --> 00:49:51,420
as all of the inputs in the domain that

1200
00:49:51,420 --> 00:49:55,200
map to some non-trivial output

1201
00:49:55,200 --> 00:49:57,599
so we can write f as a linear function

1202
00:49:57,599 --> 00:50:00,260
of its support

1203
00:50:00,260 --> 00:50:01,940
where

1204
00:50:01,940 --> 00:50:06,000
we have these point point functions that

1205
00:50:06,000 --> 00:50:06,800
only

1206
00:50:06,800 --> 00:50:09,839
depend on the support and then we have

1207
00:50:09,839 --> 00:50:13,560
this Vector of outputs on the non-non

1208
00:50:13,560 --> 00:50:14,940
trivial points

1209
00:50:14,940 --> 00:50:16,760
and the observation here really is that

1210
00:50:16,760 --> 00:50:20,160
because or rather like now we have this

1211
00:50:20,160 --> 00:50:21,420
this nice

1212
00:50:21,420 --> 00:50:25,020
structure where the point functions are

1213
00:50:25,020 --> 00:50:27,480
independent of the function itself or

1214
00:50:27,480 --> 00:50:31,440
they only depend on the support and this

1215
00:50:31,440 --> 00:50:33,480
Vector of outputs is independent of the

1216
00:50:33,480 --> 00:50:36,000
input so when we want to commit to a

1217
00:50:36,000 --> 00:50:38,880
function with this structure

1218
00:50:38,880 --> 00:50:40,980
all of the commitments to these Point

1219
00:50:40,980 --> 00:50:43,740
functions can be pre-computed and the

1220
00:50:43,740 --> 00:50:46,079
openings to to a particular X can be

1221
00:50:46,079 --> 00:50:48,839
precomputed as well and so for all of

1222
00:50:48,839 --> 00:50:51,660
the uh special cases that I'll list in

1223
00:50:51,660 --> 00:50:53,099
the next slide

1224
00:50:53,099 --> 00:50:56,599
uh all of the commitment and opening

1225
00:50:56,599 --> 00:50:59,460
operations will be linear linear

1226
00:50:59,460 --> 00:51:00,660
functions

1227
00:51:00,660 --> 00:51:03,839
and also uh all of these specializations

1228
00:51:03,839 --> 00:51:06,800
will in inherit the stateless

1229
00:51:06,800 --> 00:51:09,359
composability okay so yeah this is a

1230
00:51:09,359 --> 00:51:10,920
highly versatile framework I'll just

1231
00:51:10,920 --> 00:51:12,300
leave this at the top there but you can

1232
00:51:12,300 --> 00:51:14,900
get Vector commitments just by treating

1233
00:51:14,900 --> 00:51:17,339
the vector as a function that Maps

1234
00:51:17,339 --> 00:51:20,460
indices to outputs in the in the vector

1235
00:51:20,460 --> 00:51:24,180
space you can get an accumulator by

1236
00:51:24,180 --> 00:51:26,280
taking your your set s that you've

1237
00:51:26,280 --> 00:51:28,260
committed to in your large universe and

1238
00:51:28,260 --> 00:51:29,579
defining some function that maps

1239
00:51:29,579 --> 00:51:31,380
elements in the universe to bits that

1240
00:51:31,380 --> 00:51:33,480
indicate membership but note that like

1241
00:51:33,480 --> 00:51:34,920
you don't need to sum up over all of the

1242
00:51:34,920 --> 00:51:36,540
elements in the universe you only need

1243
00:51:36,540 --> 00:51:38,460
to sum up the elements that are actually

1244
00:51:38,460 --> 00:51:41,520
uh in the committed set same thing for

1245
00:51:41,520 --> 00:51:44,280
key key value commitments

1246
00:51:44,280 --> 00:51:47,099
um mapping from keys k to values V just

1247
00:51:47,099 --> 00:51:48,660
turns into this function and then you

1248
00:51:48,660 --> 00:51:51,540
only need to sum up over the the defined

1249
00:51:51,540 --> 00:51:53,160
keys and then finally you can get

1250
00:51:53,160 --> 00:51:54,960
polynomials through a very similar type

1251
00:51:54,960 --> 00:51:56,760
of structure but instead of using these

1252
00:51:56,760 --> 00:51:59,339
point point functions um you just use

1253
00:51:59,339 --> 00:52:01,680
the power power power function and then

1254
00:52:01,680 --> 00:52:03,300
the linear function is just with the

1255
00:52:03,300 --> 00:52:05,660
coefficients of the

1256
00:52:05,660 --> 00:52:08,640
polynomial all right that's all I have

1257
00:52:08,640 --> 00:52:11,240
thanks

1258
00:52:13,070 --> 00:52:16,199
[Music]

1259
00:52:17,640 --> 00:52:20,598
any any questions

1260
00:52:27,660 --> 00:52:30,780
nice talk Leo I have one question so

1261
00:52:30,780 --> 00:52:33,000
um can you comment on what are the steps

1262
00:52:33,000 --> 00:52:35,339
that are needed if you want to apply

1263
00:52:35,339 --> 00:52:37,680
this new construction of yours to the

1264
00:52:37,680 --> 00:52:40,079
applications of function commitment that

1265
00:52:40,079 --> 00:52:42,240
you mentioned in the slide

1266
00:52:42,240 --> 00:52:44,160
uh yeah so it would definitely depend on

1267
00:52:44,160 --> 00:52:45,900
the type of application that you're

1268
00:52:45,900 --> 00:52:46,800
talking about

1269
00:52:46,800 --> 00:52:49,380
um so yeah I mean for the vector

1270
00:52:49,380 --> 00:52:52,559
commitment say uh yeah you would just uh

1271
00:52:52,559 --> 00:52:55,980
Define your function as like right so I

1272
00:52:55,980 --> 00:52:57,180
can go back to that slide so yeah I mean

1273
00:52:57,180 --> 00:52:59,240
if you wanted to uh have a statelessly

1274
00:52:59,240 --> 00:53:01,380
updatable vector commitment say we're

1275
00:53:01,380 --> 00:53:04,079
like um you know you have the verifier

1276
00:53:04,079 --> 00:53:06,180
holds some commitment to a vector and

1277
00:53:06,180 --> 00:53:09,119
then I want to like aggregate uh updates

1278
00:53:09,119 --> 00:53:10,380
to this Vector from lots of different

1279
00:53:10,380 --> 00:53:11,640
parties none of the parties that I'm

1280
00:53:11,640 --> 00:53:12,780
aggregated from need to know anything

1281
00:53:12,780 --> 00:53:14,160
about the vector commitment they just

1282
00:53:14,160 --> 00:53:15,359
need to know the index they want to

1283
00:53:15,359 --> 00:53:17,700
update to maybe the like Delta of the

1284
00:53:17,700 --> 00:53:20,160
entry so yeah this could be um this

1285
00:53:20,160 --> 00:53:21,420
could be a nice application nice but

1286
00:53:21,420 --> 00:53:22,740
maybe I didn't really understand your

1287
00:53:22,740 --> 00:53:25,319
question yeah and that makes sense so I

1288
00:53:25,319 --> 00:53:27,720
have a quick follow-up so when you apply

1289
00:53:27,720 --> 00:53:30,839
the linearity and um with the summation

1290
00:53:30,839 --> 00:53:32,819
of two functions or multiple functions

1291
00:53:32,819 --> 00:53:34,740
so how do you handle the situation where

1292
00:53:34,740 --> 00:53:37,140
the the norm of the the opening will

1293
00:53:37,140 --> 00:53:39,180
grow if you add together yeah yeah so

1294
00:53:39,180 --> 00:53:40,859
definitely your modulus needs to account

1295
00:53:40,859 --> 00:53:42,780
for that for that growth

1296
00:53:42,780 --> 00:53:44,339
um in that sense you can think of this

1297
00:53:44,339 --> 00:53:46,319
as like sub supporting leveled level

1298
00:53:46,319 --> 00:53:49,160
updates yeah

1299
00:53:50,940 --> 00:53:53,339
thanks for the talk I have two related

1300
00:53:53,339 --> 00:53:55,920
questions uh first one is uh what is the

1301
00:53:55,920 --> 00:53:59,099
complexity of computing CF yeah yeah

1302
00:53:59,099 --> 00:54:01,140
that's a really good question

1303
00:54:01,140 --> 00:54:02,579
um I think I'll go back to that slide

1304
00:54:02,579 --> 00:54:04,740
because there's no real but um you can

1305
00:54:04,740 --> 00:54:05,760
think of it as just running the

1306
00:54:05,760 --> 00:54:08,160
arithmetic Circuit of f so there's like

1307
00:54:08,160 --> 00:54:10,140
in the paper we go over this but there's

1308
00:54:10,140 --> 00:54:12,839
kind of um analogous operations uh so

1309
00:54:12,839 --> 00:54:14,280
for each gate of the arithmetic circuit

1310
00:54:14,280 --> 00:54:16,500
uh you have some Matrix operation that

1311
00:54:16,500 --> 00:54:19,020
you use to compute C sub F and then yeah

1312
00:54:19,020 --> 00:54:20,819
you're essentially just running through

1313
00:54:20,819 --> 00:54:23,280
the authentic Circuit of f yeah okay and

1314
00:54:23,280 --> 00:54:25,680
can we say that the the stateless update

1315
00:54:25,680 --> 00:54:27,960
that you mentioned since we like reset C

1316
00:54:27,960 --> 00:54:31,140
with CF does it have the same complexity

1317
00:54:31,140 --> 00:54:34,140
as Computing CF or it's much less

1318
00:54:34,140 --> 00:54:36,059
so if you already know C sub F you don't

1319
00:54:36,059 --> 00:54:39,480
have to Recon recompute it the size of C

1320
00:54:39,480 --> 00:54:41,040
sub F will just like it will have to

1321
00:54:41,040 --> 00:54:43,440
handle the input to uh G I suppose but

1322
00:54:43,440 --> 00:54:45,059
really yeah you just start with C sub F

1323
00:54:45,059 --> 00:54:46,740
and you just can continue your

1324
00:54:46,740 --> 00:54:49,740
arithmetic circuit on G yeah

1325
00:54:49,740 --> 00:54:52,680
okay so the the stateless update is just

1326
00:54:52,680 --> 00:54:54,900
the complete like would be comparable to

1327
00:54:54,900 --> 00:54:57,180
Computing G in that case yeah yeah yeah

1328
00:54:57,180 --> 00:54:59,579
or the prover the verifier only ever

1329
00:54:59,579 --> 00:55:03,420
needs to do yeah yeah thanks

1330
00:55:05,640 --> 00:55:08,280
hello thank you for the very nice talk I

1331
00:55:08,280 --> 00:55:09,960
just had a question about Vector

1332
00:55:09,960 --> 00:55:13,079
commitments sure uh so does your

1333
00:55:13,079 --> 00:55:15,540
framework allow to open at multiple

1334
00:55:15,540 --> 00:55:18,059
positions or functions of multiple

1335
00:55:18,059 --> 00:55:21,780
positions at once yeah so yes although

1336
00:55:21,780 --> 00:55:23,640
it's not like a sub vector vector

1337
00:55:23,640 --> 00:55:25,200
commitment in the sense of like the

1338
00:55:25,200 --> 00:55:26,240
efficiency

1339
00:55:26,240 --> 00:55:28,559
requirements are not really like you're

1340
00:55:28,559 --> 00:55:29,940
just going to grow with with the the

1341
00:55:29,940 --> 00:55:32,460
number of uh indices that you want to

1342
00:55:32,460 --> 00:55:34,440
open to although you can do the

1343
00:55:34,440 --> 00:55:37,260
stateless composability very naturally

1344
00:55:37,260 --> 00:55:38,640
where like you know if you don't want to

1345
00:55:38,640 --> 00:55:40,980
open to the actual Vector element you

1346
00:55:40,980 --> 00:55:42,180
just want to open to like say the bit

1347
00:55:42,180 --> 00:55:43,619
parity of the vector element you can

1348
00:55:43,619 --> 00:55:45,780
easily update your vector commitment to

1349
00:55:45,780 --> 00:55:48,240
one that just opens to like the the bit

1350
00:55:48,240 --> 00:55:51,720
parity of that vector and um yeah the uh

1351
00:55:51,720 --> 00:55:54,180
the verification is always the same okay

1352
00:55:54,180 --> 00:55:56,779
thank you

1353
00:55:57,300 --> 00:55:59,099
okay so thank you let's thank the

1354
00:55:59,099 --> 00:56:01,520
speaker again

1355
00:56:05,819 --> 00:56:08,700
so we now have a track switching brake

1356
00:56:08,700 --> 00:56:11,700
and so we come back in 10 minutes for

1357
00:56:11,700 --> 00:56:13,920
the continuation of the volumorphic

1358
00:56:13,920 --> 00:56:16,700
encryption session

1359
00:56:17,099 --> 00:56:19,640
all right

