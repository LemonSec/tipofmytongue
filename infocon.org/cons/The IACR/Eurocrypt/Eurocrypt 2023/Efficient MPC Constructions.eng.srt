1
00:00:00,060 --> 00:00:03,959
welcome to the session on uh efficient

2
00:00:03,959 --> 00:00:06,899
MPC constructions this is going to have

3
00:00:06,899 --> 00:00:09,960
four talks there will be a track

4
00:00:09,960 --> 00:00:14,340
switching brake after the second talk

5
00:00:14,340 --> 00:00:19,440
um and yeah the first talk is going to

6
00:00:19,440 --> 00:00:22,560
be sub-linear communication secure

7
00:00:22,560 --> 00:00:24,920
multi-party computation does not require

8
00:00:24,920 --> 00:00:27,779
fully homomorphic encryption this is by

9
00:00:27,779 --> 00:00:33,780
Ellet Boyle Jeff Koto and appear Meyer

10
00:00:33,780 --> 00:00:39,260
and Pierre is going to give the talk

11
00:00:40,040 --> 00:00:42,960
just checking something out excellent

12
00:00:42,960 --> 00:00:45,899
hello everyone thank you all for coming

13
00:00:45,899 --> 00:00:49,379
and welcome to the to the session on not

14
00:00:49,379 --> 00:00:51,379
so efficient NPC

15
00:00:51,379 --> 00:00:54,539
I'm here to tell you to talk about how

16
00:00:54,539 --> 00:00:56,039
sublinear communication secure

17
00:00:56,039 --> 00:00:57,780
multi-party computation does not require

18
00:00:57,780 --> 00:01:00,300
fully homomorphic encryption which is

19
00:01:00,300 --> 00:01:03,620
joint work with the lead boylanger

20
00:01:04,319 --> 00:01:07,260
now what I mean by not so efficient is

21
00:01:07,260 --> 00:01:09,420
that you know you should know in no way

22
00:01:09,420 --> 00:01:11,760
think of our scheme as being concretely

23
00:01:11,760 --> 00:01:12,840
efficient

24
00:01:12,840 --> 00:01:15,600
uh let's say let's say what we're trying

25
00:01:15,600 --> 00:01:18,900
to do is to we see fully homomorphic

26
00:01:18,900 --> 00:01:21,000
encryption as a very you know heavy

27
00:01:21,000 --> 00:01:24,479
hammer for the problem of MPC and we're

28
00:01:24,479 --> 00:01:26,159
asking the question is this really

29
00:01:26,159 --> 00:01:29,460
required or can we do without

30
00:01:29,460 --> 00:01:31,799
now first of all what do I mean by

31
00:01:31,799 --> 00:01:33,360
sublinear communication secure

32
00:01:33,360 --> 00:01:35,159
computation

33
00:01:35,159 --> 00:01:38,159
just think of the two-part setting for

34
00:01:38,159 --> 00:01:40,860
now Alice and Bob wish to compute some

35
00:01:40,860 --> 00:01:43,380
fixed circuit C of their inputs and they

36
00:01:43,380 --> 00:01:44,939
wish to perform the computation without

37
00:01:44,939 --> 00:01:46,860
having to trust each other with their

38
00:01:46,860 --> 00:01:48,680
inputs

39
00:01:48,680 --> 00:01:50,759
now we know how to do this we have

40
00:01:50,759 --> 00:01:52,700
protocols to achieve this since the 80s

41
00:01:52,700 --> 00:01:56,240
but most the communication required

42
00:01:56,240 --> 00:01:59,520
scales with the size of the circuit so

43
00:01:59,520 --> 00:02:00,899
you'd have to communicate for each gate

44
00:02:00,899 --> 00:02:02,100
in the circuit

45
00:02:02,100 --> 00:02:04,619
and you know since most people would

46
00:02:04,619 --> 00:02:06,960
agree that communicating is hard we'd

47
00:02:06,960 --> 00:02:09,239
like to ask you know can we save out

48
00:02:09,239 --> 00:02:10,800
communication

49
00:02:10,800 --> 00:02:12,660
and specifically I'm interested in

50
00:02:12,660 --> 00:02:15,360
whether you know we can go beyond the

51
00:02:15,360 --> 00:02:17,580
gate by gate approach and Achieve secure

52
00:02:17,580 --> 00:02:19,260
computation with only a sub-linear

53
00:02:19,260 --> 00:02:22,379
amount of communication

54
00:02:22,379 --> 00:02:24,599
now there are two big families of

55
00:02:24,599 --> 00:02:27,480
protocols in this setting either you

56
00:02:27,480 --> 00:02:30,060
consider specific tasks you know like

57
00:02:30,060 --> 00:02:31,920
some specialized circuits for instance

58
00:02:31,920 --> 00:02:34,500
private information retrieval or you aim

59
00:02:34,500 --> 00:02:36,660
for a class of General circuits and our

60
00:02:36,660 --> 00:02:38,879
work is very much on the second in this

61
00:02:38,879 --> 00:02:41,220
in this second side like we'd like to do

62
00:02:41,220 --> 00:02:43,500
you know as wide the circuit class as

63
00:02:43,500 --> 00:02:46,800
possible now for technical reasons uh

64
00:02:46,800 --> 00:02:49,560
basically we're stuck at a low depth

65
00:02:49,560 --> 00:02:52,019
circuits and um

66
00:02:52,019 --> 00:02:53,640
and I'm going to explain what a lead

67
00:02:53,640 --> 00:02:55,080
circuit is in just a minute and like

68
00:02:55,080 --> 00:02:56,459
what's the relationship between the two

69
00:02:56,459 --> 00:03:00,599
but uh in in case you're interested in

70
00:03:00,599 --> 00:03:02,760
like the specific you know MPC model

71
00:03:02,760 --> 00:03:05,040
think of semi honest adversaries

72
00:03:05,040 --> 00:03:06,540
everyone will be following the protocol

73
00:03:06,540 --> 00:03:09,900
even corrupted parties and uh you know

74
00:03:09,900 --> 00:03:13,280
all but one Corruptions

75
00:03:13,800 --> 00:03:15,720
now what is alert circuit this is the

76
00:03:15,720 --> 00:03:17,760
circuit we're trying to compute

77
00:03:17,760 --> 00:03:19,980
um well a circuit is said to be led if

78
00:03:19,980 --> 00:03:23,040
you can like put the the gates into

79
00:03:23,040 --> 00:03:25,800
layers and the wire doesn't jump through

80
00:03:25,800 --> 00:03:27,659
the circuit it only goes from one layer

81
00:03:27,659 --> 00:03:29,040
to the next

82
00:03:29,040 --> 00:03:30,959
and now why is these structured circuits

83
00:03:30,959 --> 00:03:33,180
are nice for us is that you can always

84
00:03:33,180 --> 00:03:36,120
break down computation into small and

85
00:03:36,120 --> 00:03:39,180
you know like say log depth chunks

86
00:03:39,180 --> 00:03:42,900
and you know trust me on this if we know

87
00:03:42,900 --> 00:03:44,400
how to do

88
00:03:44,400 --> 00:03:46,980
a very low depth circuits but arbitrary

89
00:03:46,980 --> 00:03:48,540
you know arbitrary circuits very low

90
00:03:48,540 --> 00:03:50,640
depth with a very small amount of

91
00:03:50,640 --> 00:03:52,620
communication this translates into

92
00:03:52,620 --> 00:03:54,599
breaking the the circuit-sized barrier

93
00:03:54,599 --> 00:03:59,659
for arbitrary depth lead circuits

94
00:04:00,540 --> 00:04:03,000
so the question is do we know how to do

95
00:04:03,000 --> 00:04:04,980
sublinear Circle computation

96
00:04:04,980 --> 00:04:07,920
for now two-party setting

97
00:04:07,920 --> 00:04:10,080
uh the answer is yes and you know until

98
00:04:10,080 --> 00:04:11,879
recently we had three different ways of

99
00:04:11,879 --> 00:04:13,799
doing it now if you use fully

100
00:04:13,799 --> 00:04:15,599
homomorphic encryption or homomorphic

101
00:04:15,599 --> 00:04:17,459
SQL sharing you'll get computational

102
00:04:17,459 --> 00:04:20,339
guarantees and if you use corrected

103
00:04:20,339 --> 00:04:21,600
Randomness you can achieve information

104
00:04:21,600 --> 00:04:24,540
theoretic security

105
00:04:24,540 --> 00:04:26,820
and in turn these three paradigms

106
00:04:26,820 --> 00:04:29,759
yielded protocols from a variety of

107
00:04:29,759 --> 00:04:31,620
different assumptions

108
00:04:31,620 --> 00:04:33,840
computational or otherwise

109
00:04:33,840 --> 00:04:35,479
now

110
00:04:35,479 --> 00:04:37,440
this was the state of the art enter

111
00:04:37,440 --> 00:04:38,460
recently

112
00:04:38,460 --> 00:04:40,620
and so we'd say you know we have many

113
00:04:40,620 --> 00:04:42,240
ways of achieving secure computation

114
00:04:42,240 --> 00:04:44,460
sublinear secure computation sorry

115
00:04:44,460 --> 00:04:45,660
but

116
00:04:45,660 --> 00:04:47,759
um we we asked ourselves to you can we

117
00:04:47,759 --> 00:04:50,100
build the tool which is like a lot more

118
00:04:50,100 --> 00:04:52,560
focused on achieving sublinear circular

119
00:04:52,560 --> 00:04:54,180
computation

120
00:04:54,180 --> 00:04:56,520
which led us last year to introduce the

121
00:04:56,520 --> 00:04:59,220
object of correlated symmetric pair

122
00:04:59,220 --> 00:05:03,360
which I'm going to explain what it is in

123
00:05:03,360 --> 00:05:04,979
just a minute because we're going to use

124
00:05:04,979 --> 00:05:07,320
it today and I guess it's not a standard

125
00:05:07,320 --> 00:05:10,280
assumption yet

126
00:05:10,440 --> 00:05:12,780
so okay first of all what is symmetric

127
00:05:12,780 --> 00:05:14,520
pair I guess most of you are familiar

128
00:05:14,520 --> 00:05:17,820
with this Alice yes in this case Alice

129
00:05:17,820 --> 00:05:19,979
is the client she has an index and Bob

130
00:05:19,979 --> 00:05:22,320
has a database and the goal is to allow

131
00:05:22,320 --> 00:05:25,020
the client to retrieve the element of

132
00:05:25,020 --> 00:05:27,539
her choice in the database in a private

133
00:05:27,539 --> 00:05:28,560
manner

134
00:05:28,560 --> 00:05:30,900
now I'd like to just you know what's

135
00:05:30,900 --> 00:05:33,060
perhaps a tiny bit less standard is this

136
00:05:33,060 --> 00:05:34,919
notion of symmetric privacy

137
00:05:34,919 --> 00:05:36,960
which simply means that you would want

138
00:05:36,960 --> 00:05:39,180
the server also has some privacy

139
00:05:39,180 --> 00:05:40,800
guarantees and that the client only

140
00:05:40,800 --> 00:05:43,440
retrieves a single index

141
00:05:43,440 --> 00:05:44,639
but

142
00:05:44,639 --> 00:05:46,259
um yeah and you can see this as a very

143
00:05:46,259 --> 00:05:49,699
specialized form of secure computation

144
00:05:50,820 --> 00:05:53,460
now now to our primitive correlated

145
00:05:53,460 --> 00:05:54,600
symmetric pair

146
00:05:54,600 --> 00:05:56,340
I want to emphasize that this is a

147
00:05:56,340 --> 00:05:58,380
two-party primitive as in you have a

148
00:05:58,380 --> 00:06:00,419
single client and the single server but

149
00:06:00,419 --> 00:06:02,580
that they would like to be doing a bunch

150
00:06:02,580 --> 00:06:05,940
of symmetric peers in parallel

151
00:06:05,940 --> 00:06:09,720
and this correlated part is that the

152
00:06:09,720 --> 00:06:11,280
client doesn't want to retrieve

153
00:06:11,280 --> 00:06:13,139
arbitrary indices from all of the

154
00:06:13,139 --> 00:06:15,120
databases but like all of the queries

155
00:06:15,120 --> 00:06:17,400
are highly correlated in the public

156
00:06:17,400 --> 00:06:18,479
manner

157
00:06:18,479 --> 00:06:21,060
and you would only want to pay the

158
00:06:21,060 --> 00:06:22,800
communication

159
00:06:22,800 --> 00:06:24,380
to pay a cost of communication

160
00:06:24,380 --> 00:06:26,940
proportionally to the entropy of the

161
00:06:26,940 --> 00:06:29,759
queries not to you know the concatenated

162
00:06:29,759 --> 00:06:32,060
size of all of them

163
00:06:32,060 --> 00:06:34,440
if you think about it for a minute you

164
00:06:34,440 --> 00:06:38,520
know using rate one fhc you can do this

165
00:06:38,520 --> 00:06:40,680
but what we showed last year is that you

166
00:06:40,680 --> 00:06:43,020
can in fact do it from A Primitive which

167
00:06:43,020 --> 00:06:44,940
is morally much closer to linearly

168
00:06:44,940 --> 00:06:46,919
homomorphic encryption which is good

169
00:06:46,919 --> 00:06:48,419
news if we're trying to get rid of fhe

170
00:06:48,419 --> 00:06:49,979
for the task of sublinear circle

171
00:06:49,979 --> 00:06:51,780
computation

172
00:06:51,780 --> 00:06:54,240
so we'll be using this primitive a bit

173
00:06:54,240 --> 00:06:56,400
later in the talk

174
00:06:56,400 --> 00:06:58,860
but now let's go back to uh you know the

175
00:06:58,860 --> 00:07:00,300
set of assumptions which are known to

176
00:07:00,300 --> 00:07:02,580
imply sublimitical computation

177
00:07:02,580 --> 00:07:04,440
I'm forgetting about security randoms

178
00:07:04,440 --> 00:07:06,419
for now because since in that model

179
00:07:06,419 --> 00:07:08,100
we're not counting the communication

180
00:07:08,100 --> 00:07:10,740
necessary for the setup it's more about

181
00:07:10,740 --> 00:07:13,259
sublinear online communication

182
00:07:13,259 --> 00:07:15,660
but you know so basically we have three

183
00:07:15,660 --> 00:07:17,460
different ways of breaking the circuit

184
00:07:17,460 --> 00:07:19,139
size barrier from computational

185
00:07:19,139 --> 00:07:21,120
assumptions

186
00:07:21,120 --> 00:07:23,460
and um

187
00:07:23,460 --> 00:07:25,560
this was all of this was in the two-part

188
00:07:25,560 --> 00:07:27,599
setting and you can ask yourself what

189
00:07:27,599 --> 00:07:29,520
about the multi-part setting and

190
00:07:29,520 --> 00:07:32,699
unfortunately you know we much you know

191
00:07:32,699 --> 00:07:35,580
we we don't know much or at least we did

192
00:07:35,580 --> 00:07:37,979
yesterday uh because what I'm going to

193
00:07:37,979 --> 00:07:39,960
so what we're going to show in this talk

194
00:07:39,960 --> 00:07:41,759
is that if you combine

195
00:07:41,759 --> 00:07:44,520
the two objects that were only known to

196
00:07:44,520 --> 00:07:46,800
yield two-party computation

197
00:07:46,800 --> 00:07:48,300
then there's a way to put them together

198
00:07:48,300 --> 00:07:52,139
and achieve multi-party

199
00:07:52,139 --> 00:07:54,599
secure computation with sublinear

200
00:07:54,599 --> 00:07:56,520
communication which was previously only

201
00:07:56,520 --> 00:07:59,280
known from fhe

202
00:07:59,280 --> 00:08:00,900
so a bit more formally what are the

203
00:08:00,900 --> 00:08:02,580
results I want to talk about today

204
00:08:02,580 --> 00:08:05,220
so I want to to you know expose a

205
00:08:05,220 --> 00:08:08,160
framework so it's a protocol

206
00:08:08,160 --> 00:08:08,819
um

207
00:08:08,819 --> 00:08:11,460
which does not use fhe

208
00:08:11,460 --> 00:08:13,740
and in turns in turn it can be

209
00:08:13,740 --> 00:08:15,419
instantiated on the concrete assumptions

210
00:08:15,419 --> 00:08:18,979
for three four or five parties

211
00:08:19,139 --> 00:08:21,780
uh so first of all I'd like to emphasize

212
00:08:21,780 --> 00:08:24,000
that we use true tools you know we're

213
00:08:24,000 --> 00:08:25,680
putting together two tools to achieve n

214
00:08:25,680 --> 00:08:27,900
plus one party computation the first is

215
00:08:27,900 --> 00:08:29,759
an n-party primitive and the other one

216
00:08:29,759 --> 00:08:31,500
is a two-party primitive so there's

217
00:08:31,500 --> 00:08:33,240
really you know we're not cheating in

218
00:08:33,240 --> 00:08:35,880
order to achieve n plus one party

219
00:08:35,880 --> 00:08:39,059
and um as I said earlier the class of

220
00:08:39,059 --> 00:08:41,580
computation will be handling is either

221
00:08:41,580 --> 00:08:43,860
locked up circuit log log depth circuit

222
00:08:43,860 --> 00:08:46,980
sorry or LED circuits by the

223
00:08:46,980 --> 00:08:48,899
transformation that I showed earlier

224
00:08:48,899 --> 00:08:50,640
now for the most of this talk I'll

225
00:08:50,640 --> 00:08:52,740
actually be focusing on log depth

226
00:08:52,740 --> 00:08:54,480
circuits with very low communication

227
00:08:54,480 --> 00:08:56,880
what I mean is essentially Optimum so

228
00:08:56,880 --> 00:08:59,040
basically like linear in input plus

229
00:08:59,040 --> 00:09:00,959
output size

230
00:09:00,959 --> 00:09:03,779
um but you know so so uh I'll be going

231
00:09:03,779 --> 00:09:05,459
back and forth so if I say optimal

232
00:09:05,459 --> 00:09:07,500
communication and sublinear it usually

233
00:09:07,500 --> 00:09:09,060
means I'm thinking about one of the two

234
00:09:09,060 --> 00:09:12,260
settings but it's the same thing

235
00:09:12,959 --> 00:09:15,600
so what is this template

236
00:09:15,600 --> 00:09:18,060
um so you have to read this from top to

237
00:09:18,060 --> 00:09:20,100
bottom let's not think about efficiency

238
00:09:20,100 --> 00:09:22,140
at all for now let's just see like you

239
00:09:22,140 --> 00:09:24,060
know how how things work

240
00:09:24,060 --> 00:09:26,459
so you have n plus one parties these are

241
00:09:26,459 --> 00:09:29,100
the circled P0 P1 to PN

242
00:09:29,100 --> 00:09:31,580
and they're going to play different

243
00:09:31,580 --> 00:09:34,320
P0 is going to play a special role and

244
00:09:34,320 --> 00:09:36,300
P1 to PN have symmetric roles in the

245
00:09:36,300 --> 00:09:37,800
computation

246
00:09:37,800 --> 00:09:40,320
so these boxes are ideal functionalities

247
00:09:40,320 --> 00:09:42,180
you can think of it as just you know

248
00:09:42,180 --> 00:09:44,220
some computation providing the

249
00:09:44,220 --> 00:09:47,580
guarantees uh written Inside the Box so

250
00:09:47,580 --> 00:09:49,620
first of all the first

251
00:09:49,620 --> 00:09:51,839
let's say you want to to compute the

252
00:09:51,839 --> 00:09:55,260
circuit C which has you know which has n

253
00:09:55,260 --> 00:09:57,240
plus one set of inputs shared between

254
00:09:57,240 --> 00:09:59,040
the players

255
00:09:59,040 --> 00:10:00,839
so what P1 and P are not going to do

256
00:10:00,839 --> 00:10:03,720
first is going to send their input into

257
00:10:03,720 --> 00:10:06,540
the box which is going to hard code

258
00:10:06,540 --> 00:10:09,720
their inputs into the circuit and secret

259
00:10:09,720 --> 00:10:13,620
share that function so for now think of

260
00:10:13,620 --> 00:10:15,899
you know a naive SQL chairing just take

261
00:10:15,899 --> 00:10:17,399
the truth table and secret share it

262
00:10:17,399 --> 00:10:19,680
additively among the patches

263
00:10:19,680 --> 00:10:23,160
so now each part's API holds some some

264
00:10:23,160 --> 00:10:25,260
share of the function f i

265
00:10:25,260 --> 00:10:27,060
so you can either see this as a function

266
00:10:27,060 --> 00:10:29,519
share or like I do it like I like to

267
00:10:29,519 --> 00:10:31,860
think about it you can think of fi as

268
00:10:31,860 --> 00:10:36,120
being a function which on inputs x0

269
00:10:36,120 --> 00:10:39,720
gives you a share of f of x0 but you can

270
00:10:39,720 --> 00:10:41,760
also see it as just simply a share of

271
00:10:41,760 --> 00:10:43,140
the function f

272
00:10:43,140 --> 00:10:45,120
so now that all of the parties P1 to be

273
00:10:45,120 --> 00:10:46,740
in each have their share of the function

274
00:10:46,740 --> 00:10:49,500
in which they hard-coded their inputs

275
00:10:49,500 --> 00:10:52,260
um say each pairwise perform an

276
00:10:52,260 --> 00:10:55,200
oblivious evaluation with

277
00:10:55,200 --> 00:10:57,540
with the last part gp0

278
00:10:57,540 --> 00:10:59,100
so what's in the believer's evaluation

279
00:10:59,100 --> 00:11:03,600
it means that P0 holds some input and

280
00:11:03,600 --> 00:11:06,600
each party Pi the other one holds some

281
00:11:06,600 --> 00:11:09,300
function and the goal is to allow P0 to

282
00:11:09,300 --> 00:11:11,579
evaluate the other party's function on

283
00:11:11,579 --> 00:11:15,959
exactly one point and in this case on x0

284
00:11:15,959 --> 00:11:16,920
so

285
00:11:16,920 --> 00:11:18,660
hopefully it's simple enough that you

286
00:11:18,660 --> 00:11:19,740
know we can

287
00:11:19,740 --> 00:11:22,680
Intuit why why is this is secure so

288
00:11:22,680 --> 00:11:24,600
let's say you only corrupt a subset of

289
00:11:24,600 --> 00:11:26,519
the parties P1 to PN

290
00:11:26,519 --> 00:11:29,040
because you do not have access to all of

291
00:11:29,040 --> 00:11:30,600
the function chairs you don't know

292
00:11:30,600 --> 00:11:32,100
anything about the inputs which were

293
00:11:32,100 --> 00:11:34,380
hard-coded that you didn't already know

294
00:11:34,380 --> 00:11:37,740
and even if you also corrupt P0 the last

295
00:11:37,740 --> 00:11:39,720
party because of the oblivious

296
00:11:39,720 --> 00:11:40,860
evaluation

297
00:11:40,860 --> 00:11:43,019
is the only information you go know

298
00:11:43,019 --> 00:11:44,459
about the function shares that you did

299
00:11:44,459 --> 00:11:47,040
not already know is a single evaluation

300
00:11:47,040 --> 00:11:49,260
and the single evaluation is the output

301
00:11:49,260 --> 00:11:50,760
share which you are always allowed to

302
00:11:50,760 --> 00:11:52,939
have

303
00:11:53,040 --> 00:11:55,560
but now this protocol is it's sort of

304
00:11:55,560 --> 00:11:57,240
under specified it's more of a template

305
00:11:57,240 --> 00:11:59,579
than an actual protocol why because I

306
00:11:59,579 --> 00:12:01,740
said you know okay assume we have a way

307
00:12:01,740 --> 00:12:04,920
to secret share a function and um

308
00:12:04,920 --> 00:12:07,320
uh it's unclear that this can even be

309
00:12:07,320 --> 00:12:09,300
done in polynomial time and even less

310
00:12:09,300 --> 00:12:11,399
with polynomial computation or sublinear

311
00:12:11,399 --> 00:12:13,320
communication

312
00:12:13,320 --> 00:12:16,560
so in order to do that we need a tool

313
00:12:16,560 --> 00:12:18,959
known as function SQL sharing and the

314
00:12:18,959 --> 00:12:20,399
high level idea is simply we want to

315
00:12:20,399 --> 00:12:21,779
take effect we want to be able to

316
00:12:21,779 --> 00:12:24,600
succinctly generate these shares of some

317
00:12:24,600 --> 00:12:26,279
secret function

318
00:12:26,279 --> 00:12:28,560
so formally an FSS scheme is a pair of

319
00:12:28,560 --> 00:12:31,980
algorithms FSS gen and SSC value

320
00:12:31,980 --> 00:12:34,320
so just to be explicit the goal is to be

321
00:12:34,320 --> 00:12:36,480
able to SQL share a function such that

322
00:12:36,480 --> 00:12:38,459
and then you can evaluate the function

323
00:12:38,459 --> 00:12:40,980
shares on some on some you know public

324
00:12:40,980 --> 00:12:42,660
input

325
00:12:42,660 --> 00:12:44,579
in order to get each part you can get a

326
00:12:44,579 --> 00:12:47,940
share and then you can reconstruct

327
00:12:47,940 --> 00:12:50,279
now you can think of function SQL

328
00:12:50,279 --> 00:12:52,860
sharing as a way to compress these

329
00:12:52,860 --> 00:12:56,959
function shares down to tiny keys

330
00:12:57,180 --> 00:12:59,519
in particular

331
00:12:59,519 --> 00:13:00,480
um

332
00:13:00,480 --> 00:13:01,920
every party

333
00:13:01,920 --> 00:13:04,200
on the right like using function SQL

334
00:13:04,200 --> 00:13:06,420
sharing gets an evaluation key so what's

335
00:13:06,420 --> 00:13:08,760
that's one of the kis and if you hard

336
00:13:08,760 --> 00:13:11,639
code the evaluation key into the

337
00:13:11,639 --> 00:13:14,279
FSS evaluation algorithm

338
00:13:14,279 --> 00:13:16,200
then you can think of this function as

339
00:13:16,200 --> 00:13:19,620
being a share of the function f

340
00:13:19,620 --> 00:13:22,740
okay so let now that we've seen how you

341
00:13:22,740 --> 00:13:23,940
know

342
00:13:23,940 --> 00:13:26,399
how a function can be secret shared

343
00:13:26,399 --> 00:13:28,380
somewhat efficiently let's see what it

344
00:13:28,380 --> 00:13:30,600
looks like in our template

345
00:13:30,600 --> 00:13:33,540
so I haven't done anything except

346
00:13:33,540 --> 00:13:37,019
I've said instead of generating shares

347
00:13:37,019 --> 00:13:38,519
of the function I'm Distributing

348
00:13:38,519 --> 00:13:40,079
evaluation keys

349
00:13:40,079 --> 00:13:41,639
and then instead of obliviously

350
00:13:41,639 --> 00:13:43,440
evaluating a function share I'm

351
00:13:43,440 --> 00:13:45,300
obliviously evaluating the FSS

352
00:13:45,300 --> 00:13:48,120
evaluation procedure

353
00:13:48,120 --> 00:13:51,180
so you keep at this point

354
00:13:51,180 --> 00:13:55,440
I claim that if I if I am given an end

355
00:13:55,440 --> 00:13:58,019
party function SQL sharing scheme such

356
00:13:58,019 --> 00:13:59,940
that all of these boxes can be done with

357
00:13:59,940 --> 00:14:01,620
low enough communication

358
00:14:01,620 --> 00:14:03,600
so specifically what I need is a

359
00:14:03,600 --> 00:14:05,579
function SQL sharing scheme

360
00:14:05,579 --> 00:14:08,279
whose key generation procedure can be

361
00:14:08,279 --> 00:14:10,620
done can be distributed efficiently

362
00:14:10,620 --> 00:14:12,060
it's first condition

363
00:14:12,060 --> 00:14:14,100
and second condition such that the

364
00:14:14,100 --> 00:14:15,899
evaluation keys can be obliviously

365
00:14:15,899 --> 00:14:17,160
evaluated

366
00:14:17,160 --> 00:14:19,320
with low enough communication

367
00:14:19,320 --> 00:14:21,959
then overall we'll get a secure

368
00:14:21,959 --> 00:14:24,540
computation protocol for the

369
00:14:24,540 --> 00:14:27,000
n plus one party circuit C

370
00:14:27,000 --> 00:14:29,040
with overall

371
00:14:29,040 --> 00:14:31,800
optimal to you know very low sublinear

372
00:14:31,800 --> 00:14:33,779
depending on how you think about it low

373
00:14:33,779 --> 00:14:37,459
communication protocol 4C

374
00:14:37,980 --> 00:14:40,320
now the question is can we you know can

375
00:14:40,320 --> 00:14:43,260
we build such an FSS scheme and if you

376
00:14:43,260 --> 00:14:44,579
think about it you know I said I said

377
00:14:44,579 --> 00:14:47,699
there were two two main properties we I

378
00:14:47,699 --> 00:14:49,860
need to address the key distribution is

379
00:14:49,860 --> 00:14:51,240
a key distribution and the oblivious

380
00:14:51,240 --> 00:14:52,680
evaluation

381
00:14:52,680 --> 00:14:56,160
now since keys are fairly short it's

382
00:14:56,160 --> 00:14:57,779
perhaps not too surprising that this

383
00:14:57,779 --> 00:15:00,500
procedure can be done efficiently

384
00:15:00,500 --> 00:15:02,639
oblivious evaluation on the other hand

385
00:15:02,639 --> 00:15:04,860
since evaluation can be as hard as the

386
00:15:04,860 --> 00:15:06,720
original function the original circuit

387
00:15:06,720 --> 00:15:08,459
we are trying to compute that's the key

388
00:15:08,459 --> 00:15:11,339
step and basically what I need here is a

389
00:15:11,339 --> 00:15:13,620
very specialized two-party computation

390
00:15:13,620 --> 00:15:15,720
protocol with sublinear communication

391
00:15:15,720 --> 00:15:18,320
complexity

392
00:15:18,899 --> 00:15:20,639
and in fact we're going to use the tool

393
00:15:20,639 --> 00:15:22,800
I presented earlier correlated symmetric

394
00:15:22,800 --> 00:15:25,680
pair in order to to instantiate this

395
00:15:25,680 --> 00:15:28,620
very highly specialized uh correlated as

396
00:15:28,620 --> 00:15:30,540
this highly specialized oblivious

397
00:15:30,540 --> 00:15:32,279
evaluation

398
00:15:32,279 --> 00:15:34,800
so let's say you have a function G with

399
00:15:34,800 --> 00:15:36,480
you know two sets of inputs one for

400
00:15:36,480 --> 00:15:39,600
Alice one for Bob and what happens once

401
00:15:39,600 --> 00:15:40,680
Alice

402
00:15:40,680 --> 00:15:43,680
hard codes her own inputs in there

403
00:15:43,680 --> 00:15:45,720
so now the setting is Alice holds the

404
00:15:45,720 --> 00:15:49,620
secret function and Bob holds an input

405
00:15:49,620 --> 00:15:53,040
now under the assumption is that the you

406
00:15:53,040 --> 00:15:54,600
know this secret function with Alice's

407
00:15:54,600 --> 00:15:57,899
input hard-coded has low depth log log

408
00:15:57,899 --> 00:16:00,060
depth in Bob's input

409
00:16:00,060 --> 00:16:01,860
uh can we do

410
00:16:01,860 --> 00:16:04,980
oblivious evaluation of this circuit

411
00:16:04,980 --> 00:16:07,560
and the answer is yes using the simple

412
00:16:07,560 --> 00:16:10,500
observation that because I'm dealing

413
00:16:10,500 --> 00:16:12,959
with a circuit like where every gate be

414
00:16:12,959 --> 00:16:14,639
it an addition or a multiplication has

415
00:16:14,639 --> 00:16:16,320
fan in at most two

416
00:16:16,320 --> 00:16:19,199
each output in log log depth only

417
00:16:19,199 --> 00:16:21,060
depends on that most logarithmically

418
00:16:21,060 --> 00:16:24,839
many inputs so in turn each output gate

419
00:16:24,839 --> 00:16:27,180
of your circuit has a polynomial size

420
00:16:27,180 --> 00:16:29,160
truth table

421
00:16:29,160 --> 00:16:31,139
and now in order to evaluate the circuit

422
00:16:31,139 --> 00:16:33,300
what you can do you can have Alice

423
00:16:33,300 --> 00:16:35,820
prepare all of the truth tables they're

424
00:16:35,820 --> 00:16:38,519
all polynomial size and retrieve exactly

425
00:16:38,519 --> 00:16:39,660
one

426
00:16:39,660 --> 00:16:42,839
element from each of these databases

427
00:16:42,839 --> 00:16:45,720
and this queries are highly correlated I

428
00:16:45,720 --> 00:16:47,399
told you correlated symmetric pair with

429
00:16:47,399 --> 00:16:49,440
a public correlation so that's the

430
00:16:49,440 --> 00:16:52,620
topology of the circuit on some you know

431
00:16:52,620 --> 00:16:55,079
on some joint entropy some joint

432
00:16:55,079 --> 00:16:57,540
secretive Bobs and Bobs you know the

433
00:16:57,540 --> 00:16:59,279
entropy used to describe all of Bob's

434
00:16:59,279 --> 00:17:02,279
queries is simply his own input to the

435
00:17:02,279 --> 00:17:04,500
circuit

436
00:17:04,500 --> 00:17:08,179
so using corrected symmetric pair we can

437
00:17:08,179 --> 00:17:10,260
instantiate with essentially optimal

438
00:17:10,260 --> 00:17:12,359
communication this obligious evaluation

439
00:17:12,359 --> 00:17:14,579
procedure

440
00:17:14,579 --> 00:17:16,799
so if I now plug this back into the to

441
00:17:16,799 --> 00:17:19,020
the template to the you know end party

442
00:17:19,020 --> 00:17:21,000
FSS template

443
00:17:21,000 --> 00:17:23,099
all I've done here is I get said okay it

444
00:17:23,099 --> 00:17:25,859
used to be oblivious evaluation of the

445
00:17:25,859 --> 00:17:27,660
FSS eval

446
00:17:27,660 --> 00:17:30,660
I'm going to use corrected aspir

447
00:17:30,660 --> 00:17:33,000
so now the condition is

448
00:17:33,000 --> 00:17:36,419
can I build a an end party function SQL

449
00:17:36,419 --> 00:17:38,039
sharing scheme with efficient key

450
00:17:38,039 --> 00:17:41,400
distribution and such that the

451
00:17:41,400 --> 00:17:44,160
um evaluation can be no it can be done

452
00:17:44,160 --> 00:17:46,620
in low depth

453
00:17:46,620 --> 00:17:49,380
oh the question is can I do this so if I

454
00:17:49,380 --> 00:17:51,299
need fhe at this point this was all for

455
00:17:51,299 --> 00:17:53,160
nothing

456
00:17:53,160 --> 00:17:53,880
um

457
00:17:53,880 --> 00:17:56,400
and the answer is yes I I know how to

458
00:17:56,400 --> 00:17:59,280
build such an FSS scheme if the circuit

459
00:17:59,280 --> 00:18:01,740
I'm trying to compute is low depth

460
00:18:01,740 --> 00:18:03,960
and in turn this yields a protocol for

461
00:18:03,960 --> 00:18:05,880
lead circuits

462
00:18:05,880 --> 00:18:08,580
now what I could do is simply give you

463
00:18:08,580 --> 00:18:11,280
the FSS scheme and and you know show you

464
00:18:11,280 --> 00:18:12,840
how to instantiate the key generation

465
00:18:12,840 --> 00:18:15,179
procedure and the evaluation procedure

466
00:18:15,179 --> 00:18:18,000
but instead I'd like to go back to the

467
00:18:18,000 --> 00:18:20,340
original framework you know without even

468
00:18:20,340 --> 00:18:21,960
the FSS abstraction

469
00:18:21,960 --> 00:18:23,400
and now

470
00:18:23,400 --> 00:18:26,220
with the hypothesis that I'm I'm trying

471
00:18:26,220 --> 00:18:29,280
to compute a low depth circuit log log

472
00:18:29,280 --> 00:18:31,440
depth circuit specifically can I come up

473
00:18:31,440 --> 00:18:35,760
with a like a direct grounds up approach

474
00:18:35,760 --> 00:18:38,220
now just to remind you this is the

475
00:18:38,220 --> 00:18:39,960
original template and because I need

476
00:18:39,960 --> 00:18:42,059
space I'm going to put it in a corner

477
00:18:42,059 --> 00:18:44,880
so the first assumption is you know how

478
00:18:44,880 --> 00:18:47,100
how do I see contrary function and the

479
00:18:47,100 --> 00:18:48,480
first assumption I want to challenge is

480
00:18:48,480 --> 00:18:50,340
you know we are no longer thinking of

481
00:18:50,340 --> 00:18:52,200
SQL chart truth tables

482
00:18:52,200 --> 00:18:54,360
however the observation we made before

483
00:18:54,360 --> 00:18:56,880
is also during the setting

484
00:18:56,880 --> 00:18:58,860
all right if you have a load app circuit

485
00:18:58,860 --> 00:19:02,220
it can be represented by a bunch of

486
00:19:02,220 --> 00:19:05,660
polynomial size truth tables

487
00:19:06,059 --> 00:19:08,220
so how I'm going to secretize a function

488
00:19:08,220 --> 00:19:10,020
is I'm going to make sure that each

489
00:19:10,020 --> 00:19:13,080
party PI from P1 to PN is going to hold

490
00:19:13,080 --> 00:19:15,660
additive secret shares of these truth

491
00:19:15,660 --> 00:19:17,520
tables

492
00:19:17,520 --> 00:19:19,860
uh now how I'm going to do it I'm going

493
00:19:19,860 --> 00:19:21,960
to be very quick on the details but

494
00:19:21,960 --> 00:19:23,880
basically I'm going to use a tool known

495
00:19:23,880 --> 00:19:26,820
as homomorphic SQL sharing now just

496
00:19:26,820 --> 00:19:29,700
think about this it no no you can either

497
00:19:29,700 --> 00:19:31,799
trust me that there is a way to to

498
00:19:31,799 --> 00:19:33,660
generate these secret shares of these

499
00:19:33,660 --> 00:19:36,780
truth tables or if you want a bit more

500
00:19:36,780 --> 00:19:39,240
detail assume you have access to a

501
00:19:39,240 --> 00:19:40,559
secret sharing scheme with some

502
00:19:40,559 --> 00:19:42,240
homomorphic properties

503
00:19:42,240 --> 00:19:44,580
so the part is P1 to PN are going to

504
00:19:44,580 --> 00:19:46,440
generate secret shares of the vector of

505
00:19:46,440 --> 00:19:48,780
inputs X1 to xn

506
00:19:48,780 --> 00:19:50,460
and then you know now that they have

507
00:19:50,460 --> 00:19:51,960
their shares they're going to perform

508
00:19:51,960 --> 00:19:54,360
some homomorphic operation on the shares

509
00:19:54,360 --> 00:19:56,760
in order to homomorphically compute the

510
00:19:56,760 --> 00:19:59,400
function which on input X1 to xn

511
00:19:59,400 --> 00:20:02,160
generates these truth tables

512
00:20:02,160 --> 00:20:05,059
and while this is not entirely trivial

513
00:20:05,059 --> 00:20:07,380
it's it's not necessarily very important

514
00:20:07,380 --> 00:20:10,200
to see the details at this point

515
00:20:10,200 --> 00:20:14,100
so using the end party primitive of

516
00:20:14,100 --> 00:20:16,100
homomorphic equal sharing

517
00:20:16,100 --> 00:20:18,120
we can make sure the parties hold

518
00:20:18,120 --> 00:20:21,539
additive shares of the truth tables

519
00:20:21,539 --> 00:20:24,900
and now we can use correlated sphere

520
00:20:24,900 --> 00:20:27,539
to allow Bob to perform the oblivious

521
00:20:27,539 --> 00:20:29,340
evaluation

522
00:20:29,340 --> 00:20:31,980
and this is essentially how n-party HSS

523
00:20:31,980 --> 00:20:34,020
and the two-party primitive according to

524
00:20:34,020 --> 00:20:36,480
that aspir allows you to to not require

525
00:20:36,480 --> 00:20:38,760
fhe while doing sublinear secure

526
00:20:38,760 --> 00:20:39,960
computation

527
00:20:39,960 --> 00:20:42,960
four log log depth circuits

528
00:20:42,960 --> 00:20:46,320
now if you wanted to you could try and

529
00:20:46,320 --> 00:20:49,080
pass this and try and then I identify

530
00:20:49,080 --> 00:20:52,799
where the end party FSS is with log log

531
00:20:52,799 --> 00:20:55,260
depth evaluation whatever like you know

532
00:20:55,260 --> 00:20:56,700
what we talked in the first part of this

533
00:20:56,700 --> 00:20:59,039
talk but you can now also see this as a

534
00:20:59,039 --> 00:21:02,299
direct and Standalone Construction

535
00:21:03,480 --> 00:21:05,940
so to summarize we have a general

536
00:21:05,940 --> 00:21:07,260
framework

537
00:21:07,260 --> 00:21:09,360
with sort of abstract properties

538
00:21:09,360 --> 00:21:11,460
assuming we can secret share a function

539
00:21:11,460 --> 00:21:13,799
efficiently and evaluate and some

540
00:21:13,799 --> 00:21:16,740
specialized protocol to evaluate it

541
00:21:16,740 --> 00:21:19,740
computation

542
00:21:21,059 --> 00:21:23,760
and because of structural properties of

543
00:21:23,760 --> 00:21:25,679
log logdab circuits

544
00:21:25,679 --> 00:21:28,799
we can instantiate our framework using n

545
00:21:28,799 --> 00:21:30,480
part TFS HSS

546
00:21:30,480 --> 00:21:34,039
and correlated symmetric pair

547
00:21:34,740 --> 00:21:36,900
now

548
00:21:36,900 --> 00:21:39,539
if you don't know about HSS you'll have

549
00:21:39,539 --> 00:21:40,980
to trust me that we have all of these

550
00:21:40,980 --> 00:21:43,320
assumptions we have we have it on all of

551
00:21:43,320 --> 00:21:45,299
these assumptions and if you do know

552
00:21:45,299 --> 00:21:47,820
about HSS you might be wondering wait a

553
00:21:47,820 --> 00:21:49,559
minute we don't actually have four party

554
00:21:49,559 --> 00:21:51,539
HSS from DCR

555
00:21:51,539 --> 00:21:54,900
and we don't have two parts HSS from ddh

556
00:21:54,900 --> 00:21:57,240
which brings me I just mentioned very

557
00:21:57,240 --> 00:21:59,760
briefly some secondary contributions

558
00:21:59,760 --> 00:22:02,520
the first first thing the first thing is

559
00:22:02,520 --> 00:22:03,720
that we don't actually I don't actually

560
00:22:03,720 --> 00:22:05,580
need the full power of homomorphic

561
00:22:05,580 --> 00:22:07,799
secret sharing it's perfectly all right

562
00:22:07,799 --> 00:22:10,320
we are almost out of times okay great

563
00:22:10,320 --> 00:22:13,280
it's finished one side thank you

564
00:22:13,280 --> 00:22:18,120
assuming my HSS has a lot of errors

565
00:22:18,120 --> 00:22:20,580
um I can still it's still enough yes

566
00:22:20,580 --> 00:22:22,860
even if my HSS has errors we call this

567
00:22:22,860 --> 00:22:25,159
Las Vegas HSS

568
00:22:25,159 --> 00:22:28,320
my framework still goes through and in

569
00:22:28,320 --> 00:22:29,760
particular this is why we can get an

570
00:22:29,760 --> 00:22:31,919
assassination from ddh

571
00:22:31,919 --> 00:22:33,419
and

572
00:22:33,419 --> 00:22:36,419
how do we get four part HSS from DCR we

573
00:22:36,419 --> 00:22:38,820
can there's a very simple extension of a

574
00:22:38,820 --> 00:22:41,520
known four-party HSS for log for

575
00:22:41,520 --> 00:22:43,380
constant depth correlations which we can

576
00:22:43,380 --> 00:22:45,900
extend to feta needs

577
00:22:45,900 --> 00:22:47,159
so I don't know if you have any

578
00:22:47,159 --> 00:22:49,380
questions for me but while I thank you

579
00:22:49,380 --> 00:22:51,080
for your attention I'll leave these

580
00:22:51,080 --> 00:22:53,820
questions up uh because as you know

581
00:22:53,820 --> 00:22:55,200
these are the questions I have for you

582
00:22:55,200 --> 00:22:57,960
if you want to try and

583
00:22:57,960 --> 00:23:01,799
extend our result as so

584
00:23:01,799 --> 00:23:05,880
in one sentence what what you know what

585
00:23:05,880 --> 00:23:08,340
is the conclusion is that we can now

586
00:23:08,340 --> 00:23:10,919
break the two-party barrier for

587
00:23:10,919 --> 00:23:13,020
sublinear social computation without

588
00:23:13,020 --> 00:23:15,659
fully homomorphic encryption

589
00:23:15,659 --> 00:23:17,340
so thank you for your attention and I'm

590
00:23:17,340 --> 00:23:19,950
happy to take any questions if this time

591
00:23:19,950 --> 00:23:24,120
[Applause]

592
00:23:24,120 --> 00:23:26,100
yeah maybe we should go to the next talk

593
00:23:26,100 --> 00:23:30,199
because we are a bit over time

594
00:23:33,900 --> 00:23:36,860
thank you

595
00:23:40,440 --> 00:23:42,539
it was this Sabrina communication but

596
00:23:42,539 --> 00:23:46,440
super linear length right of the talk

597
00:23:46,440 --> 00:23:49,140
the next talk is actively secure

598
00:23:49,140 --> 00:23:52,080
arithmetic computation and Vector Ole

599
00:23:52,080 --> 00:23:54,380
with constant computational overhead

600
00:23:54,380 --> 00:23:57,539
this is a talk by or this is a work by

601
00:23:57,539 --> 00:24:00,720
Benny Applebaum and if constantini and

602
00:24:00,720 --> 00:24:02,159
Ben is going to be here with the talk

603
00:24:02,159 --> 00:24:04,679
yeah thank you

604
00:24:04,679 --> 00:24:05,700
um

605
00:24:05,700 --> 00:24:07,559
sting blocks

606
00:24:07,559 --> 00:24:09,120
I'm not sure

607
00:24:09,120 --> 00:24:11,719
okay

608
00:24:12,720 --> 00:24:14,460
good so this is John's work with my

609
00:24:14,460 --> 00:24:16,919
students never couldn't be here

610
00:24:16,919 --> 00:24:18,659
unfortunately and that's a good

611
00:24:18,659 --> 00:24:20,100
opportunity to mention that we have a

612
00:24:20,100 --> 00:24:22,799
very nice crypto group in Tel Aviv and

613
00:24:22,799 --> 00:24:25,320
we recently got a Neil cigarette a new

614
00:24:25,320 --> 00:24:27,299
one so we have available positions so if

615
00:24:27,299 --> 00:24:28,380
some of you are interested please

616
00:24:28,380 --> 00:24:30,600
contact me

617
00:24:30,600 --> 00:24:32,640
good so in general purpose secure

618
00:24:32,640 --> 00:24:35,539
computation we typically

619
00:24:35,539 --> 00:24:38,100
get a function that we want to evaluate

620
00:24:38,100 --> 00:24:39,960
and the classical setting is that this

621
00:24:39,960 --> 00:24:41,520
function is given to us as a Boolean

622
00:24:41,520 --> 00:24:42,720
circuit

623
00:24:42,720 --> 00:24:45,120
and however in the real world typically

624
00:24:45,120 --> 00:24:46,200
we are interested in numerical

625
00:24:46,200 --> 00:24:48,120
computation right over the integers of

626
00:24:48,120 --> 00:24:49,980
the real numbers

627
00:24:49,980 --> 00:24:51,780
and in Principle as we all know we can

628
00:24:51,780 --> 00:24:53,280
translate this kind of thing into a

629
00:24:53,280 --> 00:24:56,039
Boolean circuit this translation is

630
00:24:56,039 --> 00:24:58,700
typically costly

631
00:25:00,960 --> 00:25:03,020
so these are reverse lights from the

632
00:25:03,020 --> 00:25:05,220
adinz paper I think

633
00:25:05,220 --> 00:25:07,559
okay so a better alternative

634
00:25:07,559 --> 00:25:09,900
is to use the arithmetic circuit so we

635
00:25:09,900 --> 00:25:11,640
think about our items our data items

636
00:25:11,640 --> 00:25:13,500
that's being taken from a larger finite

637
00:25:13,500 --> 00:25:15,419
field and we're going to manipulate them

638
00:25:15,419 --> 00:25:17,640
by using addition and multiplication

639
00:25:17,640 --> 00:25:20,340
and indeed once you have this kind of an

640
00:25:20,340 --> 00:25:21,980
ocean you can easily translate it

641
00:25:21,980 --> 00:25:24,299
translate computation even over the

642
00:25:24,299 --> 00:25:26,279
integers of over the real numbers by

643
00:25:26,279 --> 00:25:29,039
using a sufficiently a large field

644
00:25:29,039 --> 00:25:32,340
uh so this is the goal in our in this

645
00:25:32,340 --> 00:25:34,200
book to try to understand what is the

646
00:25:34,200 --> 00:25:36,059
computational costs as opposed to

647
00:25:36,059 --> 00:25:38,100
communication costs in the previous talk

648
00:25:38,100 --> 00:25:40,740
of evaluating or securely evaluating an

649
00:25:40,740 --> 00:25:42,720
arithmetic circuit okay so that's the

650
00:25:42,720 --> 00:25:45,419
goal and we're going to use this a very

651
00:25:45,419 --> 00:25:48,179
clean model of the arithmetic Black Box

652
00:25:48,179 --> 00:25:50,580
in which the protocol is in the Black

653
00:25:50,580 --> 00:25:52,740
Box access to the field and we're going

654
00:25:52,740 --> 00:25:54,840
to measure complexity by just counting

655
00:25:54,840 --> 00:25:56,880
field operations in the measure

656
00:25:56,880 --> 00:25:58,380
communication by the number of field

657
00:25:58,380 --> 00:26:01,679
elements that are being communicated

658
00:26:01,679 --> 00:26:04,320
good so what do we know about this model

659
00:26:04,320 --> 00:26:07,320
so a few years ago in crypto with some

660
00:26:07,320 --> 00:26:08,940
respected colleagues we have this result

661
00:26:08,940 --> 00:26:11,640
that shows that if you want two party

662
00:26:11,640 --> 00:26:13,679
secure computation with the passive

663
00:26:13,679 --> 00:26:16,080
security then you can get with the

664
00:26:16,080 --> 00:26:18,539
constant a overhead meaning that if you

665
00:26:18,539 --> 00:26:20,340
are given an exercise circuit you're

666
00:26:20,340 --> 00:26:21,840
going to perform on the order of s

667
00:26:21,840 --> 00:26:23,279
arithmetic operations plus something

668
00:26:23,279 --> 00:26:24,539
which is polynomial in the security

669
00:26:24,539 --> 00:26:26,640
parameter so if the circuit is

670
00:26:26,640 --> 00:26:28,440
sufficiently large you pay a constant a

671
00:26:28,440 --> 00:26:31,440
computational overhead per gate

672
00:26:31,440 --> 00:26:34,020
now to prove this result we had to

673
00:26:34,020 --> 00:26:36,059
introduce this primitive which is now

674
00:26:36,059 --> 00:26:38,159
kind of popular primitive which is

675
00:26:38,159 --> 00:26:40,440
roughly speaking a vector by scale of

676
00:26:40,440 --> 00:26:44,100
the multiplication and we show that this

677
00:26:44,100 --> 00:26:45,720
can be implemented with a constant

678
00:26:45,720 --> 00:26:47,100
overhead and even constant number of

679
00:26:47,100 --> 00:26:49,200
rounds and then we kind of compile it

680
00:26:49,200 --> 00:26:52,140
into a protocol for General circuits

681
00:26:52,140 --> 00:26:54,720
and these protocols have several nice

682
00:26:54,720 --> 00:26:56,700
properties they make as I said the Black

683
00:26:56,700 --> 00:26:59,400
Box say access to the field we use the

684
00:26:59,400 --> 00:27:01,799
OT a hybrid model which means that we

685
00:27:01,799 --> 00:27:03,240
are going to use oblivious transfer but

686
00:27:03,240 --> 00:27:04,380
we're going to use them in a black box

687
00:27:04,380 --> 00:27:07,440
way there are many reasons to uh to want

688
00:27:07,440 --> 00:27:10,080
this feature most notably if you don't

689
00:27:10,080 --> 00:27:11,460
have this feature then you're likely to

690
00:27:11,460 --> 00:27:14,419
be completely impractical

691
00:27:14,419 --> 00:27:18,240
moreover we will rely on the arithmetic

692
00:27:18,240 --> 00:27:19,880
variants of well-studied assumptions

693
00:27:19,880 --> 00:27:23,340
concretely to get the vole we use the an

694
00:27:23,340 --> 00:27:25,440
arithmetic version of novich who is

695
00:27:25,440 --> 00:27:28,200
roughly speaking says that um this is

696
00:27:28,200 --> 00:27:30,320
the assumption that um

697
00:27:30,320 --> 00:27:34,200
noisy codewords are random where the

698
00:27:34,200 --> 00:27:36,240
code is generated by sparse metrics and

699
00:27:36,240 --> 00:27:37,640
the noise is

700
00:27:37,640 --> 00:27:40,440
constant rate

701
00:27:40,440 --> 00:27:42,720
and for the other the transform we had

702
00:27:42,720 --> 00:27:46,260
to use a arithmetic Goldberg assumption

703
00:27:46,260 --> 00:27:48,539
basically a local plg with the super

704
00:27:48,539 --> 00:27:50,100
polynomial search we heard about it

705
00:27:50,100 --> 00:27:52,459
yesterday

706
00:27:52,559 --> 00:27:54,360
and as a bonus we got statistical

707
00:27:54,360 --> 00:27:57,179
security against one party even uses

708
00:27:57,179 --> 00:27:59,279
security if you want and the and all

709
00:27:59,279 --> 00:28:00,600
these results I talked about the two

710
00:28:00,600 --> 00:28:02,340
parties but it extends nicely to any

711
00:28:02,340 --> 00:28:04,440
constant number of parties

712
00:28:04,440 --> 00:28:06,900
so that was the adinz in fact the

713
00:28:06,900 --> 00:28:08,760
protocols were sufficiently simple to be

714
00:28:08,760 --> 00:28:11,279
practical at least in the vole level so

715
00:28:11,279 --> 00:28:13,080
when they had concrete efficiency it was

716
00:28:13,080 --> 00:28:15,539
they were even implemented and this is

717
00:28:15,539 --> 00:28:17,220
nice because there are many direct

718
00:28:17,220 --> 00:28:19,679
implications of this tool all right the

719
00:28:19,679 --> 00:28:21,720
former securely now algebra to an

720
00:28:21,720 --> 00:28:24,000
ungeractive NPC

721
00:28:24,000 --> 00:28:25,799
so the goal today is to try to get a

722
00:28:25,799 --> 00:28:27,299
similar result but with active security

723
00:28:27,299 --> 00:28:28,980
right so that's the goal and the first

724
00:28:28,980 --> 00:28:31,200
thing that comes to your mind is that

725
00:28:31,200 --> 00:28:33,419
let's use the previous protocol it I

726
00:28:33,419 --> 00:28:34,740
mean we already worked on it let's throw

727
00:28:34,740 --> 00:28:36,960
in zero knowledge proofs and compile it

728
00:28:36,960 --> 00:28:40,200
and get an actively secure protocol this

729
00:28:40,200 --> 00:28:42,720
is known as the gmw Paradigm the problem

730
00:28:42,720 --> 00:28:44,159
is that this thing will not make a

731
00:28:44,159 --> 00:28:45,960
backbox say access to the OT we'll have

732
00:28:45,960 --> 00:28:47,880
to open the OT and make a non-black box

733
00:28:47,880 --> 00:28:50,460
access to the OT which is a bad thing so

734
00:28:50,460 --> 00:28:52,080
we want to avoid it

735
00:28:52,080 --> 00:28:54,299
and the main result at least the main

736
00:28:54,299 --> 00:28:56,100
theoretical result of this paper is a

737
00:28:56,100 --> 00:28:57,360
protocol that achieve active security

738
00:28:57,360 --> 00:28:59,400
constant overhead and all these previous

739
00:28:59,400 --> 00:29:01,799
features right so

740
00:29:01,799 --> 00:29:02,460
um

741
00:29:02,460 --> 00:29:04,559
that is we have like a given a circuit

742
00:29:04,559 --> 00:29:06,779
with the S Gates we can compute it by

743
00:29:06,779 --> 00:29:09,440
making only order of a field operations

744
00:29:09,440 --> 00:29:11,820
again Black Box access to the field

745
00:29:11,820 --> 00:29:13,980
Black Box access to the OT same

746
00:29:13,980 --> 00:29:15,900
assumptions as we used there before in

747
00:29:15,900 --> 00:29:18,299
the passive setting and also all these

748
00:29:18,299 --> 00:29:19,740
additional features

749
00:29:19,740 --> 00:29:22,559
and this is the I mean previously we

750
00:29:22,559 --> 00:29:23,760
didn't know how to achieve it even if

751
00:29:23,760 --> 00:29:25,020
you don't care about all these features

752
00:29:25,020 --> 00:29:27,179
and just just care about the

753
00:29:27,179 --> 00:29:29,399
um Black Box access to the OT

754
00:29:29,399 --> 00:29:31,620
okay in fact even if you focus on the

755
00:29:31,620 --> 00:29:33,539
Volare primitive the only known

756
00:29:33,539 --> 00:29:35,039
construction that achieved Black Box

757
00:29:35,039 --> 00:29:37,140
access to uh Volare and consent overhead

758
00:29:37,140 --> 00:29:39,240
is based on this compressed Volare

759
00:29:39,240 --> 00:29:42,600
approach and the record is it requires a

760
00:29:42,600 --> 00:29:44,279
somewhat less standard assumptions

761
00:29:44,279 --> 00:29:47,580
namely leaky LPN with a subconstant

762
00:29:47,580 --> 00:29:50,159
noise rate and the over less standard

763
00:29:50,159 --> 00:29:52,260
mattresses plus correlation or

764
00:29:52,260 --> 00:29:53,460
bastashing

765
00:29:53,460 --> 00:29:56,940
but these days this is for free I guess

766
00:29:56,940 --> 00:29:59,279
um okay so this is the theoretical

767
00:29:59,279 --> 00:30:01,260
result of the paper

768
00:30:01,260 --> 00:30:03,120
on the Practical side we're trying to

769
00:30:03,120 --> 00:30:05,460
optimize the concrete a complexity of

770
00:30:05,460 --> 00:30:07,320
the volume okay and this is a different

771
00:30:07,320 --> 00:30:09,960
game so here we are allowed to make more

772
00:30:09,960 --> 00:30:11,940
assumptions and indeed we made we've

773
00:30:11,940 --> 00:30:14,820
introduced a new a variant of the LPN

774
00:30:14,820 --> 00:30:16,440
assumption I'll tell you a bit a little

775
00:30:16,440 --> 00:30:18,299
bit about it later it's a kind of a non

776
00:30:18,299 --> 00:30:21,179
malleable version of LPN

777
00:30:21,179 --> 00:30:23,760
think that it's interesting for its own

778
00:30:23,760 --> 00:30:27,120
and um and we got a completely efficient

779
00:30:27,120 --> 00:30:30,480
protocol we implemented it never

780
00:30:30,480 --> 00:30:33,179
implemented it and uh to the best of our

781
00:30:33,179 --> 00:30:33,899
knowledge this is the first

782
00:30:33,899 --> 00:30:36,480
implementation of actively security over

783
00:30:36,480 --> 00:30:39,360
non-binary fields uh we kept the same

784
00:30:39,360 --> 00:30:41,460
parameters as in the previous passive

785
00:30:41,460 --> 00:30:44,279
case and the overhead is roughly 20 more

786
00:30:44,279 --> 00:30:46,200
than the than it was the in the previous

787
00:30:46,200 --> 00:30:48,419
paper we also introduced all sorts of

788
00:30:48,419 --> 00:30:50,340
new optimizations like a spouse

789
00:30:50,340 --> 00:30:52,200
decomposition

790
00:30:52,200 --> 00:30:54,299
and just to give you some numbers

791
00:30:54,299 --> 00:30:56,340
so the communication we have theorems of

792
00:30:56,340 --> 00:30:58,020
communication and we communicate fault

793
00:30:58,020 --> 00:30:59,520
field elements powerful element as

794
00:30:59,520 --> 00:31:01,799
opposed to three in the passive setting

795
00:31:01,799 --> 00:31:04,440
in terms of computation so amortization

796
00:31:04,440 --> 00:31:06,659
kicks in very fast even for 10 000 long

797
00:31:06,659 --> 00:31:09,620
vectors we pay only four hotels and

798
00:31:09,620 --> 00:31:12,299
about 300 arithmetic operations just

799
00:31:12,299 --> 00:31:14,520
additional multiplications and in fact

800
00:31:14,520 --> 00:31:16,140
if you look at longer vectors then

801
00:31:16,140 --> 00:31:18,440
you'll get better constants

802
00:31:18,440 --> 00:31:21,299
and furthermore by using all these Lu

803
00:31:21,299 --> 00:31:22,980
decompositions we can push most of the

804
00:31:22,980 --> 00:31:24,299
work to an offline phase which is

805
00:31:24,299 --> 00:31:26,640
non-interactive okay so you can do it by

806
00:31:26,640 --> 00:31:28,500
yourself and then in the online phase

807
00:31:28,500 --> 00:31:31,679
it's extremely a fast I mean the

808
00:31:31,679 --> 00:31:34,980
receiver just applies fourties and 10

809
00:31:34,980 --> 00:31:37,740
arithmetic operations the center 80

810
00:31:37,740 --> 00:31:39,720
arithmetic operations

811
00:31:39,720 --> 00:31:41,940
and this is kind of nice because we have

812
00:31:41,940 --> 00:31:44,580
OLED based zero knowledge proofs in

813
00:31:44,580 --> 00:31:46,980
which uh the verifier plays the role of

814
00:31:46,980 --> 00:31:48,659
the receiver so it means that you get

815
00:31:48,659 --> 00:31:52,140
very fast verification in New Zealand

816
00:31:52,140 --> 00:31:53,940
how does it compare with other works so

817
00:31:53,940 --> 00:31:55,380
in the last two years we've seen there

818
00:31:55,380 --> 00:31:56,340
like

819
00:31:56,340 --> 00:31:58,200
amazing breakthrough we are using this

820
00:31:58,200 --> 00:32:01,380
compressively approach

821
00:32:01,380 --> 00:32:03,840
um and in this approach actually achieve

822
00:32:03,840 --> 00:32:06,299
can achieve a right one so in terms of

823
00:32:06,299 --> 00:32:08,460
communication it's better but it seems

824
00:32:08,460 --> 00:32:11,399
that the amortization kicks in in a

825
00:32:11,399 --> 00:32:15,000
larger in a later point and and so that

826
00:32:15,000 --> 00:32:16,620
this support seems to be competitive for

827
00:32:16,620 --> 00:32:19,260
medium-sized vectors especially when you

828
00:32:19,260 --> 00:32:21,360
have a fast Network and just to give you

829
00:32:21,360 --> 00:32:23,940
some qualitative intuition

830
00:32:23,940 --> 00:32:25,799
most of the work in this approach is

831
00:32:25,799 --> 00:32:27,659
devoted to generating these short volley

832
00:32:27,659 --> 00:32:28,760
correlations

833
00:32:28,760 --> 00:32:31,100
namely in this this requires a

834
00:32:31,100 --> 00:32:33,960
cryptographic operations and now most of

835
00:32:33,960 --> 00:32:35,640
the work is just linear algebraic

836
00:32:35,640 --> 00:32:37,380
solving spouse equations I don't know

837
00:32:37,380 --> 00:32:39,179
like cryptographic operations except for

838
00:32:39,179 --> 00:32:41,279
the outing

839
00:32:41,279 --> 00:32:44,520
good so I'm not sure how am I doing with

840
00:32:44,520 --> 00:32:46,500
the time but as long as you don't stop

841
00:32:46,500 --> 00:32:47,760
me I will continue

842
00:32:47,760 --> 00:32:50,640
yeah you still have like seven eight

843
00:32:50,640 --> 00:32:53,059
minutes eight minutes nine okay

844
00:32:53,059 --> 00:32:55,919
so um I'm not going to talk too much

845
00:32:55,919 --> 00:32:57,240
about the poofs I think that there are

846
00:32:57,240 --> 00:32:59,220
three interesting ideals the two of them

847
00:32:59,220 --> 00:33:02,279
in the Volare and the the third one in

848
00:33:02,279 --> 00:33:03,720
the transformation from Volare to

849
00:33:03,720 --> 00:33:05,820
General circuits I will not have time to

850
00:33:05,820 --> 00:33:07,980
say too much about about the third one

851
00:33:07,980 --> 00:33:09,419
but let me say a few words about the

852
00:33:09,419 --> 00:33:10,980
first and the second

853
00:33:10,980 --> 00:33:13,220
so the core admz

854
00:33:13,220 --> 00:33:16,799
protocol is what we call reverse volet

855
00:33:16,799 --> 00:33:19,320
so Ali solves the scalar and the vector

856
00:33:19,320 --> 00:33:21,659
Bob holds the vector and Bob should

857
00:33:21,659 --> 00:33:24,720
learn a x a plus b and you can think

858
00:33:24,720 --> 00:33:26,399
about it as a sacred sharing of the

859
00:33:26,399 --> 00:33:28,919
product XA that's the way that's a

860
00:33:28,919 --> 00:33:30,600
convenient when you think about it let

861
00:33:30,600 --> 00:33:33,419
me know that if Bob throws in and they

862
00:33:33,419 --> 00:33:37,740
all zero Vector then learnsby it's the x

863
00:33:37,740 --> 00:33:39,720
times zeros out

864
00:33:39,720 --> 00:33:42,360
now how does the protocol look like

865
00:33:42,360 --> 00:33:45,899
well we have this linear mapping a so

866
00:33:45,899 --> 00:33:48,240
where Bob applies the linear mapping to

867
00:33:48,240 --> 00:33:49,620
his Vector when the head noise this is

868
00:33:49,620 --> 00:33:51,480
kind of a cyphotech send it to Alice

869
00:33:51,480 --> 00:33:53,460
Alice exploits the linearity she

870
00:33:53,460 --> 00:33:56,220
multiplies this ciphertext by a scalar X

871
00:33:56,220 --> 00:33:58,620
Edge the linear operation over being

872
00:33:58,620 --> 00:34:00,659
which means by linearity that you get

873
00:34:00,659 --> 00:34:03,539
this linear operation XA plus b plus

874
00:34:03,539 --> 00:34:05,640
this garbage term

875
00:34:05,640 --> 00:34:07,559
and we want to pass it back to Bob but

876
00:34:07,559 --> 00:34:09,060
we have to be careful because if you

877
00:34:09,060 --> 00:34:11,580
pass it as is then it's a additional

878
00:34:11,580 --> 00:34:14,879
expression with leak information on x

879
00:34:14,879 --> 00:34:17,159
so to solve this problem we use the we

880
00:34:17,159 --> 00:34:19,739
use the LTS namely we're going to place

881
00:34:19,739 --> 00:34:22,320
this Vector of Alice each enter is going

882
00:34:22,320 --> 00:34:25,980
to be placed in the ink in the one input

883
00:34:25,980 --> 00:34:28,619
of an OT and then we let Bob choose

884
00:34:28,619 --> 00:34:30,780
which coordinates to get based on his

885
00:34:30,780 --> 00:34:33,000
noise Vector okay so that's basically

886
00:34:33,000 --> 00:34:35,219
the protocol now problems this linear

887
00:34:35,219 --> 00:34:37,679
function solving a set of equations gets

888
00:34:37,679 --> 00:34:39,599
the vector and of course the interesting

889
00:34:39,599 --> 00:34:41,219
thing you have to do all these things in

890
00:34:41,219 --> 00:34:42,659
linear time but that's suppose all of

891
00:34:42,659 --> 00:34:43,800
these two of them

892
00:34:43,800 --> 00:34:45,540
okay so what happens in the malicious

893
00:34:45,540 --> 00:34:48,239
setting so malicious verb can simply ask

894
00:34:48,239 --> 00:34:50,820
for a noisy coordinate learn x times the

895
00:34:50,820 --> 00:34:52,379
noise and the noise the noise so that's

896
00:34:52,379 --> 00:34:54,899
it we Knows X so this is bad so the

897
00:34:54,899 --> 00:34:57,000
complete this protocol is completely

898
00:34:57,000 --> 00:34:58,320
broken

899
00:34:58,320 --> 00:35:00,300
and the the challenge is to force

900
00:35:00,300 --> 00:35:01,920
somehow false honest Behavior without

901
00:35:01,920 --> 00:35:03,599
knowing the noise vector and in fact the

902
00:35:03,599 --> 00:35:05,400
noise Vector is not fully defined right

903
00:35:05,400 --> 00:35:07,020
I mean maybe they are you can think

904
00:35:07,020 --> 00:35:08,520
about searing as having different noise

905
00:35:08,520 --> 00:35:11,880
vectors right and um we want to do it

906
00:35:11,880 --> 00:35:13,440
efficiently linear time and we want to

907
00:35:13,440 --> 00:35:15,720
Black Box access to the OT

908
00:35:15,720 --> 00:35:17,940
so the first simple observation is that

909
00:35:17,940 --> 00:35:20,040
in fact we have a clean condition that

910
00:35:20,040 --> 00:35:21,780
tells us whether there was a cheating or

911
00:35:21,780 --> 00:35:24,480
not namely if this Vector the selection

912
00:35:24,480 --> 00:35:27,359
Vector of a Bob I satisfies the

913
00:35:27,359 --> 00:35:29,040
following linear algebraic condition if

914
00:35:29,040 --> 00:35:30,839
you look at the vector C the noisy

915
00:35:30,839 --> 00:35:32,700
chordwork restricted to I and check

916
00:35:32,700 --> 00:35:34,859
whether it's in the image of the linear

917
00:35:34,859 --> 00:35:37,140
mapping restricted to I then this then

918
00:35:37,140 --> 00:35:38,700
you can prove that everything is okay

919
00:35:38,700 --> 00:35:41,400
okay and normally it means that there is

920
00:35:41,400 --> 00:35:42,780
no noise right I mean we ask only for

921
00:35:42,780 --> 00:35:44,760
clean coordinates

922
00:35:44,760 --> 00:35:46,680
and now once we have this observation

923
00:35:46,680 --> 00:35:48,960
the the natural idea which is not new it

924
00:35:48,960 --> 00:35:50,820
was used in in other context similar

925
00:35:50,820 --> 00:35:52,920
contexts as well is to use the some for

926
00:35:52,920 --> 00:35:55,440
some sort of a generalized OT so what do

927
00:35:55,440 --> 00:35:57,540
I mean by this let's wrap all these

928
00:35:57,540 --> 00:35:59,760
autism with this an additional layer

929
00:35:59,760 --> 00:36:02,099
that makes sure that information passes

930
00:36:02,099 --> 00:36:04,380
from left to right only if this

931
00:36:04,380 --> 00:36:05,820
condition holds

932
00:36:05,820 --> 00:36:08,520
okay and and the main contribution in

933
00:36:08,520 --> 00:36:10,140
this part is to actually implement this

934
00:36:10,140 --> 00:36:12,960
thing in a linear time so we use kind of

935
00:36:12,960 --> 00:36:15,180
secret sharing tools and it's not

936
00:36:15,180 --> 00:36:16,560
surprising because you know this

937
00:36:16,560 --> 00:36:18,240
condition is linear algebraic and for

938
00:36:18,240 --> 00:36:19,740
linear algebraic conditions we have a

939
00:36:19,740 --> 00:36:21,420
very efficient signature in schemes like

940
00:36:21,420 --> 00:36:23,700
if some of you know about spam programs

941
00:36:23,700 --> 00:36:27,119
so it has a very natural spam program

942
00:36:27,119 --> 00:36:29,460
um and also this linear mapping is

943
00:36:29,460 --> 00:36:31,740
linear Time computable by Design

944
00:36:31,740 --> 00:36:33,599
so this does not immediately means that

945
00:36:33,599 --> 00:36:35,339
the secret sharing trick here is going

946
00:36:35,339 --> 00:36:37,500
to be in linear time but after massaging

947
00:36:37,500 --> 00:36:38,940
things a little bit you can make it to

948
00:36:38,940 --> 00:36:40,440
you can make sure that this is really no

949
00:36:40,440 --> 00:36:41,880
time

950
00:36:41,880 --> 00:36:43,079
now

951
00:36:43,079 --> 00:36:44,760
um something interesting that happens

952
00:36:44,760 --> 00:36:46,380
here is that in order to get all these

953
00:36:46,380 --> 00:36:48,839
properties we actually have to give up a

954
00:36:48,839 --> 00:36:50,040
little bit

955
00:36:50,040 --> 00:36:52,920
so yes and

956
00:36:52,920 --> 00:36:54,900
the actual construction leaks

957
00:36:54,900 --> 00:36:56,579
information even if the condition does

958
00:36:56,579 --> 00:36:58,440
not hold in particular it leaks the

959
00:36:58,440 --> 00:37:00,599
information about the vector B

960
00:37:00,599 --> 00:37:02,280
but this is okay because in this

961
00:37:02,280 --> 00:37:04,200
concrete setting it's okay to look

962
00:37:04,200 --> 00:37:05,820
information about B because we can

963
00:37:05,820 --> 00:37:07,320
simulate it right I mean the simulator

964
00:37:07,320 --> 00:37:09,300
can simulate all the information about B

965
00:37:09,300 --> 00:37:11,400
by letting Bob ask the ideal

966
00:37:11,400 --> 00:37:13,619
functionality with the other vector

967
00:37:13,619 --> 00:37:15,780
right so this is okay and we can still

968
00:37:15,780 --> 00:37:18,180
simulate

969
00:37:18,180 --> 00:37:21,480
what about the cheating Alice

970
00:37:21,480 --> 00:37:23,579
so you know in principal at least could

971
00:37:23,579 --> 00:37:25,859
do some crazy computation and compute

972
00:37:25,859 --> 00:37:27,720
some crazy D and let's think about less

973
00:37:27,720 --> 00:37:29,220
crazy thing to do like something

974
00:37:29,220 --> 00:37:31,320
relatively simple let's assume that she

975
00:37:31,320 --> 00:37:34,380
computes d as a as she should but just

976
00:37:34,380 --> 00:37:36,240
add some garbage on the first coordinate

977
00:37:36,240 --> 00:37:38,339
what happens here

978
00:37:38,339 --> 00:37:41,040
well there is no privacy leakage right

979
00:37:41,040 --> 00:37:42,480
because Alice does not get information

980
00:37:42,480 --> 00:37:43,980
back from Bob right all the information

981
00:37:43,980 --> 00:37:46,859
goes to Bob but you can help correctness

982
00:37:46,859 --> 00:37:49,560
right and Bobs if he decides to ask for

983
00:37:49,560 --> 00:37:51,359
the first coordinate here

984
00:37:51,359 --> 00:37:53,220
right then you will see you know the

985
00:37:53,220 --> 00:37:55,380
element they will not be able to decode

986
00:37:55,380 --> 00:37:58,859
and then will I put a bottom say a boat

987
00:37:58,859 --> 00:38:00,540
now this is annoying because this event

988
00:38:00,540 --> 00:38:02,579
of outputting bottom it depends on the

989
00:38:02,579 --> 00:38:04,740
actual noise right and when we do the

990
00:38:04,740 --> 00:38:06,060
simulation

991
00:38:06,060 --> 00:38:08,339
we don't have access to this noise and

992
00:38:08,339 --> 00:38:10,440
we have a simulation problem

993
00:38:10,440 --> 00:38:11,460
okay

994
00:38:11,460 --> 00:38:14,280
so what do we do so we suggest several

995
00:38:14,280 --> 00:38:16,859
three different solutions

996
00:38:16,859 --> 00:38:18,480
the first solution is heuristic let's

997
00:38:18,480 --> 00:38:20,339
assume that everything is okay I mean we

998
00:38:20,339 --> 00:38:21,720
have a simulation problem we don't like

999
00:38:21,720 --> 00:38:23,339
it as a theoretician but we don't have

1000
00:38:23,339 --> 00:38:25,320
any attack right and we tried it quite

1001
00:38:25,320 --> 00:38:27,900
hard so although we don't like it maybe

1002
00:38:27,900 --> 00:38:29,520
in practice it's okay to say that the

1003
00:38:29,520 --> 00:38:30,839
protocol is secure and you can even

1004
00:38:30,839 --> 00:38:33,119
formulate an assumption that says that

1005
00:38:33,119 --> 00:38:35,220
the protocol is secure underly certain

1006
00:38:35,220 --> 00:38:37,260
I mean it will be a little bit ugly but

1007
00:38:37,260 --> 00:38:39,599
but it can be done

1008
00:38:39,599 --> 00:38:41,579
the second approach is the most

1009
00:38:41,579 --> 00:38:43,260
conservative one which is actually

1010
00:38:43,260 --> 00:38:44,640
reduce security to the original

1011
00:38:44,640 --> 00:38:46,920
assumption and for this we have to tweak

1012
00:38:46,920 --> 00:38:48,599
the protocol and we do some sort of a

1013
00:38:48,599 --> 00:38:50,460
cut and choose approach we run many many

1014
00:38:50,460 --> 00:38:52,560
instances going to open few of them

1015
00:38:52,560 --> 00:38:54,660
check if everything is okay and then

1016
00:38:54,660 --> 00:38:56,400
merge them together and to make it

1017
00:38:56,400 --> 00:38:57,780
linear time we have to merge them

1018
00:38:57,780 --> 00:38:59,700
efficiently so we use the linear time

1019
00:38:59,700 --> 00:39:01,680
computable exposure easily at the

1020
00:39:01,680 --> 00:39:03,119
function

1021
00:39:03,119 --> 00:39:05,640
and one cute thing about this approach

1022
00:39:05,640 --> 00:39:07,200
in this specific case is that the

1023
00:39:07,200 --> 00:39:08,820
discard and choose is silent in the

1024
00:39:08,820 --> 00:39:11,339
sense that when I open a session Bob can

1025
00:39:11,339 --> 00:39:12,960
open the session in a silent way without

1026
00:39:12,960 --> 00:39:14,520
even letting Alice know that the session

1027
00:39:14,520 --> 00:39:16,740
was opened we don't have to add another

1028
00:39:16,740 --> 00:39:18,180
layer to the protocol this kind of

1029
00:39:18,180 --> 00:39:19,859
happens inside the protocol by choosing

1030
00:39:19,859 --> 00:39:22,500
a to be the or zero string

1031
00:39:22,500 --> 00:39:24,359
and again I'm oversimplifying things a

1032
00:39:24,359 --> 00:39:25,680
little bit because you have to think

1033
00:39:25,680 --> 00:39:27,180
about the modified protocol with the

1034
00:39:27,180 --> 00:39:29,400
secret sharing Etc but let's ignore this

1035
00:39:29,400 --> 00:39:30,599
for now

1036
00:39:30,599 --> 00:39:33,599
and the third approach is to use this

1037
00:39:33,599 --> 00:39:35,700
new assumption that we introduce and

1038
00:39:35,700 --> 00:39:37,859
this assumption I'll show you it in a

1039
00:39:37,859 --> 00:39:40,619
minute with this assumption we can add a

1040
00:39:40,619 --> 00:39:43,079
small tweak to the protocol with a very

1041
00:39:43,079 --> 00:39:45,000
low complexity and then we can actually

1042
00:39:45,000 --> 00:39:47,400
prove that this is a secure so let me

1043
00:39:47,400 --> 00:39:48,540
tell you about this assumption and

1044
00:39:48,540 --> 00:39:50,280
conclude

1045
00:39:50,280 --> 00:39:52,079
so we call this technology correlated

1046
00:39:52,079 --> 00:39:53,820
codeword assumption it's the following

1047
00:39:53,820 --> 00:39:55,859
assumption so the Challenger sends a

1048
00:39:55,859 --> 00:39:59,540
noisy code word to the adversary

1049
00:39:59,540 --> 00:40:02,160
is to generate a new noisy code word

1050
00:40:02,160 --> 00:40:04,440
whose noise is correlated okay so what

1051
00:40:04,440 --> 00:40:05,940
do I mean by this

1052
00:40:05,940 --> 00:40:09,000
so diversary wins if

1053
00:40:09,000 --> 00:40:11,820
whenever the coordinate silver clean

1054
00:40:11,820 --> 00:40:14,400
also this coordinates are clean and in

1055
00:40:14,400 --> 00:40:15,359
addition

1056
00:40:15,359 --> 00:40:17,940
this Vector is Far From Any scalar

1057
00:40:17,940 --> 00:40:19,859
multiple of the original Vector noise

1058
00:40:19,859 --> 00:40:22,380
Vector okay and if you remove one of

1059
00:40:22,380 --> 00:40:24,180
this Condition it's very easy to win in

1060
00:40:24,180 --> 00:40:26,160
this game but if you put them together

1061
00:40:26,160 --> 00:40:27,900
it seems to be hard and in that we can

1062
00:40:27,900 --> 00:40:30,119
prove at least in the binary setting we

1063
00:40:30,119 --> 00:40:32,280
can reduce this assumption to stand out

1064
00:40:32,280 --> 00:40:34,380
the LPN

1065
00:40:34,380 --> 00:40:36,000
we don't know but by the way how to do

1066
00:40:36,000 --> 00:40:37,560
it in the arithmetic settings so this is

1067
00:40:37,560 --> 00:40:39,060
kind of a nice thing to think about if

1068
00:40:39,060 --> 00:40:40,380
you want

1069
00:40:40,380 --> 00:40:42,839
let me summarize

1070
00:40:42,839 --> 00:40:43,980
um

1071
00:40:43,980 --> 00:40:46,440
MPC with constant computational overhead

1072
00:40:46,440 --> 00:40:48,780
not communication

1073
00:40:48,780 --> 00:40:50,359
um I should say of course if the

1074
00:40:50,359 --> 00:40:52,619
computational over this constant also

1075
00:40:52,619 --> 00:40:54,000
the communication is constant right this

1076
00:40:54,000 --> 00:40:55,560
is stronger than just having constant

1077
00:40:55,560 --> 00:40:56,940
communication

1078
00:40:56,940 --> 00:40:58,920
so in the Boolean setting we have it by

1079
00:40:58,920 --> 00:41:01,380
icos in the arithmetic setting we had to

1080
00:41:01,380 --> 00:41:04,200
work harder and we got it in ADI and z

1081
00:41:04,200 --> 00:41:06,480
in this work we kind of get the active

1082
00:41:06,480 --> 00:41:08,579
setting now you know I said that moving

1083
00:41:08,579 --> 00:41:10,619
from here to here was harder and I

1084
00:41:10,619 --> 00:41:11,820
showed that they can do this thing so

1085
00:41:11,820 --> 00:41:14,040
why can't I do this ever

1086
00:41:14,040 --> 00:41:16,680
so that's maybe the take-home message

1087
00:41:16,680 --> 00:41:19,020
so it seems that at least in some cases

1088
00:41:19,020 --> 00:41:21,060
in the arithmetic setting it's much

1089
00:41:21,060 --> 00:41:22,920
easier to go out from a passive to

1090
00:41:22,920 --> 00:41:25,260
active security let me give you some

1091
00:41:25,260 --> 00:41:28,859
hints so we explore the linear algebraic

1092
00:41:28,859 --> 00:41:30,839
structure of the protocol that already I

1093
00:41:30,839 --> 00:41:32,339
mentioned it in the secret sharing part

1094
00:41:32,339 --> 00:41:34,140
but one thing that I didn't show you and

1095
00:41:34,140 --> 00:41:35,760
this is kind of the Hidden bullet that

1096
00:41:35,760 --> 00:41:38,040
the bullet number three that I had

1097
00:41:38,040 --> 00:41:39,780
is that we explore the fact that the

1098
00:41:39,780 --> 00:41:40,980
honest part is our low degree

1099
00:41:40,980 --> 00:41:44,880
polynomials so let me explain shortly so

1100
00:41:44,880 --> 00:41:46,800
at some point of the protocol we have a

1101
00:41:46,800 --> 00:41:49,079
gobbling right as usual but but it's an

1102
00:41:49,079 --> 00:41:50,940
arithmetic setting and we have the

1103
00:41:50,940 --> 00:41:52,740
gobbler who is malicious and we have the

1104
00:41:52,740 --> 00:41:54,599
evaluator which is honest

1105
00:41:54,599 --> 00:41:56,220
and we explore the fact that the honest

1106
00:41:56,220 --> 00:41:58,560
evaluator is a low degree polynomial the

1107
00:41:58,560 --> 00:42:00,480
code of the evaluator right of this

1108
00:42:00,480 --> 00:42:02,220
party it's not about the value of the

1109
00:42:02,220 --> 00:42:03,900
evaluated function but the code itself

1110
00:42:03,900 --> 00:42:05,220
of the evaluator

1111
00:42:05,220 --> 00:42:07,859
in the passively secure protocol

1112
00:42:07,859 --> 00:42:09,720
and for this reason even if this guy

1113
00:42:09,720 --> 00:42:12,060
goes crazy eventually the output here is

1114
00:42:12,060 --> 00:42:13,980
a low degree polynomial

1115
00:42:13,980 --> 00:42:15,780
which means now that we can use all

1116
00:42:15,780 --> 00:42:18,119
sorts of Tricks about Cloud polynomial

1117
00:42:18,119 --> 00:42:20,820
to cheaply compile this thing into the

1118
00:42:20,820 --> 00:42:23,760
active setting and that's what we do

1119
00:42:23,760 --> 00:42:26,099
and this is a kind of cool because this

1120
00:42:26,099 --> 00:42:28,260
is an unexpected there's a feature of

1121
00:42:28,260 --> 00:42:30,359
the arithmetic Black Box model

1122
00:42:30,359 --> 00:42:32,160
so many open questions let me just leave

1123
00:42:32,160 --> 00:42:35,300
them on the screen and thank you

1124
00:42:35,300 --> 00:42:40,920
[Applause]

1125
00:42:40,920 --> 00:42:45,200
we have time for maybe one question

1126
00:42:47,040 --> 00:42:49,520
um so

1127
00:42:49,520 --> 00:42:54,000
like your your constructions are oh okay

1128
00:42:54,000 --> 00:42:56,640
sorry no no please you can ask both I

1129
00:42:56,640 --> 00:42:58,380
mean it's okay I mean

1130
00:42:58,380 --> 00:43:01,200
okay thanks uh I just wanted to ask if

1131
00:43:01,200 --> 00:43:03,240
you think your techniques carry over if

1132
00:43:03,240 --> 00:43:04,740
you're in a ring setting for example

1133
00:43:04,740 --> 00:43:06,839
modular Prime power

1134
00:43:06,839 --> 00:43:07,920
uh

1135
00:43:07,920 --> 00:43:09,960
um I have to think about it I'm not sure

1136
00:43:09,960 --> 00:43:12,480
I'm not sure

1137
00:43:12,480 --> 00:43:13,619
um

1138
00:43:13,619 --> 00:43:17,640
maybe in the ring where you have a like

1139
00:43:17,640 --> 00:43:21,839
a few uh zero divide devices like a RSA

1140
00:43:21,839 --> 00:43:23,700
rings I can imagine that this thing can

1141
00:43:23,700 --> 00:43:27,000
work I'm not sure about the general ring

1142
00:43:27,000 --> 00:43:29,700
I I have to think about it yeah a good

1143
00:43:29,700 --> 00:43:32,220
good question okay thanks a lot

1144
00:43:32,220 --> 00:43:34,380
um yeah I was going to ask also if this

1145
00:43:34,380 --> 00:43:36,839
constants that you have they they depend

1146
00:43:36,839 --> 00:43:39,240
on the on the field so I mean they can

1147
00:43:39,240 --> 00:43:40,859
can they get smaller when the field is

1148
00:43:40,859 --> 00:43:42,480
large or something like that or no no so

1149
00:43:42,480 --> 00:43:44,040
so it's independent of the field that's

1150
00:43:44,040 --> 00:43:46,020
that's one of the cool things I mean you

1151
00:43:46,020 --> 00:43:47,520
can see in the paper we have tables but

1152
00:43:47,520 --> 00:43:49,260
the constants itself are independent of

1153
00:43:49,260 --> 00:43:50,460
the feeling we implement it over

1154
00:43:50,460 --> 00:43:51,900
different fields of code when the when

1155
00:43:51,900 --> 00:43:53,220
the field is loud then you know making

1156
00:43:53,220 --> 00:43:54,960
two operations of a loud field is

1157
00:43:54,960 --> 00:43:56,760
typically more expensive but but

1158
00:43:56,760 --> 00:43:59,099
actually you don't like as long as it's

1159
00:43:59,099 --> 00:44:02,400
about memory as long as they say 64 bits

1160
00:44:02,400 --> 00:44:06,540
things of uh or even a 128 bits it's

1161
00:44:06,540 --> 00:44:09,300
kind of uh fast I think

1162
00:44:09,300 --> 00:44:12,000
okay so let's think when you again

1163
00:44:12,000 --> 00:44:14,660
thank you

1164
00:44:16,800 --> 00:44:19,619
and I guess you have four minutes to

1165
00:44:19,619 --> 00:44:22,579
change tracks

1166
00:44:34,030 --> 00:44:37,269
[Music]

1167
00:44:39,540 --> 00:44:42,859
I should have said this

1168
00:44:45,250 --> 00:44:48,429
[Music]

