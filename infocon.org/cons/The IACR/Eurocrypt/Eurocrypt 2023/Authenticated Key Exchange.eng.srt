1
00:00:00,800 --> 00:00:06,080
okay everyone please take a seat

2
00:00:07,020 --> 00:00:09,360
thanks

3
00:00:09,360 --> 00:00:11,580
and welcome to the authenticated key

4
00:00:11,580 --> 00:00:14,759
exchange session uh we have first of all

5
00:00:14,759 --> 00:00:17,580
two talks about something related to

6
00:00:17,580 --> 00:00:20,279
password authenticated key exchange

7
00:00:20,279 --> 00:00:22,680
um and after that the real world crypto

8
00:00:22,680 --> 00:00:26,100
sessions very tightly aligned to that

9
00:00:26,100 --> 00:00:28,740
and we will start with the talk password

10
00:00:28,740 --> 00:00:32,098
authenticated TLS via opaque and post

11
00:00:32,098 --> 00:00:34,200
handshake Authentication

12
00:00:34,200 --> 00:00:37,440
and Julia will give the talk and yeah

13
00:00:37,440 --> 00:00:39,440
let's welcome Julia

14
00:00:39,440 --> 00:00:45,480
[Applause]

15
00:00:45,480 --> 00:00:47,399
thanks Paul

16
00:00:47,399 --> 00:00:50,520
um so this is a joint work with stash

17
00:00:50,520 --> 00:00:53,160
yaretsky hugographchik and Christopher

18
00:00:53,160 --> 00:00:56,820
wood and starch is also here if you have

19
00:00:56,820 --> 00:00:59,840
questions about this later

20
00:01:01,199 --> 00:01:02,879
okay so there have been many predictions

21
00:01:02,879 --> 00:01:04,860
when we will finally stop using

22
00:01:04,860 --> 00:01:06,060
passwords

23
00:01:06,060 --> 00:01:10,200
still um the average number of accounts

24
00:01:10,200 --> 00:01:12,360
that are protected with the password of

25
00:01:12,360 --> 00:01:15,299
us or European citizens is far beyond

26
00:01:15,299 --> 00:01:16,560
50.

27
00:01:16,560 --> 00:01:18,780
so let's have a look at

28
00:01:18,780 --> 00:01:19,500
um

29
00:01:19,500 --> 00:01:22,200
what happens cryptographically if we

30
00:01:22,200 --> 00:01:24,259
authenticate with a password

31
00:01:24,259 --> 00:01:27,780
to one of these providers so the ugly

32
00:01:27,780 --> 00:01:30,299
chooses that almost all password

33
00:01:30,299 --> 00:01:33,299
authentications work with something that

34
00:01:33,299 --> 00:01:35,820
is called password over TLS you can take

35
00:01:35,820 --> 00:01:37,740
a wild guess how this protocol looks I'm

36
00:01:37,740 --> 00:01:40,140
going to describe it so first you're

37
00:01:40,140 --> 00:01:42,119
going to establish a TLS connection to

38
00:01:42,119 --> 00:01:44,759
your provider then you verify the

39
00:01:44,759 --> 00:01:46,560
certificate of the providers so that

40
00:01:46,560 --> 00:01:49,560
it's actually the the company you intend

41
00:01:49,560 --> 00:01:51,540
to talk to and then you're going to send

42
00:01:51,540 --> 00:01:54,000
your password in the clear over this TLS

43
00:01:54,000 --> 00:01:55,500
connection

44
00:01:55,500 --> 00:01:58,200
okay and then the provider hashes the

45
00:01:58,200 --> 00:02:00,960
password and Compares it to the well the

46
00:02:00,960 --> 00:02:02,939
database of hash passwords or somehow

47
00:02:02,939 --> 00:02:06,659
encoded passwords okay so what is the

48
00:02:06,659 --> 00:02:08,580
problem with this approach um you

49
00:02:08,580 --> 00:02:10,878
probably know these headlines

50
00:02:10,878 --> 00:02:14,280
GitHub exposed user passwords to their

51
00:02:14,280 --> 00:02:15,319
employees

52
00:02:15,319 --> 00:02:18,959
Twitter accidentally locked the

53
00:02:18,959 --> 00:02:20,879
passwords while hashing them

54
00:02:20,879 --> 00:02:24,120
and Facebook did a similar thing with

55
00:02:24,120 --> 00:02:26,459
several hundreds of millions of user

56
00:02:26,459 --> 00:02:27,599
passwords

57
00:02:27,599 --> 00:02:30,000
so these passwords lie lie in the

58
00:02:30,000 --> 00:02:32,040
systems of these of these providers in

59
00:02:32,040 --> 00:02:33,300
the clear

60
00:02:33,300 --> 00:02:36,000
and of course none of this happens

61
00:02:36,000 --> 00:02:38,580
intentionally

62
00:02:38,580 --> 00:02:40,500
but the systems that these providers

63
00:02:40,500 --> 00:02:43,080
deploy they are so complex that it would

64
00:02:43,080 --> 00:02:44,640
actually be a miracle if everything

65
00:02:44,640 --> 00:02:47,779
works as expected

66
00:02:48,420 --> 00:02:50,280
but there's a very simple way to avoid

67
00:02:50,280 --> 00:02:54,060
these kind of of problems

68
00:02:54,060 --> 00:02:56,220
so I give you a short guide to secure

69
00:02:56,220 --> 00:02:57,780
password authentication

70
00:02:57,780 --> 00:03:00,360
first you establish a TLS connection to

71
00:03:00,360 --> 00:03:02,160
the provider because this is simply how

72
00:03:02,160 --> 00:03:04,260
talking on the internet works these days

73
00:03:04,260 --> 00:03:07,200
and then you convince this provider of

74
00:03:07,200 --> 00:03:08,760
your password knowledge

75
00:03:08,760 --> 00:03:10,500
but without leaking any additional

76
00:03:10,500 --> 00:03:13,640
information about the password

77
00:03:16,080 --> 00:03:17,760
the good news is we have all the tools

78
00:03:17,760 --> 00:03:19,500
we as cryptographers we have all the

79
00:03:19,500 --> 00:03:20,940
tools to do secure password

80
00:03:20,940 --> 00:03:23,900
authentication you can view this

81
00:03:23,900 --> 00:03:26,760
for example as an instance of a zero

82
00:03:26,760 --> 00:03:29,159
knowledge proof where you prove in zero

83
00:03:29,159 --> 00:03:31,620
knowledge that you know for example a

84
00:03:31,620 --> 00:03:33,599
pre-image of a hash you can view it as

85
00:03:33,599 --> 00:03:35,519
an instance of a multi-party computation

86
00:03:35,519 --> 00:03:39,420
or you can view it as an instance of

87
00:03:39,420 --> 00:03:41,159
asymmetric password authenticated key

88
00:03:41,159 --> 00:03:43,019
exchange

89
00:03:43,019 --> 00:03:44,640
um isometric password authenticated key

90
00:03:44,640 --> 00:03:47,480
exchange is a two-party computation

91
00:03:47,480 --> 00:03:51,920
where the client on the left hand side

92
00:03:51,920 --> 00:03:54,840
inputs a password into the protocol and

93
00:03:54,840 --> 00:03:57,120
the server on the right hand side inputs

94
00:03:57,120 --> 00:04:01,200
some form of encoded password so most of

95
00:04:01,200 --> 00:04:02,879
the time I will just write hash of the

96
00:04:02,879 --> 00:04:04,500
password but you can really think of any

97
00:04:04,500 --> 00:04:06,080
sort of encoding

98
00:04:06,080 --> 00:04:10,260
kind of makes it hard to revert to the

99
00:04:10,260 --> 00:04:12,439
password

100
00:04:12,780 --> 00:04:15,599
okay so this this this protocol between

101
00:04:15,599 --> 00:04:18,298
the two parties takes these inputs and

102
00:04:18,298 --> 00:04:19,978
as outputs both parties are going to

103
00:04:19,978 --> 00:04:22,260
compute a key okay and we have the

104
00:04:22,260 --> 00:04:25,080
guarantee that if the password data that

105
00:04:25,080 --> 00:04:28,080
was input matches then these keys are

106
00:04:28,080 --> 00:04:29,699
going to match right so this is an if

107
00:04:29,699 --> 00:04:32,160
and only if

108
00:04:32,160 --> 00:04:34,259
okay so because we are mainly interested

109
00:04:34,259 --> 00:04:36,300
in verification of the password we have

110
00:04:36,300 --> 00:04:38,940
to do a bit more work here we have for

111
00:04:38,940 --> 00:04:40,860
example we can do a key confirmation run

112
00:04:40,860 --> 00:04:42,660
of key confirmation appendix to this

113
00:04:42,660 --> 00:04:45,660
page protocol to let the parties learn

114
00:04:45,660 --> 00:04:47,280
whether the keys that they computed are

115
00:04:47,280 --> 00:04:50,419
actually the same okay

116
00:04:52,259 --> 00:04:55,080
okay so isn't there a trivial solution

117
00:04:55,080 --> 00:04:57,900
to this password over TLS

118
00:04:57,900 --> 00:04:58,740
um

119
00:04:58,740 --> 00:05:01,080
problem this like a way of sending

120
00:05:01,080 --> 00:05:02,460
passwords over to your last Connections

121
00:05:02,460 --> 00:05:04,740
in the clear can't you just run an apag

122
00:05:04,740 --> 00:05:07,199
over TLS so this would look as follows

123
00:05:07,199 --> 00:05:09,000
we have the client on the left hand side

124
00:05:09,000 --> 00:05:11,460
establishing a channel to some provider

125
00:05:11,460 --> 00:05:14,280
and after verifying the certificate of

126
00:05:14,280 --> 00:05:15,840
the provider so after establishing the

127
00:05:15,840 --> 00:05:18,600
channel the client and the server run

128
00:05:18,600 --> 00:05:21,660
this protocol over the channel and the

129
00:05:21,660 --> 00:05:23,520
outcome at the server side is

130
00:05:23,520 --> 00:05:24,900
essentially a bit

131
00:05:24,900 --> 00:05:27,000
right and from the security of the

132
00:05:27,000 --> 00:05:28,560
Primitive so from a security of the

133
00:05:28,560 --> 00:05:30,240
astrometric peg the server learns

134
00:05:30,240 --> 00:05:31,620
nothing else

135
00:05:31,620 --> 00:05:33,479
okay

136
00:05:33,479 --> 00:05:34,800
so the provider does not see the clear

137
00:05:34,800 --> 00:05:37,080
text password actually it guarantees

138
00:05:37,080 --> 00:05:38,520
much better as on the slides it actually

139
00:05:38,520 --> 00:05:40,080
learns nothing about the password beyond

140
00:05:40,080 --> 00:05:41,820
the result of the verification

141
00:05:41,820 --> 00:05:44,160
and this is also because the Apec

142
00:05:44,160 --> 00:05:46,380
requires the password as input this is

143
00:05:46,380 --> 00:05:47,880
somehow a proof of knowledge of the

144
00:05:47,880 --> 00:05:50,060
password

145
00:05:50,520 --> 00:05:54,120
okay so this looks good already however

146
00:05:54,120 --> 00:05:55,919
there are certain drawbacks to this

147
00:05:55,919 --> 00:05:58,500
approach so first this is a proof of

148
00:05:58,500 --> 00:05:59,820
knowledge of the password but the

149
00:05:59,820 --> 00:06:02,100
question is by whom

150
00:06:02,100 --> 00:06:04,320
because so this is the person who is

151
00:06:04,320 --> 00:06:05,880
actually talking on the channel kind of

152
00:06:05,880 --> 00:06:08,039
the the end point of the channel

153
00:06:08,039 --> 00:06:10,139
but if there's simply Apec messages

154
00:06:10,139 --> 00:06:12,600
coming out of the channel this person

155
00:06:12,600 --> 00:06:14,940
can just relay these messages kind of

156
00:06:14,940 --> 00:06:18,000
maliciously sneak them to another party

157
00:06:18,000 --> 00:06:20,160
this party might think it's talking

158
00:06:20,160 --> 00:06:22,319
doing something else but actually it

159
00:06:22,319 --> 00:06:24,720
runs like this this proof of knowledge

160
00:06:24,720 --> 00:06:27,419
of password for a dead party

161
00:06:27,419 --> 00:06:29,479
okay so there seems to be like an

162
00:06:29,479 --> 00:06:31,979
improper binding between this

163
00:06:31,979 --> 00:06:34,080
authentication action

164
00:06:34,080 --> 00:06:37,340
and the channel

165
00:06:39,479 --> 00:06:41,039
and the other thing the other downside

166
00:06:41,039 --> 00:06:43,380
is efficiency so I told you before it

167
00:06:43,380 --> 00:06:44,759
might have looked already a bit weird

168
00:06:44,759 --> 00:06:46,319
we're exchanging a key and then from

169
00:06:46,319 --> 00:06:48,479
that key we're again driving a bit so is

170
00:06:48,479 --> 00:06:49,919
it actually necessary to exchange this

171
00:06:49,919 --> 00:06:51,660
key can we somehow derive this bit like

172
00:06:51,660 --> 00:06:53,340
more efficiently I have to do we have to

173
00:06:53,340 --> 00:06:56,179
go by this key

174
00:06:59,400 --> 00:07:01,319
just a better protocol that we can use

175
00:07:01,319 --> 00:07:03,840
and this is called TLS opaque this is an

176
00:07:03,840 --> 00:07:06,180
ietf draft

177
00:07:06,180 --> 00:07:06,720
um

178
00:07:06,720 --> 00:07:09,120
and it offers so-called post handshake

179
00:07:09,120 --> 00:07:11,100
password authentication so what does

180
00:07:11,100 --> 00:07:13,080
this mean post handshake really means

181
00:07:13,080 --> 00:07:16,440
after establishment of the channel okay

182
00:07:16,440 --> 00:07:19,500
so you see here well a picture of a TLS

183
00:07:19,500 --> 00:07:21,199
Channel

184
00:07:21,199 --> 00:07:23,280
what do the parties know about each

185
00:07:23,280 --> 00:07:25,620
other well the user has verified the

186
00:07:25,620 --> 00:07:27,300
server certificate so the user knows who

187
00:07:27,300 --> 00:07:29,639
is talking to the server knows nothing

188
00:07:29,639 --> 00:07:31,860
about the client right there's an option

189
00:07:31,860 --> 00:07:35,340
it's optional on TRS connections to also

190
00:07:35,340 --> 00:07:37,800
verify a client certificate but it's not

191
00:07:37,800 --> 00:07:40,639
really used at all

192
00:07:40,680 --> 00:07:42,300
because clients usually do not have

193
00:07:42,300 --> 00:07:43,500
certificates

194
00:07:43,500 --> 00:07:48,440
okay so what does TLS opaque do

195
00:07:48,599 --> 00:07:49,319
um

196
00:07:49,319 --> 00:07:51,419
in the in the client server setting

197
00:07:51,419 --> 00:07:53,639
where we have a service during something

198
00:07:53,639 --> 00:07:55,800
like a password file a database of

199
00:07:55,800 --> 00:07:58,979
password hashes for example TLS opaque

200
00:07:58,979 --> 00:08:01,259
allows after establishment of the

201
00:08:01,259 --> 00:08:03,900
channel to add password authentication

202
00:08:03,900 --> 00:08:06,240
to this channel okay so here in this

203
00:08:06,240 --> 00:08:09,000
example Bob has the password they can

204
00:08:09,000 --> 00:08:11,099
just you know press a button after using

205
00:08:11,099 --> 00:08:12,479
the channel already for some time they

206
00:08:12,479 --> 00:08:15,060
can press a button activate this like

207
00:08:15,060 --> 00:08:17,400
TLS opaque protocol or run this TLS

208
00:08:17,400 --> 00:08:19,379
opaque protocol and the result is that

209
00:08:19,379 --> 00:08:22,139
Bob is convinced that the other endpoint

210
00:08:22,139 --> 00:08:23,759
of the channel

211
00:08:23,759 --> 00:08:25,639
this guy here

212
00:08:25,639 --> 00:08:28,440
knows the password

213
00:08:28,440 --> 00:08:31,259
right so he's unconvinced okay there's

214
00:08:31,259 --> 00:08:32,760
I'm talking to a person who knows the

215
00:08:32,760 --> 00:08:34,080
pre-image of the hash so I'm talking to

216
00:08:34,080 --> 00:08:36,979
Bob okay

217
00:08:39,360 --> 00:08:41,640
okay and all of this is done in a zero

218
00:08:41,640 --> 00:08:43,380
knowledge way meaning that the server

219
00:08:43,380 --> 00:08:45,979
learns nothing else

220
00:08:46,620 --> 00:08:49,440
so in this work I'm going to show you a

221
00:08:49,440 --> 00:08:51,540
modular analysis of the TLs opaque

222
00:08:51,540 --> 00:08:53,899
protocol

223
00:08:55,740 --> 00:08:57,839
um the base is where we start from over

224
00:08:57,839 --> 00:08:59,580
TLS opaque starts from is the channel so

225
00:08:59,580 --> 00:09:00,660
I told you it's post handshake

226
00:09:00,660 --> 00:09:02,160
authentication we have to assume that

227
00:09:02,160 --> 00:09:04,019
the channel is already there so this is

228
00:09:04,019 --> 00:09:05,640
the empty Channel dot empty TLS Channel

229
00:09:05,640 --> 00:09:08,220
that I already showed you and um a

230
00:09:08,220 --> 00:09:10,380
property of the TLs handshake is that

231
00:09:10,380 --> 00:09:12,180
both parties have like a joint secret

232
00:09:12,180 --> 00:09:14,279
knowledge this is called a TLS Masters

233
00:09:14,279 --> 00:09:15,720
Master Secret

234
00:09:15,720 --> 00:09:17,820
Ms and this is essentially what

235
00:09:17,820 --> 00:09:20,220
qualifies them at endpoint as endpoints

236
00:09:20,220 --> 00:09:22,019
of the channel the knowledge of this

237
00:09:22,019 --> 00:09:24,660
master secret the um the record so the

238
00:09:24,660 --> 00:09:26,459
actual encryption keys are derived from

239
00:09:26,459 --> 00:09:27,899
this master Secret

240
00:09:27,899 --> 00:09:29,940
and what we would like to do is that we

241
00:09:29,940 --> 00:09:31,620
would like to bind the authentication

242
00:09:31,620 --> 00:09:33,720
that these parties perform to the

243
00:09:33,720 --> 00:09:36,060
knowledge of this master secret okay

244
00:09:36,060 --> 00:09:38,700
and for this we can derive we shouldn't

245
00:09:38,700 --> 00:09:41,279
use the master secret itself but we can

246
00:09:41,279 --> 00:09:42,660
derive from it something it's called a

247
00:09:42,660 --> 00:09:44,940
channel binder you can for Simplicity

248
00:09:44,940 --> 00:09:47,399
just think about this as hash of the

249
00:09:47,399 --> 00:09:50,899
past of the of the master Secret

250
00:09:52,680 --> 00:09:54,959
okay we need another building block

251
00:09:54,959 --> 00:09:58,680
which is a TLS 1.3 extension called

252
00:09:58,680 --> 00:10:01,680
exported authenticators

253
00:10:01,680 --> 00:10:05,220
exported authenticators offer post

254
00:10:05,220 --> 00:10:08,339
handshake public key authentication okay

255
00:10:08,339 --> 00:10:11,580
so you should be familiar with some of

256
00:10:11,580 --> 00:10:13,140
these words post handshake I already

257
00:10:13,140 --> 00:10:14,820
explained but now there's no password

258
00:10:14,820 --> 00:10:16,980
here there's a public key okay

259
00:10:16,980 --> 00:10:19,560
so this exported authenticator's

260
00:10:19,560 --> 00:10:22,740
protocol allows to allow us TLS

261
00:10:22,740 --> 00:10:24,839
endpoints to authenticate on the public

262
00:10:24,839 --> 00:10:27,540
keys to each other after establishment

263
00:10:27,540 --> 00:10:29,820
of the channel as often as they want in

264
00:10:29,820 --> 00:10:31,980
both directions

265
00:10:31,980 --> 00:10:34,620
okay so this is an RFC you can find it

266
00:10:34,620 --> 00:10:38,040
here also an ITF RFC

267
00:10:38,040 --> 00:10:39,779
okay how does this work it's very simple

268
00:10:39,779 --> 00:10:42,420
it's essentially sign and Mac in this

269
00:10:42,420 --> 00:10:44,640
case I'm going to show you a client who

270
00:10:44,640 --> 00:10:46,320
wants to authenticate to a server okay

271
00:10:46,320 --> 00:10:48,899
so the client holds a keep here then he

272
00:10:48,899 --> 00:10:52,140
derives a Mac key k

273
00:10:52,140 --> 00:10:53,519
from the channel binder in a

274
00:10:53,519 --> 00:10:55,560
deterministic way just again think about

275
00:10:55,560 --> 00:10:57,720
this as hashing the channel binder

276
00:10:57,720 --> 00:11:00,120
together with some label

277
00:11:00,120 --> 00:11:02,700
and then he's going to sign the nuns and

278
00:11:02,700 --> 00:11:05,160
the channel binder actually a hash

279
00:11:05,160 --> 00:11:06,839
sorry not the most recent version of my

280
00:11:06,839 --> 00:11:07,680
slides

281
00:11:07,680 --> 00:11:09,360
a hash of the general binder and the

282
00:11:09,360 --> 00:11:10,579
nuns

283
00:11:10,579 --> 00:11:13,380
and then he he computes a Mac on this

284
00:11:13,380 --> 00:11:15,180
signature on the channel binder and

285
00:11:15,180 --> 00:11:16,500
announced I believe also on the hash of

286
00:11:16,500 --> 00:11:17,940
all these values

287
00:11:17,940 --> 00:11:19,800
and then he sends the signature and the

288
00:11:19,800 --> 00:11:22,440
mac and the public key to the server the

289
00:11:22,440 --> 00:11:24,120
server can derive the same Mac key

290
00:11:24,120 --> 00:11:25,440
because he knows the same channel why

291
00:11:25,440 --> 00:11:27,480
not because he's an endpoint of the very

292
00:11:27,480 --> 00:11:28,920
same channel

293
00:11:28,920 --> 00:11:31,019
and then he can verify the signature

294
00:11:31,019 --> 00:11:33,000
under the public key that was sent and

295
00:11:33,000 --> 00:11:34,740
he can verify the mac and this is

296
00:11:34,740 --> 00:11:36,839
essentially a proof of knowledge

297
00:11:36,839 --> 00:11:38,519
um of the secret key belonging to the

298
00:11:38,519 --> 00:11:39,600
public key

299
00:11:39,600 --> 00:11:41,940
of the other channel endpoint so if this

300
00:11:41,940 --> 00:11:43,620
verification passes the server kind of

301
00:11:43,620 --> 00:11:46,140
adds to his like in his head okay I'm

302
00:11:46,140 --> 00:11:48,600
talking to somebody who knows the secret

303
00:11:48,600 --> 00:11:52,740
key to the public key here PK

304
00:11:52,740 --> 00:11:53,880
okay

305
00:11:53,880 --> 00:11:55,560
I want to talk about password I wanted

306
00:11:55,560 --> 00:11:56,640
to show you like secure password

307
00:11:56,640 --> 00:11:58,079
authentication why the hell am I talking

308
00:11:58,079 --> 00:12:00,720
about public keys

309
00:12:00,720 --> 00:12:03,660
the reason is that we have a simple tool

310
00:12:03,660 --> 00:12:06,120
going from passwords to public keys this

311
00:12:06,120 --> 00:12:08,339
is called opaque It's actually an

312
00:12:08,339 --> 00:12:10,440
asymmetric password authenticated case

313
00:12:10,440 --> 00:12:13,200
change protocol but we're not using the

314
00:12:13,200 --> 00:12:14,760
whole thing I told you before I want to

315
00:12:14,760 --> 00:12:17,579
kind of skip the key confirmation part

316
00:12:17,579 --> 00:12:18,899
um we're not using the whole thing we're

317
00:12:18,899 --> 00:12:20,940
just using a small part of it or like

318
00:12:20,940 --> 00:12:22,800
let's say not a small part but a part of

319
00:12:22,800 --> 00:12:24,360
it

320
00:12:24,360 --> 00:12:26,579
um it's a password-based protocol so the

321
00:12:26,579 --> 00:12:28,140
first thing in a client server setting

322
00:12:28,140 --> 00:12:29,700
we need to establish some sort of

323
00:12:29,700 --> 00:12:31,260
knowledge about the password at the

324
00:12:31,260 --> 00:12:32,700
server which is called a password file

325
00:12:32,700 --> 00:12:35,880
okay so this is called registration both

326
00:12:35,880 --> 00:12:38,040
Decline and the server they generate a

327
00:12:38,040 --> 00:12:39,779
key pair

328
00:12:39,779 --> 00:12:42,000
and the server additionally generates a

329
00:12:42,000 --> 00:12:45,120
prf key okay and then they both engage

330
00:12:45,120 --> 00:12:46,700
in a

331
00:12:46,700 --> 00:12:49,019
two-party protocol which is called an

332
00:12:49,019 --> 00:12:50,820
oblivious pseudonym function it's an

333
00:12:50,820 --> 00:12:53,760
oblivious evaluation of a prf of which

334
00:12:53,760 --> 00:12:55,920
the server contributes the key the prf

335
00:12:55,920 --> 00:12:58,380
key and the client contributes the input

336
00:12:58,380 --> 00:13:01,079
on which the prf should be computed

337
00:13:01,079 --> 00:13:03,360
and the client also receives the output

338
00:13:03,360 --> 00:13:06,779
okay and this is essentially a secure

339
00:13:06,779 --> 00:13:07,980
computation meaning that the server

340
00:13:07,980 --> 00:13:09,899
learns absolutely nothing and the client

341
00:13:09,899 --> 00:13:11,579
also learns nothing about the key K

342
00:13:11,579 --> 00:13:14,160
except for this one prf value

343
00:13:14,160 --> 00:13:15,420
okay

344
00:13:15,420 --> 00:13:18,420
so the client has now somehow hardened

345
00:13:18,420 --> 00:13:20,519
or transformed his password into

346
00:13:20,519 --> 00:13:23,339
something more secure roughly

347
00:13:23,339 --> 00:13:24,839
intuitively

348
00:13:24,839 --> 00:13:27,480
and now so this is called the RW value

349
00:13:27,480 --> 00:13:30,360
in our Peg specification and he's going

350
00:13:30,360 --> 00:13:32,459
to use this RW this kind of hardened

351
00:13:32,459 --> 00:13:34,980
password as an encryption key to encrypt

352
00:13:34,980 --> 00:13:37,740
his own secret key okay

353
00:13:37,740 --> 00:13:39,600
and he's also encrypting the public key

354
00:13:39,600 --> 00:13:41,820
of the server alone so this is called

355
00:13:41,820 --> 00:13:44,279
the opaque envelope and now the client

356
00:13:44,279 --> 00:13:46,920
is sending his name just some sort of

357
00:13:46,920 --> 00:13:49,260
some username that he chooses the

358
00:13:49,260 --> 00:13:51,000
envelope and his own public key to the

359
00:13:51,000 --> 00:13:53,940
server okay and the server stores this

360
00:13:53,940 --> 00:13:59,540
all under Bob's password file okay

361
00:14:02,399 --> 00:14:04,620
okay now in the online phase when we

362
00:14:04,620 --> 00:14:06,000
actually want to retrieve these public

363
00:14:06,000 --> 00:14:08,880
Keys again from the password it looks

364
00:14:08,880 --> 00:14:11,220
very similar so the client comes says hi

365
00:14:11,220 --> 00:14:13,680
I'm Bob

366
00:14:13,680 --> 00:14:15,660
the server can retrieve the password

367
00:14:15,660 --> 00:14:17,579
file for Bob and he finds again this

368
00:14:17,579 --> 00:14:20,399
like prf key here the same that he used

369
00:14:20,399 --> 00:14:21,959
before and then they're just going to do

370
00:14:21,959 --> 00:14:23,519
the same as before they're going to

371
00:14:23,519 --> 00:14:26,399
recompute the client is recomputing the

372
00:14:26,399 --> 00:14:29,339
the prf value of the password and then

373
00:14:29,339 --> 00:14:31,440
declined the server sends the envelope

374
00:14:31,440 --> 00:14:33,360
and the client can decrypt his secret

375
00:14:33,360 --> 00:14:35,040
key from the envelope

376
00:14:35,040 --> 00:14:36,300
okay

377
00:14:36,300 --> 00:14:39,839
so the result of this of this step of

378
00:14:39,839 --> 00:14:42,180
this opaque step is that both the client

379
00:14:42,180 --> 00:14:44,220
and the server hold their own secret key

380
00:14:44,220 --> 00:14:46,500
and the public key of the other party

381
00:14:46,500 --> 00:14:49,139
okay and from this we can now invoke the

382
00:14:49,139 --> 00:14:50,760
exported authenticator's protocol which

383
00:14:50,760 --> 00:14:52,740
we can use to prove knowledge of these

384
00:14:52,740 --> 00:14:55,760
secret keys to each other

385
00:14:56,880 --> 00:14:58,560
and this knowledge of the secret key it

386
00:14:58,560 --> 00:15:00,240
corresponds to the password so actually

387
00:15:00,240 --> 00:15:01,380
it's not entirely true it doesn't

388
00:15:01,380 --> 00:15:02,940
correspond to the to the knowledge of

389
00:15:02,940 --> 00:15:04,440
the password it corresponds to either

390
00:15:04,440 --> 00:15:06,899
the knowledge of the password or the

391
00:15:06,899 --> 00:15:08,639
knowledge of the secret key

392
00:15:08,639 --> 00:15:11,519
okay but since somehow this account is

393
00:15:11,519 --> 00:15:13,139
tied to

394
00:15:13,139 --> 00:15:15,779
um to this uh the secret key there's a

395
00:15:15,779 --> 00:15:17,519
secret key is kind of somehow Superior

396
00:15:17,519 --> 00:15:19,079
knowledge of the password so we're okay

397
00:15:19,079 --> 00:15:21,060
with somebody who just remembers the

398
00:15:21,060 --> 00:15:24,240
secret key instead of the password

399
00:15:24,240 --> 00:15:26,160
okay so this is device independent Bob

400
00:15:26,160 --> 00:15:27,600
doesn't have to remember his secret key

401
00:15:27,600 --> 00:15:30,060
he can lose all the all the all the data

402
00:15:30,060 --> 00:15:32,100
and use another device and just start

403
00:15:32,100 --> 00:15:34,019
from the password

404
00:15:34,019 --> 00:15:36,420
and also crucially the password only was

405
00:15:36,420 --> 00:15:38,399
involved in the last two slides and the

406
00:15:38,399 --> 00:15:41,040
server never saw the password

407
00:15:41,040 --> 00:15:43,199
which is what we wanted to achieve in

408
00:15:43,199 --> 00:15:44,760
the first place

409
00:15:44,760 --> 00:15:47,040
putting things together on the first

410
00:15:47,040 --> 00:15:49,380
layer we had the um

411
00:15:49,380 --> 00:15:52,019
the the channel establishment which is

412
00:15:52,019 --> 00:15:55,260
the TLs handshake in this case we saw

413
00:15:55,260 --> 00:15:56,459
that we can have public key or

414
00:15:56,459 --> 00:15:58,440
syndication on this channel tied to this

415
00:15:58,440 --> 00:16:00,600
channel actually and then we saw that we

416
00:16:00,600 --> 00:16:02,459
can actually retrieve these public keys

417
00:16:02,459 --> 00:16:04,160
to authenticate with from a password

418
00:16:04,160 --> 00:16:07,260
okay so this is as I said called a TLS

419
00:16:07,260 --> 00:16:09,480
opaque protocol and it gives us Post

420
00:16:09,480 --> 00:16:11,040
handshake oblivious password

421
00:16:11,040 --> 00:16:12,779
authentication that we can just switch

422
00:16:12,779 --> 00:16:16,220
on on a TLS connection

423
00:16:17,220 --> 00:16:19,800
okay so to analyze the security of this

424
00:16:19,800 --> 00:16:24,420
like um rather complex protocol

425
00:16:24,420 --> 00:16:26,820
um a modular analysis is kind of in

426
00:16:26,820 --> 00:16:28,320
place because you know it has all these

427
00:16:28,320 --> 00:16:30,600
modular components already so what we

428
00:16:30,600 --> 00:16:33,420
did is we abstracted the channel to

429
00:16:33,420 --> 00:16:35,399
another welded TLS handshake to an

430
00:16:35,399 --> 00:16:37,139
unauthenticated secure Channel with a

431
00:16:37,139 --> 00:16:39,000
unique binder

432
00:16:39,000 --> 00:16:41,160
the next level is that the exported

433
00:16:41,160 --> 00:16:42,540
authenticators protocol gives us

434
00:16:42,540 --> 00:16:45,060
something that we call Post handshake

435
00:16:45,060 --> 00:16:47,459
public key authentication okay

436
00:16:47,459 --> 00:16:48,839
and the third layer we actually don't

437
00:16:48,839 --> 00:16:50,519
abstract it anymore because it's just a

438
00:16:50,519 --> 00:16:52,980
specific protocol this specific specific

439
00:16:52,980 --> 00:16:55,680
part of the of the opaque protocol

440
00:16:55,680 --> 00:16:58,500
okay so to prove the security of TLS

441
00:16:58,500 --> 00:17:00,779
opaque first we have to formalize these

442
00:17:00,779 --> 00:17:02,100
building blocks and we also of course

443
00:17:02,100 --> 00:17:03,300
have to formalize what we want to

444
00:17:03,300 --> 00:17:04,859
achieve in the end so what is actually

445
00:17:04,859 --> 00:17:06,839
post handshake oblivious password

446
00:17:06,839 --> 00:17:08,939
authentication

447
00:17:08,939 --> 00:17:11,640
and then for the proof um

448
00:17:11,640 --> 00:17:13,619
we completely ignore the left hand side

449
00:17:13,619 --> 00:17:15,599
of the slide the blue box and and the

450
00:17:15,599 --> 00:17:18,240
actual TLS opaque protocol and you just

451
00:17:18,240 --> 00:17:19,319
look at the right hand side of the

452
00:17:19,319 --> 00:17:21,179
protocol where you have these abstract

453
00:17:21,179 --> 00:17:22,980
building blocks that are much easier to

454
00:17:22,980 --> 00:17:25,380
deal with than protocol transcripts and

455
00:17:25,380 --> 00:17:27,179
messages and so on and so forth and

456
00:17:27,179 --> 00:17:29,580
actual instantiations and groups

457
00:17:29,580 --> 00:17:31,740
okay and then we prove that these

458
00:17:31,740 --> 00:17:33,660
abstract building blocks give you this

459
00:17:33,660 --> 00:17:34,919
post-hand check oblivious password

460
00:17:34,919 --> 00:17:36,900
authentication

461
00:17:36,900 --> 00:17:39,299
and then essentially to derive the

462
00:17:39,299 --> 00:17:42,360
security of the TLs opaque protocol we

463
00:17:42,360 --> 00:17:43,799
just have to prove that the building

464
00:17:43,799 --> 00:17:47,820
blocks instantiate these abstract

465
00:17:47,820 --> 00:17:49,740
um sorry that TLS handshake and the

466
00:17:49,740 --> 00:17:51,360
exported authenticators instantially at

467
00:17:51,360 --> 00:17:53,220
this abstract building blocks okay so

468
00:17:53,220 --> 00:17:55,740
then after proving these three things

469
00:17:55,740 --> 00:18:00,620
here we get the final result for free

470
00:18:00,660 --> 00:18:02,520
so what is the

471
00:18:02,520 --> 00:18:03,539
um

472
00:18:03,539 --> 00:18:06,000
the benefit of such a proof it's it

473
00:18:06,000 --> 00:18:08,160
makes things easier for the prover you

474
00:18:08,160 --> 00:18:09,840
can write three proofs instead of one

475
00:18:09,840 --> 00:18:11,100
big one

476
00:18:11,100 --> 00:18:12,960
and the other benefit is actually the

477
00:18:12,960 --> 00:18:15,299
lifetime of the proof so

478
00:18:15,299 --> 00:18:16,980
um it's a fairly modular protocol let's

479
00:18:16,980 --> 00:18:19,020
use these many building blocks and I

480
00:18:19,020 --> 00:18:20,640
Told You So currently it's you know

481
00:18:20,640 --> 00:18:22,980
build up on TLS it uses this EA

482
00:18:22,980 --> 00:18:25,559
extension it actually deploys a

483
00:18:25,559 --> 00:18:27,780
difficult-based or prf but at some point

484
00:18:27,780 --> 00:18:29,160
maybe you want to run this on another

485
00:18:29,160 --> 00:18:32,580
Channel or you finally manage to find an

486
00:18:32,580 --> 00:18:34,200
efficient post Quantum or puref

487
00:18:34,200 --> 00:18:36,539
unfortunately there's not in the program

488
00:18:36,539 --> 00:18:39,480
and these modular building blocks that

489
00:18:39,480 --> 00:18:41,160
we Define they kind of give you the

490
00:18:41,160 --> 00:18:43,500
properties that these future building

491
00:18:43,500 --> 00:18:46,620
blocks need to need to fulfill such that

492
00:18:46,620 --> 00:18:48,960
if you replace them in the protocol

493
00:18:48,960 --> 00:18:51,120
the overall security proof is preserved

494
00:18:51,120 --> 00:18:52,620
okay and this is something that we

495
00:18:52,620 --> 00:18:54,480
really need to need to worry about these

496
00:18:54,480 --> 00:18:55,980
days that not only you know our

497
00:18:55,980 --> 00:18:58,799
Protocols are post Quantum we have many

498
00:18:58,799 --> 00:19:00,840
things that are not post Quantum yet and

499
00:19:00,840 --> 00:19:02,460
we are writing proofs for them that

500
00:19:02,460 --> 00:19:06,000
should kind of adopt to the setting when

501
00:19:06,000 --> 00:19:08,280
we find alternatives for these building

502
00:19:08,280 --> 00:19:10,760
blocks

503
00:19:10,799 --> 00:19:13,020
I think I'm out of time

504
00:19:13,020 --> 00:19:15,660
so okay to summarize um we proved the

505
00:19:15,660 --> 00:19:17,280
security of the exported authenticators

506
00:19:17,280 --> 00:19:19,440
protocol we proved the security of the

507
00:19:19,440 --> 00:19:22,380
TLs opaque protocol and this to our

508
00:19:22,380 --> 00:19:24,539
knowledge is the first formal analysis

509
00:19:24,539 --> 00:19:25,500
and

510
00:19:25,500 --> 00:19:28,020
um security modeling of

511
00:19:28,020 --> 00:19:31,020
um a replacement of password over TLS

512
00:19:31,020 --> 00:19:32,820
which in my opinion is something that we

513
00:19:32,820 --> 00:19:34,799
should really take on

514
00:19:34,799 --> 00:19:37,340
thank you

515
00:19:40,100 --> 00:19:42,919
thank you

516
00:19:42,919 --> 00:19:45,660
if you have questions please come to the

517
00:19:45,660 --> 00:19:48,679
front to the microphone

518
00:19:48,960 --> 00:19:51,620
yes

519
00:19:52,940 --> 00:19:55,440
thanks for a nice presentation

520
00:19:55,440 --> 00:19:57,780
um what about key rotation so TLS

521
00:19:57,780 --> 00:19:58,919
usually comes with something like

522
00:19:58,919 --> 00:20:01,020
forward secrecy post compromise security

523
00:20:01,020 --> 00:20:03,419
have you thought about this we haven't

524
00:20:03,419 --> 00:20:05,400
we haven't thought about this

525
00:20:05,400 --> 00:20:07,260
um the authentication is something

526
00:20:07,260 --> 00:20:10,679
rather short-term I would say so

527
00:20:10,679 --> 00:20:13,140
um I would say if you if you rotate the

528
00:20:13,140 --> 00:20:15,780
key in that case so you you sample the

529
00:20:15,780 --> 00:20:16,880
secret key

530
00:20:16,880 --> 00:20:19,860
new refresh at each authentication is

531
00:20:19,860 --> 00:20:21,120
correct

532
00:20:21,120 --> 00:20:22,679
because if you have a long-term secret

533
00:20:22,679 --> 00:20:25,200
kitten I mean so the result of the of

534
00:20:25,200 --> 00:20:26,760
running the TLs opaque protocol is

535
00:20:26,760 --> 00:20:28,440
essentially a bit at the served so if

536
00:20:28,440 --> 00:20:30,860
the server

537
00:20:32,280 --> 00:20:34,080
now that you know your password just

538
00:20:34,080 --> 00:20:37,020
because we switch our our underlying TLS

539
00:20:37,020 --> 00:20:39,120
Keys it doesn't mean you you forgot your

540
00:20:39,120 --> 00:20:41,400
password right yes I mean so I can still

541
00:20:41,400 --> 00:20:42,900
believe that you know the password so

542
00:20:42,900 --> 00:20:44,700
you kind of remain authenticated in my

543
00:20:44,700 --> 00:20:46,380
head I would say

544
00:20:46,380 --> 00:20:47,940
but it's a good point I have not thought

545
00:20:47,940 --> 00:20:49,620
about what how key rotation should be

546
00:20:49,620 --> 00:20:51,059
handled

547
00:20:51,059 --> 00:20:54,179
I guess it would be that as a lot I mean

548
00:20:54,179 --> 00:20:56,039
the authentication essentially remains

549
00:20:56,039 --> 00:20:57,660
through the lifetime of the channel so

550
00:20:57,660 --> 00:20:58,980
that would be a lifetime of the channel

551
00:20:58,980 --> 00:21:00,660
thanks

552
00:21:00,660 --> 00:21:02,940
okay maybe one very very quick question

553
00:21:02,940 --> 00:21:05,340
and in the meantime uh the speaker of

554
00:21:05,340 --> 00:21:07,140
the second talk can come to the front

555
00:21:07,140 --> 00:21:08,160
please

556
00:21:08,160 --> 00:21:10,080
thank you okay perfect

557
00:21:10,080 --> 00:21:13,200
okay a short question about the uh 0.4

558
00:21:13,200 --> 00:21:15,380
here strong possible protection

559
00:21:15,380 --> 00:21:19,080
is that also guaranteed when so for

560
00:21:19,080 --> 00:21:21,059
example the service compromise of the K

561
00:21:21,059 --> 00:21:26,220
which is used in an opif uh it's would

562
00:21:26,220 --> 00:21:28,140
you mind going back to the retreat into

563
00:21:28,140 --> 00:21:30,380
the retrieval slide

564
00:21:30,380 --> 00:21:32,640
and here

565
00:21:32,640 --> 00:21:35,640
uh if key is compromised and if the

566
00:21:35,640 --> 00:21:37,440
password does not have enough entropy

567
00:21:37,440 --> 00:21:39,120
yet if I know the key as well as the

568
00:21:39,120 --> 00:21:41,220
let's say the envelope here as a

569
00:21:41,220 --> 00:21:43,620
possible to read to recover the password

570
00:21:43,620 --> 00:21:47,159
yes so if the um if the key is

571
00:21:47,159 --> 00:21:48,299
compromised

572
00:21:48,299 --> 00:21:50,640
um and so I mean the key is stored here

573
00:21:50,640 --> 00:21:52,679
in this password file so we would assume

574
00:21:52,679 --> 00:21:53,820
that if the key is compromised the

575
00:21:53,820 --> 00:21:55,740
envelope is compromised as well and this

576
00:21:55,740 --> 00:21:57,480
would allow the attacker to run offline

577
00:21:57,480 --> 00:21:59,400
dictionary attacks against the password

578
00:21:59,400 --> 00:22:00,480
file

579
00:22:00,480 --> 00:22:02,340
you can essentially think about the the

580
00:22:02,340 --> 00:22:04,679
key the key is essentially just you know

581
00:22:04,679 --> 00:22:06,240
this is a hash function a keyed hash

582
00:22:06,240 --> 00:22:07,740
function if you have the key you can

583
00:22:07,740 --> 00:22:08,880
compute the hash function so this

584
00:22:08,880 --> 00:22:11,400
provides no additional protection

585
00:22:11,400 --> 00:22:13,919
um over a hashed database that gets

586
00:22:13,919 --> 00:22:15,360
compromised at the point of compromise

587
00:22:15,360 --> 00:22:18,179
obviously right thank you very much

588
00:22:18,179 --> 00:22:21,000
okay let's thank Julia again and in the

589
00:22:21,000 --> 00:22:24,380
meantime we set up the settings

590
00:22:31,020 --> 00:22:34,740
okay and the second talk while setting

591
00:22:34,740 --> 00:22:36,120
up

592
00:22:36,120 --> 00:22:39,439
should I probably help you

593
00:22:57,260 --> 00:22:59,220
foreign

594
00:22:59,220 --> 00:23:02,820
the second talk is titled randomized

595
00:23:02,820 --> 00:23:04,559
half ideal Cipher on groups with

596
00:23:04,559 --> 00:23:07,860
applications to use C A Peg and the

597
00:23:07,860 --> 00:23:10,380
speaker is stanislav yaretsky

598
00:23:10,380 --> 00:23:13,620
um yeah let's uh yeah welcome stanislav

599
00:23:13,620 --> 00:23:16,280
thank you

600
00:23:18,600 --> 00:23:20,640
thank you so much good afternoon thank

601
00:23:20,640 --> 00:23:23,340
you for the introduction okay

602
00:23:23,340 --> 00:23:26,340
um so in this paper we

603
00:23:26,340 --> 00:23:27,240
um

604
00:23:27,240 --> 00:23:29,340
introduce the notion of half ideal

605
00:23:29,340 --> 00:23:33,419
Cipher for and in particular for group

606
00:23:33,419 --> 00:23:36,299
domains which includes bit strings such

607
00:23:36,299 --> 00:23:40,380
as you know clarification and

608
00:23:40,380 --> 00:23:42,960
um have ideal Cipher is a weakening of

609
00:23:42,960 --> 00:23:46,500
an ideal Cipher model in two ways first

610
00:23:46,500 --> 00:23:49,140
you need padding so when you encrypt a

611
00:23:49,140 --> 00:23:52,320
group element you need some extra order

612
00:23:52,320 --> 00:23:55,799
of security parameter bits and also the

613
00:23:55,799 --> 00:23:57,659
second weakening is with adversity

614
00:23:57,659 --> 00:24:00,000
encrypts the cipher is not random only

615
00:24:00,000 --> 00:24:03,539
this m bits of Cipher are random

616
00:24:03,539 --> 00:24:06,240
nevertheless we argue that half ID or

617
00:24:06,240 --> 00:24:08,280
Cipher can replace ID or Cipher in many

618
00:24:08,280 --> 00:24:10,380
password-based protocols in pegs and

619
00:24:10,380 --> 00:24:13,860
Apex and we showed that this can be

620
00:24:13,860 --> 00:24:15,840
efficiently realized using a single

621
00:24:15,840 --> 00:24:18,840
Arrow hash onto a group

622
00:24:18,840 --> 00:24:21,539
so in the talk I will explain first like

623
00:24:21,539 --> 00:24:23,640
why ideal Cipher is useful for this pack

624
00:24:23,640 --> 00:24:26,880
applications uh why implementing ideal

625
00:24:26,880 --> 00:24:30,299
cipheron groups was not so easy and then

626
00:24:30,299 --> 00:24:32,940
have this idea half idea Cipher works

627
00:24:32,940 --> 00:24:35,280
and and what is the model and why it

628
00:24:35,280 --> 00:24:37,320
suffices

629
00:24:37,320 --> 00:24:40,400
okay so first uh you know a beautiful

630
00:24:40,400 --> 00:24:43,799
protocol by beloved Merit encrypted key

631
00:24:43,799 --> 00:24:45,500
exchange

632
00:24:45,500 --> 00:24:47,600
and in

633
00:24:47,600 --> 00:24:51,240
2000 Belair point of Allen Rockaway

634
00:24:51,240 --> 00:24:54,720
showed that if the encryption is an

635
00:24:54,720 --> 00:24:57,720
ideal Cipher then this is a password

636
00:24:57,720 --> 00:25:00,000
authenticated key exchange

637
00:25:00,000 --> 00:25:03,059
so how does it work you have a key

638
00:25:03,059 --> 00:25:04,799
exchange for example DV Hellman Q

639
00:25:04,799 --> 00:25:06,900
exchange so that's the blue stuff Alice

640
00:25:06,900 --> 00:25:09,840
creates a g2da bob G to the B The

641
00:25:09,840 --> 00:25:12,960
Exchange and compute The Joint key but

642
00:25:12,960 --> 00:25:16,140
you add a layer of a password encryption

643
00:25:16,140 --> 00:25:19,200
so Alice doesn't send jesusda in the

644
00:25:19,200 --> 00:25:20,880
clear she encrypts it under the password

645
00:25:20,880 --> 00:25:24,659
Bob decrypts under his he encrypts his

646
00:25:24,659 --> 00:25:28,260
contribution Alice decrypts that so it's

647
00:25:28,260 --> 00:25:31,679
like a layer on top of the Enoki

648
00:25:31,679 --> 00:25:34,500
exchange right and

649
00:25:34,500 --> 00:25:37,380
why intuitively this gives a opaque

650
00:25:37,380 --> 00:25:40,980
because so recall an ideal Cipher is

651
00:25:40,980 --> 00:25:45,480
this box in the sky that if whoever

652
00:25:45,480 --> 00:25:49,140
gives a password so we call Keys

653
00:25:49,140 --> 00:25:51,539
passwords because all these applications

654
00:25:51,539 --> 00:25:53,340
will use

655
00:25:53,340 --> 00:25:55,799
um a password as a key

656
00:25:55,799 --> 00:25:59,159
so you give a password and a message and

657
00:25:59,159 --> 00:26:01,080
this box in the sky gives you a random

658
00:26:01,080 --> 00:26:03,419
Cipher text in the opposite direction

659
00:26:03,419 --> 00:26:05,220
you give password and the cipher text

660
00:26:05,220 --> 00:26:06,659
and the box in the sky gives you a

661
00:26:06,659 --> 00:26:09,840
random plain text so why this would be

662
00:26:09,840 --> 00:26:11,400
great well first of all is Collision

663
00:26:11,400 --> 00:26:13,740
resilience so if you are hoping to

664
00:26:13,740 --> 00:26:16,220
create a single Cipher text which

665
00:26:16,220 --> 00:26:19,140
encrypts two different messages that you

666
00:26:19,140 --> 00:26:21,360
know you know what messages you want to

667
00:26:21,360 --> 00:26:23,100
encrypt under two different passwords

668
00:26:23,100 --> 00:26:24,419
and you're hoping to create Collision

669
00:26:24,419 --> 00:26:27,240
you can't right because every time it's

670
00:26:27,240 --> 00:26:28,440
random

671
00:26:28,440 --> 00:26:30,659
so therefore each ciphertext commits to

672
00:26:30,659 --> 00:26:33,299
one password that was possibly used in a

673
00:26:33,299 --> 00:26:36,299
forward Direction so any message here is

674
00:26:36,299 --> 00:26:38,820
like a commitment to the password

675
00:26:38,820 --> 00:26:40,500
which should happen in a password

676
00:26:40,500 --> 00:26:43,200
authentication another thing is that it

677
00:26:43,200 --> 00:26:45,240
is when you decrypt you get random

678
00:26:45,240 --> 00:26:47,059
values what does this mean

679
00:26:47,059 --> 00:26:52,380
in you in a reduction a decryption of

680
00:26:52,380 --> 00:26:54,240
any Cipher

681
00:26:54,240 --> 00:26:56,940
under any password except the one that

682
00:26:56,940 --> 00:26:59,220
was used in a forward Direction means

683
00:26:59,220 --> 00:27:00,960
it's a random challenge of the key

684
00:27:00,960 --> 00:27:04,140
exchange and therefore based on security

685
00:27:04,140 --> 00:27:07,440
of key exchange you you cannot break

686
00:27:07,440 --> 00:27:10,159
okay we had a similar

687
00:27:10,159 --> 00:27:13,200
version of eke that was actually an

688
00:27:13,200 --> 00:27:16,260
asymmetric Peg client server take you

689
00:27:16,260 --> 00:27:18,240
know the only thing here maybe is that

690
00:27:18,240 --> 00:27:22,080
it's very similar to eke and it's

691
00:27:22,080 --> 00:27:24,840
actually becomes asymmetric key exchange

692
00:27:24,840 --> 00:27:27,360
so a client server type and it also uses

693
00:27:27,360 --> 00:27:31,699
IDR Cipher for roughly in the same way

694
00:27:31,740 --> 00:27:32,820
okay

695
00:27:32,820 --> 00:27:34,799
so

696
00:27:34,799 --> 00:27:36,059
um

697
00:27:36,059 --> 00:27:39,480
how would you implement ITR cipras so

698
00:27:39,480 --> 00:27:42,120
maybe because

699
00:27:42,120 --> 00:27:43,980
it's such a beautiful protocol this

700
00:27:43,980 --> 00:27:46,740
encrypted key exchange is so simple but

701
00:27:46,740 --> 00:27:50,039
it wasn't used and I think that it

702
00:27:50,039 --> 00:27:52,620
wasn't used I mean there's probably two

703
00:27:52,620 --> 00:27:55,020
reasons okay maybe nobody wanted to use

704
00:27:55,020 --> 00:27:58,020
pegs to begin at all but even if they

705
00:27:58,020 --> 00:28:00,900
did apparently uh

706
00:28:00,900 --> 00:28:05,460
eke was it was patented

707
00:28:05,460 --> 00:28:07,620
but another reason I think is that

708
00:28:07,620 --> 00:28:09,120
actually it's not so easy to implement

709
00:28:09,120 --> 00:28:11,520
this ideal Cipher

710
00:28:11,520 --> 00:28:14,880
so for so the first idea okay so how

711
00:28:14,880 --> 00:28:16,919
about you do a yes encryption of group

712
00:28:16,919 --> 00:28:19,559
elements well that's completely not gold

713
00:28:19,559 --> 00:28:23,220
because that's item one because if I

714
00:28:23,220 --> 00:28:25,440
give you an as encryption of a group

715
00:28:25,440 --> 00:28:28,440
element under a password the new AES

716
00:28:28,440 --> 00:28:29,760
decrypt under different password

717
00:28:29,760 --> 00:28:31,320
candidates and you test whether

718
00:28:31,320 --> 00:28:33,419
decryptions are group elements and you

719
00:28:33,419 --> 00:28:35,340
immediately reject different password

720
00:28:35,340 --> 00:28:36,919
candidates

721
00:28:36,919 --> 00:28:39,120
you learn a lot of bits of password

722
00:28:39,120 --> 00:28:41,520
every time I use this thing and like a

723
00:28:41,520 --> 00:28:43,080
few times I use it you get the whole

724
00:28:43,080 --> 00:28:44,000
password

725
00:28:44,000 --> 00:28:47,900
extract another black Rockaway gave

726
00:28:47,900 --> 00:28:50,700
another construction like this

727
00:28:50,700 --> 00:28:54,299
if the group is sort of a significant

728
00:28:54,299 --> 00:28:57,000
fraction of a bit string domain

729
00:28:57,000 --> 00:29:00,179
then what you could do you to encrypt a

730
00:29:00,179 --> 00:29:02,460
group element you

731
00:29:02,460 --> 00:29:04,980
use a cipher over the extent you know

732
00:29:04,980 --> 00:29:08,340
the bitstring domain in a cycle until

733
00:29:08,340 --> 00:29:10,860
you hit the group element

734
00:29:10,860 --> 00:29:13,440
so that's a that's a that's an ideal

735
00:29:13,440 --> 00:29:17,220
Cipher if the bit size bitstring Cipher

736
00:29:17,220 --> 00:29:18,659
is ideal

737
00:29:18,659 --> 00:29:22,020
about the length of these Cycles will

738
00:29:22,020 --> 00:29:24,179
give you information about what passport

739
00:29:24,179 --> 00:29:26,580
was used because if I decrypt something

740
00:29:26,580 --> 00:29:28,500
on one password it gives me just one hop

741
00:29:28,500 --> 00:29:30,419
but under a different password it gives

742
00:29:30,419 --> 00:29:33,779
me 10 Hops and by timing if if I could

743
00:29:33,779 --> 00:29:35,700
see the timing information then I will

744
00:29:35,700 --> 00:29:36,779
get password

745
00:29:36,779 --> 00:29:39,059
so that's not doesn't sound like a great

746
00:29:39,059 --> 00:29:41,899
implementation in this in this domain

747
00:29:41,899 --> 00:29:44,299
more recently it's our

748
00:29:44,299 --> 00:29:46,740
encodings using quasi bijective

749
00:29:46,740 --> 00:29:49,440
encodings of group elements invertible

750
00:29:49,440 --> 00:29:51,419
encoding so

751
00:29:51,419 --> 00:29:53,340
you take a group Elementor elliptic

752
00:29:53,340 --> 00:29:55,880
curve point

753
00:29:55,880 --> 00:29:59,279
encoded as a bit strict and use IDL

754
00:29:59,279 --> 00:30:01,559
server over bit strings

755
00:30:01,559 --> 00:30:03,779
problem solved except that these

756
00:30:03,779 --> 00:30:06,960
encodings had issues so

757
00:30:06,960 --> 00:30:08,240
alligator

758
00:30:08,240 --> 00:30:11,159
is first of all it works only for some

759
00:30:11,159 --> 00:30:13,200
electric curves not for others but also

760
00:30:13,200 --> 00:30:15,960
it only works for half the domain

761
00:30:15,960 --> 00:30:18,679
so every other point you can do

762
00:30:18,679 --> 00:30:21,720
so what does it mean you suddenly have

763
00:30:21,720 --> 00:30:24,720
to resample so that your point is in the

764
00:30:24,720 --> 00:30:26,340
domain that alligator actually can

765
00:30:26,340 --> 00:30:27,860
process

766
00:30:27,860 --> 00:30:30,480
not you can do but it's not the most

767
00:30:30,480 --> 00:30:32,580
convenient and it increases the running

768
00:30:32,580 --> 00:30:34,799
time of the protocols

769
00:30:34,799 --> 00:30:38,039
uh the Debussy gave another encoding

770
00:30:38,039 --> 00:30:40,380
which is expanding a non-constant time

771
00:30:40,380 --> 00:30:43,380
it is a little more expensive

772
00:30:43,380 --> 00:30:45,480
um but I think there is less

773
00:30:45,480 --> 00:30:47,760
implementation so you know maybe this

774
00:30:47,760 --> 00:30:49,679
can be improved also

775
00:30:49,679 --> 00:30:52,980
let's say you can do five stuff so eight

776
00:30:52,980 --> 00:30:55,080
rounds of five star gives you an ideal

777
00:30:55,080 --> 00:30:56,419
Cipher

778
00:30:56,419 --> 00:30:59,760
and if one of the wire holds group

779
00:30:59,760 --> 00:31:02,159
elements and you replace X source with

780
00:31:02,159 --> 00:31:03,600
group operations

781
00:31:03,600 --> 00:31:07,140
then this is an ideal Cipher too uh but

782
00:31:07,140 --> 00:31:09,419
because eight rounds is minimal then you

783
00:31:09,419 --> 00:31:13,679
need four rounds on hashing onto a curve

784
00:31:13,679 --> 00:31:16,340
uh

785
00:31:16,340 --> 00:31:20,039
showed that a two round feistel has sort

786
00:31:20,039 --> 00:31:22,220
of sufficient

787
00:31:22,220 --> 00:31:24,600
randomizing key committing properties

788
00:31:24,600 --> 00:31:28,459
for eke security

789
00:31:29,480 --> 00:31:33,000
well they they sold but not in my view

790
00:31:33,000 --> 00:31:38,059
not exactly so it's a

791
00:31:40,279 --> 00:31:44,520
one has to recheck I think at some point

792
00:31:44,520 --> 00:31:46,620
perhaps the proof of this will be will

793
00:31:46,620 --> 00:31:50,840
will be in the public domain

794
00:31:51,179 --> 00:31:54,120
um and but there is the problems in that

795
00:31:54,120 --> 00:31:57,720
that they only managed to model this as

796
00:31:57,720 --> 00:31:59,940
a using game-based properties the

797
00:31:59,940 --> 00:32:00,960
properties didn't include

798
00:32:00,960 --> 00:32:03,059
non-malleability and the kind of man in

799
00:32:03,059 --> 00:32:06,059
the middle uh security and there are

800
00:32:06,059 --> 00:32:07,980
game based so I would argue they were

801
00:32:07,980 --> 00:32:09,659
hard to use

802
00:32:09,659 --> 00:32:11,760
so our observation is that you make a

803
00:32:11,760 --> 00:32:13,679
small modification to feistel and you

804
00:32:13,679 --> 00:32:16,940
get this half ideal Cipher abstraction

805
00:32:16,940 --> 00:32:21,059
uh which we believe is easier to use

806
00:32:21,059 --> 00:32:24,000
okay so how

807
00:32:24,000 --> 00:32:26,580
um here is two five star

808
00:32:26,580 --> 00:32:30,299
on a and you can think of it as a cipher

809
00:32:30,299 --> 00:32:32,460
on an extended domain you have group

810
00:32:32,460 --> 00:32:35,880
element on wire wire one wire and a bit

811
00:32:35,880 --> 00:32:39,059
string on the other uh hash onto a group

812
00:32:39,059 --> 00:32:43,500
group operation hash onto bitstring xor

813
00:32:43,500 --> 00:32:46,020
okay and here is the modified

814
00:32:46,020 --> 00:32:47,299
construction

815
00:32:47,299 --> 00:32:51,080
it's the same except you replace the xor

816
00:32:51,080 --> 00:32:53,700
by an encryption

817
00:32:53,700 --> 00:32:56,340
it's a bit string encryption so on that

818
00:32:56,340 --> 00:32:57,240
wire

819
00:32:57,240 --> 00:33:00,000
uh you're dealing with bits so you can

820
00:33:00,000 --> 00:33:02,820
use a standard encryption

821
00:33:02,820 --> 00:33:05,880
okay and therefore an ideal you know but

822
00:33:05,880 --> 00:33:10,159
we require in the model an ideal Cipher

823
00:33:10,380 --> 00:33:11,399
um

824
00:33:11,399 --> 00:33:12,779
so

825
00:33:12,779 --> 00:33:15,179
um the construction on the right is has

826
00:33:15,179 --> 00:33:17,580
all these sort of efficiency benefits

827
00:33:17,580 --> 00:33:20,340
because uh the

828
00:33:20,340 --> 00:33:23,159
in applications is to Hash onto the

829
00:33:23,159 --> 00:33:25,679
group that has dominant cost

830
00:33:25,679 --> 00:33:30,600
and you do the same hash exactly

831
00:33:30,600 --> 00:33:33,600
uh and

832
00:33:33,600 --> 00:33:35,940
um as we will argue this so this this

833
00:33:35,940 --> 00:33:38,460
model of ours which is a weakening of

834
00:33:38,460 --> 00:33:40,559
Ideal Cipher still has Collision

835
00:33:40,559 --> 00:33:43,260
resilience non-mallability all these

836
00:33:43,260 --> 00:33:45,779
properties of the ideal Cipher that we

837
00:33:45,779 --> 00:33:47,340
need

838
00:33:47,340 --> 00:33:49,039
why half

839
00:33:49,039 --> 00:33:52,559
it is because only the S part of the

840
00:33:52,559 --> 00:33:55,559
ciphertext is truly random the T part

841
00:33:55,559 --> 00:33:58,140
can be you know in some sense structured

842
00:33:58,140 --> 00:34:00,480
so it's there's just not enough

843
00:34:00,480 --> 00:34:03,860
happening on the right wire

844
00:34:03,919 --> 00:34:08,399
but that is in the kind of password

845
00:34:08,399 --> 00:34:11,699
encryption applications seem um

846
00:34:11,699 --> 00:34:14,159
basically not a problem like so it's not

847
00:34:14,159 --> 00:34:15,800
a problem that's ciphertext

848
00:34:15,800 --> 00:34:19,820
adversarially created ciphertext

849
00:34:19,820 --> 00:34:24,560
are can have structured half

850
00:34:24,599 --> 00:34:25,980
okay

851
00:34:25,980 --> 00:34:28,918
so uh we'll argue so I will show you

852
00:34:28,918 --> 00:34:30,719
what what is this high five year Cipher

853
00:34:30,719 --> 00:34:33,179
exactly first let me just recall uh

854
00:34:33,179 --> 00:34:36,239
ideal Cipher quickly on this extended

855
00:34:36,239 --> 00:34:38,639
domain now right so in this case because

856
00:34:38,639 --> 00:34:41,639
the domain is bitstring comma group

857
00:34:41,639 --> 00:34:46,020
element so this is the plain text format

858
00:34:46,020 --> 00:34:49,379
and the ciphertext is random and also

859
00:34:49,379 --> 00:34:51,780
when I decrypt the plain text is in the

860
00:34:51,780 --> 00:34:53,699
same extended domain and it's chosen at

861
00:34:53,699 --> 00:34:55,800
random so that would happen if this was

862
00:34:55,800 --> 00:34:58,740
an IDR Cipher and what is a half

863
00:34:58,740 --> 00:35:01,560
it's this it's the red Edition

864
00:35:01,560 --> 00:35:04,020
so

865
00:35:04,020 --> 00:35:05,460
um

866
00:35:05,460 --> 00:35:07,560
when accessing half ideal Cipher

867
00:35:07,560 --> 00:35:10,680
adversary can specify what's the T part

868
00:35:10,680 --> 00:35:13,380
of the cipher text is and only the S

869
00:35:13,380 --> 00:35:15,060
part of the ciphertrix is chosen at

870
00:35:15,060 --> 00:35:17,480
random

871
00:35:18,300 --> 00:35:19,200
um

872
00:35:19,200 --> 00:35:21,720
and I would argue that it has basically

873
00:35:21,720 --> 00:35:24,960
if n is large enough right twice the

874
00:35:24,960 --> 00:35:26,579
security parameters and it's also

875
00:35:26,579 --> 00:35:29,220
Collision resilient and it has the same

876
00:35:29,220 --> 00:35:31,859
non-moldable straight line ciphertextual

877
00:35:31,859 --> 00:35:35,700
plain text extraction commitment and the

878
00:35:35,700 --> 00:35:38,760
reduction can embed random challenges

879
00:35:38,760 --> 00:35:41,040
into decryptions right so it has all

880
00:35:41,040 --> 00:35:42,900
these nice properties of IC except for

881
00:35:42,900 --> 00:35:43,680
this

882
00:35:43,680 --> 00:35:46,500
for this uh one that I don't see an

883
00:35:46,500 --> 00:35:48,720
application for which that would be an

884
00:35:48,720 --> 00:35:51,020
issue

885
00:35:51,900 --> 00:35:53,900
um

886
00:35:54,000 --> 00:35:57,540
you know so so so how do we argue that

887
00:35:57,540 --> 00:35:59,760
that the right realizes the thing on the

888
00:35:59,760 --> 00:36:03,920
left right we write a simulator that

889
00:36:03,920 --> 00:36:07,560
given a seeing as adversarial accesses

890
00:36:07,560 --> 00:36:09,839
to HH Prime and I see the building

891
00:36:09,839 --> 00:36:13,859
blocks of this Construction

892
00:36:13,859 --> 00:36:18,780
basically uses an ideal Cipher in the

893
00:36:18,780 --> 00:36:19,740
sky

894
00:36:19,740 --> 00:36:21,720
and can program

895
00:36:21,720 --> 00:36:25,680
outputs of HH Prime and IC in such a way

896
00:36:25,680 --> 00:36:28,020
that the view on the right is indisting

897
00:36:28,020 --> 00:36:30,599
control front of you on the left

898
00:36:30,599 --> 00:36:33,420
right and and and the there's this

899
00:36:33,420 --> 00:36:35,940
little IC box is the key because

900
00:36:35,940 --> 00:36:38,400
basically at this the reduction the

901
00:36:38,400 --> 00:36:42,420
simulator watches I see queries

902
00:36:42,420 --> 00:36:45,300
and you can see that if it sees an uh

903
00:36:45,300 --> 00:36:48,359
encryption query to the IC box

904
00:36:48,359 --> 00:36:51,780
then it says R and K and from K by

905
00:36:51,780 --> 00:36:54,060
corrosion resistance of H prime it gets

906
00:36:54,060 --> 00:36:58,560
password and T and now from R and T

907
00:36:58,560 --> 00:37:01,380
it gets m

908
00:37:01,380 --> 00:37:04,680
so it asks The Orange Box in the sky but

909
00:37:04,680 --> 00:37:07,140
it knows T so it pushes the T okay

910
00:37:07,140 --> 00:37:10,079
what's the s and it programs s into the

911
00:37:10,079 --> 00:37:12,900
output of IC and you know the decryption

912
00:37:12,900 --> 00:37:15,020
is is also

913
00:37:15,020 --> 00:37:20,660
possible so uh but but still we need to

914
00:37:20,660 --> 00:37:25,260
the blocks the bits size stuff on the

915
00:37:25,260 --> 00:37:27,720
left to be twice the security parameter

916
00:37:27,720 --> 00:37:31,020
because everything is the collisions

917
00:37:31,020 --> 00:37:37,440
uh write Creator explicit distinguisher

918
00:37:37,560 --> 00:37:40,020
okay so we in in for you know so in

919
00:37:40,020 --> 00:37:41,760
practice we'll have to start with an IC

920
00:37:41,760 --> 00:37:44,060
and here Cipher says 256

921
00:37:44,060 --> 00:37:46,980
block size

922
00:37:46,980 --> 00:37:49,200
and key size

923
00:37:49,200 --> 00:37:51,359
um just a little note that in the

924
00:37:51,359 --> 00:37:54,000
proceedings we have other interface what

925
00:37:54,000 --> 00:37:56,060
I told you was the adversarial

926
00:37:56,060 --> 00:37:58,619
interfaces there is also honest part

927
00:37:58,619 --> 00:38:01,320
interface which does not expose

928
00:38:01,320 --> 00:38:02,820
Randomness to the environment

929
00:38:02,820 --> 00:38:04,920
essentially

930
00:38:04,920 --> 00:38:06,960
excuse me and it's not clear that it's

931
00:38:06,960 --> 00:38:09,599
needed perhaps it's actually even you

932
00:38:09,599 --> 00:38:11,520
know confusing to have this as an

933
00:38:11,520 --> 00:38:15,259
additional interface I'm not sure

934
00:38:16,079 --> 00:38:17,760
um

935
00:38:17,760 --> 00:38:23,400
so aha okay so very briefly

936
00:38:23,400 --> 00:38:24,960
um

937
00:38:24,960 --> 00:38:28,680
I wanna say

938
00:38:28,680 --> 00:38:33,300
that even though this works we did have

939
00:38:33,300 --> 00:38:35,700
back in the conference version of the

940
00:38:35,700 --> 00:38:37,079
paper

941
00:38:37,079 --> 00:38:38,339
and

942
00:38:38,339 --> 00:38:41,579
um I can tell you what that is

943
00:38:41,579 --> 00:38:42,900
so

944
00:38:42,900 --> 00:38:43,920
um

945
00:38:43,920 --> 00:38:47,480
in actually two two bucks

946
00:38:47,480 --> 00:38:50,820
as far as I can tell you know Counting

947
00:38:50,820 --> 00:38:53,579
so um

948
00:38:53,579 --> 00:38:55,859
here is the theorem of that that

949
00:38:55,859 --> 00:38:58,160
actually this thing on the left compiles

950
00:38:58,160 --> 00:39:03,180
passive key exchange to a peg that

951
00:39:03,180 --> 00:39:06,200
doesn't seem true and thanks for to

952
00:39:06,200 --> 00:39:08,780
Manuel bargosa

953
00:39:08,780 --> 00:39:12,000
Julia Hesse to whom we are doing some

954
00:39:12,000 --> 00:39:14,960
follow-up work we sort of

955
00:39:14,960 --> 00:39:17,599
realized this it's not true

956
00:39:17,599 --> 00:39:21,780
so why uh here is a

957
00:39:21,780 --> 00:39:23,839
I mean maybe subtle I don't know

958
00:39:23,839 --> 00:39:26,280
adversary take an adversity who knows

959
00:39:26,280 --> 00:39:27,300
the password

960
00:39:27,300 --> 00:39:29,820
okay so this actually kind of removes

961
00:39:29,820 --> 00:39:33,119
all the passwords encryption layer it's

962
00:39:33,119 --> 00:39:35,520
irrelevant he knows the password there's

963
00:39:35,520 --> 00:39:37,500
two people Alice and Bob who have the

964
00:39:37,500 --> 00:39:39,119
same password addressing knows it as

965
00:39:39,119 --> 00:39:39,839
well

966
00:39:39,839 --> 00:39:41,940
so therefore all this password

967
00:39:41,940 --> 00:39:44,700
encryption you can throw out and what's

968
00:39:44,700 --> 00:39:47,160
underneath is just the basic key

969
00:39:47,160 --> 00:39:51,359
exchange which is not actively secure uh

970
00:39:51,359 --> 00:39:53,220
if the key exchange is only passively

971
00:39:53,220 --> 00:39:56,160
secure so right so attacker knows the

972
00:39:56,160 --> 00:39:59,579
password he sends Bob's message to Alice

973
00:39:59,579 --> 00:40:03,839
so she confused Hellman on a b but he

974
00:40:03,839 --> 00:40:07,500
gives his own contribution a star to Bob

975
00:40:07,500 --> 00:40:11,820
so Bob computes the key on a star B

976
00:40:11,820 --> 00:40:14,640
and now if for example a star is a

977
00:40:14,640 --> 00:40:16,140
square

978
00:40:16,140 --> 00:40:18,420
then one key is the square of the other

979
00:40:18,420 --> 00:40:20,880
you know if you use plain difficult one

980
00:40:20,880 --> 00:40:24,359
right so it's like rather glaring and so

981
00:40:24,359 --> 00:40:28,160
that's a you know it's an attacker who

982
00:40:28,160 --> 00:40:30,680
is an active attack

983
00:40:30,680 --> 00:40:33,599
so how come you know okay it's an active

984
00:40:33,599 --> 00:40:36,420
attack so what's the issue the issue is

985
00:40:36,420 --> 00:40:38,460
that uh

986
00:40:38,460 --> 00:40:41,520
it's an active attack on only Bob

987
00:40:41,520 --> 00:40:44,760
Alice was connected passively so she

988
00:40:44,760 --> 00:40:47,520
should be secure and she's not given

989
00:40:47,520 --> 00:40:52,079
Bob's key uh attacker sees Alice's key

990
00:40:52,079 --> 00:40:55,079
uh so what's the first uh this needs to

991
00:40:55,079 --> 00:40:56,960
be a one-time

992
00:40:56,960 --> 00:40:59,700
actively secure country exchange and a

993
00:40:59,700 --> 00:41:01,619
hash diffie-hellman is

994
00:41:01,619 --> 00:41:06,660
okay so this is maybe why also the

995
00:41:06,660 --> 00:41:08,400
Blogger punches The Rock Away actually

996
00:41:08,400 --> 00:41:10,980
don't have the generic compiler for any

997
00:41:10,980 --> 00:41:13,680
key exchange but a specific one and in

998
00:41:13,680 --> 00:41:17,579
fact they're using a hash DH uh in the

999
00:41:17,579 --> 00:41:20,640
2000 paper maybe you have to wrap up

1000
00:41:20,640 --> 00:41:23,040
okay

1001
00:41:23,040 --> 00:41:25,980
um yeah there is one more subtle thing

1002
00:41:25,980 --> 00:41:28,260
that okay so you can look at the slides

1003
00:41:28,260 --> 00:41:31,740
maybe one thing I should say is that uh

1004
00:41:31,740 --> 00:41:35,400
that recently uh on ePrint there is uh

1005
00:41:35,400 --> 00:41:38,880
uh we also do a version of this for

1006
00:41:38,880 --> 00:41:41,640
using any Anonymous Cam that has

1007
00:41:41,640 --> 00:41:45,000
applications to post Quantum uh secure

1008
00:41:45,000 --> 00:41:47,220
camps and

1009
00:41:47,220 --> 00:41:48,599
um

1010
00:41:48,599 --> 00:41:49,380
um

1011
00:41:49,380 --> 00:41:53,099
uh beginner at all have a paper that

1012
00:41:53,099 --> 00:41:56,760
basically have almost identical compiler

1013
00:41:56,760 --> 00:41:58,859
um and there's a different differences

1014
00:41:58,859 --> 00:42:02,400
in how the key derivation is done

1015
00:42:02,400 --> 00:42:03,560
um

1016
00:42:03,560 --> 00:42:07,260
and there are some questions uh like

1017
00:42:07,260 --> 00:42:10,320
with you know what is necessary and

1018
00:42:10,320 --> 00:42:12,780
sufficient in key derivation

1019
00:42:12,780 --> 00:42:14,579
to wrap up

1020
00:42:14,579 --> 00:42:17,280
uh we you know so this is what we do

1021
00:42:17,280 --> 00:42:19,800
some questions are like this ideal

1022
00:42:19,800 --> 00:42:23,460
Cipher that we use is needs 256 bits and

1023
00:42:23,460 --> 00:42:25,020
I'm actually not sure how to construct

1024
00:42:25,020 --> 00:42:28,079
it so like I'm not a symmetric Cipher

1025
00:42:28,079 --> 00:42:31,800
design person but I'm not sure that you

1026
00:42:31,800 --> 00:42:34,500
know toother are there artists some

1027
00:42:34,500 --> 00:42:36,000
stuff that we can just take out of the

1028
00:42:36,000 --> 00:42:37,920
box

1029
00:42:37,920 --> 00:42:38,460
um

1030
00:42:38,460 --> 00:42:41,359
and

1031
00:42:41,660 --> 00:42:44,099
there may be

1032
00:42:44,099 --> 00:42:45,660
if you really care about some

1033
00:42:45,660 --> 00:42:47,579
application it would be nice to actually

1034
00:42:47,579 --> 00:42:49,619
throw away this and go back to the

1035
00:42:49,619 --> 00:42:52,920
original two feistel of McCoy rasulak

1036
00:42:52,920 --> 00:42:54,560
and Roy

1037
00:42:54,560 --> 00:42:56,599
in particular

1038
00:42:56,599 --> 00:42:59,339
for post Quantum security maybe it's

1039
00:42:59,339 --> 00:43:01,740
easier to analyze hash functions than

1040
00:43:01,740 --> 00:43:04,619
ideal ciphers

1041
00:43:04,619 --> 00:43:07,880
um okay thank you

1042
00:43:13,980 --> 00:43:16,920
okay due to the time maybe take the

1043
00:43:16,920 --> 00:43:20,040
questions offline uh yeah and we have a

1044
00:43:20,040 --> 00:43:22,740
seven minutes track switch break and

1045
00:43:22,740 --> 00:43:24,359
after this we will continue here with

1046
00:43:24,359 --> 00:43:27,900
the real world crypto session see you in

1047
00:43:27,900 --> 00:43:30,240
five minutes and let's uh thanks

1048
00:43:30,240 --> 00:43:31,590
stanislav again

1049
00:43:31,590 --> 00:43:39,260
[Applause]

1050
00:43:51,680 --> 00:43:54,740
thank you

1051
00:43:55,220 --> 00:43:58,040
thank you

1052
00:43:58,040 --> 00:44:01,099
yeah yeah

1053
00:44:01,339 --> 00:44:02,900
yeah

1054
00:44:02,900 --> 00:44:05,460
I didn't know that you will do it so I

1055
00:44:05,460 --> 00:44:07,819
just uh

1056
00:44:07,980 --> 00:44:10,760
but we can

1057
00:44:14,280 --> 00:44:16,579
foreign

