1
00:00:00,539 --> 00:00:02,719
foreign

2
00:00:03,419 --> 00:00:05,460
good afternoon and welcome back I hope

3
00:00:05,460 --> 00:00:08,099
you enjoyed your lunch

4
00:00:08,099 --> 00:00:11,460
welcome to symmetric design two we have

5
00:00:11,460 --> 00:00:14,639
two talks in this session

6
00:00:14,639 --> 00:00:17,220
the first talk is entitled

7
00:00:17,220 --> 00:00:21,779
generic attack on duplex based aad modes

8
00:00:21,779 --> 00:00:24,720
using random function statistics

9
00:00:24,720 --> 00:00:28,939
joint work between hunger

10
00:00:33,719 --> 00:00:36,420
give it a talk so

11
00:00:36,420 --> 00:00:38,160
I switched to French mode

12
00:00:38,160 --> 00:00:40,699
go ahead

13
00:00:40,800 --> 00:00:43,260
thank you for the introduction so yeah

14
00:00:43,260 --> 00:00:46,940
this is a joint work with original

15
00:00:48,480 --> 00:00:51,480
okay so this talk is about generic

16
00:00:51,480 --> 00:00:52,980
attack against duplex based

17
00:00:52,980 --> 00:00:54,780
authenticated decryption with Associated

18
00:00:54,780 --> 00:00:58,079
data modes so first it's a forgery

19
00:00:58,079 --> 00:01:00,480
attack but actually in most cases we

20
00:01:00,480 --> 00:01:03,539
also we can also recover the secret key

21
00:01:03,539 --> 00:01:05,339
so it's based on the random function

22
00:01:05,339 --> 00:01:08,520
statistics but it's not the first work

23
00:01:08,520 --> 00:01:10,880
that uses a random function statistics

24
00:01:10,880 --> 00:01:13,920
however previous Works which mainly

25
00:01:13,920 --> 00:01:16,080
attacked a hash base Max or hash

26
00:01:16,080 --> 00:01:19,080
functions used average behavior of

27
00:01:19,080 --> 00:01:21,600
random functions whereas we use both

28
00:01:21,600 --> 00:01:24,000
average and exceptional behavior of such

29
00:01:24,000 --> 00:01:25,140
functions

30
00:01:25,140 --> 00:01:28,320
so our work allows to improve knowledge

31
00:01:28,320 --> 00:01:30,180
on the security of duplex based modes

32
00:01:30,180 --> 00:01:33,659
and also it breaks a security claim made

33
00:01:33,659 --> 00:01:36,720
by the designers of exudiac but that

34
00:01:36,720 --> 00:01:38,579
doesn't prevent Zu Jack from meeting the

35
00:01:38,579 --> 00:01:40,079
security requirements of nist

36
00:01:40,079 --> 00:01:43,740
lightweight cryptography competition

37
00:01:43,740 --> 00:01:45,479
okay so

38
00:01:45,479 --> 00:01:49,140
um there are two big families of they're

39
00:01:49,140 --> 00:01:51,360
not the only ones but main families of

40
00:01:51,360 --> 00:01:53,460
authenticated the encryption with

41
00:01:53,460 --> 00:01:55,680
Associated data algorithms so the first

42
00:01:55,680 --> 00:01:58,140
one is a the block Cipher based family

43
00:01:58,140 --> 00:02:02,640
and in that case you it uses a block

44
00:02:02,640 --> 00:02:04,979
Cipher as well as a mode and the second

45
00:02:04,979 --> 00:02:06,659
big family is permutation based

46
00:02:06,659 --> 00:02:09,080
algorithms in which case

47
00:02:09,080 --> 00:02:12,480
a kid mode is used with the public

48
00:02:12,480 --> 00:02:15,540
permutation so in for example zodiac is

49
00:02:15,540 --> 00:02:18,599
a duplex based mode that that sorry the

50
00:02:18,599 --> 00:02:21,720
Modi cyclist and the permutation news is

51
00:02:21,720 --> 00:02:24,300
the zudo 12.

52
00:02:24,300 --> 00:02:26,879
so duplex based mode of operations are

53
00:02:26,879 --> 00:02:28,980
permutation based modes they're actually

54
00:02:28,980 --> 00:02:30,860
the first ones

55
00:02:30,860 --> 00:02:33,599
that were introduced by a Bertoni DeMent

56
00:02:33,599 --> 00:02:35,760
Peters and Van Ash and they can be

57
00:02:35,760 --> 00:02:38,160
viewed as an adaptation to the adaad

58
00:02:38,160 --> 00:02:40,260
context of the sponge construction for

59
00:02:40,260 --> 00:02:41,760
hash functions

60
00:02:41,760 --> 00:02:44,760
so the first duplex based mode of

61
00:02:44,760 --> 00:02:46,920
operation is sponge wrap but there are

62
00:02:46,920 --> 00:02:49,200
other ones such as monkey wrap or

63
00:02:49,200 --> 00:02:50,640
cyclist

64
00:02:50,640 --> 00:02:53,700
okay so how do they work

65
00:02:53,700 --> 00:02:56,400
um so it's an aid algorithm so it takes

66
00:02:56,400 --> 00:02:59,099
as input a key a nonce Associated data

67
00:02:59,099 --> 00:03:02,760
and the ciphertext sorry plain text and

68
00:03:02,760 --> 00:03:06,900
a ciphertext and attack are returned so

69
00:03:06,900 --> 00:03:07,500
um

70
00:03:07,500 --> 00:03:10,080
yeah so the mode is instantiated with a

71
00:03:10,080 --> 00:03:12,959
permutation which operates on a state of

72
00:03:12,959 --> 00:03:14,099
length B

73
00:03:14,099 --> 00:03:17,220
and this stage is split in two parts so

74
00:03:17,220 --> 00:03:19,560
the first RBS are called the outer State

75
00:03:19,560 --> 00:03:21,420
and the next SEA bits are called the

76
00:03:21,420 --> 00:03:24,060
inner states and we call are the rate

77
00:03:24,060 --> 00:03:26,220
and see the capacity

78
00:03:26,220 --> 00:03:30,120
so in initial phase the key the nons and

79
00:03:30,120 --> 00:03:32,519
the associated data are fed to an

80
00:03:32,519 --> 00:03:35,519
initial function with which outputs a b

81
00:03:35,519 --> 00:03:40,319
initial a b long in B bits sorry initial

82
00:03:40,319 --> 00:03:43,620
States then the plain text is absorbed

83
00:03:43,620 --> 00:03:46,500
so each plain text blocked is absorbed

84
00:03:46,500 --> 00:03:49,200
to the outer State and the subsequently

85
00:03:49,200 --> 00:03:51,659
obtain the ciphertext block is a is

86
00:03:51,659 --> 00:03:54,000
returned and then the permutation p is

87
00:03:54,000 --> 00:03:55,260
applied

88
00:03:55,260 --> 00:03:58,080
then in the Final Phase a final function

89
00:03:58,080 --> 00:04:01,620
is applied and the tag is outputted

90
00:04:01,620 --> 00:04:05,280
so in zoo Jack R and C are equal to 192

91
00:04:05,280 --> 00:04:08,700
just to give you an idea

92
00:04:08,700 --> 00:04:12,000
okay so uh both privacy and integrity

93
00:04:12,000 --> 00:04:15,360
are required in aad algorithms but we

94
00:04:15,360 --> 00:04:17,339
mainly focus on Integrity because our

95
00:04:17,339 --> 00:04:20,399
attack is a forgery we assume that the

96
00:04:20,399 --> 00:04:23,100
adversary is non-respecting that means

97
00:04:23,100 --> 00:04:25,139
that the adversary cannot make two

98
00:04:25,139 --> 00:04:27,360
encryption queries that are different

99
00:04:27,360 --> 00:04:30,660
but have the same nouns but keep in mind

100
00:04:30,660 --> 00:04:33,240
that is not true for decryption query so

101
00:04:33,240 --> 00:04:34,620
you are allowed to use the same non

102
00:04:34,620 --> 00:04:35,940
several times

103
00:04:35,940 --> 00:04:38,820
in decryption and we also assume that

104
00:04:38,820 --> 00:04:41,220
there is no release and verified plain

105
00:04:41,220 --> 00:04:44,699
text that is if you send a ciphertext

106
00:04:44,699 --> 00:04:47,040
tag pair to the decryption Oracle and

107
00:04:47,040 --> 00:04:49,800
that is not valid the decryption Oracle

108
00:04:49,800 --> 00:04:52,199
will not return the plaintext

109
00:04:52,199 --> 00:04:54,419
so the goal of a forgery attack is to

110
00:04:54,419 --> 00:04:56,639
find a decryption query such that the

111
00:04:56,639 --> 00:04:59,100
tag verification succeeds and does the

112
00:04:59,100 --> 00:05:00,840
decryption Oracle does return the plain

113
00:05:00,840 --> 00:05:02,960
text

114
00:05:03,240 --> 00:05:05,639
um so you can make both encryption and

115
00:05:05,639 --> 00:05:07,680
uh and the forgery attempts sorry

116
00:05:07,680 --> 00:05:09,660
encryption queries and forgery attempts

117
00:05:09,660 --> 00:05:12,000
but actually our attack doesn't choose

118
00:05:12,000 --> 00:05:14,280
any encryption query

119
00:05:14,280 --> 00:05:17,400
so uh we're just going to look at how

120
00:05:17,400 --> 00:05:19,380
the decryption looks like in indeplex

121
00:05:19,380 --> 00:05:21,060
based modes

122
00:05:21,060 --> 00:05:23,880
um so there are two main things that are

123
00:05:23,880 --> 00:05:27,060
of interest in this in this picture so

124
00:05:27,060 --> 00:05:30,300
the first thing is as you can see in

125
00:05:30,300 --> 00:05:32,580
decryption queries the ciphertext blocks

126
00:05:32,580 --> 00:05:34,860
override the outer States before each

127
00:05:34,860 --> 00:05:37,380
application of the permutation

128
00:05:37,380 --> 00:05:40,020
and another thing that's interesting to

129
00:05:40,020 --> 00:05:42,900
us is you can see that if you make a

130
00:05:42,900 --> 00:05:46,620
correct guess on the interstate before

131
00:05:46,620 --> 00:05:48,300
the application of the final function

132
00:05:48,300 --> 00:05:52,100
you can build a forgery

133
00:05:53,160 --> 00:05:56,580
okay so the total time complexity of an

134
00:05:56,580 --> 00:06:00,180
attack is computed as a number of calls

135
00:06:00,180 --> 00:06:03,300
to the the permutation P so you add

136
00:06:03,300 --> 00:06:05,400
Sigma e the number of online calls to

137
00:06:05,400 --> 00:06:07,919
the permutation in encryption queries so

138
00:06:07,919 --> 00:06:11,880
for us that's uh that's zero Sigma Z is

139
00:06:11,880 --> 00:06:13,860
the number of online calls to P caused

140
00:06:13,860 --> 00:06:16,139
by fourder attempts and finally you can

141
00:06:16,139 --> 00:06:18,180
also make offline queries to the

142
00:06:18,180 --> 00:06:20,820
permutation or its inverse and there is

143
00:06:20,820 --> 00:06:22,919
also an extra term for a potentially

144
00:06:22,919 --> 00:06:25,818
extra operations

145
00:06:26,340 --> 00:06:28,979
okay so what's the motivation behind our

146
00:06:28,979 --> 00:06:31,500
work so when duplex based modes were

147
00:06:31,500 --> 00:06:33,780
introduced they they came with the First

148
00:06:33,780 --> 00:06:36,900
Security bound and it was proven at the

149
00:06:36,900 --> 00:06:39,300
time that uh I mean assuming a

150
00:06:39,300 --> 00:06:41,419
sufficiently large key and a

151
00:06:41,419 --> 00:06:45,419
sufficiently larger big tag length that

152
00:06:45,419 --> 00:06:48,560
there was no attack with a complexity

153
00:06:48,560 --> 00:06:51,539
less than 2 to the C over two

154
00:06:51,539 --> 00:06:54,060
but there was no matching attack

155
00:06:54,060 --> 00:06:57,120
um and in fact later a better security

156
00:06:57,120 --> 00:07:01,259
uh ban was proven and um

157
00:07:01,259 --> 00:07:02,759
yeah so

158
00:07:02,759 --> 00:07:05,880
this term especially is interesting so

159
00:07:05,880 --> 00:07:08,880
two to the C over Sigma D because it can

160
00:07:08,880 --> 00:07:11,460
look Beyond birthday at First Sight but

161
00:07:11,460 --> 00:07:13,440
in fact that's only if you League meet

162
00:07:13,440 --> 00:07:17,340
Sigma d uh because for example if Sigma

163
00:07:17,340 --> 00:07:20,160
D is a 2 to the C over two then it's not

164
00:07:20,160 --> 00:07:22,380
that birthday bound anymore it's not

165
00:07:22,380 --> 00:07:24,900
Beyond birthday anymore sorry we're

166
00:07:24,900 --> 00:07:28,199
looking at attacks so before the only

167
00:07:28,199 --> 00:07:30,780
attack that existed had complexity two

168
00:07:30,780 --> 00:07:33,000
to the C over Alpha where Alpha is a

169
00:07:33,000 --> 00:07:37,319
small constant and so there was a gap

170
00:07:37,319 --> 00:07:40,139
so there is still a gap but it's a

171
00:07:40,139 --> 00:07:43,680
slightly uh it's a bit better now with

172
00:07:43,680 --> 00:07:47,220
our work because we have a an attack of

173
00:07:47,220 --> 00:07:51,380
complexity two to the three C over four

174
00:07:52,199 --> 00:07:55,319
okay so uh the I'm gonna make like the

175
00:07:55,319 --> 00:07:57,060
main observation behind our attack now

176
00:07:57,060 --> 00:08:00,300
so as I said in decryption queries uh

177
00:08:00,300 --> 00:08:03,479
the ciphertext the sorry in decryption

178
00:08:03,479 --> 00:08:06,060
the ciphertext blocks they overwrite the

179
00:08:06,060 --> 00:08:08,340
outer States before each application of

180
00:08:08,340 --> 00:08:10,800
the permutation and that's what really

181
00:08:10,800 --> 00:08:11,880
interests us so we're just going to

182
00:08:11,880 --> 00:08:14,400
ignore the plain text now

183
00:08:14,400 --> 00:08:17,039
and we're also going to consider a

184
00:08:17,039 --> 00:08:20,699
specific ciphertext we're gonna look at

185
00:08:20,699 --> 00:08:22,580
the decryption of a long Cipher text

186
00:08:22,580 --> 00:08:25,860
that is built as the concatenation of

187
00:08:25,860 --> 00:08:28,919
the same block L times where again L is

188
00:08:28,919 --> 00:08:32,598
Big because we want a long Cipher text

189
00:08:33,059 --> 00:08:36,719
so in that case you can see uh the the

190
00:08:36,719 --> 00:08:39,059
tag verification as the iteration of a

191
00:08:39,059 --> 00:08:43,620
function on on C bits and the the

192
00:08:43,620 --> 00:08:46,560
function is constructed as follows so as

193
00:08:46,560 --> 00:08:50,700
input it takes x i and it outputs uh the

194
00:08:50,700 --> 00:08:53,519
image by the image by P of a beta

195
00:08:53,519 --> 00:08:56,040
concatenated with x i and you only take

196
00:08:56,040 --> 00:08:58,740
of course the the C less bits of of the

197
00:08:58,740 --> 00:09:01,019
obtained output

198
00:09:01,019 --> 00:09:04,500
and in that case for random beta we're

199
00:09:04,500 --> 00:09:06,899
going to expect this function f beta to

200
00:09:06,899 --> 00:09:09,300
behave as a random permutation drawing

201
00:09:09,300 --> 00:09:11,399
the set of permutation on on two to the

202
00:09:11,399 --> 00:09:13,560
C points and

203
00:09:13,560 --> 00:09:15,899
um since we don't know the key we also

204
00:09:15,899 --> 00:09:19,500
expect that for each nine each nouns x0

205
00:09:19,500 --> 00:09:21,360
is going to behave as a random Point

206
00:09:21,360 --> 00:09:24,420
drawn in the graph of that function f

207
00:09:24,420 --> 00:09:25,860
beta

208
00:09:25,860 --> 00:09:29,940
so uh how do graphs of random functions

209
00:09:29,940 --> 00:09:31,080
look like

210
00:09:31,080 --> 00:09:33,959
so they are defined as follow so a

211
00:09:33,959 --> 00:09:37,560
Vertex goes from not I to node J if and

212
00:09:37,560 --> 00:09:40,440
only if F of I is equal to J

213
00:09:40,440 --> 00:09:42,540
and so that looks like this so this is

214
00:09:42,540 --> 00:09:46,380
not a real function I've just yeah so as

215
00:09:46,380 --> 00:09:49,680
you can see it is built as a collection

216
00:09:49,680 --> 00:09:51,660
of connected components

217
00:09:51,660 --> 00:09:53,880
so for example in this image there are

218
00:09:53,880 --> 00:09:56,220
two connected components and each

219
00:09:56,220 --> 00:09:58,140
component itself is built as a

220
00:09:58,140 --> 00:10:00,360
collection of trees so here are some

221
00:10:00,360 --> 00:10:03,839
trees and each of these trees are linked

222
00:10:03,839 --> 00:10:06,660
is linked by a cycle

223
00:10:06,660 --> 00:10:09,240
so here there are two cycles

224
00:10:09,240 --> 00:10:10,200
um

225
00:10:10,200 --> 00:10:13,140
and we have some statistics on the the

226
00:10:13,140 --> 00:10:15,899
these graphs so for example we know that

227
00:10:15,899 --> 00:10:18,300
the size of the largest component is the

228
00:10:18,300 --> 00:10:19,860
average size of the largest components

229
00:10:19,860 --> 00:10:24,000
is 2 to the c times a 0.76 which means

230
00:10:24,000 --> 00:10:27,240
that 76 of the points in these graphs

231
00:10:27,240 --> 00:10:29,880
are located in the same main component

232
00:10:29,880 --> 00:10:32,060
and we also know that the average cycle

233
00:10:32,060 --> 00:10:35,399
anti-length of a random point is about 2

234
00:10:35,399 --> 00:10:37,740
to the C over two so in the square root

235
00:10:37,740 --> 00:10:41,180
of the total number of points

236
00:10:41,519 --> 00:10:43,860
um and another probably another

237
00:10:43,860 --> 00:10:45,899
statistic that is really of interest to

238
00:10:45,899 --> 00:10:47,700
us for our attack is that the

239
00:10:47,700 --> 00:10:49,740
probability that a random function has a

240
00:10:49,740 --> 00:10:52,079
component such that this component has

241
00:10:52,079 --> 00:10:55,200
an exceptionally small cycle and a

242
00:10:55,200 --> 00:10:58,100
reasonably large component

243
00:10:58,100 --> 00:11:00,779
so you don't need to remember this

244
00:11:00,779 --> 00:11:03,839
complicated formula but what's really

245
00:11:03,839 --> 00:11:05,880
important is to remember that for

246
00:11:05,880 --> 00:11:09,180
example if you want a component that

247
00:11:09,180 --> 00:11:12,240
covers 65 percent of the points and that

248
00:11:12,240 --> 00:11:14,339
has a cycle of length at most two to the

249
00:11:14,339 --> 00:11:17,100
C over 4 then this probability is a

250
00:11:17,100 --> 00:11:19,500
roughly 2 to the minus C over 4 times

251
00:11:19,500 --> 00:11:22,519
the constant

252
00:11:22,860 --> 00:11:24,000
okay

253
00:11:24,000 --> 00:11:27,660
so now looking at

254
00:11:27,660 --> 00:11:30,360
um at the the decryption again

255
00:11:30,360 --> 00:11:35,160
as I said for a announce uh the the the

256
00:11:35,160 --> 00:11:38,459
first out of state Interstate sorry x0

257
00:11:38,459 --> 00:11:40,620
can just be seen as a random point on

258
00:11:40,620 --> 00:11:42,660
the graph of f beta

259
00:11:42,660 --> 00:11:46,019
but as we apply F beta we progress on

260
00:11:46,019 --> 00:11:48,720
the graph and eventually if the

261
00:11:48,720 --> 00:11:50,760
ciphertext is long enough you reach the

262
00:11:50,760 --> 00:11:53,060
cycle

263
00:11:53,399 --> 00:11:56,880
so in particular if if you if you have a

264
00:11:56,880 --> 00:11:59,579
at your disposal a beta such that Hab

265
00:11:59,579 --> 00:12:02,160
beta has a large component with a very

266
00:12:02,160 --> 00:12:03,980
small cycle

267
00:12:03,980 --> 00:12:07,380
then because the component is large this

268
00:12:07,380 --> 00:12:09,240
point x0 will belong to that big

269
00:12:09,240 --> 00:12:11,940
component with high probability

270
00:12:11,940 --> 00:12:15,600
if again L is long large enough then you

271
00:12:15,600 --> 00:12:16,800
will reach the cycle with good

272
00:12:16,800 --> 00:12:18,360
probability

273
00:12:18,360 --> 00:12:20,640
and finally because you have chosen a

274
00:12:20,640 --> 00:12:22,440
beta search the cycle such that the

275
00:12:22,440 --> 00:12:24,079
cycle is

276
00:12:24,079 --> 00:12:27,300
exceptionally small they are at most two

277
00:12:27,300 --> 00:12:29,760
to the C over two two to the C over four

278
00:12:29,760 --> 00:12:32,519
sorry possible values for x n minus 1

279
00:12:32,519 --> 00:12:34,560
and thus at most two to the C over four

280
00:12:34,560 --> 00:12:36,360
possible tags

281
00:12:36,360 --> 00:12:39,000
and so our forgery attack simply

282
00:12:39,000 --> 00:12:41,880
consists in trying the possible values

283
00:12:41,880 --> 00:12:44,300
for t

284
00:12:46,260 --> 00:12:49,800
so we split this attack into phases

285
00:12:49,800 --> 00:12:52,320
first in a pre-computation phase we're

286
00:12:52,320 --> 00:12:54,779
going to spend some time trying to find

287
00:12:54,779 --> 00:12:57,779
a good beta that is a beta such that the

288
00:12:57,779 --> 00:13:00,000
associated function f beta has a large

289
00:13:00,000 --> 00:13:02,040
component with a small cycle

290
00:13:02,040 --> 00:13:04,680
and note that this this precomputation

291
00:13:04,680 --> 00:13:07,139
phase is key independent that is once

292
00:13:07,139 --> 00:13:09,720
you find a good beta you can use it for

293
00:13:09,720 --> 00:13:12,720
any for any key you don't need to redo

294
00:13:12,720 --> 00:13:14,399
this every time

295
00:13:14,399 --> 00:13:16,139
um and then in an online phase we're

296
00:13:16,139 --> 00:13:17,940
going to submit decryption queries to

297
00:13:17,940 --> 00:13:19,560
the oracle

298
00:13:19,560 --> 00:13:22,139
um where this deciphertext is the

299
00:13:22,139 --> 00:13:24,839
concatenation of the same block that the

300
00:13:24,839 --> 00:13:26,459
good beta we have found in the

301
00:13:26,459 --> 00:13:29,700
pre-computation phase L times where n is

302
00:13:29,700 --> 00:13:32,700
randomly sampled the associate that I

303
00:13:32,700 --> 00:13:35,220
set to the empty string L again is big

304
00:13:35,220 --> 00:13:38,880
and the tag is constructed as the

305
00:13:38,880 --> 00:13:40,920
application of the final function to a

306
00:13:40,920 --> 00:13:43,399
beta concatenated with

307
00:13:43,399 --> 00:13:47,300
an element in the cycle

308
00:13:47,700 --> 00:13:49,519
so I'm gonna make a simplified

309
00:13:49,519 --> 00:13:52,260
complexity analysis starting with the

310
00:13:52,260 --> 00:13:54,500
pre-computation phase

311
00:13:54,500 --> 00:13:59,579
so if you want to find a beta so okay so

312
00:13:59,579 --> 00:14:01,260
the first question is how many betas do

313
00:14:01,260 --> 00:14:03,720
I need to randomly draw to have a good

314
00:14:03,720 --> 00:14:06,480
chance to find the beta that is a valid

315
00:14:06,480 --> 00:14:09,899
I mean good in the sense of what we want

316
00:14:09,899 --> 00:14:12,720
um so this is given by the probability

317
00:14:12,720 --> 00:14:16,079
that I asked you to remember before and

318
00:14:16,079 --> 00:14:18,360
it's about 2 to the C over for random

319
00:14:18,360 --> 00:14:19,320
betas

320
00:14:19,320 --> 00:14:21,779
but it's a bit costly to investigate

321
00:14:21,779 --> 00:14:23,300
each beta

322
00:14:23,300 --> 00:14:26,820
and it can be estimated by the

323
00:14:26,820 --> 00:14:28,820
complexity of the Floyd's algorithm

324
00:14:28,820 --> 00:14:31,139
which you probably know to find

325
00:14:31,139 --> 00:14:33,600
collisions on hash functions and it's

326
00:14:33,600 --> 00:14:36,240
about 2 to the C over two so the total

327
00:14:36,240 --> 00:14:38,579
complexity is about 2 to the 3C over

328
00:14:38,579 --> 00:14:42,360
four applications of the permutation

329
00:14:42,360 --> 00:14:44,820
and note that this complexity is

330
00:14:44,820 --> 00:14:47,699
simplified for example in our algorithm

331
00:14:47,699 --> 00:14:50,220
we need to verify that the company the

332
00:14:50,220 --> 00:14:52,980
component is not only not only has a

333
00:14:52,980 --> 00:14:56,240
small cycle but is also large which

334
00:14:56,240 --> 00:14:58,800
actually doesn't really improve the

335
00:14:58,800 --> 00:15:01,380
complexity but

336
00:15:01,380 --> 00:15:03,660
requires a bit more analysis than this

337
00:15:03,660 --> 00:15:05,820
simplified one

338
00:15:05,820 --> 00:15:09,620
so moving on to the online phase

339
00:15:09,720 --> 00:15:11,100
so

340
00:15:11,100 --> 00:15:13,260
as I said before since we have selected

341
00:15:13,260 --> 00:15:16,800
the beta such that the main component so

342
00:15:16,800 --> 00:15:20,339
the com the F beta has a as a component

343
00:15:20,339 --> 00:15:22,980
that is large x0 will belong to this

344
00:15:22,980 --> 00:15:25,579
component with good probability

345
00:15:25,579 --> 00:15:28,860
so that's not really the what is going

346
00:15:28,860 --> 00:15:31,860
to impact the most our complexity but we

347
00:15:31,860 --> 00:15:33,600
need again the ciphertext to be really

348
00:15:33,600 --> 00:15:34,459
long

349
00:15:34,459 --> 00:15:39,899
and for the the the x l minus 1 to be in

350
00:15:39,899 --> 00:15:41,579
the cycle with good probability we need

351
00:15:41,579 --> 00:15:44,160
about 2 to the C over two and to be

352
00:15:44,160 --> 00:15:45,540
really sure and have a good probability

353
00:15:45,540 --> 00:15:47,459
of success we chose a three times two to

354
00:15:47,459 --> 00:15:48,839
the C over 2.

355
00:15:48,839 --> 00:15:51,600
and then as I said we we need to try at

356
00:15:51,600 --> 00:15:53,940
most 2 to the C over four values for the

357
00:15:53,940 --> 00:15:56,760
tag and test the total complexity is

358
00:15:56,760 --> 00:15:58,680
also about two to the three C over four

359
00:15:58,680 --> 00:16:02,180
applications of the permutation

360
00:16:02,339 --> 00:16:04,940
um so an interesting

361
00:16:04,940 --> 00:16:08,699
remark is that if you spend more time

362
00:16:08,699 --> 00:16:13,079
looking for a good beta and you look for

363
00:16:13,079 --> 00:16:16,560
a very small cycle then you can reduce

364
00:16:16,560 --> 00:16:19,440
the complexity of the online phase and

365
00:16:19,440 --> 00:16:21,300
in particular if you spend a lot of time

366
00:16:21,300 --> 00:16:23,519
and you find a cycle that has length one

367
00:16:23,519 --> 00:16:25,980
the complexity of the online phase can

368
00:16:25,980 --> 00:16:28,079
be brought very close to 2 to the C over

369
00:16:28,079 --> 00:16:30,560
2.

370
00:16:31,279 --> 00:16:35,040
so our attack is a somewhat heuristic

371
00:16:35,040 --> 00:16:37,680
based for example we wanted to

372
00:16:37,680 --> 00:16:40,320
corroborate the the fact that the F beta

373
00:16:40,320 --> 00:16:42,540
behave as random functions in practice

374
00:16:42,540 --> 00:16:45,180
so to do so we implemented some

375
00:16:45,180 --> 00:16:49,259
experiments and we used 12 as the

376
00:16:49,259 --> 00:16:50,279
permutation

377
00:16:50,279 --> 00:16:52,440
we found that all the Practical results

378
00:16:52,440 --> 00:16:56,040
we obtained matched our heuristic based

379
00:16:56,040 --> 00:16:58,500
results and we also implemented the

380
00:16:58,500 --> 00:17:00,959
pre-computation algorithm and found some

381
00:17:00,959 --> 00:17:05,819
valid beta values for C of 240.

382
00:17:05,819 --> 00:17:08,760
to summarize our results our attack has

383
00:17:08,760 --> 00:17:12,000
total time complexity smaller than 2 to

384
00:17:12,000 --> 00:17:14,880
the 3C over 4 times a constant that is

385
00:17:14,880 --> 00:17:17,459
not too big it has a good probability of

386
00:17:17,459 --> 00:17:21,119
success over 95 percent again it can be

387
00:17:21,119 --> 00:17:23,660
transformed into a key recovery at a

388
00:17:23,660 --> 00:17:27,480
negligible extra cost if the the initial

389
00:17:27,480 --> 00:17:30,720
function is a is reversible which is the

390
00:17:30,720 --> 00:17:33,419
case for most modes in practice and we

391
00:17:33,419 --> 00:17:35,100
do that using the plain text return by

392
00:17:35,100 --> 00:17:38,100
the decryption Oracle it is applicable

393
00:17:38,100 --> 00:17:40,980
to Knox V2 the military of Knox V2

394
00:17:40,980 --> 00:17:44,700
kitchen nut and kayak it doesn't break

395
00:17:44,700 --> 00:17:47,640
security claims for kitchen.org but it

396
00:17:47,640 --> 00:17:50,460
does for an ox V2 but nox was already

397
00:17:50,460 --> 00:17:52,559
broken by a non-generic attack

398
00:17:52,559 --> 00:17:55,380
so it's not that interesting uh however

399
00:17:55,380 --> 00:17:57,240
it does break a secure the security

400
00:17:57,240 --> 00:18:01,440
claim of zodiac so the security claim

401
00:18:01,440 --> 00:18:04,500
was 184 bits of security and our attack

402
00:18:04,500 --> 00:18:09,480
has complexity two to the power 148.

403
00:18:11,460 --> 00:18:13,260
the good news is that it's really easy

404
00:18:13,260 --> 00:18:14,720
to prevent the attack

405
00:18:14,720 --> 00:18:17,100
so there are two main features that

406
00:18:17,100 --> 00:18:19,679
frustrate our crypto analysis so the

407
00:18:19,679 --> 00:18:22,799
first one is a to make your final the

408
00:18:22,799 --> 00:18:25,860
final phase key dependent so that's the

409
00:18:25,860 --> 00:18:28,860
case for example in ascon or nox V3 and

410
00:18:28,860 --> 00:18:30,539
that prevents the attack because even

411
00:18:30,539 --> 00:18:32,280
though you recover the value of the

412
00:18:32,280 --> 00:18:35,220
inner states x minus L minus 1 before

413
00:18:35,220 --> 00:18:36,860
the application of the final function

414
00:18:36,860 --> 00:18:40,080
you cannot transform it into a forgery

415
00:18:40,080 --> 00:18:41,640
because it doesn't give you any

416
00:18:41,640 --> 00:18:44,160
information on the tag

417
00:18:44,160 --> 00:18:46,320
um another feature that frustrates our

418
00:18:46,320 --> 00:18:49,620
Crypt analysis is the uh is when the

419
00:18:49,620 --> 00:18:52,380
ciphertext blocks do not overwrite the

420
00:18:52,380 --> 00:18:54,480
outer States before each application of

421
00:18:54,480 --> 00:18:56,820
the permutation so that's the case in

422
00:18:56,820 --> 00:18:59,100
bitter Sparkle or subterranean

423
00:18:59,100 --> 00:19:00,960
so in bitter and Sparkle this is done

424
00:19:00,960 --> 00:19:03,480
thanks to a feedback function

425
00:19:03,480 --> 00:19:05,820
um and in that case the the decryption

426
00:19:05,820 --> 00:19:08,220
of long Cipher text that is the same

427
00:19:08,220 --> 00:19:11,160
block uh concatenated L times simply

428
00:19:11,160 --> 00:19:12,960
does not correspond to the iteration of

429
00:19:12,960 --> 00:19:15,000
a function so you cannot apply our

430
00:19:15,000 --> 00:19:16,200
attack

431
00:19:16,200 --> 00:19:18,059
so thank you very much for your

432
00:19:18,059 --> 00:19:20,460
attention and please feel free to ask

433
00:19:20,460 --> 00:19:21,990
any questions

434
00:19:21,990 --> 00:19:27,960
[Applause]

435
00:19:27,960 --> 00:19:31,700
so there is time for a quick question

436
00:19:32,820 --> 00:19:35,178
okay

437
00:19:37,340 --> 00:19:41,340
proof close the gap between the previous

438
00:19:41,340 --> 00:19:43,380
best your attack closed the gap between

439
00:19:43,380 --> 00:19:45,120
the previous best attack and the

440
00:19:45,120 --> 00:19:47,580
existing proofs do you have any sense

441
00:19:47,580 --> 00:19:53,639
where the truth lies is your tactile uh

442
00:19:55,440 --> 00:19:58,400
I don't know I think sorry

443
00:19:58,400 --> 00:20:01,220
I think

444
00:20:01,220 --> 00:20:05,880
uh most likely the proofs are gonna I

445
00:20:05,880 --> 00:20:08,480
think it's like

446
00:20:08,520 --> 00:20:12,480
probably gonna be uh the blue that joins

447
00:20:12,480 --> 00:20:14,820
the red and

448
00:20:14,820 --> 00:20:16,679
that's simply because we haven't found

449
00:20:16,679 --> 00:20:19,440
anything else but I don't have a better

450
00:20:19,440 --> 00:20:22,320
argument than that sorry yeah

451
00:20:22,320 --> 00:20:24,120
okay let's thank Rachelle again thank

452
00:20:24,120 --> 00:20:26,239
you

453
00:20:30,360 --> 00:20:32,700
second talk in this session and we're

454
00:20:32,700 --> 00:20:34,919
gonna try to make a small change in the

455
00:20:34,919 --> 00:20:38,160
setup so the speaker can see her notes

456
00:20:38,160 --> 00:20:40,860
um second talk is

457
00:20:40,860 --> 00:20:43,740
entitled context Discovery and

458
00:20:43,740 --> 00:20:45,419
commitment attacks

459
00:20:45,419 --> 00:20:48,360
how to break CCM

460
00:20:48,360 --> 00:20:51,299
eax SIV and more

461
00:20:51,299 --> 00:20:54,179
joint work between sanket Menda Julia

462
00:20:54,179 --> 00:20:56,900
Len Paul Grubbs and Thomas western part

463
00:20:56,900 --> 00:21:01,760
and Julia will give the talk

464
00:21:24,360 --> 00:21:25,919
all right thank you for the introduction

465
00:21:25,919 --> 00:21:28,200
I'm excited to present to you on context

466
00:21:28,200 --> 00:21:31,200
Discovery and commitment attacks

467
00:21:31,200 --> 00:21:33,419
so I'll begin with a quick overview of

468
00:21:33,419 --> 00:21:35,159
authenticated encryption with Associated

469
00:21:35,159 --> 00:21:38,520
data also known as aad this is one of

470
00:21:38,520 --> 00:21:40,200
the most fundamental Primitives in

471
00:21:40,200 --> 00:21:41,880
symmetric cryptography it's used

472
00:21:41,880 --> 00:21:44,580
everywhere from TLS to cloud storage to

473
00:21:44,580 --> 00:21:46,460
n10 encryption

474
00:21:46,460 --> 00:21:48,900
and it enables a sender and recipient

475
00:21:48,900 --> 00:21:51,120
with a shared context to exchange

476
00:21:51,120 --> 00:21:54,240
messages over an insecure Channel

477
00:21:54,240 --> 00:21:57,059
and so here what I mean by context is

478
00:21:57,059 --> 00:22:00,960
the encryption key K the nonce N which

479
00:22:00,960 --> 00:22:02,760
is a value used once and and so

480
00:22:02,760 --> 00:22:04,260
typically in practice this is something

481
00:22:04,260 --> 00:22:06,840
like a random IV or a counter and the

482
00:22:06,840 --> 00:22:09,240
associated data which is a data that

483
00:22:09,240 --> 00:22:11,280
needs to be authenticated but not kept

484
00:22:11,280 --> 00:22:13,320
confidential so in practice we see this

485
00:22:13,320 --> 00:22:14,940
as something like a network header for

486
00:22:14,940 --> 00:22:16,500
instance

487
00:22:16,500 --> 00:22:19,740
and so the key must be shared out of

488
00:22:19,740 --> 00:22:22,620
band but the nonsense Associated data

489
00:22:22,620 --> 00:22:24,299
can either be shared out of band or

490
00:22:24,299 --> 00:22:26,580
shared with ciphertext so this allows

491
00:22:26,580 --> 00:22:28,679
sending encrypted messages to the

492
00:22:28,679 --> 00:22:30,840
recipient with confidentiality and

493
00:22:30,840 --> 00:22:36,059
authenticity and there are plenty of uh

494
00:22:36,059 --> 00:22:38,940
Aid schemes popular AED schemes out

495
00:22:38,940 --> 00:22:41,580
there including AES GCM Cha-Cha 20 poly

496
00:22:41,580 --> 00:22:45,860
1305 and asgcm SIV

497
00:22:46,200 --> 00:22:48,059
um and these schemes are standardized

498
00:22:48,059 --> 00:22:50,159
and widely deployed if you're using

499
00:22:50,159 --> 00:22:51,840
encryption chances are you're using one

500
00:22:51,840 --> 00:22:54,299
of these schemes here on the slide and

501
00:22:54,299 --> 00:22:56,520
finally these schemes have security

502
00:22:56,520 --> 00:22:58,440
posts showing that they achieve

503
00:22:58,440 --> 00:23:00,720
confidentiality and authenticity in the

504
00:23:00,720 --> 00:23:03,000
presence of a meddler in the middle

505
00:23:03,000 --> 00:23:04,740
um like a network adversary who can

506
00:23:04,740 --> 00:23:07,559
observe and manipulate ciphertexts

507
00:23:07,559 --> 00:23:09,000
but

508
00:23:09,000 --> 00:23:12,120
in recent years we have had a surge of

509
00:23:12,120 --> 00:23:15,240
attacks on our use of aad so these

510
00:23:15,240 --> 00:23:16,919
attacks Target the most widely used

511
00:23:16,919 --> 00:23:18,900
schemes like those on the previous slide

512
00:23:18,900 --> 00:23:21,059
and it's especially concerning because

513
00:23:21,059 --> 00:23:23,280
we have built protocols assuming that

514
00:23:23,280 --> 00:23:25,799
aad is sort of a solved problem

515
00:23:25,799 --> 00:23:27,539
and what's going on under the hood here

516
00:23:27,539 --> 00:23:30,020
is that these attacks highlight

517
00:23:30,020 --> 00:23:33,000
new threat models that deviate from this

518
00:23:33,000 --> 00:23:34,860
traditional model of a meddler in the

519
00:23:34,860 --> 00:23:35,580
middle

520
00:23:35,580 --> 00:23:38,820
in particular these attacks exploit a

521
00:23:38,820 --> 00:23:42,059
lack of key commitment so what this

522
00:23:42,059 --> 00:23:44,340
means is that an adversary can find two

523
00:23:44,340 --> 00:23:46,679
keys and the cipher text such that the

524
00:23:46,679 --> 00:23:49,140
ciphertext can decrypt successfully

525
00:23:49,140 --> 00:23:52,440
under both keys and these attacks show

526
00:23:52,440 --> 00:23:54,900
that many popular aad schemes do not

527
00:23:54,900 --> 00:23:57,299
have this property

528
00:23:57,299 --> 00:24:00,000
uh later Volare and Wong later

529
00:24:00,000 --> 00:24:02,100
generalized this notion by introducing

530
00:24:02,100 --> 00:24:04,080
context commitment so this definition

531
00:24:04,080 --> 00:24:05,820
says that it's important to commit to

532
00:24:05,820 --> 00:24:08,940
the entire content uh context so the key

533
00:24:08,940 --> 00:24:10,740
the associate data announced not just

534
00:24:10,740 --> 00:24:13,140
the key and more formally this

535
00:24:13,140 --> 00:24:14,580
definition asked if it is

536
00:24:14,580 --> 00:24:16,620
computationally efficient to find two

537
00:24:16,620 --> 00:24:19,020
contexts and a ciphertext such that the

538
00:24:19,020 --> 00:24:21,000
ciphertext decrypts successfully under

539
00:24:21,000 --> 00:24:23,159
both contexts

540
00:24:23,159 --> 00:24:25,500
and I'll also add that context

541
00:24:25,500 --> 00:24:27,900
commitment is a strictly stronger

542
00:24:27,900 --> 00:24:31,260
security property than key commitment

543
00:24:31,260 --> 00:24:33,600
okay so where does that leave us in

544
00:24:33,600 --> 00:24:36,059
terms of what we know about aad schemes

545
00:24:36,059 --> 00:24:37,500
and they're committing properties before

546
00:24:37,500 --> 00:24:39,120
this paper

547
00:24:39,120 --> 00:24:42,179
well we knew that uh GCM and ocb3 were

548
00:24:42,179 --> 00:24:43,740
not key committing so they're also not

549
00:24:43,740 --> 00:24:46,919
context committing we had seen some work

550
00:24:46,919 --> 00:24:49,020
because of the key committing attacks to

551
00:24:49,020 --> 00:24:52,020
suggest some key committing aad schemes

552
00:24:52,020 --> 00:24:53,640
so this includes the padding zeros and

553
00:24:53,640 --> 00:24:55,980
key hashings scheme from albertini at

554
00:24:55,980 --> 00:24:59,280
all and the cauc1 scheme from bolar in

555
00:24:59,280 --> 00:25:01,260
Wong however for these key committing

556
00:25:01,260 --> 00:25:03,780
schemes it wasn't we didn't know yet

557
00:25:03,780 --> 00:25:05,100
whether these were also context

558
00:25:05,100 --> 00:25:07,020
committing and we also didn't know

559
00:25:07,020 --> 00:25:09,360
anything about any committing property

560
00:25:09,360 --> 00:25:12,059
of SIV CCM and eax

561
00:25:12,059 --> 00:25:15,000
and in fact after some of these attacks

562
00:25:15,000 --> 00:25:16,679
uh key committing attacks came to light

563
00:25:16,679 --> 00:25:19,320
we saw some interest online about

564
00:25:19,320 --> 00:25:22,559
whether CCM eax and SIV were committing

565
00:25:22,559 --> 00:25:25,080
in um therefore safe to use so we saw

566
00:25:25,080 --> 00:25:28,080
this as a major open problem

567
00:25:28,080 --> 00:25:30,059
so in our work we resolve these open

568
00:25:30,059 --> 00:25:32,279
questions by just demonstrating new key

569
00:25:32,279 --> 00:25:34,919
commitment attacks against SIV CCM and

570
00:25:34,919 --> 00:25:35,940
eax

571
00:25:35,940 --> 00:25:38,039
and we also show context committing

572
00:25:38,039 --> 00:25:40,020
attacks against the key committing

573
00:25:40,020 --> 00:25:42,480
schemes that have been proposed here on

574
00:25:42,480 --> 00:25:44,400
this slide

575
00:25:44,400 --> 00:25:45,900
so for the rest of this presentation

576
00:25:45,900 --> 00:25:47,779
I'll go over our four key contributions

577
00:25:47,779 --> 00:25:50,640
first we introduce a new granular

578
00:25:50,640 --> 00:25:52,500
framework for context commitment from

579
00:25:52,500 --> 00:25:54,659
the perspective of attacks we'll then

580
00:25:54,659 --> 00:25:56,460
demonstrate the usefulness of that

581
00:25:56,460 --> 00:25:57,960
framework by discussing two key

582
00:25:57,960 --> 00:26:00,059
committing or one uh key committing

583
00:26:00,059 --> 00:26:03,120
attack against the original SIV mode

584
00:26:03,120 --> 00:26:06,179
and then we'll introduce the new context

585
00:26:06,179 --> 00:26:07,799
commitment security notion which we call

586
00:26:07,799 --> 00:26:09,900
context Discovery and briefly mention

587
00:26:09,900 --> 00:26:11,340
some of our attacks using that

588
00:26:11,340 --> 00:26:12,779
definition

589
00:26:12,779 --> 00:26:16,799
so let's start with our granular uh our

590
00:26:16,799 --> 00:26:18,240
new definitional framework for context

591
00:26:18,240 --> 00:26:19,440
commitment

592
00:26:19,440 --> 00:26:21,299
so you might be thinking now doesn't

593
00:26:21,299 --> 00:26:23,760
there already exist a context committing

594
00:26:23,760 --> 00:26:25,440
security definition as well as other

595
00:26:25,440 --> 00:26:27,299
committing definitions why do we need

596
00:26:27,299 --> 00:26:29,580
even more definitions now

597
00:26:29,580 --> 00:26:31,679
um as referred to by this comic and to

598
00:26:31,679 --> 00:26:34,200
answer this yes the existing context

599
00:26:34,200 --> 00:26:36,360
committing definition by belarian Wong

600
00:26:36,360 --> 00:26:38,460
is what should be targeted when trying

601
00:26:38,460 --> 00:26:41,279
to prove security and for more on this

602
00:26:41,279 --> 00:26:43,559
uh for more on this topic I'll urge you

603
00:26:43,559 --> 00:26:45,659
to check out sunkit's talk from Real

604
00:26:45,659 --> 00:26:48,299
World crypto last month on this topic

605
00:26:48,299 --> 00:26:50,279
however we found that the definition

606
00:26:50,279 --> 00:26:51,900
doesn't really allow for a lot of

607
00:26:51,900 --> 00:26:53,400
granularity when trying to understand

608
00:26:53,400 --> 00:26:55,580
context committing attacks

609
00:26:55,580 --> 00:26:57,960
and for one thing in practice there's

610
00:26:57,960 --> 00:26:59,760
sort of these application specific

611
00:26:59,760 --> 00:27:02,340
restrictions which means that attackers

612
00:27:02,340 --> 00:27:04,559
might not have full control over the

613
00:27:04,559 --> 00:27:07,200
decryption context and we have seen

614
00:27:07,200 --> 00:27:08,940
these sort of different settings pop up

615
00:27:08,940 --> 00:27:10,260
which have translated to different

616
00:27:10,260 --> 00:27:13,380
definitions and some ambiguity in these

617
00:27:13,380 --> 00:27:14,760
definitions

618
00:27:14,760 --> 00:27:16,919
so to get a sense of some of the history

619
00:27:16,919 --> 00:27:20,940
here uh farsham at all first suggested

620
00:27:20,940 --> 00:27:22,860
one of these first key committing

621
00:27:22,860 --> 00:27:25,500
Notions called full robustness and this

622
00:27:25,500 --> 00:27:27,360
was really in the uh for randomized

623
00:27:27,360 --> 00:27:29,340
authenticated encryption but they didn't

624
00:27:29,340 --> 00:27:32,100
mention any Associated data and um it

625
00:27:32,100 --> 00:27:34,500
wasn't non-spaced

626
00:27:34,500 --> 00:27:36,720
grubs at all allowed for different

627
00:27:36,720 --> 00:27:40,140
Associated data so they made this more

628
00:27:40,140 --> 00:27:42,000
clear but it was again still for

629
00:27:42,000 --> 00:27:44,520
randomized authenticated encryption

630
00:27:44,520 --> 00:27:46,140
and then in our prior work on

631
00:27:46,140 --> 00:27:47,880
partitioning Oracle tax it was really

632
00:27:47,880 --> 00:27:49,260
important in the setting that we were

633
00:27:49,260 --> 00:27:51,120
looking at that the nonce and Associated

634
00:27:51,120 --> 00:27:53,460
data had to be the same so our

635
00:27:53,460 --> 00:27:55,260
definitions were completely different

636
00:27:55,260 --> 00:27:56,820
but uh

637
00:27:56,820 --> 00:27:57,740
uh

638
00:27:57,740 --> 00:28:01,200
mirrored this setting so all these

639
00:28:01,200 --> 00:28:03,179
definitions are slightly different but

640
00:28:03,179 --> 00:28:04,799
they really try to capture the same

641
00:28:04,799 --> 00:28:07,740
concept of key commitment which makes it

642
00:28:07,740 --> 00:28:09,659
really hard for the community to sort of

643
00:28:09,659 --> 00:28:12,059
classify tax here

644
00:28:12,059 --> 00:28:14,100
So to that end we try to fill this Gap

645
00:28:14,100 --> 00:28:16,919
and have this nice granular framework

646
00:28:16,919 --> 00:28:19,980
for security here so to explain this

647
00:28:19,980 --> 00:28:21,480
let's go back to the definition for

648
00:28:21,480 --> 00:28:23,840
context committing security

649
00:28:23,840 --> 00:28:26,820
so here we have again two contexts that

650
00:28:26,820 --> 00:28:28,799
try to decrypt a ciphertext and we'll

651
00:28:28,799 --> 00:28:31,440
try to add some more granularity here so

652
00:28:31,440 --> 00:28:34,260
first we'll parameterize our definition

653
00:28:34,260 --> 00:28:36,659
with a predicate that's evaluated over

654
00:28:36,659 --> 00:28:39,000
the context and this allows us to

655
00:28:39,000 --> 00:28:41,460
capture additional constraints over the

656
00:28:41,460 --> 00:28:44,220
context that can occur in practice and

657
00:28:44,220 --> 00:28:47,220
affect the context committing attack so

658
00:28:47,220 --> 00:28:48,659
then what are some of the predicates of

659
00:28:48,659 --> 00:28:49,799
Interest here

660
00:28:49,799 --> 00:28:51,600
well if we have as our predicate that

661
00:28:51,600 --> 00:28:53,580
the two contexts are not equal then we

662
00:28:53,580 --> 00:28:54,900
are covered the original context

663
00:28:54,900 --> 00:28:56,580
committing notion

664
00:28:56,580 --> 00:28:58,020
the next three predicates of Interest

665
00:28:58,020 --> 00:29:00,179
are those that focus on the inequality

666
00:29:00,179 --> 00:29:01,500
of the three individual context

667
00:29:01,500 --> 00:29:05,159
components so our cmtk definition simply

668
00:29:05,159 --> 00:29:07,980
checks that the um for the context

669
00:29:07,980 --> 00:29:10,559
provided the two keys are not equal but

670
00:29:10,559 --> 00:29:12,600
it doesn't have any restrictions on the

671
00:29:12,600 --> 00:29:15,059
other two components and so this really

672
00:29:15,059 --> 00:29:16,799
captures the notion of key commitment as

673
00:29:16,799 --> 00:29:19,740
defined by belarian Wong well I'll note

674
00:29:19,740 --> 00:29:22,080
that cmtn and cmta are brand new

675
00:29:22,080 --> 00:29:23,820
definitions

676
00:29:23,820 --> 00:29:25,440
and we call these definitions

677
00:29:25,440 --> 00:29:27,840
specifically permissive because we don't

678
00:29:27,840 --> 00:29:29,640
Place restrictions on the other context

679
00:29:29,640 --> 00:29:32,340
components not specified

680
00:29:32,340 --> 00:29:34,260
so then a related set of Notions are

681
00:29:34,260 --> 00:29:35,820
those that are restrictive in which it

682
00:29:35,820 --> 00:29:38,279
requires that the other unnamed context

683
00:29:38,279 --> 00:29:40,200
components must be equal so for instance

684
00:29:40,200 --> 00:29:42,440
our cmtk star definition

685
00:29:42,440 --> 00:29:44,940
requires again that the keys cannot be

686
00:29:44,940 --> 00:29:47,279
different but it additionally or it

687
00:29:47,279 --> 00:29:48,960
requires that the keys must be different

688
00:29:48,960 --> 00:29:51,419
but it additionally requires that the

689
00:29:51,419 --> 00:29:55,140
nonces and Associated data must be equal

690
00:29:55,140 --> 00:29:57,539
and so this cmtk definition therefore

691
00:29:57,539 --> 00:29:59,039
captures our notion of key commitment

692
00:29:59,039 --> 00:30:01,559
from partitioning Oracle attacks while

693
00:30:01,559 --> 00:30:05,279
cmtn star and CMT a star are new

694
00:30:05,279 --> 00:30:06,960
and overall the value in having

695
00:30:06,960 --> 00:30:08,520
predicates here is that this allows for

696
00:30:08,520 --> 00:30:10,320
a much more precise sound of definitions

697
00:30:10,320 --> 00:30:12,360
which capture requirements of various

698
00:30:12,360 --> 00:30:14,279
settings we've really seen previously in

699
00:30:14,279 --> 00:30:16,740
the literature but one drop back here is

700
00:30:16,740 --> 00:30:17,940
that it doesn't allow us to capture

701
00:30:17,940 --> 00:30:19,500
settings where a portion of this context

702
00:30:19,500 --> 00:30:21,299
is pre-selected

703
00:30:21,299 --> 00:30:23,640
so we next add to the definition what we

704
00:30:23,640 --> 00:30:25,860
call Target selection this allows us to

705
00:30:25,860 --> 00:30:27,539
specify settings where parts of the

706
00:30:27,539 --> 00:30:29,520
context are generated in specific ways

707
00:30:29,520 --> 00:30:32,460
for instance here if a setting requires

708
00:30:32,460 --> 00:30:34,020
that the keys need to be randomly

709
00:30:34,020 --> 00:30:37,260
generated this allows us to capture that

710
00:30:37,260 --> 00:30:39,360
and then finally we specify our last

711
00:30:39,360 --> 00:30:42,120
level of granularity with Target hiding

712
00:30:42,120 --> 00:30:44,580
this allows us to specify which parts of

713
00:30:44,580 --> 00:30:46,320
the context that were pre-selected are

714
00:30:46,320 --> 00:30:48,240
either given to or hidden from the

715
00:30:48,240 --> 00:30:49,380
adversary

716
00:30:49,380 --> 00:30:51,240
so here for example we can specify

717
00:30:51,240 --> 00:30:54,960
definition where one context k1n1 A1 is

718
00:30:54,960 --> 00:30:57,059
chosen for a message M1 and the

719
00:30:57,059 --> 00:30:59,520
ciphertext is computed from this but

720
00:30:59,520 --> 00:31:00,960
this context used to generate the

721
00:31:00,960 --> 00:31:02,820
ciphertext is hidden from the adversary

722
00:31:02,820 --> 00:31:05,220
and so the adversary must now find a

723
00:31:05,220 --> 00:31:07,020
separate context that decrypts the

724
00:31:07,020 --> 00:31:09,179
ciphertext

725
00:31:09,179 --> 00:31:11,220
and so I want to also quickly point out

726
00:31:11,220 --> 00:31:13,140
here that this looks a bit like a sort

727
00:31:13,140 --> 00:31:14,820
of pre-image resistance definition for

728
00:31:14,820 --> 00:31:17,100
aad where we're giving the adversary a

729
00:31:17,100 --> 00:31:19,440
ciphertext and asking them to provide a

730
00:31:19,440 --> 00:31:21,179
context that successfully decrypts it

731
00:31:21,179 --> 00:31:22,980
and we'll see in a bit that this will

732
00:31:22,980 --> 00:31:26,779
inspire a new definition related to this

733
00:31:26,880 --> 00:31:28,200
um so I know that I've just thrown a lot

734
00:31:28,200 --> 00:31:29,820
of new definitions at you right now but

735
00:31:29,820 --> 00:31:31,740
if you take anything away from this part

736
00:31:31,740 --> 00:31:34,080
it's that our definitions enable us to

737
00:31:34,080 --> 00:31:36,720
precisely Define or more precisely at

738
00:31:36,720 --> 00:31:38,279
least define various settings that might

739
00:31:38,279 --> 00:31:39,059
happen

740
00:31:39,059 --> 00:31:40,440
um in practice and so better model

741
00:31:40,440 --> 00:31:42,980
attacks

742
00:31:43,260 --> 00:31:44,700
um okay but let's get into our key

743
00:31:44,700 --> 00:31:48,240
commitment talk against the SIV mode

744
00:31:48,240 --> 00:31:50,220
so why is this so difficult like why

745
00:31:50,220 --> 00:31:53,340
don't we already have an attack for SIV

746
00:31:53,340 --> 00:31:55,260
um and and also I'll add that this is

747
00:31:55,260 --> 00:31:57,539
specifically for cmtk stars so recall

748
00:31:57,539 --> 00:31:58,919
that this means

749
00:31:58,919 --> 00:32:01,200
um that we're requiring that the two

750
00:32:01,200 --> 00:32:04,020
keys must be different but and we're

751
00:32:04,020 --> 00:32:05,279
also additionally requiring that the

752
00:32:05,279 --> 00:32:07,020
nonsense and Associated data must be the

753
00:32:07,020 --> 00:32:07,799
same

754
00:32:07,799 --> 00:32:10,620
well we had these nice attacks for these

755
00:32:10,620 --> 00:32:14,039
other aad schemes for cmtk Star

756
00:32:14,039 --> 00:32:16,380
um and so for GCM if we look at it it

757
00:32:16,380 --> 00:32:18,419
uses a highly structured polynomial Mac

758
00:32:18,419 --> 00:32:20,880
and so this made finding the CMT case

759
00:32:20,880 --> 00:32:23,340
star attack pretty easy it's just

760
00:32:23,340 --> 00:32:25,380
solving a simple system of two linear

761
00:32:25,380 --> 00:32:27,299
equations

762
00:32:27,299 --> 00:32:30,120
but SIV doesn't use a polynomial Mac so

763
00:32:30,120 --> 00:32:31,799
we can't adapt the attacks we already

764
00:32:31,799 --> 00:32:34,140
have and we really need to look for new

765
00:32:34,140 --> 00:32:36,120
techniques in order to make the attack

766
00:32:36,120 --> 00:32:38,840
work here

767
00:32:39,360 --> 00:32:43,200
okay so let's get into understanding SIV

768
00:32:43,200 --> 00:32:46,380
mode and for Simplicity we'll assume no

769
00:32:46,380 --> 00:32:48,240
Associated data here

770
00:32:48,240 --> 00:32:51,120
and we'll cover decryption

771
00:32:51,120 --> 00:32:54,179
so the key here uh is composed of two

772
00:32:54,179 --> 00:32:56,340
parts K1 and K2

773
00:32:56,340 --> 00:32:58,679
and specifically for the ciphertext it's

774
00:32:58,679 --> 00:33:01,200
also composed of the encrypted plain

775
00:33:01,200 --> 00:33:03,600
text and the IV

776
00:33:03,600 --> 00:33:07,380
so we run the uh the ciphertext through

777
00:33:07,380 --> 00:33:10,080
counter mode with key K2 to decrypt the

778
00:33:10,080 --> 00:33:12,720
ciphertext and here the initial counter

779
00:33:12,720 --> 00:33:14,940
that we use for this is the IV that's

780
00:33:14,940 --> 00:33:16,980
included as part of ciphertext and then

781
00:33:16,980 --> 00:33:19,860
we recover the message there

782
00:33:19,860 --> 00:33:22,799
next we recompute the synthetic IV from

783
00:33:22,799 --> 00:33:25,380
the message using s2vc Mac with the key

784
00:33:25,380 --> 00:33:27,860
K1

785
00:33:28,260 --> 00:33:30,299
and then we compare this computed

786
00:33:30,299 --> 00:33:32,820
synthetic IV with that stored as part of

787
00:33:32,820 --> 00:33:35,640
the ciphertext and so this part is

788
00:33:35,640 --> 00:33:37,200
really important for our attack this is

789
00:33:37,200 --> 00:33:38,640
where decryption is either going to

790
00:33:38,640 --> 00:33:41,940
succeed or fail because if the synthetic

791
00:33:41,940 --> 00:33:44,640
IV that we compute does not match the IV

792
00:33:44,640 --> 00:33:47,820
that's a part of the cipher part of the

793
00:33:47,820 --> 00:33:50,220
ciphertext then decryption will fail

794
00:33:50,220 --> 00:33:53,039
otherwise decryption will succeed and

795
00:33:53,039 --> 00:33:54,600
that'll make our attack work which is

796
00:33:54,600 --> 00:33:56,840
nice

797
00:33:57,360 --> 00:34:00,299
so for our attack for Simplicity we'll

798
00:34:00,299 --> 00:34:02,340
consider one block Cipher text with no

799
00:34:02,340 --> 00:34:04,200
Associated data or announced and our

800
00:34:04,200 --> 00:34:06,960
goal here is to find uh two keys and a

801
00:34:06,960 --> 00:34:09,839
ciphertext so that decryption of the

802
00:34:09,839 --> 00:34:13,320
ciphertext under both keys succeeds

803
00:34:13,320 --> 00:34:14,940
so this means that the computed

804
00:34:14,940 --> 00:34:18,540
synthetic IVs match the stored IV that's

805
00:34:18,540 --> 00:34:21,239
part of the ciphertext

806
00:34:21,239 --> 00:34:23,820
and so when we try to make this work we

807
00:34:23,820 --> 00:34:26,879
get this equation here where we have we

808
00:34:26,879 --> 00:34:31,739
set up so that the IV is equal to the

809
00:34:31,739 --> 00:34:34,159
computation of

810
00:34:34,159 --> 00:34:39,480
the the IV over the decrypted plate

811
00:34:39,480 --> 00:34:42,359
ciphertext for the for one of the keys

812
00:34:42,359 --> 00:34:46,679
K1 K2 and also for the other key K1 K1

813
00:34:46,679 --> 00:34:48,359
Prime K2 Prime

814
00:34:48,359 --> 00:34:50,580
and so we get this equation here and we

815
00:34:50,580 --> 00:34:53,639
need to find K1 K2 K1 Prime and K2 Prime

816
00:34:53,639 --> 00:34:57,060
such that it makes this equation work

817
00:34:57,060 --> 00:34:59,700
and so we can sort of simplify and

818
00:34:59,700 --> 00:35:03,060
rearrange terms and we get

819
00:35:03,060 --> 00:35:04,020
um

820
00:35:04,020 --> 00:35:05,940
this equation here so again our goal is

821
00:35:05,940 --> 00:35:08,280
to find these two keys and a ciphertext

822
00:35:08,280 --> 00:35:12,900
such that we make this equation uh such

823
00:35:12,900 --> 00:35:15,119
that we fulfill this equation

824
00:35:15,119 --> 00:35:17,099
but you'll notice that what we have here

825
00:35:17,099 --> 00:35:19,560
is something that looks like

826
00:35:19,560 --> 00:35:21,060
um four terms

827
00:35:21,060 --> 00:35:23,400
and when we xor them together we want it

828
00:35:23,400 --> 00:35:25,619
so that such that they equal zero to the

829
00:35:25,619 --> 00:35:27,119
n

830
00:35:27,119 --> 00:35:29,040
and so when we looked at this we found

831
00:35:29,040 --> 00:35:30,780
that if we modeled the block Cipher as

832
00:35:30,780 --> 00:35:32,760
an ideal Cipher then this looks very

833
00:35:32,760 --> 00:35:34,440
close to the generalized birthday

834
00:35:34,440 --> 00:35:35,760
problem

835
00:35:35,760 --> 00:35:39,720
so just as a reminder of this problem

836
00:35:39,720 --> 00:35:41,520
for specifically for the four list

837
00:35:41,520 --> 00:35:44,940
problem it says that given lists L1 L2

838
00:35:44,940 --> 00:35:47,579
L3 and L4 of elements drawn uniformly

839
00:35:47,579 --> 00:35:49,920
independently at random from zero one to

840
00:35:49,920 --> 00:35:50,820
n

841
00:35:50,820 --> 00:35:53,940
then it asks can we find an element from

842
00:35:53,940 --> 00:35:56,040
each list such that when we x-ray them

843
00:35:56,040 --> 00:35:59,099
together the result is zero to the n and

844
00:35:59,099 --> 00:36:01,560
of course Wagner gave the K tree

845
00:36:01,560 --> 00:36:03,780
algorithm to solve this in Big O of 2N

846
00:36:03,780 --> 00:36:06,480
over 3 space and time

847
00:36:06,480 --> 00:36:09,900
and so we can think about for each of

848
00:36:09,900 --> 00:36:13,140
these terms that I have colored here uh

849
00:36:13,140 --> 00:36:15,480
we can sort of map that to a function

850
00:36:15,480 --> 00:36:17,820
and we can think about modeling it as a

851
00:36:17,820 --> 00:36:19,500
pseudorandom function evaluated over

852
00:36:19,500 --> 00:36:22,760
each key and then it becomes our attack

853
00:36:22,760 --> 00:36:26,160
such that we need to find K1 K2 K1 Prime

854
00:36:26,160 --> 00:36:28,680
and K2 Prime and form our list and apply

855
00:36:28,680 --> 00:36:31,680
this algorithm but the problem here is

856
00:36:31,680 --> 00:36:33,900
that this isn't quite a pseudorandom

857
00:36:33,900 --> 00:36:36,420
function these values are not drawn

858
00:36:36,420 --> 00:36:38,280
uniformly and independently at random

859
00:36:38,280 --> 00:36:40,920
and this is because our block Cipher for

860
00:36:40,920 --> 00:36:43,200
multiple evaluations of the same key

861
00:36:43,200 --> 00:36:45,900
acts as a permutation

862
00:36:45,900 --> 00:36:47,339
so

863
00:36:47,339 --> 00:36:49,020
um but we still can make it work because

864
00:36:49,020 --> 00:36:50,940
we show that we can upper bound the

865
00:36:50,940 --> 00:36:52,619
distinguishability between the

866
00:36:52,619 --> 00:36:54,480
distribution formed by the values chosen

867
00:36:54,480 --> 00:36:56,700
to make the list and a uniformly random

868
00:36:56,700 --> 00:36:59,099
distribution so then we show that we can

869
00:36:59,099 --> 00:37:01,140
apply Wagner's K3 algorithm with the

870
00:37:01,140 --> 00:37:03,119
distributions we have and still have

871
00:37:03,119 --> 00:37:05,460
high probability of finding collisions

872
00:37:05,460 --> 00:37:07,680
so we show that with high probability we

873
00:37:07,680 --> 00:37:09,900
can find a collision in time about 2-53

874
00:37:09,900 --> 00:37:12,480
making it practical and sufficiently

875
00:37:12,480 --> 00:37:15,660
damaging to Raw SIV as a suitable for

876
00:37:15,660 --> 00:37:18,780
context where key commitment matters

877
00:37:18,780 --> 00:37:21,540
okay so now that we've covered this sib

878
00:37:21,540 --> 00:37:23,579
attack I'll briefly cover our context

879
00:37:23,579 --> 00:37:26,099
Discovery notion

880
00:37:26,099 --> 00:37:28,560
um so remember I had this slide earlier

881
00:37:28,560 --> 00:37:30,960
where we had this context committing

882
00:37:30,960 --> 00:37:32,820
definition and I said this sort of looks

883
00:37:32,820 --> 00:37:36,000
like a pre-image resistance definition

884
00:37:36,000 --> 00:37:36,900
um

885
00:37:36,900 --> 00:37:39,180
well we actually found that this would

886
00:37:39,180 --> 00:37:41,460
be useful as a separate definition and

887
00:37:41,460 --> 00:37:43,500
so we call this context discoverability

888
00:37:43,500 --> 00:37:45,960
security and so

889
00:37:45,960 --> 00:37:47,760
um this simplifies our definition so

890
00:37:47,760 --> 00:37:50,820
that for an aad scheme given some Cipher

891
00:37:50,820 --> 00:37:52,800
text the goal of the adversary is to

892
00:37:52,800 --> 00:37:55,440
find a context such that decryption

893
00:37:55,440 --> 00:37:58,619
under that context succeeds

894
00:37:58,619 --> 00:38:00,780
and so context discoverability security

895
00:38:00,780 --> 00:38:03,300
you can think of this is two context

896
00:38:03,300 --> 00:38:06,240
committing security for aad as pre-image

897
00:38:06,240 --> 00:38:07,859
resistance is to Collision resistance

898
00:38:07,859 --> 00:38:10,440
for hash functions and we also show that

899
00:38:10,440 --> 00:38:12,599
if an aad scheme is context compressing

900
00:38:12,599 --> 00:38:14,579
meaning ciphertexts are decryptable

901
00:38:14,579 --> 00:38:16,859
under more than one context then context

902
00:38:16,859 --> 00:38:18,839
committing security implies context

903
00:38:18,839 --> 00:38:21,000
discoverability security and so we

904
00:38:21,000 --> 00:38:22,920
showed context discoverability attacks

905
00:38:22,920 --> 00:38:26,579
for CCM eex SIV GCM and ocb3 which then

906
00:38:26,579 --> 00:38:29,160
translated also to context committing

907
00:38:29,160 --> 00:38:31,680
attacks and so the benefit of this

908
00:38:31,680 --> 00:38:33,180
definition is that it allows us to

909
00:38:33,180 --> 00:38:34,740
better communicate attacks and threat

910
00:38:34,740 --> 00:38:36,300
models and it's a bit of a simpler

911
00:38:36,300 --> 00:38:38,339
definition to understand than context

912
00:38:38,339 --> 00:38:40,980
committing security but it still gives

913
00:38:40,980 --> 00:38:43,320
us context committing attacks if you

914
00:38:43,320 --> 00:38:45,839
find a context discoverability attack

915
00:38:45,839 --> 00:38:49,079
all right so I'll quickly conclude here

916
00:38:49,079 --> 00:38:51,240
um by bringing up again some of the

917
00:38:51,240 --> 00:38:52,680
highlights of our work

918
00:38:52,680 --> 00:38:55,619
um and our new results in in finding

919
00:38:55,619 --> 00:38:58,980
context commitment attacks and so

920
00:38:58,980 --> 00:39:00,720
um really this is to say that as we move

921
00:39:00,720 --> 00:39:03,300
forward in developing new aad schemes we

922
00:39:03,300 --> 00:39:04,920
should really think about developing

923
00:39:04,920 --> 00:39:07,200
schemes that are also context committing

924
00:39:07,200 --> 00:39:09,240
because many of the schemes that we're

925
00:39:09,240 --> 00:39:10,740
putting forward that we've like already

926
00:39:10,740 --> 00:39:12,780
had and widely used or that we're

927
00:39:12,780 --> 00:39:15,599
putting forward for key committing

928
00:39:15,599 --> 00:39:17,940
um purposes are not context committing

929
00:39:17,940 --> 00:39:19,980
and so for more information you can

930
00:39:19,980 --> 00:39:21,300
check out the full version of our paper

931
00:39:21,300 --> 00:39:23,940
on ePrint which I have on the slide here

932
00:39:23,940 --> 00:39:25,500
so thank you and I'm happy to take any

933
00:39:25,500 --> 00:39:26,579
questions

934
00:39:26,579 --> 00:39:27,380
thank you

935
00:39:27,380 --> 00:39:31,859
[Applause]

936
00:39:31,859 --> 00:39:35,480
it's time for a quick question

937
00:39:36,780 --> 00:39:38,579
so I have a question so you have now all

938
00:39:38,579 --> 00:39:40,920
these definitions is there now any

939
00:39:40,920 --> 00:39:42,960
guidance to which ones matter in

940
00:39:42,960 --> 00:39:44,460
specific applications or which is kind

941
00:39:44,460 --> 00:39:46,140
of a topic of research or do you have a

942
00:39:46,140 --> 00:39:49,440
view on which ones are more important or

943
00:39:49,440 --> 00:39:51,900
I think so the ones that we were seeing

944
00:39:51,900 --> 00:39:54,780
pop up a lot were the predicate based

945
00:39:54,780 --> 00:39:57,000
ones that I had on the slide so like the

946
00:39:57,000 --> 00:39:59,400
one we see often is like cmtk or cmtk

947
00:39:59,400 --> 00:40:00,960
star

948
00:40:00,960 --> 00:40:03,900
um so we see that quite often

949
00:40:03,900 --> 00:40:06,359
I think though one benefit is that maybe

950
00:40:06,359 --> 00:40:07,920
in the future there's going to be some

951
00:40:07,920 --> 00:40:10,380
kind of setting and practice that we see

952
00:40:10,380 --> 00:40:11,880
such that

953
00:40:11,880 --> 00:40:13,260
um we don't really have an existing

954
00:40:13,260 --> 00:40:15,060
definition so rather than trying to

955
00:40:15,060 --> 00:40:17,099
scramble to find some new definition we

956
00:40:17,099 --> 00:40:19,500
can use this framework to sort of

957
00:40:19,500 --> 00:40:21,599
um model this setting and and show a

958
00:40:21,599 --> 00:40:24,240
text for that

959
00:40:24,240 --> 00:40:27,119
okay so let's thank Julia but also

960
00:40:27,119 --> 00:40:29,400
Rachel the speaker of this session thank

961
00:40:29,400 --> 00:40:31,420
you

962
00:40:31,420 --> 00:40:32,579
[Music]

963
00:40:32,579 --> 00:40:37,160
and we start again in nine minutes

