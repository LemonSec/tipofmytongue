1
00:00:03,540 --> 00:00:08,400
okay so welcome everyone to the session

2
00:00:08,400 --> 00:00:10,260
after the coffee break

3
00:00:10,260 --> 00:00:13,980
about npcn proofs so the first talk will

4
00:00:13,980 --> 00:00:15,660
be a complete characterization of

5
00:00:15,660 --> 00:00:17,400
broadcast and save the signatures from

6
00:00:17,400 --> 00:00:18,480
correlation

7
00:00:18,480 --> 00:00:22,199
and the tag will be given by Barun and

8
00:00:22,199 --> 00:00:28,460
it's join work with Pinot Brava Karan um

9
00:00:30,359 --> 00:00:32,960
so

10
00:00:33,180 --> 00:00:35,640
thank you Carla hi everyone thank you

11
00:00:35,640 --> 00:00:37,260
for joining this talk

12
00:00:37,260 --> 00:00:42,180
so in this work we characterized the set

13
00:00:42,180 --> 00:00:43,620
of all

14
00:00:43,620 --> 00:00:45,840
three wise correlated sources that can

15
00:00:45,840 --> 00:00:48,059
be used to realize three-party Byzantine

16
00:00:48,059 --> 00:00:50,419
broadcast

17
00:00:51,379 --> 00:00:54,899
we will also see the implications of

18
00:00:54,899 --> 00:00:57,180
this result to in party broadcast and

19
00:00:57,180 --> 00:00:58,860
MPC

20
00:00:58,860 --> 00:01:01,199
and also its implication to a closely

21
00:01:01,199 --> 00:01:04,739
related notion called uh pseudo

22
00:01:04,739 --> 00:01:06,540
signatures

23
00:01:06,540 --> 00:01:08,520
so let me Begin by describing the

24
00:01:08,520 --> 00:01:10,799
Byzantine broadcast problem there are n

25
00:01:10,799 --> 00:01:13,080
parties of which one priority that we

26
00:01:13,080 --> 00:01:14,939
call the sender has a single with

27
00:01:14,939 --> 00:01:17,100
message M that it wants to send to the

28
00:01:17,100 --> 00:01:19,979
rest of the parties

29
00:01:19,979 --> 00:01:22,939
the parties are connected by a

30
00:01:22,939 --> 00:01:24,720
communication Network that is

31
00:01:24,720 --> 00:01:25,920
synchronous

32
00:01:25,920 --> 00:01:28,080
and the

33
00:01:28,080 --> 00:01:30,780
the the question is whether we can build

34
00:01:30,780 --> 00:01:35,520
a protocol that securely uh that

35
00:01:35,520 --> 00:01:37,020
securely guarantees the following

36
00:01:37,020 --> 00:01:39,840
properties against an adversary that is

37
00:01:39,840 --> 00:01:41,400
maliciously correcting a subset of

38
00:01:41,400 --> 00:01:42,900
parties

39
00:01:42,900 --> 00:01:45,479
so the first condition is that if the

40
00:01:45,479 --> 00:01:47,640
sender is honest then we want all the

41
00:01:47,640 --> 00:01:51,240
honest uh parties to Output M at the end

42
00:01:51,240 --> 00:01:53,700
of this protocol where m is the input of

43
00:01:53,700 --> 00:01:55,619
the sender

44
00:01:55,619 --> 00:01:58,020
and if the sender is malicious then we

45
00:01:58,020 --> 00:01:59,759
want all the honest priorities to agree

46
00:01:59,759 --> 00:02:02,220
on the same output say m hat

47
00:02:02,220 --> 00:02:04,140
at the end of this protocol but we don't

48
00:02:04,140 --> 00:02:06,479
insist on what the value of this m hat

49
00:02:06,479 --> 00:02:07,799
is

50
00:02:07,799 --> 00:02:10,258
so this is a fundamental problem in

51
00:02:10,258 --> 00:02:13,200
distributed computation and it has

52
00:02:13,200 --> 00:02:14,879
application to secure multi-party

53
00:02:14,879 --> 00:02:17,340
computation blockchains fault order and

54
00:02:17,340 --> 00:02:20,340
distributed storage and so on

55
00:02:20,340 --> 00:02:23,099
so a classic result in distributed

56
00:02:23,099 --> 00:02:25,800
computation says that Byzantine

57
00:02:25,800 --> 00:02:29,160
broadcast is possible among n parties if

58
00:02:29,160 --> 00:02:30,420
and only if

59
00:02:30,420 --> 00:02:32,400
strictly more than two-thirds of those

60
00:02:32,400 --> 00:02:34,080
parties are honest

61
00:02:34,080 --> 00:02:37,080
so specifically amongst these parties

62
00:02:37,080 --> 00:02:40,260
broadcast is impossible even when one of

63
00:02:40,260 --> 00:02:42,720
the parties can be malicious

64
00:02:42,720 --> 00:02:46,080
in this talk we will be looking at using

65
00:02:46,080 --> 00:02:48,120
some setup to get around this

66
00:02:48,120 --> 00:02:50,640
impossibility

67
00:02:50,640 --> 00:02:53,780
so there is a long history of using

68
00:02:53,780 --> 00:02:57,120
setups like stochastic resources to get

69
00:02:57,120 --> 00:02:59,760
cryptographic Primitives

70
00:02:59,760 --> 00:03:01,580
so uh

71
00:03:01,580 --> 00:03:04,620
resources like noisy channels and

72
00:03:04,620 --> 00:03:08,959
correlated sources can be used to build

73
00:03:08,959 --> 00:03:12,239
protocols with unconditional security

74
00:03:12,239 --> 00:03:15,360
some notable examples of this are uh

75
00:03:15,360 --> 00:03:17,040
secret key agreement and privacy

76
00:03:17,040 --> 00:03:19,739
amplification using noisy channels and

77
00:03:19,739 --> 00:03:22,080
correlated sources

78
00:03:22,080 --> 00:03:24,720
use of oblivious transfer correlation to

79
00:03:24,720 --> 00:03:26,580
realize MPC

80
00:03:26,580 --> 00:03:29,040
use of noisy channels to realize bit

81
00:03:29,040 --> 00:03:30,840
commitment and so on

82
00:03:30,840 --> 00:03:33,300
indeed in order to realize three party

83
00:03:33,300 --> 00:03:36,420
broadcast previous Works have used

84
00:03:36,420 --> 00:03:39,599
stochastic resources a work from 2022

85
00:03:39,599 --> 00:03:41,580
used uh

86
00:03:41,580 --> 00:03:43,980
a noisy single input multiple output

87
00:03:43,980 --> 00:03:46,739
channel to realize broadcast

88
00:03:46,739 --> 00:03:48,780
and uh

89
00:03:48,780 --> 00:03:52,440
Fitzy wolf and wolfslegger in 2004

90
00:03:52,440 --> 00:03:55,560
had a result that looked at using

91
00:03:55,560 --> 00:03:57,599
correlated sources in order to realize

92
00:03:57,599 --> 00:03:59,459
realize broadcast

93
00:03:59,459 --> 00:04:02,099
and the topic of this talk is exactly

94
00:04:02,099 --> 00:04:05,640
this that of using correlated sources to

95
00:04:05,640 --> 00:04:07,680
get broadcast

96
00:04:07,680 --> 00:04:09,959
so three party broadcast has

97
00:04:09,959 --> 00:04:12,420
implications to n-party broadcast and

98
00:04:12,420 --> 00:04:14,400
end party MPC

99
00:04:14,400 --> 00:04:17,100
the result by a physion model from 2000

100
00:04:17,100 --> 00:04:19,620
states that if every subset of three

101
00:04:19,620 --> 00:04:21,959
parties among the end parties can do

102
00:04:21,959 --> 00:04:25,259
broadcast then we can indeed get in

103
00:04:25,259 --> 00:04:28,979
party broadcast with honest majority

104
00:04:28,979 --> 00:04:30,259
now

105
00:04:30,259 --> 00:04:32,940
there are Classic results that say that

106
00:04:32,940 --> 00:04:35,699
if we have broadcast then we can get

107
00:04:35,699 --> 00:04:39,000
General MPC with honest majority so one

108
00:04:39,000 --> 00:04:41,400
of the consequences of our results is

109
00:04:41,400 --> 00:04:44,900
that we get a sufficient condition for

110
00:04:44,900 --> 00:04:48,080
MPC with honest majority

111
00:04:48,080 --> 00:04:51,419
in terms of the kind of correlations

112
00:04:51,419 --> 00:04:55,940
that we can use for realizing this

113
00:04:56,220 --> 00:04:58,860
so interestingly you would need three

114
00:04:58,860 --> 00:05:01,080
voice correlations to get this kind of a

115
00:05:01,080 --> 00:05:03,120
result and we will be looking at three

116
00:05:03,120 --> 00:05:04,919
wise correlations

117
00:05:04,919 --> 00:05:07,620
so let's look at the uh

118
00:05:07,620 --> 00:05:09,840
problem statement we want Byzantine

119
00:05:09,840 --> 00:05:12,360
broadcast using correlated sources

120
00:05:12,360 --> 00:05:14,340
so let's call the three parties a b and

121
00:05:14,340 --> 00:05:16,860
c and a is the sender and they are

122
00:05:16,860 --> 00:05:19,100
connected by a communication Network

123
00:05:19,100 --> 00:05:22,320
additionally a gets random variables X1

124
00:05:22,320 --> 00:05:25,860
to X N B gets y1 to y n and C gets Z1 to

125
00:05:25,860 --> 00:05:29,100
Z in such that each triple x i y i z i

126
00:05:29,100 --> 00:05:30,900
is identically and independently

127
00:05:30,900 --> 00:05:32,880
distributed according to a fixed

128
00:05:32,880 --> 00:05:35,759
correlation p x y z

129
00:05:35,759 --> 00:05:39,180
now our problem is which correlations p

130
00:05:39,180 --> 00:05:43,820
x y z given sufficiently many copies of

131
00:05:43,820 --> 00:05:46,680
exceptionally many samples from it can

132
00:05:46,680 --> 00:05:48,240
be used to build a protocol that

133
00:05:48,240 --> 00:05:51,180
realizes three-party broadcast

134
00:05:51,180 --> 00:05:54,120
so like I was mentioning earlier this

135
00:05:54,120 --> 00:05:55,860
problem was previously looked at by

136
00:05:55,860 --> 00:05:57,240
fitzyata

137
00:05:57,240 --> 00:06:02,479
in their 2004 work they presented a

138
00:06:02,479 --> 00:06:05,100
characterization of the correlations

139
00:06:05,100 --> 00:06:06,419
that would

140
00:06:06,419 --> 00:06:09,960
allow you to get broadcast this

141
00:06:09,960 --> 00:06:12,180
characterization was in terms of a

142
00:06:12,180 --> 00:06:14,400
notion called simulatability that is

143
00:06:14,400 --> 00:06:18,000
given uh in in this slide we will look

144
00:06:18,000 --> 00:06:19,919
at what these conditions mean at a later

145
00:06:19,919 --> 00:06:21,060
time

146
00:06:21,060 --> 00:06:23,280
so what they did is they presented a

147
00:06:23,280 --> 00:06:25,259
protocol that is a non-interactive

148
00:06:25,259 --> 00:06:27,780
protocol that realizes broadcast

149
00:06:27,780 --> 00:06:30,720
whenever one of these two simulatability

150
00:06:30,720 --> 00:06:32,819
conditions is broken

151
00:06:32,819 --> 00:06:35,940
and further they claim that if both the

152
00:06:35,940 --> 00:06:37,560
simulatibility conditions are satisfied

153
00:06:37,560 --> 00:06:39,479
for a correlation then you cannot use it

154
00:06:39,479 --> 00:06:41,880
to realize uh broadcast

155
00:06:41,880 --> 00:06:44,699
however it turns out that the

156
00:06:44,699 --> 00:06:47,340
impossibility proof was incorrect and

157
00:06:47,340 --> 00:06:49,620
indeed there are simple to describe

158
00:06:49,620 --> 00:06:52,380
correlations that can be used to that

159
00:06:52,380 --> 00:06:53,699
satisfies both the simulatability

160
00:06:53,699 --> 00:06:55,800
conditions but can still be used to

161
00:06:55,800 --> 00:06:58,080
realize broadcast the trick is to use

162
00:06:58,080 --> 00:06:59,759
interaction

163
00:06:59,759 --> 00:07:03,000
so in our work we give the correct

164
00:07:03,000 --> 00:07:05,819
characterization for broadcast using

165
00:07:05,819 --> 00:07:09,900
correlated sources and this is in terms

166
00:07:09,900 --> 00:07:12,419
of this notion called simulatability

167
00:07:12,419 --> 00:07:13,800
with interaction as you can see

168
00:07:13,800 --> 00:07:16,500
interaction plays a significant role

169
00:07:16,500 --> 00:07:18,360
here

170
00:07:18,360 --> 00:07:20,580
um and we show a matching impossibility

171
00:07:20,580 --> 00:07:22,500
uh showing that there's a necessary and

172
00:07:22,500 --> 00:07:24,720
sufficient condition

173
00:07:24,720 --> 00:07:30,120
so uh let me Begin by uh looking at the

174
00:07:30,120 --> 00:07:33,780
protocol from Fitzy itself paper as this

175
00:07:33,780 --> 00:07:35,280
would be the starting point for our

176
00:07:35,280 --> 00:07:36,660
construction too

177
00:07:36,660 --> 00:07:38,340
they build the protocol for broadcast

178
00:07:38,340 --> 00:07:42,060
using uh the notion of pseudo signatures

179
00:07:42,060 --> 00:07:44,580
let's first see what a pseudo signature

180
00:07:44,580 --> 00:07:47,639
is a pseudo signature in the direction A

181
00:07:47,639 --> 00:07:48,960
to B to C

182
00:07:48,960 --> 00:07:52,620
is a way for a to send a signed message

183
00:07:52,620 --> 00:07:55,860
to b which then B can reliably transfer

184
00:07:55,860 --> 00:07:59,300
to C so we need all the natural uh

185
00:07:59,300 --> 00:08:02,400
signature like properties first of all

186
00:08:02,400 --> 00:08:06,419
if B is honest then it would accept a

187
00:08:06,419 --> 00:08:10,199
valid signature from a and if B was

188
00:08:10,199 --> 00:08:12,419
provided a valid signature that it has

189
00:08:12,419 --> 00:08:14,699
accepted then B can be confident that

190
00:08:14,699 --> 00:08:17,220
when it forwards this signature to c c

191
00:08:17,220 --> 00:08:19,979
will accept it as long as he is honest

192
00:08:19,979 --> 00:08:23,879
and finally when C receives a signed

193
00:08:23,879 --> 00:08:26,160
message and it checks out in the

194
00:08:26,160 --> 00:08:28,020
verification then C can be confident

195
00:08:28,020 --> 00:08:31,979
that it is a message signed by a uh

196
00:08:31,979 --> 00:08:34,679
specifically it has not been forged by B

197
00:08:34,679 --> 00:08:37,740
so these are natural Notions that we

198
00:08:37,740 --> 00:08:40,500
would need for a signature and

199
00:08:40,500 --> 00:08:44,039
here is a intuitive way to build uh CO2

200
00:08:44,039 --> 00:08:46,500
signatures using correlations so note

201
00:08:46,500 --> 00:08:48,600
that x y n said they are connected

202
00:08:48,600 --> 00:08:51,480
because they are correlated so

203
00:08:51,480 --> 00:08:55,260
the the signature that the sender uses

204
00:08:55,260 --> 00:08:56,760
will be a function of both the message

205
00:08:56,760 --> 00:08:58,860
and the their part of the correlation

206
00:08:58,860 --> 00:09:03,899
that is x n so now B can verify the

207
00:09:03,899 --> 00:09:06,060
signature by checking whether this is

208
00:09:06,060 --> 00:09:08,640
consistent with their share that is y n

209
00:09:08,640 --> 00:09:11,880
similarly C can verify when B forwards

210
00:09:11,880 --> 00:09:14,580
it to them whether it is consistent with

211
00:09:14,580 --> 00:09:17,700
Saturn and it turns out this is how the

212
00:09:17,700 --> 00:09:21,660
signature is built in the 2004 paper

213
00:09:21,660 --> 00:09:24,899
now given uh zero signature with these

214
00:09:24,899 --> 00:09:26,940
properties it's

215
00:09:26,940 --> 00:09:30,120
rather easy to build a broadcast

216
00:09:30,120 --> 00:09:33,360
protocol so how does it work a sends the

217
00:09:33,360 --> 00:09:35,760
message along with the signature to be

218
00:09:35,760 --> 00:09:39,779
if the signature checks out B outputs m

219
00:09:39,779 --> 00:09:42,720
and forwards this message signature pair

220
00:09:42,720 --> 00:09:44,519
to C

221
00:09:44,519 --> 00:09:48,060
if the signature checks out at C then C

222
00:09:48,060 --> 00:09:49,560
can be confident that this is the

223
00:09:49,560 --> 00:09:51,720
message sent by a this follows from the

224
00:09:51,720 --> 00:09:55,260
unforgeability property so C outputs m

225
00:09:55,260 --> 00:09:59,399
if the signature was found to be false

226
00:09:59,399 --> 00:10:01,860
then C can be confident that this is a

227
00:10:01,860 --> 00:10:04,980
forgery from a field forgery from B

228
00:10:04,980 --> 00:10:08,580
so in this case C can go ahead and ask

229
00:10:08,580 --> 00:10:10,860
Alice for the message and simply output

230
00:10:10,860 --> 00:10:12,480
whatever Alice sends

231
00:10:12,480 --> 00:10:14,640
finally if the verification had failed

232
00:10:14,640 --> 00:10:19,500
at B itself then B can go ahead and be

233
00:10:19,500 --> 00:10:22,800
sure that a has been malicious so choose

234
00:10:22,800 --> 00:10:26,040
C to be a trusted party so c as a for

235
00:10:26,040 --> 00:10:28,920
the message and forwards it to B and

236
00:10:28,920 --> 00:10:31,920
there's a typo here so B outputs what uh

237
00:10:31,920 --> 00:10:34,380
C forwarded

238
00:10:34,380 --> 00:10:37,740
so now the question is when can you what

239
00:10:37,740 --> 00:10:39,480
kind of correlations can you use to

240
00:10:39,480 --> 00:10:41,399
realize pseudo signature

241
00:10:41,399 --> 00:10:44,519
so as we saw we want the simulatability

242
00:10:44,519 --> 00:10:47,279
condition to not hold so what is

243
00:10:47,279 --> 00:10:49,019
non-simulatability it's this condition

244
00:10:49,019 --> 00:10:52,140
over here it says some quantity X down

245
00:10:52,140 --> 00:10:54,779
arrow y should be should not be

246
00:10:54,779 --> 00:10:58,680
independent of Z condition on y

247
00:10:58,680 --> 00:11:01,800
so what is X down arrow y

248
00:11:01,800 --> 00:11:04,500
so it turns this seems this turns out to

249
00:11:04,500 --> 00:11:06,540
be a quantity that has been studied

250
00:11:06,540 --> 00:11:08,220
earlier and it's called the minimal

251
00:11:08,220 --> 00:11:11,940
sufficient statistic of Y given X

252
00:11:11,940 --> 00:11:14,579
so intuitively this is the largest part

253
00:11:14,579 --> 00:11:16,680
of X that can be statistically verified

254
00:11:16,680 --> 00:11:18,420
using Y

255
00:11:18,420 --> 00:11:21,779
so what does this mean so given several

256
00:11:21,779 --> 00:11:25,920
copies y one up to y n That B has we can

257
00:11:25,920 --> 00:11:28,800
detect if a incorrectly reports many

258
00:11:28,800 --> 00:11:30,000
values

259
00:11:30,000 --> 00:11:33,660
among X down arrow X1 down arrow y one

260
00:11:33,660 --> 00:11:37,680
up to X and down arrow y one y n

261
00:11:37,680 --> 00:11:41,279
so in a sense this is the largest part

262
00:11:41,279 --> 00:11:45,000
of X that y can verify

263
00:11:45,000 --> 00:11:47,820
when X when somebody might be lying

264
00:11:47,820 --> 00:11:48,899
about X

265
00:11:48,899 --> 00:11:51,120
so it turns out to be a rather

266
00:11:51,120 --> 00:11:52,560
straightforward function and it's

267
00:11:52,560 --> 00:11:55,440
intuitive why this works out so let's

268
00:11:55,440 --> 00:11:57,480
call it so I'll be calling it X down

269
00:11:57,480 --> 00:12:00,660
arrow y so let's say this is PSI of X

270
00:12:00,660 --> 00:12:03,060
then PSI of X evaluates to the same

271
00:12:03,060 --> 00:12:06,959
value for two different X's X1 and X2 if

272
00:12:06,959 --> 00:12:09,240
and only if the distribution of Y

273
00:12:09,240 --> 00:12:11,459
conditioned on X1 is identical to

274
00:12:11,459 --> 00:12:13,920
distribution of Y condition on x2 this

275
00:12:13,920 --> 00:12:15,480
is like they are indistinguishable

276
00:12:15,480 --> 00:12:18,360
conditioned on either of these

277
00:12:18,360 --> 00:12:21,540
values realizations now what is the

278
00:12:21,540 --> 00:12:23,640
non-simulatability condition claiming

279
00:12:23,640 --> 00:12:27,720
it's claiming that this x down arrow y

280
00:12:27,720 --> 00:12:29,100
quantity

281
00:12:29,100 --> 00:12:31,440
uh

282
00:12:31,440 --> 00:12:36,779
C can use Z to catch B

283
00:12:36,779 --> 00:12:40,380
if this x down arrow y quantity has been

284
00:12:40,380 --> 00:12:42,540
forged using Y

285
00:12:42,540 --> 00:12:45,180
so this is a necessary and sufficient

286
00:12:45,180 --> 00:12:47,399
condition this the lack of Independence

287
00:12:47,399 --> 00:12:49,620
it's clear to see it's easy to see why

288
00:12:49,620 --> 00:12:51,899
this is necessary because if x down

289
00:12:51,899 --> 00:12:54,300
arrow y was independent of Z conditioned

290
00:12:54,300 --> 00:12:57,720
on y then you can indeed use y to forge

291
00:12:57,720 --> 00:13:00,000
X down arrow why

292
00:13:00,000 --> 00:13:01,860
and it turns out the converse is true

293
00:13:01,860 --> 00:13:04,279
that is if this condition is not

294
00:13:04,279 --> 00:13:09,000
satisfied then you can I mean then b a c

295
00:13:09,000 --> 00:13:11,579
with access to Z can statistically check

296
00:13:11,579 --> 00:13:13,320
whether X down arrow y has been

297
00:13:13,320 --> 00:13:16,019
correctly reported

298
00:13:16,019 --> 00:13:18,899
now this is the property this is the

299
00:13:18,899 --> 00:13:21,480
properties that are used in the 2004

300
00:13:21,480 --> 00:13:25,800
paper to get a protocol for broadcast by

301
00:13:25,800 --> 00:13:28,320
via the pseudo signatures when this

302
00:13:28,320 --> 00:13:30,000
condition is not I mean when the

303
00:13:30,000 --> 00:13:31,440
simulatability condition is not

304
00:13:31,440 --> 00:13:34,320
satisfied now why is it that this is not

305
00:13:34,320 --> 00:13:35,880
sufficient

306
00:13:35,880 --> 00:13:39,240
uh I I mean necessary it turns out that

307
00:13:39,240 --> 00:13:41,940
before starting this kind of a pseudo

308
00:13:41,940 --> 00:13:44,459
signature based protocol uh a can

309
00:13:44,459 --> 00:13:48,000
potentially upgrade C by this I mean

310
00:13:48,000 --> 00:13:51,240
that a sends the largest part of X that

311
00:13:51,240 --> 00:13:55,800
c can verify so that c can add to its

312
00:13:55,800 --> 00:13:58,860
Arsenal more than just written it can

313
00:13:58,860 --> 00:14:01,500
add things from a so what is the largest

314
00:14:01,500 --> 00:14:04,440
part that c can verify from me it's the

315
00:14:04,440 --> 00:14:06,420
same quantity that we previously saw its

316
00:14:06,420 --> 00:14:08,160
X down arrow Z

317
00:14:08,160 --> 00:14:11,820
so the protocol goes by first a sending

318
00:14:11,820 --> 00:14:14,760
this quantity and if it is verified now

319
00:14:14,760 --> 00:14:17,519
C has been upgraded to this larger

320
00:14:17,519 --> 00:14:19,980
correlation and then you can run the

321
00:14:19,980 --> 00:14:21,240
protocol

322
00:14:21,240 --> 00:14:23,279
the the previous protocol that we have

323
00:14:23,279 --> 00:14:24,720
been discussing

324
00:14:24,720 --> 00:14:27,899
and if the verification fails then C

325
00:14:27,899 --> 00:14:31,560
knows that a is corrupt so it can ask B

326
00:14:31,560 --> 00:14:33,899
to be the trusted party and carry on the

327
00:14:33,899 --> 00:14:35,579
broadcast

328
00:14:35,579 --> 00:14:39,060
so now ah it turns out that there are

329
00:14:39,060 --> 00:14:41,940
simple correlations where this kind of

330
00:14:41,940 --> 00:14:44,339
an update is necessary and this is

331
00:14:44,339 --> 00:14:46,860
exactly why the there is a gap between

332
00:14:46,860 --> 00:14:48,240
the necessary and sufficient condition

333
00:14:48,240 --> 00:14:52,380
over there in the 2004 paper so so now

334
00:14:52,380 --> 00:14:56,339
we have a an updated uh

335
00:14:56,339 --> 00:14:59,160
source for C

336
00:14:59,160 --> 00:15:01,920
but it turns out you can do

337
00:15:01,920 --> 00:15:04,320
these kind of upgrades much more

338
00:15:04,320 --> 00:15:06,899
aggressively by letting A and B interact

339
00:15:06,899 --> 00:15:07,980
with c

340
00:15:07,980 --> 00:15:10,519
in this manner so you can keep building

341
00:15:10,519 --> 00:15:12,899
its knowledge about

342
00:15:12,899 --> 00:15:16,139
X in a very verifiable manner until it's

343
00:15:16,139 --> 00:15:18,120
it reaches this quantity called X down

344
00:15:18,120 --> 00:15:20,279
arrow Z Infinity which is the largest

345
00:15:20,279 --> 00:15:22,560
quantity that you can verifiably upgrade

346
00:15:22,560 --> 00:15:24,800
to

347
00:15:25,019 --> 00:15:28,279
so one thing to note is that even though

348
00:15:28,279 --> 00:15:31,860
this is done in steps this is done in

349
00:15:31,860 --> 00:15:34,380
steps in the in in C's head but the

350
00:15:34,380 --> 00:15:36,420
communication that is required for this

351
00:15:36,420 --> 00:15:38,820
is uh

352
00:15:38,820 --> 00:15:42,420
um is only one round with a and b

353
00:15:42,420 --> 00:15:45,300
next we can also ask whether why not

354
00:15:45,300 --> 00:15:49,380
upgrade B also like we did see and here

355
00:15:49,380 --> 00:15:51,860
we should be slightly more careful

356
00:15:51,860 --> 00:15:55,560
upgrading B will allow B to verify a

357
00:15:55,560 --> 00:15:58,079
larger part of X this makes the

358
00:15:58,079 --> 00:16:01,500
verification part easy but then it also

359
00:16:01,500 --> 00:16:03,839
allows B to forge more convincingly

360
00:16:03,839 --> 00:16:06,060
towards C

361
00:16:06,060 --> 00:16:09,120
as a result uh we need to do this more

362
00:16:09,120 --> 00:16:11,519
carefully so how it is done is see

363
00:16:11,519 --> 00:16:14,040
upgrades B only on randomly chosen

364
00:16:14,040 --> 00:16:16,980
locations which are not known to a and

365
00:16:16,980 --> 00:16:19,500
this allows C to verify the signature

366
00:16:19,500 --> 00:16:24,000
that is coming from a however because B

367
00:16:24,000 --> 00:16:26,699
does not know the values the upgrades on

368
00:16:26,699 --> 00:16:29,220
several of these indices it will not be

369
00:16:29,220 --> 00:16:32,519
able to forge the signature except by

370
00:16:32,519 --> 00:16:36,120
using just Y and not the upgraded part

371
00:16:36,120 --> 00:16:38,899
so

372
00:16:39,139 --> 00:16:42,720
we call the conditions that we get from

373
00:16:42,720 --> 00:16:45,740
these two upgrades the ABC

374
00:16:45,740 --> 00:16:48,540
non-simulatability with interaction

375
00:16:48,540 --> 00:16:51,300
so when this condition is Satisfied by a

376
00:16:51,300 --> 00:16:53,699
correlation we can run a protocol which

377
00:16:53,699 --> 00:16:56,639
upgrade c and b and then eventually runs

378
00:16:56,639 --> 00:16:58,680
the protocol for broadcast using CO2

379
00:16:58,680 --> 00:17:00,959
signature that we previously saw using

380
00:17:00,959 --> 00:17:02,699
these upgraded correlations

381
00:17:02,699 --> 00:17:06,119
now if the simulatability condition is

382
00:17:06,119 --> 00:17:08,400
not satisfied in the other direction ACB

383
00:17:08,400 --> 00:17:11,400
then we can run a very similar protocol

384
00:17:11,400 --> 00:17:13,439
but with the roles of c and b

385
00:17:13,439 --> 00:17:15,780
interchanged

386
00:17:15,780 --> 00:17:17,819
this way we get uh

387
00:17:17,819 --> 00:17:20,699
a positive result and it turns out that

388
00:17:20,699 --> 00:17:24,799
we can show that this result is uh

389
00:17:24,959 --> 00:17:26,880
um I mean this condition of

390
00:17:26,880 --> 00:17:28,700
simulatability is also necessary

391
00:17:28,700 --> 00:17:31,559
non-simulatability that is so if both

392
00:17:31,559 --> 00:17:33,540
simulatability conditions are met then

393
00:17:33,540 --> 00:17:36,419
it's impossible to realize uh broadcast

394
00:17:36,419 --> 00:17:39,120
so how do we prove this we start with

395
00:17:39,120 --> 00:17:41,820
the uh impossibility

396
00:17:41,820 --> 00:17:44,160
of broadcast among three parties without

397
00:17:44,160 --> 00:17:45,440
setup

398
00:17:45,440 --> 00:17:49,080
this is a very interesting and elegant

399
00:17:49,080 --> 00:17:51,600
proof by flm

400
00:17:51,600 --> 00:17:54,240
uh

401
00:17:54,240 --> 00:17:57,360
yeah and and then uh so how does this

402
00:17:57,360 --> 00:18:01,080
proof work it connects uh several copies

403
00:18:01,080 --> 00:18:03,600
of the same parties and then make them

404
00:18:03,600 --> 00:18:07,280
run honestly the protocols of the

405
00:18:07,280 --> 00:18:10,860
purported broadcast protocol and then

406
00:18:10,860 --> 00:18:14,340
you argue uh several ways of

407
00:18:14,340 --> 00:18:17,160
interpreting this particular run and

408
00:18:17,160 --> 00:18:19,980
realize that this will always lead to a

409
00:18:19,980 --> 00:18:21,059
contradiction

410
00:18:21,059 --> 00:18:23,760
now what we do is we generalize this

411
00:18:23,760 --> 00:18:26,520
particular argument to the source

412
00:18:26,520 --> 00:18:30,419
correlation model so for this uh we

413
00:18:30,419 --> 00:18:32,580
uh

414
00:18:32,580 --> 00:18:34,679
when whenever the necessary conditions

415
00:18:34,679 --> 00:18:37,380
are not satisfied we come up with this

416
00:18:37,380 --> 00:18:40,080
joint distribution of X Y and Z which

417
00:18:40,080 --> 00:18:42,380
can be provided to these parties to

418
00:18:42,380 --> 00:18:45,059
conveniently reach a flm style

419
00:18:45,059 --> 00:18:46,919
impossibility

420
00:18:46,919 --> 00:18:49,500
so to summarize we looked at the

421
00:18:49,500 --> 00:18:51,840
characterization of correlations which

422
00:18:51,840 --> 00:18:54,059
permit three-party broadcast we realized

423
00:18:54,059 --> 00:18:56,340
that the earlier simulatability based

424
00:18:56,340 --> 00:18:59,820
condition does not fold and we replaced

425
00:18:59,820 --> 00:19:01,020
it with a simulatability with

426
00:19:01,020 --> 00:19:03,539
interaction condition

427
00:19:03,539 --> 00:19:08,240
our construction uses these uh you know

428
00:19:08,240 --> 00:19:11,960
these steps of slowly upgrading the

429
00:19:11,960 --> 00:19:15,240
correlations of both parties A and B and

430
00:19:15,240 --> 00:19:16,700
C and so on

431
00:19:16,700 --> 00:19:20,520
uh yeah and to show the negative result

432
00:19:20,520 --> 00:19:24,840
we extended the flm argument to Source

433
00:19:24,840 --> 00:19:26,220
correlations

434
00:19:26,220 --> 00:19:27,720
and it turns out this particular

435
00:19:27,720 --> 00:19:29,700
argument could go through even for the

436
00:19:29,700 --> 00:19:30,660
channel

437
00:19:30,660 --> 00:19:32,340
like setup

438
00:19:32,340 --> 00:19:33,559
finally

439
00:19:33,559 --> 00:19:35,580
it turns out that the same

440
00:19:35,580 --> 00:19:37,860
characterization that we just saw

441
00:19:37,860 --> 00:19:39,780
applies even for the feasibility of

442
00:19:39,780 --> 00:19:42,240
pseudo signatures in order to show this

443
00:19:42,240 --> 00:19:44,760
we build a protocol that reverses the

444
00:19:44,760 --> 00:19:46,919
direction of zero signatures from a b c

445
00:19:46,919 --> 00:19:49,320
to ACB this is an interesting

446
00:19:49,320 --> 00:19:51,299
construction that you can

447
00:19:51,299 --> 00:19:53,539
look into the paper for

448
00:19:53,539 --> 00:19:56,820
and another point to note is that the

449
00:19:56,820 --> 00:19:59,039
security error of this protocol is going

450
00:19:59,039 --> 00:20:01,919
to be a negligible function of n so it's

451
00:20:01,919 --> 00:20:03,419
efficient

452
00:20:03,419 --> 00:20:06,000
and it has constant number of rounds

453
00:20:06,000 --> 00:20:08,690
that's all thank you

454
00:20:08,690 --> 00:20:13,740
[Applause]

455
00:20:13,740 --> 00:20:15,299
um thank you for the nice talk we have

456
00:20:15,299 --> 00:20:17,640
time for a short question if there's one

457
00:20:17,640 --> 00:20:19,620
we

458
00:20:19,620 --> 00:20:22,939
but so

459
00:20:23,220 --> 00:20:24,780
thanks for the nice talk thank you I

460
00:20:24,780 --> 00:20:27,320
wonder what's a

461
00:20:27,539 --> 00:20:29,520
correlated sources

462
00:20:29,520 --> 00:20:32,100
I mean um

463
00:20:32,100 --> 00:20:34,620
as in so OT correlations would be a

464
00:20:34,620 --> 00:20:37,320
practical implementation I mean using OT

465
00:20:37,320 --> 00:20:40,039
correlation for realizing

466
00:20:40,039 --> 00:20:43,400
cryptographic Primitives

467
00:20:45,000 --> 00:20:47,160
no I mean so over here the correlations

468
00:20:47,160 --> 00:20:49,740
could be any kind of correlation so one

469
00:20:49,740 --> 00:20:51,360
one interesting correlation could be

470
00:20:51,360 --> 00:20:53,880
just the Rab in OT which is like a

471
00:20:53,880 --> 00:20:56,160
random bit at one arabinoid correlation

472
00:20:56,160 --> 00:20:58,440
is random bit at one side and erase it

473
00:20:58,440 --> 00:21:00,240
on the other side with probability half

474
00:21:00,240 --> 00:21:02,760
but it's worth noting that we need a

475
00:21:02,760 --> 00:21:04,500
three wise correlation at least to

476
00:21:04,500 --> 00:21:07,220
realize broadcast

477
00:21:07,799 --> 00:21:10,679
okay thank you we need to move on to the

478
00:21:10,679 --> 00:21:14,480
next talk thank you Arun

479
00:21:17,700 --> 00:21:19,080
so

480
00:21:19,080 --> 00:21:21,600
next speaker next talk is privacy

481
00:21:21,600 --> 00:21:25,260
preserving blueprints from Marco colvis

482
00:21:25,260 --> 00:21:28,080
analysis Kaya and anguyan and Mark roof

483
00:21:28,080 --> 00:21:30,740
will give the talk

484
00:21:44,039 --> 00:21:47,520
that is okay yeah welcome to my talk and

485
00:21:47,520 --> 00:21:49,919
thanks for the introduction so I started

486
00:21:49,919 --> 00:21:53,159
off with a hunt drawn slides but I made

487
00:21:53,159 --> 00:21:55,620
the slides much nicer also thanks to a

488
00:21:55,620 --> 00:21:57,179
bit nice pictures from church as well

489
00:21:57,179 --> 00:21:58,799
Martin and uh

490
00:21:58,799 --> 00:22:02,120
yeah so let's get started

491
00:22:02,120 --> 00:22:05,340
so to set the stage so this talk is kind

492
00:22:05,340 --> 00:22:08,640
of set in a in a not too far future

493
00:22:08,640 --> 00:22:10,740
where we made even more progress than we

494
00:22:10,740 --> 00:22:13,020
already did in doing Anonymous

495
00:22:13,020 --> 00:22:14,760
transactions

496
00:22:14,760 --> 00:22:17,100
and so we have a user that interacts

497
00:22:17,100 --> 00:22:18,720
with the verifier and he might use

498
00:22:18,720 --> 00:22:20,700
anonymous credentials or perfectly

499
00:22:20,700 --> 00:22:23,700
Anonymous channels and the like

500
00:22:23,700 --> 00:22:26,820
so we made technical progress but um we

501
00:22:26,820 --> 00:22:28,200
might not have made that much Social

502
00:22:28,200 --> 00:22:31,140
Focus that usually takes a

503
00:22:31,140 --> 00:22:33,840
um much longer so even that world there

504
00:22:33,840 --> 00:22:36,900
are some people that need to be audited

505
00:22:36,900 --> 00:22:39,780
and so there's an authority that might

506
00:22:39,780 --> 00:22:44,059
have to investigate crimes and the like

507
00:22:44,640 --> 00:22:46,620
so that Authority might say that in

508
00:22:46,620 --> 00:22:48,299
order to protect us from terrorists or

509
00:22:48,299 --> 00:22:51,059
protect our children it needs to see a

510
00:22:51,059 --> 00:22:52,140
lot of information about our

511
00:22:52,140 --> 00:22:54,480
transactions

512
00:22:54,480 --> 00:22:56,580
so verifiers typically are business

513
00:22:56,580 --> 00:23:00,179
people they want to be like within the

514
00:23:00,179 --> 00:23:01,260
frame of law

515
00:23:01,260 --> 00:23:03,120
so they want to make sure that that

516
00:23:03,120 --> 00:23:05,400
Authority gets to see what they need to

517
00:23:05,400 --> 00:23:08,400
see and in addition they might need some

518
00:23:08,400 --> 00:23:10,679
policy to be satisfied

519
00:23:10,679 --> 00:23:14,100
so here's an example so for instance the

520
00:23:14,100 --> 00:23:16,200
auditor might need to see some unique

521
00:23:16,200 --> 00:23:18,600
identify of the user so they can look up

522
00:23:18,600 --> 00:23:21,240
the user in the database while the

523
00:23:21,240 --> 00:23:23,580
verifier might just be happy with

524
00:23:23,580 --> 00:23:25,880
knowing that the user is older than 21

525
00:23:25,880 --> 00:23:28,620
or not in the European Union because

526
00:23:28,620 --> 00:23:31,799
they are the Privacy regulations are too

527
00:23:31,799 --> 00:23:33,960
strict

528
00:23:33,960 --> 00:23:37,700
that was kind of a joke but yeah

529
00:23:37,980 --> 00:23:42,360
so users often are quite empathetic

530
00:23:42,360 --> 00:23:44,340
about privacy I think the reason for

531
00:23:44,340 --> 00:23:46,559
that is often that they currently don't

532
00:23:46,559 --> 00:23:49,080
have like much of a choice and they also

533
00:23:49,080 --> 00:23:51,659
value free services and of course they

534
00:23:51,659 --> 00:23:54,679
also care about their kids

535
00:23:54,720 --> 00:23:58,140
however I think often bad things happen

536
00:23:58,140 --> 00:24:00,120
and we kind of realize that our world is

537
00:24:00,120 --> 00:24:02,640
not constantly moving towards more

538
00:24:02,640 --> 00:24:05,340
democracy so there's there are risks in

539
00:24:05,340 --> 00:24:06,539
having

540
00:24:06,539 --> 00:24:09,539
um too much infringement by authorities

541
00:24:09,539 --> 00:24:12,000
so users might think that yes privacy is

542
00:24:12,000 --> 00:24:14,580
a human right I want to protect that but

543
00:24:14,580 --> 00:24:17,880
I still need the service of data

544
00:24:17,880 --> 00:24:20,659
verifier offers

545
00:24:21,600 --> 00:24:25,200
so Phil wagovic complains that we always

546
00:24:25,200 --> 00:24:28,919
use this cute attackers in our talks so

547
00:24:28,919 --> 00:24:31,260
that's why I put up this uh sticker here

548
00:24:31,260 --> 00:24:34,080
for the NSA and a lot of this talk is of

549
00:24:34,080 --> 00:24:35,280
course motivated by this Northern

550
00:24:35,280 --> 00:24:37,700
Revelations

551
00:24:40,020 --> 00:24:44,280
so our goal is to kind of make all sides

552
00:24:44,280 --> 00:24:47,820
happy or at least equally unhappy

553
00:24:47,820 --> 00:24:50,940
and so what is our goal so the auditor

554
00:24:50,940 --> 00:24:52,919
knows some secret information that he

555
00:24:52,919 --> 00:24:55,740
uses to investigate crimes let's denote

556
00:24:55,740 --> 00:24:57,780
that by X for instance this might be a

557
00:24:57,780 --> 00:25:00,559
list of suspects

558
00:25:00,960 --> 00:25:04,080
so the user has attributes

559
00:25:04,080 --> 00:25:06,480
um let's focus on why being the user's

560
00:25:06,480 --> 00:25:08,039
identity for instance is social security

561
00:25:08,039 --> 00:25:10,140
number

562
00:25:10,140 --> 00:25:12,840
or some other unique identity

563
00:25:12,840 --> 00:25:15,059
and the verifier kind of can interact

564
00:25:15,059 --> 00:25:17,220
with users but only if there's if the

565
00:25:17,220 --> 00:25:20,039
auditor gets to see the function of X

566
00:25:20,039 --> 00:25:23,520
the suspect list and the user's

567
00:25:23,520 --> 00:25:25,620
attributes or his identity

568
00:25:25,620 --> 00:25:27,720
and then Additionally the policy that

569
00:25:27,720 --> 00:25:30,779
his business policy must be met

570
00:25:30,779 --> 00:25:33,299
so let's look at the concrete

571
00:25:33,299 --> 00:25:35,700
ayap so what are the the goals that we

572
00:25:35,700 --> 00:25:39,000
want to achieve so we want the auditor

573
00:25:39,000 --> 00:25:41,580
wants to keep his kind of suspect list

574
00:25:41,580 --> 00:25:45,240
private so X should be only known to him

575
00:25:45,240 --> 00:25:48,539
and we want that the auditor only gets

576
00:25:48,539 --> 00:25:51,440
to see f of x y but nothing about y

577
00:25:51,440 --> 00:25:54,779
especially for for honest users

578
00:25:54,779 --> 00:25:57,900
the user kind of only gets to see F so

579
00:25:57,900 --> 00:25:59,880
he knows what the auditing policy is but

580
00:25:59,880 --> 00:26:01,559
he doesn't know the secret input of the

581
00:26:01,559 --> 00:26:03,960
auditor and he accepts that the auditor

582
00:26:03,960 --> 00:26:06,659
gets to see f of x of Y for some

583
00:26:06,659 --> 00:26:09,360
committed X or encrypted X of the

584
00:26:09,360 --> 00:26:11,779
auditor

585
00:26:14,880 --> 00:26:17,580
so here's a concrete example that we

586
00:26:17,580 --> 00:26:20,760
call a watch list so in a watch list the

587
00:26:20,760 --> 00:26:26,159
function f of x y is y if the user is a

588
00:26:26,159 --> 00:26:28,860
suspect so if Y is in the list of

589
00:26:28,860 --> 00:26:30,779
suspects then it this function behaves

590
00:26:30,779 --> 00:26:33,000
like the identity function and otherwise

591
00:26:33,000 --> 00:26:34,620
it behaves like the constant function

592
00:26:34,620 --> 00:26:36,480
doesn't reveal anything about the user's

593
00:26:36,480 --> 00:26:38,960
information

594
00:26:40,620 --> 00:26:42,659
so what we do is we design a

595
00:26:42,659 --> 00:26:45,600
cryptographic primitive that allows us

596
00:26:45,600 --> 00:26:47,700
to achieve this that allows the auditor

597
00:26:47,700 --> 00:26:51,120
to learn f of x y but nothing else

598
00:26:51,120 --> 00:26:53,480
so that Primitives modeled

599
00:26:53,480 --> 00:26:55,799
on on public key encryption because

600
00:26:55,799 --> 00:26:57,120
that's something that we kind of

601
00:26:57,120 --> 00:26:59,760
understand quite well and that we hope

602
00:26:59,760 --> 00:27:01,620
can can be

603
00:27:01,620 --> 00:27:02,400
um

604
00:27:02,400 --> 00:27:04,980
that developers or people that use this

605
00:27:04,980 --> 00:27:07,860
scheme can understand so there's a key

606
00:27:07,860 --> 00:27:10,020
generation algorithm that takes the

607
00:27:10,020 --> 00:27:11,760
audit the sequence information acts as

608
00:27:11,760 --> 00:27:15,120
input and produces as a key pair where

609
00:27:15,120 --> 00:27:17,279
the public key encodes the secret

610
00:27:17,279 --> 00:27:19,799
information but hides it so the green

611
00:27:19,799 --> 00:27:22,559
boxes always denote ciphertext or

612
00:27:22,559 --> 00:27:24,900
something that hides the information in

613
00:27:24,900 --> 00:27:26,039
the Box

614
00:27:26,039 --> 00:27:28,740
so that public key is made available to

615
00:27:28,740 --> 00:27:30,600
users and it's important to note that

616
00:27:30,600 --> 00:27:33,539
all users use the same public key

617
00:27:33,539 --> 00:27:35,580
so a user will then create an escrow

618
00:27:35,580 --> 00:27:38,360
using that public key and his

619
00:27:38,360 --> 00:27:41,700
attribute information is identity y

620
00:27:41,700 --> 00:27:43,919
and that results in the escrow value f

621
00:27:43,919 --> 00:27:46,140
of x y

622
00:27:46,140 --> 00:27:48,419
that is sent to the verifier

623
00:27:48,419 --> 00:27:51,179
the verifier can can check that the S4

624
00:27:51,179 --> 00:27:53,220
is correctly formed but does not

625
00:27:53,220 --> 00:27:54,900
actually get to see anything so this is

626
00:27:54,900 --> 00:27:56,700
a ciphertext available it doesn't get to

627
00:27:56,700 --> 00:27:59,940
see anything but on request the auditor

628
00:27:59,940 --> 00:28:02,460
can request can obtain the SQL and

629
00:28:02,460 --> 00:28:04,980
decrypt it to learn f of x y

630
00:28:04,980 --> 00:28:08,000
but nothing else

631
00:28:08,580 --> 00:28:10,679
so this is kind of the syntax of our

632
00:28:10,679 --> 00:28:13,020
scheme so I oversimplified it a little

633
00:28:13,020 --> 00:28:15,299
bit to kind of introduce complexity

634
00:28:15,299 --> 00:28:18,480
gradually in reality the syntax is a bit

635
00:28:18,480 --> 00:28:21,720
more complex

636
00:28:21,720 --> 00:28:24,120
so we add

637
00:28:24,120 --> 00:28:26,580
and and commitment scheme and so the the

638
00:28:26,580 --> 00:28:28,799
reason for that complex is that we also

639
00:28:28,799 --> 00:28:31,080
want to kind of watch The Watchman we

640
00:28:31,080 --> 00:28:32,760
want to

641
00:28:32,760 --> 00:28:34,200
um check some information about the X

642
00:28:34,200 --> 00:28:36,240
without actually learning the X and we

643
00:28:36,240 --> 00:28:38,940
also want to integrate them this

644
00:28:38,940 --> 00:28:40,320
blueprint scheme with Anonymous

645
00:28:40,320 --> 00:28:42,000
credentials and for that we use external

646
00:28:42,000 --> 00:28:43,980
commitments but more about that

647
00:28:43,980 --> 00:28:46,340
um after I summarize our contributions

648
00:28:46,340 --> 00:28:50,340
so our contributions are fourfold so

649
00:28:50,340 --> 00:28:52,140
um our main contribution is actually to

650
00:28:52,140 --> 00:28:54,600
introduce this primitive so and we want

651
00:28:54,600 --> 00:28:56,700
it to be as simple as possible

652
00:28:56,700 --> 00:28:59,580
and as I mentioned that primitive should

653
00:28:59,580 --> 00:29:01,320
be easily integrated with Anonymous

654
00:29:01,320 --> 00:29:04,159
credentials or also ecash or Anonymous

655
00:29:04,159 --> 00:29:08,659
payment systems such as ccash

656
00:29:08,820 --> 00:29:11,340
so we give a formal notion which is

657
00:29:11,340 --> 00:29:14,760
simulation based but we um

658
00:29:14,760 --> 00:29:16,620
it's also property based so there are

659
00:29:16,620 --> 00:29:19,440
multiple properties that describe

660
00:29:19,440 --> 00:29:22,440
um what uh what the auditor and the

661
00:29:22,440 --> 00:29:26,120
users security requirements are

662
00:29:26,880 --> 00:29:28,799
then we give an efficient instantiation

663
00:29:28,799 --> 00:29:30,840
based on decisional development

664
00:29:30,840 --> 00:29:33,659
it's based on elgamal and sigma proves

665
00:29:33,659 --> 00:29:36,480
and we here we use a notion of we also

666
00:29:36,480 --> 00:29:37,620
show how to instantiate this year

667
00:29:37,620 --> 00:29:38,940
knowledge proofs and we introduce a

668
00:29:38,940 --> 00:29:40,200
concept of partial straight line

669
00:29:40,200 --> 00:29:42,179
extraction which is a relaxation of

670
00:29:42,179 --> 00:29:43,980
straight line extraction which allows

671
00:29:43,980 --> 00:29:46,760
for more efficiency

672
00:29:46,919 --> 00:29:49,140
last but not least we also show how to

673
00:29:49,140 --> 00:29:53,340
obtain blueprints for all functions from

674
00:29:53,340 --> 00:29:56,039
fhe and generic non-interactive CR

675
00:29:56,039 --> 00:29:58,020
knowledge and also from non-interactive

676
00:29:58,020 --> 00:30:00,600
secure computation so I will not be able

677
00:30:00,600 --> 00:30:03,480
to go into into all the details but more

678
00:30:03,480 --> 00:30:07,399
information can be found in our paper

679
00:30:08,220 --> 00:30:10,140
so there is of course a lot of related

680
00:30:10,140 --> 00:30:12,240
work so this Builds on a long tradition

681
00:30:12,240 --> 00:30:16,380
of cryptographic work that tries to kind

682
00:30:16,380 --> 00:30:18,059
of balance privacy and accountability

683
00:30:18,059 --> 00:30:22,020
starting with David charm in the 80s so

684
00:30:22,020 --> 00:30:23,700
he worked on his famous paper on the

685
00:30:23,700 --> 00:30:25,140
card computer he also worked on group

686
00:30:25,140 --> 00:30:26,700
signatures which is a closely related

687
00:30:26,700 --> 00:30:29,640
primitive and then work by combination

688
00:30:29,640 --> 00:30:32,159
lucianskaya and a lot of many of their

689
00:30:32,159 --> 00:30:34,679
collaborators and many other groups on

690
00:30:34,679 --> 00:30:36,899
Anonymous credentials and the latest

691
00:30:36,899 --> 00:30:39,679
hype or instantiation of this is in

692
00:30:39,679 --> 00:30:43,559
self-solving identity management

693
00:30:43,559 --> 00:30:45,960
so there are several closely related

694
00:30:45,960 --> 00:30:48,840
works one by Green corruption and layer

695
00:30:48,840 --> 00:30:50,460
the earlier system which stands for

696
00:30:50,460 --> 00:30:52,080
abuse resistant law enforcement access

697
00:30:52,080 --> 00:30:54,360
control from which we actually took the

698
00:30:54,360 --> 00:30:56,399
inspiration for our non-interactive

699
00:30:56,399 --> 00:31:00,320
secure computation Construction

700
00:31:01,020 --> 00:31:03,600
and also worked by goldwassa and park

701
00:31:03,600 --> 00:31:06,419
which looked at public accountability

702
00:31:06,419 --> 00:31:08,460
versus secret laws and they asked

703
00:31:08,460 --> 00:31:10,559
whether they can coexist in generally

704
00:31:10,559 --> 00:31:12,799
all this line of work

705
00:31:12,799 --> 00:31:15,600
answers the question of whether privacy

706
00:31:15,600 --> 00:31:18,539
and accountability can can be balanced

707
00:31:18,539 --> 00:31:21,720
in a positive way

708
00:31:21,720 --> 00:31:24,799
so this is possible

709
00:31:25,740 --> 00:31:28,200
so there's also there was also a paper I

710
00:31:28,200 --> 00:31:31,440
think on Tuesday which showed how this

711
00:31:31,440 --> 00:31:33,539
can be done for the traceability of

712
00:31:33,539 --> 00:31:35,340
group signatures so this is also close

713
00:31:35,340 --> 00:31:37,380
closely related work and would love to

714
00:31:37,380 --> 00:31:39,980
hear from you guys

715
00:31:43,200 --> 00:31:46,860
good so let's um look at the integration

716
00:31:46,860 --> 00:31:49,080
with Anonymous credentials so this is

717
00:31:49,080 --> 00:31:52,200
the kind of the simplified syntax so in

718
00:31:52,200 --> 00:31:54,240
order to integrate things we have

719
00:31:54,240 --> 00:31:57,360
external commitment parameters

720
00:31:57,360 --> 00:32:00,120
and we generate a setup based on those

721
00:32:00,120 --> 00:32:01,799
parameters

722
00:32:01,799 --> 00:32:04,820
now we give an opening to a commitment

723
00:32:04,820 --> 00:32:09,659
to the secret values X and Y to the

724
00:32:09,659 --> 00:32:13,200
keychain and Esco algorithms

725
00:32:13,200 --> 00:32:16,080
so by that the

726
00:32:16,080 --> 00:32:20,880
the we have that um

727
00:32:20,880 --> 00:32:23,700
we obtain a commitment to X that

728
00:32:23,700 --> 00:32:27,360
corresponds to the X in the public key

729
00:32:27,360 --> 00:32:29,220
and the kitchen algorithm will prove

730
00:32:29,220 --> 00:32:30,539
that

731
00:32:30,539 --> 00:32:33,779
that this commitment contains the same

732
00:32:33,779 --> 00:32:35,100
value as the public key and this can

733
00:32:35,100 --> 00:32:37,200
then be verified using the public key

734
00:32:37,200 --> 00:32:38,820
verification algorithm

735
00:32:38,820 --> 00:32:41,340
so if we now do an external commit and

736
00:32:41,340 --> 00:32:43,500
proof see a knowledge proof that this

737
00:32:43,500 --> 00:32:45,840
committed value has nice properties for

738
00:32:45,840 --> 00:32:49,559
instance that it contains only suspects

739
00:32:49,559 --> 00:32:51,600
for which there's a variant then we can

740
00:32:51,600 --> 00:32:55,200
keep them auditor more accountable

741
00:32:55,200 --> 00:32:58,620
similarly we add a commitment to the

742
00:32:58,620 --> 00:33:01,320
escrow algorithm which is verified by

743
00:33:01,320 --> 00:33:04,020
the by file and this is this is POS this

744
00:33:04,020 --> 00:33:06,539
allows us to bind y to existing

745
00:33:06,539 --> 00:33:09,860
Anonymous credential schemes

746
00:33:11,460 --> 00:33:15,000
so we Define security of blueprints as I

747
00:33:15,000 --> 00:33:16,159
mentioned

748
00:33:16,159 --> 00:33:18,419
using kind of simulation based but

749
00:33:18,419 --> 00:33:20,940
property-based definitions so we have

750
00:33:20,940 --> 00:33:23,760
three properties one is blueprint hiding

751
00:33:23,760 --> 00:33:25,940
which guarantees that

752
00:33:25,940 --> 00:33:30,960
the value X of the auditor is hidden

753
00:33:30,960 --> 00:33:34,760
both from the user antibiotifier

754
00:33:34,799 --> 00:33:36,659
so we have soundness which guarantees

755
00:33:36,659 --> 00:33:37,980
that if

756
00:33:37,980 --> 00:33:39,799
the public key

757
00:33:39,799 --> 00:33:44,220
x verifies with a commitment Cy then it

758
00:33:44,220 --> 00:33:48,200
actually decrypts to f of x y

759
00:33:48,840 --> 00:33:51,299
the third property guarantees security

760
00:33:51,299 --> 00:33:53,220
for both the auditor and for the user

761
00:33:53,220 --> 00:33:55,620
because it guarantees that both X and Y

762
00:33:55,620 --> 00:33:58,140
are hidden in the S code towards

763
00:33:58,140 --> 00:34:00,059
external parties

764
00:34:00,059 --> 00:34:02,220
and the last property is maybe the one

765
00:34:02,220 --> 00:34:04,679
that the user cares the most about

766
00:34:04,679 --> 00:34:07,320
because it says that even if the secret

767
00:34:07,320 --> 00:34:09,960
key of the auditor is used against him

768
00:34:09,960 --> 00:34:14,300
all that can be learned is f of x y

769
00:34:15,780 --> 00:34:19,560
so this I look into the last property in

770
00:34:19,560 --> 00:34:21,480
in bit more detail now so how do we

771
00:34:21,480 --> 00:34:22,859
Define this as I mentioned it is

772
00:34:22,859 --> 00:34:25,020
simulation based so we have a real world

773
00:34:25,020 --> 00:34:27,899
and an Ideal World so it's the same

774
00:34:27,899 --> 00:34:29,820
adverse in both worlds and that

775
00:34:29,820 --> 00:34:33,000
adversely kind of obtains the setup

776
00:34:33,000 --> 00:34:35,159
he then produces a public key and the

777
00:34:35,159 --> 00:34:37,679
commitment kind of commitment opening to

778
00:34:37,679 --> 00:34:39,359
that public key

779
00:34:39,359 --> 00:34:41,280
and the same happens in the ideal world

780
00:34:41,280 --> 00:34:43,199
except that there we use a simulated

781
00:34:43,199 --> 00:34:45,560
setup

782
00:34:45,719 --> 00:34:47,879
so we now require that that public key

783
00:34:47,879 --> 00:34:50,060
verifies with respect to the commitment

784
00:34:50,060 --> 00:34:54,080
computed with that opening

785
00:34:54,179 --> 00:34:56,460
so these models that when verification

786
00:34:56,460 --> 00:34:59,760
fails a user will not use the public key

787
00:34:59,760 --> 00:35:01,920
and so you will not encrypt this

788
00:35:01,920 --> 00:35:04,560
information so if verification fails we

789
00:35:04,560 --> 00:35:07,080
abort the experiment

790
00:35:07,080 --> 00:35:09,240
so now let's assume that verification is

791
00:35:09,240 --> 00:35:12,420
successful so then we require that no

792
00:35:12,420 --> 00:35:14,339
information in escrow reveals no

793
00:35:14,339 --> 00:35:17,099
information except f of x y and we model

794
00:35:17,099 --> 00:35:19,260
this using simulation so in the real

795
00:35:19,260 --> 00:35:22,920
world the adverse we can choose any user

796
00:35:22,920 --> 00:35:25,500
value by and Randomness R Prime and he

797
00:35:25,500 --> 00:35:27,960
obtains the honestly computed escort

798
00:35:27,960 --> 00:35:30,420
while in the ideal world

799
00:35:30,420 --> 00:35:32,820
he obtains a simulated escrow

800
00:35:32,820 --> 00:35:34,920
where the simulator only gets to see a

801
00:35:34,920 --> 00:35:38,040
commitment to Y and f of x y so the

802
00:35:38,040 --> 00:35:40,859
value of f x y and as this commitment

803
00:35:40,859 --> 00:35:42,240
typically would be like a Patterson

804
00:35:42,240 --> 00:35:43,560
commitment scheme that's information so

805
00:35:43,560 --> 00:35:46,020
early hiding these models that really no

806
00:35:46,020 --> 00:35:48,599
information is filled about except for f

807
00:35:48,599 --> 00:35:51,140
of x y

808
00:35:56,040 --> 00:35:59,420
okay let's speed up a bit

809
00:36:01,140 --> 00:36:03,000
so we have a generic construction from

810
00:36:03,000 --> 00:36:05,220
blueprint which follows

811
00:36:05,220 --> 00:36:09,440
um a typical recipe which lifts

812
00:36:09,440 --> 00:36:11,480
passively secure

813
00:36:11,480 --> 00:36:14,099
non-interactive and passively secure

814
00:36:14,099 --> 00:36:15,480
computation to actively secure

815
00:36:15,480 --> 00:36:17,640
computation so in our setting that means

816
00:36:17,640 --> 00:36:19,140
that we have a non-interactive secure

817
00:36:19,140 --> 00:36:21,060
computation of F that is passively

818
00:36:21,060 --> 00:36:23,579
secure and then we use Co knowledge

819
00:36:23,579 --> 00:36:25,500
proofs to lift this to active security

820
00:36:25,500 --> 00:36:31,160
and at this commitment to the inputs

821
00:36:31,619 --> 00:36:34,200
in our constructions for all functions

822
00:36:34,200 --> 00:36:36,119
we obtain the passive security from

823
00:36:36,119 --> 00:36:39,180
circuit pivot functional fully homework

824
00:36:39,180 --> 00:36:41,579
encryption or from non-interactive

825
00:36:41,579 --> 00:36:43,740
secure computation

826
00:36:43,740 --> 00:36:45,359
our efficient construction for watch

827
00:36:45,359 --> 00:36:48,839
lists is based on lifted argument

828
00:36:48,839 --> 00:36:52,800
so I will look into the details of

829
00:36:52,800 --> 00:36:57,300
lifted lgmal and there we also use as I

830
00:36:57,300 --> 00:36:58,980
mentioned this partial straight line

831
00:36:58,980 --> 00:37:01,140
extractable proofs of knowledge which

832
00:37:01,140 --> 00:37:03,960
might be of independent interest to get

833
00:37:03,960 --> 00:37:07,160
efficient Sigma proofs

834
00:37:08,700 --> 00:37:12,720
so let's recall the watch list function

835
00:37:12,720 --> 00:37:16,079
so it says that the function f of x y

836
00:37:16,079 --> 00:37:18,839
returns y if Y is in the list of

837
00:37:18,839 --> 00:37:23,060
suspects and the empty string otherwise

838
00:37:24,359 --> 00:37:26,940
so first we'll describe decryption which

839
00:37:26,940 --> 00:37:30,480
is just trial decryption in a sense so I

840
00:37:30,480 --> 00:37:33,240
get an Esco I decrypt it using an

841
00:37:33,240 --> 00:37:35,820
algemal secret key

842
00:37:35,820 --> 00:37:39,060
and then I check if the value Y is in a

843
00:37:39,060 --> 00:37:41,099
list of suspects which is also part of

844
00:37:41,099 --> 00:37:43,320
the secret key and in that case if we

845
00:37:43,320 --> 00:37:46,500
turn y otherwise will turn Epsilon so

846
00:37:46,500 --> 00:37:47,579
how do we get

847
00:37:47,579 --> 00:37:52,500
that value into into the SQL

848
00:37:52,500 --> 00:37:54,560
so we use a nice trick based on

849
00:37:54,560 --> 00:37:58,800
polynomials so we encode the list of x i

850
00:37:58,800 --> 00:38:01,500
values into the roots of a polynomial

851
00:38:01,500 --> 00:38:03,839
which we then also randomize so we get a

852
00:38:03,839 --> 00:38:10,220
random polynomial with a votes at x i

853
00:38:10,619 --> 00:38:14,720
so we represent that polynomial

854
00:38:15,480 --> 00:38:17,640
three minutes left so we present that

855
00:38:17,640 --> 00:38:20,820
polynomial using its coefficients and we

856
00:38:20,820 --> 00:38:24,180
encrypt those coefficients and add those

857
00:38:24,180 --> 00:38:28,279
encrypted coefficients to the public key

858
00:38:29,099 --> 00:38:31,859
so in order to form an escrow we

859
00:38:31,859 --> 00:38:35,339
evaluate the polynomial at the user's

860
00:38:35,339 --> 00:38:37,500
value uses an entity y

861
00:38:37,500 --> 00:38:39,540
which means that

862
00:38:39,540 --> 00:38:43,200
we get a zero value if Y is in the list

863
00:38:43,200 --> 00:38:46,619
and some non-zero value otherwise

864
00:38:46,619 --> 00:38:49,440
and this can then be used to encrypt so

865
00:38:49,440 --> 00:38:52,200
we pick a randomizer as Prime

866
00:38:52,200 --> 00:38:55,380
if we multiply that value with S Prime

867
00:38:55,380 --> 00:38:57,599
so if it was a zero value then it is

868
00:38:57,599 --> 00:39:00,060
still zero and we can add the user's

869
00:39:00,060 --> 00:39:01,380
identity to it

870
00:39:01,380 --> 00:39:03,720
and if it was non-zero then it will be

871
00:39:03,720 --> 00:39:06,420
completely randomized we add the

872
00:39:06,420 --> 00:39:08,099
identity to it which is then hidden it's

873
00:39:08,099 --> 00:39:12,859
like a one-time path type encryption

874
00:39:14,700 --> 00:39:17,160
so yeah so that's uh sums up our scheme

875
00:39:17,160 --> 00:39:19,200
I think it's it's really quite simple

876
00:39:19,200 --> 00:39:20,520
which I think is a good thing because

877
00:39:20,520 --> 00:39:22,640
one of the challenges when implementing

878
00:39:22,640 --> 00:39:24,780
mechanisms like that is that they might

879
00:39:24,780 --> 00:39:27,119
be subverted or there might be a

880
00:39:27,119 --> 00:39:29,460
backdoor inserted so just code if we

881
00:39:29,460 --> 00:39:31,440
indeed decide to use it would have to be

882
00:39:31,440 --> 00:39:34,320
very carefully audited because but I

883
00:39:34,320 --> 00:39:36,420
think any software can be supported so

884
00:39:36,420 --> 00:39:39,839
in some sense that

885
00:39:39,839 --> 00:39:41,160
but yeah

886
00:39:41,160 --> 00:39:44,579
okay that's crucial so let's swap up so

887
00:39:44,579 --> 00:39:46,320
the motivation is that

888
00:39:46,320 --> 00:39:48,839
um we wanted to find a sensible

889
00:39:48,839 --> 00:39:50,040
trade-off between privacy and

890
00:39:50,040 --> 00:39:51,960
accountability so we don't have to

891
00:39:51,960 --> 00:39:53,579
choose between

892
00:39:53,579 --> 00:39:56,040
um whether we want security or privacy

893
00:39:56,040 --> 00:39:58,140
we only have to choose what the function

894
00:39:58,140 --> 00:40:00,780
f should be and how we want to certify X

895
00:40:00,780 --> 00:40:03,060
and Y

896
00:40:03,060 --> 00:40:06,060
and we give strong definitions it's an

897
00:40:06,060 --> 00:40:07,640
interesting question whether we can

898
00:40:07,640 --> 00:40:10,920
obtain Universal composition

899
00:40:10,920 --> 00:40:14,339
I think it might be possible but

900
00:40:14,339 --> 00:40:17,220
efficiency might suffer so by doing this

901
00:40:17,220 --> 00:40:20,280
like very efficiently might be like a

902
00:40:20,280 --> 00:40:22,500
bit of a challenge still

903
00:40:22,500 --> 00:40:25,380
and then we gave constructions both for

904
00:40:25,380 --> 00:40:28,320
specific functions and for all General

905
00:40:28,320 --> 00:40:30,980
functions

906
00:40:32,490 --> 00:40:36,549
[Applause]

907
00:40:37,260 --> 00:40:39,720
okay thank you Marco for the nice talks

908
00:40:39,720 --> 00:40:42,259
any questions

909
00:40:43,619 --> 00:40:46,200
okay so I there's no question

910
00:40:46,200 --> 00:40:48,180
so I will ask something

911
00:40:48,180 --> 00:40:51,180
um so the the constructions you give for

912
00:40:51,180 --> 00:40:53,220
white leads is quite efficient

913
00:40:53,220 --> 00:40:53,820
um

914
00:40:53,820 --> 00:40:57,060
and is there any other function that you

915
00:40:57,060 --> 00:40:58,980
think might make sense to consider that

916
00:40:58,980 --> 00:41:03,119
might also give good instantiations

917
00:41:03,119 --> 00:41:05,400
so in in our paper we actually give a

918
00:41:05,400 --> 00:41:07,980
more General function which also reveals

919
00:41:07,980 --> 00:41:09,720
some additional auxiliary information

920
00:41:09,720 --> 00:41:12,900
about the user so here we just revealed

921
00:41:12,900 --> 00:41:14,880
the identity but actually you can have

922
00:41:14,880 --> 00:41:16,440
additional luxury information that is

923
00:41:16,440 --> 00:41:18,480
revealed when there is a matching so

924
00:41:18,480 --> 00:41:20,700
that's one thing we had it's an

925
00:41:20,700 --> 00:41:23,040
interesting question which

926
00:41:23,040 --> 00:41:26,280
oh a generic construction using fhe what

927
00:41:26,280 --> 00:41:27,900
could be done there's some kind of risk

928
00:41:27,900 --> 00:41:29,760
assessment and things like that I think

929
00:41:29,760 --> 00:41:31,320
that that's also something we're looking

930
00:41:31,320 --> 00:41:33,960
at for instance that you might ramp up

931
00:41:33,960 --> 00:41:35,940
some kind of risk score and if that gets

932
00:41:35,940 --> 00:41:39,240
too high then one gets uh the

933
00:41:39,240 --> 00:41:41,160
unannonymized

934
00:41:41,160 --> 00:41:43,740
okay thank you I need to move on to the

935
00:41:43,740 --> 00:41:45,560
next talk thank you very much

936
00:41:45,560 --> 00:41:49,509
[Applause]

937
00:41:56,220 --> 00:41:57,599
so

938
00:41:57,599 --> 00:42:00,300
um next talk will be by Hamza uzala who

939
00:42:00,300 --> 00:42:02,400
joined work with valeriocini and it's an

940
00:42:02,400 --> 00:42:05,520
incremental proof of sequential work for

941
00:42:05,520 --> 00:42:09,259
General weight distributions

942
00:42:09,599 --> 00:42:11,839
foreign

943
00:42:15,859 --> 00:42:19,619
so this is Joint work with Valero Cheney

944
00:42:19,619 --> 00:42:21,119
um the outline of my talk will be

945
00:42:21,119 --> 00:42:22,500
roughly the following I will give

946
00:42:22,500 --> 00:42:24,300
definitions for booster sequential work

947
00:42:24,300 --> 00:42:26,820
schemes in the Standalone setting and

948
00:42:26,820 --> 00:42:28,619
then give you an instantiation based on

949
00:42:28,619 --> 00:42:32,880
the skip list construction graph then we

950
00:42:32,880 --> 00:42:35,460
move on to definition of incremental

951
00:42:35,460 --> 00:42:37,440
proof of sequential work schemes and I

952
00:42:37,440 --> 00:42:39,359
give you and show you how to make this

953
00:42:39,359 --> 00:42:40,680
construction the skip this construction

954
00:42:40,680 --> 00:42:43,740
incremental and then we show how to

955
00:42:43,740 --> 00:42:45,720
generalize this incremental scheme to

956
00:42:45,720 --> 00:42:47,940
work for General weight distributions

957
00:42:47,940 --> 00:42:50,040
these are motivated by blockchain

958
00:42:50,040 --> 00:42:52,079
applications

959
00:42:52,079 --> 00:42:54,780
all constructions that I deal with are

960
00:42:54,780 --> 00:42:58,280
in the random Oracle model okay

961
00:42:58,500 --> 00:43:00,119
what is the proof of sequential work

962
00:43:00,119 --> 00:43:01,440
scheme it's an interactive protocol

963
00:43:01,440 --> 00:43:04,260
between a program verifier when the

964
00:43:04,260 --> 00:43:07,079
brewva does n-sequential steps in

965
00:43:07,079 --> 00:43:09,119
sequential queries to its Oracle Tau

966
00:43:09,119 --> 00:43:10,740
think of the Oracle Tower as a random

967
00:43:10,740 --> 00:43:13,520
Oracle then it makes the verify accept

968
00:43:13,520 --> 00:43:16,560
and to make things more interesting we

969
00:43:16,560 --> 00:43:18,420
the proof should be succinct and should

970
00:43:18,420 --> 00:43:20,339
verify fast otherwise it would be

971
00:43:20,339 --> 00:43:21,599
trivial

972
00:43:21,599 --> 00:43:24,480
soundness says that a malicious prover

973
00:43:24,480 --> 00:43:26,940
that does at most alpha n sequential

974
00:43:26,940 --> 00:43:30,119
queries Alpha fraction a fraction Alpha

975
00:43:30,119 --> 00:43:32,400
of the sequential queries will make the

976
00:43:32,400 --> 00:43:34,380
verifier reject accept only with

977
00:43:34,380 --> 00:43:36,720
probability Epsilon even if it has

978
00:43:36,720 --> 00:43:38,880
massive amount of parallelism so you

979
00:43:38,880 --> 00:43:40,619
have to do the work sequentially if you

980
00:43:40,619 --> 00:43:42,359
have any hope to convince the verifier

981
00:43:42,359 --> 00:43:45,000
okay all proofs of sequential work

982
00:43:45,000 --> 00:43:48,720
schemes look the same they are

983
00:43:48,720 --> 00:43:50,640
parameterized by a graph and another

984
00:43:50,640 --> 00:43:54,540
parameter T the verifier sends Akai to

985
00:43:54,540 --> 00:43:57,180
the proverb that approver uses to solve

986
00:43:57,180 --> 00:44:00,060
its random Oracle and then use the

987
00:44:00,060 --> 00:44:02,099
random Oracle The Salted random Oracle

988
00:44:02,099 --> 00:44:03,900
to compute the labeling of the graph in

989
00:44:03,900 --> 00:44:06,119
topological order and the label of the

990
00:44:06,119 --> 00:44:08,760
ith node is the Oracle applied to the

991
00:44:08,760 --> 00:44:11,760
ith index and the level of its parents

992
00:44:11,760 --> 00:44:14,280
once the proverb does this it sends the

993
00:44:14,280 --> 00:44:16,560
label of the sink of the graph to the

994
00:44:16,560 --> 00:44:18,800
verifier it's

995
00:44:18,800 --> 00:44:22,140
sorry this functions as a commitment to

996
00:44:22,140 --> 00:44:24,240
the labels and then they engage in a

997
00:44:24,240 --> 00:44:26,520
challenge response phase after which the

998
00:44:26,520 --> 00:44:28,800
verifier accepts or rejects

999
00:44:28,800 --> 00:44:31,740
concretely the skip the skip list proof

1000
00:44:31,740 --> 00:44:34,079
of sequential work scheme works like

1001
00:44:34,079 --> 00:44:36,540
this you have a skip this graph and now

1002
00:44:36,540 --> 00:44:38,460
we instantiate the challenge response

1003
00:44:38,460 --> 00:44:40,440
phase so assume you have a challenge

1004
00:44:40,440 --> 00:44:43,500
five what the approva does it locates

1005
00:44:43,500 --> 00:44:45,599
the shortest path that goes from the

1006
00:44:45,599 --> 00:44:47,819
source to the sink and pass it and

1007
00:44:47,819 --> 00:44:50,460
passes through five and then it sends to

1008
00:44:50,460 --> 00:44:53,160
the verifier the labels on this on this

1009
00:44:53,160 --> 00:44:56,460
path and the labels of its parents

1010
00:44:56,460 --> 00:44:59,460
the verifier does this T many times and

1011
00:44:59,460 --> 00:45:02,040
it accepts if the if the labeling is

1012
00:45:02,040 --> 00:45:03,660
consistent

1013
00:45:03,660 --> 00:45:06,900
it is instructive to say that that even

1014
00:45:06,900 --> 00:45:08,579
though it looks in this example that the

1015
00:45:08,579 --> 00:45:11,040
Prova since the entire graph this is the

1016
00:45:11,040 --> 00:45:13,020
short this is a short example so

1017
00:45:13,020 --> 00:45:15,780
asymptotically this is uh this achieves

1018
00:45:15,780 --> 00:45:18,480
succinctness because the the shortest

1019
00:45:18,480 --> 00:45:21,599
path is of logarithmic length and the in

1020
00:45:21,599 --> 00:45:23,640
degree of the graph is logarithmic so

1021
00:45:23,640 --> 00:45:26,339
all things check out to give you a test

1022
00:45:26,339 --> 00:45:28,260
of what the probability is of the

1023
00:45:28,260 --> 00:45:30,000
malicious prover the malicious proof

1024
00:45:30,000 --> 00:45:33,180
that does alpha and sequential queries

1025
00:45:33,180 --> 00:45:36,420
will succeed and in total does q queries

1026
00:45:36,420 --> 00:45:38,280
to the Oracle will succeed in in

1027
00:45:38,280 --> 00:45:39,960
convincing the verifier with this blue

1028
00:45:39,960 --> 00:45:41,940
probability which is Alpha to the power

1029
00:45:41,940 --> 00:45:44,640
of t plus some probability that amounts

1030
00:45:44,640 --> 00:45:45,900
to finding collisions in the random

1031
00:45:45,900 --> 00:45:46,859
Oracle

1032
00:45:46,859 --> 00:45:48,839
this is also I wanted to show you how

1033
00:45:48,839 --> 00:45:50,640
the tea Blends into this probability and

1034
00:45:50,640 --> 00:45:52,140
the efficiency okay

1035
00:45:52,140 --> 00:45:55,680
all this is uh known now I want to show

1036
00:45:55,680 --> 00:45:57,960
we want to move to the incremental world

1037
00:45:57,960 --> 00:45:59,940
and before that I want to show you the

1038
00:45:59,940 --> 00:46:02,099
limitations of these existing proof of

1039
00:46:02,099 --> 00:46:03,359
sequence of our schemes what I call

1040
00:46:03,359 --> 00:46:05,520
Standalone proof sequential work schemes

1041
00:46:05,520 --> 00:46:07,560
the approva has actually two extreme

1042
00:46:07,560 --> 00:46:08,819
strategies

1043
00:46:08,819 --> 00:46:10,619
either it stores the labels of the

1044
00:46:10,619 --> 00:46:13,140
entire graph and then it expand it

1045
00:46:13,140 --> 00:46:15,359
expands no extra computation to answer

1046
00:46:15,359 --> 00:46:18,780
challenges or it stores nothing and it

1047
00:46:18,780 --> 00:46:20,579
has to do in the worst case in

1048
00:46:20,579 --> 00:46:22,800
sequential steps extra and sequential

1049
00:46:22,800 --> 00:46:24,900
steps to answer the challenges

1050
00:46:24,900 --> 00:46:27,359
but luckily there is a space-time

1051
00:46:27,359 --> 00:46:29,579
trade-off that was known for the CP

1052
00:46:29,579 --> 00:46:32,099
graph and the left and we show the same

1053
00:46:32,099 --> 00:46:34,440
hold also for the skip list and this

1054
00:46:34,440 --> 00:46:36,000
shows like roughly speaking for an

1055
00:46:36,000 --> 00:46:38,339
example here the brewvacan store say

1056
00:46:38,339 --> 00:46:41,280
square root of n labels and and then can

1057
00:46:41,280 --> 00:46:42,960
answer challenges with an extra square

1058
00:46:42,960 --> 00:46:45,000
root of n-sequential work

1059
00:46:45,000 --> 00:46:46,680
but can we do better

1060
00:46:46,680 --> 00:46:48,660
can we get the best of both worlds

1061
00:46:48,660 --> 00:46:50,760
meaning that the approva

1062
00:46:50,760 --> 00:46:53,160
does n sequential steps stores

1063
00:46:53,160 --> 00:46:55,859
essentially nothing a succinct State and

1064
00:46:55,859 --> 00:46:57,900
requires no extra computation to answer

1065
00:46:57,900 --> 00:47:00,359
its challenges this is where incremental

1066
00:47:00,359 --> 00:47:03,060
proofs of sequential work come come in

1067
00:47:03,060 --> 00:47:04,980
handy these are defined and

1068
00:47:04,980 --> 00:47:06,960
interactively right away

1069
00:47:06,960 --> 00:47:09,599
uh the Brewer and the verifier uh form

1070
00:47:09,599 --> 00:47:11,520
uh proof of sequential work scheme

1071
00:47:11,520 --> 00:47:13,680
complete sound that's unsuccinct and we

1072
00:47:13,680 --> 00:47:15,540
have an extra algorithm increment

1073
00:47:15,540 --> 00:47:18,300
algorithm the increment algorithm once

1074
00:47:18,300 --> 00:47:21,180
it receives here a proof for parameter

1075
00:47:21,180 --> 00:47:24,420
N1 and another parameter in two it

1076
00:47:24,420 --> 00:47:27,300
generates it increments the proof by

1077
00:47:27,300 --> 00:47:30,599
doing N2 sequential computation and

1078
00:47:30,599 --> 00:47:33,599
provides a proof for N1 plus N2 in

1079
00:47:33,599 --> 00:47:35,640
particular this proof generation is

1080
00:47:35,640 --> 00:47:37,920
independent of N1 should only depend on

1081
00:47:37,920 --> 00:47:39,119
N2

1082
00:47:39,119 --> 00:47:41,339
and this should succeed with the the

1083
00:47:41,339 --> 00:47:43,560
prover the the initial proof that it was

1084
00:47:43,560 --> 00:47:46,920
given was computed honestly or

1085
00:47:46,920 --> 00:47:48,660
maliciously as long as it's an accepting

1086
00:47:48,660 --> 00:47:51,180
proof it should be able to be to to

1087
00:47:51,180 --> 00:47:52,740
increment it this is important in

1088
00:47:52,740 --> 00:47:54,780
distributed applications where maybe one

1089
00:47:54,780 --> 00:47:56,339
party is doing the part of the

1090
00:47:56,339 --> 00:47:58,020
computation and the other party wants to

1091
00:47:58,020 --> 00:47:59,940
to increment it

1092
00:47:59,940 --> 00:48:03,660
and this should hold succinctness should

1093
00:48:03,660 --> 00:48:05,579
hold no matter how many incrementation

1094
00:48:05,579 --> 00:48:08,760
uh for arbitrary many incrementation

1095
00:48:08,760 --> 00:48:10,980
okay the proof should still be success

1096
00:48:10,980 --> 00:48:12,960
otherwise you can concatenate proofs and

1097
00:48:12,960 --> 00:48:14,880
everything is Trivial and meaningless

1098
00:48:14,880 --> 00:48:17,780
cool so

1099
00:48:17,780 --> 00:48:20,940
who introduced the notion also gave a

1100
00:48:20,940 --> 00:48:23,460
construction based on the CP graph the

1101
00:48:23,460 --> 00:48:25,500
CPA proof of sequel shower scheme by

1102
00:48:25,500 --> 00:48:26,700
devising

1103
00:48:26,700 --> 00:48:29,160
um a need on the Fly sampling technique

1104
00:48:29,160 --> 00:48:31,619
their construction incurs an extra

1105
00:48:31,619 --> 00:48:34,319
security loss but not much so it's good

1106
00:48:34,319 --> 00:48:36,060
then we achieve the same the same thing

1107
00:48:36,060 --> 00:48:38,220
so what we do here in this work we show

1108
00:48:38,220 --> 00:48:40,020
that the same thing can be achieved for

1109
00:48:40,020 --> 00:48:41,940
the skip this graph

1110
00:48:41,940 --> 00:48:44,880
cool by applying the same technique and

1111
00:48:44,880 --> 00:48:47,220
reaching the same conclusions but what

1112
00:48:47,220 --> 00:48:48,780
we actually do and the motivation of

1113
00:48:48,780 --> 00:48:50,579
this work is to generalize this

1114
00:48:50,579 --> 00:48:52,260
incremental proof sequential work scheme

1115
00:48:52,260 --> 00:48:54,140
to work for General weight distributions

1116
00:48:54,140 --> 00:48:56,760
because this gave us interesting

1117
00:48:56,760 --> 00:48:58,859
applications in blockchains and for this

1118
00:48:58,859 --> 00:49:00,780
we need to devise a new variant of the

1119
00:49:00,780 --> 00:49:04,020
underfly sampling technique and modify

1120
00:49:04,020 --> 00:49:05,819
the protocol a bit to be able to prove

1121
00:49:05,819 --> 00:49:06,720
security

1122
00:49:06,720 --> 00:49:11,299
so let's get into these two two steps

1123
00:49:15,240 --> 00:49:18,060
so here's the the Standalone incremental

1124
00:49:18,060 --> 00:49:20,400
proof sequencer scheme so for T is equal

1125
00:49:20,400 --> 00:49:22,800
to four what the brewva does it computes

1126
00:49:22,800 --> 00:49:25,500
it labels the first two consecutive sets

1127
00:49:25,500 --> 00:49:27,240
of size four

1128
00:49:27,240 --> 00:49:29,400
and then what it does it wants to

1129
00:49:29,400 --> 00:49:31,920
generate a subset now it uses the

1130
00:49:31,920 --> 00:49:34,859
randomness of the sync to select a

1131
00:49:34,859 --> 00:49:37,079
random subset of size T from these two

1132
00:49:37,079 --> 00:49:39,000
subsets

1133
00:49:39,000 --> 00:49:42,119
all good so it shows this random subset

1134
00:49:42,119 --> 00:49:44,339
and what it stores it stores proofs for

1135
00:49:44,339 --> 00:49:46,859
these challenges in particular whatever

1136
00:49:46,859 --> 00:49:49,440
was not chosen and the set will never be

1137
00:49:49,440 --> 00:49:50,880
part of the challenge the final

1138
00:49:50,880 --> 00:49:54,839
challenge of the proverb okay and it's

1139
00:49:54,839 --> 00:49:57,420
it's worth noting that the the approver

1140
00:49:57,420 --> 00:49:59,819
can actually generate these proofs

1141
00:49:59,819 --> 00:50:02,280
because in the previous step it had all

1142
00:50:02,280 --> 00:50:03,720
the labels of the graph so it can

1143
00:50:03,720 --> 00:50:05,280
generate the proofs okay this is

1144
00:50:05,280 --> 00:50:07,440
important to keep keep in mind for

1145
00:50:07,440 --> 00:50:09,480
example for the challenge Pi one will be

1146
00:50:09,480 --> 00:50:11,400
the path that passes through one from

1147
00:50:11,400 --> 00:50:13,140
the source to the sink in in the in the

1148
00:50:13,140 --> 00:50:15,839
lift graph and and its parents I'm

1149
00:50:15,839 --> 00:50:17,520
dropping the parents for the sake of

1150
00:50:17,520 --> 00:50:20,760
illustration the same we do on the right

1151
00:50:20,760 --> 00:50:23,640
side and we have these two sets and now

1152
00:50:23,640 --> 00:50:25,920
we want to select again a set of size

1153
00:50:25,920 --> 00:50:28,440
four a random set of size four from

1154
00:50:28,440 --> 00:50:30,540
these two subsets we use the randomness

1155
00:50:30,540 --> 00:50:33,900
of of the sink and we do that well

1156
00:50:33,900 --> 00:50:35,700
that's fine but the thing that doesn't

1157
00:50:35,700 --> 00:50:37,859
follow trivially is that we need to form

1158
00:50:37,859 --> 00:50:39,660
to kind of we have proofs on the left

1159
00:50:39,660 --> 00:50:41,520
side and Bruce on the right side and we

1160
00:50:41,520 --> 00:50:44,099
need to generate proofs in the big graph

1161
00:50:44,099 --> 00:50:46,619
okay but this is thanks to the graph

1162
00:50:46,619 --> 00:50:48,599
structure of this graph this is doable

1163
00:50:48,599 --> 00:50:51,000
so assume that you have Pi one you were

1164
00:50:51,000 --> 00:50:54,059
giving this from the left set and you

1165
00:50:54,059 --> 00:50:55,859
want to extend it to a proof in the

1166
00:50:55,859 --> 00:50:58,619
larger graph all what you really need is

1167
00:50:58,619 --> 00:51:01,079
this extra Edge because this will be the

1168
00:51:01,079 --> 00:51:02,880
shortest path in in the largest in the

1169
00:51:02,880 --> 00:51:05,460
large graph and thanks to the proofs on

1170
00:51:05,460 --> 00:51:07,680
the right side they all pass through the

1171
00:51:07,680 --> 00:51:10,079
sync by definition they will contain

1172
00:51:10,079 --> 00:51:12,480
this extra Edge so a proof can actually

1173
00:51:12,480 --> 00:51:15,180
be be extended from the smaller lift

1174
00:51:15,180 --> 00:51:17,040
graph to the bigger graph and by

1175
00:51:17,040 --> 00:51:19,380
symmetry you can do this for for the

1176
00:51:19,380 --> 00:51:22,260
right graph so the approver can can do

1177
00:51:22,260 --> 00:51:23,700
the sampling and compute the proofs

1178
00:51:23,700 --> 00:51:25,460
everything checks out

1179
00:51:25,460 --> 00:51:28,079
the increment algorithm works exactly

1180
00:51:28,079 --> 00:51:30,420
like the honest prover so nothing needs

1181
00:51:30,420 --> 00:51:32,940
to be said about it but the verifier is

1182
00:51:32,940 --> 00:51:35,640
now having a more challenging task so it

1183
00:51:35,640 --> 00:51:38,940
it will be served uh say here T proofs

1184
00:51:38,940 --> 00:51:41,400
for proofs it look it looks at each one

1185
00:51:41,400 --> 00:51:43,680
individually and each one of them should

1186
00:51:43,680 --> 00:51:45,720
verify according to the Standalone proof

1187
00:51:45,720 --> 00:51:46,980
of sequential work scheme so the

1188
00:51:46,980 --> 00:51:48,420
consistency of the labels on the

1189
00:51:48,420 --> 00:51:50,099
shortest path should should be should be

1190
00:51:50,099 --> 00:51:53,460
met but it also has to to verify that

1191
00:51:53,460 --> 00:51:55,859
these challenges were actually cons are

1192
00:51:55,859 --> 00:51:57,480
consistent with the underfly sampling

1193
00:51:57,480 --> 00:51:58,800
technique

1194
00:51:58,800 --> 00:52:00,960
for this the approver will generate an

1195
00:52:00,960 --> 00:52:03,119
extra index set and then the verifier

1196
00:52:03,119 --> 00:52:05,220
can recursively

1197
00:52:05,220 --> 00:52:06,059
um

1198
00:52:06,059 --> 00:52:10,140
check these on the Fly samplings it's a

1199
00:52:10,140 --> 00:52:11,640
bit more detailed but doesn't have extra

1200
00:52:11,640 --> 00:52:13,740
information but what I want to highlight

1201
00:52:13,740 --> 00:52:16,800
is that at each step of the verification

1202
00:52:16,800 --> 00:52:19,619
the verifier knows all these left and

1203
00:52:19,619 --> 00:52:21,780
right sets from which we assembled a

1204
00:52:21,780 --> 00:52:24,420
smaller set they were implicitly defined

1205
00:52:24,420 --> 00:52:27,780
and they're always of size T exactly t

1206
00:52:27,780 --> 00:52:29,700
this will not be the case when we move

1207
00:52:29,700 --> 00:52:31,500
to General word distributions these

1208
00:52:31,500 --> 00:52:33,540
things will be an expectation and this

1209
00:52:33,540 --> 00:52:35,400
will will could potentially give a

1210
00:52:35,400 --> 00:52:37,859
malicious proof a chance to to cheat and

1211
00:52:37,859 --> 00:52:40,020
we need to deal with that

1212
00:52:40,020 --> 00:52:41,940
um soundness of the whole protocol will

1213
00:52:41,940 --> 00:52:43,859
follow in in a modular way you first

1214
00:52:43,859 --> 00:52:45,599
found the advantage of the underfly

1215
00:52:45,599 --> 00:52:48,660
sampling and then you reduce security to

1216
00:52:48,660 --> 00:52:50,099
the Standalone proof of signature work

1217
00:52:50,099 --> 00:52:51,960
scheme why we need to think about this

1218
00:52:51,960 --> 00:52:54,599
like like remember the the approval when

1219
00:52:54,599 --> 00:52:56,460
it was Computing at some point in the

1220
00:52:56,460 --> 00:52:58,079
computation it knew that it will never

1221
00:52:58,079 --> 00:53:00,420
be challenged on some of the vertices

1222
00:53:00,420 --> 00:53:02,640
could this give the approval extra power

1223
00:53:02,640 --> 00:53:05,520
or not one has to analyze that okay the

1224
00:53:05,520 --> 00:53:07,619
analysis will be like like on a high

1225
00:53:07,619 --> 00:53:09,119
level what you need to prove is a limit

1226
00:53:09,119 --> 00:53:12,839
like like this is saying that well if if

1227
00:53:12,839 --> 00:53:15,440
a Rover has a fraction of inconsistent

1228
00:53:15,440 --> 00:53:17,760
nodes these are the nodes that it will

1229
00:53:17,760 --> 00:53:20,599
not be able to convince the verifier

1230
00:53:20,599 --> 00:53:24,000
then this fraction will not be that much

1231
00:53:24,000 --> 00:53:26,880
that much different if the verifier

1232
00:53:26,880 --> 00:53:29,460
chose the challenges in one shot or if

1233
00:53:29,460 --> 00:53:31,079
it shows them according to the underfly

1234
00:53:31,079 --> 00:53:32,940
sampling will be the fraction will be

1235
00:53:32,940 --> 00:53:36,660
close okay and this can be proven very

1236
00:53:36,660 --> 00:53:39,119
simply from a hufting bound and this was

1237
00:53:39,119 --> 00:53:40,800
also done in previous work and we

1238
00:53:40,800 --> 00:53:42,660
applied the same and things will check

1239
00:53:42,660 --> 00:53:45,540
out this comes at an extra slight cost

1240
00:53:45,540 --> 00:53:49,740
of um in the success probability so in

1241
00:53:49,740 --> 00:53:52,440
the previous case we had this bound

1242
00:53:52,440 --> 00:53:54,599
below and say that the blue the the

1243
00:53:54,599 --> 00:53:56,420
black

1244
00:53:56,420 --> 00:53:59,339
summons they are almost the same and we

1245
00:53:59,339 --> 00:54:01,559
can compare the blue ones what is

1246
00:54:01,559 --> 00:54:03,540
different in this new technique it adds

1247
00:54:03,540 --> 00:54:06,540
this log n factor that is squared in the

1248
00:54:06,540 --> 00:54:09,420
in the exponent of e this seems inherent

1249
00:54:09,420 --> 00:54:11,339
to the to the churn of bound the way

1250
00:54:11,339 --> 00:54:13,020
that you apply it at the bound it would

1251
00:54:13,020 --> 00:54:14,940
be nice if one can remove it but this

1252
00:54:14,940 --> 00:54:16,920
was in previous work and we inherited

1253
00:54:16,920 --> 00:54:19,559
because of the technique

1254
00:54:19,559 --> 00:54:22,260
okay now the the interesting case is

1255
00:54:22,260 --> 00:54:24,300
that the general weight distributions

1256
00:54:24,300 --> 00:54:26,640
um maybe I can skip this slide and go

1257
00:54:26,640 --> 00:54:29,160
right away to this in some applications

1258
00:54:29,160 --> 00:54:31,260
in the blockchain

1259
00:54:31,260 --> 00:54:33,720
where you use proof of sequential work

1260
00:54:33,720 --> 00:54:36,180
schemes to to solve some problems in

1261
00:54:36,180 --> 00:54:38,700
light client bootstrapping for example

1262
00:54:38,700 --> 00:54:41,640
in a paper that we had on an Azure Crypt

1263
00:54:41,640 --> 00:54:43,440
called snacks which are succinct and

1264
00:54:43,440 --> 00:54:44,760
interactive arguments of shared

1265
00:54:44,760 --> 00:54:45,800
knowledge

1266
00:54:45,800 --> 00:54:48,359
somehow you the verifier needs to be

1267
00:54:48,359 --> 00:54:50,460
able to challenge the approver on on

1268
00:54:50,460 --> 00:54:53,220
nodes but not all nodes are equal you

1269
00:54:53,220 --> 00:54:55,740
need to be able to to challenge on nodes

1270
00:54:55,740 --> 00:54:58,079
close to the tip of the chain with

1271
00:54:58,079 --> 00:55:00,240
higher probability than nodes deep in

1272
00:55:00,240 --> 00:55:01,500
the chain

1273
00:55:01,500 --> 00:55:03,900
so that's not a uniform distribution but

1274
00:55:03,900 --> 00:55:06,300
it looks like this so each each node

1275
00:55:06,300 --> 00:55:08,220
will have a weight and the sum of the

1276
00:55:08,220 --> 00:55:10,200
weights will be one so it kind of

1277
00:55:10,200 --> 00:55:12,420
reflects the the challenge distribution

1278
00:55:12,420 --> 00:55:15,660
and we want to our incremental algorithm

1279
00:55:15,660 --> 00:55:17,400
to work with this distribution for

1280
00:55:17,400 --> 00:55:18,780
example

1281
00:55:18,780 --> 00:55:20,880
how do we do this here we have to change

1282
00:55:20,880 --> 00:55:23,460
the underfly sampling a bit so okay we

1283
00:55:23,460 --> 00:55:25,260
have this distribution we computed the

1284
00:55:25,260 --> 00:55:28,260
first four uh the first two sets now I'm

1285
00:55:28,260 --> 00:55:30,059
showing only the line not the entire

1286
00:55:30,059 --> 00:55:31,319
graph because otherwise it would be

1287
00:55:31,319 --> 00:55:33,000
messy so imagine this is a skip this

1288
00:55:33,000 --> 00:55:36,839
graph so you add to your subset a node

1289
00:55:36,839 --> 00:55:38,760
you look at a node and with probability

1290
00:55:38,760 --> 00:55:41,160
that is proportional to its weight T

1291
00:55:41,160 --> 00:55:43,260
times its weight you add it to the set

1292
00:55:43,260 --> 00:55:46,020
with this probability okay and we do

1293
00:55:46,020 --> 00:55:47,640
this because and you look in the next

1294
00:55:47,640 --> 00:55:50,460
node and so on and you do this because

1295
00:55:50,460 --> 00:55:52,440
you want in the end you you want to get

1296
00:55:52,440 --> 00:55:55,260
some that the sample subset is of size T

1297
00:55:55,260 --> 00:55:58,020
but here an expectation okay

1298
00:55:58,020 --> 00:56:01,260
you do this also on the right side we

1299
00:56:01,260 --> 00:56:02,880
can we know that these proofs can be

1300
00:56:02,880 --> 00:56:04,619
merged for the skip this graph easily so

1301
00:56:04,619 --> 00:56:06,480
there's no issue and now we want to

1302
00:56:06,480 --> 00:56:09,180
sample from the bigger graph and luckily

1303
00:56:09,180 --> 00:56:11,099
we can do this because this kind of the

1304
00:56:11,099 --> 00:56:14,339
blue the the distribution the curve for

1305
00:56:14,339 --> 00:56:17,760
the larger graph is lying below these

1306
00:56:17,760 --> 00:56:20,819
two two two curves which means that we

1307
00:56:20,819 --> 00:56:23,760
have enough probability Mass to resample

1308
00:56:23,760 --> 00:56:25,559
um but you can imagine if you have

1309
00:56:25,559 --> 00:56:27,740
different distributions say the the

1310
00:56:27,740 --> 00:56:30,119
gaussian distribution then this will not

1311
00:56:30,119 --> 00:56:32,579
be incrementable so we characterize

1312
00:56:32,579 --> 00:56:33,960
these distributions that can be

1313
00:56:33,960 --> 00:56:35,640
incremented in this way and we call them

1314
00:56:35,640 --> 00:56:37,980
T incrementally assemble distributions a

1315
00:56:37,980 --> 00:56:40,440
very simple definition and then we show

1316
00:56:40,440 --> 00:56:42,480
that for any such distribution the skip

1317
00:56:42,480 --> 00:56:46,319
this construction is is incremental that

1318
00:56:46,319 --> 00:56:47,880
covers of course the snack distribution

1319
00:56:47,880 --> 00:56:49,859
and the uniform distribution which shows

1320
00:56:49,859 --> 00:56:51,420
that the technique is the generalization

1321
00:56:51,420 --> 00:56:54,059
of the existing technique but new

1322
00:56:54,059 --> 00:56:55,619
challenges we need to resolve new

1323
00:56:55,619 --> 00:56:58,020
challenges the challenges come precise

1324
00:56:58,020 --> 00:57:00,180
because in the Standalone case the

1325
00:57:00,180 --> 00:57:01,619
sampling sets are already always

1326
00:57:01,619 --> 00:57:04,859
implicitly defined and are of size T why

1327
00:57:04,859 --> 00:57:08,700
in our case things are an expectation

1328
00:57:08,700 --> 00:57:11,700
and because of that we we need to first

1329
00:57:11,700 --> 00:57:14,160
to give these sets we we modify the

1330
00:57:14,160 --> 00:57:16,680
protocol a bit and we make the approva

1331
00:57:16,680 --> 00:57:20,099
first commit to this sampling sets in a

1332
00:57:20,099 --> 00:57:22,079
tree-like fashion

1333
00:57:22,079 --> 00:57:24,000
and then we whenever the roofer is

1334
00:57:24,000 --> 00:57:26,099
giving a proof it has to provide these

1335
00:57:26,099 --> 00:57:28,740
sampling sets that relate to this proof

1336
00:57:28,740 --> 00:57:31,140
uh explicitly and these will be an

1337
00:57:31,140 --> 00:57:33,119
opening in this Merkel tree

1338
00:57:33,119 --> 00:57:35,460
which will add to the size of the proof

1339
00:57:35,460 --> 00:57:38,760
but still efficient and then hopefully

1340
00:57:38,760 --> 00:57:40,200
the verifier will essentially

1341
00:57:40,200 --> 00:57:42,240
recursively be able to check the

1342
00:57:42,240 --> 00:57:44,280
consistency of this sampling it has to

1343
00:57:44,280 --> 00:57:46,440
do an extra extra checks related to that

1344
00:57:46,440 --> 00:57:50,220
these sets are are you know their size

1345
00:57:50,220 --> 00:57:51,660
does not deviate that much from the

1346
00:57:51,660 --> 00:57:53,579
expectation and so on

1347
00:57:53,579 --> 00:57:56,280
uh all I'm almost concluding so the

1348
00:57:56,280 --> 00:57:58,920
sound is now we need to bound the

1349
00:57:58,920 --> 00:58:00,720
advantage of this malicious proof

1350
00:58:00,720 --> 00:58:02,220
because now the malicious approver could

1351
00:58:02,220 --> 00:58:04,800
choose these seats in maliciously could

1352
00:58:04,800 --> 00:58:06,599
drop some elements from them because

1353
00:58:06,599 --> 00:58:08,280
they're not of size T exactly an

1354
00:58:08,280 --> 00:58:09,780
expectation so you could probably cheat

1355
00:58:09,780 --> 00:58:12,000
a bit here and there so you want to make

1356
00:58:12,000 --> 00:58:13,200
sure that this does not give the

1357
00:58:13,200 --> 00:58:14,460
adversary

1358
00:58:14,460 --> 00:58:18,660
um much uh much advantage and then we

1359
00:58:18,660 --> 00:58:20,280
need to generalize the underfly sampling

1360
00:58:20,280 --> 00:58:23,339
to work for these uh T incrementary Sam

1361
00:58:23,339 --> 00:58:24,960
level distributions and then we can

1362
00:58:24,960 --> 00:58:27,000
reduce security to the underlying group

1363
00:58:27,000 --> 00:58:28,800
of sequential work scheme in the Bible

1364
00:58:28,800 --> 00:58:30,359
we give bounds for any such

1365
00:58:30,359 --> 00:58:32,160
distributions and we give concrete

1366
00:58:32,160 --> 00:58:34,619
bounds for the uniform distribution and

1367
00:58:34,619 --> 00:58:37,740
the snack distribution and I will stop

1368
00:58:37,740 --> 00:58:39,420
here I have extra slides by the way

1369
00:58:39,420 --> 00:58:41,040
maybe if you have a question I have some

1370
00:58:41,040 --> 00:58:42,780
slides already already thank you very

1371
00:58:42,780 --> 00:58:44,960
much

1372
00:58:46,470 --> 00:58:47,940
[Applause]

1373
00:58:47,940 --> 00:58:50,460
thank you for the nice talk Hamza other

1374
00:58:50,460 --> 00:58:53,720
questions from the audience

1375
00:58:54,900 --> 00:58:56,960
um

1376
00:59:00,020 --> 00:59:02,819
thanks for the nice talk just a quick

1377
00:59:02,819 --> 00:59:05,700
question about uh you mentioned that the

1378
00:59:05,700 --> 00:59:07,440
security is analyzed in the random

1379
00:59:07,440 --> 00:59:10,380
Oracle model is it also analyzed in the

1380
00:59:10,380 --> 00:59:13,380
quantum random Oracle model

1381
00:59:13,380 --> 00:59:15,780
good question I don't know no it's not

1382
00:59:15,780 --> 00:59:17,460
but uh but this proof of sequential

1383
00:59:17,460 --> 00:59:19,920
schemes there is work on on them in the

1384
00:59:19,920 --> 00:59:22,500
quantum run worker model but this work

1385
00:59:22,500 --> 00:59:24,119
does not deal with that

1386
00:59:24,119 --> 00:59:27,559
okay thank you sure

1387
00:59:29,700 --> 00:59:31,740
okay if there are no more questions I

1388
00:59:31,740 --> 00:59:34,980
think we need to change back thank you

1389
00:59:34,980 --> 00:59:36,990
and it's over

1390
00:59:36,990 --> 00:59:42,250
[Applause]

