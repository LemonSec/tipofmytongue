1
00:00:00,000 --> 00:00:02,639
welcome to the uh second session of

2
00:00:02,639 --> 00:00:04,080
today or in the first session on

3
00:00:04,080 --> 00:00:06,600
oblivious data access

4
00:00:06,600 --> 00:00:09,300
um before we start the ramp session

5
00:00:09,300 --> 00:00:11,700
chairs would like to remind you

6
00:00:11,700 --> 00:00:13,440
that the deadline for the wrong session

7
00:00:13,440 --> 00:00:18,180
submissions is at 1pm so submit your uh

8
00:00:18,180 --> 00:00:21,720
best talks announcement for jobs or

9
00:00:21,720 --> 00:00:24,900
whatever you like until 1pm and to

10
00:00:24,900 --> 00:00:28,380
finish your slides until finishing sites

11
00:00:28,380 --> 00:00:30,300
in the lunch break because now we have

12
00:00:30,300 --> 00:00:32,220
to of course listen to all these great

13
00:00:32,220 --> 00:00:34,260
talks that will be in this session

14
00:00:34,260 --> 00:00:36,660
and the first thought is going to be

15
00:00:36,660 --> 00:00:38,399
about optimal single server private

16
00:00:38,399 --> 00:00:41,059
information retrieval by Ming Jun Zhu

17
00:00:41,059 --> 00:00:46,680
waikai Lynn Janice and elij and Zhu is

18
00:00:46,680 --> 00:00:49,460
going to give the token

19
00:00:53,520 --> 00:00:55,260
um thanks for the introduction

20
00:00:55,260 --> 00:00:57,539
um I'm missing Joe I'm a third year PhD

21
00:00:57,539 --> 00:01:00,600
at CNU this is a joint work with Ricky

22
00:01:00,600 --> 00:01:03,359
Lane Giannis Elaine and today I'm going

23
00:01:03,359 --> 00:01:05,099
to talk about optimal single server

24
00:01:05,099 --> 00:01:09,000
private information retrieval

25
00:01:09,000 --> 00:01:11,760
so PIR private information retrievable

26
00:01:11,760 --> 00:01:14,520
is stands for public database and

27
00:01:14,520 --> 00:01:16,860
private query imagine that there is a

28
00:01:16,860 --> 00:01:19,200
client and a server and the server

29
00:01:19,200 --> 00:01:21,540
stores a database of size n

30
00:01:21,540 --> 00:01:24,119
and now the client wants to know for

31
00:01:24,119 --> 00:01:26,700
some particular index what they what is

32
00:01:26,700 --> 00:01:29,580
PBX that means the value at the location

33
00:01:29,580 --> 00:01:30,720
takes

34
00:01:30,720 --> 00:01:33,659
and the Privacy requirement says that

35
00:01:33,659 --> 00:01:36,479
the server cannot tell what exactly is

36
00:01:36,479 --> 00:01:39,780
the client's query X

37
00:01:39,780 --> 00:01:42,060
there are many applications to this

38
00:01:42,060 --> 00:01:43,680
primitive for example you can build

39
00:01:43,680 --> 00:01:46,560
private DNS based on PIR you can also

40
00:01:46,560 --> 00:01:49,380
build safe browsing or private contact

41
00:01:49,380 --> 00:01:51,299
Discovery and there are many other

42
00:01:51,299 --> 00:01:54,299
applications

43
00:01:54,780 --> 00:01:58,920
in the classical model of PIR there's no

44
00:01:58,920 --> 00:02:00,720
pre-processing and we require the

45
00:02:00,720 --> 00:02:03,240
servers to store the database in plain

46
00:02:03,240 --> 00:02:06,119
text so for example if every location

47
00:02:06,119 --> 00:02:08,940
Only Stores a bit then the server simply

48
00:02:08,940 --> 00:02:10,860
stores an entry

49
00:02:10,860 --> 00:02:13,819
using whole fully homomorphic encryption

50
00:02:13,819 --> 00:02:16,560
the best game can achieve poly lock

51
00:02:16,560 --> 00:02:19,620
client time and poly log communication

52
00:02:19,620 --> 00:02:22,680
per query but the server time will at

53
00:02:22,680 --> 00:02:25,260
least be linear in n

54
00:02:25,260 --> 00:02:27,780
can we hope for a sub-linear

55
00:02:27,780 --> 00:02:29,840
um PIR in the classical model

56
00:02:29,840 --> 00:02:33,060
unfortunately this is hopeless there's a

57
00:02:33,060 --> 00:02:36,300
very important lower bound shown by

58
00:02:36,300 --> 00:02:38,280
is shown in Malkin in their 2000 paper

59
00:02:38,280 --> 00:02:40,500
they show that the server time has to be

60
00:02:40,500 --> 00:02:43,019
linear in this model

61
00:02:43,019 --> 00:02:45,540
luckily in their papers it proposed a

62
00:02:45,540 --> 00:02:47,720
new model for the pre-processing model

63
00:02:47,720 --> 00:02:50,879
and the pre-processing PIR can actually

64
00:02:50,879 --> 00:02:54,180
achieve sublinear query

65
00:02:54,180 --> 00:02:56,340
this is the particular pre-processing

66
00:02:56,340 --> 00:02:59,220
model we care about today and we call it

67
00:02:59,220 --> 00:03:02,300
the client-side pre-processing model and

68
00:03:02,300 --> 00:03:04,680
there are other proof assessing models

69
00:03:04,680 --> 00:03:06,060
but this is the one we are going to

70
00:03:06,060 --> 00:03:08,580
focus on today so during the

71
00:03:08,580 --> 00:03:10,560
pre-processing time the client will

72
00:03:10,560 --> 00:03:12,540
interact with the server but notice that

73
00:03:12,540 --> 00:03:14,760
now the client doesn't know what's going

74
00:03:14,760 --> 00:03:17,220
what would be the filter queries

75
00:03:17,220 --> 00:03:19,739
at the end of the pre-processing the

76
00:03:19,739 --> 00:03:22,200
client is going to store some hint in

77
00:03:22,200 --> 00:03:25,140
its local storage and using those locals

78
00:03:25,140 --> 00:03:27,420
hints the client can make multiple

79
00:03:27,420 --> 00:03:29,580
queries and those queries can be made

80
00:03:29,580 --> 00:03:31,680
much more efficiently and actually some

81
00:03:31,680 --> 00:03:34,099
linear

82
00:03:34,440 --> 00:03:37,019
for the previous work the password can

83
00:03:37,019 --> 00:03:40,680
achieve actually squared n online time

84
00:03:40,680 --> 00:03:42,720
per query but they require Square

85
00:03:42,720 --> 00:03:45,299
communication they are also assuming

86
00:03:45,299 --> 00:03:47,519
squared and client storage and they're

87
00:03:47,519 --> 00:03:49,920
using the LW assumption

88
00:03:49,920 --> 00:03:52,560
but the downside is they require square

89
00:03:52,560 --> 00:03:55,799
and communication per query and we know

90
00:03:55,799 --> 00:03:58,200
that In classical PIR using fhe you can

91
00:03:58,200 --> 00:03:59,940
actually achieve poly law communication

92
00:03:59,940 --> 00:04:02,040
so can we hope for the best of both

93
00:04:02,040 --> 00:04:03,840
worlds

94
00:04:03,840 --> 00:04:07,260
in our word we actually show that it is

95
00:04:07,260 --> 00:04:09,360
actually okay to have the best of both

96
00:04:09,360 --> 00:04:12,000
worlds and we actually show a single

97
00:04:12,000 --> 00:04:14,760
server pre-processing PR scheme that has

98
00:04:14,760 --> 00:04:18,000
poly log communication spirit and time

99
00:04:18,000 --> 00:04:20,220
assuming spirit and client storage and

100
00:04:20,220 --> 00:04:23,699
we are also using the LW assumption

101
00:04:23,699 --> 00:04:26,160
I want to mention that our trade-off

102
00:04:26,160 --> 00:04:28,080
between the online time and the client

103
00:04:28,080 --> 00:04:30,120
storage is actually optimal up to a

104
00:04:30,120 --> 00:04:32,699
polyline factor this has been shown by a

105
00:04:32,699 --> 00:04:36,240
previous lower bound that decline time

106
00:04:36,240 --> 00:04:38,280
the product of decline time and the

107
00:04:38,280 --> 00:04:40,860
storage has to be at least n

108
00:04:40,860 --> 00:04:43,979
so our theme is optimal up to a poly

109
00:04:43,979 --> 00:04:45,840
loss Factor

110
00:04:45,840 --> 00:04:48,600
all right let's um so here's the roadmap

111
00:04:48,600 --> 00:04:51,780
today our idea to get the optimal single

112
00:04:51,780 --> 00:04:54,540
server PIR we will first construct an

113
00:04:54,540 --> 00:04:57,180
optimal two server PR scheme then using

114
00:04:57,180 --> 00:04:59,880
then useful hormone encryption to

115
00:04:59,880 --> 00:05:02,100
compile that two service team to the one

116
00:05:02,100 --> 00:05:04,820
server scheme

117
00:05:04,979 --> 00:05:07,620
so in the two service team we assume

118
00:05:07,620 --> 00:05:09,540
that there are two non-politan servers

119
00:05:09,540 --> 00:05:12,380
they both store a copy of the database

120
00:05:12,380 --> 00:05:15,300
and here we assume that during the

121
00:05:15,300 --> 00:05:17,580
pre-processing phase the client is only

122
00:05:17,580 --> 00:05:19,620
going to talk to one of the server

123
00:05:19,620 --> 00:05:21,720
recall that the offline server and

124
00:05:21,720 --> 00:05:23,580
during the online phase the client is

125
00:05:23,580 --> 00:05:27,479
only going to talk to the online server

126
00:05:27,479 --> 00:05:30,360
idea here is that suppose we can wrap

127
00:05:30,360 --> 00:05:32,820
everything for the pre-processing phase

128
00:05:32,820 --> 00:05:35,039
into a fully homo muscle encryption

129
00:05:35,039 --> 00:05:36,600
scheme

130
00:05:36,600 --> 00:05:39,900
and simply the client use the fhe scheme

131
00:05:39,900 --> 00:05:41,699
to encrypt all the messages you need to

132
00:05:41,699 --> 00:05:44,400
send to the server and now the server

133
00:05:44,400 --> 00:05:46,500
simply use fully homomorphic evaluation

134
00:05:46,500 --> 00:05:50,039
to generate those encrypted encrypted

135
00:05:50,039 --> 00:05:52,020
responses to the client

136
00:05:52,020 --> 00:05:55,080
because now everything is encrypted it

137
00:05:55,080 --> 00:05:56,660
doesn't really matter

138
00:05:56,660 --> 00:05:59,820
whether it is the offline server or the

139
00:05:59,820 --> 00:06:02,460
online server because the server simply

140
00:06:02,460 --> 00:06:04,860
learns Nothing by the security of the

141
00:06:04,860 --> 00:06:08,220
FHA scheme so using we can actually

142
00:06:08,220 --> 00:06:10,320
just simply replace the offline server

143
00:06:10,320 --> 00:06:12,180
with the online server and now we have a

144
00:06:12,180 --> 00:06:13,740
single service key

145
00:06:13,740 --> 00:06:16,919
but this transformation has two key

146
00:06:16,919 --> 00:06:19,800
requirements first it requires that the

147
00:06:19,800 --> 00:06:21,539
scheme has full separation property

148
00:06:21,539 --> 00:06:24,000
which means that the client only starts

149
00:06:24,000 --> 00:06:25,080
with one server during the previous

150
00:06:25,080 --> 00:06:27,660
lesson phase and the client's house only

151
00:06:27,660 --> 00:06:29,460
to the online server during the online

152
00:06:29,460 --> 00:06:30,539
phase

153
00:06:30,539 --> 00:06:33,360
secondly we want efficient circuit

154
00:06:33,360 --> 00:06:35,400
representation for the means that

155
00:06:35,400 --> 00:06:37,919
when you do the compilation usually when

156
00:06:37,919 --> 00:06:39,720
we talk about the complexity of the

157
00:06:39,720 --> 00:06:42,240
algorithm we think about that as under

158
00:06:42,240 --> 00:06:45,060
the ram model but when we are using

159
00:06:45,060 --> 00:06:46,979
fully homomorphic encryption we usually

160
00:06:46,979 --> 00:06:49,560
we value the circuit so when you do the

161
00:06:49,560 --> 00:06:51,600
compilation there may be some overhead

162
00:06:51,600 --> 00:06:53,880
so we want the pre-processing server

163
00:06:53,880 --> 00:06:56,039
phase to have an efficient circuit

164
00:06:56,039 --> 00:06:57,960
representation

165
00:06:57,960 --> 00:07:00,120
unfortunately the previous optimal to

166
00:07:00,120 --> 00:07:02,220
the receive cannot satisfy both of the

167
00:07:02,220 --> 00:07:04,199
requirements so we cannot directly start

168
00:07:04,199 --> 00:07:06,539
from the previous game we have to like

169
00:07:06,539 --> 00:07:10,139
design a new service name

170
00:07:10,139 --> 00:07:12,479
so in the next I'm going to talk about

171
00:07:12,479 --> 00:07:16,460
our new optimal 2 server PIR

172
00:07:16,800 --> 00:07:18,960
so I'm going to first start from an

173
00:07:18,960 --> 00:07:20,699
inefficient instrument scheme and then

174
00:07:20,699 --> 00:07:22,259
I'm going to show you the optimization

175
00:07:22,259 --> 00:07:24,660
we do to make it efficient and finally

176
00:07:24,660 --> 00:07:26,819
I'm going to highlight some of our proof

177
00:07:26,819 --> 00:07:28,979
ideas

178
00:07:28,979 --> 00:07:31,800
so this is our true server scheme during

179
00:07:31,800 --> 00:07:33,840
the pre-processing phase the client is

180
00:07:33,840 --> 00:07:37,979
going to sample each sample msat and for

181
00:07:37,979 --> 00:07:40,919
M roughly like squared and log n and for

182
00:07:40,919 --> 00:07:42,060
each set

183
00:07:42,060 --> 00:07:43,979
the set will sample each index

184
00:07:43,979 --> 00:07:46,440
independently with probability one over

185
00:07:46,440 --> 00:07:48,419
square root n so each set will contains

186
00:07:48,419 --> 00:07:51,000
roughly just squared and indices

187
00:07:51,000 --> 00:07:53,039
the client simply sent all the sets to

188
00:07:53,039 --> 00:07:54,720
the offline server

189
00:07:54,720 --> 00:07:57,060
and the offline server returns and bits

190
00:07:57,060 --> 00:08:00,120
those M bits denote the parity for S1 to

191
00:08:00,120 --> 00:08:02,520
SM when I say parity it simply means the

192
00:08:02,520 --> 00:08:05,880
xor sum of those database locations

193
00:08:05,880 --> 00:08:07,919
and now the client simply stores those

194
00:08:07,919 --> 00:08:10,259
steps alongside with those parodies in

195
00:08:10,259 --> 00:08:13,020
its local storage and we think about

196
00:08:13,020 --> 00:08:16,500
those things as the hint

197
00:08:16,500 --> 00:08:19,139
why are those hints useful let's take a

198
00:08:19,139 --> 00:08:21,840
let's take a look so when a client make

199
00:08:21,840 --> 00:08:23,940
an online query X

200
00:08:23,940 --> 00:08:26,879
is simply find a set such that it

201
00:08:26,879 --> 00:08:28,139
contains X

202
00:08:28,139 --> 00:08:30,060
and then

203
00:08:30,060 --> 00:08:33,299
it's going to resemble the particular

204
00:08:33,299 --> 00:08:36,539
online query x intercept s when we say

205
00:08:36,539 --> 00:08:38,760
resample it simply means that we we toss

206
00:08:38,760 --> 00:08:40,799
the coin and then we keep x with

207
00:08:40,799 --> 00:08:43,140
probability one over squared n so this

208
00:08:43,140 --> 00:08:46,020
is exactly the same as the like when we

209
00:08:46,020 --> 00:08:48,600
generate a set

210
00:08:48,600 --> 00:08:51,600
and after we resemble the set we simply

211
00:08:51,600 --> 00:08:54,600
send this resembled set to the server

212
00:08:54,600 --> 00:08:56,580
and the survey returned the parity for

213
00:08:56,580 --> 00:08:59,279
this for example set and now we simply

214
00:08:59,279 --> 00:09:00,899
set the answer

215
00:09:00,899 --> 00:09:04,380
to be the parity of s xor the parity of

216
00:09:04,380 --> 00:09:07,500
this point so why is this um exactly

217
00:09:07,500 --> 00:09:10,260
just DDX well because the resample

218
00:09:10,260 --> 00:09:12,300
process we actually have high

219
00:09:12,300 --> 00:09:15,000
probability to remove X Out of the set

220
00:09:15,000 --> 00:09:18,420
so when that happens the only difference

221
00:09:18,420 --> 00:09:21,480
between the set S and S Prime is exactly

222
00:09:21,480 --> 00:09:25,339
X so when we do the xor

223
00:09:25,339 --> 00:09:29,040
the result should actually be just dbx

224
00:09:29,040 --> 00:09:30,779
notice that this is not perfectly

225
00:09:30,779 --> 00:09:33,480
correct so to get

226
00:09:33,480 --> 00:09:36,000
um negligible error probability we

227
00:09:36,000 --> 00:09:37,860
simply run care parallel instances to

228
00:09:37,860 --> 00:09:40,380
reduce it uh the error probability to be

229
00:09:40,380 --> 00:09:42,779
negligible

230
00:09:42,779 --> 00:09:45,779
after we finish one query

231
00:09:45,779 --> 00:09:49,080
we have to remove this consume hint

232
00:09:49,080 --> 00:09:50,700
otherwise the server is going to learn

233
00:09:50,700 --> 00:09:53,279
some private information so the idea

234
00:09:53,279 --> 00:09:56,399
here is to refresh the hint

235
00:09:56,399 --> 00:09:58,920
and the idea is that doing a

236
00:09:58,920 --> 00:10:00,839
pre-processing phase the client in

237
00:10:00,839 --> 00:10:03,300
addition stores spirit and backup set

238
00:10:03,300 --> 00:10:06,660
and those pair and their parodies and

239
00:10:06,660 --> 00:10:09,720
after it consumed the consumer primary

240
00:10:09,720 --> 00:10:12,120
Hint it simply replace it with a backup

241
00:10:12,120 --> 00:10:14,700
hint for example S Prime Prime but we

242
00:10:14,700 --> 00:10:17,040
have to make sure that when we add the S

243
00:10:17,040 --> 00:10:20,220
Prime line to its primary hint we need

244
00:10:20,220 --> 00:10:22,500
to make sure we need to manually add the

245
00:10:22,500 --> 00:10:24,540
online equivalent x to the set as prime

246
00:10:24,540 --> 00:10:25,320
prime

247
00:10:25,320 --> 00:10:27,300
this is because we want to maintain the

248
00:10:27,300 --> 00:10:29,640
local distribution of its primary set

249
00:10:29,640 --> 00:10:32,040
remember that we already consumer set

250
00:10:32,040 --> 00:10:34,800
that contains X so when we do the

251
00:10:34,800 --> 00:10:36,899
refresh we need to replace it with a set

252
00:10:36,899 --> 00:10:38,459
that contains space that's the reason

253
00:10:38,459 --> 00:10:42,779
why we need to manually add x to the set

254
00:10:42,779 --> 00:10:44,940
so this is our

255
00:10:44,940 --> 00:10:47,220
inefficient instruments in it is

256
00:10:47,220 --> 00:10:48,959
actually efficient in its time remember

257
00:10:48,959 --> 00:10:51,240
that during the online phase the client

258
00:10:51,240 --> 00:10:53,399
simply just find a set and then send a

259
00:10:53,399 --> 00:10:55,140
set to the server and the server simply

260
00:10:55,140 --> 00:10:57,480
just compute the parity for that set

261
00:10:57,480 --> 00:11:00,480
and every set it has only size Square n

262
00:11:00,480 --> 00:11:02,399
so the time is actually squared n per

263
00:11:02,399 --> 00:11:03,600
query

264
00:11:03,600 --> 00:11:06,240
but it is actually inefficient in in

265
00:11:06,240 --> 00:11:08,000
terms of its communication

266
00:11:08,000 --> 00:11:10,200
because every time you need to send a

267
00:11:10,200 --> 00:11:12,180
home set in a set contains script and

268
00:11:12,180 --> 00:11:14,339
indices so the communication should be

269
00:11:14,339 --> 00:11:17,160
straight in and also the storage will be

270
00:11:17,160 --> 00:11:20,040
on this is pretty bad because there are

271
00:11:20,040 --> 00:11:21,839
roughly square and 11 sets each set

272
00:11:21,839 --> 00:11:24,959
contains squared and indices

273
00:11:24,959 --> 00:11:27,480
and now the optimization here

274
00:11:27,480 --> 00:11:29,160
is that we can actually improve the

275
00:11:29,160 --> 00:11:32,100
scheme we notice that in the strawman

276
00:11:32,100 --> 00:11:34,440
scheme we represent a set with square a

277
00:11:34,440 --> 00:11:36,720
bit we simply just store all the indices

278
00:11:36,720 --> 00:11:38,459
but actually

279
00:11:38,459 --> 00:11:40,920
um the idea here is to represent a set

280
00:11:40,920 --> 00:11:43,320
with a very short key because the set is

281
00:11:43,320 --> 00:11:45,420
actually random so we can simply just

282
00:11:45,420 --> 00:11:47,640
use some kind of random seed and then

283
00:11:47,640 --> 00:11:50,459
expand this random seed to a set and

284
00:11:50,459 --> 00:11:52,680
this is the similar idea from the

285
00:11:52,680 --> 00:11:54,300
previous work

286
00:11:54,300 --> 00:11:56,160
what we need from the set representation

287
00:11:56,160 --> 00:11:58,740
well from the server side when the

288
00:11:58,740 --> 00:12:02,399
service sees the short C you should it

289
00:12:02,399 --> 00:12:03,899
should have a very fast set in

290
00:12:03,899 --> 00:12:06,120
numeration algorithm to expand the set

291
00:12:06,120 --> 00:12:08,940
so we want this algorithm to run the

292
00:12:08,940 --> 00:12:11,459
squared at a time also remember that the

293
00:12:11,459 --> 00:12:14,399
client need to find a set so they need

294
00:12:14,399 --> 00:12:17,399
to linearly scan over its local table so

295
00:12:17,399 --> 00:12:20,220
we want this set representation to have

296
00:12:20,220 --> 00:12:22,079
very efficient membership testing for

297
00:12:22,079 --> 00:12:23,820
everything

298
00:12:23,820 --> 00:12:26,700
the idea is to write down every index

299
00:12:26,700 --> 00:12:29,640
using its binary representation

300
00:12:29,640 --> 00:12:33,180
and then we think about the prf so we we

301
00:12:33,180 --> 00:12:36,180
use pseudorandom function and then given

302
00:12:36,180 --> 00:12:38,399
a key we simply think about the key as

303
00:12:38,399 --> 00:12:41,040
the like the set C and then we simply

304
00:12:41,040 --> 00:12:44,220
use that prf as the hash function and

305
00:12:44,220 --> 00:12:46,560
then we attach all the prefixes longer

306
00:12:46,560 --> 00:12:49,740
than half log n to zero or one and we

307
00:12:49,740 --> 00:12:52,380
only consider X to be in the set only

308
00:12:52,380 --> 00:12:54,839
when the half log n prefixes all has two

309
00:12:54,839 --> 00:12:57,839
one it actually happens with exactly

310
00:12:57,839 --> 00:12:59,220
probability

311
00:12:59,220 --> 00:12:59,940
um

312
00:12:59,940 --> 00:13:03,000
to the half log n so that's exactly one

313
00:13:03,000 --> 00:13:04,860
of the script and

314
00:13:04,860 --> 00:13:07,579
so why is this useful well by definition

315
00:13:07,579 --> 00:13:11,220
we can test whether an index belongs to

316
00:13:11,220 --> 00:13:12,779
the set very efficiently you just have

317
00:13:12,779 --> 00:13:16,079
half log n PRS evaluations we also have

318
00:13:16,079 --> 00:13:17,940
a very efficient set in numeration

319
00:13:17,940 --> 00:13:20,880
algorithm I'm going to skip this part

320
00:13:20,880 --> 00:13:24,600
this is still the same idea as before

321
00:13:24,600 --> 00:13:27,540
but actually in our single server scheme

322
00:13:27,540 --> 00:13:29,100
we actually need two additional

323
00:13:29,100 --> 00:13:31,620
conditions we need to have private

324
00:13:31,620 --> 00:13:35,060
resampling algorithm remember that

325
00:13:35,060 --> 00:13:38,459
declined me to resample the particular

326
00:13:38,459 --> 00:13:40,740
online query intercept so we actually

327
00:13:40,740 --> 00:13:43,380
need to do it in a privacy reserving way

328
00:13:43,380 --> 00:13:45,420
otherwise the server is going to learn

329
00:13:45,420 --> 00:13:48,000
your online query also we need to have a

330
00:13:48,000 --> 00:13:49,980
private adding operation

331
00:13:49,980 --> 00:13:51,959
remember that in the local refresh we

332
00:13:51,959 --> 00:13:54,779
have to manually add x to the set and

333
00:13:54,779 --> 00:13:57,000
the product adding and the private

334
00:13:57,000 --> 00:13:59,160
resampling so the combine of them is

335
00:13:59,160 --> 00:14:00,839
actually not supported before bio

336
00:14:00,839 --> 00:14:02,040
previous games

337
00:14:02,040 --> 00:14:04,260
so our key new idea is to use probably

338
00:14:04,260 --> 00:14:07,200
programmable pseudonym set we construct

339
00:14:07,200 --> 00:14:09,300
this new primitive based on privately

340
00:14:09,300 --> 00:14:11,399
programmable prf

341
00:14:11,399 --> 00:14:13,200
so primarily programmable so to learn

342
00:14:13,200 --> 00:14:15,000
the function it has the following syntax

343
00:14:15,000 --> 00:14:17,880
so basically given an upper bound L we

344
00:14:17,880 --> 00:14:21,839
can generate some key K and then

345
00:14:21,839 --> 00:14:22,440
um

346
00:14:22,440 --> 00:14:26,220
we can actually program the key for some

347
00:14:26,220 --> 00:14:29,040
point value pairs so after the

348
00:14:29,040 --> 00:14:31,380
programming when you evaluate on the new

349
00:14:31,380 --> 00:14:34,200
key if you're evaluation Point has been

350
00:14:34,200 --> 00:14:36,540
programmed before then the new key will

351
00:14:36,540 --> 00:14:39,240
just output the program valid otherwise

352
00:14:39,240 --> 00:14:41,100
it's going to return the same value as

353
00:14:41,100 --> 00:14:42,120
before

354
00:14:42,120 --> 00:14:44,220
and the Privacy requirement says that

355
00:14:44,220 --> 00:14:47,820
program key hides the program points

356
00:14:47,820 --> 00:14:51,060
so using this programming very strong

357
00:14:51,060 --> 00:14:54,120
primitive the private adding can be uh

358
00:14:54,120 --> 00:14:55,680
can be made pretty simple

359
00:14:55,680 --> 00:14:58,500
idea here is simply just that we program

360
00:14:58,500 --> 00:15:01,920
all the prefixes relevant to that index

361
00:15:01,920 --> 00:15:04,440
we simply program all the prefixes to be

362
00:15:04,440 --> 00:15:05,940
one

363
00:15:05,940 --> 00:15:08,880
so we have a new key and then we when we

364
00:15:08,880 --> 00:15:10,380
evaluate on this new key all the

365
00:15:10,380 --> 00:15:13,680
prefixes will be forced to one and all

366
00:15:13,680 --> 00:15:15,779
the programming operation can be done in

367
00:15:15,779 --> 00:15:17,760
a privacy preserving way so this is how

368
00:15:17,760 --> 00:15:19,920
we do the product adding

369
00:15:19,920 --> 00:15:21,779
so probably resampling is pretty simple

370
00:15:21,779 --> 00:15:25,519
we just resemble all the prefixes

371
00:15:25,620 --> 00:15:27,420
so that's the idea about how to

372
00:15:27,420 --> 00:15:30,199
construct a pretty efficient Set uh

373
00:15:30,199 --> 00:15:32,339
representation it has basically

374
00:15:32,339 --> 00:15:34,199
satisfied all the four conditions and

375
00:15:34,199 --> 00:15:36,660
this is exactly our optimization in our

376
00:15:36,660 --> 00:15:38,040
paper

377
00:15:38,040 --> 00:15:39,839
all right so I want to highlight some of

378
00:15:39,839 --> 00:15:43,079
the proof in our paper so

379
00:15:43,079 --> 00:15:46,500
we actually have two crypto Primitives

380
00:15:46,500 --> 00:15:49,199
we use the we also use the properly

381
00:15:49,199 --> 00:15:51,720
programmable prf and we also have some

382
00:15:51,720 --> 00:15:54,240
distribution analysis to do to separate

383
00:15:54,240 --> 00:15:55,800
the crypto analysis from the probability

384
00:15:55,800 --> 00:15:57,360
analysis

385
00:15:57,360 --> 00:16:01,199
we use a delay sample check and to

386
00:16:01,199 --> 00:16:03,779
separate them and if you're interested

387
00:16:03,779 --> 00:16:05,699
you can take a look at the paper

388
00:16:05,699 --> 00:16:08,180
we also derive a key Lemma for the

389
00:16:08,180 --> 00:16:10,560
Privacy preserving sorry for the

390
00:16:10,560 --> 00:16:14,040
probably programmable prf we divide a

391
00:16:14,040 --> 00:16:15,480
Lemma says that the programming

392
00:16:15,480 --> 00:16:19,800
operation can be considered as

393
00:16:19,800 --> 00:16:21,779
computational indistinguishable from

394
00:16:21,779 --> 00:16:24,240
rejection sampling hybrids so we use

395
00:16:24,240 --> 00:16:27,899
this key Lemma to switch back and forth

396
00:16:27,899 --> 00:16:32,100
between hybrids and hybrids so that's a

397
00:16:32,100 --> 00:16:34,560
highlight idea in our proof

398
00:16:34,560 --> 00:16:37,199
okay so here's the final slide so I just

399
00:16:37,199 --> 00:16:40,380
want to do a quick recap so the idea

400
00:16:40,380 --> 00:16:43,259
from two server PR to one server PR in

401
00:16:43,259 --> 00:16:45,600
our paper we simply use fully homomorph

402
00:16:45,600 --> 00:16:47,399
encryption to Simply wrap everything

403
00:16:47,399 --> 00:16:50,220
inside of a pre-processing phase and the

404
00:16:50,220 --> 00:16:51,899
key requirement is that we want to have

405
00:16:51,899 --> 00:16:54,420
full separation and efficient circuit

406
00:16:54,420 --> 00:16:57,060
representation and to satisfy both of

407
00:16:57,060 --> 00:16:58,920
the conditions we do rather an optimal

408
00:16:58,920 --> 00:17:01,560
to server plr the key idea is to derive

409
00:17:01,560 --> 00:17:03,959
to design privately programmable solar

410
00:17:03,959 --> 00:17:06,959
energy set and our PR can achieve poly

411
00:17:06,959 --> 00:17:08,939
law communication skirt and time

412
00:17:08,939 --> 00:17:12,119
assuming squared and storage using lwe

413
00:17:12,119 --> 00:17:13,980
and finally I just want to quickly

414
00:17:13,980 --> 00:17:16,859
mention that we have so the transition

415
00:17:16,859 --> 00:17:19,380
today is purely theoretical but we have

416
00:17:19,380 --> 00:17:21,959
a new practical word it's available

417
00:17:21,959 --> 00:17:24,720
ePrint is called Piano it's a still a

418
00:17:24,720 --> 00:17:26,520
single server prcm with soft linear

419
00:17:26,520 --> 00:17:28,919
server computation but it sacrifies a

420
00:17:28,919 --> 00:17:30,419
little bit about the communication it's

421
00:17:30,419 --> 00:17:32,160
actually squared and communication but

422
00:17:32,160 --> 00:17:34,740
it's really fast it can have for 100

423
00:17:34,740 --> 00:17:37,380
gigabyte database 1.6 billion records

424
00:17:37,380 --> 00:17:40,260
our newer can have less than 40

425
00:17:40,260 --> 00:17:41,760
milliseconds

426
00:17:41,760 --> 00:17:43,200
so

427
00:17:43,200 --> 00:17:44,940
um Dale bit thanks everybody for

428
00:17:44,940 --> 00:17:47,080
listening

429
00:17:47,080 --> 00:17:53,280
[Applause]

430
00:17:53,280 --> 00:17:56,539
are there any questions

431
00:17:57,120 --> 00:17:59,340
yes maybe if you've come to the

432
00:17:59,340 --> 00:18:01,699
microphone

433
00:18:05,100 --> 00:18:07,980
talk so I wonder like it seems that the

434
00:18:07,980 --> 00:18:10,080
sets uh for the sets you said that you

435
00:18:10,080 --> 00:18:11,580
want them to be random pseudo random and

436
00:18:11,580 --> 00:18:13,679
it seems to be in this Navy that it's an

437
00:18:13,679 --> 00:18:17,160
Overkill so maybe a weaker uh property

438
00:18:17,160 --> 00:18:18,660
of the randomness suffices and they

439
00:18:18,660 --> 00:18:19,980
wonder whether you looked at the

440
00:18:19,980 --> 00:18:22,500
possibility of replacing the prf with

441
00:18:22,500 --> 00:18:25,039
some information theoretic

442
00:18:25,039 --> 00:18:28,140
generator like I don't know something

443
00:18:28,140 --> 00:18:30,480
it's just like interesting point well

444
00:18:30,480 --> 00:18:32,880
then the independence or something like

445
00:18:32,880 --> 00:18:34,919
this

446
00:18:34,919 --> 00:18:37,380
like this yeah that could be possible I

447
00:18:37,380 --> 00:18:38,820
haven't thought about a very

448
00:18:38,820 --> 00:18:40,200
deeply

449
00:18:40,200 --> 00:18:42,620
but for this construction

450
00:18:42,620 --> 00:18:45,179
even if you replace the set

451
00:18:45,179 --> 00:18:47,760
representation with some I.T secure one

452
00:18:47,760 --> 00:18:49,980
you still need to

453
00:18:49,980 --> 00:18:51,780
have you need to still make

454
00:18:51,780 --> 00:18:53,580
computational assumptions because you

455
00:18:53,580 --> 00:18:55,380
need to use when you want to evaluate

456
00:18:55,380 --> 00:18:57,419
this generator in the real world by an

457
00:18:57,419 --> 00:18:59,039
FHA is the circuit that you will get

458
00:18:59,039 --> 00:19:00,539
will be more simpler than I don't know

459
00:19:00,539 --> 00:19:02,900
yeah

460
00:19:03,840 --> 00:19:06,840
right

461
00:19:08,100 --> 00:19:10,260
if we haven't thought about it but

462
00:19:10,260 --> 00:19:13,200
um our actual our newer doesn't really

463
00:19:13,200 --> 00:19:14,940
require those like complicated things so

464
00:19:14,940 --> 00:19:16,799
it's simpler so if you want to take a

465
00:19:16,799 --> 00:19:18,600
look thank you

466
00:19:18,600 --> 00:19:20,820
uh thanks for the question

467
00:19:20,820 --> 00:19:22,500
um I saw there's one more question maybe

468
00:19:22,500 --> 00:19:25,400
if it's very quick

469
00:19:27,720 --> 00:19:31,640
so I want to ask the proposal of the the

470
00:19:31,640 --> 00:19:36,900
private program for prf is a proposal to

471
00:19:36,900 --> 00:19:39,900
hire the high disappoint the the key

472
00:19:39,900 --> 00:19:42,860
point so

473
00:19:45,140 --> 00:19:48,120
so maybe you can use other tools like

474
00:19:48,120 --> 00:19:50,100
this

475
00:19:50,100 --> 00:19:51,539
um what do you mean

476
00:19:51,539 --> 00:19:55,020
okay so the purpose of this is to hide

477
00:19:55,020 --> 00:19:57,900
the supports right right okay I see

478
00:19:57,900 --> 00:19:59,700
okay

479
00:19:59,700 --> 00:20:01,260
well then let's explain the speaker

480
00:20:01,260 --> 00:20:03,559
again

481
00:20:05,960 --> 00:20:09,660
and move over to the second talk which

482
00:20:09,660 --> 00:20:11,880
is about weighted Oram with applications

483
00:20:11,880 --> 00:20:14,160
to search over symmetric encryption

484
00:20:14,160 --> 00:20:18,539
uh which is by Leonard asoline and Chris

485
00:20:18,539 --> 00:20:22,500
Mino and we are now this uh

486
00:20:22,500 --> 00:20:25,320
once everything is set up

487
00:20:25,320 --> 00:20:27,918
take it away

488
00:20:32,820 --> 00:20:35,580
thank you for the introduction so yes

489
00:20:35,580 --> 00:20:36,840
this is

490
00:20:36,840 --> 00:20:40,500
trying to work with voicemail

491
00:20:40,500 --> 00:20:41,940
um so I'm going to talk about probably

492
00:20:41,940 --> 00:20:44,880
this Ram which is

493
00:20:44,880 --> 00:20:47,400
a way for a client to exchange with the

494
00:20:47,400 --> 00:20:50,280
server and hide the access pattern

495
00:20:50,280 --> 00:20:54,660
um of what they are exchanging

496
00:20:54,660 --> 00:20:57,900
so to motivate here is an example on how

497
00:20:57,900 --> 00:20:59,580
obvious Ram is actually used by the

498
00:20:59,580 --> 00:21:01,620
signal messaging app

499
00:21:01,620 --> 00:21:03,780
so let's say that Alice downloads The

500
00:21:03,780 --> 00:21:06,120
Signal app and she wants to check if her

501
00:21:06,120 --> 00:21:09,360
friend Bob also uses signal

502
00:21:09,360 --> 00:21:11,760
so she knows Bob's phone number it's

503
00:21:11,760 --> 00:21:15,419
written below and she is going to check

504
00:21:15,419 --> 00:21:18,620
with signal server if

505
00:21:18,620 --> 00:21:22,500
Bob's number is in the database

506
00:21:22,500 --> 00:21:25,980
so every phone number is encrypted on

507
00:21:25,980 --> 00:21:28,860
the signal server and Alice can just

508
00:21:28,860 --> 00:21:31,799
make some queries

509
00:21:31,799 --> 00:21:35,640
on that and for that she's going to do a

510
00:21:35,640 --> 00:21:39,299
binary search so she uh so in green this

511
00:21:39,299 --> 00:21:41,880
is the plain text members that she sees

512
00:21:41,880 --> 00:21:44,520
and in red uh it's going to be the

513
00:21:44,520 --> 00:21:47,220
encrypted data that the services so she

514
00:21:47,220 --> 00:21:49,740
starts in the middle and does her binary

515
00:21:49,740 --> 00:21:51,780
search so

516
00:21:51,780 --> 00:21:53,820
um if it's lower than the middle value

517
00:21:53,820 --> 00:21:55,799
she's going to the left and to the right

518
00:21:55,799 --> 00:21:58,080
Etc and in the end she finds Bob's

519
00:21:58,080 --> 00:22:00,120
number or she doesn't find it

520
00:22:00,120 --> 00:22:01,460
so

521
00:22:01,460 --> 00:22:04,380
despite the fact that the phone numbers

522
00:22:04,380 --> 00:22:06,539
are encrypted some information leads

523
00:22:06,539 --> 00:22:09,000
because the server can guess what phone

524
00:22:09,000 --> 00:22:10,159
number

525
00:22:10,159 --> 00:22:15,000
Alice has access here so what we want to

526
00:22:15,000 --> 00:22:17,100
do actually is to hide the access

527
00:22:17,100 --> 00:22:20,820
pattern in that way the server only sees

528
00:22:20,820 --> 00:22:22,500
that Alice makes a certain number of

529
00:22:22,500 --> 00:22:23,640
accesses

530
00:22:23,640 --> 00:22:26,280
but the server cannot know what kind of

531
00:22:26,280 --> 00:22:29,960
computation Addis is made

532
00:22:33,020 --> 00:22:36,380
primitive it was invented in the 80s

533
00:22:36,380 --> 00:22:39,600
where the ram meant actually a CPU

534
00:22:39,600 --> 00:22:41,580
exchanging with the ram of the computer

535
00:22:41,580 --> 00:22:44,460
but right now we are more considering a

536
00:22:44,460 --> 00:22:46,740
client exchanging with a server and it's

537
00:22:46,740 --> 00:22:49,740
a simple a couple of algorithms

538
00:22:49,740 --> 00:22:53,580
first a setup where we give the block

539
00:22:53,580 --> 00:22:57,419
size and the total size n

540
00:22:57,419 --> 00:22:59,520
of the objects that is going to be

541
00:22:59,520 --> 00:23:01,500
stored on the server then we get a

542
00:23:01,500 --> 00:23:04,559
client State and a server State and we

543
00:23:04,559 --> 00:23:07,700
make some accesses to the server

544
00:23:07,700 --> 00:23:10,860
and access consists of the operation

545
00:23:10,860 --> 00:23:13,740
that we're doing either read or write

546
00:23:13,740 --> 00:23:16,140
the address of the object for accessing

547
00:23:16,140 --> 00:23:18,900
and eventually some data if we are

548
00:23:18,900 --> 00:23:20,880
making a right all of this is of course

549
00:23:20,880 --> 00:23:24,840
hidden from the server because we also

550
00:23:24,840 --> 00:23:27,059
want to hide whether we read or rewrite

551
00:23:27,059 --> 00:23:28,559
the value

552
00:23:28,559 --> 00:23:31,940
the security definition for that is

553
00:23:31,940 --> 00:23:33,840
indistinguishability between two

554
00:23:33,840 --> 00:23:35,580
sequences of accesses

555
00:23:35,580 --> 00:23:39,120
so two sequences of the same size should

556
00:23:39,120 --> 00:23:42,179
remain hidden whatever the contents of

557
00:23:42,179 --> 00:23:44,760
the actual accesses are

558
00:23:44,760 --> 00:23:48,360
but proving security is actually the

559
00:23:48,360 --> 00:23:51,679
easy part because as we are going to see

560
00:23:51,679 --> 00:23:54,720
it's easy to see that the access pattern

561
00:23:54,720 --> 00:23:57,299
is information theoretically hidden

562
00:23:57,299 --> 00:23:59,159
the the challenge is going to prove

563
00:23:59,159 --> 00:24:03,120
correctness uh meaning that we actually

564
00:24:03,120 --> 00:24:06,678
take the ram without any failure

565
00:24:06,900 --> 00:24:10,260
um so in this work our goal is to have

566
00:24:10,260 --> 00:24:13,020
an obvious run that handles many objects

567
00:24:13,020 --> 00:24:15,380
of different sizes

568
00:24:15,380 --> 00:24:20,400
without changing the communication costs

569
00:24:20,400 --> 00:24:24,500
of the existing Orem constructions

570
00:24:24,500 --> 00:24:29,360
a nice solution would be to pad to the

571
00:24:29,360 --> 00:24:32,340
largest object size but this is bad

572
00:24:32,340 --> 00:24:34,620
because you're actually paying the

573
00:24:34,620 --> 00:24:36,299
larger subject size every time you make

574
00:24:36,299 --> 00:24:37,980
an access and you don't really handle

575
00:24:37,980 --> 00:24:40,020
that many objects

576
00:24:40,020 --> 00:24:43,799
what you could also do is to divide uh

577
00:24:43,799 --> 00:24:46,320
big objects into smaller chunks but then

578
00:24:46,320 --> 00:24:47,640
you're paying because you need to make

579
00:24:47,640 --> 00:24:51,720
many accesses so this is bad as well

580
00:24:51,720 --> 00:24:52,500
um

581
00:24:52,500 --> 00:24:54,659
what we want to do is to have an alarm

582
00:24:54,659 --> 00:24:58,440
of total size n that handles more than n

583
00:24:58,440 --> 00:25:02,039
objects each of a certain weight WI such

584
00:25:02,039 --> 00:25:04,140
that the sum total of the weights is

585
00:25:04,140 --> 00:25:05,940
going to be less than the total that the

586
00:25:05,940 --> 00:25:07,200
server can handle

587
00:25:07,200 --> 00:25:09,299
uh and each weight is going to be less

588
00:25:09,299 --> 00:25:14,840
than some uh Elementary weight one

589
00:25:14,840 --> 00:25:17,100
as long as that constraint is restricted

590
00:25:17,100 --> 00:25:20,100
we can have the RMB what you call

591
00:25:20,100 --> 00:25:24,659
Dynamic so the when we write uh when we

592
00:25:24,659 --> 00:25:26,940
overwrite an object its weight can

593
00:25:26,940 --> 00:25:28,260
change

594
00:25:28,260 --> 00:25:30,000
and this is what we call a weighted

595
00:25:30,000 --> 00:25:32,720
omnivas Ram

596
00:25:33,500 --> 00:25:36,320
so there are many different around

597
00:25:36,320 --> 00:25:38,640
paradigms in this work we're going to be

598
00:25:38,640 --> 00:25:41,460
focusing on Trio runs this is the main

599
00:25:41,460 --> 00:25:43,980
result of this work but we also have

600
00:25:43,980 --> 00:25:47,340
results that prove that any Oram can be

601
00:25:47,340 --> 00:25:48,900
made to accommodate objects of variable

602
00:25:48,900 --> 00:25:51,779
sizes with a small blow up in the

603
00:25:51,779 --> 00:25:54,240
communication class

604
00:25:54,240 --> 00:25:56,100
so next I'm going to present path to run

605
00:25:56,100 --> 00:25:59,279
which is the most widely used one signal

606
00:25:59,279 --> 00:26:01,679
uses this type of protocol for their

607
00:26:01,679 --> 00:26:03,240
application

608
00:26:03,240 --> 00:26:06,539
then I'm going to explain and prove the

609
00:26:06,539 --> 00:26:08,340
uh and sketch the proof of the main

610
00:26:08,340 --> 00:26:11,880
theorem of our work which is to give a

611
00:26:11,880 --> 00:26:15,120
general transformation from a trio run a

612
00:26:15,120 --> 00:26:16,799
standard free RAM to a weighted tree

613
00:26:16,799 --> 00:26:20,460
around and explain how we can uh what

614
00:26:20,460 --> 00:26:23,340
Criterion that theorem needs to have to

615
00:26:23,340 --> 00:26:26,299
handle such a transformation

616
00:26:26,640 --> 00:26:29,580
so the idea of Festival is to have n

617
00:26:29,580 --> 00:26:31,520
objects

618
00:26:31,520 --> 00:26:34,380
so the original theorems right the

619
00:26:34,380 --> 00:26:37,080
standard one we store n objects in

620
00:26:37,080 --> 00:26:38,120
buckets

621
00:26:38,120 --> 00:26:42,059
each bucket can handle at most Z objects

622
00:26:42,059 --> 00:26:45,299
the buckets are in a binary tree

623
00:26:45,299 --> 00:26:48,720
of that login and each block is going to

624
00:26:48,720 --> 00:26:50,700
be associated with the leaf

625
00:26:50,700 --> 00:26:53,940
so the when we access a block we don't

626
00:26:53,940 --> 00:26:56,580
know its exact position in the Iran we

627
00:26:56,580 --> 00:26:59,340
just know on which path it is pass from

628
00:26:59,340 --> 00:27:00,960
root to a leaf which is what is called

629
00:27:00,960 --> 00:27:03,679
path forward

630
00:27:03,720 --> 00:27:07,500
let's say I want to access the blog the

631
00:27:07,500 --> 00:27:10,260
orange block here and I know that it is

632
00:27:10,260 --> 00:27:13,140
associated with Leaf too this means that

633
00:27:13,140 --> 00:27:15,480
when I access the server

634
00:27:15,480 --> 00:27:20,179
I only know that on the Green Path

635
00:27:20,179 --> 00:27:22,919
the block I want to access is on this

636
00:27:22,919 --> 00:27:25,140
Green Path

637
00:27:25,140 --> 00:27:28,440
and what I do is simply go up the path

638
00:27:28,440 --> 00:27:30,720
from Leaf to root and download every

639
00:27:30,720 --> 00:27:33,360
bucket so first I'm downloading the

640
00:27:33,360 --> 00:27:35,159
button bucket then the middle one then

641
00:27:35,159 --> 00:27:36,480
the other one

642
00:27:36,480 --> 00:27:39,840
and once I have done that I have seen

643
00:27:39,840 --> 00:27:42,299
where the block I wanted to access is so

644
00:27:42,299 --> 00:27:45,120
I can read it modify it maybe if it's

645
00:27:45,120 --> 00:27:46,039
right

646
00:27:46,039 --> 00:27:49,799
and I re-encrypt it

647
00:27:49,799 --> 00:27:51,299
and

648
00:27:51,299 --> 00:27:54,000
then what I'm going to do is to write

649
00:27:54,000 --> 00:27:57,419
back everything on the same Green Path

650
00:27:57,419 --> 00:28:00,179
but now that I've re-encrypted my block

651
00:28:00,179 --> 00:28:02,340
so the one that was arranged is not

652
00:28:02,340 --> 00:28:03,179
right

653
00:28:03,179 --> 00:28:07,080
I also pick Universe uniformly at random

654
00:28:07,080 --> 00:28:10,140
a new Leaf for it

655
00:28:10,140 --> 00:28:12,179
so let's say

656
00:28:12,179 --> 00:28:14,100
happy now this block needs to be on the

657
00:28:14,100 --> 00:28:16,500
path from root to lead three but I'm

658
00:28:16,500 --> 00:28:18,600
writing back on the Green Path so I need

659
00:28:18,600 --> 00:28:20,279
to write it back at the intersection of

660
00:28:20,279 --> 00:28:21,840
the past somewhere

661
00:28:21,840 --> 00:28:25,200
so here since it's step three I can only

662
00:28:25,200 --> 00:28:27,120
write it back at the root so this is

663
00:28:27,120 --> 00:28:29,159
what I'm doing I'm just writing back my

664
00:28:29,159 --> 00:28:32,039
box then I write back another block

665
00:28:32,039 --> 00:28:34,919
but as I said the buckets have a fixed

666
00:28:34,919 --> 00:28:37,020
size so what if at some point I run out

667
00:28:37,020 --> 00:28:38,340
of space

668
00:28:38,340 --> 00:28:40,799
well the client has enough line memory

669
00:28:40,799 --> 00:28:43,200
that we call this Dash

670
00:28:43,200 --> 00:28:47,039
and the stash in tata Ram is of size

671
00:28:47,039 --> 00:28:49,200
small Omega of login

672
00:28:49,200 --> 00:28:51,659
and this is where we saw the blocks that

673
00:28:51,659 --> 00:28:55,159
we cannot write back online

674
00:28:55,320 --> 00:28:57,179
um so I'm writing back the blog I

675
00:28:57,179 --> 00:29:00,360
couldn't and

676
00:29:00,539 --> 00:29:03,120
uh as I said it's easy to see that it's

677
00:29:03,120 --> 00:29:04,860
secure because

678
00:29:04,860 --> 00:29:07,080
when I access a block I reveal to the

679
00:29:07,080 --> 00:29:10,440
server the path on which this block was

680
00:29:10,440 --> 00:29:13,559
but anytime I do that immediately after

681
00:29:13,559 --> 00:29:16,799
I pick a new Leaf that is remain secret

682
00:29:16,799 --> 00:29:19,380
and I write back the block

683
00:29:19,380 --> 00:29:23,600
on the part of this new Leaf so

684
00:29:23,600 --> 00:29:28,140
the the the paths where the block is

685
00:29:28,140 --> 00:29:31,200
remain Secret at all times after every

686
00:29:31,200 --> 00:29:33,600
step for the after every access for the

687
00:29:33,600 --> 00:29:35,700
server

688
00:29:35,700 --> 00:29:36,539
um

689
00:29:36,539 --> 00:29:37,980
what is important is to prove

690
00:29:37,980 --> 00:29:39,899
correctness and in the case of path

691
00:29:39,899 --> 00:29:41,940
around to prove that the stash never

692
00:29:41,940 --> 00:29:45,919
overflows with overwhelming probability

693
00:29:47,100 --> 00:29:50,520
so from the bathroom paper we know that

694
00:29:50,520 --> 00:29:52,320
the

695
00:29:52,320 --> 00:29:55,140
the probability that the stash load is

696
00:29:55,140 --> 00:29:57,899
greater than somebody you are is

697
00:29:57,899 --> 00:30:00,779
exponentially low in R so this is why we

698
00:30:00,779 --> 00:30:02,520
need to have something slightly bigger

699
00:30:02,520 --> 00:30:04,320
than login for the probability of

700
00:30:04,320 --> 00:30:07,260
another flow to be negligible

701
00:30:07,260 --> 00:30:10,919
our contribution is to show how to

702
00:30:10,919 --> 00:30:15,020
handle blood survival sizes so

703
00:30:15,899 --> 00:30:16,799
um

704
00:30:16,799 --> 00:30:18,659
here is how we are going to modify a

705
00:30:18,659 --> 00:30:20,580
tree around to become a weighted tree

706
00:30:20,580 --> 00:30:21,720
around

707
00:30:21,720 --> 00:30:24,659
let's say that we have M blocks n

708
00:30:24,659 --> 00:30:26,820
greater than n and each block is of size

709
00:30:26,820 --> 00:30:28,220
less than b

710
00:30:28,220 --> 00:30:31,919
so you can see b as being one but this

711
00:30:31,919 --> 00:30:33,380
has been uh

712
00:30:33,380 --> 00:30:37,039
as the number of bits for black

713
00:30:37,039 --> 00:30:39,840
the sum total of the weight needs to be

714
00:30:39,840 --> 00:30:44,039
equal or less than n times B

715
00:30:44,039 --> 00:30:46,140
and we're going to modify how the

716
00:30:46,140 --> 00:30:48,200
buckets behave

717
00:30:48,200 --> 00:30:50,760
now we are going to say that we can

718
00:30:50,760 --> 00:30:53,039
store blocks in the bucket until they

719
00:30:53,039 --> 00:30:55,559
reach the threshold Z

720
00:30:55,559 --> 00:30:58,080
so I can sort a small block a bigger

721
00:30:58,080 --> 00:30:59,820
block a smaller block and at some point

722
00:30:59,820 --> 00:31:03,240
when I reach that threshold I say that

723
00:31:03,240 --> 00:31:04,799
this bucket is full

724
00:31:04,799 --> 00:31:07,320
so I cannot solve objects here anymore

725
00:31:07,320 --> 00:31:09,840
and I need to either go upper level in

726
00:31:09,840 --> 00:31:12,020
the tree or if I'm already at the roots

727
00:31:12,020 --> 00:31:15,179
things go back to the stash

728
00:31:15,179 --> 00:31:17,580
so the main theorem is

729
00:31:17,580 --> 00:31:20,340
if we have a tree around protocol where

730
00:31:20,340 --> 00:31:23,940
we read when we read buckets it's done

731
00:31:23,940 --> 00:31:25,919
by a trigger run which means that we

732
00:31:25,919 --> 00:31:27,600
download the entire botnet we are not

733
00:31:27,600 --> 00:31:29,100
trying to do anything clever to access

734
00:31:29,100 --> 00:31:32,159
only the block that we want

735
00:31:32,159 --> 00:31:34,140
um the search load comes from collection

736
00:31:34,140 --> 00:31:36,360
of subsets of rockets in the infinite

737
00:31:36,360 --> 00:31:38,700
around which is an idealizer model that

738
00:31:38,700 --> 00:31:40,740
helps out for the proof for the proof

739
00:31:40,740 --> 00:31:42,000
that I'm going to show you in the next

740
00:31:42,000 --> 00:31:44,240
slide

741
00:31:44,840 --> 00:31:48,299
is negligible and this Oram can become a

742
00:31:48,299 --> 00:31:50,580
weighted forum

743
00:31:50,580 --> 00:31:53,279
so the proof consider a sequence of

744
00:31:53,279 --> 00:31:55,200
accesses s

745
00:31:55,200 --> 00:31:56,940
and we are going to consider the

746
00:31:56,940 --> 00:31:58,200
execution

747
00:31:58,200 --> 00:31:58,799
um

748
00:31:58,799 --> 00:32:01,919
on the infinite to run where we assume

749
00:32:01,919 --> 00:32:05,220
that the buckets have an infinite size

750
00:32:05,220 --> 00:32:07,140
we can store as many objects as we want

751
00:32:07,140 --> 00:32:09,679
in the bucket

752
00:32:10,140 --> 00:32:12,600
we are going to transform this idealizer

753
00:32:12,600 --> 00:32:14,760
Ram into a real one

754
00:32:14,760 --> 00:32:20,600
that it has the same search load as our

755
00:32:20,600 --> 00:32:22,980
real or random ensure that this

756
00:32:22,980 --> 00:32:25,020
threshold is negligible

757
00:32:25,020 --> 00:32:29,700
and then in that case uh we are is going

758
00:32:29,700 --> 00:32:31,919
to show that the probability of an

759
00:32:31,919 --> 00:32:33,779
overflow is negligible in a real case

760
00:32:33,779 --> 00:32:36,179
too and so uh we're going to have

761
00:32:36,179 --> 00:32:38,820
ourselves awaited around

762
00:32:38,820 --> 00:32:41,880
so this is the state of the infinite

763
00:32:41,880 --> 00:32:43,799
term after the execution

764
00:32:43,799 --> 00:32:46,559
uh you can see we have

765
00:32:46,559 --> 00:32:48,320
um the the

766
00:32:48,320 --> 00:32:52,039
bottom left bucket which is um

767
00:32:52,039 --> 00:32:55,500
uh overflowing and it's not possible

768
00:32:55,500 --> 00:32:58,500
that this happens in the real Forum so

769
00:32:58,500 --> 00:33:00,480
we're going to transform that state into

770
00:33:00,480 --> 00:33:02,760
real estate by just cutting everything

771
00:33:02,760 --> 00:33:04,860
that sticks out

772
00:33:04,860 --> 00:33:07,140
and then we're going to try and put it

773
00:33:07,140 --> 00:33:10,620
up in the tree so here we have some

774
00:33:10,620 --> 00:33:14,039
space on the upper levels bracket so

775
00:33:14,039 --> 00:33:16,740
we're going to cut another chunk of this

776
00:33:16,740 --> 00:33:20,880
of this block put it here but now I

777
00:33:20,880 --> 00:33:22,919
don't have any more space in my tree so

778
00:33:22,919 --> 00:33:24,899
what am I going to do with the remaining

779
00:33:24,899 --> 00:33:26,279
block

780
00:33:26,279 --> 00:33:28,620
put it in the stash and this is where

781
00:33:28,620 --> 00:33:30,899
the stash load after post processing

782
00:33:30,899 --> 00:33:33,179
comes from

783
00:33:33,179 --> 00:33:35,279
and we can notice that the stash load of

784
00:33:35,279 --> 00:33:37,380
the post-process Oram here is greater

785
00:33:37,380 --> 00:33:39,419
than the threshold of the real aura

786
00:33:39,419 --> 00:33:41,519
because we're not even allowing to have

787
00:33:41,519 --> 00:33:43,380
something stick out a little everything

788
00:33:43,380 --> 00:33:46,760
just goes to the stash

789
00:33:48,659 --> 00:33:49,320
um

790
00:33:49,320 --> 00:33:53,460
so now let's call X of w where W is the

791
00:33:53,460 --> 00:33:55,320
weight distribution Vector of our

792
00:33:55,320 --> 00:33:58,860
objects uh x w is the random variable of

793
00:33:58,860 --> 00:34:00,679
the max cash load

794
00:34:00,679 --> 00:34:02,880
in the post processing we need to run

795
00:34:02,880 --> 00:34:05,820
for any permutation of Revenue so x w

796
00:34:05,820 --> 00:34:09,659
is the worst case search load that the

797
00:34:09,659 --> 00:34:11,399
Oram can have

798
00:34:11,399 --> 00:34:13,980
we are going to show that the expected

799
00:34:13,980 --> 00:34:15,960
value of this cash flow is going to be

800
00:34:15,960 --> 00:34:18,060
less than the expected value of the

801
00:34:18,060 --> 00:34:21,060
search load in the standard order okay U

802
00:34:21,060 --> 00:34:25,260
here means that we have n objects of

803
00:34:25,260 --> 00:34:27,719
size 1 and that's it so this is the

804
00:34:27,719 --> 00:34:30,259
standard case

805
00:34:31,739 --> 00:34:33,540
to prove that we use what we call a

806
00:34:33,540 --> 00:34:36,239
majorization argument

807
00:34:36,239 --> 00:34:41,179
so let's have two vectors B and W

808
00:34:41,179 --> 00:34:45,239
of the same sum total rate

809
00:34:45,239 --> 00:34:47,399
and when we saw them in decreasing order

810
00:34:47,399 --> 00:34:50,820
we say that V major raises W if

811
00:34:50,820 --> 00:34:54,359
uh there's some uh the partial sums of V

812
00:34:54,359 --> 00:34:56,520
are always greater than the partial sums

813
00:34:56,520 --> 00:34:58,020
of w

814
00:34:58,020 --> 00:34:59,400
so you can see here graphical

815
00:34:59,400 --> 00:35:00,900
representation of what majorization

816
00:35:00,900 --> 00:35:03,560
might look like

817
00:35:04,500 --> 00:35:05,280
um

818
00:35:05,280 --> 00:35:07,020
and we have a Lemma

819
00:35:07,020 --> 00:35:09,839
that is that if I have

820
00:35:09,839 --> 00:35:13,500
uh so if I have a short convex function

821
00:35:13,500 --> 00:35:15,599
which means that it's convex and it's

822
00:35:15,599 --> 00:35:17,820
symmetrical so for any permutation of a

823
00:35:17,820 --> 00:35:21,260
vector v the value of f is the same

824
00:35:21,260 --> 00:35:24,780
then this function is going to take on

825
00:35:24,780 --> 00:35:28,760
the slide the function is going to

826
00:35:28,760 --> 00:35:31,800
preserve the materialization order so if

827
00:35:31,800 --> 00:35:35,280
v materizes w f of V is greater than F

828
00:35:35,280 --> 00:35:36,780
of w

829
00:35:36,780 --> 00:35:39,660
now we can notice that of variable X is

830
00:35:39,660 --> 00:35:42,240
show convex because so this is to see

831
00:35:42,240 --> 00:35:44,640
that it's convex and by definition

832
00:35:44,640 --> 00:35:46,680
whatever the permutation is going to be

833
00:35:46,680 --> 00:35:48,180
the same value

834
00:35:48,180 --> 00:35:51,660
the expectation function is convex and U

835
00:35:51,660 --> 00:35:55,079
majorizes any wave Vector which is easy

836
00:35:55,079 --> 00:35:58,020
to see in the in the figure here

837
00:35:58,020 --> 00:36:01,380
but from that we can we we know that the

838
00:36:01,380 --> 00:36:04,859
expected value X of w is less than the

839
00:36:04,859 --> 00:36:07,079
expected value of x of U thanks to all

840
00:36:07,079 --> 00:36:07,859
them

841
00:36:07,859 --> 00:36:10,560
and thus

842
00:36:10,560 --> 00:36:12,960
since we know from the pattern paper

843
00:36:12,960 --> 00:36:15,000
that the expected value of x value is

844
00:36:15,000 --> 00:36:17,940
negligible the expected overflow is also

845
00:36:17,940 --> 00:36:20,480
negligible

846
00:36:21,359 --> 00:36:23,520
um we have some experimental results

847
00:36:23,520 --> 00:36:27,420
that show that actually uh well

848
00:36:27,420 --> 00:36:30,300
the standard run is the worst case so

849
00:36:30,300 --> 00:36:32,280
you can see that the search load is is

850
00:36:32,280 --> 00:36:36,359
always the maximum observed slash load

851
00:36:36,359 --> 00:36:40,440
is always lower than the maximum

852
00:36:40,440 --> 00:36:43,619
for the standard run

853
00:36:43,619 --> 00:36:47,760
so the takeaway from from my talk is

854
00:36:47,760 --> 00:36:50,460
that three aurams are powerful enough to

855
00:36:50,460 --> 00:36:54,119
without any added cost handle weighted

856
00:36:54,119 --> 00:36:55,079
objects

857
00:36:55,079 --> 00:36:59,420
and we give a Criterion to to prove that

858
00:36:59,420 --> 00:37:03,000
which program is capable is able to

859
00:37:03,000 --> 00:37:06,240
handle weighted objects

860
00:37:06,240 --> 00:37:08,220
now any around can actually handle them

861
00:37:08,220 --> 00:37:11,040
but we need to have some communication

862
00:37:11,040 --> 00:37:12,500
class blower

863
00:37:12,500 --> 00:37:15,480
and if you check out paper you can see

864
00:37:15,480 --> 00:37:17,880
how weight the Rams can be used to build

865
00:37:17,880 --> 00:37:19,859
a searchable symmetry conscription

866
00:37:19,859 --> 00:37:22,759
thank you very much

867
00:37:27,500 --> 00:37:29,940
Leonard thanks for the talk are there

868
00:37:29,940 --> 00:37:32,960
any questions in the audience

869
00:37:33,960 --> 00:37:35,880
yes can you please come to the

870
00:37:35,880 --> 00:37:38,180
microphone

871
00:37:38,180 --> 00:37:41,280
thank you for the nice talk I'm just

872
00:37:41,280 --> 00:37:44,820
wondering if your Technique like a sure

873
00:37:44,820 --> 00:37:48,900
complex argument work also for other

874
00:37:48,900 --> 00:37:52,200
similar Primitives say perfect

875
00:37:52,200 --> 00:37:54,060
information retrieval how do you think

876
00:37:54,060 --> 00:37:56,339
about that

877
00:37:56,339 --> 00:37:59,299
um so that's a good question

878
00:37:59,520 --> 00:38:01,140
um

879
00:38:01,140 --> 00:38:03,839
so I would need to learn a bit more

880
00:38:03,839 --> 00:38:06,960
about PR to know if this type of

881
00:38:06,960 --> 00:38:11,400
argument could work but this is uh this

882
00:38:11,400 --> 00:38:13,820
is very uh powerful

883
00:38:13,820 --> 00:38:17,339
tool to use a naturalization and show

884
00:38:17,339 --> 00:38:20,220
convex functions and

885
00:38:20,220 --> 00:38:24,060
um it's been used in a few uh

886
00:38:24,060 --> 00:38:26,220
um initial articles but it mainly comes

887
00:38:26,220 --> 00:38:27,500
from the

888
00:38:27,500 --> 00:38:31,680
combinatorics community and I haven't

889
00:38:31,680 --> 00:38:34,140
seen that used a lot in cryptography

890
00:38:34,140 --> 00:38:36,599
papers but it certainly would be of use

891
00:38:36,599 --> 00:38:40,339
to consider these arguments

892
00:38:41,520 --> 00:38:43,440
okay

893
00:38:43,440 --> 00:38:46,740
um I think in the interest of time uh if

894
00:38:46,740 --> 00:38:48,240
there are any other questions maybe ask

895
00:38:48,240 --> 00:38:51,359
the speaker in the break so let's take

896
00:38:51,359 --> 00:38:53,960
the speaker again

897
00:38:57,000 --> 00:39:00,180
and the last Talk of the session is

898
00:39:00,180 --> 00:39:03,240
going to be about Nano nanogram which is

899
00:39:03,240 --> 00:39:06,200
double gram with uh

900
00:39:06,200 --> 00:39:10,079
overlocking overheads and it's worked by

901
00:39:10,079 --> 00:39:13,200
Andrew Park like element LNG and Andrew

902
00:39:13,200 --> 00:39:16,279
is going to give the talk

903
00:39:24,420 --> 00:39:26,700
um hi everyone I'm Andrew Park I'm a

904
00:39:26,700 --> 00:39:29,160
second year grad student at CMU and I'll

905
00:39:29,160 --> 00:39:31,260
be giving a talk on our work nanogram

906
00:39:31,260 --> 00:39:34,200
barbell dram with otilda log n overhead

907
00:39:34,200 --> 00:39:36,000
and this is based on joint work with

908
00:39:36,000 --> 00:39:39,359
waycairn and my advisable Luigi

909
00:39:39,359 --> 00:39:40,800
um so before we can talk about gobble

910
00:39:40,800 --> 00:39:42,480
Ram we have to remind ourselves about

911
00:39:42,480 --> 00:39:45,480
carbo circus so as you guys may know in

912
00:39:45,480 --> 00:39:47,460
a carbocation model we have a garbler

913
00:39:47,460 --> 00:39:49,140
and an evaluator

914
00:39:49,140 --> 00:39:50,820
um so we have two parties that wish to

915
00:39:50,820 --> 00:39:53,339
compute some joint function on their

916
00:39:53,339 --> 00:39:57,300
private input data uh the most important

917
00:39:57,300 --> 00:39:58,859
property of travel circuits for us is

918
00:39:58,859 --> 00:40:00,839
the fact that it's not interactive

919
00:40:00,839 --> 00:40:02,880
um the garbler can basically garble

920
00:40:02,880 --> 00:40:04,619
their input as well as the circuit and

921
00:40:04,619 --> 00:40:06,480
pass it over to the evaluator and the

922
00:40:06,480 --> 00:40:08,220
evaluator locally can do all of the

923
00:40:08,220 --> 00:40:09,839
computation and then pass the result

924
00:40:09,839 --> 00:40:12,839
back to this coupler however as we know

925
00:40:12,839 --> 00:40:14,640
most of our computation is done in the

926
00:40:14,640 --> 00:40:16,140
ram model which is sort of incompatible

927
00:40:16,140 --> 00:40:18,660
with the circuit model and particularly

928
00:40:18,660 --> 00:40:20,760
um because we're working in the circuit

929
00:40:20,760 --> 00:40:22,440
model there's this large ramp to Circuit

930
00:40:22,440 --> 00:40:23,460
conversion

931
00:40:23,460 --> 00:40:25,260
um whenever we have to do anything with

932
00:40:25,260 --> 00:40:27,839
the ramp so um in particular if the ram

933
00:40:27,839 --> 00:40:29,760
is very large because we have to unroll

934
00:40:29,760 --> 00:40:32,220
the memory for every single Ram axis

935
00:40:32,220 --> 00:40:33,839
we're going to have a very large circuit

936
00:40:33,839 --> 00:40:36,480
blow up in the size of the rim

937
00:40:36,480 --> 00:40:37,859
um because of this there was this new

938
00:40:37,859 --> 00:40:39,480
primitive called garbled Ram that was

939
00:40:39,480 --> 00:40:42,960
introduced in 2013 By Luan ostrowski and

940
00:40:42,960 --> 00:40:45,000
in this model rather than just having a

941
00:40:45,000 --> 00:40:47,280
circuit that computes everything

942
00:40:47,280 --> 00:40:48,079
um

943
00:40:48,079 --> 00:40:50,280
we're trying to construct this thing

944
00:40:50,280 --> 00:40:52,440
called an access key and what an SSD

945
00:40:52,440 --> 00:40:54,720
does is it's basically a random access

946
00:40:54,720 --> 00:40:58,140
where the input is some garbled index I

947
00:40:58,140 --> 00:41:01,140
and the output is the value that is at

948
00:41:01,140 --> 00:41:02,880
that index

949
00:41:02,880 --> 00:41:04,680
um so you can see that um this is going

950
00:41:04,680 --> 00:41:05,940
to be very hard because the evaluator

951
00:41:05,940 --> 00:41:08,460
sort of needs to on the Fly do a dynamic

952
00:41:08,460 --> 00:41:10,680
process even though the doddler does not

953
00:41:10,680 --> 00:41:12,119
know anything about the access at the

954
00:41:12,119 --> 00:41:13,619
time of the bubbly

955
00:41:13,619 --> 00:41:16,140
in our particular our goal is that the

956
00:41:16,140 --> 00:41:18,180
access is going to take time in a

957
00:41:18,180 --> 00:41:19,740
sublinear blow up in the size of the ram

958
00:41:19,740 --> 00:41:21,960
so obviously if we allow a linear blow

959
00:41:21,960 --> 00:41:23,160
up then that's the same thing as just

960
00:41:23,160 --> 00:41:26,099
unrolling up the entire memory

961
00:41:26,099 --> 00:41:28,440
um so now briefly uh lay out the

962
00:41:28,440 --> 00:41:31,380
landscape of priority constructions so

963
00:41:31,380 --> 00:41:33,720
the first um the first couple of goggle

964
00:41:33,720 --> 00:41:36,420
Ram constructions all had blow up um in

965
00:41:36,420 --> 00:41:38,640
polynomial in the security parameter and

966
00:41:38,640 --> 00:41:40,079
on poly log in the size of the ram

967
00:41:40,079 --> 00:41:42,599
however all of these constructions are

968
00:41:42,599 --> 00:41:44,280
very impractical and in particular they

969
00:41:44,280 --> 00:41:46,980
require on non-block box use of prf

970
00:41:46,980 --> 00:41:50,460
evaluations inside of the starboard Ram

971
00:41:50,460 --> 00:41:51,960
um last year as you may know there was

972
00:41:51,960 --> 00:41:53,820
this new uh construction introduced

973
00:41:53,820 --> 00:41:56,280
called epigram by Heath at all and this

974
00:41:56,280 --> 00:41:58,560
construction had blow up log squared in

975
00:41:58,560 --> 00:42:01,020
the size of the memory and um this is a

976
00:42:01,020 --> 00:42:03,540
pretty practical

977
00:42:03,540 --> 00:42:05,339
uh and then here it's important to

978
00:42:05,339 --> 00:42:06,540
recognize that there is some lower

979
00:42:06,540 --> 00:42:08,700
bounds so if we think about

980
00:42:08,700 --> 00:42:10,260
um what is the best possible that we can

981
00:42:10,260 --> 00:42:12,960
do uh we can think about having some

982
00:42:12,960 --> 00:42:15,540
orms such as circuit Oram and gargling

983
00:42:15,540 --> 00:42:18,780
are out standard uh tree Oram uh and

984
00:42:18,780 --> 00:42:20,160
then think about what the blow up is and

985
00:42:20,160 --> 00:42:22,680
as we know from the RM literature this

986
00:42:22,680 --> 00:42:24,540
will cause a blow up a blogger making

987
00:42:24,540 --> 00:42:26,579
the size of the room however this is

988
00:42:26,579 --> 00:42:28,320
going to require interactions so this

989
00:42:28,320 --> 00:42:31,619
seems to be a a standard lower Bound for

990
00:42:31,619 --> 00:42:34,980
our bobbled Ram problem as well

991
00:42:34,980 --> 00:42:36,900
um so here in this work we ask can we

992
00:42:36,900 --> 00:42:38,940
have a non-interactive global Ram scheme

993
00:42:38,940 --> 00:42:40,680
which asymptotic performance is

994
00:42:40,680 --> 00:42:42,119
competitive to the interactive state of

995
00:42:42,119 --> 00:42:43,560
the art

996
00:42:43,560 --> 00:42:45,599
so in this work we introduced nanogram

997
00:42:45,599 --> 00:42:48,240
which has o tilde of log n overhead

998
00:42:48,240 --> 00:42:50,160
where the tool is hiding a polywog

999
00:42:50,160 --> 00:42:53,220
factors and as we can see this is uh

1000
00:42:53,220 --> 00:42:55,200
near optimal dependence on end so um

1001
00:42:55,200 --> 00:42:58,500
because of this love and lower bound

1002
00:42:58,500 --> 00:43:00,359
okay so for the outline of the rest of

1003
00:43:00,359 --> 00:43:01,920
the talk I'll first introduce the

1004
00:43:01,920 --> 00:43:03,540
language translation problem which is

1005
00:43:03,540 --> 00:43:06,300
the Crux of the global room problem then

1006
00:43:06,300 --> 00:43:07,920
I'll introduce the strawman scheme which

1007
00:43:07,920 --> 00:43:10,680
is um just gobling a standard or M3 and

1008
00:43:10,680 --> 00:43:12,480
then finally I'll discuss our trainings

1009
00:43:12,480 --> 00:43:15,060
which allow us to achieve this above uh

1010
00:43:15,060 --> 00:43:17,760
poly loving

1011
00:43:17,760 --> 00:43:19,619
okay so first I'll introduce the

1012
00:43:19,619 --> 00:43:21,180
language problem

1013
00:43:21,180 --> 00:43:22,319
um so in the linguist translation

1014
00:43:22,319 --> 00:43:25,140
problem uh if we think about the global

1015
00:43:25,140 --> 00:43:26,819
circuit um we can think about every

1016
00:43:26,819 --> 00:43:28,680
single Cobble circuit case speaking some

1017
00:43:28,680 --> 00:43:30,720
time dependent language so in particular

1018
00:43:30,720 --> 00:43:33,060
if we think about the input uh to the

1019
00:43:33,060 --> 00:43:37,380
gate uh we require that this data is

1020
00:43:37,380 --> 00:43:40,020
being encoded under some time dependent

1021
00:43:40,020 --> 00:43:41,760
label so in this case it is this orange

1022
00:43:41,760 --> 00:43:42,900
L

1023
00:43:42,900 --> 00:43:44,880
so that it is able to be read and

1024
00:43:44,880 --> 00:43:47,640
processed by that gate

1025
00:43:47,640 --> 00:43:49,380
so here if we think about the carbo

1026
00:43:49,380 --> 00:43:51,300
circuit as being a bunch of sequential

1027
00:43:51,300 --> 00:43:53,339
time dependent dates

1028
00:43:53,339 --> 00:43:55,680
every gate is expecting an input goggle

1029
00:43:55,680 --> 00:43:59,000
under is time dependent language

1030
00:43:59,220 --> 00:44:02,460
so in particular if if we're in this Ram

1031
00:44:02,460 --> 00:44:04,859
model that means that if we want to do

1032
00:44:04,859 --> 00:44:07,680
an access for some random x i

1033
00:44:07,680 --> 00:44:10,260
time dependent uh out of time dependent

1034
00:44:10,260 --> 00:44:13,020
K so here at T equals one is expecting

1035
00:44:13,020 --> 00:44:15,839
some random element x i garbled under

1036
00:44:15,839 --> 00:44:18,119
the language for T equals one

1037
00:44:18,119 --> 00:44:20,760
somehow the garbler needs to prepare for

1038
00:44:20,760 --> 00:44:22,079
this in advance even though the

1039
00:44:22,079 --> 00:44:24,000
barbeller does not know what s I will be

1040
00:44:24,000 --> 00:44:25,920
at T equals one

1041
00:44:25,920 --> 00:44:27,839
right so the Goblet here does not know

1042
00:44:27,839 --> 00:44:30,000
what i is in advance and similarly the

1043
00:44:30,000 --> 00:44:32,359
evaluator does not know at what time t

1044
00:44:32,359 --> 00:44:37,619
uh XI is going to be uh are retreat

1045
00:44:37,619 --> 00:44:40,800
so this is a clearly an incompatibility

1046
00:44:40,800 --> 00:44:43,440
here so our goal is somehow

1047
00:44:43,440 --> 00:44:45,240
need somehow we need a way for the

1048
00:44:45,240 --> 00:44:48,119
evaluator to locally translate x i under

1049
00:44:48,119 --> 00:44:51,500
the time-dependent variable

1050
00:44:51,660 --> 00:44:53,880
so now I'll talk about astronomy which

1051
00:44:53,880 --> 00:44:56,220
is just following an or entry so as we

1052
00:44:56,220 --> 00:44:57,720
saw in the previous talk

1053
00:44:57,720 --> 00:44:59,700
um if we just have a garbled orange tree

1054
00:44:59,700 --> 00:45:02,579
and then garble it we know that some

1055
00:45:02,579 --> 00:45:05,220
access is going to lie on some uh random

1056
00:45:05,220 --> 00:45:06,720
path right and this random path is

1057
00:45:06,720 --> 00:45:09,720
allowed to be uh uh shown in the clear

1058
00:45:09,720 --> 00:45:12,240
since it's a uniformly random value so

1059
00:45:12,240 --> 00:45:14,280
here if we think about each node as

1060
00:45:14,280 --> 00:45:16,020
being some global data structure and

1061
00:45:16,020 --> 00:45:18,720
every node having a local plot

1062
00:45:18,720 --> 00:45:20,880
what we can do is we can sort of pass

1063
00:45:20,880 --> 00:45:23,099
the time dependent label down this

1064
00:45:23,099 --> 00:45:24,780
random path in the tree

1065
00:45:24,780 --> 00:45:27,240
and the labels are

1066
00:45:27,240 --> 00:45:29,640
um the labels are garbled in advance so

1067
00:45:29,640 --> 00:45:30,900
that you are able to read from each

1068
00:45:30,900 --> 00:45:33,480
bucket right so if we have this type of

1069
00:45:33,480 --> 00:45:35,579
label and we know that SI is laying on

1070
00:45:35,579 --> 00:45:38,339
this um pass due to the path invariant

1071
00:45:38,339 --> 00:45:40,079
of the orm tree

1072
00:45:40,079 --> 00:45:42,060
our goal is to Route these labels as

1073
00:45:42,060 --> 00:45:44,040
well as LT down this path and we're

1074
00:45:44,040 --> 00:45:45,839
guaranteed at some point to be able to

1075
00:45:45,839 --> 00:45:48,240
do the translation of X500 LT using

1076
00:45:48,240 --> 00:45:50,940
these logarithmic labels

1077
00:45:50,940 --> 00:45:52,980
so now you may be asking how we're going

1078
00:45:52,980 --> 00:45:55,619
to actually pass down these uh label

1079
00:45:55,619 --> 00:45:57,660
payloads down the tree

1080
00:45:57,660 --> 00:45:59,160
um and we use this gadget called the

1081
00:45:59,160 --> 00:46:00,540
garble switch which was introduced in

1082
00:46:00,540 --> 00:46:02,339
the prior work and this gargle switch

1083
00:46:02,339 --> 00:46:04,020
basically is a gadget that allows for

1084
00:46:04,020 --> 00:46:06,599
dynamic language translation

1085
00:46:06,599 --> 00:46:09,480
so now I'll discuss the garble switch

1086
00:46:09,480 --> 00:46:11,760
able switch there is a parent node as

1087
00:46:11,760 --> 00:46:13,680
well as two children node two

1088
00:46:13,680 --> 00:46:15,240
nodes and

1089
00:46:15,240 --> 00:46:17,400
nodes has its own local talk

1090
00:46:17,400 --> 00:46:19,020
so you can think about the local clock

1091
00:46:19,020 --> 00:46:21,420
as being the time the number of times

1092
00:46:21,420 --> 00:46:23,280
the forward data structure has been

1093
00:46:23,280 --> 00:46:25,140
invoked so that means that this is

1094
00:46:25,140 --> 00:46:26,819
actually a dynamic value and the gobler

1095
00:46:26,819 --> 00:46:28,140
does not know what this time is going to

1096
00:46:28,140 --> 00:46:30,420
be in advance

1097
00:46:30,420 --> 00:46:32,460
yeah so when it's in both the local time

1098
00:46:32,460 --> 00:46:33,540
it's going to increment so in this

1099
00:46:33,540 --> 00:46:35,460
example here the parent lower has been

1100
00:46:35,460 --> 00:46:37,740
invoked five times and then three have

1101
00:46:37,740 --> 00:46:39,240
been passed away and two up and pass to

1102
00:46:39,240 --> 00:46:40,680
the right so every note is keeping track

1103
00:46:40,680 --> 00:46:42,599
of its own local time and here it's

1104
00:46:42,599 --> 00:46:44,400
important to note that for the apparent

1105
00:46:44,400 --> 00:46:46,920
root node the parent local time is

1106
00:46:46,920 --> 00:46:48,780
actually just equivalent to the global

1107
00:46:48,780 --> 00:46:50,880
time since the parent is going to be the

1108
00:46:50,880 --> 00:46:52,859
root node is going to be invoked at

1109
00:46:52,859 --> 00:46:55,380
every time in the computation

1110
00:46:55,380 --> 00:46:58,020
so as we're passing down the beta data

1111
00:46:58,020 --> 00:46:59,880
payload down the tree the garbles our

1112
00:46:59,880 --> 00:47:01,140
payload must be the global

1113
00:47:01,140 --> 00:47:02,700
time-dependent language of that node

1114
00:47:02,700 --> 00:47:04,680
right so here for example if we think

1115
00:47:04,680 --> 00:47:06,119
about the orange node since the orange

1116
00:47:06,119 --> 00:47:07,500
node has already been in both three

1117
00:47:07,500 --> 00:47:09,660
times at the next indication is going to

1118
00:47:09,660 --> 00:47:12,119
expect the payload to be translated into

1119
00:47:12,119 --> 00:47:15,060
some language elsewhere

1120
00:47:15,060 --> 00:47:17,099
so to do this what we can do is we can

1121
00:47:17,099 --> 00:47:19,680
prepare two garble stocks of languages

1122
00:47:19,680 --> 00:47:22,079
um and this was introduced in the prior

1123
00:47:22,079 --> 00:47:24,319
work

1124
00:47:24,420 --> 00:47:27,300
so here we can prepare for four accesses

1125
00:47:27,300 --> 00:47:28,740
on the left and four axis is on the

1126
00:47:28,740 --> 00:47:30,060
right and note that the garbler in

1127
00:47:30,060 --> 00:47:32,819
advance does know how many times each of

1128
00:47:32,819 --> 00:47:34,140
the children are going to be involved

1129
00:47:34,140 --> 00:47:36,599
although he does not know at what uh

1130
00:47:36,599 --> 00:47:38,460
time dependent time is going to actually

1131
00:47:38,460 --> 00:47:40,980
be invoked right so when we receive some

1132
00:47:40,980 --> 00:47:43,380
value of the data payload as well as the

1133
00:47:43,380 --> 00:47:45,119
leaf address which is going to be passed

1134
00:47:45,119 --> 00:47:46,079
out

1135
00:47:46,079 --> 00:47:48,839
um so here I assume that uh the the data

1136
00:47:48,839 --> 00:47:50,819
is going to be passed to the left what

1137
00:47:50,819 --> 00:47:52,260
the parent node can do is it's going to

1138
00:47:52,260 --> 00:47:54,480
do a real pop off of the left stock and

1139
00:47:54,480 --> 00:47:56,160
it's going to do a fake pop off the

1140
00:47:56,160 --> 00:47:58,680
right side so here using the fake the

1141
00:47:58,680 --> 00:47:59,940
fake pop is just going to Output a

1142
00:47:59,940 --> 00:48:01,800
covering of zero well the real pop is

1143
00:48:01,800 --> 00:48:04,560
going to Output the language for which

1144
00:48:04,560 --> 00:48:07,440
the fail needs to be translated into

1145
00:48:07,440 --> 00:48:11,400
Now using this garbled uh uh garbled

1146
00:48:11,400 --> 00:48:13,260
language value what the parent node can

1147
00:48:13,260 --> 00:48:15,000
do is he can translate the data payload

1148
00:48:15,000 --> 00:48:17,640
into the compatible language for the

1149
00:48:17,640 --> 00:48:20,160
child and then pass that translate value

1150
00:48:20,160 --> 00:48:21,900
down to this on child and then that

1151
00:48:21,900 --> 00:48:23,220
child is going to recursively do that

1152
00:48:23,220 --> 00:48:24,660
all the way down the logarithmic number

1153
00:48:24,660 --> 00:48:26,960
of times

1154
00:48:27,240 --> 00:48:28,680
um the important thing to note here and

1155
00:48:28,680 --> 00:48:30,599
this is the main source of overhead for

1156
00:48:30,599 --> 00:48:32,579
the prior work is that

1157
00:48:32,579 --> 00:48:34,380
um the cost of doing apart from this

1158
00:48:34,380 --> 00:48:36,119
Global stack is logarithmic in the size

1159
00:48:36,119 --> 00:48:38,520
of the stock so for example in the root

1160
00:48:38,520 --> 00:48:39,839
node because the root node has a

1161
00:48:39,839 --> 00:48:42,119
provision for n accesses the cost of

1162
00:48:42,119 --> 00:48:46,260
this root node is going to be a log n

1163
00:48:46,260 --> 00:48:48,240
so now I'll briefly uh discuss our

1164
00:48:48,240 --> 00:48:50,640
techniques so there's two main sources

1165
00:48:50,640 --> 00:48:52,980
of inefficiencies here the first is the

1166
00:48:52,980 --> 00:48:54,420
fact that there's very large list of

1167
00:48:54,420 --> 00:48:55,980
switches that have to provision for a

1168
00:48:55,980 --> 00:48:58,020
large number of accesses so for example

1169
00:48:58,020 --> 00:48:59,579
as we just discussed for the root node

1170
00:48:59,579 --> 00:49:01,800
because the root node needs to provision

1171
00:49:01,800 --> 00:49:04,740
for an access fees that means that

1172
00:49:04,740 --> 00:49:06,359
there's going to be a log and overhead

1173
00:49:06,359 --> 00:49:08,579
on the root node and similarly for the

1174
00:49:08,579 --> 00:49:10,319
second layer of nodes they have to each

1175
00:49:10,319 --> 00:49:12,060
prepare for n over two and then n over

1176
00:49:12,060 --> 00:49:13,200
four Etc

1177
00:49:13,200 --> 00:49:15,119
um so this is going to cause very large

1178
00:49:15,119 --> 00:49:17,339
switches um in the C and that's actually

1179
00:49:17,339 --> 00:49:18,720
the main source of overhead for the

1180
00:49:18,720 --> 00:49:20,280
prior work

1181
00:49:20,280 --> 00:49:22,680
second we must pass a large very large

1182
00:49:22,680 --> 00:49:24,780
parallel links all the way down the tree

1183
00:49:24,780 --> 00:49:26,880
and in particular we have to pass a

1184
00:49:26,880 --> 00:49:28,800
logarithmic number of labels and each

1185
00:49:28,800 --> 00:49:30,359
label is a size in the security

1186
00:49:30,359 --> 00:49:33,300
parameter and note that we have to pass

1187
00:49:33,300 --> 00:49:34,920
the logs on number of labels because we

1188
00:49:34,920 --> 00:49:36,359
have to do a read from all of the

1189
00:49:36,359 --> 00:49:39,720
buckets and this is inherent in the for

1190
00:49:39,720 --> 00:49:42,300
entry Construction

1191
00:49:42,300 --> 00:49:44,880
Arkansas so our contributions as follows

1192
00:49:44,880 --> 00:49:47,640
the first is we have using prior work

1193
00:49:47,640 --> 00:49:49,680
and basically some uh insights from

1194
00:49:49,680 --> 00:49:51,780
bucket Orem construction we're able to

1195
00:49:51,780 --> 00:49:54,060
break up the switches into poly log size

1196
00:49:54,060 --> 00:49:55,740
switches and this allows us to actually

1197
00:49:55,740 --> 00:49:57,720
break down the log n overhead from the

1198
00:49:57,720 --> 00:49:59,460
priority into poly loss out and that's

1199
00:49:59,460 --> 00:50:00,839
where we are again

1200
00:50:00,839 --> 00:50:03,060
um some of our savings

1201
00:50:03,060 --> 00:50:05,040
second instead of passing a large

1202
00:50:05,040 --> 00:50:06,960
payload links um namely the logarithm

1203
00:50:06,960 --> 00:50:09,599
number of labels we use the an xor trick

1204
00:50:09,599 --> 00:50:11,099
that allows us to only pass a single

1205
00:50:11,099 --> 00:50:13,440
label so this allows us to reduce the

1206
00:50:13,440 --> 00:50:16,819
overhead dialogue Factor

1207
00:50:20,400 --> 00:50:23,400
so now I'll discuss the um now I'll

1208
00:50:23,400 --> 00:50:25,319
discuss the um our intuition behind

1209
00:50:25,319 --> 00:50:27,720
breaking up the buckets for the large uh

1210
00:50:27,720 --> 00:50:29,640
large switches

1211
00:50:29,640 --> 00:50:31,079
so

1212
00:50:31,079 --> 00:50:31,800
um

1213
00:50:31,800 --> 00:50:33,780
our intuition is as follows basically

1214
00:50:33,780 --> 00:50:35,640
for any of the large switches what we

1215
00:50:35,640 --> 00:50:36,900
want to do is break them down into

1216
00:50:36,900 --> 00:50:38,940
switches of smaller size and what we

1217
00:50:38,940 --> 00:50:41,880
realized is that we can associate each

1218
00:50:41,880 --> 00:50:43,140
of the larger switches with an

1219
00:50:43,140 --> 00:50:45,960
exponentially growing number of uh

1220
00:50:45,960 --> 00:50:48,240
buckets and switches so if we have an

1221
00:50:48,240 --> 00:50:50,700
orange tree uh as well as like this what

1222
00:50:50,700 --> 00:50:52,500
we can do is break down each of the

1223
00:50:52,500 --> 00:50:55,380
buckets into a logarithmic size

1224
00:50:55,380 --> 00:50:59,460
uh and use a static rebuilding uh static

1225
00:50:59,460 --> 00:51:01,140
rebuilding operation in order to make

1226
00:51:01,140 --> 00:51:04,319
sure that uh the bucket is always

1227
00:51:04,319 --> 00:51:06,180
positioned with

1228
00:51:06,180 --> 00:51:07,920
um enough labels for it to actually do

1229
00:51:07,920 --> 00:51:10,619
the computation so here what we see is

1230
00:51:10,619 --> 00:51:12,660
that on the lowest level which is the

1231
00:51:12,660 --> 00:51:14,640
root node the root node is going to be

1232
00:51:14,640 --> 00:51:17,040
rebuilt on every time step

1233
00:51:17,040 --> 00:51:19,280
on the second layer is going to be

1234
00:51:19,280 --> 00:51:21,839
rebuilt every two time steps and on the

1235
00:51:21,839 --> 00:51:23,520
third layer every four Concepts and so

1236
00:51:23,520 --> 00:51:25,380
on and so forth up the tree so we see

1237
00:51:25,380 --> 00:51:27,180
that the rebuilding is being done in a

1238
00:51:27,180 --> 00:51:29,400
in a hierarchical manner of the tree and

1239
00:51:29,400 --> 00:51:32,099
it allows us to break down the bucket

1240
00:51:32,099 --> 00:51:33,900
exercise of each of the levels to the

1241
00:51:33,900 --> 00:51:36,000
same size

1242
00:51:36,000 --> 00:51:38,220
so here instead of having a linear sized

1243
00:51:38,220 --> 00:51:41,339
switch that we saw in the charm SC each

1244
00:51:41,339 --> 00:51:43,500
of these switches here are only of uh

1245
00:51:43,500 --> 00:51:44,700
each of the buckets here are only

1246
00:51:44,700 --> 00:51:47,880
outside logarithmic and this is due due

1247
00:51:47,880 --> 00:51:50,520
to insights from the uh bucket orange

1248
00:51:50,520 --> 00:51:52,800
work

1249
00:51:52,800 --> 00:51:54,660
so now we have an idea of how to break

1250
00:51:54,660 --> 00:51:56,520
down the bucket into the smaller sizes

1251
00:51:56,520 --> 00:51:58,500
so now we need to

1252
00:51:58,500 --> 00:52:00,300
um have some rebuild operation that

1253
00:52:00,300 --> 00:52:02,400
allows us to actually do the refreshing

1254
00:52:02,400 --> 00:52:04,500
and reinitialization of the focus on

1255
00:52:04,500 --> 00:52:06,540
every time step

1256
00:52:06,540 --> 00:52:08,760
so what we see here is that if we had

1257
00:52:08,760 --> 00:52:10,140
all of the buckets on the first and

1258
00:52:10,140 --> 00:52:12,359
second level School

1259
00:52:12,359 --> 00:52:14,760
um every B times subs or B is the size

1260
00:52:14,760 --> 00:52:17,160
of the stash what we'll do is use a

1261
00:52:17,160 --> 00:52:19,920
hierarchical rebuild style operation

1262
00:52:19,920 --> 00:52:21,420
um and use that in order to do the

1263
00:52:21,420 --> 00:52:23,339
rebuilding of the tree so for example

1264
00:52:23,339 --> 00:52:24,839
here if both the first and the second

1265
00:52:24,839 --> 00:52:26,700
levels are filled what we're going to do

1266
00:52:26,700 --> 00:52:28,859
is rebuild these buckets into the third

1267
00:52:28,859 --> 00:52:29,579
level

1268
00:52:29,579 --> 00:52:31,319
and this is going to happen on every

1269
00:52:31,319 --> 00:52:33,359
beat Concepts and so it's very similar

1270
00:52:33,359 --> 00:52:37,078
to a hierarchical structure

1271
00:52:37,380 --> 00:52:39,599
so you might think that here we are done

1272
00:52:39,599 --> 00:52:42,660
because uh we have all our smaller

1273
00:52:42,660 --> 00:52:44,280
buckets and we have our rebuilding

1274
00:52:44,280 --> 00:52:45,720
operation that allows us to do the

1275
00:52:45,720 --> 00:52:48,180
rebuilding of the tree however there is

1276
00:52:48,180 --> 00:52:49,619
still an issue and this is due to the

1277
00:52:49,619 --> 00:52:50,819
fact that the rebuilds are actually

1278
00:52:50,819 --> 00:52:53,520
being Dynamic so although um the refills

1279
00:52:53,520 --> 00:52:55,140
are Dynamic so although we're able to

1280
00:52:55,140 --> 00:52:57,420
provision for the buckets at a static

1281
00:52:57,420 --> 00:52:59,819
time schedule we still do not the

1282
00:52:59,819 --> 00:53:02,040
garbage still does not know what the

1283
00:53:02,040 --> 00:53:03,780
accesses are going to be at propane time

1284
00:53:03,780 --> 00:53:06,240
so here's an example imagine if the

1285
00:53:06,240 --> 00:53:07,559
buckets are filled on this person's

1286
00:53:07,559 --> 00:53:09,059
their level and we're doing a rebuild of

1287
00:53:09,059 --> 00:53:12,119
the first level into the second

1288
00:53:12,119 --> 00:53:13,980
um these children have advanced to some

1289
00:53:13,980 --> 00:53:16,680
unknown local clock on unknown local

1290
00:53:16,680 --> 00:53:18,780
time because we do not actually know how

1291
00:53:18,780 --> 00:53:20,339
many accesses went to the left and how

1292
00:53:20,339 --> 00:53:22,559
many assets these went to the right

1293
00:53:22,559 --> 00:53:24,420
and the guard um there's no way for the

1294
00:53:24,420 --> 00:53:26,520
garbbler to actually account for this in

1295
00:53:26,520 --> 00:53:27,900
advance because these are random

1296
00:53:27,900 --> 00:53:29,640
accesses

1297
00:53:29,640 --> 00:53:31,619
so our solution is to equip all of our

1298
00:53:31,619 --> 00:53:33,240
garbled data structures with finalized

1299
00:53:33,240 --> 00:53:34,940
routines that allow us to actually

1300
00:53:34,940 --> 00:53:37,200
prepare the garble state required in

1301
00:53:37,200 --> 00:53:38,579
order to pass the necessary information

1302
00:53:38,579 --> 00:53:41,220
of the tree for the evaluator to

1303
00:53:41,220 --> 00:53:42,180
actually

1304
00:53:42,180 --> 00:53:45,180
um do the reinitialization locally

1305
00:53:45,180 --> 00:53:46,740
um so note that we can actually not use

1306
00:53:46,740 --> 00:53:48,839
any of the garbled data structures that

1307
00:53:48,839 --> 00:53:50,280
were designed in any of the prior work

1308
00:53:50,280 --> 00:53:52,440
in our scheme directly because of this

1309
00:53:52,440 --> 00:53:54,720
vitalization

1310
00:53:54,720 --> 00:53:56,339
so rather than doing the rebuild

1311
00:53:56,339 --> 00:53:58,680
directly what we can do is equip all of

1312
00:53:58,680 --> 00:54:01,079
our data structures with this finalized

1313
00:54:01,079 --> 00:54:02,880
routine so here

1314
00:54:02,880 --> 00:54:04,740
um preparing the parent node is going to

1315
00:54:04,740 --> 00:54:07,020
run the finalized routine at the time of

1316
00:54:07,020 --> 00:54:09,119
the rebuild uh at the time of the

1317
00:54:09,119 --> 00:54:12,480
rebuild and this will allow the paranoid

1318
00:54:12,480 --> 00:54:14,700
to prepare the garble state required and

1319
00:54:14,700 --> 00:54:16,140
pass these down to children and this

1320
00:54:16,140 --> 00:54:17,339
will allow the children to actually

1321
00:54:17,339 --> 00:54:20,400
prepare the necessary state in order to

1322
00:54:20,400 --> 00:54:20,940
um

1323
00:54:20,940 --> 00:54:23,579
I believe we initialize the buckets and

1324
00:54:23,579 --> 00:54:25,680
the switches on that level

1325
00:54:25,680 --> 00:54:27,960
so there's a bunch of other so this is a

1326
00:54:27,960 --> 00:54:29,280
very high level overview or construction

1327
00:54:29,280 --> 00:54:32,400
so um TCR paper for a more formal um

1328
00:54:32,400 --> 00:54:35,280
treatment but we also have um many other

1329
00:54:35,280 --> 00:54:36,780
additional optimizations that allow

1330
00:54:36,780 --> 00:54:39,960
allows us to design our products team so

1331
00:54:39,960 --> 00:54:41,819
for example we have a way of avoiding a

1332
00:54:41,819 --> 00:54:43,260
security parameter of blow up when we do

1333
00:54:43,260 --> 00:54:45,720
our government scheme um based on uh

1334
00:54:45,720 --> 00:54:47,819
depending on what we know about the

1335
00:54:47,819 --> 00:54:50,700
input second we have a nice modular

1336
00:54:50,700 --> 00:54:51,900
framework that allows us to actually

1337
00:54:51,900 --> 00:54:54,480
compose our proofs for the global data

1338
00:54:54,480 --> 00:54:56,520
structures in a nice modular way and

1339
00:54:56,520 --> 00:54:57,599
finally we have other practical

1340
00:54:57,599 --> 00:54:59,520
optimizations particularly with our use

1341
00:54:59,520 --> 00:55:01,380
of the buckets and the double switches

1342
00:55:01,380 --> 00:55:03,900
allows us to achieve more practical

1343
00:55:03,900 --> 00:55:05,220
performance

1344
00:55:05,220 --> 00:55:08,040
so finally I want to end with a graph of

1345
00:55:08,040 --> 00:55:10,020
the country performance here so here the

1346
00:55:10,020 --> 00:55:11,700
orange line is a linear scan so that

1347
00:55:11,700 --> 00:55:13,619
would just be the naive strawman of

1348
00:55:13,619 --> 00:55:16,260
being able to scan across the RAM and

1349
00:55:16,260 --> 00:55:18,839
the blue line here is the prior work

1350
00:55:18,839 --> 00:55:21,599
um so you see that as the size of our

1351
00:55:21,599 --> 00:55:23,700
memory grows larger we are actually able

1352
00:55:23,700 --> 00:55:25,859
to achieve a better performance on the

1353
00:55:25,859 --> 00:55:28,319
prior work and we do consider this to be

1354
00:55:28,319 --> 00:55:30,660
practical so there are um so we're

1355
00:55:30,660 --> 00:55:33,240
actually considering actually building

1356
00:55:33,240 --> 00:55:35,040
out this double around scheme and trying

1357
00:55:35,040 --> 00:55:36,480
to find some nice applications for it in

1358
00:55:36,480 --> 00:55:37,920
practice

1359
00:55:37,920 --> 00:55:39,839
um so with that I will end and take any

1360
00:55:39,839 --> 00:55:40,600
questions thank you

1361
00:55:40,600 --> 00:55:47,040
[Applause]

1362
00:55:47,040 --> 00:55:48,660
um thanks for the talk Andrew are there

1363
00:55:48,660 --> 00:55:50,960
questions

1364
00:55:52,559 --> 00:55:54,480
in the audience so since you're thinking

1365
00:55:54,480 --> 00:55:56,220
about actually implementing this so what

1366
00:55:56,220 --> 00:55:57,540
are the roadblocks that are in the way

1367
00:55:57,540 --> 00:55:59,940
for doing this um yes I think one of the

1368
00:55:59,940 --> 00:56:01,619
hardest things is the fact that the

1369
00:56:01,619 --> 00:56:03,599
evaluator actually needs to do all of

1370
00:56:03,599 --> 00:56:06,180
the wire soldering uh to runtime so as

1371
00:56:06,180 --> 00:56:07,619
we know in most scarful circuit

1372
00:56:07,619 --> 00:56:09,180
constructions the garble actually

1373
00:56:09,180 --> 00:56:12,680
prepares all of the gates in

1374
00:56:15,140 --> 00:56:17,880
output so here the evaluator actually

1375
00:56:17,880 --> 00:56:19,260
needs to do the soldering by themselves

1376
00:56:19,260 --> 00:56:20,880
right so we're only preparing for data

1377
00:56:20,880 --> 00:56:22,380
structures for them and then they have

1378
00:56:22,380 --> 00:56:23,579
to actually have to you know connect

1379
00:56:23,579 --> 00:56:26,040
them all together so that's actually a

1380
00:56:26,040 --> 00:56:27,599
pretty difficult when we're trying to

1381
00:56:27,599 --> 00:56:28,740
actually consider the implementation

1382
00:56:28,740 --> 00:56:29,819
yeah

1383
00:56:29,819 --> 00:56:31,800
thanks

1384
00:56:31,800 --> 00:56:35,720
so let's thank the speaker again and

1385
00:56:37,380 --> 00:56:39,660
we have a short 10 minute break to

1386
00:56:39,660 --> 00:56:42,440
switch tracks

