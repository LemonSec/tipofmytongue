1
00:00:00,080 --> 00:00:02,399
okay we can

2
00:00:02,399 --> 00:00:04,480
we can move forward to our next speaker

3
00:00:04,480 --> 00:00:07,279
um vinod by contacting

4
00:00:07,279 --> 00:00:09,200
uh vinod is a professor of computer

5
00:00:09,200 --> 00:00:11,200
science at mit and the chief

6
00:00:11,200 --> 00:00:14,080
cryptographer of duality technologies

7
00:00:14,080 --> 00:00:16,640
uh vinod is the co-inventor of most

8
00:00:16,640 --> 00:00:19,520
modern foodinomorphic encryption systems

9
00:00:19,520 --> 00:00:21,119
and many other lattice-based

10
00:00:21,119 --> 00:00:22,960
post-quantum secure cryptographic

11
00:00:22,960 --> 00:00:24,240
primitives

12
00:00:24,240 --> 00:00:26,160
and we nod will talk about secure

13
00:00:26,160 --> 00:00:28,560
computation and ppml

14
00:00:28,560 --> 00:00:31,599
progress and challenges

15
00:00:31,599 --> 00:00:33,680
we are very happy to have you here

16
00:00:33,680 --> 00:00:35,280
thank you gilad and uh thanks to

17
00:00:35,280 --> 00:00:37,520
antigone and you and rafi for for

18
00:00:37,520 --> 00:00:39,920
inviting me uh let me first try to share

19
00:00:39,920 --> 00:00:44,760
my uh screen uh yeah

20
00:00:49,360 --> 00:00:53,360
um is that uh let's see

21
00:00:53,760 --> 00:00:57,239
share screen

22
00:01:04,239 --> 00:01:07,040
everybody can see it

23
00:01:07,040 --> 00:01:09,600
okay good and everybody can hear me i

24
00:01:09,600 --> 00:01:11,520
suppose yeah that's good okay all right

25
00:01:11,520 --> 00:01:14,159
so um so so thanks guys for for inviting

26
00:01:14,159 --> 00:01:17,280
me um uh the title is uh is is a little

27
00:01:17,280 --> 00:01:18,880
bit zero knowledge because i didn't know

28
00:01:18,880 --> 00:01:21,040
for a long time what i wanted to uh talk

29
00:01:21,040 --> 00:01:25,280
about um uh and but but here here it is

30
00:01:25,280 --> 00:01:26,400
uh

31
00:01:26,400 --> 00:01:28,880
one second

32
00:01:28,880 --> 00:01:31,840
as i'm still not that used to uh

33
00:01:31,840 --> 00:01:32,880
um

34
00:01:32,880 --> 00:01:34,240
zoom

35
00:01:34,240 --> 00:01:37,119
all right okay good so um so i wanna so

36
00:01:37,119 --> 00:01:39,360
this talk is in two parts uh the first

37
00:01:39,360 --> 00:01:41,759
one will fall squarely in the realm of

38
00:01:41,759 --> 00:01:44,000
secure computation and uh and what uh

39
00:01:44,000 --> 00:01:45,920
what i'll do is i'll talk about

40
00:01:45,920 --> 00:01:48,079
a new technique in realm of homomorphic

41
00:01:48,079 --> 00:01:49,439
encryption

42
00:01:49,439 --> 00:01:51,360
and its application to constructing what

43
00:01:51,360 --> 00:01:54,000
we call asymptotically quasi-optimal

44
00:01:54,000 --> 00:01:56,000
batch ole which is oblivious linear

45
00:01:56,000 --> 00:01:58,079
evaluation and ot which is oblivious

46
00:01:58,079 --> 00:01:59,920
transfer and this is in joint work with

47
00:01:59,920 --> 00:02:01,920
leo de castro iowa shai

48
00:02:01,920 --> 00:02:03,759
uh karmic hazary and matu banker

49
00:02:03,759 --> 00:02:06,320
subramaniam

50
00:02:06,960 --> 00:02:08,479
and this sort of picture this sort of

51
00:02:08,479 --> 00:02:10,318
the picture you should think of is so

52
00:02:10,318 --> 00:02:12,239
there's two beautiful worlds you know

53
00:02:12,239 --> 00:02:14,000
there's a secure computation world which

54
00:02:14,000 --> 00:02:16,239
we inhabit as cryptographers and there's

55
00:02:16,239 --> 00:02:18,560
this promised land of privacy preserving

56
00:02:18,560 --> 00:02:20,400
machine learning and there is a sort of

57
00:02:20,400 --> 00:02:22,000
bridge between the two walls you're

58
00:02:22,000 --> 00:02:25,280
using one you can get to the other

59
00:02:25,280 --> 00:02:27,520
the second part of the talk uh i'll

60
00:02:27,520 --> 00:02:30,000
switch gears and i'll actually

61
00:02:30,000 --> 00:02:32,959
talk about gaps between uh the two

62
00:02:32,959 --> 00:02:34,720
fields gaps between sort of secure

63
00:02:34,720 --> 00:02:36,319
computational privacy preserving machine

64
00:02:36,319 --> 00:02:37,760
learning this is something that i've

65
00:02:37,760 --> 00:02:39,519
been thinking about for uh for a while

66
00:02:39,519 --> 00:02:41,680
and i'll i won't have much in terms of

67
00:02:41,680 --> 00:02:43,599
technical sort of details here to give

68
00:02:43,599 --> 00:02:46,080
you but all i'll have is

69
00:02:46,080 --> 00:02:47,519
open problems

70
00:02:47,519 --> 00:02:49,360
in fact a lot of open problems and this

71
00:02:49,360 --> 00:02:51,360
will what i talk about here will be

72
00:02:51,360 --> 00:02:53,280
based on observations with uh itai

73
00:02:53,280 --> 00:02:54,879
berman and akshay degwicker with

74
00:02:54,879 --> 00:02:57,760
students of mine and sharpie callback

75
00:02:57,760 --> 00:03:01,680
okay so let's uh let's let's get started

76
00:03:01,680 --> 00:03:03,599
um let's start with secure computation

77
00:03:03,599 --> 00:03:05,280
you've heard a great deal about it

78
00:03:05,280 --> 00:03:07,519
already uh today but just to set the

79
00:03:07,519 --> 00:03:09,280
stage we'll be talking about secure

80
00:03:09,280 --> 00:03:11,280
two-party computation uh where you have

81
00:03:11,280 --> 00:03:14,159
two parties are listened uh bob

82
00:03:14,159 --> 00:03:16,640
um who have their own private data sets

83
00:03:16,640 --> 00:03:18,400
d1 and d2 they want to compute some

84
00:03:18,400 --> 00:03:20,400
function on the two days that's f of t1

85
00:03:20,400 --> 00:03:22,480
comma d2 and they want to do it without

86
00:03:22,480 --> 00:03:24,080
either party revealing anything about

87
00:03:24,080 --> 00:03:26,239
their data to the other okay so this is

88
00:03:26,239 --> 00:03:27,840
this is what we are all sort of familiar

89
00:03:27,840 --> 00:03:30,480
with in cryptography

90
00:03:30,480 --> 00:03:31,920
um of course there are other

91
00:03:31,920 --> 00:03:33,440
architectures there are multi-party

92
00:03:33,440 --> 00:03:35,519
architectures peer-to-peer client asset

93
00:03:35,519 --> 00:03:37,280
client client server or what what's

94
00:03:37,280 --> 00:03:39,120
called fed rated uh these days which you

95
00:03:39,120 --> 00:03:41,360
already just heard about uh in the

96
00:03:41,360 --> 00:03:44,000
previous talk

97
00:03:44,480 --> 00:03:47,360
um one of the most sort of innovative

98
00:03:47,360 --> 00:03:49,280
contributions of the field of

99
00:03:49,280 --> 00:03:52,239
cryptography uh in the 1980s was one the

100
00:03:52,239 --> 00:03:54,480
definition of this problem and two a

101
00:03:54,480 --> 00:03:56,400
definition of what it means for such a

102
00:03:56,400 --> 00:03:58,319
protocol to be secure and that was

103
00:03:58,319 --> 00:04:01,519
defined using that that's the ideal real

104
00:04:01,519 --> 00:04:03,439
paradigm uh what's called ideal drill

105
00:04:03,439 --> 00:04:05,040
paradigm these days

106
00:04:05,040 --> 00:04:07,360
um and what that says is the following

107
00:04:07,360 --> 00:04:08,879
so think of a

108
00:04:08,879 --> 00:04:11,599
an adversary that corrupts one

109
00:04:11,599 --> 00:04:13,439
or in the multi-party setting a subset

110
00:04:13,439 --> 00:04:14,560
of parties

111
00:04:14,560 --> 00:04:16,399
and this adversary could be either semi

112
00:04:16,399 --> 00:04:18,079
honest or malicious or somewhere in

113
00:04:18,079 --> 00:04:19,199
between

114
00:04:19,199 --> 00:04:21,600
um and

115
00:04:21,600 --> 00:04:23,520
and so ideal real paradigm tells you

116
00:04:23,520 --> 00:04:25,919
what it means for such a protocol to be

117
00:04:25,919 --> 00:04:27,919
secure against against an adversary of

118
00:04:27,919 --> 00:04:29,840
this woman what uh what we say is you

119
00:04:29,840 --> 00:04:32,160
know whatever the adversary sees in this

120
00:04:32,160 --> 00:04:34,000
execution of this protocol whatever the

121
00:04:34,000 --> 00:04:35,360
abstract can do

122
00:04:35,360 --> 00:04:37,199
in the execution of this protocol it

123
00:04:37,199 --> 00:04:40,000
should also be doable and seeable by an

124
00:04:40,000 --> 00:04:42,800
ideal adversary called the simulator

125
00:04:42,800 --> 00:04:44,720
which does not talk to the parties at

126
00:04:44,720 --> 00:04:47,360
all but rather interacts uh with an

127
00:04:47,360 --> 00:04:49,680
ideal sort of oracle with an oracle that

128
00:04:49,680 --> 00:04:51,520
actually computes the functions for them

129
00:04:51,520 --> 00:04:54,400
so the ideal adversary can only

130
00:04:54,400 --> 00:04:57,360
pick the inputs um

131
00:04:57,360 --> 00:04:59,520
send it to the oracle and you can see

132
00:04:59,520 --> 00:05:02,560
the outputs but that's it okay so that

133
00:05:02,560 --> 00:05:04,479
seems pretty benign and you say well you

134
00:05:04,479 --> 00:05:06,240
know if the real protocol is as good as

135
00:05:06,240 --> 00:05:08,639
this ideal world then you know that's

136
00:05:08,639 --> 00:05:11,520
good right so this is a mathematically

137
00:05:11,520 --> 00:05:13,120
precise definition

138
00:05:13,120 --> 00:05:15,199
it has really sort of shown the light

139
00:05:15,199 --> 00:05:17,440
for much of the really all the work in

140
00:05:17,440 --> 00:05:19,600
this field uh over the past uh i don't

141
00:05:19,600 --> 00:05:24,240
know 30 35 40 years right

142
00:05:24,240 --> 00:05:26,720
um yeah you could sort of define it for

143
00:05:26,720 --> 00:05:29,120
both parties and for collusion bodies

144
00:05:29,120 --> 00:05:31,440
and we now have a ton of techniques uh

145
00:05:31,440 --> 00:05:32,960
to construct secure computation

146
00:05:32,960 --> 00:05:34,560
protocols you you heard a great deal

147
00:05:34,560 --> 00:05:36,479
about it in yuval's talk

148
00:05:36,479 --> 00:05:39,280
um and you know uh you know in my mind

149
00:05:39,280 --> 00:05:41,199
you know i need an organization system

150
00:05:41,199 --> 00:05:43,360
to to keep track of sort of the kitchen

151
00:05:43,360 --> 00:05:45,520
sync of protocols so i divide it into

152
00:05:45,520 --> 00:05:48,720
sort of the 20th century uh protocols

153
00:05:48,720 --> 00:05:50,960
uh which are sort of the garbage circuit

154
00:05:50,960 --> 00:05:53,440
protocol and the gold rack mikali with

155
00:05:53,440 --> 00:05:55,039
distant protocol and and a lot of

156
00:05:55,039 --> 00:05:57,759
derivatives of these protocols um you

157
00:05:57,759 --> 00:06:00,319
know um that we have uh

158
00:06:00,319 --> 00:06:03,039
that we've come up with uh since then

159
00:06:03,039 --> 00:06:04,240
um

160
00:06:04,240 --> 00:06:06,720
and um

161
00:06:06,720 --> 00:06:07,680
um

162
00:06:07,680 --> 00:06:10,880
and uh and and cryptopia 21st century

163
00:06:10,880 --> 00:06:13,919
crypto uh which uses sort of fancy tools

164
00:06:13,919 --> 00:06:15,680
like fully homomorphic encryption or

165
00:06:15,680 --> 00:06:17,759
threshold fully homomorphic encryption

166
00:06:17,759 --> 00:06:20,400
um and even more recently homomorphic

167
00:06:20,400 --> 00:06:23,280
secret sharing and related and friends

168
00:06:23,280 --> 00:06:24,160
um

169
00:06:24,160 --> 00:06:26,080
to construct secure computation protocol

170
00:06:26,080 --> 00:06:27,840
so this is really a sort of modern

171
00:06:27,840 --> 00:06:32,400
development the last sort of 10 12 years

172
00:06:32,400 --> 00:06:34,479
um and again in my mind i need an

173
00:06:34,479 --> 00:06:37,840
organization system so i kind of try to

174
00:06:37,840 --> 00:06:40,720
find out what are the trade-offs what

175
00:06:40,720 --> 00:06:42,400
are the relations and trade-offs between

176
00:06:42,400 --> 00:06:44,000
these different techniques and i have a

177
00:06:44,000 --> 00:06:46,479
very sort of like um

178
00:06:46,479 --> 00:06:47,360
uh

179
00:06:47,360 --> 00:06:49,360
rough sort of line between them and uh

180
00:06:49,360 --> 00:06:52,240
you heard some of it from yuval already

181
00:06:52,240 --> 00:06:53,599
um

182
00:06:53,599 --> 00:06:56,479
the 20th century crypto techniques um

183
00:06:56,479 --> 00:06:59,680
are are great at computation so

184
00:06:59,680 --> 00:07:02,639
other than a few in in fact input size

185
00:07:02,639 --> 00:07:04,720
many uh oblivious transfers at least in

186
00:07:04,720 --> 00:07:06,880
the case of carbon circuits um or

187
00:07:06,880 --> 00:07:08,720
pre-processing in the case of the gmw

188
00:07:08,720 --> 00:07:09,840
protocol

189
00:07:09,840 --> 00:07:11,120
you can do the rest of it either

190
00:07:11,120 --> 00:07:13,440
information theoretically or just using

191
00:07:13,440 --> 00:07:15,440
uh aes sort of one-way functions mini

192
00:07:15,440 --> 00:07:18,560
correct right

193
00:07:19,280 --> 00:07:21,280
that's exactly where the modern

194
00:07:21,280 --> 00:07:23,919
techniques sort of uh fall short uh

195
00:07:23,919 --> 00:07:25,599
their computational complexity is super

196
00:07:25,599 --> 00:07:27,199
super high fully homomorphic encryption

197
00:07:27,199 --> 00:07:28,880
is famous and notorious for being

198
00:07:28,880 --> 00:07:30,720
computationally very complex

199
00:07:30,720 --> 00:07:32,400
on the other hand foliomorphic

200
00:07:32,400 --> 00:07:33,919
encryption and fss and homomorphic

201
00:07:33,919 --> 00:07:36,319
signal sharing um give you great sort of

202
00:07:36,319 --> 00:07:38,000
communication complexity essentially

203
00:07:38,000 --> 00:07:39,840
proportional to the input length

204
00:07:39,840 --> 00:07:43,280
um and not always but uh but but uh but

205
00:07:43,280 --> 00:07:46,319
sometimes uh but their communication but

206
00:07:46,319 --> 00:07:49,280
uh um uh but the communication

207
00:07:49,280 --> 00:07:51,199
complexity of the 20 20th century crypto

208
00:07:51,199 --> 00:07:52,960
protocols is typically proportional to

209
00:07:52,960 --> 00:07:54,560
the circuit size uh which is a lot

210
00:07:54,560 --> 00:07:55,680
larger

211
00:07:55,680 --> 00:07:57,039
all right so so communication versus

212
00:07:57,039 --> 00:07:58,720
computation is what separates 20th

213
00:07:58,720 --> 00:08:00,240
century from uh is one of the things

214
00:08:00,240 --> 00:08:02,080
that separates 20th century from 20th

215
00:08:02,080 --> 00:08:05,039
century so one thing that um uh is sort

216
00:08:05,039 --> 00:08:06,879
of worth remembering is that this line

217
00:08:06,879 --> 00:08:10,240
is not a dogma by any means right so you

218
00:08:10,240 --> 00:08:13,599
know you have a set of tools and you can

219
00:08:13,599 --> 00:08:16,560
combine them in any possible way you can

220
00:08:16,560 --> 00:08:17,840
you don't have to sort of when you're

221
00:08:17,840 --> 00:08:19,440
designing a secure computation protocol

222
00:08:19,440 --> 00:08:20,639
you don't need to stick to garbage

223
00:08:20,639 --> 00:08:21,919
circuits so you don't need to stick to

224
00:08:21,919 --> 00:08:24,639
threshold fhe you can really combine the

225
00:08:24,639 --> 00:08:26,560
slew of techniques you have

226
00:08:26,560 --> 00:08:28,240
that's something that people have done

227
00:08:28,240 --> 00:08:30,319
uh and i i'm really here going to focus

228
00:08:30,319 --> 00:08:31,840
on homomorphic encryption people have

229
00:08:31,840 --> 00:08:34,320
sort of come up with various ways to use

230
00:08:34,320 --> 00:08:36,880
lattice-based homomorphic encryption not

231
00:08:36,880 --> 00:08:38,479
necessarily for homomorphic just

232
00:08:38,479 --> 00:08:40,719
homomorphic encryption in a

233
00:08:40,719 --> 00:08:43,360
sparingly sparingly and in a judicious

234
00:08:43,360 --> 00:08:44,480
way so that's something that people have

235
00:08:44,480 --> 00:08:46,720
done quite a bit over the last decade

236
00:08:46,720 --> 00:08:49,519
uh perhaps the so the first such result

237
00:08:49,519 --> 00:08:50,720
is um

238
00:08:50,720 --> 00:08:54,080
is the speeds protocol um of gum tam got

239
00:08:54,080 --> 00:08:54,800
it

240
00:08:54,800 --> 00:08:56,880
um and they used sort of homomorphic

241
00:08:56,880 --> 00:08:58,160
encryption to generate sort of

242
00:08:58,160 --> 00:09:00,240
multiplication triples uh which is sort

243
00:09:00,240 --> 00:09:01,839
of something that you can use down the

244
00:09:01,839 --> 00:09:05,920
line uh in secure computation protocols

245
00:09:05,920 --> 00:09:07,920
um private information retrieval is yet

246
00:09:07,920 --> 00:09:09,279
another place where people have used

247
00:09:09,279 --> 00:09:11,120
sort of like um

248
00:09:11,120 --> 00:09:12,480
limited versions of homomorphic

249
00:09:12,480 --> 00:09:14,320
encryption to which uh to already sort

250
00:09:14,320 --> 00:09:16,720
of construct uh pretty good protocols

251
00:09:16,720 --> 00:09:19,200
um more to the point of this workshop um

252
00:09:19,200 --> 00:09:21,040
um you know uh

253
00:09:21,040 --> 00:09:23,360
we sort of uh constructed this uh system

254
00:09:23,360 --> 00:09:25,920
called gazelle uh which can actually do

255
00:09:25,920 --> 00:09:28,320
uh secure two-party uh inference for

256
00:09:28,320 --> 00:09:29,839
convolutional neural networks a few

257
00:09:29,839 --> 00:09:31,600
years ago

258
00:09:31,600 --> 00:09:33,600
um and it is along these lines that i

259
00:09:33,600 --> 00:09:35,200
the first part of my talk will go we

260
00:09:35,200 --> 00:09:36,720
will actually i will show you a

261
00:09:36,720 --> 00:09:39,440
construction of bachelorette bachelor t

262
00:09:39,440 --> 00:09:41,440
by using the machinery of lattice-based

263
00:09:41,440 --> 00:09:43,120
homomorphic encryption but in a sort of

264
00:09:43,120 --> 00:09:45,680
a careful and judicious way and along

265
00:09:45,680 --> 00:09:46,800
the lines we will actually need to

266
00:09:46,800 --> 00:09:48,640
develop new techniques for lattice-based

267
00:09:48,640 --> 00:09:50,480
homomorphic

268
00:09:50,480 --> 00:09:52,399
okay so that's the point of the first

269
00:09:52,399 --> 00:09:53,839
part of the talk

270
00:09:53,839 --> 00:09:54,720
um

271
00:09:54,720 --> 00:09:57,920
and before i sort of really get to it um

272
00:09:57,920 --> 00:09:59,600
i have to sort of set the stage and uh

273
00:09:59,600 --> 00:10:01,519
and let me do it by telling you what the

274
00:10:01,519 --> 00:10:03,440
homomorphic encryption instruction set

275
00:10:03,440 --> 00:10:05,600
is right so this is you don't have to

276
00:10:05,600 --> 00:10:07,680
know necessarily the mathematics or the

277
00:10:07,680 --> 00:10:08,800
lattices

278
00:10:08,800 --> 00:10:10,399
or even bring out the bui sort of

279
00:10:10,399 --> 00:10:12,399
underlying uh homomorphic encryption

280
00:10:12,399 --> 00:10:14,720
schemes um all you need to know is that

281
00:10:14,720 --> 00:10:16,959
homomorphic encryption deals with

282
00:10:16,959 --> 00:10:18,399
at least sort of modern homomorphic

283
00:10:18,399 --> 00:10:20,560
encryption schemes from bring lwe

284
00:10:20,560 --> 00:10:22,640
ring learning with errors deals with

285
00:10:22,640 --> 00:10:25,120
data that are vectors

286
00:10:25,120 --> 00:10:27,519
uh so the data is an element of z p to

287
00:10:27,519 --> 00:10:30,640
the n where p is a plaintext domain and

288
00:10:30,640 --> 00:10:33,120
uh zp to the end sort of a vectors that

289
00:10:33,120 --> 00:10:34,880
represents a vector a vector of uh

290
00:10:34,880 --> 00:10:36,399
plaintext from z

291
00:10:36,399 --> 00:10:37,760
all right so just really think about n

292
00:10:37,760 --> 00:10:40,480
as being large largest 10 to the three a

293
00:10:40,480 --> 00:10:42,959
thousand ten thousand can maybe even go

294
00:10:42,959 --> 00:10:45,519
further and p should be pretty small uh

295
00:10:45,519 --> 00:10:46,800
it's two to the eighth so eight bits or

296
00:10:46,800 --> 00:10:49,600
16 bits are 32 bits right knocks

297
00:10:49,600 --> 00:10:52,079
20 48 bits or 4096 bits that you're used

298
00:10:52,079 --> 00:10:54,000
to in higher or other additively

299
00:10:54,000 --> 00:10:56,000
homomorphic options

300
00:10:56,000 --> 00:10:57,680
okay so those are the data types those

301
00:10:57,680 --> 00:10:58,560
are the data that i'm going to

302
00:10:58,560 --> 00:11:00,640
manipulate i encrypt and manipulate with

303
00:11:00,640 --> 00:11:02,480
morphe construction i'm going to denote

304
00:11:02,480 --> 00:11:05,120
sort of encrypted vector a by you know

305
00:11:05,120 --> 00:11:07,600
these square brackets okay

306
00:11:07,600 --> 00:11:09,279
so what is the instruction set uh

307
00:11:09,279 --> 00:11:10,720
homomorphic encryption gives you a way

308
00:11:10,720 --> 00:11:11,440
to

309
00:11:11,440 --> 00:11:12,560
add

310
00:11:12,560 --> 00:11:15,680
numbers so sim d is uh

311
00:11:15,680 --> 00:11:17,120
single instruction multiple data just in

312
00:11:17,120 --> 00:11:18,959
parallel right

313
00:11:18,959 --> 00:11:20,320
so you can take two vectors a and b

314
00:11:20,320 --> 00:11:22,480
encrypted they can construct a vector a

315
00:11:22,480 --> 00:11:24,720
plus b you can also construct you can

316
00:11:24,720 --> 00:11:26,880
also take a plain text a and encrypted b

317
00:11:26,880 --> 00:11:29,519
and construct a times b where a times b

318
00:11:29,519 --> 00:11:31,839
here denotes coordinate wise product of

319
00:11:31,839 --> 00:11:33,760
two vectors

320
00:11:33,760 --> 00:11:35,440
another thing that turns out to be super

321
00:11:35,440 --> 00:11:37,600
useful in using uh homomorphic

322
00:11:37,600 --> 00:11:39,040
encryption is slot permutations when

323
00:11:39,040 --> 00:11:40,320
you're dealing with vectors you might

324
00:11:40,320 --> 00:11:42,000
want to move these elements of these

325
00:11:42,000 --> 00:11:44,480
vectors uh you know uh to different

326
00:11:44,480 --> 00:11:46,160
slots and that's something you can do as

327
00:11:46,160 --> 00:11:48,399
well um so you can take a an encryption

328
00:11:48,399 --> 00:11:50,320
of a vector a you can take a permutation

329
00:11:50,320 --> 00:11:52,399
and you can construct an encryption of

330
00:11:52,399 --> 00:11:54,800
the permuted vector a

331
00:11:54,800 --> 00:11:56,720
okay then finally the final thing is

332
00:11:56,720 --> 00:11:58,079
simply multiplication which is which

333
00:11:58,079 --> 00:11:59,839
just sort of takes two cipher text and

334
00:11:59,839 --> 00:12:01,920
computes the sort of coordinate by

335
00:12:01,920 --> 00:12:04,000
product of the second text okay so these

336
00:12:04,000 --> 00:12:05,920
are the instructions we have at hand and

337
00:12:05,920 --> 00:12:09,200
by now we actually know pretty well

338
00:12:09,200 --> 00:12:11,200
you know how the complexity of these

339
00:12:11,200 --> 00:12:12,880
instructions relate to each other so

340
00:12:12,880 --> 00:12:14,639
this is a table that i'm sort of you

341
00:12:14,639 --> 00:12:16,480
know lifting uh sort of directly from

342
00:12:16,480 --> 00:12:18,079
the gazelle paper that we wrote a few

343
00:12:18,079 --> 00:12:19,519
years ago

344
00:12:19,519 --> 00:12:21,120
and there we actually came up with micro

345
00:12:21,120 --> 00:12:22,560
benchmarks for this application for

346
00:12:22,560 --> 00:12:24,320
these instructions in fact there it

347
00:12:24,320 --> 00:12:25,680
turned out that we didn't have to use

348
00:12:25,680 --> 00:12:27,200
simply multiplication so all you see

349
00:12:27,200 --> 00:12:29,279
here are numbers for addition scalar

350
00:12:29,279 --> 00:12:31,279
multiplication and permutations

351
00:12:31,279 --> 00:12:33,519
um so you know just sort of eyeballing

352
00:12:33,519 --> 00:12:35,360
the numbers you see that simply addition

353
00:12:35,360 --> 00:12:38,079
is super cheap uh right first slot you

354
00:12:38,079 --> 00:12:40,000
spend eight cycles right eight clock

355
00:12:40,000 --> 00:12:41,200
cycles

356
00:12:41,200 --> 00:12:43,279
um multiplication scalar multiplication

357
00:12:43,279 --> 00:12:45,120
is slightly more expensive but still

358
00:12:45,120 --> 00:12:46,320
very well within the realm of

359
00:12:46,320 --> 00:12:48,880
feasibility 15 clock cycles

360
00:12:48,880 --> 00:12:50,480
and then when you go to sort of you know

361
00:12:50,480 --> 00:12:52,480
the other two operations you start

362
00:12:52,480 --> 00:12:54,240
seeing the

363
00:12:54,240 --> 00:12:57,519
so the overheads that fhe or homomorphic

364
00:12:57,519 --> 00:13:00,160
encryption is so infamous for

365
00:13:00,160 --> 00:13:02,480
um so permutations it turns out are very

366
00:13:02,480 --> 00:13:04,320
useful when you do things like matrix

367
00:13:04,320 --> 00:13:06,720
factor multiplications uh and for that

368
00:13:06,720 --> 00:13:08,399
you pay well depending on sort of which

369
00:13:08,399 --> 00:13:09,760
setting you're in you see widely

370
00:13:09,760 --> 00:13:10,720
different numbers from the right-hand

371
00:13:10,720 --> 00:13:13,040
side and that tells you sort of you know

372
00:13:13,040 --> 00:13:14,560
you know that differs based on what

373
00:13:14,560 --> 00:13:15,680
class of permutations you want to

374
00:13:15,680 --> 00:13:17,600
support really all permutations or just

375
00:13:17,600 --> 00:13:20,079
rotations and so on and so forth um and

376
00:13:20,079 --> 00:13:21,920
that could cost you up to two orders of

377
00:13:21,920 --> 00:13:23,200
magnitude two to three hours of

378
00:13:23,200 --> 00:13:26,800
magnitude really um uh in in the runtime

379
00:13:26,800 --> 00:13:28,240
multiplication is not something that i

380
00:13:28,240 --> 00:13:30,000
have numbers for but that again is of

381
00:13:30,000 --> 00:13:31,200
the same sort of

382
00:13:31,200 --> 00:13:32,800
order of magnitude slowdown just two to

383
00:13:32,800 --> 00:13:35,360
three hours of magnitude

384
00:13:35,360 --> 00:13:36,800
right

385
00:13:36,800 --> 00:13:39,360
so that's what we have at our disposal

386
00:13:39,360 --> 00:13:41,279
and i'm going to call an encryption

387
00:13:41,279 --> 00:13:42,720
scheme which just supports additions and

388
00:13:42,720 --> 00:13:45,360
scalar multiplications cmd

389
00:13:45,360 --> 00:13:47,040
as a packed additive homomorphic

390
00:13:47,040 --> 00:13:49,360
encryption if you want to do that plus

391
00:13:49,360 --> 00:13:52,079
permutations i'm going to call it uh

392
00:13:52,079 --> 00:13:53,600
packed allegedly homophobic encryption

393
00:13:53,600 --> 00:13:55,120
with permutations okay so these are

394
00:13:55,120 --> 00:13:56,720
really the sort of the components that

395
00:13:56,720 --> 00:13:58,720
i'll use in fact in this talk i will

396
00:13:58,720 --> 00:14:00,079
only need additions and scalar

397
00:14:00,079 --> 00:14:01,519
multiplications that's good enough for

398
00:14:01,519 --> 00:14:03,920
me right those are the good operations

399
00:14:03,920 --> 00:14:05,120
those are the ones that actually run

400
00:14:05,120 --> 00:14:07,440
fast

401
00:14:07,839 --> 00:14:10,399
so these works that i that i referenced

402
00:14:10,399 --> 00:14:12,399
a couple of slides ago they actually use

403
00:14:12,399 --> 00:14:14,320
sort of limited certain market

404
00:14:14,320 --> 00:14:15,680
encryption schemes to do very

405
00:14:15,680 --> 00:14:17,760
interesting things uh speeds for example

406
00:14:17,760 --> 00:14:19,360
uses homomorphic encryption it supports

407
00:14:19,360 --> 00:14:20,480
one multiplication just a single

408
00:14:20,480 --> 00:14:22,000
multiplication

409
00:14:22,000 --> 00:14:23,600
uh the private information retrieval

410
00:14:23,600 --> 00:14:27,120
protocols um the clpr uses uh um you

411
00:14:27,120 --> 00:14:28,320
know

412
00:14:28,320 --> 00:14:29,760
additive packed additive homomorphic

413
00:14:29,760 --> 00:14:31,839
encryption plus rotations uh to

414
00:14:31,839 --> 00:14:34,480
essentially implement the old sort of 20

415
00:14:34,480 --> 00:14:36,000
you know 20 uh

416
00:14:36,000 --> 00:14:38,480
20 years old uh kushner levitz ostrovsky

417
00:14:38,480 --> 00:14:40,480
protocol for pierre

418
00:14:40,480 --> 00:14:42,079
uh and there are more recent works that

419
00:14:42,079 --> 00:14:43,279
actually take these sort of different

420
00:14:43,279 --> 00:14:45,120
approaches to peer and actually try to

421
00:14:45,120 --> 00:14:47,040
compare their performances in different

422
00:14:47,040 --> 00:14:49,199
ranges of parameters uh so multiplayer

423
00:14:49,199 --> 00:14:51,519
is a work that appeared a couple of

424
00:14:51,519 --> 00:14:53,519
weeks ago in houston security and that's

425
00:14:53,519 --> 00:14:56,000
yet another example

426
00:14:56,000 --> 00:14:57,839
in the cnn inference paper we used

427
00:14:57,839 --> 00:14:59,760
additive homomorphic encryption plus uh

428
00:14:59,760 --> 00:15:00,959
permutations and we had to use

429
00:15:00,959 --> 00:15:02,639
permutations there to implement linear

430
00:15:02,639 --> 00:15:03,920
layers you needed matrix vector

431
00:15:03,920 --> 00:15:06,000
multiplication there

432
00:15:06,000 --> 00:15:07,920
and you know this the first part of this

433
00:15:07,920 --> 00:15:09,680
talk will go along much very much along

434
00:15:09,680 --> 00:15:11,519
these lines and i'll show you how to use

435
00:15:11,519 --> 00:15:13,279
sort of additively homomorphic

436
00:15:13,279 --> 00:15:15,199
interruption without the permutations uh

437
00:15:15,199 --> 00:15:18,560
to construct a new batch only scheme

438
00:15:18,560 --> 00:15:19,839
okay so that's the first part of the

439
00:15:19,839 --> 00:15:21,120
talk

440
00:15:21,120 --> 00:15:24,160
um actually let me uh there are

441
00:15:24,160 --> 00:15:27,839
questions some for me uh

442
00:15:27,839 --> 00:15:29,600
okay so i'm going to actually take these

443
00:15:29,600 --> 00:15:31,759
questions in uh in about 10 minutes when

444
00:15:31,759 --> 00:15:33,600
i finish describing the product okay so

445
00:15:33,600 --> 00:15:35,759
that's okay

446
00:15:35,759 --> 00:15:37,519
all right so so let's get into the

447
00:15:37,519 --> 00:15:40,000
protocol

448
00:15:40,000 --> 00:15:42,079
here's how you here's what patch only is

449
00:15:42,079 --> 00:15:43,440
to begin with right so you have two

450
00:15:43,440 --> 00:15:44,399
parties

451
00:15:44,399 --> 00:15:46,720
one of the parties alice has two vectors

452
00:15:46,720 --> 00:15:49,600
a and b so length n vectors from cp just

453
00:15:49,600 --> 00:15:51,600
like i described before

454
00:15:51,600 --> 00:15:54,639
bob has a vector x and bob after this

455
00:15:54,639 --> 00:15:56,399
interaction wants to get a times x plus

456
00:15:56,399 --> 00:15:57,920
b where the multiplication is again

457
00:15:57,920 --> 00:15:59,600
coordinate

458
00:15:59,600 --> 00:16:01,650
okay good so how

459
00:16:01,650 --> 00:16:02,880
[Music]

460
00:16:02,880 --> 00:16:04,959
do you do this okay so before doing that

461
00:16:04,959 --> 00:16:06,720
this is a fundamental building block of

462
00:16:06,720 --> 00:16:09,199
arithmetic multiparty computation um you

463
00:16:09,199 --> 00:16:10,480
know there are other things that you

464
00:16:10,480 --> 00:16:12,480
heard about or will hear about but these

465
00:16:12,480 --> 00:16:14,320
are sort of special cases like petrole

466
00:16:14,320 --> 00:16:15,839
is the setting where x is actually a

467
00:16:15,839 --> 00:16:18,639
scalar and a and b are vectors ole is

468
00:16:18,639 --> 00:16:20,240
when you know all of these things are

469
00:16:20,240 --> 00:16:22,240
actually scalars an oblivious transfer

470
00:16:22,240 --> 00:16:24,720
is ole where p is actually true

471
00:16:24,720 --> 00:16:26,240
right so so a lot of sort of special

472
00:16:26,240 --> 00:16:28,560
cases the early kind of naturally sort

473
00:16:28,560 --> 00:16:31,600
of generalizes all these settings

474
00:16:31,600 --> 00:16:32,880
okay so

475
00:16:32,880 --> 00:16:34,560
how do you do actually and you have

476
00:16:34,560 --> 00:16:36,959
additive homomorphic encryption at hand

477
00:16:36,959 --> 00:16:38,560
uh with the instruction set that i

478
00:16:38,560 --> 00:16:40,639
described before so how do you do it

479
00:16:40,639 --> 00:16:42,880
here is a naive protocol

480
00:16:42,880 --> 00:16:46,480
i'll ask bob to encrypt his

481
00:16:46,480 --> 00:16:48,800
vector x using an additively homomorphic

482
00:16:48,800 --> 00:16:50,560
encryption send it over to alice and

483
00:16:50,560 --> 00:16:52,800
alice is going to compute a times x plus

484
00:16:52,800 --> 00:16:55,519
b homomorphically and this uses one

485
00:16:55,519 --> 00:16:57,440
scalar multiplication and one

486
00:16:57,440 --> 00:16:59,680
homomorphic addition that's it end of

487
00:16:59,680 --> 00:17:02,399
story right

488
00:17:03,120 --> 00:17:05,760
so this is more or less it except not

489
00:17:05,760 --> 00:17:09,119
quite so this naive protocol has uh the

490
00:17:09,119 --> 00:17:11,679
following problem

491
00:17:11,679 --> 00:17:12,640
which is

492
00:17:12,640 --> 00:17:13,919
you know which is something that you can

493
00:17:13,919 --> 00:17:16,160
see to see this problem you need to

494
00:17:16,160 --> 00:17:18,079
actually look into the guts of the beast

495
00:17:18,079 --> 00:17:19,679
you need to look into the belly of

496
00:17:19,679 --> 00:17:21,760
homomorphic encryption and here's what

497
00:17:21,760 --> 00:17:24,000
it is okay so if you look at a cipher

498
00:17:24,000 --> 00:17:25,359
text in an additively homomorphic

499
00:17:25,359 --> 00:17:26,959
intrusion scheme it looks like many

500
00:17:26,959 --> 00:17:28,960
numbers how many n which is this which

501
00:17:28,960 --> 00:17:31,440
is the number of slots

502
00:17:31,440 --> 00:17:33,760
and each cipher text looks like well the

503
00:17:33,760 --> 00:17:35,440
message that you encrypt in the most

504
00:17:35,440 --> 00:17:37,120
significant bit so that's the the top

505
00:17:37,120 --> 00:17:38,880
the blue color

506
00:17:38,880 --> 00:17:41,600
and then a bunch of noise uh lives in

507
00:17:41,600 --> 00:17:43,360
the least significant bits of this uh

508
00:17:43,360 --> 00:17:45,360
this number

509
00:17:45,360 --> 00:17:47,360
right so that's how that's how a cipher

510
00:17:47,360 --> 00:17:49,600
text looks like n slots each slot is a

511
00:17:49,600 --> 00:17:52,000
single number the msb contains the

512
00:17:52,000 --> 00:17:54,720
message the lsv contains junk noise

513
00:17:54,720 --> 00:17:56,640
which will eventually be removed as part

514
00:17:56,640 --> 00:17:58,720
of the decryption process

515
00:17:58,720 --> 00:18:00,960
okay noise is necessary for security but

516
00:18:00,960 --> 00:18:02,799
eventually once you have the secret key

517
00:18:02,799 --> 00:18:04,720
bob can actually take this off and get

518
00:18:04,720 --> 00:18:06,000
the most significant bits which is a

519
00:18:06,000 --> 00:18:07,440
message okay so this is how it looks

520
00:18:07,440 --> 00:18:09,600
like

521
00:18:09,600 --> 00:18:12,320
and the key difficulty here is that when

522
00:18:12,320 --> 00:18:13,840
you manipulate when you take an

523
00:18:13,840 --> 00:18:15,919
encryption of x and you compute a

524
00:18:15,919 --> 00:18:18,160
function homomorphically

525
00:18:18,160 --> 00:18:20,240
the noise in the resulting ciphertext

526
00:18:20,240 --> 00:18:22,559
the homomorphically evaluated ciphertext

527
00:18:22,559 --> 00:18:23,840
depends

528
00:18:23,840 --> 00:18:26,640
on the function that you computed

529
00:18:26,640 --> 00:18:29,360
so the function that alice here computed

530
00:18:29,360 --> 00:18:30,880
depends on a and b

531
00:18:30,880 --> 00:18:32,880
and therefore the noise in the leasing

532
00:18:32,880 --> 00:18:35,520
bits actually depends on on a and b uh

533
00:18:35,520 --> 00:18:38,000
both ambi

534
00:18:38,000 --> 00:18:41,200
now the problem is that when bob sees

535
00:18:41,200 --> 00:18:43,120
the ciphertext and he actually decrypts

536
00:18:43,120 --> 00:18:44,960
it he sees the noise he can actually

537
00:18:44,960 --> 00:18:47,440
recover the noise perfectly

538
00:18:47,440 --> 00:18:49,679
that will tell him what a and b in fact

539
00:18:49,679 --> 00:18:51,520
this is not a theoretical attack you can

540
00:18:51,520 --> 00:18:53,120
actually recover a and b if you

541
00:18:53,120 --> 00:18:54,559
construct the ciphertext effects

542
00:18:54,559 --> 00:18:56,720
carefully

543
00:18:56,720 --> 00:18:58,559
okay so this is a real attack

544
00:18:58,559 --> 00:19:00,480
we need to protect against it

545
00:19:00,480 --> 00:19:01,760
and the

546
00:19:01,760 --> 00:19:03,520
and people have done that and we know

547
00:19:03,520 --> 00:19:05,120
how to protect against this kind of

548
00:19:05,120 --> 00:19:06,720
attack and the way people do it is to

549
00:19:06,720 --> 00:19:07,840
say well look

550
00:19:07,840 --> 00:19:09,280
alice computes homomorphically an

551
00:19:09,280 --> 00:19:11,200
encryption of ax plus b

552
00:19:11,200 --> 00:19:12,960
and she doesn't just kind of sit there

553
00:19:12,960 --> 00:19:15,919
she she dunks the whole cipher text

554
00:19:15,919 --> 00:19:19,360
in noise okay so she adds to every slot

555
00:19:19,360 --> 00:19:21,679
of the cipher text a large amount of

556
00:19:21,679 --> 00:19:23,280
noise

557
00:19:23,280 --> 00:19:24,960
how large is large

558
00:19:24,960 --> 00:19:28,000
that is sort of uh guided by this noise

559
00:19:28,000 --> 00:19:29,760
flooding lemma it's a super simple sort

560
00:19:29,760 --> 00:19:32,320
of statement and that says that uh if

561
00:19:32,320 --> 00:19:35,280
you take two distributions here gaussian

562
00:19:35,280 --> 00:19:36,960
but you could all actually generalize it

563
00:19:36,960 --> 00:19:38,480
for sort of the square distribute

564
00:19:38,480 --> 00:19:40,320
uniform distribution or whatever you

565
00:19:40,320 --> 00:19:42,799
really want so what it says is that uh

566
00:19:42,799 --> 00:19:44,400
if you take two gaussians that are

567
00:19:44,400 --> 00:19:46,960
separated by x whose means are separated

568
00:19:46,960 --> 00:19:49,840
by x and standard deviation is sigma

569
00:19:49,840 --> 00:19:52,960
their statistical distance is basically

570
00:19:52,960 --> 00:19:54,480
the gap divided by the standard

571
00:19:54,480 --> 00:19:56,960
deviation makes intuitive sense right so

572
00:19:56,960 --> 00:19:59,120
two gaussians which are very

573
00:19:59,120 --> 00:20:00,799
close to each other it means

574
00:20:00,799 --> 00:20:02,400
um

575
00:20:02,400 --> 00:20:04,400
what does it mean very close

576
00:20:04,400 --> 00:20:06,320
close compared to the standard distance

577
00:20:06,320 --> 00:20:07,679
standard deviation of the gaussians

578
00:20:07,679 --> 00:20:09,919
they're actually statistically uh close

579
00:20:09,919 --> 00:20:10,720
okay

580
00:20:10,720 --> 00:20:12,799
so so what does this tell us it tells us

581
00:20:12,799 --> 00:20:14,400
how much noise you need to add to the

582
00:20:14,400 --> 00:20:16,960
ciphertext to actually get privacy

583
00:20:16,960 --> 00:20:20,240
against uh a semi-honest

584
00:20:20,240 --> 00:20:21,200
bob

585
00:20:21,200 --> 00:20:22,960
it tells you that you need to add lambda

586
00:20:22,960 --> 00:20:24,559
additional bits

587
00:20:24,559 --> 00:20:26,000
okay so if the noise in the

588
00:20:26,000 --> 00:20:28,720
homomorphically evaluated ciphertext was

589
00:20:28,720 --> 00:20:30,000
50 bits

590
00:20:30,000 --> 00:20:32,000
then you need to add

591
00:20:32,000 --> 00:20:33,440
90 bits

592
00:20:33,440 --> 00:20:35,760
an additional 40 bits per 40 is my

593
00:20:35,760 --> 00:20:37,120
statistical security problem you need to

594
00:20:37,120 --> 00:20:39,919
add 90 bits to get 2 to the minus 40

595
00:20:39,919 --> 00:20:42,240
statistical uh security that's what the

596
00:20:42,240 --> 00:20:44,559
noise flooding limit does

597
00:20:44,559 --> 00:20:46,480
okay

598
00:20:46,480 --> 00:20:47,600
so that's what that's what it is and

599
00:20:47,600 --> 00:20:49,120
that's how

600
00:20:49,120 --> 00:20:50,240
you know

601
00:20:50,240 --> 00:20:54,640
all the oily protocols in the literature

602
00:20:54,640 --> 00:20:56,960
went

603
00:20:57,440 --> 00:20:59,520
um and really the key

604
00:20:59,520 --> 00:21:01,679
point here is that the cost that this

605
00:21:01,679 --> 00:21:03,840
adds in terms of the communication

606
00:21:03,840 --> 00:21:06,559
already is multiplicative right because

607
00:21:06,559 --> 00:21:08,880
in each slot you're adding regardless of

608
00:21:08,880 --> 00:21:10,799
how small the plaintext are you're going

609
00:21:10,799 --> 00:21:14,159
to have to add lambda bits of error and

610
00:21:14,159 --> 00:21:16,880
that costs in total lambda and uh bits

611
00:21:16,880 --> 00:21:18,240
for the communication this is regardless

612
00:21:18,240 --> 00:21:21,280
of how small the plaintext space is

613
00:21:21,280 --> 00:21:23,200
right

614
00:21:23,200 --> 00:21:25,200
so so here is how the picture of naive

615
00:21:25,200 --> 00:21:26,880
batch early looks like you know the

616
00:21:26,880 --> 00:21:28,559
first message is actually going to be

617
00:21:28,559 --> 00:21:31,679
very large well you know lambda and bits

618
00:21:31,679 --> 00:21:33,919
in total as opposed to essentially n or

619
00:21:33,919 --> 00:21:36,000
n log n bits that you would expect

620
00:21:36,000 --> 00:21:37,120
without

621
00:21:37,120 --> 00:21:40,678
this noise flat

622
00:21:44,000 --> 00:21:45,600
good okay

623
00:21:45,600 --> 00:21:47,440
so krusten thank you for uh for

624
00:21:47,440 --> 00:21:50,000
answering the questions

625
00:21:50,000 --> 00:21:50,880
um

626
00:21:50,880 --> 00:21:53,760
good okay so so fine so what what can

627
00:21:53,760 --> 00:21:55,919
you do that is better than this okay so

628
00:21:55,919 --> 00:21:57,200
that's that's uh that's the question we

629
00:21:57,200 --> 00:21:58,799
ask

630
00:21:58,799 --> 00:22:00,720
to do that um

631
00:22:00,720 --> 00:22:02,559
well so so we come up with this sort of

632
00:22:02,559 --> 00:22:04,559
the key idea in this work is is do noise

633
00:22:04,559 --> 00:22:07,039
flooding but do gentle noise planning

634
00:22:07,039 --> 00:22:09,760
okay so so we call this noise drizzling

635
00:22:09,760 --> 00:22:12,080
in the paper so don't go all out but

636
00:22:12,080 --> 00:22:15,520
just be careful be judicious and sparing

637
00:22:15,520 --> 00:22:17,520
in how you use homomorphic interruption

638
00:22:17,520 --> 00:22:19,600
okay so illustrate that let's uh

639
00:22:19,600 --> 00:22:20,559
actually

640
00:22:20,559 --> 00:22:23,039
play a little game okay so we have a

641
00:22:23,039 --> 00:22:24,640
number m this is the thing that i'm

642
00:22:24,640 --> 00:22:26,880
trying to flood and let's say for a

643
00:22:26,880 --> 00:22:29,120
moment the number is sort of between 0

644
00:22:29,120 --> 00:22:33,440
and 10 okay any number between 0 and

645
00:22:33,440 --> 00:22:35,280
the noise that i'm going to add the

646
00:22:35,280 --> 00:22:37,200
gentle noise that i'm going to add is a

647
00:22:37,200 --> 00:22:39,360
random number between 0 and 20. okay so

648
00:22:39,360 --> 00:22:41,919
that's like one bit more than the the

649
00:22:41,919 --> 00:22:43,600
message space

650
00:22:43,600 --> 00:22:45,760
right

651
00:22:46,400 --> 00:22:48,400
so i'm going to look at the noisy number

652
00:22:48,400 --> 00:22:50,880
which is m plus eta and and really the

653
00:22:50,880 --> 00:22:52,640
question i want to ask is can you guess

654
00:22:52,640 --> 00:22:55,120
m or how well can you guess sam can you

655
00:22:55,120 --> 00:22:57,360
really hide all information about that

656
00:22:57,360 --> 00:23:00,640
that's the question i'm gonna ask

657
00:23:00,640 --> 00:23:03,120
um so let's uh let's do it okay so let's

658
00:23:03,120 --> 00:23:06,000
say for a moment that uh when i added up

659
00:23:06,000 --> 00:23:08,720
the message and the error and the noise

660
00:23:08,720 --> 00:23:10,559
i got a zero

661
00:23:10,559 --> 00:23:12,000
okay

662
00:23:12,000 --> 00:23:14,240
can you guess what the message was to

663
00:23:14,240 --> 00:23:16,799
begin with

664
00:23:19,840 --> 00:23:23,639
anyone any volunteers

665
00:23:29,919 --> 00:23:31,600
so i know that the message is within the

666
00:23:31,600 --> 00:23:34,000
range zero to ten okay inclusive

667
00:23:34,000 --> 00:23:36,000
i know that the noise is a random number

668
00:23:36,000 --> 00:23:38,640
between 0 and 10 somehow when i took the

669
00:23:38,640 --> 00:23:40,720
message and added the error i got a

670
00:23:40,720 --> 00:23:43,200
zero no modular arithmetic here okay

671
00:23:43,200 --> 00:23:44,720
just sort of i don't know like first

672
00:23:44,720 --> 00:23:46,400
grade arithmetic okay you got over the

673
00:23:46,400 --> 00:23:48,799
integers

674
00:23:48,799 --> 00:23:52,240
what could the message have been

675
00:23:55,520 --> 00:23:57,840
zero is the only possibility okay the

676
00:23:57,840 --> 00:23:59,760
only way you could have gotten to

677
00:23:59,760 --> 00:24:01,919
zero by adding a number in this range in

678
00:24:01,919 --> 00:24:03,520
that range is when both of them were

679
00:24:03,520 --> 00:24:06,480
zero okay so that's it's a perfect break

680
00:24:06,480 --> 00:24:09,600
of privacy right

681
00:24:10,640 --> 00:24:13,200
what if on the other hand the

682
00:24:13,200 --> 00:24:16,400
noisy number was 10.

683
00:24:16,400 --> 00:24:18,880
okay could you say anything about the

684
00:24:18,880 --> 00:24:22,240
the message m here

685
00:24:22,559 --> 00:24:24,000
okay that requires a little bit more

686
00:24:24,000 --> 00:24:25,600
thoughts

687
00:24:25,600 --> 00:24:28,080
um but if you think about it right c

688
00:24:28,080 --> 00:24:29,360
time okay

689
00:24:29,360 --> 00:24:32,000
for every possible value of m in the

690
00:24:32,000 --> 00:24:33,600
range 0 to 10

691
00:24:33,600 --> 00:24:35,919
there is a unique eta

692
00:24:35,919 --> 00:24:38,080
that would have given me this d

693
00:24:38,080 --> 00:24:40,720
right so if m was 0 then the noise was

694
00:24:40,720 --> 00:24:42,720
10 if m was 10 the noise was 0. so

695
00:24:42,720 --> 00:24:45,200
there's a unique such value

696
00:24:45,200 --> 00:24:47,679
so that leads us to our gentle noise

697
00:24:47,679 --> 00:24:49,520
flooding lemma which says that if t

698
00:24:49,520 --> 00:24:51,279
falls in the race the noisy number falls

699
00:24:51,279 --> 00:24:53,679
in the range 10 comma 20

700
00:24:53,679 --> 00:24:57,200
then m is perfectly hidden

701
00:24:58,840 --> 00:25:02,000
okay so that's the lemma more precisely

702
00:25:02,000 --> 00:25:04,799
for any alpha and beta in the range 0 to

703
00:25:04,799 --> 00:25:05,919
10

704
00:25:05,919 --> 00:25:07,760
these num these sort of the probability

705
00:25:07,760 --> 00:25:10,080
that m is alpha given a t which given

706
00:25:10,080 --> 00:25:11,520
the t false in the ranks 10 20 is the

707
00:25:11,520 --> 00:25:12,799
same as the probability that i missed so

708
00:25:12,799 --> 00:25:15,200
you get semantic security condition on

709
00:25:15,200 --> 00:25:16,559
the fact that uh t falls in the

710
00:25:16,559 --> 00:25:18,240
structure

711
00:25:18,240 --> 00:25:20,480
okay

712
00:25:20,640 --> 00:25:21,600
yeah

713
00:25:21,600 --> 00:25:24,000
so far so good

714
00:25:24,000 --> 00:25:26,240
all right so so what so what do you do

715
00:25:26,240 --> 00:25:27,520
i don't want to encrypt one number

716
00:25:27,520 --> 00:25:29,279
remember we encrypted numbers in many

717
00:25:29,279 --> 00:25:31,200
slots so i have many numbers i have many

718
00:25:31,200 --> 00:25:33,679
noises one to each slot and i given many

719
00:25:33,679 --> 00:25:36,240
noisy numbers and uh and the question is

720
00:25:36,240 --> 00:25:39,679
can you guess these mis

721
00:25:39,679 --> 00:25:41,919
um the gentle noise flooring lemma tells

722
00:25:41,919 --> 00:25:43,360
you that you know in this setting where

723
00:25:43,360 --> 00:25:45,520
you have the ranges that i spoke about

724
00:25:45,520 --> 00:25:47,840
uh where the noise is one bit more than

725
00:25:47,840 --> 00:25:50,960
the uh message space

726
00:25:50,960 --> 00:25:52,640
you know that at least half the mis are

727
00:25:52,640 --> 00:25:54,559
perfectly hidden

728
00:25:54,559 --> 00:25:56,559
right because the probability that the

729
00:25:56,559 --> 00:25:59,440
mi falls into the noisy uh

730
00:25:59,440 --> 00:26:02,080
mi which is ti falls into this range 10

731
00:26:02,080 --> 00:26:05,440
comma 20 is uh at least a half

732
00:26:05,440 --> 00:26:07,679
right the worst case is when the message

733
00:26:07,679 --> 00:26:10,000
was zero right and you added a random

734
00:26:10,000 --> 00:26:11,279
number from zero to twenty the

735
00:26:11,279 --> 00:26:12,880
probability that it falls in ten twenty

736
00:26:12,880 --> 00:26:14,559
is a half okay so at least half the

737
00:26:14,559 --> 00:26:16,880
messages are perfectly hidden

738
00:26:16,880 --> 00:26:19,039
that's not what you want in crypto right

739
00:26:19,039 --> 00:26:22,640
you want semantic security you want

740
00:26:22,640 --> 00:26:24,960
you know all the mis

741
00:26:24,960 --> 00:26:26,320
to be hidden

742
00:26:26,320 --> 00:26:27,440
right

743
00:26:27,440 --> 00:26:28,960
why is that because if an mi is not

744
00:26:28,960 --> 00:26:30,720
hidden that's actually going to reveal

745
00:26:30,720 --> 00:26:32,640
information about the ai and bi so if

746
00:26:32,640 --> 00:26:34,559
you pop back the stack and see where we

747
00:26:34,559 --> 00:26:37,520
are coming from to this point right so

748
00:26:37,520 --> 00:26:39,200
you really want to hide all of a and b

749
00:26:39,200 --> 00:26:41,120
and that involves hiding all of mi so

750
00:26:41,120 --> 00:26:43,678
how do you do it

751
00:26:44,559 --> 00:26:46,720
so this is where the second idea sort of

752
00:26:46,720 --> 00:26:49,440
comes in and uh you know can any does

753
00:26:49,440 --> 00:26:50,799
anyone want to take a shot at it i think

754
00:26:50,799 --> 00:26:52,720
at this point people can simulate my you

755
00:26:52,720 --> 00:26:54,080
know our paper

756
00:26:54,080 --> 00:26:57,439
anyone want to take a shot at it

757
00:26:57,919 --> 00:26:59,760
you can't hide everything that's what

758
00:26:59,760 --> 00:27:01,679
i'm saying but you can hide half of the

759
00:27:01,679 --> 00:27:02,720
numbers

760
00:27:02,720 --> 00:27:04,400
but from there i want to go to a setting

761
00:27:04,400 --> 00:27:07,840
where i can hide all the numbers

762
00:27:08,799 --> 00:27:10,559
you do secret sharing

763
00:27:10,559 --> 00:27:11,600
okay

764
00:27:11,600 --> 00:27:14,880
so instead of encrypting numbers like x

765
00:27:14,880 --> 00:27:16,159
by itself

766
00:27:16,159 --> 00:27:18,480
you take a number and you secret share

767
00:27:18,480 --> 00:27:20,799
it you use packed shamier secret sharing

768
00:27:20,799 --> 00:27:23,279
to and to sort of you know blow it up a

769
00:27:23,279 --> 00:27:24,799
little bit right

770
00:27:24,799 --> 00:27:26,159
how much do you need to blow up we'll

771
00:27:26,159 --> 00:27:27,679
get to that in a second but not much and

772
00:27:27,679 --> 00:27:29,600
constant factor really

773
00:27:29,600 --> 00:27:31,200
uh and what you do is you secret share

774
00:27:31,200 --> 00:27:32,720
the actual message into a longer end

775
00:27:32,720 --> 00:27:34,559
prime and you gently plot n prime what

776
00:27:34,559 --> 00:27:37,360
that tells you is half of the message in

777
00:27:37,360 --> 00:27:39,520
with high probability on at most half of

778
00:27:39,520 --> 00:27:42,000
the m prime leaks and that height is m

779
00:27:42,000 --> 00:27:44,000
perfectly wrong

780
00:27:44,000 --> 00:27:47,279
okay that's it that's that's that's that

781
00:27:47,279 --> 00:27:48,640
now we want to put it together into a

782
00:27:48,640 --> 00:27:50,799
protocol so i'm going to ask bob not to

783
00:27:50,799 --> 00:27:53,840
encrypt his ex but secret share uh using

784
00:27:53,840 --> 00:27:55,840
a pact using franklin jung i suppose the

785
00:27:55,840 --> 00:27:57,760
pact shamir secret sharing scheme into

786
00:27:57,760 --> 00:27:59,039
an x prime

787
00:27:59,039 --> 00:28:00,399
and um

788
00:28:00,399 --> 00:28:02,000
alice would do the same thing with a and

789
00:28:02,000 --> 00:28:04,000
b to a prime and a b prime and she'll

790
00:28:04,000 --> 00:28:06,399
compute this homomorphically

791
00:28:06,399 --> 00:28:08,960
and uh and at the end uh bob will

792
00:28:08,960 --> 00:28:11,279
decrypt this uh ciphertext and decode

793
00:28:11,279 --> 00:28:14,559
the secret sharing uh to get ax plus b

794
00:28:14,559 --> 00:28:18,399
okay so that's uh that's how it goes

795
00:28:18,799 --> 00:28:21,600
what is the overhead the overhead is um

796
00:28:21,600 --> 00:28:24,559
uh you need to expand from x to x prime

797
00:28:24,559 --> 00:28:26,880
and uh and turns out that you can pack

798
00:28:26,880 --> 00:28:28,880
essentially n over two minus lambda

799
00:28:28,880 --> 00:28:31,120
inputs into n shares and that will give

800
00:28:31,120 --> 00:28:32,799
you 2 to the minus lambda statistical

801
00:28:32,799 --> 00:28:34,399
security for alice against a malicious

802
00:28:34,399 --> 00:28:37,600
against a semi-honest ball

803
00:28:38,000 --> 00:28:39,840
and the key thing to note here is that

804
00:28:39,840 --> 00:28:42,000
the overhead is additive because in each

805
00:28:42,000 --> 00:28:44,640
slot i added one bit

806
00:28:44,640 --> 00:28:46,000
of noise in addition as opposed to

807
00:28:46,000 --> 00:28:48,080
lambda bits right

808
00:28:48,080 --> 00:28:51,520
so one bit times n uh and and i did this

809
00:28:51,520 --> 00:28:54,000
for sort of n slot so that's n bits

810
00:28:54,000 --> 00:28:55,760
but then i had to expand i pay the price

811
00:28:55,760 --> 00:28:57,440
and kind of having to expand a smaller

812
00:28:57,440 --> 00:28:59,039
message into a larger message and that's

813
00:28:59,039 --> 00:29:01,200
the plus lambda

814
00:29:01,200 --> 00:29:02,960
okay so this is what uh

815
00:29:02,960 --> 00:29:04,640
this is what uh this what i get so you

816
00:29:04,640 --> 00:29:06,240
get additive overhead supposed to the

817
00:29:06,240 --> 00:29:09,360
naive multiplicative overhead

818
00:29:09,360 --> 00:29:11,840
concretely uh we uh we implemented this

819
00:29:11,840 --> 00:29:13,360
and sort of tested it against with the

820
00:29:13,360 --> 00:29:16,399
state-of-the-art early protocols um uh

821
00:29:16,399 --> 00:29:18,880
which is uh an older work with uh leo

822
00:29:18,880 --> 00:29:21,760
and uh chirag and also very nice work of

823
00:29:21,760 --> 00:29:22,640
uh

824
00:29:22,640 --> 00:29:24,799
carsten and friends i don't remember the

825
00:29:24,799 --> 00:29:27,440
full list of authors um and they

826
00:29:27,440 --> 00:29:29,039
actually construct an early protocol

827
00:29:29,039 --> 00:29:31,039
which is sort of one round so these are

828
00:29:31,039 --> 00:29:32,720
two round protocols right i sent you you

829
00:29:32,720 --> 00:29:34,399
send me they construct a one-round

830
00:29:34,399 --> 00:29:36,880
protocol for random only

831
00:29:36,880 --> 00:29:38,880
um and that's what we compare against

832
00:29:38,880 --> 00:29:39,919
and turns out that you know not

833
00:29:39,919 --> 00:29:42,720
surprisingly uh uh in a setting where

834
00:29:42,720 --> 00:29:45,520
you have small ish plaintext spaces

835
00:29:45,520 --> 00:29:48,000
and you have uh smallish batch sizes or

836
00:29:48,000 --> 00:29:49,840
medium length batch sizes

837
00:29:49,840 --> 00:29:51,279
we get better communication compared to

838
00:29:51,279 --> 00:29:54,320
these holy schemes and compared to per

839
00:29:54,320 --> 00:29:55,440
year

840
00:29:55,440 --> 00:29:58,000
you get far better computational cost

841
00:29:58,000 --> 00:30:00,399
okay so pierre needs to manipulate 40 96

842
00:30:00,399 --> 00:30:02,240
bits and it needs to do exponentiation

843
00:30:02,240 --> 00:30:04,159
there is no exponentiation here all you

844
00:30:04,159 --> 00:30:06,559
need to do is so you know

845
00:30:06,559 --> 00:30:08,240
parallel multiplication of numbers and

846
00:30:08,240 --> 00:30:10,080
parallel addition of numbers okay so

847
00:30:10,080 --> 00:30:11,520
this brings me to a sort of a bigger

848
00:30:11,520 --> 00:30:13,279
point which is that

849
00:30:13,279 --> 00:30:15,520
you know there are really many different

850
00:30:15,520 --> 00:30:17,120
kinds of homomorphic and additive

851
00:30:17,120 --> 00:30:18,640
homomorphic encryption schemes out there

852
00:30:18,640 --> 00:30:19,919
this pi year

853
00:30:19,919 --> 00:30:22,240
and then there is ring lwe based

854
00:30:22,240 --> 00:30:24,000
additive homomorphic encryption and

855
00:30:24,000 --> 00:30:26,960
there they do very very different things

856
00:30:26,960 --> 00:30:28,880
so if you are faced with a setting where

857
00:30:28,880 --> 00:30:31,279
you want to manipulate a lot of small

858
00:30:31,279 --> 00:30:32,960
numbers you want to do additions and

859
00:30:32,960 --> 00:30:35,039
scalar multiplications on them

860
00:30:35,039 --> 00:30:37,520
ring lwe is your front

861
00:30:37,520 --> 00:30:38,960
you should probably be looking at sort

862
00:30:38,960 --> 00:30:40,399
of the protocols and implementations

863
00:30:40,399 --> 00:30:42,080
based on these things

864
00:30:42,080 --> 00:30:45,120
right so that's the message

865
00:30:45,120 --> 00:30:46,960
we also sort of uh

866
00:30:46,960 --> 00:30:48,559
you know

867
00:30:48,559 --> 00:30:50,480
look at applications uh for example

868
00:30:50,480 --> 00:30:52,960
setting up sort of the seeds of the uh

869
00:30:52,960 --> 00:30:53,200
uh

870
00:30:53,200 --> 00:30:54,320
[Music]

871
00:30:54,320 --> 00:30:55,840
pseudorandom correlation generator which

872
00:30:55,840 --> 00:30:57,279
you've heard about in your wild stock is

873
00:30:57,279 --> 00:30:58,960
an example where you know this would

874
00:30:58,960 --> 00:31:00,799
this would come in handy

875
00:31:00,799 --> 00:31:02,799
um and and sort of taking a step back we

876
00:31:02,799 --> 00:31:04,720
introduced a new notion uh called a

877
00:31:04,720 --> 00:31:06,720
synthetic quasi-optimality uh in this

878
00:31:06,720 --> 00:31:07,600
work

879
00:31:07,600 --> 00:31:09,519
um so what is asymptotic efficiency a

880
00:31:09,519 --> 00:31:11,360
synthetic efficiency in cryptography

881
00:31:11,360 --> 00:31:13,120
means that you want to solve n instances

882
00:31:13,120 --> 00:31:16,240
of a problem like n y such only

883
00:31:16,240 --> 00:31:18,159
and you know symbolic efficiency says

884
00:31:18,159 --> 00:31:19,519
that your efficiency should be

885
00:31:19,519 --> 00:31:22,000
essentially order fan or tilde of n plus

886
00:31:22,000 --> 00:31:24,960
poly lambda right the the message being

887
00:31:24,960 --> 00:31:27,360
that as n goes to infinity the poly

888
00:31:27,360 --> 00:31:29,279
lambda kind of is amortized away and you

889
00:31:29,279 --> 00:31:31,600
get essentially you know constant or

890
00:31:31,600 --> 00:31:34,639
logarithmic overhead

891
00:31:34,720 --> 00:31:37,279
what we propose here is to look at a a

892
00:31:37,279 --> 00:31:39,120
more stringent notion of efficiency

893
00:31:39,120 --> 00:31:40,720
which is to solve an instance of a

894
00:31:40,720 --> 00:31:43,840
problem with efficiency n plus lambda

895
00:31:43,840 --> 00:31:46,880
okay no poly and plus lambda

896
00:31:46,880 --> 00:31:49,200
and the consequence of that is that you

897
00:31:49,200 --> 00:31:52,159
know while you may take a long time to

898
00:31:52,159 --> 00:31:53,840
get to the syntactic regime to hit the

899
00:31:53,840 --> 00:31:55,840
poly lambda in the previous in the case

900
00:31:55,840 --> 00:31:57,919
of a systolic efficiency you get to the

901
00:31:57,919 --> 00:32:00,799
asymptotic regime faster

902
00:32:00,799 --> 00:32:02,880
okay so it's a high level message of

903
00:32:02,880 --> 00:32:04,480
course it depends on a lot of sort of

904
00:32:04,480 --> 00:32:05,840
hidden things here it depends on the

905
00:32:05,840 --> 00:32:08,080
constant in the o notation it depends on

906
00:32:08,080 --> 00:32:10,399
the logarithmic factors and so forth but

907
00:32:10,399 --> 00:32:12,799
high level this is what we want to

908
00:32:12,799 --> 00:32:14,240
achieve and this is what our early

909
00:32:14,240 --> 00:32:16,159
protocol actually demonstrates in

910
00:32:16,159 --> 00:32:18,799
concrete terms

911
00:32:18,799 --> 00:32:20,799
okay we show other results we use this

912
00:32:20,799 --> 00:32:23,279
to build a half malicious uh you know

913
00:32:23,279 --> 00:32:24,559
batch early

914
00:32:24,559 --> 00:32:26,240
sort of like narrow pinkers

915
00:32:26,240 --> 00:32:27,440
we use it to build zero knowledge

916
00:32:27,440 --> 00:32:29,440
protocols and mpc protocols and so forth

917
00:32:29,440 --> 00:32:31,120
all these things are sort of theoretical

918
00:32:31,120 --> 00:32:32,880
uh the one thing that we concretely

919
00:32:32,880 --> 00:32:35,519
evaluated was the early protocol uh just

920
00:32:35,519 --> 00:32:37,760
to show that this sort of new notion

921
00:32:37,760 --> 00:32:40,080
if used carefully and judiciously can

922
00:32:40,080 --> 00:32:42,000
actually give you can actually result in

923
00:32:42,000 --> 00:32:44,159
new ideas like our gentle noise flooding

924
00:32:44,159 --> 00:32:47,440
idea and better protocols in some cases

925
00:32:47,440 --> 00:32:50,080
okay so that's the message of paper

926
00:32:50,080 --> 00:32:51,519
so you should really think about it as

927
00:32:51,519 --> 00:32:53,760
so like we are going into i'm you're not

928
00:32:53,760 --> 00:32:55,120
building a secure computation protocol

929
00:32:55,120 --> 00:32:56,640
that's not the point of this talk we're

930
00:32:56,640 --> 00:32:57,919
going into the guts of secure

931
00:32:57,919 --> 00:32:59,279
computation we're saying well what is

932
00:32:59,279 --> 00:33:01,039
the fundamental building block of secure

933
00:33:01,039 --> 00:33:02,720
computation and can we make it better

934
00:33:02,720 --> 00:33:04,799
and that's what we do

935
00:33:04,799 --> 00:33:05,679
okay

936
00:33:05,679 --> 00:33:06,799
good so that's the first part of the

937
00:33:06,799 --> 00:33:10,080
talk how much time do i have ah okay um

938
00:33:10,080 --> 00:33:13,760
ten minutes something like that

939
00:33:13,919 --> 00:33:17,519
all right good so um i'm assuming that

940
00:33:17,519 --> 00:33:19,600
carsten is going to answer all the uh

941
00:33:19,600 --> 00:33:21,200
all the questions i have uh you know so

942
00:33:21,200 --> 00:33:22,799
i'm going to not look at the questions

943
00:33:22,799 --> 00:33:25,039
until the end good so i want to move on

944
00:33:25,039 --> 00:33:27,039
to the second part where i'll completely

945
00:33:27,039 --> 00:33:29,519
switch gears and i want to talk about

946
00:33:29,519 --> 00:33:30,799
you know um

947
00:33:30,799 --> 00:33:33,519
the ideal world is where there is this

948
00:33:33,519 --> 00:33:35,039
massive bridge between secure

949
00:33:35,039 --> 00:33:36,720
competition and privacy preserving

950
00:33:36,720 --> 00:33:38,240
machine learning and you go back and

951
00:33:38,240 --> 00:33:40,399
forth and you're very happy okay

952
00:33:40,399 --> 00:33:42,880
but that's not really the case and i

953
00:33:42,880 --> 00:33:45,279
want to sort of highlight one problem

954
00:33:45,279 --> 00:33:46,880
that's at the interface between the two

955
00:33:46,880 --> 00:33:48,640
fields um

956
00:33:48,640 --> 00:33:50,000
and again like i said you know i have

957
00:33:50,000 --> 00:33:51,840
only open problems to offer here and i

958
00:33:51,840 --> 00:33:53,679
hope people will so this is a call to

959
00:33:53,679 --> 00:33:55,039
action you know we in the crypto

960
00:33:55,039 --> 00:33:56,960
community should think about the

961
00:33:56,960 --> 00:33:58,320
end-to-end

962
00:33:58,320 --> 00:33:59,760
sort of setting of privacy preserving

963
00:33:59,760 --> 00:34:01,279
machine learning which involves lots

964
00:34:01,279 --> 00:34:04,880
more problems than secure computation

965
00:34:05,200 --> 00:34:07,200
good okay so let's get into it okay so

966
00:34:07,200 --> 00:34:09,199
the the fundamental sort of observation

967
00:34:09,199 --> 00:34:10,480
here is that secure computation

968
00:34:10,480 --> 00:34:11,839
protocols

969
00:34:11,839 --> 00:34:13,839
you know ideal real secure computation

970
00:34:13,839 --> 00:34:15,839
protocols are only as good as the ideal

971
00:34:15,839 --> 00:34:17,440
model their security is only as good as

972
00:34:17,440 --> 00:34:18,879
the ideal model yes so this is a

973
00:34:18,879 --> 00:34:20,960
tautology like everybody knows this but

974
00:34:20,960 --> 00:34:22,879
that's what it is

975
00:34:22,879 --> 00:34:25,520
what that says is that there are two at

976
00:34:25,520 --> 00:34:27,280
least two things that an adversary can

977
00:34:27,280 --> 00:34:30,239
do in the ideal model and that the you

978
00:34:30,239 --> 00:34:31,760
know

979
00:34:31,760 --> 00:34:33,199
the atmosphere can do in the real real

980
00:34:33,199 --> 00:34:34,719
world as well there's nothing preventing

981
00:34:34,719 --> 00:34:36,480
it and one is that the artistry gets to

982
00:34:36,480 --> 00:34:37,918
pick the input

983
00:34:37,918 --> 00:34:39,359
two is the absolute gets to see the

984
00:34:39,359 --> 00:34:40,320
output

985
00:34:40,320 --> 00:34:41,839
okay

986
00:34:41,839 --> 00:34:43,520
anybody can do it in the in the oracle

987
00:34:43,520 --> 00:34:45,440
model so therefore you know it's fair

988
00:34:45,440 --> 00:34:47,199
game in the in the real world as well

989
00:34:47,199 --> 00:34:49,918
okay so you might ask me like

990
00:34:49,918 --> 00:34:50,719
but

991
00:34:50,719 --> 00:34:52,159
what the hell you know like what are you

992
00:34:52,159 --> 00:34:54,000
going to do about it okay what are you

993
00:34:54,000 --> 00:34:56,639
going to do about it

994
00:34:56,879 --> 00:34:58,320
i'll focus on the output seeing the

995
00:34:58,320 --> 00:34:59,200
output

996
00:34:59,200 --> 00:35:01,040
part in this talk

997
00:35:01,040 --> 00:35:03,119
and the question you know here is what

998
00:35:03,119 --> 00:35:06,079
do the outputs of uh of uh

999
00:35:06,079 --> 00:35:08,480
of a sort of secure protocol or what are

1000
00:35:08,480 --> 00:35:10,079
the outputs of computation in general

1001
00:35:10,079 --> 00:35:11,119
reveal

1002
00:35:11,119 --> 00:35:12,800
uh and i'm going to zoom in even further

1003
00:35:12,800 --> 00:35:14,720
and look at repeated executions of a

1004
00:35:14,720 --> 00:35:17,200
protocol where one of the inputs remains

1005
00:35:17,200 --> 00:35:18,720
fixed and this is really the setting of

1006
00:35:18,720 --> 00:35:20,480
secure inference

1007
00:35:20,480 --> 00:35:22,720
where one party sort of you know chooses

1008
00:35:22,720 --> 00:35:23,760
a model

1009
00:35:23,760 --> 00:35:25,119
and

1010
00:35:25,119 --> 00:35:28,000
by definition this is only useful

1011
00:35:28,000 --> 00:35:30,160
when this model is used many many times

1012
00:35:30,160 --> 00:35:32,640
to do inference right so the other party

1013
00:35:32,640 --> 00:35:35,040
picks many sort of inputs and gets the

1014
00:35:35,040 --> 00:35:36,400
model gets the prediction or

1015
00:35:36,400 --> 00:35:39,040
classification or whatever um uh using

1016
00:35:39,040 --> 00:35:40,720
this model

1017
00:35:40,720 --> 00:35:43,280
right so that's the setting

1018
00:35:43,280 --> 00:35:45,119
and this sort of

1019
00:35:45,119 --> 00:35:47,440
leads us to the to the to the model

1020
00:35:47,440 --> 00:35:49,200
stealing or model stealing attack

1021
00:35:49,200 --> 00:35:51,359
setting uh where the ideal adversary has

1022
00:35:51,359 --> 00:35:53,280
query access to the model and it could

1023
00:35:53,280 --> 00:35:56,640
potentially make a few queries to this

1024
00:35:56,640 --> 00:35:57,760
model

1025
00:35:57,760 --> 00:36:01,440
and reconstructs another model m prime

1026
00:36:01,440 --> 00:36:03,520
that is essentially as good

1027
00:36:03,520 --> 00:36:05,200
so this is an attack that has nothing to

1028
00:36:05,200 --> 00:36:06,880
do with the secure computation protocol

1029
00:36:06,880 --> 00:36:08,880
it has to do with the ideal so-called

1030
00:36:08,880 --> 00:36:10,480
ideal model

1031
00:36:10,480 --> 00:36:13,359
right

1032
00:36:13,359 --> 00:36:14,160
yeah

1033
00:36:14,160 --> 00:36:15,119
so

1034
00:36:15,119 --> 00:36:17,599
again you could ask you know what uh

1035
00:36:17,599 --> 00:36:19,520
what do i do about it we know you know

1036
00:36:19,520 --> 00:36:21,280
like this is this is you know an ideal

1037
00:36:21,280 --> 00:36:22,640
world permits this attack so what are

1038
00:36:22,640 --> 00:36:24,800
you going to do about it

1039
00:36:24,800 --> 00:36:26,560
in other words this attack seems

1040
00:36:26,560 --> 00:36:27,920
unpreventable

1041
00:36:27,920 --> 00:36:29,680
right especially in the setting because

1042
00:36:29,680 --> 00:36:31,760
the model is learnable like somebody

1043
00:36:31,760 --> 00:36:34,240
actually took a trove of data

1044
00:36:34,240 --> 00:36:36,079
you know run some

1045
00:36:36,079 --> 00:36:37,520
funny machine learning algorithm on it

1046
00:36:37,520 --> 00:36:40,160
and learn the model okay

1047
00:36:40,160 --> 00:36:42,240
so an adversary could make as many

1048
00:36:42,240 --> 00:36:44,880
queries right potentially

1049
00:36:44,880 --> 00:36:47,280
and actually learn to replicate this

1050
00:36:47,280 --> 00:36:49,680
learning process so so in some sense

1051
00:36:49,680 --> 00:36:51,839
this is actually an unpreventable attack

1052
00:36:51,839 --> 00:36:54,000
okay but that's a silly answer of course

1053
00:36:54,000 --> 00:36:55,119
because

1054
00:36:55,119 --> 00:36:57,119
what you want to do is you want to draw

1055
00:36:57,119 --> 00:36:59,359
your goal posts better

1056
00:36:59,359 --> 00:37:00,880
what you want to do is to get best

1057
00:37:00,880 --> 00:37:03,280
possible security which is to say

1058
00:37:03,280 --> 00:37:06,320
that any adversary that um you know

1059
00:37:06,320 --> 00:37:09,359
queries this model and um

1060
00:37:09,359 --> 00:37:11,520
reconstructs uh

1061
00:37:11,520 --> 00:37:14,880
an essentially as good model and prime

1062
00:37:14,880 --> 00:37:17,599
has to make as nearly as many queries as

1063
00:37:17,599 --> 00:37:19,839
the learner himself

1064
00:37:19,839 --> 00:37:22,240
who got just a collection of data you

1065
00:37:22,240 --> 00:37:24,640
know points drawn id from a distribution

1066
00:37:24,640 --> 00:37:25,839
let's say

1067
00:37:25,839 --> 00:37:27,119
and actually random machine learning

1068
00:37:27,119 --> 00:37:28,640
algorithm in other words

1069
00:37:28,640 --> 00:37:31,359
the sample complexity of an adversary in

1070
00:37:31,359 --> 00:37:33,599
this ideal world should be nearly as

1071
00:37:33,599 --> 00:37:36,320
much as a simple complexity of a

1072
00:37:36,320 --> 00:37:38,240
completely non-adaptive

1073
00:37:38,240 --> 00:37:40,480
you know machine learning algorithm okay

1074
00:37:40,480 --> 00:37:44,000
that's the best possible you could hope

1075
00:37:44,320 --> 00:37:47,200
but that's a very challenging goal

1076
00:37:47,200 --> 00:37:49,119
it's a very challenging goal because a

1077
00:37:49,119 --> 00:37:51,200
model stealing adversary has far more

1078
00:37:51,200 --> 00:37:53,680
power it can make its queries adaptively

1079
00:37:53,680 --> 00:37:56,000
right you know i can make a query learn

1080
00:37:56,000 --> 00:37:57,680
the answer depending on it to make

1081
00:37:57,680 --> 00:37:58,960
another query

1082
00:37:58,960 --> 00:38:00,720
and even if you cannot make the queries

1083
00:38:00,720 --> 00:38:02,000
adaptively

1084
00:38:02,000 --> 00:38:03,359
the address we can choose potentially

1085
00:38:03,359 --> 00:38:05,440
correlated queries

1086
00:38:05,440 --> 00:38:06,800
and even if you cannot choose these

1087
00:38:06,800 --> 00:38:09,280
queries uh you know but to be correlated

1088
00:38:09,280 --> 00:38:10,800
you can choose the queries from out of

1089
00:38:10,800 --> 00:38:12,480
distribution you can choose some other

1090
00:38:12,480 --> 00:38:14,480
distribution of certain inputs and try

1091
00:38:14,480 --> 00:38:18,320
to um sort of use that uh to learn so

1092
00:38:18,320 --> 00:38:19,920
this is a very very very challenging

1093
00:38:19,920 --> 00:38:22,240
setting

1094
00:38:22,480 --> 00:38:23,920
but regardless

1095
00:38:23,920 --> 00:38:25,599
my point

1096
00:38:25,599 --> 00:38:28,320
is that for the area of secure inference

1097
00:38:28,320 --> 00:38:30,800
to make end-to-end sense

1098
00:38:30,800 --> 00:38:33,200
we have to think about uh this attack

1099
00:38:33,200 --> 00:38:35,119
and we have to do something about it

1100
00:38:35,119 --> 00:38:36,640
okay

1101
00:38:36,640 --> 00:38:39,920
yes that's that's my high level

1102
00:38:39,920 --> 00:38:41,280
so um

1103
00:38:41,280 --> 00:38:42,640
um

1104
00:38:42,640 --> 00:38:45,200
so uh so let me sort of you know i have

1105
00:38:45,200 --> 00:38:46,720
to show something technical here right i

1106
00:38:46,720 --> 00:38:48,880
can't just sort of you know preach and

1107
00:38:48,880 --> 00:38:51,280
go away uh so let me show you this sort

1108
00:38:51,280 --> 00:38:53,280
of simple observation which is a

1109
00:38:53,280 --> 00:38:57,040
negative result with uh akshay thai and

1110
00:38:57,040 --> 00:38:58,480
shafi

1111
00:38:58,480 --> 00:39:00,640
uh and what we say

1112
00:39:00,640 --> 00:39:02,960
is that even if an adversary does not

1113
00:39:02,960 --> 00:39:04,960
have all these powers cannot choose

1114
00:39:04,960 --> 00:39:06,160
things adaptively it has to be

1115
00:39:06,160 --> 00:39:08,800
non-adaptive cannot choose so out of

1116
00:39:08,800 --> 00:39:10,800
distribution queries in fact

1117
00:39:10,800 --> 00:39:13,760
very benign looking adversaries even

1118
00:39:13,760 --> 00:39:16,320
those adversaries can be

1119
00:39:16,320 --> 00:39:19,200
lethal can actually do model stealing

1120
00:39:19,200 --> 00:39:20,480
um

1121
00:39:20,480 --> 00:39:21,520
you know

1122
00:39:21,520 --> 00:39:23,280
and that's uh that's that's our result

1123
00:39:23,280 --> 00:39:25,760
so more uh concretely

1124
00:39:25,760 --> 00:39:27,280
what we say is that there's a class of

1125
00:39:27,280 --> 00:39:29,920
models which are stealable

1126
00:39:29,920 --> 00:39:31,920
even by a non-adaptive adversaries whose

1127
00:39:31,920 --> 00:39:35,359
queries are jointly statistically close

1128
00:39:35,359 --> 00:39:37,280
to the data distribution so in other

1129
00:39:37,280 --> 00:39:38,160
words

1130
00:39:38,160 --> 00:39:39,920
you know if i'm sitting on the other end

1131
00:39:39,920 --> 00:39:42,240
trying to detect some anomaly in the

1132
00:39:42,240 --> 00:39:44,400
list of queries i won't be able to

1133
00:39:44,400 --> 00:39:46,000
because the queries look

1134
00:39:46,000 --> 00:39:47,440
jointly

1135
00:39:47,440 --> 00:39:48,320
close

1136
00:39:48,320 --> 00:39:50,320
to the prescribed distribution which in

1137
00:39:50,320 --> 00:39:51,520
this case will be the uniform

1138
00:39:51,520 --> 00:39:53,760
distribution and yet the guy will

1139
00:39:53,760 --> 00:39:55,200
actually manage to

1140
00:39:55,200 --> 00:39:57,520
completely reconstruct the model okay so

1141
00:39:57,520 --> 00:39:59,119
that's terrifying

1142
00:39:59,119 --> 00:40:01,119
okay so it says you know it's it's

1143
00:40:01,119 --> 00:40:03,280
unpreventable you know this really is an

1144
00:40:03,280 --> 00:40:04,880
unpreventable attack

1145
00:40:04,880 --> 00:40:06,560
so here's my model this is going to come

1146
00:40:06,560 --> 00:40:07,920
from the cryptographic world probably

1147
00:40:07,920 --> 00:40:09,119
nothing like what you see in the real

1148
00:40:09,119 --> 00:40:10,560
world but you know that's that's where i

1149
00:40:10,560 --> 00:40:13,599
live okay so so that's what you get

1150
00:40:13,599 --> 00:40:15,040
uh here's the model the model has a

1151
00:40:15,040 --> 00:40:16,800
vector s in its head okay so this is a

1152
00:40:16,800 --> 00:40:19,119
vector is from a finite field um the

1153
00:40:19,119 --> 00:40:21,440
queries are vectors themselves and the

1154
00:40:21,440 --> 00:40:23,599
answer is inner product between the two

1155
00:40:23,599 --> 00:40:25,040
vectors the query vector and the model

1156
00:40:25,040 --> 00:40:27,280
vector okay

1157
00:40:27,280 --> 00:40:28,720
so it's the first state so this is

1158
00:40:28,720 --> 00:40:30,240
actually easy to steal even with random

1159
00:40:30,240 --> 00:40:32,240
queries even if you don't do anything if

1160
00:40:32,240 --> 00:40:33,839
you just keep getting sort of random

1161
00:40:33,839 --> 00:40:36,000
sort of a in a product ss for random ace

1162
00:40:36,000 --> 00:40:37,280
you can steal it okay so that's not what

1163
00:40:37,280 --> 00:40:38,960
i'm going to do i'm going to modify this

1164
00:40:38,960 --> 00:40:40,560
a little bit i'm going to

1165
00:40:40,560 --> 00:40:43,359
have the model actually return a noisy

1166
00:40:43,359 --> 00:40:44,400
answer

1167
00:40:44,400 --> 00:40:46,880
to the inner product question

1168
00:40:46,880 --> 00:40:48,079
okay

1169
00:40:48,079 --> 00:40:50,520
now this has two effects

1170
00:40:50,520 --> 00:40:53,200
one um first of all this is easy to

1171
00:40:53,200 --> 00:40:55,359
steal with correlated queries okay so if

1172
00:40:55,359 --> 00:40:57,200
you can make sort of queries

1173
00:40:57,200 --> 00:40:59,440
individually that look like uniform but

1174
00:40:59,440 --> 00:41:01,280
they're correlated across the queries

1175
00:41:01,280 --> 00:41:03,280
then you can actually steal it uh and

1176
00:41:03,280 --> 00:41:04,960
the answer to cryptographers should be

1177
00:41:04,960 --> 00:41:06,960
obvious should be immediate that uses

1178
00:41:06,960 --> 00:41:08,319
gold right club

1179
00:41:08,319 --> 00:41:09,359
okay

1180
00:41:09,359 --> 00:41:11,440
so people have written papers about this

1181
00:41:11,440 --> 00:41:13,440
uh you know actually doing this in

1182
00:41:13,440 --> 00:41:16,079
practice uh and guess what they use uh

1183
00:41:16,079 --> 00:41:17,599
sort of differential cryptanalysis but

1184
00:41:17,599 --> 00:41:19,119
different script analysis is i guess

1185
00:41:19,119 --> 00:41:21,200
what it's called and clapping okay so at

1186
00:41:21,200 --> 00:41:23,119
the end of the day goldrich levin or

1187
00:41:23,119 --> 00:41:24,640
differential crypto analysis which came

1188
00:41:24,640 --> 00:41:26,560
a few years later in the open literature

1189
00:41:26,560 --> 00:41:29,280
uh you know tell you how to how to

1190
00:41:29,280 --> 00:41:30,480
actually do this

1191
00:41:30,480 --> 00:41:32,000
with correlated queries and correlated

1192
00:41:32,000 --> 00:41:33,200
queries are super important for

1193
00:41:33,200 --> 00:41:35,598
colorectal

1194
00:41:36,240 --> 00:41:38,319
on the other hand if i'm just given many

1195
00:41:38,319 --> 00:41:40,720
samples a and a in a product s plus e

1196
00:41:40,720 --> 00:41:42,640
noise c and a product s

1197
00:41:42,640 --> 00:41:43,440
then

1198
00:41:43,440 --> 00:41:45,040
regiffs learning this is regat's

1199
00:41:45,040 --> 00:41:46,560
learning with errors problem you cannot

1200
00:41:46,560 --> 00:41:48,079
do anything about it in fact these you

1201
00:41:48,079 --> 00:41:49,839
cannot reconstruct us in fact these

1202
00:41:49,839 --> 00:41:52,400
things look totally random to you

1203
00:41:52,400 --> 00:41:54,880
okay so that's fact two

1204
00:41:54,880 --> 00:41:56,960
so now you look at my theorem and say

1205
00:41:56,960 --> 00:41:58,960
how can you possibly prove this theorem

1206
00:41:58,960 --> 00:42:00,319
right

1207
00:42:00,319 --> 00:42:02,480
the queries of the non-adaptive

1208
00:42:02,480 --> 00:42:04,720
adversary they look jointly close to

1209
00:42:04,720 --> 00:42:07,119
just getting many a's right together

1210
00:42:07,119 --> 00:42:08,800
with the inner product s plus

1211
00:42:08,800 --> 00:42:11,599
independent noise

1212
00:42:11,599 --> 00:42:13,359
and isn't that just the rug of learning

1213
00:42:13,359 --> 00:42:14,560
with errors problem how is this

1214
00:42:14,560 --> 00:42:16,960
adversary going to work

1215
00:42:16,960 --> 00:42:20,480
well here's the key

1216
00:42:21,359 --> 00:42:24,800
the key idea is to use la distractors

1217
00:42:24,800 --> 00:42:26,720
and here's a one slide sort of summary

1218
00:42:26,720 --> 00:42:28,720
of what lattice structures are

1219
00:42:28,720 --> 00:42:31,680
it gives you a way to pick a matrix each

1220
00:42:31,680 --> 00:42:33,200
of the columns of this matrix you should

1221
00:42:33,200 --> 00:42:35,280
think about it as a query in our setting

1222
00:42:35,280 --> 00:42:36,400
right

1223
00:42:36,400 --> 00:42:37,920
you can pick this matrix so that this

1224
00:42:37,920 --> 00:42:40,079
matrix is statistically close to uniform

1225
00:42:40,079 --> 00:42:41,599
so these queries jointly are

1226
00:42:41,599 --> 00:42:44,800
statistically close to iid random right

1227
00:42:44,800 --> 00:42:47,040
but you can pick it together with the

1228
00:42:47,040 --> 00:42:50,160
trap door which is itself a matrix

1229
00:42:50,160 --> 00:42:51,839
such that the product of the two

1230
00:42:51,839 --> 00:42:53,520
matrices is zero molecule so the strap

1231
00:42:53,520 --> 00:42:55,359
door is low norm each entry is very

1232
00:42:55,359 --> 00:42:58,400
small it has full z rank but the product

1233
00:42:58,400 --> 00:43:00,160
is actually zero model

1234
00:43:00,160 --> 00:43:02,160
okay this is the magic of larissa came

1235
00:43:02,160 --> 00:43:04,480
from itae's work in the 90s

1236
00:43:04,480 --> 00:43:05,920
okay so how are you going to use how is

1237
00:43:05,920 --> 00:43:07,200
this adversary going to use a lot of

1238
00:43:07,200 --> 00:43:08,480
strawberries these queries are going to

1239
00:43:08,480 --> 00:43:09,200
be

1240
00:43:09,200 --> 00:43:10,880
the columns of this matrix it's going to

1241
00:43:10,880 --> 00:43:12,880
pick this matrix like so right it's

1242
00:43:12,880 --> 00:43:14,240
going to make queries which are columns

1243
00:43:14,240 --> 00:43:16,640
of this matrix

1244
00:43:16,640 --> 00:43:18,079
and it's going to get the answer which

1245
00:43:18,079 --> 00:43:20,000
is s times a plus e which is a vector

1246
00:43:20,000 --> 00:43:21,680
the vector of all answers multiplied by

1247
00:43:21,680 --> 00:43:24,000
t right so you get a times t is 0 so you

1248
00:43:24,000 --> 00:43:25,760
get e times t mod q

1249
00:43:25,760 --> 00:43:28,240
e times t is small so the mod q doesn't

1250
00:43:28,240 --> 00:43:30,079
make a difference this is standard in

1251
00:43:30,079 --> 00:43:31,839
lattice space cryptography it's largest

1252
00:43:31,839 --> 00:43:33,680
of 101 right

1253
00:43:33,680 --> 00:43:35,680
and you get e times t and t is full rank

1254
00:43:35,680 --> 00:43:37,520
over the integers so you can recover e

1255
00:43:37,520 --> 00:43:40,240
and therefore s

1256
00:43:40,240 --> 00:43:43,280
okay so here's an attack that a defender

1257
00:43:43,280 --> 00:43:46,319
looks at it and says it looks exactly

1258
00:43:46,319 --> 00:43:49,760
statistically close to what i expect in

1259
00:43:49,760 --> 00:43:53,359
a in a in a

1260
00:43:53,359 --> 00:43:55,119
benign setting

1261
00:43:55,119 --> 00:43:57,119
and yet it's going to kill me

1262
00:43:57,119 --> 00:43:59,599
okay so what that says is that uh i'm

1263
00:43:59,599 --> 00:44:01,520
not going to talk about this so what it

1264
00:44:01,520 --> 00:44:03,200
says is that

1265
00:44:03,200 --> 00:44:04,800
it's

1266
00:44:04,800 --> 00:44:06,319
you know defending against model

1267
00:44:06,319 --> 00:44:09,920
stealing sounds incredibly difficult

1268
00:44:09,920 --> 00:44:11,440
okay

1269
00:44:11,440 --> 00:44:13,440
lots of attacks against particular

1270
00:44:13,440 --> 00:44:15,119
models and some of these attacks papers

1271
00:44:15,119 --> 00:44:16,640
actually come up with defenses but

1272
00:44:16,640 --> 00:44:18,720
defenses without proofs right so so i'm

1273
00:44:18,720 --> 00:44:20,560
not sure what that actually means so i

1274
00:44:20,560 --> 00:44:22,000
would say i would say these are attacks

1275
00:44:22,000 --> 00:44:24,079
okay end of story

1276
00:44:24,079 --> 00:44:25,760
and what we saw is a negative result

1277
00:44:25,760 --> 00:44:28,319
which is an undefendable attack so these

1278
00:44:28,319 --> 00:44:30,400
attacks may be defendable maybe not who

1279
00:44:30,400 --> 00:44:33,359
knows but here is an undefendable attack

1280
00:44:33,359 --> 00:44:36,240
okay so i don't see how to seems like an

1281
00:44:36,240 --> 00:44:37,680
undefined value i don't see how to

1282
00:44:37,680 --> 00:44:39,200
defend against the attack that i just

1283
00:44:39,200 --> 00:44:40,560
talked about at all

1284
00:44:40,560 --> 00:44:41,359
okay

1285
00:44:41,359 --> 00:44:42,640
so

1286
00:44:42,640 --> 00:44:44,240
the open question is

1287
00:44:44,240 --> 00:44:46,720
think about it okay come up with more

1288
00:44:46,720 --> 00:44:49,200
attacks come up with negative results

1289
00:44:49,200 --> 00:44:50,960
that not only tells you that this neural

1290
00:44:50,960 --> 00:44:52,560
network that neural net can be attacked

1291
00:44:52,560 --> 00:44:53,920
or this class of neural network that

1292
00:44:53,920 --> 00:44:55,359
class of neural net can be attacked even

1293
00:44:55,359 --> 00:44:57,119
that is actually an improvement

1294
00:44:57,119 --> 00:44:59,920
but really say what can and cannot be

1295
00:44:59,920 --> 00:45:03,520
done fundamentally in this area

1296
00:45:03,520 --> 00:45:05,440
okay i didn't talk about the we have a

1297
00:45:05,440 --> 00:45:08,160
toy positive result and uh and you know

1298
00:45:08,160 --> 00:45:10,400
um uh i didn't talk about it because

1299
00:45:10,400 --> 00:45:12,079
it's toy it's weak

1300
00:45:12,079 --> 00:45:14,160
uh and uh and uh

1301
00:45:14,160 --> 00:45:16,319
and uh you know uh and then we come up

1302
00:45:16,319 --> 00:45:17,520
with this strategy called measure and

1303
00:45:17,520 --> 00:45:19,520
terminate uh so what that says is you

1304
00:45:19,520 --> 00:45:20,880
know i'm going to look at the queries

1305
00:45:20,880 --> 00:45:22,240
i'm going to measure the information

1306
00:45:22,240 --> 00:45:23,520
content that that reveals how much

1307
00:45:23,520 --> 00:45:25,200
information about that but the model

1308
00:45:25,200 --> 00:45:27,119
doesn't reveal and if it becomes too

1309
00:45:27,119 --> 00:45:28,560
much then i say

1310
00:45:28,560 --> 00:45:30,079
i'm done okay

1311
00:45:30,079 --> 00:45:31,680
so you can actually use that strategy to

1312
00:45:31,680 --> 00:45:34,160
protect against very very very simple

1313
00:45:34,160 --> 00:45:35,599
models so maybe i'll show you the

1314
00:45:35,599 --> 00:45:36,800
picture here

1315
00:45:36,800 --> 00:45:38,960
this is a model

1316
00:45:38,960 --> 00:45:40,720
uh oh yeah

1317
00:45:40,720 --> 00:45:42,960
okay here's a model okay the model is uh

1318
00:45:42,960 --> 00:45:45,520
you know points on a unit uh circle

1319
00:45:45,520 --> 00:45:46,880
some points are positive and some points

1320
00:45:46,880 --> 00:45:48,079
negative and hyperplane separates

1321
00:45:48,079 --> 00:45:49,920
between them and here you can actually

1322
00:45:49,920 --> 00:45:52,480
measure f efficiently

1323
00:45:52,480 --> 00:45:53,839
how much information did you reveal

1324
00:45:53,839 --> 00:45:55,839
about the model and even that is very a

1325
00:45:55,839 --> 00:45:57,440
very questionable sort of positive

1326
00:45:57,440 --> 00:45:59,520
result because you know these queries

1327
00:45:59,520 --> 00:46:01,599
may not all come from the same

1328
00:46:01,599 --> 00:46:03,200
person there could be collusions of

1329
00:46:03,200 --> 00:46:05,920
people each one looks truly random but

1330
00:46:05,920 --> 00:46:07,920
together they can actually sort of uh

1331
00:46:07,920 --> 00:46:09,040
you know they can actually do funny

1332
00:46:09,040 --> 00:46:09,920
things

1333
00:46:09,920 --> 00:46:11,920
uh and in slight even slightly more

1334
00:46:11,920 --> 00:46:13,920
general sort of models measuring this

1335
00:46:13,920 --> 00:46:15,760
information is an intractable problem

1336
00:46:15,760 --> 00:46:18,240
just computationally seems very complex

1337
00:46:18,240 --> 00:46:19,520
so

1338
00:46:19,520 --> 00:46:22,079
what do i do i don't know right that's

1339
00:46:22,079 --> 00:46:24,079
why it's an unpublished result uh at

1340
00:46:24,079 --> 00:46:26,079
this point so we uh we were thinking of

1341
00:46:26,079 --> 00:46:27,760
sending it to cfail and we might

1342
00:46:27,760 --> 00:46:29,280
actually at some point

1343
00:46:29,280 --> 00:46:31,520
but you know it seems uh

1344
00:46:31,520 --> 00:46:33,359
seems uh it seems very open

1345
00:46:33,359 --> 00:46:34,880
but i i think

1346
00:46:34,880 --> 00:46:36,560
for the field of secure inference to

1347
00:46:36,560 --> 00:46:38,560
make sense we must

1348
00:46:38,560 --> 00:46:40,839
think about this this

1349
00:46:40,839 --> 00:46:43,119
question okay

1350
00:46:43,119 --> 00:46:45,280
and that's only the tip of the iceberg i

1351
00:46:45,280 --> 00:46:46,720
really didn't get to talk about so many

1352
00:46:46,720 --> 00:46:48,800
other problems that that come up in the

1353
00:46:48,800 --> 00:46:50,319
gap between secure computation and

1354
00:46:50,319 --> 00:46:51,920
privacy preserving machine learning

1355
00:46:51,920 --> 00:46:53,200
first of all the administrator gets to

1356
00:46:53,200 --> 00:46:55,359
pick the input okay

1357
00:46:55,359 --> 00:46:56,400
so

1358
00:46:56,400 --> 00:46:58,480
what do we do uh in secure computation

1359
00:46:58,480 --> 00:47:00,319
we say ah

1360
00:47:00,319 --> 00:47:02,079
what are you gonna do about it okay so

1361
00:47:02,079 --> 00:47:03,200
you can pick the input you can pick the

1362
00:47:03,200 --> 00:47:04,480
input

1363
00:47:04,480 --> 00:47:07,119
now you know if um

1364
00:47:07,119 --> 00:47:08,800
the function to be computed is fixed

1365
00:47:08,800 --> 00:47:10,560
then we may not be able to do anything

1366
00:47:10,560 --> 00:47:12,640
but what differential privacy taught us

1367
00:47:12,640 --> 00:47:14,160
is that the function that we want to

1368
00:47:14,160 --> 00:47:16,480
compute on data may not sort of come

1369
00:47:16,480 --> 00:47:19,200
right from god we may be able to design

1370
00:47:19,200 --> 00:47:21,119
it

1371
00:47:21,119 --> 00:47:22,079
to be

1372
00:47:22,079 --> 00:47:25,520
better okay so you may be able to design

1373
00:47:25,520 --> 00:47:27,520
functions that compute the same so

1374
00:47:27,520 --> 00:47:29,599
achieve the same end goal

1375
00:47:29,599 --> 00:47:31,280
which may be robust you should look at

1376
00:47:31,280 --> 00:47:32,960
you should look at the field of robust

1377
00:47:32,960 --> 00:47:34,960
citizens through the to the

1378
00:47:34,960 --> 00:47:37,760
hot field of robust statistics for clues

1379
00:47:37,760 --> 00:47:39,359
on what to do here

1380
00:47:39,359 --> 00:47:40,960
the other question that comes up is

1381
00:47:40,960 --> 00:47:42,559
strategic input so so again you know

1382
00:47:42,559 --> 00:47:43,839
let's say i want to train a machine

1383
00:47:43,839 --> 00:47:45,920
learning model you know i have a million

1384
00:47:45,920 --> 00:47:48,240
data points and well let's split the

1385
00:47:48,240 --> 00:47:50,160
role okay so this is more accurate

1386
00:47:50,160 --> 00:47:53,200
antigone has a million data points and i

1387
00:47:53,200 --> 00:47:55,520
have a hundred data points okay it's not

1388
00:47:55,520 --> 00:47:57,119
inaccurate from where i stand and where

1389
00:47:57,119 --> 00:47:59,119
she stands

1390
00:47:59,119 --> 00:48:01,200
and we want to do i go to antigone and

1391
00:48:01,200 --> 00:48:02,880
say look let's do secure computation and

1392
00:48:02,880 --> 00:48:04,880
let's train a model on our collective

1393
00:48:04,880 --> 00:48:07,520
data okay and she should come back to me

1394
00:48:07,520 --> 00:48:10,720
and say why should i do it you know so

1395
00:48:10,720 --> 00:48:12,640
she is contributing so much more data

1396
00:48:12,640 --> 00:48:14,000
into the process

1397
00:48:14,000 --> 00:48:15,280
at the end of the secure computation

1398
00:48:15,280 --> 00:48:17,040
we're both going to get the same model

1399
00:48:17,040 --> 00:48:20,319
why should she do it

1400
00:48:20,319 --> 00:48:22,160
so this is a question of strategic

1401
00:48:22,160 --> 00:48:24,079
inputs and the value of data and this

1402
00:48:24,079 --> 00:48:26,480
has been sort of uh you know addressed

1403
00:48:26,480 --> 00:48:27,760
or rather

1404
00:48:27,760 --> 00:48:29,280
uh people have started looking at it

1405
00:48:29,280 --> 00:48:31,280
there's a work of christos papa demetrio

1406
00:48:31,280 --> 00:48:33,599
and costas duskalakis that address this

1407
00:48:33,599 --> 00:48:34,720
question is quite there's a work of

1408
00:48:34,720 --> 00:48:36,000
shapi gulva

1409
00:48:36,000 --> 00:48:37,839
sunu park and pablo azar that also look

1410
00:48:37,839 --> 00:48:39,760
at this question but really these are

1411
00:48:39,760 --> 00:48:42,800
sort of like you know blind people

1412
00:48:42,800 --> 00:48:44,480
looking at the elephant i don't think we

1413
00:48:44,480 --> 00:48:46,079
really have a i don't want to call these

1414
00:48:46,079 --> 00:48:48,480
blind people in their they're amazing

1415
00:48:48,480 --> 00:48:51,520
people but we haven't started to scratch

1416
00:48:51,520 --> 00:48:53,920
the surface of this area

1417
00:48:53,920 --> 00:48:55,680
again you know the problem that

1418
00:48:55,680 --> 00:48:57,200
amsterdam gets to see the output even

1419
00:48:57,200 --> 00:48:59,520
without the repeated executions is a

1420
00:48:59,520 --> 00:49:00,880
question of how much information about

1421
00:49:00,880 --> 00:49:03,200
the inputs does this process reveal this

1422
00:49:03,200 --> 00:49:04,800
differential privacy which addresses a

1423
00:49:04,800 --> 00:49:06,800
part of this question but not everything

1424
00:49:06,800 --> 00:49:08,160
right so the differential privacy

1425
00:49:08,160 --> 00:49:10,400
framework says i'm going to hide i'm

1426
00:49:10,400 --> 00:49:12,160
going to let individuals hide in the

1427
00:49:12,160 --> 00:49:13,440
data

1428
00:49:13,440 --> 00:49:14,880
but it could be that in the process of

1429
00:49:14,880 --> 00:49:16,079
computing a differentially private

1430
00:49:16,079 --> 00:49:18,240
estimate of the height of a population i

1431
00:49:18,240 --> 00:49:19,680
also reveal a differentially private

1432
00:49:19,680 --> 00:49:21,599
estimate of the weight of the population

1433
00:49:21,599 --> 00:49:23,040
that would be good

1434
00:49:23,040 --> 00:49:24,720
so there's a new set of works on

1435
00:49:24,720 --> 00:49:26,559
attribute privacy that address these

1436
00:49:26,559 --> 00:49:28,160
questions so functional privacy or

1437
00:49:28,160 --> 00:49:29,440
attribute privacy that addresses

1438
00:49:29,440 --> 00:49:32,079
question again lots more people from our

1439
00:49:32,079 --> 00:49:33,119
community

1440
00:49:33,119 --> 00:49:35,280
need to be aware of these works we need

1441
00:49:35,280 --> 00:49:36,720
to think about them

1442
00:49:36,720 --> 00:49:38,640
we need to make progress

1443
00:49:38,640 --> 00:49:39,760
on them

1444
00:49:39,760 --> 00:49:41,599
with that

1445
00:49:41,599 --> 00:49:45,079
thank you very much

1446
00:49:46,800 --> 00:49:49,200
thank you very much vinod uh any

1447
00:49:49,200 --> 00:49:50,240
questions

1448
00:49:50,240 --> 00:49:51,920
we had

1449
00:49:51,920 --> 00:49:54,160
many questions about the chat maybe it's

1450
00:49:54,160 --> 00:49:56,720
good also too uh

1451
00:49:56,720 --> 00:49:59,440
so maybe i can go from the bottom up uh

1452
00:49:59,440 --> 00:50:01,599
amit asks the negative results just for

1453
00:50:01,599 --> 00:50:03,599
the class of models can you comment more

1454
00:50:03,599 --> 00:50:05,599
on how broad narrow it this class plus

1455
00:50:05,599 --> 00:50:08,240
this class is very narrow right it's

1456
00:50:08,240 --> 00:50:10,160
linear functions over a finite field

1457
00:50:10,160 --> 00:50:11,760
which never comes up in practice as far

1458
00:50:11,760 --> 00:50:14,319
as i my machine learning friends tell me

1459
00:50:14,319 --> 00:50:16,558
um

1460
00:50:17,280 --> 00:50:19,040
you know it's just a template right it's

1461
00:50:19,040 --> 00:50:21,920
template on what could possibly go wrong

1462
00:50:21,920 --> 00:50:24,640
and um i'll post it to you as an open

1463
00:50:24,640 --> 00:50:26,400
problem to come up with more

1464
00:50:26,400 --> 00:50:28,559
wide-ranging negative results or come up

1465
00:50:28,559 --> 00:50:31,680
with positive results okay

1466
00:50:31,680 --> 00:50:33,359
uh carson asks when will the paper be

1467
00:50:33,359 --> 00:50:35,520
available soon coming to an e-print next

1468
00:50:35,520 --> 00:50:37,759
to you

1469
00:50:38,000 --> 00:50:40,160
ami it says does the extension to any

1470
00:50:40,160 --> 00:50:42,640
arbitrary data distribution work by just

1471
00:50:42,640 --> 00:50:45,200
speaking weighted uniformly distractors

1472
00:50:45,200 --> 00:50:46,559
so that's a very good question we

1473
00:50:46,559 --> 00:50:48,240
haven't thought about that

1474
00:50:48,240 --> 00:50:49,760
um

1475
00:50:49,760 --> 00:50:51,119
very good question let me just kind of

1476
00:50:51,119 --> 00:50:53,280
leave it at that okay i don't know the

1477
00:50:53,280 --> 00:50:55,119
answer potentially possible but i don't

1478
00:50:55,119 --> 00:50:57,040
know the answer

1479
00:50:57,040 --> 00:50:58,880
and the other questions thank you very

1480
00:50:58,880 --> 00:51:01,040
much karsten answered

1481
00:51:01,040 --> 00:51:03,040
the other questions um

1482
00:51:03,040 --> 00:51:05,119
when carson says secret sharing thank

1483
00:51:05,119 --> 00:51:06,240
you

1484
00:51:06,240 --> 00:51:08,640
he could have written the paper half the

1485
00:51:08,640 --> 00:51:11,359
paper at least

1486
00:51:11,359 --> 00:51:14,240
okay so i uh i'll welcome any more

1487
00:51:14,240 --> 00:51:17,240
questions

1488
00:51:25,119 --> 00:51:28,079
okay good okay that's it thank you so

1489
00:51:28,079 --> 00:51:31,440
much bye thank you sounds great

1490
00:51:31,440 --> 00:51:33,920
i will tell

