1
00:00:02,879 --> 00:00:04,880
hello and welcome to this talk on the

2
00:00:04,880 --> 00:00:05,600
topic of

3
00:00:05,600 --> 00:00:08,080
voter tags on cca secured latest camps

4
00:00:08,080 --> 00:00:10,240
my name is peter pessl and the paper

5
00:00:10,240 --> 00:00:12,880
this work is this talk is based on is

6
00:00:12,880 --> 00:00:13,920
joint work with

7
00:00:13,920 --> 00:00:16,880
luka spockop so i think you've already

8
00:00:16,880 --> 00:00:18,320
heard your fair share on the topic of

9
00:00:18,320 --> 00:00:20,000
quantum computers and john's algorithm

10
00:00:20,000 --> 00:00:20,880
and whatnot

11
00:00:20,880 --> 00:00:22,720
but still to get everyone on the same

12
00:00:22,720 --> 00:00:25,279
page nist is currently running a

13
00:00:25,279 --> 00:00:28,480
standardization process

14
00:00:28,480 --> 00:00:30,960
for post-quantum cryptography and this

15
00:00:30,960 --> 00:00:33,040
standardization process is currently in

16
00:00:33,040 --> 00:00:34,160
the third and

17
00:00:34,160 --> 00:00:36,880
kind of final round and amongst the

18
00:00:36,880 --> 00:00:37,840
finalists

19
00:00:37,840 --> 00:00:40,399
are free lattice-based key encapsulation

20
00:00:40,399 --> 00:00:41,120
mechanisms

21
00:00:41,120 --> 00:00:44,160
namely kyber and true and

22
00:00:44,160 --> 00:00:48,960
sabre and nist is expected to pick

23
00:00:48,960 --> 00:00:50,239
one out of these three for

24
00:00:50,239 --> 00:00:52,079
standardization by

25
00:00:52,079 --> 00:00:56,000
the end of this year so that's very soon

26
00:00:56,000 --> 00:00:58,079
now this process is also quite

27
00:00:58,079 --> 00:00:59,760
interesting when it comes to to the

28
00:00:59,760 --> 00:01:01,440
application in embedded

29
00:01:01,440 --> 00:01:04,479
devices because these three lattice

30
00:01:04,479 --> 00:01:06,720
based cams are actually quite a nice fit

31
00:01:06,720 --> 00:01:07,520
for such

32
00:01:07,520 --> 00:01:10,560
resource constraint devices as they

33
00:01:10,560 --> 00:01:13,840
can typically outperform in terms of

34
00:01:13,840 --> 00:01:15,280
runtime

35
00:01:15,280 --> 00:01:17,920
classic public key cryptography such as

36
00:01:17,920 --> 00:01:18,560
rsa

37
00:01:18,560 --> 00:01:21,360
and ecc that's of course nice but

38
00:01:21,360 --> 00:01:22,799
performance isn't everything in the

39
00:01:22,799 --> 00:01:23,840
embedded world

40
00:01:23,840 --> 00:01:26,000
because these devices are typically

41
00:01:26,000 --> 00:01:27,119
shipped to

42
00:01:27,119 --> 00:01:29,520
god knows where they are out somewhere

43
00:01:29,520 --> 00:01:30,960
in the field

44
00:01:30,960 --> 00:01:32,400
this which means that they are

45
00:01:32,400 --> 00:01:34,720
accessible to attackers

46
00:01:34,720 --> 00:01:36,560
which of course opens the gate to

47
00:01:36,560 --> 00:01:38,960
implementation attacks

48
00:01:38,960 --> 00:01:40,960
now when we want to look at

49
00:01:40,960 --> 00:01:42,880
implementation attacks for such

50
00:01:42,880 --> 00:01:46,240
relatively new schemes there are two

51
00:01:46,240 --> 00:01:48,640
main challenges that we need to tackle

52
00:01:48,640 --> 00:01:50,159
and the first is to actually

53
00:01:50,159 --> 00:01:53,280
find and understand vulnerabilities to

54
00:01:53,280 --> 00:01:56,079
find out how we can attack them and then

55
00:01:56,079 --> 00:01:56,719
in the next

56
00:01:56,719 --> 00:02:00,159
step to find appropriate countermeasures

57
00:02:00,159 --> 00:02:04,159
to protect against the attacks

58
00:02:04,240 --> 00:02:07,280
now what's the current status of

59
00:02:07,280 --> 00:02:08,080
implementation

60
00:02:08,080 --> 00:02:10,720
attacks and countermeasures of such

61
00:02:10,720 --> 00:02:12,160
lattice based camps

62
00:02:12,160 --> 00:02:15,120
well for the first big category of

63
00:02:15,120 --> 00:02:17,040
implementation attacks that is that of

64
00:02:17,040 --> 00:02:19,280
side channel attacks such as power

65
00:02:19,280 --> 00:02:20,239
analysis

66
00:02:20,239 --> 00:02:23,920
e or em measurements stuff like that

67
00:02:23,920 --> 00:02:26,720
well there are already a couple of works

68
00:02:26,720 --> 00:02:28,720
published so we have seen various

69
00:02:28,720 --> 00:02:29,440
attacks

70
00:02:29,440 --> 00:02:31,680
ranging from differential power analysis

71
00:02:31,680 --> 00:02:32,480
to

72
00:02:32,480 --> 00:02:34,800
algebraic single trace multi-trace

73
00:02:34,800 --> 00:02:37,040
attacks to side channel assisted chosen

74
00:02:37,040 --> 00:02:39,760
ciphertext attacks

75
00:02:39,760 --> 00:02:42,640
and we've also seen the first protected

76
00:02:42,640 --> 00:02:43,680
in terms of

77
00:02:43,680 --> 00:02:47,760
masked implementations of these cams

78
00:02:47,760 --> 00:02:50,800
now the picture is quite a bit different

79
00:02:50,800 --> 00:02:52,720
for the second big category of

80
00:02:52,720 --> 00:02:54,080
implementation attacks

81
00:02:54,080 --> 00:02:56,800
which is a fault attacks there's

82
00:02:56,800 --> 00:02:57,440
actually

83
00:02:57,440 --> 00:02:59,760
very little published work on fault

84
00:02:59,760 --> 00:03:00,959
attacks on these

85
00:03:00,959 --> 00:03:04,159
lattice-based cams

86
00:03:04,159 --> 00:03:06,720
and that's also quite a little

87
00:03:06,720 --> 00:03:07,519
information

88
00:03:07,519 --> 00:03:09,440
on how to achieve protection it's

89
00:03:09,440 --> 00:03:11,120
difficult to protect against something

90
00:03:11,120 --> 00:03:11,599
which

91
00:03:11,599 --> 00:03:15,440
you don't know what it looks like

92
00:03:15,760 --> 00:03:18,640
now these three cams are also

93
00:03:18,640 --> 00:03:19,840
interesting

94
00:03:19,840 --> 00:03:22,959
in one way in that they quite

95
00:03:22,959 --> 00:03:25,760
share a lot of high level similarities

96
00:03:25,760 --> 00:03:28,239
which makes them

97
00:03:28,239 --> 00:03:30,080
interesting to analyze because when you

98
00:03:30,080 --> 00:03:33,040
find an attack or a counter measure then

99
00:03:33,040 --> 00:03:34,720
this attack or counter measure might

100
00:03:34,720 --> 00:03:36,159
apply to multiple

101
00:03:36,159 --> 00:03:39,680
schemes instead of just one of them

102
00:03:39,680 --> 00:03:41,680
and for instance two of the schemes

103
00:03:41,680 --> 00:03:43,440
kyber and sabre

104
00:03:43,440 --> 00:03:45,920
can be seen as more or less direct

105
00:03:45,920 --> 00:03:46,799
descendants

106
00:03:46,799 --> 00:03:49,599
of an encryption scheme by lubashevsky

107
00:03:49,599 --> 00:03:50,239
picada and

108
00:03:50,239 --> 00:03:53,920
golsan and this scheme is colloquially

109
00:03:53,920 --> 00:03:54,400
known

110
00:03:54,400 --> 00:03:57,519
as the lpr encryption scheme lpr

111
00:03:57,519 --> 00:04:00,640
is a cpa secure public key encryption

112
00:04:00,640 --> 00:04:01,360
scheme

113
00:04:01,360 --> 00:04:03,840
which bases its security on the hardness

114
00:04:03,840 --> 00:04:04,480
of the

115
00:04:04,480 --> 00:04:08,399
ring learning with errors problem

116
00:04:08,720 --> 00:04:10,959
and another singularity that actually

117
00:04:10,959 --> 00:04:12,720
all three lattice based

118
00:04:12,720 --> 00:04:16,079
camps so cable cyber and andrew share

119
00:04:16,079 --> 00:04:19,358
is that they use some variant

120
00:04:19,358 --> 00:04:22,800
of the fujisaki okamoto or fo

121
00:04:22,800 --> 00:04:27,040
transform the fo transform in general

122
00:04:27,040 --> 00:04:29,680
transforms a chosen plaintext secure

123
00:04:29,680 --> 00:04:31,680
public key encryption scheme

124
00:04:31,680 --> 00:04:34,479
to a chosen ciphertext key encapsulation

125
00:04:34,479 --> 00:04:35,520
mechanism

126
00:04:35,520 --> 00:04:39,440
and the basic idea behind this fo

127
00:04:39,440 --> 00:04:41,600
you can see in the in the figure below

128
00:04:41,600 --> 00:04:42,960
which shows a

129
00:04:42,960 --> 00:04:45,759
simplified variant of of nfo of a

130
00:04:45,759 --> 00:04:47,199
possible fo

131
00:04:47,199 --> 00:04:49,360
and works as follows it first takes the

132
00:04:49,360 --> 00:04:50,880
ciphertext

133
00:04:50,880 --> 00:04:54,400
and decrypts it with a secret key sk

134
00:04:54,400 --> 00:04:57,520
and as a result you get a message m

135
00:04:57,520 --> 00:05:00,880
you then re-encrypt this message m

136
00:05:00,880 --> 00:05:04,479
using the public key and a randomness

137
00:05:04,479 --> 00:05:06,639
which is generated in some deterministic

138
00:05:06,639 --> 00:05:08,160
manner here in this figure

139
00:05:08,160 --> 00:05:10,800
it's done by hashing the message

140
00:05:10,800 --> 00:05:11,919
together with the public

141
00:05:11,919 --> 00:05:15,360
key and then you take the output of this

142
00:05:15,360 --> 00:05:16,400
re-encryption

143
00:05:16,400 --> 00:05:18,720
and compare it to the cipher text you

144
00:05:18,720 --> 00:05:20,479
originally received

145
00:05:20,479 --> 00:05:23,600
and you returned the secret the shared

146
00:05:23,600 --> 00:05:24,080
secret

147
00:05:24,080 --> 00:05:27,360
k only if these two cipher texts

148
00:05:27,360 --> 00:05:30,240
match if they don't match then you have

149
00:05:30,240 --> 00:05:31,840
to conclude that the cipher text you

150
00:05:31,840 --> 00:05:32,720
received was

151
00:05:32,720 --> 00:05:35,919
tempered wasn't honestly generated and

152
00:05:35,919 --> 00:05:36,560
so you

153
00:05:36,560 --> 00:05:38,720
might return for instance a a random

154
00:05:38,720 --> 00:05:40,720
shared secret or an error signal

155
00:05:40,720 --> 00:05:43,280
something like that

156
00:05:43,280 --> 00:05:46,160
now what's interesting here from an

157
00:05:46,160 --> 00:05:48,800
implementation security perspective is

158
00:05:48,800 --> 00:05:49,840
that

159
00:05:49,840 --> 00:05:52,880
well we from implementation security we

160
00:05:52,880 --> 00:05:55,120
know this picture we often do

161
00:05:55,120 --> 00:05:58,319
for instance in the aes we take

162
00:05:58,319 --> 00:06:00,880
uh a ciphertext decrypt it then

163
00:06:00,880 --> 00:06:02,560
re-encrypt it and check

164
00:06:02,560 --> 00:06:06,479
if if the ciphertexts then again match

165
00:06:06,479 --> 00:06:08,400
and we use this as a fault counter

166
00:06:08,400 --> 00:06:09,919
measure so this is

167
00:06:09,919 --> 00:06:13,280
unintentionally kind of a built-in

168
00:06:13,280 --> 00:06:16,719
default countermeasure

169
00:06:16,880 --> 00:06:19,759
this of course then begs the question

170
00:06:19,759 --> 00:06:20,560
well if

171
00:06:20,560 --> 00:06:24,400
if these schemes have like a built-in

172
00:06:24,400 --> 00:06:26,639
fault counter measure with this fujisaki

173
00:06:26,639 --> 00:06:28,080
or kamato transform

174
00:06:28,080 --> 00:06:31,840
do we even need to care about

175
00:06:31,840 --> 00:06:34,560
faults anymore do we just need to

176
00:06:34,560 --> 00:06:37,600
protect this transformation or whatnot

177
00:06:37,600 --> 00:06:39,440
well as you might have guessed from the

178
00:06:39,440 --> 00:06:41,440
title of this talk

179
00:06:41,440 --> 00:06:44,400
is this still very much possible and

180
00:06:44,400 --> 00:06:47,120
practical to attack

181
00:06:47,120 --> 00:06:49,840
uh these schemes which we show by

182
00:06:49,840 --> 00:06:51,520
presenting such an attack

183
00:06:51,520 --> 00:06:54,800
so our conclusion is yes if f fujisaki

184
00:06:54,800 --> 00:06:56,800
or kamoto is a fault deterrent it makes

185
00:06:56,800 --> 00:06:57,759
them

186
00:06:57,759 --> 00:07:00,960
mix attacks more difficult but it's not

187
00:07:00,960 --> 00:07:02,000
a counter measure as

188
00:07:02,000 --> 00:07:05,360
such so fault attacks are still

189
00:07:05,360 --> 00:07:07,919
possible

190
00:07:09,120 --> 00:07:12,160
our attack works by skipping an

191
00:07:12,160 --> 00:07:14,880
instruction at a specific spot

192
00:07:14,880 --> 00:07:18,080
and the trick is then to not observe

193
00:07:18,080 --> 00:07:21,759
the the output of of the

194
00:07:21,759 --> 00:07:25,120
uh the output of the decapsulation which

195
00:07:25,120 --> 00:07:27,599
would be the shared secret directly

196
00:07:27,599 --> 00:07:30,800
but instead just making a binary

197
00:07:30,800 --> 00:07:34,000
observation and to test does

198
00:07:34,000 --> 00:07:36,160
the is the shared secret still the

199
00:07:36,160 --> 00:07:37,680
correct value or

200
00:07:37,680 --> 00:07:41,120
is it something else which means a fault

201
00:07:41,120 --> 00:07:44,639
or it was detected

202
00:07:44,639 --> 00:07:47,440
now this outcome actually carries

203
00:07:47,440 --> 00:07:49,599
information on the private key

204
00:07:49,599 --> 00:07:53,120
and after uh gathering enough

205
00:07:53,120 --> 00:07:55,520
information over many invocations of the

206
00:07:55,520 --> 00:07:56,479
decapsulation

207
00:07:56,479 --> 00:07:59,520
where in each invocation we uh

208
00:07:59,520 --> 00:08:03,199
inject the fault we solve for the key

209
00:08:03,199 --> 00:08:07,280
and we can attack kyber

210
00:08:07,280 --> 00:08:11,120
and new hope which is a scheme that was

211
00:08:11,120 --> 00:08:13,759
didn't advance into the third round with

212
00:08:13,759 --> 00:08:14,400
a minimum

213
00:08:14,400 --> 00:08:17,919
of 6 000 volts but

214
00:08:17,919 --> 00:08:20,400
we also highlight that our attack has

215
00:08:20,400 --> 00:08:22,560
the potential to also be applied

216
00:08:22,560 --> 00:08:25,599
to other schemes because of the effort

217
00:08:25,599 --> 00:08:30,319
aforementioned similarities between them

218
00:08:30,639 --> 00:08:34,080
now in order to explain this attack i

219
00:08:34,080 --> 00:08:34,880
have to

220
00:08:34,880 --> 00:08:37,440
give you a brief introduction into this

221
00:08:37,440 --> 00:08:39,279
lpr encryption scheme

222
00:08:39,279 --> 00:08:41,599
i like to always describe it as a kind

223
00:08:41,599 --> 00:08:43,519
of noisy elgamal

224
00:08:43,519 --> 00:08:46,720
encryption so

225
00:08:46,720 --> 00:08:50,560
this lpr works in elements in rq

226
00:08:50,560 --> 00:08:53,920
which is a polynomial ring where all

227
00:08:53,920 --> 00:08:55,760
coefficients are taken modulo

228
00:08:55,760 --> 00:08:59,360
a a relatively small number for instance

229
00:08:59,360 --> 00:09:01,040
in kyber this is

230
00:09:01,040 --> 00:09:04,160
3 329

231
00:09:04,160 --> 00:09:07,279
and so all elements are polynomials

232
00:09:07,279 --> 00:09:11,040
modulo a a a polynomial x to the m plus

233
00:09:11,040 --> 00:09:11,920
1 versus

234
00:09:11,920 --> 00:09:16,240
n is for instance 256.

235
00:09:16,240 --> 00:09:18,880
so again all elements are polynomials

236
00:09:18,880 --> 00:09:20,240
and what's interest

237
00:09:20,240 --> 00:09:23,200
what's important for this attack is that

238
00:09:23,200 --> 00:09:23,680
you can

239
00:09:23,680 --> 00:09:26,800
rewrite a polynomial multiplication

240
00:09:26,800 --> 00:09:30,080
c equals a times b as a

241
00:09:30,080 --> 00:09:33,360
matrix vector multiplication where these

242
00:09:33,360 --> 00:09:36,080
vectors c and b are just the coefficient

243
00:09:36,080 --> 00:09:37,040
vectors

244
00:09:37,040 --> 00:09:41,040
and you get this matrix a stay the if

245
00:09:41,040 --> 00:09:44,240
column of this matrix a by multiplying

246
00:09:44,240 --> 00:09:46,000
the polynomial

247
00:09:46,000 --> 00:09:49,200
a with x to the i and again take this

248
00:09:49,200 --> 00:09:50,480
multiple x to the m

249
00:09:50,480 --> 00:09:53,760
plus one uh so

250
00:09:53,760 --> 00:09:56,080
the key generation works as follows

251
00:09:56,080 --> 00:09:57,600
first you sample

252
00:09:57,600 --> 00:10:00,720
two secret polynomials s and e from

253
00:10:00,720 --> 00:10:04,000
an error distribution chi and

254
00:10:04,000 --> 00:10:07,120
the sky is some narrow distribution and

255
00:10:07,120 --> 00:10:08,560
for instance kyber

256
00:10:08,560 --> 00:10:11,839
uses a binomial distribution which is

257
00:10:11,839 --> 00:10:15,040
centered over uh zero and with a

258
00:10:15,040 --> 00:10:18,480
very narrow range so it goes from -2 to

259
00:10:18,480 --> 00:10:21,680
plus 2. then

260
00:10:21,680 --> 00:10:23,600
in the second step of key generation you

261
00:10:23,600 --> 00:10:26,399
sample a

262
00:10:26,480 --> 00:10:29,920
uniformly random polynomial a

263
00:10:29,920 --> 00:10:32,320
and then b which is is essentially the

264
00:10:32,320 --> 00:10:34,079
public key together with a

265
00:10:34,079 --> 00:10:37,360
is computed as a times s plus e

266
00:10:37,360 --> 00:10:40,480
so it's a noisy product

267
00:10:40,480 --> 00:10:42,720
now the public key i said is a and b and

268
00:10:42,720 --> 00:10:43,600
the secret key

269
00:10:43,600 --> 00:10:46,640
is s and you can discard this

270
00:10:46,640 --> 00:10:50,399
second uh polynomial e

271
00:10:50,399 --> 00:10:52,240
now encryption works as follows the

272
00:10:52,240 --> 00:10:53,519
first step you sample

273
00:10:53,519 --> 00:10:56,480
uh three uh polynomials again from this

274
00:10:56,480 --> 00:10:57,680
error distribution

275
00:10:57,680 --> 00:11:01,839
these polynomials are r re1 and e2

276
00:11:01,839 --> 00:11:05,040
then you compute this u and v

277
00:11:05,040 --> 00:11:08,880
as shown here and you then encode

278
00:11:08,880 --> 00:11:12,160
the message m onto v

279
00:11:12,160 --> 00:11:15,440
by encoding uh the message onto a

280
00:11:15,440 --> 00:11:16,399
polynomial

281
00:11:16,399 --> 00:11:18,959
and you do that by typically uh

282
00:11:18,959 --> 00:11:20,640
multiplying each

283
00:11:20,640 --> 00:11:23,680
of the 256 message bit with

284
00:11:23,680 --> 00:11:27,120
q over two so each polynomial

285
00:11:27,120 --> 00:11:29,519
so to each coefficient you either add 0

286
00:11:29,519 --> 00:11:30,399
or q

287
00:11:30,399 --> 00:11:34,560
over 2. and decryption then

288
00:11:34,560 --> 00:11:38,320
takes this ciphertext uv and computes

289
00:11:38,320 --> 00:11:41,360
m prime equals v minus u times

290
00:11:41,360 --> 00:11:44,320
s and feeds that into decoder and then

291
00:11:44,320 --> 00:11:45,920
we return

292
00:11:45,920 --> 00:11:50,240
the message so uh why does this actually

293
00:11:50,240 --> 00:11:52,560
work well if you do a back substitution

294
00:11:52,560 --> 00:11:53,920
so you take this m prime

295
00:11:53,920 --> 00:11:57,440
equals v minus u times s you get

296
00:11:57,440 --> 00:12:00,560
this this is equal to m times q

297
00:12:00,560 --> 00:12:03,040
over two so this is the encoded uh

298
00:12:03,040 --> 00:12:04,079
message

299
00:12:04,079 --> 00:12:06,800
plus some additional terms namely r

300
00:12:06,800 --> 00:12:07,680
times e

301
00:12:07,680 --> 00:12:11,120
minus e times s plus e and if you

302
00:12:11,120 --> 00:12:14,160
remember all these all these additional

303
00:12:14,160 --> 00:12:14,800
terms

304
00:12:14,800 --> 00:12:17,279
are sampled from this narrow error

305
00:12:17,279 --> 00:12:18,160
distribution

306
00:12:18,160 --> 00:12:21,839
which means that all of them are

307
00:12:22,839 --> 00:12:25,519
small which means that

308
00:12:25,519 --> 00:12:28,800
this m prime is approximately m times

309
00:12:28,800 --> 00:12:32,399
q half which means that we can use a

310
00:12:32,399 --> 00:12:36,720
decoder to recover the coefficient

311
00:12:36,720 --> 00:12:39,760
and as you see in the figure below

312
00:12:39,760 --> 00:12:43,600
where we plotted an example of a

313
00:12:43,600 --> 00:12:45,279
coefficient wise probability

314
00:12:45,279 --> 00:12:46,480
distribution of this

315
00:12:46,480 --> 00:12:49,680
m prime you have two peaks and the first

316
00:12:49,680 --> 00:12:50,480
peak is

317
00:12:50,480 --> 00:12:52,720
around zero which corresponds to the

318
00:12:52,720 --> 00:12:53,760
zero bits

319
00:12:53,760 --> 00:12:55,760
and the second peak which is drawn with

320
00:12:55,760 --> 00:12:57,120
this dashed line

321
00:12:57,120 --> 00:13:00,560
which is centered at q over two

322
00:13:00,560 --> 00:13:04,000
uh corresponds to the one bits

323
00:13:04,000 --> 00:13:06,639
and you can use then a decoder to tell

324
00:13:06,639 --> 00:13:08,800
if a bit was either zero

325
00:13:08,800 --> 00:13:11,279
if it's closer to zero or if it's if a

326
00:13:11,279 --> 00:13:12,480
bit was one if

327
00:13:12,480 --> 00:13:17,040
the coefficient is closer to q over two

328
00:13:17,760 --> 00:13:20,880
now again uh these uh

329
00:13:20,880 --> 00:13:23,519
this lpr scheme is only uh chosen

330
00:13:23,519 --> 00:13:25,839
plaintext secure and to make it

331
00:13:25,839 --> 00:13:27,920
into something cca secure which we

332
00:13:27,920 --> 00:13:29,040
typically need

333
00:13:29,040 --> 00:13:32,639
we use the fujisaki okamoto transform

334
00:13:32,639 --> 00:13:36,560
and might look something like this

335
00:13:36,560 --> 00:13:39,360
now this i said this is quite

336
00:13:39,360 --> 00:13:41,040
interesting from the perspective

337
00:13:41,040 --> 00:13:44,160
of fault attacks because you have this

338
00:13:44,160 --> 00:13:48,480
built-in countermeasure so we have to uh

339
00:13:48,480 --> 00:13:50,000
if we want to mount a counter measure we

340
00:13:50,000 --> 00:13:51,760
have to think about okay

341
00:13:51,760 --> 00:13:54,720
where can we now and actually inject the

342
00:13:54,720 --> 00:13:56,000
faults such that

343
00:13:56,000 --> 00:14:00,000
we learn something and the first thing

344
00:14:00,000 --> 00:14:00,639
where we

345
00:14:00,639 --> 00:14:03,279
might want to inject a fault is into

346
00:14:03,279 --> 00:14:04,000
this

347
00:14:04,000 --> 00:14:06,399
equality test if the outcome of the

348
00:14:06,399 --> 00:14:07,680
re-encryption

349
00:14:07,680 --> 00:14:11,199
uh is equal to the ciphertext that

350
00:14:11,199 --> 00:14:14,399
received that we received

351
00:14:14,399 --> 00:14:17,199
so this uh four so we fold this equality

352
00:14:17,199 --> 00:14:18,480
test such that it out

353
00:14:18,480 --> 00:14:21,040
always outputs one so it tells okay they

354
00:14:21,040 --> 00:14:22,480
are equivalent

355
00:14:22,480 --> 00:14:24,959
even if they are not and which means

356
00:14:24,959 --> 00:14:26,720
that we would always get

357
00:14:26,720 --> 00:14:29,040
uh the shared secret the output of this

358
00:14:29,040 --> 00:14:30,480
key derivation function

359
00:14:30,480 --> 00:14:33,760
so the shiatsu k now this

360
00:14:33,760 --> 00:14:36,240
attack is already known it was already

361
00:14:36,240 --> 00:14:38,160
described by a couple of

362
00:14:38,160 --> 00:14:41,920
uh previous works um

363
00:14:41,920 --> 00:14:45,040
but it's also an

364
00:14:45,040 --> 00:14:47,839
fairly easy to protect against i'm not

365
00:14:47,839 --> 00:14:50,000
saying trivial it's never trivial

366
00:14:50,000 --> 00:14:53,440
but easy and that uh this equality test

367
00:14:53,440 --> 00:14:54,160
and this

368
00:14:54,160 --> 00:14:57,360
multiplexer at the end is a very

369
00:14:57,360 --> 00:15:00,320
uh small part of the overall

370
00:15:00,320 --> 00:15:02,959
decapsulation in terms of runtime

371
00:15:02,959 --> 00:15:04,560
and we already know that we have to

372
00:15:04,560 --> 00:15:06,880
protect it and there are ways to protect

373
00:15:06,880 --> 00:15:08,079
it and

374
00:15:08,079 --> 00:15:10,000
since there are such as only a small

375
00:15:10,000 --> 00:15:12,320
part we can

376
00:15:12,320 --> 00:15:14,320
throw a couple of counter measures at it

377
00:15:14,320 --> 00:15:16,000
and it doesn't matter if they are a

378
00:15:16,000 --> 00:15:16,720
little more

379
00:15:16,720 --> 00:15:20,240
expensive okay

380
00:15:20,240 --> 00:15:24,320
now what if we fold these three

381
00:15:24,320 --> 00:15:26,320
blocks in the middle so the hash

382
00:15:26,320 --> 00:15:28,079
function which derives

383
00:15:28,079 --> 00:15:30,560
this uh the randomness r and this

384
00:15:30,560 --> 00:15:33,440
pre-secret pk

385
00:15:33,440 --> 00:15:35,440
and the re-encryption key derivation

386
00:15:35,440 --> 00:15:36,639
function

387
00:15:36,639 --> 00:15:39,519
well these blocks are essentially what

388
00:15:39,519 --> 00:15:40,639
make up

389
00:15:40,639 --> 00:15:42,720
the encapsulation because in

390
00:15:42,720 --> 00:15:43,839
encapsulation

391
00:15:43,839 --> 00:15:47,279
we choose a random message and we run

392
00:15:47,279 --> 00:15:50,720
these three blocks which means that

393
00:15:50,720 --> 00:15:54,560
if the attacker was the one who

394
00:15:54,560 --> 00:15:56,399
who computed the ciphertext who ran

395
00:15:56,399 --> 00:15:58,240
encapsulation using the public

396
00:15:58,240 --> 00:16:00,480
key got the ciphertext and then sent it

397
00:16:00,480 --> 00:16:01,839
to the device

398
00:16:01,839 --> 00:16:04,079
then these three parts in the middle

399
00:16:04,079 --> 00:16:05,360
actually only

400
00:16:05,360 --> 00:16:08,720
process known data so they

401
00:16:08,720 --> 00:16:12,000
recompute this r and k and so so

402
00:16:12,000 --> 00:16:15,199
there is not a lot to

403
00:16:15,199 --> 00:16:18,399
to learn when we unchecked a fault here

404
00:16:18,399 --> 00:16:21,040
because we already know the values that

405
00:16:21,040 --> 00:16:22,000
are processed

406
00:16:22,000 --> 00:16:26,160
and yeah we don't learn anything here

407
00:16:26,160 --> 00:16:28,480
which leaves us with the decryption

408
00:16:28,480 --> 00:16:30,240
which is

409
00:16:30,240 --> 00:16:33,519
also kind of the most

410
00:16:33,600 --> 00:16:35,360
straightforward or the first thing you

411
00:16:35,360 --> 00:16:37,120
think about on attacking

412
00:16:37,120 --> 00:16:39,360
with a fault since decryption is also

413
00:16:39,360 --> 00:16:41,199
the one component

414
00:16:41,199 --> 00:16:44,560
that uses the secret key

415
00:16:44,560 --> 00:16:47,440
now when we do a fault attack we

416
00:16:47,440 --> 00:16:48,959
typically think of it and

417
00:16:48,959 --> 00:16:51,759
this way that we inject a fault into a

418
00:16:51,759 --> 00:16:53,279
component

419
00:16:53,279 --> 00:16:56,639
the output of this component changes in

420
00:16:56,639 --> 00:16:57,519
some manner

421
00:16:57,519 --> 00:17:00,880
and we use this changed out outcome to

422
00:17:00,880 --> 00:17:03,759
compute backwards to derive some

423
00:17:03,759 --> 00:17:04,559
information

424
00:17:04,559 --> 00:17:08,160
on the secret key now here with this fo

425
00:17:08,160 --> 00:17:09,919
transformation there is a problem

426
00:17:09,919 --> 00:17:13,599
if this message that we recover this m

427
00:17:13,599 --> 00:17:16,640
changes in any sort of way then

428
00:17:16,640 --> 00:17:19,199
the re-encryption step will of course

429
00:17:19,199 --> 00:17:19,839
output

430
00:17:19,839 --> 00:17:23,039
a completely different cipher text

431
00:17:23,039 --> 00:17:25,439
there's nothing to do so this ciphertext

432
00:17:25,439 --> 00:17:26,160
will of course

433
00:17:26,160 --> 00:17:28,960
not match the received ciphertext which

434
00:17:28,960 --> 00:17:29,600
means

435
00:17:29,600 --> 00:17:32,880
that we will always get a random

436
00:17:32,880 --> 00:17:35,440
shared secret k and a random shared

437
00:17:35,440 --> 00:17:36,559
secret doesn't

438
00:17:36,559 --> 00:17:39,360
convey any information on the secret key

439
00:17:39,360 --> 00:17:41,360
of course

440
00:17:41,360 --> 00:17:44,400
so we have to find another way

441
00:17:44,400 --> 00:17:47,520
and actually if we look at this well we

442
00:17:47,520 --> 00:17:48,080
can

443
00:17:48,080 --> 00:17:50,320
inject a fault into this decryption

444
00:17:50,320 --> 00:17:51,600
function

445
00:17:51,600 --> 00:17:54,400
but we can only deduce one bit of

446
00:17:54,400 --> 00:17:55,679
information

447
00:17:55,679 --> 00:17:58,880
then on the fault namely

448
00:17:58,880 --> 00:18:03,280
is this k that we receive at the end

449
00:18:03,280 --> 00:18:05,919
actually the correct one so the same one

450
00:18:05,919 --> 00:18:07,200
that the attacker

451
00:18:07,200 --> 00:18:10,000
got during encapsulation or is it

452
00:18:10,000 --> 00:18:10,960
something random

453
00:18:10,960 --> 00:18:13,520
so did this k change or not this is the

454
00:18:13,520 --> 00:18:15,280
only bit of information

455
00:18:15,280 --> 00:18:18,799
that we can extract

456
00:18:18,799 --> 00:18:21,679
so this is what we try to do in our

457
00:18:21,679 --> 00:18:22,240
attack

458
00:18:22,240 --> 00:18:25,600
we inject a fault in the decryption

459
00:18:25,600 --> 00:18:28,640
and then test if either the correct k

460
00:18:28,640 --> 00:18:31,760
is still returned or a random k

461
00:18:31,760 --> 00:18:34,480
is returned and i said the we assume

462
00:18:34,480 --> 00:18:35,679
that the attacker

463
00:18:35,679 --> 00:18:38,880
is the one that ran the encapsulation

464
00:18:38,880 --> 00:18:42,720
meaning that he knows the shared secret

465
00:18:42,720 --> 00:18:46,240
k which means he can test whether or not

466
00:18:46,240 --> 00:18:49,520
the correct k is returned

467
00:18:49,520 --> 00:18:52,240
and the outcome which mean the outcome

468
00:18:52,240 --> 00:18:53,440
meaning uh the bit

469
00:18:53,440 --> 00:18:56,000
if it's correct or not are carries

470
00:18:56,000 --> 00:18:58,160
information on the key

471
00:18:58,160 --> 00:19:00,799
i have to quickly introduce some

472
00:19:00,799 --> 00:19:02,320
terminology here

473
00:19:02,320 --> 00:19:05,600
we call a fault an effective fault

474
00:19:05,600 --> 00:19:09,039
if a random k is returned

475
00:19:09,039 --> 00:19:12,240
effective means in that default did

476
00:19:12,240 --> 00:19:15,520
do something it changed something and it

477
00:19:15,520 --> 00:19:18,480
we called we call uh the other case

478
00:19:18,480 --> 00:19:20,000
namely that the correct k

479
00:19:20,000 --> 00:19:23,039
is returned and in effect default

480
00:19:23,039 --> 00:19:26,559
the so the fault didn't do anything

481
00:19:26,559 --> 00:19:29,840
so uh here i have to give a brief

482
00:19:29,840 --> 00:19:31,679
example and also clear up something

483
00:19:31,679 --> 00:19:35,200
so an ineffective fault does not mean

484
00:19:35,200 --> 00:19:38,960
that the fault injection as such

485
00:19:38,960 --> 00:19:41,120
didn't work so we inject the fault and

486
00:19:41,120 --> 00:19:42,640
it always default

487
00:19:42,640 --> 00:19:45,919
always does what we intended to do

488
00:19:45,919 --> 00:19:49,200
but in some case this fault doesn't have

489
00:19:49,200 --> 00:19:51,280
an effect on the outcome so despite this

490
00:19:51,280 --> 00:19:52,799
fault the correct outcome

491
00:19:52,799 --> 00:19:55,840
is still returned this

492
00:19:55,840 --> 00:19:58,240
might be a little counter-intuitive so a

493
00:19:58,240 --> 00:20:00,000
quick example

494
00:20:00,000 --> 00:20:03,200
so for instance consider the uh the test

495
00:20:03,200 --> 00:20:06,960
is x x smaller than 10 so this is a

496
00:20:06,960 --> 00:20:07,919
boolean test

497
00:20:07,919 --> 00:20:10,880
also a test and it it returns one bit

498
00:20:10,880 --> 00:20:12,640
true or false

499
00:20:12,640 --> 00:20:15,679
and how a a any computer would

500
00:20:15,679 --> 00:20:18,080
typically check for this is that it

501
00:20:18,080 --> 00:20:19,120
takes this x

502
00:20:19,120 --> 00:20:21,919
subtracts 10 and tests for the same bit

503
00:20:21,919 --> 00:20:24,159
of the difference

504
00:20:24,159 --> 00:20:27,760
now think of that a a faulted egg which

505
00:20:27,760 --> 00:20:31,280
skips the subtraction step it's

506
00:20:31,280 --> 00:20:34,559
just an instruction skip so this would

507
00:20:34,559 --> 00:20:37,039
mean that the device instead of

508
00:20:37,039 --> 00:20:40,640
is x smaller than 10 actually tests if

509
00:20:40,640 --> 00:20:43,760
if x itself is if x is

510
00:20:43,760 --> 00:20:46,960
smaller than zero now in many

511
00:20:46,960 --> 00:20:50,080
cases uh this uh the outcome of this

512
00:20:50,080 --> 00:20:52,400
computation is actually the same

513
00:20:52,400 --> 00:20:55,760
as x smaller than 10.

514
00:20:55,760 --> 00:20:58,400
so which means if you put in the numbers

515
00:20:58,400 --> 00:20:59,120
the

516
00:20:59,120 --> 00:21:02,159
the outcome only differs if x

517
00:21:02,159 --> 00:21:05,760
is between 0 and 9 so only if it's

518
00:21:05,760 --> 00:21:07,840
between these values then the fault is

519
00:21:07,840 --> 00:21:09,440
effective meaning that

520
00:21:09,440 --> 00:21:12,320
if we observe that a fault was effective

521
00:21:12,320 --> 00:21:14,080
at the output the output

522
00:21:14,080 --> 00:21:17,280
of a larger operation somehow changes

523
00:21:17,280 --> 00:21:21,039
then we know that this x was between

524
00:21:21,039 --> 00:21:23,440
0 and 9 so we have learned something

525
00:21:23,440 --> 00:21:26,320
about the value

526
00:21:26,559 --> 00:21:28,640
now is the question where can we

527
00:21:28,640 --> 00:21:30,080
actually inject

528
00:21:30,080 --> 00:21:34,799
such a fault into a into decapsulation

529
00:21:34,799 --> 00:21:37,919
such that we can learn

530
00:21:37,919 --> 00:21:41,440
something about the key and we've

531
00:21:41,440 --> 00:21:43,120
actually found a place namely that

532
00:21:43,120 --> 00:21:45,600
decoder which is the component which

533
00:21:45,600 --> 00:21:48,720
recovers the original message m from

534
00:21:48,720 --> 00:21:52,320
the noisy version m prime

535
00:21:52,320 --> 00:21:54,159
so this decoder is called for each

536
00:21:54,159 --> 00:21:56,000
coefficient it takes as

537
00:21:56,000 --> 00:22:00,480
input some number between zero and q

538
00:22:00,480 --> 00:22:03,840
and outputs a single bit zero or one

539
00:22:03,840 --> 00:22:07,039
so even if we were to inject a random

540
00:22:07,039 --> 00:22:08,080
fault to

541
00:22:08,080 --> 00:22:12,080
anything in this decoder then uh

542
00:22:12,080 --> 00:22:14,159
the outcome would be correct with a

543
00:22:14,159 --> 00:22:16,559
probability of around 50 percent but of

544
00:22:16,559 --> 00:22:17,280
course

545
00:22:17,280 --> 00:22:20,159
uh we want we need to be a little more

546
00:22:20,159 --> 00:22:21,760
clever than that

547
00:22:21,760 --> 00:22:24,320
other so we can't just throw something

548
00:22:24,320 --> 00:22:27,280
random in there

549
00:22:27,280 --> 00:22:30,640
now we use an assumption here again that

550
00:22:30,640 --> 00:22:32,799
the attacker runs the encapsulation so

551
00:22:32,799 --> 00:22:35,039
he knows all the internal

552
00:22:35,039 --> 00:22:37,679
internal intermediate values that occur

553
00:22:37,679 --> 00:22:39,280
during encapsulation

554
00:22:39,280 --> 00:22:42,559
and also doing the re-encryption and

555
00:22:42,559 --> 00:22:45,840
he then sends the cipher text to this uh

556
00:22:45,840 --> 00:22:49,840
to the device and he gets so and

557
00:22:49,840 --> 00:22:52,400
as you remember this m prime is an a

558
00:22:52,400 --> 00:22:53,679
noisy version of

559
00:22:53,679 --> 00:22:57,280
this m now if we have a closer look

560
00:22:57,280 --> 00:23:00,640
at this m prime then of course the first

561
00:23:00,640 --> 00:23:01,679
component

562
00:23:01,679 --> 00:23:04,880
is this m times q over two and

563
00:23:04,880 --> 00:23:08,559
that the attacker knows

564
00:23:08,559 --> 00:23:10,880
and for this other term which we call

565
00:23:10,880 --> 00:23:13,280
the the noise or error term

566
00:23:13,280 --> 00:23:17,360
this r e minus e 1 s plus e 2

567
00:23:17,360 --> 00:23:20,799
then the terms then the polynomial

568
00:23:20,799 --> 00:23:24,240
r e 1 and e 2 are the ones that

569
00:23:24,240 --> 00:23:27,360
are sampled at the beginning of the

570
00:23:27,360 --> 00:23:30,559
encapsulation of the encryption

571
00:23:30,559 --> 00:23:32,960
that's also of the encapsulation which

572
00:23:32,960 --> 00:23:34,799
means that the attacker

573
00:23:34,799 --> 00:23:38,159
knows them and this e and s

574
00:23:38,159 --> 00:23:41,200
are actually the secret key

575
00:23:41,200 --> 00:23:43,600
so this s is actually a secret key and

576
00:23:43,600 --> 00:23:45,520
this e is this other polynomial that was

577
00:23:45,520 --> 00:23:47,840
used during key generation but it's

578
00:23:47,840 --> 00:23:50,640
also uh so it's this e is not stored as

579
00:23:50,640 --> 00:23:52,400
part of the secret key but it also needs

580
00:23:52,400 --> 00:23:52,880
to be

581
00:23:52,880 --> 00:23:56,880
kept secret now what you have here

582
00:23:56,880 --> 00:24:00,000
is actually that this m prime is

583
00:24:00,000 --> 00:24:03,600
linear in the key you multiply something

584
00:24:03,600 --> 00:24:04,080
known

585
00:24:04,080 --> 00:24:07,200
r with something unknown and

586
00:24:07,200 --> 00:24:10,400
multiply this e1 this known e1

587
00:24:10,400 --> 00:24:13,200
with uh something unknown which means

588
00:24:13,200 --> 00:24:13,600
that

589
00:24:13,600 --> 00:24:16,960
if you know something about this m prime

590
00:24:16,960 --> 00:24:19,520
other than where what the original

591
00:24:19,520 --> 00:24:20,159
message

592
00:24:20,159 --> 00:24:23,120
was so if you know something on what's

593
00:24:23,120 --> 00:24:24,000
on the concrete

594
00:24:24,000 --> 00:24:26,799
value of this m prime then you learn

595
00:24:26,799 --> 00:24:27,520
something

596
00:24:27,520 --> 00:24:32,240
which is linear in the key coefficients

597
00:24:32,240 --> 00:24:35,200
now to actually exploit it we have to

598
00:24:35,200 --> 00:24:35,919
have a

599
00:24:35,919 --> 00:24:39,840
closer look at how decoding is actually

600
00:24:39,840 --> 00:24:40,400
done

601
00:24:40,400 --> 00:24:43,440
and for that i give here the actual

602
00:24:43,440 --> 00:24:44,799
decoding function

603
00:24:44,799 --> 00:24:48,640
as it is used in kyber you can of course

604
00:24:48,640 --> 00:24:50,799
write the decoder in any other way but

605
00:24:50,799 --> 00:24:52,400
this is a nice way

606
00:24:52,400 --> 00:24:54,960
which is a constant time which is of

607
00:24:54,960 --> 00:24:57,279
course important for

608
00:24:57,279 --> 00:25:01,279
security now the first step in this

609
00:25:01,279 --> 00:25:03,760
decoding routine it takes the input a

610
00:25:03,760 --> 00:25:06,880
and shifts it to the left by one uh

611
00:25:06,880 --> 00:25:08,799
shifting by left to the one is nothing

612
00:25:08,799 --> 00:25:11,840
else than a multiplication with two

613
00:25:11,840 --> 00:25:15,520
so on the left figure we have the

614
00:25:15,520 --> 00:25:17,679
the coefficient wise probability

615
00:25:17,679 --> 00:25:18,960
distribution of this

616
00:25:18,960 --> 00:25:22,240
m prime and what shifting so

617
00:25:22,240 --> 00:25:24,799
here in the range between 0 and q and

618
00:25:24,799 --> 00:25:25,919
again the

619
00:25:25,919 --> 00:25:28,000
the solid line corresponds to a message

620
00:25:28,000 --> 00:25:30,080
bit zero and the dashed line

621
00:25:30,080 --> 00:25:32,159
to a message bit one and what

622
00:25:32,159 --> 00:25:33,840
multiplication by two does

623
00:25:33,840 --> 00:25:37,039
it well it just scales the

624
00:25:37,039 --> 00:25:40,799
the x axis so it instead of from zero to

625
00:25:40,799 --> 00:25:41,120
q

626
00:25:41,120 --> 00:25:45,039
goes from 0 to 2q

627
00:25:45,360 --> 00:25:47,919
then in the next step the decoder adds

628
00:25:47,919 --> 00:25:48,799
the constant

629
00:25:48,799 --> 00:25:51,840
q over 2 which again

630
00:25:51,840 --> 00:25:54,640
just shifts the distributions to the

631
00:25:54,640 --> 00:25:55,279
right

632
00:25:55,279 --> 00:25:58,000
so instead of beginning at zero it

633
00:25:58,000 --> 00:25:59,120
begins at q

634
00:25:59,120 --> 00:26:01,279
over two everything is shifted to the

635
00:26:01,279 --> 00:26:02,320
right

636
00:26:02,320 --> 00:26:05,760
then the third step in this

637
00:26:05,760 --> 00:26:09,039
decoder is a division by uh

638
00:26:09,039 --> 00:26:13,039
q so what this does is the following

639
00:26:13,039 --> 00:26:16,799
so between 0 and q so this is an integer

640
00:26:16,799 --> 00:26:18,400
division so it always rounds down

641
00:26:18,400 --> 00:26:21,520
so between 0 and q we have 0 between q

642
00:26:21,520 --> 00:26:25,279
and 2q we have a 1 and between 2q

643
00:26:25,279 --> 00:26:29,120
and 5q half we have a 2.

644
00:26:29,120 --> 00:26:32,480
and then this end with 1

645
00:26:32,480 --> 00:26:35,440
selects the least significant bit which

646
00:26:35,440 --> 00:26:36,640
means that

647
00:26:36,640 --> 00:26:39,440
for a two the the least significant bit

648
00:26:39,440 --> 00:26:40,159
of two

649
00:26:40,159 --> 00:26:43,760
is a zero and here you have it that

650
00:26:43,760 --> 00:26:46,799
the the solid parts always map to a zero

651
00:26:46,799 --> 00:26:49,440
and the dash parts are always mapped to

652
00:26:49,440 --> 00:26:50,000
a one so

653
00:26:50,000 --> 00:26:53,360
the decoder works correctly

654
00:26:53,360 --> 00:26:55,520
okay where can we actually inject the

655
00:26:55,520 --> 00:26:57,200
fault well we found that

656
00:26:57,200 --> 00:27:00,720
if you skip this second step this multi

657
00:27:00,720 --> 00:27:01,840
ah this addition

658
00:27:01,840 --> 00:27:03,760
of q over two then you have the

659
00:27:03,760 --> 00:27:05,760
following situation

660
00:27:05,760 --> 00:27:09,279
that that

661
00:27:09,279 --> 00:27:12,640
depending on the actual value of

662
00:27:12,640 --> 00:27:15,919
m prime the outcome is either

663
00:27:15,919 --> 00:27:18,000
correct or incorrect so if we have a

664
00:27:18,000 --> 00:27:18,960
look at the

665
00:27:18,960 --> 00:27:22,000
solid lines for a zero then

666
00:27:22,000 --> 00:27:24,080
the right part of this gaussian

667
00:27:24,080 --> 00:27:25,120
distribution

668
00:27:25,120 --> 00:27:28,159
is actually again right i mean here the

669
00:27:28,159 --> 00:27:32,480
between uh zero and q4

670
00:27:32,480 --> 00:27:34,640
so we deposit on the positive side of

671
00:27:34,640 --> 00:27:36,399
the gaussian distribution

672
00:27:36,399 --> 00:27:38,640
uh then this part is still correctly

673
00:27:38,640 --> 00:27:40,240
decoded to a zero

674
00:27:40,240 --> 00:27:44,320
whereas the red part of the zero bit

675
00:27:44,320 --> 00:27:47,600
is uh incorrectly decoded to a one bit

676
00:27:47,600 --> 00:27:50,080
and we have the same picture for a one

677
00:27:50,080 --> 00:27:50,640
bit

678
00:27:50,640 --> 00:27:53,120
so the right part of this kind of

679
00:27:53,120 --> 00:27:54,960
gaussian distribution is correctly

680
00:27:54,960 --> 00:27:56,320
decoded to one bit

681
00:27:56,320 --> 00:27:59,039
and the left part is incorrectly decoded

682
00:27:59,039 --> 00:27:59,440
to

683
00:27:59,440 --> 00:28:03,520
a zero bit so which means that

684
00:28:03,520 --> 00:28:07,039
we actually from observing

685
00:28:07,039 --> 00:28:10,399
if the decoder still recovers the

686
00:28:10,399 --> 00:28:13,200
correct message or an incorrect message

687
00:28:13,200 --> 00:28:16,960
we know we can learn something about

688
00:28:16,960 --> 00:28:21,279
uh this m prime and since for a

689
00:28:21,279 --> 00:28:23,440
and since it's the exact same picture

690
00:28:23,440 --> 00:28:25,520
for a zero bit and a one bit the

691
00:28:25,520 --> 00:28:28,080
right half is always correctly decoded

692
00:28:28,080 --> 00:28:30,640
and the left half is not correctly

693
00:28:30,640 --> 00:28:33,600
decoded we can write down an inequality

694
00:28:33,600 --> 00:28:34,720
namely that

695
00:28:34,720 --> 00:28:38,080
this error term are e minus e times e1

696
00:28:38,080 --> 00:28:38,720
times s

697
00:28:38,720 --> 00:28:41,520
plus e2 the if coefficient which is the

698
00:28:41,520 --> 00:28:42,640
coefficient

699
00:28:42,640 --> 00:28:46,000
we fault uh is either

700
00:28:46,000 --> 00:28:48,559
larger than one if we observed that the

701
00:28:48,559 --> 00:28:50,000
fault was ineffective

702
00:28:50,000 --> 00:28:53,039
meaning that the correct secret was are

703
00:28:53,039 --> 00:28:54,480
the correct shared secret was

704
00:28:54,480 --> 00:28:56,880
still returned in that encapsulation or

705
00:28:56,880 --> 00:28:58,080
it is smaller than

706
00:28:58,080 --> 00:29:03,039
one if the fault is effective

707
00:29:03,279 --> 00:29:06,880
so this is nice because uh

708
00:29:06,880 --> 00:29:10,000
we have this now this inequality and as

709
00:29:10,000 --> 00:29:10,559
i've said

710
00:29:10,559 --> 00:29:12,960
quite at the beginning this matrix we

711
00:29:12,960 --> 00:29:15,520
can use this matrix vector annotation

712
00:29:15,520 --> 00:29:18,799
to extract one

713
00:29:18,799 --> 00:29:22,000
line of this system so we can

714
00:29:22,000 --> 00:29:24,840
extract the computation of the if

715
00:29:24,840 --> 00:29:26,159
coefficient

716
00:29:26,159 --> 00:29:31,520
of this polynomial computation

717
00:29:31,679 --> 00:29:33,840
and what's also nice is that this error

718
00:29:33,840 --> 00:29:35,279
term is of course

719
00:29:35,279 --> 00:29:39,200
always small it has to be always

720
00:29:39,200 --> 00:29:43,840
smaller than q over 4 because otherwise

721
00:29:43,840 --> 00:29:46,159
there would be decryption errors which

722
00:29:46,159 --> 00:29:47,120
we of course

723
00:29:47,120 --> 00:29:49,360
don't want and since this is always

724
00:29:49,360 --> 00:29:50,799
small we can just

725
00:29:50,799 --> 00:29:53,919
drop the modulus here and say this is an

726
00:29:53,919 --> 00:29:54,799
inequality

727
00:29:54,799 --> 00:29:57,679
over set so over the integers

728
00:29:57,679 --> 00:29:58,880
inequalities

729
00:29:58,880 --> 00:30:02,080
over in a modular field modular field

730
00:30:02,080 --> 00:30:04,720
don't make much sense anyway so what we

731
00:30:04,720 --> 00:30:05,600
have here

732
00:30:05,600 --> 00:30:08,960
is a linear inequality with

733
00:30:08,960 --> 00:30:12,000
two n unknowns so remember that n

734
00:30:12,000 --> 00:30:15,039
is the is the the degree of the

735
00:30:15,039 --> 00:30:16,880
reduction polynomial and also the

736
00:30:16,880 --> 00:30:20,240
number of coefficients and we have two n

737
00:30:20,240 --> 00:30:23,440
unknowns which are the coefficients

738
00:30:23,440 --> 00:30:27,760
of e and s and this inequality is over

739
00:30:27,760 --> 00:30:31,360
the integers now of course

740
00:30:31,360 --> 00:30:33,919
one such inequality doesn't it does

741
00:30:33,919 --> 00:30:35,600
carry information about

742
00:30:35,600 --> 00:30:38,960
the secret key but of course not a lot

743
00:30:38,960 --> 00:30:40,000
so we have to

744
00:30:40,000 --> 00:30:42,320
repeat this step so we uh the attacker

745
00:30:42,320 --> 00:30:43,279
generates

746
00:30:43,279 --> 00:30:46,320
many ciphertexts sent then sends them

747
00:30:46,320 --> 00:30:50,000
to the device he faults uh

748
00:30:50,000 --> 00:30:52,960
one coefficient per encapsulation call

749
00:30:52,960 --> 00:30:53,760
and then

750
00:30:53,760 --> 00:30:56,399
which means per fault he gets one

751
00:30:56,399 --> 00:30:57,600
inequality

752
00:30:57,600 --> 00:31:01,120
and he gathers these inequalities

753
00:31:01,120 --> 00:31:04,559
in a larger system and

754
00:31:04,559 --> 00:31:07,679
this system looks like this so for

755
00:31:07,679 --> 00:31:11,120
each fault we have an an r and an e1

756
00:31:11,120 --> 00:31:14,080
that we bunch up together in this matrix

757
00:31:14,080 --> 00:31:15,600
we multiply it with e

758
00:31:15,600 --> 00:31:19,279
and s and then depending on the outcome

759
00:31:19,279 --> 00:31:20,640
of the fault

760
00:31:20,640 --> 00:31:23,200
so the outcome of the fault uh uh

761
00:31:23,200 --> 00:31:25,360
determines the signedness

762
00:31:25,360 --> 00:31:28,640
of the inequality so either greater than

763
00:31:28,640 --> 00:31:29,679
or less than

764
00:31:29,679 --> 00:31:33,840
and on the right half we have this e2

765
00:31:34,159 --> 00:31:36,960
so we just picked this e2 from here and

766
00:31:36,960 --> 00:31:38,399
put it onto the

767
00:31:38,399 --> 00:31:41,600
right side and now we have

768
00:31:41,600 --> 00:31:44,960
a large set of inequalities

769
00:31:44,960 --> 00:31:47,360
and we need to find the key how can we

770
00:31:47,360 --> 00:31:48,880
do that well our first

771
00:31:48,880 --> 00:31:52,240
for thought was that we do it in some

772
00:31:52,240 --> 00:31:57,039
analytical manner so that we

773
00:31:57,279 --> 00:31:59,519
think of these inequalities as some sort

774
00:31:59,519 --> 00:32:01,440
of constraints and then we

775
00:32:01,440 --> 00:32:04,320
we threw a solver at this system of

776
00:32:04,320 --> 00:32:06,320
constraints

777
00:32:06,320 --> 00:32:11,439
this didn't work out all that well and

778
00:32:11,760 --> 00:32:16,000
might also be not that great because

779
00:32:16,000 --> 00:32:19,279
fault attacks can maybe not work so

780
00:32:19,279 --> 00:32:20,799
default injection as such

781
00:32:20,799 --> 00:32:25,279
which means that some

782
00:32:25,360 --> 00:32:27,679
some signs in there might actually be

783
00:32:27,679 --> 00:32:28,480
incorrect

784
00:32:28,480 --> 00:32:30,640
and if we do an analytically exact

785
00:32:30,640 --> 00:32:32,240
approach one

786
00:32:32,240 --> 00:32:34,720
even one incorrect inequality might

787
00:32:34,720 --> 00:32:35,600
throw off

788
00:32:35,600 --> 00:32:38,640
the entire solver and thus

789
00:32:38,640 --> 00:32:41,679
the system might be unsolvable

790
00:32:41,679 --> 00:32:44,159
so what we did instead is we use the

791
00:32:44,159 --> 00:32:45,679
following observation

792
00:32:45,679 --> 00:32:48,960
if we replace these larger than

793
00:32:48,960 --> 00:32:51,360
and and smaller than sines with an

794
00:32:51,360 --> 00:32:53,120
approximate

795
00:32:53,120 --> 00:32:56,960
sign then this looks kind of like

796
00:32:56,960 --> 00:33:00,080
a linear decoding problem so a

797
00:33:00,080 --> 00:33:03,279
ax equals b and we have to find the x

798
00:33:03,279 --> 00:33:03,840
that

799
00:33:03,840 --> 00:33:07,279
matches the closest

800
00:33:07,760 --> 00:33:09,840
so since this is kind of similar to a

801
00:33:09,840 --> 00:33:11,360
linear decoding problem we use an

802
00:33:11,360 --> 00:33:12,960
algorithm that is

803
00:33:12,960 --> 00:33:15,679
often used in linear decoding and that

804
00:33:15,679 --> 00:33:17,200
is that of

805
00:33:17,200 --> 00:33:20,480
belief propagation so to explain that

806
00:33:20,480 --> 00:33:21,840
process

807
00:33:21,840 --> 00:33:25,679
i extract here one

808
00:33:25,679 --> 00:33:28,640
line of the system so this x 1 to x 2 to

809
00:33:28,640 --> 00:33:29,120
the n

810
00:33:29,120 --> 00:33:31,519
is for instance the first line here on

811
00:33:31,519 --> 00:33:32,480
the left this

812
00:33:32,480 --> 00:33:35,440
so it contains n components and

813
00:33:35,440 --> 00:33:37,200
coefficients of r 1

814
00:33:37,200 --> 00:33:40,640
and n coefficients of e11

815
00:33:40,640 --> 00:33:45,360
and now this y1 to y2n is

816
00:33:45,360 --> 00:33:47,279
composed of the coefficients of the

817
00:33:47,279 --> 00:33:48,720
unknown coefficients of

818
00:33:48,720 --> 00:33:52,080
e and s and in this example

819
00:33:52,080 --> 00:33:55,120
we say that this scalar product this one

820
00:33:55,120 --> 00:33:55,600
line

821
00:33:55,600 --> 00:33:58,240
in the system of inequalities has to be

822
00:33:58,240 --> 00:33:59,120
larger than

823
00:33:59,120 --> 00:34:02,240
zero so what we do here

824
00:34:02,240 --> 00:34:05,679
is uh we actually store the probability

825
00:34:05,679 --> 00:34:08,960
distribution for each coefficient and we

826
00:34:08,960 --> 00:34:11,760
initialized the probability distribution

827
00:34:11,760 --> 00:34:14,719
with uh the distribution of this error

828
00:34:14,719 --> 00:34:16,000
distribution so this

829
00:34:16,000 --> 00:34:18,399
chi which is a centered binomial

830
00:34:18,399 --> 00:34:19,679
distribution over

831
00:34:19,679 --> 00:34:23,040
a very narrow range

832
00:34:23,040 --> 00:34:26,159
and now we do the following for each

833
00:34:26,159 --> 00:34:29,359
index i so between 1 and 2n and

834
00:34:29,359 --> 00:34:32,079
each inequality that we gathered we

835
00:34:32,079 --> 00:34:32,639
compute

836
00:34:32,639 --> 00:34:35,599
this marginal distribution so the the

837
00:34:35,599 --> 00:34:37,199
probability distribution

838
00:34:37,199 --> 00:34:40,639
that this scalar product uh

839
00:34:40,639 --> 00:34:43,679
is larger than zero in this example

840
00:34:43,679 --> 00:34:47,359
uh conditioned that uh on the assumption

841
00:34:47,359 --> 00:34:50,000
that the if coefficient of y

842
00:34:50,000 --> 00:34:52,879
takes in a certain value and how we do

843
00:34:52,879 --> 00:34:54,239
that is the following

844
00:34:54,239 --> 00:34:56,879
we compute the probability distribution

845
00:34:56,879 --> 00:34:57,359
of this

846
00:34:57,359 --> 00:35:00,960
scalar product x but we leave out

847
00:35:00,960 --> 00:35:04,960
the if coefficient and then we might get

848
00:35:04,960 --> 00:35:06,320
a distribution that

849
00:35:06,320 --> 00:35:08,960
is kind of like this so again it's kind

850
00:35:08,960 --> 00:35:11,599
of like a gaussian distribution but it's

851
00:35:11,599 --> 00:35:16,320
it's not centered at zero anymore now we

852
00:35:16,320 --> 00:35:17,119
enumerate

853
00:35:17,119 --> 00:35:21,040
all possible values all realizations of

854
00:35:21,040 --> 00:35:24,880
y i so if if it's a centered binomial

855
00:35:24,880 --> 00:35:26,480
distribution these are all values

856
00:35:26,480 --> 00:35:28,720
between minus two and plus two so just

857
00:35:28,720 --> 00:35:31,760
five values for each of these values we

858
00:35:31,760 --> 00:35:32,400
predict

859
00:35:32,400 --> 00:35:36,160
the product of x i y i

860
00:35:36,160 --> 00:35:38,880
and then uh compute the probability

861
00:35:38,880 --> 00:35:39,760
distribution

862
00:35:39,760 --> 00:35:42,480
of the entire scalar product so

863
00:35:42,480 --> 00:35:44,480
essentially we just shift

864
00:35:44,480 --> 00:35:47,760
the curve accordingly to the predicted

865
00:35:47,760 --> 00:35:49,280
product x a y i

866
00:35:49,280 --> 00:35:51,760
so this might look something like this

867
00:35:51,760 --> 00:35:52,400
for

868
00:35:52,400 --> 00:35:55,839
the for the green value of y we shift to

869
00:35:55,839 --> 00:35:56,960
the right

870
00:35:56,960 --> 00:36:00,640
and for the red value we shift to the

871
00:36:00,640 --> 00:36:01,839
left and for the orange

872
00:36:01,839 --> 00:36:04,960
value for instance if y is zero then it

873
00:36:04,960 --> 00:36:08,000
stays in its place and finally

874
00:36:08,000 --> 00:36:11,040
we use the restricted area in this case

875
00:36:11,040 --> 00:36:13,119
because we say it has to be larger than

876
00:36:13,119 --> 00:36:13,599
zero

877
00:36:13,599 --> 00:36:16,720
we take the right part of this of this

878
00:36:16,720 --> 00:36:18,560
distribution and we use this

879
00:36:18,560 --> 00:36:22,240
area as the likelihood

880
00:36:22,240 --> 00:36:25,200
then we update the distribution meaning

881
00:36:25,200 --> 00:36:25,520
we

882
00:36:25,520 --> 00:36:28,160
perform a base step over all the

883
00:36:28,160 --> 00:36:29,680
inequalities

884
00:36:29,680 --> 00:36:32,960
and which gives us updated distribution

885
00:36:32,960 --> 00:36:33,359
for

886
00:36:33,359 --> 00:36:36,400
each y for each secret coefficient and

887
00:36:36,400 --> 00:36:36,800
then

888
00:36:36,800 --> 00:36:40,000
we repeat this step so

889
00:36:40,000 --> 00:36:42,240
again compute marginals do an update

890
00:36:42,240 --> 00:36:44,640
marginals update etc

891
00:36:44,640 --> 00:36:47,760
until we reach convergence so this is

892
00:36:47,760 --> 00:36:50,480
kind of like a simplified version of

893
00:36:50,480 --> 00:36:53,119
belief propagation

894
00:36:53,119 --> 00:36:55,920
and it turns out that this approach

895
00:36:55,920 --> 00:36:56,400
works

896
00:36:56,400 --> 00:36:59,280
quite well we implemented and tried out

897
00:36:59,280 --> 00:37:00,480
the attack for

898
00:37:00,480 --> 00:37:03,440
the schemes new hope and kyber and we

899
00:37:03,440 --> 00:37:04,079
also

900
00:37:04,079 --> 00:37:07,520
attacked a masked implementation of a

901
00:37:07,520 --> 00:37:08,560
decoder

902
00:37:08,560 --> 00:37:12,240
now masking is not really a counter

903
00:37:12,240 --> 00:37:13,599
measure against faults but rather

904
00:37:13,599 --> 00:37:14,240
against

905
00:37:14,240 --> 00:37:17,680
side channel analysis but still if

906
00:37:17,680 --> 00:37:19,760
if we want to have a protected device

907
00:37:19,760 --> 00:37:21,359
then it also needs to be protected

908
00:37:21,359 --> 00:37:22,640
against side channels

909
00:37:22,640 --> 00:37:24,560
and if a side channel counter measure

910
00:37:24,560 --> 00:37:26,000
already destroys

911
00:37:26,000 --> 00:37:29,040
a uh this attack venue then we don't

912
00:37:29,040 --> 00:37:30,480
need to care about it but

913
00:37:30,480 --> 00:37:34,000
we uh also attacked

914
00:37:34,000 --> 00:37:37,520
mask implementations of uh

915
00:37:38,320 --> 00:37:41,599
which means that masking as such is not

916
00:37:41,599 --> 00:37:45,040
a countermeasure we then determine the

917
00:37:45,040 --> 00:37:46,079
success rate

918
00:37:46,079 --> 00:37:50,000
of of our attack using simulations for a

919
00:37:50,000 --> 00:37:51,359
varying number of

920
00:37:51,359 --> 00:37:54,480
fault injections and for the smallest

921
00:37:54,480 --> 00:37:56,960
kyber parameter set kyber 512

922
00:37:56,960 --> 00:38:00,960
we need 6000 or a little more than 6000

923
00:38:00,960 --> 00:38:04,800
volt injections to recover

924
00:38:04,800 --> 00:38:08,560
the uh secret key

925
00:38:08,560 --> 00:38:10,640
and of course for the larger parameter

926
00:38:10,640 --> 00:38:12,400
sets we need more faults

927
00:38:12,400 --> 00:38:14,720
since the keys are larger there is more

928
00:38:14,720 --> 00:38:18,000
information in the keys

929
00:38:18,000 --> 00:38:22,079
um to actually see if this attack also

930
00:38:22,079 --> 00:38:24,000
works on a real device we verified the

931
00:38:24,000 --> 00:38:26,400
attack by attacking a microcontroller

932
00:38:26,400 --> 00:38:30,160
so we had an arm cortex m4

933
00:38:30,160 --> 00:38:33,640
a chip with an armcotics m4 core running

934
00:38:33,640 --> 00:38:35,280
kyber512

935
00:38:35,280 --> 00:38:38,320
and we injected the described folds

936
00:38:38,320 --> 00:38:42,240
with clock glitches

937
00:38:42,640 --> 00:38:47,839
and of course this was also successful

938
00:38:49,200 --> 00:38:52,720
so what this means now is that

939
00:38:52,720 --> 00:38:56,560
this attack is quite practical

940
00:38:56,560 --> 00:38:58,839
because we did it as it has to be

941
00:38:58,839 --> 00:39:00,480
practically

942
00:39:00,480 --> 00:39:03,520
this means that the

943
00:39:03,520 --> 00:39:06,079
the fujisaki or kamoto transform that

944
00:39:06,079 --> 00:39:07,520
all these lattice-based

945
00:39:07,520 --> 00:39:10,800
cams use is a fault

946
00:39:10,800 --> 00:39:14,160
deterrent it probably makes fault

947
00:39:14,160 --> 00:39:17,359
attacks harder but it doesn't

948
00:39:17,359 --> 00:39:22,480
rule them out attacks are still possible

949
00:39:22,720 --> 00:39:24,400
i'd like to also add that we

950
00:39:24,400 --> 00:39:26,240
demonstrated the attack for

951
00:39:26,240 --> 00:39:30,480
two schemes kyber and new hope but

952
00:39:30,480 --> 00:39:33,920
similar attacks for other schemes very

953
00:39:33,920 --> 00:39:36,000
likely exist because as i said in the

954
00:39:36,000 --> 00:39:37,040
beginning there

955
00:39:37,040 --> 00:39:39,680
are quite some similarities so the

956
00:39:39,680 --> 00:39:41,839
attack might look a little bit different

957
00:39:41,839 --> 00:39:43,040
other instructions

958
00:39:43,040 --> 00:39:45,839
skipped or whatnot but it's i think

959
00:39:45,839 --> 00:39:48,160
likely that

960
00:39:48,160 --> 00:39:50,720
such attacks exist for other schemes as

961
00:39:50,720 --> 00:39:52,000
well

962
00:39:52,000 --> 00:39:54,960
and of course what we showed here is one

963
00:39:54,960 --> 00:39:57,119
particular instance of

964
00:39:57,119 --> 00:39:59,760
of such an attack so we said we had to

965
00:39:59,760 --> 00:40:00,960
skip this one

966
00:40:00,960 --> 00:40:03,440
very particular instruction but of

967
00:40:03,440 --> 00:40:04,319
course we

968
00:40:04,319 --> 00:40:06,560
don't rule out and it's very likely that

969
00:40:06,560 --> 00:40:07,440
there are

970
00:40:07,440 --> 00:40:09,599
similar attacks where you fold other

971
00:40:09,599 --> 00:40:11,200
instructions

972
00:40:11,200 --> 00:40:12,960
or you use other techniques like for

973
00:40:12,960 --> 00:40:15,920
instance a bit flip at certain positions

974
00:40:15,920 --> 00:40:16,240
and

975
00:40:16,240 --> 00:40:19,599
something like that so the general idea

976
00:40:19,599 --> 00:40:20,079
of

977
00:40:20,079 --> 00:40:24,960
of of um of uh

978
00:40:24,960 --> 00:40:27,119
of injecting a fault and and see if it's

979
00:40:27,119 --> 00:40:29,040
effective or ineffective

980
00:40:29,040 --> 00:40:32,640
uh can be used probably somewhere else

981
00:40:32,640 --> 00:40:37,200
as well and in other schemes

982
00:40:37,200 --> 00:40:40,319
um and my personal opinion is that

983
00:40:40,319 --> 00:40:43,040
we've already seen great progress in the

984
00:40:43,040 --> 00:40:44,720
implementation security of

985
00:40:44,720 --> 00:40:47,920
all sorts of uh post-quantum

986
00:40:47,920 --> 00:40:51,440
post-quantum schemes

987
00:40:51,440 --> 00:40:55,920
but as this attack shows which is

988
00:40:55,920 --> 00:40:57,920
one of the first attacks on

989
00:40:57,920 --> 00:40:59,359
lattice-based camps

990
00:40:59,359 --> 00:41:03,280
that the topic is far from

991
00:41:03,280 --> 00:41:06,319
solved there is still lots of work to do

992
00:41:06,319 --> 00:41:09,119
and remember that the first picks are

993
00:41:09,119 --> 00:41:10,240
done by nist

994
00:41:10,240 --> 00:41:12,960
this year so there is absolutely no time

995
00:41:12,960 --> 00:41:13,599
to lose

996
00:41:13,599 --> 00:41:16,480
and we have to continue looking at the

997
00:41:16,480 --> 00:41:18,240
implementation security

998
00:41:18,240 --> 00:41:21,599
of these schemes

999
00:41:21,599 --> 00:41:24,880
now what security for

1000
00:41:24,880 --> 00:41:28,079
against uh this uh this specific

1001
00:41:28,079 --> 00:41:30,800
attack might look like how can we

1002
00:41:30,800 --> 00:41:31,839
protect against

1003
00:41:31,839 --> 00:41:35,040
this very specific attack

1004
00:41:35,040 --> 00:41:38,240
well since we inject a

1005
00:41:38,240 --> 00:41:41,680
an instruction skip we might use

1006
00:41:41,680 --> 00:41:44,720
something that detects directly detects

1007
00:41:44,720 --> 00:41:46,240
the instructions keep as such

1008
00:41:46,240 --> 00:41:49,200
such as fine-grained control flow

1009
00:41:49,200 --> 00:41:51,040
integrity

1010
00:41:51,040 --> 00:41:54,400
but such a fine-grained

1011
00:41:54,400 --> 00:41:57,760
control integrity often needs some sort

1012
00:41:57,760 --> 00:41:58,880
of hardware support

1013
00:41:58,880 --> 00:42:01,359
to compute checksums along the way or

1014
00:42:01,359 --> 00:42:02,560
something like that

1015
00:42:02,560 --> 00:42:04,640
and as i said there might be other

1016
00:42:04,640 --> 00:42:06,160
attack paths which don't use an

1017
00:42:06,160 --> 00:42:08,240
instruction skip but instead a bit flip

1018
00:42:08,240 --> 00:42:10,880
or something like that

1019
00:42:10,880 --> 00:42:14,160
now the next thing that one usually does

1020
00:42:14,160 --> 00:42:16,720
against all sorts of faulty text is

1021
00:42:16,720 --> 00:42:18,400
double execution so you

1022
00:42:18,400 --> 00:42:20,560
compute an operation twice and then

1023
00:42:20,560 --> 00:42:22,240
check if the same

1024
00:42:22,240 --> 00:42:26,078
result comes out

1025
00:42:27,440 --> 00:42:30,800
so the we've already heard the

1026
00:42:30,800 --> 00:42:34,160
if the same result comes out once before

1027
00:42:34,160 --> 00:42:37,760
namely in terms of the fujisaki okamoto

1028
00:42:37,760 --> 00:42:40,480
transform which checks the ciphertext

1029
00:42:40,480 --> 00:42:43,200
which means that double execution might

1030
00:42:43,200 --> 00:42:44,079
also not work

1031
00:42:44,079 --> 00:42:47,359
because if we inject a fault we don't

1032
00:42:47,359 --> 00:42:49,200
care if it's the fujisak

1033
00:42:49,200 --> 00:42:52,400
or kamoto transform that tells us

1034
00:42:52,400 --> 00:42:55,440
if a fold was effective or ineffective

1035
00:42:55,440 --> 00:42:57,440
or if it's the double execution

1036
00:42:57,440 --> 00:43:00,000
countermeasure that tells us if a fault

1037
00:43:00,000 --> 00:43:03,359
is effective or ineffective

1038
00:43:03,359 --> 00:43:05,119
so this means that the double execution

1039
00:43:05,119 --> 00:43:07,200
has to be done on a very fine grained

1040
00:43:07,200 --> 00:43:07,599
level

1041
00:43:07,599 --> 00:43:09,599
in the decoder might be even that you

1042
00:43:09,599 --> 00:43:10,640
have to check

1043
00:43:10,640 --> 00:43:13,280
after each and every cpu instruction

1044
00:43:13,280 --> 00:43:14,560
which might get

1045
00:43:14,560 --> 00:43:18,160
expensive and even then in some

1046
00:43:18,160 --> 00:43:20,800
circumstances

1047
00:43:20,800 --> 00:43:23,280
double execution doesn't help at all we

1048
00:43:23,280 --> 00:43:23,839
found an

1049
00:43:23,839 --> 00:43:26,240
attack on new hope in which double

1050
00:43:26,240 --> 00:43:27,920
execution

1051
00:43:27,920 --> 00:43:30,800
even double execution for each

1052
00:43:30,800 --> 00:43:31,599
instruction

1053
00:43:31,599 --> 00:43:35,200
doesn't help so what helps

1054
00:43:35,200 --> 00:43:38,480
against our instance of the attack

1055
00:43:38,480 --> 00:43:40,160
against this very specific instruction

1056
00:43:40,160 --> 00:43:42,800
skip is the shuffling countermeasure

1057
00:43:42,800 --> 00:43:46,000
which means that you don't apply

1058
00:43:46,000 --> 00:43:49,280
the uh the decoder

1059
00:43:49,280 --> 00:43:52,480
in a fixed order on each coefficient

1060
00:43:52,480 --> 00:43:55,599
of the of these of this m prime but

1061
00:43:55,599 --> 00:43:59,040
in some randomized fashion

1062
00:43:59,040 --> 00:44:01,680
this means that you can still inject the

1063
00:44:01,680 --> 00:44:02,240
fault

1064
00:44:02,240 --> 00:44:03,680
and you can even detect if it's

1065
00:44:03,680 --> 00:44:05,359
ineffective or effective

1066
00:44:05,359 --> 00:44:08,160
but you don't know which coefficient you

1067
00:44:08,160 --> 00:44:09,599
actually hit

1068
00:44:09,599 --> 00:44:11,760
and you need this information to

1069
00:44:11,760 --> 00:44:12,800
actually

1070
00:44:12,800 --> 00:44:15,440
set up this inequality you need to know

1071
00:44:15,440 --> 00:44:15,920
which

1072
00:44:15,920 --> 00:44:19,040
information you actually targeted and as

1073
00:44:19,040 --> 00:44:19,599
a nice

1074
00:44:19,599 --> 00:44:23,119
bonus uh the shuffling counter measure

1075
00:44:23,119 --> 00:44:25,599
you also employ typically to to protect

1076
00:44:25,599 --> 00:44:26,319
against

1077
00:44:26,319 --> 00:44:29,520
side channel analysis

1078
00:44:30,160 --> 00:44:34,000
so to close off we put

1079
00:44:34,000 --> 00:44:36,400
our source code so our attack code and

1080
00:44:36,400 --> 00:44:37,599
simulation code

1081
00:44:37,599 --> 00:44:40,000
on github which means that you can go

1082
00:44:40,000 --> 00:44:40,800
there

1083
00:44:40,800 --> 00:44:43,760
check out the code

1084
00:44:44,400 --> 00:44:47,760
run all the simulations and

1085
00:44:47,760 --> 00:44:51,200
even or try to adapt the attack

1086
00:44:51,200 --> 00:44:54,560
or build on it that's it from my side

1087
00:44:54,560 --> 00:44:58,720
thank you for watching

