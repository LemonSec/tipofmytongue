1
00:00:00,880 --> 00:00:03,600
hello my name is julia and i'm a phd

2
00:00:03,600 --> 00:00:04,880
student at cornell

3
00:00:04,880 --> 00:00:07,520
advised by tom riston part in this

4
00:00:07,520 --> 00:00:09,519
presentation i'll be giving the extended

5
00:00:09,519 --> 00:00:11,759
talk on partitioning oracle attacks

6
00:00:11,759 --> 00:00:13,840
which is joint work with paul grubbs and

7
00:00:13,840 --> 00:00:16,480
thomaston part

8
00:00:16,480 --> 00:00:19,039
to begin symmetric cryptography is a

9
00:00:19,039 --> 00:00:21,279
fundamental tool for cryptography and

10
00:00:21,279 --> 00:00:22,480
security

11
00:00:22,480 --> 00:00:23,920
it's how we secure our modern

12
00:00:23,920 --> 00:00:26,080
communications over the internet

13
00:00:26,080 --> 00:00:29,359
from https to messaging applications

14
00:00:29,359 --> 00:00:30,000
like messenger

15
00:00:30,000 --> 00:00:32,719
and signal to video call applications

16
00:00:32,719 --> 00:00:34,079
like zoom

17
00:00:34,079 --> 00:00:36,000
and while the importance of symmetric

18
00:00:36,000 --> 00:00:37,120
cryptography

19
00:00:37,120 --> 00:00:39,600
has not changed over time our view and

20
00:00:39,600 --> 00:00:41,360
understanding of what a secure scheme

21
00:00:41,360 --> 00:00:43,520
has

22
00:00:43,520 --> 00:00:45,600
initially the security goal we targeted

23
00:00:45,600 --> 00:00:47,920
was confidentiality

24
00:00:47,920 --> 00:00:50,000
but then the padding oracle attack in

25
00:00:50,000 --> 00:00:51,120
2002

26
00:00:51,120 --> 00:00:53,680
showed that systems really also needed

27
00:00:53,680 --> 00:00:55,120
authenticity

28
00:00:55,120 --> 00:00:57,920
so our new goal became confidentiality

29
00:00:57,920 --> 00:00:59,520
and authenticity

30
00:00:59,520 --> 00:01:01,440
which we achieved through what we called

31
00:01:01,440 --> 00:01:02,800
authenticated encryption

32
00:01:02,800 --> 00:01:06,159
or aad and this has since been widely

33
00:01:06,159 --> 00:01:09,200
adopted as a core symmetric primitive

34
00:01:09,200 --> 00:01:10,960
what i'll argue in this talk is that

35
00:01:10,960 --> 00:01:12,479
we're again at a juncture

36
00:01:12,479 --> 00:01:14,320
where we need to evolve our definition

37
00:01:14,320 --> 00:01:16,080
of what a secure symmetric encryption

38
00:01:16,080 --> 00:01:18,000
scheme is

39
00:01:18,000 --> 00:01:20,640
i'll be describing a new class of attack

40
00:01:20,640 --> 00:01:21,439
that we call

41
00:01:21,439 --> 00:01:23,840
the partitioning oracle attack and how

42
00:01:23,840 --> 00:01:26,159
it makes certain types of aeid schemes

43
00:01:26,159 --> 00:01:27,840
that don't commit to their keys

44
00:01:27,840 --> 00:01:29,280
vulnerable

45
00:01:29,280 --> 00:01:31,280
so while before we focused on just

46
00:01:31,280 --> 00:01:33,759
confidentiality and authenticity

47
00:01:33,759 --> 00:01:35,360
now we might also want to add key

48
00:01:35,360 --> 00:01:38,320
commitment as a security goal to target

49
00:01:38,320 --> 00:01:40,079
and we can do that through what we call

50
00:01:40,079 --> 00:01:43,679
committing aad schemes

51
00:01:43,840 --> 00:01:45,600
i'll start by giving an overview of

52
00:01:45,600 --> 00:01:47,759
authenticated encryption in general

53
00:01:47,759 --> 00:01:49,600
and for simplicity here i'll ignore

54
00:01:49,600 --> 00:01:51,600
associated data

55
00:01:51,600 --> 00:01:54,159
so here in this setting we have a client

56
00:01:54,159 --> 00:01:56,479
in a server who share a secret key

57
00:01:56,479 --> 00:01:58,320
the client wants to send an encrypted

58
00:01:58,320 --> 00:02:00,000
message to the server

59
00:02:00,000 --> 00:02:02,000
so the client chooses a nonce and plain

60
00:02:02,000 --> 00:02:04,079
text message and encrypts the message

61
00:02:04,079 --> 00:02:07,360
using the secret key then the client can

62
00:02:07,360 --> 00:02:09,199
send the ciphertext to the server

63
00:02:09,199 --> 00:02:11,120
which can now decrypt using its secret

64
00:02:11,120 --> 00:02:13,599
key to recover the plaintext message

65
00:02:13,599 --> 00:02:15,440
we expect from this that an attacker

66
00:02:15,440 --> 00:02:16,640
sees the ciphertext

67
00:02:16,640 --> 00:02:18,319
will not be able to decrypt without

68
00:02:18,319 --> 00:02:20,879
knowing the secret key

69
00:02:20,879 --> 00:02:23,040
now there are many popular aid schemes

70
00:02:23,040 --> 00:02:24,160
out there such as

71
00:02:24,160 --> 00:02:27,599
aes gcm and xl su-20 poly 1305

72
00:02:27,599 --> 00:02:30,080
among others and they're really popular

73
00:02:30,080 --> 00:02:30,959
for good reason

74
00:02:30,959 --> 00:02:33,200
they're efficient standardized and they

75
00:02:33,200 --> 00:02:35,519
have widespread library support

76
00:02:35,519 --> 00:02:37,680
they also guarantee many security

77
00:02:37,680 --> 00:02:39,920
properties such as confidentiality and

78
00:02:39,920 --> 00:02:40,879
integrity

79
00:02:40,879 --> 00:02:42,959
as well as being proven proven chosen

80
00:02:42,959 --> 00:02:45,440
cyber text attacks secure

81
00:02:45,440 --> 00:02:47,840
however there is one security property

82
00:02:47,840 --> 00:02:50,800
that the aeid schemes do not target

83
00:02:50,800 --> 00:02:52,800
and that's robustness or also called

84
00:02:52,800 --> 00:02:55,760
committing aad

85
00:02:55,760 --> 00:02:58,319
now in a non-committing aid scheme you

86
00:02:58,319 --> 00:02:59,920
can compute a ciphertext

87
00:02:59,920 --> 00:03:02,239
that can successfully decrypt under two

88
00:03:02,239 --> 00:03:05,280
different keys so now in our setting

89
00:03:05,280 --> 00:03:07,440
the client has two keys and the server

90
00:03:07,440 --> 00:03:10,319
still has just one

91
00:03:10,319 --> 00:03:12,239
and while the client knows that one of

92
00:03:12,239 --> 00:03:14,720
its keys is being used by the server

93
00:03:14,720 --> 00:03:17,120
it might not know exactly which one but

94
00:03:17,120 --> 00:03:18,879
that doesn't matter here

95
00:03:18,879 --> 00:03:20,400
the client can simply send the

96
00:03:20,400 --> 00:03:22,319
ciphertext that can decrypt under two

97
00:03:22,319 --> 00:03:22,800
keys

98
00:03:22,800 --> 00:03:25,360
and the server as expected will still be

99
00:03:25,360 --> 00:03:28,400
able to decrypt it

100
00:03:28,480 --> 00:03:30,720
so notice that there's no guarantee the

101
00:03:30,720 --> 00:03:32,720
sender actually knows the exact

102
00:03:32,720 --> 00:03:35,440
key the recipient will use to decrypt

103
00:03:35,440 --> 00:03:37,280
and for the most part

104
00:03:37,280 --> 00:03:39,519
robustness or key commitment has not

105
00:03:39,519 --> 00:03:41,360
been considered an essential security

106
00:03:41,360 --> 00:03:43,120
goal

107
00:03:43,120 --> 00:03:44,879
here's what we've known so far about

108
00:03:44,879 --> 00:03:47,040
non-committing aad

109
00:03:47,040 --> 00:03:48,879
there are a few papers describing the

110
00:03:48,879 --> 00:03:50,480
various security definitions

111
00:03:50,480 --> 00:03:52,640
associated with key commitment or also

112
00:03:52,640 --> 00:03:54,640
called robustness

113
00:03:54,640 --> 00:03:56,480
abdallah at all and farshmed all first

114
00:03:56,480 --> 00:03:58,159
presented these definitions for public

115
00:03:58,159 --> 00:03:59,120
key encryption

116
00:03:59,120 --> 00:04:00,959
and then later for schmidt all extended

117
00:04:00,959 --> 00:04:03,760
these definitions to aeid

118
00:04:03,760 --> 00:04:05,680
grubs at all and dodis at all later

119
00:04:05,680 --> 00:04:08,640
described how asgcm is non-committing

120
00:04:08,640 --> 00:04:10,080
and showed that you can construct a

121
00:04:10,080 --> 00:04:12,239
ciphertext that can successfully decrypt

122
00:04:12,239 --> 00:04:15,200
under two keys dotus at all also showed

123
00:04:15,200 --> 00:04:16,798
how the sledge and attack of facebook

124
00:04:16,798 --> 00:04:17,839
messenger's

125
00:04:17,839 --> 00:04:20,959
message ranking protocol importantly

126
00:04:20,959 --> 00:04:21,918
the issues brought up with

127
00:04:21,918 --> 00:04:23,759
non-committing aad show that they

128
00:04:23,759 --> 00:04:25,440
affected message integrity

129
00:04:25,440 --> 00:04:29,120
but not confidentiality

130
00:04:29,120 --> 00:04:30,960
so the question is that given this

131
00:04:30,960 --> 00:04:33,280
background are vulnerabilities stemming

132
00:04:33,280 --> 00:04:35,520
from non-committing aed just a niche

133
00:04:35,520 --> 00:04:38,720
issue well the short answer here is no

134
00:04:38,720 --> 00:04:40,720
and to understand why i'll give a quick

135
00:04:40,720 --> 00:04:42,479
high-level overview of a partitioning

136
00:04:42,479 --> 00:04:43,680
oracle attack

137
00:04:43,680 --> 00:04:44,960
and how it can be used to break

138
00:04:44,960 --> 00:04:49,440
confidentiality by recovering a password

139
00:04:49,600 --> 00:04:51,280
now in this setting here we have a

140
00:04:51,280 --> 00:04:53,520
server with an associated password

141
00:04:53,520 --> 00:04:55,919
the server accepts encrypted queries

142
00:04:55,919 --> 00:04:57,440
which it then decrypts using a

143
00:04:57,440 --> 00:04:58,240
password-based

144
00:04:58,240 --> 00:05:00,720
non-committing aeid scheme so something

145
00:05:00,720 --> 00:05:03,120
like aes gcm

146
00:05:03,120 --> 00:05:04,800
the attacker wants to recover the

147
00:05:04,800 --> 00:05:06,960
server's password to help with this

148
00:05:06,960 --> 00:05:08,560
the attacker has access to a password

149
00:05:08,560 --> 00:05:10,000
dictionary which

150
00:05:10,000 --> 00:05:11,280
they could have gotten from leaked

151
00:05:11,280 --> 00:05:13,919
password data the server's

152
00:05:13,919 --> 00:05:15,440
password is a member of the password

153
00:05:15,440 --> 00:05:16,800
dictionary although of course the

154
00:05:16,800 --> 00:05:20,560
attacker doesn't know which one it is

155
00:05:20,800 --> 00:05:22,800
the attacker could make a single query

156
00:05:22,800 --> 00:05:24,720
for each password in the dictionary in a

157
00:05:24,720 --> 00:05:26,320
traditional brute force dictionary

158
00:05:26,320 --> 00:05:27,360
attack

159
00:05:27,360 --> 00:05:29,039
if the server responds with some

160
00:05:29,039 --> 00:05:31,360
decryption error then the attacker knows

161
00:05:31,360 --> 00:05:32,720
it's not correct

162
00:05:32,720 --> 00:05:35,120
but if the server responds with success

163
00:05:35,120 --> 00:05:36,320
then the attacker knows they have the

164
00:05:36,320 --> 00:05:38,400
right password

165
00:05:38,400 --> 00:05:40,320
but password dictionaries can be large

166
00:05:40,320 --> 00:05:41,440
and this technique could be

167
00:05:41,440 --> 00:05:43,360
prohibitively expansive

168
00:05:43,360 --> 00:05:45,280
especially if the number of queries the

169
00:05:45,280 --> 00:05:47,120
attacker can make is bounded

170
00:05:47,120 --> 00:05:50,639
so instead the attacker can do this

171
00:05:50,639 --> 00:05:52,240
the tagger can split the password

172
00:05:52,240 --> 00:05:54,880
dictionary into two sets

173
00:05:54,880 --> 00:05:57,280
then compute a nonce in ciphertext such

174
00:05:57,280 --> 00:05:59,520
that it can decrypt under every password

175
00:05:59,520 --> 00:06:01,759
in the first set we call this a

176
00:06:01,759 --> 00:06:03,199
splitting ciphertext

177
00:06:03,199 --> 00:06:04,639
because it can decrypt under all

178
00:06:04,639 --> 00:06:06,880
passwords in one set but under no

179
00:06:06,880 --> 00:06:09,199
passwords in the second set

180
00:06:09,199 --> 00:06:11,280
we say it has an associated value of k

181
00:06:11,280 --> 00:06:13,759
equals 4 because it can decrypt under 4

182
00:06:13,759 --> 00:06:17,520
passwords next the attacker queries the

183
00:06:17,520 --> 00:06:18,960
cyber text to the server

184
00:06:18,960 --> 00:06:21,280
which then attempts to decrypt the

185
00:06:21,280 --> 00:06:23,120
server's password is not in this first

186
00:06:23,120 --> 00:06:23,440
set

187
00:06:23,440 --> 00:06:26,319
so of course decryption will fail here

188
00:06:26,319 --> 00:06:27,680
the server then responds with a

189
00:06:27,680 --> 00:06:28,800
decryption error

190
00:06:28,800 --> 00:06:30,240
which tells the attacker that the

191
00:06:30,240 --> 00:06:31,919
server's password could not have been in

192
00:06:31,919 --> 00:06:34,479
this first set of passwords

193
00:06:34,479 --> 00:06:36,240
so the attacker can now simply eliminate

194
00:06:36,240 --> 00:06:37,680
the set altogether

195
00:06:37,680 --> 00:06:41,520
and reduce its dictionary in half

196
00:06:41,840 --> 00:06:43,840
comparing these attacks more directly

197
00:06:43,840 --> 00:06:45,759
with the brute force dictionary attack

198
00:06:45,759 --> 00:06:47,840
the attacker can only eliminate one

199
00:06:47,840 --> 00:06:50,000
password with each query

200
00:06:50,000 --> 00:06:52,160
meaning this will require big o and size

201
00:06:52,160 --> 00:06:53,919
of the dictionary number of queries to

202
00:06:53,919 --> 00:06:56,000
learn the password

203
00:06:56,000 --> 00:06:58,319
however for partitioning oracle tech

204
00:06:58,319 --> 00:07:00,240
with each query the attacker can

205
00:07:00,240 --> 00:07:01,680
eliminate half of the password

206
00:07:01,680 --> 00:07:02,479
dictionary

207
00:07:02,479 --> 00:07:05,199
every time the attacker can continue

208
00:07:05,199 --> 00:07:07,280
with this binary searchlight technique

209
00:07:07,280 --> 00:07:09,919
until they recover the target password

210
00:07:09,919 --> 00:07:11,280
this means only big o

211
00:07:11,280 --> 00:07:12,639
in log in the size of the password

212
00:07:12,639 --> 00:07:14,479
dictionary number of queries is needed

213
00:07:14,479 --> 00:07:16,160
to learn the password

214
00:07:16,160 --> 00:07:18,080
notice that this is an exponential speed

215
00:07:18,080 --> 00:07:20,800
up over a brute force dictionary attack

216
00:07:20,800 --> 00:07:22,800
of course password dictionaries can be

217
00:07:22,800 --> 00:07:24,080
extremely large

218
00:07:24,080 --> 00:07:25,759
and it might not be practical to make

219
00:07:25,759 --> 00:07:28,080
such a query but if we consider a more

220
00:07:28,080 --> 00:07:29,680
practical value such as k

221
00:07:29,680 --> 00:07:33,039
equals 5000 we see that for each query

222
00:07:33,039 --> 00:07:34,960
the attacker can still eliminate

223
00:07:34,960 --> 00:07:37,840
5000 passwords every time until the

224
00:07:37,840 --> 00:07:39,919
attacker reaches the correct set of 5000

225
00:07:39,919 --> 00:07:41,199
passwords

226
00:07:41,199 --> 00:07:43,440
after which the attacker can can proceed

227
00:07:43,440 --> 00:07:46,080
with the binary searchlike technique

228
00:07:46,080 --> 00:07:48,319
this case still offers a good speed up

229
00:07:48,319 --> 00:07:51,039
over brute force

230
00:07:51,039 --> 00:07:52,800
so now that we have a high level

231
00:07:52,800 --> 00:07:54,639
overview of what a partitioning oracle

232
00:07:54,639 --> 00:07:55,520
tech is

233
00:07:55,520 --> 00:07:57,599
for the rest of this talk i'll discuss

234
00:07:57,599 --> 00:07:58,879
the formal setting

235
00:07:58,879 --> 00:08:00,720
then how we can build splitting

236
00:08:00,720 --> 00:08:02,560
ciphertexts that decrypt under k

237
00:08:02,560 --> 00:08:05,919
different keys for any k gaining access

238
00:08:05,919 --> 00:08:07,520
to a partitioning oracle

239
00:08:07,520 --> 00:08:11,039
and lastly what do we do about this

240
00:08:11,039 --> 00:08:14,400
first i'll formalize this setting here

241
00:08:14,400 --> 00:08:16,400
we have an interface f which has an

242
00:08:16,400 --> 00:08:18,560
associated secret password chosen from

243
00:08:18,560 --> 00:08:19,680
set d

244
00:08:19,680 --> 00:08:22,879
the attacker knows some subset s of d

245
00:08:22,879 --> 00:08:26,000
and is also given oracle access to f

246
00:08:26,000 --> 00:08:28,080
for each string v that the attacker

247
00:08:28,080 --> 00:08:30,160
queries f responds with

248
00:08:30,160 --> 00:08:33,919
either 0 for failure or 1 for success

249
00:08:33,919 --> 00:08:35,200
the goal of the attacker is to

250
00:08:35,200 --> 00:08:36,640
efficiently recover the password

251
00:08:36,640 --> 00:08:37,599
associated with

252
00:08:37,599 --> 00:08:40,640
f we say that f

253
00:08:40,640 --> 00:08:42,479
is a partitioning oracle if it is

254
00:08:42,479 --> 00:08:44,720
computationally trackable for an

255
00:08:44,720 --> 00:08:47,200
attacker given the set s to compute what

256
00:08:47,200 --> 00:08:47,760
we call

257
00:08:47,760 --> 00:08:50,800
a splitting value b hat such that

258
00:08:50,800 --> 00:08:52,800
querying the splitting value to f

259
00:08:52,800 --> 00:08:55,920
divides s into two sets

260
00:08:55,920 --> 00:08:58,640
if the password associated to f is an s

261
00:08:58,640 --> 00:08:59,600
star

262
00:08:59,600 --> 00:09:02,480
then f will return one however if the

263
00:09:02,480 --> 00:09:04,399
password associated to f

264
00:09:04,399 --> 00:09:09,839
is not an s star then f will return zero

265
00:09:10,399 --> 00:09:13,279
we say that the splitting value v-hat is

266
00:09:13,279 --> 00:09:13,920
targeted

267
00:09:13,920 --> 00:09:15,839
if the attacker can choose the secrets

268
00:09:15,839 --> 00:09:17,279
in s-star

269
00:09:17,279 --> 00:09:19,040
and we say that the splitting value is

270
00:09:19,040 --> 00:09:21,360
untargeted if it results in some random

271
00:09:21,360 --> 00:09:22,959
partition of s

272
00:09:22,959 --> 00:09:25,519
finally we call k which is the size of s

273
00:09:25,519 --> 00:09:26,080
star

274
00:09:26,080 --> 00:09:29,760
the degree of the splitting value

275
00:09:30,080 --> 00:09:31,440
now that we've covered the formal

276
00:09:31,440 --> 00:09:34,080
setting we'll move on to building

277
00:09:34,080 --> 00:09:34,959
splitting

278
00:09:34,959 --> 00:09:37,120
ciphertext which is really computing

279
00:09:37,120 --> 00:09:39,920
what we call key multi-collision attacks

280
00:09:39,920 --> 00:09:41,440
grubs at all first showed an attack

281
00:09:41,440 --> 00:09:44,240
against aes gcm for k equals 2.

282
00:09:44,240 --> 00:09:46,160
we'll show how to do this attack for any

283
00:09:46,160 --> 00:09:48,640
value of k

284
00:09:48,640 --> 00:09:50,959
we define key multi-collision attacks as

285
00:09:50,959 --> 00:09:52,000
a novel carton

286
00:09:52,000 --> 00:09:54,240
crypt analytical they can be either

287
00:09:54,240 --> 00:09:56,320
targeted or untargeted

288
00:09:56,320 --> 00:09:58,480
in the targeted case we say that given

289
00:09:58,480 --> 00:10:00,399
some target set of keys k

290
00:10:00,399 --> 00:10:02,079
it's difficult for an adversary to

291
00:10:02,079 --> 00:10:03,920
produce a ciphertext that can decrypt

292
00:10:03,920 --> 00:10:05,040
under all keys

293
00:10:05,040 --> 00:10:07,920
in the keysight the untargeted case is

294
00:10:07,920 --> 00:10:08,800
similar

295
00:10:08,800 --> 00:10:10,720
but it allows the adversary to output a

296
00:10:10,720 --> 00:10:13,519
set of keys of its own choosing

297
00:10:13,519 --> 00:10:17,440
mkcr security implies tmkcr

298
00:10:17,440 --> 00:10:20,720
given a tmkcr adversary it's trivial to

299
00:10:20,720 --> 00:10:23,200
make an mkcr adversary here

300
00:10:23,200 --> 00:10:25,600
this means that mkcr is a stronger

301
00:10:25,600 --> 00:10:26,720
property

302
00:10:26,720 --> 00:10:28,560
for our attacks of course targeted

303
00:10:28,560 --> 00:10:30,160
attacks will be better because it means

304
00:10:30,160 --> 00:10:31,440
the attacker can create a

305
00:10:31,440 --> 00:10:35,519
multi-collision for any set of keys

306
00:10:36,560 --> 00:10:39,600
to give a high-level overview of aes gcm

307
00:10:39,600 --> 00:10:42,959
it follows the encrypt then mac paradigm

308
00:10:42,959 --> 00:10:44,720
for encryption it uses counter mode

309
00:10:44,720 --> 00:10:46,800
encryption of aes and for its mac

310
00:10:46,800 --> 00:10:50,160
it uses g-hash which is a polynomial mac

311
00:10:50,160 --> 00:10:52,240
our attack algorithm will take its input

312
00:10:52,240 --> 00:10:53,760
k different keys

313
00:10:53,760 --> 00:10:55,360
and it will output a ciphertext that

314
00:10:55,360 --> 00:10:56,800
decrypts under all k

315
00:10:56,800 --> 00:10:59,360
keys the length of the ciphertext will

316
00:10:59,360 --> 00:11:01,120
be k at 16 byte blocks

317
00:11:01,120 --> 00:11:03,279
and the algorithm will run in big o of k

318
00:11:03,279 --> 00:11:04,959
square time

319
00:11:04,959 --> 00:11:06,959
now what really enables our attack here

320
00:11:06,959 --> 00:11:09,120
is the fact that g hash is a polynomial

321
00:11:09,120 --> 00:11:09,920
mac

322
00:11:09,920 --> 00:11:11,839
this reduces finding a ciphertext to

323
00:11:11,839 --> 00:11:15,760
solving a system of linear equations

324
00:11:15,760 --> 00:11:18,480
to provide more context about g hash

325
00:11:18,480 --> 00:11:20,000
it's a carter redmond mac

326
00:11:20,000 --> 00:11:22,320
which computes over galway field gf2 to

327
00:11:22,320 --> 00:11:23,839
the 128

328
00:11:23,839 --> 00:11:26,399
it takes as input a key a nonce and a

329
00:11:26,399 --> 00:11:27,440
ciphertext

330
00:11:27,440 --> 00:11:29,600
and again we assume no associated data

331
00:11:29,600 --> 00:11:31,200
here

332
00:11:31,200 --> 00:11:34,160
it works by computing a polynomial the

333
00:11:34,160 --> 00:11:36,160
coefficients of our polynomial will be

334
00:11:36,160 --> 00:11:37,920
blocks of the ciphertext

335
00:11:37,920 --> 00:11:40,000
so g hash first breaks the cybertext

336
00:11:40,000 --> 00:11:42,800
into 16 byte blocks

337
00:11:42,800 --> 00:11:44,640
the point at which the polynomial will

338
00:11:44,640 --> 00:11:46,079
be evaluated is h

339
00:11:46,079 --> 00:11:48,560
the aes encryption of an all zero string

340
00:11:48,560 --> 00:11:50,079
under the key

341
00:11:50,079 --> 00:11:52,720
we also compute a pad value p which is

342
00:11:52,720 --> 00:11:53,519
the aes

343
00:11:53,519 --> 00:11:56,480
encryption of the nonce and finally l

344
00:11:56,480 --> 00:12:00,320
which is the length of the ciphertext

345
00:12:00,320 --> 00:12:02,880
we next evaluate the polynomial h and

346
00:12:02,880 --> 00:12:06,480
finally xor in the pad p

347
00:12:07,120 --> 00:12:09,360
i'll now go over a quick example of how

348
00:12:09,360 --> 00:12:11,040
to compute key multicollisions for

349
00:12:11,040 --> 00:12:12,160
adsgcm

350
00:12:12,160 --> 00:12:15,120
with three keys our input will be a

351
00:12:15,120 --> 00:12:15,760
nonce

352
00:12:15,760 --> 00:12:19,279
an authentication tag and the three keys

353
00:12:19,279 --> 00:12:21,200
our goal is to compute a ciphertext that

354
00:12:21,200 --> 00:12:24,000
decrypts under all three keys

355
00:12:24,000 --> 00:12:26,320
first we pre-compute values which will

356
00:12:26,320 --> 00:12:28,000
be the coefficients of our system of

357
00:12:28,000 --> 00:12:29,360
equations

358
00:12:29,360 --> 00:12:31,200
our system of equations will have three

359
00:12:31,200 --> 00:12:33,279
variables with each variable

360
00:12:33,279 --> 00:12:35,519
representing a ciphertext block

361
00:12:35,519 --> 00:12:37,360
this means our final ciphertext will

362
00:12:37,360 --> 00:12:39,279
have three blocks

363
00:12:39,279 --> 00:12:41,360
we then set up the system by computing

364
00:12:41,360 --> 00:12:43,360
the g hash tag for each key

365
00:12:43,360 --> 00:12:46,320
in the typical way

366
00:12:46,399 --> 00:12:48,000
we can then simplify to get the

367
00:12:48,000 --> 00:12:50,880
resulting system of equations shown here

368
00:12:50,880 --> 00:12:52,560
notice that the left-hand coefficient

369
00:12:52,560 --> 00:12:55,120
matrix is a van der maan matrix

370
00:12:55,120 --> 00:12:56,880
this means we can use a more efficient

371
00:12:56,880 --> 00:12:58,880
technique for solving called polynomial

372
00:12:58,880 --> 00:12:59,920
interpolation

373
00:12:59,920 --> 00:13:03,839
which runs in big o of k squared time

374
00:13:04,639 --> 00:13:06,800
we implemented this algorithm using sage

375
00:13:06,800 --> 00:13:08,000
math and magma

376
00:13:08,000 --> 00:13:09,760
and perform timing experiments on a

377
00:13:09,760 --> 00:13:11,600
linux desktop

378
00:13:11,600 --> 00:13:14,480
the results are shown in the table here

379
00:13:14,480 --> 00:13:16,320
notice that we were able to make a cyber

380
00:13:16,320 --> 00:13:18,000
text that decrypts under greater than

381
00:13:18,000 --> 00:13:19,279
4000 keys

382
00:13:19,279 --> 00:13:22,320
in less than 30 seconds

383
00:13:22,320 --> 00:13:23,920
i'd also like to point out that there

384
00:13:23,920 --> 00:13:25,440
does exist an algorithm that does

385
00:13:25,440 --> 00:13:27,680
polynomial interpolation and big o of k

386
00:13:27,680 --> 00:13:29,279
log squared k time

387
00:13:29,279 --> 00:13:30,800
so it is possible to create multi

388
00:13:30,800 --> 00:13:35,680
collisions much faster

389
00:13:35,680 --> 00:13:37,680
in addition to asgcm we found that

390
00:13:37,680 --> 00:13:39,519
exhaust of 20 poly 1305

391
00:13:39,519 --> 00:13:43,199
child shot 20 poly 1305 and aes gcm siv

392
00:13:43,199 --> 00:13:45,360
were all also vulnerable to key

393
00:13:45,360 --> 00:13:47,279
multi-collision attacks

394
00:13:47,279 --> 00:13:49,600
however these attacks are more complex

395
00:13:49,600 --> 00:13:53,920
and less scalable than those for aes gcm

396
00:13:55,360 --> 00:13:56,560
now that we've covered key

397
00:13:56,560 --> 00:13:58,639
multi-collision attacks i'll move on to

398
00:13:58,639 --> 00:13:59,680
covering

399
00:13:59,680 --> 00:14:01,360
how we can get access to a partitioning

400
00:14:01,360 --> 00:14:02,959
oracle in other words

401
00:14:02,959 --> 00:14:06,719
where do partitioning oracles arise

402
00:14:07,360 --> 00:14:09,600
so shadowsocks is an encrypted proxy for

403
00:14:09,600 --> 00:14:10,720
tcp

404
00:14:10,720 --> 00:14:13,760
udp traffic based on sox5 it is a

405
00:14:13,760 --> 00:14:15,920
popular tool for censorship resistance

406
00:14:15,920 --> 00:14:18,079
that's widely used in china and is even

407
00:14:18,079 --> 00:14:21,360
used by google jigsaw's outline vpn tool

408
00:14:21,360 --> 00:14:23,760
i'll show how we can efficiently recover

409
00:14:23,760 --> 00:14:25,680
passwords from shadowstock servers

410
00:14:25,680 --> 00:14:28,160
using partitioning oracle texts but

411
00:14:28,160 --> 00:14:28,720
first

412
00:14:28,720 --> 00:14:30,320
i'll begin by giving you an overview of

413
00:14:30,320 --> 00:14:32,320
how shadow socks works

414
00:14:32,320 --> 00:14:35,920
and for this talk we focus on udp to

415
00:14:35,920 --> 00:14:37,760
allow the attack against tcp would

416
00:14:37,760 --> 00:14:39,360
require solving a multi-collision

417
00:14:39,360 --> 00:14:40,800
ciphertext for smaller

418
00:14:40,800 --> 00:14:45,839
than a block which is an open problem

419
00:14:46,720 --> 00:14:48,560
here we have the shadowstock server and

420
00:14:48,560 --> 00:14:50,800
the client ultimately the client wants

421
00:14:50,800 --> 00:14:52,959
to query some other destination

422
00:14:52,959 --> 00:14:55,040
but for some reason can't on its own

423
00:14:55,040 --> 00:14:56,880
perhaps because of censorship

424
00:14:56,880 --> 00:14:58,560
so the client relies on the shadowstock

425
00:14:58,560 --> 00:15:00,399
server to act as a proxy

426
00:15:00,399 --> 00:15:02,079
they both share a password which will

427
00:15:02,079 --> 00:15:03,680
enable them to encrypt their

428
00:15:03,680 --> 00:15:06,160
communication

429
00:15:06,160 --> 00:15:07,920
first the client derives a session key

430
00:15:07,920 --> 00:15:09,600
from its password

431
00:15:09,600 --> 00:15:11,680
this protocol also uses assault but for

432
00:15:11,680 --> 00:15:14,000
simplicity i ignore it here

433
00:15:14,000 --> 00:15:15,760
then it needs to encrypt the payload it

434
00:15:15,760 --> 00:15:18,160
wants to send as well as the destination

435
00:15:18,160 --> 00:15:21,199
it wants to send this to

436
00:15:21,199 --> 00:15:23,440
to do this the client forms the string

437
00:15:23,440 --> 00:15:24,320
shown

438
00:15:24,320 --> 00:15:26,399
the first byte indicates that the

439
00:15:26,399 --> 00:15:29,199
destination address is using ipv4

440
00:15:29,199 --> 00:15:30,959
the next part of the string indicates

441
00:15:30,959 --> 00:15:33,519
the destination ip address in port

442
00:15:33,519 --> 00:15:35,120
and finally the remaining part of the

443
00:15:35,120 --> 00:15:38,959
string is the actual payload itself

444
00:15:39,279 --> 00:15:41,199
next the client sends the ciphertext to

445
00:15:41,199 --> 00:15:43,680
the shadowsock server

446
00:15:43,680 --> 00:15:45,920
now the server derives the session key

447
00:15:45,920 --> 00:15:47,600
itself and tries to decrypt the

448
00:15:47,600 --> 00:15:49,199
ciphertext

449
00:15:49,199 --> 00:15:51,519
if decryption fails the server silently

450
00:15:51,519 --> 00:15:52,959
drops the invalid request

451
00:15:52,959 --> 00:15:55,839
as a counter measure looking forward

452
00:15:55,839 --> 00:15:57,440
since partitioning oracle attacks do

453
00:15:57,440 --> 00:15:58,639
rely on detecting

454
00:15:58,639 --> 00:16:00,480
decryption failure this will make our

455
00:16:00,480 --> 00:16:03,199
attack a bit harder to execute

456
00:16:03,199 --> 00:16:05,839
however if decryption succeeds the

457
00:16:05,839 --> 00:16:07,600
server now knows the payload and the

458
00:16:07,600 --> 00:16:11,120
destination address to send it to

459
00:16:11,120 --> 00:16:12,959
so the server now opens in ephemeral

460
00:16:12,959 --> 00:16:14,800
port and sends the payload to the

461
00:16:14,800 --> 00:16:17,839
destination address

462
00:16:17,839 --> 00:16:19,920
the shadowhawk server keeps us ephemeral

463
00:16:19,920 --> 00:16:21,920
report open for five minutes to wait for

464
00:16:21,920 --> 00:16:24,560
a response

465
00:16:24,800 --> 00:16:27,440
when it does importantly it never checks

466
00:16:27,440 --> 00:16:29,279
where the response came from

467
00:16:29,279 --> 00:16:33,120
this will be relevant to our talk later

468
00:16:33,839 --> 00:16:35,759
now the shadowstock server derives a new

469
00:16:35,759 --> 00:16:37,600
session key from its password and

470
00:16:37,600 --> 00:16:39,440
encrypts the response it got

471
00:16:39,440 --> 00:16:43,600
then sends this back to the source

472
00:16:44,480 --> 00:16:46,480
given this background on shadowsocks

473
00:16:46,480 --> 00:16:49,680
we'll next dive into the attack itself

474
00:16:49,680 --> 00:16:51,600
in this setting we assume a malicious

475
00:16:51,600 --> 00:16:53,600
client knows the ip address of a shadow

476
00:16:53,600 --> 00:16:54,720
clock server

477
00:16:54,720 --> 00:16:56,079
and their goal is to recover the

478
00:16:56,079 --> 00:16:58,720
server's password we do not assume the

479
00:16:58,720 --> 00:17:00,560
ability to capture honest traffic

480
00:17:00,560 --> 00:17:02,720
and notably shadow socks is already

481
00:17:02,720 --> 00:17:04,319
vulnerable to offline brute force

482
00:17:04,319 --> 00:17:06,160
dictionary attacks

483
00:17:06,160 --> 00:17:08,000
also shadow socks would be considered

484
00:17:08,000 --> 00:17:09,520
secure in our threat model

485
00:17:09,520 --> 00:17:11,839
if online online brute force dictionary

486
00:17:11,839 --> 00:17:15,520
attacks were the best possible attack

487
00:17:15,520 --> 00:17:18,400
our attack will run in two phases an

488
00:17:18,400 --> 00:17:20,079
offline precomputation phase

489
00:17:20,079 --> 00:17:22,799
and an online acquiring phase the first

490
00:17:22,799 --> 00:17:24,400
phase of our attack is the offline

491
00:17:24,400 --> 00:17:26,079
precomputation phase

492
00:17:26,079 --> 00:17:28,160
where we compute the ciphertext using an

493
00:17:28,160 --> 00:17:30,960
untargeted multi-collision attack

494
00:17:30,960 --> 00:17:33,039
recall that after decrypting the

495
00:17:33,039 --> 00:17:34,640
shadowstock server checks that the first

496
00:17:34,640 --> 00:17:37,360
byte of the plain text is 0 1.

497
00:17:37,360 --> 00:17:39,200
this makes forming a multi-collision

498
00:17:39,200 --> 00:17:41,039
cipher text a bit trickier

499
00:17:41,039 --> 00:17:42,559
and we'll have to take this into account

500
00:17:42,559 --> 00:17:46,400
when computing our cipher texts

501
00:17:46,400 --> 00:17:48,640
to do this we first assume we're given a

502
00:17:48,640 --> 00:17:50,559
password dictionary with an associated

503
00:17:50,559 --> 00:17:53,840
probability distribution

504
00:17:53,840 --> 00:17:55,679
now because of the plain text format

505
00:17:55,679 --> 00:17:57,120
check we can't make

506
00:17:57,120 --> 00:17:58,960
multi-collisions for any set of

507
00:17:58,960 --> 00:18:00,480
passwords since

508
00:18:00,480 --> 00:18:02,400
a random key will decrypt the first byte

509
00:18:02,400 --> 00:18:04,400
to random bits which are unlikely to be

510
00:18:04,400 --> 00:18:05,440
one

511
00:18:05,440 --> 00:18:07,440
so instead we can try to match a

512
00:18:07,440 --> 00:18:09,120
password that we know will encrypt the

513
00:18:09,120 --> 00:18:10,320
plaintext

514
00:18:10,320 --> 00:18:13,360
1 to the same ciphertext byte

515
00:18:13,360 --> 00:18:15,440
to do this we compute the ciphertext

516
00:18:15,440 --> 00:18:17,919
byte of the plaintext byte1

517
00:18:17,919 --> 00:18:21,760
for every password in the dictionary

518
00:18:22,160 --> 00:18:24,240
now because it's only a byte there's

519
00:18:24,240 --> 00:18:27,360
only 256 possible ciphertext

520
00:18:27,360 --> 00:18:30,080
so we can group the passwords into 256

521
00:18:30,080 --> 00:18:30,480
sets

522
00:18:30,480 --> 00:18:33,520
based on having a matching ciphertext so

523
00:18:33,520 --> 00:18:34,640
for example

524
00:18:34,640 --> 00:18:36,880
here all passwords that encrypt the

525
00:18:36,880 --> 00:18:37,919
string1

526
00:18:37,919 --> 00:18:40,480
to the ciphertext that is the all zero

527
00:18:40,480 --> 00:18:42,160
string will you put in set

528
00:18:42,160 --> 00:18:44,960
k sub zero

529
00:18:46,080 --> 00:18:47,679
now we need to choose which of these

530
00:18:47,679 --> 00:18:49,440
password sets we want to compute a

531
00:18:49,440 --> 00:18:51,520
multi-collision for

532
00:18:51,520 --> 00:18:54,160
we can choose the set k sub i that has

533
00:18:54,160 --> 00:18:56,160
the maximum aggregate probability

534
00:18:56,160 --> 00:18:58,160
under the probability distribution for a

535
00:18:58,160 --> 00:19:00,880
size k subset

536
00:19:00,880 --> 00:19:02,640
and because of udp packet size

537
00:19:02,640 --> 00:19:04,799
limitation we can have at most

538
00:19:04,799 --> 00:19:08,840
k equals 4091 passwords to form a

539
00:19:08,840 --> 00:19:11,120
multi-collision

540
00:19:11,120 --> 00:19:13,160
finally once we've chosen the set of

541
00:19:13,160 --> 00:19:14,799
4091 passwords

542
00:19:14,799 --> 00:19:18,320
we compute the mkcr ciphertext except we

543
00:19:18,320 --> 00:19:19,919
fix the first block with the correct

544
00:19:19,919 --> 00:19:22,080
byte as a constant

545
00:19:22,080 --> 00:19:25,440
this ciphertext will have 4092 16 byte

546
00:19:25,440 --> 00:19:27,919
blocks

547
00:19:28,640 --> 00:19:30,960
now we can enter the querying phase of

548
00:19:30,960 --> 00:19:32,480
the attack and send the computed

549
00:19:32,480 --> 00:19:34,880
ciphertext over to the server

550
00:19:34,880 --> 00:19:37,200
the server will attempt to decrypt the

551
00:19:37,200 --> 00:19:38,400
ciphertext

552
00:19:38,400 --> 00:19:40,559
again if decryption fails the server

553
00:19:40,559 --> 00:19:42,480
will just silently drop the ciphertext

554
00:19:42,480 --> 00:19:43,760
and do nothing

555
00:19:43,760 --> 00:19:47,200
however if decryption succeeds

556
00:19:47,200 --> 00:19:49,600
the server will open an ephemeral port

557
00:19:49,600 --> 00:19:51,120
and forward the payload to the

558
00:19:51,120 --> 00:19:53,360
destination address

559
00:19:53,360 --> 00:19:55,280
so now at this point the attacker needs

560
00:19:55,280 --> 00:19:57,280
to figure out a way to detect whether

561
00:19:57,280 --> 00:20:00,000
the ciphertext was decrypted or not

562
00:20:00,000 --> 00:20:02,080
obviously the server didn't say anything

563
00:20:02,080 --> 00:20:02,799
directly

564
00:20:02,799 --> 00:20:05,360
to the attacker but it did open this

565
00:20:05,360 --> 00:20:06,320
ephemeral port

566
00:20:06,320 --> 00:20:08,799
and very conveniently for the attacker

567
00:20:08,799 --> 00:20:10,400
the server is not checking whether a

568
00:20:10,400 --> 00:20:11,280
response to the

569
00:20:11,280 --> 00:20:13,679
port itself came from the intended

570
00:20:13,679 --> 00:20:15,679
destination

571
00:20:15,679 --> 00:20:17,440
so if the attacker could just send

572
00:20:17,440 --> 00:20:19,600
something to the correct port

573
00:20:19,600 --> 00:20:21,520
then the server will register this as a

574
00:20:21,520 --> 00:20:23,360
response and send this back to the

575
00:20:23,360 --> 00:20:24,640
attacker

576
00:20:24,640 --> 00:20:26,000
and then the attacker would know whether

577
00:20:26,000 --> 00:20:28,559
decryption succeeded

578
00:20:28,559 --> 00:20:30,159
well how does the attacker know which

579
00:20:30,159 --> 00:20:32,400
random port the shadowstocks proxy

580
00:20:32,400 --> 00:20:35,039
server opened fortunately this part is

581
00:20:35,039 --> 00:20:36,799
easy

582
00:20:36,799 --> 00:20:39,200
the attacker can simply run a udp port

583
00:20:39,200 --> 00:20:40,320
scan to probe

584
00:20:40,320 --> 00:20:44,240
every port once the correct port is

585
00:20:44,240 --> 00:20:45,039
probed

586
00:20:45,039 --> 00:20:47,280
the shadowstock server will register

587
00:20:47,280 --> 00:20:48,400
this as a response

588
00:20:48,400 --> 00:20:50,080
and encrypt it to send it back to the

589
00:20:50,080 --> 00:20:51,520
attacker

590
00:20:51,520 --> 00:20:53,760
so after the cdp port scan if the

591
00:20:53,760 --> 00:20:55,520
attacker didn't receive anything

592
00:20:55,520 --> 00:20:57,360
they know that decryption failed and

593
00:20:57,360 --> 00:20:59,039
they should try a different key set

594
00:20:59,039 --> 00:21:02,080
however if decryption succeeded

595
00:21:02,080 --> 00:21:04,000
the attacker can now trial decrypt the

596
00:21:04,000 --> 00:21:05,520
ciphertext to receive back from the

597
00:21:05,520 --> 00:21:06,080
server

598
00:21:06,080 --> 00:21:09,520
to find the right password

599
00:21:11,520 --> 00:21:13,679
now to evaluate the attack we ran

600
00:21:13,679 --> 00:21:15,600
success rate simulations

601
00:21:15,600 --> 00:21:18,720
our data set was 377 million unique

602
00:21:18,720 --> 00:21:19,760
passwords

603
00:21:19,760 --> 00:21:21,760
which we tamed from a large breach

604
00:21:21,760 --> 00:21:22,960
compilation

605
00:21:22,960 --> 00:21:25,360
together with the password frequency

606
00:21:25,360 --> 00:21:28,960
there were 1.1 billion passwords overall

607
00:21:28,960 --> 00:21:31,120
we partition the data set randomly into

608
00:21:31,120 --> 00:21:32,400
two halves

609
00:21:32,400 --> 00:21:34,400
one set is a training set used by the

610
00:21:34,400 --> 00:21:36,880
attacker and the other is a testing set

611
00:21:36,880 --> 00:21:37,280
used

612
00:21:37,280 --> 00:21:39,200
as the empirical distribution for

613
00:21:39,200 --> 00:21:41,520
sampling a target password

614
00:21:41,520 --> 00:21:43,520
the maximum success rate achievable is

615
00:21:43,520 --> 00:21:45,919
70 because some passwords in the test

616
00:21:45,919 --> 00:21:46,320
set

617
00:21:46,320 --> 00:21:48,880
are not in the training set we compare

618
00:21:48,880 --> 00:21:50,480
the partitioning oracle attack

619
00:21:50,480 --> 00:21:52,679
which has associated value of k equal

620
00:21:52,679 --> 00:21:54,880
4091

621
00:21:54,880 --> 00:21:57,039
to a brute force dictionary attack which

622
00:21:57,039 --> 00:21:59,200
has an associated value of k equals to

623
00:21:59,200 --> 00:22:01,520
1.

624
00:22:02,480 --> 00:22:04,080
shown in the graphs below are the

625
00:22:04,080 --> 00:22:06,000
results of these simulations

626
00:22:06,000 --> 00:22:07,760
the graph on the left shows the number

627
00:22:07,760 --> 00:22:10,320
of queries versus the success rate for

628
00:22:10,320 --> 00:22:11,600
each attack

629
00:22:11,600 --> 00:22:13,280
the graph on the right shows the

630
00:22:13,280 --> 00:22:15,200
bandwidth in gigabytes versus the

631
00:22:15,200 --> 00:22:17,039
success rate

632
00:22:17,039 --> 00:22:18,960
so overall the partitioning oracle

633
00:22:18,960 --> 00:22:20,799
attack outperforms the brute force

634
00:22:20,799 --> 00:22:21,600
attack for

635
00:22:21,600 --> 00:22:24,799
all query budgets

636
00:22:24,960 --> 00:22:26,720
the partitioning oracle attack does

637
00:22:26,720 --> 00:22:28,480
require more bandwidth for a single

638
00:22:28,480 --> 00:22:29,400
query

639
00:22:29,400 --> 00:22:32,880
65 000 bytes versus 68

640
00:22:32,880 --> 00:22:34,400
but we found that for success rates

641
00:22:34,400 --> 00:22:36,080
above 25 the

642
00:22:36,080 --> 00:22:37,840
partitioning oracle attack requires a

643
00:22:37,840 --> 00:22:40,080
less total bandwidth and brute force

644
00:22:40,080 --> 00:22:42,000
mostly because it requires far fewer

645
00:22:42,000 --> 00:22:44,480
queries

646
00:22:45,919 --> 00:22:48,080
we also implemented a proof of concept

647
00:22:48,080 --> 00:22:49,520
of the attack

648
00:22:49,520 --> 00:22:51,679
for our malicious client we used a linux

649
00:22:51,679 --> 00:22:54,320
desktop for the pre-computation phase

650
00:22:54,320 --> 00:22:56,880
and an ubutu ec2 micro instance for the

651
00:22:56,880 --> 00:22:58,480
acquiring phase

652
00:22:58,480 --> 00:23:00,240
for the shadow sock server we used

653
00:23:00,240 --> 00:23:02,480
another ec2 instance running go shadow

654
00:23:02,480 --> 00:23:04,320
socks 2.

655
00:23:04,320 --> 00:23:07,600
our pre-computation phase took 33 hours

656
00:23:07,600 --> 00:23:09,840
to find 200 password sets

657
00:23:09,840 --> 00:23:13,039
and 92 minutes to compute 200 mkcr

658
00:23:13,039 --> 00:23:14,799
ciphertexts

659
00:23:14,799 --> 00:23:17,440
for finding these 200 password sets it

660
00:23:17,440 --> 00:23:19,360
requires encrypting a byte for every

661
00:23:19,360 --> 00:23:20,080
password

662
00:23:20,080 --> 00:23:22,559
200 times and since our dictionary has

663
00:23:22,559 --> 00:23:25,039
188 million passwords

664
00:23:25,039 --> 00:23:28,559
this is a total of 188 million times 200

665
00:23:28,559 --> 00:23:31,200
encryptions you can of course optimize

666
00:23:31,200 --> 00:23:32,559
this by parallel

667
00:23:32,559 --> 00:23:34,960
parallelizing these computations or

668
00:23:34,960 --> 00:23:36,000
limiting the dictionary

669
00:23:36,000 --> 00:23:38,559
to some smaller set of more probable

670
00:23:38,559 --> 00:23:40,240
passwords

671
00:23:40,240 --> 00:23:42,080
our querying phase was much faster

672
00:23:42,080 --> 00:23:43,600
sending 200 cypher texts

673
00:23:43,600 --> 00:23:45,520
in 20 seconds which took about 13

674
00:23:45,520 --> 00:23:47,039
megabytes of bandwidth

675
00:23:47,039 --> 00:23:49,679
the port scan took 97 seconds and about

676
00:23:49,679 --> 00:23:52,000
1.36 megabytes of bandwidth

677
00:23:52,000 --> 00:23:54,720
and finally trial decrypting took about

678
00:23:54,720 --> 00:23:57,200
a minute

679
00:23:58,159 --> 00:24:00,000
so to wrap up our case study on shadow

680
00:24:00,000 --> 00:24:02,240
socks we disclosed this attack to the

681
00:24:02,240 --> 00:24:04,720
shadow sox developers who disabled udp

682
00:24:04,720 --> 00:24:07,200
proxying were enabled by default

683
00:24:07,200 --> 00:24:09,919
while we found an attack for udp traffic

684
00:24:09,919 --> 00:24:11,760
our attack does not work for tcp

685
00:24:11,760 --> 00:24:14,320
because the tcp protocol requires

686
00:24:14,320 --> 00:24:15,919
finding a multicollision for

687
00:24:15,919 --> 00:24:18,480
smaller than a block of cipher text this

688
00:24:18,480 --> 00:24:20,640
is an open problem

689
00:24:20,640 --> 00:24:22,240
the brute force dictionary attack is

690
00:24:22,240 --> 00:24:23,840
damaging as well but

691
00:24:23,840 --> 00:24:25,760
the partitioning oracle's attack or

692
00:24:25,760 --> 00:24:28,640
fares better in query limited settings

693
00:24:28,640 --> 00:24:30,799
this is really a great example of how

694
00:24:30,799 --> 00:24:32,480
partitioning oracle attacks arise in

695
00:24:32,480 --> 00:24:35,039
practice

696
00:24:35,520 --> 00:24:37,760
we'll now cover our second case study

697
00:24:37,760 --> 00:24:39,440
which is opaque

698
00:24:39,440 --> 00:24:42,559
opaque was selected by the ietf cfrg for

699
00:24:42,559 --> 00:24:44,080
standardization

700
00:24:44,080 --> 00:24:45,919
it's meant to replace existing password

701
00:24:45,919 --> 00:24:48,400
authentication protocols on the web

702
00:24:48,400 --> 00:24:51,039
it composes an oblivious pseudorandom

703
00:24:51,039 --> 00:24:52,799
function or oprf

704
00:24:52,799 --> 00:24:56,159
with a committing aeid

705
00:24:56,159 --> 00:24:58,480
here we'll show how the scheme becomes

706
00:24:58,480 --> 00:25:00,240
vulnerable when not using a committing

707
00:25:00,240 --> 00:25:01,440
aad scheme

708
00:25:01,440 --> 00:25:02,960
and how we found that many early

709
00:25:02,960 --> 00:25:04,880
implementations in fact did not

710
00:25:04,880 --> 00:25:07,760
use a committing aad scheme opening

711
00:25:07,760 --> 00:25:11,520
themselves up to these vulnerabilities

712
00:25:12,159 --> 00:25:13,600
we'll provide a quick overview of the

713
00:25:13,600 --> 00:25:15,679
protocol from the original paper

714
00:25:15,679 --> 00:25:17,360
the protocol and the standardization

715
00:25:17,360 --> 00:25:19,840
draft has since been modified

716
00:25:19,840 --> 00:25:22,080
so during registration the server

717
00:25:22,080 --> 00:25:24,320
computes the aad encryption key from the

718
00:25:24,320 --> 00:25:26,559
password using the oprf

719
00:25:26,559 --> 00:25:29,600
it then encrypts the keys using the aad

720
00:25:29,600 --> 00:25:32,399
encryption key

721
00:25:32,640 --> 00:25:35,200
now during login the client sends its

722
00:25:35,200 --> 00:25:38,240
own opr values and its user id to the

723
00:25:38,240 --> 00:25:39,760
server

724
00:25:39,760 --> 00:25:41,120
the server retrieves the correct

725
00:25:41,120 --> 00:25:43,919
ciphertext computes a symmetric

726
00:25:43,919 --> 00:25:46,799
session key from the using the opr

727
00:25:46,799 --> 00:25:47,440
values

728
00:25:47,440 --> 00:25:49,279
and then computes a special key check

729
00:25:49,279 --> 00:25:50,880
value which is a

730
00:25:50,880 --> 00:25:53,919
prf evaluation of the user id using the

731
00:25:53,919 --> 00:25:56,960
session key

732
00:25:56,960 --> 00:25:59,679
now the server sends the opr values

733
00:25:59,679 --> 00:26:00,559
ciphertext

734
00:26:00,559 --> 00:26:03,679
and a key check value to the client

735
00:26:03,679 --> 00:26:05,760
the client computes the aeid encryption

736
00:26:05,760 --> 00:26:07,039
key from its password

737
00:26:07,039 --> 00:26:09,679
and then tries decrypting the ciphertext

738
00:26:09,679 --> 00:26:11,039
decryption fails

739
00:26:11,039 --> 00:26:14,159
the client aborts next the client

740
00:26:14,159 --> 00:26:15,200
computes the sec

741
00:26:15,200 --> 00:26:17,600
the session key assuming that decryption

742
00:26:17,600 --> 00:26:18,880
succeeded

743
00:26:18,880 --> 00:26:21,039
it computes the key check value and

744
00:26:21,039 --> 00:26:22,640
verifies that this message that this

745
00:26:22,640 --> 00:26:25,360
matches what the server sent

746
00:26:25,360 --> 00:26:27,600
if the keycheck value does not match

747
00:26:27,600 --> 00:26:29,760
then the client aborts

748
00:26:29,760 --> 00:26:31,679
as i've said this protocol specifies

749
00:26:31,679 --> 00:26:32,880
that it needs to use

750
00:26:32,880 --> 00:26:35,919
a committing aad scheme so what happens

751
00:26:35,919 --> 00:26:36,400
if we

752
00:26:36,400 --> 00:26:40,320
do not use a committing aead scheme

753
00:26:40,640 --> 00:26:42,559
well we can build a partitioning oracle

754
00:26:42,559 --> 00:26:43,919
attack here

755
00:26:43,919 --> 00:26:46,159
unlike the shadow sox attack where the

756
00:26:46,159 --> 00:26:48,080
attacker posed as a malicious client

757
00:26:48,080 --> 00:26:50,240
in this attack the attacker impersonates

758
00:26:50,240 --> 00:26:51,360
a server

759
00:26:51,360 --> 00:26:53,200
and the goal is to recover the password

760
00:26:53,200 --> 00:26:56,400
from some honest client

761
00:26:56,400 --> 00:26:58,000
so the heat so here the attacker

762
00:26:58,000 --> 00:26:59,840
computes a key multi-collision cipher

763
00:26:59,840 --> 00:27:00,320
text

764
00:27:00,320 --> 00:27:02,960
and then chooses some opr values and a

765
00:27:02,960 --> 00:27:04,840
random key check value to send to the

766
00:27:04,840 --> 00:27:06,880
client

767
00:27:06,880 --> 00:27:08,880
the client uses its password to derive

768
00:27:08,880 --> 00:27:10,000
the aad key

769
00:27:10,000 --> 00:27:13,679
and tries to decrypt the ciphertext

770
00:27:13,679 --> 00:27:15,440
notice that there are two places in the

771
00:27:15,440 --> 00:27:17,760
protocol where the attacker where the

772
00:27:17,760 --> 00:27:19,440
client might abort

773
00:27:19,440 --> 00:27:21,520
the first abort tells the attacker that

774
00:27:21,520 --> 00:27:23,840
decryption failed

775
00:27:23,840 --> 00:27:25,840
and the client's password wasn't in the

776
00:27:25,840 --> 00:27:27,360
set of passwords the attacker was

777
00:27:27,360 --> 00:27:28,320
checking

778
00:27:28,320 --> 00:27:29,760
while the second abort tells the

779
00:27:29,760 --> 00:27:31,760
attacker that decryption succeeded

780
00:27:31,760 --> 00:27:34,960
and the password was in that set so we

781
00:27:34,960 --> 00:27:36,799
will get a partitioning oracle here if

782
00:27:36,799 --> 00:27:38,559
we can distinguish between these two

783
00:27:38,559 --> 00:27:42,159
boards for instance if an implementation

784
00:27:42,159 --> 00:27:42,640
were to

785
00:27:42,640 --> 00:27:44,720
emit distinct errors this would make it

786
00:27:44,720 --> 00:27:46,960
very easy for an attacker to determine

787
00:27:46,960 --> 00:27:48,640
whether a particular splitting cypher

788
00:27:48,640 --> 00:27:50,480
text was successfully decrypted

789
00:27:50,480 --> 00:27:53,440
or not now it's important to note that

790
00:27:53,440 --> 00:27:54,720
the opaque protocol

791
00:27:54,720 --> 00:27:56,880
does make clear that a committing aid

792
00:27:56,880 --> 00:27:58,720
scheme should be used

793
00:27:58,720 --> 00:28:00,799
which would prevent this attack and make

794
00:28:00,799 --> 00:28:02,480
all this move point

795
00:28:02,480 --> 00:28:04,480
however when we looked into early

796
00:28:04,480 --> 00:28:06,000
implementations of opaque

797
00:28:06,000 --> 00:28:09,600
we found that many did not do this

798
00:28:09,600 --> 00:28:11,440
here we have a summary of these early

799
00:28:11,440 --> 00:28:13,440
library implementations

800
00:28:13,440 --> 00:28:16,159
we found that five out of the nine

801
00:28:16,159 --> 00:28:17,440
implementations

802
00:28:17,440 --> 00:28:20,240
used a non-committing aad scheme despite

803
00:28:20,240 --> 00:28:24,080
the opaque author's specifications

804
00:28:24,080 --> 00:28:26,320
a third of the implementations opted to

805
00:28:26,320 --> 00:28:28,960
use the sodium default aad scheme

806
00:28:28,960 --> 00:28:32,240
which is non-committing and is x also 20

807
00:28:32,240 --> 00:28:34,960
1305

808
00:28:35,279 --> 00:28:37,600
and importantly three out of five of the

809
00:28:37,600 --> 00:28:40,240
vulnerable implementations emit distinct

810
00:28:40,240 --> 00:28:42,159
explicit error messages during

811
00:28:42,159 --> 00:28:43,520
decryption

812
00:28:43,520 --> 00:28:44,720
as we noted this would make the

813
00:28:44,720 --> 00:28:46,799
attacker's job very easy in determining

814
00:28:46,799 --> 00:28:48,399
whether a splitting cycle text was

815
00:28:48,399 --> 00:28:50,799
successfully decrypted or not

816
00:28:50,799 --> 00:28:53,840
but of course the question is then

817
00:28:53,840 --> 00:28:55,600
is the attack still possible even

818
00:28:55,600 --> 00:28:59,520
without these distinct error messages

819
00:28:59,520 --> 00:29:01,200
the short answer is that we found that a

820
00:29:01,200 --> 00:29:03,440
timing channel from an early abort

821
00:29:03,440 --> 00:29:06,720
could be exploitable more specifically

822
00:29:06,720 --> 00:29:08,720
to measure this we use the opaque

823
00:29:08,720 --> 00:29:10,640
implementation lip sphinx

824
00:29:10,640 --> 00:29:12,399
and perform timing experiments on a

825
00:29:12,399 --> 00:29:14,720
macbook pro with the static one megabyte

826
00:29:14,720 --> 00:29:16,480
cipher text

827
00:29:16,480 --> 00:29:18,799
we timed a thousand trials each of the

828
00:29:18,799 --> 00:29:20,640
of the decryption failure versus the key

829
00:29:20,640 --> 00:29:23,279
check failure

830
00:29:24,000 --> 00:29:27,840
to measure the

831
00:29:28,080 --> 00:29:30,240
we found that the median and mean time

832
00:29:30,240 --> 00:29:33,600
for the decryption failure was 119

833
00:29:33,600 --> 00:29:35,520
milliseconds and the median and mean

834
00:29:35,520 --> 00:29:36,960
time for the key check failure

835
00:29:36,960 --> 00:29:40,080
was 124 milliseconds so

836
00:29:40,080 --> 00:29:42,240
this shows that remote timing attacks

837
00:29:42,240 --> 00:29:43,360
could be feasible

838
00:29:43,360 --> 00:29:45,200
though more queries could be necessary

839
00:29:45,200 --> 00:29:48,080
to reduce noise

840
00:29:48,559 --> 00:29:50,640
to measure the efficacy of our attack we

841
00:29:50,640 --> 00:29:53,360
again perform success rate simulations

842
00:29:53,360 --> 00:29:55,039
the graph on the left shows the number

843
00:29:55,039 --> 00:29:57,279
of queries versus the success rate for

844
00:29:57,279 --> 00:29:58,880
various values of k

845
00:29:58,880 --> 00:30:00,480
which is the number of passwords we can

846
00:30:00,480 --> 00:30:02,399
check for each query

847
00:30:02,399 --> 00:30:05,200
it shows that unsurprisingly the greater

848
00:30:05,200 --> 00:30:06,399
the value of k

849
00:30:06,399 --> 00:30:08,000
the greater the success rate we can

850
00:30:08,000 --> 00:30:10,480
achieve with fewer queries

851
00:30:10,480 --> 00:30:12,480
more specifically the table at the right

852
00:30:12,480 --> 00:30:13,520
shows the max

853
00:30:13,520 --> 00:30:15,600
the maximum total bandwidth and the

854
00:30:15,600 --> 00:30:17,360
number of queries needed to guarantee a

855
00:30:17,360 --> 00:30:18,000
20

856
00:30:18,000 --> 00:30:21,120
success rate for various values of k you

857
00:30:21,120 --> 00:30:22,000
can see that for k

858
00:30:22,000 --> 00:30:24,880
equals one you need a total bandwidth of

859
00:30:24,880 --> 00:30:26,640
one megabyte

860
00:30:26,640 --> 00:30:28,960
but you need over 60 000 queries to

861
00:30:28,960 --> 00:30:30,000
achieve a 20

862
00:30:30,000 --> 00:30:33,360
chance of success however for k equals 2

863
00:30:33,360 --> 00:30:34,559
to the 14

864
00:30:34,559 --> 00:30:36,799
you need a total bandwidth of 1.5

865
00:30:36,799 --> 00:30:38,000
megabytes

866
00:30:38,000 --> 00:30:40,240
but you can achieve a 20 chance of

867
00:30:40,240 --> 00:30:43,120
success with only 18 queries

868
00:30:43,120 --> 00:30:45,679
interestingly we found that k equals 2

869
00:30:45,679 --> 00:30:46,640
to the 10

870
00:30:46,640 --> 00:30:48,480
required even less bandwidth than k

871
00:30:48,480 --> 00:30:51,200
equals 1 owing to smaller ciphertext

872
00:30:51,200 --> 00:30:55,279
size in combination with viewer queries

873
00:30:56,240 --> 00:30:58,480
the opaque internet draft has been

874
00:30:58,480 --> 00:31:00,480
updated and specified in

875
00:31:00,480 --> 00:31:02,399
and now specifies an ad hoc committing

876
00:31:02,399 --> 00:31:04,240
aad scheme

877
00:31:04,240 --> 00:31:06,000
in summary this is an interesting case

878
00:31:06,000 --> 00:31:07,919
study that shows how partitioning oracle

879
00:31:07,919 --> 00:31:08,480
attacks

880
00:31:08,480 --> 00:31:12,159
could have arisen in this setting

881
00:31:15,200 --> 00:31:17,600
so while the evidence i presented on

882
00:31:17,600 --> 00:31:19,200
partitioning oracle texts

883
00:31:19,200 --> 00:31:22,159
shows how vulnerabilities stem from

884
00:31:22,159 --> 00:31:23,519
non-committing aad

885
00:31:23,519 --> 00:31:26,799
it's by no means the only evidence

886
00:31:26,799 --> 00:31:28,399
we found that there were other possible

887
00:31:28,399 --> 00:31:30,559
partitioning out partitioning oracles

888
00:31:30,559 --> 00:31:31,519
out there as well

889
00:31:31,519 --> 00:31:33,519
including the hybrid public key

890
00:31:33,519 --> 00:31:35,279
encryption scheme the algae file

891
00:31:35,279 --> 00:31:36,559
encryption tool

892
00:31:36,559 --> 00:31:38,960
kerberos straps which were not adopted

893
00:31:38,960 --> 00:31:41,600
javascript object signing and encryption

894
00:31:41,600 --> 00:31:44,159
as well as anonymity systems which could

895
00:31:44,159 --> 00:31:46,240
use partitioning oracles to learn which

896
00:31:46,240 --> 00:31:46,880
public key

897
00:31:46,880 --> 00:31:49,360
a recipient is using from a set of known

898
00:31:49,360 --> 00:31:52,000
public keys

899
00:31:52,000 --> 00:31:54,880
also as i mentioned previously grub zero

900
00:31:54,880 --> 00:31:55,600
and dota

901
00:31:55,600 --> 00:31:57,760
found that committing aad was vital in

902
00:31:57,760 --> 00:31:59,600
content moderation schemes

903
00:31:59,600 --> 00:32:02,399
like message franking and more recently

904
00:32:02,399 --> 00:32:04,480
albertini had all found that

905
00:32:04,480 --> 00:32:06,320
various services offered by google and

906
00:32:06,320 --> 00:32:08,399
amazon had vulnerabilities due to not

907
00:32:08,399 --> 00:32:10,960
using committing aad schemes

908
00:32:10,960 --> 00:32:12,640
one difference here however is that

909
00:32:12,640 --> 00:32:14,559
these vulnerabilities affected message

910
00:32:14,559 --> 00:32:15,600
integrity

911
00:32:15,600 --> 00:32:17,440
while partitioning oracle attacks do

912
00:32:17,440 --> 00:32:20,880
affect confidentiality

913
00:32:21,840 --> 00:32:23,679
so now that we've covered where

914
00:32:23,679 --> 00:32:24,960
partitioning oracles

915
00:32:24,960 --> 00:32:28,000
rise we need to consider

916
00:32:28,000 --> 00:32:31,600
what to do about all this ultimately our

917
00:32:31,600 --> 00:32:33,360
paper is the latest in a growing body of

918
00:32:33,360 --> 00:32:35,519
evidence that non-committing aad can

919
00:32:35,519 --> 00:32:37,360
lead to vulnerabilities

920
00:32:37,360 --> 00:32:38,960
this tells us that we should transition

921
00:32:38,960 --> 00:32:40,720
to using committing aeid

922
00:32:40,720 --> 00:32:43,600
as a default but when we ask which

923
00:32:43,600 --> 00:32:44,559
scheme to use

924
00:32:44,559 --> 00:32:47,120
this is currently difficult to answer no

925
00:32:47,120 --> 00:32:48,799
scheme is standardized

926
00:32:48,799 --> 00:32:50,880
so really this all tells us that we need

927
00:32:50,880 --> 00:32:52,880
a committing aad standard

928
00:32:52,880 --> 00:32:54,840
and it should be the default choice for

929
00:32:54,840 --> 00:32:57,840
aeid

930
00:32:58,559 --> 00:33:00,720
to conclude we described partitioning

931
00:33:00,720 --> 00:33:01,760
oracle attacks

932
00:33:01,760 --> 00:33:04,080
which exploit non-committing aad to

933
00:33:04,080 --> 00:33:05,760
recover secrets

934
00:33:05,760 --> 00:33:07,919
we talked about how widely used aid

935
00:33:07,919 --> 00:33:10,000
schemes are not committing

936
00:33:10,000 --> 00:33:11,679
and we showed that partitioning oracle

937
00:33:11,679 --> 00:33:13,600
tax can be used to recover passwords

938
00:33:13,600 --> 00:33:15,279
from tools and protocols used in

939
00:33:15,279 --> 00:33:16,799
practice

940
00:33:16,799 --> 00:33:19,200
finally our recommendation is to design

941
00:33:19,200 --> 00:33:21,120
and standardize committing aad for

942
00:33:21,120 --> 00:33:22,720
deployment

943
00:33:22,720 --> 00:33:24,559
if you have questions or want to learn

944
00:33:24,559 --> 00:33:26,720
more i have my email on the slide

945
00:33:26,720 --> 00:33:28,399
as well as a link to the full version of

946
00:33:28,399 --> 00:33:29,840
the paper

947
00:33:29,840 --> 00:33:31,679
and i would like to thank my co-authors

948
00:33:31,679 --> 00:33:33,360
as well as those who provided helpful

949
00:33:33,360 --> 00:33:35,120
feedback on our paper

950
00:33:35,120 --> 00:33:36,640
thank you for your time and i look

951
00:33:36,640 --> 00:33:43,600
forward to answering your questions

