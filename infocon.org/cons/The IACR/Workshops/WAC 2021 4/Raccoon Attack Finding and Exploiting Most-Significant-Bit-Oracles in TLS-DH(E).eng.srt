1
00:00:00,000 --> 00:00:02,320
hi my name is robert merget and today

2
00:00:02,320 --> 00:00:03,520
i'm here to present you a long version

3
00:00:03,520 --> 00:00:05,040
of our talk to the raccoon attack

4
00:00:05,040 --> 00:00:06,560
finding and exploiting most significant

5
00:00:06,560 --> 00:00:08,720
bit oracles in tls dhe

6
00:00:08,720 --> 00:00:10,320
visit this joint research effort with

7
00:00:10,320 --> 00:00:11,920
marcus springmann nemour aveeram

8
00:00:11,920 --> 00:00:13,679
jurassoski johannes mittman

9
00:00:13,679 --> 00:00:17,199
and yorkshvink so for this audience i

10
00:00:17,199 --> 00:00:18,480
don't think tls needs much of an

11
00:00:18,480 --> 00:00:19,920
introduction he has probably the most

12
00:00:19,920 --> 00:00:22,160
used cryptographic protocol in the world

13
00:00:22,160 --> 00:00:25,920
but let's quickly recap how tls works

14
00:00:25,920 --> 00:00:28,320
so in tls the client initiates a

15
00:00:28,320 --> 00:00:30,000
connection and it sends a client hello

16
00:00:30,000 --> 00:00:31,599
message which contains nonsense and

17
00:00:31,599 --> 00:00:32,558
cryptographic

18
00:00:32,558 --> 00:00:33,920
algorithms which are supported by the

19
00:00:33,920 --> 00:00:36,079
client and the highest supported version

20
00:00:36,079 --> 00:00:37,840
from a client to the server

21
00:00:37,840 --> 00:00:39,440
server wren selects the algorithms which

22
00:00:39,440 --> 00:00:40,960
are used for connection and

23
00:00:40,960 --> 00:00:43,920
sends a nonsense back when a tlsdf

24
00:00:43,920 --> 00:00:44,719
german cypher

25
00:00:44,719 --> 00:00:46,160
is selected which is important for his

26
00:00:46,160 --> 00:00:47,840
talk the server

27
00:00:47,840 --> 00:00:50,960
also chooses private key and computes

28
00:00:50,960 --> 00:00:54,800
a public key g2 power of b mod p and

29
00:00:54,800 --> 00:00:56,640
sends the different power images and

30
00:00:56,640 --> 00:00:59,440
signature to the client

31
00:00:59,440 --> 00:01:01,680
client then choose its own private key

32
00:01:01,680 --> 00:01:03,440
and computes its own public key g to

33
00:01:03,440 --> 00:01:04,400
power of a

34
00:01:04,400 --> 00:01:06,159
and then both parties can compute the

35
00:01:06,159 --> 00:01:08,720
shared secret g to power of a b

36
00:01:08,720 --> 00:01:10,479
and with that both parties can also

37
00:01:10,479 --> 00:01:12,240
derive a master secret

38
00:01:12,240 --> 00:01:14,799
by inserting the shared sequential power

39
00:01:14,799 --> 00:01:15,360
of a b

40
00:01:15,360 --> 00:01:17,360
with a non-system to label into a solid

41
00:01:17,360 --> 00:01:18,960
random function

42
00:01:18,960 --> 00:01:21,280
and if you look at this design it looks

43
00:01:21,280 --> 00:01:23,119
actually perfectly fine so from if you

44
00:01:23,119 --> 00:01:24,080
want to proof this

45
00:01:24,080 --> 00:01:27,280
and this has already been proven before

46
00:01:27,280 --> 00:01:30,079
uh this checks perfectly fine so this

47
00:01:30,079 --> 00:01:31,360
this works

48
00:01:31,360 --> 00:01:33,840
um but in our raccoon attack we will

49
00:01:33,840 --> 00:01:35,520
take advantage of two things here

50
00:01:35,520 --> 00:01:37,280
uh which are usually not modeled in

51
00:01:37,280 --> 00:01:39,040
those cryptographic proofs

52
00:01:39,040 --> 00:01:42,079
and that is that in tls dhe leading zero

53
00:01:42,079 --> 00:01:42,960
bytes of

54
00:01:42,960 --> 00:01:44,960
the shared secret that contain all zero

55
00:01:44,960 --> 00:01:47,200
bits are stripped from the shared secret

56
00:01:47,200 --> 00:01:50,320
so if you by chance your shared

57
00:01:50,320 --> 00:01:51,439
sequencing to power a b

58
00:01:51,439 --> 00:01:54,079
starts with a zero zero zero zero zero

59
00:01:54,079 --> 00:01:54,960
then

60
00:01:54,960 --> 00:01:56,799
this zero byte is removed before it

61
00:01:56,799 --> 00:01:58,479
enters the hash function the hash

62
00:01:58,479 --> 00:01:59,759
function works on bytes

63
00:01:59,759 --> 00:02:02,399
so um only the bytes without the zero

64
00:02:02,399 --> 00:02:02,960
bytes

65
00:02:02,960 --> 00:02:06,399
into the hash function the other effect

66
00:02:06,399 --> 00:02:07,759
we take advantage of is that some

67
00:02:07,759 --> 00:02:10,000
servers reuse very familiar keys

68
00:02:10,000 --> 00:02:12,480
so intuitively we would think that if a

69
00:02:12,480 --> 00:02:14,080
key is supposed to be ephemeral that

70
00:02:14,080 --> 00:02:15,520
reserve is only using that for one

71
00:02:15,520 --> 00:02:16,480
connection

72
00:02:16,480 --> 00:02:20,319
but in practice a lot of servers want to

73
00:02:20,319 --> 00:02:22,239
speed up their implementation so they

74
00:02:22,239 --> 00:02:24,000
want to save one exponentiation for

75
00:02:24,000 --> 00:02:25,040
every connection

76
00:02:25,040 --> 00:02:27,200
so what they do is they use the same

77
00:02:27,200 --> 00:02:29,440
public key for multiple connections

78
00:02:29,440 --> 00:02:31,680
um they do this sometimes for an hour

79
00:02:31,680 --> 00:02:33,200
sometimes only for a few minutes

80
00:02:33,200 --> 00:02:35,120
sometimes they do this till you restart

81
00:02:35,120 --> 00:02:36,640
the server so

82
00:02:36,640 --> 00:02:37,840
[Music]

83
00:02:37,840 --> 00:02:39,840
it depends really on the exact

84
00:02:39,840 --> 00:02:41,040
implementation but

85
00:02:41,040 --> 00:02:44,560
this is generally had been like a bad

86
00:02:44,560 --> 00:02:46,480
practice but there was actually no real

87
00:02:46,480 --> 00:02:47,840
reason why you shouldn't

88
00:02:47,840 --> 00:02:50,720
do this other than some theoretical

89
00:02:50,720 --> 00:02:52,080
reasons so no practical

90
00:02:52,080 --> 00:02:54,319
attack was known against servers which

91
00:02:54,319 --> 00:02:56,160
do this

92
00:02:56,160 --> 00:02:59,760
but why is this a problem so the

93
00:02:59,760 --> 00:03:04,560
tls key derivation which is used in

94
00:03:04,560 --> 00:03:06,080
is based on hash functions and these

95
00:03:06,080 --> 00:03:07,680
hash functions

96
00:03:07,680 --> 00:03:09,840
cannot operate in constant time why is

97
00:03:09,840 --> 00:03:11,840
that because their inputs

98
00:03:11,840 --> 00:03:14,879
vary in length and a hash function

99
00:03:14,879 --> 00:03:15,519
operates

100
00:03:15,519 --> 00:03:18,000
in o of n and not of one which which

101
00:03:18,000 --> 00:03:18,720
means

102
00:03:18,720 --> 00:03:20,959
um as you can imagine if you hash like a

103
00:03:20,959 --> 00:03:22,080
very long

104
00:03:22,080 --> 00:03:25,040
file or very long data it takes much

105
00:03:25,040 --> 00:03:27,200
longer when if you only hash a few bytes

106
00:03:27,200 --> 00:03:31,680
and this can create a side channel

107
00:03:31,680 --> 00:03:34,480
in the implementation when it um hashes

108
00:03:34,480 --> 00:03:36,000
the shared secret

109
00:03:36,000 --> 00:03:37,680
which is even starting with the zero

110
00:03:37,680 --> 00:03:39,440
right and therefore a little bit is a

111
00:03:39,440 --> 00:03:40,560
little bit shorter

112
00:03:40,560 --> 00:03:42,480
or it has no leading zero byte and it's

113
00:03:42,480 --> 00:03:44,239
a little bit longer this can create

114
00:03:44,239 --> 00:03:46,239
various side channels within the hash

115
00:03:46,239 --> 00:03:47,680
function like the compression number of

116
00:03:47,680 --> 00:03:49,599
compression function invocations

117
00:03:49,599 --> 00:03:51,680
the hash function if a hash function is

118
00:03:51,680 --> 00:03:52,799
invoked at all

119
00:03:52,799 --> 00:03:54,640
or on the padding inside of a hash

120
00:03:54,640 --> 00:03:57,040
function

121
00:03:58,080 --> 00:03:59,840
but now i had to talk about how this

122
00:03:59,840 --> 00:04:01,599
creates a problem so we're going to take

123
00:04:01,599 --> 00:04:03,120
a key recovery tech

124
00:04:03,120 --> 00:04:04,799
and what we do in the raccoon attack we

125
00:04:04,799 --> 00:04:07,040
have to first observe a diffie-hellman

126
00:04:07,040 --> 00:04:08,239
handshake so

127
00:04:08,239 --> 00:04:10,879
a client and server should naturally

128
00:04:10,879 --> 00:04:12,000
negotiate

129
00:04:12,000 --> 00:04:14,959
different cypher suit and perform the

130
00:04:14,959 --> 00:04:16,320
vmware connection

131
00:04:16,320 --> 00:04:17,918
once we have observed such a connection

132
00:04:17,918 --> 00:04:20,160
the attacker can

133
00:04:20,160 --> 00:04:22,720
send its own connections to the server

134
00:04:22,720 --> 00:04:24,479
where it uses g2 power of a

135
00:04:24,479 --> 00:04:26,800
which is the client public key times g

136
00:04:26,800 --> 00:04:29,040
to the power of r where r is a random

137
00:04:29,040 --> 00:04:32,240
attacker chosen number to the server

138
00:04:32,240 --> 00:04:34,479
the server will then compute g to the

139
00:04:34,479 --> 00:04:35,280
power of

140
00:04:35,280 --> 00:04:37,520
a b times g to the power of r b as the

141
00:04:37,520 --> 00:04:38,960
shared secret

142
00:04:38,960 --> 00:04:40,880
and here g to the power of a b is

143
00:04:40,880 --> 00:04:42,320
actually the shared secret of a

144
00:04:42,320 --> 00:04:42,960
connection

145
00:04:42,960 --> 00:04:44,960
the original client we want to attack

146
00:04:44,960 --> 00:04:46,479
had with a server

147
00:04:46,479 --> 00:04:48,400
which we do not know as an attacker but

148
00:04:48,400 --> 00:04:50,479
what we can do is we can compute g to

149
00:04:50,479 --> 00:04:50,960
the power of

150
00:04:50,960 --> 00:04:53,840
rb like g2 power of rs and takacho's

151
00:04:53,840 --> 00:04:55,680
number hours and take a choice number

152
00:04:55,680 --> 00:04:58,800
so attacker can compute this value what

153
00:04:58,800 --> 00:04:59,919
happens when is this

154
00:04:59,919 --> 00:05:01,680
a server will then verify the finished

155
00:05:01,680 --> 00:05:03,039
message will take a sense in its

156
00:05:03,039 --> 00:05:03,919
handshake

157
00:05:03,919 --> 00:05:05,680
and the thing is that guy doesn't know a

158
00:05:05,680 --> 00:05:07,120
shared secret so he cannot compute a

159
00:05:07,120 --> 00:05:08,639
valid finished message so what he

160
00:05:08,639 --> 00:05:10,240
does instead is he's just since

161
00:05:10,240 --> 00:05:12,720
somewhere in bytes and the server who

162
00:05:12,720 --> 00:05:14,800
wants to verify these random bytes will

163
00:05:14,800 --> 00:05:16,960
notice that this are just random bytes

164
00:05:16,960 --> 00:05:18,240
and that is not um

165
00:05:18,240 --> 00:05:20,960
a valid encrypted finished message so he

166
00:05:20,960 --> 00:05:21,360
will

167
00:05:21,360 --> 00:05:23,199
terminate the connection and respond to

168
00:05:23,199 --> 00:05:24,960
the server to the attacker with some

169
00:05:24,960 --> 00:05:26,560
alert message

170
00:05:26,560 --> 00:05:27,919
and this is totally expected by the

171
00:05:27,919 --> 00:05:29,280
attacker because what the attacker is

172
00:05:29,280 --> 00:05:30,560
actually interested in

173
00:05:30,560 --> 00:05:33,280
is measuring the time that the server

174
00:05:33,280 --> 00:05:34,080
took

175
00:05:34,080 --> 00:05:36,800
to respond to the attacker so attacker

176
00:05:36,800 --> 00:05:38,400
wants to measure the time

177
00:05:38,400 --> 00:05:41,199
um of the solar random function but he

178
00:05:41,199 --> 00:05:42,320
also has to measure some other

179
00:05:42,320 --> 00:05:44,960
computations but

180
00:05:44,960 --> 00:05:47,840
if this timing measurement is a little

181
00:05:47,840 --> 00:05:49,360
bit faster than

182
00:05:49,360 --> 00:05:51,280
usual the attacker can conclude that the

183
00:05:51,280 --> 00:05:53,360
shared secret of this g to power of a b

184
00:05:53,360 --> 00:05:56,240
g to power of rb started with a zero

185
00:05:56,240 --> 00:05:56,880
byte

186
00:05:56,880 --> 00:05:58,400
while if the computation took a little

187
00:05:58,400 --> 00:05:59,919
bit longer he can computers did not

188
00:05:59,919 --> 00:06:02,000
start with the leading zero byte

189
00:06:02,000 --> 00:06:03,919
and what the attacker can then do he can

190
00:06:03,919 --> 00:06:05,199
repeat the same

191
00:06:05,199 --> 00:06:07,039
process multiple times for different

192
00:06:07,039 --> 00:06:08,720
values of r so

193
00:06:08,720 --> 00:06:10,560
he does lots of connections and he

194
00:06:10,560 --> 00:06:12,560
measures for all of them um

195
00:06:12,560 --> 00:06:14,319
if their the shared secrets start with

196
00:06:14,319 --> 00:06:15,600
zero right or not

197
00:06:15,600 --> 00:06:18,840
and once he has enough of these

198
00:06:18,840 --> 00:06:21,280
equations he can construct an instance

199
00:06:21,280 --> 00:06:22,880
of a hidden number problem

200
00:06:22,880 --> 00:06:27,919
which is a famous um cryptographic

201
00:06:27,919 --> 00:06:30,160
problem by which was initially uh

202
00:06:30,160 --> 00:06:33,680
discovered and solved by den bonnet

203
00:06:33,680 --> 00:06:37,039
uh his group and

204
00:06:37,039 --> 00:06:38,720
uh if you solve a hidden number problem

205
00:06:38,720 --> 00:06:40,479
you can actually compute g to the power

206
00:06:40,479 --> 00:06:42,000
of a b

207
00:06:42,000 --> 00:06:44,160
so you actually get the shared secret uh

208
00:06:44,160 --> 00:06:45,360
out of it

209
00:06:45,360 --> 00:06:48,479
and this is quite bad for the and for

210
00:06:48,479 --> 00:06:49,199
the server

211
00:06:49,199 --> 00:06:51,919
and for the client so solving this

212
00:06:51,919 --> 00:06:53,520
hidden number problem is not very

213
00:06:53,520 --> 00:06:56,720
easy so you need lots of equations so

214
00:06:56,720 --> 00:06:59,840
um if you leak one byte per

215
00:06:59,840 --> 00:07:03,440
connection which is k equal to 8

216
00:07:03,440 --> 00:07:05,520
this means that you need around 200

217
00:07:05,520 --> 00:07:07,360
equation systems

218
00:07:07,360 --> 00:07:12,160
so and around two and a half hours

219
00:07:12,160 --> 00:07:14,960
to compute the shared secret if you are

220
00:07:14,960 --> 00:07:16,080
in a position where you get

221
00:07:16,080 --> 00:07:19,599
more um more leading zero bits which

222
00:07:19,599 --> 00:07:20,800
might be because you measure the

223
00:07:20,800 --> 00:07:22,000
difference between

224
00:07:22,000 --> 00:07:23,520
two leading zero bytes and one leading

225
00:07:23,520 --> 00:07:25,759
zero bytes you can use less equations

226
00:07:25,759 --> 00:07:26,160
but

227
00:07:26,160 --> 00:07:27,759
and you get less computation time but

228
00:07:27,759 --> 00:07:29,599
you will probably need to measure a lot

229
00:07:29,599 --> 00:07:31,840
more

230
00:07:32,639 --> 00:07:35,440
and also it depends on the length of a

231
00:07:35,440 --> 00:07:37,360
diffie-hellman parameter so

232
00:07:37,360 --> 00:07:39,280
this was what i was talking about was

233
00:07:39,280 --> 00:07:41,280
for 1024 bits

234
00:07:41,280 --> 00:07:43,840
and it might take longer if you have

235
00:07:43,840 --> 00:07:44,720
longer

236
00:07:44,720 --> 00:07:48,160
a longer module and

237
00:07:48,160 --> 00:07:51,599
the 2048 bits module we were not able to

238
00:07:51,599 --> 00:07:52,800
solve actually with

239
00:07:52,800 --> 00:07:54,960
eight bit leaks so we for those cases we

240
00:07:54,960 --> 00:07:55,840
need

241
00:07:55,840 --> 00:07:59,520
more um more bits leaked so you have to

242
00:07:59,520 --> 00:08:00,800
differentiate between

243
00:08:00,800 --> 00:08:02,560
two leading zero bytes or one leading

244
00:08:02,560 --> 00:08:04,080
zero byte which is also possible

245
00:08:04,080 --> 00:08:05,599
for the current attack but requires a

246
00:08:05,599 --> 00:08:07,520
lot more computations uh measurements

247
00:08:07,520 --> 00:08:08,240
because

248
00:08:08,240 --> 00:08:10,080
obviously two leading zero bytes are

249
00:08:10,080 --> 00:08:12,000
less likely to happen when just single

250
00:08:12,000 --> 00:08:14,639
leading zero byte

251
00:08:14,639 --> 00:08:16,800
so we were not able to solve the case

252
00:08:16,800 --> 00:08:17,840
for k

253
00:08:17,840 --> 00:08:20,080
equal to eight so eight bit soft um but

254
00:08:20,080 --> 00:08:21,280
we do not

255
00:08:21,280 --> 00:08:23,520
um so it might still be possible it just

256
00:08:23,520 --> 00:08:27,840
means we were not able to do this

257
00:08:27,840 --> 00:08:29,680
from an attacker's point of view it is

258
00:08:29,680 --> 00:08:31,440
now interesting to optimize for side

259
00:08:31,440 --> 00:08:33,360
channels so as i said the difference is

260
00:08:33,360 --> 00:08:36,320
only a single byte or maybe two bytes

261
00:08:36,320 --> 00:08:38,000
in the different length of a hash

262
00:08:38,000 --> 00:08:39,919
function input so it would be great if

263
00:08:39,919 --> 00:08:41,599
we could optimize with such and so it

264
00:08:41,599 --> 00:08:44,000
gets a little bit bigger

265
00:08:44,000 --> 00:08:46,160
so to do this we have to look at the

266
00:08:46,160 --> 00:08:48,160
keto organizations functions within tls

267
00:08:48,160 --> 00:08:49,760
and if we do that we see that there are

268
00:08:49,760 --> 00:08:51,440
three different constructions

269
00:08:51,440 --> 00:08:54,320
ss3 which is the oldest tls protocol i

270
00:08:54,320 --> 00:08:56,000
used the custom function based on sha 1

271
00:08:56,000 --> 00:08:57,040
and md5

272
00:08:57,040 --> 00:09:01,120
it has 1.1 and 1 0 used observe random

273
00:09:01,120 --> 00:09:03,040
function which was based on sha 1 and

274
00:09:03,040 --> 00:09:04,399
md5 hmag

275
00:09:04,399 --> 00:09:06,959
and ts103 use similar design based on

276
00:09:06,959 --> 00:09:08,920
sha 256 or sha

277
00:09:08,920 --> 00:09:11,920
384

278
00:09:12,160 --> 00:09:14,399
obvious constructions use hash functions

279
00:09:14,399 --> 00:09:15,600
internally

280
00:09:15,600 --> 00:09:18,000
and if you look at a hash function which

281
00:09:18,000 --> 00:09:19,760
can be used here like me five share one

282
00:09:19,760 --> 00:09:23,120
or sha 256 or cr384 they all use america

283
00:09:23,120 --> 00:09:24,480
damn guard construction

284
00:09:24,480 --> 00:09:26,240
and with macadam construct construction

285
00:09:26,240 --> 00:09:28,160
what you do is you

286
00:09:28,160 --> 00:09:29,839
splice your input into multiples of a

287
00:09:29,839 --> 00:09:31,760
block length and

288
00:09:31,760 --> 00:09:35,040
you add padding to your input and also a

289
00:09:35,040 --> 00:09:37,200
length field is added which tells

290
00:09:37,200 --> 00:09:38,800
which marks basically how long the

291
00:09:38,800 --> 00:09:40,399
actual input was

292
00:09:40,399 --> 00:09:42,560
and then each block enters a compression

293
00:09:42,560 --> 00:09:44,560
function and is then mixed with the next

294
00:09:44,560 --> 00:09:45,040
block

295
00:09:45,040 --> 00:09:47,680
within the compression function until a

296
00:09:47,680 --> 00:09:48,720
final step

297
00:09:48,720 --> 00:09:52,320
cures and the hash is outputted so

298
00:09:52,320 --> 00:09:54,880
if we imagine how this hash function

299
00:09:54,880 --> 00:09:56,399
performance looks in this macadam good

300
00:09:56,399 --> 00:09:57,600
construction

301
00:09:57,600 --> 00:09:59,600
is that it's like a staircase figure so

302
00:09:59,600 --> 00:10:01,680
whenever you need another block

303
00:10:01,680 --> 00:10:04,000
then you will have a spike in the

304
00:10:04,000 --> 00:10:05,519
execution time

305
00:10:05,519 --> 00:10:09,279
and the more blocks you had the more

306
00:10:09,279 --> 00:10:12,480
stairs you get in your staircase so from

307
00:10:12,480 --> 00:10:13,519
attackers point of view

308
00:10:13,519 --> 00:10:16,320
it is very advantageous if the attacker

309
00:10:16,320 --> 00:10:17,360
can be

310
00:10:17,360 --> 00:10:20,720
right at the yeah at the staircase so

311
00:10:20,720 --> 00:10:23,360
if like the input is a bite longer then

312
00:10:23,360 --> 00:10:23,839
it's

313
00:10:23,839 --> 00:10:25,519
up here and if the bite is a little bit

314
00:10:25,519 --> 00:10:27,360
shorter it's down here so this is like

315
00:10:27,360 --> 00:10:28,320
the optimal case for

316
00:10:28,320 --> 00:10:32,480
a tekken so looking at md3

317
00:10:32,480 --> 00:10:35,839
uh ss3 there are multiple um

318
00:10:35,839 --> 00:10:38,480
possibilities for the attacker to get

319
00:10:38,480 --> 00:10:39,760
close to this border so

320
00:10:39,760 --> 00:10:41,040
what's happening here is the shared

321
00:10:41,040 --> 00:10:43,920
secret is concatenated within md5

322
00:10:43,920 --> 00:10:46,959
with sha-1 so the shared secret plus 20

323
00:10:46,959 --> 00:10:48,640
bytes from the sha one output

324
00:10:48,640 --> 00:10:51,680
uh inside an md5 computation so

325
00:10:51,680 --> 00:10:53,519
this depending on the modulus size was

326
00:10:53,519 --> 00:10:55,600
already might already bring you to the

327
00:10:55,600 --> 00:10:58,880
um to the block border

328
00:10:58,880 --> 00:11:00,959
and also there are three different

329
00:11:00,959 --> 00:11:02,720
internal sha-1 computations so what's

330
00:11:02,720 --> 00:11:04,160
happening here is there's a g

331
00:11:04,160 --> 00:11:06,320
to power of a b which is the shared

332
00:11:06,320 --> 00:11:08,399
secret which is concatenated with

333
00:11:08,399 --> 00:11:11,040
the letter ascii a like a literally one

334
00:11:11,040 --> 00:11:11,440
byte

335
00:11:11,440 --> 00:11:14,800
af in 0x41

336
00:11:14,800 --> 00:11:16,560
concatenated with a client nonsense

337
00:11:16,560 --> 00:11:19,200
server nones which are 32 bytes each

338
00:11:19,200 --> 00:11:21,040
and you have three different ones so

339
00:11:21,040 --> 00:11:22,880
what you do in the you can contain it

340
00:11:22,880 --> 00:11:24,640
with output with another um

341
00:11:24,640 --> 00:11:28,000
md5 sha1 computation where you have bb

342
00:11:28,000 --> 00:11:30,000
which is two ascii characters so it

343
00:11:30,000 --> 00:11:31,600
basically adds another

344
00:11:31,600 --> 00:11:34,079
byte to this internal sha-1 computation

345
00:11:34,079 --> 00:11:35,200
so you get an other

346
00:11:35,200 --> 00:11:36,800
shift which brings into closer to the

347
00:11:36,800 --> 00:11:38,399
staircase and

348
00:11:38,399 --> 00:11:40,480
in the last computation you do it with

349
00:11:40,480 --> 00:11:41,519
ccc which is

350
00:11:41,519 --> 00:11:44,560
also two two more bytes which might also

351
00:11:44,560 --> 00:11:45,920
bring you to

352
00:11:45,920 --> 00:11:49,120
the staircase so you got four different

353
00:11:49,120 --> 00:11:50,959
offsets here

354
00:11:50,959 --> 00:11:53,200
where the shared secret might bring it

355
00:11:53,200 --> 00:11:54,959
to a staircase

356
00:11:54,959 --> 00:11:58,959
depending on the modular size for ts 1.0

357
00:11:58,959 --> 00:12:00,800
and ts 1.1 you have a solid random

358
00:12:00,800 --> 00:12:01,279
function

359
00:12:01,279 --> 00:12:04,160
based on hmac and what you do is you

360
00:12:04,160 --> 00:12:06,560
split the shared secret into two halves

361
00:12:06,560 --> 00:12:09,920
and one half enters the md5 based plot

362
00:12:09,920 --> 00:12:11,519
random function and oneness with sha1

363
00:12:11,519 --> 00:12:12,000
based

364
00:12:12,000 --> 00:12:14,240
absolute random function and in the end

365
00:12:14,240 --> 00:12:16,480
both outputs are xor and this is

366
00:12:16,480 --> 00:12:19,200
basically the output of a hole function

367
00:12:19,200 --> 00:12:21,279
if a shared secret is of uneven length

368
00:12:21,279 --> 00:12:22,880
and the byte in the middle is in both

369
00:12:22,880 --> 00:12:24,399
halves yeah

370
00:12:24,399 --> 00:12:26,639
and this is important because it allows

371
00:12:26,639 --> 00:12:27,440
us to find

372
00:12:27,440 --> 00:12:30,399
additional offsets for the attacker to

373
00:12:30,399 --> 00:12:32,480
reach the staircase

374
00:12:32,480 --> 00:12:34,399
yeah but how does this put a random

375
00:12:34,399 --> 00:12:37,279
function based on hmac worth well

376
00:12:37,279 --> 00:12:39,920
the pms is entered into hmac and the

377
00:12:39,920 --> 00:12:41,839
hmac is computed over the label and the

378
00:12:41,839 --> 00:12:42,320
seat

379
00:12:42,320 --> 00:12:45,440
and stuff like that and

380
00:12:45,440 --> 00:12:47,680
the pre-master seeker is actually the

381
00:12:47,680 --> 00:12:49,519
key which is used in the hmac

382
00:12:49,519 --> 00:12:53,200
yeah so how does this look

383
00:12:53,200 --> 00:12:56,560
if the key is greater than the block

384
00:12:56,560 --> 00:12:58,160
length of a hash function

385
00:12:58,160 --> 00:13:00,399
then the key has to be hashed before it

386
00:13:00,399 --> 00:13:02,000
is used in the

387
00:13:02,000 --> 00:13:04,959
hmac and it's then padded so you hash

388
00:13:04,959 --> 00:13:06,959
the key and pad the key if it's too big

389
00:13:06,959 --> 00:13:09,200
and if it's smaller then you just pat

390
00:13:09,200 --> 00:13:10,720
the key and if it's exactly the same for

391
00:13:10,720 --> 00:13:13,360
size when you can use the key right away

392
00:13:13,360 --> 00:13:18,480
so in tls k is typically 1024 to 2048

393
00:13:18,480 --> 00:13:19,360
bits long

394
00:13:19,360 --> 00:13:22,959
so because your um your

395
00:13:22,959 --> 00:13:27,120
your modulus size is 1024 to 2048

396
00:13:27,120 --> 00:13:30,360
so sha 1 and d5 and chart 156 all have

397
00:13:30,360 --> 00:13:31,680
512

398
00:13:31,680 --> 00:13:33,760
bit block length so in those cases

399
00:13:33,760 --> 00:13:35,200
you're always

400
00:13:35,200 --> 00:13:38,959
um you're always in the top case where

401
00:13:38,959 --> 00:13:40,399
k is bigger than the block length of the

402
00:13:40,399 --> 00:13:43,279
hash function in shaft 384

403
00:13:43,279 --> 00:13:46,480
um okay has 1024 bit block length so

404
00:13:46,480 --> 00:13:47,440
here you are

405
00:13:47,440 --> 00:13:48,880
[Music]

406
00:13:48,880 --> 00:13:52,480
sometimes in k namely if your

407
00:13:52,480 --> 00:13:56,000
key is 1024 bit

408
00:13:56,000 --> 00:13:59,040
if your model is 1024 bit long then

409
00:13:59,040 --> 00:14:04,480
you are always under the block length

410
00:14:06,399 --> 00:14:09,120
okay so your key is basically hashed

411
00:14:09,120 --> 00:14:10,720
which means that the

412
00:14:10,720 --> 00:14:14,000
key is basically in input in the hash

413
00:14:14,000 --> 00:14:16,560
function directly

414
00:14:16,560 --> 00:14:20,160
so to get back to this to the expected

415
00:14:20,160 --> 00:14:22,160
computation time of a hash function

416
00:14:22,160 --> 00:14:24,079
we we expect the staircase figure so

417
00:14:24,079 --> 00:14:26,320
what we did is we measured actually

418
00:14:26,320 --> 00:14:28,399
how this would look like and here is an

419
00:14:28,399 --> 00:14:30,000
example of bouncy castle

420
00:14:30,000 --> 00:14:33,360
and this is sha 384 and

421
00:14:33,360 --> 00:14:35,279
what you see is you can you can see the

422
00:14:35,279 --> 00:14:37,519
staircase figure we expected

423
00:14:37,519 --> 00:14:39,440
but what you can also see that the time

424
00:14:39,440 --> 00:14:41,760
execution time is slightly rising

425
00:14:41,760 --> 00:14:44,399
so even if you're on a staircase it's

426
00:14:44,399 --> 00:14:45,920
not completely flat

427
00:14:45,920 --> 00:14:49,199
like there is um there's some

428
00:14:49,199 --> 00:14:52,320
some some slope here or

429
00:14:52,320 --> 00:14:54,880
slowly slowly rising so what this means

430
00:14:54,880 --> 00:14:55,680
is that in an

431
00:14:55,680 --> 00:14:58,480
actual shaft 384 implementation like in

432
00:14:58,480 --> 00:14:59,680
this monthly castle

433
00:14:59,680 --> 00:15:01,360
you could potentially also measure on

434
00:15:01,360 --> 00:15:03,040
the slope so you do not need

435
00:15:03,040 --> 00:15:06,160
necessarily to be here at the staircase

436
00:15:06,160 --> 00:15:09,120
with your moduli you can also be here

437
00:15:09,120 --> 00:15:10,240
you just need to measure

438
00:15:10,240 --> 00:15:12,079
a very fine sidechain you just need to

439
00:15:12,079 --> 00:15:15,120
be very good at measuring time

440
00:15:15,120 --> 00:15:17,440
here's another image from i think this

441
00:15:17,440 --> 00:15:20,240
is open sha 156

442
00:15:20,240 --> 00:15:23,279
and this kind of surprised us because

443
00:15:23,279 --> 00:15:25,120
you can still see the staircase figure

444
00:15:25,120 --> 00:15:27,440
so it's still continuously rising

445
00:15:27,440 --> 00:15:30,320
but what's happening on the stairs is

446
00:15:30,320 --> 00:15:31,519
kind of

447
00:15:31,519 --> 00:15:33,680
random like there's some jitter but does

448
00:15:33,680 --> 00:15:35,600
not look completely random so if you

449
00:15:35,600 --> 00:15:37,759
look closely like all also these smaller

450
00:15:37,759 --> 00:15:38,880
jitter blocks

451
00:15:38,880 --> 00:15:41,279
have some repeating pattern here and you

452
00:15:41,279 --> 00:15:42,160
see that

453
00:15:42,160 --> 00:15:45,120
right before stack is slowly rising and

454
00:15:45,120 --> 00:15:46,079
after each

455
00:15:46,079 --> 00:15:48,399
at each staircase there is like another

456
00:15:48,399 --> 00:15:50,240
spike

457
00:15:50,240 --> 00:15:53,040
here and this was kind of surprising to

458
00:15:53,040 --> 00:15:55,839
us so we were like okay what is this

459
00:15:55,839 --> 00:15:59,519
and um this is just internet of the open

460
00:15:59,519 --> 00:16:00,079
essay

461
00:16:00,079 --> 00:16:03,040
implementation like oh my has a custom

462
00:16:03,040 --> 00:16:04,639
assembly written

463
00:16:04,639 --> 00:16:06,720
chart 156 implementation which was

464
00:16:06,720 --> 00:16:07,759
written to be

465
00:16:07,759 --> 00:16:10,800
very fast for most inputs and very

466
00:16:10,800 --> 00:16:13,839
um very fast this but this created some

467
00:16:13,839 --> 00:16:15,519
artifacts

468
00:16:15,519 --> 00:16:17,120
in the execution time which you can see

469
00:16:17,120 --> 00:16:19,440
here and we specifically these

470
00:16:19,440 --> 00:16:21,279
bigger ones in the start of each

471
00:16:21,279 --> 00:16:23,839
staircase

472
00:16:24,480 --> 00:16:26,000
from the interaction between the update

473
00:16:26,000 --> 00:16:28,639
and finalize function

474
00:16:28,639 --> 00:16:30,639
so what i want to say here is that

475
00:16:30,639 --> 00:16:32,320
basically

476
00:16:32,320 --> 00:16:34,079
the racoon attack works even if you are

477
00:16:34,079 --> 00:16:35,600
not on a staircase if you're just able

478
00:16:35,600 --> 00:16:36,160
to measure

479
00:16:36,160 --> 00:16:39,680
the time uh good enough because

480
00:16:39,680 --> 00:16:41,360
the hash function real world hash

481
00:16:41,360 --> 00:16:43,040
functions just have weird

482
00:16:43,040 --> 00:16:44,880
performance characteristics and they do

483
00:16:44,880 --> 00:16:47,360
not have this perfectly flat

484
00:16:47,360 --> 00:16:49,040
execution time they should not have

485
00:16:49,040 --> 00:16:50,720
actually so it's kind of

486
00:16:50,720 --> 00:16:54,000
ridiculous to assume but um yeah we did

487
00:16:54,000 --> 00:16:55,279
that first so

488
00:16:55,279 --> 00:16:58,800
yeah okay and uh now to the

489
00:16:58,800 --> 00:17:02,639
to the crux of attack optimization so

490
00:17:02,639 --> 00:17:04,880
um if the attacker observed the tls-102

491
00:17:04,880 --> 00:17:06,400
connection and wants to detect that

492
00:17:06,400 --> 00:17:10,160
he does not actually need to do a tls10

493
00:17:10,160 --> 00:17:10,640
connect

494
00:17:10,640 --> 00:17:12,319
to the connection in his own connection

495
00:17:12,319 --> 00:17:14,079
so what attacker can do he can choose

496
00:17:14,079 --> 00:17:14,640
the

497
00:17:14,640 --> 00:17:16,640
parameters for his own connections where

498
00:17:16,640 --> 00:17:18,720
you want to measure the side channel

499
00:17:18,720 --> 00:17:21,119
to use the most advantageous one for him

500
00:17:21,119 --> 00:17:22,959
so you can use tiers 1.0 if that fits

501
00:17:22,959 --> 00:17:24,480
better with modulus length

502
00:17:24,480 --> 00:17:27,280
you can use uts-102 or you can use sf3

503
00:17:27,280 --> 00:17:29,600
whatever the server offers

504
00:17:29,600 --> 00:17:33,200
the attacker can use to his advantage

505
00:17:33,200 --> 00:17:35,840
so now a quick x-course to measuring

506
00:17:35,840 --> 00:17:36,320
time

507
00:17:36,320 --> 00:17:38,960
so recruitment attack relies on very

508
00:17:38,960 --> 00:17:40,799
precise timing measurements

509
00:17:40,799 --> 00:17:43,840
so if you have like

510
00:17:43,840 --> 00:17:45,280
bad timing measurements the tech does

511
00:17:45,280 --> 00:17:46,240
not work because you cannot

512
00:17:46,240 --> 00:17:48,320
differentiate those

513
00:17:48,320 --> 00:17:50,880
differences and if you want to do this

514
00:17:50,880 --> 00:17:52,080
attack over the network which is

515
00:17:52,080 --> 00:17:53,679
probably the most interesting you need

516
00:17:53,679 --> 00:17:54,480
to

517
00:17:54,480 --> 00:17:57,360
be very careful with your design so if

518
00:17:57,360 --> 00:17:59,200
you do this naively and use a space so

519
00:17:59,200 --> 00:18:00,640
you just write a program which

520
00:18:00,640 --> 00:18:02,640
sends network packets and measures the

521
00:18:02,640 --> 00:18:05,039
time when you introduce a lot of noise

522
00:18:05,039 --> 00:18:06,720
namely the corner can introduce noise

523
00:18:06,720 --> 00:18:08,480
the network card can introduce noise the

524
00:18:08,480 --> 00:18:10,000
transmission introduces noise and the

525
00:18:10,000 --> 00:18:11,120
same is true

526
00:18:11,120 --> 00:18:13,440
onwards on the end where the data is

527
00:18:13,440 --> 00:18:14,480
received and the server

528
00:18:14,480 --> 00:18:16,160
can also do the same thing like the

529
00:18:16,160 --> 00:18:18,000
network card can introduce noise

530
00:18:18,000 --> 00:18:21,520
kernel can reduce noise and so on so

531
00:18:21,520 --> 00:18:23,840
it's not optimal to to to do this kind

532
00:18:23,840 --> 00:18:26,000
of measurements in user space so

533
00:18:26,000 --> 00:18:28,480
what previously approached it is they

534
00:18:28,480 --> 00:18:30,640
measured in kernel space so they wrote a

535
00:18:30,640 --> 00:18:33,200
custom kernel module or something

536
00:18:33,200 --> 00:18:33,919
similar

537
00:18:33,919 --> 00:18:37,360
they gave this module a dedicated

538
00:18:37,360 --> 00:18:40,480
cpu kernel and let the cpu

539
00:18:40,480 --> 00:18:44,000
process measure constantly the time and

540
00:18:44,000 --> 00:18:45,760
they also did not measure the time with

541
00:18:45,760 --> 00:18:48,320
cpu timestamps or something

542
00:18:48,320 --> 00:18:51,840
instead they counted cycles and um

543
00:18:51,840 --> 00:18:53,360
because this was more accurate than

544
00:18:53,360 --> 00:18:55,039
actually doing it

545
00:18:55,039 --> 00:18:59,360
with a with a bit in um timestamps

546
00:18:59,360 --> 00:19:01,360
but for current tech we found that this

547
00:19:01,360 --> 00:19:02,799
was also

548
00:19:02,799 --> 00:19:05,280
not optimal so what we did instead we

549
00:19:05,280 --> 00:19:06,720
used the network card directly to

550
00:19:06,720 --> 00:19:07,520
measure

551
00:19:07,520 --> 00:19:09,360
with timestamps so there is a feature in

552
00:19:09,360 --> 00:19:10,799
modern network cards which allows the

553
00:19:10,799 --> 00:19:12,240
network card to just

554
00:19:12,240 --> 00:19:15,120
add a timestamp to each incoming packet

555
00:19:15,120 --> 00:19:16,000
they receive

556
00:19:16,000 --> 00:19:18,930
and send and then you can

557
00:19:18,930 --> 00:19:20,799
[Music]

558
00:19:20,799 --> 00:19:24,080
just use those timestamps directly and

559
00:19:24,080 --> 00:19:25,840
then you only create noise on the

560
00:19:25,840 --> 00:19:27,200
network and

561
00:19:27,200 --> 00:19:29,919
on the other part and but on your own

562
00:19:29,919 --> 00:19:33,039
the noise is really minimized

563
00:19:33,039 --> 00:19:35,360
and what we do is we perform this timing

564
00:19:35,360 --> 00:19:36,640
measurements with special timing

565
00:19:36,640 --> 00:19:38,160
measurement equipment so

566
00:19:38,160 --> 00:19:41,039
normal network cards have a resolution

567
00:19:41,039 --> 00:19:43,679
of like 233 megahertz

568
00:19:43,679 --> 00:19:46,240
and this is not very good and this is

569
00:19:46,240 --> 00:19:48,320
why people previously used

570
00:19:48,320 --> 00:19:49,840
some kernel modules because the

571
00:19:49,840 --> 00:19:51,760
timestamps provided by the network card

572
00:19:51,760 --> 00:19:53,440
were not good enough

573
00:19:53,440 --> 00:19:56,000
however there exists a community which

574
00:19:56,000 --> 00:19:57,039
builds these

575
00:19:57,039 --> 00:19:59,360
special timing measurements network

576
00:19:59,360 --> 00:20:01,039
cards which are actually built for

577
00:20:01,039 --> 00:20:03,919
financial transactions or rocket science

578
00:20:03,919 --> 00:20:06,000
clock synchronizations and stuff like

579
00:20:06,000 --> 00:20:07,600
that and they

580
00:20:07,600 --> 00:20:09,919
are optimized to provide high quality

581
00:20:09,919 --> 00:20:11,679
timestamps and they do this with a four

582
00:20:11,679 --> 00:20:12,559
gigahertz

583
00:20:12,559 --> 00:20:15,919
um special chip on the network card

584
00:20:15,919 --> 00:20:16,559
which is

585
00:20:16,559 --> 00:20:18,559
only purpose is to make the most

586
00:20:18,559 --> 00:20:19,679
accurate timing

587
00:20:19,679 --> 00:20:23,039
timestamps on those network packets and

588
00:20:23,039 --> 00:20:25,600
those cards are kind of expensive but

589
00:20:25,600 --> 00:20:27,039
from a tech's point of view they are

590
00:20:27,039 --> 00:20:28,559
really the optimal thing to do those

591
00:20:28,559 --> 00:20:30,320
time measurements with

592
00:20:30,320 --> 00:20:33,120
and you can measure timing difference up

593
00:20:33,120 --> 00:20:34,840
to 25

594
00:20:34,840 --> 00:20:37,679
0.25 nanoseconds so which is like 250

595
00:20:37,679 --> 00:20:39,360
picoseconds and which is really really

596
00:20:39,360 --> 00:20:41,120
good

597
00:20:41,120 --> 00:20:44,880
um so

598
00:20:44,880 --> 00:20:46,799
what you can do is you can perform these

599
00:20:46,799 --> 00:20:48,000
complex timing attacks

600
00:20:48,000 --> 00:20:50,240
but what we found is there are sometimes

601
00:20:50,240 --> 00:20:52,000
easier ways and where you do not need

602
00:20:52,000 --> 00:20:53,600
these special network

603
00:20:53,600 --> 00:20:56,960
equipment and you do not need to do all

604
00:20:56,960 --> 00:20:58,799
this kind of really hard stuff

605
00:20:58,799 --> 00:21:00,840
but you can do something much much

606
00:21:00,840 --> 00:21:03,120
easier and

607
00:21:03,120 --> 00:21:06,240
that is a cve 2022-529

608
00:21:06,240 --> 00:21:08,640
which is from the company f5 which

609
00:21:08,640 --> 00:21:10,799
produces like tls

610
00:21:10,799 --> 00:21:14,480
acceleration equipment and f5 pip

611
00:21:14,480 --> 00:21:16,080
had a bug which caused it to leak

612
00:21:16,080 --> 00:21:18,000
leading zero bytes

613
00:21:18,000 --> 00:21:21,600
so if you send a shared secret and

614
00:21:21,600 --> 00:21:24,240
a a public key and the server computes

615
00:21:24,240 --> 00:21:25,679
the shared secret which starts with a

616
00:21:25,679 --> 00:21:26,960
leading zero byte

617
00:21:26,960 --> 00:21:28,960
and the finished message is invalid it

618
00:21:28,960 --> 00:21:31,520
sends two alert messages

619
00:21:31,520 --> 00:21:33,280
while if the shared secret did not start

620
00:21:33,280 --> 00:21:35,120
with a leading zero right but

621
00:21:35,120 --> 00:21:37,039
the finished message it only sends one

622
00:21:37,039 --> 00:21:39,039
alert message

623
00:21:39,039 --> 00:21:41,520
so there was actually a bug inside bkp

624
00:21:41,520 --> 00:21:42,080
we do not

625
00:21:42,080 --> 00:21:43,679
know exactly what how this bug looked

626
00:21:43,679 --> 00:21:46,000
like but this bug caused it to

627
00:21:46,000 --> 00:21:49,120
um send either two or one alert messages

628
00:21:49,120 --> 00:21:52,240
in response to our public key and this

629
00:21:52,240 --> 00:21:53,679
is much easier because now you do not

630
00:21:53,679 --> 00:21:55,120
need to measure timings at all you just

631
00:21:55,120 --> 00:21:56,000
need to

632
00:21:56,000 --> 00:21:57,840
see if you receive one alert or two

633
00:21:57,840 --> 00:21:59,679
alerts and depending on what you can

634
00:21:59,679 --> 00:22:01,120
decide if a shared secret starts with

635
00:22:01,120 --> 00:22:03,280
leading zero right or not

636
00:22:03,280 --> 00:22:06,240
we also found other servers which had

637
00:22:06,240 --> 00:22:07,679
similar bugs

638
00:22:07,679 --> 00:22:09,760
we did this with a black box scan of the

639
00:22:09,760 --> 00:22:12,000
internet and

640
00:22:12,000 --> 00:22:14,230
in the other cases the bug

641
00:22:14,230 --> 00:22:15,360
[Music]

642
00:22:15,360 --> 00:22:17,039
was not exploitable because the server

643
00:22:17,039 --> 00:22:18,880
was not reusing the keys but these fi

644
00:22:18,880 --> 00:22:21,679
f5 big ips were almost all exclusively

645
00:22:21,679 --> 00:22:27,039
reusing their ethernet keys

646
00:22:27,039 --> 00:22:30,799
so as i already said um

647
00:22:30,799 --> 00:22:33,760
we recover is oracle's direct racoon and

648
00:22:33,760 --> 00:22:35,440
not all of these direct recruitment

649
00:22:35,440 --> 00:22:36,240
oracles

650
00:22:36,240 --> 00:22:38,000
we found during our scans were

651
00:22:38,000 --> 00:22:39,520
deterministic so

652
00:22:39,520 --> 00:22:42,559
they sometimes responded with this 201

653
00:22:42,559 --> 00:22:43,840
alert maybe

654
00:22:43,840 --> 00:22:48,240
or some other response but

655
00:22:48,320 --> 00:22:50,720
sometimes they did not and we assume

656
00:22:50,720 --> 00:22:52,320
that this might be due to

657
00:22:52,320 --> 00:22:55,840
some bugs internally maybe these

658
00:22:55,840 --> 00:22:58,880
leading zero bite shared secrets mess up

659
00:22:58,880 --> 00:23:00,480
with the memory internally and

660
00:23:00,480 --> 00:23:02,640
after a while it crashes so i don't know

661
00:23:02,640 --> 00:23:04,320
or it might also be because there's a

662
00:23:04,320 --> 00:23:06,320
non-homogeneous

663
00:23:06,320 --> 00:23:08,080
deployment so maybe there are some

664
00:23:08,080 --> 00:23:09,760
vulnerabilities deployed and some are

665
00:23:09,760 --> 00:23:10,480
not

666
00:23:10,480 --> 00:23:12,400
and it's by chance which server you're

667
00:23:12,400 --> 00:23:13,760
talking to when you're doing this

668
00:23:13,760 --> 00:23:16,799
skins and

669
00:23:16,799 --> 00:23:19,919
um so we had to come up with a

670
00:23:19,919 --> 00:23:21,679
with a technique which also performs

671
00:23:21,679 --> 00:23:22,799
well when the server is not

672
00:23:22,799 --> 00:23:24,159
deterministic

673
00:23:24,159 --> 00:23:26,320
so what we ended up doing is we

674
00:23:26,320 --> 00:23:27,360
performed

675
00:23:27,360 --> 00:23:30,640
each shared circuit multiple times so we

676
00:23:30,640 --> 00:23:32,159
repeated the same measurement multiple

677
00:23:32,159 --> 00:23:34,640
times and we recorded the connection

678
00:23:34,640 --> 00:23:36,080
when we did a statistic

679
00:23:36,080 --> 00:23:39,520
test to determine if the response we got

680
00:23:39,520 --> 00:23:40,640
were significant

681
00:23:40,640 --> 00:23:42,720
um dependent on the leading zero right

682
00:23:42,720 --> 00:23:44,960
or not so what you would assume is that

683
00:23:44,960 --> 00:23:46,480
if it's just by chance that you get a

684
00:23:46,480 --> 00:23:48,080
different response from server

685
00:23:48,080 --> 00:23:51,039
that we by chance responses are equally

686
00:23:51,039 --> 00:23:52,320
distributed among our

687
00:23:52,320 --> 00:23:55,520
possible um uh test factors

688
00:23:55,520 --> 00:23:58,159
but um if they are not equally

689
00:23:58,159 --> 00:23:59,600
distributed then you know

690
00:23:59,600 --> 00:24:02,640
there's something going on so

691
00:24:02,640 --> 00:24:03,840
this is what we did so we are scanned

692
00:24:03,840 --> 00:24:06,240
for alexa top 100 000 and we found that

693
00:24:06,240 --> 00:24:07,760
32 percent of our servers were

694
00:24:07,760 --> 00:24:09,760
supporting dhe cypher suits so it's

695
00:24:09,760 --> 00:24:10,640
still widely

696
00:24:10,640 --> 00:24:13,919
um supported by the servers

697
00:24:13,919 --> 00:24:17,919
but um only 10.9 of those service reused

698
00:24:17,919 --> 00:24:19,520
vape family keys so i think it was like

699
00:24:19,520 --> 00:24:21,120
three point three percent overall

700
00:24:21,120 --> 00:24:24,559
or something like that um

701
00:24:24,559 --> 00:24:27,200
so if you are using dhe services on a

702
00:24:27,200 --> 00:24:28,559
server whereas a temperature and chance

703
00:24:28,559 --> 00:24:29,840
that your servers actually want to build

704
00:24:29,840 --> 00:24:31,520
to recruit attack

705
00:24:31,520 --> 00:24:34,000
and um but to be vulnerable to

706
00:24:34,000 --> 00:24:35,279
recruiting it's not enough at the

707
00:24:35,279 --> 00:24:37,200
service supporting the cypher suit

708
00:24:37,200 --> 00:24:39,039
um you also have to have a client

709
00:24:39,039 --> 00:24:40,400
connection you want to attack and for

710
00:24:40,400 --> 00:24:41,440
that to happen

711
00:24:41,440 --> 00:24:42,720
you have to have a client which is

712
00:24:42,720 --> 00:24:44,080
connecting to the server which is

713
00:24:44,080 --> 00:24:45,120
actually

714
00:24:45,120 --> 00:24:48,240
using the dhg cipher suit and

715
00:24:48,240 --> 00:24:50,080
for on that side firefox was the last

716
00:24:50,080 --> 00:24:52,000
browser to drop support for um

717
00:24:52,000 --> 00:24:55,279
for dhe in september 2020. um we

718
00:24:55,279 --> 00:24:57,360
actually reported it to firefox a little

719
00:24:57,360 --> 00:24:59,200
bit earlier but they were already in the

720
00:24:59,200 --> 00:25:00,240
process of

721
00:25:00,240 --> 00:25:02,960
deprecating dhe so we cannot claim that

722
00:25:02,960 --> 00:25:03,919
we

723
00:25:03,919 --> 00:25:07,279
caused them to deprecate it but um

724
00:25:07,279 --> 00:25:09,200
it certainly helped in the deprecation

725
00:25:09,200 --> 00:25:11,279
process um

726
00:25:11,279 --> 00:25:12,720
and as of now no major browser

727
00:25:12,720 --> 00:25:14,640
supporting dhe anymore

728
00:25:14,640 --> 00:25:16,880
and during our scans we found 87 perfect

729
00:25:16,880 --> 00:25:18,720
direct oracles which is like

730
00:25:18,720 --> 00:25:21,840
oracles which are deterministic and um

731
00:25:21,840 --> 00:25:25,120
of those 87 outcomes 84 were reusing

732
00:25:25,120 --> 00:25:26,240
keys so if you had a

733
00:25:26,240 --> 00:25:28,400
perfect direct oracle which is like the

734
00:25:28,400 --> 00:25:30,880
five one

735
00:25:31,120 --> 00:25:33,279
then you were also very likely using

736
00:25:33,279 --> 00:25:35,120
your keys

737
00:25:35,120 --> 00:25:37,760
and we've also found 815 imperfect uh

738
00:25:37,760 --> 00:25:39,840
meaning non-deterministic oracles

739
00:25:39,840 --> 00:25:43,520
and of those non-very reusing the keys

740
00:25:43,520 --> 00:25:44,880
so there's likely another implementation

741
00:25:44,880 --> 00:25:46,559
which has the same bug but

742
00:25:46,559 --> 00:25:48,080
since we are not using the keys they're

743
00:25:48,080 --> 00:25:49,440
not exploitable and we could not

744
00:25:49,440 --> 00:25:50,720
identify which implementation is

745
00:25:50,720 --> 00:25:52,240
actually vulnerable for

746
00:25:52,240 --> 00:25:56,640
or responsible for this so as a counter

747
00:25:56,640 --> 00:25:57,200
measure

748
00:25:57,200 --> 00:25:59,440
um to racuna tech there are general

749
00:25:59,440 --> 00:26:01,200
lessons to be learned so

750
00:26:01,200 --> 00:26:02,720
one important one is that you should not

751
00:26:02,720 --> 00:26:05,039
leak um partial information about sql

752
00:26:05,039 --> 00:26:07,120
values so in this case this was not done

753
00:26:07,120 --> 00:26:10,480
on purpose obviously but

754
00:26:10,480 --> 00:26:12,320
a good design approach to achieve this

755
00:26:12,320 --> 00:26:13,840
is to make sure that all your secret

756
00:26:13,840 --> 00:26:15,840
values are always of constant size

757
00:26:15,840 --> 00:26:17,760
so that you do not strip leading zero

758
00:26:17,760 --> 00:26:18,880
bytes or

759
00:26:18,880 --> 00:26:20,720
something like that or that you're by

760
00:26:20,720 --> 00:26:22,159
chance i don't know but because your

761
00:26:22,159 --> 00:26:23,360
iron did something

762
00:26:23,360 --> 00:26:25,279
it's a little bit bigger it makes it

763
00:26:25,279 --> 00:26:27,760
really easy to implement if you

764
00:26:27,760 --> 00:26:29,440
do this because verteca doesn't need to

765
00:26:29,440 --> 00:26:31,679
worry so much about

766
00:26:31,679 --> 00:26:34,159
the internal processing of of a secret

767
00:26:34,159 --> 00:26:35,679
value

768
00:26:35,679 --> 00:26:38,799
for tls specific for clients should now

769
00:26:38,799 --> 00:26:41,120
avoid dhe so browser already doing that

770
00:26:41,120 --> 00:26:42,240
which is great um

771
00:26:42,240 --> 00:26:44,480
but if you have some other applications

772
00:26:44,480 --> 00:26:46,080
it's probably smart to switch to

773
00:26:46,080 --> 00:26:49,039
elliptic curved if you haven't or ts103

774
00:26:49,039 --> 00:26:53,200
because tiffy hermann and um

775
00:26:53,279 --> 00:26:55,360
in static divi hammond you always reuse

776
00:26:55,360 --> 00:26:57,279
the key so it's always wonderful

777
00:26:57,279 --> 00:26:59,279
and in difficult ephemera you do not

778
00:26:59,279 --> 00:27:00,960
know if the server you're connecting to

779
00:27:00,960 --> 00:27:02,400
is actually reusing

780
00:27:02,400 --> 00:27:04,480
the ephemer keys or not so as a client

781
00:27:04,480 --> 00:27:06,159
you are kind of guessing

782
00:27:06,159 --> 00:27:09,120
or risking that your data gets stolen so

783
00:27:09,120 --> 00:27:10,799
as a client it's better to be safe than

784
00:27:10,799 --> 00:27:12,159
sorry and

785
00:27:12,159 --> 00:27:15,440
just not use the dvm anymore on the

786
00:27:15,440 --> 00:27:16,159
server side

787
00:27:16,159 --> 00:27:18,080
you can actually still support the

788
00:27:18,080 --> 00:27:20,000
diffie-hellman handshake so this is

789
00:27:20,000 --> 00:27:22,799
perfectly fine but you should not reuse

790
00:27:22,799 --> 00:27:24,640
ephemera keys so

791
00:27:24,640 --> 00:27:26,960
if you just uh use the key ones and you

792
00:27:26,960 --> 00:27:28,880
can at most leak one byte and which is

793
00:27:28,880 --> 00:27:30,399
not enough to solve any hidden number

794
00:27:30,399 --> 00:27:31,279
problem

795
00:27:31,279 --> 00:27:34,799
so um this is this is fine

796
00:27:34,799 --> 00:27:37,440
but um most servers also have options

797
00:27:37,440 --> 00:27:37,919
for that

798
00:27:37,919 --> 00:27:39,200
in their configuration files where you

799
00:27:39,200 --> 00:27:41,279
can say oh explicitly do not reuse

800
00:27:41,279 --> 00:27:43,679
ephemera keys

801
00:27:43,679 --> 00:27:45,440
and um the static diffie-hellman

802
00:27:45,440 --> 00:27:47,120
handshake should not be used by either

803
00:27:47,120 --> 00:27:48,240
clients or servers so

804
00:27:48,240 --> 00:27:49,919
aesthetic different handshake is lost

805
00:27:49,919 --> 00:27:52,080
you cannot you cannot fix this so

806
00:27:52,080 --> 00:27:54,399
we have a public keys in the certificate

807
00:27:54,399 --> 00:27:55,520
of server

808
00:27:55,520 --> 00:27:58,480
and that is always static so there's no

809
00:27:58,480 --> 00:28:01,440
chance to repair that

810
00:28:01,679 --> 00:28:03,600
so how does the racoon attack interact

811
00:28:03,600 --> 00:28:04,559
with the elliptic curve that if you

812
00:28:04,559 --> 00:28:06,640
haven't changed so i already said this

813
00:28:06,640 --> 00:28:07,919
elliptical the feminine check is

814
00:28:07,919 --> 00:28:09,760
probably the way to go

815
00:28:09,760 --> 00:28:11,840
and the reason is that the zero bytes of

816
00:28:11,840 --> 00:28:13,600
shared secret and elliptic cuff defeat

817
00:28:13,600 --> 00:28:17,279
are maintained so what they do is they

818
00:28:17,279 --> 00:28:18,480
compute a shared point

819
00:28:18,480 --> 00:28:20,159
and from that shared point they only use

820
00:28:20,159 --> 00:28:22,320
the x coordinate and they keep the

821
00:28:22,320 --> 00:28:24,960
leading zero bytes of that so that is

822
00:28:24,960 --> 00:28:26,080
great

823
00:28:26,080 --> 00:28:29,200
um however we found that a lot of

824
00:28:29,200 --> 00:28:30,720
implementations

825
00:28:30,720 --> 00:28:32,720
are not using secure big number

826
00:28:32,720 --> 00:28:35,200
libraries so what they have to do is

827
00:28:35,200 --> 00:28:37,039
they have to convert the big number to

828
00:28:37,039 --> 00:28:38,480
bytes again and when

829
00:28:38,480 --> 00:28:41,760
they do that they notice oh my

830
00:28:41,760 --> 00:28:44,559
my i had leading zero by strip so they

831
00:28:44,559 --> 00:28:46,080
have to manually

832
00:28:46,080 --> 00:28:48,720
add the leading zero bytes back in and

833
00:28:48,720 --> 00:28:50,080
this in return creates a

834
00:28:50,080 --> 00:28:52,320
sachin again so it's a small one again

835
00:28:52,320 --> 00:28:53,919
so maybe even smaller than

836
00:28:53,919 --> 00:28:56,640
uh the one from the final field if you

837
00:28:56,640 --> 00:28:57,440
haven't

838
00:28:57,440 --> 00:29:00,640
but it's still a measurable timing side

839
00:29:00,640 --> 00:29:02,720
channel

840
00:29:02,720 --> 00:29:06,320
and yeah this is this is very common in

841
00:29:06,320 --> 00:29:09,200
big number libraries

842
00:29:09,440 --> 00:29:11,360
so there might be microarchitecture

843
00:29:11,360 --> 00:29:12,480
situations depending

844
00:29:12,480 --> 00:29:14,960
on the implementation and how they how

845
00:29:14,960 --> 00:29:16,080
they do this

846
00:29:16,080 --> 00:29:18,640
um but fortunately if a hidden number

847
00:29:18,640 --> 00:29:20,320
problem is

848
00:29:20,320 --> 00:29:22,080
in this setup so where you have only the

849
00:29:22,080 --> 00:29:23,440
x coordinate of a

850
00:29:23,440 --> 00:29:25,120
shared point you have to use the

851
00:29:25,120 --> 00:29:26,799
elliptic curve for the number problem

852
00:29:26,799 --> 00:29:29,760
and solving this uh equation system is

853
00:29:29,760 --> 00:29:31,279
not possible

854
00:29:31,279 --> 00:29:33,840
with current techniques with the leak

855
00:29:33,840 --> 00:29:34,559
sizes

856
00:29:34,559 --> 00:29:37,360
of one two and like say maybe five bytes

857
00:29:37,360 --> 00:29:38,320
so currently

858
00:29:38,320 --> 00:29:41,120
i think the best known elliptic curve in

859
00:29:41,120 --> 00:29:42,480
number problem algorithms

860
00:29:42,480 --> 00:29:45,039
require like a third of uh of a leading

861
00:29:45,039 --> 00:29:47,679
zero bytes or or for leading bytes so

862
00:29:47,679 --> 00:29:50,720
um you need much much more bigger leaks

863
00:29:50,720 --> 00:29:53,600
to solve it but i would not feel too

864
00:29:53,600 --> 00:29:54,559
safe with this

865
00:29:54,559 --> 00:29:56,559
because um this might change in the

866
00:29:56,559 --> 00:29:58,080
future like philip de curve number

867
00:29:58,080 --> 00:30:00,159
problem was not very interesting

868
00:30:00,159 --> 00:30:03,039
maybe uh before because it was just some

869
00:30:03,039 --> 00:30:04,000
theoretical

870
00:30:04,000 --> 00:30:07,360
academic thing and now it's suddenly

871
00:30:07,360 --> 00:30:09,760
maybe possible to perform a real attack

872
00:30:09,760 --> 00:30:10,559
with that

873
00:30:10,559 --> 00:30:12,000
and i'm pretty sure that a lot of

874
00:30:12,000 --> 00:30:13,919
researchers are now very curious

875
00:30:13,919 --> 00:30:15,600
if you can actually do this with less

876
00:30:15,600 --> 00:30:17,440
leaks

877
00:30:17,440 --> 00:30:19,279
so i would probably not count on that

878
00:30:19,279 --> 00:30:21,120
and already

879
00:30:21,120 --> 00:30:23,279
move towards not reusing elliptic curve

880
00:30:23,279 --> 00:30:24,320
um

881
00:30:24,320 --> 00:30:28,080
uh public keys and tls so that you

882
00:30:28,080 --> 00:30:31,120
uh are on the safe side safe side and

883
00:30:31,120 --> 00:30:31,600
actually

884
00:30:31,600 --> 00:30:33,360
um this is also what open message did in

885
00:30:33,360 --> 00:30:35,760
response to raccoon attack so they were

886
00:30:35,760 --> 00:30:38,159
i think since 2016 where we were not

887
00:30:38,159 --> 00:30:38,799
reusing

888
00:30:38,799 --> 00:30:41,440
the final 50 female public keys anymore

889
00:30:41,440 --> 00:30:42,240
but

890
00:30:42,240 --> 00:30:45,039
after our disclosure they also started

891
00:30:45,039 --> 00:30:46,080
not reusing

892
00:30:46,080 --> 00:30:49,440
elliptic curve public keys to mitigate

893
00:30:49,440 --> 00:30:50,159
potential

894
00:30:50,159 --> 00:30:53,840
attacks in the future so

895
00:30:53,840 --> 00:30:56,880
for tls 103 leading zero bytes of all

896
00:30:56,880 --> 00:30:59,600
shared secrets are maintained so this is

897
00:30:59,600 --> 00:31:01,120
a change by david benjamin which was

898
00:31:01,120 --> 00:31:01,679
made in

899
00:31:01,679 --> 00:31:04,960
craft 13 which proved very useful here

900
00:31:04,960 --> 00:31:05,519
because

901
00:31:05,519 --> 00:31:07,679
he hated that there was this mess that

902
00:31:07,679 --> 00:31:08,510
sometimes

903
00:31:08,510 --> 00:31:10,880
[Music]

904
00:31:10,880 --> 00:31:12,880
removes leading the right sometimes you

905
00:31:12,880 --> 00:31:15,440
keep it and also he hates

906
00:31:15,440 --> 00:31:18,000
that you have his non-equal size shared

907
00:31:18,000 --> 00:31:20,159
secret so

908
00:31:20,159 --> 00:31:23,039
he proposed to change this and and

909
00:31:23,039 --> 00:31:24,559
indeed he did and this

910
00:31:24,559 --> 00:31:27,200
makes the ts 103 only may be vulnerable

911
00:31:27,200 --> 00:31:28,240
to micro architecture

912
00:31:28,240 --> 00:31:30,399
side chain so the same as with elliptic

913
00:31:30,399 --> 00:31:31,279
curves

914
00:31:31,279 --> 00:31:33,679
but at the same time ephemeral keyboard

915
00:31:33,679 --> 00:31:36,080
is not so common in tls103

916
00:31:36,080 --> 00:31:39,840
so ts103 is probably secure against the

917
00:31:39,840 --> 00:31:42,080
recon attack

918
00:31:42,080 --> 00:31:45,600
but there exists actually a variant of

919
00:31:45,600 --> 00:31:49,039
ts103 which is called etls or ets

920
00:31:49,039 --> 00:31:52,080
and this is a variant created by etsy so

921
00:31:52,080 --> 00:31:55,279
the problem was that some

922
00:31:55,279 --> 00:31:58,799
industry organizations were not so happy

923
00:31:58,799 --> 00:31:59,360
that

924
00:31:59,360 --> 00:32:01,600
there was no non-perfect forward secure

925
00:32:01,600 --> 00:32:02,799
key exchange anymore

926
00:32:02,799 --> 00:32:04,399
so what they did is they basically

927
00:32:04,399 --> 00:32:06,559
copied ts103 and they said

928
00:32:06,559 --> 00:32:08,960
uh okay with this standard it's okay to

929
00:32:08,960 --> 00:32:10,640
reuse the family keys for multiple

930
00:32:10,640 --> 00:32:12,080
connections

931
00:32:12,080 --> 00:32:13,760
and if you do this and you have a micro

932
00:32:13,760 --> 00:32:15,360
architecture in side channel the

933
00:32:15,360 --> 00:32:15,760
attack

934
00:32:15,760 --> 00:32:17,919
suddenly becomes possible against these

935
00:32:17,919 --> 00:32:18,799
etls

936
00:32:18,799 --> 00:32:21,919
or ets implementations so i cannot

937
00:32:21,919 --> 00:32:23,279
really recommend

938
00:32:23,279 --> 00:32:26,799
going that route but why is that

939
00:32:26,799 --> 00:32:29,840
this mess in first place so we found the

940
00:32:29,840 --> 00:32:31,120
answer to this in an

941
00:32:31,120 --> 00:32:34,000
old mozilla back tracker and apparently

942
00:32:34,000 --> 00:32:35,760
like this is 15 years ago

943
00:32:35,760 --> 00:32:39,120
so um but apparently

944
00:32:39,120 --> 00:32:42,799
um the developers of um tls 1.0

945
00:32:42,799 --> 00:32:45,279
uh ssa3 so this is actually back in

946
00:32:45,279 --> 00:32:46,559
1996.

947
00:32:46,559 --> 00:32:50,080
we're all independently implementing ss3

948
00:32:50,080 --> 00:32:50,640
with

949
00:32:50,640 --> 00:32:52,240
uh stripping of leading zero bytes

950
00:32:52,240 --> 00:32:54,399
because this was the default behavior

951
00:32:54,399 --> 00:32:57,919
of most big number libraries

952
00:32:57,919 --> 00:33:01,679
and the um the specification of ss3

953
00:33:01,679 --> 00:33:03,200
which was not in our series was just

954
00:33:03,200 --> 00:33:04,399
some design document

955
00:33:04,399 --> 00:33:07,039
did not actually um mention how you

956
00:33:07,039 --> 00:33:08,720
should do this so this just said

957
00:33:08,720 --> 00:33:10,080
a convention conventional diffi herman

958
00:33:10,080 --> 00:33:12,080
computation is performed and

959
00:33:12,080 --> 00:33:15,519
what we meant is pkc is free but pkcs3

960
00:33:15,519 --> 00:33:16,320
is

961
00:33:16,320 --> 00:33:18,080
oh pikacy has released a standard on how

962
00:33:18,080 --> 00:33:19,760
to implement different hammond

963
00:33:19,760 --> 00:33:23,039
and pkc3 says keep the leading zero

964
00:33:23,039 --> 00:33:23,679
bytes but

965
00:33:23,679 --> 00:33:26,960
since the uh sf3 the design document did

966
00:33:26,960 --> 00:33:28,240
not mention this

967
00:33:28,240 --> 00:33:30,640
everyone started implementing it with

968
00:33:30,640 --> 00:33:32,480
the stripping of leading zero bytes

969
00:33:32,480 --> 00:33:34,320
and actually in practice this does not

970
00:33:34,320 --> 00:33:35,840
happen so often so um

971
00:33:35,840 --> 00:33:37,840
this only happens like in one of every

972
00:33:37,840 --> 00:33:40,240
200 250ish

973
00:33:40,240 --> 00:33:42,960
connections so if you implement one

974
00:33:42,960 --> 00:33:43,679
implementation

975
00:33:43,679 --> 00:33:44,960
implements it with one way and the other

976
00:33:44,960 --> 00:33:46,880
implements in another way they are

977
00:33:46,880 --> 00:33:49,039
probably interoperable most of the time

978
00:33:49,039 --> 00:33:50,960
but sometimes the connections break so

979
00:33:50,960 --> 00:33:53,039
um at the time this was noticed they

980
00:33:53,039 --> 00:33:54,960
were all already interrupted

981
00:33:54,960 --> 00:33:58,000
to each other so when they um defined

982
00:33:58,000 --> 00:34:01,440
tls 1.0 in 1999 they

983
00:34:01,440 --> 00:34:04,559
just said okay then let's just remove

984
00:34:04,559 --> 00:34:05,200
the

985
00:34:05,200 --> 00:34:06,720
leaving zero bytes outs and here's one

986
00:34:06,720 --> 00:34:09,280
at zero so that we are interoperable

987
00:34:09,280 --> 00:34:11,440
with all ssf3 code and we that we do not

988
00:34:11,440 --> 00:34:14,960
change need to change so much

989
00:34:15,839 --> 00:34:19,520
if you are very um familiar with tls

990
00:34:19,520 --> 00:34:22,079
and tlsdhe in the academic field when

991
00:34:22,079 --> 00:34:23,760
you would know that there are actually

992
00:34:23,760 --> 00:34:24,879
proofs for tls

993
00:34:24,879 --> 00:34:26,960
um and there are actually two ones one

994
00:34:26,960 --> 00:34:28,480
from craftcheck a dive

995
00:34:28,480 --> 00:34:31,040
for tsdf hereman the static variant and

996
00:34:31,040 --> 00:34:32,719
one for dhe

997
00:34:32,719 --> 00:34:35,760
from yagativoyagai and

998
00:34:35,760 --> 00:34:39,280
both showed that actually the tls

999
00:34:39,280 --> 00:34:42,399
protocol is safe

1000
00:34:42,879 --> 00:34:47,119
if you rely on the prf odh assumption

1001
00:34:47,119 --> 00:34:49,040
the problem is that they did not model

1002
00:34:49,040 --> 00:34:51,440
the byte encoding and fed those proofs

1003
00:34:51,440 --> 00:34:54,480
um um

1004
00:34:54,480 --> 00:34:56,399
uh also not did not model timing and

1005
00:34:56,399 --> 00:34:57,920
that that is not a

1006
00:34:57,920 --> 00:35:00,079
not a problem for vs proof specifically

1007
00:35:00,079 --> 00:35:01,839
but this is a problem with all our

1008
00:35:01,839 --> 00:35:04,000
proofs so none of our proofs actually do

1009
00:35:04,000 --> 00:35:06,240
this

1010
00:35:06,560 --> 00:35:11,760
and the pfodh assumption which we

1011
00:35:11,760 --> 00:35:13,599
both relied on is actually not met by

1012
00:35:13,599 --> 00:35:15,680
those implementations in practice

1013
00:35:15,680 --> 00:35:18,160
so what is the pr of odh assumption the

1014
00:35:18,160 --> 00:35:20,400
pfodh assumption basically says that the

1015
00:35:20,400 --> 00:35:23,280
function value pf g to the power of uvx

1016
00:35:23,280 --> 00:35:27,440
for a dhk guv looks random even if given

1017
00:35:27,440 --> 00:35:28,000
g

1018
00:35:28,000 --> 00:35:31,119
u and gv and if seeing retrovirus

1019
00:35:31,119 --> 00:35:34,960
of p f s u x and or p f t

1020
00:35:34,960 --> 00:35:38,240
v x for chosen b s t and x

1021
00:35:38,240 --> 00:35:40,640
um so basically what this means is that

1022
00:35:40,640 --> 00:35:42,960
you cannot distinguish if you

1023
00:35:42,960 --> 00:35:46,240
hashed a specific pair of the specific

1024
00:35:46,240 --> 00:35:47,680
shared secret or if you appear of the

1025
00:35:47,680 --> 00:35:49,680
random value and

1026
00:35:49,680 --> 00:35:51,440
the thing is in tls you can actually

1027
00:35:51,440 --> 00:35:54,880
distinguish that because um

1028
00:35:55,599 --> 00:35:59,200
a random value um

1029
00:35:59,200 --> 00:36:02,560
no the the real value has this property

1030
00:36:02,560 --> 00:36:04,320
way if you multiply that you suddenly

1031
00:36:04,320 --> 00:36:05,520
get this

1032
00:36:05,520 --> 00:36:08,800
um yeah this information about leading

1033
00:36:08,800 --> 00:36:12,480
zero bytes

1034
00:36:12,480 --> 00:36:15,920
okay um so the raccoon attack

1035
00:36:15,920 --> 00:36:18,160
also interacts in other protocols so we

1036
00:36:18,160 --> 00:36:18,960
are tls

1037
00:36:18,960 --> 00:36:21,359
people and so we mostly focus our

1038
00:36:21,359 --> 00:36:22,640
analysis on tls but

1039
00:36:22,640 --> 00:36:26,079
it's actually not very tls specific so

1040
00:36:26,079 --> 00:36:28,720
it can also work perfectly fine in other

1041
00:36:28,720 --> 00:36:30,800
protocols

1042
00:36:30,800 --> 00:36:34,160
and for example we looked at ssh and ssh

1043
00:36:34,160 --> 00:36:34,960
also does

1044
00:36:34,960 --> 00:36:39,680
strip leading zero bytes fortunately ssh

1045
00:36:39,680 --> 00:36:42,560
does not reuse the family key so the ssh

1046
00:36:42,560 --> 00:36:43,680
developers are a little bit more

1047
00:36:43,680 --> 00:36:45,520
paranoid since the service on the line

1048
00:36:45,520 --> 00:36:46,079
so they

1049
00:36:46,079 --> 00:36:49,359
do not take these shortcuts

1050
00:36:49,359 --> 00:36:51,520
so ssh is probably secure against the

1051
00:36:51,520 --> 00:36:52,800
current attack

1052
00:36:52,800 --> 00:36:55,680
but your favorite protocol might be not

1053
00:36:55,680 --> 00:36:56,160
so

1054
00:36:56,160 --> 00:36:58,240
we did not look at every cryptographic

1055
00:36:58,240 --> 00:37:00,079
protocol in existence

1056
00:37:00,079 --> 00:37:01,839
um so maybe this is a good time for you

1057
00:37:01,839 --> 00:37:05,359
to check your own protocols if they are

1058
00:37:05,359 --> 00:37:07,119
in a scenario where they are leaking

1059
00:37:07,119 --> 00:37:08,560
leading zero beds and if

1060
00:37:08,560 --> 00:37:09,839
those leading zero bytes might be

1061
00:37:09,839 --> 00:37:12,160
exploitable or not so

1062
00:37:12,160 --> 00:37:15,520
you can contribute to research here

1063
00:37:15,520 --> 00:37:17,839
okay to conclude um there's no need to

1064
00:37:17,839 --> 00:37:19,280
panic the raccoon attack is actually

1065
00:37:19,280 --> 00:37:21,280
very very hard to exploit so you have to

1066
00:37:21,280 --> 00:37:22,960
measure very price

1067
00:37:22,960 --> 00:37:26,400
precise timing and this is very very

1068
00:37:26,400 --> 00:37:28,160
hard in practice so we could

1069
00:37:28,160 --> 00:37:31,200
do it in a in a lab setting

1070
00:37:31,200 --> 00:37:33,920
with special network equipment but in

1071
00:37:33,920 --> 00:37:35,599
the real world where the attackers

1072
00:37:35,599 --> 00:37:37,280
on the internet or stuff like that it's

1073
00:37:37,280 --> 00:37:38,720
really really hard to pull off because

1074
00:37:38,720 --> 00:37:40,480
the side chain is so small

1075
00:37:40,480 --> 00:37:43,040
however if you have these bugs which um

1076
00:37:43,040 --> 00:37:43,920
where you

1077
00:37:43,920 --> 00:37:46,000
leak for leading zero bite directly then

1078
00:37:46,000 --> 00:37:47,760
it's actually very very exploitable and

1079
00:37:47,760 --> 00:37:50,880
very very dangerous

1080
00:37:50,880 --> 00:37:52,400
also the root contact is not yet

1081
00:37:52,400 --> 00:37:54,560
specific as mentioned you can

1082
00:37:54,560 --> 00:37:55,920
find viral kunatak also in other

1083
00:37:55,920 --> 00:37:57,599
protocols potentially

1084
00:37:57,599 --> 00:38:01,280
so the community has some work to do

1085
00:38:01,280 --> 00:38:03,920
and also what's nice about raccoon tech

1086
00:38:03,920 --> 00:38:05,280
is that's actually the first time the

1087
00:38:05,280 --> 00:38:06,800
hidden number problem is used to attack

1088
00:38:06,800 --> 00:38:08,880
divi hermann in a practic

1089
00:38:08,880 --> 00:38:11,200
practical protocol sense um like the

1090
00:38:11,200 --> 00:38:13,520
hidden number problem was actually first

1091
00:38:13,520 --> 00:38:16,839
um defined or designed

1092
00:38:16,839 --> 00:38:20,800
to analyze how difficult reacts if you

1093
00:38:20,800 --> 00:38:24,240
leak leading bytes but this is the first

1094
00:38:24,240 --> 00:38:25,680
time this is used in practice to

1095
00:38:25,680 --> 00:38:27,520
actually detective here and usually

1096
00:38:27,520 --> 00:38:31,119
it's used to attack ecdsa or dss or

1097
00:38:31,119 --> 00:38:34,960
dsa and this was also very nice

1098
00:38:34,960 --> 00:38:36,320
so if you want to find more information

1099
00:38:36,320 --> 00:38:37,760
on raccoon attack or you want to read

1100
00:38:37,760 --> 00:38:39,119
your paper you can find it on

1101
00:38:39,119 --> 00:38:41,520
raccoon attack.com and if you want to

1102
00:38:41,520 --> 00:38:42,960
find out if your servers actually win a

1103
00:38:42,960 --> 00:38:44,800
bit to raccoon attack or the director

1104
00:38:44,800 --> 00:38:45,599
could attack

1105
00:38:45,599 --> 00:38:49,280
we have a tls scanner

1106
00:38:49,280 --> 00:38:51,280
it's also called tscana on the github

1107
00:38:51,280 --> 00:38:52,880
repo you can download and

1108
00:38:52,880 --> 00:38:55,119
checks um or also implementation

1109
00:38:55,119 --> 00:38:56,560
specific variants with these

1110
00:38:56,560 --> 00:38:58,440
deterministic and non-deterministic side

1111
00:38:58,440 --> 00:39:00,079
channels notes

1112
00:39:00,079 --> 00:39:02,160
if you have any questions towards me you

1113
00:39:02,160 --> 00:39:03,760
can either ask me in the chat or contact

1114
00:39:03,760 --> 00:39:05,280
me via twitter

1115
00:39:05,280 --> 00:39:09,720
or pay email thanks and have a great day

1116
00:39:09,720 --> 00:39:12,720
bye

