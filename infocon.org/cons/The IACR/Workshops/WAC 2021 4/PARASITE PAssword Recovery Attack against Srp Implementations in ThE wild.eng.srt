1
00:00:02,639 --> 00:00:03,040
hi

2
00:00:03,040 --> 00:00:04,720
and welcome to the extending version of

3
00:00:04,720 --> 00:00:07,040
my talk on the parasite attack

4
00:00:07,040 --> 00:00:09,360
my name is daniel der medabaga and i'm a

5
00:00:09,360 --> 00:00:10,400
phd student

6
00:00:10,400 --> 00:00:12,240
under the supervision of piranha hook

7
00:00:12,240 --> 00:00:13,679
and mohammed sapp

8
00:00:13,679 --> 00:00:16,000
working on finding practical attacks on

9
00:00:16,000 --> 00:00:18,000
cryptographic implementation in order to

10
00:00:18,000 --> 00:00:18,720
highlight

11
00:00:18,720 --> 00:00:21,439
weak spots and hopefully make developer

12
00:00:21,439 --> 00:00:23,519
more sensitive about some issue

13
00:00:23,519 --> 00:00:26,000
that really need to be fixed the main

14
00:00:26,000 --> 00:00:27,119
idea behind my work

15
00:00:27,119 --> 00:00:29,439
is to clearly identify new attack

16
00:00:29,439 --> 00:00:30,400
vectors

17
00:00:30,400 --> 00:00:32,558
and show how practical they may be so

18
00:00:32,558 --> 00:00:33,840
that they are considered

19
00:00:33,840 --> 00:00:37,440
seriously there is often as much work in

20
00:00:37,440 --> 00:00:39,200
finding the issue as there is in

21
00:00:39,200 --> 00:00:40,719
actually exploiting them

22
00:00:40,719 --> 00:00:43,440
as you may notice during this talk

23
00:00:43,440 --> 00:00:44,079
particular

24
00:00:44,079 --> 00:00:47,520
talk is about our most recent paper

25
00:00:47,520 --> 00:00:49,760
untitled parasite for password recovery

26
00:00:49,760 --> 00:00:52,079
attack against srp implementation in the

27
00:00:52,079 --> 00:00:52,960
wild

28
00:00:52,960 --> 00:00:55,120
which is a work by me and my two

29
00:00:55,120 --> 00:00:56,079
supervisor

30
00:00:56,079 --> 00:01:00,640
that was accepted at ccs2021

31
00:01:00,640 --> 00:01:03,120
the goal of this talk is not only to

32
00:01:03,120 --> 00:01:03,680
discuss

33
00:01:03,680 --> 00:01:05,840
about our paper but also to outline some

34
00:01:05,840 --> 00:01:07,360
properties of bakes

35
00:01:07,360 --> 00:01:09,600
which makes them particularly sensitive

36
00:01:09,600 --> 00:01:11,760
to side channel attacks

37
00:01:11,760 --> 00:01:13,840
so i will start by giving a bit of

38
00:01:13,840 --> 00:01:16,479
background on pegs and why we decided to

39
00:01:16,479 --> 00:01:17,759
look at them

40
00:01:17,759 --> 00:01:19,439
and their implementation before

41
00:01:19,439 --> 00:01:21,600
summarizing our actual contributions

42
00:01:21,600 --> 00:01:24,560
and dive into some detail of our work i

43
00:01:24,560 --> 00:01:24,960
will

44
00:01:24,960 --> 00:01:27,520
end up with the impact analysis of some

45
00:01:27,520 --> 00:01:28,880
affected projects

46
00:01:28,880 --> 00:01:31,600
and a small discussion on the mitigation

47
00:01:31,600 --> 00:01:34,079
of the vulnerability

48
00:01:34,079 --> 00:01:37,119
so first what's a peck and why did we

49
00:01:37,119 --> 00:01:40,720
look at them sometimes you may

50
00:01:40,720 --> 00:01:42,880
want or simply need to be able to

51
00:01:42,880 --> 00:01:45,040
establish a secure communication channel

52
00:01:45,040 --> 00:01:47,439
only based on the knowledge of a quite

53
00:01:47,439 --> 00:01:49,119
short password

54
00:01:49,119 --> 00:01:51,040
this mainly the case when you don't want

55
00:01:51,040 --> 00:01:52,159
to manage

56
00:01:52,159 --> 00:01:55,040
public infrastructure or more generally

57
00:01:55,040 --> 00:01:56,880
when you want to derive

58
00:01:56,880 --> 00:01:58,719
some cryptographic material from the

59
00:01:58,719 --> 00:01:59,920
mere knowledge of

60
00:01:59,920 --> 00:02:03,920
a password so that's basically what

61
00:02:03,920 --> 00:02:06,320
bakes for password authenticated key

62
00:02:06,320 --> 00:02:07,040
exchange

63
00:02:07,040 --> 00:02:10,800
r4 there are an interactive protocol

64
00:02:10,800 --> 00:02:12,879
aiming to combine the key exchange and

65
00:02:12,879 --> 00:02:14,239
the authentication part

66
00:02:14,239 --> 00:02:16,560
of a protocol and the knowledge of the

67
00:02:16,560 --> 00:02:18,319
password will be used to authenticate

68
00:02:18,319 --> 00:02:19,040
the user

69
00:02:19,040 --> 00:02:21,520
and from this low entropy secret both

70
00:02:21,520 --> 00:02:22,800
parts will end up

71
00:02:22,800 --> 00:02:24,640
sharing some strong cryptographic

72
00:02:24,640 --> 00:02:26,640
material

73
00:02:26,640 --> 00:02:28,879
of course as we are dealing with low

74
00:02:28,879 --> 00:02:30,400
entropy password

75
00:02:30,400 --> 00:02:33,120
they have to protect against dictionary

76
00:02:33,120 --> 00:02:33,680
attacks

77
00:02:33,680 --> 00:02:37,440
namely offline dictionary attacks

78
00:02:37,440 --> 00:02:39,760
and there are a lot of different peaks

79
00:02:39,760 --> 00:02:41,040
but we can distinguish

80
00:02:41,040 --> 00:02:43,440
two main family on one side we have

81
00:02:43,440 --> 00:02:44,560
balance pack

82
00:02:44,560 --> 00:02:48,560
where bost both side knows the password

83
00:02:48,560 --> 00:02:50,560
on the other side we have asymmetric

84
00:02:50,560 --> 00:02:51,840
pegs where there is

85
00:02:51,840 --> 00:02:54,959
some clear hole of client and server and

86
00:02:54,959 --> 00:02:57,120
only the client will know the password

87
00:02:57,120 --> 00:02:59,040
while the server only know a password

88
00:02:59,040 --> 00:03:00,800
derivative value called

89
00:03:00,800 --> 00:03:04,480
the verifier so

90
00:03:04,480 --> 00:03:08,319
why did we decide to take a look at pigs

91
00:03:08,319 --> 00:03:10,319
pigs are around for quite a long time

92
00:03:10,319 --> 00:03:12,720
now and there are many schemes but

93
00:03:12,720 --> 00:03:13,680
adoption was

94
00:03:13,680 --> 00:03:16,000
really slowed down by patents on the

95
00:03:16,000 --> 00:03:17,040
first

96
00:03:17,040 --> 00:03:20,400
pegs and some designs are kind of

97
00:03:20,400 --> 00:03:21,920
weird because of the patent's

98
00:03:21,920 --> 00:03:24,159
circumvention making the security proof

99
00:03:24,159 --> 00:03:28,239
quite hard however recently we've seen

100
00:03:28,239 --> 00:03:30,640
speed up a significant speeder for fake

101
00:03:30,640 --> 00:03:31,599
adoption

102
00:03:31,599 --> 00:03:34,879
with two notable facts first

103
00:03:34,879 --> 00:03:38,000
the choice of dragonfly to secure wpa3

104
00:03:38,000 --> 00:03:40,879
the new wi-fi standards and second the

105
00:03:40,879 --> 00:03:42,560
recent patent exploration

106
00:03:42,560 --> 00:03:44,879
on original design which triggered a

107
00:03:44,879 --> 00:03:47,360
cfrg standardization competition which

108
00:03:47,360 --> 00:03:48,959
ended up quite recently

109
00:03:48,959 --> 00:03:52,159
a couple of years ago and this recent

110
00:03:52,159 --> 00:03:52,720
interest

111
00:03:52,720 --> 00:03:55,280
also tickled academics and we've seen

112
00:03:55,280 --> 00:03:56,159
some work

113
00:03:56,159 --> 00:03:57,599
assessing their security both

114
00:03:57,599 --> 00:04:00,560
theoretical and practical we can mention

115
00:04:00,560 --> 00:04:02,640
the dragon blood attack that made quite

116
00:04:02,640 --> 00:04:04,480
some noise a couple years ago

117
00:04:04,480 --> 00:04:06,080
and more recently the partitioning

118
00:04:06,080 --> 00:04:08,000
oracle attack which applies to some

119
00:04:08,000 --> 00:04:12,080
insecure opaque implementations

120
00:04:12,080 --> 00:04:14,239
in the light of the vulnerability we

121
00:04:14,239 --> 00:04:15,519
can't stress

122
00:04:15,519 --> 00:04:17,440
enough that side channel leaks are

123
00:04:17,440 --> 00:04:19,199
disastrous for bake

124
00:04:19,199 --> 00:04:21,120
since they may leak information on a

125
00:04:21,120 --> 00:04:23,040
very low entropy value

126
00:04:23,040 --> 00:04:25,120
and each bit may be used independently

127
00:04:25,120 --> 00:04:29,280
to halve the set of possible passwords

128
00:04:29,280 --> 00:04:30,960
in this talk we'll discuss about a

129
00:04:30,960 --> 00:04:32,560
particular page named

130
00:04:32,560 --> 00:04:35,520
srp for secure remote password which is

131
00:04:35,520 --> 00:04:36,320
among the most

132
00:04:36,320 --> 00:04:39,919
deployed in a lot of context

133
00:04:41,360 --> 00:04:44,800
and srp has been around since 1998

134
00:04:44,800 --> 00:04:46,880
and it's the most deployed because it

135
00:04:46,880 --> 00:04:48,639
was one of the only peak

136
00:04:48,639 --> 00:04:51,600
at this time that was not patent and

137
00:04:51,600 --> 00:04:52,720
there was a free

138
00:04:52,720 --> 00:04:54,840
open source implementation made

139
00:04:54,840 --> 00:04:56,320
available

140
00:04:56,320 --> 00:04:59,360
and there has not been a lot of work

141
00:04:59,360 --> 00:05:02,560
uh on srp recently we have seen a few

142
00:05:02,560 --> 00:05:04,320
issues that have been outlined

143
00:05:04,320 --> 00:05:06,320
leading to adjustment of the protocol

144
00:05:06,320 --> 00:05:07,680
that's why we're at

145
00:05:07,680 --> 00:05:10,800
version 6a but there is

146
00:05:10,800 --> 00:05:13,520
not much recent analysis of the protocol

147
00:05:13,520 --> 00:05:16,080
or its implementations

148
00:05:16,080 --> 00:05:19,600
this year at acns we saw a paper showing

149
00:05:19,600 --> 00:05:20,560
a side channel attack

150
00:05:20,560 --> 00:05:22,720
based on power analysis on apple's

151
00:05:22,720 --> 00:05:24,160
crypto core library

152
00:05:24,160 --> 00:05:26,960
implementation of srp which share quite

153
00:05:26,960 --> 00:05:29,120
some similarities with our attack

154
00:05:29,120 --> 00:05:31,840
however we didn't use the same side

155
00:05:31,840 --> 00:05:32,960
channel attack

156
00:05:32,960 --> 00:05:34,479
the target is different and the

157
00:05:34,479 --> 00:05:36,560
practicality of the attack

158
00:05:36,560 --> 00:05:39,680
is not the same

159
00:05:39,680 --> 00:05:41,919
so let's uh let's say a few words about

160
00:05:41,919 --> 00:05:43,039
srp

161
00:05:43,039 --> 00:05:45,600
first it's an asymmetric peg so there is

162
00:05:45,600 --> 00:05:47,520
really a client and a server

163
00:05:47,520 --> 00:05:50,639
roles the client will know the password

164
00:05:50,639 --> 00:05:51,759
while the server will

165
00:05:51,759 --> 00:05:54,880
only know a verifier which is always the

166
00:05:54,880 --> 00:05:55,280
same

167
00:05:55,280 --> 00:05:58,639
and is computing once at registration

168
00:05:58,639 --> 00:06:00,800
time

169
00:06:00,800 --> 00:06:02,080
an element to notice is that the

170
00:06:02,080 --> 00:06:03,680
protocol security relies on the

171
00:06:03,680 --> 00:06:05,280
difficulty of solving the discrete

172
00:06:05,280 --> 00:06:06,560
logarithm problem

173
00:06:06,560 --> 00:06:08,160
on infinite fields with some

174
00:06:08,160 --> 00:06:11,199
standardized parameters

175
00:06:11,199 --> 00:06:13,840
the protocols go as follows first the

176
00:06:13,840 --> 00:06:15,600
client will start the exchange by

177
00:06:15,600 --> 00:06:16,880
sending their id

178
00:06:16,880 --> 00:06:19,840
and an ephemeral key share to the server

179
00:06:19,840 --> 00:06:21,520
after which the server gets

180
00:06:21,520 --> 00:06:23,280
the corresponding information from its

181
00:06:23,280 --> 00:06:25,039
database namely the salt

182
00:06:25,039 --> 00:06:28,240
and the verifier and sends the verifier

183
00:06:28,240 --> 00:06:31,600
masked with an ephemeral keyshare

184
00:06:31,600 --> 00:06:34,000
when the client gets it they can compute

185
00:06:34,000 --> 00:06:35,280
the verifier

186
00:06:35,280 --> 00:06:37,840
and both sides can end up with the same

187
00:06:37,840 --> 00:06:39,199
cryptographic key

188
00:06:39,199 --> 00:06:42,800
so this is the commit step

189
00:06:42,800 --> 00:06:44,319
this step is followed by a more

190
00:06:44,319 --> 00:06:45,919
classical verification

191
00:06:45,919 --> 00:06:47,919
where both sides send each other the

192
00:06:47,919 --> 00:06:49,840
hash mark of the session transcript

193
00:06:49,840 --> 00:06:52,080
authenticated by a key derived derived

194
00:06:52,080 --> 00:06:55,840
from the result of the commit step

195
00:06:56,080 --> 00:06:57,520
one operation you want to be

196
00:06:57,520 --> 00:06:59,360
particularly careful with is the

197
00:06:59,360 --> 00:07:00,400
computation of

198
00:07:00,400 --> 00:07:03,120
j to the power x on the client's side

199
00:07:03,120 --> 00:07:04,960
aka the verifier

200
00:07:04,960 --> 00:07:06,479
since here the exponent is

201
00:07:06,479 --> 00:07:09,120
deterministically computed from

202
00:07:09,120 --> 00:07:11,919
two fixed public value the id and the

203
00:07:11,919 --> 00:07:12,960
result

204
00:07:12,960 --> 00:07:16,080
and the secret password but we'll get

205
00:07:16,080 --> 00:07:18,479
back to the point a little bit later

206
00:07:18,479 --> 00:07:22,080
for now let's sum up our contribution

207
00:07:22,080 --> 00:07:24,960
we reviewed a few srp implementation

208
00:07:24,960 --> 00:07:26,240
that we found to

209
00:07:26,240 --> 00:07:28,800
be used in various projects and we end

210
00:07:28,800 --> 00:07:29,680
up noticing that

211
00:07:29,680 --> 00:07:32,560
a lot of them relies on the same root

212
00:07:32,560 --> 00:07:33,440
library

213
00:07:33,440 --> 00:07:36,160
to perform the core arithmetic operation

214
00:07:36,160 --> 00:07:37,360
namely they relies

215
00:07:37,360 --> 00:07:40,639
on openssl and by digging up a little

216
00:07:40,639 --> 00:07:41,120
bit on

217
00:07:41,120 --> 00:07:43,199
openssl supplementation we found some

218
00:07:43,199 --> 00:07:45,120
leakage in the core implementation of

219
00:07:45,120 --> 00:07:47,440
the modular exponentiation

220
00:07:47,440 --> 00:07:50,000
that we managed to exploit to perform an

221
00:07:50,000 --> 00:07:51,680
offline dictionary attack allowing to

222
00:07:51,680 --> 00:07:53,599
recover the right password

223
00:07:53,599 --> 00:07:58,000
in realistic sized dictionary

224
00:07:58,000 --> 00:08:00,319
also performed an impact analysis on

225
00:08:00,319 --> 00:08:01,919
various projects that we found to be

226
00:08:01,919 --> 00:08:03,039
vulnerable

227
00:08:03,039 --> 00:08:05,280
and developed a full proof of concept of

228
00:08:05,280 --> 00:08:07,120
on our experimental setup

229
00:08:07,120 --> 00:08:09,520
for some of them that we published on

230
00:08:09,520 --> 00:08:11,360
our gitlab after the vulnerability has

231
00:08:11,360 --> 00:08:13,840
been patched

232
00:08:14,240 --> 00:08:16,800
so let's review our contribution in more

233
00:08:16,800 --> 00:08:17,759
details

234
00:08:17,759 --> 00:08:20,080
we have a cache attack that lets us

235
00:08:20,080 --> 00:08:21,440
extract information during

236
00:08:21,440 --> 00:08:23,680
openssl modular exponentiation which

237
00:08:23,680 --> 00:08:25,840
allow to recover the password with a

238
00:08:25,840 --> 00:08:29,360
single measurement so first

239
00:08:29,360 --> 00:08:32,080
this is a cache based side channel

240
00:08:32,080 --> 00:08:32,958
attack

241
00:08:32,958 --> 00:08:34,880
which means that we exploit some cpu

242
00:08:34,880 --> 00:08:36,719
properties and behavior to leak

243
00:08:36,719 --> 00:08:39,200
information on the secrets

244
00:08:39,200 --> 00:08:42,719
in particular we used a flashing red

245
00:08:42,719 --> 00:08:44,320
attack coupled with a performance

246
00:08:44,320 --> 00:08:48,399
degradation attack to come to our end

247
00:08:49,440 --> 00:08:51,360
before giving some explanation on

248
00:08:51,360 --> 00:08:53,760
flushing reload let's remind that cpu

249
00:08:53,760 --> 00:08:55,839
have caches which are basically very

250
00:08:55,839 --> 00:08:56,320
fast

251
00:08:56,320 --> 00:08:58,480
access memory they use to store

252
00:08:58,480 --> 00:09:00,000
instruction

253
00:09:00,000 --> 00:09:03,279
they execute and to store the data that

254
00:09:03,279 --> 00:09:04,640
they use to

255
00:09:04,640 --> 00:09:07,920
perform the instruction the use of

256
00:09:07,920 --> 00:09:09,760
flushing reload is for the attacker to

257
00:09:09,760 --> 00:09:10,560
be able to

258
00:09:10,560 --> 00:09:13,600
monitor the calls to some very specific

259
00:09:13,600 --> 00:09:16,480
instruction used by the victim and there

260
00:09:16,480 --> 00:09:18,320
is basically two constraints to perform

261
00:09:18,320 --> 00:09:19,360
this attack

262
00:09:19,360 --> 00:09:21,680
first the attacker and the victim needs

263
00:09:21,680 --> 00:09:24,720
to share the same cpu caches

264
00:09:24,720 --> 00:09:26,560
and second the attacker need to be able

265
00:09:26,560 --> 00:09:28,959
to map the address space

266
00:09:28,959 --> 00:09:31,680
of the victim process or at least the

267
00:09:31,680 --> 00:09:33,519
part containing the instruction to

268
00:09:33,519 --> 00:09:35,519
monitor

269
00:09:35,519 --> 00:09:37,519
to give you a quick example let's

270
00:09:37,519 --> 00:09:38,720
imagine that the attacker wants to

271
00:09:38,720 --> 00:09:40,399
monitor the function

272
00:09:40,399 --> 00:09:42,720
from let's say openssl which is used by

273
00:09:42,720 --> 00:09:44,000
the victim

274
00:09:44,000 --> 00:09:45,920
first the attacker will need to load

275
00:09:45,920 --> 00:09:48,320
openssl library into memory

276
00:09:48,320 --> 00:09:50,800
in order to access the same address as

277
00:09:50,800 --> 00:09:51,760
the victim

278
00:09:51,760 --> 00:09:55,279
for the instruction foo from this point

279
00:09:55,279 --> 00:09:57,120
onward the address space of openness

280
00:09:57,120 --> 00:09:57,920
library is

281
00:09:57,920 --> 00:09:59,839
shared this means that if either the

282
00:09:59,839 --> 00:10:01,519
attacker or the victim

283
00:10:01,519 --> 00:10:05,440
load instruction meaning execute it

284
00:10:05,440 --> 00:10:08,560
both can see this instruction and can

285
00:10:08,560 --> 00:10:11,440
access it in the cache

286
00:10:11,440 --> 00:10:13,200
from there the attacker only needs to

287
00:10:13,200 --> 00:10:14,480
flash the instruction

288
00:10:14,480 --> 00:10:16,720
out of the cache so this is a flash part

289
00:10:16,720 --> 00:10:18,079
of the attack we don't need any

290
00:10:18,079 --> 00:10:19,839
privileges to do it

291
00:10:19,839 --> 00:10:22,480
and simply measure how long it takes to

292
00:10:22,480 --> 00:10:24,160
reload this instruction so

293
00:10:24,160 --> 00:10:27,600
to execute it and there we have two

294
00:10:27,600 --> 00:10:30,560
possibilities first if the victim

295
00:10:30,560 --> 00:10:32,320
executed it in the meantime

296
00:10:32,320 --> 00:10:34,640
it is already in the cpu cache it is

297
00:10:34,640 --> 00:10:35,680
already reloaded

298
00:10:35,680 --> 00:10:38,320
so the reload step on the attacker side

299
00:10:38,320 --> 00:10:40,160
will be very fast

300
00:10:40,160 --> 00:10:43,120
otherwise the attackers need to look for

301
00:10:43,120 --> 00:10:45,120
the instruction in higher memory level

302
00:10:45,120 --> 00:10:47,360
which will be slower to access

303
00:10:47,360 --> 00:10:49,440
and this time difference make the

304
00:10:49,440 --> 00:10:50,880
attacker able to

305
00:10:50,880 --> 00:10:53,360
know whether or not the victim executed

306
00:10:53,360 --> 00:10:54,640
the instruction

307
00:10:54,640 --> 00:10:56,880
so the idea is to loop over this process

308
00:10:56,880 --> 00:10:57,680
and track

309
00:10:57,680 --> 00:10:59,200
the execution of this particular

310
00:10:59,200 --> 00:11:01,519
instruction

311
00:11:01,519 --> 00:11:03,040
once you get the id for the flash and

312
00:11:03,040 --> 00:11:05,200
real attack the performance degradation

313
00:11:05,200 --> 00:11:06,640
attack is quite easy because it's

314
00:11:06,640 --> 00:11:07,200
basically

315
00:11:07,200 --> 00:11:09,600
the first part of the attack the flash

316
00:11:09,600 --> 00:11:10,480
part

317
00:11:10,480 --> 00:11:12,720
the idea is to flush again and again

318
00:11:12,720 --> 00:11:14,640
some particular instruction in order to

319
00:11:14,640 --> 00:11:16,560
degrade the overall performance

320
00:11:16,560 --> 00:11:18,800
of the victim process on this

321
00:11:18,800 --> 00:11:20,959
instruction

322
00:11:20,959 --> 00:11:23,440
so the performance degradation attack

323
00:11:23,440 --> 00:11:25,920
will not allow us to track the execution

324
00:11:25,920 --> 00:11:26,720
per se

325
00:11:26,720 --> 00:11:29,040
but it's more of a tool that we can use

326
00:11:29,040 --> 00:11:30,720
to make the measurement easier to

327
00:11:30,720 --> 00:11:31,360
increase

328
00:11:31,360 --> 00:11:34,079
the leakage and basically make the

329
00:11:34,079 --> 00:11:36,800
overall attack much more accurate

330
00:11:36,800 --> 00:11:38,959
we'll talk a little bit later about how

331
00:11:38,959 --> 00:11:42,560
we combine these two attacks but to come

332
00:11:42,560 --> 00:11:44,079
back to our contribution

333
00:11:44,079 --> 00:11:46,160
we observed this leakage during the

334
00:11:46,160 --> 00:11:48,320
modular exponentiation of openssl

335
00:11:48,320 --> 00:11:50,720
because a weak algorithm is used when

336
00:11:50,720 --> 00:11:53,040
the client computes the verifier

337
00:11:53,040 --> 00:11:55,279
and this leaks some information on the

338
00:11:55,279 --> 00:11:57,440
password-related value

339
00:11:57,440 --> 00:11:59,680
with this leakage we can do a fully

340
00:11:59,680 --> 00:12:01,519
offline and completely passive

341
00:12:01,519 --> 00:12:03,519
dictionary attack

342
00:12:03,519 --> 00:12:06,880
with a single measurement this last

343
00:12:06,880 --> 00:12:08,399
point is quite important

344
00:12:08,399 --> 00:12:10,160
in the practical aspect of our attack

345
00:12:10,160 --> 00:12:12,240
because with me this means that with a

346
00:12:12,240 --> 00:12:13,920
single measurement we are accurate

347
00:12:13,920 --> 00:12:14,880
enough to get

348
00:12:14,880 --> 00:12:17,279
reliable data thanks to the combination

349
00:12:17,279 --> 00:12:18,800
of the flush and reload and performance

350
00:12:18,800 --> 00:12:20,399
degradation attack

351
00:12:20,399 --> 00:12:22,160
and more importantly we can extract

352
00:12:22,160 --> 00:12:23,760
enough information

353
00:12:23,760 --> 00:12:26,240
to perform a dictionary attack on a very

354
00:12:26,240 --> 00:12:29,920
large password dictionary

355
00:12:30,560 --> 00:12:32,880
now that we have seen and that we know

356
00:12:32,880 --> 00:12:34,639
where the problem comes from

357
00:12:34,639 --> 00:12:37,519
let's dig a little bit into the details

358
00:12:37,519 --> 00:12:38,880
as i said we attacked

359
00:12:38,880 --> 00:12:41,360
openssl's modular exponentiation so

360
00:12:41,360 --> 00:12:43,839
let's see how it works

361
00:12:43,839 --> 00:12:46,079
when you are dealing with an odd modulus

362
00:12:46,079 --> 00:12:47,920
which is the case in srp since the

363
00:12:47,920 --> 00:12:49,920
modulus is a large prime

364
00:12:49,920 --> 00:12:52,240
the main function will try to call three

365
00:12:52,240 --> 00:12:54,160
different subroutine in the following

366
00:12:54,160 --> 00:12:55,839
order

367
00:12:55,839 --> 00:12:58,560
first if the base is small enough to fit

368
00:12:58,560 --> 00:12:58,959
in

369
00:12:58,959 --> 00:13:01,440
one processor world and no constant time

370
00:13:01,440 --> 00:13:02,959
flag are set

371
00:13:02,959 --> 00:13:04,959
it calls an optimized square and

372
00:13:04,959 --> 00:13:08,639
multiply in montgomery form

373
00:13:08,639 --> 00:13:11,279
next if a constant time flag is set it

374
00:13:11,279 --> 00:13:12,959
calls the secure implementation of the

375
00:13:12,959 --> 00:13:14,880
montgomery exponentiation

376
00:13:14,880 --> 00:13:17,040
which includes some mitigation to side

377
00:13:17,040 --> 00:13:18,160
channel attacks

378
00:13:18,160 --> 00:13:21,120
including the flush and reload attack

379
00:13:21,120 --> 00:13:23,200
however if none of the above match our

380
00:13:23,200 --> 00:13:23,920
case

381
00:13:23,920 --> 00:13:26,480
it calls the classical sliding window

382
00:13:26,480 --> 00:13:28,399
exponentiation

383
00:13:28,399 --> 00:13:31,519
usually when we hear about attacks and

384
00:13:31,519 --> 00:13:33,279
modular exponentiation on opponent's

385
00:13:33,279 --> 00:13:35,519
cell the sliding window exponentiation

386
00:13:35,519 --> 00:13:36,639
is targeted

387
00:13:36,639 --> 00:13:38,399
this has been the case for one of the

388
00:13:38,399 --> 00:13:39,760
first side channel attack

389
00:13:39,760 --> 00:13:43,040
by percival in 2005 which led to the

390
00:13:43,040 --> 00:13:46,240
secure implementation that we have now

391
00:13:46,240 --> 00:13:49,760
but now and then we find some corner

392
00:13:49,760 --> 00:13:51,519
case where a flag is not set

393
00:13:51,519 --> 00:13:53,519
and it fall back to the sliding window

394
00:13:53,519 --> 00:13:54,560
exponentiation

395
00:13:54,560 --> 00:13:57,440
like in a recent use next paper that was

396
00:13:57,440 --> 00:14:00,000
published last year

397
00:14:00,000 --> 00:14:02,560
here it turns out that not only the flag

398
00:14:02,560 --> 00:14:03,839
the flag is never set

399
00:14:03,839 --> 00:14:06,800
but srp fills the requirement for the

400
00:14:06,800 --> 00:14:08,560
optimized implementation

401
00:14:08,560 --> 00:14:11,600
since the base j is 2 5

402
00:14:11,600 --> 00:14:14,639
or 19.

403
00:14:15,120 --> 00:14:18,160
so i think everyone agrees that using

404
00:14:18,160 --> 00:14:20,560
square multiply itself is an issue since

405
00:14:20,560 --> 00:14:23,199
we can in theory distinguish bits to 0

406
00:14:23,199 --> 00:14:25,920
and bits to 1 simply by looking at the

407
00:14:25,920 --> 00:14:28,480
operations that are performed

408
00:14:28,480 --> 00:14:31,199
in our case it's an optimized version

409
00:14:31,199 --> 00:14:32,000
where almost

410
00:14:32,000 --> 00:14:34,639
all operations are performed on a single

411
00:14:34,639 --> 00:14:36,399
processor world w

412
00:14:36,399 --> 00:14:38,800
which makes them really fast and quite

413
00:14:38,800 --> 00:14:39,600
hard to

414
00:14:39,600 --> 00:14:42,560
distinguish from one another to give you

415
00:14:42,560 --> 00:14:44,560
a better idea of how it works

416
00:14:44,560 --> 00:14:47,040
you can think of this algorithm as those

417
00:14:47,040 --> 00:14:48,399
japanese fountains

418
00:14:48,399 --> 00:14:50,800
which fills with water and then pour

419
00:14:50,800 --> 00:14:52,480
everything in a bigger recipient when

420
00:14:52,480 --> 00:14:53,440
they are full

421
00:14:53,440 --> 00:14:56,000
here the bigger recipient is our actual

422
00:14:56,000 --> 00:14:57,920
result which will be a big number in

423
00:14:57,920 --> 00:14:58,880
openssl

424
00:14:58,880 --> 00:15:02,720
cells and each bit

425
00:15:02,720 --> 00:15:05,760
of the exponents processed will drop one

426
00:15:05,760 --> 00:15:08,240
or two droplets in the accumulator w

427
00:15:08,240 --> 00:15:11,360
which will slowly fill up

428
00:15:11,360 --> 00:15:13,839
those drawer plates are very small and

429
00:15:13,839 --> 00:15:14,959
close to each other

430
00:15:14,959 --> 00:15:16,720
and we cannot distinguish them in

431
00:15:16,720 --> 00:15:19,760
practice with a flush and reload attack

432
00:15:19,760 --> 00:15:22,720
however when the accumulator is full and

433
00:15:22,720 --> 00:15:23,920
we spill the water

434
00:15:23,920 --> 00:15:26,160
into the bigger recipient the operations

435
00:15:26,160 --> 00:15:27,199
are significantly

436
00:15:27,199 --> 00:15:30,880
heavier and very more noticeable

437
00:15:30,880 --> 00:15:33,519
now what's very interesting about this

438
00:15:33,519 --> 00:15:34,800
is that

439
00:15:34,800 --> 00:15:37,279
for a given word size so for a given

440
00:15:37,279 --> 00:15:38,240
architecture

441
00:15:38,240 --> 00:15:40,639
and a value of j the base of the

442
00:15:40,639 --> 00:15:41,920
exponentiation

443
00:15:41,920 --> 00:15:44,160
the time it takes to fill the

444
00:15:44,160 --> 00:15:45,199
accumulator

445
00:15:45,199 --> 00:15:47,920
only depends on the number of droplets

446
00:15:47,920 --> 00:15:50,480
we pour into it

447
00:15:50,480 --> 00:15:52,560
in other words it only depends on the

448
00:15:52,560 --> 00:15:53,600
bit sequence

449
00:15:53,600 --> 00:15:55,759
of the exponent since the last

450
00:15:55,759 --> 00:15:58,000
arithmetic overflow of the accumulator

451
00:15:58,000 --> 00:16:01,440
and that's the key to our attack

452
00:16:01,839 --> 00:16:04,320
so let's see how the practical attack

453
00:16:04,320 --> 00:16:05,920
works

454
00:16:05,920 --> 00:16:08,480
we have a pretty classical attacker

455
00:16:08,480 --> 00:16:09,279
model for

456
00:16:09,279 --> 00:16:11,600
a cache attack with an unprivileged

457
00:16:11,600 --> 00:16:13,759
spyware running on the victim computer

458
00:16:13,759 --> 00:16:15,680
which is needed for the flash and reload

459
00:16:15,680 --> 00:16:17,360
attack to work since we need to share

460
00:16:17,360 --> 00:16:19,600
some processor cores

461
00:16:19,600 --> 00:16:21,680
and having an attacker and a man in the

462
00:16:21,680 --> 00:16:22,639
middle position

463
00:16:22,639 --> 00:16:25,040
may be a fool if we need to gather more

464
00:16:25,040 --> 00:16:25,839
information

465
00:16:25,839 --> 00:16:28,399
but it is not actually needed and our

466
00:16:28,399 --> 00:16:29,839
experiment shows that we get

467
00:16:29,839 --> 00:16:32,000
more than enough information from only

468
00:16:32,000 --> 00:16:36,240
one measurement

469
00:16:36,240 --> 00:16:38,560
here is the classical adapter workflow

470
00:16:38,560 --> 00:16:40,399
we are the legitimate user trained to

471
00:16:40,399 --> 00:16:42,720
connect to a service or anything using

472
00:16:42,720 --> 00:16:43,440
srp

473
00:16:43,440 --> 00:16:46,639
with their valid password if we meet our

474
00:16:46,639 --> 00:16:47,440
requirement

475
00:16:47,440 --> 00:16:49,839
we have our spy process monitoring the

476
00:16:49,839 --> 00:16:51,600
user activity

477
00:16:51,600 --> 00:16:53,920
hence when the client computes the

478
00:16:53,920 --> 00:16:55,759
verifier during srp

479
00:16:55,759 --> 00:16:57,920
the spy will generate some execution

480
00:16:57,920 --> 00:16:59,120
trace that can be

481
00:16:59,120 --> 00:17:03,199
passed with this trace passed we can

482
00:17:03,199 --> 00:17:05,520
extract some relevant information

483
00:17:05,520 --> 00:17:07,280
namely when did the accumulator

484
00:17:07,280 --> 00:17:08,880
overflowed and

485
00:17:08,880 --> 00:17:11,919
needed to be spilled into the results

486
00:17:11,919 --> 00:17:13,280
from this information we are able to

487
00:17:13,280 --> 00:17:15,599
perform an offline dictionary attack

488
00:17:15,599 --> 00:17:18,240
and remove any password which doesn't

489
00:17:18,240 --> 00:17:18,640
meet

490
00:17:18,640 --> 00:17:21,760
the criteria defined by the information

491
00:17:21,760 --> 00:17:24,160
we recovered

492
00:17:24,160 --> 00:17:25,919
let's get back to our exponentiation

493
00:17:25,919 --> 00:17:28,240
algorithm we can see in the middle

494
00:17:28,240 --> 00:17:30,880
that the actual result not the processor

495
00:17:30,880 --> 00:17:32,320
word but the big number

496
00:17:32,320 --> 00:17:35,120
results needs to be squared at each

497
00:17:35,120 --> 00:17:37,679
iteration to be kept updated

498
00:17:37,679 --> 00:17:39,360
and this is actually nice for the

499
00:17:39,360 --> 00:17:42,320
attacker since spying on this operation

500
00:17:42,320 --> 00:17:44,640
which is longer than a classical world

501
00:17:44,640 --> 00:17:46,640
squaring or multiplication

502
00:17:46,640 --> 00:17:48,880
allows us to distinguish one iteration

503
00:17:48,880 --> 00:17:50,480
from another

504
00:17:50,480 --> 00:17:52,240
in a classical iteration without

505
00:17:52,240 --> 00:17:53,600
arithmetic overflow

506
00:17:53,600 --> 00:17:56,160
of the value the result is only updated

507
00:17:56,160 --> 00:17:56,799
once

508
00:17:56,799 --> 00:17:59,919
however whenever w overflows the result

509
00:17:59,919 --> 00:18:00,640
is updated

510
00:18:00,640 --> 00:18:04,000
once more leading to a longer iteration

511
00:18:04,000 --> 00:18:06,240
we can slow down this iteration even

512
00:18:06,240 --> 00:18:07,679
more by applying the performance

513
00:18:07,679 --> 00:18:08,880
degradation attack

514
00:18:08,880 --> 00:18:10,880
in this piece of code making the

515
00:18:10,880 --> 00:18:12,840
overflowing iteration even more

516
00:18:12,840 --> 00:18:14,880
noticeable

517
00:18:14,880 --> 00:18:16,559
with this measurement we end up with

518
00:18:16,559 --> 00:18:18,240
quite nice graphs

519
00:18:18,240 --> 00:18:20,880
where each blue cross under the

520
00:18:20,880 --> 00:18:21,600
threshold

521
00:18:21,600 --> 00:18:24,240
represents a call to the squaring of the

522
00:18:24,240 --> 00:18:25,039
result

523
00:18:25,039 --> 00:18:28,480
hence a new iteration every time we get

524
00:18:28,480 --> 00:18:31,360
a long pause in between two crosses we

525
00:18:31,360 --> 00:18:35,280
have an overflow of the accumulator

526
00:18:35,440 --> 00:18:38,240
as stated earlier for a given word size

527
00:18:38,240 --> 00:18:40,160
and base the number of iterations

528
00:18:40,160 --> 00:18:41,120
between two

529
00:18:41,120 --> 00:18:43,600
flows only depends on the bit sequence

530
00:18:43,600 --> 00:18:45,120
of the exponent

531
00:18:45,120 --> 00:18:47,760
and we can quite easily map the number

532
00:18:47,760 --> 00:18:48,960
of iteration

533
00:18:48,960 --> 00:18:51,360
between two overflows to the bit pattern

534
00:18:51,360 --> 00:18:53,360
in the exponents and define some rules

535
00:18:53,360 --> 00:18:54,720
to apply to our trace

536
00:18:54,720 --> 00:18:57,840
in order to recover some bits value

537
00:18:57,840 --> 00:19:00,160
here is the set of rules we end up with

538
00:19:00,160 --> 00:19:02,960
for 64 bits architecture and the base

539
00:19:02,960 --> 00:19:06,080
j equal 5 which is the most commonly

540
00:19:06,080 --> 00:19:07,600
used base

541
00:19:07,600 --> 00:19:11,440
as of today here the value b

542
00:19:11,440 --> 00:19:14,640
represents an unknown bit and the four

543
00:19:14,640 --> 00:19:15,679
y's represent

544
00:19:15,679 --> 00:19:17,679
a subset of the possible values for

545
00:19:17,679 --> 00:19:19,840
those four bits

546
00:19:19,840 --> 00:19:21,840
notice that if we only get four

547
00:19:21,840 --> 00:19:24,240
iteration between two overflows we can

548
00:19:24,240 --> 00:19:24,720
guess

549
00:19:24,720 --> 00:19:27,200
exactly the value of three of those four

550
00:19:27,200 --> 00:19:28,400
exponent bits

551
00:19:28,400 --> 00:19:30,960
otherwise we can only guess part of the

552
00:19:30,960 --> 00:19:32,000
bits

553
00:19:32,000 --> 00:19:34,240
but we can still significantly reduce

554
00:19:34,240 --> 00:19:37,280
the set of possible values

555
00:19:37,280 --> 00:19:40,160
now consider that the trace give us the

556
00:19:40,160 --> 00:19:42,320
following execution flow where each

557
00:19:42,320 --> 00:19:45,440
v is an iteration and spaces denote

558
00:19:45,440 --> 00:19:48,400
overflows of the accumulator by simply

559
00:19:48,400 --> 00:19:50,320
applying the rule to each group

560
00:19:50,320 --> 00:19:53,280
of bits independently we can get a lot

561
00:19:53,280 --> 00:19:54,240
of information

562
00:19:54,240 --> 00:19:57,440
on this sequence however notice that we

563
00:19:57,440 --> 00:19:58,240
don't get

564
00:19:58,240 --> 00:20:01,039
as much information on the last group of

565
00:20:01,039 --> 00:20:01,440
bits

566
00:20:01,440 --> 00:20:04,159
since we don't know where when the

567
00:20:04,159 --> 00:20:07,840
accumulator would have overflowed

568
00:20:07,840 --> 00:20:10,799
now that we have recovered this sequence

569
00:20:10,799 --> 00:20:12,960
how do we find the password

570
00:20:12,960 --> 00:20:15,600
remember that the exponent x is defined

571
00:20:15,600 --> 00:20:16,000
by

572
00:20:16,000 --> 00:20:19,120
the password and two public values

573
00:20:19,120 --> 00:20:21,280
then the only thing an attacker needs to

574
00:20:21,280 --> 00:20:22,480
do is to take

575
00:20:22,480 --> 00:20:25,840
the recover bit sequence and compute

576
00:20:25,840 --> 00:20:27,760
the x value corresponding to all

577
00:20:27,760 --> 00:20:29,440
password candidates

578
00:20:29,440 --> 00:20:31,760
from its dictionary and see which one

579
00:20:31,760 --> 00:20:34,559
match the most

580
00:20:34,559 --> 00:20:36,880
of course we can't expect a full match

581
00:20:36,880 --> 00:20:39,360
since some other bits are not recovered

582
00:20:39,360 --> 00:20:39,760
but

583
00:20:39,760 --> 00:20:41,440
simply counting the differences allowed

584
00:20:41,440 --> 00:20:43,200
to highlight the

585
00:20:43,200 --> 00:20:45,679
most probable password which should have

586
00:20:45,679 --> 00:20:46,960
less differences

587
00:20:46,960 --> 00:20:50,400
than the other now let's discuss

588
00:20:50,400 --> 00:20:53,679
why do we need a single measurement

589
00:20:53,679 --> 00:20:56,000
to perform a realistic password

590
00:20:56,000 --> 00:20:58,640
dictionary attack

591
00:20:58,640 --> 00:21:00,240
first we have a very accurate

592
00:21:00,240 --> 00:21:02,000
measurement by combining the flush and

593
00:21:02,000 --> 00:21:03,840
reload and the performance degradation

594
00:21:03,840 --> 00:21:05,120
attack in such a way

595
00:21:05,120 --> 00:21:07,440
so there is almost no error and we are

596
00:21:07,440 --> 00:21:09,520
able to extract as much information as

597
00:21:09,520 --> 00:21:10,400
we could

598
00:21:10,400 --> 00:21:12,640
using our rules so we don't need to

599
00:21:12,640 --> 00:21:14,240
repeat our measurement in order to

600
00:21:14,240 --> 00:21:14,880
smooth

601
00:21:14,880 --> 00:21:18,080
out some errors second point is

602
00:21:18,080 --> 00:21:20,880
that on average we get a lot of

603
00:21:20,880 --> 00:21:22,240
information

604
00:21:22,240 --> 00:21:25,360
from a single exponentiation and even if

605
00:21:25,360 --> 00:21:27,280
this information is scattered across the

606
00:21:27,280 --> 00:21:28,159
exponent

607
00:21:28,159 --> 00:21:31,120
we can exploit each bit of information

608
00:21:31,120 --> 00:21:32,880
independently

609
00:21:32,880 --> 00:21:34,400
this is because the hash function

610
00:21:34,400 --> 00:21:36,559
behaves as a random oracle

611
00:21:36,559 --> 00:21:39,360
so for any password each bit of the

612
00:21:39,360 --> 00:21:40,799
corresponding x value

613
00:21:40,799 --> 00:21:43,760
has a 50 percent chance to match the

614
00:21:43,760 --> 00:21:46,240
trace we recovered

615
00:21:46,240 --> 00:21:48,400
this means that each bit of information

616
00:21:48,400 --> 00:21:49,280
we recover

617
00:21:49,280 --> 00:21:51,679
allows us to halve the set of possible

618
00:21:51,679 --> 00:21:52,720
password

619
00:21:52,720 --> 00:21:55,120
in other words if we recover k bits of

620
00:21:55,120 --> 00:21:55,919
information

621
00:21:55,919 --> 00:21:58,640
a wrong password only as 1 over 2 to the

622
00:21:58,640 --> 00:21:59,600
power k

623
00:21:59,600 --> 00:22:02,799
chance to match our trace

624
00:22:02,799 --> 00:22:05,679
and with our rule base pattern matching

625
00:22:05,679 --> 00:22:06,720
algorithm

626
00:22:06,720 --> 00:22:10,000
our n-bit exponent are still for

627
00:22:10,000 --> 00:22:13,679
j equals 5 and the 64-bit architecture

628
00:22:13,679 --> 00:22:17,200
we recover about 0.4 n plus 2

629
00:22:17,200 --> 00:22:20,000
bits of information meaning that using

630
00:22:20,000 --> 00:22:20,880
sha-1

631
00:22:20,880 --> 00:22:22,880
as it is the case in opponent's sales

632
00:22:22,880 --> 00:22:24,880
implementation of srp

633
00:22:24,880 --> 00:22:29,120
we get about 66 bits of information

634
00:22:29,120 --> 00:22:31,280
other implementation which switch to a

635
00:22:31,280 --> 00:22:33,440
more secure hash function such as

636
00:22:33,440 --> 00:22:36,880
shadow 256

637
00:22:36,880 --> 00:22:38,960
leaks even more information because the

638
00:22:38,960 --> 00:22:40,159
bigger the output of the

639
00:22:40,159 --> 00:22:42,000
function the more information we get

640
00:22:42,000 --> 00:22:44,720
from our trace

641
00:22:45,360 --> 00:22:48,000
as i said earlier we spent quite some

642
00:22:48,000 --> 00:22:48,400
time

643
00:22:48,400 --> 00:22:50,880
finding which project used this

644
00:22:50,880 --> 00:22:52,559
implementation

645
00:22:52,559 --> 00:22:54,480
of course openssl implementation is

646
00:22:54,480 --> 00:22:55,840
vulnerable but we

647
00:22:55,840 --> 00:22:59,280
rarely see tls srp being used however

648
00:22:59,280 --> 00:23:00,960
quite a few other projects

649
00:23:00,960 --> 00:23:03,840
used openssl api to provide an srp

650
00:23:03,840 --> 00:23:06,240
implementation

651
00:23:06,240 --> 00:23:09,600
first we can mention the case of apple

652
00:23:09,600 --> 00:23:12,400
homekit adk which is a development kit

653
00:23:12,400 --> 00:23:14,880
for apple connected device where srp is

654
00:23:14,880 --> 00:23:15,760
used to

655
00:23:15,760 --> 00:23:19,120
pair your apple phone laptop or

656
00:23:19,120 --> 00:23:22,480
tablet to an apple iot device using a

657
00:23:22,480 --> 00:23:23,600
pin code

658
00:23:23,600 --> 00:23:25,679
and those iot device range from garage

659
00:23:25,679 --> 00:23:28,159
door to light bulb or doorbell so we can

660
00:23:28,159 --> 00:23:28,880
think of

661
00:23:28,880 --> 00:23:32,240
a lot of issue it is also

662
00:23:32,240 --> 00:23:35,600
the case of pi srp which is a python

663
00:23:35,600 --> 00:23:38,240
srp reference package namely used by

664
00:23:38,240 --> 00:23:40,720
protonmaze python client to authenticate

665
00:23:40,720 --> 00:23:43,279
the client's open connection

666
00:23:43,279 --> 00:23:45,840
and it may also be the case of go to

667
00:23:45,840 --> 00:23:46,559
assist

668
00:23:46,559 --> 00:23:48,640
software for remote support allowing to

669
00:23:48,640 --> 00:23:50,880
share your screen and give control to

670
00:23:50,880 --> 00:23:51,440
your

671
00:23:51,440 --> 00:23:54,559
of your computer to an expert here srp

672
00:23:54,559 --> 00:23:55,679
is used to establish

673
00:23:55,679 --> 00:23:57,760
the secure session protecting screen

674
00:23:57,760 --> 00:23:58,720
sharing

675
00:23:58,720 --> 00:24:01,279
keyboard and mouse control diagnosis

676
00:24:01,279 --> 00:24:01,840
data

677
00:24:01,840 --> 00:24:04,240
and text chat thus an attacker

678
00:24:04,240 --> 00:24:06,000
recovering this secret password may be

679
00:24:06,000 --> 00:24:07,279
able to put themselves

680
00:24:07,279 --> 00:24:09,840
in an active man in the middle position

681
00:24:09,840 --> 00:24:10,559
achieving

682
00:24:10,559 --> 00:24:12,559
complete control over the victim

683
00:24:12,559 --> 00:24:16,400
computer by impersonating the its report

684
00:24:16,400 --> 00:24:18,720
for this last one this still has to be

685
00:24:18,720 --> 00:24:19,679
confirmed

686
00:24:19,679 --> 00:24:22,080
since their project is closed source but

687
00:24:22,080 --> 00:24:23,279
they clearly reference

688
00:24:23,279 --> 00:24:25,760
srp in their documentation and clearly

689
00:24:25,760 --> 00:24:27,840
state that they use openssl for the

690
00:24:27,840 --> 00:24:29,840
cryptographic implementation

691
00:24:29,840 --> 00:24:32,400
we contacted them but they did not

692
00:24:32,400 --> 00:24:35,840
respond to our emails

693
00:24:35,919 --> 00:24:38,320
finding that openssl is being used in

694
00:24:38,320 --> 00:24:39,360
this project

695
00:24:39,360 --> 00:24:42,320
made us wonder what about the more

696
00:24:42,320 --> 00:24:44,240
generic big number implementation

697
00:24:44,240 --> 00:24:47,760
in higher level languages and

698
00:24:47,760 --> 00:24:49,919
it turns out that there is basically two

699
00:24:49,919 --> 00:24:52,080
options

700
00:24:52,080 --> 00:24:54,159
maybe they reimplement it from scratch

701
00:24:54,159 --> 00:24:55,200
completely

702
00:24:55,200 --> 00:24:58,159
or maybe they rely on a lower level big

703
00:24:58,159 --> 00:24:59,600
number library

704
00:24:59,600 --> 00:25:03,360
like open ssl and it turns out that many

705
00:25:03,360 --> 00:25:04,400
reference package

706
00:25:04,400 --> 00:25:07,360
for either big number arithmetic or

707
00:25:07,360 --> 00:25:08,320
straight

708
00:25:08,320 --> 00:25:10,080
cryptographic implementation are

709
00:25:10,080 --> 00:25:12,480
basically mapping to open ssl

710
00:25:12,480 --> 00:25:15,120
inheriting its vulnerabilities and they

711
00:25:15,120 --> 00:25:16,400
usually don't bother

712
00:25:16,400 --> 00:25:19,360
touching the constant time flag which we

713
00:25:19,360 --> 00:25:19,679
can

714
00:25:19,679 --> 00:25:21,360
completely understand since they assume

715
00:25:21,360 --> 00:25:23,200
that the library to

716
00:25:23,200 --> 00:25:26,640
our is handling those things securely

717
00:25:26,640 --> 00:25:28,640
but this means that not only those

718
00:25:28,640 --> 00:25:29,760
package or library

719
00:25:29,760 --> 00:25:33,360
inherit the vulnerability but all srp

720
00:25:33,360 --> 00:25:36,559
implementation based on those are also

721
00:25:36,559 --> 00:25:37,760
vulnerable

722
00:25:37,760 --> 00:25:39,840
and it is hard to know exactly how many

723
00:25:39,840 --> 00:25:41,279
projects are impacted

724
00:25:41,279 --> 00:25:43,760
since some of them may be close source

725
00:25:43,760 --> 00:25:45,120
and even for

726
00:25:45,120 --> 00:25:47,919
open source projects it is not always

727
00:25:47,919 --> 00:25:49,279
very easy to know

728
00:25:49,279 --> 00:25:53,679
which project is implementing srp

729
00:25:54,400 --> 00:25:57,279
so we discussed this issue with openssl

730
00:25:57,279 --> 00:25:57,840
of course

731
00:25:57,840 --> 00:26:01,120
and two mitigation came out

732
00:26:01,120 --> 00:26:03,279
first we could simply add the

733
00:26:03,279 --> 00:26:04,320
constantine flag

734
00:26:04,320 --> 00:26:06,799
to the implementation of srp in openssl

735
00:26:06,799 --> 00:26:07,360
code

736
00:26:07,360 --> 00:26:09,600
this is very easy to do but it only

737
00:26:09,600 --> 00:26:11,039
patches open ssl's

738
00:26:11,039 --> 00:26:13,279
srp implementation and all other

739
00:26:13,279 --> 00:26:14,400
implementation which

740
00:26:14,400 --> 00:26:17,679
usually use the bing number api rather

741
00:26:17,679 --> 00:26:20,400
than the srp api from openssl

742
00:26:20,400 --> 00:26:24,000
will need to be patched independently

743
00:26:24,000 --> 00:26:26,960
a broader patch and more suitable for

744
00:26:26,960 --> 00:26:27,760
long term

745
00:26:27,760 --> 00:26:30,240
fix would be to switch to a secure by

746
00:26:30,240 --> 00:26:30,880
default

747
00:26:30,880 --> 00:26:33,600
approach namely on such sensitive

748
00:26:33,600 --> 00:26:35,200
function

749
00:26:35,200 --> 00:26:37,120
however the latter proposition was

750
00:26:37,120 --> 00:26:38,880
declined by openssl

751
00:26:38,880 --> 00:26:41,919
because of a potential performance loss

752
00:26:41,919 --> 00:26:44,720
and open cell choose to apply the first

753
00:26:44,720 --> 00:26:45,120
fix

754
00:26:45,120 --> 00:26:47,520
leaving most of the impacted projects

755
00:26:47,520 --> 00:26:50,158
vulnerable

756
00:26:50,320 --> 00:26:51,919
open a cell patch being deployed we

757
00:26:51,919 --> 00:26:53,760
contacted all other projects that we

758
00:26:53,760 --> 00:26:54,880
found to be vulnerable

759
00:26:54,880 --> 00:26:56,640
and most of which thanked us for our

760
00:26:56,640 --> 00:26:58,640
patch and applied it in a very timely

761
00:26:58,640 --> 00:26:59,600
manner

762
00:26:59,600 --> 00:27:02,159
however we mostly identified open source

763
00:27:02,159 --> 00:27:03,120
projects

764
00:27:03,120 --> 00:27:05,520
and proprietary software may still be

765
00:27:05,520 --> 00:27:06,320
vulnerable

766
00:27:06,320 --> 00:27:08,720
and we may have missed some open source

767
00:27:08,720 --> 00:27:10,960
projects

768
00:27:10,960 --> 00:27:14,080
now in nhl we described an attack on srp

769
00:27:14,080 --> 00:27:15,919
implementation which applies to many

770
00:27:15,919 --> 00:27:16,480
projects

771
00:27:16,480 --> 00:27:18,559
and packages and this attack is very

772
00:27:18,559 --> 00:27:20,080
practical because we could

773
00:27:20,080 --> 00:27:23,120
exploit the information on of each

774
00:27:23,120 --> 00:27:25,760
recovered bit independently and didn't

775
00:27:25,760 --> 00:27:27,919
need to recover the full exponent

776
00:27:27,919 --> 00:27:31,440
or anything like that this shows that

777
00:27:31,440 --> 00:27:33,600
even when audited library in their most

778
00:27:33,600 --> 00:27:35,679
critical functionality

779
00:27:35,679 --> 00:27:37,760
still have issues and that such

780
00:27:37,760 --> 00:27:39,919
analytics are very tricky to

781
00:27:39,919 --> 00:27:43,039
to detect it also shows us that we need

782
00:27:43,039 --> 00:27:44,880
to be extra careful when implementing

783
00:27:44,880 --> 00:27:45,600
peaks

784
00:27:45,600 --> 00:27:48,320
since the smallest issue may lead to a

785
00:27:48,320 --> 00:27:48,720
very

786
00:27:48,720 --> 00:27:51,919
big attack and finally

787
00:27:51,919 --> 00:27:54,240
the root cause of this vulnerability is

788
00:27:54,240 --> 00:27:56,559
a weak exponentiation algorithm which

789
00:27:56,559 --> 00:27:58,559
may be used in other protocols if the

790
00:27:58,559 --> 00:28:00,240
flag are not set carefully

791
00:28:00,240 --> 00:28:02,240
and if the base is small enough to fit

792
00:28:02,240 --> 00:28:03,919
in a processor world

793
00:28:03,919 --> 00:28:06,480
we couldn't actually think of another

794
00:28:06,480 --> 00:28:07,120
protocol

795
00:28:07,120 --> 00:28:10,720
which fits this description but if you

796
00:28:10,720 --> 00:28:12,399
find one feel free to contact us it

797
00:28:12,399 --> 00:28:14,840
could be the beginning of a nice

798
00:28:14,840 --> 00:28:16,240
collaboration

799
00:28:16,240 --> 00:28:17,919
thank you very much for your attention

800
00:28:17,919 --> 00:28:20,240
if you want more detail about our proof

801
00:28:20,240 --> 00:28:21,039
of concepts

802
00:28:21,039 --> 00:28:24,320
that are available on this gitlab pages

803
00:28:24,320 --> 00:28:26,559
and if you have any question or if you

804
00:28:26,559 --> 00:28:28,559
want to discuss it further feel free to

805
00:28:28,559 --> 00:28:29,520
contact me at

806
00:28:29,520 --> 00:28:34,960
this email address thank you very much

