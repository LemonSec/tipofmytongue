1
00:00:01,040 --> 00:00:03,360
hello i am mati vanu i'm currently a

2
00:00:03,360 --> 00:00:04,000
post-doc

3
00:00:04,000 --> 00:00:06,799
at nyu abu dhabi and later this year i

4
00:00:06,799 --> 00:00:08,400
will start as a professor at

5
00:00:08,400 --> 00:00:11,599
k11 today i will be presenting frag

6
00:00:11,599 --> 00:00:12,320
attacks

7
00:00:12,320 --> 00:00:14,920
aggregation on fragmentation flaws in

8
00:00:14,920 --> 00:00:16,320
wi-fi

9
00:00:16,320 --> 00:00:17,840
if we look at the history of wi-fi

10
00:00:17,840 --> 00:00:20,400
security we can see that initially

11
00:00:20,400 --> 00:00:23,519
wi-fi provided the web security protocol

12
00:00:23,519 --> 00:00:25,920
unfortunately it was quickly shown to be

13
00:00:25,920 --> 00:00:26,720
horribly

14
00:00:26,720 --> 00:00:30,800
broken in response wpa and wpa2 were

15
00:00:30,800 --> 00:00:31,840
released

16
00:00:31,840 --> 00:00:33,680
however these two protocols were

17
00:00:33,680 --> 00:00:36,559
vulnerable to offline dictionary attacks

18
00:00:36,559 --> 00:00:38,800
on a few years ago i also showed that

19
00:00:38,800 --> 00:00:40,000
they are vulnerable to key

20
00:00:40,000 --> 00:00:41,760
reinstallation attacks

21
00:00:41,760 --> 00:00:44,879
so the crack attack and also the small

22
00:00:44,879 --> 00:00:46,399
improvement of the crack attack the

23
00:00:46,399 --> 00:00:48,719
kraken attack

24
00:00:48,719 --> 00:00:51,199
just a year ago academic researchers

25
00:00:51,199 --> 00:00:53,600
showed that the defenses against crack

26
00:00:53,600 --> 00:00:57,120
are formally secure meaning existing

27
00:00:57,120 --> 00:00:59,680
implementations of web on wpa2

28
00:00:59,680 --> 00:01:02,000
should now provide defenses against the

29
00:01:02,000 --> 00:01:05,199
kiwi installation attack

30
00:01:05,280 --> 00:01:07,360
additionally three years ago the wifi

31
00:01:07,360 --> 00:01:08,920
alliance released

32
00:01:08,920 --> 00:01:13,680
wpa3 on wpa3 provides a new handshake

33
00:01:13,680 --> 00:01:16,799
to prevent offline dictionary attacks

34
00:01:16,799 --> 00:01:19,439
on this means that wpa3 is a major

35
00:01:19,439 --> 00:01:20,320
improvement

36
00:01:20,320 --> 00:01:23,360
upon wpa2

37
00:01:23,360 --> 00:01:25,840
unfortunately together with el ronan we

38
00:01:25,840 --> 00:01:27,280
demonstrated that the

39
00:01:27,280 --> 00:01:30,640
dragonfly handshake of wk3 is vulnerable

40
00:01:30,640 --> 00:01:31,600
to the so-called

41
00:01:31,600 --> 00:01:34,799
dragonblood side channel leaks

42
00:01:34,799 --> 00:01:37,280
in response the wi-fi alliance now

43
00:01:37,280 --> 00:01:38,000
requires

44
00:01:38,000 --> 00:01:41,200
certified devices to implement defenses

45
00:01:41,200 --> 00:01:44,399
against the dragonblood attack

46
00:01:44,399 --> 00:01:46,320
i also want to highlight that once a

47
00:01:46,320 --> 00:01:47,759
client has connected to

48
00:01:47,759 --> 00:01:51,520
either a wpa2 or wpa3 network

49
00:01:51,520 --> 00:01:53,600
the encryption used to protect data

50
00:01:53,600 --> 00:01:55,200
frames is practically

51
00:01:55,200 --> 00:01:58,079
identical this also means that attacks

52
00:01:58,079 --> 00:01:59,439
in this presentation

53
00:01:59,439 --> 00:02:05,199
will work against both wpa2 and wpa3

54
00:02:05,600 --> 00:02:09,440
in late 2020 two extra defenses were

55
00:02:09,440 --> 00:02:10,959
also added to the

56
00:02:10,959 --> 00:02:13,840
standard that underpins wi-fi and these

57
00:02:13,840 --> 00:02:14,480
are called

58
00:02:14,480 --> 00:02:16,879
operating channel validation on beacon

59
00:02:16,879 --> 00:02:18,720
protection

60
00:02:18,720 --> 00:02:20,560
now these two defenses would make our

61
00:02:20,560 --> 00:02:21,760
attacks harder

62
00:02:21,760 --> 00:02:24,560
but not impossible we just require more

63
00:02:24,560 --> 00:02:25,120
skill

64
00:02:25,120 --> 00:02:28,000
to pull them off additionally these

65
00:02:28,000 --> 00:02:29,200
defenses are still

66
00:02:29,200 --> 00:02:31,840
undergoing adoption and practice meaning

67
00:02:31,840 --> 00:02:32,720
right now these

68
00:02:32,720 --> 00:02:35,360
two defenses unfortunately don't yet

69
00:02:35,360 --> 00:02:36,400
have practical

70
00:02:36,400 --> 00:02:38,800
impact

71
00:02:39,760 --> 00:02:42,080
so we can see that in the past few years

72
00:02:42,080 --> 00:02:42,959
some major

73
00:02:42,959 --> 00:02:45,680
advancements have in fact been made to

74
00:02:45,680 --> 00:02:48,560
the security of wi-fi

75
00:02:48,560 --> 00:02:50,959
unfortunately in this work i'm going to

76
00:02:50,959 --> 00:02:51,840
present

77
00:02:51,840 --> 00:02:54,560
three new design flaws on several

78
00:02:54,560 --> 00:02:55,200
related

79
00:02:55,200 --> 00:02:58,159
implementation flaws i will begin by

80
00:02:58,159 --> 00:02:59,760
explaining the design flaws

81
00:02:59,760 --> 00:03:02,400
and in particular i will first explain

82
00:03:02,400 --> 00:03:05,680
the aggregation design flaw

83
00:03:05,680 --> 00:03:08,319
to explain this flaw i first have to

84
00:03:08,319 --> 00:03:09,120
explain how

85
00:03:09,120 --> 00:03:12,239
aggregation works in a wi-fi network

86
00:03:12,239 --> 00:03:15,040
on a wi-fi network if you want to send

87
00:03:15,040 --> 00:03:15,519
small

88
00:03:15,519 --> 00:03:19,040
packets that causes a lot of overhead

89
00:03:19,040 --> 00:03:21,280
and this is because every small packet

90
00:03:21,280 --> 00:03:22,720
shown in green here

91
00:03:22,720 --> 00:03:25,040
needs to have its individual wi-fi

92
00:03:25,040 --> 00:03:25,840
header

93
00:03:25,840 --> 00:03:28,239
it needs to be individually acknowledged

94
00:03:28,239 --> 00:03:29,599
by the receiver

95
00:03:29,599 --> 00:03:31,519
on between every packet there needs to

96
00:03:31,519 --> 00:03:33,040
be a small delay

97
00:03:33,040 --> 00:03:35,680
and that causes a lot of overhead on the

98
00:03:35,680 --> 00:03:36,480
practice

99
00:03:36,480 --> 00:03:38,720
it's much more efficient to aggregate

100
00:03:38,720 --> 00:03:40,000
these small packets

101
00:03:40,000 --> 00:03:44,080
into one larger wi-fi frame

102
00:03:44,080 --> 00:03:46,319
the question then becomes how can a

103
00:03:46,319 --> 00:03:47,599
receiver know

104
00:03:47,599 --> 00:03:50,080
whether a packet contains just a single

105
00:03:50,080 --> 00:03:51,120
network packet

106
00:03:51,120 --> 00:03:53,360
or whether a wi-fi frame contains

107
00:03:53,360 --> 00:03:56,000
multiple network packets

108
00:03:56,000 --> 00:03:58,400
on the answer is quite straightforward

109
00:03:58,400 --> 00:03:59,519
the wi-fi header

110
00:03:59,519 --> 00:04:02,080
contains a flag that indicates whether

111
00:04:02,080 --> 00:04:03,760
the encrypted payload

112
00:04:03,760 --> 00:04:06,879
contains just a single network packet

113
00:04:06,879 --> 00:04:09,680
or whether it contains an aggregation of

114
00:04:09,680 --> 00:04:11,920
multiple network packets

115
00:04:11,920 --> 00:04:14,480
so if this flag is true the encrypted

116
00:04:14,480 --> 00:04:16,160
payload will first start with some

117
00:04:16,160 --> 00:04:18,320
metadata about the first packet

118
00:04:18,320 --> 00:04:20,399
and the length of the first packet the

119
00:04:20,399 --> 00:04:21,759
actual content of the

120
00:04:21,759 --> 00:04:24,479
first packet then the metadata about the

121
00:04:24,479 --> 00:04:25,440
second packet

122
00:04:25,440 --> 00:04:28,960
and so on

123
00:04:28,960 --> 00:04:31,360
now what is the design flaw here the

124
00:04:31,360 --> 00:04:33,680
design flaw is that this header is not

125
00:04:33,680 --> 00:04:36,320
authenticated this means that an

126
00:04:36,320 --> 00:04:38,720
adversary can for instance take a normal

127
00:04:38,720 --> 00:04:39,840
wi-fi frame

128
00:04:39,840 --> 00:04:42,160
and turn it into an aggregated wi-fi

129
00:04:42,160 --> 00:04:45,360
frame without a receiver realizing this

130
00:04:45,360 --> 00:04:47,680
this means that the decrypted content of

131
00:04:47,680 --> 00:04:49,520
the packet will be parsed in an

132
00:04:49,520 --> 00:04:50,400
unexpected

133
00:04:50,400 --> 00:04:54,080
manner and we showed that this can be

134
00:04:54,080 --> 00:04:55,120
abused to inject

135
00:04:55,120 --> 00:04:58,320
arbitrary packets to the victim

136
00:04:58,320 --> 00:05:00,160
now before explaining the technical

137
00:05:00,160 --> 00:05:03,120
details let me first explain the attack

138
00:05:03,120 --> 00:05:04,160
scenario

139
00:05:04,160 --> 00:05:05,919
in which case this vulnerability can be

140
00:05:05,919 --> 00:05:07,919
exploited

141
00:05:07,919 --> 00:05:10,400
so here we have a client on the left and

142
00:05:10,400 --> 00:05:12,240
it's connected to the access point

143
00:05:12,240 --> 00:05:15,520
on the right and we have an adversary

144
00:05:15,520 --> 00:05:18,080
that has established a special

145
00:05:18,080 --> 00:05:19,199
multi-channel

146
00:05:19,199 --> 00:05:21,520
man in the middle position between the

147
00:05:21,520 --> 00:05:23,680
client on the access point

148
00:05:23,680 --> 00:05:26,000
now this multi-channel man in the middle

149
00:05:26,000 --> 00:05:27,039
position

150
00:05:27,039 --> 00:05:29,680
does not require the password of the

151
00:05:29,680 --> 00:05:30,880
network

152
00:05:30,880 --> 00:05:33,280
this position can be established against

153
00:05:33,280 --> 00:05:35,520
any protected wi-fi network

154
00:05:35,520 --> 00:05:38,960
as long as the adversary is within range

155
00:05:38,960 --> 00:05:40,479
this man in the middle does not allow

156
00:05:40,479 --> 00:05:42,160
the adversary to currently

157
00:05:42,160 --> 00:05:44,400
decrypt packets it only allows the

158
00:05:44,400 --> 00:05:46,479
adversary to reliably block

159
00:05:46,479 --> 00:05:52,000
or modify encrypted frames

160
00:05:52,000 --> 00:05:54,479
the second step is that the victim is

161
00:05:54,479 --> 00:05:56,160
tricked into downloading an

162
00:05:56,160 --> 00:05:59,360
image from the attacker's server this

163
00:05:59,360 --> 00:06:01,440
causes the victim device to establish a

164
00:06:01,440 --> 00:06:02,000
tcp

165
00:06:02,000 --> 00:06:04,840
connection with the web server of the

166
00:06:04,840 --> 00:06:06,639
adversary

167
00:06:06,639 --> 00:06:08,639
this can for example be accomplished by

168
00:06:08,639 --> 00:06:10,560
sending an email to the victim

169
00:06:10,560 --> 00:06:13,440
with an embedded image that is hosted on

170
00:06:13,440 --> 00:06:15,440
the server of the adversary

171
00:06:15,440 --> 00:06:17,840
or by sending the victim a whatsapp or

172
00:06:17,840 --> 00:06:18,560
linked

173
00:06:18,560 --> 00:06:21,120
or signal message that causes the

174
00:06:21,120 --> 00:06:22,319
message app

175
00:06:22,319 --> 00:06:26,080
to show a preview of the website

176
00:06:26,080 --> 00:06:28,400
and that means the device is again

177
00:06:28,400 --> 00:06:30,560
initiating a tcp connection

178
00:06:30,560 --> 00:06:34,639
with the server of the adversary

179
00:06:34,639 --> 00:06:37,759
once this tcp connection is established

180
00:06:37,759 --> 00:06:39,600
the adversary will send a specially

181
00:06:39,600 --> 00:06:42,080
crafted tcp ipv4 packet

182
00:06:42,080 --> 00:06:44,639
over this connection and i will explain

183
00:06:44,639 --> 00:06:46,840
later how exactly this packet is

184
00:06:46,840 --> 00:06:48,240
constructed

185
00:06:48,240 --> 00:06:51,360
for now this packet is sent as normal to

186
00:06:51,360 --> 00:06:52,479
the client

187
00:06:52,479 --> 00:06:54,560
meaning at some point it will arrive at

188
00:06:54,560 --> 00:06:56,800
a legitimate access point

189
00:06:56,800 --> 00:06:58,800
the legitimate access point will encrypt

190
00:06:58,800 --> 00:07:00,319
it as a normal frame

191
00:07:00,319 --> 00:07:03,840
unforwarded to the client

192
00:07:03,919 --> 00:07:06,080
before this wifi frame arrives at the

193
00:07:06,080 --> 00:07:08,880
client the adversary will set the is

194
00:07:08,880 --> 00:07:10,080
aggregated flag

195
00:07:10,080 --> 00:07:13,280
in the wifi header and i want to remark

196
00:07:13,280 --> 00:07:15,280
here that the adversary cannot modify

197
00:07:15,280 --> 00:07:16,080
the encrypted

198
00:07:16,080 --> 00:07:19,120
content of the frame the adversary can

199
00:07:19,120 --> 00:07:21,919
only abuse this design flaw and wi-fi

200
00:07:21,919 --> 00:07:24,960
to change the this aggregated flag in

201
00:07:24,960 --> 00:07:26,800
the header

202
00:07:26,800 --> 00:07:29,599
however because we constructed this ipv4

203
00:07:29,599 --> 00:07:30,000
packet

204
00:07:30,000 --> 00:07:32,400
in a special manner this will allow us

205
00:07:32,400 --> 00:07:33,199
to inject

206
00:07:33,199 --> 00:07:36,080
arbitrary packets towards the victim so

207
00:07:36,080 --> 00:07:37,680
we can for instance inject an

208
00:07:37,680 --> 00:07:41,360
r packet dhcp packet and so on

209
00:07:41,360 --> 00:07:44,479
and we can also inject an v6

210
00:07:44,479 --> 00:07:47,360
router advertisement that will trick the

211
00:07:47,360 --> 00:07:48,080
victim

212
00:07:48,080 --> 00:07:53,120
into using a malicious dns server

213
00:07:53,120 --> 00:07:55,120
now although this attack might look

214
00:07:55,120 --> 00:07:56,479
complicated

215
00:07:56,479 --> 00:07:59,840
i want to remark that this condition

216
00:07:59,840 --> 00:08:02,080
in order to exploit the attack is in

217
00:08:02,080 --> 00:08:04,639
fact easier than the well-known beast

218
00:08:04,639 --> 00:08:08,160
time on the heist attack against tls

219
00:08:08,160 --> 00:08:09,759
this is because these attacks against

220
00:08:09,759 --> 00:08:12,720
tls require the victim to execute

221
00:08:12,720 --> 00:08:14,639
malicious javascript

222
00:08:14,639 --> 00:08:16,960
while in our case we only require that

223
00:08:16,960 --> 00:08:19,360
the victim will establish a tcp connect

224
00:08:19,360 --> 00:08:21,919
connection with the adversary so that

225
00:08:21,919 --> 00:08:24,080
means our attack is simpler than these

226
00:08:24,080 --> 00:08:26,879
attacks against tls

227
00:08:26,879 --> 00:08:29,440
additionally if the router is vulnerable

228
00:08:29,440 --> 00:08:29,919
to a

229
00:08:29,919 --> 00:08:32,479
common implementation flaw then instead

230
00:08:32,479 --> 00:08:35,279
of sending the special ipv4 packet

231
00:08:35,279 --> 00:08:38,320
we can directly send a special handshake

232
00:08:38,320 --> 00:08:39,039
frame

233
00:08:39,039 --> 00:08:41,519
to the access point on the vulnerable

234
00:08:41,519 --> 00:08:43,360
access point will then forward this

235
00:08:43,360 --> 00:08:44,480
handshake message

236
00:08:44,480 --> 00:08:46,959
to the victim and we can then execute

237
00:08:46,959 --> 00:08:48,000
the attack

238
00:08:48,000 --> 00:08:51,040
without any social engineering simply by

239
00:08:51,040 --> 00:08:52,160
being within range

240
00:08:52,160 --> 00:08:55,519
of the victim and this vulnerability was

241
00:08:55,519 --> 00:08:57,279
present in two out of four

242
00:08:57,279 --> 00:09:00,959
home access points that we tested

243
00:09:00,959 --> 00:09:02,640
now you may still be wondering how

244
00:09:02,640 --> 00:09:04,640
exactly this can be abused to inject

245
00:09:04,640 --> 00:09:06,800
any type of network packet well i'll

246
00:09:06,800 --> 00:09:08,560
explain that later

247
00:09:08,560 --> 00:09:10,480
first let's look at the demonstration of

248
00:09:10,480 --> 00:09:12,240
this attack in practice

249
00:09:12,240 --> 00:09:14,000
note that this recorded demonstration

250
00:09:14,000 --> 00:09:15,920
will be a bit more fast paced than the

251
00:09:15,920 --> 00:09:16,959
presentation

252
00:09:16,959 --> 00:09:19,519
to assure i won't run out of time our

253
00:09:19,519 --> 00:09:22,399
target will be a mac os laptop

254
00:09:22,399 --> 00:09:24,240
this laptop is connected to a protected

255
00:09:24,240 --> 00:09:25,519
wifi network as

256
00:09:25,519 --> 00:09:27,440
indicated by the lock symbol and the

257
00:09:27,440 --> 00:09:29,360
victim will use it to visit websites

258
00:09:29,360 --> 00:09:32,800
such as nyu.edu notice that the home

259
00:09:32,800 --> 00:09:34,959
page of this website is insecure

260
00:09:34,959 --> 00:09:38,160
however the login page does use https as

261
00:09:38,160 --> 00:09:39,920
an extra layer of security

262
00:09:39,920 --> 00:09:43,519
as indicated by the lock symbol

263
00:09:43,839 --> 00:09:45,920
before starting the attack we have to

264
00:09:45,920 --> 00:09:47,360
prepare it by running the following

265
00:09:47,360 --> 00:09:49,040
script on a server

266
00:09:49,040 --> 00:09:50,959
this script waits for connections from

267
00:09:50,959 --> 00:09:53,120
the victim and i'll explain its purpose

268
00:09:53,120 --> 00:09:54,320
later

269
00:09:54,320 --> 00:09:56,320
on the server i'm also running a dns on

270
00:09:56,320 --> 00:09:58,720
web server to intercept on impersonate

271
00:09:58,720 --> 00:09:59,920
websites

272
00:09:59,920 --> 00:10:01,920
i'll also run wireshark to capture

273
00:10:01,920 --> 00:10:05,360
traffic towards the server

274
00:10:05,360 --> 00:10:06,959
we can now start attack with the

275
00:10:06,959 --> 00:10:08,399
following tool

276
00:10:08,399 --> 00:10:10,160
here i included the protected wi-fi

277
00:10:10,160 --> 00:10:11,680
network that will be attacked

278
00:10:11,680 --> 00:10:13,120
and that we will only target one

279
00:10:13,120 --> 00:10:14,800
specific victim

280
00:10:14,800 --> 00:10:16,480
the tool starts by searching for this

281
00:10:16,480 --> 00:10:18,399
wifi network and then it clones its

282
00:10:18,399 --> 00:10:20,640
network on a different channel

283
00:10:20,640 --> 00:10:22,480
this malicious clone of the network

284
00:10:22,480 --> 00:10:24,079
enables the attacker to reliably

285
00:10:24,079 --> 00:10:26,079
manipulate encrypted data frames

286
00:10:26,079 --> 00:10:28,079
which is required to abuse the design

287
00:10:28,079 --> 00:10:29,279
flaw

288
00:10:29,279 --> 00:10:31,440
when the victim now enables wi-fi it

289
00:10:31,440 --> 00:10:33,600
will connect to the malicious clone

290
00:10:33,600 --> 00:10:35,440
to better understand the attack i'll

291
00:10:35,440 --> 00:10:39,360
also start wireshark on the victim

292
00:10:39,760 --> 00:10:41,360
we must now trick the victim into

293
00:10:41,360 --> 00:10:43,920
connecting to the attacker's server

294
00:10:43,920 --> 00:10:45,680
here this is accomplished by sending an

295
00:10:45,680 --> 00:10:46,959
email to the victim

296
00:10:46,959 --> 00:10:49,040
and although this email looks innocent

297
00:10:49,040 --> 00:10:50,480
it contains a hidden image

298
00:10:50,480 --> 00:10:53,040
hosted on the server of the attacker

299
00:10:53,040 --> 00:10:54,800
this causes the victim to download the

300
00:10:54,800 --> 00:10:55,200
image

301
00:10:55,200 --> 00:10:57,279
from the attacker's server but instead

302
00:10:57,279 --> 00:10:58,399
of sending the image

303
00:10:58,399 --> 00:11:00,399
the attacker will send a malicious tcp

304
00:11:00,399 --> 00:11:02,640
packet

305
00:11:02,640 --> 00:11:04,959
this packet is constructed in such a way

306
00:11:04,959 --> 00:11:06,480
so that when it's turned into an

307
00:11:06,480 --> 00:11:08,000
aggregated wi-fi frame

308
00:11:08,000 --> 00:11:09,920
it will cause the injection of a frame

309
00:11:09,920 --> 00:11:11,839
that tricks the victim into using our

310
00:11:11,839 --> 00:11:15,279
malicious dns server

311
00:11:15,279 --> 00:11:16,959
the wi-fi attacker can detect this

312
00:11:16,959 --> 00:11:18,399
packet based on its length

313
00:11:18,399 --> 00:11:20,160
and it will set the aggregated flag in

314
00:11:20,160 --> 00:11:22,640
the wi-fi header before forwarding it to

315
00:11:22,640 --> 00:11:24,000
the victim

316
00:11:24,000 --> 00:11:26,320
due to a design flaw on wi-fi the victim

317
00:11:26,320 --> 00:11:28,079
won't notice that the attacker changed

318
00:11:28,079 --> 00:11:29,279
this flag

319
00:11:29,279 --> 00:11:31,440
as a result the victim will process the

320
00:11:31,440 --> 00:11:32,560
modified frame

321
00:11:32,560 --> 00:11:34,720
and will start using our malicious dns

322
00:11:34,720 --> 00:11:37,120
server

323
00:11:37,120 --> 00:11:39,279
looking at the victim we can indeed see

324
00:11:39,279 --> 00:11:41,120
that it received a frame containing the

325
00:11:41,120 --> 00:11:42,160
malicious dns

326
00:11:42,160 --> 00:11:44,800
server note that normally we cannot

327
00:11:44,800 --> 00:11:45,279
inject

328
00:11:45,279 --> 00:11:48,079
such frames over a tcp connection this

329
00:11:48,079 --> 00:11:50,399
is only possible by abusing design flaws

330
00:11:50,399 --> 00:11:53,040
in wi-fi

331
00:11:54,000 --> 00:11:56,160
when the victim again visits an insecure

332
00:11:56,160 --> 00:11:58,800
website such as nyu.edu

333
00:11:58,800 --> 00:12:01,360
our malicious dns server will redirect

334
00:12:01,360 --> 00:12:03,200
the victim to our own copy of the

335
00:12:03,200 --> 00:12:04,560
website

336
00:12:04,560 --> 00:12:06,639
this copy contains a link to an insecure

337
00:12:06,639 --> 00:12:07,600
login page

338
00:12:07,600 --> 00:12:09,920
and safari is in fact warning us that we

339
00:12:09,920 --> 00:12:12,240
may not be on the real website

340
00:12:12,240 --> 00:12:15,040
however most users likely won't notice

341
00:12:15,040 --> 00:12:15,519
this

342
00:12:15,519 --> 00:12:17,120
and will enter their username and

343
00:12:17,120 --> 00:12:19,440
password because i'm using a fake

344
00:12:19,440 --> 00:12:22,839
username and password the login fails

345
00:12:22,839 --> 00:12:25,120
nevertheless when looking at the capture

346
00:12:25,120 --> 00:12:26,399
traffic on the attacker's

347
00:12:26,399 --> 00:12:28,399
server we can search for the victims

348
00:12:28,399 --> 00:12:30,480
login attempt and extract the username

349
00:12:30,480 --> 00:12:33,120
and password

350
00:12:34,240 --> 00:12:35,760
you may now be wondering how many

351
00:12:35,760 --> 00:12:37,680
devices are affected

352
00:12:37,680 --> 00:12:40,160
unfortunately i have bad news here all

353
00:12:40,160 --> 00:12:42,720
major operating systems are affected

354
00:12:42,720 --> 00:12:44,959
with the exception of net bsd on some

355
00:12:44,959 --> 00:12:46,399
iot devices

356
00:12:46,399 --> 00:12:48,880
which do not support aggregate wi-fi

357
00:12:48,880 --> 00:12:50,560
frames

358
00:12:50,560 --> 00:12:52,399
now one thing i did not yet explain is

359
00:12:52,399 --> 00:12:54,480
how the special ipv4 packet is

360
00:12:54,480 --> 00:12:55,600
constructed

361
00:12:55,600 --> 00:12:57,519
and it is constructed in the following

362
00:12:57,519 --> 00:12:59,040
way so

363
00:12:59,040 --> 00:13:02,000
first we create an ipv4 packet with the

364
00:13:02,000 --> 00:13:03,760
following header on with the following

365
00:13:03,760 --> 00:13:04,800
length

366
00:13:04,800 --> 00:13:07,600
then we can pick an arbitrary ip

367
00:13:07,600 --> 00:13:09,360
identification value

368
00:13:09,360 --> 00:13:11,279
we have the remaining ip header and then

369
00:13:11,279 --> 00:13:12,800
the tcp header

370
00:13:12,800 --> 00:13:15,200
and finally we put the frame that we

371
00:13:15,200 --> 00:13:16,480
want to inject

372
00:13:16,480 --> 00:13:20,240
in the data field of the tcp

373
00:13:20,240 --> 00:13:25,040
packet now we can control the fields

374
00:13:25,040 --> 00:13:27,279
in green here we can put arbitrary

375
00:13:27,279 --> 00:13:28,079
values there

376
00:13:28,079 --> 00:13:30,800
as an attacker but for the red fields we

377
00:13:30,800 --> 00:13:32,800
must use a certain value

378
00:13:32,800 --> 00:13:34,880
because if we do not use this value the

379
00:13:34,880 --> 00:13:36,160
ipv4 packet

380
00:13:36,160 --> 00:13:39,279
will not reach the client now when

381
00:13:39,279 --> 00:13:39,920
sending this

382
00:13:39,920 --> 00:13:42,079
ipv4 packet when it arrives at a

383
00:13:42,079 --> 00:13:43,760
legitimate access point

384
00:13:43,760 --> 00:13:45,839
the legitimate access point will add an

385
00:13:45,839 --> 00:13:46,880
extra header

386
00:13:46,880 --> 00:13:48,720
and then it will encrypt all this data

387
00:13:48,720 --> 00:13:52,000
and send it as a wi-fi frame

388
00:13:52,000 --> 00:13:54,560
now here we're going to assume that the

389
00:13:54,560 --> 00:13:56,639
access point will send it as a normal

390
00:13:56,639 --> 00:13:58,399
individual frame

391
00:13:58,399 --> 00:14:00,639
and then the adversary will turn this

392
00:14:00,639 --> 00:14:02,639
frame into an aggregate

393
00:14:02,639 --> 00:14:06,160
frame on the receiver the receiver will

394
00:14:06,160 --> 00:14:06,480
now

395
00:14:06,480 --> 00:14:09,279
think that these first bytes are the

396
00:14:09,279 --> 00:14:10,480
metadata

397
00:14:10,480 --> 00:14:13,360
of the first packet now this will result

398
00:14:13,360 --> 00:14:13,600
in

399
00:14:13,600 --> 00:14:16,240
invalid metadata meaning that the first

400
00:14:16,240 --> 00:14:17,920
subpacket will in fact be

401
00:14:17,920 --> 00:14:20,880
ignored what's very interesting here

402
00:14:20,880 --> 00:14:21,279
though

403
00:14:21,279 --> 00:14:23,600
is that the length of this first sub

404
00:14:23,600 --> 00:14:25,040
packet corresponds

405
00:14:25,040 --> 00:14:28,240
exactly to the ip identification field

406
00:14:28,240 --> 00:14:30,959
and as an adversary we can put any value

407
00:14:30,959 --> 00:14:32,160
we want there

408
00:14:32,160 --> 00:14:34,399
meaning we can fully control how long

409
00:14:34,399 --> 00:14:36,720
this first subpacket is

410
00:14:36,720 --> 00:14:38,639
meaning we can control where the second

411
00:14:38,639 --> 00:14:40,800
subpacket starts

412
00:14:40,800 --> 00:14:42,839
in other words we can fully control the

413
00:14:42,839 --> 00:14:44,720
metadata the length

414
00:14:44,720 --> 00:14:48,160
and the content of the second sub packet

415
00:14:48,160 --> 00:14:50,560
meaning as long as we control the ip

416
00:14:50,560 --> 00:14:52,240
identification field

417
00:14:52,240 --> 00:14:55,440
on the subset of the tcp data then by

418
00:14:55,440 --> 00:14:57,040
turning this normal frame

419
00:14:57,040 --> 00:14:59,760
into an aggregate frame we can in fact

420
00:14:59,760 --> 00:15:00,399
inject

421
00:15:00,399 --> 00:15:03,199
any packet that we want so that's how

422
00:15:03,199 --> 00:15:04,480
the attack works

423
00:15:04,480 --> 00:15:07,120
in detail

424
00:15:07,519 --> 00:15:09,519
let me now move on to the mixed key

425
00:15:09,519 --> 00:15:10,560
attack

426
00:15:10,560 --> 00:15:13,440
and i first have to explain how

427
00:15:13,440 --> 00:15:15,120
fragmentation works

428
00:15:15,120 --> 00:15:17,199
this is because both the mixed key and

429
00:15:17,199 --> 00:15:18,560
the fragment cache attack

430
00:15:18,560 --> 00:15:22,320
rely on wi-fi fragmentation

431
00:15:22,320 --> 00:15:25,680
now with wi-fi fragmentation we have the

432
00:15:25,680 --> 00:15:26,720
opposite problem

433
00:15:26,720 --> 00:15:29,519
as before here we have a wi-fi packet

434
00:15:29,519 --> 00:15:31,040
that is too large

435
00:15:31,040 --> 00:15:33,040
and if there is then a lot of background

436
00:15:33,040 --> 00:15:35,360
noise then there's a high chance this

437
00:15:35,360 --> 00:15:36,880
packet will be corrupted

438
00:15:36,880 --> 00:15:39,279
and we have to transmit all the data

439
00:15:39,279 --> 00:15:40,480
again

440
00:15:40,480 --> 00:15:42,800
on here it is more efficient if there is

441
00:15:42,800 --> 00:15:44,000
background noise

442
00:15:44,000 --> 00:15:46,720
to fragment large packets into smaller

443
00:15:46,720 --> 00:15:47,360
ones

444
00:15:47,360 --> 00:15:49,920
so that if a fragment is lost we only

445
00:15:49,920 --> 00:15:51,199
need to retransmit

446
00:15:51,199 --> 00:15:54,800
that one specific fragment

447
00:15:54,800 --> 00:15:56,399
now the question becomes how can a

448
00:15:56,399 --> 00:15:58,320
receiver properly

449
00:15:58,320 --> 00:16:01,040
unsecurely reassemble these fragments

450
00:16:01,040 --> 00:16:01,680
back to the

451
00:16:01,680 --> 00:16:05,360
original frame let me first explain this

452
00:16:05,360 --> 00:16:08,639
for plain text wifi frames using

453
00:16:08,639 --> 00:16:10,959
this example here where we have three

454
00:16:10,959 --> 00:16:12,880
fragments

455
00:16:12,880 --> 00:16:14,880
the first information that we need is

456
00:16:14,880 --> 00:16:16,720
that every wi-fi

457
00:16:16,720 --> 00:16:20,399
frame has a sequence number s

458
00:16:20,399 --> 00:16:22,560
and here every fragment has the same

459
00:16:22,560 --> 00:16:24,000
sequence number s

460
00:16:24,000 --> 00:16:26,079
so that we can identify fragments that

461
00:16:26,079 --> 00:16:27,040
belong to the same

462
00:16:27,040 --> 00:16:30,160
original frame additionally

463
00:16:30,160 --> 00:16:32,639
every frame contains a fragment number

464
00:16:32,639 --> 00:16:34,240
that allows us to determine

465
00:16:34,240 --> 00:16:37,040
the order of the fragments and finally

466
00:16:37,040 --> 00:16:38,720
there is a flag to indicate what the

467
00:16:38,720 --> 00:16:39,199
last

468
00:16:39,199 --> 00:16:42,639
fragment is and with these fields we can

469
00:16:42,639 --> 00:16:43,839
reliably and

470
00:16:43,839 --> 00:16:46,560
properly reconstruct the original

471
00:16:46,560 --> 00:16:47,680
fragment

472
00:16:47,680 --> 00:16:50,480
for a plain text so an open wi-fi

473
00:16:50,480 --> 00:16:52,880
network

474
00:16:52,880 --> 00:16:55,680
for a protected wi-fi network there is

475
00:16:55,680 --> 00:16:57,759
another field that is added to the wi-fi

476
00:16:57,759 --> 00:16:58,399
header

477
00:16:58,399 --> 00:17:01,600
and this is the so-called packet number

478
00:17:01,600 --> 00:17:03,519
this packet number is used at the

479
00:17:03,519 --> 00:17:04,640
encryption lay

480
00:17:04,640 --> 00:17:09,039
to for instance prevent replays

481
00:17:09,039 --> 00:17:11,919
now when fragmentation is used every

482
00:17:11,919 --> 00:17:12,720
fragment

483
00:17:12,720 --> 00:17:15,760
must have a consecutive packet number so

484
00:17:15,760 --> 00:17:17,439
here the first fragment has packed

485
00:17:17,439 --> 00:17:17,839
number

486
00:17:17,839 --> 00:17:20,160
n that means that the second fragment

487
00:17:20,160 --> 00:17:22,400
must have packet number n plus one

488
00:17:22,400 --> 00:17:24,720
on the third must have packet number n

489
00:17:24,720 --> 00:17:25,679
plus two

490
00:17:25,679 --> 00:17:27,919
and if that is not the case the fragment

491
00:17:27,919 --> 00:17:30,240
should be dropped

492
00:17:30,240 --> 00:17:32,559
now all these fields except the sequence

493
00:17:32,559 --> 00:17:34,480
number are authenticated

494
00:17:34,480 --> 00:17:37,440
meaning an adversary cannot modify these

495
00:17:37,440 --> 00:17:38,240
flags

496
00:17:38,240 --> 00:17:41,440
because if the adversary does that

497
00:17:41,440 --> 00:17:44,160
the receiver will detect this on the

498
00:17:44,160 --> 00:17:45,280
frame or fragment

499
00:17:45,280 --> 00:17:48,320
will be dropped on that first side this

500
00:17:48,320 --> 00:17:51,039
actually seems quite secure

501
00:17:51,039 --> 00:17:54,320
however problems begin when

502
00:17:54,320 --> 00:17:57,440
fragmentation is combined with the

503
00:17:57,440 --> 00:18:00,640
session key renewal now what is session

504
00:18:00,640 --> 00:18:01,760
key renewal

505
00:18:01,760 --> 00:18:05,039
well a client can periodically refresh

506
00:18:05,039 --> 00:18:08,240
the key that it is using to encrypt data

507
00:18:08,240 --> 00:18:09,360
frames

508
00:18:09,360 --> 00:18:14,320
by performing the handshake again

509
00:18:14,320 --> 00:18:15,760
and this will update the session key

510
00:18:15,760 --> 00:18:18,400
that is used to encrypt data frames

511
00:18:18,400 --> 00:18:19,919
and the session key will also be

512
00:18:19,919 --> 00:18:21,919
automatically re renewed

513
00:18:21,919 --> 00:18:23,760
when the client roams from one access

514
00:18:23,760 --> 00:18:25,600
point to another

515
00:18:25,600 --> 00:18:28,240
and when the session key is renewed the

516
00:18:28,240 --> 00:18:30,640
packet numbers that a sender is using

517
00:18:30,640 --> 00:18:35,360
will also restart back from zero

518
00:18:35,760 --> 00:18:39,039
now why is this a problem well without

519
00:18:39,039 --> 00:18:41,440
yet going into too much detail

520
00:18:41,440 --> 00:18:43,840
the problem is that a receiver will

521
00:18:43,840 --> 00:18:45,840
reassemble fragments

522
00:18:45,840 --> 00:18:48,400
that are encrypted using different keys

523
00:18:48,400 --> 00:18:48,880
after

524
00:18:48,880 --> 00:18:52,000
one of these session key renewals took

525
00:18:52,000 --> 00:18:53,600
place

526
00:18:53,600 --> 00:18:55,919
so let me illustrate that graphically

527
00:18:55,919 --> 00:18:57,679
let's say we have our client on access

528
00:18:57,679 --> 00:18:58,480
point here

529
00:18:58,480 --> 00:19:01,360
under again our adversary that has this

530
00:19:01,360 --> 00:19:02,480
multi-channel

531
00:19:02,480 --> 00:19:06,799
man in the middle position in our attack

532
00:19:06,799 --> 00:19:08,880
we assume that the client will send a

533
00:19:08,880 --> 00:19:10,000
wi-fi frame that

534
00:19:10,000 --> 00:19:12,799
is split into two fragments on the

535
00:19:12,799 --> 00:19:15,200
adversary will block the second fragment

536
00:19:15,200 --> 00:19:17,039
meaning only the first fragment

537
00:19:17,039 --> 00:19:21,600
is forwarded to the access point

538
00:19:21,760 --> 00:19:23,760
then at some point the client will

539
00:19:23,760 --> 00:19:26,799
refresh the session key from k to m

540
00:19:26,799 --> 00:19:29,919
so notice that these frames here on top

541
00:19:29,919 --> 00:19:33,760
are encrypted using the key k

542
00:19:33,760 --> 00:19:36,559
but when the wi-fi client now refreshes

543
00:19:36,559 --> 00:19:38,000
the session key

544
00:19:38,000 --> 00:19:40,799
the packet numbers will be reset to zero

545
00:19:40,799 --> 00:19:42,960
and when it now sends another fragmented

546
00:19:42,960 --> 00:19:44,000
frame

547
00:19:44,000 --> 00:19:46,320
the adversary will block the first

548
00:19:46,320 --> 00:19:47,120
fragment

549
00:19:47,120 --> 00:19:50,160
from arriving and will only forward the

550
00:19:50,160 --> 00:19:51,120
second fragment

551
00:19:51,120 --> 00:19:54,720
to the access point and because of the

552
00:19:54,720 --> 00:19:56,640
design flaw in wi-fi

553
00:19:56,640 --> 00:19:59,440
the access point will reassemble both of

554
00:19:59,440 --> 00:19:59,840
these

555
00:19:59,840 --> 00:20:03,120
fragments even though

556
00:20:03,120 --> 00:20:06,559
they belong to different frames and even

557
00:20:06,559 --> 00:20:06,960
though

558
00:20:06,960 --> 00:20:10,240
they were decrypted using a different

559
00:20:10,240 --> 00:20:13,039
key k

560
00:20:13,520 --> 00:20:16,559
in other words as an adversary we can

561
00:20:16,559 --> 00:20:17,760
abuse this

562
00:20:17,760 --> 00:20:20,799
design flaw to mix the content of two

563
00:20:20,799 --> 00:20:23,600
different frames

564
00:20:26,000 --> 00:20:27,520
so what is the impact of this in

565
00:20:27,520 --> 00:20:29,840
practice well in practice we can abuse

566
00:20:29,840 --> 00:20:30,320
this to

567
00:20:30,320 --> 00:20:33,280
exfiltrate data if the client sends

568
00:20:33,280 --> 00:20:34,799
fragmented frames

569
00:20:34,799 --> 00:20:37,280
which is relatively rare unless wi-fi 6

570
00:20:37,280 --> 00:20:38,400
is used

571
00:20:38,400 --> 00:20:40,320
aren't we again need to social engineer

572
00:20:40,320 --> 00:20:42,400
the victim into connecting to the server

573
00:20:42,400 --> 00:20:44,240
of the attacker

574
00:20:44,240 --> 00:20:46,320
a third condition is that the network

575
00:20:46,320 --> 00:20:48,480
must also periodically refresh the

576
00:20:48,480 --> 00:20:49,520
session key

577
00:20:49,520 --> 00:20:51,520
and that is in fact very rare in

578
00:20:51,520 --> 00:20:53,120
practice

579
00:20:53,120 --> 00:20:55,679
however there is an extremely common

580
00:20:55,679 --> 00:20:57,039
implementation flaw

581
00:20:57,039 --> 00:20:59,520
that allows us to perform this attack

582
00:20:59,520 --> 00:21:00,799
even if the network

583
00:21:00,799 --> 00:21:04,159
doesn't refresh the session key

584
00:21:04,159 --> 00:21:08,159
and how can we then exfiltrate data

585
00:21:08,159 --> 00:21:10,720
well the idea is that the first frame

586
00:21:10,720 --> 00:21:12,080
that we target

587
00:21:12,080 --> 00:21:15,360
is a frame that the adversary is sending

588
00:21:15,360 --> 00:21:17,919
sorry that the victim is sending to the

589
00:21:17,919 --> 00:21:19,840
server of the adversary

590
00:21:19,840 --> 00:21:21,840
for instance we trick the victim to

591
00:21:21,840 --> 00:21:23,600
download an image

592
00:21:23,600 --> 00:21:28,000
from our server and the second fragment

593
00:21:28,000 --> 00:21:31,600
contains sensitive information that

594
00:21:31,600 --> 00:21:34,320
the user is sending for instance here we

595
00:21:34,320 --> 00:21:35,600
assume that the user

596
00:21:35,600 --> 00:21:38,480
is logging in on a plain text http

597
00:21:38,480 --> 00:21:40,240
website

598
00:21:40,240 --> 00:21:43,440
on using our mixed key attack we can now

599
00:21:43,440 --> 00:21:47,679
mix the content of both of these frames

600
00:21:47,679 --> 00:21:50,880
in other words we can construct an

601
00:21:50,880 --> 00:21:54,080
ip packet with as destination the server

602
00:21:54,080 --> 00:21:55,919
of the adversary

603
00:21:55,919 --> 00:21:59,919
and as content sensitive user data

604
00:21:59,919 --> 00:22:01,679
that essentially means that sensitive

605
00:22:01,679 --> 00:22:03,039
data is now sent

606
00:22:03,039 --> 00:22:05,679
to the server of the adversary meaning

607
00:22:05,679 --> 00:22:07,280
we learn the password

608
00:22:07,280 --> 00:22:09,918
of the victim

609
00:22:11,360 --> 00:22:13,919
so that concludes the mixed key attack i

610
00:22:13,919 --> 00:22:14,640
will now

611
00:22:14,640 --> 00:22:17,360
very briefly also explain the fragment

612
00:22:17,360 --> 00:22:17,840
cache

613
00:22:17,840 --> 00:22:21,280
design flaw and what goes wrong here

614
00:22:21,280 --> 00:22:23,840
is that fragments are not removed from

615
00:22:23,840 --> 00:22:24,799
memory

616
00:22:24,799 --> 00:22:28,320
after the receiver has disconnected

617
00:22:28,320 --> 00:22:29,919
so let me illustrate this using the

618
00:22:29,919 --> 00:22:31,360
following example

619
00:22:31,360 --> 00:22:33,600
where we are targeting an enterprise

620
00:22:33,600 --> 00:22:34,799
wi-fi network

621
00:22:34,799 --> 00:22:38,240
such as in-room or hotspot 2.0

622
00:22:38,240 --> 00:22:43,120
where users mutually distrust each other

623
00:22:43,760 --> 00:22:46,720
in that case in these kinds of networks

624
00:22:46,720 --> 00:22:49,120
the adversary can also connect

625
00:22:49,120 --> 00:22:51,280
to this network because the adversary

626
00:22:51,280 --> 00:22:54,000
has a personal username and password

627
00:22:54,000 --> 00:22:56,159
and then the adversary can inject a

628
00:22:56,159 --> 00:22:57,760
malicious fragment

629
00:22:57,760 --> 00:23:00,080
into the memory of the access point so

630
00:23:00,080 --> 00:23:01,679
the access point will decrypt this

631
00:23:01,679 --> 00:23:03,679
fragment sent by the adversary

632
00:23:03,679 --> 00:23:07,120
unstored in memory when the adversary

633
00:23:07,120 --> 00:23:08,480
now disconnects

634
00:23:08,480 --> 00:23:10,720
due to the design flaw this fragment

635
00:23:10,720 --> 00:23:13,440
stays in the memory of the access point

636
00:23:13,440 --> 00:23:15,440
meaning if the client now connects to

637
00:23:15,440 --> 00:23:17,120
the access point

638
00:23:17,120 --> 00:23:20,960
then it becomes possible that fragments

639
00:23:20,960 --> 00:23:23,440
sent by the victim sent by the client

640
00:23:23,440 --> 00:23:24,159
here

641
00:23:24,159 --> 00:23:26,480
will be reassembled together with the

642
00:23:26,480 --> 00:23:27,919
malicious fragment

643
00:23:27,919 --> 00:23:30,480
of the adversary and then things go

644
00:23:30,480 --> 00:23:32,159
wrong

645
00:23:32,159 --> 00:23:35,039
and what exactly can go wrong well we

646
00:23:35,039 --> 00:23:36,400
can abuse this to again

647
00:23:36,400 --> 00:23:40,000
exfiltrate data or possibly to inject

648
00:23:40,000 --> 00:23:40,880
packets

649
00:23:40,880 --> 00:23:42,799
assuming we are we are targeting a

650
00:23:42,799 --> 00:23:44,240
network where users

651
00:23:44,240 --> 00:23:46,480
distrust each other on the assuming that

652
00:23:46,480 --> 00:23:49,039
the client sends fragmented frames

653
00:23:49,039 --> 00:23:51,600
which is fairly rare unless wi-fi 6 is

654
00:23:51,600 --> 00:23:54,000
being used

655
00:23:54,000 --> 00:23:56,080
now what i do want to remark here is

656
00:23:56,080 --> 00:23:58,640
that even the very old web protocol is

657
00:23:58,640 --> 00:24:00,640
affected by this design flaw

658
00:24:00,640 --> 00:24:03,279
and web was in fact also affected by the

659
00:24:03,279 --> 00:24:04,320
mixed key attack

660
00:24:04,320 --> 00:24:07,360
that i just explained this really shows

661
00:24:07,360 --> 00:24:09,120
that these design flaws have been part

662
00:24:09,120 --> 00:24:10,400
of wifi since a

663
00:24:10,400 --> 00:24:13,760
very long time

664
00:24:13,760 --> 00:24:16,480
now how do we fix these design flaws

665
00:24:16,480 --> 00:24:18,159
well for the aggregation design

666
00:24:18,159 --> 00:24:20,640
flaw ideally we authenticate the is

667
00:24:20,640 --> 00:24:21,440
aggregated

668
00:24:21,440 --> 00:24:24,080
flag unfortunately this will not be

669
00:24:24,080 --> 00:24:25,840
backwards compatible

670
00:24:25,840 --> 00:24:28,320
instead vendors are now preventing known

671
00:24:28,320 --> 00:24:29,200
attacks

672
00:24:29,200 --> 00:24:32,400
by the following defense particular

673
00:24:32,400 --> 00:24:34,320
what vendors are doing is they are

674
00:24:34,320 --> 00:24:35,679
trying to detect

675
00:24:35,679 --> 00:24:38,400
when an adversary takes the following

676
00:24:38,400 --> 00:24:39,760
normal frame

677
00:24:39,760 --> 00:24:42,080
and the adversary turns it into an

678
00:24:42,080 --> 00:24:44,000
aggregated frame

679
00:24:44,000 --> 00:24:47,520
because in that case the metadata of the

680
00:24:47,520 --> 00:24:51,200
aggregate frame will start with a valid

681
00:24:51,200 --> 00:24:52,000
rfc

682
00:24:52,000 --> 00:24:56,080
1042 header and if that is the case

683
00:24:56,080 --> 00:24:58,720
then it is extremely likely that an

684
00:24:58,720 --> 00:25:00,000
attack is going on where

685
00:25:00,000 --> 00:25:03,279
an adversary turns this normal frame

686
00:25:03,279 --> 00:25:06,559
into an aggregated one

687
00:25:06,559 --> 00:25:08,880
unfortunately that does mean that the

688
00:25:08,880 --> 00:25:10,000
true root cause

689
00:25:10,000 --> 00:25:12,480
of the vulnerability is not fixed so it

690
00:25:12,480 --> 00:25:14,080
could be that someone in the future

691
00:25:14,080 --> 00:25:17,120
might be able to bypass this adhoc

692
00:25:17,120 --> 00:25:21,200
defense for the mixed key attack

693
00:25:21,200 --> 00:25:23,279
there the solution is to only reassemble

694
00:25:23,279 --> 00:25:25,120
fragments that are decrypted

695
00:25:25,120 --> 00:25:27,600
under the same key and for the fragment

696
00:25:27,600 --> 00:25:28,640
cache attack

697
00:25:28,640 --> 00:25:31,279
there a receiver should clear unused

698
00:25:31,279 --> 00:25:32,640
fragments from memory

699
00:25:32,640 --> 00:25:35,120
whenever the client disconnects or when

700
00:25:35,120 --> 00:25:36,960
the corresponding key that was used to

701
00:25:36,960 --> 00:25:38,640
decrypt this fragment

702
00:25:38,640 --> 00:25:42,559
is removed now apart from these design

703
00:25:42,559 --> 00:25:44,240
flaws i also discovered

704
00:25:44,240 --> 00:25:47,520
very common implementation flaws and the

705
00:25:47,520 --> 00:25:48,000
first

706
00:25:48,000 --> 00:25:50,240
set of implementation flaws allow an

707
00:25:50,240 --> 00:25:51,679
adversary to inject

708
00:25:51,679 --> 00:25:54,799
plain text packets particularly in

709
00:25:54,799 --> 00:25:56,640
particular by sending a plain text

710
00:25:56,640 --> 00:25:58,720
packet that is either fragmented or

711
00:25:58,720 --> 00:25:59,919
broadcasted

712
00:25:59,919 --> 00:26:02,000
or by sending this plain text packet

713
00:26:02,000 --> 00:26:03,520
while connecting

714
00:26:03,520 --> 00:26:05,679
a vulnerable device will accept this

715
00:26:05,679 --> 00:26:07,600
plain text frame

716
00:26:07,600 --> 00:26:09,520
even when the device is connected to a

717
00:26:09,520 --> 00:26:11,760
protected wi-fi network

718
00:26:11,760 --> 00:26:14,080
and there are many vulnerable devices

719
00:26:14,080 --> 00:26:14,880
for instance

720
00:26:14,880 --> 00:26:16,640
apple on some android devices are

721
00:26:16,640 --> 00:26:18,720
vulnerable windows

722
00:26:18,720 --> 00:26:20,320
some network cards on windows are

723
00:26:20,320 --> 00:26:22,480
vulnerable home and professional access

724
00:26:22,480 --> 00:26:23,760
points are vulnerable

725
00:26:23,760 --> 00:26:26,880
and so on and this vulnerability can be

726
00:26:26,880 --> 00:26:27,440
used to

727
00:26:27,440 --> 00:26:30,880
trivially inject packets and i will now

728
00:26:30,880 --> 00:26:32,720
show a recorded demo where this is

729
00:26:32,720 --> 00:26:34,080
abused to remotely turn

730
00:26:34,080 --> 00:26:37,120
on and off a power socket

731
00:26:37,120 --> 00:26:39,120
this power socket can be manually turned

732
00:26:39,120 --> 00:26:41,039
on and off but can also be controlled

733
00:26:41,039 --> 00:26:42,640
over wi-fi

734
00:26:42,640 --> 00:26:45,039
as an attacker we can detect such power

735
00:26:45,039 --> 00:26:47,279
sockets based on their mac address

736
00:26:47,279 --> 00:26:48,720
without knowing the password of the

737
00:26:48,720 --> 00:26:50,960
wi-fi network the implementation flaw

738
00:26:50,960 --> 00:26:52,000
allows an attacker to

739
00:26:52,000 --> 00:26:54,000
easily inject packets into the wi-fi

740
00:26:54,000 --> 00:26:55,200
network

741
00:26:55,200 --> 00:26:56,960
because the power socket doesn't use a

742
00:26:56,960 --> 00:26:59,120
separate password on top of wi-fi

743
00:26:59,120 --> 00:27:01,039
this allows the adversary to remotely

744
00:27:01,039 --> 00:27:07,840
turn on and off the power socket

745
00:27:08,559 --> 00:27:10,480
another common implementation flaw is

746
00:27:10,480 --> 00:27:13,919
the so-called cloaked amsdu attack

747
00:27:13,919 --> 00:27:16,559
how does this attack work well to

748
00:27:16,559 --> 00:27:17,760
perform this attack

749
00:27:17,760 --> 00:27:20,080
the adversary sends the following wifi

750
00:27:20,080 --> 00:27:21,279
frame as an

751
00:27:21,279 --> 00:27:24,080
aggregated frame so the is aggregated

752
00:27:24,080 --> 00:27:25,279
flag is true

753
00:27:25,279 --> 00:27:28,000
and as content of the frame we first

754
00:27:28,000 --> 00:27:30,320
start with the following magic bytes

755
00:27:30,320 --> 00:27:32,159
and then at the end of the packet we

756
00:27:32,159 --> 00:27:35,039
include the packet that we want to

757
00:27:35,039 --> 00:27:35,600
inject

758
00:27:35,600 --> 00:27:38,880
into the network now how will a normal

759
00:27:38,880 --> 00:27:41,039
receiver process this frame

760
00:27:41,039 --> 00:27:43,520
well a normal receiver will first

761
00:27:43,520 --> 00:27:44,559
de-aggregate

762
00:27:44,559 --> 00:27:46,960
this frame and it will result in the

763
00:27:46,960 --> 00:27:48,159
following two

764
00:27:48,159 --> 00:27:51,279
packets the first packet here will be

765
00:27:51,279 --> 00:27:52,480
ignored because

766
00:27:52,480 --> 00:27:54,799
the metadata of this packet corresponds

767
00:27:54,799 --> 00:27:56,799
to these magic bytes and that's in fact

768
00:27:56,799 --> 00:27:59,840
invalid metadata meaning this first

769
00:27:59,840 --> 00:28:02,880
subpacket is ignored the second

770
00:28:02,880 --> 00:28:03,840
subpacket

771
00:28:03,840 --> 00:28:07,279
has valid metadata however

772
00:28:07,279 --> 00:28:09,919
it is sent in plain text and it does not

773
00:28:09,919 --> 00:28:11,919
correspond to a handshake frame because

774
00:28:11,919 --> 00:28:14,080
it looks like a normal data frame

775
00:28:14,080 --> 00:28:16,720
and therefore the second subpac this

776
00:28:16,720 --> 00:28:17,520
subpacket

777
00:28:17,520 --> 00:28:21,440
is also dropped now the problem is that

778
00:28:21,440 --> 00:28:23,039
a vulnerable device

779
00:28:23,039 --> 00:28:25,200
will switch the order of these two

780
00:28:25,200 --> 00:28:26,480
operations

781
00:28:26,480 --> 00:28:29,440
so a vulnerable device will first check

782
00:28:29,440 --> 00:28:31,600
if a plain text frame is a handshake

783
00:28:31,600 --> 00:28:32,880
frame

784
00:28:32,880 --> 00:28:35,039
but in this case the frame indeed

785
00:28:35,039 --> 00:28:37,360
corresponds to the magic bytes

786
00:28:37,360 --> 00:28:39,760
of a handshake frame meaning the full

787
00:28:39,760 --> 00:28:42,159
frame is now accepted

788
00:28:42,159 --> 00:28:44,960
and only after this does a vulnerable

789
00:28:44,960 --> 00:28:46,000
implementation

790
00:28:46,000 --> 00:28:49,039
de-aggregate the frame meaning

791
00:28:49,039 --> 00:28:52,240
only after accepting the frame does it

792
00:28:52,240 --> 00:28:52,960
split this

793
00:28:52,960 --> 00:28:55,200
aggregated frame into the su two

794
00:28:55,200 --> 00:28:56,640
sub-packets

795
00:28:56,640 --> 00:28:58,559
now this first subpacket is still

796
00:28:58,559 --> 00:29:00,240
ignored however

797
00:29:00,240 --> 00:29:02,640
the second subpacket which remember is

798
00:29:02,640 --> 00:29:04,000
send the plain text

799
00:29:04,000 --> 00:29:07,600
is now accepted this means that we as an

800
00:29:07,600 --> 00:29:08,480
adversary

801
00:29:08,480 --> 00:29:10,960
can abuse this vulnerability to inject

802
00:29:10,960 --> 00:29:12,480
plain text packets

803
00:29:12,480 --> 00:29:15,360
into a protected wi-fi network on the

804
00:29:15,360 --> 00:29:17,679
root cause is that implementations

805
00:29:17,679 --> 00:29:22,960
do these operations in the wrong order

806
00:29:22,960 --> 00:29:25,200
surprisingly many devices are affected

807
00:29:25,200 --> 00:29:26,880
for example freebsd

808
00:29:26,880 --> 00:29:30,000
some windows dongles three out of four

809
00:29:30,000 --> 00:29:32,320
home routers and even one professional

810
00:29:32,320 --> 00:29:33,919
access point

811
00:29:33,919 --> 00:29:36,080
and i'll now show a recorded demo where

812
00:29:36,080 --> 00:29:38,399
the cloaked amsdu flaw allows an

813
00:29:38,399 --> 00:29:40,559
attacker to inject packets towards the

814
00:29:40,559 --> 00:29:42,880
router

815
00:29:42,880 --> 00:29:45,279
more precisely in this demo the cloaked

816
00:29:45,279 --> 00:29:46,960
ams due vulnerability

817
00:29:46,960 --> 00:29:48,640
will be abused to punch a hole in the

818
00:29:48,640 --> 00:29:50,000
router's firewall

819
00:29:50,000 --> 00:29:52,000
so that the attacker can connect with on

820
00:29:52,000 --> 00:29:54,000
the tech devices in the victim's home

821
00:29:54,000 --> 00:29:56,080
network

822
00:29:56,080 --> 00:29:58,240
in our case the target is an outdated

823
00:29:58,240 --> 00:29:59,520
windows 7 computer

824
00:29:59,520 --> 00:30:01,679
that is vulnerable to blue keep this

825
00:30:01,679 --> 00:30:03,840
computer is inside a local network

826
00:30:03,840 --> 00:30:05,360
meaning someone on the internet cannot

827
00:30:05,360 --> 00:30:07,679
directly access it

828
00:30:07,679 --> 00:30:10,000
however the following script will punch

829
00:30:10,000 --> 00:30:11,919
a hole in the router's firewall

830
00:30:11,919 --> 00:30:13,600
such that an attacker on the internet

831
00:30:13,600 --> 00:30:17,440
can connect to local devices behind it

832
00:30:17,440 --> 00:30:19,600
first though i'll connect to the server

833
00:30:19,600 --> 00:30:21,600
and i'll start wireshark to capture any

834
00:30:21,600 --> 00:30:22,080
traffic

835
00:30:22,080 --> 00:30:25,200
that is sent towards it

836
00:30:25,200 --> 00:30:27,360
going back to the wi-fi attacker we can

837
00:30:27,360 --> 00:30:29,440
see that the script injects a plain text

838
00:30:29,440 --> 00:30:31,039
aggregated wifi frame

839
00:30:31,039 --> 00:30:32,880
that looks like a neopol handshake

840
00:30:32,880 --> 00:30:34,159
message

841
00:30:34,159 --> 00:30:35,840
this causes a vulnerable device to

842
00:30:35,840 --> 00:30:37,360
accept the injected frame

843
00:30:37,360 --> 00:30:40,000
even though it's not encrypted the frame

844
00:30:40,000 --> 00:30:41,039
is nevertheless

845
00:30:41,039 --> 00:30:43,600
processed as an aggregated wifi frame

846
00:30:43,600 --> 00:30:45,840
meaning we can sneak in a tcp packet

847
00:30:45,840 --> 00:30:49,120
inside the aggregated frame this tcp

848
00:30:49,120 --> 00:30:49,600
packet

849
00:30:49,600 --> 00:30:51,760
punches a hole in the router's firewall

850
00:30:51,760 --> 00:30:53,360
and is eventually received by the

851
00:30:53,360 --> 00:30:54,640
attacker

852
00:30:54,640 --> 00:30:56,640
from this we learn the public ip address

853
00:30:56,640 --> 00:30:58,559
on port that can be used to access the

854
00:30:58,559 --> 00:31:01,440
windows 7 machine

855
00:31:01,440 --> 00:31:03,120
we'll abuse this to take over the

856
00:31:03,120 --> 00:31:04,799
outdated windows 7 machine

857
00:31:04,799 --> 00:31:07,279
by exploiting blue keep we first

858
00:31:07,279 --> 00:31:09,519
configure metasploit with ip address on

859
00:31:09,519 --> 00:31:10,000
port

860
00:31:10,000 --> 00:31:13,279
and then run the exploit

861
00:31:14,240 --> 00:31:16,240
once the exploit completed we can

862
00:31:16,240 --> 00:31:18,000
monitor what the user is typing

863
00:31:18,000 --> 00:31:19,519
which we illustrate by stealing the

864
00:31:19,519 --> 00:31:22,799
login and password of the victim

865
00:31:22,799 --> 00:31:25,279
as another example it's also possible to

866
00:31:25,279 --> 00:31:27,279
take a screenshot of the windows machine

867
00:31:27,279 --> 00:31:30,640
to see what the victim is doing

868
00:31:31,039 --> 00:31:33,360
finally it's also possible to execute

869
00:31:33,360 --> 00:31:35,360
any program on the victim's machine

870
00:31:35,360 --> 00:31:37,200
which here is illustrated by starting

871
00:31:37,200 --> 00:31:40,080
the calculator

872
00:31:43,279 --> 00:31:45,039
i also discovered various other

873
00:31:45,039 --> 00:31:46,559
implementation flaws

874
00:31:46,559 --> 00:31:49,360
and i'll highlight a few of them first i

875
00:31:49,360 --> 00:31:49,760
found

876
00:31:49,760 --> 00:31:52,240
that various vulnerable implementations

877
00:31:52,240 --> 00:31:54,320
only require the last fragment to be

878
00:31:54,320 --> 00:31:55,360
encrypted

879
00:31:55,360 --> 00:31:57,120
and this is for example the case for

880
00:31:57,120 --> 00:32:00,159
many network cards on windows on linux

881
00:32:00,159 --> 00:32:02,159
and with this vulnerability it becomes

882
00:32:02,159 --> 00:32:04,320
more easy to perform the aggregation on

883
00:32:04,320 --> 00:32:05,039
cache attack

884
00:32:05,039 --> 00:32:07,919
design flaw on the other hand some

885
00:32:07,919 --> 00:32:10,080
implementations accept fragmented frames

886
00:32:10,080 --> 00:32:11,840
even if only the last fragment is

887
00:32:11,840 --> 00:32:12,720
encrypted

888
00:32:12,720 --> 00:32:14,480
and then it becomes trivial to inject

889
00:32:14,480 --> 00:32:16,080
packets into the network

890
00:32:16,080 --> 00:32:18,320
on for example free and netbsd is

891
00:32:18,320 --> 00:32:20,559
affected by this

892
00:32:20,559 --> 00:32:24,080
another vulnerability is that

893
00:32:24,080 --> 00:32:26,240
many receivers don't check whether

894
00:32:26,240 --> 00:32:27,200
fragments are

895
00:32:27,200 --> 00:32:31,600
consecutive remember that normally

896
00:32:31,600 --> 00:32:33,760
fragments of the same fray must have

897
00:32:33,760 --> 00:32:34,960
this consecutive

898
00:32:34,960 --> 00:32:38,399
packet number however in practically

899
00:32:38,399 --> 00:32:41,600
all implementations except linux they do

900
00:32:41,600 --> 00:32:43,200
not perform this check

901
00:32:43,200 --> 00:32:45,360
meaning we can mix fragments of

902
00:32:45,360 --> 00:32:47,279
different frames

903
00:32:47,279 --> 00:32:49,279
or put differently we can more easily

904
00:32:49,279 --> 00:32:52,720
perform the mixed key attack

905
00:32:52,720 --> 00:32:54,799
we also found that devices that do not

906
00:32:54,799 --> 00:32:56,480
support fragmentation

907
00:32:56,480 --> 00:32:59,840
are rather surprisingly still vulnerable

908
00:32:59,840 --> 00:33:01,200
to attacks

909
00:33:01,200 --> 00:33:04,480
for instance open b on open bsd on

910
00:33:04,480 --> 00:33:06,960
expressive iot chips they treat

911
00:33:06,960 --> 00:33:08,159
fragmented frames

912
00:33:08,159 --> 00:33:10,960
as full frames and under the right

913
00:33:10,960 --> 00:33:11,840
conditions

914
00:33:11,840 --> 00:33:14,320
this can still be abused to inject

915
00:33:14,320 --> 00:33:15,039
frames

916
00:33:15,039 --> 00:33:18,080
towards them and this really shows that

917
00:33:18,080 --> 00:33:20,799
all implementations are vulnerable even

918
00:33:20,799 --> 00:33:21,120
that

919
00:33:21,120 --> 00:33:23,279
those that don't support fragmentation

920
00:33:23,279 --> 00:33:24,559
and those that don't support

921
00:33:24,559 --> 00:33:27,279
aggregation are still vulnerable to

922
00:33:27,279 --> 00:33:29,679
attacks

923
00:33:29,919 --> 00:33:32,559
now to test if a device is vulnerable i

924
00:33:32,559 --> 00:33:33,120
created

925
00:33:33,120 --> 00:33:35,760
a test tool and it can detect all the

926
00:33:35,760 --> 00:33:37,760
vulnerabilities that i discussed in this

927
00:33:37,760 --> 00:33:39,440
presentation

928
00:33:39,440 --> 00:33:41,760
to test if a device is vulnerable you do

929
00:33:41,760 --> 00:33:42,960
need the credentials

930
00:33:42,960 --> 00:33:45,440
of the wi-fi network so this is not on a

931
00:33:45,440 --> 00:33:46,640
tech tool

932
00:33:46,640 --> 00:33:49,039
and this tool can also be used as the

933
00:33:49,039 --> 00:33:49,679
basis

934
00:33:49,679 --> 00:33:52,640
for future wi-fi research so i do

935
00:33:52,640 --> 00:33:53,919
recommend that you

936
00:33:53,919 --> 00:33:58,080
check it out now i want to discuss

937
00:33:58,080 --> 00:34:00,720
a few things first and for all why did

938
00:34:00,720 --> 00:34:02,559
it took more than two decades to

939
00:34:02,559 --> 00:34:05,200
discover these design flaws

940
00:34:05,200 --> 00:34:08,239
i think the first reason is that without

941
00:34:08,239 --> 00:34:10,159
modified drivers

942
00:34:10,159 --> 00:34:12,320
the attacks are not possible to perform

943
00:34:12,320 --> 00:34:13,359
in practice

944
00:34:13,359 --> 00:34:16,079
so maybe someone had the id but was

945
00:34:16,079 --> 00:34:17,359
unable to verify

946
00:34:17,359 --> 00:34:20,480
their ids in practice

947
00:34:20,480 --> 00:34:22,719
second the fragmentation and aggregation

948
00:34:22,719 --> 00:34:24,480
functionality of wi-fi

949
00:34:24,480 --> 00:34:27,359
were never considered security essential

950
00:34:27,359 --> 00:34:31,040
so nobody really looked at them

951
00:34:31,040 --> 00:34:32,879
there's also some general lessons that

952
00:34:32,879 --> 00:34:34,639
we can learn from this

953
00:34:34,639 --> 00:34:36,639
first and for all we should adopt

954
00:34:36,639 --> 00:34:38,239
defenses early

955
00:34:38,239 --> 00:34:40,480
even if the concerns are theoretic

956
00:34:40,480 --> 00:34:42,079
because that for example would have

957
00:34:42,079 --> 00:34:45,280
prevented the aggregation design flaw

958
00:34:45,280 --> 00:34:47,839
it is also important to properly isolate

959
00:34:47,839 --> 00:34:49,440
security context

960
00:34:49,440 --> 00:34:52,159
onto properly managed data that was

961
00:34:52,159 --> 00:34:53,040
decrypted

962
00:34:53,040 --> 00:34:55,520
under different keys and finally we

963
00:34:55,520 --> 00:34:56,159
should keep

964
00:34:56,159 --> 00:34:58,960
fuzzing devices near the wi-fi lines can

965
00:34:58,960 --> 00:34:59,440
help

966
00:34:59,440 --> 00:35:01,839
the wi-fi alliance can for instance fuss

967
00:35:01,839 --> 00:35:02,640
devices

968
00:35:02,640 --> 00:35:06,078
while they are being certified

969
00:35:06,400 --> 00:35:08,480
now to disclose these vulnerabilities i

970
00:35:08,480 --> 00:35:10,560
collaborated with the wi-fi alliance on

971
00:35:10,560 --> 00:35:11,599
ikasi

972
00:35:11,599 --> 00:35:14,400
through an embargo of roughly nine

973
00:35:14,400 --> 00:35:15,359
months

974
00:35:15,359 --> 00:35:18,640
and during this embargo i

975
00:35:18,640 --> 00:35:21,520
even created several updates to the test

976
00:35:21,520 --> 00:35:22,160
tool so

977
00:35:22,160 --> 00:35:24,560
to the in the sense the proof of concept

978
00:35:24,560 --> 00:35:26,240
and this really shows that this was an

979
00:35:26,240 --> 00:35:27,119
exceptional

980
00:35:27,119 --> 00:35:30,480
disclosure and i'm currently still doing

981
00:35:30,480 --> 00:35:30,960
some

982
00:35:30,960 --> 00:35:34,240
follow-up work so i'm helping the ieee

983
00:35:34,240 --> 00:35:34,640
with

984
00:35:34,640 --> 00:35:36,720
updating the wi-fi standard to fix the

985
00:35:36,720 --> 00:35:38,240
design flaws

986
00:35:38,240 --> 00:35:40,160
i'm currently maintaining the test tool

987
00:35:40,160 --> 00:35:42,800
and also double checking whether vendors

988
00:35:42,800 --> 00:35:43,599
are indeed

989
00:35:43,599 --> 00:35:46,880
implementing patches

990
00:35:46,880 --> 00:35:49,599
now looking back was this long

991
00:35:49,599 --> 00:35:50,720
multi-party

992
00:35:50,720 --> 00:35:54,079
coordinated disclosures worth it

993
00:35:54,079 --> 00:35:58,000
and well to my surprise some companies

994
00:35:58,000 --> 00:36:00,960
weren't happen weren't happy even if

995
00:36:00,960 --> 00:36:03,040
they managed to write patches for most

996
00:36:03,040 --> 00:36:04,480
devices

997
00:36:04,480 --> 00:36:06,640
and this was a bit disappointing to me

998
00:36:06,640 --> 00:36:08,560
because i was actually very happy that

999
00:36:08,560 --> 00:36:09,599
most devices

1000
00:36:09,599 --> 00:36:12,320
got patches because usually that's not

1001
00:36:12,320 --> 00:36:15,119
the case for wifi

1002
00:36:15,119 --> 00:36:18,400
fortunately most vendors did appreciate

1003
00:36:18,400 --> 00:36:18,800
this

1004
00:36:18,800 --> 00:36:21,200
long embargo and here in particular i

1005
00:36:21,200 --> 00:36:21,920
want to thank

1006
00:36:21,920 --> 00:36:25,520
cisco lancome aruba huawei ubiquity

1007
00:36:25,520 --> 00:36:28,640
mediatek samsung and netgear for their

1008
00:36:28,640 --> 00:36:29,359
positive

1009
00:36:29,359 --> 00:36:33,040
responses if you are watching a recorded

1010
00:36:33,040 --> 00:36:34,880
video you can pause on this slide

1011
00:36:34,880 --> 00:36:37,760
for the references and with that i come

1012
00:36:37,760 --> 00:36:39,119
to the conclusion

1013
00:36:39,119 --> 00:36:41,920
i discovered three design flaws in wi-fi

1014
00:36:41,920 --> 00:36:42,240
on

1015
00:36:42,240 --> 00:36:45,359
multiple implementation vulnerabilities

1016
00:36:45,359 --> 00:36:47,359
in practice the implementation flaws are

1017
00:36:47,359 --> 00:36:49,040
the easiest to abuse

1018
00:36:49,040 --> 00:36:51,040
and the design flaws can be a bit more

1019
00:36:51,040 --> 00:36:52,560
tricky to abuse

1020
00:36:52,560 --> 00:36:54,720
and for more information you can visit

1021
00:36:54,720 --> 00:36:55,599
the following

1022
00:36:55,599 --> 00:37:02,720
url thank you for your attention

