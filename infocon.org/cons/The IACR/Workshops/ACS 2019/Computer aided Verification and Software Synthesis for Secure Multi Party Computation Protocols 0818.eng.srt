1
00:00:05,240 --> 00:00:11,600
all right thank you I really think Sam I

2
00:00:09,170 --> 00:00:14,629
mean he like the question this is

3
00:00:11,600 --> 00:00:16,460
exactly the perfect setup for this this

4
00:00:14,629 --> 00:00:18,410
is ongoing work I mean not ongoing I

5
00:00:16,460 --> 00:00:21,080
mean it's gonna be presented at CCS it's

6
00:00:18,410 --> 00:00:23,060
on ePrint it's exactly to tackle some of

7
00:00:21,080 --> 00:00:27,049
the problems or the issues that were

8
00:00:23,060 --> 00:00:28,520
brought up and all the points that he

9
00:00:27,050 --> 00:00:30,590
pointed out clearly has a lot of

10
00:00:28,520 --> 00:00:33,640
experience actually digging deeper into

11
00:00:30,590 --> 00:00:36,769
these protocols and implementing them I

12
00:00:33,640 --> 00:00:39,410
claim that hopefully what you get out of

13
00:00:36,770 --> 00:00:40,880
this talk that you would be forced to do

14
00:00:39,410 --> 00:00:42,620
these things if you use an interactive

15
00:00:40,880 --> 00:00:44,540
sea improver or computer-aided

16
00:00:42,620 --> 00:00:45,890
verification for your protocols all

17
00:00:44,540 --> 00:00:47,780
right so what this talk is not about

18
00:00:45,890 --> 00:00:50,059
there are no new protocols no hardness

19
00:00:47,780 --> 00:00:54,100
assumptions or I'm not also talking

20
00:00:50,059 --> 00:00:57,050
about you see yet we're doing game based

21
00:00:54,100 --> 00:00:59,750
verification sort of modeling also and

22
00:00:57,050 --> 00:01:01,339
we're also not what I'm not talking

23
00:00:59,750 --> 00:01:02,930
about having the computer find the

24
00:01:01,340 --> 00:01:04,699
protocol or proof for you this is

25
00:01:02,930 --> 00:01:07,219
basically if you have a specific

26
00:01:04,699 --> 00:01:09,950
protocol and a proof for it and you want

27
00:01:07,219 --> 00:01:12,229
to get high confidence in it and also

28
00:01:09,950 --> 00:01:14,360
what I wanna hopefully you get out of

29
00:01:12,229 --> 00:01:16,369
this talk is that if you've been through

30
00:01:14,360 --> 00:01:19,210
the trouble of actually verifying it in

31
00:01:16,369 --> 00:01:22,130
a formal model I'm like a fear improver

32
00:01:19,210 --> 00:01:23,960
you have to do a little bit of work and

33
00:01:22,130 --> 00:01:29,179
you will get an executable out of it

34
00:01:23,960 --> 00:01:32,750
that is correctly constructed okay just

35
00:01:29,180 --> 00:01:34,490
a the Katori slide on MPC protocol that

36
00:01:32,750 --> 00:01:36,560
allows a bunch of mistrusting parties

37
00:01:34,490 --> 00:01:39,289
typically software to compute a function

38
00:01:36,560 --> 00:01:41,180
under private input historically semi

39
00:01:39,290 --> 00:01:42,979
honest passive honest but curious the

40
00:01:41,180 --> 00:01:44,869
model that cares more about privacy and

41
00:01:42,979 --> 00:01:47,090
the act of one or the malicious one is

42
00:01:44,869 --> 00:01:48,500
where you basically can have cheating

43
00:01:47,090 --> 00:01:51,229
and arbitrary deviation from the

44
00:01:48,500 --> 00:01:53,810
protocol I'm not gonna go through this I

45
00:01:51,229 --> 00:01:55,400
mean this crowd doesn't need it but the

46
00:01:53,810 --> 00:01:57,020
reason why I just want if anybody

47
00:01:55,400 --> 00:01:58,579
doesn't know secret sharing is you

48
00:01:57,020 --> 00:01:59,979
have the share and reconstruct protocol

49
00:01:58,579 --> 00:02:02,720
is because I want to show you actually

50
00:01:59,979 --> 00:02:04,340
formalizing it easy crypt and show you

51
00:02:02,720 --> 00:02:06,530
what I want you to walk away to

52
00:02:04,340 --> 00:02:09,189
basically the message is that this is

53
00:02:06,530 --> 00:02:12,560
possible like MPC I consider it as a

54
00:02:09,189 --> 00:02:13,760
advanced cryptographic protocol and

55
00:02:12,560 --> 00:02:15,980
primitive and it's not that

56
00:02:13,760 --> 00:02:18,620
straightforward to implement especially

57
00:02:15,980 --> 00:02:21,590
once you get to the malicious and active

58
00:02:18,620 --> 00:02:22,879
and also adaptive adversaries one more

59
00:02:21,590 --> 00:02:25,970
thing I'm going to talk about is okay

60
00:02:22,879 --> 00:02:27,470
over long period of time if you have

61
00:02:25,970 --> 00:02:29,060
things our secret chair then mobile

62
00:02:27,470 --> 00:02:31,640
adversary can basically collect all

63
00:02:29,060 --> 00:02:33,860
shares this has been handled in the

64
00:02:31,640 --> 00:02:35,599
literature before in the proactive

65
00:02:33,860 --> 00:02:38,120
setting where you basically are going to

66
00:02:35,599 --> 00:02:39,530
move sort of your you're moving the

67
00:02:38,120 --> 00:02:41,870
polynomials that you're sharing with

68
00:02:39,530 --> 00:02:43,909
over time so that somebody that is

69
00:02:41,870 --> 00:02:45,920
comparing to compromise and get all the

70
00:02:43,909 --> 00:02:48,500
shares over times you're resetting

71
00:02:45,920 --> 00:02:50,958
parties and starting them from scratch

72
00:02:48,500 --> 00:02:52,310
they need to recover their shares from

73
00:02:50,959 --> 00:02:54,500
the existing polynomial so you cannot

74
00:02:52,310 --> 00:02:57,019
stitch things together I mean this is

75
00:02:54,500 --> 00:02:58,519
very basic I just wanna you to be aware

76
00:02:57,019 --> 00:03:00,650
of this because I will show you

77
00:02:58,519 --> 00:03:04,489
formalism that actually implements this

78
00:03:00,650 --> 00:03:07,909
stuff all right

79
00:03:04,489 --> 00:03:09,980
okay so the reason what I'm saying NPC

80
00:03:07,909 --> 00:03:12,048
starts to become much more complex is

81
00:03:09,980 --> 00:03:13,640
once you start to worry about dynamic

82
00:03:12,049 --> 00:03:15,829
groups and things like proactive

83
00:03:13,640 --> 00:03:19,429
security very quickly you'll find that

84
00:03:15,829 --> 00:03:22,459
your MPC protocol has seven eight or

85
00:03:19,430 --> 00:03:24,500
nine sub protocols and that's why you

86
00:03:22,459 --> 00:03:26,180
see and composability is very important

87
00:03:24,500 --> 00:03:27,470
but that's at the protocol design what

88
00:03:26,180 --> 00:03:31,579
about the software this is non-trivial

89
00:03:27,470 --> 00:03:33,739
so just when you refresh shares the

90
00:03:31,579 --> 00:03:36,560
standard trick is if you basically had

91
00:03:33,739 --> 00:03:38,329
multiple shares on a polynomial

92
00:03:36,560 --> 00:03:40,250
everybody gets the evaluation of the

93
00:03:38,329 --> 00:03:42,739
polynomial so a simple way to refresh it

94
00:03:40,250 --> 00:03:45,139
is ver sorry to refresh is generate a

95
00:03:42,739 --> 00:03:46,790
polynomial that evaluates to zeros

96
00:03:45,139 --> 00:03:49,010
that's the green one ad where the

97
00:03:46,790 --> 00:03:50,690
secrets are share it again everybody

98
00:03:49,010 --> 00:03:52,040
deletes their own CH they're all chairs

99
00:03:50,690 --> 00:03:54,290
so basically what you get is a new

100
00:03:52,040 --> 00:03:56,599
sharing of the same secret when you

101
00:03:54,290 --> 00:03:59,000
recover share is basically when a party

102
00:03:56,599 --> 00:04:00,619
leaves the protocol and comes up again

103
00:03:59,000 --> 00:04:02,180
you need to give it doesn't have any

104
00:04:00,620 --> 00:04:06,889
state you need to give it existing

105
00:04:02,180 --> 00:04:09,470
shares so this is very basic MPC has

106
00:04:06,889 --> 00:04:11,599
been known since 88 bgw is one of the

107
00:04:09,470 --> 00:04:13,879
most fundamental protocol this is an

108
00:04:11,599 --> 00:04:17,988
interesting fact there wants no fully

109
00:04:13,879 --> 00:04:20,238
specified proof till 2011 and once you

110
00:04:17,988 --> 00:04:23,000
get and I highly I mean this is very

111
00:04:20,238 --> 00:04:25,039
appreciated that the work that our share

112
00:04:23,000 --> 00:04:26,659
of and lindo go through to specify

113
00:04:25,039 --> 00:04:30,500
everything in detail and have a

114
00:04:26,659 --> 00:04:32,000
foolproof that's a long time okay and

115
00:04:30,500 --> 00:04:32,270
when you look at that paper that's like

116
00:04:32,000 --> 00:04:34,460
an

117
00:04:32,270 --> 00:04:40,090
eighty-seven page paper eighty-four

118
00:04:34,460 --> 00:04:42,979
pages of it is about passive and static

119
00:04:40,090 --> 00:04:46,940
static active when you start to get into

120
00:04:42,980 --> 00:04:49,700
adaptive malicious adversaries and also

121
00:04:46,940 --> 00:04:51,200
composability there's a lot of other

122
00:04:49,700 --> 00:04:53,360
papers that you need to refer to and

123
00:04:51,200 --> 00:04:55,250
theorems this is highly non-trivial so

124
00:04:53,360 --> 00:04:57,440
actually even implementing something for

125
00:04:55,250 --> 00:05:00,020
adaptive active adversity is I don't

126
00:04:57,440 --> 00:05:03,920
know if anybody did it but it's whatever

127
00:05:00,020 --> 00:05:06,469
happened is none trip so basically why

128
00:05:03,920 --> 00:05:08,480
worry about verifying NPC because one it

129
00:05:06,470 --> 00:05:10,360
provides an existent proof that you can

130
00:05:08,480 --> 00:05:12,410
tackle in computer data verification

131
00:05:10,360 --> 00:05:13,760
complex protocols and then people now

132
00:05:12,410 --> 00:05:15,440
are talking about zero knowledge who

133
00:05:13,760 --> 00:05:18,950
morphic encryption I think we're ready

134
00:05:15,440 --> 00:05:20,780
to actually verify these in interactive

135
00:05:18,950 --> 00:05:23,150
to your improvers they're becoming

136
00:05:20,780 --> 00:05:25,669
increasingly relied event in blockchain

137
00:05:23,150 --> 00:05:27,380
settings and not only that honestly if

138
00:05:25,670 --> 00:05:29,240
you were at the talk yesterday the

139
00:05:27,380 --> 00:05:31,190
blockchain Dalya Malky mentioned this

140
00:05:29,240 --> 00:05:34,760
protocol this is a consensus protocol

141
00:05:31,190 --> 00:05:36,950
ziva that was written in 2007 and ten

142
00:05:34,760 --> 00:05:39,289
years later they found that the liveness

143
00:05:36,950 --> 00:05:42,140
and safety conditions were violated in

144
00:05:39,290 --> 00:05:43,490
very simple scenarios ten years to do

145
00:05:42,140 --> 00:05:45,919
that and this is something that doesn't

146
00:05:43,490 --> 00:05:47,780
even worry about confidentiality and

147
00:05:45,920 --> 00:05:51,020
privacy of inputs MPC is way more

148
00:05:47,780 --> 00:05:52,520
complicated so I'm not saying that the

149
00:05:51,020 --> 00:05:53,479
implicit protocols have issues in them

150
00:05:52,520 --> 00:05:56,150
I'm saying this is like higher

151
00:05:53,480 --> 00:05:59,240
confidence level of confidence that's

152
00:05:56,150 --> 00:06:01,729
just not there yet and if we if we go

153
00:05:59,240 --> 00:06:04,070
there to build infrastructure that

154
00:06:01,730 --> 00:06:05,990
should last for decades I think this is

155
00:06:04,070 --> 00:06:06,650
the best way to go to get that level of

156
00:06:05,990 --> 00:06:08,750
confidence

157
00:06:06,650 --> 00:06:10,549
all right there's already been some

158
00:06:08,750 --> 00:06:12,500
workshops and people talking there's

159
00:06:10,550 --> 00:06:13,910
some funding programs about so there is

160
00:06:12,500 --> 00:06:16,490
interest in the community of sort of

161
00:06:13,910 --> 00:06:18,110
merging cryptography and the PL

162
00:06:16,490 --> 00:06:21,350
community and get formal verification

163
00:06:18,110 --> 00:06:22,760
it's just that so far they talk I've

164
00:06:21,350 --> 00:06:24,920
been to that workshop it was very useful

165
00:06:22,760 --> 00:06:27,530
different languages and it's it's

166
00:06:24,920 --> 00:06:29,570
unclear how soon we can sort of sort of

167
00:06:27,530 --> 00:06:32,000
merge both and hopefully this work

168
00:06:29,570 --> 00:06:34,820
provides evidence that it's gonna happen

169
00:06:32,000 --> 00:06:37,970
soon and people can build on it all

170
00:06:34,820 --> 00:06:39,740
right so my opinion is that and just

171
00:06:37,970 --> 00:06:42,170
gonna mention here and this is the end

172
00:06:39,740 --> 00:06:44,690
of the fluffy stuff it's all gonna be

173
00:06:42,170 --> 00:06:46,099
more technical from now is that when you

174
00:06:44,690 --> 00:06:48,020
talk about formal verification

175
00:06:46,099 --> 00:06:49,938
don't only talk about the specification

176
00:06:48,020 --> 00:06:51,948
of the protocol might as well get

177
00:06:49,939 --> 00:06:55,069
executable software that is correctly

178
00:06:51,949 --> 00:06:56,900
constructed because what you but I

179
00:06:55,069 --> 00:07:00,620
learned in the last year going through

180
00:06:56,900 --> 00:07:02,659
that exercise is that you're almost 80%

181
00:07:00,620 --> 00:07:04,009
of the way through when you use one of

182
00:07:02,659 --> 00:07:07,310
these theorem provers to actually

183
00:07:04,009 --> 00:07:08,569
formalize any protocol all right so easy

184
00:07:07,310 --> 00:07:09,830
Krypton are not sure if you haven't

185
00:07:08,569 --> 00:07:12,800
heard about it it's an interactive

186
00:07:09,830 --> 00:07:15,139
theorem prover that basically allows you

187
00:07:12,800 --> 00:07:17,389
it has a probabilistic language that

188
00:07:15,139 --> 00:07:19,279
allows you to describe a lot of the

189
00:07:17,389 --> 00:07:21,800
primitives and the constructions we use

190
00:07:19,279 --> 00:07:23,779
in papers so that you can sample from

191
00:07:21,800 --> 00:07:26,509
random distribution can be hooked to

192
00:07:23,779 --> 00:07:29,379
interact with your improver and SMT this

193
00:07:26,509 --> 00:07:32,599
is satisfiable modulo Theory solvers to

194
00:07:29,379 --> 00:07:34,250
automate the proofs this is following

195
00:07:32,599 --> 00:07:35,659
the construction of it architecture is

196
00:07:34,250 --> 00:07:38,360
following some work from bellari

197
00:07:35,659 --> 00:07:40,460
that basically is proposing to verify

198
00:07:38,360 --> 00:07:44,389
crypto protocol as gos code based sort

199
00:07:40,460 --> 00:07:46,909
of objects typically you would describe

200
00:07:44,389 --> 00:07:48,770
a construction or a protocol as a module

201
00:07:46,909 --> 00:07:50,300
some some global variables and

202
00:07:48,770 --> 00:07:52,758
procedures and definitions and then

203
00:07:50,300 --> 00:07:55,460
there's multiple levels at which you

204
00:07:52,759 --> 00:07:57,289
would verify something like this so for

205
00:07:55,460 --> 00:07:58,818
instance like take L gamma a text book

206
00:07:57,289 --> 00:08:00,800
ill gamma I mean if you write an easy

207
00:07:58,819 --> 00:08:03,409
crip as you would write it in your paper

208
00:08:00,800 --> 00:08:06,139
you have three function three procedures

209
00:08:03,409 --> 00:08:09,199
or algorithms key generation encrypt and

210
00:08:06,139 --> 00:08:12,020
decrypt and they have already operators

211
00:08:09,199 --> 00:08:14,990
to sample randomly from let's say a

212
00:08:12,020 --> 00:08:16,698
group of a specific order so this is not

213
00:08:14,990 --> 00:08:19,310
far away from how you would write in

214
00:08:16,699 --> 00:08:21,979
tech your your protocol so what I'm

215
00:08:19,310 --> 00:08:24,139
advocating is if you write this first

216
00:08:21,979 --> 00:08:26,930
and then extract from attack which is

217
00:08:24,139 --> 00:08:29,629
actually possible I think that's the

218
00:08:26,930 --> 00:08:31,759
right way to do it so what we did in

219
00:08:29,629 --> 00:08:35,329
this paper which we presented at CCS is

220
00:08:31,759 --> 00:08:36,860
we did the following we defined abstract

221
00:08:35,328 --> 00:08:38,989
definition for a lot of the primitives

222
00:08:36,860 --> 00:08:40,310
that you would have an NPC not ot I mean

223
00:08:38,990 --> 00:08:42,049
I think that should be done but what we

224
00:08:40,309 --> 00:08:43,789
did is we did secret sharing a lot of

225
00:08:42,049 --> 00:08:46,430
variations of secret chain your standard

226
00:08:43,789 --> 00:08:49,640
Shamir one by some polynomial additive

227
00:08:46,430 --> 00:08:51,800
gradual we did MPC an abstract

228
00:08:49,640 --> 00:08:54,290
definition and then we proved some

229
00:08:51,800 --> 00:08:56,930
compositions theorem at that abstract

230
00:08:54,290 --> 00:08:59,430
level then basically what you do is for

231
00:08:56,930 --> 00:09:01,979
each abstract primitive you need to have

232
00:08:59,430 --> 00:09:03,959
a instantiation of it which is like

233
00:09:01,980 --> 00:09:06,270
Engineers case basically you select a

234
00:09:03,960 --> 00:09:08,790
polynomial of a specific degree over a

235
00:09:06,270 --> 00:09:10,350
field and then you prove equivalence of

236
00:09:08,790 --> 00:09:13,069
the abstract definition and the actual

237
00:09:10,350 --> 00:09:17,580
instantiation of the primitive and then

238
00:09:13,070 --> 00:09:19,709
basically you would prove security

239
00:09:17,580 --> 00:09:21,660
that's equivalent you can extract from

240
00:09:19,709 --> 00:09:24,510
the specification you have a security

241
00:09:21,660 --> 00:09:26,399
game also and then you basically prove

242
00:09:24,510 --> 00:09:27,839
you have to specify the proof in Easy

243
00:09:26,399 --> 00:09:29,520
Clip and I'll show you examples of this

244
00:09:27,839 --> 00:09:31,230
it's not gonna stay that high level it's

245
00:09:29,520 --> 00:09:33,270
just I want you to walk away with the

246
00:09:31,230 --> 00:09:36,420
overall sort of mental map of what

247
00:09:33,270 --> 00:09:38,430
happens so we have game based security

248
00:09:36,420 --> 00:09:41,550
definition for each of the primitives we

249
00:09:38,430 --> 00:09:43,410
code the actual proofs and verify them

250
00:09:41,550 --> 00:09:45,029
an easy crypt but that's only half the

251
00:09:43,410 --> 00:09:46,649
story or like two-thirds of the story

252
00:09:45,029 --> 00:09:49,080
the interesting thing that we observed

253
00:09:46,649 --> 00:09:51,899
is the language of easy crypt is very

254
00:09:49,080 --> 00:09:54,420
close to a language called yml which you

255
00:09:51,899 --> 00:09:56,790
can automatically extract from it Oh

256
00:09:54,420 --> 00:09:59,660
camel which is executable in a verified

257
00:09:56,790 --> 00:10:01,980
way exactly the question that was raised

258
00:09:59,660 --> 00:10:04,050
before before I walked on the stage I

259
00:10:01,980 --> 00:10:06,650
think this is possible and I think this

260
00:10:04,050 --> 00:10:10,310
is how things should be done because

261
00:10:06,650 --> 00:10:13,680
expecting software developers to learn

262
00:10:10,310 --> 00:10:16,739
cryptography the cryptographers also are

263
00:10:13,680 --> 00:10:19,319
not going to write the code so it's much

264
00:10:16,740 --> 00:10:21,720
easier if the protocol designer uses a

265
00:10:19,320 --> 00:10:23,550
tool like this and then you get the

266
00:10:21,720 --> 00:10:26,180
whole thing automated and again in a

267
00:10:23,550 --> 00:10:28,890
verifiable way all right so this is not

268
00:10:26,180 --> 00:10:30,150
happening in vacuum I mean in the last

269
00:10:28,890 --> 00:10:32,520
several years have been a lot of

270
00:10:30,150 --> 00:10:34,860
interesting efforts sort of slowly

271
00:10:32,520 --> 00:10:38,490
making progress towards this but till

272
00:10:34,860 --> 00:10:41,040
this paper nobody has verified a generic

273
00:10:38,490 --> 00:10:44,640
MPC protocol for n parties for the act

274
00:10:41,040 --> 00:10:47,370
of setting active adversaries and had

275
00:10:44,640 --> 00:10:50,370
the whole proof in easy crypt and also

276
00:10:47,370 --> 00:10:52,740
nobody had extracted software from that

277
00:10:50,370 --> 00:10:54,480
proof specification or that formalism

278
00:10:52,740 --> 00:10:57,720
that is actually executable and that's

279
00:10:54,480 --> 00:11:01,589
what we have in in our paper previous

280
00:10:57,720 --> 00:11:03,180
work has looked at like the SV 17

281
00:11:01,589 --> 00:11:05,339
private count retrieval that's a

282
00:11:03,180 --> 00:11:07,650
protocol for three parties that is

283
00:11:05,339 --> 00:11:09,150
basically counting the number of records

284
00:11:07,650 --> 00:11:11,040
that match a certain query in a database

285
00:11:09,150 --> 00:11:12,540
and they only did it for the passive

286
00:11:11,040 --> 00:11:16,670
model

287
00:11:12,540 --> 00:11:19,079
in ccs 17 they did it for Yahoo

288
00:11:16,670 --> 00:11:21,120
two-party computation horrible circuits

289
00:11:19,079 --> 00:11:23,489
but also only for passive and they did

290
00:11:21,120 --> 00:11:27,480
extract executable software and then

291
00:11:23,490 --> 00:11:29,010
finally in 18h K+ they did it for a

292
00:11:27,480 --> 00:11:30,930
protocol by only Maurer that's very

293
00:11:29,010 --> 00:11:33,060
simple the beauty of that protocol is

294
00:11:30,930 --> 00:11:34,410
it's not only for threshold adversary

295
00:11:33,060 --> 00:11:36,899
structures for general adversary

296
00:11:34,410 --> 00:11:38,730
structures but there's a catch here that

297
00:11:36,899 --> 00:11:40,800
the protocol they didn't have the whole

298
00:11:38,730 --> 00:11:42,660
proof actually formalized in easy crypt

299
00:11:40,800 --> 00:11:46,079
if you read the paper carefully you find

300
00:11:42,660 --> 00:11:47,910
that they did at some point prove that

301
00:11:46,079 --> 00:11:49,319
the protocol satisfies some properties

302
00:11:47,910 --> 00:11:50,850
and then they have a manual step where

303
00:11:49,320 --> 00:11:52,320
they say oh if these properties are

304
00:11:50,850 --> 00:11:54,000
satisfied there in protocol then you

305
00:11:52,320 --> 00:11:56,670
have a simulator but it was never really

306
00:11:54,000 --> 00:11:58,529
coded an easy crypt I think it's doable

307
00:11:56,670 --> 00:12:01,019
they just didn't and they also didn't

308
00:11:58,529 --> 00:12:05,279
bother extracting executable software

309
00:12:01,019 --> 00:12:06,720
from the formalism and easy crypt so

310
00:12:05,279 --> 00:12:08,579
okay so I've been talking now about

311
00:12:06,720 --> 00:12:09,930
these abstract definitions so this would

312
00:12:08,579 --> 00:12:11,939
be for instance an example of an

313
00:12:09,930 --> 00:12:14,579
abstract definition of secret share okay

314
00:12:11,940 --> 00:12:17,250
the same way you would define it in a

315
00:12:14,579 --> 00:12:18,839
paper right when you start writing about

316
00:12:17,250 --> 00:12:20,459
let's say I'm going to use secret

317
00:12:18,839 --> 00:12:22,139
sharing you define have a definition

318
00:12:20,459 --> 00:12:23,579
that says secret sharing which is

319
00:12:22,139 --> 00:12:24,750
essentially what matters is what's in

320
00:12:23,579 --> 00:12:27,599
the red box there are two algorithms

321
00:12:24,750 --> 00:12:29,670
share and reconstruct takes an input

322
00:12:27,600 --> 00:12:31,680
some randomness a secret and output some

323
00:12:29,670 --> 00:12:35,160
shares and the reconstruct takes the

324
00:12:31,680 --> 00:12:36,630
shares and outputs some I mean all this

325
00:12:35,160 --> 00:12:39,180
code is in the paper and we have it on

326
00:12:36,630 --> 00:12:40,980
also on github so I mean the link I'm

327
00:12:39,180 --> 00:12:44,670
happy to turn it or see people taking

328
00:12:40,980 --> 00:12:46,949
pictures it's all open source so

329
00:12:44,670 --> 00:12:48,750
basically this is you're not really

330
00:12:46,949 --> 00:12:51,449
specifying how you're going to share or

331
00:12:48,750 --> 00:12:52,769
reconstruct so you do this once the the

332
00:12:51,449 --> 00:12:54,660
good thing about this working at the

333
00:12:52,769 --> 00:12:57,000
abstract level is you do it once and

334
00:12:54,660 --> 00:12:59,310
then later on every time you instantiate

335
00:12:57,000 --> 00:13:02,010
it using a different I know mathematical

336
00:12:59,310 --> 00:13:04,949
structure I know you can do additive

337
00:13:02,010 --> 00:13:07,199
sharing or using polynomials it doesn't

338
00:13:04,949 --> 00:13:10,019
matter it still will satisfy these two

339
00:13:07,199 --> 00:13:12,870
conditions sorry I mean these two

340
00:13:10,019 --> 00:13:14,430
definitions then you can also do it I

341
00:13:12,870 --> 00:13:17,639
mean we did it all this code is

342
00:13:14,430 --> 00:13:20,609
therefore verifiable secret sharing now

343
00:13:17,639 --> 00:13:22,709
similar the way you would implement in

344
00:13:20,610 --> 00:13:24,750
C++ or any other object oriented

345
00:13:22,709 --> 00:13:25,719
language where you inherit a class and

346
00:13:24,750 --> 00:13:27,310
then overload

347
00:13:25,720 --> 00:13:29,200
for instance some of the members we're

348
00:13:27,310 --> 00:13:31,300
doing here the same thing now the the

349
00:13:29,200 --> 00:13:33,010
share and reconstruct operations are a

350
00:13:31,300 --> 00:13:35,380
little bit more involved because it's

351
00:13:33,010 --> 00:13:38,200
verifiable but you can do the same thing

352
00:13:35,380 --> 00:13:40,210
for this is now not this is not the

353
00:13:38,200 --> 00:13:41,620
abstract definition anymore now that we

354
00:13:40,210 --> 00:13:43,390
have the abstract definition this is the

355
00:13:41,620 --> 00:13:44,980
concrete implementation of secret

356
00:13:43,390 --> 00:13:48,280
sharing that's following Shamir

357
00:13:44,980 --> 00:13:49,780
basically what this map says is

358
00:13:48,280 --> 00:13:52,720
basically saying you take some

359
00:13:49,780 --> 00:13:55,150
randomness and a secret of type secret T

360
00:13:52,720 --> 00:13:59,620
which you define up there and then you

361
00:13:55,150 --> 00:14:02,530
evaluate a polynomial using that secret

362
00:13:59,620 --> 00:14:04,870
as the free term and the randomness I

363
00:14:02,530 --> 00:14:08,740
mean if you were here on the talk before

364
00:14:04,870 --> 00:14:10,690
I think it was who was it was talking

365
00:14:08,740 --> 00:14:14,710
about the IETF standardization process

366
00:14:10,690 --> 00:14:18,700
BLS signatures at some point he said you

367
00:14:14,710 --> 00:14:21,700
might make the the sampling of the the

368
00:14:18,700 --> 00:14:24,400
the keys I think make it deterministic

369
00:14:21,700 --> 00:14:25,540
and pass it a random randomness and

370
00:14:24,400 --> 00:14:27,069
don't verify

371
00:14:25,540 --> 00:14:28,420
I mean don't don't sort of explicitly

372
00:14:27,070 --> 00:14:30,760
say how that randomness it should be

373
00:14:28,420 --> 00:14:32,620
chosen this issue actually encountered

374
00:14:30,760 --> 00:14:34,750
that when we're trying to formalize this

375
00:14:32,620 --> 00:14:36,070
we realize that it's easier to pass the

376
00:14:34,750 --> 00:14:38,440
randomness as sort of like the

377
00:14:36,070 --> 00:14:40,750
polynomial typically when you write a

378
00:14:38,440 --> 00:14:42,730
secret sharing sort of like on paper so

379
00:14:40,750 --> 00:14:44,560
you you say okay I'm going to select

380
00:14:42,730 --> 00:14:46,060
random coefficients and then put the

381
00:14:44,560 --> 00:14:47,589
secret and the free term and that

382
00:14:46,060 --> 00:14:49,089
determines the polynomial here what I'm

383
00:14:47,590 --> 00:14:50,770
saying is the randomness you're gonna

384
00:14:49,090 --> 00:14:52,930
pass me is going to be a random

385
00:14:50,770 --> 00:14:55,750
polynomial with a zero free term and I'm

386
00:14:52,930 --> 00:14:56,829
done adding to it the actual secret so

387
00:14:55,750 --> 00:14:59,890
that it's in the free term and then

388
00:14:56,830 --> 00:15:02,200
share it what I found is when you try to

389
00:14:59,890 --> 00:15:05,380
formalize things there are multiple ways

390
00:15:02,200 --> 00:15:07,120
to do to do the formalism and each one

391
00:15:05,380 --> 00:15:08,650
can make your life later on easier or

392
00:15:07,120 --> 00:15:10,720
harder there's no right answer it's

393
00:15:08,650 --> 00:15:13,630
really up to your experience and your

394
00:15:10,720 --> 00:15:15,190
taste so we have the same thing for

395
00:15:13,630 --> 00:15:17,290
instance this would be additive secret

396
00:15:15,190 --> 00:15:19,210
sharing a concrete implementation of it

397
00:15:17,290 --> 00:15:20,770
that satisfies that abstract definition

398
00:15:19,210 --> 00:15:22,750
and then we have the same thing

399
00:15:20,770 --> 00:15:27,579
commitment scheme Peterson and Feldman

400
00:15:22,750 --> 00:15:29,680
and then what we have in the paper is at

401
00:15:27,580 --> 00:15:32,560
the abstract level where we're proving

402
00:15:29,680 --> 00:15:34,359
that if you combine a primitive that

403
00:15:32,560 --> 00:15:37,000
satisfies the honest but curious

404
00:15:34,360 --> 00:15:37,990
definition for basically that the shares

405
00:15:37,000 --> 00:15:40,950
are in

406
00:15:37,990 --> 00:15:43,089
and of the secret and then with a

407
00:15:40,950 --> 00:15:45,100
commitment scheme then you get the

408
00:15:43,089 --> 00:15:48,490
revival secret chair again this is

409
00:15:45,100 --> 00:15:50,260
proven at the abstract level and this

410
00:15:48,490 --> 00:15:52,750
framework basically anytime you

411
00:15:50,260 --> 00:15:56,140
instantiate any of these primitive using

412
00:15:52,750 --> 00:15:58,420
a concrete mathematical structure their

413
00:15:56,140 --> 00:15:59,980
protocol will inherit the composition

414
00:15:58,420 --> 00:16:03,040
proofs that you did at the abstract

415
00:15:59,980 --> 00:16:04,810
level so that's actually very useful

416
00:16:03,040 --> 00:16:06,250
because these compositions you prove

417
00:16:04,810 --> 00:16:07,869
once that mean this is not you see

418
00:16:06,250 --> 00:16:10,870
composition this is composition in

419
00:16:07,870 --> 00:16:12,640
series so we did the same thing for MPC

420
00:16:10,870 --> 00:16:14,410
just this is an abstract definition of

421
00:16:12,640 --> 00:16:16,720
what could be an MPC protocol I mean

422
00:16:14,410 --> 00:16:18,370
again this is very high-level it's like

423
00:16:16,720 --> 00:16:20,320
you have inputs you have players you

424
00:16:18,370 --> 00:16:22,510
have IDs of players you have phases you

425
00:16:20,320 --> 00:16:24,010
have an output phase doesn't say

426
00:16:22,510 --> 00:16:26,950
anything and we think of this as sort of

427
00:16:24,010 --> 00:16:28,569
the ideal function out but then you have

428
00:16:26,950 --> 00:16:31,360
to instantiate this actually using

429
00:16:28,570 --> 00:16:33,550
concrete protocols and and we have also

430
00:16:31,360 --> 00:16:34,750
because we're initially when we started

431
00:16:33,550 --> 00:16:36,760
were very ambitious we wanted to

432
00:16:34,750 --> 00:16:39,610
actually do a proactive protocol for

433
00:16:36,760 --> 00:16:41,920
dynamic groups and dishonest majority

434
00:16:39,610 --> 00:16:43,720
that didn't happen we settle for just

435
00:16:41,920 --> 00:16:47,339
honest majority and proactive but no

436
00:16:43,720 --> 00:16:50,050
dynamic groups yet so we have some some

437
00:16:47,339 --> 00:16:51,279
composition theorems on in the proactive

438
00:16:50,050 --> 00:16:53,859
settings that are formalized at the

439
00:16:51,279 --> 00:16:56,200
abstract level all right this for

440
00:16:53,860 --> 00:16:58,089
instance would be the recover protocol

441
00:16:56,200 --> 00:17:01,029
that I tried briefly to describe earlier

442
00:16:58,089 --> 00:17:02,589
in using just curves for MPC when you

443
00:17:01,029 --> 00:17:05,829
have proactive MPC when you have

444
00:17:02,589 --> 00:17:07,900
basically a party that has been reset

445
00:17:05,829 --> 00:17:11,020
and it's trying to join the MPC again

446
00:17:07,900 --> 00:17:12,790
and it needs to get a the shares how do

447
00:17:11,020 --> 00:17:14,859
you give it the shares what I showed you

448
00:17:12,790 --> 00:17:17,589
before that every party would generate a

449
00:17:14,859 --> 00:17:20,139
random polynomial with 0 at that index

450
00:17:17,589 --> 00:17:21,428
of that chair this this basically is the

451
00:17:20,140 --> 00:17:24,429
protocol how you'd implemented in

452
00:17:21,429 --> 00:17:26,140
easy-grip all right so so far I'm

453
00:17:24,429 --> 00:17:28,540
talking only about abstract definitions

454
00:17:26,140 --> 00:17:31,480
and concrete instantiations then there's

455
00:17:28,540 --> 00:17:33,790
the proof how does a proof in easy crypt

456
00:17:31,480 --> 00:17:35,559
look like well I mean the proof script

457
00:17:33,790 --> 00:17:37,389
will basically be a bunch of definitions

458
00:17:35,559 --> 00:17:38,980
at the beginning you're importing the

459
00:17:37,390 --> 00:17:40,150
modules the abstract definitions you

460
00:17:38,980 --> 00:17:42,160
want to satisfy in the concrete

461
00:17:40,150 --> 00:17:44,080
instantiation x' and then you're

462
00:17:42,160 --> 00:17:45,910
defining the type of the adversary we're

463
00:17:44,080 --> 00:17:47,740
defining here an Oracle because in the

464
00:17:45,910 --> 00:17:49,950
security game you have to allow the

465
00:17:47,740 --> 00:17:51,820
adversary to query the share

466
00:17:49,950 --> 00:17:54,070
functionality with

467
00:17:51,820 --> 00:17:57,580
the secrets that it wants and the game

468
00:17:54,070 --> 00:17:59,379
that you're the security game that you

469
00:17:57,580 --> 00:18:00,760
have is basically similar to how you

470
00:17:59,380 --> 00:18:03,790
would define security of an encryption

471
00:18:00,760 --> 00:18:04,690
scheme is come up with two messages and

472
00:18:03,790 --> 00:18:06,129
then encrypt them and you should

473
00:18:04,690 --> 00:18:08,200
distinguish we're doing the same thing

474
00:18:06,130 --> 00:18:10,240
here for the semi honest model what

475
00:18:08,200 --> 00:18:12,340
secret sharing it just doesn't fit here

476
00:18:10,240 --> 00:18:15,130
so this is how it looked like basically

477
00:18:12,340 --> 00:18:16,780
you generate two secrets or it could be

478
00:18:15,130 --> 00:18:19,810
two lists of Secrets

479
00:18:16,780 --> 00:18:21,910
you have the adversary choose one flip a

480
00:18:19,810 --> 00:18:23,919
bit you send them the shares of one of

481
00:18:21,910 --> 00:18:27,010
them the adversity can then query an

482
00:18:23,920 --> 00:18:29,080
Oracle on sharing on any any secret they

483
00:18:27,010 --> 00:18:32,500
want to get the shares for and at the

484
00:18:29,080 --> 00:18:34,419
end they should have guessed a bit and

485
00:18:32,500 --> 00:18:36,430
you basically in easy crap because you

486
00:18:34,420 --> 00:18:38,830
can compare two probabilistic

487
00:18:36,430 --> 00:18:41,890
distributions you compare if the two

488
00:18:38,830 --> 00:18:43,389
bits are similarly distributed or not I

489
00:18:41,890 --> 00:18:46,210
mean depending on if you want to have a

490
00:18:43,390 --> 00:18:49,060
statistical lis secure or perfect

491
00:18:46,210 --> 00:18:50,740
security or computational you can do all

492
00:18:49,060 --> 00:18:53,590
this in easy crypt so we've done all of

493
00:18:50,740 --> 00:18:55,510
this for this is the list of primitives

494
00:18:53,590 --> 00:18:58,149
and proofs we had so there's like 30

495
00:18:55,510 --> 00:19:00,760
files was was a lot of definitions in

496
00:18:58,150 --> 00:19:03,550
the semi honest and the malicious use

497
00:19:00,760 --> 00:19:06,850
cases alright so as I said this is only

498
00:19:03,550 --> 00:19:09,879
half the story that you basically wrote

499
00:19:06,850 --> 00:19:11,679
the abstract definitions and the

500
00:19:09,880 --> 00:19:13,350
concrete installations an easy crypt and

501
00:19:11,680 --> 00:19:15,790
you wrote the proofs and verified them

502
00:19:13,350 --> 00:19:18,669
the interesting thing is that we found

503
00:19:15,790 --> 00:19:21,310
that the easy craft language is very

504
00:19:18,670 --> 00:19:23,860
similar to yml and I think this is not

505
00:19:21,310 --> 00:19:25,870
an accident I think why am L is a a

506
00:19:23,860 --> 00:19:28,750
framework used for the deductive

507
00:19:25,870 --> 00:19:30,070
verification and I think the easy crap

508
00:19:28,750 --> 00:19:33,250
people when they developed it they were

509
00:19:30,070 --> 00:19:36,159
inspired by or affected by that language

510
00:19:33,250 --> 00:19:38,380
so it turns out that you can actually

511
00:19:36,160 --> 00:19:40,750
easily translate from easy crypt to IML

512
00:19:38,380 --> 00:19:42,550
and then if I know if you've heard about

513
00:19:40,750 --> 00:19:43,930
Oh camel or not before it's a language

514
00:19:42,550 --> 00:19:46,780
that's been around for a while it's very

515
00:19:43,930 --> 00:19:50,110
heavily used in the verification and PL

516
00:19:46,780 --> 00:19:54,100
community and it's really designed for

517
00:19:50,110 --> 00:19:56,139
safety so what we basically did is we

518
00:19:54,100 --> 00:19:57,909
wrote a small tool that translates from

519
00:19:56,140 --> 00:20:01,240
an easy crypt specification of a

520
00:19:57,910 --> 00:20:04,390
protocol to a yml specification of that

521
00:20:01,240 --> 00:20:05,170
protocol and then once you're in yml you

522
00:20:04,390 --> 00:20:07,600
have the all the

523
00:20:05,170 --> 00:20:11,050
power of the y3 framework there's a lot

524
00:20:07,600 --> 00:20:14,110
of tools that can verify yml code and

525
00:20:11,050 --> 00:20:15,970
that can also extract code from yml to

526
00:20:14,110 --> 00:20:19,330
other languages so there's already work

527
00:20:15,970 --> 00:20:21,430
that extracts Oh camel that the tool is

528
00:20:19,330 --> 00:20:24,280
verified like a verify tool that would

529
00:20:21,430 --> 00:20:26,710
translate yml to oh camel and Oh camel

530
00:20:24,280 --> 00:20:28,389
is already executable there's also some

531
00:20:26,710 --> 00:20:31,000
tools online that claim to translate

532
00:20:28,390 --> 00:20:32,230
from yml to see I haven't tried I mean

533
00:20:31,000 --> 00:20:34,330
we tried them but they didn't work

534
00:20:32,230 --> 00:20:36,820
they're also not claimed to be verified

535
00:20:34,330 --> 00:20:38,530
PVS is the proof verification system

536
00:20:36,820 --> 00:20:41,379
which is the interactive the improver of

537
00:20:38,530 --> 00:20:44,050
SRO it's been around for 20 years the

538
00:20:41,380 --> 00:20:45,850
language in PPS is very close to I ml so

539
00:20:44,050 --> 00:20:47,889
you can easily translate from why ml we

540
00:20:45,850 --> 00:20:51,090
haven't done it yet to PVS and my

541
00:20:47,890 --> 00:20:54,370
colleagues have a PVS to see translator

542
00:20:51,090 --> 00:20:56,080
so so i think it's it's very plausible

543
00:20:54,370 --> 00:20:58,330
that in the next year or so somebody can

544
00:20:56,080 --> 00:21:00,520
write a tool that translates from yml to

545
00:20:58,330 --> 00:21:02,199
C and or like we will maybe do it from

546
00:21:00,520 --> 00:21:03,610
PVS and then you can get a C

547
00:21:02,200 --> 00:21:05,500
implementation so now the interesting

548
00:21:03,610 --> 00:21:07,810
thing when we did this oh this is just

549
00:21:05,500 --> 00:21:10,300
showing you how closely similar I mean

550
00:21:07,810 --> 00:21:13,149
like the languages also and the right

551
00:21:10,300 --> 00:21:14,590
here would be the easy crypt I mean part

552
00:21:13,150 --> 00:21:17,080
of these a crypt code for additive

553
00:21:14,590 --> 00:21:19,149
gradual sharing sorry gradual sharing is

554
00:21:17,080 --> 00:21:20,949
basically you take a secret you share it

555
00:21:19,150 --> 00:21:23,290
additively and then take each of the

556
00:21:20,950 --> 00:21:26,110
summons the additive share and share it

557
00:21:23,290 --> 00:21:27,970
using schmear sharing the reason why we

558
00:21:26,110 --> 00:21:30,729
use that is because it's used in some

559
00:21:27,970 --> 00:21:32,560
protocols for mixed adversaries that

560
00:21:30,730 --> 00:21:36,190
basically if you were the talk yesterday

561
00:21:32,560 --> 00:21:38,950
from Dalia you can have these trade offs

562
00:21:36,190 --> 00:21:40,450
between how many passive party how many

563
00:21:38,950 --> 00:21:43,090
parties are corrupt passively and

564
00:21:40,450 --> 00:21:45,100
actively and it's sort of a dial so you

565
00:21:43,090 --> 00:21:47,830
look at the protocols that do this they

566
00:21:45,100 --> 00:21:50,620
use the notion of gradual sharing with a

567
00:21:47,830 --> 00:21:53,169
different polynomial degree of

568
00:21:50,620 --> 00:21:55,300
polynomials for the different shares the

569
00:21:53,170 --> 00:21:57,910
additive shares so on the left this is

570
00:21:55,300 --> 00:21:59,710
the easy crypt code for a gradual

571
00:21:57,910 --> 00:22:01,750
sharing scheme and on the middle that's

572
00:21:59,710 --> 00:22:04,510
the YAML code and on the right the Oh

573
00:22:01,750 --> 00:22:05,980
camel code they're very similar if a

574
00:22:04,510 --> 00:22:08,470
human if you can see sort of a bunch of

575
00:22:05,980 --> 00:22:10,960
variables and then let for instance here

576
00:22:08,470 --> 00:22:13,420
you're defining and yml a function when

577
00:22:10,960 --> 00:22:15,640
you say let very similar to easy crypt

578
00:22:13,420 --> 00:22:18,130
in oh camel it's a little bit different

579
00:22:15,640 --> 00:22:19,150
so I mean basically when I want to show

580
00:22:18,130 --> 00:22:20,860
you that

581
00:22:19,150 --> 00:22:22,840
not for and that's why we have verified

582
00:22:20,860 --> 00:22:26,320
tools to translate from each to the

583
00:22:22,840 --> 00:22:28,330
other so then the question is that code

584
00:22:26,320 --> 00:22:32,260
that you extract which is executable how

585
00:22:28,330 --> 00:22:33,790
bad is the performance so I think it's a

586
00:22:32,260 --> 00:22:35,860
little bit unfair to expect that you

587
00:22:33,790 --> 00:22:37,899
would compare this against sort of an

588
00:22:35,860 --> 00:22:39,610
optimized tool so what we do is we take

589
00:22:37,900 --> 00:22:42,160
charm which is a Python based framework

590
00:22:39,610 --> 00:22:46,110
and we it has its own secret chair in

591
00:22:42,160 --> 00:22:48,430
class so we compare against what's there

592
00:22:46,110 --> 00:22:51,550
for different field sizes different

593
00:22:48,430 --> 00:22:55,000
number of parties and it's not that bad

594
00:22:51,550 --> 00:22:56,379
I mean listen it's this is something

595
00:22:55,000 --> 00:23:00,100
that you get within a minute once you

596
00:22:56,380 --> 00:23:01,660
write things easy crypt people spend

597
00:23:00,100 --> 00:23:04,870
months and years optimizing

598
00:23:01,660 --> 00:23:06,970
implementations so I think it's it's

599
00:23:04,870 --> 00:23:09,969
it's premature to say we expect the same

600
00:23:06,970 --> 00:23:12,070
level of performance but there's nothing

601
00:23:09,970 --> 00:23:13,600
that precludes us from also implementing

602
00:23:12,070 --> 00:23:15,639
a lot of the optimizations that people

603
00:23:13,600 --> 00:23:17,559
do in easy crypt and getting similar

604
00:23:15,640 --> 00:23:19,660
performance so in some of the cases

605
00:23:17,559 --> 00:23:22,270
actually one thing I'm gonna point out

606
00:23:19,660 --> 00:23:25,390
is when you look at charm sharing and

607
00:23:22,270 --> 00:23:27,700
reconstructing and then our extracted

608
00:23:25,390 --> 00:23:30,790
code so it be constructing in charm for

609
00:23:27,700 --> 00:23:32,710
15 parties sorry there's about the

610
00:23:30,790 --> 00:23:36,129
second row and extracted that should be

611
00:23:32,710 --> 00:23:40,059
15 15 party it takes two millisecond to

612
00:23:36,130 --> 00:23:43,420
reconstruct it took us six millisecond

613
00:23:40,059 --> 00:23:45,190
and to share 23 and 1/2 the reason why

614
00:23:43,420 --> 00:23:48,400
we were faster in sharing and not to be

615
00:23:45,190 --> 00:23:50,140
constructing is because we actually

616
00:23:48,400 --> 00:23:52,540
needed to implement an easy crypt a

617
00:23:50,140 --> 00:23:54,850
library for evaluating polynomials and

618
00:23:52,540 --> 00:23:56,920
doing the interpolation and that's what

619
00:23:54,850 --> 00:23:58,600
we're actually synthesizing in Oh camel

620
00:23:56,920 --> 00:24:00,370
and that's what we're using for

621
00:23:58,600 --> 00:24:02,409
interpolate if you take that part out

622
00:24:00,370 --> 00:24:04,989
and let's say replace it by NTL a

623
00:24:02,410 --> 00:24:07,150
sea-based implementation for has a lot

624
00:24:04,990 --> 00:24:09,309
of algorithms that you would need it

625
00:24:07,150 --> 00:24:11,380
would be much faster the point is that

626
00:24:09,309 --> 00:24:13,030
ntl is not verified whereas the Oh camel

627
00:24:11,380 --> 00:24:14,559
code here is is formally verified

628
00:24:13,030 --> 00:24:16,990
because the tool is formally verified

629
00:24:14,559 --> 00:24:18,309
that extracted so so there's area

630
00:24:16,990 --> 00:24:20,890
there's a lot of research to be done

631
00:24:18,309 --> 00:24:23,139
here on optimizing I think there is hope

632
00:24:20,890 --> 00:24:24,850
I mean in the next five years even if

633
00:24:23,140 --> 00:24:28,360
you have I think 20 percent 30 percent

634
00:24:24,850 --> 00:24:29,980
overhead it might be worth it for the

635
00:24:28,360 --> 00:24:32,820
increased confidence you have in the

636
00:24:29,980 --> 00:24:35,350
correctness of the software

637
00:24:32,820 --> 00:24:37,809
anyway what's missing what we haven't

638
00:24:35,350 --> 00:24:40,000
done and yeah we're working on some of

639
00:24:37,809 --> 00:24:41,800
this but please if you're interested in

640
00:24:40,000 --> 00:24:44,860
this area be glad to see people work in

641
00:24:41,800 --> 00:24:47,470
it is adaptive active adversaries you

642
00:24:44,860 --> 00:24:48,879
see verifying the underlying broadcast

643
00:24:47,470 --> 00:24:51,160
protocol for instance nobody has done

644
00:24:48,880 --> 00:24:53,020
this before the underlying

645
00:24:51,160 --> 00:24:54,550
implementations of field groups and all

646
00:24:53,020 --> 00:24:56,190
these things nobody has done a verified

647
00:24:54,550 --> 00:24:58,330
implementation of this as far as I know

648
00:24:56,190 --> 00:25:02,290
recently there's been some project like

649
00:24:58,330 --> 00:25:05,610
project Everest or ever crypt using this

650
00:25:02,290 --> 00:25:09,010
as the underlying parameters for an

651
00:25:05,610 --> 00:25:11,020
extracted NPC code would be would be an

652
00:25:09,010 --> 00:25:14,410
interesting Avenue nobody has done this

653
00:25:11,020 --> 00:25:16,629
before comparing against sort of more

654
00:25:14,410 --> 00:25:20,050
optimized protocols and implementations

655
00:25:16,630 --> 00:25:21,730
I think if you start to look now at

656
00:25:20,050 --> 00:25:24,370
optimizing what we have implemented an

657
00:25:21,730 --> 00:25:25,960
easy crypt you might that would be a

658
00:25:24,370 --> 00:25:28,479
fair comparison but but so far it was

659
00:25:25,960 --> 00:25:28,780
really all the basic stuff just wasn't

660
00:25:28,480 --> 00:25:30,580
there

661
00:25:28,780 --> 00:25:32,080
so it took us a lot of time to implement

662
00:25:30,580 --> 00:25:36,120
the very basic libraries and building

663
00:25:32,080 --> 00:25:38,470
blocks and then translating to see Oh

664
00:25:36,120 --> 00:25:39,879
camels performance is not bad I

665
00:25:38,470 --> 00:25:41,830
personally think I mean you're not gonna

666
00:25:39,880 --> 00:25:43,480
get much more out of C but the memory

667
00:25:41,830 --> 00:25:47,080
footprint of a camel is bad because oh

668
00:25:43,480 --> 00:25:49,360
camel doesn't release memory so it's not

669
00:25:47,080 --> 00:25:54,340
gonna scale at some point so there is

670
00:25:49,360 --> 00:25:55,719
need to also work in C um I think anyway

671
00:25:54,340 --> 00:25:58,350
and obviously the future work is

672
00:25:55,720 --> 00:26:00,370
basically addressing these things and

673
00:25:58,350 --> 00:26:01,990
there are other interactive theorem

674
00:26:00,370 --> 00:26:03,790
provers other than easy crypt easy crypt

675
00:26:01,990 --> 00:26:06,130
is really focused for cryptography so

676
00:26:03,790 --> 00:26:08,530
like things like Isabel and PVS if

677
00:26:06,130 --> 00:26:10,750
you now want to start also reasoning

678
00:26:08,530 --> 00:26:12,250
about like this MPC software it's gonna

679
00:26:10,750 --> 00:26:16,929
be sitting either in a virtual machine

680
00:26:12,250 --> 00:26:18,309
or like container or something like that

681
00:26:16,929 --> 00:26:20,170
I mean if you people are starting to

682
00:26:18,309 --> 00:26:20,530
talk about not starting it's been around

683
00:26:20,170 --> 00:26:22,600
for a while

684
00:26:20,530 --> 00:26:24,820
verified microkernel if you've ever

685
00:26:22,600 --> 00:26:26,620
heard of SEL for I mean ultimately what

686
00:26:24,820 --> 00:26:29,620
you want to verify everything end-to-end

687
00:26:26,620 --> 00:26:32,439
then so SEL for instance is verified in

688
00:26:29,620 --> 00:26:33,969
Isabel if you want to verify the

689
00:26:32,440 --> 00:26:35,890
composition of both of those two things

690
00:26:33,970 --> 00:26:37,870
you need to do the work we've done like

691
00:26:35,890 --> 00:26:39,910
an easy crypt in Isabel and it's in

692
00:26:37,870 --> 00:26:42,159
principle doable it's it's just X was

693
00:26:39,910 --> 00:26:44,110
gonna take a lot of effort which is good

694
00:26:42,160 --> 00:26:47,169
I mean there's a lot of research

695
00:26:44,110 --> 00:26:49,029
to be done anyway whenever I talk to

696
00:26:47,169 --> 00:26:51,730
people about this kind of work and this

697
00:26:49,029 --> 00:26:54,909
sort of approach these are the questions

698
00:26:51,730 --> 00:26:55,690
I or objections I often get and I just

699
00:26:54,909 --> 00:26:57,519
want to put it out there because

700
00:26:55,690 --> 00:26:59,590
honestly I don't think these are valid

701
00:26:57,519 --> 00:27:01,059
objections it's like oh what if your

702
00:26:59,590 --> 00:27:02,709
security definition or abstract

703
00:27:01,059 --> 00:27:04,809
definition of implementation is wrong I

704
00:27:02,710 --> 00:27:07,120
mean you have the same issue as papers

705
00:27:04,809 --> 00:27:09,100
there's nothing different yeah I just

706
00:27:07,120 --> 00:27:13,479
took it and implemented it just a little

707
00:27:09,100 --> 00:27:15,250
bit more rigorous formalism what if the

708
00:27:13,480 --> 00:27:17,440
computer checked proof has a problem

709
00:27:15,250 --> 00:27:19,570
it's exactly the same as you have it in

710
00:27:17,440 --> 00:27:21,220
a paper you can always if you find the

711
00:27:19,570 --> 00:27:23,710
bug if it's nothing fundamental you can

712
00:27:21,220 --> 00:27:26,289
fix it and within a couple of minutes of

713
00:27:23,710 --> 00:27:29,440
worst case hours you verify the whole

714
00:27:26,289 --> 00:27:31,179
pipeline what if there's a bug in the

715
00:27:29,440 --> 00:27:33,360
verification or synthesis tool chain

716
00:27:31,179 --> 00:27:37,389
easy crypt an easy crypt is a big

717
00:27:33,360 --> 00:27:39,699
computer trust a computer based at your

718
00:27:37,389 --> 00:27:42,370
trusted code base that you're trusting

719
00:27:39,700 --> 00:27:44,049
fair enough but easy crypt has been

720
00:27:42,370 --> 00:27:45,729
around for 10 years a lot of people are

721
00:27:44,049 --> 00:27:47,740
using it eventually I think bugs will be

722
00:27:45,730 --> 00:27:50,470
discovered and if you really want to go

723
00:27:47,740 --> 00:27:52,210
there you can the same way you in a

724
00:27:50,470 --> 00:27:54,070
programming language when you design a

725
00:27:52,210 --> 00:27:56,320
programming language or the first ones

726
00:27:54,070 --> 00:27:59,289
you bootstrap a compiler you can do the

727
00:27:56,320 --> 00:28:01,360
same thing like I can imagine a verified

728
00:27:59,289 --> 00:28:03,940
interactive theorem provers like easy

729
00:28:01,360 --> 00:28:05,860
crypt that is you start with a very

730
00:28:03,940 --> 00:28:07,330
small kernel that you have enough

731
00:28:05,860 --> 00:28:09,039
confidence in it manually and you

732
00:28:07,330 --> 00:28:13,178
bootstrap things and that's how people

733
00:28:09,039 --> 00:28:14,620
did things was compilers and what if the

734
00:28:13,179 --> 00:28:16,659
use tool I've had that discussion

735
00:28:14,620 --> 00:28:18,459
actually I just added this today because

736
00:28:16,659 --> 00:28:20,289
I hadn't a discussion in the morning

737
00:28:18,460 --> 00:28:21,760
what if I spend if I'm a student I spent

738
00:28:20,289 --> 00:28:23,620
six months nine months learning easy

739
00:28:21,760 --> 00:28:26,260
crypt and that goes away after two years

740
00:28:23,620 --> 00:28:28,989
I mean first of all I am not involved at

741
00:28:26,260 --> 00:28:31,210
all in easy crypt I am NOT I have zero

742
00:28:28,990 --> 00:28:33,159
interest in easier but I think they did

743
00:28:31,210 --> 00:28:35,110
a great job and it has matured a lot

744
00:28:33,159 --> 00:28:37,360
over the last 10 years I think anybody

745
00:28:35,110 --> 00:28:39,939
if you told anybody ten years ago I'm

746
00:28:37,360 --> 00:28:43,299
going to verify something like bgw for

747
00:28:39,940 --> 00:28:44,860
active adversaries with a computer they

748
00:28:43,299 --> 00:28:49,029
probably would have dismissed it we've

749
00:28:44,860 --> 00:28:51,610
done it ok there's no reason not to take

750
00:28:49,029 --> 00:28:53,080
this approach moving forward because as

751
00:28:51,610 --> 00:28:56,080
things get more complicated and more

752
00:28:53,080 --> 00:28:58,360
automated we need we need that level of

753
00:28:56,080 --> 00:29:02,350
rigor it takes time yes but it's

754
00:28:58,360 --> 00:29:04,419
and also if in my experience same thing

755
00:29:02,350 --> 00:29:06,280
was programming languages the first one

756
00:29:04,420 --> 00:29:07,660
you learn will take you longer but then

757
00:29:06,280 --> 00:29:08,920
once you've learned it the second and

758
00:29:07,660 --> 00:29:10,720
the third one will be much much quicker

759
00:29:08,920 --> 00:29:14,050
if you learn one of these theorem

760
00:29:10,720 --> 00:29:18,250
provers and sort of use it as an extra

761
00:29:14,050 --> 00:29:19,360
verification step in your work if for

762
00:29:18,250 --> 00:29:21,550
some reason you need to switch to

763
00:29:19,360 --> 00:29:23,620
another one it's not gonna be that much

764
00:29:21,550 --> 00:29:25,600
time to learn and pick up the other one

765
00:29:23,620 --> 00:29:28,929
and if you're a student that's starting

766
00:29:25,600 --> 00:29:30,639
and expecting to have a 30 40 year

767
00:29:28,930 --> 00:29:32,380
career in design in cross the

768
00:29:30,640 --> 00:29:35,830
cryptographer I think it's worth it

769
00:29:32,380 --> 00:29:37,390
because you might not use it on every

770
00:29:35,830 --> 00:29:40,360
paper but every once in a while you need

771
00:29:37,390 --> 00:29:41,800
that anyway I'll leave you hopefully

772
00:29:40,360 --> 00:29:43,689
with these conclusions that one

773
00:29:41,800 --> 00:29:46,060
computer-aided verification and

774
00:29:43,690 --> 00:29:47,950
automated verified synthesis of software

775
00:29:46,060 --> 00:29:52,629
for cryptographic protocols complex ones

776
00:29:47,950 --> 00:29:53,350
is achievable today and I think they go

777
00:29:52,630 --> 00:29:54,850
hand-in-hand

778
00:29:53,350 --> 00:29:57,550
I mean verification by itself is

779
00:29:54,850 --> 00:29:59,320
important but if you've done 85% of the

780
00:29:57,550 --> 00:30:02,379
work why don't you just do that X report

781
00:29:59,320 --> 00:30:05,260
and it's reasonably low performance now

782
00:30:02,380 --> 00:30:07,450
- given that it's automatically

783
00:30:05,260 --> 00:30:09,490
synthesized code and that is you have a

784
00:30:07,450 --> 00:30:11,200
much higher degree of confidence in its

785
00:30:09,490 --> 00:30:14,440
correctness and there's a lot more

786
00:30:11,200 --> 00:30:17,050
research to be done and yeah was that

787
00:30:14,440 --> 00:30:19,300
I'm happy to take any questions I hope I

788
00:30:17,050 --> 00:30:22,110
hope that this is something I expose you

789
00:30:19,300 --> 00:30:22,110
to something new today

790
00:30:25,320 --> 00:30:32,908
a couple quick things I might have

791
00:30:30,509 --> 00:30:35,940
misunderstood but I think maybe on slide

792
00:30:32,909 --> 00:30:40,980
1450 it's something about um there's no

793
00:30:35,940 --> 00:30:42,870
formally verified fuel implementations I

794
00:30:40,980 --> 00:30:44,509
didn't say I said we didn't use whoa I

795
00:30:42,870 --> 00:30:48,178
see I see

796
00:30:44,509 --> 00:30:51,600
because certainly there's a bunch in our

797
00:30:48,179 --> 00:30:52,980
work no no okay I know there is just no

798
00:30:51,600 --> 00:30:55,678
I was just trying to focus yeah the

799
00:30:52,980 --> 00:30:58,110
actual question I have is this in a lot

800
00:30:55,679 --> 00:31:00,330
of these it seems like I've been

801
00:30:58,110 --> 00:31:03,508
following this work and related work

802
00:31:00,330 --> 00:31:05,639
because it's extremely interesting um it

803
00:31:03,509 --> 00:31:07,440
seems like there's on the one hand

804
00:31:05,639 --> 00:31:09,600
getting correct by construction software

805
00:31:07,440 --> 00:31:12,029
is excellent on the other hand one of

806
00:31:09,600 --> 00:31:14,189
the reasons when we implement something

807
00:31:12,029 --> 00:31:16,169
in C for example one of the reasons that

808
00:31:14,190 --> 00:31:18,720
we do that is not just because we want

809
00:31:16,169 --> 00:31:21,629
it to be fast but because in some sense

810
00:31:18,720 --> 00:31:23,549
like maybe the compiler gets out of the

811
00:31:21,629 --> 00:31:25,080
way a little more than the old camel

812
00:31:23,549 --> 00:31:26,279
compiler does which I mean kind of

813
00:31:25,080 --> 00:31:27,689
sounds like a joke because of course you

814
00:31:26,279 --> 00:31:31,399
always fight the C compiler when you try

815
00:31:27,690 --> 00:31:33,570
to write code in it but specifically

816
00:31:31,399 --> 00:31:35,879
look if I'm trying to write constant

817
00:31:33,570 --> 00:31:37,200
time code I have basically no prayer as

818
00:31:35,879 --> 00:31:39,480
far as I can tell of doing that in oh

819
00:31:37,200 --> 00:31:40,500
camel I could probably get that done or

820
00:31:39,480 --> 00:31:41,909
at least you know if I know what

821
00:31:40,500 --> 00:31:43,740
compiler I'm targeting I could probably

822
00:31:41,909 --> 00:31:45,330
get that done at C so it seems like

823
00:31:43,740 --> 00:31:47,580
maybe there's a little gap right between

824
00:31:45,330 --> 00:31:49,110
on the one hand correct software but

825
00:31:47,580 --> 00:31:51,570
it's a little camel and on the other

826
00:31:49,110 --> 00:31:54,178
hand what I maybe want is really like

827
00:31:51,570 --> 00:31:57,059
software in C that's constant time and

828
00:31:54,179 --> 00:32:00,389
maybe I can examine the you know in the

829
00:31:57,059 --> 00:32:02,759
IR or the assembly afterwards how do you

830
00:32:00,389 --> 00:32:03,750
see how will we close that gap fair

831
00:32:02,759 --> 00:32:06,230
enough are you worried because of

832
00:32:03,750 --> 00:32:11,610
leakage resilience and in constant time

833
00:32:06,230 --> 00:32:13,169
for example yes I think if you want to

834
00:32:11,610 --> 00:32:14,399
do that I don't think easy crypt in its

835
00:32:13,169 --> 00:32:15,750
current format has to do that I think

836
00:32:14,399 --> 00:32:18,239
you would need to move to something like

837
00:32:15,750 --> 00:32:22,529
 or Isabel and I'm not very familiar

838
00:32:18,240 --> 00:32:24,149
with that that area of research some of

839
00:32:22,529 --> 00:32:25,980
my colleagues actually have been working

840
00:32:24,149 --> 00:32:29,219
on sort of these constant time

841
00:32:25,980 --> 00:32:30,779
implementations I don't have an aunt I

842
00:32:29,220 --> 00:32:32,940
haven't looked at it I don't think there

843
00:32:30,779 --> 00:32:35,159
is we require a lot of work it would

844
00:32:32,940 --> 00:32:37,500
require probably like I can't imagine it

845
00:32:35,159 --> 00:32:38,970
as I said if you move to PVS which is

846
00:32:37,500 --> 00:32:41,820
very close to yml you can

847
00:32:38,970 --> 00:32:43,559
extract sea from it and PVS is based on

848
00:32:41,820 --> 00:32:45,418
hire or law it's very generic you can

849
00:32:43,559 --> 00:32:48,049
start reasoning about these constant

850
00:32:45,419 --> 00:32:50,789
time it's just nobody has done it yet

851
00:32:48,049 --> 00:32:52,440
okay thank you I'll tell you what we did

852
00:32:50,789 --> 00:32:54,179
honestly we did oke ammo because at some

853
00:32:52,440 --> 00:32:56,190
point it was just two of us it's a lot

854
00:32:54,179 --> 00:32:57,630
of work and this is this is excellent

855
00:32:56,190 --> 00:32:58,919
it's it's great it's just like of course

856
00:32:57,630 --> 00:33:00,720
as you said there's there's tons more

857
00:32:58,919 --> 00:33:01,799
work to do and I'm worried about one

858
00:33:00,720 --> 00:33:03,780
thing I'm sure everyone else is right

859
00:33:01,799 --> 00:33:05,760
about you know ten other things but yeah

860
00:33:03,780 --> 00:33:08,059
so this is a good answer I really

861
00:33:05,760 --> 00:33:10,620
appreciate it thank you thank you it's

862
00:33:08,059 --> 00:33:12,240
more common on the question dust now so

863
00:33:10,620 --> 00:33:13,939
I mean you mentioned ever Crypt I mean

864
00:33:12,240 --> 00:33:16,020
one of their motivations is to get

865
00:33:13,940 --> 00:33:18,510
software down all the way down

866
00:33:16,020 --> 00:33:20,730
has it even have one very fine the

867
00:33:18,510 --> 00:33:22,020
Assembly level so there is other works

868
00:33:20,730 --> 00:33:24,900
in high assurance cryptographic

869
00:33:22,020 --> 00:33:27,299
engineering so it just has to interface

870
00:33:24,900 --> 00:33:29,159
somehow question to you you might need a

871
00:33:27,299 --> 00:33:31,860
whole bunch of shinier things and I see

872
00:33:29,159 --> 00:33:35,340
like sharing and we sharing and well

873
00:33:31,860 --> 00:33:36,870
reconstruction but it's your protocol

874
00:33:35,340 --> 00:33:38,340
taking into account that you don't

875
00:33:36,870 --> 00:33:39,239
actually have to reconstruct it I mean

876
00:33:38,340 --> 00:33:42,418
do you have for instance the

877
00:33:39,240 --> 00:33:44,370
diffie-hellman where you never recon we

878
00:33:42,419 --> 00:33:49,409
construct the share but you just apply

879
00:33:44,370 --> 00:33:51,239
it using the shares I'm sorry so I mean

880
00:33:49,409 --> 00:33:52,860
like when you when you do secret sharing

881
00:33:51,240 --> 00:33:55,380
and you want to run different allman

882
00:33:52,860 --> 00:33:57,418
okay you don't have to recover the

883
00:33:55,380 --> 00:33:59,460
secret we can just apply the dish

884
00:33:57,419 --> 00:34:01,169
yeah we're recovering is I mean you it's

885
00:33:59,460 --> 00:34:03,929
up to you when you want to recover

886
00:34:01,169 --> 00:34:06,270
I mean we're composing these I mean you

887
00:34:03,929 --> 00:34:08,550
can just share and just open are you

888
00:34:06,270 --> 00:34:12,780
asking I mean but I mean do you have the

889
00:34:08,550 --> 00:34:14,820
functionality do diffie-hellman without

890
00:34:12,780 --> 00:34:16,169
ever reconstructing we don't we haven't

891
00:34:14,820 --> 00:34:17,460
implemented anything in the fam I think

892
00:34:16,168 --> 00:34:19,080
other people implemented the fear

893
00:34:17,460 --> 00:34:20,429
because I mean that's that's what would

894
00:34:19,080 --> 00:34:22,560
really interest me because I mean once

895
00:34:20,429 --> 00:34:26,220
you have recovered the share it's gone I

896
00:34:22,560 --> 00:34:28,469
mean if if you're malicious member gets

897
00:34:26,219 --> 00:34:30,118
the the combined share or you assume

898
00:34:28,469 --> 00:34:32,199
that the combination takes place

899
00:34:30,119 --> 00:34:36,760
somewhere else

900
00:34:32,199 --> 00:34:38,679
I mean India model are you assume we're

901
00:34:36,760 --> 00:34:40,420
we're doing NPCs overtake everyone would

902
00:34:38,679 --> 00:34:42,040
be would share their inputs and your

903
00:34:40,420 --> 00:34:44,110
computing a circuit as additions or

904
00:34:42,040 --> 00:34:46,029
multiplications you can leave the the

905
00:34:44,110 --> 00:34:49,180
result chip secret shared without

906
00:34:46,030 --> 00:34:51,370
reconstructing so you can leave it

907
00:34:49,179 --> 00:34:52,839
without reconstruct I mean so when you

908
00:34:51,370 --> 00:34:54,400
say we construct you reconstructing the

909
00:34:52,840 --> 00:34:55,750
result of the computation yeah you're

910
00:34:54,400 --> 00:34:58,480
not saying you've reconstructing the

911
00:34:55,750 --> 00:35:01,740
Shamy see no no no sorry yes we can

912
00:34:58,480 --> 00:35:01,740
suppose might result of the computation

913
00:35:08,620 --> 00:35:13,549
[Applause]

