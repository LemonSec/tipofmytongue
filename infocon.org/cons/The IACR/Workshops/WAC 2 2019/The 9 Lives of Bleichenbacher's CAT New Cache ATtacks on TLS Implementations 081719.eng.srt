1
00:00:04,860 --> 00:00:12,450
Thank You production so this is joint

2
00:00:09,330 --> 00:00:15,780
work together with Abbott Gilliam David

3
00:00:12,450 --> 00:00:18,029
Wong and additional and then in getting

4
00:00:15,780 --> 00:00:20,689
a new value home which are supposed to

5
00:00:18,029 --> 00:00:25,800
be here at least and they'll give a talk

6
00:00:20,689 --> 00:00:28,198
if you in about 15 minutes and that

7
00:00:25,800 --> 00:00:30,470
they'll very long and elaborate title is

8
00:00:28,199 --> 00:00:34,230
the nine lives of Lacan bajas Katz and

9
00:00:30,470 --> 00:00:37,080
it's a new cash attack em against TLS

10
00:00:34,230 --> 00:00:41,459
implementations using a very very all

11
00:00:37,080 --> 00:00:44,729
this we already have today and pending

12
00:00:41,460 --> 00:00:46,830
oral health ok so what we're going to

13
00:00:44,729 --> 00:00:50,250
talk about is a little bit of background

14
00:00:46,830 --> 00:00:54,720
how we can attack TLS in do damn good

15
00:00:50,250 --> 00:00:57,830
attack a new weight method that we have

16
00:00:54,720 --> 00:01:02,070
to paralyze and the original back in the

17
00:00:57,830 --> 00:01:04,140
attack and then talk a little bit about

18
00:01:02,070 --> 00:01:06,740
how we actually what were the

19
00:01:04,140 --> 00:01:12,150
vulnerabilities for the cash attacks and

20
00:01:06,740 --> 00:01:14,399
hopefully some conclusion in the end so

21
00:01:12,150 --> 00:01:16,980
I don't feel that we really need to

22
00:01:14,400 --> 00:01:19,110
introduce TLS in this session but I'll

23
00:01:16,980 --> 00:01:21,210
still do it it's probably the most

24
00:01:19,110 --> 00:01:23,190
widely used cryptographic protocol in

25
00:01:21,210 --> 00:01:25,649
the world it provides communication

26
00:01:23,190 --> 00:01:28,950
security for many purposes maybe the

27
00:01:25,650 --> 00:01:31,920
most used one is for HTTP communication

28
00:01:28,950 --> 00:01:35,010
on the internet and it has could say two

29
00:01:31,920 --> 00:01:36,810
main parts the TLS handshake which is

30
00:01:35,010 --> 00:01:39,780
used to authenticate the different

31
00:01:36,810 --> 00:01:41,790
parties and to do a secure key exchange

32
00:01:39,780 --> 00:01:44,790
and the TSA holder that actually

33
00:01:41,790 --> 00:01:47,370
encrypts them and the data and it

34
00:01:44,790 --> 00:01:49,590
supports cryptographic agility I'm using

35
00:01:47,370 --> 00:01:53,820
the different cipher suites which

36
00:01:49,590 --> 00:01:55,680
basically says that and if we learn over

37
00:01:53,820 --> 00:01:57,869
the years that some kind of cipher suite

38
00:01:55,680 --> 00:02:00,500
that were using is vulnerable then we

39
00:01:57,870 --> 00:02:02,340
can just duplicate stop using it and

40
00:02:00,500 --> 00:02:05,490
move to new ones

41
00:02:02,340 --> 00:02:08,459
and as we already seen today and we'll

42
00:02:05,490 --> 00:02:12,030
see here and in theory it might work in

43
00:02:08,459 --> 00:02:15,630
practice and till he doesn't work and

44
00:02:12,030 --> 00:02:18,140
cryptographic agility and also and help

45
00:02:15,630 --> 00:02:21,200
us many by

46
00:02:18,140 --> 00:02:23,779
the support forever every possible

47
00:02:21,200 --> 00:02:27,530
vulnerable surface witted has ever been

48
00:02:23,780 --> 00:02:29,540
invented so this is basically the layers

49
00:02:27,530 --> 00:02:32,210
of TLS and we're going to talk about the

50
00:02:29,540 --> 00:02:33,620
handshake protocol which is circled and

51
00:02:32,210 --> 00:02:36,920
we're going to talk specifically about

52
00:02:33,620 --> 00:02:40,850
RSA key exchange in TLS and so Alice a

53
00:02:36,920 --> 00:02:43,070
key change uses the infamous pkcs number

54
00:02:40,850 --> 00:02:44,810
one version 1.5 padding scheme that

55
00:02:43,070 --> 00:02:45,950
we're going to hear a lot about it in

56
00:02:44,810 --> 00:02:48,620
the rest of the talk

57
00:02:45,950 --> 00:02:51,230
it was once maybe the most popular TLS

58
00:02:48,620 --> 00:02:53,810
big change option that was used almost

59
00:02:51,230 --> 00:02:56,540
by one other percent of them of the

60
00:02:53,810 --> 00:02:59,540
terrace connection however it has a very

61
00:02:56,540 --> 00:03:01,370
very very long history of particle

62
00:02:59,540 --> 00:03:03,760
implemented text and history were

63
00:03:01,370 --> 00:03:09,290
talking about a paper that was published

64
00:03:03,760 --> 00:03:12,530
last week the latest one and I and I

65
00:03:09,290 --> 00:03:15,890
feel that this this system is going to

66
00:03:12,530 --> 00:03:17,570
continue to the future and but we

67
00:03:15,890 --> 00:03:19,399
already feel that there's a large

68
00:03:17,570 --> 00:03:23,239
consensus that our stake here change is

69
00:03:19,400 --> 00:03:25,130
a bad thing and in part of the whole of

70
00:03:23,239 --> 00:03:27,320
the implementation text also doesn't

71
00:03:25,130 --> 00:03:32,540
support force for secrecy which is also

72
00:03:27,320 --> 00:03:33,980
a main issue but still and maybe the

73
00:03:32,540 --> 00:03:37,609
last time I checked it was in the end of

74
00:03:33,980 --> 00:03:40,070
2019 it's still widely used about 6% of

75
00:03:37,610 --> 00:03:46,070
the connections on the internet still

76
00:03:40,070 --> 00:03:48,109
use RSA key exchange and there are much

77
00:03:46,070 --> 00:03:50,590
better alternatives that we can use that

78
00:03:48,110 --> 00:03:52,970
now but it's still supported for and

79
00:03:50,590 --> 00:03:55,880
maybe the most dangerous pin in

80
00:03:52,970 --> 00:03:56,600
cryptography which is backward

81
00:03:55,880 --> 00:03:58,640
compatibility

82
00:03:56,600 --> 00:04:00,680
we still need to support those old

83
00:03:58,640 --> 00:04:04,488
machines that doesn't know how to use

84
00:04:00,680 --> 00:04:06,530
anything else and this will see puts the

85
00:04:04,489 --> 00:04:08,870
whole ecosystem of the internet in in

86
00:04:06,530 --> 00:04:12,350
risk okay

87
00:04:08,870 --> 00:04:12,799
so large overview what we did in the

88
00:04:12,350 --> 00:04:15,440
paper

89
00:04:12,799 --> 00:04:19,010
we tested nine different implementations

90
00:04:15,440 --> 00:04:23,510
for vulnerability to cache attacks and

91
00:04:19,010 --> 00:04:26,390
on RSA padding's and out of those nine

92
00:04:23,510 --> 00:04:28,880
level two and Boeing SSL and SSL which

93
00:04:26,390 --> 00:04:31,430
were secure we would we couldn't manage

94
00:04:28,880 --> 00:04:33,740
and to find any vulnerabilities and

95
00:04:31,430 --> 00:04:36,170
the rest had multiple types of

96
00:04:33,740 --> 00:04:39,200
vulnerabilities and we'll talk a bit

97
00:04:36,170 --> 00:04:44,510
about the different different types and

98
00:04:39,200 --> 00:04:46,039
later on okay so for now we believe me

99
00:04:44,510 --> 00:04:48,320
that we're able to do those cache

100
00:04:46,040 --> 00:04:50,660
attacks and then we flame okay we book

101
00:04:48,320 --> 00:04:54,050
6% of the internet and then you could

102
00:04:50,660 --> 00:04:56,330
say okay maybe you're in the other 94%

103
00:04:54,050 --> 00:04:59,240
so why do you care about this paper and

104
00:04:56,330 --> 00:05:00,950
the main field that we want to do claim

105
00:04:59,240 --> 00:05:02,090
is that we show that it might be

106
00:05:00,950 --> 00:05:05,659
feasible to do a man-in-the-middle

107
00:05:02,090 --> 00:05:08,330
downgrade attack and then using our

108
00:05:05,660 --> 00:05:10,520
parallelization technique for for this

109
00:05:08,330 --> 00:05:12,280
attack and assuming that we can do this

110
00:05:10,520 --> 00:05:15,560
cache attack against multiple servers

111
00:05:12,280 --> 00:05:17,929
for example large companies and Facebook

112
00:05:15,560 --> 00:05:19,700
Amazon whatever has multiple servers to

113
00:05:17,930 --> 00:05:22,730
support a lot you can do it if you can

114
00:05:19,700 --> 00:05:27,740
attack them in parallel then we can do

115
00:05:22,730 --> 00:05:30,080
an attack we use a beast attack to boost

116
00:05:27,740 --> 00:05:32,570
the success probability and then we

117
00:05:30,080 --> 00:05:35,349
claim that we are able to break 100

118
00:05:32,570 --> 00:05:40,340
percent of the connections that use this

119
00:05:35,350 --> 00:05:44,750
vulnerable implementation ok so we try

120
00:05:40,340 --> 00:05:47,719
to explain what we what we did here so

121
00:05:44,750 --> 00:05:50,980
this is alice encryption assume most of

122
00:05:47,720 --> 00:05:52,460
you and have seen it before and this is

123
00:05:50,980 --> 00:05:55,310
nice man

124
00:05:52,460 --> 00:05:58,099
we have prime numbers with our say

125
00:05:55,310 --> 00:06:01,370
modulus we have secret keys and we can

126
00:05:58,100 --> 00:06:03,320
do encryption with that and but the

127
00:06:01,370 --> 00:06:05,390
question is how we can use this nice

128
00:06:03,320 --> 00:06:08,870
match to actually encrypt real-world

129
00:06:05,390 --> 00:06:10,280
data and there are several well promised

130
00:06:08,870 --> 00:06:13,760
that we need to overcome in order to

131
00:06:10,280 --> 00:06:16,039
really use this and so we'll give few

132
00:06:13,760 --> 00:06:19,340
example the first one let's assume we

133
00:06:16,040 --> 00:06:22,820
use a small public exponent 3 it was

134
00:06:19,340 --> 00:06:25,489
something that was actually used and we

135
00:06:22,820 --> 00:06:27,200
want to encrypt the number 1000 and we

136
00:06:25,490 --> 00:06:33,170
want to be secure and today the standard

137
00:06:27,200 --> 00:06:37,640
is Safina 1 200 2048 bit RSA keys so we

138
00:06:33,170 --> 00:06:41,390
have generated a very secure Alice a

139
00:06:37,640 --> 00:06:45,229
model ok and so what we have this

140
00:06:41,390 --> 00:06:47,539
problem well if we take 1000 Reza to the

141
00:06:45,230 --> 00:06:50,530
verse three and we're still much smaller

142
00:06:47,540 --> 00:06:53,780
than the modulus and actually to

143
00:06:50,530 --> 00:06:54,890
calculate the log of this value of the

144
00:06:53,780 --> 00:06:57,440
really something that's not very

145
00:06:54,890 --> 00:06:59,270
complicated and so we need to make sure

146
00:06:57,440 --> 00:07:02,150
that M is the number that we encrypt is

147
00:06:59,270 --> 00:07:04,930
large enough so it will be so it will

148
00:07:02,150 --> 00:07:08,270
actually go over the value of the models

149
00:07:04,930 --> 00:07:11,630
okay now another problem let's say I

150
00:07:08,270 --> 00:07:13,190
want to to encrypt the information for

151
00:07:11,630 --> 00:07:15,590
my application and by implication can

152
00:07:13,190 --> 00:07:18,980
answer yes or no to a specific question

153
00:07:15,590 --> 00:07:22,159
so the encrypt the value of zero or one

154
00:07:18,980 --> 00:07:24,740
so this is vulnerable to dictionary

155
00:07:22,160 --> 00:07:26,870
attack it basically means if I encrypt

156
00:07:24,740 --> 00:07:28,610
the values even multiple times you can

157
00:07:26,870 --> 00:07:32,570
see that it's the same value each time

158
00:07:28,610 --> 00:07:34,520
and it's easy to detect repetitions so

159
00:07:32,570 --> 00:07:36,590
in order for scheme to be secure we need

160
00:07:34,520 --> 00:07:37,450
the value and between encrypt to also be

161
00:07:36,590 --> 00:07:41,330
random

162
00:07:37,450 --> 00:07:43,820
okay so here's pkcs number one vision

163
00:07:41,330 --> 00:07:46,460
one point five to the rescue and what

164
00:07:43,820 --> 00:07:48,530
does this basic you uses a padding

165
00:07:46,460 --> 00:07:50,930
scheme to read and then encrypt the

166
00:07:48,530 --> 00:07:53,599
plaintext and what it does it basically

167
00:07:50,930 --> 00:07:55,070
pets the plaintext to the RSA key link

168
00:07:53,600 --> 00:07:57,490
to make sure that the number is big

169
00:07:55,070 --> 00:07:59,930
enough and it adds the randomization

170
00:07:57,490 --> 00:08:03,860
okay so this is the example of what is

171
00:07:59,930 --> 00:08:06,920
done in TLS 1.2 basically we start with

172
00:08:03,860 --> 00:08:07,400
an encryption preamble it's two bytes 0

173
00:08:06,920 --> 00:08:10,910
and 2

174
00:08:07,400 --> 00:08:14,390
but States this is this is an encryption

175
00:08:10,910 --> 00:08:15,920
process then we have eight random non

176
00:08:14,390 --> 00:08:18,320
zero bytes this make sure that the

177
00:08:15,920 --> 00:08:21,350
number is random and also the number is

178
00:08:18,320 --> 00:08:23,540
large enough where delimiter zero

179
00:08:21,350 --> 00:08:25,280
delimiter because in the general scheme

180
00:08:23,540 --> 00:08:27,680
we don't know what is the actual size of

181
00:08:25,280 --> 00:08:29,150
the plaintext that we want to encrypt or

182
00:08:27,680 --> 00:08:32,659
don't tell us we do know it

183
00:08:29,150 --> 00:08:35,990
and until s were 48 bytes of the actual

184
00:08:32,659 --> 00:08:40,089
premaster secret that is generated by

185
00:08:35,990 --> 00:08:47,090
the client and sent to the server okay

186
00:08:40,090 --> 00:08:50,360
so we have nowhere what's called

187
00:08:47,090 --> 00:08:53,210
blessing battles attack and it's a very

188
00:08:50,360 --> 00:08:56,000
old attack from 1998 and it's inductive

189
00:08:53,210 --> 00:08:58,520
adaptive chosen ciphertext and what it

190
00:08:56,000 --> 00:09:02,410
does it exploits the strict manner in

191
00:08:58,520 --> 00:09:05,500
which is a Pegasus padding is done and

192
00:09:02,410 --> 00:09:08,839
actually what we have is we have this

193
00:09:05,500 --> 00:09:11,840
innocent client sends this ciphertext to

194
00:09:08,840 --> 00:09:14,810
the server and we have the malicious

195
00:09:11,840 --> 00:09:17,150
attacker it listens to the to the

196
00:09:14,810 --> 00:09:20,060
ciphertext and then he uses the same

197
00:09:17,150 --> 00:09:24,290
server as an Oracle and basically what

198
00:09:20,060 --> 00:09:26,500
it does is since then he changed the

199
00:09:24,290 --> 00:09:29,300
ciphertext he sent a malleable multi

200
00:09:26,500 --> 00:09:32,810
version of the ciphertext to the server

201
00:09:29,300 --> 00:09:34,939
and then we checks with the server does

202
00:09:32,810 --> 00:09:37,160
this the plaintiffs that corresponds to

203
00:09:34,940 --> 00:09:40,160
this ciphertext does it start with zero

204
00:09:37,160 --> 00:09:42,140
- or not and with this response you can

205
00:09:40,160 --> 00:09:44,630
continue the attack this is an adaptive

206
00:09:42,140 --> 00:09:47,810
attack and in the NDK is able to decrypt

207
00:09:44,630 --> 00:09:52,010
it and there is also a very similar

208
00:09:47,810 --> 00:09:53,839
attack that's from 2001 by manga which

209
00:09:52,010 --> 00:09:56,720
is aimed at another pattern another

210
00:09:53,840 --> 00:09:59,120
neural padding scheme by the way want to

211
00:09:56,720 --> 00:10:04,100
take care thank people in the audience

212
00:09:59,120 --> 00:10:07,520
still for this wonderful slide ok so we

213
00:10:04,100 --> 00:10:10,190
have this amazing block attack and we're

214
00:10:07,520 --> 00:10:12,290
not going to go to all of the details of

215
00:10:10,190 --> 00:10:14,240
the material although this is really a

216
00:10:12,290 --> 00:10:17,930
beautiful paper in my opinion I

217
00:10:14,240 --> 00:10:19,640
recommend people to edit and it was it

218
00:10:17,930 --> 00:10:21,949
was used to be called the million

219
00:10:19,640 --> 00:10:24,439
message attacks because you need about a

220
00:10:21,950 --> 00:10:25,850
million messages that million five is to

221
00:10:24,440 --> 00:10:27,800
to several in order to decrypt the

222
00:10:25,850 --> 00:10:30,320
message so this is a quite a large

223
00:10:27,800 --> 00:10:32,120
number but in general the exact

224
00:10:30,320 --> 00:10:33,880
performance is dependent on these very

225
00:10:32,120 --> 00:10:37,100
specific properties of the Oracle that

226
00:10:33,880 --> 00:10:39,530
that we have so we can actually get it

227
00:10:37,100 --> 00:10:42,470
in much less than 1 million messages in

228
00:10:39,530 --> 00:10:43,819
some cases but for this stuff what the

229
00:10:42,470 --> 00:10:46,340
main field that I want you to remember

230
00:10:43,820 --> 00:10:48,380
is that the attack is adaptive chosen

231
00:10:46,340 --> 00:10:50,120
ciphertext which means that no matter

232
00:10:48,380 --> 00:10:52,550
how lucky we are and what kind of

233
00:10:50,120 --> 00:10:55,670
optimization we are able to do and if

234
00:10:52,550 --> 00:10:59,300
you want to decrypt the 2048 bit RSA key

235
00:10:55,670 --> 00:11:02,290
we need 2048 sequential or inquiries

236
00:10:59,300 --> 00:11:06,680
there's no way to go around it

237
00:11:02,290 --> 00:11:09,500
ok so what is the call of our attack the

238
00:11:06,680 --> 00:11:11,359
goal of our attack is is in most field

239
00:11:09,500 --> 00:11:13,069
in life we want to get cookies

240
00:11:11,360 --> 00:11:14,629
and there wasn't one to get cookies

241
00:11:13,069 --> 00:11:17,209
because this is a very efficient way to

242
00:11:14,629 --> 00:11:22,489
get users the data the session cookies

243
00:11:17,209 --> 00:11:24,888
is what enable us to connect to a web

244
00:11:22,489 --> 00:11:27,559
server without in putting the password

245
00:11:24,889 --> 00:11:30,709
in each connection so it it's very

246
00:11:27,559 --> 00:11:32,329
comfortable for the user and it gives if

247
00:11:30,709 --> 00:11:34,488
you got the session cookie then you can

248
00:11:32,329 --> 00:11:37,279
get access to them to the web server and

249
00:11:34,489 --> 00:11:39,350
then you can download off the victims

250
00:11:37,279 --> 00:11:41,569
emails or information you don't really

251
00:11:39,350 --> 00:11:44,119
need to try to decrypt each and every

252
00:11:41,569 --> 00:11:47,089
TLS communication that the client makes

253
00:11:44,119 --> 00:11:50,029
and the those cookies are sent in the

254
00:11:47,089 --> 00:11:51,739
beginning of each TLS connection and so

255
00:11:50,029 --> 00:11:54,649
we have this attack scenario for this

256
00:11:51,739 --> 00:11:57,139
RSA key exchange we're going to sleep to

257
00:11:54,649 --> 00:11:59,089
sniff one TLS handshake and the first

258
00:11:57,139 --> 00:12:02,689
message that is sent by the client and

259
00:11:59,089 --> 00:12:07,429
then we're going to use last battle to

260
00:12:02,689 --> 00:12:09,319
decrypt a pretty master secret and after

261
00:12:07,429 --> 00:12:11,929
we get the premaster secret we can

262
00:12:09,319 --> 00:12:14,929
decrypt the first message and then we

263
00:12:11,929 --> 00:12:17,660
get the cookie so all right it's very

264
00:12:14,929 --> 00:12:20,389
simple very elegant attack and this is

265
00:12:17,660 --> 00:12:24,469
how it's done if we have in the case of

266
00:12:20,389 --> 00:12:28,730
cache and timing side-channel so in our

267
00:12:24,470 --> 00:12:32,149
example we have a bank that has that has

268
00:12:28,730 --> 00:12:34,669
a very secure HTTP server and it

269
00:12:32,149 --> 00:12:37,879
translated a very very secure cloud

270
00:12:34,669 --> 00:12:40,309
service provider and we have mr. smiley

271
00:12:37,879 --> 00:12:43,160
hill mr. smiley wants to connect to the

272
00:12:40,309 --> 00:12:45,259
bank the Cookie Monster listens to the

273
00:12:43,160 --> 00:12:47,360
staff to communication and afterwards

274
00:12:45,259 --> 00:12:49,939
the Cookie Monster starts to do the

275
00:12:47,360 --> 00:12:54,649
blackened AHA attack and it gets the

276
00:12:49,939 --> 00:12:57,379
keys and for that we have the allocate

277
00:12:54,649 --> 00:12:58,939
cash attacker he runs on on the same

278
00:12:57,379 --> 00:13:00,949
hardware inside the cloud but on

279
00:12:58,939 --> 00:13:04,069
different virtual machine or different

280
00:13:00,949 --> 00:13:06,919
process and is able to measure the crash

281
00:13:04,069 --> 00:13:09,049
site owners so we have the Cookie

282
00:13:06,919 --> 00:13:13,040
Monster it cooperates with a cat and

283
00:13:09,049 --> 00:13:17,480
they're able to give the cookies okay so

284
00:13:13,040 --> 00:13:20,149
this is a relatively simple but we are

285
00:13:17,480 --> 00:13:22,220
very greedy people and we are and also

286
00:13:20,149 --> 00:13:24,499
the Cookie Monster is very greedy and we

287
00:13:22,220 --> 00:13:26,599
want to evolve the cookies

288
00:13:24,499 --> 00:13:29,149
okay so 6% of the connection is not

289
00:13:26,599 --> 00:13:31,429
enough force so what I want to do is

290
00:13:29,149 --> 00:13:34,369
what to use and there's a key exchange

291
00:13:31,429 --> 00:13:40,218
for and done great attack basically and

292
00:13:34,369 --> 00:13:43,189
what we want to do is to attack attack

293
00:13:40,219 --> 00:13:45,159
connection using a firm a deferment or

294
00:13:43,189 --> 00:13:48,829
some new SF or sweet and cause it to

295
00:13:45,159 --> 00:13:51,079
done get to another our sake I was a

296
00:13:48,829 --> 00:13:53,179
Christian and the nice thing about it is

297
00:13:51,079 --> 00:13:55,218
basically it only requires the server to

298
00:13:53,179 --> 00:13:56,929
support Alice a key change even if you

299
00:13:55,219 --> 00:13:59,749
have a client that doesn't support this

300
00:13:56,929 --> 00:14:01,848
at all we can still do this attack and I

301
00:13:59,749 --> 00:14:04,369
think it was mentioned before but using

302
00:14:01,849 --> 00:14:07,129
the the black box attack we were not

303
00:14:04,369 --> 00:14:09,409
only able to decrypt messages were able

304
00:14:07,129 --> 00:14:11,089
to cause the server to signed messages

305
00:14:09,409 --> 00:14:13,879
so we were able to sign the ephemeral

306
00:14:11,089 --> 00:14:16,939
different keys and the nice thing about

307
00:14:13,879 --> 00:14:18,619
it is also works on TLS 1.8

308
00:14:16,939 --> 00:14:20,228
it was already shown before in fact the

309
00:14:18,619 --> 00:14:22,579
field this is the only currently known

310
00:14:20,229 --> 00:14:27,349
possibility of a done by the tech on TLS

311
00:14:22,579 --> 00:14:29,059
one point see it does require an active

312
00:14:27,349 --> 00:14:31,309
man in the middle attack which is a bit

313
00:14:29,059 --> 00:14:33,289
more complicated but something we can

314
00:14:31,309 --> 00:14:36,829
leave it so the question is do we have

315
00:14:33,289 --> 00:14:40,970
the cookies and unfortunately for us the

316
00:14:36,829 --> 00:14:43,819
answer is no and the reason for that is

317
00:14:40,970 --> 00:14:45,829
that the tailless session has a timeout

318
00:14:43,819 --> 00:14:48,319
when we started here a spot a call after

319
00:14:45,829 --> 00:14:50,388
30 seconds if the protocol doesn't

320
00:14:48,319 --> 00:14:51,919
finish correctly the client will

321
00:14:50,389 --> 00:14:54,889
probably about this

322
00:14:51,919 --> 00:14:57,649
this protocol and unfortunately for us

323
00:14:54,889 --> 00:14:59,419
as we said this is this attack text what

324
00:14:57,649 --> 00:15:04,059
a large number of messages we can't

325
00:14:59,419 --> 00:15:06,859
finish it in other 30 seconds okay so

326
00:15:04,059 --> 00:15:09,368
the first nice thing is that we can

327
00:15:06,859 --> 00:15:12,229
still try to do this attack on Firefox

328
00:15:09,369 --> 00:15:14,629
and the reason for that is that there's

329
00:15:12,229 --> 00:15:17,239
a way to prevent timeout

330
00:15:14,629 --> 00:15:18,379
in Firefox TLS and check I'm using

331
00:15:17,239 --> 00:15:20,239
something called TLS

332
00:15:18,379 --> 00:15:22,849
warning alert something that's known

333
00:15:20,239 --> 00:15:26,059
field since the long term paper I think

334
00:15:22,849 --> 00:15:27,349
that they recently decided to fix this

335
00:15:26,059 --> 00:15:30,319
but something that's been known for

336
00:15:27,349 --> 00:15:32,239
several several years so basically what

337
00:15:30,319 --> 00:15:32,598
you can do we can do the man in the

338
00:15:32,239 --> 00:15:35,059
middle

339
00:15:32,599 --> 00:15:37,670
downloaded attack it we can keep the

340
00:15:35,059 --> 00:15:40,040
session alive for a relatively long time

341
00:15:37,670 --> 00:15:41,750
depending the deck itself and then we

342
00:15:40,040 --> 00:15:46,189
can finish the TLS and check after we

343
00:15:41,750 --> 00:15:49,190
decrypted the premaster secret so do we

344
00:15:46,190 --> 00:15:51,880
get the cookies and there's still one

345
00:15:49,190 --> 00:15:54,320
caveat left and this is the problem that

346
00:15:51,880 --> 00:15:55,790
use of the trying to access is back a

347
00:15:54,320 --> 00:15:58,280
crowd who might notice that it takes

348
00:15:55,790 --> 00:16:01,250
more than 10 minutes for this to website

349
00:15:58,280 --> 00:16:04,430
to to load and suffering that might look

350
00:16:01,250 --> 00:16:07,430
a little bit fishy to the user okay so

351
00:16:04,430 --> 00:16:11,120
we want to be able to still do the tag

352
00:16:07,430 --> 00:16:13,400
so we use the beast attack and the beast

353
00:16:11,120 --> 00:16:15,650
attack is a very nice I did and

354
00:16:13,400 --> 00:16:18,620
basically says that if we can run

355
00:16:15,650 --> 00:16:21,140
JavaScript code inside the browser of

356
00:16:18,620 --> 00:16:24,170
the user this JavaScript code can try to

357
00:16:21,140 --> 00:16:26,720
even repeatedly open TLS connection to

358
00:16:24,170 --> 00:16:29,540
the bear count does it can do it in the

359
00:16:26,720 --> 00:16:32,660
background the same TLS is will be sent

360
00:16:29,540 --> 00:16:34,280
to to the server and we can do this

361
00:16:32,660 --> 00:16:35,870
attack and this will doesn't need to

362
00:16:34,280 --> 00:16:40,100
know anything about it it's nothing

363
00:16:35,870 --> 00:16:41,300
really really nice and again at the

364
00:16:40,100 --> 00:16:43,730
start of which connection the same

365
00:16:41,300 --> 00:16:46,280
cookie is sent in the first in the first

366
00:16:43,730 --> 00:16:47,960
packet and so even if we have multiple

367
00:16:46,280 --> 00:16:51,699
connection we only need to break just

368
00:16:47,960 --> 00:16:54,800
one connection so we have the cookie

369
00:16:51,700 --> 00:16:57,380
okay so let's see what how does this

370
00:16:54,800 --> 00:17:00,050
affect the attack scenario and now we

371
00:16:57,380 --> 00:17:03,200
just want to take a Firefox so we have

372
00:17:00,050 --> 00:17:05,990
the same Bank with the same HTTP server

373
00:17:03,200 --> 00:17:08,569
and now we have mr. smiley that like me

374
00:17:05,990 --> 00:17:10,970
uses and the Firefox browser any wants

375
00:17:08,569 --> 00:17:12,859
to access his bank account so access the

376
00:17:10,970 --> 00:17:14,270
bank account and what you see is that it

377
00:17:12,859 --> 00:17:16,879
doesn't have any money in their country

378
00:17:14,270 --> 00:17:19,790
so mr. smiley is very very said that now

379
00:17:16,880 --> 00:17:22,970
and what it does when when people are in

380
00:17:19,790 --> 00:17:26,839
this kind of dispel is looking for the

381
00:17:22,970 --> 00:17:29,630
internet - way to find big prizes but as

382
00:17:26,839 --> 00:17:32,270
we all know nothing comes for free and

383
00:17:29,630 --> 00:17:34,640
those sites usually hide a very

384
00:17:32,270 --> 00:17:36,530
malicious attacker in this case this is

385
00:17:34,640 --> 00:17:38,930
the Cookie Monster and what the Cookie

386
00:17:36,530 --> 00:17:42,320
Monster does is sending this malicious

387
00:17:38,930 --> 00:17:45,650
JavaScript code to the to mr. smiley and

388
00:17:42,320 --> 00:17:48,290
Firefox browser and it now starts to try

389
00:17:45,650 --> 00:17:50,960
to reopen the connection and

390
00:17:48,290 --> 00:17:53,149
and the Cookie Monster can die to do

391
00:17:50,960 --> 00:17:56,450
them in in the middle attack again we

392
00:17:53,150 --> 00:17:59,450
use the cat in the in the same we're

393
00:17:56,450 --> 00:18:03,160
cloud provider and who managed to get

394
00:17:59,450 --> 00:18:06,050
the cookies okay so now we're very happy

395
00:18:03,160 --> 00:18:08,210
but we still have one problem and the

396
00:18:06,050 --> 00:18:09,919
main problem is that and I really like

397
00:18:08,210 --> 00:18:13,220
the Firefox browser so if you could say

398
00:18:09,920 --> 00:18:14,930
have very good quality properties and I

399
00:18:13,220 --> 00:18:17,050
don't want to attack on if I first want

400
00:18:14,930 --> 00:18:19,940
to be able to take all of the users and

401
00:18:17,050 --> 00:18:23,360
in most puzzles we don't we couldn't

402
00:18:19,940 --> 00:18:25,130
find any way to try to delay this

403
00:18:23,360 --> 00:18:28,310
timeout so we have only 30 seconds to

404
00:18:25,130 --> 00:18:30,650
finish the TLS and checked and the

405
00:18:28,310 --> 00:18:33,040
problem is that the expected number of

406
00:18:30,650 --> 00:18:35,870
queries that we need to in order to

407
00:18:33,040 --> 00:18:39,440
implement this Battenberg attack is very

408
00:18:35,870 --> 00:18:41,600
high however a nice feeling that you can

409
00:18:39,440 --> 00:18:43,640
see is that with a relatively low

410
00:18:41,600 --> 00:18:45,320
probably a low probability we might get

411
00:18:43,640 --> 00:18:48,650
really really lucky and the tech might

412
00:18:45,320 --> 00:18:50,720
finish much sooner using much smaller

413
00:18:48,650 --> 00:18:52,910
number of choirs so this is something

414
00:18:50,720 --> 00:18:54,920
that we can actually use we can use the

415
00:18:52,910 --> 00:18:56,750
beast attack and try to reason the tech

416
00:18:54,920 --> 00:18:59,060
multiple times and again we want to get

417
00:18:56,750 --> 00:19:02,660
a session cookie we need to be safe

418
00:18:59,060 --> 00:19:06,800
successful just once maybe one out of

419
00:19:02,660 --> 00:19:08,870
1,000 is really good enough okay so can

420
00:19:06,800 --> 00:19:13,129
we used to get the cookies and

421
00:19:08,870 --> 00:19:17,239
unfortunately still not and the reason

422
00:19:13,130 --> 00:19:19,130
is what we need at least 2048 queries as

423
00:19:17,240 --> 00:19:23,780
we said before and we have time for

424
00:19:19,130 --> 00:19:29,000
about 600 so unfortunate for us we need

425
00:19:23,780 --> 00:19:30,740
to do some more work okay so next try to

426
00:19:29,000 --> 00:19:31,420
paralyze this attack to make it go

427
00:19:30,740 --> 00:19:33,530
faster

428
00:19:31,420 --> 00:19:35,150
many companies reuse the same

429
00:19:33,530 --> 00:19:36,530
certificate across multiple servers

430
00:19:35,150 --> 00:19:38,570
around the world who want to have a

431
00:19:36,530 --> 00:19:41,450
server that runs in Europe and one in

432
00:19:38,570 --> 00:19:43,939
the US and one in Asia and we and

433
00:19:41,450 --> 00:19:45,740
usually do use the same certificate in

434
00:19:43,940 --> 00:19:47,060
all of the servers I'm not sure if

435
00:19:45,740 --> 00:19:50,300
there's a really good reason to do it

436
00:19:47,060 --> 00:19:52,730
but it really helped us in any way and

437
00:19:50,300 --> 00:19:54,590
we can actually try to paralyze the

438
00:19:52,730 --> 00:19:57,920
attacker cost-of-service

439
00:19:54,590 --> 00:20:00,320
so it's server is a separate Oracle

440
00:19:57,920 --> 00:20:01,639
there's been many many previous work

441
00:20:00,320 --> 00:20:03,769
that talk about how we

442
00:20:01,639 --> 00:20:06,019
and paralyzed this type of laughing

443
00:20:03,769 --> 00:20:09,079
attack so is it enough to get the cookie

444
00:20:06,019 --> 00:20:11,149
and again the answer is unfortunately no

445
00:20:09,079 --> 00:20:14,359
because as we said before we need at

446
00:20:11,149 --> 00:20:17,089
least two for 748 sequential adaptive

447
00:20:14,359 --> 00:20:18,589
core and wireless so we need to hear the

448
00:20:17,089 --> 00:20:20,989
response of their previous pilot before

449
00:20:18,589 --> 00:20:26,599
we can continue and we won't have time

450
00:20:20,989 --> 00:20:28,759
for 600 so we can't do this attack so we

451
00:20:26,599 --> 00:20:31,099
need to find a way to paralyze this

452
00:20:28,759 --> 00:20:32,479
attack in a new way and before we start

453
00:20:31,099 --> 00:20:36,349
we'll give a little bit of background

454
00:20:32,479 --> 00:20:39,049
about the about the manual attack and

455
00:20:36,349 --> 00:20:41,899
the manual attack is again padding or

456
00:20:39,049 --> 00:20:43,969
scale attack against RSA which it uses a

457
00:20:41,899 --> 00:20:47,629
more powerful oracle than the one that

458
00:20:43,969 --> 00:20:48,919
uses in black box and Amanda Walker

459
00:20:47,629 --> 00:20:52,089
looks something like this

460
00:20:48,919 --> 00:20:55,759
we all can receive a ciphertext

461
00:20:52,089 --> 00:20:59,539
encrypted with our same and it simply

462
00:20:55,759 --> 00:21:03,489
returns 1 if the topmost byte of the

463
00:20:59,539 --> 00:21:06,109
plaintext is 0 or not this is it and

464
00:21:03,489 --> 00:21:08,719
it's more powerful because the chances

465
00:21:06,109 --> 00:21:13,728
that we will find such a ciphertext and

466
00:21:08,719 --> 00:21:15,529
on is 1 over 2 funds to 256 which is

467
00:21:13,729 --> 00:21:18,320
much better than the regular black and

468
00:21:15,529 --> 00:21:22,219
butter orchid that requires 2 bytes in

469
00:21:18,320 --> 00:21:24,109
order to succeed so we start the attack

470
00:21:22,219 --> 00:21:27,409
with what we call the blending phase we

471
00:21:24,109 --> 00:21:30,859
simply generate random numbers random as

472
00:21:27,409 --> 00:21:33,139
values we'll clip this s value and then

473
00:21:30,859 --> 00:21:35,739
multiplied to the ciphertext and due to

474
00:21:33,139 --> 00:21:38,718
the malleability properties of oh maybe

475
00:21:35,739 --> 00:21:42,440
some homomorphic properties of a let's

476
00:21:38,719 --> 00:21:46,669
say and that plaintext is simply M times

477
00:21:42,440 --> 00:21:49,279
s and then if the Oracle returns 1 then

478
00:21:46,669 --> 00:21:54,049
what we know is that M times s is

479
00:21:49,279 --> 00:21:57,409
smaller than 2 to the log of n minus 8

480
00:21:54,049 --> 00:21:59,570
we know that they ate top bits are 0 so

481
00:21:57,409 --> 00:22:02,359
if this is the whole range of the

482
00:21:59,570 --> 00:22:06,229
possible values of M times s now we know

483
00:22:02,359 --> 00:22:08,389
that this topmost thought is it's not

484
00:22:06,229 --> 00:22:10,879
possible and we narrowed our search

485
00:22:08,389 --> 00:22:14,059
range which of course is still really

486
00:22:10,879 --> 00:22:15,240
huge and the way that this continues is

487
00:22:14,059 --> 00:22:17,610
by iterative

488
00:22:15,240 --> 00:22:20,090
reducing the possible interval will M

489
00:22:17,610 --> 00:22:23,699
times s lives in and actually after

490
00:22:20,090 --> 00:22:25,770
doing maybe extra is sequential queries

491
00:22:23,700 --> 00:22:28,130
what we have is that we know that M

492
00:22:25,770 --> 00:22:33,480
times s is in some smaller interval

493
00:22:28,130 --> 00:22:36,210
which is denoted by AI n bi and then we

494
00:22:33,480 --> 00:22:39,029
know that there is some value all right

495
00:22:36,210 --> 00:22:41,460
that if we take M times s minus a while

496
00:22:39,029 --> 00:22:44,690
this value is small we don't know what

497
00:22:41,460 --> 00:22:48,450
it is but we know it is smaller than the

498
00:22:44,690 --> 00:22:51,029
size of the interval and the way that

499
00:22:48,450 --> 00:22:53,899
this attack was basically we do a query

500
00:22:51,029 --> 00:22:56,250
it quietly removes about half of the

501
00:22:53,899 --> 00:22:58,678
possible range then we can decrease the

502
00:22:56,250 --> 00:23:01,500
range in the end we know that we are

503
00:22:58,679 --> 00:23:04,679
somewhere in this small much smaller

504
00:23:01,500 --> 00:23:07,700
range and in the full attack what we do

505
00:23:04,679 --> 00:23:10,440
is we continue until this range becomes

506
00:23:07,700 --> 00:23:14,580
size of 1 and we actually retrieve the

507
00:23:10,440 --> 00:23:16,470
the plaintext although in our in our

508
00:23:14,580 --> 00:23:19,470
case we don't have enough time to do it

509
00:23:16,470 --> 00:23:21,480
so we can do only about six hundred five

510
00:23:19,470 --> 00:23:24,600
years out of the required two thousand

511
00:23:21,480 --> 00:23:27,990
so we still have a very very large range

512
00:23:24,600 --> 00:23:30,000
and so the tech is not good enough so

513
00:23:27,990 --> 00:23:32,190
what we're going to do is we're going to

514
00:23:30,000 --> 00:23:33,929
use what we call the cookie lattice and

515
00:23:32,190 --> 00:23:36,929
basically let's assume that we can do

516
00:23:33,929 --> 00:23:39,299
this attack in parallel and we kate x

517
00:23:36,929 --> 00:23:43,140
and 4 h attack we have a different

518
00:23:39,299 --> 00:23:49,110
random s value that was used for the

519
00:23:43,140 --> 00:23:51,630
blending so F and K formulas of this of

520
00:23:49,110 --> 00:23:53,520
this format well we have this value that

521
00:23:51,630 --> 00:23:56,190
will not know but we know that it's very

522
00:23:53,520 --> 00:23:59,760
small which equals two M's time s minus

523
00:23:56,190 --> 00:24:01,820
the start of the interval and this is

524
00:23:59,760 --> 00:24:03,539
very similar to the very well-known

525
00:24:01,820 --> 00:24:05,720
hidden and Oh problem

526
00:24:03,539 --> 00:24:09,570
and this suffering that we know how to

527
00:24:05,720 --> 00:24:12,270
to stop using lattices so basically and

528
00:24:09,570 --> 00:24:15,120
finding M is reduced to solving the

529
00:24:12,270 --> 00:24:16,980
closest vector problem in a lattice we

530
00:24:15,120 --> 00:24:19,590
can invent this in the shortest vector

531
00:24:16,980 --> 00:24:22,230
problem of a lattice and then solved it

532
00:24:19,590 --> 00:24:26,100
really relatively efficiently using LLL

533
00:24:22,230 --> 00:24:28,060
and this is the lattice that we create

534
00:24:26,100 --> 00:24:30,449
for the for this attack

535
00:24:28,060 --> 00:24:33,970
and in the end what we need is about

536
00:24:30,450 --> 00:24:36,270
five servers to order to decrypt 2048

537
00:24:33,970 --> 00:24:40,420
bits I would say using this manual

538
00:24:36,270 --> 00:24:42,910
manual worker so in the end we get the

539
00:24:40,420 --> 00:24:46,330
cookie okay

540
00:24:42,910 --> 00:24:48,270
and is something that's a bit

541
00:24:46,330 --> 00:24:50,770
interesting about about this and

542
00:24:48,270 --> 00:24:52,900
interesting about this is that this is

543
00:24:50,770 --> 00:24:55,510
not an optimization for that tech this

544
00:24:52,900 --> 00:24:57,130
is a trade off and actually the initial

545
00:24:55,510 --> 00:25:01,350
blending phase that we mentioned trying

546
00:24:57,130 --> 00:25:05,800
to find some value s that is that Oracle

547
00:25:01,350 --> 00:25:10,300
returns one on is more expensive in some

548
00:25:05,800 --> 00:25:13,060
way a bit then than the other stages so

549
00:25:10,300 --> 00:25:15,669
if we want to run this at a compiler

550
00:25:13,060 --> 00:25:19,690
actually require more quiet than the

551
00:25:15,670 --> 00:25:21,880
original attack needed so what we so you

552
00:25:19,690 --> 00:25:23,560
can ask why why do we want to do it so

553
00:25:21,880 --> 00:25:25,090
the reason is that it gives us a

554
00:25:23,560 --> 00:25:27,190
trade-off between the total number of

555
00:25:25,090 --> 00:25:29,770
queries and the number of sequential

556
00:25:27,190 --> 00:25:31,420
choir is that we need and this is allows

557
00:25:29,770 --> 00:25:33,100
us basically to finish the attack in

558
00:25:31,420 --> 00:25:35,920
under 30 seconds

559
00:25:33,100 --> 00:25:38,260
and the attack scenario now looks

560
00:25:35,920 --> 00:25:41,410
nothing like this we have the same

561
00:25:38,260 --> 00:25:46,180
attack with the with same smiley but now

562
00:25:41,410 --> 00:25:48,010
we use in this case for service in

563
00:25:46,180 --> 00:25:50,020
parallel in order to under run the

564
00:25:48,010 --> 00:25:52,240
attack with we do the same attacks

565
00:25:50,020 --> 00:25:54,520
before we get all of the results we put

566
00:25:52,240 --> 00:26:00,640
them in the lattice and then we have the

567
00:25:54,520 --> 00:26:03,040
cookies okay so this is the full before

568
00:26:00,640 --> 00:26:05,950
attack scenario but so far I didn't

569
00:26:03,040 --> 00:26:07,360
mention anyway and what are the actual

570
00:26:05,950 --> 00:26:09,190
vulnerabilities of the blackened mahi

571
00:26:07,360 --> 00:26:13,600
attack and actually why is it so

572
00:26:09,190 --> 00:26:16,990
difficult to to fix this problem it's

573
00:26:13,600 --> 00:26:22,449
known from 98 we still we still see it

574
00:26:16,990 --> 00:26:25,660
in 2019 and the reason is that it's very

575
00:26:22,450 --> 00:26:27,370
hard to reduce the the term durability

576
00:26:25,660 --> 00:26:31,120
when you do have a say cake change

577
00:26:27,370 --> 00:26:33,370
basically in the the main goal that we

578
00:26:31,120 --> 00:26:34,350
want to achieve is that no matter what

579
00:26:33,370 --> 00:26:36,939
the

580
00:26:34,350 --> 00:26:39,309
pkcs verification function returns if

581
00:26:36,940 --> 00:26:41,890
it's 1 or 0 the TLS sanction should

582
00:26:39,309 --> 00:26:44,740
continue in the same manner basically

583
00:26:41,890 --> 00:26:47,140
and the way that the brothel bark

584
00:26:44,740 --> 00:26:50,860
original attack was mitigated in TLS was

585
00:26:47,140 --> 00:26:53,470
that if the paddle scheme fails then we

586
00:26:50,860 --> 00:26:54,699
generate a random key and this is what

587
00:26:53,470 --> 00:26:55,330
the server used to continue the

588
00:26:54,700 --> 00:26:57,100
handshake

589
00:26:55,330 --> 00:26:58,300
then check will fail in the end but it

590
00:26:57,100 --> 00:27:01,178
will be very difficult for the attacker

591
00:26:58,300 --> 00:27:03,879
to know if it was because of the padding

592
00:27:01,179 --> 00:27:06,370
that didn't succeed because the random

593
00:27:03,880 --> 00:27:09,550
key is not indicated to sent by the

594
00:27:06,370 --> 00:27:11,020
client so we need to do it in a way

595
00:27:09,550 --> 00:27:13,090
that's very difficult for the attacker

596
00:27:11,020 --> 00:27:16,720
to differentiate if we use this random

597
00:27:13,090 --> 00:27:19,178
key or the original key that was sent by

598
00:27:16,720 --> 00:27:22,000
the client so this is something that's

599
00:27:19,179 --> 00:27:24,640
very very hard to do in with very low

600
00:27:22,000 --> 00:27:26,410
tempo availability but most of the

601
00:27:24,640 --> 00:27:29,850
implementations that you check managed

602
00:27:26,410 --> 00:27:34,450
to do it relatively relatively well

603
00:27:29,850 --> 00:27:36,428
however it is very very very hard to

604
00:27:34,450 --> 00:27:38,410
implement this in what we call full

605
00:27:36,429 --> 00:27:40,780
constant time for constant time means

606
00:27:38,410 --> 00:27:43,300
that does not a small very temporal

607
00:27:40,780 --> 00:27:44,950
ability there is no time variability the

608
00:27:43,300 --> 00:27:47,620
the soft flow actually behaves the same

609
00:27:44,950 --> 00:27:51,760
way no matter what the the padding

610
00:27:47,620 --> 00:27:53,919
check returns and as we've seen many

611
00:27:51,760 --> 00:27:54,910
times before when we have sub constant

612
00:27:53,920 --> 00:27:58,120
time implementations

613
00:27:54,910 --> 00:28:01,840
they're only self secure and this is the

614
00:27:58,120 --> 00:28:03,689
reason we have all of this nice table so

615
00:28:01,840 --> 00:28:06,730
in this table you can see that there are

616
00:28:03,690 --> 00:28:09,190
3 different categories that we have the

617
00:28:06,730 --> 00:28:11,740
data conversion the PK verification the

618
00:28:09,190 --> 00:28:13,510
tears mitigation which we consider the

619
00:28:11,740 --> 00:28:16,320
three layers in the way that we want to

620
00:28:13,510 --> 00:28:18,580
mitigate this type of attacks in each

621
00:28:16,320 --> 00:28:21,700
each layer has its own type of

622
00:28:18,580 --> 00:28:24,010
vulnerabilities so we start with the

623
00:28:21,700 --> 00:28:25,750
data conversion and what do mean by data

624
00:28:24,010 --> 00:28:27,340
conversion basically as I said a

625
00:28:25,750 --> 00:28:30,010
description of encryption as we said

626
00:28:27,340 --> 00:28:33,730
before it's math it works with big

627
00:28:30,010 --> 00:28:36,070
integer numbers although the pkcs pedal

628
00:28:33,730 --> 00:28:38,260
scheme works with bytes or so this is

629
00:28:36,070 --> 00:28:39,939
well this this is were the way that we

630
00:28:38,260 --> 00:28:42,280
handle the keys and information want to

631
00:28:39,940 --> 00:28:46,359
encrypt so we need to convert from one

632
00:28:42,280 --> 00:28:50,178
to another so after after we decrypt the

633
00:28:46,359 --> 00:28:52,340
the sephadex we get plaintext number and

634
00:28:50,179 --> 00:28:54,320
want to convert it to bytes

635
00:28:52,340 --> 00:28:57,649
this is depending on implementation

636
00:28:54,320 --> 00:29:00,289
might be relatively hard thing to do in

637
00:28:57,649 --> 00:29:01,580
constant time and when we view the

638
00:29:00,289 --> 00:29:05,749
different implementations what we found

639
00:29:01,580 --> 00:29:08,478
is and most most prominent was a

640
00:29:05,749 --> 00:29:11,210
conditional padding with zeros if the

641
00:29:08,479 --> 00:29:13,549
decrypted number was small we need to

642
00:29:11,210 --> 00:29:16,190
read it with zeros in the top bytes and

643
00:29:13,549 --> 00:29:19,158
this something that was actually very

644
00:29:16,190 --> 00:29:21,139
hard to do in constant time there was

645
00:29:19,159 --> 00:29:25,419
conditional branching on the exact size

646
00:29:21,139 --> 00:29:27,799
of the padding and again the timing

647
00:29:25,419 --> 00:29:31,159
difference that was caused by this type

648
00:29:27,799 --> 00:29:32,509
of branches is actually negligible it's

649
00:29:31,159 --> 00:29:35,330
very hard to measure it from outside

650
00:29:32,509 --> 00:29:37,070
well however and we're using cache

651
00:29:35,330 --> 00:29:38,989
attacks it's something that sometimes

652
00:29:37,070 --> 00:29:40,639
it's very easy to find for example it

653
00:29:38,989 --> 00:29:43,279
was in one of the implementation a

654
00:29:40,639 --> 00:29:46,070
conditional call to memset if we need to

655
00:29:43,279 --> 00:29:47,450
set one or more bytes to zero this is

656
00:29:46,070 --> 00:29:51,559
something that's when you do a cache

657
00:29:47,450 --> 00:29:54,349
attack is very very easy to see and the

658
00:29:51,559 --> 00:29:55,940
vulnerability is very problematic here

659
00:29:54,349 --> 00:29:57,710
because there is from very very low

660
00:29:55,940 --> 00:29:59,299
level civilization function this is

661
00:29:57,710 --> 00:30:02,479
something that's the people that

662
00:29:59,299 --> 00:30:03,969
actually implement the TLS mitigation

663
00:30:02,479 --> 00:30:06,979
they usually work in a very different

664
00:30:03,969 --> 00:30:10,690
level we've been seen cases which the

665
00:30:06,979 --> 00:30:14,289
the TLS Brackenbury mitigation and this

666
00:30:10,690 --> 00:30:17,109
function were in different cryptographic

667
00:30:14,289 --> 00:30:19,339
libraries all together it's very hard to

668
00:30:17,109 --> 00:30:23,168
to understand that this surface that

669
00:30:19,339 --> 00:30:26,239
might help you in the upper layers

670
00:30:23,169 --> 00:30:28,969
another level of attack is the precursor

671
00:30:26,239 --> 00:30:30,859
as verification itself and this is a

672
00:30:28,969 --> 00:30:33,409
relatively complex check it who has

673
00:30:30,859 --> 00:30:35,449
multiple valid lead validity checks we

674
00:30:33,409 --> 00:30:37,849
need to check that the two top most

675
00:30:35,450 --> 00:30:40,849
bytes are 0 and 2 we need to check that

676
00:30:37,849 --> 00:30:43,519
wave and a large enough number of random

677
00:30:40,849 --> 00:30:44,989
bytes until before we get 0 we need to

678
00:30:43,519 --> 00:30:47,839
check the link of the plaintext

679
00:30:44,989 --> 00:30:50,539
all of these checks are done one of the

680
00:30:47,839 --> 00:30:55,158
the other and what we found is basically

681
00:30:50,539 --> 00:30:58,129
a lot of unconstant behavior for example

682
00:30:55,159 --> 00:30:59,520
conditional calls to mem copy so in some

683
00:30:58,129 --> 00:31:02,429
cases we

684
00:30:59,520 --> 00:31:06,440
the that we only copied the plaintext -

685
00:31:02,430 --> 00:31:09,870
that's odd if the if the if the pending

686
00:31:06,440 --> 00:31:12,210
is valid otherwise they simply leave and

687
00:31:09,870 --> 00:31:13,919
leave the buffer alone the world

688
00:31:12,210 --> 00:31:15,720
condition of Expo ever long if the

689
00:31:13,920 --> 00:31:17,100
verification affairs conditional

690
00:31:15,720 --> 00:31:19,290
branching or the different validity

691
00:31:17,100 --> 00:31:23,040
checks which was nice because they gave

692
00:31:19,290 --> 00:31:25,980
us many types of more efficient platen

693
00:31:23,040 --> 00:31:28,470
baha workers and again timely difference

694
00:31:25,980 --> 00:31:32,580
is relatively negligible but it's very

695
00:31:28,470 --> 00:31:35,610
easy to detect ok the last layer that we

696
00:31:32,580 --> 00:31:37,949
have is what we call the TLS mitigation

697
00:31:35,610 --> 00:31:40,290
and as we said before the goal is to

698
00:31:37,950 --> 00:31:45,870
keep the same behavior if the

699
00:31:40,290 --> 00:31:49,139
verification succeed or fails and if we

700
00:31:45,870 --> 00:31:51,810
use a random key so on this layer what

701
00:31:49,140 --> 00:31:54,000
we found is again conditional branching

702
00:31:51,810 --> 00:31:56,790
on the vacation result conditional

703
00:31:54,000 --> 00:32:00,500
member we accesses and even in some case

704
00:31:56,790 --> 00:32:02,790
and the call to the random generator

705
00:32:00,500 --> 00:32:07,140
function was only done if the

706
00:32:02,790 --> 00:32:10,080
verification failed and again apart from

707
00:32:07,140 --> 00:32:11,970
this random key generation which is

708
00:32:10,080 --> 00:32:14,159
actually text what a long time most of

709
00:32:11,970 --> 00:32:19,380
the tech time a difference of negligible

710
00:32:14,160 --> 00:32:23,640
okay so if we try to sum up our results

711
00:32:19,380 --> 00:32:25,650
and we show several techniques for micro

712
00:32:23,640 --> 00:32:28,490
of the architectural padding all the

713
00:32:25,650 --> 00:32:30,510
texts we found it seven out of nine

714
00:32:28,490 --> 00:32:33,210
implementations that we check available

715
00:32:30,510 --> 00:32:35,670
we show a proof of concept for the

716
00:32:33,210 --> 00:32:38,040
monitor band Breitenbach attack we show

717
00:32:35,670 --> 00:32:41,820
how we can boost the tech efficiency

718
00:32:38,040 --> 00:32:43,889
using this type of attack and we show

719
00:32:41,820 --> 00:32:45,960
how we can paralyze this attack and to

720
00:32:43,890 --> 00:32:48,690
do download attack and we have a proof

721
00:32:45,960 --> 00:32:52,250
of concept for attack using a manga

722
00:32:48,690 --> 00:32:58,770
Vulcan and n11

723
00:32:52,250 --> 00:33:01,170
okay and so basically the goal of this

724
00:32:58,770 --> 00:33:03,900
type of research is to help make the

725
00:33:01,170 --> 00:33:04,890
internet most Hugh so the main goal is

726
00:33:03,900 --> 00:33:07,860
to try to fix this type of

727
00:33:04,890 --> 00:33:10,740
vulnerabilities so we started relatively

728
00:33:07,860 --> 00:33:12,939
non-disclosure disclosure process there

729
00:33:10,740 --> 00:33:16,480
were seven windows that were title

730
00:33:12,940 --> 00:33:18,730
plus two and from the beginning we

731
00:33:16,480 --> 00:33:22,510
thought this is going to be relatively

732
00:33:18,730 --> 00:33:27,280
hard thing to to fix because of the wide

733
00:33:22,510 --> 00:33:30,280
range of flesh that we need to fix in

734
00:33:27,280 --> 00:33:35,350
order to close these vulnerabilities so

735
00:33:30,280 --> 00:33:37,389
we decided to give 120 days embargo

736
00:33:35,350 --> 00:33:40,270
period and so to make sure that

737
00:33:37,390 --> 00:33:41,980
everybody would be able to to fix it and

738
00:33:40,270 --> 00:33:44,620
this stuff it is relatively difficult

739
00:33:41,980 --> 00:33:46,000
because you have here and some very

740
00:33:44,620 --> 00:33:49,590
large companies with people that are

741
00:33:46,000 --> 00:33:51,760
paid for and some open source

742
00:33:49,590 --> 00:33:54,220
implementation that there's one guy that

743
00:33:51,760 --> 00:33:56,379
does all of the coding on his own spare

744
00:33:54,220 --> 00:34:00,340
time with somehow holding at all of

745
00:33:56,380 --> 00:34:02,530
these different parties and in the end

746
00:34:00,340 --> 00:34:05,080
all of them have purchased patch the

747
00:34:02,530 --> 00:34:07,120
code and with some various level of

748
00:34:05,080 --> 00:34:08,110
successes we have some laboratory that

749
00:34:07,120 --> 00:34:11,380
did it patch it

750
00:34:08,110 --> 00:34:15,490
one enough but most of it was it was

751
00:34:11,380 --> 00:34:18,430
okay and I think we wish we learned some

752
00:34:15,489 --> 00:34:21,159
lessons from this type of disclosure

753
00:34:18,429 --> 00:34:24,040
when I process and I feel that it's

754
00:34:21,159 --> 00:34:26,259
something that maybe we as a community

755
00:34:24,040 --> 00:34:28,719
need to try to think about how we do

756
00:34:26,260 --> 00:34:30,220
this disclosure process and how we make

757
00:34:28,719 --> 00:34:33,399
sure that the people will disclose to

758
00:34:30,219 --> 00:34:36,520
cooperate in in a good manner and when

759
00:34:33,400 --> 00:34:38,350
you disclose to a specific window then

760
00:34:36,520 --> 00:34:40,060
everything is okay you can code in at

761
00:34:38,350 --> 00:34:41,589
the time of the embargo if you need a

762
00:34:40,060 --> 00:34:44,469
little bit more time you can try to

763
00:34:41,590 --> 00:34:46,810
extend it if we fix it very early you

764
00:34:44,469 --> 00:34:48,609
can try to disclose sooner but what

765
00:34:46,810 --> 00:34:50,639
happens if there's one company that

766
00:34:48,610 --> 00:34:52,960
wants to disclose in about one week and

767
00:34:50,639 --> 00:34:58,720
another company says it's going to take

768
00:34:52,960 --> 00:35:00,190
90 days my belief is that we should give

769
00:34:58,720 --> 00:35:02,220
the time for at least a reasonable

770
00:35:00,190 --> 00:35:06,100
amount of time for all of the parties to

771
00:35:02,220 --> 00:35:08,680
to have time to fix it unfortunately as

772
00:35:06,100 --> 00:35:12,970
we've seen not all of the vendors that

773
00:35:08,680 --> 00:35:15,910
we disclose to for the same and we had

774
00:35:12,970 --> 00:35:19,569
for one example we had one of the vendor

775
00:35:15,910 --> 00:35:21,370
says said to us that is not it's not

776
00:35:19,570 --> 00:35:24,070
winning to keep an along about embargo

777
00:35:21,370 --> 00:35:25,870
period is going to give us as most two

778
00:35:24,070 --> 00:35:26,800
weeks after we disclose it to and then

779
00:35:25,870 --> 00:35:28,990
it's going to

780
00:35:26,800 --> 00:35:30,640
do a public pitch and this kind of

781
00:35:28,990 --> 00:35:31,990
public page is basically releasing the

782
00:35:30,640 --> 00:35:33,819
zero day and all of the other vendors

783
00:35:31,990 --> 00:35:34,149
that didn't patch it because it's not

784
00:35:33,820 --> 00:35:37,570
very

785
00:35:34,150 --> 00:35:38,980
docetaxel nice elegant but they're not

786
00:35:37,570 --> 00:35:40,930
very complicated to understand

787
00:35:38,980 --> 00:35:43,420
especially after you diff the source

788
00:35:40,930 --> 00:35:46,149
code of the changes and with this window

789
00:35:43,420 --> 00:35:49,930
it was relatively easy we said okay so I

790
00:35:46,150 --> 00:35:51,190
will contact you again in about nine

791
00:35:49,930 --> 00:35:52,839
weeks and then we'll discuss to you

792
00:35:51,190 --> 00:35:56,340
after all of the rest of the the windows

793
00:35:52,840 --> 00:35:59,320
dan decided to fix what happens was that

794
00:35:56,340 --> 00:36:02,230
after two months he returned to us I

795
00:35:59,320 --> 00:36:04,540
said okay maybe I don't want to hear it

796
00:36:02,230 --> 00:36:07,360
now and then we disclosed it and then

797
00:36:04,540 --> 00:36:10,090
what happens is that we discovered that

798
00:36:07,360 --> 00:36:12,010
and one of the vulnerabilities wasn't in

799
00:36:10,090 --> 00:36:14,320
a code that he's responsible but some

800
00:36:12,010 --> 00:36:17,890
other open source libraries responsible

801
00:36:14,320 --> 00:36:20,620
too and then we got a message from this

802
00:36:17,890 --> 00:36:23,379
poor guy that says I'm doing it on my

803
00:36:20,620 --> 00:36:26,049
own free time and you want me to do this

804
00:36:23,380 --> 00:36:28,600
entire large patch of Thanksgiving I

805
00:36:26,050 --> 00:36:31,210
need to have at least one week that of

806
00:36:28,600 --> 00:36:33,069
unpaid vacation from work to do it is it

807
00:36:31,210 --> 00:36:35,500
possible to postpone the disclosure

808
00:36:33,070 --> 00:36:38,440
process so again because we feel that

809
00:36:35,500 --> 00:36:39,910
the main goal here is to make Nitin at

810
00:36:38,440 --> 00:36:42,220
most a human waste all of the other

811
00:36:39,910 --> 00:36:46,779
vendors are you able to postpone it and

812
00:36:42,220 --> 00:36:49,660
we postpone and the one main issue that

813
00:36:46,780 --> 00:36:51,640
we had is that one of the companies

814
00:36:49,660 --> 00:36:55,629
which I won't mention its name although

815
00:36:51,640 --> 00:37:00,279
it has been mentioned before in previous

816
00:36:55,630 --> 00:37:03,490
talks and decided that they want to do a

817
00:37:00,280 --> 00:37:05,440
better test of the of the patch and then

818
00:37:03,490 --> 00:37:07,629
they called at some point it says okay

819
00:37:05,440 --> 00:37:10,570
two days ago we already patched it and

820
00:37:07,630 --> 00:37:12,640
we sent the which sent it is a better

821
00:37:10,570 --> 00:37:16,480
version to the better channel for

822
00:37:12,640 --> 00:37:20,620
protest for people to test we claimed

823
00:37:16,480 --> 00:37:23,170
that if for example I would be kind of a

824
00:37:20,620 --> 00:37:25,600
techie that wants to find zero this one

825
00:37:23,170 --> 00:37:28,300
product I will probably try to be on

826
00:37:25,600 --> 00:37:30,970
this better tester list that to get

827
00:37:28,300 --> 00:37:33,790
those no saralyn list and see if there's

828
00:37:30,970 --> 00:37:36,370
anything interesting in them and then

829
00:37:33,790 --> 00:37:38,970
saw that we got was yes that is an

830
00:37:36,370 --> 00:37:43,480
interesting point and

831
00:37:38,970 --> 00:37:45,580
but we don't really care and in the end

832
00:37:43,480 --> 00:37:46,900
I'm not sure that especially in this

833
00:37:45,580 --> 00:37:49,049
type of attack is not something that's

834
00:37:46,900 --> 00:37:55,780
very easy to implement in in practice

835
00:37:49,050 --> 00:37:57,490
but I feel that I for once will be very

836
00:37:55,780 --> 00:38:00,280
careful in disclosing to this company

837
00:37:57,490 --> 00:38:02,319
again when we having multiple vendor

838
00:38:00,280 --> 00:38:04,750
problem it's often that I feel that with

839
00:38:02,320 --> 00:38:08,830
community should try to see how we can

840
00:38:04,750 --> 00:38:10,390
share this kind of information so maybe

841
00:38:08,830 --> 00:38:14,980
we can find a way to cause these

842
00:38:10,390 --> 00:38:18,160
companies to behave more nicely in this

843
00:38:14,980 --> 00:38:22,830
type of situations okay

844
00:38:18,160 --> 00:38:24,940
and so after having said all that and

845
00:38:22,830 --> 00:38:28,240
what are the recommendations that we

846
00:38:24,940 --> 00:38:30,220
have from this type of attack and so in

847
00:38:28,240 --> 00:38:32,470
the paper we have many headlock tactic

848
00:38:30,220 --> 00:38:34,899
commendation how you can try to prevent

849
00:38:32,470 --> 00:38:36,850
this type of attack in the different

850
00:38:34,900 --> 00:38:40,000
layers but the bottom line is simply

851
00:38:36,850 --> 00:38:41,350
don't use mistake if change it's

852
00:38:40,000 --> 00:38:43,690
something that has failed us too many

853
00:38:41,350 --> 00:38:46,240
times in in the past and we need to find

854
00:38:43,690 --> 00:38:48,870
and we have better alternatives we need

855
00:38:46,240 --> 00:38:51,819
to find a way to actually duplicate it

856
00:38:48,870 --> 00:38:55,900
however if you really really really

857
00:38:51,820 --> 00:38:59,290
really must use I would say the main

858
00:38:55,900 --> 00:39:02,800
thing to do is please separate your

859
00:38:59,290 --> 00:39:05,590
certificates and in most companies that

860
00:39:02,800 --> 00:39:08,650
we that we've checked they reuse the

861
00:39:05,590 --> 00:39:13,990
same other certificate both for key

862
00:39:08,650 --> 00:39:15,700
decryption and for signing for and this

863
00:39:13,990 --> 00:39:18,669
what enables the all of the downgrade

864
00:39:15,700 --> 00:39:20,830
attacks if there will be separate

865
00:39:18,670 --> 00:39:23,350
certificates for decryption and for

866
00:39:20,830 --> 00:39:26,049
signing and if it will be possible to

867
00:39:23,350 --> 00:39:27,700
use different description certificates

868
00:39:26,050 --> 00:39:32,200
in different servers this will make this

869
00:39:27,700 --> 00:39:36,790
type of attacks not practical at all but

870
00:39:32,200 --> 00:39:38,500
again please just stop black box and

871
00:39:36,790 --> 00:39:42,310
this is a vendor field data and

872
00:39:38,500 --> 00:39:45,550
Twitter's a response to the pattern okay

873
00:39:42,310 --> 00:39:49,090
and in conclude in another conclusion

874
00:39:45,550 --> 00:39:50,710
what we say is that mitigating predicate

875
00:39:49,090 --> 00:39:51,490
acts on RSA it's not something that's

876
00:39:50,710 --> 00:39:52,720
impossible

877
00:39:51,490 --> 00:39:55,450
we've seen at least tool

878
00:39:52,720 --> 00:39:57,819
that were able to to do it and a few

879
00:39:55,450 --> 00:39:59,379
that several levels are now also secure

880
00:39:57,820 --> 00:40:02,950
but it's something that's very very

881
00:39:59,380 --> 00:40:06,280
close to impossible and I feel it's

882
00:40:02,950 --> 00:40:07,330
often that's mainly restaurant people

883
00:40:06,280 --> 00:40:09,340
that designed this cryptographic

884
00:40:07,330 --> 00:40:11,950
protocols try to do it in a way that

885
00:40:09,340 --> 00:40:14,290
it's much easier for people to implement

886
00:40:11,950 --> 00:40:16,419
it safely we're going to see another

887
00:40:14,290 --> 00:40:21,250
talk today about the similar a similar

888
00:40:16,420 --> 00:40:23,109
issue and it's not fair to just say all

889
00:40:21,250 --> 00:40:26,320
of these problems are implementation

890
00:40:23,109 --> 00:40:28,240
problems and the polymers did something

891
00:40:26,320 --> 00:40:30,010
wrong this is the fault of the people to

892
00:40:28,240 --> 00:40:33,279
design the protocol protocol should be

893
00:40:30,010 --> 00:40:35,590
easy enough to to implement and if you

894
00:40:33,280 --> 00:40:38,020
want the full papers and other

895
00:40:35,590 --> 00:40:40,830
information is in the website and I will

896
00:40:38,020 --> 00:40:40,830
be happy to take questions

897
00:40:40,880 --> 00:40:51,750
[Applause]

898
00:40:47,990 --> 00:40:53,549
hi so how did you actually find the

899
00:40:51,750 --> 00:40:55,790
cache size genetics was the menu code

900
00:40:53,550 --> 00:40:57,690
with you or is there something to

901
00:40:55,790 --> 00:41:00,410
cooperate into some continuous

902
00:40:57,690 --> 00:41:03,900
integration environment or something I

903
00:41:00,410 --> 00:41:05,490
would really want to say we have really

904
00:41:03,900 --> 00:41:08,940
excellent tools to do it automatically

905
00:41:05,490 --> 00:41:12,290
but the answer is very long manual code

906
00:41:08,940 --> 00:41:17,869
okay so next year captain

907
00:41:12,290 --> 00:41:17,869
Publius are there any other questions

908
00:41:24,320 --> 00:41:29,550
they care about this field this is the

909
00:41:26,849 --> 00:41:31,440
main the main field and they did a lot

910
00:41:29,550 --> 00:41:33,960
of work to try to fix all of the

911
00:41:31,440 --> 00:41:37,740
vulnerabilities and they out of

912
00:41:33,960 --> 00:41:40,109
open SSL which were almost safe to begin

913
00:41:37,740 --> 00:41:42,299
with and they just fixed something that

914
00:41:40,109 --> 00:41:45,119
I think that the vulnerabilities for

915
00:41:42,300 --> 00:41:46,619
open SSL was something that was known to

916
00:41:45,119 --> 00:41:49,680
be a problem they didn't think it was

917
00:41:46,619 --> 00:41:51,839
exploitable but you know and Obama SSI

918
00:41:49,680 --> 00:41:56,250
decided to take the time to fix it open

919
00:41:51,839 --> 00:42:01,290
SSL fix it a little bit later but on the

920
00:41:56,250 --> 00:42:03,359
other end Bayliss cell was written from

921
00:42:01,290 --> 00:42:04,800
the start as something that's one - it's

922
00:42:03,359 --> 00:42:08,580
supposed to be constant time and the

923
00:42:04,800 --> 00:42:09,930
coder is much much simpler and this one

924
00:42:08,580 --> 00:42:14,580
of the reason why they were able to do

925
00:42:09,930 --> 00:42:17,819
it okay any other questions maybe I have

926
00:42:14,580 --> 00:42:19,830
a question so you have many experiences

927
00:42:17,820 --> 00:42:20,550
with different vulnerabilities and

928
00:42:19,830 --> 00:42:24,509
casados

929
00:42:20,550 --> 00:42:32,790
what is so easier to prevent CBC padding

930
00:42:24,510 --> 00:42:35,700
Oracle attacks or and lucky 14 and this

931
00:42:32,790 --> 00:42:40,080
stuff I think that life is 13 if you're

932
00:42:35,700 --> 00:42:42,020
willing to pay not a very large penalty

933
00:42:40,080 --> 00:42:47,069
in performance it's something that's

934
00:42:42,020 --> 00:42:48,300
relatively easy to fix and if you're if

935
00:42:47,070 --> 00:42:50,550
you wanted to pay the price that it

936
00:42:48,300 --> 00:42:52,200
cause it's either performance or to

937
00:42:50,550 --> 00:42:53,790
break some of the abstraction layers in

938
00:42:52,200 --> 00:42:55,589
the software which something that many

939
00:42:53,790 --> 00:42:56,790
programmers really really hate to do but

940
00:42:55,589 --> 00:42:58,150
if you will need to do it it's

941
00:42:56,790 --> 00:43:00,759
relatively

942
00:42:58,150 --> 00:43:03,309
easy to fix and this type of attack

943
00:43:00,759 --> 00:43:05,289
because it has very many different

944
00:43:03,309 --> 00:43:06,940
levels of code that each one of them

945
00:43:05,289 --> 00:43:11,490
might affect the other I think it's a

946
00:43:06,940 --> 00:43:15,119
much more complex thing to fix okay

947
00:43:11,490 --> 00:43:18,118
if there are no other questions then

948
00:43:15,119 --> 00:43:18,119
things

949
00:43:18,380 --> 00:43:23,139
[Applause]

