1
00:00:04,860 --> 00:00:09,900
so thank you for the introduction and

2
00:00:07,080 --> 00:00:12,240
good afternoon so I'm going to present

3
00:00:09,900 --> 00:00:14,370
some work that we did on the dragonfly

4
00:00:12,240 --> 00:00:19,140
handshake and this was done in

5
00:00:14,370 --> 00:00:21,779
collaboration with al Onan so the

6
00:00:19,140 --> 00:00:25,859
dragonfly handshake has recently been

7
00:00:21,779 --> 00:00:29,400
used in WPA 3 which was announced about

8
00:00:25,859 --> 00:00:31,710
a year ago the dragonfly handshake

9
00:00:29,400 --> 00:00:36,180
before that was actually already in use

10
00:00:31,710 --> 00:00:38,699
by the eep PWD protocol now what is the

11
00:00:36,180 --> 00:00:41,549
EPW D protocol well it's another

12
00:00:38,699 --> 00:00:44,460
protocol in Wi-Fi which is used by a

13
00:00:41,549 --> 00:00:47,040
small amount of enterprise Wi-Fi

14
00:00:44,460 --> 00:00:49,830
networks where you authenticate using a

15
00:00:47,040 --> 00:00:52,890
username and password for example about

16
00:00:49,830 --> 00:00:57,379
two to five percent of eDRAM networks

17
00:00:52,890 --> 00:01:00,989
use EEP PWD and that also uses dragonfly

18
00:00:57,379 --> 00:01:04,140
so let's first briefly introduce what

19
00:01:00,989 --> 00:01:07,710
the dragonfly handshake actually is so

20
00:01:04,140 --> 00:01:10,470
the dragonfly handshake is a Paik it's a

21
00:01:07,710 --> 00:01:13,550
password authenticated key exchange

22
00:01:10,470 --> 00:01:16,500
which in practice means that

23
00:01:13,550 --> 00:01:20,550
authentication happens based on a shared

24
00:01:16,500 --> 00:01:22,440
password and besides that the dragonfly

25
00:01:20,550 --> 00:01:24,899
handshake also negotiates a fresh

26
00:01:22,440 --> 00:01:27,450
session key which after the handshake

27
00:01:24,900 --> 00:01:30,960
can be used to encrypt actual data

28
00:01:27,450 --> 00:01:33,690
traffic now the interesting property

29
00:01:30,960 --> 00:01:36,960
that dragonfly owns a lot of other pics

30
00:01:33,690 --> 00:01:39,270
provides is that it offers forward

31
00:01:36,960 --> 00:01:42,658
secrecy and it protects against

32
00:01:39,270 --> 00:01:45,600
dictionary attacks and that's a huge

33
00:01:42,659 --> 00:01:48,630
advantage compared to wpa2 for example

34
00:01:45,600 --> 00:01:51,570
because with wpa2 an adversary can just

35
00:01:48,630 --> 00:01:53,399
passively capture a handshake you can he

36
00:01:51,570 --> 00:01:57,149
or she can take that handshake offline

37
00:01:53,400 --> 00:02:01,680
undo a dictionary or brute force attacks

38
00:01:57,150 --> 00:02:04,560
against it now a few other pics also

39
00:02:01,680 --> 00:02:07,350
have another property namely that they

40
00:02:04,560 --> 00:02:10,590
protect against what I called here

41
00:02:07,350 --> 00:02:13,739
server compromised in other words there

42
00:02:10,590 --> 00:02:16,440
are also commenting on asymmetric pics

43
00:02:13,740 --> 00:02:18,159
where if for example the server is

44
00:02:16,440 --> 00:02:20,439
compromised

45
00:02:18,159 --> 00:02:23,409
difficult for an attacker to then try to

46
00:02:20,439 --> 00:02:25,510
recover the original password so you can

47
00:02:23,409 --> 00:02:28,450
think of this that the server can store

48
00:02:25,510 --> 00:02:29,370
assaulted version of the password in a

49
00:02:28,450 --> 00:02:32,170
sense

50
00:02:29,370 --> 00:02:34,360
unfortunately dragonfly does not provide

51
00:02:32,170 --> 00:02:36,879
that property so a dragonfly if you

52
00:02:34,360 --> 00:02:38,890
manage to compromise for example access

53
00:02:36,879 --> 00:02:42,370
point or the router you have enough

54
00:02:38,890 --> 00:02:45,518
information to print at present to be a

55
00:02:42,370 --> 00:02:49,629
client so let me give a high-level

56
00:02:45,519 --> 00:02:51,250
overview of how dragonfly works so let's

57
00:02:49,629 --> 00:02:53,920
say we have a client that wants to

58
00:02:51,250 --> 00:02:56,349
connect to an Access Point then the

59
00:02:53,920 --> 00:02:59,078
first thing that needs to happen is that

60
00:02:56,349 --> 00:03:01,388
the password which is for example stored

61
00:02:59,079 --> 00:03:03,819
and asking it needs to be converted to a

62
00:03:01,389 --> 00:03:07,150
so called group elements which I will

63
00:03:03,819 --> 00:03:10,768
represent using P on this B can be used

64
00:03:07,150 --> 00:03:14,200
in the actual cryptographic calculations

65
00:03:10,769 --> 00:03:16,569
once this is done the handshake

66
00:03:14,200 --> 00:03:19,298
essentially consists of two main phases

67
00:03:16,569 --> 00:03:22,569
the first is the commit phase where we

68
00:03:19,299 --> 00:03:24,639
negotiate the shared secret and then we

69
00:03:22,569 --> 00:03:26,649
have a confirmed phrase where both

70
00:03:24,639 --> 00:03:29,079
parties essentially confirm that they

71
00:03:26,650 --> 00:03:32,799
negotiated the same key on that they

72
00:03:29,079 --> 00:03:37,660
both are using the same password now

73
00:03:32,799 --> 00:03:40,299
what's the interesting part here the

74
00:03:37,660 --> 00:03:43,239
interesting part is how the password is

75
00:03:40,299 --> 00:03:45,760
converted to a group element B because

76
00:03:43,239 --> 00:03:48,879
this is where a lot of vulnerabilities

77
00:03:45,760 --> 00:03:50,798
on a lot of side channels occur before I

78
00:03:48,879 --> 00:03:52,840
get into that there is one important

79
00:03:50,799 --> 00:03:55,239
remark and that is that the dragonfly

80
00:03:52,840 --> 00:03:58,060
handshake can be executed using both so

81
00:03:55,239 --> 00:04:01,750
called mod P crypto groups aren't using

82
00:03:58,060 --> 00:04:06,010
elliptic curves so let me first zoom in

83
00:04:01,750 --> 00:04:08,069
into the mod p groups first very quick

84
00:04:06,010 --> 00:04:11,828
background what are mod P groups

85
00:04:08,069 --> 00:04:16,930
basically means your calculations are

86
00:04:11,829 --> 00:04:19,720
done modulo P hence the name as well but

87
00:04:16,930 --> 00:04:22,360
what's more interesting here is how is

88
00:04:19,720 --> 00:04:25,630
the passwords converted into a member of

89
00:04:22,360 --> 00:04:28,770
the script a group and a naive first

90
00:04:25,630 --> 00:04:30,800
attempt would be the following algorithm

91
00:04:28,770 --> 00:04:33,289
basically you

92
00:04:30,800 --> 00:04:36,470
the password here using represented

93
00:04:33,290 --> 00:04:39,020
using PW you hash it together with the

94
00:04:36,470 --> 00:04:41,840
MAC addresses of the clients on the

95
00:04:39,020 --> 00:04:45,500
access point aren't you interpreted the

96
00:04:41,840 --> 00:04:47,900
resulting value as an integer then you

97
00:04:45,500 --> 00:04:51,020
just calculate some form formula here

98
00:04:47,900 --> 00:04:56,359
which converts it into a member of the

99
00:04:51,020 --> 00:04:59,390
mod P group and this would be this would

100
00:04:56,360 --> 00:05:00,050
work well except there is one small

101
00:04:59,390 --> 00:05:04,099
problem

102
00:05:00,050 --> 00:05:06,140
and that is for certain mod P groups the

103
00:05:04,100 --> 00:05:08,480
prime of the group

104
00:05:06,140 --> 00:05:10,490
well actually the value the resulting

105
00:05:08,480 --> 00:05:12,970
value here might be bigger than the

106
00:05:10,490 --> 00:05:16,430
prime of the group that is being used

107
00:05:12,970 --> 00:05:19,070
now one simple solution would have been

108
00:05:16,430 --> 00:05:22,490
to simply take the hash here and then do

109
00:05:19,070 --> 00:05:25,040
modulo P so mod P to get a number

110
00:05:22,490 --> 00:05:29,540
smaller than P but that introduces a

111
00:05:25,040 --> 00:05:32,240
small theoretic bias into this value so

112
00:05:29,540 --> 00:05:35,000
how did they decide to tackle this

113
00:05:32,240 --> 00:05:37,580
instead well they decided to add an

114
00:05:35,000 --> 00:05:41,090
f-test here and if the value is bigger

115
00:05:37,580 --> 00:05:45,080
than P then we actually include a

116
00:05:41,090 --> 00:05:47,270
counter here and if this value is

117
00:05:45,080 --> 00:05:49,190
smaller than P the first time we simply

118
00:05:47,270 --> 00:05:52,219
increase the counter try again

119
00:05:49,190 --> 00:05:55,610
until we finally have a value that is

120
00:05:52,220 --> 00:05:58,330
smaller than P so most of you can

121
00:05:55,610 --> 00:06:01,400
probably already see the problem here

122
00:05:58,330 --> 00:06:05,719
namely the number of iterations that are

123
00:06:01,400 --> 00:06:08,299
needed here depends on the password and

124
00:06:05,720 --> 00:06:11,750
in fact this was already pointed out by

125
00:06:08,300 --> 00:06:14,330
the ietf on c frg when this algorithm

126
00:06:11,750 --> 00:06:20,390
was being proposed

127
00:06:14,330 --> 00:06:22,969
so already back in 2010 when there was

128
00:06:20,390 --> 00:06:25,729
the first standardization effort of

129
00:06:22,970 --> 00:06:27,620
dragonfly and a mailing list it was

130
00:06:25,730 --> 00:06:30,320
mentioned that you know this design is

131
00:06:27,620 --> 00:06:33,860
susceptible to timing side channels and

132
00:06:30,320 --> 00:06:36,980
it may leak the password on what they

133
00:06:33,860 --> 00:06:40,490
recommended to do is to exclude the MAC

134
00:06:36,980 --> 00:06:42,110
addresses from this algorithm because

135
00:06:40,490 --> 00:06:44,080
then you only need to execute this

136
00:06:42,110 --> 00:06:48,550
algorithm once and not every time

137
00:06:44,080 --> 00:06:50,889
that the handshake is executed now what

138
00:06:48,550 --> 00:06:54,669
was the reply at least at the time

139
00:06:50,889 --> 00:06:57,719
well the reply at the time was well I'm

140
00:06:54,669 --> 00:07:00,758
not really sure how important is this

141
00:06:57,719 --> 00:07:02,560
they thought it wouldn't leak the shared

142
00:07:00,759 --> 00:07:08,710
passwords aren't that the resulting

143
00:07:02,560 --> 00:07:10,990
attacks are quite complicated now their

144
00:07:08,710 --> 00:07:14,349
opinion changed a bit over the years but

145
00:07:10,990 --> 00:07:16,330
initially that was the reaction so let

146
00:07:14,349 --> 00:07:19,030
me come back to this first remark here

147
00:07:16,330 --> 00:07:23,050
that it's uncertain whether this really

148
00:07:19,030 --> 00:07:25,750
leaks the shared password or not so what

149
00:07:23,050 --> 00:07:30,039
can we as an attacker do well let's say

150
00:07:25,750 --> 00:07:33,520
that an access point is using WPA 3 with

151
00:07:30,039 --> 00:07:36,039
this algorithm that we just saw as an

152
00:07:33,520 --> 00:07:38,948
adversary I can then try to connect as a

153
00:07:36,039 --> 00:07:41,500
client for example using the client uses

154
00:07:38,949 --> 00:07:44,020
MAC address a and using a timing attack

155
00:07:41,500 --> 00:07:47,710
I can measure how many iterations that

156
00:07:44,020 --> 00:07:49,750
the access point needs let's say that I

157
00:07:47,710 --> 00:07:52,180
measure ok the access point needs two

158
00:07:49,750 --> 00:07:55,569
iterations to convert the password into

159
00:07:52,180 --> 00:07:58,180
a multi element and I then have a

160
00:07:55,569 --> 00:08:01,000
dictionary of possible passwords here I

161
00:07:58,180 --> 00:08:03,729
just have three as an example on what I

162
00:08:01,000 --> 00:08:06,099
can then do as an adversary is run this

163
00:08:03,729 --> 00:08:07,659
algorithm on my own laptop and see how

164
00:08:06,099 --> 00:08:10,599
many iterations are needed for a

165
00:08:07,659 --> 00:08:13,930
specific password and see if it matches

166
00:08:10,599 --> 00:08:16,150
my observation so here in this example

167
00:08:13,930 --> 00:08:19,180
password one uses a different amount of

168
00:08:16,150 --> 00:08:22,690
iteration so I know that password is not

169
00:08:19,180 --> 00:08:26,979
a news but there's still a lot of other

170
00:08:22,690 --> 00:08:28,719
possible passwords that remain so how

171
00:08:26,979 --> 00:08:31,659
can I gain more information as an

172
00:08:28,719 --> 00:08:33,578
adversary well remember that this

173
00:08:31,659 --> 00:08:36,519
algorithm here depends on the MAC

174
00:08:33,578 --> 00:08:39,098
address of both the clients and the

175
00:08:36,519 --> 00:08:41,110
access point so I can just spoof a

176
00:08:39,099 --> 00:08:43,510
different clients MAC address I can

177
00:08:41,110 --> 00:08:45,910
again measure how many iterations are

178
00:08:43,510 --> 00:08:49,569
needed and I can just repeat this

179
00:08:45,910 --> 00:08:51,670
process so here in my example passwords

180
00:08:49,570 --> 00:08:55,449
to would use a different amount of

181
00:08:51,670 --> 00:08:57,310
iterations if I spoof clients address B

182
00:08:55,449 --> 00:09:00,430
so I can again include X

183
00:08:57,310 --> 00:09:04,750
clewd dis passwords and I can keep doing

184
00:09:00,430 --> 00:09:08,079
this for another mac address and so on

185
00:09:04,750 --> 00:09:12,640
until I uniquely identifies the password

186
00:09:08,080 --> 00:09:14,770
in my dictionary to give you an idea how

187
00:09:12,640 --> 00:09:18,339
many MAC addresses you need to spoof for

188
00:09:14,770 --> 00:09:21,370
this let's say you use the RockYou data

189
00:09:18,339 --> 00:09:24,580
by a password dump then you need to

190
00:09:21,370 --> 00:09:28,510
spoof around 17 MAC addresses to be able

191
00:09:24,580 --> 00:09:33,700
to uniquely recover the password so

192
00:09:28,510 --> 00:09:36,520
that's not too much the main takeaway

193
00:09:33,700 --> 00:09:39,460
lesson here is that the amount of

194
00:09:36,520 --> 00:09:42,550
iterations that are needed to convert a

195
00:09:39,460 --> 00:09:45,100
password into this mod P elements if you

196
00:09:42,550 --> 00:09:46,900
measure that this for several MAC

197
00:09:45,100 --> 00:09:48,790
addresses then you essentially have a

198
00:09:46,900 --> 00:09:53,770
signature of the password which you can

199
00:09:48,790 --> 00:09:55,810
use an offline brute-force attacks and

200
00:09:53,770 --> 00:09:58,000
there's one thing I haven't discussed

201
00:09:55,810 --> 00:10:00,699
here yet and that is is making these

202
00:09:58,000 --> 00:10:02,650
timing measurements feasible in practice

203
00:10:00,700 --> 00:10:05,680
can I really determine how many

204
00:10:02,650 --> 00:10:09,250
iterations that make that for example

205
00:10:05,680 --> 00:10:12,040
the access point is executing so we try

206
00:10:09,250 --> 00:10:15,700
this in practice what we did is we took

207
00:10:12,040 --> 00:10:17,920
a Raspberry Pi one and the reason why we

208
00:10:15,700 --> 00:10:21,339
took a Raspberry Pi one is because its

209
00:10:17,920 --> 00:10:24,400
CPU is similar to home routers and even

210
00:10:21,339 --> 00:10:27,520
similar to some professional access

211
00:10:24,400 --> 00:10:30,310
points on this Raspberry Pi

212
00:10:27,520 --> 00:10:33,430
we ran host APD as the access point

213
00:10:30,310 --> 00:10:35,500
which is the most widely used software

214
00:10:33,430 --> 00:10:38,020
for Wi-Fi access points it's using home

215
00:10:35,500 --> 00:10:41,410
routers using even quite some

216
00:10:38,020 --> 00:10:45,660
professional access points so that is

217
00:10:41,410 --> 00:10:48,850
the setup we used and we noticed that

218
00:10:45,660 --> 00:10:52,540
measuring the number of iterations is

219
00:10:48,850 --> 00:10:55,650
quite feasible under this setup to give

220
00:10:52,540 --> 00:10:59,140
you a concrete number if we make around

221
00:10:55,650 --> 00:11:01,360
75 timing measurements per MAC address

222
00:10:59,140 --> 00:11:04,209
we're able to determine how many

223
00:11:01,360 --> 00:11:09,120
iterations that the access points need

224
00:11:04,209 --> 00:11:10,959
it so that's quite feasible in practice

225
00:11:09,120 --> 00:11:12,880
now

226
00:11:10,960 --> 00:11:15,120
recall that in the beginning of the talk

227
00:11:12,880 --> 00:11:17,860
I said that we can use multiple groups

228
00:11:15,120 --> 00:11:21,070
but that the handshake can also be used

229
00:11:17,860 --> 00:11:22,510
using elliptic curves now I guess for

230
00:11:21,070 --> 00:11:25,779
this audience I don't really need to

231
00:11:22,510 --> 00:11:29,290
introduce elliptic curves basically all

232
00:11:25,779 --> 00:11:32,649
operations happen on a point x and y X&Y

233
00:11:29,290 --> 00:11:35,199
have to satisfy a certain formula the

234
00:11:32,649 --> 00:11:37,990
real question here is how can we convert

235
00:11:35,200 --> 00:11:40,750
the password to a point on the elliptic

236
00:11:37,990 --> 00:11:41,740
curve so that we can then use this point

237
00:11:40,750 --> 00:11:47,020
on the elliptic curve for our

238
00:11:41,740 --> 00:11:50,890
cryptographic operations well initially

239
00:11:47,020 --> 00:11:55,270
they proposed a very similar algorithm

240
00:11:50,890 --> 00:11:57,640
to the one for mod P groups namely we

241
00:11:55,270 --> 00:11:59,649
again have a loop here with a counter we

242
00:11:57,640 --> 00:12:01,569
calculate a hash based on the counter of

243
00:11:59,649 --> 00:12:03,640
the MAC addresses the result is

244
00:12:01,570 --> 00:12:06,160
interpreted as the xre as the

245
00:12:03,640 --> 00:12:08,500
x-coordinate and then we simply see if

246
00:12:06,160 --> 00:12:11,140
there is a solution for the y-coordinate

247
00:12:08,500 --> 00:12:13,450
and about half of the times there is

248
00:12:11,140 --> 00:12:15,810
indeed a solution for y aunt we have

249
00:12:13,450 --> 00:12:19,630
found two points on the elliptic curve

250
00:12:15,810 --> 00:12:21,520
now here you can see that we again have

251
00:12:19,630 --> 00:12:24,100
exactly the same problem the amount of

252
00:12:21,520 --> 00:12:28,360
iterations depends on the password being

253
00:12:24,100 --> 00:12:31,150
used unfortunately for the EPW D

254
00:12:28,360 --> 00:12:34,270
protocol which remember it's used in

255
00:12:31,150 --> 00:12:36,220
certain enterprise Wi-Fi networks there

256
00:12:34,270 --> 00:12:41,890
are no defenses against this timing leak

257
00:12:36,220 --> 00:12:45,550
at all what's interesting is that for

258
00:12:41,890 --> 00:12:49,120
WPA 3 they did realize there would be a

259
00:12:45,550 --> 00:12:51,849
timing league here so for WPA 3 they

260
00:12:49,120 --> 00:12:55,300
decided to simply execute this loop

261
00:12:51,850 --> 00:12:58,950
always 40 times unless just ignore the

262
00:12:55,300 --> 00:13:02,140
computational overhead that is causes

263
00:12:58,950 --> 00:13:05,260
they decided to implement this defense

264
00:13:02,140 --> 00:13:08,439
here and what's a bit surprising here is

265
00:13:05,260 --> 00:13:10,329
that in the case of elliptic curves they

266
00:13:08,440 --> 00:13:13,589
have this defense against timing leaks

267
00:13:10,329 --> 00:13:15,969
where they just always do 40 iterations

268
00:13:13,589 --> 00:13:20,410
independent of when the password element

269
00:13:15,970 --> 00:13:22,720
was found while for the mod P case they

270
00:13:20,410 --> 00:13:25,379
don't they didn't have this defense so

271
00:13:22,720 --> 00:13:30,040
that's that's quite surprising

272
00:13:25,379 --> 00:13:31,660
okay so we have this defense and there's

273
00:13:30,040 --> 00:13:33,910
one more thing I need to mention here

274
00:13:31,660 --> 00:13:36,759
and in my opinion it's a bit of a

275
00:13:33,910 --> 00:13:39,339
leftover of discussions that they had

276
00:13:36,759 --> 00:13:42,160
about this algorithm and this is that

277
00:13:39,339 --> 00:13:45,819
for the extra iterations that are being

278
00:13:42,160 --> 00:13:47,709
performed to reach 40 iterations they do

279
00:13:45,819 --> 00:13:51,579
these iterations based on a random

280
00:13:47,709 --> 00:13:55,359
password so once we have an X on that we

281
00:13:51,579 --> 00:13:57,628
have a solution for y we now do extra

282
00:13:55,360 --> 00:14:00,189
iterations based on a random passwords

283
00:13:57,629 --> 00:14:07,060
and you can just consider that to be a

284
00:14:00,189 --> 00:14:08,949
defense in depth so far this algorithm

285
00:14:07,060 --> 00:14:11,349
would actually be fine and if we use

286
00:14:08,949 --> 00:14:14,740
nist curves there would be no timing

287
00:14:11,350 --> 00:14:17,829
leaks but there's one problem and that

288
00:14:14,740 --> 00:14:20,949
is that WPA 3 also explicitly supports

289
00:14:17,829 --> 00:14:23,529
brain pool curse what's the problem with

290
00:14:20,949 --> 00:14:26,050
brain pool curse there again we have the

291
00:14:23,529 --> 00:14:29,199
case that the results here of our hash

292
00:14:26,050 --> 00:14:31,508
hash function the x value it has a high

293
00:14:29,199 --> 00:14:34,199
probability of being bigger than the

294
00:14:31,509 --> 00:14:37,060
prime being used by our elliptic curves

295
00:14:34,199 --> 00:14:37,660
ons you can maybe see where this is

296
00:14:37,060 --> 00:14:41,109
going

297
00:14:37,660 --> 00:14:44,259
they decided to handle this the same way

298
00:14:41,110 --> 00:14:46,720
as with mod P groups if X is bigger than

299
00:14:44,259 --> 00:14:49,560
the prime we just increase the counter

300
00:14:46,720 --> 00:14:49,560
and try again

301
00:14:50,339 --> 00:14:56,439
now here we still do these 40 iterations

302
00:14:53,620 --> 00:14:59,740
even in this case but still there's a

303
00:14:56,439 --> 00:15:02,500
problem here because if X is smaller

304
00:14:59,740 --> 00:15:05,019
than P then this code here is skipped on

305
00:15:02,500 --> 00:15:06,790
in particular the amount of times that

306
00:15:05,019 --> 00:15:09,819
this code is skipped again depends on

307
00:15:06,790 --> 00:15:12,670
the passwords there's one catch that

308
00:15:09,819 --> 00:15:14,949
makes this a bit more a bit harder to

309
00:15:12,670 --> 00:15:17,349
exploit in practice because the amount

310
00:15:14,949 --> 00:15:20,199
of times that this code is skipped also

311
00:15:17,350 --> 00:15:23,680
depends on our random password that is

312
00:15:20,199 --> 00:15:28,660
used in the extra iterations so that

313
00:15:23,680 --> 00:15:31,839
adds a bit of complexity but this still

314
00:15:28,660 --> 00:15:34,600
leaks information because the variance

315
00:15:31,839 --> 00:15:37,980
of the execution time depends on when

316
00:15:34,600 --> 00:15:37,980
the password element was found

317
00:15:38,140 --> 00:15:42,579
for example if the password element was

318
00:15:40,240 --> 00:15:45,250
found here in the last iteration then

319
00:15:42,579 --> 00:15:47,140
there are no extra iterations based on a

320
00:15:45,250 --> 00:15:50,110
random password so there's basically

321
00:15:47,140 --> 00:15:51,579
zero variance if the passwords element

322
00:15:50,110 --> 00:15:53,640
is immediately found there are a lot of

323
00:15:51,579 --> 00:15:58,000
iterations based on a random password

324
00:15:53,640 --> 00:16:00,149
meaning there's a lot of variants on top

325
00:15:58,000 --> 00:16:02,470
of that the average also still leaks

326
00:16:00,149 --> 00:16:08,370
information as well because that just

327
00:16:02,470 --> 00:16:11,589
average averages out this random noise

328
00:16:08,370 --> 00:16:14,500
so now the question here again is is

329
00:16:11,589 --> 00:16:16,570
this are these timing differences

330
00:16:14,500 --> 00:16:19,839
measurable in practice

331
00:16:16,570 --> 00:16:23,560
and without going into too much detail

332
00:16:19,839 --> 00:16:25,779
yes this is the case but these timing

333
00:16:23,560 --> 00:16:29,680
measurements are a bit smaller than with

334
00:16:25,779 --> 00:16:32,290
a mod P example that we had on here we

335
00:16:29,680 --> 00:16:36,339
need about 300 measurements per MAC

336
00:16:32,290 --> 00:16:39,550
address to gain useful information as an

337
00:16:36,339 --> 00:16:41,829
attacker the resulting timing

338
00:16:39,550 --> 00:16:43,899
measurements they can again be abused in

339
00:16:41,829 --> 00:16:46,000
a similar way they form a signature of

340
00:16:43,899 --> 00:16:50,199
the password and we can use this

341
00:16:46,000 --> 00:16:56,980
signature in offline dictionary or brute

342
00:16:50,199 --> 00:16:59,949
force attacks so this covers the timing

343
00:16:56,980 --> 00:17:03,790
attacks now apart from that we also

344
00:16:59,949 --> 00:17:09,220
looked at other side channels namely

345
00:17:03,790 --> 00:17:12,389
cache attack side channels so another

346
00:17:09,220 --> 00:17:16,750
way to attack this algorithm and to know

347
00:17:12,390 --> 00:17:20,949
when the password element is find it is

348
00:17:16,750 --> 00:17:22,869
found is two I'm simplifying a bit here

349
00:17:20,949 --> 00:17:26,980
but basically we can use flash and

350
00:17:22,869 --> 00:17:30,939
reload to detect when a solution for Y

351
00:17:26,980 --> 00:17:33,549
has been found now there is one thing

352
00:17:30,940 --> 00:17:36,190
that makes this that makes this a bit

353
00:17:33,549 --> 00:17:38,620
more tricky is that we also need to know

354
00:17:36,190 --> 00:17:40,660
in which iteration this was found so we

355
00:17:38,620 --> 00:17:43,000
don't just want to know is this code

356
00:17:40,660 --> 00:17:46,300
executed we want to know in which

357
00:17:43,000 --> 00:17:49,210
iteration was this executed and in our

358
00:17:46,300 --> 00:17:51,430
specific example that we tried we wanted

359
00:17:49,210 --> 00:17:52,930
to know is this executed and

360
00:17:51,430 --> 00:17:56,800
we have a solution here in the first

361
00:17:52,930 --> 00:18:00,040
iteration or not I'm to able to be able

362
00:17:56,800 --> 00:18:02,649
to determine this we also used a cache

363
00:18:00,040 --> 00:18:05,710
attack basically to monitor when this

364
00:18:02,650 --> 00:18:07,930
hash function here is being called so in

365
00:18:05,710 --> 00:18:10,060
a sense we monitor when this hash

366
00:18:07,930 --> 00:18:13,360
function is being called sort of as a

367
00:18:10,060 --> 00:18:17,800
clock to determine in which iteration we

368
00:18:13,360 --> 00:18:20,439
are and we can do the similar thing for

369
00:18:17,800 --> 00:18:23,889
brain pull curves we can also try to

370
00:18:20,440 --> 00:18:27,370
find out when here the x value is bigger

371
00:18:23,890 --> 00:18:29,290
or smaller than P by monitoring when

372
00:18:27,370 --> 00:18:32,610
this function here is being executed

373
00:18:29,290 --> 00:18:36,730
that checks if there is a solution for y

374
00:18:32,610 --> 00:18:39,879
so for brain pokers we roughly have a

375
00:18:36,730 --> 00:18:44,350
similar cache attack these cache attacks

376
00:18:39,880 --> 00:18:48,670
are fairly reliable in practice the ones

377
00:18:44,350 --> 00:18:50,860
that we use now these attacks do require

378
00:18:48,670 --> 00:18:52,630
more powerful adversary than the timing

379
00:18:50,860 --> 00:18:56,560
attacks we need to be able to run

380
00:18:52,630 --> 00:18:59,920
unprivileged codes on either the machine

381
00:18:56,560 --> 00:19:02,139
or the victim that's still quite

382
00:18:59,920 --> 00:19:05,890
feasible we can for example imagine a

383
00:19:02,140 --> 00:19:07,990
malicious Android executable or some

384
00:19:05,890 --> 00:19:10,390
previous Worx have shown that at least

385
00:19:07,990 --> 00:19:13,180
on older browsers this may be possible

386
00:19:10,390 --> 00:19:16,000
even from JavaScript so against the

387
00:19:13,180 --> 00:19:19,750
client I think this is a realistic

388
00:19:16,000 --> 00:19:22,210
scenario in theory this would also be

389
00:19:19,750 --> 00:19:24,070
possible against the access points but

390
00:19:22,210 --> 00:19:28,830
against an access point it may be more

391
00:19:24,070 --> 00:19:32,020
difficult to run malicious codes on that

392
00:19:28,830 --> 00:19:34,929
may be the one exception here is is if

393
00:19:32,020 --> 00:19:40,900
you set up a hotspot on your phone then

394
00:19:34,930 --> 00:19:43,930
it would still be feasible now the

395
00:19:40,900 --> 00:19:47,170
information that is leaked here in our

396
00:19:43,930 --> 00:19:49,900
cache attacks we can use this well it

397
00:19:47,170 --> 00:19:52,180
again forms a signature of the password

398
00:19:49,900 --> 00:19:54,880
basically just like the example we had

399
00:19:52,180 --> 00:19:58,150
previously on the signature can be used

400
00:19:54,880 --> 00:20:02,010
to partition a dictionary onto them

401
00:19:58,150 --> 00:20:04,840
uniquely recover the password once again

402
00:20:02,010 --> 00:20:05,230
so that's actually quite interesting

403
00:20:04,840 --> 00:20:07,330
because

404
00:20:05,230 --> 00:20:09,850
for both the timing attack on the cache

405
00:20:07,330 --> 00:20:12,428
attack the result is a signature of the

406
00:20:09,850 --> 00:20:14,469
password and this signature is used in a

407
00:20:12,429 --> 00:20:16,809
brute-force algorithm and in fact it's

408
00:20:14,470 --> 00:20:19,720
used and almost exactly the same route

409
00:20:16,809 --> 00:20:22,660
force algorithm so it makes a lot of

410
00:20:19,720 --> 00:20:24,910
sense to optimize the brute force the

411
00:20:22,660 --> 00:20:27,130
dictionary attack algorithm and see how

412
00:20:24,910 --> 00:20:30,630
efficient these attacks really are in

413
00:20:27,130 --> 00:20:33,190
practice so what we did is we

414
00:20:30,630 --> 00:20:36,429
implemented the brute force on the

415
00:20:33,190 --> 00:20:39,130
dictionary attacks on GPU code and we

416
00:20:36,429 --> 00:20:41,799
found that if we want to brute force 10

417
00:20:39,130 --> 00:20:44,770
to the power 10 passwords or a

418
00:20:41,799 --> 00:20:50,260
dictionary of that side size we need

419
00:20:44,770 --> 00:20:53,168
less than $1 in Amazon ec2 instances now

420
00:20:50,260 --> 00:20:56,830
to give you some intuitive idea about

421
00:20:53,169 --> 00:21:00,190
this number here this is bigger than all

422
00:20:56,830 --> 00:21:01,899
possible dictionaries or password dumps

423
00:21:00,190 --> 00:21:04,179
that you can find it's bigger than the

424
00:21:01,900 --> 00:21:05,919
rock you dump it's bigger than all the

425
00:21:04,179 --> 00:21:07,390
passwords on have I been pwned

426
00:21:05,919 --> 00:21:10,120
it's bigger than an English dictionary

427
00:21:07,390 --> 00:21:12,910
so if you have a dictionary you can

428
00:21:10,120 --> 00:21:15,178
brute force it using a dollar at least

429
00:21:12,910 --> 00:21:20,380
if your timing attack or cache attack

430
00:21:15,179 --> 00:21:23,770
succeeded so that's quite a low amount

431
00:21:20,380 --> 00:21:25,690
of money so we thought okay how about

432
00:21:23,770 --> 00:21:27,850
instead of just dictionary attacks we

433
00:21:25,690 --> 00:21:31,210
also look at the complexity of full

434
00:21:27,850 --> 00:21:35,049
brute-force attacks so let's try to

435
00:21:31,210 --> 00:21:38,790
brute force all passwords of 8

436
00:21:35,049 --> 00:21:41,590
characters over all possible symbols

437
00:21:38,790 --> 00:21:44,740
well it turns out that if we then want

438
00:21:41,590 --> 00:21:48,639
to attack mod P or brain pool groups

439
00:21:44,740 --> 00:21:51,460
this costs about $70 which is quite

440
00:21:48,640 --> 00:21:55,679
cheap in my opinion if we want to attack

441
00:21:51,460 --> 00:21:58,000
NIST curse then the brute force

442
00:21:55,679 --> 00:21:59,980
calculations is a bit more expensive

443
00:21:58,000 --> 00:22:02,350
because we have to check whether it is

444
00:21:59,980 --> 00:22:06,700
there is a solution for Y which is a bit

445
00:22:02,350 --> 00:22:09,730
more costly than checking the case for

446
00:22:06,700 --> 00:22:11,620
the mod P on brain pokers and practice

447
00:22:09,730 --> 00:22:14,140
this means that the cost is higher if

448
00:22:11,620 --> 00:22:18,729
this curve is being used so that would

449
00:22:14,140 --> 00:22:20,680
cost about $14,000 it's a lot more

450
00:22:18,730 --> 00:22:24,340
considering that you know this is a pro

451
00:22:20,680 --> 00:22:27,460
this is a encryption protocol that has

452
00:22:24,340 --> 00:22:29,679
very recently been proposed this is

453
00:22:27,460 --> 00:22:33,730
quite a low amount for a modern protocol

454
00:22:29,680 --> 00:22:38,050
to be broken that easily if you want to

455
00:22:33,730 --> 00:22:40,420
know more details about how we estimated

456
00:22:38,050 --> 00:22:44,649
this or if you want to know the results

457
00:22:40,420 --> 00:22:46,750
for other sizes I refer to the paper

458
00:22:44,650 --> 00:22:50,740
where we analyzed this in a bit more

459
00:22:46,750 --> 00:22:54,760
detail okay

460
00:22:50,740 --> 00:22:57,340
so let's recap a bit so far we've had

461
00:22:54,760 --> 00:22:59,680
side-channel attacks we've had timing

462
00:22:57,340 --> 00:23:03,010
attacks where they were actually warned

463
00:22:59,680 --> 00:23:05,110
about his timing attacks yet they didn't

464
00:23:03,010 --> 00:23:06,700
defend against them properly we have new

465
00:23:05,110 --> 00:23:10,990
timing attacks against the brain pool

466
00:23:06,700 --> 00:23:12,790
case we have cache attacks on top of

467
00:23:10,990 --> 00:23:14,530
that we're now also going to discuss

468
00:23:12,790 --> 00:23:18,550
some implementation specific

469
00:23:14,530 --> 00:23:21,270
vulnerabilities as well and the first

470
00:23:18,550 --> 00:23:22,690
one that I want to discuss is an invalid

471
00:23:21,270 --> 00:23:25,840
perfect ACK

472
00:23:22,690 --> 00:23:29,380
so let's say we have the following

473
00:23:25,840 --> 00:23:33,220
situation we have an access point here

474
00:23:29,380 --> 00:23:35,530
that we want to attack and we as an

475
00:23:33,220 --> 00:23:38,620
adversary are going to send a commit

476
00:23:35,530 --> 00:23:40,360
frame and this commit frame contains a

477
00:23:38,620 --> 00:23:42,669
point on the elliptic curve but as an

478
00:23:40,360 --> 00:23:45,360
attacker we can decide to send actually

479
00:23:42,670 --> 00:23:47,560
a coordinate that's not on the curve

480
00:23:45,360 --> 00:23:51,159
normally the access point is supposed to

481
00:23:47,560 --> 00:23:55,179
detect this but if it doesn't we can

482
00:23:51,160 --> 00:23:58,120
carefully pick the x and y values to

483
00:23:55,180 --> 00:24:02,200
make sure that the secret key that is

484
00:23:58,120 --> 00:24:03,639
being negotiated is very predictable so

485
00:24:02,200 --> 00:24:05,740
if the access point doesn't check

486
00:24:03,640 --> 00:24:08,200
whether x and y is on the is on the

487
00:24:05,740 --> 00:24:11,110
curve the negotiated key is predictable

488
00:24:08,200 --> 00:24:13,030
the access point won't realize this and

489
00:24:11,110 --> 00:24:17,649
it will just continue executing the

490
00:24:13,030 --> 00:24:20,230
handshake now in our specific case we

491
00:24:17,650 --> 00:24:23,890
can actually guess the negotiated key

492
00:24:20,230 --> 00:24:26,980
here with roughly 66 percent chance of

493
00:24:23,890 --> 00:24:29,340
having it right so we can guess this key

494
00:24:26,980 --> 00:24:31,460
and then just try to complete the

495
00:24:29,340 --> 00:24:34,230
and shake and if our guess was correct

496
00:24:31,460 --> 00:24:36,120
we successfully authenticated with the

497
00:24:34,230 --> 00:24:38,330
network on we're essentially

498
00:24:36,120 --> 00:24:40,830
impersonating a client

499
00:24:38,330 --> 00:24:45,240
so which implementations were vulnerable

500
00:24:40,830 --> 00:24:47,760
to this well we have all it pwt

501
00:24:45,240 --> 00:24:51,240
implementations that were vulnerable so

502
00:24:47,760 --> 00:24:54,690
this is free radius this is hostapd this

503
00:24:51,240 --> 00:24:59,670
is commercial clients every single one

504
00:24:54,690 --> 00:25:03,770
that we tested was vulnerable with WPA

505
00:24:59,670 --> 00:25:06,060
three we were able to test some early

506
00:25:03,770 --> 00:25:08,370
implementations onto open source ones

507
00:25:06,060 --> 00:25:10,710
and there the situation at least

508
00:25:08,370 --> 00:25:15,449
initially seems a lot better because

509
00:25:10,710 --> 00:25:19,140
they're only IWD is vulnerable on i WDS

510
00:25:15,450 --> 00:25:25,980
in relatively recent open source Wi-Fi

511
00:25:19,140 --> 00:25:28,740
clients for linux so i'm not going to go

512
00:25:25,980 --> 00:25:31,680
into detail here how this invalid curved

513
00:25:28,740 --> 00:25:34,620
attack works in detail how the x and y

514
00:25:31,680 --> 00:25:36,210
spec there's a talk after this which the

515
00:25:34,620 --> 00:25:37,800
Bluetooth one which I think goes into

516
00:25:36,210 --> 00:25:40,230
more detail about invalid curse attacks

517
00:25:37,800 --> 00:25:44,340
as well so I'm just going to keep it at

518
00:25:40,230 --> 00:25:49,160
this high level another attack I instead

519
00:25:44,340 --> 00:25:53,250
want to discuss is a reflection attack

520
00:25:49,160 --> 00:25:56,460
in this case I'm not going to assume we

521
00:25:53,250 --> 00:25:58,470
were attacking WPA three in the example

522
00:25:56,460 --> 00:26:05,280
diagram here I assume that we're going

523
00:25:58,470 --> 00:26:08,310
to attack EP WD now why am I taking it

524
00:26:05,280 --> 00:26:12,389
PWD as a specific example here well

525
00:26:08,310 --> 00:26:14,669
that's because with EP WD the dragonfly

526
00:26:12,390 --> 00:26:17,700
handshake is initiated by the access

527
00:26:14,670 --> 00:26:19,440
point while with WPA three the dragonfly

528
00:26:17,700 --> 00:26:22,680
handshake is initiated by the clients

529
00:26:19,440 --> 00:26:23,400
and in this case we can do something

530
00:26:22,680 --> 00:26:26,580
interesting

531
00:26:23,400 --> 00:26:29,220
namely we can first go through the Wi-Fi

532
00:26:26,580 --> 00:26:32,040
Association stage the access point will

533
00:26:29,220 --> 00:26:35,070
then send the commit frame and we as an

534
00:26:32,040 --> 00:26:37,950
attacker can just reflect exactly the

535
00:26:35,070 --> 00:26:42,320
same frame back to the access point with

536
00:26:37,950 --> 00:26:44,420
some minor changes if the access point

537
00:26:42,320 --> 00:26:46,610
doesn't realize that this is a reflected

538
00:26:44,420 --> 00:26:49,430
flame frame it will simply continue the

539
00:26:46,610 --> 00:26:51,469
handshake we can also then reflect the

540
00:26:49,430 --> 00:26:53,690
confirm phrase and we can then

541
00:26:51,470 --> 00:26:56,120
successfully complete the handshake

542
00:26:53,690 --> 00:27:01,010
without knowing anything simply by

543
00:26:56,120 --> 00:27:04,399
reflecting these messages and this is in

544
00:27:01,010 --> 00:27:07,550
a sense a very basic attack because we

545
00:27:04,400 --> 00:27:10,070
can fool the access point into thinking

546
00:27:07,550 --> 00:27:13,310
that a certain user authenticated with

547
00:27:10,070 --> 00:27:15,470
the network now we won't be able to

548
00:27:13,310 --> 00:27:17,360
reveal the session key that is being

549
00:27:15,470 --> 00:27:20,480
negotiated here so we cannot send

550
00:27:17,360 --> 00:27:23,300
clients so we cannot send traffic as the

551
00:27:20,480 --> 00:27:25,430
victim here but in certain cases this

552
00:27:23,300 --> 00:27:27,680
might still be useful for example you

553
00:27:25,430 --> 00:27:29,510
can imagine a case where if a user

554
00:27:27,680 --> 00:27:32,450
successfully connect student to the

555
00:27:29,510 --> 00:27:36,440
network then maybe run some script or

556
00:27:32,450 --> 00:27:40,160
unlocked some device so admittedly this

557
00:27:36,440 --> 00:27:43,990
is a bit of an edge case but in certain

558
00:27:40,160 --> 00:27:46,870
cases this might still be a risk

559
00:27:43,990 --> 00:27:49,100
normally implementations are supposed to

560
00:27:46,870 --> 00:27:52,070
detectives they are supposed to check

561
00:27:49,100 --> 00:27:57,560
whether this x and y is the same one as

562
00:27:52,070 --> 00:27:59,540
that the access point just sent now here

563
00:27:57,560 --> 00:28:03,470
we have a bit of a similar story as

564
00:27:59,540 --> 00:28:06,770
before all if PWD implementations are

565
00:28:03,470 --> 00:28:10,010
vulnerable while with WPA 3 the

566
00:28:06,770 --> 00:28:14,210
situation is a bit better with wk3 only

567
00:28:10,010 --> 00:28:15,530
all WPS applicants are affected but this

568
00:28:14,210 --> 00:28:20,210
is a bit of a common theme that we

569
00:28:15,530 --> 00:28:24,649
noticed namely each PWD the security of

570
00:28:20,210 --> 00:28:31,310
its implementations is a bit shaky in

571
00:28:24,650 --> 00:28:33,100
practice so we actually have even more

572
00:28:31,310 --> 00:28:36,679
we checked for more implementation

573
00:28:33,100 --> 00:28:38,360
vulnerabilities as well and another

574
00:28:36,680 --> 00:28:42,500
interesting one that I want to highlight

575
00:28:38,360 --> 00:28:45,949
here is that we noticed one client it's

576
00:28:42,500 --> 00:28:49,640
an e p-- PWD clients that used bad

577
00:28:45,950 --> 00:28:51,680
randomness in particular generated

578
00:28:49,640 --> 00:28:55,220
random numbers based on the system time

579
00:28:51,680 --> 00:28:56,200
on some other inputs but basically we

580
00:28:55,220 --> 00:29:00,340
could predict around

581
00:28:56,200 --> 00:29:04,480
numbers that was going to use what's

582
00:29:00,340 --> 00:29:06,399
interesting about dragonfly is that if

583
00:29:04,480 --> 00:29:09,639
we can predict the random numbers that a

584
00:29:06,399 --> 00:29:13,059
certain clients or peer is using we can

585
00:29:09,639 --> 00:29:15,219
recover the password element P and then

586
00:29:13,059 --> 00:29:18,190
we can impersonate either the clients or

587
00:29:15,220 --> 00:29:22,090
the access point so if bad randomness is

588
00:29:18,190 --> 00:29:27,850
used the impact is catastrophic and we

589
00:29:22,090 --> 00:29:30,428
noticed this in one case but my hunch is

590
00:29:27,850 --> 00:29:32,769
that in practice this might also occur

591
00:29:30,429 --> 00:29:36,460
on other devices for example if you have

592
00:29:32,769 --> 00:29:39,370
a cheap IOT Wi-Fi device it may not have

593
00:29:36,460 --> 00:29:42,240
the best source of randomness so I think

594
00:29:39,370 --> 00:29:45,549
this might be a risk in practice and

595
00:29:42,240 --> 00:29:47,830
what's interesting here as well is that

596
00:29:45,549 --> 00:29:53,200
the impact of bad randomness is actually

597
00:29:47,830 --> 00:29:55,449
worse with WPA 3 than with wpa2 because

598
00:29:53,200 --> 00:29:58,299
with wpa2 if you have bad randomness

599
00:29:55,450 --> 00:30:01,690
there at worse what you can do is a key

600
00:29:58,299 --> 00:30:03,220
reinstallation attack or you might when

601
00:30:01,690 --> 00:30:05,080
you want to do a dictionary attack you

602
00:30:03,220 --> 00:30:07,210
can already do some pre computations

603
00:30:05,080 --> 00:30:09,220
before you carry out the attack but in

604
00:30:07,210 --> 00:30:15,220
general the impact of bad randomness is

605
00:30:09,220 --> 00:30:17,230
worse with WPA 3 one final

606
00:30:15,220 --> 00:30:21,460
implementation flaw that I want to

607
00:30:17,230 --> 00:30:25,059
discuss is it's actually a side channel

608
00:30:21,460 --> 00:30:28,720
but a bit of an implementation specific

609
00:30:25,059 --> 00:30:32,500
side Channel it has a bit of an

610
00:30:28,720 --> 00:30:35,320
interesting history recall that in the

611
00:30:32,500 --> 00:30:37,419
beginning of the presentation we had

612
00:30:35,320 --> 00:30:40,510
this algorithm that converted the

613
00:30:37,419 --> 00:30:45,220
passwords into a group element of the

614
00:30:40,510 --> 00:30:48,490
crypto group initially EPW D didn't had

615
00:30:45,220 --> 00:30:51,340
a timing leak defense against this but

616
00:30:48,490 --> 00:30:53,110
after a while implementers did realize

617
00:30:51,340 --> 00:30:55,178
that this was a problem and they decided

618
00:30:53,110 --> 00:30:58,539
to try to implement some countermeasures

619
00:30:55,179 --> 00:31:01,539
measure against this and what free

620
00:30:58,539 --> 00:31:06,309
radius decided to do was okay

621
00:31:01,539 --> 00:31:08,049
let's always do at least no actually I

622
00:31:06,309 --> 00:31:09,970
think they had no defense against this

623
00:31:08,049 --> 00:31:12,970
they just tried to

624
00:31:09,970 --> 00:31:15,370
finds the password element and once it

625
00:31:12,970 --> 00:31:17,860
was found it returns but there was

626
00:31:15,370 --> 00:31:20,649
another problem here that if needed more

627
00:31:17,860 --> 00:31:25,120
than 10 iterations then the handshake

628
00:31:20,650 --> 00:31:31,180
would just abort now that's problematic

629
00:31:25,120 --> 00:31:35,830
because in 1 out of 2048 handshakes you

630
00:31:31,180 --> 00:31:37,840
do need more than 10 iterations so what

631
00:31:35,830 --> 00:31:41,500
can i as an attacker do I can just

632
00:31:37,840 --> 00:31:45,520
initiate about 2,000 handshakes and on

633
00:31:41,500 --> 00:31:48,400
average one of them will fail and if the

634
00:31:45,520 --> 00:31:50,889
handshake then fails I know that okay

635
00:31:48,400 --> 00:31:54,100
that means free radius needed more than

636
00:31:50,890 --> 00:31:55,990
ten iterations and that gives me a lot

637
00:31:54,100 --> 00:31:58,270
of information about the passwords on

638
00:31:55,990 --> 00:32:00,100
that leaked information I can again use

639
00:31:58,270 --> 00:32:03,610
to do a dictionary or a brute force

640
00:32:00,100 --> 00:32:07,270
attack so here against free radius you

641
00:32:03,610 --> 00:32:10,030
didn't even need a timing attack or a

642
00:32:07,270 --> 00:32:12,700
cache attack simply perform about two

643
00:32:10,030 --> 00:32:15,120
thousands and shakes one of them on

644
00:32:12,700 --> 00:32:19,350
average will fail that leaks information

645
00:32:15,120 --> 00:32:19,350
out you can then recover the password

646
00:32:19,680 --> 00:32:25,840
okay so you might think now that we

647
00:32:24,040 --> 00:32:29,320
covered most attacks mean we had side

648
00:32:25,840 --> 00:32:32,800
channels implementation flaws but we're

649
00:32:29,320 --> 00:32:35,409
not quite done one other thing I want to

650
00:32:32,800 --> 00:32:40,260
mention is some risks that are really

651
00:32:35,410 --> 00:32:45,160
specific to Wi-Fi at least in my opinion

652
00:32:40,260 --> 00:32:47,680
the first one is that the access point

653
00:32:45,160 --> 00:32:49,840
here always needs to convert the

654
00:32:47,680 --> 00:32:52,930
password to a group element be when a

655
00:32:49,840 --> 00:32:55,330
client is connecting it cannot do this

656
00:32:52,930 --> 00:32:57,970
computation beforehand because remember

657
00:32:55,330 --> 00:32:59,530
that the P here depends also on the MAC

658
00:32:57,970 --> 00:33:02,440
address of the clients and you don't

659
00:32:59,530 --> 00:33:06,190
notice in advance so every time the

660
00:33:02,440 --> 00:33:08,580
access points notices that a client is

661
00:33:06,190 --> 00:33:11,860
connected it needs to run this algorithm

662
00:33:08,580 --> 00:33:14,530
the problem is this algorithm now if you

663
00:33:11,860 --> 00:33:17,379
implement all the fences needs to

664
00:33:14,530 --> 00:33:19,570
execute sorry 40 iterations all that

665
00:33:17,380 --> 00:33:23,040
every single time and that's a ton of

666
00:33:19,570 --> 00:33:27,389
overhead if you use

667
00:33:23,040 --> 00:33:30,300
elliptic curve of around 500 bit size

668
00:33:27,390 --> 00:33:32,970
then we found this was against a

669
00:33:30,300 --> 00:33:36,210
professional access point that just

670
00:33:32,970 --> 00:33:38,610
recently support a WPA 3 if you make if

671
00:33:36,210 --> 00:33:41,880
you Forge 8 connection attempts per

672
00:33:38,610 --> 00:33:43,560
second then the access point is actually

673
00:33:41,880 --> 00:33:47,550
already fully overloaded and it won't

674
00:33:43,560 --> 00:33:50,490
accept any other WPA 3 handshakes that's

675
00:33:47,550 --> 00:33:54,470
a very low amount if you use a smaller

676
00:33:50,490 --> 00:33:57,090
elliptic curve of 256 bit this is around

677
00:33:54,470 --> 00:33:59,970
70 connection at tablets and then the

678
00:33:57,090 --> 00:34:05,820
access point overloads but it's still

679
00:33:59,970 --> 00:34:10,710
not ideal this is in fact one of the big

680
00:34:05,820 --> 00:34:12,569
issues with dragonfly is that you can

681
00:34:10,710 --> 00:34:14,639
either decide not to perform these

682
00:34:12,570 --> 00:34:17,040
iterations and be vulnerable to timing

683
00:34:14,639 --> 00:34:18,899
links or you can implement these

684
00:34:17,040 --> 00:34:22,790
iterations and then risk denial of

685
00:34:18,899 --> 00:34:25,290
service attacks so now as an implementer

686
00:34:22,790 --> 00:34:27,210
you're always sacrificing something

687
00:34:25,290 --> 00:34:31,429
which indicates that there's really some

688
00:34:27,210 --> 00:34:31,429
design flaws with the handshake here

689
00:34:31,940 --> 00:34:38,940
another Wi-Fi specific attack I want to

690
00:34:34,980 --> 00:34:41,940
mention is that if you want to deploy

691
00:34:38,940 --> 00:34:43,770
WPA 3 not all devices are immediately

692
00:34:41,940 --> 00:34:45,810
going to support it so you want

693
00:34:43,770 --> 00:34:50,100
backwards compatibility it's a usual

694
00:34:45,810 --> 00:34:52,168
story the way that the Wi-Fi lines

695
00:34:50,100 --> 00:34:55,679
suggested to handle the backwards

696
00:34:52,168 --> 00:35:00,150
compatibility problem is to if you set

697
00:34:55,679 --> 00:35:02,790
up an access point to configure WPA 2 &

698
00:35:00,150 --> 00:35:08,730
3 using the same network name and using

699
00:35:02,790 --> 00:35:14,250
the same password unfortunately this is

700
00:35:08,730 --> 00:35:16,290
not a perfect defense because well on

701
00:35:14,250 --> 00:35:20,250
one hand it does prevent some attacks

702
00:35:16,290 --> 00:35:23,160
because let's say I have a client that

703
00:35:20,250 --> 00:35:26,850
supports WPA 3 on an access point that

704
00:35:23,160 --> 00:35:28,259
supports both WPA 2 and 3 if I would

705
00:35:26,850 --> 00:35:31,230
then try to act as a man-in-the-middle

706
00:35:28,260 --> 00:35:33,780
and try to force the client into using

707
00:35:31,230 --> 00:35:37,050
WPA 2 so if I if I would try to

708
00:35:33,780 --> 00:35:39,390
downgrade it the client would actually

709
00:35:37,050 --> 00:35:43,620
detect this attack because a wpa2

710
00:35:39,390 --> 00:35:45,839
handshake does detect down grades which

711
00:35:43,620 --> 00:35:49,500
in this case means that this setup does

712
00:35:45,840 --> 00:35:52,470
provide forward secrecy but there is one

713
00:35:49,500 --> 00:35:55,980
rather big problem and this is that a

714
00:35:52,470 --> 00:35:59,100
partial wpa2 handshake is still executed

715
00:35:55,980 --> 00:36:02,400
on this partial wpa2 handshake is still

716
00:35:59,100 --> 00:36:04,100
sufficient to then perform a dictionary

717
00:36:02,400 --> 00:36:07,320
attack

718
00:36:04,100 --> 00:36:09,690
another works another word words the way

719
00:36:07,320 --> 00:36:12,570
that the Wi-Fi Alliance suggests to

720
00:36:09,690 --> 00:36:14,850
simultaneously use wpa2 and three at the

721
00:36:12,570 --> 00:36:17,360
same time as vulnerable to downgrades

722
00:36:14,850 --> 00:36:22,650
meaning you gain little advantage of

723
00:36:17,360 --> 00:36:24,900
configuring your network in this way so

724
00:36:22,650 --> 00:36:26,700
maybe you are now wondering okay can we

725
00:36:24,900 --> 00:36:27,990
defend against this at all I mean

726
00:36:26,700 --> 00:36:30,240
disabling wpa2

727
00:36:27,990 --> 00:36:34,169
isn't really an option as the at this

728
00:36:30,240 --> 00:36:38,640
time fortunately there is one thing we

729
00:36:34,170 --> 00:36:41,910
can do that is as a client as a client

730
00:36:38,640 --> 00:36:45,629
device we can remember whether an access

731
00:36:41,910 --> 00:36:49,109
point supported WPA 3 in the past and if

732
00:36:45,630 --> 00:36:51,810
so if it previously supported WPA 3 we

733
00:36:49,110 --> 00:36:54,540
do not fall back to wpa2 automatically

734
00:36:51,810 --> 00:36:56,509
unless maybe the user explicitly enters

735
00:36:54,540 --> 00:37:00,330
the passwords again or some other

736
00:36:56,510 --> 00:37:04,170
indication and this is similar to the

737
00:37:00,330 --> 00:37:08,640
trust on first usage of SSH and also

738
00:37:04,170 --> 00:37:11,100
with certificate pinning on HTTPS the

739
00:37:08,640 --> 00:37:14,129
good news is that for example the Google

740
00:37:11,100 --> 00:37:16,470
pixel 3 on the Linux network manager

741
00:37:14,130 --> 00:37:18,000
they have actually implemented this

742
00:37:16,470 --> 00:37:20,279
defense so if you use those devices

743
00:37:18,000 --> 00:37:25,740
you're not vulnerable to downgrade

744
00:37:20,280 --> 00:37:27,710
attacks unfortunately this isn't the

745
00:37:25,740 --> 00:37:32,879
only downgrade attack that there exists

746
00:37:27,710 --> 00:37:34,290
the story goes on recall at the

747
00:37:32,880 --> 00:37:36,570
beginning of the presentation I

748
00:37:34,290 --> 00:37:38,670
mentioned that this handshake can be

749
00:37:36,570 --> 00:37:40,890
used using mod P groups it can be used

750
00:37:38,670 --> 00:37:42,720
using elliptic curves and it can be used

751
00:37:40,890 --> 00:37:48,270
using quite a lot of elliptic curves

752
00:37:42,720 --> 00:37:50,430
actually which make makes you wonder ok

753
00:37:48,270 --> 00:37:51,560
how does it then negotiate which group

754
00:37:50,430 --> 00:37:54,210
do you

755
00:37:51,560 --> 00:37:57,450
well it uses a simple mechanism here

756
00:37:54,210 --> 00:37:59,520
the initiator suggests which group it

757
00:37:57,450 --> 00:38:03,180
wants to use on the responder simply

758
00:37:59,520 --> 00:38:05,940
says yes or no the problem is this

759
00:38:03,180 --> 00:38:09,419
reject message of the responder it can

760
00:38:05,940 --> 00:38:11,400
very easily be spoofed and after the

761
00:38:09,420 --> 00:38:13,860
handshake there is no kind of mechanism

762
00:38:11,400 --> 00:38:15,840
to detect if someone tried to manipulate

763
00:38:13,860 --> 00:38:18,440
or mess with the handshake

764
00:38:15,840 --> 00:38:21,330
so as an attacker all you need to do is

765
00:38:18,440 --> 00:38:25,880
for example Jam a message which is

766
00:38:21,330 --> 00:38:25,880
feasible using cheap Wi-Fi devices

767
00:38:26,270 --> 00:38:32,940
so basically downgrade attacks are quite

768
00:38:29,760 --> 00:38:35,160
easy and this is really a design flaw in

769
00:38:32,940 --> 00:38:38,000
the standard against on all

770
00:38:35,160 --> 00:38:41,220
implementations are vulnerable to this

771
00:38:38,000 --> 00:38:44,490
the only defense against it is to only

772
00:38:41,220 --> 00:38:52,140
use elliptic curves or multiple groups

773
00:38:44,490 --> 00:38:55,080
that you know that are secure yeah okay

774
00:38:52,140 --> 00:38:57,680
so that was down great attack number two

775
00:38:55,080 --> 00:39:01,980
you think there's gonna be a third one

776
00:38:57,680 --> 00:39:04,080
well there is but it's not a downgrade

777
00:39:01,980 --> 00:39:08,100
attack against specification or against

778
00:39:04,080 --> 00:39:12,049
the standard but we also did notice a

779
00:39:08,100 --> 00:39:16,470
downgrade attack against two very recent

780
00:39:12,050 --> 00:39:19,230
implementations of WPA three namely what

781
00:39:16,470 --> 00:39:22,680
we noticed there is if you set up a WPA

782
00:39:19,230 --> 00:39:28,410
three only network and you connect to it

783
00:39:22,680 --> 00:39:30,839
using for example Samsung S 10 then this

784
00:39:28,410 --> 00:39:33,990
Samsung as ten should remember oh I

785
00:39:30,840 --> 00:39:36,720
connected to a WPA three only network so

786
00:39:33,990 --> 00:39:40,049
this password I should use only with WPA

787
00:39:36,720 --> 00:39:42,120
three well it turns out if I set up a

788
00:39:40,050 --> 00:39:45,810
wpa2 network with exactly the same

789
00:39:42,120 --> 00:39:48,330
network name then the Samsung as stand

790
00:39:45,810 --> 00:39:51,090
on the iwd client will use that same

791
00:39:48,330 --> 00:39:53,660
password to connect to wpa2 as well

792
00:39:51,090 --> 00:39:56,940
meaning you have exactly the same issues

793
00:39:53,660 --> 00:39:59,700
now this is just an implementation flaw

794
00:39:56,940 --> 00:40:01,770
it's not a flaw in the standard but it's

795
00:39:59,700 --> 00:40:04,080
still something interesting to highlight

796
00:40:01,770 --> 00:40:06,960
as well

797
00:40:04,080 --> 00:40:09,150
okay so that was quite something but we

798
00:40:06,960 --> 00:40:12,060
finally went through all the attacks

799
00:40:09,150 --> 00:40:14,970
that we found the last thing I briefly

800
00:40:12,060 --> 00:40:18,600
want to discuss is the exclosure process

801
00:40:14,970 --> 00:40:21,089
that we followed and our goal here was

802
00:40:18,600 --> 00:40:24,390
to disclose this as early as possible

803
00:40:21,090 --> 00:40:27,810
with the hope to influence WPA 3 before

804
00:40:24,390 --> 00:40:30,270
it was deployed a bit to our surprise we

805
00:40:27,810 --> 00:40:32,460
were met with some skepticism here

806
00:40:30,270 --> 00:40:34,080
because initially they consider this to

807
00:40:32,460 --> 00:40:36,390
be implementation flaws

808
00:40:34,080 --> 00:40:40,529
the standard is fine we can just patch

809
00:40:36,390 --> 00:40:43,890
implementations on were good there was

810
00:40:40,530 --> 00:40:46,440
even one surprising comments of one

811
00:40:43,890 --> 00:40:48,180
developer who said oh yeah we were

812
00:40:46,440 --> 00:40:50,430
actually aware of one of the downgrade

813
00:40:48,180 --> 00:40:52,799
attacks it was discussed during some

814
00:40:50,430 --> 00:41:01,140
standardization meetings we just forgot

815
00:40:52,800 --> 00:41:04,490
to warn about it ok so what was then the

816
00:41:01,140 --> 00:41:08,879
official reaction of the Wi-Fi Alliance

817
00:41:04,490 --> 00:41:10,910
they privately created security

818
00:41:08,880 --> 00:41:16,380
guidelines on how to properly implement

819
00:41:10,910 --> 00:41:18,420
WPA 3 in those guidelines they set brain

820
00:41:16,380 --> 00:41:22,050
pool curves are perfectly fine to use

821
00:41:18,420 --> 00:41:24,080
you don't need extra defenses but as I

822
00:41:22,050 --> 00:41:27,110
explained earlier in the presentation

823
00:41:24,080 --> 00:41:30,960
even with brain pokers timing leaks on

824
00:41:27,110 --> 00:41:32,490
timing leaks are possible so we actually

825
00:41:30,960 --> 00:41:36,930
had to go through a small second

826
00:41:32,490 --> 00:41:39,870
disclosure to fix the mistake they made

827
00:41:36,930 --> 00:41:41,790
in their security guidelines which they

828
00:41:39,870 --> 00:41:42,569
privately created so this is again also

829
00:41:41,790 --> 00:41:45,690
the same story

830
00:41:42,570 --> 00:41:50,460
don't create guidelines and private ask

831
00:41:45,690 --> 00:41:52,530
for feedback first now even with these

832
00:41:50,460 --> 00:41:56,460
security guidelines of the Wi-Fi lines

833
00:41:52,530 --> 00:41:59,340
there's still two major problems the

834
00:41:56,460 --> 00:42:02,670
first one is that implementing WPA 3

835
00:41:59,340 --> 00:42:04,170
without any possibility of side channels

836
00:42:02,670 --> 00:42:07,140
is extremely hard

837
00:42:04,170 --> 00:42:09,900
I would even compare it to the CBC mode

838
00:42:07,140 --> 00:42:11,819
attacks of TLS where if we keep using

839
00:42:09,900 --> 00:42:15,960
this maybe every year we're gonna find

840
00:42:11,820 --> 00:42:17,730
some new attacks against this another

841
00:42:15,960 --> 00:42:21,630
problematic thing which

842
00:42:17,730 --> 00:42:23,760
already highlighted is that to defend

843
00:42:21,630 --> 00:42:27,570
against timing leaks they currently

844
00:42:23,760 --> 00:42:30,090
suggest using 40 iterations now this is

845
00:42:27,570 --> 00:42:33,810
quite costly especially on low weights

846
00:42:30,090 --> 00:42:36,270
for example IOT devices and you may

847
00:42:33,810 --> 00:42:38,730
think now here that's that's okay I have

848
00:42:36,270 --> 00:42:41,210
a powerful smartphone or laptop I'll be

849
00:42:38,730 --> 00:42:43,200
fine I don't care

850
00:42:41,210 --> 00:42:47,070
unfortunately even if you have a

851
00:42:43,200 --> 00:42:49,589
powerful smartphone or computer the WPA

852
00:42:47,070 --> 00:42:52,859
three handshakes or dragonfly might be

853
00:42:49,590 --> 00:42:55,380
offloaded to the Wi-Fi chip itself which

854
00:42:52,859 --> 00:42:58,020
is again a light lightweight chip so

855
00:42:55,380 --> 00:43:00,780
even if you have a powerful laptop the

856
00:42:58,020 --> 00:43:03,119
Wi-Fi handshake itself is handled using

857
00:43:00,780 --> 00:43:04,680
a lightweight Wi-Fi chip where these

858
00:43:03,119 --> 00:43:10,950
timing attacks might still be feasible

859
00:43:04,680 --> 00:43:13,230
and unfortunately this argument was the

860
00:43:10,950 --> 00:43:17,368
one that convinced offenders the most I

861
00:43:13,230 --> 00:43:18,780
think to update a standard so on one

862
00:43:17,369 --> 00:43:20,550
hand it's good at the standard is being

863
00:43:18,780 --> 00:43:22,350
updated on the other hand I have the

864
00:43:20,550 --> 00:43:26,970
impression that it's mostly done because

865
00:43:22,350 --> 00:43:28,650
of the overhead issues here the good

866
00:43:26,970 --> 00:43:30,930
news is they are updating it

867
00:43:28,650 --> 00:43:33,119
so are they are preventing the group

868
00:43:30,930 --> 00:43:37,759
downgrade attack they are now allowing

869
00:43:33,119 --> 00:43:39,930
to do a large part of this algorithm

870
00:43:37,760 --> 00:43:41,820
that you can execute this when you

871
00:43:39,930 --> 00:43:44,399
configure the password when you enter it

872
00:43:41,820 --> 00:43:49,800
so not so that you have to do a lot less

873
00:43:44,400 --> 00:43:52,050
work for every individual handshake on

874
00:43:49,800 --> 00:43:54,900
top of that for the mod P groups they

875
00:43:52,050 --> 00:43:56,760
are now prohibiting weak groups and they

876
00:43:54,900 --> 00:43:59,010
are moving to a constant time algorithm

877
00:43:56,760 --> 00:44:01,080
to convert the passwords into a group

878
00:43:59,010 --> 00:44:03,240
elements on the same thing is true for

879
00:44:01,080 --> 00:44:05,819
elliptic curves there they are

880
00:44:03,240 --> 00:44:08,459
restricting the use of weak elliptic

881
00:44:05,820 --> 00:44:10,500
curves and they are again using well

882
00:44:08,460 --> 00:44:11,910
they are proposing to use a constant

883
00:44:10,500 --> 00:44:18,000
time algorithm it still has to be

884
00:44:11,910 --> 00:44:21,390
approved so all this might lead to WPA

885
00:44:18,000 --> 00:44:24,359
3.1 it's unclear how this will be

886
00:44:21,390 --> 00:44:27,839
handled because these changes they are

887
00:44:24,359 --> 00:44:31,650
not backwards compatible

888
00:44:27,840 --> 00:44:34,820
now I recently saw some remarks where

889
00:44:31,650 --> 00:44:37,050
it was said that this update might be

890
00:44:34,820 --> 00:44:39,150
seamless to the user that the user might

891
00:44:37,050 --> 00:44:41,310
may not notice a thing about this update

892
00:44:39,150 --> 00:44:42,960
which to me might indicate that there is

893
00:44:41,310 --> 00:44:45,960
a risk of possible downgrade attacks

894
00:44:42,960 --> 00:44:47,790
back to the old WP three it's unclear

895
00:44:45,960 --> 00:44:51,240
how this will be handled that's a

896
00:44:47,790 --> 00:44:53,460
possible risk now there is one last

897
00:44:51,240 --> 00:44:57,089
message I want to give to the ordinary

898
00:44:53,460 --> 00:44:59,720
Wi-Fi users and that's that if WPA 3

899
00:44:57,090 --> 00:45:03,060
comes out I still recommend to use it

900
00:44:59,720 --> 00:45:06,540
because at least for now it still seems

901
00:45:03,060 --> 00:45:09,140
better than wpa2 yes we have the side

902
00:45:06,540 --> 00:45:11,070
channels where we can then use

903
00:45:09,140 --> 00:45:13,770
dictionary attacks on brute force

904
00:45:11,070 --> 00:45:17,160
attacks but it's still harder to do this

905
00:45:13,770 --> 00:45:20,340
attacks with WPA 3 or wpa2 these attacks

906
00:45:17,160 --> 00:45:22,620
are quite easy with WPA 3 it's harder

907
00:45:20,340 --> 00:45:25,290
for example making these timing attacks

908
00:45:22,620 --> 00:45:29,060
it's harder to do that compared to just

909
00:45:25,290 --> 00:45:31,740
passively capturing a wpa2 handshake

910
00:45:29,060 --> 00:45:34,740
so that gets me to the end of the talk

911
00:45:31,740 --> 00:45:37,259
to conclude WPA 3 is vulnerable to side

912
00:45:34,740 --> 00:45:39,569
channels the countermeasures against

913
00:45:37,260 --> 00:45:41,750
this are costly because of that the

914
00:45:39,570 --> 00:45:44,190
standard is now being updated

915
00:45:41,750 --> 00:45:46,530
maybe the most interesting observation

916
00:45:44,190 --> 00:45:48,240
is that a lot of at least quite some of

917
00:45:46,530 --> 00:45:51,120
these side channel issues could have

918
00:45:48,240 --> 00:45:54,000
been avoided remember in the beginning

919
00:45:51,120 --> 00:45:56,190
of the presentation we're in 2010

920
00:45:54,000 --> 00:45:58,350
someone recommended to exclude the MAC

921
00:45:56,190 --> 00:46:00,930
addresses from the algorithms that I

922
00:45:58,350 --> 00:46:03,299
discussed if they would have followed

923
00:46:00,930 --> 00:46:05,399
this advice a lot of our side channel

924
00:46:03,300 --> 00:46:06,870
text just wouldn't have been possible or

925
00:46:05,400 --> 00:46:10,020
they would have been a ton more

926
00:46:06,870 --> 00:46:12,150
difficult so I guess advice is don't

927
00:46:10,020 --> 00:46:15,060
just ask cryptographers for advice

928
00:46:12,150 --> 00:46:17,410
listen to them as well so with that

929
00:46:15,060 --> 00:46:21,170
thank you for your attention

930
00:46:17,410 --> 00:46:23,549
[Applause]

931
00:46:21,170 --> 00:46:24,599
Thank You Marty oh thank you my Tivo

932
00:46:23,549 --> 00:46:30,809
great dog

933
00:46:24,599 --> 00:46:33,420
Lisa regarding the mod peek at the mod p

934
00:46:30,809 --> 00:46:36,390
prime do you know where they got that

935
00:46:33,420 --> 00:46:39,769
from because I'm thinking you know there

936
00:46:36,390 --> 00:46:44,038
are RFC's where the the modulus is like

937
00:46:39,769 --> 00:46:46,910
ffffff staff ffffff and the chances of

938
00:46:44,039 --> 00:46:50,940
it ever iterating are essentially zero

939
00:46:46,910 --> 00:46:53,629
now the mod P curves here have the 160

940
00:46:50,940 --> 00:46:58,230
bit I guess Q so they're different could

941
00:46:53,630 --> 00:46:59,490
not curves different primes but they

942
00:46:58,230 --> 00:47:02,309
could have done the same thing all right

943
00:46:59,490 --> 00:47:06,868
they could have found a prime that was

944
00:47:02,309 --> 00:47:09,150
almost 2 to the 2048 yeah but still had

945
00:47:06,869 --> 00:47:09,630
a mod Q sub group but they didn't do

946
00:47:09,150 --> 00:47:11,220
that

947
00:47:09,630 --> 00:47:16,410
so do you know where they could know

948
00:47:11,220 --> 00:47:18,328
where that prime came from so they could

949
00:47:16,410 --> 00:47:19,799
have indeed used mod P groups where they

950
00:47:18,329 --> 00:47:21,390
wouldn't really have had this issue or

951
00:47:19,799 --> 00:47:23,640
at least have a very small chance that

952
00:47:21,390 --> 00:47:26,460
this value is bigger than the prime I

953
00:47:23,640 --> 00:47:28,140
guess maybe one of the problems with

954
00:47:26,460 --> 00:47:31,440
dragonfly is that they really try to

955
00:47:28,140 --> 00:47:33,180
support a lot of groups including one of

956
00:47:31,440 --> 00:47:35,849
the mod P groups where this is an issue

957
00:47:33,180 --> 00:47:38,430
so I would say they maybe the problem is

958
00:47:35,849 --> 00:47:40,380
that they said they wanted to support to

959
00:47:38,430 --> 00:47:42,480
many crypto groups than was really

960
00:47:40,380 --> 00:47:44,009
necessary and because of that they had

961
00:47:42,480 --> 00:47:46,019
one of these groups where it was an

962
00:47:44,009 --> 00:47:49,500
issue but that seems to be the one that

963
00:47:46,019 --> 00:47:51,299
they're using well it's not the default

964
00:47:49,500 --> 00:47:53,309
one but it is one that is officially

965
00:47:51,299 --> 00:47:55,288
supported in the standard yes yeah okay

966
00:47:53,309 --> 00:47:58,170
thank you but you still don't know where

967
00:47:55,289 --> 00:48:01,769
they got it from like was it in an East

968
00:47:58,170 --> 00:48:03,990
standard or it wasn't one of the RFC's

969
00:48:01,769 --> 00:48:10,410
or standards yet it's it's a it's a

970
00:48:03,990 --> 00:48:12,450
group that was previously defined yeah

971
00:48:10,410 --> 00:48:14,250
it could also be from IPSec I thought

972
00:48:12,450 --> 00:48:16,710
the IPSec ones were the ones Hillary

973
00:48:14,250 --> 00:48:20,039
woman designed which which are safe

974
00:48:16,710 --> 00:48:22,380
Prime's yeah but but it's definitely not

975
00:48:20,039 --> 00:48:26,700
a new group it's one out existed before

976
00:48:22,380 --> 00:48:28,289
okay thank you hey great talk I have a

977
00:48:26,700 --> 00:48:30,149
question regarding the inverted cortex

978
00:48:28,289 --> 00:48:31,780
so from my own experience it's quite

979
00:48:30,150 --> 00:48:33,850
surprising what you found so many of

980
00:48:31,780 --> 00:48:35,710
because usually developers use libraries

981
00:48:33,850 --> 00:48:37,509
for this because they think elliptic

982
00:48:35,710 --> 00:48:42,610
curve is too spooky and too complicated

983
00:48:37,510 --> 00:48:43,800
why is this not focus and VPI free can

984
00:48:42,610 --> 00:48:47,410
you repeat the beginning of the question

985
00:48:43,800 --> 00:48:48,820
why are developers of BPA free not using

986
00:48:47,410 --> 00:48:53,859
libraries because it's usually too

987
00:48:48,820 --> 00:48:55,600
complicated for them well so does this

988
00:48:53,860 --> 00:48:58,560
refer to a developed curve it yeah yeah

989
00:48:55,600 --> 00:49:03,940
yeah yeah so they are using libraries

990
00:48:58,560 --> 00:49:08,049
there so some implementations use open

991
00:49:03,940 --> 00:49:09,460
SSL but they forgot to call the open SSL

992
00:49:08,050 --> 00:49:15,340
function that checks whether the point

993
00:49:09,460 --> 00:49:18,280
is on the elliptic curve and new open

994
00:49:15,340 --> 00:49:20,860
SSL versions do this implicitly yes but

995
00:49:18,280 --> 00:49:22,690
old versions don't on quite smoke

996
00:49:20,860 --> 00:49:29,110
limitations still use the old version of

997
00:49:22,690 --> 00:49:30,760
open SSL where this is not checked sorry

998
00:49:29,110 --> 00:49:33,220
I was Kim inlay so maybe you've already

999
00:49:30,760 --> 00:49:36,640
addressed this if I'm moving around with

1000
00:49:33,220 --> 00:49:40,810
my mobile and addressing multiple Wi-Fi

1001
00:49:36,640 --> 00:49:42,520
hotspots the it's gonna have to go

1002
00:49:40,810 --> 00:49:44,320
through it and in fact it already is

1003
00:49:42,520 --> 00:49:46,780
going through a lot of trouble to

1004
00:49:44,320 --> 00:49:50,950
constantly check on the second third

1005
00:49:46,780 --> 00:49:52,870
best access point isn't this generating

1006
00:49:50,950 --> 00:49:55,359
any enormous amount of computation for

1007
00:49:52,870 --> 00:49:59,680
all the access points even with no data

1008
00:49:55,360 --> 00:50:02,290
actually being transmitted so is the

1009
00:49:59,680 --> 00:50:04,600
question how much so if you scan for

1010
00:50:02,290 --> 00:50:06,310
networks but I'm constantly scanning as

1011
00:50:04,600 --> 00:50:10,270
I'm moving because I may have to switch

1012
00:50:06,310 --> 00:50:12,670
within the next second you know so well

1013
00:50:10,270 --> 00:50:14,530
that uses some amount of energy as well

1014
00:50:12,670 --> 00:50:17,710
and computation but I think that's still

1015
00:50:14,530 --> 00:50:20,620
quite low compared to doing a wp3

1016
00:50:17,710 --> 00:50:23,170
handshake so you don't have to redo the

1017
00:50:20,620 --> 00:50:26,410
the basic handshake all over again so

1018
00:50:23,170 --> 00:50:27,880
when you're just so is the question when

1019
00:50:26,410 --> 00:50:28,839
you are connecting to other networks or

1020
00:50:27,880 --> 00:50:31,360
only searching

1021
00:50:28,840 --> 00:50:34,060
well now you're constantly searching but

1022
00:50:31,360 --> 00:50:37,240
you may immediately switch so you don't

1023
00:50:34,060 --> 00:50:40,060
have time otherwise your optic if you're

1024
00:50:37,240 --> 00:50:41,439
on a phone call or something else so in

1025
00:50:40,060 --> 00:50:44,230
other words you have to be prepared to

1026
00:50:41,440 --> 00:50:45,840
switch at any within I don't know 20

1027
00:50:44,230 --> 00:50:50,590
milliseconds

1028
00:50:45,840 --> 00:50:52,600
so so just searching for networks of

1029
00:50:50,590 --> 00:50:54,430
course doesn't involve the w3 handshake

1030
00:50:52,600 --> 00:50:55,779
now let's say you're walking around your

1031
00:50:54,430 --> 00:50:58,359
house and you're constantly switching

1032
00:50:55,780 --> 00:51:01,900
from access point to access point then

1033
00:50:58,360 --> 00:51:03,670
it depends a bits what version of Wi-Fi

1034
00:51:01,900 --> 00:51:06,820
you're using there's one extension which

1035
00:51:03,670 --> 00:51:09,040
allows you to seamlessly and more

1036
00:51:06,820 --> 00:51:12,130
efficiently switch from one access point

1037
00:51:09,040 --> 00:51:16,230
to another if you don't have that update

1038
00:51:12,130 --> 00:51:19,720
depends a bit how WPA 3 is implemented

1039
00:51:16,230 --> 00:51:21,310
there it depends again some cases you

1040
00:51:19,720 --> 00:51:24,009
will have to redo and eat the complete

1041
00:51:21,310 --> 00:51:26,440
wp3 handshake every time against other

1042
00:51:24,010 --> 00:51:28,540
cases you don't and you can reuse the

1043
00:51:26,440 --> 00:51:30,160
previously negotiated session key

1044
00:51:28,540 --> 00:51:31,750
essential because they're also talking

1045
00:51:30,160 --> 00:51:33,339
now about putting Wi-Fi in cars and

1046
00:51:31,750 --> 00:51:36,880
having a harsh talk to one another on

1047
00:51:33,340 --> 00:51:37,990
the road yeah yes so I think they're

1048
00:51:36,880 --> 00:51:40,300
they're counting on one of the

1049
00:51:37,990 --> 00:51:42,819
extensions on Wi-Fi where you have like

1050
00:51:40,300 --> 00:51:50,230
fast transition to handle that in a

1051
00:51:42,820 --> 00:51:51,970
hopefully better way so okay I think if

1052
00:51:50,230 --> 00:51:53,650
you have further questions to Marty you

1053
00:51:51,970 --> 00:51:57,069
can ask him in the next coffee break

1054
00:51:53,650 --> 00:51:58,790
so thank him once again and see you in

1055
00:51:57,070 --> 00:52:02,980
30 minutes

1056
00:51:58,790 --> 00:52:02,980
[Applause]

