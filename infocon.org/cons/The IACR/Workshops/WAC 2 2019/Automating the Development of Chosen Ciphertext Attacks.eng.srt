1
00:00:04,900 --> 00:00:09,700
today I'm gonna talk a bit about some

2
00:00:07,809 --> 00:00:12,610
sort of ongoing work that I'm currently

3
00:00:09,700 --> 00:00:15,790
doing with a pair of my students that is

4
00:00:12,610 --> 00:00:18,550
aimed at automatically detecting and and

5
00:00:15,790 --> 00:00:20,290
finding new attacks on format Oracle's

6
00:00:18,550 --> 00:00:22,210
which are a generalization of patting

7
00:00:20,290 --> 00:00:24,160
Oracle's I want to quickly give a little

8
00:00:22,210 --> 00:00:27,220
bit of credit this is work that really

9
00:00:24,160 --> 00:00:29,290
the bulk of the awful painful work was

10
00:00:27,220 --> 00:00:30,820
done by my two PhD students Gabrielle

11
00:00:29,290 --> 00:00:32,140
back in MCEs Incas who aren't here to

12
00:00:30,820 --> 00:00:33,280
take credit for it so I'm here to take

13
00:00:32,140 --> 00:00:34,930
credit for them

14
00:00:33,280 --> 00:00:37,329
there's a draft online you can see the

15
00:00:34,930 --> 00:00:38,890
actual paper there I also want to

16
00:00:37,329 --> 00:00:40,750
mention that this is work in progress

17
00:00:38,890 --> 00:00:42,760
this is the result of months of

18
00:00:40,750 --> 00:00:44,260
wrestling with sat solvers and we're

19
00:00:42,760 --> 00:00:46,178
still wrestling with sat solvers we

20
00:00:44,260 --> 00:00:47,949
actually had to like repair bugs and Sat

21
00:00:46,179 --> 00:00:49,300
solvers so this is kind of like the

22
00:00:47,949 --> 00:00:52,449
preliminary results and there will be

23
00:00:49,300 --> 00:00:53,649
more results later on down the line the

24
00:00:52,449 --> 00:00:55,839
last thing I want to say in this

25
00:00:53,649 --> 00:00:57,519
interest slide is that you know they say

26
00:00:55,839 --> 00:00:59,379
that sometimes a lot of research papers

27
00:00:57,519 --> 00:01:02,199
are born as the result of an argument

28
00:00:59,379 --> 00:01:04,239
and this research paper is actually born

29
00:01:02,199 --> 00:01:06,429
as the result of kind of a painful story

30
00:01:04,239 --> 00:01:07,870
or we found a vulnerability a few years

31
00:01:06,430 --> 00:01:09,820
ago in an apple product and we had to

32
00:01:07,870 --> 00:01:12,070
spend like weeks and months manually

33
00:01:09,820 --> 00:01:13,539
exploiting it so we just determined we

34
00:01:12,070 --> 00:01:14,919
would never have to do that again so we

35
00:01:13,540 --> 00:01:16,780
wanted to automate that process and I'm

36
00:01:14,920 --> 00:01:18,970
gonna come back to that story in just a

37
00:01:16,780 --> 00:01:21,130
little bit okay so quick background

38
00:01:18,970 --> 00:01:22,900
chosen ciphertext attacks are an old

39
00:01:21,130 --> 00:01:24,699
thing I actually spent some time trying

40
00:01:22,900 --> 00:01:26,980
to go into the pre research literature

41
00:01:24,700 --> 00:01:29,260
to see where the first examples of

42
00:01:26,980 --> 00:01:31,750
practical chosen ciphertext attacks a

43
00:01:29,260 --> 00:01:33,640
text attacks exist I wasn't really able

44
00:01:31,750 --> 00:01:35,560
to find anything kind of before the 90s

45
00:01:33,640 --> 00:01:37,300
I'm sure that they happened you know

46
00:01:35,560 --> 00:01:38,620
maybe back in the days of the Enigma but

47
00:01:37,300 --> 00:01:40,929
nobody was able to give me any examples

48
00:01:38,620 --> 00:01:44,230
but we do know that starting in about

49
00:01:40,930 --> 00:01:46,450
the mid 1990s there was a bunch maybe

50
00:01:44,230 --> 00:01:48,160
earlier late 80s there was a bunch of

51
00:01:46,450 --> 00:01:49,630
formal work in the research community

52
00:01:48,160 --> 00:01:51,759
looking at ways we could immunize

53
00:01:49,630 --> 00:01:53,380
schemes against chosen ciphertext

54
00:01:51,760 --> 00:01:55,660
attacks we knew these things were real

55
00:01:53,380 --> 00:01:57,670
we came up with models and we started to

56
00:01:55,660 --> 00:01:58,869
sort of build the groundwork for schemes

57
00:01:57,670 --> 00:02:01,660
that were actually secured in this

58
00:01:58,870 --> 00:02:03,640
particular model but at the time this is

59
00:02:01,660 --> 00:02:04,899
the 80s and 90s this was really theory

60
00:02:03,640 --> 00:02:07,120
nobody thought this was actually

61
00:02:04,900 --> 00:02:09,729
something that would affect us until the

62
00:02:07,120 --> 00:02:11,230
late 1990s in the early 2000s when

63
00:02:09,729 --> 00:02:12,760
suddenly two attacks which we talked

64
00:02:11,230 --> 00:02:15,219
about today kind of came out of nowhere

65
00:02:12,760 --> 00:02:16,799
and made industry and people who

66
00:02:15,219 --> 00:02:18,720
actually do things with real crypto

67
00:02:16,800 --> 00:02:20,370
care about this problem the first is we

68
00:02:18,720 --> 00:02:22,170
discuss in the last talk in the

69
00:02:20,370 --> 00:02:24,780
asymmetric crypto world was the biking

70
00:02:22,170 --> 00:02:26,429
baka attack and in the symmetric crypto

71
00:02:24,780 --> 00:02:29,040
world the first was the vaad may attack

72
00:02:26,430 --> 00:02:30,780
I have it as 2001 maybe it was 2002 and

73
00:02:29,040 --> 00:02:32,730
this was a padding Oracle attack and

74
00:02:30,780 --> 00:02:34,530
since this talk is mostly or almost

75
00:02:32,730 --> 00:02:37,470
entirely about symmetric crypto I'm

76
00:02:34,530 --> 00:02:40,950
gonna focus on that and not go back to

77
00:02:37,470 --> 00:02:42,570
black in baccarat for a while so the

78
00:02:40,950 --> 00:02:43,769
vaad may attack and I'm really glad I

79
00:02:42,570 --> 00:02:45,060
don't have to sort of start from scratch

80
00:02:43,770 --> 00:02:47,730
on this we just saw it in the previous

81
00:02:45,060 --> 00:02:49,140
attack basically works on the theory

82
00:02:47,730 --> 00:02:50,429
that a lot of schemes don't use

83
00:02:49,140 --> 00:02:51,690
authenticated encryption a lot of

84
00:02:50,430 --> 00:02:53,790
protocols don't use authenticated

85
00:02:51,690 --> 00:02:56,220
encryption there is a padding check

86
00:02:53,790 --> 00:02:58,109
function this was a vulnerability in SSL

87
00:02:56,220 --> 00:03:00,120
but is all over the place as we now know

88
00:02:58,110 --> 00:03:03,090
that will basically give you back some

89
00:03:00,120 --> 00:03:05,070
signal let's say a 0 or a 1 depending on

90
00:03:03,090 --> 00:03:07,410
whether the padding checks out in a

91
00:03:05,070 --> 00:03:09,870
decrypted cypher text and so if the

92
00:03:07,410 --> 00:03:11,820
cipher text is not authenticated we can

93
00:03:09,870 --> 00:03:14,430
exploit this to do useful things it was

94
00:03:11,820 --> 00:03:17,220
a very famous old attack amazingly still

95
00:03:14,430 --> 00:03:19,020
exists today in 2019 there is a

96
00:03:17,220 --> 00:03:20,700
generalization of this called the format

97
00:03:19,020 --> 00:03:22,740
Oracle attack and it's the same idea

98
00:03:20,700 --> 00:03:24,600
it's just that now we're going to

99
00:03:22,740 --> 00:03:26,340
replace that format checking function

100
00:03:24,600 --> 00:03:28,320
the padding check function with an

101
00:03:26,340 --> 00:03:30,930
arbitrary predicate that basically says

102
00:03:28,320 --> 00:03:32,310
hey let's look at whatever it is about

103
00:03:30,930 --> 00:03:34,770
this decrypted message and tell you

104
00:03:32,310 --> 00:03:36,150
whether or not this is valid ok so we're

105
00:03:34,770 --> 00:03:38,430
just gonna define this as an arbitrary

106
00:03:36,150 --> 00:03:40,590
function f and the basic idea is a

107
00:03:38,430 --> 00:03:41,910
format Oracle does decryption evaluate

108
00:03:40,590 --> 00:03:43,620
to this function and then tells you

109
00:03:41,910 --> 00:03:45,329
whether or not things work the neat

110
00:03:43,620 --> 00:03:47,280
thing about format Oracle attacks from

111
00:03:45,330 --> 00:03:49,590
my perspective is that they can be very

112
00:03:47,280 --> 00:03:50,790
deep so typically we like to think about

113
00:03:49,590 --> 00:03:52,650
crypto in terms of cryptographic

114
00:03:50,790 --> 00:03:53,880
libraries and cryptographic code and

115
00:03:52,650 --> 00:03:55,950
that's even the case for padding Oracle

116
00:03:53,880 --> 00:03:59,070
attacks because padding check functions

117
00:03:55,950 --> 00:04:01,230
are in libraries like open SSL but

118
00:03:59,070 --> 00:04:02,519
format Oracle attacks can go way way

119
00:04:01,230 --> 00:04:04,140
beyond the crypto code if you're

120
00:04:02,520 --> 00:04:06,510
vulnerable to a format Oracle attack

121
00:04:04,140 --> 00:04:08,760
that stuff that might be vulnerable

122
00:04:06,510 --> 00:04:11,579
could be like your application specific

123
00:04:08,760 --> 00:04:13,350
parsing logic your decompressor it could

124
00:04:11,580 --> 00:04:15,540
even be something completely insane like

125
00:04:13,350 --> 00:04:17,730
you're decrypting a firmware image and

126
00:04:15,540 --> 00:04:19,320
trying to run code from that firmware

127
00:04:17,730 --> 00:04:21,299
image so this goes way way beyond the

128
00:04:19,320 --> 00:04:23,430
crypto if you're vulnerable if you're

129
00:04:21,298 --> 00:04:25,469
not authenticating your encryption now

130
00:04:23,430 --> 00:04:27,120
the answer to this problem is you should

131
00:04:25,470 --> 00:04:29,100
be authenticating your encryption I want

132
00:04:27,120 --> 00:04:29,960
to put this up front obviously that's

133
00:04:29,100 --> 00:04:32,240
the kind of odd

134
00:04:29,960 --> 00:04:34,250
the solution we tell people to do this

135
00:04:32,240 --> 00:04:35,539
they don't always listen to us

136
00:04:34,250 --> 00:04:38,330
unfortunately the fact that we're still

137
00:04:35,539 --> 00:04:40,219
seeing vulnerabilities in TLS and 2019

138
00:04:38,330 --> 00:04:42,318
tells us that we haven't really solved

139
00:04:40,220 --> 00:04:44,319
this problem so people don't like to

140
00:04:42,319 --> 00:04:47,210
change legacy systems unless they see

141
00:04:44,319 --> 00:04:49,009
proof of exploitability even like in

142
00:04:47,210 --> 00:04:50,840
this very well trodden area of just

143
00:04:49,009 --> 00:04:52,639
simple padding Oracle attacks on TLS

144
00:04:50,840 --> 00:04:54,830
we're seeing problems when it comes to

145
00:04:52,639 --> 00:04:56,690
custom protocols it's much much harder

146
00:04:54,830 --> 00:04:59,300
to get people to change and there's

147
00:04:56,690 --> 00:05:00,729
still this problem of misuse right even

148
00:04:59,300 --> 00:05:03,500
if you use authenticated encryption

149
00:05:00,729 --> 00:05:05,690
somebody goes with AES GCM and they

150
00:05:03,500 --> 00:05:07,580
reuse a nonce all of a sudden you have a

151
00:05:05,690 --> 00:05:09,469
new malleability issue that pops right

152
00:05:07,580 --> 00:05:12,050
up and we're trying to fix this with you

153
00:05:09,470 --> 00:05:14,000
know SIV and other kinds of modes of

154
00:05:12,050 --> 00:05:16,099
operation but we're not there yet the

155
00:05:14,000 --> 00:05:18,680
last sort of reason that AE doesn't

156
00:05:16,099 --> 00:05:19,789
solve this is because open SSL and I'm

157
00:05:18,680 --> 00:05:21,590
not going to say anything else about

158
00:05:19,789 --> 00:05:27,349
that so we're always gonna be suffering

159
00:05:21,590 --> 00:05:29,270
for those I'm gonna grab the personal

160
00:05:27,349 --> 00:05:30,889
story that I kind of meant to relay and

161
00:05:29,270 --> 00:05:33,049
this is along the lines of you can't get

162
00:05:30,889 --> 00:05:35,659
people to fix things without a and

163
00:05:33,050 --> 00:05:37,849
exploitable vulnerability so several

164
00:05:35,659 --> 00:05:40,219
years ago is back in 2015 I went I gave

165
00:05:37,849 --> 00:05:42,139
a talk at Apple and the night before the

166
00:05:40,220 --> 00:05:43,909
talk I pulled open their iOS security

167
00:05:42,139 --> 00:05:46,520
guide and I looked to specifically see

168
00:05:43,909 --> 00:05:48,800
how iMessage security how the crypto and

169
00:05:46,520 --> 00:05:50,448
iMessage worked and I noticed really

170
00:05:48,800 --> 00:05:51,530
just like a basic observation that they

171
00:05:50,449 --> 00:05:53,599
weren't using authenticated encryption

172
00:05:51,530 --> 00:05:55,130
they were using sign encryption and they

173
00:05:53,599 --> 00:05:56,570
weren't using it right so that meant

174
00:05:55,130 --> 00:05:58,130
they might have some kind of padding

175
00:05:56,570 --> 00:06:00,469
Oracle at a forum at Oracle attack in

176
00:05:58,130 --> 00:06:02,180
their system so the next day when I was

177
00:06:00,469 --> 00:06:04,610
giving this a talk to the entire Apple

178
00:06:02,180 --> 00:06:06,560
security team I put this in the last few

179
00:06:04,610 --> 00:06:08,449
slides of my talk and I said look you

180
00:06:06,560 --> 00:06:10,430
folks you have this problem here you're

181
00:06:08,449 --> 00:06:13,219
not authenticating there might be some

182
00:06:10,430 --> 00:06:15,830
kind of padding Oracle unless you have

183
00:06:13,219 --> 00:06:17,979
some kind of extra protocol level check

184
00:06:15,830 --> 00:06:22,219
that makes this attack not work and

185
00:06:17,979 --> 00:06:24,169
Apple doesn't talk to you they like wink

186
00:06:22,219 --> 00:06:25,130
and twinkle their eyes at you because

187
00:06:24,169 --> 00:06:27,380
they're not allowed to share information

188
00:06:25,130 --> 00:06:30,590
so I looked at the head of the security

189
00:06:27,380 --> 00:06:33,020
team and I swear that his eyes twinkled

190
00:06:30,590 --> 00:06:34,190
which to me said yeah we have some kind

191
00:06:33,020 --> 00:06:36,469
of countermeasure to this down at the

192
00:06:34,190 --> 00:06:38,210
protocol level about two three months

193
00:06:36,469 --> 00:06:39,349
later I went back with my students and

194
00:06:38,210 --> 00:06:41,150
we actually looked to see what that

195
00:06:39,349 --> 00:06:43,400
countermeasure was and there was nothing

196
00:06:41,150 --> 00:06:43,909
there was nothing at all so later on we

197
00:06:43,400 --> 00:06:45,409
spent three

198
00:06:43,910 --> 00:06:47,330
months or so trying to exploit this it

199
00:06:45,410 --> 00:06:49,310
involved a gzip format Oracle attack we

200
00:06:47,330 --> 00:06:51,320
did all this work we went back to Apple

201
00:06:49,310 --> 00:06:52,880
and we said hey we pointed out this

202
00:06:51,320 --> 00:06:54,500
vulnerability you know we should get

203
00:06:52,880 --> 00:06:56,420
credit in terms of the disclosure

204
00:06:54,500 --> 00:06:58,340
timeline for telling you this and they

205
00:06:56,420 --> 00:06:59,930
said what vulnerability we have no

206
00:06:58,340 --> 00:07:01,849
recollection of any of that happening at

207
00:06:59,930 --> 00:07:03,050
all so the point is just telling people

208
00:07:01,850 --> 00:07:04,520
like you're not using encryption

209
00:07:03,050 --> 00:07:06,560
correctly you should use authenticated

210
00:07:04,520 --> 00:07:07,969
encryption doesn't make them do anything

211
00:07:06,560 --> 00:07:09,740
when you come to them and say we can

212
00:07:07,970 --> 00:07:11,600
exploit this and decrypt your cipher

213
00:07:09,740 --> 00:07:13,550
texts suddenly they care but

214
00:07:11,600 --> 00:07:15,140
unfortunately that's incredibly painful

215
00:07:13,550 --> 00:07:17,600
I just want to give you some examples of

216
00:07:15,140 --> 00:07:19,070
recent work in the crypto and the

217
00:07:17,600 --> 00:07:20,660
systems community of people doing this

218
00:07:19,070 --> 00:07:22,969
these don't have dates but they're all

219
00:07:20,660 --> 00:07:24,740
within the last few years some folks

220
00:07:22,970 --> 00:07:27,050
probably here did them there have been

221
00:07:24,740 --> 00:07:28,490
exploits on XML encryption that take

222
00:07:27,050 --> 00:07:30,080
advantage of the fact that parsers can

223
00:07:28,490 --> 00:07:32,300
leak information about well formulas of

224
00:07:30,080 --> 00:07:34,550
cipher text there have been examples a

225
00:07:32,300 --> 00:07:35,990
fail a year to go took advantage of gzip

226
00:07:34,550 --> 00:07:38,060
compression just like the iMessage

227
00:07:35,990 --> 00:07:40,190
attack I mentioned did there are other

228
00:07:38,060 --> 00:07:41,570
kind of miscellaneous problems with PGP

229
00:07:40,190 --> 00:07:43,730
parsing it's a little unfair to pick on

230
00:07:41,570 --> 00:07:45,260
PGP because PGP sucks but like obviously

231
00:07:43,730 --> 00:07:47,450
you know there are gonna be things like

232
00:07:45,260 --> 00:07:49,550
that and then of course we have this

233
00:07:47,450 --> 00:07:51,890
recent talk about padding Oracle still

234
00:07:49,550 --> 00:07:53,870
cropping up and in new and exciting ways

235
00:07:51,890 --> 00:07:55,419
and I'm not giving you a full list here

236
00:07:53,870 --> 00:07:58,310
I'm just giving you like the the quick

237
00:07:55,420 --> 00:08:00,440
examples I could find by searching the

238
00:07:58,310 --> 00:08:02,060
point that I want to make here is even

239
00:08:00,440 --> 00:08:03,590
though just by searching for five

240
00:08:02,060 --> 00:08:06,080
minutes I can come up with maybe eight

241
00:08:03,590 --> 00:08:08,060
or nine papers on the subject of format

242
00:08:06,080 --> 00:08:10,669
Oracle's and modern protocols this is

243
00:08:08,060 --> 00:08:13,370
almost certainly the tip of a really

244
00:08:10,669 --> 00:08:14,990
really big iceberg and the reason this

245
00:08:13,370 --> 00:08:16,280
is the case is that if you see any

246
00:08:14,990 --> 00:08:17,780
protocol that's not properly

247
00:08:16,280 --> 00:08:20,239
authenticating the encryption or is

248
00:08:17,780 --> 00:08:23,599
vulnerable to nonce reuse attacks it is

249
00:08:20,240 --> 00:08:25,790
almost certainly vulnerable to some kind

250
00:08:23,600 --> 00:08:27,440
of format Oracle attack you'd have to

251
00:08:25,790 --> 00:08:29,480
dig down into the code of whatever it's

252
00:08:27,440 --> 00:08:31,010
doing deep inside of message parsing it

253
00:08:29,480 --> 00:08:32,510
might be incredibly complex it might

254
00:08:31,010 --> 00:08:34,189
involve compression and some kind of

255
00:08:32,510 --> 00:08:36,110
like proprietary binary format on

256
00:08:34,190 --> 00:08:38,240
marshalling but there's going to be

257
00:08:36,110 --> 00:08:40,219
something there the question is how easy

258
00:08:38,240 --> 00:08:41,960
is it to exploit how much data can you

259
00:08:40,219 --> 00:08:43,640
get out of it that's the hard part and

260
00:08:41,960 --> 00:08:45,530
that can take months and months for

261
00:08:43,640 --> 00:08:47,210
human beings to actually figure out and

262
00:08:45,530 --> 00:08:48,500
you know just just knowing there might

263
00:08:47,210 --> 00:08:50,780
be a vulnerability doesn't tell you how

264
00:08:48,500 --> 00:08:52,339
much you can actually do with it and so

265
00:08:50,780 --> 00:08:54,530
the problem with this is we have some

266
00:08:52,339 --> 00:08:56,930
really smart people in this audience

267
00:08:54,530 --> 00:08:57,350
spending time poking at these protocols

268
00:08:56,930 --> 00:08:59,180
and try

269
00:08:57,350 --> 00:09:00,770
to make it a break them when we

270
00:08:59,180 --> 00:09:03,109
shouldn't be doing that we should have

271
00:09:00,770 --> 00:09:04,939
the computers we use be doing that so

272
00:09:03,110 --> 00:09:06,940
the solution to this problem obviously

273
00:09:04,940 --> 00:09:09,230
is just to get rid of the human beings

274
00:09:06,940 --> 00:09:10,400
not like that we want to do it in a way

275
00:09:09,230 --> 00:09:12,110
that's helped us we want to build

276
00:09:10,400 --> 00:09:14,360
machines that can actually help us do

277
00:09:12,110 --> 00:09:17,030
exploitation in a useful way so the idea

278
00:09:14,360 --> 00:09:19,390
of this talk or this work is we want to

279
00:09:17,030 --> 00:09:22,010
try to automate the development of novel

280
00:09:19,390 --> 00:09:24,050
format Oracle attacks so I don't want to

281
00:09:22,010 --> 00:09:25,670
just execute things that have been done

282
00:09:24,050 --> 00:09:27,469
before they're really good works like

283
00:09:25,670 --> 00:09:29,870
some of the things we saw in the last

284
00:09:27,470 --> 00:09:31,190
session that do that really well we want

285
00:09:29,870 --> 00:09:32,750
to take format Oracle's that we've never

286
00:09:31,190 --> 00:09:34,700
seen before we want to come up with

287
00:09:32,750 --> 00:09:35,680
exploits and determine exploit ability

288
00:09:34,700 --> 00:09:38,660
and go from there

289
00:09:35,680 --> 00:09:40,670
what does that mean more concretely okay

290
00:09:38,660 --> 00:09:43,040
let's assume we have the following

291
00:09:40,670 --> 00:09:44,290
ingredients so we have some knowledge

292
00:09:43,040 --> 00:09:46,130
about the system we're attacking

293
00:09:44,290 --> 00:09:48,290
specifically we have a machine readable

294
00:09:46,130 --> 00:09:50,030
description of a format checking

295
00:09:48,290 --> 00:09:51,530
function I'll talk about what machine

296
00:09:50,030 --> 00:09:52,189
readable description means maybe it's

297
00:09:51,530 --> 00:09:54,800
Python

298
00:09:52,190 --> 00:09:56,510
we'll go from there we also have some

299
00:09:54,800 --> 00:09:59,060
kind of machine readable description of

300
00:09:56,510 --> 00:10:00,439
the malleability characteristics of the

301
00:09:59,060 --> 00:10:02,060
symmetric encryption scheme that we're

302
00:10:00,440 --> 00:10:03,890
working with now when I say the

303
00:10:02,060 --> 00:10:05,839
malleability characteristics I mean I'm

304
00:10:03,890 --> 00:10:07,010
not talking about the entire scheme I

305
00:10:05,840 --> 00:10:08,840
don't want have to reason over an entire

306
00:10:07,010 --> 00:10:10,910
encryption scheme but I might want to

307
00:10:08,840 --> 00:10:12,920
know that when I flip certain bits this

308
00:10:10,910 --> 00:10:14,240
is going to happen after decryption so

309
00:10:12,920 --> 00:10:15,650
that's the kind of thing that I want to

310
00:10:14,240 --> 00:10:17,660
know about we want to have a target

311
00:10:15,650 --> 00:10:19,610
ciphertext C char C star that we want to

312
00:10:17,660 --> 00:10:21,439
attack and of course we need a format

313
00:10:19,610 --> 00:10:23,300
Oracle so the goal is using that

314
00:10:21,440 --> 00:10:26,150
information with no further human

315
00:10:23,300 --> 00:10:28,280
interaction derive an adaptive chosen

316
00:10:26,150 --> 00:10:30,650
ciphertext attack that will recover as

317
00:10:28,280 --> 00:10:33,319
much information about the decryption of

318
00:10:30,650 --> 00:10:35,630
C star in you know as little time as

319
00:10:33,320 --> 00:10:36,860
possible so this is basically you know

320
00:10:35,630 --> 00:10:38,750
kind of our goal so we want it to be

321
00:10:36,860 --> 00:10:40,910
fast in terms of the number of queries

322
00:10:38,750 --> 00:10:43,790
it takes and we want it to be fast in

323
00:10:40,910 --> 00:10:46,520
terms of wall clock time as well okay

324
00:10:43,790 --> 00:10:48,170
this slide is standing in for a lot of

325
00:10:46,520 --> 00:10:49,880
works that I'm not explicitly citing but

326
00:10:48,170 --> 00:10:51,620
they are cited in the paper there is

327
00:10:49,880 --> 00:10:53,480
some work in this area that doesn't

328
00:10:51,620 --> 00:10:54,830
focus on this specific problem but does

329
00:10:53,480 --> 00:10:56,870
focus on the problem of side-channel

330
00:10:54,830 --> 00:10:59,510
attacks which is really interesting it

331
00:10:56,870 --> 00:11:02,450
does basically symbolic execution of

332
00:10:59,510 --> 00:11:04,370
like Java code and it uses Sat solvers

333
00:11:02,450 --> 00:11:07,040
in ways that are related to what we're

334
00:11:04,370 --> 00:11:08,450
doing basically tries to solve a related

335
00:11:07,040 --> 00:11:09,980
problem you can actually show there's a

336
00:11:08,450 --> 00:11:10,569
kind of an equivalence between these two

337
00:11:09,980 --> 00:11:13,179
problem

338
00:11:10,569 --> 00:11:14,559
the problem with the works that I've

339
00:11:13,179 --> 00:11:16,480
seen they're really really interesting

340
00:11:14,559 --> 00:11:17,889
techniques and I'm trying to sort of

341
00:11:16,480 --> 00:11:19,959
figure out how they translate into our

342
00:11:17,889 --> 00:11:22,809
techniques unfortunately most of the

343
00:11:19,959 --> 00:11:25,868
results in those papers deal with very

344
00:11:22,809 --> 00:11:27,549
very small secret domain sizes so for

345
00:11:25,869 --> 00:11:29,049
example a couple of the papers the

346
00:11:27,549 --> 00:11:31,360
secret is restricted to being three

347
00:11:29,049 --> 00:11:32,920
bytes long and the size of the message

348
00:11:31,360 --> 00:11:33,999
is very small there's some some work

349
00:11:32,920 --> 00:11:36,549
where you have like modular

350
00:11:33,999 --> 00:11:38,889
exponentiations I gentle attacks but the

351
00:11:36,549 --> 00:11:40,449
modulus is maybe like ten bits long or

352
00:11:38,889 --> 00:11:42,189
like thirty bits long or something so

353
00:11:40,449 --> 00:11:44,199
these techniques work but it's not clear

354
00:11:42,189 --> 00:11:45,879
how scalable it is we want to be very

355
00:11:44,199 --> 00:11:48,519
scalable so this is the direction we're

356
00:11:45,879 --> 00:11:50,499
going in all right so reminding just to

357
00:11:48,519 --> 00:11:52,119
remind you the basic attack setting that

358
00:11:50,499 --> 00:11:54,850
we're in looks like this we have this

359
00:11:52,119 --> 00:11:56,889
ciphertext C star we want we know it

360
00:11:54,850 --> 00:11:59,319
encrypt some unknown plaintext M star

361
00:11:56,889 --> 00:12:00,939
our goal is to decrypt this or if we

362
00:11:59,319 --> 00:12:03,069
can't fully decrypt it get as much

363
00:12:00,939 --> 00:12:05,290
information as possible and we want to

364
00:12:03,069 --> 00:12:07,269
do this by basically adaptively coming

365
00:12:05,290 --> 00:12:09,969
up with experiments that we can submit

366
00:12:07,269 --> 00:12:11,709
to this online decryption Oracle alright

367
00:12:09,970 --> 00:12:13,600
so any time you develop an adaptive

368
00:12:11,709 --> 00:12:14,949
chosen ciphertext attack you're doing

369
00:12:13,600 --> 00:12:16,720
something like the following whether

370
00:12:14,949 --> 00:12:18,399
it's a computer doing it or you doing it

371
00:12:16,720 --> 00:12:20,559
the first thing you're doing is you're

372
00:12:18,399 --> 00:12:24,339
building up a set of initial constraints

373
00:12:20,559 --> 00:12:25,360
on the unknown message m star then the

374
00:12:24,339 --> 00:12:27,100
next thing you're gonna do is you're

375
00:12:25,360 --> 00:12:28,360
gonna generate a useful experiment that

376
00:12:27,100 --> 00:12:30,249
hopefully gives you some more

377
00:12:28,360 --> 00:12:32,439
information more constraints on M star

378
00:12:30,249 --> 00:12:34,269
you're going to take that experiment

379
00:12:32,439 --> 00:12:36,669
you're gonna run it and then having run

380
00:12:34,269 --> 00:12:38,829
it you're gonna use that result of the

381
00:12:36,669 --> 00:12:40,569
running it on the actual Oracle to

382
00:12:38,829 --> 00:12:43,029
increase or extend the set of

383
00:12:40,569 --> 00:12:44,679
constraints and if that works you go

384
00:12:43,029 --> 00:12:47,110
back to step two and you continue that

385
00:12:44,679 --> 00:12:47,410
process adaptively until you can't do it

386
00:12:47,110 --> 00:12:48,910
any more

387
00:12:47,410 --> 00:12:50,649
that's the entire nature of pretty much

388
00:12:48,910 --> 00:12:53,649
every adaptive chosen cipher text attack

389
00:12:50,649 --> 00:12:56,410
now it should be obvious that the hard

390
00:12:53,649 --> 00:12:58,179
part all the actual work comes inside of

391
00:12:56,410 --> 00:12:59,919
this step two how do we generate useful

392
00:12:58,179 --> 00:13:02,738
experiments because everything else is

393
00:12:59,919 --> 00:13:04,449
just a constraint solving problem to do

394
00:13:02,739 --> 00:13:05,919
this we're gonna need to introduce or at

395
00:13:04,449 --> 00:13:09,609
least talk about a couple of building

396
00:13:05,919 --> 00:13:11,079
blocks the first building block and it

397
00:13:09,610 --> 00:13:13,779
should be pretty obvious based on what

398
00:13:11,079 --> 00:13:15,309
I've said so far is we need to have some

399
00:13:13,779 --> 00:13:16,629
kind of solver that can reason over

400
00:13:15,309 --> 00:13:19,240
constraint systems we're gonna work with

401
00:13:16,629 --> 00:13:20,799
constraint systems the obvious tool is

402
00:13:19,240 --> 00:13:23,439
to use theory solvers these come in two

403
00:13:20,799 --> 00:13:23,980
flavors the most famous flavor is

404
00:13:23,439 --> 00:13:25,900
satsang

405
00:13:23,980 --> 00:13:28,900
solving we know that we have a bunch of

406
00:13:25,900 --> 00:13:30,579
nice research / production sat solvers

407
00:13:28,900 --> 00:13:33,459
that can solve pretty complex formula is

408
00:13:30,580 --> 00:13:35,710
typically given in CNF form we also have

409
00:13:33,460 --> 00:13:37,720
these great SMT solvers like z3 which

410
00:13:35,710 --> 00:13:40,350
extend the logic beyond Sat to other

411
00:13:37,720 --> 00:13:43,300
sorts of maybe bit vector arithmetic

412
00:13:40,350 --> 00:13:45,700
other kinds of logic that we can use the

413
00:13:43,300 --> 00:13:46,930
nice thing about these these SMT solvers

414
00:13:45,700 --> 00:13:49,120
is they also provide a bunch of

415
00:13:46,930 --> 00:13:51,459
simplification and additional tools that

416
00:13:49,120 --> 00:13:52,600
normal Sat solvers don't provide us so

417
00:13:51,460 --> 00:13:55,330
this is just something we're gonna use

418
00:13:52,600 --> 00:13:57,430
as kind of a black box the good news

419
00:13:55,330 --> 00:13:58,660
about Theory solvers is that they exist

420
00:13:57,430 --> 00:14:00,130
they work if we have a set of

421
00:13:58,660 --> 00:14:01,540
constraints we can solve this is

422
00:14:00,130 --> 00:14:04,090
terrific the bad news is they don't

423
00:14:01,540 --> 00:14:05,560
solve our problem there is no notion in

424
00:14:04,090 --> 00:14:07,810
a theory solver of basically getting a

425
00:14:05,560 --> 00:14:09,250
theory solver to say hey generate an

426
00:14:07,810 --> 00:14:10,989
experiment that gives me useful

427
00:14:09,250 --> 00:14:12,940
information if you have a set of

428
00:14:10,990 --> 00:14:14,710
constraints you can solve but there's no

429
00:14:12,940 --> 00:14:16,060
kind of idea of an Oracle query inside

430
00:14:14,710 --> 00:14:18,340
of a theory solver so we need to come up

431
00:14:16,060 --> 00:14:19,869
with some way to do that the next thing

432
00:14:18,340 --> 00:14:21,310
we need is we need to talk about what

433
00:14:19,870 --> 00:14:22,930
we're actually specifically gonna say

434
00:14:21,310 --> 00:14:24,760
when it comes to encryption malleability

435
00:14:22,930 --> 00:14:26,439
so we want a reason over the scheme's

436
00:14:24,760 --> 00:14:28,810
Mally ation properties we need to define

437
00:14:26,440 --> 00:14:30,580
that the pretty basic way to define that

438
00:14:28,810 --> 00:14:32,500
is to define a pair of functions we'll

439
00:14:30,580 --> 00:14:34,240
call them the ciphertext Mally ation

440
00:14:32,500 --> 00:14:36,340
function and the plaintext Mally ation

441
00:14:34,240 --> 00:14:37,930
function not surprisingly and they work

442
00:14:36,340 --> 00:14:40,060
as follows so each of these functions

443
00:14:37,930 --> 00:14:41,680
takes in some string we're gonna call

444
00:14:40,060 --> 00:14:42,969
this string it's the S up there we're

445
00:14:41,680 --> 00:14:44,349
gonna call this the Mallee ation

446
00:14:42,970 --> 00:14:46,540
instruction string or just a Mallee

447
00:14:44,350 --> 00:14:48,010
ation string ciphertext Mally ation

448
00:14:46,540 --> 00:14:50,079
takes in a ciphertext and this Mally

449
00:14:48,010 --> 00:14:52,180
ation string and spits out a new

450
00:14:50,080 --> 00:14:54,700
ciphertext hopefully in the same domain

451
00:14:52,180 --> 00:14:56,890
of valid cipher texts the plaintext

452
00:14:54,700 --> 00:14:58,270
Mally ation takes in a plaintext does

453
00:14:56,890 --> 00:15:00,520
the same thing with the same kind of

454
00:14:58,270 --> 00:15:02,740
valuation string and spits out in this

455
00:15:00,520 --> 00:15:04,329
case i'm saying just a new plaintext but

456
00:15:02,740 --> 00:15:06,400
it could spit out a set of plaintext in

457
00:15:04,330 --> 00:15:09,070
fact for some schemes like CBC mode it

458
00:15:06,400 --> 00:15:11,079
actually does do that okay so we have to

459
00:15:09,070 --> 00:15:12,460
specify a few things you should think

460
00:15:11,080 --> 00:15:13,630
about these they're really obvious

461
00:15:12,460 --> 00:15:16,450
examples if we're just dealing with

462
00:15:13,630 --> 00:15:18,010
simple xor based stream ciphers both of

463
00:15:16,450 --> 00:15:20,620
these functions could be realized using

464
00:15:18,010 --> 00:15:22,780
simple XOR treat asks the Mallee ation

465
00:15:20,620 --> 00:15:24,040
string as just a string to be XOR it

466
00:15:22,780 --> 00:15:25,000
into the plain text or the cipher text

467
00:15:24,040 --> 00:15:27,490
and you're done

468
00:15:25,000 --> 00:15:28,810
they're the same function CBC as we saw

469
00:15:27,490 --> 00:15:30,610
in the previous talk is a bit more

470
00:15:28,810 --> 00:15:32,170
complicated because if you flip a bit in

471
00:15:30,610 --> 00:15:34,420
a particular block of a message

472
00:15:32,170 --> 00:15:36,520
you essentially trash upon decryption

473
00:15:34,420 --> 00:15:37,599
that same block in the plaintext because

474
00:15:36,520 --> 00:15:39,399
you're using a pseudo-random

475
00:15:37,600 --> 00:15:41,740
mutation so you have to define a more

476
00:15:39,399 --> 00:15:42,730
complex Mally ation function and that

477
00:15:41,740 --> 00:15:44,139
that can be a little bit more

478
00:15:42,730 --> 00:15:45,670
interesting but Mally ation functions

479
00:15:44,139 --> 00:15:47,380
don't have to be limited just to X or

480
00:15:45,670 --> 00:15:49,389
you could have Mally ation functions

481
00:15:47,380 --> 00:15:51,370
that do editing that do truncation that

482
00:15:49,389 --> 00:15:54,250
do chop-chop tax to all kinds of things

483
00:15:51,370 --> 00:15:57,639
the point here is we don't care

484
00:15:54,250 --> 00:15:59,709
from our perspective s is this opaque

485
00:15:57,639 --> 00:16:01,750
string it can specify any set of

486
00:15:59,709 --> 00:16:03,489
instructions to these two functions we

487
00:16:01,750 --> 00:16:04,779
don't care about the nature of s we care

488
00:16:03,490 --> 00:16:07,149
about the description of the functions

489
00:16:04,779 --> 00:16:08,560
as we go forward so now that we have

490
00:16:07,149 --> 00:16:10,360
these ingredients let's talk about a

491
00:16:08,560 --> 00:16:13,119
very high level what this technique

492
00:16:10,360 --> 00:16:15,160
looks like so when we start the attack

493
00:16:13,120 --> 00:16:17,500
we have a set of initial constraints

494
00:16:15,160 --> 00:16:18,910
it's called this G 0 this formula

495
00:16:17,500 --> 00:16:21,130
basically tells us everything that we

496
00:16:18,910 --> 00:16:23,560
currently know about the plain text that

497
00:16:21,130 --> 00:16:25,000
underlies the cipher text now G 0 might

498
00:16:23,560 --> 00:16:26,529
be null we might not have any

499
00:16:25,000 --> 00:16:28,389
information or we meant no it's a valid

500
00:16:26,529 --> 00:16:30,939
cipher text and that sort of restricts

501
00:16:28,389 --> 00:16:32,589
the space a bit this really terrible

502
00:16:30,940 --> 00:16:35,110
visualization my students call this this

503
00:16:32,589 --> 00:16:37,329
the amoeba basically just gives us the

504
00:16:35,110 --> 00:16:39,100
set of messages that could be valid I've

505
00:16:37,329 --> 00:16:40,899
cheated a little bit by showing you that

506
00:16:39,100 --> 00:16:42,220
one of these is actually M star but we

507
00:16:40,899 --> 00:16:44,319
don't know that information when we were

508
00:16:42,220 --> 00:16:45,910
on this attack so we start with our

509
00:16:44,319 --> 00:16:48,399
initial constraints our high-level goal

510
00:16:45,910 --> 00:16:50,709
is to spit out an experiment in this

511
00:16:48,399 --> 00:16:53,199
case an experiment is a concrete malee

512
00:16:50,709 --> 00:16:55,300
ation instruction string s that we can

513
00:16:53,199 --> 00:16:57,609
use to maul the target ciphertext and

514
00:16:55,300 --> 00:16:58,569
submits the Oracle and the goal is we

515
00:16:57,610 --> 00:17:01,029
want to come up with an experiment

516
00:16:58,569 --> 00:17:02,979
that's going to eliminate some of these

517
00:17:01,029 --> 00:17:04,809
candidate plaintext messages so we

518
00:17:02,980 --> 00:17:07,750
gradually reduce our space down until we

519
00:17:04,809 --> 00:17:10,510
get the actual M star the real question

520
00:17:07,750 --> 00:17:12,640
is how do we identify the experimental

521
00:17:10,510 --> 00:17:13,929
string s what do we do how do we

522
00:17:12,640 --> 00:17:15,250
guarantee that we come up with a string

523
00:17:13,929 --> 00:17:17,319
that's useful we could pick at random

524
00:17:15,250 --> 00:17:20,319
but these strings are large if we have

525
00:17:17,319 --> 00:17:22,449
let's say a 512 bit long counter mode

526
00:17:20,319 --> 00:17:25,089
encrypted message there are a lot of

527
00:17:22,449 --> 00:17:26,740
possible malee ation instruction strings

528
00:17:25,089 --> 00:17:28,569
there are 2 to the 512 approximately we

529
00:17:26,740 --> 00:17:30,909
can't just guess we have to do this in a

530
00:17:28,569 --> 00:17:33,820
principled way so the way we do it is as

531
00:17:30,909 --> 00:17:35,830
follows what we do is we ask the solver

532
00:17:33,820 --> 00:17:37,780
given our knowledge of G 0 we ask it to

533
00:17:35,830 --> 00:17:40,240
find 2 different messages we're gonna

534
00:17:37,780 --> 00:17:41,649
call them m0 this is a toy example this

535
00:17:40,240 --> 00:17:43,630
will not be efficient but this

536
00:17:41,650 --> 00:17:45,640
inefficient approach works as follows we

537
00:17:43,630 --> 00:17:48,309
ask the solver to come up with 3 bit

538
00:17:45,640 --> 00:17:50,049
vectors one of them represents a first

539
00:17:48,309 --> 00:17:51,789
candidate plaintext m0

540
00:17:50,049 --> 00:17:54,190
drawn from this set the second one

541
00:17:51,789 --> 00:17:56,590
represents a second m1 also drawn from

542
00:17:54,190 --> 00:17:59,649
the set they have to be different and a

543
00:17:56,590 --> 00:18:01,959
Mallee ation instruction string s that

544
00:17:59,649 --> 00:18:04,840
has a specific property and the property

545
00:18:01,960 --> 00:18:07,570
is this if we were to run an experiment

546
00:18:04,840 --> 00:18:10,299
using this this candidate palliation

547
00:18:07,570 --> 00:18:12,100
string s we would be guaranteed to get

548
00:18:10,299 --> 00:18:14,769
either a 0 or a 1 result from the

549
00:18:12,100 --> 00:18:16,928
auricle we could use that result then to

550
00:18:14,769 --> 00:18:19,029
add a new constraint to the existing

551
00:18:16,929 --> 00:18:21,190
constraint system and what we require is

552
00:18:19,029 --> 00:18:23,769
that adding that new constraint will

553
00:18:21,190 --> 00:18:26,109
definitively rule out one of these two

554
00:18:23,769 --> 00:18:28,359
messages so roughly speaking we're just

555
00:18:26,109 --> 00:18:29,918
going to basically enforce this equation

556
00:18:28,359 --> 00:18:31,210
on the solver solvers are good at

557
00:18:29,919 --> 00:18:33,340
solving this kind of thing and then we

558
00:18:31,210 --> 00:18:35,470
just ask it to do that terrific it comes

559
00:18:33,340 --> 00:18:37,988
up with some concrete value s we now

560
00:18:35,470 --> 00:18:39,639
conduct the experiment we send we mall

561
00:18:37,989 --> 00:18:42,009
the ciphertext and we send it off to the

562
00:18:39,639 --> 00:18:44,649
Oracle and the end result is we get back

563
00:18:42,009 --> 00:18:47,259
a concrete bit B from the Oracle we add

564
00:18:44,649 --> 00:18:49,299
a new constraint of this form we add it

565
00:18:47,259 --> 00:18:52,840
to g0 to make the next iteration of the

566
00:18:49,299 --> 00:18:54,820
constraint system and we're done so this

567
00:18:52,840 --> 00:18:59,230
is a beautiful attack if you run it on a

568
00:18:54,820 --> 00:19:01,330
plain text of size 2 to the 24 it runs

569
00:18:59,230 --> 00:19:03,489
in less than an hour it's incredibly

570
00:19:01,330 --> 00:19:05,799
cool you can do it if you run it on a

571
00:19:03,489 --> 00:19:08,559
plain text space of size 2 to the 128th

572
00:19:05,799 --> 00:19:10,509
it does not ever come back and the

573
00:19:08,559 --> 00:19:12,279
reason is obvious right all we've really

574
00:19:10,509 --> 00:19:14,049
guaranteed is that at least one

575
00:19:12,279 --> 00:19:15,730
candidate plain text is going to be

576
00:19:14,049 --> 00:19:17,590
eliminated each round of this process

577
00:19:15,730 --> 00:19:19,659
that's incredibly stupid if we have 2 to

578
00:19:17,590 --> 00:19:21,100
the 128th candidate plain text will be

579
00:19:19,659 --> 00:19:22,960
running this forever we might get lucky

580
00:19:21,100 --> 00:19:25,330
some of these queries might eliminate

581
00:19:22,960 --> 00:19:26,529
many possible values but we're not going

582
00:19:25,330 --> 00:19:28,989
to be doing this in any reasonable

583
00:19:26,529 --> 00:19:32,619
amount of time so this does guarantee

584
00:19:28,989 --> 00:19:33,879
progress but it's not very efficient so

585
00:19:32,619 --> 00:19:36,220
we need to make this more efficient so

586
00:19:33,879 --> 00:19:38,019
we need to maximize the cut basically we

587
00:19:36,220 --> 00:19:40,359
need to make sure that as many plain

588
00:19:38,019 --> 00:19:43,720
texts get eliminated at each set as

589
00:19:40,359 --> 00:19:46,119
possible so here is the if we didn't

590
00:19:43,720 --> 00:19:49,119
care about the limitations of actual

591
00:19:46,119 --> 00:19:50,738
solvers it's a very obvious and simple

592
00:19:49,119 --> 00:19:52,238
solution what we want to do is instead

593
00:19:50,739 --> 00:19:55,059
of saying find me two different messages

594
00:19:52,239 --> 00:19:57,070
and omalley ation string we just asked

595
00:19:55,059 --> 00:20:00,580
the solver find me two different subsets

596
00:19:57,070 --> 00:20:02,590
and make them as large as possible make

597
00:20:00,580 --> 00:20:04,000
sure that every single candidate plain

598
00:20:02,590 --> 00:20:06,340
text within a given subs

599
00:20:04,000 --> 00:20:08,200
shares the property that you know that

600
00:20:06,340 --> 00:20:10,600
first candidate plaintext would have

601
00:20:08,200 --> 00:20:13,120
meaning that all of the values in one

602
00:20:10,600 --> 00:20:15,639
subset will be eliminated when we get a

603
00:20:13,120 --> 00:20:16,899
concrete result from the Oracle if we

604
00:20:15,640 --> 00:20:18,760
make sure that we get these large

605
00:20:16,900 --> 00:20:20,530
classes of subsets and we can eliminate

606
00:20:18,760 --> 00:20:22,660
one of those two subsets they're

607
00:20:20,530 --> 00:20:24,700
disjoint we can eliminate them after

608
00:20:22,660 --> 00:20:26,230
each query and we make them very large

609
00:20:24,700 --> 00:20:27,970
then we're gradually going we're going

610
00:20:26,230 --> 00:20:30,130
to much more quickly winnow down the

611
00:20:27,970 --> 00:20:32,170
space and after a much smaller number of

612
00:20:30,130 --> 00:20:35,380
queries we're going to arrive at the

613
00:20:32,170 --> 00:20:38,530
candidate plain text itself or quit so

614
00:20:35,380 --> 00:20:40,090
that makes sense okay could if we lived

615
00:20:38,530 --> 00:20:42,040
in a world where this was actually the

616
00:20:40,090 --> 00:20:43,689
way we could use solvers this would be a

617
00:20:42,040 --> 00:20:45,399
great solution we just have to make sure

618
00:20:43,690 --> 00:20:47,410
the size is as large as possible it

619
00:20:45,400 --> 00:20:49,600
becomes an optimization problem we tell

620
00:20:47,410 --> 00:20:52,500
the solver just find the set that

621
00:20:49,600 --> 00:20:55,240
matches these properties and maximize it

622
00:20:52,500 --> 00:20:57,460
but in the world of Theory solvers and

623
00:20:55,240 --> 00:20:59,320
Sat solvers nothing is good like

624
00:20:57,460 --> 00:21:01,570
everything is bad everything you want to

625
00:20:59,320 --> 00:21:04,030
do beyond simple equations turns out to

626
00:21:01,570 --> 00:21:06,129
be really really hard to do and it turns

627
00:21:04,030 --> 00:21:08,410
out that that kind of thing is not easy

628
00:21:06,130 --> 00:21:10,360
at all to do so we have to think a

629
00:21:08,410 --> 00:21:12,880
little bit harder about the way we do it

630
00:21:10,360 --> 00:21:14,949
so there do exist this is the good news

631
00:21:12,880 --> 00:21:17,110
there exist SMT and Sat solvers that can

632
00:21:14,950 --> 00:21:18,640
reason over sets their experimental

633
00:21:17,110 --> 00:21:19,840
there's one out of Stanford there are a

634
00:21:18,640 --> 00:21:22,030
couple of others that have tried to add

635
00:21:19,840 --> 00:21:24,820
set logic to the first-order logic that

636
00:21:22,030 --> 00:21:26,320
the the solver handles the problem is

637
00:21:24,820 --> 00:21:29,230
that the sets I'm talking about our

638
00:21:26,320 --> 00:21:30,310
small sets they're sets that like you

639
00:21:29,230 --> 00:21:32,920
know the number of people in this room

640
00:21:30,310 --> 00:21:35,889
kind of sets not sets like 2 to the

641
00:21:32,920 --> 00:21:37,960
128th or 2 to the 256 or larger when we

642
00:21:35,890 --> 00:21:40,180
start to talk about large plaintext

643
00:21:37,960 --> 00:21:42,460
spaces we need to reason over very very

644
00:21:40,180 --> 00:21:45,070
interestingly large sets and this is not

645
00:21:42,460 --> 00:21:46,390
going to work at all and worse even if

646
00:21:45,070 --> 00:21:48,250
we start working working with those set

647
00:21:46,390 --> 00:21:51,070
solvers we don't have a notion of set

648
00:21:48,250 --> 00:21:53,230
size solution size maximization you

649
00:21:51,070 --> 00:21:55,330
could maximize variables but you don't

650
00:21:53,230 --> 00:21:57,550
have a way to say find me the solution

651
00:21:55,330 --> 00:21:59,830
that has the most or find me a value s

652
00:21:57,550 --> 00:22:01,720
that gives me the largest cut for these

653
00:21:59,830 --> 00:22:03,300
two variables doesn't work like that or

654
00:22:01,720 --> 00:22:06,070
at least most of the time it doesn't and

655
00:22:03,300 --> 00:22:07,300
things get worse they get like much

656
00:22:06,070 --> 00:22:09,429
worse and by the way you have to

657
00:22:07,300 --> 00:22:12,129
understand I'm coming at this with zero

658
00:22:09,430 --> 00:22:15,070
knowledge of theory solving and learning

659
00:22:12,130 --> 00:22:16,480
like way too much as I go in it turns

660
00:22:15,070 --> 00:22:17,260
out that this problem even the problem

661
00:22:16,480 --> 00:22:19,510
of counting

662
00:22:17,260 --> 00:22:21,220
the number of solutions to a given

663
00:22:19,510 --> 00:22:22,629
constraint formulas a very very hard

664
00:22:21,220 --> 00:22:24,820
problem and then solver community this

665
00:22:22,630 --> 00:22:26,380
is known as model counting and model

666
00:22:24,820 --> 00:22:28,240
counting is something where there is an

667
00:22:26,380 --> 00:22:29,530
enormous amount of work some of its

668
00:22:28,240 --> 00:22:32,200
successful and some of it less

669
00:22:29,530 --> 00:22:33,910
successful this problem is actually a

670
00:22:32,200 --> 00:22:36,010
version of the Sharps at problem and

671
00:22:33,910 --> 00:22:37,750
Sharpe said is theoretically actually

672
00:22:36,010 --> 00:22:38,230
pretty hard it's strictly harder than

673
00:22:37,750 --> 00:22:40,240
SAP

674
00:22:38,230 --> 00:22:42,070
it's sharp P complete so we've kind of

675
00:22:40,240 --> 00:22:44,380
wandered into a domain that sort of like

676
00:22:42,070 --> 00:22:46,030
dragons are all around us just by trying

677
00:22:44,380 --> 00:22:48,010
to tackle this problem of just counting

678
00:22:46,030 --> 00:22:49,600
forget about the optimization but the

679
00:22:48,010 --> 00:22:50,710
great news about the solver communities

680
00:22:49,600 --> 00:22:52,780
they don't care about whether something

681
00:22:50,710 --> 00:22:54,520
is np-complete or pshhh are complete

682
00:22:52,780 --> 00:22:56,440
doesn't matter start be complete they're

683
00:22:54,520 --> 00:22:57,850
willing to try so there are a bunch of

684
00:22:56,440 --> 00:22:59,950
solutions out there that do something

685
00:22:57,850 --> 00:23:01,300
called exact model counting when you

686
00:22:59,950 --> 00:23:03,220
think about how a solver works it's

687
00:23:01,300 --> 00:23:04,480
basically reasoning over a large tree of

688
00:23:03,220 --> 00:23:06,130
possible solutions it's trying to

689
00:23:04,480 --> 00:23:08,920
eliminate as many solutions as quickly

690
00:23:06,130 --> 00:23:10,690
as possible and you can if you're lucky

691
00:23:08,920 --> 00:23:13,270
in the fact that all of the solutions

692
00:23:10,690 --> 00:23:15,610
that satisfy you are a constraint

693
00:23:13,270 --> 00:23:17,710
formula live in a particular sub tree

694
00:23:15,610 --> 00:23:19,899
you can get lucky and you can be able to

695
00:23:17,710 --> 00:23:21,850
count that very efficiently if you're

696
00:23:19,900 --> 00:23:23,380
not lucky and if you happen to have a

697
00:23:21,850 --> 00:23:24,939
particular constraint formula where

698
00:23:23,380 --> 00:23:27,970
these satisfying assignments to that

699
00:23:24,940 --> 00:23:30,430
formula are sparse and finally

700
00:23:27,970 --> 00:23:32,320
distributed all over the tree it's

701
00:23:30,430 --> 00:23:34,150
actually very hard to do this kind of

702
00:23:32,320 --> 00:23:35,620
counting it often just fails and the

703
00:23:34,150 --> 00:23:37,600
problems that we're dealing with here

704
00:23:35,620 --> 00:23:39,189
tend to be the kind the latter kind the

705
00:23:37,600 --> 00:23:41,139
kind that are not well distributed for

706
00:23:39,190 --> 00:23:42,850
exact model counting so this approach

707
00:23:41,140 --> 00:23:45,220
probably is not viable maybe in the

708
00:23:42,850 --> 00:23:46,990
future it will be so when you can't do

709
00:23:45,220 --> 00:23:48,880
something exactly the obvious answer is

710
00:23:46,990 --> 00:23:50,380
to approximate it and we can deal with

711
00:23:48,880 --> 00:23:51,880
approximation we're just trying to make

712
00:23:50,380 --> 00:23:53,500
something more efficient so maybe we can

713
00:23:51,880 --> 00:23:55,810
find a way to do it approximately that

714
00:23:53,500 --> 00:23:57,250
gives us a pretty good solution and the

715
00:23:55,810 --> 00:23:58,929
great news is there are some really

716
00:23:57,250 --> 00:24:00,670
really efficient approximate model

717
00:23:58,930 --> 00:24:05,050
counting techniques that work with

718
00:24:00,670 --> 00:24:07,270
existing solvers the old idea is the the

719
00:24:05,050 --> 00:24:09,490
basic idea the one that is most commonly

720
00:24:07,270 --> 00:24:12,700
used with a lot of refinements is do two

721
00:24:09,490 --> 00:24:14,650
valiant advisor Ani from the 1980s even

722
00:24:12,700 --> 00:24:16,750
before solvers were a thing it's a

723
00:24:14,650 --> 00:24:18,520
really kind of cute obvious in

724
00:24:16,750 --> 00:24:20,110
retrospect and I hate to say obvious

725
00:24:18,520 --> 00:24:21,910
it's the worst thing to say but like

726
00:24:20,110 --> 00:24:23,379
it's so elegant that you think why

727
00:24:21,910 --> 00:24:26,200
didn't I think of that like five minutes

728
00:24:23,380 --> 00:24:27,580
ago the basic idea is this you start

729
00:24:26,200 --> 00:24:29,470
with some constraint formally you want

730
00:24:27,580 --> 00:24:31,179
to determine whether there are

731
00:24:29,470 --> 00:24:34,090
approximately two to the N

732
00:24:31,180 --> 00:24:35,710
possible solutions for that formula well

733
00:24:34,090 --> 00:24:37,149
if you just go and you ask a solver

734
00:24:35,710 --> 00:24:38,950
whether there's a solution it will come

735
00:24:37,150 --> 00:24:42,130
up with you know either one or it will

736
00:24:38,950 --> 00:24:44,080
say unset so what we have to do is we

737
00:24:42,130 --> 00:24:46,480
have to add some additional constraints

738
00:24:44,080 --> 00:24:48,610
that reduce the number of possible

739
00:24:46,480 --> 00:24:49,810
solutions it seems obvious so if we want

740
00:24:48,610 --> 00:24:52,510
to know if there are two to the end

741
00:24:49,810 --> 00:24:54,490
possible solutions we want to add some

742
00:24:52,510 --> 00:24:56,680
constraints that reduce the number of

743
00:24:54,490 --> 00:24:59,740
possible solutions by approximately a

744
00:24:56,680 --> 00:25:01,120
factor of two to the end it seems easy

745
00:24:59,740 --> 00:25:03,520
enough but we need to do it in a way

746
00:25:01,120 --> 00:25:05,860
that we are reducing the number of

747
00:25:03,520 --> 00:25:08,110
solutions uniformly so we're not going

748
00:25:05,860 --> 00:25:09,550
to be dependent on the structure of the

749
00:25:08,110 --> 00:25:12,340
underlying data and the way you can do

750
00:25:09,550 --> 00:25:14,050
this is using pairwise independent hash

751
00:25:12,340 --> 00:25:15,790
functions so basically using universal

752
00:25:14,050 --> 00:25:18,190
hash functions which turn out to be very

753
00:25:15,790 --> 00:25:19,480
easy to implement using parity checks or

754
00:25:18,190 --> 00:25:22,390
parity constraints you basically

755
00:25:19,480 --> 00:25:24,220
construct a series of n universal hash

756
00:25:22,390 --> 00:25:26,230
functions each of which outputs a bit

757
00:25:24,220 --> 00:25:28,030
you add those on to your initial

758
00:25:26,230 --> 00:25:30,850
constraint formula and then you run the

759
00:25:28,030 --> 00:25:33,010
Sat solver on that revised formula if

760
00:25:30,850 --> 00:25:35,110
you get a satisfying solution the logic

761
00:25:33,010 --> 00:25:37,060
is that you should have approximately 2

762
00:25:35,110 --> 00:25:38,229
to the N underlying solutions to the

763
00:25:37,060 --> 00:25:40,120
original equation seems pretty

764
00:25:38,230 --> 00:25:41,770
reasonable its probabilistic it doesn't

765
00:25:40,120 --> 00:25:43,750
know his work sometimes you have to run

766
00:25:41,770 --> 00:25:45,220
multiple trials to see if your you can

767
00:25:43,750 --> 00:25:46,720
increase the probability of getting a

768
00:25:45,220 --> 00:25:48,940
good solution but roughly speaking

769
00:25:46,720 --> 00:25:50,350
that's it it's a beautiful and simple

770
00:25:48,940 --> 00:25:53,050
technique and it has been used for

771
00:25:50,350 --> 00:25:54,399
counting when it comes to optimization

772
00:25:53,050 --> 00:25:55,930
it's a little trickier to actually

773
00:25:54,400 --> 00:25:58,060
figure out what the underlying theory is

774
00:25:55,930 --> 00:26:00,280
but it turns out empirically it just

775
00:25:58,060 --> 00:26:02,379
works in a really kind of lovely way so

776
00:26:00,280 --> 00:26:04,930
what we do is we modify our original

777
00:26:02,380 --> 00:26:08,110
idea from a few slides ago we take this

778
00:26:04,930 --> 00:26:10,810
idea of findme m0 and m1 as well as a

779
00:26:08,110 --> 00:26:13,689
Mallee ation instruction string s but

780
00:26:10,810 --> 00:26:17,500
now we add n hash constraints to each of

781
00:26:13,690 --> 00:26:18,970
the values m0 and m1 which tells us that

782
00:26:17,500 --> 00:26:21,280
we should only get a Mallee ation

783
00:26:18,970 --> 00:26:22,870
instruction string back if we are

784
00:26:21,280 --> 00:26:25,090
actually identifying not just an

785
00:26:22,870 --> 00:26:27,250
individual message for each case but a

786
00:26:25,090 --> 00:26:30,340
large set of size approximately two to

787
00:26:27,250 --> 00:26:32,950
the N if we don't find a solution for

788
00:26:30,340 --> 00:26:35,500
this new revised equation we reduce N

789
00:26:32,950 --> 00:26:37,510
and we try again so n gradually falls

790
00:26:35,500 --> 00:26:40,060
down and were identifying looking for

791
00:26:37,510 --> 00:26:42,370
smaller and smaller cut sets until

792
00:26:40,060 --> 00:26:44,530
hopefully we find one and then we use

793
00:26:42,370 --> 00:26:46,719
the resulting Mally ation string which

794
00:26:44,530 --> 00:26:48,879
reduce the space by a significant amount

795
00:26:46,720 --> 00:26:50,950
and so this kind of eventually gives us

796
00:26:48,880 --> 00:26:52,420
a new algorithm this is the basics of

797
00:26:50,950 --> 00:26:54,250
our algorithm there's a lot of detail in

798
00:26:52,420 --> 00:26:57,420
this in terms of the number of trials we

799
00:26:54,250 --> 00:26:59,560
have to run how we build the the actual

800
00:26:57,420 --> 00:27:05,320
queries we make to the solver but this

801
00:26:59,560 --> 00:27:08,470
is kind of the basic idea okay so this

802
00:27:05,320 --> 00:27:11,050
is the first I would say 10% of the work

803
00:27:08,470 --> 00:27:12,400
and everything else comes down to agony

804
00:27:11,050 --> 00:27:14,020
it comes down to the fact that SAP

805
00:27:12,400 --> 00:27:15,610
solvers are like the worst thing that

806
00:27:14,020 --> 00:27:17,980
human beings I started with the idea

807
00:27:15,610 --> 00:27:19,330
that sad solvers are magical and it

808
00:27:17,980 --> 00:27:20,770
turns out that when you actually have to

809
00:27:19,330 --> 00:27:23,620
use them like Sat solvers are

810
00:27:20,770 --> 00:27:25,060
horrifyingly bad so we started out by

811
00:27:23,620 --> 00:27:27,399
trying to work with a bunch of different

812
00:27:25,060 --> 00:27:27,909
research and production SMT and Sat

813
00:27:27,400 --> 00:27:29,260
solvers

814
00:27:27,910 --> 00:27:30,910
but I hope nobody here is offended by

815
00:27:29,260 --> 00:27:32,230
that sorry if you work on solvers

816
00:27:30,910 --> 00:27:33,630
they're wonderful you're the best I'm

817
00:27:32,230 --> 00:27:35,920
sorry I didn't mean anything by that

818
00:27:33,630 --> 00:27:38,380
we started by working through a bunch of

819
00:27:35,920 --> 00:27:39,880
these we found that some of them were

820
00:27:38,380 --> 00:27:42,220
really good but unfortunately they

821
00:27:39,880 --> 00:27:44,380
didn't handle the Gaussian reduction

822
00:27:42,220 --> 00:27:46,000
that we need to do X or these very

823
00:27:44,380 --> 00:27:47,590
complex X or constraints very

824
00:27:46,000 --> 00:27:49,450
efficiently like XIII for example

825
00:27:47,590 --> 00:27:51,040
doesn't handle X ORS there's an

826
00:27:49,450 --> 00:27:53,410
exponential increase in the number of

827
00:27:51,040 --> 00:27:55,420
gates if you feed it big piles of parity

828
00:27:53,410 --> 00:27:58,390
constraints they get exponentially blown

829
00:27:55,420 --> 00:27:59,860
up into much larger CNF formula which

830
00:27:58,390 --> 00:28:02,380
take forever to solve so it's totally

831
00:27:59,860 --> 00:28:03,969
unworkable there's basically one solver

832
00:28:02,380 --> 00:28:05,230
out there called crypto mini Sat that

833
00:28:03,970 --> 00:28:07,390
can handle this kind of stuff very

834
00:28:05,230 --> 00:28:11,080
efficiently so we tried to use that it

835
00:28:07,390 --> 00:28:13,720
connects to a an SMT solver called SMT

836
00:28:11,080 --> 00:28:15,129
we tried that unfortunately we started

837
00:28:13,720 --> 00:28:18,040
to realize that we were working in a

838
00:28:15,130 --> 00:28:19,930
domain of solver queries that like

839
00:28:18,040 --> 00:28:22,300
nobody else was working with and we knew

840
00:28:19,930 --> 00:28:25,390
this when we started feeding bit vectors

841
00:28:22,300 --> 00:28:27,700
into the SMT solver that were of size 65

842
00:28:25,390 --> 00:28:30,310
bits and the solver began to just

843
00:28:27,700 --> 00:28:31,450
completely seg fault and it turned out

844
00:28:30,310 --> 00:28:33,280
that the people who were developing

845
00:28:31,450 --> 00:28:35,980
these solvers had made a specialized

846
00:28:33,280 --> 00:28:38,620
data structure for bit vectors under 64

847
00:28:35,980 --> 00:28:40,330
bits and bit vectors over 64 bits and

848
00:28:38,620 --> 00:28:42,729
had apparently never tested the bit

849
00:28:40,330 --> 00:28:44,409
vectors over 64 bits because it was done

850
00:28:42,730 --> 00:28:46,030
by a grad student so we went back in we

851
00:28:44,410 --> 00:28:48,460
said this will be easy to fix turned out

852
00:28:46,030 --> 00:28:49,899
it was actually a giant 1 million line

853
00:28:48,460 --> 00:28:51,550
commit I don't even know what of 1

854
00:28:49,900 --> 00:28:53,620
million line commit is maybe it's code

855
00:28:51,550 --> 00:28:55,419
prettification with thousands of

856
00:28:53,620 --> 00:28:57,010
different references and not like a data

857
00:28:55,420 --> 00:28:57,890
structure like you or I would think of a

858
00:28:57,010 --> 00:29:00,890
data structure but

859
00:28:57,890 --> 00:29:03,590
actually doing pointer arithmetic every

860
00:29:00,890 --> 00:29:05,390
time you touch this pointer kind of data

861
00:29:03,590 --> 00:29:07,909
structure so it was really bad

862
00:29:05,390 --> 00:29:09,140
this is not to crap on a particular

863
00:29:07,910 --> 00:29:11,000
solver I mean people are working on

864
00:29:09,140 --> 00:29:12,679
these in their spare time it's just to

865
00:29:11,000 --> 00:29:14,990
point out that like for this particular

866
00:29:12,679 --> 00:29:16,970
scale of problem let me give you one

867
00:29:14,990 --> 00:29:18,559
more reason why I'm sort of surprised by

868
00:29:16,970 --> 00:29:21,110
this there was a paper at use Neck

869
00:29:18,559 --> 00:29:22,190
security that was doing fuzzing and they

870
00:29:21,110 --> 00:29:25,428
were doing fuzzing one of their targets

871
00:29:22,190 --> 00:29:28,070
was one of these solvers and for me I

872
00:29:25,429 --> 00:29:29,809
was like why do you have to fuzz them

873
00:29:28,070 --> 00:29:31,580
just ask them to solve a problem that

874
00:29:29,809 --> 00:29:33,770
has more than 64 bits like this is not

875
00:29:31,580 --> 00:29:34,549
like a hard thing so it turns out that

876
00:29:33,770 --> 00:29:36,110
when you're dealing with these

877
00:29:34,549 --> 00:29:38,840
particular class of problems they're not

878
00:29:36,110 --> 00:29:40,189
well tested at all z3 is very good the

879
00:29:38,840 --> 00:29:41,449
rest of everything else is kind of the

880
00:29:40,190 --> 00:29:44,600
Wild West so we had to do a lot of

881
00:29:41,450 --> 00:29:47,120
painful fixes we sent some code upstream

882
00:29:44,600 --> 00:29:51,500
ultimately we decided on this really ad

883
00:29:47,120 --> 00:29:54,889
hoc jerry-rigged solution of using z3 to

884
00:29:51,500 --> 00:29:57,500
output CNF files that are then eaten by

885
00:29:54,890 --> 00:29:59,440
crypto mini sat and this unfortunately

886
00:29:57,500 --> 00:30:02,870
reduces our performance by 90 percent

887
00:29:59,440 --> 00:30:04,730
which turns out to be better than using

888
00:30:02,870 --> 00:30:05,870
any of the other combination of solvers

889
00:30:04,730 --> 00:30:07,790
so we're working on a direct integration

890
00:30:05,870 --> 00:30:09,590
between z3 and crypto mini sat because

891
00:30:07,790 --> 00:30:11,299
it's a cool tool but we just haven't

892
00:30:09,590 --> 00:30:13,699
done that so our results are much slower

893
00:30:11,299 --> 00:30:15,049
than they should should be ok so the

894
00:30:13,700 --> 00:30:17,419
result of all this is we built a tool

895
00:30:15,049 --> 00:30:19,639
called delphinium delphinium is

896
00:30:17,419 --> 00:30:22,400
ultimately intended to be a practical

897
00:30:19,640 --> 00:30:24,380
tool that cryptographic cryptographers

898
00:30:22,400 --> 00:30:26,900
can go out and use to actually build

899
00:30:24,380 --> 00:30:28,700
exploits it's not quite there yet but I

900
00:30:26,900 --> 00:30:31,040
want to show you kind of some examples

901
00:30:28,700 --> 00:30:33,169
of what it can do today and hope that it

902
00:30:31,040 --> 00:30:36,020
can do more in the future so we saw the

903
00:30:33,169 --> 00:30:37,669
pkcs we saw the TLS padding example the

904
00:30:36,020 --> 00:30:39,889
CBC mode padding where you actually

905
00:30:37,669 --> 00:30:42,230
throw padding bytes onto the end of it

906
00:30:39,890 --> 00:30:44,600
on the end of a cipher block this is

907
00:30:42,230 --> 00:30:47,630
just a quick overview of kind of what

908
00:30:44,600 --> 00:30:50,570
that looks like the string down here the

909
00:30:47,630 --> 00:30:52,580
bottom string is a plaintext that has

910
00:30:50,570 --> 00:30:54,260
several bytes of message followed by

911
00:30:52,580 --> 00:30:57,199
five bytes of padding each of these

912
00:30:54,260 --> 00:30:59,330
bytes has to be 5 if you go to an

913
00:30:57,200 --> 00:31:01,640
undergraduate you say go implement a

914
00:30:59,330 --> 00:31:03,110
pkcs7 padding Oracle attack what they're

915
00:31:01,640 --> 00:31:05,540
gonna do is something like this they're

916
00:31:03,110 --> 00:31:08,330
gonna come up with a Mallee ation string

917
00:31:05,540 --> 00:31:10,159
that changes those bytes of padding by

918
00:31:08,330 --> 00:31:11,389
causing them to increments your

919
00:31:10,160 --> 00:31:13,820
plaintext Mally ation

920
00:31:11,389 --> 00:31:15,859
is gonna be the xor function that causes

921
00:31:13,820 --> 00:31:18,049
them all ink to increment to a six and

922
00:31:15,859 --> 00:31:19,609
then what's gonna happen is the format

923
00:31:18,049 --> 00:31:20,779
Oracle is gonna look at those bytes and

924
00:31:19,609 --> 00:31:22,999
compare them to the last byte of the

925
00:31:20,779 --> 00:31:24,079
message and if that last byte of the

926
00:31:22,999 --> 00:31:26,629
message is six you're gonna get a

927
00:31:24,079 --> 00:31:28,820
positive result otherwise you won't and

928
00:31:26,629 --> 00:31:31,968
so to fix that problem you have to

929
00:31:28,820 --> 00:31:34,070
iterate through every possible Mally

930
00:31:31,969 --> 00:31:35,570
ation of that last message byte until

931
00:31:34,070 --> 00:31:38,089
you get a match and that tells you what

932
00:31:35,570 --> 00:31:40,369
the last message byte is if you actually

933
00:31:38,089 --> 00:31:43,129
go out and implement that thing as a

934
00:31:40,369 --> 00:31:44,509
human being and you show and here I'm

935
00:31:43,129 --> 00:31:46,029
just gonna use an XOR based stream

936
00:31:44,509 --> 00:31:48,769
cipher and you show what this looks like

937
00:31:46,029 --> 00:31:50,359
you get an attack trace what I'm showing

938
00:31:48,769 --> 00:31:52,519
you here is just the Mallee ation

939
00:31:50,359 --> 00:31:54,289
strings the X oars that are added to the

940
00:31:52,519 --> 00:31:55,489
cipher text that looks like this it's

941
00:31:54,289 --> 00:31:59,179
kind of intuitive and I'm gonna just

942
00:31:55,489 --> 00:32:00,950
zoom in on this what you see in the zoom

943
00:31:59,179 --> 00:32:02,929
is you see that somebody has kind of

944
00:32:00,950 --> 00:32:04,999
mauled the rightmost bytes of padding a

945
00:32:02,929 --> 00:32:06,859
little bit and they are now counting

946
00:32:04,999 --> 00:32:08,959
their way on the this sort of leftmost

947
00:32:06,859 --> 00:32:10,399
byte they're counting their way through

948
00:32:08,959 --> 00:32:12,079
all the possible solutions until they

949
00:32:10,399 --> 00:32:13,549
get lucky and find one and then they

950
00:32:12,079 --> 00:32:17,690
increment left words this is what a

951
00:32:13,549 --> 00:32:19,668
human being does so let's take our pkcs7

952
00:32:17,690 --> 00:32:21,679
padding code this is implemented in

953
00:32:19,669 --> 00:32:24,440
Python let's feed it into the solver and

954
00:32:21,679 --> 00:32:26,479
see what it starts to produce and what

955
00:32:24,440 --> 00:32:28,279
we get looks like this which actually

956
00:32:26,479 --> 00:32:29,419
isn't that surprising when you think

957
00:32:28,279 --> 00:32:33,320
about it you noticed a lot noisier

958
00:32:29,419 --> 00:32:35,179
looking at the human attack let me jump

959
00:32:33,320 --> 00:32:37,070
in it takes about the same amount of

960
00:32:35,179 --> 00:32:40,009
time in terms of queries as the human

961
00:32:37,070 --> 00:32:42,408
attack so it does develop the attack but

962
00:32:40,009 --> 00:32:43,849
it looks random right so clearly

963
00:32:42,409 --> 00:32:45,649
everything on the left side is now

964
00:32:43,849 --> 00:32:47,119
unconstrained to the solver so it's

965
00:32:45,649 --> 00:32:48,619
picking arbitrary solutions there

966
00:32:47,119 --> 00:32:51,289
instead of the pretty white space that

967
00:32:48,619 --> 00:32:52,820
we saw in the previous attack but also

968
00:32:51,289 --> 00:32:54,859
you can sort of look at this and you're

969
00:32:52,820 --> 00:32:57,889
like what's happening in that leftmost

970
00:32:54,859 --> 00:33:00,199
padding byte is it doing something new

971
00:32:57,889 --> 00:33:03,498
or is it just counting when you go and

972
00:33:00,200 --> 00:33:05,239
you actually sort these results you find

973
00:33:03,499 --> 00:33:06,799
out that actually it is just running the

974
00:33:05,239 --> 00:33:08,539
counting attack but it's doing it in the

975
00:33:06,799 --> 00:33:09,979
order it pleases so basically we have

976
00:33:08,539 --> 00:33:12,079
you know kind of ground truth that it

977
00:33:09,979 --> 00:33:14,209
rediscovers the standard padding Oracle

978
00:33:12,079 --> 00:33:15,769
attack you would expect but does it with

979
00:33:14,209 --> 00:33:16,940
about as much efficiency as a human

980
00:33:15,769 --> 00:33:18,709
being I'm just gonna show those two

981
00:33:16,940 --> 00:33:20,359
attacks next to each other so you get a

982
00:33:18,709 --> 00:33:23,029
kind of a visualization of what the

983
00:33:20,359 --> 00:33:24,570
human and the Machine - another way we

984
00:33:23,029 --> 00:33:27,899
can look at this attack is we can

985
00:33:24,570 --> 00:33:30,840
a how much of the message space gets cut

986
00:33:27,899 --> 00:33:32,820
after each query so here we have by the

987
00:33:30,840 --> 00:33:34,230
way this is just two examples so the

988
00:33:32,820 --> 00:33:35,730
difference between the speed of these is

989
00:33:34,230 --> 00:33:37,919
basically down to the fact that these

990
00:33:35,730 --> 00:33:39,240
particular runs happen to come out this

991
00:33:37,919 --> 00:33:41,159
way they can they can be faster or

992
00:33:39,240 --> 00:33:44,190
slower depending on what happens but

993
00:33:41,159 --> 00:33:46,080
here is basically the the Purple Line is

994
00:33:44,190 --> 00:33:48,179
the machine developed attack and you can

995
00:33:46,080 --> 00:33:50,820
see it starts at about two to the 120

996
00:33:48,179 --> 00:33:54,120
something possible candidates based on

997
00:33:50,820 --> 00:33:56,129
the on the left side and as it goes you

998
00:33:54,120 --> 00:33:58,168
can see it's making jumps downward by

999
00:33:56,130 --> 00:34:00,389
about a space of 2 to the 8 so it's

1000
00:33:58,169 --> 00:34:02,009
finding one byte at a time with this

1001
00:34:00,389 --> 00:34:04,080
little kind of bent downward trajectory

1002
00:34:02,009 --> 00:34:05,490
you can see that the machine developed

1003
00:34:04,080 --> 00:34:07,408
attack and the human developed attack

1004
00:34:05,490 --> 00:34:09,030
are doing basically the same thing so we

1005
00:34:07,409 --> 00:34:12,389
can actually see progress in the same

1006
00:34:09,030 --> 00:34:14,550
way so we came up with some of the other

1007
00:34:12,389 --> 00:34:16,500
examples that were new things we came up

1008
00:34:14,550 --> 00:34:18,060
with a bitwise padding scheme this

1009
00:34:16,500 --> 00:34:20,159
bitwise padding schemes a little goofy

1010
00:34:18,060 --> 00:34:22,139
it basically says at the rightmost bits

1011
00:34:20,159 --> 00:34:23,639
of the plaintext we're going to have a

1012
00:34:22,139 --> 00:34:25,889
series of bits that give the padding

1013
00:34:23,639 --> 00:34:28,230
length in bits and then every previous

1014
00:34:25,889 --> 00:34:29,520
bit is going to be set to one and then

1015
00:34:28,230 --> 00:34:31,800
you're gonna have to the left of that

1016
00:34:29,520 --> 00:34:33,119
the message what happens when we feed

1017
00:34:31,800 --> 00:34:34,589
that in this is just much easier because

1018
00:34:33,119 --> 00:34:37,379
it's a padding scheme that's guaranteed

1019
00:34:34,589 --> 00:34:40,199
to give us about one bit of information

1020
00:34:37,379 --> 00:34:41,940
per query and it happens that we get a

1021
00:34:40,199 --> 00:34:43,678
very similar-looking attack you can see

1022
00:34:41,940 --> 00:34:46,619
the solver basically coming up with

1023
00:34:43,679 --> 00:34:48,450
these queries and rapidly kind of fixing

1024
00:34:46,619 --> 00:34:49,800
individual bits of the padding and the

1025
00:34:48,449 --> 00:34:51,388
message as you go down until it

1026
00:34:49,800 --> 00:34:53,010
basically figures out the message after

1027
00:34:51,389 --> 00:34:55,200
about a hundred and fifty three three

1028
00:34:53,010 --> 00:34:56,940
queries in this case okay so the other

1029
00:34:55,199 --> 00:35:00,779
example that we have that we worked out

1030
00:34:56,940 --> 00:35:02,640
don't ask me why we did this but we know

1031
00:35:00,780 --> 00:35:05,760
that sat solvers are great at solving

1032
00:35:02,640 --> 00:35:07,230
Sudoku so imagine that you have a

1033
00:35:05,760 --> 00:35:09,599
encryption protocol that involves

1034
00:35:07,230 --> 00:35:12,270
encrypting pseudo COO boards sorry this

1035
00:35:09,599 --> 00:35:13,829
was just a ridiculous example it's a

1036
00:35:12,270 --> 00:35:15,390
small Sudoku board it's a four by four

1037
00:35:13,829 --> 00:35:17,730
Sudoku so not really killing ourselves

1038
00:35:15,390 --> 00:35:19,259
here on the size of this but we encoded

1039
00:35:17,730 --> 00:35:21,810
this four by four Sudoku board is a

1040
00:35:19,260 --> 00:35:23,730
cipher text and we basically said here

1041
00:35:21,810 --> 00:35:25,529
is the cipher text go try to solve it so

1042
00:35:23,730 --> 00:35:27,300
what the solver can do now is it knows

1043
00:35:25,530 --> 00:35:29,250
the rules of pseudo ku which is our

1044
00:35:27,300 --> 00:35:31,200
check function it can go and it can Maul

1045
00:35:29,250 --> 00:35:33,810
the ciphertext and try to switch things

1046
00:35:31,200 --> 00:35:36,299
around and what it gets back is was the

1047
00:35:33,810 --> 00:35:38,220
resulting decrypted board a valid pseudo

1048
00:35:36,300 --> 00:35:40,710
ku and what's kind of neat is

1049
00:35:38,220 --> 00:35:44,129
after seven whole queries to 4x4 board

1050
00:35:40,710 --> 00:35:45,390
it basically comes back with the actual

1051
00:35:44,130 --> 00:35:47,220
we give it a pseudo keyboard that's

1052
00:35:45,390 --> 00:35:48,569
valid it tweaks it for a while and it

1053
00:35:47,220 --> 00:35:51,089
comes back what you can see on the right

1054
00:35:48,570 --> 00:35:53,040
side is the solvers knowledge and on the

1055
00:35:51,090 --> 00:35:55,109
left side you see the actual query that

1056
00:35:53,040 --> 00:35:56,550
it's making when you decrypt the cipher

1057
00:35:55,109 --> 00:35:58,619
text and you can see it kind of like

1058
00:35:56,550 --> 00:36:00,570
fiddles around for a while gradually

1059
00:35:58,619 --> 00:36:03,210
figures out hey this particular square

1060
00:36:00,570 --> 00:36:05,310
is a 1 or a 2 or a 3 and it's knowledge

1061
00:36:03,210 --> 00:36:06,540
becomes more constrained over time and

1062
00:36:05,310 --> 00:36:08,490
then all of a sudden it has the right

1063
00:36:06,540 --> 00:36:10,830
solution so these kind of things show

1064
00:36:08,490 --> 00:36:12,000
that this works obviously we wanted to

1065
00:36:10,830 --> 00:36:14,940
things that are more interesting than

1066
00:36:12,000 --> 00:36:16,770
Sudoku this is kind of bound by

1067
00:36:14,940 --> 00:36:18,599
engineering problems right now so we're

1068
00:36:16,770 --> 00:36:19,890
working our way through it there are a

1069
00:36:18,599 --> 00:36:21,450
whole bunch of things that we also do

1070
00:36:19,890 --> 00:36:24,000
that I'm not going to show here just for

1071
00:36:21,450 --> 00:36:25,500
time obviously using these stream

1072
00:36:24,000 --> 00:36:27,780
ciphers is kind of silly we want to use

1073
00:36:25,500 --> 00:36:29,700
other modes of operation CBC is a little

1074
00:36:27,780 --> 00:36:31,470
more complicated because as Robert

1075
00:36:29,700 --> 00:36:33,750
showed when you flip a bit in a

1076
00:36:31,470 --> 00:36:36,569
particular block of a CBC ciphertext if

1077
00:36:33,750 --> 00:36:38,369
it's not the IV you trash the resulting

1078
00:36:36,570 --> 00:36:40,020
decrypted plaintext this is actually a

1079
00:36:38,369 --> 00:36:42,210
little bit hard to encode to a solver

1080
00:36:40,020 --> 00:36:43,920
you have to tell it hey you can't trust

1081
00:36:42,210 --> 00:36:45,690
any of the bits in this plaintext

1082
00:36:43,920 --> 00:36:47,130
because there's pseudo-random there's no

1083
00:36:45,690 --> 00:36:48,599
way for your Mally ation to predict

1084
00:36:47,130 --> 00:36:49,920
what's going to happen to them so we

1085
00:36:48,599 --> 00:36:51,450
have a different encoding scheme where

1086
00:36:49,920 --> 00:36:53,790
we can actually tell the solver that it

1087
00:36:51,450 --> 00:36:55,080
should not reason over those broken bits

1088
00:36:53,790 --> 00:36:56,490
and it should only reason over ones

1089
00:36:55,080 --> 00:36:58,500
where it can say for certain what's

1090
00:36:56,490 --> 00:37:00,930
happening and that actually guides the

1091
00:36:58,500 --> 00:37:04,080
Mallee ation string selection it will

1092
00:37:00,930 --> 00:37:05,609
avoid breaking ciphertext in interesting

1093
00:37:04,080 --> 00:37:07,290
ways and it will constrict it's it's

1094
00:37:05,609 --> 00:37:08,819
changes to the ciphertext to places

1095
00:37:07,290 --> 00:37:11,130
where I can actually get results so this

1096
00:37:08,820 --> 00:37:12,780
is kind of working backwards from the

1097
00:37:11,130 --> 00:37:15,150
the nature of the scheme to the actual

1098
00:37:12,780 --> 00:37:17,490
solution we also have solutions that do

1099
00:37:15,150 --> 00:37:19,140
truncation so it's much easier in some

1100
00:37:17,490 --> 00:37:21,509
cases to truncate the ciphertext size

1101
00:37:19,140 --> 00:37:23,670
either by a whole block or by a bit or a

1102
00:37:21,510 --> 00:37:25,230
bite and the solver will gladly go out

1103
00:37:23,670 --> 00:37:26,970
and it will find the right truncation

1104
00:37:25,230 --> 00:37:28,320
for you and it will go and it will make

1105
00:37:26,970 --> 00:37:30,240
its life easier we can even make the

1106
00:37:28,320 --> 00:37:32,190
solver hunt down the best truncation

1107
00:37:30,240 --> 00:37:33,598
that will reduce the amount of time it

1108
00:37:32,190 --> 00:37:36,240
takes to solve so there's a lot of work

1109
00:37:33,599 --> 00:37:38,190
there you can do there have been some

1110
00:37:36,240 --> 00:37:39,899
recent vulnerabilities that one of them

1111
00:37:38,190 --> 00:37:41,220
was an open SSL and there there are some

1112
00:37:39,900 --> 00:37:43,170
other formats that we're currently

1113
00:37:41,220 --> 00:37:44,879
running experiments on and so we're

1114
00:37:43,170 --> 00:37:47,520
trying to develop some kind of novel

1115
00:37:44,880 --> 00:37:48,720
attacks for things like gzip encryption

1116
00:37:47,520 --> 00:37:50,009
we're trying to show that you can

1117
00:37:48,720 --> 00:37:51,098
actually do not to use of encryption

1118
00:37:50,010 --> 00:37:53,259
gzip compression

1119
00:37:51,099 --> 00:37:54,489
that have some different formats and so

1120
00:37:53,259 --> 00:37:57,400
we're sort of working those through the

1121
00:37:54,489 --> 00:37:59,410
solver the reason that we don't have

1122
00:37:57,400 --> 00:38:01,630
results on those unfortunately is that

1123
00:37:59,410 --> 00:38:03,489
we haven't been able to steal enough

1124
00:38:01,630 --> 00:38:05,709
compute time to actually get these

1125
00:38:03,489 --> 00:38:07,869
things done so one of the experiences

1126
00:38:05,709 --> 00:38:09,669
that I've had in doing this work is

1127
00:38:07,869 --> 00:38:11,469
finding out for the first time in my

1128
00:38:09,670 --> 00:38:13,180
career that like I actually need to buy

1129
00:38:11,469 --> 00:38:14,890
computers instead of just relying on

1130
00:38:13,180 --> 00:38:17,109
Nadia to loan me our computers every now

1131
00:38:14,890 --> 00:38:18,459
and then which has been great in the

1132
00:38:17,109 --> 00:38:20,440
past but it turns out that these Sat

1133
00:38:18,459 --> 00:38:22,209
solvers are incredibly intensive and we

1134
00:38:20,440 --> 00:38:24,130
really we burn through a few thousand

1135
00:38:22,209 --> 00:38:25,749
dollars of Amazon time just kind of

1136
00:38:24,130 --> 00:38:27,819
getting the basic results that we have

1137
00:38:25,749 --> 00:38:29,529
so there's a huge amount of work here in

1138
00:38:27,819 --> 00:38:31,420
optimizing and we think that the value

1139
00:38:29,529 --> 00:38:32,559
of this is now we're working with some

1140
00:38:31,420 --> 00:38:34,209
of the people in the SATs Oliver

1141
00:38:32,559 --> 00:38:37,539
community to actually take these

1142
00:38:34,209 --> 00:38:39,308
problems and consider them in the design

1143
00:38:37,539 --> 00:38:41,619
and optimization optimization of their

1144
00:38:39,309 --> 00:38:43,690
solvers the problems are really

1145
00:38:41,619 --> 00:38:45,369
interesting we're working with with CNF

1146
00:38:43,690 --> 00:38:47,680
formula that are on the orders of

1147
00:38:45,369 --> 00:38:50,109
hundreds of thousands of constraints and

1148
00:38:47,680 --> 00:38:52,029
variables whereas a lot of the tests

1149
00:38:50,109 --> 00:38:54,308
that people use in Sat competitions are

1150
00:38:52,029 --> 00:38:55,959
maybe ten thousand variables so we're

1151
00:38:54,309 --> 00:38:57,579
really kind of pushing this to the outer

1152
00:38:55,959 --> 00:38:59,410
edge of what's at solvers can do right

1153
00:38:57,579 --> 00:39:01,119
now but I think there's a lot of room to

1154
00:38:59,410 --> 00:39:02,769
optimize and actually solve useful

1155
00:39:01,119 --> 00:39:04,239
cryptographic problems here there's a

1156
00:39:02,769 --> 00:39:06,488
lot of future work in terms of other

1157
00:39:04,239 --> 00:39:08,829
kinds of attack for example attacks on

1158
00:39:06,489 --> 00:39:10,539
public key crypto attacks on side

1159
00:39:08,829 --> 00:39:11,920
channels and so on so I think we're kind

1160
00:39:10,539 --> 00:39:13,089
of entering this area where we're

1161
00:39:11,920 --> 00:39:15,430
actually gonna be able to make progress

1162
00:39:13,089 --> 00:39:17,979
in building attacks but this is just a

1163
00:39:15,430 --> 00:39:20,279
first step towards that so that's all

1164
00:39:17,979 --> 00:39:27,299
thank you very much

1165
00:39:20,280 --> 00:39:31,360
[Applause]

1166
00:39:27,300 --> 00:39:33,910
Lisa hi Greg rose deck hard technologies

1167
00:39:31,360 --> 00:39:35,410
if you if people will leave with me I

1168
00:39:33,910 --> 00:39:39,540
can give you an example of a chosen

1169
00:39:35,410 --> 00:39:43,480
cipher text attack in World War 2 okay

1170
00:39:39,540 --> 00:39:48,070
the the attack that defeated the

1171
00:39:43,480 --> 00:39:51,670
Japanese fleet at Midway the the

1172
00:39:48,070 --> 00:39:56,140
Americans could decrypt the message the

1173
00:39:51,670 --> 00:39:59,800
Japanese naval traffic but they as they

1174
00:39:56,140 --> 00:40:03,910
super encrypted the locations of names

1175
00:39:59,800 --> 00:40:05,350
so so they get a message saying you know

1176
00:40:03,910 --> 00:40:07,390
the fleet's going to assemble at

1177
00:40:05,350 --> 00:40:08,980
such-and-such an island but it didn't it

1178
00:40:07,390 --> 00:40:11,500
there was a super encryption on the name

1179
00:40:08,980 --> 00:40:15,030
of the island and they couldn't get

1180
00:40:11,500 --> 00:40:17,320
around that very easily so the u.s. sent

1181
00:40:15,030 --> 00:40:20,730
messages to all of the different

1182
00:40:17,320 --> 00:40:24,940
possible islands that they had bases on

1183
00:40:20,730 --> 00:40:26,830
with DIF with instructions sorry they

1184
00:40:24,940 --> 00:40:29,380
yeah they sent messages to the island

1185
00:40:26,830 --> 00:40:31,560
saying report back that you have a

1186
00:40:29,380 --> 00:40:33,910
particular problem in the case of Midway

1187
00:40:31,560 --> 00:40:35,620
they reported back in their regular

1188
00:40:33,910 --> 00:40:39,279
report that they had a shortage of fresh

1189
00:40:35,620 --> 00:40:41,620
water and so when they decrypted the

1190
00:40:39,280 --> 00:40:44,470
naval traffic the routine naval traffic

1191
00:40:41,620 --> 00:40:47,680
that said Island X Y Zed has a shortage

1192
00:40:44,470 --> 00:40:49,330
of fresh water and another message that

1193
00:40:47,680 --> 00:40:52,629
said Island XYZ that's where we're going

1194
00:40:49,330 --> 00:40:53,920
to attack and yeah that was chosen so I

1195
00:40:52,630 --> 00:40:56,110
could text today I have heard of this

1196
00:40:53,920 --> 00:40:57,340
one I'm familiar with it the debate that

1197
00:40:56,110 --> 00:40:59,050
I've heard people have is is this a

1198
00:40:57,340 --> 00:41:00,820
chosen plaintext attack or is it chosen

1199
00:40:59,050 --> 00:41:02,650
ciphertext attacks okay I'll give you

1200
00:41:00,820 --> 00:41:04,030
that yeah no no it's tough it's really

1201
00:41:02,650 --> 00:41:06,460
hard to find like examples where the

1202
00:41:04,030 --> 00:41:08,050
u.s. actually sent traffic encrypted

1203
00:41:06,460 --> 00:41:10,120
traffic if we could find something like

1204
00:41:08,050 --> 00:41:11,710
that to the Japanese and then somehow

1205
00:41:10,120 --> 00:41:14,500
saw the response that would be amazing I

1206
00:41:11,710 --> 00:41:15,760
just bad okay yeah it's very tricky but

1207
00:41:14,500 --> 00:41:20,370
there were a lot of these kind of

1208
00:41:15,760 --> 00:41:20,370
attacks thank you

1209
00:41:22,360 --> 00:41:30,640
hi I'm Marcus Bingham from poor

1210
00:41:25,540 --> 00:41:32,800
University boham give a talk thank you

1211
00:41:30,640 --> 00:41:34,330
you've talked about the scalability

1212
00:41:32,800 --> 00:41:37,540
problems when it comes to complexity

1213
00:41:34,330 --> 00:41:39,580
like parity checks and X or are you also

1214
00:41:37,540 --> 00:41:43,090
concerned about the performance when it

1215
00:41:39,580 --> 00:41:48,009
comes to scaling the actual application

1216
00:41:43,090 --> 00:41:55,450
code like a PDF reader or email clients

1217
00:41:48,010 --> 00:41:57,460
have a lot of code and scale so I think

1218
00:41:55,450 --> 00:41:58,839
that the answer is and there was some

1219
00:41:57,460 --> 00:42:00,820
work in use neck security where people

1220
00:41:58,840 --> 00:42:02,500
were basically taking large programs and

1221
00:42:00,820 --> 00:42:05,290
what they're doing is they're extracting

1222
00:42:02,500 --> 00:42:07,570
kind of a simplified and by the way

1223
00:42:05,290 --> 00:42:09,550
simplified means still huge a simplified

1224
00:42:07,570 --> 00:42:12,220
constraint set from the program so I

1225
00:42:09,550 --> 00:42:13,480
think the direction here is not I may

1226
00:42:12,220 --> 00:42:16,899
not be answering your question properly

1227
00:42:13,480 --> 00:42:18,400
but stop me if I'm not but the basic

1228
00:42:16,900 --> 00:42:20,110
idea is yes if we just try to feed an

1229
00:42:18,400 --> 00:42:22,060
incredibly complex application code that

1230
00:42:20,110 --> 00:42:24,010
has everything in it probably not going

1231
00:42:22,060 --> 00:42:25,870
to work so the idea is to ultimately

1232
00:42:24,010 --> 00:42:28,210
marry this to symbolic execution kind of

1233
00:42:25,870 --> 00:42:30,640
techniques or we can go through and we

1234
00:42:28,210 --> 00:42:32,440
can extract at least a simplified

1235
00:42:30,640 --> 00:42:33,819
version of the the constraint formula

1236
00:42:32,440 --> 00:42:35,560
and then use these techniques to

1237
00:42:33,820 --> 00:42:37,660
actually develop the attacks so there is

1238
00:42:35,560 --> 00:42:39,430
a big direct in that were there if I can

1239
00:42:37,660 --> 00:42:40,480
follow up on this and this means you

1240
00:42:39,430 --> 00:42:42,210
need to have an hunch

1241
00:42:40,480 --> 00:42:44,770
it's part of the part of the for example

1242
00:42:42,210 --> 00:42:50,140
the back focusing on an eighth and one

1243
00:42:44,770 --> 00:42:51,550
part or a PDF powers and yes yes so I'd

1244
00:42:50,140 --> 00:42:52,839
like to live in a world where I can just

1245
00:42:51,550 --> 00:42:54,280
push those problems off to somebody else

1246
00:42:52,840 --> 00:42:56,950
that's like the best world to live in

1247
00:42:54,280 --> 00:42:58,750
but but definitely like this is if you

1248
00:42:56,950 --> 00:43:00,399
have description of the system what can

1249
00:42:58,750 --> 00:43:01,810
you do how do you get a description of

1250
00:43:00,400 --> 00:43:04,240
the system that's useful for like this

1251
00:43:01,810 --> 00:43:09,460
particular processor is a big problem

1252
00:43:04,240 --> 00:43:11,830
too okay okay I think now it's a good

1253
00:43:09,460 --> 00:43:14,350
time to have the first coffee and to

1254
00:43:11,830 --> 00:43:15,680
enter the coffee break so please let's

1255
00:43:14,350 --> 00:43:19,589
thank the speaker again

1256
00:43:15,680 --> 00:43:19,589
[Applause]

