1
00:00:04,160 --> 00:00:07,520
all right thank you

2
00:00:10,000 --> 00:00:13,200
okay so uh welcome to the fourth and and

3
00:00:13,200 --> 00:00:15,839
final session uh we've got two talks in

4
00:00:15,839 --> 00:00:17,680
this session the first of which is going

5
00:00:17,680 --> 00:00:21,039
to be incorrectly generated rsa keys

6
00:00:21,039 --> 00:00:23,039
for which we'll have a video and then

7
00:00:23,039 --> 00:00:27,320
we'll have a live q a

8
00:00:35,360 --> 00:00:37,200
hold on just a second let me find the

9
00:00:37,200 --> 00:00:38,559
right

10
00:00:38,559 --> 00:00:40,559
file

11
00:00:40,559 --> 00:00:45,078
which i should have done before

12
00:01:14,000 --> 00:01:16,400
hi i'm dan schuma from the microsoft

13
00:01:16,400 --> 00:01:18,880
research security and cryptography team

14
00:01:18,880 --> 00:01:20,799
and i'm here to talk to you guys about

15
00:01:20,799 --> 00:01:23,680
incorrectly generated rsa keys or how i

16
00:01:23,680 --> 00:01:25,600
learned to stop worrying about a bug and

17
00:01:25,600 --> 00:01:28,799
recover some plain texts

18
00:01:28,799 --> 00:01:32,079
so uh before we get into it uh i think i

19
00:01:32,079 --> 00:01:35,280
have to review rsa key generation

20
00:01:35,280 --> 00:01:37,280
which is surprising to me

21
00:01:37,280 --> 00:01:39,280
um but we're gonna get into the weeds

22
00:01:39,280 --> 00:01:40,960
with this here so

23
00:01:40,960 --> 00:01:42,159
um

24
00:01:42,159 --> 00:01:44,320
y'all have seen this before i'm assuming

25
00:01:44,320 --> 00:01:46,079
um

26
00:01:46,079 --> 00:01:47,200
but

27
00:01:47,200 --> 00:01:49,200
you know what we do is uh to generate an

28
00:01:49,200 --> 00:01:52,320
n-bit rsa key uh with a public exponent

29
00:01:52,320 --> 00:01:53,680
e

30
00:01:53,680 --> 00:01:57,600
we generate two uh random and over two

31
00:01:57,600 --> 00:01:58,399
bit

32
00:01:58,399 --> 00:01:59,920
primes p and q

33
00:01:59,920 --> 00:02:00,880
um

34
00:02:00,880 --> 00:02:02,479
and we have to make sure that p minus

35
00:02:02,479 --> 00:02:04,560
one and q minus one are both relatively

36
00:02:04,560 --> 00:02:08,479
prime to that supplied public exponent e

37
00:02:08,479 --> 00:02:10,560
we set the public modulus to be p times

38
00:02:10,560 --> 00:02:11,599
q

39
00:02:11,599 --> 00:02:14,000
and uh

40
00:02:14,000 --> 00:02:15,200
we

41
00:02:15,200 --> 00:02:18,480
set the private decrypt exponent to be

42
00:02:18,480 --> 00:02:20,720
uh the public exponent

43
00:02:20,720 --> 00:02:22,480
inverted modulo

44
00:02:22,480 --> 00:02:24,800
fee of n or p minus 1 times q minus 1

45
00:02:24,800 --> 00:02:27,520
and we return the private values

46
00:02:27,520 --> 00:02:29,280
p q d

47
00:02:29,280 --> 00:02:33,200
and the public values and an e

48
00:02:33,280 --> 00:02:35,280
so

49
00:02:35,280 --> 00:02:36,879
first thing to note is that the public

50
00:02:36,879 --> 00:02:39,360
exponent is a parameter to key

51
00:02:39,360 --> 00:02:41,280
generation um so it's assumed to be

52
00:02:41,280 --> 00:02:43,200
chosen a priori

53
00:02:43,200 --> 00:02:45,440
um to the to the generation of the

54
00:02:45,440 --> 00:02:48,239
primes and in fact the vast majority of

55
00:02:48,239 --> 00:02:49,760
rsa keys

56
00:02:49,760 --> 00:02:52,720
use uh the fermat prime

57
00:02:52,720 --> 00:02:55,840
f4 2 to the two to the four

58
00:02:55,840 --> 00:02:57,920
plus one

59
00:02:57,920 --> 00:02:59,519
or six five five

60
00:02:59,519 --> 00:03:00,640
three seven

61
00:03:00,640 --> 00:03:02,239
uh most of the remaining public

62
00:03:02,239 --> 00:03:06,319
exponents are three and uh

63
00:03:06,319 --> 00:03:07,760
there's a reason that you might want

64
00:03:07,760 --> 00:03:11,280
prime uh public exponents um so usually

65
00:03:11,280 --> 00:03:13,680
it suffices to check that e uh doesn't

66
00:03:13,680 --> 00:03:16,000
divide p minus one and q minus one

67
00:03:16,000 --> 00:03:18,400
and uh for simplicity's sake

68
00:03:18,400 --> 00:03:20,959
uh throughout this presentation

69
00:03:20,959 --> 00:03:22,480
um i'm going to

70
00:03:22,480 --> 00:03:26,239
just assume that e is prime uh the paper

71
00:03:26,239 --> 00:03:28,080
contains a brief discussion on how to

72
00:03:28,080 --> 00:03:31,440
deal with composity

73
00:03:31,519 --> 00:03:32,879
so

74
00:03:32,879 --> 00:03:34,959
the reason why i went over that is

75
00:03:34,959 --> 00:03:38,080
because there was a public forum post

76
00:03:38,080 --> 00:03:40,799
that indicated in a pre-release

77
00:03:40,799 --> 00:03:42,640
uh version of windows 10 that went out

78
00:03:42,640 --> 00:03:43,760
to the public

79
00:03:43,760 --> 00:03:44,879
um

80
00:03:44,879 --> 00:03:47,599
with the version and build there

81
00:03:47,599 --> 00:03:50,879
uh people found one bug reporter in

82
00:03:50,879 --> 00:03:54,159
particular found and posted that about

83
00:03:54,159 --> 00:03:58,239
every 30 000 or so rsa keys

84
00:03:58,239 --> 00:04:01,040
that were generated with the cng api

85
00:04:01,040 --> 00:04:04,480
uh couldn't decrypt plain texts and

86
00:04:04,480 --> 00:04:06,480
instead returned an error

87
00:04:06,480 --> 00:04:08,879
the blog reporter found that in these

88
00:04:08,879 --> 00:04:10,879
cases they debugged down and they found

89
00:04:10,879 --> 00:04:13,519
that in these cases the public exponent

90
00:04:13,519 --> 00:04:16,000
uh six five five three seven

91
00:04:16,000 --> 00:04:18,079
in fact divided

92
00:04:18,079 --> 00:04:21,680
one of p minus one or q minus one

93
00:04:21,680 --> 00:04:23,680
and uh

94
00:04:23,680 --> 00:04:26,560
exponentiating to the calculated uh

95
00:04:26,560 --> 00:04:28,720
decrypt exponent that was included with

96
00:04:28,720 --> 00:04:31,360
those keys um did not

97
00:04:31,360 --> 00:04:33,759
at all map the generated cipher text to

98
00:04:33,759 --> 00:04:35,919
the plain texts

99
00:04:35,919 --> 00:04:37,120
so

100
00:04:37,120 --> 00:04:40,320
um and also you know we can note that

101
00:04:40,320 --> 00:04:43,280
if e divides p minus one times q minus

102
00:04:43,280 --> 00:04:45,600
one then uh this

103
00:04:45,600 --> 00:04:47,759
notion of d having a multiplicative

104
00:04:47,759 --> 00:04:49,759
inverse isn't even well defined so it's

105
00:04:49,759 --> 00:04:51,440
not even clear what that decrypt

106
00:04:51,440 --> 00:04:53,120
exponent was

107
00:04:53,120 --> 00:04:56,639
um and so it's important to note that uh

108
00:04:56,639 --> 00:04:59,280
encryption can occur before

109
00:04:59,280 --> 00:05:03,120
calculating this decrypt exponent

110
00:05:03,120 --> 00:05:04,639
so all right i know some of you are

111
00:05:04,639 --> 00:05:07,520
thinking all right there's a bug in some

112
00:05:07,520 --> 00:05:09,600
pre-release version of windows 10 that

113
00:05:09,600 --> 00:05:11,759
generates bad rsa keys

114
00:05:11,759 --> 00:05:13,759
cool story bro

115
00:05:13,759 --> 00:05:16,080
why should we care

116
00:05:16,080 --> 00:05:18,960
you know if if you detect this just

117
00:05:18,960 --> 00:05:21,280
don't use that key get a new key and go

118
00:05:21,280 --> 00:05:24,000
on

119
00:05:24,000 --> 00:05:25,840
yeah

120
00:05:25,840 --> 00:05:27,600
but

121
00:05:27,600 --> 00:05:30,800
like i said before encryption can occur

122
00:05:30,800 --> 00:05:34,240
before calculating the decrypt exponent

123
00:05:34,240 --> 00:05:36,160
and without checking

124
00:05:36,160 --> 00:05:39,120
that e doesn't divide p minus 1 or q

125
00:05:39,120 --> 00:05:41,520
minus 1.

126
00:05:41,520 --> 00:05:42,400
also

127
00:05:42,400 --> 00:05:44,720
encrypting a symmetric key with an rsa

128
00:05:44,720 --> 00:05:47,199
key is a popular solution in many data

129
00:05:47,199 --> 00:05:50,000
encryption apis

130
00:05:50,000 --> 00:05:55,199
and windows dp api uh dp api ng

131
00:05:55,199 --> 00:05:58,960
efs uses this um

132
00:05:58,960 --> 00:06:01,199
dkm which was something that our team

133
00:06:01,199 --> 00:06:02,160
had built

134
00:06:02,160 --> 00:06:05,120
uses something like this in some cases

135
00:06:05,120 --> 00:06:08,479
so the situation is if you happen to

136
00:06:08,479 --> 00:06:11,039
encrypt some important data

137
00:06:11,039 --> 00:06:12,160
um

138
00:06:12,160 --> 00:06:14,560
before that decrypt exponent was

139
00:06:14,560 --> 00:06:16,880
calculated or before this uh

140
00:06:16,880 --> 00:06:19,360
divisibility condition was checked

141
00:06:19,360 --> 00:06:22,720
um getting a new rs rsa key isn't going

142
00:06:22,720 --> 00:06:24,639
to get that data back

143
00:06:24,639 --> 00:06:25,840
in fact

144
00:06:25,840 --> 00:06:27,840
sort of like you ransomware yourself in

145
00:06:27,840 --> 00:06:30,719
a certain sense

146
00:06:31,199 --> 00:06:34,199
so

147
00:06:35,440 --> 00:06:38,160
note that you know

148
00:06:38,160 --> 00:06:40,560
if a prime is generated for an rsa

149
00:06:40,560 --> 00:06:42,880
private key and it's not checked to make

150
00:06:42,880 --> 00:06:45,520
sure that the public exponent doesn't

151
00:06:45,520 --> 00:06:47,280
divide p minus one

152
00:06:47,280 --> 00:06:48,720
then you're gonna see a you're gonna see

153
00:06:48,720 --> 00:06:51,120
this happen um

154
00:06:51,120 --> 00:06:53,520
for about one over e

155
00:06:53,520 --> 00:06:53,840
uh

156
00:06:53,840 --> 00:06:56,000
[Music]

157
00:06:56,000 --> 00:06:57,919
uh of these primes so you just do it for

158
00:06:57,919 --> 00:06:59,840
the the first prime

159
00:06:59,840 --> 00:07:02,960
so that's one over e um

160
00:07:02,960 --> 00:07:04,800
but there's two primes

161
00:07:04,800 --> 00:07:06,960
so the probability

162
00:07:06,960 --> 00:07:10,160
uh for any given key is gonna be

163
00:07:10,160 --> 00:07:12,720
two over e

164
00:07:12,720 --> 00:07:15,919
and so then we see that you know with e

165
00:07:15,919 --> 00:07:16,960
for mod

166
00:07:16,960 --> 00:07:18,319
4

167
00:07:18,319 --> 00:07:21,280
that's going to be about 2 over 6

168
00:07:21,280 --> 00:07:23,199
65 000 sum

169
00:07:23,199 --> 00:07:26,479
approximately 1 over

170
00:07:26,560 --> 00:07:28,319
2 to the 15

171
00:07:28,319 --> 00:07:31,280
or approximately 1 over 30 000

172
00:07:31,280 --> 00:07:34,319
as was reported in the bug

173
00:07:34,319 --> 00:07:35,919
um

174
00:07:35,919 --> 00:07:38,400
so and going forward here you know it is

175
00:07:38,400 --> 00:07:41,680
possible that you could generate

176
00:07:41,680 --> 00:07:43,599
a key where uh

177
00:07:43,599 --> 00:07:46,160
e divides both p minus one and q minus

178
00:07:46,160 --> 00:07:47,039
one

179
00:07:47,039 --> 00:07:49,520
but the probability of that is about one

180
00:07:49,520 --> 00:07:52,319
over two to the 32 about one over uh one

181
00:07:52,319 --> 00:07:54,160
and about four billion so that's a lot

182
00:07:54,160 --> 00:07:56,879
less likely than one

183
00:07:56,879 --> 00:08:00,400
uh in every 30 000 keys so we're just

184
00:08:00,400 --> 00:08:02,800
gonna focus on the case where

185
00:08:02,800 --> 00:08:03,919
uh

186
00:08:03,919 --> 00:08:06,800
e divides uh

187
00:08:06,800 --> 00:08:12,080
the totient of n but um not e squared

188
00:08:12,080 --> 00:08:13,280
so

189
00:08:13,280 --> 00:08:15,680
now we have to kind of look at

190
00:08:15,680 --> 00:08:18,400
what happens

191
00:08:18,400 --> 00:08:19,599
um

192
00:08:19,599 --> 00:08:21,680
when we have

193
00:08:21,680 --> 00:08:24,479
uh the public exponent dividing

194
00:08:24,479 --> 00:08:26,400
fee event

195
00:08:26,400 --> 00:08:28,319
so

196
00:08:28,319 --> 00:08:30,479
uh to see what goes wrong

197
00:08:30,479 --> 00:08:32,719
we want to look at the structure

198
00:08:32,719 --> 00:08:34,399
of the units

199
00:08:34,399 --> 00:08:37,120
of the integers mod n

200
00:08:37,120 --> 00:08:38,080
um

201
00:08:38,080 --> 00:08:41,839
which is implicitly the group that all

202
00:08:41,839 --> 00:08:44,480
the arithmetic that we do for rsa is

203
00:08:44,480 --> 00:08:46,320
sort of happening in

204
00:08:46,320 --> 00:08:48,000
um so now

205
00:08:48,000 --> 00:08:49,839
if we have

206
00:08:49,839 --> 00:08:52,880
e dividing um fee of n phi of n is the

207
00:08:52,880 --> 00:08:54,640
order of that group

208
00:08:54,640 --> 00:08:58,080
um and so you know elementary results

209
00:08:58,080 --> 00:09:00,399
on abelian groups

210
00:09:00,399 --> 00:09:03,839
um give us that there's this isomorphism

211
00:09:03,839 --> 00:09:05,040
um

212
00:09:05,040 --> 00:09:07,279
that the structure

213
00:09:07,279 --> 00:09:08,560
of the

214
00:09:08,560 --> 00:09:10,320
of this group

215
00:09:10,320 --> 00:09:12,000
is going to be

216
00:09:12,000 --> 00:09:13,680
g cross e

217
00:09:13,680 --> 00:09:16,800
where g has order p minus 1 times q

218
00:09:16,800 --> 00:09:18,720
minus 1 divided by e

219
00:09:18,720 --> 00:09:20,800
and that subgroup

220
00:09:20,800 --> 00:09:22,800
e is going to have

221
00:09:22,800 --> 00:09:23,760
order

222
00:09:23,760 --> 00:09:26,240
equal to little e the public exponent

223
00:09:26,240 --> 00:09:27,200
um

224
00:09:27,200 --> 00:09:28,880
and that follows from the assumption

225
00:09:28,880 --> 00:09:29,839
that

226
00:09:29,839 --> 00:09:32,480
e is prime

227
00:09:32,800 --> 00:09:34,399
so

228
00:09:34,399 --> 00:09:37,680
uh that isomorphism there that structure

229
00:09:37,680 --> 00:09:40,399
is given explicitly

230
00:09:40,399 --> 00:09:42,160
by decomposing

231
00:09:42,160 --> 00:09:44,560
any integer

232
00:09:44,560 --> 00:09:46,320
x

233
00:09:46,320 --> 00:09:47,600
in this group

234
00:09:47,600 --> 00:09:50,320
as g times l where g is going to be in

235
00:09:50,320 --> 00:09:53,920
big g and l is going to be in big e

236
00:09:53,920 --> 00:09:54,800
so

237
00:09:54,800 --> 00:09:57,440
if we look at the exponentiation step of

238
00:09:57,440 --> 00:10:00,080
public key encryption

239
00:10:00,080 --> 00:10:02,320
with

240
00:10:02,480 --> 00:10:04,880
n and e is the public

241
00:10:04,880 --> 00:10:06,720
parameters it's going to have this

242
00:10:06,720 --> 00:10:07,839
effect

243
00:10:07,839 --> 00:10:10,240
the calculated decrypt y

244
00:10:10,240 --> 00:10:11,440
it's going to be

245
00:10:11,440 --> 00:10:12,320
uh

246
00:10:12,320 --> 00:10:14,160
x to the e but then you do some

247
00:10:14,160 --> 00:10:16,800
arithmetic out and because

248
00:10:16,800 --> 00:10:22,079
e has uh that group big e has order

249
00:10:22,079 --> 00:10:24,320
little he the public exponent that

250
00:10:24,320 --> 00:10:27,680
factor l is lost like in an information

251
00:10:27,680 --> 00:10:30,240
theoretic sense this is just gone

252
00:10:30,240 --> 00:10:31,200
so

253
00:10:31,200 --> 00:10:33,279
this sort of explains what's going on

254
00:10:33,279 --> 00:10:36,640
when you have this situation

255
00:10:36,720 --> 00:10:38,959
so

256
00:10:38,959 --> 00:10:40,399
the

257
00:10:40,399 --> 00:10:42,320
set and from that we can see that the

258
00:10:42,320 --> 00:10:45,120
set of possible pre-images of pre-images

259
00:10:45,120 --> 00:10:47,920
of y from public exponentiation

260
00:10:47,920 --> 00:10:50,240
is going to be capital p

261
00:10:50,240 --> 00:10:52,959
um and it's going to be equal to that uh

262
00:10:52,959 --> 00:10:54,480
element g

263
00:10:54,480 --> 00:10:55,680
times

264
00:10:55,680 --> 00:10:58,000
l where l ranges over all the elements

265
00:10:58,000 --> 00:11:01,680
of that e e-order sub-group

266
00:11:01,680 --> 00:11:03,760
and so when we look at it like this this

267
00:11:03,760 --> 00:11:06,880
sort of gives us the hope that um the

268
00:11:06,880 --> 00:11:09,680
lost plain text might be able to be

269
00:11:09,680 --> 00:11:11,680
recovered now

270
00:11:11,680 --> 00:11:15,120
if public exponents were general length

271
00:11:15,120 --> 00:11:17,200
um

272
00:11:17,200 --> 00:11:19,040
this wouldn't be possible but as i noted

273
00:11:19,040 --> 00:11:22,079
before the most common is 65537 and it's

274
00:11:22,079 --> 00:11:24,720
only 17 bits long so that's a trivial

275
00:11:24,720 --> 00:11:26,720
search space for us to look over on a

276
00:11:26,720 --> 00:11:29,120
computer

277
00:11:29,120 --> 00:11:31,120
so the first thing we need to do is

278
00:11:31,120 --> 00:11:33,279
figure out how we're going to um

279
00:11:33,279 --> 00:11:35,040
enumerate over

280
00:11:35,040 --> 00:11:37,200
uh the e-order sub-group

281
00:11:37,200 --> 00:11:39,680
and so we have this algorithm that's

282
00:11:39,680 --> 00:11:42,160
going to

283
00:11:42,240 --> 00:11:45,440
help us find a generator of that group

284
00:11:45,440 --> 00:11:47,040
so

285
00:11:47,040 --> 00:11:50,320
what we do is we first calculate uh

286
00:11:50,320 --> 00:11:52,560
phi tilde and that's going to be defined

287
00:11:52,560 --> 00:11:54,800
to be

288
00:11:54,800 --> 00:11:56,880
p minus one times q minus one

289
00:11:56,880 --> 00:11:59,279
all divided by e

290
00:11:59,279 --> 00:12:01,600
um okay and then we set g

291
00:12:01,600 --> 00:12:03,120
uh to be

292
00:12:03,120 --> 00:12:04,000
one

293
00:12:04,000 --> 00:12:05,760
and then we repeat this loop where we're

294
00:12:05,760 --> 00:12:07,360
just going to iterate over so we first

295
00:12:07,360 --> 00:12:09,120
look at g equals two

296
00:12:09,120 --> 00:12:12,000
um and we just try

297
00:12:12,000 --> 00:12:14,079
exponentiating g

298
00:12:14,079 --> 00:12:15,920
to f tilde

299
00:12:15,920 --> 00:12:17,279
um

300
00:12:17,279 --> 00:12:18,720
mod n

301
00:12:18,720 --> 00:12:21,519
and then we just do this loop until

302
00:12:21,519 --> 00:12:24,480
uh the result of that is not one

303
00:12:24,480 --> 00:12:27,519
and whenever we see that we return it

304
00:12:27,519 --> 00:12:30,480
so using the same argument uh

305
00:12:30,480 --> 00:12:31,920
from before

306
00:12:31,920 --> 00:12:33,120
um

307
00:12:33,120 --> 00:12:35,519
we see that you know g can be broken

308
00:12:35,519 --> 00:12:37,440
down as x of g

309
00:12:37,440 --> 00:12:39,120
times x sub e

310
00:12:39,120 --> 00:12:41,680
where x of g is going to have order

311
00:12:41,680 --> 00:12:44,959
uh v tilde and x sub e

312
00:12:44,959 --> 00:12:46,639
uh has

313
00:12:46,639 --> 00:12:48,720
order e

314
00:12:48,720 --> 00:12:49,920
and so

315
00:12:49,920 --> 00:12:52,480
we see that we annihilate that part

316
00:12:52,480 --> 00:12:54,800
that doesn't have

317
00:12:54,800 --> 00:12:56,880
uh the order that's the public exponent

318
00:12:56,880 --> 00:12:58,639
and we're left with

319
00:12:58,639 --> 00:13:00,560
um

320
00:13:00,560 --> 00:13:02,880
uh x sub e to the

321
00:13:02,880 --> 00:13:04,880
v tilde

322
00:13:04,880 --> 00:13:06,720
so um

323
00:13:06,720 --> 00:13:09,920
because e is prime no higher orders of e

324
00:13:09,920 --> 00:13:11,120
divide

325
00:13:11,120 --> 00:13:13,040
uh fee of n

326
00:13:13,040 --> 00:13:14,560
and uh

327
00:13:14,560 --> 00:13:16,160
the assumption that e is a prime larger

328
00:13:16,160 --> 00:13:17,120
group

329
00:13:17,120 --> 00:13:19,040
um so all of the elements are going to

330
00:13:19,040 --> 00:13:21,440
be generators of it

331
00:13:21,440 --> 00:13:22,560
now of course

332
00:13:22,560 --> 00:13:24,800
an iteration could fail to find a

333
00:13:24,800 --> 00:13:27,920
generator if that x of e component were

334
00:13:27,920 --> 00:13:29,600
1 mod n

335
00:13:29,600 --> 00:13:31,279
and this is going to happen with

336
00:13:31,279 --> 00:13:33,040
probability 1 over e

337
00:13:33,040 --> 00:13:35,600
um not that often and the probability of

338
00:13:35,600 --> 00:13:36,959
success

339
00:13:36,959 --> 00:13:38,160
um

340
00:13:38,160 --> 00:13:41,279
is gonna decrea uh is increasing

341
00:13:41,279 --> 00:13:43,519
uh sort of exponentially so we expect

342
00:13:43,519 --> 00:13:45,920
that this is not going to uh it's just

343
00:13:45,920 --> 00:13:48,480
gonna be found in a small number of

344
00:13:48,480 --> 00:13:50,320
iterations

345
00:13:50,320 --> 00:13:51,920
um

346
00:13:51,920 --> 00:13:53,519
so that that's you know gonna be

347
00:13:53,519 --> 00:13:55,440
familiar to anybody who works a lot with

348
00:13:55,440 --> 00:13:57,120
elementary number theory but it's worth

349
00:13:57,120 --> 00:13:59,680
going over um just in case it's not

350
00:13:59,680 --> 00:14:02,959
fresh in your your memory

351
00:14:02,959 --> 00:14:05,440
so okay so now now that we've got that

352
00:14:05,440 --> 00:14:08,160
generator of the e-order subgroup

353
00:14:08,160 --> 00:14:10,480
we can get a sketch

354
00:14:10,480 --> 00:14:12,480
of how to

355
00:14:12,480 --> 00:14:15,519
um enumerate over all the possible plain

356
00:14:15,519 --> 00:14:16,959
texts

357
00:14:16,959 --> 00:14:19,839
so you know we assume that we know the

358
00:14:19,839 --> 00:14:22,480
pr the prime factors p and q

359
00:14:22,480 --> 00:14:24,079
um

360
00:14:24,079 --> 00:14:26,160
and then

361
00:14:26,160 --> 00:14:28,480
what we do here is again we calculate

362
00:14:28,480 --> 00:14:31,839
our uh fe tilde

363
00:14:31,839 --> 00:14:34,000
we compute

364
00:14:34,000 --> 00:14:36,560
the decrypt exponent d

365
00:14:36,560 --> 00:14:38,800
to be

366
00:14:38,800 --> 00:14:40,000
e

367
00:14:40,000 --> 00:14:41,839
inverse mod

368
00:14:41,839 --> 00:14:44,320
phi tilde now

369
00:14:44,320 --> 00:14:48,800
and we use that as our decrypt exponent

370
00:14:48,800 --> 00:14:51,440
to retrieve a

371
00:14:51,440 --> 00:14:54,000
now we use that last algorithm

372
00:14:54,000 --> 00:14:56,399
to get a generator

373
00:14:56,399 --> 00:14:58,639
we initialize an empty set

374
00:14:58,639 --> 00:15:00,800
and we're going to iterate over all the

375
00:15:00,800 --> 00:15:03,360
powers of that generator

376
00:15:03,360 --> 00:15:05,760
and multiply them times that uh

377
00:15:05,760 --> 00:15:08,880
resulting value a that we got from

378
00:15:08,880 --> 00:15:11,519
our modified decrypt exponent

379
00:15:11,519 --> 00:15:14,399
and each one of those is a candidate

380
00:15:14,399 --> 00:15:16,240
plain text

381
00:15:16,240 --> 00:15:19,440
um and we do this for uh

382
00:15:19,440 --> 00:15:21,680
all e powers

383
00:15:21,680 --> 00:15:23,040
of

384
00:15:23,040 --> 00:15:26,240
gde and um

385
00:15:26,240 --> 00:15:28,000
and then we return that

386
00:15:28,000 --> 00:15:31,040
that set of potential plaintexts

387
00:15:31,040 --> 00:15:32,880
so

388
00:15:32,880 --> 00:15:34,000
that loop

389
00:15:34,000 --> 00:15:36,160
it iterates over the set of all the

390
00:15:36,160 --> 00:15:38,839
possible plaintexts

391
00:15:38,839 --> 00:15:42,079
um and that that loop is also going to

392
00:15:42,079 --> 00:15:44,399
determine the scaling so that we can see

393
00:15:44,399 --> 00:15:46,160
pretty easily the algorithm has runtime

394
00:15:46,160 --> 00:15:47,680
order e

395
00:15:47,680 --> 00:15:49,120
and uh

396
00:15:49,120 --> 00:15:51,920
also the output set has order e

397
00:15:51,920 --> 00:15:53,279
uh which is going to have to be searched

398
00:15:53,279 --> 00:15:56,240
to find the correct plain text

399
00:15:56,240 --> 00:15:58,720
uh which is which is not great i mean

400
00:15:58,720 --> 00:16:01,120
it's totally it's possible like you know

401
00:16:01,120 --> 00:16:02,480
if

402
00:16:02,480 --> 00:16:03,519
you know

403
00:16:03,519 --> 00:16:05,199
you really have some data that got lost

404
00:16:05,199 --> 00:16:06,720
it's very valuable that you want to find

405
00:16:06,720 --> 00:16:09,199
okay you could you could find it

406
00:16:09,199 --> 00:16:10,240
but

407
00:16:10,240 --> 00:16:13,199
um this can actually be improved

408
00:16:13,199 --> 00:16:16,560
um by filtering out invalid plain texts

409
00:16:16,560 --> 00:16:20,079
by considering plain text pad

410
00:16:20,079 --> 00:16:21,680
so

411
00:16:21,680 --> 00:16:23,279
now i'll talk a little bit about

412
00:16:23,279 --> 00:16:25,519
asymmetric padding modes

413
00:16:25,519 --> 00:16:27,839
um

414
00:16:27,839 --> 00:16:29,839
so

415
00:16:29,839 --> 00:16:31,519
the operations

416
00:16:31,519 --> 00:16:36,399
that we do in rsa as mentioned before uh

417
00:16:36,399 --> 00:16:38,800
are performed in a certain

418
00:16:38,800 --> 00:16:40,560
multiplicative group

419
00:16:40,560 --> 00:16:42,240
um

420
00:16:42,240 --> 00:16:44,800
and that's contained in the ring of

421
00:16:44,800 --> 00:16:46,720
integers mod n

422
00:16:46,720 --> 00:16:48,959
but messages are bit string so we need

423
00:16:48,959 --> 00:16:52,639
to map them into that ring to begin with

424
00:16:52,639 --> 00:16:55,759
um and then also we don't want attackers

425
00:16:55,759 --> 00:16:57,360
to be able to just like

426
00:16:57,360 --> 00:17:00,480
be encrypting raw input and having

427
00:17:00,480 --> 00:17:02,720
you decrypt it and do operations with

428
00:17:02,720 --> 00:17:03,519
that

429
00:17:03,519 --> 00:17:05,679
so it needs to be structured

430
00:17:05,679 --> 00:17:07,520
to try to help

431
00:17:07,520 --> 00:17:09,918
against

432
00:17:10,480 --> 00:17:12,799
certain attacks etc

433
00:17:12,799 --> 00:17:14,400
so

434
00:17:14,400 --> 00:17:16,400
we accomplished this through asymmetric

435
00:17:16,400 --> 00:17:18,400
padding and you can think of it as a

436
00:17:18,400 --> 00:17:20,240
pair of functions a format function and

437
00:17:20,240 --> 00:17:22,079
a verification function the format

438
00:17:22,079 --> 00:17:24,000
function maps

439
00:17:24,000 --> 00:17:26,160
n bit strings

440
00:17:26,160 --> 00:17:28,480
into the ring of integers mod n and the

441
00:17:28,480 --> 00:17:30,840
verification

442
00:17:30,840 --> 00:17:32,400
maps

443
00:17:32,400 --> 00:17:33,600
uh

444
00:17:33,600 --> 00:17:35,520
elements from the ring of integers but n

445
00:17:35,520 --> 00:17:39,120
to either the messages or uh a fail

446
00:17:39,120 --> 00:17:40,080
symbol

447
00:17:40,080 --> 00:17:41,520
um

448
00:17:41,520 --> 00:17:42,640
and

449
00:17:42,640 --> 00:17:44,400
so that's how you know it's sort of

450
00:17:44,400 --> 00:17:46,799
abstractly how padding

451
00:17:46,799 --> 00:17:48,080
is

452
00:17:48,080 --> 00:17:50,080
is done

453
00:17:50,080 --> 00:17:52,320
so with that sort of abstract definition

454
00:17:52,320 --> 00:17:54,400
in mind we can go back to that plain

455
00:17:54,400 --> 00:17:57,200
text enumeration algorithm

456
00:17:57,200 --> 00:17:59,120
and

457
00:17:59,120 --> 00:18:00,640
we can

458
00:18:00,640 --> 00:18:03,679
now just add an if statement inside the

459
00:18:03,679 --> 00:18:05,200
loop

460
00:18:05,200 --> 00:18:07,440
where we just look at we just do a plain

461
00:18:07,440 --> 00:18:08,559
text

462
00:18:08,559 --> 00:18:10,799
uh padding check

463
00:18:10,799 --> 00:18:13,440
on the potential plain texts that we're

464
00:18:13,440 --> 00:18:15,760
getting out

465
00:18:15,760 --> 00:18:18,799
and we only add them to the set

466
00:18:18,799 --> 00:18:21,039
of potential plaintexts if they have

467
00:18:21,039 --> 00:18:22,720
valid padding

468
00:18:22,720 --> 00:18:24,799
so that greatly that's gonna greatly

469
00:18:24,799 --> 00:18:26,160
reduce

470
00:18:26,160 --> 00:18:27,039
the

471
00:18:27,039 --> 00:18:29,200
size of our

472
00:18:29,200 --> 00:18:32,160
set of potential plaintexts

473
00:18:32,160 --> 00:18:33,039
so

474
00:18:33,039 --> 00:18:36,080
in practice the two most widely used

475
00:18:36,080 --> 00:18:39,200
uh rsa padding modes are pkcs1 version

476
00:18:39,200 --> 00:18:42,240
1.5 and oep

477
00:18:42,240 --> 00:18:44,160
pkcs1

478
00:18:44,160 --> 00:18:46,640
v 1.5 is older and

479
00:18:46,640 --> 00:18:48,559
it can lead to fault injection and side

480
00:18:48,559 --> 00:18:50,320
channel attacks so you know it should be

481
00:18:50,320 --> 00:18:52,559
avoided

482
00:18:52,559 --> 00:18:54,880
oap is more modern it has improvable

483
00:18:54,880 --> 00:18:57,120
security properties

484
00:18:57,120 --> 00:18:58,720
um

485
00:18:58,720 --> 00:19:00,880
and just completely in practice using

486
00:19:00,880 --> 00:19:02,559
these really helps

487
00:19:02,559 --> 00:19:04,400
filter out

488
00:19:04,400 --> 00:19:06,559
a lot of false positives and really

489
00:19:06,559 --> 00:19:08,240
reduce the number

490
00:19:08,240 --> 00:19:09,280
of

491
00:19:09,280 --> 00:19:12,080
potentially correct plain texts

492
00:19:12,080 --> 00:19:13,600
so first i'll

493
00:19:13,600 --> 00:19:16,400
make some comments about pkcs1 version

494
00:19:16,400 --> 00:19:18,080
1.5

495
00:19:18,080 --> 00:19:19,440
um

496
00:19:19,440 --> 00:19:20,799
so

497
00:19:20,799 --> 00:19:25,679
that takes a message uh of m bytes uh

498
00:19:25,679 --> 00:19:27,679
where m is the

499
00:19:27,679 --> 00:19:31,760
modulus length in uh bytes minus 11.

500
00:19:31,760 --> 00:19:36,160
um and we have to generate a non-zero

501
00:19:36,160 --> 00:19:38,720
uh a random nonzero padding

502
00:19:38,720 --> 00:19:39,679
uh

503
00:19:39,679 --> 00:19:41,440
string

504
00:19:41,440 --> 00:19:45,280
um and the padded bytes the message is

505
00:19:45,280 --> 00:19:48,160
padded out to be an integer

506
00:19:48,160 --> 00:19:49,200
um

507
00:19:49,200 --> 00:19:50,960
of length

508
00:19:50,960 --> 00:19:53,039
of the modulus length with the leading

509
00:19:53,039 --> 00:19:54,320
byte of zero

510
00:19:54,320 --> 00:19:57,200
the second most significant byte is two

511
00:19:57,200 --> 00:19:59,200
um then there's that random non-zero

512
00:19:59,200 --> 00:20:00,640
padding string

513
00:20:00,640 --> 00:20:02,559
a zero byte and then the message and

514
00:20:02,559 --> 00:20:04,720
this is interpreted as a big endian

515
00:20:04,720 --> 00:20:07,440
integer and encrypted with rsa as we

516
00:20:07,440 --> 00:20:10,559
would usually expect

517
00:20:11,280 --> 00:20:13,280
so um

518
00:20:13,280 --> 00:20:15,600
we can we can

519
00:20:15,600 --> 00:20:20,720
detect incorrect pkcs1 v 1.5 padding

520
00:20:20,720 --> 00:20:22,799
of a random plaintext candidate as

521
00:20:22,799 --> 00:20:24,159
follows

522
00:20:24,159 --> 00:20:26,960
if the most significant two bytes

523
00:20:26,960 --> 00:20:28,240
are not

524
00:20:28,240 --> 00:20:30,640
0 and 2

525
00:20:30,640 --> 00:20:31,760
and that's going to occur with

526
00:20:31,760 --> 00:20:36,960
probability uh 1 over 256 squared or 2

527
00:20:36,960 --> 00:20:39,120
to the 16.

528
00:20:39,120 --> 00:20:40,799
the details of calculating this are in

529
00:20:40,799 --> 00:20:42,960
the paper but the probability that a

530
00:20:42,960 --> 00:20:45,520
random plaintext candidate has at least

531
00:20:45,520 --> 00:20:49,120
eight valid non-zero bytes of padding

532
00:20:49,120 --> 00:20:52,559
um is uh 31 out of 32 and combining

533
00:20:52,559 --> 00:20:54,799
those two probabilities

534
00:20:54,799 --> 00:20:56,080
um

535
00:20:56,080 --> 00:20:59,760
and then multiplying by the e

536
00:20:59,760 --> 00:21:00,480
uh

537
00:21:00,480 --> 00:21:01,840
plaintext candidates that we're gonna

538
00:21:01,840 --> 00:21:02,799
check

539
00:21:02,799 --> 00:21:05,520
tells us that the expected

540
00:21:05,520 --> 00:21:06,400
uh

541
00:21:06,400 --> 00:21:08,720
number of

542
00:21:08,720 --> 00:21:12,240
uh false positives looking through there

543
00:21:12,240 --> 00:21:14,480
um through a set of

544
00:21:14,480 --> 00:21:17,919
size format 4 is gonna be just under one

545
00:21:17,919 --> 00:21:20,880
so we would expect that most of the time

546
00:21:20,880 --> 00:21:22,480
that we do this we're gonna find at

547
00:21:22,480 --> 00:21:26,240
least one false positive

548
00:21:26,799 --> 00:21:29,280
so the other option for asymmetric

549
00:21:29,280 --> 00:21:32,880
padding is oaep

550
00:21:32,880 --> 00:21:34,960
and here

551
00:21:34,960 --> 00:21:36,240
we have

552
00:21:36,240 --> 00:21:37,120
uh

553
00:21:37,120 --> 00:21:40,240
what we do is we have a message

554
00:21:40,240 --> 00:21:41,360
[Music]

555
00:21:41,360 --> 00:21:45,280
that is of length n minus k0 minus k1

556
00:21:45,280 --> 00:21:47,600
it's padded out with zero bytes

557
00:21:47,600 --> 00:21:50,240
um and then a random

558
00:21:50,240 --> 00:21:51,760
uh

559
00:21:51,760 --> 00:21:53,600
a random value

560
00:21:53,600 --> 00:21:56,240
that random value is fed into this hash

561
00:21:56,240 --> 00:21:59,120
function which um like an implementation

562
00:21:59,120 --> 00:22:01,600
of a random oracle model that gives us

563
00:22:01,600 --> 00:22:02,799
uh

564
00:22:02,799 --> 00:22:06,000
n minus k0 bits which are xored with the

565
00:22:06,000 --> 00:22:08,799
m 0 padded out

566
00:22:08,799 --> 00:22:10,880
that output

567
00:22:10,880 --> 00:22:12,559
is then fed into

568
00:22:12,559 --> 00:22:14,000
another

569
00:22:14,000 --> 00:22:14,260
uh

570
00:22:14,260 --> 00:22:15,679
[Music]

571
00:22:15,679 --> 00:22:16,640
hash

572
00:22:16,640 --> 00:22:18,960
type function h

573
00:22:18,960 --> 00:22:20,960
which outputs k zero bits and that's

574
00:22:20,960 --> 00:22:24,000
used to mask off that random seed

575
00:22:24,000 --> 00:22:27,200
uh by xoring and then the outputs of

576
00:22:27,200 --> 00:22:30,080
those two masks are concatenated

577
00:22:30,080 --> 00:22:33,200
together and that is fed into

578
00:22:33,200 --> 00:22:34,159
um

579
00:22:34,159 --> 00:22:37,120
rsa encryption in the usual way

580
00:22:37,120 --> 00:22:38,960
now that might look a little familiar

581
00:22:38,960 --> 00:22:41,200
it's actually a feistel network from

582
00:22:41,200 --> 00:22:44,400
symmetric cryptography

583
00:22:44,559 --> 00:22:46,240
those functions g and h are supposed to

584
00:22:46,240 --> 00:22:49,039
implement random oracles um with the

585
00:22:49,039 --> 00:22:52,320
correct number of bits respectively

586
00:22:52,320 --> 00:22:54,480
they're implemented um

587
00:22:54,480 --> 00:22:56,480
by iterating a standard hash function by

588
00:22:56,480 --> 00:22:57,840
the way that that example that i gave

589
00:22:57,840 --> 00:23:00,240
you is not exactly how oap is

590
00:23:00,240 --> 00:23:02,480
implemented uh out there in the real

591
00:23:02,480 --> 00:23:05,280
world it's it's just a much simplified

592
00:23:05,280 --> 00:23:07,520
version that simplifies our discussion

593
00:23:07,520 --> 00:23:09,280
here

594
00:23:09,280 --> 00:23:11,200
so um

595
00:23:11,200 --> 00:23:14,000
in practice uh the length of r and the

596
00:23:14,000 --> 00:23:17,600
zero string padding um have at least

597
00:23:17,600 --> 00:23:21,360
um the hash digest length h where a uh

598
00:23:21,360 --> 00:23:22,799
where that's the hash that's used

599
00:23:22,799 --> 00:23:24,720
instantiate g and those g and h

600
00:23:24,720 --> 00:23:26,080
functions

601
00:23:26,080 --> 00:23:27,520
and so

602
00:23:27,520 --> 00:23:29,919
the probability that a random string is

603
00:23:29,919 --> 00:23:31,280
gonna pass

604
00:23:31,280 --> 00:23:33,440
this padding check is the result that

605
00:23:33,440 --> 00:23:36,320
you reverse that feistel network and get

606
00:23:36,320 --> 00:23:39,200
zeros all zeros in the correct place and

607
00:23:39,200 --> 00:23:41,279
that's going to be at most

608
00:23:41,279 --> 00:23:45,039
uh two to the negative h

609
00:23:45,679 --> 00:23:46,640
so

610
00:23:46,640 --> 00:23:48,840
when iterating through e possible

611
00:23:48,840 --> 00:23:51,679
candidates uh we expect to see e over

612
00:23:51,679 --> 00:23:54,559
two to the h false positives and in what

613
00:23:54,559 --> 00:23:56,159
that means is in practice we don't

614
00:23:56,159 --> 00:23:58,640
expect to see any false positives with

615
00:23:58,640 --> 00:24:01,200
oaep

616
00:24:02,080 --> 00:24:03,760
so uh

617
00:24:03,760 --> 00:24:06,320
i implemented all this uh which confirms

618
00:24:06,320 --> 00:24:09,840
that analysis that was done um it's done

619
00:24:09,840 --> 00:24:12,480
in python and it's been made available

620
00:24:12,480 --> 00:24:15,600
uh on github the url is here

621
00:24:15,600 --> 00:24:16,960
um

622
00:24:16,960 --> 00:24:19,120
for an incorrectly generated rsa key

623
00:24:19,120 --> 00:24:22,480
with a 40 96 bit modulus and then

624
00:24:22,480 --> 00:24:25,279
usual for mod 4 public exponent the

625
00:24:25,279 --> 00:24:29,039
script runs in uh under 30 seconds on my

626
00:24:29,039 --> 00:24:33,200
windows 10 laptop it's a core i7 2.6

627
00:24:33,200 --> 00:24:36,080
gigahertz 16 gigs of ram

628
00:24:36,080 --> 00:24:39,600
uh for smaller key sizes it runs uh

629
00:24:39,600 --> 00:24:42,200
in seconds or under a second uh for

630
00:24:42,200 --> 00:24:45,279
81.92 um

631
00:24:45,279 --> 00:24:48,240
it takes several minutes but still uh

632
00:24:48,240 --> 00:24:50,640
it's possible to run it's released under

633
00:24:50,640 --> 00:24:52,799
the mit license if anybody needs to use

634
00:24:52,799 --> 00:24:54,720
it wants to use it wants to play with it

635
00:24:54,720 --> 00:24:56,240
and it's self-contained with no

636
00:24:56,240 --> 00:24:58,840
dependencies other than

637
00:24:58,840 --> 00:25:05,199
uh uh python version 3.4 or creator

638
00:25:05,279 --> 00:25:06,320
so

639
00:25:06,320 --> 00:25:07,760
now i'm gonna

640
00:25:07,760 --> 00:25:08,559
uh

641
00:25:08,559 --> 00:25:09,760
talk about

642
00:25:09,760 --> 00:25:12,880
rsa key generation in simcrip so

643
00:25:12,880 --> 00:25:14,480
simcrypt is

644
00:25:14,480 --> 00:25:18,080
the underlying crypto implementations uh

645
00:25:18,080 --> 00:25:21,919
in windows uh and the cng api it has

646
00:25:21,919 --> 00:25:24,000
been released as open source on github

647
00:25:24,000 --> 00:25:26,640
and you can find it at this url

648
00:25:26,640 --> 00:25:29,279
um it wasn't released on github

649
00:25:29,279 --> 00:25:31,520
until after the build of windows 10 that

650
00:25:31,520 --> 00:25:33,679
had this bug in it

651
00:25:33,679 --> 00:25:35,840
um and if you review the history of the

652
00:25:35,840 --> 00:25:38,320
code and the um

653
00:25:38,320 --> 00:25:40,880
uh the pull requests and everything you

654
00:25:40,880 --> 00:25:43,600
you see that from when it was uploaded

655
00:25:43,600 --> 00:25:45,840
this bug had been fixed

656
00:25:45,840 --> 00:25:48,000
um and if you're interested the relevant

657
00:25:48,000 --> 00:25:52,039
code is in rsa key.cnprimes.c

658
00:25:52,159 --> 00:25:54,000
now there have been some other high

659
00:25:54,000 --> 00:25:56,880
profile issues with some crypt including

660
00:25:56,880 --> 00:25:59,120
a bug which would allow a carefully

661
00:25:59,120 --> 00:26:01,039
crafted modulus to create an infinite

662
00:26:01,039 --> 00:26:03,919
loop while using dsa and this dsa bug

663
00:26:03,919 --> 00:26:05,200
and the other issues that have been

664
00:26:05,200 --> 00:26:06,159
found

665
00:26:06,159 --> 00:26:08,240
um have had to do with how the library

666
00:26:08,240 --> 00:26:10,400
performs error handling and basically

667
00:26:10,400 --> 00:26:12,720
ignoring errors

668
00:26:12,720 --> 00:26:16,559
so one might conclude that the bug

669
00:26:16,559 --> 00:26:19,440
with incorrectly generated rsa keys may

670
00:26:19,440 --> 00:26:22,720
be a little bit similar

671
00:26:23,120 --> 00:26:24,799
so if

672
00:26:24,799 --> 00:26:26,240
and the reason why i think this is

673
00:26:26,240 --> 00:26:27,440
because

674
00:26:27,440 --> 00:26:30,080
the relevant function is simcrypt rsa

675
00:26:30,080 --> 00:26:32,480
key calculate private fields and rsa

676
00:26:32,480 --> 00:26:35,200
key.c and note that in this rsa key

677
00:26:35,200 --> 00:26:37,440
generation function there's no retry

678
00:26:37,440 --> 00:26:38,559
logic

679
00:26:38,559 --> 00:26:41,520
around prime generation or when gcd of

680
00:26:41,520 --> 00:26:43,440
fee of n and the public exponent are

681
00:26:43,440 --> 00:26:44,240
checked

682
00:26:44,240 --> 00:26:46,400
rather the prime generation function

683
00:26:46,400 --> 00:26:49,120
takes an optional parameter

684
00:26:49,120 --> 00:26:51,120
for the public exponent and make sure

685
00:26:51,120 --> 00:26:54,080
that the generated prime p has p minus

686
00:26:54,080 --> 00:26:56,720
one relatively prime to that parameter

687
00:26:56,720 --> 00:26:58,480
uh this is a non-standard way of doing

688
00:26:58,480 --> 00:27:00,400
general purpose prime generation and

689
00:27:00,400 --> 00:27:02,480
really only applies to rsa

690
00:27:02,480 --> 00:27:04,559
and so one might conclude that this may

691
00:27:04,559 --> 00:27:06,640
be an artifact

692
00:27:06,640 --> 00:27:09,679
of fixing this bug that's

693
00:27:09,679 --> 00:27:10,559
i'm

694
00:27:10,559 --> 00:27:11,919
i'm just saying you could go check it

695
00:27:11,919 --> 00:27:14,400
out yourself

696
00:27:14,880 --> 00:27:17,120
so in conclusion there's a bug on

697
00:27:17,120 --> 00:27:19,760
windows 10 in the simcrip library um

698
00:27:19,760 --> 00:27:21,919
that was exposed through cng that caused

699
00:27:21,919 --> 00:27:25,279
rsa keys to be generated where uh fee of

700
00:27:25,279 --> 00:27:28,720
n was divisible by the public exponent e

701
00:27:28,720 --> 00:27:31,120
standard rsa decryption of ciphertext

702
00:27:31,120 --> 00:27:33,279
encrypted to those keys failed

703
00:27:33,279 --> 00:27:34,880
this presentation shows you how to

704
00:27:34,880 --> 00:27:37,200
recover plain text that are encrypted to

705
00:27:37,200 --> 00:27:39,760
those incorrectly generated keys

706
00:27:39,760 --> 00:27:42,240
uh a full paper isn't available on the

707
00:27:42,240 --> 00:27:44,559
eprints and uh

708
00:27:44,559 --> 00:27:46,320
thank you for listening to me talk about

709
00:27:46,320 --> 00:27:51,520
this uh really like weird esoteric bug

710
00:27:51,520 --> 00:27:53,440
and i'm happy to hear whatever questions

711
00:27:53,440 --> 00:27:56,600
you have

712
00:28:02,720 --> 00:28:05,039
all right thank you so people can feel

713
00:28:05,039 --> 00:28:08,159
free to put any questions in the chat or

714
00:28:08,159 --> 00:28:11,039
in zulip or just it looks like tomer has

715
00:28:11,039 --> 00:28:13,520
a question to start us off

716
00:28:13,520 --> 00:28:15,919
so it's not really a question about the

717
00:28:15,919 --> 00:28:18,080
paper but i'm curious

718
00:28:18,080 --> 00:28:20,240
how why would you have a bag like this

719
00:28:20,240 --> 00:28:22,000
in windows 10 in one of their

720
00:28:22,000 --> 00:28:23,679
pre-releases so

721
00:28:23,679 --> 00:28:26,080
why does it why do you need to rewrite

722
00:28:26,080 --> 00:28:31,080
the whole thing between windows versions

723
00:28:31,600 --> 00:28:33,679
it's a good question um one that i would

724
00:28:33,679 --> 00:28:37,440
direct towards the windows uh

725
00:28:37,440 --> 00:28:40,720
uh software engineer in charge of uh the

726
00:28:40,720 --> 00:28:43,279
crypto um

727
00:28:43,279 --> 00:28:45,120
that that's neil's ferguson

728
00:28:45,120 --> 00:28:47,279
yeah okay thanks so so you should you

729
00:28:47,279 --> 00:28:50,000
should ask him i i i asked him that and

730
00:28:50,000 --> 00:28:52,420
i didn't get a good answer so oh

731
00:28:52,420 --> 00:28:54,640
[Music]

732
00:28:54,640 --> 00:28:58,240
he probably didn't write the code

733
00:28:58,240 --> 00:29:00,880
no comment

734
00:29:05,120 --> 00:29:07,200
if it makes you feel better i discovered

735
00:29:07,200 --> 00:29:08,000
uh

736
00:29:08,000 --> 00:29:10,159
something similar to this

737
00:29:10,159 --> 00:29:11,600
it turns out in

738
00:29:11,600 --> 00:29:13,279
google app engine

739
00:29:13,279 --> 00:29:14,240
they had

740
00:29:14,240 --> 00:29:17,039
i know 20 48-bit keys that could under

741
00:29:17,039 --> 00:29:18,960
some circumstances turn out to be 20

742
00:29:18,960 --> 00:29:20,960
47-bit keys

743
00:29:20,960 --> 00:29:23,520
and the algorithm for looking up the key

744
00:29:23,520 --> 00:29:25,360
couldn't find the key because it was the

745
00:29:25,360 --> 00:29:27,520
wrong number of bits

746
00:29:27,520 --> 00:29:29,760
and so this is just a stupid you know

747
00:29:29,760 --> 00:29:31,520
implementation bug that would almost

748
00:29:31,520 --> 00:29:33,919
never occur but of course it hit me

749
00:29:33,919 --> 00:29:35,760
of all people right so the first thing i

750
00:29:35,760 --> 00:29:37,840
do is go read the code what's going on

751
00:29:37,840 --> 00:29:40,240
here

752
00:29:40,240 --> 00:29:42,320
was there anything interesting that was

753
00:29:42,320 --> 00:29:44,159
that was causing it

754
00:29:44,159 --> 00:29:46,000
not really no it's just a padding issue

755
00:29:46,000 --> 00:29:48,000
in the in the way and you know the key

756
00:29:48,000 --> 00:29:50,640
generation was some hacked up

757
00:29:50,640 --> 00:29:53,039
thing that somebody had done early on

758
00:29:53,039 --> 00:29:54,960
and had survived

759
00:29:54,960 --> 00:29:57,360
this is really ancient history this is

760
00:29:57,360 --> 00:29:58,480
like

761
00:29:58,480 --> 00:30:01,600
12 years ago so

762
00:30:01,919 --> 00:30:03,760
but i think these implementations that

763
00:30:03,760 --> 00:30:05,600
all these things about padding

764
00:30:05,600 --> 00:30:07,679
i think they're actually

765
00:30:07,679 --> 00:30:09,039
they're probably a bigger source of

766
00:30:09,039 --> 00:30:10,880
errors than the mathematics

767
00:30:10,880 --> 00:30:13,760
oh absolutely absolutely in fact i

768
00:30:13,760 --> 00:30:16,159
mentioned this uh in the paper the the

769
00:30:16,159 --> 00:30:18,640
paper has a whole section on like some

770
00:30:18,640 --> 00:30:21,039
lessons you can draw for randomized

771
00:30:21,039 --> 00:30:23,360
testing of uh crypto

772
00:30:23,360 --> 00:30:25,760
functions um and it reminded me of a bug

773
00:30:25,760 --> 00:30:27,679
that so

774
00:30:27,679 --> 00:30:28,559
i

775
00:30:28,559 --> 00:30:31,200
uh i was the windows uh

776
00:30:31,200 --> 00:30:33,360
crypto software engineer

777
00:30:33,360 --> 00:30:35,840
before i went to graduate school um so

778
00:30:35,840 --> 00:30:38,960
like 15 years ago and uh

779
00:30:38,960 --> 00:30:42,080
when we were implementing the cng api

780
00:30:42,080 --> 00:30:45,600
uh there was this bug where like one

781
00:30:45,600 --> 00:30:47,200
out of every

782
00:30:47,200 --> 00:30:50,640
two to the 16 or one you know a similar

783
00:30:50,640 --> 00:30:54,240
rate as this bug occurred um

784
00:30:54,240 --> 00:30:55,919
uh rsa

785
00:30:55,919 --> 00:30:59,840
decryption with pkcs1 v 1.5 would fail

786
00:30:59,840 --> 00:31:00,880
um

787
00:31:00,880 --> 00:31:03,200
and

788
00:31:03,279 --> 00:31:04,480
we

789
00:31:04,480 --> 00:31:06,640
i debug down and what i eventually found

790
00:31:06,640 --> 00:31:07,919
was that the

791
00:31:07,919 --> 00:31:10,399
loop to generate the non-zero padding

792
00:31:10,399 --> 00:31:14,480
it's like just take a uh crypto prng

793
00:31:14,480 --> 00:31:16,880
fill a buffer and then a loop just went

794
00:31:16,880 --> 00:31:18,880
through

795
00:31:18,880 --> 00:31:21,120
and it said if

796
00:31:21,120 --> 00:31:23,600
there's a zero byte

797
00:31:23,600 --> 00:31:26,720
generate a new byte and put it in

798
00:31:26,720 --> 00:31:28,240
but you don't want to do if you want to

799
00:31:28,240 --> 00:31:30,399
do until you get a non-zero byte so you

800
00:31:30,399 --> 00:31:33,760
might hit two zero bytes in a row

801
00:31:33,760 --> 00:31:36,080
what's the probability of that

802
00:31:36,080 --> 00:31:38,159
one over two to the 16.

803
00:31:38,159 --> 00:31:39,279
so

804
00:31:39,279 --> 00:31:40,960
um

805
00:31:40,960 --> 00:31:42,480
yeah it was it was an interesting

806
00:31:42,480 --> 00:31:44,840
juxtaposition to see

807
00:31:44,840 --> 00:31:47,760
how you know back then it was like oh

808
00:31:47,760 --> 00:31:50,399
yeah a bug that happens one every thirty

809
00:31:50,399 --> 00:31:52,799
thousand times like yeah oh that's a lot

810
00:31:52,799 --> 00:31:54,880
you gotta fix that and nowadays it seems

811
00:31:54,880 --> 00:31:57,039
like a bug that happens one every thirty

812
00:31:57,039 --> 00:31:59,600
thousand times no it doesn't get

813
00:31:59,600 --> 00:32:04,240
doesn't reach the buyer uh to get fixed

814
00:32:09,919 --> 00:32:11,679
all right so let's thank our speaker

815
00:32:11,679 --> 00:32:14,679
again

816
00:32:15,600 --> 00:32:18,959
and alright so moving on

