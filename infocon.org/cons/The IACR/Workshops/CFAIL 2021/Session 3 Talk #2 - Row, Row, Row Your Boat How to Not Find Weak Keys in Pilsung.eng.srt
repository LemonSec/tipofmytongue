1
00:00:04,799 --> 00:00:07,520
so now starting the next presentation i

2
00:00:07,520 --> 00:00:09,840
think we have a recorded presentation

3
00:00:09,840 --> 00:00:10,960
now

4
00:00:10,960 --> 00:00:15,360
um the title is whoa whoa oh your boat

5
00:00:15,360 --> 00:00:18,880
how how to not find rookies in pilsen

6
00:00:18,880 --> 00:00:20,880
uh by

7
00:00:20,880 --> 00:00:22,000
by

8
00:00:22,000 --> 00:00:23,680
chit nachok

9
00:00:23,680 --> 00:00:24,020
um

10
00:00:24,020 --> 00:00:25,359
[Music]

11
00:00:25,359 --> 00:00:27,519
greg rose and duvalier

12
00:00:27,519 --> 00:00:30,000
and we have a recording so we'll just

13
00:00:30,000 --> 00:00:32,479
play now alison

14
00:00:32,479 --> 00:00:34,160
please i think you have the recording

15
00:00:34,160 --> 00:00:36,398
right

16
00:00:53,120 --> 00:00:56,559
hello everyone i am cito norton satyansa

17
00:00:56,559 --> 00:00:59,760
in this presentation i will talk about

18
00:00:59,760 --> 00:01:02,800
row row row your board how to not find

19
00:01:02,800 --> 00:01:05,600
weak keys in fuel sound

20
00:01:05,600 --> 00:01:08,000
this is a joint work with er ronin

21
00:01:08,000 --> 00:01:11,520
gregory zeros and you follow your room

22
00:01:11,520 --> 00:01:12,400
first

23
00:01:12,400 --> 00:01:15,920
let me briefly describe what pilsen is

24
00:01:15,920 --> 00:01:19,119
pilsen is a block cipher it is part of

25
00:01:19,119 --> 00:01:21,680
the north korean red star operating

26
00:01:21,680 --> 00:01:22,880
system

27
00:01:22,880 --> 00:01:25,520
its construction is very much similar to

28
00:01:25,520 --> 00:01:29,920
aes except that in pearson it uses key

29
00:01:29,920 --> 00:01:32,000
dependent permutation

30
00:01:32,000 --> 00:01:34,640
which will be the main focus of our

31
00:01:34,640 --> 00:01:37,200
cryptanalysis

32
00:01:37,200 --> 00:01:39,200
pearson follows a substitution

33
00:01:39,200 --> 00:01:42,000
permutation network design with multiple

34
00:01:42,000 --> 00:01:45,119
rounds to produce ciphertext

35
00:01:45,119 --> 00:01:47,600
subprocessors in each round are sub

36
00:01:47,600 --> 00:01:50,479
bytes several mixed columns and that

37
00:01:50,479 --> 00:01:52,000
round key

38
00:01:52,000 --> 00:01:55,680
unlike aes surprise improv shiftroll in

39
00:01:55,680 --> 00:01:59,200
pilsen is replaced by permutation which

40
00:01:59,200 --> 00:02:02,159
is the main focus of this presentation

41
00:02:02,159 --> 00:02:04,399
so next let's take a look at how this

42
00:02:04,399 --> 00:02:08,399
shift flow permutation works in fusion

43
00:02:08,399 --> 00:02:10,878
this permutation was called the shuffles

44
00:02:10,878 --> 00:02:14,160
estate which has 16 bytes

45
00:02:14,160 --> 00:02:16,560
and it consists of several step or

46
00:02:16,560 --> 00:02:19,760
through level of shuffling

47
00:02:19,760 --> 00:02:21,920
the first level of shuffling it splits

48
00:02:21,920 --> 00:02:24,400
from 16 bytes into two groups of eight

49
00:02:24,400 --> 00:02:27,520
bytes and actually at each step of each

50
00:02:27,520 --> 00:02:29,280
level of shuffling in

51
00:02:29,280 --> 00:02:30,640
its split

52
00:02:30,640 --> 00:02:34,239
into two groups of the same size

53
00:02:34,239 --> 00:02:36,239
so now at the first level two groups of

54
00:02:36,239 --> 00:02:37,519
eight whites

55
00:02:37,519 --> 00:02:40,080
and at the second level of shuffling it

56
00:02:40,080 --> 00:02:42,319
further split from eight bytes into a

57
00:02:42,319 --> 00:02:43,440
group

58
00:02:43,440 --> 00:02:45,280
of four bytes

59
00:02:45,280 --> 00:02:47,200
or in total we have four groups of four

60
00:02:47,200 --> 00:02:48,319
bytes

61
00:02:48,319 --> 00:02:51,120
and at level three it photo split from

62
00:02:51,120 --> 00:02:53,519
four into two or eight groups of two

63
00:02:53,519 --> 00:02:56,160
bytes in total and finally

64
00:02:56,160 --> 00:02:58,720
at the last level on level four we have

65
00:02:58,720 --> 00:03:00,319
16 groups

66
00:03:00,319 --> 00:03:02,000
of one byte

67
00:03:02,000 --> 00:03:04,159
and the result of shuffling or

68
00:03:04,159 --> 00:03:06,480
permutation is the concatenation of

69
00:03:06,480 --> 00:03:09,599
those 16 groups of one white

70
00:03:09,599 --> 00:03:11,440
and the important thing is

71
00:03:11,440 --> 00:03:14,080
how it determines which byte should go

72
00:03:14,080 --> 00:03:15,760
in which group

73
00:03:15,760 --> 00:03:18,000
it uses some randomness to determine

74
00:03:18,000 --> 00:03:18,800
this

75
00:03:18,800 --> 00:03:21,200
we will take a look into details of

76
00:03:21,200 --> 00:03:23,280
randomness used to determine which group

77
00:03:23,280 --> 00:03:25,040
it should go into

78
00:03:25,040 --> 00:03:28,000
again at the first level of shuffling it

79
00:03:28,000 --> 00:03:30,319
looks at the first four bytes and it

80
00:03:30,319 --> 00:03:32,480
uses four bits

81
00:03:32,480 --> 00:03:33,680
one for

82
00:03:33,680 --> 00:03:36,239
each byte and determine

83
00:03:36,239 --> 00:03:38,239
which group we should go into if it is

84
00:03:38,239 --> 00:03:40,319
zero then it goes through one group the

85
00:03:40,319 --> 00:03:42,319
first group if it is one then it goes to

86
00:03:42,319 --> 00:03:43,920
the second group or the second half of

87
00:03:43,920 --> 00:03:46,080
the group

88
00:03:46,080 --> 00:03:48,720
and to make sure that at each split

89
00:03:48,720 --> 00:03:51,280
it results in two groups of the equal

90
00:03:51,280 --> 00:03:54,159
size so within those four bits there

91
00:03:54,159 --> 00:03:58,720
must be exactly two ones and two zeros

92
00:03:59,280 --> 00:04:01,200
and then it once it is

93
00:04:01,200 --> 00:04:02,640
done with the first four bytes and it

94
00:04:02,640 --> 00:04:04,239
looks at the next four white and again

95
00:04:04,239 --> 00:04:07,439
it uses another four bits having exactly

96
00:04:07,439 --> 00:04:09,599
two ones and two zeros

97
00:04:09,599 --> 00:04:11,040
and split

98
00:04:11,040 --> 00:04:13,040
two bytes into one room and another two

99
00:04:13,040 --> 00:04:15,439
bytes into another group and again the

100
00:04:15,439 --> 00:04:20,079
next four bytes and the last four bodies

101
00:04:20,079 --> 00:04:22,240
and if we look at the total number of

102
00:04:22,240 --> 00:04:24,880
permutation that can be produced by the

103
00:04:24,880 --> 00:04:27,360
first level of shuffling

104
00:04:27,360 --> 00:04:31,120
we can see that you uses four bits

105
00:04:31,120 --> 00:04:33,040
having two ones and two zeros there are

106
00:04:33,040 --> 00:04:36,880
exactly six ways to represent this

107
00:04:36,880 --> 00:04:40,000
and we have four sets of those therefore

108
00:04:40,000 --> 00:04:43,199
in total there are 6 to the power 4

109
00:04:43,199 --> 00:04:44,639
total number

110
00:04:44,639 --> 00:04:46,320
of permutation

111
00:04:46,320 --> 00:04:49,360
produced from this level 1.

112
00:04:49,360 --> 00:04:52,000
and in level 2 it uses slightly

113
00:04:52,000 --> 00:04:53,440
different method

114
00:04:53,440 --> 00:04:56,560
for the spreading or shuffling

115
00:04:56,560 --> 00:04:57,680
this time

116
00:04:57,680 --> 00:05:00,720
it looks at two consecutive white

117
00:05:00,720 --> 00:05:02,639
together and then

118
00:05:02,639 --> 00:05:04,720
it either put the first bite into the

119
00:05:04,720 --> 00:05:06,720
first group second right to the second

120
00:05:06,720 --> 00:05:09,199
room or it's one of them around first by

121
00:05:09,199 --> 00:05:11,759
goes to the second row and second by

122
00:05:11,759 --> 00:05:13,280
square to the first group

123
00:05:13,280 --> 00:05:14,400
and so on

124
00:05:14,400 --> 00:05:17,680
which means that it uses only one bit to

125
00:05:17,680 --> 00:05:19,600
determine two bytes

126
00:05:19,600 --> 00:05:22,160
and in total there are 16 bytes so it

127
00:05:22,160 --> 00:05:25,280
uses eight bits or the total of 6 oh

128
00:05:25,280 --> 00:05:27,680
sorry 2 to the power of 8 possible

129
00:05:27,680 --> 00:05:30,560
number of permutations produces at this

130
00:05:30,560 --> 00:05:33,440
level 2.

131
00:05:33,520 --> 00:05:35,280
and at level 3

132
00:05:35,280 --> 00:05:37,759
it goes back and use the same method as

133
00:05:37,759 --> 00:05:39,759
in level one

134
00:05:39,759 --> 00:05:42,160
again at this level at this moment we

135
00:05:42,160 --> 00:05:44,720
have a group of four bytes it uses four

136
00:05:44,720 --> 00:05:48,080
bits and each bit determine each of the

137
00:05:48,080 --> 00:05:50,560
byte if it is zero it goes to one group

138
00:05:50,560 --> 00:05:53,520
if it is one it goes to another group

139
00:05:53,520 --> 00:05:56,400
and again it must be exactly two ones

140
00:05:56,400 --> 00:05:58,880
and two zeros to guarantee that

141
00:05:58,880 --> 00:06:02,080
the group is equally sweet

142
00:06:02,080 --> 00:06:04,720
therefore it has exactly the same number

143
00:06:04,720 --> 00:06:07,680
of possible permutation as in level 1 or

144
00:06:07,680 --> 00:06:10,880
6 to the power of 4.

145
00:06:10,880 --> 00:06:13,759
finally at level 4 the last level of

146
00:06:13,759 --> 00:06:16,800
shuffling it again uses similar approach

147
00:06:16,800 --> 00:06:20,000
as level 2. it looks at two consecutive

148
00:06:20,000 --> 00:06:23,039
bites at the same time using one bit

149
00:06:23,039 --> 00:06:25,919
to determine where to swap them around

150
00:06:25,919 --> 00:06:28,319
or does not sweat

151
00:06:28,319 --> 00:06:30,479
therefore at this level

152
00:06:30,479 --> 00:06:32,720
there are again two to the power of

153
00:06:32,720 --> 00:06:36,400
eight possible number of permutation

154
00:06:36,400 --> 00:06:38,720
and if we put everything together we can

155
00:06:38,720 --> 00:06:41,440
see that pilsner produces

156
00:06:41,440 --> 00:06:43,160
2 to the power of

157
00:06:43,160 --> 00:06:46,840
36.7 possible

158
00:06:46,840 --> 00:06:51,360
permutation and if we compare this

159
00:06:51,360 --> 00:06:54,000
to a random permutation of 16 byte which

160
00:06:54,000 --> 00:06:58,319
is 16 factorial it is 2 to the power 44.

161
00:06:58,319 --> 00:07:00,479
so there's a gap between

162
00:07:00,479 --> 00:07:03,599
permutation that fusion produces

163
00:07:03,599 --> 00:07:04,479
and

164
00:07:04,479 --> 00:07:07,120
random permutation

165
00:07:07,120 --> 00:07:09,440
and actually with the random permutation

166
00:07:09,440 --> 00:07:10,720
itself

167
00:07:10,720 --> 00:07:13,120
it may expose weakness

168
00:07:13,120 --> 00:07:16,720
when they do not mix device enough

169
00:07:16,720 --> 00:07:20,160
and we want to explore these weaknesses

170
00:07:20,160 --> 00:07:22,720
in particular we are interested in

171
00:07:22,720 --> 00:07:24,080
weaknesses

172
00:07:24,080 --> 00:07:25,840
that permutation

173
00:07:25,840 --> 00:07:26,880
preserve

174
00:07:26,880 --> 00:07:27,450
a column

175
00:07:27,450 --> 00:07:28,560
[Music]

176
00:07:28,560 --> 00:07:30,639
and we will take a look what we mean by

177
00:07:30,639 --> 00:07:32,560
preserve for columns

178
00:07:32,560 --> 00:07:35,360
what we mean by price of a column we are

179
00:07:35,360 --> 00:07:38,080
looking at shift row that move all bys

180
00:07:38,080 --> 00:07:39,759
in one column

181
00:07:39,759 --> 00:07:42,240
to another column again in a single

182
00:07:42,240 --> 00:07:43,360
column

183
00:07:43,360 --> 00:07:45,199
that's in the figure

184
00:07:45,199 --> 00:07:47,759
so we move column two to column four

185
00:07:47,759 --> 00:07:50,639
rows can be shuffled around but again it

186
00:07:50,639 --> 00:07:51,680
align

187
00:07:51,680 --> 00:07:54,400
in the same single column

188
00:07:54,400 --> 00:07:57,199
and why is this interesting if we have

189
00:07:57,199 --> 00:08:00,319
this imagine that if we have this

190
00:08:00,319 --> 00:08:03,360
for the entire 10 round

191
00:08:03,360 --> 00:08:05,440
we can easily distinguish between

192
00:08:05,440 --> 00:08:07,520
plaintext that produce from this

193
00:08:07,520 --> 00:08:09,919
permutation that preserve columns and

194
00:08:09,919 --> 00:08:11,680
the

195
00:08:11,680 --> 00:08:13,759
permutation or

196
00:08:13,759 --> 00:08:16,319
ciphertext or random ciphertext

197
00:08:16,319 --> 00:08:17,759
because with this

198
00:08:17,759 --> 00:08:19,520
we can easily see that

199
00:08:19,520 --> 00:08:21,440
at starting point and the ending point

200
00:08:21,440 --> 00:08:24,080
we have exactly same

201
00:08:24,080 --> 00:08:25,199
four

202
00:08:25,199 --> 00:08:27,520
columns i mean one column four bytes in

203
00:08:27,520 --> 00:08:29,199
the same columns

204
00:08:29,199 --> 00:08:31,599
that are preserved

205
00:08:31,599 --> 00:08:32,799
with this

206
00:08:32,799 --> 00:08:34,399
we can build a distinguisher to

207
00:08:34,399 --> 00:08:36,399
distinguish between

208
00:08:36,399 --> 00:08:37,599
ciphertexts

209
00:08:37,599 --> 00:08:39,200
that produce from pure zoom and the

210
00:08:39,200 --> 00:08:41,360
random subjects

211
00:08:41,360 --> 00:08:43,519
and this is a simple

212
00:08:43,519 --> 00:08:44,640
or

213
00:08:44,640 --> 00:08:48,000
two simple ways to express why we care

214
00:08:48,000 --> 00:08:51,279
about this column preserve shift

215
00:08:51,279 --> 00:08:52,839
shift row or

216
00:08:52,839 --> 00:08:55,920
permutation and to build

217
00:08:55,920 --> 00:08:56,640
a

218
00:08:56,640 --> 00:09:00,399
distinguisher we can reduce to actually

219
00:09:00,399 --> 00:09:01,680
looking at

220
00:09:01,680 --> 00:09:03,600
permutation that preserve from two to

221
00:09:03,600 --> 00:09:05,360
round nine

222
00:09:05,360 --> 00:09:07,120
to take a look into more detail so we

223
00:09:07,120 --> 00:09:09,440
start again with two plain text

224
00:09:09,440 --> 00:09:10,240
that

225
00:09:10,240 --> 00:09:12,080
differ at one byte

226
00:09:12,080 --> 00:09:14,080
and in the first row

227
00:09:14,080 --> 00:09:17,200
shift row will move that bias around and

228
00:09:17,200 --> 00:09:18,880
with the mixed column it will probably

229
00:09:18,880 --> 00:09:21,360
get a difference as to entire column and

230
00:09:21,360 --> 00:09:23,839
if it happens that that is a column

231
00:09:23,839 --> 00:09:26,000
that's preserved from round two to round

232
00:09:26,000 --> 00:09:28,640
nine then by the end of round nine we

233
00:09:28,640 --> 00:09:31,920
have two ciphertexts or in this in

234
00:09:31,920 --> 00:09:34,720
internal side of the ciphertext

235
00:09:34,720 --> 00:09:37,600
that have exactly one columns that is

236
00:09:37,600 --> 00:09:39,920
different or four by difference

237
00:09:39,920 --> 00:09:42,720
and round ten shift row will permeate

238
00:09:42,720 --> 00:09:45,040
those four bytes around and because

239
00:09:45,040 --> 00:09:47,920
there's no mixed column then it remains

240
00:09:47,920 --> 00:09:49,519
it remains that

241
00:09:49,519 --> 00:09:51,920
we have two cyber cybertexts that have

242
00:09:51,920 --> 00:09:55,360
exactly four bytes that are different

243
00:09:55,360 --> 00:09:56,959
and in another case

244
00:09:56,959 --> 00:09:59,040
it is the case that the differences is

245
00:09:59,040 --> 00:10:01,440
not in the column that is preserved in

246
00:10:01,440 --> 00:10:03,519
this situation we start quite the same

247
00:10:03,519 --> 00:10:06,320
way so we are looking at two plaintexts

248
00:10:06,320 --> 00:10:08,399
that differ at one byte

249
00:10:08,399 --> 00:10:10,399
and with the first round shift row will

250
00:10:10,399 --> 00:10:12,480
move that byte around and mix column

251
00:10:12,480 --> 00:10:14,399
will propagate the differences through

252
00:10:14,399 --> 00:10:15,839
entire column

253
00:10:15,839 --> 00:10:18,079
and if it happens that it is not the

254
00:10:18,079 --> 00:10:19,920
column that's preserved

255
00:10:19,920 --> 00:10:21,519
which means that preserve another

256
00:10:21,519 --> 00:10:24,480
columns are already identical

257
00:10:24,480 --> 00:10:26,800
so by the end of round nine we have two

258
00:10:26,800 --> 00:10:28,160
ciphertexts

259
00:10:28,160 --> 00:10:30,160
that have

260
00:10:30,160 --> 00:10:32,240
four identical bytes and again with

261
00:10:32,240 --> 00:10:34,640
round 10 shift row will shift those four

262
00:10:34,640 --> 00:10:36,240
identical white arrows and there's no

263
00:10:36,240 --> 00:10:38,320
mixed column it remains that we still

264
00:10:38,320 --> 00:10:40,480
have four identical bytes

265
00:10:40,480 --> 00:10:43,519
so in either case we ended up having two

266
00:10:43,519 --> 00:10:46,399
ciphertexts that have at least four

267
00:10:46,399 --> 00:10:48,800
identical bytes

268
00:10:48,800 --> 00:10:50,720
and the possibility of two random

269
00:10:50,720 --> 00:10:52,959
ciphertexts that have four identical y's

270
00:10:52,959 --> 00:10:55,040
is very small therefore we can

271
00:10:55,040 --> 00:10:58,320
distinguish between a random permutation

272
00:10:58,320 --> 00:11:03,600
and the one that is created by pierson

273
00:11:03,760 --> 00:11:05,680
and we can even push further this

274
00:11:05,680 --> 00:11:07,279
distinguisher and build a better

275
00:11:07,279 --> 00:11:08,880
distinguisher by

276
00:11:08,880 --> 00:11:11,200
reducing the requirement of resolving

277
00:11:11,200 --> 00:11:13,360
from round two to round nine to round

278
00:11:13,360 --> 00:11:15,680
three to round nine

279
00:11:15,680 --> 00:11:18,079
and to do so we start with two

280
00:11:18,079 --> 00:11:20,800
ciphertexts sorry two plain texts that

281
00:11:20,800 --> 00:11:23,760
differ at four different bytes

282
00:11:23,760 --> 00:11:25,839
and at the first round the first shift

283
00:11:25,839 --> 00:11:28,399
row happens to shift those four bytes

284
00:11:28,399 --> 00:11:30,320
into the same column so they all align

285
00:11:30,320 --> 00:11:32,880
in one column and mixed column happens

286
00:11:32,880 --> 00:11:35,440
to collapse those differences into one

287
00:11:35,440 --> 00:11:36,640
byte

288
00:11:36,640 --> 00:11:39,120
so at this step we have two internal

289
00:11:39,120 --> 00:11:42,720
state that different and one body

290
00:11:42,720 --> 00:11:45,040
and from round two shift row will move

291
00:11:45,040 --> 00:11:47,040
that binds around and mixed column will

292
00:11:47,040 --> 00:11:48,399
probably get the differences to the

293
00:11:48,399 --> 00:11:49,760
entire column

294
00:11:49,760 --> 00:11:51,920
and now we can consider

295
00:11:51,920 --> 00:11:52,800
shift

296
00:11:52,800 --> 00:11:54,160
c throw

297
00:11:54,160 --> 00:11:56,000
that preserved

298
00:11:56,000 --> 00:11:57,440
columns from round three to round nine

299
00:11:57,440 --> 00:11:59,839
so by the end of round nine we will have

300
00:11:59,839 --> 00:12:02,880
two ciphertexts that differ

301
00:12:02,880 --> 00:12:04,240
at four bytes

302
00:12:04,240 --> 00:12:06,320
and because routine subflow will shift

303
00:12:06,320 --> 00:12:08,880
just four binds around no mix column

304
00:12:08,880 --> 00:12:11,120
differences remain at four different

305
00:12:11,120 --> 00:12:12,720
body

306
00:12:12,720 --> 00:12:14,079
we can have

307
00:12:14,079 --> 00:12:16,639
this distinguisher of the requirement of

308
00:12:16,639 --> 00:12:19,200
preserving only from round three to

309
00:12:19,200 --> 00:12:21,040
round nine

310
00:12:21,040 --> 00:12:22,560
so now that

311
00:12:22,560 --> 00:12:25,120
we know what we are looking for we are

312
00:12:25,120 --> 00:12:26,240
looking for

313
00:12:26,240 --> 00:12:28,880
wikis or key status of columns

314
00:12:28,880 --> 00:12:31,440
and we now need to see whether this wiki

315
00:12:31,440 --> 00:12:34,480
exists at all in pewson

316
00:12:34,480 --> 00:12:38,720
now we need to see we need to explain

317
00:12:38,720 --> 00:12:42,480
how we search for such wiki

318
00:12:42,480 --> 00:12:44,560
so we

319
00:12:44,560 --> 00:12:46,480
develop an algorithm an efficient

320
00:12:46,480 --> 00:12:49,040
algorithm to search for such wikis

321
00:12:49,040 --> 00:12:52,399
and first let me recall let me recall

322
00:12:52,399 --> 00:12:55,480
about the round key so one round key has

323
00:12:55,480 --> 00:13:00,399
128 bits because this uses um for

324
00:13:00,399 --> 00:13:02,399
its uses for

325
00:13:02,399 --> 00:13:04,160
several permutation and we have four

326
00:13:04,160 --> 00:13:06,320
level of suffering

327
00:13:06,320 --> 00:13:09,440
and we shop for around 16 bytes and each

328
00:13:09,440 --> 00:13:13,920
by has eight bits so in total 128 bits

329
00:13:13,920 --> 00:13:16,720
and we start from round key three

330
00:13:16,720 --> 00:13:19,200
because we want to preserve from row

331
00:13:19,200 --> 00:13:20,800
three to round

332
00:13:20,800 --> 00:13:22,480
to round nine

333
00:13:22,480 --> 00:13:25,680
with this we select the first six total

334
00:13:25,680 --> 00:13:28,560
bits at random and we check

335
00:13:28,560 --> 00:13:29,680
whether

336
00:13:29,680 --> 00:13:32,880
this key can preserve a column or not

337
00:13:32,880 --> 00:13:35,279
recall that this part of the key

338
00:13:35,279 --> 00:13:37,279
corresponds to the first two level of

339
00:13:37,279 --> 00:13:39,040
shuffling

340
00:13:39,040 --> 00:13:40,560
and

341
00:13:40,560 --> 00:13:42,800
we want to make sure that

342
00:13:42,800 --> 00:13:44,639
the columns still

343
00:13:44,639 --> 00:13:47,120
align in the position that

344
00:13:47,120 --> 00:13:48,880
well the columns still move to the

345
00:13:48,880 --> 00:13:50,959
position that they can still align in

346
00:13:50,959 --> 00:13:52,800
the same column

347
00:13:52,800 --> 00:13:54,800
and once we have that

348
00:13:54,800 --> 00:13:58,639
we continue proceed to select

349
00:13:58,639 --> 00:14:02,000
the second half the 64 the remaining 64

350
00:14:02,000 --> 00:14:04,240
bits of the round k3 and once we have

351
00:14:04,240 --> 00:14:06,399
the entire row key 3 we can check

352
00:14:06,399 --> 00:14:09,279
whether this round k3 indeed preserve a

353
00:14:09,279 --> 00:14:11,279
column or not

354
00:14:11,279 --> 00:14:13,839
if it's preserved then we continue

355
00:14:13,839 --> 00:14:17,440
to look at round key 4 we select 30 the

356
00:14:17,440 --> 00:14:19,760
first 32 bits at random

357
00:14:19,760 --> 00:14:23,440
and once we have in total 160 bits

358
00:14:23,440 --> 00:14:26,959
we can now expand the entire round key

359
00:14:26,959 --> 00:14:29,040
so we do so we expand and then we check

360
00:14:29,040 --> 00:14:30,480
whether this key

361
00:14:30,480 --> 00:14:33,120
can preserve to round nine or not if it

362
00:14:33,120 --> 00:14:36,480
can then we say that we found a weak key

363
00:14:36,480 --> 00:14:39,360
and then we increment this part around

364
00:14:39,360 --> 00:14:41,920
key for the 32 bits that we look at

365
00:14:41,920 --> 00:14:44,079
right now we increment and again we

366
00:14:44,079 --> 00:14:45,920
expand and we check whether it can

367
00:14:45,920 --> 00:14:49,360
preserve or it preservation or key 9.

368
00:14:49,360 --> 00:14:52,240
we increment and we keep iterating this

369
00:14:52,240 --> 00:14:53,519
process

370
00:14:53,519 --> 00:14:56,000
until we say we should change

371
00:14:56,000 --> 00:14:58,560
round k3 it if we decided to change and

372
00:14:58,560 --> 00:15:01,440
we will go back to step one we re select

373
00:15:01,440 --> 00:15:03,440
the first six star bit at random and we

374
00:15:03,440 --> 00:15:06,800
check whether it can reserve a column if

375
00:15:06,800 --> 00:15:09,600
yes then we continue to select the

376
00:15:09,600 --> 00:15:11,680
second half six four bit at random and

377
00:15:11,680 --> 00:15:13,839
check that indeed this entire round is

378
00:15:13,839 --> 00:15:16,800
really present a color

379
00:15:16,800 --> 00:15:17,920
continue

380
00:15:17,920 --> 00:15:21,600
to round key 4 and so on

381
00:15:21,600 --> 00:15:24,320
once we have algorithm we implemented

382
00:15:24,320 --> 00:15:27,440
this algorithm

383
00:15:27,440 --> 00:15:30,320
and we let it run on phoenix high

384
00:15:30,320 --> 00:15:32,800
performance cluster at the university of

385
00:15:32,800 --> 00:15:34,000
adelaide

386
00:15:34,000 --> 00:15:36,160
we send it out we let it run and with

387
00:15:36,160 --> 00:15:38,240
this high performance it can explore

388
00:15:38,240 --> 00:15:41,279
approximately 2 to the power of 25 keys

389
00:15:41,279 --> 00:15:43,440
per chord per second

390
00:15:43,440 --> 00:15:45,279
we spent quite some time

391
00:15:45,279 --> 00:15:46,399
more than

392
00:15:46,399 --> 00:15:48,959
10 000 cpu hours

393
00:15:48,959 --> 00:15:51,440
and at the end of the run we found

394
00:15:51,440 --> 00:15:54,639
multiple potential key that preserve

395
00:15:54,639 --> 00:15:57,440
from round three to round eight

396
00:15:57,440 --> 00:15:59,920
we could let it run further and to try

397
00:15:59,920 --> 00:16:01,680
to find the ones that preserve from

398
00:16:01,680 --> 00:16:04,959
round key to round nine but we say it's

399
00:16:04,959 --> 00:16:06,160
it's

400
00:16:06,160 --> 00:16:08,320
we should at least check whether our

401
00:16:08,320 --> 00:16:11,040
algorithm works or not

402
00:16:11,040 --> 00:16:12,880
so because we don't have it until round

403
00:16:12,880 --> 00:16:15,600
nine so we need to modify the original

404
00:16:15,600 --> 00:16:18,480
pizza so we modified it to reduce round

405
00:16:18,480 --> 00:16:19,680
pizza

406
00:16:19,680 --> 00:16:22,880
specifically with a 9round fusion and we

407
00:16:22,880 --> 00:16:25,040
test against this

408
00:16:25,040 --> 00:16:26,880
and

409
00:16:26,880 --> 00:16:28,959
we found out that our attack actually

410
00:16:28,959 --> 00:16:30,720
failed

411
00:16:30,720 --> 00:16:34,079
we try to investigate what went wrong

412
00:16:34,079 --> 00:16:36,639
and we noticed that there's a confusion

413
00:16:36,639 --> 00:16:40,000
between the representation

414
00:16:40,000 --> 00:16:42,480
in pearson code

415
00:16:42,480 --> 00:16:45,279
it uses two representation for internal

416
00:16:45,279 --> 00:16:46,240
state

417
00:16:46,240 --> 00:16:47,680
but the first one

418
00:16:47,680 --> 00:16:51,440
is in the vector format for 16 bytes and

419
00:16:51,440 --> 00:16:53,440
the other one is in the form of two

420
00:16:53,440 --> 00:16:55,680
dimensional array

421
00:16:55,680 --> 00:16:57,120
and

422
00:16:57,120 --> 00:17:01,000
these two representations are keep

423
00:17:01,000 --> 00:17:02,639
distribution

424
00:17:02,639 --> 00:17:05,520
changing within the implementation

425
00:17:05,520 --> 00:17:07,119
and we thought that

426
00:17:07,119 --> 00:17:09,679
from vector to two-dimensional array we

427
00:17:09,679 --> 00:17:12,799
thought that it uses row first order or

428
00:17:12,799 --> 00:17:15,119
on the left-hand side of the figure

429
00:17:15,119 --> 00:17:18,400
but in reality pilsen uses column first

430
00:17:18,400 --> 00:17:20,480
order when the right-hand side of the

431
00:17:20,480 --> 00:17:20,829
figure

432
00:17:20,829 --> 00:17:22,319
[Music]

433
00:17:22,319 --> 00:17:24,319
what it means is that

434
00:17:24,319 --> 00:17:25,119
our

435
00:17:25,119 --> 00:17:28,160
our algorithm actually sources for shift

436
00:17:28,160 --> 00:17:30,799
rows that preserve row rather than

437
00:17:30,799 --> 00:17:32,640
column

438
00:17:32,640 --> 00:17:33,600
so

439
00:17:33,600 --> 00:17:38,240
even though we have efficient algorithm

440
00:17:38,559 --> 00:17:41,440
but the security impact

441
00:17:41,440 --> 00:17:42,480
of

442
00:17:42,480 --> 00:17:44,640
raw preserve

443
00:17:44,640 --> 00:17:46,640
is questionable

444
00:17:46,640 --> 00:17:49,280
why is that if you take a look at aes

445
00:17:49,280 --> 00:17:54,000
aes chi from actually preserves our role

446
00:17:54,000 --> 00:17:56,880
once we have a more understanding of

447
00:17:56,880 --> 00:17:59,600
pearson we again we investigate

448
00:17:59,600 --> 00:18:02,640
whether it indeed can have

449
00:18:02,640 --> 00:18:05,120
permutations that preserve columns or

450
00:18:05,120 --> 00:18:06,400
not

451
00:18:06,400 --> 00:18:08,640
now i use colors to the same colors to

452
00:18:08,640 --> 00:18:10,480
represent the same columns because it is

453
00:18:10,480 --> 00:18:12,960
column first order so the first four

454
00:18:12,960 --> 00:18:15,360
bytes is one column and the next four

455
00:18:15,360 --> 00:18:17,840
bar is the next column

456
00:18:17,840 --> 00:18:19,919
again if we look at the shuffling

457
00:18:19,919 --> 00:18:22,880
algorithm the first level of shuffling

458
00:18:22,880 --> 00:18:24,160
splits into

459
00:18:24,160 --> 00:18:26,960
two half of the same size and it looks

460
00:18:26,960 --> 00:18:29,520
at four consecutive bytes

461
00:18:29,520 --> 00:18:31,600
which has which means that it looks at

462
00:18:31,600 --> 00:18:33,679
one column at a time

463
00:18:33,679 --> 00:18:35,679
and then it splits

464
00:18:35,679 --> 00:18:37,840
two bytes into one group

465
00:18:37,840 --> 00:18:40,320
another two bites into another group

466
00:18:40,320 --> 00:18:42,720
and again there's no mixing across two

467
00:18:42,720 --> 00:18:45,360
different groups

468
00:18:45,600 --> 00:18:48,080
and it then once it's done with the

469
00:18:48,080 --> 00:18:49,760
first column it looks at the next column

470
00:18:49,760 --> 00:18:52,320
and again it puts two bytes of that

471
00:18:52,320 --> 00:18:54,240
columns into one group another two buys

472
00:18:54,240 --> 00:18:56,320
into another group the same for the

473
00:18:56,320 --> 00:18:59,440
third columns and fourth columns

474
00:18:59,440 --> 00:19:01,440
that is the first level

475
00:19:01,440 --> 00:19:04,080
and in the second level it looks at two

476
00:19:04,080 --> 00:19:06,720
consecutive bytes

477
00:19:06,720 --> 00:19:08,320
which have should come from the same

478
00:19:08,320 --> 00:19:11,039
columns and then it split them into two

479
00:19:11,039 --> 00:19:13,600
different groups

480
00:19:13,600 --> 00:19:16,230
so it means that at this step

481
00:19:16,230 --> 00:19:17,520
[Music]

482
00:19:17,520 --> 00:19:20,880
one column a new column each byte of the

483
00:19:20,880 --> 00:19:23,440
new column must come from each of the

484
00:19:23,440 --> 00:19:25,840
previous columns so it takes one byte

485
00:19:25,840 --> 00:19:26,799
from

486
00:19:26,799 --> 00:19:29,200
one byte from one column one by from

487
00:19:29,200 --> 00:19:31,039
another column one byte from another and

488
00:19:31,039 --> 00:19:32,880
one from laggard and put it into one

489
00:19:32,880 --> 00:19:35,280
column

490
00:19:35,919 --> 00:19:37,760
and the last two level of shuffling

491
00:19:37,760 --> 00:19:40,320
basically shuffle within

492
00:19:40,320 --> 00:19:41,280
those

493
00:19:41,280 --> 00:19:43,039
columns

494
00:19:43,039 --> 00:19:45,120
what it means is that

495
00:19:45,120 --> 00:19:47,360
piercing shift row permutation actually

496
00:19:47,360 --> 00:19:52,000
ensures that no columns are preserved

497
00:19:52,000 --> 00:19:53,440
to summarize

498
00:19:53,440 --> 00:19:56,160
in this work we analyze pearson an

499
00:19:56,160 --> 00:19:58,720
as-like cipher with key dependent shift

500
00:19:58,720 --> 00:20:00,320
row permutation

501
00:20:00,320 --> 00:20:03,520
and we demonstrate how a is like cipher

502
00:20:03,520 --> 00:20:04,880
with weak

503
00:20:04,880 --> 00:20:07,440
shift flow permutation can be attacked

504
00:20:07,440 --> 00:20:10,159
specifically shift flow permutation dot

505
00:20:10,159 --> 00:20:12,159
preserve column

506
00:20:12,159 --> 00:20:13,919
we also present techniques to

507
00:20:13,919 --> 00:20:16,880
efficiently search for such weak keys we

508
00:20:16,880 --> 00:20:19,039
spend quite some resources to search for

509
00:20:19,039 --> 00:20:22,000
that and we learned that or we should

510
00:20:22,000 --> 00:20:23,919
highlight the benefit of early

511
00:20:23,919 --> 00:20:26,320
verification of the result

512
00:20:26,320 --> 00:20:28,799
if we had tried to verify the result on

513
00:20:28,799 --> 00:20:30,000
for example

514
00:20:30,000 --> 00:20:32,480
one round preserved we would have

515
00:20:32,480 --> 00:20:35,360
identified the error regarding

516
00:20:35,360 --> 00:20:38,480
confusion of representation

517
00:20:38,480 --> 00:20:42,600
thank you very much for your attention

518
00:20:50,240 --> 00:20:53,280
well thank you video for the good

519
00:20:53,280 --> 00:20:54,960
presentation

520
00:20:54,960 --> 00:20:56,320
um

521
00:20:56,320 --> 00:20:57,840
i see that uh

522
00:20:57,840 --> 00:21:01,520
chi channel is here to answer questions

523
00:21:01,520 --> 00:21:04,400
does anyone have any

524
00:21:04,400 --> 00:21:06,640
i have a question

525
00:21:06,640 --> 00:21:08,880
um yeah this is particularly fascinating

526
00:21:08,880 --> 00:21:10,960
to me now as a person who actually has

527
00:21:10,960 --> 00:21:13,360
to develop software and industry and

528
00:21:13,360 --> 00:21:14,880
think about all these tiny little things

529
00:21:14,880 --> 00:21:17,440
of representation this seems like the

530
00:21:17,440 --> 00:21:19,360
kind of error that an implementer could

531
00:21:19,360 --> 00:21:21,440
make too right like using the wrong

532
00:21:21,440 --> 00:21:23,840
representation and therefore creating a

533
00:21:23,840 --> 00:21:25,919
weak version of this cipher instead of a

534
00:21:25,919 --> 00:21:28,000
strong version do you think this might

535
00:21:28,000 --> 00:21:30,480
be a kind of inspiration for formulating

536
00:21:30,480 --> 00:21:33,039
a set of robustness criterion for cypher

537
00:21:33,039 --> 00:21:35,559
design that might protect you against

538
00:21:35,559 --> 00:21:37,440
misimplementation that leads to weak

539
00:21:37,440 --> 00:21:38,799
ciphers do you think there might be a

540
00:21:38,799 --> 00:21:39,840
sort of like

541
00:21:39,840 --> 00:21:42,640
lesson here in terms of that

542
00:21:42,640 --> 00:21:45,440
yeah so i think it's it's very very good

543
00:21:45,440 --> 00:21:47,440
point so that would be uh

544
00:21:47,440 --> 00:21:49,360
implementation error so i think that

545
00:21:49,360 --> 00:21:50,320
would be

546
00:21:50,320 --> 00:21:52,030
like integrated into

547
00:21:52,030 --> 00:21:53,280
[Music]

548
00:21:53,280 --> 00:21:56,480
testing or maybe verification because

549
00:21:56,480 --> 00:21:59,919
i mean so that's like

550
00:21:59,919 --> 00:22:01,679
it could be that there's no there's not

551
00:22:01,679 --> 00:22:03,360
something wrong with the design but then

552
00:22:03,360 --> 00:22:04,720
how the

553
00:22:04,720 --> 00:22:05,760
how

554
00:22:05,760 --> 00:22:08,480
how to implement it how to implement

555
00:22:08,480 --> 00:22:10,960
player implement it so it would be nice

556
00:22:10,960 --> 00:22:12,559
to have some kind of like

557
00:22:12,559 --> 00:22:14,480
test vector into that so if you

558
00:22:14,480 --> 00:22:16,240
implemented this then you test against

559
00:22:16,240 --> 00:22:19,039
this and then you check whether your

560
00:22:19,039 --> 00:22:20,799
implementation

561
00:22:20,799 --> 00:22:24,600
is correct or not

562
00:22:27,200 --> 00:22:29,520
kevin

563
00:22:29,520 --> 00:22:30,880
did you have

564
00:22:30,880 --> 00:22:32,000
uh

565
00:22:32,000 --> 00:22:34,640
a very precise description of the

566
00:22:34,640 --> 00:22:36,400
algorithm or

567
00:22:36,400 --> 00:22:37,919
you were working from a reverse

568
00:22:37,919 --> 00:22:41,840
engineered description of the algorithm

569
00:22:42,320 --> 00:22:44,320
we

570
00:22:44,320 --> 00:22:46,559
worked on the reverse engineer of the

571
00:22:46,559 --> 00:22:48,799
implementation so we have implementation

572
00:22:48,799 --> 00:22:50,960
but it's not our implementation it's the

573
00:22:50,960 --> 00:22:54,880
reverse engineer world of implementation

574
00:22:54,880 --> 00:22:57,120
and did you gain any insight from this

575
00:22:57,120 --> 00:23:00,080
study onto

576
00:23:00,080 --> 00:23:02,720
why they made this modification to aes

577
00:23:02,720 --> 00:23:05,440
in the first place

578
00:23:05,440 --> 00:23:06,880
well i

579
00:23:06,880 --> 00:23:10,240
believe what we believe that well they

580
00:23:10,240 --> 00:23:12,000
don't want to rely

581
00:23:12,000 --> 00:23:14,720
totally on like ways to understand that

582
00:23:14,720 --> 00:23:16,320
for example so they don't want to have

583
00:23:16,320 --> 00:23:18,640
their own standard and probably they

584
00:23:18,640 --> 00:23:21,120
think by having

585
00:23:21,120 --> 00:23:25,200
um key dependent so it's create

586
00:23:25,200 --> 00:23:28,080
more like there's more like hidden data

587
00:23:28,080 --> 00:23:30,480
or something like that so it could be

588
00:23:30,480 --> 00:23:31,760
more secure

589
00:23:31,760 --> 00:23:34,000
instead of having

590
00:23:34,000 --> 00:23:34,960
like

591
00:23:34,960 --> 00:23:37,919
non-dependency on on the key so this

592
00:23:37,919 --> 00:23:40,240
our thought out of belief that that's

593
00:23:40,240 --> 00:23:42,960
why they have their own key dependent

594
00:23:42,960 --> 00:23:45,679
permutation

595
00:23:49,120 --> 00:23:50,960
but it also seems like

596
00:23:50,960 --> 00:23:52,880
it introduces the possibility for weak

597
00:23:52,880 --> 00:23:55,840
keys too in a way that does yes yes

598
00:23:55,840 --> 00:23:58,080
yes yes uh we okay that's why we

599
00:23:58,080 --> 00:24:01,600
investigate whether there's a

600
00:24:01,840 --> 00:24:04,880
possibility after we keep but with the

601
00:24:04,880 --> 00:24:07,279
wiki that we thought

602
00:24:07,279 --> 00:24:10,320
it doesn't exist but it's possible that

603
00:24:10,320 --> 00:24:12,400
there could be different wiki because if

604
00:24:12,400 --> 00:24:15,919
we look at the differences between

605
00:24:15,919 --> 00:24:18,480
total the space of the random

606
00:24:18,480 --> 00:24:20,880
permutation of and the permutation that

607
00:24:20,880 --> 00:24:22,480
person can produce so there's some some

608
00:24:22,480 --> 00:24:24,960
gap so maybe there exists different type

609
00:24:24,960 --> 00:24:26,400
of wikis but

610
00:24:26,400 --> 00:24:30,000
within the this work we we did not find

611
00:24:30,000 --> 00:24:32,400
with the first of column we did not find

612
00:24:32,400 --> 00:24:34,559
that

613
00:24:35,360 --> 00:24:37,279
and uh i i noticed you didn't mention

614
00:24:37,279 --> 00:24:40,080
the financial impact of this work like

615
00:24:40,080 --> 00:24:42,559
you have in your last paragraph

616
00:24:42,559 --> 00:24:44,720
um

617
00:24:44,720 --> 00:24:47,720
yes

618
00:24:49,600 --> 00:24:51,600
i believe that the standard question in

619
00:24:51,600 --> 00:24:54,000
cryptanalysis presentations is whether

620
00:24:54,000 --> 00:24:56,559
adding more rounds would make the cypher

621
00:24:56,559 --> 00:24:58,240
less vulnerable so i'd like to ask

622
00:24:58,240 --> 00:25:01,440
whether removing few rounds would make

623
00:25:01,440 --> 00:25:05,600
it more vulnerable to your attack

624
00:25:05,679 --> 00:25:07,919
um you mean reduce the number of rounds

625
00:25:07,919 --> 00:25:10,880
like from 10 to fewer than 10 rounds

626
00:25:10,880 --> 00:25:14,240
yeah maybe to one

627
00:25:14,240 --> 00:25:17,279
um yes in that

628
00:25:17,279 --> 00:25:19,520
case for

629
00:25:19,520 --> 00:25:20,320
the

630
00:25:20,320 --> 00:25:23,440
shift flow permutation it

631
00:25:23,440 --> 00:25:25,279
i mean there's no

632
00:25:25,279 --> 00:25:27,360
like preserve columns but if it's

633
00:25:27,360 --> 00:25:29,840
reduced to 10 rounds i i would say the

634
00:25:29,840 --> 00:25:32,000
crypto analysis would be somewhat

635
00:25:32,000 --> 00:25:34,480
similar we have to take into account

636
00:25:34,480 --> 00:25:37,520
like if we analyze aes what would be

637
00:25:37,520 --> 00:25:40,159
uh security of radios to 10 uh two one

638
00:25:40,159 --> 00:25:42,640
round or something like that

639
00:25:42,640 --> 00:25:44,640
great

640
00:25:44,640 --> 00:25:46,000
um

641
00:25:46,000 --> 00:25:47,039
then

642
00:25:47,039 --> 00:25:48,880
i'd like to thank

643
00:25:48,880 --> 00:25:51,520
chitna choke and

644
00:25:51,520 --> 00:25:54,080
all the speakers of the session

645
00:25:54,080 --> 00:25:56,159
and we have a 15 minutes break so we

646
00:25:56,159 --> 00:25:57,679
meet again at

647
00:25:57,679 --> 00:26:00,080
15

