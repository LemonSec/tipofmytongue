1
00:00:00,719 --> 00:00:03,679
so let's move on then to our last talk

2
00:00:03,679 --> 00:00:05,759
last but not least of course

3
00:00:05,759 --> 00:00:08,320
um so the last talk's

4
00:00:08,320 --> 00:00:10,719
going to be delivered by simon mall um

5
00:00:10,719 --> 00:00:12,080
simon's currently a professor at the

6
00:00:12,080 --> 00:00:13,759
university of cambridge

7
00:00:13,759 --> 00:00:16,560
he's got extensive experience within

8
00:00:16,560 --> 00:00:18,080
sort of computer architecture and

9
00:00:18,080 --> 00:00:19,520
interests that

10
00:00:19,520 --> 00:00:20,320
uh

11
00:00:20,320 --> 00:00:21,760
encompass the hardware and software

12
00:00:21,760 --> 00:00:23,680
interface and hardware security so i'm

13
00:00:23,680 --> 00:00:26,000
really pleased to agree to speak today

14
00:00:26,000 --> 00:00:28,320
about uh cherry and specifically cherry

15
00:00:28,320 --> 00:00:30,000
risk five or s

16
00:00:30,000 --> 00:00:32,479
simon over to you

17
00:00:32,479 --> 00:00:34,640
well thank you dan um thank you for

18
00:00:34,640 --> 00:00:36,719
earlier speakers giving uh

19
00:00:36,719 --> 00:00:38,879
really useful uh background info

20
00:00:38,879 --> 00:00:41,040
information about memory safety

21
00:00:41,040 --> 00:00:44,079
uh so yeah today i'm going to try and uh

22
00:00:44,079 --> 00:00:46,239
cram in a short talk giving you a bit of

23
00:00:46,239 --> 00:00:50,079
an overview of uh cherry based memory

24
00:00:50,079 --> 00:00:52,160
protection for both spatial and temple

25
00:00:52,160 --> 00:00:53,680
memory safety

26
00:00:53,680 --> 00:00:55,440
uh we originally did this work actually

27
00:00:55,440 --> 00:00:56,480
on mips

28
00:00:56,480 --> 00:00:57,680
we've been

29
00:00:57,680 --> 00:00:59,280
working on a risk five version for the

30
00:00:59,280 --> 00:01:01,760
last few years um

31
00:01:01,760 --> 00:01:03,840
and we'll also look working with arm on

32
00:01:03,840 --> 00:01:05,760
transitioning that technology and

33
00:01:05,760 --> 00:01:07,520
they've been a lot of people involved in

34
00:01:07,520 --> 00:01:08,799
this project

35
00:01:08,799 --> 00:01:11,119
many of them listed there

36
00:01:11,119 --> 00:01:13,840
um

37
00:01:14,080 --> 00:01:16,400
thanks to sponsors so the basic agenda

38
00:01:16,400 --> 00:01:17,680
is

39
00:01:17,680 --> 00:01:19,600
so i'm just going to move the zoom thing

40
00:01:19,600 --> 00:01:21,439
over there we go

41
00:01:21,439 --> 00:01:22,640
um

42
00:01:22,640 --> 00:01:25,200
so give you a bit of motivation tell you

43
00:01:25,200 --> 00:01:28,159
about uh you know concretely what cherry

44
00:01:28,159 --> 00:01:30,720
uh risk life hardware looks like

45
00:01:30,720 --> 00:01:32,720
uh talk a little bit about software

46
00:01:32,720 --> 00:01:35,280
models at a high level uh actually my

47
00:01:35,280 --> 00:01:36,720
colleague robert watson is giving an

48
00:01:36,720 --> 00:01:38,640
invited talk at the main chess

49
00:01:38,640 --> 00:01:40,320
conference so if you want to know more

50
00:01:40,320 --> 00:01:41,840
about the software models

51
00:01:41,840 --> 00:01:44,240
do attend that

52
00:01:44,240 --> 00:01:46,240
i'll tell you about some of the misfired

53
00:01:46,240 --> 00:01:49,600
calls we've created and then wrap up

54
00:01:49,600 --> 00:01:53,680
with exploitation paths and conclusions

55
00:01:53,680 --> 00:01:54,399
so

56
00:01:54,399 --> 00:01:56,399
background uh you know memory safety is

57
00:01:56,399 --> 00:01:59,119
a really big deal uh and you know for

58
00:01:59,119 --> 00:02:01,360
applications and operating systems and

59
00:02:01,360 --> 00:02:04,399
so on you get a lot of memory safety uh

60
00:02:04,399 --> 00:02:05,840
vulnerabilities

61
00:02:05,840 --> 00:02:07,680
and so you know just give you two

62
00:02:07,680 --> 00:02:09,440
examples you know matt miller from

63
00:02:09,440 --> 00:02:11,520
microsoft response center

64
00:02:11,520 --> 00:02:14,239
said that basically over the last 20 odd

65
00:02:14,239 --> 00:02:15,280
years

66
00:02:15,280 --> 00:02:17,280
something like 70 percent of all of

67
00:02:17,280 --> 00:02:19,280
microsoft's vulnerabilities have been

68
00:02:19,280 --> 00:02:21,760
memory safety bugs in first place very

69
00:02:21,760 --> 00:02:24,480
much special memory safety and then uh

70
00:02:24,480 --> 00:02:26,959
second place uh use after three type bug

71
00:02:26,959 --> 00:02:29,440
so temporal memory safety

72
00:02:29,440 --> 00:02:31,680
and uh cherry directly addresses the

73
00:02:31,680 --> 00:02:33,760
first and really helps to address the

74
00:02:33,760 --> 00:02:35,599
second

75
00:02:35,599 --> 00:02:37,840
it's just not not just microsoft seeing

76
00:02:37,840 --> 00:02:39,120
the same thing if you say look at

77
00:02:39,120 --> 00:02:40,640
chromium browser

78
00:02:40,640 --> 00:02:43,360
uh there again about 70 of all their

79
00:02:43,360 --> 00:02:45,599
serious security bugs were memory safety

80
00:02:45,599 --> 00:02:47,760
problems

81
00:02:47,760 --> 00:02:49,360
so how we're going to go about solving

82
00:02:49,360 --> 00:02:52,640
this so the basic cherry approach is

83
00:02:52,640 --> 00:02:54,080
as follows

84
00:02:54,080 --> 00:02:55,760
firstly we have this idea of the sort of

85
00:02:55,760 --> 00:02:58,080
principle of intentional use so we want

86
00:02:58,080 --> 00:03:00,800
to ensure that software runs the way the

87
00:03:00,800 --> 00:03:03,360
programmer intended and not the way the

88
00:03:03,360 --> 00:03:06,080
attacker tried to trick it

89
00:03:06,080 --> 00:03:08,319
the way we actually go about this is to

90
00:03:08,319 --> 00:03:09,920
have a

91
00:03:09,920 --> 00:03:12,159
guaranteed point to integrity and

92
00:03:12,159 --> 00:03:14,640
provenance and very efficient bounds

93
00:03:14,640 --> 00:03:15,920
checking

94
00:03:15,920 --> 00:03:17,440
on those pointers

95
00:03:17,440 --> 00:03:18,879
using a mechanism we'll call

96
00:03:18,879 --> 00:03:21,040
capabilities which i'll tell you more

97
00:03:21,040 --> 00:03:23,040
about in a moment

98
00:03:23,040 --> 00:03:25,280
um

99
00:03:26,560 --> 00:03:29,120
we also are very specific about you know

100
00:03:29,120 --> 00:03:32,159
intentional use of those capabilities

101
00:03:32,159 --> 00:03:33,599
and i'll also tell you more about that

102
00:03:33,599 --> 00:03:35,280
in a minute

103
00:03:35,280 --> 00:03:37,440
another aspect is the principle of least

104
00:03:37,440 --> 00:03:39,599
privilege so we want to reduce the

105
00:03:39,599 --> 00:03:41,080
attack surface using

106
00:03:41,080 --> 00:03:43,519
compartmentalization techniques

107
00:03:43,519 --> 00:03:46,239
and um cherry gives us very efficient

108
00:03:46,239 --> 00:03:49,280
ways of describing uh different sorts of

109
00:03:49,280 --> 00:03:51,920
compartments

110
00:03:51,920 --> 00:03:53,439
and finally should be noted that we're

111
00:03:53,439 --> 00:03:55,519
really interested in deterministic

112
00:03:55,519 --> 00:03:57,519
protection so quite a lot of other

113
00:03:57,519 --> 00:03:59,680
techniques out there that rely on

114
00:03:59,680 --> 00:04:02,319
statistical approaches to me you know to

115
00:04:02,319 --> 00:04:04,560
help uh reduce

116
00:04:04,560 --> 00:04:06,959
memory safety vulnerabilities

117
00:04:06,959 --> 00:04:08,959
but the usual problem with deterministic

118
00:04:08,959 --> 00:04:11,360
approaches or statistical approaches is

119
00:04:11,360 --> 00:04:12,720
that there's usually some way of

120
00:04:12,720 --> 00:04:15,040
bypassing them and we really want to

121
00:04:15,040 --> 00:04:17,680
avoid that

122
00:04:17,918 --> 00:04:22,400
so in terms of implementing this um

123
00:04:22,400 --> 00:04:24,080
we really want to sort of stay within

124
00:04:24,080 --> 00:04:26,320
the risk philosophy so we don't want to

125
00:04:26,320 --> 00:04:29,840
have you know microcode or new lookup

126
00:04:29,840 --> 00:04:33,120
tables or exec exotic memories or

127
00:04:33,120 --> 00:04:35,360
really sort of extending the pipeline a

128
00:04:35,360 --> 00:04:37,919
lot or reducing the clock frequency we

129
00:04:37,919 --> 00:04:39,680
don't want to reduce addressing modes

130
00:04:39,680 --> 00:04:41,440
and so on

131
00:04:41,440 --> 00:04:42,400
also

132
00:04:42,400 --> 00:04:45,120
uh somewhat related uh for this cherry

133
00:04:45,120 --> 00:04:47,040
work we don't rely on cryptography at

134
00:04:47,040 --> 00:04:48,800
all it's just not needed i mean crypto

135
00:04:48,800 --> 00:04:51,759
has its place uh but uh you know just to

136
00:04:51,759 --> 00:04:56,000
say obviously you can have security uh

137
00:04:56,000 --> 00:04:57,840
or you know secure hardware without

138
00:04:57,840 --> 00:05:00,240
using crypto

139
00:05:00,240 --> 00:05:03,520
and we want yes to uh you know low-level

140
00:05:03,520 --> 00:05:06,000
hardware functionality on which many

141
00:05:06,000 --> 00:05:08,479
software's com structures can be built

142
00:05:08,479 --> 00:05:11,039
we want it to be compiler friendly

143
00:05:11,039 --> 00:05:13,600
and we want to get the compiler the link

144
00:05:13,600 --> 00:05:15,520
and the runtime system to do much of the

145
00:05:15,520 --> 00:05:16,639
work

146
00:05:16,639 --> 00:05:18,000
um

147
00:05:18,000 --> 00:05:21,280
not just you know isa plus the decoder

148
00:05:21,280 --> 00:05:22,800
and finally we want to keep it as simple

149
00:05:22,800 --> 00:05:25,759
as possible so how do we go about this

150
00:05:25,759 --> 00:05:28,000
so let me tell you about the

151
00:05:28,000 --> 00:05:30,720
basic principles hardware principles by

152
00:05:30,720 --> 00:05:32,560
cherry and then we'll see how we build

153
00:05:32,560 --> 00:05:35,440
things on top of it

154
00:05:35,759 --> 00:05:37,520
so we've got a new type

155
00:05:37,520 --> 00:05:39,360
the capability

156
00:05:39,360 --> 00:05:41,840
so a capability is a bound check pointer

157
00:05:41,840 --> 00:05:43,280
with integrity

158
00:05:43,280 --> 00:05:45,199
in the cherry world

159
00:05:45,199 --> 00:05:47,680
capabilities are held in memory

160
00:05:47,680 --> 00:05:51,759
and in extended integer registers

161
00:05:51,759 --> 00:05:54,160
so we start with an address 64-bit

162
00:05:54,160 --> 00:05:57,120
address there's also a 32-bit variant

163
00:05:57,120 --> 00:06:00,720
we then add further 64-bits of metadata

164
00:06:00,720 --> 00:06:01,919
that

165
00:06:01,919 --> 00:06:03,280
are part of that

166
00:06:03,280 --> 00:06:06,160
that include permissions confessed

167
00:06:06,160 --> 00:06:07,440
bounds

168
00:06:07,440 --> 00:06:08,319
and

169
00:06:08,319 --> 00:06:10,880
uh a sealed bit i'll tell you more about

170
00:06:10,880 --> 00:06:13,199
in a minute

171
00:06:13,199 --> 00:06:15,919
oh and a hidden validity tag uh the

172
00:06:15,919 --> 00:06:18,000
hidden validity tag actually it's kind

173
00:06:18,000 --> 00:06:19,120
of funny when you start talking to

174
00:06:19,120 --> 00:06:20,639
process architects they hate this

175
00:06:20,639 --> 00:06:23,039
validity attack but we've demonstrated

176
00:06:23,039 --> 00:06:25,199
that it's very easy to support with

177
00:06:25,199 --> 00:06:29,039
conventional memory so more later

178
00:06:29,039 --> 00:06:31,280
the basic idea is that those compressed

179
00:06:31,280 --> 00:06:32,560
bounds

180
00:06:32,560 --> 00:06:35,360
just indicate what region of memory

181
00:06:35,360 --> 00:06:39,039
that address can refer to

182
00:06:39,440 --> 00:06:41,360
and that gives it's a very simple

183
00:06:41,360 --> 00:06:43,280
low-level mechanism on which we can

184
00:06:43,280 --> 00:06:45,840
build many things

185
00:06:45,840 --> 00:06:48,880
to go with this capability we add just a

186
00:06:48,880 --> 00:06:50,639
few new instructions

187
00:06:50,639 --> 00:06:52,960
so we add very specific load and store

188
00:06:52,960 --> 00:06:55,599
instructions that work with bounds check

189
00:06:55,599 --> 00:06:57,120
capabilities

190
00:06:57,120 --> 00:06:58,880
and you get an exception if you try to

191
00:06:58,880 --> 00:07:01,039
dereference a capability where the

192
00:07:01,039 --> 00:07:03,280
address is out of range

193
00:07:03,280 --> 00:07:05,360
we have guarded manipulation of

194
00:07:05,360 --> 00:07:07,840
capabilities so we can decrease bounds

195
00:07:07,840 --> 00:07:10,479
decrease permissions adjust

196
00:07:10,479 --> 00:07:11,599
the address

197
00:07:11,599 --> 00:07:15,360
and extract or test fields

198
00:07:15,360 --> 00:07:17,440
the decreasing bounds and permissions

199
00:07:17,440 --> 00:07:19,440
are absolutely critical to the security

200
00:07:19,440 --> 00:07:22,560
properties here so monotonic decrease in

201
00:07:22,560 --> 00:07:23,919
rights

202
00:07:23,919 --> 00:07:25,039
is something that we've formally

203
00:07:25,039 --> 00:07:26,479
verified

204
00:07:26,479 --> 00:07:28,639
in the isa

205
00:07:28,639 --> 00:07:30,560
since it is so critical

206
00:07:30,560 --> 00:07:33,919
for the security

207
00:07:34,639 --> 00:07:37,440
we also have a sealed mode

208
00:07:37,440 --> 00:07:39,039
which i'm going to just give you a very

209
00:07:39,039 --> 00:07:40,560
quick overview

210
00:07:40,560 --> 00:07:42,840
so sealed capabilities are

211
00:07:42,840 --> 00:07:44,960
non-dereferenceable capabilities i you

212
00:07:44,960 --> 00:07:46,879
can't use them directly to point at

213
00:07:46,879 --> 00:07:49,360
something to to access it

214
00:07:49,360 --> 00:07:52,560
they have to be unsealed first typically

215
00:07:52,560 --> 00:07:55,199
when you do a compartment transition

216
00:07:55,199 --> 00:07:56,960
in order to use it

217
00:07:56,960 --> 00:07:59,919
the main thing is we add a 24-bit object

218
00:07:59,919 --> 00:08:02,639
type and we further compress the bounds

219
00:08:02,639 --> 00:08:05,280
to make that possible

220
00:08:05,280 --> 00:08:08,000
and we set the sealed bit to indicate

221
00:08:08,000 --> 00:08:11,680
that it's a sealed capability

222
00:08:11,680 --> 00:08:15,280
and we use this during uh

223
00:08:15,280 --> 00:08:17,919
compartment transitions so when we're

224
00:08:17,919 --> 00:08:20,000
transitioning from one compartment to

225
00:08:20,000 --> 00:08:21,199
another

226
00:08:21,199 --> 00:08:23,199
uh you start off with the sealed code

227
00:08:23,199 --> 00:08:25,840
capability uh together with the sealed

228
00:08:25,840 --> 00:08:27,599
data capability so that gives you a

229
00:08:27,599 --> 00:08:29,360
pointer to your code and a pointer to

230
00:08:29,360 --> 00:08:31,280
the data space

231
00:08:31,280 --> 00:08:34,320
and the c invoke instruction

232
00:08:34,320 --> 00:08:36,719
basically unpacks those it checks that

233
00:08:36,719 --> 00:08:38,799
the object types match

234
00:08:38,799 --> 00:08:40,958
and you then end up with a program

235
00:08:40,958 --> 00:08:43,039
counter capability and a

236
00:08:43,039 --> 00:08:45,120
data capability

237
00:08:45,120 --> 00:08:46,880
and using this low-level mechanism you

238
00:08:46,880 --> 00:08:48,680
can build lots of different

239
00:08:48,680 --> 00:08:51,200
compartmentalization models

240
00:08:51,200 --> 00:08:52,880
which i will skim over today we don't

241
00:08:52,880 --> 00:08:54,560
have time there'll be another talk in

242
00:08:54,560 --> 00:08:56,959
itself

243
00:08:57,839 --> 00:08:59,519
so let's just quickly tell you about

244
00:08:59,519 --> 00:09:01,440
some of the software models

245
00:09:01,440 --> 00:09:04,480
i think it's worth bearing in mind that

246
00:09:04,480 --> 00:09:06,080
you know when you add some low-level

247
00:09:06,080 --> 00:09:08,640
support like this software can use it in

248
00:09:08,640 --> 00:09:10,720
many different ways

249
00:09:10,720 --> 00:09:12,480
so you know it's sort of a machine level

250
00:09:12,480 --> 00:09:14,560
it's a very simple mechanism

251
00:09:14,560 --> 00:09:16,959
but if you think about it just like you

252
00:09:16,959 --> 00:09:19,040
know we use tlbs for instance to make

253
00:09:19,040 --> 00:09:22,160
virtual memory uh much faster now the

254
00:09:22,160 --> 00:09:23,920
processor in some sense doesn't really

255
00:09:23,920 --> 00:09:26,160
understand virtual memory

256
00:09:26,160 --> 00:09:27,920
in all of its nuances i mean for

257
00:09:27,920 --> 00:09:29,920
instance the processor has no idea what

258
00:09:29,920 --> 00:09:32,399
a guard page is that's a software

259
00:09:32,399 --> 00:09:35,200
construct that just simply makes use of

260
00:09:35,200 --> 00:09:37,040
the paging mechanism

261
00:09:37,040 --> 00:09:38,160
and

262
00:09:38,160 --> 00:09:40,160
in many ways cherries even more so so

263
00:09:40,160 --> 00:09:41,600
once you've got these very low level

264
00:09:41,600 --> 00:09:43,920
mechanisms you can build all sorts of

265
00:09:43,920 --> 00:09:47,760
different software constructs on the top

266
00:09:47,839 --> 00:09:50,880
and we can use cherry in different modes

267
00:09:50,880 --> 00:09:52,399
so

268
00:09:52,399 --> 00:09:56,320
we can really sort of on the one hand be

269
00:09:56,320 --> 00:09:59,040
have unmodified code running

270
00:09:59,040 --> 00:10:01,440
basically legacy binaries where all

271
00:10:01,440 --> 00:10:03,360
pointers are integers

272
00:10:03,360 --> 00:10:05,600
and that means you can just run you know

273
00:10:05,600 --> 00:10:08,000
legacy stuff

274
00:10:08,000 --> 00:10:09,040
um

275
00:10:09,040 --> 00:10:10,480
but you don't really get any security

276
00:10:10,480 --> 00:10:12,480
benefits at all

277
00:10:12,480 --> 00:10:14,320
then at the other extreme we can just

278
00:10:14,320 --> 00:10:17,120
recompile all the code and using our

279
00:10:17,120 --> 00:10:18,640
compiler

280
00:10:18,640 --> 00:10:20,160
all pointers are turned into

281
00:10:20,160 --> 00:10:22,240
capabilities and you actually get an

282
00:10:22,240 --> 00:10:23,680
awful lot of protection just by

283
00:10:23,680 --> 00:10:26,160
recompiling the code

284
00:10:26,160 --> 00:10:28,160
and we also have a hybrid mode where you

285
00:10:28,160 --> 00:10:30,880
can sort of interoperate

286
00:10:30,880 --> 00:10:32,880
between using integer pointers and

287
00:10:32,880 --> 00:10:34,399
capabilities

288
00:10:34,399 --> 00:10:36,240
um and that's particularly useful when

289
00:10:36,240 --> 00:10:37,120
you

290
00:10:37,120 --> 00:10:39,200
uh for instance want to

291
00:10:39,200 --> 00:10:42,079
interface a legacy or wrap a legacy

292
00:10:42,079 --> 00:10:44,959
library uh to have a capability

293
00:10:44,959 --> 00:10:47,839
interface or if you want to interoperate

294
00:10:47,839 --> 00:10:48,880
between

295
00:10:48,880 --> 00:10:50,720
a legacy operating system and a

296
00:10:50,720 --> 00:10:53,920
capability aware application

297
00:10:53,920 --> 00:10:56,560
and finally we have a very good compiler

298
00:10:56,560 --> 00:10:58,079
support now

299
00:10:58,079 --> 00:11:02,560
that generates code for all three models

300
00:11:02,640 --> 00:11:04,959
we tend to focus on the pure capability

301
00:11:04,959 --> 00:11:07,200
side uh that's where we tend to use

302
00:11:07,200 --> 00:11:09,440
things where we recompile everything and

303
00:11:09,440 --> 00:11:11,920
of course at this point you end up with

304
00:11:11,920 --> 00:11:14,160
all your pointers being capabilities so

305
00:11:14,160 --> 00:11:15,920
of course as soon as you want to call

306
00:11:15,920 --> 00:11:17,120
the os

307
00:11:17,120 --> 00:11:20,079
you have to do so using capabilities and

308
00:11:20,079 --> 00:11:22,640
so you need a cherry aware api in much

309
00:11:22,640 --> 00:11:25,360
the same way you know you say got a

310
00:11:25,360 --> 00:11:28,560
64-bit os and you want to run 32-bit

311
00:11:28,560 --> 00:11:32,560
binaries you need a 32-bit aware abi and

312
00:11:32,560 --> 00:11:34,240
here we could have

313
00:11:34,240 --> 00:11:36,800
you know a cherry abi

314
00:11:36,800 --> 00:11:40,079
running on a legacy 64-bit os

315
00:11:40,079 --> 00:11:42,640
providing a compatibility layer and more

316
00:11:42,640 --> 00:11:45,200
recently we've been adding a very good

317
00:11:45,200 --> 00:11:47,279
capability support directly into the

318
00:11:47,279 --> 00:11:49,760
freebsd operating system so in which

319
00:11:49,760 --> 00:11:51,440
case you have a native

320
00:11:51,440 --> 00:11:54,320
cherry abi layer and you can then have

321
00:11:54,320 --> 00:11:57,680
32-bit and 64-bit compatibility layers

322
00:11:57,680 --> 00:12:01,680
to that pure capability os

323
00:12:01,920 --> 00:12:03,760
we've done lots of evaluation work but

324
00:12:03,760 --> 00:12:06,399
there's just one example here where we

325
00:12:06,399 --> 00:12:08,240
are sort of slightly earlier on in the

326
00:12:08,240 --> 00:12:09,839
project

327
00:12:09,839 --> 00:12:12,959
when heartbleed was a new exploit

328
00:12:12,959 --> 00:12:15,440
there was an evaluation team uh in darpa

329
00:12:15,440 --> 00:12:17,920
speaker red team at mit lincoln labs and

330
00:12:17,920 --> 00:12:19,680
they'd taken our stuff

331
00:12:19,680 --> 00:12:21,760
recompiled heartbleed and

332
00:12:21,760 --> 00:12:24,800
lo and behold hot cherry just mitigated

333
00:12:24,800 --> 00:12:26,560
heartbleed without having to make any

334
00:12:26,560 --> 00:12:28,959
further software changes at all

335
00:12:28,959 --> 00:12:30,959
which is a good start

336
00:12:30,959 --> 00:12:33,519
we also use cherry to

337
00:12:33,519 --> 00:12:36,079
give us more robustness against control

338
00:12:36,079 --> 00:12:37,839
flow attacks

339
00:12:37,839 --> 00:12:39,360
so we

340
00:12:39,360 --> 00:12:42,079
we actually not only use

341
00:12:42,079 --> 00:12:44,560
capabilities as pointers to data but we

342
00:12:44,560 --> 00:12:47,040
also use them as pointers to code

343
00:12:47,040 --> 00:12:49,440
so if you put a capability on a stack so

344
00:12:49,440 --> 00:12:52,560
return address on the stack

345
00:12:52,560 --> 00:12:53,680
if you

346
00:12:53,680 --> 00:12:56,639
trick the code to overwrite that with

347
00:12:56,639 --> 00:12:57,760
data

348
00:12:57,760 --> 00:12:59,200
then it

349
00:12:59,200 --> 00:13:01,360
automatically becomes

350
00:13:01,360 --> 00:13:04,560
if it invalidates that return address it

351
00:13:04,560 --> 00:13:07,120
is no longer a valid capability

352
00:13:07,120 --> 00:13:10,079
similarly if you uh put a

353
00:13:10,079 --> 00:13:12,959
you know a pointer to some data there it

354
00:13:12,959 --> 00:13:15,519
is no longer an executable capability so

355
00:13:15,519 --> 00:13:17,760
you wouldn't get a return from it

356
00:13:17,760 --> 00:13:19,200
so it gives us quite a lot of control

357
00:13:19,200 --> 00:13:21,839
for robustness

358
00:13:22,480 --> 00:13:24,240
the other thing that is very powerful

359
00:13:24,240 --> 00:13:26,399
about the cherry model

360
00:13:26,399 --> 00:13:30,079
is a very efficient compartmentalization

361
00:13:30,079 --> 00:13:33,040
you can effectively have you can isolate

362
00:13:33,040 --> 00:13:36,079
compartments using

363
00:13:36,079 --> 00:13:39,360
sort of sets or graphs of capabilities

364
00:13:39,360 --> 00:13:41,279
so you know you can have one protection

365
00:13:41,279 --> 00:13:43,519
domain where that has one set of

366
00:13:43,519 --> 00:13:45,519
capabilities you can have another

367
00:13:45,519 --> 00:13:47,040
protection domain that has a different

368
00:13:47,040 --> 00:13:48,639
set of capabilities

369
00:13:48,639 --> 00:13:50,800
and potentially also very efficiently

370
00:13:50,800 --> 00:13:52,560
share data

371
00:13:52,560 --> 00:13:55,600
between those protection domains

372
00:13:55,600 --> 00:13:58,399
as appropriate

373
00:14:01,199 --> 00:14:04,000
temple memory safety uh isn't directly

374
00:14:04,000 --> 00:14:07,199
provided by the hardware however because

375
00:14:07,199 --> 00:14:09,839
we now have um

376
00:14:09,839 --> 00:14:11,839
this validity tag on every single

377
00:14:11,839 --> 00:14:13,040
pointer

378
00:14:13,040 --> 00:14:15,839
it becomes much easier to

379
00:14:15,839 --> 00:14:18,720
quickly scan memory and identify where

380
00:14:18,720 --> 00:14:21,360
the pointers are and to revoke

381
00:14:21,360 --> 00:14:22,880
references

382
00:14:22,880 --> 00:14:24,480
to memory regions that have been

383
00:14:24,480 --> 00:14:27,760
deallocated thereby mitigating use after

384
00:14:27,760 --> 00:14:30,240
free vulnerabilities

385
00:14:30,240 --> 00:14:32,399
so

386
00:14:32,720 --> 00:14:34,399
and i'll show you some data in just a

387
00:14:34,399 --> 00:14:35,360
minute

388
00:14:35,360 --> 00:14:36,800
we've got a couple of papers on this

389
00:14:36,800 --> 00:14:40,800
already and it's work in progress

390
00:14:41,440 --> 00:14:43,199
the

391
00:14:43,199 --> 00:14:45,040
current data indicates that we've really

392
00:14:45,040 --> 00:14:47,360
got state of the art uh runtime

393
00:14:47,360 --> 00:14:50,320
overheads of incredibly low overheads

394
00:14:50,320 --> 00:14:53,360
um even using the cornucopia system and

395
00:14:53,360 --> 00:14:55,040
we're looking at reducing the overheads

396
00:14:55,040 --> 00:14:56,480
even further

397
00:14:56,480 --> 00:14:58,000
so you can have very strong temporal

398
00:14:58,000 --> 00:15:02,320
memory safety for very little cost

399
00:15:05,440 --> 00:15:07,839
okay so let's just sort of summarize the

400
00:15:07,839 --> 00:15:09,680
capability protections that we have and

401
00:15:09,680 --> 00:15:12,639
then we'll look at uh hardware

402
00:15:12,639 --> 00:15:15,839
so you get integrity and provenance

403
00:15:15,839 --> 00:15:17,680
you get bounce checking you get

404
00:15:17,680 --> 00:15:19,839
monotonicity so you can't increase your

405
00:15:19,839 --> 00:15:21,360
privileges

406
00:15:21,360 --> 00:15:23,839
and you get very strong checking of

407
00:15:23,839 --> 00:15:25,440
permissions

408
00:15:25,440 --> 00:15:27,680
it's opens you can't accidentally you

409
00:15:27,680 --> 00:15:29,920
know execute some data

410
00:15:29,920 --> 00:15:33,519
uh or vice versa

411
00:15:34,639 --> 00:15:36,480
so let's just quickly talk about some of

412
00:15:36,480 --> 00:15:38,560
the implementations that we've done

413
00:15:38,560 --> 00:15:41,199
we've done sort of you know tablet type

414
00:15:41,199 --> 00:15:43,600
demonstrations which are quite useful to

415
00:15:43,600 --> 00:15:45,920
wheel around at poster sessions and

416
00:15:45,920 --> 00:15:46,800
things

417
00:15:46,800 --> 00:15:48,720
we've done a number of implementations

418
00:15:48,720 --> 00:15:49,680
so

419
00:15:49,680 --> 00:15:50,800
um

420
00:15:50,800 --> 00:15:53,360
we our early work was on mips

421
00:15:53,360 --> 00:15:55,440
our current work is on risk five and on

422
00:15:55,440 --> 00:15:57,040
risk five we have

423
00:15:57,040 --> 00:15:59,839
uh you know fairly short pipelined uh

424
00:15:59,839 --> 00:16:03,120
32-bit microcontroller called piccolo

425
00:16:03,120 --> 00:16:05,120
we've got flute which actually works

426
00:16:05,120 --> 00:16:07,839
64-bit or 32-bit which is more of a

427
00:16:07,839 --> 00:16:10,240
classic risk pipeline but still very

428
00:16:10,240 --> 00:16:12,560
much a scalar core and then we have

429
00:16:12,560 --> 00:16:15,120
tuber which is an out-of-all order core

430
00:16:15,120 --> 00:16:20,320
based on mit's risky oo call

431
00:16:20,320 --> 00:16:22,240
and that's quite interesting we've been

432
00:16:22,240 --> 00:16:25,120
using that at the moment to explore

433
00:16:25,120 --> 00:16:28,240
uh the sort of intersection of uh cherry

434
00:16:28,240 --> 00:16:30,160
features and

435
00:16:30,160 --> 00:16:33,759
uh mitigation of um transient execution

436
00:16:33,759 --> 00:16:37,839
attacks like spectrum meltdown

437
00:16:38,000 --> 00:16:39,519
we've also been doing a lot of work on

438
00:16:39,519 --> 00:16:41,120
sort of specification and test i

439
00:16:41,120 --> 00:16:43,199
mentioned that we've got a formal method

440
00:16:43,199 --> 00:16:44,800
angle to this

441
00:16:44,800 --> 00:16:46,880
i've been working with my colleague

442
00:16:46,880 --> 00:16:50,079
peter sewell and others in his group on

443
00:16:50,079 --> 00:16:52,480
a language called sale which can be used

444
00:16:52,480 --> 00:16:54,639
to describe um

445
00:16:54,639 --> 00:16:57,199
formal models of instruction sets and in

446
00:16:57,199 --> 00:16:59,199
fact the sale risk five model has now

447
00:16:59,199 --> 00:17:01,199
been ratified by

448
00:17:01,199 --> 00:17:03,920
um by risk five and is now the official

449
00:17:03,920 --> 00:17:06,000
formal specification

450
00:17:06,000 --> 00:17:08,559
there's also a cherry version that

451
00:17:08,559 --> 00:17:10,880
we've made publicly available

452
00:17:10,880 --> 00:17:12,079
um

453
00:17:12,079 --> 00:17:13,839
should you want to look at that

454
00:17:13,839 --> 00:17:15,760
and we've also been uh

455
00:17:15,760 --> 00:17:17,520
as hardware engineers have also got a

456
00:17:17,520 --> 00:17:21,119
system test rig that where we can

457
00:17:21,119 --> 00:17:23,919
run testing against this executable

458
00:17:23,919 --> 00:17:26,559
model and our implementations which is

459
00:17:26,559 --> 00:17:28,640
proven to be quite useful that's also

460
00:17:28,640 --> 00:17:31,280
open source

461
00:17:31,440 --> 00:17:33,440
lots of work on the tool chain and

462
00:17:33,440 --> 00:17:36,000
operating system support we now have

463
00:17:36,000 --> 00:17:38,240
really good compiler support

464
00:17:38,240 --> 00:17:40,640
we've got a really good operating system

465
00:17:40,640 --> 00:17:43,520
support so cherry on top of freebsd and

466
00:17:43,520 --> 00:17:46,400
free rtos

467
00:17:46,400 --> 00:17:48,640
we generally find we get you know little

468
00:17:48,640 --> 00:17:51,679
to no software modification required

469
00:17:51,679 --> 00:17:54,320
if you port all sorts of you know unix

470
00:17:54,320 --> 00:17:56,080
tools for instance you know everything

471
00:17:56,080 --> 00:17:56,960
from

472
00:17:56,960 --> 00:18:00,320
ls to grep and all sorts of things and

473
00:18:00,320 --> 00:18:02,160
but we've also been trying much larger

474
00:18:02,160 --> 00:18:04,160
applications as well

475
00:18:04,160 --> 00:18:05,679
and more recently

476
00:18:05,679 --> 00:18:07,760
um you know porting large systems

477
00:18:07,760 --> 00:18:09,120
libraries

478
00:18:09,120 --> 00:18:10,160
um

479
00:18:10,160 --> 00:18:13,200
you know tools like postgres sql

480
00:18:13,200 --> 00:18:14,720
x webkit

481
00:18:14,720 --> 00:18:18,240
and also you know gui based stuff so an

482
00:18:18,240 --> 00:18:20,880
x11 client and qt

483
00:18:20,880 --> 00:18:23,120
all with very strong

484
00:18:23,120 --> 00:18:24,480
cherry

485
00:18:24,480 --> 00:18:26,640
memory protection support

486
00:18:26,640 --> 00:18:28,640
and actually requiring very little work

487
00:18:28,640 --> 00:18:30,960
to port in fact most of the work often

488
00:18:30,960 --> 00:18:33,039
is just like finding and getting rid of

489
00:18:33,039 --> 00:18:34,240
the bugs

490
00:18:34,240 --> 00:18:37,760
that cherry throws up um

491
00:18:37,760 --> 00:18:39,679
let me just wrap up by talking about

492
00:18:39,679 --> 00:18:44,559
exploitation paths so we have a big

493
00:18:44,559 --> 00:18:47,600
chunk of funding from uk government

494
00:18:47,600 --> 00:18:49,280
so 70 million

495
00:18:49,280 --> 00:18:52,720
with further 170 million of

496
00:18:52,720 --> 00:18:54,720
industry matched funding

497
00:18:54,720 --> 00:18:56,240
to

498
00:18:56,240 --> 00:18:58,240
really push the cherry technology out of

499
00:18:58,240 --> 00:19:00,240
the door

500
00:19:00,240 --> 00:19:02,720
uh we've been working with arm on a

501
00:19:02,720 --> 00:19:05,200
system called morello which is a

502
00:19:05,200 --> 00:19:07,039
demonstrator platform

503
00:19:07,039 --> 00:19:09,280
and in fact they're expecting the chips

504
00:19:09,280 --> 00:19:11,520
back very soon from tsmc

505
00:19:11,520 --> 00:19:13,200
that's a cutting edge you know seven

506
00:19:13,200 --> 00:19:15,120
nanometer process

507
00:19:15,120 --> 00:19:16,000
uh

508
00:19:16,000 --> 00:19:18,400
based on their arm neo versus n1 cores

509
00:19:18,400 --> 00:19:20,559
it'll be a quad core system

510
00:19:20,559 --> 00:19:22,320
with a gpu and so on so it's quite a

511
00:19:22,320 --> 00:19:23,760
serious chip

512
00:19:23,760 --> 00:19:26,160
on board and those will be going out

513
00:19:26,160 --> 00:19:28,160
those evaluation chips and boards will

514
00:19:28,160 --> 00:19:30,720
be going out to industry and academic

515
00:19:30,720 --> 00:19:32,400
partners to

516
00:19:32,400 --> 00:19:36,720
evaluate the cherry technology on

517
00:19:36,880 --> 00:19:39,280
um and as i mentioned my colleague uh

518
00:19:39,280 --> 00:19:41,280
robert watson is giving an invited talk

519
00:19:41,280 --> 00:19:43,280
at chairs and he'll if you want to know

520
00:19:43,280 --> 00:19:46,160
more about almarello do go to that

521
00:19:46,160 --> 00:19:47,840
i'm very interested in the risk five

522
00:19:47,840 --> 00:19:49,280
side and

523
00:19:49,280 --> 00:19:50,400
uh one of the things that's been

524
00:19:50,400 --> 00:19:51,760
interesting with working with arm

525
00:19:51,760 --> 00:19:53,600
actually they've agreed that they will

526
00:19:53,600 --> 00:19:56,559
not patent anything in this space

527
00:19:56,559 --> 00:19:58,880
or if they do they will then relinquish

528
00:19:58,880 --> 00:20:01,200
the ip which is quite amazing

529
00:20:01,200 --> 00:20:03,760
um that's been part of the way we've

530
00:20:03,760 --> 00:20:05,440
worked all the way along

531
00:20:05,440 --> 00:20:08,080
so very very very keen on open source

532
00:20:08,080 --> 00:20:10,000
very keen on getting the ideas out there

533
00:20:10,000 --> 00:20:11,520
absolutely everywhere

534
00:20:11,520 --> 00:20:12,960
so you'll find that our calls are

535
00:20:12,960 --> 00:20:14,880
available um

536
00:20:14,880 --> 00:20:17,520
uh open source the documentation the

537
00:20:17,520 --> 00:20:20,559
formal specs the simulators compilers

538
00:20:20,559 --> 00:20:22,960
operating system stuff it's all out

539
00:20:22,960 --> 00:20:25,919
there we've made it all available

540
00:20:25,919 --> 00:20:27,919
right let me wrap up

541
00:20:27,919 --> 00:20:30,400
because we must be running out of time

542
00:20:30,400 --> 00:20:32,000
um so

543
00:20:32,000 --> 00:20:34,799
cherry provides hardware with

544
00:20:34,799 --> 00:20:36,320
it it sends that the hardware sort of

545
00:20:36,320 --> 00:20:38,080
ends up with more semantic knowledge of

546
00:20:38,080 --> 00:20:40,320
what the programmer intended and it

547
00:20:40,320 --> 00:20:43,360
really pushes us towards this idea of

548
00:20:43,360 --> 00:20:46,000
the principle of intentional use so the

549
00:20:46,000 --> 00:20:48,000
code is much more likely to run exactly

550
00:20:48,000 --> 00:20:50,000
as the programmer intended

551
00:20:50,000 --> 00:20:53,039
not the way the attacker tricked it

552
00:20:53,039 --> 00:20:54,640
we have this

553
00:20:54,640 --> 00:20:56,799
capabilities give us very efficient

554
00:20:56,799 --> 00:20:59,360
pointer integrity and bounds checking

555
00:20:59,360 --> 00:21:01,280
and that eliminates things like buffer

556
00:21:01,280 --> 00:21:04,240
overflows and buffer over read attacks

557
00:21:04,240 --> 00:21:06,080
you know finally i mean these are

558
00:21:06,080 --> 00:21:08,640
vulnerabilities been around a long time

559
00:21:08,640 --> 00:21:10,559
and

560
00:21:10,559 --> 00:21:13,120
you know we just have to get rid of them

561
00:21:13,120 --> 00:21:15,039
it gives us very deterministic

562
00:21:15,039 --> 00:21:17,440
protection there's no statistical

563
00:21:17,440 --> 00:21:19,840
techniques involved here

564
00:21:19,840 --> 00:21:21,919
we get proven scalable and efficient

565
00:21:21,919 --> 00:21:23,840
compartmentalization

566
00:21:23,840 --> 00:21:25,919
and this is really very powerful because

567
00:21:25,919 --> 00:21:28,000
you can then

568
00:21:28,000 --> 00:21:29,919
it's a mechanism that allows software to

569
00:21:29,919 --> 00:21:32,000
sort of exploit the principle of least

570
00:21:32,000 --> 00:21:33,440
privilege

571
00:21:33,440 --> 00:21:36,799
and we know that um if you can really

572
00:21:36,799 --> 00:21:39,200
you do fine grain compartmentalization

573
00:21:39,200 --> 00:21:41,600
you can mitigate both known and many

574
00:21:41,600 --> 00:21:42,840
unknown

575
00:21:42,840 --> 00:21:45,760
attacks and it gives us vast performance

576
00:21:45,760 --> 00:21:47,280
improvement over

577
00:21:47,280 --> 00:21:49,679
process-based compartmentalization

578
00:21:49,679 --> 00:21:51,520
that we currently see

579
00:21:51,520 --> 00:21:53,840
in things like the chromium browser but

580
00:21:53,840 --> 00:21:56,480
also in ios and so on

581
00:21:56,480 --> 00:21:58,080
and finally we're working with industry

582
00:21:58,080 --> 00:22:00,080
and the open source community to deploy

583
00:22:00,080 --> 00:22:01,440
the technology

584
00:22:01,440 --> 00:22:03,679
and it's great to be able to talk today

585
00:22:03,679 --> 00:22:05,919
uh to you all because we're

586
00:22:05,919 --> 00:22:08,240
really socially socializing the ideas

587
00:22:08,240 --> 00:22:11,039
with the risk five community and we're

588
00:22:11,039 --> 00:22:13,039
looking we'll be looking in the next

589
00:22:13,039 --> 00:22:14,640
year or so to

590
00:22:14,640 --> 00:22:17,200
ways that we can um

591
00:22:17,200 --> 00:22:19,520
get cherry standardised

592
00:22:19,520 --> 00:22:21,918
thank you

593
00:22:24,720 --> 00:22:26,880
great thanks a lot simon

594
00:22:26,880 --> 00:22:28,960
um we have a few minutes for questions

595
00:22:28,960 --> 00:22:31,760
if there are any

596
00:22:33,760 --> 00:22:35,520
so straight away in the chat so marcel

597
00:22:35,520 --> 00:22:37,360
asks would it be possible to create some

598
00:22:37,360 --> 00:22:39,919
crafted tag in a buffer overflow for a

599
00:22:39,919 --> 00:22:42,000
desired return address in hybrid mode

600
00:22:42,000 --> 00:22:44,720
what's the barrier stopping us

601
00:22:44,720 --> 00:22:46,960
yeah so there's no way you can access

602
00:22:46,960 --> 00:22:49,840
the tag memory directly

603
00:22:49,840 --> 00:22:51,039
from code

604
00:22:51,039 --> 00:22:53,840
and you can only

605
00:22:53,840 --> 00:22:55,919
basically generate a capability from

606
00:22:55,919 --> 00:22:57,919
another capability

607
00:22:57,919 --> 00:22:59,760
so the only way you can possibly set

608
00:22:59,760 --> 00:23:02,080
that validity tag is to start with a

609
00:23:02,080 --> 00:23:04,400
valid capability to begin with

610
00:23:04,400 --> 00:23:06,159
and the instruction set absolutely

611
00:23:06,159 --> 00:23:10,240
guarantees you can't break that model

612
00:23:13,679 --> 00:23:15,760
so i've got a quick question maybe i

613
00:23:15,760 --> 00:23:16,720
mean

614
00:23:16,720 --> 00:23:18,240
you mentioned me working on this for

615
00:23:18,240 --> 00:23:20,240
quite some time and you know the the

616
00:23:20,240 --> 00:23:22,480
concept and the a lot of the engineering

617
00:23:22,480 --> 00:23:24,799
is pretty mature so if someone's

618
00:23:24,799 --> 00:23:26,320
interested in working in this space

619
00:23:26,320 --> 00:23:28,080
maybe is there anything you haven't done

620
00:23:28,080 --> 00:23:30,320
seems like you've really uh touched

621
00:23:30,320 --> 00:23:32,320
every part of the stack basically

622
00:23:32,320 --> 00:23:34,320
are there any gaps that's a lot i mean

623
00:23:34,320 --> 00:23:36,320
there are things we're working on at

624
00:23:36,320 --> 00:23:38,320
present um

625
00:23:38,320 --> 00:23:39,120
so

626
00:23:39,120 --> 00:23:40,720
uh

627
00:23:40,720 --> 00:23:42,480
you know we've looked a little bit about

628
00:23:42,480 --> 00:23:44,559
trusted execution environment but it'd

629
00:23:44,559 --> 00:23:48,720
be great to do more in that space

630
00:23:49,039 --> 00:23:52,880
we've done some work uh exploring

631
00:23:52,880 --> 00:23:56,720
um how we can use cherry to

632
00:23:56,720 --> 00:24:00,559
mitigate uh transient execution attacks

633
00:24:00,559 --> 00:24:02,320
but in some sense we almost make that

634
00:24:02,320 --> 00:24:04,720
problem harder because

635
00:24:04,720 --> 00:24:06,880
because obviously we want um

636
00:24:06,880 --> 00:24:08,559
more compartments

637
00:24:08,559 --> 00:24:10,240
that's part of the sort of

638
00:24:10,240 --> 00:24:11,840
direction we're going

639
00:24:11,840 --> 00:24:13,520
uh to you know use the principle of

640
00:24:13,520 --> 00:24:14,799
least privilege but as soon as you've

641
00:24:14,799 --> 00:24:16,480
got more compartments you've got more

642
00:24:16,480 --> 00:24:19,039
protection domain transitions so if you

643
00:24:19,039 --> 00:24:20,640
like there's potentially more

644
00:24:20,640 --> 00:24:22,159
opportunities

645
00:24:22,159 --> 00:24:24,240
to leak information

646
00:24:24,240 --> 00:24:26,240
and so you know very efficient

647
00:24:26,240 --> 00:24:28,640
techniques

648
00:24:28,640 --> 00:24:29,919
to do

649
00:24:29,919 --> 00:24:32,880
to mitigate transient execution attacks

650
00:24:32,880 --> 00:24:35,520
they're going to be quite critical

651
00:24:35,520 --> 00:24:36,720
um

652
00:24:36,720 --> 00:24:38,880
so that's just some of the areas

653
00:24:38,880 --> 00:24:40,880
um but we also want to work with people

654
00:24:40,880 --> 00:24:42,279
on you know

655
00:24:42,279 --> 00:24:44,480
standardizing cherry

656
00:24:44,480 --> 00:24:47,120
and also there are there you know there

657
00:24:47,120 --> 00:24:48,720
are other things that people are doing

658
00:24:48,720 --> 00:24:50,799
that are orthogonal to cherry in the

659
00:24:50,799 --> 00:24:52,880
risk five space and we want to make sure

660
00:24:52,880 --> 00:24:53,760
that

661
00:24:53,760 --> 00:24:56,559
cherry composes well with those

662
00:24:56,559 --> 00:24:58,559
um and so one of the things we haven't

663
00:24:58,559 --> 00:25:00,720
yet looked at but we need to is simply

664
00:25:00,720 --> 00:25:03,520
the the new vector instructions we need

665
00:25:03,520 --> 00:25:05,600
to make sure that cherry works really

666
00:25:05,600 --> 00:25:07,600
well with those which we believe that

667
00:25:07,600 --> 00:25:08,880
they do but

668
00:25:08,880 --> 00:25:11,200
we really need to do all the uh

669
00:25:11,200 --> 00:25:12,880
you know the engineering work to ensure

670
00:25:12,880 --> 00:25:15,840
that really is the case

671
00:25:19,039 --> 00:25:21,200
so maybe one last question before we we

672
00:25:21,200 --> 00:25:24,559
call it a close from ravi who asks do we

673
00:25:24,559 --> 00:25:26,480
have estimates on the hardware or area

674
00:25:26,480 --> 00:25:28,480
cost to incorporate the cherry

675
00:25:28,480 --> 00:25:32,799
uh concept or capability into a call

676
00:25:32,799 --> 00:25:37,200
yeah it varies a lot actually um

677
00:25:37,200 --> 00:25:39,279
so

678
00:25:39,279 --> 00:25:42,000
it's probably most expensive on really

679
00:25:42,000 --> 00:25:44,080
small calls

680
00:25:44,080 --> 00:25:46,559
because apart from anything else we make

681
00:25:46,559 --> 00:25:50,880
the integer register file twice as wide

682
00:25:50,880 --> 00:25:52,799
and on a small call that's sort of

683
00:25:52,799 --> 00:25:55,440
noticeable

684
00:25:55,440 --> 00:25:57,840
once you start getting up to uh more the

685
00:25:57,840 --> 00:26:00,960
superscalar processor it's much less of

686
00:26:00,960 --> 00:26:04,000
an issue um

687
00:26:04,000 --> 00:26:06,640
but it's it it's a tricky one to answer

688
00:26:06,640 --> 00:26:08,240
because i think you really need to look

689
00:26:08,240 --> 00:26:12,240
at the overall system costs

690
00:26:12,240 --> 00:26:13,440
and the other thing that's even more

691
00:26:13,440 --> 00:26:15,919
confusing is you know people start

692
00:26:15,919 --> 00:26:17,120
adding

693
00:26:17,120 --> 00:26:20,640
other hardware mechanisms to

694
00:26:20,640 --> 00:26:23,279
improve security and once you've added

695
00:26:23,279 --> 00:26:25,600
cherry you may not need those mechanisms

696
00:26:25,600 --> 00:26:27,360
so there's also the question

697
00:26:27,360 --> 00:26:29,679
with both in hardware and in software so

698
00:26:29,679 --> 00:26:30,720
even something like you know

699
00:26:30,720 --> 00:26:33,279
address-based layout randomization that

700
00:26:33,279 --> 00:26:35,039
software tends to use comes with some

701
00:26:35,039 --> 00:26:37,520
cost it's really not clear that you need

702
00:26:37,520 --> 00:26:39,520
that once you have cherry

703
00:26:39,520 --> 00:26:41,760
um

704
00:26:41,760 --> 00:26:43,120
so i'm not going to give you a straight

705
00:26:43,120 --> 00:26:45,360
answer is i think it's the simple one uh

706
00:26:45,360 --> 00:26:47,840
i think for super scalar cause we look

707
00:26:47,840 --> 00:26:50,480
at the sort of overall system overhead

708
00:26:50,480 --> 00:26:52,640
below five percent

709
00:26:52,640 --> 00:26:54,720
but that's when you include caches and

710
00:26:54,720 --> 00:26:56,559
various other things

711
00:26:56,559 --> 00:26:59,039
uh you know if you've got a really tiny

712
00:26:59,039 --> 00:27:00,799
core you could

713
00:27:00,799 --> 00:27:03,760
easily be talking a 30 overhead

714
00:27:03,760 --> 00:27:05,600
but are you measuring the right thing at

715
00:27:05,600 --> 00:27:08,080
that point

716
00:27:09,520 --> 00:27:10,960
the other thing though on terms of

717
00:27:10,960 --> 00:27:13,120
overheads that's really critical

718
00:27:13,120 --> 00:27:16,080
is in terms of execution time

719
00:27:16,080 --> 00:27:19,440
it tends to have a very low overhead

720
00:27:19,440 --> 00:27:20,960
and in fact the

721
00:27:20,960 --> 00:27:23,120
the most overhead we see in terms of

722
00:27:23,120 --> 00:27:24,640
performance

723
00:27:24,640 --> 00:27:26,240
is that the

724
00:27:26,240 --> 00:27:28,399
because we have bigger pointers that

725
00:27:28,399 --> 00:27:30,799
does impact cash footprint

726
00:27:30,799 --> 00:27:34,240
so you get a some hit because of cash

727
00:27:34,240 --> 00:27:35,440
pressure

728
00:27:35,440 --> 00:27:36,799
um

729
00:27:36,799 --> 00:27:39,039
but i said typically performance

730
00:27:39,039 --> 00:27:41,520
overhead is well below five percent and

731
00:27:41,520 --> 00:27:43,520
often below one percent for many

732
00:27:43,520 --> 00:27:46,520
applications

733
00:27:49,679 --> 00:27:51,039
okay great so

734
00:27:51,039 --> 00:27:53,520
we're close to being bang on time so i'm

735
00:27:53,520 --> 00:27:55,520
tempted to say we draw a line there so

736
00:27:55,520 --> 00:27:57,760
sorry for any questions that i miss out

737
00:27:57,760 --> 00:27:59,440
but bear in mind there's this talk

738
00:27:59,440 --> 00:28:01,840
tomorrow by robert maybe we can call it

739
00:28:01,840 --> 00:28:03,279
a day there and say thanks i'm in for

740
00:28:03,279 --> 00:28:04,080
that

741
00:28:04,080 --> 00:28:06,000
yeah i think he's talking on thursday oh

742
00:28:06,000 --> 00:28:07,600
thursday sorry i think it was thursday

743
00:28:07,600 --> 00:28:10,240
yeah okay

744
00:28:10,240 --> 00:28:11,840
um

745
00:28:11,840 --> 00:28:14,320
yeah so

746
00:28:14,559 --> 00:28:16,159
yeah it's time to me to to say a few

747
00:28:16,159 --> 00:28:17,919
closing remarks i i don't have too many

748
00:28:17,919 --> 00:28:21,120
but for sure i want to say um some

749
00:28:21,120 --> 00:28:25,760
thanks and particularly to the speakers

