1
00:00:00,000 --> 00:00:02,240
talk

2
00:00:02,879 --> 00:00:04,480
um

3
00:00:04,480 --> 00:00:06,640
so our next speaker is

4
00:00:06,640 --> 00:00:08,320
barbara gigle

5
00:00:08,320 --> 00:00:10,320
uh barbara's currently a phd student in

6
00:00:10,320 --> 00:00:12,559
the secure systems group at graz

7
00:00:12,559 --> 00:00:14,559
university of technology and she's going

8
00:00:14,559 --> 00:00:16,560
to talk about coco which i guess is more

9
00:00:16,560 --> 00:00:18,560
like an approach or technique enabled by

10
00:00:18,560 --> 00:00:20,400
risk five rather than something kind of

11
00:00:20,400 --> 00:00:22,640
within risk five right

12
00:00:22,640 --> 00:00:26,039
over to you

13
00:00:33,120 --> 00:00:36,959
okay can you see my slides

14
00:00:37,120 --> 00:00:40,320
uh yes you'll just need to um we see all

15
00:00:40,320 --> 00:00:43,280
of them ah never mind that's good i will

16
00:00:43,280 --> 00:00:46,239
tell you that there is a small black bar

17
00:00:46,239 --> 00:00:48,640
in the upper right hand corner that is

18
00:00:48,640 --> 00:00:50,879
most likely the zoom controls

19
00:00:50,879 --> 00:00:52,800
if you can move those out of the way

20
00:00:52,800 --> 00:00:54,239
that would be fine but if you don't have

21
00:00:54,239 --> 00:00:56,480
any um

22
00:00:56,480 --> 00:00:59,280
any content up there then it'll be fine

23
00:00:59,280 --> 00:01:02,800
i think it's okay like that right okay

24
00:01:02,800 --> 00:01:03,760
good

25
00:01:03,760 --> 00:01:04,959
okay so

26
00:01:04,959 --> 00:01:08,479
welcome everyone um my name is barbara

27
00:01:08,479 --> 00:01:09,680
and today

28
00:01:09,680 --> 00:01:12,880
i will talk about coco which stands for

29
00:01:12,880 --> 00:01:15,200
co-design and co-verification

30
00:01:15,200 --> 00:01:18,880
of mask software on risk-file cpus

31
00:01:18,880 --> 00:01:21,600
this work was joint work by

32
00:01:21,600 --> 00:01:23,439
my colleagues and me from kratz

33
00:01:23,439 --> 00:01:24,840
university of

34
00:01:24,840 --> 00:01:28,240
technology so

35
00:01:28,240 --> 00:01:30,400
in physically side channel attacks the

36
00:01:30,400 --> 00:01:33,119
setting looks similar to this so we have

37
00:01:33,119 --> 00:01:34,560
one attacker

38
00:01:34,560 --> 00:01:36,079
who has physically access to a

39
00:01:36,079 --> 00:01:38,079
cryptographic device

40
00:01:38,079 --> 00:01:40,159
and for example the attacker can use an

41
00:01:40,159 --> 00:01:41,920
oscilloscope to

42
00:01:41,920 --> 00:01:42,799
um

43
00:01:42,799 --> 00:01:44,799
yeah to observe the power consumption of

44
00:01:44,799 --> 00:01:47,920
the device in our case this device is a

45
00:01:47,920 --> 00:01:49,200
cpu

46
00:01:49,200 --> 00:01:51,360
and in that case the power consumption

47
00:01:51,360 --> 00:01:54,240
will depend on two things first of all

48
00:01:54,240 --> 00:01:56,560
the instruction which is currently being

49
00:01:56,560 --> 00:01:58,560
executed and second

50
00:01:58,560 --> 00:02:00,240
the data which is involved in the

51
00:02:00,240 --> 00:02:02,640
instruction so the data which lies in

52
00:02:02,640 --> 00:02:06,479
the register file and the data memory

53
00:02:06,479 --> 00:02:09,119
to prevent such attacks we can apply the

54
00:02:09,119 --> 00:02:11,200
masking counter measure this which

55
00:02:11,200 --> 00:02:13,920
basically splits any intermediate value

56
00:02:13,920 --> 00:02:14,959
s

57
00:02:14,959 --> 00:02:17,840
into multiple random shears

58
00:02:17,840 --> 00:02:21,280
and um the attacker can now or has to

59
00:02:21,280 --> 00:02:22,640
now

60
00:02:22,640 --> 00:02:24,959
observe or shares

61
00:02:24,959 --> 00:02:26,959
to be able to deduce some information

62
00:02:26,959 --> 00:02:29,120
about the native value

63
00:02:29,120 --> 00:02:32,319
and as you can imagine constructing such

64
00:02:32,319 --> 00:02:35,280
masked implementations is not an easy

65
00:02:35,280 --> 00:02:37,599
task and therefore we want to have

66
00:02:37,599 --> 00:02:39,920
verification tools which help us by

67
00:02:39,920 --> 00:02:41,120
doing so

68
00:02:41,120 --> 00:02:43,360
and such tools can

69
00:02:43,360 --> 00:02:46,239
more concretely check the separation of

70
00:02:46,239 --> 00:02:48,000
our shares

71
00:02:48,000 --> 00:02:50,959
when a certain mask program or

72
00:02:50,959 --> 00:02:53,040
a certain piece of musk hardware is

73
00:02:53,040 --> 00:02:55,680
computing something

74
00:02:55,680 --> 00:02:58,159
okay so

75
00:02:58,159 --> 00:02:59,040
those

76
00:02:59,040 --> 00:03:00,319
masked

77
00:03:00,319 --> 00:03:02,239
verification tools

78
00:03:02,239 --> 00:03:04,959
so far exist either for masked hardware

79
00:03:04,959 --> 00:03:06,319
circuits

80
00:03:06,319 --> 00:03:08,319
for example here we have rebecca and

81
00:03:08,319 --> 00:03:11,599
mask for reef as one of the first tools

82
00:03:11,599 --> 00:03:12,720
and

83
00:03:12,720 --> 00:03:16,000
basically these tools check

84
00:03:16,000 --> 00:03:17,200
for a given

85
00:03:17,200 --> 00:03:18,640
mask circuit

86
00:03:18,640 --> 00:03:20,640
whether there exists the gates which

87
00:03:20,640 --> 00:03:23,760
combines two shares and these checks are

88
00:03:23,760 --> 00:03:25,599
done in the so-called classical probing

89
00:03:25,599 --> 00:03:26,560
model

90
00:03:26,560 --> 00:03:28,640
which defines the abilities as an

91
00:03:28,640 --> 00:03:29,840
attacker

92
00:03:29,840 --> 00:03:31,519
in the classical probing model the

93
00:03:31,519 --> 00:03:32,879
attacker has

94
00:03:32,879 --> 00:03:35,680
d probes and these probes can be

95
00:03:35,680 --> 00:03:37,599
distributed

96
00:03:37,599 --> 00:03:38,640
onto the

97
00:03:38,640 --> 00:03:39,599
gates

98
00:03:39,599 --> 00:03:41,360
and then the probes will deliver

99
00:03:41,360 --> 00:03:43,599
basically the value

100
00:03:43,599 --> 00:03:45,519
which are computed by these gates to

101
00:03:45,519 --> 00:03:47,200
their attacker

102
00:03:47,200 --> 00:03:49,200
and most importantly this includes

103
00:03:49,200 --> 00:03:51,760
glitches and transitions which might be

104
00:03:51,760 --> 00:03:53,280
visible on

105
00:03:53,280 --> 00:03:56,720
on a certain wire which is being probed

106
00:03:56,720 --> 00:03:59,280
the second class of verification tools

107
00:03:59,280 --> 00:04:02,159
are constructed for verifying mask

108
00:04:02,159 --> 00:04:03,360
software

109
00:04:03,360 --> 00:04:06,560
in the so-called software probing model

110
00:04:06,560 --> 00:04:08,400
and these checks are rather on

111
00:04:08,400 --> 00:04:10,239
algorithmic level

112
00:04:10,239 --> 00:04:13,840
and hardly consider the hardware or cpu

113
00:04:13,840 --> 00:04:15,599
which is in the end

114
00:04:15,599 --> 00:04:18,478
used to execute the software

115
00:04:18,478 --> 00:04:20,560
and the assumption is basically that the

116
00:04:20,560 --> 00:04:23,040
hardware is secure so our processor does

117
00:04:23,040 --> 00:04:26,880
not introduce additional security

118
00:04:26,880 --> 00:04:28,800
threads to the software

119
00:04:28,800 --> 00:04:31,120
unfortunately this is often not the case

120
00:04:31,120 --> 00:04:32,560
because

121
00:04:32,560 --> 00:04:36,240
as it is with every hardware

122
00:04:36,320 --> 00:04:38,400
there can be glitches and transitions in

123
00:04:38,400 --> 00:04:39,600
the circuit

124
00:04:39,600 --> 00:04:42,320
therefore what we want to have is a tool

125
00:04:42,320 --> 00:04:45,199
which can verify a certain piece of mask

126
00:04:45,199 --> 00:04:47,840
software when we execute it with a

127
00:04:47,840 --> 00:04:50,240
certain concrete cpu

128
00:04:50,240 --> 00:04:52,160
and the cpu is

129
00:04:52,160 --> 00:04:54,800
best represented by a netlist so after

130
00:04:54,800 --> 00:04:57,199
the synthesis and everything

131
00:04:57,199 --> 00:05:00,000
uh yeah and with cocoa we have such a

132
00:05:00,000 --> 00:05:01,759
tool

133
00:05:01,759 --> 00:05:04,960
now let's look at one specific example

134
00:05:04,960 --> 00:05:07,919
which we have in almost every processor

135
00:05:07,919 --> 00:05:10,880
we have a register file and the register

136
00:05:10,880 --> 00:05:12,560
file can be

137
00:05:12,560 --> 00:05:13,440
um

138
00:05:13,440 --> 00:05:16,400
yeah a thread to your mask software so

139
00:05:16,400 --> 00:05:20,160
this is a good example of hardware which

140
00:05:20,160 --> 00:05:22,320
yeah which might reduce the security

141
00:05:22,320 --> 00:05:25,520
level of your mask software

142
00:05:25,520 --> 00:05:27,759
in this example we have four registers

143
00:05:27,759 --> 00:05:30,560
here and here we have a multiplexer tree

144
00:05:30,560 --> 00:05:31,919
which is used

145
00:05:31,919 --> 00:05:32,960
to

146
00:05:32,960 --> 00:05:34,000
address

147
00:05:34,000 --> 00:05:35,520
the registers

148
00:05:35,520 --> 00:05:38,000
and here in the gray box you see the

149
00:05:38,000 --> 00:05:39,919
software we want to execute so we want

150
00:05:39,919 --> 00:05:42,560
to store x2 and then x1

151
00:05:42,560 --> 00:05:45,440
additionally we know that we have a

152
00:05:45,440 --> 00:05:48,720
program which has two shares s1 and s2

153
00:05:48,720 --> 00:05:51,440
and the shares are in registers x1 and

154
00:05:51,440 --> 00:05:53,199
x2

155
00:05:53,199 --> 00:05:55,360
okay so in the first cycle

156
00:05:55,360 --> 00:05:58,240
we want to store x2 which means

157
00:05:58,240 --> 00:06:00,960
we have to read x2 from the register

158
00:06:00,960 --> 00:06:01,840
file

159
00:06:01,840 --> 00:06:03,680
the multiplexes here

160
00:06:03,680 --> 00:06:05,680
get their respective value

161
00:06:05,680 --> 00:06:09,199
and the value of s2 will kind of

162
00:06:09,199 --> 00:06:11,199
propagate through the circuit until we

163
00:06:11,199 --> 00:06:13,680
see the date at the report

164
00:06:13,680 --> 00:06:15,520
in the next cycle

165
00:06:15,520 --> 00:06:18,400
we want to store x1 which means we have

166
00:06:18,400 --> 00:06:22,160
to read x1 from the register file

167
00:06:22,160 --> 00:06:24,479
and what happens now is that this

168
00:06:24,479 --> 00:06:26,639
multiplexer here switches

169
00:06:26,639 --> 00:06:29,199
the select signal from 0 to 1 which

170
00:06:29,199 --> 00:06:31,680
leads to the output of the multiplexer

171
00:06:31,680 --> 00:06:32,840
switching

172
00:06:32,840 --> 00:06:36,080
from the previous value to the new and

173
00:06:36,080 --> 00:06:38,240
we have a transition from one share to

174
00:06:38,240 --> 00:06:41,520
another which means we have a leak

175
00:06:41,520 --> 00:06:43,680
in our program

176
00:06:43,680 --> 00:06:44,880
this is

177
00:06:44,880 --> 00:06:46,479
you might argue that this is a rather

178
00:06:46,479 --> 00:06:48,400
obvious case because

179
00:06:48,400 --> 00:06:51,120
you're kind of accessing your shares in

180
00:06:51,120 --> 00:06:53,680
two consecutive cycles but

181
00:06:53,680 --> 00:06:55,919
there are cases in which it's not that

182
00:06:55,919 --> 00:06:57,919
obvious for example here we want to

183
00:06:57,919 --> 00:07:00,319
store x3 and then x4

184
00:07:00,319 --> 00:07:04,080
when we read in the first cycle x3

185
00:07:04,080 --> 00:07:06,639
this multiplexer again has the value 1

186
00:07:06,639 --> 00:07:09,199
but this one kind of selects that the

187
00:07:09,199 --> 00:07:11,120
data from the lower part of the register

188
00:07:11,120 --> 00:07:13,680
file should be read in the end

189
00:07:13,680 --> 00:07:16,639
and in the second cycle we want to read

190
00:07:16,639 --> 00:07:18,240
x4

191
00:07:18,240 --> 00:07:20,639
and again this multiplexer switches from

192
00:07:20,639 --> 00:07:22,080
one to zero

193
00:07:22,080 --> 00:07:24,400
which is why we have a transition now

194
00:07:24,400 --> 00:07:26,639
from the first chair to the second on

195
00:07:26,639 --> 00:07:27,919
this wire

196
00:07:27,919 --> 00:07:29,919
and this means we have a leak in our

197
00:07:29,919 --> 00:07:32,720
program even though we do not touch any

198
00:07:32,720 --> 00:07:34,160
of the shares

199
00:07:34,160 --> 00:07:36,720
and such situations are

200
00:07:36,720 --> 00:07:39,199
very hard to find without a proper

201
00:07:39,199 --> 00:07:41,360
verification pool

202
00:07:41,360 --> 00:07:43,360
so

203
00:07:43,360 --> 00:07:47,120
this is why we yeah constructed coco

204
00:07:47,120 --> 00:07:49,919
which basically takes a piece of mask

205
00:07:49,919 --> 00:07:53,680
software written in risk file assembly

206
00:07:53,680 --> 00:07:54,879
and

207
00:07:54,879 --> 00:07:57,120
the hardware which is used to execute

208
00:07:57,120 --> 00:07:59,120
the software in our case this was the

209
00:07:59,120 --> 00:08:02,240
risc-5 ebx core

210
00:08:02,240 --> 00:08:04,879
yeah and coco can then verify or prove

211
00:08:04,879 --> 00:08:07,599
that the software as executed with the

212
00:08:07,599 --> 00:08:10,479
e-bike score is secure

213
00:08:10,479 --> 00:08:12,639
or does not introduce any leaks in the

214
00:08:12,639 --> 00:08:15,599
context of masking

215
00:08:15,599 --> 00:08:17,840
we cannot adapt the classical probing

216
00:08:17,840 --> 00:08:19,680
model which we already saw for hardware

217
00:08:19,680 --> 00:08:22,240
here but we have to kind of make some

218
00:08:22,240 --> 00:08:24,720
constraints to this classical probing

219
00:08:24,720 --> 00:08:26,960
model because in the classical probing

220
00:08:26,960 --> 00:08:29,759
model the attacker can kind of observe a

221
00:08:29,759 --> 00:08:32,559
wire for an infinite amount of time and

222
00:08:32,559 --> 00:08:34,000
if we do that

223
00:08:34,000 --> 00:08:36,399
in a cpu the attacker can simply choose

224
00:08:36,399 --> 00:08:38,880
the register file output and observe it

225
00:08:38,880 --> 00:08:41,440
for an infinite amount of time so for

226
00:08:41,440 --> 00:08:42,880
all the cycles

227
00:08:42,880 --> 00:08:45,600
the program will last and then our

228
00:08:45,600 --> 00:08:48,720
scheme is immediately broken so we

229
00:08:48,720 --> 00:08:51,920
constrain the classical probing model by

230
00:08:51,920 --> 00:08:54,240
the notion of time what does this mean

231
00:08:54,240 --> 00:08:57,120
now the attack has again deep ropes

232
00:08:57,120 --> 00:08:58,240
and can

233
00:08:58,240 --> 00:08:59,760
use one probe

234
00:08:59,760 --> 00:09:02,399
to measure information

235
00:09:02,399 --> 00:09:05,279
at one specific location but also in one

236
00:09:05,279 --> 00:09:07,680
specific clock cycle so this means the

237
00:09:07,680 --> 00:09:10,000
probes can be distributed

238
00:09:10,000 --> 00:09:12,240
to be either at the same location in

239
00:09:12,240 --> 00:09:14,480
different clock cycles or at different

240
00:09:14,480 --> 00:09:16,880
locations in the same clock cycle or a

241
00:09:16,880 --> 00:09:19,600
mix of both

242
00:09:19,760 --> 00:09:21,680
let's have a look at the co-verification

243
00:09:21,680 --> 00:09:24,800
flow of coco so here we have again our

244
00:09:24,800 --> 00:09:26,640
software and the hardware and the first

245
00:09:26,640 --> 00:09:28,800
step is to simulate the software

246
00:09:28,800 --> 00:09:31,040
execution with the hardware

247
00:09:31,040 --> 00:09:32,800
there we get out

248
00:09:32,800 --> 00:09:35,120
a dump of control signals

249
00:09:35,120 --> 00:09:37,440
which kind of maps the software to the

250
00:09:37,440 --> 00:09:40,800
hardware in terms of control signals

251
00:09:40,800 --> 00:09:44,320
next we perform an annotation

252
00:09:44,320 --> 00:09:47,200
which means that we tell the verifier

253
00:09:47,200 --> 00:09:49,440
where the shares and randomness is

254
00:09:49,440 --> 00:09:50,560
located

255
00:09:50,560 --> 00:09:53,839
so in which registers is

256
00:09:53,839 --> 00:09:56,320
the first year for example and this is

257
00:09:56,320 --> 00:09:58,480
done on bit level of course we cannot

258
00:09:58,480 --> 00:10:00,880
only annotate registers but also memory

259
00:10:00,880 --> 00:10:02,320
locations

260
00:10:02,320 --> 00:10:04,399
and these two things are then given to

261
00:10:04,399 --> 00:10:06,959
the verifier the verifier will run the

262
00:10:06,959 --> 00:10:10,240
verification for a few cycles

263
00:10:10,240 --> 00:10:12,480
and then output yes the execution is

264
00:10:12,480 --> 00:10:13,600
secure

265
00:10:13,600 --> 00:10:16,800
or no it's not secure and there's a leak

266
00:10:16,800 --> 00:10:20,880
in cycle 8 at a specific gate

267
00:10:20,880 --> 00:10:22,160
ok

268
00:10:22,160 --> 00:10:24,079
so

269
00:10:24,079 --> 00:10:26,640
the co-verification methodology itself

270
00:10:26,640 --> 00:10:29,600
was inspired by rebecca which is

271
00:10:29,600 --> 00:10:30,959
a pure

272
00:10:30,959 --> 00:10:33,040
hardware verification tool

273
00:10:33,040 --> 00:10:35,360
and we extended it such that we can

274
00:10:35,360 --> 00:10:37,839
execute mask software

275
00:10:37,839 --> 00:10:41,440
on a concrete cpu netlist so on on a

276
00:10:41,440 --> 00:10:42,800
hardware

277
00:10:42,800 --> 00:10:44,240
and

278
00:10:44,240 --> 00:10:47,360
it works roughly like that we have the

279
00:10:47,360 --> 00:10:49,440
labels which we saw earlier in the

280
00:10:49,440 --> 00:10:51,040
annotation step

281
00:10:51,040 --> 00:10:52,880
and we propagate these labels through

282
00:10:52,880 --> 00:10:55,440
the whole cpu netlist

283
00:10:55,440 --> 00:10:56,880
and um

284
00:10:56,880 --> 00:10:59,279
for each gate in the sibu netlist we

285
00:10:59,279 --> 00:11:03,600
then compute the so called correlation

286
00:11:03,600 --> 00:11:05,839
the correlation will tell us if there is

287
00:11:05,839 --> 00:11:08,320
a correlation to a native value which we

288
00:11:08,320 --> 00:11:09,760
don't want to have

289
00:11:09,760 --> 00:11:13,120
and can either be saber or transient

290
00:11:13,120 --> 00:11:15,040
transient means that glitches and

291
00:11:15,040 --> 00:11:16,640
transitions

292
00:11:16,640 --> 00:11:19,519
will be taken into account

293
00:11:19,519 --> 00:11:21,920
let's have a look at the short example

294
00:11:21,920 --> 00:11:25,279
so here you see a circuit

295
00:11:25,279 --> 00:11:29,200
which consists of a wire a which comes

296
00:11:29,200 --> 00:11:32,320
out of combinatorial logic and a wire b

297
00:11:32,320 --> 00:11:35,360
which comes out directly of a register

298
00:11:35,360 --> 00:11:39,040
and both inputs then go into an and gate

299
00:11:39,040 --> 00:11:42,399
and in this case the value b will would

300
00:11:42,399 --> 00:11:45,040
be our control signal

301
00:11:45,040 --> 00:11:46,640
and um

302
00:11:46,640 --> 00:11:49,440
here you can see the dump of contour

303
00:11:49,440 --> 00:11:52,000
signals for three cycles n n plus one

304
00:11:52,000 --> 00:11:54,560
and n plus two and you see that b

305
00:11:54,560 --> 00:11:57,279
first is one and then switches to zero

306
00:11:57,279 --> 00:11:59,760
so the output of x will basically first

307
00:11:59,760 --> 00:12:02,320
be a and then zero

308
00:12:02,320 --> 00:12:04,000
when we now want to compute the

309
00:12:04,000 --> 00:12:06,160
correlation of x

310
00:12:06,160 --> 00:12:08,480
we would for first of all focus on the

311
00:12:08,480 --> 00:12:11,120
stable correlation set so in the first

312
00:12:11,120 --> 00:12:15,040
cycle since x displays the value of a

313
00:12:15,040 --> 00:12:17,440
x will correlate to a

314
00:12:17,440 --> 00:12:18,800
but then

315
00:12:18,800 --> 00:12:21,760
since x switches to zero it then

316
00:12:21,760 --> 00:12:24,560
correlates to zero or a constant

317
00:12:24,560 --> 00:12:27,200
the verification tool does not

318
00:12:27,200 --> 00:12:29,600
make any difference between constants or

319
00:12:29,600 --> 00:12:31,839
or the zeros that you see here

320
00:12:31,839 --> 00:12:33,680
then

321
00:12:33,680 --> 00:12:35,440
for the case of the transient

322
00:12:35,440 --> 00:12:36,880
correlation

323
00:12:36,880 --> 00:12:40,480
we also have the same in the first cycle

324
00:12:40,480 --> 00:12:43,360
but in the second cycle we have to add a

325
00:12:43,360 --> 00:12:46,399
to the correlation set

326
00:12:46,399 --> 00:12:48,959
why is that the case because b switches

327
00:12:48,959 --> 00:12:50,880
from one to zero

328
00:12:50,880 --> 00:12:53,200
so for a short amount of time

329
00:12:53,200 --> 00:12:54,079
in

330
00:12:54,079 --> 00:12:55,680
the first

331
00:12:55,680 --> 00:12:57,440
yeah in the first

332
00:12:57,440 --> 00:12:59,920
time frame of the cycle m plus 1 we will

333
00:12:59,920 --> 00:13:02,959
still see the old value of the wire a

334
00:13:02,959 --> 00:13:06,079
until the 0 from register b will

335
00:13:06,079 --> 00:13:08,880
propagate to the end gate

336
00:13:08,880 --> 00:13:11,279
and in the next cycle we can safely

337
00:13:11,279 --> 00:13:13,680
assume that x does not correlate to a

338
00:13:13,680 --> 00:13:15,360
anymore because

339
00:13:15,360 --> 00:13:20,560
b has been stable 0 for two cycles now

340
00:13:20,560 --> 00:13:23,600
yeah and this is a quite

341
00:13:23,600 --> 00:13:26,320
nice concept which we also applied to

342
00:13:26,320 --> 00:13:28,639
the register file so to construct the

343
00:13:28,639 --> 00:13:30,959
secure register file which you see

344
00:13:30,959 --> 00:13:33,600
here so we placed an

345
00:13:33,600 --> 00:13:36,720
gate before each register

346
00:13:36,720 --> 00:13:40,480
and this gate determines if we

347
00:13:40,480 --> 00:13:43,600
we will see the the register value at

348
00:13:43,600 --> 00:13:45,519
the gate output

349
00:13:45,519 --> 00:13:48,959
and as a gate value we use the one hot

350
00:13:48,959 --> 00:13:52,560
encoded register address

351
00:13:52,560 --> 00:13:55,279
so in this register here

352
00:13:55,279 --> 00:13:58,800
at most one bit will be one

353
00:13:58,800 --> 00:14:02,160
and this refers to kind of the gate is

354
00:14:02,160 --> 00:14:06,560
open and we want to read the register

355
00:14:06,560 --> 00:14:09,120
if we now consider the example where we

356
00:14:09,120 --> 00:14:11,920
want to store x2 and then x3

357
00:14:11,920 --> 00:14:14,160
we see that in the first cycle

358
00:14:14,160 --> 00:14:17,920
x2 the gate of x2 will be open and

359
00:14:17,920 --> 00:14:21,120
therefore the data can kind of

360
00:14:21,120 --> 00:14:23,040
be seen at the read part

361
00:14:23,040 --> 00:14:25,279
and in the next cycle

362
00:14:25,279 --> 00:14:26,720
we will have

363
00:14:26,720 --> 00:14:30,959
the data of x3 here at the read port so

364
00:14:30,959 --> 00:14:33,040
at most we can see at the read point at

365
00:14:33,040 --> 00:14:36,399
the value of two registers

366
00:14:36,399 --> 00:14:37,279
yeah

367
00:14:37,279 --> 00:14:39,600
and

368
00:14:39,600 --> 00:14:42,399
now let's come to the second part of

369
00:14:42,399 --> 00:14:44,880
coco which is called the co-design we

370
00:14:44,880 --> 00:14:47,199
conducted the case study with the risc-5

371
00:14:47,199 --> 00:14:49,120
e-bikes core

372
00:14:49,120 --> 00:14:51,360
and the e-bike score is a rather small

373
00:14:51,360 --> 00:14:54,160
core a 32-bit core with

374
00:14:54,160 --> 00:14:55,839
which is in order

375
00:14:55,839 --> 00:14:58,800
and has a two-stage pipeline

376
00:14:58,800 --> 00:15:01,600
and uh yeah it's applied rather to small

377
00:15:01,600 --> 00:15:04,720
iot devices and smaller use cases

378
00:15:04,720 --> 00:15:08,000
and then we tried to harden the ebex

379
00:15:08,000 --> 00:15:10,240
core with cocoa against side channel

380
00:15:10,240 --> 00:15:12,720
attacks so what we did was we

381
00:15:12,720 --> 00:15:14,480
constructed a

382
00:15:14,480 --> 00:15:17,199
set of mask software implementations and

383
00:15:17,199 --> 00:15:19,360
then tried to verify

384
00:15:19,360 --> 00:15:22,480
that software implementations with cocoa

385
00:15:22,480 --> 00:15:24,480
and

386
00:15:24,480 --> 00:15:28,639
yeah coco reported a whole list of leaks

387
00:15:28,639 --> 00:15:29,680
um

388
00:15:29,680 --> 00:15:30,480
and

389
00:15:30,480 --> 00:15:32,480
in yeah this leaks were in various parts

390
00:15:32,480 --> 00:15:36,560
of the cpu and we had two strategies to

391
00:15:36,560 --> 00:15:39,040
remove these leaks first of all

392
00:15:39,040 --> 00:15:41,120
sometimes we decided to

393
00:15:41,120 --> 00:15:44,480
do changes in the cpu

394
00:15:44,480 --> 00:15:47,440
or in the hardware itself so

395
00:15:47,440 --> 00:15:48,399
this

396
00:15:48,399 --> 00:15:49,199
would

397
00:15:49,199 --> 00:15:51,360
for example be the same as we did in the

398
00:15:51,360 --> 00:15:52,399
register

399
00:15:52,399 --> 00:15:54,480
we introduced the skating mechanism to

400
00:15:54,480 --> 00:15:57,440
have to enable secure register

401
00:15:57,440 --> 00:15:58,560
reads

402
00:15:58,560 --> 00:16:01,279
but sometimes um changes in the hardware

403
00:16:01,279 --> 00:16:03,839
are too costly and we rather want to

404
00:16:03,839 --> 00:16:05,759
adapt the software

405
00:16:05,759 --> 00:16:07,920
and this is what we call the software

406
00:16:07,920 --> 00:16:10,160
constraints the software constraints are

407
00:16:10,160 --> 00:16:13,279
basically a set of rules

408
00:16:13,279 --> 00:16:15,600
and if these rules are followed by the

409
00:16:15,600 --> 00:16:18,240
programmer of the mask software

410
00:16:18,240 --> 00:16:20,560
this already helps to prevent some known

411
00:16:20,560 --> 00:16:23,839
leakages and of course if the the

412
00:16:23,839 --> 00:16:25,920
software does not

413
00:16:25,920 --> 00:16:28,480
meet this software constraints coco will

414
00:16:28,480 --> 00:16:29,759
report it

415
00:16:29,759 --> 00:16:32,160
by pointing out that there is a leak in

416
00:16:32,160 --> 00:16:34,839
a certain cycle at a certain

417
00:16:34,839 --> 00:16:37,680
gate okay let's have a look at an

418
00:16:37,680 --> 00:16:40,079
example of how a software constraint

419
00:16:40,079 --> 00:16:42,720
could look like so here we have our

420
00:16:42,720 --> 00:16:45,440
hardened register file again

421
00:16:45,440 --> 00:16:48,000
with two shares in the registers

422
00:16:48,000 --> 00:16:50,800
and now we want to first store x2 which

423
00:16:50,800 --> 00:16:52,959
means we see the value of the second

424
00:16:52,959 --> 00:16:55,120
chair at the read port a and then we

425
00:16:55,120 --> 00:16:56,959
want to store x1

426
00:16:56,959 --> 00:17:00,639
which means we create a transition here

427
00:17:00,639 --> 00:17:02,959
and the software constraint to prevent

428
00:17:02,959 --> 00:17:04,559
such kinds of

429
00:17:04,559 --> 00:17:07,039
of of leakages would be the chairs of

430
00:17:07,039 --> 00:17:09,439
the same secret must not be accessed

431
00:17:09,439 --> 00:17:12,079
within two successive cons instructions

432
00:17:12,079 --> 00:17:14,959
so between the two store um instructions

433
00:17:14,959 --> 00:17:16,799
there should be another unrelated

434
00:17:16,799 --> 00:17:19,520
instruction for example a knob

435
00:17:19,520 --> 00:17:22,240
which prevents this transition at the

436
00:17:22,240 --> 00:17:25,280
read pod a of the register file

437
00:17:25,280 --> 00:17:28,160
okay then we also found some further

438
00:17:28,160 --> 00:17:31,039
problems in the

439
00:17:31,039 --> 00:17:32,559
in the core

440
00:17:32,559 --> 00:17:33,600
um

441
00:17:33,600 --> 00:17:35,840
first of all we found out that there is

442
00:17:35,840 --> 00:17:37,760
a hidden state in the load store unit

443
00:17:37,760 --> 00:17:40,320
which is basically a register

444
00:17:40,320 --> 00:17:42,640
and every time you store something to

445
00:17:42,640 --> 00:17:44,400
memory this register

446
00:17:44,400 --> 00:17:46,640
gets the value of whatever you want to

447
00:17:46,640 --> 00:17:49,280
store so this could be a bad if you

448
00:17:49,280 --> 00:17:51,679
store two shares because then you have a

449
00:17:51,679 --> 00:17:53,600
register override

450
00:17:53,600 --> 00:17:56,640
um another thing where the computation

451
00:17:56,640 --> 00:17:59,200
units so the alu the multiplier and the

452
00:17:59,200 --> 00:18:01,120
csr unit because they were always

453
00:18:01,120 --> 00:18:03,520
computing so if we

454
00:18:03,520 --> 00:18:04,559
kind of

455
00:18:04,559 --> 00:18:07,120
for example execute a load instruction

456
00:18:07,120 --> 00:18:10,640
still the alu would compute

457
00:18:10,640 --> 00:18:12,080
the xor

458
00:18:12,080 --> 00:18:15,039
without being needed and

459
00:18:15,039 --> 00:18:16,960
this specifically

460
00:18:16,960 --> 00:18:19,280
creates leaks when you want to use

461
00:18:19,280 --> 00:18:21,760
parallel masking schemes

462
00:18:21,760 --> 00:18:26,240
so in in these parallel masking schemes

463
00:18:26,240 --> 00:18:29,039
you do not place all the bits of one

464
00:18:29,039 --> 00:18:32,000
share in one register but distribute

465
00:18:32,000 --> 00:18:34,799
order n bits of one share to end

466
00:18:34,799 --> 00:18:36,640
different registers

467
00:18:36,640 --> 00:18:37,600
and then

468
00:18:37,600 --> 00:18:39,919
this means that one register will then

469
00:18:39,919 --> 00:18:41,360
store

470
00:18:41,360 --> 00:18:44,080
the different shares of the same secret

471
00:18:44,080 --> 00:18:47,200
and in the case of for example the csr

472
00:18:47,200 --> 00:18:49,919
unit or also the multiplier

473
00:18:49,919 --> 00:18:52,160
some parts of that combine the bits of

474
00:18:52,160 --> 00:18:55,280
one register and this creates a leaks

475
00:18:55,280 --> 00:18:59,919
because your bits are two shears

476
00:18:59,919 --> 00:19:02,320
and one point is also the communication

477
00:19:02,320 --> 00:19:05,440
with the data memory so um there are

478
00:19:05,440 --> 00:19:06,720
strategies

479
00:19:06,720 --> 00:19:08,880
you you can follow to have

480
00:19:08,880 --> 00:19:14,000
secure loads and stores from into memory

481
00:19:14,000 --> 00:19:16,559
but i won't go into detail about that

482
00:19:16,559 --> 00:19:18,799
right now if you're interested you can

483
00:19:18,799 --> 00:19:22,080
simply have a look at our paper

484
00:19:22,080 --> 00:19:23,120
okay

485
00:19:23,120 --> 00:19:25,360
now let's have a short look at our

486
00:19:25,360 --> 00:19:27,360
evaluation so

487
00:19:27,360 --> 00:19:29,840
the total overhead of the

488
00:19:29,840 --> 00:19:32,400
um yeah of the security measurements we

489
00:19:32,400 --> 00:19:35,520
built into e-bikes is about 10

490
00:19:35,520 --> 00:19:38,640
so we compared here the basic design

491
00:19:38,640 --> 00:19:41,200
without any security feature to the

492
00:19:41,200 --> 00:19:43,679
design which has or security features

493
00:19:43,679 --> 00:19:45,200
enabled

494
00:19:45,200 --> 00:19:48,559
and we also tried to um

495
00:19:48,559 --> 00:19:50,160
yeah to to

496
00:19:50,160 --> 00:19:53,039
do some small benchmarks so to benchmark

497
00:19:53,039 --> 00:19:54,799
our tour

498
00:19:54,799 --> 00:19:57,760
um for example here we tried some simple

499
00:19:57,760 --> 00:19:59,919
end gates but also

500
00:19:59,919 --> 00:20:02,159
some broken implementations

501
00:20:02,159 --> 00:20:04,000
broken means that the software

502
00:20:04,000 --> 00:20:07,440
constraints which i showed you before

503
00:20:07,440 --> 00:20:09,840
were not met by the software

504
00:20:09,840 --> 00:20:11,120
and

505
00:20:11,120 --> 00:20:12,000
yeah

506
00:20:12,000 --> 00:20:14,480
coco in this case pointed out that the

507
00:20:14,480 --> 00:20:17,360
12th cycle is the problem

508
00:20:17,360 --> 00:20:20,000
we also had some bigger test cases like

509
00:20:20,000 --> 00:20:22,080
the ass box

510
00:20:22,080 --> 00:20:24,640
and also some higher order tests like a

511
00:20:24,640 --> 00:20:27,440
ketchup s box and a third order dom and

512
00:20:27,440 --> 00:20:29,520
gate

513
00:20:29,520 --> 00:20:30,480
yeah

514
00:20:30,480 --> 00:20:31,280
so

515
00:20:31,280 --> 00:20:33,280
now i want to give you a short outlook

516
00:20:33,280 --> 00:20:37,679
on what could also be done with coco

517
00:20:37,679 --> 00:20:39,840
we managed to analyze

518
00:20:39,840 --> 00:20:42,480
a bigger core also the risk five swerve

519
00:20:42,480 --> 00:20:44,080
core

520
00:20:44,080 --> 00:20:47,120
um the swerve core is also a 32-bit core

521
00:20:47,120 --> 00:20:49,200
is also in order

522
00:20:49,200 --> 00:20:51,679
but has a dual issue pipeline which

523
00:20:51,679 --> 00:20:54,400
means it can execute two instructions in

524
00:20:54,400 --> 00:20:56,320
one cycle

525
00:20:56,320 --> 00:20:59,360
um it also has instead of two

526
00:20:59,360 --> 00:21:01,840
pipeline stages it has nine pipeline

527
00:21:01,840 --> 00:21:04,799
stages so it's bigger than the ebex core

528
00:21:04,799 --> 00:21:06,400
and also has some other applications

529
00:21:06,400 --> 00:21:07,280
like

530
00:21:07,280 --> 00:21:10,240
automotive or more data intensive iot

531
00:21:10,240 --> 00:21:11,760
devices

532
00:21:11,760 --> 00:21:16,159
and in our analysis we tried to

533
00:21:16,159 --> 00:21:18,240
yeah we tried to find out

534
00:21:18,240 --> 00:21:19,280
whether

535
00:21:19,280 --> 00:21:23,120
these pipeline stages or execution units

536
00:21:23,120 --> 00:21:25,440
or data caches in the core

537
00:21:25,440 --> 00:21:27,600
have some effect on the security of

538
00:21:27,600 --> 00:21:31,679
masked hardware of mask software sorry

539
00:21:31,679 --> 00:21:33,840
um yeah and we could do that with the

540
00:21:33,840 --> 00:21:34,960
coco

541
00:21:34,960 --> 00:21:39,600
tour and uh yeah just to a short outlook

542
00:21:39,600 --> 00:21:42,480
we we managed to show some interesting

543
00:21:42,480 --> 00:21:44,159
properties

544
00:21:44,159 --> 00:21:46,080
of those pipelines

545
00:21:46,080 --> 00:21:49,360
in the connection of mask software

546
00:21:49,360 --> 00:21:50,799
yeah so

547
00:21:50,799 --> 00:21:53,600
in summary there exists what we call the

548
00:21:53,600 --> 00:21:56,559
hardware software cap because former

549
00:21:56,559 --> 00:21:58,960
proofs for mask software often do not

550
00:21:58,960 --> 00:22:00,320
consider

551
00:22:00,320 --> 00:22:01,919
the hardware

552
00:22:01,919 --> 00:22:03,280
as it should be

553
00:22:03,280 --> 00:22:05,520
therefore we can have coco which helps

554
00:22:05,520 --> 00:22:07,600
with the co-verification

555
00:22:07,600 --> 00:22:09,280
of mask software

556
00:22:09,280 --> 00:22:11,600
on concrete cpu netlists

557
00:22:11,600 --> 00:22:13,840
and also with the co-design such that we

558
00:22:13,840 --> 00:22:15,679
can find

559
00:22:15,679 --> 00:22:17,919
some patches for the hardware and also

560
00:22:17,919 --> 00:22:19,440
constraints for the software for a

561
00:22:19,440 --> 00:22:22,480
specific cpu

562
00:22:22,960 --> 00:22:25,600
here in this talk i presented the case

563
00:22:25,600 --> 00:22:27,760
study about the ebooks core which you

564
00:22:27,760 --> 00:22:30,240
can if you are interested also

565
00:22:30,240 --> 00:22:33,039
read up about in our paper

566
00:22:33,039 --> 00:22:34,559
and if you're interested about the

567
00:22:34,559 --> 00:22:37,600
second case study with the swerve core

568
00:22:37,600 --> 00:22:41,520
you can also find it here in the paper

569
00:22:41,520 --> 00:22:44,720
and yeah i also included the links here

570
00:22:44,720 --> 00:22:47,760
so this was basically my presentation

571
00:22:47,760 --> 00:22:49,679
thank you very much for listening if you

572
00:22:49,679 --> 00:22:52,320
have any questions i'd be happy to

573
00:22:52,320 --> 00:22:55,639
answer them

574
00:22:56,400 --> 00:22:57,840
yeah thanks very much father that's

575
00:22:57,840 --> 00:22:59,039
really interesting

576
00:22:59,039 --> 00:23:01,360
um we have got a couple of minutes for

577
00:23:01,360 --> 00:23:04,719
questions if if there are any

578
00:23:07,440 --> 00:23:09,520
okay so a lot a long one in the track

579
00:23:09,520 --> 00:23:11,760
window from c

580
00:23:11,760 --> 00:23:14,000
let me read it out for you so

581
00:23:14,000 --> 00:23:16,400
do the proposed revisions security

582
00:23:16,400 --> 00:23:19,440
patches eg gated or unused computational

583
00:23:19,440 --> 00:23:21,440
units have an impact on the verification

584
00:23:21,440 --> 00:23:23,840
performance

585
00:23:24,799 --> 00:23:27,039
um

586
00:23:29,760 --> 00:23:30,559
i

587
00:23:30,559 --> 00:23:32,799
so

588
00:23:32,799 --> 00:23:37,480
on the verification performance

589
00:23:37,760 --> 00:23:40,480
yes it kind of did because

590
00:23:40,480 --> 00:23:41,919
for the

591
00:23:41,919 --> 00:23:45,440
for the case of the computation units

592
00:23:45,440 --> 00:23:48,720
which were kind of always computing

593
00:23:48,720 --> 00:23:50,480
we also introduced such a gating

594
00:23:50,480 --> 00:23:54,480
mechanisms such that the alu for example

595
00:23:54,480 --> 00:23:55,360
would be

596
00:23:55,360 --> 00:23:58,400
turned off when we do not need it

597
00:23:58,400 --> 00:24:00,480
and therefore of course

598
00:24:00,480 --> 00:24:03,760
the data will not enter the alu anymore

599
00:24:03,760 --> 00:24:06,720
during verification and this

600
00:24:06,720 --> 00:24:10,000
yeah this kind of cuts away the alu from

601
00:24:10,000 --> 00:24:12,720
the verification process and this

602
00:24:12,720 --> 00:24:16,000
increases the performance

603
00:24:16,000 --> 00:24:18,880
yeah

604
00:24:18,880 --> 00:24:21,120
and

605
00:24:26,080 --> 00:24:28,080
yeah about the second part of the

606
00:24:28,080 --> 00:24:29,120
question

607
00:24:29,120 --> 00:24:33,520
um yes we could actually apply coco

608
00:24:33,520 --> 00:24:36,159
also to arm processors but the problem

609
00:24:36,159 --> 00:24:37,919
there is that we do not have the net

610
00:24:37,919 --> 00:24:40,080
list so the net list of the processor is

611
00:24:40,080 --> 00:24:41,760
not public and

612
00:24:41,760 --> 00:24:45,520
um yeah without the netlist we cannot do

613
00:24:45,520 --> 00:24:47,360
the verification

614
00:24:47,360 --> 00:24:48,240
and

615
00:24:48,240 --> 00:24:51,039
yeah but if the net list were

616
00:24:51,039 --> 00:24:52,559
public available

617
00:24:52,559 --> 00:24:55,840
we could of course just apply the same

618
00:24:55,840 --> 00:24:57,760
approach we have with coco

619
00:24:57,760 --> 00:25:01,760
for an arm assembly executable and for

620
00:25:01,760 --> 00:25:05,279
any arm core you wish

621
00:25:06,159 --> 00:25:09,840
i hope this answers your question

622
00:25:13,600 --> 00:25:15,360
great okay

623
00:25:15,360 --> 00:25:18,240
um also we're kind of up against time so

624
00:25:18,240 --> 00:25:20,799
if there aren't any other questions then

625
00:25:20,799 --> 00:25:22,960
i think we thank barbara and move on to

626
00:25:22,960 --> 00:25:24,480
the next talk

627
00:25:24,480 --> 00:25:27,120
thanks a lot

628
00:25:27,120 --> 00:25:29,760
um so

