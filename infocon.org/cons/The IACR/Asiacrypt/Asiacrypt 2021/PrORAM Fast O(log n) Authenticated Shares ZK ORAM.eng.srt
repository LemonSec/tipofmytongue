1
00:00:00,320 --> 00:00:02,080
program is a new construction that

2
00:00:02,080 --> 00:00:04,000
efficiently handles random access arrays

3
00:00:04,000 --> 00:00:06,160
inside zero knowledge proofs

4
00:00:06,160 --> 00:00:08,320
program is specifically for interactive

5
00:00:08,320 --> 00:00:10,000
zero knowledge protocols and achieves

6
00:00:10,000 --> 00:00:12,400
excellent asymptotic and concrete

7
00:00:12,400 --> 00:00:14,160
performance

8
00:00:14,160 --> 00:00:16,239
in particular for an oblivious transfer

9
00:00:16,239 --> 00:00:18,160
based zero knowledge protocol that i'll

10
00:00:18,160 --> 00:00:19,840
describe in this talk

11
00:00:19,840 --> 00:00:22,000
program incurs only order of log n

12
00:00:22,000 --> 00:00:24,720
oblivious transfers per access

13
00:00:24,720 --> 00:00:27,760
in this work we formally specify program

14
00:00:27,760 --> 00:00:29,199
and incorporate it as part of an

15
00:00:29,199 --> 00:00:30,960
efficient arithmetic zero knowledge

16
00:00:30,960 --> 00:00:32,079
protocol

17
00:00:32,079 --> 00:00:33,920
the resulting system supports arbitrary

18
00:00:33,920 --> 00:00:35,840
proof statements encoded as arithmetic

19
00:00:35,840 --> 00:00:37,520
circuits that have access to efficient

20
00:00:37,520 --> 00:00:39,680
random access arrays

21
00:00:39,680 --> 00:00:41,440
we also implemented the resulting system

22
00:00:41,440 --> 00:00:43,920
and we examine its concrete performance

23
00:00:43,920 --> 00:00:46,719
let's get started

24
00:00:47,360 --> 00:00:49,440
recall that the zero knowledge proof is

25
00:00:49,440 --> 00:00:51,120
a type of proof system run between two

26
00:00:51,120 --> 00:00:54,480
parties approver and a verifier

27
00:00:54,480 --> 00:00:56,000
the two parties agree on some public

28
00:00:56,000 --> 00:00:58,079
statement which the prover claims to be

29
00:00:58,079 --> 00:00:59,600
true

30
00:00:59,600 --> 00:01:01,359
as evidence to this fact the priver

31
00:01:01,359 --> 00:01:02,960
holds a witness

32
00:01:02,960 --> 00:01:05,040
however the prover may wish to hide her

33
00:01:05,040 --> 00:01:06,720
witness from the verifier because it may

34
00:01:06,720 --> 00:01:09,360
contain sensitive information

35
00:01:09,360 --> 00:01:11,439
an interactive zero knowledge protocol

36
00:01:11,439 --> 00:01:12,799
allows the prover to convince the

37
00:01:12,799 --> 00:01:15,119
verifier that the statement must be true

38
00:01:15,119 --> 00:01:18,080
while keeping the witness hidden

39
00:01:18,080 --> 00:01:19,680
that is while the verifier becomes

40
00:01:19,680 --> 00:01:22,320
convinced that the statement is true he

41
00:01:22,320 --> 00:01:24,320
learns no information from the protocol

42
00:01:24,320 --> 00:01:27,200
interaction

43
00:01:27,200 --> 00:01:29,280
today zero knowledge proofs are widely

44
00:01:29,280 --> 00:01:31,200
studied largely due to their relevance

45
00:01:31,200 --> 00:01:32,799
to blockchains and to post quantum

46
00:01:32,799 --> 00:01:34,720
secure cryptography

47
00:01:34,720 --> 00:01:36,000
the types of proofs needed in these

48
00:01:36,000 --> 00:01:37,680
scenarios are often short and use

49
00:01:37,680 --> 00:01:38,880
non-interactive zero knowledge

50
00:01:38,880 --> 00:01:40,560
techniques

51
00:01:40,560 --> 00:01:42,479
however proofs of large statements are

52
00:01:42,479 --> 00:01:44,000
also interesting

53
00:01:44,000 --> 00:01:45,439
large price can be used to encode

54
00:01:45,439 --> 00:01:47,680
statements like a given program has a

55
00:01:47,680 --> 00:01:49,280
bug or

56
00:01:49,280 --> 00:01:51,200
a private certified database stored in

57
00:01:51,200 --> 00:01:55,439
the cloud satisfies some property

58
00:01:55,439 --> 00:01:56,960
when working with larger statements of

59
00:01:56,960 --> 00:01:59,200
this kind it is interesting to consider

60
00:01:59,200 --> 00:02:00,719
completing the proof interaction as

61
00:02:00,719 --> 00:02:03,200
quickly as possible

62
00:02:03,200 --> 00:02:05,119
in this end-to-end wall clock proof time

63
00:02:05,119 --> 00:02:07,439
metric interactive proof protocols

64
00:02:07,439 --> 00:02:10,399
remain an excellent choice

65
00:02:10,399 --> 00:02:12,319
in this work we consider these kinds of

66
00:02:12,319 --> 00:02:16,399
interactive proofs of large statements

67
00:02:16,640 --> 00:02:17,760
typically

68
00:02:17,760 --> 00:02:19,280
zero knowledge protocols allow for

69
00:02:19,280 --> 00:02:21,120
arbitrary statements where the statement

70
00:02:21,120 --> 00:02:22,959
is encoded as a simple boolean or

71
00:02:22,959 --> 00:02:24,959
arithmetic circuit and the witness is

72
00:02:24,959 --> 00:02:26,560
encoded as an assignment to the

73
00:02:26,560 --> 00:02:28,800
circuit's input wires

74
00:02:28,800 --> 00:02:31,040
however as we scale to larger and larger

75
00:02:31,040 --> 00:02:32,959
proofs it becomes harder and harder to

76
00:02:32,959 --> 00:02:34,640
efficiently describe the statement as a

77
00:02:34,640 --> 00:02:36,720
circuit

78
00:02:36,720 --> 00:02:38,480
therefore a recent line of work has

79
00:02:38,480 --> 00:02:40,640
pushed for zero knowledge machines

80
00:02:40,640 --> 00:02:43,440
that in essence run a powerful cpu

81
00:02:43,440 --> 00:02:46,720
inside a zero knowledge protocol

82
00:02:46,720 --> 00:02:48,640
the advantage of this approach is that

83
00:02:48,640 --> 00:02:50,879
we can describe the proof statement as a

84
00:02:50,879 --> 00:02:52,160
program written in a high-level

85
00:02:52,160 --> 00:02:55,599
programming language like c

86
00:02:56,800 --> 00:02:58,640
this allows users to easily describe

87
00:02:58,640 --> 00:03:01,280
extremely complex proof statements and

88
00:03:01,280 --> 00:03:03,040
has the added benefit that the engineer

89
00:03:03,040 --> 00:03:04,879
who designed such a system requires very

90
00:03:04,879 --> 00:03:06,800
little cryptographic training

91
00:03:06,800 --> 00:03:08,480
designing end-to-end proof systems of

92
00:03:08,480 --> 00:03:10,879
this kind is a large multi-faceted

93
00:03:10,879 --> 00:03:12,000
challenge

94
00:03:12,000 --> 00:03:13,920
in this work we consider an important

95
00:03:13,920 --> 00:03:16,319
problem motivated by such systems

96
00:03:16,319 --> 00:03:18,720
efficient ram access

97
00:03:18,720 --> 00:03:20,959
more precisely as the cpu runs the

98
00:03:20,959 --> 00:03:23,200
compiled program it needs to read and

99
00:03:23,200 --> 00:03:25,680
write data from a large main memory

100
00:03:25,680 --> 00:03:28,400
the cpu accesses main memory frequently

101
00:03:28,400 --> 00:03:30,319
and so a slow main memory will greatly

102
00:03:30,319 --> 00:03:32,159
harm performance

103
00:03:32,159 --> 00:03:33,680
in this work we build a new and

104
00:03:33,680 --> 00:03:35,120
efficient construction that can

105
00:03:35,120 --> 00:03:38,560
implement a main memory

106
00:03:38,879 --> 00:03:41,519
informally a suitable ram must provide

107
00:03:41,519 --> 00:03:44,319
two properties

108
00:03:44,319 --> 00:03:46,720
first it must provide obliviousness in

109
00:03:46,720 --> 00:03:49,040
the sense that the verifier should learn

110
00:03:49,040 --> 00:03:51,120
nothing about the ram access order from

111
00:03:51,120 --> 00:03:53,200
the sequences of accesses and the actual

112
00:03:53,200 --> 00:03:55,280
proof

113
00:03:55,280 --> 00:03:57,599
second a suitable ram must provide

114
00:03:57,599 --> 00:03:59,599
authenticity

115
00:03:59,599 --> 00:04:01,120
here it is useful to consider a

116
00:04:01,120 --> 00:04:03,280
malicious prover who wishes to cheat in

117
00:04:03,280 --> 00:04:05,519
the proof interaction

118
00:04:05,519 --> 00:04:07,200
suppose that this malicious prover

119
00:04:07,200 --> 00:04:09,280
wishes to substitute some value looked

120
00:04:09,280 --> 00:04:12,159
up from the ram by some other value

121
00:04:12,159 --> 00:04:14,239
for instance on the slide i have

122
00:04:14,239 --> 00:04:16,160
indicated that the ram slot holding the

123
00:04:16,160 --> 00:04:19,120
value 42 is to be red but the prover

124
00:04:19,120 --> 00:04:20,639
might try to substitute in some

125
00:04:20,639 --> 00:04:23,759
different value say 50.

126
00:04:23,759 --> 00:04:25,040
note that the approver might try to

127
00:04:25,040 --> 00:04:27,120
substitute in some arbitrary value as i

128
00:04:27,120 --> 00:04:29,199
have depicted or she might try to

129
00:04:29,199 --> 00:04:30,960
substitute in some value from a

130
00:04:30,960 --> 00:04:33,919
different slot of ram say 21.

131
00:04:33,919 --> 00:04:35,759
a suitable ram should defend against

132
00:04:35,759 --> 00:04:37,600
these types of attacks

133
00:04:37,600 --> 00:04:38,960
we refer to a construction that

134
00:04:38,960 --> 00:04:41,360
satisfies both of these properties as a

135
00:04:41,360 --> 00:04:43,280
oram because of this problem's

136
00:04:43,280 --> 00:04:45,440
connections to the field of oblivious

137
00:04:45,440 --> 00:04:47,520
ram

138
00:04:47,520 --> 00:04:49,840
in this work we introduce program a new

139
00:04:49,840 --> 00:04:51,600
zero knowledge oram

140
00:04:51,600 --> 00:04:53,440
program relies on only very simple

141
00:04:53,440 --> 00:04:54,639
primitives

142
00:04:54,639 --> 00:04:56,639
namely oblivious transfers and is

143
00:04:56,639 --> 00:04:58,080
efficient

144
00:04:58,080 --> 00:05:00,479
in particular each ram access

145
00:05:00,479 --> 00:05:04,160
uses only two log n oblivious transfers

146
00:05:04,160 --> 00:05:05,600
in the remainder of this talk i'll dig

147
00:05:05,600 --> 00:05:07,520
into the details of program

148
00:05:07,520 --> 00:05:09,360
at the end we'll consider the concrete

149
00:05:09,360 --> 00:05:12,400
performance of the overall system

150
00:05:12,400 --> 00:05:14,960
let's start with some notation

151
00:05:14,960 --> 00:05:16,639
our proof protocol will support

152
00:05:16,639 --> 00:05:18,479
arbitrary arithmetic circuits with

153
00:05:18,479 --> 00:05:21,360
multiplication gates and addition gates

154
00:05:21,360 --> 00:05:23,199
for concreteness suppose that each

155
00:05:23,199 --> 00:05:24,400
circuit wire

156
00:05:24,400 --> 00:05:26,160
holds a value in a relatively large

157
00:05:26,160 --> 00:05:28,320
field such as a field with around 2 to

158
00:05:28,320 --> 00:05:30,800
the 40 elements or more

159
00:05:30,800 --> 00:05:32,880
for each wire in the circuit the two

160
00:05:32,880 --> 00:05:34,720
parties will hold a kind of shared

161
00:05:34,720 --> 00:05:38,320
encoding of the actual value on the wire

162
00:05:38,320 --> 00:05:40,400
for instance if the wire holds the

163
00:05:40,400 --> 00:05:42,240
arithmetic value a

164
00:05:42,240 --> 00:05:45,120
then the verifier holds a random value

165
00:05:45,120 --> 00:05:47,360
big a

166
00:05:47,360 --> 00:05:49,120
while the prover holds the specific

167
00:05:49,120 --> 00:05:53,840
value big a plus little a times delta

168
00:05:54,320 --> 00:05:57,440
here the value big a is local to this

169
00:05:57,440 --> 00:05:58,960
particular wire

170
00:05:58,960 --> 00:06:00,639
each wire in the circuit will have a

171
00:06:00,639 --> 00:06:04,160
different value of the kind big a

172
00:06:04,160 --> 00:06:06,639
delta on the other hand is global to the

173
00:06:06,639 --> 00:06:08,960
entire circuit each wire sharing is

174
00:06:08,960 --> 00:06:12,159
written in terms of delta

175
00:06:12,240 --> 00:06:16,319
delta is a random non-zero value

176
00:06:16,479 --> 00:06:18,319
when these individual shares held by the

177
00:06:18,319 --> 00:06:20,560
two players are not relevant i'll

178
00:06:20,560 --> 00:06:22,160
package both shares together into a

179
00:06:22,160 --> 00:06:24,000
single value written with this double

180
00:06:24,000 --> 00:06:25,680
bracket notation

181
00:06:25,680 --> 00:06:27,440
we refer to these joint sharings as

182
00:06:27,440 --> 00:06:30,000
authenticated sharings in the literature

183
00:06:30,000 --> 00:06:31,680
such sharings are sometimes called

184
00:06:31,680 --> 00:06:35,360
information theoretic macs

185
00:06:35,360 --> 00:06:37,199
i'll note a few important properties of

186
00:06:37,199 --> 00:06:38,960
authenticated sharings

187
00:06:38,960 --> 00:06:40,080
first

188
00:06:40,080 --> 00:06:42,880
we will always assume that the prover p

189
00:06:42,880 --> 00:06:44,479
knows and cleartext the value on each

190
00:06:44,479 --> 00:06:45,440
wire

191
00:06:45,440 --> 00:06:48,800
specifically p knows the value little a

192
00:06:48,800 --> 00:06:51,680
however we will enforce that p will not

193
00:06:51,680 --> 00:06:53,759
know the value big a

194
00:06:53,759 --> 00:06:58,000
and also will not know the value delta

195
00:06:58,000 --> 00:07:00,479
this is how we achieve authentication

196
00:07:00,479 --> 00:07:03,440
it is infeasible for p who knows a share

197
00:07:03,440 --> 00:07:04,960
of little a

198
00:07:04,960 --> 00:07:07,280
to forge a share of some other value say

199
00:07:07,280 --> 00:07:09,520
little a plus one

200
00:07:09,520 --> 00:07:11,840
forging such a value would require p to

201
00:07:11,840 --> 00:07:13,440
guess delta

202
00:07:13,440 --> 00:07:15,440
and delta is a random value in a large

203
00:07:15,440 --> 00:07:16,479
field

204
00:07:16,479 --> 00:07:18,400
thus p can guess delta only with

205
00:07:18,400 --> 00:07:21,440
negligible probability

206
00:07:21,440 --> 00:07:23,759
finally notice that big a acts as a

207
00:07:23,759 --> 00:07:25,919
simple one-time pad on the authenticated

208
00:07:25,919 --> 00:07:29,039
value a times delta

209
00:07:29,039 --> 00:07:31,840
these one-time pads are central to

210
00:07:31,840 --> 00:07:33,120
pro-ram

211
00:07:33,120 --> 00:07:34,400
and we will discuss them for the

212
00:07:34,400 --> 00:07:36,479
remainder of this talk

213
00:07:36,479 --> 00:07:38,400
our zika proof system implements

214
00:07:38,400 --> 00:07:40,080
arithmetic circuits that propagate

215
00:07:40,080 --> 00:07:44,479
authentic sharings as shown on the slide

216
00:07:44,479 --> 00:07:46,240
recall that our goal

217
00:07:46,240 --> 00:07:47,919
is to implement a ram that works with

218
00:07:47,919 --> 00:07:49,840
arithmetic circuits

219
00:07:49,840 --> 00:07:52,319
therefore the ram should produce as

220
00:07:52,319 --> 00:07:54,800
output and accept as input authenticated

221
00:07:54,800 --> 00:07:57,280
sharings

222
00:07:57,759 --> 00:07:59,840
before moving on let me introduce one

223
00:07:59,840 --> 00:08:02,240
final piece of notation

224
00:08:02,240 --> 00:08:04,639
for a sharing with mask big a i will

225
00:08:04,639 --> 00:08:07,120
sometimes write big a in the subscript

226
00:08:07,120 --> 00:08:10,319
of the authenticated sharing

227
00:08:11,280 --> 00:08:12,960
the ram should output an authenticated

228
00:08:12,960 --> 00:08:17,520
sharing masked by some arbitrary value m

229
00:08:17,520 --> 00:08:19,120
we're now ready to look at the ram

230
00:08:19,120 --> 00:08:22,160
problem a bit more formally

231
00:08:22,160 --> 00:08:24,400
suppose that we simply store the ram as

232
00:08:24,400 --> 00:08:28,240
a sequence of authenticated sharings

233
00:08:28,240 --> 00:08:30,479
that is each ram slot is simply a

234
00:08:30,479 --> 00:08:32,880
distinct sharing authenticated by some

235
00:08:32,880 --> 00:08:35,200
mask

236
00:08:35,200 --> 00:08:37,440
suppose that at runtime the arithmetic

237
00:08:37,440 --> 00:08:39,360
circuit requests access to a particular

238
00:08:39,360 --> 00:08:43,680
index of the ram say index 3.

239
00:08:44,000 --> 00:08:46,160
first note that the prover knows that

240
00:08:46,160 --> 00:08:48,240
the circuit requests index 3 in clear

241
00:08:48,240 --> 00:08:49,200
text

242
00:08:49,200 --> 00:08:52,000
indeed the priver p has the entire ram

243
00:08:52,000 --> 00:08:55,839
access history in her head

244
00:08:56,080 --> 00:08:57,760
since this is the case

245
00:08:57,760 --> 00:09:00,000
p can simply retrieve her share of index

246
00:09:00,000 --> 00:09:02,000
3 directly

247
00:09:02,000 --> 00:09:05,360
however the problem is that in doing so

248
00:09:05,360 --> 00:09:06,800
she retrieves a share with the

249
00:09:06,800 --> 00:09:09,839
particular mask m3

250
00:09:09,839 --> 00:09:11,680
we need the output of the ram to be a

251
00:09:11,680 --> 00:09:14,080
valid authenticated sharing but to form

252
00:09:14,080 --> 00:09:16,720
a valid sharing both parties must agree

253
00:09:16,720 --> 00:09:20,320
on the specific mask m3

254
00:09:20,320 --> 00:09:24,480
but v cannot know the specific mask m3

255
00:09:24,480 --> 00:09:26,560
otherwise he would learn the access

256
00:09:26,560 --> 00:09:29,839
index and the ram would not be oblivious

257
00:09:29,839 --> 00:09:36,519
however v does know all such masks mi

258
00:09:36,959 --> 00:09:38,399
we're now ready for the high level

259
00:09:38,399 --> 00:09:40,720
intuition behind program

260
00:09:40,720 --> 00:09:42,800
note that this will just be high level

261
00:09:42,800 --> 00:09:44,800
intuition and i will leave several

262
00:09:44,800 --> 00:09:46,880
crucial problems on the table that must

263
00:09:46,880 --> 00:09:49,439
be solved

264
00:09:49,519 --> 00:09:51,839
first let's suppose that it's possible

265
00:09:51,839 --> 00:09:54,320
to describe the ram access order as a

266
00:09:54,320 --> 00:09:56,399
permutation

267
00:09:56,399 --> 00:09:58,160
with this restriction made

268
00:09:58,160 --> 00:10:00,560
the idea is that the proofer p will

269
00:10:00,560 --> 00:10:04,079
somehow request from the verifier each

270
00:10:04,079 --> 00:10:08,880
of the ram masks in some permuted order

271
00:10:09,839 --> 00:10:11,839
the idea is that the approver will

272
00:10:11,839 --> 00:10:15,120
request these masks in the order of ram

273
00:10:15,120 --> 00:10:16,160
access

274
00:10:16,160 --> 00:10:18,160
in essence aligning the order of the

275
00:10:18,160 --> 00:10:22,399
masks with the order of ram access

276
00:10:22,399 --> 00:10:24,079
note that if the priver holds these

277
00:10:24,079 --> 00:10:25,200
masks

278
00:10:25,200 --> 00:10:26,800
then she can read elements from the

279
00:10:26,800 --> 00:10:29,360
array one by one by stripping off the

280
00:10:29,360 --> 00:10:32,360
masks

281
00:10:33,440 --> 00:10:35,440
as i said this intuition leaves on the

282
00:10:35,440 --> 00:10:38,880
table several important problems

283
00:10:38,880 --> 00:10:40,079
first

284
00:10:40,079 --> 00:10:42,640
my description implied that p will learn

285
00:10:42,640 --> 00:10:44,640
each of these ram masks

286
00:10:44,640 --> 00:10:46,800
this is clearly insecure

287
00:10:46,800 --> 00:10:48,320
since my entire argument for the

288
00:10:48,320 --> 00:10:51,120
authenticity of authenticated shares was

289
00:10:51,120 --> 00:10:53,200
based on the secret one-time pad nature

290
00:10:53,200 --> 00:10:55,279
of the masks

291
00:10:55,279 --> 00:10:56,320
second

292
00:10:56,320 --> 00:10:58,079
i assume that the ram access order can

293
00:10:58,079 --> 00:11:00,480
be described as a permutation but this

294
00:11:00,480 --> 00:11:02,399
is clearly insufficient to describe

295
00:11:02,399 --> 00:11:05,279
arbitrary ram access orders

296
00:11:05,279 --> 00:11:07,200
in real rams we assume that we can

297
00:11:07,200 --> 00:11:09,360
access the same slot repeatedly a

298
00:11:09,360 --> 00:11:10,959
permutation cannot support this

299
00:11:10,959 --> 00:11:12,560
capability

300
00:11:12,560 --> 00:11:14,480
the rest of this talk will be about

301
00:11:14,480 --> 00:11:17,279
resolving these two problems

302
00:11:17,279 --> 00:11:20,320
let's start with this first problem

303
00:11:20,320 --> 00:11:22,880
our high-level intuition will still hold

304
00:11:22,880 --> 00:11:24,959
p will request from v a permuted

305
00:11:24,959 --> 00:11:27,200
collection of masks

306
00:11:27,200 --> 00:11:29,279
however rather than obtaining these

307
00:11:29,279 --> 00:11:31,120
masks in clear text

308
00:11:31,120 --> 00:11:33,600
p will instead obtain encodings of the

309
00:11:33,600 --> 00:11:36,640
masks that hide their clear text values

310
00:11:36,640 --> 00:11:38,720
to encode masks we will introduce to our

311
00:11:38,720 --> 00:11:41,279
system a second type of sharing

312
00:11:41,279 --> 00:11:43,519
in addition to authenticated sharings

313
00:11:43,519 --> 00:11:45,360
our system will also work with simple

314
00:11:45,360 --> 00:11:47,200
additive sharings

315
00:11:47,200 --> 00:11:49,600
here as with the authenticated sharings

316
00:11:49,600 --> 00:11:52,079
the parties hold a shared encoding of a

317
00:11:52,079 --> 00:11:55,120
field element little a

318
00:11:55,120 --> 00:11:57,040
however these simple additive sharings

319
00:11:57,040 --> 00:12:01,199
do not involve the global secret delta

320
00:12:02,079 --> 00:12:04,480
additionally for additive sharings we

321
00:12:04,480 --> 00:12:07,760
will enforce that the prover p does not

322
00:12:07,760 --> 00:12:10,959
know the clear text value little a

323
00:12:10,959 --> 00:12:12,959
this is starkly in contrast to

324
00:12:12,959 --> 00:12:15,040
authenticated sharings where we assume

325
00:12:15,040 --> 00:12:17,600
that p knows all encoded values in clear

326
00:12:17,600 --> 00:12:19,680
text

327
00:12:19,680 --> 00:12:21,360
one of the crucial insights behind

328
00:12:21,360 --> 00:12:23,200
program is that we can use these

329
00:12:23,200 --> 00:12:26,639
additive sharings to encode the masks

330
00:12:26,639 --> 00:12:29,600
for authenticated sharings

331
00:12:29,600 --> 00:12:31,519
very shortly we'll use the ability to

332
00:12:31,519 --> 00:12:33,760
operate on additive sharings to express

333
00:12:33,760 --> 00:12:35,360
permutations

334
00:12:35,360 --> 00:12:37,120
since these new sharings are additive

335
00:12:37,120 --> 00:12:39,519
they trivially support homomorphic

336
00:12:39,519 --> 00:12:43,519
addition and subtraction operations

337
00:12:43,519 --> 00:12:45,279
to this list we'll add one further

338
00:12:45,279 --> 00:12:47,839
operation

339
00:12:48,399 --> 00:12:50,800
this operation allows p to scale a

340
00:12:50,800 --> 00:12:53,120
shared field element b

341
00:12:53,120 --> 00:12:57,120
by some bit a of her choice

342
00:12:57,120 --> 00:12:58,720
i won't describe the procedure for this

343
00:12:58,720 --> 00:13:01,040
operation in detail here but it can be

344
00:13:01,040 --> 00:13:03,200
easily implemented by a single oblivious

345
00:13:03,200 --> 00:13:04,240
transfer

346
00:13:04,240 --> 00:13:05,600
have a look at our paper if you want

347
00:13:05,600 --> 00:13:08,079
further details

348
00:13:08,079 --> 00:13:10,399
these three operations together induce a

349
00:13:10,399 --> 00:13:12,560
vector space over additive sharings

350
00:13:12,560 --> 00:13:15,120
where private bits chosen by the prover

351
00:13:15,120 --> 00:13:18,000
act as scalars

352
00:13:18,079 --> 00:13:20,079
a vector space is not sufficient to

353
00:13:20,079 --> 00:13:22,079
encode arbitrary computations on the

354
00:13:22,079 --> 00:13:24,800
field elements but at least informally

355
00:13:24,800 --> 00:13:27,519
it is sufficient to arbitrarily move

356
00:13:27,519 --> 00:13:31,200
field elements around inside the circuit

357
00:13:31,200 --> 00:13:33,120
more specifically the vector space

358
00:13:33,120 --> 00:13:34,959
operations are powerful enough to build

359
00:13:34,959 --> 00:13:38,639
permutations as we will see next

360
00:13:38,639 --> 00:13:41,360
let's return to our high level intuition

361
00:13:41,360 --> 00:13:43,600
we will substitute each plaintext mask

362
00:13:43,600 --> 00:13:45,839
by an additive sharing that instead

363
00:13:45,839 --> 00:13:48,639
encodes that mask

364
00:13:48,639 --> 00:13:50,959
from here we will permute the masks

365
00:13:50,959 --> 00:13:53,279
according to a permutation pie chosen by

366
00:13:53,279 --> 00:13:55,760
the prover

367
00:13:56,880 --> 00:13:58,320
let's briefly discuss how we can

368
00:13:58,320 --> 00:14:00,639
implement such a permutation

369
00:14:00,639 --> 00:14:02,320
the idea is to use a classic

370
00:14:02,320 --> 00:14:03,920
construction called a permutation

371
00:14:03,920 --> 00:14:05,600
network

372
00:14:05,600 --> 00:14:07,839
a permutation network is a recursive

373
00:14:07,839 --> 00:14:09,839
construction whereby we build a

374
00:14:09,839 --> 00:14:11,839
permutation on n elements

375
00:14:11,839 --> 00:14:14,240
using two permutations on and over two

376
00:14:14,240 --> 00:14:15,680
elements

377
00:14:15,680 --> 00:14:17,680
in addition to the two recursive calls

378
00:14:17,680 --> 00:14:19,600
the network uses a linear number of

379
00:14:19,600 --> 00:14:23,120
so-called swap gates

380
00:14:23,120 --> 00:14:25,600
a swap gate either swaps its two inputs

381
00:14:25,600 --> 00:14:28,800
or leaves them as is

382
00:14:29,120 --> 00:14:30,880
it's easy to implement a swap gate that

383
00:14:30,880 --> 00:14:32,800
is controlled by the prover using our

384
00:14:32,800 --> 00:14:36,319
vector space operations

385
00:14:36,720 --> 00:14:39,680
specifically we'll calculate this scaled

386
00:14:39,680 --> 00:14:42,800
difference between the two inputs

387
00:14:42,800 --> 00:14:44,399
then we will add and subtract

388
00:14:44,399 --> 00:14:46,000
appropriately to construct the gate

389
00:14:46,000 --> 00:14:48,480
outputs

390
00:14:48,800 --> 00:14:50,480
let's observe that this operation is

391
00:14:50,480 --> 00:14:52,480
correct

392
00:14:52,480 --> 00:14:56,160
if p's choice bit s happens to be 0

393
00:14:56,160 --> 00:14:59,440
then the scaled difference is also zero

394
00:14:59,440 --> 00:15:01,199
and therefore the inputs are propagated

395
00:15:01,199 --> 00:15:03,279
directly to the outputs

396
00:15:03,279 --> 00:15:07,440
if instead p's choice bit s is one

397
00:15:07,440 --> 00:15:10,800
then the scaled difference goes through

398
00:15:10,800 --> 00:15:14,000
and swaps the two inputs

399
00:15:14,000 --> 00:15:16,079
hence the prover can control a single

400
00:15:16,079 --> 00:15:20,160
swap gate by a single scaling operation

401
00:15:20,160 --> 00:15:22,320
and therefore a swap gate uses a single

402
00:15:22,320 --> 00:15:24,720
oblivious transfer

403
00:15:24,720 --> 00:15:26,560
we can use this capability to implement

404
00:15:26,560 --> 00:15:29,279
an arbitrarily large permutation network

405
00:15:29,279 --> 00:15:30,959
our permutation networks will take as

406
00:15:30,959 --> 00:15:34,000
inputs shared masks mi

407
00:15:34,000 --> 00:15:36,079
and then output them in a permuted order

408
00:15:36,079 --> 00:15:37,920
chosen by the prover

409
00:15:37,920 --> 00:15:40,639
the entire permutation will consume only

410
00:15:40,639 --> 00:15:43,600
n log n oblivious transfers

411
00:15:43,600 --> 00:15:45,759
if we return to our top level view we

412
00:15:45,759 --> 00:15:47,519
can now understand more formally our

413
00:15:47,519 --> 00:15:49,440
high level intuition

414
00:15:49,440 --> 00:15:52,000
the verifier v starts by constructing

415
00:15:52,000 --> 00:15:54,959
additive sharings of each of his masks

416
00:15:54,959 --> 00:15:56,959
the parties then apply a permutation

417
00:15:56,959 --> 00:15:59,279
network to these encoded masks

418
00:15:59,279 --> 00:16:01,519
generating a permuted set of encoded

419
00:16:01,519 --> 00:16:03,040
masks

420
00:16:03,040 --> 00:16:05,680
crucially throughout this entire process

421
00:16:05,680 --> 00:16:10,638
the prover does not learn any mask mi

422
00:16:10,720 --> 00:16:13,120
let's now look at how this permutation

423
00:16:13,120 --> 00:16:16,480
supports ram accesses

424
00:16:16,639 --> 00:16:18,480
consider the first ram access in this

425
00:16:18,480 --> 00:16:20,880
example which will be to the index

426
00:16:20,880 --> 00:16:23,279
3.

427
00:16:23,279 --> 00:16:25,120
the parties hold these two relevant

428
00:16:25,120 --> 00:16:26,800
sharings

429
00:16:26,800 --> 00:16:28,639
if we unpack the definition of these two

430
00:16:28,639 --> 00:16:30,800
sharings we can see that the parties

431
00:16:30,800 --> 00:16:32,959
have enough information to locally

432
00:16:32,959 --> 00:16:34,880
construct an authenticated sharing of

433
00:16:34,880 --> 00:16:38,320
the appropriate ram value

434
00:16:39,920 --> 00:16:41,279
specifically

435
00:16:41,279 --> 00:16:43,920
p subtracts her share of the encoded

436
00:16:43,920 --> 00:16:46,560
mask from her share of the encoded ram

437
00:16:46,560 --> 00:16:48,399
value

438
00:16:48,399 --> 00:16:50,480
meanwhile the verifier chooses as his

439
00:16:50,480 --> 00:16:53,680
input negative r

440
00:16:53,759 --> 00:16:55,839
some simple arithmetic demonstrates that

441
00:16:55,839 --> 00:16:57,920
this is a valid sharing of the

442
00:16:57,920 --> 00:17:01,600
appropriate ram value x3

443
00:17:01,600 --> 00:17:03,440
notice that this has solved our original

444
00:17:03,440 --> 00:17:05,039
problem

445
00:17:05,039 --> 00:17:07,119
the parties have managed to agree on a

446
00:17:07,119 --> 00:17:10,160
specific mask negative r without leaking

447
00:17:10,160 --> 00:17:12,959
a mask to the prover

448
00:17:12,959 --> 00:17:15,039
thus we have solved this first problem

449
00:17:15,039 --> 00:17:17,280
by incorporating two different types of

450
00:17:17,280 --> 00:17:20,879
sharings in the same circuit

451
00:17:21,119 --> 00:17:23,119
however one high-level problem from our

452
00:17:23,119 --> 00:17:24,640
intuition remains

453
00:17:24,640 --> 00:17:27,359
as described our ram still only supports

454
00:17:27,359 --> 00:17:29,120
access orders that can be expressed as

455
00:17:29,120 --> 00:17:30,799
permutations

456
00:17:30,799 --> 00:17:33,280
to support full ram we need to upgrade

457
00:17:33,280 --> 00:17:35,039
the ram to support arbitrary access

458
00:17:35,039 --> 00:17:36,720
orders that cannot be described as

459
00:17:36,720 --> 00:17:38,640
permutations

460
00:17:38,640 --> 00:17:40,960
to implement general purpose ram we will

461
00:17:40,960 --> 00:17:43,280
perform a reduction to a simpler object

462
00:17:43,280 --> 00:17:45,600
that we call a sword ram

463
00:17:45,600 --> 00:17:48,320
a sword ramp allows random access reads

464
00:17:48,320 --> 00:17:51,679
but only allows each ram slot to be read

465
00:17:51,679 --> 00:17:55,039
at most one time

466
00:17:55,760 --> 00:17:58,400
meanwhile the sword ram only allows

467
00:17:58,400 --> 00:18:00,080
sequential rights

468
00:18:00,080 --> 00:18:02,320
that is the parties can only append

469
00:18:02,320 --> 00:18:05,520
values to the end of a sword ram

470
00:18:05,520 --> 00:18:07,919
since we write sequentially on each

471
00:18:07,919 --> 00:18:10,160
right the parties can trivially agree on

472
00:18:10,160 --> 00:18:13,120
masks for stored authenticated sharings

473
00:18:13,120 --> 00:18:15,120
and since we read each element at most

474
00:18:15,120 --> 00:18:17,679
once a permutation suffices to describe

475
00:18:17,679 --> 00:18:19,280
the read order

476
00:18:19,280 --> 00:18:21,120
thus we have all the tools we need

477
00:18:21,120 --> 00:18:25,039
already to implement a sword rim

478
00:18:26,559 --> 00:18:28,480
i'll now show the reduction from ram to

479
00:18:28,480 --> 00:18:30,080
sword ram

480
00:18:30,080 --> 00:18:32,160
for sake of example suppose we wish to

481
00:18:32,160 --> 00:18:35,840
instantiate a size 4 ram

482
00:18:35,840 --> 00:18:37,760
for our reduction we will need a sword

483
00:18:37,760 --> 00:18:39,440
rim that is twice as large as the

484
00:18:39,440 --> 00:18:42,320
desired ram so i've drawn a size 8 sword

485
00:18:42,320 --> 00:18:44,720
ram on the slide

486
00:18:44,720 --> 00:18:46,240
recall that the sword ram supports

487
00:18:46,240 --> 00:18:48,880
sequential writes i'll indicate the next

488
00:18:48,880 --> 00:18:52,880
location to be written with this arrow

489
00:18:53,200 --> 00:18:55,200
the parties start by sequentially

490
00:18:55,200 --> 00:18:57,120
writing the initial content of the ram

491
00:18:57,120 --> 00:18:59,440
into the sword ram

492
00:18:59,440 --> 00:19:01,840
the numbers on the slide indicate the

493
00:19:01,840 --> 00:19:03,679
ram index that is stored in the sword

494
00:19:03,679 --> 00:19:07,760
ram slot so sword ram slot 0 holds ram

495
00:19:07,760 --> 00:19:10,960
slot 0.

496
00:19:10,960 --> 00:19:12,960
recall that p holds in her head the

497
00:19:12,960 --> 00:19:16,559
entire ram access history

498
00:19:16,559 --> 00:19:19,120
p uses this information to program a

499
00:19:19,120 --> 00:19:20,880
permutation network as we've already

500
00:19:20,880 --> 00:19:22,160
described

501
00:19:22,160 --> 00:19:24,080
and this permutation network will allow

502
00:19:24,080 --> 00:19:26,240
her to read from the sword ram in some

503
00:19:26,240 --> 00:19:28,720
permuted order

504
00:19:28,720 --> 00:19:30,720
for sake of example suppose that the

505
00:19:30,720 --> 00:19:34,000
first ram access indexes into ram slot

506
00:19:34,000 --> 00:19:35,840
2.

507
00:19:35,840 --> 00:19:37,679
p uses the output of the permutation

508
00:19:37,679 --> 00:19:40,000
network to read the appropriate element

509
00:19:40,000 --> 00:19:41,840
from ram and the parties can thus

510
00:19:41,840 --> 00:19:43,840
construct an authenticated sharing of

511
00:19:43,840 --> 00:19:47,520
the appropriate ram element x2

512
00:19:47,520 --> 00:19:49,360
note that the access sword rim slot is

513
00:19:49,360 --> 00:19:51,280
now essentially burned because it can

514
00:19:51,280 --> 00:19:53,760
never be read again

515
00:19:53,760 --> 00:19:55,840
this is problematic because it might be

516
00:19:55,840 --> 00:19:58,320
the case that ram slot 2 will be read

517
00:19:58,320 --> 00:20:00,400
again in the future

518
00:20:00,400 --> 00:20:02,400
to account for this fact the parties

519
00:20:02,400 --> 00:20:05,520
write back a new version of index 2 to

520
00:20:05,520 --> 00:20:06,960
the sword ram

521
00:20:06,960 --> 00:20:08,559
this is also where the parties were to

522
00:20:08,559 --> 00:20:11,679
account for rights to the ram

523
00:20:11,679 --> 00:20:14,000
if the next access is indeed also to

524
00:20:14,000 --> 00:20:16,799
index 2 we will be able to support that

525
00:20:16,799 --> 00:20:19,600
access as well

526
00:20:19,600 --> 00:20:21,919
the parties continue in this manner

527
00:20:21,919 --> 00:20:23,919
on each access reading a slot from sword

528
00:20:23,919 --> 00:20:26,000
ram and writing it back to a fresh slot

529
00:20:26,000 --> 00:20:29,840
until n accesses are completed

530
00:20:29,840 --> 00:20:32,240
notice that after n accesses the sword

531
00:20:32,240 --> 00:20:34,320
ram is completely full and we cannot

532
00:20:34,320 --> 00:20:37,360
write any more values

533
00:20:37,360 --> 00:20:39,280
however also notice that there are main

534
00:20:39,280 --> 00:20:41,840
n available reads and that those reads

535
00:20:41,840 --> 00:20:44,880
contain the most recent copy of each ram

536
00:20:44,880 --> 00:20:46,799
index

537
00:20:46,799 --> 00:20:49,520
to continue we use our remaining reads

538
00:20:49,520 --> 00:20:51,760
to extract the rim content from our now

539
00:20:51,760 --> 00:20:53,840
exhausted sword ram and then rewrite

540
00:20:53,840 --> 00:20:56,080
these values into a fresh sword ram one

541
00:20:56,080 --> 00:20:58,639
at a time

542
00:21:01,360 --> 00:21:03,200
once we have copied the ram content in

543
00:21:03,200 --> 00:21:05,280
this way we are ready to handle and more

544
00:21:05,280 --> 00:21:06,480
accesses

545
00:21:06,480 --> 00:21:09,039
by repeating this process our ram can

546
00:21:09,039 --> 00:21:12,480
support arbitrary numbers of accesses

547
00:21:12,480 --> 00:21:14,880
so by using sword ram we can construct

548
00:21:14,880 --> 00:21:17,600
an efficient ram

549
00:21:17,600 --> 00:21:19,520
there is still one issue i have until

550
00:21:19,520 --> 00:21:22,320
now swept under the rug

551
00:21:22,320 --> 00:21:24,000
suppose that the arithmetic circuit

552
00:21:24,000 --> 00:21:26,559
generates a query into the array

553
00:21:26,559 --> 00:21:28,559
specifically it searches for some

554
00:21:28,559 --> 00:21:32,159
specific ram index say index 2.

555
00:21:32,159 --> 00:21:34,480
as is there is no way to force the

556
00:21:34,480 --> 00:21:36,480
prover to read the corresponding index

557
00:21:36,480 --> 00:21:38,080
from ram

558
00:21:38,080 --> 00:21:40,159
in some sense the prover has total

559
00:21:40,159 --> 00:21:42,400
freedom to select whichever ram slot she

560
00:21:42,400 --> 00:21:44,559
would like

561
00:21:44,559 --> 00:21:47,760
this is of course problematic

562
00:21:47,760 --> 00:21:49,520
the solution to this problem is actually

563
00:21:49,520 --> 00:21:51,280
quite simple

564
00:21:51,280 --> 00:21:52,799
rather than just storing each ram

565
00:21:52,799 --> 00:21:55,840
element x i alone we store each ram

566
00:21:55,840 --> 00:21:58,559
element as a pair containing both x i

567
00:21:58,559 --> 00:22:01,440
and an explicit index i

568
00:22:01,440 --> 00:22:02,960
we are careful to ensure that all

569
00:22:02,960 --> 00:22:05,120
operations permute the ram element and

570
00:22:05,120 --> 00:22:08,479
its index as a unit

571
00:22:08,960 --> 00:22:11,760
now when the circuit requests index two

572
00:22:11,760 --> 00:22:14,480
we can force p to read the appropriate

573
00:22:14,480 --> 00:22:16,640
ram slot

574
00:22:16,640 --> 00:22:18,880
we do this by forcing p to generate a

575
00:22:18,880 --> 00:22:21,840
so-called proof of zero

576
00:22:21,840 --> 00:22:24,000
namely she will subtract the accessed

577
00:22:24,000 --> 00:22:26,559
ram index from the ram index that was

578
00:22:26,559 --> 00:22:28,799
stored in the ram itself

579
00:22:28,799 --> 00:22:32,000
generating an encoding of zero

580
00:22:32,000 --> 00:22:33,919
the prover can then send her share of

581
00:22:33,919 --> 00:22:35,520
this encoding to the verifier as

582
00:22:35,520 --> 00:22:37,200
evidence that she accessed the cram ram

583
00:22:37,200 --> 00:22:38,559
slot

584
00:22:38,559 --> 00:22:40,720
the verifier simply checks

585
00:22:40,720 --> 00:22:42,640
that the share sent by the approver is

586
00:22:42,640 --> 00:22:44,720
equal to his own share

587
00:22:44,720 --> 00:22:46,240
notice that if the prover attempts to

588
00:22:46,240 --> 00:22:48,240
cheat and substitute in some different

589
00:22:48,240 --> 00:22:50,000
rim value she will be unable to

590
00:22:50,000 --> 00:22:53,520
construct this proof of zero

591
00:22:53,520 --> 00:22:55,520
the proof of zero is an extremely cheap

592
00:22:55,520 --> 00:22:58,400
operation we can even compress many

593
00:22:58,400 --> 00:22:59,840
proofs of zero together using a

594
00:22:59,840 --> 00:23:02,880
cryptographic hash function

595
00:23:02,880 --> 00:23:05,280
thus program allows us to force p to

596
00:23:05,280 --> 00:23:07,840
provide a consistent ram access order in

597
00:23:07,840 --> 00:23:10,000
a very straightforward manner

598
00:23:10,000 --> 00:23:12,000
the prover simply generates a number of

599
00:23:12,000 --> 00:23:14,559
these proofs of zero

600
00:23:14,559 --> 00:23:17,520
to recap program builds a size and ram

601
00:23:17,520 --> 00:23:20,559
from a size 2n sword ram

602
00:23:20,559 --> 00:23:22,960
each time we initialize a size 2n sword

603
00:23:22,960 --> 00:23:23,840
ram

604
00:23:23,840 --> 00:23:26,559
the prover programs a permutation on two

605
00:23:26,559 --> 00:23:29,280
n masks

606
00:23:29,280 --> 00:23:30,880
this means that on each access we

607
00:23:30,880 --> 00:23:33,440
consume amortized two log n oblivious

608
00:23:33,440 --> 00:23:35,600
transfers

609
00:23:35,600 --> 00:23:36,880
notice that the number of oblivious

610
00:23:36,880 --> 00:23:38,960
transfers is independent of the size of

611
00:23:38,960 --> 00:23:42,400
elements stored in the ram

612
00:23:42,400 --> 00:23:44,320
additionally program features extremely

613
00:23:44,320 --> 00:23:47,200
straightforward consistency checks

614
00:23:47,200 --> 00:23:49,120
this is in contrast to other zko ramps

615
00:23:49,120 --> 00:23:50,640
that require a much more complex

616
00:23:50,640 --> 00:23:52,960
consistency check involving comparison

617
00:23:52,960 --> 00:23:55,600
operations on both ram indices and on

618
00:23:55,600 --> 00:23:58,080
timestamp values

619
00:23:58,080 --> 00:24:00,000
to conclude i want to briefly look at

620
00:24:00,000 --> 00:24:02,159
programs performance

621
00:24:02,159 --> 00:24:04,559
we implemented program in c plus and ran

622
00:24:04,559 --> 00:24:06,799
it on commodity hardware

623
00:24:06,799 --> 00:24:08,720
in terms of communication

624
00:24:08,720 --> 00:24:10,720
our implementation confirms program's

625
00:24:10,720 --> 00:24:12,960
low logarithmic scaling

626
00:24:12,960 --> 00:24:15,120
and in terms of wall clock time program

627
00:24:15,120 --> 00:24:17,200
gives excellent performance requiring

628
00:24:17,200 --> 00:24:19,360
only a few microseconds per access even

629
00:24:19,360 --> 00:24:21,279
for moderate rams that store megabytes

630
00:24:21,279 --> 00:24:23,679
of data

631
00:24:23,679 --> 00:24:25,440
so this was proram

632
00:24:25,440 --> 00:24:28,000
to recap program is a simple and fast

633
00:24:28,000 --> 00:24:29,919
zero knowledge oblivious ram with

634
00:24:29,919 --> 00:24:31,679
excellent asymptotic and concrete

635
00:24:31,679 --> 00:24:34,679
performance

