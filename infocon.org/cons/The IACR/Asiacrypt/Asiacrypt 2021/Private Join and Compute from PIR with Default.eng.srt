1
00:00:08,880 --> 00:00:10,400
hello uh

2
00:00:10,400 --> 00:00:12,719
thank you for watching this talk uh

3
00:00:12,719 --> 00:00:15,360
today i'll be talking about pure default

4
00:00:15,360 --> 00:00:17,119
and applications

5
00:00:17,119 --> 00:00:19,520
and this is work together with my

6
00:00:19,520 --> 00:00:23,600
co-authors for google and me true who is

7
00:00:23,600 --> 00:00:26,400
our intern and is currently at arizona

8
00:00:26,400 --> 00:00:29,640
state university

9
00:00:30,080 --> 00:00:31,920
uh first let me discuss what's the

10
00:00:31,920 --> 00:00:35,200
problem we're trying to solve

11
00:00:35,360 --> 00:00:37,200
the particular problem we're looking at

12
00:00:37,200 --> 00:00:39,680
is called inner join private join and

13
00:00:39,680 --> 00:00:41,680
compute

14
00:00:41,680 --> 00:00:44,239
so in this problem consider a user who

15
00:00:44,239 --> 00:00:47,760
has several ids x1 through xm

16
00:00:47,760 --> 00:00:51,039
and several associated weights v1

17
00:00:51,039 --> 00:00:55,360
through vm associated with each id

18
00:00:55,440 --> 00:00:57,840
and also a server who has a much larger

19
00:00:57,840 --> 00:01:00,239
database of a similar kind with many

20
00:01:00,239 --> 00:01:02,239
more ids y

21
00:01:02,239 --> 00:01:04,239
and associated with

22
00:01:04,239 --> 00:01:06,640
w

23
00:01:06,799 --> 00:01:09,200
and the goal is for the user to find the

24
00:01:09,200 --> 00:01:11,520
inner product of

25
00:01:11,520 --> 00:01:15,439
its data set with the servers data set

26
00:01:15,439 --> 00:01:18,720
only for those values x i which are in

27
00:01:18,720 --> 00:01:21,040
the set y contained or held by the

28
00:01:21,040 --> 00:01:22,640
server

29
00:01:22,640 --> 00:01:24,400
and for all such values you should learn

30
00:01:24,400 --> 00:01:26,960
the product of the sum of the products

31
00:01:26,960 --> 00:01:29,840
vx times wx where vx represents the

32
00:01:29,840 --> 00:01:31,840
value associated with that for each

33
00:01:31,840 --> 00:01:34,400
particular x and w represents the value

34
00:01:34,400 --> 00:01:36,000
w associated with

35
00:01:36,000 --> 00:01:37,520
that particular

36
00:01:37,520 --> 00:01:39,520
y

37
00:01:39,520 --> 00:01:41,360
so the server should learn this the user

38
00:01:41,360 --> 00:01:43,200
should learn this inner product together

39
00:01:43,200 --> 00:01:45,200
with some differentially private noise

40
00:01:45,200 --> 00:01:46,159
added

41
00:01:46,159 --> 00:01:48,159
epsilon

42
00:01:48,159 --> 00:01:49,840
and in particular nothing more should be

43
00:01:49,840 --> 00:01:51,439
learned by the user

44
00:01:51,439 --> 00:01:53,280
nor should anything extra be learned by

45
00:01:53,280 --> 00:01:55,840
the server

46
00:01:57,280 --> 00:01:59,600
so as we noted the functionality we want

47
00:01:59,600 --> 00:02:01,200
is the user should learn the dot product

48
00:02:01,200 --> 00:02:03,439
of weights perhaps with noise added for

49
00:02:03,439 --> 00:02:07,119
ids in the intersection of x and y

50
00:02:07,119 --> 00:02:08,720
and furthermore we want the user's

51
00:02:08,720 --> 00:02:11,280
communication competition cost to be

52
00:02:11,280 --> 00:02:13,520
nearly linear in the size of its own

53
00:02:13,520 --> 00:02:15,440
data set

54
00:02:15,440 --> 00:02:18,000
in particular it should grow very slowly

55
00:02:18,000 --> 00:02:20,000
with the server's data set size and

56
00:02:20,000 --> 00:02:21,599
that's what this tilde means and the

57
00:02:21,599 --> 00:02:23,280
assumption is that the user set is much

58
00:02:23,280 --> 00:02:26,959
smaller than the server's data set

59
00:02:26,959 --> 00:02:28,879
in terms of privacy what we want is that

60
00:02:28,879 --> 00:02:31,599
each party's input should remain hidden

61
00:02:31,599 --> 00:02:33,680
we also want that the elements of x

62
00:02:33,680 --> 00:02:35,840
intersection y should remain hidden and

63
00:02:35,840 --> 00:02:39,280
this is which ids were in common

64
00:02:39,280 --> 00:02:41,599
we may further want that the size of the

65
00:02:41,599 --> 00:02:43,440
intersection should remain hidden which

66
00:02:43,440 --> 00:02:45,920
is a number of ids that were in common

67
00:02:45,920 --> 00:02:48,400
but we assume that the sizes of the

68
00:02:48,400 --> 00:02:51,280
inputs size of x and size of y are okay

69
00:02:51,280 --> 00:02:54,319
to reveal to each of the bodies

70
00:02:54,319 --> 00:02:56,560
and this leakage can be mitigated by

71
00:02:56,560 --> 00:03:00,000
adding the inputs on either side

72
00:03:00,000 --> 00:03:02,800
with random ids

73
00:03:02,800 --> 00:03:04,319
so why do we care about this problem

74
00:03:04,319 --> 00:03:06,159
let's look at a couple of hypothetical

75
00:03:06,159 --> 00:03:09,200
applications so the first uh application

76
00:03:09,200 --> 00:03:11,120
we could think of is for exposure

77
00:03:11,120 --> 00:03:12,400
notification

78
00:03:12,400 --> 00:03:13,440
where the

79
00:03:13,440 --> 00:03:15,760
data held by the user could be thought

80
00:03:15,760 --> 00:03:16,959
of as

81
00:03:16,959 --> 00:03:20,000
the bluetooth ids of devices the user

82
00:03:20,000 --> 00:03:22,480
has been in proximity with

83
00:03:22,480 --> 00:03:23,519
and the

84
00:03:23,519 --> 00:03:25,760
values associated with each id could be

85
00:03:25,760 --> 00:03:28,480
how close the user was to that

86
00:03:28,480 --> 00:03:30,879
other bluetooth id

87
00:03:30,879 --> 00:03:32,480
for example and how long they may have

88
00:03:32,480 --> 00:03:35,519
spent in proximity

89
00:03:35,519 --> 00:03:37,120
and on the server side you could think

90
00:03:37,120 --> 00:03:39,120
of the servers holding a data set of all

91
00:03:39,120 --> 00:03:42,720
the users who reported being uh infected

92
00:03:42,720 --> 00:03:45,680
with a particular disease say covid19

93
00:03:45,680 --> 00:03:49,120
and the weight could represent the

94
00:03:49,120 --> 00:03:51,200
you know variance of that user on a

95
00:03:51,200 --> 00:03:53,200
particular day

96
00:03:53,200 --> 00:03:54,879
so for example there could be one row

97
00:03:54,879 --> 00:03:58,319
for each user day here

98
00:03:58,400 --> 00:04:00,480
and so the output of an inner join

99
00:04:00,480 --> 00:04:02,319
private joint compute in this setting

100
00:04:02,319 --> 00:04:03,680
would be

101
00:04:03,680 --> 00:04:06,959
uh for those users who the user was for

102
00:04:06,959 --> 00:04:09,040
those id so the user was in close

103
00:04:09,040 --> 00:04:11,439
contact with it read the product of the

104
00:04:11,439 --> 00:04:13,200
proximity rate and the virulence weight

105
00:04:13,200 --> 00:04:15,439
which could gives in some sense how

106
00:04:15,439 --> 00:04:17,759
likely the user was to be infected

107
00:04:17,759 --> 00:04:20,639
and uh potentially with some noise added

108
00:04:20,639 --> 00:04:22,639
so this you could use this kind of inner

109
00:04:22,639 --> 00:04:26,880
joint pj and c in order to uh

110
00:04:26,880 --> 00:04:30,800
to achieve an exposure notification

111
00:04:30,800 --> 00:04:32,560
to do this kind of exposure notification

112
00:04:32,560 --> 00:04:34,240
computation and obviously privacy is

113
00:04:34,240 --> 00:04:36,560
important here

114
00:04:36,560 --> 00:04:39,040
uh basically you could show an alert if

115
00:04:39,040 --> 00:04:39,919
the

116
00:04:39,919 --> 00:04:42,240
value here is above some threshold for

117
00:04:42,240 --> 00:04:44,639
example

118
00:04:44,960 --> 00:04:46,880
another potential application is to

119
00:04:46,880 --> 00:04:49,520
measure ad effectiveness so on one hand

120
00:04:49,520 --> 00:04:51,600
you could have the user being a merchant

121
00:04:51,600 --> 00:04:54,080
with a bunch of ids corresponding to

122
00:04:54,080 --> 00:04:55,759
users

123
00:04:55,759 --> 00:04:58,479
bought some particular type of item and

124
00:04:58,479 --> 00:05:01,520
the values being the spend values

125
00:05:01,520 --> 00:05:04,240
and on the server side you could have

126
00:05:04,240 --> 00:05:06,240
a server holding a whole bunch of user

127
00:05:06,240 --> 00:05:08,880
ids corresponding to users who've seen

128
00:05:08,880 --> 00:05:11,680
an ad for a particular

129
00:05:11,680 --> 00:05:13,360
campaign

130
00:05:13,360 --> 00:05:15,600
let's say a shoe ad

131
00:05:15,600 --> 00:05:17,600
and the weights could correspond to the

132
00:05:17,600 --> 00:05:20,479
time decayed effect of that ad so this

133
00:05:20,479 --> 00:05:22,400
is assuming that both the merchant and

134
00:05:22,400 --> 00:05:24,479
the ad tech company have fixed a

135
00:05:24,479 --> 00:05:26,320
particular date on which they want to do

136
00:05:26,320 --> 00:05:28,400
a measurement and the merchant is only

137
00:05:28,400 --> 00:05:30,160
using transactions for that particular

138
00:05:30,160 --> 00:05:32,479
date

139
00:05:32,720 --> 00:05:34,720
and so what you could want to

140
00:05:34,720 --> 00:05:37,039
compute is the weighted conversion

141
00:05:37,039 --> 00:05:39,360
credit that should be given to the ad

142
00:05:39,360 --> 00:05:41,199
tech company for showing ads to these

143
00:05:41,199 --> 00:05:43,600
users where conversion is basically

144
00:05:43,600 --> 00:05:45,360
somebody seeing an ad and then going and

145
00:05:45,360 --> 00:05:47,919
buying that thing

146
00:05:47,919 --> 00:05:50,320
so in this case the uh this graded

147
00:05:50,320 --> 00:05:52,960
conversion credit you could uh do a

148
00:05:52,960 --> 00:05:55,199
computer for example by taking the spend

149
00:05:55,199 --> 00:05:57,120
value and multiplying it by

150
00:05:57,120 --> 00:05:59,120
a time decayed ad effect for a

151
00:05:59,120 --> 00:06:01,840
particular user who both saw an ad and

152
00:06:01,840 --> 00:06:04,319
bought something

153
00:06:04,319 --> 00:06:06,000
so in this case the interjoint private

154
00:06:06,000 --> 00:06:08,479
joint compute could basically uh compute

155
00:06:08,479 --> 00:06:11,520
like the total uh value

156
00:06:11,520 --> 00:06:13,199
uh spent by

157
00:06:13,199 --> 00:06:14,960
users um

158
00:06:14,960 --> 00:06:17,440
who had also seen ads and proportionally

159
00:06:17,440 --> 00:06:20,000
decayed based on how long it had been

160
00:06:20,000 --> 00:06:23,280
since that user had seen it

161
00:06:23,280 --> 00:06:25,120
so clearly privacy is important here and

162
00:06:25,120 --> 00:06:26,479
would be

163
00:06:26,479 --> 00:06:27,759
you know neither party would want to

164
00:06:27,759 --> 00:06:29,520
reveal to each other but might be

165
00:06:29,520 --> 00:06:33,039
happy revealing the aggregates

166
00:06:33,680 --> 00:06:35,360
so uh

167
00:06:35,360 --> 00:06:36,960
basically our approach to solving this

168
00:06:36,960 --> 00:06:38,960
problem is to build a secure multi-party

169
00:06:38,960 --> 00:06:41,280
computation protocol

170
00:06:41,280 --> 00:06:43,360
by tailored for computing inner join

171
00:06:43,360 --> 00:06:45,039
private join and compute

172
00:06:45,039 --> 00:06:49,840
and focusing on asymmetric input sizes

173
00:06:50,400 --> 00:06:51,360
so

174
00:06:51,360 --> 00:06:52,720
what are the properties we want from

175
00:06:52,720 --> 00:06:54,240
this as we mentioned before we want to

176
00:06:54,240 --> 00:06:56,000
hide the particular items that are

177
00:06:56,000 --> 00:06:58,400
uncommon between the user and the server

178
00:06:58,400 --> 00:07:00,880
hide the size of the intersection

179
00:07:00,880 --> 00:07:02,800
be able to compute the inner products on

180
00:07:02,800 --> 00:07:04,160
the associated values in the

181
00:07:04,160 --> 00:07:06,319
intersection and we want the user class

182
00:07:06,319 --> 00:07:07,440
to be

183
00:07:07,440 --> 00:07:09,919
nearly linear in only its input size and

184
00:07:09,919 --> 00:07:11,680
relatively independent of the server's

185
00:07:11,680 --> 00:07:14,240
input size

186
00:07:14,639 --> 00:07:16,880
so the private joinery compute protocol

187
00:07:16,880 --> 00:07:19,120
as designed by google and described in

188
00:07:19,120 --> 00:07:21,360
this blog post

189
00:07:21,360 --> 00:07:23,840
achieves the first and third property

190
00:07:23,840 --> 00:07:27,199
but uh it reveals the intersection size

191
00:07:27,199 --> 00:07:29,599
and furthermore the user cost is linear

192
00:07:29,599 --> 00:07:32,479
in the size of both its and the service

193
00:07:32,479 --> 00:07:34,960
data set

194
00:07:35,280 --> 00:07:37,199
now there's another technology known as

195
00:07:37,199 --> 00:07:39,360
private information retrieval

196
00:07:39,360 --> 00:07:41,280
which basically is very well tailored to

197
00:07:41,280 --> 00:07:43,440
asymmetric data set sizes and in fact

198
00:07:43,440 --> 00:07:45,199
you can build inner join private join

199
00:07:45,199 --> 00:07:47,039
compute from private information

200
00:07:47,039 --> 00:07:49,280
retrieval basically by using it as a

201
00:07:49,280 --> 00:07:51,680
private set intersection protocol

202
00:07:51,680 --> 00:07:53,680
and so if you do so

203
00:07:53,680 --> 00:07:54,800
you would

204
00:07:54,800 --> 00:07:56,560
the basic way you would use private

205
00:07:56,560 --> 00:07:58,080
information retrieval to build private

206
00:07:58,080 --> 00:08:01,120
set intersection reveals the items

207
00:08:01,120 --> 00:08:03,280
particular items in the intersection and

208
00:08:03,280 --> 00:08:06,240
it reveals the intersection size

209
00:08:06,240 --> 00:08:08,160
but given that it

210
00:08:08,160 --> 00:08:10,240
allows computation on the intersection

211
00:08:10,240 --> 00:08:13,199
and also um has user costs that's

212
00:08:13,199 --> 00:08:16,319
proportional to only the that's almost

213
00:08:16,319 --> 00:08:20,400
linear in the smaller data set

214
00:08:20,879 --> 00:08:23,120
on the other hand there's a very nice

215
00:08:23,120 --> 00:08:25,039
work uh

216
00:08:25,039 --> 00:08:27,120
based on called circuit psi which uses

217
00:08:27,120 --> 00:08:29,759
carbon circuits in order to do a private

218
00:08:29,759 --> 00:08:31,120
set intersection

219
00:08:31,120 --> 00:08:33,440
and in this case you can get all of the

220
00:08:33,440 --> 00:08:34,958
first three properties that means you

221
00:08:34,958 --> 00:08:36,719
can hide the intersection the size of

222
00:08:36,719 --> 00:08:38,640
the intersection and compute arbitrary

223
00:08:38,640 --> 00:08:40,958
functions on the intersection including

224
00:08:40,958 --> 00:08:43,598
dot products

225
00:08:43,679 --> 00:08:46,880
but uh again encourage cost linear or

226
00:08:46,880 --> 00:08:49,040
like slightly more than linear in both

227
00:08:49,040 --> 00:08:52,640
of the two parties as data sets

228
00:08:52,959 --> 00:08:54,800
and so in our work we get all four of

229
00:08:54,800 --> 00:08:57,040
these properties

230
00:08:57,040 --> 00:08:58,560
and basically our approach is going to

231
00:08:58,560 --> 00:09:00,560
be to use some kind of private

232
00:09:00,560 --> 00:09:03,040
information which we will

233
00:09:03,040 --> 00:09:04,560
and

234
00:09:04,560 --> 00:09:06,640
i'd just like to note here that our this

235
00:09:06,640 --> 00:09:08,640
setting is actually also addressed by

236
00:09:08,640 --> 00:09:12,640
this work uh by uh chen pong uh lane and

237
00:09:12,640 --> 00:09:13,680
randall

238
00:09:13,680 --> 00:09:16,560
um which also does a kind of asymmetric

239
00:09:16,560 --> 00:09:18,800
private set intersection and allows

240
00:09:18,800 --> 00:09:21,200
computing over the intersection though

241
00:09:21,200 --> 00:09:23,279
their work differs from mars in several

242
00:09:23,279 --> 00:09:25,440
important ways and for a more detailed

243
00:09:25,440 --> 00:09:28,080
comparison uh please do refer to the

244
00:09:28,080 --> 00:09:31,120
full version of the paper

245
00:09:32,080 --> 00:09:34,560
so with that let's jump into how our

246
00:09:34,560 --> 00:09:37,839
construction works

247
00:09:37,839 --> 00:09:40,640
so at first i'll give an overview of the

248
00:09:40,640 --> 00:09:42,560
pieces that go into building inner joint

249
00:09:42,560 --> 00:09:45,680
private joint compute

250
00:09:46,080 --> 00:09:47,839
and so what we're going to do here is

251
00:09:47,839 --> 00:09:49,440
we're going to start from a private

252
00:09:49,440 --> 00:09:52,560
information retrieval protocol

253
00:09:52,560 --> 00:09:55,680
so in private information retrieval a

254
00:09:55,680 --> 00:09:58,640
user has a particular index i

255
00:09:58,640 --> 00:10:00,480
and the server has a database consisting

256
00:10:00,480 --> 00:10:01,839
of many

257
00:10:01,839 --> 00:10:03,360
identifiers

258
00:10:03,360 --> 00:10:06,480
and basically what it pure allows the

259
00:10:06,480 --> 00:10:09,040
user to do is to retrieve that

260
00:10:09,040 --> 00:10:12,880
index value from the server

261
00:10:13,600 --> 00:10:15,040
so the first thing we want to do is

262
00:10:15,040 --> 00:10:17,519
actually to use a variant of pair called

263
00:10:17,519 --> 00:10:19,760
keyword here where the user instead of

264
00:10:19,760 --> 00:10:22,800
having an index now has a keyword x

265
00:10:22,800 --> 00:10:25,839
and the server has key value pairs y and

266
00:10:25,839 --> 00:10:27,920
w

267
00:10:27,920 --> 00:10:31,680
and keyword pure now allows the user to

268
00:10:31,680 --> 00:10:33,680
basically query this keyword and

269
00:10:33,680 --> 00:10:35,920
retrieve w of x

270
00:10:35,920 --> 00:10:38,480
if x is in y

271
00:10:38,480 --> 00:10:40,959
or otherwise retrieve garbage so the

272
00:10:40,959 --> 00:10:42,320
first thing we're going to do is start

273
00:10:42,320 --> 00:10:46,040
with the keyword piercing

274
00:10:46,160 --> 00:10:47,680
and the next thing we're going to do is

275
00:10:47,680 --> 00:10:50,480
modify this keyword pure scheme so that

276
00:10:50,480 --> 00:10:52,560
instead of getting garbage when x is not

277
00:10:52,560 --> 00:10:54,000
in y

278
00:10:54,000 --> 00:10:55,920
instead the user will retrieve some

279
00:10:55,920 --> 00:10:58,800
prescribed default value from the server

280
00:10:58,800 --> 00:11:01,040
without revealing to the server that a

281
00:11:01,040 --> 00:11:04,480
default value was received

282
00:11:04,880 --> 00:11:07,200
and note that in normal peer schemes i

283
00:11:07,200 --> 00:11:09,440
didn't say this before but pure schemes

284
00:11:09,440 --> 00:11:11,200
don't reveal to the server what the

285
00:11:11,200 --> 00:11:14,399
client was very and that's also the case

286
00:11:14,399 --> 00:11:16,160
in what we're going to call purely

287
00:11:16,160 --> 00:11:18,640
default

288
00:11:19,360 --> 00:11:21,760
uh so basically the client square is on

289
00:11:21,760 --> 00:11:23,600
x and the difference from keyword pairs

290
00:11:23,600 --> 00:11:24,560
instead of

291
00:11:24,560 --> 00:11:26,320
receiving garbage when the client

292
00:11:26,320 --> 00:11:28,720
doesn't when x is not in y the client

293
00:11:28,720 --> 00:11:31,600
will instead receive a server chosen

294
00:11:31,600 --> 00:11:34,240
default value

295
00:11:34,240 --> 00:11:36,240
so we're going to keep pure defaults

296
00:11:36,240 --> 00:11:37,760
from keyword peer

297
00:11:37,760 --> 00:11:39,200
and in fact we're going to do something

298
00:11:39,200 --> 00:11:40,959
more which is we're going to allow the

299
00:11:40,959 --> 00:11:43,440
client to have a value v

300
00:11:43,440 --> 00:11:45,120
and what's going to happen is the client

301
00:11:45,120 --> 00:11:47,360
is either going to retrieve

302
00:11:47,360 --> 00:11:50,000
v times w of x

303
00:11:50,000 --> 00:11:51,839
in case x is in y

304
00:11:51,839 --> 00:11:53,680
or otherwise it's going to retrieve the

305
00:11:53,680 --> 00:11:56,800
default value t

306
00:11:56,800 --> 00:11:58,320
and we're going to introduce a further

307
00:11:58,320 --> 00:11:59,760
modification

308
00:11:59,760 --> 00:12:02,320
which is so that the client doesn't just

309
00:12:02,320 --> 00:12:03,680
retrieve these values but it will

310
00:12:03,680 --> 00:12:06,639
receive these values masked with the

311
00:12:06,639 --> 00:12:09,680
random mask chosen by the server

312
00:12:09,680 --> 00:12:13,120
and once we introduce this random mask

313
00:12:13,120 --> 00:12:15,200
we'll actually gain the property that

314
00:12:15,200 --> 00:12:18,000
the client will not be able to tell

315
00:12:18,000 --> 00:12:18,880
whether

316
00:12:18,880 --> 00:12:20,880
it received

317
00:12:20,880 --> 00:12:24,240
a v times w or whether it received the

318
00:12:24,240 --> 00:12:27,120
default value

319
00:12:27,920 --> 00:12:29,920
and so this is exactly what we're going

320
00:12:29,920 --> 00:12:32,320
to call extended period default so

321
00:12:32,320 --> 00:12:34,880
actually what our work does is it

322
00:12:34,880 --> 00:12:37,120
gives a construction for extended period

323
00:12:37,120 --> 00:12:39,760
default

324
00:12:39,760 --> 00:12:42,399
and once we have this extended period

325
00:12:42,399 --> 00:12:44,560
default we can use this to build inner

326
00:12:44,560 --> 00:12:46,399
join private joining compute in a

327
00:12:46,399 --> 00:12:48,480
straightforward way

328
00:12:48,480 --> 00:12:50,560
so just to pause here what extended

329
00:12:50,560 --> 00:12:53,040
period default is doing is the client is

330
00:12:53,040 --> 00:12:54,800
a key value pair

331
00:12:54,800 --> 00:12:57,279
and the server has many key value pairs

332
00:12:57,279 --> 00:12:59,839
and the client is able to retrieve

333
00:12:59,839 --> 00:13:01,440
either

334
00:13:01,440 --> 00:13:03,600
the mass product of the values the

335
00:13:03,600 --> 00:13:05,200
associated values

336
00:13:05,200 --> 00:13:08,000
if x is in the server's data set

337
00:13:08,000 --> 00:13:10,320
or it will receive a massed default

338
00:13:10,320 --> 00:13:12,800
value if x is not in the service data

339
00:13:12,800 --> 00:13:14,959
set

340
00:13:15,440 --> 00:13:17,200
and so what we're going to do to build

341
00:13:17,200 --> 00:13:18,880
inner join private joint compute from

342
00:13:18,880 --> 00:13:22,480
this is now recall the user has

343
00:13:22,480 --> 00:13:24,399
many different key value pairs and so

344
00:13:24,399 --> 00:13:27,200
does the server

345
00:13:27,360 --> 00:13:30,320
the user is going to execute extended

346
00:13:30,320 --> 00:13:33,360
period defaults on each of its inputs x

347
00:13:33,360 --> 00:13:34,720
i and vi

348
00:13:34,720 --> 00:13:37,519
with the server using the default value

349
00:13:37,519 --> 00:13:38,720
0

350
00:13:38,720 --> 00:13:42,560
and a different random mask each time

351
00:13:42,560 --> 00:13:45,199
so note that in each of these executions

352
00:13:45,199 --> 00:13:47,920
the user will either receive the product

353
00:13:47,920 --> 00:13:50,880
of v i times w i

354
00:13:50,880 --> 00:13:53,120
mass with a different mask or it will

355
00:13:53,120 --> 00:13:54,720
receive

356
00:13:54,720 --> 00:13:58,240
zero mass with that same mass

357
00:13:58,240 --> 00:13:59,680
and this will happen for each of its

358
00:13:59,680 --> 00:14:03,239
different xivs

359
00:14:03,519 --> 00:14:06,000
then the user will simply sum together

360
00:14:06,000 --> 00:14:07,600
all the outputs that's received from

361
00:14:07,600 --> 00:14:12,160
each execution to get a value t

362
00:14:12,639 --> 00:14:15,040
and the server will sum together all the

363
00:14:15,040 --> 00:14:17,120
masks it used in each of these

364
00:14:17,120 --> 00:14:18,639
executions

365
00:14:18,639 --> 00:14:21,199
and send these over to the user together

366
00:14:21,199 --> 00:14:24,240
with some noise added epsilon and this

367
00:14:24,240 --> 00:14:25,600
noise is going to be for differential

368
00:14:25,600 --> 00:14:27,680
privacy

369
00:14:27,680 --> 00:14:30,160
and the user is now going to subtract

370
00:14:30,160 --> 00:14:31,920
the sum of the masks that the server

371
00:14:31,920 --> 00:14:34,079
provided from the sum of the values are

372
00:14:34,079 --> 00:14:37,279
retrieved in step one

373
00:14:37,279 --> 00:14:39,519
and this it turns out is exactly going

374
00:14:39,519 --> 00:14:42,560
to be the noisy inner product

375
00:14:42,560 --> 00:14:45,839
as we needed

376
00:14:46,560 --> 00:14:48,399
and so this is how we would build inner

377
00:14:48,399 --> 00:14:50,320
joint paragraph compute from extended

378
00:14:50,320 --> 00:14:52,160
period default and this is going to be

379
00:14:52,160 --> 00:14:55,279
our solution strategy

380
00:14:55,680 --> 00:14:57,920
and so given this now the question is

381
00:14:57,920 --> 00:14:59,920
how do we build this extended peer

382
00:14:59,920 --> 00:15:01,920
retail and that's what we'll be going

383
00:15:01,920 --> 00:15:04,479
into next

384
00:15:05,120 --> 00:15:07,040
so again our starting point is going to

385
00:15:07,040 --> 00:15:09,920
be using a private information retrieval

386
00:15:09,920 --> 00:15:11,839
protocol

387
00:15:11,839 --> 00:15:13,760
and so in most private information

388
00:15:13,760 --> 00:15:15,680
retrieval protocols or single server

389
00:15:15,680 --> 00:15:17,440
private information retrieval protocols

390
00:15:17,440 --> 00:15:18,959
that are efficient

391
00:15:18,959 --> 00:15:22,720
uh they leverage homomorphic encryption

392
00:15:22,720 --> 00:15:24,399
and so the clients will basically

393
00:15:24,399 --> 00:15:26,560
encrypt the index i for which it wants

394
00:15:26,560 --> 00:15:29,920
to retrieve something from the server

395
00:15:29,920 --> 00:15:31,839
and technically you know it's not

396
00:15:31,839 --> 00:15:33,839
exactly encrypting the index i but it's

397
00:15:33,839 --> 00:15:36,079
some special encoding of i but we skip

398
00:15:36,079 --> 00:15:38,480
the details here

399
00:15:38,480 --> 00:15:40,560
and what the server does is it expands

400
00:15:40,560 --> 00:15:42,639
this into an in

401
00:15:42,639 --> 00:15:46,320
one hot vector of n values where all the

402
00:15:46,320 --> 00:15:48,639
encryptions are zero

403
00:15:48,639 --> 00:15:50,560
except in the ith position and this

404
00:15:50,560 --> 00:15:53,040
expansion is done homomorphically

405
00:15:53,040 --> 00:15:55,120
uh so the server doesn't know which

406
00:15:55,120 --> 00:15:58,959
index is zero and which index is one

407
00:15:58,959 --> 00:16:01,279
and then it executes a homomorphic dot

408
00:16:01,279 --> 00:16:03,519
product with the ciphertext with its

409
00:16:03,519 --> 00:16:06,000
data set

410
00:16:06,000 --> 00:16:08,560
and sums together the results which will

411
00:16:08,560 --> 00:16:10,079
basically give it an encryption of

412
00:16:10,079 --> 00:16:13,839
exactly y i because all the other values

413
00:16:13,839 --> 00:16:16,959
will morph with the multiplied by zero

414
00:16:16,959 --> 00:16:18,959
and this will get sent back to this to

415
00:16:18,959 --> 00:16:23,599
the client who can decrypt again why i

416
00:16:24,240 --> 00:16:26,160
and so what do we do if you have an id

417
00:16:26,160 --> 00:16:29,839
or keyword instead of an index

418
00:16:29,839 --> 00:16:31,040
so there's a couple of different

419
00:16:31,040 --> 00:16:33,199
approaches you can go in order to deal

420
00:16:33,199 --> 00:16:34,560
with a keyword

421
00:16:34,560 --> 00:16:36,639
but our approach is to use a bloom

422
00:16:36,639 --> 00:16:39,040
filter

423
00:16:39,040 --> 00:16:41,519
and what is a bloom filter just to give

424
00:16:41,519 --> 00:16:43,360
some background a bloom filter is a data

425
00:16:43,360 --> 00:16:44,320
structure

426
00:16:44,320 --> 00:16:46,639
which allows to test membership

427
00:16:46,639 --> 00:16:48,639
so suppose the server has a data set

428
00:16:48,639 --> 00:16:52,480
which consists of y 1 to y n

429
00:16:52,480 --> 00:16:54,880
it can create a bloom filter which

430
00:16:54,880 --> 00:16:57,920
consists of bits b 1 to b capital n

431
00:16:57,920 --> 00:17:02,639
where capital n is larger than little n

432
00:17:03,440 --> 00:17:05,599
and the clients can now

433
00:17:05,599 --> 00:17:09,039
uh take its value x and turn it into k

434
00:17:09,039 --> 00:17:10,160
indices

435
00:17:10,160 --> 00:17:14,079
h1x to hkx which can be computed by

436
00:17:14,079 --> 00:17:16,880
simply hashing x using k different hash

437
00:17:16,880 --> 00:17:17,839
functions

438
00:17:17,839 --> 00:17:21,280
specified by the blue filter

439
00:17:22,880 --> 00:17:25,760
and now the client can test membership

440
00:17:25,760 --> 00:17:27,919
in the boom filter by looking up the

441
00:17:27,919 --> 00:17:29,840
boom filter entries

442
00:17:29,840 --> 00:17:33,200
at each of the positions h i x

443
00:17:33,200 --> 00:17:35,039
and if all the bloom filter entries are

444
00:17:35,039 --> 00:17:35,919
one

445
00:17:35,919 --> 00:17:36,720
then

446
00:17:36,720 --> 00:17:39,760
the client can conclude that its item x

447
00:17:39,760 --> 00:17:41,440
is in the set y

448
00:17:41,440 --> 00:17:43,280
except for some negligible failure

449
00:17:43,280 --> 00:17:45,200
probability

450
00:17:45,200 --> 00:17:46,720
so this is a well they're well-known

451
00:17:46,720 --> 00:17:49,280
constructions with boom filters uh and

452
00:17:49,280 --> 00:17:54,080
it's a widely used uh primitive

453
00:17:56,000 --> 00:17:59,039
and uh just for concreteness we'll be

454
00:17:59,039 --> 00:18:01,280
using 31 hash functions

455
00:18:01,280 --> 00:18:02,880
which will give a failure probability of

456
00:18:02,880 --> 00:18:05,360
2 to the minus 40 and this will mean

457
00:18:05,360 --> 00:18:07,039
that the boom filter has an expansion of

458
00:18:07,039 --> 00:18:09,919
58 times

459
00:18:10,400 --> 00:18:12,160
and so the way we're going to do keyword

460
00:18:12,160 --> 00:18:13,039
here

461
00:18:13,039 --> 00:18:16,240
is to use a regular in

462
00:18:16,240 --> 00:18:18,559
index period as we discussed earlier

463
00:18:18,559 --> 00:18:20,480
together with the filters

464
00:18:20,480 --> 00:18:22,960
so recall that we have user and server

465
00:18:22,960 --> 00:18:25,200
with key value pairs let's just forget

466
00:18:25,200 --> 00:18:27,120
about the values for now and have the

467
00:18:27,120 --> 00:18:31,280
user just use a single keyword

468
00:18:31,280 --> 00:18:32,480
what we're going to do is have the

469
00:18:32,480 --> 00:18:34,880
server create a bloom filter out of its

470
00:18:34,880 --> 00:18:37,440
keywords

471
00:18:38,320 --> 00:18:40,240
and have the user

472
00:18:40,240 --> 00:18:41,520
send

473
00:18:41,520 --> 00:18:44,240
key encryptions one for each entry of

474
00:18:44,240 --> 00:18:45,840
the blue filter that it would need to

475
00:18:45,840 --> 00:18:49,200
look up in order to do its uh membership

476
00:18:49,200 --> 00:18:51,440
check

477
00:18:52,080 --> 00:18:54,640
and it can send these as peer queries so

478
00:18:54,640 --> 00:18:56,480
encrypted using a homomorphic encryption

479
00:18:56,480 --> 00:18:57,760
scheme

480
00:18:57,760 --> 00:18:59,840
and then the server can process each of

481
00:18:59,840 --> 00:19:02,320
these peer queries to basically get

482
00:19:02,320 --> 00:19:04,559
encryptions off those particular bits in

483
00:19:04,559 --> 00:19:06,240
the bloom filter

484
00:19:06,240 --> 00:19:08,000
corresponding to the indices that the

485
00:19:08,000 --> 00:19:11,120
clients had sent

486
00:19:11,120 --> 00:19:13,440
and then it can homomorphically sum the

487
00:19:13,440 --> 00:19:14,720
responses

488
00:19:14,720 --> 00:19:17,039
to get the sum of all those blue filter

489
00:19:17,039 --> 00:19:18,720
bits

490
00:19:18,720 --> 00:19:22,160
and add a random mask r2

491
00:19:22,160 --> 00:19:24,320
and send it to the client

492
00:19:24,320 --> 00:19:27,120
and the client can decrypt and subtract

493
00:19:27,120 --> 00:19:28,799
k where k is the number of hash

494
00:19:28,799 --> 00:19:30,799
functions that were in the blue filter

495
00:19:30,799 --> 00:19:34,639
and therefore gets r1

496
00:19:34,960 --> 00:19:38,799
and we know that r1 is equal to r2 if

497
00:19:38,799 --> 00:19:41,280
and only if x is in y

498
00:19:41,280 --> 00:19:43,200
and this is because r1 will be equal to

499
00:19:43,200 --> 00:19:46,880
r2 precisely when all the bits

500
00:19:46,880 --> 00:19:49,039
b that were retrieved that would have

501
00:19:49,039 --> 00:19:50,799
been retrieved in the pure query were

502
00:19:50,799 --> 00:19:52,480
all one

503
00:19:52,480 --> 00:19:56,400
or there were cave one bits

504
00:19:57,520 --> 00:19:59,520
so this is a way to take index pair and

505
00:19:59,520 --> 00:20:02,799
turn it into keyword here

506
00:20:02,880 --> 00:20:04,480
and of course you just recall that

507
00:20:04,480 --> 00:20:06,080
there's some failure probability 2 to

508
00:20:06,080 --> 00:20:08,400
the minus 40 here

509
00:20:08,400 --> 00:20:10,720
and so suppose you have this step now

510
00:20:10,720 --> 00:20:12,480
where you have r and r 2 that are equal

511
00:20:12,480 --> 00:20:15,200
if and only if x's and y

512
00:20:15,200 --> 00:20:16,799
let's just stash these for a second

513
00:20:16,799 --> 00:20:20,240
because we're going to use them later

514
00:20:20,240 --> 00:20:21,919
and now let's think about what we're

515
00:20:21,919 --> 00:20:25,520
going to do with associated values

516
00:20:25,520 --> 00:20:27,360
and to deal with associated values we're

517
00:20:27,360 --> 00:20:29,120
going to use something called a garble

518
00:20:29,120 --> 00:20:30,720
blue filter

519
00:20:30,720 --> 00:20:34,400
and a barbell blue filter is another

520
00:20:34,400 --> 00:20:36,240
data structure is very similar to a boom

521
00:20:36,240 --> 00:20:38,159
filter where now instead of just having

522
00:20:38,159 --> 00:20:40,559
keywords a server can have key value

523
00:20:40,559 --> 00:20:41,919
pairs

524
00:20:41,919 --> 00:20:44,640
and the garble bloom filter will now be

525
00:20:44,640 --> 00:20:46,720
able to

526
00:20:46,720 --> 00:20:49,360
encode these key value pairs such that

527
00:20:49,360 --> 00:20:51,679
if a client can take its input and query

528
00:20:51,679 --> 00:20:53,280
k locations in the

529
00:20:53,280 --> 00:20:55,520
in the garble boom filter such that the

530
00:20:55,520 --> 00:20:57,039
result

531
00:20:57,039 --> 00:20:58,480
of

532
00:20:58,480 --> 00:21:00,960
adding together those k locations in the

533
00:21:00,960 --> 00:21:03,440
global boom filter will be exactly the

534
00:21:03,440 --> 00:21:05,280
associated value

535
00:21:05,280 --> 00:21:06,000
if

536
00:21:06,000 --> 00:21:08,799
x is in y

537
00:21:11,200 --> 00:21:13,679
however if x is not in y then the carbon

538
00:21:13,679 --> 00:21:15,919
bloom filter entries will sum to some

539
00:21:15,919 --> 00:21:18,640
unknown value

540
00:21:18,640 --> 00:21:21,600
which is undetermined or unspecified by

541
00:21:21,600 --> 00:21:25,039
the group filter it could be anything

542
00:21:27,039 --> 00:21:29,520
and so what this next piece for

543
00:21:29,520 --> 00:21:32,000
construction is to be to combine pure

544
00:21:32,000 --> 00:21:35,440
with global bloom filters

545
00:21:35,600 --> 00:21:37,120
and so what the server is going to do is

546
00:21:37,120 --> 00:21:38,880
make a garble bloom filter out of its

547
00:21:38,880 --> 00:21:40,640
key value pairs and now let's just think

548
00:21:40,640 --> 00:21:42,480
of the user as having a single key value

549
00:21:42,480 --> 00:21:44,640
pair x and v

550
00:21:44,640 --> 00:21:46,159
and so what the user is going to do is

551
00:21:46,159 --> 00:21:48,240
now send it again encryptions of the

552
00:21:48,240 --> 00:21:49,840
locations that wants to look up in the

553
00:21:49,840 --> 00:21:51,919
bloom filter corresponding to its input

554
00:21:51,919 --> 00:21:53,200
x

555
00:21:53,200 --> 00:21:55,600
the server is again going to process

556
00:21:55,600 --> 00:21:59,360
these encrypted indices as peer queries

557
00:21:59,360 --> 00:22:02,159
and thereby get encryptions of the

558
00:22:02,159 --> 00:22:04,240
locations at the boom filter that the

559
00:22:04,240 --> 00:22:06,799
clients wanted

560
00:22:06,799 --> 00:22:10,799
and homomorphic resume the responses

561
00:22:11,200 --> 00:22:13,360
and the user is actually also going to

562
00:22:13,360 --> 00:22:15,520
send along an encryption of the value v

563
00:22:15,520 --> 00:22:17,520
that it had

564
00:22:17,520 --> 00:22:18,640
and the server is going to

565
00:22:18,640 --> 00:22:21,440
homomorphically multiply this value v

566
00:22:21,440 --> 00:22:22,400
into

567
00:22:22,400 --> 00:22:24,240
the sum that it had computed in the

568
00:22:24,240 --> 00:22:26,400
previous step

569
00:22:26,400 --> 00:22:28,480
and furthermore it's going to

570
00:22:28,480 --> 00:22:32,240
mask this value with a random mask s2

571
00:22:32,240 --> 00:22:34,159
and send it back to the user who will

572
00:22:34,159 --> 00:22:37,520
decrypt again s1

573
00:22:37,520 --> 00:22:40,880
and note that s1 and s 2

574
00:22:40,880 --> 00:22:43,520
are additive secret shares of

575
00:22:43,520 --> 00:22:47,520
v x times w x if x is in y

576
00:22:47,520 --> 00:22:49,200
and our secret shares of something

577
00:22:49,200 --> 00:22:50,240
random

578
00:22:50,240 --> 00:22:52,640
or some garbage value otherwise some

579
00:22:52,640 --> 00:22:55,840
undetermined value

580
00:22:56,640 --> 00:22:59,039
so now from these two things what we

581
00:22:59,039 --> 00:23:00,640
have is

582
00:23:00,640 --> 00:23:02,000
if we do

583
00:23:02,000 --> 00:23:04,559
the pure query on a bloom filter and the

584
00:23:04,559 --> 00:23:06,720
clear query on the carbon blue filter

585
00:23:06,720 --> 00:23:09,120
the user will have retrieved values r1

586
00:23:09,120 --> 00:23:10,720
and s1

587
00:23:10,720 --> 00:23:13,120
and the server will have created values

588
00:23:13,120 --> 00:23:16,240
r2 and s2 with the properties that r1

589
00:23:16,240 --> 00:23:20,240
equals r2 if and only if x is in y

590
00:23:20,240 --> 00:23:23,679
and s1 and s2 are secret shares of v

591
00:23:23,679 --> 00:23:26,400
times w if x's and y

592
00:23:26,400 --> 00:23:28,240
and secret shares of some garbage value

593
00:23:28,240 --> 00:23:30,799
otherwise

594
00:23:30,880 --> 00:23:33,280
and now in order to get pure default

595
00:23:33,280 --> 00:23:34,799
what we're going to do is have the user

596
00:23:34,799 --> 00:23:37,200
and the server execute a generic mpc

597
00:23:37,200 --> 00:23:39,520
protocol

598
00:23:39,520 --> 00:23:41,440
where this generic mpc protocol will

599
00:23:41,440 --> 00:23:45,840
output secret shares t1 plus t2

600
00:23:47,360 --> 00:23:49,760
which will be

601
00:23:49,760 --> 00:23:53,039
a shares of v times w if x is in y

602
00:23:53,039 --> 00:23:56,799
and shares of zero otherwise

603
00:23:56,960 --> 00:23:58,960
and this is exactly what we wanted for

604
00:23:58,960 --> 00:24:01,679
your default and note that this generic

605
00:24:01,679 --> 00:24:04,240
mpc protocol now only needs to take as

606
00:24:04,240 --> 00:24:05,360
input

607
00:24:05,360 --> 00:24:09,520
these values r1 s1 r2 and s2

608
00:24:09,520 --> 00:24:12,000
and does not depend on the size of the

609
00:24:12,000 --> 00:24:14,799
service data set

610
00:24:16,960 --> 00:24:19,919
uh and in fact it's easy to modify this

611
00:24:19,919 --> 00:24:21,919
to make it so that the server can

612
00:24:21,919 --> 00:24:24,400
specify a default value

613
00:24:24,400 --> 00:24:27,360
such that instead of the t1 plus t2

614
00:24:27,360 --> 00:24:30,240
adding up to zero the instead add up to

615
00:24:30,240 --> 00:24:34,480
the server specified default value

616
00:24:35,360 --> 00:24:37,760
and this is exactly the crux of our

617
00:24:37,760 --> 00:24:39,840
construction and note that the generic

618
00:24:39,840 --> 00:24:42,159
mpc protocol can be any generic npc

619
00:24:42,159 --> 00:24:45,120
protocol but we specifically use a

620
00:24:45,120 --> 00:24:48,559
carpel circuit-based protocol

621
00:24:49,840 --> 00:24:51,919
and our construction also has several

622
00:24:51,919 --> 00:24:53,600
optimizations

623
00:24:53,600 --> 00:24:55,440
so note that we described everything

624
00:24:55,440 --> 00:24:58,880
just for a single key value pair

625
00:24:58,880 --> 00:25:01,679
but in fact um

626
00:25:01,679 --> 00:25:03,840
you can get huge benefits by doing

627
00:25:03,840 --> 00:25:05,919
multiple key value pair queries in

628
00:25:05,919 --> 00:25:07,120
parallel

629
00:25:07,120 --> 00:25:08,640
and this is a

630
00:25:08,640 --> 00:25:11,600
well-known technique used in here and

631
00:25:11,600 --> 00:25:13,440
keyword here

632
00:25:13,440 --> 00:25:16,640
which it uses slotting and batching of

633
00:25:16,640 --> 00:25:20,080
homomorphic encryption schemes

634
00:25:20,080 --> 00:25:21,760
and another well-known optimization

635
00:25:21,760 --> 00:25:26,320
which is the cuckoo hd inputs on the

636
00:25:26,559 --> 00:25:28,960
client side which basically is a

637
00:25:28,960 --> 00:25:32,000
standard technique that allows um

638
00:25:32,000 --> 00:25:33,360
grouping the

639
00:25:33,360 --> 00:25:35,279
inputs into smaller

640
00:25:35,279 --> 00:25:37,840
groups so that the peers are

641
00:25:37,840 --> 00:25:40,640
executed over smaller sets

642
00:25:40,640 --> 00:25:42,640
and this basically has the effect of

643
00:25:42,640 --> 00:25:44,960
inducing a huge computational savings on

644
00:25:44,960 --> 00:25:47,120
the server with some minor increase in

645
00:25:47,120 --> 00:25:50,959
the client's uh costs

646
00:25:51,279 --> 00:25:52,080
um

647
00:25:52,080 --> 00:25:53,279
i'll now

648
00:25:53,279 --> 00:25:55,039
discuss some of the experimental costs

649
00:25:55,039 --> 00:25:57,760
for our implementation of this period

650
00:25:57,760 --> 00:26:00,159
default

651
00:26:00,159 --> 00:26:01,200
um

652
00:26:01,200 --> 00:26:03,279
so in these graphs i'd like to highlight

653
00:26:03,279 --> 00:26:06,000
the communication costs so in particular

654
00:26:06,000 --> 00:26:08,799
the presentation sorry the construction

655
00:26:08,799 --> 00:26:12,080
we presented is the red line here

656
00:26:12,080 --> 00:26:15,039
uh marked as construction two

657
00:26:15,039 --> 00:26:17,919
and uh on the x-axis you have the

658
00:26:17,919 --> 00:26:20,240
database size held by the server and on

659
00:26:20,240 --> 00:26:22,799
the y-axis you have the log of the

660
00:26:22,799 --> 00:26:24,400
communication

661
00:26:24,400 --> 00:26:27,279
between the client and the server

662
00:26:27,279 --> 00:26:29,840
and t here is the number of

663
00:26:29,840 --> 00:26:31,679
queries the client makes to the server's

664
00:26:31,679 --> 00:26:33,600
data set

665
00:26:33,600 --> 00:26:35,600
and basically what this graph shows is

666
00:26:35,600 --> 00:26:36,840
that

667
00:26:36,840 --> 00:26:40,000
the communication cost grows very slowly

668
00:26:40,000 --> 00:26:41,120
as

669
00:26:41,120 --> 00:26:43,120
grossly as the service data set size

670
00:26:43,120 --> 00:26:44,480
increases which is exactly what we

671
00:26:44,480 --> 00:26:47,039
wanted and in particular comparing to

672
00:26:47,039 --> 00:26:48,559
other works uh

673
00:26:48,559 --> 00:26:51,120
existing works

674
00:26:51,120 --> 00:26:52,640
i also just wanted to highlight that

675
00:26:52,640 --> 00:26:54,480
there's actually you know the

676
00:26:54,480 --> 00:26:56,000
construction we presented is actually

677
00:26:56,000 --> 00:26:58,080
the second construction in the paper and

678
00:26:58,080 --> 00:26:59,919
there is actually a warm-up construction

679
00:26:59,919 --> 00:27:01,200
which we didn't discuss which is

680
00:27:01,200 --> 00:27:03,200
actually also very interesting

681
00:27:03,200 --> 00:27:06,400
which essentially uses a naive pier

682
00:27:06,400 --> 00:27:08,799
instead of a pure like a compressing

683
00:27:08,799 --> 00:27:10,240
here which is what we've discussed so

684
00:27:10,240 --> 00:27:11,679
far

685
00:27:11,679 --> 00:27:12,960
and it's very interesting and please do

686
00:27:12,960 --> 00:27:14,320
take a look it's in the full version of

687
00:27:14,320 --> 00:27:16,879
the paper

688
00:27:18,080 --> 00:27:19,120
next

689
00:27:19,120 --> 00:27:21,039
we also measured you know the end-to-end

690
00:27:21,039 --> 00:27:23,840
runtime and total communication

691
00:27:23,840 --> 00:27:25,520
and here i particularly like to

692
00:27:25,520 --> 00:27:28,640
highlight uh this setting which is where

693
00:27:28,640 --> 00:27:30,480
there's a large gap between the server's

694
00:27:30,480 --> 00:27:32,559
data set size and the client's data set

695
00:27:32,559 --> 00:27:34,159
size

696
00:27:34,159 --> 00:27:35,520
and here we can see that our

697
00:27:35,520 --> 00:27:37,760
communication costs in particular

698
00:27:37,760 --> 00:27:38,559
are

699
00:27:38,559 --> 00:27:41,440
quite a bit smaller than existing works

700
00:27:41,440 --> 00:27:43,520
and this is exactly what we

701
00:27:43,520 --> 00:27:45,520
were aiming for but note that our

702
00:27:45,520 --> 00:27:48,480
computation costs are quite a bit higher

703
00:27:48,480 --> 00:27:50,480
and so a natural question is how would

704
00:27:50,480 --> 00:27:52,480
we justify this larger

705
00:27:52,480 --> 00:27:54,399
uh computation cost

706
00:27:54,399 --> 00:27:56,640
well because of that we looked at total

707
00:27:56,640 --> 00:27:58,080
monetary costs

708
00:27:58,080 --> 00:27:59,279
that is the cost that we're being

709
00:27:59,279 --> 00:28:00,840
curative here and

710
00:28:00,840 --> 00:28:04,080
this protocol over gcp

711
00:28:04,080 --> 00:28:06,640
and in particular again looking at this

712
00:28:06,640 --> 00:28:08,480
sector where there's a large gap between

713
00:28:08,480 --> 00:28:09,840
the client and server communication

714
00:28:09,840 --> 00:28:12,159
costs we can see that specifically for

715
00:28:12,159 --> 00:28:15,440
the clients the costs are a lot lower

716
00:28:15,440 --> 00:28:17,760
uh than in other works like other works

717
00:28:17,760 --> 00:28:20,080
in uh incur equal cost for a cliented

718
00:28:20,080 --> 00:28:21,760
server

719
00:28:21,760 --> 00:28:24,559
but uh basically our protocol offloads a

720
00:28:24,559 --> 00:28:27,520
lot of the monetary costs to the server

721
00:28:27,520 --> 00:28:29,600
and in fact if you look at the total

722
00:28:29,600 --> 00:28:31,919
costs our total costs are higher than

723
00:28:31,919 --> 00:28:33,200
existing works

724
00:28:33,200 --> 00:28:35,840
but um moderately higher

725
00:28:35,840 --> 00:28:38,159
um so they're still like somewhat

726
00:28:38,159 --> 00:28:40,720
competitive

727
00:28:40,799 --> 00:28:42,399
but we have the huge benefit that the

728
00:28:42,399 --> 00:28:45,279
client does not incur

729
00:28:45,279 --> 00:28:48,480
as much cost as a server

730
00:28:48,880 --> 00:28:50,960
so now briefly discuss ways that our

731
00:28:50,960 --> 00:28:54,000
protocol can be extended

732
00:28:54,000 --> 00:28:57,120
the first is that we can

733
00:28:57,120 --> 00:28:58,960
we so far discussed the inner join

734
00:28:58,960 --> 00:29:01,120
functionality between the two data sets

735
00:29:01,120 --> 00:29:04,080
interjoin dot product

736
00:29:04,080 --> 00:29:07,200
but in fact we can easily support any uh

737
00:29:07,200 --> 00:29:09,600
other function f which is supported by

738
00:29:09,600 --> 00:29:12,159
the homomorphic encryption scheme uh

739
00:29:12,159 --> 00:29:13,760
underlying the period defaults

740
00:29:13,760 --> 00:29:17,279
construction that we described

741
00:29:19,039 --> 00:29:22,159
and furthermore uh

742
00:29:22,159 --> 00:29:25,200
instead of just doing sums

743
00:29:25,200 --> 00:29:29,520
so here we had the sum of uh values f of

744
00:29:29,520 --> 00:29:30,960
you know the two associated values

745
00:29:30,960 --> 00:29:32,640
associated with x

746
00:29:32,640 --> 00:29:34,480
but in fact instead of sums we could do

747
00:29:34,480 --> 00:29:36,960
any computation g

748
00:29:36,960 --> 00:29:39,440
over these values where g is anything

749
00:29:39,440 --> 00:29:42,640
supported by a secret sharing scheme

750
00:29:42,640 --> 00:29:44,880
and in particular you know uh over

751
00:29:44,880 --> 00:29:48,000
secret shares you can compute any uh

752
00:29:48,000 --> 00:29:50,240
any function using generic mpc protocol

753
00:29:50,240 --> 00:29:52,799
so in fact you can do any gp if you want

754
00:29:52,799 --> 00:29:55,200
wanted

755
00:29:55,200 --> 00:29:57,279
so that's all i wanted to present and

756
00:29:57,279 --> 00:29:59,679
thank you and please feel free to reach

757
00:29:59,679 --> 00:30:01,440
out to me or any of the other co-authors

758
00:30:01,440 --> 00:30:02,960
if you have questions

759
00:30:02,960 --> 00:30:06,120
thank you

760
00:30:08,480 --> 00:30:10,880
uh so now briefly discuss ways that our

761
00:30:10,880 --> 00:30:13,440
protocol can be extended

762
00:30:13,440 --> 00:30:17,039
uh the first is that we can uh

763
00:30:17,039 --> 00:30:18,799
we so far discussed the inner join

764
00:30:18,799 --> 00:30:21,279
functionality between the two data sets

765
00:30:21,279 --> 00:30:24,000
join innerjoin.product

766
00:30:24,000 --> 00:30:27,120
but in fact we can easily support any uh

767
00:30:27,120 --> 00:30:29,520
other function f which is supported by

768
00:30:29,520 --> 00:30:31,760
the homomorphic encryption scheme

769
00:30:31,760 --> 00:30:33,679
uh underlying the pyramid defaults

770
00:30:33,679 --> 00:30:37,720
construction that we described

771
00:30:38,159 --> 00:30:42,000
uh and furthermore uh

772
00:30:42,000 --> 00:30:45,039
instead of just doing sums

773
00:30:45,039 --> 00:30:49,440
so here we had the sum of uh values f of

774
00:30:49,440 --> 00:30:50,799
you know the two associated values

775
00:30:50,799 --> 00:30:52,559
associated with x

776
00:30:52,559 --> 00:30:54,399
but in fact instead of sums we could do

777
00:30:54,399 --> 00:30:56,880
any computation g

778
00:30:56,880 --> 00:30:59,360
over these values where g is anything

779
00:30:59,360 --> 00:31:02,480
supported by a secret sharing scheme

780
00:31:02,480 --> 00:31:04,799
and in particular you know uh over

781
00:31:04,799 --> 00:31:07,919
secret shares you can compute any uh

782
00:31:07,919 --> 00:31:10,159
any function using generic npc protocol

783
00:31:10,159 --> 00:31:12,720
so in fact you can do any gp if you

784
00:31:12,720 --> 00:31:15,039
wanted

785
00:31:15,039 --> 00:31:17,120
so that's all i wanted to present and

786
00:31:17,120 --> 00:31:19,600
thank you and please feel free to reach

787
00:31:19,600 --> 00:31:21,279
out to me or any of the other co-authors

788
00:31:21,279 --> 00:31:22,880
if you have questions

789
00:31:22,880 --> 00:31:26,039
thank you

790
00:31:44,640 --> 00:31:46,720
you

