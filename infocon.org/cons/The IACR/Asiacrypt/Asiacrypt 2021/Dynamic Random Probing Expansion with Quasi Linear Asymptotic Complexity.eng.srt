1
00:00:00,560 --> 00:00:03,120
hi everyone i'm abdel and today i'll be

2
00:00:03,120 --> 00:00:05,279
presenting our work dynamic random

3
00:00:05,279 --> 00:00:07,200
probing expansion with kazi linear

4
00:00:07,200 --> 00:00:09,200
asymptotic complexity

5
00:00:09,200 --> 00:00:11,120
and this is the joint work with sonya

6
00:00:11,120 --> 00:00:15,719
bellaid maturiba and damian vanu

7
00:00:16,160 --> 00:00:18,000
in this work we reason about the

8
00:00:18,000 --> 00:00:20,720
security of implementations against side

9
00:00:20,720 --> 00:00:22,080
channel attacks

10
00:00:22,080 --> 00:00:24,080
and so these attacks derive information

11
00:00:24,080 --> 00:00:26,080
about the secret from measurements such

12
00:00:26,080 --> 00:00:28,240
as power consumption or electromagnetic

13
00:00:28,240 --> 00:00:31,119
magnetic radiations for instance

14
00:00:31,119 --> 00:00:32,960
and so the most deployed countermeasure

15
00:00:32,960 --> 00:00:35,760
against this class of attacks is what we

16
00:00:35,760 --> 00:00:37,760
call the masking scheme

17
00:00:37,760 --> 00:00:39,920
so the idea is to split a sensitive

18
00:00:39,920 --> 00:00:42,559
variable into n values that we call

19
00:00:42,559 --> 00:00:43,520
shares

20
00:00:43,520 --> 00:00:46,000
and their recombination should give us

21
00:00:46,000 --> 00:00:48,160
the original secret

22
00:00:48,160 --> 00:00:50,079
this actually helps to break the

23
00:00:50,079 --> 00:00:52,800
dependence with the any set of n minus

24
00:00:52,800 --> 00:00:54,879
one shares making it difficult to

25
00:00:54,879 --> 00:00:57,039
recover the secret as the value of n

26
00:00:57,039 --> 00:00:58,800
grows

27
00:00:58,800 --> 00:01:00,320
but so when working with masked

28
00:01:00,320 --> 00:01:03,359
implementations regular operations of

29
00:01:03,359 --> 00:01:05,680
addition multiplication or copy over the

30
00:01:05,680 --> 00:01:08,240
field are not enough anymore

31
00:01:08,240 --> 00:01:10,240
so we actually need some building blocks

32
00:01:10,240 --> 00:01:12,880
which perform these operations but over

33
00:01:12,880 --> 00:01:14,720
and share variables

34
00:01:14,720 --> 00:01:17,759
and so this replaces each gate in the

35
00:01:17,759 --> 00:01:20,240
field by a functionally equivalent and

36
00:01:20,240 --> 00:01:23,119
share circuit that we call a gadget

37
00:01:23,119 --> 00:01:24,240
and so

38
00:01:24,240 --> 00:01:26,720
we add a new gadget which we call

39
00:01:26,720 --> 00:01:27,920
refresh

40
00:01:27,920 --> 00:01:30,400
to produce a fresh entry copy of the

41
00:01:30,400 --> 00:01:32,560
original variable whenever we want to

42
00:01:32,560 --> 00:01:34,479
manipulate the simple the same variable

43
00:01:34,479 --> 00:01:37,119
several times

44
00:01:38,000 --> 00:01:39,840
so below you can see an example of such

45
00:01:39,840 --> 00:01:42,240
an additional gadget with two shares

46
00:01:42,240 --> 00:01:44,240
so the idea is simply to perform a

47
00:01:44,240 --> 00:01:46,320
sharewise addition and make sure that

48
00:01:46,320 --> 00:01:48,560
the sum of the output shares are equal

49
00:01:48,560 --> 00:01:52,240
to the sum of the input shares

50
00:01:53,680 --> 00:01:55,600
but so to reason about the security of

51
00:01:55,600 --> 00:01:58,079
masking schemes in theory

52
00:01:58,079 --> 00:02:00,159
the community introduced the idea of

53
00:02:00,159 --> 00:02:01,600
leakage models

54
00:02:01,600 --> 00:02:03,680
so usually we prove that a circuit is

55
00:02:03,680 --> 00:02:06,000
secure in a certain model

56
00:02:06,000 --> 00:02:08,160
if the leaking variables do not reveal

57
00:02:08,160 --> 00:02:11,200
any information about the secret values

58
00:02:11,200 --> 00:02:13,040
so these models actually differ with

59
00:02:13,040 --> 00:02:15,760
respect to their closeness to reality of

60
00:02:15,760 --> 00:02:18,000
leakage and convenience for security

61
00:02:18,000 --> 00:02:20,160
proofs

62
00:02:20,160 --> 00:02:22,640
and so the most the most widely used one

63
00:02:22,640 --> 00:02:24,640
until now is what we call the probing

64
00:02:24,640 --> 00:02:26,879
model where we consider that during an

65
00:02:26,879 --> 00:02:29,760
execution there is a fixed number of t

66
00:02:29,760 --> 00:02:31,280
leaking variables over the

67
00:02:31,280 --> 00:02:33,040
implementation

68
00:02:33,040 --> 00:02:35,360
but this model has been challenged since

69
00:02:35,360 --> 00:02:37,040
it does not capture very well the

70
00:02:37,040 --> 00:02:38,959
reality of physical leakage due for

71
00:02:38,959 --> 00:02:41,280
instance to horizontal attacks

72
00:02:41,280 --> 00:02:43,120
and so another model that has been

73
00:02:43,120 --> 00:02:45,680
introduced is the random probing model

74
00:02:45,680 --> 00:02:47,680
where each variable leaks with a certain

75
00:02:47,680 --> 00:02:49,760
probability

76
00:02:49,760 --> 00:02:51,440
and so the last one is what we call the

77
00:02:51,440 --> 00:02:53,920
noisy leakage model where all variables

78
00:02:53,920 --> 00:02:56,480
leak a noisy function of their value

79
00:02:56,480 --> 00:02:58,800
so there are other other leakage models

80
00:02:58,800 --> 00:03:01,120
in the state of the art but these three

81
00:03:01,120 --> 00:03:04,720
are the most widely used ones

82
00:03:04,720 --> 00:03:06,239
and actually there is a reduction

83
00:03:06,239 --> 00:03:07,599
property

84
00:03:07,599 --> 00:03:10,080
which proves that if a circuit is secure

85
00:03:10,080 --> 00:03:12,480
in the probing model then it is also

86
00:03:12,480 --> 00:03:14,879
secure in the other two models

87
00:03:14,879 --> 00:03:16,640
but the problem with this reduction

88
00:03:16,640 --> 00:03:18,959
especially to the random probing model

89
00:03:18,959 --> 00:03:21,599
is that it uses the turn off bound and

90
00:03:21,599 --> 00:03:24,239
so the security parameter degrades as

91
00:03:24,239 --> 00:03:26,239
the size of the circuit grows

92
00:03:26,239 --> 00:03:28,159
so this is for the first the first part

93
00:03:28,159 --> 00:03:30,000
of the reduction

94
00:03:30,000 --> 00:03:31,280
meanwhile

95
00:03:31,280 --> 00:03:33,200
the second part of the reduction is

96
00:03:33,200 --> 00:03:36,400
tighter and we don't lose uh security

97
00:03:36,400 --> 00:03:39,200
when the size of the circuit grows

98
00:03:39,200 --> 00:03:41,200
and so in this work we focus on the

99
00:03:41,200 --> 00:03:43,440
random probing model from which the

100
00:03:43,440 --> 00:03:45,440
title reduction to the noisy leakage

101
00:03:45,440 --> 00:03:46,799
model exists

102
00:03:46,799 --> 00:03:49,120
and in which security proofs are still

103
00:03:49,120 --> 00:03:51,680
manageable

104
00:03:52,720 --> 00:03:55,280
our work is actually a follow-up to two

105
00:03:55,280 --> 00:03:58,000
previous works in the past two years

106
00:03:58,000 --> 00:04:00,959
the first one is from crypto 2020 where

107
00:04:00,959 --> 00:04:02,879
the authors explicitly define what

108
00:04:02,879 --> 00:04:05,280
random probing security is

109
00:04:05,280 --> 00:04:07,519
and they also introduced the notion of

110
00:04:07,519 --> 00:04:09,760
random probing secure composition to

111
00:04:09,760 --> 00:04:12,000
generate larger circuits with overall

112
00:04:12,000 --> 00:04:13,280
security

113
00:04:13,280 --> 00:04:15,439
but their essential contribution resides

114
00:04:15,439 --> 00:04:17,918
in the study of the expansion strategy

115
00:04:17,918 --> 00:04:20,560
now this strategy aims to arbitrarily

116
00:04:20,560 --> 00:04:23,759
amplify the security level of any rp

117
00:04:23,759 --> 00:04:25,520
secure circuit

118
00:04:25,520 --> 00:04:27,759
while it has already been introduced in

119
00:04:27,759 --> 00:04:30,639
another work based on mpc protocols

120
00:04:30,639 --> 00:04:32,479
here the authors exhibit a more

121
00:04:32,479 --> 00:04:35,280
practical definition

122
00:04:35,280 --> 00:04:37,280
now the second work is from eurocrypt

123
00:04:37,280 --> 00:04:38,720
2021

124
00:04:38,720 --> 00:04:40,639
and it follows on this expansion

125
00:04:40,639 --> 00:04:43,600
strategy providing a detailed analysis

126
00:04:43,600 --> 00:04:46,080
with tighter complexity bounds

127
00:04:46,080 --> 00:04:48,479
the authors also introduced some generic

128
00:04:48,479 --> 00:04:50,560
instructions for the expansion strategy

129
00:04:50,560 --> 00:04:53,199
with improved complexities

130
00:04:53,199 --> 00:04:54,960
and so based on this generic

131
00:04:54,960 --> 00:04:57,560
construction they exhibit concrete

132
00:04:57,560 --> 00:05:00,160
instantiations and they could provide

133
00:05:00,160 --> 00:05:03,759
three share and five share constructions

134
00:05:03,759 --> 00:05:06,320
with improved complexity over previous

135
00:05:06,320 --> 00:05:08,720
work the previous work and which can

136
00:05:08,720 --> 00:05:10,639
tolerate a leakage rate of about 2 to

137
00:05:10,639 --> 00:05:13,120
the minus 7.5 and i will discuss later

138
00:05:13,120 --> 00:05:16,320
what this tolerated leakage rate means

139
00:05:16,320 --> 00:05:18,639
now these two these two works actually

140
00:05:18,639 --> 00:05:20,639
show the importance and the potential

141
00:05:20,639 --> 00:05:22,639
that the expansion strategy can have for

142
00:05:22,639 --> 00:05:24,400
random probing security

143
00:05:24,400 --> 00:05:26,960
and so by the end of the eurocrip 2021

144
00:05:26,960 --> 00:05:29,039
paper the authors show that there are

145
00:05:29,039 --> 00:05:31,199
still many open questions left

146
00:05:31,199 --> 00:05:33,440
and much room for improvement

147
00:05:33,440 --> 00:05:35,759
so specifically how to tolerate for

148
00:05:35,759 --> 00:05:38,080
example the best leakage rate and how to

149
00:05:38,080 --> 00:05:42,479
achieve the best asymptotic complexity

150
00:05:42,960 --> 00:05:45,280
so in this work we also study this

151
00:05:45,280 --> 00:05:48,080
expansion strategy given its importance

152
00:05:48,080 --> 00:05:49,680
and we introduced the concept of

153
00:05:49,680 --> 00:05:51,680
dynamism and expansion

154
00:05:51,680 --> 00:05:53,840
so previously applying the expansion

155
00:05:53,840 --> 00:05:56,479
would consist in choosing a fixed set of

156
00:05:56,479 --> 00:05:57,520
gadgets

157
00:05:57,520 --> 00:05:59,680
and using them recursively

158
00:05:59,680 --> 00:06:02,080
the idea here is to be able to change

159
00:06:02,080 --> 00:06:04,400
gadgets between iterations in order to

160
00:06:04,400 --> 00:06:06,800
benefit from better security parameters

161
00:06:06,800 --> 00:06:09,360
and better complexities

162
00:06:09,360 --> 00:06:11,600
so in order to do this we had to

163
00:06:11,600 --> 00:06:14,080
generalize the definition of rpe in

164
00:06:14,080 --> 00:06:16,319
order to support any kind of basic

165
00:06:16,319 --> 00:06:17,600
operations

166
00:06:17,600 --> 00:06:20,080
instead of restricting it to like add

167
00:06:20,080 --> 00:06:21,919
copy and multiplication

168
00:06:21,919 --> 00:06:24,400
so for instance for our work we needed

169
00:06:24,400 --> 00:06:25,840
the multiplication by a constant

170
00:06:25,840 --> 00:06:27,039
operation

171
00:06:27,039 --> 00:06:29,759
in our new compilers

172
00:06:29,759 --> 00:06:31,840
so one of the questions that the dynamic

173
00:06:31,840 --> 00:06:34,080
expansion raised was to find rpe

174
00:06:34,080 --> 00:06:36,240
compilers which have better asymptotic

175
00:06:36,240 --> 00:06:38,960
complexities regardless of the tolerated

176
00:06:38,960 --> 00:06:41,199
leakage rate they can support

177
00:06:41,199 --> 00:06:43,280
so for this we were able to provide

178
00:06:43,280 --> 00:06:46,479
constructions of linear gadgets notably

179
00:06:46,479 --> 00:06:48,960
addition multiplication by constant and

180
00:06:48,960 --> 00:06:50,400
copy gadgets

181
00:06:50,400 --> 00:06:53,520
with a kazi linear asymptotic complexity

182
00:06:53,520 --> 00:06:55,759
using as a building block the refresh

183
00:06:55,759 --> 00:06:59,120
gadget proposed in chess 2016

184
00:06:59,120 --> 00:07:01,039
and so we proved that this refresh

185
00:07:01,039 --> 00:07:02,560
gadget can achieve the necessary

186
00:07:02,560 --> 00:07:04,639
properties in order for it to be used as

187
00:07:04,639 --> 00:07:06,400
a building block

188
00:07:06,400 --> 00:07:08,080
and this is an improvement over the

189
00:07:08,080 --> 00:07:10,479
quadratic complexity of previous gadgets

190
00:07:10,479 --> 00:07:12,639
for the expansion

191
00:07:12,639 --> 00:07:14,560
and finally we also provide the

192
00:07:14,560 --> 00:07:16,800
construction of a multiplication gadget

193
00:07:16,800 --> 00:07:18,319
which has a

194
00:07:18,319 --> 00:07:21,039
kazi linear randomness complexity

195
00:07:21,039 --> 00:07:22,800
and performs a linear number of

196
00:07:22,800 --> 00:07:25,280
multiplications between variables

197
00:07:25,280 --> 00:07:27,599
now this is at the expense of more

198
00:07:27,599 --> 00:07:29,520
operations of multiplication by a

199
00:07:29,520 --> 00:07:30,720
constant

200
00:07:30,720 --> 00:07:33,280
but we prove that these operations don't

201
00:07:33,280 --> 00:07:34,960
have an effect on the asymptotic

202
00:07:34,960 --> 00:07:36,800
complexity

203
00:07:36,800 --> 00:07:38,560
now this construction is done in two

204
00:07:38,560 --> 00:07:39,440
steps

205
00:07:39,440 --> 00:07:42,319
using a multiplication sub gadget which

206
00:07:42,319 --> 00:07:44,319
outputs a certain number of shares

207
00:07:44,319 --> 00:07:46,000
bigger than n

208
00:07:46,000 --> 00:07:48,240
and so this gadget is essentially based

209
00:07:48,240 --> 00:07:52,000
on a work from crypto 2017

210
00:07:52,000 --> 00:07:54,319
and then this is concatenated or

211
00:07:54,319 --> 00:07:56,639
followed by a compression gadget which

212
00:07:56,639 --> 00:07:59,280
compresses this output back into end

213
00:07:59,280 --> 00:08:00,479
shares

214
00:08:00,479 --> 00:08:03,039
and so we are able to provide an rpe

215
00:08:03,039 --> 00:08:05,599
compiler with a casi linear asymptotic

216
00:08:05,599 --> 00:08:07,280
complexity overall

217
00:08:07,280 --> 00:08:09,360
and which can be used for the dynamic

218
00:08:09,360 --> 00:08:12,919
expansion strategy

219
00:08:18,560 --> 00:08:20,479
so i will first start with an

220
00:08:20,479 --> 00:08:22,639
illustration of what random probing

221
00:08:22,639 --> 00:08:24,080
security is

222
00:08:24,080 --> 00:08:25,520
now on the left you can see a toy

223
00:08:25,520 --> 00:08:27,840
circuit with the five types of gates

224
00:08:27,840 --> 00:08:29,599
that we consider for our concrete

225
00:08:29,599 --> 00:08:31,120
instantiations

226
00:08:31,120 --> 00:08:33,039
so there are typically addition

227
00:08:33,039 --> 00:08:35,599
multiplication copy random gates and

228
00:08:35,599 --> 00:08:38,159
multiplication by constant

229
00:08:38,159 --> 00:08:40,719
so in the random probing model each wire

230
00:08:40,719 --> 00:08:42,640
leaks with probability p

231
00:08:42,640 --> 00:08:45,519
so we consider a set of leaking wires as

232
00:08:45,519 --> 00:08:47,040
a random variable

233
00:08:47,040 --> 00:08:49,440
where each wire is added to the set with

234
00:08:49,440 --> 00:08:52,399
independent probability p

235
00:08:52,399 --> 00:08:54,880
and so considering each set of wires we

236
00:08:54,880 --> 00:08:56,480
need to be able to simulate the

237
00:08:56,480 --> 00:08:58,720
distribution of these wires without the

238
00:08:58,720 --> 00:09:00,959
knowledge of the secret inputs

239
00:09:00,959 --> 00:09:03,200
now this would imply that the wires are

240
00:09:03,200 --> 00:09:05,519
independent of the secret

241
00:09:05,519 --> 00:09:07,839
if this is the case we say that we have

242
00:09:07,839 --> 00:09:10,000
a simulation success

243
00:09:10,000 --> 00:09:12,320
and if not we say that we have a

244
00:09:12,320 --> 00:09:14,160
simulation failure

245
00:09:14,160 --> 00:09:16,480
and this should occur with probability

246
00:09:16,480 --> 00:09:19,200
epsilon in the random probing model

247
00:09:19,200 --> 00:09:21,920
and so a circuit is said p epsilon

248
00:09:21,920 --> 00:09:23,600
random probing secure

249
00:09:23,600 --> 00:09:26,160
if any set of leaking wires on the

250
00:09:26,160 --> 00:09:30,719
circuit satisfies this definition

251
00:09:31,760 --> 00:09:33,360
now in the random probing model the

252
00:09:33,360 --> 00:09:35,760
expansion strategy allows gadgets to be

253
00:09:35,760 --> 00:09:37,600
composed and expanded

254
00:09:37,600 --> 00:09:40,640
to achieve arbitrary arbitrarily large

255
00:09:40,640 --> 00:09:42,480
security levels

256
00:09:42,480 --> 00:09:44,560
so the expansion strategy consists in

257
00:09:44,560 --> 00:09:46,480
using ensure gadgets for basic

258
00:09:46,480 --> 00:09:48,880
operations that are what we call random

259
00:09:48,880 --> 00:09:50,720
probing expandable

260
00:09:50,720 --> 00:09:53,200
and in this case we have beta different

261
00:09:53,200 --> 00:09:56,240
gates and beta corresponding gadgets so

262
00:09:56,240 --> 00:09:58,480
the base operations are generalized to

263
00:09:58,480 --> 00:10:01,519
the definition of the strategy

264
00:10:01,519 --> 00:10:03,839
the idea is to use these gadgets to

265
00:10:03,839 --> 00:10:06,399
replace a base circuit where each wire

266
00:10:06,399 --> 00:10:08,480
leaks with probability p

267
00:10:08,480 --> 00:10:11,200
by an expanded circuit where each gate

268
00:10:11,200 --> 00:10:13,920
is replaced by the corresponding gadget

269
00:10:13,920 --> 00:10:16,480
and each wire by n wires carrying a

270
00:10:16,480 --> 00:10:19,040
sharing of the original wire

271
00:10:19,040 --> 00:10:21,279
so doing so we hope to replace the

272
00:10:21,279 --> 00:10:23,200
leakage probability p of a wire in the

273
00:10:23,200 --> 00:10:24,720
original circuit

274
00:10:24,720 --> 00:10:27,200
by the failure event probability epsilon

275
00:10:27,200 --> 00:10:30,160
in the expanded gadget simulation

276
00:10:30,160 --> 00:10:32,320
and so if the simulation fails then one

277
00:10:32,320 --> 00:10:34,240
needs the full input sharing for the

278
00:10:34,240 --> 00:10:36,000
gadget simulation

279
00:10:36,000 --> 00:10:37,600
which corresponds to leaking the

280
00:10:37,600 --> 00:10:39,680
corresponding wire value in the base

281
00:10:39,680 --> 00:10:41,680
case

282
00:10:41,680 --> 00:10:43,600
so the interesting thing is that this

283
00:10:43,600 --> 00:10:45,519
extra expansion can be applied

284
00:10:45,519 --> 00:10:48,320
recursively until we attain a desired

285
00:10:48,320 --> 00:10:50,560
security level

286
00:10:50,560 --> 00:10:53,600
and so this works as long as epsilon is

287
00:10:53,600 --> 00:10:55,600
strictly smaller than p and this

288
00:10:55,600 --> 00:10:57,760
introduces the definition of the maximum

289
00:10:57,760 --> 00:11:01,640
tolerated leakage probability

290
00:11:01,839 --> 00:11:04,079
so to do this the gadgets should be

291
00:11:04,079 --> 00:11:06,640
random probing expandable so the rp

292
00:11:06,640 --> 00:11:08,959
expandability notion of a gadget ensures

293
00:11:08,959 --> 00:11:11,680
that first of all it is random probing

294
00:11:11,680 --> 00:11:14,800
secure with p epsilon parameters

295
00:11:14,800 --> 00:11:16,560
but it also guarantees that we can

296
00:11:16,560 --> 00:11:19,519
compose this gadget with other rp secure

297
00:11:19,519 --> 00:11:20,720
gadgets

298
00:11:20,720 --> 00:11:23,279
the idea is to be able to simulate any

299
00:11:23,279 --> 00:11:26,160
set of wires on the gadget along with t

300
00:11:26,160 --> 00:11:28,959
output shares using at most t input

301
00:11:28,959 --> 00:11:30,720
shares

302
00:11:30,720 --> 00:11:32,399
so if we have for example a circuit

303
00:11:32,399 --> 00:11:34,399
composed of a bunch of gadgets and we

304
00:11:34,399 --> 00:11:36,399
fixed the parameter t here for example

305
00:11:36,399 --> 00:11:38,640
you can say that t is equal to two

306
00:11:38,640 --> 00:11:40,560
then we can actually go from the bottom

307
00:11:40,560 --> 00:11:42,880
level to the top level

308
00:11:42,880 --> 00:11:46,320
by simulating t outputs along with the

309
00:11:46,320 --> 00:11:47,760
internal probes

310
00:11:47,760 --> 00:11:49,839
using t inputs

311
00:11:49,839 --> 00:11:52,880
until we arrive to the topmost inputs of

312
00:11:52,880 --> 00:11:55,200
the circuit

313
00:11:55,200 --> 00:11:57,200
so in addition

314
00:11:57,200 --> 00:11:58,959
the random probing expandability

315
00:11:58,959 --> 00:12:01,600
property also imposes that we get an

316
00:12:01,600 --> 00:12:04,399
independent failure event probability on

317
00:12:04,399 --> 00:12:06,959
each input sharing of the gadget

318
00:12:06,959 --> 00:12:09,440
so this is an essential condition for

319
00:12:09,440 --> 00:12:11,839
these for the expansion to work on an

320
00:12:11,839 --> 00:12:15,040
arbitrary level k

321
00:12:15,040 --> 00:12:16,880
so it has been shown that if the used

322
00:12:16,880 --> 00:12:19,040
gadgets are random probing expandable

323
00:12:19,040 --> 00:12:20,880
according to the previous conditions

324
00:12:20,880 --> 00:12:23,440
with failure probability epsilon

325
00:12:23,440 --> 00:12:25,360
then the compiled circuit

326
00:12:25,360 --> 00:12:27,600
with these gadgets is random probing

327
00:12:27,600 --> 00:12:28,639
secure

328
00:12:28,639 --> 00:12:30,800
with the failure probability reduced

329
00:12:30,800 --> 00:12:32,800
exponentially with respect to the

330
00:12:32,800 --> 00:12:36,680
expansion level k

331
00:12:38,000 --> 00:12:40,079
so expanding a circuit to achieve an

332
00:12:40,079 --> 00:12:42,399
arbitrarily large security level comes

333
00:12:42,399 --> 00:12:44,560
of course with a certain cost

334
00:12:44,560 --> 00:12:46,720
in fact if we want to achieve a security

335
00:12:46,720 --> 00:12:49,440
level kappa using some fixed base and

336
00:12:49,440 --> 00:12:50,959
share gadgets

337
00:12:50,959 --> 00:12:53,200
the complexity of the expansion can be

338
00:12:53,200 --> 00:12:55,920
expressed in terms of the size of the

339
00:12:55,920 --> 00:12:57,440
original circuit

340
00:12:57,440 --> 00:12:59,760
and kappa to the power e where e is

341
00:12:59,760 --> 00:13:01,279
basically a function of two main

342
00:13:01,279 --> 00:13:05,680
parameters which are called nmax and d

343
00:13:05,680 --> 00:13:08,320
so nmax is essentially a parameter which

344
00:13:08,320 --> 00:13:10,160
depends on the complexity of the base

345
00:13:10,160 --> 00:13:11,279
gadgets

346
00:13:11,279 --> 00:13:13,440
so in the case of this constructions in

347
00:13:13,440 --> 00:13:16,160
our paper where our basic operations are

348
00:13:16,160 --> 00:13:17,680
add copy multiplication and

349
00:13:17,680 --> 00:13:20,399
multiplication by a constant we prove

350
00:13:20,399 --> 00:13:22,639
that n max specifically depends on the

351
00:13:22,639 --> 00:13:24,399
number of multiplication gates in the

352
00:13:24,399 --> 00:13:26,320
multiplication gadget

353
00:13:26,320 --> 00:13:28,399
the number of adding propagates in the

354
00:13:28,399 --> 00:13:30,079
adding copy gadget

355
00:13:30,079 --> 00:13:31,920
and the number of multiplications by a

356
00:13:31,920 --> 00:13:33,920
constant in the multiplication by a

357
00:13:33,920 --> 00:13:35,600
constant gadget

358
00:13:35,600 --> 00:13:38,240
so for example if we use a standard

359
00:13:38,240 --> 00:13:40,079
multiplication gadget

360
00:13:40,079 --> 00:13:42,560
nmax would be at least quadratic in the

361
00:13:42,560 --> 00:13:45,359
number of shares

362
00:13:45,680 --> 00:13:47,600
another critical parameter is the

363
00:13:47,600 --> 00:13:50,399
amplification order which is defined as

364
00:13:50,399 --> 00:13:52,959
the size of the smallest set of probes

365
00:13:52,959 --> 00:13:56,160
for which we get a simulation failure

366
00:13:56,160 --> 00:13:57,519
so for instance

367
00:13:57,519 --> 00:13:59,279
if we take the same example of the two

368
00:13:59,279 --> 00:14:02,000
share addition gadget from before and

369
00:14:02,000 --> 00:14:04,320
take the parameter of the rp expansion t

370
00:14:04,320 --> 00:14:05,760
equal to one

371
00:14:05,760 --> 00:14:08,240
then we can consider the output share c1

372
00:14:08,240 --> 00:14:11,920
and the single internal probe share b2

373
00:14:11,920 --> 00:14:13,279
now it is clear that in order to

374
00:14:13,279 --> 00:14:15,199
simulate both probes

375
00:14:15,199 --> 00:14:18,079
we would need both shares of b

376
00:14:18,079 --> 00:14:20,959
and the share a1

377
00:14:20,959 --> 00:14:23,120
but since as defined earlier we need to

378
00:14:23,120 --> 00:14:25,600
be able to simulate all of the probes

379
00:14:25,600 --> 00:14:27,920
from at most t input shares

380
00:14:27,920 --> 00:14:30,399
then this set w actually represents a

381
00:14:30,399 --> 00:14:32,800
simulation failure on input b

382
00:14:32,800 --> 00:14:34,800
which means that the amplification order

383
00:14:34,800 --> 00:14:37,680
is equal to one

384
00:14:38,000 --> 00:14:39,920
so why is this amplification order so

385
00:14:39,920 --> 00:14:42,000
important well it is because the failure

386
00:14:42,000 --> 00:14:44,560
probability epsilon can be expressed

387
00:14:44,560 --> 00:14:46,160
as a function of p

388
00:14:46,160 --> 00:14:48,079
where the amplification order is the

389
00:14:48,079 --> 00:14:50,399
smallest exponent exponent of p in its

390
00:14:50,399 --> 00:14:52,000
expression

391
00:14:52,000 --> 00:14:53,920
now since during the expansion we

392
00:14:53,920 --> 00:14:55,920
compose this function a certain number

393
00:14:55,920 --> 00:14:57,519
of times

394
00:14:57,519 --> 00:15:00,000
we hope to get the highest amplification

395
00:15:00,000 --> 00:15:02,399
order possible to reduce the failure

396
00:15:02,399 --> 00:15:05,279
probability as fast as possible and thus

397
00:15:05,279 --> 00:15:07,120
reduce the complexity

398
00:15:07,120 --> 00:15:08,720
so it has been proven that for end

399
00:15:08,720 --> 00:15:11,199
shares the best amplification order that

400
00:15:11,199 --> 00:15:12,880
we can achieve that we can hope to

401
00:15:12,880 --> 00:15:13,760
achieve

402
00:15:13,760 --> 00:15:18,240
is equal to almost n plus one over two

403
00:15:20,000 --> 00:15:22,079
in the basic version of the expansion

404
00:15:22,079 --> 00:15:24,240
strategy the expanded compiler is

405
00:15:24,240 --> 00:15:26,720
defined and fixed with a certain number

406
00:15:26,720 --> 00:15:29,360
of gadgets which are used recursively to

407
00:15:29,360 --> 00:15:31,519
replace the gates in the compiled

408
00:15:31,519 --> 00:15:32,800
circuit

409
00:15:32,800 --> 00:15:34,800
now another possible approach would be

410
00:15:34,800 --> 00:15:37,360
to consider instead l different

411
00:15:37,360 --> 00:15:39,519
compilers with potentially different

412
00:15:39,519 --> 00:15:41,199
numbers of shares

413
00:15:41,199 --> 00:15:43,279
and then apply each of them at a

414
00:15:43,279 --> 00:15:45,120
different iteration

415
00:15:45,120 --> 00:15:47,040
so we would start with the first

416
00:15:47,040 --> 00:15:49,120
compiler for instance with the k1

417
00:15:49,120 --> 00:15:52,000
iterations then the second then the

418
00:15:52,000 --> 00:15:52,839
third

419
00:15:52,839 --> 00:15:55,680
etc and at each step the number of

420
00:15:55,680 --> 00:15:56,720
shares

421
00:15:56,720 --> 00:15:58,240
of the compiled circuit and the

422
00:15:58,240 --> 00:16:01,040
corresponding failure function behaves

423
00:16:01,040 --> 00:16:03,600
exactly the same as in the static rpe

424
00:16:03,600 --> 00:16:04,720
case

425
00:16:04,720 --> 00:16:06,800
now the difference here is that at each

426
00:16:06,800 --> 00:16:08,800
step a different number of shares is

427
00:16:08,800 --> 00:16:11,279
used and the failure function is the

428
00:16:11,279 --> 00:16:13,360
composition of different failure

429
00:16:13,360 --> 00:16:14,639
functions

430
00:16:14,639 --> 00:16:16,800
so in the original case the only

431
00:16:16,800 --> 00:16:18,720
condition for this to work is to have

432
00:16:18,720 --> 00:16:21,199
epsilon smaller than p

433
00:16:21,199 --> 00:16:23,600
now here we would have a generalized

434
00:16:23,600 --> 00:16:24,720
condition

435
00:16:24,720 --> 00:16:26,560
a set of conditions

436
00:16:26,560 --> 00:16:27,530
in order for the

437
00:16:27,530 --> 00:16:28,639
[Music]

438
00:16:28,639 --> 00:16:30,480
like in order to be able to move from

439
00:16:30,480 --> 00:16:33,759
one step of the compilation to another

440
00:16:33,759 --> 00:16:35,440
now the main question that needs to be

441
00:16:35,440 --> 00:16:38,079
answered here is why would we need like

442
00:16:38,079 --> 00:16:40,560
a dynamic expansion instead of the usual

443
00:16:40,560 --> 00:16:42,480
one

444
00:16:42,480 --> 00:16:45,199
well in fact in our work we rigorously

445
00:16:45,199 --> 00:16:47,680
rigorously show that an rpe compiler

446
00:16:47,680 --> 00:16:49,839
with a smaller number of shares

447
00:16:49,839 --> 00:16:52,240
tend to tolerate the best leakage rates

448
00:16:52,240 --> 00:16:54,639
in the random probing model because with

449
00:16:54,639 --> 00:16:56,639
fewer numbers of shares we would also

450
00:16:56,639 --> 00:16:59,519
get fewer numbers of variables and thus

451
00:16:59,519 --> 00:17:02,399
like fewer num fewer sets of probes that

452
00:17:02,399 --> 00:17:04,720
reveal the secret

453
00:17:04,720 --> 00:17:06,880
while an rpe compiler with a big number

454
00:17:06,880 --> 00:17:08,640
of shares could achieve the highest

455
00:17:08,640 --> 00:17:10,959
amplification order possible with good

456
00:17:10,959 --> 00:17:13,119
asymptotic complexity

457
00:17:13,119 --> 00:17:14,480
now recall that the higher the

458
00:17:14,480 --> 00:17:16,240
amplification order

459
00:17:16,240 --> 00:17:18,160
the fewer the number of iterations we

460
00:17:18,160 --> 00:17:19,919
would need to achieve a certain security

461
00:17:19,919 --> 00:17:21,520
level

462
00:17:21,520 --> 00:17:23,520
so the idea in the dynamic expansion is

463
00:17:23,520 --> 00:17:25,520
to start with a few iterations of a

464
00:17:25,520 --> 00:17:28,160
compiler with for instance three shares

465
00:17:28,160 --> 00:17:30,000
tolerating the best rate

466
00:17:30,000 --> 00:17:32,240
and then continue on the expansion with

467
00:17:32,240 --> 00:17:34,000
a different compiler with higher number

468
00:17:34,000 --> 00:17:35,679
of shares and better asymptotic

469
00:17:35,679 --> 00:17:37,520
complexity

470
00:17:37,520 --> 00:17:39,440
so to illustrate the benefits of this

471
00:17:39,440 --> 00:17:41,840
idea we draw a figure representing the

472
00:17:41,840 --> 00:17:43,760
complexity which means the number of

473
00:17:43,760 --> 00:17:46,640
gates of an rp secure version of the aes

474
00:17:46,640 --> 00:17:47,840
algorithm

475
00:17:47,840 --> 00:17:50,320
and the security of this algorithm after

476
00:17:50,320 --> 00:17:52,720
applying the expansion strategy

477
00:17:52,720 --> 00:17:54,640
now we use the three share and five

478
00:17:54,640 --> 00:17:56,720
share compilers proposed in eurocrypt

479
00:17:56,720 --> 00:17:59,440
2021 which are the best compilers

480
00:17:59,440 --> 00:18:01,280
proposed until now

481
00:18:01,280 --> 00:18:03,360
and so the best tolerated leakage rate

482
00:18:03,360 --> 00:18:05,919
is of 2 to the minus 7.6 for the three

483
00:18:05,919 --> 00:18:07,679
share compiler in the random probing

484
00:18:07,679 --> 00:18:09,520
model

485
00:18:09,520 --> 00:18:11,120
now let's say for instance that we would

486
00:18:11,120 --> 00:18:13,200
like to achieve a security level of at

487
00:18:13,200 --> 00:18:15,600
least 2 to the minus 80. then we can

488
00:18:15,600 --> 00:18:18,160
achieve it either by doing 11 iterations

489
00:18:18,160 --> 00:18:20,799
of the three-share compiler but also by

490
00:18:20,799 --> 00:18:23,120
starting with seven iterations of the

491
00:18:23,120 --> 00:18:25,360
of the three share compiler and then two

492
00:18:25,360 --> 00:18:28,240
iterations of the five-share compiler

493
00:18:28,240 --> 00:18:30,480
and we will get a factor 10 improvement

494
00:18:30,480 --> 00:18:32,240
over the complexity as you can see in

495
00:18:32,240 --> 00:18:34,240
the figure

496
00:18:34,240 --> 00:18:36,080
if for example we would like to achieve

497
00:18:36,080 --> 00:18:37,600
a security of

498
00:18:37,600 --> 00:18:38,390
two to the

499
00:18:38,390 --> 00:18:39,600
[Music]

500
00:18:39,600 --> 00:18:41,760
minus 128

501
00:18:41,760 --> 00:18:44,320
then we can still use 11 iterations of

502
00:18:44,320 --> 00:18:46,880
the three share compiler but we also can

503
00:18:46,880 --> 00:18:49,679
use seven iterations of three shares and

504
00:18:49,679 --> 00:18:52,080
three iterations of five shares

505
00:18:52,080 --> 00:18:54,799
with almost the same complexity but also

506
00:18:54,799 --> 00:18:56,799
almost doubling the achieved security

507
00:18:56,799 --> 00:18:57,919
level

508
00:18:57,919 --> 00:18:59,440
so we can actually observe that doing

509
00:18:59,440 --> 00:19:02,080
the dynamic approach we als we

510
00:19:02,080 --> 00:19:03,919
like we win either in terms of

511
00:19:03,919 --> 00:19:06,480
complexity or achieved security level or

512
00:19:06,480 --> 00:19:08,320
sometimes both

513
00:19:08,320 --> 00:19:10,799
so this clearly illustrates the benefits

514
00:19:10,799 --> 00:19:12,960
of using a dynamic approach instead of a

515
00:19:12,960 --> 00:19:15,679
static one

516
00:19:16,080 --> 00:19:18,240
so after exhibiting the dynamic approach

517
00:19:18,240 --> 00:19:19,840
we could have two possible directions

518
00:19:19,840 --> 00:19:21,120
for improvement

519
00:19:21,120 --> 00:19:22,720
either look for gadgets with small

520
00:19:22,720 --> 00:19:24,320
number of shares which can tolerate the

521
00:19:24,320 --> 00:19:26,400
best leakage rate possible

522
00:19:26,400 --> 00:19:28,160
or look for gadgets with a maximal

523
00:19:28,160 --> 00:19:30,320
amplification order and good asymptotic

524
00:19:30,320 --> 00:19:32,559
complexities but with a higher number of

525
00:19:32,559 --> 00:19:34,080
shares

526
00:19:34,080 --> 00:19:36,880
in this work we focus on the latter goal

527
00:19:36,880 --> 00:19:39,120
so as stated in our contributions we

528
00:19:39,120 --> 00:19:41,120
provide constructions of linear gadgets

529
00:19:41,120 --> 00:19:43,840
with gasi linear asymptotic complexity

530
00:19:43,840 --> 00:19:45,200
and which achieve the maximal

531
00:19:45,200 --> 00:19:46,960
amplification order

532
00:19:46,960 --> 00:19:49,200
and we also construct a multiplication

533
00:19:49,200 --> 00:19:51,600
gadget with the casio linear randomness

534
00:19:51,600 --> 00:19:53,520
complexity and the linear number of

535
00:19:53,520 --> 00:19:55,919
multiplications between variables in

536
00:19:55,919 --> 00:19:58,320
order to have a kazi linear asymptotic

537
00:19:58,320 --> 00:20:00,960
complexity for the final rpe compiler

538
00:20:00,960 --> 00:20:04,320
using all of these gadgets

539
00:20:04,880 --> 00:20:07,200
so let me first start by exhibiting the

540
00:20:07,200 --> 00:20:10,159
construction of our linear gadgets

541
00:20:10,159 --> 00:20:12,880
so we base our construction on a single

542
00:20:12,880 --> 00:20:15,120
building block of a refresh gadget and

543
00:20:15,120 --> 00:20:16,799
this strategy has already been proven

544
00:20:16,799 --> 00:20:19,120
secure in the previous work of eurocrypt

545
00:20:19,120 --> 00:20:20,720
2021

546
00:20:20,720 --> 00:20:22,720
but the refresh gadget that we use here

547
00:20:22,720 --> 00:20:24,960
is the n login refresh gadget from chest

548
00:20:24,960 --> 00:20:27,760
to sound 2016.

549
00:20:27,760 --> 00:20:29,760
so the main idea is to start with an

550
00:20:29,760 --> 00:20:31,520
input sharing

551
00:20:31,520 --> 00:20:33,120
of n shares

552
00:20:33,120 --> 00:20:34,559
split it into

553
00:20:34,559 --> 00:20:37,919
two and over two sharings and add a same

554
00:20:37,919 --> 00:20:40,240
random value to each couple of sharing

555
00:20:40,240 --> 00:20:42,320
from both sharings so to each couple of

556
00:20:42,320 --> 00:20:44,480
shares from both sharings

557
00:20:44,480 --> 00:20:47,679
so this uses n over two random values

558
00:20:47,679 --> 00:20:50,720
next each block of n over two shares is

559
00:20:50,720 --> 00:20:53,280
used as input to a recursive call to the

560
00:20:53,280 --> 00:20:55,918
full gadget

561
00:20:56,720 --> 00:20:59,840
and finally the final layer which does

562
00:20:59,840 --> 00:21:03,120
the same thing as the first layer so

563
00:21:03,120 --> 00:21:05,120
it is added before outputting the final

564
00:21:05,120 --> 00:21:08,080
output share and it adds also n over two

565
00:21:08,080 --> 00:21:11,840
random values to the final sharing

566
00:21:11,840 --> 00:21:13,760
so this means that each call to the

567
00:21:13,760 --> 00:21:15,520
gadget uses

568
00:21:15,520 --> 00:21:18,559
n over two operations on each side

569
00:21:18,559 --> 00:21:20,960
and so we have n operations in total and

570
00:21:20,960 --> 00:21:23,440
this gives an overall complexity of

571
00:21:23,440 --> 00:21:26,640
big o of n log n

572
00:21:27,120 --> 00:21:28,880
so here you can see an example of the

573
00:21:28,880 --> 00:21:30,960
for share refresh gadget with different

574
00:21:30,960 --> 00:21:33,520
colors representing the different layers

575
00:21:33,520 --> 00:21:35,919
so at each layer two random values are

576
00:21:35,919 --> 00:21:37,200
used and are

577
00:21:37,200 --> 00:21:39,120
equally distributed over the output

578
00:21:39,120 --> 00:21:40,080
shares

579
00:21:40,080 --> 00:21:42,320
the original layer of the orange layer

580
00:21:42,320 --> 00:21:44,640
sorry corresponds to the recursive calls

581
00:21:44,640 --> 00:21:47,360
to the gadget

582
00:21:47,360 --> 00:21:50,080
so this gadget has been proven to be n

583
00:21:50,080 --> 00:21:52,880
minus one sni in the probing model in

584
00:21:52,880 --> 00:21:55,760
the original work from chess 2016.

585
00:21:55,760 --> 00:21:58,320
in our work we proved that it satisfies

586
00:21:58,320 --> 00:22:00,640
stronger requirements to be used as a

587
00:22:00,640 --> 00:22:02,799
block for rpe constructions

588
00:22:02,799 --> 00:22:04,799
now such requirements have already been

589
00:22:04,799 --> 00:22:07,440
introduced in earlier works but here we

590
00:22:07,440 --> 00:22:09,200
actually define an extension of these

591
00:22:09,200 --> 00:22:10,799
requirements in order for the

592
00:22:10,799 --> 00:22:13,840
constructions to work

593
00:22:16,000 --> 00:22:17,919
so once we have done this we can finally

594
00:22:17,919 --> 00:22:20,000
use the refresh gadget to build our

595
00:22:20,000 --> 00:22:23,360
three linear gadgets notably add copy

596
00:22:23,360 --> 00:22:26,159
and multiplication by a constant

597
00:22:26,159 --> 00:22:28,240
so for the add gadget we would refresh

598
00:22:28,240 --> 00:22:30,240
both input sharings before performing

599
00:22:30,240 --> 00:22:32,799
the sharewise addition

600
00:22:32,799 --> 00:22:35,200
for the copy gadget we would produce two

601
00:22:35,200 --> 00:22:36,799
fresh copies of the input with two

602
00:22:36,799 --> 00:22:38,880
independent refreshes

603
00:22:38,880 --> 00:22:40,640
and for the multiplication by a constant

604
00:22:40,640 --> 00:22:42,880
gadget we would start by multiplying the

605
00:22:42,880 --> 00:22:44,880
sharing by the constant

606
00:22:44,880 --> 00:22:46,960
and then outputting the output of the

607
00:22:46,960 --> 00:22:50,080
refresh of the refresh gadget

608
00:22:50,080 --> 00:22:52,400
now all of these gadgets naturally have

609
00:22:52,400 --> 00:22:55,200
a complexity of big o of n log n

610
00:22:55,200 --> 00:22:58,000
and are proven to be rpe secure with the

611
00:22:58,000 --> 00:23:00,240
maximal amplification order of n plus

612
00:23:00,240 --> 00:23:01,600
one over two

613
00:23:01,600 --> 00:23:03,840
so this this gives us the construction

614
00:23:03,840 --> 00:23:06,159
of all of the linear gadgets necessary

615
00:23:06,159 --> 00:23:08,720
for the rpe compiler with the kazi

616
00:23:08,720 --> 00:23:11,600
linear asymptotic complexity

617
00:23:11,600 --> 00:23:13,200
in the rest i will show you the

618
00:23:13,200 --> 00:23:14,960
construction of the multiplication

619
00:23:14,960 --> 00:23:17,360
gadget

620
00:23:20,960 --> 00:23:22,960
so for the multiplication gadget we

621
00:23:22,960 --> 00:23:24,720
split our construction into two sub

622
00:23:24,720 --> 00:23:25,919
gadgets

623
00:23:25,919 --> 00:23:27,760
the idea is to apply a sub

624
00:23:27,760 --> 00:23:29,840
multiplication gadget on both input

625
00:23:29,840 --> 00:23:32,240
sharings which outputs certain number of

626
00:23:32,240 --> 00:23:34,080
shares let's say m

627
00:23:34,080 --> 00:23:36,400
and then compress this sharing back into

628
00:23:36,400 --> 00:23:38,559
n shares using a compression function or

629
00:23:38,559 --> 00:23:39,840
gadget

630
00:23:39,840 --> 00:23:41,760
in classical constructions for instance

631
00:23:41,760 --> 00:23:43,919
the sub multiplication would be the sub

632
00:23:43,919 --> 00:23:46,720
the cross products of shares so m would

633
00:23:46,720 --> 00:23:48,799
be of about n squared

634
00:23:48,799 --> 00:23:50,640
and then a compression function can be

635
00:23:50,640 --> 00:23:54,720
used such as the well-known isw

636
00:23:54,720 --> 00:23:56,640
now since the multiplication gadget must

637
00:23:56,640 --> 00:23:59,440
be rpe secure we must ensure that the

638
00:23:59,440 --> 00:24:02,240
composition of both sub-gadgets is also

639
00:24:02,240 --> 00:24:04,799
rpe secure which is not evidently the

640
00:24:04,799 --> 00:24:06,400
case all the time

641
00:24:06,400 --> 00:24:08,559
in our work we explicit the necessary

642
00:24:08,559 --> 00:24:10,720
properties for this to be true on both

643
00:24:10,720 --> 00:24:13,440
sub-gadgets

644
00:24:13,679 --> 00:24:14,799
now for the construction of the

645
00:24:14,799 --> 00:24:17,279
sub-multiplication gadget we use an

646
00:24:17,279 --> 00:24:19,440
extension of the one proposed in crypto

647
00:24:19,440 --> 00:24:21,120
2017

648
00:24:21,120 --> 00:24:24,159
and which outputs is a sharing of two n

649
00:24:24,159 --> 00:24:25,679
plus one shares

650
00:24:25,679 --> 00:24:27,440
now in the original work this would be

651
00:24:27,440 --> 00:24:29,760
to n minus one shares but we used two

652
00:24:29,760 --> 00:24:32,000
extra random values and we will get to

653
00:24:32,000 --> 00:24:33,679
extra output shares and i will explain

654
00:24:33,679 --> 00:24:35,840
this later

655
00:24:35,840 --> 00:24:38,159
as for the compression function we prove

656
00:24:38,159 --> 00:24:40,960
that the one proposed in crypto 2017 is

657
00:24:40,960 --> 00:24:42,480
actually not secure

658
00:24:42,480 --> 00:24:44,400
and we propose the construction of a new

659
00:24:44,400 --> 00:24:47,679
compression with complexity in m log m

660
00:24:47,679 --> 00:24:51,919
always using the n logan refresh gadget

661
00:24:52,799 --> 00:24:55,440
so let me first start by exhibiting the

662
00:24:55,440 --> 00:24:58,000
uh extended sub multiplication gadget

663
00:24:58,000 --> 00:25:01,279
based on the one from crypto 2017

664
00:25:01,279 --> 00:25:03,360
for this i will illustrate an example

665
00:25:03,360 --> 00:25:05,919
with three shares construction

666
00:25:05,919 --> 00:25:08,640
so the idea is to have a matrix of n

667
00:25:08,640 --> 00:25:10,480
squared constant values

668
00:25:10,480 --> 00:25:13,919
and compute one minus its transpose

669
00:25:13,919 --> 00:25:17,679
which corresponds to the matrix delta

670
00:25:17,679 --> 00:25:19,679
so the sub gadget produces two n plus

671
00:25:19,679 --> 00:25:21,840
one output shares in this case it would

672
00:25:21,840 --> 00:25:23,840
be seven shares

673
00:25:23,840 --> 00:25:25,919
for three input sharings

674
00:25:25,919 --> 00:25:28,400
so the first share would be the product

675
00:25:28,400 --> 00:25:31,039
of two linear combinations of the input

676
00:25:31,039 --> 00:25:32,960
sharings a and b

677
00:25:32,960 --> 00:25:36,480
here the ri and si are random values

678
00:25:36,480 --> 00:25:38,320
used by the gadget

679
00:25:38,320 --> 00:25:40,559
and we can see that this

680
00:25:40,559 --> 00:25:44,000
share c1 produces the cross products of

681
00:25:44,000 --> 00:25:45,520
the input shares

682
00:25:45,520 --> 00:25:48,000
but also produces products between input

683
00:25:48,000 --> 00:25:50,080
shares and random values which needs to

684
00:25:50,080 --> 00:25:52,559
be eliminated

685
00:25:52,559 --> 00:25:54,159
so in order to eliminate them in a

686
00:25:54,159 --> 00:25:55,360
secure way

687
00:25:55,360 --> 00:25:57,840
we would multiply the random values by

688
00:25:57,840 --> 00:26:00,240
constants from the matrices gamma and

689
00:26:00,240 --> 00:26:02,880
delta on each side

690
00:26:02,880 --> 00:26:04,640
and multiply to run the corresponding

691
00:26:04,640 --> 00:26:07,360
random value by the linear combination

692
00:26:07,360 --> 00:26:09,120
of the other side

693
00:26:09,120 --> 00:26:11,360
so delta would be used for the s random

694
00:26:11,360 --> 00:26:13,760
values and gamma would be used for the r

695
00:26:13,760 --> 00:26:15,840
random values

696
00:26:15,840 --> 00:26:18,320
now it can be verified that the sum of

697
00:26:18,320 --> 00:26:22,559
all of these shares c1 through c7

698
00:26:22,559 --> 00:26:25,039
gives like gives the terms only

699
00:26:25,039 --> 00:26:26,960
corresponding to the cross products

700
00:26:26,960 --> 00:26:29,200
between the input shares

701
00:26:29,200 --> 00:26:31,919
and here we can we have we can count 18

702
00:26:31,919 --> 00:26:33,840
operations of multiplications by a

703
00:26:33,840 --> 00:26:36,000
constant but we only have seven

704
00:26:36,000 --> 00:26:38,320
multiplications between variables which

705
00:26:38,320 --> 00:26:40,240
are linear combinations between input

706
00:26:40,240 --> 00:26:41,520
shares

707
00:26:41,520 --> 00:26:43,440
now in a regular multiplication gadget

708
00:26:43,440 --> 00:26:45,120
we would have nine multiplications

709
00:26:45,120 --> 00:26:47,600
between variables which corresponds to

710
00:26:47,600 --> 00:26:51,200
the quadratic term n squared

711
00:26:51,200 --> 00:26:52,880
now in the original work from crypto

712
00:26:52,880 --> 00:26:57,919
2017 the r1 and s1 random values are not

713
00:26:57,919 --> 00:27:00,320
used which is why the authors had two

714
00:27:00,320 --> 00:27:02,000
fewer shares of c

715
00:27:02,000 --> 00:27:04,240
but in our case we needed these extra

716
00:27:04,240 --> 00:27:06,559
random values in order to achieve the

717
00:27:06,559 --> 00:27:08,480
maximal amplification order for the

718
00:27:08,480 --> 00:27:11,520
expansion security

719
00:27:12,720 --> 00:27:15,039
now for a number of shares n

720
00:27:15,039 --> 00:27:17,600
the sub multiplication gadget uses 2n

721
00:27:17,600 --> 00:27:20,399
random values and outputs to n plus one

722
00:27:20,399 --> 00:27:21,919
shares

723
00:27:21,919 --> 00:27:23,520
it performs two n plus one

724
00:27:23,520 --> 00:27:25,760
multiplication operations which is

725
00:27:25,760 --> 00:27:27,360
linear in n

726
00:27:27,360 --> 00:27:29,840
at the expense of performing a quadratic

727
00:27:29,840 --> 00:27:32,720
number of multiplications by constants

728
00:27:32,720 --> 00:27:35,039
now in a general manner multiplications

729
00:27:35,039 --> 00:27:38,399
by constant are much less less expensive

730
00:27:38,399 --> 00:27:41,520
than regular multiplications

731
00:27:41,520 --> 00:27:43,440
in our work we prove that this

732
00:27:43,440 --> 00:27:46,000
construction is rpe secure

733
00:27:46,000 --> 00:27:47,919
given that we have the right choice of

734
00:27:47,919 --> 00:27:50,640
constants in the matrix gamma

735
00:27:50,640 --> 00:27:53,279
now if the field is large enough uh we

736
00:27:53,279 --> 00:27:55,360
prove that gamma can be for instance

737
00:27:55,360 --> 00:27:57,679
chosen uniformly at random from the

738
00:27:57,679 --> 00:28:00,000
underlying field otherwise we would need

739
00:28:00,000 --> 00:28:03,840
to find explicit constructions

740
00:28:04,480 --> 00:28:06,080
now after constructing the

741
00:28:06,080 --> 00:28:08,640
sub-multiplication gadget we need to

742
00:28:08,640 --> 00:28:10,399
construct the following compression

743
00:28:10,399 --> 00:28:12,000
gadget

744
00:28:12,000 --> 00:28:14,720
now in the work from crypto 2017

745
00:28:14,720 --> 00:28:16,640
the authors also propose a compression

746
00:28:16,640 --> 00:28:19,039
gadget from end to end shares and claim

747
00:28:19,039 --> 00:28:21,679
it to be secure in the probing model

748
00:28:21,679 --> 00:28:23,520
we actually argue that the constructed

749
00:28:23,520 --> 00:28:25,520
gadget is not secure for the rpe

750
00:28:25,520 --> 00:28:26,559
strategy

751
00:28:26,559 --> 00:28:28,480
and is actually not even secure in the

752
00:28:28,480 --> 00:28:31,039
prep in the probing model as claimed

753
00:28:31,039 --> 00:28:32,880
now for this reason we needed to

754
00:28:32,880 --> 00:28:35,200
construct a new compression gadget which

755
00:28:35,200 --> 00:28:37,919
satisfies our needs

756
00:28:37,919 --> 00:28:39,600
now the proposed compression gadget has

757
00:28:39,600 --> 00:28:42,000
a simple conception and is based on a

758
00:28:42,000 --> 00:28:43,440
refresh gadget

759
00:28:43,440 --> 00:28:46,480
the idea is to refresh the input i am

760
00:28:46,480 --> 00:28:47,760
sharing

761
00:28:47,760 --> 00:28:50,480
using a certain refresh gadget and then

762
00:28:50,480 --> 00:28:52,960
output the sharewise addition of the

763
00:28:52,960 --> 00:28:55,200
refreshed output

764
00:28:55,200 --> 00:28:57,120
when it is split into different

765
00:28:57,120 --> 00:29:00,080
consecutive groups of n shares

766
00:29:00,080 --> 00:29:03,039
so in total we would have m over n

767
00:29:03,039 --> 00:29:05,440
groups of n shares

768
00:29:05,440 --> 00:29:08,000
and this compresses the m shares into n

769
00:29:08,000 --> 00:29:09,919
shares and the security of the

770
00:29:09,919 --> 00:29:12,159
compression gadget largely depends on

771
00:29:12,159 --> 00:29:15,120
the security of the refresh gadget so

772
00:29:15,120 --> 00:29:18,880
the refresh gadget with input m shares

773
00:29:18,880 --> 00:29:21,360
now we you have to recall that

774
00:29:21,360 --> 00:29:23,120
basing the construction of complex

775
00:29:23,120 --> 00:29:24,960
gadgets on refresh gadgets is very

776
00:29:24,960 --> 00:29:26,799
convenient since refresh gadgets are

777
00:29:26,799 --> 00:29:29,279
smaller and thus proving the security is

778
00:29:29,279 --> 00:29:30,720
much easier

779
00:29:30,720 --> 00:29:32,000
so in addition there are some

780
00:29:32,000 --> 00:29:34,000
verification tools which automatically

781
00:29:34,000 --> 00:29:36,559
verifies the security of small gadgets

782
00:29:36,559 --> 00:29:38,799
and which can be easily executed on

783
00:29:38,799 --> 00:29:40,880
small refresh gadgets instead of more

784
00:29:40,880 --> 00:29:42,720
complex gadgets like compression or

785
00:29:42,720 --> 00:29:46,000
addition or copy

786
00:29:48,159 --> 00:29:50,159
so the complexity of the new compression

787
00:29:50,159 --> 00:29:52,240
is almost equal to the complexity of the

788
00:29:52,240 --> 00:29:54,720
underlying refresh gadget plus m

789
00:29:54,720 --> 00:29:56,640
addition operations

790
00:29:56,640 --> 00:29:58,880
for instance using the n log n refresh

791
00:29:58,880 --> 00:30:00,000
gadget

792
00:30:00,000 --> 00:30:01,360
we would have

793
00:30:01,360 --> 00:30:03,840
with the complexity of m log n

794
00:30:03,840 --> 00:30:05,200
like the compression would have a

795
00:30:05,200 --> 00:30:07,360
complexity of m log n

796
00:30:07,360 --> 00:30:08,960
and we prove that this refresh can be

797
00:30:08,960 --> 00:30:10,720
safely used for the conf for the

798
00:30:10,720 --> 00:30:13,039
compression in our case

799
00:30:13,039 --> 00:30:15,600
now with m being linear in the number of

800
00:30:15,600 --> 00:30:17,440
shares n using the sub multiplication

801
00:30:17,440 --> 00:30:19,039
gadget from before

802
00:30:19,039 --> 00:30:21,200
we get a compression gadget with kazi

803
00:30:21,200 --> 00:30:22,720
linear complexity in the number of

804
00:30:22,720 --> 00:30:26,000
shares and which is secure

805
00:30:26,000 --> 00:30:27,279
in the global construction of the

806
00:30:27,279 --> 00:30:28,880
multiplication gadget when it is

807
00:30:28,880 --> 00:30:30,559
composed with a sub multiplication

808
00:30:30,559 --> 00:30:32,559
gadget

809
00:30:32,559 --> 00:30:34,399
now finally

810
00:30:34,399 --> 00:30:36,559
using this compression gadget and the

811
00:30:36,559 --> 00:30:39,200
previous sub-multiplication gadget

812
00:30:39,200 --> 00:30:40,640
we can see that their composition

813
00:30:40,640 --> 00:30:42,720
provides a multiplication gadget which

814
00:30:42,720 --> 00:30:44,480
performs a linear number of

815
00:30:44,480 --> 00:30:48,080
multiplications between variables

816
00:30:48,080 --> 00:30:50,559
and which has a kazi linear randomness

817
00:30:50,559 --> 00:30:52,000
complexity

818
00:30:52,000 --> 00:30:53,679
now this gadget is

819
00:30:53,679 --> 00:30:56,320
proven to be also rpe secure

820
00:30:56,320 --> 00:30:58,320
and achieves the maximal amplification

821
00:30:58,320 --> 00:31:00,559
order of n plus one over two which is

822
00:31:00,559 --> 00:31:02,799
exactly what we were looking to achieve

823
00:31:02,799 --> 00:31:05,840
in the first place

824
00:31:06,080 --> 00:31:08,880
so to sum up we constructed the linear

825
00:31:08,880 --> 00:31:11,120
gadgets along with a new multiplication

826
00:31:11,120 --> 00:31:13,440
by a constant gadget all with the kazoo

827
00:31:13,440 --> 00:31:15,440
linear complexity

828
00:31:15,440 --> 00:31:17,840
we also constructed a new multiplication

829
00:31:17,840 --> 00:31:19,519
gadget with a linear number of

830
00:31:19,519 --> 00:31:21,919
multiplications operations

831
00:31:21,919 --> 00:31:23,760
and all of the above gadgets achieve an

832
00:31:23,760 --> 00:31:26,000
amplification order of n plus 1 over 2

833
00:31:26,000 --> 00:31:28,240
which is the maximal order

834
00:31:28,240 --> 00:31:30,799
now to plug all of this data into the

835
00:31:30,799 --> 00:31:32,559
asymptotic complexity of the

836
00:31:32,559 --> 00:31:34,799
corresponding rpe compiler

837
00:31:34,799 --> 00:31:36,480
we need to consider the asymptotic

838
00:31:36,480 --> 00:31:39,120
complexity formula which expresses in

839
00:31:39,120 --> 00:31:41,120
terms of the size of the circuit to be

840
00:31:41,120 --> 00:31:43,200
compiled and kappa to the power e where

841
00:31:43,200 --> 00:31:44,840
kappa is the security

842
00:31:44,840 --> 00:31:47,440
parameter now from the definition of

843
00:31:47,440 --> 00:31:50,640
nmax as defined earlier we get that its

844
00:31:50,640 --> 00:31:53,360
asymptotic value is actually kazi linear

845
00:31:53,360 --> 00:31:55,279
in the number of shares

846
00:31:55,279 --> 00:31:57,519
if we use our gadgets

847
00:31:57,519 --> 00:32:00,559
so e would be a fraction of big o of n

848
00:32:00,559 --> 00:32:03,200
log n over the amplification order of n

849
00:32:03,200 --> 00:32:06,080
plus one over two

850
00:32:06,480 --> 00:32:08,000
now in this figure we compare the

851
00:32:08,000 --> 00:32:10,159
asymptotic complexity exponent of our

852
00:32:10,159 --> 00:32:12,640
new compiler which is the pink curve

853
00:32:12,640 --> 00:32:14,640
and the previously best compiler in

854
00:32:14,640 --> 00:32:16,720
terms of asymptotic complexity with

855
00:32:16,720 --> 00:32:19,120
respect to the number of shares

856
00:32:19,120 --> 00:32:21,039
now while the best construction which is

857
00:32:21,039 --> 00:32:24,480
from eurocrypt 2021 achieves values for

858
00:32:24,480 --> 00:32:26,799
e close to three for near reasonable

859
00:32:26,799 --> 00:32:30,240
number of shares our new compiler

860
00:32:30,240 --> 00:32:32,159
quickly achieves a sub quadratic

861
00:32:32,159 --> 00:32:34,559
complexity in the same settings

862
00:32:34,559 --> 00:32:36,640
and the interesting thing is that in

863
00:32:36,640 --> 00:32:38,640
this case our compiler doesn't need to

864
00:32:38,640 --> 00:32:41,039
tolerate a good leakage rate in the

865
00:32:41,039 --> 00:32:42,880
random probing model because we can

866
00:32:42,880 --> 00:32:45,120
start the expansion with a specific

867
00:32:45,120 --> 00:32:46,960
small shares construction which

868
00:32:46,960 --> 00:32:48,880
tolerates a very good rate but which can

869
00:32:48,880 --> 00:32:50,640
have higher complexity

870
00:32:50,640 --> 00:32:52,240
and then continue on with our new

871
00:32:52,240 --> 00:32:54,640
compiler in order to have good overall

872
00:32:54,640 --> 00:32:57,840
asymptotic complexity

873
00:32:59,200 --> 00:33:01,600
so to conclude in this work uh we

874
00:33:01,600 --> 00:33:03,519
provide a new construction of an rpe

875
00:33:03,519 --> 00:33:05,600
compiler with the kazi linear asymptotic

876
00:33:05,600 --> 00:33:06,880
complexity

877
00:33:06,880 --> 00:33:09,279
the construction uses linear gadgets of

878
00:33:09,279 --> 00:33:11,279
add copy and multiplication by a

879
00:33:11,279 --> 00:33:14,159
constant with gazillionaire complexity

880
00:33:14,159 --> 00:33:15,919
and a new multiplication gadget with

881
00:33:15,919 --> 00:33:18,240
gasoline randomness complexity and a

882
00:33:18,240 --> 00:33:19,840
linear number of multiplications

883
00:33:19,840 --> 00:33:21,440
operations

884
00:33:21,440 --> 00:33:23,679
this compiler fits perfectly into the

885
00:33:23,679 --> 00:33:26,159
dynamic rpe approach that we introduce

886
00:33:26,159 --> 00:33:27,519
and which is proven to be more

887
00:33:27,519 --> 00:33:29,919
interesting than a static approach

888
00:33:29,919 --> 00:33:32,000
to get the best of both worlds we start

889
00:33:32,000 --> 00:33:34,240
the expansion with an rpe compiler which

890
00:33:34,240 --> 00:33:35,760
tolerates a good leakage rate with a

891
00:33:35,760 --> 00:33:37,519
small number of shares

892
00:33:37,519 --> 00:33:40,399
then continue on with an asymptotic rpe

893
00:33:40,399 --> 00:33:42,720
compiler which have better asymptotic

894
00:33:42,720 --> 00:33:44,480
complexity and does not necessarily

895
00:33:44,480 --> 00:33:47,600
tolerate a good leakage rate

896
00:33:47,600 --> 00:33:49,120
now since the question to the second

897
00:33:49,120 --> 00:33:50,960
part of the dynamic expansion have been

898
00:33:50,960 --> 00:33:53,039
partially answered in this work

899
00:33:53,039 --> 00:33:54,720
one of the natural

900
00:33:54,720 --> 00:33:57,360
future works would be to find gadgets

901
00:33:57,360 --> 00:33:59,360
with small number of shares for example

902
00:33:59,360 --> 00:34:00,480
three shares

903
00:34:00,480 --> 00:34:02,240
which can tolerate the best leakage rate

904
00:34:02,240 --> 00:34:04,480
possible and define what is this best

905
00:34:04,480 --> 00:34:07,120
leakage rate possible

906
00:34:07,120 --> 00:34:08,960
this would be the end of my presentation

907
00:34:08,960 --> 00:34:10,320
and i would like to thank you all for

908
00:34:10,320 --> 00:34:13,560
your attention

