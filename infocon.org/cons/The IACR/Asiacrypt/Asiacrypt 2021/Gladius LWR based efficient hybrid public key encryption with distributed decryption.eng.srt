1
00:00:02,399 --> 00:00:04,480
greetings

2
00:00:04,480 --> 00:00:07,200
in this talk i will be talking about

3
00:00:07,200 --> 00:00:08,480
gladius

4
00:00:08,480 --> 00:00:11,360
our lwr based hybrid cipher which

5
00:00:11,360 --> 00:00:15,280
supports fast distributed decryption

6
00:00:15,280 --> 00:00:18,880
this is work by gran kong myself baron

7
00:00:18,880 --> 00:00:23,198
maran and professor nigel smart

8
00:00:24,320 --> 00:00:25,119
so

9
00:00:25,119 --> 00:00:28,000
securely distributing decryption means

10
00:00:28,000 --> 00:00:30,560
that

11
00:00:30,560 --> 00:00:34,399
several distrustful parties want to

12
00:00:34,399 --> 00:00:38,239
jointly decrypt some ciphertext

13
00:00:38,239 --> 00:00:39,040
and

14
00:00:39,040 --> 00:00:42,000
the way you do that is by secret sharing

15
00:00:42,000 --> 00:00:44,480
the key among the parties so each party

16
00:00:44,480 --> 00:00:45,360
will

17
00:00:45,360 --> 00:00:48,079
hold a secret shot of the secret key

18
00:00:48,079 --> 00:00:51,440
and by that you can define

19
00:00:51,440 --> 00:00:53,920
some access structure so for example if

20
00:00:53,920 --> 00:00:56,640
you have a

21
00:00:56,840 --> 00:01:00,320
threshold then it means that

22
00:01:00,320 --> 00:01:04,080
any subset of at least the parties can

23
00:01:04,080 --> 00:01:06,479
use the shares and recover the secret

24
00:01:06,479 --> 00:01:07,840
key

25
00:01:07,840 --> 00:01:11,040
so those are the qualified parties

26
00:01:11,040 --> 00:01:13,280
and on the other hand less than tea

27
00:01:13,280 --> 00:01:14,720
parties

28
00:01:14,720 --> 00:01:17,360
uh can't use their shares in

29
00:01:17,360 --> 00:01:19,600
any way so those are the unqualified

30
00:01:19,600 --> 00:01:21,600
practice

31
00:01:21,600 --> 00:01:24,080
so the parties with the shares engage in

32
00:01:24,080 --> 00:01:25,200
a protocol

33
00:01:25,200 --> 00:01:27,600
which implements the

34
00:01:27,600 --> 00:01:30,159
decryption functionality

35
00:01:30,159 --> 00:01:31,040
and

36
00:01:31,040 --> 00:01:33,119
since they are

37
00:01:33,119 --> 00:01:34,960
they don't trust each other the

38
00:01:34,960 --> 00:01:38,720
communication has to be secured

39
00:01:38,720 --> 00:01:41,280
so intuitively this means that

40
00:01:41,280 --> 00:01:44,159
the protocol should be as secure as the

41
00:01:44,159 --> 00:01:47,920
pre primitive that it implements

42
00:01:47,920 --> 00:01:51,360
so for example if the

43
00:01:51,360 --> 00:01:55,360
underlying encryption scheme is in cca

44
00:01:55,360 --> 00:01:58,000
security means that

45
00:01:58,000 --> 00:02:00,079
an adversary was given access to the

46
00:02:00,079 --> 00:02:02,719
decryption oracle

47
00:02:02,719 --> 00:02:05,040
shouldn't be able to distinguish between

48
00:02:05,040 --> 00:02:06,880
cipher texts

49
00:02:06,880 --> 00:02:09,119
without processing

50
00:02:09,119 --> 00:02:10,878
the secret key

51
00:02:10,878 --> 00:02:12,400
and similarly

52
00:02:12,400 --> 00:02:15,120
at the level of the protocol the

53
00:02:15,120 --> 00:02:17,040
adversary

54
00:02:17,040 --> 00:02:20,400
that controls some unqualified party and

55
00:02:20,400 --> 00:02:23,680
is given access to the decryption

56
00:02:23,680 --> 00:02:25,920
oracle

57
00:02:25,920 --> 00:02:29,040
coming from the functionality

58
00:02:29,040 --> 00:02:31,040
shouldn't be able to distinguish between

59
00:02:31,040 --> 00:02:33,200
cipher texts without

60
00:02:33,200 --> 00:02:37,839
possessing the qualified parties shares

61
00:02:39,280 --> 00:02:42,000
so we want to construct a public key

62
00:02:42,000 --> 00:02:43,920
encryption

63
00:02:43,920 --> 00:02:46,239
for which we can implement the

64
00:02:46,239 --> 00:02:49,120
decryption algorithm

65
00:02:49,120 --> 00:02:51,760
using a secure protocol and we want to

66
00:02:51,760 --> 00:02:54,160
do that efficiently

67
00:02:54,160 --> 00:02:56,000
so we start by

68
00:02:56,000 --> 00:02:58,080
fixing some requirements from the

69
00:02:58,080 --> 00:03:00,000
underlying primitive

70
00:03:00,000 --> 00:03:01,920
so the public encryption should be

71
00:03:01,920 --> 00:03:04,400
insisted secure

72
00:03:04,400 --> 00:03:06,159
should be pass quantum

73
00:03:06,159 --> 00:03:07,280
and

74
00:03:07,280 --> 00:03:09,440
should be able to encrypt messages of

75
00:03:09,440 --> 00:03:12,080
any length

76
00:03:12,080 --> 00:03:13,280
so

77
00:03:13,280 --> 00:03:15,920
what we are really looking for is an

78
00:03:15,920 --> 00:03:19,399
hybrid construction

79
00:03:19,599 --> 00:03:22,720
so in an hybrid construction it is not

80
00:03:22,720 --> 00:03:24,319
enough

81
00:03:24,319 --> 00:03:27,040
to design a fast distributed decryption

82
00:03:27,040 --> 00:03:29,840
for the cam part only because the cam

83
00:03:29,840 --> 00:03:33,120
part is embedded in a larger

84
00:03:33,120 --> 00:03:35,920
circuit and the other components

85
00:03:35,920 --> 00:03:39,760
might be quite expensive for

86
00:03:39,760 --> 00:03:42,319
for distributed computing

87
00:03:42,319 --> 00:03:43,360
and

88
00:03:43,360 --> 00:03:44,640
indeed

89
00:03:44,640 --> 00:03:46,879
it has been an open problem for quite a

90
00:03:46,879 --> 00:03:50,720
long that of having uh and on hybrids

91
00:03:50,720 --> 00:03:53,760
constructing constructing and hybrid

92
00:03:53,760 --> 00:03:55,920
um

93
00:03:55,920 --> 00:03:57,439
having the

94
00:03:57,439 --> 00:04:00,959
the wall decryption circuit optimized

95
00:04:00,959 --> 00:04:05,360
for multi-party computation techniques

96
00:04:05,360 --> 00:04:08,000
in this paper we tried to solve this

97
00:04:08,000 --> 00:04:10,159
problem

98
00:04:10,159 --> 00:04:11,920
so

99
00:04:11,920 --> 00:04:14,720
the most famous hybrid is that from

100
00:04:14,720 --> 00:04:17,120
grammar shoop

101
00:04:17,120 --> 00:04:18,959
it combines a chem

102
00:04:18,959 --> 00:04:21,759
and a them into

103
00:04:21,759 --> 00:04:24,479
a public encryption

104
00:04:24,479 --> 00:04:27,280
key generation is

105
00:04:27,280 --> 00:04:29,360
that from the can

106
00:04:29,360 --> 00:04:31,919
and to encrypt a message

107
00:04:31,919 --> 00:04:35,600
you first generate a small session key

108
00:04:35,600 --> 00:04:38,960
you encrypt you encapsulate it using the

109
00:04:38,960 --> 00:04:41,120
can on the public key

110
00:04:41,120 --> 00:04:43,919
and this will form the first cipher text

111
00:04:43,919 --> 00:04:45,680
while the message is efficiently

112
00:04:45,680 --> 00:04:48,560
encrypted with the demo component using

113
00:04:48,560 --> 00:04:49,919
the session key

114
00:04:49,919 --> 00:04:52,160
and this will be the second

115
00:04:52,160 --> 00:04:54,800
cipher text

116
00:04:54,800 --> 00:04:58,160
with that decryption is quite obvious so

117
00:04:58,160 --> 00:05:00,880
you first encapsulate k

118
00:05:00,880 --> 00:05:03,680
from this ciphertext and you will use

119
00:05:03,680 --> 00:05:06,080
the session key to decrypt the second

120
00:05:06,080 --> 00:05:10,479
ciphertext and get the message

121
00:05:10,479 --> 00:05:11,280
so

122
00:05:11,280 --> 00:05:13,679
we get

123
00:05:14,880 --> 00:05:17,039
in cca security

124
00:05:17,039 --> 00:05:20,400
if we start with ncca components

125
00:05:20,400 --> 00:05:22,840
and we are able to encrypt

126
00:05:22,840 --> 00:05:24,639
messages

127
00:05:24,639 --> 00:05:25,440
of

128
00:05:25,440 --> 00:05:27,840
any length because we can

129
00:05:27,840 --> 00:05:30,080
simply

130
00:05:30,080 --> 00:05:31,600
use any

131
00:05:31,600 --> 00:05:32,720
symmetric

132
00:05:32,720 --> 00:05:37,199
key cipher in a mode of operation

133
00:05:37,199 --> 00:05:39,680
the problem it comes when we try to

134
00:05:39,680 --> 00:05:43,600
distribute the decryption algorithm

135
00:05:43,600 --> 00:05:45,759
so everything that involves the secret

136
00:05:45,759 --> 00:05:48,400
key needs to be implemented as a secure

137
00:05:48,400 --> 00:05:50,720
protocol

138
00:05:50,720 --> 00:05:52,240
so

139
00:05:52,240 --> 00:05:54,960
we start by securely computing the

140
00:05:54,960 --> 00:05:57,840
capsulation

141
00:05:57,840 --> 00:05:59,919
and the result secret key

142
00:05:59,919 --> 00:06:00,800
is

143
00:06:00,800 --> 00:06:03,840
should still be kept secret

144
00:06:03,840 --> 00:06:06,960
and this means that we also need to

145
00:06:06,960 --> 00:06:08,800
implement a secure protocol the

146
00:06:08,800 --> 00:06:11,600
decryption of the dam

147
00:06:11,600 --> 00:06:14,560
now this last step is the problem

148
00:06:14,560 --> 00:06:16,479
especially for long messages when you

149
00:06:16,479 --> 00:06:18,160
are using

150
00:06:18,160 --> 00:06:20,400
um

151
00:06:20,400 --> 00:06:23,840
i don't know aes in a mode of operation

152
00:06:23,840 --> 00:06:27,600
uh the decryption under general

153
00:06:27,600 --> 00:06:30,400
multi-party computation techniques is

154
00:06:30,400 --> 00:06:32,639
quite expensive

155
00:06:32,639 --> 00:06:36,000
so it would be great if we

156
00:06:36,000 --> 00:06:39,919
avoided this last step

157
00:06:39,919 --> 00:06:40,960
so

158
00:06:40,960 --> 00:06:42,560
the native idea

159
00:06:42,560 --> 00:06:43,360
is

160
00:06:43,360 --> 00:06:46,080
to just simply

161
00:06:46,080 --> 00:06:49,360
release this the session key

162
00:06:49,360 --> 00:06:50,960
make it public

163
00:06:50,960 --> 00:06:53,039
so that we can perform the decryption

164
00:06:53,039 --> 00:06:56,639
over clear data so no need of any

165
00:06:56,639 --> 00:06:59,360
uh secure protocol

166
00:06:59,360 --> 00:07:02,560
what i mean is that once we get

167
00:07:02,560 --> 00:07:04,880
the secret shinky we just

168
00:07:04,880 --> 00:07:06,160
reveal it

169
00:07:06,160 --> 00:07:09,199
so we can perform the decryption

170
00:07:09,199 --> 00:07:12,720
uh over clear data

171
00:07:12,880 --> 00:07:13,919
and

172
00:07:13,919 --> 00:07:15,680
yeah the problem is that there is an

173
00:07:15,680 --> 00:07:18,479
obvious cca attack because an adversary

174
00:07:18,479 --> 00:07:20,319
you get

175
00:07:20,319 --> 00:07:22,160
the challenge so you want to start c to

176
00:07:22,160 --> 00:07:23,199
star

177
00:07:23,199 --> 00:07:25,039
then forms this

178
00:07:25,039 --> 00:07:28,080
cipher text c1 star c2 where c2 is a

179
00:07:28,080 --> 00:07:31,360
completely random ciphertext

180
00:07:31,360 --> 00:07:32,639
and

181
00:07:32,639 --> 00:07:35,440
he queries the decryption oracle on this

182
00:07:35,440 --> 00:07:37,840
ciphertext which is allowed because it

183
00:07:37,840 --> 00:07:39,759
is different from

184
00:07:39,759 --> 00:07:42,400
the challenge

185
00:07:42,400 --> 00:07:46,560
so let's look let's see what happens on

186
00:07:46,560 --> 00:07:47,440
uh

187
00:07:47,440 --> 00:07:49,039
when it requires

188
00:07:49,039 --> 00:07:51,360
the oracle so the first component will

189
00:07:51,360 --> 00:07:54,720
be correctly decrypted by definition

190
00:07:54,720 --> 00:07:56,160
and

191
00:07:56,160 --> 00:07:57,120
yeah

192
00:07:57,120 --> 00:07:59,120
following our strategy the

193
00:07:59,120 --> 00:08:01,199
the the session key will be really

194
00:08:01,199 --> 00:08:02,479
revealed

195
00:08:02,479 --> 00:08:03,680
and

196
00:08:03,680 --> 00:08:05,759
yeah the second component probably will

197
00:08:05,759 --> 00:08:09,840
result in an error because it's random

198
00:08:09,840 --> 00:08:12,240
some something completely random so the

199
00:08:12,240 --> 00:08:15,440
adversary high probability will get

200
00:08:15,440 --> 00:08:17,520
the valid session key and an error

201
00:08:17,520 --> 00:08:20,879
message whatever the second component is

202
00:08:20,879 --> 00:08:22,800
so we will just use the session key to

203
00:08:22,800 --> 00:08:24,840
decrypt the second

204
00:08:24,840 --> 00:08:29,280
challenge and get the full message so

205
00:08:29,280 --> 00:08:32,959
security is completely broken

206
00:08:33,279 --> 00:08:35,519
now

207
00:08:37,039 --> 00:08:38,640
our

208
00:08:38,640 --> 00:08:41,599
our hybrid our proposal comes from

209
00:08:41,599 --> 00:08:45,360
is the result of trying to fix this um

210
00:08:45,360 --> 00:08:47,040
security flow

211
00:08:47,040 --> 00:08:49,519
and yeah this is what we

212
00:08:49,519 --> 00:08:52,720
propose our high reconstruction

213
00:08:52,720 --> 00:08:55,839
again we are combining a public key

214
00:08:55,839 --> 00:09:00,000
encryption with a symmetric encryption

215
00:09:00,000 --> 00:09:01,360
uh

216
00:09:01,360 --> 00:09:04,800
it's very similar to claroshope

217
00:09:04,800 --> 00:09:06,560
and the difference is we are using a

218
00:09:06,560 --> 00:09:10,000
secure hash function here

219
00:09:10,000 --> 00:09:13,760
so after generating a session key

220
00:09:13,760 --> 00:09:16,320
encapsulating it and

221
00:09:16,320 --> 00:09:18,480
after the encryption of the message we

222
00:09:18,480 --> 00:09:21,519
authenticate the session key using this

223
00:09:21,519 --> 00:09:24,240
hash function so we are linking k to the

224
00:09:24,240 --> 00:09:27,519
second cipher text

225
00:09:28,080 --> 00:09:30,160
as a result we get an additional cipher

226
00:09:30,160 --> 00:09:32,959
text here

227
00:09:33,120 --> 00:09:36,240
the effect of this on the decryption

228
00:09:36,240 --> 00:09:38,560
algorithm is that

229
00:09:38,560 --> 00:09:40,320
we will need to

230
00:09:40,320 --> 00:09:41,839
perform

231
00:09:41,839 --> 00:09:45,600
a verification of the hash

232
00:09:45,600 --> 00:09:47,839
so

233
00:09:48,880 --> 00:09:53,519
if this uh verification passes

234
00:09:53,519 --> 00:09:57,200
namely evaluating g over c2 and k will

235
00:09:57,200 --> 00:10:00,800
produces the third ciphertext

236
00:10:00,800 --> 00:10:02,320
then we will

237
00:10:02,320 --> 00:10:05,440
reveal we will broadcast k along with

238
00:10:05,440 --> 00:10:08,000
the message

239
00:10:08,000 --> 00:10:10,399
otherwise we will return just

240
00:10:10,399 --> 00:10:13,440
an error message

241
00:10:14,480 --> 00:10:15,839
probably you

242
00:10:15,839 --> 00:10:17,760
already guessed

243
00:10:17,760 --> 00:10:19,680
that

244
00:10:19,680 --> 00:10:24,160
by using a hash function this way

245
00:10:25,519 --> 00:10:27,680
we are basically preventing the previous

246
00:10:27,680 --> 00:10:29,440
attack

247
00:10:29,440 --> 00:10:30,800
indeed

248
00:10:30,800 --> 00:10:32,800
if the adversary follows the previous

249
00:10:32,800 --> 00:10:37,360
strategy so by submitting something like

250
00:10:37,360 --> 00:10:41,200
a challenge and other random stuff

251
00:10:41,200 --> 00:10:43,200
then with high probability the

252
00:10:43,200 --> 00:10:47,200
verification here will fail

253
00:10:47,200 --> 00:10:48,399
and

254
00:10:48,399 --> 00:10:52,079
the adversary will get nothing

255
00:10:52,720 --> 00:10:54,560
so the only way for the adversary to get

256
00:10:54,560 --> 00:10:56,800
the session key

257
00:10:56,800 --> 00:10:58,720
is either of course submitting the

258
00:10:58,720 --> 00:11:00,800
challenge but this is not allowed

259
00:11:00,800 --> 00:11:01,600
or

260
00:11:01,600 --> 00:11:03,680
by finding a collision in the hash

261
00:11:03,680 --> 00:11:06,079
function

262
00:11:08,079 --> 00:11:09,760
so the previous attack

263
00:11:09,760 --> 00:11:11,920
is prevented

264
00:11:11,920 --> 00:11:13,519
also notice

265
00:11:13,519 --> 00:11:15,040
that

266
00:11:15,040 --> 00:11:17,920
by placing on a hash function here

267
00:11:17,920 --> 00:11:19,839
and authenticating k

268
00:11:19,839 --> 00:11:21,920
here

269
00:11:21,920 --> 00:11:24,160
we have the following advantage that we

270
00:11:24,160 --> 00:11:27,040
don't need the randomness from our

271
00:11:27,040 --> 00:11:28,720
public encryption

272
00:11:28,720 --> 00:11:31,600
and indeed we can just use a

273
00:11:31,600 --> 00:11:35,600
deterministic public key encryption

274
00:11:35,600 --> 00:11:37,360
well it should be

275
00:11:37,360 --> 00:11:38,800
still

276
00:11:38,800 --> 00:11:41,279
secure enough just to prevent some brute

277
00:11:41,279 --> 00:11:44,880
force attacks on the first ciphertext

278
00:11:44,880 --> 00:11:46,880
so the right

279
00:11:46,880 --> 00:11:49,680
security notion we are interested in is

280
00:11:49,680 --> 00:11:51,839
one-way cpa

281
00:11:51,839 --> 00:11:54,240
so putting everything together we are

282
00:11:54,240 --> 00:11:58,639
able to prove that

283
00:11:58,800 --> 00:12:01,920
leaking the key this way

284
00:12:01,920 --> 00:12:04,399
is still it is secure produces something

285
00:12:04,399 --> 00:12:06,240
secure namely

286
00:12:06,240 --> 00:12:07,839
if we start with a one-way cpa

287
00:12:07,839 --> 00:12:11,040
deterministic public key encryption and

288
00:12:11,040 --> 00:12:14,399
a one-time ncpa symmetric encryption

289
00:12:14,399 --> 00:12:16,880
then we will get

290
00:12:16,880 --> 00:12:19,200
a public encryption which is in cca

291
00:12:19,200 --> 00:12:23,200
secure in the random oracle model

292
00:12:23,200 --> 00:12:26,320
now let's go to the

293
00:12:26,320 --> 00:12:27,519
protocol

294
00:12:27,519 --> 00:12:29,120
secure protocol that implements the

295
00:12:29,120 --> 00:12:32,480
distributed decryption of this hybrid

296
00:12:32,480 --> 00:12:34,560
so this is a picture that gives you the

297
00:12:34,560 --> 00:12:37,440
idea of what should be performed in a

298
00:12:37,440 --> 00:12:39,600
secure way

299
00:12:39,600 --> 00:12:41,920
um so everything that involves the

300
00:12:41,920 --> 00:12:43,519
secret key or

301
00:12:43,519 --> 00:12:46,000
the session key

302
00:12:46,000 --> 00:12:49,120
should be done securely so these

303
00:12:49,120 --> 00:12:52,320
operations are marked with threatened

304
00:12:52,320 --> 00:12:53,200
so

305
00:12:53,200 --> 00:12:55,519
first we decrypt the first ciphertext

306
00:12:55,519 --> 00:12:57,760
using the secret key the result is the

307
00:12:57,760 --> 00:13:00,399
session key which is still secret which

308
00:13:00,399 --> 00:13:02,160
is then passed to the

309
00:13:02,160 --> 00:13:04,959
hash function g which will

310
00:13:04,959 --> 00:13:08,240
verify that the session key comes from a

311
00:13:08,240 --> 00:13:11,040
valid encryption

312
00:13:11,040 --> 00:13:14,480
and if this verification

313
00:13:14,480 --> 00:13:18,639
passes then we are able to

314
00:13:18,839 --> 00:13:22,320
leak broadcast the session key

315
00:13:22,320 --> 00:13:23,279
and

316
00:13:23,279 --> 00:13:25,839
pass it to the decryption and execute

317
00:13:25,839 --> 00:13:28,480
this decryption the clear the

318
00:13:28,480 --> 00:13:30,639
decrypting the second component the

319
00:13:30,639 --> 00:13:34,000
ciphertext don't get the message

320
00:13:34,000 --> 00:13:36,160
now

321
00:13:36,160 --> 00:13:37,519
in order for

322
00:13:37,519 --> 00:13:40,399
this to be efficient as a secure

323
00:13:40,399 --> 00:13:42,959
protocol

324
00:13:43,279 --> 00:13:46,839
we basically need two things

325
00:13:46,839 --> 00:13:48,639
evaluating

326
00:13:48,639 --> 00:13:51,760
efficiently g over secret data

327
00:13:51,760 --> 00:13:53,519
and

328
00:13:53,519 --> 00:13:56,800
evaluating uh performing a secure

329
00:13:56,800 --> 00:13:59,040
protocol efficiently for the public

330
00:13:59,040 --> 00:14:00,880
encryption

331
00:14:00,880 --> 00:14:04,560
so the first

332
00:14:05,360 --> 00:14:07,120
requirement is

333
00:14:07,120 --> 00:14:11,440
can be easily met by using any

334
00:14:11,440 --> 00:14:15,120
mpc friendly function

335
00:14:15,120 --> 00:14:16,800
as a g so

336
00:14:16,800 --> 00:14:19,120
the only thing that is left to do is to

337
00:14:19,120 --> 00:14:21,760
find a good candidate for this public

338
00:14:21,760 --> 00:14:24,399
encryption

339
00:14:26,079 --> 00:14:28,560
so we are

340
00:14:28,560 --> 00:14:30,720
also presenting we are also proposing a

341
00:14:30,720 --> 00:14:33,760
second hybrid

342
00:14:33,760 --> 00:14:36,000
uh which is exactly

343
00:14:36,000 --> 00:14:40,000
the same as before except we now add two

344
00:14:40,000 --> 00:14:42,480
more hash functions one here

345
00:14:42,480 --> 00:14:45,839
and one here producing a fourth cipher

346
00:14:45,839 --> 00:14:48,160
text

347
00:14:48,160 --> 00:14:50,399
and also

348
00:14:50,399 --> 00:14:53,360
we will need to redo this hash functions

349
00:14:53,360 --> 00:14:56,639
evaluations in the um

350
00:14:56,639 --> 00:14:59,760
in the decryption

351
00:14:59,760 --> 00:15:00,560
so

352
00:15:00,560 --> 00:15:05,760
if we do so then the previous statement

353
00:15:06,800 --> 00:15:10,639
holds in the quantum random oracle model

354
00:15:10,639 --> 00:15:13,120
the reason for this is quite technical

355
00:15:13,120 --> 00:15:16,079
and you can find the details in the full

356
00:15:16,079 --> 00:15:19,279
version of the paper

357
00:15:19,920 --> 00:15:22,880
also we can

358
00:15:23,360 --> 00:15:24,800
provide a

359
00:15:24,800 --> 00:15:27,770
general distributed

360
00:15:27,770 --> 00:15:29,120
[Music]

361
00:15:29,120 --> 00:15:31,680
circuit for the decryption of the second

362
00:15:31,680 --> 00:15:32,720
hybrid

363
00:15:32,720 --> 00:15:33,759
which is

364
00:15:33,759 --> 00:15:36,399
similar to the previous one except now

365
00:15:36,399 --> 00:15:38,959
we need to

366
00:15:39,440 --> 00:15:41,680
implement as a protocol these two

367
00:15:41,680 --> 00:15:45,279
additional hash evaluations

368
00:15:45,279 --> 00:15:47,360
so they need to be evaluated over the

369
00:15:47,360 --> 00:15:48,480
secret

370
00:15:48,480 --> 00:15:50,720
session key

371
00:15:50,720 --> 00:15:52,720
so again for

372
00:15:52,720 --> 00:15:54,560
so everything is

373
00:15:54,560 --> 00:15:57,920
almost exactly as before

374
00:15:57,920 --> 00:15:59,279
and

375
00:15:59,279 --> 00:16:00,800
the only things that need to be

376
00:16:00,800 --> 00:16:03,360
implemented as secure protocols are the

377
00:16:03,360 --> 00:16:06,480
decryption and the actual evaluations

378
00:16:06,480 --> 00:16:08,959
for those we can use again npch

379
00:16:08,959 --> 00:16:10,160
functions

380
00:16:10,160 --> 00:16:12,720
and for this we need to find a good

381
00:16:12,720 --> 00:16:14,800
public encryption

382
00:16:14,800 --> 00:16:17,120
for which we can do the encryption

383
00:16:17,120 --> 00:16:21,040
efficiently with a protocol

384
00:16:21,600 --> 00:16:22,560
so

385
00:16:22,560 --> 00:16:24,800
um

386
00:16:25,680 --> 00:16:27,680
what is left to do

387
00:16:27,680 --> 00:16:29,680
is to

388
00:16:29,680 --> 00:16:30,880
find

389
00:16:30,880 --> 00:16:32,720
a public key encryption which is

390
00:16:32,720 --> 00:16:34,560
deterministic

391
00:16:34,560 --> 00:16:39,199
but still one-way cpa is secure

392
00:16:39,519 --> 00:16:41,680
also

393
00:16:41,680 --> 00:16:43,440
we would like it to be

394
00:16:43,440 --> 00:16:46,160
quantum because if we plug something a

395
00:16:46,160 --> 00:16:49,120
pub a public key encryption which is

396
00:16:49,120 --> 00:16:50,480
spot

397
00:16:50,480 --> 00:16:52,320
quantum based on post quantum

398
00:16:52,320 --> 00:16:54,320
assumptions in second hybrid then we

399
00:16:54,320 --> 00:16:56,450
will get

400
00:16:56,450 --> 00:16:57,600
[Music]

401
00:16:57,600 --> 00:16:59,360
we will get

402
00:16:59,360 --> 00:17:00,160
the

403
00:17:00,160 --> 00:17:02,800
in hybrid public key

404
00:17:02,800 --> 00:17:06,400
encryption which is also what's granted

405
00:17:06,400 --> 00:17:07,599
so

406
00:17:07,599 --> 00:17:11,280
the standard way of

407
00:17:11,280 --> 00:17:12,880
having um

408
00:17:12,880 --> 00:17:14,720
of getting a

409
00:17:14,720 --> 00:17:17,439
deterministic public key encryption is

410
00:17:17,439 --> 00:17:20,720
by de-randomizing a probabilistic

411
00:17:20,720 --> 00:17:22,640
encryption

412
00:17:22,640 --> 00:17:24,079
and

413
00:17:24,079 --> 00:17:26,400
there is a technical encrypted hash

414
00:17:26,400 --> 00:17:29,440
which basically takes a

415
00:17:29,440 --> 00:17:31,360
probabilistic end

416
00:17:31,360 --> 00:17:33,520
cpa

417
00:17:33,520 --> 00:17:36,799
public encryption and gives you

418
00:17:36,799 --> 00:17:39,200
a deterministic one-way cpa

419
00:17:39,200 --> 00:17:42,160
public encryption

420
00:17:42,240 --> 00:17:43,760
so

421
00:17:43,760 --> 00:17:45,760
basically you

422
00:17:45,760 --> 00:17:48,320
replace

423
00:17:49,520 --> 00:17:51,679
replace the randomness

424
00:17:51,679 --> 00:17:54,960
with the hash of the message

425
00:17:54,960 --> 00:17:55,840
and

426
00:17:55,840 --> 00:18:00,799
to get the one-way cpa security you

427
00:18:00,799 --> 00:18:03,280
have to redo these operations again in

428
00:18:03,280 --> 00:18:06,000
the description

429
00:18:06,720 --> 00:18:08,400
so um this is

430
00:18:08,400 --> 00:18:10,240
basically what the

431
00:18:10,240 --> 00:18:11,760
what one of the

432
00:18:11,760 --> 00:18:13,120
variants of the

433
00:18:13,120 --> 00:18:14,320
come out to

434
00:18:14,320 --> 00:18:16,320
transform us

435
00:18:16,320 --> 00:18:18,160
and

436
00:18:18,160 --> 00:18:19,200
so

437
00:18:19,200 --> 00:18:21,840
again we have a problem if we try to do

438
00:18:21,840 --> 00:18:24,160
this in a

439
00:18:24,160 --> 00:18:26,720
distributed way

440
00:18:26,720 --> 00:18:29,280
and the reason is that

441
00:18:29,280 --> 00:18:31,600
this message in our case is going to be

442
00:18:31,600 --> 00:18:32,400
the

443
00:18:32,400 --> 00:18:34,400
session key which is still secret at

444
00:18:34,400 --> 00:18:36,000
this point so

445
00:18:36,000 --> 00:18:38,240
we would need to re-evaluate the hash

446
00:18:38,240 --> 00:18:41,200
function over secret data

447
00:18:41,200 --> 00:18:44,480
and use it as a seed

448
00:18:44,480 --> 00:18:47,679
for the randomness of the

449
00:18:47,679 --> 00:18:49,280
encryption

450
00:18:49,280 --> 00:18:51,760
encryption which has to be computed over

451
00:18:51,760 --> 00:18:54,160
the secret session key

452
00:18:54,160 --> 00:18:54,960
so

453
00:18:54,960 --> 00:18:56,720
especially when

454
00:18:56,720 --> 00:18:59,039
the encryption algorithm

455
00:18:59,039 --> 00:19:00,320
is

456
00:19:00,320 --> 00:19:02,960
using some uh weird

457
00:19:02,960 --> 00:19:05,600
probabilistic probability distribution

458
00:19:05,600 --> 00:19:08,720
then this operation is really expensive

459
00:19:08,720 --> 00:19:10,640
for general multi-party computation

460
00:19:10,640 --> 00:19:12,640
techniques

461
00:19:12,640 --> 00:19:13,440
so

462
00:19:13,440 --> 00:19:16,080
i hope you are convinced that this

463
00:19:16,080 --> 00:19:19,840
approach doesn't really

464
00:19:19,840 --> 00:19:24,320
work in our case so

465
00:19:24,320 --> 00:19:27,120
we would like to find something that

466
00:19:27,120 --> 00:19:28,880
doesn't use

467
00:19:28,880 --> 00:19:32,480
randomness to get security

468
00:19:33,360 --> 00:19:36,240
so one operation that is intrinsically

469
00:19:36,240 --> 00:19:39,600
secure intrinsically

470
00:19:39,600 --> 00:19:40,799
random

471
00:19:40,799 --> 00:19:42,880
is the rounding map

472
00:19:42,880 --> 00:19:45,120
so for two integers p and q where p is

473
00:19:45,120 --> 00:19:46,640
less than q

474
00:19:46,640 --> 00:19:49,679
you have this rounding map that takes an

475
00:19:49,679 --> 00:19:51,520
integer and

476
00:19:51,520 --> 00:19:55,760
scales it by p over q and

477
00:19:55,919 --> 00:19:59,520
approximates it by the nearest integer

478
00:19:59,520 --> 00:20:01,600
and this hides the lower bits of the

479
00:20:01,600 --> 00:20:03,520
input

480
00:20:03,520 --> 00:20:08,000
if the input is sufficiently random

481
00:20:08,000 --> 00:20:09,600
then this map is

482
00:20:09,600 --> 00:20:12,639
basically one way

483
00:20:13,200 --> 00:20:13,919
so

484
00:20:13,919 --> 00:20:17,440
we have something that

485
00:20:18,320 --> 00:20:21,039
doesn't need additional noise or

486
00:20:21,039 --> 00:20:22,799
randomness to

487
00:20:22,799 --> 00:20:23,600
to be

488
00:20:23,600 --> 00:20:25,679
one way to be secure

489
00:20:25,679 --> 00:20:27,600
and that's perfect we want to base our

490
00:20:27,600 --> 00:20:30,640
encryption on that

491
00:20:30,640 --> 00:20:33,440
luckily there is an assumption based on

492
00:20:33,440 --> 00:20:36,080
such constructions which is related to

493
00:20:36,080 --> 00:20:39,280
the learning with iris problem

494
00:20:39,280 --> 00:20:41,440
and guess what the name is

495
00:20:41,440 --> 00:20:45,120
learning without its problem

496
00:20:45,120 --> 00:20:46,559
so

497
00:20:46,559 --> 00:20:50,000
here instead of having a nice

498
00:20:50,000 --> 00:20:52,799
linear system you have a

499
00:20:52,799 --> 00:20:55,520
rounded linear system

500
00:20:55,520 --> 00:20:57,440
and the basic

501
00:20:57,440 --> 00:21:00,320
version of the decision learning

502
00:21:00,320 --> 00:21:01,679
surroundings

503
00:21:01,679 --> 00:21:03,760
says that

504
00:21:03,760 --> 00:21:06,559
for a secret vector and the public

505
00:21:06,559 --> 00:21:09,760
matrix this rounded matrix by vector

506
00:21:09,760 --> 00:21:13,120
product looks indistinguishable from

507
00:21:13,120 --> 00:21:17,520
a completely random vector

508
00:21:17,520 --> 00:21:20,400
then you also have the

509
00:21:20,400 --> 00:21:23,600
decision ring lwr

510
00:21:23,600 --> 00:21:24,480
if you

511
00:21:24,480 --> 00:21:26,000
consider the same problem over

512
00:21:26,000 --> 00:21:28,840
polynomial rings

513
00:21:28,840 --> 00:21:33,440
and the decision module lwr

514
00:21:33,440 --> 00:21:35,600
if you are considering

515
00:21:35,600 --> 00:21:37,679
adding more structure and considering

516
00:21:37,679 --> 00:21:41,360
matrices of polynomial rings

517
00:21:41,520 --> 00:21:43,440
finally you have to search under your

518
00:21:43,440 --> 00:21:46,720
problem which says that

519
00:21:46,720 --> 00:21:50,000
it's difficult to retrieve s from many

520
00:21:50,000 --> 00:21:53,440
lwr samples

521
00:21:54,080 --> 00:21:57,760
so on top of that we are able to

522
00:21:57,760 --> 00:22:00,240
construct our

523
00:22:00,240 --> 00:22:03,600
public key encryption

524
00:22:04,480 --> 00:22:05,280
so

525
00:22:05,280 --> 00:22:06,400
um

526
00:22:06,400 --> 00:22:08,720
it's really simple

527
00:22:08,720 --> 00:22:11,600
the encryption so is probably it is

528
00:22:11,600 --> 00:22:13,600
deterministic

529
00:22:13,600 --> 00:22:16,159
and this comes from the fact that we are

530
00:22:16,159 --> 00:22:17,200
base

531
00:22:17,200 --> 00:22:19,520
we are basing the encryption directly on

532
00:22:19,520 --> 00:22:21,760
the rounding map

533
00:22:21,760 --> 00:22:24,159
so you see that we don't need

534
00:22:24,159 --> 00:22:28,720
any we are not using any randomness

535
00:22:29,679 --> 00:22:31,440
and

536
00:22:31,440 --> 00:22:32,640
the

537
00:22:32,640 --> 00:22:35,600
decryption is quite fast

538
00:22:35,600 --> 00:22:37,600
for

539
00:22:37,600 --> 00:22:40,880
distributed techniques cause

540
00:22:40,880 --> 00:22:43,360
and the reason lies on the fact that we

541
00:22:43,360 --> 00:22:46,000
are using lwe

542
00:22:46,000 --> 00:22:48,000
techniques constructions in the key

543
00:22:48,000 --> 00:22:50,640
generation

544
00:22:50,799 --> 00:22:52,240
now

545
00:22:52,240 --> 00:22:54,400
what is left to do is to argue the

546
00:22:54,400 --> 00:22:56,559
one-way cpa security

547
00:22:56,559 --> 00:22:59,280
and this is just a combination of the

548
00:22:59,280 --> 00:23:00,880
search on we

549
00:23:00,880 --> 00:23:01,840
here

550
00:23:01,840 --> 00:23:03,840
because

551
00:23:03,840 --> 00:23:05,039
this is

552
00:23:05,039 --> 00:23:07,039
saying our

553
00:23:07,039 --> 00:23:10,400
public key is indistinguishable from

554
00:23:10,400 --> 00:23:12,799
a pair of random matrices and the search

555
00:23:12,799 --> 00:23:15,039
lwr

556
00:23:15,039 --> 00:23:16,799
which is basically the fact that the

557
00:23:16,799 --> 00:23:18,080
encryption

558
00:23:18,080 --> 00:23:19,760
is

559
00:23:19,760 --> 00:23:23,440
our encryption is a one-way map

560
00:23:23,440 --> 00:23:26,159
so we are done

561
00:23:26,159 --> 00:23:27,679
on to summarize

562
00:23:27,679 --> 00:23:30,080
we started with the problem of finding

563
00:23:30,080 --> 00:23:33,520
constructing a public encryption

564
00:23:33,520 --> 00:23:35,200
for which we could do

565
00:23:35,200 --> 00:23:37,039
the decryption

566
00:23:37,039 --> 00:23:39,360
um

567
00:23:40,000 --> 00:23:43,520
in a distributed way quite efficiently

568
00:23:43,520 --> 00:23:46,480
so as i mentioned this problem reduces

569
00:23:46,480 --> 00:23:48,559
to that of

570
00:23:48,559 --> 00:23:52,159
considering hybrid cyphers

571
00:23:52,159 --> 00:23:53,760
and so

572
00:23:53,760 --> 00:23:56,960
we started looking at the chromosome

573
00:23:56,960 --> 00:23:59,440
hybrid which was the problem

574
00:23:59,440 --> 00:24:02,240
of requiring one to evaluate

575
00:24:02,240 --> 00:24:04,240
the decryption of the them over the

576
00:24:04,240 --> 00:24:06,080
secret session

577
00:24:06,080 --> 00:24:08,960
this operation is costly

578
00:24:08,960 --> 00:24:09,919
for

579
00:24:09,919 --> 00:24:12,880
uh in in a distributed way

580
00:24:12,880 --> 00:24:16,080
also it requires

581
00:24:16,320 --> 00:24:19,679
ncca components so quite demanding

582
00:24:19,679 --> 00:24:22,240
so the idea is that we leak

583
00:24:22,240 --> 00:24:24,000
the session key

584
00:24:24,000 --> 00:24:26,159
before doing the decryption so the

585
00:24:26,159 --> 00:24:28,000
decryption then

586
00:24:28,000 --> 00:24:29,039
becomes

587
00:24:29,039 --> 00:24:31,120
just an operation

588
00:24:31,120 --> 00:24:33,600
over clear data so there is no need for

589
00:24:33,600 --> 00:24:36,000
any secure protocol

590
00:24:36,000 --> 00:24:37,200
and

591
00:24:37,200 --> 00:24:39,919
we we are able to do that without

592
00:24:39,919 --> 00:24:42,960
consequences securely so we can lick the

593
00:24:42,960 --> 00:24:45,520
key securely because we are using

594
00:24:45,520 --> 00:24:47,600
um hash function

595
00:24:47,600 --> 00:24:48,760
as a

596
00:24:48,760 --> 00:24:50,480
authentication

597
00:24:50,480 --> 00:24:51,200
on

598
00:24:51,200 --> 00:24:54,799
for for this for the session

599
00:24:55,200 --> 00:24:58,320
also this hash function is useful

600
00:24:58,320 --> 00:25:00,880
because we can

601
00:25:00,880 --> 00:25:03,200
use minimal

602
00:25:03,200 --> 00:25:05,600
assumptions for our

603
00:25:05,600 --> 00:25:07,600
public key encryption we just need a

604
00:25:07,600 --> 00:25:10,559
deterministic public key encryption

605
00:25:10,559 --> 00:25:13,279
so what we get

606
00:25:13,279 --> 00:25:16,159
at the end is a very general transform

607
00:25:16,159 --> 00:25:17,360
that takes

608
00:25:17,360 --> 00:25:20,720
um a deterministic one-way cpa public

609
00:25:20,720 --> 00:25:24,480
encryption with a one-time ncpa dam

610
00:25:24,480 --> 00:25:26,159
and gives you a

611
00:25:26,159 --> 00:25:28,559
ncca public encryption in the random

612
00:25:28,559 --> 00:25:30,240
oracle model

613
00:25:30,240 --> 00:25:31,919
we get full security in the quantum

614
00:25:31,919 --> 00:25:34,480
random oracle model if we had two more

615
00:25:34,480 --> 00:25:36,880
hashes

616
00:25:37,200 --> 00:25:39,760
finally we are able to

617
00:25:39,760 --> 00:25:42,480
show that it is possible to

618
00:25:42,480 --> 00:25:43,679
construct

619
00:25:43,679 --> 00:25:45,360
a public encryption which is

620
00:25:45,360 --> 00:25:48,159
deterministic still one way

621
00:25:48,159 --> 00:25:50,640
secure

622
00:25:51,120 --> 00:25:54,400
based on the lwr assumption

623
00:25:54,400 --> 00:25:57,440
so we are basing encryption directly on

624
00:25:57,440 --> 00:25:59,520
the rounding map

625
00:25:59,520 --> 00:26:02,080
which basically is

626
00:26:02,080 --> 00:26:04,159
avoiding us doing

627
00:26:04,159 --> 00:26:08,400
expensive randomization procedures

628
00:26:08,400 --> 00:26:09,520
so

629
00:26:09,520 --> 00:26:11,520
putting everything together

630
00:26:11,520 --> 00:26:12,559
we get

631
00:26:12,559 --> 00:26:15,600
the first practical

632
00:26:15,600 --> 00:26:18,080
post quantum public encryption

633
00:26:18,080 --> 00:26:19,840
for which we can

634
00:26:19,840 --> 00:26:22,960
implement the decryption using

635
00:26:22,960 --> 00:26:24,610
a secure protocol in

636
00:26:24,610 --> 00:26:25,840
[Music]

637
00:26:25,840 --> 00:26:30,158
in an efficient way very efficiently

638
00:26:30,240 --> 00:26:33,279
so this concludes my talk if you have

639
00:26:33,279 --> 00:26:36,080
questions about paper please

640
00:26:36,080 --> 00:26:39,679
feel free to contact me by email

641
00:26:39,679 --> 00:26:42,640
take care

