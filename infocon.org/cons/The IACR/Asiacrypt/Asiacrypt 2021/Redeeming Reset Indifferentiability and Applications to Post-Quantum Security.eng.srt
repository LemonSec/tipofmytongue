1
00:00:02,960 --> 00:00:05,759
today i'll be talking about new results

2
00:00:05,759 --> 00:00:09,759
about reset and differentiability

3
00:00:09,920 --> 00:00:11,599
to motivate things

4
00:00:11,599 --> 00:00:13,519
consider the following

5
00:00:13,519 --> 00:00:15,759
bob goes to alice saying

6
00:00:15,759 --> 00:00:18,720
look at my great new hash function

7
00:00:18,720 --> 00:00:21,039
alice is skeptical as any cryptographer

8
00:00:21,039 --> 00:00:22,240
would be

9
00:00:22,240 --> 00:00:23,840
she therefore asked bob to prove

10
00:00:23,840 --> 00:00:26,640
security under a widely believed

11
00:00:26,640 --> 00:00:28,400
mathematical assumption the gold

12
00:00:28,400 --> 00:00:32,159
standard of modern cryptography

13
00:00:33,040 --> 00:00:35,280
bob points out that for much of

14
00:00:35,280 --> 00:00:37,760
practical symmetric crypto the community

15
00:00:37,760 --> 00:00:39,520
does not have such proofs and in

16
00:00:39,520 --> 00:00:41,680
particular we don't have any proofs for

17
00:00:41,680 --> 00:00:45,039
the shah family of hash functions

18
00:00:45,039 --> 00:00:47,120
alice therefore acquiesces and decides

19
00:00:47,120 --> 00:00:50,640
to look at bob's construction

20
00:00:50,879 --> 00:00:52,320
let's say that bob's hash function

21
00:00:52,320 --> 00:00:54,000
starts out by building some complex

22
00:00:54,000 --> 00:00:55,680
permutation p

23
00:00:55,680 --> 00:00:57,360
and then truncates the output to get a

24
00:00:57,360 --> 00:00:59,839
hash function

25
00:01:00,239 --> 00:01:02,239
alice agrees with bob that p itself

26
00:01:02,239 --> 00:01:04,959
seems like a pretty good permutation

27
00:01:04,959 --> 00:01:06,479
but she points out that the

28
00:01:06,479 --> 00:01:08,240
resulting hash function is trivially

29
00:01:08,240 --> 00:01:10,240
insecure nonetheless

30
00:01:10,240 --> 00:01:12,000
basically you can invert the hash

31
00:01:12,000 --> 00:01:13,920
function on any output just by

32
00:01:13,920 --> 00:01:15,920
arbitrarily selecting the values for the

33
00:01:15,920 --> 00:01:19,600
discarded bits and then inverting p

34
00:01:19,600 --> 00:01:21,360
this violates one awayness and also

35
00:01:21,360 --> 00:01:24,479
allows for finding collisions

36
00:01:24,479 --> 00:01:26,320
all right so bob goes back to the

37
00:01:26,320 --> 00:01:28,880
drawing board

38
00:01:29,600 --> 00:01:32,240
now bob proposes first padding the input

39
00:01:32,240 --> 00:01:34,320
with several zeros

40
00:01:34,320 --> 00:01:35,840
applying the permutation and then

41
00:01:35,840 --> 00:01:38,880
truncating the output

42
00:01:39,280 --> 00:01:41,119
now alice can't find any issues with the

43
00:01:41,119 --> 00:01:43,520
hash function she's willing to accept

44
00:01:43,520 --> 00:01:46,960
that p is a fantastic permutation

45
00:01:46,960 --> 00:01:48,640
uh but still wants to be sure that she

46
00:01:48,640 --> 00:01:50,799
didn't just miss some trivial attack on

47
00:01:50,799 --> 00:01:52,960
the resulting hash function so she asked

48
00:01:52,960 --> 00:01:55,119
bob to prove that there's no such

49
00:01:55,119 --> 00:01:57,920
trivial attacks

50
00:01:59,040 --> 00:02:01,439
and so what bob does is propose

51
00:02:01,439 --> 00:02:03,600
proposing to use the concept of

52
00:02:03,600 --> 00:02:06,000
interference ability

53
00:02:06,000 --> 00:02:08,479
so what is indifferentiability

54
00:02:08,479 --> 00:02:09,919
proposed by

55
00:02:09,919 --> 00:02:12,400
maurer renner and hollandstein it's a

56
00:02:12,400 --> 00:02:14,640
strengthening of indistinguishability

57
00:02:14,640 --> 00:02:16,720
which is used when trying to build one

58
00:02:16,720 --> 00:02:19,280
idealized object from another

59
00:02:19,280 --> 00:02:21,200
in our case we are willing to accept

60
00:02:21,200 --> 00:02:23,840
that p is a good permutation so we are

61
00:02:23,840 --> 00:02:25,840
going to model it as a truly random

62
00:02:25,840 --> 00:02:28,239
permutation and its inverse

63
00:02:28,239 --> 00:02:31,280
which is also called an ideal cipher

64
00:02:31,280 --> 00:02:32,640
our goal is to justify that the

65
00:02:32,640 --> 00:02:34,319
resulting construction which we will

66
00:02:34,319 --> 00:02:35,760
call c

67
00:02:35,760 --> 00:02:37,599
is in some sense as good as an ideal

68
00:02:37,599 --> 00:02:38,879
hash function

69
00:02:38,879 --> 00:02:41,840
uh which are often called random oracles

70
00:02:41,840 --> 00:02:43,440
and differentiability is a way to

71
00:02:43,440 --> 00:02:45,840
formalize this goal of justifying a

72
00:02:45,840 --> 00:02:48,239
construction is as good as

73
00:02:48,239 --> 00:02:51,519
a random oracle and differentiability is

74
00:02:51,519 --> 00:02:54,319
defined by the picture here

75
00:02:54,319 --> 00:02:57,760
the adversary is given two interfaces

76
00:02:57,760 --> 00:03:00,800
one corresponds to the building block in

77
00:03:00,800 --> 00:03:02,560
our case an ideal permutation it's

78
00:03:02,560 --> 00:03:05,760
inverse depicted here

79
00:03:05,760 --> 00:03:08,080
the second corresponds to the desired

80
00:03:08,080 --> 00:03:10,319
object we're trying to construct in our

81
00:03:10,319 --> 00:03:12,159
case a hash function which is depicted

82
00:03:12,159 --> 00:03:14,400
on the bottom here

83
00:03:14,400 --> 00:03:16,080
differentiability then defines two

84
00:03:16,080 --> 00:03:18,480
worlds real and ideal

85
00:03:18,480 --> 00:03:19,599
the real

86
00:03:19,599 --> 00:03:21,680
is depicted on the left

87
00:03:21,680 --> 00:03:23,840
where the

88
00:03:23,840 --> 00:03:26,720
building block oracle

89
00:03:26,720 --> 00:03:28,640
is the ideal cipher and the hash

90
00:03:28,640 --> 00:03:30,640
function is set to be the construction

91
00:03:30,640 --> 00:03:32,640
which makes queries to the building

92
00:03:32,640 --> 00:03:34,958
block

93
00:03:35,200 --> 00:03:37,920
the ideal world is given on the right

94
00:03:37,920 --> 00:03:39,920
where the hash function is set to be a

95
00:03:39,920 --> 00:03:42,319
truly random oracle

96
00:03:42,319 --> 00:03:44,400
and queries to the

97
00:03:44,400 --> 00:03:47,760
cipher are answered via a simulator

98
00:03:47,760 --> 00:03:49,120
which can

99
00:03:49,120 --> 00:03:51,040
make queries to the random oracle in

100
00:03:51,040 --> 00:03:54,879
order to help it answer the queries

101
00:03:55,599 --> 00:03:58,879
importantly for this talk the

102
00:03:58,879 --> 00:04:01,280
simulator will be allowed to keep state

103
00:04:01,280 --> 00:04:04,480
between the queries

104
00:04:04,480 --> 00:04:07,040
and differentiability requires that for

105
00:04:07,040 --> 00:04:08,799
every adversary

106
00:04:08,799 --> 00:04:11,200
there exists a simulator that causes

107
00:04:11,200 --> 00:04:15,480
these two worlds to be indistinguishable

108
00:04:16,238 --> 00:04:18,160
so differentiability can be seen as a

109
00:04:18,160 --> 00:04:20,880
form of universal composability

110
00:04:20,880 --> 00:04:22,960
for idealized objects

111
00:04:22,960 --> 00:04:25,919
and indeed now or at all show that

112
00:04:25,919 --> 00:04:28,960
indifferentiability compose as well

113
00:04:28,960 --> 00:04:30,720
that if you construct

114
00:04:30,720 --> 00:04:33,040
one indifferential object from another

115
00:04:33,040 --> 00:04:35,040
indifferential object the final object

116
00:04:35,040 --> 00:04:37,919
is in fact different in differentiable

117
00:04:37,919 --> 00:04:39,840
and they also show that

118
00:04:39,840 --> 00:04:42,720
indifferentiability implies security for

119
00:04:42,720 --> 00:04:45,040
what are called single stage games these

120
00:04:45,040 --> 00:04:46,479
are games making up the most of

121
00:04:46,479 --> 00:04:48,479
cartography where a single adversary

122
00:04:48,479 --> 00:04:50,960
interacts with the challenger

123
00:04:50,960 --> 00:04:52,960
so for now on i will call this result

124
00:04:52,960 --> 00:04:53,759
the

125
00:04:53,759 --> 00:04:57,600
mrh composition theorem

126
00:04:57,600 --> 00:04:59,360
because of these nice properties of

127
00:04:59,360 --> 00:05:01,440
indifferentiability and because many

128
00:05:01,440 --> 00:05:03,039
hash functions are built from lower

129
00:05:03,039 --> 00:05:04,880
level building blocks

130
00:05:04,880 --> 00:05:06,720
proof of indifferentiability have become

131
00:05:06,720 --> 00:05:08,639
a popular way to justify that a new

132
00:05:08,639 --> 00:05:09,840
construction

133
00:05:09,840 --> 00:05:12,320
at least doesn't have trivial attacks

134
00:05:12,320 --> 00:05:14,160
and many popular constructions have

135
00:05:14,160 --> 00:05:16,639
indifferentiability proofs such as

136
00:05:16,639 --> 00:05:18,560
merkel dam guard and the sponge

137
00:05:18,560 --> 00:05:20,320
construction

138
00:05:20,320 --> 00:05:23,360
with a major caveat that i will discuss

139
00:05:23,360 --> 00:05:24,479
in a moment

140
00:05:24,479 --> 00:05:26,479
the an indifferentiability proof shows

141
00:05:26,479 --> 00:05:28,160
that the hash function

142
00:05:28,160 --> 00:05:29,840
might as well be treated as a random

143
00:05:29,840 --> 00:05:32,560
oracle provided we are willing to treat

144
00:05:32,560 --> 00:05:34,400
the underlying building block as an

145
00:05:34,400 --> 00:05:37,799
ideal object

146
00:05:38,240 --> 00:05:40,560
so what this work is about is exploring

147
00:05:40,560 --> 00:05:42,560
a strengthening of indifferentiability

148
00:05:42,560 --> 00:05:45,039
called reset indifferentiability which

149
00:05:45,039 --> 00:05:47,759
is needed to overcome a significant

150
00:05:47,759 --> 00:05:48,960
limitation in plane and

151
00:05:48,960 --> 00:05:51,520
differentiability

152
00:05:51,520 --> 00:05:54,639
concretely as observed by wrist and part

153
00:05:54,639 --> 00:05:56,600
chachum and tripton

154
00:05:56,600 --> 00:05:59,840
indifferentiability is insufficient for

155
00:05:59,840 --> 00:06:02,479
what are called multi-stage games

156
00:06:02,479 --> 00:06:04,000
these are games where there are actually

157
00:06:04,000 --> 00:06:06,479
two or more different adversaries

158
00:06:06,479 --> 00:06:09,600
each interacting with the challenger

159
00:06:09,600 --> 00:06:11,360
importantly the adversaries are not

160
00:06:11,360 --> 00:06:13,280
allowed arbitrary communication between

161
00:06:13,280 --> 00:06:14,400
them

162
00:06:14,400 --> 00:06:16,479
maybe they're fully isolated or perhaps

163
00:06:16,479 --> 00:06:19,360
a minimal communication is allowed

164
00:06:19,360 --> 00:06:22,880
examples of games that are multi-stage

165
00:06:22,880 --> 00:06:25,360
include deterministic encryption

166
00:06:25,360 --> 00:06:27,440
key dependent message security

167
00:06:27,440 --> 00:06:31,039
leakage resilience and others

168
00:06:31,280 --> 00:06:33,759
as wrist and part at all observe the

169
00:06:33,759 --> 00:06:35,520
fact that the

170
00:06:35,520 --> 00:06:37,520
plane and differentiability simulator is

171
00:06:37,520 --> 00:06:39,840
a lot is a loud state

172
00:06:39,840 --> 00:06:41,600
causes problems

173
00:06:41,600 --> 00:06:42,800
for indifferential building the

174
00:06:42,800 --> 00:06:45,680
multi-stage setting basically since both

175
00:06:45,680 --> 00:06:48,240
adversaries will clarity the same

176
00:06:48,240 --> 00:06:49,520
simulator

177
00:06:49,520 --> 00:06:51,440
and that simulator is keeping state

178
00:06:51,440 --> 00:06:53,120
between its queries

179
00:06:53,120 --> 00:06:54,960
the state of the simulator breaks the

180
00:06:54,960 --> 00:06:57,440
isolation between the adversaries and

181
00:06:57,440 --> 00:06:59,039
what this means is that the mrh

182
00:06:59,039 --> 00:07:01,039
composition theorem actually fails for

183
00:07:01,039 --> 00:07:03,520
multi-stage games

184
00:07:03,520 --> 00:07:05,599
to remedy this issue wrist and part at

185
00:07:05,599 --> 00:07:07,120
all propose a notion called reset and

186
00:07:07,120 --> 00:07:08,880
differentiability

187
00:07:08,880 --> 00:07:11,280
uh and this is exactly identical to

188
00:07:11,280 --> 00:07:12,800
plane and differentiability except that

189
00:07:12,800 --> 00:07:14,840
the simulator now is required to be

190
00:07:14,840 --> 00:07:16,560
stingless

191
00:07:16,560 --> 00:07:19,440
they then prove what i'll call the rss

192
00:07:19,440 --> 00:07:21,120
composition theorem

193
00:07:21,120 --> 00:07:22,800
showing that reset indifferentiability

194
00:07:22,800 --> 00:07:25,520
composes and imply security for general

195
00:07:25,520 --> 00:07:28,400
potentially multi-stage games

196
00:07:28,400 --> 00:07:29,120
they even show that this

197
00:07:29,120 --> 00:07:31,280
characterization is tight namely that if

198
00:07:31,280 --> 00:07:34,080
you don't have reset indifferentiability

199
00:07:34,080 --> 00:07:36,479
then there must exist some game where

200
00:07:36,479 --> 00:07:39,440
security fails

201
00:07:40,400 --> 00:07:42,800
unfortunately reset indifferentiability

202
00:07:42,800 --> 00:07:44,879
itself has a major limitation

203
00:07:44,879 --> 00:07:46,879
wisdom part of all proven impossibility

204
00:07:46,879 --> 00:07:48,639
which was later refined and strengthened

205
00:07:48,639 --> 00:07:50,720
by several follow-up works

206
00:07:50,720 --> 00:07:52,240
showing that domain extension is

207
00:07:52,240 --> 00:07:53,759
impossible under reset

208
00:07:53,759 --> 00:07:55,280
indifferentiability

209
00:07:55,280 --> 00:07:56,960
domain extension is just taking any

210
00:07:56,960 --> 00:07:58,879
small domain ideal object like a small

211
00:07:58,879 --> 00:08:01,199
random oracle and constructing a large

212
00:08:01,199 --> 00:08:03,440
domain object such as

213
00:08:03,440 --> 00:08:05,360
as a big random oracle or even a random

214
00:08:05,360 --> 00:08:08,000
oracle with an unbounded domain

215
00:08:08,000 --> 00:08:10,000
which is what you would do with merkel

216
00:08:10,000 --> 00:08:13,440
dam guard or the sponge construction

217
00:08:13,440 --> 00:08:15,199
so what this shows is that merkel damn

218
00:08:15,199 --> 00:08:17,280
guard and the sponge construction for

219
00:08:17,280 --> 00:08:19,520
long messages actually can't be reset

220
00:08:19,520 --> 00:08:21,120
and differentiable

221
00:08:21,120 --> 00:08:22,800
uh which is in contrast to the plain and

222
00:08:22,800 --> 00:08:25,199
differentiably setting where we have

223
00:08:25,199 --> 00:08:27,840
such proofs

224
00:08:27,919 --> 00:08:30,160
now the the strong impossibility seems

225
00:08:30,160 --> 00:08:31,120
to have

226
00:08:31,120 --> 00:08:33,839
basically led to indifferent to reset

227
00:08:33,839 --> 00:08:35,440
and differentiability being abandoned

228
00:08:35,440 --> 00:08:37,039
and there have been a few subsequent

229
00:08:37,039 --> 00:08:41,000
works in the area

230
00:08:42,958 --> 00:08:45,120
so the starting point for this work is

231
00:08:45,120 --> 00:08:46,399
is two

232
00:08:46,399 --> 00:08:48,480
observations

233
00:08:48,480 --> 00:08:50,480
first we observe that domain extension

234
00:08:50,480 --> 00:08:52,480
is not always necessary

235
00:08:52,480 --> 00:08:54,080
for example sometimes we use random

236
00:08:54,080 --> 00:08:56,000
oracles for deriving the coins for a

237
00:08:56,000 --> 00:08:58,399
public encryption scheme

238
00:08:58,399 --> 00:09:00,959
as an example consider building cca

239
00:09:00,959 --> 00:09:03,360
secure encryption using the fujisaki

240
00:09:03,360 --> 00:09:05,040
okomoto transform

241
00:09:05,040 --> 00:09:06,800
or building deterministic encryption

242
00:09:06,800 --> 00:09:09,120
from general public key encryption

243
00:09:09,120 --> 00:09:10,800
the deterministic encryption example is

244
00:09:10,800 --> 00:09:12,160
more relevant to us since it's a

245
00:09:12,160 --> 00:09:13,680
multi-stage game and we need and

246
00:09:13,680 --> 00:09:14,800
therefore need reset to

247
00:09:14,800 --> 00:09:17,440
differentiability

248
00:09:17,440 --> 00:09:20,160
if our messages are a fixed size then we

249
00:09:20,160 --> 00:09:21,760
actually don't necessarily care about

250
00:09:21,760 --> 00:09:23,680
domain extension as long as the building

251
00:09:23,680 --> 00:09:24,880
block we're starting from has a

252
00:09:24,880 --> 00:09:27,360
sufficiently large domain

253
00:09:27,360 --> 00:09:29,600
so for example if we are building our

254
00:09:29,600 --> 00:09:32,240
hash function from a random permutation

255
00:09:32,240 --> 00:09:34,560
say using the sponge construction

256
00:09:34,560 --> 00:09:36,399
we might be interested in the reset and

257
00:09:36,399 --> 00:09:38,080
differentiability for very small

258
00:09:38,080 --> 00:09:40,640
messages

259
00:09:41,440 --> 00:09:43,760
uh secondly we observe that basically is

260
00:09:43,760 --> 00:09:45,600
nothing nothing is known about reset

261
00:09:45,600 --> 00:09:47,040
interference ability beyond the

262
00:09:47,040 --> 00:09:48,720
impossibilities

263
00:09:48,720 --> 00:09:51,600
uh prior work didn't even establish the

264
00:09:51,600 --> 00:09:53,680
possibility of domain shrinkage building

265
00:09:53,680 --> 00:09:56,480
a small random oracle from a big one

266
00:09:56,480 --> 00:09:57,760
this

267
00:09:57,760 --> 00:09:59,600
might seem crazy because it seems

268
00:09:59,600 --> 00:10:01,279
intuitively obvious that we should be

269
00:10:01,279 --> 00:10:02,399
able to just

270
00:10:02,399 --> 00:10:05,760
pad the input to get a smaller domain

271
00:10:05,760 --> 00:10:07,200
but it was not clear that this was

272
00:10:07,200 --> 00:10:10,480
possible and in fact um some work has

273
00:10:10,480 --> 00:10:13,040
even demonstrated some barriers to doing

274
00:10:13,040 --> 00:10:16,320
this and has left it as a explicit open

275
00:10:16,320 --> 00:10:18,240
problem

276
00:10:18,240 --> 00:10:20,399
another question is whether we can build

277
00:10:20,399 --> 00:10:23,200
small random oracles from ideal ciphers

278
00:10:23,200 --> 00:10:24,959
in particular is a sponge construction

279
00:10:24,959 --> 00:10:26,880
for sufficiently small messages reset

280
00:10:26,880 --> 00:10:28,640
and differentiable

281
00:10:28,640 --> 00:10:30,720
this wouldn't contradict a domain

282
00:10:30,720 --> 00:10:32,480
extension impossibility since the domain

283
00:10:32,480 --> 00:10:34,640
remains small

284
00:10:34,640 --> 00:10:36,079
and finally what about the other

285
00:10:36,079 --> 00:10:37,920
direction can we build ideal ciphers

286
00:10:37,920 --> 00:10:40,959
from random oracles

287
00:10:41,279 --> 00:10:43,760
this finally leads us to our work where

288
00:10:43,760 --> 00:10:46,480
we give several new results for reset

289
00:10:46,480 --> 00:10:49,519
and differentiability

290
00:10:50,320 --> 00:10:52,079
first we try to shed

291
00:10:52,079 --> 00:10:54,000
more light on what can be ascertained

292
00:10:54,000 --> 00:10:56,560
from the techniques of prior work

293
00:10:56,560 --> 00:10:58,640
and concretely we show that the prior

294
00:10:58,640 --> 00:11:00,560
possibility is actually extraordinarily

295
00:11:00,560 --> 00:11:01,920
strong

296
00:11:01,920 --> 00:11:04,160
the impossibility for domain extension

297
00:11:04,160 --> 00:11:05,600
actually holds even if you let the

298
00:11:05,600 --> 00:11:07,519
simulator have an unbounded number of

299
00:11:07,519 --> 00:11:10,000
queries

300
00:11:11,040 --> 00:11:13,040
on the other hand we prove a general

301
00:11:13,040 --> 00:11:15,240
theorem showing how to achieve

302
00:11:15,240 --> 00:11:17,040
indifferentiability for unbounded

303
00:11:17,040 --> 00:11:20,000
simulators for a variety of tests

304
00:11:20,000 --> 00:11:22,160
including domain shrinkage ideal ciphers

305
00:11:22,160 --> 00:11:25,120
random oracles uh sorry ideal ciphers

306
00:11:25,120 --> 00:11:29,320
from random oracles and vice versa

307
00:11:29,680 --> 00:11:30,880
now indifferentiability with an

308
00:11:30,880 --> 00:11:33,120
unbounded simulator is rather useless on

309
00:11:33,120 --> 00:11:34,399
its own

310
00:11:34,399 --> 00:11:36,640
the unbounded simulator would would

311
00:11:36,640 --> 00:11:37,519
break

312
00:11:37,519 --> 00:11:39,920
pretty much any application

313
00:11:39,920 --> 00:11:41,680
but what these two results together show

314
00:11:41,680 --> 00:11:43,760
is that domain extension is really quite

315
00:11:43,760 --> 00:11:46,240
different from other natural goals you

316
00:11:46,240 --> 00:11:48,240
might want to achieve

317
00:11:48,240 --> 00:11:49,760
and so

318
00:11:49,760 --> 00:11:50,800
there

319
00:11:50,800 --> 00:11:53,200
the impossibility of domain extension

320
00:11:53,200 --> 00:11:55,519
really doesn't seem to apply elsewhere

321
00:11:55,519 --> 00:11:57,279
and there may be hope is hope of

322
00:11:57,279 --> 00:11:59,120
achieving these other tasks or

323
00:11:59,120 --> 00:12:01,120
alternatively if we wanted to actually

324
00:12:01,120 --> 00:12:02,880
prove these tasks impossible it would

325
00:12:02,880 --> 00:12:06,639
seem to require brand new ideas

326
00:12:07,600 --> 00:12:09,519
next we move on to our actual meaningful

327
00:12:09,519 --> 00:12:11,279
results

328
00:12:11,279 --> 00:12:13,519
first we prove that domain shrinkage is

329
00:12:13,519 --> 00:12:15,200
in fact possible with reset and

330
00:12:15,200 --> 00:12:16,880
differentiability

331
00:12:16,880 --> 00:12:18,880
using the obvious padding construction

332
00:12:18,880 --> 00:12:21,519
the difficulty is going to be in

333
00:12:21,519 --> 00:12:25,560
actually proving that this works

334
00:12:25,680 --> 00:12:27,120
then we

335
00:12:27,120 --> 00:12:29,360
investigate the natural approach to

336
00:12:29,360 --> 00:12:31,519
building a random oracle from a random

337
00:12:31,519 --> 00:12:33,920
permutation by padding the input and

338
00:12:33,920 --> 00:12:36,000
truncating the output this can also be

339
00:12:36,000 --> 00:12:38,880
seen as the sponge construction for a a

340
00:12:38,880 --> 00:12:41,680
single message block

341
00:12:41,680 --> 00:12:45,200
we show that as long as the

342
00:12:45,200 --> 00:12:47,200
input and output size of the derived

343
00:12:47,200 --> 00:12:48,959
hash function satisfy a certain

344
00:12:48,959 --> 00:12:50,079
constraint

345
00:12:50,079 --> 00:12:51,040
that

346
00:12:51,040 --> 00:12:52,800
this actually does give a reset

347
00:12:52,800 --> 00:12:54,880
indifferential hash function

348
00:12:54,880 --> 00:12:57,200
and what are the what is the constraint

349
00:12:57,200 --> 00:12:59,519
basically we need that the input size of

350
00:12:59,519 --> 00:13:01,680
the hash function plus the output size

351
00:13:01,680 --> 00:13:03,279
of the hash function can't exceed the

352
00:13:03,279 --> 00:13:05,680
block size of the

353
00:13:05,680 --> 00:13:08,479
ideal cipher

354
00:13:09,279 --> 00:13:10,560
now uh

355
00:13:10,560 --> 00:13:12,480
you may look at this restriction on the

356
00:13:12,480 --> 00:13:15,440
input and output size and it may

357
00:13:15,440 --> 00:13:16,320
seem

358
00:13:16,320 --> 00:13:17,760
unexpected

359
00:13:17,760 --> 00:13:19,040
but we show that this is actually the

360
00:13:19,040 --> 00:13:21,440
right answer and it's actually inherent

361
00:13:21,440 --> 00:13:24,880
for this particular construction

362
00:13:24,880 --> 00:13:26,560
we show that if you try to have the sum

363
00:13:26,560 --> 00:13:28,399
of input and output size

364
00:13:28,399 --> 00:13:31,360
exceed the block size of the permutation

365
00:13:31,360 --> 00:13:33,519
then there's actually an explicit attack

366
00:13:33,519 --> 00:13:35,440
breaking the reset indifferentiality of

367
00:13:35,440 --> 00:13:36,880
the construction

368
00:13:36,880 --> 00:13:39,040
now note that this is in contrast to the

369
00:13:39,040 --> 00:13:41,199
plane indifferentiability setting

370
00:13:41,199 --> 00:13:43,199
where the padding and truncating just

371
00:13:43,199 --> 00:13:46,639
need to each be independently

372
00:13:46,639 --> 00:13:50,560
larger than the security parameter

373
00:13:51,680 --> 00:13:53,199
finally we showed that all of our

374
00:13:53,199 --> 00:13:55,440
results lift the quantum setting for the

375
00:13:55,440 --> 00:13:57,120
purposes of this talk i won't discuss

376
00:13:57,120 --> 00:13:58,399
this too much

377
00:13:58,399 --> 00:14:00,639
but basically stateful simulation

378
00:14:00,639 --> 00:14:02,720
techniques are particularly challenging

379
00:14:02,720 --> 00:14:04,320
in the quantum setting where a stateless

380
00:14:04,320 --> 00:14:06,639
simulation is much easier though still

381
00:14:06,639 --> 00:14:09,600
often non-trivial

382
00:14:09,600 --> 00:14:11,279
so reset interference ability is

383
00:14:11,279 --> 00:14:13,760
particularly amenable to lifting to

384
00:14:13,760 --> 00:14:16,760
quantum

385
00:14:17,360 --> 00:14:20,160
one note is that even if you don't

386
00:14:20,160 --> 00:14:22,240
care about reset indifferentiability and

387
00:14:22,240 --> 00:14:23,760
all you care about is plane and

388
00:14:23,760 --> 00:14:25,519
differentiability

389
00:14:25,519 --> 00:14:27,360
in the quantum setting it was previously

390
00:14:27,360 --> 00:14:29,440
open to construct a random oracle from

391
00:14:29,440 --> 00:14:31,680
an ideal cipher

392
00:14:31,680 --> 00:14:33,519
in the quantum setting

393
00:14:33,519 --> 00:14:35,839
and what our work shows is that by going

394
00:14:35,839 --> 00:14:37,440
through reset indifferentiability we

395
00:14:37,440 --> 00:14:40,160
actually are able to achieve such a a

396
00:14:40,160 --> 00:14:42,399
result and in a way that is pretty

397
00:14:42,399 --> 00:14:44,320
accessible without knowing too much

398
00:14:44,320 --> 00:14:45,760
about quantum

399
00:14:45,760 --> 00:14:48,800
because all of our results lift

400
00:14:48,800 --> 00:14:50,240
somewhat straightforwardly to the

401
00:14:50,240 --> 00:14:53,040
quantum setting

402
00:14:53,040 --> 00:14:54,880
i'll note that there's a concurrent and

403
00:14:54,880 --> 00:14:57,120
independent work that also proves that

404
00:14:57,120 --> 00:14:59,040
ideal ciphers imply random oracles in

405
00:14:59,040 --> 00:15:00,480
the quantum setting

406
00:15:00,480 --> 00:15:03,120
and in particular this work proves the

407
00:15:03,120 --> 00:15:05,199
quantum and differentiability of the

408
00:15:05,199 --> 00:15:07,440
full sponge construction however the

409
00:15:07,440 --> 00:15:09,120
work uses completely different and more

410
00:15:09,120 --> 00:15:13,399
sophisticated quantum techniques

411
00:15:13,920 --> 00:15:15,839
so due to lack of time i won't talk

412
00:15:15,839 --> 00:15:18,160
about all the results but i want to

413
00:15:18,160 --> 00:15:19,519
discuss

414
00:15:19,519 --> 00:15:21,360
what could be seen as the main results

415
00:15:21,360 --> 00:15:23,519
which is building an indifferential a

416
00:15:23,519 --> 00:15:25,199
reset and differentiable random oracle

417
00:15:25,199 --> 00:15:28,319
from an ideal cipher

418
00:15:28,560 --> 00:15:31,519
and in order to motivate

419
00:15:31,519 --> 00:15:33,839
our proof i'll actually give the the

420
00:15:33,839 --> 00:15:35,759
lower bound

421
00:15:35,759 --> 00:15:37,600
since it'll actually sort of hint at our

422
00:15:37,600 --> 00:15:39,120
solution

423
00:15:39,120 --> 00:15:42,160
so suppose we are trying to

424
00:15:42,160 --> 00:15:44,240
build a random oracle from an ideal

425
00:15:44,240 --> 00:15:46,480
cipher by padding the input and

426
00:15:46,480 --> 00:15:48,720
truncating the output and suppose the

427
00:15:48,720 --> 00:15:50,800
input size and output size sum together

428
00:15:50,800 --> 00:15:54,320
to be more than the block length

429
00:15:54,320 --> 00:15:55,600
our goal is to show that this is not

430
00:15:55,600 --> 00:15:58,399
reset and differentiable

431
00:15:58,399 --> 00:15:59,920
the way we do this is we actually just

432
00:15:59,920 --> 00:16:02,000
give an explicit adversary which is

433
00:16:02,000 --> 00:16:04,000
pretty simple the adversary first

434
00:16:04,000 --> 00:16:05,920
queries the hash function

435
00:16:05,920 --> 00:16:08,320
uh its hash function oracle on a random

436
00:16:08,320 --> 00:16:09,680
input x

437
00:16:09,680 --> 00:16:11,600
um here i'm depicting what happens in

438
00:16:11,600 --> 00:16:13,120
the real world where the hash function

439
00:16:13,120 --> 00:16:15,199
is instantiated with the

440
00:16:15,199 --> 00:16:17,040
ideal cipher

441
00:16:17,040 --> 00:16:20,000
in response to x the adversary gets a

442
00:16:20,000 --> 00:16:23,839
value i'll call w prime

443
00:16:23,839 --> 00:16:25,759
the adversary also queries the

444
00:16:25,759 --> 00:16:28,000
permutation oracle on input x

445
00:16:28,000 --> 00:16:30,079
concatenated with zero

446
00:16:30,079 --> 00:16:32,240
getting a string in response that

447
00:16:32,240 --> 00:16:36,480
we will parse as w concatenated with z

448
00:16:36,480 --> 00:16:39,040
then finally it takes this w concat z

449
00:16:39,040 --> 00:16:42,240
queries the p inverse oracle to get

450
00:16:42,240 --> 00:16:46,240
what we will call x prime cat y prime

451
00:16:46,720 --> 00:16:48,800
the adversary then just simply checks

452
00:16:48,800 --> 00:16:52,160
that w equals w prime x equals x prime

453
00:16:52,160 --> 00:16:55,360
and y prime equals zero outputting one

454
00:16:55,360 --> 00:16:57,519
if and only if all of these checks pass

455
00:16:57,519 --> 00:17:00,160
and otherwise it up with zero

456
00:17:00,160 --> 00:17:01,680
so it should hopefully be clear that in

457
00:17:01,680 --> 00:17:04,559
the real world depicted here the all of

458
00:17:04,559 --> 00:17:06,240
the checks will pass

459
00:17:06,240 --> 00:17:08,079
and so the probability that the add 3

460
00:17:08,079 --> 00:17:09,439
outputs 1

461
00:17:09,439 --> 00:17:11,919
is 1.

462
00:17:12,160 --> 00:17:14,959
so to give just a little intuition for

463
00:17:14,959 --> 00:17:17,119
what the adversary is doing

464
00:17:17,119 --> 00:17:19,119
basically the checks for x equals x

465
00:17:19,119 --> 00:17:21,439
prime and y prime equals zero

466
00:17:21,439 --> 00:17:23,119
are just needed to make sure that p and

467
00:17:23,119 --> 00:17:25,760
p inverse are indeed inverses of each

468
00:17:25,760 --> 00:17:26,720
other

469
00:17:26,720 --> 00:17:27,679
um

470
00:17:27,679 --> 00:17:29,679
and that any simulator when we move to

471
00:17:29,679 --> 00:17:31,440
the ideal world

472
00:17:31,440 --> 00:17:33,360
isn't cheating us by setting a

473
00:17:33,360 --> 00:17:34,880
permutation oracle to be something

474
00:17:34,880 --> 00:17:36,400
trivial

475
00:17:36,400 --> 00:17:39,120
and then the check that w equals w prime

476
00:17:39,120 --> 00:17:41,280
is just to make sure that the hash

477
00:17:41,280 --> 00:17:43,039
function oracle and the permutation

478
00:17:43,039 --> 00:17:44,000
oracle

479
00:17:44,000 --> 00:17:47,840
are consistent with each other

480
00:17:49,039 --> 00:17:51,200
okay so why does the adversary break

481
00:17:51,200 --> 00:17:53,280
reset and differentiability

482
00:17:53,280 --> 00:17:55,360
um well let's consider

483
00:17:55,360 --> 00:17:57,520
moving to the ideal world

484
00:17:57,520 --> 00:17:59,360
where the hash function is a random

485
00:17:59,360 --> 00:18:01,600
oracle and the permutation oracles are

486
00:18:01,600 --> 00:18:04,320
being simulated by the simulator

487
00:18:04,320 --> 00:18:05,840
since we are in the reset

488
00:18:05,840 --> 00:18:07,600
indifferentiability setting

489
00:18:07,600 --> 00:18:08,400
the

490
00:18:08,400 --> 00:18:10,400
two queries of the permutation oracle

491
00:18:10,400 --> 00:18:11,840
and its inverse are answered

492
00:18:11,840 --> 00:18:13,840
independently and i'll call the

493
00:18:13,840 --> 00:18:16,160
algorithms that are used to answer them

494
00:18:16,160 --> 00:18:20,559
simpy and simpy inverse

495
00:18:20,720 --> 00:18:23,919
the first thing to notice

496
00:18:24,240 --> 00:18:27,600
is that simpy inverse is given w

497
00:18:27,600 --> 00:18:29,600
and must produce x

498
00:18:29,600 --> 00:18:32,880
but w is a random oracle output and x is

499
00:18:32,880 --> 00:18:35,039
the corresponding pre-image

500
00:18:35,039 --> 00:18:37,600
so it seems that simpy inverse must be

501
00:18:37,600 --> 00:18:40,320
inverting h on w remember all that

502
00:18:40,320 --> 00:18:43,039
simpy and simpy inverse can do is query

503
00:18:43,039 --> 00:18:45,760
the oracle h

504
00:18:45,760 --> 00:18:48,960
um and since sim must be query efficient

505
00:18:48,960 --> 00:18:51,120
this would violate the known one-wayness

506
00:18:51,120 --> 00:18:53,919
of random oracles

507
00:18:53,919 --> 00:18:55,919
now this doesn't quite work as a proof

508
00:18:55,919 --> 00:18:58,640
since simpee inverse is also given z as

509
00:18:58,640 --> 00:18:59,840
an input

510
00:18:59,840 --> 00:19:01,600
and z could be side information which

511
00:19:01,600 --> 00:19:03,760
helps it invert h

512
00:19:03,760 --> 00:19:05,520
remember after all that z was produced

513
00:19:05,520 --> 00:19:07,600
by sim p

514
00:19:07,600 --> 00:19:11,280
and sin p actually got x as an input

515
00:19:11,280 --> 00:19:15,919
so z z can in fact depend on x

516
00:19:15,919 --> 00:19:18,000
therefore in order to justify

517
00:19:18,000 --> 00:19:19,919
um that there's a problem

518
00:19:19,919 --> 00:19:21,679
and that this attack actually works we

519
00:19:21,679 --> 00:19:24,559
need to be more careful

520
00:19:24,559 --> 00:19:26,160
so to finish the proof

521
00:19:26,160 --> 00:19:28,640
basically what we're going to do is use

522
00:19:28,640 --> 00:19:30,480
simpy inverse

523
00:19:30,480 --> 00:19:32,880
to construct an inverter for the random

524
00:19:32,880 --> 00:19:34,559
oracle h

525
00:19:34,559 --> 00:19:36,720
the inverter is given w

526
00:19:36,720 --> 00:19:38,640
and then just guessed as a random z and

527
00:19:38,640 --> 00:19:41,039
runs simpy inverse forwarding all

528
00:19:41,039 --> 00:19:42,480
queries to h

529
00:19:42,480 --> 00:19:44,240
finally it outputs whatever simpy

530
00:19:44,240 --> 00:19:47,120
inverse outputs

531
00:19:47,120 --> 00:19:49,760
if z is the correct value that would

532
00:19:49,760 --> 00:19:53,280
have been outputted by simpy

533
00:19:53,280 --> 00:19:55,360
then we know that sin p inverse must

534
00:19:55,360 --> 00:19:56,480
succeed

535
00:19:56,480 --> 00:19:58,480
as in we we know that x prime must equal

536
00:19:58,480 --> 00:20:01,840
x because this happens in the real world

537
00:20:01,840 --> 00:20:04,159
with probability one it must therefore

538
00:20:04,159 --> 00:20:06,880
also happen in the ideal world

539
00:20:06,880 --> 00:20:09,840
uh condition on z being correct

540
00:20:09,840 --> 00:20:11,919
now since z is just random the

541
00:20:11,919 --> 00:20:14,559
probability it is correct is just

542
00:20:14,559 --> 00:20:15,520
um

543
00:20:15,520 --> 00:20:17,760
one over the number of z's

544
00:20:17,760 --> 00:20:20,240
and that is equal to one half raised to

545
00:20:20,240 --> 00:20:22,080
the

546
00:20:22,080 --> 00:20:23,520
size of the

547
00:20:23,520 --> 00:20:27,280
block minus the size of the output

548
00:20:27,919 --> 00:20:29,520
on the other hand we can bound the

549
00:20:29,520 --> 00:20:32,240
probability of success by the known

550
00:20:32,240 --> 00:20:34,480
one-wayness of random oracles

551
00:20:34,480 --> 00:20:37,360
for any algorithm making queries

552
00:20:37,360 --> 00:20:39,600
combining these together then gives us a

553
00:20:39,600 --> 00:20:41,840
lower bound on the number of queries

554
00:20:41,840 --> 00:20:43,600
shown here

555
00:20:43,600 --> 00:20:45,039
notice that if the input and output

556
00:20:45,039 --> 00:20:48,720
sizes sum to somewhat larger than the

557
00:20:48,720 --> 00:20:50,960
block size this quantity will be

558
00:20:50,960 --> 00:20:52,799
exponential implying an inefficient

559
00:20:52,799 --> 00:20:54,080
simulator

560
00:20:54,080 --> 00:20:55,760
and therefore contradicting

561
00:20:55,760 --> 00:20:57,919
indifferentiability

562
00:20:57,919 --> 00:21:01,640
this gives the theorem

563
00:21:02,080 --> 00:21:04,559
all right so now let's turn to our

564
00:21:04,559 --> 00:21:06,400
our positive result

565
00:21:06,400 --> 00:21:08,720
and the the the negative result actually

566
00:21:08,720 --> 00:21:10,720
strongly hints at how to prove reset and

567
00:21:10,720 --> 00:21:13,600
differentiability in in this case

568
00:21:13,600 --> 00:21:15,280
basically the

569
00:21:15,280 --> 00:21:17,760
the the reason that the negative result

570
00:21:17,760 --> 00:21:19,679
didn't extend to all input and output

571
00:21:19,679 --> 00:21:22,480
sizes is because the z value could

572
00:21:22,480 --> 00:21:25,840
encode um information about x

573
00:21:25,840 --> 00:21:26,720
so

574
00:21:26,720 --> 00:21:28,159
to turn this into a positive result

575
00:21:28,159 --> 00:21:30,880
that's exactly what we're going to do

576
00:21:30,880 --> 00:21:33,360
what we're going to do is have simpy

577
00:21:33,360 --> 00:21:35,520
have

578
00:21:35,520 --> 00:21:36,880
access

579
00:21:36,880 --> 00:21:37,679
to

580
00:21:37,679 --> 00:21:39,679
a

581
00:21:39,679 --> 00:21:41,039
we're going to pretend for the moment

582
00:21:41,039 --> 00:21:43,520
that cmp has access to an ideal

583
00:21:43,520 --> 00:21:45,679
permutations inverse which will denote i

584
00:21:45,679 --> 00:21:48,559
and i inverse

585
00:21:50,480 --> 00:21:51,280
now

586
00:21:51,280 --> 00:21:53,120
importantly while this is going to

587
00:21:53,120 --> 00:21:55,440
actually be shared between p and p

588
00:21:55,440 --> 00:21:58,799
inverse simpy and simpy inverse

589
00:21:58,799 --> 00:22:00,400
it's immutable and cannot be used to

590
00:22:00,400 --> 00:22:03,679
store state adaptively

591
00:22:03,679 --> 00:22:06,559
so what is uh cmp going to do it's going

592
00:22:06,559 --> 00:22:07,919
to set p

593
00:22:07,919 --> 00:22:08,960
to be

594
00:22:08,960 --> 00:22:10,640
i of x

595
00:22:10,640 --> 00:22:12,799
and it'll set the

596
00:22:12,799 --> 00:22:17,039
um this the w value to be h of x which

597
00:22:17,039 --> 00:22:18,480
it actually just gets by clearing the

598
00:22:18,480 --> 00:22:21,280
random oracle

599
00:22:21,360 --> 00:22:23,919
um simpy inverse then which also we're

600
00:22:23,919 --> 00:22:27,360
going to pretend knows i and i inverse

601
00:22:27,360 --> 00:22:30,880
just uses i to decode what's what x is

602
00:22:30,880 --> 00:22:32,960
in output x without having to break any

603
00:22:32,960 --> 00:22:37,200
one wayness of the random oracle

604
00:22:38,320 --> 00:22:40,559
now there are some lingering issues here

605
00:22:40,559 --> 00:22:44,000
the most uh obvious problem is how to

606
00:22:44,000 --> 00:22:46,000
actually simulate eye without having any

607
00:22:46,000 --> 00:22:48,240
state at all you know at least it's not

608
00:22:48,240 --> 00:22:51,360
um sort of adaptive state but it is

609
00:22:51,360 --> 00:22:53,280
still state and

610
00:22:53,280 --> 00:22:55,600
um we can't have any state if we're

611
00:22:55,600 --> 00:22:59,039
going to do reset differentiability

612
00:22:59,039 --> 00:23:01,440
and basically we show how to overcome

613
00:23:01,440 --> 00:23:04,240
this issue by using the randomness in h

614
00:23:04,240 --> 00:23:06,960
itself in order to simulate

615
00:23:06,960 --> 00:23:09,200
the random permutation in its inverse

616
00:23:09,200 --> 00:23:11,200
and this requires care in order to make

617
00:23:11,200 --> 00:23:12,799
sure that

618
00:23:12,799 --> 00:23:14,559
i and i

619
00:23:14,559 --> 00:23:17,280
i i inverse and h don't share any

620
00:23:17,280 --> 00:23:19,039
correlations that could be detected by

621
00:23:19,039 --> 00:23:22,200
the adversary

622
00:23:22,480 --> 00:23:24,320
the other issue

623
00:23:24,320 --> 00:23:25,200
is

624
00:23:25,200 --> 00:23:27,520
well we basically only explained how to

625
00:23:27,520 --> 00:23:29,760
handle the queries made by our

626
00:23:29,760 --> 00:23:31,679
particular attack we need to handle

627
00:23:31,679 --> 00:23:34,000
queries for all attacks and in

628
00:23:34,000 --> 00:23:37,120
particular we need to define what cmp

629
00:23:37,120 --> 00:23:38,799
does on inputs that don't have the form

630
00:23:38,799 --> 00:23:41,440
x concat 0. and we show how to do this

631
00:23:41,440 --> 00:23:44,880
by additionally having more

632
00:23:44,880 --> 00:23:47,360
ideal ciphers in their inverses that

633
00:23:47,360 --> 00:23:51,840
same pnc and p infers have access to

634
00:23:52,720 --> 00:23:54,400
so this concludes the overview of our

635
00:23:54,400 --> 00:23:56,480
work and i briefly wanted to discuss

636
00:23:56,480 --> 00:23:59,120
some open questions

637
00:23:59,120 --> 00:24:01,039
the main open question is that we were

638
00:24:01,039 --> 00:24:02,720
unable to answer

639
00:24:02,720 --> 00:24:04,640
whether you can build a recent

640
00:24:04,640 --> 00:24:06,480
indifferential ideal cipher from a

641
00:24:06,480 --> 00:24:08,559
random oracle if you could do this then

642
00:24:08,559 --> 00:24:10,640
this would prove the equivalence of

643
00:24:10,640 --> 00:24:12,559
ideal ciphers and

644
00:24:12,559 --> 00:24:15,279
small domain random oracles

645
00:24:15,279 --> 00:24:16,960
somewhat mirroring what's known in the

646
00:24:16,960 --> 00:24:20,480
plane and differentiability setting

647
00:24:21,440 --> 00:24:23,520
another interesting question is whether

648
00:24:23,520 --> 00:24:25,120
there is a way to more efficiently

649
00:24:25,120 --> 00:24:27,200
construct a random oracle from an atl

650
00:24:27,200 --> 00:24:28,480
cipher

651
00:24:28,480 --> 00:24:30,880
our the patent truncate construction we

652
00:24:30,880 --> 00:24:34,320
use will lose much of the domain of the

653
00:24:34,320 --> 00:24:36,400
ideal cipher in order to achieve reset

654
00:24:36,400 --> 00:24:38,480
indifferentiality and while we prove

655
00:24:38,480 --> 00:24:39,840
this is inherent to the particular

656
00:24:39,840 --> 00:24:41,279
construction maybe there's a better

657
00:24:41,279 --> 00:24:42,799
construction out there that doesn't

658
00:24:42,799 --> 00:24:46,080
suffer from such a limitation

659
00:24:46,080 --> 00:24:48,000
the final question is to explore other

660
00:24:48,000 --> 00:24:50,000
indifferentiability results which don't

661
00:24:50,000 --> 00:24:52,240
involve domain extension and see if they

662
00:24:52,240 --> 00:24:53,679
can be proved in the reset and

663
00:24:53,679 --> 00:24:55,919
differentiability setting as just one

664
00:24:55,919 --> 00:24:57,440
example

665
00:24:57,440 --> 00:24:59,600
would be indifferentiable encryption

666
00:24:59,600 --> 00:25:01,200
both in the secret key and public key

667
00:25:01,200 --> 00:25:03,679
setting which have been explored in a

668
00:25:03,679 --> 00:25:06,400
couple recent works

669
00:25:06,400 --> 00:25:09,039
with that i conclude my talk thank you

670
00:25:09,039 --> 00:25:12,200
for listening

