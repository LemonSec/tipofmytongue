1
00:00:00,160 --> 00:00:01,920
this talk is about trailer tracing for

2
00:00:01,920 --> 00:00:03,840
pseudo-random functions and is trying to

3
00:00:03,840 --> 00:00:06,720
work with reshab sam and brent

4
00:00:06,720 --> 00:00:08,800
software watermarking has been proposed

5
00:00:08,800 --> 00:00:10,800
as a mechanism for proving software

6
00:00:10,800 --> 00:00:12,960
ownership and protecting against the

7
00:00:12,960 --> 00:00:15,679
unauthorized distribution of software

8
00:00:15,679 --> 00:00:18,080
typically in a saltwater marking scheme

9
00:00:18,080 --> 00:00:20,960
a user can embed a tag or a mark within

10
00:00:20,960 --> 00:00:23,039
a program so that the resulting marked

11
00:00:23,039 --> 00:00:25,119
version of the program is functionally

12
00:00:25,119 --> 00:00:27,680
equivalent to the original program here

13
00:00:27,680 --> 00:00:29,920
the mark could be a username a serial

14
00:00:29,920 --> 00:00:32,719
number or some other kind of identifier

15
00:00:32,719 --> 00:00:35,040
the security requirement is that if an

16
00:00:35,040 --> 00:00:37,440
adversary manages to obtain a marked

17
00:00:37,440 --> 00:00:39,520
version of the program and tries to

18
00:00:39,520 --> 00:00:41,520
remove the mark from the program in

19
00:00:41,520 --> 00:00:43,760
doing so the adversary necessarily

20
00:00:43,760 --> 00:00:46,160
destroys the functionality of the

21
00:00:46,160 --> 00:00:47,200
program

22
00:00:47,200 --> 00:00:49,360
more precisely the water marking scheme

23
00:00:49,360 --> 00:00:51,520
consists of two main algorithms a

24
00:00:51,520 --> 00:00:53,039
marking algorithm that takes as

25
00:00:53,039 --> 00:00:55,680
description a boolean circuit c

26
00:00:55,680 --> 00:00:57,680
and a mark m and outputs a marked

27
00:00:57,680 --> 00:00:59,440
version of the circuit

28
00:00:59,440 --> 00:01:01,600
the second requirement is the extraction

29
00:01:01,600 --> 00:01:02,800
algorithm

30
00:01:02,800 --> 00:01:05,040
which given a circuit c prime will

31
00:01:05,040 --> 00:01:06,960
extract the mark from the underlying

32
00:01:06,960 --> 00:01:08,000
circuit

33
00:01:08,000 --> 00:01:10,080
the two requirements on a water marking

34
00:01:10,080 --> 00:01:12,880
scheme are one functionality preserving

35
00:01:12,880 --> 00:01:14,720
which essentially says the marked

36
00:01:14,720 --> 00:01:16,640
version of the circuit and the original

37
00:01:16,640 --> 00:01:19,200
circuit behave identically in terms of

38
00:01:19,200 --> 00:01:21,680
its input output behavior on almost all

39
00:01:21,680 --> 00:01:24,159
inputs in the domain or in the input

40
00:01:24,159 --> 00:01:26,479
space of the function the second

41
00:01:26,479 --> 00:01:28,799
requirement is on removability which is

42
00:01:28,799 --> 00:01:31,680
a security requirement that says that an

43
00:01:31,680 --> 00:01:34,560
adversary given a marked program c prime

44
00:01:34,560 --> 00:01:36,400
will not be able to construct a new

45
00:01:36,400 --> 00:01:39,280
program c star such that c star and c

46
00:01:39,280 --> 00:01:40,799
prime compute exactly the same

47
00:01:40,799 --> 00:01:44,079
functionality on most inputs and

48
00:01:44,079 --> 00:01:47,600
c star does not contain the mark

49
00:01:47,600 --> 00:01:49,920
with respect to the extraction algorithm

50
00:01:49,920 --> 00:01:52,720
so essentially an adversary either has

51
00:01:52,720 --> 00:01:54,479
to construct a new program that is very

52
00:01:54,479 --> 00:01:57,280
different from the market program or

53
00:01:57,280 --> 00:01:59,040
the adversary will produce a program

54
00:01:59,040 --> 00:02:01,040
that is similar to the original program

55
00:02:01,040 --> 00:02:03,759
but which will preserve the watermark

56
00:02:03,759 --> 00:02:06,240
these two requirements together

57
00:02:06,240 --> 00:02:08,959
are sufficient to show that watermarking

58
00:02:08,959 --> 00:02:11,520
is only achievable for functionalities

59
00:02:11,520 --> 00:02:14,239
that are not learnable as such the study

60
00:02:14,239 --> 00:02:16,480
of software watermarking has so far

61
00:02:16,480 --> 00:02:18,400
primarily focused on watermarking

62
00:02:18,400 --> 00:02:20,879
cryptographic functions a natural class

63
00:02:20,879 --> 00:02:23,040
of non-learnable functions

64
00:02:23,040 --> 00:02:24,959
many previous works have in fact focused

65
00:02:24,959 --> 00:02:27,040
on watermarking pseudorandom functions

66
00:02:27,040 --> 00:02:30,319
or prfs where essentially the suit the

67
00:02:30,319 --> 00:02:32,879
program has hardwired inside it the key

68
00:02:32,879 --> 00:02:35,519
for a pseudorandom function and on input

69
00:02:35,519 --> 00:02:38,000
x we'll simply output the evaluation of

70
00:02:38,000 --> 00:02:40,560
the pseudo-random function on x this is

71
00:02:40,560 --> 00:02:42,800
useful because pseudorandom functions

72
00:02:42,800 --> 00:02:44,239
are the workhorses of symmetric

73
00:02:44,239 --> 00:02:46,400
cryptography and so once we can

74
00:02:46,400 --> 00:02:48,959
watermark a pseudorandom function we can

75
00:02:48,959 --> 00:02:50,959
use it to watermark the signing key for

76
00:02:50,959 --> 00:02:53,040
a message authentication code or the

77
00:02:53,040 --> 00:02:55,760
decryption key in asymmetric encryption

78
00:02:55,760 --> 00:02:57,280
scheme

79
00:02:57,280 --> 00:02:59,760
the starting point of our work is to

80
00:02:59,760 --> 00:03:02,080
revisit the security definitions

81
00:03:02,080 --> 00:03:03,920
underlying these kinds of software

82
00:03:03,920 --> 00:03:06,239
watermarking schemes especially in a

83
00:03:06,239 --> 00:03:08,560
setting of pseudorandom functions

84
00:03:08,560 --> 00:03:10,800
let us take a look at the unremovability

85
00:03:10,800 --> 00:03:13,200
requirement in greater detail

86
00:03:13,200 --> 00:03:15,239
under the current formulation of

87
00:03:15,239 --> 00:03:18,000
unremovability we require security to

88
00:03:18,000 --> 00:03:20,959
hold against any adversarial strategy

89
00:03:20,959 --> 00:03:22,959
that preserves the functionality of the

90
00:03:22,959 --> 00:03:25,440
marked program here we capture this

91
00:03:25,440 --> 00:03:27,599
notion of function equivalency by

92
00:03:27,599 --> 00:03:29,680
requiring that the adversaries program

93
00:03:29,680 --> 00:03:32,799
preserve the exact input output behavior

94
00:03:32,799 --> 00:03:34,239
of the program

95
00:03:34,239 --> 00:03:36,720
so consider the sec setting in the case

96
00:03:36,720 --> 00:03:39,040
of a pseudorandom function and consider

97
00:03:39,040 --> 00:03:42,159
is in particular an adversarial strategy

98
00:03:42,159 --> 00:03:44,560
that produces a program that only

99
00:03:44,560 --> 00:03:47,280
outputs the n over four bits of the

100
00:03:47,280 --> 00:03:49,280
pseudo-random function namely on any

101
00:03:49,280 --> 00:03:52,400
input x it will evaluate the prf at x

102
00:03:52,400 --> 00:03:54,720
and then it will truncate the output to

103
00:03:54,720 --> 00:03:57,280
only preserve the first and over four

104
00:03:57,280 --> 00:03:58,159
bits

105
00:03:58,159 --> 00:04:00,879
under the existing security notion this

106
00:04:00,879 --> 00:04:03,120
strategy does not preserve the exact

107
00:04:03,120 --> 00:04:04,879
input output behavior in fact it

108
00:04:04,879 --> 00:04:06,560
preserves the exact input output

109
00:04:06,560 --> 00:04:10,000
behavior on none of the inputs and so

110
00:04:10,000 --> 00:04:11,599
this is considered to not be

111
00:04:11,599 --> 00:04:14,480
functionality preserving and as such the

112
00:04:14,480 --> 00:04:17,600
definition of unremovability stipulates

113
00:04:17,600 --> 00:04:20,160
no guarantees on whether this new

114
00:04:20,160 --> 00:04:22,880
program contains the mark or not

115
00:04:22,880 --> 00:04:25,040
in fact if you look at all existing

116
00:04:25,040 --> 00:04:27,120
constructions of software watermarking

117
00:04:27,120 --> 00:04:29,360
for the case of pseudorandom functions

118
00:04:29,360 --> 00:04:31,280
they would be unable to recover the

119
00:04:31,280 --> 00:04:34,080
watermark from this kind of program

120
00:04:34,080 --> 00:04:36,479
it turns out that this can actually be

121
00:04:36,479 --> 00:04:38,400
quite problematic in concrete

122
00:04:38,400 --> 00:04:39,759
applications

123
00:04:39,759 --> 00:04:42,479
so imagine a scenario where we have a

124
00:04:42,479 --> 00:04:45,199
watermarkable prf and we want to use

125
00:04:45,199 --> 00:04:47,600
this to protect the decryption keys in a

126
00:04:47,600 --> 00:04:49,600
symmetric encryption scheme

127
00:04:49,600 --> 00:04:51,680
in this case a program that outputs the

128
00:04:51,680 --> 00:04:53,440
first and over four bits of a

129
00:04:53,440 --> 00:04:55,840
pseudorandom function might completely

130
00:04:55,840 --> 00:04:58,639
break semantic security of any

131
00:04:58,639 --> 00:05:00,880
encryption scheme that depends on it and

132
00:05:00,880 --> 00:05:02,880
yet it would not be possible to remove

133
00:05:02,880 --> 00:05:05,360
the mark to recover the mark from this

134
00:05:05,360 --> 00:05:07,680
particular decryption program because

135
00:05:07,680 --> 00:05:09,680
under the existing definitions it does

136
00:05:09,680 --> 00:05:11,759
not preserve functionality

137
00:05:11,759 --> 00:05:13,600
let's illustrate this using a simple

138
00:05:13,600 --> 00:05:14,639
example

139
00:05:14,639 --> 00:05:17,039
on the left here we have an image that

140
00:05:17,039 --> 00:05:19,360
is encrypted using a standard prf based

141
00:05:19,360 --> 00:05:21,759
encryption scheme say encounter mode and

142
00:05:21,759 --> 00:05:24,560
now suppose we run our decryption

143
00:05:24,560 --> 00:05:26,560
our decryption program that only

144
00:05:26,560 --> 00:05:28,880
recovers the first and over four bits of

145
00:05:28,880 --> 00:05:30,960
the pseudorandom function on this

146
00:05:30,960 --> 00:05:32,400
encrypted image

147
00:05:32,400 --> 00:05:34,639
just by visual inspection it is pretty

148
00:05:34,639 --> 00:05:37,039
clear what the image is encrypting and

149
00:05:37,039 --> 00:05:39,600
for all intensive purposes this program

150
00:05:39,600 --> 00:05:41,520
actually functions as a pretty good

151
00:05:41,520 --> 00:05:43,280
decryption algorithm

152
00:05:43,280 --> 00:05:45,039
however the water marking security

153
00:05:45,039 --> 00:05:47,440
definitions provide no guarantees on

154
00:05:47,440 --> 00:05:49,360
whether we can extract a mark from this

155
00:05:49,360 --> 00:05:52,160
program or not so if we're depending on

156
00:05:52,160 --> 00:05:54,479
the water marking scheme to ensure that

157
00:05:54,479 --> 00:05:56,639
we can identify who leaked or who

158
00:05:56,639 --> 00:05:59,360
compromised a particular key or who the

159
00:05:59,360 --> 00:06:00,479
who

160
00:06:00,479 --> 00:06:03,199
the owner of this particular program is

161
00:06:03,199 --> 00:06:05,039
such a decryption program that

162
00:06:05,039 --> 00:06:07,199
essentially breaks security of the

163
00:06:07,199 --> 00:06:09,199
encryption scheme we would not be able

164
00:06:09,199 --> 00:06:12,080
to get any of the watermarking benefits

165
00:06:12,080 --> 00:06:15,360
from such a program and this i believe

166
00:06:15,360 --> 00:06:17,600
illustrates why when we consider

167
00:06:17,600 --> 00:06:18,880
protecting building blocks like

168
00:06:18,880 --> 00:06:21,440
pseudorandom functions restricting the

169
00:06:21,440 --> 00:06:24,000
definition the security definition to

170
00:06:24,000 --> 00:06:26,720
only allow adversarial strategies that

171
00:06:26,720 --> 00:06:29,440
preserve the exact input output behavior

172
00:06:29,440 --> 00:06:31,840
is overly restrictive and does not can

173
00:06:31,840 --> 00:06:34,400
capture the full range of potential

174
00:06:34,400 --> 00:06:36,639
attack strategies strategies that might

175
00:06:36,639 --> 00:06:38,479
be considered to have defeated the

176
00:06:38,479 --> 00:06:41,120
scheme in any realistic application

177
00:06:41,120 --> 00:06:42,880
would not be permitted under the

178
00:06:42,880 --> 00:06:45,600
existing security model

179
00:06:45,600 --> 00:06:48,000
and more broadly this problem with the

180
00:06:48,000 --> 00:06:49,759
existing definition is that it's

181
00:06:49,759 --> 00:06:52,000
fundamentally tying the adversary's

182
00:06:52,000 --> 00:06:54,479
goals to the functionality requirements

183
00:06:54,479 --> 00:06:55,520
itself

184
00:06:55,520 --> 00:06:57,919
well typically in cryptography we try

185
00:06:57,919 --> 00:07:00,080
and decouple these for instance in the

186
00:07:00,080 --> 00:07:02,960
case of encryption we require that the

187
00:07:02,960 --> 00:07:05,039
honest parties are able to recover the

188
00:07:05,039 --> 00:07:07,120
message in their entirety

189
00:07:07,120 --> 00:07:09,280
but when we consider the adversary when

190
00:07:09,280 --> 00:07:11,120
we consider the security notion and what

191
00:07:11,120 --> 00:07:13,599
the adversary's goals are we will say

192
00:07:13,599 --> 00:07:15,599
that recovering any information about

193
00:07:15,599 --> 00:07:17,599
the message from the ciphertext will

194
00:07:17,599 --> 00:07:20,000
constitute a successful attack

195
00:07:20,000 --> 00:07:22,080
naturally the same philosophy should

196
00:07:22,080 --> 00:07:23,919
also apply to softer watermarking

197
00:07:23,919 --> 00:07:26,240
schemes when we consider notions like

198
00:07:26,240 --> 00:07:28,160
pseudorandom functions

199
00:07:28,160 --> 00:07:30,319
here the exact functionality preserving

200
00:07:30,319 --> 00:07:32,560
seems like a very natural notion when

201
00:07:32,560 --> 00:07:34,560
capturing correctness but it does not

202
00:07:34,560 --> 00:07:37,280
seem like the right notion for security

203
00:07:37,280 --> 00:07:39,759
namely what we would desire if we want a

204
00:07:39,759 --> 00:07:41,680
watermarking scheme for pseudo-random

205
00:07:41,680 --> 00:07:44,240
functions is that whenever the adversary

206
00:07:44,240 --> 00:07:47,440
produces a program that breaks the

207
00:07:47,440 --> 00:07:50,000
security of the primitive then the

208
00:07:50,000 --> 00:07:52,400
watermark should also be preserved and

209
00:07:52,400 --> 00:07:54,479
should be able to be extracted given

210
00:07:54,479 --> 00:07:56,319
access to such a program

211
00:07:56,319 --> 00:07:58,400
and this motivates the main primitive

212
00:07:58,400 --> 00:08:00,319
that we introduce in this work to

213
00:08:00,319 --> 00:08:02,960
address the shortcomings in existing

214
00:08:02,960 --> 00:08:04,639
definitions of security for

215
00:08:04,639 --> 00:08:07,280
watermarkable prfs we introduced the

216
00:08:07,280 --> 00:08:09,919
notion of a traceable prf where

217
00:08:09,919 --> 00:08:12,400
essentially we require that this marking

218
00:08:12,400 --> 00:08:14,400
security or this unremovability

219
00:08:14,400 --> 00:08:16,720
guarantee to hold not just against

220
00:08:16,720 --> 00:08:18,720
programs that preserve the exact input

221
00:08:18,720 --> 00:08:21,680
output behavior but more generally any

222
00:08:21,680 --> 00:08:24,160
program that manages to break security

223
00:08:24,160 --> 00:08:26,400
of the pseudo-random function this

224
00:08:26,400 --> 00:08:28,639
notion is very similar to the setting in

225
00:08:28,639 --> 00:08:31,120
trader tracing where we require that any

226
00:08:31,120 --> 00:08:32,799
program that is able to decrypt

227
00:08:32,799 --> 00:08:35,599
ciphertexts must necessarily preserve

228
00:08:35,599 --> 00:08:39,120
the embedded identifier namely the mark

229
00:08:39,120 --> 00:08:40,880
in the case of a traceable prf we

230
00:08:40,880 --> 00:08:43,120
require that any program that is able to

231
00:08:43,120 --> 00:08:45,680
break prf security must contain the

232
00:08:45,680 --> 00:08:47,839
watermark itself and a watermark should

233
00:08:47,839 --> 00:08:51,440
be extractable from any such program

234
00:08:51,440 --> 00:08:53,120
we can model this more generally as

235
00:08:53,120 --> 00:08:55,680
follows suppose an adversary is given a

236
00:08:55,680 --> 00:08:57,360
marked version of a pseudorandom

237
00:08:57,360 --> 00:08:59,600
function and this adversary produces a

238
00:08:59,600 --> 00:09:01,200
new circuit c

239
00:09:01,200 --> 00:09:03,440
we say that the circuit c is good or

240
00:09:03,440 --> 00:09:06,080
that it breaks pseudorandomness if

241
00:09:06,080 --> 00:09:08,320
essentially it can win the prf security

242
00:09:08,320 --> 00:09:10,560
game given input output behaviors of

243
00:09:10,560 --> 00:09:12,640
either the pseudo-random function or the

244
00:09:12,640 --> 00:09:15,279
truly random function the circuit c will

245
00:09:15,279 --> 00:09:17,839
be able to tell these two distributions

246
00:09:17,839 --> 00:09:18,880
apart

247
00:09:18,880 --> 00:09:20,480
now if we look at this particular

248
00:09:20,480 --> 00:09:22,880
definition as formulated currently there

249
00:09:22,880 --> 00:09:24,959
is actually an problem that it is

250
00:09:24,959 --> 00:09:27,760
problematic because the circuit c here

251
00:09:27,760 --> 00:09:29,440
could actually just contain a single

252
00:09:29,440 --> 00:09:31,200
hard-coded input output of the

253
00:09:31,200 --> 00:09:33,360
pseudo-random function right the circuit

254
00:09:33,360 --> 00:09:34,800
c is derived from the original

255
00:09:34,800 --> 00:09:36,720
pseudo-random function so it contains

256
00:09:36,720 --> 00:09:38,399
information about the input output

257
00:09:38,399 --> 00:09:41,680
behavior so we construct a distinguisher

258
00:09:41,680 --> 00:09:45,519
that has a single x-star prf at x-star

259
00:09:45,519 --> 00:09:47,839
hardwired inside it it can always

260
00:09:47,839 --> 00:09:49,680
trivially break

261
00:09:49,680 --> 00:09:51,760
and distinguish these two distributions

262
00:09:51,760 --> 00:09:54,240
just by evaluating at x star and seeing

263
00:09:54,240 --> 00:09:55,760
whether the response matches the

264
00:09:55,760 --> 00:09:57,839
pseudo-random value or

265
00:09:57,839 --> 00:09:59,440
does not match in which case we can

266
00:09:59,440 --> 00:10:01,760
conclude that we are interacting with a

267
00:10:01,760 --> 00:10:04,320
truly random function in this particular

268
00:10:04,320 --> 00:10:06,240
case this particular circuit c is not

269
00:10:06,240 --> 00:10:07,839
very interesting because it only

270
00:10:07,839 --> 00:10:09,519
contains information about the

271
00:10:09,519 --> 00:10:12,240
pseudo-random function at a single point

272
00:10:12,240 --> 00:10:14,160
and in some sense it's not really

273
00:10:14,160 --> 00:10:16,640
capturing the full capabilities of the

274
00:10:16,640 --> 00:10:19,920
prf so in order to make this definition

275
00:10:19,920 --> 00:10:22,560
meaningful and useful we will relax the

276
00:10:22,560 --> 00:10:24,800
security requirement and say that the

277
00:10:24,800 --> 00:10:27,040
adversary has to produce a circuit c

278
00:10:27,040 --> 00:10:29,040
that contains some kind of global

279
00:10:29,040 --> 00:10:32,800
structure about the prf behavior namely

280
00:10:32,800 --> 00:10:33,760
the

281
00:10:33,760 --> 00:10:35,440
le circus c should be able to

282
00:10:35,440 --> 00:10:37,360
distinguish a pseudo-random function

283
00:10:37,360 --> 00:10:40,320
given only random evaluations of the prf

284
00:10:40,320 --> 00:10:42,800
so prf evaluations on random points in

285
00:10:42,800 --> 00:10:45,600
the domain in other words we allow the

286
00:10:45,600 --> 00:10:47,200
distinguish we require that the

287
00:10:47,200 --> 00:10:50,079
distinguisher not only be able to break

288
00:10:50,079 --> 00:10:52,320
strong pseudo-randomness but even break

289
00:10:52,320 --> 00:10:54,480
weak pseudorandomness the adversary has

290
00:10:54,480 --> 00:10:56,720
to produce a circuit c that contains

291
00:10:56,720 --> 00:10:58,079
some global structure of the

292
00:10:58,079 --> 00:11:00,079
pseudorandom function that contains

293
00:11:00,079 --> 00:11:02,959
information about the outputs of the prf

294
00:11:02,959 --> 00:11:04,880
on a

295
00:11:04,880 --> 00:11:08,480
large fraction of the domain

296
00:11:08,480 --> 00:11:10,959
so just more formally the syntax of a

297
00:11:10,959 --> 00:11:13,279
traceable prf consists of the following

298
00:11:13,279 --> 00:11:15,680
four algorithms a setup algorithm that

299
00:11:15,680 --> 00:11:17,360
samples the pseudo key for the

300
00:11:17,360 --> 00:11:19,839
pseudorandom function a key generation

301
00:11:19,839 --> 00:11:22,399
algorithm this basically embeds a mark

302
00:11:22,399 --> 00:11:25,200
or an identifier here denoted id within

303
00:11:25,200 --> 00:11:27,839
the key an evaluation algorithm that

304
00:11:27,839 --> 00:11:30,640
basically implements prf evaluation and

305
00:11:30,640 --> 00:11:33,040
finally a tracing algorithm that given

306
00:11:33,040 --> 00:11:35,600
oracle access to some distinguisher will

307
00:11:35,600 --> 00:11:38,480
be able to produce an identity or a set

308
00:11:38,480 --> 00:11:40,480
of identities that were used to

309
00:11:40,480 --> 00:11:42,800
construct that distinguisher

310
00:11:42,800 --> 00:11:44,560
the properties we require are

311
00:11:44,560 --> 00:11:47,120
correctness which basically says

312
00:11:47,120 --> 00:11:48,800
is basically saying functionality

313
00:11:48,800 --> 00:11:51,760
preserving holds namely the unmarked

314
00:11:51,760 --> 00:11:54,000
version of the key the master prf key

315
00:11:54,000 --> 00:11:55,760
should implement roughly the same

316
00:11:55,760 --> 00:11:58,639
functionality as the marked version of

317
00:11:58,639 --> 00:11:59,760
the key

318
00:11:59,760 --> 00:12:01,680
pseudo-randomness requires that we still

319
00:12:01,680 --> 00:12:03,360
have a pseudo-random function so

320
00:12:03,360 --> 00:12:06,800
evaluation using the prf key induces a

321
00:12:06,800 --> 00:12:09,120
pseudo-random distribution and finally

322
00:12:09,120 --> 00:12:11,680
we have this tracing security definition

323
00:12:11,680 --> 00:12:13,920
which as i defined earlier says any

324
00:12:13,920 --> 00:12:15,920
adversary that manages to produce a

325
00:12:15,920 --> 00:12:18,320
useful distinguisher that can

326
00:12:18,320 --> 00:12:20,480
break pseudo-randomness on uniform

327
00:12:20,480 --> 00:12:23,440
random stamp given uniform

328
00:12:23,440 --> 00:12:25,120
input outputs

329
00:12:25,120 --> 00:12:27,839
will be able to

330
00:12:27,839 --> 00:12:29,519
will must necessarily preserve the

331
00:12:29,519 --> 00:12:32,079
watermark more formally we model this as

332
00:12:32,079 --> 00:12:33,839
a gain between an adversary and a

333
00:12:33,839 --> 00:12:36,079
challenger the adversary starts by

334
00:12:36,079 --> 00:12:39,360
specifying a mark or an identity

335
00:12:39,360 --> 00:12:40,880
it gets the secret key for that

336
00:12:40,880 --> 00:12:43,200
particular identity and then it needs to

337
00:12:43,200 --> 00:12:45,279
construct a distinguisher

338
00:12:45,279 --> 00:12:47,040
in a single key setting we only allow

339
00:12:47,040 --> 00:12:50,079
the adversary to submit a single key the

340
00:12:50,079 --> 00:12:52,079
requirement is that as long as this

341
00:12:52,079 --> 00:12:54,560
distinguisher is useful namely it breaks

342
00:12:54,560 --> 00:12:56,079
weak pseudorandomness with

343
00:12:56,079 --> 00:12:58,480
non-negligible advantage epsilon then

344
00:12:58,480 --> 00:13:00,720
the tracing algorithm will successfully

345
00:13:00,720 --> 00:13:03,680
recover this identity with probability

346
00:13:03,680 --> 00:13:07,200
that is close to epsilon

347
00:13:07,200 --> 00:13:09,120
one nice property of traceable

348
00:13:09,120 --> 00:13:11,120
pseudo-random functions is that we can

349
00:13:11,120 --> 00:13:13,680
directly use them to obtain traceable

350
00:13:13,680 --> 00:13:15,360
notions of other

351
00:13:15,360 --> 00:13:17,200
primitives built from pseudorandom

352
00:13:17,200 --> 00:13:20,399
functions for instance if we apply if we

353
00:13:20,399 --> 00:13:22,480
consider the construction of symmetric

354
00:13:22,480 --> 00:13:24,320
encryption from any pseudo-random

355
00:13:24,320 --> 00:13:27,040
function and we replace that encryption

356
00:13:27,040 --> 00:13:29,600
scheme with a trace sorry if we replace

357
00:13:29,600 --> 00:13:31,360
the pseudo-random function with a

358
00:13:31,360 --> 00:13:33,680
traceable pseudorandom function then we

359
00:13:33,680 --> 00:13:35,839
get a traceable encryption scheme in

360
00:13:35,839 --> 00:13:37,920
fact this gives us a secret key trader

361
00:13:37,920 --> 00:13:40,079
tracing scheme

362
00:13:40,079 --> 00:13:41,760
now i'll

363
00:13:41,760 --> 00:13:43,839
note here that this is not the case if

364
00:13:43,839 --> 00:13:46,399
we start with a water markable prf for

365
00:13:46,399 --> 00:13:48,880
many of these reasons that i outlined at

366
00:13:48,880 --> 00:13:51,440
the beginning of this talk so traceable

367
00:13:51,440 --> 00:13:53,920
prfs are useful in a sense that they

368
00:13:53,920 --> 00:13:56,639
allow us to directly take an application

369
00:13:56,639 --> 00:13:58,720
that depends on pseudo-random functions

370
00:13:58,720 --> 00:14:02,240
and derive a traceable version of that

371
00:14:02,240 --> 00:14:04,800
application with watermarkable prfs

372
00:14:04,800 --> 00:14:06,720
because it satisfies this much weaker

373
00:14:06,720 --> 00:14:09,360
security notion these types of results

374
00:14:09,360 --> 00:14:11,600
do not apply

375
00:14:11,600 --> 00:14:13,760
so in terms of constructions we show in

376
00:14:13,760 --> 00:14:15,680
this work that under the learning with

377
00:14:15,680 --> 00:14:17,680
errors assumption we can construct a

378
00:14:17,680 --> 00:14:20,720
single key traceable prf so here uh

379
00:14:20,720 --> 00:14:22,399
tracing security holds against an

380
00:14:22,399 --> 00:14:25,120
adversary that just obtains a single

381
00:14:25,120 --> 00:14:26,240
key

382
00:14:26,240 --> 00:14:29,920
and the resulting construction

383
00:14:29,920 --> 00:14:32,639
is in the secret tracing model so only

384
00:14:32,639 --> 00:14:35,440
an authority that knows a secret tracing

385
00:14:35,440 --> 00:14:38,800
key will be able to uh extract the mark

386
00:14:38,800 --> 00:14:40,320
from a particular

387
00:14:40,320 --> 00:14:41,440
circuit

388
00:14:41,440 --> 00:14:43,199
and then assuming indistinguishability

389
00:14:43,199 --> 00:14:45,360
obfuscation and one-way functions we can

390
00:14:45,360 --> 00:14:47,120
actually get a fully collusion resistant

391
00:14:47,120 --> 00:14:49,360
traceable pseudorandom function and this

392
00:14:49,360 --> 00:14:51,519
even supports public tracing where any

393
00:14:51,519 --> 00:14:53,839
party is able to trace just given the

394
00:14:53,839 --> 00:14:56,079
public parameters of the scheme

395
00:14:56,079 --> 00:14:58,160
and something that's noteworthy here is

396
00:14:58,160 --> 00:14:59,839
that the assumptions that we need to

397
00:14:59,839 --> 00:15:02,240
rely on in both the single key setting

398
00:15:02,240 --> 00:15:03,839
as well as the collusion resistance

399
00:15:03,839 --> 00:15:06,079
setting are exactly the same as the

400
00:15:06,079 --> 00:15:08,000
assumptions we need for water markable

401
00:15:08,000 --> 00:15:10,560
prfs so even though we have dramatically

402
00:15:10,560 --> 00:15:14,000
strengthened this achievable security

403
00:15:14,000 --> 00:15:16,000
with this new definition of a traceable

404
00:15:16,000 --> 00:15:20,079
prf we can still obtain many of the

405
00:15:20,079 --> 00:15:22,720
similar kinds of constructions from the

406
00:15:22,720 --> 00:15:24,959
same underlying assumptions and they all

407
00:15:24,959 --> 00:15:28,000
rely on similar building blocks however

408
00:15:28,000 --> 00:15:29,519
we there is no

409
00:15:29,519 --> 00:15:32,000
as a black box way of taking a water

410
00:15:32,000 --> 00:15:34,560
markable construction and translating it

411
00:15:34,560 --> 00:15:37,199
into a traceable construction

412
00:15:37,199 --> 00:15:38,720
and in this talk i'm mostly going to

413
00:15:38,720 --> 00:15:42,399
focus on the construction based on lwe

414
00:15:42,399 --> 00:15:43,839
so to construct the traceable

415
00:15:43,839 --> 00:15:46,079
pseudorandom function we are going to

416
00:15:46,079 --> 00:15:48,560
rely on a new intermediate notion that

417
00:15:48,560 --> 00:15:50,800
we call a private linear constrained

418
00:15:50,800 --> 00:15:53,759
pseudorandom function and this very much

419
00:15:53,759 --> 00:15:55,680
parallels the constructions of trader

420
00:15:55,680 --> 00:15:58,399
tracing from the notion called private

421
00:15:58,399 --> 00:16:00,560
linear broadcast encryption you can view

422
00:16:00,560 --> 00:16:02,639
private linear constrained prfs as

423
00:16:02,639 --> 00:16:05,120
essentially the analog of a private

424
00:16:05,120 --> 00:16:07,600
linear broadcast encryption in the prf

425
00:16:07,600 --> 00:16:08,399
world

426
00:16:08,399 --> 00:16:10,320
so let's begin by defining this notion

427
00:16:10,320 --> 00:16:14,000
more precisely so in a constrained prf

428
00:16:14,000 --> 00:16:16,800
the holder of the prf key can constrain

429
00:16:16,800 --> 00:16:18,720
it with respect to some constraint

430
00:16:18,720 --> 00:16:20,720
hereby again modeled as a boolean

431
00:16:20,720 --> 00:16:23,839
circuit c to produce a constrained key

432
00:16:23,839 --> 00:16:26,079
the constraint key can in turn be used

433
00:16:26,079 --> 00:16:28,320
to evaluate the pseudo-random function

434
00:16:28,320 --> 00:16:30,480
at all points x in the domain that

435
00:16:30,480 --> 00:16:32,480
satisfy the constraint

436
00:16:32,480 --> 00:16:34,160
in the case where we are considering a

437
00:16:34,160 --> 00:16:36,800
linear constraint family then the input

438
00:16:36,800 --> 00:16:38,560
points are associated with that with

439
00:16:38,560 --> 00:16:41,040
some index t and this index t you can

440
00:16:41,040 --> 00:16:44,880
view as a number between 0 and 2 to dl

441
00:16:44,880 --> 00:16:46,959
and the constrained keys is also

442
00:16:46,959 --> 00:16:49,519
identified with an associated with an

443
00:16:49,519 --> 00:16:51,839
identifier here this is a number between

444
00:16:51,839 --> 00:16:54,959
0 and 2 to dl minus 1.

445
00:16:54,959 --> 00:16:57,360
the we say that it's a linear constraint

446
00:16:57,360 --> 00:17:00,320
family when basically a constrained key

447
00:17:00,320 --> 00:17:03,519
with index id can be used to evaluate on

448
00:17:03,519 --> 00:17:05,919
all domain elements whose index is

449
00:17:05,919 --> 00:17:08,880
smaller than the index associated with

450
00:17:08,880 --> 00:17:10,640
the key itself

451
00:17:10,640 --> 00:17:12,640
finally we say that

452
00:17:12,640 --> 00:17:14,959
a linear constraint prf is a private

453
00:17:14,959 --> 00:17:17,679
linear constraint prf if the index that

454
00:17:17,679 --> 00:17:20,240
is associated with a particular index

455
00:17:20,240 --> 00:17:23,839
point is actually hidden

456
00:17:23,839 --> 00:17:25,919
finally there exists a sampling

457
00:17:25,919 --> 00:17:28,319
algorithm and that can be used to sample

458
00:17:28,319 --> 00:17:31,280
inputs with a specified index so again

459
00:17:31,280 --> 00:17:32,880
there's two dl

460
00:17:32,880 --> 00:17:34,799
possible indices there's a sampling

461
00:17:34,799 --> 00:17:36,880
algorithm that takes a particular index

462
00:17:36,880 --> 00:17:39,360
and will sample up here a domain element

463
00:17:39,360 --> 00:17:41,520
in the domain of the prf that has that

464
00:17:41,520 --> 00:17:43,440
particular index

465
00:17:43,440 --> 00:17:45,840
now we require some additional security

466
00:17:45,840 --> 00:17:47,760
properties to hold for our private

467
00:17:47,760 --> 00:17:49,840
linear constraints to prf

468
00:17:49,840 --> 00:17:52,720
the first property is that the points in

469
00:17:52,720 --> 00:17:54,799
the domain of the pseudorandom function

470
00:17:54,799 --> 00:17:57,280
that has the smallest index namely index

471
00:17:57,280 --> 00:17:58,160
0

472
00:17:58,160 --> 00:18:00,000
these are the distribution of these

473
00:18:00,000 --> 00:18:00,880
points

474
00:18:00,880 --> 00:18:02,880
are actually indistinguishable from just

475
00:18:02,880 --> 00:18:05,120
sampling a random element in the domain

476
00:18:05,120 --> 00:18:06,880
of the prf so

477
00:18:06,880 --> 00:18:09,679
we the distribution over the points with

478
00:18:09,679 --> 00:18:11,520
index 0 is computationally

479
00:18:11,520 --> 00:18:13,760
indistinguishable from a uniform random

480
00:18:13,760 --> 00:18:16,000
distribution over the full domain of the

481
00:18:16,000 --> 00:18:18,480
prf

482
00:18:18,640 --> 00:18:21,840
next we require that a prf input that

483
00:18:21,840 --> 00:18:25,919
has an index i versus an index j are

484
00:18:25,919 --> 00:18:29,200
computationally indistinguishable unless

485
00:18:29,200 --> 00:18:31,600
the adversary possesses a key for an

486
00:18:31,600 --> 00:18:33,679
identity that lies in between this

487
00:18:33,679 --> 00:18:36,240
interval so notice that if the adversary

488
00:18:36,240 --> 00:18:38,640
possesses a key that lies between this

489
00:18:38,640 --> 00:18:40,640
interval then the key can be used to

490
00:18:40,640 --> 00:18:42,480
evaluate the prf

491
00:18:42,480 --> 00:18:44,880
with index i but cannot be used to

492
00:18:44,880 --> 00:18:47,039
evaluate the prf at the point with index

493
00:18:47,039 --> 00:18:47,840
j

494
00:18:47,840 --> 00:18:50,480
however if the adversary does not have

495
00:18:50,480 --> 00:18:51,760
such a key

496
00:18:51,760 --> 00:18:53,840
that either it is unable to evaluate the

497
00:18:53,840 --> 00:18:56,720
prf at both i inj where it is able to

498
00:18:56,720 --> 00:18:59,919
evaluate the prf at points i and j so

499
00:18:59,919 --> 00:19:01,760
identity hiding says

500
00:19:01,760 --> 00:19:03,520
that in this case the adversary would

501
00:19:03,520 --> 00:19:05,760
not be able to distinguish a point with

502
00:19:05,760 --> 00:19:09,280
index i from a point with index j

503
00:19:09,280 --> 00:19:11,440
and finally the last requirement is

504
00:19:11,440 --> 00:19:14,000
pseudorandomness which basically says

505
00:19:14,000 --> 00:19:14,799
the

506
00:19:14,799 --> 00:19:17,039
valuing the value of the pseudorandom

507
00:19:17,039 --> 00:19:19,120
function on inputs with the largest

508
00:19:19,120 --> 00:19:21,440
index namely 2 to dl will appear

509
00:19:21,440 --> 00:19:24,640
pseudorandom even if the adversary has

510
00:19:24,640 --> 00:19:27,120
many constrained keys and this follows

511
00:19:27,120 --> 00:19:29,760
because any constrained key will never

512
00:19:29,760 --> 00:19:33,440
enable evaluation at the largest point

513
00:19:33,440 --> 00:19:34,320
in

514
00:19:34,320 --> 00:19:35,200
in this

515
00:19:35,200 --> 00:19:36,799
set

516
00:19:36,799 --> 00:19:39,280
so once we have a private linear

517
00:19:39,280 --> 00:19:41,200
constrained prf that satisfies these

518
00:19:41,200 --> 00:19:43,360
three properties it is actually fairly

519
00:19:43,360 --> 00:19:46,080
straightforward to construct a traceable

520
00:19:46,080 --> 00:19:49,360
prf so let's show how we can use these

521
00:19:49,360 --> 00:19:51,280
three properties to aid us in

522
00:19:51,280 --> 00:19:53,679
constructing the tracing algorithm the

523
00:19:53,679 --> 00:19:55,600
assumption here is that we have an

524
00:19:55,600 --> 00:19:57,840
adversary who manages to produce a

525
00:19:57,840 --> 00:20:00,160
distinguisher that is able to break weak

526
00:20:00,160 --> 00:20:02,559
pseudorandomness of the traceable prf

527
00:20:02,559 --> 00:20:05,039
with non-negligible advantage epsilon so

528
00:20:05,039 --> 00:20:07,120
the distinguishing advantage here is

529
00:20:07,120 --> 00:20:08,559
epsilon

530
00:20:08,559 --> 00:20:10,799
so suppose now

531
00:20:10,799 --> 00:20:12,880
that we want to trace this particular

532
00:20:12,880 --> 00:20:14,240
distinguisher

533
00:20:14,240 --> 00:20:17,600
the first property we have is that if we

534
00:20:17,600 --> 00:20:21,440
sample a domain element with index 0

535
00:20:21,440 --> 00:20:23,520
these are going to be indistinguishable

536
00:20:23,520 --> 00:20:25,919
from a random domain element and because

537
00:20:25,919 --> 00:20:27,760
the distinguisher is able to break weak

538
00:20:27,760 --> 00:20:29,840
pseudorandomness with advantage epsilon

539
00:20:29,840 --> 00:20:32,480
so given just input output behavior on

540
00:20:32,480 --> 00:20:34,559
random domain elements

541
00:20:34,559 --> 00:20:35,520
then

542
00:20:35,520 --> 00:20:37,200
if we replace those random domain

543
00:20:37,200 --> 00:20:40,000
elements with random elements with index

544
00:20:40,000 --> 00:20:42,320
0 then the distinguisher would still

545
00:20:42,320 --> 00:20:45,440
succeed with advantage around epsilon or

546
00:20:45,440 --> 00:20:48,559
negligibly close to epsilon

547
00:20:48,559 --> 00:20:50,960
at the other end of the spectrum if we

548
00:20:50,960 --> 00:20:53,360
instead of sampling domain elements with

549
00:20:53,360 --> 00:20:55,919
index 0 we sample domain elements with

550
00:20:55,919 --> 00:20:57,919
index 2 to dl well by the

551
00:20:57,919 --> 00:21:00,480
pseudo-randomness property the decoder

552
00:21:00,480 --> 00:21:02,240
or the distinguisher should have

553
00:21:02,240 --> 00:21:04,720
advantage that is negligible or

554
00:21:04,720 --> 00:21:08,000
negligibly close to zero because the

555
00:21:08,000 --> 00:21:09,919
distinguisher should should not be able

556
00:21:09,919 --> 00:21:11,840
to distinguish in this particular

557
00:21:11,840 --> 00:21:12,880
setting

558
00:21:12,880 --> 00:21:14,880
now if we look at the points in between

559
00:21:14,880 --> 00:21:17,360
if we consider two points i and j we

560
00:21:17,360 --> 00:21:19,520
know that by this final property this

561
00:21:19,520 --> 00:21:21,360
identity hiding property the

562
00:21:21,360 --> 00:21:23,280
distinguishing advantage can only change

563
00:21:23,280 --> 00:21:25,520
by a negligible amount

564
00:21:25,520 --> 00:21:27,360
as long as the

565
00:21:27,360 --> 00:21:30,799
adversary did not have a key for

566
00:21:30,799 --> 00:21:33,120
that lies between that interval

567
00:21:33,120 --> 00:21:35,520
so if we take these three properties all

568
00:21:35,520 --> 00:21:38,799
together the implication is on one end

569
00:21:38,799 --> 00:21:41,200
the distinguishing advantage is epsilon

570
00:21:41,200 --> 00:21:43,200
at the very other end the distinguishing

571
00:21:43,200 --> 00:21:45,760
advantage is zero and that in between

572
00:21:45,760 --> 00:21:48,799
any interval that does not contain a key

573
00:21:48,799 --> 00:21:50,320
known to the adversary the

574
00:21:50,320 --> 00:21:52,320
distinguishing advantage cannot change

575
00:21:52,320 --> 00:21:55,280
except by a negligible amount and so

576
00:21:55,280 --> 00:21:57,600
there must be a jump somewhere and that

577
00:21:57,600 --> 00:21:59,760
jump can only appear in intervals that

578
00:21:59,760 --> 00:22:01,840
contain the identity

579
00:22:01,840 --> 00:22:05,120
so now we can actually trace

580
00:22:05,120 --> 00:22:07,039
that particular identity or a set of

581
00:22:07,039 --> 00:22:08,480
identities in the case where there are

582
00:22:08,480 --> 00:22:10,400
multiple using an algorithm for

583
00:22:10,400 --> 00:22:12,400
something called the oracle jump finding

584
00:22:12,400 --> 00:22:14,240
problem introduced

585
00:22:14,240 --> 00:22:15,039
by

586
00:22:15,039 --> 00:22:17,520
nishimaki wix and jandri

587
00:22:17,520 --> 00:22:19,120
and this is basically

588
00:22:19,120 --> 00:22:21,120
using the same kind of algorithms that

589
00:22:21,120 --> 00:22:22,880
can be used in trader tracing

590
00:22:22,880 --> 00:22:24,559
constructions

591
00:22:24,559 --> 00:22:26,159
so once we have a private linear

592
00:22:26,159 --> 00:22:28,240
constraint pseudo-random function is

593
00:22:28,240 --> 00:22:30,159
actually quite straightforward to

594
00:22:30,159 --> 00:22:33,440
construct a traceable prf using

595
00:22:33,440 --> 00:22:35,919
previous techniques developed in

596
00:22:35,919 --> 00:22:38,159
the setting of trader tracing

597
00:22:38,159 --> 00:22:40,240
so all that suffices now to construct a

598
00:22:40,240 --> 00:22:42,960
traceable prf is to construct a private

599
00:22:42,960 --> 00:22:44,799
linear constraint prf

600
00:22:44,799 --> 00:22:46,480
the starting point for our construction

601
00:22:46,480 --> 00:22:49,200
here will be a standard constraint prf

602
00:22:49,200 --> 00:22:51,600
for general circuit constraints so

603
00:22:51,600 --> 00:22:53,600
suppose the domain of our prf consists

604
00:22:53,600 --> 00:22:55,200
of l-bit strings

605
00:22:55,200 --> 00:22:57,360
we will consider a circuit constraint

606
00:22:57,360 --> 00:22:59,440
prf

607
00:22:59,440 --> 00:23:01,039
over this domain

608
00:23:01,039 --> 00:23:02,640
if we only want to support linear

609
00:23:02,640 --> 00:23:04,640
constraints this is quite simple we can

610
00:23:04,640 --> 00:23:07,200
just encode a linear constraint as a

611
00:23:07,200 --> 00:23:09,840
circuit functionality

612
00:23:09,840 --> 00:23:12,000
now the problem here though is that the

613
00:23:12,000 --> 00:23:13,679
indices for the domain elements are

614
00:23:13,679 --> 00:23:15,760
basically the domain values themselves

615
00:23:15,760 --> 00:23:18,000
and these are completely public versus

616
00:23:18,000 --> 00:23:19,440
in a private linear constraint

617
00:23:19,440 --> 00:23:21,760
pseudorandom function we require that

618
00:23:21,760 --> 00:23:23,840
the index associated with a particular

619
00:23:23,840 --> 00:23:26,159
domain element has to be hidden and this

620
00:23:26,159 --> 00:23:28,400
is necessary in order to have

621
00:23:28,400 --> 00:23:30,240
properties like normal hiding index

622
00:23:30,240 --> 00:23:32,159
hiding and so on

623
00:23:32,159 --> 00:23:35,120
so a natural solution to this is well if

624
00:23:35,120 --> 00:23:37,840
we want to hide something in crypto the

625
00:23:37,840 --> 00:23:40,000
usual approach is to apply some kind of

626
00:23:40,000 --> 00:23:42,880
encryption so instead of having the

627
00:23:42,880 --> 00:23:43,919
points

628
00:23:43,919 --> 00:23:47,039
themselves be the index we will instead

629
00:23:47,039 --> 00:23:49,520
take our domain to be the ciphertext

630
00:23:49,520 --> 00:23:51,360
space for some symmetric encryption

631
00:23:51,360 --> 00:23:53,760
scheme and the index associated with a

632
00:23:53,760 --> 00:23:56,799
point is basically

633
00:23:56,799 --> 00:23:59,919
the value that we get when we decrypt

634
00:23:59,919 --> 00:24:02,400
the particular point so now when we

635
00:24:02,400 --> 00:24:04,480
construct our circuit constraints or

636
00:24:04,480 --> 00:24:06,480
when we encode the linear constraints

637
00:24:06,480 --> 00:24:07,919
what we're going to do is we're going to

638
00:24:07,919 --> 00:24:12,000
include the decryption key for

639
00:24:12,000 --> 00:24:13,440
this

640
00:24:13,440 --> 00:24:15,360
for the encryption scheme as part of the

641
00:24:15,360 --> 00:24:19,360
constraining circuit and on input a

642
00:24:19,360 --> 00:24:21,600
domain element which is basically a

643
00:24:21,600 --> 00:24:23,679
ciphertext we will first decrypt the

644
00:24:23,679 --> 00:24:26,080
ciphertext to check what the index is

645
00:24:26,080 --> 00:24:28,080
and then we will compare that index to

646
00:24:28,080 --> 00:24:30,159
the index associated with the key and

647
00:24:30,159 --> 00:24:32,640
depending on that comparison relation

648
00:24:32,640 --> 00:24:36,240
either allow for evaluation or not

649
00:24:36,240 --> 00:24:38,480
so the only problem now is that this

650
00:24:38,480 --> 00:24:40,880
constraint key could leak information

651
00:24:40,880 --> 00:24:42,480
about

652
00:24:42,480 --> 00:24:44,159
the indices so if you have the

653
00:24:44,159 --> 00:24:45,679
constraint key

654
00:24:45,679 --> 00:24:47,600
you might be able to learn in some

655
00:24:47,600 --> 00:24:49,600
information about the decryption key and

656
00:24:49,600 --> 00:24:51,760
now if you know the decryption key

657
00:24:51,760 --> 00:24:53,760
you can decrypt the index associated

658
00:24:53,760 --> 00:24:55,840
with any domain element and learn that

659
00:24:55,840 --> 00:24:58,240
index then once again so somehow we need

660
00:24:58,240 --> 00:25:00,240
to make sure that the decryption key is

661
00:25:00,240 --> 00:25:02,720
actually hidden in the constrained keys

662
00:25:02,720 --> 00:25:04,880
under of our private linear constraint

663
00:25:04,880 --> 00:25:06,400
prf system

664
00:25:06,400 --> 00:25:09,120
it turns out that this we can also do

665
00:25:09,120 --> 00:25:11,279
by instead of using a constrained

666
00:25:11,279 --> 00:25:13,279
pseudorandom function we use something

667
00:25:13,279 --> 00:25:14,559
called a private constraints

668
00:25:14,559 --> 00:25:16,159
pseudorandom function

669
00:25:16,159 --> 00:25:18,400
which basically says the constrained key

670
00:25:18,400 --> 00:25:20,880
hides the underlying constraint

671
00:25:20,880 --> 00:25:22,799
so with this we can actually build a

672
00:25:22,799 --> 00:25:25,440
private linear constrained prf

673
00:25:25,440 --> 00:25:26,480
and

674
00:25:26,480 --> 00:25:30,799
which in turn implies a traceable prf

675
00:25:30,799 --> 00:25:32,720
uh so just to summarize to construct

676
00:25:32,720 --> 00:25:34,559
this private linear constraint prfs we

677
00:25:34,559 --> 00:25:37,039
can cons we can combine a private

678
00:25:37,039 --> 00:25:38,880
constraint prf with any symmetric

679
00:25:38,880 --> 00:25:40,880
encryption this gives us a private

680
00:25:40,880 --> 00:25:42,880
linear constraint prf

681
00:25:42,880 --> 00:25:43,679
here

682
00:25:43,679 --> 00:25:45,440
in order to sample

683
00:25:45,440 --> 00:25:47,760
points that have a particular index it

684
00:25:47,760 --> 00:25:50,240
is necessary to know the secret

685
00:25:50,240 --> 00:25:52,320
encryption key so this is why this

686
00:25:52,320 --> 00:25:55,039
scheme only provides a secret

687
00:25:55,039 --> 00:25:57,039
tracing capabilities

688
00:25:57,039 --> 00:25:59,440
and then this will give us a traceable

689
00:25:59,440 --> 00:26:00,480
prf

690
00:26:00,480 --> 00:26:02,960
so starting from the lwe assumption we

691
00:26:02,960 --> 00:26:05,200
can obtain private constrained prfs that

692
00:26:05,200 --> 00:26:07,200
is secure against a single key so an

693
00:26:07,200 --> 00:26:09,279
adversary that has a single key will not

694
00:26:09,279 --> 00:26:10,720
be able to break any of the

695
00:26:10,720 --> 00:26:12,880
corresponding properties and in turn

696
00:26:12,880 --> 00:26:14,880
this gives us a single key

697
00:26:14,880 --> 00:26:16,880
private linear constraint prf which

698
00:26:16,880 --> 00:26:19,760
implies a single key traceable prfs

699
00:26:19,760 --> 00:26:22,720
as i just summarized in this work

700
00:26:22,720 --> 00:26:25,279
our focus was on revisiting some of the

701
00:26:25,279 --> 00:26:27,360
definitional foundations of software

702
00:26:27,360 --> 00:26:29,440
watermarking especially in the case of

703
00:26:29,440 --> 00:26:32,320
pseudo-random functions and i hopefully

704
00:26:32,320 --> 00:26:34,559
i have convinced you that in many

705
00:26:34,559 --> 00:26:36,159
settings where we are using a

706
00:26:36,159 --> 00:26:38,080
pseudo-random function to build a more

707
00:26:38,080 --> 00:26:40,320
general primitive

708
00:26:40,320 --> 00:26:42,480
the existing definition security

709
00:26:42,480 --> 00:26:44,480
definitions for software watermarking

710
00:26:44,480 --> 00:26:47,200
are insufficient and to address that

711
00:26:47,200 --> 00:26:50,159
deficiency in the existing definitions

712
00:26:50,159 --> 00:26:52,159
we introduce this notion of a traceable

713
00:26:52,159 --> 00:26:54,559
pseudorandom function which requires

714
00:26:54,559 --> 00:26:57,120
that the watermark or this traceability

715
00:26:57,120 --> 00:27:00,159
guarantee the hold against any program

716
00:27:00,159 --> 00:27:02,240
that is able to distinguish or break

717
00:27:02,240 --> 00:27:03,840
pseudorandomness of the underlying

718
00:27:03,840 --> 00:27:05,919
primitive and not only just against

719
00:27:05,919 --> 00:27:07,919
programs that preserve the exact input

720
00:27:07,919 --> 00:27:10,080
output behavior which

721
00:27:10,080 --> 00:27:12,799
can be problematic depending on the

722
00:27:12,799 --> 00:27:14,960
exact application

723
00:27:14,960 --> 00:27:16,799
and i think this illustrates a more

724
00:27:16,799 --> 00:27:19,360
general point that when we study notions

725
00:27:19,360 --> 00:27:21,360
of software water marking

726
00:27:21,360 --> 00:27:23,600
we should not always immediately tie

727
00:27:23,600 --> 00:27:26,399
functionality preserving to a notion of

728
00:27:26,399 --> 00:27:29,039
input output preservation in particular

729
00:27:29,039 --> 00:27:31,679
there are many natural settings where

730
00:27:31,679 --> 00:27:33,919
we want to distinguish between what the

731
00:27:33,919 --> 00:27:36,720
honest parties should be able to do so

732
00:27:36,720 --> 00:27:38,960
the functionality preserving for honest

733
00:27:38,960 --> 00:27:41,679
parties property versus what it means

734
00:27:41,679 --> 00:27:43,840
for the adversary to break security of

735
00:27:43,840 --> 00:27:45,039
the scheme

736
00:27:45,039 --> 00:27:47,520
just we should be able to capture

737
00:27:47,520 --> 00:27:49,520
adversarial strategies that do not

738
00:27:49,520 --> 00:27:51,919
necessarily replicate the exact input

739
00:27:51,919 --> 00:27:53,679
output behavior but could still break

740
00:27:53,679 --> 00:27:56,480
the scheme in other contexts

741
00:27:56,480 --> 00:27:59,200
and so with that i will wrap up and

742
00:27:59,200 --> 00:28:01,520
for full details on the constructions

743
00:28:01,520 --> 00:28:04,080
and the proofs i'll refer to our paper

744
00:28:04,080 --> 00:28:06,960
on eprint thanks

