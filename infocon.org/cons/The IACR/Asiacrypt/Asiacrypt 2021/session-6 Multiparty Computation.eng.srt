1
00:00:00,080 --> 00:00:02,240
a good number

2
00:00:02,240 --> 00:00:04,080
of 35s

3
00:00:04,080 --> 00:00:07,759
so welcome everybody to the mpc session

4
00:00:07,759 --> 00:00:10,080
of asia crypt 2021

5
00:00:10,080 --> 00:00:13,040
once again online but close your hearts

6
00:00:13,040 --> 00:00:15,280
and i'm your co-chair

7
00:00:15,280 --> 00:00:17,600
bernardo david and my other coach here

8
00:00:17,600 --> 00:00:19,520
is sophia kubov

9
00:00:19,520 --> 00:00:22,960
maybe you can introduce yourself sofia

10
00:00:22,960 --> 00:00:24,320
i think you did a great job introducing

11
00:00:24,320 --> 00:00:26,800
me i'm sophia

12
00:00:26,800 --> 00:00:29,519
good so let's get started with the first

13
00:00:29,519 --> 00:00:31,519
talk which will be

14
00:00:31,519 --> 00:00:33,600
on homomorphic secret sharing for

15
00:00:33,600 --> 00:00:35,680
multipartite and general adversary

16
00:00:35,680 --> 00:00:37,600
structures supporting parallel

17
00:00:37,600 --> 00:00:40,480
evaluation of low degree polynomials

18
00:00:40,480 --> 00:00:43,120
and rio riguchi will be giving the talk

19
00:00:43,120 --> 00:00:45,200
for us uh please

20
00:00:45,200 --> 00:00:47,520
share your screen and go ahead

21
00:00:47,520 --> 00:00:51,039
okay or can you hear this slide

22
00:00:51,039 --> 00:00:52,719
yes we can see your screen and hear you

23
00:00:52,719 --> 00:00:54,960
just fine okay uh thank you for

24
00:00:54,960 --> 00:00:58,160
introduction uh my name is raygucci

25
00:00:58,160 --> 00:01:00,320
today i talk about the paper titled

26
00:01:00,320 --> 00:01:02,079
homomorphic secret sharing for

27
00:01:02,079 --> 00:01:03,680
multipathetic and general advantage

28
00:01:03,680 --> 00:01:05,519
structures supporting a parallel

29
00:01:05,519 --> 00:01:08,000
evaluation of low degree polynomials

30
00:01:08,000 --> 00:01:12,400
this is a joint work with koji nuita

31
00:01:12,400 --> 00:01:14,960
secret sharing um uh is an important

32
00:01:14,960 --> 00:01:16,400
building block for a multi-party

33
00:01:16,400 --> 00:01:19,119
computation um as in standard secret

34
00:01:19,119 --> 00:01:21,759
sharing it has a sharing algorithm which

35
00:01:21,759 --> 00:01:24,799
takes a secret access input and outputs

36
00:01:24,799 --> 00:01:27,600
and shares then the privacy requirement

37
00:01:27,600 --> 00:01:30,159
is specified by the adversary structure

38
00:01:30,159 --> 00:01:32,799
delta which is the collection of subsets

39
00:01:32,799 --> 00:01:35,759
a such that the shares in a reveals no

40
00:01:35,759 --> 00:01:38,000
information on the secret x

41
00:01:38,000 --> 00:01:39,439
homomorphic secret sharing has

42
00:01:39,439 --> 00:01:42,079
additional algorithms called evaluation

43
00:01:42,079 --> 00:01:45,040
and decryption algorithms i suppose that

44
00:01:45,040 --> 00:01:48,399
any input players generate m shares from

45
00:01:48,399 --> 00:01:51,280
their private inputs and send them to m

46
00:01:51,280 --> 00:01:52,479
servers

47
00:01:52,479 --> 00:01:54,640
then each server locally runs the

48
00:01:54,640 --> 00:01:57,840
evaluation algorithm on function f and n

49
00:01:57,840 --> 00:01:59,680
shares it receives

50
00:01:59,680 --> 00:02:02,079
finally an output player collects all

51
00:02:02,079 --> 00:02:03,840
the outputs of the validation algorithms

52
00:02:03,840 --> 00:02:06,320
from servers and run the decryption

53
00:02:06,320 --> 00:02:07,520
algorithm

54
00:02:07,520 --> 00:02:09,440
whose output is supposed to be a value

55
00:02:09,440 --> 00:02:12,000
of the function f

56
00:02:12,000 --> 00:02:14,239
in this work uh we consider three kinds

57
00:02:14,239 --> 00:02:16,800
of adversary structures the

58
00:02:16,800 --> 00:02:18,720
the first the simplest case is the

59
00:02:18,720 --> 00:02:22,080
threshold advances fracture which um

60
00:02:22,080 --> 00:02:24,319
which tolerates any collision of that

61
00:02:24,319 --> 00:02:25,840
most t servers

62
00:02:25,840 --> 00:02:27,840
on the other hand the most general case

63
00:02:27,840 --> 00:02:30,080
is a general adversary structure which

64
00:02:30,080 --> 00:02:32,080
has no limitation on the adversary

65
00:02:32,080 --> 00:02:33,680
structure delta

66
00:02:33,680 --> 00:02:35,519
finally a multi-party adversary

67
00:02:35,519 --> 00:02:38,000
structure lies between threshold and

68
00:02:38,000 --> 00:02:40,400
general adversity structures

69
00:02:40,400 --> 00:02:42,560
specifically

70
00:02:42,560 --> 00:02:45,200
suppose that the subset of m servers is

71
00:02:45,200 --> 00:02:48,400
partitioned into l parts p1 to pl

72
00:02:48,400 --> 00:02:50,800
roughly speaking in a multiparted bus

73
00:02:50,800 --> 00:02:53,360
structure uh whether a subsidy x is in

74
00:02:53,360 --> 00:02:55,920
delta or not is uniquely determined by

75
00:02:55,920 --> 00:02:58,400
this vector which comes which counts the

76
00:02:58,400 --> 00:03:00,800
number of servers in each part

77
00:03:00,800 --> 00:03:03,040
then multiplied advanced structures

78
00:03:03,040 --> 00:03:05,519
include various kinds of non-threshold

79
00:03:05,519 --> 00:03:07,760
adverse structures such as weighted

80
00:03:07,760 --> 00:03:09,599
threshold a hierarchical and

81
00:03:09,599 --> 00:03:11,840
compartmented advanced structures and so

82
00:03:11,840 --> 00:03:14,000
on

83
00:03:14,000 --> 00:03:15,519
there are several homophobic secret

84
00:03:15,519 --> 00:03:17,280
sharing schemes for computing

85
00:03:17,280 --> 00:03:19,360
polynomials um

86
00:03:19,360 --> 00:03:21,680
of degree d at most p

87
00:03:21,680 --> 00:03:23,599
first information theoretically secure

88
00:03:23,599 --> 00:03:25,440
schemes have been proposed for a

89
00:03:25,440 --> 00:03:27,360
threshold of multiparted and general

90
00:03:27,360 --> 00:03:29,200
advanced structures

91
00:03:29,200 --> 00:03:31,680
however their adverse restrictions must

92
00:03:31,680 --> 00:03:35,040
satisfy a condition called a type 2d

93
00:03:35,040 --> 00:03:38,000
which puts a strong limit on adversaries

94
00:03:38,000 --> 00:03:40,080
corruption power

95
00:03:40,080 --> 00:03:41,920
on the other hand there is the most

96
00:03:41,920 --> 00:03:44,159
powerful homomorphic secret sharing

97
00:03:44,159 --> 00:03:46,959
scheme tolerating the maximum corruption

98
00:03:46,959 --> 00:03:50,159
threshold however it must assume a

99
00:03:50,159 --> 00:03:51,760
narrow class of cryptographic

100
00:03:51,760 --> 00:03:53,040
assumptions

101
00:03:53,040 --> 00:03:55,360
related to lattices

102
00:03:55,360 --> 00:03:56,560
recently

103
00:03:56,560 --> 00:03:59,040
two schemes have been proposed which lie

104
00:03:59,040 --> 00:04:02,640
between these uh two extreme cases

105
00:04:02,640 --> 00:04:05,439
uh first they can be obtained from uh

106
00:04:05,439 --> 00:04:07,840
moderate assumption of homophobic

107
00:04:07,840 --> 00:04:10,720
encryption for a degree k polynomials

108
00:04:10,720 --> 00:04:13,680
second and they can tolerate um

109
00:04:13,680 --> 00:04:16,238
wider class of adversary structures than

110
00:04:16,238 --> 00:04:20,160
type qd um the the condition um they can

111
00:04:20,160 --> 00:04:23,520
they must satisfy is uh called type qdk

112
00:04:23,520 --> 00:04:25,680
for example in the threshold case a type

113
00:04:25,680 --> 00:04:29,440
qdk means the threshold is k plus 1

114
00:04:29,440 --> 00:04:31,919
times larger than the upper bound of

115
00:04:31,919 --> 00:04:34,240
type 2d

116
00:04:34,240 --> 00:04:36,400
our work also follows that direction of

117
00:04:36,400 --> 00:04:37,440
research

118
00:04:37,440 --> 00:04:40,400
first based on homomorphic encryption we

119
00:04:40,400 --> 00:04:42,720
propose a novel moving secret sharing

120
00:04:42,720 --> 00:04:45,120
scheme for multipath adversary

121
00:04:45,120 --> 00:04:47,680
structures of type qdk

122
00:04:47,680 --> 00:04:50,960
the share size of our scheme is only

123
00:04:50,960 --> 00:04:54,000
polynomial in the number of servers so

124
00:04:54,000 --> 00:04:56,000
our scheme is more efficient than the

125
00:04:56,000 --> 00:04:58,320
previously known general construction

126
00:04:58,320 --> 00:05:02,160
whose share size is exponentially now

127
00:05:02,160 --> 00:05:04,720
so furthermore our scheme can tolerate a

128
00:05:04,720 --> 00:05:06,639
multiplied advanced structure so it is

129
00:05:06,639 --> 00:05:08,840
more general than the threshold

130
00:05:08,840 --> 00:05:12,000
scheme in addition we also show that the

131
00:05:12,000 --> 00:05:13,680
these homophobic secret sharing schemes

132
00:05:13,680 --> 00:05:15,919
can be extended to homomorphic secret

133
00:05:15,919 --> 00:05:18,320
sharing for symlody operation which

134
00:05:18,320 --> 00:05:20,639
means that they can compute a single

135
00:05:20,639 --> 00:05:23,600
polynomial on l different inputs

136
00:05:23,600 --> 00:05:25,039
simultaneously

137
00:05:25,039 --> 00:05:27,600
and the overhead in our share size is

138
00:05:27,600 --> 00:05:30,800
only logarithmic in l so it is um

139
00:05:30,800 --> 00:05:33,039
more efficient than the naive solution

140
00:05:33,039 --> 00:05:35,600
of simply running l computations

141
00:05:35,600 --> 00:05:38,960
independently which results in overhead

142
00:05:38,960 --> 00:05:40,960
proportional to l

143
00:05:40,960 --> 00:05:43,280
as a drawback however our the adversary

144
00:05:43,280 --> 00:05:45,280
structure of our scheme must satisfy a

145
00:05:45,280 --> 00:05:48,000
stronger condition which we call type qd

146
00:05:48,000 --> 00:05:49,280
kl

147
00:05:49,280 --> 00:05:51,199
but it is still wider than the

148
00:05:51,199 --> 00:05:55,280
information theoretic bound of type qd

149
00:05:55,280 --> 00:05:57,360
technically we use the notion of packed

150
00:05:57,360 --> 00:05:59,919
secret sharing scheme for example um the

151
00:05:59,919 --> 00:06:02,000
previous scheme can tolerate the general

152
00:06:02,000 --> 00:06:04,400
advanced structure but does not support

153
00:06:04,400 --> 00:06:06,479
power evaluation on the other hand the

154
00:06:06,479 --> 00:06:07,680
pack the

155
00:06:07,680 --> 00:06:09,759
share size of practice secret sharing

156
00:06:09,759 --> 00:06:12,960
scheme is only logarithmic in

157
00:06:12,960 --> 00:06:15,759
the number of evaluations however it you

158
00:06:15,759 --> 00:06:17,600
can only tolerate a threshold advanced

159
00:06:17,600 --> 00:06:19,520
structure in this work we propose a

160
00:06:19,520 --> 00:06:22,080
novel way to combine these two schemes

161
00:06:22,080 --> 00:06:24,479
and as a result we obtain a homomorphic

162
00:06:24,479 --> 00:06:26,880
secret sharing which not only tolerates

163
00:06:26,880 --> 00:06:29,280
general adverse structures but also

164
00:06:29,280 --> 00:06:31,440
achieve share size logarithmic in the

165
00:06:31,440 --> 00:06:33,680
number evaluations

166
00:06:33,680 --> 00:06:35,680
at this is the end of my talk uh please

167
00:06:35,680 --> 00:06:38,240
see here for the details that's all

168
00:06:38,240 --> 00:06:40,639
thank you

169
00:06:41,280 --> 00:06:43,120
thanks rio for a doc

170
00:06:43,120 --> 00:06:45,360
do we have any questions please remember

171
00:06:45,360 --> 00:06:47,280
you can ask questions on zulip on the

172
00:06:47,280 --> 00:06:49,919
link that gavin posted on the chat here

173
00:06:49,919 --> 00:06:52,880
or feel free to unmute and ask your

174
00:06:52,880 --> 00:06:56,719
questions on zoom right now

175
00:06:56,960 --> 00:06:58,400
so there doesn't seem to be anything on

176
00:06:58,400 --> 00:07:01,400
zulip

177
00:07:02,639 --> 00:07:03,520
yeah

178
00:07:03,520 --> 00:07:06,960
uh so let's thank uh rio again uh for a

179
00:07:06,960 --> 00:07:08,080
start and

180
00:07:08,080 --> 00:07:09,360
i'd like to

181
00:07:09,360 --> 00:07:10,080
to

182
00:07:10,080 --> 00:07:12,639
ask one uh one question here you

183
00:07:12,639 --> 00:07:14,240
mentioned that there were previous

184
00:07:14,240 --> 00:07:16,560
constructions based on strong and

185
00:07:16,560 --> 00:07:17,840
stronger

186
00:07:17,840 --> 00:07:19,759
um

187
00:07:19,759 --> 00:07:21,280
assumptions

188
00:07:21,280 --> 00:07:23,199
and then

189
00:07:23,199 --> 00:07:26,479
and then now you have a weaker

190
00:07:26,479 --> 00:07:30,960
type qdkl class but you can get security

191
00:07:30,960 --> 00:07:32,479
assuming k

192
00:07:32,479 --> 00:07:33,360
uh

193
00:07:33,360 --> 00:07:35,759
homomorphic encryption what class of

194
00:07:35,759 --> 00:07:37,680
assumptions can you build that uh

195
00:07:37,680 --> 00:07:39,599
primitive from

196
00:07:39,599 --> 00:07:41,039
oh uh

197
00:07:41,039 --> 00:07:42,240
um

198
00:07:42,240 --> 00:07:45,759
our scheme can be obtained from um any

199
00:07:45,759 --> 00:07:47,919
homophobic encryption scheme so uh

200
00:07:47,919 --> 00:07:49,440
homophobic secret sharing a harmonic

201
00:07:49,440 --> 00:07:51,840
encryption can be obtained from um

202
00:07:51,840 --> 00:07:53,919
several cryptographic assumptions such

203
00:07:53,919 --> 00:07:55,039
as um

204
00:07:55,039 --> 00:07:58,639
um defeat helmand and in addition to all

205
00:07:58,639 --> 00:08:00,639
lattice lattices

206
00:08:00,639 --> 00:08:02,319
um

207
00:08:02,319 --> 00:08:03,440
yeah okay

208
00:08:03,440 --> 00:08:05,759
so it generalizes to both lattice-based

209
00:08:05,759 --> 00:08:07,599
and number theoretical uh assumption

210
00:08:07,599 --> 00:08:10,160
classes that's uh that's interesting

211
00:08:10,160 --> 00:08:12,400
um do you have anyone has any other

212
00:08:12,400 --> 00:08:14,878
questions

213
00:08:16,000 --> 00:08:18,319
so if you have any further questions you

214
00:08:18,319 --> 00:08:21,280
can always use zulip and i would ask all

215
00:08:21,280 --> 00:08:23,759
of the presenters to keep an eye there

216
00:08:23,759 --> 00:08:25,360
and answer anything that might come up

217
00:08:25,360 --> 00:08:27,840
later let's uh proceed to the next

218
00:08:27,840 --> 00:08:30,479
presentation thanks again rayo uh i

219
00:08:30,479 --> 00:08:32,958
would like to proceed now to the

220
00:08:32,958 --> 00:08:36,080
presentation on improved single round

221
00:08:36,080 --> 00:08:39,679
secure multiplication using regenerating

222
00:08:39,679 --> 00:08:43,200
a paper by mark ospal ronald kramer ivan

223
00:08:43,200 --> 00:08:45,680
dungo daniele escudero

224
00:08:45,680 --> 00:08:48,399
and ciao ping shin and daniel will be

225
00:08:48,399 --> 00:08:50,080
presenting for us

226
00:08:50,080 --> 00:08:52,560
please share your screen and you're

227
00:08:52,560 --> 00:08:55,040
welcome to start anytime you want

228
00:08:55,040 --> 00:08:56,640
yeah hello thank you so much for the

229
00:08:56,640 --> 00:08:58,240
introduction so you all hear me fine

230
00:08:58,240 --> 00:08:59,600
correct

231
00:08:59,600 --> 00:09:01,279
yes we can hear you

232
00:09:01,279 --> 00:09:03,360
okay perfect thank you

233
00:09:03,360 --> 00:09:04,800
so thank you for the introduction

234
00:09:04,800 --> 00:09:07,040
bernardo uh as you mentioned my name is

235
00:09:07,040 --> 00:09:09,040
is is danielle and i'm going to talk

236
00:09:09,040 --> 00:09:10,000
about

237
00:09:10,000 --> 00:09:12,080
this paper with markup spell runner

238
00:09:12,080 --> 00:09:15,680
crammer even dan guard and chopin ching

239
00:09:15,680 --> 00:09:16,800
so

240
00:09:16,800 --> 00:09:19,200
first let me

241
00:09:19,200 --> 00:09:21,040
mention what our setting is we have a

242
00:09:21,040 --> 00:09:23,200
multi-party computation with n parties

243
00:09:23,200 --> 00:09:24,080
we have

244
00:09:24,080 --> 00:09:26,480
we label them by p1 or 2pm

245
00:09:26,480 --> 00:09:27,920
and we assume that we have two

246
00:09:27,920 --> 00:09:29,760
corruptions where

247
00:09:29,760 --> 00:09:33,120
n is going to be to t plus one so is the

248
00:09:33,120 --> 00:09:34,959
honest majority setting with the maximum

249
00:09:34,959 --> 00:09:37,120
corruption threshold

250
00:09:37,120 --> 00:09:40,720
and we are going to use a brackets with

251
00:09:40,720 --> 00:09:43,120
a subscript d to denote basically linear

252
00:09:43,120 --> 00:09:44,800
sequential scheme

253
00:09:44,800 --> 00:09:46,880
with threshold d

254
00:09:46,880 --> 00:09:48,720
and

255
00:09:48,720 --> 00:09:51,120
the problem that we're considering this

256
00:09:51,120 --> 00:09:52,160
work

257
00:09:52,160 --> 00:09:54,399
is basically secure multiplication so

258
00:09:54,399 --> 00:09:56,720
given two secret share the inputs x and

259
00:09:56,720 --> 00:09:58,080
y

260
00:09:58,080 --> 00:10:01,040
how to obtain shares of the product x

261
00:10:01,040 --> 00:10:02,399
and y

262
00:10:02,399 --> 00:10:05,920
and this is an example of a very typical

263
00:10:05,920 --> 00:10:08,959
multiplication protocol if you have a

264
00:10:08,959 --> 00:10:13,040
shared triple a b and the product of a b

265
00:10:13,040 --> 00:10:15,600
where a and b are random

266
00:10:15,600 --> 00:10:17,440
then the practice could execute the

267
00:10:17,440 --> 00:10:19,920
following so basically

268
00:10:19,920 --> 00:10:21,920
take the shares of x subtract a and then

269
00:10:21,920 --> 00:10:23,200
they obtain

270
00:10:23,200 --> 00:10:25,279
some value d similarly they obtain some

271
00:10:25,279 --> 00:10:27,600
value e by max masking y and then

272
00:10:27,600 --> 00:10:31,279
they're going to reconstruct

273
00:10:31,440 --> 00:10:33,200
these values d and these values e and

274
00:10:33,200 --> 00:10:34,800
then they take certain a fine

275
00:10:34,800 --> 00:10:37,120
combination that can be checked the

276
00:10:37,120 --> 00:10:39,120
results in the shares of the product but

277
00:10:39,120 --> 00:10:40,160
the point is that they need to

278
00:10:40,160 --> 00:10:42,079
reconstruct in this process

279
00:10:42,079 --> 00:10:43,360
so

280
00:10:43,360 --> 00:10:44,800
for the reconstruction they have two

281
00:10:44,800 --> 00:10:45,920
options

282
00:10:45,920 --> 00:10:47,600
so one can be that

283
00:10:47,600 --> 00:10:49,839
all parties send shares to each other

284
00:10:49,839 --> 00:10:51,200
but in this case the communication

285
00:10:51,200 --> 00:10:52,800
complexity will be quadratic in the

286
00:10:52,800 --> 00:10:54,399
number of parts because everyone talks

287
00:10:54,399 --> 00:10:56,000
to everyone

288
00:10:56,000 --> 00:10:57,120
but the good thing is that it will have

289
00:10:57,120 --> 00:10:58,480
only one round

290
00:10:58,480 --> 00:11:00,959
and on the other hand if

291
00:11:00,959 --> 00:11:03,440
all parties instead send shares to one

292
00:11:03,440 --> 00:11:06,000
single party that's a p1 this party

293
00:11:06,000 --> 00:11:08,320
reconstructs a secret and then sends the

294
00:11:08,320 --> 00:11:10,320
result back then the communication

295
00:11:10,320 --> 00:11:12,160
complexity will be linear now but it

296
00:11:12,160 --> 00:11:14,560
will have two rounds

297
00:11:14,560 --> 00:11:16,560
so the question that we explored is

298
00:11:16,560 --> 00:11:18,320
whether or not we can achieve secure

299
00:11:18,320 --> 00:11:21,040
multiplication using only one round

300
00:11:21,040 --> 00:11:23,120
with a communication complexity that is

301
00:11:23,120 --> 00:11:25,760
strictly better than n squared

302
00:11:25,760 --> 00:11:28,240
and unfortunately we cannot give a full

303
00:11:28,240 --> 00:11:30,959
answer we cannot either provide a an

304
00:11:30,959 --> 00:11:32,959
impossibility result because like the

305
00:11:32,959 --> 00:11:34,880
problem actually seems quite challenging

306
00:11:34,880 --> 00:11:36,399
if you need openings during the

307
00:11:36,399 --> 00:11:38,160
multiplication protocol then it's true

308
00:11:38,160 --> 00:11:40,480
that you will go to n square but maybe

309
00:11:40,480 --> 00:11:42,480
there are other approaches

310
00:11:42,480 --> 00:11:44,240
that will get you seven square

311
00:11:44,240 --> 00:11:45,040
but

312
00:11:45,040 --> 00:11:47,440
we have a partial result towards this

313
00:11:47,440 --> 00:11:48,480
which is

314
00:11:48,480 --> 00:11:50,320
that there exists a protocol to securely

315
00:11:50,320 --> 00:11:52,480
evaluate not one secure multiplication

316
00:11:52,480 --> 00:11:54,800
band but many secure multiplications or

317
00:11:54,800 --> 00:11:56,720
at least a batch of them that depends on

318
00:11:56,720 --> 00:11:58,240
the number of party

319
00:11:58,240 --> 00:12:00,880
where the communication complexity of

320
00:12:00,880 --> 00:12:03,279
each one of those multiplications like

321
00:12:03,279 --> 00:12:04,959
when you one more ties or divided by the

322
00:12:04,959 --> 00:12:06,800
number of multiplications

323
00:12:06,800 --> 00:12:09,440
it is sub n square

324
00:12:09,440 --> 00:12:10,399
in

325
00:12:10,399 --> 00:12:12,079
the detroit communication becomes a

326
00:12:12,079 --> 00:12:14,800
seventh square

327
00:12:15,600 --> 00:12:16,800
so

328
00:12:16,800 --> 00:12:18,320
as a

329
00:12:18,320 --> 00:12:20,639
bonus of our purple also works for galwa

330
00:12:20,639 --> 00:12:23,519
rings which are generalization of finite

331
00:12:23,519 --> 00:12:26,079
fields and also integers modulo powers

332
00:12:26,079 --> 00:12:27,680
of a prime

333
00:12:27,680 --> 00:12:30,320
and another interesting thing is that we

334
00:12:30,320 --> 00:12:31,680
are

335
00:12:31,680 --> 00:12:33,600
confusing at the first work making use

336
00:12:33,600 --> 00:12:35,600
of regenerating codes in the context of

337
00:12:35,600 --> 00:12:38,720
npc explicitly so these tools are very

338
00:12:38,720 --> 00:12:40,000
useful or

339
00:12:40,000 --> 00:12:42,639
seem very useful for helping

340
00:12:42,639 --> 00:12:44,320
optimizing reconstruction but it was

341
00:12:44,320 --> 00:12:45,920
quite hard to find out like a concrete

342
00:12:45,920 --> 00:12:48,880
application for them

343
00:12:49,680 --> 00:12:51,839
so just to give you an idea about how

344
00:12:51,839 --> 00:12:54,880
this result is obtained

345
00:12:54,880 --> 00:12:56,079
consider

346
00:12:56,079 --> 00:12:57,920
the existence of regenerating codes

347
00:12:57,920 --> 00:13:00,000
studied in this work by griswami and

348
00:13:00,000 --> 00:13:02,480
voters in stock 2016.

349
00:13:02,480 --> 00:13:05,440
so if we have this result say that we

350
00:13:05,440 --> 00:13:07,920
have a shared value x

351
00:13:07,920 --> 00:13:10,720
basically you can find linear functions

352
00:13:10,720 --> 00:13:13,360
that take big vectors or big values and

353
00:13:13,360 --> 00:13:15,279
turn it into small values

354
00:13:15,279 --> 00:13:18,079
and certain scalars such that this

355
00:13:18,079 --> 00:13:20,959
linear combination here when you take

356
00:13:20,959 --> 00:13:22,880
all these compressed shares and multiply

357
00:13:22,880 --> 00:13:24,720
them by their scalars then you're going

358
00:13:24,720 --> 00:13:26,079
to reconstruct the sequence so basically

359
00:13:26,079 --> 00:13:27,760
you can reconstruct the secret by

360
00:13:27,760 --> 00:13:30,639
sending smaller shares

361
00:13:30,639 --> 00:13:32,399
so if you want to reconstruct the share

362
00:13:32,399 --> 00:13:34,399
value x in one round

363
00:13:34,399 --> 00:13:36,240
you can instead of using the full shares

364
00:13:36,240 --> 00:13:37,920
you can use the small shares

365
00:13:37,920 --> 00:13:40,240
and compute the upper linear combination

366
00:13:40,240 --> 00:13:42,320
and now the communication complexity

367
00:13:42,320 --> 00:13:44,000
will be n squared but

368
00:13:44,000 --> 00:13:45,760
if you count the number of elements in

369
00:13:45,760 --> 00:13:48,480
terms of the elements in f2 then

370
00:13:48,480 --> 00:13:50,240
basically this brings you down to

371
00:13:50,240 --> 00:13:52,399
sub-linear and square but this is just

372
00:13:52,399 --> 00:13:54,320
the start of the story

373
00:13:54,320 --> 00:13:56,240
several problems will appear so i'm just

374
00:13:56,240 --> 00:13:58,399
gonna close over them very quickly but

375
00:13:58,399 --> 00:13:59,600
at least give you the idea of some of

376
00:13:59,600 --> 00:14:01,040
the challenges

377
00:14:01,040 --> 00:14:02,959
so the first challenge is that

378
00:14:02,959 --> 00:14:04,079
you definitely don't want to have

379
00:14:04,079 --> 00:14:05,680
multiplication or lifted to the end

380
00:14:05,680 --> 00:14:07,120
because uh

381
00:14:07,120 --> 00:14:08,800
in the previous slide i had that m is

382
00:14:08,800 --> 00:14:11,600
about log n so this structure is going

383
00:14:11,600 --> 00:14:12,959
to grow with the number of parties and

384
00:14:12,959 --> 00:14:14,720
you would like to have something that

385
00:14:14,720 --> 00:14:17,120
that is constant for the computation and

386
00:14:17,120 --> 00:14:18,800
for this we can use reverse

387
00:14:18,800 --> 00:14:20,720
multiplication friendly bearings in 30

388
00:14:20,720 --> 00:14:23,040
user crypto 18.

389
00:14:23,040 --> 00:14:24,000
but

390
00:14:24,000 --> 00:14:25,920
doing this naively will not work because

391
00:14:25,920 --> 00:14:27,519
the techniques from this work that i

392
00:14:27,519 --> 00:14:30,800
just cited ccxy18 will not work in our

393
00:14:30,800 --> 00:14:32,160
setting because it will add an extra

394
00:14:32,160 --> 00:14:32,959
round

395
00:14:32,959 --> 00:14:35,519
so in our paper we introduce a novel

396
00:14:35,519 --> 00:14:38,000
encoding mechanism that also might be an

397
00:14:38,000 --> 00:14:39,839
independent interest

398
00:14:39,839 --> 00:14:42,399
that will improve this paper in several

399
00:14:42,399 --> 00:14:44,560
aspects including reducing this extra

400
00:14:44,560 --> 00:14:46,160
round

401
00:14:46,160 --> 00:14:47,680
also we have problems with active

402
00:14:47,680 --> 00:14:49,600
adversaries and we also show how to

403
00:14:49,600 --> 00:14:52,480
address this using the pre-processing

404
00:14:52,480 --> 00:14:54,480
from turbospeeds but instead of using

405
00:14:54,480 --> 00:14:56,079
for communication improvements we use it

406
00:14:56,079 --> 00:14:58,560
for security purposes i'm not giving

407
00:14:58,560 --> 00:15:00,320
details of course i encourage you to go

408
00:15:00,320 --> 00:15:02,000
and check the paper and the full video

409
00:15:02,000 --> 00:15:04,399
to to see how this is done

410
00:15:04,399 --> 00:15:06,800
and finally uh

411
00:15:06,800 --> 00:15:08,560
rmf is over galwa rings because

412
00:15:08,560 --> 00:15:09,920
everything i have said so far is for

413
00:15:09,920 --> 00:15:12,800
fine and fuel so rmf's over colorings we

414
00:15:12,800 --> 00:15:14,959
do have them they do exist

415
00:15:14,959 --> 00:15:16,720
but we generalize the theory of

416
00:15:16,720 --> 00:15:19,600
regenerating codes to this setting

417
00:15:19,600 --> 00:15:21,680
and we actually give a new

418
00:15:21,680 --> 00:15:23,120
characterization of the concept of

419
00:15:23,120 --> 00:15:25,839
repairability in terms of the dual code

420
00:15:25,839 --> 00:15:27,920
the previous characterizations did not

421
00:15:27,920 --> 00:15:29,360
um

422
00:15:29,360 --> 00:15:31,680
did not have these press this

423
00:15:31,680 --> 00:15:33,199
did not look like this

424
00:15:33,199 --> 00:15:35,199
and then we give concrete instantiations

425
00:15:35,199 --> 00:15:36,639
over colorings which is the case of

426
00:15:36,639 --> 00:15:39,120
interest for us

427
00:15:39,120 --> 00:15:40,959
and that would be my five minute stop

428
00:15:40,959 --> 00:15:43,279
thank you

429
00:15:43,279 --> 00:15:45,759
thanks for the talk danielle uh do we

430
00:15:45,759 --> 00:15:47,759
have any questions i don't see anything

431
00:15:47,759 --> 00:15:50,240
on zulip yet uh if anyone would like to

432
00:15:50,240 --> 00:15:55,480
ask a question by audio please go ahead

433
00:15:58,480 --> 00:16:00,079
i see a

434
00:16:00,079 --> 00:16:03,120
raised hand here from sofia or

435
00:16:03,120 --> 00:16:04,959
instead of clapping

436
00:16:04,959 --> 00:16:07,839
it's a clapping hand oh nice thank you

437
00:16:07,839 --> 00:16:09,040
thank you so

438
00:16:09,040 --> 00:16:11,120
i actually have a question i i i see

439
00:16:11,120 --> 00:16:13,120
that clearly it's a more theoretically

440
00:16:13,120 --> 00:16:15,040
oriented result and quite an interesting

441
00:16:15,040 --> 00:16:18,000
one but uh is there any hope that the

442
00:16:18,000 --> 00:16:20,160
constants hidden in all of the

443
00:16:20,160 --> 00:16:22,560
asymptotic notation are actually nice

444
00:16:22,560 --> 00:16:24,240
enough that we could apply these

445
00:16:24,240 --> 00:16:27,600
techniques to concrete settings or uh is

446
00:16:27,600 --> 00:16:30,560
it still in a in a purely theoretical

447
00:16:30,560 --> 00:16:31,920
setting

448
00:16:31,920 --> 00:16:33,920
so this question in terms of in terms of

449
00:16:33,920 --> 00:16:35,519
constants the constants are actually

450
00:16:35,519 --> 00:16:37,759
quite nice like when you see this thing

451
00:16:37,759 --> 00:16:39,920
here the constants that will appear here

452
00:16:39,920 --> 00:16:42,320
basically come from

453
00:16:42,320 --> 00:16:44,399
the rmf the reverse multiplication from

454
00:16:44,399 --> 00:16:46,959
anybody we use and the overhead of this

455
00:16:46,959 --> 00:16:48,560
thing will be something like between

456
00:16:48,560 --> 00:16:51,360
four and five so

457
00:16:51,360 --> 00:16:53,600
i mean it's it's not really that bad

458
00:16:53,600 --> 00:16:56,320
what i think is not that

459
00:16:56,320 --> 00:16:59,199
practical is that i mean this is sub n

460
00:16:59,199 --> 00:17:01,600
square but but in reality is this number

461
00:17:01,600 --> 00:17:03,920
here which is n squared divided by log n

462
00:17:03,920 --> 00:17:05,280
so i think

463
00:17:05,280 --> 00:17:07,679
we break the barrier of the n squared

464
00:17:07,679 --> 00:17:10,079
but if you have two protocols one takes

465
00:17:10,079 --> 00:17:12,079
two rounds and it's linear communication

466
00:17:12,079 --> 00:17:14,160
complexity one the other one takes one

467
00:17:14,160 --> 00:17:16,240
round and it's almost quadratic it's

468
00:17:16,240 --> 00:17:18,160
soft quadratic but almost quadratic so

469
00:17:18,160 --> 00:17:19,599
it's probably more efficient to use the

470
00:17:19,599 --> 00:17:21,599
linear one but we hope that we can keep

471
00:17:21,599 --> 00:17:23,359
studying this problem and bring down the

472
00:17:23,359 --> 00:17:25,839
complexity of one round multiplication

473
00:17:25,839 --> 00:17:28,240
hopefully to linear although i have no

474
00:17:28,240 --> 00:17:29,600
idea how to achieve this so i think this

475
00:17:29,600 --> 00:17:30,799
is a very interesting result because it

476
00:17:30,799 --> 00:17:32,160
breaks the career but i don't know how

477
00:17:32,160 --> 00:17:34,799
to get it more efficient

478
00:17:34,799 --> 00:17:36,480
well thanks for the answer and let's

479
00:17:36,480 --> 00:17:39,039
thanks danielle again for his

480
00:17:39,039 --> 00:17:40,400
presentation

481
00:17:40,400 --> 00:17:42,480
we'll now proceed to the next

482
00:17:42,480 --> 00:17:45,520
presentation on garbling stacked and

483
00:17:45,520 --> 00:17:48,160
staggered faster k out of van garbled

484
00:17:48,160 --> 00:17:50,799
function evaluation a paper by david

485
00:17:50,799 --> 00:17:53,760
heath vlad kolezenkov and stanislav

486
00:17:53,760 --> 00:17:56,480
piccini i guess it is stanislav who is

487
00:17:56,480 --> 00:17:58,320
presenting for us

488
00:17:58,320 --> 00:18:01,039
please go ahead and share a screen and

489
00:18:01,039 --> 00:18:04,799
feel free to start your presentation

490
00:18:04,799 --> 00:18:06,960
thanks for the introduction uh can you

491
00:18:06,960 --> 00:18:08,240
hear me and

492
00:18:08,240 --> 00:18:09,919
see my screen

493
00:18:09,919 --> 00:18:11,840
yes we can hear you just fine and see

494
00:18:11,840 --> 00:18:13,360
your screen

495
00:18:13,360 --> 00:18:16,080
perfect so thank you again uh i will

496
00:18:16,080 --> 00:18:18,880
talk about our paper garbling stock and

497
00:18:18,880 --> 00:18:21,520
staggered faster chaotic and carbon

498
00:18:21,520 --> 00:18:23,280
function evaluation

499
00:18:23,280 --> 00:18:25,520
and this is going to work with david

500
00:18:25,520 --> 00:18:28,640
heath and bart kolesnikov and we work at

501
00:18:28,640 --> 00:18:31,440
georgia tech

502
00:18:31,440 --> 00:18:34,160
so now consider a server and this server

503
00:18:34,160 --> 00:18:36,799
offers a suite of services to clients

504
00:18:36,799 --> 00:18:37,919
and

505
00:18:37,919 --> 00:18:40,000
suppose that these services have privacy

506
00:18:40,000 --> 00:18:43,120
concerns for both the server and the

507
00:18:43,120 --> 00:18:45,280
client

508
00:18:45,280 --> 00:18:48,080
and as an example suppose that a

509
00:18:48,080 --> 00:18:50,960
telehealth company offers services that

510
00:18:50,960 --> 00:18:53,120
screen concern patients for a variety of

511
00:18:53,120 --> 00:18:55,600
medical conditions represented as

512
00:18:55,600 --> 00:18:59,600
function zero through n minus one

513
00:18:59,600 --> 00:19:00,320
and

514
00:19:00,320 --> 00:19:03,120
the patient may apriori know that a

515
00:19:03,120 --> 00:19:05,120
number of medical conditions are

516
00:19:05,120 --> 00:19:07,120
unlikely to be the source of her

517
00:19:07,120 --> 00:19:10,320
symptoms so the patient may only wish to

518
00:19:10,320 --> 00:19:11,840
be screened for

519
00:19:11,840 --> 00:19:14,160
k health conditions out of the possible

520
00:19:14,160 --> 00:19:16,400
end

521
00:19:16,640 --> 00:19:19,120
so the patient really wants to evaluate

522
00:19:19,120 --> 00:19:22,000
k out of n public functions to which the

523
00:19:22,000 --> 00:19:26,160
patient has some private inputs

524
00:19:26,160 --> 00:19:28,559
so i emphasize that the patient knows

525
00:19:28,559 --> 00:19:30,960
which k functions she wants to evaluate

526
00:19:30,960 --> 00:19:34,160
and in this talk i present our chaotic

527
00:19:34,160 --> 00:19:37,679
construction and this construction use a

528
00:19:37,679 --> 00:19:39,200
concrete improvement over the

529
00:19:39,200 --> 00:19:42,720
state-of-the-art constructions

530
00:19:42,720 --> 00:19:45,039
so the construction is garbage circuit

531
00:19:45,039 --> 00:19:46,480
based

532
00:19:46,480 --> 00:19:47,600
and

533
00:19:47,600 --> 00:19:49,679
i repeat that in our construction

534
00:19:49,679 --> 00:19:54,720
alice's k-choices are known to her

535
00:19:56,080 --> 00:19:58,799
i will start by presenting why a naive

536
00:19:58,799 --> 00:20:01,280
garbage circuit solution to the chaotic

537
00:20:01,280 --> 00:20:03,600
problem is not satisfactory

538
00:20:03,600 --> 00:20:06,080
and an important point is that the

539
00:20:06,080 --> 00:20:08,240
garbler should not know

540
00:20:08,240 --> 00:20:10,960
nor learn which case circuits alice will

541
00:20:10,960 --> 00:20:14,400
evaluate so he garbles all n circuits

542
00:20:14,400 --> 00:20:16,799
compiles them into a single string and

543
00:20:16,799 --> 00:20:18,799
sends the string across the wire to

544
00:20:18,799 --> 00:20:20,480
alice and

545
00:20:20,480 --> 00:20:22,320
i emphasize the descending of the

546
00:20:22,320 --> 00:20:24,480
circuit guard buildings which i will

547
00:20:24,480 --> 00:20:29,360
refer to as the material is expensive

548
00:20:29,600 --> 00:20:30,880
in fact

549
00:20:30,880 --> 00:20:33,520
this process of sending the material is

550
00:20:33,520 --> 00:20:35,600
traditionally considered the most

551
00:20:35,600 --> 00:20:37,440
expensive part of the garbage circuit

552
00:20:37,440 --> 00:20:40,080
protocol

553
00:20:40,240 --> 00:20:43,120
but in crypto 2020 david heath and vodka

554
00:20:43,120 --> 00:20:45,120
listening off introduce dark garbling

555
00:20:45,120 --> 00:20:48,080
which reduces precisely this bandwidth

556
00:20:48,080 --> 00:20:50,960
consumption for one out of n circuits

557
00:20:50,960 --> 00:20:53,280
and this work showed that it is not

558
00:20:53,280 --> 00:20:55,360
necessary to send a garble link for each

559
00:20:55,360 --> 00:20:57,039
of the n circuits

560
00:20:57,039 --> 00:20:59,280
in fact it's a physicist to send a

561
00:20:59,280 --> 00:21:01,600
single material of length equal to the

562
00:21:01,600 --> 00:21:04,559
single longest garbling among the n

563
00:21:04,559 --> 00:21:06,320
circuits

564
00:21:06,320 --> 00:21:09,520
and while it is communication that has

565
00:21:09,520 --> 00:21:11,760
been traditionally viewed as the garbage

566
00:21:11,760 --> 00:21:14,480
circuit bottleneck start garbling really

567
00:21:14,480 --> 00:21:17,280
changed the status quo and

568
00:21:17,280 --> 00:21:19,360
garbling itself consumes significant

569
00:21:19,360 --> 00:21:22,240
computational resources

570
00:21:22,240 --> 00:21:23,840
and in many settings it is now

571
00:21:23,840 --> 00:21:28,080
computation that becomes the bottleneck

572
00:21:28,080 --> 00:21:30,159
so the start garbling technique can be

573
00:21:30,159 --> 00:21:33,679
generalized generalized to arbitrary k

574
00:21:33,679 --> 00:21:36,400
and while the communication improvement

575
00:21:36,400 --> 00:21:39,280
is preserved that is the communication

576
00:21:39,280 --> 00:21:43,840
cost is proportional to k rather than n

577
00:21:43,840 --> 00:21:46,799
naively extending this technique to k

578
00:21:46,799 --> 00:21:49,600
out of n circuit incurs factor k

579
00:21:49,600 --> 00:21:52,960
increase in computation

580
00:21:52,960 --> 00:21:58,080
so meaning the computation grows with k

581
00:21:58,080 --> 00:22:00,000
so there seems to be an inherent

582
00:22:00,000 --> 00:22:01,840
trade-off between computation and

583
00:22:01,840 --> 00:22:03,679
communication with the current

584
00:22:03,679 --> 00:22:06,320
techniques so stat karbelling reduces

585
00:22:06,320 --> 00:22:08,799
communication consumption but it also

586
00:22:08,799 --> 00:22:11,840
increases computation consumption and

587
00:22:11,840 --> 00:22:14,159
this trade-off forces us to choose

588
00:22:14,159 --> 00:22:15,919
between either communication and

589
00:22:15,919 --> 00:22:19,360
computation which is not desirable so in

590
00:22:19,360 --> 00:22:21,360
our work we ask whether we can have the

591
00:22:21,360 --> 00:22:23,600
best of both worlds

592
00:22:23,600 --> 00:22:25,679
that is can we pay communication only

593
00:22:25,679 --> 00:22:29,360
for k materials and still incur

594
00:22:29,360 --> 00:22:32,559
computation on the order of n and we

595
00:22:32,559 --> 00:22:34,720
answer in the affirmative

596
00:22:34,720 --> 00:22:38,480
and central to our idea is the fact that

597
00:22:38,480 --> 00:22:40,880
material is viewed differently in each

598
00:22:40,880 --> 00:22:42,080
technique

599
00:22:42,080 --> 00:22:46,000
so in the garbage circuit traditionally

600
00:22:46,000 --> 00:22:48,159
material was viewed as a collection of

601
00:22:48,159 --> 00:22:50,559
encrypted truth tables

602
00:22:50,559 --> 00:22:52,640
the key idea of star garbling was that

603
00:22:52,640 --> 00:22:55,520
the material should instead be viewed as

604
00:22:55,520 --> 00:22:59,120
a bit string and this idea enabled to

605
00:22:59,120 --> 00:23:01,200
manage these materials with natural

606
00:23:01,200 --> 00:23:04,240
operations such as bitwise xor and we

607
00:23:04,240 --> 00:23:06,640
take this idea further and instead view

608
00:23:06,640 --> 00:23:08,720
the material as an element in a large

609
00:23:08,720 --> 00:23:11,120
color field and as a result we can

610
00:23:11,120 --> 00:23:14,080
perform linear algebraic operations on

611
00:23:14,080 --> 00:23:16,400
the material

612
00:23:16,400 --> 00:23:17,840
so i will now

613
00:23:17,840 --> 00:23:19,280
very briefly present the three

614
00:23:19,280 --> 00:23:21,120
constructions at a high level and on a

615
00:23:21,120 --> 00:23:23,360
small example where n equals 3 and k

616
00:23:23,360 --> 00:23:25,440
equals 2. so again in the hour

617
00:23:25,440 --> 00:23:27,120
scarborough circuit the guardball

618
00:23:27,120 --> 00:23:29,520
garbage all three circuits concatenates

619
00:23:29,520 --> 00:23:31,360
them into one string and sends the

620
00:23:31,360 --> 00:23:34,720
string across the wire to alice

621
00:23:34,720 --> 00:23:37,600
in start garbling instead of sending m0

622
00:23:37,600 --> 00:23:40,400
m1 and m2 separately the gabriel adds

623
00:23:40,400 --> 00:23:43,039
these three values together using xor

624
00:23:43,039 --> 00:23:45,360
and here is where we have one in terms

625
00:23:45,360 --> 00:23:47,600
of communication because we do not send

626
00:23:47,600 --> 00:23:50,640
m0 and one and m2 separately but instead

627
00:23:50,640 --> 00:23:53,200
send their sum and then importantly

628
00:23:53,200 --> 00:23:54,960
alice needs to be able to unstack the

629
00:23:54,960 --> 00:23:57,760
taken materials star garbling describes

630
00:23:57,760 --> 00:23:59,600
how this can be securely and efficiently

631
00:23:59,600 --> 00:24:00,960
achieved

632
00:24:00,960 --> 00:24:03,520
uh i will not get into it at this moment

633
00:24:03,520 --> 00:24:06,880
but since k equals two we need two

634
00:24:06,880 --> 00:24:09,679
stacks so note that the material in

635
00:24:09,679 --> 00:24:12,159
stock one

636
00:24:12,159 --> 00:24:13,120
uh

637
00:24:13,120 --> 00:24:14,799
those materials are different from those

638
00:24:14,799 --> 00:24:16,880
in stack zero although they represent

639
00:24:16,880 --> 00:24:19,279
the same functions and this is exactly

640
00:24:19,279 --> 00:24:21,360
where the computation costs proportional

641
00:24:21,360 --> 00:24:24,080
to k times and garblings comes in as new

642
00:24:24,080 --> 00:24:25,919
materials are needed for each of the

643
00:24:25,919 --> 00:24:28,320
case steps instead

644
00:24:28,320 --> 00:24:30,000
we would like to reuse the same end

645
00:24:30,000 --> 00:24:32,559
materials across the stacks which is

646
00:24:32,559 --> 00:24:34,559
precisely what we achieve in our stack

647
00:24:34,559 --> 00:24:37,200
and staggered construction

648
00:24:37,200 --> 00:24:39,120
and in this slide i showed the two

649
00:24:39,120 --> 00:24:40,720
stacks in our stack and staggered

650
00:24:40,720 --> 00:24:43,600
construction note that m0 and one and m2

651
00:24:43,600 --> 00:24:45,679
are same across the stacks that is there

652
00:24:45,679 --> 00:24:48,960
is a total of n materials and while

653
00:24:48,960 --> 00:24:51,120
stack zero is the same as in the start

654
00:24:51,120 --> 00:24:53,760
garbling approach the materials in stack

655
00:24:53,760 --> 00:24:56,400
one are multiplied by hours powers of

656
00:24:56,400 --> 00:24:58,960
two before they're added together and

657
00:24:58,960 --> 00:25:01,039
now it should be believable that this

658
00:25:01,039 --> 00:25:03,679
multiplication provides some additional

659
00:25:03,679 --> 00:25:05,760
information that will enable alice to

660
00:25:05,760 --> 00:25:09,360
bit by bit and stack the taken materials

661
00:25:09,360 --> 00:25:11,600
and since we view the materials as

662
00:25:11,600 --> 00:25:13,840
elements in a galois field we can

663
00:25:13,840 --> 00:25:15,919
multiply them by these different powers

664
00:25:15,919 --> 00:25:18,240
of two which simply adds zeros and

665
00:25:18,240 --> 00:25:21,760
shifts each material within the stack

666
00:25:21,760 --> 00:25:23,360
this means we can pick our linear

667
00:25:23,360 --> 00:25:25,440
algebraic operation such that everything

668
00:25:25,440 --> 00:25:28,159
can be implemented with simple bitwise

669
00:25:28,159 --> 00:25:29,200
xor

670
00:25:29,200 --> 00:25:31,600
and hence we obtain high performance we

671
00:25:31,600 --> 00:25:32,480
shift

672
00:25:32,480 --> 00:25:35,600
we simply shift each material and xor it

673
00:25:35,600 --> 00:25:37,440
into a stack

674
00:25:37,440 --> 00:25:39,360
and these simple stacking operations are

675
00:25:39,360 --> 00:25:40,880
far cheaper than the garbeling

676
00:25:40,880 --> 00:25:43,600
operations as a result we obtain

677
00:25:43,600 --> 00:25:45,679
performance that matches computation of

678
00:25:45,679 --> 00:25:47,840
the standard javascript circuit approach

679
00:25:47,840 --> 00:25:51,440
and communication of start garbling

680
00:25:51,440 --> 00:25:53,440
and in summary so the key contribution

681
00:25:53,440 --> 00:25:55,039
is that we improve garbage circuit

682
00:25:55,039 --> 00:25:57,360
evaluation of k out of n functions where

683
00:25:57,360 --> 00:25:59,360
the k choices are known to the garbage

684
00:25:59,360 --> 00:26:01,520
circuit evaluator

685
00:26:01,520 --> 00:26:03,360
we retained the start goblin

686
00:26:03,360 --> 00:26:05,840
communication complexity

687
00:26:05,840 --> 00:26:07,679
while simultaneously retained the

688
00:26:07,679 --> 00:26:11,200
computation complexity of standard

689
00:26:11,200 --> 00:26:14,080
garbage circuit approach

690
00:26:14,080 --> 00:26:16,480
and thank you for listening and i'm

691
00:26:16,480 --> 00:26:20,320
happy to answer any questions

692
00:26:21,919 --> 00:26:24,720
thanks for our presentation stan uh if

693
00:26:24,720 --> 00:26:28,000
anyone has any questions uh i would ask

694
00:26:28,000 --> 00:26:30,159
you to actually put it on zulip because

695
00:26:30,159 --> 00:26:33,679
we are almost out of time for this lot

696
00:26:33,679 --> 00:26:34,640
so

697
00:26:34,640 --> 00:26:37,360
uh i will actually ask that we proceed

698
00:26:37,360 --> 00:26:38,480
to the next

699
00:26:38,480 --> 00:26:40,960
presentation and then

700
00:26:40,960 --> 00:26:43,360
please leave your questions on zulip and

701
00:26:43,360 --> 00:26:46,159
i'll ask stan to also watch tulip and

702
00:26:46,159 --> 00:26:48,640
answer anything that might come up

703
00:26:48,640 --> 00:26:51,440
our next presentation

704
00:26:51,440 --> 00:26:53,120
is on

705
00:26:53,120 --> 00:26:55,640
better security efficiency trade-offs in

706
00:26:55,640 --> 00:26:58,240
permutation-based two-party computation

707
00:26:58,240 --> 00:27:02,320
a paper by yulon chen and stefano tesaro

708
00:27:02,320 --> 00:27:04,480
and the presentation will be given by

709
00:27:04,480 --> 00:27:05,279
you

710
00:27:05,279 --> 00:27:07,039
so please

711
00:27:07,039 --> 00:27:09,600
share your screen and start the

712
00:27:09,600 --> 00:27:13,039
presentation when you're ready you

713
00:27:17,600 --> 00:27:20,960
hello so can you see the slide

714
00:27:20,960 --> 00:27:25,279
uh no we can see your face but

715
00:27:26,159 --> 00:27:27,120
sorry

716
00:27:27,120 --> 00:27:29,360
let me try it again

717
00:27:29,360 --> 00:27:31,678
um

718
00:27:31,840 --> 00:27:34,840
okay

719
00:27:37,360 --> 00:27:39,760
now i hope that's uh you can see the

720
00:27:39,760 --> 00:27:42,720
slice yes we can see your slices okay

721
00:27:42,720 --> 00:27:45,120
thank you so this joint works with

722
00:27:45,120 --> 00:27:47,760
stefano de sado

723
00:27:47,760 --> 00:27:50,320
so as you already heard from the last

724
00:27:50,320 --> 00:27:51,200
three

725
00:27:51,200 --> 00:27:52,640
presentations that muti party

726
00:27:52,640 --> 00:27:54,799
computation is one of the hottest topic

727
00:27:54,799 --> 00:27:58,240
at this moment but do you also know that

728
00:27:58,240 --> 00:28:01,440
um protocols such as ot extension

729
00:28:01,440 --> 00:28:04,399
schemes and double circuit actually make

730
00:28:04,399 --> 00:28:06,159
have heavy use of symmetry key

731
00:28:06,159 --> 00:28:07,360
primitives

732
00:28:07,360 --> 00:28:10,159
so that means this talk is actually more

733
00:28:10,159 --> 00:28:12,559
about the primitives that are actually

734
00:28:12,559 --> 00:28:14,559
used in the protocol instead of the

735
00:28:14,559 --> 00:28:16,399
protocols itself

736
00:28:16,399 --> 00:28:18,880
um so actually one of the common

737
00:28:18,880 --> 00:28:21,840
denominator in those protocols is

738
00:28:21,840 --> 00:28:23,600
actually a special form of hash

739
00:28:23,600 --> 00:28:25,760
functions and this type of hash

740
00:28:25,760 --> 00:28:28,880
functions is an often remodeled as a

741
00:28:28,880 --> 00:28:33,039
random oracle but um

742
00:28:33,279 --> 00:28:36,880
also um yeah i used to hash 128 bit

743
00:28:36,880 --> 00:28:39,120
streams

744
00:28:39,120 --> 00:28:40,559
that means that

745
00:28:40,559 --> 00:28:43,279
the traditional three hash function is

746
00:28:43,279 --> 00:28:44,399
too large

747
00:28:44,399 --> 00:28:47,120
for this type of applications

748
00:28:47,120 --> 00:28:50,159
because sha 3 has a large state size it

749
00:28:50,159 --> 00:28:52,559
will lead to low performance

750
00:28:52,559 --> 00:28:55,120
and that's the reason why currently

751
00:28:55,120 --> 00:28:57,679
construction is based on fixed key

752
00:28:57,679 --> 00:29:00,480
are used to improve the performance

753
00:29:00,480 --> 00:29:03,520
however the big problem here is that

754
00:29:03,520 --> 00:29:06,159
many of the existing protocols actually

755
00:29:06,159 --> 00:29:07,039
use

756
00:29:07,039 --> 00:29:09,279
an inefficient and sometimes even

757
00:29:09,279 --> 00:29:11,919
insecure hash functions so the fact that

758
00:29:11,919 --> 00:29:14,640
those insecure hash functions are used

759
00:29:14,640 --> 00:29:16,320
means that um

760
00:29:16,320 --> 00:29:18,399
the protocols just

761
00:29:18,399 --> 00:29:20,640
yeah don't

762
00:29:20,640 --> 00:29:21,679
get the

763
00:29:21,679 --> 00:29:24,000
claim to security so that means

764
00:29:24,000 --> 00:29:26,240
protocols will be insecure with those

765
00:29:26,240 --> 00:29:28,000
insecure hash functions

766
00:29:28,000 --> 00:29:29,919
so and besides

767
00:29:29,919 --> 00:29:32,000
there are several notions needed for

768
00:29:32,000 --> 00:29:34,880
different types of protocols

769
00:29:34,880 --> 00:29:37,919
and that makes that we need different

770
00:29:37,919 --> 00:29:40,480
constructions in order to satisfy

771
00:29:40,480 --> 00:29:44,320
stronger version of notions

772
00:29:44,960 --> 00:29:48,240
maybe one explanation about why this

773
00:29:48,240 --> 00:29:50,559
problem is hard what we want here is

774
00:29:50,559 --> 00:29:52,399
something that's called coloration

775
00:29:52,399 --> 00:29:55,440
robustness but that means um yeah you

776
00:29:55,440 --> 00:29:57,200
can find it back in the full version of

777
00:29:57,200 --> 00:29:58,880
the presentation

778
00:29:58,880 --> 00:30:01,440
on youtube so keep in mind that we are

779
00:30:01,440 --> 00:30:03,279
dealing with something that's called a

780
00:30:03,279 --> 00:30:05,600
hash function so hash function means

781
00:30:05,600 --> 00:30:09,120
that no destinated secret key inputs

782
00:30:09,120 --> 00:30:10,000
that

783
00:30:10,000 --> 00:30:12,559
means that here the only randomness

784
00:30:12,559 --> 00:30:15,440
comes together with the message inputs

785
00:30:15,440 --> 00:30:17,520
and there's nothing we can change about

786
00:30:17,520 --> 00:30:20,880
it and we can not just obtain this type

787
00:30:20,880 --> 00:30:23,360
of hash function under traditional

788
00:30:23,360 --> 00:30:25,679
symmetry key primitives such as two

789
00:30:25,679 --> 00:30:27,440
global blocks

790
00:30:27,440 --> 00:30:30,720
this problem is however related to a

791
00:30:30,720 --> 00:30:32,320
classical

792
00:30:32,320 --> 00:30:34,720
symmetry key problem which is a related

793
00:30:34,720 --> 00:30:37,919
key security for xor

794
00:30:37,919 --> 00:30:40,559
so um the first

795
00:30:40,559 --> 00:30:42,799
security call and um quick ball

796
00:30:42,799 --> 00:30:45,279
correlation replacement hash function

797
00:30:45,279 --> 00:30:47,360
was actually this triple mmo

798
00:30:47,360 --> 00:30:50,960
construction proposed in smp in um by

799
00:30:50,960 --> 00:30:52,320
goal at all in

800
00:30:52,320 --> 00:30:54,080
last year so we can see that

801
00:30:54,080 --> 00:30:56,000
construction makes

802
00:30:56,000 --> 00:30:59,279
two permutation calls to uh object um

803
00:30:59,279 --> 00:31:01,760
for public permutation and then we can

804
00:31:01,760 --> 00:31:04,320
see that the security achieved by this

805
00:31:04,320 --> 00:31:06,000
um transaction is

806
00:31:06,000 --> 00:31:07,919
this type of typical birthday bonds of

807
00:31:07,919 --> 00:31:10,880
security which um p is the number of the

808
00:31:10,880 --> 00:31:13,360
evaluation to the underlying primitive

809
00:31:13,360 --> 00:31:14,399
um

810
00:31:14,399 --> 00:31:16,240
permutation and q is the number of

811
00:31:16,240 --> 00:31:18,880
evaluations to the entire construction

812
00:31:18,880 --> 00:31:21,039
and um the

813
00:31:21,039 --> 00:31:24,000
problem here is that this construction

814
00:31:24,000 --> 00:31:27,360
so this um yeah it was shown by this um

815
00:31:27,360 --> 00:31:29,360
one of the follow-up work by the same

816
00:31:29,360 --> 00:31:31,919
elders or more or less the same elders

817
00:31:31,919 --> 00:31:34,559
and it's crypto loss here

818
00:31:34,559 --> 00:31:36,480
and the security achieved by this

819
00:31:36,480 --> 00:31:38,880
construction is actually inefficient

820
00:31:38,880 --> 00:31:40,640
when the newly used security is

821
00:31:40,640 --> 00:31:43,760
considered reason their voice that's mp

822
00:31:43,760 --> 00:31:46,399
is usually a very large number and now

823
00:31:46,399 --> 00:31:48,559
the fact that we considered new the user

824
00:31:48,559 --> 00:31:50,240
case cubic

825
00:31:50,240 --> 00:31:52,320
also become large so while the second

826
00:31:52,320 --> 00:31:55,360
term is still not so important for the

827
00:31:55,360 --> 00:31:58,159
practical applications the the first

828
00:31:58,159 --> 00:32:01,279
term is very um yeah i would say

829
00:32:01,279 --> 00:32:04,000
it will be very painful for the um for

830
00:32:04,000 --> 00:32:05,760
the practical applications due to the

831
00:32:05,760 --> 00:32:08,799
mute using skill and setting

832
00:32:08,799 --> 00:32:11,519
so the authors also introduce the

833
00:32:11,519 --> 00:32:13,679
following construction which just make

834
00:32:13,679 --> 00:32:16,480
one call to an ideal cipher here this

835
00:32:16,480 --> 00:32:19,760
street t serves us um

836
00:32:19,760 --> 00:32:22,320
the inputs key for this i o cipher we

837
00:32:22,320 --> 00:32:24,640
can see this is a bond that i choose by

838
00:32:24,640 --> 00:32:27,120
this construction and here b is actually

839
00:32:27,120 --> 00:32:29,440
the number of um

840
00:32:29,440 --> 00:32:30,480
and the

841
00:32:30,480 --> 00:32:32,960
construction queries per um

842
00:32:32,960 --> 00:32:35,840
of percent reach it's this b you just

843
00:32:35,840 --> 00:32:37,760
need to remember that b is usually a

844
00:32:37,760 --> 00:32:40,840
very small number for d and scalable

845
00:32:40,840 --> 00:32:44,000
circuits and yeah because this

846
00:32:44,000 --> 00:32:46,480
change and this sphere depends the

847
00:32:46,480 --> 00:32:48,480
construction is very and provides

848
00:32:48,480 --> 00:32:51,279
sufficient security for the user setting

849
00:32:51,279 --> 00:32:52,399
but the

850
00:32:52,399 --> 00:32:54,320
limitation of the construction is that

851
00:32:54,320 --> 00:32:55,279
this

852
00:32:55,279 --> 00:32:58,240
transformation makes uh assumption that

853
00:32:58,240 --> 00:33:00,080
ideal cypher

854
00:33:00,080 --> 00:33:02,080
and exists in practice which is too

855
00:33:02,080 --> 00:33:04,399
strong assumption for practice

856
00:33:04,399 --> 00:33:06,880
and for example assumptions like random

857
00:33:06,880 --> 00:33:11,919
oracles but it was also broken by um

858
00:33:12,000 --> 00:33:13,919
for example in those um

859
00:33:13,919 --> 00:33:16,960
md5 constructions or something like that

860
00:33:16,960 --> 00:33:19,039
and so i do cyber construction is

861
00:33:19,039 --> 00:33:21,360
actually something that's more or less

862
00:33:21,360 --> 00:33:25,039
um from the same level so that's reason

863
00:33:25,039 --> 00:33:27,440
why we start again so the main

864
00:33:27,440 --> 00:33:29,440
contribution in this work is and the

865
00:33:29,440 --> 00:33:32,000
following construction it's actually

866
00:33:32,000 --> 00:33:33,440
makes um

867
00:33:33,440 --> 00:33:36,240
again two permutation posts to a pi one

868
00:33:36,240 --> 00:33:38,000
and so one permutation called two taiwan

869
00:33:38,000 --> 00:33:40,399
and one permutation called two i2 and

870
00:33:40,399 --> 00:33:41,760
this construction is called the feed

871
00:33:41,760 --> 00:33:44,159
forward permutation three permutation or

872
00:33:44,159 --> 00:33:46,720
the fpdp transaction you see that this

873
00:33:46,720 --> 00:33:48,399
construction looks very similar to

874
00:33:48,399 --> 00:33:50,240
that's previous and

875
00:33:50,240 --> 00:33:52,960
yeah tmmo construction but the only

876
00:33:52,960 --> 00:33:55,440
difference now is that instead of feeds

877
00:33:55,440 --> 00:33:58,000
forward from the output of this um first

878
00:33:58,000 --> 00:34:00,720
permutation we should feed forward here

879
00:34:00,720 --> 00:34:01,840
the inputs

880
00:34:01,840 --> 00:34:04,480
so this small modification makes a big

881
00:34:04,480 --> 00:34:06,799
improvement while the second term is

882
00:34:06,799 --> 00:34:08,879
still the same which is not important

883
00:34:08,879 --> 00:34:09,839
for the

884
00:34:09,839 --> 00:34:12,560
ot and scalable circuits applications

885
00:34:12,560 --> 00:34:15,599
the first term improves for um a factor

886
00:34:15,599 --> 00:34:17,918
of and square root of q

887
00:34:17,918 --> 00:34:20,800
and c again b is very small for and of

888
00:34:20,800 --> 00:34:22,960
the h covered circuits and is equal to

889
00:34:22,960 --> 00:34:24,560
the number of construction products i

890
00:34:24,560 --> 00:34:28,239
tweak and we do request those uh three

891
00:34:28,239 --> 00:34:30,560
t's are chosen by nice combinatorial

892
00:34:30,560 --> 00:34:33,520
subsets for example random subsets we

893
00:34:33,520 --> 00:34:37,918
can show that we can we also present a

894
00:34:37,918 --> 00:34:40,960
small od protocol in our paper that's we

895
00:34:40,960 --> 00:34:45,599
can do that a priori and fix the tweaks

896
00:34:45,599 --> 00:34:48,159
so we proved the security for distinct

897
00:34:48,159 --> 00:34:50,560
and uniform random messages

898
00:34:50,560 --> 00:34:53,280
and but the same results can also hold

899
00:34:53,280 --> 00:34:56,399
for arbitrary input message and if we

900
00:34:56,399 --> 00:34:58,720
replace m by um this

901
00:34:58,720 --> 00:34:59,520
m

902
00:34:59,520 --> 00:35:01,520
financial multiplication with the three

903
00:35:01,520 --> 00:35:03,680
t so just introducing one extra

904
00:35:03,680 --> 00:35:06,240
financial multiplication we can get a

905
00:35:06,240 --> 00:35:08,160
much better result

906
00:35:08,160 --> 00:35:11,760
and we prove um the results say um both

907
00:35:11,760 --> 00:35:14,240
for independent i one and pi two also

908
00:35:14,240 --> 00:35:16,800
indicates when pi taiwan is equal to i2

909
00:35:16,800 --> 00:35:19,359
both cases and the construction

910
00:35:19,359 --> 00:35:22,240
achieves this security bond

911
00:35:22,240 --> 00:35:25,119
and um just because this improvement of

912
00:35:25,119 --> 00:35:27,520
square root of q makes this

913
00:35:27,520 --> 00:35:30,079
reconstruction sufficient for the

914
00:35:30,079 --> 00:35:31,760
multi-user setting

915
00:35:31,760 --> 00:35:34,320
so this is uh um yeah at the end of my

916
00:35:34,320 --> 00:35:37,440
presentation and um more about more

917
00:35:37,440 --> 00:35:39,680
details about that you can find it's um

918
00:35:39,680 --> 00:35:42,480
in the on the full version of this paper

919
00:35:42,480 --> 00:35:46,079
or um just on the on on my full vote

920
00:35:46,079 --> 00:35:48,960
version of the talk only print so and

921
00:35:48,960 --> 00:35:52,000
thank you for your attention

922
00:35:52,880 --> 00:35:55,040
thanks for your presentation you

923
00:35:55,040 --> 00:35:59,400
do we have any quick questions

924
00:36:02,800 --> 00:36:04,160
looks like

925
00:36:04,160 --> 00:36:08,078
we also have silence on zulip

926
00:36:08,720 --> 00:36:10,000
so

927
00:36:10,000 --> 00:36:12,640
i have one quick question uh i saw that

928
00:36:12,640 --> 00:36:14,960
you have uh some uh analysis some

929
00:36:14,960 --> 00:36:17,760
self-contained analysis of ot extensions

930
00:36:17,760 --> 00:36:20,320
um could you get a similar

931
00:36:20,320 --> 00:36:22,880
efficiency concrete efficiency as the

932
00:36:22,880 --> 00:36:24,720
constructions that are based on just

933
00:36:24,720 --> 00:36:27,119
using aes with a fixed key or something

934
00:36:27,119 --> 00:36:28,480
like that

935
00:36:28,480 --> 00:36:30,160
and yeah that's a very interesting

936
00:36:30,160 --> 00:36:32,160
question because we i i discussed with

937
00:36:32,160 --> 00:36:35,280
my goal of about that so um so actually

938
00:36:35,280 --> 00:36:38,000
what can be done is instead of um

939
00:36:38,000 --> 00:36:40,480
implementing this phi 1 and 5 2 as a

940
00:36:40,480 --> 00:36:42,960
real um permutation we can also choose

941
00:36:42,960 --> 00:36:45,280
for example to implement this um

942
00:36:45,280 --> 00:36:47,680
taiwanese on the first five front of a

943
00:36:47,680 --> 00:36:50,000
um fixed key a s and this pipe was the

944
00:36:50,000 --> 00:36:52,800
second five front of aes but i also

945
00:36:52,800 --> 00:36:55,359
talked with a colleague who is doing

946
00:36:55,359 --> 00:36:57,920
symmetrical analysis um yeah he taught

947
00:36:57,920 --> 00:37:00,560
me probably uh we need more rounds for

948
00:37:00,560 --> 00:37:03,920
this for example and six or seven rounds

949
00:37:03,920 --> 00:37:06,880
for each but and in that case i think um

950
00:37:06,880 --> 00:37:09,839
there are really the real crypt analysis

951
00:37:09,839 --> 00:37:12,320
needed for this um construction to make

952
00:37:12,320 --> 00:37:14,880
sure we do not use too less front and

953
00:37:14,880 --> 00:37:17,280
make the um yeah the on the line

954
00:37:17,280 --> 00:37:19,760
primitive actually insecure so that's

955
00:37:19,760 --> 00:37:21,680
actually my opinion but that's probably

956
00:37:21,680 --> 00:37:25,200
something for the future work

957
00:37:25,440 --> 00:37:26,320
okay

958
00:37:26,320 --> 00:37:27,760
thanks for the answer and thanks again

959
00:37:27,760 --> 00:37:29,440
for a presentation

960
00:37:29,440 --> 00:37:31,680
so now let's move on to our next

961
00:37:31,680 --> 00:37:32,960
presentation

962
00:37:32,960 --> 00:37:34,880
that's going to be about two-round

963
00:37:34,880 --> 00:37:38,079
adaptively secure npc from isogeny's lpn

964
00:37:38,079 --> 00:37:39,680
or cdh

965
00:37:39,680 --> 00:37:43,359
which is a work by navida lamati heart

966
00:37:43,359 --> 00:37:46,480
montgomery si car patranadis and pratik

967
00:37:46,480 --> 00:37:47,599
sarkar

968
00:37:47,599 --> 00:37:50,480
the talk will be given by pratik who has

969
00:37:50,480 --> 00:37:52,320
already shared his screen so please go

970
00:37:52,320 --> 00:37:54,880
ahead whenever you're ready

971
00:37:54,880 --> 00:37:56,000
hello

972
00:37:56,000 --> 00:37:58,400
hi everyone so my name is pratik and

973
00:37:58,400 --> 00:38:00,240
today we are going to talk about

974
00:38:00,240 --> 00:38:02,880
a two round adaptively secure mpc from

975
00:38:02,880 --> 00:38:06,240
misogynist lpn or cdh so this is a joint

976
00:38:06,240 --> 00:38:10,160
work with naveed heart and shikhar

977
00:38:10,640 --> 00:38:12,240
so today we are going to talk about

978
00:38:12,240 --> 00:38:14,320
secure competition i will consider the

979
00:38:14,320 --> 00:38:16,560
two-party setting so there is a party

980
00:38:16,560 --> 00:38:18,640
bob and there's a party alice they have

981
00:38:18,640 --> 00:38:20,480
private inputs x and y

982
00:38:20,480 --> 00:38:22,240
so they want to compute a function f on

983
00:38:22,240 --> 00:38:24,160
their private input x and y so the

984
00:38:24,160 --> 00:38:27,119
parties compute the protocol which is pi

985
00:38:27,119 --> 00:38:29,040
and the output the protocol output which

986
00:38:29,040 --> 00:38:31,599
is product pi of x comma y

987
00:38:31,599 --> 00:38:33,599
so the protocol should satisfy two

988
00:38:33,599 --> 00:38:35,760
properties first is correctness function

989
00:38:35,760 --> 00:38:37,839
output should be same as protocol output

990
00:38:37,839 --> 00:38:40,320
and security uh the pi should not leak

991
00:38:40,320 --> 00:38:41,680
anything about

992
00:38:41,680 --> 00:38:44,640
the private witness

993
00:38:45,440 --> 00:38:47,760
okay so and uh

994
00:38:47,760 --> 00:38:50,800
yeah so the uh the first few protocols

995
00:38:50,800 --> 00:38:53,760
for two pc were presented by yao gold

996
00:38:53,760 --> 00:38:56,400
like mikali and viva mikali roger

997
00:38:56,400 --> 00:38:58,960
and this uh thing um

998
00:38:58,960 --> 00:39:00,800
2pc has applications in

999
00:39:00,800 --> 00:39:02,400
privacy-preserving machine learning and

1000
00:39:02,400 --> 00:39:04,079
blockchains

1001
00:39:04,079 --> 00:39:06,079
so today we are going to talk about ot

1002
00:39:06,079 --> 00:39:08,160
so it's a very simple primitive

1003
00:39:08,160 --> 00:39:10,079
there's a receiver and sender so the

1004
00:39:10,079 --> 00:39:13,440
receiver has inputs v and mb i mean b

1005
00:39:13,440 --> 00:39:15,760
and the sender has inputs m0 m1 and the

1006
00:39:15,760 --> 00:39:17,920
receiver obtains mb as output

1007
00:39:17,920 --> 00:39:20,000
so the receiver should not know what is

1008
00:39:20,000 --> 00:39:22,000
m1 minus b and the sender should not

1009
00:39:22,000 --> 00:39:23,200
know what is b

1010
00:39:23,200 --> 00:39:25,359
and so this primitive of ot is complete

1011
00:39:25,359 --> 00:39:27,359
for secure computation

1012
00:39:27,359 --> 00:39:29,359
and we also know that ground optimal ot

1013
00:39:29,359 --> 00:39:32,560
enables round optimal secure computation

1014
00:39:32,560 --> 00:39:34,000
it also has other

1015
00:39:34,000 --> 00:39:35,760
uh applications like private server

1016
00:39:35,760 --> 00:39:37,359
intersection and interactive zero

1017
00:39:37,359 --> 00:39:38,880
knowledge

1018
00:39:38,880 --> 00:39:41,760
uh but in this work we aim for

1019
00:39:41,760 --> 00:39:42,960
constructing

1020
00:39:42,960 --> 00:39:45,280
adaptively secure ots which are secured

1021
00:39:45,280 --> 00:39:48,160
against malicious corruption of parties

1022
00:39:48,160 --> 00:39:48,960
and

1023
00:39:48,960 --> 00:39:52,079
we aim to achieve uc security and this

1024
00:39:52,079 --> 00:39:53,920
is the strongest corruption model and

1025
00:39:53,920 --> 00:39:57,760
the strongest security model in mpc

1026
00:39:57,760 --> 00:40:00,079
so let us briefly focus on

1027
00:40:00,079 --> 00:40:01,680
the

1028
00:40:01,680 --> 00:40:04,160
literature of adaptable secured mpc so

1029
00:40:04,160 --> 00:40:05,760
we are going to talk about non-ear

1030
00:40:05,760 --> 00:40:06,960
models where

1031
00:40:06,960 --> 00:40:09,119
the party okay so in the adaptive

1032
00:40:09,119 --> 00:40:11,359
setting the parties can get corrupted

1033
00:40:11,359 --> 00:40:13,440
during after or beginning of the

1034
00:40:13,440 --> 00:40:15,680
protocol at any time during the protocol

1035
00:40:15,680 --> 00:40:18,160
execution so it's a very strong model

1036
00:40:18,160 --> 00:40:20,560
and here the simulator needs to uh

1037
00:40:20,560 --> 00:40:22,800
simulate the view of the party

1038
00:40:22,800 --> 00:40:25,680
even when the parties are corrupted uh

1039
00:40:25,680 --> 00:40:27,839
during the protocol so we consider the

1040
00:40:27,839 --> 00:40:30,079
non-eurasian model uh where the

1041
00:40:30,079 --> 00:40:32,400
simulator cannot erase the states of the

1042
00:40:32,400 --> 00:40:33,839
parties

1043
00:40:33,839 --> 00:40:35,440
so in this work it was shown by

1044
00:40:35,440 --> 00:40:39,040
gurgaon's eye that you cannot obtain um

1045
00:40:39,040 --> 00:40:41,200
a constant round mpc protocol in the

1046
00:40:41,200 --> 00:40:43,440
plane model with black box simulation so

1047
00:40:43,440 --> 00:40:46,160
that's why uh there are two works uh

1048
00:40:46,160 --> 00:40:48,319
which construct from non-black box

1049
00:40:48,319 --> 00:40:50,480
simulation techniques uh they construct

1050
00:40:50,480 --> 00:40:52,960
constant round mpc protocol so this the

1051
00:40:52,960 --> 00:40:54,800
second work is going to be the next

1052
00:40:54,800 --> 00:40:57,520
stock given by mac

1053
00:40:57,520 --> 00:40:59,839
and in the setup string model uh there

1054
00:40:59,839 --> 00:41:02,160
were a few few works uh which

1055
00:41:02,160 --> 00:41:04,079
constructed linear round protocols

1056
00:41:04,079 --> 00:41:07,920
starting from the work of clos uh

1057
00:41:07,920 --> 00:41:11,520
and then uh the work by hazai and um

1058
00:41:11,520 --> 00:41:13,680
they constructed the first constant

1059
00:41:13,680 --> 00:41:15,440
round protocol from public key

1060
00:41:15,440 --> 00:41:17,680
encryption with oblivious ciphertext

1061
00:41:17,680 --> 00:41:19,200
generation

1062
00:41:19,200 --> 00:41:21,520
um so that is the minimal assumption

1063
00:41:21,520 --> 00:41:23,200
required

1064
00:41:23,200 --> 00:41:26,560
and now uh let us focus on the two round

1065
00:41:26,560 --> 00:41:29,200
setting so we know that two round mpc is

1066
00:41:29,200 --> 00:41:32,160
round optimal in the crs model so in

1067
00:41:32,160 --> 00:41:35,520
this model uh there were a few works in

1068
00:41:35,520 --> 00:41:36,720
from io

1069
00:41:36,720 --> 00:41:38,480
uh starting from

1070
00:41:38,480 --> 00:41:43,920
uh the cgp and gp 15 papers and then uh

1071
00:41:43,920 --> 00:41:46,240
the work by behind muda at all

1072
00:41:46,240 --> 00:41:47,920
constructed the first two round

1073
00:41:47,920 --> 00:41:49,760
adaptively secured mpc

1074
00:41:49,760 --> 00:41:52,480
uh from standard assumptions like ddh

1075
00:41:52,480 --> 00:41:55,440
lwe and qr without io in the common

1076
00:41:55,440 --> 00:41:57,760
reference string model and in another

1077
00:41:57,760 --> 00:41:59,200
work

1078
00:41:59,200 --> 00:42:01,599
we constructed

1079
00:42:01,599 --> 00:42:04,400
adapted to secure mpc from ddh in crs

1080
00:42:04,400 --> 00:42:07,440
mode in common random string model

1081
00:42:07,440 --> 00:42:09,200
so let me uh go through our

1082
00:42:09,200 --> 00:42:11,280
contributions so in this work we show

1083
00:42:11,280 --> 00:42:13,599
that uh we can construct adaptively

1084
00:42:13,599 --> 00:42:15,920
secured mpc from a very weak primitive

1085
00:42:15,920 --> 00:42:18,800
called riot in the crs model i will

1086
00:42:18,800 --> 00:42:21,119
define riot in the next slide

1087
00:42:21,119 --> 00:42:24,160
and then we constructed riot from cdh

1088
00:42:24,160 --> 00:42:27,760
lpn and isig isogenes in the crs model

1089
00:42:27,760 --> 00:42:29,520
so these were not known

1090
00:42:29,520 --> 00:42:31,040
and

1091
00:42:31,040 --> 00:42:32,560
as a result we obtained the first two

1092
00:42:32,560 --> 00:42:35,200
round malicious adaptively secured mpc

1093
00:42:35,200 --> 00:42:38,560
from cdh lpn and isogenes in crs model

1094
00:42:38,560 --> 00:42:40,720
and as a side result we also construct

1095
00:42:40,720 --> 00:42:42,160
the first non-committing encryption

1096
00:42:42,160 --> 00:42:45,440
scheme from lpl so i will just briefly

1097
00:42:45,440 --> 00:42:48,079
go through the results uh

1098
00:42:48,079 --> 00:42:50,560
so let me first define what is riot so

1099
00:42:50,560 --> 00:42:54,079
it's an iot iot is is a

1100
00:42:54,079 --> 00:42:56,400
indistinguishability based security ot

1101
00:42:56,400 --> 00:42:58,000
protocol that

1102
00:42:58,000 --> 00:42:59,359
is secured against static malicious

1103
00:42:59,359 --> 00:43:02,640
corruptions riot just adds a

1104
00:43:02,640 --> 00:43:04,720
sampling property where the receivers

1105
00:43:04,720 --> 00:43:06,319
other protocol message can be

1106
00:43:06,319 --> 00:43:08,319
obliviously sampled

1107
00:43:08,319 --> 00:43:09,440
so

1108
00:43:09,440 --> 00:43:12,319
we show that uh using this riot and a

1109
00:43:12,319 --> 00:43:14,720
bunch of primitives you can construct rs

1110
00:43:14,720 --> 00:43:17,359
iot so in rs iot you can also

1111
00:43:17,359 --> 00:43:19,280
obliviously sample a sender's ot

1112
00:43:19,280 --> 00:43:22,960
protocol message that is uh yeah

1113
00:43:22,960 --> 00:43:24,800
and then you can construct these

1114
00:43:24,800 --> 00:43:27,359
primitives from one way functions

1115
00:43:27,359 --> 00:43:29,680
next we show that

1116
00:43:29,680 --> 00:43:31,760
from rx iot you can build something

1117
00:43:31,760 --> 00:43:35,839
called semi-adaptive ot which is like a

1118
00:43:35,839 --> 00:43:37,920
intermediate step to adaptive secured

1119
00:43:37,920 --> 00:43:39,280
mpc

1120
00:43:39,280 --> 00:43:41,520
then again we show that from rs iot you

1121
00:43:41,520 --> 00:43:43,280
can obtain something called trapdoor

1122
00:43:43,280 --> 00:43:45,280
simulator pke

1123
00:43:45,280 --> 00:43:48,480
and using the result of cdmw you can get

1124
00:43:48,480 --> 00:43:50,640
augmented nce so

1125
00:43:50,640 --> 00:43:55,680
um using just riot you can get till nce

1126
00:43:55,680 --> 00:43:57,680
and then by applying the result of

1127
00:43:57,680 --> 00:44:00,640
benmuda at all uh we obtain adapted

1128
00:44:00,640 --> 00:44:02,240
secure mpc

1129
00:44:02,240 --> 00:44:03,680
and finally we show that you can

1130
00:44:03,680 --> 00:44:06,960
construct riot from cdh lpn or group

1131
00:44:06,960 --> 00:44:09,359
actions and

1132
00:44:09,359 --> 00:44:11,040
yeah that's all

1133
00:44:11,040 --> 00:44:14,240
so concluding we construct uh the first

1134
00:44:14,240 --> 00:44:16,960
two round maliciously secure adaptive

1135
00:44:16,960 --> 00:44:20,560
mpc from riot so to end with two open

1136
00:44:20,560 --> 00:44:21,599
questions

1137
00:44:21,599 --> 00:44:23,599
what is the minimal assumption required

1138
00:44:23,599 --> 00:44:26,079
for this riot primitives

1139
00:44:26,079 --> 00:44:28,079
and what is the minimal assumption in

1140
00:44:28,079 --> 00:44:30,720
general required for to round adaptively

1141
00:44:30,720 --> 00:44:34,000
secure mpc protocol

1142
00:44:34,000 --> 00:44:37,240
thank you

1143
00:44:38,160 --> 00:44:40,480
thanks for a presentation pratik

1144
00:44:40,480 --> 00:44:43,760
do we have any questions

1145
00:44:48,000 --> 00:44:49,119
okay

1146
00:44:49,119 --> 00:44:52,079
i do have a question uh here uh what is

1147
00:44:52,079 --> 00:44:55,680
the relationship between uh iot or riot

1148
00:44:55,680 --> 00:44:58,160
or is iot and

1149
00:44:58,160 --> 00:45:02,240
say standard uc security can you compile

1150
00:45:02,240 --> 00:45:05,040
from one to two to the other or

1151
00:45:05,040 --> 00:45:07,040
do you need more tools

1152
00:45:07,040 --> 00:45:08,560
right uh

1153
00:45:08,560 --> 00:45:12,400
so uh ucot is stronger but in this work

1154
00:45:12,400 --> 00:45:13,520
because you need simulation

1155
00:45:13,520 --> 00:45:15,200
extractability right i mean you need to

1156
00:45:15,200 --> 00:45:18,319
extract the party's inputs uh so the

1157
00:45:18,319 --> 00:45:20,640
work by benmuda at all they actually

1158
00:45:20,640 --> 00:45:23,119
started off with ucot and that's why you

1159
00:45:23,119 --> 00:45:24,720
cannot

1160
00:45:24,720 --> 00:45:27,839
build that from uh lpn

1161
00:45:27,839 --> 00:45:29,599
uh like they start they require they

1162
00:45:29,599 --> 00:45:31,760
started off with ucot with some sampling

1163
00:45:31,760 --> 00:45:33,440
properties and that's why you cannot

1164
00:45:33,440 --> 00:45:34,560
build it from

1165
00:45:34,560 --> 00:45:37,200
lpn cdh or isogenics so that's why we

1166
00:45:37,200 --> 00:45:39,520
reduced it through this riot primitive

1167
00:45:39,520 --> 00:45:42,079
which is game based definition along

1168
00:45:42,079 --> 00:45:44,160
with some receivers amplitude probably

1169
00:45:44,160 --> 00:45:46,319
so essentially we show that uh these two

1170
00:45:46,319 --> 00:45:49,920
are equivalent riot implies uc

1171
00:45:49,920 --> 00:45:52,800
or adaptable security ucod in that sense

1172
00:45:52,800 --> 00:45:55,599
like our work shows that right

1173
00:45:55,599 --> 00:45:58,000
okay that that was uh basically my

1174
00:45:58,000 --> 00:46:01,520
question uh thanks do we have any any

1175
00:46:01,520 --> 00:46:04,160
other questions

1176
00:46:05,440 --> 00:46:06,560
so

1177
00:46:06,560 --> 00:46:08,880
thanks again pratik for a presentation

1178
00:46:08,880 --> 00:46:11,920
and we will proceed to the final

1179
00:46:11,920 --> 00:46:14,720
presentation of the session on reverse

1180
00:46:14,720 --> 00:46:17,200
firewalls for adaptively secure npc

1181
00:46:17,200 --> 00:46:19,920
without setup that's a paper by suvra

1182
00:46:19,920 --> 00:46:23,200
deep chakraborty chayaganesh mahak

1183
00:46:23,200 --> 00:46:26,160
pancholi and pratik sarkar again

1184
00:46:26,160 --> 00:46:28,000
but this presentation will be given by

1185
00:46:28,000 --> 00:46:30,960
mahak so please mohawk share your screen

1186
00:46:30,960 --> 00:46:31,920
and

1187
00:46:31,920 --> 00:46:35,200
start whenever you're ready

1188
00:46:37,760 --> 00:46:40,079
um

1189
00:46:40,480 --> 00:46:43,839
just a second

1190
00:46:56,960 --> 00:46:59,119
can you see this

1191
00:46:59,119 --> 00:47:02,480
yes we can see your screen

1192
00:47:02,480 --> 00:47:04,960
okay although we can see the

1193
00:47:04,960 --> 00:47:07,760
the bar on top i don't know if you can

1194
00:47:07,760 --> 00:47:11,560
maximize those lights

1195
00:47:12,079 --> 00:47:14,319
uh

1196
00:47:15,280 --> 00:47:17,839
it's okay though yeah don't worry we can

1197
00:47:17,839 --> 00:47:19,680
see those lights it's just a minor

1198
00:47:19,680 --> 00:47:22,000
detail we can see the slides just fine

1199
00:47:22,000 --> 00:47:24,160
just just go ahead

1200
00:47:24,160 --> 00:47:25,920
okay

1201
00:47:25,920 --> 00:47:26,960
well

1202
00:47:26,960 --> 00:47:28,960
hi again i'm going to talk about reverse

1203
00:47:28,960 --> 00:47:31,040
firewalls for adaptively secure npc

1204
00:47:31,040 --> 00:47:33,040
without setup

1205
00:47:33,040 --> 00:47:35,599
um let me first talk about mpc in the

1206
00:47:35,599 --> 00:47:37,440
classical setting

1207
00:47:37,440 --> 00:47:40,079
so suppose there are two parties charlie

1208
00:47:40,079 --> 00:47:41,839
and lucy and they want to compute a

1209
00:47:41,839 --> 00:47:45,599
function f on their inputs x1 and x2

1210
00:47:45,599 --> 00:47:47,680
and they want to do it securely by

1211
00:47:47,680 --> 00:47:49,520
securely we mean that lucy who is

1212
00:47:49,520 --> 00:47:51,920
corrupt here should only learn about the

1213
00:47:51,920 --> 00:47:53,760
output and nothing else about charlie's

1214
00:47:53,760 --> 00:47:54,720
input

1215
00:47:54,720 --> 00:47:56,960
so in classical setting charlie and lucy

1216
00:47:56,960 --> 00:47:59,760
would run some secure two pc protocol

1217
00:47:59,760 --> 00:48:01,839
and exchange some round messages and

1218
00:48:01,839 --> 00:48:04,000
towards the end they would be able to

1219
00:48:04,000 --> 00:48:07,599
learn uh f of x 1 and x 2.

1220
00:48:07,599 --> 00:48:09,760
and in this process the guarantee is

1221
00:48:09,760 --> 00:48:10,960
that

1222
00:48:10,960 --> 00:48:12,480
lucy will not learn anything about

1223
00:48:12,480 --> 00:48:15,040
charlie's input except for whatever is

1224
00:48:15,040 --> 00:48:17,839
revealed from the function output itself

1225
00:48:17,839 --> 00:48:20,079
but it is important to note that the

1226
00:48:20,079 --> 00:48:22,160
security guarantee crucially relies on

1227
00:48:22,160 --> 00:48:24,240
the assumption that the honest parties

1228
00:48:24,240 --> 00:48:26,640
execute the protocol honestly

1229
00:48:26,640 --> 00:48:28,880
that is charlie's computer has honest

1230
00:48:28,880 --> 00:48:31,040
implementation of the protocol

1231
00:48:31,040 --> 00:48:34,400
but what if this assumption is not valid

1232
00:48:34,400 --> 00:48:36,130
so in this work we consider

1233
00:48:36,130 --> 00:48:37,359
[Music]

1234
00:48:37,359 --> 00:48:38,720
uh

1235
00:48:38,720 --> 00:48:39,599
again

1236
00:48:39,599 --> 00:48:42,480
lucy is corrupt here but now we think of

1237
00:48:42,480 --> 00:48:44,960
charlie having an uh tempered

1238
00:48:44,960 --> 00:48:46,160
implementation

1239
00:48:46,160 --> 00:48:48,240
so this is this this machine is tampered

1240
00:48:48,240 --> 00:48:51,359
by the adversary before charlie gets to

1241
00:48:51,359 --> 00:48:52,880
own it

1242
00:48:52,880 --> 00:48:55,280
so what can happen in this case is that

1243
00:48:55,280 --> 00:48:57,119
instead of sending the correct message

1244
00:48:57,119 --> 00:48:59,280
prescribed for the protocol a tampon

1245
00:48:59,280 --> 00:49:00,880
implementation can just output some

1246
00:49:00,880 --> 00:49:04,160
sequence and so there is no privacy

1247
00:49:04,160 --> 00:49:05,920
and this type of leakage is called

1248
00:49:05,920 --> 00:49:08,640
exfiltration

1249
00:49:08,640 --> 00:49:10,240
um

1250
00:49:10,240 --> 00:49:12,800
but note that a tampering is slightly

1251
00:49:12,800 --> 00:49:16,400
different from an actual corruption here

1252
00:49:16,400 --> 00:49:18,480
the adversary tampers a machine in the

1253
00:49:18,480 --> 00:49:20,960
beginning and once it's owned by charlie

1254
00:49:20,960 --> 00:49:23,359
the adversary cannot arbitrarily control

1255
00:49:23,359 --> 00:49:27,280
or see the internal state of the machine

1256
00:49:27,280 --> 00:49:30,160
so the question we ask in this work is

1257
00:49:30,160 --> 00:49:33,119
can we design an mpc protocol such that

1258
00:49:33,119 --> 00:49:34,640
we get some meaningful notion of

1259
00:49:34,640 --> 00:49:36,880
security even when the machines of

1260
00:49:36,880 --> 00:49:38,559
honest parties are tampered by the

1261
00:49:38,559 --> 00:49:41,040
adversary

1262
00:49:41,040 --> 00:49:42,960
in general the answer is no

1263
00:49:42,960 --> 00:49:45,440
but with few assumptions we do get

1264
00:49:45,440 --> 00:49:47,760
positive results

1265
00:49:47,760 --> 00:49:50,240
in particular in this work we assume

1266
00:49:50,240 --> 00:49:54,160
cryptographic reverse firewalls are rfs

1267
00:49:54,160 --> 00:49:56,240
once again charlie's implementation is

1268
00:49:56,240 --> 00:49:58,640
tampered here but now there is a

1269
00:49:58,640 --> 00:50:01,200
firewall which is a piece of code that

1270
00:50:01,200 --> 00:50:03,359
sits between the implementation and the

1271
00:50:03,359 --> 00:50:06,720
outside world and its job is to sanitize

1272
00:50:06,720 --> 00:50:09,440
all incoming and outgoing messages

1273
00:50:09,440 --> 00:50:13,119
so that nothing important is leaked

1274
00:50:13,119 --> 00:50:15,040
we want that the

1275
00:50:15,040 --> 00:50:17,440
rf preserves the security notion of the

1276
00:50:17,440 --> 00:50:18,480
underlying

1277
00:50:18,480 --> 00:50:21,440
mbc protocol and this is called security

1278
00:50:21,440 --> 00:50:24,480
preserving rsp

1279
00:50:24,480 --> 00:50:26,720
and we want it to prevent the tampering

1280
00:50:26,720 --> 00:50:28,880
from leaking any sorts of secrets which

1281
00:50:28,880 --> 00:50:31,280
is called exfiltration resistance

1282
00:50:31,280 --> 00:50:32,880
and one of the objectives while

1283
00:50:32,880 --> 00:50:34,800
designing the rs is to keep its

1284
00:50:34,800 --> 00:50:37,280
operations very very simple so that the

1285
00:50:37,280 --> 00:50:39,359
code can be tested and verified before

1286
00:50:39,359 --> 00:50:41,119
using it

1287
00:50:41,119 --> 00:50:42,960
moreover it's not like we're shifting a

1288
00:50:42,960 --> 00:50:45,680
thrust to the rf as we do not allow the

1289
00:50:45,680 --> 00:50:50,078
rf to hold any of charlie's secrets

1290
00:50:50,800 --> 00:50:52,800
um let me talk a little bit about the

1291
00:50:52,800 --> 00:50:54,880
previous results before i talk about our

1292
00:50:54,880 --> 00:50:56,400
contributions

1293
00:50:56,400 --> 00:50:58,880
so this notion was introduced by marinov

1294
00:50:58,880 --> 00:50:59,920
at all

1295
00:50:59,920 --> 00:51:02,800
in europe 2015

1296
00:51:02,800 --> 00:51:04,480
and in their work they gave a

1297
00:51:04,480 --> 00:51:06,880
construction for a 2 pc protocol along

1298
00:51:06,880 --> 00:51:09,119
with the turret that is secure even in

1299
00:51:09,119 --> 00:51:11,520
the face of tampering however the

1300
00:51:11,520 --> 00:51:13,440
construction works only for passive and

1301
00:51:13,440 --> 00:51:14,960
static corruptions

1302
00:51:14,960 --> 00:51:17,119
where passive corruptions means the

1303
00:51:17,119 --> 00:51:19,280
corrupted party uh

1304
00:51:19,280 --> 00:51:20,880
corporate bodies need to follow the

1305
00:51:20,880 --> 00:51:22,640
protocol but try to learn something

1306
00:51:22,640 --> 00:51:24,720
extra from the transcript

1307
00:51:24,720 --> 00:51:26,480
and static corruptions means that the

1308
00:51:26,480 --> 00:51:28,800
adversary corrupts the parties at the

1309
00:51:28,800 --> 00:51:32,160
beginning of the protocol execution

1310
00:51:32,160 --> 00:51:35,040
then chakravarti at all uh extended this

1311
00:51:35,040 --> 00:51:37,119
result to multi-party setting and to

1312
00:51:37,119 --> 00:51:38,800
active corruptions where active

1313
00:51:38,800 --> 00:51:40,319
corrections means that the corrupted

1314
00:51:40,319 --> 00:51:43,119
parties can now uh arbitrarily behave

1315
00:51:43,119 --> 00:51:46,079
arbitrarily arbitrarily and not follow

1316
00:51:46,079 --> 00:51:47,359
the protocol

1317
00:51:47,359 --> 00:51:48,880
however this

1318
00:51:48,880 --> 00:51:51,599
construction assumes a

1319
00:51:51,599 --> 00:51:53,680
common reference string or a crs and

1320
00:51:53,680 --> 00:51:55,520
that is a setup assumption

1321
00:51:55,520 --> 00:51:57,200
um

1322
00:51:57,200 --> 00:51:59,359
so in this work we ex we further

1323
00:51:59,359 --> 00:52:01,280
strengthen the result to active and

1324
00:52:01,280 --> 00:52:02,880
adaptive corruptions

1325
00:52:02,880 --> 00:52:04,960
where adaptive corruptions means that

1326
00:52:04,960 --> 00:52:07,440
the adversary can now corrupt honest

1327
00:52:07,440 --> 00:52:09,040
parties even during the protocol

1328
00:52:09,040 --> 00:52:10,240
execution

1329
00:52:10,240 --> 00:52:12,800
and moreover we remove the assumption on

1330
00:52:12,800 --> 00:52:16,000
crs and our final construction is in the

1331
00:52:16,000 --> 00:52:19,240
plane model

1332
00:52:19,280 --> 00:52:21,760
finally to summarize our results

1333
00:52:21,760 --> 00:52:23,680
we introduced new definitions for the

1334
00:52:23,680 --> 00:52:25,280
adaptive case

1335
00:52:25,280 --> 00:52:26,800
because the older definitions did not

1336
00:52:26,800 --> 00:52:29,280
suffice for this setting

1337
00:52:29,280 --> 00:52:32,240
we give a new implication for uh between

1338
00:52:32,240 --> 00:52:34,400
exfiltration resistance and security

1339
00:52:34,400 --> 00:52:35,680
preservation

1340
00:52:35,680 --> 00:52:38,079
and this is a very interesting result

1341
00:52:38,079 --> 00:52:40,960
because uh the prior works conjecture

1342
00:52:40,960 --> 00:52:43,599
that these two results these two notions

1343
00:52:43,599 --> 00:52:45,920
might not be related but we show that

1344
00:52:45,920 --> 00:52:47,599
they indeed are for simulation based

1345
00:52:47,599 --> 00:52:49,839
security

1346
00:52:49,839 --> 00:52:52,000
and as mentioned uh we give a new

1347
00:52:52,000 --> 00:52:53,760
construction that is secure against

1348
00:52:53,760 --> 00:52:56,800
adaptive and active adversary and secure

1349
00:52:56,800 --> 00:52:58,480
even when honest bodies machines are

1350
00:52:58,480 --> 00:53:00,800
tempered

1351
00:53:00,800 --> 00:53:03,440
um thank you and you can find more uh

1352
00:53:03,440 --> 00:53:05,280
details on our paper which is on the

1353
00:53:05,280 --> 00:53:09,839
apron and um on the extended top

1354
00:53:09,839 --> 00:53:12,000
thanks for talking

1355
00:53:12,000 --> 00:53:14,800
uh do we have any questions

1356
00:53:14,800 --> 00:53:16,800
if someone wants to ask questions on

1357
00:53:16,800 --> 00:53:18,480
audio please open your microphones

1358
00:53:18,480 --> 00:53:20,960
otherwise we do have zulip that is

1359
00:53:20,960 --> 00:53:24,640
looking a bit silent right now

1360
00:53:26,079 --> 00:53:27,680
so start with a

1361
00:53:27,680 --> 00:53:29,359
with the question maybe it was my

1362
00:53:29,359 --> 00:53:31,280
misunderstanding or maybe we even talked

1363
00:53:31,280 --> 00:53:33,440
about it but i'm not clear on whether

1364
00:53:33,440 --> 00:53:35,760
the adaptive adversary is allowed to

1365
00:53:35,760 --> 00:53:37,920
adaptively tamper with the honest

1366
00:53:37,920 --> 00:53:40,480
party's machine after the execution has

1367
00:53:40,480 --> 00:53:42,400
started or not

1368
00:53:42,400 --> 00:53:44,720
so what is the case

1369
00:53:44,720 --> 00:53:47,680
it is adaptive corruption so the uh

1370
00:53:47,680 --> 00:53:49,520
in the beginning the

1371
00:53:49,520 --> 00:53:52,079
the adversary would have tampered on its

1372
00:53:52,079 --> 00:53:55,680
bodies but later during execution it can

1373
00:53:55,680 --> 00:53:57,920
corrupt these already tampered parties

1374
00:53:57,920 --> 00:54:00,079
also in which case it would

1375
00:54:00,079 --> 00:54:01,520
start controlling the parties from that

1376
00:54:01,520 --> 00:54:04,000
point onwards but we would want

1377
00:54:04,000 --> 00:54:06,800
uh that before this corruption happens

1378
00:54:06,800 --> 00:54:08,480
nothing is revealed

1379
00:54:08,480 --> 00:54:10,720
we don't really we don't say much about

1380
00:54:10,720 --> 00:54:13,280
what happens after corruption

1381
00:54:13,280 --> 00:54:14,240
okay

1382
00:54:14,240 --> 00:54:16,079
uh and

1383
00:54:16,079 --> 00:54:18,720
what tools do you need to build these uh

1384
00:54:18,720 --> 00:54:21,119
reverse firewalls for this very strong

1385
00:54:21,119 --> 00:54:23,760
case of a adaptive secure npc can you

1386
00:54:23,760 --> 00:54:25,440
build it from the same kind of tools you

1387
00:54:25,440 --> 00:54:27,680
use for adaptively secure npc like

1388
00:54:27,680 --> 00:54:29,599
non-convenient encryption and so on

1389
00:54:29,599 --> 00:54:31,359
adaptively security or do you need

1390
00:54:31,359 --> 00:54:34,240
something else for the

1391
00:54:34,240 --> 00:54:36,480
so we do use some of the standard tools

1392
00:54:36,480 --> 00:54:38,720
we use and adaptively secure uh

1393
00:54:38,720 --> 00:54:41,119
commitment scheme

1394
00:54:41,119 --> 00:54:43,680
um and we so so we our general

1395
00:54:43,680 --> 00:54:46,480
construction is it follows gmw uh

1396
00:54:46,480 --> 00:54:48,160
compiler approach

1397
00:54:48,160 --> 00:54:49,760
and so all the building blocks the

1398
00:54:49,760 --> 00:54:52,640
commitments came the zero knowledge uh

1399
00:54:52,640 --> 00:54:54,319
protocol that we use all of them have to

1400
00:54:54,319 --> 00:54:57,119
be adaptively secure

1401
00:54:57,119 --> 00:54:59,680
but finally to make it uh work in plain

1402
00:54:59,680 --> 00:55:02,240
model we do we do assume knowledge

1403
00:55:02,240 --> 00:55:04,400
assumptions

1404
00:55:04,400 --> 00:55:05,440
okay

1405
00:55:05,440 --> 00:55:07,520
thanks for the explanation

1406
00:55:07,520 --> 00:55:11,760
uh do we have any any more questions

1407
00:55:11,760 --> 00:55:14,640
so i'd like to thank mahak again

1408
00:55:14,640 --> 00:55:17,760
and uh now since we have three remaining

1409
00:55:17,760 --> 00:55:19,440
minutes i'd like to open the floor to

1410
00:55:19,440 --> 00:55:21,119
anyone who would like to ask any

1411
00:55:21,119 --> 00:55:23,040
questions about any of the

1412
00:55:23,040 --> 00:55:26,240
the presentations we had

1413
00:55:28,160 --> 00:55:29,760
i guess not so

1414
00:55:29,760 --> 00:55:32,079
finally i'd like to thank all of the

1415
00:55:32,079 --> 00:55:34,240
presenters and all of the authors of the

1416
00:55:34,240 --> 00:55:36,720
papers in the session and of course also

1417
00:55:36,720 --> 00:55:39,119
thank you all who attended our session

1418
00:55:39,119 --> 00:55:41,280
and a special thanks to kevin mccurley

1419
00:55:41,280 --> 00:55:43,359
who once again helped us set up the

1420
00:55:43,359 --> 00:55:45,359
whole infrastructure for those online

1421
00:55:45,359 --> 00:55:46,480
conferences

1422
00:55:46,480 --> 00:55:48,559
thank you all and i hope to

1423
00:55:48,559 --> 00:55:51,200
see you later in the social hour and in

1424
00:55:51,200 --> 00:55:55,200
the remaining days of asia crypt 2021

1425
00:55:55,200 --> 00:55:56,720
have a good day

1426
00:55:56,720 --> 00:55:58,559
and i believe the social hour is

1427
00:55:58,559 --> 00:56:00,319
starting in two minutes

1428
00:56:00,319 --> 00:56:01,119
so

1429
00:56:01,119 --> 00:56:02,720
if you haven't noticed in the program

1430
00:56:02,720 --> 00:56:04,720
there are four different rooms for four

1431
00:56:04,720 --> 00:56:06,720
different languages hopefully that

1432
00:56:06,720 --> 00:56:07,920
covers

1433
00:56:07,920 --> 00:56:09,839
the whole spectrum of necessary

1434
00:56:09,839 --> 00:56:11,680
languages

1435
00:56:11,680 --> 00:56:13,359
and uh

1436
00:56:13,359 --> 00:56:15,359
the the rooms are hosted by people who

1437
00:56:15,359 --> 00:56:17,760
speak those languages so i invite you to

1438
00:56:17,760 --> 00:56:19,200
go and

1439
00:56:19,200 --> 00:56:20,319
mingle with some of your other

1440
00:56:20,319 --> 00:56:23,440
cryptographer friends

1441
00:56:25,599 --> 00:56:27,599
thanks everyone

1442
00:56:27,599 --> 00:56:30,839
thank you

