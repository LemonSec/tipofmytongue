1
00:00:00,880 --> 00:00:03,120
good afternoon everybody i am shandib

2
00:00:03,120 --> 00:00:05,040
shaha and today i am going to present

3
00:00:05,040 --> 00:00:07,600
our talk divided with stand united with

4
00:00:07,600 --> 00:00:11,040
fall security analysis of some scs ifa

5
00:00:11,040 --> 00:00:13,679
counter measures against sca enhanced

6
00:00:13,679 --> 00:00:15,759
fault template attacks this is a joint

7
00:00:15,759 --> 00:00:19,920
work with orno bag director zap debt

8
00:00:19,920 --> 00:00:21,840
and shivan basin

9
00:00:21,840 --> 00:00:25,279
myself or nope and devops are from

10
00:00:25,279 --> 00:00:28,000
indian stock technology kharagpur

11
00:00:28,000 --> 00:00:30,400
diribantho zap

12
00:00:30,400 --> 00:00:32,159
are from nanyang technological

13
00:00:32,159 --> 00:00:35,519
university singapore

14
00:00:36,399 --> 00:00:38,480
crypto illumination is real life leak

15
00:00:38,480 --> 00:00:40,879
sensitive information pretty well known

16
00:00:40,879 --> 00:00:42,559
till now

17
00:00:42,559 --> 00:00:45,039
uh among several

18
00:00:45,039 --> 00:00:47,920
sources of information leakage

19
00:00:47,920 --> 00:00:50,079
side channels are one of the most

20
00:00:50,079 --> 00:00:52,800
prominent one where the adversary

21
00:00:52,800 --> 00:00:54,960
passively observes some

22
00:00:54,960 --> 00:00:57,120
physical signals such as electromagnetic

23
00:00:57,120 --> 00:00:58,719
radiation or

24
00:00:58,719 --> 00:01:00,800
power consumption of the chip and from

25
00:01:00,800 --> 00:01:03,359
there it tries to detect the secret in

26
00:01:03,359 --> 00:01:06,400
contrast a fault attack adversary

27
00:01:06,400 --> 00:01:08,320
deliberately part of the computation of

28
00:01:08,320 --> 00:01:10,640
the chip and from the faulty system

29
00:01:10,640 --> 00:01:14,880
responses tries to derive the secret

30
00:01:14,880 --> 00:01:16,720
counter measures

31
00:01:16,720 --> 00:01:20,159
are there for both of these attacks

32
00:01:20,159 --> 00:01:22,159
and they have been defined i mean

33
00:01:22,159 --> 00:01:26,000
designed quite orthogonal date

34
00:01:26,000 --> 00:01:28,240
however one thing is common

35
00:01:28,240 --> 00:01:30,320
that designing counter measure for both

36
00:01:30,320 --> 00:01:31,840
of these attacks are very tricky and

37
00:01:31,840 --> 00:01:34,720
there are several failures tools

38
00:01:34,720 --> 00:01:37,759
now we address the question that when

39
00:01:37,759 --> 00:01:39,520
both kind of counter measures are

40
00:01:39,520 --> 00:01:41,360
present

41
00:01:41,360 --> 00:01:44,240
can there be adversaries meeting their

42
00:01:44,240 --> 00:01:45,439
hands like

43
00:01:45,439 --> 00:01:47,759
they can be present together

44
00:01:47,759 --> 00:01:50,320
now given modern experimental setups it

45
00:01:50,320 --> 00:01:52,720
is quite feasible and we have also shown

46
00:01:52,720 --> 00:01:55,119
that practically in this world however

47
00:01:55,119 --> 00:01:57,920
this area is relatively less explored

48
00:01:57,920 --> 00:01:59,119
now

49
00:01:59,119 --> 00:02:01,520
our major concern is that when both

50
00:02:01,520 --> 00:02:03,439
countermeasures are present and the

51
00:02:03,439 --> 00:02:06,560
adversaries are present simultaneously

52
00:02:06,560 --> 00:02:08,800
or they're assisting each other

53
00:02:08,800 --> 00:02:10,639
then what is the picture what happens to

54
00:02:10,639 --> 00:02:12,400
the countermeasure that is what we

55
00:02:12,400 --> 00:02:15,280
address in this work

56
00:02:15,280 --> 00:02:16,720
now talking about fault data

57
00:02:16,720 --> 00:02:18,800
countermeasures

58
00:02:18,800 --> 00:02:21,760
the main theme is redundancy

59
00:02:21,760 --> 00:02:24,560
in simpler words

60
00:02:24,560 --> 00:02:26,720
i mean the computation is performed

61
00:02:26,720 --> 00:02:28,160
several times

62
00:02:28,160 --> 00:02:29,599
and

63
00:02:29,599 --> 00:02:31,599
if the results agree with each other

64
00:02:31,599 --> 00:02:33,440
then only the cipher text is outputted

65
00:02:33,440 --> 00:02:37,200
otherwise it is muted or randomized

66
00:02:37,200 --> 00:02:39,280
such redundancy can be implemented at

67
00:02:39,280 --> 00:02:41,840
finer grain like for every round for

68
00:02:41,840 --> 00:02:44,080
every xbox operation and so

69
00:02:44,080 --> 00:02:45,280
but the

70
00:02:45,280 --> 00:02:46,560
main

71
00:02:46,560 --> 00:02:49,360
idea is the same for everything

72
00:02:49,360 --> 00:02:50,800
in contrast

73
00:02:50,800 --> 00:02:52,800
side channel counter measures tries to

74
00:02:52,800 --> 00:02:55,040
randomize the computation in some way so

75
00:02:55,040 --> 00:02:55,840
that

76
00:02:55,840 --> 00:02:57,760
the side channel signals become

77
00:02:57,760 --> 00:03:00,800
uncorrelated with the secret

78
00:03:00,800 --> 00:03:03,280
so one of the most popular one is called

79
00:03:03,280 --> 00:03:04,400
masking

80
00:03:04,400 --> 00:03:06,319
which requires fresh randomness for each

81
00:03:06,319 --> 00:03:08,720
every execution of the

82
00:03:08,720 --> 00:03:12,000
cipher so the main idea is that we split

83
00:03:12,000 --> 00:03:14,239
a secret or sensitive variable into

84
00:03:14,239 --> 00:03:16,400
multiple random variables which we call

85
00:03:16,400 --> 00:03:19,440
as shares such that the exhaust sum of

86
00:03:19,440 --> 00:03:21,360
shares give you gives you back the

87
00:03:21,360 --> 00:03:24,000
actual variable the function which works

88
00:03:24,000 --> 00:03:26,400
over the shares are also separated into

89
00:03:26,400 --> 00:03:29,360
several component functions such that

90
00:03:29,360 --> 00:03:31,440
their operation over the shares if you

91
00:03:31,440 --> 00:03:34,879
combine them you get the exact result

92
00:03:34,879 --> 00:03:36,799
now such splitting of function is kind

93
00:03:36,799 --> 00:03:38,959
of previous on linear function thanks to

94
00:03:38,959 --> 00:03:41,360
the linearity properties however for

95
00:03:41,360 --> 00:03:43,599
non-linear function it is very tricky

96
00:03:43,599 --> 00:03:46,159
and electron and over the years people

97
00:03:46,159 --> 00:03:48,560
have figured out several ways for doing

98
00:03:48,560 --> 00:03:50,239
a proper sharing

99
00:03:50,239 --> 00:03:52,959
lightweight and secure one for nonlinear

100
00:03:52,959 --> 00:03:55,040
functions there are other tricks like

101
00:03:55,040 --> 00:03:57,760
hiding shuffling where randomly the

102
00:03:57,760 --> 00:04:00,400
program sequence is altered without

103
00:04:00,400 --> 00:04:02,640
changing the end result but in this talk

104
00:04:02,640 --> 00:04:04,480
we'll be mainly focusing on masking and

105
00:04:04,480 --> 00:04:06,159
with no doubt masking is the most

106
00:04:06,159 --> 00:04:07,680
prominent one

107
00:04:07,680 --> 00:04:11,360
in situational confirmation

108
00:04:11,360 --> 00:04:13,599
now since 2018

109
00:04:13,599 --> 00:04:15,439
there has been some breakthrough results

110
00:04:15,439 --> 00:04:17,839
in the context of fault attacks

111
00:04:17,839 --> 00:04:20,079
so which basically

112
00:04:20,079 --> 00:04:22,000
makes all the countermeasures vulnerable

113
00:04:22,000 --> 00:04:24,800
to attacks so more precisely we are

114
00:04:24,800 --> 00:04:27,120
talking about ineffective faults

115
00:04:27,120 --> 00:04:28,880
so what is an effective for let's take

116
00:04:28,880 --> 00:04:31,680
an example say i'm injecting a fault in

117
00:04:31,680 --> 00:04:33,120
a four bit state

118
00:04:33,120 --> 00:04:35,199
or more precisely a

119
00:04:35,199 --> 00:04:37,520
bit stuck at fault stuck at zero fault

120
00:04:37,520 --> 00:04:39,840
at the first bit of the four bit state

121
00:04:39,840 --> 00:04:41,520
now if i considered all possible

122
00:04:41,520 --> 00:04:44,080
valuations we see that for first eight

123
00:04:44,080 --> 00:04:46,320
valuations the fault has no impact of

124
00:04:46,320 --> 00:04:48,880
the output so even if you are injecting

125
00:04:48,880 --> 00:04:50,720
the fault you will get correct

126
00:04:50,720 --> 00:04:51,520
now

127
00:04:51,520 --> 00:04:53,600
one of the most prominent charts called

128
00:04:53,600 --> 00:04:55,919
statistical ineffective fault analysis

129
00:04:55,919 --> 00:04:57,840
exploit this fact

130
00:04:57,840 --> 00:04:59,919
and it can extract the key from the

131
00:04:59,919 --> 00:05:02,000
correct system

132
00:05:02,000 --> 00:05:04,400
the fact given that if you just consider

133
00:05:04,400 --> 00:05:06,080
the correct ciphertext space the

134
00:05:06,080 --> 00:05:07,600
intermediate while you are injecting

135
00:05:07,600 --> 00:05:09,919
fault getting biased it only takes seven

136
00:05:09,919 --> 00:05:12,320
values or eight values among all

137
00:05:12,320 --> 00:05:14,000
possible valuation

138
00:05:14,000 --> 00:05:16,800
so this bias has in recovering the key

139
00:05:16,800 --> 00:05:18,720
in contrast

140
00:05:18,720 --> 00:05:21,120
fta attack which is published in 2020

141
00:05:21,120 --> 00:05:23,759
eurocrip is slightly different first of

142
00:05:23,759 --> 00:05:25,919
all it is the first case of profile

143
00:05:25,919 --> 00:05:28,720
letter in the context of fault analysis

144
00:05:28,720 --> 00:05:31,280
and it exploits the fact that

145
00:05:31,280 --> 00:05:34,160
fault propagation through logic gates is

146
00:05:34,160 --> 00:05:36,320
data dependent that is whether the fault

147
00:05:36,320 --> 00:05:37,919
will propagate to the output of the gate

148
00:05:37,919 --> 00:05:40,800
or not depends on the inputs of the gate

149
00:05:40,800 --> 00:05:44,320
and this fact actually helps

150
00:05:44,320 --> 00:05:46,639
to recover the secret without any

151
00:05:46,639 --> 00:05:48,639
ciphertext access you just need to know

152
00:05:48,639 --> 00:05:50,160
whether the fault is there in the

153
00:05:50,160 --> 00:05:51,919
ciphertext or not just in one bit

154
00:05:51,919 --> 00:05:53,840
information

155
00:05:53,840 --> 00:05:55,440
now

156
00:05:55,440 --> 00:05:57,199
one fact is common for both of these

157
00:05:57,199 --> 00:05:59,759
countermeasures that the bypass

158
00:05:59,759 --> 00:06:02,160
all existing faulted encounter measures

159
00:06:02,160 --> 00:06:03,360
as well as

160
00:06:03,360 --> 00:06:04,960
counter measures which are which

161
00:06:04,960 --> 00:06:07,120
combines faulted account counter measure

162
00:06:07,120 --> 00:06:09,759
with saturn at accountability

163
00:06:09,759 --> 00:06:13,360
fortunately since 2020 we are observing

164
00:06:13,360 --> 00:06:15,199
significant research in counter measure

165
00:06:15,199 --> 00:06:16,960
development to prevent these attacks

166
00:06:16,960 --> 00:06:18,960
especially the sifa

167
00:06:18,960 --> 00:06:21,520
the first proposals consider fine gain

168
00:06:21,520 --> 00:06:23,680
error correction i mean for partial

169
00:06:23,680 --> 00:06:26,720
level along with masking

170
00:06:26,720 --> 00:06:29,840
there is another solution which consider

171
00:06:29,840 --> 00:06:32,319
to implement the mass gates using

172
00:06:32,319 --> 00:06:36,080
toefully gates so that some advantages

173
00:06:36,080 --> 00:06:37,520
are gained

174
00:06:37,520 --> 00:06:39,600
we'll discuss this counter measures

175
00:06:39,600 --> 00:06:42,240
later in this talk in more detail

176
00:06:42,240 --> 00:06:45,039
but here we have to focus that most of

177
00:06:45,039 --> 00:06:46,319
the fault attack

178
00:06:46,319 --> 00:06:48,639
fifa counter measures actually involve

179
00:06:48,639 --> 00:06:50,479
masking because masking has some

180
00:06:50,479 --> 00:06:52,800
advantages over sifa

181
00:06:52,800 --> 00:06:55,280
and also it involves some error

182
00:06:55,280 --> 00:06:57,120
correction or detection operation so

183
00:06:57,120 --> 00:06:59,039
there is a complex interaction between

184
00:06:59,039 --> 00:07:01,360
an sd counter mirror masking and the

185
00:07:01,360 --> 00:07:02,800
faulted standard folder account

186
00:07:02,800 --> 00:07:04,319
dimensions here

187
00:07:04,319 --> 00:07:06,639
now since there are both counter

188
00:07:06,639 --> 00:07:09,840
measures present so our aim is to see

189
00:07:09,840 --> 00:07:12,560
whether this stands against a combined

190
00:07:12,560 --> 00:07:14,720
adversary or we need to do something

191
00:07:14,720 --> 00:07:17,120
extra

192
00:07:17,120 --> 00:07:20,400
say this regard our finding says

193
00:07:20,400 --> 00:07:21,599
that we are

194
00:07:21,599 --> 00:07:24,240
we have stilled

195
00:07:24,240 --> 00:07:26,800
to do something more to prevent all

196
00:07:26,800 --> 00:07:29,120
these attacks more precisely we propose

197
00:07:29,120 --> 00:07:30,960
a cft attack

198
00:07:30,960 --> 00:07:33,280
which actually breaks certain existing

199
00:07:33,280 --> 00:07:35,520
fifa counter measures moreover it

200
00:07:35,520 --> 00:07:37,599
exposes few injury cases associated with

201
00:07:37,599 --> 00:07:39,280
masking while realizing fifa

202
00:07:39,280 --> 00:07:41,039
countermeasures

203
00:07:41,039 --> 00:07:43,440
like fta attack it enables middle round

204
00:07:43,440 --> 00:07:45,680
attacks without ciphertext access or

205
00:07:45,680 --> 00:07:48,720
direct access to flink

206
00:07:48,960 --> 00:07:49,759
so

207
00:07:49,759 --> 00:07:53,120
let's see what is scfta

208
00:07:53,120 --> 00:07:54,240
so

209
00:07:54,240 --> 00:07:56,240
it is a template attack or profile

210
00:07:56,240 --> 00:07:57,360
technique

211
00:07:57,360 --> 00:07:59,520
and has similarities with

212
00:07:59,520 --> 00:08:01,520
fault absolute attack as well as side

213
00:08:01,520 --> 00:08:03,360
chain template attack so the adversary

214
00:08:03,360 --> 00:08:06,000
is assumed to have access to a device

215
00:08:06,000 --> 00:08:07,199
for which he knows the key and

216
00:08:07,199 --> 00:08:08,479
randomness

217
00:08:08,479 --> 00:08:10,800
he injects faults at different locations

218
00:08:10,800 --> 00:08:12,319
and simultaneously measured the side

219
00:08:12,319 --> 00:08:13,759
channel sequence

220
00:08:13,759 --> 00:08:14,879
now

221
00:08:14,879 --> 00:08:17,120
combining the side channel signals for

222
00:08:17,120 --> 00:08:19,039
several fault locations

223
00:08:19,039 --> 00:08:21,360
he actually creates a template which

224
00:08:21,360 --> 00:08:22,479
indicates

225
00:08:22,479 --> 00:08:25,599
what is the intermediate state like

226
00:08:25,599 --> 00:08:28,639
upon getting a new

227
00:08:28,639 --> 00:08:31,599
setup where that key is unknown

228
00:08:31,599 --> 00:08:34,000
he deliberately parted those locations

229
00:08:34,000 --> 00:08:36,880
which he have previously decided of

230
00:08:36,880 --> 00:08:38,880
course one at a time

231
00:08:38,880 --> 00:08:41,120
measures the side chain signal and from

232
00:08:41,120 --> 00:08:43,519
there extracts the circuit

233
00:08:43,519 --> 00:08:44,399
now

234
00:08:44,399 --> 00:08:46,560
the model is similar to fta or we can

235
00:08:46,560 --> 00:08:48,320
also call it similar to standard

236
00:08:48,320 --> 00:08:50,560
classical side-chain template attacks

237
00:08:50,560 --> 00:08:53,360
but the gain is that over fta

238
00:08:53,360 --> 00:08:54,560
that

239
00:08:54,560 --> 00:08:56,320
fda only exploits the fact whether the

240
00:08:56,320 --> 00:08:58,240
cybertex is character faulty typically

241
00:08:58,240 --> 00:09:00,640
in one bit information but here due to

242
00:09:00,640 --> 00:09:02,480
side channel you get something more and

243
00:09:02,480 --> 00:09:04,160
that actually becomes crucial for

244
00:09:04,160 --> 00:09:06,720
breaking fifa contraband

245
00:09:06,720 --> 00:09:09,040
now how we build this template we

246
00:09:09,040 --> 00:09:10,399
exploit

247
00:09:10,399 --> 00:09:11,760
the interaction between fault

248
00:09:11,760 --> 00:09:14,880
propagation and error detection so as i

249
00:09:14,880 --> 00:09:16,959
mentioned fault propagation and

250
00:09:16,959 --> 00:09:18,560
activation through gates are data

251
00:09:18,560 --> 00:09:20,800
dependent so if you consider an xor gate

252
00:09:20,800 --> 00:09:22,880
and a stack at zero fault

253
00:09:22,880 --> 00:09:26,160
the outcome is only faulted if the fault

254
00:09:26,160 --> 00:09:28,720
location contains the value one for and

255
00:09:28,720 --> 00:09:30,000
gate

256
00:09:30,000 --> 00:09:31,680
even if the value is one the fault may

257
00:09:31,680 --> 00:09:33,360
not propagate because it depends on the

258
00:09:33,360 --> 00:09:35,279
other inputs if the other input is also

259
00:09:35,279 --> 00:09:38,240
one you see a fault location so if you

260
00:09:38,240 --> 00:09:39,839
see that there is a fault propagation at

261
00:09:39,839 --> 00:09:41,440
the output of this gate you surely know

262
00:09:41,440 --> 00:09:43,600
that the inputs are one and one for a

263
00:09:43,600 --> 00:09:45,360
24k

264
00:09:45,360 --> 00:09:47,600
now

265
00:09:48,640 --> 00:09:50,800
how can we see the fault replication so

266
00:09:50,800 --> 00:09:52,880
if there is some circuitry

267
00:09:52,880 --> 00:09:54,800
which actually reacts in the fall

268
00:09:54,800 --> 00:09:56,320
propagation

269
00:09:56,320 --> 00:09:59,040
then there is a chance that it will

270
00:09:59,040 --> 00:10:01,360
detect whether the fault is propagating

271
00:10:01,360 --> 00:10:03,760
or not and that will lead to some

272
00:10:03,760 --> 00:10:06,160
effective side channel information and

273
00:10:06,160 --> 00:10:07,839
this is what error correction or

274
00:10:07,839 --> 00:10:10,240
detection module does in

275
00:10:10,240 --> 00:10:13,279
fault attack or certain items

276
00:10:13,279 --> 00:10:15,519
now let's take a more prominent example

277
00:10:15,519 --> 00:10:19,200
here we consider a 3-bit xbox

278
00:10:19,200 --> 00:10:22,640
due to catch at subu etc and we are

279
00:10:22,640 --> 00:10:25,519
injecting a fault at h0 now we see the

280
00:10:25,519 --> 00:10:28,560
fault mandatory propagates to y naught

281
00:10:28,560 --> 00:10:29,680
every time

282
00:10:29,680 --> 00:10:32,399
but the propagation to y one and y2

283
00:10:32,399 --> 00:10:35,680
are conditional on the input values

284
00:10:35,680 --> 00:10:38,240
now given this fact we see that if we

285
00:10:38,240 --> 00:10:39,920
observe the fault propagation or fault

286
00:10:39,920 --> 00:10:41,760
differential at the output of this xbox

287
00:10:41,760 --> 00:10:44,240
it exposes the input

288
00:10:44,240 --> 00:10:45,360
and

289
00:10:45,360 --> 00:10:47,440
the main fact is that

290
00:10:47,440 --> 00:10:50,079
we cannot directly observe such fall

291
00:10:50,079 --> 00:10:51,760
propagation in all practical cases when

292
00:10:51,760 --> 00:10:53,760
you have countermeasures right

293
00:10:53,760 --> 00:10:55,120
so for that

294
00:10:55,120 --> 00:10:57,120
if we use a side channel

295
00:10:57,120 --> 00:10:59,680
we still can do that track because side

296
00:10:59,680 --> 00:11:01,279
channel although uh

297
00:11:01,279 --> 00:11:02,800
abstracts the information in form of

298
00:11:02,800 --> 00:11:04,320
hamming waves so it loses some

299
00:11:04,320 --> 00:11:06,000
information but still there is some

300
00:11:06,000 --> 00:11:09,040
entropy loss in this intermediate state

301
00:11:09,040 --> 00:11:11,680
or the input of this box so that can be

302
00:11:11,680 --> 00:11:14,320
exploited for it let's see a more

303
00:11:14,320 --> 00:11:16,640
concrete example here here we consider

304
00:11:16,640 --> 00:11:18,720
the present test box it's a four bit as

305
00:11:18,720 --> 00:11:21,760
box and we excite

306
00:11:21,760 --> 00:11:24,160
each of the bits one at a time with

307
00:11:24,160 --> 00:11:27,440
faults and measure the output signal

308
00:11:27,440 --> 00:11:29,360
from an error detection circuit this is

309
00:11:29,360 --> 00:11:31,120
quite common because present at a bit

310
00:11:31,120 --> 00:11:32,560
permutation

311
00:11:32,560 --> 00:11:34,000
now

312
00:11:34,000 --> 00:11:35,360
observing them

313
00:11:35,360 --> 00:11:36,880
and measuring the side channel leakage

314
00:11:36,880 --> 00:11:38,640
we can construct a

315
00:11:38,640 --> 00:11:40,240
template of this kind here we have

316
00:11:40,240 --> 00:11:42,240
abstracted the side channel signals

317
00:11:42,240 --> 00:11:44,560
using hemingway which is noise free but

318
00:11:44,560 --> 00:11:46,240
actual experiment has been performed

319
00:11:46,240 --> 00:11:48,560
considering both fault injection noise

320
00:11:48,560 --> 00:11:51,360
as well as side channel noise and we see

321
00:11:51,360 --> 00:11:53,440
that the state intermediate state of

322
00:11:53,440 --> 00:11:55,600
present can be exposed roughly with

323
00:11:55,600 --> 00:11:57,279
eleven thousand traces and fault

324
00:11:57,279 --> 00:11:58,959
detection

325
00:11:58,959 --> 00:12:01,760
now this one was an unprotected side

326
00:12:01,760 --> 00:12:03,440
channel unprotected version of present

327
00:12:03,440 --> 00:12:06,399
and only fa protection was present

328
00:12:06,399 --> 00:12:08,320
now let's see what happens when masking

329
00:12:08,320 --> 00:12:10,079
is present now the scenario becomes

330
00:12:10,079 --> 00:12:11,920
quite interesting

331
00:12:11,920 --> 00:12:14,399
because now you can also mask the error

332
00:12:14,399 --> 00:12:16,399
detection logic

333
00:12:16,399 --> 00:12:18,320
so directly from the error detection

334
00:12:18,320 --> 00:12:20,320
logic you are not supposed to get any

335
00:12:20,320 --> 00:12:21,519
information

336
00:12:21,519 --> 00:12:23,440
but still we get some information at

337
00:12:23,440 --> 00:12:26,079
least for some specific masking schemes

338
00:12:26,079 --> 00:12:29,440
we consider here domain oriented masking

339
00:12:29,440 --> 00:12:31,360
now let's see what happens if you inject

340
00:12:31,360 --> 00:12:33,279
a fault at a naught

341
00:12:33,279 --> 00:12:35,440
now since we inject a fault at a naught

342
00:12:35,440 --> 00:12:38,720
it exposes the information of b because

343
00:12:38,720 --> 00:12:41,279
it's only propagated to q naught when b

344
00:12:41,279 --> 00:12:43,120
is one

345
00:12:43,120 --> 00:12:45,519
now interesting fact is that it only

346
00:12:45,519 --> 00:12:47,519
propagates to q one and not the other

347
00:12:47,519 --> 00:12:50,160
share q one of the

348
00:12:50,160 --> 00:12:51,519
dom game

349
00:12:51,519 --> 00:12:53,920
now when considering an ac attack we

350
00:12:53,920 --> 00:12:55,760
always have to think about the order of

351
00:12:55,760 --> 00:12:57,360
the leakage because this is what we are

352
00:12:57,360 --> 00:12:58,720
considering here is the first order

353
00:12:58,720 --> 00:13:01,040
implementation so if you consider a

354
00:13:01,040 --> 00:13:02,880
second-order ac attack on that that is

355
00:13:02,880 --> 00:13:05,279
not efficient right but fortunately due

356
00:13:05,279 --> 00:13:07,600
to the fault propagation if we just

357
00:13:07,600 --> 00:13:08,800
prove

358
00:13:08,800 --> 00:13:11,440
the error detection logic of q naught we

359
00:13:11,440 --> 00:13:13,519
are good we are still exposing the

360
00:13:13,519 --> 00:13:15,360
information of b and that is the first

361
00:13:15,360 --> 00:13:16,800
order vector

362
00:13:16,800 --> 00:13:20,000
so the attack is efficient and with just

363
00:13:20,000 --> 00:13:21,760
a fault and a fast order side channel

364
00:13:21,760 --> 00:13:23,920
leakage we can expose

365
00:13:23,920 --> 00:13:26,079
the information from this kind of

366
00:13:26,079 --> 00:13:27,920
construction

367
00:13:27,920 --> 00:13:31,279
interestingly this also applies to

368
00:13:31,279 --> 00:13:32,880
modern

369
00:13:32,880 --> 00:13:34,399
dom based or

370
00:13:34,399 --> 00:13:36,959
isw based schemes like pinning

371
00:13:36,959 --> 00:13:39,040
and it is not limited to the first order

372
00:13:39,040 --> 00:13:42,079
case only even for any higher order you

373
00:13:42,079 --> 00:13:44,000
can still do a faster attack because the

374
00:13:44,000 --> 00:13:46,639
fault propagation is something like this

375
00:13:46,639 --> 00:13:48,720
so this is a clear

376
00:13:48,720 --> 00:13:51,120
vulnerability

377
00:13:51,120 --> 00:13:53,600
now let's consider a situation when

378
00:13:53,600 --> 00:13:55,680
there is inner correction on the shared

379
00:13:55,680 --> 00:13:58,000
values in a bit level manner now why we

380
00:13:58,000 --> 00:13:59,600
are considering this because this has

381
00:13:59,600 --> 00:14:01,839
been crucial in developing some recent

382
00:14:01,839 --> 00:14:04,639
sifa countermeasures so here we consider

383
00:14:04,639 --> 00:14:06,560
shear level error correction for each

384
00:14:06,560 --> 00:14:08,560
year there is some error correction

385
00:14:08,560 --> 00:14:10,160
now we see that we can see if you

386
00:14:10,160 --> 00:14:11,839
consider this kind of inner correction

387
00:14:11,839 --> 00:14:13,040
logic

388
00:14:13,040 --> 00:14:15,120
then when the encoding is perfect that

389
00:14:15,120 --> 00:14:17,199
there is no error then some of the

390
00:14:17,199 --> 00:14:19,839
intermediates were toggles randomly it's

391
00:14:19,839 --> 00:14:22,160
no doubt but whenever there is an error

392
00:14:22,160 --> 00:14:24,160
such that this bit becomes zero or this

393
00:14:24,160 --> 00:14:25,600
bit becomes one

394
00:14:25,600 --> 00:14:28,720
this intermediate wire starts to zero

395
00:14:28,720 --> 00:14:30,560
so there is a clear difference between a

396
00:14:30,560 --> 00:14:32,959
faulty and non-faulty situation and that

397
00:14:32,959 --> 00:14:35,120
leaks the side chain information

398
00:14:35,120 --> 00:14:38,320
which leads to an attack

399
00:14:39,199 --> 00:14:41,600
now let's see what happens for a sifa

400
00:14:41,600 --> 00:14:43,440
countermeasure we consider the fifa

401
00:14:43,440 --> 00:14:45,600
countermeasure published in pks 2020

402
00:14:45,600 --> 00:14:47,600
which uses topholy gates

403
00:14:47,600 --> 00:14:48,800
the exciting feature of this

404
00:14:48,800 --> 00:14:50,800
countermeasure is that whenever you

405
00:14:50,800 --> 00:14:53,839
inject a fault within the xbox operation

406
00:14:53,839 --> 00:14:55,760
or outside of the xbox operation the

407
00:14:55,760 --> 00:14:59,040
fault mandatory propagates without

408
00:14:59,040 --> 00:15:00,959
but the tricky part is that

409
00:15:00,959 --> 00:15:02,880
the mandatory fault propagation is valid

410
00:15:02,880 --> 00:15:06,079
only for one output where here shown in

411
00:15:06,079 --> 00:15:07,120
rate

412
00:15:07,120 --> 00:15:09,040
but for rest of the wires the

413
00:15:09,040 --> 00:15:12,320
propagation is still ineffective

414
00:15:12,320 --> 00:15:14,720
so if we consider an error card error

415
00:15:14,720 --> 00:15:16,959
detection circuit at the end

416
00:15:16,959 --> 00:15:18,560
which is working

417
00:15:18,560 --> 00:15:20,480
on the shared values or which is working

418
00:15:20,480 --> 00:15:22,079
on the unshared value this still can

419
00:15:22,079 --> 00:15:24,880
leak some secret so considering the case

420
00:15:24,880 --> 00:15:26,320
that the error correction happening on

421
00:15:26,320 --> 00:15:27,519
shares

422
00:15:27,519 --> 00:15:29,199
we see that

423
00:15:29,199 --> 00:15:30,959
due to the dom based construction of

424
00:15:30,959 --> 00:15:33,600
this xbox this error detection logic on

425
00:15:33,600 --> 00:15:38,079
s0 still leaks information about a

426
00:15:38,079 --> 00:15:38,959
because

427
00:15:38,959 --> 00:15:41,440
it propagates through both a0 and a1

428
00:15:41,440 --> 00:15:43,360
simultaneously

429
00:15:43,360 --> 00:15:45,519
and that completely breaks this

430
00:15:45,519 --> 00:15:47,519
confirmation

431
00:15:47,519 --> 00:15:49,600
now if we consider error correction on

432
00:15:49,600 --> 00:15:51,519
stairs with the logic that we have

433
00:15:51,519 --> 00:15:53,920
previously discussed it still leaks the

434
00:15:53,920 --> 00:15:56,560
information now this kind of proposals

435
00:15:56,560 --> 00:15:58,880
are made in counter measures published

436
00:15:58,880 --> 00:16:01,759
in tips 2020 where they propose that

437
00:16:01,759 --> 00:16:03,680
masking and error correction on each

438
00:16:03,680 --> 00:16:05,759
share is good enough for super

439
00:16:05,759 --> 00:16:08,480
protection here we found that it might

440
00:16:08,480 --> 00:16:10,880
be true but not for every master's game

441
00:16:10,880 --> 00:16:12,399
especially if you have a dom based

442
00:16:12,399 --> 00:16:14,639
masking theme then

443
00:16:14,639 --> 00:16:17,360
you are not good

444
00:16:18,480 --> 00:16:21,199
now does this only applies to dom and

445
00:16:21,199 --> 00:16:22,880
isw variants

446
00:16:22,880 --> 00:16:24,880
no the answer is no

447
00:16:24,880 --> 00:16:27,279
so we see that for higher order ti the

448
00:16:27,279 --> 00:16:30,160
case still perceives so here the main

449
00:16:30,160 --> 00:16:32,639
problem is the shear compression step

450
00:16:32,639 --> 00:16:35,040
which is always applied to reduce the

451
00:16:35,040 --> 00:16:37,279
blow up in share count

452
00:16:37,279 --> 00:16:40,959
now due to shear compression

453
00:16:40,959 --> 00:16:42,959
we can still do the attack for example

454
00:16:42,959 --> 00:16:45,120
if you consider this simon s box which

455
00:16:45,120 --> 00:16:46,560
is second order seek here and if you

456
00:16:46,560 --> 00:16:48,959
inject a fault at a4 share

457
00:16:48,959 --> 00:16:51,120
and probe the error detection logic of

458
00:16:51,120 --> 00:16:52,639
e3 and e4

459
00:16:52,639 --> 00:16:54,959
we leak the information of b

460
00:16:54,959 --> 00:16:56,560
now this is a second order

461
00:16:56,560 --> 00:16:58,240
implementation and we are still doing a

462
00:16:58,240 --> 00:16:59,920
second order attack and the attack is

463
00:16:59,920 --> 00:17:02,160
efficient so it means that even for

464
00:17:02,160 --> 00:17:04,160
higher order ti we can apply our attack

465
00:17:04,160 --> 00:17:06,319
quite efficiently

466
00:17:06,319 --> 00:17:08,880
we practically validated this attack

467
00:17:08,880 --> 00:17:11,199
on an atmega board with an open source

468
00:17:11,199 --> 00:17:13,679
cipher protected k check implementation

469
00:17:13,679 --> 00:17:15,679
present in this link this is due to the

470
00:17:15,679 --> 00:17:17,760
topology based implementation

471
00:17:17,760 --> 00:17:20,079
we perform laser fault injection with h1

472
00:17:20,079 --> 00:17:22,480
diode laser and power measurement was

473
00:17:22,480 --> 00:17:24,240
done for sc

474
00:17:24,240 --> 00:17:25,839
we tested

475
00:17:25,839 --> 00:17:27,760
unshared and shared detection operation

476
00:17:27,760 --> 00:17:30,000
in this experiment so one interesting

477
00:17:30,000 --> 00:17:32,480
feature of this experiment is that or

478
00:17:32,480 --> 00:17:35,360
what you observed here is that

479
00:17:35,360 --> 00:17:38,080
we do not need to measure the laser

480
00:17:38,080 --> 00:17:40,000
injection and perform the laser

481
00:17:40,000 --> 00:17:41,520
injection and measure the side chain in

482
00:17:41,520 --> 00:17:43,600
the same clock cycle so for software

483
00:17:43,600 --> 00:17:45,840
implementations the injection point and

484
00:17:45,840 --> 00:17:47,520
the side channel measurement points are

485
00:17:47,520 --> 00:17:50,000
several clock cycle head

486
00:17:50,000 --> 00:17:52,080
so what's the advantage of that we do

487
00:17:52,080 --> 00:17:54,880
not need to face the noise due to laser

488
00:17:54,880 --> 00:17:56,960
injection on the side generation side

489
00:17:56,960 --> 00:17:59,039
generations are fairly clear

490
00:17:59,039 --> 00:18:02,320
and we see around 200 to 300

491
00:18:02,320 --> 00:18:04,799
operations in both of the cases we can

492
00:18:04,799 --> 00:18:07,360
recover each week so for each bit we

493
00:18:07,360 --> 00:18:09,120
need this many number of traces of fault

494
00:18:09,120 --> 00:18:10,160
injection

495
00:18:10,160 --> 00:18:12,480
but eventually we can recover the entire

496
00:18:12,480 --> 00:18:15,480
secret

497
00:18:15,520 --> 00:18:17,840
in another experiment we do a simulated

498
00:18:17,840 --> 00:18:20,160
evaluation on hardware setters but we're

499
00:18:20,160 --> 00:18:22,400
worth mentioning that

500
00:18:22,400 --> 00:18:24,080
the setup that we have discussed

501
00:18:24,080 --> 00:18:26,160
previously can also be tuned for

502
00:18:26,160 --> 00:18:27,120
hardware

503
00:18:27,120 --> 00:18:29,520
systems especially for some cases but in

504
00:18:29,520 --> 00:18:31,039
this experiment specifically we have

505
00:18:31,039 --> 00:18:32,880
simulated the faults on the power stress

506
00:18:32,880 --> 00:18:35,200
leakage but the main stress was given

507
00:18:35,200 --> 00:18:38,000
that whether with adjacent gate leakages

508
00:18:38,000 --> 00:18:39,919
can we still discover the side channel

509
00:18:39,919 --> 00:18:41,600
signal that we are looking for the

510
00:18:41,600 --> 00:18:43,919
answer is yes and we see that roughly

511
00:18:43,919 --> 00:18:45,919
with thousand traces considering all

512
00:18:45,919 --> 00:18:47,679
kind of noises that present inside

513
00:18:47,679 --> 00:18:50,960
channel we can still recover the secret

514
00:18:50,960 --> 00:18:53,280
beats

515
00:18:53,760 --> 00:18:57,520
now there are still some ray of hope

516
00:18:57,520 --> 00:18:59,360
we found that

517
00:18:59,360 --> 00:19:01,840
the counter measure instantiation that

518
00:19:01,840 --> 00:19:03,600
has been made in the masking plus error

519
00:19:03,600 --> 00:19:05,280
correction based

520
00:19:05,280 --> 00:19:07,679
proposal is still secure

521
00:19:07,679 --> 00:19:10,000
and here we see the non-completeness

522
00:19:10,000 --> 00:19:13,120
property of ti plays a crucial role

523
00:19:13,120 --> 00:19:15,280
so more precisely if we do error

524
00:19:15,280 --> 00:19:16,480
protection and correction over

525
00:19:16,480 --> 00:19:18,400
non-conflict paths

526
00:19:18,400 --> 00:19:20,320
then we can still maintain the security

527
00:19:20,320 --> 00:19:22,240
here is an example for

528
00:19:22,240 --> 00:19:24,400
first order ti are present we have just

529
00:19:24,400 --> 00:19:27,760
considered a part of the present xbox

530
00:19:27,760 --> 00:19:29,440
implementation

531
00:19:29,440 --> 00:19:32,400
now if we inject a fault here at x20 we

532
00:19:32,400 --> 00:19:35,520
can still recover x2

533
00:19:35,520 --> 00:19:37,679
but if we are doing error detection

534
00:19:37,679 --> 00:19:39,919
correction on shares then we have a

535
00:19:39,919 --> 00:19:40,880
problem

536
00:19:40,880 --> 00:19:42,559
because the error propagation always

537
00:19:42,559 --> 00:19:46,000
happens to f1 0 and f3 0

538
00:19:46,000 --> 00:19:48,320
so unless we do a second order attack we

539
00:19:48,320 --> 00:19:50,640
cannot combine the information we cannot

540
00:19:50,640 --> 00:19:53,120
extract x2 in this manner so given a

541
00:19:53,120 --> 00:19:54,720
fault and a first order site channel

542
00:19:54,720 --> 00:19:57,200
adversary which is that should be the

543
00:19:57,200 --> 00:19:59,120
case here because we are considering a

544
00:19:59,120 --> 00:20:01,600
faster search and secure implementation

545
00:20:01,600 --> 00:20:05,440
we are good we cannot do that job

546
00:20:05,440 --> 00:20:06,960
and

547
00:20:06,960 --> 00:20:09,280
in this line of work the uh other

548
00:20:09,280 --> 00:20:11,520
proposal which is pretty similar is

549
00:20:11,520 --> 00:20:14,080
called nina which also performs error

550
00:20:14,080 --> 00:20:15,280
correction

551
00:20:15,280 --> 00:20:16,720
on shares

552
00:20:16,720 --> 00:20:19,120
that is also found to be secure

553
00:20:19,120 --> 00:20:22,080
another class of words such as kappa is

554
00:20:22,080 --> 00:20:23,600
found to be secure against this

555
00:20:23,600 --> 00:20:26,720
combination of ki chat because

556
00:20:26,720 --> 00:20:28,400
it performs multi-party computation

557
00:20:28,400 --> 00:20:29,360
based

558
00:20:29,360 --> 00:20:31,600
masking and it is fairly different than

559
00:20:31,600 --> 00:20:33,200
any other boolean masking scheme that we

560
00:20:33,200 --> 00:20:35,120
are considering so far

561
00:20:35,120 --> 00:20:37,840
but we found that it is still secure

562
00:20:37,840 --> 00:20:39,760
so to conclude combined attacks are

563
00:20:39,760 --> 00:20:41,760
practical and should be considered for

564
00:20:41,760 --> 00:20:43,840
implementations having both fault attack

565
00:20:43,840 --> 00:20:46,240
and side genetic counter measures

566
00:20:46,240 --> 00:20:48,320
now we found that having both counter

567
00:20:48,320 --> 00:20:50,080
measure doesn't mean that you have

568
00:20:50,080 --> 00:20:51,679
security

569
00:20:51,679 --> 00:20:54,080
for a combined attack and we show a very

570
00:20:54,080 --> 00:20:56,559
important combined adversary

571
00:20:56,559 --> 00:20:58,240
for the scenario which is extremely

572
00:20:58,240 --> 00:21:00,799
powerful it's worth mentioning that

573
00:21:00,799 --> 00:21:02,640
just consider the countermeasure cases

574
00:21:02,640 --> 00:21:04,880
but a cfd might apply to other scenarios

575
00:21:04,880 --> 00:21:07,360
like for public implementations or

576
00:21:07,360 --> 00:21:08,960
other kind of implementations such as

577
00:21:08,960 --> 00:21:11,760
modes of operation

578
00:21:11,760 --> 00:21:15,440
surprisingly bricks cifa countermeasures

579
00:21:15,440 --> 00:21:17,360
and exposes certain critical properties

580
00:21:17,360 --> 00:21:19,200
of masking schemes which are implemented

581
00:21:19,200 --> 00:21:21,760
to develop fifa countermeasures as

582
00:21:21,760 --> 00:21:24,240
potential future work is we would like

583
00:21:24,240 --> 00:21:26,480
to analyze multi-party-based schemes

584
00:21:26,480 --> 00:21:28,960
like kappa and some other schemes

585
00:21:28,960 --> 00:21:31,280
because it's not yet clear whether how

586
00:21:31,280 --> 00:21:33,840
this attack applies to the schemes but

587
00:21:33,840 --> 00:21:36,159
there is no sign that it won't apply as

588
00:21:36,159 --> 00:21:37,120
well

589
00:21:37,120 --> 00:21:39,120
also finding lightweight countermeasure

590
00:21:39,120 --> 00:21:40,960
is an important research direction

591
00:21:40,960 --> 00:21:41,919
because

592
00:21:41,919 --> 00:21:43,679
so far what if whatever counter measures

593
00:21:43,679 --> 00:21:44,880
we have seen

594
00:21:44,880 --> 00:21:46,559
requires a lot of error detection or

595
00:21:46,559 --> 00:21:48,640
correction operation so if we can reduce

596
00:21:48,640 --> 00:21:52,000
that overhead that will be a real gain

597
00:21:52,000 --> 00:21:53,520
so with this message i would like to

598
00:21:53,520 --> 00:21:55,840
conclude my talk i'll be happy to answer

599
00:21:55,840 --> 00:21:57,360
your question

600
00:21:57,360 --> 00:21:59,840
thank you

