1
00:00:04,160 --> 00:00:06,960
welcome to our youtube video about tight

2
00:00:06,960 --> 00:00:08,800
adaptive reprogramming in the quantum

3
00:00:08,800 --> 00:00:10,639
random oracle model

4
00:00:10,639 --> 00:00:13,519
this is joint work with alex grillo

5
00:00:13,519 --> 00:00:16,640
and myself andreas suzing and christian

6
00:00:16,640 --> 00:00:19,199
marians

7
00:00:21,680 --> 00:00:23,840
so to say a few words about the quantum

8
00:00:23,840 --> 00:00:26,240
random oracle model

9
00:00:26,240 --> 00:00:28,320
i'd start with a random oracle model

10
00:00:28,320 --> 00:00:30,000
which is

11
00:00:30,000 --> 00:00:32,320
very popular because it allows for

12
00:00:32,320 --> 00:00:35,920
simple proofs of official constructions

13
00:00:35,920 --> 00:00:38,320
but it suffers from the drawback that it

14
00:00:38,320 --> 00:00:40,079
cannot take into account quantum

15
00:00:40,079 --> 00:00:42,000
attackers

16
00:00:42,000 --> 00:00:44,879
and this is why 10 years ago

17
00:00:44,879 --> 00:00:47,440
the random oracle model was generalized

18
00:00:47,440 --> 00:00:49,120
in such a way

19
00:00:49,120 --> 00:00:51,920
by allowing the random oracle to be

20
00:00:51,920 --> 00:00:53,280
accessible

21
00:00:53,280 --> 00:00:56,160
via superposition queries or ensured

22
00:00:56,160 --> 00:00:59,359
quantum accessible

23
00:00:59,359 --> 00:01:00,320
and

24
00:01:00,320 --> 00:01:01,920
a proof in the quantum random oracle

25
00:01:01,920 --> 00:01:04,400
model allows to argue security against

26
00:01:04,400 --> 00:01:06,080
quantum attacks

27
00:01:06,080 --> 00:01:09,280
that are run in classical networks

28
00:01:09,280 --> 00:01:11,600
meaning interacting with honest users

29
00:01:11,600 --> 00:01:14,960
that are still classical

30
00:01:17,759 --> 00:01:20,080
sorry

31
00:01:20,159 --> 00:01:22,960
why this is very neat because it allows

32
00:01:22,960 --> 00:01:26,080
to argue post quantum security it comes

33
00:01:26,080 --> 00:01:28,320
with its own challenges

34
00:01:28,320 --> 00:01:30,320
quantum access

35
00:01:30,320 --> 00:01:33,280
meaning superposition queries

36
00:01:33,280 --> 00:01:35,680
add proof complexity

37
00:01:35,680 --> 00:01:37,600
and

38
00:01:37,600 --> 00:01:40,000
very useful random oracle properties

39
00:01:40,000 --> 00:01:41,759
like programmability and pre-image

40
00:01:41,759 --> 00:01:44,320
awareness

41
00:01:44,320 --> 00:01:47,280
are not trivially known to

42
00:01:47,280 --> 00:01:50,000
generalize to this new scenario

43
00:01:50,000 --> 00:01:54,560
and the bounds we can derive by quantum

44
00:01:54,560 --> 00:01:57,600
random oracle arguments are usually less

45
00:01:57,600 --> 00:01:58,560
tight

46
00:01:58,560 --> 00:02:01,520
than their classical counterparts

47
00:02:01,520 --> 00:02:04,159
and now we'll zoom in into one of those

48
00:02:04,159 --> 00:02:06,320
properties i just mentioned namely

49
00:02:06,320 --> 00:02:09,320
programmability

50
00:02:10,720 --> 00:02:13,040
so now to say a few words about adaptive

51
00:02:13,040 --> 00:02:14,959
reprogramming in the quantum menu oracle

52
00:02:14,959 --> 00:02:15,840
model

53
00:02:15,840 --> 00:02:18,319
in the classical random oracle model

54
00:02:18,319 --> 00:02:20,800
things are very easy we can say

55
00:02:20,800 --> 00:02:23,440
if the random oracle has not been

56
00:02:23,440 --> 00:02:27,280
queried yet on a particular pre-image x

57
00:02:27,280 --> 00:02:28,560
then

58
00:02:28,560 --> 00:02:31,840
the attacker has no knowledge of the

59
00:02:31,840 --> 00:02:34,080
value of this position

60
00:02:34,080 --> 00:02:36,560
and we can choose it on the fly

61
00:02:36,560 --> 00:02:38,560
and this in particular means that

62
00:02:38,560 --> 00:02:39,760
reduction

63
00:02:39,760 --> 00:02:42,000
could um

64
00:02:42,000 --> 00:02:43,200
pick it

65
00:02:43,200 --> 00:02:45,599
in a way that's helpful to the reduction

66
00:02:45,599 --> 00:02:46,480
to

67
00:02:46,480 --> 00:02:48,560
simulate a particular security game

68
00:02:48,560 --> 00:02:51,040
without any secret knowledge like for

69
00:02:51,040 --> 00:02:54,080
example a secret key

70
00:02:54,080 --> 00:02:55,760
it only has to

71
00:02:55,760 --> 00:02:58,640
make sure that the value is uniform and

72
00:02:58,640 --> 00:03:00,560
consistent with the rest of the view of

73
00:03:00,560 --> 00:03:02,319
the attacker

74
00:03:02,319 --> 00:03:04,239
unfortunately in the quantum random

75
00:03:04,239 --> 00:03:08,159
oracle model things are not as easy

76
00:03:10,480 --> 00:03:12,400
if we allow the attacker to post

77
00:03:12,400 --> 00:03:14,800
superposition queries then in principle

78
00:03:14,800 --> 00:03:17,599
any query could already have contained x

79
00:03:17,599 --> 00:03:19,840
with some amplitude

80
00:03:19,840 --> 00:03:20,640
and

81
00:03:20,640 --> 00:03:22,640
checking whether

82
00:03:22,640 --> 00:03:24,319
this was the case

83
00:03:24,319 --> 00:03:27,599
would have meant measuring the query

84
00:03:27,599 --> 00:03:28,879
meaning

85
00:03:28,879 --> 00:03:31,840
altering the state and hence potentially

86
00:03:31,840 --> 00:03:34,480
disturbing the attacker so

87
00:03:34,480 --> 00:03:36,640
an interesting question is can we

88
00:03:36,640 --> 00:03:39,040
adaptively reprogram the quantum random

89
00:03:39,040 --> 00:03:40,480
oracle model

90
00:03:40,480 --> 00:03:42,400
and i'll mention right away that there

91
00:03:42,400 --> 00:03:44,959
has been previous work on this question

92
00:03:44,959 --> 00:03:47,360
which will be discussed after

93
00:03:47,360 --> 00:03:50,000
we have presented our findings

94
00:03:50,000 --> 00:03:51,360
to make stuff

95
00:03:51,360 --> 00:03:54,159
more comparable

96
00:03:54,159 --> 00:03:56,319
so for the rest of the talk

97
00:03:56,319 --> 00:03:57,840
i will first

98
00:03:57,840 --> 00:03:59,920
describe a motivational use case to

99
00:03:59,920 --> 00:04:01,599
convince you that this is actually a

100
00:04:01,599 --> 00:04:04,480
question that's worth tackling

101
00:04:04,480 --> 00:04:06,159
and afterwards

102
00:04:06,159 --> 00:04:09,040
i present to you our results and

103
00:04:09,040 --> 00:04:11,040
show how these can be

104
00:04:11,040 --> 00:04:14,879
applied to the motivational use case

105
00:04:14,879 --> 00:04:16,160
after that

106
00:04:16,160 --> 00:04:17,680
chris will

107
00:04:17,680 --> 00:04:20,399
um sketch to you the proof technique

108
00:04:20,399 --> 00:04:21,918
that we used

109
00:04:21,918 --> 00:04:23,040
and we'll

110
00:04:23,040 --> 00:04:25,360
finally show you that

111
00:04:25,360 --> 00:04:27,680
there's reason to believe that the bound

112
00:04:27,680 --> 00:04:30,000
we derive is tight because we found a

113
00:04:30,000 --> 00:04:32,400
matching attack

114
00:04:32,400 --> 00:04:35,360
but now let's first go to the motivating

115
00:04:35,360 --> 00:04:37,919
example the use case in the classical

116
00:04:37,919 --> 00:04:39,759
random oracle model

117
00:04:39,759 --> 00:04:40,800
and

118
00:04:40,800 --> 00:04:42,960
we decided to discuss fiat premiere

119
00:04:42,960 --> 00:04:45,680
signatures

120
00:04:46,240 --> 00:04:47,759
so this is

121
00:04:47,759 --> 00:04:51,120
a vietnamese signature scheme built from

122
00:04:51,120 --> 00:04:52,080
an

123
00:04:52,080 --> 00:04:54,240
identification scheme and a hash

124
00:04:54,240 --> 00:04:56,000
function that will be modeled as a

125
00:04:56,000 --> 00:04:58,800
random oracle

126
00:04:59,199 --> 00:05:00,240
to

127
00:05:00,240 --> 00:05:01,919
generate keys we'll just use the key

128
00:05:01,919 --> 00:05:03,440
generation algorithm of the

129
00:05:03,440 --> 00:05:05,520
identification scheme

130
00:05:05,520 --> 00:05:07,360
and to sign a message

131
00:05:07,360 --> 00:05:09,600
we'll first use the commit algorithm of

132
00:05:09,600 --> 00:05:11,680
the identification scheme to derive a

133
00:05:11,680 --> 00:05:14,000
commitment and a state

134
00:05:14,000 --> 00:05:16,880
and then the respond algorithm

135
00:05:16,880 --> 00:05:19,280
to define a response

136
00:05:19,280 --> 00:05:23,039
and what's important is to notice that

137
00:05:23,039 --> 00:05:25,360
the challenge we will forward

138
00:05:25,360 --> 00:05:27,520
to the respond algorithm will be the

139
00:05:27,520 --> 00:05:30,240
hash value of the commitment we picked

140
00:05:30,240 --> 00:05:32,000
and the message

141
00:05:32,000 --> 00:05:33,680
and the signature then

142
00:05:33,680 --> 00:05:35,520
consists of the commitment and the

143
00:05:35,520 --> 00:05:37,199
response

144
00:05:37,199 --> 00:05:40,160
to verify a message and a signature

145
00:05:40,160 --> 00:05:41,840
we'll use the

146
00:05:41,840 --> 00:05:43,680
verification algorithm of the

147
00:05:43,680 --> 00:05:45,919
identification scheme

148
00:05:45,919 --> 00:05:48,960
again relative to the challenge that is

149
00:05:48,960 --> 00:05:50,960
the hash value of the commitment and the

150
00:05:50,960 --> 00:05:53,840
message

151
00:05:55,280 --> 00:05:57,919
and an important proof step to argue

152
00:05:57,919 --> 00:06:00,479
that fierce amir is unforgivable even if

153
00:06:00,479 --> 00:06:02,319
an attacker has access to a signing

154
00:06:02,319 --> 00:06:03,360
oracle

155
00:06:03,360 --> 00:06:06,240
is to get rid of the signing oracle by

156
00:06:06,240 --> 00:06:08,319
arguing that if the identification

157
00:06:08,319 --> 00:06:10,560
scheme is spanish verifier zero

158
00:06:10,560 --> 00:06:13,280
knowledge meaning that identification

159
00:06:13,280 --> 00:06:14,960
transcripts can be simulated by a

160
00:06:14,960 --> 00:06:16,720
simulator that only has access to the

161
00:06:16,720 --> 00:06:19,120
public key

162
00:06:19,120 --> 00:06:21,680
then in the random oracle model it holds

163
00:06:21,680 --> 00:06:24,000
that the signing algorithm

164
00:06:24,000 --> 00:06:26,960
can be simulated by a simulator that

165
00:06:26,960 --> 00:06:30,719
also does without the secret key

166
00:06:32,319 --> 00:06:34,880
and the proof of the step goes as

167
00:06:34,880 --> 00:06:37,199
follows again we want to show that if

168
00:06:37,199 --> 00:06:38,960
the identification scheme is under

169
00:06:38,960 --> 00:06:41,520
verifier zero knowledge then

170
00:06:41,520 --> 00:06:43,600
the signing algorithm can be simulated

171
00:06:43,600 --> 00:06:45,680
without the secret key

172
00:06:45,680 --> 00:06:47,199
the idea is

173
00:06:47,199 --> 00:06:49,199
to simulate a signature

174
00:06:49,199 --> 00:06:52,160
using the honest verifier zero knowledge

175
00:06:52,160 --> 00:06:53,520
simulator

176
00:06:53,520 --> 00:06:54,290
by

177
00:06:54,290 --> 00:06:56,080
[Music]

178
00:06:56,080 --> 00:06:57,039
picking

179
00:06:57,039 --> 00:06:59,360
a simulated transcript

180
00:06:59,360 --> 00:07:01,680
and letting the signature be the

181
00:07:01,680 --> 00:07:03,680
commitment and the response that was

182
00:07:03,680 --> 00:07:06,319
part of this transcript

183
00:07:06,319 --> 00:07:07,680
but of course this wouldn't be

184
00:07:07,680 --> 00:07:10,160
consistent with the attacker's view

185
00:07:10,160 --> 00:07:12,160
because the attacker would

186
00:07:12,160 --> 00:07:14,160
would expect that the challenge is the

187
00:07:14,160 --> 00:07:16,560
random oracle value so what we do is

188
00:07:16,560 --> 00:07:18,560
that we program the random oracle

189
00:07:18,560 --> 00:07:20,400
aposteriori

190
00:07:20,400 --> 00:07:23,599
by setting it to challenge on

191
00:07:23,599 --> 00:07:27,280
the commitment and the message

192
00:07:28,639 --> 00:07:31,759
and um this simulation works unless this

193
00:07:31,759 --> 00:07:33,599
particular random oracle value has

194
00:07:33,599 --> 00:07:35,520
already been queried because then the

195
00:07:35,520 --> 00:07:36,960
attacker would

196
00:07:36,960 --> 00:07:40,800
notice that we reprogrammed it

197
00:07:40,800 --> 00:07:43,280
but this is pretty unlikely uh given

198
00:07:43,280 --> 00:07:45,520
that the commitment has high enough

199
00:07:45,520 --> 00:07:48,319
entropy because the probability of this

200
00:07:48,319 --> 00:07:50,879
happening can be upper bounded in terms

201
00:07:50,879 --> 00:07:53,280
of the number of random oracle queries

202
00:07:53,280 --> 00:07:55,919
and the probability of this commitment

203
00:07:55,919 --> 00:07:57,280
happening

204
00:07:57,280 --> 00:08:00,878
this is once per signature

205
00:08:01,199 --> 00:08:03,280
so all in all in total the

206
00:08:03,280 --> 00:08:05,759
distinguishing advantage between proper

207
00:08:05,759 --> 00:08:09,840
signatures and this simulated signature

208
00:08:09,840 --> 00:08:12,800
these simulated signatures

209
00:08:12,800 --> 00:08:14,720
can be upper bounded in terms of the

210
00:08:14,720 --> 00:08:17,599
advantage against our honest verifier

211
00:08:17,599 --> 00:08:19,360
zero knowledge for

212
00:08:19,360 --> 00:08:22,080
a q as many

213
00:08:22,080 --> 00:08:24,240
transcripts where qs is the number of

214
00:08:24,240 --> 00:08:27,440
signing queries plus number of sign-in

215
00:08:27,440 --> 00:08:29,120
queries times

216
00:08:29,120 --> 00:08:31,840
number of oracle queries times maximum

217
00:08:31,840 --> 00:08:35,760
probability of the commitments

218
00:08:37,120 --> 00:08:38,000
okay

219
00:08:38,000 --> 00:08:41,440
what did we just see we saw that we can

220
00:08:41,440 --> 00:08:44,159
pretty much simplify security proofs for

221
00:08:44,159 --> 00:08:46,240
fiat chamier

222
00:08:46,240 --> 00:08:49,279
in the random oracle model and we used

223
00:08:49,279 --> 00:08:50,399
that

224
00:08:50,399 --> 00:08:52,720
reprogramming is triggered by queries to

225
00:08:52,720 --> 00:08:55,040
the shining oracle

226
00:08:55,040 --> 00:08:57,200
and

227
00:08:57,200 --> 00:09:00,959
what we want to take away here is that

228
00:09:00,959 --> 00:09:03,760
oracle's like signing oracles or

229
00:09:03,760 --> 00:09:06,640
decryption oracles meaning all oracles

230
00:09:06,640 --> 00:09:08,399
that

231
00:09:08,399 --> 00:09:11,200
represent honest users in the security

232
00:09:11,200 --> 00:09:13,519
game will remain classical even if we

233
00:09:13,519 --> 00:09:17,440
want to prove post-quantum security

234
00:09:17,440 --> 00:09:19,920
so reprogramming was triggered by a

235
00:09:19,920 --> 00:09:24,000
classical query and we use that it's

236
00:09:24,000 --> 00:09:27,279
unlikely to query

237
00:09:27,279 --> 00:09:29,680
the particular reprogramming position

238
00:09:29,680 --> 00:09:32,720
before the reprogramming happens

239
00:09:32,720 --> 00:09:35,200
and now we want to take a look

240
00:09:35,200 --> 00:09:38,080
at what happens quantumly

241
00:09:38,080 --> 00:09:42,880
and there it's not even so clear what to

242
00:09:42,880 --> 00:09:45,519
what it means that this particular

243
00:09:45,519 --> 00:09:46,640
position

244
00:09:46,640 --> 00:09:49,600
was not queried before the reprogramming

245
00:09:49,600 --> 00:09:52,480
and we also have to consider that we

246
00:09:52,480 --> 00:09:54,240
cannot simply check

247
00:09:54,240 --> 00:09:55,200
whether

248
00:09:55,200 --> 00:09:57,200
the oracle was queried on a particular

249
00:09:57,200 --> 00:09:59,519
position or not because then

250
00:09:59,519 --> 00:10:00,320
it

251
00:10:00,320 --> 00:10:02,000
might happen that we disturbed the

252
00:10:02,000 --> 00:10:04,240
attacker

253
00:10:04,240 --> 00:10:08,079
now we'll move on to the results

254
00:10:11,040 --> 00:10:12,160
and

255
00:10:12,160 --> 00:10:15,040
our results are a reprogramming toolbox

256
00:10:15,040 --> 00:10:17,360
and first i present to you the simplest

257
00:10:17,360 --> 00:10:21,519
case just to get you into it

258
00:10:21,519 --> 00:10:23,120
and

259
00:10:23,120 --> 00:10:24,320
we

260
00:10:24,320 --> 00:10:26,800
consider distinguishes that have a

261
00:10:26,800 --> 00:10:29,040
particular task namely the task to

262
00:10:29,040 --> 00:10:31,600
distinguish between access to a plain

263
00:10:31,600 --> 00:10:33,120
random oracle

264
00:10:33,120 --> 00:10:36,880
and its adaptively reprogrammed

265
00:10:36,880 --> 00:10:41,279
counterpart which we call h1

266
00:10:41,279 --> 00:10:43,040
so at the beginning of the game a

267
00:10:43,040 --> 00:10:45,519
started with access to the original

268
00:10:45,519 --> 00:10:47,360
random oracle

269
00:10:47,360 --> 00:10:50,240
and the random article is defined

270
00:10:50,240 --> 00:10:52,800
on the product of

271
00:10:52,800 --> 00:10:58,079
a finite side x1 and a finite set x2

272
00:10:58,079 --> 00:11:00,880
just imagine that we have some

273
00:11:00,880 --> 00:11:04,959
bit string of length 2l and x1 is the

274
00:11:04,959 --> 00:11:07,839
bit strings of length l and x2 is the

275
00:11:07,839 --> 00:11:10,560
second half

276
00:11:10,880 --> 00:11:12,399
and

277
00:11:12,399 --> 00:11:15,760
after having queried the original oracle

278
00:11:15,760 --> 00:11:17,120
for some time

279
00:11:17,120 --> 00:11:20,240
a will pick its own position x1 which

280
00:11:20,240 --> 00:11:23,200
marks the first half of the position

281
00:11:23,200 --> 00:11:25,920
and the game completes this position

282
00:11:25,920 --> 00:11:28,160
to a complete reprogramming position by

283
00:11:28,160 --> 00:11:29,839
uniformly picking

284
00:11:29,839 --> 00:11:30,959
x2

285
00:11:30,959 --> 00:11:33,839
from the second set

286
00:11:33,839 --> 00:11:35,760
and now we'll define

287
00:11:35,760 --> 00:11:39,040
h1 as h0 but reprogrammed on this

288
00:11:39,040 --> 00:11:40,640
position

289
00:11:40,640 --> 00:11:43,760
meaning we let h1 coincide with h0

290
00:11:43,760 --> 00:11:46,399
anywhere but on this particular position

291
00:11:46,399 --> 00:11:48,240
and on this position

292
00:11:48,240 --> 00:11:51,680
we'll just define it to be a new freshly

293
00:11:51,680 --> 00:11:53,360
uniformly random

294
00:11:53,360 --> 00:11:55,360
value

295
00:11:55,360 --> 00:11:57,279
and

296
00:11:57,279 --> 00:12:00,079
the second half of the pre-programming

297
00:12:00,079 --> 00:12:03,519
position will forward to a

298
00:12:03,519 --> 00:12:04,320
and

299
00:12:04,320 --> 00:12:07,360
then continue a with access to

300
00:12:07,360 --> 00:12:12,480
either h0 or h1 and the task of h

301
00:12:12,480 --> 00:12:14,000
the task of a

302
00:12:14,000 --> 00:12:18,800
is to tell to which oracle it has access

303
00:12:21,040 --> 00:12:23,920
so if we were in a classical world

304
00:12:23,920 --> 00:12:26,000
things would be pretty easy then the

305
00:12:26,000 --> 00:12:28,240
distinguishing advantage would be

306
00:12:28,240 --> 00:12:31,040
upper bounded in terms of the number of

307
00:12:31,040 --> 00:12:33,839
oracle queries and the size of x2

308
00:12:33,839 --> 00:12:36,320
because the reprogramming

309
00:12:36,320 --> 00:12:37,360
part

310
00:12:37,360 --> 00:12:39,600
that wasn't under the control of a

311
00:12:39,600 --> 00:12:40,959
cannot be

312
00:12:40,959 --> 00:12:44,160
foreseen by a meaning it will only have

313
00:12:44,160 --> 00:12:46,320
queried the oracle

314
00:12:46,320 --> 00:12:50,480
with this probability on this position

315
00:12:50,480 --> 00:12:51,920
and

316
00:12:51,920 --> 00:12:54,480
first nice result is that quantumly

317
00:12:54,480 --> 00:12:57,760
things don't look too different

318
00:12:57,760 --> 00:12:59,920
so all we have to do is to add a square

319
00:12:59,920 --> 00:13:01,360
root

320
00:13:01,360 --> 00:13:04,160
and to multiply by a factor of one and a

321
00:13:04,160 --> 00:13:06,639
half

322
00:13:06,639 --> 00:13:08,800
so this is

323
00:13:08,800 --> 00:13:10,160
kind of nice

324
00:13:10,160 --> 00:13:13,360
but it's not really very general because

325
00:13:13,360 --> 00:13:14,480
um

326
00:13:14,480 --> 00:13:16,800
with this argument we wouldn't be able

327
00:13:16,800 --> 00:13:19,760
to for example argue security of here

328
00:13:19,760 --> 00:13:21,120
jamie

329
00:13:21,120 --> 00:13:23,279
so what we did was to generalize this

330
00:13:23,279 --> 00:13:26,320
result a bit and um

331
00:13:26,320 --> 00:13:28,720
i'll show you on the next slide how we

332
00:13:28,720 --> 00:13:31,120
generalized it but before that let me

333
00:13:31,120 --> 00:13:34,240
state that this bound is actually tight

334
00:13:34,240 --> 00:13:36,079
because we found a matching attack and

335
00:13:36,079 --> 00:13:37,760
this will be the last section of the

336
00:13:37,760 --> 00:13:39,600
talk

337
00:13:39,600 --> 00:13:43,880
and now on to the generalizations

338
00:13:44,480 --> 00:13:46,560
so here we see the bound for the simple

339
00:13:46,560 --> 00:13:50,240
case we have just considered before

340
00:13:50,240 --> 00:13:52,240
now our first important generalization

341
00:13:52,240 --> 00:13:54,560
is to reprogram many times because we

342
00:13:54,560 --> 00:13:57,199
don't just want to reprogram once

343
00:13:57,199 --> 00:13:59,199
but for example

344
00:13:59,199 --> 00:14:02,399
as often as an attacker might issue

345
00:14:02,399 --> 00:14:04,639
signing queries

346
00:14:04,639 --> 00:14:08,160
so if we want to reprogram r many times

347
00:14:08,160 --> 00:14:10,320
this bound has trivially to be

348
00:14:10,320 --> 00:14:12,639
multiplied by r because we can just give

349
00:14:12,639 --> 00:14:14,800
a

350
00:14:14,839 --> 00:14:17,920
hybrid another another more important

351
00:14:17,920 --> 00:14:21,279
generalization is that we now

352
00:14:21,279 --> 00:14:23,680
let a pick the whole reprogramming

353
00:14:23,680 --> 00:14:25,040
position

354
00:14:25,040 --> 00:14:27,600
instead of just the first half

355
00:14:27,600 --> 00:14:29,120
and

356
00:14:29,120 --> 00:14:31,360
a is even allowed to

357
00:14:31,360 --> 00:14:33,680
pick distributions according to which

358
00:14:33,680 --> 00:14:36,959
those reprogramming positions are picked

359
00:14:36,959 --> 00:14:39,920
adaptively so it might completely change

360
00:14:39,920 --> 00:14:44,480
distributions depending on its input

361
00:14:44,480 --> 00:14:45,279
and

362
00:14:45,279 --> 00:14:47,680
the resulting bound

363
00:14:47,680 --> 00:14:50,079
is in spirit very similar to what we've

364
00:14:50,079 --> 00:14:53,130
seen before we just have to

365
00:14:53,130 --> 00:14:54,560
[Music]

366
00:14:54,560 --> 00:14:55,839
replace

367
00:14:55,839 --> 00:14:58,399
the term relative to the size of

368
00:14:58,399 --> 00:15:00,480
the second half

369
00:15:00,480 --> 00:15:01,519
with the

370
00:15:01,519 --> 00:15:04,160
maximal probability of any element to be

371
00:15:04,160 --> 00:15:05,120
drawn

372
00:15:05,120 --> 00:15:08,399
from any of those distributions

373
00:15:08,399 --> 00:15:10,880
and the last generalization

374
00:15:10,880 --> 00:15:12,639
is

375
00:15:12,639 --> 00:15:15,519
a scenario in which these distributions

376
00:15:15,519 --> 00:15:16,959
also generate some additional

377
00:15:16,959 --> 00:15:19,680
information x prime which will also be

378
00:15:19,680 --> 00:15:21,760
forwarded to a not only the

379
00:15:21,760 --> 00:15:24,160
reprogramming position but also the site

380
00:15:24,160 --> 00:15:26,880
information will be forwarded to a

381
00:15:26,880 --> 00:15:30,560
and this doesn't change the bound

382
00:15:33,440 --> 00:15:36,240
so now i can compare our results with

383
00:15:36,240 --> 00:15:40,440
what was previously known

384
00:15:40,560 --> 00:15:41,759
there has been

385
00:15:41,759 --> 00:15:44,399
some work before on this question

386
00:15:44,399 --> 00:15:46,399
or resulting in essentially the same

387
00:15:46,399 --> 00:15:48,720
bound

388
00:15:49,680 --> 00:15:50,560
but

389
00:15:50,560 --> 00:15:52,560
none of these results considered

390
00:15:52,560 --> 00:15:55,199
arbitrary distributions that might be

391
00:15:55,199 --> 00:15:56,480
adaptively

392
00:15:56,480 --> 00:15:58,800
picked they just considered the uniform

393
00:15:58,800 --> 00:16:00,560
distribution

394
00:16:00,560 --> 00:16:03,120
and they also didn't consider site

395
00:16:03,120 --> 00:16:05,120
information that is forwarded to the

396
00:16:05,120 --> 00:16:08,120
attacker

397
00:16:10,079 --> 00:16:13,040
yes and all those bounds are for just

398
00:16:13,040 --> 00:16:14,880
one reprogramming incident and all

399
00:16:14,880 --> 00:16:17,120
bounds all results have in common that

400
00:16:17,120 --> 00:16:19,040
if you want to reprogram r many times

401
00:16:19,040 --> 00:16:23,839
you have to multiply the bound by r

402
00:16:25,920 --> 00:16:28,399
okay now i want to show you how we can

403
00:16:28,399 --> 00:16:31,199
use this result um

404
00:16:31,199 --> 00:16:34,839
to prove that viatra mere

405
00:16:34,839 --> 00:16:37,839
signatures can be simulated

406
00:16:37,839 --> 00:16:41,839
without the attacker noticing too much

407
00:16:41,839 --> 00:16:43,600
and the goal

408
00:16:43,600 --> 00:16:44,399
of

409
00:16:44,399 --> 00:16:46,240
our approach is to use the same

410
00:16:46,240 --> 00:16:48,079
simulation that we have seen in the

411
00:16:48,079 --> 00:16:51,519
classical scenario

412
00:16:51,519 --> 00:16:54,160
so here we see honest signatures

413
00:16:54,160 --> 00:16:58,480
as defined by the fiat mere transform

414
00:16:58,480 --> 00:17:03,199
and before we move to simulating

415
00:17:03,199 --> 00:17:06,160
by um honest verifiers your knowledge

416
00:17:06,160 --> 00:17:07,439
transcripts

417
00:17:07,439 --> 00:17:11,199
we'll do an intermediate simulation

418
00:17:11,199 --> 00:17:12,480
that is pretty

419
00:17:12,480 --> 00:17:15,679
straightforward we remove this step we

420
00:17:15,679 --> 00:17:17,439
will not define the challenge to be the

421
00:17:17,439 --> 00:17:19,199
random oracle value of the commitment

422
00:17:19,199 --> 00:17:22,400
and the message anymore instead we

423
00:17:22,400 --> 00:17:25,760
choose it uniformly at random and then

424
00:17:25,760 --> 00:17:30,640
reprogram the random article accordingly

425
00:17:31,520 --> 00:17:34,000
and due to our theorems

426
00:17:34,000 --> 00:17:37,200
we now know that this is essentially a

427
00:17:37,200 --> 00:17:39,919
noticeable

428
00:17:40,160 --> 00:17:41,440
if the

429
00:17:41,440 --> 00:17:44,720
commitment scheme has sufficiently

430
00:17:44,720 --> 00:17:47,840
high entropy

431
00:17:48,559 --> 00:17:50,240
and

432
00:17:50,240 --> 00:17:53,200
from this intermediate simulation

433
00:17:53,200 --> 00:17:55,280
we can now go forward

434
00:17:55,280 --> 00:17:58,000
to the desired simulation where we

435
00:17:58,000 --> 00:18:01,840
simply draw a simulated transcript and

436
00:18:01,840 --> 00:18:06,320
program the random oracle accordingly

437
00:18:06,720 --> 00:18:09,039
and this is justifiable via a

438
00:18:09,039 --> 00:18:11,440
straightforward honest verifier zero

439
00:18:11,440 --> 00:18:14,919
knowledge argument

440
00:18:15,360 --> 00:18:16,480
okay

441
00:18:16,480 --> 00:18:17,919
and um

442
00:18:17,919 --> 00:18:20,080
as we can see

443
00:18:20,080 --> 00:18:22,080
the um proof

444
00:18:22,080 --> 00:18:24,480
for this uh this proof step for fiat

445
00:18:24,480 --> 00:18:27,360
mirror was as

446
00:18:27,360 --> 00:18:29,360
simple and straightforward as in the

447
00:18:29,360 --> 00:18:32,559
random oracle model

448
00:18:34,960 --> 00:18:36,000
and

449
00:18:36,000 --> 00:18:37,679
yeah our work

450
00:18:37,679 --> 00:18:39,600
again

451
00:18:39,600 --> 00:18:41,280
contains

452
00:18:41,280 --> 00:18:44,000
this this proof of uh signatures that is

453
00:18:44,000 --> 00:18:46,559
conceptually simple and also

454
00:18:46,559 --> 00:18:48,559
tighter than the ones that were

455
00:18:48,559 --> 00:18:50,720
previously known

456
00:18:50,720 --> 00:18:54,000
it also contains a tighter result for

457
00:18:54,000 --> 00:18:58,000
xmss because we give a title proof for

458
00:18:58,000 --> 00:18:59,440
hash and sign and the message

459
00:18:59,440 --> 00:19:02,720
compression routine of xmlss

460
00:19:02,720 --> 00:19:05,750
and what we also did was to

461
00:19:05,750 --> 00:19:07,600
[Music]

462
00:19:07,600 --> 00:19:11,440
take a look at work that considered how

463
00:19:11,440 --> 00:19:13,919
to hatch via samir against real-world

464
00:19:13,919 --> 00:19:15,600
attacks where

465
00:19:15,600 --> 00:19:18,400
hardware malfunctions are induced to

466
00:19:18,400 --> 00:19:21,120
derail the algorithms

467
00:19:21,120 --> 00:19:21,870
and

468
00:19:21,870 --> 00:19:23,200
[Music]

469
00:19:23,200 --> 00:19:27,280
to show how the work generalized to the

470
00:19:27,280 --> 00:19:29,360
quantum random oracle model meaning that

471
00:19:29,360 --> 00:19:30,320
even

472
00:19:30,320 --> 00:19:32,799
uh quantum attackers

473
00:19:32,799 --> 00:19:35,200
will not have too much success by

474
00:19:35,200 --> 00:19:37,520
inducing fault injection when attacking

475
00:19:37,520 --> 00:19:41,200
the hedgefield shamir transform

476
00:19:42,559 --> 00:19:45,039
okay and with this i say bye and let

477
00:19:45,039 --> 00:19:49,039
chris talk about our proof technique

478
00:19:50,400 --> 00:19:52,400
hello my name is christian mayans and in

479
00:19:52,400 --> 00:19:54,320
this last part of the talk i will um

480
00:19:54,320 --> 00:19:55,760
give you a little bit of an idea about

481
00:19:55,760 --> 00:19:57,840
our proof technique and we'll present

482
00:19:57,840 --> 00:20:00,559
the matching attack that

483
00:20:00,559 --> 00:20:02,640
shows that our reprogramming lemma is

484
00:20:02,640 --> 00:20:04,960
tight

485
00:20:05,520 --> 00:20:08,240
and we begin with a little sketch of the

486
00:20:08,240 --> 00:20:10,480
rom proof so in the rest of the talk we

487
00:20:10,480 --> 00:20:12,240
will for simplicity leave out this

488
00:20:12,240 --> 00:20:15,200
adversary chosen part of the input

489
00:20:15,200 --> 00:20:17,679
um also um

490
00:20:17,679 --> 00:20:19,280
let's take the input and the output of

491
00:20:19,280 --> 00:20:21,280
the hash function to be equal to the end

492
00:20:21,280 --> 00:20:23,679
of strings just for simplicity so here

493
00:20:23,679 --> 00:20:25,600
is again the game that the adversary is

494
00:20:25,600 --> 00:20:27,679
playing um the first stage of the

495
00:20:27,679 --> 00:20:29,200
address ray gets to interact with the

496
00:20:29,200 --> 00:20:30,799
random oracle h

497
00:20:30,799 --> 00:20:32,159
then

498
00:20:32,159 --> 00:20:34,720
the random oracle h is reprogrammed at

499
00:20:34,720 --> 00:20:37,039
some random input x star

500
00:20:37,039 --> 00:20:39,520
to the random output y y star or not

501
00:20:39,520 --> 00:20:41,840
depending on the bit b and

502
00:20:41,840 --> 00:20:44,960
finally um the address a gets to

503
00:20:44,960 --> 00:20:47,039
interact with the possibly reprogrammed

504
00:20:47,039 --> 00:20:49,120
oracle again to come up with the guess b

505
00:20:49,120 --> 00:20:51,200
prime for the big b

506
00:20:51,200 --> 00:20:53,600
now the distinguishing advantage of such

507
00:20:53,600 --> 00:20:55,600
an adversary that has classical access

508
00:20:55,600 --> 00:20:56,559
to h

509
00:20:56,559 --> 00:20:59,200
um is upper bounded by the number of

510
00:20:59,200 --> 00:21:01,679
queries in the first phase divided by

511
00:21:01,679 --> 00:21:03,120
two to the n

512
00:21:03,120 --> 00:21:05,600
this is um fairly straightforward so

513
00:21:05,600 --> 00:21:07,280
here's the intuition

514
00:21:07,280 --> 00:21:09,440
um basically the adversary needs to

515
00:21:09,440 --> 00:21:12,159
resort to guessing b unless

516
00:21:12,159 --> 00:21:15,600
they have uh queried x-star in the first

517
00:21:15,600 --> 00:21:17,760
phase

518
00:21:17,760 --> 00:21:19,760
and therefore we can bound the uh the

519
00:21:19,760 --> 00:21:22,320
advantage by

520
00:21:22,320 --> 00:21:24,320
the expectation over the choice of

521
00:21:24,320 --> 00:21:25,360
x-star

522
00:21:25,360 --> 00:21:27,360
of the probability that x-star has been

523
00:21:27,360 --> 00:21:28,880
great in the learning phase this is a

524
00:21:28,880 --> 00:21:31,440
bit of a roundabout way to express

525
00:21:31,440 --> 00:21:33,360
this upper bound but um it will be

526
00:21:33,360 --> 00:21:36,080
helpful for the quantum proof and this

527
00:21:36,080 --> 00:21:38,000
is more or less obviously bounded body

528
00:21:38,000 --> 00:21:41,679
by the number of queries by 2pm

529
00:21:42,640 --> 00:21:43,760
now uh

530
00:21:43,760 --> 00:21:46,080
in the quantum random article model

531
00:21:46,080 --> 00:21:49,039
version of this uh this lemma we use um

532
00:21:49,039 --> 00:21:51,200
the superposition oracle technique so i

533
00:21:51,200 --> 00:21:52,080
want to

534
00:21:52,080 --> 00:21:54,080
briefly explain what the supreme

535
00:21:54,080 --> 00:21:56,240
position oracle technique is

536
00:21:56,240 --> 00:21:58,880
essentially the superposition oracle is

537
00:21:58,880 --> 00:22:00,720
something like a quantum function table

538
00:22:00,720 --> 00:22:03,120
of a random function

539
00:22:03,120 --> 00:22:05,679
so again for simplicity let's look at an

540
00:22:05,679 --> 00:22:07,919
embed to end it random function and

541
00:22:07,919 --> 00:22:10,799
here's a comparison between the function

542
00:22:10,799 --> 00:22:12,799
table of a random oracle and the

543
00:22:12,799 --> 00:22:15,520
superposition article so this the entire

544
00:22:15,520 --> 00:22:17,679
object so the entire random oracle

545
00:22:17,679 --> 00:22:19,360
function table is just two to the n

546
00:22:19,360 --> 00:22:21,760
random variables abstractly speaking and

547
00:22:21,760 --> 00:22:24,000
the entire superposition article that's

548
00:22:24,000 --> 00:22:27,200
just true to the n quantum registers

549
00:22:27,200 --> 00:22:28,799
now in

550
00:22:28,799 --> 00:22:31,520
the random article an unqueried entry of

551
00:22:31,520 --> 00:22:33,360
the function table is just an

552
00:22:33,360 --> 00:22:36,159
independent uniformly random random

553
00:22:36,159 --> 00:22:37,440
variable

554
00:22:37,440 --> 00:22:39,039
on the other hand in the superposition

555
00:22:39,039 --> 00:22:41,600
article um an unqueried entry just

556
00:22:41,600 --> 00:22:44,000
corresponds to a uniform superposition

557
00:22:44,000 --> 00:22:46,320
state

558
00:22:48,000 --> 00:22:50,880
now here is um the rom proof sketch

559
00:22:50,880 --> 00:22:54,080
again now let's try to mimic this in in

560
00:22:54,080 --> 00:22:56,799
the superposition article

561
00:22:56,799 --> 00:22:59,840
so um why does this rom proof actually

562
00:22:59,840 --> 00:23:00,720
work

563
00:23:00,720 --> 00:23:03,520
it works because um an unqueried entry

564
00:23:03,520 --> 00:23:04,960
as we've just seen

565
00:23:04,960 --> 00:23:07,200
corresponds to a uniformly random

566
00:23:07,200 --> 00:23:09,039
variable so

567
00:23:09,039 --> 00:23:12,080
if x star has not been created

568
00:23:12,080 --> 00:23:14,240
in the learning phase then

569
00:23:14,240 --> 00:23:16,640
the corresponding output is a uniformly

570
00:23:16,640 --> 00:23:19,200
random variable and so replacing it with

571
00:23:19,200 --> 00:23:21,200
a fresh uniformly random string doesn't

572
00:23:21,200 --> 00:23:23,760
change anything

573
00:23:23,760 --> 00:23:25,760
now in the quantum random oracle model

574
00:23:25,760 --> 00:23:28,159
we just use the superposition oracle and

575
00:23:28,159 --> 00:23:30,400
to reprogram instead of

576
00:23:30,400 --> 00:23:31,919
you know sampling a new output we

577
00:23:31,919 --> 00:23:32,960
prepare

578
00:23:32,960 --> 00:23:35,120
the register corresponding to the output

579
00:23:35,120 --> 00:23:37,520
and x star into a fresh uniform

580
00:23:37,520 --> 00:23:40,639
superposition state

581
00:23:41,039 --> 00:23:41,919
now

582
00:23:41,919 --> 00:23:43,919
essentially we can repeat the proof that

583
00:23:43,919 --> 00:23:46,400
we have or this proof sketch up up there

584
00:23:46,400 --> 00:23:48,400
except that we need to replace

585
00:23:48,400 --> 00:23:50,080
this expectation y value by the

586
00:23:50,080 --> 00:23:52,400
expectation over x star of the

587
00:23:52,400 --> 00:23:56,080
probability that um h of x star the

588
00:23:56,080 --> 00:23:57,840
corresponding register is not in the

589
00:23:57,840 --> 00:24:00,080
uniform superposition state because that

590
00:24:00,080 --> 00:24:02,080
basically corresponds to the adversary

591
00:24:02,080 --> 00:24:05,039
having created this input now this

592
00:24:05,039 --> 00:24:08,000
expectation value over x star is put in

593
00:24:08,000 --> 00:24:10,720
quotation marks here because

594
00:24:10,720 --> 00:24:14,400
somehow the argument so this probability

595
00:24:14,400 --> 00:24:15,440
is not

596
00:24:15,440 --> 00:24:17,279
well-formed

597
00:24:17,279 --> 00:24:19,679
we are talking about a quantum register

598
00:24:19,679 --> 00:24:21,760
so we cannot talk about the probability

599
00:24:21,760 --> 00:24:24,640
that this quantum register is not in

600
00:24:24,640 --> 00:24:26,400
uniform superposition or implicitly we

601
00:24:26,400 --> 00:24:28,240
could talk about this probability but it

602
00:24:28,240 --> 00:24:30,080
doesn't make any sense so what we

603
00:24:30,080 --> 00:24:32,559
actually do is we handle this whole

604
00:24:32,559 --> 00:24:35,120
proof inside the quantum formalism but i

605
00:24:35,120 --> 00:24:37,520
still didn't want to discuss it here so

606
00:24:37,520 --> 00:24:39,360
i think this expectation value in

607
00:24:39,360 --> 00:24:41,279
quotation marks is as close as you will

608
00:24:41,279 --> 00:24:43,360
get to

609
00:24:43,360 --> 00:24:47,639
getting an idea of that proof

610
00:24:48,320 --> 00:24:50,000
okay so after

611
00:24:50,000 --> 00:24:51,120
this

612
00:24:51,120 --> 00:24:53,600
short kind of insight into our proof

613
00:24:53,600 --> 00:24:54,960
technique let me

614
00:24:54,960 --> 00:24:57,600
present the matching attack that we have

615
00:24:57,600 --> 00:24:59,840
that shows that on the reprogramming

616
00:24:59,840 --> 00:25:03,200
lemma is tight

617
00:25:03,200 --> 00:25:04,640
so let's first have a look at a

618
00:25:04,640 --> 00:25:06,640
classical attack here's the the theorem

619
00:25:06,640 --> 00:25:08,480
again that gives them the upper bound on

620
00:25:08,480 --> 00:25:10,400
the distinguishing advantage

621
00:25:10,400 --> 00:25:12,960
a simple attack is to just query few

622
00:25:12,960 --> 00:25:14,960
different values of x store all of the

623
00:25:14,960 --> 00:25:16,000
results

624
00:25:16,000 --> 00:25:18,080
and then do this in the first phase

625
00:25:18,080 --> 00:25:20,799
right and then um in the second phase

626
00:25:20,799 --> 00:25:23,440
just hope that um

627
00:25:23,440 --> 00:25:25,840
the reprogrammed input is among the ones

628
00:25:25,840 --> 00:25:27,600
great in the first phase

629
00:25:27,600 --> 00:25:30,799
this costs q queries in the first phase

630
00:25:30,799 --> 00:25:32,320
but um

631
00:25:32,320 --> 00:25:34,480
an important caveat is that the memory

632
00:25:34,480 --> 00:25:36,720
cost is order q right because we need to

633
00:25:36,720 --> 00:25:38,960
store all the values so here's a better

634
00:25:38,960 --> 00:25:42,320
attack you can just store the xor of all

635
00:25:42,320 --> 00:25:44,799
the gray outputs and then recompute them

636
00:25:44,799 --> 00:25:47,200
in the second phase and compare the two

637
00:25:47,200 --> 00:25:49,120
check sounds

638
00:25:49,120 --> 00:25:50,880
this costs two queue queries because we

639
00:25:50,880 --> 00:25:53,039
need to query all of the inputs again in

640
00:25:53,039 --> 00:25:54,960
the second phase but on the other hand

641
00:25:54,960 --> 00:25:58,000
the memory cost is um order one

642
00:25:58,000 --> 00:26:00,720
now what we do is we

643
00:26:00,720 --> 00:26:02,080
quantize

644
00:26:02,080 --> 00:26:04,159
the better attack

645
00:26:04,159 --> 00:26:06,480
um so how does that work

646
00:26:06,480 --> 00:26:08,480
let's first have a look at

647
00:26:08,480 --> 00:26:11,120
when the classical attack succeeds so

648
00:26:11,120 --> 00:26:13,919
here the attack succeeds whenever the

649
00:26:13,919 --> 00:26:16,240
reprogrammed input x star is in the set

650
00:26:16,240 --> 00:26:19,200
of great input and that obviously is the

651
00:26:19,200 --> 00:26:21,120
case with probability q times 2 to the

652
00:26:21,120 --> 00:26:22,960
minus n

653
00:26:22,960 --> 00:26:26,480
the idea is to query a superposition of

654
00:26:26,480 --> 00:26:29,120
different sets of inputs

655
00:26:29,120 --> 00:26:31,919
and um then some of the success

656
00:26:31,919 --> 00:26:35,120
probability should actually grow with

657
00:26:35,120 --> 00:26:37,919
what we can call the amplitude of x-star

658
00:26:37,919 --> 00:26:40,000
being in the query set

659
00:26:40,000 --> 00:26:42,400
instead of the probability that's how we

660
00:26:42,400 --> 00:26:45,360
gain the square root advantage

661
00:26:45,360 --> 00:26:47,679
so more concretely how can we do this

662
00:26:47,679 --> 00:26:49,520
efficiently we start with a uniform

663
00:26:49,520 --> 00:26:51,520
superposition of inputs then we

664
00:26:51,520 --> 00:26:54,640
repeatedly do the following we query

665
00:26:54,640 --> 00:26:57,279
our superposition and then we apply some

666
00:26:57,279 --> 00:27:00,559
fixed cyclic permutation of

667
00:27:00,559 --> 00:27:03,440
the domain of our hash function

668
00:27:03,440 --> 00:27:05,679
and that we do that q times and then

669
00:27:05,679 --> 00:27:08,000
after reprogramming we undo the whole

670
00:27:08,000 --> 00:27:08,799
thing

671
00:27:08,799 --> 00:27:10,400
now if we're back with the in the

672
00:27:10,400 --> 00:27:12,640
initial state then uh nothing has

673
00:27:12,640 --> 00:27:15,520
happened and if something has changed

674
00:27:15,520 --> 00:27:18,000
and then reprogramming has happened and

675
00:27:18,000 --> 00:27:19,600
there is an optimal measurement that

676
00:27:19,600 --> 00:27:22,799
gives us this square root of advantage

677
00:27:22,799 --> 00:27:25,440
this reveals basically the the theorem

678
00:27:25,440 --> 00:27:26,159
that

679
00:27:26,159 --> 00:27:28,559
says that our reprogramming theorem is

680
00:27:28,559 --> 00:27:30,240
tight or in other words the

681
00:27:30,240 --> 00:27:32,320
distinguishing advantage of order square

682
00:27:32,320 --> 00:27:34,559
root of the number of oracle queries

683
00:27:34,559 --> 00:27:38,960
divided by two to three n is achievable

684
00:27:39,760 --> 00:27:42,240
that was all we wanted to say thank you

685
00:27:42,240 --> 00:27:45,799
very much for listening

