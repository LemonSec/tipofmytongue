1
00:00:01,360 --> 00:00:02,240
hello

2
00:00:02,240 --> 00:00:04,560
my name is lisa miller and i will be

3
00:00:04,560 --> 00:00:06,640
talking about our paper symmetric key

4
00:00:06,640 --> 00:00:09,120
exchange with full forward security and

5
00:00:09,120 --> 00:00:11,440
robust synchronization

6
00:00:11,440 --> 00:00:13,840
this is joint work with colin boyd

7
00:00:13,840 --> 00:00:15,679
gareth t davis

8
00:00:15,679 --> 00:00:20,720
or the cook kai galette and teboyaga

9
00:00:22,160 --> 00:00:24,160
in this paper we are looking at

10
00:00:24,160 --> 00:00:26,000
authenticated key exchange for very

11
00:00:26,000 --> 00:00:28,080
constrained devices but we still want to

12
00:00:28,080 --> 00:00:31,279
achieve desirable security properties

13
00:00:31,279 --> 00:00:33,520
for this purpose we want to look at only

14
00:00:33,520 --> 00:00:35,600
symmetric key primitives as they in

15
00:00:35,600 --> 00:00:37,680
general require less resources than

16
00:00:37,680 --> 00:00:39,840
public key primitives

17
00:00:39,840 --> 00:00:41,600
another benefit of protocols relying

18
00:00:41,600 --> 00:00:43,600
purely on symmetric key techniques such

19
00:00:43,600 --> 00:00:45,120
as hash functions and symmetric

20
00:00:45,120 --> 00:00:46,160
encryption

21
00:00:46,160 --> 00:00:47,840
is that they can also achieve post

22
00:00:47,840 --> 00:00:49,760
quantum security

23
00:00:49,760 --> 00:00:51,120
so we want to achieve symmetric

24
00:00:51,120 --> 00:00:52,960
authenticated key exchange from

25
00:00:52,960 --> 00:00:54,320
pre-shared keys

26
00:00:54,320 --> 00:00:56,320
and we want to keep desirable security

27
00:00:56,320 --> 00:00:58,640
properties such as forward security and

28
00:00:58,640 --> 00:01:01,680
concurrent correctness

29
00:01:01,920 --> 00:01:04,159
typically forward security is achieved

30
00:01:04,159 --> 00:01:06,560
with ephemeral keys using for example

31
00:01:06,560 --> 00:01:08,080
diffie-hellman

32
00:01:08,080 --> 00:01:10,560
however for symmetric keys we don't have

33
00:01:10,560 --> 00:01:12,640
a similar technique and using

34
00:01:12,640 --> 00:01:14,799
traditional long-term symmetric keys

35
00:01:14,799 --> 00:01:16,960
will not protect previous sessions upon

36
00:01:16,960 --> 00:01:19,439
corruption

37
00:01:19,600 --> 00:01:21,680
a natural way of overcoming this issue

38
00:01:21,680 --> 00:01:24,000
is to evolve our symmetric keys in such

39
00:01:24,000 --> 00:01:26,240
a way that finding the previous key and

40
00:01:26,240 --> 00:01:28,799
thus any previous session keys

41
00:01:28,799 --> 00:01:31,759
would be impractical

42
00:01:32,000 --> 00:01:34,400
when we use evolving keys we run into a

43
00:01:34,400 --> 00:01:36,799
synchronization issue we need some way

44
00:01:36,799 --> 00:01:38,560
of ensuring that both parties have

45
00:01:38,560 --> 00:01:40,799
evolved their key the same number of

46
00:01:40,799 --> 00:01:43,119
steps from the starting point

47
00:01:43,119 --> 00:01:45,040
if the parties become out of sync with

48
00:01:45,040 --> 00:01:47,200
no means of recovering then our system

49
00:01:47,200 --> 00:01:49,600
is broken

50
00:01:49,600 --> 00:01:51,439
another problem we face

51
00:01:51,439 --> 00:01:53,759
is correctness in the presence of

52
00:01:53,759 --> 00:01:57,920
multiple concurrent or parallel sessions

53
00:01:57,920 --> 00:01:59,680
we want to make sure that we don't have

54
00:01:59,680 --> 00:02:00,719
sessions

55
00:02:00,719 --> 00:02:02,240
where the parties accept with different

56
00:02:02,240 --> 00:02:04,399
session keys

57
00:02:04,399 --> 00:02:05,840
we have proposed two methods of

58
00:02:05,840 --> 00:02:07,600
overcoming this issue

59
00:02:07,600 --> 00:02:09,840
one way is by keeping a counter that

60
00:02:09,840 --> 00:02:11,599
counts the number of steps the key has

61
00:02:11,599 --> 00:02:12,800
been advanced

62
00:02:12,800 --> 00:02:14,160
and the other way

63
00:02:14,160 --> 00:02:15,920
is by making use of a punctuable

64
00:02:15,920 --> 00:02:17,840
pseudorandom function

65
00:02:17,840 --> 00:02:21,400
more on this later

66
00:02:22,319 --> 00:02:24,800
in this paper we present a suite of key

67
00:02:24,800 --> 00:02:26,720
exchange particles

68
00:02:26,720 --> 00:02:28,560
three of these protocols are very

69
00:02:28,560 --> 00:02:31,120
efficient and make use of a linear key

70
00:02:31,120 --> 00:02:32,959
evolving scheme

71
00:02:32,959 --> 00:02:35,040
these protocols also achieve the weak

72
00:02:35,040 --> 00:02:36,879
synchronization property that we will

73
00:02:36,879 --> 00:02:39,200
see later

74
00:02:39,200 --> 00:02:41,040
in order to address the challenges we

75
00:02:41,040 --> 00:02:43,840
face with linearly evolving keys we also

76
00:02:43,840 --> 00:02:46,000
present two protocols which make use of

77
00:02:46,000 --> 00:02:48,720
punctual pseudorandom functions for key

78
00:02:48,720 --> 00:02:50,800
evolution and this allows them to

79
00:02:50,800 --> 00:02:52,319
achieve the full synchronization

80
00:02:52,319 --> 00:02:55,280
robustness properties

81
00:02:55,519 --> 00:02:57,840
we also provide a formal framework

82
00:02:57,840 --> 00:02:59,519
protocol analysis

83
00:02:59,519 --> 00:03:02,480
we described the ake model and also note

84
00:03:02,480 --> 00:03:04,640
that this model lacks any formal notion

85
00:03:04,640 --> 00:03:07,200
of concurrent correctness

86
00:03:07,200 --> 00:03:08,959
therefore we formalize the security

87
00:03:08,959 --> 00:03:11,440
notion of synchronization robustness

88
00:03:11,440 --> 00:03:13,280
which captures the ability of

89
00:03:13,280 --> 00:03:14,800
resynchronization

90
00:03:14,800 --> 00:03:16,480
and concurrent correctness of the

91
00:03:16,480 --> 00:03:19,040
protocols

92
00:03:19,040 --> 00:03:21,760
this security definition is a novel

93
00:03:21,760 --> 00:03:24,480
modeling of availability as a security

94
00:03:24,480 --> 00:03:25,680
property

95
00:03:25,680 --> 00:03:26,959
and this is our most important

96
00:03:26,959 --> 00:03:29,120
contribution to the security model we

97
00:03:29,120 --> 00:03:33,840
will see some more detail on this later

98
00:03:34,720 --> 00:03:36,799
so what we're trying to achieve is

99
00:03:36,799 --> 00:03:40,159
authenticated key exchange ake for short

100
00:03:40,159 --> 00:03:42,239
with very constrained devices

101
00:03:42,239 --> 00:03:43,680
and thus we choose to do this with

102
00:03:43,680 --> 00:03:46,159
pre-shared symmetric keys and only

103
00:03:46,159 --> 00:03:49,360
symmetric key primitives

104
00:03:49,360 --> 00:03:51,200
alice and bob wants to exchange a

105
00:03:51,200 --> 00:03:53,040
session key and they each have the

106
00:03:53,040 --> 00:03:57,040
pre-shared key k-a-b

107
00:03:57,920 --> 00:04:00,319
they run a key exchange protocol by

108
00:04:00,319 --> 00:04:02,480
sending messages to each other they use

109
00:04:02,480 --> 00:04:04,959
the pre-shared key material to convince

110
00:04:04,959 --> 00:04:06,560
each other that they are in fact the

111
00:04:06,560 --> 00:04:08,560
person they're claiming to be

112
00:04:08,560 --> 00:04:10,959
and if alice and bob are both convinced

113
00:04:10,959 --> 00:04:13,439
of the identity of their partner and all

114
00:04:13,439 --> 00:04:14,959
of the messages were delivered and

115
00:04:14,959 --> 00:04:17,759
accepted then they both revive a session

116
00:04:17,759 --> 00:04:20,000
key

117
00:04:23,120 --> 00:04:25,120
forward security is a property that

118
00:04:25,120 --> 00:04:27,360
ensures that if a party is compromised

119
00:04:27,360 --> 00:04:30,000
then any previous session still remains

120
00:04:30,000 --> 00:04:31,680
secure

121
00:04:31,680 --> 00:04:33,040
specifically

122
00:04:33,040 --> 00:04:34,320
alice and bob

123
00:04:34,320 --> 00:04:36,400
are sharing asymmetric key

124
00:04:36,400 --> 00:04:40,240
kab and they run the ake protocol to get

125
00:04:40,240 --> 00:04:42,960
a session key ks1

126
00:04:42,960 --> 00:04:44,880
at a later point they run the aka

127
00:04:44,880 --> 00:04:47,440
protocol again and get a new session key

128
00:04:47,440 --> 00:04:49,440
ks2

129
00:04:49,440 --> 00:04:51,680
if our adversary eve now compromises

130
00:04:51,680 --> 00:04:54,240
alice e will get access to the shared

131
00:04:54,240 --> 00:04:57,440
symmetric key kab

132
00:04:57,440 --> 00:05:00,240
depending on how the key state

133
00:05:00,240 --> 00:05:03,199
is and how we define corruption eve may

134
00:05:03,199 --> 00:05:05,360
also get access to the second session

135
00:05:05,360 --> 00:05:06,400
key

136
00:05:06,400 --> 00:05:08,560
even if she's unable to recompute it

137
00:05:08,560 --> 00:05:11,039
from the shared symmetric key

138
00:05:11,039 --> 00:05:12,880
however eve will not be able to get

139
00:05:12,880 --> 00:05:16,240
access to or recompute any previous

140
00:05:16,240 --> 00:05:17,440
session key

141
00:05:17,440 --> 00:05:18,720
in particular

142
00:05:18,720 --> 00:05:20,560
eve is unable to recompute the first

143
00:05:20,560 --> 00:05:23,520
session key so the first session is

144
00:05:23,520 --> 00:05:27,120
protected against the adversary

145
00:05:29,520 --> 00:05:31,520
using symmetric keys in the traditional

146
00:05:31,520 --> 00:05:33,840
way does not give us forward security

147
00:05:33,840 --> 00:05:37,280
since all of the key material is static

148
00:05:37,280 --> 00:05:39,919
in order to overcome this we involve our

149
00:05:39,919 --> 00:05:41,520
symmetric keys

150
00:05:41,520 --> 00:05:43,759
if we after deriving a session key

151
00:05:43,759 --> 00:05:45,280
evolve our

152
00:05:45,280 --> 00:05:47,520
long-term symmetric key in such a way

153
00:05:47,520 --> 00:05:49,199
that it's not convenient to find the

154
00:05:49,199 --> 00:05:51,440
previous version of the key then any

155
00:05:51,440 --> 00:05:53,360
past session will be protected from the

156
00:05:53,360 --> 00:05:56,319
symmetric key being compromised

157
00:05:56,319 --> 00:05:58,240
there are essentially two strategies to

158
00:05:58,240 --> 00:06:00,880
evolve the key either time-based or

159
00:06:00,880 --> 00:06:03,680
triggered evolution

160
00:06:03,680 --> 00:06:06,080
time-based evolution was first described

161
00:06:06,080 --> 00:06:08,400
by dusty and jalili in their paper from

162
00:06:08,400 --> 00:06:10,160
2015.

163
00:06:10,160 --> 00:06:12,080
this means that the parties agree that

164
00:06:12,080 --> 00:06:13,840
they will evolve their key after a

165
00:06:13,840 --> 00:06:16,000
specific amount of time for example

166
00:06:16,000 --> 00:06:18,880
every day or every hour

167
00:06:18,880 --> 00:06:20,800
this means that within this time which

168
00:06:20,800 --> 00:06:23,280
we call an epoch any past session

169
00:06:23,280 --> 00:06:24,880
remains vulnerable

170
00:06:24,880 --> 00:06:27,199
but any session from previous epochs are

171
00:06:27,199 --> 00:06:29,120
protected

172
00:06:29,120 --> 00:06:30,880
this is a weaker form of forward

173
00:06:30,880 --> 00:06:33,199
security but may in some cases be

174
00:06:33,199 --> 00:06:34,560
acceptable

175
00:06:34,560 --> 00:06:37,280
this method does require synchronized

176
00:06:37,280 --> 00:06:40,000
clocks on the devices in use

177
00:06:40,000 --> 00:06:41,440
since we are considering very

178
00:06:41,440 --> 00:06:43,360
constrained devices this is not an

179
00:06:43,360 --> 00:06:45,039
assumption that we are willing to make

180
00:06:45,039 --> 00:06:48,800
therefore we use triggered evolution

181
00:06:48,800 --> 00:06:50,639
triggered key evolution essentially

182
00:06:50,639 --> 00:06:52,960
means that we evolve the key every time

183
00:06:52,960 --> 00:06:55,360
some specific event occurs

184
00:06:55,360 --> 00:06:56,800
in our case

185
00:06:56,800 --> 00:06:58,880
any time a session key has been derived

186
00:06:58,880 --> 00:07:01,680
by a party we evolve the key

187
00:07:01,680 --> 00:07:03,759
so immediately after session key

188
00:07:03,759 --> 00:07:05,919
derivation the key is evolved and we are

189
00:07:05,919 --> 00:07:07,919
no longer able to recompute the session

190
00:07:07,919 --> 00:07:10,159
key

191
00:07:11,919 --> 00:07:13,680
since we're using triggered key

192
00:07:13,680 --> 00:07:16,080
evolution where each party evolves their

193
00:07:16,080 --> 00:07:18,080
key after they have derived a session

194
00:07:18,080 --> 00:07:22,479
key we run into a synchronization issue

195
00:07:22,479 --> 00:07:24,560
both parties need to have evolved their

196
00:07:24,560 --> 00:07:27,039
key the same number of steps in order to

197
00:07:27,039 --> 00:07:30,080
derive the same session key

198
00:07:30,080 --> 00:07:32,160
this is in order to achieve correctness

199
00:07:32,160 --> 00:07:35,440
of our ake protocol

200
00:07:35,440 --> 00:07:37,840
another significant challenge is how can

201
00:07:37,840 --> 00:07:39,919
we ensure correctness when we allow

202
00:07:39,919 --> 00:07:42,560
concurrent protocol sessions in parallel

203
00:07:42,560 --> 00:07:45,199
the problem is that their requirement of

204
00:07:45,199 --> 00:07:47,440
all forward security and concurrent

205
00:07:47,440 --> 00:07:50,160
correctness seem incompatible with our

206
00:07:50,160 --> 00:07:52,479
first attempt at key evolution

207
00:07:52,479 --> 00:07:55,280
in the case of two parallel session we

208
00:07:55,280 --> 00:07:56,720
have that one of the sessions may

209
00:07:56,720 --> 00:07:59,039
advance the key to early such that the

210
00:07:59,039 --> 00:08:02,160
other session is unable to complete

211
00:08:02,160 --> 00:08:03,919
note that this is a problem even if we

212
00:08:03,919 --> 00:08:05,919
assume that all parties are honest and

213
00:08:05,919 --> 00:08:08,560
messages are reliably transmitted

214
00:08:08,560 --> 00:08:11,039
it is inherent to the linear key

215
00:08:11,039 --> 00:08:13,599
evolution

216
00:08:13,599 --> 00:08:15,440
in traditional key exchange protocols

217
00:08:15,440 --> 00:08:17,599
with forward security this is not an

218
00:08:17,599 --> 00:08:18,479
issue

219
00:08:18,479 --> 00:08:20,400
since the long-term key material isn't

220
00:08:20,400 --> 00:08:22,879
changed and forward security is achieved

221
00:08:22,879 --> 00:08:25,759
using ephemeral keys

222
00:08:25,759 --> 00:08:27,599
in order to overcome the synchronization

223
00:08:27,599 --> 00:08:30,639
problem we propose two fixes the first

224
00:08:30,639 --> 00:08:32,559
fix is more efficient

225
00:08:32,559 --> 00:08:34,320
using a counter to keep track of how

226
00:08:34,320 --> 00:08:37,039
many steps the key has been evolved

227
00:08:37,039 --> 00:08:39,360
the other method uses punctual

228
00:08:39,360 --> 00:08:41,760
pseudo-random functions

229
00:08:41,760 --> 00:08:44,000
punctuable prfs are computationally

230
00:08:44,000 --> 00:08:46,320
efficient but do require larger key

231
00:08:46,320 --> 00:08:48,240
sizes so they are less efficient in

232
00:08:48,240 --> 00:08:49,680
terms of memory

233
00:08:49,680 --> 00:08:51,600
but it also provides stronger security

234
00:08:51,600 --> 00:08:54,600
properties

235
00:08:54,720 --> 00:08:56,800
in the table we see the state of the art

236
00:08:56,800 --> 00:08:58,240
before this work for the type of

237
00:08:58,240 --> 00:09:00,720
protocol we are interested in

238
00:09:00,720 --> 00:09:02,880
before our particles there were two

239
00:09:02,880 --> 00:09:05,760
protocols presented by avon at all in

240
00:09:05,760 --> 00:09:07,279
2020

241
00:09:07,279 --> 00:09:08,959
these protocols do not achieve

242
00:09:08,959 --> 00:09:11,120
synchronization robustness or concurrent

243
00:09:11,120 --> 00:09:12,240
correctness

244
00:09:12,240 --> 00:09:14,080
but they do achieve forward security

245
00:09:14,080 --> 00:09:16,160
using so much only symmetric key

246
00:09:16,160 --> 00:09:17,600
primitives

247
00:09:17,600 --> 00:09:19,839
it is surprisingly non-trivial to

248
00:09:19,839 --> 00:09:21,760
achieve these properties and we will

249
00:09:21,760 --> 00:09:23,519
illustrate where this can go wrong and

250
00:09:23,519 --> 00:09:25,519
present our protocols that do achieve

251
00:09:25,519 --> 00:09:27,760
them

252
00:09:29,440 --> 00:09:30,720
let's have a look at one of our

253
00:09:30,720 --> 00:09:33,839
protocols we call it lp2

254
00:09:33,839 --> 00:09:35,519
this is a two message protocol with

255
00:09:35,519 --> 00:09:38,240
fixed roles meaning that the same party

256
00:09:38,240 --> 00:09:41,200
will always initiate the key exchange

257
00:09:41,200 --> 00:09:43,440
we start out with alice and bob and they

258
00:09:43,440 --> 00:09:46,640
have a pre-shared key k-a-b

259
00:09:46,640 --> 00:09:49,279
they both also keep a counter

260
00:09:49,279 --> 00:09:51,440
that we usually call ctr which is

261
00:09:51,440 --> 00:09:54,080
initialized at zero

262
00:09:54,080 --> 00:09:55,440
note that the parties will be

263
00:09:55,440 --> 00:09:57,680
synchronized before the first session

264
00:09:57,680 --> 00:09:59,680
but we don't in general assume that they

265
00:09:59,680 --> 00:10:02,959
are synchronized as we will see

266
00:10:02,959 --> 00:10:05,839
the parties also share a map key which

267
00:10:05,839 --> 00:10:07,760
is used for authentication

268
00:10:07,760 --> 00:10:10,160
the mac key is static so there is no

269
00:10:10,160 --> 00:10:12,000
synchronization issue involved with

270
00:10:12,000 --> 00:10:13,839
authentication

271
00:10:13,839 --> 00:10:15,519
please see the protocol description in

272
00:10:15,519 --> 00:10:17,600
the paper for further details on mac

273
00:10:17,600 --> 00:10:19,600
generation and what is included in the

274
00:10:19,600 --> 00:10:21,360
messages

275
00:10:21,360 --> 00:10:23,440
when alice initiates a session she will

276
00:10:23,440 --> 00:10:25,519
evolve her countering key to the next

277
00:10:25,519 --> 00:10:28,079
odd number in this case one

278
00:10:28,079 --> 00:10:30,160
she generates a message with a mac and

279
00:10:30,160 --> 00:10:33,839
sends it to bob bob receives the message

280
00:10:33,839 --> 00:10:36,160
he authenticates alice and if he accepts

281
00:10:36,160 --> 00:10:38,240
the message he will set his own counter

282
00:10:38,240 --> 00:10:40,480
to the same value as alice and generate

283
00:10:40,480 --> 00:10:42,000
a message for the mac to send back to

284
00:10:42,000 --> 00:10:43,200
alice

285
00:10:43,200 --> 00:10:45,839
he will then derive the session key and

286
00:10:45,839 --> 00:10:48,720
evolve the shared symmetric key k a b

287
00:10:48,720 --> 00:10:52,079
ending up with counter value 2.

288
00:10:52,079 --> 00:10:54,399
alice will receive this message she will

289
00:10:54,399 --> 00:10:57,279
authenticate bob and if she accepts then

290
00:10:57,279 --> 00:10:59,360
she will derive the session key and

291
00:10:59,360 --> 00:11:02,720
evolve the shared symmetric key k a b

292
00:11:02,720 --> 00:11:06,560
also ending up with counter value 2.

293
00:11:08,079 --> 00:11:09,839
let's also have a look at a session

294
00:11:09,839 --> 00:11:12,480
which doesn't successfully complete

295
00:11:12,480 --> 00:11:14,560
alice and bob both have counter value

296
00:11:14,560 --> 00:11:16,959
two from the last session

297
00:11:16,959 --> 00:11:19,120
alice wants to initiate a new session

298
00:11:19,120 --> 00:11:21,120
and she will so she will evolve her

299
00:11:21,120 --> 00:11:23,040
counter and key to the next odd number

300
00:11:23,040 --> 00:11:24,399
which is three

301
00:11:24,399 --> 00:11:26,240
she generates a message and sends it to

302
00:11:26,240 --> 00:11:27,440
bob

303
00:11:27,440 --> 00:11:28,959
bob receives this message and

304
00:11:28,959 --> 00:11:31,760
authenticates alex if he accepts then he

305
00:11:31,760 --> 00:11:34,399
evolves his counter and key to three

306
00:11:34,399 --> 00:11:36,000
generates a message and sends it to

307
00:11:36,000 --> 00:11:38,000
alice and then he derives the session

308
00:11:38,000 --> 00:11:39,519
key

309
00:11:39,519 --> 00:11:42,560
and ends up at counter value for

310
00:11:42,560 --> 00:11:44,880
however the message is never delivered

311
00:11:44,880 --> 00:11:46,240
to alice

312
00:11:46,240 --> 00:11:48,399
if alice now wants to initiate a new

313
00:11:48,399 --> 00:11:50,639
session at some point she will be one

314
00:11:50,639 --> 00:11:53,760
step behind bob so she can't initiate a

315
00:11:53,760 --> 00:11:55,519
key exchange at the counter value she's

316
00:11:55,519 --> 00:11:57,760
at because bob cannot go back to this

317
00:11:57,760 --> 00:11:59,680
counter value

318
00:11:59,680 --> 00:12:01,680
since bob can get one step ahead of

319
00:12:01,680 --> 00:12:03,440
alice if the second message is not

320
00:12:03,440 --> 00:12:06,079
delivered alice overcomes this by moving

321
00:12:06,079 --> 00:12:07,760
to the next odd number at the beginning

322
00:12:07,760 --> 00:12:09,040
of the session

323
00:12:09,040 --> 00:12:10,959
if she was at an even number

324
00:12:10,959 --> 00:12:12,800
this means that the previous session

325
00:12:12,800 --> 00:12:14,399
never completed

326
00:12:14,399 --> 00:12:16,639
if she wasn't add an odd number the last

327
00:12:16,639 --> 00:12:17,680
session

328
00:12:17,680 --> 00:12:20,240
had completed either way starting at the

329
00:12:20,240 --> 00:12:22,639
next odd number will put alice ahead of

330
00:12:22,639 --> 00:12:25,040
bob making it possible to execute a

331
00:12:25,040 --> 00:12:27,760
successful protocol run

332
00:12:27,760 --> 00:12:29,680
therefore alice

333
00:12:29,680 --> 00:12:31,680
initiates the next session at counter

334
00:12:31,680 --> 00:12:34,079
value 5.

335
00:12:34,079 --> 00:12:36,320
this strategy of choosing the next odd

336
00:12:36,320 --> 00:12:38,560
number to start a new session ensures

337
00:12:38,560 --> 00:12:40,240
that the new session can always be

338
00:12:40,240 --> 00:12:41,360
successful

339
00:12:41,360 --> 00:12:44,720
if messages from previous

340
00:12:44,720 --> 00:12:47,440
sessions were not delivered

341
00:12:47,440 --> 00:12:50,560
note that the protocol has fixed roles

342
00:12:50,560 --> 00:12:53,040
if bob could also initiate a session

343
00:12:53,040 --> 00:12:54,399
then we could never be sure that the

344
00:12:54,399 --> 00:12:56,959
initiator would be behind its partner

345
00:12:56,959 --> 00:12:58,639
and thus we could never be sure that a

346
00:12:58,639 --> 00:13:02,560
session could be completed successfully

347
00:13:04,959 --> 00:13:07,200
our linearly evolving protocols come in

348
00:13:07,200 --> 00:13:09,120
three variations the two message

349
00:13:09,120 --> 00:13:11,519
protocol we have already seen

350
00:13:11,519 --> 00:13:13,760
and two others a one message protocol

351
00:13:13,760 --> 00:13:16,320
and a three message protocol

352
00:13:16,320 --> 00:13:18,720
if we require a simpler protocol we can

353
00:13:18,720 --> 00:13:20,720
go for the one message protocol

354
00:13:20,720 --> 00:13:23,360
we naturally get only one-sided explicit

355
00:13:23,360 --> 00:13:25,600
authentication but this is the most

356
00:13:25,600 --> 00:13:28,959
efficient way we can exchange keys

357
00:13:28,959 --> 00:13:31,360
if we require stronger properties we can

358
00:13:31,360 --> 00:13:33,360
use the three message protocol this

359
00:13:33,360 --> 00:13:36,079
protocol gives mutual authentication and

360
00:13:36,079 --> 00:13:39,360
also has a provably bounded gap

361
00:13:39,360 --> 00:13:41,040
this means that regardless of

362
00:13:41,040 --> 00:13:43,199
adversarial influence

363
00:13:43,199 --> 00:13:45,199
the parties will never be more out of

364
00:13:45,199 --> 00:13:46,959
sync than the number of concurrent

365
00:13:46,959 --> 00:13:48,880
sessions

366
00:13:48,880 --> 00:13:50,720
this property is proved in a state

367
00:13:50,720 --> 00:13:52,800
analysis

368
00:13:52,800 --> 00:13:56,000
this protocol also allows role reversal

369
00:13:56,000 --> 00:13:58,399
meaning it is more flexible than our one

370
00:13:58,399 --> 00:14:02,000
and two message protocols

371
00:14:02,000 --> 00:14:03,199
the table

372
00:14:03,199 --> 00:14:05,040
summarizes the

373
00:14:05,040 --> 00:14:07,360
security properties of our linearly

374
00:14:07,360 --> 00:14:09,120
evolving protocols

375
00:14:09,120 --> 00:14:10,800
as we can see they all achieve forward

376
00:14:10,800 --> 00:14:13,760
security and they all achieve weak

377
00:14:13,760 --> 00:14:17,480
synchronization robustness

378
00:14:18,399 --> 00:14:20,160
we provide a framework that makes it

379
00:14:20,160 --> 00:14:22,000
possible to analyze protocols of this

380
00:14:22,000 --> 00:14:22,880
type

381
00:14:22,880 --> 00:14:24,800
there are other examples of protocols of

382
00:14:24,800 --> 00:14:27,199
this type in the literature which also

383
00:14:27,199 --> 00:14:29,199
achieve many of the desirable properties

384
00:14:29,199 --> 00:14:30,959
that we're interested in

385
00:14:30,959 --> 00:14:33,120
however we have not seen other protocols

386
00:14:33,120 --> 00:14:35,680
to satisfy all of the properties that we

387
00:14:35,680 --> 00:14:38,800
proved that our protocols satisfy

388
00:14:38,800 --> 00:14:41,440
we give a description of the ake model

389
00:14:41,440 --> 00:14:44,240
in which we prove our protocol secure

390
00:14:44,240 --> 00:14:46,160
this model follows the standard approach

391
00:14:46,160 --> 00:14:48,800
for ake models based on the ballara rug

392
00:14:48,800 --> 00:14:50,880
away model and is very similar to the

393
00:14:50,880 --> 00:14:56,079
one presented by lee et al in 2014

394
00:14:57,120 --> 00:14:59,760
the ake model doesn't have any notion of

395
00:14:59,760 --> 00:15:01,040
concurrent correctness or

396
00:15:01,040 --> 00:15:03,360
synchronization robustness

397
00:15:03,360 --> 00:15:06,079
in traditional public key ake protocols

398
00:15:06,079 --> 00:15:07,839
we don't have the synchronization

399
00:15:07,839 --> 00:15:10,160
problem so the model doesn't need to

400
00:15:10,160 --> 00:15:11,360
handle this

401
00:15:11,360 --> 00:15:13,760
however for the symmetric key case with

402
00:15:13,760 --> 00:15:16,079
the bulb and keys we need some way of

403
00:15:16,079 --> 00:15:19,199
analyzing this property

404
00:15:19,519 --> 00:15:21,839
this is something we have addressed

405
00:15:21,839 --> 00:15:23,839
the formalization of this property is

406
00:15:23,839 --> 00:15:25,519
our most important contribution to the

407
00:15:25,519 --> 00:15:26,959
security model

408
00:15:26,959 --> 00:15:28,720
and our framework for analyzing

409
00:15:28,720 --> 00:15:31,199
protocols is unique in that it models

410
00:15:31,199 --> 00:15:34,639
availability as a security feature

411
00:15:34,639 --> 00:15:36,880
synchronization robustness captures the

412
00:15:36,880 --> 00:15:40,399
ability to compute keys in the future no

413
00:15:40,399 --> 00:15:42,560
matter what happens either accidentally

414
00:15:42,560 --> 00:15:47,199
or by adversarial intervention now

415
00:15:47,519 --> 00:15:49,519
concurrent correctness is what we call

416
00:15:49,519 --> 00:15:51,600
the property that any protocol run that

417
00:15:51,600 --> 00:15:53,519
is allowed to honestly complete will

418
00:15:53,519 --> 00:15:55,040
succeed

419
00:15:55,040 --> 00:15:57,360
we can see that for a linearly

420
00:15:57,360 --> 00:16:00,160
key evolving protocol such as lp2

421
00:16:00,160 --> 00:16:02,320
if we have two concurrent sessions at

422
00:16:02,320 --> 00:16:05,759
least one of them will fail

423
00:16:05,759 --> 00:16:08,880
again alice and bob will exchange keys

424
00:16:08,880 --> 00:16:10,720
they start out synchronized at counter

425
00:16:10,720 --> 00:16:13,199
value 0 and now we will let them run two

426
00:16:13,199 --> 00:16:15,920
concurrent key exchange sessions

427
00:16:15,920 --> 00:16:17,759
alice initiates a session at counter

428
00:16:17,759 --> 00:16:20,720
value 1 she sends the message to bob

429
00:16:20,720 --> 00:16:22,800
who accepts the session at counter value

430
00:16:22,800 --> 00:16:25,120
1 and completes the session accepting

431
00:16:25,120 --> 00:16:28,000
the final counter value 2 and sends the

432
00:16:28,000 --> 00:16:30,320
message back to alice

433
00:16:30,320 --> 00:16:32,320
before alice receives the message from

434
00:16:32,320 --> 00:16:34,839
bob she initiates a new

435
00:16:34,839 --> 00:16:37,279
session she has to start the session at

436
00:16:37,279 --> 00:16:39,279
the next odd number so she initiates

437
00:16:39,279 --> 00:16:41,120
with counter value 3

438
00:16:41,120 --> 00:16:44,639
and sends the message to bob

439
00:16:45,519 --> 00:16:47,360
now she gets

440
00:16:47,360 --> 00:16:49,600
the message that bob sent in the session

441
00:16:49,600 --> 00:16:51,519
with counter value one

442
00:16:51,519 --> 00:16:53,759
however she has already evolved past

443
00:16:53,759 --> 00:16:56,639
this point so she cannot derive a key at

444
00:16:56,639 --> 00:16:58,160
this counter value

445
00:16:58,160 --> 00:17:01,920
thus she has to abort the session

446
00:17:02,240 --> 00:17:04,160
bob on the other hand gets the second

447
00:17:04,160 --> 00:17:06,240
message from alice for a session on

448
00:17:06,240 --> 00:17:08,880
counter value 3. he accepts this and

449
00:17:08,880 --> 00:17:10,880
completes the session accepting the

450
00:17:10,880 --> 00:17:13,520
final counter value 4 and sends the

451
00:17:13,520 --> 00:17:16,240
message back to alice

452
00:17:16,240 --> 00:17:18,640
alice gets this message and since she

453
00:17:18,640 --> 00:17:20,880
has not evolved too far she is able to

454
00:17:20,880 --> 00:17:22,400
accept this message and complete the

455
00:17:22,400 --> 00:17:23,280
session

456
00:17:23,280 --> 00:17:27,039
accepting with final counter value for

457
00:17:27,039 --> 00:17:29,039
so with two concurrent session

458
00:17:29,039 --> 00:17:31,280
the first session failed because alice

459
00:17:31,280 --> 00:17:33,120
cannot go back to a previous counter

460
00:17:33,120 --> 00:17:34,640
value

461
00:17:34,640 --> 00:17:36,880
this linear nature of the key evolving

462
00:17:36,880 --> 00:17:38,960
scheme makes it impossible for this kind

463
00:17:38,960 --> 00:17:40,640
of protocol to achieve concurrent

464
00:17:40,640 --> 00:17:43,200
correctness

465
00:17:44,799 --> 00:17:46,400
the security property we call

466
00:17:46,400 --> 00:17:48,799
synchronization robustness captures the

467
00:17:48,799 --> 00:17:51,200
ability of successfully exchanging keys

468
00:17:51,200 --> 00:17:52,400
in the future

469
00:17:52,400 --> 00:17:55,280
even if something goes wrong now

470
00:17:55,280 --> 00:17:57,120
if the parties get out of sync for any

471
00:17:57,120 --> 00:17:58,640
reason they need to be able to

472
00:17:58,640 --> 00:18:00,880
re-synchronize

473
00:18:00,880 --> 00:18:03,039
we formalize this property and present

474
00:18:03,039 --> 00:18:05,039
it in two variants

475
00:18:05,039 --> 00:18:07,120
because linearly evolving protocols

476
00:18:07,120 --> 00:18:09,200
cannot achieve concurrent correctness we

477
00:18:09,200 --> 00:18:11,440
define weak synchronization robustness

478
00:18:11,440 --> 00:18:13,280
which our linearly evolving protocols

479
00:18:13,280 --> 00:18:15,039
will achieve

480
00:18:15,039 --> 00:18:17,120
full synchronization robustness is

481
00:18:17,120 --> 00:18:19,120
achieved by our non-linear evolving

482
00:18:19,120 --> 00:18:21,678
protocols

483
00:18:23,039 --> 00:18:25,039
the weaker version of synchronization

484
00:18:25,039 --> 00:18:27,520
robustness captures the idea that no

485
00:18:27,520 --> 00:18:29,360
matter how much the adversary does to

486
00:18:29,360 --> 00:18:31,120
mess things up for alice

487
00:18:31,120 --> 00:18:32,080
by

488
00:18:32,080 --> 00:18:34,480
initiating concurrent sessions

489
00:18:34,480 --> 00:18:36,320
dropping reordering and altering

490
00:18:36,320 --> 00:18:37,600
messages

491
00:18:37,600 --> 00:18:39,520
making the parties go out of sync by

492
00:18:39,520 --> 00:18:43,200
arbitrarily many steps in any case

493
00:18:43,200 --> 00:18:45,360
the next time alice and bob are able to

494
00:18:45,360 --> 00:18:47,679
execute the session without interruption

495
00:18:47,679 --> 00:18:51,679
that session will complete successfully

496
00:18:52,240 --> 00:18:54,720
weak synchronization robustness may not

497
00:18:54,720 --> 00:18:56,240
be achieved by a linearly evolving

498
00:18:56,240 --> 00:18:58,240
protocol for instance with our two

499
00:18:58,240 --> 00:19:00,400
message protocol lp2

500
00:19:00,400 --> 00:19:02,320
if we drop the requirement of fixed

501
00:19:02,320 --> 00:19:04,400
roles we may find ourselves in a

502
00:19:04,400 --> 00:19:06,480
situation where the initiator is more

503
00:19:06,480 --> 00:19:08,960
than one step behind the responder

504
00:19:08,960 --> 00:19:10,559
and thus when the next session is

505
00:19:10,559 --> 00:19:13,039
initiated it will not succeed breaking

506
00:19:13,039 --> 00:19:14,799
the weak synchronization robustness

507
00:19:14,799 --> 00:19:17,360
requirement

508
00:19:18,720 --> 00:19:20,960
full synchronization robustness captures

509
00:19:20,960 --> 00:19:22,880
concurrent correctness that is the

510
00:19:22,880 --> 00:19:25,840
requirement that any honestly executed

511
00:19:25,840 --> 00:19:28,480
and completed session will succeed

512
00:19:28,480 --> 00:19:30,640
even if the adversary is messing with

513
00:19:30,640 --> 00:19:32,960
current sessions and interleaving

514
00:19:32,960 --> 00:19:35,919
messages from different sessions

515
00:19:35,919 --> 00:19:38,080
linear key evolving protocols did not

516
00:19:38,080 --> 00:19:39,600
achieve

517
00:19:39,600 --> 00:19:42,000
full synchronization robustness because

518
00:19:42,000 --> 00:19:44,240
if we're running two parallel sessions

519
00:19:44,240 --> 00:19:46,080
then one of the sessions will trigger a

520
00:19:46,080 --> 00:19:47,760
key evolution first

521
00:19:47,760 --> 00:19:49,360
making it impossible for the other

522
00:19:49,360 --> 00:19:51,600
session to succeed in deriving a session

523
00:19:51,600 --> 00:19:53,280
key at the counter value it was

524
00:19:53,280 --> 00:19:55,120
initiated

525
00:19:55,120 --> 00:19:57,039
in order to overcome this limitation of

526
00:19:57,039 --> 00:19:59,600
linearly evolving keys we present our

527
00:19:59,600 --> 00:20:02,719
alternative solution

528
00:20:03,360 --> 00:20:05,679
as we have seen our linearly evolving

529
00:20:05,679 --> 00:20:07,919
protocols achieve weak synchronization

530
00:20:07,919 --> 00:20:10,400
robustness but it is not possible for

531
00:20:10,400 --> 00:20:12,159
them to achieve full synchronization

532
00:20:12,159 --> 00:20:14,159
robustness due to the nature of the key

533
00:20:14,159 --> 00:20:15,360
evolution

534
00:20:15,360 --> 00:20:17,280
so we cannot get concurrent correctness

535
00:20:17,280 --> 00:20:18,799
and therefore we need a different way of

536
00:20:18,799 --> 00:20:20,640
evolving our keys in order to achieve

537
00:20:20,640 --> 00:20:22,080
this

538
00:20:22,080 --> 00:20:24,000
our way of solving this problem is to

539
00:20:24,000 --> 00:20:27,200
use punctual pseudo-random functions

540
00:20:27,200 --> 00:20:29,919
a punctuable prf is a prf with an

541
00:20:29,919 --> 00:20:32,159
additional algorithm that we call

542
00:20:32,159 --> 00:20:33,600
puncture

543
00:20:33,600 --> 00:20:36,159
so we have two algorithms evaluation and

544
00:20:36,159 --> 00:20:38,880
puncturing we evaluate in a point to get

545
00:20:38,880 --> 00:20:40,240
a session key

546
00:20:40,240 --> 00:20:41,840
and we puncture our key in the same

547
00:20:41,840 --> 00:20:43,919
value to make it impossible to recompute

548
00:20:43,919 --> 00:20:46,159
this session key

549
00:20:46,159 --> 00:20:48,400
if we puncture on a specific value

550
00:20:48,400 --> 00:20:51,120
then evaluating on that value later will

551
00:20:51,120 --> 00:20:53,440
return failure and if we puncture on the

552
00:20:53,440 --> 00:20:55,760
same value twice

553
00:20:55,760 --> 00:20:58,080
the second time will return no change in

554
00:20:58,080 --> 00:21:00,000
the key

555
00:21:00,000 --> 00:21:02,000
puncturing also has a commutative

556
00:21:02,000 --> 00:21:03,280
property

557
00:21:03,280 --> 00:21:04,640
which means that it doesn't matter in

558
00:21:04,640 --> 00:21:08,640
which order you puncture values

559
00:21:08,640 --> 00:21:11,200
note that the ggm pseudorandom function

560
00:21:11,200 --> 00:21:13,600
is essentially a pseudo-random function

561
00:21:13,600 --> 00:21:16,000
and we can in general construct a pprf

562
00:21:16,000 --> 00:21:18,480
by using hash based evaluation in a tree

563
00:21:18,480 --> 00:21:20,960
structure

564
00:21:21,200 --> 00:21:23,840
in our protocols using this a nonce is

565
00:21:23,840 --> 00:21:25,840
chosen for each session

566
00:21:25,840 --> 00:21:27,520
and the session key is derived by

567
00:21:27,520 --> 00:21:31,200
evaluating the pprf in this nodes

568
00:21:31,200 --> 00:21:33,280
after key duration the shared key is

569
00:21:33,280 --> 00:21:35,280
punctured in this value so that it's no

570
00:21:35,280 --> 00:21:37,360
longer possible to evaluate the prf in

571
00:21:37,360 --> 00:21:38,640
this point

572
00:21:38,640 --> 00:21:42,480
thus we achieve forward security

573
00:21:42,480 --> 00:21:44,080
since the order in which you puncture

574
00:21:44,080 --> 00:21:46,559
values doesn't matter any honestly

575
00:21:46,559 --> 00:21:49,120
completed session will succeed because

576
00:21:49,120 --> 00:21:51,200
any puncturing done by other sessions

577
00:21:51,200 --> 00:21:53,440
and other values do not affect this

578
00:21:53,440 --> 00:21:54,400
session's

579
00:21:54,400 --> 00:21:58,919
ability to derive the session key

580
00:21:59,840 --> 00:22:01,760
the two protocols we present with

581
00:22:01,760 --> 00:22:04,720
non-linear key evolution are called pp1

582
00:22:04,720 --> 00:22:06,400
and ppt

583
00:22:06,400 --> 00:22:08,000
they have one and two messages

584
00:22:08,000 --> 00:22:09,760
respectively

585
00:22:09,760 --> 00:22:11,440
these protocols achieve all of the

586
00:22:11,440 --> 00:22:13,679
properties we are interested in

587
00:22:13,679 --> 00:22:15,679
full and therefore also weak

588
00:22:15,679 --> 00:22:17,840
synchronization robustness concurrent

589
00:22:17,840 --> 00:22:21,840
correctness and forward security

590
00:22:22,400 --> 00:22:24,240
lastly we would like to summarize the

591
00:22:24,240 --> 00:22:26,480
security properties of our protocols and

592
00:22:26,480 --> 00:22:28,240
compare them to the protocols introduced

593
00:22:28,240 --> 00:22:31,360
by ob1 at al in 2020

594
00:22:31,360 --> 00:22:33,760
the sake and sake am protocols do not

595
00:22:33,760 --> 00:22:35,840
achieve weak synchronization robustness

596
00:22:35,840 --> 00:22:38,080
or concurrent correctness but they do

597
00:22:38,080 --> 00:22:40,799
achieve forward security our linear

598
00:22:40,799 --> 00:22:44,320
protocols lp 1 2 and 3 all achieve weak

599
00:22:44,320 --> 00:22:46,240
synchronization robustness and forward

600
00:22:46,240 --> 00:22:47,440
security

601
00:22:47,440 --> 00:22:48,960
but they do not achieve concurrent

602
00:22:48,960 --> 00:22:50,799
correctness

603
00:22:50,799 --> 00:22:53,919
our non-linear protocols pp1 and pp2

604
00:22:53,919 --> 00:22:56,000
using punctual prfs

605
00:22:56,000 --> 00:22:58,240
achieve full synchronization robustness

606
00:22:58,240 --> 00:23:00,320
concurrent correctness and forward

607
00:23:00,320 --> 00:23:02,080
security

608
00:23:02,080 --> 00:23:03,840
these protocols achieve everything we

609
00:23:03,840 --> 00:23:05,919
want but we do have to sacrifice some

610
00:23:05,919 --> 00:23:07,679
efficiency due to the nature of the

611
00:23:07,679 --> 00:23:10,720
punctuable prf

612
00:23:11,039 --> 00:23:12,960
thank you for your attention

613
00:23:12,960 --> 00:23:15,919
the paper is also available on eprint

614
00:23:15,919 --> 00:23:17,440
and if you have any questions you are

615
00:23:17,440 --> 00:23:21,880
welcome to contact one of the authors

