1
00:00:02,800 --> 00:00:03,840
hello

2
00:00:03,840 --> 00:00:06,080
my name is stan pasceni

3
00:00:06,080 --> 00:00:09,120
in this talk i will present our paper

4
00:00:09,120 --> 00:00:12,639
garbling stacked and staggered faster k

5
00:00:12,639 --> 00:00:14,920
out of n carpet function

6
00:00:14,920 --> 00:00:17,920
evaluation this is joint work with david

7
00:00:17,920 --> 00:00:21,039
heath and vlad kolesnikov and we work at

8
00:00:21,039 --> 00:00:24,000
the georgia institute of technology in

9
00:00:24,000 --> 00:00:27,680
atlanta georgia

10
00:00:29,119 --> 00:00:32,320
consider a server that offers a suite of

11
00:00:32,320 --> 00:00:35,440
various services to clients and suppose

12
00:00:35,440 --> 00:00:37,360
that these services have privacy

13
00:00:37,360 --> 00:00:42,320
concerns for both the server and client

14
00:00:43,680 --> 00:00:46,559
as an example suppose a telehealth

15
00:00:46,559 --> 00:00:49,200
company offers services that screen

16
00:00:49,200 --> 00:00:51,360
concerned patients for a variety of

17
00:00:51,360 --> 00:00:53,920
medical conditions represented as

18
00:00:53,920 --> 00:00:56,800
functions 0 through n minus 1.

19
00:00:56,800 --> 00:00:59,520
in this example both parties may have

20
00:00:59,520 --> 00:01:02,879
privacy concerns the patient alice in

21
00:01:02,879 --> 00:01:05,280
our case may not wish to disclose her

22
00:01:05,280 --> 00:01:07,760
health data and the telehealth company

23
00:01:07,760 --> 00:01:09,920
may use sensitive health data of other

24
00:01:09,920 --> 00:01:12,799
individuals do aid in the screening or

25
00:01:12,799 --> 00:01:16,400
use proprietary data

26
00:01:17,520 --> 00:01:19,759
the patient may a priori know that a

27
00:01:19,759 --> 00:01:21,920
number of medical conditions are

28
00:01:21,920 --> 00:01:23,680
unlikely to be the source of her

29
00:01:23,680 --> 00:01:24,799
symptoms

30
00:01:24,799 --> 00:01:27,360
for example it is unlikely that the

31
00:01:27,360 --> 00:01:29,280
patient's headaches are caused by

32
00:01:29,280 --> 00:01:31,200
athlete's foot

33
00:01:31,200 --> 00:01:33,840
hence the patient may only wish to be

34
00:01:33,840 --> 00:01:36,240
screened for k health conditions out of

35
00:01:36,240 --> 00:01:40,119
the possible end

36
00:01:40,400 --> 00:01:42,799
that is the patient wants to evaluate

37
00:01:42,799 --> 00:01:45,520
chaotic and public functions to which

38
00:01:45,520 --> 00:01:49,679
the parties have some private inputs

39
00:01:50,799 --> 00:01:53,840
i emphasize that the patient knows which

40
00:01:53,840 --> 00:01:56,640
k functions she wants to evaluate in

41
00:01:56,640 --> 00:01:59,439
this talk i present our k out of n

42
00:01:59,439 --> 00:02:02,000
garbage circuit-based construction which

43
00:02:02,000 --> 00:02:03,840
yields a significant concrete

44
00:02:03,840 --> 00:02:06,399
improvement over the state-of-the-art

45
00:02:06,399 --> 00:02:10,560
also garbage circuit-based construction

46
00:02:11,440 --> 00:02:14,319
so as some background for this work

47
00:02:14,319 --> 00:02:17,200
garbage circuit is an efficient protocol

48
00:02:17,200 --> 00:02:19,520
that allows two parties to securely

49
00:02:19,520 --> 00:02:21,840
compute an arbitrary function

50
00:02:21,840 --> 00:02:24,400
represented as a boolean circuit of

51
00:02:24,400 --> 00:02:26,560
their private inputs

52
00:02:26,560 --> 00:02:29,440
what i mean by securely compute is that

53
00:02:29,440 --> 00:02:31,680
the two parties provide their private

54
00:02:31,680 --> 00:02:34,080
inputs to a public function

55
00:02:34,080 --> 00:02:36,720
which they evaluate and the security

56
00:02:36,720 --> 00:02:39,120
guarantee is that an adversary

57
00:02:39,120 --> 00:02:42,160
corrupting a single party cannot learn

58
00:02:42,160 --> 00:02:44,560
anything about the other party's input

59
00:02:44,560 --> 00:02:46,640
just by looking at the transcript of

60
00:02:46,640 --> 00:02:49,280
messages he received and his internal

61
00:02:49,280 --> 00:02:50,720
state

62
00:02:50,720 --> 00:02:53,840
the only thing he can learn is what can

63
00:02:53,840 --> 00:02:56,160
be deduced from the corrupted party's

64
00:02:56,160 --> 00:02:59,920
input and the function output

65
00:02:59,920 --> 00:03:02,400
garbage circuits are interesting because

66
00:03:02,400 --> 00:03:04,560
they are often the most efficient

67
00:03:04,560 --> 00:03:06,480
technique for secure two-party

68
00:03:06,480 --> 00:03:08,080
computation

69
00:03:08,080 --> 00:03:10,720
in particular garbage circuit is a

70
00:03:10,720 --> 00:03:13,599
constant round protocol and this means

71
00:03:13,599 --> 00:03:15,760
we do not need to suffer from high

72
00:03:15,760 --> 00:03:19,399
network latency

73
00:03:19,760 --> 00:03:22,400
i repeat that in our construction

74
00:03:22,400 --> 00:03:25,360
alice's k choices are known to her

75
00:03:25,360 --> 00:03:28,239
either a priori or revealed by the

76
00:03:28,239 --> 00:03:31,239
computation

77
00:03:33,840 --> 00:03:36,799
i will start by presenting why a naive

78
00:03:36,799 --> 00:03:39,200
garbage circuit solution to the k out of

79
00:03:39,200 --> 00:03:42,799
n problem is not satisfactory

80
00:03:42,799 --> 00:03:45,599
an important point is that the generator

81
00:03:45,599 --> 00:03:48,159
should not know nor learn which k

82
00:03:48,159 --> 00:03:50,720
circuits alice will evaluate

83
00:03:50,720 --> 00:03:54,000
hence he garbles all n circuits compiles

84
00:03:54,000 --> 00:03:56,799
them into a single string and sends the

85
00:03:56,799 --> 00:03:59,920
string across the wire to alice i would

86
00:03:59,920 --> 00:04:02,640
like to emphasize that this sending of

87
00:04:02,640 --> 00:04:04,560
the circuit garberlings

88
00:04:04,560 --> 00:04:07,360
which i will henceforth refer to as the

89
00:04:07,360 --> 00:04:11,640
material is expensive

90
00:04:14,480 --> 00:04:17,040
in fact this process of sending the

91
00:04:17,040 --> 00:04:19,918
material is traditionally considered the

92
00:04:19,918 --> 00:04:22,000
most expensive part of the garbage

93
00:04:22,000 --> 00:04:25,120
circuit protocol

94
00:04:26,639 --> 00:04:30,320
in 2020 david heath and vlad kolesnikov

95
00:04:30,320 --> 00:04:33,280
introduced start garbling which reduces

96
00:04:33,280 --> 00:04:35,680
precisely this bandwidth consumption for

97
00:04:35,680 --> 00:04:37,919
one out of n circuits

98
00:04:37,919 --> 00:04:40,080
this work showed that it is not

99
00:04:40,080 --> 00:04:42,960
necessary to send a garbling for each of

100
00:04:42,960 --> 00:04:44,880
the m circuits

101
00:04:44,880 --> 00:04:47,600
in fact it suffices to send a single

102
00:04:47,600 --> 00:04:50,160
material of length equal to the single

103
00:04:50,160 --> 00:04:52,720
longest garbage link among the n

104
00:04:52,720 --> 00:04:54,479
circuits

105
00:04:54,479 --> 00:04:56,400
while it is communication

106
00:04:56,400 --> 00:04:58,320
that has been viewed as the garbage

107
00:04:58,320 --> 00:05:00,960
circuit bottleneck start garbling

108
00:05:00,960 --> 00:05:03,280
changed the status quo

109
00:05:03,280 --> 00:05:06,400
indeed even without start carpooling and

110
00:05:06,400 --> 00:05:08,880
in many settings communicating the

111
00:05:08,880 --> 00:05:11,759
carpet circuit is usually only a small

112
00:05:11,759 --> 00:05:14,560
factor slower than garbling it as

113
00:05:14,560 --> 00:05:16,400
garbling consumes significant

114
00:05:16,400 --> 00:05:19,039
computational resources

115
00:05:19,039 --> 00:05:21,520
thus even for only three or four

116
00:05:21,520 --> 00:05:24,320
branches and in many settings

117
00:05:24,320 --> 00:05:28,800
computation becomes the bottleneck

118
00:05:30,639 --> 00:05:33,039
the start garbling technique can be

119
00:05:33,039 --> 00:05:36,160
generalized to arbitrary k

120
00:05:36,160 --> 00:05:38,479
while the communication improvement is

121
00:05:38,479 --> 00:05:41,680
preserved that is the communication cost

122
00:05:41,680 --> 00:05:45,360
is proportional to k rather than n

123
00:05:45,360 --> 00:05:48,080
neither extending this technique to k

124
00:05:48,080 --> 00:05:51,759
out of n circuits incurs factor k

125
00:05:51,759 --> 00:05:55,600
increase in computation

126
00:05:57,199 --> 00:06:02,400
that is computation cost grows with k

127
00:06:05,759 --> 00:06:08,240
hence there seems to be an inherent

128
00:06:08,240 --> 00:06:10,880
trade-off between computation and

129
00:06:10,880 --> 00:06:13,199
communication with the current

130
00:06:13,199 --> 00:06:14,479
techniques

131
00:06:14,479 --> 00:06:17,520
start garbling reduces communication

132
00:06:17,520 --> 00:06:20,560
consumption but increases computation

133
00:06:20,560 --> 00:06:22,160
consumption

134
00:06:22,160 --> 00:06:24,560
this trade-off forces us to choose

135
00:06:24,560 --> 00:06:27,680
between communication and computation

136
00:06:27,680 --> 00:06:29,919
which is undesirable

137
00:06:29,919 --> 00:06:32,560
this is the key problem we are trying to

138
00:06:32,560 --> 00:06:33,440
solve

139
00:06:33,440 --> 00:06:36,160
more specifically we ask whether we can

140
00:06:36,160 --> 00:06:40,160
have the best of both worlds

141
00:06:43,120 --> 00:06:46,160
that is can we pay communication only

142
00:06:46,160 --> 00:06:49,120
for k materials and still incur

143
00:06:49,120 --> 00:06:52,720
computation on the order of n

144
00:06:52,720 --> 00:06:55,360
we answer in the affirmative and match

145
00:06:55,360 --> 00:06:57,599
the communication complexity of stat

146
00:06:57,599 --> 00:07:00,800
carbon and the garberling complexity of

147
00:07:00,800 --> 00:07:04,240
standard garbage circuit

148
00:07:06,639 --> 00:07:09,440
central to our idea is the fact that

149
00:07:09,440 --> 00:07:11,919
material is viewed differently in each

150
00:07:11,919 --> 00:07:13,120
technique

151
00:07:13,120 --> 00:07:16,000
traditionally garbage circuit was viewed

152
00:07:16,000 --> 00:07:18,319
as a collection of encrypted truth

153
00:07:18,319 --> 00:07:19,440
tables

154
00:07:19,440 --> 00:07:22,160
the key idea of start garbling was that

155
00:07:22,160 --> 00:07:24,800
the material should instead be viewed as

156
00:07:24,800 --> 00:07:26,560
a bit string

157
00:07:26,560 --> 00:07:29,039
this idea enabled to manage these

158
00:07:29,039 --> 00:07:31,919
materials as bit strings that is use

159
00:07:31,919 --> 00:07:35,120
natural operations such as bitwise xor

160
00:07:35,120 --> 00:07:38,000
to reduce communication

161
00:07:38,000 --> 00:07:40,639
we take this idea further and view the

162
00:07:40,639 --> 00:07:43,599
material as an element in a large galois

163
00:07:43,599 --> 00:07:44,879
field

164
00:07:44,879 --> 00:07:47,599
as a result we can perform linear

165
00:07:47,599 --> 00:07:50,560
algebraic operations on the material

166
00:07:50,560 --> 00:07:52,319
which will help us reduce the

167
00:07:52,319 --> 00:07:55,280
computation costs associated with

168
00:07:55,280 --> 00:07:58,840
stacked garbling

169
00:07:59,360 --> 00:08:01,919
now that i showed the costs associated

170
00:08:01,919 --> 00:08:04,400
with the different approaches and also

171
00:08:04,400 --> 00:08:07,599
stated a central observation of our work

172
00:08:07,599 --> 00:08:10,160
i will get into how the individual

173
00:08:10,160 --> 00:08:13,440
approaches stock garbling in particular

174
00:08:13,440 --> 00:08:16,400
actually work since this is necessary to

175
00:08:16,400 --> 00:08:18,800
understand our technique

176
00:08:18,800 --> 00:08:21,599
more specifically i will start with k

177
00:08:21,599 --> 00:08:23,919
equals 1 and then generalize to

178
00:08:23,919 --> 00:08:25,759
arbitrary k

179
00:08:25,759 --> 00:08:29,199
assume that n equals three that is we

180
00:08:29,199 --> 00:08:32,320
have three circuits c zero c one and c

181
00:08:32,320 --> 00:08:33,120
two

182
00:08:33,120 --> 00:08:38,039
and c zero is the taken circuit

183
00:08:40,159 --> 00:08:42,399
a key point is that each circuit

184
00:08:42,399 --> 00:08:45,600
encryption that is the material the bit

185
00:08:45,600 --> 00:08:48,480
string can be viewed as an expansion of

186
00:08:48,480 --> 00:08:50,720
a pseudo random seed

187
00:08:50,720 --> 00:08:53,440
in particular we will let the generator

188
00:08:53,440 --> 00:08:56,240
start from a short seat for each circuit

189
00:08:56,240 --> 00:08:58,240
and use this as a source of all the

190
00:08:58,240 --> 00:09:00,959
randomness that he uses to encrypt each

191
00:09:00,959 --> 00:09:05,360
circuit and produce m0 and 1 and m2

192
00:09:05,360 --> 00:09:07,680
that is a seed becomes a compact

193
00:09:07,680 --> 00:09:11,760
representation of each circuit

194
00:09:14,640 --> 00:09:17,360
now that the generator has garbled all n

195
00:09:17,360 --> 00:09:20,399
circuits he can concatenate them into a

196
00:09:20,399 --> 00:09:22,640
single string and send this string

197
00:09:22,640 --> 00:09:24,959
across the network to alice

198
00:09:24,959 --> 00:09:26,959
this would be the step in the standard

199
00:09:26,959 --> 00:09:29,600
javascript circuit approach

200
00:09:29,600 --> 00:09:32,000
after receiving this material alice

201
00:09:32,000 --> 00:09:33,920
would simply retrieve the circuit

202
00:09:33,920 --> 00:09:36,320
encryptions she wants to take and

203
00:09:36,320 --> 00:09:39,360
evaluate them

204
00:09:41,600 --> 00:09:44,320
in star car billing instead of sending

205
00:09:44,320 --> 00:09:47,839
m0 and 1 and m2 separately

206
00:09:47,839 --> 00:09:50,320
the generator adds these three values

207
00:09:50,320 --> 00:09:54,399
together using bitwise exclusive or

208
00:09:54,399 --> 00:09:56,600
here is where we have one in terms of

209
00:09:56,600 --> 00:09:58,320
communication

210
00:09:58,320 --> 00:10:00,720
in the standard garbage circuit approach

211
00:10:00,720 --> 00:10:03,839
we would have sent m0 m1 and m2

212
00:10:03,839 --> 00:10:05,200
separately

213
00:10:05,200 --> 00:10:08,000
but now we are sending the xor sum of

214
00:10:08,000 --> 00:10:11,279
these three values

215
00:10:13,680 --> 00:10:16,079
the generator then sends this compact

216
00:10:16,079 --> 00:10:19,839
stacked material to alice

217
00:10:25,760 --> 00:10:28,480
and from here we want that alice somehow

218
00:10:28,480 --> 00:10:31,839
recovers m0 that is the material

219
00:10:31,839 --> 00:10:33,920
corresponding to the circuit that she

220
00:10:33,920 --> 00:10:37,120
wants to evaluate

221
00:10:39,839 --> 00:10:42,079
recall that the generator holds the

222
00:10:42,079 --> 00:10:45,279
short seats which compactly represent m0

223
00:10:45,279 --> 00:10:47,839
m1 and m2

224
00:10:47,839 --> 00:10:50,880
indeed alice could learn m0 by receiving

225
00:10:50,880 --> 00:10:53,040
the seed zero

226
00:10:53,040 --> 00:10:56,320
however we want alice to learn m0

227
00:10:56,320 --> 00:10:58,800
without receiving the seed corresponding

228
00:10:58,800 --> 00:11:01,279
to the taken circuit as that would be

229
00:11:01,279 --> 00:11:02,880
insecure

230
00:11:02,880 --> 00:11:05,360
this is because from this c alice can

231
00:11:05,360 --> 00:11:09,600
derive all the garbage circuit keys

232
00:11:12,240 --> 00:11:15,279
instead we convey seats to alice for the

233
00:11:15,279 --> 00:11:17,920
circuits that will not be evaluated

234
00:11:17,920 --> 00:11:20,640
either by oblivious transfer or by

235
00:11:20,640 --> 00:11:22,800
encrypting them as part of the carbon

236
00:11:22,800 --> 00:11:25,800
circuit

237
00:11:28,079 --> 00:11:31,600
since circuits 1 and 2 are not evaluated

238
00:11:31,600 --> 00:11:34,800
alice obliviously receives the seats 1

239
00:11:34,800 --> 00:11:38,040
and 2.

240
00:11:43,440 --> 00:11:46,000
upon receiving these seeds alice can

241
00:11:46,000 --> 00:11:48,720
re-expand the seeds into materials and

242
00:11:48,720 --> 00:11:51,720
1m2

243
00:11:54,320 --> 00:11:59,360
then using xor alice can extract out m0

244
00:11:59,360 --> 00:12:02,000
now we achieved our goal that alice

245
00:12:02,000 --> 00:12:05,519
retrieved m0 but importantly she has

246
00:12:05,519 --> 00:12:10,600
never seen the seat corresponding to m0

247
00:12:12,320 --> 00:12:15,200
alice then evaluates m0

248
00:12:15,200 --> 00:12:17,680
note that the communication consisted of

249
00:12:17,680 --> 00:12:20,800
sending only a single longest material

250
00:12:20,800 --> 00:12:23,600
in terms of computation the generator

251
00:12:23,600 --> 00:12:25,920
only garbled and circuits while the

252
00:12:25,920 --> 00:12:29,120
evaluator garbage and -1 circuits that

253
00:12:29,120 --> 00:12:31,760
is all but the taken circuit

254
00:12:31,760 --> 00:12:35,120
thus for k equals one communication is

255
00:12:35,120 --> 00:12:38,639
improved and the computation complexity

256
00:12:38,639 --> 00:12:40,959
is the same as in the standard carbon

257
00:12:40,959 --> 00:12:44,000
circuit approach

258
00:12:45,839 --> 00:12:48,639
now let's consider the more general case

259
00:12:48,639 --> 00:12:51,200
when k is greater than 1 more

260
00:12:51,200 --> 00:12:52,399
specifically

261
00:12:52,399 --> 00:12:54,560
k equals two

262
00:12:54,560 --> 00:12:57,760
n still equals three that is we have

263
00:12:57,760 --> 00:13:01,920
three circuits c0 c1 and c2

264
00:13:01,920 --> 00:13:05,519
of which c0 and c1 are taken

265
00:13:05,519 --> 00:13:10,639
first we try the same approach as before

266
00:13:12,320 --> 00:13:14,880
the garbler produces the material for

267
00:13:14,880 --> 00:13:17,600
each circuit by expanding a short

268
00:13:17,600 --> 00:13:21,480
pseudo-random seed

269
00:13:22,800 --> 00:13:25,680
then he stacks the material and sends it

270
00:13:25,680 --> 00:13:28,399
to alice

271
00:13:33,519 --> 00:13:36,480
alice now needs to reconstruct m0 and

272
00:13:36,480 --> 00:13:38,959
and one corresponding to the taken

273
00:13:38,959 --> 00:13:41,518
circuits

274
00:13:43,199 --> 00:13:45,920
she also obliviously receives the seats

275
00:13:45,920 --> 00:13:49,839
for the circuits not taken

276
00:13:51,680 --> 00:13:56,399
in this case this is only seed 2.

277
00:13:59,760 --> 00:14:04,399
alice expands the seed into m2

278
00:14:05,680 --> 00:14:08,000
and exhausts it out from the stacked

279
00:14:08,000 --> 00:14:10,639
material

280
00:14:12,160 --> 00:14:14,240
it is impossible for alice to

281
00:14:14,240 --> 00:14:19,440
reconstruct m0 and m1 from m0 xor n1

282
00:14:19,440 --> 00:14:22,639
so what can we do

283
00:14:24,320 --> 00:14:28,240
importantly we observe that receiving c2

284
00:14:28,240 --> 00:14:30,480
is not sufficient to reconstruct the

285
00:14:30,480 --> 00:14:32,399
taken material

286
00:14:32,399 --> 00:14:35,279
furthermore i explained that it is not

287
00:14:35,279 --> 00:14:38,079
secure to send a seat to alice which

288
00:14:38,079 --> 00:14:42,319
corresponds to a taken circuit

289
00:14:43,440 --> 00:14:46,240
this implies that to naively solve the k

290
00:14:46,240 --> 00:14:49,519
out of n problem with stack garbling we

291
00:14:49,519 --> 00:14:52,560
need to generate k separate stacks in

292
00:14:52,560 --> 00:14:57,719
each stack must use n fresh garblings

293
00:14:58,800 --> 00:15:01,839
more specifically since k equals two we

294
00:15:01,839 --> 00:15:04,800
need two stacks note that the materials

295
00:15:04,800 --> 00:15:07,040
in stack one are different from those in

296
00:15:07,040 --> 00:15:09,680
stack zero although they represent the

297
00:15:09,680 --> 00:15:11,120
same functions

298
00:15:11,120 --> 00:15:13,519
this is exactly where the computation

299
00:15:13,519 --> 00:15:16,399
cost proportional to k times n

300
00:15:16,399 --> 00:15:20,320
garberlings comes in as n new materials

301
00:15:20,320 --> 00:15:23,600
are needed for each of the k stacks

302
00:15:23,600 --> 00:15:26,480
instead we would like to reuse the same

303
00:15:26,480 --> 00:15:29,759
n materials across the stacks which is

304
00:15:29,759 --> 00:15:32,079
precisely what we achieve in our stacked

305
00:15:32,079 --> 00:15:34,320
and staggered construction

306
00:15:34,320 --> 00:15:37,360
recall that our key observation is that

307
00:15:37,360 --> 00:15:39,680
we can view circuit materials as

308
00:15:39,680 --> 00:15:42,240
elements in a large galoa field

309
00:15:42,240 --> 00:15:44,480
and hence we can operate on them with

310
00:15:44,480 --> 00:15:46,160
linear algebra

311
00:15:46,160 --> 00:15:48,320
this will enable us to compute only a

312
00:15:48,320 --> 00:15:50,720
linear number of materials and then

313
00:15:50,720 --> 00:15:52,880
construct k linearly independent

314
00:15:52,880 --> 00:15:55,920
combinations of the same materials as

315
00:15:55,920 --> 00:15:58,399
the stacks first i will describe

316
00:15:58,399 --> 00:16:02,880
visually only then algebraically

317
00:16:04,079 --> 00:16:06,880
in this slide i show the two stacks in

318
00:16:06,880 --> 00:16:09,519
our stacked and staggered construction

319
00:16:09,519 --> 00:16:13,519
note that m0 m1 and m2 are same across

320
00:16:13,519 --> 00:16:16,800
the stacks that is there is a total of n

321
00:16:16,800 --> 00:16:18,240
materials

322
00:16:18,240 --> 00:16:20,959
while stack 0 is the same as in the stat

323
00:16:20,959 --> 00:16:22,399
garbling approach

324
00:16:22,399 --> 00:16:25,279
the materials in stack one are shifted

325
00:16:25,279 --> 00:16:27,839
before being absorbed together

326
00:16:27,839 --> 00:16:30,079
now it should be believable that these

327
00:16:30,079 --> 00:16:31,839
shifts provide some additional

328
00:16:31,839 --> 00:16:34,480
information that will enable alice to

329
00:16:34,480 --> 00:16:37,600
bit by bit and stack the taken materials

330
00:16:37,600 --> 00:16:39,920
i will get into details of unstacking

331
00:16:39,920 --> 00:16:41,040
later

332
00:16:41,040 --> 00:16:43,680
at this point i would like to emphasize

333
00:16:43,680 --> 00:16:46,000
that since we view the materials as

334
00:16:46,000 --> 00:16:48,399
elements in a galoa field we can

335
00:16:48,399 --> 00:16:51,120
multiply them by different powers of two

336
00:16:51,120 --> 00:16:54,079
which simply adds zeros and shifts each

337
00:16:54,079 --> 00:16:56,639
material within the stack

338
00:16:56,639 --> 00:16:58,720
this means we can pick our linear

339
00:16:58,720 --> 00:17:00,959
algebraic operations such that

340
00:17:00,959 --> 00:17:02,800
everything can be implemented with

341
00:17:02,800 --> 00:17:05,839
simple device exhaust and hence we

342
00:17:05,839 --> 00:17:08,880
obtain high performance we simply shift

343
00:17:08,880 --> 00:17:12,720
each material and xor it into a stack

344
00:17:12,720 --> 00:17:15,839
these simple stacking operations are far

345
00:17:15,839 --> 00:17:18,799
far cheaper than the garbling operations

346
00:17:18,799 --> 00:17:20,959
the result is that although we still

347
00:17:20,959 --> 00:17:23,760
need to construct k stacks we obtain

348
00:17:23,760 --> 00:17:26,400
performance that matches computation of

349
00:17:26,400 --> 00:17:28,720
the standard yao scarborough circuit

350
00:17:28,720 --> 00:17:30,880
approach and communication of stacked

351
00:17:30,880 --> 00:17:33,919
stark garberling

352
00:17:34,880 --> 00:17:36,960
we call our construction stacked and

353
00:17:36,960 --> 00:17:39,840
staggered because as in start garbling

354
00:17:39,840 --> 00:17:42,640
we stop that is exert the materials

355
00:17:42,640 --> 00:17:43,760
together

356
00:17:43,760 --> 00:17:46,960
however we also stagger that is shift

357
00:17:46,960 --> 00:17:49,679
the materials such that we construct k

358
00:17:49,679 --> 00:17:51,919
linearly independent combinations of

359
00:17:51,919 --> 00:17:53,840
these same materials

360
00:17:53,840 --> 00:17:56,480
now that we know how to stack i will get

361
00:17:56,480 --> 00:17:59,600
into how we unstack again i will first

362
00:17:59,600 --> 00:18:02,320
present the idea informally and only

363
00:18:02,320 --> 00:18:05,280
then algebraically recall that alice

364
00:18:05,280 --> 00:18:08,640
needs to learn m0 and m1 since those

365
00:18:08,640 --> 00:18:10,960
materials correspond to the taken

366
00:18:10,960 --> 00:18:14,720
circuits m2 is not taken and hence alice

367
00:18:14,720 --> 00:18:16,960
obtains a c that will enable her to

368
00:18:16,960 --> 00:18:20,320
reconstruct n2

369
00:18:21,919 --> 00:18:25,360
after reconstructing m2 alice can exert

370
00:18:25,360 --> 00:18:28,000
out from each stop taking care to shift

371
00:18:28,000 --> 00:18:32,799
m2 by the appropriate offset first

372
00:18:33,919 --> 00:18:36,559
now alice is left with stats containing

373
00:18:36,559 --> 00:18:38,799
only the taken materials

374
00:18:38,799 --> 00:18:41,039
note that alice can just retrieve one

375
00:18:41,039 --> 00:18:44,240
bit of m0 directly from the second stack

376
00:18:44,240 --> 00:18:46,799
she can then take this bit and xor it

377
00:18:46,799 --> 00:18:48,960
out with the corresponding position in

378
00:18:48,960 --> 00:18:50,400
stack zero

379
00:18:50,400 --> 00:18:53,280
this will give her one bit of m1 which

380
00:18:53,280 --> 00:18:55,360
can then be used to obtain another bit

381
00:18:55,360 --> 00:18:57,840
of m0 from stack 1.

382
00:18:57,840 --> 00:19:00,240
alice continues this bit by bit

383
00:19:00,240 --> 00:19:03,280
unstacking in this manner until she has

384
00:19:03,280 --> 00:19:08,160
recovered m0 and m1 in its

385
00:19:08,840 --> 00:19:13,760
entirety alice then evaluates m0 and m1

386
00:19:13,760 --> 00:19:16,559
i would like to emphasize that when k is

387
00:19:16,559 --> 00:19:19,600
greater than 2 this unstacking procedure

388
00:19:19,600 --> 00:19:22,559
gets much more complicated the algorithm

389
00:19:22,559 --> 00:19:24,960
must carefully coordinate the order in

390
00:19:24,960 --> 00:19:27,679
which bits are unstacked as we need to

391
00:19:27,679 --> 00:19:30,320
ensure we do not attempt to recover bits

392
00:19:30,320 --> 00:19:32,880
prematurely from each stack

393
00:19:32,880 --> 00:19:35,520
while i will not get into details we

394
00:19:35,520 --> 00:19:38,400
introduce a notion of a per stack delay

395
00:19:38,400 --> 00:19:40,720
which ensures that we do not try to

396
00:19:40,720 --> 00:19:44,720
unstack the bits prematurely

397
00:19:46,559 --> 00:19:49,280
now that i gave the intuition i will

398
00:19:49,280 --> 00:19:53,280
describe our construction algebraically

399
00:19:53,280 --> 00:19:56,240
following up on our informal discussion

400
00:19:56,240 --> 00:19:59,360
we need two stacks as k equals two

401
00:19:59,360 --> 00:20:02,080
stacking is simple we construct the

402
00:20:02,080 --> 00:20:04,720
first stack as a simple exclusive ore of

403
00:20:04,720 --> 00:20:06,559
the materials

404
00:20:06,559 --> 00:20:09,520
in the second stack we multiply m1 and

405
00:20:09,520 --> 00:20:13,520
m2 by 2 and 4 respectively

406
00:20:13,520 --> 00:20:16,640
this in practice shifts each material by

407
00:20:16,640 --> 00:20:20,159
one position from the preceding material

408
00:20:20,159 --> 00:20:22,960
hence we get the same stack as in the

409
00:20:22,960 --> 00:20:26,159
pictorial representation

410
00:20:26,159 --> 00:20:29,039
again we multiply the materials by

411
00:20:29,039 --> 00:20:31,919
powers of 2 such that everything can be

412
00:20:31,919 --> 00:20:34,960
implemented with simple bitwise exhaust

413
00:20:34,960 --> 00:20:38,159
hence stacking is very cheap

414
00:20:38,159 --> 00:20:40,960
additionally we reduce the number of

415
00:20:40,960 --> 00:20:44,159
bitwise xors needed to further optimize

416
00:20:44,159 --> 00:20:46,159
our stacking

417
00:20:46,159 --> 00:20:49,360
we observe that it is not necessary to

418
00:20:49,360 --> 00:20:53,440
include all n materials in each stack

419
00:20:53,440 --> 00:20:56,000
in practice each stack is used to

420
00:20:56,000 --> 00:20:58,640
recover a single material

421
00:20:58,640 --> 00:21:01,200
this means we need to ensure that each

422
00:21:01,200 --> 00:21:04,480
stack has at least one taken material to

423
00:21:04,480 --> 00:21:06,080
unstack

424
00:21:06,080 --> 00:21:06,960
hence

425
00:21:06,960 --> 00:21:10,320
k minus 1 materials can be excluded from

426
00:21:10,320 --> 00:21:11,679
each stack

427
00:21:11,679 --> 00:21:14,240
as a result each stack needs to have

428
00:21:14,240 --> 00:21:19,440
only n minus k plus one materials

429
00:21:21,280 --> 00:21:26,320
more formally to stack n materials m0 m1

430
00:21:26,320 --> 00:21:29,760
and m2 into k stacks s

431
00:21:29,760 --> 00:21:32,080
the generator simply multiplies the

432
00:21:32,080 --> 00:21:35,520
vector of materials by a stacking matrix

433
00:21:35,520 --> 00:21:37,200
a

434
00:21:37,200 --> 00:21:40,640
a is a key object in our formalization

435
00:21:40,640 --> 00:21:44,159
it is a k by n matrix and formalizes the

436
00:21:44,159 --> 00:21:47,360
bit shift distance for each material in

437
00:21:47,360 --> 00:21:49,120
each stack

438
00:21:49,120 --> 00:21:52,159
a key property of the stacking matrix is

439
00:21:52,159 --> 00:21:55,039
that any choice of k columns is linearly

440
00:21:55,039 --> 00:21:56,400
independent

441
00:21:56,400 --> 00:21:59,120
this means that any sub matrix with k

442
00:21:59,120 --> 00:22:01,280
columns is invertible

443
00:22:01,280 --> 00:22:03,360
we will use this property when

444
00:22:03,360 --> 00:22:05,200
unstacking

445
00:22:05,200 --> 00:22:07,520
next i will show a larger stacking

446
00:22:07,520 --> 00:22:10,320
matrix a so that it is easier to

447
00:22:10,320 --> 00:22:13,840
understand its structure

448
00:22:15,120 --> 00:22:18,240
i show a stacking matrix for k equals 4

449
00:22:18,240 --> 00:22:20,320
and n equals 6.

450
00:22:20,320 --> 00:22:24,000
notice that each matrix row has k minus

451
00:22:24,000 --> 00:22:27,360
1 that is three zeros

452
00:22:27,360 --> 00:22:30,000
other entries can be expressed as powers

453
00:22:30,000 --> 00:22:32,640
of two

454
00:22:35,360 --> 00:22:38,400
the powers of two increase with the rows

455
00:22:38,400 --> 00:22:41,679
that is in row 0 the powers do not

456
00:22:41,679 --> 00:22:42,960
increase

457
00:22:42,960 --> 00:22:47,280
in row 1 they increase by 1 and in row i

458
00:22:47,280 --> 00:22:50,320
they increase by i

459
00:22:50,320 --> 00:22:52,799
these properties again allow for an

460
00:22:52,799 --> 00:22:56,000
efficient algorithm that stacks material

461
00:22:56,000 --> 00:22:58,400
using only simple xors

462
00:22:58,400 --> 00:23:00,960
because multiplying by powers of two

463
00:23:00,960 --> 00:23:04,880
simply shifts the material in each stack

464
00:23:04,880 --> 00:23:09,640
now we return to our former example

465
00:23:11,200 --> 00:23:13,440
after the generator computes the vector

466
00:23:13,440 --> 00:23:19,400
of stax s he sends s to alice

467
00:23:23,280 --> 00:23:26,320
alice then obliviously receives a minus

468
00:23:26,320 --> 00:23:29,760
k that is one seed in our case

469
00:23:29,760 --> 00:23:35,000
corresponding to the circuits not taken

470
00:23:36,159 --> 00:23:37,679
in our example

471
00:23:37,679 --> 00:23:40,799
this is seat 2.

472
00:23:43,039 --> 00:23:47,120
from here alice reconstructs m2

473
00:23:47,120 --> 00:23:53,039
now alice is ready to unstack m0 nm1

474
00:23:56,080 --> 00:23:59,200
first alice removes all materials not

475
00:23:59,200 --> 00:24:00,400
taken

476
00:24:00,400 --> 00:24:02,960
and to only in our example from her

477
00:24:02,960 --> 00:24:04,400
stacks

478
00:24:04,400 --> 00:24:07,120
she does that by shifting m2 by the

479
00:24:07,120 --> 00:24:10,080
appropriate amount which means according

480
00:24:10,080 --> 00:24:11,520
to a

481
00:24:11,520 --> 00:24:14,720
before examining it with each stack

482
00:24:14,720 --> 00:24:17,760
the resulting vector s prime contains

483
00:24:17,760 --> 00:24:20,720
linear combinations of only the two

484
00:24:20,720 --> 00:24:24,240
taken materials

485
00:24:26,880 --> 00:24:30,000
to define how alice transforms these two

486
00:24:30,000 --> 00:24:33,200
stacks into the two taken materials we

487
00:24:33,200 --> 00:24:36,240
note the following equality

488
00:24:36,240 --> 00:24:37,520
on the left

489
00:24:37,520 --> 00:24:40,159
s prime is the vector of stacks of only

490
00:24:40,159 --> 00:24:42,480
the taken materials

491
00:24:42,480 --> 00:24:45,520
we can get these stacks by striking out

492
00:24:45,520 --> 00:24:47,919
from the stacking matrix all columns

493
00:24:47,919 --> 00:24:50,559
corresponding to the indices of circuits

494
00:24:50,559 --> 00:24:52,880
not taken

495
00:24:52,880 --> 00:24:56,559
in our case the taken indices are 0 and

496
00:24:56,559 --> 00:24:59,840
1 and hence we strike out the column at

497
00:24:59,840 --> 00:25:01,679
index 2

498
00:25:01,679 --> 00:25:04,400
then we multiply this modified stacking

499
00:25:04,400 --> 00:25:08,400
matrix by the vector of taken materials

500
00:25:08,400 --> 00:25:11,440
note that alice can compute as prime the

501
00:25:11,440 --> 00:25:14,480
stats of the taken materials as shown on

502
00:25:14,480 --> 00:25:16,159
the previous slides

503
00:25:16,159 --> 00:25:18,559
she can also compute the modified

504
00:25:18,559 --> 00:25:21,279
stacking matrix as the stacking matrix

505
00:25:21,279 --> 00:25:24,480
is public and she knows her k taken

506
00:25:24,480 --> 00:25:27,480
indices

507
00:25:29,360 --> 00:25:31,760
what alice wants to learn is the vector

508
00:25:31,760 --> 00:25:34,720
of taken materials she can thus solve

509
00:25:34,720 --> 00:25:37,120
the equation on the slide for the vector

510
00:25:37,120 --> 00:25:40,678
of taken materials

511
00:25:42,400 --> 00:25:45,120
thus to transform the two stacks into

512
00:25:45,120 --> 00:25:47,600
the two target materials

513
00:25:47,600 --> 00:25:49,840
alice needs to invert the modified

514
00:25:49,840 --> 00:25:51,520
stacking matrix

515
00:25:51,520 --> 00:25:54,320
she then multiplies this inverted matrix

516
00:25:54,320 --> 00:25:57,200
by s prime to recover the vector of

517
00:25:57,200 --> 00:25:59,200
taken materials

518
00:25:59,200 --> 00:26:01,440
i repeat that like our stacking

519
00:26:01,440 --> 00:26:04,559
procedure this unstacking can also be

520
00:26:04,559 --> 00:26:07,760
achieved using simplex only

521
00:26:07,760 --> 00:26:10,799
but unlike our stacking procedure

522
00:26:10,799 --> 00:26:13,279
this procedure is non-trivial

523
00:26:13,279 --> 00:26:15,760
so i hope that if you are interested you

524
00:26:15,760 --> 00:26:19,600
will take a look at our paper

525
00:26:22,159 --> 00:26:27,760
alice then evaluates m0 and m1

526
00:26:28,559 --> 00:26:30,799
we implemented our stockton staggered

527
00:26:30,799 --> 00:26:33,840
construction in c plus plus and reported

528
00:26:33,840 --> 00:26:36,480
experimental results obtained when

529
00:26:36,480 --> 00:26:39,600
running our system against both standard

530
00:26:39,600 --> 00:26:42,080
start garbling and standard garbage

531
00:26:42,080 --> 00:26:44,799
circuits without stacking

532
00:26:44,799 --> 00:26:47,279
we used all three implementations to

533
00:26:47,279 --> 00:26:50,000
handle k out of n circuits where each

534
00:26:50,000 --> 00:26:52,640
circuit was sha-256

535
00:26:52,640 --> 00:26:56,080
in this experiment we set n to 16 and

536
00:26:56,080 --> 00:26:59,360
then varied k from 2 to n minus 1.

537
00:26:59,360 --> 00:27:01,520
recall that our technique improves

538
00:27:01,520 --> 00:27:04,240
computation when evaluating k out of n

539
00:27:04,240 --> 00:27:07,440
circuits this figure demonstrates that

540
00:27:07,440 --> 00:27:09,760
our method achieves this computation

541
00:27:09,760 --> 00:27:12,000
improvement without sacrificing

542
00:27:12,000 --> 00:27:13,520
communication

543
00:27:13,520 --> 00:27:16,240
specifically our technique has similar

544
00:27:16,240 --> 00:27:18,320
communication to the start karballing

545
00:27:18,320 --> 00:27:21,320
method

546
00:27:22,159 --> 00:27:24,559
in this plot we show the wall clock

547
00:27:24,559 --> 00:27:26,720
runtime for all three approaches on a

548
00:27:26,720 --> 00:27:28,640
wide area network

549
00:27:28,640 --> 00:27:31,039
our experiment shows that we indeed

550
00:27:31,039 --> 00:27:32,840
concretely improve

551
00:27:32,840 --> 00:27:35,520
computation thus we do achieve the best

552
00:27:35,520 --> 00:27:37,919
of both worlds meaning we capture the

553
00:27:37,919 --> 00:27:40,000
low communication utilization of

554
00:27:40,000 --> 00:27:43,039
standard stat garbling but without high

555
00:27:43,039 --> 00:27:45,039
computation

556
00:27:45,039 --> 00:27:47,440
notice that our performance is roughly

557
00:27:47,440 --> 00:27:49,440
upper bounded by the performance of

558
00:27:49,440 --> 00:27:52,480
standard carbon circuit without stacking

559
00:27:52,480 --> 00:27:54,960
specifically our wall clock time

560
00:27:54,960 --> 00:27:58,080
approaches that of standard garbling as

561
00:27:58,080 --> 00:28:00,559
k approaches n

562
00:28:00,559 --> 00:28:02,799
this can be explained by our choice of

563
00:28:02,799 --> 00:28:04,880
stacking matrix a

564
00:28:04,880 --> 00:28:07,200
as k approaches n

565
00:28:07,200 --> 00:28:10,480
a features increasing numbers of zeros

566
00:28:10,480 --> 00:28:13,039
which reduces the cost to both stack and

567
00:28:13,039 --> 00:28:16,399
unstack material in the special case n

568
00:28:16,399 --> 00:28:19,679
equals k a features zeros everywhere

569
00:28:19,679 --> 00:28:22,080
except on one diagonal

570
00:28:22,080 --> 00:28:23,919
where it is once

571
00:28:23,919 --> 00:28:27,120
it is a mirror of the identity matrix

572
00:28:27,120 --> 00:28:29,600
hence in this special case our scheme

573
00:28:29,600 --> 00:28:32,080
and standard garbage circuit perform

574
00:28:32,080 --> 00:28:36,158
essentially identical actions

575
00:28:36,880 --> 00:28:39,919
in summary the key contribution is that

576
00:28:39,919 --> 00:28:42,960
we improve carbon circuit evaluation of

577
00:28:42,960 --> 00:28:46,080
k out of n functions where the k choices

578
00:28:46,080 --> 00:28:47,840
are known to the garbage circuit

579
00:28:47,840 --> 00:28:49,360
evaluator

580
00:28:49,360 --> 00:28:51,440
we retain the start garbling

581
00:28:51,440 --> 00:28:53,960
communication complexity while

582
00:28:53,960 --> 00:28:56,640
simultaneously retain the computation

583
00:28:56,640 --> 00:29:00,080
complexity of standard garbage circuit

584
00:29:00,080 --> 00:29:02,559
the result is we get a significant

585
00:29:02,559 --> 00:29:05,440
concrete improvement over both start

586
00:29:05,440 --> 00:29:07,600
garbling and the standard garbage

587
00:29:07,600 --> 00:29:09,279
circuit approach

588
00:29:09,279 --> 00:29:13,440
for example for n equals 128

589
00:29:13,440 --> 00:29:16,799
and k equals 16 we improve over start

590
00:29:16,799 --> 00:29:20,880
garbling by approximately factor 7.7 and

591
00:29:20,880 --> 00:29:23,039
over yao's carbohydrate circuit by

592
00:29:23,039 --> 00:29:25,120
factor 4.8

593
00:29:25,120 --> 00:29:27,840
thank you for listening

