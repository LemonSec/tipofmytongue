1
00:00:00,480 --> 00:00:02,800
hello everyone um today we're gonna

2
00:00:02,800 --> 00:00:04,480
present the improved programmable

3
00:00:04,480 --> 00:00:06,480
bootstrapping with larger precision and

4
00:00:06,480 --> 00:00:09,599
efficient arithmetic circuit for tfha

5
00:00:09,599 --> 00:00:11,519
this is a working collaboration between

6
00:00:11,519 --> 00:00:14,400
me ilaria lottie damian li

7
00:00:14,400 --> 00:00:16,880
jean batister fila and samuel tap

8
00:00:16,880 --> 00:00:18,640
the four of us today are gonna take care

9
00:00:18,640 --> 00:00:21,520
of the presentation

10
00:00:21,680 --> 00:00:24,000
so before we start uh let's see a little

11
00:00:24,000 --> 00:00:25,760
overview of what we're gonna present

12
00:00:25,760 --> 00:00:27,599
today so the presentation is gonna be

13
00:00:27,599 --> 00:00:30,400
split in five major parts we're going to

14
00:00:30,400 --> 00:00:31,599
start with a

15
00:00:31,599 --> 00:00:33,760
introduction of the tfh schema an

16
00:00:33,760 --> 00:00:36,000
overview of the tfh schema then we're

17
00:00:36,000 --> 00:00:38,160
going to present our improvements um

18
00:00:38,160 --> 00:00:40,960
which are the pbs mini loot the bfv

19
00:00:40,960 --> 00:00:44,239
product into tfh and the ypbs and then

20
00:00:44,239 --> 00:00:45,360
we're going to finish with some

21
00:00:45,360 --> 00:00:48,399
challenges and conclusions

22
00:00:48,399 --> 00:00:50,719
okay so before we start talking about

23
00:00:50,719 --> 00:00:54,079
tfh um let's understand what is the fhe

24
00:00:54,079 --> 00:00:56,239
so fhe stands for fully homomorphic

25
00:00:56,239 --> 00:00:57,280
encryption

26
00:00:57,280 --> 00:00:59,600
and it's a new technology allowing to do

27
00:00:59,600 --> 00:01:02,000
computations over encrypted data every

28
00:01:02,000 --> 00:01:03,600
encrypted messages

29
00:01:03,600 --> 00:01:05,600
so in the slides you're going to often

30
00:01:05,600 --> 00:01:08,640
see the messages encrypted inside

31
00:01:08,640 --> 00:01:11,119
a box this as instance in the slide a

32
00:01:11,119 --> 00:01:13,040
little blue box with a

33
00:01:13,040 --> 00:01:15,200
with a lock on the bottom this means the

34
00:01:15,200 --> 00:01:16,640
encryption and the message is going to

35
00:01:16,640 --> 00:01:18,799
be x and y in this

36
00:01:18,799 --> 00:01:20,080
in the slide

37
00:01:20,080 --> 00:01:22,000
so in practice what happens in

38
00:01:22,000 --> 00:01:23,920
homomorphic encryption is that if we add

39
00:01:23,920 --> 00:01:26,080
the homomorphically to ciphertext or if

40
00:01:26,080 --> 00:01:27,840
we multiply homomorphically to

41
00:01:27,840 --> 00:01:30,240
ciphertext the result is going to be a

42
00:01:30,240 --> 00:01:32,720
new ciphertext encrypting the addition

43
00:01:32,720 --> 00:01:34,320
and the multiplication of the original

44
00:01:34,320 --> 00:01:36,960
messages respectively

45
00:01:36,960 --> 00:01:38,880
by combining addition and multiplication

46
00:01:38,880 --> 00:01:41,280
we can possibly evaluate any function

47
00:01:41,280 --> 00:01:43,360
and the type of messages we can treat in

48
00:01:43,360 --> 00:01:45,200
homomorphic encryption are values we can

49
00:01:45,200 --> 00:01:48,720
have bits integers real messages

50
00:01:48,720 --> 00:01:51,119
so the most annoying part in homomorphic

51
00:01:51,119 --> 00:01:53,040
encryption is what we call the the noise

52
00:01:53,040 --> 00:01:55,840
growth um to be more clear what happens

53
00:01:55,840 --> 00:01:58,880
when we encrypt them is that we add some

54
00:01:58,880 --> 00:02:00,719
little amount of noise this little

55
00:02:00,719 --> 00:02:02,799
randomness that is measured in the

56
00:02:02,799 --> 00:02:05,119
slides with um with this little

57
00:02:05,119 --> 00:02:07,840
thermometer and when we start uh when we

58
00:02:07,840 --> 00:02:08,800
encrypt

59
00:02:08,800 --> 00:02:11,280
the noise is very very small however

60
00:02:11,280 --> 00:02:13,440
when we start computing homomorphic

61
00:02:13,440 --> 00:02:16,239
operations the noise grows and when we

62
00:02:16,239 --> 00:02:18,319
do additions and linear combination the

63
00:02:18,319 --> 00:02:19,760
noise is

64
00:02:19,760 --> 00:02:22,080
grows a little bit however when we do

65
00:02:22,080 --> 00:02:24,640
multiplication and non-linear operations

66
00:02:24,640 --> 00:02:27,120
uh the noise grows faster and the

67
00:02:27,120 --> 00:02:28,959
problem is that if there is too much

68
00:02:28,959 --> 00:02:30,480
noise and especially if the noise

69
00:02:30,480 --> 00:02:32,640
reaches a limit a certain limit that in

70
00:02:32,640 --> 00:02:34,400
the slides are going to be is going to

71
00:02:34,400 --> 00:02:38,080
be um indicated by this horizontal red

72
00:02:38,080 --> 00:02:40,640
line in thermometers then we risk to

73
00:02:40,640 --> 00:02:43,120
have an incorrect decryption

74
00:02:43,120 --> 00:02:44,800
um

75
00:02:44,800 --> 00:02:47,040
thanks uh for us

76
00:02:47,040 --> 00:02:48,480
there is a technique called the

77
00:02:48,480 --> 00:02:50,560
bootstrapping that allows us to deal

78
00:02:50,560 --> 00:02:52,879
with this noise growth problem

79
00:02:52,879 --> 00:02:54,959
and the tfh the scheme that we're gonna

80
00:02:54,959 --> 00:02:57,360
use today has a bootstrapping so the

81
00:02:57,360 --> 00:03:00,239
bootstrapping of tfh is very special

82
00:03:00,239 --> 00:03:02,480
as any bootstrapping it allows to reduce

83
00:03:02,480 --> 00:03:04,800
the noise inside ciphertext so in

84
00:03:04,800 --> 00:03:07,200
particular it takes an input what we

85
00:03:07,200 --> 00:03:09,440
called an lwe ciphertext we're going to

86
00:03:09,440 --> 00:03:10,959
explain um

87
00:03:10,959 --> 00:03:12,879
in a few slides what it is

88
00:03:12,879 --> 00:03:15,599
um there is a noisy and

89
00:03:15,599 --> 00:03:17,599
by using a bootstrapping key which is an

90
00:03:17,599 --> 00:03:19,519
encryption of the secret key originally

91
00:03:19,519 --> 00:03:22,159
used to encrypt the x it will evaluate a

92
00:03:22,159 --> 00:03:24,400
decryption circuit and produce a new

93
00:03:24,400 --> 00:03:25,760
cipher text

94
00:03:25,760 --> 00:03:28,159
of the type lwe as well

95
00:03:28,159 --> 00:03:30,560
with less noise inside so in practice it

96
00:03:30,560 --> 00:03:33,599
refreshes the ciphertext noise

97
00:03:33,599 --> 00:03:35,360
and the boost tracking of tfh is even

98
00:03:35,360 --> 00:03:37,200
more special because at the same time

99
00:03:37,200 --> 00:03:39,680
that he reduces the noise is also able

100
00:03:39,680 --> 00:03:42,720
to evaluate a lookup table

101
00:03:42,720 --> 00:03:45,280
so the result is not only going to be

102
00:03:45,280 --> 00:03:47,760
the same encryption of the same message

103
00:03:47,760 --> 00:03:49,920
with less noise but an encryption of lo

104
00:03:49,920 --> 00:03:51,200
ol of x

105
00:03:51,200 --> 00:03:53,280
where l of x is the position

106
00:03:53,280 --> 00:03:56,239
corresponding to x the input inside the

107
00:03:56,239 --> 00:03:58,239
lookup table so the result is going to

108
00:03:58,239 --> 00:04:01,200
be l of x with less noise

109
00:04:01,200 --> 00:04:04,159
so this technique is actually uh and in

110
00:04:04,159 --> 00:04:05,840
the in the rest of the slides we're

111
00:04:05,840 --> 00:04:07,680
going to often call

112
00:04:07,680 --> 00:04:08,640
this

113
00:04:08,640 --> 00:04:10,799
technique pbs for programmable

114
00:04:10,799 --> 00:04:12,879
bootstrapping

115
00:04:12,879 --> 00:04:15,840
um before we try to understand how the

116
00:04:15,840 --> 00:04:18,320
bootstrapping work let's uh um let's

117
00:04:18,320 --> 00:04:20,798
check what are the ciphertext using tfhe

118
00:04:20,798 --> 00:04:22,560
so first of all what is an lwe

119
00:04:22,560 --> 00:04:23,759
ciphertext

120
00:04:23,759 --> 00:04:24,560
well

121
00:04:24,560 --> 00:04:28,000
lw ciphertext is a tuple a b where a is

122
00:04:28,000 --> 00:04:31,120
a uniformly random vector and b is equal

123
00:04:31,120 --> 00:04:32,880
to the inner product between this

124
00:04:32,880 --> 00:04:35,280
uniformly random vector a and the secret

125
00:04:35,280 --> 00:04:36,720
key

126
00:04:36,720 --> 00:04:38,479
and then we have an addition of the

127
00:04:38,479 --> 00:04:41,440
message rescale to a certain

128
00:04:41,440 --> 00:04:44,320
to a certain delta uh and the error so

129
00:04:44,320 --> 00:04:47,040
the error is generally a gaussian error

130
00:04:47,040 --> 00:04:48,320
um

131
00:04:48,320 --> 00:04:50,320
sampled with a certain variance and the

132
00:04:50,320 --> 00:04:52,240
variance is going to be indicated in the

133
00:04:52,240 --> 00:04:54,000
thermometer

134
00:04:54,000 --> 00:04:55,440
um

135
00:04:55,440 --> 00:04:57,840
the lw cipher texts are very nice

136
00:04:57,840 --> 00:05:00,000
because they have homomorphic properties

137
00:05:00,000 --> 00:05:01,680
and especially they are homomorphic with

138
00:05:01,680 --> 00:05:03,360
respect to the addition and in the

139
00:05:03,360 --> 00:05:05,039
general multiplication

140
00:05:05,039 --> 00:05:07,520
in tfh we not only use the lwe

141
00:05:07,520 --> 00:05:09,680
ciphertext but we use also two other

142
00:05:09,680 --> 00:05:11,440
cipher texts

143
00:05:11,440 --> 00:05:13,919
the first one is a wrinkle we cipher

144
00:05:13,919 --> 00:05:15,919
text which are homomorphic with respect

145
00:05:15,919 --> 00:05:17,199
to the addition and the constant

146
00:05:17,199 --> 00:05:18,560
multiplication

147
00:05:18,560 --> 00:05:21,280
and ring jsw cipher text which are

148
00:05:21,280 --> 00:05:23,440
homomorphic with respect to addition

149
00:05:23,440 --> 00:05:24,800
constant multiplication and

150
00:05:24,800 --> 00:05:27,039
multiplication as well so this means

151
00:05:27,039 --> 00:05:28,800
that when we have two ring adjustable

152
00:05:28,800 --> 00:05:30,720
use ciphertext we can multiply them

153
00:05:30,720 --> 00:05:32,320
together and the result is going to be

154
00:05:32,320 --> 00:05:34,639
our ingestable ciphertext containing the

155
00:05:34,639 --> 00:05:36,960
product of the messages

156
00:05:36,960 --> 00:05:39,520
there is an additional operation in tfh

157
00:05:39,520 --> 00:05:41,440
that is largely used which is called the

158
00:05:41,440 --> 00:05:43,840
external product and it's an operation

159
00:05:43,840 --> 00:05:46,320
between a ring jsw cipher text and a

160
00:05:46,320 --> 00:05:48,560
wrinkle we cipher text

161
00:05:48,560 --> 00:05:50,400
and the result is going to be a wrinkle

162
00:05:50,400 --> 00:05:52,080
we cipher ciphertext encrypting the

163
00:05:52,080 --> 00:05:55,199
product of the messages

164
00:05:55,199 --> 00:05:58,000
okay so now that we saw um what are the

165
00:05:58,000 --> 00:05:59,919
ciphertext in tfg let's try to

166
00:05:59,919 --> 00:06:02,720
understand how the bootstrapping is done

167
00:06:02,720 --> 00:06:04,880
so just to summarize what we said before

168
00:06:04,880 --> 00:06:07,039
we're going to have an lwe ciphertexting

169
00:06:07,039 --> 00:06:08,960
input quite noisy

170
00:06:08,960 --> 00:06:10,479
we're going to take also an input a

171
00:06:10,479 --> 00:06:12,560
lookup table that we want to evaluate

172
00:06:12,560 --> 00:06:14,319
and the bootstrapping key that in the

173
00:06:14,319 --> 00:06:17,120
case of kfc is a list of ring jsw cipher

174
00:06:17,120 --> 00:06:17,919
text

175
00:06:17,919 --> 00:06:19,280
we're not going to see the details

176
00:06:19,280 --> 00:06:20,880
because this is not important for the

177
00:06:20,880 --> 00:06:23,600
comprehension of the presentation

178
00:06:23,600 --> 00:06:24,880
the output

179
00:06:24,880 --> 00:06:26,560
as announced before is going to be again

180
00:06:26,560 --> 00:06:29,440
an lwe ciphertext this time encrypting l

181
00:06:29,440 --> 00:06:30,720
of m

182
00:06:30,720 --> 00:06:33,039
with less noise

183
00:06:33,039 --> 00:06:34,720
so what else what is the operation that

184
00:06:34,720 --> 00:06:36,479
we evaluate during bootstrapping well we

185
00:06:36,479 --> 00:06:38,400
homomorphically evaluate the decryption

186
00:06:38,400 --> 00:06:41,520
algorithm of the lwe um encryption and

187
00:06:41,520 --> 00:06:43,520
the decryption algorithm consists in two

188
00:06:43,520 --> 00:06:45,520
major steps the first one is the

189
00:06:45,520 --> 00:06:48,560
computation of b minus a times s which

190
00:06:48,560 --> 00:06:50,400
by solving the equations i should show

191
00:06:50,400 --> 00:06:53,039
you before uh gives us an output delta m

192
00:06:53,039 --> 00:06:55,199
plus the error and the second step is a

193
00:06:55,199 --> 00:06:57,440
rescaling and rounding allowing us to

194
00:06:57,440 --> 00:06:59,360
retrieve the message m

195
00:06:59,360 --> 00:07:01,599
so in order to better understand what is

196
00:07:01,599 --> 00:07:04,080
coming next it's important that we we

197
00:07:04,080 --> 00:07:07,360
visualize uh what is the lwe input so

198
00:07:07,360 --> 00:07:10,240
delta m plus the error so you can always

199
00:07:10,240 --> 00:07:13,199
imagine it as a list of bits where we

200
00:07:13,199 --> 00:07:15,599
have the message that is put in the most

201
00:07:15,599 --> 00:07:17,680
significant bits and the error that is

202
00:07:17,680 --> 00:07:19,520
in the least significant bits and in

203
00:07:19,520 --> 00:07:21,599
this presentation the message

204
00:07:21,599 --> 00:07:23,280
is gonna um

205
00:07:23,280 --> 00:07:24,240
it's gonna

206
00:07:24,240 --> 00:07:27,039
get uh values between zero and p minus

207
00:07:27,039 --> 00:07:28,880
one

208
00:07:28,880 --> 00:07:31,120
okay so um how does the bootstrapping

209
00:07:31,120 --> 00:07:33,440
work so we have a first step that is

210
00:07:33,440 --> 00:07:35,360
called the modulus switching

211
00:07:35,360 --> 00:07:37,440
which is a step of switching from the

212
00:07:37,440 --> 00:07:39,840
modulus queue which is the original

213
00:07:39,840 --> 00:07:42,240
module of ciphertext modules and a

214
00:07:42,240 --> 00:07:44,800
modulo to n which means that we are

215
00:07:44,800 --> 00:07:46,400
going to select

216
00:07:46,400 --> 00:07:49,199
the log to n more significant bits

217
00:07:49,199 --> 00:07:52,000
inside this homomorphically of the input

218
00:07:52,000 --> 00:07:54,080
so what happens in practice is that by

219
00:07:54,080 --> 00:07:56,560
selecting this to n

220
00:07:56,560 --> 00:07:59,360
log to n more significant bits um we're

221
00:07:59,360 --> 00:08:01,520
gonna preserve them as such because the

222
00:08:01,520 --> 00:08:03,599
message is in the most significant bits

223
00:08:03,599 --> 00:08:06,000
and if the error is not too big before

224
00:08:06,000 --> 00:08:07,680
entering the bootstrapping then the

225
00:08:07,680 --> 00:08:09,680
message will also be preserved after

226
00:08:09,680 --> 00:08:11,759
module switching

227
00:08:11,759 --> 00:08:13,759
the second step is a description of the

228
00:08:13,759 --> 00:08:16,160
lookup table inside the polynomial

229
00:08:16,160 --> 00:08:18,479
v modulo x n plus one

230
00:08:18,479 --> 00:08:19,759
in which we're going to put the sum

231
00:08:19,759 --> 00:08:22,240
redundancy so uh what does it mean it

232
00:08:22,240 --> 00:08:23,360
means that

233
00:08:23,360 --> 00:08:25,680
if the vector you're seeing in the slide

234
00:08:25,680 --> 00:08:26,639
is

235
00:08:26,639 --> 00:08:28,400
a vector representing the coefficients

236
00:08:28,400 --> 00:08:31,199
of a polynomial modulo x n plus one

237
00:08:31,199 --> 00:08:32,880
we're going to have a multiple

238
00:08:32,880 --> 00:08:34,479
repetitions of the elements of the

239
00:08:34,479 --> 00:08:36,000
lookup table so we're going to start

240
00:08:36,000 --> 00:08:38,640
with many repetitions of l0 then many

241
00:08:38,640 --> 00:08:41,599
repetitions of l1 and so on until lp

242
00:08:41,599 --> 00:08:43,440
minus one

243
00:08:43,440 --> 00:08:44,880
and then the third step is going to be

244
00:08:44,880 --> 00:08:48,160
our rotation of this uh polynomial um of

245
00:08:48,160 --> 00:08:50,880
the delta m plus error position well

246
00:08:50,880 --> 00:08:53,360
delta m plus the error are gonna be the

247
00:08:53,360 --> 00:08:55,519
result of the module switching

248
00:08:55,519 --> 00:08:57,600
so we're not going to check into detail

249
00:08:57,600 --> 00:09:00,480
uh this step this is performed in tfhe

250
00:09:00,480 --> 00:09:03,440
by using a loop of external products

251
00:09:03,440 --> 00:09:06,080
and um the final result of this

252
00:09:06,080 --> 00:09:08,560
operation is a wrinkle w encryption of

253
00:09:08,560 --> 00:09:10,800
the same vector rotated

254
00:09:10,800 --> 00:09:11,519
and

255
00:09:11,519 --> 00:09:13,519
the what happens after the rotation is

256
00:09:13,519 --> 00:09:16,240
that the coefficient uh the were

257
00:09:16,240 --> 00:09:18,080
associated to l of m

258
00:09:18,080 --> 00:09:20,240
are gonna move to the first position of

259
00:09:20,240 --> 00:09:22,480
the vector and then the last step was

260
00:09:22,480 --> 00:09:24,160
going to be uh what we call a sample

261
00:09:24,160 --> 00:09:26,080
extraction which consists in extracting

262
00:09:26,080 --> 00:09:28,959
the first element of this polynomial

263
00:09:28,959 --> 00:09:31,600
into an lw ciphertext and since so the

264
00:09:31,600 --> 00:09:34,240
first element was l of m

265
00:09:34,240 --> 00:09:36,720
then um is we're going to obtain an lw

266
00:09:36,720 --> 00:09:39,200
encryption of l of m with less noise as

267
00:09:39,200 --> 00:09:41,920
expected before

268
00:09:41,920 --> 00:09:44,480
okay so the tfh boost wrapping similar

269
00:09:44,480 --> 00:09:46,640
very a very powerful actually is a very

270
00:09:46,640 --> 00:09:49,200
powerful tool but unfortunately has some

271
00:09:49,200 --> 00:09:50,480
limitations

272
00:09:50,480 --> 00:09:52,640
and the major limitation is due to the

273
00:09:52,640 --> 00:09:55,839
fact that we work modular x n plus one

274
00:09:55,839 --> 00:09:57,440
so in order to be more clear what

275
00:09:57,440 --> 00:09:59,360
happens when we work modulo x and plus

276
00:09:59,360 --> 00:10:02,880
one so we have polynomial of size n of

277
00:10:02,880 --> 00:10:05,279
with n coefficients and the since the

278
00:10:05,279 --> 00:10:08,880
rotation um modulus n plus 1 is of order

279
00:10:08,880 --> 00:10:09,839
2n

280
00:10:09,839 --> 00:10:12,079
what happens is that it exists a sort of

281
00:10:12,079 --> 00:10:13,839
imaginary part

282
00:10:13,839 --> 00:10:16,640
of size n as well which contains exactly

283
00:10:16,640 --> 00:10:18,880
the same elements of the first part the

284
00:10:18,880 --> 00:10:22,000
first n elements but with a minus if

285
00:10:22,000 --> 00:10:24,160
sign in front of them

286
00:10:24,160 --> 00:10:27,200
so what happened is the following see if

287
00:10:27,200 --> 00:10:29,920
the most significant bit of our message

288
00:10:29,920 --> 00:10:31,440
is equal to zero

289
00:10:31,440 --> 00:10:34,160
during the rotation we're gonna find an

290
00:10:34,160 --> 00:10:36,240
element inside the first

291
00:10:36,240 --> 00:10:38,959
n coefficient so an element of v

292
00:10:38,959 --> 00:10:41,200
uh and the result is gonna be exactly l

293
00:10:41,200 --> 00:10:42,320
of m

294
00:10:42,320 --> 00:10:45,200
however if in the the most significant

295
00:10:45,200 --> 00:10:47,360
bit of the message is gonna be equal to

296
00:10:47,360 --> 00:10:48,240
one

297
00:10:48,240 --> 00:10:50,880
after the rotation the result is gonna

298
00:10:50,880 --> 00:10:53,519
be in the let's say imaginary part and

299
00:10:53,519 --> 00:10:56,240
so the result is not gonna be l of m but

300
00:10:56,240 --> 00:10:58,880
minus l of m instead

301
00:10:58,880 --> 00:11:01,680
so if we want to always have alabama as

302
00:11:01,680 --> 00:11:04,800
a result uh we have to know the first

303
00:11:04,800 --> 00:11:06,399
and most significant bit of the message

304
00:11:06,399 --> 00:11:08,880
and especially in general uh we're gonna

305
00:11:08,880 --> 00:11:11,920
fix this more significant beta to zero

306
00:11:11,920 --> 00:11:14,480
and we're gonna try to keep it equal to

307
00:11:14,480 --> 00:11:16,959
zero all the time and this is actually a

308
00:11:16,959 --> 00:11:19,040
a big limitation

309
00:11:19,040 --> 00:11:20,959
so in this paper what we try to do is to

310
00:11:20,959 --> 00:11:22,880
overcome this limitation together with

311
00:11:22,880 --> 00:11:25,519
other tfh limitations

312
00:11:25,519 --> 00:11:27,839
um in the rest of the presentation uh

313
00:11:27,839 --> 00:11:30,160
you're going to see our contribution so

314
00:11:30,160 --> 00:11:32,000
we're going to start with uh what we

315
00:11:32,000 --> 00:11:35,040
call pbs mini luto which is a technique

316
00:11:35,040 --> 00:11:37,200
allowing us to evaluate several lookup

317
00:11:37,200 --> 00:11:39,200
tables per bootstrapping on the same

318
00:11:39,200 --> 00:11:40,800
input

319
00:11:40,800 --> 00:11:43,040
then we're gonna see how to use the

320
00:11:43,040 --> 00:11:45,680
bfv-like multiplication into tfh to

321
00:11:45,680 --> 00:11:47,760
improve the tfh techniques

322
00:11:47,760 --> 00:11:49,600
and this was especially possible thanks

323
00:11:49,600 --> 00:11:51,760
to a tight noise analysis

324
00:11:51,760 --> 00:11:53,680
and finally we're gonna see what we call

325
00:11:53,680 --> 00:11:56,240
a wall pbs which is a pbs without a bit

326
00:11:56,240 --> 00:11:57,440
of padding

327
00:11:57,440 --> 00:11:59,200
which is the technique allowing us to

328
00:11:59,200 --> 00:12:01,200
overcome the limitation i just described

329
00:12:01,200 --> 00:12:02,399
about

330
00:12:02,399 --> 00:12:04,480
the most significant bit

331
00:12:04,480 --> 00:12:07,200
set to zero

332
00:12:08,240 --> 00:12:10,240
so now we are going to have a look on a

333
00:12:10,240 --> 00:12:13,200
new method which is called bbs miniboots

334
00:12:13,200 --> 00:12:15,680
and allows us to evaluate many functions

335
00:12:15,680 --> 00:12:19,120
into one single pbs

336
00:12:19,120 --> 00:12:20,880
first we're going to introduce a new

337
00:12:20,880 --> 00:12:22,560
tool which is called generalized

338
00:12:22,560 --> 00:12:23,600
strapping

339
00:12:23,600 --> 00:12:25,920
and it will act on the module switching

340
00:12:25,920 --> 00:12:27,120
which is the first step of the

341
00:12:27,120 --> 00:12:28,320
bootstrapping

342
00:12:28,320 --> 00:12:30,480
so in the usual strapping

343
00:12:30,480 --> 00:12:33,519
the first step required to shift from

344
00:12:33,519 --> 00:12:35,680
ciphertext which is encoded over qubits

345
00:12:35,680 --> 00:12:38,000
into ciphertext which is only encoded

346
00:12:38,000 --> 00:12:40,720
over two m bits and that the frame we

347
00:12:40,720 --> 00:12:42,800
obtain after this module switching

348
00:12:42,800 --> 00:12:45,040
contains the most significant bits

349
00:12:45,040 --> 00:12:47,200
so the idea is to add more degrees of

350
00:12:47,200 --> 00:12:49,200
freedom to this step

351
00:12:49,200 --> 00:12:50,720
so first

352
00:12:50,720 --> 00:12:52,720
we want to choose the position of the

353
00:12:52,720 --> 00:12:55,360
most significant bit which will be

354
00:12:55,360 --> 00:12:58,240
retained after model switching so

355
00:12:58,240 --> 00:13:00,000
for instance we define new variable

356
00:13:00,000 --> 00:13:01,680
which is called kpa

357
00:13:01,680 --> 00:13:03,600
and this kappa in this example is

358
00:13:03,600 --> 00:13:05,279
defined to two

359
00:13:05,279 --> 00:13:07,680
so in this case after module switching

360
00:13:07,680 --> 00:13:09,519
this means that we have shifted from two

361
00:13:09,519 --> 00:13:12,639
bits from the most significant bits and

362
00:13:12,639 --> 00:13:14,800
so that if our message encrypted was

363
00:13:14,800 --> 00:13:17,279
only originally defined as m prime

364
00:13:17,279 --> 00:13:19,600
concatenated with m after the module

365
00:13:19,600 --> 00:13:22,000
switching will only have the encryption

366
00:13:22,000 --> 00:13:26,000
on n since we have shifted from two bits

367
00:13:26,000 --> 00:13:28,160
we can also define a shifting which is

368
00:13:28,160 --> 00:13:30,800
negative so that the kappa is negative

369
00:13:30,800 --> 00:13:32,240
this means that after the modulus

370
00:13:32,240 --> 00:13:34,560
switching we'll add some random bit

371
00:13:34,560 --> 00:13:36,480
as the most significant one

372
00:13:36,480 --> 00:13:38,000
in the frame which is retained after the

373
00:13:38,000 --> 00:13:39,440
mod switching

374
00:13:39,440 --> 00:13:42,240
in this example we define kappa as -1 so

375
00:13:42,240 --> 00:13:44,000
this means that we want to shift from

376
00:13:44,000 --> 00:13:46,720
one bit after the modulus q so that

377
00:13:46,720 --> 00:13:48,560
after the mode switching we'll have

378
00:13:48,560 --> 00:13:50,720
random one random bits as the most

379
00:13:50,720 --> 00:13:53,440
significant bit

380
00:13:54,000 --> 00:13:56,560
the second approaches uh is about

381
00:13:56,560 --> 00:13:58,639
shifting from the right side but in this

382
00:13:58,639 --> 00:14:00,399
case we'll define what we call a right

383
00:14:00,399 --> 00:14:03,040
padding in this case the idea is to have

384
00:14:03,040 --> 00:14:04,959
some bits that we will unsure to be

385
00:14:04,959 --> 00:14:07,760
equal to 0 after the model switching

386
00:14:07,760 --> 00:14:09,920
this is defined by the variable theta

387
00:14:09,920 --> 00:14:11,760
and theta will represent the number of

388
00:14:11,760 --> 00:14:13,519
bits which are equal to 0 after the

389
00:14:13,519 --> 00:14:16,000
model is switching so in this example we

390
00:14:16,000 --> 00:14:18,639
define theta as two so that after the

391
00:14:18,639 --> 00:14:20,240
model switching the two least

392
00:14:20,240 --> 00:14:24,320
significant bits are now equal to zero

393
00:14:25,519 --> 00:14:28,000
we can combine with these two approaches

394
00:14:28,000 --> 00:14:29,680
so that in fact this offers us the

395
00:14:29,680 --> 00:14:31,760
possibility to choose the frame which

396
00:14:31,760 --> 00:14:33,519
will be module switch

397
00:14:33,519 --> 00:14:35,760
so with the kappa we shift from kappa

398
00:14:35,760 --> 00:14:38,079
bits and with the theta we ensure that

399
00:14:38,079 --> 00:14:39,920
the last theta bits will be equal to

400
00:14:39,920 --> 00:14:41,440
zero so that the frame of the middle

401
00:14:41,440 --> 00:14:44,959
switching is now up to our choice

402
00:14:44,959 --> 00:14:47,120
the first application of this uh

403
00:14:47,120 --> 00:14:48,959
generalized strapping will be in the pbs

404
00:14:48,959 --> 00:14:50,240
mini leads

405
00:14:50,240 --> 00:14:53,279
so just for recall in the pbs normally

406
00:14:53,279 --> 00:14:56,079
we have one pbs for one loot and that at

407
00:14:56,079 --> 00:14:58,240
the blend rotation state we are going to

408
00:14:58,240 --> 00:15:00,079
choose the correct case of the loot

409
00:15:00,079 --> 00:15:02,320
which will be evaluated meaning that we

410
00:15:02,320 --> 00:15:04,639
want to obtain l of m depending on the

411
00:15:04,639 --> 00:15:07,600
encryption of the message m

412
00:15:07,600 --> 00:15:09,920
now if we apply the general bootstrap by

413
00:15:09,920 --> 00:15:12,079
defining just the theta and theta will

414
00:15:12,079 --> 00:15:14,639
be equal to one this means that we here

415
00:15:14,639 --> 00:15:16,160
we represent what we obtain after

416
00:15:16,160 --> 00:15:18,160
modulus switch in the plaintext version

417
00:15:18,160 --> 00:15:20,160
so that the last bit will be equal to

418
00:15:20,160 --> 00:15:22,320
zero and we are sure that

419
00:15:22,320 --> 00:15:24,560
this offers more possibilities to encode

420
00:15:24,560 --> 00:15:27,040
loots now we are able to encode two

421
00:15:27,040 --> 00:15:29,360
lookup tables instead of just one as

422
00:15:29,360 --> 00:15:30,800
previously

423
00:15:30,800 --> 00:15:33,759
why is this possible because now we can

424
00:15:33,759 --> 00:15:35,680
use the value of this list least

425
00:15:35,680 --> 00:15:38,160
significant bit to select which lookup

426
00:15:38,160 --> 00:15:40,639
table which will be chosen so for

427
00:15:40,639 --> 00:15:43,440
instance if we say that the significant

428
00:15:43,440 --> 00:15:46,160
bit is equal to zero we will select the

429
00:15:46,160 --> 00:15:48,959
first lookup table so l0 so that after a

430
00:15:48,959 --> 00:15:51,600
sample extract will be obtained lw

431
00:15:51,600 --> 00:15:55,440
ciphertext encrypting l0 l0 of m

432
00:15:55,440 --> 00:15:58,240
if the last bit is now equal to 1 then

433
00:15:58,240 --> 00:16:00,000
this means that we are going to select

434
00:16:00,000 --> 00:16:02,320
the first the second lookup table so

435
00:16:02,320 --> 00:16:07,959
that we obtain the encryption of l1 of m

436
00:16:09,120 --> 00:16:11,040
another view of the pbs magnitude is

437
00:16:11,040 --> 00:16:13,759
then that using this parameter theta we

438
00:16:13,759 --> 00:16:15,759
are unable to evaluate 2 to the power of

439
00:16:15,759 --> 00:16:17,440
theta function

440
00:16:17,440 --> 00:16:20,639
with the cost of only 1 pbs and the cost

441
00:16:20,639 --> 00:16:23,440
of two to paracetamol extract however

442
00:16:23,440 --> 00:16:25,600
the sample extract is almost free so

443
00:16:25,600 --> 00:16:28,240
that the cost of a general spps and the

444
00:16:28,240 --> 00:16:30,399
evaluation of many loots is the cost of

445
00:16:30,399 --> 00:16:32,560
only one pbs

446
00:16:32,560 --> 00:16:34,800
this offers the multiple instructions

447
00:16:34,800 --> 00:16:37,839
single paradigm to the bbs

448
00:16:37,839 --> 00:16:39,120
these methods are

449
00:16:39,120 --> 00:16:40,959
however some drawbacks in fact we

450
00:16:40,959 --> 00:16:42,720
require that the message are small

451
00:16:42,720 --> 00:16:44,560
enough since we are restricting the less

452
00:16:44,560 --> 00:16:46,560
bits after the switching to be equal to

453
00:16:46,560 --> 00:16:47,600
zero

454
00:16:47,600 --> 00:16:49,839
and moreover the more we increase the

455
00:16:49,839 --> 00:16:52,079
value of theta the more increase the

456
00:16:52,079 --> 00:16:54,320
probability of having here or after

457
00:16:54,320 --> 00:16:57,040
after a pbs

458
00:16:57,040 --> 00:17:00,079
so now we're gonna focus on the bfv

459
00:17:00,079 --> 00:17:01,199
product

460
00:17:01,199 --> 00:17:05,280
in the context of tfhe

461
00:17:05,280 --> 00:17:06,480
so what is

462
00:17:06,480 --> 00:17:09,199
the uh product alabia v

463
00:17:09,199 --> 00:17:12,319
it's pretty simple you have two ring lw

464
00:17:12,319 --> 00:17:14,400
ciphertext as input

465
00:17:14,400 --> 00:17:16,720
and you compute a tensor product between

466
00:17:16,720 --> 00:17:19,919
those two you end up with a larger

467
00:17:19,919 --> 00:17:22,959
cipher text encrypted with a bigger

468
00:17:22,959 --> 00:17:24,720
secret key

469
00:17:24,720 --> 00:17:27,520
and what they do in bav

470
00:17:27,520 --> 00:17:28,319
they

471
00:17:28,319 --> 00:17:29,679
add this

472
00:17:29,679 --> 00:17:31,840
key switch to go back to the original

473
00:17:31,840 --> 00:17:33,200
secret key

474
00:17:33,200 --> 00:17:36,160
so in this presentation we're gonna call

475
00:17:36,160 --> 00:17:38,080
the tensor product followed by the key

476
00:17:38,080 --> 00:17:39,039
switch

477
00:17:39,039 --> 00:17:42,400
ring lwe product

478
00:17:42,880 --> 00:17:43,919
we

479
00:17:43,919 --> 00:17:46,480
had to work on the noise formula for

480
00:17:46,480 --> 00:17:48,000
this operation

481
00:17:48,000 --> 00:17:50,559
in order to prove that it's

482
00:17:50,559 --> 00:17:54,400
possible to use it in the tfhe context

483
00:17:54,400 --> 00:17:57,360
in the tfhe context we have

484
00:17:57,360 --> 00:18:00,640
a small cube the the integer modulus for

485
00:18:00,640 --> 00:18:02,240
the ciphertext

486
00:18:02,240 --> 00:18:04,240
it means that we cannot have

487
00:18:04,240 --> 00:18:07,360
really big amounts of noise so we had to

488
00:18:07,360 --> 00:18:10,480
work on this formula

489
00:18:10,480 --> 00:18:14,400
and we did it in a generic way meaning

490
00:18:14,400 --> 00:18:18,000
we can have a different kind of secret

491
00:18:18,000 --> 00:18:20,960
key distributions it can be binary

492
00:18:20,960 --> 00:18:23,919
ternary gaussian or anything else as

493
00:18:23,919 --> 00:18:24,880
long as

494
00:18:24,880 --> 00:18:27,039
you can provide the standard deviation

495
00:18:27,039 --> 00:18:30,799
and the mean of the distribution

496
00:18:30,799 --> 00:18:34,320
so we were able to use that

497
00:18:34,320 --> 00:18:36,000
ugly formula

498
00:18:36,000 --> 00:18:38,559
and prove that we can compute some level

499
00:18:38,559 --> 00:18:42,400
multiplication in tfhe

500
00:18:42,400 --> 00:18:44,080
for instance we

501
00:18:44,080 --> 00:18:46,080
we can see that with the message

502
00:18:46,080 --> 00:18:49,200
precision of four bit we can have eight

503
00:18:49,200 --> 00:18:52,960
levels of multiplication

504
00:18:53,600 --> 00:18:57,840
so uh to to use it in tfhe we have to

505
00:18:57,840 --> 00:19:01,679
convert uh lw ciphertext into ringlw

506
00:19:01,679 --> 00:19:04,799
ciphertext indeed in tfh we mostly work

507
00:19:04,799 --> 00:19:07,039
uh with messages encrypted as lw

508
00:19:07,039 --> 00:19:10,320
ciphertexts so we're gonna use this key

509
00:19:10,320 --> 00:19:11,200
switch

510
00:19:11,200 --> 00:19:12,559
converting

511
00:19:12,559 --> 00:19:15,919
our input messages m0 and m1 into

512
00:19:15,919 --> 00:19:18,000
constant polynomials

513
00:19:18,000 --> 00:19:21,039
uh encrypted in wrinkle w ciphertext

514
00:19:21,039 --> 00:19:23,360
then we do the tensor product n key

515
00:19:23,360 --> 00:19:24,960
switch

516
00:19:24,960 --> 00:19:27,440
we end up with a wrinkle delay

517
00:19:27,440 --> 00:19:30,720
ciphertext encrypting m0 times m1

518
00:19:30,720 --> 00:19:34,640
and to go back to lwe we simply compute

519
00:19:34,640 --> 00:19:38,200
the sample extraction

520
00:19:39,120 --> 00:19:41,360
so now we're gonna see how this

521
00:19:41,360 --> 00:19:45,039
uh bfv product in tfh can be useful to

522
00:19:45,039 --> 00:19:47,919
overcome uh the legacy click property of

523
00:19:47,919 --> 00:19:50,799
the programmable bootstrapping

524
00:19:50,799 --> 00:19:52,320
so we're gonna start with this toy

525
00:19:52,320 --> 00:19:54,559
example we consider ciphertext

526
00:19:54,559 --> 00:19:57,360
encrypting this plain text with a zero

527
00:19:57,360 --> 00:20:00,000
in the most significant bits

528
00:20:00,000 --> 00:20:00,799
and

529
00:20:00,799 --> 00:20:03,280
this lookup table l

530
00:20:03,280 --> 00:20:05,200
when we do the regular programmable

531
00:20:05,200 --> 00:20:08,000
bootstrapping we end up with a cyclotext

532
00:20:08,000 --> 00:20:10,640
of the message l of m

533
00:20:10,640 --> 00:20:12,640
if now we look

534
00:20:12,640 --> 00:20:14,880
at what would happen if there was a one

535
00:20:14,880 --> 00:20:17,039
in the most significant bits

536
00:20:17,039 --> 00:20:20,960
we end up with minus l of m and that's

537
00:20:20,960 --> 00:20:23,919
that's exactly what we want to correct

538
00:20:23,919 --> 00:20:26,559
a way to do that is to compute

539
00:20:26,559 --> 00:20:28,640
what we call the sign

540
00:20:28,640 --> 00:20:31,039
so we use another lookup table

541
00:20:31,039 --> 00:20:33,679
it's a constant lookup table

542
00:20:33,679 --> 00:20:34,400
and

543
00:20:34,400 --> 00:20:36,559
if we go back to this plain text with a

544
00:20:36,559 --> 00:20:38,799
zero in the most significant bit we end

545
00:20:38,799 --> 00:20:41,280
up with an encryption of one

546
00:20:41,280 --> 00:20:44,720
if we now look at what happened with a

547
00:20:44,720 --> 00:20:46,799
one in the most significant bit we end

548
00:20:46,799 --> 00:20:48,640
up with a minus one

549
00:20:48,640 --> 00:20:51,039
and it's easy to see that if we compute

550
00:20:51,039 --> 00:20:54,320
a multiplication between

551
00:20:54,320 --> 00:20:56,320
those two

552
00:20:56,320 --> 00:20:59,360
we end up with what we wanted which is l

553
00:20:59,360 --> 00:21:03,559
of m in both cases

554
00:21:04,080 --> 00:21:07,520
so how to build this warp pbs

555
00:21:07,520 --> 00:21:09,360
we start with

556
00:21:09,360 --> 00:21:11,840
a ciphertext encrypting

557
00:21:11,840 --> 00:21:15,360
plaintext without any bit of padding

558
00:21:15,360 --> 00:21:17,280
we start with

559
00:21:17,280 --> 00:21:18,960
pulling a bit

560
00:21:18,960 --> 00:21:21,360
which is random because of the way we

561
00:21:21,360 --> 00:21:23,679
encrypt with lwe

562
00:21:23,679 --> 00:21:26,640
and we apply the little trick we just

563
00:21:26,640 --> 00:21:29,039
showed you in more details

564
00:21:29,039 --> 00:21:32,080
we're gonna see what it is

565
00:21:32,080 --> 00:21:34,480
you start with this

566
00:21:34,480 --> 00:21:37,280
ciphertext encrypting a random beta

567
00:21:37,280 --> 00:21:40,240
followed by your message m

568
00:21:40,240 --> 00:21:43,280
you compute two pbs's one for the lookup

569
00:21:43,280 --> 00:21:45,120
table you want to evaluate and one for

570
00:21:45,120 --> 00:21:46,240
the sign

571
00:21:46,240 --> 00:21:49,600
and then you use the lwe multiplication

572
00:21:49,600 --> 00:21:51,280
we described

573
00:21:51,280 --> 00:21:53,760
and you end up with the desired message

574
00:21:53,760 --> 00:21:55,360
l of m

575
00:21:55,360 --> 00:21:59,120
so there are two pbs's to evaluate here

576
00:21:59,120 --> 00:22:00,159
and

577
00:22:00,159 --> 00:22:02,400
we see that we can

578
00:22:02,400 --> 00:22:05,280
factorize them into one using the team

579
00:22:05,280 --> 00:22:08,000
19 trick but there is a price here you

580
00:22:08,000 --> 00:22:11,760
add a little bit of additional noise

581
00:22:11,760 --> 00:22:13,360
if the message is

582
00:22:13,360 --> 00:22:16,240
small enough you can use our trig pbs

583
00:22:16,240 --> 00:22:20,000
many loot and also evaluate

584
00:22:20,000 --> 00:22:23,440
for the price of one pbs only

585
00:22:23,440 --> 00:22:24,720
those two

586
00:22:24,720 --> 00:22:26,880
lookup tables

587
00:22:26,880 --> 00:22:29,280
so i'm going to present another way to

588
00:22:29,280 --> 00:22:31,600
achieve a programmable bootstrapping

589
00:22:31,600 --> 00:22:33,200
without padding

590
00:22:33,200 --> 00:22:36,080
so in the version damian just showed you

591
00:22:36,080 --> 00:22:37,200
we use

592
00:22:37,200 --> 00:22:40,400
the lwe multiplication to correct the

593
00:22:40,400 --> 00:22:41,200
sign

594
00:22:41,200 --> 00:22:44,159
of the random bit in the msb of the

595
00:22:44,159 --> 00:22:46,640
message and here we use

596
00:22:46,640 --> 00:22:48,320
another technique

597
00:22:48,320 --> 00:22:51,039
so we still have

598
00:22:51,039 --> 00:22:54,480
an encryption of a message m as input

599
00:22:54,480 --> 00:22:57,840
and we want to obtain the evaluation of

600
00:22:57,840 --> 00:23:00,240
lookup table l

601
00:23:00,240 --> 00:23:02,559
with m

602
00:23:02,559 --> 00:23:05,760
so the lookup table l is representing

603
00:23:05,760 --> 00:23:09,039
in the bottom left of the screen

604
00:23:09,039 --> 00:23:12,559
and so we don't want to work with this

605
00:23:12,559 --> 00:23:15,039
huge table we want to work with look up

606
00:23:15,039 --> 00:23:16,400
table twice

607
00:23:16,400 --> 00:23:17,919
as small

608
00:23:17,919 --> 00:23:18,720
so

609
00:23:18,720 --> 00:23:21,200
first we are going to break apart this

610
00:23:21,200 --> 00:23:24,640
lookup table into two lookup tables l0

611
00:23:24,640 --> 00:23:28,000
and l1

612
00:23:29,120 --> 00:23:31,200
so now we are going to see how we can

613
00:23:31,200 --> 00:23:33,760
use l0 and l1

614
00:23:33,760 --> 00:23:39,200
to obtain this encryption of l of m

615
00:23:39,919 --> 00:23:41,840
so at the beginning we have our

616
00:23:41,840 --> 00:23:44,320
encryption of the message m

617
00:23:44,320 --> 00:23:46,240
and here we

618
00:23:46,240 --> 00:23:47,039
call

619
00:23:47,039 --> 00:23:48,880
beta the most significant bit of this

620
00:23:48,880 --> 00:23:52,640
message and m prime the rest of the

621
00:23:52,640 --> 00:23:55,200
message

622
00:23:55,279 --> 00:23:58,720
if beta is equal to 0

623
00:23:58,720 --> 00:24:01,200
and we evaluate

624
00:24:01,200 --> 00:24:06,080
the lookup table l0 on m prime we obtain

625
00:24:06,080 --> 00:24:08,640
the evaluation of the lookup table l on

626
00:24:08,640 --> 00:24:09,919
m

627
00:24:09,919 --> 00:24:11,919
and if we have

628
00:24:11,919 --> 00:24:14,480
beta equals to 1

629
00:24:14,480 --> 00:24:17,120
and we evaluate l1

630
00:24:17,120 --> 00:24:18,559
in n prime

631
00:24:18,559 --> 00:24:21,120
we will obtain

632
00:24:21,120 --> 00:24:22,640
the lookup table

633
00:24:22,640 --> 00:24:25,039
of m

634
00:24:25,039 --> 00:24:26,240
so now how

635
00:24:26,240 --> 00:24:29,200
does this work in fhe

636
00:24:29,200 --> 00:24:30,960
so at the beginning we have our

637
00:24:30,960 --> 00:24:34,480
ciphertext of our message m

638
00:24:34,480 --> 00:24:35,279
we

639
00:24:35,279 --> 00:24:37,600
and at the end we want uh to obtain the

640
00:24:37,600 --> 00:24:39,840
encryption of the evaluation of the

641
00:24:39,840 --> 00:24:41,440
lookup table

642
00:24:41,440 --> 00:24:44,960
so first we are going to perform the pbs

643
00:24:44,960 --> 00:24:46,799
with the first look up table

644
00:24:46,799 --> 00:24:48,240
to obtain

645
00:24:48,240 --> 00:24:51,360
the evaluation of our local table

646
00:24:51,360 --> 00:24:54,320
at the sign

647
00:24:54,400 --> 00:24:56,480
up to a sign

648
00:24:56,480 --> 00:24:59,200
we also are going to perform a bootstrap

649
00:24:59,200 --> 00:25:01,679
with the sign lookup table

650
00:25:01,679 --> 00:25:02,559
as

651
00:25:02,559 --> 00:25:04,880
with the first version of the bootstrap

652
00:25:04,880 --> 00:25:07,440
without padding and

653
00:25:07,440 --> 00:25:09,919
the bootstrapping with the second lookup

654
00:25:09,919 --> 00:25:11,919
table

655
00:25:11,919 --> 00:25:14,400
then we are going to add some offset to

656
00:25:14,400 --> 00:25:16,240
the to the sign

657
00:25:16,240 --> 00:25:19,440
and perform an lwe multiplication

658
00:25:19,440 --> 00:25:22,000
and we all we do the same thing for the

659
00:25:22,000 --> 00:25:24,960
second lookup table with the sign and at

660
00:25:24,960 --> 00:25:27,120
the end we are going just to sum

661
00:25:27,120 --> 00:25:28,400
everything

662
00:25:28,400 --> 00:25:31,039
so here we use the

663
00:25:31,039 --> 00:25:34,000
we use beta the msb of the message

664
00:25:34,000 --> 00:25:38,559
to select uh between l0 and l1 the two

665
00:25:38,559 --> 00:25:41,440
lookup tables and also to correct the

666
00:25:41,440 --> 00:25:44,880
sign at the same time

667
00:25:45,679 --> 00:25:48,400
as with the pre president previous

668
00:25:48,400 --> 00:25:49,520
version

669
00:25:49,520 --> 00:25:52,480
we have a layer of pbs so we can use

670
00:25:52,480 --> 00:25:54,240
either the

671
00:25:54,240 --> 00:25:56,880
sim 19 tbs trick

672
00:25:56,880 --> 00:26:01,840
or the pbs menu we just introduced

673
00:26:01,840 --> 00:26:02,960
and we can

674
00:26:02,960 --> 00:26:04,960
as there is

675
00:26:04,960 --> 00:26:08,080
two multiplication lw multiplication we

676
00:26:08,080 --> 00:26:10,799
can use an lwe square

677
00:26:10,799 --> 00:26:14,000
which consists of an lwe multiplication

678
00:26:14,000 --> 00:26:16,290
with both input

679
00:26:16,290 --> 00:26:17,520
[Music]

680
00:26:17,520 --> 00:26:19,520
that are the same

681
00:26:19,520 --> 00:26:22,480
and the complexity of the lwe square is

682
00:26:22,480 --> 00:26:26,000
more or less the same as one of lwe

683
00:26:26,000 --> 00:26:28,000
multiplication

684
00:26:28,000 --> 00:26:30,559
so now we want to compare the complexity

685
00:26:30,559 --> 00:26:34,640
of a classical pbs and the two version

686
00:26:34,640 --> 00:26:37,120
of the bootstrap without padding we just

687
00:26:37,120 --> 00:26:38,960
introduced

688
00:26:38,960 --> 00:26:42,400
so we are going to look at pbs working

689
00:26:42,400 --> 00:26:43,840
on pivot

690
00:26:43,840 --> 00:26:45,200
message

691
00:26:45,200 --> 00:26:48,559
so for a traditional pbs you will need a

692
00:26:48,559 --> 00:26:51,120
pbs for p plus one

693
00:26:51,120 --> 00:26:54,799
bit so p bit for the message and the

694
00:26:54,799 --> 00:26:57,360
plus one is for the the row padding you

695
00:26:57,360 --> 00:27:00,480
put in the most significant bit of the

696
00:27:00,480 --> 00:27:02,240
message

697
00:27:02,240 --> 00:27:04,480
for the first version of the bootstrap

698
00:27:04,480 --> 00:27:08,240
without padding you will need two pbs

699
00:27:08,240 --> 00:27:11,039
for p plus one bits

700
00:27:11,039 --> 00:27:13,600
so the p is for the message and the plus

701
00:27:13,600 --> 00:27:16,159
one is for the random padding

702
00:27:16,159 --> 00:27:19,279
we added during the module switching

703
00:27:19,279 --> 00:27:22,399
for the second version ah sorry and we

704
00:27:22,399 --> 00:27:26,720
also have lwe multiplication

705
00:27:26,720 --> 00:27:28,240
for the second version of the

706
00:27:28,240 --> 00:27:30,880
bootstrapping without padding we need

707
00:27:30,880 --> 00:27:34,720
three pbs but only for p bit because we

708
00:27:34,720 --> 00:27:37,200
don't need any padding

709
00:27:37,200 --> 00:27:38,640
and

710
00:27:38,640 --> 00:27:41,360
two lwe multiplication and three

711
00:27:41,360 --> 00:27:42,799
editions

712
00:27:42,799 --> 00:27:43,840
so

713
00:27:43,840 --> 00:27:48,080
we can see that the warp vs1 seems to be

714
00:27:48,080 --> 00:27:50,399
always

715
00:27:50,399 --> 00:27:52,799
to cost more than a

716
00:27:52,799 --> 00:27:54,640
traditional pbs

717
00:27:54,640 --> 00:27:57,760
but it really depends on the context

718
00:27:57,760 --> 00:27:58,559
for

719
00:27:58,559 --> 00:28:01,520
the comparison between waptbs

720
00:28:01,520 --> 00:28:05,840
2 and a traditional pbs

721
00:28:06,640 --> 00:28:07,919
what about

722
00:28:07,919 --> 00:28:10,880
parallel complexity how does it

723
00:28:10,880 --> 00:28:12,480
compare

724
00:28:12,480 --> 00:28:14,320
so

725
00:28:14,320 --> 00:28:17,279
each layer of pbs became just

726
00:28:17,279 --> 00:28:19,279
one tbs and

727
00:28:19,279 --> 00:28:20,960
if we have two multiplication we have

728
00:28:20,960 --> 00:28:24,159
one multiplication so the interesting

729
00:28:24,159 --> 00:28:25,840
take on

730
00:28:25,840 --> 00:28:28,880
this slide is that the algorithm we

731
00:28:28,880 --> 00:28:32,320
introduced are easily parallel

732
00:28:32,320 --> 00:28:33,760
and

733
00:28:33,760 --> 00:28:35,679
with the help of

734
00:28:35,679 --> 00:28:38,159
parallelization the complexity

735
00:28:38,159 --> 00:28:39,840
are quite

736
00:28:39,840 --> 00:28:44,600
close to the one of the traditional pbs

737
00:28:45,840 --> 00:28:47,919
so now it's the time to conclude this

738
00:28:47,919 --> 00:28:51,600
presentation and to um so i will begin

739
00:28:51,600 --> 00:28:54,159
by by summing up the contribution we

740
00:28:54,159 --> 00:28:55,120
just

741
00:28:55,120 --> 00:28:57,600
presented

742
00:28:57,600 --> 00:29:01,120
so first of all we showed you a bf like

743
00:29:01,120 --> 00:29:04,399
multiplication in tfh

744
00:29:04,399 --> 00:29:07,520
then we introduced a way to evaluate

745
00:29:07,520 --> 00:29:10,320
several lookup table at once with the

746
00:29:10,320 --> 00:29:12,240
pbs menu mentioned

747
00:29:12,240 --> 00:29:15,360
and finally we introduced two ways to

748
00:29:15,360 --> 00:29:17,360
build a bootstrapping without padding

749
00:29:17,360 --> 00:29:21,360
the wallpbs one and the what pbs2

750
00:29:21,360 --> 00:29:24,080
if you look at the at the paper you will

751
00:29:24,080 --> 00:29:26,559
find more contribution

752
00:29:26,559 --> 00:29:28,960
you will find a generic entire noise

753
00:29:28,960 --> 00:29:31,440
analysis of each

754
00:29:31,440 --> 00:29:34,559
introduced fhc operators

755
00:29:34,559 --> 00:29:37,279
you will also find a way to

756
00:29:37,279 --> 00:29:39,760
build an efficient circuit bootstrap

757
00:29:39,760 --> 00:29:42,960
using the pbs midi route

758
00:29:42,960 --> 00:29:45,039
you will also find an efficient

759
00:29:45,039 --> 00:29:46,240
algorithm

760
00:29:46,240 --> 00:29:48,960
to split ciphertex in chunk

761
00:29:48,960 --> 00:29:51,600
using the warp dbs

762
00:29:51,600 --> 00:29:53,279
and using this

763
00:29:53,279 --> 00:29:55,600
splitting in chunks you can

764
00:29:55,600 --> 00:29:59,440
easily build a large precision bootstrap

765
00:29:59,440 --> 00:30:03,440
and to finish we also introduced a new

766
00:30:03,440 --> 00:30:06,000
approach for get bootstrapping and we

767
00:30:06,000 --> 00:30:10,399
extend it to arithmetic circuits

768
00:30:13,679 --> 00:30:15,760
so finally i'm going to introduce some

769
00:30:15,760 --> 00:30:17,600
open problems that

770
00:30:17,600 --> 00:30:19,840
still need to be solved

771
00:30:19,840 --> 00:30:22,960
so first of all we need to take a look

772
00:30:22,960 --> 00:30:26,080
at the fft because for the tensor

773
00:30:26,080 --> 00:30:31,439
product we need a high precision fft

774
00:30:31,679 --> 00:30:33,840
next we want to

775
00:30:33,840 --> 00:30:36,640
experiment with hardware implementation

776
00:30:36,640 --> 00:30:37,600
as

777
00:30:37,600 --> 00:30:39,840
it will be easy to parallelize

778
00:30:39,840 --> 00:30:41,679
everything and to play with the

779
00:30:41,679 --> 00:30:45,440
precision inside the fft

780
00:30:45,440 --> 00:30:49,279
we also want to find alternatives to

781
00:30:49,279 --> 00:30:50,960
the bootstrapping without padding we

782
00:30:50,960 --> 00:30:52,960
just showed you because of the noise

783
00:30:52,960 --> 00:30:54,720
growth

784
00:30:54,720 --> 00:30:56,799
in those algorithms

785
00:30:56,799 --> 00:31:00,320
and to finish we want to improve

786
00:31:00,320 --> 00:31:04,799
the lwe to glw keyswitch because as of

787
00:31:04,799 --> 00:31:09,679
now it's a huge part of the complexity

788
00:31:09,679 --> 00:31:12,640
of the warp pbs

789
00:31:12,640 --> 00:31:14,559
thank you for your

790
00:31:14,559 --> 00:31:17,559
listening

