1
00:00:01,520 --> 00:00:02,800
hi i am

2
00:00:02,800 --> 00:00:04,400
from indian institute of technology

3
00:00:04,400 --> 00:00:06,480
kharagpur

4
00:00:06,480 --> 00:00:08,720
today i will be presenting our compact

5
00:00:08,720 --> 00:00:11,200
adaptive security for attribute weighted

6
00:00:11,200 --> 00:00:12,960
sums from kelly

7
00:00:12,960 --> 00:00:14,880
this is a joint work with bodhisattva

8
00:00:14,880 --> 00:00:16,560
from entity research

9
00:00:16,560 --> 00:00:18,400
and this work is done during my

10
00:00:18,400 --> 00:00:21,199
internship at entity research

11
00:00:21,199 --> 00:00:22,960
in functional encryption scheme there is

12
00:00:22,960 --> 00:00:25,279
a setup authority who generates master

13
00:00:25,279 --> 00:00:27,840
secret key and a master public key using

14
00:00:27,840 --> 00:00:30,240
master public key and encrypted encrypts

15
00:00:30,240 --> 00:00:33,760
messaging and generates the ciphertext

16
00:00:33,760 --> 00:00:36,000
the decrypter who wants to

17
00:00:36,000 --> 00:00:38,079
decrypt the ciphertext city

18
00:00:38,079 --> 00:00:41,200
where is a functional security skf

19
00:00:41,200 --> 00:00:43,600
corresponding to the functioning

20
00:00:43,600 --> 00:00:45,920
to the central authority the central

21
00:00:45,920 --> 00:00:49,360
authority will generate a secret key skf

22
00:00:49,360 --> 00:00:51,600
and gives it to decryptor

23
00:00:51,600 --> 00:00:54,079
having escape the decryptor can now

24
00:00:54,079 --> 00:00:56,480
decrypt the ciphertext city and learns

25
00:00:56,480 --> 00:00:58,480
function of the messaging

26
00:00:58,480 --> 00:01:00,239
the security of function encryption

27
00:01:00,239 --> 00:01:03,120
scheme is defined in two model

28
00:01:03,120 --> 00:01:05,760
first one is indistinguishable security

29
00:01:05,760 --> 00:01:07,200
model

30
00:01:07,200 --> 00:01:09,119
in indistinguishability security of

31
00:01:09,119 --> 00:01:11,920
option encryption the adversary submits

32
00:01:11,920 --> 00:01:14,799
to pair of challenge messages m0 m1 in

33
00:01:14,799 --> 00:01:16,479
the challenge space

34
00:01:16,479 --> 00:01:18,720
it cannot distinguish between encryption

35
00:01:18,720 --> 00:01:21,600
of m0 and the encryption of m1

36
00:01:21,600 --> 00:01:23,119
given the fact that

37
00:01:23,119 --> 00:01:24,159
all the

38
00:01:24,159 --> 00:01:26,080
functional secret keys is k5

39
00:01:26,080 --> 00:01:28,799
corresponding to the function a5 that

40
00:01:28,799 --> 00:01:30,720
anniversary has squared it

41
00:01:30,720 --> 00:01:33,200
satisfies the fact that if i of m0 equal

42
00:01:33,200 --> 00:01:35,200
to fi of m1

43
00:01:35,200 --> 00:01:37,360
adversary can query multiple number of 6

44
00:01:37,360 --> 00:01:39,200
such secret keys

45
00:01:39,200 --> 00:01:41,840
if the number of secret keys

46
00:01:41,840 --> 00:01:44,479
is uh is pyrolyze bounded then we call

47
00:01:44,479 --> 00:01:47,119
the scheme bounded collision resistance

48
00:01:47,119 --> 00:01:49,200
and if the adversary is allowed to

49
00:01:49,200 --> 00:01:51,840
submit any polynomial number of security

50
00:01:51,840 --> 00:01:53,840
queries then we call the scheme

51
00:01:53,840 --> 00:01:56,320
unbounded collision resistance

52
00:01:56,320 --> 00:01:58,079
simulation security of function

53
00:01:58,079 --> 00:02:00,960
encryption is defined by two words first

54
00:02:00,960 --> 00:02:02,880
one is the real world where the

55
00:02:02,880 --> 00:02:04,479
challenger runs all the algorithms

56
00:02:04,479 --> 00:02:05,520
honestly

57
00:02:05,520 --> 00:02:07,840
second one is the ideal world right the

58
00:02:07,840 --> 00:02:09,598
challenger runs the simulated version of

59
00:02:09,598 --> 00:02:11,280
the algorithms

60
00:02:11,280 --> 00:02:13,120
the adversary subjects the single

61
00:02:13,120 --> 00:02:14,480
charring message during the challenge

62
00:02:14,480 --> 00:02:16,879
space the challenger will now compute

63
00:02:16,879 --> 00:02:18,879
the chinese cipher text using the

64
00:02:18,879 --> 00:02:21,200
challenge message game in the real world

65
00:02:21,200 --> 00:02:23,840
and in the ideal world it uses the

66
00:02:23,840 --> 00:02:25,760
functional values of the messaging for

67
00:02:25,760 --> 00:02:28,239
all the functions that adversary has

68
00:02:28,239 --> 00:02:30,800
queried for the secret key till now

69
00:02:30,800 --> 00:02:32,800
for the question and secret key queries

70
00:02:32,800 --> 00:02:34,720
the challenger can use the functional

71
00:02:34,720 --> 00:02:37,200
values directly during the key

72
00:02:37,200 --> 00:02:39,360
generation process

73
00:02:39,360 --> 00:02:40,879
the adversary will not be able to

74
00:02:40,879 --> 00:02:42,720
distinguish between the real and the

75
00:02:42,720 --> 00:02:44,879
ideal world

76
00:02:44,879 --> 00:02:46,640
the simulation security captures the

77
00:02:46,640 --> 00:02:49,599
fact that the adversary can learn only

78
00:02:49,599 --> 00:02:52,480
the functional values from the cipher

79
00:02:52,480 --> 00:02:55,120
text for all the functions that it has a

80
00:02:55,120 --> 00:02:57,760
secret key

81
00:02:58,400 --> 00:02:59,319
both

82
00:02:59,319 --> 00:03:01,519
indistinguishability and simulation

83
00:03:01,519 --> 00:03:04,400
security are further classified into

84
00:03:04,400 --> 00:03:06,720
selective semi-adaptive and adaptive

85
00:03:06,720 --> 00:03:08,159
secret notions

86
00:03:08,159 --> 00:03:09,840
i will discuss those notions in

87
00:03:09,840 --> 00:03:12,080
simulation security setting

88
00:03:12,080 --> 00:03:13,360
in selective

89
00:03:13,360 --> 00:03:15,680
simulation security the adversary will

90
00:03:15,680 --> 00:03:17,680
submit the challenge messaging before

91
00:03:17,680 --> 00:03:20,080
seeing any public parameter

92
00:03:20,080 --> 00:03:22,959
it can also query for many functional

93
00:03:22,959 --> 00:03:25,200
secret keys the investor should not be

94
00:03:25,200 --> 00:03:27,120
able to distinguish between the real and

95
00:03:27,120 --> 00:03:28,879
the ideal world

96
00:03:28,879 --> 00:03:31,040
in semi attractive case the adversary

97
00:03:31,040 --> 00:03:34,080
can see the master public key before

98
00:03:34,080 --> 00:03:36,239
choosing the challenge messaging

99
00:03:36,239 --> 00:03:38,159
in adaptive simulation security the

100
00:03:38,159 --> 00:03:40,319
adversary is allowed to query some

101
00:03:40,319 --> 00:03:42,319
functional secret keys before choosing

102
00:03:42,319 --> 00:03:44,000
the challenge message

103
00:03:44,000 --> 00:03:46,080
it can also query for some functional

104
00:03:46,080 --> 00:03:48,480
secret keys after seeing the challenge

105
00:03:48,480 --> 00:03:50,879
cipher text

106
00:03:50,879 --> 00:03:52,799
what we can see now that selective

107
00:03:52,799 --> 00:03:54,879
security is seems to be weaker than

108
00:03:54,879 --> 00:03:57,120
semi-adaptive security and semi-adaptive

109
00:03:57,120 --> 00:03:59,200
disability is weaker than attractive

110
00:03:59,200 --> 00:04:01,439
security and in all such cases

111
00:04:01,439 --> 00:04:02,720
simulation security implies

112
00:04:02,720 --> 00:04:05,720
indistinguishability

113
00:04:05,760 --> 00:04:07,040
in this paper

114
00:04:07,040 --> 00:04:08,560
we construct functional encryption

115
00:04:08,560 --> 00:04:10,080
scheme for attribute rotation

116
00:04:10,080 --> 00:04:12,840
functionality introduced by

117
00:04:12,840 --> 00:04:16,000
agw20 in this functionality the message

118
00:04:16,000 --> 00:04:18,959
m consists of two parts first one is the

119
00:04:18,959 --> 00:04:20,880
public part which is excel and the

120
00:04:20,880 --> 00:04:22,880
second one is the secret part which is

121
00:04:22,880 --> 00:04:24,080
jedi

122
00:04:24,080 --> 00:04:26,000
during decryption the decrypter will

123
00:04:26,000 --> 00:04:28,080
learn the function of the n which is as

124
00:04:28,080 --> 00:04:30,960
follows function over i f x i transpose

125
00:04:30,960 --> 00:04:32,400
data

126
00:04:32,400 --> 00:04:35,120
if i is not a primary bounded then you

127
00:04:35,120 --> 00:04:39,440
call the scheme on your own x log schema

128
00:04:39,680 --> 00:04:42,320
to get an idea about the significance of

129
00:04:42,320 --> 00:04:44,080
the functionality i will discuss some

130
00:04:44,080 --> 00:04:46,479
special cases

131
00:04:46,479 --> 00:04:49,280
firstly if f outputs a fixed vector then

132
00:04:49,280 --> 00:04:51,040
this functionality will imply inner

133
00:04:51,040 --> 00:04:52,960
product function encryption

134
00:04:52,960 --> 00:04:55,440
secondly if jd is payload and if it's a

135
00:04:55,440 --> 00:04:57,280
boolean function then this functionality

136
00:04:57,280 --> 00:05:00,160
will give you at least best encryption

137
00:05:00,160 --> 00:05:03,199
lastly if f x is of the form y times g x

138
00:05:03,199 --> 00:05:05,600
y where y is a fixed vector and g is a

139
00:05:05,600 --> 00:05:07,360
boolean function then this function

140
00:05:07,360 --> 00:05:10,400
activating type attribute base type afr

141
00:05:10,400 --> 00:05:14,599
recently introduced in acgu20

142
00:05:14,720 --> 00:05:16,400
there are some interesting applications

143
00:05:16,400 --> 00:05:18,800
of this functionality i will discuss one

144
00:05:18,800 --> 00:05:21,520
of them suppose in a banking sector all

145
00:05:21,520 --> 00:05:23,840
the employees are divided into certain

146
00:05:23,840 --> 00:05:25,199
categories

147
00:05:25,199 --> 00:05:28,000
job ji h a i

148
00:05:28,000 --> 00:05:31,199
experience ei salary gi

149
00:05:31,199 --> 00:05:32,960
now let's say we want to compute the

150
00:05:32,960 --> 00:05:34,720
various salary of a certain group of

151
00:05:34,720 --> 00:05:35,919
people

152
00:05:35,919 --> 00:05:38,960
where j i is cashier ai is greater than

153
00:05:38,960 --> 00:05:42,000
40 and ei is equal to 10 that means the

154
00:05:42,000 --> 00:05:43,759
job job is cashier

155
00:05:43,759 --> 00:05:45,840
age is greater than 40 and experience is

156
00:05:45,840 --> 00:05:47,039
obtained

157
00:05:47,039 --> 00:05:48,639
then using the attributed some

158
00:05:48,639 --> 00:05:50,080
functionality we can calculate the

159
00:05:50,080 --> 00:05:52,320
average you say by calculating summation

160
00:05:52,320 --> 00:05:56,479
of i f of g i a i e i times zero where x

161
00:05:56,479 --> 00:05:59,120
i is equal to g i ai which are public

162
00:05:59,120 --> 00:06:01,120
part of the message and gi which is

163
00:06:01,120 --> 00:06:03,600
salary is the secret part of the message

164
00:06:03,600 --> 00:06:06,400
agw 20 proposed function encryption

165
00:06:06,400 --> 00:06:08,080
schemes for attribute weighted some

166
00:06:08,080 --> 00:06:09,840
functionality with some interesting

167
00:06:09,840 --> 00:06:11,280
features

168
00:06:11,280 --> 00:06:13,120
first one is that that scheme supports

169
00:06:13,120 --> 00:06:14,639
unbounded slots

170
00:06:14,639 --> 00:06:16,240
for weight functions

171
00:06:16,240 --> 00:06:19,280
which are arithmetic branching proton

172
00:06:19,280 --> 00:06:21,360
the ciphertext size depends only on the

173
00:06:21,360 --> 00:06:23,759
private part of the message

174
00:06:23,759 --> 00:06:25,680
and the security is based on the killing

175
00:06:25,680 --> 00:06:27,280
or entities assumption which are known

176
00:06:27,280 --> 00:06:30,160
to be standard assumptions

177
00:06:30,160 --> 00:06:32,400
however the security is based on only

178
00:06:32,400 --> 00:06:35,120
semiative simulation security that means

179
00:06:35,120 --> 00:06:37,199
the scheme would not provide

180
00:06:37,199 --> 00:06:40,720
adaptive simulation security

181
00:06:40,800 --> 00:06:42,720
as is as it seems that selective

182
00:06:42,720 --> 00:06:44,319
security is weaker than single active

183
00:06:44,319 --> 00:06:48,560
security however due to gkw 16 selective

184
00:06:48,560 --> 00:06:50,639
security is equivalent to some adaptive

185
00:06:50,639 --> 00:06:52,400
security

186
00:06:52,400 --> 00:06:54,400
although existing transformations from

187
00:06:54,400 --> 00:06:56,560
semiadaptive to adaptive security

188
00:06:56,560 --> 00:06:58,240
requires much more expressive

189
00:06:58,240 --> 00:07:00,160
functionality in the sense that the

190
00:07:00,160 --> 00:07:02,400
underlying semi-adaptive secure

191
00:07:02,400 --> 00:07:03,840
functional encryption scheme should

192
00:07:03,840 --> 00:07:06,720
support general circuits

193
00:07:06,720 --> 00:07:08,240
therefore

194
00:07:08,240 --> 00:07:11,440
htw 20 proposed a open problem in their

195
00:07:11,440 --> 00:07:12,639
paper

196
00:07:12,639 --> 00:07:15,039
how to construct a fee for attribute

197
00:07:15,039 --> 00:07:16,240
voltage sum

198
00:07:16,240 --> 00:07:19,520
with unbounded slot for avp

199
00:07:19,520 --> 00:07:21,680
having compact cipher text

200
00:07:21,680 --> 00:07:24,080
and adaptive simulation security based

201
00:07:24,080 --> 00:07:26,800
on standard assumptions

202
00:07:26,800 --> 00:07:28,800
now i will present some previous works

203
00:07:28,800 --> 00:07:30,720
and challenges in solving the proposed

204
00:07:30,720 --> 00:07:31,919
open problem

205
00:07:31,919 --> 00:07:34,400
the left hand side of the screen we have

206
00:07:34,400 --> 00:07:38,000
shown some apes presented

207
00:07:38,000 --> 00:07:40,240
in the context of partially attributed

208
00:07:40,240 --> 00:07:44,000
city agr 17 to proposed abe for general

209
00:07:44,000 --> 00:07:46,400
policies with semi-adaptive simulation

210
00:07:46,400 --> 00:07:49,360
security e17 proposed a much more

211
00:07:49,360 --> 00:07:52,720
efficient ap for epp policies with some

212
00:07:52,720 --> 00:07:54,560
attractive strangers and security

213
00:07:54,560 --> 00:07:57,759
whereas duty 18 proposed debi for

214
00:07:57,759 --> 00:07:59,599
abp policies with

215
00:07:59,599 --> 00:08:02,400
adaptive simulation security

216
00:08:02,400 --> 00:08:05,039
in the right hand side of the screen

217
00:08:05,039 --> 00:08:06,960
we see some functional encryption

218
00:08:06,960 --> 00:08:09,599
schemes for different functionality

219
00:08:09,599 --> 00:08:11,840
starting from

220
00:08:11,840 --> 00:08:13,280
where they proposed

221
00:08:13,280 --> 00:08:14,960
an attribute-based inner product

222
00:08:14,960 --> 00:08:16,879
functional encryption schemes where the

223
00:08:16,879 --> 00:08:19,599
policies are nc on circuits the security

224
00:08:19,599 --> 00:08:21,759
is based on indistinguishable based

225
00:08:21,759 --> 00:08:26,720
adaptive model agw 20 proposed a fee for

226
00:08:26,720 --> 00:08:28,479
attribute weighted some functionality

227
00:08:28,479 --> 00:08:30,160
where the weight functions are

228
00:08:30,160 --> 00:08:32,159
arithmetic branching programs and the

229
00:08:32,159 --> 00:08:34,240
security is modeled as

230
00:08:34,240 --> 00:08:36,880
semi-adaptive assimilation security

231
00:08:36,880 --> 00:08:39,120
their scheme also supports unbounded

232
00:08:39,120 --> 00:08:42,399
slot we 20 proposed fee for quadratic

233
00:08:42,399 --> 00:08:44,720
functions with semi-adaptive simulation

234
00:08:44,720 --> 00:08:46,240
security

235
00:08:46,240 --> 00:08:49,680
lastly april m20 proposed a fee for

236
00:08:49,680 --> 00:08:53,600
inner product function encryptions with

237
00:08:53,600 --> 00:08:55,279
bounded collision and adaptive

238
00:08:55,279 --> 00:08:57,839
simulation security so what we can see

239
00:08:57,839 --> 00:09:00,560
is that achieving unbounded collision

240
00:09:00,560 --> 00:09:02,480
with adaptive simulation security for

241
00:09:02,480 --> 00:09:04,399
functional encryption is really a

242
00:09:04,399 --> 00:09:07,519
challenging task and now we know it only

243
00:09:07,519 --> 00:09:09,920
for inner product functionality

244
00:09:09,920 --> 00:09:13,440
in this work we build a fee for uh

245
00:09:13,440 --> 00:09:15,519
attribute weighted some functionality

246
00:09:15,519 --> 00:09:18,000
where the weight functions are abp

247
00:09:18,000 --> 00:09:18,800
and

248
00:09:18,800 --> 00:09:21,839
we propose the scheme

249
00:09:21,839 --> 00:09:24,720
additive simulation security first we

250
00:09:24,720 --> 00:09:27,360
propose a one slot scheme then we extend

251
00:09:27,360 --> 00:09:29,360
it to unbounded slot scheme with a small

252
00:09:29,360 --> 00:09:31,680
caveat which i will explain in the next

253
00:09:31,680 --> 00:09:34,399
slide our scheme supports compact cipher

254
00:09:34,399 --> 00:09:37,279
text which means that

255
00:09:37,279 --> 00:09:39,839
the ciphertext size will not grow with

256
00:09:39,839 --> 00:09:41,760
multiple occurrences a particular

257
00:09:41,760 --> 00:09:43,920
attribute in the weight function

258
00:09:43,920 --> 00:09:46,640
our scheme is based on kelin assumption

259
00:09:46,640 --> 00:09:49,360
which is a standard assumption and it

260
00:09:49,360 --> 00:09:51,839
basically generalizes the framework

261
00:09:51,839 --> 00:09:55,360
given by ln 20 from

262
00:09:55,360 --> 00:09:58,800
abe to fe that means from um a load

263
00:09:58,800 --> 00:10:00,640
height into partial attribute hiding

264
00:10:00,640 --> 00:10:02,839
setting also we extend the

265
00:10:02,839 --> 00:10:06,320
indistinguishable security of ln 20 to

266
00:10:06,320 --> 00:10:10,560
simulation-based security for our fee

267
00:10:11,040 --> 00:10:13,279
i will first keep the overview of our

268
00:10:13,279 --> 00:10:15,519
auction encryption scheme

269
00:10:15,519 --> 00:10:17,040
before discussing

270
00:10:17,040 --> 00:10:19,040
about main construction

271
00:10:19,040 --> 00:10:21,760
so we require two cryptographic tools

272
00:10:21,760 --> 00:10:24,160
first one is information theory two

273
00:10:24,160 --> 00:10:26,640
arithmetic key carboning scheme in short

274
00:10:26,640 --> 00:10:28,880
ekgs which is a particular type of

275
00:10:28,880 --> 00:10:31,360
randomized encoding and the second one

276
00:10:31,360 --> 00:10:34,079
is a computational tool which is

277
00:10:34,079 --> 00:10:35,920
function hiding inner product function

278
00:10:35,920 --> 00:10:39,600
and encryption insert ipfe

279
00:10:39,600 --> 00:10:44,240
using akgs and ipfe we first construct a

280
00:10:44,240 --> 00:10:47,120
one key one ciphertext secure one slot

281
00:10:47,120 --> 00:10:49,600
fee scheme in the secret key setting

282
00:10:49,600 --> 00:10:52,480
then we extend it to a one slot fee

283
00:10:52,480 --> 00:10:54,480
scheme in the public key setting however

284
00:10:54,480 --> 00:10:56,720
for that we require a slotted version of

285
00:10:56,720 --> 00:10:59,200
the ipfe i will discuss about the

286
00:10:59,200 --> 00:11:01,680
slotted ipv in a bit

287
00:11:01,680 --> 00:11:04,160
then we extend our one slot one fee

288
00:11:04,160 --> 00:11:07,120
scheme into one slot one extv scheme

289
00:11:07,120 --> 00:11:09,120
which is again in the civic key setting

290
00:11:09,120 --> 00:11:11,120
and it supports one key and one cyber

291
00:11:11,120 --> 00:11:14,720
text so what is the extf functionality

292
00:11:14,720 --> 00:11:16,480
the secret key is generated for a

293
00:11:16,480 --> 00:11:18,640
function and a vector y and the

294
00:11:18,640 --> 00:11:21,200
ciphertext is generated for a vector x

295
00:11:21,200 --> 00:11:23,839
which is public and a vector z

296
00:11:23,839 --> 00:11:26,640
concatenation concreted with a vector w

297
00:11:26,640 --> 00:11:28,480
which are secret

298
00:11:28,480 --> 00:11:30,560
the decryption will recover from if it

299
00:11:30,560 --> 00:11:32,640
affects transportation plus y transfer

300
00:11:32,640 --> 00:11:33,839
structure

301
00:11:33,839 --> 00:11:36,800
then we extend this one slot one extf

302
00:11:36,800 --> 00:11:40,640
scheme uh to a full fridge one slot extf

303
00:11:40,640 --> 00:11:41,519
scheme

304
00:11:41,519 --> 00:11:44,160
using the same idea that were involved

305
00:11:44,160 --> 00:11:46,320
in the transformation of one slot one

306
00:11:46,320 --> 00:11:49,040
fee to one's notify scheme that means we

307
00:11:49,040 --> 00:11:51,279
require slotted ipv

308
00:11:51,279 --> 00:11:52,959
after that

309
00:11:52,959 --> 00:11:56,320
we use the transmission given by agw20

310
00:11:56,320 --> 00:11:58,959
with a little notification to get our

311
00:11:58,959 --> 00:12:01,440
unbounded slotify scheme in adaptive

312
00:12:01,440 --> 00:12:03,839
simulation-based security

313
00:12:03,839 --> 00:12:05,920
here i would like to mention one thing

314
00:12:05,920 --> 00:12:08,240
is that our one in our one slot fee

315
00:12:08,240 --> 00:12:10,399
scheme adversary can query

316
00:12:10,399 --> 00:12:12,639
any polynomial number of secret keys

317
00:12:12,639 --> 00:12:14,880
both before and after the challenge

318
00:12:14,880 --> 00:12:16,320
cipher text

319
00:12:16,320 --> 00:12:18,320
whereas in the in our unbounded slot

320
00:12:18,320 --> 00:12:21,040
scheme adversary can query

321
00:12:21,040 --> 00:12:23,839
a priori bounded number of secret keys

322
00:12:23,839 --> 00:12:25,920
before chinese effort text

323
00:12:25,920 --> 00:12:27,760
and after chinese cipher text it can

324
00:12:27,760 --> 00:12:29,519
query any polynomial number of secret

325
00:12:29,519 --> 00:12:30,639
keys

326
00:12:30,639 --> 00:12:33,040
i will discuss the notion of additivity

327
00:12:33,040 --> 00:12:34,959
key governance scheme

328
00:12:34,959 --> 00:12:37,920
the kernel function takes the function f

329
00:12:37,920 --> 00:12:40,959
and the secret beta as input

330
00:12:40,959 --> 00:12:43,440
where f is an abp

331
00:12:43,440 --> 00:12:45,760
from z b to the power into z p

332
00:12:45,760 --> 00:12:48,720
z and x are variables and r belongs to z

333
00:12:48,720 --> 00:12:51,760
p to the power m is the randomness

334
00:12:51,760 --> 00:12:54,000
the carbon function outputs level

335
00:12:54,000 --> 00:12:57,200
functions l one l two l n plus one

336
00:12:57,200 --> 00:12:59,600
suppose this level functions are known

337
00:12:59,600 --> 00:13:03,519
for some particular values of x and z

338
00:13:03,519 --> 00:13:05,519
the label values are

339
00:13:05,519 --> 00:13:07,600
to up to ln plus 1

340
00:13:07,600 --> 00:13:09,360
these level values are now feed into

341
00:13:09,360 --> 00:13:12,639
some even algorithm which takes input f

342
00:13:12,639 --> 00:13:14,480
and x

343
00:13:14,480 --> 00:13:17,279
and outputs the functional value jdfx

344
00:13:17,279 --> 00:13:19,360
plus beta

345
00:13:19,360 --> 00:13:21,440
in simulation security the simulator

346
00:13:21,440 --> 00:13:24,079
takes the input if x and the function

347
00:13:24,079 --> 00:13:27,279
value get effects as beta and outputs a

348
00:13:27,279 --> 00:13:30,240
simulated level uh a set of simulated

349
00:13:30,240 --> 00:13:34,480
levels l1 will then up to ln plus one

350
00:13:34,480 --> 00:13:36,240
these level values are identically

351
00:13:36,240 --> 00:13:38,880
distributed with the uh level values

352
00:13:38,880 --> 00:13:41,680
output by the carbel algorithm

353
00:13:41,680 --> 00:13:44,160
and we call it simulation security for

354
00:13:44,160 --> 00:13:46,560
ekgs

355
00:13:46,560 --> 00:13:48,480
i will discuss some properties of linear

356
00:13:48,480 --> 00:13:50,880
function uh linear properties of the

357
00:13:50,880 --> 00:13:52,959
level functions

358
00:13:52,959 --> 00:13:55,680
firstly li is linear in x that means if

359
00:13:55,680 --> 00:13:58,000
we take inner product of li and one

360
00:13:58,000 --> 00:14:00,160
comma x it will be the level uh it will

361
00:14:00,160 --> 00:14:02,720
be the 11 value of

362
00:14:02,720 --> 00:14:05,440
that particular level in life

363
00:14:05,440 --> 00:14:08,480
ln is also linear in x z and r and in

364
00:14:08,480 --> 00:14:11,199
particular ln plus 1 z is equal to z

365
00:14:11,199 --> 00:14:14,240
minus of rm where rn denotes the emit

366
00:14:14,240 --> 00:14:17,519
component of the vector r

367
00:14:17,519 --> 00:14:20,240
er algorithm is also linear in the level

368
00:14:20,240 --> 00:14:23,360
values l one two up to f and plus one

369
00:14:23,360 --> 00:14:25,279
in order to prove the adaptive uh

370
00:14:25,279 --> 00:14:28,959
security of abe ll

371
00:14:28,959 --> 00:14:29,760
piece 20 introduced

372
00:14:29,760 --> 00:14:32,160
version for a kgs

373
00:14:32,160 --> 00:14:34,240
it has two notions reverse sampling and

374
00:14:34,240 --> 00:14:36,079
marginal randomness

375
00:14:36,079 --> 00:14:38,880
reverse samp algorithm takes input the

376
00:14:38,880 --> 00:14:41,760
level values into two up to ln plus one

377
00:14:41,760 --> 00:14:44,560
if x and the functional value of z dx

378
00:14:44,560 --> 00:14:45,920
plus beta

379
00:14:45,920 --> 00:14:47,920
and simulates the first level value of

380
00:14:47,920 --> 00:14:49,120
l1

381
00:14:49,120 --> 00:14:51,360
such that the set of level values

382
00:14:51,360 --> 00:14:53,440
relating to up to ln plus 1 is

383
00:14:53,440 --> 00:14:56,800
identically distributed

384
00:14:57,040 --> 00:14:59,120
with the level five was output by the

385
00:14:59,120 --> 00:15:00,240
gargle

386
00:15:00,240 --> 00:15:01,760
this property is called

387
00:15:01,760 --> 00:15:03,760
reverse sampling

388
00:15:03,760 --> 00:15:06,240
in the second property given the level

389
00:15:06,240 --> 00:15:07,600
functions for

390
00:15:07,600 --> 00:15:10,000
j greater than one

391
00:15:10,000 --> 00:15:13,440
lg plus one l n plus 1 we can actually

392
00:15:13,440 --> 00:15:15,839
sample the j level function l j

393
00:15:15,839 --> 00:15:18,079
uniformly at random this property is

394
00:15:18,079 --> 00:15:21,519
called marginal randomness

395
00:15:22,320 --> 00:15:24,480
l u 20 also showed that the partial

396
00:15:24,480 --> 00:15:27,760
governing scheme of iw14 is an akgs with

397
00:15:27,760 --> 00:15:29,839
piecewise security and piecewise

398
00:15:29,839 --> 00:15:34,240
security implies simulation security

399
00:15:35,279 --> 00:15:37,519
in inner product function encryption the

400
00:15:37,519 --> 00:15:39,519
key generation algorithm takes input a

401
00:15:39,519 --> 00:15:43,199
vector v and outputs the secret kv

402
00:15:43,199 --> 00:15:45,199
the encryption algorithm takes input a

403
00:15:45,199 --> 00:15:49,040
vector u and outputs the secret key cte

404
00:15:49,040 --> 00:15:50,720
the decryption algorithm decrease the

405
00:15:50,720 --> 00:15:54,079
ciphertext city u using skv and outputs

406
00:15:54,079 --> 00:15:58,000
the n product between u and v

407
00:15:58,320 --> 00:16:00,880
in terms of security given a set of

408
00:16:00,880 --> 00:16:03,040
secretly ciphertext

409
00:16:03,040 --> 00:16:04,880
distribution

410
00:16:04,880 --> 00:16:08,560
for beta equal to 0 and beta equal to 1

411
00:16:08,560 --> 00:16:09,839
these two distributions are

412
00:16:09,839 --> 00:16:12,320
computationally indistinguishable given

413
00:16:12,320 --> 00:16:15,360
inner product of e y 0 and v j 0 is

414
00:16:15,360 --> 00:16:18,079
equal to the product of e y 1 and v j 1

415
00:16:18,079 --> 00:16:19,759
for every i j

416
00:16:19,759 --> 00:16:20,800
this is called the function

417
00:16:20,800 --> 00:16:23,519
identification of ikv

418
00:16:23,519 --> 00:16:26,800
for our work we have used ipfe in

419
00:16:26,800 --> 00:16:28,720
peering group model

420
00:16:28,720 --> 00:16:30,560
that means the keygen and encryption

421
00:16:30,560 --> 00:16:33,440
algorithm can take the vectors in the

422
00:16:33,440 --> 00:16:36,000
power of the source group

423
00:16:36,000 --> 00:16:39,199
g2 and g1 respectively the decryption

424
00:16:39,199 --> 00:16:41,920
algorithm uses the pairing operation e

425
00:16:41,920 --> 00:16:45,440
and outputs inner product u comma v

426
00:16:45,440 --> 00:16:48,320
in the power of the target group

427
00:16:48,320 --> 00:16:51,759
we now discuss our one slot one f scheme

428
00:16:51,759 --> 00:16:53,920
suppose we have a function f which

429
00:16:53,920 --> 00:16:57,680
consists of um at n prime number of abps

430
00:16:57,680 --> 00:16:58,959
f t

431
00:16:58,959 --> 00:17:01,279
where t does from one to n prime

432
00:17:01,279 --> 00:17:03,759
now we carbon the function z t density x

433
00:17:03,759 --> 00:17:06,319
plus beta t where g t and x are

434
00:17:06,319 --> 00:17:09,839
variables and beta t are secret

435
00:17:09,839 --> 00:17:12,160
and rt is the randomness used in the

436
00:17:12,160 --> 00:17:13,679
kerbal algorithm

437
00:17:13,679 --> 00:17:15,359
and beta t are chosen such that

438
00:17:15,359 --> 00:17:17,679
summation of beta t is equal to zero the

439
00:17:17,679 --> 00:17:19,839
gravity algorithm outputs the level

440
00:17:19,839 --> 00:17:24,000
functions l1t to up to l10 plus one t

441
00:17:24,000 --> 00:17:27,039
we consider two ipfe schemes

442
00:17:27,039 --> 00:17:30,799
the first ipv used is used to hide the

443
00:17:30,799 --> 00:17:33,520
first in level values and the second ipv

444
00:17:33,520 --> 00:17:36,080
is used to hide the m plus one level

445
00:17:36,080 --> 00:17:37,760
value

446
00:17:37,760 --> 00:17:40,160
first ipv using the first ipv will

447
00:17:40,160 --> 00:17:42,559
compute say the secret key corresponding

448
00:17:42,559 --> 00:17:45,760
to the label functions ljt

449
00:17:45,760 --> 00:17:48,480
for j has from 1 to n and using the

450
00:17:48,480 --> 00:17:51,200
second ipv we compute ipv security

451
00:17:51,200 --> 00:17:53,120
corresponding to the vector at t comma

452
00:17:53,120 --> 00:17:54,880
1.

453
00:17:54,880 --> 00:17:56,720
while generating cipher text

454
00:17:56,720 --> 00:17:59,360
corresponding to the vector x major we

455
00:17:59,360 --> 00:18:03,039
use the first ipv to compute an ipf

456
00:18:03,039 --> 00:18:06,720
ciphertext for the vector 1 comma x

457
00:18:06,720 --> 00:18:09,600
using the second type av we compute an

458
00:18:09,600 --> 00:18:11,760
ipf ciphertext for the vector minus 1

459
00:18:11,760 --> 00:18:13,840
comma zt

460
00:18:13,840 --> 00:18:16,559
now if you decrypt using the first uh

461
00:18:16,559 --> 00:18:20,240
ipfe then we get to know the first m

462
00:18:20,240 --> 00:18:24,880
level values l one t two up to l m t

463
00:18:24,880 --> 00:18:26,480
and if you apply the decryption

464
00:18:26,480 --> 00:18:29,120
algorithm of the second ipfe then we get

465
00:18:29,120 --> 00:18:31,280
to another m class under level value

466
00:18:31,280 --> 00:18:34,080
which is zt minus rtm

467
00:18:34,080 --> 00:18:36,720
now since we have all the level values

468
00:18:36,720 --> 00:18:38,720
in the power of the target group we can

469
00:18:38,720 --> 00:18:41,120
apply the equal algorithm and since

470
00:18:41,120 --> 00:18:44,240
either algorithm of the kgs is linear in

471
00:18:44,240 --> 00:18:46,160
the label values therefore we can

472
00:18:46,160 --> 00:18:47,919
compute the linear operation in the

473
00:18:47,919 --> 00:18:50,160
power of the target group

474
00:18:50,160 --> 00:18:53,919
so each ft will give z t times 80 x plus

475
00:18:53,919 --> 00:18:54,840
beta

476
00:18:54,840 --> 00:18:56,400
t

477
00:18:56,400 --> 00:18:58,480
and if we multiply all these evaluated

478
00:18:58,480 --> 00:19:02,720
terms we learn effects transfer subject

479
00:19:02,799 --> 00:19:05,360
now recall that our one fe scheme is

480
00:19:05,360 --> 00:19:08,080
only secure for a single secret key

481
00:19:08,080 --> 00:19:09,760
since our goal is to prove adaptive

482
00:19:09,760 --> 00:19:12,240
simulation security we assume that the

483
00:19:12,240 --> 00:19:16,000
adversary is submitting the uh

484
00:19:16,000 --> 00:19:20,559
secret key before challenging ciphertext

485
00:19:20,880 --> 00:19:23,200
the proof of our one slot one f scheme

486
00:19:23,200 --> 00:19:26,160
is inspired by lm20 where we have used

487
00:19:26,160 --> 00:19:28,240
pre-image sampling led technique along

488
00:19:28,240 --> 00:19:30,400
with the piecewise security of the vgs

489
00:19:30,400 --> 00:19:34,400
and functionality security of iphone

490
00:19:34,400 --> 00:19:36,640
the one if scheme already supports

491
00:19:36,640 --> 00:19:39,600
multi-secret key and single cipher text

492
00:19:39,600 --> 00:19:42,320
since ekgs is insecure for multiple

493
00:19:42,320 --> 00:19:44,559
evaluation

494
00:19:44,559 --> 00:19:46,799
for that we first introduce

495
00:19:46,799 --> 00:19:49,919
a random element is into the ciphertext

496
00:19:49,919 --> 00:19:52,919
vector

497
00:19:53,039 --> 00:19:55,440
then we move this random element s to

498
00:19:55,440 --> 00:19:58,559
the secret key vector using ipv

499
00:19:58,559 --> 00:20:00,400
security

500
00:20:00,400 --> 00:20:02,720
now using ddh we can argue that the

501
00:20:02,720 --> 00:20:04,840
label functions are

502
00:20:04,840 --> 00:20:07,520
randomized however if you look at the

503
00:20:07,520 --> 00:20:09,600
decryption and procedure of the

504
00:20:09,600 --> 00:20:12,000
functional encryption scheme then the

505
00:20:12,000 --> 00:20:14,880
value s is multiplied with the term g t

506
00:20:14,880 --> 00:20:18,000
f d x plus beta t

507
00:20:18,000 --> 00:20:20,880
since this value s is not available to

508
00:20:20,880 --> 00:20:23,200
the decryptor the decryption algorithm

509
00:20:23,200 --> 00:20:25,039
will not be able to output a fixed

510
00:20:25,039 --> 00:20:27,679
transpose change

511
00:20:27,679 --> 00:20:31,280
for that we use additional vector a

512
00:20:31,280 --> 00:20:33,679
we are now carbureting the function z t

513
00:20:33,679 --> 00:20:36,799
times a times 50 x plus beta d iota

514
00:20:36,799 --> 00:20:39,039
such that summation of beta t alpha is

515
00:20:39,039 --> 00:20:41,919
equal to zero for each iodine

516
00:20:41,919 --> 00:20:44,480
we compute additional ipv secret key for

517
00:20:44,480 --> 00:20:47,200
the vector a comma zero

518
00:20:47,200 --> 00:20:48,799
and the g

519
00:20:48,799 --> 00:20:51,440
and for j equal to n plus one we compute

520
00:20:51,440 --> 00:20:53,200
the ipv secret key corresponding to the

521
00:20:53,200 --> 00:20:56,159
vector rti

522
00:20:57,360 --> 00:20:59,360
while generating ciphertext for the

523
00:20:59,360 --> 00:21:02,080
vector x comma j we generally type av

524
00:21:02,080 --> 00:21:03,840
cipher text corresponding to the vector

525
00:21:03,840 --> 00:21:06,880
is comma s tensor product x and this

526
00:21:06,880 --> 00:21:08,240
effect is corresponding to the vector

527
00:21:08,240 --> 00:21:12,400
minus s comma s dot zt

528
00:21:12,960 --> 00:21:15,200
now if you look at the decryption all

529
00:21:15,200 --> 00:21:17,039
the level functions are now the linear

530
00:21:17,039 --> 00:21:20,400
combination of the level functions ljd

531
00:21:20,400 --> 00:21:24,960
iota with the coefficient vector s

532
00:21:25,360 --> 00:21:28,320
since the event algorithm outputs a dot

533
00:21:28,320 --> 00:21:32,720
s dot z t times f d x plus beta t dot s

534
00:21:32,720 --> 00:21:34,880
and a dot s is available to the

535
00:21:34,880 --> 00:21:37,039
decrypter

536
00:21:37,039 --> 00:21:38,960
and the fact that summation of beta t is

537
00:21:38,960 --> 00:21:40,320
equal to zero

538
00:21:40,320 --> 00:21:41,280
therefore

539
00:21:41,280 --> 00:21:43,520
the decryptor can easily compute fx

540
00:21:43,520 --> 00:21:46,320
transmission

541
00:21:48,320 --> 00:21:50,720
another problem remains is that the

542
00:21:50,720 --> 00:21:52,799
encryption algorithm still uses master

543
00:21:52,799 --> 00:21:54,880
secret key of the ipfe

544
00:21:54,880 --> 00:21:57,200
and our goal is to make the encryption

545
00:21:57,200 --> 00:21:59,360
algorithm public

546
00:21:59,360 --> 00:22:01,360
for that we use the notion of slotted

547
00:22:01,360 --> 00:22:02,799
ipfe

548
00:22:02,799 --> 00:22:05,280
instructed ipfe vectors are divided into

549
00:22:05,280 --> 00:22:06,559
two slots

550
00:22:06,559 --> 00:22:09,039
one is public slot and encrypting in the

551
00:22:09,039 --> 00:22:10,559
public slot requires only mastered

552
00:22:10,559 --> 00:22:11,760
public key

553
00:22:11,760 --> 00:22:13,679
and another is private slot and

554
00:22:13,679 --> 00:22:15,440
encrypting in the private start request

555
00:22:15,440 --> 00:22:17,200
master secret key

556
00:22:17,200 --> 00:22:19,520
and function hiding security holds only

557
00:22:19,520 --> 00:22:22,720
in the private slot

558
00:22:22,880 --> 00:22:26,400
this is now the original scheme

559
00:22:26,400 --> 00:22:29,039
i will now discuss the security proof of

560
00:22:29,039 --> 00:22:31,440
our one slot f scheme

561
00:22:31,440 --> 00:22:34,000
hybrid zero is the real experiment where

562
00:22:34,000 --> 00:22:38,000
all the algorithms are run honestly

563
00:22:38,000 --> 00:22:40,960
in hypertone we activate the

564
00:22:40,960 --> 00:22:43,520
private slot that means the encryption

565
00:22:43,520 --> 00:22:45,520
algorithm will be using master secret

566
00:22:45,520 --> 00:22:46,400
key

567
00:22:46,400 --> 00:22:48,080
and that and the indistinguishable

568
00:22:48,080 --> 00:22:50,000
follow from the slotted correctness of

569
00:22:50,000 --> 00:22:52,720
the ipa frame

570
00:22:53,440 --> 00:22:56,159
in height one we see the inner product

571
00:22:56,159 --> 00:22:58,240
values are a dot s

572
00:22:58,240 --> 00:22:59,360
l j t

573
00:22:59,360 --> 00:23:03,760
x and minus r t m plus a dot s times z t

574
00:23:03,760 --> 00:23:05,520
these inner product values will be now

575
00:23:05,520 --> 00:23:08,559
computed through private slots

576
00:23:08,559 --> 00:23:11,520
so in hybrid 2 we make all the 5

577
00:23:11,520 --> 00:23:15,120
public slots in the cipher text 0 and

578
00:23:15,120 --> 00:23:17,360
rearrange the drums so that the inner

579
00:23:17,360 --> 00:23:20,080
product between the ciphertext vector

580
00:23:20,080 --> 00:23:21,360
and the

581
00:23:21,360 --> 00:23:24,880
security factors remains unchanged

582
00:23:24,880 --> 00:23:27,280
and hence the security will follow from

583
00:23:27,280 --> 00:23:30,799
the function id ipfe

584
00:23:34,720 --> 00:23:36,640
our next goal is to randomize the level

585
00:23:36,640 --> 00:23:39,600
functions using press this and build

586
00:23:39,600 --> 00:23:44,159
random values for rtm and a dot is

587
00:23:44,159 --> 00:23:46,400
so in hybrid 3 we press the sample base

588
00:23:46,400 --> 00:23:49,039
values and in distance we should follow

589
00:23:49,039 --> 00:23:52,080
from the mdds assumption

590
00:23:52,080 --> 00:23:54,240
in hybrid 4 we apply the image

591
00:23:54,240 --> 00:23:56,960
suppliability technique

592
00:23:56,960 --> 00:23:59,760
the simulator knows the function value f

593
00:23:59,760 --> 00:24:02,640
corresponding to all these

594
00:24:02,640 --> 00:24:05,840
cipher text key query space

595
00:24:05,840 --> 00:24:07,679
so it can sort the linear system of

596
00:24:07,679 --> 00:24:10,320
equation if x transpose z equal to minus

597
00:24:10,320 --> 00:24:12,799
and get a dynamic vector d such that f x

598
00:24:12,799 --> 00:24:15,600
transpose just equal to f x transpose d

599
00:24:15,600 --> 00:24:18,400
we will use this vector d in cipher text

600
00:24:18,400 --> 00:24:19,919
vectors

601
00:24:19,919 --> 00:24:23,120
so we add additional hidden slopes minus

602
00:24:23,120 --> 00:24:25,840
1 dt minus 1 zt

603
00:24:25,840 --> 00:24:27,840
and the corresponding

604
00:24:27,840 --> 00:24:30,559
vector elements in the secret key vector

605
00:24:30,559 --> 00:24:32,799
are all zero

606
00:24:32,799 --> 00:24:35,600
here we extend the dual system

607
00:24:35,600 --> 00:24:38,720
encryption abstraction used by ln 20

608
00:24:38,720 --> 00:24:40,799
into a three slotted encryption

609
00:24:40,799 --> 00:24:42,240
technique

610
00:24:42,240 --> 00:24:45,360
the first slot is minus one zt the

611
00:24:45,360 --> 00:24:47,919
second slot is minus one dt and the

612
00:24:47,919 --> 00:24:50,960
third slot is minus one gt

613
00:24:50,960 --> 00:24:54,159
our goal is to make all the pitch

614
00:24:54,159 --> 00:24:56,400
ciphertext secret key queries to

615
00:24:56,400 --> 00:24:59,200
interact with only the second slot that

616
00:24:59,200 --> 00:25:01,679
is minus one dt

617
00:25:01,679 --> 00:25:03,840
for that we consider

618
00:25:03,840 --> 00:25:05,760
only the first crystalline security

619
00:25:05,760 --> 00:25:06,720
query

620
00:25:06,720 --> 00:25:12,400
and we do it one by one through a loop

621
00:25:12,559 --> 00:25:15,200
in the first hybrid of the loop we copy

622
00:25:15,200 --> 00:25:17,679
the secret key elements from first

623
00:25:17,679 --> 00:25:19,600
third slot

624
00:25:19,600 --> 00:25:21,919
since first slot and first slot are the

625
00:25:21,919 --> 00:25:24,320
same in the ciphertext factor therefore

626
00:25:24,320 --> 00:25:27,200
the inner product will remain unchanged

627
00:25:27,200 --> 00:25:28,799
hence the indistinguishability will

628
00:25:28,799 --> 00:25:31,279
follow from the function id security of

629
00:25:31,279 --> 00:25:33,600
ipv

630
00:25:33,600 --> 00:25:36,960
now at this stage we will apply our one

631
00:25:36,960 --> 00:25:40,080
key one fe scheme security

632
00:25:40,080 --> 00:25:43,279
in the third slot and make the element

633
00:25:43,279 --> 00:25:47,279
in the first plot from zt to dt

634
00:25:47,760 --> 00:25:50,240
for that we need to introduce some

635
00:25:50,240 --> 00:25:54,240
additional hidden subspaces

636
00:25:54,400 --> 00:25:56,720
now you know that

637
00:25:56,720 --> 00:25:59,279
all the other secret keys are

638
00:25:59,279 --> 00:26:01,200
interacting with minus one gt of the

639
00:26:01,200 --> 00:26:03,279
first slot and only the first

640
00:26:03,279 --> 00:26:05,200
pre-challenge the secret key is

641
00:26:05,200 --> 00:26:08,159
interacting with the third slot

642
00:26:08,159 --> 00:26:10,640
since second slot and third slot are

643
00:26:10,640 --> 00:26:12,799
same therefore we can copy the secret

644
00:26:12,799 --> 00:26:15,279
key left element from third slot to

645
00:26:15,279 --> 00:26:18,000
second slot

646
00:26:18,559 --> 00:26:20,559
now the first pre-charge secret key is

647
00:26:20,559 --> 00:26:22,880
interacting with the second slot which

648
00:26:22,880 --> 00:26:25,520
is minus one dt

649
00:26:25,520 --> 00:26:28,320
and we make the third slot back to the

650
00:26:28,320 --> 00:26:30,480
normal stage

651
00:26:30,480 --> 00:26:33,600
which is minus one zt

652
00:26:33,600 --> 00:26:35,760
we can repeat this technique for all

653
00:26:35,760 --> 00:26:39,840
other pre-challenged security queries

654
00:26:40,159 --> 00:26:42,480
one by one

655
00:26:42,480 --> 00:26:44,559
and after this loop

656
00:26:44,559 --> 00:26:46,559
all the feature in secret key queries

657
00:26:46,559 --> 00:26:49,120
will interact with the second slot and

658
00:26:49,120 --> 00:26:51,279
all hostile security queries will

659
00:26:51,279 --> 00:26:53,520
interact with the first slot

660
00:26:53,520 --> 00:26:55,919
and the third slot has worked for us as

661
00:26:55,919 --> 00:26:59,279
a temporary waste station

662
00:27:00,480 --> 00:27:02,720
now we will modify all the post

663
00:27:02,720 --> 00:27:06,520
challenge secret key queries

664
00:27:07,120 --> 00:27:09,039
for the first selection to query since

665
00:27:09,039 --> 00:27:11,360
we know the challenge message vectors

666
00:27:11,360 --> 00:27:13,600
exceed therefore we can directly put the

667
00:27:13,600 --> 00:27:18,000
label values into the cipher text

668
00:27:18,000 --> 00:27:20,159
next we'll use the simulation security

669
00:27:20,159 --> 00:27:24,240
of akgs to simulate the values using the

670
00:27:24,240 --> 00:27:26,880
simulator

671
00:27:27,520 --> 00:27:30,080
but we can see that the simulator still

672
00:27:30,080 --> 00:27:34,399
uses a tilde ztftx plus beta t tilde for

673
00:27:34,399 --> 00:27:38,000
simulating the function with t

674
00:27:38,159 --> 00:27:40,320
however the final simulator should be

675
00:27:40,320 --> 00:27:43,120
using only if x transpose j

676
00:27:43,120 --> 00:27:45,279
for that we use a statistical

677
00:27:45,279 --> 00:27:47,039
transformation

678
00:27:47,039 --> 00:27:50,080
using beta t tilde

679
00:27:50,080 --> 00:27:51,679
and we use

680
00:27:51,679 --> 00:27:55,120
uh f1 to simulate the value a tilde a

681
00:27:55,120 --> 00:27:57,520
fixed transpose check plus v1 tilde and

682
00:27:57,520 --> 00:28:00,240
all other functions fd will simulate the

683
00:28:00,240 --> 00:28:03,120
value beta t tilde

684
00:28:03,120 --> 00:28:05,760
finally hybrid nine is our simulator

685
00:28:05,760 --> 00:28:07,520
where all these challenge secret key

686
00:28:07,520 --> 00:28:10,640
queries will interact with minus one dt

687
00:28:10,640 --> 00:28:14,399
and we have used the ekg simulator for

688
00:28:14,399 --> 00:28:15,200
the

689
00:28:15,200 --> 00:28:19,440
all post channel secret key queries

690
00:28:20,799 --> 00:28:23,679
so till now what we have seen using akgs

691
00:28:23,679 --> 00:28:27,679
and ipfe we construct one slot one fee

692
00:28:27,679 --> 00:28:30,640
and we convert the secret key 1.15 into

693
00:28:30,640 --> 00:28:33,600
a public key one slotted scheme

694
00:28:33,600 --> 00:28:35,279
how we can

695
00:28:35,279 --> 00:28:40,000
convert our 1.1 fee to one extf scheme

696
00:28:40,000 --> 00:28:42,799
let us see that

697
00:28:42,880 --> 00:28:45,679
we recall that our one extreme scheme

698
00:28:45,679 --> 00:28:48,320
has has this functionality as follows

699
00:28:48,320 --> 00:28:50,559
the secret key is generated for a

700
00:28:50,559 --> 00:28:51,760
function f

701
00:28:51,760 --> 00:28:53,440
and deleted y

702
00:28:53,440 --> 00:28:56,640
and ciphertext is generated for vector x

703
00:28:56,640 --> 00:28:59,440
and a vector just concatenated with

704
00:28:59,440 --> 00:29:01,039
another vector w

705
00:29:01,039 --> 00:29:03,600
and decryption outputs f x transpose z

706
00:29:03,600 --> 00:29:05,840
plus y transpose w

707
00:29:05,840 --> 00:29:09,360
here we use the linear property of equal

708
00:29:09,360 --> 00:29:12,080
algorithm we recall that even algorithm

709
00:29:12,080 --> 00:29:15,679
is linear in all the level values

710
00:29:15,679 --> 00:29:19,360
our idea is to see that if we add any

711
00:29:19,360 --> 00:29:23,120
value new to the first level value l1d

712
00:29:23,120 --> 00:29:25,279
then the value will come out of the

713
00:29:25,279 --> 00:29:29,120
evaluation and we get z t times f d x

714
00:29:29,120 --> 00:29:32,159
plus mu plus beta t

715
00:29:32,159 --> 00:29:34,720
our idea is to use this name to compute

716
00:29:34,720 --> 00:29:37,760
the term y transpose w

717
00:29:37,760 --> 00:29:38,799
for that

718
00:29:38,799 --> 00:29:41,760
for only the first level function we

719
00:29:41,760 --> 00:29:45,360
compute ipv secret key for the vector l

720
00:29:45,360 --> 00:29:47,840
one t comma y

721
00:29:47,840 --> 00:29:50,399
and during the cipher text generation

722
00:29:50,399 --> 00:29:53,919
process we compute the first ipv cipher

723
00:29:53,919 --> 00:29:58,159
text for the vector 1 x comma w

724
00:29:58,159 --> 00:30:00,240
now you can see that the term y

725
00:30:00,240 --> 00:30:03,600
transpose w will be added to each level

726
00:30:03,600 --> 00:30:06,320
value l 1 t

727
00:30:06,320 --> 00:30:08,000
hence we need to secretly share the

728
00:30:08,000 --> 00:30:12,799
value y transpose w through all f t

729
00:30:12,799 --> 00:30:14,799
so we introduce additional random

730
00:30:14,799 --> 00:30:16,640
element alpha t

731
00:30:16,640 --> 00:30:20,080
in the secret key generation process

732
00:30:20,080 --> 00:30:22,080
such that summation of alpha t is equal

733
00:30:22,080 --> 00:30:23,919
to one

734
00:30:23,919 --> 00:30:26,960
and nu t is added to the value l one t

735
00:30:26,960 --> 00:30:30,240
where nu t is equal to alpha t times y

736
00:30:30,240 --> 00:30:32,399
transpose w

737
00:30:32,399 --> 00:30:34,559
now if we multiply all the evaluated

738
00:30:34,559 --> 00:30:36,799
terms then you can get

739
00:30:36,799 --> 00:30:39,919
fx transpose j plus y transpose w which

740
00:30:39,919 --> 00:30:43,279
is the required functional value

741
00:30:43,279 --> 00:30:46,000
using this idea we convert our one slot

742
00:30:46,000 --> 00:30:49,679
one fee to one slot one htv

743
00:30:49,679 --> 00:30:51,919
and using the same idea involved in the

744
00:30:51,919 --> 00:30:54,320
transmission of one slot one if we do

745
00:30:54,320 --> 00:30:56,960
one slot if we we convert our one slot

746
00:30:56,960 --> 00:31:00,240
one extf with one slot next tv

747
00:31:00,240 --> 00:31:03,760
finally we use agw 20

748
00:31:03,760 --> 00:31:06,240
transformation to convert or one slot

749
00:31:06,240 --> 00:31:08,960
hdf to unbounded slot fee

750
00:31:08,960 --> 00:31:11,440
here we know that adversary can only

751
00:31:11,440 --> 00:31:13,240
query q number of

752
00:31:13,240 --> 00:31:15,840
precipitate secret keys this is due to

753
00:31:15,840 --> 00:31:18,640
the fact that we are unable to solve the

754
00:31:18,640 --> 00:31:20,960
linear system of equation if the

755
00:31:20,960 --> 00:31:23,840
coefficient matrix is available in the

756
00:31:23,840 --> 00:31:26,159
exponent of a group

757
00:31:26,159 --> 00:31:29,679
for that we have introduced q mini

758
00:31:29,679 --> 00:31:31,679
additional hidden subspaces and secret

759
00:31:31,679 --> 00:31:34,559
keys and ciphertext to incorporate all

760
00:31:34,559 --> 00:31:35,440
the

761
00:31:35,440 --> 00:31:38,559
precisely text functional values into

762
00:31:38,559 --> 00:31:42,000
the chinese cipher text

763
00:31:42,000 --> 00:31:44,399
i will now conclude my talk

764
00:31:44,399 --> 00:31:46,320
so in this work we present a function

765
00:31:46,320 --> 00:31:48,559
encryption scheme for attributed sum

766
00:31:48,559 --> 00:31:50,799
functionality but the weight functions

767
00:31:50,799 --> 00:31:53,200
are arithmetic branching program

768
00:31:53,200 --> 00:31:55,360
the security is defined by

769
00:31:55,360 --> 00:31:58,080
adaptive simulation based security model

770
00:31:58,080 --> 00:32:00,880
our scheme supports unbounded slot with

771
00:32:00,880 --> 00:32:03,440
compare ciphertext which means

772
00:32:03,440 --> 00:32:05,679
the ciphertext size will not grow with

773
00:32:05,679 --> 00:32:07,360
multiple occurrences of a particular

774
00:32:07,360 --> 00:32:09,600
attribute in the wait function

775
00:32:09,600 --> 00:32:11,919
our scheme is secured based on killing

776
00:32:11,919 --> 00:32:13,440
assumption

777
00:32:13,440 --> 00:32:15,120
so from the technical ground we

778
00:32:15,120 --> 00:32:17,840
generalizes the panel framework from

779
00:32:17,840 --> 00:32:19,600
attribute based encryption to function

780
00:32:19,600 --> 00:32:21,440
encryption

781
00:32:21,440 --> 00:32:24,720
or from payload hiding to partially

782
00:32:24,720 --> 00:32:27,200
attribute id

783
00:32:27,200 --> 00:32:29,760
our one slot scheme the ciphertext size

784
00:32:29,760 --> 00:32:32,880
grows with the size of private and

785
00:32:32,880 --> 00:32:35,519
public part of the message

786
00:32:35,519 --> 00:32:37,919
and additionally for our unbounded slot

787
00:32:37,919 --> 00:32:40,240
screen the cipher texas grows with the

788
00:32:40,240 --> 00:32:43,600
number of pre-channel secret requests

789
00:32:43,600 --> 00:32:46,559
whereas the senior activity secure fe

790
00:32:46,559 --> 00:32:48,960
scheme of hdw 20

791
00:32:48,960 --> 00:32:51,200
the ciphertext size grows with the

792
00:32:51,200 --> 00:32:53,440
private part of the message

793
00:32:53,440 --> 00:32:55,279
therefore it is an interesting open

794
00:32:55,279 --> 00:32:57,039
problem to investigate a function

795
00:32:57,039 --> 00:32:58,399
encryption scheme with adaptive

796
00:32:58,399 --> 00:33:00,880
simulation security where the ciphertex

797
00:33:00,880 --> 00:33:03,120
size grows with only

798
00:33:03,120 --> 00:33:04,720
the size of the

799
00:33:04,720 --> 00:33:07,440
private part of the message

800
00:33:07,440 --> 00:33:09,919
another interesting open problem is to

801
00:33:09,919 --> 00:33:11,919
construct a function encryption scheme

802
00:33:11,919 --> 00:33:15,279
for general circuit or ebps

803
00:33:15,279 --> 00:33:18,080
with selective security and unbounded

804
00:33:18,080 --> 00:33:21,120
slot with compact ciphertext based on lw

805
00:33:21,120 --> 00:33:23,440
assumption

806
00:33:23,440 --> 00:33:25,519
thank you if you have any question you

807
00:33:25,519 --> 00:33:29,480
can discuss doing

