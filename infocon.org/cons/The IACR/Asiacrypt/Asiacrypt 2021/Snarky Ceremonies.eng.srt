1
00:00:02,159 --> 00:00:04,240
hi my name is jan nasim and this is a

2
00:00:04,240 --> 00:00:07,919
talk for asia group 2021

3
00:00:07,919 --> 00:00:09,440
presentation

4
00:00:09,440 --> 00:00:11,759
titled snaky ceremonies

5
00:00:11,759 --> 00:00:14,480
this is a joint work by marco kovis mary

6
00:00:14,480 --> 00:00:18,560
mahler and mikhail vocal

7
00:00:19,439 --> 00:00:21,920
let me start you by reminding what are

8
00:00:21,920 --> 00:00:24,080
sick snacks

9
00:00:24,080 --> 00:00:25,039
this

10
00:00:25,039 --> 00:00:27,439
this stands for zero knowledge succinct

11
00:00:27,439 --> 00:00:30,720
non-interactive argument of knowledge

12
00:00:30,720 --> 00:00:34,160
and the idea is that we want to prove

13
00:00:34,160 --> 00:00:36,640
that some statement x

14
00:00:36,640 --> 00:00:39,200
which is public and some weakness w

15
00:00:39,200 --> 00:00:40,719
which is private

16
00:00:40,719 --> 00:00:45,000
satisfy a certain relation

17
00:00:45,200 --> 00:00:46,160
and

18
00:00:46,160 --> 00:00:48,239
from security wise

19
00:00:48,239 --> 00:00:51,840
we wanted to satisfy knowledge soundness

20
00:00:51,840 --> 00:00:54,239
this means that prover who is able to

21
00:00:54,239 --> 00:00:56,000
convince the verifier

22
00:00:56,000 --> 00:01:00,320
should know a witness w

23
00:01:00,320 --> 00:01:02,640
and we want zero knowledge

24
00:01:02,640 --> 00:01:05,199
which essentially means that the only

25
00:01:05,199 --> 00:01:07,439
information we leak

26
00:01:07,439 --> 00:01:11,600
is that x and w are in the relation

27
00:01:11,600 --> 00:01:13,119
and we don't even

28
00:01:13,119 --> 00:01:16,640
reveal the witness here

29
00:01:16,640 --> 00:01:19,600
and finally we want succinctness

30
00:01:19,600 --> 00:01:22,640
which essentially means that proof size

31
00:01:22,640 --> 00:01:24,560
is independent of the size of the

32
00:01:24,560 --> 00:01:28,320
statement and the size of the witness

33
00:01:28,799 --> 00:01:31,280
smallest snark so far

34
00:01:31,280 --> 00:01:33,759
or at least one of the smallest

35
00:01:33,759 --> 00:01:37,040
is uh proposed by krotz six uh inscribed

36
00:01:37,040 --> 00:01:38,880
in 2016

37
00:01:38,880 --> 00:01:41,439
and it requires a complicated trusted

38
00:01:41,439 --> 00:01:43,759
setup unfortunately

39
00:01:43,759 --> 00:01:45,680
which has

40
00:01:45,680 --> 00:01:47,520
made it very difficult to use it in

41
00:01:47,520 --> 00:01:49,759
practice

42
00:01:49,759 --> 00:01:53,280
so what i mean by this trusted setup

43
00:01:53,280 --> 00:01:57,360
um essentially we have here a prover

44
00:01:57,360 --> 00:01:58,799
a verifier

45
00:01:58,799 --> 00:02:02,640
and some trusted central party

46
00:02:02,640 --> 00:02:05,200
kruger knows statement and witness and

47
00:02:05,200 --> 00:02:09,119
verifier knows only the statement

48
00:02:09,119 --> 00:02:10,479
and then in the beginning of the

49
00:02:10,479 --> 00:02:13,200
protocol the trusted party

50
00:02:13,200 --> 00:02:15,360
will generate what we call a common

51
00:02:15,360 --> 00:02:16,879
reference string

52
00:02:16,879 --> 00:02:18,160
so this is a

53
00:02:18,160 --> 00:02:20,879
a bit string for from some very specific

54
00:02:20,879 --> 00:02:22,400
distribution

55
00:02:22,400 --> 00:02:24,720
and he gives this to both approver and

56
00:02:24,720 --> 00:02:26,879
the verifier and then prover can use

57
00:02:26,879 --> 00:02:28,160
this

58
00:02:28,160 --> 00:02:30,640
to construct an argument and verify

59
00:02:30,640 --> 00:02:32,400
again use this to

60
00:02:32,400 --> 00:02:34,800
either accept the argument which means

61
00:02:34,800 --> 00:02:39,519
he believes it or he will reject it

62
00:02:40,640 --> 00:02:43,040
there are essentially two flavors of the

63
00:02:43,040 --> 00:02:45,280
common reference string

64
00:02:45,280 --> 00:02:48,239
there are uniformly random strings

65
00:02:48,239 --> 00:02:50,480
which is completely uniformed around the

66
00:02:50,480 --> 00:02:52,319
bit string

67
00:02:52,319 --> 00:02:54,879
or there are structured reference spring

68
00:02:54,879 --> 00:02:58,080
which is anything besides the uniform

69
00:02:58,080 --> 00:03:00,800
random string

70
00:03:00,800 --> 00:03:03,120
and uniformly random string we sometimes

71
00:03:03,120 --> 00:03:05,760
call a transparent setup

72
00:03:05,760 --> 00:03:07,200
because it's

73
00:03:07,200 --> 00:03:08,959
uh

74
00:03:08,959 --> 00:03:11,840
it's relatively easy

75
00:03:11,840 --> 00:03:15,280
to obtain a uniformly random string

76
00:03:15,280 --> 00:03:19,120
from some natural resources

77
00:03:19,120 --> 00:03:22,239
which means that

78
00:03:22,319 --> 00:03:24,560
we essentially don't have to trust it

79
00:03:24,560 --> 00:03:25,680
anymore

80
00:03:25,680 --> 00:03:28,720
we can obtain it by you know

81
00:03:28,720 --> 00:03:31,519
picking for example

82
00:03:31,519 --> 00:03:34,080
certain digits of pi

83
00:03:34,080 --> 00:03:35,840
or or some other

84
00:03:35,840 --> 00:03:38,560
natural source of randomness

85
00:03:38,560 --> 00:03:41,680
unfortunately protocols based on urs

86
00:03:41,680 --> 00:03:44,480
are less efficient

87
00:03:44,480 --> 00:03:47,360
and then you have uh

88
00:03:47,360 --> 00:03:49,200
protocols with structured reference

89
00:03:49,200 --> 00:03:50,959
string

90
00:03:50,959 --> 00:03:52,239
here the

91
00:03:52,239 --> 00:03:54,400
setup is much more complicated

92
00:03:54,400 --> 00:03:57,680
and we don't have as good ways of

93
00:03:57,680 --> 00:03:59,280
generating this

94
00:03:59,280 --> 00:04:01,280
structured reference string but the

95
00:04:01,280 --> 00:04:04,720
protocols are much more efficient

96
00:04:04,720 --> 00:04:06,159
so in case of structured reference

97
00:04:06,159 --> 00:04:07,439
string

98
00:04:07,439 --> 00:04:09,200
the trusted part usually does something

99
00:04:09,200 --> 00:04:10,319
like this

100
00:04:10,319 --> 00:04:13,040
it first generates the trapdoor

101
00:04:13,040 --> 00:04:15,760
then he applies some function destructor

102
00:04:15,760 --> 00:04:19,519
and this then generates the srs

103
00:04:19,519 --> 00:04:21,918
unfortunately anyone who knows the

104
00:04:21,918 --> 00:04:23,840
trapdoor can completely break the

105
00:04:23,840 --> 00:04:26,960
protocol it is actually by design

106
00:04:26,960 --> 00:04:30,479
of the protocol that this is possible

107
00:04:30,479 --> 00:04:32,320
essentially this trap door is used to

108
00:04:32,320 --> 00:04:34,240
prove that the serial knowledge property

109
00:04:34,240 --> 00:04:35,120
holds

110
00:04:35,120 --> 00:04:37,520
but it accidentally also can break the

111
00:04:37,520 --> 00:04:39,840
soundness properly if someone actually

112
00:04:39,840 --> 00:04:42,720
knows this

113
00:04:42,720 --> 00:04:45,360
which essentially means that in most

114
00:04:45,360 --> 00:04:47,280
applications

115
00:04:47,280 --> 00:04:50,080
a single party should not be able to

116
00:04:50,080 --> 00:04:53,280
generate the srs

117
00:04:53,680 --> 00:04:54,800
because

118
00:04:54,800 --> 00:04:57,360
otherwise

119
00:04:57,360 --> 00:05:00,000
i mean we really have a centralized

120
00:05:00,000 --> 00:05:01,520
trust in the system

121
00:05:01,520 --> 00:05:03,199
which for example in the blockchain

122
00:05:03,199 --> 00:05:04,560
setting

123
00:05:04,560 --> 00:05:08,400
is not really acceptable at all

124
00:05:08,400 --> 00:05:10,639
there have been several

125
00:05:10,639 --> 00:05:13,520
proposals how to solve this

126
00:05:13,520 --> 00:05:16,479
uh one of the earlier proposals was to

127
00:05:16,479 --> 00:05:20,000
use multi-party computation

128
00:05:20,000 --> 00:05:22,240
so here the idea is very simple we

129
00:05:22,240 --> 00:05:23,840
already have a bunch of multi-party

130
00:05:23,840 --> 00:05:26,560
computation protocols

131
00:05:26,560 --> 00:05:29,199
uh the trapdoor can be shared between

132
00:05:29,199 --> 00:05:30,960
different parties

133
00:05:30,960 --> 00:05:33,600
so each party will generate

134
00:05:33,600 --> 00:05:37,039
generate its local trapdoor

135
00:05:37,039 --> 00:05:39,280
then they runs a multi-party computation

136
00:05:39,280 --> 00:05:41,199
protocol

137
00:05:41,199 --> 00:05:45,680
and the final output is an srs

138
00:05:45,680 --> 00:05:48,400
uh where

139
00:05:48,400 --> 00:05:51,280
f is applied to a master trap door

140
00:05:51,280 --> 00:05:54,000
where the master door is some sort of

141
00:05:54,000 --> 00:05:55,919
the combination of the individual

142
00:05:55,919 --> 00:05:59,440
trapdoors of each party

143
00:05:59,600 --> 00:06:03,120
and typically you get a property that if

144
00:06:03,120 --> 00:06:07,520
some fraction of the parties is honest

145
00:06:07,520 --> 00:06:10,080
then the final trapdoor does not leak

146
00:06:10,080 --> 00:06:14,479
and the srs has a correct structure

147
00:06:14,800 --> 00:06:16,800
unfortunately it's also quite

148
00:06:16,800 --> 00:06:19,199
inconvenient if you want to run this but

149
00:06:19,199 --> 00:06:21,759
a large number of parties

150
00:06:21,759 --> 00:06:24,880
because they have to be available

151
00:06:24,880 --> 00:06:26,639
throughout this whole protocol which

152
00:06:26,639 --> 00:06:29,120
might take quite a while

153
00:06:29,120 --> 00:06:30,479
and

154
00:06:30,479 --> 00:06:32,800
also multiparty computation protocols

155
00:06:32,800 --> 00:06:34,880
are not that efficient if you want to

156
00:06:34,880 --> 00:06:37,440
run it with huge number of parties

157
00:06:37,440 --> 00:06:39,440
which you would perhaps in a blockchain

158
00:06:39,440 --> 00:06:41,360
setting

159
00:06:41,360 --> 00:06:43,680
so in response to that yes there have

160
00:06:43,680 --> 00:06:45,520
been proposed some specialized

161
00:06:45,520 --> 00:06:47,759
multi-party computation protocols which

162
00:06:47,759 --> 00:06:49,680
are a bit more efficient

163
00:06:49,680 --> 00:06:52,479
but they are still quite cumbersome to

164
00:06:52,479 --> 00:06:55,280
use in practice

165
00:06:57,199 --> 00:07:00,560
another possibility

166
00:07:00,720 --> 00:07:02,800
which is a little bit better

167
00:07:02,800 --> 00:07:05,360
is known as updatability

168
00:07:05,360 --> 00:07:07,520
so these are essentially specialized

169
00:07:07,520 --> 00:07:09,120
snarks

170
00:07:09,120 --> 00:07:10,720
where the multi-party computation

171
00:07:10,720 --> 00:07:14,319
protocol has only one round

172
00:07:14,319 --> 00:07:17,280
uh what do i mean by this

173
00:07:17,280 --> 00:07:18,479
um

174
00:07:18,479 --> 00:07:20,560
now we basically have

175
00:07:20,560 --> 00:07:22,400
that each party

176
00:07:22,400 --> 00:07:24,110
generates a pixel trapdoor

177
00:07:24,110 --> 00:07:26,240
[Music]

178
00:07:26,240 --> 00:07:28,479
and the first party will produce some

179
00:07:28,479 --> 00:07:30,479
srs and some

180
00:07:30,479 --> 00:07:33,360
proof of update raw one

181
00:07:33,360 --> 00:07:35,440
the second party will just update this

182
00:07:35,440 --> 00:07:37,199
proof and

183
00:07:37,199 --> 00:07:39,680
generate its own update proof so this

184
00:07:39,680 --> 00:07:42,400
update proof is something just to verify

185
00:07:42,400 --> 00:07:44,479
that it was done correctly

186
00:07:44,479 --> 00:07:47,120
and so on

187
00:07:47,360 --> 00:07:50,000
and these in these protocols we only

188
00:07:50,000 --> 00:07:53,680
rely on one honest party

189
00:07:53,840 --> 00:07:58,720
and in order to verify the final srs

190
00:07:58,720 --> 00:08:01,120
you just need

191
00:08:01,120 --> 00:08:04,400
the very last srs and some all of those

192
00:08:04,400 --> 00:08:06,639
intermediate update proofs which are

193
00:08:06,639 --> 00:08:09,520
typically short in those protocols

194
00:08:09,520 --> 00:08:11,840
and there are now many works in this

195
00:08:11,840 --> 00:08:16,318
model like sonic and marlin and blanc

196
00:08:16,479 --> 00:08:18,080
but in general they are a little bit

197
00:08:18,080 --> 00:08:20,000
less efficient than the non-updatable

198
00:08:20,000 --> 00:08:22,560
snacks

199
00:08:22,879 --> 00:08:26,560
so it would still be interesting

200
00:08:26,560 --> 00:08:28,240
to kind of

201
00:08:28,240 --> 00:08:29,599
uh

202
00:08:29,599 --> 00:08:31,680
make those non-updatable snacks also

203
00:08:31,680 --> 00:08:34,210
updatable in some way

204
00:08:34,210 --> 00:08:36,000
[Music]

205
00:08:36,000 --> 00:08:40,559
and finally there is a solution by

206
00:08:41,440 --> 00:08:44,959
which is a player exchangeable npc

207
00:08:44,959 --> 00:08:46,959
um

208
00:08:46,959 --> 00:08:49,360
the basically the idea is that in these

209
00:08:49,360 --> 00:08:51,279
types of protocols

210
00:08:51,279 --> 00:08:52,640
the trapdoor doesn't have to be

211
00:08:52,640 --> 00:08:54,640
committed

212
00:08:54,640 --> 00:08:57,920
in the beginning of the protocol

213
00:08:58,560 --> 00:09:02,240
and instead they use a random beacon

214
00:09:02,240 --> 00:09:03,760
which is like an extra body in the

215
00:09:03,760 --> 00:09:06,240
protocol

216
00:09:06,240 --> 00:09:07,120
and

217
00:09:07,120 --> 00:09:09,360
then in each round of the protocol also

218
00:09:09,360 --> 00:09:11,920
this random p comparison participates

219
00:09:11,920 --> 00:09:13,279
and we can kind of

220
00:09:13,279 --> 00:09:15,200
we're just assuming that this random

221
00:09:15,200 --> 00:09:16,880
beacon

222
00:09:16,880 --> 00:09:17,920
behaves

223
00:09:17,920 --> 00:09:19,760
correctly it produces some random

224
00:09:19,760 --> 00:09:22,240
numbers for us

225
00:09:22,240 --> 00:09:23,519
and

226
00:09:23,519 --> 00:09:25,600
yeah

227
00:09:25,600 --> 00:09:27,680
the output of the protocol is kind of

228
00:09:27,680 --> 00:09:29,950
the same as in the

229
00:09:29,950 --> 00:09:31,440
[Music]

230
00:09:31,440 --> 00:09:33,839
usual npc protocols but what is nice

231
00:09:33,839 --> 00:09:36,560
here is that the parties

232
00:09:36,560 --> 00:09:37,360
can

233
00:09:37,360 --> 00:09:39,200
be different in different rounds of the

234
00:09:39,200 --> 00:09:40,640
protocol

235
00:09:40,640 --> 00:09:45,120
so now we are not anymore relying on the

236
00:09:45,279 --> 00:09:48,240
fact that the same party

237
00:09:48,240 --> 00:09:50,320
is available in the first phase and the

238
00:09:50,320 --> 00:09:52,959
second phase of the protocol

239
00:09:52,959 --> 00:09:54,800
so this is a lot more

240
00:09:54,800 --> 00:09:57,200
convenient if you have a lot of parties

241
00:09:57,200 --> 00:09:58,880
in a multi-party computation product

242
00:09:58,880 --> 00:10:00,640
called especially in the blockchain

243
00:10:00,640 --> 00:10:02,959
setting

244
00:10:03,680 --> 00:10:06,160
and now this uh protocol of power

245
00:10:06,160 --> 00:10:08,800
gap is on the myers this was used quite

246
00:10:08,800 --> 00:10:10,480
extensively

247
00:10:10,480 --> 00:10:13,760
for example with the zed cache protocol

248
00:10:13,760 --> 00:10:16,640
aztec protocol file coin semaphore loop

249
00:10:16,640 --> 00:10:19,839
ring and so on

250
00:10:20,000 --> 00:10:23,519
with quite some success

251
00:10:24,320 --> 00:10:26,720
so let's look a bit more closely what is

252
00:10:26,720 --> 00:10:30,240
this random beacon here

253
00:10:30,240 --> 00:10:33,760
idea of the random beacon is that

254
00:10:33,760 --> 00:10:34,880
uh

255
00:10:34,880 --> 00:10:37,440
after certain time intervals it will

256
00:10:37,440 --> 00:10:41,440
produce us a new random number

257
00:10:42,720 --> 00:10:45,360
um

258
00:10:45,440 --> 00:10:47,200
and why it's useful in this previous

259
00:10:47,200 --> 00:10:49,360
protocol is that we can basically use

260
00:10:49,360 --> 00:10:50,320
this

261
00:10:50,320 --> 00:10:51,200
uh

262
00:10:51,200 --> 00:10:53,600
previously unknown random number

263
00:10:53,600 --> 00:10:55,440
to randomize

264
00:10:55,440 --> 00:11:00,600
uh this current state of the srs

265
00:11:01,200 --> 00:11:03,040
unfortunately it is quite

266
00:11:03,040 --> 00:11:05,760
complicated to construct secure random

267
00:11:05,760 --> 00:11:08,240
beacons

268
00:11:08,640 --> 00:11:12,399
there's a heuristic approach which

269
00:11:12,399 --> 00:11:13,839
has been

270
00:11:13,839 --> 00:11:15,760
used in this blockchain world which is

271
00:11:15,760 --> 00:11:16,560
that

272
00:11:16,560 --> 00:11:18,480
you just take a hash

273
00:11:18,480 --> 00:11:21,760
of a relatively recent blockchain block

274
00:11:21,760 --> 00:11:24,160
and you now say that okay this is my new

275
00:11:24,160 --> 00:11:25,279
random

276
00:11:25,279 --> 00:11:27,600
output of the beacon

277
00:11:27,600 --> 00:11:30,240
this is only a heuristic approach if you

278
00:11:30,240 --> 00:11:32,959
ask actually want to do it securely

279
00:11:32,959 --> 00:11:34,480
then it's a

280
00:11:34,480 --> 00:11:36,640
very challenging problem

281
00:11:36,640 --> 00:11:39,200
so ideally we would not want to use a

282
00:11:39,200 --> 00:11:42,480
random beacon at all

283
00:11:42,480 --> 00:11:45,360
so what is our contribution here

284
00:11:45,360 --> 00:11:47,920
firstly we propose a security framework

285
00:11:47,920 --> 00:11:51,120
for non-interactive arguments

286
00:11:51,120 --> 00:11:51,920
which

287
00:11:51,920 --> 00:11:53,360
uh

288
00:11:53,360 --> 00:11:56,160
have a ceremony protocol so this is a

289
00:11:56,160 --> 00:11:58,639
product called for setting up

290
00:11:58,639 --> 00:12:01,519
the srs

291
00:12:02,639 --> 00:12:05,120
and you can kind of see this as a

292
00:12:05,120 --> 00:12:07,040
generalization of the notion of

293
00:12:07,040 --> 00:12:09,040
updatability if you're familiar with

294
00:12:09,040 --> 00:12:11,279
this one

295
00:12:11,279 --> 00:12:14,399
and then we propose a simplified version

296
00:12:14,399 --> 00:12:17,940
of crop 16 ceremony

297
00:12:17,940 --> 00:12:19,200
[Music]

298
00:12:19,200 --> 00:12:20,959
essentially a simplified version of this

299
00:12:20,959 --> 00:12:23,760
bowie gap is a myers protocol

300
00:12:23,760 --> 00:12:27,519
which does not use a random beacon

301
00:12:27,519 --> 00:12:30,000
so we completely eliminate this

302
00:12:30,000 --> 00:12:32,560
assumption

303
00:12:33,360 --> 00:12:34,560
and finally

304
00:12:34,560 --> 00:12:37,279
we give a proof of security

305
00:12:37,279 --> 00:12:40,160
in a mixed model of algebraic group

306
00:12:40,160 --> 00:12:42,880
model and random oracle model

307
00:12:42,880 --> 00:12:45,120
is technically quite an advanced

308
00:12:45,120 --> 00:12:47,279
security proof which we will very

309
00:12:47,279 --> 00:12:51,399
briefly go over as well

310
00:12:52,480 --> 00:12:54,320
so let's take a look of that security

311
00:12:54,320 --> 00:12:56,560
framework of our

312
00:12:56,560 --> 00:12:59,119
proposal

313
00:12:59,360 --> 00:13:02,240
so snuck with the ceremony

314
00:13:02,240 --> 00:13:04,079
firstly we have our approver algorithm

315
00:13:04,079 --> 00:13:07,839
and the verifier algorithm as usual

316
00:13:07,920 --> 00:13:11,120
but the srs is now split into

317
00:13:11,120 --> 00:13:13,680
independently updatable parts

318
00:13:13,680 --> 00:13:15,120
srsu

319
00:13:15,120 --> 00:13:18,160
which we call updatable srs

320
00:13:18,160 --> 00:13:19,440
and the

321
00:13:19,440 --> 00:13:23,200
srss which is a specialized srs

322
00:13:23,200 --> 00:13:26,800
the idea here is that srsu

323
00:13:26,800 --> 00:13:29,200
is independent of the concrete relation

324
00:13:29,200 --> 00:13:30,959
that we are trying to prove

325
00:13:30,959 --> 00:13:33,600
and the srss already depends on the

326
00:13:33,600 --> 00:13:35,839
relation

327
00:13:36,560 --> 00:13:38,639
then we have an update algorithm which

328
00:13:38,639 --> 00:13:41,120
is used to update the srs

329
00:13:41,120 --> 00:13:42,399
it takes in

330
00:13:42,399 --> 00:13:44,320
the previous srs

331
00:13:44,320 --> 00:13:46,560
a set of update proofs

332
00:13:46,560 --> 00:13:47,360
and

333
00:13:47,360 --> 00:13:49,839
an index either urs

334
00:13:49,839 --> 00:13:51,839
depending on which part of the servers

335
00:13:51,839 --> 00:13:53,600
we want to update

336
00:13:53,600 --> 00:13:55,360
and then it produces

337
00:13:55,360 --> 00:13:57,279
a new version of the

338
00:13:57,279 --> 00:13:58,880
srs

339
00:13:58,880 --> 00:14:03,680
and an update proof for that srs

340
00:14:03,680 --> 00:14:05,600
then we have an srs verification

341
00:14:05,600 --> 00:14:06,720
algorithm

342
00:14:06,720 --> 00:14:08,079
which takes

343
00:14:08,079 --> 00:14:10,800
as an input and srs and the setup update

344
00:14:10,800 --> 00:14:14,839
proves and either resets it or rejects

345
00:14:14,839 --> 00:14:17,920
it um

346
00:14:17,920 --> 00:14:19,440
yeah so what does the model actually

347
00:14:19,440 --> 00:14:21,920
look like

348
00:14:22,399 --> 00:14:23,199
uh

349
00:14:23,199 --> 00:14:25,120
basically we do updating in two phases

350
00:14:25,120 --> 00:14:26,079
so

351
00:14:26,079 --> 00:14:27,680
first

352
00:14:27,680 --> 00:14:31,120
we update the universal srs this is the

353
00:14:31,120 --> 00:14:32,800
srs without

354
00:14:32,800 --> 00:14:34,959
a specific relation

355
00:14:34,959 --> 00:14:37,839
and it goes as in usual updatability

356
00:14:37,839 --> 00:14:40,800
model so the first guy updates and

357
00:14:40,800 --> 00:14:42,720
produces a crew

358
00:14:42,720 --> 00:14:45,839
and so on

359
00:14:46,000 --> 00:14:46,880
then

360
00:14:46,880 --> 00:14:50,800
we finish the universal updating phase

361
00:14:50,800 --> 00:14:53,519
and fix the srs

362
00:14:53,519 --> 00:14:55,920
the universal srs

363
00:14:55,920 --> 00:14:58,000
and now

364
00:14:58,000 --> 00:15:00,399
we have let's say some relation that we

365
00:15:00,399 --> 00:15:02,480
want to use

366
00:15:02,480 --> 00:15:04,720
and we take the srs

367
00:15:04,720 --> 00:15:05,600
which is

368
00:15:05,600 --> 00:15:07,760
universal

369
00:15:07,760 --> 00:15:10,320
and we generate

370
00:15:10,320 --> 00:15:11,600
initial

371
00:15:11,600 --> 00:15:14,399
specialized srs so this is a srs which

372
00:15:14,399 --> 00:15:15,839
depends

373
00:15:15,839 --> 00:15:18,320
on the relation and we start updating

374
00:15:18,320 --> 00:15:19,920
this

375
00:15:19,920 --> 00:15:22,800
and as you see here

376
00:15:22,959 --> 00:15:24,560
this part is in the first place and

377
00:15:24,560 --> 00:15:26,079
second phase they don't have to be the

378
00:15:26,079 --> 00:15:28,320
same

379
00:15:28,320 --> 00:15:29,920
so from

380
00:15:29,920 --> 00:15:32,480
updatability perspective we sort of

381
00:15:32,480 --> 00:15:33,680
argue that

382
00:15:33,680 --> 00:15:37,360
there's actually not much difference

383
00:15:37,360 --> 00:15:39,920
if you work in this type of updatability

384
00:15:39,920 --> 00:15:41,680
model

385
00:15:41,680 --> 00:15:43,920
where you fix the universal srs at some

386
00:15:43,920 --> 00:15:45,120
point and then

387
00:15:45,120 --> 00:15:46,800
go on with the

388
00:15:46,800 --> 00:15:48,639
specialized srs

389
00:15:48,639 --> 00:15:50,880
or

390
00:15:51,199 --> 00:15:53,199
you just have your usual notion of

391
00:15:53,199 --> 00:15:55,839
updatability

392
00:15:58,160 --> 00:16:00,880
and the final srs

393
00:16:00,880 --> 00:16:03,759
is just a conjunction

394
00:16:03,759 --> 00:16:07,440
of the final updatable srs and the final

395
00:16:07,440 --> 00:16:10,720
specialized srs

396
00:16:10,880 --> 00:16:12,959
and from the secure device we want

397
00:16:12,959 --> 00:16:14,720
completeness

398
00:16:14,720 --> 00:16:16,959
in two flavors actually we want update

399
00:16:16,959 --> 00:16:18,480
completeness

400
00:16:18,480 --> 00:16:21,199
which essentially says that okay so if

401
00:16:21,199 --> 00:16:25,120
you have some srs which verifies

402
00:16:25,120 --> 00:16:27,680
and we make an update

403
00:16:27,680 --> 00:16:29,199
then

404
00:16:29,199 --> 00:16:32,880
also this updated srs will verify

405
00:16:32,880 --> 00:16:35,120
and we also have prover completeness

406
00:16:35,120 --> 00:16:37,040
which is

407
00:16:37,040 --> 00:16:38,880
essentially the usual notion of

408
00:16:38,880 --> 00:16:40,720
completeness in an interactive

409
00:16:40,720 --> 00:16:42,639
zero-knowledge protocols

410
00:16:42,639 --> 00:16:44,000
that

411
00:16:44,000 --> 00:16:46,720
okay so if the srs verifies

412
00:16:46,720 --> 00:16:50,000
and the honest prover generates approved

413
00:16:50,000 --> 00:16:53,120
then also the verifier accept the proof

414
00:16:53,120 --> 00:16:55,600
so these are just some properties to

415
00:16:55,600 --> 00:16:57,440
guarantee that our protocol even makes

416
00:16:57,440 --> 00:16:59,759
sense

417
00:17:01,759 --> 00:17:02,839
then we

418
00:17:02,839 --> 00:17:07,280
require optic knowledge soundness

419
00:17:07,359 --> 00:17:09,760
what this one says is that for every

420
00:17:09,760 --> 00:17:12,240
efficient adversary a

421
00:17:12,240 --> 00:17:15,359
there exists an efficient extractor

422
00:17:15,359 --> 00:17:18,799
such that if the adversary outputs

423
00:17:18,799 --> 00:17:19,520
a

424
00:17:19,520 --> 00:17:22,240
statement x and some proof pi and it

425
00:17:22,240 --> 00:17:24,559
verifies

426
00:17:24,559 --> 00:17:26,799
uh then the extractor

427
00:17:26,799 --> 00:17:29,760
is able to extract the witness

428
00:17:29,760 --> 00:17:32,640
from the view of a so this is all the

429
00:17:32,640 --> 00:17:35,039
internal knowledge that the adversary

430
00:17:35,039 --> 00:17:37,280
has

431
00:17:37,440 --> 00:17:38,400
uh

432
00:17:38,400 --> 00:17:39,760
and

433
00:17:39,760 --> 00:17:40,880
yeah so

434
00:17:40,880 --> 00:17:42,000
you can

435
00:17:42,000 --> 00:17:43,840
extract the business

436
00:17:43,840 --> 00:17:47,360
and the srs here is generated by

437
00:17:47,360 --> 00:17:50,879
interacting with the challenger

438
00:17:52,000 --> 00:17:54,080
so

439
00:17:54,080 --> 00:17:56,320
essentially what we allow is that

440
00:17:56,320 --> 00:17:59,200
the first ways of updating

441
00:17:59,200 --> 00:18:03,039
adversary can request the challenger

442
00:18:03,039 --> 00:18:05,440
to update his

443
00:18:05,440 --> 00:18:07,760
srs

444
00:18:07,760 --> 00:18:10,960
and by the end of the universal phase

445
00:18:10,960 --> 00:18:14,080
adversary will submit some srsu together

446
00:18:14,080 --> 00:18:15,919
with some update proofs

447
00:18:15,919 --> 00:18:18,080
such that at least one of those update

448
00:18:18,080 --> 00:18:19,120
proofs

449
00:18:19,120 --> 00:18:21,520
was generated by the challenger

450
00:18:21,520 --> 00:18:23,200
so essentially there has to be one

451
00:18:23,200 --> 00:18:25,600
honest update

452
00:18:25,600 --> 00:18:26,840
and the second

453
00:18:26,840 --> 00:18:30,400
phase works basically the same way

454
00:18:30,400 --> 00:18:33,600
so now we have some srsu already fixed

455
00:18:33,600 --> 00:18:35,679
adversary can

456
00:18:35,679 --> 00:18:38,160
request updates for

457
00:18:38,160 --> 00:18:40,080
specialized srs

458
00:18:40,080 --> 00:18:42,480
and by the end of the phase he submits

459
00:18:42,480 --> 00:18:47,679
some srs a specialist srs

460
00:18:48,000 --> 00:18:51,120
and update proofs such that at least one

461
00:18:51,120 --> 00:18:53,440
of the updates was done honestly by the

462
00:18:53,440 --> 00:18:56,440
challenger

463
00:18:57,039 --> 00:18:58,880
uh and then we borrowed the notion of

464
00:18:58,880 --> 00:19:01,440
subversions or knowledge

465
00:19:01,440 --> 00:19:04,000
uh which was invented by the lara hooks

466
00:19:04,000 --> 00:19:06,799
power and skapuro

467
00:19:06,799 --> 00:19:09,840
and the idea there is that

468
00:19:09,840 --> 00:19:14,080
adversary is allowed to pick any srs

469
00:19:14,080 --> 00:19:15,360
and

470
00:19:15,360 --> 00:19:18,880
a set of update proofs such that

471
00:19:18,880 --> 00:19:21,600
they verify

472
00:19:21,919 --> 00:19:23,520
and in that case

473
00:19:23,520 --> 00:19:25,600
there must exist an extra efficient

474
00:19:25,600 --> 00:19:28,240
extractor that can extract

475
00:19:28,240 --> 00:19:31,840
a trapdoor from the srs

476
00:19:31,840 --> 00:19:34,400
and this trap door can use

477
00:19:34,400 --> 00:19:36,840
to simulate

478
00:19:36,840 --> 00:19:40,320
uh proofs that are indistinguishable

479
00:19:40,320 --> 00:19:43,280
from honest proofs

480
00:19:44,080 --> 00:19:47,520
so yeah this is our security model

481
00:19:47,520 --> 00:19:49,760
uh

482
00:19:49,760 --> 00:19:51,280
okay

483
00:19:51,280 --> 00:19:52,559
so now

484
00:19:52,559 --> 00:19:53,679
let's

485
00:19:53,679 --> 00:19:55,679
go and check what this

486
00:19:55,679 --> 00:19:58,080
uh ceremony protocol of quote 16 roughly

487
00:19:58,080 --> 00:19:59,520
looks like

488
00:19:59,520 --> 00:20:02,159
so uh grout 16

489
00:20:02,159 --> 00:20:04,080
as i mentioned before it's dark with one

490
00:20:04,080 --> 00:20:06,799
of the shortest proofs so far

491
00:20:06,799 --> 00:20:10,159
and we can split the srs into universal

492
00:20:10,159 --> 00:20:13,760
universal part in the specialized part

493
00:20:13,760 --> 00:20:16,640
uh here this g

494
00:20:16,640 --> 00:20:18,799
is generator of one of the

495
00:20:18,799 --> 00:20:20,960
bearing groups and h is the generator of

496
00:20:20,960 --> 00:20:23,200
the other pairing group

497
00:20:23,200 --> 00:20:26,880
and x is some integer

498
00:20:26,880 --> 00:20:31,280
which is a trapdoor so x alpha and beta

499
00:20:31,280 --> 00:20:34,400
here are actually a tractor

500
00:20:34,400 --> 00:20:37,919
and the specialist srs

501
00:20:37,919 --> 00:20:40,400
kind of looks something similar

502
00:20:40,400 --> 00:20:42,960
but what we can notice here is that

503
00:20:42,960 --> 00:20:45,360
there's universal srs

504
00:20:45,360 --> 00:20:46,840
has essentially

505
00:20:46,840 --> 00:20:49,919
monomials in the exponent

506
00:20:49,919 --> 00:20:53,679
whereas the specialized srs

507
00:20:54,640 --> 00:20:57,440
does not necessarily have monomials so

508
00:20:57,440 --> 00:20:59,280
here we see some much more complicated

509
00:20:59,280 --> 00:21:02,240
polynomials

510
00:21:02,240 --> 00:21:04,720
but essentially what we when we update

511
00:21:04,720 --> 00:21:06,480
this is that

512
00:21:06,480 --> 00:21:08,640
in the first srs

513
00:21:08,640 --> 00:21:10,240
let's say if we want to update this

514
00:21:10,240 --> 00:21:11,360
element

515
00:21:11,360 --> 00:21:14,799
an updater we pick some x prime

516
00:21:14,799 --> 00:21:16,960
exponentiate

517
00:21:16,960 --> 00:21:18,799
um

518
00:21:18,799 --> 00:21:21,120
let's say this element with x prime to

519
00:21:21,120 --> 00:21:22,960
the power of y

520
00:21:22,960 --> 00:21:24,720
and then the updated element will look

521
00:21:24,720 --> 00:21:27,280
like such

522
00:21:27,440 --> 00:21:30,559
so this x prime x is now

523
00:21:30,559 --> 00:21:32,960
the new trapdoor x

524
00:21:32,960 --> 00:21:34,799
and if you want to update the second

525
00:21:34,799 --> 00:21:35,760
phase

526
00:21:35,760 --> 00:21:39,520
then already x alpha and beta are fixed

527
00:21:39,520 --> 00:21:42,880
and we're only updating delta

528
00:21:42,880 --> 00:21:46,640
so update we pick some delta prime and

529
00:21:46,640 --> 00:21:49,840
uh again exponentiate

530
00:21:49,840 --> 00:21:52,080
let's say this element for example by

531
00:21:52,080 --> 00:21:54,400
one over delta prime

532
00:21:54,400 --> 00:21:56,960
which means that now this delta here is

533
00:21:56,960 --> 00:21:59,840
updated

534
00:22:00,320 --> 00:22:01,280
um

535
00:22:01,280 --> 00:22:03,440
and beyond that

536
00:22:03,440 --> 00:22:07,360
we also need to include the update proof

537
00:22:07,360 --> 00:22:09,840
which essentially allows us to verify

538
00:22:09,840 --> 00:22:12,960
that the updating was done correctly

539
00:22:12,960 --> 00:22:15,760
so what this proof contains is

540
00:22:15,760 --> 00:22:18,559
in case of x for example trap door x

541
00:22:18,559 --> 00:22:21,520
it will have g to the power of x times x

542
00:22:21,520 --> 00:22:21,980
prime

543
00:22:21,980 --> 00:22:23,120
[Music]

544
00:22:23,120 --> 00:22:25,280
g to the power x prime

545
00:22:25,280 --> 00:22:27,840
and h to the x prime

546
00:22:27,840 --> 00:22:30,320
so x prime is this new trapdoor here and

547
00:22:30,320 --> 00:22:31,120
x

548
00:22:31,120 --> 00:22:33,360
is the previous tractor

549
00:22:33,360 --> 00:22:34,960
and then we also have a proof of

550
00:22:34,960 --> 00:22:36,240
knowledge

551
00:22:36,240 --> 00:22:38,640
for x prime

552
00:22:38,640 --> 00:22:40,320
this is something which we need for a

553
00:22:40,320 --> 00:22:42,159
security proof

554
00:22:42,159 --> 00:22:43,440
uh

555
00:22:43,440 --> 00:22:44,960
and the verification looks something

556
00:22:44,960 --> 00:22:47,840
like this so

557
00:22:48,080 --> 00:22:51,280
e here is a pairing operator

558
00:22:51,280 --> 00:22:54,640
and we can kind of verify this that this

559
00:22:54,640 --> 00:22:57,280
g x

560
00:22:57,280 --> 00:23:00,400
x prime was computed correctly by

561
00:23:00,400 --> 00:23:04,000
running this function for example

562
00:23:04,000 --> 00:23:06,480
and then we also verify

563
00:23:06,480 --> 00:23:09,840
the proof of knowledge

564
00:23:11,039 --> 00:23:12,720
so this proof of knowledge is actually

565
00:23:12,720 --> 00:23:15,200
some very specialized protocol i won't

566
00:23:15,200 --> 00:23:17,919
go very much into details here

567
00:23:17,919 --> 00:23:19,679
um

568
00:23:19,679 --> 00:23:21,280
but so far the protocol that i've

569
00:23:21,280 --> 00:23:22,400
introduced is

570
00:23:22,400 --> 00:23:24,799
essentially the same as the

571
00:23:24,799 --> 00:23:27,919
bowie capisson mayas protocol

572
00:23:27,919 --> 00:23:29,840
but here we somehow already are

573
00:23:29,840 --> 00:23:32,400
deviating a bit we are requiring

574
00:23:32,400 --> 00:23:34,880
stronger security properties

575
00:23:34,880 --> 00:23:36,640
for the proof of knowledge

576
00:23:36,640 --> 00:23:38,000
part

577
00:23:38,000 --> 00:23:38,460
uh

578
00:23:38,460 --> 00:23:39,760
[Music]

579
00:23:39,760 --> 00:23:41,919
what we essentially prove in the paper

580
00:23:41,919 --> 00:23:44,080
is that this proof of knowledge

581
00:23:44,080 --> 00:23:46,720
has to satisfy zero knowledge

582
00:23:46,720 --> 00:23:48,559
and the very specific flavor of

583
00:23:48,559 --> 00:23:50,320
soundness

584
00:23:50,320 --> 00:23:51,840
which will have

585
00:23:51,840 --> 00:23:54,240
straight line simulation extractability

586
00:23:54,240 --> 00:23:55,840
so this is a very

587
00:23:55,840 --> 00:23:57,279
strong notion

588
00:23:57,279 --> 00:23:58,960
of soundness

589
00:23:58,960 --> 00:24:01,120
and in addition

590
00:24:01,120 --> 00:24:02,840
the soundness

591
00:24:02,840 --> 00:24:06,640
adversary is allowed to

592
00:24:06,640 --> 00:24:11,279
ask from the challenger a group element

593
00:24:12,159 --> 00:24:14,960
as we can see here where x1 to xn is

594
00:24:14,960 --> 00:24:16,720
some secret value

595
00:24:16,720 --> 00:24:20,400
and f with some polynomial chosen by the

596
00:24:20,400 --> 00:24:22,799
adversary

597
00:24:22,799 --> 00:24:24,400
and additional

598
00:24:24,400 --> 00:24:26,240
additionally we can

599
00:24:26,240 --> 00:24:28,159
we allow the adversary to query the

600
00:24:28,159 --> 00:24:30,000
random oracle

601
00:24:30,000 --> 00:24:34,080
and we prove this in the model which

602
00:24:34,080 --> 00:24:35,679
combined random rocket model and the

603
00:24:35,679 --> 00:24:37,679
algebra group model

604
00:24:37,679 --> 00:24:40,880
as right group model i will introduce

605
00:24:40,880 --> 00:24:42,559
now

606
00:24:42,559 --> 00:24:45,679
so yeah let's look briefly

607
00:24:45,679 --> 00:24:47,279
what is the

608
00:24:47,279 --> 00:24:50,320
our uh security model and

609
00:24:50,320 --> 00:24:52,240
the security proof

610
00:24:52,240 --> 00:24:55,279
i will give some very brief overview

611
00:24:55,279 --> 00:24:57,679
of our main security proof

612
00:24:57,679 --> 00:24:59,679
but before that what is this algebraic

613
00:24:59,679 --> 00:25:02,320
proof model

614
00:25:02,960 --> 00:25:04,960
so here we have an adversary and the

615
00:25:04,960 --> 00:25:07,520
challenger

616
00:25:07,520 --> 00:25:08,640
and in

617
00:25:08,640 --> 00:25:10,720
algebraic group model

618
00:25:10,720 --> 00:25:12,720
the challenger can give us some group

619
00:25:12,720 --> 00:25:16,240
elements and whenever adversarial puts a

620
00:25:16,240 --> 00:25:18,559
group element a

621
00:25:18,559 --> 00:25:21,039
then he also has to output integers

622
00:25:21,039 --> 00:25:22,480
which are a linear

623
00:25:22,480 --> 00:25:24,640
representation of those group elements

624
00:25:24,640 --> 00:25:26,799
what i mean by this

625
00:25:26,799 --> 00:25:28,480
is that a

626
00:25:28,480 --> 00:25:30,880
has to satisfy

627
00:25:30,880 --> 00:25:34,320
this type of relation

628
00:25:34,880 --> 00:25:37,440
between the elements that he has

629
00:25:37,440 --> 00:25:40,559
received so far

630
00:25:41,360 --> 00:25:42,480
and now

631
00:25:42,480 --> 00:25:45,200
the juncture can send us some new set of

632
00:25:45,200 --> 00:25:46,480
elements

633
00:25:46,480 --> 00:25:49,520
and again with adversary outputs

634
00:25:49,520 --> 00:25:52,320
some group element b

635
00:25:52,320 --> 00:25:55,679
then he has to also provide integers t1

636
00:25:55,679 --> 00:25:57,120
to dm

637
00:25:57,120 --> 00:26:00,159
which again satisfy this type of linear

638
00:26:00,159 --> 00:26:02,720
relation

639
00:26:02,880 --> 00:26:05,120
but notice here that now

640
00:26:05,120 --> 00:26:07,600
uh b can depend

641
00:26:07,600 --> 00:26:10,159
both the elements that were sent in the

642
00:26:10,159 --> 00:26:12,640
first round and also

643
00:26:12,640 --> 00:26:14,240
the ones that were sent in the second

644
00:26:14,240 --> 00:26:15,840
round

645
00:26:15,840 --> 00:26:17,600
but this is what we assume from the

646
00:26:17,600 --> 00:26:18,880
adversary

647
00:26:18,880 --> 00:26:20,400
so essentially this is a restricted

648
00:26:20,400 --> 00:26:23,600
model of computation

649
00:26:23,600 --> 00:26:25,679
is forced to output something that you

650
00:26:25,679 --> 00:26:27,679
would usually not force

651
00:26:27,679 --> 00:26:30,559
but this has become very

652
00:26:30,559 --> 00:26:34,480
uh widely used in the very base setting

653
00:26:34,480 --> 00:26:36,799
and additionally we assume a random

654
00:26:36,799 --> 00:26:38,559
oracle

655
00:26:38,559 --> 00:26:41,840
where adversary can input some

656
00:26:41,840 --> 00:26:44,480
bit string x

657
00:26:44,480 --> 00:26:46,960
and in return you will get a group

658
00:26:46,960 --> 00:26:49,760
element y

659
00:26:49,840 --> 00:26:53,840
which is a random group element

660
00:26:54,159 --> 00:26:57,360
and our security of our main result

661
00:26:57,360 --> 00:26:59,760
depends on q1 q2

662
00:26:59,760 --> 00:27:03,360
discrete logarithm assumption

663
00:27:04,400 --> 00:27:06,640
we're basically adversary will be a

664
00:27:06,640 --> 00:27:07,679
random

665
00:27:07,679 --> 00:27:10,320
exponent set

666
00:27:10,320 --> 00:27:13,039
and send these group elements that you

667
00:27:13,039 --> 00:27:15,840
see on the screen

668
00:27:16,240 --> 00:27:18,320
and now the adversary is

669
00:27:18,320 --> 00:27:20,720
supposed to find

670
00:27:20,720 --> 00:27:22,559
an integer set

671
00:27:22,559 --> 00:27:24,720
which is the exponent

672
00:27:24,720 --> 00:27:26,799
so it's the usual discrete algorithm

673
00:27:26,799 --> 00:27:28,000
assumption

674
00:27:28,000 --> 00:27:29,679
but uh

675
00:27:29,679 --> 00:27:34,240
adversary gets more knowledge than usual

676
00:27:34,240 --> 00:27:36,000
and the statement of our main theorem is

677
00:27:36,000 --> 00:27:36,799
that

678
00:27:36,799 --> 00:27:39,520
if 2 n minus 1 2 n minus 2 discrete

679
00:27:39,520 --> 00:27:41,919
logarithm assumption holds

680
00:27:41,919 --> 00:27:44,320
and we work in this combined model of

681
00:27:44,320 --> 00:27:46,080
algebraic group model and random rocket

682
00:27:46,080 --> 00:27:47,600
model

683
00:27:47,600 --> 00:27:48,720
then

684
00:27:48,720 --> 00:27:51,520
we achieve update knowledge soundness

685
00:27:51,520 --> 00:27:54,559
for the ceremonial krog 16 snack so this

686
00:27:54,559 --> 00:27:56,399
is cross 16 snack

687
00:27:56,399 --> 00:27:59,360
together with this

688
00:27:59,360 --> 00:28:01,200
updating protocol

689
00:28:01,200 --> 00:28:03,520
and notice that here we don't require

690
00:28:03,520 --> 00:28:06,399
random beacon which is one of the main

691
00:28:06,399 --> 00:28:08,080
results

692
00:28:08,080 --> 00:28:11,840
or main achievements of this paper

693
00:28:13,200 --> 00:28:15,279
oh yes and the n here

694
00:28:15,279 --> 00:28:17,120
stands for

695
00:28:17,120 --> 00:28:19,520
the number of multiplication gates in

696
00:28:19,520 --> 00:28:23,279
the circuit of the relation

697
00:28:23,279 --> 00:28:26,320
so i will very briefly go over

698
00:28:26,320 --> 00:28:28,880
of a high level strategy of our main

699
00:28:28,880 --> 00:28:30,640
security proof

700
00:28:30,640 --> 00:28:33,039
and this will end this talk

701
00:28:33,039 --> 00:28:35,600
so essentially the idea is that okay we

702
00:28:35,600 --> 00:28:39,360
pick some algebraic adversary a

703
00:28:39,360 --> 00:28:40,960
and then

704
00:28:40,960 --> 00:28:43,360
we will construct an extractor and this

705
00:28:43,360 --> 00:28:45,360
extractor

706
00:28:45,360 --> 00:28:46,800
will

707
00:28:46,800 --> 00:28:48,960
[Music]

708
00:28:48,960 --> 00:28:52,320
output specific

709
00:28:52,320 --> 00:28:55,120
coefficients

710
00:28:55,120 --> 00:28:56,720
like this algebraic representation

711
00:28:56,720 --> 00:28:59,840
coefficients that i showed before

712
00:28:59,840 --> 00:29:02,399
which we claim that will

713
00:29:02,399 --> 00:29:06,159
now correspond to the witness

714
00:29:06,159 --> 00:29:09,120
and our rest of the proof will actually

715
00:29:09,120 --> 00:29:11,600
be we will be arguing that this output

716
00:29:11,600 --> 00:29:16,158
of extractor is indeed the witness

717
00:29:17,279 --> 00:29:18,320
the

718
00:29:18,320 --> 00:29:19,680
views are several games

719
00:29:19,680 --> 00:29:21,039
[Music]

720
00:29:21,039 --> 00:29:23,440
game zero is the original optic noise on

721
00:29:23,440 --> 00:29:26,320
this game with adverse array and the

722
00:29:26,320 --> 00:29:30,080
extractor that i just described

723
00:29:30,240 --> 00:29:31,840
and

724
00:29:31,840 --> 00:29:34,000
so

725
00:29:34,000 --> 00:29:34,880
if

726
00:29:34,880 --> 00:29:37,120
gear5

727
00:29:37,120 --> 00:29:38,559
is the

728
00:29:38,559 --> 00:29:40,399
setup update proofs

729
00:29:40,399 --> 00:29:43,520
in summon phase 5

730
00:29:43,520 --> 00:29:45,840
then we call the critical query to be

731
00:29:45,840 --> 00:29:47,120
the last

732
00:29:47,120 --> 00:29:49,679
honest update that is the update timing

733
00:29:49,679 --> 00:29:52,559
by the challenger

734
00:29:53,200 --> 00:29:54,960
and in game one

735
00:29:54,960 --> 00:29:57,200
what we will try to do is try we will

736
00:29:57,200 --> 00:29:59,279
guess

737
00:29:59,279 --> 00:30:02,480
the index for the critical query

738
00:30:02,480 --> 00:30:05,840
before the beginning of the protocol

739
00:30:05,840 --> 00:30:07,679
um

740
00:30:07,679 --> 00:30:11,600
we don't know despite i guess

741
00:30:11,760 --> 00:30:14,000
and uh

742
00:30:14,000 --> 00:30:17,200
basically if we guess it correctly

743
00:30:17,200 --> 00:30:19,760
then the challenger

744
00:30:19,760 --> 00:30:21,520
will on the ice

745
00:30:21,520 --> 00:30:22,559
i guess

746
00:30:22,559 --> 00:30:25,679
query he will not update

747
00:30:25,679 --> 00:30:28,159
the srs proposed by the

748
00:30:28,159 --> 00:30:30,880
adversary but he will instead generate a

749
00:30:30,880 --> 00:30:33,440
completely fresh srs

750
00:30:33,440 --> 00:30:34,840
which is

751
00:30:34,840 --> 00:30:37,360
unbiased and

752
00:30:37,360 --> 00:30:39,440
he will instead simulate the update

753
00:30:39,440 --> 00:30:40,720
proof

754
00:30:40,720 --> 00:30:42,480
so now what this will guarantee for us

755
00:30:42,480 --> 00:30:43,840
is that

756
00:30:43,840 --> 00:30:47,039
the srs from this point on

757
00:30:47,039 --> 00:30:48,480
has not been

758
00:30:48,480 --> 00:30:50,559
up to this point has not been biased at

759
00:30:50,559 --> 00:30:52,320
all by the adversary because we

760
00:30:52,320 --> 00:30:55,200
generated it freshly

761
00:30:55,200 --> 00:30:57,600
um

762
00:30:58,000 --> 00:31:00,240
and we will use the zero knowledge and

763
00:31:00,240 --> 00:31:02,240
straight line simulation extractability

764
00:31:02,240 --> 00:31:03,519
properties

765
00:31:03,519 --> 00:31:05,679
of this protocol knowledge

766
00:31:05,679 --> 00:31:07,200
sub protocol

767
00:31:07,200 --> 00:31:08,720
to show that these two games are

768
00:31:08,720 --> 00:31:11,519
indistinguishable

769
00:31:11,519 --> 00:31:14,240
and then the algebraic group model part

770
00:31:14,240 --> 00:31:16,840
of the proof will look something like

771
00:31:16,840 --> 00:31:21,039
this we define a polynomial q

772
00:31:21,039 --> 00:31:21,840
in

773
00:31:21,840 --> 00:31:25,600
the trapdoor variables x excel by expata

774
00:31:25,600 --> 00:31:28,159
index delta

775
00:31:28,159 --> 00:31:29,360
where

776
00:31:29,360 --> 00:31:31,519
if you

777
00:31:31,519 --> 00:31:33,840
apply

778
00:31:34,000 --> 00:31:37,120
basically the trap doors at the point

779
00:31:37,120 --> 00:31:40,239
at the index guess

780
00:31:41,919 --> 00:31:42,640
that

781
00:31:42,640 --> 00:31:46,320
they will be zero exactly when we accept

782
00:31:46,320 --> 00:31:48,320
so this q is essentially some very

783
00:31:48,320 --> 00:31:50,320
complicated polynomial

784
00:31:50,320 --> 00:31:52,399
which depends on the verification

785
00:31:52,399 --> 00:31:53,840
equation

786
00:31:53,840 --> 00:31:56,559
all the intermediate srs states and

787
00:31:56,559 --> 00:31:59,519
random oracle responses to the adversary

788
00:31:59,519 --> 00:32:01,519
and also the agent coefficients of the

789
00:32:01,519 --> 00:32:03,120
adversary

790
00:32:03,120 --> 00:32:04,960
but it will have this property that it

791
00:32:04,960 --> 00:32:06,320
is zero

792
00:32:06,320 --> 00:32:08,399
exactly when

793
00:32:08,399 --> 00:32:11,120
v accepts the proof

794
00:32:11,120 --> 00:32:12,880
and now the proof will branch into two

795
00:32:12,880 --> 00:32:16,000
parts in the first part

796
00:32:16,000 --> 00:32:18,559
we say okay suppose that this polynomial

797
00:32:18,559 --> 00:32:20,960
q is not zero

798
00:32:20,960 --> 00:32:23,840
then we show that we can do a reduction

799
00:32:23,840 --> 00:32:25,600
to this variation of the discrete

800
00:32:25,600 --> 00:32:27,679
logarithm assumption

801
00:32:27,679 --> 00:32:29,120
and

802
00:32:29,120 --> 00:32:31,360
if it is zero

803
00:32:31,360 --> 00:32:32,960
then

804
00:32:32,960 --> 00:32:35,440
we show

805
00:32:35,570 --> 00:32:37,440
[Music]

806
00:32:37,440 --> 00:32:39,120
by arguing the structure of this

807
00:32:39,120 --> 00:32:40,799
polynomial

808
00:32:40,799 --> 00:32:43,200
that whatever the extractor outputs is

809
00:32:43,200 --> 00:32:44,880
actually the witness

810
00:32:44,880 --> 00:32:47,039
so this is a very technical part of the

811
00:32:47,039 --> 00:32:48,399
proof

812
00:32:48,399 --> 00:32:52,239
but it indeed seems to work out

813
00:32:52,640 --> 00:32:55,919
so so much about this proof and this is

814
00:32:55,919 --> 00:32:58,240
this was the by far the hardest part of

815
00:32:58,240 --> 00:33:00,480
this paper i think it took us

816
00:33:00,480 --> 00:33:02,799
a couple of months to get this proof

817
00:33:02,799 --> 00:33:04,399
correct

818
00:33:04,399 --> 00:33:04,990
um

819
00:33:04,990 --> 00:33:06,159
[Music]

820
00:33:06,159 --> 00:33:07,840
but yeah so the main takeaway helped

821
00:33:07,840 --> 00:33:10,240
this paper

822
00:33:10,240 --> 00:33:12,720
even non-applicable snacks

823
00:33:12,720 --> 00:33:15,840
can be updated if we allow it multiple

824
00:33:15,840 --> 00:33:18,000
phases

825
00:33:18,000 --> 00:33:20,640
and this seems to have very little

826
00:33:20,640 --> 00:33:21,679
different

827
00:33:21,679 --> 00:33:24,480
difference in practice if you have

828
00:33:24,480 --> 00:33:26,320
only one phase updating or two phase

829
00:33:26,320 --> 00:33:28,159
updating

830
00:33:28,159 --> 00:33:29,279
however

831
00:33:29,279 --> 00:33:31,840
what is actually important is that those

832
00:33:31,840 --> 00:33:34,880
one-phase updatable snarks

833
00:33:34,880 --> 00:33:37,760
are also universal typically and by

834
00:33:37,760 --> 00:33:40,640
universal i mean that the srs does not

835
00:33:40,640 --> 00:33:42,960
depend on the relation

836
00:33:42,960 --> 00:33:44,720
and this might be actually much more

837
00:33:44,720 --> 00:33:48,080
difficult to achieve

838
00:33:50,240 --> 00:33:52,159
but there is actually a protocol called

839
00:33:52,159 --> 00:33:53,919
mirage

840
00:33:53,919 --> 00:33:56,880
where they do modificate 16

841
00:33:56,880 --> 00:33:59,519
to also obtain universality

842
00:33:59,519 --> 00:34:01,039
but this is already quite a big

843
00:34:01,039 --> 00:34:03,519
modification i would say

844
00:34:03,519 --> 00:34:05,519
but if you apply this paper together

845
00:34:05,519 --> 00:34:08,560
with the mirage then you can get a

846
00:34:08,560 --> 00:34:10,639
version of quote 16 which is both

847
00:34:10,639 --> 00:34:14,320
universal and updatable

848
00:34:14,879 --> 00:34:16,879
so yeah thank you for

849
00:34:16,879 --> 00:34:19,879
listening

850
00:34:20,480 --> 00:34:22,560
you

