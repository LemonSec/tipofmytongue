1
00:00:00,399 --> 00:00:02,080
hi everyone welcome to this presentation

2
00:00:02,080 --> 00:00:03,840
we should be about quantum linearization

3
00:00:03,840 --> 00:00:05,920
attacks this is a joint work with xavier

4
00:00:05,920 --> 00:00:07,279
banter

5
00:00:07,279 --> 00:00:09,760
and maya they appreciate

6
00:00:09,760 --> 00:00:11,840
so i will start this presentation by a

7
00:00:11,840 --> 00:00:14,400
little introduction and some context on

8
00:00:14,400 --> 00:00:15,519
quantum attacks in symmetric

9
00:00:15,519 --> 00:00:16,640
cryptography

10
00:00:16,640 --> 00:00:18,240
then we're going to see precisely what

11
00:00:18,240 --> 00:00:20,880
we do here quantum forgery attacks on

12
00:00:20,880 --> 00:00:23,119
message authentication codes

13
00:00:23,119 --> 00:00:26,480
and then i introduce the new attack

14
00:00:26,480 --> 00:00:29,439
so in symmetry crypto

15
00:00:29,439 --> 00:00:31,039
when we come to the

16
00:00:31,039 --> 00:00:33,120
security against quantum adversaries

17
00:00:33,120 --> 00:00:34,480
there are actually two

18
00:00:34,480 --> 00:00:36,000
main

19
00:00:36,000 --> 00:00:38,399
kind of attackers we can consider

20
00:00:38,399 --> 00:00:41,040
in the first setting let's say what we

21
00:00:41,040 --> 00:00:44,079
call the q1 model the adversary has

22
00:00:44,079 --> 00:00:45,680
quantum

23
00:00:45,680 --> 00:00:47,840
can do quantum computations but you can

24
00:00:47,840 --> 00:00:50,000
only make classical queries to a black

25
00:00:50,000 --> 00:00:51,920
box for example a cipher with a secret

26
00:00:51,920 --> 00:00:53,360
key

27
00:00:53,360 --> 00:00:55,840
this is the more realistic model and

28
00:00:55,840 --> 00:00:57,120
this is also the model in which for

29
00:00:57,120 --> 00:00:58,399
example you can think of applying

30
00:00:58,399 --> 00:01:00,800
rover's algorithm to a recovery of the

31
00:01:00,800 --> 00:01:01,840
key

32
00:01:01,840 --> 00:01:03,920
in this situation so far we have playing

33
00:01:03,920 --> 00:01:05,920
only polynomial speedups on our symmetry

34
00:01:05,920 --> 00:01:07,680
crypto attacks

35
00:01:07,680 --> 00:01:09,520
now there is a stronger model strictly

36
00:01:09,520 --> 00:01:11,520
stronger in which the adversary can do

37
00:01:11,520 --> 00:01:13,760
quantum computations but you can also

38
00:01:13,760 --> 00:01:14,799
query

39
00:01:14,799 --> 00:01:16,799
this black box from inside the quantum

40
00:01:16,799 --> 00:01:17,920
algorithm

41
00:01:17,920 --> 00:01:19,680
which means this black box which

42
00:01:19,680 --> 00:01:21,119
contains a secret

43
00:01:21,119 --> 00:01:22,159
right

44
00:01:22,159 --> 00:01:24,880
can become a quantum oracle or a super

45
00:01:24,880 --> 00:01:27,280
superposition record

46
00:01:27,280 --> 00:01:29,439
and this allows new attacks in

47
00:01:29,439 --> 00:01:31,439
particular these settles some breaks and

48
00:01:31,439 --> 00:01:33,680
some exponential speedups on attacks

49
00:01:33,680 --> 00:01:36,960
that didn't exist classically

50
00:01:36,960 --> 00:01:39,200
this is also a model in which basically

51
00:01:39,200 --> 00:01:41,280
you don't put any restriction on what

52
00:01:41,280 --> 00:01:43,439
the adversary can do with this oracle

53
00:01:43,439 --> 00:01:45,520
with this oracle so perhaps it's also

54
00:01:45,520 --> 00:01:47,280
actually more suited if you if you want

55
00:01:47,280 --> 00:01:49,280
to prove the security

56
00:01:49,280 --> 00:01:50,799
of these constructions of some

57
00:01:50,799 --> 00:01:55,720
constructions in the quantum world

58
00:01:55,759 --> 00:01:58,640
so this quantum superposition attacks

59
00:01:58,640 --> 00:02:01,759
work usually this way

60
00:02:01,759 --> 00:02:04,000
you have a symmetric construction

61
00:02:04,000 --> 00:02:05,119
and you're going to target this

62
00:02:05,119 --> 00:02:06,960
structure so usually you can abstract

63
00:02:06,960 --> 00:02:08,479
out all the sub-components that you're

64
00:02:08,479 --> 00:02:09,679
using there

65
00:02:09,679 --> 00:02:12,239
it's always a structure that is attacked

66
00:02:12,239 --> 00:02:13,280
and

67
00:02:13,280 --> 00:02:16,000
it has a classical security proof but

68
00:02:16,000 --> 00:02:18,000
there is a way

69
00:02:18,000 --> 00:02:19,360
to use

70
00:02:19,360 --> 00:02:22,000
a quantum hidden shift or hidden period

71
00:02:22,000 --> 00:02:24,080
algorithm a dedicated one

72
00:02:24,080 --> 00:02:24,879
to

73
00:02:24,879 --> 00:02:26,080
break this construction using

74
00:02:26,080 --> 00:02:27,840
superposition quiz

75
00:02:27,840 --> 00:02:30,800
so basically you translate this uh the

76
00:02:30,800 --> 00:02:32,640
key recovery problem or state recovery

77
00:02:32,640 --> 00:02:33,599
problem

78
00:02:33,599 --> 00:02:35,519
into a hidden period problem and then

79
00:02:35,519 --> 00:02:38,080
you use a dedicated control algorithm

80
00:02:38,080 --> 00:02:39,760
to solve this problem

81
00:02:39,760 --> 00:02:41,440
and this is where we need to position

82
00:02:41,440 --> 00:02:44,560
queries to the construction

83
00:02:45,440 --> 00:02:46,879
a typical

84
00:02:46,879 --> 00:02:49,120
tool that we use and the one we that

85
00:02:49,120 --> 00:02:51,120
we're going to use today is simon's

86
00:02:51,120 --> 00:02:53,760
algorithm it says the following problem

87
00:02:53,760 --> 00:02:55,360
you have a function and the function has

88
00:02:55,360 --> 00:02:56,560
a period

89
00:02:56,560 --> 00:02:59,599
or let's say it is either injective

90
00:02:59,599 --> 00:03:02,400
or it is two to one with a period a

91
00:03:02,400 --> 00:03:04,879
boolean period so if you take x and if

92
00:03:04,879 --> 00:03:07,360
you take x or your period you have the

93
00:03:07,360 --> 00:03:09,440
same image and you want to determine the

94
00:03:09,440 --> 00:03:12,959
case or to find the product if it exists

95
00:03:12,959 --> 00:03:16,879
now simon's algorithm is very powerful

96
00:03:16,879 --> 00:03:18,879
but a single superposition query to f

97
00:03:18,879 --> 00:03:21,200
you can sample a random vector that is

98
00:03:21,200 --> 00:03:24,319
orthogonal to separate

99
00:03:24,319 --> 00:03:26,720
and of course if you do that n times or

100
00:03:26,720 --> 00:03:29,120
a linear number of times you can have

101
00:03:29,120 --> 00:03:30,799
enough information to recover the period

102
00:03:30,799 --> 00:03:33,519
with a linear system

103
00:03:33,519 --> 00:03:36,319
now what we mean by superposition query

104
00:03:36,319 --> 00:03:37,120
is

105
00:03:37,120 --> 00:03:39,920
you actually apply f on a quantum state

106
00:03:39,920 --> 00:03:41,440
and this quantum state can be an

107
00:03:41,440 --> 00:03:43,040
arbitrary preposition

108
00:03:43,040 --> 00:03:45,440
of all possible input values this is why

109
00:03:45,440 --> 00:03:48,159
we say superposition queries

110
00:03:48,159 --> 00:03:50,319
but we're not going to enter into any

111
00:03:50,319 --> 00:03:51,760
more details of the quantum algorithms

112
00:03:51,760 --> 00:03:53,519
since we can use simon's algorithm as

113
00:03:53,519 --> 00:03:55,439
blackbox

114
00:03:55,439 --> 00:03:58,000
uh it's it's important to note that the

115
00:03:58,000 --> 00:04:00,159
original problem wasn't a cryptographic

116
00:04:00,159 --> 00:04:01,200
problem

117
00:04:01,200 --> 00:04:02,879
because the function was two to one but

118
00:04:02,879 --> 00:04:05,439
if f is a random function

119
00:04:05,439 --> 00:04:07,360
with the only promise that it has a

120
00:04:07,360 --> 00:04:08,319
period

121
00:04:08,319 --> 00:04:11,760
the algorithm is still going to work

122
00:04:12,640 --> 00:04:15,120
so in this paper we introduce an attack

123
00:04:15,120 --> 00:04:16,798
which we call the quantum linearization

124
00:04:16,798 --> 00:04:19,519
attack and it's a new way to use period

125
00:04:19,519 --> 00:04:22,479
finding uh and algorithms such as

126
00:04:22,479 --> 00:04:24,320
segments to target symmetric

127
00:04:24,320 --> 00:04:27,360
constructions any particular max

128
00:04:27,360 --> 00:04:29,759
so we create new photoread tags on many

129
00:04:29,759 --> 00:04:31,919
mac constructions

130
00:04:31,919 --> 00:04:34,160
we also end up using more algorithms

131
00:04:34,160 --> 00:04:36,479
than just assignments we use

132
00:04:36,479 --> 00:04:40,000
dodge algorithm a short algorithm

133
00:04:40,000 --> 00:04:41,360
and there are many there are many

134
00:04:41,360 --> 00:04:43,360
targets that are concerned by this uh

135
00:04:43,360 --> 00:04:46,960
many macs that uh parallel pilots aboard

136
00:04:46,960 --> 00:04:49,600
max and and also beyond burst upon max

137
00:04:49,600 --> 00:04:51,280
and so on

138
00:04:51,280 --> 00:04:53,280
um we also obtained for example the new

139
00:04:53,280 --> 00:04:55,520
superposition attack on 0.81305 the

140
00:04:55,520 --> 00:04:57,680
previous one had two today 38 degrees

141
00:04:57,680 --> 00:05:00,000
and this one has a 32 about about 32

142
00:05:00,000 --> 00:05:01,520
degrees

143
00:05:01,520 --> 00:05:03,280
okay

144
00:05:03,280 --> 00:05:04,479
but let's

145
00:05:04,479 --> 00:05:07,039
let's see the cryptographic context now

146
00:05:07,039 --> 00:05:09,600
for the for these attacks

147
00:05:09,600 --> 00:05:11,360
so we're studying max

148
00:05:11,360 --> 00:05:14,560
mostly and a mac message authentication

149
00:05:14,560 --> 00:05:16,479
code is simply a function

150
00:05:16,479 --> 00:05:18,240
that

151
00:05:18,240 --> 00:05:20,720
given a certain secret k and on a

152
00:05:20,720 --> 00:05:23,039
message of any length produces an

153
00:05:23,039 --> 00:05:25,680
authentication tag

154
00:05:25,680 --> 00:05:27,120
so what we want

155
00:05:27,120 --> 00:05:29,039
of this mac is that it must be

156
00:05:29,039 --> 00:05:30,479
unfoldable

157
00:05:30,479 --> 00:05:32,320
so an adversary that is making chosen

158
00:05:32,320 --> 00:05:33,759
message queries

159
00:05:33,759 --> 00:05:35,600
describing the mac

160
00:05:35,600 --> 00:05:36,479
with

161
00:05:36,479 --> 00:05:38,880
chosen messages shouldn't be able to

162
00:05:38,880 --> 00:05:41,360
come up with a valid tag for a message

163
00:05:41,360 --> 00:05:43,919
he hasn't created

164
00:05:43,919 --> 00:05:46,160
now

165
00:05:46,160 --> 00:05:48,880
we can also consider a max that admits

166
00:05:48,880 --> 00:05:52,240
an additional input the initial value iv

167
00:05:52,240 --> 00:05:53,759
or unknowns

168
00:05:53,759 --> 00:05:56,479
and the role of this input is to

169
00:05:56,479 --> 00:05:58,720
is is to be a random

170
00:05:58,720 --> 00:06:01,199
value or an unrepeated value that the

171
00:06:01,199 --> 00:06:03,840
adversary is not going to control

172
00:06:03,840 --> 00:06:04,720
and

173
00:06:04,720 --> 00:06:07,199
and then the definition adapts uh

174
00:06:07,199 --> 00:06:09,039
easily because we just say the adversary

175
00:06:09,039 --> 00:06:11,520
shouldn't output a valid triple iv

176
00:06:11,520 --> 00:06:12,800
message tag

177
00:06:12,800 --> 00:06:15,680
for a new iv message he hasn't created

178
00:06:15,680 --> 00:06:18,000
before

179
00:06:18,080 --> 00:06:20,400
we can consider max with ivs or without

180
00:06:20,400 --> 00:06:22,479
ivs

181
00:06:22,479 --> 00:06:25,280
but for now we will start with macs that

182
00:06:25,280 --> 00:06:28,000
use ivs

183
00:06:29,840 --> 00:06:32,319
what does a new message mean in the

184
00:06:32,319 --> 00:06:34,639
quantum setting this is the main

185
00:06:34,639 --> 00:06:36,080
question because the adversary now is

186
00:06:36,080 --> 00:06:39,840
making superposition queries to the mac

187
00:06:40,400 --> 00:06:42,160
and the superposition query possibly

188
00:06:42,160 --> 00:06:43,280
contains all the messages in

189
00:06:43,280 --> 00:06:44,960
superposition

190
00:06:44,960 --> 00:06:46,800
fortunately there are appropriate

191
00:06:46,800 --> 00:06:48,240
definitions in the quantum setting the

192
00:06:48,240 --> 00:06:51,520
first one was uh what we call uh plus

193
00:06:51,520 --> 00:06:54,639
one unfortunately by body and sorry and

194
00:06:54,639 --> 00:06:56,880
there we just say the adversary makes q

195
00:06:56,880 --> 00:06:58,400
queries and he shouldn't be able to

196
00:06:58,400 --> 00:07:02,240
output q plus one valid message tags

197
00:07:02,240 --> 00:07:03,680
there is a stronger definition which was

198
00:07:03,680 --> 00:07:04,960
developed

199
00:07:04,960 --> 00:07:07,039
at your group 20

200
00:07:07,039 --> 00:07:09,360
and splined affordability

201
00:07:09,360 --> 00:07:11,120
so the adversary is making blinded

202
00:07:11,120 --> 00:07:13,360
macros so he can only

203
00:07:13,360 --> 00:07:15,360
query the mac basically on the subset of

204
00:07:15,360 --> 00:07:16,400
the messages

205
00:07:16,400 --> 00:07:17,840
and he shouldn't be able to output the

206
00:07:17,840 --> 00:07:19,919
tag of a message that is outside this

207
00:07:19,919 --> 00:07:22,080
subset

208
00:07:22,080 --> 00:07:24,160
and even stronger there is the security

209
00:07:24,160 --> 00:07:26,560
as a quantum scenario function in there

210
00:07:26,560 --> 00:07:28,880
the adversary really cannot distinguish

211
00:07:28,880 --> 00:07:29,840
at all

212
00:07:29,840 --> 00:07:30,960
the mac

213
00:07:30,960 --> 00:07:33,840
from a random function

214
00:07:33,840 --> 00:07:37,599
so all these notions um well being a

215
00:07:37,599 --> 00:07:39,360
pseudonym function implies blind

216
00:07:39,360 --> 00:07:41,840
affordability implies plus one so we

217
00:07:41,840 --> 00:07:44,240
just focus on breaking plus one and this

218
00:07:44,240 --> 00:07:47,599
breaks all the other notions

219
00:07:47,919 --> 00:07:50,800
so let's take an example

220
00:07:50,800 --> 00:07:53,280
and this would be the

221
00:07:53,280 --> 00:07:56,800
tag part the tag computation in ocp

222
00:07:56,800 --> 00:07:58,720
ocb is a mod in which you do the

223
00:07:58,720 --> 00:08:00,479
encryption and also the authentication

224
00:08:00,479 --> 00:08:01,759
at the same time

225
00:08:01,759 --> 00:08:04,080
but then we only consider here the

226
00:08:04,080 --> 00:08:05,599
the authentication

227
00:08:05,599 --> 00:08:08,080
so it's based on a block cipher

228
00:08:08,080 --> 00:08:09,759
you have all the associated data blocks

229
00:08:09,759 --> 00:08:11,199
which are

230
00:08:11,199 --> 00:08:14,800
controlled they're part of the queries

231
00:08:14,800 --> 00:08:17,520
the n-bit blocks we exalt them to offset

232
00:08:17,520 --> 00:08:20,319
values which are secret values we

233
00:08:20,319 --> 00:08:22,800
encrypt through ek

234
00:08:22,800 --> 00:08:24,400
and

235
00:08:24,400 --> 00:08:26,400
we store everything and then we add

236
00:08:26,400 --> 00:08:28,639
message checksum

237
00:08:28,639 --> 00:08:30,960
and we obtain our n-bit tag

238
00:08:30,960 --> 00:08:33,039
so the assets should be secret

239
00:08:33,039 --> 00:08:35,279
and also each time we do a query we

240
00:08:35,279 --> 00:08:37,360
change the iv

241
00:08:37,360 --> 00:08:39,039
okay

242
00:08:39,039 --> 00:08:40,719
so what can a quantum adversary do on

243
00:08:40,719 --> 00:08:42,240
that

244
00:08:42,240 --> 00:08:44,880
well um let's take an empty message so

245
00:08:44,880 --> 00:08:46,320
we don't don't have to care about the

246
00:08:46,320 --> 00:08:48,240
message and then we take two end bit

247
00:08:48,240 --> 00:08:49,600
blocks

248
00:08:49,600 --> 00:08:52,959
uh which are equal 2 n bits equal

249
00:08:52,959 --> 00:08:54,560
80 blocks

250
00:08:54,560 --> 00:08:56,560
and we look at the input and we look at

251
00:08:56,560 --> 00:08:58,720
the mac with these two blocks

252
00:08:58,720 --> 00:09:00,959
and both are equal

253
00:09:00,959 --> 00:09:03,920
and we observe that actually

254
00:09:03,920 --> 00:09:05,680
there is an equality between calling the

255
00:09:05,680 --> 00:09:08,720
mac with these two block x and coding

256
00:09:08,720 --> 00:09:12,640
the mac with these two blocks x process

257
00:09:12,640 --> 00:09:14,720
where s would be

258
00:09:14,720 --> 00:09:16,560
the saw of the two offsets

259
00:09:16,560 --> 00:09:19,200
of delta zero and delta one

260
00:09:19,200 --> 00:09:21,360
because storing the two sets just means

261
00:09:21,360 --> 00:09:22,720
we're basically exchanging the blocks

262
00:09:22,720 --> 00:09:24,160
but the blocks are equal so exchanging

263
00:09:24,160 --> 00:09:25,680
two equal blocks so it gives the same

264
00:09:25,680 --> 00:09:27,920
value

265
00:09:27,920 --> 00:09:29,279
um

266
00:09:29,279 --> 00:09:30,320
and then we have that we have this

267
00:09:30,320 --> 00:09:31,600
periodicity

268
00:09:31,600 --> 00:09:33,519
that's nice

269
00:09:33,519 --> 00:09:35,600
then you can say well the iv is changing

270
00:09:35,600 --> 00:09:37,519
at each query but it's not really a

271
00:09:37,519 --> 00:09:38,560
problem

272
00:09:38,560 --> 00:09:40,399
because simon's subroutine uses a single

273
00:09:40,399 --> 00:09:41,600
query anyway

274
00:09:41,600 --> 00:09:43,279
and once you have done that you obtain a

275
00:09:43,279 --> 00:09:45,360
vector orthogonal period

276
00:09:45,360 --> 00:09:46,640
so what really matters is that the

277
00:09:46,640 --> 00:09:48,959
period stays always the same

278
00:09:48,959 --> 00:09:50,880
just making new queries to different

279
00:09:50,880 --> 00:09:52,480
functions but since it's always the same

280
00:09:52,480 --> 00:09:54,480
period you can still

281
00:09:54,480 --> 00:09:57,680
you can still end up recovering it

282
00:09:57,680 --> 00:09:59,040
so

283
00:09:59,040 --> 00:10:01,040
after making a few queries to the mac

284
00:10:01,040 --> 00:10:04,320
few quantum queries we find the period s

285
00:10:04,320 --> 00:10:07,040
and once we know s we can actually

286
00:10:07,040 --> 00:10:09,839
double the number of tags

287
00:10:09,839 --> 00:10:11,200
that we

288
00:10:11,200 --> 00:10:13,680
output by making queries

289
00:10:13,680 --> 00:10:15,519
because we know that any message that

290
00:10:15,519 --> 00:10:16,880
starts with

291
00:10:16,880 --> 00:10:18,399
a0 a1

292
00:10:18,399 --> 00:10:20,399
and any misses that starts with a1 plus

293
00:10:20,399 --> 00:10:22,160
s a0 plus s

294
00:10:22,160 --> 00:10:23,680
we have the same tag

295
00:10:23,680 --> 00:10:26,160
because s corresponds to exchanging

296
00:10:26,160 --> 00:10:27,680
the two offsets

297
00:10:27,680 --> 00:10:30,320
so we cannot put from a single query two

298
00:10:30,320 --> 00:10:31,760
valid

299
00:10:31,760 --> 00:10:35,600
triples in that case message iv attack

300
00:10:35,600 --> 00:10:37,600
and of course we break the plus one and

301
00:10:37,600 --> 00:10:40,240
forge ability

302
00:10:41,440 --> 00:10:43,519
so all these previous attacks on max

303
00:10:43,519 --> 00:10:45,839
they they did all that that consisted

304
00:10:45,839 --> 00:10:47,600
all in

305
00:10:47,600 --> 00:10:49,519
finding out a

306
00:10:49,519 --> 00:10:51,519
hidden period problem

307
00:10:51,519 --> 00:10:53,440
and this usually happens because there

308
00:10:53,440 --> 00:10:55,600
is a control value

309
00:10:55,600 --> 00:10:57,360
in our case the ad blocks which is

310
00:10:57,360 --> 00:10:59,440
exhaust to a secret value in our case

311
00:10:59,440 --> 00:11:01,120
the offsets

312
00:11:01,120 --> 00:11:03,040
and you can use this hidden period

313
00:11:03,040 --> 00:11:05,760
problem as a recovery of this internal

314
00:11:05,760 --> 00:11:07,360
secret value

315
00:11:07,360 --> 00:11:09,200
and once you have that

316
00:11:09,200 --> 00:11:11,680
then usually there is this can yield

317
00:11:11,680 --> 00:11:14,480
some internal collision which increases

318
00:11:14,480 --> 00:11:15,920
the number of tags you can produce by

319
00:11:15,920 --> 00:11:18,480
macquaries and completely breaks the

320
00:11:18,480 --> 00:11:21,279
unfoldability

321
00:11:22,160 --> 00:11:25,279
which brings us to the idea of

322
00:11:25,279 --> 00:11:27,839
our new

323
00:11:27,839 --> 00:11:29,120
and to

324
00:11:29,120 --> 00:11:31,360
to see how it happens we're going to

325
00:11:31,360 --> 00:11:34,399
start by trying to avoid

326
00:11:34,399 --> 00:11:35,839
the attack that is just presented on the

327
00:11:35,839 --> 00:11:37,760
cb

328
00:11:37,760 --> 00:11:39,760
let's remove the offsets to make life

329
00:11:39,760 --> 00:11:43,120
difficult for quantum adversary and this

330
00:11:43,120 --> 00:11:44,000
would

331
00:11:44,000 --> 00:11:46,320
bring us to the cp which is an

332
00:11:46,320 --> 00:11:48,640
abstraction of ocb in which instead of

333
00:11:48,640 --> 00:11:50,240
having offsets and block cipher calls

334
00:11:50,240 --> 00:11:51,440
you have a tweakable block cipher

335
00:11:51,440 --> 00:11:52,720
instead

336
00:11:52,720 --> 00:11:54,240
this tweakable block cipher is just a

337
00:11:54,240 --> 00:11:55,839
family of block ciphers indexed by the

338
00:11:55,839 --> 00:11:58,320
tweak they make all these

339
00:11:58,320 --> 00:12:00,000
block ciphers

340
00:12:00,000 --> 00:12:02,079
independent

341
00:12:02,079 --> 00:12:03,360
and

342
00:12:03,360 --> 00:12:05,279
while now you don't have xor with it

343
00:12:05,279 --> 00:12:07,200
with the offset anymore and so you don't

344
00:12:07,200 --> 00:12:09,519
have the nice periodicity property that

345
00:12:09,519 --> 00:12:11,680
we observed the previous attack doesn't

346
00:12:11,680 --> 00:12:12,639
work

347
00:12:12,639 --> 00:12:14,079
but actually on this precise

348
00:12:14,079 --> 00:12:15,279
construction

349
00:12:15,279 --> 00:12:17,920
there is an easier attack that is based

350
00:12:17,920 --> 00:12:20,240
on deutsche algorithm

351
00:12:20,240 --> 00:12:21,760
which sounds a bit weird because dodge

352
00:12:21,760 --> 00:12:23,600
algorithm is actually the

353
00:12:23,600 --> 00:12:26,079
simplest quantum algorithm there is

354
00:12:26,079 --> 00:12:28,320
it just solves the following problem

355
00:12:28,320 --> 00:12:30,160
with a constant

356
00:12:30,160 --> 00:12:31,600
speed up

357
00:12:31,600 --> 00:12:33,120
you are going to

358
00:12:33,120 --> 00:12:35,200
find out if a function from one bit to

359
00:12:35,200 --> 00:12:38,399
one bit is constant or balanced with a

360
00:12:38,399 --> 00:12:40,639
single query

361
00:12:40,639 --> 00:12:41,760
classically of course you need two

362
00:12:41,760 --> 00:12:43,680
queries to find out

363
00:12:43,680 --> 00:12:46,000
and there basically you're computing the

364
00:12:46,000 --> 00:12:48,079
xor of the two outputs of f

365
00:12:48,079 --> 00:12:50,320
with a single preposition query this is

366
00:12:50,320 --> 00:12:53,680
exactly what deutsche algorithm does

367
00:12:53,680 --> 00:12:54,720
um

368
00:12:54,720 --> 00:12:57,040
let's use that with our mac function

369
00:12:57,040 --> 00:12:57,920
here

370
00:12:57,920 --> 00:12:59,600
so we're going to take a single block

371
00:12:59,600 --> 00:13:01,200
and this is going to be either a zero or

372
00:13:01,200 --> 00:13:02,160
one

373
00:13:02,160 --> 00:13:04,160
i do have a function of this block of

374
00:13:04,160 --> 00:13:06,560
this box zero one and we truncate the

375
00:13:06,560 --> 00:13:08,000
output to a single bit so now we have a

376
00:13:08,000 --> 00:13:10,720
function from one bit to one bit

377
00:13:10,720 --> 00:13:12,880
and with a single superposition query to

378
00:13:12,880 --> 00:13:14,079
this mac

379
00:13:14,079 --> 00:13:15,680
we can obtain

380
00:13:15,680 --> 00:13:17,440
one bit

381
00:13:17,440 --> 00:13:18,800
of uh

382
00:13:18,800 --> 00:13:20,399
well we obtained the zero of the two

383
00:13:20,399 --> 00:13:21,360
outputs

384
00:13:21,360 --> 00:13:23,760
so the the the

385
00:13:23,760 --> 00:13:25,680
the part that depends on the iv simply

386
00:13:25,680 --> 00:13:26,800
source out

387
00:13:26,800 --> 00:13:28,959
and we obtain one bit of encryption of

388
00:13:28,959 --> 00:13:32,079
zero plus encryption of one

389
00:13:32,079 --> 00:13:34,000
and we do that for all the bits so we

390
00:13:34,000 --> 00:13:36,639
can reconstruct the value

391
00:13:36,639 --> 00:13:39,120
and once we have this complete value

392
00:13:39,120 --> 00:13:39,920
here

393
00:13:39,920 --> 00:13:42,720
we can simply switch a zero block

394
00:13:42,720 --> 00:13:45,440
in the first in the first ad block

395
00:13:45,440 --> 00:13:47,279
for a one block which means we can

396
00:13:47,279 --> 00:13:48,800
create the tag of anything that starts

397
00:13:48,800 --> 00:13:50,000
with a zero

398
00:13:50,000 --> 00:13:51,519
and force the tag of anything that

399
00:13:51,519 --> 00:13:53,440
starts with a one

400
00:13:53,440 --> 00:13:55,760
what happens here is that xoring with an

401
00:13:55,760 --> 00:13:57,199
iv dependent value

402
00:13:57,199 --> 00:13:59,680
was a sufficient protection classically

403
00:13:59,680 --> 00:14:01,760
but it's not a sufficient protection for

404
00:14:01,760 --> 00:14:04,800
a quantum adversary and this is what

405
00:14:04,800 --> 00:14:06,800
deutsche's algorithm allows to bypass

406
00:14:06,800 --> 00:14:09,120
completely

407
00:14:09,120 --> 00:14:11,839
okay so this is the first attack

408
00:14:11,839 --> 00:14:13,199
still it's not the complete

409
00:14:13,199 --> 00:14:16,240
linearization attack

410
00:14:17,360 --> 00:14:19,519
let's try to make life even more

411
00:14:19,519 --> 00:14:21,920
difficult for our quantum adversary

412
00:14:21,920 --> 00:14:23,920
and instead of just soaring with an iv

413
00:14:23,920 --> 00:14:26,160
dependent value we're going to post

414
00:14:26,160 --> 00:14:28,680
compute with an iv independent

415
00:14:28,680 --> 00:14:31,440
function so now we have

416
00:14:31,440 --> 00:14:34,160
independent tweakable log cipher that

417
00:14:34,160 --> 00:14:36,959
just process our message blocks

418
00:14:36,959 --> 00:14:38,959
we saw everything and then we post

419
00:14:38,959 --> 00:14:41,600
process with a function

420
00:14:41,600 --> 00:14:45,040
and there on this construction

421
00:14:45,040 --> 00:14:46,399
which actually

422
00:14:46,399 --> 00:14:48,320
abstracts out many classically secured

423
00:14:48,320 --> 00:14:50,560
macs many parallel mags such as like mac

424
00:14:50,560 --> 00:14:51,680
for example

425
00:14:51,680 --> 00:14:53,120
so on this construction simon's

426
00:14:53,120 --> 00:14:57,839
algorithm can be used to make factories

427
00:14:57,839 --> 00:15:00,800
it's going to be used in a different way

428
00:15:00,800 --> 00:15:02,399
so we're going to start a bit lacking

429
00:15:02,399 --> 00:15:04,720
the attack with dutch's algorithm

430
00:15:04,720 --> 00:15:07,199
and we're going to take two values for

431
00:15:07,199 --> 00:15:08,800
each block

432
00:15:08,800 --> 00:15:10,720
so either 0 or 1.

433
00:15:10,720 --> 00:15:12,639
so basically we replace instead of

434
00:15:12,639 --> 00:15:15,839
calling the mac with any messages

435
00:15:15,839 --> 00:15:18,240
we're going to restrict the inputs

436
00:15:18,240 --> 00:15:20,880
to a single bit blocks

437
00:15:20,880 --> 00:15:23,839
so this single bit input is here b1 to

438
00:15:23,839 --> 00:15:25,360
ba

439
00:15:25,360 --> 00:15:27,839
and so we will consider this restricted

440
00:15:27,839 --> 00:15:29,519
mac

441
00:15:29,519 --> 00:15:32,639
as a function of an lb input

442
00:15:32,639 --> 00:15:36,160
and our n-bit input here is x

443
00:15:36,160 --> 00:15:38,639
and so this is a function

444
00:15:38,639 --> 00:15:41,759
that composes the post-processing and

445
00:15:41,759 --> 00:15:44,399
the sum of the internal sum

446
00:15:44,399 --> 00:15:45,519
and now let's have a look at the

447
00:15:45,519 --> 00:15:47,279
internal sound

448
00:15:47,279 --> 00:15:49,199
we're going to remark that this

449
00:15:49,199 --> 00:15:51,839
internal function that in h here is a

450
00:15:51,839 --> 00:15:56,000
defined function of the input x

451
00:15:56,000 --> 00:15:58,079
the reason for that is

452
00:15:58,079 --> 00:16:00,480
you can see that if i if we flip one bit

453
00:16:00,480 --> 00:16:02,320
of the input x

454
00:16:02,320 --> 00:16:04,959
then we end up absorbing just storing an

455
00:16:04,959 --> 00:16:09,440
n bit value to the output of h

456
00:16:09,440 --> 00:16:10,720
because we're just

457
00:16:10,720 --> 00:16:13,360
swapping uh one of the for example we're

458
00:16:13,360 --> 00:16:16,480
swapping a zero block for a one block

459
00:16:16,480 --> 00:16:18,560
so we just have to show an input

460
00:16:18,560 --> 00:16:21,199
so algebraically you can write this down

461
00:16:21,199 --> 00:16:24,480
as as this h of x is simply

462
00:16:24,480 --> 00:16:26,720
uh if you use a squadron vectors it's

463
00:16:26,720 --> 00:16:29,600
simply like a magnetic binary matrix

464
00:16:29,600 --> 00:16:30,959
times

465
00:16:30,959 --> 00:16:33,440
our l bit input

466
00:16:33,440 --> 00:16:35,519
plus a colon vector

467
00:16:35,519 --> 00:16:37,440
so this is undefined function of the

468
00:16:37,440 --> 00:16:40,480
8-bit input x

469
00:16:40,720 --> 00:16:43,120
but a fine function means that

470
00:16:43,120 --> 00:16:45,120
if there are too many blocks

471
00:16:45,120 --> 00:16:47,120
because we have we have the choice of

472
00:16:47,120 --> 00:16:49,519
the number of blocks that we query

473
00:16:49,519 --> 00:16:52,639
so if let's say there are more than n or

474
00:16:52,639 --> 00:16:55,279
more than n plus one block

475
00:16:55,279 --> 00:16:58,240
then we can expect that this matrix ml

476
00:16:58,240 --> 00:17:01,199
is going to have a non-trivial kernel

477
00:17:01,199 --> 00:17:03,120
and they are going to be

478
00:17:03,120 --> 00:17:06,160
l bit strings such that

479
00:17:06,160 --> 00:17:09,439
for each x x plus alpha

480
00:17:09,439 --> 00:17:12,240
has the same output

481
00:17:12,240 --> 00:17:15,760
by this function h as x

482
00:17:15,760 --> 00:17:17,199
right so it's simply

483
00:17:17,199 --> 00:17:19,439
this this alpha here is simply going to

484
00:17:19,439 --> 00:17:22,720
be a choice of uh a choice of of input

485
00:17:22,720 --> 00:17:23,760
bits

486
00:17:23,760 --> 00:17:25,439
such that if you flip all these input

487
00:17:25,439 --> 00:17:27,119
bits

488
00:17:27,119 --> 00:17:30,240
then you reobtain the same value

489
00:17:30,240 --> 00:17:32,320
in the uh

490
00:17:32,320 --> 00:17:34,480
just before post processing so in in the

491
00:17:34,480 --> 00:17:37,039
uh in this

492
00:17:39,120 --> 00:17:41,760
anyway there is a period here uh because

493
00:17:41,760 --> 00:17:45,039
this age was undefined function and so

494
00:17:45,039 --> 00:17:47,280
even when you post process by the

495
00:17:47,280 --> 00:17:48,720
function f

496
00:17:48,720 --> 00:17:51,440
you still have a periodic function

497
00:17:51,440 --> 00:17:52,320
and

498
00:17:52,320 --> 00:17:53,760
we can recover this period using

499
00:17:53,760 --> 00:17:55,280
segments algorithm

500
00:17:55,280 --> 00:17:56,559
the only change

501
00:17:56,559 --> 00:17:58,160
is that the data complexity has

502
00:17:58,160 --> 00:17:59,679
increased because now each of our

503
00:17:59,679 --> 00:18:01,520
queries contains a linear number of

504
00:18:01,520 --> 00:18:02,400
blocks

505
00:18:02,400 --> 00:18:04,080
so instead of making

506
00:18:04,080 --> 00:18:06,000
instead of having a data complexity of

507
00:18:06,000 --> 00:18:07,360
the order of n

508
00:18:07,360 --> 00:18:09,919
we have order of n squared

509
00:18:09,919 --> 00:18:11,760
but once we have obtained this period

510
00:18:11,760 --> 00:18:12,720
alpha

511
00:18:12,720 --> 00:18:14,720
then we can

512
00:18:14,720 --> 00:18:17,200
as before we can make queries

513
00:18:17,200 --> 00:18:19,200
and produce two valley tags for each

514
00:18:19,200 --> 00:18:23,039
query we make so this is again a break

515
00:18:23,039 --> 00:18:26,400
of the plus one affordability

516
00:18:27,440 --> 00:18:29,360
there is even more uh with this

517
00:18:29,360 --> 00:18:30,559
technique

518
00:18:30,559 --> 00:18:32,799
so um actually

519
00:18:32,799 --> 00:18:36,080
when we can attack uh

520
00:18:36,080 --> 00:18:38,320
max of of the forms that are presented

521
00:18:38,320 --> 00:18:40,320
we can also attack beyond thus the bound

522
00:18:40,320 --> 00:18:41,520
variance

523
00:18:41,520 --> 00:18:44,240
so billion burst debt secure max

524
00:18:44,240 --> 00:18:46,480
were proposed to offer more

525
00:18:46,480 --> 00:18:48,720
security against forgery attacks because

526
00:18:48,720 --> 00:18:50,559
usually

527
00:18:50,559 --> 00:18:52,559
the the macs such as lightmag they offer

528
00:18:52,559 --> 00:18:54,320
any over two bits of security against

529
00:18:54,320 --> 00:18:56,640
future attacks and we can do better than

530
00:18:56,640 --> 00:18:57,679
that

531
00:18:57,679 --> 00:19:01,360
a very uh classical approach is to is

532
00:19:01,360 --> 00:19:03,280
double hash synthetic approach

533
00:19:03,280 --> 00:19:04,960
where you process your message block

534
00:19:04,960 --> 00:19:08,080
independently in two pipes of size n

535
00:19:08,080 --> 00:19:09,600
and then the results are absorbed in the

536
00:19:09,600 --> 00:19:11,039
end

537
00:19:11,039 --> 00:19:13,440
now it's possible to apply i would say

538
00:19:13,440 --> 00:19:17,360
standard simon based attacks on on this

539
00:19:17,360 --> 00:19:18,799
on these constructions

540
00:19:18,799 --> 00:19:21,039
but the problem is you're able to if

541
00:19:21,039 --> 00:19:23,520
you're able to embed a period

542
00:19:23,520 --> 00:19:25,280
on one of the pipes then you don't

543
00:19:25,280 --> 00:19:27,440
control the other one anymore basically

544
00:19:27,440 --> 00:19:30,320
so your complexity is going to be

545
00:19:30,320 --> 00:19:32,960
time of applying salmon's algorithm

546
00:19:32,960 --> 00:19:35,520
multiplied by doing some kind of grover

547
00:19:35,520 --> 00:19:36,559
search

548
00:19:36,559 --> 00:19:40,480
on the second on the second pipe and

549
00:19:40,480 --> 00:19:42,160
it's an n-bit value so it's going to be

550
00:19:42,160 --> 00:19:45,600
of the order to the n over two basically

551
00:19:45,600 --> 00:19:47,679
in our case

552
00:19:47,679 --> 00:19:49,039
in this context we can still have a

553
00:19:49,039 --> 00:19:52,480
polynomial time attack so let's take an

554
00:19:52,480 --> 00:19:55,760
example and that would be like mac plus

555
00:19:55,760 --> 00:19:56,559
here

556
00:19:56,559 --> 00:19:59,120
your process all the message blocks

557
00:19:59,120 --> 00:20:00,400
and then

558
00:20:00,400 --> 00:20:02,159
in one branch

559
00:20:02,159 --> 00:20:04,799
you just saw them as before and then the

560
00:20:04,799 --> 00:20:06,480
other one you compute a different linear

561
00:20:06,480 --> 00:20:07,679
function

562
00:20:07,679 --> 00:20:09,360
because there are multiplications by two

563
00:20:09,360 --> 00:20:10,799
all the time

564
00:20:10,799 --> 00:20:12,320
and in the end your post process and you

565
00:20:12,320 --> 00:20:15,280
sort to obtain the tag

566
00:20:16,640 --> 00:20:19,520
if you if we abstract this a bit

567
00:20:19,520 --> 00:20:21,440
we have this

568
00:20:21,440 --> 00:20:23,840
so we we compute independently all the

569
00:20:23,840 --> 00:20:24,960
all the

570
00:20:24,960 --> 00:20:27,520
blocks and then we sum them and then we

571
00:20:27,520 --> 00:20:30,080
have another linear function

572
00:20:30,080 --> 00:20:31,840
but we can apply the same reasoning as

573
00:20:31,840 --> 00:20:33,520
before

574
00:20:33,520 --> 00:20:35,840
except that now when we restrict our

575
00:20:35,840 --> 00:20:37,120
inputs to

576
00:20:37,120 --> 00:20:39,200
single bits

577
00:20:39,200 --> 00:20:42,720
we will have first a fine function of

578
00:20:42,720 --> 00:20:44,480
our l bit input

579
00:20:44,480 --> 00:20:46,320
and we have a second defined function of

580
00:20:46,320 --> 00:20:48,480
our n bit input which is different

581
00:20:48,480 --> 00:20:50,400
because it's a different linear

582
00:20:50,400 --> 00:20:52,080
for different linear mapping of the

583
00:20:52,080 --> 00:20:54,399
blocks

584
00:20:54,880 --> 00:20:56,240
but although there are two different

585
00:20:56,240 --> 00:20:58,559
defined functions now

586
00:20:58,559 --> 00:21:00,799
we are ensured that

587
00:21:00,799 --> 00:21:02,480
as as soon as our

588
00:21:02,480 --> 00:21:05,919
enough blocks let's say two n blocks

589
00:21:05,919 --> 00:21:08,720
there will be a trivial a non-trivial

590
00:21:08,720 --> 00:21:11,600
vector which is going to be a period of

591
00:21:11,600 --> 00:21:12,480
this

592
00:21:12,480 --> 00:21:14,080
defined function and of this defined

593
00:21:14,080 --> 00:21:16,640
function

594
00:21:16,640 --> 00:21:18,159
and so there is going to be there are

595
00:21:18,159 --> 00:21:20,159
going to be periods for the for the full

596
00:21:20,159 --> 00:21:22,320
mac

597
00:21:22,320 --> 00:21:24,720
and the attack applies again

598
00:21:24,720 --> 00:21:26,240
the only difference is that we just had

599
00:21:26,240 --> 00:21:27,919
to increase a little

600
00:21:27,919 --> 00:21:29,520
the data complexity but just by a

601
00:21:29,520 --> 00:21:33,200
constant by a constant factor

602
00:21:34,000 --> 00:21:35,440
so

603
00:21:35,440 --> 00:21:38,880
this is going to apply to many examples

604
00:21:38,880 --> 00:21:42,240
and you can see it applies as soon as

605
00:21:42,240 --> 00:21:43,760
we process the input blocks

606
00:21:43,760 --> 00:21:46,320
independently and then we compute some

607
00:21:46,320 --> 00:21:48,400
linear functions of these blocks

608
00:21:48,400 --> 00:21:50,080
and then again we compute the tag from

609
00:21:50,080 --> 00:21:52,000
the outputs of these functions

610
00:21:52,000 --> 00:21:54,400
this is uh this is

611
00:21:54,400 --> 00:21:56,840
all what we need to to be able to apply

612
00:21:56,840 --> 00:21:59,760
this which means that conversely if you

613
00:21:59,760 --> 00:22:01,919
want plus one affordability then you

614
00:22:01,919 --> 00:22:03,919
need some sequentiality

615
00:22:03,919 --> 00:22:05,600
and we know that actually n mac for

616
00:22:05,600 --> 00:22:06,640
example

617
00:22:06,640 --> 00:22:08,799
is quantum seeker

618
00:22:08,799 --> 00:22:09,919
you need

619
00:22:09,919 --> 00:22:12,320
you can also you can also use

620
00:22:12,320 --> 00:22:14,720
constructions that are iv based

621
00:22:14,720 --> 00:22:16,080
and that

622
00:22:16,080 --> 00:22:18,000
use the iv and the processing of all the

623
00:22:18,000 --> 00:22:19,440
blocks

624
00:22:19,440 --> 00:22:22,240
not only in the in the final function

625
00:22:22,240 --> 00:22:24,480
and we also know that this works

626
00:22:24,480 --> 00:22:27,120
now potentially uh but we don't know

627
00:22:27,120 --> 00:22:29,520
about that yet um there there could be

628
00:22:29,520 --> 00:22:32,320
some uh some security if instead of

629
00:22:32,320 --> 00:22:33,679
using xor

630
00:22:33,679 --> 00:22:36,159
to uh to sum all these blocks you use

631
00:22:36,159 --> 00:22:38,159
for example the modular additions

632
00:22:38,159 --> 00:22:40,000
it's just that with the modular addition

633
00:22:40,000 --> 00:22:42,559
the attack doesn't work anymore

634
00:22:42,559 --> 00:22:44,480
but we don't know what the security

635
00:22:44,480 --> 00:22:47,280
would be in the end

636
00:22:48,080 --> 00:22:49,280
so

637
00:22:49,280 --> 00:22:51,760
to conclude there are different ways in

638
00:22:51,760 --> 00:22:53,200
which you can see

639
00:22:53,200 --> 00:22:55,120
this attack in this presentation i

640
00:22:55,120 --> 00:22:56,559
adopted more of the quantum

641
00:22:56,559 --> 00:22:58,559
cryptanalysis perspective

642
00:22:58,559 --> 00:23:00,159
you have a procedure that is based on

643
00:23:00,159 --> 00:23:03,039
simon's agreement that is different from

644
00:23:03,039 --> 00:23:05,039
the previous approaches and that allows

645
00:23:05,039 --> 00:23:06,640
to break

646
00:23:06,640 --> 00:23:07,919
many max

647
00:23:07,919 --> 00:23:09,679
the unforgetability of any max and

648
00:23:09,679 --> 00:23:10,799
practically

649
00:23:10,799 --> 00:23:13,280
all the deterministic and paralyzable

650
00:23:13,280 --> 00:23:15,440
mac constructions that we that we had so

651
00:23:15,440 --> 00:23:17,440
far

652
00:23:17,440 --> 00:23:19,200
you can also view this from a probable

653
00:23:19,200 --> 00:23:20,720
security perspective because the fact

654
00:23:20,720 --> 00:23:22,799
that we have broken this max means that

655
00:23:22,799 --> 00:23:25,679
they we can't prove their security

656
00:23:25,679 --> 00:23:27,600
uh in the code of setting

657
00:23:27,600 --> 00:23:29,200
and now the question remains whether we

658
00:23:29,200 --> 00:23:30,480
can design

659
00:23:30,480 --> 00:23:33,200
actual efficient biasable

660
00:23:33,200 --> 00:23:35,280
uh quantum physical functions for

661
00:23:35,280 --> 00:23:39,440
example and quantum secure max

662
00:23:40,159 --> 00:23:41,360
also from a concrete security

663
00:23:41,360 --> 00:23:43,360
perspective while

664
00:23:43,360 --> 00:23:44,880
we have attacks in the superposition

665
00:23:44,880 --> 00:23:46,559
setting

666
00:23:46,559 --> 00:23:48,320
that will be interesting to know whether

667
00:23:48,320 --> 00:23:49,120
this

668
00:23:49,120 --> 00:23:50,960
has consequences when the queries are

669
00:23:50,960 --> 00:23:54,159
only classical of course

670
00:23:54,559 --> 00:23:55,600
so

671
00:23:55,600 --> 00:23:57,279
these these are these are interesting

672
00:23:57,279 --> 00:23:58,720
open questions

673
00:23:58,720 --> 00:24:00,799
and

674
00:24:00,799 --> 00:24:02,799
my presentation is here thank you for

675
00:24:02,799 --> 00:24:05,799
attention

