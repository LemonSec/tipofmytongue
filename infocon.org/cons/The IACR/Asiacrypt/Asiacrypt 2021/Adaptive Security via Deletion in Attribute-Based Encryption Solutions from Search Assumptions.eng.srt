1
00:00:00,640 --> 00:00:01,760
hi

2
00:00:01,760 --> 00:00:03,280
i'm going to talk about adaptive

3
00:00:03,280 --> 00:00:05,520
security by deletioning attribute-based

4
00:00:05,520 --> 00:00:07,279
encryption

5
00:00:07,279 --> 00:00:09,519
this is joint work with richard goyal

6
00:00:09,519 --> 00:00:12,400
and brentwaters

7
00:00:15,440 --> 00:00:17,680
so consider we want to do public

8
00:00:17,680 --> 00:00:20,080
encryption in a large organization

9
00:00:20,080 --> 00:00:22,640
where everyone can send a secret message

10
00:00:22,640 --> 00:00:24,480
to another person by encrypting the

11
00:00:24,480 --> 00:00:27,439
message with that with respect to that

12
00:00:27,439 --> 00:00:29,920
person's public key a naive way to

13
00:00:29,920 --> 00:00:31,760
realize this is just let everyone

14
00:00:31,760 --> 00:00:35,840
publish their public key in a directory

15
00:00:37,120 --> 00:00:39,600
however this approach may be very

16
00:00:39,600 --> 00:00:41,520
inefficient when we want to send a

17
00:00:41,520 --> 00:00:43,600
message to a group of people we need to

18
00:00:43,600 --> 00:00:46,000
encrypt and send a message to each of

19
00:00:46,000 --> 00:00:46,960
them

20
00:00:46,960 --> 00:00:49,120
suppose this group of people actually

21
00:00:49,120 --> 00:00:51,680
have some common features for example

22
00:00:51,680 --> 00:00:53,600
they all work in the same research group

23
00:00:53,600 --> 00:00:55,920
or they are all under or above some

24
00:00:55,920 --> 00:00:58,079
certain age we can probably just send a

25
00:00:58,079 --> 00:00:59,359
message

26
00:00:59,359 --> 00:01:01,440
a encrypted message to

27
00:01:01,440 --> 00:01:04,400
the people with all this feature

28
00:01:04,400 --> 00:01:06,720
that can decrypt but others without this

29
00:01:06,720 --> 00:01:09,439
feature cannot

30
00:01:09,439 --> 00:01:11,680
such a notion was formulated as

31
00:01:11,680 --> 00:01:14,080
attribute-based encryption in these two

32
00:01:14,080 --> 00:01:17,680
papers the high waters 2005 and

33
00:01:17,680 --> 00:01:22,320
goyu pandey sahib waters 2006.

34
00:01:22,720 --> 00:01:26,000
in an attribute-based encryption scheme

35
00:01:26,000 --> 00:01:28,640
every user has an attribute

36
00:01:28,640 --> 00:01:30,880
as an nb binary string

37
00:01:30,880 --> 00:01:33,280
and we have policies which can be seen

38
00:01:33,280 --> 00:01:35,680
as boolean functions that take in n-bit

39
00:01:35,680 --> 00:01:37,840
input

40
00:01:37,840 --> 00:01:40,240
these boolean functions evaluate on the

41
00:01:40,240 --> 00:01:42,479
attribute and output

42
00:01:42,479 --> 00:01:45,200
zero for reject and one for accept means

43
00:01:45,200 --> 00:01:47,360
the attributes satisfy this specific

44
00:01:47,360 --> 00:01:50,960
process policy we want to deploy

45
00:01:50,960 --> 00:01:52,399
to issue keys

46
00:01:52,399 --> 00:01:54,720
we run setup to generate the public key

47
00:01:54,720 --> 00:01:56,960
and the master secret key

48
00:01:56,960 --> 00:01:58,960
using the master secret key we can

49
00:01:58,960 --> 00:02:01,119
derive secret keys associated with

50
00:02:01,119 --> 00:02:04,079
different attributes

51
00:02:05,520 --> 00:02:08,560
and to encrypt we use the public key

52
00:02:08,560 --> 00:02:10,000
and

53
00:02:10,000 --> 00:02:12,000
we incorporate respect to a certain

54
00:02:12,000 --> 00:02:15,280
policy and the message we want to we

55
00:02:15,280 --> 00:02:17,920
want to put into the ciphertext

56
00:02:17,920 --> 00:02:19,760
the policy can be like decrypters must

57
00:02:19,760 --> 00:02:22,160
be or graduate students and it's

58
00:02:22,160 --> 00:02:24,000
expressed as a boolean function of

59
00:02:24,000 --> 00:02:26,720
attributes as we mentioned before

60
00:02:26,720 --> 00:02:29,599
and only users with the secret key

61
00:02:29,599 --> 00:02:32,000
associated with attributes where this

62
00:02:32,000 --> 00:02:34,879
policy would evaluate them on them to be

63
00:02:34,879 --> 00:02:37,200
one can decrypt the ciphertext

64
00:02:37,200 --> 00:02:39,920
and the rest cannot

65
00:02:39,920 --> 00:02:42,400
and this formulation above is often

66
00:02:42,400 --> 00:02:44,720
called ciphertext policy attribute-based

67
00:02:44,720 --> 00:02:45,920
encryption

68
00:02:45,920 --> 00:02:48,560
since the policy the functionality is

69
00:02:48,560 --> 00:02:52,319
embedded into the ciphertext

70
00:02:52,560 --> 00:02:55,200
there is also a dual formulation called

71
00:02:55,200 --> 00:02:57,440
key policy attribute-based encryption

72
00:02:57,440 --> 00:02:59,599
that invests the policy into the secret

73
00:02:59,599 --> 00:03:01,280
key

74
00:03:01,280 --> 00:03:03,440
and the attribute into the ciphertext

75
00:03:03,440 --> 00:03:05,200
and both of these have constructions

76
00:03:05,200 --> 00:03:08,000
that have a lot of applications

77
00:03:08,000 --> 00:03:10,239
and for both of these formulations we

78
00:03:10,239 --> 00:03:12,560
also have two levels of simatic security

79
00:03:12,560 --> 00:03:14,800
requirement

80
00:03:14,800 --> 00:03:17,040
called adaptive security and selective

81
00:03:17,040 --> 00:03:19,840
security

82
00:03:20,640 --> 00:03:23,519
so adaptive security is actually what we

83
00:03:23,519 --> 00:03:25,920
usually want in practice and it's also

84
00:03:25,920 --> 00:03:28,080
called full security

85
00:03:28,080 --> 00:03:30,799
the challenger generates uh in the

86
00:03:30,799 --> 00:03:32,560
security game the challenger generates a

87
00:03:32,560 --> 00:03:33,760
public key

88
00:03:33,760 --> 00:03:35,840
and the master secret key it gives

89
00:03:35,840 --> 00:03:38,000
public key to the adversary the

90
00:03:38,000 --> 00:03:40,319
adversary can then make queries

91
00:03:40,319 --> 00:03:42,319
uh for secret keys corresponding to some

92
00:03:42,319 --> 00:03:44,080
attributes he chooses

93
00:03:44,080 --> 00:03:45,040
and for

94
00:03:45,040 --> 00:03:47,120
for polynomial many times

95
00:03:47,120 --> 00:03:48,720
this procedure can be seen as the

96
00:03:48,720 --> 00:03:50,480
adversary

97
00:03:50,480 --> 00:03:53,760
uh corrupting a bunch of user keys

98
00:03:53,760 --> 00:03:56,000
and this uh this query stage can happen

99
00:03:56,000 --> 00:03:58,879
again after the challenge phase

100
00:03:58,879 --> 00:04:00,959
uh in the challenge phase he sends in a

101
00:04:00,959 --> 00:04:03,519
policy and a two messages of his own

102
00:04:03,519 --> 00:04:06,159
choice but this policy must be one that

103
00:04:06,159 --> 00:04:07,920
none of the other attributes he has

104
00:04:07,920 --> 00:04:10,720
queried before or he will acquiring that

105
00:04:10,720 --> 00:04:13,519
the query phase after challenge phrase

106
00:04:13,519 --> 00:04:14,959
like none of these attributes he will

107
00:04:14,959 --> 00:04:18,160
query will satisfy this policy

108
00:04:18,160 --> 00:04:20,238
and the decrypter that encrypts one of

109
00:04:20,238 --> 00:04:22,479
these messages randomly with respect to

110
00:04:22,479 --> 00:04:24,800
this policy the adversary gets the

111
00:04:24,800 --> 00:04:27,199
cipher text and he's not supposed to get

112
00:04:27,199 --> 00:04:29,759
guess which message is encrypted

113
00:04:29,759 --> 00:04:32,400
this definition even though natural is

114
00:04:32,400 --> 00:04:36,159
in fact not easy to realize

115
00:04:36,880 --> 00:04:38,639
therefore

116
00:04:38,639 --> 00:04:41,440
people actually turn to a weaker

117
00:04:41,440 --> 00:04:43,520
security notion called selective

118
00:04:43,520 --> 00:04:45,840
security

119
00:04:45,840 --> 00:04:48,479
adversary in the selected security game

120
00:04:48,479 --> 00:04:50,400
the adversity has to first send in the

121
00:04:50,400 --> 00:04:53,040
policy wants to attack on before it sees

122
00:04:53,040 --> 00:04:54,960
the public key

123
00:04:54,960 --> 00:04:57,680
and this uh in the full security happens

124
00:04:57,680 --> 00:04:59,199
in the challenge phase where the

125
00:04:59,199 --> 00:05:01,280
anniversary can see the public key can

126
00:05:01,280 --> 00:05:03,360
make queries and then he chooses the

127
00:05:03,360 --> 00:05:06,479
messages and the the policy and here

128
00:05:06,479 --> 00:05:09,199
here has has to sending this policy

129
00:05:09,199 --> 00:05:11,520
and before he even sees any public

130
00:05:11,520 --> 00:05:13,840
parameters uh everything else every

131
00:05:13,840 --> 00:05:15,840
other stages stay the same

132
00:05:15,840 --> 00:05:17,919
and many of early works would

133
00:05:17,919 --> 00:05:20,000
would first try to build this selected

134
00:05:20,000 --> 00:05:23,199
security and later works move on to

135
00:05:23,199 --> 00:05:26,720
range adaptive security

136
00:05:30,240 --> 00:05:32,560
next we can look at the line of works

137
00:05:32,560 --> 00:05:36,400
that try to build a secure abe

138
00:05:36,639 --> 00:05:38,320
we look at both group assumptions and

139
00:05:38,320 --> 00:05:41,280
lattice and both selective and adaptive

140
00:05:41,280 --> 00:05:42,400
security

141
00:05:42,400 --> 00:05:45,039
so as we mentioned uh early works first

142
00:05:45,039 --> 00:05:47,440
of all selected security uh in terms of

143
00:05:47,440 --> 00:05:48,560
group

144
00:05:48,560 --> 00:05:51,120
constructions these already works uh

145
00:05:51,120 --> 00:05:53,360
built selective security from bilinear

146
00:05:53,360 --> 00:05:55,680
defeat helmet

147
00:05:55,680 --> 00:05:58,160
and later uh there was this well-known

148
00:05:58,160 --> 00:05:59,919
new system technique introduced by

149
00:05:59,919 --> 00:06:01,120
waters

150
00:06:01,120 --> 00:06:03,199
and the adaptive security was realizing

151
00:06:03,199 --> 00:06:07,039
these later works for policies in nc1

152
00:06:07,039 --> 00:06:08,880
and they're based on different types of

153
00:06:08,880 --> 00:06:11,360
decision or group assumptions and and

154
00:06:11,360 --> 00:06:14,560
however uh the reliance on decisional

155
00:06:14,560 --> 00:06:16,720
assumptions seems to be inherent uh when

156
00:06:16,720 --> 00:06:19,039
using this technique whereas in these

157
00:06:19,039 --> 00:06:21,039
early works uh that only have secure

158
00:06:21,039 --> 00:06:22,639
selected security

159
00:06:22,639 --> 00:06:25,120
uh we can actually build from search

160
00:06:25,120 --> 00:06:27,280
assumptions

161
00:06:27,280 --> 00:06:29,199
moving on to the lattice side uh these

162
00:06:29,199 --> 00:06:30,960
works realize selective security for

163
00:06:30,960 --> 00:06:34,000
latitude from lattice for circuits uh

164
00:06:34,000 --> 00:06:36,800
however it was not until re uh recent uh

165
00:06:36,800 --> 00:06:38,720
two years that we finally know something

166
00:06:38,720 --> 00:06:41,120
of adaptive security from lattice and

167
00:06:41,120 --> 00:06:42,720
just to mention here this buoyant

168
00:06:42,720 --> 00:06:45,280
certain scheme was actually uh actually

169
00:06:45,280 --> 00:06:46,880
head attack uh

170
00:06:46,880 --> 00:06:49,520
in last year but we would uh we would

171
00:06:49,520 --> 00:06:50,880
leave it here because it will be

172
00:06:50,880 --> 00:06:52,080
actually useful

173
00:06:52,080 --> 00:06:54,240
uh when we talk about looking forward

174
00:06:54,240 --> 00:06:57,680
when we talk about our construction

175
00:06:57,680 --> 00:07:01,039
and uh so the reason brexu we mentioned

176
00:07:01,039 --> 00:07:04,560
uh was suffering in 2000 2019 realized

177
00:07:04,560 --> 00:07:07,360
the adaptive secure abe from lattice

178
00:07:07,360 --> 00:07:09,280
even though the functionality uh

179
00:07:09,280 --> 00:07:11,120
realizable is only a subset

180
00:07:11,120 --> 00:07:14,080
functionality it is a a step towards

181
00:07:14,080 --> 00:07:16,639
adaptive security and it's a different

182
00:07:16,639 --> 00:07:20,400
approach from all past approaches

183
00:07:21,840 --> 00:07:24,400
we therefore ask the question can we

184
00:07:24,400 --> 00:07:27,199
expand this approach in some way to make

185
00:07:27,199 --> 00:07:29,280
that security hold for more general

186
00:07:29,280 --> 00:07:31,840
cases

187
00:07:32,960 --> 00:07:34,560
okay in our work

188
00:07:34,560 --> 00:07:36,800
we simplified and expanded the framework

189
00:07:36,800 --> 00:07:37,599
of

190
00:07:37,599 --> 00:07:40,479
realizing adaptive security following

191
00:07:40,479 --> 00:07:41,680
sudbury

192
00:07:41,680 --> 00:07:43,440
2019 paper

193
00:07:43,440 --> 00:07:45,280
we show that uh

194
00:07:45,280 --> 00:07:47,520
in a simplified framework we can

195
00:07:47,520 --> 00:07:50,240
instantiate

196
00:07:50,639 --> 00:07:53,520
the adaptive secure a b for subset

197
00:07:53,520 --> 00:07:56,400
functionality from both search

198
00:07:56,400 --> 00:07:58,960
by linear assumptions and lattice

199
00:07:58,960 --> 00:08:01,360
and we can make the whole framework more

200
00:08:01,360 --> 00:08:03,759
clear and understandable

201
00:08:03,759 --> 00:08:05,919
what's our high-level approach

202
00:08:05,919 --> 00:08:08,160
a hell of a project is just combining uh

203
00:08:08,160 --> 00:08:09,759
two building blocks

204
00:08:09,759 --> 00:08:11,280
uh

205
00:08:11,280 --> 00:08:13,120
in an interesting way the first building

206
00:08:13,120 --> 00:08:15,599
block is selected secure key policy

207
00:08:15,599 --> 00:08:17,759
attribute based encryption with a

208
00:08:17,759 --> 00:08:21,120
property that we call deletable

209
00:08:21,120 --> 00:08:23,440
and we just require this uh underline

210
00:08:23,440 --> 00:08:24,879
key policy scheme

211
00:08:24,879 --> 00:08:26,879
scheme to be selective secure

212
00:08:26,879 --> 00:08:30,160
but it needs to be for nc1 circuits

213
00:08:30,160 --> 00:08:30,960
um

214
00:08:30,960 --> 00:08:33,360
which we already have from some previous

215
00:08:33,360 --> 00:08:35,200
papers we mentioned

216
00:08:35,200 --> 00:08:36,320
um

217
00:08:36,320 --> 00:08:38,399
and we will talk about what deleted for

218
00:08:38,399 --> 00:08:40,958
property means and how we can realize

219
00:08:40,958 --> 00:08:43,760
that from previous work

220
00:08:43,760 --> 00:08:45,360
the second building block is a

221
00:08:45,360 --> 00:08:47,839
constraint prf with deletion conforming

222
00:08:47,839 --> 00:08:49,519
property we'll also talk about that

223
00:08:49,519 --> 00:08:52,160
later and together with these two we can

224
00:08:52,160 --> 00:08:54,240
realize adaptive secure ciphertext

225
00:08:54,240 --> 00:08:57,680
policy abe

226
00:08:57,680 --> 00:09:00,720
okay now let's go to our first building

227
00:09:00,720 --> 00:09:01,760
block

228
00:09:01,760 --> 00:09:04,640
deletable abe will demonstrate

229
00:09:04,640 --> 00:09:07,279
deleteable property as follows

230
00:09:07,279 --> 00:09:09,839
given a ciphertext which is

231
00:09:09,839 --> 00:09:12,560
uh an encryption of a message m to an

232
00:09:12,560 --> 00:09:15,360
attribute x1 and we can view the

233
00:09:15,360 --> 00:09:17,360
ciphertext actually as

234
00:09:17,360 --> 00:09:20,320
a bunch of blocks a composition of

235
00:09:20,320 --> 00:09:23,760
a few blocks and then we can perform a

236
00:09:23,760 --> 00:09:25,600
algorithm called delete on the

237
00:09:25,600 --> 00:09:26,800
ciphertext

238
00:09:26,800 --> 00:09:28,480
this delete algorithm will take in the

239
00:09:28,480 --> 00:09:31,360
ciphertext and the set of indices

240
00:09:31,360 --> 00:09:32,880
it will delete the blocks in the

241
00:09:32,880 --> 00:09:36,080
ciphertext index by this these indices

242
00:09:36,080 --> 00:09:38,640
in this set for example 2 and 4 here and

243
00:09:38,640 --> 00:09:43,040
we just take away block 2 and 4.

244
00:09:44,800 --> 00:09:47,680
in fact the number of blocks is equal to

245
00:09:47,680 --> 00:09:48,720
the length

246
00:09:48,720 --> 00:09:50,640
of the attribute

247
00:09:50,640 --> 00:09:53,040
and each block is actually just

248
00:09:53,040 --> 00:09:55,360
associated with one bit in the attribute

249
00:09:55,360 --> 00:09:58,080
so we can take a look at this delete

250
00:09:58,080 --> 00:10:00,320
thing the other way around by looking at

251
00:10:00,320 --> 00:10:03,200
the attribute first we can perform this

252
00:10:03,200 --> 00:10:05,200
algorithm called restrict that basically

253
00:10:05,200 --> 00:10:08,240
just remove some beats in the indices

254
00:10:08,240 --> 00:10:09,200
uh in

255
00:10:09,200 --> 00:10:12,720
and indicating this is they set given

256
00:10:12,720 --> 00:10:15,040
and then we we can probably replace

257
00:10:15,040 --> 00:10:17,600
these places with a special symbol like

258
00:10:17,600 --> 00:10:18,480
bot

259
00:10:18,480 --> 00:10:20,240
and then we have this encryption

260
00:10:20,240 --> 00:10:22,800
procedure that can encrypt with respect

261
00:10:22,800 --> 00:10:24,720
to an attribute

262
00:10:24,720 --> 00:10:27,040
that might have some special single bot

263
00:10:27,040 --> 00:10:29,279
and will still give us a valid cipher

264
00:10:29,279 --> 00:10:31,279
text

265
00:10:31,279 --> 00:10:33,839
and

266
00:10:33,920 --> 00:10:36,320
uh after we said we see these two

267
00:10:36,320 --> 00:10:38,320
different approaches of doing deletion

268
00:10:38,320 --> 00:10:40,640
we actually uh we we say that we they

269
00:10:40,640 --> 00:10:42,480
are actually indistinguishable once you

270
00:10:42,480 --> 00:10:44,399
get a cipher text

271
00:10:44,399 --> 00:10:45,279
so

272
00:10:45,279 --> 00:10:47,920
that basically means whether we encrypt

273
00:10:47,920 --> 00:10:51,040
we first get encrypt and then we perform

274
00:10:51,040 --> 00:10:53,839
deletion on the ciphertext by removing a

275
00:10:53,839 --> 00:10:55,279
few blocks or

276
00:10:55,279 --> 00:10:56,720
whether we first

277
00:10:56,720 --> 00:10:58,640
just remove a few bits in the in the

278
00:10:58,640 --> 00:11:01,440
attribute that encrypt this uh

279
00:11:01,440 --> 00:11:04,399
this uh deleted attribute where we can

280
00:11:04,399 --> 00:11:06,959
get another cipher text and these two

281
00:11:06,959 --> 00:11:09,519
cipher text should be indistinguishable

282
00:11:09,519 --> 00:11:10,800
we call such

283
00:11:10,800 --> 00:11:12,880
uh we call an ap scheme with such

284
00:11:12,880 --> 00:11:15,600
property are this delete procedure this

285
00:11:15,600 --> 00:11:17,600
remove uh restrict actually restrict

286
00:11:17,600 --> 00:11:19,200
procedures here

287
00:11:19,200 --> 00:11:20,480
uh and also there is a

288
00:11:20,480 --> 00:11:23,440
distinguishability uh property they such

289
00:11:23,440 --> 00:11:28,120
an abe will call a deletable abe

290
00:11:28,720 --> 00:11:32,480
and now we get to our second um

291
00:11:32,480 --> 00:11:35,040
building block is this constraint prf

292
00:11:35,040 --> 00:11:37,040
let's first look at uh a usual

293
00:11:37,040 --> 00:11:39,440
constraint prf what properties do we

294
00:11:39,440 --> 00:11:40,399
have

295
00:11:40,399 --> 00:11:41,680
so

296
00:11:41,680 --> 00:11:43,839
a constraint pif has constraints to the

297
00:11:43,839 --> 00:11:45,680
randomness property

298
00:11:45,680 --> 00:11:48,399
so given an original key of the prf

299
00:11:48,399 --> 00:11:51,360
which we call the master secret key here

300
00:11:51,360 --> 00:11:53,440
we can constrain the key

301
00:11:53,440 --> 00:11:56,959
with respect to a function f the prf

302
00:11:56,959 --> 00:11:59,519
would evaluate correctly and normally on

303
00:11:59,519 --> 00:12:01,040
the constraint key

304
00:12:01,040 --> 00:12:02,639
when the inputs satisfy this

305
00:12:02,639 --> 00:12:05,279
functionality f that we constrain would

306
00:12:05,279 --> 00:12:06,560
constrain to

307
00:12:06,560 --> 00:12:08,959
however if an anniversary is given a

308
00:12:08,959 --> 00:12:11,279
constraint key is not able to evaluate

309
00:12:11,279 --> 00:12:12,399
the prs

310
00:12:12,399 --> 00:12:14,160
and inputs that do not satisfy the

311
00:12:14,160 --> 00:12:15,200
function

312
00:12:15,200 --> 00:12:16,880
more formally he cannot distinguish

313
00:12:16,880 --> 00:12:19,360
evaluation on these inputs using the

314
00:12:19,360 --> 00:12:21,760
original master secret key

315
00:12:21,760 --> 00:12:24,800
from any uniform random values

316
00:12:24,800 --> 00:12:27,519
and here we only need single key

317
00:12:27,519 --> 00:12:29,040
adaptive secure

318
00:12:29,040 --> 00:12:31,040
uh pseudorandomness

319
00:12:31,040 --> 00:12:32,480
and

320
00:12:32,480 --> 00:12:33,920
another property we need is called

321
00:12:33,920 --> 00:12:36,480
adaptive key simulation

322
00:12:36,480 --> 00:12:38,320
that is we let adversary choose a

323
00:12:38,320 --> 00:12:41,360
function f adaptively adaptively and uh

324
00:12:41,360 --> 00:12:43,680
there's a procedure called keysim to

325
00:12:43,680 --> 00:12:45,519
generate a simulated key for the

326
00:12:45,519 --> 00:12:46,800
function f

327
00:12:46,800 --> 00:12:47,519
and

328
00:12:47,519 --> 00:12:49,279
it would give a simulated key

329
00:12:49,279 --> 00:12:51,360
indistinguishable from the constrail

330
00:12:51,360 --> 00:12:53,200
constraint key

331
00:12:53,200 --> 00:12:55,519
that procedure only needs to know this

332
00:12:55,519 --> 00:12:57,920
procedure key theme only needs to know

333
00:12:57,920 --> 00:12:59,440
function f

334
00:12:59,440 --> 00:13:00,639
and the

335
00:13:00,639 --> 00:13:02,480
security parameters and

336
00:13:02,480 --> 00:13:05,040
and input output size of

337
00:13:05,040 --> 00:13:07,680
of the prf and no need for knowledge of

338
00:13:07,680 --> 00:13:09,920
any secret key information

339
00:13:09,920 --> 00:13:11,360
so therefore this procedure can

340
00:13:11,360 --> 00:13:13,279
basically be done by anyone given the

341
00:13:13,279 --> 00:13:15,360
encryption of f and this will be needed

342
00:13:15,360 --> 00:13:16,959
in our encryption

343
00:13:16,959 --> 00:13:20,160
data only our construction

344
00:13:20,160 --> 00:13:22,639
okay and now we move on to some special

345
00:13:22,639 --> 00:13:24,880
properties we need for our our

346
00:13:24,880 --> 00:13:26,639
construction to conform with our

347
00:13:26,639 --> 00:13:28,959
framework we call deletion conforming

348
00:13:28,959 --> 00:13:30,480
pif

349
00:13:30,480 --> 00:13:32,639
uh so firstly

350
00:13:32,639 --> 00:13:34,639
we can constrain that when we constrain

351
00:13:34,639 --> 00:13:36,720
the master secret key we in fact just

352
00:13:36,720 --> 00:13:38,079
need to remove

353
00:13:38,079 --> 00:13:40,639
some blocks in this key according to a

354
00:13:40,639 --> 00:13:42,720
set of indices so this would probably

355
00:13:42,720 --> 00:13:44,320
remind you of something we just talked

356
00:13:44,320 --> 00:13:45,279
about

357
00:13:45,279 --> 00:13:47,920
the deletion uh uh the restriction on on

358
00:13:47,920 --> 00:13:49,839
the on the attribute that we can just

359
00:13:49,839 --> 00:13:52,959
keep uh that when we give given a set of

360
00:13:52,959 --> 00:13:56,480
indices we just remove some attributes

361
00:13:56,480 --> 00:13:58,800
uh some some beats in in that attribute

362
00:13:58,800 --> 00:14:00,320
and this here will do the same thing to

363
00:14:00,320 --> 00:14:02,639
the mass secret key

364
00:14:02,639 --> 00:14:04,399
but how how do we know how do we know

365
00:14:04,399 --> 00:14:06,639
what indices to delete how how it is

366
00:14:06,639 --> 00:14:08,959
created for f and we actually have

367
00:14:08,959 --> 00:14:10,800
another procedure

368
00:14:10,800 --> 00:14:12,320
that that is

369
00:14:12,320 --> 00:14:15,199
that takes in the description of f and

370
00:14:15,199 --> 00:14:17,680
it would just output a set of indices

371
00:14:17,680 --> 00:14:19,920
that uh that to tell that tell us what

372
00:14:19,920 --> 00:14:22,079
what to delete what indices we should

373
00:14:22,079 --> 00:14:24,079
remove from the master secret key in

374
00:14:24,079 --> 00:14:26,399
order to to realize the constraint

375
00:14:26,399 --> 00:14:29,199
functionality for f

376
00:14:29,199 --> 00:14:31,279
and secondly uh

377
00:14:31,279 --> 00:14:34,000
we need a a scientist special evaluation

378
00:14:34,000 --> 00:14:35,120
procedure

379
00:14:35,120 --> 00:14:37,519
that is we can evaluate the prf on a

380
00:14:37,519 --> 00:14:39,600
heart coded input x

381
00:14:39,600 --> 00:14:42,160
using a special circuit evaluation this

382
00:14:42,160 --> 00:14:43,360
takes in

383
00:14:43,360 --> 00:14:45,760
a circuit hard coded with input x and

384
00:14:45,760 --> 00:14:48,480
the prf secret key as input it can be

385
00:14:48,480 --> 00:14:50,240
constrained or it can be the master

386
00:14:50,240 --> 00:14:52,160
quickie an output

387
00:14:52,160 --> 00:14:54,399
a correct evaluation uh

388
00:14:54,399 --> 00:14:57,279
as if you do just if you do just using a

389
00:14:57,279 --> 00:14:59,600
normal pif evaluation on the same key

390
00:14:59,600 --> 00:15:00,959
and the uh

391
00:15:00,959 --> 00:15:04,319
and that value x

392
00:15:04,399 --> 00:15:06,639
now we can build our adaptive secure

393
00:15:06,639 --> 00:15:09,360
ciphertext policy a b scheme

394
00:15:09,360 --> 00:15:11,519
from these two underlying

395
00:15:11,519 --> 00:15:13,600
building blocks the deletion conforming

396
00:15:13,600 --> 00:15:16,320
constraint prf and deletable key policy

397
00:15:16,320 --> 00:15:17,920
abe

398
00:15:17,920 --> 00:15:19,680
the first way we can start by talking

399
00:15:19,680 --> 00:15:21,680
about the keychain algorithm

400
00:15:21,680 --> 00:15:25,760
of our ciphertext ciphertext policy ede

401
00:15:25,760 --> 00:15:27,920
our kitchen algorithm takes in a master

402
00:15:27,920 --> 00:15:31,279
secret key which is just composed of

403
00:15:31,279 --> 00:15:34,399
prf secret master secret key and the

404
00:15:34,399 --> 00:15:37,040
deletable abs master secret key

405
00:15:37,040 --> 00:15:39,199
and to derive

406
00:15:39,199 --> 00:15:41,680
a key for attribute x we first compute

407
00:15:41,680 --> 00:15:44,880
this prf evaluation on x using the prf

408
00:15:44,880 --> 00:15:47,199
master secret key and we get a value we

409
00:15:47,199 --> 00:15:49,199
call t

410
00:15:49,199 --> 00:15:51,839
then we run the underlined in turbo a b

411
00:15:51,839 --> 00:15:53,360
is keychain

412
00:15:53,360 --> 00:15:55,440
with respect to the foreign policy just

413
00:15:55,440 --> 00:15:58,240
recorded this is a key policy v so uh

414
00:15:58,240 --> 00:16:00,320
the t derivation

415
00:16:00,320 --> 00:16:03,360
uh algorithm is respect to a policy this

416
00:16:03,360 --> 00:16:06,959
policy f x t takes in a secret key

417
00:16:06,959 --> 00:16:08,560
looking forward this secretly will

418
00:16:08,560 --> 00:16:11,360
actually be a constraint a prf key that

419
00:16:11,360 --> 00:16:13,199
we will generate

420
00:16:13,199 --> 00:16:16,480
and it outputs one if we have this prf

421
00:16:16,480 --> 00:16:18,880
evaluation using the hard-coded circuit

422
00:16:18,880 --> 00:16:19,920
of x

423
00:16:19,920 --> 00:16:23,040
on input of the secret key s k

424
00:16:23,040 --> 00:16:25,040
i'll put something that does not equal

425
00:16:25,040 --> 00:16:26,800
the t we computed period that we

426
00:16:26,800 --> 00:16:28,800
computed previously

427
00:16:28,800 --> 00:16:33,319
and uh we'll put zero otherwise

428
00:16:36,160 --> 00:16:38,480
and then we need to encrypt the message

429
00:16:38,480 --> 00:16:41,120
uh what do we do to encrypt

430
00:16:41,120 --> 00:16:43,920
well we just uh we're taking the uh the

431
00:16:43,920 --> 00:16:45,279
policy f

432
00:16:45,279 --> 00:16:47,360
and we can compute this simulated key

433
00:16:47,360 --> 00:16:50,399
using the prvis key simulation algorithm

434
00:16:50,399 --> 00:16:52,320
and recall that this can be done by

435
00:16:52,320 --> 00:16:54,000
anyone

436
00:16:54,000 --> 00:16:56,079
because it only needs the description of

437
00:16:56,079 --> 00:16:58,240
f and security parameters

438
00:16:58,240 --> 00:16:59,839
and after we get the

439
00:16:59,839 --> 00:17:02,079
the simulated key we just encrypt the

440
00:17:02,079 --> 00:17:04,720
message in the underlying deletable abs

441
00:17:04,720 --> 00:17:06,480
encryption with respect to this

442
00:17:06,480 --> 00:17:08,000
attribute

443
00:17:08,000 --> 00:17:10,240
of the simulated key

444
00:17:10,240 --> 00:17:12,319
and to decrypt it's simple we just run

445
00:17:12,319 --> 00:17:14,880
the underlying deletable abe decryption

446
00:17:14,880 --> 00:17:17,199
using the secret key associated with

447
00:17:17,199 --> 00:17:18,480
that previous

448
00:17:18,480 --> 00:17:22,000
fxt we talked about we get such a secret

449
00:17:22,000 --> 00:17:24,400
key and we can decrypt

450
00:17:24,400 --> 00:17:26,480
and it's probably not very obvious at

451
00:17:26,480 --> 00:17:28,880
first sight why correctness would hold

452
00:17:28,880 --> 00:17:30,080
varsity

453
00:17:30,080 --> 00:17:33,360
we refer the orders to check the details

454
00:17:33,360 --> 00:17:36,320
in our papers and take uh effective use

455
00:17:36,320 --> 00:17:38,559
of this noncluding properties

456
00:17:38,559 --> 00:17:40,160
of the prf

457
00:17:40,160 --> 00:17:42,720
simulated key and the real master secret

458
00:17:42,720 --> 00:17:44,240
key

459
00:17:44,240 --> 00:17:47,520
to show security we basically hybrid as

460
00:17:47,520 --> 00:17:49,360
follows

461
00:17:49,360 --> 00:17:51,440
so in our first hybrid

462
00:17:51,440 --> 00:17:53,919
we switch the attribute used during

463
00:17:53,919 --> 00:17:56,720
encryption from the simulated key

464
00:17:56,720 --> 00:17:59,280
to a real constraint prf key

465
00:17:59,280 --> 00:18:01,840
so recording our real uh

466
00:18:01,840 --> 00:18:03,679
encryption we need to

467
00:18:03,679 --> 00:18:06,000
do something uh we need to encrypt it to

468
00:18:06,000 --> 00:18:07,840
uh to an attribute and that we can

469
00:18:07,840 --> 00:18:10,320
generate by anyone because this is a

470
00:18:10,320 --> 00:18:12,240
public key encryption procedure and we

471
00:18:12,240 --> 00:18:16,000
can just run the key simulation uh on

472
00:18:16,000 --> 00:18:18,799
appear on the function f

473
00:18:18,799 --> 00:18:20,880
however in our hybrids we can switch it

474
00:18:20,880 --> 00:18:23,679
to a real cons uh constraint procedure

475
00:18:23,679 --> 00:18:25,679
on the master secret key uh with

476
00:18:25,679 --> 00:18:27,280
function at f

477
00:18:27,280 --> 00:18:29,360
and these indistinguishability will just

478
00:18:29,360 --> 00:18:31,679
follow from the key simulation

479
00:18:31,679 --> 00:18:35,200
property of constraint prf

480
00:18:35,200 --> 00:18:37,760
and secondly we use the restrict

481
00:18:37,760 --> 00:18:40,160
algorithm to to perform the

482
00:18:40,160 --> 00:18:42,559
uh the constraint uh

483
00:18:42,559 --> 00:18:44,240
constraining functionality thing on the

484
00:18:44,240 --> 00:18:46,559
master secret key of pif and we have

485
00:18:46,559 --> 00:18:49,120
mentioned this uh before that in our

486
00:18:49,120 --> 00:18:51,840
deletion conforming constraint prf these

487
00:18:51,840 --> 00:18:53,360
two operations are actually just

488
00:18:53,360 --> 00:18:54,720
equivalent

489
00:18:54,720 --> 00:18:56,880
and this is just

490
00:18:56,880 --> 00:19:00,000
basically removing a few blocks from the

491
00:19:00,000 --> 00:19:02,480
master secret key uh

492
00:19:02,480 --> 00:19:04,640
using the the set of indices that we we

493
00:19:04,640 --> 00:19:07,120
need to remove for f and that would just

494
00:19:07,120 --> 00:19:08,320
perform the functionality of

495
00:19:08,320 --> 00:19:12,000
constraining master secret key to f

496
00:19:12,000 --> 00:19:13,679
and finally

497
00:19:13,679 --> 00:19:16,080
notice that here uh in the previous two

498
00:19:16,080 --> 00:19:18,880
hybrids we we perform this uh

499
00:19:18,880 --> 00:19:21,280
restrict or say removal on the master

500
00:19:21,280 --> 00:19:22,400
secret key

501
00:19:22,400 --> 00:19:24,160
which would give us this attribute that

502
00:19:24,160 --> 00:19:26,080
we want to encrypt to

503
00:19:26,080 --> 00:19:28,320
and then we encrypt respect to this

504
00:19:28,320 --> 00:19:29,760
constraint key

505
00:19:29,760 --> 00:19:31,039
attribute

506
00:19:31,039 --> 00:19:33,600
uh and in the final hybrid we switch the

507
00:19:33,600 --> 00:19:35,200
order of deletion

508
00:19:35,200 --> 00:19:37,200
we first uh

509
00:19:37,200 --> 00:19:40,320
uh just uh normally use uh we just uh

510
00:19:40,320 --> 00:19:42,320
normally encrypt with respect to

511
00:19:42,320 --> 00:19:44,799
attribute that is the master uh secret

512
00:19:44,799 --> 00:19:47,520
key of prf without any constraining

513
00:19:47,520 --> 00:19:50,160
using the deletable abs encryption

514
00:19:50,160 --> 00:19:53,120
and then we run delete on the ciphertext

515
00:19:53,120 --> 00:19:55,840
using the indices to delete for f so we

516
00:19:55,840 --> 00:19:56,880
can still

517
00:19:56,880 --> 00:19:59,200
you know take taking f we can still just

518
00:19:59,200 --> 00:20:01,760
generate this set of indices and that

519
00:20:01,760 --> 00:20:03,200
wouldn't disturb

520
00:20:03,200 --> 00:20:05,360
that wouldn't really affect anything we

521
00:20:05,360 --> 00:20:08,159
can we can do the division

522
00:20:08,159 --> 00:20:10,320
on the master secret key or we can do

523
00:20:10,320 --> 00:20:12,480
the same deletion on the ciphertext and

524
00:20:12,480 --> 00:20:14,440
then this follows from deletion of

525
00:20:14,440 --> 00:20:18,640
indistinguishability of deletable abe

526
00:20:19,360 --> 00:20:21,360
and finally

527
00:20:21,360 --> 00:20:22,880
we can uh

528
00:20:22,880 --> 00:20:25,440
we can actually use this to break the

529
00:20:25,440 --> 00:20:27,919
selected security of deletable abe and

530
00:20:27,919 --> 00:20:30,960
suppose the adversary can break the uh

531
00:20:30,960 --> 00:20:33,360
the adaptive cpa security of our a b

532
00:20:33,360 --> 00:20:35,280
scheme in the final hybrid

533
00:20:35,280 --> 00:20:37,600
and we can use it to break the selective

534
00:20:37,600 --> 00:20:40,240
sap security of the underlying deletable

535
00:20:40,240 --> 00:20:42,640
abe

536
00:20:44,480 --> 00:20:46,720
and finally how do we instantiate our

537
00:20:46,720 --> 00:20:49,280
building blocks the first thing is

538
00:20:49,280 --> 00:20:52,080
deletion conforming construing prf

539
00:20:52,080 --> 00:20:54,880
we can realize it a subset functionality

540
00:20:54,880 --> 00:20:57,280
just following the construction in these

541
00:20:57,280 --> 00:20:59,760
two works

542
00:21:00,640 --> 00:21:03,520
and secondly for deletable abe

543
00:21:03,520 --> 00:21:06,240
uh we can uh uh realize that from from

544
00:21:06,240 --> 00:21:08,880
uh from uh some different sorts of works

545
00:21:08,880 --> 00:21:11,280
uh we can actually modify the following

546
00:21:11,280 --> 00:21:12,640
schemes

547
00:21:12,640 --> 00:21:15,440
into a deletable abe scheme

548
00:21:15,440 --> 00:21:18,080
into divisible a b streams for the group

549
00:21:18,080 --> 00:21:20,640
side we can

550
00:21:20,640 --> 00:21:22,799
modify the gpsw

551
00:21:22,799 --> 00:21:26,240
2006 paper which uses the search

552
00:21:26,240 --> 00:21:29,120
assumption on bilinear groups

553
00:21:29,120 --> 00:21:31,200
and for the laddie side we can do both

554
00:21:31,200 --> 00:21:34,559
buoyant thirteen and bgg plots fourteen

555
00:21:34,559 --> 00:21:36,480
even though actually recently as we

556
00:21:36,480 --> 00:21:38,320
mentioned there is what was this attack

557
00:21:38,320 --> 00:21:40,320
on buoyancy paper

558
00:21:40,320 --> 00:21:42,240
uh but that came out after the first

559
00:21:42,240 --> 00:21:45,200
draft of our paper and we just we still

560
00:21:45,200 --> 00:21:47,280
leave this example in our paper just for

561
00:21:47,280 --> 00:21:49,600
the illustrative purpose to see how the

562
00:21:49,600 --> 00:21:50,640
deletion

563
00:21:50,640 --> 00:21:54,559
uh how the deletable abe would work

564
00:21:54,640 --> 00:21:57,600
and uh regarding uh related works

565
00:21:57,600 --> 00:21:58,400
actually

566
00:21:58,400 --> 00:22:00,240
besides all these passwords we already

567
00:22:00,240 --> 00:22:02,480
mentioned there was also a concurrent

568
00:22:02,480 --> 00:22:05,679
work by katsumata nishimaki yamada and

569
00:22:05,679 --> 00:22:08,559
yamakawa that extend the functionality

570
00:22:08,559 --> 00:22:10,400
of sabari scheme into an inner product

571
00:22:10,400 --> 00:22:12,640
functionality and they also follow

572
00:22:12,640 --> 00:22:14,240
the same high level approach as the

573
00:22:14,240 --> 00:22:16,880
subreddit scheme

574
00:22:16,880 --> 00:22:19,200
finally is our summary

575
00:22:19,200 --> 00:22:22,880
with adaptive constraint prf adapting

576
00:22:22,880 --> 00:22:25,200
secure constraint prf and selective

577
00:22:25,200 --> 00:22:26,400
secure a b

578
00:22:26,400 --> 00:22:29,360
we can realize that that is secure abe

579
00:22:29,360 --> 00:22:32,080
but the policy is just a subsystem

580
00:22:32,080 --> 00:22:34,559
constraint which follows from the policy

581
00:22:34,559 --> 00:22:37,840
we can realize for the constraint prf

582
00:22:37,840 --> 00:22:40,240
and we need the abe to be deletable but

583
00:22:40,240 --> 00:22:42,400
we can build such a be from a bunch of

584
00:22:42,400 --> 00:22:45,200
assumptions both

585
00:22:45,200 --> 00:22:48,799
search bilinear and lattice

586
00:22:50,000 --> 00:22:52,960
thank you that's it for our talk

587
00:22:52,960 --> 00:22:54,720
please refer for more details in our

588
00:22:54,720 --> 00:22:57,720
paper

