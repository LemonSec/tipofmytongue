1
00:00:01,439 --> 00:00:03,600
hello thank you for watching this talk

2
00:00:03,600 --> 00:00:05,520
on improved single round secure

3
00:00:05,520 --> 00:00:08,480
multiplication using regenerating codes

4
00:00:08,480 --> 00:00:10,880
i am daniel scudero and this is joint

5
00:00:10,880 --> 00:00:13,599
work with markups paul

6
00:00:13,599 --> 00:00:17,040
evan dungard donald

7
00:00:18,960 --> 00:00:22,160
so let me begin by describing what the

8
00:00:22,160 --> 00:00:24,560
setting we are starting here is

9
00:00:24,560 --> 00:00:27,359
so our context is secure multiplication

10
00:00:27,359 --> 00:00:29,519
with sql sharing based and pc

11
00:00:29,519 --> 00:00:33,040
so imagine you have n parties

12
00:00:33,040 --> 00:00:36,079
p1 p2 up to pn

13
00:00:36,079 --> 00:00:39,200
and they have two secret share values

14
00:00:39,200 --> 00:00:41,280
we are denoting sql sharing by brackets

15
00:00:41,280 --> 00:00:42,000
of

16
00:00:42,000 --> 00:00:45,280
x brackets of y and and the shares are x

17
00:00:45,280 --> 00:00:48,800
1 up to x n and y 1 up to y n

18
00:00:48,800 --> 00:00:52,000
respectively secret shared means

19
00:00:52,000 --> 00:00:53,360
i'm assuming background on secret

20
00:00:53,360 --> 00:00:56,160
sharing but it basically means that

21
00:00:56,160 --> 00:00:58,640
each subset of at most the

22
00:00:58,640 --> 00:01:00,800
tea parties cannot learn anything about

23
00:01:00,800 --> 00:01:03,039
the secret and any subset of t plus one

24
00:01:03,039 --> 00:01:04,479
parties can completely determine the

25
00:01:04,479 --> 00:01:06,000
secret

26
00:01:06,000 --> 00:01:07,760
and

27
00:01:07,760 --> 00:01:09,360
imagine they have these two share values

28
00:01:09,360 --> 00:01:11,280
the goal in secure multiplication is

29
00:01:11,280 --> 00:01:13,520
essentially to obtain shares

30
00:01:13,520 --> 00:01:16,159
of the product of x times y and the

31
00:01:16,159 --> 00:01:17,920
shares

32
00:01:17,920 --> 00:01:19,759
i would denote them by z one up to the

33
00:01:19,759 --> 00:01:20,400
end

34
00:01:20,400 --> 00:01:22,799
and the idea is that the parties will

35
00:01:22,799 --> 00:01:25,680
engage in some kind of protocol in some

36
00:01:25,680 --> 00:01:28,799
kind of interaction to be able to obtain

37
00:01:28,799 --> 00:01:32,000
these z1 z2 up to the ends so that they

38
00:01:32,000 --> 00:01:34,400
are sharing of the corresponding product

39
00:01:34,400 --> 00:01:36,159
of the two secrets

40
00:01:36,159 --> 00:01:37,040
and

41
00:01:37,040 --> 00:01:39,600
in this context in in this work we are

42
00:01:39,600 --> 00:01:41,759
in the honest majority setting so we

43
00:01:41,759 --> 00:01:43,439
assuming and we assume the maximal

44
00:01:43,439 --> 00:01:45,439
adversary so we are assuming that n the

45
00:01:45,439 --> 00:01:48,320
number of parties is equal to 2t plus 1

46
00:01:48,320 --> 00:01:49,920
where t is the number of corruptions

47
00:01:49,920 --> 00:01:51,840
which is also the threshold of the

48
00:01:51,840 --> 00:01:53,040
scheme

49
00:01:53,040 --> 00:01:55,200
and we assume in a paper we assume

50
00:01:55,200 --> 00:01:57,920
active security with the board but

51
00:01:57,920 --> 00:01:59,360
for the purpose of the slides i'm going

52
00:01:59,360 --> 00:02:01,119
to be talking mostly about passive

53
00:02:01,119 --> 00:02:02,399
security

54
00:02:02,399 --> 00:02:04,479
so this is the sort of main problem that

55
00:02:04,479 --> 00:02:05,600
we're selling

56
00:02:05,600 --> 00:02:07,360
and there are several

57
00:02:07,360 --> 00:02:09,038
different protocols to achieve this so

58
00:02:09,038 --> 00:02:11,920
one of them one of the oldest one

59
00:02:11,920 --> 00:02:16,400
is bgw and in this protocol we have two

60
00:02:16,400 --> 00:02:18,879
sharings so we have x and y the inputs

61
00:02:18,879 --> 00:02:21,040
again are like x1

62
00:02:21,040 --> 00:02:24,080
up to y 1 x 1 up to x n the sharings of

63
00:02:24,080 --> 00:02:27,040
x and y 1 up to y n the series of y

64
00:02:27,040 --> 00:02:29,280
and the first observation is that this

65
00:02:29,280 --> 00:02:32,160
uses shameer secret sharing

66
00:02:32,160 --> 00:02:35,280
which uses polynomials of degree in

67
00:02:35,280 --> 00:02:36,959
at most t

68
00:02:36,959 --> 00:02:38,480
and

69
00:02:38,480 --> 00:02:39,920
with this secretion scheme if the

70
00:02:39,920 --> 00:02:42,319
parties locally multiply their shares so

71
00:02:42,319 --> 00:02:43,519
x1

72
00:02:43,519 --> 00:02:47,200
times y1 so p1 executes x1 times y1

73
00:02:47,200 --> 00:02:50,319
p2 similarly executes x2 times y2 up to

74
00:02:50,319 --> 00:02:53,040
bn who executes who computes internally

75
00:02:53,040 --> 00:02:55,840
xn times yn if the parties do this then

76
00:02:55,840 --> 00:02:57,920
one can easily show that these are

77
00:02:57,920 --> 00:03:00,720
sharings of the product but now under a

78
00:03:00,720 --> 00:03:02,080
different degree

79
00:03:02,080 --> 00:03:04,400
so this is the first observation in bdw

80
00:03:04,400 --> 00:03:06,800
and then

81
00:03:06,800 --> 00:03:08,159
because we don't want to have them with

82
00:03:08,159 --> 00:03:09,360
degree to t we want to have them with

83
00:03:09,360 --> 00:03:11,599
degree t we can execute the second step

84
00:03:11,599 --> 00:03:15,120
in which each party pi will essentially

85
00:03:15,120 --> 00:03:16,879
take its own share

86
00:03:16,879 --> 00:03:18,879
x i y i that computed in the previous

87
00:03:18,879 --> 00:03:20,640
step and it would simply share it

88
00:03:20,640 --> 00:03:23,280
towards towards all the other parties so

89
00:03:23,280 --> 00:03:25,120
now all the parties have shares of

90
00:03:25,120 --> 00:03:27,200
degree t of each one of these individual

91
00:03:27,200 --> 00:03:28,080
shares

92
00:03:28,080 --> 00:03:30,400
and because we know that these are

93
00:03:30,400 --> 00:03:32,720
sharings of degree to t we know that

94
00:03:32,720 --> 00:03:35,680
there exists certain coefficients

95
00:03:35,680 --> 00:03:38,159
that i'm denoting here by lambda

96
00:03:38,159 --> 00:03:40,319
there are certain coefficients so that

97
00:03:40,319 --> 00:03:42,239
if you take this linear combination of

98
00:03:42,239 --> 00:03:43,760
these shares

99
00:03:43,760 --> 00:03:45,760
you get x y this is just from the fact

100
00:03:45,760 --> 00:03:49,200
that the x i y i are shares

101
00:03:49,200 --> 00:03:52,239
of x and y and then because we know that

102
00:03:52,239 --> 00:03:54,239
such coefficients exist and now we have

103
00:03:54,239 --> 00:03:55,200
shares

104
00:03:55,200 --> 00:03:57,840
of these individual sharings then we can

105
00:03:57,840 --> 00:03:59,360
take the same linear combination down

106
00:03:59,360 --> 00:04:01,439
here but now with sharings

107
00:04:01,439 --> 00:04:04,879
and obtain sharings with the same degree

108
00:04:04,879 --> 00:04:07,360
of the product and this is what is done

109
00:04:07,360 --> 00:04:10,159
in bdw so

110
00:04:10,159 --> 00:04:12,400
this is this is a very old a

111
00:04:12,400 --> 00:04:14,480
untraditional protocol and

112
00:04:14,480 --> 00:04:17,440
the downside with this protocol

113
00:04:17,440 --> 00:04:20,320
is that the communication complexity is

114
00:04:20,320 --> 00:04:23,680
n square like because every single party

115
00:04:23,680 --> 00:04:25,120
in this step

116
00:04:25,120 --> 00:04:27,040
which are any of them needs to

117
00:04:27,040 --> 00:04:29,600
distribute shares of this product

118
00:04:29,600 --> 00:04:31,440
and there are n parties to distribute

119
00:04:31,440 --> 00:04:33,120
the shares too

120
00:04:33,120 --> 00:04:34,320
so

121
00:04:34,320 --> 00:04:37,040
like this this step it will take a

122
00:04:37,040 --> 00:04:38,880
communication in total of roughly n

123
00:04:38,880 --> 00:04:40,720
square the good thing is that it takes

124
00:04:40,720 --> 00:04:42,720
one round though because you only need

125
00:04:42,720 --> 00:04:43,759
to

126
00:04:43,759 --> 00:04:45,360
do this the only interaction comes in

127
00:04:45,360 --> 00:04:46,880
this step and it's just

128
00:04:46,880 --> 00:04:48,639
like one party sending a message to

129
00:04:48,639 --> 00:04:50,960
another parties

130
00:04:50,960 --> 00:04:52,639
so this is one of the first protocols

131
00:04:52,639 --> 00:04:55,440
but then we also have a more updated and

132
00:04:55,440 --> 00:04:58,000
more efficient approach which is the

133
00:04:58,000 --> 00:05:00,560
danganronism protocol from crypto 2007

134
00:05:00,560 --> 00:05:03,440
and this protocol again we start with

135
00:05:03,440 --> 00:05:05,360
the observation that

136
00:05:05,360 --> 00:05:07,120
if you have shares of x and the parts

137
00:05:07,120 --> 00:05:09,039
have also shares of y

138
00:05:09,039 --> 00:05:11,199
then they can locally get shares with

139
00:05:11,199 --> 00:05:13,600
with a higher degree with degree to t

140
00:05:13,600 --> 00:05:15,680
this is the same starting point but

141
00:05:15,680 --> 00:05:17,600
instead of proceeding as before what the

142
00:05:17,600 --> 00:05:19,759
parties will do is that they will assume

143
00:05:19,759 --> 00:05:22,080
some pre-processed data this consists of

144
00:05:22,080 --> 00:05:23,600
pairs

145
00:05:23,600 --> 00:05:25,280
random values that are secret shared

146
00:05:25,280 --> 00:05:27,199
both with degree t and also with degree

147
00:05:27,199 --> 00:05:28,160
to t

148
00:05:28,160 --> 00:05:30,000
so assuming this preprocessing the

149
00:05:30,000 --> 00:05:31,360
parties can

150
00:05:31,360 --> 00:05:33,840
first locally compute

151
00:05:33,840 --> 00:05:36,240
this difference so they take x y with

152
00:05:36,240 --> 00:05:38,720
degrees to t and they subtract from it r

153
00:05:38,720 --> 00:05:40,639
with degree to t as well and they obtain

154
00:05:40,639 --> 00:05:42,240
some value that we're calling e also

155
00:05:42,240 --> 00:05:43,680
with degrees of t

156
00:05:43,680 --> 00:05:46,000
and then each party pi

157
00:05:46,000 --> 00:05:50,080
sends this value to p1 the share of e

158
00:05:50,080 --> 00:05:51,600
is sent to p1

159
00:05:51,600 --> 00:05:53,919
and then p1 will reconstruct e it's fine

160
00:05:53,919 --> 00:05:55,919
for p1 to learn all this because even

161
00:05:55,919 --> 00:05:57,759
though p1 is not supposed to learn what

162
00:05:57,759 --> 00:06:00,479
the product is it is being masked with r

163
00:06:00,479 --> 00:06:04,880
so this looks nothing sensitive to p1

164
00:06:04,880 --> 00:06:07,680
and this is the first step and the i

165
00:06:07,680 --> 00:06:09,520
mean the first interaction step and then

166
00:06:09,520 --> 00:06:11,440
the second interactive step

167
00:06:11,440 --> 00:06:15,120
is that after p1 reconstructs e

168
00:06:15,120 --> 00:06:19,120
p1 will send this value to all parties

169
00:06:19,120 --> 00:06:21,840
a and then after all the parties learned

170
00:06:21,840 --> 00:06:24,160
e then they can

171
00:06:24,160 --> 00:06:26,160
they can locally compute

172
00:06:26,160 --> 00:06:28,319
add e to the other part of of the

173
00:06:28,319 --> 00:06:30,400
preprocessing to obtain shares of x

174
00:06:30,400 --> 00:06:32,160
times y so

175
00:06:32,160 --> 00:06:34,319
in nutshell what what's happening here

176
00:06:34,319 --> 00:06:36,720
is that the parties are reconstructing

177
00:06:36,720 --> 00:06:39,600
this e-value

178
00:06:39,600 --> 00:06:41,759
but to do so they are first sending the

179
00:06:41,759 --> 00:06:43,520
shares to one single party and this

180
00:06:43,520 --> 00:06:45,440
single party is sending the result to

181
00:06:45,440 --> 00:06:47,039
everyone this way the communication

182
00:06:47,039 --> 00:06:49,280
complexity is not n square because not

183
00:06:49,280 --> 00:06:51,120
everyone is talking to everyone

184
00:06:51,120 --> 00:06:52,639
everyone is talking to just one single

185
00:06:52,639 --> 00:06:54,479
party who is replying back so the

186
00:06:54,479 --> 00:06:55,840
communication complexity grows

187
00:06:55,840 --> 00:06:58,719
proportionately with n

188
00:06:58,880 --> 00:07:00,240
so the communication complexity as i

189
00:07:00,240 --> 00:07:02,240
mentioned well it goes with n but the

190
00:07:02,240 --> 00:07:04,960
number of rounds now is two because

191
00:07:04,960 --> 00:07:07,199
there is one round to send all the

192
00:07:07,199 --> 00:07:09,360
single shares to p1 and then there is

193
00:07:09,360 --> 00:07:12,080
another round for p1 to send the value

194
00:07:12,080 --> 00:07:14,000
the reconstructed value back

195
00:07:14,000 --> 00:07:15,759
so much more efficient protocol but now

196
00:07:15,759 --> 00:07:17,360
has two rounds

197
00:07:17,360 --> 00:07:19,440
so the question

198
00:07:19,440 --> 00:07:22,080
is is the scenario the panorama looks

199
00:07:22,080 --> 00:07:23,840
something like this in terms of

200
00:07:23,840 --> 00:07:26,319
communication complexity

201
00:07:26,319 --> 00:07:28,639
it you can have

202
00:07:28,639 --> 00:07:30,560
you can have a very small communication

203
00:07:30,560 --> 00:07:32,560
complexity in particular it can be soft

204
00:07:32,560 --> 00:07:34,400
and square it can be linear in fact as

205
00:07:34,400 --> 00:07:35,520
we just saw

206
00:07:35,520 --> 00:07:37,680
with the dn07 protocol but then it would

207
00:07:37,680 --> 00:07:39,680
require more than one round two to be

208
00:07:39,680 --> 00:07:42,639
concrete and then the other approach is

209
00:07:42,639 --> 00:07:44,639
that maybe i want to have one round but

210
00:07:44,639 --> 00:07:47,759
then you have to use the vdw protocol

211
00:07:47,759 --> 00:07:49,599
which has a communication complexity of

212
00:07:49,599 --> 00:07:51,120
n squared

213
00:07:51,120 --> 00:07:54,639
so this regime here is essentially

214
00:07:54,639 --> 00:07:56,400
unexplored this what happens when we

215
00:07:56,400 --> 00:07:58,160
want to

216
00:07:58,160 --> 00:08:00,479
stick to one single round

217
00:08:00,479 --> 00:08:03,440
but at the same time we want to achieve

218
00:08:03,440 --> 00:08:05,199
a communication complexity that is

219
00:08:05,199 --> 00:08:07,440
better than the one from vdw so also

220
00:08:07,440 --> 00:08:08,960
better than n square

221
00:08:08,960 --> 00:08:11,360
so can there exist one round secure

222
00:08:11,360 --> 00:08:13,120
multiplication protocols with soft

223
00:08:13,120 --> 00:08:15,759
quadratic communication complexity and

224
00:08:15,759 --> 00:08:18,080
even we may allow some pre-processing

225
00:08:18,080 --> 00:08:20,080
just like dn070 uses pre-processing we

226
00:08:20,080 --> 00:08:21,680
may allow this

227
00:08:21,680 --> 00:08:23,199
and this is the question we're looking

228
00:08:23,199 --> 00:08:26,000
at in this work so can we find protocols

229
00:08:26,000 --> 00:08:28,479
like this

230
00:08:29,199 --> 00:08:31,440
so the first

231
00:08:31,440 --> 00:08:32,399
a

232
00:08:32,399 --> 00:08:33,760
the first idea to resolve in the

233
00:08:33,760 --> 00:08:35,599
question is that there cannot exceed

234
00:08:35,599 --> 00:08:39,360
such protocols if in the process of of

235
00:08:39,360 --> 00:08:41,279
reconstruct in the process of getting

236
00:08:41,279 --> 00:08:43,519
the multiplication you need to open

237
00:08:43,519 --> 00:08:46,320
or reconstruct certain

238
00:08:46,320 --> 00:08:48,320
shared values and this is easy because

239
00:08:48,320 --> 00:08:50,160
when everybody is supposed to learn a

240
00:08:50,160 --> 00:08:51,440
share value

241
00:08:51,440 --> 00:08:54,480
in one single round there is no other

242
00:08:54,480 --> 00:08:57,279
option than letting each party hear from

243
00:08:57,279 --> 00:08:59,760
at least t plus one parties because if a

244
00:08:59,760 --> 00:09:02,399
single party could learn a secret if by

245
00:09:02,399 --> 00:09:03,600
hearing

246
00:09:03,600 --> 00:09:05,839
from less of this number of parties

247
00:09:05,839 --> 00:09:08,320
then this party like an adversary

248
00:09:08,320 --> 00:09:10,480
corrupting tea parties will have

249
00:09:10,480 --> 00:09:12,320
known the secret to begin with

250
00:09:12,320 --> 00:09:15,680
so if openings are part of your protocol

251
00:09:15,680 --> 00:09:17,360
if somehow you need to open something

252
00:09:17,360 --> 00:09:19,760
and you have to stick to one round

253
00:09:19,760 --> 00:09:20,800
then

254
00:09:20,800 --> 00:09:22,640
then you have to go with the n squared

255
00:09:22,640 --> 00:09:24,399
but in general we don't know

256
00:09:24,399 --> 00:09:26,720
we don't know if you really need to

257
00:09:26,720 --> 00:09:27,839
to

258
00:09:27,839 --> 00:09:28,959
go

259
00:09:28,959 --> 00:09:30,560
up to n square if you insist in one

260
00:09:30,560 --> 00:09:32,320
round and in particular i mean this is

261
00:09:32,320 --> 00:09:35,360
the case because if you look at bdw bgw

262
00:09:35,360 --> 00:09:38,000
is a protocol that does not use

263
00:09:38,000 --> 00:09:40,720
the bdw protocol does not use

264
00:09:40,720 --> 00:09:42,720
openings it uses

265
00:09:42,720 --> 00:09:45,279
a re-sharing how it's called and still

266
00:09:45,279 --> 00:09:47,279
takes n squared so so maybe every

267
00:09:47,279 --> 00:09:49,360
protocol will take n squared even if it

268
00:09:49,360 --> 00:09:51,440
is

269
00:09:51,440 --> 00:09:53,519
even if it is only it doesn't use

270
00:09:53,519 --> 00:09:55,519
openings so

271
00:09:55,519 --> 00:09:58,880
this is a very interesting question and

272
00:09:58,880 --> 00:10:01,040
i would like to motivate also i mean

273
00:10:01,040 --> 00:10:02,640
this is an interesting question on its

274
00:10:02,640 --> 00:10:04,720
own because most protocol seems to have

275
00:10:04,720 --> 00:10:06,480
this compromise but it's also a very

276
00:10:06,480 --> 00:10:08,480
useful question so minimizing the number

277
00:10:08,480 --> 00:10:10,560
of rounds is is very well motivated in

278
00:10:10,560 --> 00:10:13,040
especially in highly relevant

279
00:10:13,040 --> 00:10:14,800
especially in highly

280
00:10:14,800 --> 00:10:17,839
in scenarios with high latency

281
00:10:17,839 --> 00:10:20,079
because these scenarios you will spend a

282
00:10:20,079 --> 00:10:21,839
lot of time if you have to communicate

283
00:10:21,839 --> 00:10:23,120
back and forth you want to minimize the

284
00:10:23,120 --> 00:10:24,800
number of rounds

285
00:10:24,800 --> 00:10:26,560
it's okay if you maybe communicate a

286
00:10:26,560 --> 00:10:27,600
little bit more as long as you're

287
00:10:27,600 --> 00:10:30,480
minimizing the round count

288
00:10:30,480 --> 00:10:32,640
so that's one motivation but besides

289
00:10:32,640 --> 00:10:34,240
that there are some protocols in the

290
00:10:34,240 --> 00:10:36,320
literature most notably we have this

291
00:10:36,320 --> 00:10:38,160
protocol fluid mpc

292
00:10:38,160 --> 00:10:40,880
that aims at tolerating dynamic

293
00:10:40,880 --> 00:10:42,160
participants

294
00:10:42,160 --> 00:10:44,560
so people can come and go

295
00:10:44,560 --> 00:10:46,880
in those protocols you want to do things

296
00:10:46,880 --> 00:10:48,240
as

297
00:10:48,240 --> 00:10:49,839
fast as possible in the sense that you

298
00:10:49,839 --> 00:10:50,560
don't want to have a lot of

299
00:10:50,560 --> 00:10:51,680
communication around so every

300
00:10:51,680 --> 00:10:53,200
multiplication or every layer in the

301
00:10:53,200 --> 00:10:55,200
circuit hopefully takes you one single

302
00:10:55,200 --> 00:10:57,519
round because if you achieve this then

303
00:10:57,519 --> 00:11:00,640
it means that you have a you can sort of

304
00:11:00,640 --> 00:11:02,160
transfer the state

305
00:11:02,160 --> 00:11:04,160
from one set of parties to the other set

306
00:11:04,160 --> 00:11:05,360
of parts which is the setting they

307
00:11:05,360 --> 00:11:06,880
consider in their work

308
00:11:06,880 --> 00:11:09,519
so in other words in other words if you

309
00:11:09,519 --> 00:11:11,839
have one round multiplication protocols

310
00:11:11,839 --> 00:11:14,560
you can essentially plug and play a plug

311
00:11:14,560 --> 00:11:16,640
these protocols into works like this one

312
00:11:16,640 --> 00:11:18,720
that require one run multiplication

313
00:11:18,720 --> 00:11:21,200
protocols

314
00:11:22,240 --> 00:11:24,079
so what are the results that we achieve

315
00:11:24,079 --> 00:11:25,519
in this work

316
00:11:25,519 --> 00:11:26,320
in

317
00:11:26,320 --> 00:11:27,440
in this

318
00:11:27,440 --> 00:11:30,079
work we actually make use of of a very

319
00:11:30,079 --> 00:11:31,519
interesting mathematical tool called

320
00:11:31,519 --> 00:11:34,160
regenerating codes in order to design a

321
00:11:34,160 --> 00:11:36,720
one-round secure multiplication protocol

322
00:11:36,720 --> 00:11:37,680
but

323
00:11:37,680 --> 00:11:39,040
unfortunately we don't know how to do

324
00:11:39,040 --> 00:11:42,079
that exactly like that we need to design

325
00:11:42,079 --> 00:11:43,839
such multiplication protocol for many

326
00:11:43,839 --> 00:11:45,920
multiplications at once

327
00:11:45,920 --> 00:11:48,880
uh i was i would be delighted to show a

328
00:11:48,880 --> 00:11:51,120
result that says we can we i give you a

329
00:11:51,120 --> 00:11:52,880
protocol for one single multiplication

330
00:11:52,880 --> 00:11:54,800
that is one round and only and takes

331
00:11:54,800 --> 00:11:56,880
less than n squared communication but we

332
00:11:56,880 --> 00:11:58,160
don't know how to do that we don't even

333
00:11:58,160 --> 00:12:00,000
know if that's possible but for many

334
00:12:00,000 --> 00:12:02,240
multiplications

335
00:12:02,240 --> 00:12:03,680
in parallel

336
00:12:03,680 --> 00:12:05,680
we can get a self quadratic

337
00:12:05,680 --> 00:12:07,839
communication complexity amortized per

338
00:12:07,839 --> 00:12:08,880
product

339
00:12:08,880 --> 00:12:10,880
so of course computing all these single

340
00:12:10,880 --> 00:12:13,279
products all together they will take

341
00:12:13,279 --> 00:12:15,920
they may take a more than n square but

342
00:12:15,920 --> 00:12:17,440
when you amortize divide by the number

343
00:12:17,440 --> 00:12:19,839
of products being or computed then you

344
00:12:19,839 --> 00:12:22,320
get less than quadratic

345
00:12:22,320 --> 00:12:23,600
so this is the result we get in this

346
00:12:23,600 --> 00:12:24,639
work

347
00:12:24,639 --> 00:12:26,320
and

348
00:12:26,320 --> 00:12:28,240
it to be more concrete with this

349
00:12:28,240 --> 00:12:30,959
we present uh an npc protocol with the

350
00:12:30,959 --> 00:12:32,800
following characteristics so first it's

351
00:12:32,800 --> 00:12:34,240
going to be actively secure and this is

352
00:12:34,240 --> 00:12:36,720
one of the big things that is one of the

353
00:12:36,720 --> 00:12:38,399
big problems because passive security is

354
00:12:38,399 --> 00:12:40,560
much easier than active so moving to

355
00:12:40,560 --> 00:12:42,880
active requires some care

356
00:12:42,880 --> 00:12:45,519
it considers the maximal adversary

357
00:12:45,519 --> 00:12:47,680
possible which is in the honest majority

358
00:12:47,680 --> 00:12:49,680
setting which is essentially n equal to

359
00:12:49,680 --> 00:12:51,920
two t plus one if you go less than that

360
00:12:51,920 --> 00:12:53,839
then you can start considering using

361
00:12:53,839 --> 00:12:56,000
back secret sharing techniques that

362
00:12:56,000 --> 00:12:58,079
somehow can achieve this kind of result

363
00:12:58,079 --> 00:13:01,120
already so the interesting case is is

364
00:13:01,120 --> 00:13:03,120
the maximum adversaries

365
00:13:03,120 --> 00:13:05,600
and then our protocol would evaluate a

366
00:13:05,600 --> 00:13:06,959
set of a

367
00:13:06,959 --> 00:13:08,959
gates or more generally we generalize

368
00:13:08,959 --> 00:13:11,120
the circuit so we evaluate a d layer

369
00:13:11,120 --> 00:13:12,240
circuit

370
00:13:12,240 --> 00:13:14,639
so circuit with demultiplicative layers

371
00:13:14,639 --> 00:13:16,959
we evaluate not not one of them but

372
00:13:16,959 --> 00:13:18,480
actually log in copies of the same

373
00:13:18,480 --> 00:13:20,560
circuit

374
00:13:20,560 --> 00:13:23,440
and we do it in essentially d rounds

375
00:13:23,440 --> 00:13:25,839
d rounds but with a little bit more that

376
00:13:25,839 --> 00:13:27,360
comes from the pre-processing basically

377
00:13:27,360 --> 00:13:28,639
and some check that must be done at the

378
00:13:28,639 --> 00:13:30,240
end but

379
00:13:30,240 --> 00:13:33,360
essentially the rounds which

380
00:13:33,600 --> 00:13:35,040
is essentially one single round per

381
00:13:35,040 --> 00:13:38,959
multiplication layer and each

382
00:13:38,959 --> 00:13:41,440
gate each multiplication gate

383
00:13:41,440 --> 00:13:43,360
of each instant instance is going to

384
00:13:43,360 --> 00:13:46,160
take soft quadratic communication

385
00:13:46,160 --> 00:13:48,000
and what i would like to stress that

386
00:13:48,000 --> 00:13:49,680
this is the first application of

387
00:13:49,680 --> 00:13:51,440
regenerating codes

388
00:13:51,440 --> 00:13:53,920
in the context of mpc

389
00:13:53,920 --> 00:13:55,920
which is something that

390
00:13:55,920 --> 00:13:57,519
the community has been looking at for a

391
00:13:57,519 --> 00:13:59,360
while like how to get

392
00:13:59,360 --> 00:14:01,040
this type of regenerating codes to help

393
00:14:01,040 --> 00:14:02,800
applications in npc

394
00:14:02,800 --> 00:14:04,240
and

395
00:14:04,240 --> 00:14:06,880
it was not possible to design one of

396
00:14:06,880 --> 00:14:10,399
those until recently

397
00:14:10,800 --> 00:14:12,480
so let me give you an idea about

398
00:14:12,480 --> 00:14:14,240
why are generating code is useful so

399
00:14:14,240 --> 00:14:15,920
let's begin with this diagram imagine we

400
00:14:15,920 --> 00:14:17,839
have a secret s

401
00:14:17,839 --> 00:14:18,880
and this

402
00:14:18,880 --> 00:14:21,279
secret is secret shared

403
00:14:21,279 --> 00:14:23,199
into well shares of s

404
00:14:23,199 --> 00:14:25,120
let's call them as one is two one is n

405
00:14:25,120 --> 00:14:26,800
and then the dealer whoever is dealing

406
00:14:26,800 --> 00:14:28,240
these values is going to distribute

407
00:14:28,240 --> 00:14:30,399
these values to p p1 p2 up to pn so this

408
00:14:30,399 --> 00:14:33,279
is the the sharing phase

409
00:14:33,279 --> 00:14:35,600
so imagine this is this is the beginning

410
00:14:35,600 --> 00:14:36,959
this is the first one of the first

411
00:14:36,959 --> 00:14:38,959
stages and then later on eventually you

412
00:14:38,959 --> 00:14:40,720
want to reconstruct this data imagine i

413
00:14:40,720 --> 00:14:42,399
know you are storing a file among

414
00:14:42,399 --> 00:14:43,760
multiple nodes and then later on you

415
00:14:43,760 --> 00:14:45,360
want to retrieve this file

416
00:14:45,360 --> 00:14:47,440
so then what you do later on

417
00:14:47,440 --> 00:14:49,199
is that

418
00:14:49,199 --> 00:14:51,360
well all these

419
00:14:51,360 --> 00:14:53,839
parties will send the shares to whoever

420
00:14:53,839 --> 00:14:56,160
needs them and all the shares together

421
00:14:56,160 --> 00:14:58,480
with will determine the secret s but

422
00:14:58,480 --> 00:15:01,120
actually only t plus one of them suffice

423
00:15:01,120 --> 00:15:02,639
because it's a threshold secret sharing

424
00:15:02,639 --> 00:15:04,880
scheme less than t shares don't don't

425
00:15:04,880 --> 00:15:06,399
tell you anything about the secret but t

426
00:15:06,399 --> 00:15:08,800
plus one will completely determine the

427
00:15:08,800 --> 00:15:10,720
secret so so many of these parts don't

428
00:15:10,720 --> 00:15:12,320
need to send a message only t plus one

429
00:15:12,320 --> 00:15:14,800
need to send a message

430
00:15:14,800 --> 00:15:15,920
so

431
00:15:15,920 --> 00:15:18,560
what is the the goal with regenerating

432
00:15:18,560 --> 00:15:20,639
codes or what's the deal with them so

433
00:15:20,639 --> 00:15:23,279
it's the same setting as before except

434
00:15:23,279 --> 00:15:26,480
that this time instead of p1 sending the

435
00:15:26,480 --> 00:15:29,279
whole s1 for reconstruction is going to

436
00:15:29,279 --> 00:15:31,519
send it's going to apply a function to

437
00:15:31,519 --> 00:15:33,199
s1 first

438
00:15:33,199 --> 00:15:35,839
before sending it and the idea is that

439
00:15:35,839 --> 00:15:39,680
maybe now we need all the n shares

440
00:15:39,680 --> 00:15:41,600
like instead of taking a subset of them

441
00:15:41,600 --> 00:15:45,199
we we will need all of them but each mu

442
00:15:45,199 --> 00:15:46,079
i

443
00:15:46,079 --> 00:15:49,040
as denoted here will be a compression

444
00:15:49,040 --> 00:15:51,120
function so down here you can see that

445
00:15:51,120 --> 00:15:54,800
each mu i takes elements in a big field

446
00:15:54,800 --> 00:15:57,360
and they return element in a small field

447
00:15:57,360 --> 00:15:58,079
so

448
00:15:58,079 --> 00:16:00,880
these mu eyes here that i'm showing up

449
00:16:00,880 --> 00:16:03,279
here they are all reduction functions

450
00:16:03,279 --> 00:16:05,120
they take something bigger and they turn

451
00:16:05,120 --> 00:16:06,480
into something smaller

452
00:16:06,480 --> 00:16:08,240
so overall this is better than before

453
00:16:08,240 --> 00:16:10,079
because then you have like

454
00:16:10,079 --> 00:16:11,920
sure everyone is talking now but the

455
00:16:11,920 --> 00:16:13,759
amount of data they're sending is way

456
00:16:13,759 --> 00:16:15,680
smaller

457
00:16:15,680 --> 00:16:17,920
so this is regenerating codes

458
00:16:17,920 --> 00:16:19,680
in the context of secret sharing and

459
00:16:19,680 --> 00:16:21,759
they're very useful because we can use

460
00:16:21,759 --> 00:16:24,639
them for for example

461
00:16:24,639 --> 00:16:26,480
reducing the amount of communication

462
00:16:26,480 --> 00:16:29,360
distributed storage applications

463
00:16:29,360 --> 00:16:30,560
and things like that where secret

464
00:16:30,560 --> 00:16:32,240
sharing is used in a

465
00:16:32,240 --> 00:16:34,560
somehow static manner but when you want

466
00:16:34,560 --> 00:16:36,399
to have some computation over secrecy

467
00:16:36,399 --> 00:16:38,079
values just like the task we have at

468
00:16:38,079 --> 00:16:39,040
hand

469
00:16:39,040 --> 00:16:41,360
which is secure multiplication

470
00:16:41,360 --> 00:16:43,839
it is not clear how to

471
00:16:43,839 --> 00:16:45,759
use regenerating codes for anything and

472
00:16:45,759 --> 00:16:47,759
i would like to highlight why this is

473
00:16:47,759 --> 00:16:49,279
the case what is the challenging thing

474
00:16:49,279 --> 00:16:51,199
because they look very useful

475
00:16:51,199 --> 00:16:52,480
so

476
00:16:52,480 --> 00:16:54,959
so let's begin by i mean i don't know

477
00:16:54,959 --> 00:16:56,880
brainstorming a bit and mentioning how

478
00:16:56,880 --> 00:16:59,839
they could be useful in principle so

479
00:16:59,839 --> 00:17:02,639
how could they be useful

480
00:17:02,639 --> 00:17:04,799
the main problem they have i mean they

481
00:17:04,799 --> 00:17:06,480
can be useful for mpc of course by by

482
00:17:06,480 --> 00:17:08,319
helping you reconstruct values right so

483
00:17:08,319 --> 00:17:11,199
so for example in the context of

484
00:17:11,199 --> 00:17:13,039
in the context of

485
00:17:13,039 --> 00:17:16,839
the dn07 protocol we saw that one of the

486
00:17:16,839 --> 00:17:19,359
main steps that need to be carried out

487
00:17:19,359 --> 00:17:20,559
in this protocol which i'm going to

488
00:17:20,559 --> 00:17:22,160
mention here again so one of the main

489
00:17:22,160 --> 00:17:23,520
steps that we need to carry out here is

490
00:17:23,520 --> 00:17:25,919
that each party pi will send the share

491
00:17:25,919 --> 00:17:28,880
ei to p1 so maybe one of the thoughts

492
00:17:28,880 --> 00:17:31,360
could be well why not using regenerating

493
00:17:31,360 --> 00:17:33,919
codes here so that this share goes in a

494
00:17:33,919 --> 00:17:36,320
reduced form or like compressed form to

495
00:17:36,320 --> 00:17:38,160
p1 so p1 needs to

496
00:17:38,160 --> 00:17:39,600
receive less data

497
00:17:39,600 --> 00:17:42,240
this sounds promising but then one of

498
00:17:42,240 --> 00:17:46,400
the problems with this approach

499
00:17:46,400 --> 00:17:49,120
is that um

500
00:17:49,120 --> 00:17:51,120
this computation requires using

501
00:17:51,120 --> 00:17:53,440
regenerating codes requires us to go to

502
00:17:53,440 --> 00:17:54,320
a

503
00:17:54,320 --> 00:17:57,120
to a larger field a field the an

504
00:17:57,120 --> 00:17:59,440
extension field that has roughly

505
00:17:59,440 --> 00:18:02,000
an extension degree of log n where n is

506
00:18:02,000 --> 00:18:04,080
the number of parties and in

507
00:18:04,080 --> 00:18:06,559
computations in concrete context we want

508
00:18:06,559 --> 00:18:08,559
to operate sure maybe over a finite

509
00:18:08,559 --> 00:18:11,280
field but of constant degree

510
00:18:11,280 --> 00:18:13,760
we don't constant size we don't want to

511
00:18:13,760 --> 00:18:16,160
have a degree or a like uh like a

512
00:18:16,160 --> 00:18:17,520
structure that grows with the number of

513
00:18:17,520 --> 00:18:18,559
parties

514
00:18:18,559 --> 00:18:20,000
because typically your application is

515
00:18:20,000 --> 00:18:21,520
fixed and then you want more parties on

516
00:18:21,520 --> 00:18:23,120
top it's not like you decide your

517
00:18:23,120 --> 00:18:24,320
application based on the number of

518
00:18:24,320 --> 00:18:25,600
parties so

519
00:18:25,600 --> 00:18:28,240
so this is one of the main dropbox of a

520
00:18:28,240 --> 00:18:29,200
um

521
00:18:29,200 --> 00:18:31,280
regenerating codes that they they simply

522
00:18:31,280 --> 00:18:33,919
don't work over a constant size field

523
00:18:33,919 --> 00:18:35,760
they really require you to go to a to an

524
00:18:35,760 --> 00:18:37,200
extension field that is that grows with

525
00:18:37,200 --> 00:18:40,000
the number of parties but then but then

526
00:18:40,000 --> 00:18:42,320
they're still useful because a solution

527
00:18:42,320 --> 00:18:44,240
for this is that

528
00:18:44,240 --> 00:18:45,760
well maybe you want your computation to

529
00:18:45,760 --> 00:18:47,440
be over fp

530
00:18:47,440 --> 00:18:49,840
z which is a constant size field

531
00:18:49,840 --> 00:18:53,360
you can embed this structure into fpm

532
00:18:53,360 --> 00:18:54,480
which is the one you can use

533
00:18:54,480 --> 00:18:56,799
regenerating codes over

534
00:18:56,799 --> 00:18:58,480
uh oh well and you use regenerating

535
00:18:58,480 --> 00:19:01,520
codes here to

536
00:19:01,520 --> 00:19:03,919
avoid the overhead name so basically

537
00:19:03,919 --> 00:19:07,039
it's like you do mpc here

538
00:19:07,039 --> 00:19:10,559
but your application is over here so

539
00:19:10,559 --> 00:19:12,640
you use the regenerating codes so that

540
00:19:12,640 --> 00:19:13,919
every time that you are supposed to

541
00:19:13,919 --> 00:19:16,160
reconstruct something here instead of

542
00:19:16,160 --> 00:19:18,080
sending a weak element you send a

543
00:19:18,080 --> 00:19:20,240
smaller element in the in the smaller

544
00:19:20,240 --> 00:19:22,320
ring in the smaller field

545
00:19:22,320 --> 00:19:24,880
and it's true regenerating codes can

546
00:19:24,880 --> 00:19:27,039
help in that direction

547
00:19:27,039 --> 00:19:28,080
but then

548
00:19:28,080 --> 00:19:30,640
i mean the the issue is that we

549
00:19:30,640 --> 00:19:32,720
already know how to solve this

550
00:19:32,720 --> 00:19:34,960
without going to regenerating codes and

551
00:19:34,960 --> 00:19:37,039
i want to show it very slightly here

552
00:19:37,039 --> 00:19:39,120
like very very simple

553
00:19:39,120 --> 00:19:41,120
how is that you can do it so this issue

554
00:19:41,120 --> 00:19:43,039
can be already avoided without the need

555
00:19:43,039 --> 00:19:45,440
of regenerating codes what the issue on

556
00:19:45,440 --> 00:19:46,799
one shotgun again

557
00:19:46,799 --> 00:19:48,799
i want to stress it is there is

558
00:19:48,799 --> 00:19:51,440
if you do an npc over fp to the m

559
00:19:51,440 --> 00:19:53,440
how do you

560
00:19:53,440 --> 00:19:56,240
sort of avoid the overhead in terms of m

561
00:19:56,240 --> 00:19:58,080
if you want to compete over a fixed size

562
00:19:58,080 --> 00:19:59,120
field

563
00:19:59,120 --> 00:20:00,720
so this can be already avoided and to

564
00:20:00,720 --> 00:20:03,760
give you an idea is that

565
00:20:03,760 --> 00:20:05,440
we can also use a different type of

566
00:20:05,440 --> 00:20:07,520
reconstruction functions that are like

567
00:20:07,520 --> 00:20:10,400
compressing functions that still allows

568
00:20:10,400 --> 00:20:13,919
a party to retrieve a

569
00:20:13,919 --> 00:20:15,520
the secret which is assumed to be in the

570
00:20:15,520 --> 00:20:16,799
subfield

571
00:20:16,799 --> 00:20:19,120
without the need of

572
00:20:19,120 --> 00:20:20,480
using regenerating codes and these

573
00:20:20,480 --> 00:20:22,080
compression functions can be given by

574
00:20:22,080 --> 00:20:23,360
this for example

575
00:20:23,360 --> 00:20:24,960
so

576
00:20:24,960 --> 00:20:27,360
the compression function

577
00:20:27,360 --> 00:20:30,799
rho i can be given by the projection

578
00:20:30,799 --> 00:20:32,799
into the small field

579
00:20:32,799 --> 00:20:37,200
of the appropriate lagrange coefficient

580
00:20:37,200 --> 00:20:40,080
multiplied by by the input so basically

581
00:20:40,080 --> 00:20:42,559
what this is doing is that every party

582
00:20:42,559 --> 00:20:44,799
is locally multiplying the lagrange

583
00:20:44,799 --> 00:20:46,320
coefficient corresponding to its own

584
00:20:46,320 --> 00:20:47,280
share

585
00:20:47,280 --> 00:20:49,280
but then instead of sending this whole

586
00:20:49,280 --> 00:20:52,480
big field element they are just sending

587
00:20:52,480 --> 00:20:55,200
the let's say the the first coordinate

588
00:20:55,200 --> 00:20:56,559
which is the one corresponding to the

589
00:20:56,559 --> 00:20:58,080
small field

590
00:20:58,080 --> 00:20:59,520
corresponding to the

591
00:20:59,520 --> 00:21:01,600
to the domain you're competing over

592
00:21:01,600 --> 00:21:03,120
so

593
00:21:03,120 --> 00:21:04,880
you can check that if you sum all these

594
00:21:04,880 --> 00:21:06,159
values

595
00:21:06,159 --> 00:21:07,919
then this is the same as projecting over

596
00:21:07,919 --> 00:21:10,880
the sum of these guys and this guy here

597
00:21:10,880 --> 00:21:12,880
inside because of samir secret sharing

598
00:21:12,880 --> 00:21:14,799
is just the secret and this is the main

599
00:21:14,799 --> 00:21:15,679
trick

600
00:21:15,679 --> 00:21:17,760
the the trick is that

601
00:21:17,760 --> 00:21:19,280
your secret

602
00:21:19,280 --> 00:21:22,000
sure it belongs to the big field

603
00:21:22,000 --> 00:21:24,320
but more than that it belongs to the

604
00:21:24,320 --> 00:21:26,000
small field

605
00:21:26,000 --> 00:21:27,919
because we chose it to be like that the

606
00:21:27,919 --> 00:21:30,000
secrets are even though the computation

607
00:21:30,000 --> 00:21:31,679
could happen in principle over the big

608
00:21:31,679 --> 00:21:33,280
field it's actually happening over the

609
00:21:33,280 --> 00:21:35,440
small field so so it means that

610
00:21:35,440 --> 00:21:37,280
projecting is into the first chord and

611
00:21:37,280 --> 00:21:38,960
it gives you the same s

612
00:21:38,960 --> 00:21:41,600
and this is like why this trick works

613
00:21:41,600 --> 00:21:42,880
it's because

614
00:21:42,880 --> 00:21:44,880
this element could be very this element

615
00:21:44,880 --> 00:21:46,880
here could be very large

616
00:21:46,880 --> 00:21:49,440
but it's actually very small it's just a

617
00:21:49,440 --> 00:21:51,360
one coordinate so

618
00:21:51,360 --> 00:21:52,960
we could already have solved this

619
00:21:52,960 --> 00:21:54,799
problem as i mentioned without the help

620
00:21:54,799 --> 00:21:56,400
of regenerating codes

621
00:21:56,400 --> 00:21:58,799
which is is a shame because we wanted to

622
00:21:58,799 --> 00:22:00,080
to apply them

623
00:22:00,080 --> 00:22:02,960
and the main observation

624
00:22:02,960 --> 00:22:04,080
is that

625
00:22:04,080 --> 00:22:05,760
we can actually use them

626
00:22:05,760 --> 00:22:07,919
because

627
00:22:07,919 --> 00:22:09,520
unlike the previous compressing

628
00:22:09,520 --> 00:22:11,679
functions that i mentioned regenerating

629
00:22:11,679 --> 00:22:13,919
codes enable the reconstruction of the

630
00:22:13,919 --> 00:22:16,480
full s

631
00:22:16,480 --> 00:22:17,760
instead of reconstructing just the

632
00:22:17,760 --> 00:22:19,440
projection so here you can see that

633
00:22:19,440 --> 00:22:21,760
we've reconstructed the projection

634
00:22:21,760 --> 00:22:23,280
and the projection happens to coincide

635
00:22:23,280 --> 00:22:25,600
with s because s belongs to the small

636
00:22:25,600 --> 00:22:26,400
field

637
00:22:26,400 --> 00:22:27,200
but

638
00:22:27,200 --> 00:22:28,400
what if

639
00:22:28,400 --> 00:22:30,640
we take s to belong to this to the big

640
00:22:30,640 --> 00:22:31,840
field

641
00:22:31,840 --> 00:22:35,120
so now suddenly these regenerating codes

642
00:22:35,120 --> 00:22:39,120
enable the reconstruction not of p of s

643
00:22:39,120 --> 00:22:42,080
which is is an element of of

644
00:22:42,080 --> 00:22:44,240
the small field and may lose a lot of

645
00:22:44,240 --> 00:22:46,320
information it will actually enable the

646
00:22:46,320 --> 00:22:49,440
reconstruction of the whole s

647
00:22:49,440 --> 00:22:51,919
which is is is a much bigger element it

648
00:22:51,919 --> 00:22:54,720
has like a factor of m over c

649
00:22:54,720 --> 00:22:56,240
size a bigger

650
00:22:56,240 --> 00:22:57,039
so

651
00:22:57,039 --> 00:22:58,320
this is the observation that

652
00:22:58,320 --> 00:23:00,320
regenerating codes can be useful for is

653
00:23:00,320 --> 00:23:02,159
that they enable us to reconstruct big

654
00:23:02,159 --> 00:23:04,240
elements with little communication not

655
00:23:04,240 --> 00:23:07,200
only small elements

656
00:23:07,440 --> 00:23:08,720
so

657
00:23:08,720 --> 00:23:11,200
we basically use regenerating codes to

658
00:23:11,200 --> 00:23:13,679
optimize secure multiplication over this

659
00:23:13,679 --> 00:23:15,919
extension ring

660
00:23:15,919 --> 00:23:18,799
so now we get like fast multiplication

661
00:23:18,799 --> 00:23:21,039
but over this big ring but again this is

662
00:23:21,039 --> 00:23:22,799
a problem because this big ring is not

663
00:23:22,799 --> 00:23:24,320
very interesting because we're

664
00:23:24,320 --> 00:23:25,919
interested in computation over constant

665
00:23:25,919 --> 00:23:27,039
size ring

666
00:23:27,039 --> 00:23:29,760
but it well it turns out that because f

667
00:23:29,760 --> 00:23:32,559
q to the m is essentially as as vector

668
00:23:32,559 --> 00:23:36,480
space is the same as m as m copies of f

669
00:23:36,480 --> 00:23:38,000
q

670
00:23:38,000 --> 00:23:40,240
with the help of a very interesting tool

671
00:23:40,240 --> 00:23:41,760
called reverse multiplication friendly

672
00:23:41,760 --> 00:23:44,320
embeddings we can actually turn these

673
00:23:44,320 --> 00:23:46,240
multiplication protocol over extension

674
00:23:46,240 --> 00:23:47,279
fields

675
00:23:47,279 --> 00:23:48,320
into

676
00:23:48,320 --> 00:23:51,679
a protocol to multiply essentially m

677
00:23:51,679 --> 00:23:53,600
copies of the same

678
00:23:53,600 --> 00:23:57,679
multiplications over the small field

679
00:23:57,679 --> 00:23:59,520
so this is very very very interesting

680
00:23:59,520 --> 00:24:01,039
because at the end of the day it shows

681
00:24:01,039 --> 00:24:03,279
that sure you can use

682
00:24:03,279 --> 00:24:04,480
you obtain multiplication

683
00:24:04,480 --> 00:24:06,320
over here with the help of regenerating

684
00:24:06,320 --> 00:24:07,919
codes

685
00:24:07,919 --> 00:24:10,000
and that's not very useful on its own

686
00:24:10,000 --> 00:24:12,320
unless by using these rmfs we can turn

687
00:24:12,320 --> 00:24:13,840
it into several multiplications of

688
00:24:13,840 --> 00:24:15,039
graphq

689
00:24:15,039 --> 00:24:17,200
and this is indeed what we do so this is

690
00:24:17,200 --> 00:24:18,880
the main result in terms of npc we

691
00:24:18,880 --> 00:24:20,640
obtain a lot of multiplications each one

692
00:24:20,640 --> 00:24:22,480
of them having less than n square

693
00:24:22,480 --> 00:24:25,360
multiple communication

694
00:24:25,360 --> 00:24:26,320
and

695
00:24:26,320 --> 00:24:28,240
taking exactly one round and this is

696
00:24:28,240 --> 00:24:30,480
with the help of regenerating codes i

697
00:24:30,480 --> 00:24:32,960
want to emphasize that if you don't care

698
00:24:32,960 --> 00:24:34,159
about

699
00:24:34,159 --> 00:24:36,240
if you didn't care about reconstructing

700
00:24:36,240 --> 00:24:38,320
the whole value you could follow this

701
00:24:38,320 --> 00:24:39,279
approach

702
00:24:39,279 --> 00:24:42,159
back here which is very interesting but

703
00:24:42,159 --> 00:24:43,360
and it doesn't have the overhead in

704
00:24:43,360 --> 00:24:45,440
terms of m but the communication

705
00:24:45,440 --> 00:24:47,840
complexity will be still in square in

706
00:24:47,840 --> 00:24:49,120
terms of the size of the thing you're

707
00:24:49,120 --> 00:24:51,520
reconstructing so it's it's not

708
00:24:51,520 --> 00:24:54,720
useful for our problem

709
00:24:58,559 --> 00:24:59,840
so what are the challenges that we face

710
00:24:59,840 --> 00:25:01,039
in this work

711
00:25:01,039 --> 00:25:02,720
um

712
00:25:02,720 --> 00:25:04,880
there are the the main challenge is that

713
00:25:04,880 --> 00:25:07,279
we want to keep the number of rounds

714
00:25:07,279 --> 00:25:09,039
they bounded by one let's say exactly

715
00:25:09,039 --> 00:25:10,480
equal to one

716
00:25:10,480 --> 00:25:12,720
and there are several issues with this

717
00:25:12,720 --> 00:25:16,400
one is that the use of rmfes

718
00:25:16,400 --> 00:25:19,200
as traditionally used will introduce an

719
00:25:19,200 --> 00:25:21,840
additional round to do something called

720
00:25:21,840 --> 00:25:24,159
ring coding and this is very bad for us

721
00:25:24,159 --> 00:25:25,440
because we really don't want to have

722
00:25:25,440 --> 00:25:26,960
this overhead we want to stick to one

723
00:25:26,960 --> 00:25:28,880
single round

724
00:25:28,880 --> 00:25:30,640
so to address this we will introduce a

725
00:25:30,640 --> 00:25:32,400
novel encoding method that removes the

726
00:25:32,400 --> 00:25:34,320
need of having an extra round and this

727
00:25:34,320 --> 00:25:36,159
is of independent interest because it

728
00:25:36,159 --> 00:25:37,760
also applies to previous works that have

729
00:25:37,760 --> 00:25:40,720
used rmfes

730
00:25:41,200 --> 00:25:43,200
the second challenge is that

731
00:25:43,200 --> 00:25:45,039
in terms of active security you need to

732
00:25:45,039 --> 00:25:46,000
ensure

733
00:25:46,000 --> 00:25:47,440
you need to do some broadcasting every

734
00:25:47,440 --> 00:25:48,880
single round

735
00:25:48,880 --> 00:25:50,720
and

736
00:25:50,720 --> 00:25:52,240
well if you want to avoid doing

737
00:25:52,240 --> 00:25:53,600
broadcasting every single round you can

738
00:25:53,600 --> 00:25:55,200
always just check that all the values

739
00:25:55,200 --> 00:25:57,120
broadcasters were correct at the end of

740
00:25:57,120 --> 00:26:00,240
the protocol but then sometimes

741
00:26:00,240 --> 00:26:02,000
and we showed that if we do the things

742
00:26:02,000 --> 00:26:03,279
naively then this will be the case

743
00:26:03,279 --> 00:26:05,120
sometimes this will introduce some

744
00:26:05,120 --> 00:26:06,480
attack vectors

745
00:26:06,480 --> 00:26:10,080
so to avoid this we make a oval use of

746
00:26:10,080 --> 00:26:12,960
function dependent preprocessing

747
00:26:12,960 --> 00:26:14,960
and we show that this will alleviate

748
00:26:14,960 --> 00:26:16,080
this issue

749
00:26:16,080 --> 00:26:17,840
this is an oval use of this type of

750
00:26:17,840 --> 00:26:19,200
pre-processing it has been used in the

751
00:26:19,200 --> 00:26:21,760
literature before for

752
00:26:21,760 --> 00:26:24,880
optimizing the communication count so

753
00:26:24,880 --> 00:26:26,480
dividing by two essentially the amount

754
00:26:26,480 --> 00:26:27,760
of elements sent

755
00:26:27,760 --> 00:26:28,070
but

756
00:26:28,070 --> 00:26:29,520
[Music]

757
00:26:29,520 --> 00:26:31,840
but the idea is that here we can also

758
00:26:31,840 --> 00:26:34,159
not use it we can also use it not only

759
00:26:34,159 --> 00:26:35,200
for

760
00:26:35,200 --> 00:26:36,880
efficiency purposes but also for

761
00:26:36,880 --> 00:26:39,840
security purposes

762
00:26:40,159 --> 00:26:42,400
and finally we also have like a

763
00:26:42,400 --> 00:26:44,320
some notable contributions to the theory

764
00:26:44,320 --> 00:26:46,320
of regenerating codes

765
00:26:46,320 --> 00:26:48,159
in particular we provide a new

766
00:26:48,159 --> 00:26:49,840
characterization of

767
00:26:49,840 --> 00:26:51,760
what are regenerating code

768
00:26:51,760 --> 00:26:54,159
like when is a code regenerating

769
00:26:54,159 --> 00:26:55,200
basically

770
00:26:55,200 --> 00:26:56,559
in terms of certain properties of its

771
00:26:56,559 --> 00:26:58,159
dual so that's like the first

772
00:26:58,159 --> 00:27:00,480
interesting result but then

773
00:27:00,480 --> 00:27:02,400
also very interestingly we generalize

774
00:27:02,400 --> 00:27:04,240
all this theory that exists already for

775
00:27:04,240 --> 00:27:05,600
the case of

776
00:27:05,600 --> 00:27:07,520
finance fields and we generalize it to

777
00:27:07,520 --> 00:27:10,000
something called galorings which are a

778
00:27:10,000 --> 00:27:12,159
generalization of integers modulated

779
00:27:12,159 --> 00:27:13,679
decay

780
00:27:13,679 --> 00:27:14,960
in particular as i mentioned because

781
00:27:14,960 --> 00:27:18,000
it's a generalization of these rings

782
00:27:18,000 --> 00:27:19,440
these type of links already include that

783
00:27:19,440 --> 00:27:20,720
case which is very interesting in

784
00:27:20,720 --> 00:27:22,640
practice because it is computational

785
00:27:22,640 --> 00:27:25,039
model for example 2 to the 64 or 2 to

786
00:27:25,039 --> 00:27:28,720
the 128 which is more compatible with

787
00:27:28,720 --> 00:27:31,919
modern hardware

788
00:27:31,919 --> 00:27:33,840
so these are contributions in terms of

789
00:27:33,840 --> 00:27:35,679
the theory of generating codes

790
00:27:35,679 --> 00:27:37,679
now in what follows i want to give you

791
00:27:37,679 --> 00:27:40,640
an idea about how is that

792
00:27:40,640 --> 00:27:42,720
we get our results

793
00:27:42,720 --> 00:27:45,039
so first i'm going to

794
00:27:45,039 --> 00:27:46,799
go over the definition of regenerating

795
00:27:46,799 --> 00:27:48,720
codes over galway rings

796
00:27:48,720 --> 00:27:49,440
so

797
00:27:49,440 --> 00:27:51,360
we're going to consider

798
00:27:51,360 --> 00:27:53,279
throughout the the rest of the talk two

799
00:27:53,279 --> 00:27:54,720
gallery rings

800
00:27:54,720 --> 00:27:55,760
so

801
00:27:55,760 --> 00:27:59,600
s is going to be a lowering of a

802
00:27:59,600 --> 00:28:01,200
integers modulo an extension ring of the

803
00:28:01,200 --> 00:28:03,760
integers model of p to the k of degree l

804
00:28:03,760 --> 00:28:06,559
this is the degree and the second one r

805
00:28:06,559 --> 00:28:07,919
is going to be a coloring goes with the

806
00:28:07,919 --> 00:28:10,080
same base ring but now it's going to

807
00:28:10,080 --> 00:28:12,480
have a degree extension m times l which

808
00:28:12,480 --> 00:28:14,799
means that r can be seen as an extension

809
00:28:14,799 --> 00:28:17,840
of s of degree the extra factor here

810
00:28:17,840 --> 00:28:20,559
sort of the extra factor here which is m

811
00:28:20,559 --> 00:28:22,720
so a gallon ring is you if you're not

812
00:28:22,720 --> 00:28:24,640
familiar with it it's just polynomials

813
00:28:24,640 --> 00:28:26,320
over this base ring

814
00:28:26,320 --> 00:28:29,440
integers modulo p to the k being a

815
00:28:29,440 --> 00:28:31,840
is just like polynomials but you take

816
00:28:31,840 --> 00:28:33,760
model of some irreducible polynomial of

817
00:28:33,760 --> 00:28:37,279
degree l it's literally the same

818
00:28:37,279 --> 00:28:39,679
if k is equal to one this literally

819
00:28:39,679 --> 00:28:41,200
boils down to

820
00:28:41,200 --> 00:28:42,559
f

821
00:28:42,559 --> 00:28:46,080
b to the dl or the golova field with ptl

822
00:28:46,080 --> 00:28:47,039
elements

823
00:28:47,039 --> 00:28:49,840
so it's a generalization of that for k

824
00:28:49,840 --> 00:28:51,360
greater than one

825
00:28:51,360 --> 00:28:53,440
it's in general that's not a field but

826
00:28:53,440 --> 00:28:55,279
it's still a local ring that has very

827
00:28:55,279 --> 00:28:57,600
nice properties

828
00:28:57,600 --> 00:29:00,880
and and we start by taking a c to be

829
00:29:00,880 --> 00:29:03,919
an r sub module of r to the n plus one

830
00:29:03,919 --> 00:29:05,760
that is literally

831
00:29:05,760 --> 00:29:08,320
another way of describing a secret

832
00:29:08,320 --> 00:29:10,559
sharing scheme elements in c are just

833
00:29:10,559 --> 00:29:13,600
vectors with n plus one entries the

834
00:29:13,600 --> 00:29:15,840
first one will act as the secret and the

835
00:29:15,840 --> 00:29:18,159
other ones will act as the shears so

836
00:29:18,159 --> 00:29:19,440
this is just an alternative way of

837
00:29:19,440 --> 00:29:20,960
describing a secret sharing scheme it's

838
00:29:20,960 --> 00:29:22,559
very well known that there is a duality

839
00:29:22,559 --> 00:29:25,679
or like a relation between a codes and

840
00:29:25,679 --> 00:29:28,480
linear secretion schemes

841
00:29:28,480 --> 00:29:30,720
so let's begin by defining what this

842
00:29:30,720 --> 00:29:32,399
regenerating property has been mentioned

843
00:29:32,399 --> 00:29:36,159
in all this time a consists of so

844
00:29:36,159 --> 00:29:38,240
c which can be seen as a sequestering

845
00:29:38,240 --> 00:29:40,960
scheme or as a code has linear repair

846
00:29:40,960 --> 00:29:42,080
over s

847
00:29:42,080 --> 00:29:43,760
if

848
00:29:43,760 --> 00:29:45,279
if there exists

849
00:29:45,279 --> 00:29:47,039
s linear maps

850
00:29:47,039 --> 00:29:49,840
fee of i that map from the big ring to

851
00:29:49,840 --> 00:29:52,320
the small ring and also some scalars in

852
00:29:52,320 --> 00:29:53,520
the big ring

853
00:29:53,520 --> 00:29:56,000
such that whenever you have a

854
00:29:56,000 --> 00:29:56,880
big

855
00:29:56,880 --> 00:29:58,799
vector

856
00:29:58,799 --> 00:30:00,080
in the

857
00:30:00,080 --> 00:30:03,919
in the galwa ring sorry in the code

858
00:30:03,919 --> 00:30:06,320
then you can essentially reconstruct the

859
00:30:06,320 --> 00:30:08,559
first coordinate of this vector by

860
00:30:08,559 --> 00:30:10,000
taking

861
00:30:10,000 --> 00:30:14,240
a linear combination with the scalars zi

862
00:30:14,240 --> 00:30:15,039
of

863
00:30:15,039 --> 00:30:16,880
the compressed

864
00:30:16,880 --> 00:30:18,960
a coordinates the other coordinates of

865
00:30:18,960 --> 00:30:22,159
the vector so so the vector is x0 x1 up

866
00:30:22,159 --> 00:30:24,559
to xn and we can essentially reconstruct

867
00:30:24,559 --> 00:30:26,880
x0 by taking a linear combination of the

868
00:30:26,880 --> 00:30:29,760
other coordinates but without

869
00:30:29,760 --> 00:30:31,520
taking the full coordinates but actually

870
00:30:31,520 --> 00:30:32,720
some compressed version of those

871
00:30:32,720 --> 00:30:35,120
coordinates we see that this value here

872
00:30:35,120 --> 00:30:37,600
belongs to r but these values here they

873
00:30:37,600 --> 00:30:40,640
all belong to so they're smaller than r

874
00:30:40,640 --> 00:30:42,240
so this is our generating code with

875
00:30:42,240 --> 00:30:43,840
linear repair

876
00:30:43,840 --> 00:30:45,440
in the first coordinate it's called

877
00:30:45,440 --> 00:30:47,840
repairable code but also regenerating i

878
00:30:47,840 --> 00:30:49,679
use the two terms indistinguishably

879
00:30:49,679 --> 00:30:52,320
during this talk

880
00:30:54,640 --> 00:30:57,519
so one of our results will actually show

881
00:30:57,519 --> 00:30:59,440
that there exists a repairing or

882
00:30:59,440 --> 00:31:01,519
regenerating code

883
00:31:01,519 --> 00:31:03,840
of r over s and is based essentially on

884
00:31:03,840 --> 00:31:05,760
chemistry sharing so it's essentially is

885
00:31:05,760 --> 00:31:09,200
literally shaming secret sharing

886
00:31:10,159 --> 00:31:12,640
assuming that certain inequality holds

887
00:31:12,640 --> 00:31:15,039
in terms of l and m so basically what

888
00:31:15,039 --> 00:31:18,000
this is saying is that l is going to be

889
00:31:18,000 --> 00:31:20,320
constant because it's just the the

890
00:31:20,320 --> 00:31:22,559
the base string over which one over

891
00:31:22,559 --> 00:31:24,880
which we wanted to have the computation

892
00:31:24,880 --> 00:31:27,919
and m here after we apply this

893
00:31:27,919 --> 00:31:30,080
inequality basically it turns out that m

894
00:31:30,080 --> 00:31:33,760
is going to be something like log n

895
00:31:33,760 --> 00:31:37,279
so think of m as as something m remember

896
00:31:37,279 --> 00:31:39,120
is the degree extension of

897
00:31:39,120 --> 00:31:40,960
r over s

898
00:31:40,960 --> 00:31:43,519
so r is essentially

899
00:31:43,519 --> 00:31:45,360
m copies of s

900
00:31:45,360 --> 00:31:46,880
as modules

901
00:31:46,880 --> 00:31:48,080
and

902
00:31:48,080 --> 00:31:51,039
m is going to be size roughly log n

903
00:31:51,039 --> 00:31:53,279
and again because it's a code we can

904
00:31:53,279 --> 00:31:56,159
naturally use this as a secretion scheme

905
00:31:56,159 --> 00:31:57,919
and the regenerating or the repairing

906
00:31:57,919 --> 00:32:00,880
property will be used to simplify and

907
00:32:00,880 --> 00:32:02,960
make a more efficient the reconstruction

908
00:32:02,960 --> 00:32:06,159
of a given secret

909
00:32:08,320 --> 00:32:09,919
this is exactly what i just mentioned so

910
00:32:09,919 --> 00:32:11,919
so the repairing property

911
00:32:11,919 --> 00:32:13,120
enables

912
00:32:13,120 --> 00:32:14,480
a very efficient one-round

913
00:32:14,480 --> 00:32:16,480
reconstruction if you have a shared

914
00:32:16,480 --> 00:32:17,519
secret

915
00:32:17,519 --> 00:32:20,159
then each party pi will send the

916
00:32:20,159 --> 00:32:22,480
compressed version of its own share to

917
00:32:22,480 --> 00:32:24,000
all the parties remember that this is in

918
00:32:24,000 --> 00:32:27,600
the small ring and not in the big ring

919
00:32:27,600 --> 00:32:28,399
and then

920
00:32:28,399 --> 00:32:30,399
the parties will compute this linear

921
00:32:30,399 --> 00:32:33,200
combination which is the one that we

922
00:32:33,200 --> 00:32:35,360
have from from before so

923
00:32:35,360 --> 00:32:36,799
because of the properties of our pairing

924
00:32:36,799 --> 00:32:39,200
code this linear combination here will

925
00:32:39,200 --> 00:32:40,159
give you

926
00:32:40,159 --> 00:32:43,600
the secret back i insist this belongs to

927
00:32:43,600 --> 00:32:46,720
r this belongs to r but this belongs to

928
00:32:46,720 --> 00:32:48,799
us

929
00:32:50,480 --> 00:32:51,679
so this is

930
00:32:51,679 --> 00:32:53,120
one of the main results we obtained like

931
00:32:53,120 --> 00:32:55,360
you can get such a such a

932
00:32:55,360 --> 00:32:57,440
type of regenerating property from some

933
00:32:57,440 --> 00:32:59,120
researchers saying over galwa rings it

934
00:32:59,120 --> 00:33:00,559
was already known that you can get it

935
00:33:00,559 --> 00:33:01,360
for

936
00:33:01,360 --> 00:33:03,440
a fields but now we also can get it over

937
00:33:03,440 --> 00:33:04,799
the larynx

938
00:33:04,799 --> 00:33:07,760
and how do we use them so i want to

939
00:33:07,760 --> 00:33:10,000
guide you through our protocol about how

940
00:33:10,000 --> 00:33:12,399
is that you can use regenerating codes

941
00:33:12,399 --> 00:33:14,640
to obtain multiplication in one single

942
00:33:14,640 --> 00:33:16,960
round

943
00:33:16,960 --> 00:33:19,760
so let's begin by reviewing

944
00:33:19,760 --> 00:33:21,519
what bieber-based multiplication or

945
00:33:21,519 --> 00:33:23,120
triple based multiplication is this is

946
00:33:23,120 --> 00:33:25,120
this the the standard protocol that we

947
00:33:25,120 --> 00:33:26,720
typically use when we want to multiply

948
00:33:26,720 --> 00:33:28,000
two values

949
00:33:28,000 --> 00:33:28,799
so

950
00:33:28,799 --> 00:33:30,880
given two share values we want to

951
00:33:30,880 --> 00:33:32,399
compute the product

952
00:33:32,399 --> 00:33:34,399
so it happens in three stages the first

953
00:33:34,399 --> 00:33:36,000
one is just pre-processing so i call it

954
00:33:36,000 --> 00:33:38,480
the phase zero where the parties compute

955
00:33:38,480 --> 00:33:41,679
a triple a b and c where c is supposed

956
00:33:41,679 --> 00:33:43,600
to be the the products of a and b and

957
00:33:43,600 --> 00:33:46,559
and a and b are random

958
00:33:46,559 --> 00:33:48,559
in the first actual step in the first

959
00:33:48,559 --> 00:33:50,240
interaction the parties will reconstruct

960
00:33:50,240 --> 00:33:51,760
the difference between x the actual

961
00:33:51,760 --> 00:33:54,399
input they want to compute over and a

962
00:33:54,399 --> 00:33:56,000
the value from the pre-processing and

963
00:33:56,000 --> 00:33:57,519
they reconstruct this value which leaks

964
00:33:57,519 --> 00:33:59,440
nothing because a is random

965
00:33:59,440 --> 00:34:01,039
and

966
00:34:01,039 --> 00:34:02,880
in this reconstruction it happens in one

967
00:34:02,880 --> 00:34:04,240
round

968
00:34:04,240 --> 00:34:05,919
because we use this for construction

969
00:34:05,919 --> 00:34:08,079
with where everybody just announced

970
00:34:08,079 --> 00:34:10,000
their share to everybody actually their

971
00:34:10,000 --> 00:34:11,280
compressor

972
00:34:11,280 --> 00:34:13,599
similarly the part is open e which is

973
00:34:13,599 --> 00:34:16,320
the difference between y and b

974
00:34:16,320 --> 00:34:18,239
then in the final step the part is

975
00:34:18,239 --> 00:34:19,760
compute locally

976
00:34:19,760 --> 00:34:21,760
this linear combination here on the

977
00:34:21,760 --> 00:34:23,679
right which you can check very easily it

978
00:34:23,679 --> 00:34:26,399
actually leads to the shares of x and y

979
00:34:26,399 --> 00:34:28,560
so this is a very standard protocol and

980
00:34:28,560 --> 00:34:31,679
here we're going to use a

981
00:34:31,679 --> 00:34:33,679
generating codes so the communication

982
00:34:33,679 --> 00:34:34,800
costs

983
00:34:34,800 --> 00:34:38,320
are the following so

984
00:34:38,480 --> 00:34:40,239
if you if you

985
00:34:40,239 --> 00:34:42,000
com if you take into account how many

986
00:34:42,000 --> 00:34:44,000
elements are being sent here

987
00:34:44,000 --> 00:34:45,440
they send

988
00:34:45,440 --> 00:34:47,520
o of n squared elements

989
00:34:47,520 --> 00:34:49,599
in s which are the compressed shares

990
00:34:49,599 --> 00:34:51,760
right so so normally would be n square

991
00:34:51,760 --> 00:34:53,119
elements of r but because they are

992
00:34:53,119 --> 00:34:55,119
compressing before sending is n squared

993
00:34:55,119 --> 00:34:56,639
elements of s

994
00:34:56,639 --> 00:34:58,640
and when you count that in terms of how

995
00:34:58,640 --> 00:35:00,880
many elements of r they're sending

996
00:35:00,880 --> 00:35:03,839
around because remember r is going to be

997
00:35:03,839 --> 00:35:06,560
the same as m copies of s this is the

998
00:35:06,560 --> 00:35:09,119
same as dividing by m here so so

999
00:35:09,119 --> 00:35:11,920
basically in terms of how many elements

1000
00:35:11,920 --> 00:35:15,119
of r are being sent we get something

1001
00:35:15,119 --> 00:35:17,520
like n squared divided by log n

1002
00:35:17,520 --> 00:35:20,000
which is sub n square

1003
00:35:20,000 --> 00:35:20,800
so

1004
00:35:20,800 --> 00:35:22,560
it's we break the barrier of the

1005
00:35:22,560 --> 00:35:24,480
quadratic communication complexity by a

1006
00:35:24,480 --> 00:35:26,560
login factor which is not very big but

1007
00:35:26,560 --> 00:35:28,000
it really breaks the barrier which is a

1008
00:35:28,000 --> 00:35:30,400
pretty interesting result in terms of

1009
00:35:30,400 --> 00:35:32,560
the of the count of elements overall

1010
00:35:32,560 --> 00:35:34,480
this is fine and this is a very

1011
00:35:34,480 --> 00:35:36,800
interesting result already but the main

1012
00:35:36,800 --> 00:35:39,440
drawback is that as we know as as i

1013
00:35:39,440 --> 00:35:41,599
already mentioned several times

1014
00:35:41,599 --> 00:35:43,040
we are not interested in having

1015
00:35:43,040 --> 00:35:45,440
computation over r we're interested

1016
00:35:45,440 --> 00:35:48,560
interested in having computation over s

1017
00:35:48,560 --> 00:35:50,800
so let's let's continue so so this is

1018
00:35:50,800 --> 00:35:53,280
actually mentioned we want mpc over s

1019
00:35:53,280 --> 00:35:54,960
not over r

1020
00:35:54,960 --> 00:35:58,340
but the intuition that we want to to

1021
00:35:58,340 --> 00:36:00,000
[Music]

1022
00:36:00,000 --> 00:36:02,560
to have is that s will be equivalent to

1023
00:36:02,560 --> 00:36:05,119
many copies of a of r as i mentioned

1024
00:36:05,119 --> 00:36:07,760
before s can be embedded into r the same

1025
00:36:07,760 --> 00:36:10,560
as as in the case of fields fpc as i was

1026
00:36:10,560 --> 00:36:12,400
mentioning

1027
00:36:12,400 --> 00:36:14,320
i was referring to it can be embedded

1028
00:36:14,320 --> 00:36:17,920
into fpm but then all the efficiency

1029
00:36:17,920 --> 00:36:19,760
benefits are lost if we use this because

1030
00:36:19,760 --> 00:36:20,720
at the end of the day we will be

1031
00:36:20,720 --> 00:36:24,720
communicating n square elements of s

1032
00:36:24,720 --> 00:36:26,560
and we want to communicate

1033
00:36:26,560 --> 00:36:28,560
if if this is your domain of

1034
00:36:28,560 --> 00:36:30,400
multiplication then you will essentially

1035
00:36:30,400 --> 00:36:31,680
be operating

1036
00:36:31,680 --> 00:36:34,000
sending n square elements

1037
00:36:34,000 --> 00:36:35,839
of your domain we want to send less than

1038
00:36:35,839 --> 00:36:36,960
that

1039
00:36:36,960 --> 00:36:40,760
so what we do

1040
00:36:41,760 --> 00:36:43,920
is that we identified that this is not a

1041
00:36:43,920 --> 00:36:45,440
new problem actually

1042
00:36:45,440 --> 00:36:49,520
and to illustrate why this is the case

1043
00:36:49,520 --> 00:36:52,320
we take this as an example so

1044
00:36:52,320 --> 00:36:55,280
chemistry sharing as we know it it does

1045
00:36:55,280 --> 00:36:58,640
not work over f2 for example because f2

1046
00:36:58,640 --> 00:37:00,000
is very small it doesn't have enough

1047
00:37:00,000 --> 00:37:02,400
elements to allow for interpolation so

1048
00:37:02,400 --> 00:37:03,920
what people typically do that they take

1049
00:37:03,920 --> 00:37:06,079
a field extension

1050
00:37:06,079 --> 00:37:08,800
a of degree well coincidentally

1051
00:37:08,800 --> 00:37:10,400
also log n

1052
00:37:10,400 --> 00:37:12,880
and now we use this extension instead

1053
00:37:12,880 --> 00:37:18,079
and again we embed f2 into f2 to the m

1054
00:37:18,079 --> 00:37:18,880
now

1055
00:37:18,880 --> 00:37:21,040
at first glance we noticed that this is

1056
00:37:21,040 --> 00:37:22,880
very wasteful once again because we have

1057
00:37:22,880 --> 00:37:24,960
this overhead in m

1058
00:37:24,960 --> 00:37:25,839
so

1059
00:37:25,839 --> 00:37:28,560
there is this very interesting work

1060
00:37:28,560 --> 00:37:31,040
uh cc x y 19. of course could we talk

1061
00:37:31,040 --> 00:37:32,800
about crypto 18

1062
00:37:32,800 --> 00:37:35,200
it yeah it should be 18 here my

1063
00:37:35,200 --> 00:37:36,720
apologies so

1064
00:37:36,720 --> 00:37:38,720
there is this very interesting work

1065
00:37:38,720 --> 00:37:41,359
uh that shows that

1066
00:37:41,359 --> 00:37:44,240
shows the following like intuitively f2

1067
00:37:44,240 --> 00:37:47,040
to the m is the same as

1068
00:37:47,040 --> 00:37:50,160
well m copies of f2 so if we are

1069
00:37:50,160 --> 00:37:52,240
computing over f2 to the m it sounds i

1070
00:37:52,240 --> 00:37:54,320
mean every element here is like a vector

1071
00:37:54,320 --> 00:37:56,560
and it has m entries and before we were

1072
00:37:56,560 --> 00:37:58,320
using only this entry and all the others

1073
00:37:58,320 --> 00:38:01,040
were completely wasted so because we

1074
00:38:01,040 --> 00:38:02,640
have so many

1075
00:38:02,640 --> 00:38:04,400
entries in these long vectors we can

1076
00:38:04,400 --> 00:38:06,160
hope to actually make use of all the

1077
00:38:06,160 --> 00:38:08,079
individual entries to run one

1078
00:38:08,079 --> 00:38:09,839
computation in all of them

1079
00:38:09,839 --> 00:38:12,079
so that's like the intuition the problem

1080
00:38:12,079 --> 00:38:13,839
with this intuition is that even though

1081
00:38:13,839 --> 00:38:16,320
these two

1082
00:38:16,400 --> 00:38:18,560
algebraic structures are isomorphic

1083
00:38:18,560 --> 00:38:21,119
they're isomorphic as vector spaces

1084
00:38:21,119 --> 00:38:23,040
and what we would like to do over this

1085
00:38:23,040 --> 00:38:25,280
space here which are vectors is to

1086
00:38:25,280 --> 00:38:27,680
multiply pointwise right we want we want

1087
00:38:27,680 --> 00:38:29,760
to execute a computation over each

1088
00:38:29,760 --> 00:38:33,119
coordinate so we have to add point wise

1089
00:38:33,119 --> 00:38:35,040
and i think it's easy because vector

1090
00:38:35,040 --> 00:38:37,280
spaces addition are point wise but

1091
00:38:37,280 --> 00:38:39,359
vector spaces don't don't even have a

1092
00:38:39,359 --> 00:38:42,320
multiplication notion so

1093
00:38:42,320 --> 00:38:44,480
this isomorphism here does not help

1094
00:38:44,480 --> 00:38:47,119
towards getting what we want

1095
00:38:47,119 --> 00:38:49,040
but the solution from this work that

1096
00:38:49,040 --> 00:38:50,480
we're citing here

1097
00:38:50,480 --> 00:38:52,240
is that we can use the so-called reverse

1098
00:38:52,240 --> 00:38:54,320
multiplication friendly embeddings which

1099
00:38:54,320 --> 00:38:56,320
are very interesting tools essentially

1100
00:38:56,320 --> 00:38:58,880
is a pair of of

1101
00:38:58,880 --> 00:39:01,280
linear morphisms

1102
00:39:01,280 --> 00:39:02,560
c and v

1103
00:39:02,560 --> 00:39:03,680
such that

1104
00:39:03,680 --> 00:39:07,760
well c maps from f2 to the m to f2 to

1105
00:39:07,760 --> 00:39:10,000
the d and and you can think of m as

1106
00:39:10,000 --> 00:39:11,440
being very close to the

1107
00:39:11,440 --> 00:39:13,440
for for illustration purpose i just

1108
00:39:13,440 --> 00:39:15,119
think it's the same

1109
00:39:15,119 --> 00:39:16,720
although it's not and it cannot be the

1110
00:39:16,720 --> 00:39:18,000
same but let's think for a moment about

1111
00:39:18,000 --> 00:39:19,200
that

1112
00:39:19,200 --> 00:39:21,040
and

1113
00:39:21,040 --> 00:39:22,640
we have these two

1114
00:39:22,640 --> 00:39:25,760
maps and the two maps satisfied that

1115
00:39:25,760 --> 00:39:29,280
well maybe you cannot get the

1116
00:39:29,280 --> 00:39:31,040
the component-wise product of two

1117
00:39:31,040 --> 00:39:32,480
vectors

1118
00:39:32,480 --> 00:39:34,079
directly but

1119
00:39:34,079 --> 00:39:36,880
you can first map the two vectors with v

1120
00:39:36,880 --> 00:39:38,400
that gives you two

1121
00:39:38,400 --> 00:39:40,720
field extension elements over after to

1122
00:39:40,720 --> 00:39:41,680
the m

1123
00:39:41,680 --> 00:39:44,160
and now you can map them back with

1124
00:39:44,160 --> 00:39:44,880
c

1125
00:39:44,880 --> 00:39:46,000
and it turns out because of the

1126
00:39:46,000 --> 00:39:47,280
properties of these two functions that

1127
00:39:47,280 --> 00:39:49,200
will give you the the component wise

1128
00:39:49,200 --> 00:39:51,520
product

1129
00:39:52,079 --> 00:39:53,760
how can they be used

1130
00:39:53,760 --> 00:39:54,839
so in

1131
00:39:54,839 --> 00:39:57,119
ccxy19 they are used in the following

1132
00:39:57,119 --> 00:39:59,440
way

1133
00:39:59,440 --> 00:40:01,040
oh before i get into that i'm sorry i

1134
00:40:01,040 --> 00:40:03,760
want to stress that the ratio aim

1135
00:40:03,760 --> 00:40:05,119
divided by d

1136
00:40:05,119 --> 00:40:07,760
it can actually be shown to approach a

1137
00:40:07,760 --> 00:40:08,960
constant

1138
00:40:08,960 --> 00:40:11,200
and in our case we're not dealing with

1139
00:40:11,200 --> 00:40:12,640
fields we're dealing with galore rings

1140
00:40:12,640 --> 00:40:15,359
but recent work at crypto uh

1141
00:40:15,359 --> 00:40:18,000
this year crypto 21 actually showed that

1142
00:40:18,000 --> 00:40:20,319
we can also get our rmfes over galore

1143
00:40:20,319 --> 00:40:24,920
rings so that's not really a problem

1144
00:40:25,040 --> 00:40:28,240
so in ccxy 19

1145
00:40:28,240 --> 00:40:31,520
a the protocol operates as follows so to

1146
00:40:31,520 --> 00:40:33,680
secret share a value

1147
00:40:33,680 --> 00:40:35,440
i'm going to stick to the field

1148
00:40:35,440 --> 00:40:37,200
extensions just for

1149
00:40:37,200 --> 00:40:39,520
because that's how this original work is

1150
00:40:39,520 --> 00:40:44,800
described an insist i'm sorry is cc xy18

1151
00:40:44,800 --> 00:40:47,760
and to secretary one of these vectors

1152
00:40:47,760 --> 00:40:50,960
they will secret share over

1153
00:40:50,960 --> 00:40:53,839
f2 to the

1154
00:40:54,000 --> 00:40:55,599
this vector here

1155
00:40:55,599 --> 00:40:57,920
actually leaves in

1156
00:40:57,920 --> 00:41:00,240
f2 to d and when they want to secret

1157
00:41:00,240 --> 00:41:01,839
share it they

1158
00:41:01,839 --> 00:41:04,079
actually do secret sharing of the image

1159
00:41:04,079 --> 00:41:05,760
under fee of this vector which is an

1160
00:41:05,760 --> 00:41:09,280
element of f 2 to the m

1161
00:41:09,280 --> 00:41:10,880
and this is secret sharing over f 2 to

1162
00:41:10,880 --> 00:41:12,880
the m as we know it that can be made to

1163
00:41:12,880 --> 00:41:16,400
work let's say xiaomi secretary

1164
00:41:17,359 --> 00:41:18,640
if you want to

1165
00:41:18,640 --> 00:41:21,839
add to values then it's easy because fee

1166
00:41:21,839 --> 00:41:22,720
is

1167
00:41:22,720 --> 00:41:25,599
additive or homomorphic if you want to

1168
00:41:25,599 --> 00:41:27,359
multiply then it gets a little bit more

1169
00:41:27,359 --> 00:41:30,400
tricky because in multiplication

1170
00:41:30,400 --> 00:41:33,359
you want to essentially obtain

1171
00:41:33,359 --> 00:41:35,599
shares of the product component-wise

1172
00:41:35,599 --> 00:41:37,200
product of x and y but the

1173
00:41:37,200 --> 00:41:39,200
component-wise product of x and y having

1174
00:41:39,200 --> 00:41:41,520
shares of it means that you have shares

1175
00:41:41,520 --> 00:41:45,040
over f2 to the m of the image under fee

1176
00:41:45,040 --> 00:41:47,280
of exactly that product so so that's why

1177
00:41:47,280 --> 00:41:49,359
we want to get shares of fee of

1178
00:41:49,359 --> 00:41:51,520
the company voice product how do we get

1179
00:41:51,520 --> 00:41:52,560
it

1180
00:41:52,560 --> 00:41:55,280
they get it into steps

1181
00:41:55,280 --> 00:41:56,640
so

1182
00:41:56,640 --> 00:41:58,240
in the first step

1183
00:41:58,240 --> 00:41:59,520
the

1184
00:41:59,520 --> 00:42:01,520
parties execute whatever protocol they

1185
00:42:01,520 --> 00:42:02,640
come up with

1186
00:42:02,640 --> 00:42:06,400
over f2 to the m to compute

1187
00:42:06,400 --> 00:42:08,160
the product of these two secrets and

1188
00:42:08,160 --> 00:42:10,079
that's like there are many protocols we

1189
00:42:10,079 --> 00:42:11,359
can use for example the triple based

1190
00:42:11,359 --> 00:42:13,440
protocol i just mentioned

1191
00:42:13,440 --> 00:42:15,520
and now they got this now however this

1192
00:42:15,520 --> 00:42:18,480
is not enough because phi of x

1193
00:42:18,480 --> 00:42:20,000
times phi of y

1194
00:42:20,000 --> 00:42:21,920
may not be equal and in fact is in

1195
00:42:21,920 --> 00:42:24,079
general is in general not equal

1196
00:42:24,079 --> 00:42:25,920
to the to the thing we want which is the

1197
00:42:25,920 --> 00:42:28,079
image of the component waste product so

1198
00:42:28,079 --> 00:42:31,599
to address this they use mpc like

1199
00:42:31,599 --> 00:42:33,760
another small protocol but it requires

1200
00:42:33,760 --> 00:42:36,720
interaction to apply this map this

1201
00:42:36,720 --> 00:42:38,880
composition it's a map that takes

1202
00:42:38,880 --> 00:42:41,760
elements of f2 to the m into elements of

1203
00:42:41,760 --> 00:42:42,839
f2 to the

1204
00:42:42,839 --> 00:42:47,359
m and they take this and apply tau to it

1205
00:42:47,359 --> 00:42:48,960
so they take this value and apply tau to

1206
00:42:48,960 --> 00:42:50,960
it again this is an interactive protocol

1207
00:42:50,960 --> 00:42:52,880
they have some interaction and then they

1208
00:42:52,880 --> 00:42:55,200
get this and i claim that this is

1209
00:42:55,200 --> 00:42:58,160
exactly equal to what we want and this

1210
00:42:58,160 --> 00:43:01,200
is easy to see if you essentially

1211
00:43:01,200 --> 00:43:02,480
apply

1212
00:43:02,480 --> 00:43:04,160
use the definition of tau tau is just

1213
00:43:04,160 --> 00:43:05,599
this composition and then use the

1214
00:43:05,599 --> 00:43:07,839
properties of a

1215
00:43:07,839 --> 00:43:09,040
reverse multiplication from the

1216
00:43:09,040 --> 00:43:10,640
embeddings that tell you that whenever

1217
00:43:10,640 --> 00:43:13,280
you have c of two products of v

1218
00:43:13,280 --> 00:43:15,760
functions then you get the

1219
00:43:15,760 --> 00:43:18,000
arguments multiplied point waste so this

1220
00:43:18,000 --> 00:43:21,520
is c c x y in a nutshell now

1221
00:43:21,520 --> 00:43:23,359
can we use this protocol for our goals

1222
00:43:23,359 --> 00:43:25,599
for what we want here and the answer is

1223
00:43:25,599 --> 00:43:26,400
no

1224
00:43:26,400 --> 00:43:28,319
this protocol will not work in our

1225
00:43:28,319 --> 00:43:30,640
setting directly like not out of the box

1226
00:43:30,640 --> 00:43:33,119
because applying this extra function

1227
00:43:33,119 --> 00:43:35,119
this function tau will add an extra

1228
00:43:35,119 --> 00:43:37,200
round i insist i want to emphasize we

1229
00:43:37,200 --> 00:43:38,560
need to stick to one round

1230
00:43:38,560 --> 00:43:41,200
multiplication so even though this

1231
00:43:41,200 --> 00:43:43,200
multiplication up here

1232
00:43:43,200 --> 00:43:45,040
can be done in one round

1233
00:43:45,040 --> 00:43:46,800
this thing down here will require an

1234
00:43:46,800 --> 00:43:48,079
extra round

1235
00:43:48,079 --> 00:43:51,680
and we don't want to do that

1236
00:43:52,079 --> 00:43:55,440
this is why in this work we introduce

1237
00:43:55,440 --> 00:43:57,520
an additional contribution which is that

1238
00:43:57,520 --> 00:44:00,400
we encode values differently so this is

1239
00:44:00,400 --> 00:44:02,079
very important

1240
00:44:02,079 --> 00:44:05,280
now if you want to secret share a vector

1241
00:44:05,280 --> 00:44:07,599
over sd so now i'm coming back to our

1242
00:44:07,599 --> 00:44:10,000
galore rings remember s

1243
00:44:10,000 --> 00:44:11,839
is a galois ring

1244
00:44:11,839 --> 00:44:13,839
of pitches decay

1245
00:44:13,839 --> 00:44:15,680
l is is like a constant element you can

1246
00:44:15,680 --> 00:44:19,359
think of it as the anal analogous of fpc

1247
00:44:19,359 --> 00:44:21,280
and here you have r

1248
00:44:21,280 --> 00:44:22,960
actually fpl

1249
00:44:22,960 --> 00:44:25,839
to be concrete and here you have a r

1250
00:44:25,839 --> 00:44:28,880
that is p to the k m l which is the

1251
00:44:28,880 --> 00:44:32,160
analogous to f p to the m

1252
00:44:32,160 --> 00:44:34,640
so it's a is a r is an extension of s of

1253
00:44:34,640 --> 00:44:37,119
degree m

1254
00:44:37,119 --> 00:44:39,520
so if you want a secret share

1255
00:44:39,520 --> 00:44:42,319
a vector here

1256
00:44:42,319 --> 00:44:43,040
we

1257
00:44:43,040 --> 00:44:43,839
if

1258
00:44:43,839 --> 00:44:46,160
in the previous context you just apply

1259
00:44:46,160 --> 00:44:48,319
feed to that vector that gives you an

1260
00:44:48,319 --> 00:44:50,000
element of r and then you do secrecion

1261
00:44:50,000 --> 00:44:51,680
over r of that vector

1262
00:44:51,680 --> 00:44:53,119
now instead

1263
00:44:53,119 --> 00:44:55,280
we're going to find some x

1264
00:44:55,280 --> 00:44:58,880
such that x under the function c gives

1265
00:44:58,880 --> 00:45:00,800
you the vector x that you're interested

1266
00:45:00,800 --> 00:45:03,040
in sharing and this is the small x that

1267
00:45:03,040 --> 00:45:04,880
we're going to

1268
00:45:04,880 --> 00:45:08,400
now we're going to a secret share

1269
00:45:08,400 --> 00:45:10,480
so this is the new type of sharing or

1270
00:45:10,480 --> 00:45:12,000
the new type of encoding to encode a

1271
00:45:12,000 --> 00:45:13,839
vector x we encode instead of mapping

1272
00:45:13,839 --> 00:45:16,319
through v we encode with a pre-image of

1273
00:45:16,319 --> 00:45:17,520
andropc

1274
00:45:17,520 --> 00:45:18,880
and by the way you can always show that

1275
00:45:18,880 --> 00:45:20,720
you can show by the properties of rmfe

1276
00:45:20,720 --> 00:45:22,480
is that c is going to be

1277
00:45:22,480 --> 00:45:25,119
subjective

1278
00:45:25,599 --> 00:45:27,359
so you can show that addition is still

1279
00:45:27,359 --> 00:45:29,680
local

1280
00:45:29,760 --> 00:45:32,319
because of the linearity of c so i will

1281
00:45:32,319 --> 00:45:34,160
just skip this quickly but

1282
00:45:34,160 --> 00:45:36,160
multiplication in one round

1283
00:45:36,160 --> 00:45:37,440
can be done

1284
00:45:37,440 --> 00:45:38,560
also

1285
00:45:38,560 --> 00:45:41,119
quite fast in with with very good

1286
00:45:41,119 --> 00:45:42,319
communication

1287
00:45:42,319 --> 00:45:44,880
so it works like this we assume that

1288
00:45:44,880 --> 00:45:46,640
we're going to have now a more complex

1289
00:45:46,640 --> 00:45:49,760
multiplication triple as preprocessing

1290
00:45:49,760 --> 00:45:51,040
of this form

1291
00:45:51,040 --> 00:45:52,880
and with this at hand

1292
00:45:52,880 --> 00:45:56,079
if you have x and you have y which you

1293
00:45:56,079 --> 00:45:58,480
want to multiply so so the corresponding

1294
00:45:58,480 --> 00:46:00,000
vectors encoded by them are just the

1295
00:46:00,000 --> 00:46:01,760
images on the c

1296
00:46:01,760 --> 00:46:03,839
with the goal is to obtain

1297
00:46:03,839 --> 00:46:06,319
shares of the product which means

1298
00:46:06,319 --> 00:46:08,720
shares of a value such that when you map

1299
00:46:08,720 --> 00:46:10,800
it under seed you get

1300
00:46:10,800 --> 00:46:13,599
a the original two vectors the component

1301
00:46:13,599 --> 00:46:15,680
was spread of the two vectors and to do

1302
00:46:15,680 --> 00:46:17,680
this we just need to execute two rounds

1303
00:46:17,680 --> 00:46:20,079
the first one

1304
00:46:20,079 --> 00:46:23,760
if the part is open x minus a

1305
00:46:23,760 --> 00:46:27,040
and also y minus b just like with normal

1306
00:46:27,040 --> 00:46:29,200
a beaver based multiplication and here

1307
00:46:29,200 --> 00:46:31,920
we use regenerating codes

1308
00:46:31,920 --> 00:46:34,240
so this one is very efficient it only

1309
00:46:34,240 --> 00:46:37,119
involves n squared divided by m also

1310
00:46:37,119 --> 00:46:39,680
divided n squared divided by

1311
00:46:39,680 --> 00:46:40,839
log n

1312
00:46:40,839 --> 00:46:42,400
elements

1313
00:46:42,400 --> 00:46:45,599
and then the parties compute locally

1314
00:46:45,599 --> 00:46:47,440
this expression here which is

1315
00:46:47,440 --> 00:46:48,640
essentially the beaver based

1316
00:46:48,640 --> 00:46:50,960
multiplication expression but now with

1317
00:46:50,960 --> 00:46:53,359
taus

1318
00:46:53,760 --> 00:46:55,599
so this is essentially what they this is

1319
00:46:55,599 --> 00:46:57,680
all data from the pre-processing

1320
00:46:57,680 --> 00:46:59,440
and they get this you can check that

1321
00:46:59,440 --> 00:47:01,680
it's equal to this now i claim that this

1322
00:47:01,680 --> 00:47:03,760
is the z we can take

1323
00:47:03,760 --> 00:47:05,520
so in other words i claim that if we

1324
00:47:05,520 --> 00:47:08,640
take c to be this value then when we map

1325
00:47:08,640 --> 00:47:11,440
z through troop c we get what we want

1326
00:47:11,440 --> 00:47:13,520
which is the component voice product

1327
00:47:13,520 --> 00:47:15,920
this is true because this is the same as

1328
00:47:15,920 --> 00:47:18,400
c of these two things and remember

1329
00:47:18,400 --> 00:47:20,720
because of the properties of rmfes

1330
00:47:20,720 --> 00:47:23,599
c of a product under fee

1331
00:47:23,599 --> 00:47:25,280
of a product of fees

1332
00:47:25,280 --> 00:47:26,880
is the same as the component-wise

1333
00:47:26,880 --> 00:47:30,079
product of the arguments of the fee

1334
00:47:30,079 --> 00:47:32,240
and well the arguments in this case are

1335
00:47:32,240 --> 00:47:35,599
c of x which is vector x by definition c

1336
00:47:35,599 --> 00:47:37,359
of y which is vector y by definition so

1337
00:47:37,359 --> 00:47:39,200
this gives you the component spread so

1338
00:47:39,200 --> 00:47:42,319
this normal method of encoding really

1339
00:47:42,319 --> 00:47:45,119
rules uh or removes the issue of having

1340
00:47:45,119 --> 00:47:45,920
to

1341
00:47:45,920 --> 00:47:48,480
apply tau after the multiplication has

1342
00:47:48,480 --> 00:47:50,800
been done so basically you can apply tau

1343
00:47:50,800 --> 00:47:52,559
at the same time as you do the complete

1344
00:47:52,559 --> 00:47:55,520
computation if you will

1345
00:47:56,400 --> 00:47:58,400
now i also want to note that our new

1346
00:47:58,400 --> 00:48:02,240
encoding improves ccxy in in other

1347
00:48:02,240 --> 00:48:04,640
like on its own like this encoding is

1348
00:48:04,640 --> 00:48:06,720
not only useful for a work but also for

1349
00:48:06,720 --> 00:48:09,280
cc xy which i'm sorry insists this is

1350
00:48:09,280 --> 00:48:11,200
easy xy 18.

1351
00:48:11,200 --> 00:48:13,440
so the extra ring coding ground is

1352
00:48:13,440 --> 00:48:16,000
removed as i mentioned

1353
00:48:16,000 --> 00:48:16,800
so

1354
00:48:16,800 --> 00:48:18,880
so this can also be

1355
00:48:18,880 --> 00:48:20,960
our encoding can also be applied to ccxy

1356
00:48:20,960 --> 00:48:23,280
to remove the raincoating over there and

1357
00:48:23,280 --> 00:48:25,040
also there is this annoying thing at the

1358
00:48:25,040 --> 00:48:26,720
beginning which is a

1359
00:48:26,720 --> 00:48:28,800
subspace check

1360
00:48:28,800 --> 00:48:30,480
for the input phase that

1361
00:48:30,480 --> 00:48:32,319
verifies that the input is in the right

1362
00:48:32,319 --> 00:48:34,880
subspace well here you don't need that

1363
00:48:34,880 --> 00:48:37,440
because every secret sharing is is a

1364
00:48:37,440 --> 00:48:38,720
possible sharing of a vector in the

1365
00:48:38,720 --> 00:48:41,520
previous case only the the

1366
00:48:41,520 --> 00:48:43,200
elements in the image of fee can be

1367
00:48:43,200 --> 00:48:45,200
correct encodings so now here everyone

1368
00:48:45,200 --> 00:48:47,200
can be an encoding which removes this

1369
00:48:47,200 --> 00:48:48,400
problem

1370
00:48:48,400 --> 00:48:50,000
there are several additional challenges

1371
00:48:50,000 --> 00:48:51,839
specifically when we move to active

1372
00:48:51,839 --> 00:48:54,079
security in our protocol you need to

1373
00:48:54,079 --> 00:48:55,680
deal with the correctness of of the

1374
00:48:55,680 --> 00:48:58,319
openings because the

1375
00:48:58,319 --> 00:49:00,160
regenerating codes don't give you any

1376
00:49:00,160 --> 00:49:03,200
redundancy and you also need to deal

1377
00:49:03,200 --> 00:49:05,119
with

1378
00:49:05,119 --> 00:49:06,640
the consistency of the broadcast and so

1379
00:49:06,640 --> 00:49:08,160
on we use function dependent

1380
00:49:08,160 --> 00:49:10,000
preprocessing to address this in a novel

1381
00:49:10,000 --> 00:49:12,400
way and we leave the details for you to

1382
00:49:12,400 --> 00:49:14,000
check in the paper but like it's very

1383
00:49:14,000 --> 00:49:15,200
interesting that we can solve it that

1384
00:49:15,200 --> 00:49:17,920
way and then finally i just want to

1385
00:49:17,920 --> 00:49:20,400
revisit in one single slide

1386
00:49:20,400 --> 00:49:21,599
the

1387
00:49:21,599 --> 00:49:23,440
the results and regenerating codes these

1388
00:49:23,440 --> 00:49:25,200
are not so important

1389
00:49:25,200 --> 00:49:26,559
to understand in detail i just want to

1390
00:49:26,559 --> 00:49:28,079
mention that we have this new

1391
00:49:28,079 --> 00:49:29,440
characterization of what it means to

1392
00:49:29,440 --> 00:49:32,400
have repairing ability in terms of the

1393
00:49:32,400 --> 00:49:33,920
dual code

1394
00:49:33,920 --> 00:49:35,920
that can be interesting on its own

1395
00:49:35,920 --> 00:49:37,760
and then we also have an existing

1396
00:49:37,760 --> 00:49:39,040
theorem on

1397
00:49:39,040 --> 00:49:40,720
repairing codes with shammier secret

1398
00:49:40,720 --> 00:49:41,599
sharing

1399
00:49:41,599 --> 00:49:43,839
so basically to be concrete the function

1400
00:49:43,839 --> 00:49:44,960
that you take

1401
00:49:44,960 --> 00:49:47,839
is is a trace function with

1402
00:49:47,839 --> 00:49:48,880
um

1403
00:49:48,880 --> 00:49:50,240
the generalized trace function of our

1404
00:49:50,240 --> 00:49:51,839
calorics

1405
00:49:51,839 --> 00:49:53,839
where the alphas are some evaluation

1406
00:49:53,839 --> 00:49:55,760
points that you need to take very

1407
00:49:55,760 --> 00:49:58,960
carefully as powers of certain a root of

1408
00:49:58,960 --> 00:50:02,160
unity and also the weights are the the

1409
00:50:02,160 --> 00:50:04,160
w's are the weights coming from the dual

1410
00:50:04,160 --> 00:50:06,480
code of read solomon codes

1411
00:50:06,480 --> 00:50:09,040
and this is similar to the result of

1412
00:50:09,040 --> 00:50:10,559
refuels but it has several crucial

1413
00:50:10,559 --> 00:50:12,240
differences for example the trace

1414
00:50:12,240 --> 00:50:15,119
function is to be defined differently or

1415
00:50:15,119 --> 00:50:17,599
more in a marginalized way and also the

1416
00:50:17,599 --> 00:50:19,920
evaluation points need to be taken

1417
00:50:19,920 --> 00:50:21,440
in a very careful manner because

1418
00:50:21,440 --> 00:50:23,680
otherwise this won't work so there are

1419
00:50:23,680 --> 00:50:25,200
several differences that are very

1420
00:50:25,200 --> 00:50:27,119
interesting

1421
00:50:27,119 --> 00:50:28,480
with this i would like to thank you for

1422
00:50:28,480 --> 00:50:30,240
your attention you stick with me all

1423
00:50:30,240 --> 00:50:33,839
this time so i appreciate that you

1424
00:50:33,920 --> 00:50:37,920
were in this talk thank you so much

