1
00:00:02,720 --> 00:00:04,480
hi everyone

2
00:00:04,480 --> 00:00:06,640
my name is andrea basso and i'm going to

3
00:00:06,640 --> 00:00:09,360
present our work on cryptanalyzing an

4
00:00:09,360 --> 00:00:11,920
oblivious pseudorandom function protocol

5
00:00:11,920 --> 00:00:14,160
based on super singularizogenics by

6
00:00:14,160 --> 00:00:17,039
bonnie hogan hebrew this is joint work

7
00:00:17,039 --> 00:00:19,439
together with my co-authors peter kootas

8
00:00:19,439 --> 00:00:21,680
simon philip mertz christophe betty and

9
00:00:21,680 --> 00:00:24,000
anthony sanso

10
00:00:24,000 --> 00:00:26,480
i will start by briefly recalling what a

11
00:00:26,480 --> 00:00:28,320
no prf is

12
00:00:28,320 --> 00:00:31,039
then i will describe the oprf protocol

13
00:00:31,039 --> 00:00:33,840
by bonnie ital and eventually present

14
00:00:33,840 --> 00:00:36,079
two types of attack a polytime attack in

15
00:00:36,079 --> 00:00:38,879
a southern exponential time attack

16
00:00:38,879 --> 00:00:41,120
eventually i will conclude by describing

17
00:00:41,120 --> 00:00:43,280
some implementational results as well as

18
00:00:43,280 --> 00:00:46,879
discussing the need for a trusted setup

19
00:00:46,879 --> 00:00:48,960
an oblivious pseudo-random function or

20
00:00:48,960 --> 00:00:51,680
oprf is a two-party protocol where a

21
00:00:51,680 --> 00:00:54,160
client and a server jointly evaluate

22
00:00:54,160 --> 00:00:58,480
acid random function f whose input is

23
00:00:58,480 --> 00:01:02,399
a value m chosen by the client and a key

24
00:01:02,399 --> 00:01:04,159
chosen by the server

25
00:01:04,159 --> 00:01:06,320
in particular we want the client to

26
00:01:06,320 --> 00:01:09,119
learn the output of the evaluation

27
00:01:09,119 --> 00:01:13,520
because f of k and m but nothing else so

28
00:01:13,520 --> 00:01:15,840
the client shouldn't be able to

29
00:01:15,840 --> 00:01:17,759
evaluate or

30
00:01:17,759 --> 00:01:20,240
the function on any other input without

31
00:01:20,240 --> 00:01:22,400
interacting further with the server

32
00:01:22,400 --> 00:01:24,159
and conversely we want the server to

33
00:01:24,159 --> 00:01:25,520
learn nothing

34
00:01:25,520 --> 00:01:27,759
so the identity of the client must

35
00:01:27,759 --> 00:01:30,400
remain protected as well as its input

36
00:01:30,400 --> 00:01:31,200
and

37
00:01:31,200 --> 00:01:33,600
on top of that we want the server does

38
00:01:33,600 --> 00:01:36,720
not learn even the hash of the message

39
00:01:36,720 --> 00:01:39,280
because that would allow the server to

40
00:01:39,280 --> 00:01:41,520
distinguish when the same

41
00:01:41,520 --> 00:01:44,560
input is reused twice

42
00:01:44,560 --> 00:01:45,759
moreover

43
00:01:45,759 --> 00:01:48,320
some oprx protocol have an additional

44
00:01:48,320 --> 00:01:51,119
property called verifiableness when a

45
00:01:51,119 --> 00:01:53,759
nokia rf is verifiable the server also

46
00:01:53,759 --> 00:01:56,880
provides some guarantee or some zero

47
00:01:56,880 --> 00:01:59,520
knowledge proof that the same key k is

48
00:01:59,520 --> 00:02:02,719
reused across all iterations

49
00:02:02,719 --> 00:02:04,880
obliviously random functions are an

50
00:02:04,880 --> 00:02:06,560
important primitive

51
00:02:06,560 --> 00:02:09,038
because they have several applications

52
00:02:09,038 --> 00:02:11,200
these include password authenticated key

53
00:02:11,200 --> 00:02:13,760
exchanges with the

54
00:02:13,760 --> 00:02:17,200
one notable i mentioned opaque the

55
00:02:17,200 --> 00:02:18,959
protocol that

56
00:02:18,959 --> 00:02:21,840
builds packet based on

57
00:02:21,840 --> 00:02:24,560
as well as privacy intersection privacy

58
00:02:24,560 --> 00:02:27,280
preserving captchas and many other real

59
00:02:27,280 --> 00:02:29,760
water applications that are used and

60
00:02:29,760 --> 00:02:30,800
deployed

61
00:02:30,800 --> 00:02:33,280
every day

62
00:02:34,879 --> 00:02:37,840
last year bonnie ital presented two

63
00:02:37,840 --> 00:02:39,840
oblivious pseudo-random functions based

64
00:02:39,840 --> 00:02:42,879
on super singular esogenies one was

65
00:02:42,879 --> 00:02:45,920
developed in the framework of seaside

66
00:02:45,920 --> 00:02:48,879
and one in the sidh framework

67
00:02:48,879 --> 00:02:53,200
our work focuses on the sadh one

68
00:02:53,200 --> 00:02:55,599
which was also the main focus of their

69
00:02:55,599 --> 00:02:57,040
work

70
00:02:57,040 --> 00:03:00,560
the main idea is that we can have an sdh

71
00:03:00,560 --> 00:03:02,640
type of exchange

72
00:03:02,640 --> 00:03:05,840
and we can look at the shared

73
00:03:05,840 --> 00:03:08,560
secret the resulting curve

74
00:03:08,560 --> 00:03:11,840
and use that as the output of

75
00:03:11,840 --> 00:03:14,640
of our pseudorandom function

76
00:03:14,640 --> 00:03:17,920
however we cannot use an sadh type of

77
00:03:17,920 --> 00:03:20,640
exchange directly because

78
00:03:20,640 --> 00:03:23,519
the client has access to the server

79
00:03:23,519 --> 00:03:26,000
public key which allows the client to

80
00:03:26,000 --> 00:03:27,280
evaluate

81
00:03:27,280 --> 00:03:29,360
the opr on

82
00:03:29,360 --> 00:03:30,959
multiple inputs without further

83
00:03:30,959 --> 00:03:32,879
interacting with the server

84
00:03:32,879 --> 00:03:36,000
and similarly the server can also see

85
00:03:36,000 --> 00:03:39,519
the curve em which depends exclusively

86
00:03:39,519 --> 00:03:42,000
on the message m

87
00:03:42,000 --> 00:03:45,280
so while the result is what we want the

88
00:03:45,280 --> 00:03:47,760
privacy guarantees are not there

89
00:03:47,760 --> 00:03:51,120
thus pune it all proposed to

90
00:03:51,120 --> 00:03:53,599
disregard all the other computations and

91
00:03:53,599 --> 00:03:56,239
only start by computing

92
00:03:56,239 --> 00:03:57,200
the

93
00:03:57,200 --> 00:04:00,799
isogenic corresponding the input m then

94
00:04:00,799 --> 00:04:02,720
the client computes an additional result

95
00:04:02,720 --> 00:04:04,319
in phi of r

96
00:04:04,319 --> 00:04:06,879
which is called a blinding gasoline

97
00:04:06,879 --> 00:04:09,680
the resulting curve emr

98
00:04:09,680 --> 00:04:13,120
does depend on the input m but heights

99
00:04:13,120 --> 00:04:15,840
or blinds this value indeed the server

100
00:04:15,840 --> 00:04:19,440
once uh sees the curve e m r will not be

101
00:04:19,440 --> 00:04:22,880
able to recover em or the message m

102
00:04:22,880 --> 00:04:24,960
this curve is then sent to the server

103
00:04:24,960 --> 00:04:28,400
who computes lysogeny5k

104
00:04:28,400 --> 00:04:31,360
know that this exogeny is parallel to

105
00:04:31,360 --> 00:04:33,840
disogne between e0 or ek

106
00:04:33,840 --> 00:04:36,400
and corresponds to that one

107
00:04:36,400 --> 00:04:38,320
the server also provides some torsional

108
00:04:38,320 --> 00:04:39,919
information

109
00:04:39,919 --> 00:04:42,800
which allows the client to invert these

110
00:04:42,800 --> 00:04:45,280
identify r

111
00:04:45,280 --> 00:04:47,759
when the client inverse that isogeny

112
00:04:47,759 --> 00:04:49,120
unblinds

113
00:04:49,120 --> 00:04:52,720
the value and obtain the curve e m k

114
00:04:52,720 --> 00:04:54,720
in this way we can

115
00:04:54,720 --> 00:04:57,600
the client can recompute the curve that

116
00:04:57,600 --> 00:05:00,639
would have been computed by a shared

117
00:05:00,639 --> 00:05:02,639
sidh computation

118
00:05:02,639 --> 00:05:05,680
however in this case the client does not

119
00:05:05,680 --> 00:05:08,240
learn the public key of the server and

120
00:05:08,240 --> 00:05:10,560
the server does not learn anything about

121
00:05:10,560 --> 00:05:11,600
the client

122
00:05:11,600 --> 00:05:13,919
more formally we can define the

123
00:05:13,919 --> 00:05:15,759
random function f

124
00:05:15,759 --> 00:05:18,720
to be the hash of the input m the

125
00:05:18,720 --> 00:05:20,720
resulting

126
00:05:20,720 --> 00:05:22,800
curve or its j invariant and the public

127
00:05:22,800 --> 00:05:25,600
key observer

128
00:05:27,199 --> 00:05:29,919
the security of oprefs

129
00:05:29,919 --> 00:05:32,880
are fairly complex because they depend

130
00:05:32,880 --> 00:05:33,680
on

131
00:05:33,680 --> 00:05:35,520
several assumptions

132
00:05:35,520 --> 00:05:37,759
in our work we mainly focus on one

133
00:05:37,759 --> 00:05:40,080
assumption the so-called one more

134
00:05:40,080 --> 00:05:42,320
assumption

135
00:05:42,320 --> 00:05:45,680
which states that an attacker who has

136
00:05:45,680 --> 00:05:48,800
interacted several times with the server

137
00:05:48,800 --> 00:05:51,039
cannot compute

138
00:05:51,039 --> 00:05:54,160
one more evaluation of the opr on a new

139
00:05:54,160 --> 00:05:56,240
input

140
00:05:56,240 --> 00:05:57,199
and

141
00:05:57,199 --> 00:05:59,759
the assumption is stated in reference to

142
00:05:59,759 --> 00:06:02,160
a game which starts with the attacker

143
00:06:02,160 --> 00:06:05,440
being able to send points m

144
00:06:05,440 --> 00:06:07,520
on the curve e0

145
00:06:07,520 --> 00:06:09,919
the challenger then computes the

146
00:06:09,919 --> 00:06:12,720
corresponding curve e of m zero

147
00:06:12,720 --> 00:06:14,080
and then

148
00:06:14,080 --> 00:06:16,479
e on zero k

149
00:06:16,479 --> 00:06:19,520
which is the resulting curve from the

150
00:06:19,520 --> 00:06:21,840
prf

151
00:06:21,840 --> 00:06:23,919
the attacker then is allowed to repeat

152
00:06:23,919 --> 00:06:26,160
this process several times

153
00:06:26,160 --> 00:06:28,880
and eventually the attacker needs

154
00:06:28,880 --> 00:06:31,120
to output the

155
00:06:31,120 --> 00:06:34,639
epr oprf evaluation corresponding point

156
00:06:34,639 --> 00:06:37,440
m prime where m prime is chosen by the

157
00:06:37,440 --> 00:06:39,600
challenger

158
00:06:39,600 --> 00:06:41,280
this assumption

159
00:06:41,280 --> 00:06:42,240
is

160
00:06:42,240 --> 00:06:43,280
different

161
00:06:43,280 --> 00:06:47,039
from the protocol in two main ways

162
00:06:47,039 --> 00:06:50,880
one in the assumption the attacker which

163
00:06:50,880 --> 00:06:53,280
in the process corresponds to the client

164
00:06:53,280 --> 00:06:55,199
submits points

165
00:06:55,199 --> 00:06:58,000
in the protocol itself

166
00:06:58,000 --> 00:07:01,039
this would reveal the input of the

167
00:07:01,039 --> 00:07:03,039
client because the client needs to

168
00:07:03,039 --> 00:07:05,039
compute that chain organization is to

169
00:07:05,039 --> 00:07:06,000
protect

170
00:07:06,000 --> 00:07:08,960
their own privacy

171
00:07:10,080 --> 00:07:12,960
in the assumption

172
00:07:12,960 --> 00:07:14,240
the

173
00:07:14,240 --> 00:07:17,759
attacker sends points to abstract away

174
00:07:17,759 --> 00:07:20,080
from the privacy for serving

175
00:07:20,080 --> 00:07:23,360
computations as well as

176
00:07:23,360 --> 00:07:25,199
because the

177
00:07:25,199 --> 00:07:26,720
client

178
00:07:26,720 --> 00:07:29,280
provides zero knowledge proofs that

179
00:07:29,280 --> 00:07:32,160
their energy competitions are correct in

180
00:07:32,160 --> 00:07:34,160
the protocol

181
00:07:34,160 --> 00:07:37,360
the other main difference is that

182
00:07:37,360 --> 00:07:40,880
in the oprah vertical the clients

183
00:07:40,880 --> 00:07:41,919
hashes

184
00:07:41,919 --> 00:07:45,520
their input onto the control point m

185
00:07:45,520 --> 00:07:48,319
and then uses that for their computation

186
00:07:48,319 --> 00:07:51,199
this is needed to prevent simple attacks

187
00:07:51,199 --> 00:07:52,160
where

188
00:07:52,160 --> 00:07:53,120
a

189
00:07:53,120 --> 00:07:54,560
two neighbor

190
00:07:54,560 --> 00:07:56,800
here who responds to a two neighbor of

191
00:07:56,800 --> 00:07:58,400
the resulting curve

192
00:07:58,400 --> 00:07:59,199
and

193
00:07:59,199 --> 00:08:00,800
that prevents those type of attacks

194
00:08:00,800 --> 00:08:02,720
because even if

195
00:08:02,720 --> 00:08:04,879
the client would compute

196
00:08:04,879 --> 00:08:07,199
a neighboring curve of this curve they

197
00:08:07,199 --> 00:08:08,479
would not know

198
00:08:08,479 --> 00:08:09,599
the

199
00:08:09,599 --> 00:08:13,680
input corresponding to that point m

200
00:08:13,680 --> 00:08:17,039
and this corresponds in the assumption

201
00:08:17,039 --> 00:08:19,280
to the fact that the attacker needs to

202
00:08:19,280 --> 00:08:20,319
output the

203
00:08:20,319 --> 00:08:21,440
um

204
00:08:21,440 --> 00:08:24,720
resulting value for a point m one chosen

205
00:08:24,720 --> 00:08:26,879
by the challenger rather than chosen by

206
00:08:26,879 --> 00:08:29,280
the attack

207
00:08:29,680 --> 00:08:34,000
we will now present an attack that can

208
00:08:34,000 --> 00:08:36,880
fully break this assumption and

209
00:08:36,880 --> 00:08:38,080
compute

210
00:08:38,080 --> 00:08:40,719
the shared curve for any

211
00:08:40,719 --> 00:08:43,279
input point p

212
00:08:43,279 --> 00:08:45,519
and in general we will use a two-step

213
00:08:45,519 --> 00:08:46,800
strategy

214
00:08:46,800 --> 00:08:47,839
first

215
00:08:47,839 --> 00:08:50,720
we devise a strategy to recover the

216
00:08:50,720 --> 00:08:53,440
curve ek which corresponds to the public

217
00:08:53,440 --> 00:08:54,480
key

218
00:08:54,480 --> 00:08:58,480
of the server if it was an sdh exchange

219
00:08:58,480 --> 00:08:59,920
as well as

220
00:08:59,920 --> 00:09:01,120
the

221
00:09:01,120 --> 00:09:03,920
subgroup generated by the image of a

222
00:09:03,920 --> 00:09:05,360
point m

223
00:09:05,360 --> 00:09:08,959
under the private exogeny of the server

224
00:09:08,959 --> 00:09:11,279
for some point m

225
00:09:11,279 --> 00:09:12,880
once we

226
00:09:12,880 --> 00:09:13,680
can

227
00:09:13,680 --> 00:09:16,640
do this then we can repeat this process

228
00:09:16,640 --> 00:09:19,839
a few times in order to combine several

229
00:09:19,839 --> 00:09:22,959
points to obtain the image of

230
00:09:22,959 --> 00:09:26,320
phi k on the two to the n version on e

231
00:09:26,320 --> 00:09:27,680
zero

232
00:09:27,680 --> 00:09:29,680
this is assuming that

233
00:09:29,680 --> 00:09:33,760
the exogenous of the client corresponds

234
00:09:33,760 --> 00:09:37,600
of um order two to the n

235
00:09:37,600 --> 00:09:39,600
once we have this then we have a full

236
00:09:39,600 --> 00:09:42,160
attack because for any point p in the

237
00:09:42,160 --> 00:09:45,040
two to the n torsion in a zero we can

238
00:09:45,040 --> 00:09:46,080
compute

239
00:09:46,080 --> 00:09:48,399
the sub group generated by the image of

240
00:09:48,399 --> 00:09:50,399
p on e k

241
00:09:50,399 --> 00:09:53,279
and this we can compute the output of

242
00:09:53,279 --> 00:09:55,279
the prf as

243
00:09:55,279 --> 00:09:57,040
ek

244
00:09:57,040 --> 00:09:59,839
modded by this value which corresponds

245
00:09:59,839 --> 00:10:03,360
to isogeny from e0

246
00:10:03,360 --> 00:10:06,800
with kernel p and k

247
00:10:07,519 --> 00:10:09,519
so let's see how to do the first step

248
00:10:09,519 --> 00:10:12,720
first where we want to recover ek as

249
00:10:12,720 --> 00:10:15,279
well as points on that curve we start

250
00:10:15,279 --> 00:10:18,240
from the curve e0 and we query the

251
00:10:18,240 --> 00:10:21,120
challenger with a point m

252
00:10:21,120 --> 00:10:24,079
and we obtain the curve e and q

253
00:10:24,079 --> 00:10:24,959
then

254
00:10:24,959 --> 00:10:27,920
we will carry with the point 2 m

255
00:10:27,920 --> 00:10:28,880
now

256
00:10:28,880 --> 00:10:31,839
the point to m will have order to the n

257
00:10:31,839 --> 00:10:34,720
minus one and this curve will correspond

258
00:10:34,720 --> 00:10:37,040
to the curve on the xogene between e

259
00:10:37,040 --> 00:10:38,399
zero and e m

260
00:10:38,399 --> 00:10:40,399
we can then repeat the process with four

261
00:10:40,399 --> 00:10:43,519
m eight m and so on

262
00:10:43,519 --> 00:10:45,200
eventually when

263
00:10:45,200 --> 00:10:48,800
at the end we will obtain the curve e k

264
00:10:48,800 --> 00:10:51,519
but we will also have recovered all the

265
00:10:51,519 --> 00:10:52,560
points

266
00:10:52,560 --> 00:10:54,320
all the curves on dissociation in

267
00:10:54,320 --> 00:10:57,440
between eka and emk

268
00:10:57,440 --> 00:11:00,000
because if we know the green isotony we

269
00:11:00,000 --> 00:11:02,399
know the kernel of the greenhouse algae

270
00:11:02,399 --> 00:11:04,399
and the kernel of the green esogenic is

271
00:11:04,399 --> 00:11:05,680
precisely

272
00:11:05,680 --> 00:11:06,480
the

273
00:11:06,480 --> 00:11:09,600
generated by the image of m under

274
00:11:09,600 --> 00:11:12,600
isogeny5k

275
00:11:13,440 --> 00:11:17,120
so now that we can recover the sub

276
00:11:17,120 --> 00:11:19,680
group generated by 5 k of m for any

277
00:11:19,680 --> 00:11:20,880
point m

278
00:11:20,880 --> 00:11:24,399
on e0 on the 2n version of 0

279
00:11:24,399 --> 00:11:26,399
we can also recover that means that we

280
00:11:26,399 --> 00:11:30,079
can also recover the image of m on e k

281
00:11:30,079 --> 00:11:33,200
up to another scalar

282
00:11:33,200 --> 00:11:35,680
thus we repeat the process by querying

283
00:11:35,680 --> 00:11:37,360
for point m

284
00:11:37,360 --> 00:11:39,440
n which must be linearly independent

285
00:11:39,440 --> 00:11:40,320
from m

286
00:11:40,320 --> 00:11:42,880
and m plus n

287
00:11:42,880 --> 00:11:44,959
which gives us the point m prime which

288
00:11:44,959 --> 00:11:47,760
is a scalar multiple of the image of m n

289
00:11:47,760 --> 00:11:49,680
prime a scalar multiple of the image of

290
00:11:49,680 --> 00:11:52,320
n and the same for r which is a scalar

291
00:11:52,320 --> 00:11:55,200
multiple of the sum of the images of m

292
00:11:55,200 --> 00:11:56,399
plus n

293
00:11:56,399 --> 00:11:59,600
but now we know that m prime and l prime

294
00:11:59,600 --> 00:12:03,200
form a basis particular inversion on e k

295
00:12:03,200 --> 00:12:06,000
so we can express r prime in terms of m

296
00:12:06,000 --> 00:12:08,320
prime and m prime

297
00:12:08,320 --> 00:12:11,440
if we do all the computations we see

298
00:12:11,440 --> 00:12:13,120
that

299
00:12:13,120 --> 00:12:15,839
the ratio between alpha and beta is

300
00:12:15,839 --> 00:12:18,160
exactly the same as the ratio between

301
00:12:18,160 --> 00:12:22,079
beta and then b and alpha and a

302
00:12:22,079 --> 00:12:24,800
which gives us just enough information

303
00:12:24,800 --> 00:12:28,399
to compute what we want indeed given any

304
00:12:28,399 --> 00:12:29,519
point p

305
00:12:29,519 --> 00:12:32,639
of order 2 to the n on e0 we can express

306
00:12:32,639 --> 00:12:35,519
that in terms of m and n

307
00:12:35,519 --> 00:12:37,440
and then we can compute the subgroup

308
00:12:37,440 --> 00:12:39,680
generated by the image of p

309
00:12:39,680 --> 00:12:44,079
as x prime plus y and prime times alpha

310
00:12:44,079 --> 00:12:45,200
over beta

311
00:12:45,200 --> 00:12:48,480
that is because we know that m prime is

312
00:12:48,480 --> 00:12:50,399
the correct image

313
00:12:50,399 --> 00:12:52,800
scale by alpha and n prime is the

314
00:12:52,800 --> 00:12:55,600
correct image scaled by beta but then

315
00:12:55,600 --> 00:12:57,839
when we multiply by alpha for beta the

316
00:12:57,839 --> 00:13:00,079
two betas cancels out and we have that

317
00:13:00,079 --> 00:13:02,480
both this value and this value are

318
00:13:02,480 --> 00:13:05,279
multiples of alpha which is a not scalar

319
00:13:05,279 --> 00:13:07,680
so that does not affect the subgroup

320
00:13:07,680 --> 00:13:09,600
computations and we are clean precisely

321
00:13:09,600 --> 00:13:12,240
what we want

322
00:13:12,320 --> 00:13:13,200
so

323
00:13:13,200 --> 00:13:14,959
to briefly summarize what we have done

324
00:13:14,959 --> 00:13:17,920
so far we've seen that we can use all of

325
00:13:17,920 --> 00:13:20,399
lambda queries to recover

326
00:13:20,399 --> 00:13:23,200
the sub group generated by phi k of m

327
00:13:23,200 --> 00:13:25,360
for any point m in the two to the n

328
00:13:25,360 --> 00:13:27,519
torsion in e zero

329
00:13:27,519 --> 00:13:30,240
once we have three such subgroups

330
00:13:30,240 --> 00:13:31,360
for

331
00:13:31,360 --> 00:13:32,320
m

332
00:13:32,320 --> 00:13:34,480
n and m plus n

333
00:13:34,480 --> 00:13:35,839
we can then

334
00:13:35,839 --> 00:13:38,240
compute the subgroup generated by the

335
00:13:38,240 --> 00:13:41,440
image of b for any point p without

336
00:13:41,440 --> 00:13:44,079
further queries or further interaction

337
00:13:44,079 --> 00:13:45,760
with the challenger

338
00:13:45,760 --> 00:13:47,519
and this allows us to break the one more

339
00:13:47,519 --> 00:13:49,920
assumption because we can now evaluate

340
00:13:49,920 --> 00:13:52,560
the oprf or any input of our choosing

341
00:13:52,560 --> 00:13:55,360
without further interactions

342
00:13:55,360 --> 00:13:57,279
however

343
00:13:57,279 --> 00:13:59,680
this depends entirely on the fact that

344
00:13:59,680 --> 00:14:04,320
we can submit points of varying order

345
00:14:04,320 --> 00:14:05,839
and

346
00:14:05,839 --> 00:14:08,000
while the isogeny

347
00:14:08,000 --> 00:14:10,240
sorry while the assumption as stated

348
00:14:10,240 --> 00:14:11,440
does not

349
00:14:11,440 --> 00:14:14,480
have any requirements it is easy to

350
00:14:14,480 --> 00:14:16,720
check that the query plans have full

351
00:14:16,720 --> 00:14:18,160
order

352
00:14:18,160 --> 00:14:20,240
because it is easy to twerk such an

353
00:14:20,240 --> 00:14:21,120
attack

354
00:14:21,120 --> 00:14:23,839
moreover while this attack applies to

355
00:14:23,839 --> 00:14:25,120
the assumption

356
00:14:25,120 --> 00:14:27,040
it does not directly translate to the

357
00:14:27,040 --> 00:14:29,839
operaf protocol because the protocol

358
00:14:29,839 --> 00:14:32,320
also requires the client to provide a

359
00:14:32,320 --> 00:14:35,839
zero knowledge truth to protect against

360
00:14:35,839 --> 00:14:38,320
gpst attacks

361
00:14:38,320 --> 00:14:40,959
which this zero is proof has also the

362
00:14:40,959 --> 00:14:44,160
effect of guaranteeing that the

363
00:14:44,160 --> 00:14:45,920
corresponding points and does the

364
00:14:45,920 --> 00:14:48,720
corresponding exogenous have full order

365
00:14:48,720 --> 00:14:52,160
so we will now present a new way

366
00:14:52,160 --> 00:14:54,160
to recompute

367
00:14:54,160 --> 00:14:55,120
the

368
00:14:55,120 --> 00:14:57,279
values on ek

369
00:14:57,279 --> 00:15:00,000
that will only use queries with full

370
00:15:00,000 --> 00:15:01,519
order points

371
00:15:01,519 --> 00:15:03,920
this type of attack will be exponent sub

372
00:15:03,920 --> 00:15:06,480
explanation but will also apply to the

373
00:15:06,480 --> 00:15:08,000
protocol

374
00:15:08,000 --> 00:15:09,760
note that the second part

375
00:15:09,760 --> 00:15:13,600
where we use multiple um subgroups on ek

376
00:15:13,600 --> 00:15:16,399
to then break the one more assumption

377
00:15:16,399 --> 00:15:17,839
remain the same as in the previous

378
00:15:17,839 --> 00:15:19,120
attack

379
00:15:19,120 --> 00:15:20,000
now

380
00:15:20,000 --> 00:15:22,639
we submit a point m again to the

381
00:15:22,639 --> 00:15:24,839
challenger and obtain the curve

382
00:15:24,839 --> 00:15:28,160
emt then we consider the isogeny from e0

383
00:15:28,160 --> 00:15:30,560
to em and backtrack

384
00:15:30,560 --> 00:15:31,519
a bit

385
00:15:31,519 --> 00:15:34,320
after we backtrack we deviate and go

386
00:15:34,320 --> 00:15:35,920
back to another curve

387
00:15:35,920 --> 00:15:40,240
here that has distance from e0 to the n

388
00:15:40,240 --> 00:15:42,399
so we can then submit the point

389
00:15:42,399 --> 00:15:44,000
corresponding to this curve to the

390
00:15:44,000 --> 00:15:45,759
challenger because this point will have

391
00:15:45,759 --> 00:15:47,040
four order

392
00:15:47,040 --> 00:15:49,440
and we obtain then

393
00:15:49,440 --> 00:15:51,600
a curve down here

394
00:15:51,600 --> 00:15:52,720
now

395
00:15:52,720 --> 00:15:56,000
since the degree of the secretization is

396
00:15:56,000 --> 00:15:59,199
co-prime with the degree of the exogeny

397
00:15:59,199 --> 00:16:01,600
of the client we have that

398
00:16:01,600 --> 00:16:04,959
the shared parent of these two curves

399
00:16:04,959 --> 00:16:08,240
corresponds to the image of this curve

400
00:16:08,240 --> 00:16:09,360
under the

401
00:16:09,360 --> 00:16:10,639
the correspond

402
00:16:10,639 --> 00:16:12,639
the curve under the exogeny

403
00:16:12,639 --> 00:16:14,720
5k of the server

404
00:16:14,720 --> 00:16:16,880
and we can re

405
00:16:16,880 --> 00:16:20,959
repeat this process several times

406
00:16:20,959 --> 00:16:22,880
by creating multiple points and then

407
00:16:22,880 --> 00:16:24,959
checking for their common parents and

408
00:16:24,959 --> 00:16:26,240
then we can check for their common

409
00:16:26,240 --> 00:16:28,480
parents again and repeat this several

410
00:16:28,480 --> 00:16:31,920
times until we go back all the way to ek

411
00:16:31,920 --> 00:16:33,839
once again we recover all the

412
00:16:33,839 --> 00:16:36,800
intermediate curves from ek to enk so we

413
00:16:36,800 --> 00:16:37,839
recover

414
00:16:37,839 --> 00:16:40,560
testosterone from eka to emt the

415
00:16:40,560 --> 00:16:42,639
greenhouse origin

416
00:16:42,639 --> 00:16:44,079
once we have that

417
00:16:44,079 --> 00:16:46,079
the remaining part of the time is

418
00:16:46,079 --> 00:16:48,639
exactly the same as in the polynomial

419
00:16:48,639 --> 00:16:51,519
time attack

420
00:16:51,519 --> 00:16:54,399
the attack relies on building a binary

421
00:16:54,399 --> 00:16:55,680
tree

422
00:16:55,680 --> 00:16:58,399
to recompute all the intermediate occurs

423
00:16:58,399 --> 00:17:02,720
and thus resulting from ek to ek over a

424
00:17:02,720 --> 00:17:05,439
given point

425
00:17:05,439 --> 00:17:08,160
this attack can now work because all the

426
00:17:08,160 --> 00:17:11,039
curves on the bottom layer are two to

427
00:17:11,039 --> 00:17:14,720
the n away from e k and this order

428
00:17:14,720 --> 00:17:16,839
checking won't prevent this type of

429
00:17:16,839 --> 00:17:20,160
attack the complexity of building these

430
00:17:20,160 --> 00:17:21,039
three

431
00:17:21,039 --> 00:17:23,039
depends on

432
00:17:23,039 --> 00:17:25,919
the number of queries that we are using

433
00:17:25,919 --> 00:17:28,240
a higher number of queries will mean

434
00:17:28,240 --> 00:17:30,720
that we have a higher number of curves

435
00:17:30,720 --> 00:17:33,360
on the bottom layer and this

436
00:17:33,360 --> 00:17:35,919
multiple computations are required to

437
00:17:35,919 --> 00:17:37,840
build the entire tree

438
00:17:37,840 --> 00:17:40,640
conversely if we use fewer queries

439
00:17:40,640 --> 00:17:41,600
then

440
00:17:41,600 --> 00:17:44,640
we will have fewer curves on the bottom

441
00:17:44,640 --> 00:17:46,799
layer and there's fewer computations and

442
00:17:46,799 --> 00:17:49,360
fewer steps needed to object to ek

443
00:17:49,360 --> 00:17:51,520
however when we use a higher number of

444
00:17:51,520 --> 00:17:53,679
queries the curves

445
00:17:53,679 --> 00:17:56,320
are closer together and thus computing a

446
00:17:56,320 --> 00:17:59,520
common parent will be faster indeed to

447
00:17:59,520 --> 00:18:01,200
compute a common parent we use a

448
00:18:01,200 --> 00:18:02,640
meet-in-the-middle approach with

449
00:18:02,640 --> 00:18:04,320
complexity depends on the distance

450
00:18:04,320 --> 00:18:06,640
between the two curves

451
00:18:06,640 --> 00:18:09,760
if we use fewer queries then we will

452
00:18:09,760 --> 00:18:11,440
require fewer meet-in-the-middle

453
00:18:11,440 --> 00:18:14,320
computations but the complexity of each

454
00:18:14,320 --> 00:18:16,559
would be higher

455
00:18:16,559 --> 00:18:19,120
and this explains the flexibility of our

456
00:18:19,120 --> 00:18:22,559
attack indeed our attack allows to

457
00:18:22,559 --> 00:18:25,200
easily trade off queries for complexity

458
00:18:25,200 --> 00:18:28,240
and vice versa

459
00:18:28,240 --> 00:18:31,039
to show that such an attack always

460
00:18:31,039 --> 00:18:34,320
brings a positive impact on

461
00:18:34,320 --> 00:18:37,360
and can always decrease the security we

462
00:18:37,360 --> 00:18:39,919
showed that with as few as two queries

463
00:18:39,919 --> 00:18:42,480
we already reduced the complexity of the

464
00:18:42,480 --> 00:18:47,120
attack from lambda to 2 lambda over 3.

465
00:18:47,120 --> 00:18:49,039
moreover the

466
00:18:49,039 --> 00:18:51,919
attack can be highly parallelizable that

467
00:18:51,919 --> 00:18:54,400
is because the computation that takes

468
00:18:54,400 --> 00:18:56,640
place in one side of the tree are

469
00:18:56,640 --> 00:18:58,000
completely independent from the

470
00:18:58,000 --> 00:19:00,720
computations on the other side

471
00:19:00,720 --> 00:19:01,760
which

472
00:19:01,760 --> 00:19:03,760
means that we can then traverse the tree

473
00:19:03,760 --> 00:19:07,280
on a breath first approach and thus

474
00:19:07,280 --> 00:19:10,320
paralyze the different branches on the

475
00:19:10,320 --> 00:19:12,160
other hand if we do

476
00:19:12,160 --> 00:19:14,480
want to minimize the amount of memory

477
00:19:14,480 --> 00:19:16,880
required we can travel the tree in a

478
00:19:16,880 --> 00:19:20,000
depth-first manner which will require a

479
00:19:20,000 --> 00:19:21,679
higher computation time but will

480
00:19:21,679 --> 00:19:24,640
minimize the amount of memory

481
00:19:24,640 --> 00:19:29,200
thus to sum up we have a full sub attack

482
00:19:29,200 --> 00:19:30,000
that

483
00:19:30,000 --> 00:19:33,120
builds a binary tree to recover

484
00:19:33,120 --> 00:19:36,000
ek and points on ek

485
00:19:36,000 --> 00:19:37,760
and we'll then use the second part of

486
00:19:37,760 --> 00:19:39,440
the attack

487
00:19:39,440 --> 00:19:41,280
already presented for the qualifying

488
00:19:41,280 --> 00:19:42,880
attack

489
00:19:42,880 --> 00:19:45,679
and since we have this for

490
00:19:45,679 --> 00:19:47,600
trade-off between

491
00:19:47,600 --> 00:19:50,080
number of queries and overall complexity

492
00:19:50,080 --> 00:19:52,799
we can achieve a balanced

493
00:19:52,799 --> 00:19:56,400
trade-off when the number of queries is

494
00:19:56,400 --> 00:19:59,280
comparable to the complexity of the meet

495
00:19:59,280 --> 00:20:01,280
in the middle computations and when that

496
00:20:01,280 --> 00:20:02,720
happens we have an overall

497
00:20:02,720 --> 00:20:04,240
sub-exponential complexity for the

498
00:20:04,240 --> 00:20:05,360
effect

499
00:20:05,360 --> 00:20:07,760
note that this

500
00:20:07,760 --> 00:20:11,039
assumes that query computations have a

501
00:20:11,039 --> 00:20:13,520
unitary complexity

502
00:20:13,520 --> 00:20:15,760
in real world applications this is not

503
00:20:15,760 --> 00:20:18,240
the case because the server will require

504
00:20:18,240 --> 00:20:19,919
a certain amount of time to process the

505
00:20:19,919 --> 00:20:21,360
request and

506
00:20:21,360 --> 00:20:24,159
res output the

507
00:20:24,159 --> 00:20:27,280
the value of the opr

508
00:20:27,280 --> 00:20:28,960
however since the attack is highly

509
00:20:28,960 --> 00:20:31,200
flexible we can then take into

510
00:20:31,200 --> 00:20:34,000
consideration the

511
00:20:34,000 --> 00:20:37,600
computation times of the server and find

512
00:20:37,600 --> 00:20:40,960
the number of queries that minimize the

513
00:20:40,960 --> 00:20:43,360
running time of the attack

514
00:20:43,360 --> 00:20:45,679
an interesting point of this type of

515
00:20:45,679 --> 00:20:48,480
attack is that unlike the polytime

516
00:20:48,480 --> 00:20:50,000
attack

517
00:20:50,000 --> 00:20:53,120
cannot be easily prevented there are no

518
00:20:53,120 --> 00:20:55,120
simple or obvious counting measures that

519
00:20:55,120 --> 00:20:56,559
can afford the attack

520
00:20:56,559 --> 00:20:58,799
with one possible exception which is

521
00:20:58,799 --> 00:21:01,200
increasing the parameter size

522
00:21:01,200 --> 00:21:03,440
the attack of course is sub exponential

523
00:21:03,440 --> 00:21:06,240
non-volatile time yes if we increase the

524
00:21:06,240 --> 00:21:09,440
parameter enough we can

525
00:21:09,440 --> 00:21:12,880
make this type of attack costly enough

526
00:21:12,880 --> 00:21:15,440
however if we want to guarantee 128 bits

527
00:21:15,440 --> 00:21:17,600
of security we would have to use

528
00:21:17,600 --> 00:21:21,760
extremely large isolate degrees for 128

529
00:21:21,760 --> 00:21:24,320
bits of security the client will need to

530
00:21:24,320 --> 00:21:26,880
use isogenic degrees higher than due to

531
00:21:26,880 --> 00:21:30,080
the power of four thousands which is

532
00:21:30,080 --> 00:21:32,240
extremely not practical

533
00:21:32,240 --> 00:21:34,880
and of course there might be new adult

534
00:21:34,880 --> 00:21:37,280
and efficient countermeasures but this

535
00:21:37,280 --> 00:21:39,760
seems to be highly non-trivial to

536
00:21:39,760 --> 00:21:41,919
validate the correctness of the attack

537
00:21:41,919 --> 00:21:44,960
it shows its visibility in practice we

538
00:21:44,960 --> 00:21:48,880
implemented our attack in sage math and

539
00:21:48,880 --> 00:21:52,480
run the full attack on a laptop machine

540
00:21:52,480 --> 00:21:54,799
we remarked that this implementation is

541
00:21:54,799 --> 00:21:57,200
not particularly optimized so the

542
00:21:57,200 --> 00:22:00,080
results shown here provide some sort of

543
00:22:00,080 --> 00:22:03,520
lower bound to what it can be achieved

544
00:22:03,520 --> 00:22:05,360
on this side of the table we see the

545
00:22:05,360 --> 00:22:07,120
power of interviews

546
00:22:07,120 --> 00:22:09,919
including the size of the prime the bits

547
00:22:09,919 --> 00:22:12,960
of security and the degree of the

548
00:22:12,960 --> 00:22:15,200
esogenic corresponding to the client

549
00:22:15,200 --> 00:22:16,880
where q denotes the exponent of the

550
00:22:16,880 --> 00:22:19,440
number of queries so in this attack we

551
00:22:19,440 --> 00:22:22,080
use two to the three queries up to the

552
00:22:22,080 --> 00:22:24,480
18th queries

553
00:22:24,480 --> 00:22:26,159
in the middle section we see the

554
00:22:26,159 --> 00:22:27,840
parameters correspond to the meeting the

555
00:22:27,840 --> 00:22:30,720
middle part where the distance distance

556
00:22:30,720 --> 00:22:33,360
between two curves as well as its memory

557
00:22:33,360 --> 00:22:34,559
requirements

558
00:22:34,559 --> 00:22:37,520
and eventually we have the running time

559
00:22:37,520 --> 00:22:39,679
of the complete attack

560
00:22:39,679 --> 00:22:42,240
as you can see the running time does

561
00:22:42,240 --> 00:22:45,679
grow quite quickly but for 67 bits of

562
00:22:45,679 --> 00:22:47,520
security we can

563
00:22:47,520 --> 00:22:49,600
compute the entire attack in less than

564
00:22:49,600 --> 00:22:52,240
two days which is a complete break of

565
00:22:52,240 --> 00:22:54,480
the security guarantees and while we

566
00:22:54,480 --> 00:22:57,679
didn't run the full attack for 120 it's

567
00:22:57,679 --> 00:23:00,559
a security we were able to estimate the

568
00:23:00,559 --> 00:23:02,559
overall running time based on partial

569
00:23:02,559 --> 00:23:05,360
results and we saw that the attack

570
00:23:05,360 --> 00:23:08,559
should take less than six years

571
00:23:08,559 --> 00:23:11,440
once again this implementation is not

572
00:23:11,440 --> 00:23:13,760
particularly optimized and does not run

573
00:23:13,760 --> 00:23:16,640
on a powerful machine so

574
00:23:16,640 --> 00:23:18,880
a better implementation running on a

575
00:23:18,880 --> 00:23:21,520
cluster will be able to significantly

576
00:23:21,520 --> 00:23:24,400
reduce the running time of the attack

577
00:23:24,400 --> 00:23:27,760
and our code is available on github so

578
00:23:27,760 --> 00:23:30,799
feel free to check it out

579
00:23:32,880 --> 00:23:35,120
lastly we want to discuss how the

580
00:23:35,120 --> 00:23:38,480
starting curve is selected

581
00:23:38,480 --> 00:23:40,960
the paper does not specify how the

582
00:23:40,960 --> 00:23:43,200
starting curve is chosen besides saying

583
00:23:43,200 --> 00:23:45,679
that it should be random however there

584
00:23:45,679 --> 00:23:47,520
is no

585
00:23:47,520 --> 00:23:50,159
angle to compute a random super singular

586
00:23:50,159 --> 00:23:53,039
curve at the moment because some party

587
00:23:53,039 --> 00:23:55,760
needs to pick it and we have several

588
00:23:55,760 --> 00:23:58,240
possibilities including the client a

589
00:23:58,240 --> 00:24:00,880
third party the server using a known

590
00:24:00,880 --> 00:24:03,200
curve or having to rely on the trustee

591
00:24:03,200 --> 00:24:04,880
set up

592
00:24:04,880 --> 00:24:07,279
if the client or a third party choose

593
00:24:07,279 --> 00:24:09,440
the curve they can choose to back the

594
00:24:09,440 --> 00:24:11,360
rate

595
00:24:11,360 --> 00:24:13,360
this means that if

596
00:24:13,360 --> 00:24:15,679
a backed or curve is used

597
00:24:15,679 --> 00:24:17,600
the server is then vulnerable to a key

598
00:24:17,600 --> 00:24:19,600
recovery attack using torsion point

599
00:24:19,600 --> 00:24:20,720
attacks

600
00:24:20,720 --> 00:24:21,760
which

601
00:24:21,760 --> 00:24:25,120
would reveal the key k of the server and

602
00:24:25,120 --> 00:24:29,039
would completely break the opr protocol

603
00:24:29,039 --> 00:24:31,279
secondly the server

604
00:24:31,279 --> 00:24:33,840
may choose the curve or a known curve

605
00:24:33,840 --> 00:24:37,520
such as g e 1728 may be chosen however

606
00:24:37,520 --> 00:24:39,679
if the server knows the endomorphic

607
00:24:39,679 --> 00:24:43,120
string of starting curve

608
00:24:43,120 --> 00:24:44,880
this can lead to a simple attack that

609
00:24:44,880 --> 00:24:46,320
breaks the super singularisogenic

610
00:24:46,320 --> 00:24:48,799
collision assumption using the security

611
00:24:48,799 --> 00:24:50,880
proof of the protocol

612
00:24:50,880 --> 00:24:53,440
at this stage it is not clear yet

613
00:24:53,440 --> 00:24:56,240
whether breaking the assumption leads to

614
00:24:56,240 --> 00:24:59,120
breaking um some security properties of

615
00:24:59,120 --> 00:25:01,440
the protocol because it seems like the

616
00:25:01,440 --> 00:25:02,799
protocol

617
00:25:02,799 --> 00:25:06,400
is slightly more involved than what the

618
00:25:06,400 --> 00:25:08,480
security assumption proves

619
00:25:08,480 --> 00:25:09,760
however

620
00:25:09,760 --> 00:25:12,480
since the security guarantees are not

621
00:25:12,480 --> 00:25:14,960
clear when the server knows the end of

622
00:25:14,960 --> 00:25:16,000
the ring

623
00:25:16,000 --> 00:25:18,559
and since if the client or third party

624
00:25:18,559 --> 00:25:20,080
issues the curve

625
00:25:20,080 --> 00:25:22,480
that can lead to a full key recovery

626
00:25:22,480 --> 00:25:24,240
attack on the server

627
00:25:24,240 --> 00:25:29,440
at the moment a trusted setup is needed

628
00:25:29,440 --> 00:25:30,640
to sum up

629
00:25:30,640 --> 00:25:34,000
we presented two attacks that break the

630
00:25:34,000 --> 00:25:36,880
one more assumption used in the security

631
00:25:36,880 --> 00:25:39,679
proof of the protocol and we also showed

632
00:25:39,679 --> 00:25:40,559
that

633
00:25:40,559 --> 00:25:41,679
one of the two attacks the

634
00:25:41,679 --> 00:25:44,559
sub-exponential one leads to an attack

635
00:25:44,559 --> 00:25:47,360
on the prf protocol where after a

636
00:25:47,360 --> 00:25:50,240
sub-exponential amount of queries and a

637
00:25:50,240 --> 00:25:52,720
sub-exponential amount of computations

638
00:25:52,720 --> 00:25:56,159
we can then evaluate the opref without

639
00:25:56,159 --> 00:25:57,919
further interacting with the server

640
00:25:57,919 --> 00:26:01,200
which defeats the entire purpose of a no

641
00:26:01,200 --> 00:26:03,360
prs protocol

642
00:26:03,360 --> 00:26:06,960
we also provide an implementation that

643
00:26:06,960 --> 00:26:08,799
demonstrates the attack is feasible in

644
00:26:08,799 --> 00:26:12,640
practice and does sensibly reduce the

645
00:26:12,640 --> 00:26:15,279
security guarantees of the protocol

646
00:26:15,279 --> 00:26:17,440
and eventually we also discussed the

647
00:26:17,440 --> 00:26:19,600
need for a trusted setup

648
00:26:19,600 --> 00:26:22,640
for future work we want to

649
00:26:22,640 --> 00:26:24,159
look into improving the attack

650
00:26:24,159 --> 00:26:26,320
complexity

651
00:26:26,320 --> 00:26:28,640
ideally reducing the sub-exponential

652
00:26:28,640 --> 00:26:31,919
attack to a polynomial one as well as

653
00:26:31,919 --> 00:26:33,520
develop new and efficient

654
00:26:33,520 --> 00:26:35,120
countermeasures that can prevent this

655
00:26:35,120 --> 00:26:36,799
type of attack

656
00:26:36,799 --> 00:26:38,400
we are also interested

657
00:26:38,400 --> 00:26:40,480
in studying the trusses attack

658
00:26:40,480 --> 00:26:43,840
requirements and either

659
00:26:43,840 --> 00:26:46,240
showing that attack on the assumption

660
00:26:46,240 --> 00:26:49,039
leads an attack on the protocol or

661
00:26:49,039 --> 00:26:51,520
amending the security proof to show that

662
00:26:51,520 --> 00:26:53,760
this attack does not actually apply to

663
00:26:53,760 --> 00:26:55,200
the protocol

664
00:26:55,200 --> 00:26:56,640
if you have any questions feel free to

665
00:26:56,640 --> 00:26:58,559
check out our paper available on the

666
00:26:58,559 --> 00:27:01,200
eprint or reach out to me or any of my

667
00:27:01,200 --> 00:27:02,960
co-authors thank you very much for your

668
00:27:02,960 --> 00:27:05,960
attention

