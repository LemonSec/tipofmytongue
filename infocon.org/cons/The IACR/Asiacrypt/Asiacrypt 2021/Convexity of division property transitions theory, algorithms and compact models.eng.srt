1
00:00:00,960 --> 00:00:04,319
welcome everybody to asia equipped 2021

2
00:00:04,319 --> 00:00:06,399
my name is alexis obenko and i will be

3
00:00:06,399 --> 00:00:08,559
talking about convexity of division

4
00:00:08,559 --> 00:00:10,160
property transitions

5
00:00:10,160 --> 00:00:12,639
theory algorithms and compact models

6
00:00:12,639 --> 00:00:15,040
enjoy

7
00:00:15,679 --> 00:00:17,440
first i would like to provide a quick

8
00:00:17,440 --> 00:00:19,760
high-level overview of the work

9
00:00:19,760 --> 00:00:21,920
the work studies division property which

10
00:00:21,920 --> 00:00:23,359
is a great analysis technique for

11
00:00:23,359 --> 00:00:24,960
symmetric ciphers

12
00:00:24,960 --> 00:00:26,400
there are many variants of division

13
00:00:26,400 --> 00:00:28,400
property and this work focuses on the

14
00:00:28,400 --> 00:00:30,240
earliest and the most widely applicable

15
00:00:30,240 --> 00:00:30,960
one

16
00:00:30,960 --> 00:00:33,520
big based to subset division property

17
00:00:33,520 --> 00:00:35,520
also called traditional or conventional

18
00:00:35,520 --> 00:00:37,280
division property

19
00:00:37,280 --> 00:00:39,440
it was introduced by todo at eurocrypt

20
00:00:39,440 --> 00:00:41,120
2015.

21
00:00:41,120 --> 00:00:43,200
the contributions of our work include

22
00:00:43,200 --> 00:00:45,760
new theoretic insights such as closed

23
00:00:45,760 --> 00:00:47,920
links of division property propagation

24
00:00:47,920 --> 00:00:50,480
with graphs of analyzed functions

25
00:00:50,480 --> 00:00:52,800
which lead to one of the key results a

26
00:00:52,800 --> 00:00:54,960
new compact representation of division

27
00:00:54,960 --> 00:00:57,120
property propagation suitable for

28
00:00:57,120 --> 00:00:59,600
modelling by sat solvers

29
00:00:59,600 --> 00:01:02,000
in addition we describe new algorithms

30
00:01:02,000 --> 00:01:03,840
for computing propagation tables and

31
00:01:03,840 --> 00:01:05,760
compact representations in quadratic

32
00:01:05,760 --> 00:01:08,000
time improving previous cubic time

33
00:01:08,000 --> 00:01:09,200
approaches

34
00:01:09,200 --> 00:01:10,960
as a proof of concept we studied the

35
00:01:10,960 --> 00:01:13,840
super sbox model of led which was

36
00:01:13,840 --> 00:01:15,840
impractical by previous methods and was

37
00:01:15,840 --> 00:01:17,439
challenged in the recent work of their

38
00:01:17,439 --> 00:01:19,840
best and

39
00:01:19,840 --> 00:01:21,520
now i'm going to introduce all the

40
00:01:21,520 --> 00:01:23,840
relevant concepts required for the work

41
00:01:23,840 --> 00:01:25,680
including division property working with

42
00:01:25,680 --> 00:01:28,000
the partial order or bit vectors and

43
00:01:28,000 --> 00:01:31,280
formalization of division property

44
00:01:31,280 --> 00:01:33,439
consider a cryptographic primitive built

45
00:01:33,439 --> 00:01:35,200
from iterations of a simple round

46
00:01:35,200 --> 00:01:37,680
function for example a block cipher or a

47
00:01:37,680 --> 00:01:39,200
stream cipher

48
00:01:39,200 --> 00:01:41,600
in integral clip analysis we want to

49
00:01:41,600 --> 00:01:43,920
know whether the multivariate polynomial

50
00:01:43,920 --> 00:01:46,079
expression of an output bit of the

51
00:01:46,079 --> 00:01:48,560
primitive may contain a chosen monomial

52
00:01:48,560 --> 00:01:50,240
of the input variables

53
00:01:50,240 --> 00:01:52,320
if the presence of the monomial does not

54
00:01:52,320 --> 00:01:54,720
depend on the involved secret keys

55
00:01:54,720 --> 00:01:56,560
we obtain a distinguisher from a random

56
00:01:56,560 --> 00:01:58,560
function which can be used to attack the

57
00:01:58,560 --> 00:01:59,680
primitive

58
00:01:59,680 --> 00:02:01,520
the core idea of division property is

59
00:02:01,520 --> 00:02:03,040
very simple

60
00:02:03,040 --> 00:02:06,399
in order for y0 as a function of x

61
00:02:06,399 --> 00:02:09,758
to contain the monomial x0 x1 x2

62
00:02:09,758 --> 00:02:11,840
there must exist a sequence of monomials

63
00:02:11,840 --> 00:02:13,599
in the intermediate states

64
00:02:13,599 --> 00:02:15,680
such as at each step the product of

65
00:02:15,680 --> 00:02:18,239
functions defined by the output monomer

66
00:02:18,239 --> 00:02:20,959
contains the input monomial

67
00:02:20,959 --> 00:02:23,360
for example here the product of the bits

68
00:02:23,360 --> 00:02:26,480
of w with indexes 2 and 5 as a function

69
00:02:26,480 --> 00:02:28,879
of that may contain the monomial that

70
00:02:28,879 --> 00:02:30,640
won that 3.

71
00:02:30,640 --> 00:02:32,480
such a sequence is called a division

72
00:02:32,480 --> 00:02:34,879
trail and each step in it is called a

73
00:02:34,879 --> 00:02:37,280
division property transition

74
00:02:37,280 --> 00:02:39,440
usually division trails are searched

75
00:02:39,440 --> 00:02:42,400
using such or smt solvers or mlp

76
00:02:42,400 --> 00:02:43,920
optimizers

77
00:02:43,920 --> 00:02:46,080
in this work we focus on studying single

78
00:02:46,080 --> 00:02:48,160
step transitions in depth

79
00:02:48,160 --> 00:02:50,319
in particular we aim to find compact

80
00:02:50,319 --> 00:02:52,800
encodings of possible transitions into

81
00:02:52,800 --> 00:02:54,160
such solvers

82
00:02:54,160 --> 00:02:57,120
this process is often called modeling

83
00:02:57,120 --> 00:02:58,959
a notable difference with say linear or

84
00:02:58,959 --> 00:03:01,120
differential trails is that here the

85
00:03:01,120 --> 00:03:03,120
distinguisher holds only if there is no

86
00:03:03,120 --> 00:03:04,480
division trail

87
00:03:04,480 --> 00:03:06,319
otherwise we cannot conclude on the

88
00:03:06,319 --> 00:03:09,120
existence of the distinguisher

89
00:03:09,120 --> 00:03:10,879
i will now introduce some definitions

90
00:03:10,879 --> 00:03:12,560
related to the partial order on bit

91
00:03:12,560 --> 00:03:14,640
vectors that are used extensively in

92
00:03:14,640 --> 00:03:16,000
this work

93
00:03:16,000 --> 00:03:18,640
the order is defined as follows we say

94
00:03:18,640 --> 00:03:21,040
that a vector u is below or is equal to

95
00:03:21,040 --> 00:03:22,080
vector v

96
00:03:22,080 --> 00:03:24,319
if for each bit position the respective

97
00:03:24,319 --> 00:03:26,959
coordinate of u is smaller or equal than

98
00:03:26,959 --> 00:03:28,319
that of v

99
00:03:28,319 --> 00:03:30,000
on the slide you can see the partial

100
00:03:30,000 --> 00:03:32,080
order graph associated with a set of

101
00:03:32,080 --> 00:03:33,920
four bit vectors

102
00:03:33,920 --> 00:03:36,239
here edges go upwards and one h

103
00:03:36,239 --> 00:03:38,640
corresponds to flipping one zero bit

104
00:03:38,640 --> 00:03:40,879
into a bit equal to one

105
00:03:40,879 --> 00:03:42,400
then the partial order can be

106
00:03:42,400 --> 00:03:45,040
reformulated as follows a vector u is

107
00:03:45,040 --> 00:03:47,680
below or is equal to vector v if there

108
00:03:47,680 --> 00:03:49,760
is a directed path from u to v in this

109
00:03:49,760 --> 00:03:51,120
graph

110
00:03:51,120 --> 00:03:53,439
monotonicity and convexity are defined

111
00:03:53,439 --> 00:03:55,680
with respect to this partial order

112
00:03:55,680 --> 00:03:58,080
a set is called a lower set if there are

113
00:03:58,080 --> 00:04:01,360
no edges going from a non-element to an

114
00:04:01,360 --> 00:04:03,760
element of the set

115
00:04:03,760 --> 00:04:07,280
the upper set is defined analogously

116
00:04:07,280 --> 00:04:10,239
extreme elements which are maximal for

117
00:04:10,239 --> 00:04:12,480
the lower set and minimal for the upper

118
00:04:12,480 --> 00:04:13,439
set

119
00:04:13,439 --> 00:04:15,120
form a compact representation of

120
00:04:15,120 --> 00:04:16,959
monotone sets

121
00:04:16,959 --> 00:04:19,120
for upper sets extreme elements can be

122
00:04:19,120 --> 00:04:21,918
viewed as patterns with wild cards and

123
00:04:21,918 --> 00:04:23,680
ones

124
00:04:23,680 --> 00:04:26,000
for lower sets the patterns consist of

125
00:04:26,000 --> 00:04:28,720
wild cards and zeros

126
00:04:28,720 --> 00:04:30,800
they can be seen as vectorial upper or

127
00:04:30,800 --> 00:04:32,960
lower bounds

128
00:04:32,960 --> 00:04:35,600
a set is called convex if it has both

129
00:04:35,600 --> 00:04:37,600
lower and upper bounds

130
00:04:37,600 --> 00:04:40,000
in other words it is an intersection of

131
00:04:40,000 --> 00:04:43,759
a lower set and an upper set

132
00:04:43,759 --> 00:04:45,759
since we aim to model transitions for

133
00:04:45,759 --> 00:04:48,320
say assad solver we are interested in

134
00:04:48,320 --> 00:04:52,000
modeling this monotone or convex sets

135
00:04:52,000 --> 00:04:53,919
quite naturally an upper set can be

136
00:04:53,919 --> 00:04:56,639
modeled using a monotone dnf disjunction

137
00:04:56,639 --> 00:04:58,000
normal form

138
00:04:58,000 --> 00:04:59,919
where the number of the clauses is equal

139
00:04:59,919 --> 00:05:01,600
to the number of the minimal elements in

140
00:05:01,600 --> 00:05:02,800
the set

141
00:05:02,800 --> 00:05:04,560
for example the first clause here

142
00:05:04,560 --> 00:05:06,479
corresponds to bit vectors with the last

143
00:05:06,479 --> 00:05:08,560
two bits equal to one

144
00:05:08,560 --> 00:05:10,720
and all such vectors are included in the

145
00:05:10,720 --> 00:05:12,880
considered set

146
00:05:12,880 --> 00:05:14,720
alternatively an upper set can be

147
00:05:14,720 --> 00:05:16,960
modeled by cnf formula conjunction

148
00:05:16,960 --> 00:05:19,440
normal form it requires to consider the

149
00:05:19,440 --> 00:05:21,919
complementary lower set the size of the

150
00:05:21,919 --> 00:05:24,160
formula then is defined by the number of

151
00:05:24,160 --> 00:05:26,880
maximal elements in the complement

152
00:05:26,880 --> 00:05:28,639
it is worth noting that the compact

153
00:05:28,639 --> 00:05:30,400
representation is not always really

154
00:05:30,400 --> 00:05:33,280
compact in addition the gap between cnf

155
00:05:33,280 --> 00:05:35,840
and dnf representation can itself be

156
00:05:35,840 --> 00:05:37,360
huge

157
00:05:37,360 --> 00:05:39,440
however on practice there is a

158
00:05:39,440 --> 00:05:41,440
significant chance of large reduction in

159
00:05:41,440 --> 00:05:43,680
size of the representation increasing

160
00:05:43,680 --> 00:05:46,080
modelling possibilities

161
00:05:46,080 --> 00:05:48,000
finally a convex set can be trivially

162
00:05:48,000 --> 00:05:50,000
modeled by concatenating the lower and

163
00:05:50,000 --> 00:05:52,400
the upper bounds in the cnf form

164
00:05:52,400 --> 00:05:54,639
this method however doesn't work with

165
00:05:54,639 --> 00:05:57,039
dnf formulas notably and perhaps

166
00:05:57,039 --> 00:05:58,960
counterintuitively due to higher

167
00:05:58,960 --> 00:06:01,199
dimension the upper and the lower bounds

168
00:06:01,199 --> 00:06:03,759
can intersect as is shown in the example

169
00:06:03,759 --> 00:06:05,039
on the slide

170
00:06:05,039 --> 00:06:08,560
here the vector 1 0 1 0 is both minimal

171
00:06:08,560 --> 00:06:10,560
in the complementary upper set

172
00:06:10,560 --> 00:06:12,720
and maximal in the complementary lower

173
00:06:12,720 --> 00:06:13,759
set

174
00:06:13,759 --> 00:06:16,000
this phenomenon introduces some freedom

175
00:06:16,000 --> 00:06:17,680
into modeling we can choose for the

176
00:06:17,680 --> 00:06:19,840
elements in the intersection whether

177
00:06:19,840 --> 00:06:21,520
they should be removed by an upper set

178
00:06:21,520 --> 00:06:24,160
or by lower set

179
00:06:24,160 --> 00:06:26,319
i will now briefly recall formalization

180
00:06:26,319 --> 00:06:28,000
of division property

181
00:06:28,000 --> 00:06:30,960
at crypto 2016 buran canton introduced

182
00:06:30,960 --> 00:06:33,440
parity sets as another view of division

183
00:06:33,440 --> 00:06:34,639
property

184
00:06:34,639 --> 00:06:37,199
simply speaking parity sets capture

185
00:06:37,199 --> 00:06:39,840
which products of bits sum to one over

186
00:06:39,840 --> 00:06:41,680
the given set

187
00:06:41,680 --> 00:06:43,919
total's division property of a set can

188
00:06:43,919 --> 00:06:46,000
be defined simply as a lower bound on

189
00:06:46,000 --> 00:06:47,680
its parity set

190
00:06:47,680 --> 00:06:50,000
here upper closure simply means the

191
00:06:50,000 --> 00:06:53,440
smallest upper set containing k

192
00:06:53,440 --> 00:06:55,599
it can be shown that the parity set is

193
00:06:55,599 --> 00:06:57,840
basically equivalent to the algebraic

194
00:06:57,840 --> 00:06:59,759
normal form of the set's indicator

195
00:06:59,759 --> 00:07:02,000
function i recall that indicator

196
00:07:02,000 --> 00:07:04,639
function is a boolean function equal to

197
00:07:04,639 --> 00:07:07,120
one on the elements of the set and to

198
00:07:07,120 --> 00:07:09,680
zero on the known element the set

199
00:07:09,680 --> 00:07:12,479
in other words it represents the set as

200
00:07:12,479 --> 00:07:14,960
a function

201
00:07:14,960 --> 00:07:17,759
so using this link we can conclude that

202
00:07:17,759 --> 00:07:19,919
division property simply defines

203
00:07:19,919 --> 00:07:22,639
vectorial upper bounds or monomials in

204
00:07:22,639 --> 00:07:26,560
the a f of the indicator of the set

205
00:07:26,639 --> 00:07:28,720
recall the division trails i mentioned

206
00:07:28,720 --> 00:07:30,960
when introducing division property for

207
00:07:30,960 --> 00:07:34,000
example in the trail here i said before

208
00:07:34,000 --> 00:07:35,919
that we know that the product that one

209
00:07:35,919 --> 00:07:39,360
that's 3 may contain the monomer x0 x1

210
00:07:39,360 --> 00:07:42,560
x2 for some key k0

211
00:07:42,560 --> 00:07:44,400
to handle the secret keys being stored

212
00:07:44,400 --> 00:07:46,319
between the round functions in a more

213
00:07:46,319 --> 00:07:47,680
simple way

214
00:07:47,680 --> 00:07:50,000
we can relax the propagation rule to

215
00:07:50,000 --> 00:07:52,639
allow smaller products of z to contain

216
00:07:52,639 --> 00:07:54,720
larger monomials of x

217
00:07:54,720 --> 00:07:57,280
then we can ignore the secret keys

218
00:07:57,280 --> 00:07:59,360
for example we consider this transition

219
00:07:59,360 --> 00:08:00,639
valid if

220
00:08:00,639 --> 00:08:06,479
say z1 instead of z1z3 contains x0 x1 x2

221
00:08:06,479 --> 00:08:10,319
x5 instead of just x0 x1 x2

222
00:08:10,319 --> 00:08:12,479
where we consider only the function f0

223
00:08:12,479 --> 00:08:14,319
and no keys at all

224
00:08:14,319 --> 00:08:16,400
this manipulation introduces the

225
00:08:16,400 --> 00:08:18,800
monotonicity aspect because we can now

226
00:08:18,800 --> 00:08:20,319
add or remove variables from the

227
00:08:20,319 --> 00:08:22,400
products which is equivalent to flipping

228
00:08:22,400 --> 00:08:25,878
bits in exponents

229
00:08:26,160 --> 00:08:28,000
now i will describe new insights into

230
00:08:28,000 --> 00:08:29,919
division property transitions including

231
00:08:29,919 --> 00:08:32,399
new characterizations leading to compact

232
00:08:32,399 --> 00:08:34,320
representations and also exhibiting

233
00:08:34,320 --> 00:08:36,559
explicitly convexity of minimal

234
00:08:36,559 --> 00:08:39,199
transitions

235
00:08:39,440 --> 00:08:41,519
first recall the definition of the graph

236
00:08:41,519 --> 00:08:43,760
of a vectorial boolean function which is

237
00:08:43,760 --> 00:08:46,320
simply the set of all valid input output

238
00:08:46,320 --> 00:08:49,360
pairs of the function

239
00:08:49,519 --> 00:08:51,519
one of the main results of this work

240
00:08:51,519 --> 00:08:53,519
provides new characterizations of valid

241
00:08:53,519 --> 00:08:55,440
division property transitions in

242
00:08:55,440 --> 00:08:57,680
particular it turns out that the set of

243
00:08:57,680 --> 00:08:59,680
varied transitions through f

244
00:08:59,680 --> 00:09:02,399
coincides up to negating the input part

245
00:09:02,399 --> 00:09:04,160
with the division property of the graph

246
00:09:04,160 --> 00:09:06,240
of f as a set

247
00:09:06,240 --> 00:09:07,920
it is an interesting connection between

248
00:09:07,920 --> 00:09:09,920
the division property of a set and

249
00:09:09,920 --> 00:09:12,800
transitions of such division properties

250
00:09:12,800 --> 00:09:14,800
in addition it draws attention to the

251
00:09:14,800 --> 00:09:16,880
extreme elements which are minimal

252
00:09:16,880 --> 00:09:19,040
elements of the parity set of the graph

253
00:09:19,040 --> 00:09:22,399
or alternatively transitions u to v with

254
00:09:22,399 --> 00:09:24,800
maximal u and minimal v

255
00:09:24,800 --> 00:09:27,440
moreover thanks to the nf formulation of

256
00:09:27,440 --> 00:09:28,880
division property

257
00:09:28,880 --> 00:09:31,360
we can deduce that this extreme set

258
00:09:31,360 --> 00:09:34,160
coincides again up to some negations

259
00:09:34,160 --> 00:09:36,320
with a set of maximal monomials in the

260
00:09:36,320 --> 00:09:39,120
nf of the graph indicator function

261
00:09:39,120 --> 00:09:41,200
this link is in particular interesting

262
00:09:41,200 --> 00:09:43,519
due to a recent work by carla deriving

263
00:09:43,519 --> 00:09:45,680
new methods of degree bounds based on

264
00:09:45,680 --> 00:09:47,360
the degrees of the involved graph

265
00:09:47,360 --> 00:09:48,880
indicators

266
00:09:48,880 --> 00:09:50,480
i will focus on the extreme set of

267
00:09:50,480 --> 00:09:52,240
transitions highlighted by these

268
00:09:52,240 --> 00:09:54,399
characterizations as it will play the

269
00:09:54,399 --> 00:09:57,519
role of the compact representation

270
00:09:57,519 --> 00:09:59,600
and that's exactly how we define the

271
00:09:59,600 --> 00:10:01,839
compact representation which due to its

272
00:10:01,839 --> 00:10:05,600
utility we shall call the division core

273
00:10:05,600 --> 00:10:07,440
so the division core of a vectorial

274
00:10:07,440 --> 00:10:09,839
boolean function is simply the set of

275
00:10:09,839 --> 00:10:11,920
minimal elements of the parity set of

276
00:10:11,920 --> 00:10:13,200
its graph

277
00:10:13,200 --> 00:10:14,959
equivalently it is the set of

278
00:10:14,959 --> 00:10:18,079
transitions with maximal u and minimal v

279
00:10:18,079 --> 00:10:20,240
with the first part negated

280
00:10:20,240 --> 00:10:22,240
alternatively it is the bitwise negation

281
00:10:22,240 --> 00:10:24,399
of the set of maximal monomials in the

282
00:10:24,399 --> 00:10:27,600
nf of the graph indicator

283
00:10:27,600 --> 00:10:29,519
i would like to emphasize the difference

284
00:10:29,519 --> 00:10:31,519
with the notions from the literature

285
00:10:31,519 --> 00:10:33,600
since it may be confusing

286
00:10:33,600 --> 00:10:36,000
classic propagation of division property

287
00:10:36,000 --> 00:10:37,920
focuses on transitions which are called

288
00:10:37,920 --> 00:10:40,399
minimal or reduced which only require

289
00:10:40,399 --> 00:10:42,959
that the output vector v is minimal for

290
00:10:42,959 --> 00:10:45,279
every fixed input vector u

291
00:10:45,279 --> 00:10:47,279
the idea of considering every possible

292
00:10:47,279 --> 00:10:48,560
input vector

293
00:10:48,560 --> 00:10:50,240
comes from the table based modeling

294
00:10:50,240 --> 00:10:51,440
method

295
00:10:51,440 --> 00:10:53,600
first the table of all transitions is

296
00:10:53,600 --> 00:10:56,640
computed where for each input vector all

297
00:10:56,640 --> 00:10:58,240
possible output transitions are

298
00:10:58,240 --> 00:10:59,440
enumerated

299
00:10:59,440 --> 00:11:01,279
and then this table is modeled by an

300
00:11:01,279 --> 00:11:02,720
appropriate method

301
00:11:02,720 --> 00:11:04,399
here we instead

302
00:11:04,399 --> 00:11:06,480
avoid full enumeration of input vectors

303
00:11:06,480 --> 00:11:09,040
and record only constraints in some form

304
00:11:09,040 --> 00:11:10,320
which is achieved by considering

305
00:11:10,320 --> 00:11:12,399
transitions with a maximal input vector

306
00:11:12,399 --> 00:11:13,120
u

307
00:11:13,120 --> 00:11:15,440
a simple formulation then is that any

308
00:11:15,440 --> 00:11:17,680
valid transition should be equal to or

309
00:11:17,680 --> 00:11:19,600
lie above of some vector from the

310
00:11:19,600 --> 00:11:21,040
division core

311
00:11:21,040 --> 00:11:23,440
the compactness here is associated with

312
00:11:23,440 --> 00:11:25,040
the fact that we consider the set of

313
00:11:25,040 --> 00:11:26,800
minimal vectors

314
00:11:26,800 --> 00:11:28,640
i remind that it doesn't have strong

315
00:11:28,640 --> 00:11:31,200
guarantees on the size but provides very

316
00:11:31,200 --> 00:11:33,440
reasonable results in practice at least

317
00:11:33,440 --> 00:11:35,519
if compared with the enumeration of all

318
00:11:35,519 --> 00:11:37,200
input vectors

319
00:11:37,200 --> 00:11:38,880
finally i recall from the beginning of

320
00:11:38,880 --> 00:11:41,279
this talk that extreme sets lend

321
00:11:41,279 --> 00:11:44,240
themselves naturally to cnf or dnf

322
00:11:44,240 --> 00:11:48,560
modelling and so does the division core

323
00:11:48,560 --> 00:11:50,639
it is notable that solely from the

324
00:11:50,639 --> 00:11:53,200
division core we can deduce the full set

325
00:11:53,200 --> 00:11:55,360
of valid transitions or the full set of

326
00:11:55,360 --> 00:11:57,040
minimal transitions

327
00:11:57,040 --> 00:11:59,600
even more division core contains

328
00:11:59,600 --> 00:12:01,600
information about division transitions

329
00:12:01,600 --> 00:12:03,519
through the inverse of the function if

330
00:12:03,519 --> 00:12:05,120
it exists

331
00:12:05,120 --> 00:12:06,880
this highlights completeness of division

332
00:12:06,880 --> 00:12:09,440
core as representing the behavior of the

333
00:12:09,440 --> 00:12:11,519
function with respect to the traditional

334
00:12:11,519 --> 00:12:14,399
division property

335
00:12:14,399 --> 00:12:16,560
one last bit of the theory covers

336
00:12:16,560 --> 00:12:18,959
minimal transitions whereby minimal i

337
00:12:18,959 --> 00:12:21,279
mean the usual minimality under a fixed

338
00:12:21,279 --> 00:12:22,959
input vector u

339
00:12:22,959 --> 00:12:25,040
these transitions are important due to

340
00:12:25,040 --> 00:12:27,440
their utility in modeling where we want

341
00:12:27,440 --> 00:12:29,200
to reduce the search space as much as

342
00:12:29,200 --> 00:12:30,720
possible

343
00:12:30,720 --> 00:12:32,639
if we look at the full set of possible

344
00:12:32,639 --> 00:12:33,839
transitions

345
00:12:33,839 --> 00:12:36,639
invalid transitions form a lower set

346
00:12:36,639 --> 00:12:39,040
and redundant transitions form an upper

347
00:12:39,040 --> 00:12:40,480
set

348
00:12:40,480 --> 00:12:42,959
it follows that minimal transitions form

349
00:12:42,959 --> 00:12:44,560
a convex set

350
00:12:44,560 --> 00:12:47,600
it has both a lower and an upper bound

351
00:12:47,600 --> 00:12:50,079
therefore we can model it by cnn formula

352
00:12:50,079 --> 00:12:52,399
by removing the redundant upper set and

353
00:12:52,399 --> 00:12:54,880
the invalid lower set

354
00:12:54,880 --> 00:12:55,920
however

355
00:12:55,920 --> 00:12:58,240
due to the high dimensions involved the

356
00:12:58,240 --> 00:13:00,480
covering of non-minimal transitions by

357
00:13:00,480 --> 00:13:02,880
an upper set and the lower set is not

358
00:13:02,880 --> 00:13:05,360
unique we saw that already on the

359
00:13:05,360 --> 00:13:07,920
example from the convex set where the

360
00:13:07,920 --> 00:13:09,920
maximal complementary lower and upper

361
00:13:09,920 --> 00:13:12,399
sets actually intersected

362
00:13:12,399 --> 00:13:13,680
on practice

363
00:13:13,680 --> 00:13:15,839
we noticed that removing the maximal

364
00:13:15,839 --> 00:13:17,760
complementary upper set

365
00:13:17,760 --> 00:13:20,480
usually has more compact models in this

366
00:13:20,480 --> 00:13:21,440
case

367
00:13:21,440 --> 00:13:24,399
these side parts are removed twice

368
00:13:24,399 --> 00:13:26,160
by the lower bound and by the upper

369
00:13:26,160 --> 00:13:27,600
bound

370
00:13:27,600 --> 00:13:29,440
while this is a simplified picture it

371
00:13:29,440 --> 00:13:31,519
nicely conveys the idea

372
00:13:31,519 --> 00:13:33,760
all these sets and the extreme parts can

373
00:13:33,760 --> 00:13:36,000
be computed from the division core

374
00:13:36,000 --> 00:13:38,079
i would like to emphasize that here the

375
00:13:38,079 --> 00:13:40,079
minimal set is defined by considering

376
00:13:40,079 --> 00:13:42,720
each fixed vector u separately

377
00:13:42,720 --> 00:13:44,639
while in the figure we consider the full

378
00:13:44,639 --> 00:13:47,040
set of transitions this is precisely

379
00:13:47,040 --> 00:13:48,880
what allows to obtain more compact

380
00:13:48,880 --> 00:13:51,279
models

381
00:13:51,360 --> 00:13:53,839
here are examples on model size for some

382
00:13:53,839 --> 00:13:55,360
s-boxes

383
00:13:55,360 --> 00:13:58,399
for s-boxes we consider modeling the set

384
00:13:58,399 --> 00:14:00,800
of minimal transitions precisely

385
00:14:00,800 --> 00:14:03,279
in the table you can see the number of

386
00:14:03,279 --> 00:14:05,519
minimal transitions in the set and the

387
00:14:05,519 --> 00:14:08,639
size of the cnf representation using our

388
00:14:08,639 --> 00:14:11,199
methods and also using optimal modeling

389
00:14:11,199 --> 00:14:14,560
method the quine mcclaskey algorithm

390
00:14:14,560 --> 00:14:16,399
we can see that our representation is

391
00:14:16,399 --> 00:14:18,639
about twice as larger than the optimal

392
00:14:18,639 --> 00:14:19,600
one

393
00:14:19,600 --> 00:14:21,440
the problem with the optimal one is that

394
00:14:21,440 --> 00:14:23,920
it doesn't scale well obtaining even

395
00:14:23,920 --> 00:14:26,560
sub-optimal results using the quan

396
00:14:26,560 --> 00:14:28,800
mclasky algorithm quickly becomes

397
00:14:28,800 --> 00:14:31,600
invisible for larger s-box sizes while

398
00:14:31,600 --> 00:14:34,720
our method scales reasonably well

399
00:14:34,720 --> 00:14:36,800
notably we observe very compact

400
00:14:36,800 --> 00:14:40,000
representation for heavy s-boxes that is

401
00:14:40,000 --> 00:14:42,079
those having most high degree monomials

402
00:14:42,079 --> 00:14:44,320
in their output bits or in small

403
00:14:44,320 --> 00:14:46,240
products of output bits

404
00:14:46,240 --> 00:14:49,120
for example the aes s-box has quite

405
00:14:49,120 --> 00:14:50,720
compact model

406
00:14:50,720 --> 00:14:53,519
misty s-boxes however have algebraic

407
00:14:53,519 --> 00:14:55,920
weaknesses which was exploited by todo

408
00:14:55,920 --> 00:14:58,800
in the attack on full misty and so have

409
00:14:58,800 --> 00:15:00,800
more complex and less compact structure

410
00:15:00,800 --> 00:15:03,360
of transitions

411
00:15:03,360 --> 00:15:06,160
for larger s-boxes i focus only on the

412
00:15:06,160 --> 00:15:08,320
number of constraints necessary to

413
00:15:08,320 --> 00:15:10,399
remove the invalid trails

414
00:15:10,399 --> 00:15:12,000
redundant trails can be removed

415
00:15:12,000 --> 00:15:14,720
imprecisely by much smaller formulas

416
00:15:14,720 --> 00:15:16,959
such as cardinality constraints

417
00:15:16,959 --> 00:15:19,279
we can model super sboxes with variant

418
00:15:19,279 --> 00:15:22,880
success for example strong leds super

419
00:15:22,880 --> 00:15:26,000
sbox can be modeled by about 300 000

420
00:15:26,000 --> 00:15:27,199
constraints

421
00:15:27,199 --> 00:15:29,680
while weaker midori's super sbox

422
00:15:29,680 --> 00:15:32,000
requires 2 millions

423
00:15:32,000 --> 00:15:34,560
for modern sat solvers it may be still

424
00:15:34,560 --> 00:15:36,320
in the feasible range but it really

425
00:15:36,320 --> 00:15:38,320
depends on the exact setup

426
00:15:38,320 --> 00:15:40,560
an interesting case is the heavy linear

427
00:15:40,560 --> 00:15:43,360
layer of led which is based on an mds

428
00:15:43,360 --> 00:15:44,560
matrix

429
00:15:44,560 --> 00:15:46,959
it was the source of complexity in the

430
00:15:46,959 --> 00:15:48,880
work by derbys and

431
00:15:48,880 --> 00:15:51,199
it can be modeled by just 30 000

432
00:15:51,199 --> 00:15:53,519
constraints using our method

433
00:15:53,519 --> 00:15:56,480
finally merely as a proof of concept

434
00:15:56,480 --> 00:15:59,040
we managed to model a randomly generated

435
00:15:59,040 --> 00:16:01,120
32-bit s-box

436
00:16:01,120 --> 00:16:03,839
as i mentioned before heavy s-boxes tend

437
00:16:03,839 --> 00:16:05,680
to have very compact representations

438
00:16:05,680 --> 00:16:08,079
which is nicely illustrated by this case

439
00:16:08,079 --> 00:16:10,240
where we need only three thousand enough

440
00:16:10,240 --> 00:16:14,000
clauses to model all valid transitions

441
00:16:14,000 --> 00:16:15,920
the compact representation is practice

442
00:16:15,920 --> 00:16:18,000
oriented so it is necessary to

443
00:16:18,000 --> 00:16:19,920
understand how to compute it and work

444
00:16:19,920 --> 00:16:21,360
with it in practice

445
00:16:21,360 --> 00:16:23,360
to this end we propose an elegant

446
00:16:23,360 --> 00:16:25,600
algorithmic framework capturing all the

447
00:16:25,600 --> 00:16:27,920
necessary manipulations

448
00:16:27,920 --> 00:16:30,160
the key algorithmic component we use is

449
00:16:30,160 --> 00:16:32,079
the slide generalization of the classic

450
00:16:32,079 --> 00:16:34,639
anf computation algorithm or the fast

451
00:16:34,639 --> 00:16:36,560
fourier transform

452
00:16:36,560 --> 00:16:38,880
these algorithms transform an array of

453
00:16:38,880 --> 00:16:42,160
size two to the n in quasi-linear time

454
00:16:42,160 --> 00:16:44,000
the basic function we use called

455
00:16:44,000 --> 00:16:46,639
transform takes an array of size two to

456
00:16:46,639 --> 00:16:47,680
the n

457
00:16:47,680 --> 00:16:49,199
which can be the two's table of a

458
00:16:49,199 --> 00:16:51,839
function or a set's indicator vector

459
00:16:51,839 --> 00:16:54,160
and transform it by two elements at a

460
00:16:54,160 --> 00:16:55,120
time

461
00:16:55,120 --> 00:16:56,959
such that indices of these elements

462
00:16:56,959 --> 00:16:59,519
differ in exactly one bit the parameter

463
00:16:59,519 --> 00:17:01,120
f of the algorithm

464
00:17:01,120 --> 00:17:03,279
is a two valid binary function described

465
00:17:03,279 --> 00:17:05,119
in the manipulation

466
00:17:05,119 --> 00:17:07,520
depending on this function we can obtain

467
00:17:07,520 --> 00:17:10,160
many useful bit oriented transformations

468
00:17:10,160 --> 00:17:12,640
the function sort up which source the

469
00:17:12,640 --> 00:17:14,559
first element to the second one

470
00:17:14,559 --> 00:17:16,240
corresponds simply to the merbus

471
00:17:16,240 --> 00:17:18,559
transform that is the classic nf

472
00:17:18,559 --> 00:17:20,319
computation

473
00:17:20,319 --> 00:17:22,400
sort down which stores the second

474
00:17:22,400 --> 00:17:24,720
element to the first one computes the

475
00:17:24,720 --> 00:17:26,799
parity set of a set

476
00:17:26,799 --> 00:17:28,559
this transformation is particularly

477
00:17:28,559 --> 00:17:30,960
important in view of our theorem

478
00:17:30,960 --> 00:17:32,960
which links the set of division property

479
00:17:32,960 --> 00:17:35,120
transitions with the parity set of the

480
00:17:35,120 --> 00:17:36,880
graph of the function

481
00:17:36,880 --> 00:17:39,760
or up and or down simply compute the

482
00:17:39,760 --> 00:17:41,600
upper closure and the lower closure

483
00:17:41,600 --> 00:17:44,480
respectively which are the minimal upper

484
00:17:44,480 --> 00:17:48,240
or lower sets containing the given set

485
00:17:48,240 --> 00:17:50,880
finally less up which replaces the

486
00:17:50,880 --> 00:17:52,799
second value with the n naught of the

487
00:17:52,799 --> 00:17:55,039
inputs computes the set of minimal

488
00:17:55,039 --> 00:17:57,200
vectors when called after the upper

489
00:17:57,200 --> 00:17:58,559
closure

490
00:17:58,559 --> 00:18:00,400
similarly we can compute the set of

491
00:18:00,400 --> 00:18:02,559
maximal elements

492
00:18:02,559 --> 00:18:04,960
again all these algorithms work in time

493
00:18:04,960 --> 00:18:08,000
and times to the end

494
00:18:08,000 --> 00:18:09,760
using these algorithms and our

495
00:18:09,760 --> 00:18:12,160
theoretical insights we can reduce a

496
00:18:12,160 --> 00:18:13,840
simple algorithm for computing the

497
00:18:13,840 --> 00:18:15,840
division property propagation table of a

498
00:18:15,840 --> 00:18:16,880
function

499
00:18:16,880 --> 00:18:18,799
which improves previous algorithms

500
00:18:18,799 --> 00:18:21,039
mainly due to the non-heuristic mean set

501
00:18:21,039 --> 00:18:22,640
step

502
00:18:22,640 --> 00:18:24,799
as a result we can compute all relevant

503
00:18:24,799 --> 00:18:28,000
sets for an s-box in quadratic time

504
00:18:28,000 --> 00:18:31,120
while previous algorithms were cubic

505
00:18:31,120 --> 00:18:33,360
in addition this framework can be

506
00:18:33,360 --> 00:18:35,360
implemented very efficiently in a bit

507
00:18:35,360 --> 00:18:38,080
slice fashion

508
00:18:38,080 --> 00:18:40,160
finally i will briefly mention our

509
00:18:40,160 --> 00:18:43,440
application to led unfortunately

510
00:18:43,440 --> 00:18:45,600
while compact modelling greatly expands

511
00:18:45,600 --> 00:18:48,240
visibility of modern division property

512
00:18:48,240 --> 00:18:49,919
we couldn't find other interesting

513
00:18:49,919 --> 00:18:53,280
applications with large s-boxes

514
00:18:53,280 --> 00:18:55,039
led is a lightweight box cypher

515
00:18:55,039 --> 00:18:57,600
published a chest 10 years ago

516
00:18:57,600 --> 00:18:59,679
best integral distinguisher is on seven

517
00:18:59,679 --> 00:19:02,960
rounds due to who one guang who used an

518
00:19:02,960 --> 00:19:05,280
smt solver to model the linear layer

519
00:19:05,280 --> 00:19:07,520
precisely for the first time

520
00:19:07,520 --> 00:19:09,919
i recall that with our method we can

521
00:19:09,919 --> 00:19:13,120
modulate with cnf directly

522
00:19:13,120 --> 00:19:15,520
recently their base and applied

523
00:19:15,520 --> 00:19:18,320
ad-hoc dividend trail search using super

524
00:19:18,320 --> 00:19:20,720
sbox models of ciphers and linear

525
00:19:20,720 --> 00:19:22,559
combinations of bits and the input and

526
00:19:22,559 --> 00:19:25,120
at the output their method was not

527
00:19:25,120 --> 00:19:27,600
practical for led due to its complex

528
00:19:27,600 --> 00:19:28,960
linear layer

529
00:19:28,960 --> 00:19:31,280
therefore the question remained open

530
00:19:31,280 --> 00:19:33,520
whether the super sbox model with linear

531
00:19:33,520 --> 00:19:35,600
combinations can find h round

532
00:19:35,600 --> 00:19:38,320
distinguisher or not

533
00:19:38,320 --> 00:19:40,880
our compact models for led are rather

534
00:19:40,880 --> 00:19:43,200
large but reasonable and fire well with

535
00:19:43,200 --> 00:19:46,240
modern sat solvers such as kisat

536
00:19:46,240 --> 00:19:48,160
the eight round model for a fixed linear

537
00:19:48,160 --> 00:19:50,400
combination is solved in about one

538
00:19:50,400 --> 00:19:52,320
minute

539
00:19:52,320 --> 00:19:54,720
we exhausted all linear combinations but

540
00:19:54,720 --> 00:19:57,120
found no 8 round distinguishers

541
00:19:57,120 --> 00:19:59,280
therefore one has to go beyond this

542
00:19:59,280 --> 00:20:03,200
module to find them if they exist

543
00:20:03,200 --> 00:20:05,039
here we can see an example division

544
00:20:05,039 --> 00:20:06,640
trail for led

545
00:20:06,640 --> 00:20:08,880
the first column in the first transition

546
00:20:08,880 --> 00:20:10,880
covers a subset of all possible linear

547
00:20:10,880 --> 00:20:13,200
masks alpha that correspond to a

548
00:20:13,200 --> 00:20:15,520
constant component at the inputs supers

549
00:20:15,520 --> 00:20:16,640
box

550
00:20:16,640 --> 00:20:18,960
similarly the first column in the last

551
00:20:18,960 --> 00:20:21,280
transition covers a subset of all

552
00:20:21,280 --> 00:20:23,440
possible linear masks better

553
00:20:23,440 --> 00:20:25,679
that correspond to a considered output

554
00:20:25,679 --> 00:20:28,240
component

555
00:20:28,559 --> 00:20:30,480
we found that all possible pairs of

556
00:20:30,480 --> 00:20:34,559
masks alpha beta can be covered by 255

557
00:20:34,559 --> 00:20:37,120
different columns on each side

558
00:20:37,120 --> 00:20:39,600
this means that all combinations can be

559
00:20:39,600 --> 00:20:41,360
checked by running the start solver

560
00:20:41,360 --> 00:20:43,520
almost 2 to 16 times

561
00:20:43,520 --> 00:20:45,679
which is quite a lot

562
00:20:45,679 --> 00:20:48,080
on practice we found that a small set of

563
00:20:48,080 --> 00:20:50,720
discovered trails is sufficient to cover

564
00:20:50,720 --> 00:20:52,320
all possible pairs

565
00:20:52,320 --> 00:20:54,400
so that assault solver has to be run

566
00:20:54,400 --> 00:20:58,000
only a few dozens of times

567
00:20:58,080 --> 00:21:00,240
to conclude please look for more results

568
00:21:00,240 --> 00:21:02,000
in the paper and check out the code

569
00:21:02,000 --> 00:21:04,000
repository which has convenient

570
00:21:04,000 --> 00:21:05,440
implementations of the described

571
00:21:05,440 --> 00:21:06,960
techniques

572
00:21:06,960 --> 00:21:08,240
there are still many interesting

573
00:21:08,240 --> 00:21:11,039
problems left such as compressing cnf

574
00:21:11,039 --> 00:21:14,080
models into compact mlp models or using

575
00:21:14,080 --> 00:21:15,760
more advanced techniques to find or

576
00:21:15,760 --> 00:21:17,679
prove in existence of an 8 round

577
00:21:17,679 --> 00:21:20,000
distinguisher for led

578
00:21:20,000 --> 00:21:21,919
and of course we hope the new techniques

579
00:21:21,919 --> 00:21:24,159
will find more applications

580
00:21:24,159 --> 00:21:26,080
thank you and i will be happy to answer

581
00:21:26,080 --> 00:21:29,240
your questions

582
00:21:40,559 --> 00:21:42,639
you

