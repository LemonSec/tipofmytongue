1
00:00:00,240 --> 00:00:02,320
today

2
00:00:02,320 --> 00:00:04,720
my apologies but please go ahead

3
00:00:04,720 --> 00:00:06,879
yes thank you we are very pleased today

4
00:00:06,879 --> 00:00:08,480
to present

5
00:00:08,480 --> 00:00:10,480
this session of asia crypt

6
00:00:10,480 --> 00:00:13,360
called uh physical attacks leakage

7
00:00:13,360 --> 00:00:15,440
encounter measures

8
00:00:15,440 --> 00:00:17,840
we will have six wonderful papers in

9
00:00:17,840 --> 00:00:19,119
this session

10
00:00:19,119 --> 00:00:21,119
and we will start with

11
00:00:21,119 --> 00:00:24,240
secure and efficient software masking on

12
00:00:24,240 --> 00:00:27,279
super scalar pipeline processors

13
00:00:27,279 --> 00:00:30,480
that will be presented by barbara eagle

14
00:00:30,480 --> 00:00:33,760
barbara the floor is yours

15
00:00:33,760 --> 00:00:37,830
hello thank you for the introduction

16
00:00:37,830 --> 00:00:41,150
[Music]

17
00:00:41,200 --> 00:00:44,160
you can see my presentation right

18
00:00:44,160 --> 00:00:45,440
yes we do

19
00:00:45,440 --> 00:00:47,520
okay thank you

20
00:00:47,520 --> 00:00:50,800
so yeah welcome to my presentation um so

21
00:00:50,800 --> 00:00:52,480
in the setting of physically side

22
00:00:52,480 --> 00:00:53,920
channel attacks

23
00:00:53,920 --> 00:00:55,760
um we have a certain cryptographic

24
00:00:55,760 --> 00:00:57,840
device and an attacker who wants to

25
00:00:57,840 --> 00:00:59,920
attack the device who has physically

26
00:00:59,920 --> 00:01:02,640
access to the device also and can mount

27
00:01:02,640 --> 00:01:05,360
therefore things like a power analysis

28
00:01:05,360 --> 00:01:06,400
attack

29
00:01:06,400 --> 00:01:08,560
masking is one counter-measure we can

30
00:01:08,560 --> 00:01:10,720
apply against these attacks where we

31
00:01:10,720 --> 00:01:12,960
split a sensitive value for example in

32
00:01:12,960 --> 00:01:15,119
our mask software into multiple random

33
00:01:15,119 --> 00:01:16,240
shares

34
00:01:16,240 --> 00:01:18,880
the problem however here is that it

35
00:01:18,880 --> 00:01:20,799
relies on

36
00:01:20,799 --> 00:01:22,880
an assumption that independent

37
00:01:22,880 --> 00:01:24,799
computations result in independent

38
00:01:24,799 --> 00:01:27,280
leakage and this is what unfortunately

39
00:01:27,280 --> 00:01:30,720
not always fulfilled by microprocessors

40
00:01:30,720 --> 00:01:33,520
there exists several solutions to it but

41
00:01:33,520 --> 00:01:35,200
they all have in common that the

42
00:01:35,200 --> 00:01:36,640
software

43
00:01:36,640 --> 00:01:39,920
has increased run time and we also need

44
00:01:39,920 --> 00:01:42,479
still manual leakage assessments to make

45
00:01:42,479 --> 00:01:44,799
sure that the mask software is really

46
00:01:44,799 --> 00:01:48,159
secure on our microprocessor

47
00:01:48,159 --> 00:01:51,040
in our work we wanted to focus on

48
00:01:51,040 --> 00:01:53,759
mask software for more complex processes

49
00:01:53,759 --> 00:01:56,079
so where you can barely do any manual

50
00:01:56,079 --> 00:01:59,119
measurements and assessments anymore

51
00:01:59,119 --> 00:02:02,719
we stick therefore to a former approach

52
00:02:02,719 --> 00:02:05,600
in our case study we focus on the 32-bit

53
00:02:05,600 --> 00:02:07,280
risk five swerve core

54
00:02:07,280 --> 00:02:09,679
which is one of these complex processes

55
00:02:09,679 --> 00:02:12,080
for example it has nine pipeline stages

56
00:02:12,080 --> 00:02:14,480
and a dual issue pipeline

57
00:02:14,480 --> 00:02:16,879
the main conclusions of our work are

58
00:02:16,879 --> 00:02:18,720
that first of all there are several

59
00:02:18,720 --> 00:02:21,120
components in the swerve core which will

60
00:02:21,120 --> 00:02:23,760
cause problems related to masking and if

61
00:02:23,760 --> 00:02:26,000
you want to fix these problems we can do

62
00:02:26,000 --> 00:02:28,160
that on hardware or software level

63
00:02:28,160 --> 00:02:29,360
however

64
00:02:29,360 --> 00:02:32,239
hardware solutions often have such a

65
00:02:32,239 --> 00:02:35,519
high latency that we cannot really

66
00:02:35,519 --> 00:02:37,200
implement then

67
00:02:37,200 --> 00:02:40,000
to be practical however if we want to

68
00:02:40,000 --> 00:02:42,000
fix that on software level we will still

69
00:02:42,000 --> 00:02:44,239
get the high overhead but now we can

70
00:02:44,239 --> 00:02:48,000
apply special implementation techniques

71
00:02:48,000 --> 00:02:50,160
which will allow us to have efficient

72
00:02:50,160 --> 00:02:53,280
mask software on our 12th core or on any

73
00:02:53,280 --> 00:02:56,560
other complex processors

74
00:02:56,560 --> 00:02:59,120
we use coco as a formal tool which will

75
00:02:59,120 --> 00:03:01,680
basically just verify that

76
00:03:01,680 --> 00:03:04,560
a mask assembly implementation runs

77
00:03:04,560 --> 00:03:07,680
securely on a given cpu netlist

78
00:03:07,680 --> 00:03:10,239
and in the case it's not secure it will

79
00:03:10,239 --> 00:03:11,360
give us

80
00:03:11,360 --> 00:03:13,599
the exact cycle and gate in the netlist

81
00:03:13,599 --> 00:03:16,640
by the legal cures

82
00:03:17,280 --> 00:03:19,680
the this tool has already been applied

83
00:03:19,680 --> 00:03:22,400
to a much smaller processor the ebx core

84
00:03:22,400 --> 00:03:24,080
and it was shown there that there are

85
00:03:24,080 --> 00:03:26,239
already several components in the e-box

86
00:03:26,239 --> 00:03:27,440
core

87
00:03:27,440 --> 00:03:29,519
which are problematic in the context of

88
00:03:29,519 --> 00:03:32,400
masking for example the register file

89
00:03:32,400 --> 00:03:35,440
when we did the first analysis with coco

90
00:03:35,440 --> 00:03:38,000
of the swerve core we found similar

91
00:03:38,000 --> 00:03:40,720
problems so therefore we carry over

92
00:03:40,720 --> 00:03:42,480
hardware fixes which were proposed for

93
00:03:42,480 --> 00:03:44,080
the small ebx core

94
00:03:44,080 --> 00:03:47,840
to the biggest verve core however still

95
00:03:47,840 --> 00:03:49,599
if we want to verify software

96
00:03:49,599 --> 00:03:52,159
implementations on the swath core

97
00:03:52,159 --> 00:03:54,319
this mask implementations will still

98
00:03:54,319 --> 00:03:56,879
lose several protection orders due to

99
00:03:56,879 --> 00:04:00,000
components in the cpu one example are

100
00:04:00,000 --> 00:04:02,400
pipelines and execution units

101
00:04:02,400 --> 00:04:05,760
so in this figure you see the

102
00:04:05,760 --> 00:04:08,400
the pipeline stages of this wealth core

103
00:04:08,400 --> 00:04:11,040
and you see that here is a multiplexer

104
00:04:11,040 --> 00:04:13,599
which will forward data from the correct

105
00:04:13,599 --> 00:04:16,320
pipeline stage to the alu

106
00:04:16,320 --> 00:04:19,040
the problem here is that the select

107
00:04:19,040 --> 00:04:22,000
signal of the multiplexer will glitch

108
00:04:22,000 --> 00:04:24,880
and therefore also the forward data

109
00:04:24,880 --> 00:04:27,440
might glitch and combine

110
00:04:27,440 --> 00:04:30,160
all the inputs of the multiplexer if we

111
00:04:30,160 --> 00:04:31,280
therefore

112
00:04:31,280 --> 00:04:32,240
have

113
00:04:32,240 --> 00:04:33,759
shares of the same

114
00:04:33,759 --> 00:04:35,680
native values stored in our pipeline

115
00:04:35,680 --> 00:04:38,400
registers forever data will potentially

116
00:04:38,400 --> 00:04:40,080
combine all these shares and we will

117
00:04:40,080 --> 00:04:44,160
have a leak how can we fix that

118
00:04:44,160 --> 00:04:46,320
hardware solutions are as already

119
00:04:46,320 --> 00:04:48,639
mentioned not feasible due to the huge

120
00:04:48,639 --> 00:04:50,880
latency overhead which is why we want to

121
00:04:50,880 --> 00:04:53,759
fix that on software level by separating

122
00:04:53,759 --> 00:04:56,960
two instructions which load shares

123
00:04:56,960 --> 00:04:58,639
into these pipeline registers by

124
00:04:58,639 --> 00:05:01,199
multiple unrelated instructions such as

125
00:05:01,199 --> 00:05:02,639
knobs

126
00:05:02,639 --> 00:05:04,479
however if we do that

127
00:05:04,479 --> 00:05:06,560
we will still have a huge software

128
00:05:06,560 --> 00:05:08,080
overhead

129
00:05:08,080 --> 00:05:09,680
but fortunately there are several

130
00:05:09,680 --> 00:05:11,360
techniques how we can reduce this

131
00:05:11,360 --> 00:05:13,840
overhead first of all parallel

132
00:05:13,840 --> 00:05:16,560
implementations so a serial implant

133
00:05:16,560 --> 00:05:18,960
implementation would mean on a really

134
00:05:18,960 --> 00:05:21,120
high level that we

135
00:05:21,120 --> 00:05:23,600
use knobs for unrelated instructions

136
00:05:23,600 --> 00:05:25,840
well we can replace these maps by

137
00:05:25,840 --> 00:05:27,600
something useful in parallel

138
00:05:27,600 --> 00:05:28,960
implementations

139
00:05:28,960 --> 00:05:31,120
by reordering the instructions of our

140
00:05:31,120 --> 00:05:33,440
mask software

141
00:05:33,440 --> 00:05:35,520
second we found out that threshold

142
00:05:35,520 --> 00:05:38,240
implementations are very useful in this

143
00:05:38,240 --> 00:05:39,759
context

144
00:05:39,759 --> 00:05:42,160
due to the non-completeness property of

145
00:05:42,160 --> 00:05:44,960
the component functions and this can

146
00:05:44,960 --> 00:05:47,520
also give us certain advantages when we

147
00:05:47,520 --> 00:05:49,840
want to design mask software for complex

148
00:05:49,840 --> 00:05:52,720
abuse however if you want to have more

149
00:05:52,720 --> 00:05:54,639
details on this

150
00:05:54,639 --> 00:05:58,000
topics i would uh yeah invite you to

151
00:05:58,000 --> 00:06:00,319
watch my presentation on youtube or read

152
00:06:00,319 --> 00:06:01,840
our paper

153
00:06:01,840 --> 00:06:04,240
uh yeah thank you all for listening and

154
00:06:04,240 --> 00:06:06,000
if you have any questions i'm happy to

155
00:06:06,000 --> 00:06:08,560
answer them

156
00:06:11,440 --> 00:06:13,120
thank you barbara for your nice

157
00:06:13,120 --> 00:06:15,600
presentation

158
00:06:15,600 --> 00:06:18,240
we are going to to ask

159
00:06:18,240 --> 00:06:20,800
the audience to uh to ask questions

160
00:06:20,800 --> 00:06:23,520
using the chatting zoom or the chatting

161
00:06:23,520 --> 00:06:24,560
salad

162
00:06:24,560 --> 00:06:27,280
uh we will try our best to

163
00:06:27,280 --> 00:06:29,280
to serve these questions i have one

164
00:06:29,280 --> 00:06:31,919
question for you barbara

165
00:06:31,919 --> 00:06:36,479
so when you are using knob operations

166
00:06:36,960 --> 00:06:39,120
this doesn't open the door for ford

167
00:06:39,120 --> 00:06:40,160
attacks

168
00:06:40,160 --> 00:06:42,639
um because you are using operations that

169
00:06:42,639 --> 00:06:46,000
are basically dummy right they do not um

170
00:06:46,000 --> 00:06:48,000
yeah exactly so knob operations are

171
00:06:48,000 --> 00:06:49,199
simply

172
00:06:49,199 --> 00:06:53,039
a knob so the cpu does uh nothing or i

173
00:06:53,039 --> 00:06:55,039
think in the case of risk five the cpu

174
00:06:55,039 --> 00:06:58,000
adds um the zero register

175
00:06:58,000 --> 00:07:00,400
with the zero register and so stores it

176
00:07:00,400 --> 00:07:01,919
in the serial register so nothing

177
00:07:01,919 --> 00:07:04,318
happens

178
00:07:04,960 --> 00:07:05,919
right

179
00:07:05,919 --> 00:07:06,800
right

180
00:07:06,800 --> 00:07:09,520
and and from your paper uh

181
00:07:09,520 --> 00:07:11,919
can we apply the technique for say for

182
00:07:11,919 --> 00:07:14,840
the s-box of trishak

183
00:07:14,840 --> 00:07:16,400
this

184
00:07:16,400 --> 00:07:18,800
um yeah of course so we also have

185
00:07:18,800 --> 00:07:21,919
several experiments in our paper where

186
00:07:21,919 --> 00:07:23,360
we apply

187
00:07:23,360 --> 00:07:25,919
this techniques um the parallel

188
00:07:25,919 --> 00:07:27,440
implementations and the threshold

189
00:07:27,440 --> 00:07:30,880
implementations on the s box and we also

190
00:07:30,880 --> 00:07:34,880
have one ti implementation of ascon

191
00:07:34,880 --> 00:07:36,000
and

192
00:07:36,000 --> 00:07:38,960
yeah so i think in the best case we see

193
00:07:38,960 --> 00:07:39,680
that

194
00:07:39,680 --> 00:07:42,720
the overhead of inserting

195
00:07:42,720 --> 00:07:46,160
this unrelated instructions or

196
00:07:46,160 --> 00:07:47,280
yeah

197
00:07:47,280 --> 00:07:48,160
as

198
00:07:48,160 --> 00:07:50,319
following the software rules which we

199
00:07:50,319 --> 00:07:52,000
propose in the paper

200
00:07:52,000 --> 00:07:55,120
is as low as 13 percent

201
00:07:55,120 --> 00:07:57,680
if you for example consider a ti

202
00:07:57,680 --> 00:07:59,280
implementation of

203
00:07:59,280 --> 00:08:02,400
the ketchup s-box

204
00:08:02,960 --> 00:08:04,960
i i see thank you very much we have a

205
00:08:04,960 --> 00:08:07,440
question here from sargandeep he is

206
00:08:07,440 --> 00:08:09,759
asking us which masking schemes you have

207
00:08:09,759 --> 00:08:12,080
tested

208
00:08:12,080 --> 00:08:15,280
uh which masking schemes we've tested um

209
00:08:15,280 --> 00:08:17,680
yeah so

210
00:08:17,680 --> 00:08:20,479
of course ti

211
00:08:20,479 --> 00:08:24,479
and also we have several dom based

212
00:08:24,479 --> 00:08:26,400
implementations so domain oriented

213
00:08:26,400 --> 00:08:27,680
masking

214
00:08:27,680 --> 00:08:29,440
we have applied that to the ketchup

215
00:08:29,440 --> 00:08:31,840
s-box

216
00:08:31,840 --> 00:08:35,200
but we have also some

217
00:08:35,200 --> 00:08:38,320
multi-mask multiplayer players so and

218
00:08:38,320 --> 00:08:39,760
gates

219
00:08:39,760 --> 00:08:42,880
i think we also tested

220
00:08:42,880 --> 00:08:44,320
the

221
00:08:44,320 --> 00:08:47,600
trajina and gate there

222
00:08:47,600 --> 00:08:49,040
and

223
00:08:49,040 --> 00:08:49,839
i

224
00:08:49,839 --> 00:08:52,480
sw and gate

225
00:08:52,480 --> 00:08:54,720
but you can find a list of that in our

226
00:08:54,720 --> 00:08:56,880
paper

227
00:08:56,880 --> 00:08:57,920
right

228
00:08:57,920 --> 00:08:59,200
right

229
00:08:59,200 --> 00:09:01,360
and and which of these masking schemes

230
00:09:01,360 --> 00:09:02,800
you would recommend

231
00:09:02,800 --> 00:09:03,519
for

232
00:09:03,519 --> 00:09:05,440
combining with the techniques presented

233
00:09:05,440 --> 00:09:07,519
in this paper

234
00:09:07,519 --> 00:09:09,440
um yeah of course

235
00:09:09,440 --> 00:09:12,560
it depends uh on what you want and also

236
00:09:12,560 --> 00:09:15,760
how your microprocessor looks like

237
00:09:15,760 --> 00:09:20,320
so um in our paper we also have um

238
00:09:20,320 --> 00:09:21,600
like uh

239
00:09:21,600 --> 00:09:24,480
several general rules for masking

240
00:09:24,480 --> 00:09:26,160
schemes on

241
00:09:26,160 --> 00:09:28,399
general microprocessors so depending

242
00:09:28,399 --> 00:09:30,640
depending on how many execution units

243
00:09:30,640 --> 00:09:34,560
and pipeline stages your processor has

244
00:09:34,560 --> 00:09:35,680
but

245
00:09:35,680 --> 00:09:37,920
yeah i mean the good thing about

246
00:09:37,920 --> 00:09:40,320
threshold implementations is

247
00:09:40,320 --> 00:09:42,160
that um

248
00:09:42,160 --> 00:09:44,399
if there are components in your cpu

249
00:09:44,399 --> 00:09:45,279
which

250
00:09:45,279 --> 00:09:47,600
might combine two shares

251
00:09:47,600 --> 00:09:48,480
so

252
00:09:48,480 --> 00:09:51,040
only two shares then you can use

253
00:09:51,040 --> 00:09:53,680
threshold implementations because there

254
00:09:53,680 --> 00:09:55,839
you will work with free shares for first

255
00:09:55,839 --> 00:09:59,839
order security and then it's um

256
00:09:59,839 --> 00:10:03,040
so to say it's it's not a problem if you

257
00:10:03,040 --> 00:10:05,279
combine two of them

258
00:10:05,279 --> 00:10:07,279
so threshold implementations turned out

259
00:10:07,279 --> 00:10:08,240
to be

260
00:10:08,240 --> 00:10:10,800
uh really useful in our

261
00:10:10,800 --> 00:10:13,040
uh yeah in our scenario

262
00:10:13,040 --> 00:10:15,120
okay thank you very much barbara we have

263
00:10:15,120 --> 00:10:17,760
time just for a quick question uh

264
00:10:17,760 --> 00:10:19,440
what about

265
00:10:19,440 --> 00:10:23,279
sni maskings did you try them

266
00:10:23,279 --> 00:10:24,880
no not really so

267
00:10:24,880 --> 00:10:27,440
coco the tool we applied

268
00:10:27,440 --> 00:10:28,720
is

269
00:10:28,720 --> 00:10:31,120
constructed to verify

270
00:10:31,120 --> 00:10:33,519
software in the time constraint probing

271
00:10:33,519 --> 00:10:35,120
model this is

272
00:10:35,120 --> 00:10:37,839
a bit stricter version of the

273
00:10:37,839 --> 00:10:40,160
hardware probing model

274
00:10:40,160 --> 00:10:43,279
but we didn't look at sni and stuff

275
00:10:43,279 --> 00:10:45,440
okay and right now the very last

276
00:10:45,440 --> 00:10:48,160
question by bjorn hasey

277
00:10:48,160 --> 00:10:50,160
he is asking us do you have any

278
00:10:50,160 --> 00:10:53,519
recommendation on how to proceed on cpus

279
00:10:53,519 --> 00:10:54,320
where

280
00:10:54,320 --> 00:10:56,240
don't have the micro architecture

281
00:10:56,240 --> 00:10:58,880
sources available

282
00:10:58,880 --> 00:11:01,040
yeah this is a problem so

283
00:11:01,040 --> 00:11:04,079
um there you can in my view only stick

284
00:11:04,079 --> 00:11:06,000
to manual measurements

285
00:11:06,000 --> 00:11:08,720
so you cannot apply the coco tool which

286
00:11:08,720 --> 00:11:10,640
we used because it requires that the

287
00:11:10,640 --> 00:11:13,200
netlist is kind of known to you

288
00:11:13,200 --> 00:11:15,279
and that you have the netlist and if

289
00:11:15,279 --> 00:11:17,360
this is a closed source and you cannot

290
00:11:17,360 --> 00:11:20,160
access it you cannot apply the tool

291
00:11:20,160 --> 00:11:22,720
so for closed source processes you would

292
00:11:22,720 --> 00:11:25,040
stick to manual measurements

293
00:11:25,040 --> 00:11:26,959
okay well barbara you have more

294
00:11:26,959 --> 00:11:28,320
questions but unfortunately we don't

295
00:11:28,320 --> 00:11:30,720
have more time but we will have time at

296
00:11:30,720 --> 00:11:32,959
the end of the session so you guys can

297
00:11:32,959 --> 00:11:35,440
ask and maybe you cannot answer in solid

298
00:11:35,440 --> 00:11:38,000
uh barbara we will move on with the

299
00:11:38,000 --> 00:11:40,160
second uh

300
00:11:40,160 --> 00:11:42,399
paper of this session fault injection

301
00:11:42,399 --> 00:11:44,399
attacks against nist post quantum

302
00:11:44,399 --> 00:11:46,560
cryptography round three chems

303
00:11:46,560 --> 00:11:49,200
candidates uh this will be presented by

304
00:11:49,200 --> 00:11:51,760
keita chagawa

305
00:11:51,760 --> 00:11:53,760
keita please proceed

306
00:11:53,760 --> 00:11:55,519
yeah thank you for

307
00:11:55,519 --> 00:11:56,560
uh

308
00:11:56,560 --> 00:11:58,800
changing my screen

309
00:11:58,800 --> 00:12:02,160
yes we can okay thank you great please

310
00:12:02,160 --> 00:12:04,240
so let me start

311
00:12:04,240 --> 00:12:06,880
so this is uh uh so i'm getting so this

312
00:12:06,880 --> 00:12:09,880
is

313
00:12:15,360 --> 00:12:17,680
so this is what we did in this paper so

314
00:12:17,680 --> 00:12:20,000
we surveyed an old chem scheme uh in

315
00:12:20,000 --> 00:12:22,560
nist p273 and

316
00:12:22,560 --> 00:12:23,920
we invested investigate

317
00:12:23,920 --> 00:12:26,639
we survey social recovery attack uh

318
00:12:26,639 --> 00:12:29,040
against the uh so using apprenticeship

319
00:12:29,040 --> 00:12:31,600
in oracle and forty decapitation oracle

320
00:12:31,600 --> 00:12:33,680
and we also investigate attack surface

321
00:12:33,680 --> 00:12:34,399
in

322
00:12:34,399 --> 00:12:37,040
the real world implementation so pqm4 so

323
00:12:37,040 --> 00:12:40,800
which is a library for cortex info and

324
00:12:40,800 --> 00:12:41,680
so

325
00:12:41,680 --> 00:12:44,160
multiplying them so we

326
00:12:44,160 --> 00:12:45,120
can

327
00:12:45,120 --> 00:12:47,200
assess the effect of photo injection

328
00:12:47,200 --> 00:12:50,320
attack in p2m4 so let me start a next

329
00:12:50,320 --> 00:12:51,519
page

330
00:12:51,519 --> 00:12:53,279
so let us

331
00:12:53,279 --> 00:12:56,160
we first review so what is uh became

332
00:12:56,160 --> 00:12:59,200
streams in this slide

333
00:12:59,200 --> 00:12:59,920
so

334
00:12:59,920 --> 00:13:02,639
nist starts post uh standardization post

335
00:13:02,639 --> 00:13:04,240
quantum cryptography

336
00:13:04,240 --> 00:13:06,480
from 2016

337
00:13:06,480 --> 00:13:08,560
and this uh

338
00:13:08,560 --> 00:13:11,279
success this reduces the number of

339
00:13:11,279 --> 00:13:14,480
candidates and we are now in round three

340
00:13:14,480 --> 00:13:16,720
so there are the four finals fourteen

341
00:13:16,720 --> 00:13:18,880
class materials kyber and through saber

342
00:13:18,880 --> 00:13:20,959
and five alternate candidates for camp

343
00:13:20,959 --> 00:13:23,440
bike road game sqc and through prime and

344
00:13:23,440 --> 00:13:24,800
psych

345
00:13:24,800 --> 00:13:26,800
and so in

346
00:13:26,800 --> 00:13:29,600
in the at the end of this year or very

347
00:13:29,600 --> 00:13:32,320
beginning of the next year the news will

348
00:13:32,320 --> 00:13:34,959
decide the

349
00:13:34,959 --> 00:13:37,200
the renown of james i came skinned and

350
00:13:37,200 --> 00:13:40,000
stranger scheme also here so there are

351
00:13:40,000 --> 00:13:44,000
nine candidates for james game chemskin

352
00:13:44,000 --> 00:13:44,800
okay

353
00:13:44,800 --> 00:13:46,720
so in extra review so what is the

354
00:13:46,720 --> 00:13:48,800
friendly french unfortunately person

355
00:13:48,800 --> 00:13:50,800
oracle

356
00:13:50,800 --> 00:13:51,839
so

357
00:13:51,839 --> 00:13:54,480
we often consider attacks against

358
00:13:54,480 --> 00:13:57,040
attacks against the champ scheme with

359
00:13:57,040 --> 00:13:59,519
use using oracles so like a branded

360
00:13:59,519 --> 00:14:01,760
touching oracle or the calculation

361
00:14:01,760 --> 00:14:02,720
oracle

362
00:14:02,720 --> 00:14:04,800
so print just checking our oracles

363
00:14:04,800 --> 00:14:06,399
allows us

364
00:14:06,399 --> 00:14:07,600
uh

365
00:14:07,600 --> 00:14:10,959
us to check h of x prime is h of x yes

366
00:14:10,959 --> 00:14:13,600
so here's x prime is the uh decryption

367
00:14:13,600 --> 00:14:17,040
result and x yes is also our guess

368
00:14:17,040 --> 00:14:18,160
and if

369
00:14:18,160 --> 00:14:20,639
uh and so we consider often so

370
00:14:20,639 --> 00:14:22,240
the theory capability attack using such

371
00:14:22,240 --> 00:14:24,240
such principle oracle

372
00:14:24,240 --> 00:14:27,199
and moreover so if we can get

373
00:14:27,199 --> 00:14:29,440
h of x prime itself

374
00:14:29,440 --> 00:14:32,079
so shiloh so x prime is a decryption

375
00:14:32,079 --> 00:14:33,600
result

376
00:14:33,600 --> 00:14:34,720
so

377
00:14:34,720 --> 00:14:36,000
we can

378
00:14:36,000 --> 00:14:37,040
move

379
00:14:37,040 --> 00:14:38,720
we can get a

380
00:14:38,720 --> 00:14:40,800
more efficient kilogram attacks using

381
00:14:40,800 --> 00:14:44,079
such oracles

382
00:14:44,079 --> 00:14:46,880
and so using those oracles so

383
00:14:46,880 --> 00:14:48,000
uh

384
00:14:48,000 --> 00:14:50,000
there are several three recovery attacks

385
00:14:50,000 --> 00:14:52,240
using such oracles against the uh nest

386
00:14:52,240 --> 00:14:54,800
candidates and instagram candidates

387
00:14:54,800 --> 00:14:57,920
so for example so kaiba has such five

388
00:14:57,920 --> 00:14:59,120
papers

389
00:14:59,120 --> 00:15:01,839
for charity couple attack and saber has

390
00:15:01,839 --> 00:15:05,120
so fully powerful papers like this one

391
00:15:05,120 --> 00:15:06,240
so we

392
00:15:06,240 --> 00:15:08,800
additionally so propose a new attacks a

393
00:15:08,800 --> 00:15:10,560
new chief of attacks against andrew

394
00:15:10,560 --> 00:15:11,600
airport

395
00:15:11,600 --> 00:15:14,000
prime so which is the one of gemstream

396
00:15:14,000 --> 00:15:16,639
in n through prime okay

397
00:15:16,639 --> 00:15:19,440
and the mobile so if we can use 40-day

398
00:15:19,440 --> 00:15:21,839
transaction workflow we can use number

399
00:15:21,839 --> 00:15:24,560
of queries because we can get h of x

400
00:15:24,560 --> 00:15:28,000
prime instead of just we can check h of

401
00:15:28,000 --> 00:15:32,720
x prime is equal to h sub x guess

402
00:15:33,920 --> 00:15:35,839
also this is about uh

403
00:15:35,839 --> 00:15:38,399
and we next survey so

404
00:15:38,399 --> 00:15:41,199
attack surface in that p2m flow

405
00:15:41,199 --> 00:15:42,880
so for example so

406
00:15:42,880 --> 00:15:45,839
enterprime has a sushi a bug

407
00:15:45,839 --> 00:15:47,279
so this is a

408
00:15:47,279 --> 00:15:48,959
this is a software

409
00:15:48,959 --> 00:15:52,399
i cannot find and so she also this

410
00:15:52,399 --> 00:15:55,040
function in the uh checks

411
00:15:55,040 --> 00:15:58,959
to ciphertext and it will return 0 and

412
00:15:58,959 --> 00:15:59,759
if

413
00:15:59,759 --> 00:16:02,240
the the ciphertext is not equal to and

414
00:16:02,240 --> 00:16:04,720
then so it will return -1 but

415
00:16:04,720 --> 00:16:06,560
unfortunately so this

416
00:16:06,560 --> 00:16:08,959
function always written zero due to the

417
00:16:08,959 --> 00:16:11,279
bug

418
00:16:11,680 --> 00:16:14,240
next one is also fraud game so it is

419
00:16:14,240 --> 00:16:17,920
well known that so in the last year

420
00:16:17,920 --> 00:16:18,639
so

421
00:16:18,639 --> 00:16:20,959
go and johansen and nielsen propose a

422
00:16:20,959 --> 00:16:22,959
timing bug attack

423
00:16:22,959 --> 00:16:25,040
against the key against the frost game

424
00:16:25,040 --> 00:16:26,639
but so it remains

425
00:16:26,639 --> 00:16:28,639
in pqm full

426
00:16:28,639 --> 00:16:30,000
the next one is the photo injection

427
00:16:30,000 --> 00:16:31,759
attack so

428
00:16:31,759 --> 00:16:33,839
silva kyber and russell shares some

429
00:16:33,839 --> 00:16:36,880
structures to which uses conditional

430
00:16:36,880 --> 00:16:38,240
move

431
00:16:38,240 --> 00:16:39,360
so to

432
00:16:39,360 --> 00:16:42,320
replace uh the critical information to a

433
00:16:42,320 --> 00:16:43,680
random sheet

434
00:16:43,680 --> 00:16:46,160
so here so um literally so this symbol

435
00:16:46,160 --> 00:16:49,519
function is called in assembly like this

436
00:16:49,519 --> 00:16:52,079
this block in the

437
00:16:52,079 --> 00:16:54,720
line 8 in the right hand side so if we

438
00:16:54,720 --> 00:16:56,240
skip this

439
00:16:56,240 --> 00:16:58,480
line this instruction

440
00:16:58,480 --> 00:17:02,399
by some injecting effort then so it will

441
00:17:02,399 --> 00:17:03,680
return

442
00:17:03,680 --> 00:17:04,400
h

443
00:17:04,400 --> 00:17:06,480
of x prime always

444
00:17:06,480 --> 00:17:08,319
so therefore so if uh

445
00:17:08,319 --> 00:17:10,720
so we can uh

446
00:17:10,720 --> 00:17:12,880
implement exchange for dangerous attack

447
00:17:12,880 --> 00:17:15,839
against the such saber kyber and rule

448
00:17:15,839 --> 00:17:20,000
and the more of us and we did

449
00:17:20,000 --> 00:17:21,199
experiment

450
00:17:21,199 --> 00:17:23,359
uh in the real world

451
00:17:23,359 --> 00:17:24,720
p2m4

452
00:17:24,720 --> 00:17:27,439
using the cheap whisper as a result we

453
00:17:27,439 --> 00:17:29,280
obtained a such experimental result in

454
00:17:29,280 --> 00:17:31,280
this in this slide

455
00:17:31,280 --> 00:17:35,039
so this is rough buff so

456
00:17:35,039 --> 00:17:36,559
we subbing uh

457
00:17:36,559 --> 00:17:39,679
mr pgc cam streams and we have a kill

458
00:17:39,679 --> 00:17:41,120
cable attacks used uh using the

459
00:17:41,120 --> 00:17:43,039
predecessor on the 40-day transmission

460
00:17:43,039 --> 00:17:45,280
oracle and we also investigate attack

461
00:17:45,280 --> 00:17:47,760
surface in p2m4 and so

462
00:17:47,760 --> 00:17:48,880
we assess

463
00:17:48,880 --> 00:17:51,600
effect of photo injection attack in p2m4

464
00:17:51,600 --> 00:17:53,440
thank you

465
00:17:53,440 --> 00:17:55,280
thank you very much keita for your nice

466
00:17:55,280 --> 00:17:58,799
presentation and yeah nice work

467
00:17:58,799 --> 00:18:00,799
so i have some questions could you say

468
00:18:00,799 --> 00:18:03,200
something more about counter measures to

469
00:18:03,200 --> 00:18:05,760
this attack

470
00:18:05,760 --> 00:18:08,160
counter measures yes

471
00:18:08,160 --> 00:18:11,200
okay so for example so uh

472
00:18:11,200 --> 00:18:13,600
the most

473
00:18:13,600 --> 00:18:16,240
okay so there are i think we have we

474
00:18:16,240 --> 00:18:19,039
have two counter measures so the one is

475
00:18:19,039 --> 00:18:20,000
also

476
00:18:20,000 --> 00:18:20,880
uh

477
00:18:20,880 --> 00:18:23,280
default fourth

478
00:18:23,280 --> 00:18:24,080
is

479
00:18:24,080 --> 00:18:26,000
default for implementation

480
00:18:26,000 --> 00:18:26,799
so

481
00:18:26,799 --> 00:18:29,200
in the case of saber so

482
00:18:29,200 --> 00:18:31,679
unfortunately so if we skip

483
00:18:31,679 --> 00:18:34,880
this right eight then so uh the x frames

484
00:18:34,880 --> 00:18:38,640
remained so therefore so if uh set

485
00:18:38,640 --> 00:18:42,790
the random sheet as a default then so

486
00:18:42,790 --> 00:18:45,940
[Music]

487
00:18:51,440 --> 00:18:53,520
measures is the

488
00:18:53,520 --> 00:18:56,799
duplicate instruction instructions so we

489
00:18:56,799 --> 00:18:58,640
always

490
00:18:58,640 --> 00:19:01,840
every instruction twice

491
00:19:03,039 --> 00:19:06,000
does that make sense

492
00:19:06,000 --> 00:19:09,120
sounds sounds expensive though but

493
00:19:09,120 --> 00:19:10,559
yes yes

494
00:19:10,559 --> 00:19:11,760
okay

495
00:19:11,760 --> 00:19:13,760
and and how do you compare this with

496
00:19:13,760 --> 00:19:15,600
your other work about site channel

497
00:19:15,600 --> 00:19:17,360
attacks not fault attacks but side

498
00:19:17,360 --> 00:19:19,440
channel attacks on

499
00:19:19,440 --> 00:19:22,160
uh yes yes so we also have been a

500
00:19:22,160 --> 00:19:23,600
federal attacks

501
00:19:23,600 --> 00:19:27,120
in in such uh mr ptc terms and so this

502
00:19:27,120 --> 00:19:29,600
is for century so this is accepted in

503
00:19:29,600 --> 00:19:32,000
the next stage

504
00:19:32,000 --> 00:19:33,840
my question was how would you compare

505
00:19:33,840 --> 00:19:35,919
the two settings do you think that the

506
00:19:35,919 --> 00:19:38,320
two attacks are complementary or once

507
00:19:38,320 --> 00:19:39,200
yes

508
00:19:39,200 --> 00:19:42,080
yeah complementary but also

509
00:19:42,080 --> 00:19:46,879
ah sorry so so in the case of 40 uh

510
00:19:47,360 --> 00:19:50,880
so it depends on schemes

511
00:19:50,880 --> 00:19:52,960
i think

512
00:19:52,960 --> 00:19:56,000
okay thank you very much uh let me just

513
00:19:56,000 --> 00:19:58,240
quickly check if we have questions in

514
00:19:58,240 --> 00:19:59,600
solid no

515
00:19:59,600 --> 00:20:01,760
no more questions right now so thank you

516
00:20:01,760 --> 00:20:04,559
very much uh for your nice presentation

517
00:20:04,559 --> 00:20:05,360
and

518
00:20:05,360 --> 00:20:08,240
we will move to our next presenter thank

519
00:20:08,240 --> 00:20:09,280
you very much

520
00:20:09,280 --> 00:20:11,760
thank you thank you

521
00:20:11,760 --> 00:20:14,480
so we are doing fine on time we will

522
00:20:14,480 --> 00:20:16,720
move now to our third paper in this

523
00:20:16,720 --> 00:20:17,840
session

524
00:20:17,840 --> 00:20:21,039
that is a title divided we stand uni

525
00:20:21,039 --> 00:20:23,760
united with all security analysis of

526
00:20:23,760 --> 00:20:26,720
some essays s c a

527
00:20:26,720 --> 00:20:27,600
plus

528
00:20:27,600 --> 00:20:32,720
s i f a counter measures against sca so

529
00:20:32,720 --> 00:20:35,919
we will ask for the presenter to

530
00:20:35,919 --> 00:20:37,840
to start the presentation please

531
00:20:37,840 --> 00:20:38,640
uh

532
00:20:38,640 --> 00:20:41,360
please slide in deep go ahead hello am i

533
00:20:41,360 --> 00:20:44,000
honorable clearly yes absolutely we can

534
00:20:44,000 --> 00:20:46,159
we can kill you okay

535
00:20:46,159 --> 00:20:47,280
let's go

536
00:20:47,280 --> 00:20:48,880
uh i'm shandy

537
00:20:48,880 --> 00:20:50,480
and today i'm presenting our work

538
00:20:50,480 --> 00:20:53,039
divided with stand united with fall

539
00:20:53,039 --> 00:20:55,520
security analysis of some sca cifa

540
00:20:55,520 --> 00:20:57,440
countermeasures against hca enhanced

541
00:20:57,440 --> 00:20:59,360
fault template attacks this is a joint

542
00:20:59,360 --> 00:21:03,039
work with onobat the month

543
00:21:10,799 --> 00:21:13,039
so in this work we are mainly proposing

544
00:21:13,039 --> 00:21:14,720
a combined attack technique combine

545
00:21:14,720 --> 00:21:16,559
cycle and fault attack technique where

546
00:21:16,559 --> 00:21:18,720
we have taken the recently proposed

547
00:21:18,720 --> 00:21:20,400
fault template attack in europe with

548
00:21:20,400 --> 00:21:23,440
2020 and enhance that with sc

549
00:21:23,440 --> 00:21:26,080
now it's a profile technique and it

550
00:21:26,080 --> 00:21:28,159
bypasses some recently proposed fifa

551
00:21:28,159 --> 00:21:29,840
counter measures now why we have chosen

552
00:21:29,840 --> 00:21:31,200
this class of counter measures the

553
00:21:31,200 --> 00:21:33,679
reason is that it combines both

554
00:21:33,679 --> 00:21:35,120
side channel and fault error counter

555
00:21:35,120 --> 00:21:36,880
measures ideal target for a combined

556
00:21:36,880 --> 00:21:39,440
adversary and our main aim was to see

557
00:21:39,440 --> 00:21:41,600
if this counter measures really protect

558
00:21:41,600 --> 00:21:44,480
against an adversary when you have when

559
00:21:44,480 --> 00:21:46,240
both fault attacker and side channel

560
00:21:46,240 --> 00:21:48,960
attacker are present together

561
00:21:48,960 --> 00:21:50,960
we also expose few intricacies

562
00:21:50,960 --> 00:21:53,200
associated with masking while realizing

563
00:21:53,200 --> 00:21:55,120
sifa counter measure or any class of

564
00:21:55,120 --> 00:21:57,200
combined countermeasure and we think

565
00:21:57,200 --> 00:21:59,600
that it's a really important information

566
00:21:59,600 --> 00:22:01,360
we also enable middle ground attracts

567
00:22:01,360 --> 00:22:03,919
without any ciphertext access or direct

568
00:22:03,919 --> 00:22:06,000
access to plaintext

569
00:22:06,000 --> 00:22:08,320
so how it works so initially i assume

570
00:22:08,320 --> 00:22:10,000
that the adversary is in a profile

571
00:22:10,000 --> 00:22:11,760
setting where he has access to some

572
00:22:11,760 --> 00:22:13,360
device which is similar to the target

573
00:22:13,360 --> 00:22:16,080
device and what he can do he has a known

574
00:22:16,080 --> 00:22:17,919
key randomness everything he can choose

575
00:22:17,919 --> 00:22:20,559
certain fault locations and excite them

576
00:22:20,559 --> 00:22:22,159
and measure side channel leakage now

577
00:22:22,159 --> 00:22:24,320
based on that measurements he creates a

578
00:22:24,320 --> 00:22:26,559
template where the template contains

579
00:22:26,559 --> 00:22:28,400
site channel measurements as well as

580
00:22:28,400 --> 00:22:31,039
intermediate values of the state

581
00:22:31,039 --> 00:22:33,760
now upon getting the actual device where

582
00:22:33,760 --> 00:22:35,760
the key is unknown he excites those

583
00:22:35,760 --> 00:22:38,000
specific fault locations one at a time

584
00:22:38,000 --> 00:22:39,679
measure side chain

585
00:22:39,679 --> 00:22:42,080
and access the template to get the

586
00:22:42,080 --> 00:22:44,320
secret now it is fairly similar to the

587
00:22:44,320 --> 00:22:47,039
fda model or standard site and template

588
00:22:47,039 --> 00:22:48,720
model and the difference is that with

589
00:22:48,720 --> 00:22:50,960
respect to fk is that if they use a

590
00:22:50,960 --> 00:22:53,520
single bit of information is the cipher

591
00:22:53,520 --> 00:22:56,960
text is correct or faulted here we have

592
00:22:56,960 --> 00:22:58,799
access to more information thanks to the

593
00:22:58,799 --> 00:23:00,640
side channel leakages and we

594
00:23:00,640 --> 00:23:02,480
show that this information can be

595
00:23:02,480 --> 00:23:05,360
catastrophic for certain countermeasures

596
00:23:05,360 --> 00:23:07,760
now let us take an example here

597
00:23:07,760 --> 00:23:09,360
we actually exploit the fault

598
00:23:09,360 --> 00:23:11,600
propagation to basic logic and the

599
00:23:11,600 --> 00:23:13,280
presence of some detection or correction

600
00:23:13,280 --> 00:23:15,760
mechanisms to prevent fault attacks so

601
00:23:15,760 --> 00:23:17,919
one example is like if i inject a fault

602
00:23:17,919 --> 00:23:20,080
here and assume that the xbox output

603
00:23:20,080 --> 00:23:21,840
have some error correction or direction

604
00:23:21,840 --> 00:23:23,919
logic implemented we see

605
00:23:23,919 --> 00:23:25,679
that for y naught output the fault

606
00:23:25,679 --> 00:23:27,679
propagates mandatory every time there is

607
00:23:27,679 --> 00:23:30,640
a fault however for y1 and y2 the fault

608
00:23:30,640 --> 00:23:32,240
propagation is conditional and the

609
00:23:32,240 --> 00:23:34,880
condition depends on the input values or

610
00:23:34,880 --> 00:23:36,880
the input value of the xbox so

611
00:23:36,880 --> 00:23:40,000
effectively we are exposing the xbox

612
00:23:40,000 --> 00:23:41,919
input from just by seeing the fault

613
00:23:41,919 --> 00:23:44,080
differential at the output

614
00:23:44,080 --> 00:23:46,400
now in practice we cannot directly see

615
00:23:46,400 --> 00:23:48,480
this for differentials because there are

616
00:23:48,480 --> 00:23:50,640
some counter measures be present so what

617
00:23:50,640 --> 00:23:53,120
we see what we do here we exploit the

618
00:23:53,120 --> 00:23:54,640
leakage from error detection or

619
00:23:54,640 --> 00:23:57,120
correction blocks and we inject several

620
00:23:57,120 --> 00:23:59,520
faults in each independent execution

621
00:23:59,520 --> 00:24:01,360
cycles and create a complete template

622
00:24:01,360 --> 00:24:03,760
like this here on sitechannel hemingway

623
00:24:03,760 --> 00:24:04,799
values

624
00:24:04,799 --> 00:24:06,640
and we can extract the intermediate

625
00:24:06,640 --> 00:24:09,039
state of the cipher and that eventually

626
00:24:09,039 --> 00:24:11,120
helps us to recover the key

627
00:24:11,120 --> 00:24:13,600
now one might think that okay if i have

628
00:24:13,600 --> 00:24:15,039
masking implemented for this error

629
00:24:15,039 --> 00:24:16,960
detection or correctional logic it might

630
00:24:16,960 --> 00:24:19,760
not work right but surprisingly it works

631
00:24:19,760 --> 00:24:22,559
why let's see let us consider dom gate

632
00:24:22,559 --> 00:24:24,799
and i inject a fault at a naught now due

633
00:24:24,799 --> 00:24:27,200
to the fault propagation properties b is

634
00:24:27,200 --> 00:24:29,440
leaked as shown in this example

635
00:24:29,440 --> 00:24:32,000
our more interesting fact is that b

636
00:24:32,000 --> 00:24:34,480
leaks through only one output share of

637
00:24:34,480 --> 00:24:36,080
the implementation data output share

638
00:24:36,080 --> 00:24:37,919
remains uncorrected so

639
00:24:37,919 --> 00:24:40,480
that means with a single fault and a

640
00:24:40,480 --> 00:24:42,320
fast order side channel attack i can

641
00:24:42,320 --> 00:24:44,080
break a fast product dom implementation

642
00:24:44,080 --> 00:24:46,640
and it actually extends to any order in

643
00:24:46,640 --> 00:24:48,960
order dom implementation so i can do a

644
00:24:48,960 --> 00:24:51,200
fast order attack on any other dom and

645
00:24:51,200 --> 00:24:53,279
it also extend to other

646
00:24:53,279 --> 00:24:55,520
i mean protected schemes like pini which

647
00:24:55,520 --> 00:24:57,200
has medicine reports

648
00:24:57,200 --> 00:24:59,600
now let's see how it works for a cifa

649
00:24:59,600 --> 00:25:01,279
countermeasure so this specific one is

650
00:25:01,279 --> 00:25:03,440
due to teachers french 20

651
00:25:03,440 --> 00:25:05,600
and it is constructed in a way so that

652
00:25:05,600 --> 00:25:07,039
whenever there is a fault in the

653
00:25:07,039 --> 00:25:08,960
computation there is at least one

654
00:25:08,960 --> 00:25:10,480
mandatory fault propagation at the

655
00:25:10,480 --> 00:25:12,880
output as shown in line 16.

656
00:25:12,880 --> 00:25:15,120
now we found that there are other fault

657
00:25:15,120 --> 00:25:16,720
propagations to the output which are

658
00:25:16,720 --> 00:25:18,720
conditional and they cannot hide from

659
00:25:18,720 --> 00:25:21,279
side channel leakage as a result from

660
00:25:21,279 --> 00:25:23,840
this expressions from line number 15 we

661
00:25:23,840 --> 00:25:25,760
can actually perform

662
00:25:25,760 --> 00:25:28,400
a temp fault template attack and here we

663
00:25:28,400 --> 00:25:29,840
actually use the

664
00:25:29,840 --> 00:25:31,840
first expression of line 15 only so it's

665
00:25:31,840 --> 00:25:34,159
the first order attack once again and we

666
00:25:34,159 --> 00:25:36,080
can break this confirmation

667
00:25:36,080 --> 00:25:39,360
we practically tested this one with an

668
00:25:39,360 --> 00:25:41,679
atmega board where the implementation is

669
00:25:41,679 --> 00:25:43,200
open source from the authors of the

670
00:25:43,200 --> 00:25:45,600
previous paper it's a kitchen gas box

671
00:25:45,600 --> 00:25:47,919
and we actually targeted this with laser

672
00:25:47,919 --> 00:25:49,440
fault injection and power with side

673
00:25:49,440 --> 00:25:51,279
chain measurement and were successful to

674
00:25:51,279 --> 00:25:53,520
recover the secret base inside the

675
00:25:53,520 --> 00:25:54,960
implementation

676
00:25:54,960 --> 00:25:56,799
so to conclude combined attacks are

677
00:25:56,799 --> 00:25:58,240
really practical and should be

678
00:25:58,240 --> 00:26:00,000
considered for implementations having

679
00:26:00,000 --> 00:26:01,440
both fault attack and side challenge

680
00:26:01,440 --> 00:26:03,120
countermeasure i should mention that

681
00:26:03,120 --> 00:26:04,960
this attack is not limited to dom

682
00:26:04,960 --> 00:26:07,679
implementations or isw variants only it

683
00:26:07,679 --> 00:26:10,080
also works on higher order ti and there

684
00:26:10,080 --> 00:26:12,480
are examples given in the paper but also

685
00:26:12,480 --> 00:26:14,559
there is a summary of oh because we

686
00:26:14,559 --> 00:26:18,080
found that for certain pi implementation

687
00:26:18,080 --> 00:26:20,880
uh there are some way out where you can

688
00:26:20,880 --> 00:26:22,640
prevent this attack and non-completeness

689
00:26:22,640 --> 00:26:24,720
property of ti plays a very crucial role

690
00:26:24,720 --> 00:26:25,919
in that fan

691
00:26:25,919 --> 00:26:28,000
however whatever counter measure has

692
00:26:28,000 --> 00:26:29,919
been designed so far after taking this

693
00:26:29,919 --> 00:26:32,720
attack into considerations are kind of

694
00:26:32,720 --> 00:26:35,440
heavy weight so we have to look for more

695
00:26:35,440 --> 00:26:36,799
lightweight versions of the counter

696
00:26:36,799 --> 00:26:39,679
measures also we believe that this

697
00:26:39,679 --> 00:26:41,279
attack would work on certain other

698
00:26:41,279 --> 00:26:43,039
implementations because quite generic

699
00:26:43,039 --> 00:26:45,840
such as public implementations or

700
00:26:45,840 --> 00:26:48,080
authentication inclusion schemes

701
00:26:48,080 --> 00:26:50,080
uh surprisingly found that few

702
00:26:50,080 --> 00:26:52,400
multi-party web schemes like kappa it's

703
00:26:52,400 --> 00:26:54,720
fairly protected against this attack so

704
00:26:54,720 --> 00:26:57,039
some more i mean information is required

705
00:26:57,039 --> 00:26:58,960
in that regard so i'd like to do further

706
00:26:58,960 --> 00:27:00,320
research on that

707
00:27:00,320 --> 00:27:01,840
so with this message i would like to

708
00:27:01,840 --> 00:27:07,320
conclude any questions welcome thank you

709
00:27:08,080 --> 00:27:09,360
thank you very much for your nice

710
00:27:09,360 --> 00:27:10,799
presentation

711
00:27:10,799 --> 00:27:12,960
so let's see if we have some questions

712
00:27:12,960 --> 00:27:15,679
for from our audience meanwhile i i

713
00:27:15,679 --> 00:27:18,240
wanted to ask you what is the

714
00:27:18,240 --> 00:27:20,720
the success rate of your attack

715
00:27:20,720 --> 00:27:22,880
that you presented in the last slide

716
00:27:22,880 --> 00:27:25,200
yeah oh yeah of course so in this in

717
00:27:25,200 --> 00:27:27,840
this attack i mean we kind of

718
00:27:27,840 --> 00:27:29,919
were able to recover most of the bits

719
00:27:29,919 --> 00:27:31,840
okay so that's not a problem

720
00:27:31,840 --> 00:27:34,320
uh because uh the implementation we used

721
00:27:34,320 --> 00:27:36,080
here it's an atmega implementation we

722
00:27:36,080 --> 00:27:38,240
found that uh if you are injecting a

723
00:27:38,240 --> 00:27:41,279
fault some at some location the location

724
00:27:41,279 --> 00:27:42,559
where you are measuring side channel

725
00:27:42,559 --> 00:27:44,320
leakages several clock cycles have it

726
00:27:44,320 --> 00:27:46,240
because it's a software implementation

727
00:27:46,240 --> 00:27:49,360
so side channel signal was very good

728
00:27:49,360 --> 00:27:50,960
i mean uh i mean

729
00:27:50,960 --> 00:27:52,960
there's very low noise so that you can

730
00:27:52,960 --> 00:27:54,640
easily extract the key and another point

731
00:27:54,640 --> 00:27:56,399
is that we are recovering information

732
00:27:56,399 --> 00:27:58,240
bit by bit here so

733
00:27:58,240 --> 00:28:00,159
i mean the templates were also quite

734
00:28:00,159 --> 00:28:03,159
good

735
00:28:04,080 --> 00:28:05,919
it might be a little difficult

736
00:28:05,919 --> 00:28:08,559
right so this attack is assuming that

737
00:28:08,559 --> 00:28:11,679
the attacker is quite powerful right

738
00:28:11,679 --> 00:28:13,919
yes

739
00:28:13,919 --> 00:28:16,559
yeah not full control he can do side

740
00:28:16,559 --> 00:28:18,720
channel and fault simultaneously

741
00:28:18,720 --> 00:28:21,600
that's the only assumption

742
00:28:21,600 --> 00:28:22,960
okay

743
00:28:22,960 --> 00:28:25,520
okay thank you very much

744
00:28:25,520 --> 00:28:26,799
so

745
00:28:26,799 --> 00:28:28,559
well thank you for your presentation and

746
00:28:28,559 --> 00:28:29,600
we will have

747
00:28:29,600 --> 00:28:31,120
time for more questions at the end of

748
00:28:31,120 --> 00:28:32,159
the session

749
00:28:32,159 --> 00:28:34,240
we appreciate it thank you

750
00:28:34,240 --> 00:28:37,919
so we will move to the next uh

751
00:28:38,000 --> 00:28:39,919
paper that we have

752
00:28:39,919 --> 00:28:40,720
so

753
00:28:40,720 --> 00:28:43,440
we asked francesco bertie to present

754
00:28:43,440 --> 00:28:46,960
efficiently resilient max without ideal

755
00:28:46,960 --> 00:28:49,600
idealized assumptions

756
00:28:49,600 --> 00:28:53,360
so please francesco go ahead

757
00:28:53,360 --> 00:28:55,200
do you see the slide itself

758
00:28:55,200 --> 00:28:57,679
we can see it but yeah perfect okay now

759
00:28:57,679 --> 00:28:59,840
it's full scale perfect

760
00:28:59,840 --> 00:29:02,080
thank you for this nice presentation i

761
00:29:02,080 --> 00:29:03,440
would present

762
00:29:03,440 --> 00:29:05,360
this work which talks about providing

763
00:29:05,360 --> 00:29:07,600
integrity in presence of leakage

764
00:29:07,600 --> 00:29:09,919
with only assumption in the standard

765
00:29:09,919 --> 00:29:11,279
model

766
00:29:11,279 --> 00:29:13,679
as usual we when we talk about integrity

767
00:29:13,679 --> 00:29:15,360
we have alice who wants to send a

768
00:29:15,360 --> 00:29:18,080
message to bob in a secure way because

769
00:29:18,080 --> 00:29:20,559
she wants that bob is sure if the

770
00:29:20,559 --> 00:29:23,120
message he has received comes from alice

771
00:29:23,120 --> 00:29:26,480
or not so she use a mac which computes a

772
00:29:26,480 --> 00:29:28,240
tiger for the message and then bob

773
00:29:28,240 --> 00:29:30,159
verifies this message this couple

774
00:29:30,159 --> 00:29:33,360
message tag but we have our versa heave

775
00:29:33,360 --> 00:29:36,480
who can see this couple message tag and

776
00:29:36,480 --> 00:29:39,679
also she's she has physical access to

777
00:29:39,679 --> 00:29:41,279
this cryptographic device she can

778
00:29:41,279 --> 00:29:43,919
measure information she can measure

779
00:29:43,919 --> 00:29:45,679
physical quantities

780
00:29:45,679 --> 00:29:47,120
which are obtained during this

781
00:29:47,120 --> 00:29:48,320
computation

782
00:29:48,320 --> 00:29:50,720
which these physical quantities may leak

783
00:29:50,720 --> 00:29:53,039
critical information in some case even

784
00:29:53,039 --> 00:29:54,559
the full key

785
00:29:54,559 --> 00:29:57,840
eve wants to be able to send a message

786
00:29:57,840 --> 00:29:59,679
to bob in person

787
00:29:59,679 --> 00:30:03,360
in personificating alice

788
00:30:03,360 --> 00:30:05,360
the goal in our talk is to provide some

789
00:30:05,360 --> 00:30:07,919
mech which are integer which provides

790
00:30:07,919 --> 00:30:11,679
authenticity in process of leakage

791
00:30:11,679 --> 00:30:14,559
i start talking about some side channel

792
00:30:14,559 --> 00:30:15,760
about

793
00:30:15,760 --> 00:30:17,679
and our side channel may affect

794
00:30:17,679 --> 00:30:19,600
integrity for example we can consider

795
00:30:19,600 --> 00:30:21,120
this simple

796
00:30:21,120 --> 00:30:23,279
mac which where we have a message which

797
00:30:23,279 --> 00:30:25,600
is asked to obtain a value h which is

798
00:30:25,600 --> 00:30:27,919
the input of a block cipher and we

799
00:30:27,919 --> 00:30:30,399
obtain a tag in verification what we can

800
00:30:30,399 --> 00:30:32,960
do we recompute the real target total

801
00:30:32,960 --> 00:30:36,720
and then we check if toe is a

802
00:30:36,720 --> 00:30:40,080
is the tag provided with the message

803
00:30:40,080 --> 00:30:42,000
we can see that clearly if we can

804
00:30:42,000 --> 00:30:45,039
recover with said channel leki

805
00:30:45,039 --> 00:30:47,600
we can forge but also for example if we

806
00:30:47,600 --> 00:30:50,880
can recover with side channel

807
00:30:50,880 --> 00:30:53,279
kilda talk we can forge

808
00:30:53,279 --> 00:30:54,159
thus

809
00:30:54,159 --> 00:30:56,320
we this shows that

810
00:30:56,320 --> 00:30:58,880
it is important to understand uh to

811
00:30:58,880 --> 00:31:00,320
understand that there are much more

812
00:31:00,320 --> 00:31:02,000
information to protect in presence of

813
00:31:02,000 --> 00:31:04,799
his gender that only the single key and

814
00:31:04,799 --> 00:31:06,640
moreover we must consider that

815
00:31:06,640 --> 00:31:09,360
cryptographic devices should not be seen

816
00:31:09,360 --> 00:31:12,080
as black box oracles

817
00:31:12,080 --> 00:31:14,640
and then we have the problem of defining

818
00:31:14,640 --> 00:31:16,399
security of

819
00:31:16,399 --> 00:31:17,840
the block cipher the tweak of block

820
00:31:17,840 --> 00:31:20,880
cipher in presence of leakage there is a

821
00:31:20,880 --> 00:31:23,200
enough sanction which is ideal which is

822
00:31:23,200 --> 00:31:24,320
leak free

823
00:31:24,320 --> 00:31:26,799
which says that the leakage gives no

824
00:31:26,799 --> 00:31:29,519
information about the secret of the

825
00:31:29,519 --> 00:31:31,919
block cipher but it is problematic

826
00:31:31,919 --> 00:31:35,279
because it's not verifiable thus in

827
00:31:35,279 --> 00:31:37,519
this talk and in the paper we use a

828
00:31:37,519 --> 00:31:39,760
strong unpredictability with leakage

829
00:31:39,760 --> 00:31:42,159
which means that for diversity is

830
00:31:42,159 --> 00:31:44,960
difficult to predict a new output for a

831
00:31:44,960 --> 00:31:46,880
fresh query of the block cipher or

832
00:31:46,880 --> 00:31:49,679
tweakable block cipher even if she has

833
00:31:49,679 --> 00:31:52,240
access to the leakage of

834
00:31:52,240 --> 00:31:55,919
f and of f minus one

835
00:31:56,480 --> 00:31:58,720
here now i will present the results of

836
00:31:58,720 --> 00:32:00,799
our paper which are

837
00:32:00,799 --> 00:32:02,399
three max

838
00:32:02,399 --> 00:32:04,960
which are strong and pretty which are um

839
00:32:04,960 --> 00:32:06,799
which provides integrity in presence of

840
00:32:06,799 --> 00:32:09,679
leakage the first use a one clickable

841
00:32:09,679 --> 00:32:11,600
block cipher call and a collision

842
00:32:11,600 --> 00:32:13,840
resistant ash and it is beyond birthday

843
00:32:13,840 --> 00:32:16,640
secure if the tweak is uh longer than

844
00:32:16,640 --> 00:32:19,360
the block size of the

845
00:32:19,360 --> 00:32:20,559
block cipher

846
00:32:20,559 --> 00:32:22,159
then we have a second typical block

847
00:32:22,159 --> 00:32:24,880
cipher which used two tbc calls and the

848
00:32:24,880 --> 00:32:27,039
collisional resistance ash and we can

849
00:32:27,039 --> 00:32:30,480
provide beyond the security even

850
00:32:30,480 --> 00:32:31,760
adding a

851
00:32:31,760 --> 00:32:34,640
standard standard model hypothesis on an

852
00:32:34,640 --> 00:32:36,159
additional fundamental hypothesis for

853
00:32:36,159 --> 00:32:38,559
the function then the third

854
00:32:38,559 --> 00:32:40,960
which is which user which is the more

855
00:32:40,960 --> 00:32:43,039
efficient which use one tbc call and the

856
00:32:43,039 --> 00:32:46,320
collision resistant ash it is

857
00:32:46,320 --> 00:32:48,399
we can provide security with strong

858
00:32:48,399 --> 00:32:50,960
assumption on the ash function

859
00:32:50,960 --> 00:32:53,120
in for all these uh

860
00:32:53,120 --> 00:32:55,039
in the security in the security analysis

861
00:32:55,039 --> 00:32:57,200
of all this construction we assume that

862
00:32:57,200 --> 00:32:58,559
it triggers block cipher to be strong

863
00:32:58,559 --> 00:33:00,399
and predictable with the cage

864
00:33:00,399 --> 00:33:02,559
i will show one of this construction the

865
00:33:02,559 --> 00:33:03,360
first

866
00:33:03,360 --> 00:33:05,679
one of the program that we

867
00:33:05,679 --> 00:33:08,159
we discovered studying this is that

868
00:33:08,159 --> 00:33:10,000
there may be some problematic

869
00:33:10,000 --> 00:33:12,240
interaction between the hash function

870
00:33:12,240 --> 00:33:14,000
and the trick of block cipher when there

871
00:33:14,000 --> 00:33:17,279
is leakage so what we do is to use to

872
00:33:17,279 --> 00:33:19,840
prove to present this

873
00:33:19,840 --> 00:33:22,880
smack where we have the message which is

874
00:33:22,880 --> 00:33:24,880
to attain a value h which is used only

875
00:33:24,880 --> 00:33:26,240
as a tweak of the two called block

876
00:33:26,240 --> 00:33:28,720
cipher then we use a fixed input for the

877
00:33:28,720 --> 00:33:30,240
tweet called block cipher and we obtain

878
00:33:30,240 --> 00:33:32,320
the tag

879
00:33:32,320 --> 00:33:34,799
from this fixed input which in this case

880
00:33:34,799 --> 00:33:37,039
is zero and and the district

881
00:33:37,039 --> 00:33:38,399
the idea is to

882
00:33:38,399 --> 00:33:40,880
use the message and so the hash of the

883
00:33:40,880 --> 00:33:42,880
message only is a tweak and to use a

884
00:33:42,880 --> 00:33:44,799
fixed input for the tweakable lock

885
00:33:44,799 --> 00:33:47,120
cipher and in verification we would like

886
00:33:47,120 --> 00:33:48,799
to use the inverse of the tweakable

887
00:33:48,799 --> 00:33:51,519
block section so what we do is again we

888
00:33:51,519 --> 00:33:52,480
take

889
00:33:52,480 --> 00:33:55,039
to verify what we do is again we compute

890
00:33:55,039 --> 00:33:56,399
the ash of the

891
00:33:56,399 --> 00:33:57,360
message

892
00:33:57,360 --> 00:33:59,440
and we inverse that we call block cipher

893
00:33:59,440 --> 00:34:01,919
and we obtain a value x tilde

894
00:34:01,919 --> 00:34:04,559
which and then we check if this value is

895
00:34:04,559 --> 00:34:06,159
equal to zero n

896
00:34:06,159 --> 00:34:08,320
which is the fixed input for the two tbc

897
00:34:08,320 --> 00:34:09,599
or not

898
00:34:09,599 --> 00:34:12,399
the idea is that this if this x tilde is

899
00:34:12,399 --> 00:34:13,280
leaked

900
00:34:13,280 --> 00:34:15,119
no problem because if this is zero and

901
00:34:15,119 --> 00:34:16,719
you have already forged if it is not

902
00:34:16,719 --> 00:34:18,399
zero and you cannot use for a new

903
00:34:18,399 --> 00:34:21,440
fortran and so using this idea we can

904
00:34:21,440 --> 00:34:24,239
prove that this construction is secure

905
00:34:24,239 --> 00:34:26,480
only with uh assumption that can be

906
00:34:26,480 --> 00:34:28,159
verified by available

907
00:34:28,159 --> 00:34:30,399
i thank you for your attention and i'm

908
00:34:30,399 --> 00:34:32,159
open for

909
00:34:32,159 --> 00:34:35,399
any question

910
00:34:40,480 --> 00:34:43,599
yeah i have a question about the capital

911
00:34:43,599 --> 00:34:44,960
f function

912
00:34:44,960 --> 00:34:47,359
it's the same thing to the mac function

913
00:34:47,359 --> 00:34:50,560
we use normally

914
00:34:51,040 --> 00:34:55,599
what the f is a trigger block cipher

915
00:35:00,640 --> 00:35:03,839
is a trigger block cipher

916
00:35:03,839 --> 00:35:07,359
so this allows that you insert

917
00:35:07,359 --> 00:35:09,920
the m bit of zero as an input

918
00:35:09,920 --> 00:35:12,160
yeah

919
00:35:13,200 --> 00:35:15,040
we use a constant input for logical

920
00:35:15,040 --> 00:35:16,560
excitement

921
00:35:16,560 --> 00:35:18,720
and what changes during uh mac

922
00:35:18,720 --> 00:35:21,280
authentication are the trick

923
00:35:21,280 --> 00:35:23,440
essentially you can choose

924
00:35:23,440 --> 00:35:25,040
any strings

925
00:35:25,040 --> 00:35:27,520
any constant string as an input okay as

926
00:35:27,520 --> 00:35:31,040
long as that into the inverse

927
00:35:32,000 --> 00:35:34,160
yeah the important stuff is that you use

928
00:35:34,160 --> 00:35:36,240
only the same uh

929
00:35:36,240 --> 00:35:38,560
constant string as input for all mac

930
00:35:38,560 --> 00:35:40,400
queries

931
00:35:40,400 --> 00:35:42,240
what is the constant input is not

932
00:35:42,240 --> 00:35:45,240
important

933
00:35:45,920 --> 00:35:47,680
because if you change also the constant

934
00:35:47,680 --> 00:35:50,720
input for all this

935
00:35:50,880 --> 00:35:52,960
you may have x tilde which is equal on

936
00:35:52,960 --> 00:35:55,760
one of these constant inputs

937
00:35:55,760 --> 00:35:59,400
and this may be problematic

938
00:36:04,800 --> 00:36:06,640
yes thank you francesco i have another

939
00:36:06,640 --> 00:36:08,880
question uh you are assuming that the

940
00:36:08,880 --> 00:36:12,000
tickle to cover block cipher can is

941
00:36:12,000 --> 00:36:14,320
unpredictable for the leakage right this

942
00:36:14,320 --> 00:36:16,079
is one

943
00:36:16,079 --> 00:36:18,800
how realistic is this in your opinion

944
00:36:18,800 --> 00:36:20,000
to assume this

945
00:36:20,000 --> 00:36:20,720
well

946
00:36:20,720 --> 00:36:22,400
in my opinion

947
00:36:22,400 --> 00:36:24,960
first if it's not unpredictable with

948
00:36:24,960 --> 00:36:27,680
leakage we cannot have any security

949
00:36:27,680 --> 00:36:29,520
using trigger block cipher

950
00:36:29,520 --> 00:36:31,680
so at least

951
00:36:31,680 --> 00:36:33,839
uh this is the minimum requirement if

952
00:36:33,839 --> 00:36:35,390
you can predict new output

953
00:36:35,390 --> 00:36:36,880
[Music]

954
00:36:36,880 --> 00:36:39,359
which click there is no point to use

955
00:36:39,359 --> 00:36:40,880
something

956
00:36:40,880 --> 00:36:43,280
it may be really problematic second i

957
00:36:43,280 --> 00:36:46,720
think that substantially

958
00:36:47,359 --> 00:36:49,760
stronger predictability it is much or

959
00:36:49,760 --> 00:36:51,760
less the same as retrieving the key

960
00:36:51,760 --> 00:36:55,040
because i do not see as why

961
00:36:55,040 --> 00:36:57,839
for a good block cipher you can predict

962
00:36:57,839 --> 00:37:00,800
the output not knowing the key for new

963
00:37:00,800 --> 00:37:03,920
in for a new couple input for new input

964
00:37:03,920 --> 00:37:05,760
and tweak

965
00:37:05,760 --> 00:37:08,640
i do not see how you

966
00:37:08,640 --> 00:37:10,800
you can do a prediction for a good

967
00:37:10,800 --> 00:37:11,680
figure

968
00:37:11,680 --> 00:37:14,960
without knowing the key

969
00:37:15,599 --> 00:37:16,560
okay

970
00:37:16,560 --> 00:37:19,520
fair enough uh thank you very much so i

971
00:37:19,520 --> 00:37:22,000
don't know if there are more questions

972
00:37:22,000 --> 00:37:23,760
so sorry

973
00:37:23,760 --> 00:37:26,400
please go ahead

974
00:37:28,480 --> 00:37:31,200
no sorry i was stopping sharing

975
00:37:31,200 --> 00:37:34,400
oh yeah yeah i can see it no yeah yeah

976
00:37:34,400 --> 00:37:36,240
okay francesco thank you very much for

977
00:37:36,240 --> 00:37:38,000
your presentations in my presentation

978
00:37:38,000 --> 00:37:42,240
and we will move now to our next speaker

979
00:37:42,240 --> 00:37:43,920
um

980
00:37:43,920 --> 00:37:46,400
so we will ask as young men seem to

981
00:37:46,400 --> 00:37:48,480
present default

982
00:37:48,480 --> 00:37:50,560
cipher level resistance against

983
00:37:50,560 --> 00:37:53,280
differential fault attack uh please see

984
00:37:53,280 --> 00:37:57,520
an uh go ahead the floor is yours

985
00:37:57,520 --> 00:37:59,760
hello unfortunately uh ciamin couldn't

986
00:37:59,760 --> 00:38:01,599
be here today so i will be presenting

987
00:38:01,599 --> 00:38:02,720
the extent

988
00:38:02,720 --> 00:38:05,200
mustafa

989
00:38:16,640 --> 00:38:19,920
and the team is from like ntu

990
00:38:19,920 --> 00:38:21,839
austria

991
00:38:21,839 --> 00:38:25,040
ds phone labs

992
00:38:25,040 --> 00:38:27,839
and in this talk i will just give a

993
00:38:27,839 --> 00:38:29,040
brief

994
00:38:29,040 --> 00:38:30,880
discussion of the paper so i will give

995
00:38:30,880 --> 00:38:33,680
an introduction to dfa attacks

996
00:38:33,680 --> 00:38:36,400
and the dfa resistant framework will

997
00:38:36,400 --> 00:38:37,760
propose and then the actual

998
00:38:37,760 --> 00:38:39,440
instantiation that we propose in the

999
00:38:39,440 --> 00:38:41,520
paper

1000
00:38:41,520 --> 00:38:42,560
so

1001
00:38:42,560 --> 00:38:45,119
fault attacks are a form of

1002
00:38:45,119 --> 00:38:47,200
invasive side channel attack so you have

1003
00:38:47,200 --> 00:38:48,320
the cipher

1004
00:38:48,320 --> 00:38:49,760
and you

1005
00:38:49,760 --> 00:38:52,560
actively inject a fault inside and then

1006
00:38:52,560 --> 00:38:55,119
based on the values of the output the

1007
00:38:55,119 --> 00:38:56,400
cipher text

1008
00:38:56,400 --> 00:38:58,560
you can predict some information about

1009
00:38:58,560 --> 00:39:01,839
the key or the plain text

1010
00:39:02,320 --> 00:39:04,880
and usually to protect it we need

1011
00:39:04,880 --> 00:39:07,119
physical protection on the engineering

1012
00:39:07,119 --> 00:39:08,240
level so

1013
00:39:08,240 --> 00:39:10,320
we need some form of

1014
00:39:10,320 --> 00:39:12,839
shield inside the integrated circuit

1015
00:39:12,839 --> 00:39:15,599
or something like duplication

1016
00:39:15,599 --> 00:39:17,680
full detection so we encrypt twice and

1017
00:39:17,680 --> 00:39:19,920
then we detect whether the ciphertext is

1018
00:39:19,920 --> 00:39:22,720
different or not

1019
00:39:23,359 --> 00:39:25,280
however such

1020
00:39:25,280 --> 00:39:27,440
counter measures can still be bypassed

1021
00:39:27,440 --> 00:39:30,000
by injecting stronger folds or by

1022
00:39:30,000 --> 00:39:31,839
injecting the same fault twice in both

1023
00:39:31,839 --> 00:39:35,920
executions in case of duplication

1024
00:39:36,079 --> 00:39:37,359
so

1025
00:39:37,359 --> 00:39:39,440
what we were looking for is

1026
00:39:39,440 --> 00:39:41,359
fault resilience we were looking for a

1027
00:39:41,359 --> 00:39:43,280
cipher level solution

1028
00:39:43,280 --> 00:39:46,240
that can be applied on top of existing

1029
00:39:46,240 --> 00:39:47,599
block ciphers

1030
00:39:47,599 --> 00:39:48,400
and

1031
00:39:48,400 --> 00:39:49,920
can provide

1032
00:39:49,920 --> 00:39:52,320
a lower bound on the

1033
00:39:52,320 --> 00:39:54,800
search complexity of dfa in terms of the

1034
00:39:54,800 --> 00:39:57,839
key recovery

1035
00:39:58,480 --> 00:40:01,040
so we proposed a dfa resistance

1036
00:40:01,040 --> 00:40:02,160
framework

1037
00:40:02,160 --> 00:40:04,400
and in the first part of the paper we

1038
00:40:04,400 --> 00:40:07,440
look first at the main problem where dfa

1039
00:40:07,440 --> 00:40:09,599
comes from which is the xbox

1040
00:40:09,599 --> 00:40:13,680
so the s-vox is an n-bit lookup table

1041
00:40:13,680 --> 00:40:14,640
and

1042
00:40:14,640 --> 00:40:17,680
usually in dfa we will inject a fault at

1043
00:40:17,680 --> 00:40:20,480
the input of the s-box

1044
00:40:20,480 --> 00:40:22,000
and we will observe the output

1045
00:40:22,000 --> 00:40:23,119
difference

1046
00:40:23,119 --> 00:40:25,520
and from this equation

1047
00:40:25,520 --> 00:40:27,280
we can find

1048
00:40:27,280 --> 00:40:29,119
some solutions for x and then by

1049
00:40:29,119 --> 00:40:32,480
repeating the equation two or four times

1050
00:40:32,480 --> 00:40:36,160
we can solve and find x uniquely

1051
00:40:36,160 --> 00:40:38,880
and this is used to recover the key with

1052
00:40:38,880 --> 00:40:40,880
very small number of faults

1053
00:40:40,880 --> 00:40:44,240
and that's because when we design good

1054
00:40:44,240 --> 00:40:45,520
s-boxes

1055
00:40:45,520 --> 00:40:48,240
usually they have a

1056
00:40:48,240 --> 00:40:50,480
very low differential property

1057
00:40:50,480 --> 00:40:51,520
and

1058
00:40:51,520 --> 00:40:53,119
what happens is

1059
00:40:53,119 --> 00:40:55,599
this low probability means that we can

1060
00:40:55,599 --> 00:40:57,359
solve with very small number of

1061
00:40:57,359 --> 00:40:58,960
differences if we have access to one

1062
00:40:58,960 --> 00:41:01,680
xbox which is the case in dfa

1063
00:41:01,680 --> 00:41:02,720
so

1064
00:41:02,720 --> 00:41:04,400
for a normal cipher this doesn't matter

1065
00:41:04,400 --> 00:41:06,480
because we have many rounds but for when

1066
00:41:06,480 --> 00:41:08,000
we're considering dfk and we're

1067
00:41:08,000 --> 00:41:09,839
accessing say one round this becomes a

1068
00:41:09,839 --> 00:41:12,240
problem

1069
00:41:13,920 --> 00:41:14,960
so

1070
00:41:14,960 --> 00:41:17,119
as i said the good properties of the s

1071
00:41:17,119 --> 00:41:20,319
box make dfk easier so we inject a fault

1072
00:41:20,319 --> 00:41:22,720
and we observe the output difference and

1073
00:41:22,720 --> 00:41:24,319
usually this leads to a very small

1074
00:41:24,319 --> 00:41:27,520
number of solutions for k

1075
00:41:27,520 --> 00:41:30,640
and we repeat a few times and we can

1076
00:41:30,640 --> 00:41:32,800
uniquely identify k by reducing the key

1077
00:41:32,800 --> 00:41:35,280
space every time

1078
00:41:35,280 --> 00:41:37,359
so we observe that

1079
00:41:37,359 --> 00:41:39,839
if the s-box has what we call linear

1080
00:41:39,839 --> 00:41:41,040
structure

1081
00:41:41,040 --> 00:41:43,280
so for example it has one input

1082
00:41:43,280 --> 00:41:45,520
difference that always goes to the same

1083
00:41:45,520 --> 00:41:47,200
output difference

1084
00:41:47,200 --> 00:41:50,240
then the situation is slightly changed

1085
00:41:50,240 --> 00:41:53,040
of course any s box will have the input

1086
00:41:53,040 --> 00:41:54,720
difference zero always go to output

1087
00:41:54,720 --> 00:41:56,000
different zero

1088
00:41:56,000 --> 00:41:57,920
but we want non-trivial linear

1089
00:41:57,920 --> 00:42:00,000
structures so we want

1090
00:42:00,000 --> 00:42:02,160
s boxes that have other non-zero

1091
00:42:02,160 --> 00:42:04,880
differences that have this progress

1092
00:42:04,880 --> 00:42:05,920
and

1093
00:42:05,920 --> 00:42:07,920
what we observe is that

1094
00:42:07,920 --> 00:42:10,000
if we have this property then we can

1095
00:42:10,000 --> 00:42:11,599
never uniquely i

1096
00:42:11,599 --> 00:42:12,800
identify

1097
00:42:12,800 --> 00:42:13,520
the

1098
00:42:13,520 --> 00:42:16,480
z in this case or the key if we have a

1099
00:42:16,480 --> 00:42:20,160
key export to the output of the xbox

1100
00:42:20,160 --> 00:42:22,480
so even if we

1101
00:42:22,480 --> 00:42:25,200
apply many faults we can never uniquely

1102
00:42:25,200 --> 00:42:27,119
identify the key

1103
00:42:27,119 --> 00:42:29,599
we can only reduce the key space

1104
00:42:29,599 --> 00:42:32,160
to a size that depends on how many of

1105
00:42:32,160 --> 00:42:33,920
these linear structures exist in the

1106
00:42:33,920 --> 00:42:36,240
s-box

1107
00:42:36,240 --> 00:42:36,960
so

1108
00:42:36,960 --> 00:42:39,359
based on this we think this is good for

1109
00:42:39,359 --> 00:42:40,560
dfa

1110
00:42:40,560 --> 00:42:42,240
because

1111
00:42:42,240 --> 00:42:45,920
we since we can bound the number of key

1112
00:42:45,920 --> 00:42:47,760
candidates that we can get out of this

1113
00:42:47,760 --> 00:42:49,599
then it might be helpful for dfa

1114
00:42:49,599 --> 00:42:52,160
protection

1115
00:42:52,319 --> 00:42:55,040
so for example here

1116
00:42:55,040 --> 00:42:56,319
we

1117
00:42:56,319 --> 00:42:59,119
look at some cases so if we have a four

1118
00:42:59,119 --> 00:43:01,760
bit xbox

1119
00:43:01,760 --> 00:43:04,640
and we have

1120
00:43:04,640 --> 00:43:07,680
a 128 bit state or block size then we

1121
00:43:07,680 --> 00:43:10,160
will need 32 s boxes

1122
00:43:10,160 --> 00:43:12,240
and if we have one linear structure

1123
00:43:12,240 --> 00:43:14,480
which is the trivial case only linear

1124
00:43:14,480 --> 00:43:18,240
structure at zero difference zero

1125
00:43:18,240 --> 00:43:22,480
then we can uniquely solve the s box and

1126
00:43:22,480 --> 00:43:23,200
we

1127
00:43:23,200 --> 00:43:26,319
can uniquely find the ground key well if

1128
00:43:26,319 --> 00:43:28,640
we have two linear structures so there

1129
00:43:28,640 --> 00:43:31,359
is one more difference that has this

1130
00:43:31,359 --> 00:43:33,440
property

1131
00:43:33,440 --> 00:43:34,319
then

1132
00:43:34,319 --> 00:43:36,000
we can

1133
00:43:36,000 --> 00:43:39,359
at most reduce the solution space to two

1134
00:43:39,359 --> 00:43:40,480
values

1135
00:43:40,480 --> 00:43:42,480
and if we have 32

1136
00:43:42,480 --> 00:43:44,480
s boxes this would lead to a key space

1137
00:43:44,480 --> 00:43:47,680
of 2 to the power 32.

1138
00:43:47,680 --> 00:43:50,160
if we have 4 linear structures

1139
00:43:50,160 --> 00:43:52,240
then

1140
00:43:52,240 --> 00:43:54,000
the number of solutions is four and the

1141
00:43:54,000 --> 00:43:56,400
number of overall key space is to the

1142
00:43:56,400 --> 00:44:00,000
power 64 which is around birthday bound

1143
00:44:00,000 --> 00:44:03,440
if we have eight bit as box

1144
00:44:03,440 --> 00:44:05,440
the these numbers become better but the

1145
00:44:05,440 --> 00:44:07,680
problem is it's harder to come up with

1146
00:44:07,680 --> 00:44:09,200
this s box

1147
00:44:09,200 --> 00:44:11,200
with more linear structures when you

1148
00:44:11,200 --> 00:44:12,960
skip it because the search space is much

1149
00:44:12,960 --> 00:44:15,280
bigger

1150
00:44:16,960 --> 00:44:18,000
so

1151
00:44:18,000 --> 00:44:20,880
based on this in mind we propose the gfa

1152
00:44:20,880 --> 00:44:22,720
resistance framework

1153
00:44:22,720 --> 00:44:25,599
which we say that if we have a cipher e

1154
00:44:25,599 --> 00:44:28,160
we assume that we have a

1155
00:44:28,160 --> 00:44:31,200
construction that's secure against gfa

1156
00:44:31,200 --> 00:44:33,760
and we applied before and after the

1157
00:44:33,760 --> 00:44:35,280
encryption

1158
00:44:35,280 --> 00:44:37,920
so if we're doing encryption

1159
00:44:37,920 --> 00:44:40,240
usually dfa will be applied towards the

1160
00:44:40,240 --> 00:44:42,880
end of the encryption and since the

1161
00:44:42,880 --> 00:44:44,400
rounds at the end are part of this

1162
00:44:44,400 --> 00:44:45,920
construction they should be secure

1163
00:44:45,920 --> 00:44:47,440
against gfa

1164
00:44:47,440 --> 00:44:49,280
and if we're doing decryption then it

1165
00:44:49,280 --> 00:44:50,880
will be the opposite and the layer at

1166
00:44:50,880 --> 00:44:52,400
the beginning will

1167
00:44:52,400 --> 00:44:55,200
have this problem

1168
00:44:56,640 --> 00:44:59,599
based on these two ideas we propose the

1169
00:44:59,599 --> 00:45:02,000
default which is an instantiation of the

1170
00:45:02,000 --> 00:45:05,040
dfa resistant framework

1171
00:45:05,040 --> 00:45:08,480
and basically we have a default core

1172
00:45:08,480 --> 00:45:10,079
which is a normal

1173
00:45:10,079 --> 00:45:12,880
128 bit block cipher it's based on the

1174
00:45:12,880 --> 00:45:15,040
gift permutation

1175
00:45:15,040 --> 00:45:17,200
and we have default layer which is used

1176
00:45:17,200 --> 00:45:19,440
to implement the outer layers

1177
00:45:19,440 --> 00:45:21,119
and the difference is for the default

1178
00:45:21,119 --> 00:45:23,200
layer we use these as boxes with linear

1179
00:45:23,200 --> 00:45:25,759
structures

1180
00:45:26,240 --> 00:45:27,280
and

1181
00:45:27,280 --> 00:45:29,760
if we you don't use want to use default

1182
00:45:29,760 --> 00:45:31,440
core the idea was to

1183
00:45:31,440 --> 00:45:34,160
that you can use default layer

1184
00:45:34,160 --> 00:45:35,839
for any cipher it doesn't have to be

1185
00:45:35,839 --> 00:45:37,760
default code

1186
00:45:37,760 --> 00:45:40,560
and the goal is to have 64-bit security

1187
00:45:40,560 --> 00:45:43,280
against dfe

1188
00:45:43,280 --> 00:45:45,440
unfortunately the combination of the

1189
00:45:45,440 --> 00:45:47,599
xbox idea with the dfa

1190
00:45:47,599 --> 00:45:50,480
resistance framework led to more recent

1191
00:45:50,480 --> 00:45:52,000
crypt analysis

1192
00:45:52,000 --> 00:45:54,880
and new attacks emerge which show that

1193
00:45:54,880 --> 00:45:57,839
the xbox when used inside an spn

1194
00:45:57,839 --> 00:45:58,720
will

1195
00:45:58,720 --> 00:46:00,640
so it's true that we will never be able

1196
00:46:00,640 --> 00:46:02,880
to uniquely identify the key but we will

1197
00:46:02,880 --> 00:46:05,440
be able to get a

1198
00:46:05,440 --> 00:46:08,079
equivalent key that can be used to

1199
00:46:08,079 --> 00:46:11,280
instead of the actual key

1200
00:46:11,440 --> 00:46:13,520
while it requires more faults

1201
00:46:13,520 --> 00:46:15,920
than a normal spn it still does not

1202
00:46:15,920 --> 00:46:19,359
provide the intended dfa security

1203
00:46:19,359 --> 00:46:22,640
so now the current research question is

1204
00:46:22,640 --> 00:46:24,800
can we use these default xboxes in a

1205
00:46:24,800 --> 00:46:27,440
different construction that's not spn

1206
00:46:27,440 --> 00:46:30,640
to provide the intended security

1207
00:46:30,640 --> 00:46:32,240
thanks for listening if you have any

1208
00:46:32,240 --> 00:46:34,640
questions

1209
00:46:36,240 --> 00:46:40,078
thank you mustafa for your presentation

1210
00:46:40,839 --> 00:46:45,440
um i have a question related to

1211
00:46:45,440 --> 00:46:48,800
the practicability visibility visibility

1212
00:46:48,800 --> 00:46:50,480
of your attack

1213
00:46:50,480 --> 00:46:52,319
because you are assuming that the the

1214
00:46:52,319 --> 00:46:54,960
attacker can

1215
00:46:54,960 --> 00:46:56,000
can

1216
00:46:56,000 --> 00:46:57,760
can launch several faults for instance

1217
00:46:57,760 --> 00:47:00,079
in this in this slide right

1218
00:47:00,079 --> 00:47:01,359
how

1219
00:47:01,359 --> 00:47:03,920
yes how practical is that an attacker

1220
00:47:03,920 --> 00:47:06,000
this should be a very powerful attacker

1221
00:47:06,000 --> 00:47:08,240
right that can inject not one but two

1222
00:47:08,240 --> 00:47:09,280
faults

1223
00:47:09,280 --> 00:47:11,280
in a very timing manner

1224
00:47:11,280 --> 00:47:12,240
no

1225
00:47:12,240 --> 00:47:14,240
the two faults here are not meant to be

1226
00:47:14,240 --> 00:47:15,839
in the same execution so you will fix

1227
00:47:15,839 --> 00:47:17,119
the plaintext

1228
00:47:17,119 --> 00:47:20,319
yeah and then encrypt it many times

1229
00:47:20,319 --> 00:47:21,920
and each time you will inject a

1230
00:47:21,920 --> 00:47:25,240
different food

1231
00:47:25,599 --> 00:47:29,040
have you made experiments on this

1232
00:47:29,040 --> 00:47:30,559
normally this is the same fault model

1233
00:47:30,559 --> 00:47:33,200
that's used to attack aes of course when

1234
00:47:33,200 --> 00:47:34,720
the number of faults increases it

1235
00:47:34,720 --> 00:47:36,079
becomes harder

1236
00:47:36,079 --> 00:47:37,359
but uh

1237
00:47:37,359 --> 00:47:40,240
dfa against aes works in exactly the

1238
00:47:40,240 --> 00:47:41,280
same way

1239
00:47:41,280 --> 00:47:42,640
you

1240
00:47:42,640 --> 00:47:44,480
inject you encrypt the same plaintext

1241
00:47:44,480 --> 00:47:46,800
twice or three times one without fault

1242
00:47:46,800 --> 00:47:48,480
and then two times you inject different

1243
00:47:48,480 --> 00:47:51,480
folds

1244
00:47:54,400 --> 00:47:55,839
in this work you didn't try this

1245
00:47:55,839 --> 00:47:57,119
experiment no no

1246
00:47:57,119 --> 00:47:59,599
okay okay thank you very much i don't

1247
00:47:59,599 --> 00:48:01,119
know if there is there are more

1248
00:48:01,119 --> 00:48:04,480
questions uh for musafa

1249
00:48:04,480 --> 00:48:06,800
uh so about the crypto analysis

1250
00:48:06,800 --> 00:48:08,960
of the scheme mentioned that there's

1251
00:48:08,960 --> 00:48:10,319
some

1252
00:48:10,319 --> 00:48:12,079
a successful attack

1253
00:48:12,079 --> 00:48:14,960
so i don't understand the implication of

1254
00:48:14,960 --> 00:48:16,559
this attack that doesn't mean that

1255
00:48:16,559 --> 00:48:19,680
default cipher is not secure

1256
00:48:19,680 --> 00:48:22,480
so yeah so it means that uh

1257
00:48:22,480 --> 00:48:24,000
yeah it doesn't it doesn't provide

1258
00:48:24,000 --> 00:48:26,079
64-bit security because

1259
00:48:26,079 --> 00:48:27,440
while the attack

1260
00:48:27,440 --> 00:48:29,280
requires i think

1261
00:48:29,280 --> 00:48:32,000
even if you have like

1262
00:48:32,000 --> 00:48:34,800
independent round keys for the default

1263
00:48:34,800 --> 00:48:37,440
layer it will require i think around 2

1264
00:48:37,440 --> 00:48:40,079
000 volts but it would still

1265
00:48:40,079 --> 00:48:42,880
not file uniquely find the key but will

1266
00:48:42,880 --> 00:48:45,760
find some equivalent key that

1267
00:48:45,760 --> 00:48:48,400
you don't need the actual key anymore so

1268
00:48:48,400 --> 00:48:50,480
yeah i mean in the current construction

1269
00:48:50,480 --> 00:48:53,760
it does not provide the intended skills

1270
00:48:53,760 --> 00:48:56,720
the best i think still provides uh to

1271
00:48:56,720 --> 00:48:58,800
some extent the security for example uh

1272
00:48:58,800 --> 00:49:02,160
this kurdigo is 64-bit right so after

1273
00:49:02,160 --> 00:49:03,520
the attack

1274
00:49:03,520 --> 00:49:05,280
it's launched so how many bits of

1275
00:49:05,280 --> 00:49:08,319
security have or roughly speaking uh so

1276
00:49:08,319 --> 00:49:10,000
after this

1277
00:49:10,000 --> 00:49:12,400
number of faults

1278
00:49:12,400 --> 00:49:14,319
because the thing is

1279
00:49:14,319 --> 00:49:15,839
you don't care about the actual key

1280
00:49:15,839 --> 00:49:18,240
anymore the equivalent key is enough so

1281
00:49:18,240 --> 00:49:19,520
after

1282
00:49:19,520 --> 00:49:22,079
x number of faults you will not

1283
00:49:22,079 --> 00:49:24,160
like there will be no security maybe the

1284
00:49:24,160 --> 00:49:26,000
number of faults is larger than a normal

1285
00:49:26,000 --> 00:49:27,119
cipher

1286
00:49:27,119 --> 00:49:29,680
but it's still drawable

1287
00:49:29,680 --> 00:49:32,640
i mean in theory at least

1288
00:49:32,640 --> 00:49:35,599
yeah thank you that is kind of a serious

1289
00:49:35,599 --> 00:49:38,720
uh attack for people

1290
00:49:38,720 --> 00:49:40,959
yeah

1291
00:49:41,920 --> 00:49:43,040
okay

1292
00:49:43,040 --> 00:49:44,960
well if there are no more questions for

1293
00:49:44,960 --> 00:49:46,319
musafa thank you very much for your

1294
00:49:46,319 --> 00:49:48,319
presentation mustafa

1295
00:49:48,319 --> 00:49:51,200
and we will move to our last uh paper

1296
00:49:51,200 --> 00:49:53,200
for this session that will be presented

1297
00:49:53,200 --> 00:49:55,760
by abdul rahman talev

1298
00:49:55,760 --> 00:49:58,760
and

1299
00:49:58,880 --> 00:49:59,920
yeah

1300
00:49:59,920 --> 00:50:01,280
so please

1301
00:50:01,280 --> 00:50:03,520
go ahead the floor is yours hi can you

1302
00:50:03,520 --> 00:50:06,480
see my slides yes we can but not in full

1303
00:50:06,480 --> 00:50:09,599
yeah now we can do it yes

1304
00:50:09,599 --> 00:50:11,680
so hi everybody i'm going to present our

1305
00:50:11,680 --> 00:50:14,160
work joined with sonia bellaid materiva

1306
00:50:14,160 --> 00:50:16,960
and damian vanu

1307
00:50:16,960 --> 00:50:18,640
so in this work we reason about the

1308
00:50:18,640 --> 00:50:21,040
security of implementations i guess side

1309
00:50:21,040 --> 00:50:23,200
channel attacks and so the most deployed

1310
00:50:23,200 --> 00:50:24,640
countermeasure against them is the

1311
00:50:24,640 --> 00:50:27,359
masking scheme and so the idea is to

1312
00:50:27,359 --> 00:50:29,520
split a sensitive variable into n values

1313
00:50:29,520 --> 00:50:30,960
that we call shares and their

1314
00:50:30,960 --> 00:50:32,640
recombination should give back the

1315
00:50:32,640 --> 00:50:34,240
original secret

1316
00:50:34,240 --> 00:50:36,559
and so when working with mask variables

1317
00:50:36,559 --> 00:50:38,640
regular operations of add multiplication

1318
00:50:38,640 --> 00:50:41,040
and copy over the field are replaced by

1319
00:50:41,040 --> 00:50:42,559
functionally equivalent and share

1320
00:50:42,559 --> 00:50:44,480
circuits that we call gadgets

1321
00:50:44,480 --> 00:50:46,079
in addition to a new gadget that we call

1322
00:50:46,079 --> 00:50:48,480
refresh which aims to produce a fresh

1323
00:50:48,480 --> 00:50:50,880
and shared copy of the original variable

1324
00:50:50,880 --> 00:50:52,319
and so below you can see an example of

1325
00:50:52,319 --> 00:50:53,920
such an addition gadget with two shares

1326
00:50:53,920 --> 00:50:55,839
for example

1327
00:50:55,839 --> 00:50:57,280
so to reason about the security of

1328
00:50:57,280 --> 00:50:59,359
masking schemes in theory the community

1329
00:50:59,359 --> 00:51:01,760
introduced the idea of leakage models

1330
00:51:01,760 --> 00:51:03,839
and in the in this work we particularly

1331
00:51:03,839 --> 00:51:06,240
focus on the random probing model

1332
00:51:06,240 --> 00:51:08,000
where each variable is considered to

1333
00:51:08,000 --> 00:51:10,000
leak its value with a fixed probability

1334
00:51:10,000 --> 00:51:10,880
p

1335
00:51:10,880 --> 00:51:12,480
now we focus on this model because it

1336
00:51:12,480 --> 00:51:14,079
offers a very interesting trade-off

1337
00:51:14,079 --> 00:51:15,839
between closeness to the reality of

1338
00:51:15,839 --> 00:51:17,920
leakage and convenience for security

1339
00:51:17,920 --> 00:51:20,240
proofs

1340
00:51:20,319 --> 00:51:23,119
so in our work we focus on the strategy

1341
00:51:23,119 --> 00:51:24,640
introduced in the random probing model

1342
00:51:24,640 --> 00:51:26,559
which is called the expansion strategy

1343
00:51:26,559 --> 00:51:28,480
and it actually allows gadgets to be

1344
00:51:28,480 --> 00:51:30,559
composed and expanded to achieve

1345
00:51:30,559 --> 00:51:33,280
arbitrarily large security levels

1346
00:51:33,280 --> 00:51:35,440
now in our work we define the dynamic

1347
00:51:35,440 --> 00:51:37,760
version of the expansion strategy

1348
00:51:37,760 --> 00:51:40,240
the idea is to use a different expanding

1349
00:51:40,240 --> 00:51:41,920
compiler which is formed of a set of

1350
00:51:41,920 --> 00:51:44,400
gadgets at each iteration

1351
00:51:44,400 --> 00:51:47,040
to produce a new circuit where each gate

1352
00:51:47,040 --> 00:51:49,280
is replaced of the original circuit is

1353
00:51:49,280 --> 00:51:51,680
replaced by the corresponding gadget

1354
00:51:51,680 --> 00:51:53,760
and each wire by n wires carrying a

1355
00:51:53,760 --> 00:51:55,680
sharing of the original wire

1356
00:51:55,680 --> 00:51:57,599
now doing so we hope to replace the

1357
00:51:57,599 --> 00:51:59,680
leakage rate p of the original circuit

1358
00:51:59,680 --> 00:52:02,079
by a smaller failure event probability

1359
00:52:02,079 --> 00:52:04,400
in the compiled circuits and this

1360
00:52:04,400 --> 00:52:06,480
strategy can be applied recursively with

1361
00:52:06,480 --> 00:52:08,640
a different compiler at each step to

1362
00:52:08,640 --> 00:52:11,359
achieve a desired security level

1363
00:52:11,359 --> 00:52:13,440
now at the end the failure function is a

1364
00:52:13,440 --> 00:52:15,440
composition of different functions for

1365
00:52:15,440 --> 00:52:17,359
different compilers while in the

1366
00:52:17,359 --> 00:52:19,599
original expansion uh the failure

1367
00:52:19,599 --> 00:52:20,960
function in the static version the

1368
00:52:20,960 --> 00:52:22,720
failure function is just unique and is

1369
00:52:22,720 --> 00:52:24,480
composed with itself a certain number of

1370
00:52:24,480 --> 00:52:26,319
times

1371
00:52:26,319 --> 00:52:28,400
now to show the benefit of using dynamic

1372
00:52:28,400 --> 00:52:30,480
expansion instead of a static expansion

1373
00:52:30,480 --> 00:52:32,640
with a single compiler

1374
00:52:32,640 --> 00:52:34,240
i will show you here a figure

1375
00:52:34,240 --> 00:52:36,160
representing the complexity in terms of

1376
00:52:36,160 --> 00:52:38,240
number of gates of an of a random

1377
00:52:38,240 --> 00:52:39,920
probing secure version of the aes

1378
00:52:39,920 --> 00:52:41,200
algorithm

1379
00:52:41,200 --> 00:52:43,280
and its security after applying the

1380
00:52:43,280 --> 00:52:44,880
expansion strategy

1381
00:52:44,880 --> 00:52:47,040
now for this we use the three share and

1382
00:52:47,040 --> 00:52:48,800
five share compilers proposed in

1383
00:52:48,800 --> 00:52:50,880
eurocrypt 2021 which are the best

1384
00:52:50,880 --> 00:52:52,720
compilers proposed in the state of the

1385
00:52:52,720 --> 00:52:54,640
art until now

1386
00:52:54,640 --> 00:52:56,079
now let's say for instance that we would

1387
00:52:56,079 --> 00:52:58,720
like to achieve 80 bits of security then

1388
00:52:58,720 --> 00:53:00,720
we can achieve it either by doing 11

1389
00:53:00,720 --> 00:53:03,200
iterations of this three share compiler

1390
00:53:03,200 --> 00:53:04,880
but also by starting with seven

1391
00:53:04,880 --> 00:53:06,800
iterations of the three share and then

1392
00:53:06,800 --> 00:53:08,400
two iterations of the five share

1393
00:53:08,400 --> 00:53:10,480
compiler and we have a factor ten

1394
00:53:10,480 --> 00:53:12,800
improvement over the complexity

1395
00:53:12,800 --> 00:53:14,520
if for example we would like to achieve

1396
00:53:14,520 --> 00:53:17,200
128 bits of security then we can still

1397
00:53:17,200 --> 00:53:19,520
use 11 iterational iterations of the

1398
00:53:19,520 --> 00:53:21,760
three share compiler but we could also

1399
00:53:21,760 --> 00:53:23,760
use uh seven iterations of the three

1400
00:53:23,760 --> 00:53:26,079
share compiler and then three iterations

1401
00:53:26,079 --> 00:53:28,559
of the five shares compiler

1402
00:53:28,559 --> 00:53:30,400
and we almost have the same complexity

1403
00:53:30,400 --> 00:53:32,160
but we also almost double the achieved

1404
00:53:32,160 --> 00:53:33,680
security level

1405
00:53:33,680 --> 00:53:35,520
you can actually observe that doing the

1406
00:53:35,520 --> 00:53:38,000
dynamic approach we always win either in

1407
00:53:38,000 --> 00:53:40,079
terms of complexity or achieve security

1408
00:53:40,079 --> 00:53:42,160
and even sometimes in both on both

1409
00:53:42,160 --> 00:53:44,799
parameters

1410
00:53:44,880 --> 00:53:46,319
now after exhibiting the dynamic

1411
00:53:46,319 --> 00:53:47,760
approach we could have two possible

1412
00:53:47,760 --> 00:53:49,839
directions for improvements we can

1413
00:53:49,839 --> 00:53:51,440
either look for gadgets with a small

1414
00:53:51,440 --> 00:53:52,960
number of shares which which can

1415
00:53:52,960 --> 00:53:54,800
tolerate the bets the best leakage rate

1416
00:53:54,800 --> 00:53:57,520
possible to start the compilation with

1417
00:53:57,520 --> 00:53:59,839
and then look for gadgets with the best

1418
00:53:59,839 --> 00:54:01,680
expansion parameters for a generic

1419
00:54:01,680 --> 00:54:03,520
number of shares and with good

1420
00:54:03,520 --> 00:54:05,680
asymptotic complexity to continue on the

1421
00:54:05,680 --> 00:54:07,200
expansion

1422
00:54:07,200 --> 00:54:09,200
now in this work we are able to provide

1423
00:54:09,200 --> 00:54:11,119
an asymptotic construction of gadgets

1424
00:54:11,119 --> 00:54:12,960
with kazi linear

1425
00:54:12,960 --> 00:54:14,480
complexity

1426
00:54:14,480 --> 00:54:16,079
while the best construction which is

1427
00:54:16,079 --> 00:54:19,200
from eurocrypt 2021 achieves

1428
00:54:19,200 --> 00:54:21,280
values for the exponent e in the in the

1429
00:54:21,280 --> 00:54:23,359
complexity which are close to three for

1430
00:54:23,359 --> 00:54:25,440
a reasonable number of shares

1431
00:54:25,440 --> 00:54:27,760
our new compiler quickly achieves a

1432
00:54:27,760 --> 00:54:29,599
sub-quadratic complexity in the same

1433
00:54:29,599 --> 00:54:32,000
settings

1434
00:54:32,720 --> 00:54:34,800
so to summarize our contributions we

1435
00:54:34,800 --> 00:54:36,640
provide a full construction for a new

1436
00:54:36,640 --> 00:54:38,960
rpe compiler with kazi linear asymptotic

1437
00:54:38,960 --> 00:54:41,520
complexity and which improves on the

1438
00:54:41,520 --> 00:54:45,760
best rpe compiler known uh known to date

1439
00:54:45,760 --> 00:54:47,440
and we also introduced the concept of

1440
00:54:47,440 --> 00:54:49,359
dynamic expansion which proves to be

1441
00:54:49,359 --> 00:54:52,160
more interesting than its static version

1442
00:54:52,160 --> 00:54:54,480
and we actually can start the expansion

1443
00:54:54,480 --> 00:54:56,480
with an rpe compiler as i said earlier

1444
00:54:56,480 --> 00:54:58,240
with a small number of shares tolerating

1445
00:54:58,240 --> 00:54:59,680
the best leakage rate

1446
00:54:59,680 --> 00:55:01,920
and then continue on with other rpe

1447
00:55:01,920 --> 00:55:03,760
compilers which don't necessarily

1448
00:55:03,760 --> 00:55:06,400
tolerate a good rate but have a much

1449
00:55:06,400 --> 00:55:08,400
better asymptotic complexity to have an

1450
00:55:08,400 --> 00:55:12,160
overall good asymptotic complexity

1451
00:55:12,559 --> 00:55:14,079
now since the question to the second

1452
00:55:14,079 --> 00:55:16,000
part of the dynamic expansion have been

1453
00:55:16,000 --> 00:55:18,079
partially answered in this work one of

1454
00:55:18,079 --> 00:55:20,160
the natural future works or follow-up

1455
00:55:20,160 --> 00:55:21,920
works would be to find gadgets with

1456
00:55:21,920 --> 00:55:23,680
small number of shares for example three

1457
00:55:23,680 --> 00:55:25,839
share constructions which can tolerate

1458
00:55:25,839 --> 00:55:28,160
the best leakage rate possible

1459
00:55:28,160 --> 00:55:30,079
so that's all i have to say about our

1460
00:55:30,079 --> 00:55:31,280
work and if you're interested i

1461
00:55:31,280 --> 00:55:33,119
encourage you to go read our paper or

1462
00:55:33,119 --> 00:55:35,040
see the full presentation and i'm open

1463
00:55:35,040 --> 00:55:38,079
to any questions thank you

1464
00:55:39,760 --> 00:55:41,280
thank you very much

1465
00:55:41,280 --> 00:55:44,319
for your nice presentation we have a

1466
00:55:44,319 --> 00:55:48,160
question by scientific

1467
00:55:48,160 --> 00:55:50,160
he is asking if you have anything about

1468
00:55:50,160 --> 00:55:53,759
sni uh lick

1469
00:55:54,319 --> 00:55:55,760
sorry if we have

1470
00:55:55,760 --> 00:55:58,079
my my question is how large is the final

1471
00:55:58,079 --> 00:56:00,079
circuit after compilation

1472
00:56:00,079 --> 00:56:01,839
what is the final

1473
00:56:01,839 --> 00:56:04,240
oh yeah

1474
00:56:04,240 --> 00:56:06,160
so the size of the final circuit depends

1475
00:56:06,160 --> 00:56:07,760
on the gadgets that we use in the

1476
00:56:07,760 --> 00:56:09,920
beginning and so the better the security

1477
00:56:09,920 --> 00:56:11,839
parameters of the gadgets are the the

1478
00:56:11,839 --> 00:56:14,079
smaller the the circuit will be so for

1479
00:56:14,079 --> 00:56:16,400
example what i showed earlier on the aes

1480
00:56:16,400 --> 00:56:18,079
you can see that in terms of number of

1481
00:56:18,079 --> 00:56:20,480
gates is huge so it's actually

1482
00:56:20,480 --> 00:56:21,920
it's some kind of a proof of concept but

1483
00:56:21,920 --> 00:56:24,160
it's also an improvement over previous

1484
00:56:24,160 --> 00:56:25,839
work so the first work of the expansion

1485
00:56:25,839 --> 00:56:28,000
was very like theoretical proof of

1486
00:56:28,000 --> 00:56:28,960
concept

1487
00:56:28,960 --> 00:56:31,040
and we're improving on like the size of

1488
00:56:31,040 --> 00:56:32,400
the circuit that we obtain after the

1489
00:56:32,400 --> 00:56:34,000
compilation

1490
00:56:34,000 --> 00:56:36,400
and so we can use for example some sni

1491
00:56:36,400 --> 00:56:38,240
gadgets that are maybe secure in the

1492
00:56:38,240 --> 00:56:39,760
probing model which

1493
00:56:39,760 --> 00:56:41,520
sometimes they are also secure for our

1494
00:56:41,520 --> 00:56:43,599
constructions not always

1495
00:56:43,599 --> 00:56:46,480
and we might obtain like good circuit

1496
00:56:46,480 --> 00:56:48,640
sizes but yeah it still depends on the

1497
00:56:48,640 --> 00:56:50,160
gadgets

1498
00:56:50,160 --> 00:56:53,040
thank you thank you

1499
00:56:53,200 --> 00:56:55,119
then i have a question in this slide now

1500
00:56:55,119 --> 00:56:57,119
that you are here uh do you have any

1501
00:56:57,119 --> 00:56:58,480
proof of

1502
00:56:58,480 --> 00:57:00,400
not proof but maybe some

1503
00:57:00,400 --> 00:57:02,799
ideas of optimality or

1504
00:57:02,799 --> 00:57:04,319
that these are the best possible

1505
00:57:04,319 --> 00:57:05,599
solutions the ones that you're

1506
00:57:05,599 --> 00:57:07,359
presenting

1507
00:57:07,359 --> 00:57:09,599
uh no these these are not necessarily

1508
00:57:09,599 --> 00:57:11,359
the best possible solution solutions but

1509
00:57:11,359 --> 00:57:13,359
in the state of the art until now

1510
00:57:13,359 --> 00:57:16,640
the two compilers are the best ones yet

1511
00:57:16,640 --> 00:57:19,359
but for example in our new work we

1512
00:57:19,359 --> 00:57:20,319
provide

1513
00:57:20,319 --> 00:57:23,040
another compiler which has much better

1514
00:57:23,040 --> 00:57:26,400
uh complexity so it will reduce over

1515
00:57:26,400 --> 00:57:28,319
like the 10 to the power 16 for example

1516
00:57:28,319 --> 00:57:30,240
it will reduce it further

1517
00:57:30,240 --> 00:57:32,720
and also if we can find

1518
00:57:32,720 --> 00:57:34,559
gadgets which can tolerate a better

1519
00:57:34,559 --> 00:57:36,319
leakage rate of this one two to the

1520
00:57:36,319 --> 00:57:39,200
minus 7.6 we can also reduce further the

1521
00:57:39,200 --> 00:57:40,880
complexity

1522
00:57:40,880 --> 00:57:43,520
so we we don't necessarily have yet uh

1523
00:57:43,520 --> 00:57:46,799
minimality arguments between we know

1524
00:57:46,799 --> 00:57:49,040
intuitively that this is not minimal yet

1525
00:57:49,040 --> 00:57:52,000
there is still mushroom

1526
00:57:52,839 --> 00:57:56,000
probably uh finding out this optimality

1527
00:57:56,000 --> 00:57:59,200
resource would be a hard problem right

1528
00:57:59,200 --> 00:58:00,400
it's not

1529
00:58:00,400 --> 00:58:02,640
yeah it's not easy and now for example

1530
00:58:02,640 --> 00:58:04,079
we're looking at the second topic

1531
00:58:04,079 --> 00:58:06,000
question how to find gadgets with best

1532
00:58:06,000 --> 00:58:08,640
tolerated leakage rate and we actually

1533
00:58:08,640 --> 00:58:10,640
observe at some points that it's not

1534
00:58:10,640 --> 00:58:12,480
evident how to find them and even know

1535
00:58:12,480 --> 00:58:14,160
like if they are the best ones how to

1536
00:58:14,160 --> 00:58:16,400
know they are the best ones there are

1537
00:58:16,400 --> 00:58:18,480
many parameters that can

1538
00:58:18,480 --> 00:58:22,000
like modify the the the optimality

1539
00:58:22,000 --> 00:58:23,040
argument

1540
00:58:23,040 --> 00:58:25,520
so at some point we have to fix some

1541
00:58:25,520 --> 00:58:28,000
hypotheses in order to continue on the

1542
00:58:28,000 --> 00:58:29,280
argumentation

1543
00:58:29,280 --> 00:58:30,799
and see like

1544
00:58:30,799 --> 00:58:32,799
it will also it will always depend on

1545
00:58:32,799 --> 00:58:36,400
some kind of fixed parameters

1546
00:58:36,400 --> 00:58:38,559
okay okay thank you very much

1547
00:58:38,559 --> 00:58:42,240
uh some more questions for abdel

1548
00:58:43,680 --> 00:58:45,760
if not then thank you very much for your

1549
00:58:45,760 --> 00:58:48,000
presentation of them uh it was really

1550
00:58:48,000 --> 00:58:48,960
nice

1551
00:58:48,960 --> 00:58:50,480
and with this

1552
00:58:50,480 --> 00:58:53,440
we end our session of physical attacks

1553
00:58:53,440 --> 00:58:55,040
and countermeasures

1554
00:58:55,040 --> 00:58:57,119
so thank you very much for being here

1555
00:58:57,119 --> 00:58:59,440
and we hope that you still

1556
00:58:59,440 --> 00:59:02,480
keep enjoying more of the asia crypt

1557
00:59:02,480 --> 00:59:07,000
main program thank you very much

