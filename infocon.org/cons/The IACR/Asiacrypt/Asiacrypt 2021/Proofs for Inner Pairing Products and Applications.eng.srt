1
00:00:01,040 --> 00:00:04,160
hi i'm cybestly they them

2
00:00:04,160 --> 00:00:06,080
and today i'll be presenting proofs for

3
00:00:06,080 --> 00:00:08,480
inner pairing products and applications

4
00:00:08,480 --> 00:00:10,480
this is a joint work with my excellent

5
00:00:10,480 --> 00:00:13,120
collaborators benedict boones mary

6
00:00:13,120 --> 00:00:15,280
mallor pratush misra

7
00:00:15,280 --> 00:00:18,240
nirvan thiagi

8
00:00:18,560 --> 00:00:20,640
so in this work we use pairing-based

9
00:00:20,640 --> 00:00:23,039
commitments with a structured reference

10
00:00:23,039 --> 00:00:25,599
string to achieve linear time prover and

11
00:00:25,599 --> 00:00:27,920
log time proof and verifier arguments of

12
00:00:27,920 --> 00:00:30,640
knowledge for several relations

13
00:00:30,640 --> 00:00:33,680
first we have tip where we have a vector

14
00:00:33,680 --> 00:00:37,440
of g1 and a vector of g2 elements for a

15
00:00:37,440 --> 00:00:39,840
pairing friendly elliptic curve equipped

16
00:00:39,840 --> 00:00:42,800
with a bilinear pairing and we show that

17
00:00:42,800 --> 00:00:45,120
the interpreting product

18
00:00:45,120 --> 00:00:46,079
of

19
00:00:46,079 --> 00:00:48,559
the these witness vectors is equal to

20
00:00:48,559 --> 00:00:51,760
some public value z not shown here is

21
00:00:51,760 --> 00:00:54,640
that we first have a commitment to

22
00:00:54,640 --> 00:00:58,559
these a and b vectors

23
00:00:58,559 --> 00:01:01,120
we also construct

24
00:01:01,120 --> 00:01:03,600
inner product arguments for

25
00:01:03,600 --> 00:01:05,680
multi-exponentiation

26
00:01:05,680 --> 00:01:06,479
or

27
00:01:06,479 --> 00:01:09,200
multi-scalar multiplication depending on

28
00:01:09,200 --> 00:01:10,960
how you like to write your group

29
00:01:10,960 --> 00:01:12,720
operation

30
00:01:12,720 --> 00:01:15,439
don't worry in our paper we

31
00:01:15,439 --> 00:01:19,040
use both addition and multiplication

32
00:01:19,040 --> 00:01:21,840
so you'll be happy either way

33
00:01:21,840 --> 00:01:24,680
we actually present two

34
00:01:24,680 --> 00:01:26,479
multi-exponentiation inner product

35
00:01:26,479 --> 00:01:28,640
arguments one for

36
00:01:28,640 --> 00:01:31,439
a known vector of exponents and one for

37
00:01:31,439 --> 00:01:35,200
an unknown and committed vector of

38
00:01:35,200 --> 00:01:37,920
exponents

39
00:01:38,960 --> 00:01:40,479
all these schemes are given as an

40
00:01:40,479 --> 00:01:42,079
instantiation

41
00:01:42,079 --> 00:01:46,920
of a protocol jipa which generalizes bcc

42
00:01:46,920 --> 00:01:50,000
gpe16 this was the precursor to the

43
00:01:50,000 --> 00:01:53,200
better known bulletproofs

44
00:01:53,200 --> 00:01:56,479
and lmr 19 which first extended this to

45
00:01:56,479 --> 00:01:58,640
the pairing setting

46
00:01:58,640 --> 00:02:00,880
so the main difference between

47
00:02:00,880 --> 00:02:04,799
our protocols and the ones in llmr

48
00:02:04,799 --> 00:02:07,920
is that we achieve a log time verifier

49
00:02:07,920 --> 00:02:12,239
whereas using pippingers you get an o n

50
00:02:12,239 --> 00:02:14,959
divided by log n group operations

51
00:02:14,959 --> 00:02:19,120
verifier for lmr19 we also reduce prover

52
00:02:19,120 --> 00:02:21,760
complexity and proof size by a constant

53
00:02:21,760 --> 00:02:24,160
factor

54
00:02:25,120 --> 00:02:27,520
we also show a lot of applications of

55
00:02:27,520 --> 00:02:30,400
our inner product arguments in our paper

56
00:02:30,400 --> 00:02:32,319
so for example we build a polynomial

57
00:02:32,319 --> 00:02:34,319
commitment for people who are not

58
00:02:34,319 --> 00:02:37,280
familiar with these the idea is that

59
00:02:37,280 --> 00:02:40,239
alice knows some polynomial

60
00:02:40,239 --> 00:02:43,920
over a finite field of degree at most d

61
00:02:43,920 --> 00:02:47,040
she is able to make a short commitment c

62
00:02:47,040 --> 00:02:48,720
to f x

63
00:02:48,720 --> 00:02:51,840
and send that to bob we'll then send a

64
00:02:51,840 --> 00:02:55,280
challenge point z maybe multiple

65
00:02:55,280 --> 00:02:58,879
but for simplicity we'll say single one

66
00:02:58,879 --> 00:03:00,640
alice responds

67
00:03:00,640 --> 00:03:03,599
with an evaluation v an evaluation proof

68
00:03:03,599 --> 00:03:04,879
pi

69
00:03:04,879 --> 00:03:07,519
which is an argument of knowledge of f

70
00:03:07,519 --> 00:03:09,680
of x such that

71
00:03:09,680 --> 00:03:12,239
f z is equal to v

72
00:03:12,239 --> 00:03:13,040
and

73
00:03:13,040 --> 00:03:15,040
applications of polynomial commitments

74
00:03:15,040 --> 00:03:17,440
include snarks for np accumulators

75
00:03:17,440 --> 00:03:20,000
vector commitments verifiable secret

76
00:03:20,000 --> 00:03:21,440
sharing

77
00:03:21,440 --> 00:03:24,319
and a lot more

78
00:03:26,000 --> 00:03:29,360
so to look at our polynomial commitment

79
00:03:29,360 --> 00:03:30,799
we get

80
00:03:30,799 --> 00:03:32,720
constant size commitments

81
00:03:32,720 --> 00:03:34,159
logarithmic

82
00:03:34,159 --> 00:03:36,959
proof sizes and verifier time

83
00:03:36,959 --> 00:03:41,440
and interestingly we get square root

84
00:03:41,440 --> 00:03:46,480
crs and evaluation prover complexity

85
00:03:46,480 --> 00:03:49,760
so for applications where we need to

86
00:03:49,760 --> 00:03:52,480
deal with really high degree polynomials

87
00:03:52,480 --> 00:03:55,280
such as proofs of replication

88
00:03:55,280 --> 00:03:57,920
or applications where we need to make

89
00:03:57,920 --> 00:04:00,720
numerous or frequent openings of these

90
00:04:00,720 --> 00:04:03,439
polynomials such as accumulators

91
00:04:03,439 --> 00:04:06,319
this provides a good option

92
00:04:06,319 --> 00:04:09,200
to give a concrete example we compare

93
00:04:09,200 --> 00:04:11,840
our work to the state-of-the-art kzg10

94
00:04:11,840 --> 00:04:14,400
polynomial commitment scheme

95
00:04:14,400 --> 00:04:17,680
for polynomials of degree to the 26.

96
00:04:17,680 --> 00:04:20,639
so we see the crs

97
00:04:20,639 --> 00:04:23,600
is dramatically smaller at 3.2

98
00:04:23,600 --> 00:04:26,000
gigabytes versus 4 megabytes that

99
00:04:26,000 --> 00:04:28,639
evaluation improver time shrinks

100
00:04:28,639 --> 00:04:31,360
drastically also from 16 minutes to 15

101
00:04:31,360 --> 00:04:32,479
seconds

102
00:04:32,479 --> 00:04:35,440
and then kzg10 does have better proof

103
00:04:35,440 --> 00:04:38,960
size and verifier time both by a factor

104
00:04:38,960 --> 00:04:43,040
of about 10x but that concretely our

105
00:04:43,040 --> 00:04:45,280
proof size is only a few kilobytes and

106
00:04:45,280 --> 00:04:48,160
our verification time is only 46

107
00:04:48,160 --> 00:04:51,120
milliseconds for these large polynomials

108
00:04:51,120 --> 00:04:53,680
and for a lot of applications

109
00:04:53,680 --> 00:04:56,720
that might be a lot more acceptable than

110
00:04:56,720 --> 00:05:01,120
16-minute approver time for example

111
00:05:03,039 --> 00:05:05,759
our next application is zk snark

112
00:05:05,759 --> 00:05:08,720
aggregation in particular we look at

113
00:05:08,720 --> 00:05:12,479
public aggregation of n gross 16 snarks

114
00:05:12,479 --> 00:05:13,600
into

115
00:05:13,600 --> 00:05:14,479
a

116
00:05:14,479 --> 00:05:16,960
log size proof that's verifiable in log

117
00:05:16,960 --> 00:05:18,479
time

118
00:05:18,479 --> 00:05:20,400
previously we only knew how to do this

119
00:05:20,400 --> 00:05:22,880
using recursive proof composition which

120
00:05:22,880 --> 00:05:25,759
is pretty inefficient as we can see in

121
00:05:25,759 --> 00:05:27,759
this comparison

122
00:05:27,759 --> 00:05:29,759
in general

123
00:05:29,759 --> 00:05:32,240
our inner product arguments are really

124
00:05:32,240 --> 00:05:34,639
good for

125
00:05:34,639 --> 00:05:37,039
aggregation of

126
00:05:37,039 --> 00:05:40,240
any pairing-based cryptography where the

127
00:05:40,240 --> 00:05:43,360
verification equation is a pairing based

128
00:05:43,360 --> 00:05:44,800
language

129
00:05:44,800 --> 00:05:49,120
when we look at the verification of

130
00:05:49,120 --> 00:05:50,479
interactive

131
00:05:50,479 --> 00:05:52,960
snarks that are made on interactive via

132
00:05:52,960 --> 00:05:55,600
the fiat shamir transform

133
00:05:55,600 --> 00:05:58,240
we see that because of the need to make

134
00:05:58,240 --> 00:06:00,720
these hash function calls to get the

135
00:06:00,720 --> 00:06:03,280
challenges that we are no longer in a

136
00:06:03,280 --> 00:06:06,240
pairing based language and we just run

137
00:06:06,240 --> 00:06:08,880
into complications with these but for

138
00:06:08,880 --> 00:06:11,199
graph 16 which is built from

139
00:06:11,199 --> 00:06:13,360
non-interactive linear proofs

140
00:06:13,360 --> 00:06:16,000
this works well

141
00:06:16,000 --> 00:06:18,880
in recursive proof composition we take

142
00:06:18,880 --> 00:06:20,639
one more snark

143
00:06:20,639 --> 00:06:21,600
and

144
00:06:21,600 --> 00:06:24,720
we use it to prove knowledge of

145
00:06:24,720 --> 00:06:27,440
the n gras 16 snarks

146
00:06:27,440 --> 00:06:30,960
that satisfy the n instances

147
00:06:30,960 --> 00:06:32,880
this means that we're proving the

148
00:06:32,880 --> 00:06:36,560
verification circuit for bra 16.

149
00:06:36,560 --> 00:06:39,360
so we have to first arithmetize that in

150
00:06:39,360 --> 00:06:43,840
particular we need to express it in r1cs

151
00:06:43,840 --> 00:06:45,120
where

152
00:06:45,120 --> 00:06:47,520
a pairing costs about

153
00:06:47,520 --> 00:06:48,960
constraints

154
00:06:48,960 --> 00:06:51,520
so this is a major cause of blow up for

155
00:06:51,520 --> 00:06:53,919
this approach and this is avoided by our

156
00:06:53,919 --> 00:06:56,160
inner pairing product which is

157
00:06:56,160 --> 00:06:59,440
essentially for exactly the gros 16

158
00:06:59,440 --> 00:07:02,479
verification equation relation so

159
00:07:02,479 --> 00:07:05,680
another major cause of blow up improver

160
00:07:05,680 --> 00:07:08,560
time for the recursive proof composition

161
00:07:08,560 --> 00:07:09,599
approach

162
00:07:09,599 --> 00:07:11,520
is the fact that

163
00:07:11,520 --> 00:07:13,520
i won't get into the technical details

164
00:07:13,520 --> 00:07:16,639
of why but you need to use a

165
00:07:16,639 --> 00:07:18,960
two chain or a cycle of pairing friendly

166
00:07:18,960 --> 00:07:20,960
elliptic curves the two chain is a

167
00:07:20,960 --> 00:07:22,400
little bit more efficient and that's

168
00:07:22,400 --> 00:07:25,280
what we compared to here where

169
00:07:25,280 --> 00:07:26,080
the

170
00:07:26,080 --> 00:07:27,840
proof of the proofs

171
00:07:27,840 --> 00:07:28,800
in the

172
00:07:28,800 --> 00:07:32,680
outer curve is done over a

173
00:07:32,680 --> 00:07:36,800
760 bit curve unfortunately we do not

174
00:07:36,800 --> 00:07:37,840
have

175
00:07:37,840 --> 00:07:38,960
smaller

176
00:07:38,960 --> 00:07:43,120
outer curves for two chains or cycles

177
00:07:43,120 --> 00:07:47,039
and for comparison we use 380 bit curves

178
00:07:47,039 --> 00:07:49,280
for parent base cryptography when we

179
00:07:49,280 --> 00:07:50,800
don't need recursion

180
00:07:50,800 --> 00:07:53,680
and this is for the 128 bit security

181
00:07:53,680 --> 00:07:55,120
level

182
00:07:55,120 --> 00:07:57,360
so we actually see because of this big

183
00:07:57,360 --> 00:08:02,240
blow up that benchmark stop at 64 for

184
00:08:02,240 --> 00:08:05,039
the 2 chain approach because we ran out

185
00:08:05,039 --> 00:08:07,919
of memory on a laptop

186
00:08:07,919 --> 00:08:09,120
and

187
00:08:09,120 --> 00:08:12,240
we see though for 64 proofs that

188
00:08:12,240 --> 00:08:13,599
aggregation

189
00:08:13,599 --> 00:08:15,759
using our inner pairing product

190
00:08:15,759 --> 00:08:19,759
arguments is about 900 times faster and

191
00:08:19,759 --> 00:08:22,160
in fact in the time it takes to make a

192
00:08:22,160 --> 00:08:26,400
recursive proof of 64 proofs we can

193
00:08:26,400 --> 00:08:32,000
aggregate 65 000 proofs to a 35 kilobyte

194
00:08:32,000 --> 00:08:34,719
proof that takes 300 milliseconds to

195
00:08:34,719 --> 00:08:37,200
verify

196
00:08:37,440 --> 00:08:39,360
the third and final application that we

197
00:08:39,360 --> 00:08:42,080
look at is low memory snarks for machine

198
00:08:42,080 --> 00:08:43,919
computations

199
00:08:43,919 --> 00:08:46,720
for a computation that takes time t in

200
00:08:46,720 --> 00:08:50,000
space s a monolithic start proof

201
00:08:50,000 --> 00:08:53,360
takes space that is quasi-linear and s

202
00:08:53,360 --> 00:08:54,640
times t

203
00:08:54,640 --> 00:08:57,200
our approach is to create t snarks each

204
00:08:57,200 --> 00:08:59,279
of a single transition

205
00:08:59,279 --> 00:09:01,600
and we use inner product arguments to

206
00:09:01,600 --> 00:09:03,279
aggregate the results

207
00:09:03,279 --> 00:09:06,160
if we were to apply the techniques of

208
00:09:06,160 --> 00:09:08,480
last section directly here

209
00:09:08,480 --> 00:09:11,680
then we would end up with proof size

210
00:09:11,680 --> 00:09:13,360
that were

211
00:09:13,360 --> 00:09:15,200
linear in

212
00:09:15,200 --> 00:09:17,760
the size of the instance x

213
00:09:17,760 --> 00:09:18,959
times t

214
00:09:18,959 --> 00:09:22,480
because we would be including all the

215
00:09:22,480 --> 00:09:25,360
intermediate values of the register the

216
00:09:25,360 --> 00:09:27,920
intermediate instances

217
00:09:27,920 --> 00:09:29,120
instead

218
00:09:29,120 --> 00:09:32,160
we recognize that the verifier doesn't

219
00:09:32,160 --> 00:09:34,399
need to know these intermediate values

220
00:09:34,399 --> 00:09:36,560
and doesn't care about them

221
00:09:36,560 --> 00:09:39,760
instead what they care about is the fact

222
00:09:39,760 --> 00:09:40,640
that

223
00:09:40,640 --> 00:09:41,760
the

224
00:09:41,760 --> 00:09:45,360
output of one map transition snark

225
00:09:45,360 --> 00:09:47,600
matches the input of the next

226
00:09:47,600 --> 00:09:48,399
so

227
00:09:48,399 --> 00:09:50,880
what we do is commit to all these

228
00:09:50,880 --> 00:09:53,839
intermediate register values and then we

229
00:09:53,839 --> 00:09:55,360
create a

230
00:09:55,360 --> 00:09:56,320
proof

231
00:09:56,320 --> 00:09:57,440
that

232
00:09:57,440 --> 00:09:59,920
this is the case that this matchup

233
00:09:59,920 --> 00:10:01,200
happens and

234
00:10:01,200 --> 00:10:02,480
doing so

235
00:10:02,480 --> 00:10:05,680
we are able to instead get proofs that

236
00:10:05,680 --> 00:10:07,760
are linear in just the

237
00:10:07,760 --> 00:10:10,160
x that we care about

238
00:10:10,160 --> 00:10:13,519
and logarithmic in t

239
00:10:13,519 --> 00:10:16,000
and we get the same verifier time

240
00:10:16,000 --> 00:10:19,360
complexity as well and this only

241
00:10:19,360 --> 00:10:22,480
requires space that is quasi-linear and

242
00:10:22,480 --> 00:10:24,560
s plus t

243
00:10:24,560 --> 00:10:28,560
so previous results used recursive proof

244
00:10:28,560 --> 00:10:30,160
composition

245
00:10:30,160 --> 00:10:33,680
and as we saw before this is concretely

246
00:10:33,680 --> 00:10:36,399
inefficient

247
00:10:36,959 --> 00:10:38,399
building up to

248
00:10:38,399 --> 00:10:40,560
our inner product arguments are in

249
00:10:40,560 --> 00:10:42,880
repairing product arguments we're going

250
00:10:42,880 --> 00:10:44,800
to first look at an argument of

251
00:10:44,800 --> 00:10:46,399
knowledge for

252
00:10:46,399 --> 00:10:48,800
a pairing-based commitment opening

253
00:10:48,800 --> 00:10:50,519
specifically the

254
00:10:50,519 --> 00:10:54,079
afghan 16 commitment scheme which is

255
00:10:54,079 --> 00:10:55,519
what we base

256
00:10:55,519 --> 00:10:58,320
our commitment scheme off of

257
00:10:58,320 --> 00:11:01,120
the approver is given a common reference

258
00:11:01,120 --> 00:11:04,399
string which is a vector of n random g2

259
00:11:04,399 --> 00:11:07,120
elements and they hold a witness which

260
00:11:07,120 --> 00:11:09,040
is a vector of n

261
00:11:09,040 --> 00:11:11,040
g1 elements

262
00:11:11,040 --> 00:11:14,000
the commitment is the inner pairing

263
00:11:14,000 --> 00:11:18,160
product between e a and v vectors

264
00:11:18,160 --> 00:11:20,399
which we write as this

265
00:11:20,399 --> 00:11:23,120
a asterisk v

266
00:11:23,120 --> 00:11:24,800
notation

267
00:11:24,800 --> 00:11:27,760
next approver parses the v vector and

268
00:11:27,760 --> 00:11:29,680
the a vector

269
00:11:29,680 --> 00:11:32,399
into a left and right half each of equal

270
00:11:32,399 --> 00:11:33,600
length

271
00:11:33,600 --> 00:11:36,800
the prover then sends these cross terms

272
00:11:36,800 --> 00:11:38,880
tl and tr

273
00:11:38,880 --> 00:11:40,399
which is the

274
00:11:40,399 --> 00:11:42,480
right half of the a

275
00:11:42,480 --> 00:11:45,360
in our pairing product with the

276
00:11:45,360 --> 00:11:48,640
left half of v and vice versa

277
00:11:48,640 --> 00:11:51,200
fire responds with a random challenge x

278
00:11:51,200 --> 00:11:52,880
from the field

279
00:11:52,880 --> 00:11:57,519
and then the prover outputs a witness

280
00:11:57,519 --> 00:11:59,200
a prime

281
00:11:59,200 --> 00:12:00,639
so

282
00:12:00,639 --> 00:12:02,560
in practice we

283
00:12:02,560 --> 00:12:04,880
keep folding a logarithmic number of

284
00:12:04,880 --> 00:12:07,440
times until a prime is just a single

285
00:12:07,440 --> 00:12:09,360
group one element

286
00:12:09,360 --> 00:12:12,079
just to show how the math works we look

287
00:12:12,079 --> 00:12:14,399
at a single round here

288
00:12:14,399 --> 00:12:18,480
the verifier computes the scaled crs v

289
00:12:18,480 --> 00:12:20,240
prime

290
00:12:20,240 --> 00:12:22,480
and then checks

291
00:12:22,480 --> 00:12:25,680
that a prime inner product v prime is

292
00:12:25,680 --> 00:12:27,120
equal to

293
00:12:27,120 --> 00:12:30,720
x times t l plus t plus x inverse times

294
00:12:30,720 --> 00:12:31,920
t r

295
00:12:31,920 --> 00:12:32,959
and

296
00:12:32,959 --> 00:12:35,279
we show how the left hand side expands

297
00:12:35,279 --> 00:12:38,800
here and basically that the math works

298
00:12:38,800 --> 00:12:41,040
out

299
00:12:41,760 --> 00:12:44,240
i'll give you a second just to check

300
00:12:44,240 --> 00:12:47,240
that

301
00:12:55,680 --> 00:12:58,399
great so now we're going to look at how

302
00:12:58,399 --> 00:13:00,160
to extend

303
00:13:00,160 --> 00:13:03,440
this to get an inner pairing product

304
00:13:03,440 --> 00:13:04,800
argument

305
00:13:04,800 --> 00:13:07,519
when we have another witness vector

306
00:13:07,519 --> 00:13:12,000
which is a vector of ng2 elements

307
00:13:12,000 --> 00:13:15,360
and we have a commitment an afgh o16

308
00:13:15,360 --> 00:13:17,040
commitment u to that

309
00:13:17,040 --> 00:13:20,560
we want to show that for some public z

310
00:13:20,560 --> 00:13:21,920
we know

311
00:13:21,920 --> 00:13:25,120
witness vectors a and b such that their

312
00:13:25,120 --> 00:13:28,079
inner pairing product is z

313
00:13:28,079 --> 00:13:31,600
so what we do is we perform the two

314
00:13:31,600 --> 00:13:34,160
opening argument of knowledge in

315
00:13:34,160 --> 00:13:36,240
parallel using the

316
00:13:36,240 --> 00:13:39,040
same challenges the opening of

317
00:13:39,040 --> 00:13:45,040
t and u and we also in each round send

318
00:13:45,040 --> 00:13:46,560
these z

319
00:13:46,560 --> 00:13:49,680
l and z are cross terms between

320
00:13:49,680 --> 00:13:54,360
the a and b vectors the okays for

321
00:13:54,360 --> 00:13:57,760
afgo16 commitment openings ensure that

322
00:13:57,760 --> 00:14:00,560
the final a prime and b prime

323
00:14:00,560 --> 00:14:03,839
are correct finally we check the inner

324
00:14:03,839 --> 00:14:08,240
product claim with this last equation

325
00:14:08,240 --> 00:14:10,240
where again things work out because of

326
00:14:10,240 --> 00:14:10,959
the

327
00:14:10,959 --> 00:14:14,079
bilinear property

328
00:14:14,240 --> 00:14:17,760
this protocol is pretty much the

329
00:14:17,760 --> 00:14:20,079
pairing analog to

330
00:14:20,079 --> 00:14:21,040
the

331
00:14:21,040 --> 00:14:26,399
discrete log based bccg p16 protocol

332
00:14:26,399 --> 00:14:27,279
so

333
00:14:27,279 --> 00:14:32,000
bulletproof's improved on bcc gp16

334
00:14:32,000 --> 00:14:35,839
by committing to the a and b vectors

335
00:14:35,839 --> 00:14:39,440
with a single commitment as well as to

336
00:14:39,440 --> 00:14:40,800
the

337
00:14:40,800 --> 00:14:42,480
z value

338
00:14:42,480 --> 00:14:45,760
you can't commit to both one and group

339
00:14:45,760 --> 00:14:49,199
two elements with a single

340
00:14:49,199 --> 00:14:51,680
target group element it wouldn't be

341
00:14:51,680 --> 00:14:55,760
binding so we get six log n versus two

342
00:14:55,760 --> 00:14:56,959
log n

343
00:14:56,959 --> 00:14:58,880
for bulletproofs

344
00:14:58,880 --> 00:15:00,399
on the other hand we get a log time

345
00:15:00,399 --> 00:15:01,760
verifier

346
00:15:01,760 --> 00:15:05,040
whereas bulletproofs has a

347
00:15:05,040 --> 00:15:07,839
slightly sublinear verifier

348
00:15:07,839 --> 00:15:10,480
the main difference between

349
00:15:10,480 --> 00:15:12,959
this protocol we just presented and the

350
00:15:12,959 --> 00:15:16,160
one in lmr19 is just the commitment

351
00:15:16,160 --> 00:15:17,279
scheme

352
00:15:17,279 --> 00:15:18,639
used

353
00:15:18,639 --> 00:15:22,240
they commit to both the g1 and g2

354
00:15:22,240 --> 00:15:23,600
elements

355
00:15:23,600 --> 00:15:24,959
in

356
00:15:24,959 --> 00:15:27,920
two commitments under different random

357
00:15:27,920 --> 00:15:30,639
generators

358
00:15:30,880 --> 00:15:33,040
now that we've got some sense of how

359
00:15:33,040 --> 00:15:35,759
these inner product arguments work we're

360
00:15:35,759 --> 00:15:38,160
going to talk about our generalized

361
00:15:38,160 --> 00:15:41,120
inner product argument which takes the

362
00:15:41,120 --> 00:15:42,639
core ideas

363
00:15:42,639 --> 00:15:43,759
from

364
00:15:43,759 --> 00:15:45,360
protocols like

365
00:15:45,360 --> 00:15:49,920
b c g g p 16 bulletproof cell lmr

366
00:15:49,920 --> 00:15:52,880
and abstracts them

367
00:15:52,880 --> 00:15:55,680
basically our generalized argument shows

368
00:15:55,680 --> 00:15:58,639
that if we have three primordial groups

369
00:15:58,639 --> 00:16:04,079
m1 m2 and m3 m1 times m2 to m3

370
00:16:04,079 --> 00:16:08,560
and a commitment for messages that are

371
00:16:08,560 --> 00:16:09,279
n

372
00:16:09,279 --> 00:16:12,880
m1 elements and m2 elements and an m3

373
00:16:12,880 --> 00:16:14,160
element

374
00:16:14,160 --> 00:16:16,800
where the commitment has an additive

375
00:16:16,800 --> 00:16:19,360
homomorphism for both the message and

376
00:16:19,360 --> 00:16:21,600
commitment key space we call these

377
00:16:21,600 --> 00:16:24,160
doubly homomorphic commitments then we

378
00:16:24,160 --> 00:16:27,360
get an inner product argument we see

379
00:16:27,360 --> 00:16:29,600
both our own works and previous works as

380
00:16:29,600 --> 00:16:33,279
instantiations of a single generalized

381
00:16:33,279 --> 00:16:34,399
protocol

382
00:16:34,399 --> 00:16:37,360
so we build inner product arguments for

383
00:16:37,360 --> 00:16:39,720
elliptic curve pairings and

384
00:16:39,720 --> 00:16:41,920
multi-exponentiations then we can also

385
00:16:41,920 --> 00:16:44,160
see previous works that do scalar multi

386
00:16:44,160 --> 00:16:45,600
field multiplication such as

387
00:16:45,600 --> 00:16:48,480
bulletproofs as an instantiation

388
00:16:48,480 --> 00:16:52,000
of jibba as well and this lets us create

389
00:16:52,000 --> 00:16:53,199
for example

390
00:16:53,199 --> 00:16:55,040
one security proof

391
00:16:55,040 --> 00:16:57,759
uh that covers all of these

392
00:16:57,759 --> 00:17:00,320
based on properties of

393
00:17:00,320 --> 00:17:02,720
the commitment scheme with respect to

394
00:17:02,720 --> 00:17:05,199
jipa security we observe that most

395
00:17:05,199 --> 00:17:07,280
practical applications require

396
00:17:07,280 --> 00:17:09,839
non-interactive protocols

397
00:17:09,839 --> 00:17:12,160
and we know that we can use the fiat

398
00:17:12,160 --> 00:17:14,240
schemer heuristic to compress an

399
00:17:14,240 --> 00:17:16,799
interactive proof into a non-interactive

400
00:17:16,799 --> 00:17:20,559
one for this resulting protocol we run

401
00:17:20,559 --> 00:17:22,319
into the problem that

402
00:17:22,319 --> 00:17:24,720
existing fiesta mere rom extraction

403
00:17:24,720 --> 00:17:25,839
techniques

404
00:17:25,839 --> 00:17:29,360
give a super polynomial extractor for

405
00:17:29,360 --> 00:17:31,280
log round protocols when you try to

406
00:17:31,280 --> 00:17:33,440
generalize them

407
00:17:33,440 --> 00:17:36,240
so here was our solution we treat the

408
00:17:36,240 --> 00:17:38,799
commitment as algebraic

409
00:17:38,799 --> 00:17:40,160
essentially

410
00:17:40,160 --> 00:17:43,760
requiring the adversary to output an a

411
00:17:43,760 --> 00:17:45,679
and b vector

412
00:17:45,679 --> 00:17:48,880
then the extractor has to show

413
00:17:48,880 --> 00:17:51,440
that z is equal to the inner product of

414
00:17:51,440 --> 00:17:54,400
a and b which is a bit more difficult

415
00:17:54,400 --> 00:17:57,200
for this we use the zero finding game

416
00:17:57,200 --> 00:17:59,600
from bcms 20

417
00:17:59,600 --> 00:18:00,400
which

418
00:18:00,400 --> 00:18:03,120
essentially relates the

419
00:18:03,120 --> 00:18:06,640
probability that an adversary wins at

420
00:18:06,640 --> 00:18:09,280
short zipple to

421
00:18:09,280 --> 00:18:12,160
the number of random oracle queries it

422
00:18:12,160 --> 00:18:14,320
makes

423
00:18:14,320 --> 00:18:17,600
we saw an inner pairing product argument

424
00:18:17,600 --> 00:18:19,120
for

425
00:18:19,120 --> 00:18:22,160
the afgho commitment scheme

426
00:18:22,160 --> 00:18:23,440
that had

427
00:18:23,440 --> 00:18:27,039
logarithmic size proofs in each round we

428
00:18:27,039 --> 00:18:27,840
sent

429
00:18:27,840 --> 00:18:30,400
those cross terms which

430
00:18:30,400 --> 00:18:33,039
was a constant number of target group

431
00:18:33,039 --> 00:18:34,640
elements

432
00:18:34,640 --> 00:18:36,400
and there's only a logarithmic number of

433
00:18:36,400 --> 00:18:39,120
rounds and that constitutes the proof so

434
00:18:39,120 --> 00:18:41,360
we have a lot of proof size and we

435
00:18:41,360 --> 00:18:42,400
had a

436
00:18:42,400 --> 00:18:43,760
linear

437
00:18:43,760 --> 00:18:45,520
verifier time

438
00:18:45,520 --> 00:18:46,480
so

439
00:18:46,480 --> 00:18:47,919
we had to do

440
00:18:47,919 --> 00:18:50,440
a logarithmic number of target group

441
00:18:50,440 --> 00:18:52,799
exponentiations to

442
00:18:52,799 --> 00:18:55,200
fold in those

443
00:18:55,200 --> 00:18:58,480
cross products with the commitments in

444
00:18:58,480 --> 00:19:00,080
each round

445
00:19:00,080 --> 00:19:01,679
where that was on the right hand side of

446
00:19:01,679 --> 00:19:03,919
those equalities we're checking and then

447
00:19:03,919 --> 00:19:05,840
on the left hand side

448
00:19:05,840 --> 00:19:08,080
we had to

449
00:19:08,080 --> 00:19:11,840
fold in each round the commitment key

450
00:19:11,840 --> 00:19:14,320
and this is what required a

451
00:19:14,320 --> 00:19:17,280
linear amount of work overall or

452
00:19:17,280 --> 00:19:19,039
slightly sublinear

453
00:19:19,039 --> 00:19:20,799
if we

454
00:19:20,799 --> 00:19:24,320
defer computing the final commitment key

455
00:19:24,320 --> 00:19:27,039
to the end which the verifier can do

456
00:19:27,039 --> 00:19:30,559
and then use pippingers to compute

457
00:19:30,559 --> 00:19:33,840
the multi-exponentiation

458
00:19:33,840 --> 00:19:37,440
next we observe that for a log time

459
00:19:37,440 --> 00:19:40,559
evaluable polynomial in some

460
00:19:40,559 --> 00:19:42,640
indeterminate and

461
00:19:42,640 --> 00:19:43,440
the

462
00:19:43,440 --> 00:19:45,919
l challenges for

463
00:19:45,919 --> 00:19:48,960
the where l is the number of rounds that

464
00:19:48,960 --> 00:19:50,960
the final commitment key

465
00:19:50,960 --> 00:19:54,400
can be written as a commitment

466
00:19:54,400 --> 00:19:55,280
to

467
00:19:55,280 --> 00:19:57,679
that polynomial

468
00:19:57,679 --> 00:20:00,640
then using a polynomial commitment in

469
00:20:00,640 --> 00:20:03,120
particular kcg10

470
00:20:03,120 --> 00:20:04,640
we can

471
00:20:04,640 --> 00:20:09,120
offload computation of the final

472
00:20:09,120 --> 00:20:12,799
v prime value to p so that

473
00:20:12,799 --> 00:20:15,600
the verifier does not have to scale the

474
00:20:15,600 --> 00:20:17,919
commitment key themselves they're only

475
00:20:17,919 --> 00:20:20,960
doing a logarithmic amount of work by

476
00:20:20,960 --> 00:20:23,679
evaluating this halo polynomial and by

477
00:20:23,679 --> 00:20:26,799
orbit group multi-exponentiation

478
00:20:26,799 --> 00:20:29,280
so here is how this sub-protocol works

479
00:20:29,280 --> 00:20:32,640
or sends v-prime to the verifier

480
00:20:32,640 --> 00:20:34,640
the verifier then picks a random

481
00:20:34,640 --> 00:20:37,760
challenge point for the field and uses

482
00:20:37,760 --> 00:20:39,919
the halo polynomial and the challenges

483
00:20:39,919 --> 00:20:41,520
from each round of the inner product

484
00:20:41,520 --> 00:20:45,760
argument to compute this v value

485
00:20:45,760 --> 00:20:48,880
in log time the prover then sends a

486
00:20:48,880 --> 00:20:51,360
succinct evaluation proof

487
00:20:51,360 --> 00:20:52,880
showing that

488
00:20:52,880 --> 00:20:56,240
v prime opens to

489
00:20:56,240 --> 00:20:57,280
v

490
00:20:57,280 --> 00:20:59,440
at z

491
00:20:59,440 --> 00:21:01,760
recall the prover is proving knowledge

492
00:21:01,760 --> 00:21:05,360
of some polynomial f prime of x that

493
00:21:05,360 --> 00:21:07,600
agrees with f

494
00:21:07,600 --> 00:21:08,480
at

495
00:21:08,480 --> 00:21:12,159
z and the x1 through xl

496
00:21:12,159 --> 00:21:13,760
challenges

497
00:21:13,760 --> 00:21:16,720
these two polynomials will

498
00:21:16,720 --> 00:21:19,840
only agree if they are different with

499
00:21:19,840 --> 00:21:22,640
negligible probability by short zipple

500
00:21:22,640 --> 00:21:23,520
and

501
00:21:23,520 --> 00:21:26,960
v is able to check this evaluation proof

502
00:21:26,960 --> 00:21:31,120
in constant time using the kg kz g10

503
00:21:31,120 --> 00:21:33,760
verifier this is the basic idea of how

504
00:21:33,760 --> 00:21:36,559
we achieve log time verification

505
00:21:36,559 --> 00:21:39,280
using pairing based commitments and

506
00:21:39,280 --> 00:21:42,320
again this isn't just for our

507
00:21:42,320 --> 00:21:43,679
inner pairing

508
00:21:43,679 --> 00:21:46,520
product protocol but for

509
00:21:46,520 --> 00:21:48,080
multi-exponentiation

510
00:21:48,080 --> 00:21:48,960
a

511
00:21:48,960 --> 00:21:51,760
pairing based commitment

512
00:21:51,760 --> 00:21:54,559
just to give a basic idea of the

513
00:21:54,559 --> 00:21:57,520
halo polynomial and its long time

514
00:21:57,520 --> 00:21:59,200
valuable form

515
00:21:59,200 --> 00:22:02,480
uh here instead of a trapdoor beta we

516
00:22:02,480 --> 00:22:05,200
have a trapdoor alpha

517
00:22:05,200 --> 00:22:06,320
and

518
00:22:06,320 --> 00:22:08,640
this would represent the

519
00:22:08,640 --> 00:22:11,600
logarithm of the structured reference

520
00:22:11,600 --> 00:22:13,039
string

521
00:22:13,039 --> 00:22:18,000
elements uh w1 w2 and and so on for uh

522
00:22:18,000 --> 00:22:19,919
eight values and then

523
00:22:19,919 --> 00:22:23,760
after one round we would have a srs that

524
00:22:23,760 --> 00:22:28,159
is half the size and is folded uh thusly

525
00:22:28,159 --> 00:22:30,480
and and so on in terms of these

526
00:22:30,480 --> 00:22:31,679
challenges

527
00:22:31,679 --> 00:22:34,960
uh x1 x2 and x3

528
00:22:34,960 --> 00:22:37,200
and then we see how

529
00:22:37,200 --> 00:22:41,679
this forms a log time a valuable

530
00:22:41,679 --> 00:22:43,280
polynomial

531
00:22:43,280 --> 00:22:45,760
which we can then

532
00:22:45,760 --> 00:22:47,760
write the final

533
00:22:47,760 --> 00:22:51,679
w prime in terms of

534
00:22:51,919 --> 00:22:53,120
moving on

535
00:22:53,120 --> 00:22:54,960
we're going to talk about our polynomial

536
00:22:54,960 --> 00:22:57,840
commitment scheme is that a high level

537
00:22:57,840 --> 00:22:59,600
we begin

538
00:22:59,600 --> 00:23:02,640
by using the strategy of having a

539
00:23:02,640 --> 00:23:05,039
two-tiered homomorphic commitment this

540
00:23:05,039 --> 00:23:07,440
is what will ultimately give us

541
00:23:07,440 --> 00:23:09,120
square root

542
00:23:09,120 --> 00:23:12,240
opening and square root crs we'll see

543
00:23:12,240 --> 00:23:14,880
how that works later

544
00:23:14,880 --> 00:23:16,000
and it

545
00:23:16,000 --> 00:23:19,440
will be presented as a commitment for a

546
00:23:19,440 --> 00:23:23,039
bivariate polynomial of degree at most m

547
00:23:23,039 --> 00:23:25,280
equal to square root of n in each

548
00:23:25,280 --> 00:23:26,320
variable

549
00:23:26,320 --> 00:23:28,720
but in the paper we also give a

550
00:23:28,720 --> 00:23:31,520
univariate transformation

551
00:23:31,520 --> 00:23:34,640
so we consider a coefficient matrix a

552
00:23:34,640 --> 00:23:38,320
whereas we move down the rows the power

553
00:23:38,320 --> 00:23:40,799
of x grows

554
00:23:40,799 --> 00:23:42,480
and as we

555
00:23:42,480 --> 00:23:45,840
move down the columns the power of y

556
00:23:45,840 --> 00:23:47,360
grows

557
00:23:47,360 --> 00:23:50,400
we commit to each row

558
00:23:50,400 --> 00:23:55,279
using a kz g10 commitment with the same

559
00:23:55,279 --> 00:23:56,640
srs

560
00:23:56,640 --> 00:23:58,960
so this means only a square root size

561
00:23:58,960 --> 00:24:00,320
srs

562
00:24:00,320 --> 00:24:02,480
and then we commit

563
00:24:02,480 --> 00:24:05,200
to all the row commitments

564
00:24:05,200 --> 00:24:06,240
using

565
00:24:06,240 --> 00:24:08,720
the tip commitment scheme which is again

566
00:24:08,720 --> 00:24:09,840
basically

567
00:24:09,840 --> 00:24:13,360
a trusted version of the afgho

568
00:24:13,360 --> 00:24:16,480
16 commitment just like the kzg10

569
00:24:16,480 --> 00:24:17,760
commitment

570
00:24:17,760 --> 00:24:18,799
is

571
00:24:18,799 --> 00:24:22,640
basically a trusted version of

572
00:24:22,640 --> 00:24:26,960
the generalized patterson commitment

573
00:24:26,960 --> 00:24:29,039
and we get a

574
00:24:29,039 --> 00:24:31,440
commitment that is a single

575
00:24:31,440 --> 00:24:34,000
target group element

576
00:24:34,000 --> 00:24:35,039
and

577
00:24:35,039 --> 00:24:37,279
also our

578
00:24:37,279 --> 00:24:40,720
srs for the tip commitment is also

579
00:24:40,720 --> 00:24:43,520
square root and size we want to prove an

580
00:24:43,520 --> 00:24:46,480
evaluation at x y

581
00:24:46,480 --> 00:24:48,000
to do this

582
00:24:48,000 --> 00:24:50,159
we first create

583
00:24:50,159 --> 00:24:53,039
an outer tier evaluation proof

584
00:24:53,039 --> 00:24:54,080
where

585
00:24:54,080 --> 00:24:55,760
we show

586
00:24:55,760 --> 00:24:57,840
that u is equal to this

587
00:24:57,840 --> 00:25:00,159
multi-exponentiation

588
00:25:00,159 --> 00:25:01,919
inner product

589
00:25:01,919 --> 00:25:04,000
between the

590
00:25:04,000 --> 00:25:07,360
commitments to the row vectors a i

591
00:25:07,360 --> 00:25:08,880
and the power

592
00:25:08,880 --> 00:25:10,960
powers of x

593
00:25:10,960 --> 00:25:13,679
and this is a proof of a partial

594
00:25:13,679 --> 00:25:15,360
evaluation

595
00:25:15,360 --> 00:25:19,039
of f of x where we've plugged in the x

596
00:25:19,039 --> 00:25:22,880
but we have left y indeterminate

597
00:25:22,880 --> 00:25:26,720
and this means that u is a kzg

598
00:25:26,720 --> 00:25:29,679
commitment to the following

599
00:25:29,679 --> 00:25:32,080
monic polynomial

600
00:25:32,080 --> 00:25:33,679
so

601
00:25:33,679 --> 00:25:34,880
for the

602
00:25:34,880 --> 00:25:37,679
inner tier evaluation

603
00:25:37,679 --> 00:25:40,480
we use kg g10

604
00:25:40,480 --> 00:25:41,440
the

605
00:25:41,440 --> 00:25:43,760
opening evaluation proof from that

606
00:25:43,760 --> 00:25:46,880
protocol to prove that u

607
00:25:46,880 --> 00:25:50,240
opens to v equal to f x y

608
00:25:50,240 --> 00:25:51,360
at y

609
00:25:51,360 --> 00:25:54,720
as we already noted both mip k

610
00:25:54,720 --> 00:25:59,440
and kzg commitments use an srs

611
00:25:59,440 --> 00:26:02,320
with size linear and m equal to square

612
00:26:02,320 --> 00:26:03,840
root of n

613
00:26:03,840 --> 00:26:07,360
and we also note that both the mip k

614
00:26:07,360 --> 00:26:11,279
and kz g10 provers run in time

615
00:26:11,279 --> 00:26:12,400
linear

616
00:26:12,400 --> 00:26:16,279
in square root of n

617
00:26:36,400 --> 00:26:38,320
we will however take a minute to look at

618
00:26:38,320 --> 00:26:41,919
subsequent work first lee 20 and dory

619
00:26:41,919 --> 00:26:44,240
introduces an inner pairing product

620
00:26:44,240 --> 00:26:46,240
argument that achieves a log time

621
00:26:46,240 --> 00:26:48,960
verifier without a trusted setup this

622
00:26:48,960 --> 00:26:51,760
comes at a six times increase to proof

623
00:26:51,760 --> 00:26:55,279
size plus verifier time whether this is

624
00:26:55,279 --> 00:26:57,600
a good trade-off or not just depends on

625
00:26:57,600 --> 00:27:01,039
the application we've also seen lattice

626
00:27:01,039 --> 00:27:03,679
base in our product arguments from bl

627
00:27:03,679 --> 00:27:07,600
and s20 recently which achieve

628
00:27:07,600 --> 00:27:11,039
poly logarithmic proof size and

629
00:27:11,039 --> 00:27:13,679
linear time verifiers

630
00:27:13,679 --> 00:27:17,279
we've also seen our work applied to

631
00:27:17,279 --> 00:27:19,360
vector commitment opening proof

632
00:27:19,360 --> 00:27:20,720
aggregation

633
00:27:20,720 --> 00:27:23,120
incrementally verifiable computation

634
00:27:23,120 --> 00:27:28,320
without recursion and snark aggregation

635
00:27:28,320 --> 00:27:32,320
and we've seen some industry adoption

636
00:27:32,320 --> 00:27:35,840
our protocols or derivatives thereof are

637
00:27:35,840 --> 00:27:40,799
already in use by polka dot and filecoin

638
00:27:40,960 --> 00:27:43,279
finally we conclude with some open

639
00:27:43,279 --> 00:27:44,399
questions

640
00:27:44,399 --> 00:27:46,399
some of which have

641
00:27:46,399 --> 00:27:49,200
been very recently answered

642
00:27:49,200 --> 00:27:50,799
so recently

643
00:27:50,799 --> 00:27:52,399
we've seen

644
00:27:52,399 --> 00:27:55,760
a proof in the rom for

645
00:27:55,760 --> 00:27:57,919
inner product arguments

646
00:27:57,919 --> 00:28:00,720
in particular the result is

647
00:28:00,720 --> 00:28:03,279
showing for a generalized notion of

648
00:28:03,279 --> 00:28:05,520
special soundness that when you apply

649
00:28:05,520 --> 00:28:08,000
fiat chmir to these protocols you get a

650
00:28:08,000 --> 00:28:11,039
knowledge sound protocol in the realm

651
00:28:11,039 --> 00:28:13,360
that is tight and so this is actually a

652
00:28:13,360 --> 00:28:16,720
little bit more general of a result the

653
00:28:16,720 --> 00:28:19,679
next step would be

654
00:28:19,679 --> 00:28:21,760
to consider

655
00:28:21,760 --> 00:28:22,480
if

656
00:28:22,480 --> 00:28:23,279
for

657
00:28:23,279 --> 00:28:25,840
particular commitment schemes there are

658
00:28:25,840 --> 00:28:28,960
correlation intractable hash functions

659
00:28:28,960 --> 00:28:30,799
such that we could

660
00:28:30,799 --> 00:28:33,440
have non-interactive inner product

661
00:28:33,440 --> 00:28:35,360
arguments that are knowledge sound in

662
00:28:35,360 --> 00:28:36,960
the standard model

663
00:28:36,960 --> 00:28:39,600
another direction to go in would be to

664
00:28:39,600 --> 00:28:44,559
try and extend the results of afk 21

665
00:28:44,559 --> 00:28:48,399
to the quantum random oracle model

666
00:28:48,399 --> 00:28:50,799
another question was whether we could

667
00:28:50,799 --> 00:28:51,760
achieve

668
00:28:51,760 --> 00:28:55,840
sublinear verification without pairings

669
00:28:55,840 --> 00:28:57,200
and

670
00:28:57,200 --> 00:28:58,799
in particular this is kind of a

671
00:28:58,799 --> 00:29:00,720
technical reason

672
00:29:00,720 --> 00:29:02,039
but

673
00:29:02,039 --> 00:29:04,399
multi-exponentiations using pippingers

674
00:29:04,399 --> 00:29:06,799
still use a quasi-linear number of field

675
00:29:06,799 --> 00:29:09,440
operations which is important when using

676
00:29:09,440 --> 00:29:10,960
inner product arguments to build

677
00:29:10,960 --> 00:29:13,440
polynomial commitments to plug into

678
00:29:13,440 --> 00:29:16,960
polynomial iops or algebraic holographic

679
00:29:16,960 --> 00:29:18,960
proofs if you want them to run in a

680
00:29:18,960 --> 00:29:20,399
linear number of

681
00:29:20,399 --> 00:29:23,919
field operations and since ls21

682
00:29:23,919 --> 00:29:27,120
actually requires square root group

683
00:29:27,120 --> 00:29:28,640
operations

684
00:29:28,640 --> 00:29:32,000
it does accomplish this

685
00:29:32,000 --> 00:29:34,559
the next question would be can we

686
00:29:34,559 --> 00:29:36,399
achieve logarithmic

687
00:29:36,399 --> 00:29:41,039
verification without pairings

688
00:29:41,039 --> 00:29:41,919
and

689
00:29:41,919 --> 00:29:44,640
can we improve on the lattice base inner

690
00:29:44,640 --> 00:29:48,640
product argument of bl and s20 could

691
00:29:48,640 --> 00:29:51,279
dory be adapted to the lattice setting

692
00:29:51,279 --> 00:29:54,000
and this might also answer a question of

693
00:29:54,000 --> 00:29:55,679
whether we can achieve logarithmic

694
00:29:55,679 --> 00:29:58,399
verification without pairings can we

695
00:29:58,399 --> 00:30:01,440
improve on the arithmetization

696
00:30:01,440 --> 00:30:02,799
of

697
00:30:02,799 --> 00:30:05,919
bulletproofs or lmr

698
00:30:05,919 --> 00:30:08,480
which would mean

699
00:30:08,480 --> 00:30:11,440
taking an arithmetic circuit and

700
00:30:11,440 --> 00:30:13,520
turning it into

701
00:30:13,520 --> 00:30:16,000
an inner product which we then proved

702
00:30:16,000 --> 00:30:18,240
with an inner product protocol rather

703
00:30:18,240 --> 00:30:20,559
than turning our inner product argument

704
00:30:20,559 --> 00:30:22,320
into a polynomial commitment and then

705
00:30:22,320 --> 00:30:27,600
plugging it into a p o i p or ahp

706
00:30:27,600 --> 00:30:30,960
so that wraps up my talk thank you for

707
00:30:30,960 --> 00:30:33,840
watching and be sure to check out the

708
00:30:33,840 --> 00:30:38,080
paper at this link if this were a live

709
00:30:38,080 --> 00:30:40,559
talk this is where i would be asking for

710
00:30:40,559 --> 00:30:43,520
questions but if you are at azure crypt

711
00:30:43,520 --> 00:30:46,000
you can ask me them during the live

712
00:30:46,000 --> 00:30:48,960
session

