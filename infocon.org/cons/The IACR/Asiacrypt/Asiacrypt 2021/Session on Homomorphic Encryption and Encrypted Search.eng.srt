1
00:00:00,560 --> 00:00:02,159
so

2
00:00:02,159 --> 00:00:04,380
thank you for starting recording so

3
00:00:04,380 --> 00:00:06,799
[Music]

4
00:00:06,799 --> 00:00:10,160
oops you've muted yourself

5
00:00:10,160 --> 00:00:11,440
thank you

6
00:00:11,440 --> 00:00:14,160
so now we would like to start normal

7
00:00:14,160 --> 00:00:17,520
encryption and encrypted search session

8
00:00:17,520 --> 00:00:20,960
the first speaker is mark joy the title

9
00:00:20,960 --> 00:00:24,000
is balance no adojence forms so could

10
00:00:24,000 --> 00:00:28,119
you start please mark

11
00:00:31,599 --> 00:00:34,559
so thank you etsuko

12
00:00:40,239 --> 00:00:42,399
every season on your side

13
00:00:42,399 --> 00:00:47,360
yes that's good can you see my legs

14
00:00:47,760 --> 00:00:50,800
yes yes okay perfect

15
00:00:50,800 --> 00:00:52,960
um so this session is on

16
00:00:52,960 --> 00:00:54,800
part of it at least it's on philomorphic

17
00:00:54,800 --> 00:00:56,239
encryption

18
00:00:56,239 --> 00:00:56,960
and

19
00:00:56,960 --> 00:00:59,280
sometimes sociomorphic encryption is

20
00:00:59,280 --> 00:01:02,160
called the holy grail of crypto

21
00:01:02,160 --> 00:01:04,799
and indeed that's a beautiful technology

22
00:01:04,799 --> 00:01:06,560
um and for example

23
00:01:06,560 --> 00:01:08,560
it could be a solution to address data

24
00:01:08,560 --> 00:01:09,920
breaches

25
00:01:09,920 --> 00:01:12,799
and what is nice with fhe sociomorphic

26
00:01:12,799 --> 00:01:15,520
encryption is that data is end to end

27
00:01:15,520 --> 00:01:18,799
encrypted so that is encrypted at rest

28
00:01:18,799 --> 00:01:20,400
during transit

29
00:01:20,400 --> 00:01:22,880
and even during its processing

30
00:01:22,880 --> 00:01:24,320
so unlike

31
00:01:24,320 --> 00:01:26,560
traditional cryptography so there is no

32
00:01:26,560 --> 00:01:30,960
need to decrypt to process the data

33
00:01:31,680 --> 00:01:34,560
now if you want to implement fhe

34
00:01:34,560 --> 00:01:36,880
so one of the main challenge is the

35
00:01:36,880 --> 00:01:37,759
noise

36
00:01:37,759 --> 00:01:39,280
so today

37
00:01:39,280 --> 00:01:41,040
all the construction we know for

38
00:01:41,040 --> 00:01:42,720
photomorphic encryption

39
00:01:42,720 --> 00:01:45,280
produced noisy ciphertext

40
00:01:45,280 --> 00:01:47,600
and when you play with those ciphertext

41
00:01:47,600 --> 00:01:48,720
so when you

42
00:01:48,720 --> 00:01:51,680
work over encrypted data so the noise

43
00:01:51,680 --> 00:01:52,560
tent

44
00:01:52,560 --> 00:01:55,360
tends to increase and if the noise

45
00:01:55,360 --> 00:01:57,759
exceeds a given threshold so it might be

46
00:01:57,759 --> 00:02:00,320
the case that the ciphertext cannot

47
00:02:00,320 --> 00:02:02,799
longer be decrypted

48
00:02:02,799 --> 00:02:05,040
and so what i'd like to do in this talk

49
00:02:05,040 --> 00:02:07,439
is to find a way to better control the

50
00:02:07,439 --> 00:02:09,199
noise and

51
00:02:09,199 --> 00:02:10,000
let's

52
00:02:10,000 --> 00:02:12,879
first take a look at one example so

53
00:02:12,879 --> 00:02:15,760
assume that you have some private data x

54
00:02:15,760 --> 00:02:18,800
and you'd like to compute k times x

55
00:02:18,800 --> 00:02:20,640
so the basic approach so the most

56
00:02:20,640 --> 00:02:23,200
natural one we did first

57
00:02:23,200 --> 00:02:25,440
to get the encryption of x

58
00:02:25,440 --> 00:02:27,599
then you multiply by k and of course you

59
00:02:27,599 --> 00:02:31,280
get the encryption of k times x

60
00:02:31,599 --> 00:02:33,840
but there's another way to do it so

61
00:02:33,840 --> 00:02:36,560
something else you could do instead

62
00:02:36,560 --> 00:02:40,319
would be to first decompose k so in some

63
00:02:40,319 --> 00:02:41,840
radix b

64
00:02:41,840 --> 00:02:43,920
then you obtain

65
00:02:43,920 --> 00:02:47,760
the encryption of b to the i times x

66
00:02:47,760 --> 00:02:50,720
then you take a linear combination of

67
00:02:50,720 --> 00:02:53,280
all the ciphertext and again so it's

68
00:02:53,280 --> 00:02:54,959
easy to see that you'll get the

69
00:02:54,959 --> 00:02:56,239
encryption of

70
00:02:56,239 --> 00:02:58,000
k times x

71
00:02:58,000 --> 00:02:59,840
so what's the advantage of the signal

72
00:02:59,840 --> 00:03:00,800
approach

73
00:03:00,800 --> 00:03:03,120
over the first one

74
00:03:03,120 --> 00:03:05,200
so remember that's what we'd like to

75
00:03:05,200 --> 00:03:08,080
address is the noise issue so if we look

76
00:03:08,080 --> 00:03:11,040
at the nose variance in the first case

77
00:03:11,040 --> 00:03:12,480
so we see that

78
00:03:12,480 --> 00:03:13,519
that

79
00:03:13,519 --> 00:03:15,760
variance is proportional to the square

80
00:03:15,760 --> 00:03:17,599
of k

81
00:03:17,599 --> 00:03:19,680
in the second case

82
00:03:19,680 --> 00:03:22,640
so you can see that the noise variance

83
00:03:22,640 --> 00:03:25,040
is now proportional

84
00:03:25,040 --> 00:03:27,599
to the sum of the square of the digit of

85
00:03:27,599 --> 00:03:28,799
k

86
00:03:28,799 --> 00:03:31,360
and you see that that second bond is

87
00:03:31,360 --> 00:03:33,680
slower than the first one so that one is

88
00:03:33,680 --> 00:03:35,519
better

89
00:03:35,519 --> 00:03:36,319
and

90
00:03:36,319 --> 00:03:37,920
what i'd like to do

91
00:03:37,920 --> 00:03:39,519
is to find the best possible

92
00:03:39,519 --> 00:03:40,879
decomposition

93
00:03:40,879 --> 00:03:42,239
so the problem is the following one so

94
00:03:42,239 --> 00:03:44,720
we are given some integer k

95
00:03:44,720 --> 00:03:46,159
somewhat b

96
00:03:46,159 --> 00:03:48,319
and you'd like to find the best possible

97
00:03:48,319 --> 00:03:50,959
decomposition

98
00:03:50,959 --> 00:03:53,200
so that is written like this

99
00:03:53,200 --> 00:03:54,319
such that

100
00:03:54,319 --> 00:03:56,159
the square the sum of the square of the

101
00:03:56,159 --> 00:03:58,959
digit so this is called the euclidean

102
00:03:58,959 --> 00:04:01,840
weight is minimum

103
00:04:02,239 --> 00:04:03,680
and

104
00:04:03,680 --> 00:04:05,680
there are already some decomposition

105
00:04:05,680 --> 00:04:07,680
that we know so for example

106
00:04:07,680 --> 00:04:10,879
so when b is equal to two

107
00:04:10,879 --> 00:04:12,799
so there is one that is pretty well

108
00:04:12,799 --> 00:04:14,480
known which is the nav

109
00:04:14,480 --> 00:04:17,120
so the non-adjacent form

110
00:04:17,120 --> 00:04:19,680
and for that form so we know that the

111
00:04:19,680 --> 00:04:20,959
number

112
00:04:20,959 --> 00:04:23,040
of non-zero digits is minimum so the

113
00:04:23,040 --> 00:04:25,680
number of one and minus one is minimal

114
00:04:25,680 --> 00:04:28,880
in that form so in the naf

115
00:04:28,880 --> 00:04:31,520
and because of that so i mean it's easy

116
00:04:31,520 --> 00:04:34,320
to see that that one will uh minimize

117
00:04:34,320 --> 00:04:36,880
euclidean weight

118
00:04:36,880 --> 00:04:38,479
another case that is not too difficult

119
00:04:38,479 --> 00:04:41,840
to deal with is when the radix is odd so

120
00:04:41,840 --> 00:04:43,520
when b is r

121
00:04:43,520 --> 00:04:45,440
so what you can always do

122
00:04:45,440 --> 00:04:48,160
for a node radix b you can always

123
00:04:48,160 --> 00:04:51,280
decompose an integer using digit in the

124
00:04:51,280 --> 00:04:53,040
set minus

125
00:04:53,040 --> 00:04:56,720
b minus 1 over 2 up to b minus 1 over 2.

126
00:04:56,720 --> 00:04:59,840
so the form you get is unique and it can

127
00:04:59,840 --> 00:05:01,360
be shown that

128
00:05:01,360 --> 00:05:04,000
actually so it also minimize the

129
00:05:04,000 --> 00:05:06,800
euclidean weight

130
00:05:07,120 --> 00:05:09,840
so the difficult case is when uh you

131
00:05:09,840 --> 00:05:12,720
have an even radix b that is larger than

132
00:05:12,720 --> 00:05:14,160
two

133
00:05:14,160 --> 00:05:17,039
but in that case there is a very simple

134
00:05:17,039 --> 00:05:17,840
but

135
00:05:17,840 --> 00:05:19,840
useful observation

136
00:05:19,840 --> 00:05:22,240
is that when you have

137
00:05:22,240 --> 00:05:24,479
some decomposition so like this one

138
00:05:24,479 --> 00:05:26,880
so something you can always do of course

139
00:05:26,880 --> 00:05:28,240
you can flip

140
00:05:28,240 --> 00:05:31,039
the sign of one digit so this one and

141
00:05:31,039 --> 00:05:33,120
what you have to do is just to propagate

142
00:05:33,120 --> 00:05:35,600
the sign to the side to the to the next

143
00:05:35,600 --> 00:05:36,560
digit

144
00:05:36,560 --> 00:05:39,360
and that give you another

145
00:05:39,360 --> 00:05:41,680
representation that is valid so you may

146
00:05:41,680 --> 00:05:43,520
need to propagate again and again and

147
00:05:43,520 --> 00:05:44,400
again

148
00:05:44,400 --> 00:05:46,000
but at the end so you get a valid

149
00:05:46,000 --> 00:05:49,759
representation of your uh integer k

150
00:05:49,759 --> 00:05:51,759
so let's take an example

151
00:05:51,759 --> 00:05:54,479
so assume for example that's radix b is

152
00:05:54,479 --> 00:05:56,720
equal to 4

153
00:05:56,720 --> 00:06:00,319
so 2 2 is a valid representation for 10

154
00:06:00,319 --> 00:06:02,880
what you could do so you could flip the

155
00:06:02,880 --> 00:06:04,479
digits so you get

156
00:06:04,479 --> 00:06:07,280
1 minus two two which is another

157
00:06:07,280 --> 00:06:10,160
value representation for ten in red x4

158
00:06:10,160 --> 00:06:13,120
you can also flip the digits and you end

159
00:06:13,120 --> 00:06:16,400
up with minus two minus one and one

160
00:06:16,400 --> 00:06:18,160
and this is the minimal form so you

161
00:06:18,160 --> 00:06:20,800
cannot do better

162
00:06:20,800 --> 00:06:24,400
and so intuition tells you that well uh

163
00:06:24,400 --> 00:06:26,880
it seems that what we have to do is when

164
00:06:26,880 --> 00:06:28,319
we have a two

165
00:06:28,319 --> 00:06:30,800
followed by a minus two then we flip so

166
00:06:30,800 --> 00:06:31,919
we flip

167
00:06:31,919 --> 00:06:35,039
that that tube and the same so if you

168
00:06:35,039 --> 00:06:37,520
have a two followed by another two

169
00:06:37,520 --> 00:06:38,240
and

170
00:06:38,240 --> 00:06:40,880
actually so this is essentially what we

171
00:06:40,880 --> 00:06:44,479
do to get uh the optimal form

172
00:06:44,479 --> 00:06:49,039
and so i just show you the algorithm

173
00:06:49,039 --> 00:06:51,280
here it is

174
00:06:51,280 --> 00:06:52,479
so

175
00:06:52,479 --> 00:06:54,560
as an input you take

176
00:06:54,560 --> 00:06:56,000
an integer k

177
00:06:56,000 --> 00:06:58,160
and as an output so you get that optimal

178
00:06:58,160 --> 00:07:00,960
form so i call it the binauf

179
00:07:00,960 --> 00:07:03,280
the digits are in that range

180
00:07:03,280 --> 00:07:04,080
so

181
00:07:04,080 --> 00:07:06,800
between minus b over two up to b over

182
00:07:06,800 --> 00:07:08,639
two and this is right it's called

183
00:07:08,639 --> 00:07:11,199
balanced

184
00:07:11,280 --> 00:07:12,240
um

185
00:07:12,240 --> 00:07:14,000
so what is the domain the main step in

186
00:07:14,000 --> 00:07:16,160
that recording is this one so there is

187
00:07:16,160 --> 00:07:17,280
that

188
00:07:17,280 --> 00:07:19,280
if branching here with two conditions so

189
00:07:19,280 --> 00:07:21,039
this one and this one

190
00:07:21,039 --> 00:07:23,039
and in if one of those two condition is

191
00:07:23,039 --> 00:07:26,000
satisfied then you have to flip you just

192
00:07:26,000 --> 00:07:26,960
flip

193
00:07:26,960 --> 00:07:31,239
the digit value

194
00:07:31,360 --> 00:07:32,639
so some

195
00:07:32,639 --> 00:07:35,360
special cases when b is r

196
00:07:35,360 --> 00:07:39,360
so it simplifies to just one condition

197
00:07:39,360 --> 00:07:41,039
and actually so this is

198
00:07:41,039 --> 00:07:44,240
just the usual balanced form so using

199
00:07:44,240 --> 00:07:46,560
that set of digits

200
00:07:46,560 --> 00:07:50,960
and that one is known to be unique

201
00:07:51,840 --> 00:07:54,479
when we have b equal to 2

202
00:07:54,479 --> 00:07:56,319
so it's not too difficult to see that

203
00:07:56,319 --> 00:07:58,560
this is another way to get enough so the

204
00:07:58,560 --> 00:07:59,840
regular one

205
00:07:59,840 --> 00:08:03,759
and so i mean that's not a surprise

206
00:08:03,759 --> 00:08:06,400
and so the the difficult case so when b

207
00:08:06,400 --> 00:08:08,319
is even and larger than two

208
00:08:08,319 --> 00:08:10,800
so we need to check those two condition

209
00:08:10,800 --> 00:08:13,440
and this is the general algorithm to get

210
00:08:13,440 --> 00:08:15,039
the binaura recording

211
00:08:15,039 --> 00:08:17,440
so it's called binauf because

212
00:08:17,440 --> 00:08:20,400
it's enough when b is equal to 2 and

213
00:08:20,400 --> 00:08:22,639
balanced because the set of digi that is

214
00:08:22,639 --> 00:08:26,120
used is balanced

215
00:08:27,199 --> 00:08:28,720
okay

216
00:08:28,720 --> 00:08:32,080
um so the main results uh

217
00:08:32,080 --> 00:08:36,240
so first we showed that binauf is unique

218
00:08:36,240 --> 00:08:38,640
and more importantly so we showed that

219
00:08:38,640 --> 00:08:42,479
the equidant weight of binauf is minimal

220
00:08:42,479 --> 00:08:45,440
so you cannot do better

221
00:08:47,120 --> 00:08:49,360
so in the paper so we also

222
00:08:49,360 --> 00:08:52,399
analyze the digit distribution

223
00:08:52,399 --> 00:08:54,640
and that allows us to compute the

224
00:08:54,640 --> 00:08:56,959
expectation and the variance

225
00:08:56,959 --> 00:08:59,440
and what is nice is that the expectation

226
00:08:59,440 --> 00:09:01,680
is zero so the distribution is centered

227
00:09:01,680 --> 00:09:05,920
i mean which is also a useful property

228
00:09:07,519 --> 00:09:09,360
so to sum up

229
00:09:09,360 --> 00:09:12,480
so i did present a new form to decompose

230
00:09:12,480 --> 00:09:14,399
an integer

231
00:09:14,399 --> 00:09:15,440
so

232
00:09:15,440 --> 00:09:17,279
you can do exactly the same

233
00:09:17,279 --> 00:09:20,480
using modular integer so that's in the

234
00:09:20,480 --> 00:09:21,519
paper

235
00:09:21,519 --> 00:09:24,480
we show that snap always exists and is

236
00:09:24,480 --> 00:09:27,279
unique it's optimal so meaning that the

237
00:09:27,279 --> 00:09:30,080
euclidean weight is minimal

238
00:09:30,080 --> 00:09:33,040
we analyze the dg distribution and also

239
00:09:33,040 --> 00:09:34,320
in the paper

240
00:09:34,320 --> 00:09:36,000
so you can't find uh several

241
00:09:36,000 --> 00:09:38,160
cryptographic applications and mostly

242
00:09:38,160 --> 00:09:41,040
for uh foreign morphic encryption

243
00:09:41,040 --> 00:09:43,839
thank you very much

244
00:09:44,959 --> 00:09:47,760
thank you mark do we have any questions

245
00:09:47,760 --> 00:09:51,240
from the audience

246
00:09:53,519 --> 00:09:56,480
if not i'll i'll ah so you're you

247
00:09:56,480 --> 00:09:57,920
analyzed

248
00:09:57,920 --> 00:09:59,440
oh sorry

249
00:09:59,440 --> 00:10:00,720
one

250
00:10:00,720 --> 00:10:04,920
one audience has hangings

251
00:10:08,880 --> 00:10:11,040
okay just you you analyze this for a

252
00:10:11,040 --> 00:10:12,640
particular radix

253
00:10:12,640 --> 00:10:14,720
can you give some intuition for why

254
00:10:14,720 --> 00:10:17,360
different radixes come up in practice in

255
00:10:17,360 --> 00:10:20,160
in fhe evaluation

256
00:10:20,160 --> 00:10:22,160
so typically so you use a power of two

257
00:10:22,160 --> 00:10:24,240
because that's more convenient

258
00:10:24,240 --> 00:10:27,040
and uh i mean this is mostly used

259
00:10:27,040 --> 00:10:28,399
in what is known as the gadget

260
00:10:28,399 --> 00:10:30,000
decomposition

261
00:10:30,000 --> 00:10:33,120
and so the size of b i mean um tells you

262
00:10:33,120 --> 00:10:34,000
uh

263
00:10:34,000 --> 00:10:35,600
i'm going to give you exactly the

264
00:10:35,600 --> 00:10:37,440
decomposition so i mean it's always a

265
00:10:37,440 --> 00:10:38,720
trade-off

266
00:10:38,720 --> 00:10:40,240
um

267
00:10:40,240 --> 00:10:41,839
so i mean a smaller b i mean will

268
00:10:41,839 --> 00:10:43,519
increase the size of the encryption but

269
00:10:43,519 --> 00:10:45,440
uh give you a more fine

270
00:10:45,440 --> 00:10:47,440
control of the noise while a larger

271
00:10:47,440 --> 00:10:49,920
value for b i mean instead

272
00:10:49,920 --> 00:10:52,880
the opposite effect

273
00:10:58,000 --> 00:10:59,760
i mean that's also using the gsw

274
00:10:59,760 --> 00:11:01,519
cryptosystem so i mean this is a

275
00:11:01,519 --> 00:11:05,519
well-known trick to to manage the noise

276
00:11:11,120 --> 00:11:11,920
okay

277
00:11:11,920 --> 00:11:15,040
um great uh thank you very much mark

278
00:11:15,040 --> 00:11:17,279
there's no more questions we'll

279
00:11:17,279 --> 00:11:20,399
move to the next speaker

280
00:11:24,480 --> 00:11:26,000
which

281
00:11:26,000 --> 00:11:29,440
gets all introduced so the this talk is

282
00:11:29,440 --> 00:11:32,079
going to be given by uh jun young the

283
00:11:32,079 --> 00:11:34,399
title of the talk is efficient boolean

284
00:11:34,399 --> 00:11:37,200
search over encrypted data with reduced

285
00:11:37,200 --> 00:11:39,040
leakage

286
00:11:39,040 --> 00:11:40,800
and

287
00:11:40,800 --> 00:11:42,720
can you go ahead and uh share your

288
00:11:42,720 --> 00:11:43,920
screen

289
00:11:43,920 --> 00:11:46,880
uh can everyone see my screen or

290
00:11:46,880 --> 00:11:48,160
not yet

291
00:11:48,160 --> 00:11:50,160
oh it's not shared

292
00:11:50,160 --> 00:11:51,920
right

293
00:11:51,920 --> 00:11:53,600
oh sorry

294
00:11:53,600 --> 00:11:54,639
oh can

295
00:11:54,639 --> 00:11:58,800
you see my screen yep that looks great

296
00:11:58,959 --> 00:12:02,560
okay so um yeah hi uh my name is uh jin

297
00:12:02,560 --> 00:12:05,519
yang and i'm here to present our work

298
00:12:05,519 --> 00:12:07,680
titled the efficient boolean search over

299
00:12:07,680 --> 00:12:11,839
increment data with reduced leakage

300
00:12:12,399 --> 00:12:14,639
so um there has been extensive studies

301
00:12:14,639 --> 00:12:17,200
on encrypted search and many different

302
00:12:17,200 --> 00:12:19,200
approaches have been proposed with

303
00:12:19,200 --> 00:12:21,760
different trade-offs and in our work

304
00:12:21,760 --> 00:12:24,480
specifically we focus on structured

305
00:12:24,480 --> 00:12:26,959
encryption which considers a more

306
00:12:26,959 --> 00:12:28,959
relaxed privacy requirement with the

307
00:12:28,959 --> 00:12:31,440
hope of achieving small overhead

308
00:12:31,440 --> 00:12:35,440
necessary for practical applications

309
00:12:35,440 --> 00:12:38,160
a little bit of a preliminaries

310
00:12:38,160 --> 00:12:40,720
a multi-map data structure maintains a

311
00:12:40,720 --> 00:12:44,079
set of labels to uh value two low pairs

312
00:12:44,079 --> 00:12:45,920
and the multiple data structure supports

313
00:12:45,920 --> 00:12:48,800
a query operation that receives a label

314
00:12:48,800 --> 00:12:51,440
and returns a value tuple associated

315
00:12:51,440 --> 00:12:54,240
with the given label and um you'll

316
00:12:54,240 --> 00:12:57,440
consider the extended boolean multi-map

317
00:12:57,440 --> 00:12:59,360
that enables more complex query

318
00:12:59,360 --> 00:13:02,320
operations beyond simply just retrieving

319
00:13:02,320 --> 00:13:04,000
value tuples associated with a single

320
00:13:04,000 --> 00:13:05,120
label

321
00:13:05,120 --> 00:13:07,519
and essentially a boolean multi-map is

322
00:13:07,519 --> 00:13:09,600
associated with the supported class of

323
00:13:09,600 --> 00:13:12,320
boolean formula query over labels and in

324
00:13:12,320 --> 00:13:15,279
our work we specifically focus on

325
00:13:15,279 --> 00:13:18,720
conjunctive queries and the cnf formulae

326
00:13:18,720 --> 00:13:19,600
and

327
00:13:19,600 --> 00:13:22,240
finally encrypted buoy multi-map is just

328
00:13:22,240 --> 00:13:24,399
a structured encryption for uh boolean

329
00:13:24,399 --> 00:13:27,040
multimaps

330
00:13:28,959 --> 00:13:31,600
our work is largely influenced by the

331
00:13:31,600 --> 00:13:34,079
following three papers and especially

332
00:13:34,079 --> 00:13:36,240
and we'll especially reference the biex

333
00:13:36,240 --> 00:13:39,279
scheme presented in km17

334
00:13:39,279 --> 00:13:42,160
throughout our work

335
00:13:43,680 --> 00:13:46,480
so um we present new encrypted boolean

336
00:13:46,480 --> 00:13:49,839
multi-maps which are adaptably secure

337
00:13:49,839 --> 00:13:51,360
non-interactive

338
00:13:51,360 --> 00:13:53,760
have similar or better efficiency and

339
00:13:53,760 --> 00:13:56,240
have reduced leakage compared to prior

340
00:13:56,240 --> 00:13:57,279
works

341
00:13:57,279 --> 00:13:58,720
in particular we obtain new

342
00:13:58,720 --> 00:14:01,600
constructions for handling conjunctions

343
00:14:01,600 --> 00:14:05,279
and cnf queries with reduced leakage and

344
00:14:05,279 --> 00:14:07,199
has have a optimal communication

345
00:14:07,199 --> 00:14:08,880
complexity

346
00:14:08,880 --> 00:14:10,959
and furthermore our scheme only uses a

347
00:14:10,959 --> 00:14:12,800
symmetric key parameters and ends up

348
00:14:12,800 --> 00:14:13,920
being

349
00:14:13,920 --> 00:14:17,160
quite practical

350
00:14:18,639 --> 00:14:21,760
uh we start by presenting the approach

351
00:14:21,760 --> 00:14:24,560
to handling conjunctive queries using

352
00:14:24,560 --> 00:14:28,000
previous works such as km17

353
00:14:28,000 --> 00:14:31,600
so consider the conjunctive query l1 and

354
00:14:31,600 --> 00:14:34,959
l2 and all the way up to lq

355
00:14:34,959 --> 00:14:38,399
the main idea of bix is to decompose the

356
00:14:38,399 --> 00:14:41,120
query into q minus one

357
00:14:41,120 --> 00:14:42,639
two conjunctions

358
00:14:42,639 --> 00:14:44,720
where each is computed independently

359
00:14:44,720 --> 00:14:46,959
such that the resulting response sets

360
00:14:46,959 --> 00:14:49,920
are all pr evaluations under the key

361
00:14:49,920 --> 00:14:52,720
solely depending on the first label l1

362
00:14:52,720 --> 00:14:53,600
and

363
00:14:53,600 --> 00:14:56,000
essentially the server can retrieve mm

364
00:14:56,000 --> 00:14:59,120
of l1 and l2 mm l1 and l3

365
00:14:59,120 --> 00:15:01,600
etc independently and compute the

366
00:15:01,600 --> 00:15:04,720
intersection of all q minus 1 sets and

367
00:15:04,720 --> 00:15:08,000
return the response to the client

368
00:15:08,000 --> 00:15:10,160
however there are several drawbacks to

369
00:15:10,160 --> 00:15:12,320
using this approach

370
00:15:12,320 --> 00:15:14,800
first the scheme leaks the volumes of

371
00:15:14,800 --> 00:15:17,279
the q minus one two conjunctions

372
00:15:17,279 --> 00:15:19,279
so the server can learn volumes of more

373
00:15:19,279 --> 00:15:21,040
complex queries

374
00:15:21,040 --> 00:15:23,760
and secondly the server must perform

375
00:15:23,760 --> 00:15:26,240
competition computation on the order of

376
00:15:26,240 --> 00:15:28,560
the sum of the size of the response sets

377
00:15:28,560 --> 00:15:30,480
from the two conjunctions

378
00:15:30,480 --> 00:15:32,160
which seems quite wasteful as the

379
00:15:32,160 --> 00:15:35,199
response sets of mm of l1 and l2

380
00:15:35,199 --> 00:15:37,440
is already a superset of the final

381
00:15:37,440 --> 00:15:40,240
response

382
00:15:40,240 --> 00:15:42,880
and um to address these drawbacks uh we

383
00:15:42,880 --> 00:15:44,800
present the new filtering algorithm

384
00:15:44,800 --> 00:15:48,560
which is going to be the core of our um

385
00:15:48,560 --> 00:15:49,600
paper

386
00:15:49,600 --> 00:15:51,839
which will be utilized by our by our

387
00:15:51,839 --> 00:15:54,480
construction and the conch filter

388
00:15:54,480 --> 00:15:57,040
the main idea is to only retrieve mm of

389
00:15:57,040 --> 00:16:00,240
l1 and l2 and do the filtering on this

390
00:16:00,240 --> 00:16:02,160
set instead of retrieving

391
00:16:02,160 --> 00:16:06,160
all of mm of l1 and l3 and on mml and l4

392
00:16:06,160 --> 00:16:07,440
and so on

393
00:16:07,440 --> 00:16:11,360
like it does in km17

394
00:16:11,360 --> 00:16:13,600
to do this we maintain an additional

395
00:16:13,600 --> 00:16:15,920
data structure that allows the server to

396
00:16:15,920 --> 00:16:19,279
check whether a value v and mm of l1 and

397
00:16:19,279 --> 00:16:21,519
l2 belongs to

398
00:16:21,519 --> 00:16:25,360
mm of like l1 and l3 mml and l4 and so

399
00:16:25,360 --> 00:16:27,279
on directly

400
00:16:27,279 --> 00:16:29,759
without having to retrieve them

401
00:16:29,759 --> 00:16:31,759
retrieve them

402
00:16:31,759 --> 00:16:34,320
and this data structure is constructed

403
00:16:34,320 --> 00:16:36,240
in such a way that the leakage is

404
00:16:36,240 --> 00:16:38,160
significantly reduced

405
00:16:38,160 --> 00:16:40,000
and at a high level um this data

406
00:16:40,000 --> 00:16:42,560
structure is just a set of double prf

407
00:16:42,560 --> 00:16:44,320
evaluations of the values stored in the

408
00:16:44,320 --> 00:16:45,920
encrypted multi-maps

409
00:16:45,920 --> 00:16:48,399
and one can check for the membership by

410
00:16:48,399 --> 00:16:50,880
simply applying a prf in the response

411
00:16:50,880 --> 00:16:53,199
set and then checking whether this uh

412
00:16:53,199 --> 00:16:55,680
resulting evaluation is in this set and

413
00:16:55,680 --> 00:16:57,600
then do the filtering

414
00:16:57,600 --> 00:16:59,040
on the response

415
00:16:59,040 --> 00:17:01,199
[Music]

416
00:17:01,199 --> 00:17:03,839
um and it turns out our conch filter

417
00:17:03,839 --> 00:17:06,400
scheme has smaller query leakage

418
00:17:06,400 --> 00:17:08,079
and with the setup leakage being

419
00:17:08,079 --> 00:17:11,439
identical to bix and km17

420
00:17:11,439 --> 00:17:13,439
and it also turns out that the storage

421
00:17:13,439 --> 00:17:15,439
and the token size also turns out to be

422
00:17:15,439 --> 00:17:19,559
identical to km17

423
00:17:23,280 --> 00:17:27,119
and um so our we also present um

424
00:17:27,119 --> 00:17:29,360
the cnn filter which handles our cnf

425
00:17:29,360 --> 00:17:30,840
queries

426
00:17:30,840 --> 00:17:34,880
um and um using a clever reformulation

427
00:17:34,880 --> 00:17:37,679
of the given clf formula and using our

428
00:17:37,679 --> 00:17:39,600
filtering algorithm again we can

429
00:17:39,600 --> 00:17:42,559
actually construct the new um cnf scheme

430
00:17:42,559 --> 00:17:43,919
cnn filter

431
00:17:43,919 --> 00:17:45,919
which has a small leakage and better

432
00:17:45,919 --> 00:17:49,120
computation cost compared to um bix

433
00:17:49,120 --> 00:17:51,840
um so it's a bit lengthy to go into

434
00:17:51,840 --> 00:17:54,240
details on this here but please see the

435
00:17:54,240 --> 00:17:57,919
full paper for anyone interested

436
00:18:00,240 --> 00:18:01,440
um so

437
00:18:01,440 --> 00:18:04,000
this table shows micro benchmarks for

438
00:18:04,000 --> 00:18:07,039
the search time of the rcn filter and

439
00:18:07,039 --> 00:18:10,640
the bix on randomly chosen queries

440
00:18:10,640 --> 00:18:11,760
and

441
00:18:11,760 --> 00:18:13,840
we actually see that our cn filter

442
00:18:13,840 --> 00:18:17,440
scheme outperforms biex in all scenarios

443
00:18:17,440 --> 00:18:20,480
and in some cases as much as a 20x

444
00:18:20,480 --> 00:18:22,960
faster

445
00:18:23,120 --> 00:18:24,720
and the both

446
00:18:24,720 --> 00:18:27,280
line charts show search token sizes of

447
00:18:27,280 --> 00:18:30,400
the cn filter and the biex and we see

448
00:18:30,400 --> 00:18:32,400
that in practice our

449
00:18:32,400 --> 00:18:34,799
token size of the sand filter is almost

450
00:18:34,799 --> 00:18:38,960
twice as small as that of the iex

451
00:18:40,480 --> 00:18:43,039
and lastly um this table

452
00:18:43,039 --> 00:18:45,039
shows storage instead of time of stamp

453
00:18:45,039 --> 00:18:47,360
filter and diex

454
00:18:47,360 --> 00:18:49,600
since cn filter maintains an additional

455
00:18:49,600 --> 00:18:51,520
data structure we observe that the

456
00:18:51,520 --> 00:18:52,799
source size and set of time are

457
00:18:52,799 --> 00:18:55,360
generally larger for cn filter

458
00:18:55,360 --> 00:18:57,919
but we see that the storage size is only

459
00:18:57,919 --> 00:19:01,520
20 to 25 larger and we believe that the

460
00:19:01,520 --> 00:19:04,720
extra set up time is a reasonable um

461
00:19:04,720 --> 00:19:06,240
trade-off given the leakage

462
00:19:06,240 --> 00:19:07,679
communication and the service

463
00:19:07,679 --> 00:19:09,039
computation

464
00:19:09,039 --> 00:19:13,120
improvements that our scheme provides

465
00:19:13,360 --> 00:19:15,600
and

466
00:19:15,600 --> 00:19:18,480
that is it

467
00:19:18,799 --> 00:19:21,120
great thank you once again um any

468
00:19:21,120 --> 00:19:25,479
questions from the audience

469
00:19:26,960 --> 00:19:30,240
so just while while we're waiting

470
00:19:30,240 --> 00:19:33,600
um can you give some intuition on why

471
00:19:33,600 --> 00:19:36,320
you couldn't so you're essentially

472
00:19:36,320 --> 00:19:38,960
except for the first leaking triples of

473
00:19:38,960 --> 00:19:41,679
volumes why you couldn't extend this to

474
00:19:41,679 --> 00:19:45,200
any like constant number of

475
00:19:45,200 --> 00:19:46,000
of

476
00:19:46,000 --> 00:19:49,200
operands or literals

477
00:19:49,200 --> 00:19:50,080
um

478
00:19:50,080 --> 00:19:52,400
constants

479
00:19:52,400 --> 00:19:55,760
so like why couldn't could you put three

480
00:19:55,760 --> 00:19:58,400
conjunctions in the outer prf evaluation

481
00:19:58,400 --> 00:20:00,000
what keeps you from being able to do

482
00:20:00,000 --> 00:20:00,799
that

483
00:20:00,799 --> 00:20:02,880
so that would actually increase the

484
00:20:02,880 --> 00:20:04,559
storage size to

485
00:20:04,559 --> 00:20:06,720
i guess like so right now the storage

486
00:20:06,720 --> 00:20:09,360
size is all quadratic like in a bi ex

487
00:20:09,360 --> 00:20:12,960
but if we um make a triple then that

488
00:20:12,960 --> 00:20:15,039
would actually

489
00:20:15,039 --> 00:20:17,600
make the storage size

490
00:20:17,600 --> 00:20:18,640
um

491
00:20:18,640 --> 00:20:22,080
like yeah to the power of three so um

492
00:20:22,080 --> 00:20:24,559
that essentially is a reason why we uh

493
00:20:24,559 --> 00:20:25,760
had to

494
00:20:25,760 --> 00:20:29,360
um keep it as only a double prf so this

495
00:20:29,360 --> 00:20:30,640
would keep the

496
00:20:30,640 --> 00:20:32,000
storage size

497
00:20:32,000 --> 00:20:34,640
asymptotically the same as the

498
00:20:34,640 --> 00:20:36,159
encrypted multimap

499
00:20:36,159 --> 00:20:39,360
how it's constructed yeah

500
00:20:45,679 --> 00:20:47,919
all right great thank you very much uh

501
00:20:47,919 --> 00:20:50,919
junior

502
00:21:02,080 --> 00:21:05,120
and vincent can you

503
00:21:05,120 --> 00:21:07,439
share

504
00:21:14,480 --> 00:21:17,799
with your phone

505
00:21:18,640 --> 00:21:21,200
great so the the third speaker of this

506
00:21:21,200 --> 00:21:23,360
session is going to be vincent suka

507
00:21:23,360 --> 00:21:24,640
who's going to be talking about

508
00:21:24,640 --> 00:21:26,240
revisiting homomorphic encryption

509
00:21:26,240 --> 00:21:30,200
schemes for finite fields

510
00:21:30,640 --> 00:21:32,559
can you hear me

511
00:21:32,559 --> 00:21:35,520
uh vincent your microphone appears oh

512
00:21:35,520 --> 00:21:38,000
actually i'm sorry keep talking

513
00:21:38,000 --> 00:21:39,679
yeah can you hear me

514
00:21:39,679 --> 00:21:41,760
yes i'm so sorry that was that was my

515
00:21:41,760 --> 00:21:44,480
fault please continue

516
00:21:44,480 --> 00:21:45,360
okay

517
00:21:45,360 --> 00:21:48,159
so before diving uh into the subject i

518
00:21:48,159 --> 00:21:50,720
will quickly remind some basics about

519
00:21:50,720 --> 00:21:52,799
homomorphic encryption even though mark

520
00:21:52,799 --> 00:21:53,760
already

521
00:21:53,760 --> 00:21:55,200
did it

522
00:21:55,200 --> 00:21:57,520
so essentially homomorphic encryption

523
00:21:57,520 --> 00:22:00,159
allows users to perform computation

524
00:22:00,159 --> 00:22:02,320
directly over encrypted data and in a

525
00:22:02,320 --> 00:22:04,559
nutshell this means that

526
00:22:04,559 --> 00:22:06,720
if you have two encrypted messages you

527
00:22:06,720 --> 00:22:10,640
can compute an encryption of their sum

528
00:22:10,640 --> 00:22:12,400
or their product without having access

529
00:22:12,400 --> 00:22:15,280
to the decryption key

530
00:22:15,280 --> 00:22:16,720
now the problematic thing with

531
00:22:16,720 --> 00:22:19,360
automotive encryption is that each

532
00:22:19,360 --> 00:22:21,840
ciphertext carries some noise which

533
00:22:21,840 --> 00:22:23,840
grows as computations are performed and

534
00:22:23,840 --> 00:22:26,320
we can only decrypt a message if the

535
00:22:26,320 --> 00:22:28,000
noise is not too large so this means

536
00:22:28,000 --> 00:22:30,000
essentially that ciphertext have a

537
00:22:30,000 --> 00:22:32,559
computational budget

538
00:22:32,559 --> 00:22:33,600
and

539
00:22:33,600 --> 00:22:36,480
the most expensive operation in terms of

540
00:22:36,480 --> 00:22:38,480
both computational complexity and noise

541
00:22:38,480 --> 00:22:40,240
introduced is usually thermometric

542
00:22:40,240 --> 00:22:42,400
multiplication

543
00:22:42,400 --> 00:22:44,080
and the way of handling this noise

544
00:22:44,080 --> 00:22:46,559
growth depends essentially on the scheme

545
00:22:46,559 --> 00:22:49,679
you consider and in this work we focused

546
00:22:49,679 --> 00:22:51,520
on optimizing

547
00:22:51,520 --> 00:22:55,200
this operation and for the bgv and bfv

548
00:22:55,200 --> 00:22:57,520
scheme

549
00:22:57,840 --> 00:23:01,120
so in bgv and bfv the ciphertexts are

550
00:23:01,120 --> 00:23:03,679
represented modulo in integer q

551
00:23:03,679 --> 00:23:06,159
and in bjb the message is encrypted into

552
00:23:06,159 --> 00:23:08,000
the list significant digits of a

553
00:23:08,000 --> 00:23:10,080
ciphertext while the noise is scaled by

554
00:23:10,080 --> 00:23:12,000
some parameter t to lie into the most

555
00:23:12,000 --> 00:23:14,320
significant digit

556
00:23:14,320 --> 00:23:16,480
as long as the noise is small enough the

557
00:23:16,480 --> 00:23:18,400
product of two cypher text will not

558
00:23:18,400 --> 00:23:20,640
overwrap modulo q and thus we can

559
00:23:20,640 --> 00:23:23,520
compute it directly modulo queue

560
00:23:23,520 --> 00:23:24,880
but because the noise grows

561
00:23:24,880 --> 00:23:26,480
quadratically you see on the picture

562
00:23:26,480 --> 00:23:28,159
that i won't be able to perform another

563
00:23:28,159 --> 00:23:30,559
multiplication after this one if i

564
00:23:30,559 --> 00:23:31,760
wanted to

565
00:23:31,760 --> 00:23:33,600
so the idea of the scheme is to handle

566
00:23:33,600 --> 00:23:36,720
this quadratic noise growth

567
00:23:36,720 --> 00:23:38,799
is to scale the ciphertext down by some

568
00:23:38,799 --> 00:23:40,000
factor

569
00:23:40,000 --> 00:23:42,640
before the next multiplication in such a

570
00:23:42,640 --> 00:23:44,559
way that the noise will also be scaled

571
00:23:44,559 --> 00:23:46,400
down to a minimum level that is

572
00:23:46,400 --> 00:23:48,640
equivalent to removing the red part of

573
00:23:48,640 --> 00:23:50,640
the noise on my picture

574
00:23:50,640 --> 00:23:52,320
so that after this i will be able to

575
00:23:52,320 --> 00:23:55,039
perform another multiplication

576
00:23:55,039 --> 00:23:57,039
and it is therefore crucial to have a

577
00:23:57,039 --> 00:23:59,360
precise estimate of the size of the

578
00:23:59,360 --> 00:24:01,039
noise carried by your cycle text to

579
00:24:01,039 --> 00:24:03,440
scale it down appropriately if the noise

580
00:24:03,440 --> 00:24:05,440
is underestimated then it won't be

581
00:24:05,440 --> 00:24:07,919
reduced enough and if it's overestimated

582
00:24:07,919 --> 00:24:09,760
then we will lose some computational

583
00:24:09,760 --> 00:24:13,120
budget uselessly

584
00:24:13,120 --> 00:24:14,880
in the bfv encryption scheme at the

585
00:24:14,880 --> 00:24:17,039
opposite it's a message that is scaled

586
00:24:17,039 --> 00:24:18,240
up to be encoded into the most

587
00:24:18,240 --> 00:24:19,679
significant digit

588
00:24:19,679 --> 00:24:21,520
and because of this when we perform a

589
00:24:21,520 --> 00:24:23,600
multiplication the product of the two

590
00:24:23,600 --> 00:24:26,320
cipher text will necessarily overwrap

591
00:24:26,320 --> 00:24:29,760
modulo q and if the cipher text if the

592
00:24:29,760 --> 00:24:31,760
project over rock modulo q then we lose

593
00:24:31,760 --> 00:24:33,760
the product of the two messages so to

594
00:24:33,760 --> 00:24:37,360
prevent this we need to add another

595
00:24:37,360 --> 00:24:40,480
temporarily modulus p

596
00:24:40,480 --> 00:24:42,400
to perform the multiplication and

597
00:24:42,400 --> 00:24:44,720
prevent the product of overwrapping

598
00:24:44,720 --> 00:24:45,520
the

599
00:24:45,520 --> 00:24:47,600
downside of this approach is that

600
00:24:47,600 --> 00:24:49,760
the multiplication has to be performed

601
00:24:49,760 --> 00:24:53,120
modulo pq and is less efficient than for

602
00:24:53,120 --> 00:24:55,039
bgv

603
00:24:55,039 --> 00:24:58,960
and then to get back a cypher text

604
00:24:58,960 --> 00:25:02,000
representing modulo q we basically scale

605
00:25:02,000 --> 00:25:04,799
the ciphertext down you and

606
00:25:04,799 --> 00:25:06,799
like in bgv the noise this will scale

607
00:25:06,799 --> 00:25:08,640
the noise down and similarly

608
00:25:08,640 --> 00:25:11,200
and since we have to perform this

609
00:25:11,200 --> 00:25:13,440
scaling automatic um

610
00:25:13,440 --> 00:25:16,080
after each multiplication the noise is

611
00:25:16,080 --> 00:25:18,400
also scaled automatically and we don't

612
00:25:18,400 --> 00:25:20,480
need to have any dynamic noise

613
00:25:20,480 --> 00:25:23,440
estimation in the ciphertext

614
00:25:23,440 --> 00:25:25,039
so

615
00:25:25,039 --> 00:25:28,720
in theory bgv and bfv are equivalent and

616
00:25:28,720 --> 00:25:31,039
we can even convert ciphertext from one

617
00:25:31,039 --> 00:25:32,720
scheme to the other

618
00:25:32,720 --> 00:25:33,840
however

619
00:25:33,840 --> 00:25:37,120
in practice bgv is faster while bfe is

620
00:25:37,120 --> 00:25:39,039
simpler to use since it does not require

621
00:25:39,039 --> 00:25:42,480
to handle the noise growth dynamically

622
00:25:42,480 --> 00:25:45,200
it was also noticed recently then

623
00:25:45,200 --> 00:25:47,760
by kostas lane and player that when the

624
00:25:47,760 --> 00:25:51,120
plaintext modulus t is large vfe has a

625
00:25:51,120 --> 00:25:54,720
more important noise growth than bgv

626
00:25:54,720 --> 00:25:57,039
in this work we've focused on reducing

627
00:25:57,039 --> 00:25:58,799
the gap in practice between the two

628
00:25:58,799 --> 00:26:00,480
schemes

629
00:26:00,480 --> 00:26:03,760
uh first we modified the bfv encoding

630
00:26:03,760 --> 00:26:05,520
which was responsible of the noise

631
00:26:05,520 --> 00:26:07,440
growth observed by kostas lane and

632
00:26:07,440 --> 00:26:09,440
player in such a way that

633
00:26:09,440 --> 00:26:11,039
now both schemes have essentially the

634
00:26:11,039 --> 00:26:13,039
same noise balance

635
00:26:13,039 --> 00:26:14,640
second we

636
00:26:14,640 --> 00:26:16,320
modified

637
00:26:16,320 --> 00:26:18,480
behavior memory multiplication in order

638
00:26:18,480 --> 00:26:21,120
to reduce the size of the second integer

639
00:26:21,120 --> 00:26:22,080
p

640
00:26:22,080 --> 00:26:23,919
which improves the computational

641
00:26:23,919 --> 00:26:26,000
complexity of the procedure

642
00:26:26,000 --> 00:26:27,919
and to improve it further we also

643
00:26:27,919 --> 00:26:29,760
propose a level variant of bfv

644
00:26:29,760 --> 00:26:31,840
multiplication in which the product is

645
00:26:31,840 --> 00:26:34,400
performed internally modulo p prime q

646
00:26:34,400 --> 00:26:35,279
prime

647
00:26:35,279 --> 00:26:39,240
which is smaller than pq

648
00:26:39,600 --> 00:26:42,320
and the last contribution was to propose

649
00:26:42,320 --> 00:26:45,279
the static sort of static variant of bgv

650
00:26:45,279 --> 00:26:47,120
where everything is set up at key

651
00:26:47,120 --> 00:26:49,200
generation and we don't need any dynamic

652
00:26:49,200 --> 00:26:51,520
noise estimation

653
00:26:51,520 --> 00:26:53,600
we also proposed some other optimization

654
00:26:53,600 --> 00:26:56,000
for bfv and in particular we improved

655
00:26:56,000 --> 00:26:58,559
the rns decryption procedure of levy

656
00:26:58,559 --> 00:27:01,039
poliakoff and ship

657
00:27:01,039 --> 00:27:02,960
removing the

658
00:27:02,960 --> 00:27:05,039
constraint on the module on the size of

659
00:27:05,039 --> 00:27:07,600
the modularity

660
00:27:07,600 --> 00:27:09,919
so overall if you look at the

661
00:27:09,919 --> 00:27:11,919
performance of the different

662
00:27:11,919 --> 00:27:14,240
scheme we studied

663
00:27:14,240 --> 00:27:15,440
you

664
00:27:15,440 --> 00:27:17,440
notice that the

665
00:27:17,440 --> 00:27:20,640
our new variant of bgv the blue line

666
00:27:20,640 --> 00:27:21,760
is

667
00:27:21,760 --> 00:27:25,760
faster than the original bfe the purple

668
00:27:25,760 --> 00:27:28,640
one and the level variant of bfv the red

669
00:27:28,640 --> 00:27:32,720
line mimic the behavior of bgv

670
00:27:32,720 --> 00:27:35,440
the most surprising point on this

671
00:27:35,440 --> 00:27:38,000
graphics is that our variance of bgv

672
00:27:38,000 --> 00:27:40,399
appears to be smaller

673
00:27:40,399 --> 00:27:42,559
at least for small moduli than

674
00:27:42,559 --> 00:27:45,200
at the first level than bfe

675
00:27:45,200 --> 00:27:47,279
this is actually a side effect of our

676
00:27:47,279 --> 00:27:49,520
implementation since

677
00:27:49,520 --> 00:27:51,200
every modular

678
00:27:51,200 --> 00:27:53,360
well when the size of the modular in bgv

679
00:27:53,360 --> 00:27:55,440
depends on the plaintext modulus so when

680
00:27:55,440 --> 00:27:57,440
the plaintext modulus is small

681
00:27:57,440 --> 00:27:59,520
you have small moduli and you can have

682
00:27:59,520 --> 00:28:00,640
more of them

683
00:28:00,640 --> 00:28:02,399
so when the plaintext modulus is small

684
00:28:02,399 --> 00:28:04,720
we have a lot of moduli and

685
00:28:04,720 --> 00:28:08,000
since each moduli is represented on a

686
00:28:08,000 --> 00:28:09,679
different machine world

687
00:28:09,679 --> 00:28:11,840
and the experiments were run in a single

688
00:28:11,840 --> 00:28:14,000
thread spreading mode

689
00:28:14,000 --> 00:28:16,399
we have to compute a lot of entities uh

690
00:28:16,399 --> 00:28:18,320
sequentially so that's why we have this

691
00:28:18,320 --> 00:28:20,399
gap of performance between the two

692
00:28:20,399 --> 00:28:23,440
schemes but this can be easily overcome

693
00:28:23,440 --> 00:28:25,840
if you choose to trunk the small moduli

694
00:28:25,840 --> 00:28:28,880
together on the same machine well

695
00:28:28,880 --> 00:28:30,559
well that's essentially everything i

696
00:28:30,559 --> 00:28:32,480
wanted to say so thank you for your

697
00:28:32,480 --> 00:28:34,559
attention and i will be happy to answer

698
00:28:34,559 --> 00:28:36,320
your question

699
00:28:36,320 --> 00:28:39,799
if you have some

700
00:28:44,960 --> 00:28:46,399
thank you

701
00:28:46,399 --> 00:28:47,279
so

702
00:28:47,279 --> 00:28:49,919
is there any question or comment from

703
00:28:49,919 --> 00:28:52,919
audience

704
00:29:01,760 --> 00:29:04,480
okay so i have a question so it is very

705
00:29:04,480 --> 00:29:07,039
nice result so i want to know the

706
00:29:07,039 --> 00:29:09,760
difference so now you show the result in

707
00:29:09,760 --> 00:29:12,240
the case of t equal to and t equal to

708
00:29:12,240 --> 00:29:14,399
360 n plus one

709
00:29:14,399 --> 00:29:18,799
so is there any you know good key that

710
00:29:18,799 --> 00:29:22,240
output good result

711
00:29:22,480 --> 00:29:24,240
well the

712
00:29:24,240 --> 00:29:25,440
proper

713
00:29:25,440 --> 00:29:28,000
regarding the performance the

714
00:29:28,000 --> 00:29:30,880
shape of tea does not impact uh

715
00:29:30,880 --> 00:29:32,640
well the shape of it does not impact the

716
00:29:32,640 --> 00:29:33,760
performance

717
00:29:33,760 --> 00:29:34,480
it

718
00:29:34,480 --> 00:29:36,080
it may impact the way you encode the

719
00:29:36,080 --> 00:29:38,480
message but the procedure itself will

720
00:29:38,480 --> 00:29:41,760
only be impacted for bgp by the size of

721
00:29:41,760 --> 00:29:42,640
t

722
00:29:42,640 --> 00:29:44,799
and not by its shape

723
00:29:44,799 --> 00:29:46,240
so

724
00:29:46,240 --> 00:29:47,600
for the performance there is no

725
00:29:47,600 --> 00:29:49,679
particular t that

726
00:29:49,679 --> 00:29:50,399
well

727
00:29:50,399 --> 00:29:52,240
not a particular shape of t that could

728
00:29:52,240 --> 00:29:53,039
be

729
00:29:53,039 --> 00:29:56,159
could result in better performances

730
00:29:56,159 --> 00:29:58,559
okay

731
00:29:59,120 --> 00:30:01,520
thank you

732
00:30:05,039 --> 00:30:07,200
so

733
00:30:07,200 --> 00:30:10,480
is any other question

734
00:30:12,559 --> 00:30:15,039
okay thank you again and let's move to

735
00:30:15,039 --> 00:30:18,600
the next talk

736
00:30:28,399 --> 00:30:31,600
uh can you see the slides

737
00:30:31,600 --> 00:30:33,440
yep

738
00:30:33,440 --> 00:30:35,440
okay i'll start

739
00:30:35,440 --> 00:30:38,000
hi my name is seongwang kim

740
00:30:38,000 --> 00:30:40,159
today i present trend ciphering

741
00:30:40,159 --> 00:30:42,159
framework for approximate homomorphic

742
00:30:42,159 --> 00:30:43,520
encryption

743
00:30:43,520 --> 00:30:46,320
this is a joint work with jihoon jinter

744
00:30:46,320 --> 00:30:49,439
hyung chewie

745
00:30:52,799 --> 00:30:55,600
now let's begin from morph encryption

746
00:30:55,600 --> 00:30:58,000
morph encryption is an encryption scheme

747
00:30:58,000 --> 00:31:00,320
that enables addition and multiplication

748
00:31:00,320 --> 00:31:02,399
over encrypted data

749
00:31:02,399 --> 00:31:04,240
someone might think about partially

750
00:31:04,240 --> 00:31:07,039
homomorphic encryption but when we say

751
00:31:07,039 --> 00:31:10,000
he in this presentation it supports both

752
00:31:10,000 --> 00:31:12,640
addition and multiplication

753
00:31:12,640 --> 00:31:15,360
there are well-known examples of he

754
00:31:15,360 --> 00:31:18,799
fe schemes in the previous slides

755
00:31:18,799 --> 00:31:21,919
for modular ring and skks for complex

756
00:31:21,919 --> 00:31:23,840
reading

757
00:31:23,840 --> 00:31:25,519
recent homomorphic encryption schemes

758
00:31:25,519 --> 00:31:28,159
have two demerits

759
00:31:28,159 --> 00:31:30,320
slow encryption speed and large

760
00:31:30,320 --> 00:31:32,720
ciphertext expansion

761
00:31:32,720 --> 00:31:34,720
as you can see in this table

762
00:31:34,720 --> 00:31:37,120
encryption speed and ciphertex expansion

763
00:31:37,120 --> 00:31:40,879
might be quite an overload

764
00:31:41,840 --> 00:31:44,960
to resolve the merits of hc

765
00:31:44,960 --> 00:31:47,039
lauter at our proposed trend ciphering

766
00:31:47,039 --> 00:31:49,279
framework which is conversion from

767
00:31:49,279 --> 00:31:51,760
symmetric ciphertext to a homomorphic

768
00:31:51,760 --> 00:31:53,279
ciphertext

769
00:31:53,279 --> 00:31:55,760
imagine that a client wants to

770
00:31:55,760 --> 00:31:58,799
delegate computation to a server while

771
00:31:58,799 --> 00:32:01,039
all the data are encrypted

772
00:32:01,039 --> 00:32:02,640
the client sends homomorphically

773
00:32:02,640 --> 00:32:05,919
encrypted symmetry key to server once

774
00:32:05,919 --> 00:32:08,080
and encrypts all the messages with

775
00:32:08,080 --> 00:32:10,240
symmetric cipher

776
00:32:10,240 --> 00:32:12,720
then given symmetric ciphertext the

777
00:32:12,720 --> 00:32:15,519
server evaluates the decryption circuit

778
00:32:15,519 --> 00:32:20,080
to make morphically encrypted messages

779
00:32:20,080 --> 00:32:22,240
using the trend ciphering framework the

780
00:32:22,240 --> 00:32:24,880
client can encrypt fast and get smaller

781
00:32:24,880 --> 00:32:26,799
ciphertext

782
00:32:26,799 --> 00:32:29,440
however for real numbers there have been

783
00:32:29,440 --> 00:32:33,120
no transferring framework

784
00:32:34,480 --> 00:32:36,240
to make a trend ciphering framework for

785
00:32:36,240 --> 00:32:38,240
real numbers we observe some

786
00:32:38,240 --> 00:32:40,960
similarities between ckt and some fb

787
00:32:40,960 --> 00:32:42,480
schemes

788
00:32:42,480 --> 00:32:44,960
the first observation is that ckks and

789
00:32:44,960 --> 00:32:47,039
fv schemes have similar encryption

790
00:32:47,039 --> 00:32:48,399
algorithms

791
00:32:48,399 --> 00:32:50,720
here we wrote down the formula of the

792
00:32:50,720 --> 00:32:54,159
encryption algorithms in both schemes

793
00:32:54,159 --> 00:32:57,039
as you can see they are very similar and

794
00:32:57,039 --> 00:33:00,080
the major difference is the delta

795
00:33:00,080 --> 00:33:03,279
for ckks the delta is scaling vector

796
00:33:03,279 --> 00:33:05,440
which preserves precision

797
00:33:05,440 --> 00:33:07,519
while delta and fv

798
00:33:07,519 --> 00:33:10,480
is a big scalar to make plaintext modulo

799
00:33:10,480 --> 00:33:11,840
t

800
00:33:11,840 --> 00:33:14,559
the second observation is that ckks and

801
00:33:14,559 --> 00:33:15,519
fv

802
00:33:15,519 --> 00:33:18,799
have similar plaintext space

803
00:33:18,799 --> 00:33:21,519
both schemes use a plain text in

804
00:33:21,519 --> 00:33:23,840
polynomial ring zx with bounded

805
00:33:23,840 --> 00:33:26,159
coefficients

806
00:33:26,159 --> 00:33:28,480
in this figure we give a pictorial

807
00:33:28,480 --> 00:33:31,760
description of two skims these bars

808
00:33:31,760 --> 00:33:33,919
stands for coefficients

809
00:33:33,919 --> 00:33:37,279
they are different in the size of delta

810
00:33:37,279 --> 00:33:39,519
we found out that those two schemes can

811
00:33:39,519 --> 00:33:41,760
be converted to each other by

812
00:33:41,760 --> 00:33:44,559
boost wrapping

813
00:33:45,600 --> 00:33:48,159
now we pre we present our tf turn

814
00:33:48,159 --> 00:33:50,399
ciphering framework which is a new

815
00:33:50,399 --> 00:33:53,360
transcife framework for real numbers

816
00:33:53,360 --> 00:33:57,200
rtf means real to finite field

817
00:33:57,200 --> 00:34:00,559
the overall diagram is on the right

818
00:34:00,559 --> 00:34:03,039
the client has a real message m and

819
00:34:03,039 --> 00:34:04,480
convert it to

820
00:34:04,480 --> 00:34:06,880
integers modulo t by scaling and

821
00:34:06,880 --> 00:34:08,239
rounding off

822
00:34:08,239 --> 00:34:10,560
here t should be large enough to

823
00:34:10,560 --> 00:34:14,560
preserve predetermined precision

824
00:34:14,560 --> 00:34:16,960
the client generates key stream from a

825
00:34:16,960 --> 00:34:20,079
non-spaced stream cipher over zt by

826
00:34:20,079 --> 00:34:21,599
adding the key stream to the scaled

827
00:34:21,599 --> 00:34:22,639
message

828
00:34:22,639 --> 00:34:24,800
the client can get a symmetric

829
00:34:24,800 --> 00:34:26,560
ciphertext c

830
00:34:26,560 --> 00:34:29,679
the client needs to send an fe encrypted

831
00:34:29,679 --> 00:34:32,639
symmetry key k to the server

832
00:34:32,639 --> 00:34:35,679
the server roughly speaking transceiver

833
00:34:35,679 --> 00:34:38,879
to fv ciphertext and bootstrap it to a

834
00:34:38,879 --> 00:34:42,239
ckk ciphertext

835
00:34:43,040 --> 00:34:45,520
we also made an age-friendly cypher hera

836
00:34:45,520 --> 00:34:46,879
over zt

837
00:34:46,879 --> 00:34:49,359
to use in the rtf framework

838
00:34:49,359 --> 00:34:52,719
like rasta it is a block cipher-like

839
00:34:52,719 --> 00:34:55,199
stream cipher outputting a vector in

840
00:34:55,199 --> 00:34:58,200
zt16

841
00:34:58,560 --> 00:35:01,119
hera is an sbn with randomized key

842
00:35:01,119 --> 00:35:03,200
schedule on the right this figure

843
00:35:03,200 --> 00:35:05,760
describes the round function of hara

844
00:35:05,760 --> 00:35:09,040
hara is composed of aes like mds matrix

845
00:35:09,040 --> 00:35:10,960
component-wise cube map

846
00:35:10,960 --> 00:35:12,960
randomized key schedule and fixed

847
00:35:12,960 --> 00:35:16,520
constant input

848
00:35:16,560 --> 00:35:18,640
this table shows the recommended number

849
00:35:18,640 --> 00:35:21,520
of rounds with respect to each attack

850
00:35:21,520 --> 00:35:23,760
we analyzed the security of hera against

851
00:35:23,760 --> 00:35:25,839
linear and differential cryptanalysis

852
00:35:25,839 --> 00:35:29,040
linearization interpolation attack

853
00:35:29,040 --> 00:35:32,720
see the attack and gravity basis attack

854
00:35:32,720 --> 00:35:35,520
the number of rounds of hera is the

855
00:35:35,520 --> 00:35:38,880
maximum of each column

856
00:35:39,680 --> 00:35:41,520
as we propose the first train cycling

857
00:35:41,520 --> 00:35:44,000
framework for real numbers there's not

858
00:35:44,000 --> 00:35:46,079
many things to compare

859
00:35:46,079 --> 00:35:50,079
we compare rtf combined with hera to lwe

860
00:35:50,079 --> 00:35:52,000
to rlw conversion

861
00:35:52,000 --> 00:35:55,359
and ckkks only environment

862
00:35:55,359 --> 00:35:58,640
we experiment lwe to rswwe conversion

863
00:35:58,640 --> 00:36:01,440
using open pegasus library in this paper

864
00:36:01,440 --> 00:36:03,440
below

865
00:36:03,440 --> 00:36:05,520
the ckks only environment is

866
00:36:05,520 --> 00:36:08,640
experimented using latico library

867
00:36:08,640 --> 00:36:10,800
the first rtf hera is full batching

868
00:36:10,800 --> 00:36:13,040
instance and the second rtf pair is said

869
00:36:13,040 --> 00:36:16,480
to have the same number of slots as lwe

870
00:36:16,480 --> 00:36:19,280
to rw conversion we emphasize that the

871
00:36:19,280 --> 00:36:20,720
red part

872
00:36:20,720 --> 00:36:22,880
ciphertext size ciphertext expansion

873
00:36:22,880 --> 00:36:25,359
ratio

874
00:36:25,440 --> 00:36:27,359
and the client-side performance is

875
00:36:27,359 --> 00:36:29,599
significantly better than the ckks only

876
00:36:29,599 --> 00:36:31,200
environment

877
00:36:31,200 --> 00:36:34,720
that's it thank you for listening

878
00:36:35,119 --> 00:36:37,200
all right thank you do we have uh

879
00:36:37,200 --> 00:36:40,800
questions from the audience

880
00:36:40,800 --> 00:36:43,200
and i'll do that well while we're

881
00:36:43,200 --> 00:36:44,400
waiting

882
00:36:44,400 --> 00:36:47,440
do you do you have a sense of

883
00:36:47,440 --> 00:36:49,599
what type of circuits you have to be

884
00:36:49,599 --> 00:36:52,079
evaluating for the the client-side

885
00:36:52,079 --> 00:36:54,880
encryption to become the bottleneck

886
00:36:54,880 --> 00:36:55,920
uh

887
00:36:55,920 --> 00:36:57,920
it's it's like

888
00:36:57,920 --> 00:37:00,720
it was uh well known to

889
00:37:00,720 --> 00:37:02,960
multiplication but

890
00:37:02,960 --> 00:37:06,079
i think it was a mattress matrix

891
00:37:06,079 --> 00:37:09,280
multiplication is

892
00:37:09,280 --> 00:37:12,000
harder when matrix is

893
00:37:12,000 --> 00:37:17,359
randomly generated so we fix the matrix

894
00:37:22,400 --> 00:37:24,400
so sorry what do you mean

895
00:37:24,400 --> 00:37:26,480
am i wrong uh

896
00:37:26,480 --> 00:37:28,320
no just what do you mean by you fix the

897
00:37:28,320 --> 00:37:29,440
matrix

898
00:37:29,440 --> 00:37:31,839
ah i mean that

899
00:37:31,839 --> 00:37:32,640
uh

900
00:37:32,640 --> 00:37:35,680
it's well known that there is a

901
00:37:35,680 --> 00:37:38,720
bottleneck for multiplication

902
00:37:38,720 --> 00:37:41,440
so the linear layers are usually

903
00:37:41,440 --> 00:37:42,800
randomized

904
00:37:42,800 --> 00:37:44,880
but we think that

905
00:37:44,880 --> 00:37:45,920
it was

906
00:37:45,920 --> 00:37:48,720
wrong so we

907
00:37:48,720 --> 00:37:52,800
fixed and do not uh generate random

908
00:37:52,800 --> 00:37:54,079
matrixes

909
00:37:54,079 --> 00:37:57,040
for the cipher

910
00:37:58,079 --> 00:37:59,440
good okay

911
00:37:59,440 --> 00:38:03,400
okay thank you very much

912
00:38:07,920 --> 00:38:12,560
okay we'll um move on to the the last

913
00:38:12,560 --> 00:38:16,078
talk of the the session

914
00:38:17,520 --> 00:38:20,160
which is going to be given by uh samuel

915
00:38:20,160 --> 00:38:22,800
the title is improve quote

916
00:38:22,800 --> 00:38:24,560
programmable bootstrapping with larger

917
00:38:24,560 --> 00:38:26,560
precision and efficient arithmetic

918
00:38:26,560 --> 00:38:28,000
circuits for

919
00:38:28,000 --> 00:38:29,599
tfh

920
00:38:29,599 --> 00:38:32,400
and uh say oh sorry not by samuel is not

921
00:38:32,400 --> 00:38:34,800
speaking it's by sean bertis sorry go

922
00:38:34,800 --> 00:38:37,680
ahead tell me ortiz

923
00:38:37,680 --> 00:38:39,440
especially for the execution yeah

924
00:38:39,440 --> 00:38:41,280
smaller small replacement

925
00:38:41,280 --> 00:38:43,280
at the last moment so yeah we'll present

926
00:38:43,280 --> 00:38:44,800
our work which is the untitled improved

927
00:38:44,800 --> 00:38:46,400
programmable strapping with larger

928
00:38:46,400 --> 00:38:48,079
precision and efficient arithmetic

929
00:38:48,079 --> 00:38:50,720
circuits for tfhe this is a joining work

930
00:38:50,720 --> 00:38:51,640
with

931
00:38:51,640 --> 00:38:54,720
uh and simultaneous

932
00:38:54,720 --> 00:38:58,160
so first what is feiichi so fhe is a

933
00:38:58,160 --> 00:39:00,079
cryptographic paradigm which allows us

934
00:39:00,079 --> 00:39:03,280
to compute our unprecedented data so the

935
00:39:03,280 --> 00:39:05,200
idea that in folio movie encryption we

936
00:39:05,200 --> 00:39:06,880
are able to make addition and also

937
00:39:06,880 --> 00:39:09,440
notification over archite data so that

938
00:39:09,440 --> 00:39:11,040
at the end we obtain an encrypted

939
00:39:11,040 --> 00:39:12,560
version of the addition of the plain

940
00:39:12,560 --> 00:39:14,160
text all the multiplication over the

941
00:39:14,160 --> 00:39:16,079
plain text

942
00:39:16,079 --> 00:39:18,160
so this is quite general and we are able

943
00:39:18,160 --> 00:39:20,960
to evaluate almost every circuit on

944
00:39:20,960 --> 00:39:22,880
every possible types of data which might

945
00:39:22,880 --> 00:39:26,720
be its integer or real messages

946
00:39:27,119 --> 00:39:29,680
the thing we have to look on the fhe is

947
00:39:29,680 --> 00:39:31,680
the noise because due to security reason

948
00:39:31,680 --> 00:39:33,839
we have to add noise when encrypting and

949
00:39:33,839 --> 00:39:35,680
the fact is when we are making some

950
00:39:35,680 --> 00:39:38,079
operation this noise will grows so we

951
00:39:38,079 --> 00:39:39,680
have to be sure when evaluating circuit

952
00:39:39,680 --> 00:39:42,400
bits but this noise doesn't get over a

953
00:39:42,400 --> 00:39:44,560
threshold so that the decryption will

954
00:39:44,560 --> 00:39:47,839
give us the correct results

955
00:39:47,839 --> 00:39:50,000
so magically there is a breakthrough in

956
00:39:50,000 --> 00:39:52,800
fhe which is called strapping and it's

957
00:39:52,800 --> 00:39:54,640
quite simplified the

958
00:39:54,640 --> 00:39:56,640
evaluation of circuits since

959
00:39:56,640 --> 00:39:58,560
it allows us to reduce the noise so

960
00:39:58,560 --> 00:40:01,119
bootstrapping takes one cipher text in

961
00:40:01,119 --> 00:40:03,280
as input which is a lw ciphertext in our

962
00:40:03,280 --> 00:40:05,280
case plus a public key which is a

963
00:40:05,280 --> 00:40:07,920
bootstrapping key and so with the

964
00:40:07,920 --> 00:40:09,599
bootstrapping algorithm at the end it

965
00:40:09,599 --> 00:40:11,520
will output the same cipher text with

966
00:40:11,520 --> 00:40:13,680
the noise which has been reduced

967
00:40:13,680 --> 00:40:15,119
in our case we are particularly

968
00:40:15,119 --> 00:40:17,359
interested in the tfh bootstrapping

969
00:40:17,359 --> 00:40:19,359
because it takes another parameters

970
00:40:19,359 --> 00:40:20,800
which is a lookup table so

971
00:40:20,800 --> 00:40:22,960
representation of a discrete function as

972
00:40:22,960 --> 00:40:25,680
a recap table and so as long as we

973
00:40:25,680 --> 00:40:27,280
refresh the noise with the bootstrapping

974
00:40:27,280 --> 00:40:29,760
we'll also be able to evaluate to

975
00:40:29,760 --> 00:40:31,440
evaluate the lookup table

976
00:40:31,440 --> 00:40:33,920
which means that from a ciphertext which

977
00:40:33,920 --> 00:40:35,839
encrypts x at the end of the

978
00:40:35,839 --> 00:40:38,720
bootstrapping we we are able to have the

979
00:40:38,720 --> 00:40:41,359
encryption of l of x and the noise has

980
00:40:41,359 --> 00:40:42,640
been reduced so this is the

981
00:40:42,640 --> 00:40:46,640
particularity of the tfa chip strapping

982
00:40:46,720 --> 00:40:48,400
in the following slides we are referring

983
00:40:48,400 --> 00:40:51,680
to the programmable strapping as the pbs

984
00:40:51,680 --> 00:40:54,480
so uh the pbs has some limitation and in

985
00:40:54,480 --> 00:40:56,880
this contribution we want to overcome

986
00:40:56,880 --> 00:40:59,280
these limitations so the first one is

987
00:40:59,280 --> 00:41:01,599
that during a pbs we only able to

988
00:41:01,599 --> 00:41:03,920
evaluate one function so we propose a

989
00:41:03,920 --> 00:41:06,000
new solution in order to be

990
00:41:06,000 --> 00:41:08,079
able to evaluate more function during

991
00:41:08,079 --> 00:41:09,760
one pbs

992
00:41:09,760 --> 00:41:12,079
the other limitation is about the

993
00:41:12,079 --> 00:41:14,160
requirement that we have in the

994
00:41:14,160 --> 00:41:16,800
programmable strapping so to be able to

995
00:41:16,800 --> 00:41:20,160
correctly evaluate the pbs we we have a

996
00:41:20,160 --> 00:41:22,400
bit of padding which has to be known in

997
00:41:22,400 --> 00:41:24,160
the plain text although i said the

998
00:41:24,160 --> 00:41:26,640
intuition is that we can use only half

999
00:41:26,640 --> 00:41:29,359
on the precision space of the message

1000
00:41:29,359 --> 00:41:31,359
space during the strapping otherwise the

1001
00:41:31,359 --> 00:41:33,200
bootstrap will not be correct

1002
00:41:33,200 --> 00:41:35,440
in order to overcome this limitation i

1003
00:41:35,440 --> 00:41:37,599
will introduce the bfv modification into

1004
00:41:37,599 --> 00:41:39,839
the tfh scheme and we propose two

1005
00:41:39,839 --> 00:41:41,440
versions of an algorithm which is called

1006
00:41:41,440 --> 00:41:43,760
woops for without padding programmable

1007
00:41:43,760 --> 00:41:45,680
strapping

1008
00:41:45,680 --> 00:41:48,000
so first let's have a look on on the pbs

1009
00:41:48,000 --> 00:41:50,160
middle east so without getting into

1010
00:41:50,160 --> 00:41:52,160
details the idea of the pbs main dilutes

1011
00:41:52,160 --> 00:41:54,960
is to trick a little the pbs to have a

1012
00:41:54,960 --> 00:41:57,040
more generalized version which allows us

1013
00:41:57,040 --> 00:41:59,839
to define a new parameters fifa and this

1014
00:41:59,839 --> 00:42:01,760
fitter will give us the possibility to

1015
00:42:01,760 --> 00:42:03,440
evaluate two to the power of theta

1016
00:42:03,440 --> 00:42:05,440
functions on the same input

1017
00:42:05,440 --> 00:42:07,119
which is interesting in this approach is

1018
00:42:07,119 --> 00:42:08,400
that it offered the multiple

1019
00:42:08,400 --> 00:42:10,319
instructions sigil data paradigm to the

1020
00:42:10,319 --> 00:42:13,119
pbs and that the cost is almost because

1021
00:42:13,119 --> 00:42:15,599
of only one pbs the only difference is

1022
00:42:15,599 --> 00:42:17,440
that we have to compute multiple sample

1023
00:42:17,440 --> 00:42:19,280
extracts for as many functions as we

1024
00:42:19,280 --> 00:42:21,200
want to compute but in practice the

1025
00:42:21,200 --> 00:42:25,279
sample extract is almost free

1026
00:42:25,359 --> 00:42:28,480
the second idea is to introduce a new

1027
00:42:28,480 --> 00:42:30,880
operation in tfhe which is the lw

1028
00:42:30,880 --> 00:42:31,920
product

1029
00:42:31,920 --> 00:42:35,200
to do so we start from the lwe product

1030
00:42:35,200 --> 00:42:38,240
of bfv so the idea is to have two rlws

1031
00:42:38,240 --> 00:42:40,800
and to make a computation which is

1032
00:42:40,800 --> 00:42:42,560
more or less a transfer product and

1033
00:42:42,560 --> 00:42:44,960
realization and at the end we obtain the

1034
00:42:44,960 --> 00:42:47,920
product of the two messages as an llw

1035
00:42:47,920 --> 00:42:49,599
so with simple tricks like the key

1036
00:42:49,599 --> 00:42:51,280
switch and sample extract we are able to

1037
00:42:51,280 --> 00:42:54,880
extend this product to lwes

1038
00:42:54,880 --> 00:42:58,560
now the tedious part of including the

1039
00:42:58,560 --> 00:43:01,040
dfv product into tfhe was the noise

1040
00:43:01,040 --> 00:43:02,800
analysis and we have done this noise

1041
00:43:02,800 --> 00:43:04,880
analysis to be sure that it exists

1042
00:43:04,880 --> 00:43:06,960
practice parameter practical parameters

1043
00:43:06,960 --> 00:43:09,200
to do so with the tfh streams since the

1044
00:43:09,200 --> 00:43:11,680
parameters from bfv and tfh are quite

1045
00:43:11,680 --> 00:43:13,839
different

1046
00:43:14,480 --> 00:43:16,079
with this new tool we are now able to

1047
00:43:16,079 --> 00:43:18,319
define the woop abs so the pbs without

1048
00:43:18,319 --> 00:43:19,680
padding bits

1049
00:43:19,680 --> 00:43:21,599
so first we start with of message and we

1050
00:43:21,599 --> 00:43:23,440
want to compute the first pbs will be

1051
00:43:23,440 --> 00:43:26,640
the pbs computing the function l so now

1052
00:43:26,640 --> 00:43:29,200
at the end we obtain plus or minus l of

1053
00:43:29,200 --> 00:43:31,680
m the evaluation and in fact this is why

1054
00:43:31,680 --> 00:43:34,160
we need in the classical pbs

1055
00:43:34,160 --> 00:43:35,920
a padding bit in fact we aren't sure the

1056
00:43:35,920 --> 00:43:37,359
correctness and the correctness isn't

1057
00:43:37,359 --> 00:43:39,359
sure up to the sign so if we remove this

1058
00:43:39,359 --> 00:43:41,440
padding bit at the end we are not sure

1059
00:43:41,440 --> 00:43:42,960
about the sign of the function we are

1060
00:43:42,960 --> 00:43:44,640
computing so at the end we have the

1061
00:43:44,640 --> 00:43:46,800
encryption of plus or minus l of m and

1062
00:43:46,800 --> 00:43:48,960
we don't know this sign

1063
00:43:48,960 --> 00:43:52,000
to counter this we are computing another

1064
00:43:52,000 --> 00:43:53,599
we have to compute another pbs which

1065
00:43:53,599 --> 00:43:55,200
will be the sign

1066
00:43:55,200 --> 00:43:58,079
and so which is interesting is the pbs

1067
00:43:58,079 --> 00:44:00,079
will be compute on the same input

1068
00:44:00,079 --> 00:44:01,839
so in the end we are going to have the

1069
00:44:01,839 --> 00:44:04,560
sign of the bbs but it is also encrypted

1070
00:44:04,560 --> 00:44:06,560
however since it is applied on the same

1071
00:44:06,560 --> 00:44:08,640
input in the end we know that the sign

1072
00:44:08,640 --> 00:44:11,280
will be the same for the two pbs so that

1073
00:44:11,280 --> 00:44:13,520
we are going to have plus l of m and

1074
00:44:13,520 --> 00:44:17,280
plus one or minus l of m and minus one

1075
00:44:17,280 --> 00:44:19,440
and then with the simple information

1076
00:44:19,440 --> 00:44:21,760
this simple observation that f n times 1

1077
00:44:21,760 --> 00:44:24,240
is equal to minus l of m minus time

1078
00:44:24,240 --> 00:44:26,960
minus 1. in the end using the product we

1079
00:44:26,960 --> 00:44:28,640
have just introduced before we are able

1080
00:44:28,640 --> 00:44:31,600
to obtain the correct results of the dbs

1081
00:44:31,600 --> 00:44:33,200
[Music]

1082
00:44:33,200 --> 00:44:35,280
so in conclusion we have seen

1083
00:44:35,280 --> 00:44:37,200
lot in detail that we have the now the

1084
00:44:37,200 --> 00:44:39,599
bf notification to the fhe and this is

1085
00:44:39,599 --> 00:44:42,240
used to compute the um without padding

1086
00:44:42,240 --> 00:44:45,119
pbs and also they are a simple method to

1087
00:44:45,119 --> 00:44:48,079
compute many loots during a single dbs

1088
00:44:48,079 --> 00:44:50,480
in the purpose in the paper there is

1089
00:44:50,480 --> 00:44:52,079
much more result than that

1090
00:44:52,079 --> 00:44:54,480
which are another version of the pbs

1091
00:44:54,480 --> 00:44:56,000
which might be more efficient and many

1092
00:44:56,000 --> 00:44:57,760
many optimization of the two versions of

1093
00:44:57,760 --> 00:45:00,319
the dbses moreover we propose a generic

1094
00:45:00,319 --> 00:45:02,480
type noise analysis which might be seen

1095
00:45:02,480 --> 00:45:05,920
as a tool to generally analyze a new tfh

1096
00:45:05,920 --> 00:45:07,680
operation

1097
00:45:07,680 --> 00:45:09,839
moreover there is a lot of

1098
00:45:09,839 --> 00:45:12,319
applications of this two of these new

1099
00:45:12,319 --> 00:45:14,240
tools which are the generic circuit

1100
00:45:14,240 --> 00:45:16,720
board strapping or large position bds or

1101
00:45:16,720 --> 00:45:18,000
more efficient gate destruction for

1102
00:45:18,000 --> 00:45:20,400
example

1103
00:45:21,040 --> 00:45:23,200
it also raises some open problems more

1104
00:45:23,200 --> 00:45:26,640
for example we want to have a fast and

1105
00:45:26,640 --> 00:45:29,280
quite precise quite precise fast fourier

1106
00:45:29,280 --> 00:45:31,280
transform in order to accelerate and

1107
00:45:31,280 --> 00:45:33,280
reduce the parameter during the

1108
00:45:33,280 --> 00:45:35,760
gfh computations moreover we want to

1109
00:45:35,760 --> 00:45:37,680
reduce the noise growth during the wps

1110
00:45:37,680 --> 00:45:40,480
because it has some cost on the noise

1111
00:45:40,480 --> 00:45:42,240
and lastly we want to improve the key

1112
00:45:42,240 --> 00:45:44,480
switching in order to globally improve

1113
00:45:44,480 --> 00:45:48,560
the performances during the lw products

1114
00:45:48,720 --> 00:45:51,118
thank you

1115
00:45:55,280 --> 00:45:56,240
thank you

1116
00:45:56,240 --> 00:45:58,079
yeah clap

1117
00:45:58,079 --> 00:45:59,200
just

1118
00:45:59,200 --> 00:46:00,400
while we're waiting to see if there's

1119
00:46:00,400 --> 00:46:03,040
any questions i want to thank all all

1120
00:46:03,040 --> 00:46:05,839
the speakers today um five really nice

1121
00:46:05,839 --> 00:46:07,280
talks

1122
00:46:07,280 --> 00:46:08,800
um

1123
00:46:08,800 --> 00:46:09,599
just

1124
00:46:09,599 --> 00:46:11,839
i'll i'll ask kind of a silly question

1125
00:46:11,839 --> 00:46:13,760
is

1126
00:46:13,760 --> 00:46:16,720
is the size of the lut that you're

1127
00:46:16,720 --> 00:46:18,319
evaluating like

1128
00:46:18,319 --> 00:46:20,880
is is there any bound on the complexity

1129
00:46:20,880 --> 00:46:22,800
of the lookup table you're evaluating or

1130
00:46:22,800 --> 00:46:25,119
you can encode an arbitrary function as

1131
00:46:25,119 --> 00:46:28,319
as long as the the plaintext

1132
00:46:28,319 --> 00:46:30,480
like feel or as long as the plain text

1133
00:46:30,480 --> 00:46:32,160
lookup makes sense

1134
00:46:32,160 --> 00:46:33,040
yeah

1135
00:46:33,040 --> 00:46:34,560
you're kind of right in fact the size of

1136
00:46:34,560 --> 00:46:36,079
the lookup table depends on the size of

1137
00:46:36,079 --> 00:46:38,560
the message so the size of lookup level

1138
00:46:38,560 --> 00:46:40,160
will be two to the power the size of the

1139
00:46:40,160 --> 00:46:42,560
message since we have to

1140
00:46:42,560 --> 00:46:45,359
have at least one

1141
00:46:45,359 --> 00:46:47,839
one association for each of the entry of

1142
00:46:47,839 --> 00:46:49,040
the message

1143
00:46:49,040 --> 00:46:50,880
in practice it's much more larger than

1144
00:46:50,880 --> 00:46:52,240
that since we have to make some

1145
00:46:52,240 --> 00:46:53,760
redundancy to be sure that the

1146
00:46:53,760 --> 00:46:55,440
computation of the bbs is correct

1147
00:46:55,440 --> 00:46:57,440
because we have to deal with the error

1148
00:46:57,440 --> 00:47:00,000
so which this is quite dependent from

1149
00:47:00,000 --> 00:47:02,720
the tft parameters

1150
00:47:02,720 --> 00:47:05,520
it just is um

1151
00:47:05,520 --> 00:47:07,440
you didn't mention it but if if you have

1152
00:47:07,440 --> 00:47:08,400
a

1153
00:47:08,400 --> 00:47:10,160
a pac cipher ciphertext

1154
00:47:10,160 --> 00:47:11,920
uh a simdi ciphertext where you have

1155
00:47:11,920 --> 00:47:14,160
multiple message slots

1156
00:47:14,160 --> 00:47:16,640
can you can you apply the techniques

1157
00:47:16,640 --> 00:47:17,920
there as well

1158
00:47:17,920 --> 00:47:19,200
or so

1159
00:47:19,200 --> 00:47:21,599
yeah so but in tfhe

1160
00:47:21,599 --> 00:47:23,760
maybe the most silly way to pack thing

1161
00:47:23,760 --> 00:47:26,559
would be to have an lwe as input

1162
00:47:26,559 --> 00:47:29,359
and so we cannot directly apply this so

1163
00:47:29,359 --> 00:47:30,880
the idea will be first to have sample

1164
00:47:30,880 --> 00:47:33,920
extract to have some lwes and on each lw

1165
00:47:33,920 --> 00:47:37,800
is you have to apply the dbs

1166
00:47:38,880 --> 00:47:41,200
okay

1167
00:47:42,960 --> 00:47:45,359
all right do do we have

1168
00:47:45,359 --> 00:47:48,880
other other questions

1169
00:47:50,559 --> 00:47:53,359
okay let's um thank all the the speakers

1170
00:47:53,359 --> 00:47:55,200
again this uh great session really

1171
00:47:55,200 --> 00:47:56,800
appreciate everybody's time and

1172
00:47:56,800 --> 00:47:59,800
attention

