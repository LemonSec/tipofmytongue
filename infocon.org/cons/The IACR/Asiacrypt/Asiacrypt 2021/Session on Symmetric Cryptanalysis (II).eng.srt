1
00:00:02,240 --> 00:00:03,679
yes

2
00:00:03,679 --> 00:00:07,279
okay thank you so uh welcome to uh

3
00:00:07,279 --> 00:00:10,480
uh session uh crypto analysis two

4
00:00:10,480 --> 00:00:12,080
so uh my name is

5
00:00:12,080 --> 00:00:15,120
mitsudiganoto uh i'm sharing a decision

6
00:00:15,120 --> 00:00:16,640
with christian

7
00:00:16,640 --> 00:00:18,800
so uh

8
00:00:18,800 --> 00:00:21,680
we have five talks and uh we have uh we

9
00:00:21,680 --> 00:00:23,760
will have uh q and a time after each

10
00:00:23,760 --> 00:00:24,880
talk

11
00:00:24,880 --> 00:00:28,240
so uh if you have questions uh in in

12
00:00:28,240 --> 00:00:31,039
during the talk so please use a jury or

13
00:00:31,039 --> 00:00:32,800
chat box

14
00:00:32,800 --> 00:00:34,719
okay so uh the

15
00:00:34,719 --> 00:00:37,600
first talk is

16
00:00:37,600 --> 00:00:39,920
convexity of division property

17
00:00:39,920 --> 00:00:41,440
transitions

18
00:00:41,440 --> 00:00:45,039
theory algorithm and compact models are

19
00:00:45,039 --> 00:00:47,760
by alexey duvenko

20
00:00:47,760 --> 00:00:51,360
he will give a talk okay

21
00:00:51,360 --> 00:00:53,600
thank you for for the introduction i'll

22
00:00:53,600 --> 00:00:55,039
just

23
00:00:55,039 --> 00:00:58,399
share my screen

24
00:00:58,399 --> 00:00:59,199
so

25
00:00:59,199 --> 00:01:02,399
yeah let me start my talk

26
00:01:05,199 --> 00:01:06,960
first i would like to provide a very

27
00:01:06,960 --> 00:01:09,600
quick high level overview of the work

28
00:01:09,600 --> 00:01:11,040
the work study is division property

29
00:01:11,040 --> 00:01:12,560
which is equipped analysis technique for

30
00:01:12,560 --> 00:01:14,000
symmetric ciphers

31
00:01:14,000 --> 00:01:15,280
there are many variants of division

32
00:01:15,280 --> 00:01:16,960
property and this work focuses on the

33
00:01:16,960 --> 00:01:18,720
earliest and the most widely applicable

34
00:01:18,720 --> 00:01:19,520
one

35
00:01:19,520 --> 00:01:21,600
bit based two subset division property

36
00:01:21,600 --> 00:01:23,360
also called traditional or conventional

37
00:01:23,360 --> 00:01:25,840
division property it was introduced by

38
00:01:25,840 --> 00:01:28,960
todo at eurotip 2015.

39
00:01:28,960 --> 00:01:30,799
the contributions of our work include

40
00:01:30,799 --> 00:01:32,799
new theoretical insights such as close

41
00:01:32,799 --> 00:01:34,640
links of division property with graphs

42
00:01:34,640 --> 00:01:36,479
or analyzed functions

43
00:01:36,479 --> 00:01:38,079
and a new compact representation

44
00:01:38,079 --> 00:01:40,320
suitable for modeling larger s-boxes by

45
00:01:40,320 --> 00:01:42,479
sat solvers

46
00:01:42,479 --> 00:01:44,159
in addition we describe new algorithms

47
00:01:44,159 --> 00:01:46,079
for computing propagation tables and

48
00:01:46,079 --> 00:01:48,240
compact representations in quadratic

49
00:01:48,240 --> 00:01:50,159
time improving previous cubic time

50
00:01:50,159 --> 00:01:52,240
approaches

51
00:01:52,240 --> 00:01:53,920
as a proof of concept we studied the

52
00:01:53,920 --> 00:01:56,560
super xbox model of led which was

53
00:01:56,560 --> 00:01:59,119
impractical by previous methods and was

54
00:01:59,119 --> 00:02:00,880
challenged in recent work of direbas and

55
00:02:00,880 --> 00:02:02,000


56
00:02:02,000 --> 00:02:03,600
in this short presentation i'll focus

57
00:02:03,600 --> 00:02:07,119
mainly on the compact representation

58
00:02:07,119 --> 00:02:08,639
now i will briefly introduce division

59
00:02:08,639 --> 00:02:09,758
property

60
00:02:09,758 --> 00:02:11,520
consider a cryptographic primitive built

61
00:02:11,520 --> 00:02:13,120
from iterations of a simple round

62
00:02:13,120 --> 00:02:14,560
function

63
00:02:14,560 --> 00:02:16,319
in integral cryptanalysis we want to

64
00:02:16,319 --> 00:02:18,160
know whether the multivariate polynomial

65
00:02:18,160 --> 00:02:20,560
expression of an output bit may contain

66
00:02:20,560 --> 00:02:24,560
a chosen normal of the input variables

67
00:02:24,640 --> 00:02:26,239
if the presence of the monomer does not

68
00:02:26,239 --> 00:02:28,319
depend on the involved secret keys we

69
00:02:28,319 --> 00:02:29,840
obtain a distinguisher from a random

70
00:02:29,840 --> 00:02:31,680
function which can be used to attack the

71
00:02:31,680 --> 00:02:33,200
primitive

72
00:02:33,200 --> 00:02:34,720
the core idea of division property is

73
00:02:34,720 --> 00:02:38,160
very simple i consider this example

74
00:02:38,160 --> 00:02:40,640
in order for y 0 as a function of x to

75
00:02:40,640 --> 00:02:43,440
contain the monomial x 0 x 1 x 2

76
00:02:43,440 --> 00:02:46,319
there must exist a sequence of monomials

77
00:02:46,319 --> 00:02:48,480
in each intermediate state such that at

78
00:02:48,480 --> 00:02:50,480
each step the product of functions

79
00:02:50,480 --> 00:02:52,720
defined by the output monomer contains

80
00:02:52,720 --> 00:02:54,560
the input monomer

81
00:02:54,560 --> 00:02:56,160
such a sequence is called a division

82
00:02:56,160 --> 00:02:58,560
trail and they are searched using sat or

83
00:02:58,560 --> 00:03:02,720
smt solvers or mlp optimizers

84
00:03:03,599 --> 00:03:05,360
to handle the secret keys being sold

85
00:03:05,360 --> 00:03:06,959
between the round functions in a simple

86
00:03:06,959 --> 00:03:07,840
way

87
00:03:07,840 --> 00:03:09,840
traditional division property relaxes

88
00:03:09,840 --> 00:03:12,319
the propagation rule to allow smaller

89
00:03:12,319 --> 00:03:15,040
products of output bits to contain

90
00:03:15,040 --> 00:03:18,400
larger products of input variables at

91
00:03:18,400 --> 00:03:19,360
each step

92
00:03:19,360 --> 00:03:21,680
then we can ignore the secret keys

93
00:03:21,680 --> 00:03:23,599
for example we consider this transition

94
00:03:23,599 --> 00:03:24,640
valid

95
00:03:24,640 --> 00:03:27,120
if say that one instead of that one the

96
00:03:27,120 --> 00:03:31,040
three contains monomial x0 x1 x2 x5

97
00:03:31,040 --> 00:03:33,680
instead of just x0 x1 x2

98
00:03:33,680 --> 00:03:35,280
and here we don't consider we consider

99
00:03:35,280 --> 00:03:36,959
the function f0 itself and note the

100
00:03:36,959 --> 00:03:39,599
secret key

101
00:03:39,760 --> 00:03:42,480
in order to use sat snt or mlp solvers

102
00:03:42,480 --> 00:03:44,560
to find trails we need to encode

103
00:03:44,560 --> 00:03:47,280
possible steps of the trail

104
00:03:47,280 --> 00:03:49,040
the classic approach is to compute full

105
00:03:49,040 --> 00:03:51,120
propagation table where for each input

106
00:03:51,120 --> 00:03:53,280
vector we list all possible output

107
00:03:53,280 --> 00:03:55,519
vectors and then to encode this table in

108
00:03:55,519 --> 00:03:56,799
some way

109
00:03:56,799 --> 00:03:58,319
because of the monotonicity of division

110
00:03:58,319 --> 00:04:01,360
property which is exactly due to this

111
00:04:01,360 --> 00:04:03,360
ability to remove or add variables from

112
00:04:03,360 --> 00:04:05,519
anomales

113
00:04:05,519 --> 00:04:07,280
for possible outputs we consider only

114
00:04:07,280 --> 00:04:08,720
minimal vectors

115
00:04:08,720 --> 00:04:11,200
or also called reduced vectors

116
00:04:11,200 --> 00:04:12,879
this significantly reduces the table

117
00:04:12,879 --> 00:04:14,959
size but we are still limited by the

118
00:04:14,959 --> 00:04:18,560
exponential number of inputs

119
00:04:18,880 --> 00:04:20,798
and here is the key observation of our

120
00:04:20,798 --> 00:04:21,680
work

121
00:04:21,680 --> 00:04:23,440
if you consider the full set of reduced

122
00:04:23,440 --> 00:04:24,800
transitions

123
00:04:24,800 --> 00:04:27,520
that is pairs of input output vectors of

124
00:04:27,520 --> 00:04:31,040
valid transitions with minimal outputs

125
00:04:31,040 --> 00:04:32,960
we can show that this set is convex

126
00:04:32,960 --> 00:04:35,360
meaning that it has two monotone bounds

127
00:04:35,360 --> 00:04:38,720
the upper bound and the lower bound

128
00:04:38,720 --> 00:04:40,960
this is explained by this ability to add

129
00:04:40,960 --> 00:04:43,919
or remove variables from animals

130
00:04:43,919 --> 00:04:46,080
and what's important about convexity is

131
00:04:46,080 --> 00:04:47,919
that it lends itself nicely to cnf

132
00:04:47,919 --> 00:04:50,639
encodings to be used in a sat solver

133
00:04:50,639 --> 00:04:52,639
more precisely the cnf formulas have

134
00:04:52,639 --> 00:04:54,840
size depending on size of these two

135
00:04:54,840 --> 00:04:56,479
boundaries

136
00:04:56,479 --> 00:04:58,320
rather on the sides of the of the full

137
00:04:58,320 --> 00:05:00,400
set itself

138
00:05:00,400 --> 00:05:01,680
while it is not guaranteed that their

139
00:05:01,680 --> 00:05:03,520
presentation is always small

140
00:05:03,520 --> 00:05:05,280
it is usually much smaller than the full

141
00:05:05,280 --> 00:05:07,039
table

142
00:05:07,039 --> 00:05:09,199
here are some examples on model sizes of

143
00:05:09,199 --> 00:05:12,240
sums boxes obtained using our technique

144
00:05:12,240 --> 00:05:14,800
on medium-sized s-boxes such as the iss

145
00:05:14,800 --> 00:05:17,280
box we can see that our method produces

146
00:05:17,280 --> 00:05:19,199
a bit more constraints than the optimal

147
00:05:19,199 --> 00:05:20,320
encoding

148
00:05:20,320 --> 00:05:22,000
the problem with the optimal encoding is

149
00:05:22,000 --> 00:05:24,320
that it doesn't scale well and quickly

150
00:05:24,320 --> 00:05:26,320
becomes invisible to obtain for larger

151
00:05:26,320 --> 00:05:28,400
s-boxes

152
00:05:28,400 --> 00:05:31,440
we can model 16-bit supers boxes with

153
00:05:31,440 --> 00:05:32,880
variant success

154
00:05:32,880 --> 00:05:35,520
for example leds super sbox can be

155
00:05:35,520 --> 00:05:37,440
modeled by about

156
00:05:37,440 --> 00:05:39,600
three hundred thousand constraints

157
00:05:39,600 --> 00:05:40,800
while weaker

158
00:05:40,800 --> 00:05:43,120
midori's super s box requires two

159
00:05:43,120 --> 00:05:44,320
millions

160
00:05:44,320 --> 00:05:46,240
for modern solvers it may be still in

161
00:05:46,240 --> 00:05:48,800
the feasible range but it really depends

162
00:05:48,800 --> 00:05:50,720
on the exact setup

163
00:05:50,720 --> 00:05:52,960
an interesting case is the heavy linear

164
00:05:52,960 --> 00:05:54,400
layer of led

165
00:05:54,400 --> 00:05:55,759
which is based on

166
00:05:55,759 --> 00:05:57,680
an mds matrix

167
00:05:57,680 --> 00:05:59,600
it was the source of problems in the

168
00:05:59,600 --> 00:06:01,440
work by derbys and

169
00:06:01,440 --> 00:06:03,280
using our method it can be modeled by

170
00:06:03,280 --> 00:06:07,318
just 30 000 constraints

171
00:06:07,520 --> 00:06:09,440
to conclude please look for more results

172
00:06:09,440 --> 00:06:11,120
in the paper and check the court

173
00:06:11,120 --> 00:06:12,960
repository which has convenient

174
00:06:12,960 --> 00:06:14,319
implementations of the described

175
00:06:14,319 --> 00:06:15,360
techniques

176
00:06:15,360 --> 00:06:17,280
and please look at the

177
00:06:17,280 --> 00:06:20,240
interesting problems left and so this

178
00:06:20,240 --> 00:06:21,600
concludes my talk

179
00:06:21,600 --> 00:06:23,360
thank you and i'll be happy to answer

180
00:06:23,360 --> 00:06:25,919
your questions

181
00:06:26,160 --> 00:06:28,560
hey thank you very much for your talk uh

182
00:06:28,560 --> 00:06:30,400
so they have do you have any questions

183
00:06:30,400 --> 00:06:32,960
or comments

184
00:06:32,960 --> 00:06:35,840
so if you have questions uh please use

185
00:06:35,840 --> 00:06:38,639
uh zurich or chatbox

186
00:06:38,639 --> 00:06:40,240
or uh

187
00:06:40,240 --> 00:06:43,680
raise your hand virtually and uh

188
00:06:43,680 --> 00:06:44,880
uh

189
00:06:44,880 --> 00:06:48,160
by making yourself

190
00:06:48,160 --> 00:06:50,560
so maybe i'll start with a question in

191
00:06:50,560 --> 00:06:53,199
the longer version of of your talk the

192
00:06:53,199 --> 00:06:54,639
recorded one right

193
00:06:54,639 --> 00:06:56,960
and i think that was slide 5 here and

194
00:06:56,960 --> 00:06:57,919
slide

195
00:06:57,919 --> 00:07:00,880
12 in this yeah right so over there you

196
00:07:00,880 --> 00:07:02,720
said something like more complex

197
00:07:02,720 --> 00:07:04,720
transition structure

198
00:07:04,720 --> 00:07:07,280
may somehow indicate algebraic weakness

199
00:07:07,280 --> 00:07:10,160
of the xbox right is is this some uh did

200
00:07:10,160 --> 00:07:11,520
i get it right

201
00:07:11,520 --> 00:07:12,880
do you think that this could be used as

202
00:07:12,880 --> 00:07:14,720
some sort of a you know quick

203
00:07:14,720 --> 00:07:17,280
test that you know i have this new way

204
00:07:17,280 --> 00:07:19,120
new icebox and then i can run this and

205
00:07:19,120 --> 00:07:21,759
see oh this looks much bigger than i

206
00:07:21,759 --> 00:07:23,759
would expect and then perhaps there is

207
00:07:23,759 --> 00:07:25,360
something deeper there and i can you

208
00:07:25,360 --> 00:07:29,560
know it's worth studying it

209
00:07:30,000 --> 00:07:33,520
yes it can be but it's not

210
00:07:33,520 --> 00:07:37,520
it's not very dark for example we can uh

211
00:07:37,840 --> 00:07:41,120
we can look at a a leds

212
00:07:41,120 --> 00:07:44,080
a linear layer so it's linear so it's

213
00:07:44,080 --> 00:07:46,800
it's not algebraically it has degree one

214
00:07:46,800 --> 00:07:48,800
and it has very uh

215
00:07:48,800 --> 00:07:51,440
compact representation here

216
00:07:51,440 --> 00:07:53,360
so in this way you cannot say it's very

217
00:07:53,360 --> 00:07:56,560
weak well it's weak because it's linear

218
00:07:56,560 --> 00:07:59,039
but if if you if you will say

219
00:07:59,039 --> 00:08:01,199
have some degree uh

220
00:08:01,199 --> 00:08:04,080
like you have uh

221
00:08:04,080 --> 00:08:05,520
yeah for example if you compare is and

222
00:08:05,520 --> 00:08:08,240
this js boxes you can see that uh

223
00:08:08,240 --> 00:08:11,120
iss box is much uh has much more compact

224
00:08:11,120 --> 00:08:12,960
representation than misty and we know

225
00:08:12,960 --> 00:08:15,039
that misty has this

226
00:08:15,039 --> 00:08:16,879
weaknesses that allowed uh integral

227
00:08:16,879 --> 00:08:19,199
attack

228
00:08:20,479 --> 00:08:23,120
all right thanks

229
00:08:23,120 --> 00:08:26,879
thank you so uh

230
00:08:26,879 --> 00:08:28,560
if you have another

231
00:08:28,560 --> 00:08:31,520
questions or comments

232
00:08:37,360 --> 00:08:39,599
you can also unmute yourself and ask the

233
00:08:39,599 --> 00:08:43,959
question directly if you prefer

234
00:08:59,920 --> 00:09:02,160
okay uh thank you very much for uh for

235
00:09:02,160 --> 00:09:03,360
your talk

236
00:09:03,360 --> 00:09:05,600
so uh let me do the second vlog thanks

237
00:09:05,600 --> 00:09:06,480
so

238
00:09:06,480 --> 00:09:10,320
yeah thank you the second talk is uh uh

239
00:09:10,320 --> 00:09:12,480
strong and tight security

240
00:09:12,480 --> 00:09:14,560
security guarantees against integral

241
00:09:14,560 --> 00:09:17,440
distinguishers uh the authors are phil

242
00:09:17,440 --> 00:09:20,560
heborn uh baptist alumn

243
00:09:20,560 --> 00:09:22,800
uh

244
00:09:28,640 --> 00:09:30,800
thanks for the introduction so yeah

245
00:09:30,800 --> 00:09:32,399
today we talk about

246
00:09:32,399 --> 00:09:33,839
strong attack security guarantees that

247
00:09:33,839 --> 00:09:36,640
can integral distinguishes

248
00:09:36,640 --> 00:09:38,800
so

249
00:09:39,440 --> 00:09:40,800
the main topic

250
00:09:40,800 --> 00:09:42,720
is what integral attacks on block

251
00:09:42,720 --> 00:09:44,160
ciphers so

252
00:09:44,160 --> 00:09:45,920
a very generic way of thinking this

253
00:09:45,920 --> 00:09:48,160
attacks is that we need to find the set

254
00:09:48,160 --> 00:09:51,200
aim of plaintext such that for any key

255
00:09:51,200 --> 00:09:52,800
if we the sum of the corresponding

256
00:09:52,800 --> 00:09:54,640
ciphertext is always equal to zero which

257
00:09:54,640 --> 00:09:56,640
point one and no matter the value of the

258
00:09:56,640 --> 00:09:59,360
key so this is uh something we

259
00:09:59,360 --> 00:10:01,920
would not want for an id block cipher so

260
00:10:01,920 --> 00:10:03,440
this leads to a distinguisher which

261
00:10:03,440 --> 00:10:05,760
leads to an attack and so we would like

262
00:10:05,760 --> 00:10:08,079
to be able to give arguments

263
00:10:08,079 --> 00:10:10,560
on whether or not given block cipher is

264
00:10:10,560 --> 00:10:13,360
secure against these attacks

265
00:10:13,360 --> 00:10:14,720
and

266
00:10:14,720 --> 00:10:17,120
if you follow the generic id and that

267
00:10:17,120 --> 00:10:18,560
would mean showing that there is no such

268
00:10:18,560 --> 00:10:20,640
set m of plaintext

269
00:10:20,640 --> 00:10:23,279
so this looks a bit complicated but if

270
00:10:23,279 --> 00:10:23,950
we take a

271
00:10:23,950 --> 00:10:25,600
[Music]

272
00:10:25,600 --> 00:10:27,519
closer look at the block cipher we can

273
00:10:27,519 --> 00:10:29,200
see how we can eliminate at least some

274
00:10:29,200 --> 00:10:31,600
integral attacks for now so let's take a

275
00:10:31,600 --> 00:10:34,240
look at the inf for block cipher so it's

276
00:10:34,240 --> 00:10:37,600
a way to represent block cipher as a

277
00:10:37,600 --> 00:10:39,680
key boolean function so as the sum of

278
00:10:39,680 --> 00:10:42,000
some vector of polynomials p u which

279
00:10:42,000 --> 00:10:43,680
depends on the key times some monomial

280
00:10:43,680 --> 00:10:45,839
texture and using this a and f we can

281
00:10:45,839 --> 00:10:48,240
define the algebraic degree which is a

282
00:10:48,240 --> 00:10:51,279
maximum of uh a all amid weight of u so

283
00:10:51,279 --> 00:10:52,959
that p u is not zero basically just the

284
00:10:52,959 --> 00:10:55,200
highest degree of any monomial x2 in the

285
00:10:55,200 --> 00:10:56,240
anf

286
00:10:56,240 --> 00:10:57,440
and the reason why this degree is

287
00:10:57,440 --> 00:10:58,880
interesting is that

288
00:10:58,880 --> 00:11:00,880
um it's well known that if the degree is

289
00:11:00,880 --> 00:11:01,920
too low

290
00:11:01,920 --> 00:11:03,760
then we get you know we get integral

291
00:11:03,760 --> 00:11:05,200
attacks

292
00:11:05,200 --> 00:11:07,360
and so the first step to show that we

293
00:11:07,360 --> 00:11:08,720
have no integral attacks would be to

294
00:11:08,720 --> 00:11:10,800
show that the degree is high enough

295
00:11:10,800 --> 00:11:13,200
and it just requires to keep lower bound

296
00:11:13,200 --> 00:11:15,440
on this degree and when we did that last

297
00:11:15,440 --> 00:11:17,120
year at azure grid with the same outer

298
00:11:17,120 --> 00:11:18,880
we gave for the first time some more

299
00:11:18,880 --> 00:11:20,160
lower bound of the degree of block

300
00:11:20,160 --> 00:11:21,279
ciphers

301
00:11:21,279 --> 00:11:23,040
and

302
00:11:23,040 --> 00:11:24,720
the way we did this in a very short

303
00:11:24,720 --> 00:11:27,200
summary is that if we expand

304
00:11:27,200 --> 00:11:30,160
the key polynomials p u as some the sum

305
00:11:30,160 --> 00:11:32,800
of some lambda u v times k v

306
00:11:32,800 --> 00:11:34,800
you can show that this block cipher is

307
00:11:34,800 --> 00:11:36,959
of degree d if you can find the u if i

308
00:11:36,959 --> 00:11:39,440
mean weight g so that at least one

309
00:11:39,440 --> 00:11:41,200
lambda u v is non-zero which means that

310
00:11:41,200 --> 00:11:43,600
there is this monomial like you of the

311
00:11:43,600 --> 00:11:44,880
gradient so

312
00:11:44,880 --> 00:11:47,120
cipher is at least of degree and what we

313
00:11:47,120 --> 00:11:49,600
did in this paper last year was to

314
00:11:49,600 --> 00:11:51,920
essentially show how

315
00:11:51,920 --> 00:11:53,920
we can choose which lambda uf to focus

316
00:11:53,920 --> 00:11:55,680
on so that we can actually compute this

317
00:11:55,680 --> 00:11:58,240
from the uv in particular time and just

318
00:11:58,240 --> 00:11:59,680
um showing some lower bound of the

319
00:11:59,680 --> 00:12:01,360
artery degree as well as some stronger

320
00:12:01,360 --> 00:12:03,200
properties

321
00:12:03,200 --> 00:12:05,200
however we still have some issues

322
00:12:05,200 --> 00:12:07,440
because it only proves resistance again

323
00:12:07,440 --> 00:12:09,600
the subset of integral attack not actual

324
00:12:09,600 --> 00:12:10,639
resistance

325
00:12:10,639 --> 00:12:12,639
and in addition to c being quite

326
00:12:12,639 --> 00:12:15,600
expensive in terms of computations um

327
00:12:15,600 --> 00:12:17,440
the bounds we gave were also only true

328
00:12:17,440 --> 00:12:19,600
for a given number of rounds without any

329
00:12:19,600 --> 00:12:21,279
guarantees on moran which is a bit

330
00:12:21,279 --> 00:12:23,200
disappointing when you think about bulk

331
00:12:23,200 --> 00:12:24,800
ciphers

332
00:12:24,800 --> 00:12:27,360
so in our purpose this year we addressed

333
00:12:27,360 --> 00:12:29,120
these few problems and today i will only

334
00:12:29,120 --> 00:12:31,040
focus on the first one and i encourage

335
00:12:31,040 --> 00:12:33,760
you to either watch a full video or read

336
00:12:33,760 --> 00:12:36,240
the paper for more details

337
00:12:36,240 --> 00:12:36,959
so

338
00:12:36,959 --> 00:12:39,279
the main observation uh we made is that

339
00:12:39,279 --> 00:12:41,360
if there is an integral distinguisher so

340
00:12:41,360 --> 00:12:43,440
if there is a set m so that the sum of

341
00:12:43,440 --> 00:12:45,519
ciphertex is equal to zero it actually

342
00:12:45,519 --> 00:12:46,800
means that the key

343
00:12:46,800 --> 00:12:50,800
polynomials pu are linear dependent so

344
00:12:50,800 --> 00:12:52,399
if we want to show security we need to

345
00:12:52,399 --> 00:12:54,480
show that all of these two to the n

346
00:12:54,480 --> 00:12:57,120
functions p u are linear independent

347
00:12:57,120 --> 00:12:59,360
which when n is at least 64 for more

348
00:12:59,360 --> 00:13:02,399
than block cipher seems very hard to do

349
00:13:02,399 --> 00:13:03,200
so

350
00:13:03,200 --> 00:13:05,920
what we showed is that under a few

351
00:13:05,920 --> 00:13:08,320
assumptions so having independent round

352
00:13:08,320 --> 00:13:10,160
keys like in our paper last year as well

353
00:13:10,160 --> 00:13:12,560
as adding a whitening key we can reduce

354
00:13:12,560 --> 00:13:16,079
the problem from two to the n um

355
00:13:16,079 --> 00:13:18,399
linear independent polynomial only and

356
00:13:18,399 --> 00:13:21,120
squared polynomials where

357
00:13:21,120 --> 00:13:23,839
just uh some specific polynomial uh

358
00:13:23,839 --> 00:13:26,000
polynomials speak for um some specific

359
00:13:26,000 --> 00:13:30,000
value of the um vector so

360
00:13:30,000 --> 00:13:31,760
the vectors e i

361
00:13:31,760 --> 00:13:33,360
uh which are equal to one everywhere

362
00:13:33,360 --> 00:13:35,120
except in one coordinate

363
00:13:35,120 --> 00:13:36,079
and

364
00:13:36,079 --> 00:13:37,600
so now we only need to show that n

365
00:13:37,600 --> 00:13:38,959
square polynomials are linearly

366
00:13:38,959 --> 00:13:40,800
independent which means we only need to

367
00:13:40,800 --> 00:13:43,839
compute about n squared coefficient um

368
00:13:43,839 --> 00:13:46,480
lambda for each polynomial

369
00:13:46,480 --> 00:13:47,760
so

370
00:13:47,760 --> 00:13:49,760
in short assuming independent round keys

371
00:13:49,760 --> 00:13:51,440
for even block cipher we only need to

372
00:13:51,440 --> 00:13:53,680
compute about n to the four well chosen

373
00:13:53,680 --> 00:13:56,320
coefficients from the uv and we want

374
00:13:56,320 --> 00:13:58,399
by doing so we want to show that these

375
00:13:58,399 --> 00:14:00,639
polynomials are independent and if we

376
00:14:00,639 --> 00:14:03,600
are able to do so then by um adding a

377
00:14:03,600 --> 00:14:06,000
whitening key to the block cipher uh

378
00:14:06,000 --> 00:14:07,839
this augmented block cipher is actually

379
00:14:07,839 --> 00:14:10,800
resistant against integral attacks

380
00:14:10,800 --> 00:14:13,360
and so this end to the four

381
00:14:13,360 --> 00:14:14,880
is

382
00:14:14,880 --> 00:14:16,480
quite a bit more work compared to our

383
00:14:16,480 --> 00:14:18,560
work last year so we had to improve a

384
00:14:18,560 --> 00:14:20,560
bit of compensational side by improving

385
00:14:20,560 --> 00:14:22,079
heuristics we used

386
00:14:22,079 --> 00:14:24,399
and we also showed that if it's integral

387
00:14:24,399 --> 00:14:26,480
resistant on a given number of funds

388
00:14:26,480 --> 00:14:27,839
it's also resistant for any higher

389
00:14:27,839 --> 00:14:30,320
number of funds um it's not true in

390
00:14:30,320 --> 00:14:32,399
general for algebraic degree and minimum

391
00:14:32,399 --> 00:14:35,040
degree but in the paper we showed when

392
00:14:35,040 --> 00:14:37,360
this is actually the case

393
00:14:37,360 --> 00:14:39,839
to give an overview of the results

394
00:14:39,839 --> 00:14:42,320
here are the block cipher we studied and

395
00:14:42,320 --> 00:14:44,399
in red you can show the cases where the

396
00:14:44,399 --> 00:14:45,680
bounds are attacked meaning so the

397
00:14:45,680 --> 00:14:46,800
number of fronts we proved to be

398
00:14:46,800 --> 00:14:49,839
resistant uh matches um n plus one when

399
00:14:49,839 --> 00:14:51,360
n is the highest number of funds we can

400
00:14:51,360 --> 00:14:53,199
attack with in the graphics and in the

401
00:14:53,199 --> 00:14:54,800
case of kitchen present it doesn't mean

402
00:14:54,800 --> 00:14:57,199
that for example we can find an attack

403
00:14:57,199 --> 00:14:58,800
on eleven rounds of gate it means that

404
00:14:58,800 --> 00:15:01,519
computer center computationally

405
00:15:01,519 --> 00:15:03,600
we were not able to show that eleven

406
00:15:03,600 --> 00:15:05,680
rounds is resistant or not so there's

407
00:15:05,680 --> 00:15:07,839
still some margin to improve here and

408
00:15:07,839 --> 00:15:10,480
overall we would like to well

409
00:15:10,480 --> 00:15:12,560
improve this uh method uh making it

410
00:15:12,560 --> 00:15:13,600
faster

411
00:15:13,600 --> 00:15:15,279
improves heuristic and better understand

412
00:15:15,279 --> 00:15:17,440
these heuristics and also making making

413
00:15:17,440 --> 00:15:19,519
it more usable and more versatile

414
00:15:19,519 --> 00:15:21,600
because uh for now it still requires a

415
00:15:21,600 --> 00:15:24,000
bit of tweaking for each block life

416
00:15:24,000 --> 00:15:25,600
so thank you for attention and if you

417
00:15:25,600 --> 00:15:28,320
have any questions

418
00:15:28,320 --> 00:15:29,440
okay

419
00:15:29,440 --> 00:15:31,839
thank you very much very talk uh so uh

420
00:15:31,839 --> 00:15:35,759
we have a question from in the uh

421
00:15:35,759 --> 00:15:38,639
checkbox so do you have some ideas about

422
00:15:38,639 --> 00:15:40,959
how to process the permutation based

423
00:15:40,959 --> 00:15:43,600
cyprus which loads the keys at the

424
00:15:43,600 --> 00:15:46,000
beginning

425
00:15:47,759 --> 00:15:49,839
it's also part of the future work it's

426
00:15:49,839 --> 00:15:52,000
very hard with the current framework

427
00:15:52,000 --> 00:15:54,000
because

428
00:15:54,000 --> 00:15:55,710
we rely on having some

429
00:15:55,710 --> 00:15:56,959
[Music]

430
00:15:56,959 --> 00:15:59,519
so this hypothesis of having independent

431
00:15:59,519 --> 00:16:02,720
home keys allow us to

432
00:16:03,279 --> 00:16:05,519
simplify the problem with because

433
00:16:05,519 --> 00:16:08,079
computing system uvs comes down to

434
00:16:08,079 --> 00:16:09,600
counting the number of trails to an

435
00:16:09,600 --> 00:16:11,920
mielp problem the number of solutions to

436
00:16:11,920 --> 00:16:14,000
an mlb problem which is very hard in

437
00:16:14,000 --> 00:16:16,399
general and having this around keys

438
00:16:16,399 --> 00:16:18,000
allow us to

439
00:16:18,000 --> 00:16:20,240
a bit control this number of solutions

440
00:16:20,240 --> 00:16:22,160
so that we can make it low and actually

441
00:16:22,160 --> 00:16:23,120
count them

442
00:16:23,120 --> 00:16:26,160
so for permutation based crypto

443
00:16:26,160 --> 00:16:28,320
we don't have these home keys

444
00:16:28,320 --> 00:16:30,800
so if for example there are two to the

445
00:16:30,800 --> 00:16:33,360
32 trays to enumerate

446
00:16:33,360 --> 00:16:36,320
well we have to do we cannot control

447
00:16:36,320 --> 00:16:38,720
lower so for now

448
00:16:38,720 --> 00:16:40,399
um

449
00:16:40,399 --> 00:16:42,560
immediately no i don't really know but

450
00:16:42,560 --> 00:16:44,000
it's part of

451
00:16:44,000 --> 00:16:46,079
the future work for this

452
00:16:46,079 --> 00:16:47,920
this

453
00:16:47,920 --> 00:16:50,560
project i mean this

454
00:16:50,560 --> 00:16:51,330
topic can see

455
00:16:51,330 --> 00:16:54,450
[Music]

456
00:16:55,519 --> 00:16:58,720
okay thank you so awesome

457
00:16:58,720 --> 00:17:00,959
the next question is that

458
00:17:00,959 --> 00:17:03,199
is this method potential to extend to

459
00:17:03,199 --> 00:17:07,199
prove a balanced integral sum

460
00:17:08,160 --> 00:17:10,799
sorry can you repeat that

461
00:17:10,799 --> 00:17:13,439
is it in the chat

462
00:17:13,439 --> 00:17:16,439
yes

463
00:17:18,799 --> 00:17:22,319
to prove a balance integral

464
00:17:22,400 --> 00:17:23,599
um

465
00:17:23,599 --> 00:17:25,839
so technically

466
00:17:25,839 --> 00:17:28,079
you can use this to

467
00:17:28,079 --> 00:17:29,600
since you can compute the compute the

468
00:17:29,600 --> 00:17:31,520
lambda u v source coefficient in the key

469
00:17:31,520 --> 00:17:34,240
polynomials of the inf

470
00:17:34,240 --> 00:17:36,000
you could

471
00:17:36,000 --> 00:17:38,400
theoretically try to show that a given

472
00:17:38,400 --> 00:17:40,720
key polynomial is zero

473
00:17:40,720 --> 00:17:42,559
meaning that the given monomial x2 does

474
00:17:42,559 --> 00:17:45,200
not appear on dnf in practice this is

475
00:17:45,200 --> 00:17:47,600
quite hard because

476
00:17:47,600 --> 00:17:49,600
it's much easier to show that these

477
00:17:49,600 --> 00:17:51,440
polynomials are non-zero by showing that

478
00:17:51,440 --> 00:17:53,600
at least one coefficient is non-zero

479
00:17:53,600 --> 00:17:55,760
and showing that these polynomials are

480
00:17:55,760 --> 00:17:57,440
equal to zero which means showing that

481
00:17:57,440 --> 00:18:00,750
every coefficient is equal to zero

482
00:18:00,750 --> 00:18:02,320
[Music]

483
00:18:02,320 --> 00:18:05,280
so it looks rather hard and

484
00:18:05,280 --> 00:18:06,080
if

485
00:18:06,080 --> 00:18:09,120
we can you can still use

486
00:18:09,120 --> 00:18:11,520
so it's based on division property i

487
00:18:11,520 --> 00:18:13,679
encourage you to check the

488
00:18:13,679 --> 00:18:16,000
euro crypt last year paper

489
00:18:16,000 --> 00:18:19,360
by hour i think

490
00:18:19,600 --> 00:18:21,440
then introduce this

491
00:18:21,440 --> 00:18:22,960
division property with three subsets

492
00:18:22,960 --> 00:18:24,559
without any subset

493
00:18:24,559 --> 00:18:26,240
and if you just

494
00:18:26,240 --> 00:18:28,880
use it without

495
00:18:28,880 --> 00:18:32,720
in a bit of a weaker way you can

496
00:18:32,720 --> 00:18:36,000
still show some distinguishes by

497
00:18:36,000 --> 00:18:38,240
because some cases you can

498
00:18:38,240 --> 00:18:41,360
show that there is no trail

499
00:18:41,679 --> 00:18:43,840
maybe i can ask i can answer that more

500
00:18:43,840 --> 00:18:46,000
details

501
00:18:46,000 --> 00:18:48,640
if you want more details let me know

502
00:18:48,640 --> 00:18:50,480
thank you

503
00:18:50,480 --> 00:18:53,039
okay thank you so uh do you have any any

504
00:18:53,039 --> 00:18:55,039
other comments questions

505
00:18:55,039 --> 00:18:57,039
i have one more question

506
00:18:57,039 --> 00:18:59,280
please if i understand

507
00:18:59,280 --> 00:19:01,440
this paper correctly then you know you

508
00:19:01,440 --> 00:19:03,120
use this assumption that

509
00:19:03,120 --> 00:19:04,400
you know you have addition of

510
00:19:04,400 --> 00:19:06,400
independent round keys and my question

511
00:19:06,400 --> 00:19:07,120
is

512
00:19:07,120 --> 00:19:10,000
okay what happens if the round key added

513
00:19:10,000 --> 00:19:11,840
at each round is smaller than the

514
00:19:11,840 --> 00:19:14,559
internal state of uh you know the round

515
00:19:14,559 --> 00:19:17,440
so basically we don't do a full xor but

516
00:19:17,440 --> 00:19:19,360
something less than that does it

517
00:19:19,360 --> 00:19:21,520
complicate things could this be extended

518
00:19:21,520 --> 00:19:24,960
to cover this this case um so it's for

519
00:19:24,960 --> 00:19:26,559
example it's a case for skinny and gift

520
00:19:26,559 --> 00:19:28,559
so in our case indeed we added the

521
00:19:28,559 --> 00:19:30,400
account versus the full state where

522
00:19:30,400 --> 00:19:32,400
while first clinian gives the keys only

523
00:19:32,400 --> 00:19:33,440
added on

524
00:19:33,440 --> 00:19:34,880
half the state

525
00:19:34,880 --> 00:19:37,039
um right

526
00:19:37,039 --> 00:19:38,559
so the idea can be translated

527
00:19:38,559 --> 00:19:40,320
immediately if you still assume that

528
00:19:40,320 --> 00:19:41,919
they are independent

529
00:19:41,919 --> 00:19:43,520
because handling exactly schedule is a

530
00:19:43,520 --> 00:19:46,400
bit complicated but right

531
00:19:46,400 --> 00:19:47,440
if you still assume that there are

532
00:19:47,440 --> 00:19:49,840
dependents algorithm works basically the

533
00:19:49,840 --> 00:19:52,879
same you just

534
00:19:53,280 --> 00:19:55,760
like it's not even super hard to

535
00:19:55,760 --> 00:19:57,600
change in our implementation you fix

536
00:19:57,600 --> 00:19:59,440
some uh

537
00:19:59,440 --> 00:20:01,280
value for the division property to be 0

538
00:20:01,280 --> 00:20:02,480
basically

539
00:20:02,480 --> 00:20:04,559
the issue is that it gives us a lot less

540
00:20:04,559 --> 00:20:07,679
control on the number of trials

541
00:20:07,679 --> 00:20:09,919
on the number of solutions to this milp

542
00:20:09,919 --> 00:20:12,559
problem so it's

543
00:20:12,559 --> 00:20:15,280
likely to be much harder to do

544
00:20:15,280 --> 00:20:15,930
and

545
00:20:15,930 --> 00:20:17,280
[Music]

546
00:20:17,280 --> 00:20:19,039
i did not have time to experiment too

547
00:20:19,039 --> 00:20:21,039
much with this i think it's uh

548
00:20:21,039 --> 00:20:22,480
something we could

549
00:20:22,480 --> 00:20:24,640
probably try

550
00:20:24,640 --> 00:20:26,799
it shouldn't be like it's not very hard

551
00:20:26,799 --> 00:20:28,720
to

552
00:20:28,720 --> 00:20:30,159
to adapt

553
00:20:30,159 --> 00:20:31,840
but in terms of computation time it

554
00:20:31,840 --> 00:20:32,799
makes it

555
00:20:32,799 --> 00:20:34,480
likely to make the problem quite a lot

556
00:20:34,480 --> 00:20:37,200
more complicated

557
00:20:37,280 --> 00:20:39,440
all right thank you

558
00:20:39,440 --> 00:20:42,000
okay thank you very much uh so let's

559
00:20:42,000 --> 00:20:44,640
move to the uh third doc

560
00:20:44,640 --> 00:20:46,000
uh

561
00:20:46,000 --> 00:20:49,360
the third talk is uh entitled massive uh

562
00:20:49,360 --> 00:20:53,039
super poly recovery with nested monomial

563
00:20:53,039 --> 00:20:54,400
predictions

564
00:20:54,400 --> 00:20:57,200
so the authors akaiku

565
00:20:57,200 --> 00:20:58,240
uh

566
00:20:58,240 --> 00:20:59,360
yosuke

567
00:20:59,360 --> 00:21:02,959
are making one and

568
00:21:06,480 --> 00:21:08,799
okay please go ahead

569
00:21:08,799 --> 00:21:10,320
thank you for the introduction and my

570
00:21:10,320 --> 00:21:12,320
name is careful and uh

571
00:21:12,320 --> 00:21:14,080
this paper is called massive for poly

572
00:21:14,080 --> 00:21:15,679
recovery with nasty monolingual

573
00:21:15,679 --> 00:21:17,600
predictions and this is the joint work

574
00:21:17,600 --> 00:21:21,200
with suicidal mitiga and the chinjiwang

575
00:21:21,200 --> 00:21:23,679
kubataku was proposed by dina and xiaomi

576
00:21:23,679 --> 00:21:25,440
and europe

577
00:21:25,440 --> 00:21:28,240
given a polynomial we have focused on

578
00:21:28,240 --> 00:21:31,039
the coefficient of a so-called crypto

579
00:21:31,039 --> 00:21:32,080
and this

580
00:21:32,080 --> 00:21:34,880
support here and this

581
00:21:34,880 --> 00:21:38,080
polynomial is called supporting and it

582
00:21:38,080 --> 00:21:40,559
will be simpler than the original

583
00:21:40,559 --> 00:21:43,360
polynomial and for any other bit of

584
00:21:43,360 --> 00:21:45,440
symmetric suffer the support is a

585
00:21:45,440 --> 00:21:47,200
function of p and nine

586
00:21:47,200 --> 00:21:50,400
cube variables and if we let the nine

587
00:21:50,400 --> 00:21:52,240
triple variables at zero then this

588
00:21:52,240 --> 00:21:55,120
property will be a pure polynomial of

589
00:21:55,120 --> 00:21:58,799
only k variables so if we know the af of

590
00:21:58,799 --> 00:22:00,320
this property we can get some

591
00:22:00,320 --> 00:22:03,039
information of key variables and the

592
00:22:03,039 --> 00:22:05,039
thought recovering the af of the

593
00:22:05,039 --> 00:22:06,720
superpoly is a

594
00:22:06,720 --> 00:22:08,720
core problem in

595
00:22:08,720 --> 00:22:11,039
crypto tax

596
00:22:11,039 --> 00:22:13,120
division property was proposed by todo

597
00:22:13,120 --> 00:22:16,320
and euro crypto 2015 and introduced to

598
00:22:16,320 --> 00:22:19,760
the cube tax and the crypto 2017 and the

599
00:22:19,760 --> 00:22:21,679
nominal prediction is another language

600
00:22:21,679 --> 00:22:23,760
expanding the division property from a

601
00:22:23,760 --> 00:22:27,520
polynomial perspective given a composite

602
00:22:27,520 --> 00:22:30,640
volume function y equals f x

603
00:22:30,640 --> 00:22:32,159
the nominal prediction or the

604
00:22:32,159 --> 00:22:36,159
variability can predict if x u this term

605
00:22:36,159 --> 00:22:38,320
does or doesn't appear in the polynomial

606
00:22:38,320 --> 00:22:40,159
of this

607
00:22:40,159 --> 00:22:41,600
term

608
00:22:41,600 --> 00:22:43,520
by counting the monomial or dividend

609
00:22:43,520 --> 00:22:46,480
trials so given a cube term if we can

610
00:22:46,480 --> 00:22:48,720
find all the

611
00:22:48,720 --> 00:22:51,679
g k times x to u so

612
00:22:51,679 --> 00:22:54,080
sum them together we can get the final

613
00:22:54,080 --> 00:22:55,679
body

614
00:22:55,679 --> 00:22:58,159
however the previous method has some

615
00:22:58,159 --> 00:23:00,080
challenges

616
00:23:00,080 --> 00:23:01,760
as the number of rounds of suffering

617
00:23:01,760 --> 00:23:04,080
increases the superpowers become more

618
00:23:04,080 --> 00:23:05,600
and more complicated

619
00:23:05,600 --> 00:23:08,400
the previous method cannot work

620
00:23:08,400 --> 00:23:10,640
actually we took directing the monomial

621
00:23:10,640 --> 00:23:13,559
prediction to recover the property for

622
00:23:13,559 --> 00:23:16,640
843 run tribute no results are obtained

623
00:23:16,640 --> 00:23:17,840
for

624
00:23:17,840 --> 00:23:19,280
a month

625
00:23:19,280 --> 00:23:21,520
in this paper we give a new nested

626
00:23:21,520 --> 00:23:24,320
framework with phenomenal prediction

627
00:23:24,320 --> 00:23:26,400
which is efficient for massive

628
00:23:26,400 --> 00:23:28,799
superpowers of course it

629
00:23:28,799 --> 00:23:31,200
works very well for simple

630
00:23:31,200 --> 00:23:32,559
super bodies

631
00:23:32,559 --> 00:23:33,440
and

632
00:23:33,440 --> 00:23:35,440
given

633
00:23:35,440 --> 00:23:38,640
output of our stream server we firstly

634
00:23:38,640 --> 00:23:40,799
to the past people are there and express

635
00:23:40,799 --> 00:23:42,400
f as a

636
00:23:42,400 --> 00:23:45,279
polynomial of the internal states

637
00:23:45,279 --> 00:23:47,120
here and

638
00:23:47,120 --> 00:23:51,039
then we construct mrp models to

639
00:23:51,039 --> 00:23:52,159
for each

640
00:23:52,159 --> 00:23:55,039
term in this polynomial

641
00:23:55,039 --> 00:23:58,080
different from the previous method we

642
00:23:58,080 --> 00:24:00,960
need to add a term limit to

643
00:24:00,960 --> 00:24:03,760
this mrp model this is

644
00:24:03,760 --> 00:24:05,279
in grouping

645
00:24:05,279 --> 00:24:08,480
server for example

646
00:24:08,480 --> 00:24:11,279
and then after the time it up all terms

647
00:24:11,279 --> 00:24:13,679
in this polynomial can be grouped into

648
00:24:13,679 --> 00:24:15,840
three disjoint sets the first set

649
00:24:15,840 --> 00:24:18,799
contains the monomials which are solved

650
00:24:18,799 --> 00:24:22,400
but infeasible so we know these terms

651
00:24:22,400 --> 00:24:24,320
have no contribution to the final

652
00:24:24,320 --> 00:24:26,880
property and the second term contains

653
00:24:26,880 --> 00:24:27,760
those

654
00:24:27,760 --> 00:24:31,360
terms which are solved and feasible so

655
00:24:31,360 --> 00:24:33,600
we can extract some partials properly

656
00:24:33,600 --> 00:24:34,720
from this

657
00:24:34,720 --> 00:24:37,200
term and the second

658
00:24:37,200 --> 00:24:39,440
set contains those

659
00:24:39,440 --> 00:24:42,240
monomials which are not solved within

660
00:24:42,240 --> 00:24:43,679
the time limit

661
00:24:43,679 --> 00:24:46,960
so we have to proceed this

662
00:24:46,960 --> 00:24:48,000
uh

663
00:24:48,000 --> 00:24:48,880
set

664
00:24:48,880 --> 00:24:50,880
uh in the following step and this set is

665
00:24:50,880 --> 00:24:53,600
called undetermined set and again the

666
00:24:53,600 --> 00:24:55,200
fourth is set

667
00:24:55,200 --> 00:24:58,159
this step we can

668
00:24:58,159 --> 00:25:02,559
recover a part of the supporters

669
00:25:02,559 --> 00:25:05,360
so in the next step we

670
00:25:05,360 --> 00:25:08,799
expand the polynomial the monomials in

671
00:25:08,799 --> 00:25:11,600
this undetermined set to another deeper

672
00:25:11,600 --> 00:25:14,400
internal states other polynomial uh

673
00:25:14,400 --> 00:25:15,919
other polynomials

674
00:25:15,919 --> 00:25:18,080
and then repeat the process to construct

675
00:25:18,080 --> 00:25:18,799
the

676
00:25:18,799 --> 00:25:21,600
mrp model with time limit and then

677
00:25:21,600 --> 00:25:23,200
discard something

678
00:25:23,200 --> 00:25:26,000
discard some nominal and uh collected

679
00:25:26,000 --> 00:25:30,240
some part of the uh throughput and until

680
00:25:30,240 --> 00:25:32,640
the undetermined set is the amplitude

681
00:25:32,640 --> 00:25:36,320
and then we can collect all the partial

682
00:25:36,320 --> 00:25:38,320
polynomials along the way and then we

683
00:25:38,320 --> 00:25:42,640
can examine them to find multiple body

684
00:25:42,640 --> 00:25:44,799
and here is the

685
00:25:44,799 --> 00:25:47,200
application to trivial and the table

686
00:25:47,200 --> 00:25:50,080
shows the five cubes we used for

687
00:25:50,080 --> 00:25:50,880
the

688
00:25:50,880 --> 00:25:52,679
trivium up to

689
00:25:52,679 --> 00:25:56,720
845 rounds and this and these cubes are

690
00:25:56,720 --> 00:25:59,120
just are chosen just

691
00:25:59,120 --> 00:26:02,559
by just adding index to a previous cube

692
00:26:02,559 --> 00:26:05,120
so th these cubes are chosen very

693
00:26:05,120 --> 00:26:07,120
clearly

694
00:26:07,120 --> 00:26:09,039
here are some detailed information of

695
00:26:09,039 --> 00:26:13,039
the superbodies we recovered for

696
00:26:13,039 --> 00:26:15,600
cubes i introduced just now and you can

697
00:26:15,600 --> 00:26:18,799
see the trials the division trials are

698
00:26:18,799 --> 00:26:20,640
many and the terms

699
00:26:20,640 --> 00:26:24,159
are also here

700
00:26:24,159 --> 00:26:25,120
this

701
00:26:25,120 --> 00:26:27,440
supporter can recover the recent

702
00:26:27,440 --> 00:26:30,320
about three weeks

703
00:26:31,919 --> 00:26:34,159
uh and this and this is the results for

704
00:26:34,159 --> 00:26:36,080
grade one to eight

705
00:26:36,080 --> 00:26:39,039
and we also recover improve the support

706
00:26:39,039 --> 00:26:42,158
for premium

707
00:26:42,480 --> 00:26:44,799
so with the recover the superpolis we

708
00:26:44,799 --> 00:26:48,240
can do the carrier attack however uh

709
00:26:48,240 --> 00:26:50,559
because our supporters are very

710
00:26:50,559 --> 00:26:52,799
complicated and involving all the key

711
00:26:52,799 --> 00:26:56,400
bits so a simple exhaustive method

712
00:26:56,400 --> 00:26:58,480
cannot work anymore because the

713
00:26:58,480 --> 00:27:00,880
complexity will pass

714
00:27:00,880 --> 00:27:03,200
to to earn so uh

715
00:27:03,200 --> 00:27:05,679
as in one way mobius transform can

716
00:27:05,679 --> 00:27:08,400
transform the f of a bond function to

717
00:27:08,400 --> 00:27:10,320
its

718
00:27:10,320 --> 00:27:13,600
table or transform the table to its nf

719
00:27:13,600 --> 00:27:17,279
with n times two minus n to two minus

720
00:27:17,279 --> 00:27:20,320
a minus one x y

721
00:27:20,320 --> 00:27:22,000
and also

722
00:27:22,000 --> 00:27:24,240
notes that uh

723
00:27:24,240 --> 00:27:27,200
also note that our support is although

724
00:27:27,200 --> 00:27:28,799
although they are very complicated but

725
00:27:28,799 --> 00:27:31,440
they are skills but compared to randomly

726
00:27:31,440 --> 00:27:32,840
chosen

727
00:27:32,840 --> 00:27:36,559
polynomials so a fine grade analysis can

728
00:27:36,559 --> 00:27:39,039
upper bound the complexity to n times

729
00:27:39,039 --> 00:27:40,240
two to

730
00:27:40,240 --> 00:27:42,640
n minus two xor and then we can use a

731
00:27:42,640 --> 00:27:44,799
mobile transform and with the divider

732
00:27:44,799 --> 00:27:46,799
and counter strategy to do the q

733
00:27:46,799 --> 00:27:48,559
recovery attack

734
00:27:48,559 --> 00:27:50,799
and we introduced a new concept called

735
00:27:50,799 --> 00:27:54,399
disjoint set given uh super body pk if

736
00:27:54,399 --> 00:27:56,480
pr and kj

737
00:27:56,480 --> 00:27:59,279
are two are two variable uh in this

738
00:27:59,279 --> 00:28:02,799
super body uh a never multiple and

739
00:28:02,799 --> 00:28:05,360
multiplied together and we say here and

740
00:28:05,360 --> 00:28:07,840
kg are destroying you for a subset of

741
00:28:07,840 --> 00:28:10,080
variables d and

742
00:28:10,080 --> 00:28:12,399
every pair of variables are destroyed

743
00:28:12,399 --> 00:28:15,279
with the d the destroying set

744
00:28:15,279 --> 00:28:16,640
the giveaway is

745
00:28:16,640 --> 00:28:20,480
n super bowl is uh p0 and dlp n minus

746
00:28:20,480 --> 00:28:23,840
one and if d is the disjoint set for

747
00:28:23,840 --> 00:28:25,120
each

748
00:28:25,120 --> 00:28:27,840
super body we call these the common

749
00:28:27,840 --> 00:28:29,520
disjoint set

750
00:28:29,520 --> 00:28:32,320
of these small bodies

751
00:28:32,320 --> 00:28:34,880
then even

752
00:28:34,880 --> 00:28:37,200
if pk has a disjoint set d with m

753
00:28:37,200 --> 00:28:41,039
variables and we can write the

754
00:28:41,039 --> 00:28:43,120
polynomial in this form

755
00:28:43,120 --> 00:28:46,240
and the pij and the pm are involved at

756
00:28:46,240 --> 00:28:48,799
most n minus m variables and then we can

757
00:28:48,799 --> 00:28:50,159
use the

758
00:28:50,159 --> 00:28:52,559
mobius transform to construct the truth

759
00:28:52,559 --> 00:28:56,960
table for pij and the pmg

760
00:28:56,960 --> 00:29:00,640
so with the m plus one two tables we can

761
00:29:00,640 --> 00:29:02,880
access them and get the value for each

762
00:29:02,880 --> 00:29:05,520
key combination in j and then this

763
00:29:05,520 --> 00:29:08,159
equation will become a linear equation

764
00:29:08,159 --> 00:29:09,760
then with the linear equation we can

765
00:29:09,760 --> 00:29:11,120
recall some

766
00:29:11,120 --> 00:29:13,840
key information is there

767
00:29:13,840 --> 00:29:16,240
and this demonstrates the critical

768
00:29:16,240 --> 00:29:18,159
attacks

769
00:29:18,159 --> 00:29:21,120
in this paper and

770
00:29:22,720 --> 00:29:24,640
they are improved according to the

771
00:29:24,640 --> 00:29:26,320
wrongs

772
00:29:26,320 --> 00:29:27,679
so in this video we'll give a new

773
00:29:27,679 --> 00:29:29,760
efficient framework with net monomial

774
00:29:29,760 --> 00:29:31,279
prediction for

775
00:29:31,279 --> 00:29:33,840
massive supporting recovery and we also

776
00:29:33,840 --> 00:29:36,240
give a new kilocare attack strategy with

777
00:29:36,240 --> 00:29:38,399
mobile transform based on muscles for

778
00:29:38,399 --> 00:29:40,000
bodies

779
00:29:40,000 --> 00:29:42,159
we also give some improved key recovery

780
00:29:42,159 --> 00:29:44,640
tasks on trivium group one to eight a

781
00:29:44,640 --> 00:29:46,080
and equilibrium

782
00:29:46,080 --> 00:29:48,559
thank you for your attention

783
00:29:48,559 --> 00:29:50,960
that's all

784
00:29:51,039 --> 00:29:52,880
okay uh thank you very much for your

785
00:29:52,880 --> 00:29:56,000
talk so uh we can have a short question

786
00:29:56,000 --> 00:29:59,840
so if you have any questions or comments

787
00:30:04,720 --> 00:30:07,279
so i i have one quick question

788
00:30:07,279 --> 00:30:10,240
and this time limit tau zero so could

789
00:30:10,240 --> 00:30:13,440
you maybe quickly elaborate you know how

790
00:30:13,440 --> 00:30:16,080
what's the optimum strategy of choosing

791
00:30:16,080 --> 00:30:18,880
those time limits for those you know

792
00:30:18,880 --> 00:30:22,000
different layers of the nested framework

793
00:30:22,000 --> 00:30:24,240
uh yeah yes

794
00:30:24,240 --> 00:30:26,080
actually we have some detailed

795
00:30:26,080 --> 00:30:28,399
explanation of the intuition to choose

796
00:30:28,399 --> 00:30:29,440
the

797
00:30:29,440 --> 00:30:32,480
time limit in our paper but here time is

798
00:30:32,480 --> 00:30:35,600
limited so i i cannot enjoy it uh eureka

799
00:30:35,600 --> 00:30:37,679
speaking when

800
00:30:37,679 --> 00:30:40,880
uh for the higher rank for example we

801
00:30:40,880 --> 00:30:42,440
attacked the

802
00:30:42,440 --> 00:30:45,600
845 rounds then

803
00:30:45,600 --> 00:30:48,159
with the first uh

804
00:30:48,159 --> 00:30:50,240
expanding we

805
00:30:50,240 --> 00:30:51,360
tend to

806
00:30:51,360 --> 00:30:54,880
choose a smaller time limit because uh

807
00:30:54,880 --> 00:30:56,399
the round is

808
00:30:56,399 --> 00:30:59,519
high the number of rounds is high so

809
00:30:59,519 --> 00:31:00,720
we

810
00:31:00,720 --> 00:31:03,519
don't expect to

811
00:31:03,519 --> 00:31:05,440
solve

812
00:31:05,440 --> 00:31:09,519
many models so if we set a bigger time

813
00:31:09,519 --> 00:31:10,480
limit

814
00:31:10,480 --> 00:31:11,600
then

815
00:31:11,600 --> 00:31:13,760
it is very like

816
00:31:13,760 --> 00:31:15,760
luckily that

817
00:31:15,760 --> 00:31:16,880
this time

818
00:31:16,880 --> 00:31:20,080
or waste our whiskey because

819
00:31:20,080 --> 00:31:22,480
the number of round is high so it is

820
00:31:22,480 --> 00:31:25,679
very difficult to expand uh to evaluate

821
00:31:25,679 --> 00:31:27,600
the partial support

822
00:31:27,600 --> 00:31:29,840
but as the lungs get

823
00:31:29,840 --> 00:31:34,159
smaller and then we gradually

824
00:31:34,159 --> 00:31:36,960
enlarge the

825
00:31:36,960 --> 00:31:40,159
time limit because of the wrong become

826
00:31:40,159 --> 00:31:41,600
smaller

827
00:31:41,600 --> 00:31:43,840
the

828
00:31:44,240 --> 00:31:46,640
the number of terms beyond the support

829
00:31:46,640 --> 00:31:49,440
you know in the polynomials become more

830
00:31:49,440 --> 00:31:52,799
animal anymore so we want to solve as

831
00:31:52,799 --> 00:31:55,600
much as many as possible

832
00:31:55,600 --> 00:31:57,120
uh

833
00:31:57,120 --> 00:31:58,720
terms in

834
00:31:58,720 --> 00:32:03,039
each step so we will choose a bigger

835
00:32:03,039 --> 00:32:04,399
time limit

836
00:32:04,399 --> 00:32:06,720
yeah this is a strategy

837
00:32:06,720 --> 00:32:08,480
all right thank you very much

838
00:32:08,480 --> 00:32:10,240
thank you okay

839
00:32:10,240 --> 00:32:13,039
thank you very much for uh so uh

840
00:32:13,039 --> 00:32:16,080
so let's go to the first talk so i would

841
00:32:16,080 --> 00:32:18,960
like to hand over the scale to christian

842
00:32:18,960 --> 00:32:20,960
that's right thank you very much so our

843
00:32:20,960 --> 00:32:23,840
next stock is quantum linearization

844
00:32:23,840 --> 00:32:26,080
attacks

845
00:32:26,080 --> 00:32:27,519
and

846
00:32:27,519 --> 00:32:29,370
yes and let's wait uh

847
00:32:29,370 --> 00:32:30,559
[Music]

848
00:32:30,559 --> 00:32:33,600
should be able to see

849
00:32:33,679 --> 00:32:35,840
nice like you can see our screen and now

850
00:32:35,840 --> 00:32:37,519
we can see your slides perfect that's

851
00:32:37,519 --> 00:32:39,840
right so the stock uh and this

852
00:32:39,840 --> 00:32:42,799
presentation is very

853
00:32:47,519 --> 00:32:49,840
hopefully i pronounce this close enough

854
00:32:49,840 --> 00:32:53,200
and then andre is going to give the talk

855
00:32:53,200 --> 00:32:54,399
thanks a lot

856
00:32:54,399 --> 00:32:56,720
so yes the tattoo says this is the only

857
00:32:56,720 --> 00:32:58,399
talking decision i think which is about

858
00:32:58,399 --> 00:33:00,640
quantum attacks actually

859
00:33:00,640 --> 00:33:02,960
so the model of quantum attacker that

860
00:33:02,960 --> 00:33:04,720
we're going to consider here is even

861
00:33:04,720 --> 00:33:06,240
more specific

862
00:33:06,240 --> 00:33:08,000
we're considering quantum attacks in

863
00:33:08,000 --> 00:33:10,240
this reposition model so imagine an

864
00:33:10,240 --> 00:33:11,519
adversary that can make quantum

865
00:33:11,519 --> 00:33:12,960
computations

866
00:33:12,960 --> 00:33:15,039
and then during these computations the

867
00:33:15,039 --> 00:33:16,399
adversary can

868
00:33:16,399 --> 00:33:19,440
make a query to in our case a mac a

869
00:33:19,440 --> 00:33:21,919
message authentication code

870
00:33:21,919 --> 00:33:24,720
which has inputs of multiple blocks

871
00:33:24,720 --> 00:33:25,919
and these queries can be made in

872
00:33:25,919 --> 00:33:27,519
superposition over the

873
00:33:27,519 --> 00:33:29,039
inputs

874
00:33:29,039 --> 00:33:31,600
so you can consider this mac oracle

875
00:33:31,600 --> 00:33:34,159
as a quantum component from the

876
00:33:34,159 --> 00:33:36,480
web which is yes as a quantum component

877
00:33:36,480 --> 00:33:39,440
inside the adverse series computations

878
00:33:39,440 --> 00:33:41,519
um this is a very strong model

879
00:33:41,519 --> 00:33:44,480
uh but it it has been it's known that

880
00:33:44,480 --> 00:33:46,000
there are

881
00:33:46,000 --> 00:33:48,080
attacks in this model that we don't have

882
00:33:48,080 --> 00:33:49,840
with classical queries

883
00:33:49,840 --> 00:33:52,559
and this is what we're going to do here

884
00:33:52,559 --> 00:33:55,840
um and on this attack our goal is to

885
00:33:55,840 --> 00:33:58,720
forge tags so these are filtery attacks

886
00:33:58,720 --> 00:33:59,519
and

887
00:33:59,519 --> 00:34:01,200
we're just going to say that this means

888
00:34:01,200 --> 00:34:03,360
that the adversary in the end of these

889
00:34:03,360 --> 00:34:06,240
computations is able to put more valid

890
00:34:06,240 --> 00:34:09,359
message uh mac pers

891
00:34:09,359 --> 00:34:11,440
than the total number of macquaries that

892
00:34:11,440 --> 00:34:13,199
the other so you made

893
00:34:13,199 --> 00:34:15,359
okay so you have this computation

894
00:34:15,359 --> 00:34:17,040
making a number of superposition queries

895
00:34:17,040 --> 00:34:21,399
and then in the end outputting many tags

896
00:34:21,760 --> 00:34:25,359
so typically in superposition attacks

897
00:34:25,359 --> 00:34:26,399
we use

898
00:34:26,399 --> 00:34:28,960
uh structural finding tools dedicated

899
00:34:28,960 --> 00:34:30,480
quantum algorithms to find hidden

900
00:34:30,480 --> 00:34:32,879
instructors a typical tool for that is

901
00:34:32,879 --> 00:34:34,399
simon's algorithm

902
00:34:34,399 --> 00:34:36,239
actually it's also one of the tools that

903
00:34:36,239 --> 00:34:38,159
we use in our paper

904
00:34:38,159 --> 00:34:40,560
the simon's problem is the following

905
00:34:40,560 --> 00:34:41,760
if you have a function that is either

906
00:34:41,760 --> 00:34:44,399
injective or that has a period

907
00:34:44,399 --> 00:34:46,560
and this is a boolean period so it means

908
00:34:46,560 --> 00:34:47,520
that

909
00:34:47,520 --> 00:34:51,040
x and x so s for the spirit s always

910
00:34:51,040 --> 00:34:53,440
have the same image now if you have that

911
00:34:53,440 --> 00:34:54,879
then you can

912
00:34:54,879 --> 00:34:57,280
recover the period very easily uh with

913
00:34:57,280 --> 00:34:58,800
the quantum algorithm that makes

914
00:34:58,800 --> 00:35:00,040
superposition

915
00:35:00,040 --> 00:35:02,480
corresponding polynomial time and

916
00:35:02,480 --> 00:35:03,839
classically of course if you don't have

917
00:35:03,839 --> 00:35:04,880
any

918
00:35:04,880 --> 00:35:07,280
like any other information about f uh it

919
00:35:07,280 --> 00:35:10,079
will cost you an exponential time

920
00:35:10,079 --> 00:35:11,200
and it works

921
00:35:11,200 --> 00:35:12,960
it works in a crypto context even if

922
00:35:12,960 --> 00:35:14,960
it's a random function

923
00:35:14,960 --> 00:35:17,440
with the promise that is a spirit

924
00:35:17,440 --> 00:35:19,040
so typically what we do

925
00:35:19,040 --> 00:35:21,119
in this superposition attacks is

926
00:35:21,119 --> 00:35:23,119
we have a function that has a very

927
00:35:23,119 --> 00:35:25,200
strong algebraic structure like a block

928
00:35:25,200 --> 00:35:26,480
cipher construction or a

929
00:35:26,480 --> 00:35:28,079
microconstruction

930
00:35:28,079 --> 00:35:30,000
and we have this oracle with a secret

931
00:35:30,000 --> 00:35:32,240
key k i want to recover something about

932
00:35:32,240 --> 00:35:33,280
the secret

933
00:35:33,280 --> 00:35:35,280
so what we do is we define a periodic

934
00:35:35,280 --> 00:35:36,240
function

935
00:35:36,240 --> 00:35:37,599
from this

936
00:35:37,599 --> 00:35:39,200
so we take the output of our black box e

937
00:35:39,200 --> 00:35:39,920
k

938
00:35:39,920 --> 00:35:41,680
and then we do some post computation on

939
00:35:41,680 --> 00:35:44,160
it and this becomes a periodic function

940
00:35:44,160 --> 00:35:46,160
and then we use simon's algorithm so of

941
00:35:46,160 --> 00:35:47,359
course simon's algorithm requires

942
00:35:47,359 --> 00:35:48,480
repositioning grays so we lose

943
00:35:48,480 --> 00:35:50,400
population grades

944
00:35:50,400 --> 00:35:52,000
but you can imagine that

945
00:35:52,000 --> 00:35:53,760
in general this approach needs to have

946
00:35:53,760 --> 00:35:55,200
at some point

947
00:35:55,200 --> 00:35:57,280
in this structured function

948
00:35:57,280 --> 00:35:58,320
exhaust

949
00:35:58,320 --> 00:36:00,480
between some secret value

950
00:36:00,480 --> 00:36:02,160
that we're going to recover that is our

951
00:36:02,160 --> 00:36:03,440
secret period

952
00:36:03,440 --> 00:36:05,200
and some input of the black box that we

953
00:36:05,200 --> 00:36:07,280
need to control that the adversary needs

954
00:36:07,280 --> 00:36:10,880
to be able to put into super position

955
00:36:11,440 --> 00:36:13,520
this is what happened in

956
00:36:13,520 --> 00:36:15,599
most or let's say all the previous

957
00:36:15,599 --> 00:36:18,480
attacks in this model

958
00:36:18,480 --> 00:36:20,000
in this paper what we show you that you

959
00:36:20,000 --> 00:36:21,599
can do things a bit differently to

960
00:36:21,599 --> 00:36:23,280
target some

961
00:36:23,280 --> 00:36:25,359
new symmetry constructions in particular

962
00:36:25,359 --> 00:36:28,240
these are a certain number of max

963
00:36:28,240 --> 00:36:30,880
parallel mac constructions

964
00:36:30,880 --> 00:36:32,800
that you can attack using samus

965
00:36:32,800 --> 00:36:34,720
algorithm but also different quantum

966
00:36:34,720 --> 00:36:36,640
algorithms like deutsch benson vezirani

967
00:36:36,640 --> 00:36:38,160
and shows

968
00:36:38,160 --> 00:36:40,079
and there is a long list of mics that

969
00:36:40,079 --> 00:36:41,359
are attacked so i'm just going to say

970
00:36:41,359 --> 00:36:42,400
some of them

971
00:36:42,400 --> 00:36:45,040
uh like mac like my plus

972
00:36:45,040 --> 00:36:46,880
and also beyond both the bound variants

973
00:36:46,880 --> 00:36:48,320
of them

974
00:36:48,320 --> 00:36:50,160
um and also we have like a new

975
00:36:50,160 --> 00:36:51,599
superposition attack company one zero

976
00:36:51,599 --> 00:36:53,760
five

977
00:36:53,760 --> 00:36:54,560
so

978
00:36:54,560 --> 00:36:56,079
how does it work

979
00:36:56,079 --> 00:36:58,560
so i'm going to take a very uh generic

980
00:36:58,560 --> 00:37:00,480
example of this

981
00:37:00,480 --> 00:37:02,720
and you can see since it's very generic

982
00:37:02,720 --> 00:37:04,160
there are many constructions that fall

983
00:37:04,160 --> 00:37:05,200
into this

984
00:37:05,200 --> 00:37:06,560
depiction

985
00:37:06,560 --> 00:37:08,720
so let's say you take uh

986
00:37:08,720 --> 00:37:11,760
secret dependent functions uh with this

987
00:37:11,760 --> 00:37:13,839
permutations by i here

988
00:37:13,839 --> 00:37:16,320
and a function f here and the industry

989
00:37:16,320 --> 00:37:17,839
doesn't access these components he only

990
00:37:17,839 --> 00:37:20,960
has access to the mac the whole mac

991
00:37:20,960 --> 00:37:23,680
um and the goal is to full stack right

992
00:37:23,680 --> 00:37:25,920
so on this construction you can't why do

993
00:37:25,920 --> 00:37:27,599
you not have access between a message

994
00:37:27,599 --> 00:37:29,440
and a secret

995
00:37:29,440 --> 00:37:30,880
um

996
00:37:30,880 --> 00:37:33,680
and this is what we're going to attack

997
00:37:33,680 --> 00:37:34,560
so

998
00:37:34,560 --> 00:37:36,800
this function mark is not periodic

999
00:37:36,800 --> 00:37:38,880
but what we're going to do is to create

1000
00:37:38,880 --> 00:37:40,320
another function

1001
00:37:40,320 --> 00:37:42,640
create a restriction on the inputs such

1002
00:37:42,640 --> 00:37:44,320
that the mac restricted to the inputs

1003
00:37:44,320 --> 00:37:46,240
becomes periodic

1004
00:37:46,240 --> 00:37:48,960
and in order to do that we just take

1005
00:37:48,960 --> 00:37:50,880
two values for each block

1006
00:37:50,880 --> 00:37:52,560
so each block is going to depend on one

1007
00:37:52,560 --> 00:37:53,599
bit only

1008
00:37:53,599 --> 00:37:55,680
and now you make this a function of an

1009
00:37:55,680 --> 00:37:57,760
input of l bits because they were l

1010
00:37:57,760 --> 00:38:00,160
blocks

1011
00:38:00,560 --> 00:38:02,560
and you can remark that this function is

1012
00:38:02,560 --> 00:38:04,880
basically

1013
00:38:04,880 --> 00:38:07,680
the the output computation

1014
00:38:07,680 --> 00:38:10,079
of some sum which depends on the l

1015
00:38:10,079 --> 00:38:11,200
blocks

1016
00:38:11,200 --> 00:38:12,880
and this sum inside is an affine

1017
00:38:12,880 --> 00:38:13,920
function

1018
00:38:13,920 --> 00:38:15,760
because each time you flip a bit you

1019
00:38:15,760 --> 00:38:19,280
simply exhaust something to it

1020
00:38:19,280 --> 00:38:21,680
okay so we have uh some some post

1021
00:38:21,680 --> 00:38:23,839
processing of a defined function

1022
00:38:23,839 --> 00:38:25,200
of our own bit

1023
00:38:25,200 --> 00:38:26,079
and

1024
00:38:26,079 --> 00:38:28,560
well an fn function is periodic

1025
00:38:28,560 --> 00:38:29,760
as long as

1026
00:38:29,760 --> 00:38:33,040
l is large enough

1027
00:38:33,040 --> 00:38:35,440
actually there are periods that appear

1028
00:38:35,440 --> 00:38:36,480
inside

1029
00:38:36,480 --> 00:38:38,880
in this fine time zone

1030
00:38:38,880 --> 00:38:41,680
and so these periods become periods of

1031
00:38:41,680 --> 00:38:44,320
the whole mac function

1032
00:38:44,320 --> 00:38:46,000
so by doing this so by restricting our

1033
00:38:46,000 --> 00:38:47,760
inputs we're able to create a periodic

1034
00:38:47,760 --> 00:38:49,040
function

1035
00:38:49,040 --> 00:38:51,680
and actually once we cover this period

1036
00:38:51,680 --> 00:38:54,079
we can use it to forge as many texts

1037
00:38:54,079 --> 00:38:56,560
that we want

1038
00:38:59,680 --> 00:39:00,400
so

1039
00:39:00,400 --> 00:39:03,119
this to analysis nicely to beyond burst

1040
00:39:03,119 --> 00:39:05,440
demand variance because uh

1041
00:39:05,440 --> 00:39:07,440
if if you have like uh what usually

1042
00:39:07,440 --> 00:39:08,720
happens to that instead of having a

1043
00:39:08,720 --> 00:39:09,680
single

1044
00:39:09,680 --> 00:39:11,920
sum in the end you have multiple of them

1045
00:39:11,920 --> 00:39:14,560
and you can do that for all the sums uh

1046
00:39:14,560 --> 00:39:16,160
in pilots so you can use the same

1047
00:39:16,160 --> 00:39:17,440
technique

1048
00:39:17,440 --> 00:39:18,880
so what happens really that if you

1049
00:39:18,880 --> 00:39:20,000
process all the input boxes

1050
00:39:20,000 --> 00:39:22,160
independently and you compute

1051
00:39:22,160 --> 00:39:23,920
xor of this

1052
00:39:23,920 --> 00:39:25,359
of these blocks

1053
00:39:25,359 --> 00:39:28,240
or anything that is linear and you

1054
00:39:28,240 --> 00:39:30,800
compute the tag out of that then you're

1055
00:39:30,800 --> 00:39:34,160
exposed to this kind of attack

1056
00:39:34,400 --> 00:39:36,400
so you can see this really uh from a

1057
00:39:36,400 --> 00:39:38,720
kryptonisis perspective it means that

1058
00:39:38,720 --> 00:39:40,480
we're able to break in the superposition

1059
00:39:40,480 --> 00:39:44,320
model of course uh many many macs

1060
00:39:44,320 --> 00:39:45,839
from a probable security perspective it

1061
00:39:45,839 --> 00:39:48,240
means that well um

1062
00:39:48,240 --> 00:39:50,240
it is an interesting question

1063
00:39:50,240 --> 00:39:53,280
uh to to to to know how we could

1064
00:39:53,280 --> 00:39:56,640
overcome this to be able to see compute

1065
00:39:56,640 --> 00:39:59,200
to create uh sacred designs

1066
00:39:59,200 --> 00:40:01,359
and in that case secure pyrializable

1067
00:40:01,359 --> 00:40:03,599
quantum centralizations

1068
00:40:03,599 --> 00:40:05,440
and we also don't know uh if this has

1069
00:40:05,440 --> 00:40:06,560
consequences when you make on the

1070
00:40:06,560 --> 00:40:07,760
classical queries so that's an

1071
00:40:07,760 --> 00:40:10,319
interesting open question thank you for

1072
00:40:10,319 --> 00:40:12,640
attention

1073
00:40:14,160 --> 00:40:15,920
thank you very much thank you for the

1074
00:40:15,920 --> 00:40:16,800
talk

1075
00:40:16,800 --> 00:40:17,760
and now

1076
00:40:17,760 --> 00:40:19,440
i'm maybe for

1077
00:40:19,440 --> 00:40:22,240
one or two quick

1078
00:40:22,839 --> 00:40:27,680
questions the chat or zulip

1079
00:40:28,079 --> 00:40:30,079
so while we wait maybe i'll start with

1080
00:40:30,079 --> 00:40:32,480
one so i have a question about this

1081
00:40:32,480 --> 00:40:33,920
combining function right so you said

1082
00:40:33,920 --> 00:40:35,599
that okay for everything that is linear

1083
00:40:35,599 --> 00:40:37,920
that's actually you know insecure

1084
00:40:37,920 --> 00:40:39,440
but i think in the longer version of the

1085
00:40:39,440 --> 00:40:41,200
talk you mentioned that modular edition

1086
00:40:41,200 --> 00:40:43,200
for example that the

1087
00:40:43,200 --> 00:40:45,599
case is not clear what we can do so you

1088
00:40:45,599 --> 00:40:47,520
have any other intuitions of you know

1089
00:40:47,520 --> 00:40:49,119
the speed between those that are

1090
00:40:49,119 --> 00:40:51,359
definitely you know vulnerable to their

1091
00:40:51,359 --> 00:40:52,800
attack like linear functions and then

1092
00:40:52,800 --> 00:40:55,760
those that maybe are okay and then those

1093
00:40:55,760 --> 00:40:57,359
that you are kind of reasonably

1094
00:40:57,359 --> 00:41:00,160
confident that they should be fine

1095
00:41:00,160 --> 00:41:02,400
well we know for example that uh if you

1096
00:41:02,400 --> 00:41:04,480
if you have a not a parallel but a

1097
00:41:04,480 --> 00:41:07,440
sequential mac like hmac and mac

1098
00:41:07,440 --> 00:41:09,040
they are secure

1099
00:41:09,040 --> 00:41:10,640
so uh

1100
00:41:10,640 --> 00:41:12,640
so because in this max actually you

1101
00:41:12,640 --> 00:41:14,079
don't process so you don't serve

1102
00:41:14,079 --> 00:41:16,560
everything into in in parallel

1103
00:41:16,560 --> 00:41:18,560
but you have uh but you have like a

1104
00:41:18,560 --> 00:41:20,400
compression function that processes each

1105
00:41:20,400 --> 00:41:22,640
block sequentially

1106
00:41:22,640 --> 00:41:23,760
um

1107
00:41:23,760 --> 00:41:26,640
for modular additions i i really don't

1108
00:41:26,640 --> 00:41:28,079
know uh

1109
00:41:28,079 --> 00:41:28,960
like

1110
00:41:28,960 --> 00:41:31,359
it just happens that you need unique

1111
00:41:31,359 --> 00:41:32,640
source here

1112
00:41:32,640 --> 00:41:34,800
because you need some kind of involution

1113
00:41:34,800 --> 00:41:36,319
um

1114
00:41:36,319 --> 00:41:38,000
and i really i really don't know if you

1115
00:41:38,000 --> 00:41:39,119
can prove something with modular

1116
00:41:39,119 --> 00:41:40,400
additions it would be i think it would

1117
00:41:40,400 --> 00:41:42,880
be uh it would be a great result

1118
00:41:42,880 --> 00:41:45,119
but uh but it might be extremely hard as

1119
00:41:45,119 --> 00:41:45,920
well

1120
00:41:45,920 --> 00:41:50,000
just because uh um

1121
00:41:50,000 --> 00:41:51,599
the the only problem with them is really

1122
00:41:51,599 --> 00:41:53,200
that they're not involvative and the

1123
00:41:53,200 --> 00:41:55,359
attack just don't doesn't work but that

1124
00:41:55,359 --> 00:41:57,680
doesn't mean like there is a an easy way

1125
00:41:57,680 --> 00:41:59,200
to prove that

1126
00:41:59,200 --> 00:42:00,079
um

1127
00:42:00,079 --> 00:42:02,480
yeah apart from that like i i don't

1128
00:42:02,480 --> 00:42:05,119
really know uh

1129
00:42:05,119 --> 00:42:06,960
yeah i don't i don't really know how

1130
00:42:06,960 --> 00:42:08,880
what would be a really good uh security

1131
00:42:08,880 --> 00:42:11,760
design uh

1132
00:42:11,920 --> 00:42:14,480
all right thank you that's interesting

1133
00:42:14,480 --> 00:42:16,960
any other quick question if not you can

1134
00:42:16,960 --> 00:42:19,520
always you know put a question in solip

1135
00:42:19,520 --> 00:42:21,920
and hopefully the authors can answer

1136
00:42:21,920 --> 00:42:24,400
offline

1137
00:42:24,880 --> 00:42:29,119
sorry can i ask a question sure go ahead

1138
00:42:29,280 --> 00:42:31,920
andre did you consider far falling

1139
00:42:31,920 --> 00:42:33,440
because this has kind of similar

1140
00:42:33,440 --> 00:42:36,480
structure but maybe a bit different

1141
00:42:36,480 --> 00:42:39,440
yes yes uh so so we didn't specifically

1142
00:42:39,440 --> 00:42:40,560
consider that

1143
00:42:40,560 --> 00:42:42,800
so i think that the i mean the problem

1144
00:42:42,800 --> 00:42:46,079
uh with with society so to say is uh

1145
00:42:46,079 --> 00:42:48,480
synthetic right you have you have a

1146
00:42:48,480 --> 00:42:49,440
like

1147
00:42:49,440 --> 00:42:50,720
you have several you have several

1148
00:42:50,720 --> 00:42:52,400
message blocks uh you process all of

1149
00:42:52,400 --> 00:42:54,319
them indeed you have a exhaust of

1150
00:42:54,319 --> 00:42:55,280
everything

1151
00:42:55,280 --> 00:42:58,960
and then you expand the output i guess

1152
00:42:58,960 --> 00:43:00,640
but what happens is for example if you

1153
00:43:00,640 --> 00:43:03,440
reduce this to a single block

1154
00:43:03,440 --> 00:43:05,599
uh then i think in specifically in the

1155
00:43:05,599 --> 00:43:07,440
fifa construction you already have like

1156
00:43:07,440 --> 00:43:09,920
a saw between message and key somewhere

1157
00:43:09,920 --> 00:43:12,240
also between message and secret and you

1158
00:43:12,240 --> 00:43:14,000
can already attack this with someone

1159
00:43:14,000 --> 00:43:15,760
secretary so actually i think you didn't

1160
00:43:15,760 --> 00:43:18,160
need the the linearization attack to do

1161
00:43:18,160 --> 00:43:19,359
that

1162
00:43:19,359 --> 00:43:22,319
um my guess is you could use the

1163
00:43:22,319 --> 00:43:24,400
realization if you wanted to attack some

1164
00:43:24,400 --> 00:43:27,040
kind of generalization of it

1165
00:43:27,040 --> 00:43:29,680
that would be that would look a bit like

1166
00:43:29,680 --> 00:43:31,359
like this uh like this construction on

1167
00:43:31,359 --> 00:43:32,800
this slide

1168
00:43:32,800 --> 00:43:33,839
um

1169
00:43:33,839 --> 00:43:35,599
but so i think the main problem is that

1170
00:43:35,599 --> 00:43:37,280
there is actually already an attack in

1171
00:43:37,280 --> 00:43:39,119
this reposition setting

1172
00:43:39,119 --> 00:43:43,520
so we we don't have anything new there

1173
00:43:44,079 --> 00:43:46,560
okay i see thank you

1174
00:43:46,560 --> 00:43:47,839
thank you very much i'm looking at the

1175
00:43:47,839 --> 00:43:49,680
time and i think we need to move on to

1176
00:43:49,680 --> 00:43:51,599
the next talk so thank you again

1177
00:43:51,599 --> 00:43:53,440
and yeah if you have any questions don't

1178
00:43:53,440 --> 00:43:56,319
try then put them in the chat

1179
00:43:56,319 --> 00:43:58,640
all right so let's move on to our

1180
00:43:58,640 --> 00:44:00,800
next talk and the last talk of this

1181
00:44:00,800 --> 00:44:01,839
session

1182
00:44:01,839 --> 00:44:04,160
is going to be generic framework for key

1183
00:44:04,160 --> 00:44:06,480
guessing improvements

1184
00:44:06,480 --> 00:44:09,760
by marek pro federico canale antonio

1185
00:44:09,760 --> 00:44:12,800
flores goterius gregor leander and maria

1186
00:44:12,800 --> 00:44:15,280
naya placencia and marek is going to

1187
00:44:15,280 --> 00:44:17,760
give the talk please go ahead

1188
00:44:17,760 --> 00:44:20,319
thank you very much for the introduction

1189
00:44:20,319 --> 00:44:23,680
in this paper we

1190
00:44:23,680 --> 00:44:25,040
improved the key recovery part of

1191
00:44:25,040 --> 00:44:26,880
various attacks against

1192
00:44:26,880 --> 00:44:28,560
spn cyphers

1193
00:44:28,560 --> 00:44:32,799
by looking at the s-boxes and driving

1194
00:44:35,119 --> 00:44:38,000
deriving special

1195
00:44:38,000 --> 00:44:39,520
key guessing strategies for those s

1196
00:44:39,520 --> 00:44:42,800
boxes and related functions

1197
00:44:43,280 --> 00:44:45,040
let's say we are given a cipher which is

1198
00:44:45,040 --> 00:44:46,800
subdivided into three parts then in a

1199
00:44:46,800 --> 00:44:51,119
usual key recovery attack we are

1200
00:44:52,480 --> 00:44:54,640
we are given a certain set of plaintext

1201
00:44:54,640 --> 00:44:56,960
ciphertext pairs and

1202
00:44:56,960 --> 00:44:58,800
try to guess

1203
00:44:58,800 --> 00:45:01,040
key material on the outer part of the

1204
00:45:01,040 --> 00:45:02,960
cipher to derive

1205
00:45:02,960 --> 00:45:04,319
states around the middle part of the

1206
00:45:04,319 --> 00:45:05,520
cipher

1207
00:45:05,520 --> 00:45:08,160
then we apply a distinguisher which can

1208
00:45:08,160 --> 00:45:10,319
discriminate between the right key

1209
00:45:10,319 --> 00:45:12,240
guesses and the wrong key guesses and in

1210
00:45:12,240 --> 00:45:15,760
this paper we only look at the

1211
00:45:15,760 --> 00:45:18,400
key recovery part and optimize that

1212
00:45:18,400 --> 00:45:21,839
the guessing strategy for that

1213
00:45:21,839 --> 00:45:24,000
we have two main observations the first

1214
00:45:24,000 --> 00:45:25,599
observation is that the distinguisher

1215
00:45:25,599 --> 00:45:29,359
doesn't need all of a and b

1216
00:45:29,359 --> 00:45:31,280
and therefore we don't need to guess all

1217
00:45:31,280 --> 00:45:34,720
of the outer key material k0 and k2

1218
00:45:34,720 --> 00:45:37,359
this also holds inside s boxes so if we

1219
00:45:37,359 --> 00:45:39,680
only need a few output bits of an s box

1220
00:45:39,680 --> 00:45:41,280
then

1221
00:45:41,280 --> 00:45:43,440
this this does not depend on all of the

1222
00:45:43,440 --> 00:45:45,839
input bits

1223
00:45:45,839 --> 00:45:48,079
second observation is that even if we do

1224
00:45:48,079 --> 00:45:50,400
need every uh do you need to guess every

1225
00:45:50,400 --> 00:45:51,520
key bit

1226
00:45:51,520 --> 00:45:54,240
uh we usually can cut the computation

1227
00:45:54,240 --> 00:45:55,200
short

1228
00:45:55,200 --> 00:45:57,359
because after a partial key guess the

1229
00:45:57,359 --> 00:45:59,440
relevant output bit is already fully

1230
00:45:59,440 --> 00:46:01,280
determined

1231
00:46:01,280 --> 00:46:02,800
we'll illustrate this with the following

1232
00:46:02,800 --> 00:46:05,839
example we are given a plain text m we

1233
00:46:05,839 --> 00:46:08,240
add some key material then apply forbid

1234
00:46:08,240 --> 00:46:10,720
s box and we are interested in the last

1235
00:46:10,720 --> 00:46:12,480
output bit

1236
00:46:12,480 --> 00:46:14,160
instead of guessing the key we can also

1237
00:46:14,160 --> 00:46:15,599
just guess the

1238
00:46:15,599 --> 00:46:17,599
direct input to the s box which is in

1239
00:46:17,599 --> 00:46:19,920
this case then m plus k

1240
00:46:19,920 --> 00:46:23,119
and we'll denote it by x

1241
00:46:23,200 --> 00:46:24,960
here you see um

1242
00:46:24,960 --> 00:46:27,280
we did this for the noiki and s box and

1243
00:46:27,280 --> 00:46:28,800
on the right you see

1244
00:46:28,800 --> 00:46:30,319
you see the guessing strategy in form of

1245
00:46:30,319 --> 00:46:31,599
the tree

1246
00:46:31,599 --> 00:46:34,640
you start at the root label and

1247
00:46:34,640 --> 00:46:36,720
guess the

1248
00:46:36,720 --> 00:46:39,040
linear combination of the

1249
00:46:39,040 --> 00:46:42,319
bits indicated by that label if it's

1250
00:46:42,319 --> 00:46:44,640
zero you go left if it's

1251
00:46:44,640 --> 00:46:46,720
non-zero you go right

1252
00:46:46,720 --> 00:46:47,680
and

1253
00:46:47,680 --> 00:46:49,520
at some point you will arrive in a leaf

1254
00:46:49,520 --> 00:46:51,680
and that's the desired output bit note

1255
00:46:51,680 --> 00:46:54,078
that the

1256
00:46:54,160 --> 00:46:55,839
output doesn't have to be a bit it can

1257
00:46:55,839 --> 00:46:59,040
also be a binary vector

1258
00:47:00,400 --> 00:47:02,720
if we had guessed naively we would have

1259
00:47:02,720 --> 00:47:03,680
needed

1260
00:47:03,680 --> 00:47:06,480
16 guesses in total

1261
00:47:06,480 --> 00:47:07,520
but

1262
00:47:07,520 --> 00:47:08,960
from the tree we already see the

1263
00:47:08,960 --> 00:47:11,920
function only ever depends on x0 x1 and

1264
00:47:11,920 --> 00:47:14,400
x2 therefore we can do with 8 instead of

1265
00:47:14,400 --> 00:47:17,119
16 guesses

1266
00:47:17,119 --> 00:47:20,079
and from the tree we also see that

1267
00:47:20,079 --> 00:47:21,920
we don't we don't have to guess all

1268
00:47:21,920 --> 00:47:23,280
three bits

1269
00:47:23,280 --> 00:47:25,280
in the left branch we only have to guess

1270
00:47:25,280 --> 00:47:27,520
x0 and x1 in the right branch we only

1271
00:47:27,520 --> 00:47:29,119
have to guess x1 and the linear

1272
00:47:29,119 --> 00:47:31,920
combination of x0 and x2

1273
00:47:31,920 --> 00:47:34,079
and therefore we can do with for

1274
00:47:34,079 --> 00:47:35,520
four guesses

1275
00:47:35,520 --> 00:47:37,359
this is no coincidence

1276
00:47:37,359 --> 00:47:39,599
because because we can we could show in

1277
00:47:39,599 --> 00:47:42,640
the paper that in many instances the

1278
00:47:42,640 --> 00:47:44,559
um

1279
00:47:44,559 --> 00:47:47,119
the complexity of of the

1280
00:47:47,119 --> 00:47:49,040
guessing strategy is directly related to

1281
00:47:49,040 --> 00:47:51,040
the number of leaves of a corresponding

1282
00:47:51,040 --> 00:47:53,280
tree in this case

1283
00:47:53,280 --> 00:47:55,839
we gain a factor of four

1284
00:47:55,839 --> 00:47:57,680
but we can also

1285
00:47:57,680 --> 00:47:59,680
apply this technique to

1286
00:47:59,680 --> 00:48:01,839
more than one s box and then further

1287
00:48:01,839 --> 00:48:04,319
increase the gain

1288
00:48:04,319 --> 00:48:06,000
another trick that we've introduced is

1289
00:48:06,000 --> 00:48:08,079
key absorption i won't go into details

1290
00:48:08,079 --> 00:48:08,960
here

1291
00:48:08,960 --> 00:48:10,880
but

1292
00:48:10,880 --> 00:48:13,040
basically it allows us to

1293
00:48:13,040 --> 00:48:14,960
join certain

1294
00:48:14,960 --> 00:48:16,640
key guesses in

1295
00:48:16,640 --> 00:48:18,640
subsequent rounds into a single guess

1296
00:48:18,640 --> 00:48:21,200
and then by that reducing the number of

1297
00:48:21,200 --> 00:48:23,119
guesses in total

1298
00:48:23,119 --> 00:48:24,559
for more details please consult our

1299
00:48:24,559 --> 00:48:27,200
paper on that

1300
00:48:27,280 --> 00:48:30,000
our attack can be applied to many our

1301
00:48:30,000 --> 00:48:32,000
methods can be applied to many types of

1302
00:48:32,000 --> 00:48:33,040
attacks

1303
00:48:33,040 --> 00:48:35,280
for example we applied it to a linear

1304
00:48:35,280 --> 00:48:37,359
attack against noikion to a rectangle

1305
00:48:37,359 --> 00:48:39,359
attack against gif to a

1306
00:48:39,359 --> 00:48:41,200
differential attack again attack against

1307
00:48:41,200 --> 00:48:43,760
rectangle and to a

1308
00:48:43,760 --> 00:48:44,960
sieve in the middle attack against

1309
00:48:44,960 --> 00:48:47,040
present the last one is noteworthy

1310
00:48:47,040 --> 00:48:49,280
because it's neither a linear type nor

1311
00:48:49,280 --> 00:48:52,400
differential type attack

1312
00:48:52,960 --> 00:48:55,520
thank you very much for listening

1313
00:48:55,520 --> 00:48:57,040
if you're interested in further details

1314
00:48:57,040 --> 00:48:58,000
please

1315
00:48:58,000 --> 00:49:00,839
look at our paper on

1316
00:49:00,839 --> 00:49:04,400
eprint you very much for your talk and i

1317
00:49:04,400 --> 00:49:06,400
see that we actually have two very

1318
00:49:06,400 --> 00:49:09,040
specific questions in the zulu chapter

1319
00:49:09,040 --> 00:49:10,800
so let me

1320
00:49:10,800 --> 00:49:12,400
read the first one

1321
00:49:12,400 --> 00:49:14,559
um in the description of the boomerang

1322
00:49:14,559 --> 00:49:18,079
attack on rectangle 80 step one you said

1323
00:49:18,079 --> 00:49:20,559
just as an example in order to guess the

1324
00:49:20,559 --> 00:49:23,920
relevant key material for xbox seven we

1325
00:49:23,920 --> 00:49:26,319
can compute both the good pairs and the

1326
00:49:26,319 --> 00:49:28,720
linear relations for the active output

1327
00:49:28,720 --> 00:49:31,280
bit y zero necessary for the key

1328
00:49:31,280 --> 00:49:33,520
absorption in step two with an average

1329
00:49:33,520 --> 00:49:36,800
number of key guesses 2 times 1 8 plus 7

1330
00:49:36,800 --> 00:49:38,720
times 7 8

1331
00:49:38,720 --> 00:49:42,240
is equal to 2 to the power 2.73

1332
00:49:42,240 --> 00:49:45,040
i want to know uh what does the seven

1333
00:49:45,040 --> 00:49:48,559
times seven over eight mean here how can

1334
00:49:48,559 --> 00:49:51,200
you get the number seven

1335
00:49:51,200 --> 00:49:52,960
so if you yeah if you can read the the

1336
00:49:52,960 --> 00:49:55,520
the chart uh as a zodiac chapter right i

1337
00:49:55,520 --> 00:49:56,800
can't read the

1338
00:49:56,800 --> 00:49:59,040
chat because i'm not locked in there

1339
00:49:59,040 --> 00:50:01,440
oh okay

1340
00:50:01,440 --> 00:50:03,760
so well okay it's a bit specific

1341
00:50:03,760 --> 00:50:06,160
question and here it is thank you

1342
00:50:06,160 --> 00:50:09,160
thanks

1343
00:50:20,960 --> 00:50:23,680
i i don't i can't answer the question

1344
00:50:23,680 --> 00:50:25,680
from the top of my head i'm sorry

1345
00:50:25,680 --> 00:50:27,440
right so i think that it would maybe

1346
00:50:27,440 --> 00:50:30,160
make sense to to just uh uh uh chat

1347
00:50:30,160 --> 00:50:31,920
offline and then yeah explain this is a

1348
00:50:31,920 --> 00:50:34,240
bit specific and i don't know what about

1349
00:50:34,240 --> 00:50:36,559
that and write it in the zoom but if i

1350
00:50:36,559 --> 00:50:38,559
forget please write uh drop us an email

1351
00:50:38,559 --> 00:50:40,720
then we will answer that question

1352
00:50:40,720 --> 00:50:42,079
that makes sense

1353
00:50:42,079 --> 00:50:43,520
and then i think that the second

1354
00:50:43,520 --> 00:50:45,440
question is also pretty specific because

1355
00:50:45,440 --> 00:50:49,440
it asks about you know the derivation of

1356
00:50:49,440 --> 00:50:52,640
complexity in appendix e2 right so that

1357
00:50:52,640 --> 00:50:55,280
might be probably also hard to to answer

1358
00:50:55,280 --> 00:50:56,480
right now

1359
00:50:56,480 --> 00:50:59,520
just one quick question from from me uh

1360
00:50:59,520 --> 00:51:01,599
so you said that you know one of those

1361
00:51:01,599 --> 00:51:03,359
strategies is the ski absorption

1362
00:51:03,359 --> 00:51:05,680
strategy do you think that this can be

1363
00:51:05,680 --> 00:51:07,440
somehow combined with the knowledge of

1364
00:51:07,440 --> 00:51:09,200
the key schedule and then you know this

1365
00:51:09,200 --> 00:51:10,960
could improve somehow those

1366
00:51:10,960 --> 00:51:13,440
attacks

1367
00:51:14,480 --> 00:51:16,330
theoretically yes because

1368
00:51:16,330 --> 00:51:19,460
[Music]

1369
00:51:19,839 --> 00:51:21,680
i mean the key guessing so the key

1370
00:51:21,680 --> 00:51:24,240
absorption in more in detail works like

1371
00:51:24,240 --> 00:51:27,040
this you have to uh you your last guess

1372
00:51:27,040 --> 00:51:29,119
the last guess that you do for a certain

1373
00:51:29,119 --> 00:51:32,079
bit that you need in the second round

1374
00:51:32,079 --> 00:51:36,480
uh can just be written as an um

1375
00:51:36,480 --> 00:51:38,960
a second

1376
00:51:38,960 --> 00:51:41,520
can just be written as a

1377
00:51:41,520 --> 00:51:44,079
additive term uh

1378
00:51:44,079 --> 00:51:45,040
to a

1379
00:51:45,040 --> 00:51:48,160
nonlinear function and then to the

1380
00:51:48,160 --> 00:51:50,640
next key guess that you need

1381
00:51:50,640 --> 00:51:53,520
and if you have uh if you skip

1382
00:51:53,520 --> 00:51:56,400
the key schedule uh

1383
00:51:56,400 --> 00:51:58,800
there then you might have you might see

1384
00:51:58,800 --> 00:52:00,400
relations between single key bits in the

1385
00:52:00,400 --> 00:52:03,200
key schedule

1386
00:52:03,200 --> 00:52:04,880
therefore i would think it might be

1387
00:52:04,880 --> 00:52:07,520
possible but it would be probably uh

1388
00:52:07,520 --> 00:52:10,559
involved to look at this

1389
00:52:10,800 --> 00:52:12,319
all right thank you

1390
00:52:12,319 --> 00:52:14,400
i think we are running out of time so if

1391
00:52:14,400 --> 00:52:15,839
there are no other

1392
00:52:15,839 --> 00:52:17,599
questions then thank you again for the

1393
00:52:17,599 --> 00:52:20,000
talk and i'm turning it back to mitsuru

1394
00:52:20,000 --> 00:52:21,839
to close the session

1395
00:52:21,839 --> 00:52:23,440
okay thank you very much for uh

1396
00:52:23,440 --> 00:52:25,520
christian also uh

1397
00:52:25,520 --> 00:52:27,760
so i would like to put succession uh

1398
00:52:27,760 --> 00:52:30,079
thank you very much for uh

1399
00:52:30,079 --> 00:52:31,119
speakers

1400
00:52:31,119 --> 00:52:32,480
and uh

1401
00:52:32,480 --> 00:52:34,240
uh

1402
00:52:34,240 --> 00:52:37,040
thank you very much for uh audiences to

1403
00:52:37,040 --> 00:52:39,599
join the session and uh discussions

1404
00:52:39,599 --> 00:52:41,760
okay oh thank you very much

1405
00:52:41,760 --> 00:52:44,400
so please enjoy the last session in the

1406
00:52:44,400 --> 00:52:45,280
asian

1407
00:52:45,280 --> 00:52:47,960
uh starting within

1408
00:52:47,960 --> 00:52:50,000
38 minutes

1409
00:52:50,000 --> 00:52:51,599
thank you very much for joining thank

1410
00:52:51,599 --> 00:52:53,599
you very much to everyone thank you

1411
00:52:53,599 --> 00:52:56,160
thank you

