1
00:00:02,560 --> 00:00:04,560
yes you're ready to go

2
00:00:04,560 --> 00:00:05,759
okay

3
00:00:05,759 --> 00:00:08,880
yes welcome everyone to this uh

4
00:00:08,880 --> 00:00:11,200
session on a pubic key crypt analysis an

5
00:00:11,200 --> 00:00:13,440
authenticated key exchange

6
00:00:13,440 --> 00:00:16,480
so with fabrics ben amuda we will

7
00:00:16,480 --> 00:00:18,480
monitor the question and introduce the

8
00:00:18,480 --> 00:00:20,240
speakers

9
00:00:20,240 --> 00:00:22,640
so we we organize in uh

10
00:00:22,640 --> 00:00:24,400
10 minutes for each talk like five

11
00:00:24,400 --> 00:00:27,519
minutes of presentation then right after

12
00:00:27,519 --> 00:00:30,560
the questions that you can ask on the

13
00:00:30,560 --> 00:00:32,960
on the chat on the lip

14
00:00:32,960 --> 00:00:35,120
and or also in

15
00:00:35,120 --> 00:00:35,920
you

16
00:00:35,920 --> 00:00:38,320
will see if you can unmute yourself

17
00:00:38,320 --> 00:00:41,280
during the zoom

18
00:00:41,680 --> 00:00:42,640
then

19
00:00:42,640 --> 00:00:46,000
our first speaker today is

20
00:00:46,000 --> 00:00:48,160
julian novakovsky

21
00:00:48,160 --> 00:00:50,559
and he will present

22
00:00:50,559 --> 00:00:52,960
his work on partial key exposure attack

23
00:00:52,960 --> 00:00:55,840
on short secret exponent ctressa

24
00:00:55,840 --> 00:00:59,840
you learn it to you

25
00:01:00,239 --> 00:01:03,280
just one second my laptop is doing

26
00:01:03,280 --> 00:01:05,680
something strange but i guess i have it

27
00:01:05,680 --> 00:01:09,200
fixed in like 10 seconds

28
00:01:09,680 --> 00:01:12,400
okay now it should be fine

29
00:01:12,400 --> 00:01:13,360
you can

30
00:01:13,360 --> 00:01:15,439
you can still hear me

31
00:01:15,439 --> 00:01:16,880
yes we can

32
00:01:16,880 --> 00:01:19,880
okay

33
00:01:30,400 --> 00:01:31,439
yeah so

34
00:01:31,439 --> 00:01:33,439
thanks thanks for the introduction this

35
00:01:33,439 --> 00:01:35,200
is joint work with alexander mai and

36
00:01:35,200 --> 00:01:37,280
santanusaka

37
00:01:37,280 --> 00:01:39,040
before we talk about short secret

38
00:01:39,040 --> 00:01:40,880
exponents here trsa i would like to have

39
00:01:40,880 --> 00:01:42,479
a few words on

40
00:01:42,479 --> 00:01:44,960
secret exponent rsa for that let me

41
00:01:44,960 --> 00:01:47,280
quickly fix some notation so as usual in

42
00:01:47,280 --> 00:01:49,200
rsi we denote the public key by a tuple

43
00:01:49,200 --> 00:01:52,320
n e the private key by a tuple md

44
00:01:52,320 --> 00:01:54,560
now the point with short secret exponent

45
00:01:54,560 --> 00:01:57,439
rsa is that d is significantly smaller

46
00:01:57,439 --> 00:01:59,040
than n

47
00:01:59,040 --> 00:02:01,040
if we want to discuss the following

48
00:02:01,040 --> 00:02:02,399
simple question

49
00:02:02,399 --> 00:02:04,880
how many bits of d do we have to know to

50
00:02:04,880 --> 00:02:07,360
break rsa in polynomial time

51
00:02:07,360 --> 00:02:10,160
the answer is quite nice for rsa

52
00:02:10,160 --> 00:02:11,280
it is

53
00:02:11,280 --> 00:02:13,520
the smaller d the less bits you have to

54
00:02:13,520 --> 00:02:16,239
know and in addition as long as d is

55
00:02:16,239 --> 00:02:18,080
really smaller than n then you have to

56
00:02:18,080 --> 00:02:21,440
know less than 100 of the bits

57
00:02:21,440 --> 00:02:23,599
let's illustrate this a bit so on the

58
00:02:23,599 --> 00:02:26,000
horizontal axis we draw how large d is

59
00:02:26,000 --> 00:02:27,760
in comparison to n and on the vertical

60
00:02:27,760 --> 00:02:30,080
axis we draw how large of a fraction of

61
00:02:30,080 --> 00:02:32,160
bits of d we have to know to break rsa

62
00:02:32,160 --> 00:02:33,920
in polynomial time

63
00:02:33,920 --> 00:02:35,920
and as you may know there are these

64
00:02:35,920 --> 00:02:37,840
famous results by reena and bernie and

65
00:02:37,840 --> 00:02:39,680
durfee and they show that if you are

66
00:02:39,680 --> 00:02:42,480
actually below this 0.292 pound here

67
00:02:42,480 --> 00:02:43,920
well then you don't have to know any

68
00:02:43,920 --> 00:02:46,000
bits at all

69
00:02:46,000 --> 00:02:49,280
but you can show much more than this and

70
00:02:49,280 --> 00:02:51,760
this uh these results here and they

71
00:02:51,760 --> 00:02:54,400
nicely extend this and what you can see

72
00:02:54,400 --> 00:02:56,480
is that if you are slightly above this

73
00:02:56,480 --> 00:02:58,560
bound of 0.292 then you have to know a

74
00:02:58,560 --> 00:03:00,159
really small fraction of bits to break

75
00:03:00,159 --> 00:03:02,560
our same polynomial time and then the

76
00:03:02,560 --> 00:03:04,560
larger id gets the more bits you have to

77
00:03:04,560 --> 00:03:06,720
know but as you can see as long as d

78
00:03:06,720 --> 00:03:09,040
really is smaller than n then

79
00:03:09,040 --> 00:03:11,680
less than 100 percent of the bits of t

80
00:03:11,680 --> 00:03:13,920
are sufficient

81
00:03:13,920 --> 00:03:15,599
now in our paper we looked at short

82
00:03:15,599 --> 00:03:17,760
secret exponents here trsa now the

83
00:03:17,760 --> 00:03:19,840
public key is exactly the same as an rsa

84
00:03:19,840 --> 00:03:21,040
but the private key looks a bit

85
00:03:21,040 --> 00:03:22,480
different instead of having just one

86
00:03:22,480 --> 00:03:24,480
secret exponent d we now have two secret

87
00:03:24,480 --> 00:03:27,040
exponents dp and dq and here the thing

88
00:03:27,040 --> 00:03:29,519
with short secret exponent is that now

89
00:03:29,519 --> 00:03:31,280
dp and dq are

90
00:03:31,280 --> 00:03:32,959
significantly smaller than the square

91
00:03:32,959 --> 00:03:34,879
root of n

92
00:03:34,879 --> 00:03:37,280
we basically asked the cit rsa

93
00:03:37,280 --> 00:03:38,879
counterpart of this question here on the

94
00:03:38,879 --> 00:03:41,920
left we asked how many bits of dp and dq

95
00:03:41,920 --> 00:03:43,920
do we have to know to break crt rsa

96
00:03:43,920 --> 00:03:46,640
polynomial time

97
00:03:46,640 --> 00:03:49,840
so far pretty much nothing was known uh

98
00:03:49,840 --> 00:03:52,159
for this question but what we found is

99
00:03:52,159 --> 00:03:54,319
um yeah basically the perfect

100
00:03:54,319 --> 00:03:56,480
counterpart to this here on the left we

101
00:03:56,480 --> 00:03:59,599
found the smaller dp and dqr the list

102
00:03:59,599 --> 00:04:01,840
bits you have to know and similarly as

103
00:04:01,840 --> 00:04:04,319
on the left if the p and dq really are

104
00:04:04,319 --> 00:04:06,560
smaller than the square root of n then

105
00:04:06,560 --> 00:04:08,560
you also have to know less than 100

106
00:04:08,560 --> 00:04:10,480
percent of the bits

107
00:04:10,480 --> 00:04:12,799
let's also visualize this so now we see

108
00:04:12,799 --> 00:04:14,640
on the horizontal axis how large the p

109
00:04:14,640 --> 00:04:16,798
and q are and again on the vertical axis

110
00:04:16,798 --> 00:04:18,880
we see how large of a fraction of bits

111
00:04:18,880 --> 00:04:21,040
we have to know not to break citr's a in

112
00:04:21,040 --> 00:04:22,560
polynomial time

113
00:04:22,560 --> 00:04:25,520
and actually for quite a long time there

114
00:04:25,520 --> 00:04:28,320
weren't even results like the wiener and

115
00:04:28,320 --> 00:04:31,040
near durfee results for rsa

116
00:04:31,040 --> 00:04:34,320
until then in 2007 johansen mai finally

117
00:04:34,320 --> 00:04:35,840
could show something and they showed

118
00:04:35,840 --> 00:04:37,560
that if you are below

119
00:04:37,560 --> 00:04:39,759
0.073 then you don't have to know any

120
00:04:39,759 --> 00:04:40,960
bits at all

121
00:04:40,960 --> 00:04:43,040
then for 10 years this was the only

122
00:04:43,040 --> 00:04:45,280
thing that we knew but quite recently

123
00:04:45,280 --> 00:04:47,280
this has been improved by takayasu liu

124
00:04:47,280 --> 00:04:48,560
and peng

125
00:04:48,560 --> 00:04:50,720
first in 2017 and then shortly after

126
00:04:50,720 --> 00:04:53,199
again in 2019 and now we know that

127
00:04:53,199 --> 00:04:55,360
actually if you are below sorry

128
00:04:55,360 --> 00:04:58,000
if you are below 0.122 then you don't

129
00:04:58,000 --> 00:05:00,160
have to know any bits at all

130
00:05:00,160 --> 00:05:02,160
the reason that this took so long is

131
00:05:02,160 --> 00:05:05,600
that when compared to the attacks on rsa

132
00:05:05,600 --> 00:05:07,680
these three attacks here are much more

133
00:05:07,680 --> 00:05:08,800
difficult

134
00:05:08,800 --> 00:05:10,560
they are all based on coppersmiths

135
00:05:10,560 --> 00:05:14,400
method and especially this tlp 19 attack

136
00:05:14,400 --> 00:05:16,160
is perhaps in all of the coppersmiths

137
00:05:16,160 --> 00:05:19,360
type literary literate literature

138
00:05:19,360 --> 00:05:21,680
the most difficult paper published so

139
00:05:21,680 --> 00:05:22,720
far

140
00:05:22,720 --> 00:05:24,400
and therefore it took

141
00:05:24,400 --> 00:05:26,240
quite some years until

142
00:05:26,240 --> 00:05:28,320
somebody was able to show

143
00:05:28,320 --> 00:05:29,680
anything

144
00:05:29,680 --> 00:05:31,680
and what we did now is we took another

145
00:05:31,680 --> 00:05:34,000
look at this tlp 19 um

146
00:05:34,000 --> 00:05:36,400
attack and its proof and what we could

147
00:05:36,400 --> 00:05:38,800
do is we could significantly simplify

148
00:05:38,800 --> 00:05:39,840
its proof

149
00:05:39,840 --> 00:05:41,919
especially we could give much more

150
00:05:41,919 --> 00:05:44,400
intuition on the proof than the original

151
00:05:44,400 --> 00:05:45,600
work did

152
00:05:45,600 --> 00:05:47,680
and then this intuition helped us to

153
00:05:47,680 --> 00:05:48,800
generalize

154
00:05:48,800 --> 00:05:51,759
this proof and with this generalization

155
00:05:51,759 --> 00:05:53,759
we obtained a partial key exposure

156
00:05:53,759 --> 00:05:56,479
attack and its graph looks like this

157
00:05:56,479 --> 00:05:58,560
yeah so what we showed is essentially

158
00:05:58,560 --> 00:06:00,639
the counterpart to the results already

159
00:06:00,639 --> 00:06:03,840
known for rsa we now know if we are

160
00:06:03,840 --> 00:06:06,080
slightly above this bound the previously

161
00:06:06,080 --> 00:06:07,280
known bound then we have to know a

162
00:06:07,280 --> 00:06:08,880
really small fraction of bits and then

163
00:06:08,880 --> 00:06:11,120
the larger dp and b you get the more

164
00:06:11,120 --> 00:06:12,720
bits we have to know

165
00:06:12,720 --> 00:06:13,600
and

166
00:06:13,600 --> 00:06:15,280
as long as we are below the square root

167
00:06:15,280 --> 00:06:17,199
of n you really have to know less than

168
00:06:17,199 --> 00:06:19,520
100 of the bits

169
00:06:19,520 --> 00:06:22,000
okay i guess that's already everything

170
00:06:22,000 --> 00:06:24,479
um i can show you in five minutes uh

171
00:06:24,479 --> 00:06:26,880
much more details and uh details on the

172
00:06:26,880 --> 00:06:29,440
intuition of our new proof is given in

173
00:06:29,440 --> 00:06:30,400
the full

174
00:06:30,400 --> 00:06:31,840
version of this talk which you can find

175
00:06:31,840 --> 00:06:33,520
on youtube and

176
00:06:33,520 --> 00:06:37,520
yeah thanks thanks for your attention

177
00:06:40,720 --> 00:06:41,680
thank you

178
00:06:41,680 --> 00:06:43,759
thank you for another talk

179
00:06:43,759 --> 00:06:47,919
are there any questions i'm checking the

180
00:06:47,919 --> 00:06:50,240
zulip

181
00:06:50,240 --> 00:06:52,560
or you can

182
00:06:52,560 --> 00:06:54,160
ask in the zoom

183
00:06:54,160 --> 00:06:57,990
directly and mute yourself

184
00:06:57,990 --> 00:06:59,199
[Music]

185
00:06:59,199 --> 00:07:01,599
so i have a have a question and who are

186
00:07:01,599 --> 00:07:04,160
waiting for the other to ask

187
00:07:04,160 --> 00:07:06,400
so i'm

188
00:07:06,400 --> 00:07:08,960
in your longer talk in the video you

189
00:07:08,960 --> 00:07:10,800
present this nice

190
00:07:10,800 --> 00:07:14,199
geometric way of having a

191
00:07:14,199 --> 00:07:16,720
intuition on how to uh improve the

192
00:07:16,720 --> 00:07:18,880
polynomial so that the attack will work

193
00:07:18,880 --> 00:07:21,280
so where does this uh geometric view

194
00:07:21,280 --> 00:07:23,758
come from

195
00:07:27,360 --> 00:07:30,080
so what i i skipped in the in the longer

196
00:07:30,080 --> 00:07:32,560
talk for simplicity there's actually a

197
00:07:32,560 --> 00:07:34,800
whole theory behind this i called mutant

198
00:07:34,800 --> 00:07:37,440
polytopes uh we give a bit more on this

199
00:07:37,440 --> 00:07:38,639
in the paper

200
00:07:38,639 --> 00:07:41,919
this was already used in an rsa by

201
00:07:41,919 --> 00:07:44,639
bloomer in my in the early 2000's i

202
00:07:44,639 --> 00:07:45,759
guess

203
00:07:45,759 --> 00:07:48,879
perhaps your crypt paper it's called a

204
00:07:48,879 --> 00:07:53,680
toolkit for solving polynomial equations

205
00:07:53,680 --> 00:07:55,840
they're already something similar

206
00:07:55,840 --> 00:07:58,479
appears

207
00:07:58,479 --> 00:07:59,759
thank you

208
00:07:59,759 --> 00:08:02,000
and in the

209
00:08:02,000 --> 00:08:03,919
um

210
00:08:03,919 --> 00:08:06,560
in maybe in the experiment um so you

211
00:08:06,560 --> 00:08:08,080
have to

212
00:08:08,080 --> 00:08:11,280
to run a lattice reduction to to reduce

213
00:08:11,280 --> 00:08:13,520
the coefficient polynomials and then

214
00:08:13,520 --> 00:08:16,159
find roots

215
00:08:17,199 --> 00:08:18,080
and

216
00:08:18,080 --> 00:08:21,199
so did you use a particular library to

217
00:08:21,199 --> 00:08:23,599
run some experiments

218
00:08:23,599 --> 00:08:25,759
yeah we just used the

219
00:08:25,759 --> 00:08:28,240
standard things from sage

220
00:08:28,240 --> 00:08:29,680
yeah so i guess

221
00:08:29,680 --> 00:08:31,919
if you use something uh

222
00:08:31,919 --> 00:08:33,919
more clever that you could get even

223
00:08:33,919 --> 00:08:36,320
better results and stronger experimental

224
00:08:36,320 --> 00:08:38,719
results

225
00:08:39,039 --> 00:08:41,599
okay so now we have a question from um

226
00:08:41,599 --> 00:08:43,839
ian juncker um

227
00:08:43,839 --> 00:08:46,000
question for julian do you see any

228
00:08:46,000 --> 00:08:48,000
possibilities for improvement of the

229
00:08:48,000 --> 00:08:49,040
attack

230
00:08:49,040 --> 00:08:51,519
anywhere where future work might lead to

231
00:08:51,519 --> 00:08:52,839
something

232
00:08:52,839 --> 00:08:54,800
interesting

233
00:08:54,800 --> 00:08:58,560
yes so far our attack only works for

234
00:08:58,560 --> 00:09:01,200
exposed least significant bits

235
00:09:01,200 --> 00:09:03,279
and the attacks on rsa

236
00:09:03,279 --> 00:09:05,440
usually also work for exposed most

237
00:09:05,440 --> 00:09:07,839
significant bits

238
00:09:07,839 --> 00:09:10,240
tried some things to also make our

239
00:09:10,240 --> 00:09:12,240
attack work for more significant bits

240
00:09:12,240 --> 00:09:14,800
but all the known techniques for rsa

241
00:09:14,800 --> 00:09:17,200
they they seem to not translate to crt

242
00:09:17,200 --> 00:09:20,320
rsa so this is perhaps interesting to

243
00:09:20,320 --> 00:09:22,640
look at because i guess you have to find

244
00:09:22,640 --> 00:09:25,279
some new techniques to get something for

245
00:09:25,279 --> 00:09:27,439
that

246
00:09:33,920 --> 00:09:37,399
okay thank you

247
00:09:42,000 --> 00:09:44,320
when if there are no more questions we

248
00:09:44,320 --> 00:09:45,040
will

249
00:09:45,040 --> 00:09:47,120
ask the remaining question at the end of

250
00:09:47,120 --> 00:09:48,399
the session

251
00:09:48,399 --> 00:09:50,160
and thank you again very much for your

252
00:09:50,160 --> 00:09:51,839
talk

253
00:09:51,839 --> 00:09:55,519
and then our next speaker

254
00:09:55,519 --> 00:09:58,320
uh will be

255
00:09:58,320 --> 00:10:02,160
uh vladimir glasek and he will present a

256
00:10:02,160 --> 00:10:05,760
work on a formula for disaster a unified

257
00:10:05,760 --> 00:10:08,560
unified approach to elliptical special

258
00:10:08,560 --> 00:10:12,160
special point based attack

259
00:10:14,000 --> 00:10:18,519
hello and thanks for the introduction

260
00:10:19,519 --> 00:10:21,360
so let us imagine

261
00:10:21,360 --> 00:10:23,120
you are a developer who wants to

262
00:10:23,120 --> 00:10:24,640
implement ecc

263
00:10:24,640 --> 00:10:26,880
you have quite many choices to make you

264
00:10:26,880 --> 00:10:29,040
need to decide which curve model you

265
00:10:29,040 --> 00:10:30,240
will use

266
00:10:30,240 --> 00:10:32,320
what type of point representation you

267
00:10:32,320 --> 00:10:34,160
will choose

268
00:10:34,160 --> 00:10:35,440
then you need to

269
00:10:35,440 --> 00:10:37,519
pick a formula for adding two elliptic

270
00:10:37,519 --> 00:10:38,720
curve points

271
00:10:38,720 --> 00:10:40,880
and finally you need to decide which

272
00:10:40,880 --> 00:10:44,320
scalar multiplication algorithm to use

273
00:10:44,320 --> 00:10:46,640
and in our work we mostly focused on the

274
00:10:46,640 --> 00:10:48,160
formula part

275
00:10:48,160 --> 00:10:49,120
so

276
00:10:49,120 --> 00:10:52,160
how does an addition formula look like

277
00:10:52,160 --> 00:10:54,079
it takes as inputs

278
00:10:54,079 --> 00:10:55,920
two elliptic curve points

279
00:10:55,920 --> 00:10:57,120
and

280
00:10:57,120 --> 00:10:58,720
sequentially it

281
00:10:58,720 --> 00:11:00,480
computes the output in the same

282
00:11:00,480 --> 00:11:02,560
representation

283
00:11:02,560 --> 00:11:04,480
but you only have quite a few choices

284
00:11:04,480 --> 00:11:06,560
for these formulas here you can see

285
00:11:06,560 --> 00:11:09,680
the explicit formulas database

286
00:11:09,680 --> 00:11:12,399
and in the right column you can see the

287
00:11:12,399 --> 00:11:15,279
number of formulas for every specific

288
00:11:15,279 --> 00:11:17,760
setup composed of the modal coordinates

289
00:11:17,760 --> 00:11:19,279
and representation

290
00:11:19,279 --> 00:11:21,519
so there are lots of them

291
00:11:21,519 --> 00:11:23,680
but why does it matter to

292
00:11:23,680 --> 00:11:25,279
choose the right formula the thing is

293
00:11:25,279 --> 00:11:27,360
that some formulas have exceptional

294
00:11:27,360 --> 00:11:28,640
cases meaning

295
00:11:28,640 --> 00:11:30,320
there are exist points

296
00:11:30,320 --> 00:11:32,720
that when you add them using the formula

297
00:11:32,720 --> 00:11:35,040
will give you the wrong result

298
00:11:35,040 --> 00:11:37,360
and in the past this has really been

299
00:11:37,360 --> 00:11:38,880
quite an issue

300
00:11:38,880 --> 00:11:40,320
in several

301
00:11:40,320 --> 00:11:43,360
big cryptographic libraries

302
00:11:43,360 --> 00:11:45,760
so one of our goals was to try to

303
00:11:45,760 --> 00:11:48,160
classify all possible exceptional cases

304
00:11:48,160 --> 00:11:50,639
in the efd formulas

305
00:11:50,639 --> 00:11:53,440
and we used both an automated fuzzing

306
00:11:53,440 --> 00:11:55,600
approach as well as manual analysis to

307
00:11:55,600 --> 00:11:57,519
do this

308
00:11:57,519 --> 00:11:59,839
and we really did succeed

309
00:11:59,839 --> 00:12:01,120
we went through

310
00:12:01,120 --> 00:12:03,519
all these addition and differential

311
00:12:03,519 --> 00:12:05,839
addition formulas in the efd and

312
00:12:05,839 --> 00:12:07,760
classified exceptions

313
00:12:07,760 --> 00:12:10,320
and we found a new family of exceptional

314
00:12:10,320 --> 00:12:13,040
points for one specific formula you can

315
00:12:13,040 --> 00:12:15,279
see the family here

316
00:12:15,279 --> 00:12:16,399
okay so

317
00:12:16,399 --> 00:12:17,760
what do you do when you have these

318
00:12:17,760 --> 00:12:19,519
exceptional points

319
00:12:19,519 --> 00:12:21,519
there is the exceptional procedure

320
00:12:21,519 --> 00:12:23,360
attack or epa

321
00:12:23,360 --> 00:12:25,279
but i don't have time to tell you more

322
00:12:25,279 --> 00:12:27,839
about it here instead let me mention

323
00:12:27,839 --> 00:12:29,519
that there are also two other attacks

324
00:12:29,519 --> 00:12:32,160
that actually do not use exceptional

325
00:12:32,160 --> 00:12:33,360
points

326
00:12:33,360 --> 00:12:35,839
refined power analysis or rpa

327
00:12:35,839 --> 00:12:38,880
and zero value point or gvp

328
00:12:38,880 --> 00:12:41,120
but we noticed that these three attacks

329
00:12:41,120 --> 00:12:43,040
have quite a lot in common

330
00:12:43,040 --> 00:12:45,760
so another goal of our work was to

331
00:12:45,760 --> 00:12:48,079
unify and generalize these attacks in a

332
00:12:48,079 --> 00:12:49,680
common framework

333
00:12:49,680 --> 00:12:51,839
so very briefly how does that look like

334
00:12:51,839 --> 00:12:54,480
the common goal of the attacks is to

335
00:12:54,480 --> 00:12:57,120
recover the secret scalar from some ecc

336
00:12:57,120 --> 00:12:59,760
implementation

337
00:12:59,760 --> 00:13:02,000
in each of these cases you have some

338
00:13:02,000 --> 00:13:05,200
cell channel that that can differ

339
00:13:05,200 --> 00:13:06,639
and

340
00:13:06,639 --> 00:13:09,040
the common part is first you guess some

341
00:13:09,040 --> 00:13:11,519
prefix of the secret key

342
00:13:11,519 --> 00:13:14,160
then you construct a special point based

343
00:13:14,160 --> 00:13:16,079
on your guess and the given formula this

344
00:13:16,079 --> 00:13:17,519
is important

345
00:13:17,519 --> 00:13:19,279
you give this special point to the

346
00:13:19,279 --> 00:13:20,560
implementation

347
00:13:20,560 --> 00:13:22,480
and you can verify if your guess was

348
00:13:22,480 --> 00:13:25,200
correct using a site channel

349
00:13:25,200 --> 00:13:27,279
and you just repeat this

350
00:13:27,279 --> 00:13:29,200
all over again until you recover all

351
00:13:29,200 --> 00:13:32,160
bits of the private key

352
00:13:32,160 --> 00:13:35,279
so to summarize our contributions

353
00:13:35,279 --> 00:13:36,320
are

354
00:13:36,320 --> 00:13:38,880
we released an open source tool for

355
00:13:38,880 --> 00:13:40,959
unrolling formulas which can help you

356
00:13:40,959 --> 00:13:43,760
understand better what's going on

357
00:13:43,760 --> 00:13:45,199
we managed to

358
00:13:45,199 --> 00:13:46,560
classify

359
00:13:46,560 --> 00:13:48,959
all the

360
00:13:48,959 --> 00:13:50,880
all the additional formulas in the efd

361
00:13:50,880 --> 00:13:53,600
and found new exceptions

362
00:13:53,600 --> 00:13:56,399
we designed a unified framework for the

363
00:13:56,399 --> 00:13:58,480
free attacks i mentioned and we also

364
00:13:58,480 --> 00:14:01,279
managed to adapt the zvp attack against

365
00:14:01,279 --> 00:14:03,040
window methods

366
00:14:03,040 --> 00:14:04,880
which is quite new

367
00:14:04,880 --> 00:14:07,920
and we also managed to solve new cases

368
00:14:07,920 --> 00:14:10,320
of the underlying heart math problem

369
00:14:10,320 --> 00:14:12,320
but it does not help the attacks that

370
00:14:12,320 --> 00:14:14,000
much in general so

371
00:14:14,000 --> 00:14:16,320
the problem still remains open and

372
00:14:16,320 --> 00:14:18,079
that's everything for this

373
00:14:18,079 --> 00:14:19,920
short overview thank you and if you are

374
00:14:19,920 --> 00:14:22,240
interested you can find more materials

375
00:14:22,240 --> 00:14:23,519
at this link

376
00:14:23,519 --> 00:14:26,519
thanks

377
00:14:30,079 --> 00:14:31,680
thank you very much and thank you for

378
00:14:31,680 --> 00:14:35,199
the the long talk and in the video too

379
00:14:35,199 --> 00:14:36,240
um

380
00:14:36,240 --> 00:14:39,040
so my my question is that

381
00:14:39,040 --> 00:14:41,279
is it common to find such pair of

382
00:14:41,279 --> 00:14:42,880
exceptional points like the one you

383
00:14:42,880 --> 00:14:44,800
identify for the

384
00:14:44,800 --> 00:14:48,480
the formula 2007 adds bl

385
00:14:48,480 --> 00:14:50,880
then you you obtain that

386
00:14:50,880 --> 00:14:54,880
x1 minus y1 0 and x2

387
00:14:54,880 --> 00:14:55,920
y2

388
00:14:55,920 --> 00:14:58,959
0 are are making a

389
00:14:58,959 --> 00:15:00,560
failure in the

390
00:15:00,560 --> 00:15:03,040
in the algorithm i mean

391
00:15:03,040 --> 00:15:05,040
they are giving a zero that you can

392
00:15:05,040 --> 00:15:06,240
identify

393
00:15:06,240 --> 00:15:08,480
um is it common to find such pair of

394
00:15:08,480 --> 00:15:11,440
point on any elliptic curve

395
00:15:11,440 --> 00:15:13,760
are there many pair of such points on

396
00:15:13,760 --> 00:15:16,720
any elliptic curves

397
00:15:16,880 --> 00:15:18,160
yeah so so

398
00:15:18,160 --> 00:15:20,800
in general uh like across all the

399
00:15:20,800 --> 00:15:21,920
formulas

400
00:15:21,920 --> 00:15:24,320
it's it's quite quite a rare find

401
00:15:24,320 --> 00:15:26,480
like uh there are cases where you have

402
00:15:26,480 --> 00:15:27,839
to distinguish

403
00:15:27,839 --> 00:15:30,480
uh between adding and the blink and

404
00:15:30,480 --> 00:15:32,800
these these are mostly well known

405
00:15:32,800 --> 00:15:33,839
but

406
00:15:33,839 --> 00:15:35,759
aside from these

407
00:15:35,759 --> 00:15:38,720
this was this was basically the

408
00:15:38,720 --> 00:15:41,360
the only exceptional family we found so

409
00:15:41,360 --> 00:15:44,639
from this point of view it's quite rare

410
00:15:44,639 --> 00:15:47,199
but but if you mean uh

411
00:15:47,199 --> 00:15:49,680
hopefully yes so my my question is is it

412
00:15:49,680 --> 00:15:52,000
a family of points that work on any

413
00:15:52,000 --> 00:15:54,720
elliptic curve will this attack work

414
00:15:54,720 --> 00:15:59,199
with this formula for any elliptic curve

415
00:16:00,560 --> 00:16:03,040
yeah i think so okay does it depend on

416
00:16:03,040 --> 00:16:05,199
some prime p or is it not related to

417
00:16:05,199 --> 00:16:08,639
particularities of a prime p for example

418
00:16:08,639 --> 00:16:10,560
no no it should it should work on on any

419
00:16:10,560 --> 00:16:11,519
curve

420
00:16:11,519 --> 00:16:14,320
like it's it's not it should not be

421
00:16:14,320 --> 00:16:16,399
really hard to find these points but

422
00:16:16,399 --> 00:16:19,120
what is hard is to find these points if

423
00:16:19,120 --> 00:16:21,199
you also have the condition that one of

424
00:16:21,199 --> 00:16:23,920
them is a

425
00:16:23,920 --> 00:16:26,079
is a multiple by a specific scalar of

426
00:16:26,079 --> 00:16:28,320
the other which is what you actually

427
00:16:28,320 --> 00:16:30,959
need to do when you mount the epa attack

428
00:16:30,959 --> 00:16:33,119
so

429
00:16:33,199 --> 00:16:35,279
yeah it will not be that hard to find

430
00:16:35,279 --> 00:16:37,519
these points but if you if you want to

431
00:16:37,519 --> 00:16:39,600
leverage that for the epa attack then

432
00:16:39,600 --> 00:16:41,360
that is much harder

433
00:16:41,360 --> 00:16:42,800
but it does not really depend on the

434
00:16:42,800 --> 00:16:44,639
curve

435
00:16:44,639 --> 00:16:46,320
thank you

436
00:16:46,320 --> 00:16:50,600
um do we have other questions

437
00:16:51,600 --> 00:16:53,440
no question in the

438
00:16:53,440 --> 00:16:56,320
chat so far

439
00:17:00,399 --> 00:17:02,079
then thank you very much for your talk

440
00:17:02,079 --> 00:17:03,360
we will

441
00:17:03,360 --> 00:17:06,720
move to the next speaker and at the end

442
00:17:06,720 --> 00:17:08,640
if there are more questions then we will

443
00:17:08,640 --> 00:17:11,679
ask them thank you so our next speaker

444
00:17:11,679 --> 00:17:14,160
is um simon merz

445
00:17:14,160 --> 00:17:16,880
and he will present cryptanalysis of an

446
00:17:16,880 --> 00:17:21,679
obligous prf from supersangular isogenys

447
00:17:24,559 --> 00:17:26,000
thanks a lot aurora

448
00:17:26,000 --> 00:17:28,240
this was joint work with my co-authors

449
00:17:28,240 --> 00:17:30,559
andreya vasso peter gutash christoph

450
00:17:30,559 --> 00:17:34,400
petty and antonio sanso

451
00:17:34,400 --> 00:17:36,720
an oblivious pseudorandum function or

452
00:17:36,720 --> 00:17:39,360
short oprf is a two-party protocol to

453
00:17:39,360 --> 00:17:42,320
evaluate a keyed pseudorandom function

454
00:17:42,320 --> 00:17:44,080
the setting is that the server holds a

455
00:17:44,080 --> 00:17:47,280
key k and the client holds an input m

456
00:17:47,280 --> 00:17:49,200
at the end of the protocol the client

457
00:17:49,200 --> 00:17:50,960
should learn the evaluation of the

458
00:17:50,960 --> 00:17:53,440
pseudorandom function at km but nothing

459
00:17:53,440 --> 00:17:54,720
about the key k

460
00:17:54,720 --> 00:17:56,080
and the server should learn nothing

461
00:17:56,080 --> 00:17:59,360
about the input or the evaluation

462
00:17:59,360 --> 00:18:00,960
of the client

463
00:18:00,960 --> 00:18:03,200
there's some variation called verifiable

464
00:18:03,200 --> 00:18:06,000
prf where server provides an additional

465
00:18:06,000 --> 00:18:08,320
proof to the client that he always uses

466
00:18:08,320 --> 00:18:11,600
the same key for evaluations

467
00:18:11,600 --> 00:18:14,400
and these oprs have various applications

468
00:18:14,400 --> 00:18:17,039
such as in password authenticated key

469
00:18:17,039 --> 00:18:19,200
exchanges private set intersection or

470
00:18:19,200 --> 00:18:22,400
privacy preserving capture codes

471
00:18:22,400 --> 00:18:25,039
last year at asia equipped bonnie coogan

472
00:18:25,039 --> 00:18:27,520
and wu presented two oprf's based on

473
00:18:27,520 --> 00:18:30,400
isogenes one is based on seaside and the

474
00:18:30,400 --> 00:18:32,880
other one sidh in our analysis we

475
00:18:32,880 --> 00:18:36,480
focused on the oprf from sidh

476
00:18:36,480 --> 00:18:38,480
sidh is a key exchange between two

477
00:18:38,480 --> 00:18:40,880
parties introduced by yao and defeo and

478
00:18:40,880 --> 00:18:42,960
the key idea is that two parties compute

479
00:18:42,960 --> 00:18:45,520
isogenys of coprime degrees which for

480
00:18:45,520 --> 00:18:47,200
the sake of this talk you can just think

481
00:18:47,200 --> 00:18:49,280
of as random looking walks in a large

482
00:18:49,280 --> 00:18:50,160
graph

483
00:18:50,160 --> 00:18:50,960
and

484
00:18:50,960 --> 00:18:52,799
both parties exchange the endpoints

485
00:18:52,799 --> 00:18:55,679
which is an elliptic curve of their walk

486
00:18:55,679 --> 00:18:57,440
as well as some associated information

487
00:18:57,440 --> 00:18:58,960
that allows to shift their private i

488
00:18:58,960 --> 00:19:01,280
thought you need to this new endpoint

489
00:19:01,280 --> 00:19:03,520
and both both parties

490
00:19:03,520 --> 00:19:05,919
agree on the same shared curve in the

491
00:19:05,919 --> 00:19:08,000
picture emk

492
00:19:08,000 --> 00:19:09,440
in the end

493
00:19:09,440 --> 00:19:11,919
so the idea of bonecogen and wu

494
00:19:11,919 --> 00:19:14,240
was to transform this into an oprf as

495
00:19:14,240 --> 00:19:15,200
follows

496
00:19:15,200 --> 00:19:17,840
the input of the client is a torsion

497
00:19:17,840 --> 00:19:20,480
point that defines the first isogeny

498
00:19:20,480 --> 00:19:22,320
to hide the curve em and thus

499
00:19:22,320 --> 00:19:24,240
information about the private isogeny of

500
00:19:24,240 --> 00:19:26,480
a client the client client blinds this

501
00:19:26,480 --> 00:19:29,039
walk with another isogeny walk sends

502
00:19:29,039 --> 00:19:31,520
across the end curve on which the server

503
00:19:31,520 --> 00:19:32,640
computes

504
00:19:32,640 --> 00:19:34,320
their secret walk

505
00:19:34,320 --> 00:19:36,480
which the client unblinds

506
00:19:36,480 --> 00:19:37,520
to

507
00:19:37,520 --> 00:19:40,640
receive the curve emk which allows them

508
00:19:40,640 --> 00:19:42,799
to evaluate the

509
00:19:42,799 --> 00:19:44,000
um

510
00:19:44,000 --> 00:19:46,880
oprf which is just a like a hash of this

511
00:19:46,880 --> 00:19:48,880
curve together with some other

512
00:19:48,880 --> 00:19:50,880
information

513
00:19:50,880 --> 00:19:53,520
the p in oprf stands for pseudorandom

514
00:19:53,520 --> 00:19:55,280
and thus without knowledge of the key k

515
00:19:55,280 --> 00:19:56,960
an attacker should not be able to

516
00:19:56,960 --> 00:19:58,480
predict the function

517
00:19:58,480 --> 00:20:00,960
or evaluate the opf without the service

518
00:20:00,960 --> 00:20:01,760
help

519
00:20:01,760 --> 00:20:03,520
even after multiple queries so if you

520
00:20:03,520 --> 00:20:05,200
have one query

521
00:20:05,200 --> 00:20:07,840
an evaluation by the server to get e-m0k

522
00:20:07,840 --> 00:20:10,960
and another query from e0 to em1

523
00:20:10,960 --> 00:20:13,840
evaluated by the server to em1k it

524
00:20:13,840 --> 00:20:16,080
should be still hard to compute the

525
00:20:16,080 --> 00:20:19,678
curve e m prime k

526
00:20:21,200 --> 00:20:23,440
the pseudo-randomness of their okf on a

527
00:20:23,440 --> 00:20:25,840
new so-called auxiliary one more

528
00:20:25,840 --> 00:20:28,240
assumption

529
00:20:28,240 --> 00:20:30,640
um in our paper we give two attacks on

530
00:20:30,640 --> 00:20:32,559
the one more assumption that also break

531
00:20:32,559 --> 00:20:34,799
the pseudo-randomness of the oprf the

532
00:20:34,799 --> 00:20:37,280
idea is to recover the curve ek that's

533
00:20:37,280 --> 00:20:41,120
in the bottom left of the diagram

534
00:20:41,120 --> 00:20:43,360
as well as

535
00:20:43,360 --> 00:20:45,600
three

536
00:20:46,480 --> 00:20:48,080
arrows like the green arrow here in the

537
00:20:48,080 --> 00:20:49,840
bottom four four three linearly

538
00:20:49,840 --> 00:20:52,000
independent point and then basically

539
00:20:52,000 --> 00:20:54,880
this allows to evaluate the

540
00:20:54,880 --> 00:20:56,240
isogeny

541
00:20:56,240 --> 00:20:58,720
uh via the southwest passage instead of

542
00:20:58,720 --> 00:21:01,600
the northeast passage as intended

543
00:21:01,600 --> 00:21:05,520
of the commutative diagram

544
00:21:06,240 --> 00:21:08,320
so how do we

545
00:21:08,320 --> 00:21:11,360
recover the ek and the path to em k as a

546
00:21:11,360 --> 00:21:12,799
malicious client

547
00:21:12,799 --> 00:21:14,720
say m is the two torsion point that

548
00:21:14,720 --> 00:21:17,360
defines the isogeny walk from

549
00:21:17,360 --> 00:21:18,640
from

550
00:21:18,640 --> 00:21:19,679
e

551
00:21:19,679 --> 00:21:22,240
0 to e m

552
00:21:22,240 --> 00:21:23,039
then

553
00:21:23,039 --> 00:21:25,760
taking two power multiples of m

554
00:21:25,760 --> 00:21:27,919
as a client

555
00:21:27,919 --> 00:21:31,120
allows to evaluate the or cut short the

556
00:21:31,120 --> 00:21:33,440
surgery work from e0 to em and it

557
00:21:33,440 --> 00:21:36,240
basically gives you the points that lie

558
00:21:36,240 --> 00:21:39,520
in between ek and emk

559
00:21:39,520 --> 00:21:40,880
so essentially

560
00:21:40,880 --> 00:21:43,120
using multiple queries you can recover

561
00:21:43,120 --> 00:21:46,559
the entire isogeny from ek to the mk

562
00:21:46,559 --> 00:21:48,720
just stepwise

563
00:21:48,720 --> 00:21:51,679
however the oprf could defend against

564
00:21:51,679 --> 00:21:54,480
such an attack by requiring a proof that

565
00:21:54,480 --> 00:21:56,720
the points of the client's

566
00:21:56,720 --> 00:21:58,880
input are full order then this is not

567
00:21:58,880 --> 00:22:00,480
possible

568
00:22:00,480 --> 00:22:03,039
however we also give a sub-exponential

569
00:22:03,039 --> 00:22:04,799
attack for this case the idea is that

570
00:22:04,799 --> 00:22:06,400
instead of step-by-step walking

571
00:22:06,400 --> 00:22:08,799
backwards the isogeny from em to e0 in

572
00:22:08,799 --> 00:22:11,520
our queries we carefully craft queries

573
00:22:11,520 --> 00:22:15,039
on of points of full order to

574
00:22:15,039 --> 00:22:16,960
build a binary tree where the leaves are

575
00:22:16,960 --> 00:22:20,080
the evaluations of the obf queries and

576
00:22:20,080 --> 00:22:23,679
ek is at the at the root of the tree

577
00:22:23,679 --> 00:22:26,000
using multiple meat in the middle steps

578
00:22:26,000 --> 00:22:28,799
this allows to again recover the isogeny

579
00:22:28,799 --> 00:22:32,080
from ek to emk and there's a trade-off

580
00:22:32,080 --> 00:22:33,840
between computational costs and the

581
00:22:33,840 --> 00:22:36,559
number of queries to the oprf we need to

582
00:22:36,559 --> 00:22:37,760
execute

583
00:22:37,760 --> 00:22:39,679
the only counter measure so far seems to

584
00:22:39,679 --> 00:22:41,200
be to increase the parameters

585
00:22:41,200 --> 00:22:43,760
drastically

586
00:22:43,760 --> 00:22:45,840
and it's it's maybe an interesting

587
00:22:45,840 --> 00:22:48,640
future research topic to find

588
00:22:48,640 --> 00:22:51,120
more efficient countermeasures

589
00:22:51,120 --> 00:22:53,280
so let me summarize our paper provides

590
00:22:53,280 --> 00:22:54,960
two attacks on the one more assumption

591
00:22:54,960 --> 00:22:56,320
that lead to attacks on the

592
00:22:56,320 --> 00:23:00,240
pseudo-randomness of the sidh based opi

593
00:23:00,240 --> 00:23:01,600
we give a proof of concept

594
00:23:01,600 --> 00:23:03,440
implementation of the attack

595
00:23:03,440 --> 00:23:06,799
which was implemented in sage

596
00:23:06,799 --> 00:23:08,480
and finally something i didn't get

597
00:23:08,480 --> 00:23:10,880
around to in this short talk but i refer

598
00:23:10,880 --> 00:23:12,960
to the longer talk and obviously our

599
00:23:12,960 --> 00:23:16,000
paper um we discussed in the paper that

600
00:23:16,000 --> 00:23:18,000
the starting curve e0 has to be chosen

601
00:23:18,000 --> 00:23:21,120
by a trusted setup as otherwise the oprf

602
00:23:21,120 --> 00:23:23,600
can be either backdoored by the client

603
00:23:23,600 --> 00:23:25,440
or a malicious

604
00:23:25,440 --> 00:23:27,679
third party or at least one of the

605
00:23:27,679 --> 00:23:29,039
security proofs

606
00:23:29,039 --> 00:23:32,000
by winning at all break if the server

607
00:23:32,000 --> 00:23:34,559
chooses the starting curve

608
00:23:34,559 --> 00:23:37,840
thank you for your attention

609
00:23:40,400 --> 00:23:42,720
thank you very much for your talk

610
00:23:42,720 --> 00:23:46,080
um are there any questions

611
00:23:49,039 --> 00:23:51,760
so to start then

612
00:23:51,760 --> 00:23:53,120
um

613
00:23:53,120 --> 00:23:56,240
how can you apply your attack to

614
00:23:56,240 --> 00:23:57,440
the

615
00:23:57,440 --> 00:24:01,200
system that use a suicide instead of acd

616
00:24:01,200 --> 00:24:03,120
ace idh

617
00:24:03,120 --> 00:24:06,880
uh it doesn't doesn't apply um the eop

618
00:24:06,880 --> 00:24:10,720
rf looks actually completely different

619
00:24:10,720 --> 00:24:12,480
so it's not just you don't just change

620
00:24:12,480 --> 00:24:14,080
one primitive like the the entire

621
00:24:14,080 --> 00:24:16,240
project looks differently

622
00:24:16,240 --> 00:24:17,200
but the

623
00:24:17,200 --> 00:24:20,240
so for example in the original paper the

624
00:24:20,240 --> 00:24:22,559
the authors only gave a version of a

625
00:24:22,559 --> 00:24:25,600
verifiable opf in the sidh case

626
00:24:25,600 --> 00:24:28,400
um and and the seaside case required um

627
00:24:28,400 --> 00:24:30,000
to know the class group structure if i

628
00:24:30,000 --> 00:24:33,360
remember correctly so um

629
00:24:33,360 --> 00:24:35,440
depending on current like discussions

630
00:24:35,440 --> 00:24:37,279
about um

631
00:24:37,279 --> 00:24:39,120
about seaside parameters this might not

632
00:24:39,120 --> 00:24:39,840
be

633
00:24:39,840 --> 00:24:43,918
actually that practical to instantiate

634
00:24:45,039 --> 00:24:47,039
okay thank you

635
00:24:47,039 --> 00:24:49,919
other questions

636
00:24:53,520 --> 00:24:54,559
so

637
00:24:54,559 --> 00:24:59,639
there is no question in the chat so far

638
00:25:00,640 --> 00:25:03,120
then thank you very much for your talk

639
00:25:03,120 --> 00:25:05,600
and we will move to the

640
00:25:05,600 --> 00:25:08,720
ah no yes sorry so there is a

641
00:25:08,720 --> 00:25:09,520
sorry

642
00:25:09,520 --> 00:25:14,200
there is a question from francisco

643
00:25:15,200 --> 00:25:17,440
uh francisco would you like to unmute

644
00:25:17,440 --> 00:25:21,799
yourself or do i ask you a question

645
00:25:28,720 --> 00:25:31,200
uh so that yeah

646
00:25:31,200 --> 00:25:32,960
i guess i can i can see the question so

647
00:25:32,960 --> 00:25:35,440
it's whether we we can produce an uh

648
00:25:35,440 --> 00:25:39,360
isogeny based oblivious prf um so um

649
00:25:39,360 --> 00:25:40,880
first of all the the seaside version

650
00:25:40,880 --> 00:25:42,640
does exist so i guess that's one i saw

651
00:25:42,640 --> 00:25:45,279
genie based oblivious prf but uh

652
00:25:45,279 --> 00:25:46,960
otherwise it's a it's a very interesting

653
00:25:46,960 --> 00:25:49,600
question i think uh to to build a

654
00:25:49,600 --> 00:25:52,480
an sidh version that that is different

655
00:25:52,480 --> 00:25:53,600
from the

656
00:25:53,600 --> 00:25:56,400
um on a version so so like you could you

657
00:25:56,400 --> 00:25:57,840
could still um

658
00:25:57,840 --> 00:25:59,840
obviously just raise parameters but that

659
00:25:59,840 --> 00:26:01,279
that will be

660
00:26:01,279 --> 00:26:04,000
rather impractical given this attack

661
00:26:04,000 --> 00:26:05,600
um but otherwise i think it's an

662
00:26:05,600 --> 00:26:07,600
interesting open problem i i don't i

663
00:26:07,600 --> 00:26:11,480
don't have an answer for you

664
00:26:31,679 --> 00:26:33,600
oh well i think you me

665
00:26:33,600 --> 00:26:36,080
yeah yeah francisco is muted too i don't

666
00:26:36,080 --> 00:26:39,840
know if he's trying to speak then

667
00:26:43,120 --> 00:26:45,840
okay then we move to the next talk to be

668
00:26:45,840 --> 00:26:47,840
sure we are not being late

669
00:26:47,840 --> 00:26:50,799
uh thank you again and i

670
00:26:50,799 --> 00:26:52,880
so fabulous is going to

671
00:26:52,880 --> 00:26:54,799
continue

672
00:26:54,799 --> 00:26:56,960
so hi so

673
00:26:56,960 --> 00:26:58,880
welcome to the second part of the

674
00:26:58,880 --> 00:27:00,880
session so the next talk is about

675
00:27:00,880 --> 00:27:03,120
symmetric key exchange with full forward

676
00:27:03,120 --> 00:27:05,600
security and robust synchronization this

677
00:27:05,600 --> 00:27:08,480
is a paper by colleen boyd gareth davies

678
00:27:08,480 --> 00:27:12,080
border kai gellert tibor jagger

679
00:27:12,080 --> 00:27:14,320
and lisa miller young

680
00:27:14,320 --> 00:27:15,120
and

681
00:27:15,120 --> 00:27:18,479
bo is giving the talk

682
00:27:18,799 --> 00:27:21,840
yes thanks a lot

683
00:27:22,960 --> 00:27:25,919
yes so uh yeah so this paper is called

684
00:27:25,919 --> 00:27:27,679
the symmetric key exchange with full

685
00:27:27,679 --> 00:27:29,039
forward security and we're boosting

686
00:27:29,039 --> 00:27:31,440
pronunciation uh and as mentioned this

687
00:27:31,440 --> 00:27:33,520
is joint work with colin boyd garrett

688
00:27:33,520 --> 00:27:35,840
davies

689
00:27:37,600 --> 00:27:39,840
so the problem we focus on in this paper

690
00:27:39,840 --> 00:27:42,320
is uh how to do authenticated key

691
00:27:42,320 --> 00:27:44,880
exchange for very constrained devices

692
00:27:44,880 --> 00:27:47,440
using pre-shared symmetric keys

693
00:27:47,440 --> 00:27:49,120
and then this leads to several

694
00:27:49,120 --> 00:27:50,880
challenges and those are for instance

695
00:27:50,880 --> 00:27:52,399
related to forward security

696
00:27:52,399 --> 00:27:54,399
synchronization uh concurrent

697
00:27:54,399 --> 00:27:57,520
correctness and and the like so the

698
00:27:57,520 --> 00:27:59,520
contributions that we have in this paper

699
00:27:59,520 --> 00:28:01,840
are three very efficient ape protocols

700
00:28:01,840 --> 00:28:04,640
with linear key evolution and two aku

701
00:28:04,640 --> 00:28:06,960
protocols with non-linear key evolution

702
00:28:06,960 --> 00:28:09,039
and then we also provide a framework for

703
00:28:09,039 --> 00:28:11,440
protocol analysis and we formalize in

704
00:28:11,440 --> 00:28:13,919
this framework uh several properties for

705
00:28:13,919 --> 00:28:17,360
instance synchronization or business and

706
00:28:17,360 --> 00:28:19,840
and yeah and several more

707
00:28:19,840 --> 00:28:21,679
so what again are we looking at so an

708
00:28:21,679 --> 00:28:23,840
authenticated key exchange is of course

709
00:28:23,840 --> 00:28:26,320
a protocol in which alice and bob

710
00:28:26,320 --> 00:28:29,440
managed to talk to each other using some

711
00:28:29,440 --> 00:28:31,440
shared secrets and then they are also

712
00:28:31,440 --> 00:28:32,640
convinced that they're talking to the

713
00:28:32,640 --> 00:28:34,640
right person so ellis knows that they're

714
00:28:34,640 --> 00:28:36,320
talking to bob and bob and us directly

715
00:28:36,320 --> 00:28:37,440
to alice

716
00:28:37,440 --> 00:28:39,600
and then forward security means that if

717
00:28:39,600 --> 00:28:41,679
we have several sessions based on the

718
00:28:41,679 --> 00:28:44,159
same shared secret and there is an

719
00:28:44,159 --> 00:28:46,480
attacker eve who manages to steal this

720
00:28:46,480 --> 00:28:48,480
shared secret and maybe even steals the

721
00:28:48,480 --> 00:28:51,520
second key the second session key then

722
00:28:51,520 --> 00:28:54,320
the attacker will not have access to any

723
00:28:54,320 --> 00:28:57,279
session before that so we know that

724
00:28:57,279 --> 00:28:59,600
security is not compromised in the past

725
00:28:59,600 --> 00:29:02,159
if it is compromised in the future

726
00:29:02,159 --> 00:29:04,640
um achieving this is something that you

727
00:29:04,640 --> 00:29:06,399
would normally do with ephemeral key

728
00:29:06,399 --> 00:29:08,000
exchange or ephemeral material or

729
00:29:08,000 --> 00:29:09,679
development or something

730
00:29:09,679 --> 00:29:11,520
which we of course cannot do

731
00:29:11,520 --> 00:29:12,559
now

732
00:29:12,559 --> 00:29:15,679
so instead we will do a key evolution to

733
00:29:15,679 --> 00:29:18,480
obtain forward security there is some

734
00:29:18,480 --> 00:29:20,880
other work related to this and you

735
00:29:20,880 --> 00:29:22,640
generally have two flavors one of them

736
00:29:22,640 --> 00:29:24,960
is time-based evolution

737
00:29:24,960 --> 00:29:26,880
and this is for instance formalized by

738
00:29:26,880 --> 00:29:29,440
luciano lili in 2015 and you have

739
00:29:29,440 --> 00:29:32,240
triggered evolution where something

740
00:29:32,240 --> 00:29:34,720
happening triggers evolving the key to

741
00:29:34,720 --> 00:29:36,960
the next step

742
00:29:36,960 --> 00:29:40,000
and in our case we will use this

743
00:29:40,000 --> 00:29:41,919
and the trigger will be key derivation

744
00:29:41,919 --> 00:29:43,760
so every time you derive a new session

745
00:29:43,760 --> 00:29:44,960
key we will

746
00:29:44,960 --> 00:29:46,960
then evolve the

747
00:29:46,960 --> 00:29:50,559
key that we will the static key material

748
00:29:50,559 --> 00:29:52,720
there are several challenges with this

749
00:29:52,720 --> 00:29:53,840
one of them of course being

750
00:29:53,840 --> 00:29:56,399
synchronization so both parties need to

751
00:29:56,399 --> 00:29:58,480
have evolved the shared key the same

752
00:29:58,480 --> 00:30:00,159
number of steps so that they actually

753
00:30:00,159 --> 00:30:02,080
use the shared key

754
00:30:02,080 --> 00:30:04,000
there is some property called concurrent

755
00:30:04,000 --> 00:30:05,360
correctness

756
00:30:05,360 --> 00:30:07,760
which means that parallel sessions where

757
00:30:07,760 --> 00:30:10,399
one session has evolved the shared key

758
00:30:10,399 --> 00:30:12,720
and the other has not

759
00:30:12,720 --> 00:30:14,880
might mean that the key material is not

760
00:30:14,880 --> 00:30:17,279
usable for the second session

761
00:30:17,279 --> 00:30:20,000
or more than two so in previous work

762
00:30:20,000 --> 00:30:22,000
there are most notably two materials

763
00:30:22,000 --> 00:30:24,559
called two uh two protocols sake and say

764
00:30:24,559 --> 00:30:28,159
km both are from avoid it all in 2020

765
00:30:28,159 --> 00:30:30,399
and they do not obtain these properties

766
00:30:30,399 --> 00:30:33,200
that we define in our security model

767
00:30:33,200 --> 00:30:35,360
so what is our security model it's a

768
00:30:35,360 --> 00:30:37,279
framework for analysis of this kind of

769
00:30:37,279 --> 00:30:39,520
protocols uh it

770
00:30:39,520 --> 00:30:41,679
is of course inspired slightly on the

771
00:30:41,679 --> 00:30:43,600
ake model from valerie rogoway at all

772
00:30:43,600 --> 00:30:45,279
but that model lacks a notion of

773
00:30:45,279 --> 00:30:47,440
concurrent correctness so correctness in

774
00:30:47,440 --> 00:30:48,799
the presence of several parallel

775
00:30:48,799 --> 00:30:51,200
sessions and synchronization which is an

776
00:30:51,200 --> 00:30:53,919
important property for us here

777
00:30:53,919 --> 00:30:56,080
and we also in our model then formalize

778
00:30:56,080 --> 00:30:57,360
synchronization

779
00:30:57,360 --> 00:30:59,360
robustness which means that if something

780
00:30:59,360 --> 00:31:01,760
goes wrong in a session then you can

781
00:31:01,760 --> 00:31:03,760
recover from this and compute keys in

782
00:31:03,760 --> 00:31:06,080
future sessions afterwards which is

783
00:31:06,080 --> 00:31:07,760
something that is important to us if

784
00:31:07,760 --> 00:31:09,440
we're again working on very constrained

785
00:31:09,440 --> 00:31:11,919
devices where you cannot just start from

786
00:31:11,919 --> 00:31:13,919
scratch because it for instance drain

787
00:31:13,919 --> 00:31:15,840
the battery

788
00:31:15,840 --> 00:31:17,679
what is then concurrent correctness well

789
00:31:17,679 --> 00:31:19,679
say that alice initializes two sessions

790
00:31:19,679 --> 00:31:20,880
with bob

791
00:31:20,880 --> 00:31:23,360
and bob replies first to the first

792
00:31:23,360 --> 00:31:25,279
session before he arrives

793
00:31:25,279 --> 00:31:27,039
before he receives the message from the

794
00:31:27,039 --> 00:31:29,679
second session then bob might have

795
00:31:29,679 --> 00:31:32,559
evolved his key material but alice

796
00:31:32,559 --> 00:31:35,440
cannot actually evolve

797
00:31:35,440 --> 00:31:37,760
responds based on this material anymore

798
00:31:37,760 --> 00:31:39,440
because she has already evolved her key

799
00:31:39,440 --> 00:31:41,760
material to start the second session

800
00:31:41,760 --> 00:31:44,320
so this is a problem that we solve in

801
00:31:44,320 --> 00:31:46,880
our in our uh in our work so we managed

802
00:31:46,880 --> 00:31:48,799
to recover from this and there is the

803
00:31:48,799 --> 00:31:50,799
property synchronization room business

804
00:31:50,799 --> 00:31:52,320
which captures the ability of two

805
00:31:52,320 --> 00:31:55,600
parties to succeed uh in uh exchanging a

806
00:31:55,600 --> 00:31:57,279
session key in the future no matter what

807
00:31:57,279 --> 00:31:59,440
has happened in the past

808
00:31:59,440 --> 00:32:01,440
we also show that if the parties get out

809
00:32:01,440 --> 00:32:03,840
of sync then we can resynchronize

810
00:32:03,840 --> 00:32:05,840
and we can define this in a strong and

811
00:32:05,840 --> 00:32:07,360
in a weak way and we say that strong

812
00:32:07,360 --> 00:32:09,360
synchronization or business will mean

813
00:32:09,360 --> 00:32:11,679
that all sessions will always terminate

814
00:32:11,679 --> 00:32:14,159
successfully while weak synchronization

815
00:32:14,159 --> 00:32:15,679
or business will mean that all

816
00:32:15,679 --> 00:32:17,279
uninterrupted sessions will always

817
00:32:17,279 --> 00:32:19,200
terminate successfully

818
00:32:19,200 --> 00:32:20,880
and we show that in our work that this

819
00:32:20,880 --> 00:32:22,880
strong version so that every single

820
00:32:22,880 --> 00:32:23,840
session will always terminate

821
00:32:23,840 --> 00:32:26,880
successfully is impossible to obtain

822
00:32:26,880 --> 00:32:29,279
with linearly evolving key material but

823
00:32:29,279 --> 00:32:31,840
we show that if we use punctuable pprfs

824
00:32:31,840 --> 00:32:33,679
then we can actually obtain this so we

825
00:32:33,679 --> 00:32:35,600
can construct protocols in which we

826
00:32:35,600 --> 00:32:37,840
evolve the key in a non-linear way as

827
00:32:37,840 --> 00:32:39,679
well

828
00:32:39,679 --> 00:32:41,840
so except for apart from all this

829
00:32:41,840 --> 00:32:43,919
modeling work the result in our paper is

830
00:32:43,919 --> 00:32:46,399
five new protocols so here we see those

831
00:32:46,399 --> 00:32:49,840
five compared with the existing work um

832
00:32:49,840 --> 00:32:52,480
and so we see that all of our protocols

833
00:32:52,480 --> 00:32:53,440
obtain

834
00:32:53,440 --> 00:32:55,360
the weak version of synchronization or

835
00:32:55,360 --> 00:32:57,519
business the the ones based on

836
00:32:57,519 --> 00:32:59,279
non-linear evolution also have the

837
00:32:59,279 --> 00:33:00,720
strong flavor

838
00:33:00,720 --> 00:33:01,840
and also have this concurrent

839
00:33:01,840 --> 00:33:03,760
correctness in all cases all our

840
00:33:03,760 --> 00:33:06,399
protocols obtain for security and it's

841
00:33:06,399 --> 00:33:08,480
also worth noting that all our protocols

842
00:33:08,480 --> 00:33:12,080
uh need a need fewer messages than the

843
00:33:12,080 --> 00:33:13,840
existing work so

844
00:33:13,840 --> 00:33:15,120
we approve this state of the art

845
00:33:15,120 --> 00:33:18,399
significantly in that way as well

846
00:33:18,399 --> 00:33:20,399
if you're interested in the protocols or

847
00:33:20,399 --> 00:33:22,720
in the actual proofs or you know many

848
00:33:22,720 --> 00:33:24,559
more things i hope that you will find

849
00:33:24,559 --> 00:33:27,200
time to watch the full talk on youtube

850
00:33:27,200 --> 00:33:30,080
or read the eprint version of the paper

851
00:33:30,080 --> 00:33:32,159
and then i am

852
00:33:32,159 --> 00:33:34,000
thankful that you listen to my talk and

853
00:33:34,000 --> 00:33:37,640
i'm here for questions

854
00:33:38,640 --> 00:33:40,240
thanks thank you

855
00:33:40,240 --> 00:33:45,159
both so does anybody ask questions

856
00:33:54,559 --> 00:33:57,039
okay so

857
00:33:57,679 --> 00:34:00,080
yeah i don't see any questions so i have

858
00:34:00,080 --> 00:34:01,919
one question for you so

859
00:34:01,919 --> 00:34:03,039
so in

860
00:34:03,039 --> 00:34:05,840
the paper you show that the signal the

861
00:34:05,840 --> 00:34:07,519
signal protocol like the double write

862
00:34:07,519 --> 00:34:10,159
checking id the protocol do

863
00:34:10,159 --> 00:34:12,480
is not sufficient for your purpose

864
00:34:12,480 --> 00:34:15,119
but what i was wondering is whether your

865
00:34:15,119 --> 00:34:17,440
ids or your protocol can be used to

866
00:34:17,440 --> 00:34:20,079
improve the signal protocol and get more

867
00:34:20,079 --> 00:34:21,679
efficiency using like symmetric

868
00:34:21,679 --> 00:34:24,079
primitive instead of

869
00:34:24,079 --> 00:34:27,119
asymmetric primitive

870
00:34:27,119 --> 00:34:29,760
um there's an interesting question so uh

871
00:34:29,760 --> 00:34:32,239
what makes this hard

872
00:34:32,239 --> 00:34:34,239
to use for signal is that you will need

873
00:34:34,239 --> 00:34:36,079
pre-shared keys

874
00:34:36,079 --> 00:34:38,800
uh so to initialize we need to actually

875
00:34:38,800 --> 00:34:41,280
put keys on the devices

876
00:34:41,280 --> 00:34:43,918
uh and that is that is very suitable for

877
00:34:43,918 --> 00:34:46,320
deployment of for instance iot devices

878
00:34:46,320 --> 00:34:48,320
or those kind of things but it might be

879
00:34:48,320 --> 00:34:51,280
more challenging for a signal

880
00:34:51,280 --> 00:34:53,030
approach

881
00:34:53,030 --> 00:34:54,560
[Music]

882
00:34:54,560 --> 00:34:56,800
but it's an interesting thought no i

883
00:34:56,800 --> 00:34:59,520
mean after after managing better you

884
00:34:59,520 --> 00:35:01,760
pre-share the key using the man and then

885
00:35:01,760 --> 00:35:03,599
after you have this pre-shot key can you

886
00:35:03,599 --> 00:35:05,760
just use your protocol instead of

887
00:35:05,760 --> 00:35:07,760
reusing your

888
00:35:07,760 --> 00:35:10,560
asymmetrics

889
00:35:10,560 --> 00:35:11,280
so

890
00:35:11,280 --> 00:35:13,680
um

891
00:35:13,680 --> 00:35:15,599
so i guess you could and i guess that

892
00:35:15,599 --> 00:35:18,480
what we do is in a sense uh

893
00:35:18,480 --> 00:35:19,520
not

894
00:35:19,520 --> 00:35:22,160
it's not super different from

895
00:35:22,160 --> 00:35:24,720
uh this hash based ratchet that signal

896
00:35:24,720 --> 00:35:27,119
uses after each new message from one

897
00:35:27,119 --> 00:35:30,880
user to another um but of course what

898
00:35:30,880 --> 00:35:33,520
signal does in every in every message in

899
00:35:33,520 --> 00:35:35,440
every new message from one user to the

900
00:35:35,440 --> 00:35:36,960
other user is add

901
00:35:36,960 --> 00:35:38,800
a new key material

902
00:35:38,800 --> 00:35:41,680
uh through a new diffie-hellman

903
00:35:41,680 --> 00:35:42,839
public

904
00:35:42,839 --> 00:35:46,320
key and then signal with this not only

905
00:35:46,320 --> 00:35:48,560
has forward secure forward security but

906
00:35:48,560 --> 00:35:51,040
also what they call backward security

907
00:35:51,040 --> 00:35:51,920
um

908
00:35:51,920 --> 00:35:54,480
which is something that i don't think we

909
00:35:54,480 --> 00:35:57,599
have uh which is this complete recovery

910
00:35:57,599 --> 00:36:01,280
if everything is compromised completely

911
00:36:01,280 --> 00:36:02,079
i

912
00:36:02,079 --> 00:36:04,400
i'm now not 100 sure but i think that

913
00:36:04,400 --> 00:36:05,839
that is something that we actually

914
00:36:05,839 --> 00:36:08,160
cannot obtain with our protocols

915
00:36:08,160 --> 00:36:10,880
while signal can because they sample

916
00:36:10,880 --> 00:36:13,680
these new keys in every step

917
00:36:13,680 --> 00:36:16,000
and that is something that we yeah we

918
00:36:16,000 --> 00:36:17,520
don't have the resources for in this

919
00:36:17,520 --> 00:36:20,880
model that we that we use

920
00:36:21,440 --> 00:36:23,920
i thank you

921
00:36:23,920 --> 00:36:25,760
thanks for the question

922
00:36:25,760 --> 00:36:29,359
does anyone assess questions

923
00:36:29,839 --> 00:36:31,520
okay

924
00:36:31,520 --> 00:36:34,320
okay so let's move to the next talk i

925
00:36:34,320 --> 00:36:35,440
guess

926
00:36:35,440 --> 00:36:36,560
uh

927
00:36:36,560 --> 00:36:39,280
so the next call talk is entitled like

928
00:36:39,280 --> 00:36:43,440
uh is titled security analysis of c pass

929
00:36:43,440 --> 00:36:46,320
it's by mishra abdallah

930
00:36:46,320 --> 00:36:49,680
az and julia hessel

931
00:36:49,680 --> 00:36:50,800
and

932
00:36:50,800 --> 00:36:54,400
john is giving the talk

933
00:36:54,400 --> 00:36:56,640
so did you hear me

934
00:36:56,640 --> 00:36:58,480
yes

935
00:36:58,480 --> 00:36:59,839
okay

936
00:36:59,839 --> 00:37:02,160
so welcome for the advertising session

937
00:37:02,160 --> 00:37:04,800
for uh where i try to motivate you to

938
00:37:04,800 --> 00:37:06,800
have a closer look at the full talk on

939
00:37:06,800 --> 00:37:09,119
the full paper

940
00:37:09,119 --> 00:37:11,359
so

941
00:37:11,359 --> 00:37:13,359
in i'd like to convince you that there

942
00:37:13,359 --> 00:37:16,320
might be reasons why our paper may be

943
00:37:16,320 --> 00:37:18,640
interesting for you and not only if

944
00:37:18,640 --> 00:37:20,240
you're interested in pick but also other

945
00:37:20,240 --> 00:37:23,760
reasons so one option might be that

946
00:37:23,760 --> 00:37:25,200
you're looking for a way for making

947
00:37:25,200 --> 00:37:26,880
reduction arguments on of your

948
00:37:26,880 --> 00:37:28,880
simulation based protocol proof more

949
00:37:28,880 --> 00:37:30,960
readable i found it quite hard to

950
00:37:30,960 --> 00:37:32,079
understand

951
00:37:32,079 --> 00:37:34,240
you see proofs when reading them

952
00:37:34,240 --> 00:37:36,880
and we found a method for

953
00:37:36,880 --> 00:37:38,800
formalizing the cryptographic assumption

954
00:37:38,800 --> 00:37:39,599
by

955
00:37:39,599 --> 00:37:42,240
executable code so which makes it more

956
00:37:42,240 --> 00:37:44,000
transparent in the simulator which

957
00:37:44,000 --> 00:37:46,320
strategy is actually used for carrying

958
00:37:46,320 --> 00:37:48,960
out the reduction

959
00:37:48,960 --> 00:37:50,880
second reason might be that you're

960
00:37:50,880 --> 00:37:52,880
working on protocols that need to hash

961
00:37:52,880 --> 00:37:54,560
on an elliptic curve

962
00:37:54,560 --> 00:37:58,000
so most commonly the hashing

963
00:37:58,000 --> 00:38:00,320
operation is considered as a random

964
00:38:00,320 --> 00:38:02,320
oracle which directly hashes to the

965
00:38:02,320 --> 00:38:03,520
curve group

966
00:38:03,520 --> 00:38:04,560
and

967
00:38:04,560 --> 00:38:08,320
we went one step further by deriving the

968
00:38:08,320 --> 00:38:10,960
exact requirements that we need to

969
00:38:10,960 --> 00:38:13,280
have from primitives such as alligator 2

970
00:38:13,280 --> 00:38:16,320
or swu in order to make the cpase

971
00:38:16,320 --> 00:38:17,599
protocol

972
00:38:17,599 --> 00:38:20,160
working securely

973
00:38:20,160 --> 00:38:22,240
and finally of course

974
00:38:22,240 --> 00:38:24,240
it might happen that you are dealing

975
00:38:24,240 --> 00:38:25,920
with an application where you were not

976
00:38:25,920 --> 00:38:28,480
able to get rid of the password or a pin

977
00:38:28,480 --> 00:38:31,520
so an efficient page might improve the

978
00:38:31,520 --> 00:38:33,440
security of your system

979
00:38:33,440 --> 00:38:36,480
that might be the third reason

980
00:38:36,480 --> 00:38:39,520
so cpace is about password authenticated

981
00:38:39,520 --> 00:38:41,520
key exchange or

982
00:38:41,520 --> 00:38:43,680
establishing a high entropy session key

983
00:38:43,680 --> 00:38:47,839
by use of a low entry entropy password

984
00:38:47,839 --> 00:38:50,320
there are already many paid protocols in

985
00:38:50,320 --> 00:38:53,119
the literature and the specific thing

986
00:38:53,119 --> 00:38:55,920
about see pace is that it was designed

987
00:38:55,920 --> 00:38:58,640
uh we designed it at the time

988
00:38:58,640 --> 00:39:00,720
to for an application and a very

989
00:39:00,720 --> 00:39:02,560
constrained setting

990
00:39:02,560 --> 00:39:06,000
uh where we tried everything and

991
00:39:06,000 --> 00:39:08,640
similar to the the paper just presented

992
00:39:08,640 --> 00:39:11,440
beforehand where the asymmetric crypto

993
00:39:11,440 --> 00:39:13,359
is the challenge

994
00:39:13,359 --> 00:39:14,560
for the

995
00:39:14,560 --> 00:39:16,160
computation complexity and power

996
00:39:16,160 --> 00:39:18,560
consumptions and we tried everything to

997
00:39:18,560 --> 00:39:21,280
reduce the power consumption

998
00:39:21,280 --> 00:39:24,160
for the paid protocol and this generates

999
00:39:24,160 --> 00:39:25,920
complexity of course for the security

1000
00:39:25,920 --> 00:39:28,320
analysis because we have some tweaks

1001
00:39:28,320 --> 00:39:30,640
which are normally not considered in

1002
00:39:30,640 --> 00:39:33,680
protocol security analysis

1003
00:39:33,680 --> 00:39:35,280
so since two years

1004
00:39:35,280 --> 00:39:38,320
cpas is recommended by cfrg for using

1005
00:39:38,320 --> 00:39:40,720
iatf protocols and this is also a part

1006
00:39:40,720 --> 00:39:42,880
which triggered the more detailed

1007
00:39:42,880 --> 00:39:46,000
analysis of our paper

1008
00:39:46,000 --> 00:39:48,000
to give you an idea

1009
00:39:48,000 --> 00:39:48,960
the

1010
00:39:48,960 --> 00:39:50,880
target platform that benoit and me had

1011
00:39:50,880 --> 00:39:53,599
in mind when designing cpas

1012
00:39:53,599 --> 00:39:56,720
first was an industrial control sensor

1013
00:39:56,720 --> 00:39:58,079
in a

1014
00:39:58,079 --> 00:40:00,400
critical infrastructure setting where we

1015
00:40:00,400 --> 00:40:01,599
had really

1016
00:40:01,599 --> 00:40:04,319
tight power budgets because of why of

1017
00:40:04,319 --> 00:40:06,319
explosion protected

1018
00:40:06,319 --> 00:40:08,640
environments and really we had really

1019
00:40:08,640 --> 00:40:09,760
tight

1020
00:40:09,760 --> 00:40:11,920
memory budgets and we tried really

1021
00:40:11,920 --> 00:40:15,200
everything to squeeze the

1022
00:40:15,200 --> 00:40:16,720
memory and

1023
00:40:16,720 --> 00:40:18,880
power consumption

1024
00:40:18,880 --> 00:40:21,200
requirements to the minimum the possible

1025
00:40:21,200 --> 00:40:22,640
minimum

1026
00:40:22,640 --> 00:40:24,880
to motivate you that's interest page is

1027
00:40:24,880 --> 00:40:27,520
interesting for constraint device here's

1028
00:40:27,520 --> 00:40:30,480
a slide taken from uh this year's crypto

1029
00:40:30,480 --> 00:40:31,599
conference

1030
00:40:31,599 --> 00:40:35,040
where an analysis has been uh

1031
00:40:35,040 --> 00:40:38,240
has revealed that the current 502

1032
00:40:38,240 --> 00:40:41,040
standard could be significantly improved

1033
00:40:41,040 --> 00:40:43,760
if one authentication step which where

1034
00:40:43,760 --> 00:40:44,720
the

1035
00:40:44,720 --> 00:40:47,520
the token is authenticated by a pin is

1036
00:40:47,520 --> 00:40:49,440
replaced by a peg protocol and also

1037
00:40:49,440 --> 00:40:51,599
there we have

1038
00:40:51,599 --> 00:40:52,960
situation that we have constrained

1039
00:40:52,960 --> 00:40:55,119
devices and also the interest to have a

1040
00:40:55,119 --> 00:40:57,280
protocol which is uh

1041
00:40:57,280 --> 00:40:59,040
more easily protected against side

1042
00:40:59,040 --> 00:41:00,960
channels

1043
00:41:00,960 --> 00:41:02,319
so

1044
00:41:02,319 --> 00:41:06,400
the cpace paper is mostly on

1045
00:41:06,400 --> 00:41:09,440
the topic of a quite

1046
00:41:09,440 --> 00:41:12,640
tedious security analysis where we tried

1047
00:41:12,640 --> 00:41:13,520
to

1048
00:41:13,520 --> 00:41:15,440
capture the implementation tweaks that

1049
00:41:15,440 --> 00:41:18,079
we have made to improve efficiency

1050
00:41:18,079 --> 00:41:20,720
and in order to obtain this

1051
00:41:20,720 --> 00:41:24,160
and realize this target we um formula

1052
00:41:24,160 --> 00:41:26,160
used a method where we formalized the

1053
00:41:26,160 --> 00:41:28,319
cryptographic assumptions by

1054
00:41:28,319 --> 00:41:31,200
executable code so essentially

1055
00:41:31,200 --> 00:41:32,960
for if you have an assumption you can

1056
00:41:32,960 --> 00:41:35,839
generate an experiment

1057
00:41:35,839 --> 00:41:38,000
algorithm where the experiment generates

1058
00:41:38,000 --> 00:41:40,800
a challenge and you try to

1059
00:41:40,800 --> 00:41:42,319
you hand over the challenge to some

1060
00:41:42,319 --> 00:41:45,280
adversary and you can represent the

1061
00:41:45,280 --> 00:41:47,680
assumption by the executable code of

1062
00:41:47,680 --> 00:41:49,760
this experiments

1063
00:41:49,760 --> 00:41:51,040
algorithm

1064
00:41:51,040 --> 00:41:52,880
and what we did is we embed the

1065
00:41:52,880 --> 00:41:54,800
assumption code in the main code body of

1066
00:41:54,800 --> 00:41:56,880
the simulator so it's not similar

1067
00:41:56,880 --> 00:42:00,240
separated step for the simulation

1068
00:42:00,240 --> 00:42:04,000
and a second step for

1069
00:42:04,000 --> 00:42:06,079
the reduction argument but we have the

1070
00:42:06,079 --> 00:42:08,800
reduction integrated in the simulator

1071
00:42:08,800 --> 00:42:10,480
code

1072
00:42:10,480 --> 00:42:11,839
and this

1073
00:42:11,839 --> 00:42:14,160
has the advantage that we can reuse the

1074
00:42:14,160 --> 00:42:15,119
same

1075
00:42:15,119 --> 00:42:17,920
simulator code body and only replace the

1076
00:42:17,920 --> 00:42:19,520
assumption code for

1077
00:42:19,520 --> 00:42:21,359
studying the efficiency tuned protocol

1078
00:42:21,359 --> 00:42:24,720
variants for instance we replace the

1079
00:42:24,720 --> 00:42:26,960
code which represents the computational

1080
00:42:26,960 --> 00:42:28,720
different assumption

1081
00:42:28,720 --> 00:42:31,200
with the code that represents the twist

1082
00:42:31,200 --> 00:42:32,560
secure

1083
00:42:32,560 --> 00:42:34,400
computational diffie-hellman assumption

1084
00:42:34,400 --> 00:42:37,359
when working on twist secure curves

1085
00:42:37,359 --> 00:42:40,560
and as a side effect i think or we think

1086
00:42:40,560 --> 00:42:43,040
that the reduction strategy

1087
00:42:43,040 --> 00:42:44,880
becomes more clearly visible in the

1088
00:42:44,880 --> 00:42:47,119
executable code because it's

1089
00:42:47,119 --> 00:42:48,880
you don't have the reduction argument

1090
00:42:48,880 --> 00:42:50,400
hidden in

1091
00:42:50,400 --> 00:42:53,280
on the last pages on over the text body

1092
00:42:53,280 --> 00:42:55,440
of an

1093
00:42:55,440 --> 00:42:56,800
appendix of

1094
00:42:56,800 --> 00:42:58,960
a proof paper but you really directly

1095
00:42:58,960 --> 00:43:03,119
directly see it in in the simulator code

1096
00:43:03,119 --> 00:43:05,040
and this helped us reducing the effort

1097
00:43:05,040 --> 00:43:06,800
for considering various implementation

1098
00:43:06,800 --> 00:43:08,880
tweaks and

1099
00:43:08,880 --> 00:43:11,839
we think that having a simulator which

1100
00:43:11,839 --> 00:43:14,240
has the assumptions integrated might

1101
00:43:14,240 --> 00:43:16,319
also make simulation based proofs more

1102
00:43:16,319 --> 00:43:20,400
accessible to machine based verification

1103
00:43:20,400 --> 00:43:23,440
so our results in a nutshell

1104
00:43:23,440 --> 00:43:26,079
our analysis has shown that cpace is a

1105
00:43:26,079 --> 00:43:28,319
fast and secure peak protocol

1106
00:43:28,319 --> 00:43:31,040
which enjoys composability under strong

1107
00:43:31,040 --> 00:43:34,240
adaptive adversary models

1108
00:43:34,240 --> 00:43:36,640
and and the various tweaks that were

1109
00:43:36,640 --> 00:43:38,880
inserted for constrained devices don't

1110
00:43:38,880 --> 00:43:41,520
impair security

1111
00:43:41,520 --> 00:43:42,400
second

1112
00:43:42,400 --> 00:43:44,640
result main result is that we were able

1113
00:43:44,640 --> 00:43:46,880
to derive the exact property that we

1114
00:43:46,880 --> 00:43:49,359
need from alligator 2 or

1115
00:43:49,359 --> 00:43:51,119
the other maps

1116
00:43:51,119 --> 00:43:53,520
and we coined this property

1117
00:43:53,520 --> 00:43:56,240
probabilistic invertibility

1118
00:43:56,240 --> 00:43:59,119
so basically it's the fact that

1119
00:43:59,119 --> 00:44:02,319
the map needs to have a few

1120
00:44:02,319 --> 00:44:03,200
uh

1121
00:44:03,200 --> 00:44:05,520
pre-images a point generated by the map

1122
00:44:05,520 --> 00:44:07,920
needs to be have a few pre-images and

1123
00:44:07,920 --> 00:44:09,920
you need to know how many

1124
00:44:09,920 --> 00:44:12,160
pre-images you can get in the worst case

1125
00:44:12,160 --> 00:44:13,839
case

1126
00:44:13,839 --> 00:44:15,280
and third

1127
00:44:15,280 --> 00:44:16,880
result is we

1128
00:44:16,880 --> 00:44:19,040
as i mentioned before we formalize the

1129
00:44:19,040 --> 00:44:20,640
reduction arguments by embedding

1130
00:44:20,640 --> 00:44:22,160
assumption libraries in the simulator

1131
00:44:22,160 --> 00:44:23,040
code

1132
00:44:23,040 --> 00:44:26,079
and this technique works whenever

1133
00:44:26,079 --> 00:44:28,400
assumptions are falsifiable because if

1134
00:44:28,400 --> 00:44:30,560
you have a falsifiable assumption you

1135
00:44:30,560 --> 00:44:32,960
are able to generate an efficient

1136
00:44:32,960 --> 00:44:35,440
algorithm for the experiment which

1137
00:44:35,440 --> 00:44:38,000
verifies the assumption

1138
00:44:38,000 --> 00:44:40,480
so we would like to

1139
00:44:40,480 --> 00:44:42,800
i hope that i motivated you to to have a

1140
00:44:42,800 --> 00:44:45,440
closer look at the paper

1141
00:44:45,440 --> 00:44:47,680
and the long talk

1142
00:44:47,680 --> 00:44:49,040
we also would

1143
00:44:49,040 --> 00:44:50,640
appreciate

1144
00:44:50,640 --> 00:44:53,520
review and feedback regarding the

1145
00:44:53,520 --> 00:44:55,599
current internet draft we are planning

1146
00:44:55,599 --> 00:44:58,480
to make a review larger review around

1147
00:44:58,480 --> 00:45:00,480
end of this year so any feedback there

1148
00:45:00,480 --> 00:45:01,599
is welcome

1149
00:45:01,599 --> 00:45:04,839
thank you

1150
00:45:04,880 --> 00:45:08,160
thank you john and um

1151
00:45:08,160 --> 00:45:12,240
and does anyone have any question

1152
00:45:15,920 --> 00:45:18,800
okay so i have i have one question i

1153
00:45:18,800 --> 00:45:21,280
do can you extend your result to the

1154
00:45:21,280 --> 00:45:23,760
asymmetric case and in particular

1155
00:45:23,760 --> 00:45:25,680
i am maybe i

1156
00:45:25,680 --> 00:45:27,359
look too fast but i had the impression

1157
00:45:27,359 --> 00:45:29,520
that the c base could easily be

1158
00:45:29,520 --> 00:45:31,920
transformed into isometric base because

1159
00:45:31,920 --> 00:45:34,400
you always start by hashing the

1160
00:45:34,400 --> 00:45:36,319
password and so i guess the server could

1161
00:45:36,319 --> 00:45:38,560
just otherwise r server

1162
00:45:38,560 --> 00:45:40,240
uh

1163
00:45:40,240 --> 00:45:42,720
so in fact in fact

1164
00:45:42,720 --> 00:45:46,400
originally c pace was a sub step in in

1165
00:45:46,400 --> 00:45:49,040
the in the when i go back to is a sub

1166
00:45:49,040 --> 00:45:51,520
step in the augmented page protocol that

1167
00:45:51,520 --> 00:45:54,319
we actually using in this device here

1168
00:45:54,319 --> 00:45:55,520
and and

1169
00:45:55,520 --> 00:45:56,400
the

1170
00:45:56,400 --> 00:45:58,079
protocol

1171
00:45:58,079 --> 00:46:01,920
the augmented variant is called oak pace

1172
00:46:01,920 --> 00:46:05,599
and there's it's um we have had a have a

1173
00:46:05,599 --> 00:46:08,720
publication on it in teeth from teachers

1174
00:46:08,720 --> 00:46:11,040
2018

1175
00:46:11,040 --> 00:46:12,560
so in atlanta

1176
00:46:12,560 --> 00:46:13,920
so

1177
00:46:13,920 --> 00:46:17,280
in fact you uh the c-pace has been uh

1178
00:46:17,280 --> 00:46:19,119
designed as a sub-component for the

1179
00:46:19,119 --> 00:46:21,520
security analysis of the of the larger

1180
00:46:21,520 --> 00:46:23,200
construction and for this reason it was

1181
00:46:23,200 --> 00:46:25,440
also important to have us you see proof

1182
00:46:25,440 --> 00:46:28,000
force the seepage sub-step because we

1183
00:46:28,000 --> 00:46:30,240
use

1184
00:46:31,520 --> 00:46:32,560
the

1185
00:46:32,560 --> 00:46:34,480
the fact that we can compose the c paste

1186
00:46:34,480 --> 00:46:37,119
substep in the larger construction

1187
00:46:37,119 --> 00:46:39,599
oh i see so your result automatically

1188
00:46:39,599 --> 00:46:43,520
carries to the augmented version

1189
00:46:43,520 --> 00:46:45,839
but it's more complex complex

1190
00:46:45,839 --> 00:46:48,160
so but that's the topic of the oak paste

1191
00:46:48,160 --> 00:46:50,960
paper from teachers

1192
00:46:50,960 --> 00:46:53,520
two years ago

1193
00:46:54,000 --> 00:46:55,040
okay

1194
00:46:55,040 --> 00:46:56,560
that's

1195
00:46:56,560 --> 00:46:58,560
some that's

1196
00:46:58,560 --> 00:47:01,420
any other question

1197
00:47:01,420 --> 00:47:03,920
[Music]

1198
00:47:03,920 --> 00:47:06,400
so let's move to the next talk then

1199
00:47:06,400 --> 00:47:08,960
uh then the next talk and final talk the

1200
00:47:08,960 --> 00:47:11,200
final talk of the section is

1201
00:47:11,200 --> 00:47:13,920
titled modular design of world symmetric

1202
00:47:13,920 --> 00:47:17,040
authenticated key exchange protocols and

1203
00:47:17,040 --> 00:47:20,160
it's a paper by xiao yutin

1204
00:47:20,160 --> 00:47:22,640
chong roy and ma

1205
00:47:22,640 --> 00:47:24,720
and you think is

1206
00:47:24,720 --> 00:47:26,880
giving the talk

1207
00:47:26,880 --> 00:47:29,280
thank you for introduction this work is

1208
00:47:29,280 --> 00:47:33,200
collaborated with rija and

1209
00:47:34,000 --> 00:47:36,160
oh before you begin can you just put it

1210
00:47:36,160 --> 00:47:38,960
in full screen mode or uh play

1211
00:47:38,960 --> 00:47:41,520
presentation mode something like that

1212
00:47:41,520 --> 00:47:44,000
okay okay

1213
00:47:46,559 --> 00:47:49,440
ah we're only seeing a portion

1214
00:47:49,440 --> 00:47:53,839
oh perfect never mind thank you

1215
00:47:55,200 --> 00:47:58,079
in the literature there are many strong

1216
00:47:58,079 --> 00:48:00,319
security models have been put forward

1217
00:48:00,319 --> 00:48:05,200
for pki best akes like ck 6 plus eck and

1218
00:48:05,200 --> 00:48:08,160
zero extensions

1219
00:48:08,160 --> 00:48:10,880
and to date these straw models were

1220
00:48:10,880 --> 00:48:13,599
widely accepted to become incomparable

1221
00:48:13,599 --> 00:48:16,319
with each other over more or less for

1222
00:48:16,319 --> 00:48:18,079
this reason

1223
00:48:18,079 --> 00:48:20,480
even melon products protocols have been

1224
00:48:20,480 --> 00:48:23,839
proposed but they were merely analyzed

1225
00:48:23,839 --> 00:48:25,760
in a single model

1226
00:48:25,760 --> 00:48:26,960
thus

1227
00:48:26,960 --> 00:48:30,720
in this field of pki best a case

1228
00:48:30,720 --> 00:48:33,680
we still lack a systematic understanding

1229
00:48:33,680 --> 00:48:36,079
of the pre-requests for constructing

1230
00:48:36,079 --> 00:48:38,160
secure akas

1231
00:48:38,160 --> 00:48:40,880
so our essential goal is to give better

1232
00:48:40,880 --> 00:48:43,920
systematic understandings of akes

1233
00:48:43,920 --> 00:48:46,720
more specific in the raw symmetrical

1234
00:48:46,720 --> 00:48:49,920
setting where nobody needs to wait and

1235
00:48:49,920 --> 00:48:52,000
it only involves two messages to

1236
00:48:52,000 --> 00:48:54,480
establish a session key

1237
00:48:54,480 --> 00:48:55,920
these are nice

1238
00:48:55,920 --> 00:48:57,440
properties

1239
00:48:57,440 --> 00:48:59,680
for practical use

1240
00:48:59,680 --> 00:49:03,200
for this we have we have we first made

1241
00:49:03,200 --> 00:49:06,240
efforts in understanding the security

1242
00:49:06,240 --> 00:49:07,520
different

1243
00:49:07,520 --> 00:49:08,960
definitions

1244
00:49:08,960 --> 00:49:11,040
thus we have a

1245
00:49:11,040 --> 00:49:12,920
substance and

1246
00:49:12,920 --> 00:49:14,960
comprehensible unification of the

1247
00:49:14,960 --> 00:49:16,800
elastic models

1248
00:49:16,800 --> 00:49:20,400
we also made efforts in constructing

1249
00:49:20,400 --> 00:49:25,440
methods to make it in a modular way

1250
00:49:25,440 --> 00:49:27,680
putting this together will also get some

1251
00:49:27,680 --> 00:49:30,079
new results

1252
00:49:30,079 --> 00:49:32,319
there are several important security

1253
00:49:32,319 --> 00:49:35,359
notions i should introduce here the

1254
00:49:35,359 --> 00:49:39,359
first one is perfect for security pfs

1255
00:49:39,359 --> 00:49:40,800
it states that

1256
00:49:40,800 --> 00:49:42,480
the

1257
00:49:42,480 --> 00:49:46,480
the compromise of the long-term keys of

1258
00:49:46,480 --> 00:49:49,839
both sides do not affect the secrecy of

1259
00:49:49,839 --> 00:49:51,839
older session keys

1260
00:49:51,839 --> 00:49:56,000
the second is a weak variant of cafes it

1261
00:49:56,000 --> 00:49:57,920
requires that the adversary should be

1262
00:49:57,920 --> 00:50:00,079
passive when generating the older

1263
00:50:00,079 --> 00:50:03,280
session keys the third is key compromise

1264
00:50:03,280 --> 00:50:06,319
impersonation kci in this attack the

1265
00:50:06,319 --> 00:50:10,640
adversary crafted some party like pi

1266
00:50:10,640 --> 00:50:11,440
then

1267
00:50:11,440 --> 00:50:14,960
is try authenticate itself

1268
00:50:14,960 --> 00:50:18,559
as some other party pj to pi

1269
00:50:18,559 --> 00:50:22,000
the last thing is maximal exposure max

1270
00:50:22,000 --> 00:50:24,960
in this attacks the adversary can get

1271
00:50:24,960 --> 00:50:27,280
keys on both sides

1272
00:50:27,280 --> 00:50:29,520
but at most one

1273
00:50:29,520 --> 00:50:31,040
on each side

1274
00:50:31,040 --> 00:50:34,319
the keys include the long-term keys of

1275
00:50:34,319 --> 00:50:37,760
the party or the ephemeral keys of a

1276
00:50:37,760 --> 00:50:39,680
session if a

1277
00:50:39,680 --> 00:50:43,279
also known as the reminisce

1278
00:50:43,599 --> 00:50:46,319
we formulated the existing security

1279
00:50:46,319 --> 00:50:47,440
models

1280
00:50:47,440 --> 00:50:50,960
as in these tables

1281
00:50:50,960 --> 00:50:51,680
but

1282
00:50:51,680 --> 00:50:53,520
by exhaustively

1283
00:50:53,520 --> 00:50:57,920
classifying key negative leakages

1284
00:50:57,920 --> 00:50:59,839
in each case

1285
00:50:59,839 --> 00:51:02,720
in each model

1286
00:51:02,720 --> 00:51:05,280
they can be classified into

1287
00:51:05,280 --> 00:51:08,240
a security notion we mentioned before

1288
00:51:08,240 --> 00:51:10,559
thus to achieve secure

1289
00:51:10,559 --> 00:51:14,000
akis the most important is to achieve

1290
00:51:14,000 --> 00:51:17,440
these security goals we also

1291
00:51:17,440 --> 00:51:20,800
abstracted the raw symmetrical case like

1292
00:51:20,800 --> 00:51:21,680
this

1293
00:51:21,680 --> 00:51:23,040
on each side

1294
00:51:23,040 --> 00:51:26,240
the its computations can be abstracted

1295
00:51:26,240 --> 00:51:27,680
as

1296
00:51:27,680 --> 00:51:29,760
three functions f

1297
00:51:29,760 --> 00:51:33,920
f c f bar and f c they are used to

1298
00:51:33,920 --> 00:51:35,119
compute

1299
00:51:35,119 --> 00:51:37,440
or recover

1300
00:51:37,440 --> 00:51:41,920
three key materials s-i-s-j-s-i-j

1301
00:51:41,920 --> 00:51:45,920
and finally and it will use a pdf to

1302
00:51:45,920 --> 00:51:48,480
derive a session key from this key

1303
00:51:48,480 --> 00:51:51,359
materials with such

1304
00:51:51,359 --> 00:51:53,520
abstraction we can

1305
00:51:53,520 --> 00:51:56,400
describe the paradigm of raw symmetry

1306
00:51:56,400 --> 00:51:58,480
keys like this

1307
00:51:58,480 --> 00:52:01,760
our starting point is how to securely

1308
00:52:01,760 --> 00:52:04,400
implement the function pair f

1309
00:52:04,400 --> 00:52:06,319
f bar

1310
00:52:06,319 --> 00:52:09,119
this motivates us to

1311
00:52:09,119 --> 00:52:13,520
define the function key wise recover

1312
00:52:13,520 --> 00:52:17,040
recoverable function kif and from this

1313
00:52:17,040 --> 00:52:19,200
security goals

1314
00:52:19,200 --> 00:52:22,319
we define several uh two

1315
00:52:22,319 --> 00:52:26,160
true security requirements for kif

1316
00:52:26,160 --> 00:52:29,520
and so we have a pif at hand we put it

1317
00:52:29,520 --> 00:52:33,200
back into our modular construction

1318
00:52:33,200 --> 00:52:35,359
a model uh our

1319
00:52:35,359 --> 00:52:36,319
our

1320
00:52:36,319 --> 00:52:39,520
generic description of raw summer kkk is

1321
00:52:39,520 --> 00:52:41,599
thus we can get our modular

1322
00:52:41,599 --> 00:52:44,800
constructions easily

1323
00:52:44,800 --> 00:52:47,119
our rmb results are listed as in these

1324
00:52:47,119 --> 00:52:48,319
tables

1325
00:52:48,319 --> 00:52:51,280
use a passively secure kickstring

1326
00:52:51,280 --> 00:52:54,559
protocol to implement fse

1327
00:52:54,559 --> 00:52:57,280
and assuming the underlying kif meets

1328
00:52:57,280 --> 00:52:58,400
different

1329
00:52:58,400 --> 00:53:01,599
properties we can get

1330
00:53:01,599 --> 00:53:03,200
different

1331
00:53:03,200 --> 00:53:04,720
secure

1332
00:53:04,720 --> 00:53:08,240
protocols in these models

1333
00:53:08,240 --> 00:53:11,520
apart from our modular constructions we

1334
00:53:11,520 --> 00:53:12,960
also get some

1335
00:53:12,960 --> 00:53:14,880
other results

1336
00:53:14,880 --> 00:53:17,200
we'll use our module constructions to

1337
00:53:17,200 --> 00:53:20,800
explain some existing protocols

1338
00:53:20,800 --> 00:53:24,079
about the in the cks explosive can

1339
00:53:24,079 --> 00:53:26,640
escape pfs models

1340
00:53:26,640 --> 00:53:30,640
of course according to our results

1341
00:53:30,640 --> 00:53:34,640
um the c the same kif can be used to

1342
00:53:34,640 --> 00:53:37,359
achieve security in both the ck-plus and

1343
00:53:37,359 --> 00:53:39,839
the ecap models

1344
00:53:39,839 --> 00:53:40,559
the

1345
00:53:40,559 --> 00:53:42,800
same result also holds

1346
00:53:42,800 --> 00:53:48,640
for the eck pfs and 6k plus pfs models

1347
00:53:48,640 --> 00:53:50,720
in particular will also

1348
00:53:50,720 --> 00:53:51,680
give

1349
00:53:51,680 --> 00:53:55,680
an extension of our results in the ckpfs

1350
00:53:55,680 --> 00:53:56,640
model

1351
00:53:56,640 --> 00:53:59,920
we give a new construction

1352
00:53:59,920 --> 00:54:04,000
it is inspired by the technique used in

1353
00:54:04,000 --> 00:54:06,000
bjs 15.

1354
00:54:06,000 --> 00:54:07,359
of course we

1355
00:54:07,359 --> 00:54:09,119
um

1356
00:54:09,119 --> 00:54:13,760
we will use our um observations

1357
00:54:13,760 --> 00:54:14,800
uh

1358
00:54:14,800 --> 00:54:17,359
of our results

1359
00:54:17,359 --> 00:54:20,559
uh which is the result is more efficient

1360
00:54:20,559 --> 00:54:25,680
than directly applying a compiler to

1361
00:54:25,680 --> 00:54:27,040
existing

1362
00:54:27,040 --> 00:54:30,400
protocol secure in the ck model

1363
00:54:30,400 --> 00:54:32,480
this compiler is

1364
00:54:32,480 --> 00:54:36,240
simply by adding signatures on the

1365
00:54:36,240 --> 00:54:40,480
messages sent by both sides

1366
00:54:40,480 --> 00:54:41,359
this

1367
00:54:41,359 --> 00:54:43,760
these are our main results i can

1368
00:54:43,760 --> 00:54:46,480
introduce in the five minutes

1369
00:54:46,480 --> 00:54:51,640
and that's all is there any questions

1370
00:54:52,480 --> 00:54:55,520
i thank you thank you eating

1371
00:54:55,520 --> 00:55:00,119
for your talk so is there any question

1372
00:55:06,000 --> 00:55:08,960
i guess i have a question for you like

1373
00:55:08,960 --> 00:55:10,240
did you

1374
00:55:10,240 --> 00:55:13,200
did you try to study like a

1375
00:55:13,200 --> 00:55:17,118
model in the uc setting

1376
00:55:18,480 --> 00:55:21,599
um on ucc user framework

1377
00:55:21,599 --> 00:55:22,880
yes

1378
00:55:22,880 --> 00:55:26,000
oh no i haven't considered the uc

1379
00:55:26,000 --> 00:55:29,000
framework

1380
00:55:34,319 --> 00:55:37,440
okay so if you have a any

1381
00:55:37,440 --> 00:55:39,920
any question to you thing or any other

1382
00:55:39,920 --> 00:55:41,520
previous speaker

1383
00:55:41,520 --> 00:55:42,559
please

1384
00:55:42,559 --> 00:55:48,040
send it to the chat or like julie

1385
00:55:48,170 --> 00:55:51,449
[Music]

1386
00:55:54,000 --> 00:55:56,160
okay

1387
00:55:56,160 --> 00:55:57,440
so i think

1388
00:55:57,440 --> 00:56:00,799
that concludes our session so we'd like

1389
00:56:00,799 --> 00:56:03,680
we'd like to thank all the speaker again

1390
00:56:03,680 --> 00:56:06,399
for that

1391
00:56:07,280 --> 00:56:09,920
and thank you for the station

1392
00:56:09,920 --> 00:56:12,559
thank you all for for

1393
00:56:12,559 --> 00:56:14,319
presenting the first part of the session

1394
00:56:14,319 --> 00:56:15,119
and

1395
00:56:15,119 --> 00:56:17,440
i think you can all come back uh

1396
00:56:17,440 --> 00:56:20,240
tomorrow so it's 3am for me so i won't

1397
00:56:20,240 --> 00:56:21,440
be there but

1398
00:56:21,440 --> 00:56:23,520
there is a completed talk by caswell

1399
00:56:23,520 --> 00:56:24,559
cycle

1400
00:56:24,559 --> 00:56:25,359
at

1401
00:56:25,359 --> 00:56:28,319
atm ptc

1402
00:56:28,799 --> 00:56:30,960
yes thank you very much everyone for

1403
00:56:30,960 --> 00:56:33,359
participating and then

1404
00:56:33,359 --> 00:56:36,680
see you tomorrow

