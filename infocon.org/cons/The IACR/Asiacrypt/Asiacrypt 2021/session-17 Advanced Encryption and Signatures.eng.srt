1
00:00:02,639 --> 00:00:05,759
yes so we will start the session

2
00:00:05,759 --> 00:00:08,880
advanced encryption and signatures

3
00:00:08,880 --> 00:00:10,000
the first

4
00:00:10,000 --> 00:00:13,120
presentation is public key encryption

5
00:00:13,120 --> 00:00:17,719
with flexible pattern matching

6
00:00:19,630 --> 00:00:22,480
[Music]

7
00:00:22,480 --> 00:00:23,600
so

8
00:00:23,600 --> 00:00:25,439
please go ahead

9
00:00:25,439 --> 00:00:27,920
thank you very much hello everyone

10
00:00:27,920 --> 00:00:29,439
so

11
00:00:29,439 --> 00:00:32,960
first just to recall that uh public key

12
00:00:32,960 --> 00:00:35,520
classical public public key encryption

13
00:00:35,520 --> 00:00:38,239
ensures the privacy of traffic between

14
00:00:38,239 --> 00:00:40,239
users

15
00:00:40,239 --> 00:00:44,000
but if the receiver wants to use an

16
00:00:44,000 --> 00:00:46,960
intrusion detect detection system so a

17
00:00:46,960 --> 00:00:49,120
service provider who

18
00:00:49,120 --> 00:00:51,440
analyzes the traffic to check if there

19
00:00:51,440 --> 00:00:53,760
is malicious activity

20
00:00:53,760 --> 00:00:56,320
then he can only give the secret key to

21
00:00:56,320 --> 00:00:59,039
him and it breaks the

22
00:00:59,039 --> 00:01:01,520
the end-to-end encryption

23
00:01:01,520 --> 00:01:03,680
so in searchable encryption

24
00:01:03,680 --> 00:01:05,920
if the service provider needs to search

25
00:01:05,920 --> 00:01:08,000
for some pattern w

26
00:01:08,000 --> 00:01:10,799
he can ask a trapdoor to the receiver

27
00:01:10,799 --> 00:01:12,479
and with this trapdoor

28
00:01:12,479 --> 00:01:15,119
he can see if the pattern occurs in the

29
00:01:15,119 --> 00:01:17,920
traffic but he learns nothing else

30
00:01:17,920 --> 00:01:18,960
okay

31
00:01:18,960 --> 00:01:22,400
so now what i want to show you is that

32
00:01:22,400 --> 00:01:24,799
the use case we are looking

33
00:01:24,799 --> 00:01:28,000
at is very different from

34
00:01:28,000 --> 00:01:30,720
the one of existing of some existing

35
00:01:30,720 --> 00:01:32,799
solutions namely

36
00:01:32,799 --> 00:01:35,759
uh symmetric searchable encryption

37
00:01:35,759 --> 00:01:36,640
so

38
00:01:36,640 --> 00:01:39,600
if we compare the the case where we are

39
00:01:39,600 --> 00:01:41,680
rooting emails

40
00:01:41,680 --> 00:01:43,040
emails

41
00:01:43,040 --> 00:01:45,439
can be

42
00:01:45,920 --> 00:01:48,799
associated with keywords naturally

43
00:01:48,799 --> 00:01:51,200
like the words that appear in the object

44
00:01:51,200 --> 00:01:53,119
field

45
00:01:53,119 --> 00:01:55,680
so they are indexable data

46
00:01:55,680 --> 00:01:58,399
uh and in deep packet inspection so if

47
00:01:58,399 --> 00:02:01,119
we look directly in the traffic it's

48
00:02:01,119 --> 00:02:03,119
like it's a stream

49
00:02:03,119 --> 00:02:06,799
that may or may not contain some pattern

50
00:02:06,799 --> 00:02:10,080
so in the first case uh

51
00:02:10,080 --> 00:02:13,440
the the server who is looking for males

52
00:02:13,440 --> 00:02:16,000
with some keyword is just performing an

53
00:02:16,000 --> 00:02:19,040
equality test with the keyword attached

54
00:02:19,040 --> 00:02:21,760
and in our case he's trying to find a

55
00:02:21,760 --> 00:02:24,319
pattern that can occur at any position

56
00:02:24,319 --> 00:02:26,958
in the stream

57
00:02:27,120 --> 00:02:30,239
here the dictionary of keywords can be

58
00:02:30,239 --> 00:02:32,239
set before setup

59
00:02:32,239 --> 00:02:34,800
but here the the patterns that are

60
00:02:34,800 --> 00:02:38,400
filtered evolve to to get new virus

61
00:02:38,400 --> 00:02:40,160
signatures

62
00:02:40,160 --> 00:02:42,080
and

63
00:02:42,080 --> 00:02:44,560
a pattern can even be searched in

64
00:02:44,560 --> 00:02:47,040
something that has been encrypted before

65
00:02:47,040 --> 00:02:48,879
we chose this pattern

66
00:02:48,879 --> 00:02:53,280
for forensic search uh for instance

67
00:02:53,280 --> 00:02:56,640
uh so we we we give another name to our

68
00:02:56,640 --> 00:03:00,239
special case and we we we name it stream

69
00:03:00,239 --> 00:03:02,840
encryption supporting pattern

70
00:03:02,840 --> 00:03:06,720
matching so just a loop a quick look at

71
00:03:06,720 --> 00:03:09,040
the kind of pattern that we can have to

72
00:03:09,040 --> 00:03:11,360
to search so this is a

73
00:03:11,360 --> 00:03:13,680
list for some

74
00:03:13,680 --> 00:03:16,239
version of snort

75
00:03:16,239 --> 00:03:18,640
which is an ids an intrusion detection

76
00:03:18,640 --> 00:03:20,400
system and we see there are many

77
00:03:20,400 --> 00:03:23,120
patterns um

78
00:03:23,120 --> 00:03:23,840
and

79
00:03:23,840 --> 00:03:26,080
we see that they have very different

80
00:03:26,080 --> 00:03:27,599
lengths uh

81
00:03:27,599 --> 00:03:30,720
quite short but very different lengths

82
00:03:30,720 --> 00:03:35,040
and so uh some solutions uh try to

83
00:03:35,040 --> 00:03:39,360
to get back to string equality so there

84
00:03:39,360 --> 00:03:42,720
they break the stream into strings of

85
00:03:42,720 --> 00:03:44,879
fixed length

86
00:03:44,879 --> 00:03:45,680
so

87
00:03:45,680 --> 00:03:47,920
for instance here uh

88
00:03:47,920 --> 00:03:50,799
in blind box uh if we

89
00:03:50,799 --> 00:03:53,120
if we choose a sliding window of four

90
00:03:53,120 --> 00:03:54,239
letters

91
00:03:54,239 --> 00:03:55,360
uh

92
00:03:55,360 --> 00:03:57,680
every four consecutive letter will be

93
00:03:57,680 --> 00:04:00,319
encrypted into one ciphertext element

94
00:04:00,319 --> 00:04:02,720
and we can give trapdoors

95
00:04:02,720 --> 00:04:05,840
for only keywords of of length four so

96
00:04:05,840 --> 00:04:07,599
for instance we can give a trapdoor for

97
00:04:07,599 --> 00:04:08,640
hosts

98
00:04:08,640 --> 00:04:10,799
and the service provider can learn that

99
00:04:10,799 --> 00:04:12,959
host is in there

100
00:04:12,959 --> 00:04:15,280
but hostile has a different length and

101
00:04:15,280 --> 00:04:16,079
so

102
00:04:16,079 --> 00:04:18,079
it won't be encrypted at once and we

103
00:04:18,079 --> 00:04:21,120
cannot give a trapdoor for it like that

104
00:04:21,120 --> 00:04:22,639
so one

105
00:04:22,639 --> 00:04:25,280
possibility would be to to encrypt

106
00:04:25,280 --> 00:04:27,759
everything for each length but we have

107
00:04:27,759 --> 00:04:29,360
seen that the patterns have very

108
00:04:29,360 --> 00:04:31,280
different lengths so this is very low

109
00:04:31,280 --> 00:04:32,720
efficiency

110
00:04:32,720 --> 00:04:36,240
and a third possibility would be to

111
00:04:36,240 --> 00:04:39,759
break hostile into host and tile and to

112
00:04:39,759 --> 00:04:41,199
search these two

113
00:04:41,199 --> 00:04:44,639
but now the service provider learns more

114
00:04:44,639 --> 00:04:47,680
information he can learn if tile is in

115
00:04:47,680 --> 00:04:48,800
in it

116
00:04:48,800 --> 00:04:50,240
and we have seen that there are many

117
00:04:50,240 --> 00:04:52,320
patterns so if we do that for every

118
00:04:52,320 --> 00:04:55,360
pattern we get a lot of extra

119
00:04:55,360 --> 00:04:58,560
information for the service provider

120
00:04:58,560 --> 00:05:00,000
uh

121
00:05:00,000 --> 00:05:02,320
the generic solution we we are not

122
00:05:02,320 --> 00:05:04,240
really interested in them because they

123
00:05:04,240 --> 00:05:06,960
are very costly so we wanted solutions

124
00:05:06,960 --> 00:05:09,520
that are more specific to our problem

125
00:05:09,520 --> 00:05:12,240
and there are there exists uh two papers

126
00:05:12,240 --> 00:05:15,039
that use bilinear pairings

127
00:05:15,039 --> 00:05:17,199
and the second one is really adapted to

128
00:05:17,199 --> 00:05:20,400
streams but they have two limitations

129
00:05:20,400 --> 00:05:23,520
first both of them are on a rely on a

130
00:05:23,520 --> 00:05:24,400
very

131
00:05:24,400 --> 00:05:27,280
strong assumption that is interactive

132
00:05:27,280 --> 00:05:29,520
and their public key depends on the size

133
00:05:29,520 --> 00:05:32,639
of the alphabet and patterns use byte

134
00:05:32,639 --> 00:05:34,479
strings so there is a two to the eighth

135
00:05:34,479 --> 00:05:35,840
factor

136
00:05:35,840 --> 00:05:38,000
and so we address both this problem by

137
00:05:38,000 --> 00:05:41,759
providing uh two schemes uh the first

138
00:05:41,759 --> 00:05:44,479
one is really efficient uh

139
00:05:44,479 --> 00:05:46,400
and it

140
00:05:46,400 --> 00:05:48,320
reduced the size of the public key by a

141
00:05:48,320 --> 00:05:51,120
factor two to the fourth and it halves

142
00:05:51,120 --> 00:05:52,720
the size of the ciphertext of the

143
00:05:52,720 --> 00:05:56,240
previous solutions and the second scheme

144
00:05:56,240 --> 00:05:59,759
also has removed the dependency on the

145
00:05:59,759 --> 00:06:01,360
alphabet size

146
00:06:01,360 --> 00:06:03,919
and he it's the first one that uses a

147
00:06:03,919 --> 00:06:07,199
static assumption for security

148
00:06:07,199 --> 00:06:09,600
yeah that's that's it for me thank you

149
00:06:09,600 --> 00:06:10,639
um

150
00:06:10,639 --> 00:06:11,919
and

151
00:06:11,919 --> 00:06:14,560
any question is welcomed

152
00:06:14,560 --> 00:06:16,080
thank you

153
00:06:16,080 --> 00:06:19,719
so uh

154
00:06:20,720 --> 00:06:23,600
no question on sleep chat

155
00:06:23,600 --> 00:06:26,000
if some you have some question or

156
00:06:26,000 --> 00:06:27,120
comment

157
00:06:27,120 --> 00:06:28,160
please

158
00:06:28,160 --> 00:06:30,400
write down on drip

159
00:06:30,400 --> 00:06:34,120
or zoom chat

160
00:06:37,840 --> 00:06:40,560
so i have one naive question

161
00:06:40,560 --> 00:06:41,919
so uh

162
00:06:41,919 --> 00:06:43,600
what is the next

163
00:06:43,600 --> 00:06:46,560
direction or some open problem

164
00:06:46,560 --> 00:06:49,840
of your work here

165
00:06:49,840 --> 00:06:52,400
so uh the security that is proven for

166
00:06:52,400 --> 00:06:54,960
all these schemes is uh selective

167
00:06:54,960 --> 00:06:56,319
security

168
00:06:56,319 --> 00:06:58,880
so we are looking for adaptative

169
00:06:58,880 --> 00:07:00,479
adaptive security

170
00:07:00,479 --> 00:07:03,599
if possible and uh another thing is that

171
00:07:03,599 --> 00:07:07,360
we are using bilinear pairings and it's

172
00:07:07,360 --> 00:07:08,400
still

173
00:07:08,400 --> 00:07:11,120
costly uh for

174
00:07:11,120 --> 00:07:13,520
real-time computation

175
00:07:13,520 --> 00:07:16,160
so we are trying to find

176
00:07:16,160 --> 00:07:17,199
lighter

177
00:07:17,199 --> 00:07:20,479
lighter solutions also yes okay thank

178
00:07:20,479 --> 00:07:21,759
you so

179
00:07:21,759 --> 00:07:22,720
uh

180
00:07:22,720 --> 00:07:25,199
for adaptive security so

181
00:07:25,199 --> 00:07:28,479
uh your scheme use batting appearing so

182
00:07:28,479 --> 00:07:31,199
usually such kind of uh

183
00:07:31,199 --> 00:07:34,000
public encryption scheme can be

184
00:07:34,000 --> 00:07:36,800
leveraged too by using a

185
00:07:36,800 --> 00:07:39,120
dual system encryption framework so you

186
00:07:39,120 --> 00:07:41,199
tried it already

187
00:07:41,199 --> 00:07:43,919
so yes we we are looking at these

188
00:07:43,919 --> 00:07:47,599
solutions and um

189
00:07:47,599 --> 00:07:50,879
so the the the first uh papers that that

190
00:07:50,879 --> 00:07:53,840
we see they don't provide directly a

191
00:07:53,840 --> 00:07:56,160
solution for it uh

192
00:07:56,160 --> 00:07:57,890
because the the

193
00:07:57,890 --> 00:07:59,599
[Music]

194
00:07:59,599 --> 00:08:03,520
uh the security that we are using uh is

195
00:08:03,520 --> 00:08:06,400
the adversary can make a lot of queries

196
00:08:06,400 --> 00:08:09,840
for trapdoors in it uh so it's it's a

197
00:08:09,840 --> 00:08:11,360
it's at least

198
00:08:11,360 --> 00:08:14,800
very much more complicated than identity

199
00:08:14,800 --> 00:08:17,599
based encryption or stuff like that

200
00:08:17,599 --> 00:08:20,400
uh so we are looking uh for more

201
00:08:20,400 --> 00:08:22,720
sophisticated things and

202
00:08:22,720 --> 00:08:24,639
and we'll see if there is something that

203
00:08:24,639 --> 00:08:27,280
works yeah i see i see

204
00:08:27,280 --> 00:08:29,919
that's a really nice uh

205
00:08:29,919 --> 00:08:31,680
way yeah yeah

206
00:08:31,680 --> 00:08:33,120
yeah very

207
00:08:33,120 --> 00:08:34,240
nice

208
00:08:34,240 --> 00:08:37,599
yeah i see i understand

209
00:08:37,599 --> 00:08:38,320
the

210
00:08:38,320 --> 00:08:41,360
technical hardware

211
00:08:41,360 --> 00:08:46,560
okay so any other question or comment

212
00:08:46,560 --> 00:08:48,480
so we have no

213
00:08:48,480 --> 00:08:51,519
uh no more uh comment so okay i'll

214
00:08:51,519 --> 00:08:53,279
return to the next

215
00:08:53,279 --> 00:08:55,839
so uh

216
00:08:55,839 --> 00:08:58,160
jeffrey you so

217
00:08:58,160 --> 00:09:02,719
can can you make a presentation here now

218
00:09:05,279 --> 00:09:06,080
oh

219
00:09:06,080 --> 00:09:08,959
okay okay okay

220
00:09:08,959 --> 00:09:10,320
so the next

221
00:09:10,320 --> 00:09:11,760
uh talk

222
00:09:11,760 --> 00:09:16,399
uh is uh title is

223
00:09:17,040 --> 00:09:19,360
adaptive security via

224
00:09:19,360 --> 00:09:21,680
deletion in attribute-based encryption

225
00:09:21,680 --> 00:09:23,680
solutions from

226
00:09:23,680 --> 00:09:26,880
such assumptions in barina groups

227
00:09:26,880 --> 00:09:27,760
by

228
00:09:27,760 --> 00:09:30,800
lishav goyal joffrey liu and brent

229
00:09:30,800 --> 00:09:34,399
waters so a presentation given is will

230
00:09:34,399 --> 00:09:38,080
be given by uh jeffrey liu so please go

231
00:09:38,080 --> 00:09:40,000
ahead

232
00:09:40,000 --> 00:09:43,360
okay uh just give me one second um

233
00:09:43,360 --> 00:09:44,480
okay

234
00:09:44,480 --> 00:09:45,279
um

235
00:09:45,279 --> 00:09:48,080
okay so i'll talk about that to security

236
00:09:48,080 --> 00:09:50,959
by deletion attribute-based encryption

237
00:09:50,959 --> 00:09:52,959
and this joins this is john ward with

238
00:09:52,959 --> 00:09:55,760
richard goyal and brent waters

239
00:09:55,760 --> 00:09:57,680
so everyone see the present presenter

240
00:09:57,680 --> 00:09:59,440
view do you mind sort of just

241
00:09:59,440 --> 00:10:03,200
already okay yeah just just uh

242
00:10:03,200 --> 00:10:05,120
yeah sorry let me let me share once

243
00:10:05,120 --> 00:10:07,600
again um

244
00:10:07,600 --> 00:10:08,959
let me share

245
00:10:08,959 --> 00:10:10,720
okay

246
00:10:10,720 --> 00:10:13,720
um

247
00:10:24,959 --> 00:10:27,920
uh is it good right now good okay

248
00:10:27,920 --> 00:10:29,279
okay okay

249
00:10:29,279 --> 00:10:32,640
cool okay so okay as we know av was

250
00:10:32,640 --> 00:10:35,519
first formulated in these two papers and

251
00:10:35,519 --> 00:10:37,519
in a b scheme we

252
00:10:37,519 --> 00:10:40,800
uh every user has attribute as nb binary

253
00:10:40,800 --> 00:10:42,959
string and we have policies as boolean

254
00:10:42,959 --> 00:10:44,079
functions

255
00:10:44,079 --> 00:10:47,040
uh the two issue keys we first generate

256
00:10:47,040 --> 00:10:49,040
the public key and master secret key and

257
00:10:49,040 --> 00:10:50,399
we derive

258
00:10:50,399 --> 00:10:51,200
uh

259
00:10:51,200 --> 00:10:54,560
uh and we uh when we encrypt we can uh

260
00:10:54,560 --> 00:10:56,399
use a master secret key we can derive

261
00:10:56,399 --> 00:10:58,160
secret keys associated with different

262
00:10:58,160 --> 00:11:00,399
attributes and when we encrypt we

263
00:11:00,399 --> 00:11:02,640
encrypt using the public key

264
00:11:02,640 --> 00:11:05,519
and policy

265
00:11:05,519 --> 00:11:08,160
and only users with the secret key

266
00:11:08,160 --> 00:11:10,240
associated with attributes that these

267
00:11:10,240 --> 00:11:12,640
policies evaluate on them to be one can

268
00:11:12,640 --> 00:11:14,800
decrypt the ciphertext and the rest

269
00:11:14,800 --> 00:11:16,000
cannot

270
00:11:16,000 --> 00:11:18,000
and this format uh this formulation is

271
00:11:18,000 --> 00:11:20,720
called ciphertext policy b specifically

272
00:11:20,720 --> 00:11:22,640
since the policy is embedded into the

273
00:11:22,640 --> 00:11:24,640
ciphertext and there's a also due

274
00:11:24,640 --> 00:11:26,880
formulation called key policy ab where

275
00:11:26,880 --> 00:11:29,680
we embed the policy into the secret key

276
00:11:29,680 --> 00:11:31,760
and both of these formulations and we

277
00:11:31,760 --> 00:11:33,839
have two levels of semantic security

278
00:11:33,839 --> 00:11:35,440
requirement

279
00:11:35,440 --> 00:11:37,680
in most papers uh

280
00:11:37,680 --> 00:11:40,959
papers will discuss these two levels and

281
00:11:40,959 --> 00:11:42,720
what we usually would want in practice

282
00:11:42,720 --> 00:11:45,360
is of of course the full security also

283
00:11:45,360 --> 00:11:47,760
called adaptive that adversary first

284
00:11:47,760 --> 00:11:50,320
sees the public key it queries a bunch

285
00:11:50,320 --> 00:11:52,720
of secret keys associated with some

286
00:11:52,720 --> 00:11:54,079
attributes and

287
00:11:54,079 --> 00:11:56,160
then he sends in a challenge policy and

288
00:11:56,160 --> 00:11:58,560
the message to messages adversary the

289
00:11:58,560 --> 00:12:00,959
challenger encrypts well the messages

290
00:12:00,959 --> 00:12:03,120
with respect to this policy and the

291
00:12:03,120 --> 00:12:05,200
adversary is not supposed to guess which

292
00:12:05,200 --> 00:12:07,440
message is encrypt encrypted this

293
00:12:07,440 --> 00:12:09,519
definition even though natural but uh

294
00:12:09,519 --> 00:12:12,000
it's in fact hard to realize

295
00:12:12,000 --> 00:12:14,880
uh in most cases and people often turn

296
00:12:14,880 --> 00:12:16,720
to this weaker notion called selective

297
00:12:16,720 --> 00:12:18,720
security first

298
00:12:18,720 --> 00:12:21,360
if they are not able to prove adaptive

299
00:12:21,360 --> 00:12:24,079
security and in this case adversary has

300
00:12:24,079 --> 00:12:25,360
to send in

301
00:12:25,360 --> 00:12:27,839
uh the policy uh the challenge policy it

302
00:12:27,839 --> 00:12:29,760
wants to attack on before it even sees

303
00:12:29,760 --> 00:12:32,240
the public uh keys

304
00:12:32,240 --> 00:12:34,480
um the if we look at the line of works

305
00:12:34,480 --> 00:12:37,680
that try to build a secure abe

306
00:12:37,680 --> 00:12:39,600
so starting from group assumptions this

307
00:12:39,600 --> 00:12:42,480
already works but selecting security

308
00:12:42,480 --> 00:12:45,200
from bilinear decay helmet

309
00:12:45,200 --> 00:12:48,000
and later on there was this dual system

310
00:12:48,000 --> 00:12:50,480
technique introduced by waters and we

311
00:12:50,480 --> 00:12:53,519
could realize adaptive security but uh

312
00:12:53,519 --> 00:12:56,639
the real uh reliance on decisional uh

313
00:12:56,639 --> 00:12:58,639
bilinear assumptions seems inherent in

314
00:12:58,639 --> 00:12:59,519
these

315
00:12:59,519 --> 00:13:00,480
uh

316
00:13:00,480 --> 00:13:02,720
in these works in in these techniques

317
00:13:02,720 --> 00:13:04,639
and whereas the earlier selective

318
00:13:04,639 --> 00:13:06,639
security schemes can actually be built

319
00:13:06,639 --> 00:13:09,040
from search assumptions

320
00:13:09,040 --> 00:13:11,680
and uh um moving to the lattice side

321
00:13:11,680 --> 00:13:14,079
these works uh realized selective

322
00:13:14,079 --> 00:13:17,120
security from lattice but it was uh

323
00:13:17,120 --> 00:13:19,600
uh always it's been been a long time

324
00:13:19,600 --> 00:13:21,519
before we we finally had something of

325
00:13:21,519 --> 00:13:23,839
adaptive security from latis

326
00:13:23,839 --> 00:13:26,480
and there was a recent breakthrough in

327
00:13:26,480 --> 00:13:28,720
2019 by separate

328
00:13:28,720 --> 00:13:30,720
it realized that definitely secure abe

329
00:13:30,720 --> 00:13:32,160
from lattice even though the

330
00:13:32,160 --> 00:13:35,279
functionality was in fact a

331
00:13:35,279 --> 00:13:37,519
subset functionality it is a step

332
00:13:37,519 --> 00:13:39,120
forward towards

333
00:13:39,120 --> 00:13:41,360
uh adaptive security and it's different

334
00:13:41,360 --> 00:13:44,399
from our past approaches

335
00:13:44,399 --> 00:13:46,880
so and we therefore would ask can we

336
00:13:46,880 --> 00:13:48,800
generalize this approach

337
00:13:48,800 --> 00:13:50,560
to make adaptive security hope for more

338
00:13:50,560 --> 00:13:52,160
general cases

339
00:13:52,160 --> 00:13:54,959
um okay in our work we simplify and

340
00:13:54,959 --> 00:13:57,600
expand the framework of realizing

341
00:13:57,600 --> 00:14:00,720
adaptive security in february 2019 and

342
00:14:00,720 --> 00:14:03,040
we we showed that the the simplified

343
00:14:03,040 --> 00:14:04,880
framework can be instantiated from both

344
00:14:04,880 --> 00:14:06,959
search bi-linear assumptions and

345
00:14:06,959 --> 00:14:08,160
lattices

346
00:14:08,160 --> 00:14:10,079
and we will still stick with the subset

347
00:14:10,079 --> 00:14:11,600
functionality

348
00:14:11,600 --> 00:14:14,160
and our high-level approach is combining

349
00:14:14,160 --> 00:14:16,720
two building blocks the first one is a

350
00:14:16,720 --> 00:14:19,199
selectively secure key policy a b with

351
00:14:19,199 --> 00:14:21,519
deletable property and it should shoot

352
00:14:21,519 --> 00:14:23,680
for nc1 circuit

353
00:14:23,680 --> 00:14:24,880
and

354
00:14:24,880 --> 00:14:26,720
the second building block is constrained

355
00:14:26,720 --> 00:14:28,800
prf with this deletion conforming

356
00:14:28,800 --> 00:14:31,040
property together we can realize that

357
00:14:31,040 --> 00:14:33,519
adaptive secure and cipher text policy

358
00:14:33,519 --> 00:14:35,519
ade

359
00:14:35,519 --> 00:14:37,839
and uh let's quickly go over like the

360
00:14:37,839 --> 00:14:40,000
properties we need so what's a deletable

361
00:14:40,000 --> 00:14:42,639
abe so basically we have two approaches

362
00:14:42,639 --> 00:14:44,480
to perform deletion

363
00:14:44,480 --> 00:14:46,880
uh the first one is uh we can remove

364
00:14:46,880 --> 00:14:48,240
certain blocks

365
00:14:48,240 --> 00:14:50,160
uh on the cipher text according to an

366
00:14:50,160 --> 00:14:52,560
index set and the second one is we

367
00:14:52,560 --> 00:14:55,760
remove certain indices in an attribute

368
00:14:55,760 --> 00:14:57,760
replace it with like a special symbol

369
00:14:57,760 --> 00:15:00,240
for example bought and we we can have a

370
00:15:00,240 --> 00:15:03,279
valid encryption procedure that encrypts

371
00:15:03,279 --> 00:15:05,839
such as cipher text and we get a cipher

372
00:15:05,839 --> 00:15:08,160
text that is indistinguishable from one

373
00:15:08,160 --> 00:15:10,560
that you where where we perform the

374
00:15:10,560 --> 00:15:11,600
deletion

375
00:15:11,600 --> 00:15:14,079
over the ciphertext

376
00:15:14,079 --> 00:15:16,240
and a second building block is a

377
00:15:16,240 --> 00:15:18,399
constraint prf we know that in

378
00:15:18,399 --> 00:15:21,360
construing prf we can constrain this a

379
00:15:21,360 --> 00:15:22,720
secret key

380
00:15:22,720 --> 00:15:24,480
according to a functionality so that you

381
00:15:24,480 --> 00:15:28,639
can only evaluate uh on the on par on

382
00:15:28,639 --> 00:15:30,079
the inputs that

383
00:15:30,079 --> 00:15:32,560
satisfy this functionality

384
00:15:32,560 --> 00:15:35,120
and here we need additional property for

385
00:15:35,120 --> 00:15:38,560
the constraint prf oh sorry uh we can

386
00:15:38,560 --> 00:15:41,040
actually constrain the uh the prf by

387
00:15:41,040 --> 00:15:42,800
just removing certain blocks from the

388
00:15:42,800 --> 00:15:45,600
master secret key uh similar to what we

389
00:15:45,600 --> 00:15:47,199
did for the attributes

390
00:15:47,199 --> 00:15:49,680
and here uh we we can uh given

391
00:15:49,680 --> 00:15:51,680
functionality f we we should be able to

392
00:15:51,680 --> 00:15:55,279
know which blocks we should remove

393
00:15:55,279 --> 00:15:57,360
and another property is that we can do

394
00:15:57,360 --> 00:15:58,720
this uh

395
00:15:58,720 --> 00:16:01,120
evaluation on the prf with some

396
00:16:01,120 --> 00:16:04,160
hard coded x uh hard coded x

397
00:16:04,160 --> 00:16:07,519
and uh so due to time uh restriction i

398
00:16:07,519 --> 00:16:09,680
won't going to talk about how i complete

399
00:16:09,680 --> 00:16:11,759
uh com how we combine these two building

400
00:16:11,759 --> 00:16:13,120
blocks to give us

401
00:16:13,120 --> 00:16:16,079
fully security let's just briefly talk

402
00:16:16,079 --> 00:16:17,920
about how we instantiate these building

403
00:16:17,920 --> 00:16:19,120
blocks and

404
00:16:19,120 --> 00:16:21,279
the uh the audience can refer to our

405
00:16:21,279 --> 00:16:23,839
papers for details on the construction

406
00:16:23,839 --> 00:16:25,600
and to to instantiate division

407
00:16:25,600 --> 00:16:28,240
conforming constraint prf it's not hard

408
00:16:28,240 --> 00:16:31,120
we can have such a constraint prf with a

409
00:16:31,120 --> 00:16:32,480
subset

410
00:16:32,480 --> 00:16:35,440
functionality following these two works

411
00:16:35,440 --> 00:16:38,639
and for lattices we have uh like uh

412
00:16:38,639 --> 00:16:41,440
sort of more more choices um sorry for

413
00:16:41,440 --> 00:16:43,519
for deletable a b we have more choices

414
00:16:43,519 --> 00:16:44,959
and instantiation

415
00:16:44,959 --> 00:16:47,680
we can uh for the by linear group site

416
00:16:47,680 --> 00:16:52,199
we can modify the gps w uh 2006 uh

417
00:16:52,199 --> 00:16:54,160
2006 paper

418
00:16:54,160 --> 00:16:55,600
uh

419
00:16:55,600 --> 00:16:58,320
the one using a search assumption and we

420
00:16:58,320 --> 00:17:01,519
can turn that into deletable and uh for

421
00:17:01,519 --> 00:17:03,600
the lattice side we can turn both of

422
00:17:03,600 --> 00:17:06,160
these two constructions into a deletable

423
00:17:06,160 --> 00:17:08,720
a b scheme even though some of you might

424
00:17:08,720 --> 00:17:10,640
know that there was recently attack on

425
00:17:10,640 --> 00:17:12,480
the buoyant searching scheme but the

426
00:17:12,480 --> 00:17:14,720
attack came out after our first draft

427
00:17:14,720 --> 00:17:17,280
and we still leave the example in our

428
00:17:17,280 --> 00:17:19,599
paper as just for illustrative purpose

429
00:17:19,599 --> 00:17:22,240
on how deletable abe works

430
00:17:22,240 --> 00:17:24,480
and finally uh there's also concurrent

431
00:17:24,480 --> 00:17:26,880
work by kasumata nishimaki amada

432
00:17:26,880 --> 00:17:30,080
yamakawa that extend the functionality

433
00:17:30,080 --> 00:17:33,120
of subreddit scheming to inner product

434
00:17:33,120 --> 00:17:35,919
and that's everything for this talk uh

435
00:17:35,919 --> 00:17:38,240
thank you

436
00:17:38,240 --> 00:17:39,840
thank you

437
00:17:39,840 --> 00:17:43,440
so any question or comment

438
00:17:43,440 --> 00:17:45,440
oh

439
00:17:45,440 --> 00:17:49,039
i cannot find any comment or

440
00:17:49,039 --> 00:17:50,400
question on

441
00:17:50,400 --> 00:17:52,480
zurip or

442
00:17:52,480 --> 00:17:55,280
the chat

443
00:17:55,440 --> 00:17:56,160
so

444
00:17:56,160 --> 00:18:00,880
uh i i have one naive question so com

445
00:18:04,080 --> 00:18:04,880
work

446
00:18:04,880 --> 00:18:08,640
uh your work uh what is a main advantage

447
00:18:08,640 --> 00:18:11,120
of your work with compared with their

448
00:18:11,120 --> 00:18:12,400
work

449
00:18:12,400 --> 00:18:15,919
yeah we expand the the the framework of

450
00:18:15,919 --> 00:18:16,799
uh

451
00:18:16,799 --> 00:18:19,120
uh of the submarine scheme so in summary

452
00:18:19,120 --> 00:18:21,120
scheme it's a it's using this uh very

453
00:18:21,120 --> 00:18:23,520
specific properties of it uh like

454
00:18:23,520 --> 00:18:25,280
overalls using this uh it is

455
00:18:25,280 --> 00:18:28,080
specifically over working with the bgg

456
00:18:28,080 --> 00:18:30,720
plus 14 lattice-based construction but

457
00:18:30,720 --> 00:18:32,880
in fact it can we can abstract the

458
00:18:32,880 --> 00:18:35,440
properties out and it is actually a more

459
00:18:35,440 --> 00:18:38,960
generalized framework with like certain

460
00:18:38,960 --> 00:18:42,000
abe and uh and certain and certain

461
00:18:42,000 --> 00:18:44,240
constraint prf and uh

462
00:18:44,240 --> 00:18:46,320
and for that kind of abu we can actually

463
00:18:46,320 --> 00:18:48,480
fit we can actually fit some other

464
00:18:48,480 --> 00:18:50,960
existing ab schemes uh into the

465
00:18:50,960 --> 00:18:52,240
framework

466
00:18:52,240 --> 00:18:55,760
and uh and i think for the the the

467
00:18:55,760 --> 00:18:58,160
customer at all work and they

468
00:18:58,160 --> 00:19:00,720
uh they yeah they they do expand the

469
00:19:00,720 --> 00:19:03,039
functionality and but they they follow

470
00:19:03,039 --> 00:19:05,200
they sort of follow this very specific

471
00:19:05,200 --> 00:19:08,160
uh lattice-based construction uh

472
00:19:08,160 --> 00:19:10,240
as in the suburbs scheme so yeah it's

473
00:19:10,240 --> 00:19:13,440
not uh a very abstract uh it's like a

474
00:19:13,440 --> 00:19:15,679
more like non-black box use

475
00:19:15,679 --> 00:19:18,550
uh extension of the work right

476
00:19:18,550 --> 00:19:21,669
[Music]

477
00:19:22,080 --> 00:19:26,080
yeah i see i see so one uh advantage is

478
00:19:26,080 --> 00:19:28,640
uh uh security from uh

479
00:19:28,640 --> 00:19:31,600
uh computational program uh okay thank

480
00:19:31,600 --> 00:19:34,480
you yeah yes uh yes so we we can have

481
00:19:34,480 --> 00:19:35,440
fun

482
00:19:35,440 --> 00:19:36,880
yeah we can have security from

483
00:19:36,880 --> 00:19:39,919
computational uh group assumptions and

484
00:19:39,919 --> 00:19:41,760
uh right

485
00:19:41,760 --> 00:19:45,200
okay so any other question or comment so

486
00:19:45,200 --> 00:19:49,280
no comment thank you very much

487
00:19:49,520 --> 00:19:53,120
and okay thank you okay

488
00:19:53,120 --> 00:19:55,760
next talk

489
00:19:56,080 --> 00:19:58,320
uh

490
00:20:00,960 --> 00:20:02,240
next

491
00:20:02,240 --> 00:20:06,880
uh talk uh the title is bounded

492
00:20:06,880 --> 00:20:09,600
collision abe for uh

493
00:20:09,600 --> 00:20:12,159
turing machines from ibe

494
00:20:12,159 --> 00:20:15,039
uh zeo says uh richard

495
00:20:15,039 --> 00:20:16,000
well

496
00:20:16,000 --> 00:20:19,919
little ones side and brentwood so this

497
00:20:19,919 --> 00:20:23,520
shop will give a talk go ahead

498
00:20:23,520 --> 00:20:25,280
thanks a lot for the introduction and

499
00:20:25,280 --> 00:20:27,039
yeah today i'll tell you how to build

500
00:20:27,039 --> 00:20:29,039
attribute based encryption for the

501
00:20:29,039 --> 00:20:32,080
uniform model of tuning machines

502
00:20:32,080 --> 00:20:32,960
from

503
00:20:32,960 --> 00:20:34,320
general assumption of identity based

504
00:20:34,320 --> 00:20:37,280
encryption in the bound collision model

505
00:20:37,280 --> 00:20:38,960
so just let me quickly recap

506
00:20:38,960 --> 00:20:40,640
attribute-based encryption so java did a

507
00:20:40,640 --> 00:20:42,080
great job of telling you about attribute

508
00:20:42,080 --> 00:20:43,520
based description but i'm going to be

509
00:20:43,520 --> 00:20:44,799
switching things around a little bit so

510
00:20:44,799 --> 00:20:46,720
let me just redo it again

511
00:20:46,720 --> 00:20:48,400
so attribute-based encryption is a

512
00:20:48,400 --> 00:20:49,760
fine-grained notion of encryption which

513
00:20:49,760 --> 00:20:51,200
allows finding an access of

514
00:20:51,200 --> 00:20:52,720
over-encrypted data

515
00:20:52,720 --> 00:20:54,480
so it can be pictorially instead using

516
00:20:54,480 --> 00:20:55,919
the following picture where we have two

517
00:20:55,919 --> 00:20:58,320
parties alice and bob where alice has

518
00:20:58,320 --> 00:21:00,240
some private data m and it wants to

519
00:21:00,240 --> 00:21:02,880
share this private data m corresponding

520
00:21:02,880 --> 00:21:04,799
to the people who satisfy certain

521
00:21:04,799 --> 00:21:06,159
attributes

522
00:21:06,159 --> 00:21:08,080
so bob has a secret key alice has a

523
00:21:08,080 --> 00:21:09,840
public key and alice basically encrypts

524
00:21:09,840 --> 00:21:12,720
her message under these attributes

525
00:21:12,720 --> 00:21:14,559
now suppose we have a third party

526
00:21:14,559 --> 00:21:16,400
charlie and charlie here it wants to

527
00:21:16,400 --> 00:21:18,880
recover the message m as long as the

528
00:21:18,880 --> 00:21:21,520
policy that charlie has it satisfies the

529
00:21:21,520 --> 00:21:23,200
set of attributes the attributes could

530
00:21:23,200 --> 00:21:26,640
be i am say age people over age 25 can

531
00:21:26,640 --> 00:21:28,880
be here the speakers have text

532
00:21:28,880 --> 00:21:31,520
so that's one example and uh one way to

533
00:21:31,520 --> 00:21:34,080
solve this problem in order to enable uh

534
00:21:34,080 --> 00:21:36,000
charlie from decrypting this particular

535
00:21:36,000 --> 00:21:38,000
site text charlie can simply send the

536
00:21:38,000 --> 00:21:40,159
soft text over to bob and bob can

537
00:21:40,159 --> 00:21:41,520
decrypt the search text authorize

538
00:21:41,520 --> 00:21:42,880
whether check whether a child is

539
00:21:42,880 --> 00:21:44,720
authorized or not and send it back

540
00:21:44,720 --> 00:21:46,159
but this is not very efficient because

541
00:21:46,159 --> 00:21:48,159
you have to perform interaction

542
00:21:48,159 --> 00:21:49,440
attribute based encryption allows a

543
00:21:49,440 --> 00:21:50,720
non-interactive and a very efficient way

544
00:21:50,720 --> 00:21:52,640
of solving this problem in which you can

545
00:21:52,640 --> 00:21:54,320
come up with some partial secret keys

546
00:21:54,320 --> 00:21:56,000
called predicate secret keys for the

547
00:21:56,000 --> 00:21:58,000
function app such that given this

548
00:21:58,000 --> 00:21:59,520
predicate secret key you can perform

549
00:21:59,520 --> 00:22:01,039
decryption on its own

550
00:22:01,039 --> 00:22:02,480
so the advantages of attribute

551
00:22:02,480 --> 00:22:04,240
description is that it allows this

552
00:22:04,240 --> 00:22:06,159
finding access over encrypted data you

553
00:22:06,159 --> 00:22:07,360
can choose when to release encrypted

554
00:22:07,360 --> 00:22:09,360
data and it solves this problem without

555
00:22:09,360 --> 00:22:11,280
outsourcing and even when bob is offline

556
00:22:11,280 --> 00:22:14,000
charlie can perform this decryption

557
00:22:14,000 --> 00:22:16,240
so a little more abstractly as uh you

558
00:22:16,240 --> 00:22:17,520
already saw the previous talk we have a

559
00:22:17,520 --> 00:22:19,200
setup algorithm and generates the master

560
00:22:19,200 --> 00:22:21,520
set republican secret keys using the

561
00:22:21,520 --> 00:22:23,520
master public you can encrypt any

562
00:22:23,520 --> 00:22:25,520
message for the attribute string of your

563
00:22:25,520 --> 00:22:27,440
choice recall i'm switching the

564
00:22:27,440 --> 00:22:28,960
attributes and policies in the previous

565
00:22:28,960 --> 00:22:31,120
talk you saw policies being interpreted

566
00:22:31,120 --> 00:22:33,280
in the soft text here i'm going to talk

567
00:22:33,280 --> 00:22:34,799
about attributes being incremented under

568
00:22:34,799 --> 00:22:37,360
cytric so it's like a dual version of

569
00:22:37,360 --> 00:22:40,320
which is called these uh the key policy

570
00:22:40,320 --> 00:22:42,480
uh version of attribute based encryption

571
00:22:42,480 --> 00:22:44,159
so that means in the key generation

572
00:22:44,159 --> 00:22:45,919
algorithm we take it and put a policy

573
00:22:45,919 --> 00:22:48,000
and gets a secret key and finally we can

574
00:22:48,000 --> 00:22:49,520
combine the side effects and secret key

575
00:22:49,520 --> 00:22:51,200
to recover the message depending upon

576
00:22:51,200 --> 00:22:52,799
whether the policy was satisfied or not

577
00:22:52,799 --> 00:22:54,400
on that given attribute

578
00:22:54,400 --> 00:22:56,559
present inside that cipher text

579
00:22:56,559 --> 00:22:58,480
and for security as you saw typically

580
00:22:58,480 --> 00:23:00,080
the intuition is that the adversary

581
00:23:00,080 --> 00:23:01,360
should not be able to learn anything

582
00:23:01,360 --> 00:23:02,880
beyond that it can learn by performing

583
00:23:02,880 --> 00:23:04,880
decryption so suppose adversary is given

584
00:23:04,880 --> 00:23:07,039
aside text and a bunch of many secret

585
00:23:07,039 --> 00:23:09,600
keys as long as none of the suited keys

586
00:23:09,600 --> 00:23:11,120
none of the policies associated with

587
00:23:11,120 --> 00:23:13,520
secret key can satisfy the underlying

588
00:23:13,520 --> 00:23:16,000
attributes the message should be hidden

589
00:23:16,000 --> 00:23:17,440
if you can satisfy the attribute then

590
00:23:17,440 --> 00:23:18,559
you can run the decryption algorithm and

591
00:23:18,559 --> 00:23:20,159
learn the message otherwise it should be

592
00:23:20,159 --> 00:23:22,799
completely hidden and what's more

593
00:23:22,799 --> 00:23:24,400
interesting about attribute description

594
00:23:24,400 --> 00:23:26,080
is that attributes encryption really

595
00:23:26,080 --> 00:23:28,240
depends upon the class of policies that

596
00:23:28,240 --> 00:23:30,240
you can build it for if the class of

597
00:23:30,240 --> 00:23:32,320
policy is just empty then it's basically

598
00:23:32,320 --> 00:23:34,080
the public encryption but depending upon

599
00:23:34,080 --> 00:23:36,159
how expensive the class is you get more

600
00:23:36,159 --> 00:23:38,159
interesting applications typically the

601
00:23:38,159 --> 00:23:39,520
models of computation that has been

602
00:23:39,520 --> 00:23:41,360
discussed or have been done so far for

603
00:23:41,360 --> 00:23:43,279
attribute description can be split into

604
00:23:43,279 --> 00:23:45,039
two categories the non-uniform and the

605
00:23:45,039 --> 00:23:47,120
uniform classes with the non-uniform

606
00:23:47,120 --> 00:23:48,480
classes we have boolean formulas and

607
00:23:48,480 --> 00:23:50,480
circuits but the problem with that is

608
00:23:50,480 --> 00:23:53,679
that the attributes that you can encrypt

609
00:23:53,679 --> 00:23:55,440
have to be of fixed size you have to

610
00:23:55,440 --> 00:23:56,960
declare that this is the length of my

611
00:23:56,960 --> 00:23:58,400
attributes whereas in the uniform

612
00:23:58,400 --> 00:24:00,080
classes such as deterministic finite

613
00:24:00,080 --> 00:24:02,320
automata turing machines ramp programs

614
00:24:02,320 --> 00:24:05,360
etc you can handle potentially unbounded

615
00:24:05,360 --> 00:24:06,720
length attributes

616
00:24:06,720 --> 00:24:08,320
so basically the main difference is that

617
00:24:08,320 --> 00:24:10,159
in the non-uniform setting you have a

618
00:24:10,159 --> 00:24:12,080
separate key for different length

619
00:24:12,080 --> 00:24:13,919
attributes whereas in the uniform

620
00:24:13,919 --> 00:24:16,240
classes you have one single key

621
00:24:16,240 --> 00:24:18,000
that can decrypt potentially factors

622
00:24:18,000 --> 00:24:19,760
that encrypt different varying length

623
00:24:19,760 --> 00:24:21,200
attributes

624
00:24:21,200 --> 00:24:24,000
so in practice uniform uh model of

625
00:24:24,000 --> 00:24:26,799
computation is much more useful for uh

626
00:24:26,799 --> 00:24:29,279
attribute-based encryption

627
00:24:29,279 --> 00:24:32,000
and uh so far we've seen that there has

628
00:24:32,000 --> 00:24:33,840
been tremendous amount of progress in

629
00:24:33,840 --> 00:24:35,679
trying to build attribute description

630
00:24:35,679 --> 00:24:36,960
from a wide variety of assumptions such

631
00:24:36,960 --> 00:24:38,960
as pilot maps learning with others

632
00:24:38,960 --> 00:24:40,960
multimedia maps and much more

633
00:24:40,960 --> 00:24:43,520
and one commonality for all these

634
00:24:43,520 --> 00:24:45,360
positive results is that they require

635
00:24:45,360 --> 00:24:47,760
specific algebraic assumptions to enable

636
00:24:47,760 --> 00:24:49,679
attribute-based encryption

637
00:24:49,679 --> 00:24:51,120
and even further

638
00:24:51,120 --> 00:24:52,880
there seems to be a gap between the

639
00:24:52,880 --> 00:24:54,559
feasibilities that we have for the

640
00:24:54,559 --> 00:24:56,320
non-uniform models as well as the

641
00:24:56,320 --> 00:24:58,320
uniform models typically from the

642
00:24:58,320 --> 00:25:00,640
non-uniform models it's easier to use

643
00:25:00,640 --> 00:25:02,320
algebraic assumptions to get feasible

644
00:25:02,320 --> 00:25:04,559
results but for uniform models we still

645
00:25:04,559 --> 00:25:06,320
don't know a lot for example we don't

646
00:25:06,320 --> 00:25:08,080
know how to get collision resistant

647
00:25:08,080 --> 00:25:10,000
attribute-based encryption for securing

648
00:25:10,000 --> 00:25:12,840
machines in the uh from a standard

649
00:25:12,840 --> 00:25:15,440
assumption uh if you don't want to go

650
00:25:15,440 --> 00:25:17,440
via the route of obfuscation for which

651
00:25:17,440 --> 00:25:18,880
we have construction from well-founded

652
00:25:18,880 --> 00:25:20,080
assumptions

653
00:25:20,080 --> 00:25:21,600
but going forward

654
00:25:21,600 --> 00:25:23,760
the question that we ask in this work or

655
00:25:23,760 --> 00:25:25,840
the under consideration is that is there

656
00:25:25,840 --> 00:25:27,600
always a gap between uniform and

657
00:25:27,600 --> 00:25:30,159
non-uniform models or can we actually

658
00:25:30,159 --> 00:25:31,919
get the same feasibilities for the

659
00:25:31,919 --> 00:25:34,000
uniform models as well and in general

660
00:25:34,000 --> 00:25:36,080
can we also rely on general assumptions

661
00:25:36,080 --> 00:25:38,000
non-algebra exempt are not algebraic

662
00:25:38,000 --> 00:25:39,279
assumptions to perform this

663
00:25:39,279 --> 00:25:41,440
instantiation

664
00:25:41,440 --> 00:25:43,279
and in this work we show exactly the

665
00:25:43,279 --> 00:25:45,279
following we showed we built an ab

666
00:25:45,279 --> 00:25:46,799
scheme for curing machines which is a

667
00:25:46,799 --> 00:25:48,880
uniform class from identity based

668
00:25:48,880 --> 00:25:50,720
encryption which is a general assumption

669
00:25:50,720 --> 00:25:52,960
in the bound inclusion model

670
00:25:52,960 --> 00:25:54,559
and the two theorems we show in this

671
00:25:54,559 --> 00:25:56,400
work is that starting with ib you can

672
00:25:56,400 --> 00:25:58,240
build a non-adaptively secure a b scheme

673
00:25:58,240 --> 00:26:00,159
with two collisions and you can also

674
00:26:00,159 --> 00:26:01,919
upgrade this security to adaptive

675
00:26:01,919 --> 00:26:04,240
security if you start from if you work

676
00:26:04,240 --> 00:26:06,880
in the random oracle model

677
00:26:06,880 --> 00:26:09,360
and one caveat of our results

678
00:26:09,360 --> 00:26:10,960
is that although the encryption

679
00:26:10,960 --> 00:26:12,720
algorithm can take us and put unbounded

680
00:26:12,720 --> 00:26:14,320
length attributes

681
00:26:14,320 --> 00:26:16,799
the runtime of the turing machine that

682
00:26:16,799 --> 00:26:18,640
can be run on those attributes has to be

683
00:26:18,640 --> 00:26:20,240
declared during encryption time so the

684
00:26:20,240 --> 00:26:22,159
attribute length is unbounded with the

685
00:26:22,159 --> 00:26:23,760
turing machines which you can run on

686
00:26:23,760 --> 00:26:25,120
that particular attribute that has to be

687
00:26:25,120 --> 00:26:27,200
a pretty mounted

688
00:26:27,200 --> 00:26:29,600
and as a consequence we also saw we also

689
00:26:29,600 --> 00:26:32,080
were able to uh propose a fine-grained

690
00:26:32,080 --> 00:26:33,600
simulation security for something called

691
00:26:33,600 --> 00:26:35,520
gobble grams as it was an important

692
00:26:35,520 --> 00:26:38,400
ingredient construction

693
00:26:38,400 --> 00:26:40,640
now just trying to explain our result a

694
00:26:40,640 --> 00:26:42,559
little bit better let me explain what

695
00:26:42,559 --> 00:26:44,000
the boundary collision model is let me

696
00:26:44,000 --> 00:26:45,679
just recall it so this was the security

697
00:26:45,679 --> 00:26:47,360
definition that we saw before the

698
00:26:47,360 --> 00:26:49,200
bounded collision model says that the

699
00:26:49,200 --> 00:26:52,000
security holes as long as the number of

700
00:26:52,000 --> 00:26:54,080
corruptions of keys that the adversary

701
00:26:54,080 --> 00:26:56,559
can do is bounded is at most some a

702
00:26:56,559 --> 00:26:59,600
primary para decided parameter q

703
00:26:59,600 --> 00:27:01,120
and as long as you don't corrupt more

704
00:27:01,120 --> 00:27:03,600
than two keys the security still holds

705
00:27:03,600 --> 00:27:05,840
and we although this is weaker

706
00:27:05,840 --> 00:27:07,440
than fully collusionist

707
00:27:07,440 --> 00:27:09,679
model it is very interesting and has

708
00:27:09,679 --> 00:27:11,919
seen many interesting applications and

709
00:27:11,919 --> 00:27:13,679
it turns out in the landscape in the

710
00:27:13,679 --> 00:27:15,279
bound collision model is already very

711
00:27:15,279 --> 00:27:17,440
interesting for the non-uniform models

712
00:27:17,440 --> 00:27:20,159
we already know that a b for circuits

713
00:27:20,159 --> 00:27:21,360
can be built just from public

714
00:27:21,360 --> 00:27:23,200
integration the minimal assumption

715
00:27:23,200 --> 00:27:25,440
but it turns out all prior constructions

716
00:27:25,440 --> 00:27:26,559
for a b

717
00:27:26,559 --> 00:27:28,240
for any uniform models even in the

718
00:27:28,240 --> 00:27:29,760
bounded collision setting they need

719
00:27:29,760 --> 00:27:31,760
specific algebraic assumptions so

720
00:27:31,760 --> 00:27:33,520
there's huge gap for

721
00:27:33,520 --> 00:27:34,960
your non-uniform model it's just public

722
00:27:34,960 --> 00:27:36,399
encryption is enough but for uniform

723
00:27:36,399 --> 00:27:38,480
models it's not clear and in this work

724
00:27:38,480 --> 00:27:40,159
we precisely show that algebra is not

725
00:27:40,159 --> 00:27:41,600
needed for uniform models and you can

726
00:27:41,600 --> 00:27:43,440
start from general assumptions if you're

727
00:27:43,440 --> 00:27:45,919
working in the bound collision model

728
00:27:45,919 --> 00:27:47,840
so at a very high level our construction

729
00:27:47,840 --> 00:27:49,679
for attribute-based description proceeds

730
00:27:49,679 --> 00:27:51,760
in three steps in the first step we

731
00:27:51,760 --> 00:27:53,760
design a attribute-based encryption

732
00:27:53,760 --> 00:27:56,080
scheme for tv machines in which we only

733
00:27:56,080 --> 00:27:59,678
corrupt allow one single key

734
00:28:00,320 --> 00:28:01,760
the second step we show how to go from

735
00:28:01,760 --> 00:28:04,159
single corruption to boundary corruption

736
00:28:04,159 --> 00:28:05,840
and then we show how to upgrade

737
00:28:05,840 --> 00:28:07,120
non-adaptive security to adaptive

738
00:28:07,120 --> 00:28:09,039
security in the random oracle model so

739
00:28:09,039 --> 00:28:10,640
combining all these things we get both

740
00:28:10,640 --> 00:28:12,080
of the results

741
00:28:12,080 --> 00:28:13,600
and during the lack of time i won't tell

742
00:28:13,600 --> 00:28:15,120
you exactly how to do it but let me just

743
00:28:15,120 --> 00:28:17,120
quickly summarize so the step two

744
00:28:17,120 --> 00:28:19,360
follows by standard combinatorial tricks

745
00:28:19,360 --> 00:28:21,760
for amplifying completion bound but as

746
00:28:21,760 --> 00:28:23,840
in the third step we rely on a very

747
00:28:23,840 --> 00:28:26,159
simple non-committing encryption uh

748
00:28:26,159 --> 00:28:27,679
scheme that be instantiated in the

749
00:28:27,679 --> 00:28:29,760
random oracle model and show that this

750
00:28:29,760 --> 00:28:32,159
particular non-interactive

751
00:28:32,159 --> 00:28:33,600
communicate non-committing encryption

752
00:28:33,600 --> 00:28:36,159
scheme can be used to upgrade security

753
00:28:36,159 --> 00:28:37,840
now the step one is where a lot of

754
00:28:37,840 --> 00:28:40,640
technical ideas came in and

755
00:28:40,640 --> 00:28:42,159
in the interest of time let me just

756
00:28:42,159 --> 00:28:44,399
summarize them very briefly so the

757
00:28:44,399 --> 00:28:46,640
intuition is as follows to build an a b

758
00:28:46,640 --> 00:28:49,039
scheme with one single key corruption

759
00:28:49,039 --> 00:28:51,360
we work as follows the scifix is going

760
00:28:51,360 --> 00:28:53,600
to contain t garblings where the t is a

761
00:28:53,600 --> 00:28:54,799
time bound of the clearing machine that

762
00:28:54,799 --> 00:28:56,840
can be run on this particular soft

763
00:28:56,840 --> 00:29:00,080
text each garbling is going to perform a

764
00:29:00,080 --> 00:29:01,600
computation step of the curing machine

765
00:29:01,600 --> 00:29:03,200
so the ith cobbling is going to perform

766
00:29:03,200 --> 00:29:05,120
the ith tubing machine step

767
00:29:05,120 --> 00:29:07,120
and it's basically going to output the

768
00:29:07,120 --> 00:29:09,440
labels for the the i plus one at the

769
00:29:09,440 --> 00:29:10,799
goblin

770
00:29:10,799 --> 00:29:13,200
and the labels are actually encrypted

771
00:29:13,200 --> 00:29:15,039
under certain identities which

772
00:29:15,039 --> 00:29:16,320
correspond to the tuning machine

773
00:29:16,320 --> 00:29:18,080
transitions when you go from the ith

774
00:29:18,080 --> 00:29:20,000
step to the i plus one extent

775
00:29:20,000 --> 00:29:21,520
and secret key

776
00:29:21,520 --> 00:29:23,039
for a particular turing machine is going

777
00:29:23,039 --> 00:29:25,279
to be the identity keys for the ib

778
00:29:25,279 --> 00:29:27,679
system for the appropriate turing

779
00:29:27,679 --> 00:29:29,200
machines tuning machine state

780
00:29:29,200 --> 00:29:31,520
transitions basically giving decryption

781
00:29:31,520 --> 00:29:34,000
i will run uh the first problem that's

782
00:29:34,000 --> 00:29:36,559
going to give me an encryption of the

783
00:29:36,559 --> 00:29:38,720
wired labels for the next coupling

784
00:29:38,720 --> 00:29:39,760
and those

785
00:29:39,760 --> 00:29:41,360
encryptions can be recovered depending

786
00:29:41,360 --> 00:29:44,000
upon my state transitions

787
00:29:44,000 --> 00:29:45,440
that's the high level id and i invite

788
00:29:45,440 --> 00:29:47,120
you to look at the full version of the

789
00:29:47,120 --> 00:29:49,360
paper or just the full paper to see how

790
00:29:49,360 --> 00:29:51,039
we execute this

791
00:29:51,039 --> 00:29:52,480
we're just throwing in a little more of

792
00:29:52,480 --> 00:29:54,880
details what type of goblins do we need

793
00:29:54,880 --> 00:29:56,559
so it turns out garbled circuits could

794
00:29:56,559 --> 00:29:58,159
be enough could be sufficient but they

795
00:29:58,159 --> 00:29:59,840
lead to quadratic blow up in the cyclic

796
00:29:59,840 --> 00:30:01,120
size if you just

797
00:30:01,120 --> 00:30:02,640
use them naively

798
00:30:02,640 --> 00:30:04,799
and we show that using carbon ramps we

799
00:30:04,799 --> 00:30:06,799
can make it linear much more efficient

800
00:30:06,799 --> 00:30:08,720
and the point is that in gable ramps we

801
00:30:08,720 --> 00:30:10,960
have a persistent memory database and we

802
00:30:10,960 --> 00:30:13,039
have different ram programs so that's

803
00:30:13,039 --> 00:30:15,600
why we can take out this ram this memory

804
00:30:15,600 --> 00:30:18,080
to encode the database to the to sort of

805
00:30:18,080 --> 00:30:20,240
encode the turing machine state

806
00:30:20,240 --> 00:30:22,159
in kabul circuit you have to pass the

807
00:30:22,159 --> 00:30:24,080
the steering machine state uh

808
00:30:24,080 --> 00:30:26,000
during each ram program which we try to

809
00:30:26,000 --> 00:30:26,960
avoid

810
00:30:26,960 --> 00:30:29,039
and in this paper we propose a new

811
00:30:29,039 --> 00:30:30,559
security definition for garbled ramps

812
00:30:30,559 --> 00:30:32,240
which we call iterative simulation

813
00:30:32,240 --> 00:30:34,799
security and basically the point is that

814
00:30:34,799 --> 00:30:36,960
in the standard notion of security all

815
00:30:36,960 --> 00:30:39,440
ram programs for the given database have

816
00:30:39,440 --> 00:30:41,120
to be simulated together at the same

817
00:30:41,120 --> 00:30:42,240
time

818
00:30:42,240 --> 00:30:43,520
but in this work we show that the

819
00:30:43,520 --> 00:30:45,919
simulation still works if you simulate

820
00:30:45,919 --> 00:30:48,080
the programs some of the programs and

821
00:30:48,080 --> 00:30:49,440
compute the rest of the programs

822
00:30:49,440 --> 00:30:50,399
honestly

823
00:30:50,399 --> 00:30:51,919
then still we can get interesting

824
00:30:51,919 --> 00:30:53,919
simulation security properties and this

825
00:30:53,919 --> 00:30:56,000
is very crucial for our proof since we

826
00:30:56,000 --> 00:30:58,799
have to simulate things step by step and

827
00:30:58,799 --> 00:31:00,880
we can't simulate things all at once

828
00:31:00,880 --> 00:31:03,440
because we work in this unbounded model

829
00:31:03,440 --> 00:31:05,919
unbounded attribute model

830
00:31:05,919 --> 00:31:07,679
and yeah please look at the paper for

831
00:31:07,679 --> 00:31:09,760
details i'm trying to conclude in this

832
00:31:09,760 --> 00:31:11,600
work we provide the bounded collusion

833
00:31:11,600 --> 00:31:13,200
attribute-based encryption scheme for

834
00:31:13,200 --> 00:31:15,120
turing machines from ibe

835
00:31:15,120 --> 00:31:16,799
and he proves provide security in the

836
00:31:16,799 --> 00:31:18,720
adaptive and non-adaptive setting in the

837
00:31:18,720 --> 00:31:20,960
random oracle understanding assumptions

838
00:31:20,960 --> 00:31:23,679
and uh this is the first uniform model

839
00:31:23,679 --> 00:31:25,279
attribute description scheme in the

840
00:31:25,279 --> 00:31:27,360
bounded collision setting from general

841
00:31:27,360 --> 00:31:28,720
assumptions which does not rely on

842
00:31:28,720 --> 00:31:30,080
algebra

843
00:31:30,080 --> 00:31:32,480
showing that the gap between non-uniform

844
00:31:32,480 --> 00:31:35,519
and uniform is actually uh

845
00:31:35,519 --> 00:31:37,360
is not that big at least in the boundary

846
00:31:37,360 --> 00:31:39,200
collision water and we also provide a

847
00:31:39,200 --> 00:31:40,399
new fine information security for

848
00:31:40,399 --> 00:31:42,080
garbage ramps which we show can be

849
00:31:42,080 --> 00:31:44,880
instantiated from prior works by a new

850
00:31:44,880 --> 00:31:46,399
security proof

851
00:31:46,399 --> 00:31:48,399
and just trying to conclude with some

852
00:31:48,399 --> 00:31:49,760
interesting directions for the future

853
00:31:49,760 --> 00:31:51,760
work a very natural question could be

854
00:31:51,760 --> 00:31:53,519
can you actually do the same for

855
00:31:53,519 --> 00:31:54,960
functional encryption can we get

856
00:31:54,960 --> 00:31:56,159
function encryption procuring machines

857
00:31:56,159 --> 00:31:58,080
in the boundary collision model

858
00:31:58,080 --> 00:31:59,840
or can you also remove this time bound

859
00:31:59,840 --> 00:32:01,919
that we had in the encryption algorithm

860
00:32:01,919 --> 00:32:03,519
and can we go beyond can you improve

861
00:32:03,519 --> 00:32:05,440
adaptive security without relying on

862
00:32:05,440 --> 00:32:07,279
random oracle modules

863
00:32:07,279 --> 00:32:08,880
and recently there has been some other

864
00:32:08,880 --> 00:32:10,080
bounded collision models which are

865
00:32:10,080 --> 00:32:12,000
called the dynamic collision model model

866
00:32:12,000 --> 00:32:14,399
and we actually extend our results for

867
00:32:14,399 --> 00:32:16,159
eb for tuning machines in those dynamic

868
00:32:16,159 --> 00:32:17,360
model as well

869
00:32:17,360 --> 00:32:18,720
with that i would like to conclude and

870
00:32:18,720 --> 00:32:20,159
thanks for listening and i'd be happy to

871
00:32:20,159 --> 00:32:21,919
answer any questions

872
00:32:21,919 --> 00:32:26,000
okay thank you very nice talk

873
00:32:26,000 --> 00:32:28,880
so any question or comment

874
00:32:28,880 --> 00:32:29,919
oh

875
00:32:29,919 --> 00:32:32,799
i cannot find

876
00:32:35,440 --> 00:32:39,200
so i i have one naive question so you

877
00:32:39,200 --> 00:32:43,519
you say at the end of your talk uh the

878
00:32:43,519 --> 00:32:45,120
challenge is

879
00:32:45,120 --> 00:32:46,080
to

880
00:32:46,080 --> 00:32:48,880
leverage to adaptive security without

881
00:32:48,880 --> 00:32:50,720
london molecular model and

882
00:32:50,720 --> 00:32:51,600
uh

883
00:32:51,600 --> 00:32:54,840
i think uh in the

884
00:32:54,840 --> 00:32:57,840
uniform uh computational model turing

885
00:32:57,840 --> 00:32:58,880
machine

886
00:32:58,880 --> 00:33:01,919
so maybe uh uh selective

887
00:33:01,919 --> 00:33:04,320
uh the gap of selective security and

888
00:33:04,320 --> 00:33:06,240
adaptive security is

889
00:33:06,240 --> 00:33:07,039
more

890
00:33:07,039 --> 00:33:10,880
large and because uh that in the key

891
00:33:10,880 --> 00:33:12,240
policy type

892
00:33:12,240 --> 00:33:14,000
uh

893
00:33:14,000 --> 00:33:15,120
abe

894
00:33:15,120 --> 00:33:16,000
so

895
00:33:16,000 --> 00:33:16,799
so

896
00:33:16,799 --> 00:33:19,200
the main advantage is

897
00:33:19,200 --> 00:33:22,960
any language uh any language attributes

898
00:33:22,960 --> 00:33:25,919
can be handled but if uh selective

899
00:33:25,919 --> 00:33:28,080
security we consider selective security

900
00:33:28,080 --> 00:33:30,880
so the first as the first of the game we

901
00:33:30,880 --> 00:33:33,279
should uh declare the challenge

902
00:33:33,279 --> 00:33:34,960
attribute so the

903
00:33:34,960 --> 00:33:37,760
maybe the hardware is very

904
00:33:37,760 --> 00:33:41,120
get low compared to the non-uniform

905
00:33:41,120 --> 00:33:42,320
model

906
00:33:42,320 --> 00:33:43,760
so uh

907
00:33:43,760 --> 00:33:47,279
maybe the hardware is large gap is raj

908
00:33:47,279 --> 00:33:48,799
is it right

909
00:33:48,799 --> 00:33:50,720
so that's a great question that's your

910
00:33:50,720 --> 00:33:53,919
key but uh it's possible but i don't

911
00:33:53,919 --> 00:33:55,360
think that might be the case the reason

912
00:33:55,360 --> 00:33:57,200
is follow is the following reason is

913
00:33:57,200 --> 00:33:59,360
that even right now we proved something

914
00:33:59,360 --> 00:34:01,120
stronger than selective security we

915
00:34:01,120 --> 00:34:02,640
proved non-adaptive security in

916
00:34:02,640 --> 00:34:04,399
non-adaptive security

917
00:34:04,399 --> 00:34:06,640
the uh the only restriction is that they

918
00:34:06,640 --> 00:34:09,520
should not be any post challenge

919
00:34:09,520 --> 00:34:11,199
secret key queries

920
00:34:11,199 --> 00:34:11,918
so

921
00:34:11,918 --> 00:34:14,159
you do not have to declare the challenge

922
00:34:14,159 --> 00:34:16,320
attribute at the beginning of the game

923
00:34:16,320 --> 00:34:18,639
all you have to do is that the secret

924
00:34:18,639 --> 00:34:21,520
key queries must be made before uh

925
00:34:21,520 --> 00:34:24,719
seeing the challenge uh uh ciphertext

926
00:34:24,719 --> 00:34:26,399
so you actually don't need any

927
00:34:26,399 --> 00:34:27,839
information about the challenge text the

928
00:34:27,839 --> 00:34:29,679
property is that we have to hardwire

929
00:34:29,679 --> 00:34:31,520
certain computation inside the challenge

930
00:34:31,520 --> 00:34:33,119
side of text and that's why we need to

931
00:34:33,119 --> 00:34:35,040
make those queries before

932
00:34:35,040 --> 00:34:35,839
so

933
00:34:35,839 --> 00:34:38,719
i think uh this is uh i haven't spent

934
00:34:38,719 --> 00:34:41,040
too much time on it but i suspect that

935
00:34:41,040 --> 00:34:44,000
we should be able to use checks from the

936
00:34:44,000 --> 00:34:46,399
adaptive security of goblin uh gobble

937
00:34:46,399 --> 00:34:48,560
circuits uh literature where we use

938
00:34:48,560 --> 00:34:50,480
these uh pebbling techniques to prove

939
00:34:50,480 --> 00:34:52,399
adaptive security and i think those

940
00:34:52,399 --> 00:34:53,839
techniques have already been used to

941
00:34:53,839 --> 00:34:56,000
prove adaptive security for abe in the

942
00:34:56,000 --> 00:34:58,400
binary literature and i think those

943
00:34:58,400 --> 00:35:00,560
ideas can also be used to prove adaptive

944
00:35:00,560 --> 00:35:02,560
security by a more fine-grained analysis

945
00:35:02,560 --> 00:35:04,079
of our construction because we right now

946
00:35:04,079 --> 00:35:06,480
work in a lot of these abstractions if

947
00:35:06,480 --> 00:35:08,480
you open up all the abstractions do

948
00:35:08,480 --> 00:35:10,320
everything from first principles and

949
00:35:10,320 --> 00:35:12,000
have a very very fine-grained proof

950
00:35:12,000 --> 00:35:14,160
video use these pebbling structures to

951
00:35:14,160 --> 00:35:15,839
put them tricks in a nice way i think

952
00:35:15,839 --> 00:35:17,200
you should be able to get to adaptive

953
00:35:17,200 --> 00:35:18,960
security as well i'm not saying it's

954
00:35:18,960 --> 00:35:21,040
immediate i think it's feasible but

955
00:35:21,040 --> 00:35:21,839
there

956
00:35:21,839 --> 00:35:24,160
this needs to be more research done in

957
00:35:24,160 --> 00:35:26,320
order to solve that problem okay okay

958
00:35:26,320 --> 00:35:28,480
thank you very interesting but we have

959
00:35:28,480 --> 00:35:30,880
no times we should switch to the next

960
00:35:30,880 --> 00:35:33,200
talk thank you very much

961
00:35:33,200 --> 00:35:34,079
yeah

962
00:35:34,079 --> 00:35:37,520
it's to next talk

963
00:35:38,560 --> 00:35:40,160
so i will

964
00:35:40,160 --> 00:35:41,280
share the

965
00:35:41,280 --> 00:35:44,079
next three talks uh this is xingi huang

966
00:35:44,079 --> 00:35:48,000
from uh fujian normal university china

967
00:35:48,000 --> 00:35:50,640
our next talk is

968
00:35:50,640 --> 00:35:52,960
digital signatures with memory type

969
00:35:52,960 --> 00:35:56,240
security in the multi-challenge setting

970
00:35:56,240 --> 00:35:59,119
and it will be presented by ning ning

971
00:35:59,119 --> 00:36:01,599
are you here

972
00:36:02,160 --> 00:36:04,960
yes yes okay great great it's your turn

973
00:36:04,960 --> 00:36:05,920
yeah

974
00:36:05,920 --> 00:36:07,040
okay

975
00:36:07,040 --> 00:36:08,720
hi everyone my name is

976
00:36:08,720 --> 00:36:10,800
and i'm glad to briefly introduce our

977
00:36:10,800 --> 00:36:12,640
work due to the signatures with

978
00:36:12,640 --> 00:36:13,920
memorized security in the

979
00:36:13,920 --> 00:36:15,920
multi-challenge setting to you

980
00:36:15,920 --> 00:36:19,440
and in our work sorry in our work we

981
00:36:19,440 --> 00:36:21,440
consider memory type reductions

982
00:36:21,440 --> 00:36:23,359
researchers usually measure the quality

983
00:36:23,359 --> 00:36:25,280
of a reduction by its running time and

984
00:36:25,280 --> 00:36:28,160
success probability or advantage

985
00:36:28,160 --> 00:36:30,400
uh i've heard how they observed that

986
00:36:30,400 --> 00:36:32,480
memory is also a valuable computational

987
00:36:32,480 --> 00:36:34,560
resource and should be considered as a

988
00:36:34,560 --> 00:36:37,119
measurement for reductions

989
00:36:37,119 --> 00:36:39,119
so they call a reduction memory type if

990
00:36:39,119 --> 00:36:41,520
the overall memory consumed by the

991
00:36:41,520 --> 00:36:43,760
reduction is approximately the same with

992
00:36:43,760 --> 00:36:46,079
the memory consumed by the adversary

993
00:36:46,079 --> 00:36:48,240
and especially independent of the

994
00:36:48,240 --> 00:36:49,760
adversary

995
00:36:49,760 --> 00:36:51,119
and one

996
00:36:51,119 --> 00:36:52,240
sorry

997
00:36:52,240 --> 00:36:53,920
one interesting setting in this

998
00:36:53,920 --> 00:36:56,000
direction is that

999
00:36:56,000 --> 00:36:58,640
is the multi-challenge a strong uf cma

1000
00:36:58,640 --> 00:37:01,599
security or the msuf cma security of

1001
00:37:01,599 --> 00:37:04,160
digital signature scheme

1002
00:37:04,160 --> 00:37:06,400
different from classical single

1003
00:37:06,400 --> 00:37:08,560
challenges security the adversary could

1004
00:37:08,560 --> 00:37:11,280
submit multiple forge queries throughout

1005
00:37:11,280 --> 00:37:14,640
the msuf cma game and wins if at least

1006
00:37:14,640 --> 00:37:16,160
one of the

1007
00:37:16,160 --> 00:37:17,920
forgery is valid

1008
00:37:17,920 --> 00:37:19,839
and without considering memory single

1009
00:37:19,839 --> 00:37:22,079
challenge security tightly implies the

1010
00:37:22,079 --> 00:37:24,640
multi challenge security

1011
00:37:24,640 --> 00:37:27,280
however albert hall and one method shows

1012
00:37:27,280 --> 00:37:30,160
some impossibility results for msuf cma

1013
00:37:30,160 --> 00:37:32,960
security the memory is considered they

1014
00:37:32,960 --> 00:37:34,720
show that certain black box reductions

1015
00:37:34,720 --> 00:37:37,119
from multi-challenge security to single

1016
00:37:37,119 --> 00:37:38,800
channel security or to some

1017
00:37:38,800 --> 00:37:41,040
computational problem must be known

1018
00:37:41,040 --> 00:37:44,640
tight with respect to memory or time

1019
00:37:44,640 --> 00:37:47,440
so our work shows some good news

1020
00:37:47,440 --> 00:37:50,079
and we focus on finding which properties

1021
00:37:50,079 --> 00:37:52,240
of reduction are sufficient to achieve

1022
00:37:52,240 --> 00:37:53,839
memory tightness

1023
00:37:53,839 --> 00:37:56,079
and keeping the impossibility results

1024
00:37:56,079 --> 00:37:57,119
about

1025
00:37:57,119 --> 00:37:59,440
blackboard reductions of albert hall and

1026
00:37:59,440 --> 00:38:02,240
volunteer in mind we decided to consider

1027
00:38:02,240 --> 00:38:05,200
non-black box reductions and a weaker

1028
00:38:05,200 --> 00:38:07,520
security notion which we call the cma-1

1029
00:38:07,520 --> 00:38:09,599
security

1030
00:38:09,599 --> 00:38:11,680
and even in this setting we still face

1031
00:38:11,680 --> 00:38:13,599
the main challenge that the reduction

1032
00:38:13,599 --> 00:38:15,839
needs to distinguish fresh forgery from

1033
00:38:15,839 --> 00:38:18,480
replayed message signature pair

1034
00:38:18,480 --> 00:38:21,440
without using memory

1035
00:38:21,440 --> 00:38:23,920
so our first step towards solving this

1036
00:38:23,920 --> 00:38:26,160
problem is that we define a special kind

1037
00:38:26,160 --> 00:38:29,200
of non-black reduction which we call the

1038
00:38:29,200 --> 00:38:31,040
canonical reductions

1039
00:38:31,040 --> 00:38:33,200
and the idea of a canonical reduction is

1040
00:38:33,200 --> 00:38:36,000
that the reduction r deals with a single

1041
00:38:36,000 --> 00:38:37,839
challenge adversary a

1042
00:38:37,839 --> 00:38:40,320
and simulates a signature for a in some

1043
00:38:40,320 --> 00:38:42,000
deterministic way

1044
00:38:42,000 --> 00:38:43,839
and then the check for the final forge

1045
00:38:43,839 --> 00:38:46,640
query can be done by comparing the sigma

1046
00:38:46,640 --> 00:38:48,800
star with the simulated signature for

1047
00:38:48,800 --> 00:38:50,640
the message m star

1048
00:38:50,640 --> 00:38:52,960
and in this way the reduction r does not

1049
00:38:52,960 --> 00:38:55,680
use memory to store any signature

1050
00:38:55,680 --> 00:38:58,320
message signature pair

1051
00:38:58,320 --> 00:39:00,640
however canonical reductions are still

1052
00:39:00,640 --> 00:39:03,040
restricted in many aspects for example

1053
00:39:03,040 --> 00:39:05,040
it only deals with a single challenge

1054
00:39:05,040 --> 00:39:06,320
adversaries

1055
00:39:06,320 --> 00:39:08,880
and it is still not memory tied because

1056
00:39:08,880 --> 00:39:11,680
it it needs to simulate a random

1057
00:39:11,680 --> 00:39:12,800
function

1058
00:39:12,800 --> 00:39:15,599
and it only works for a weaker security

1059
00:39:15,599 --> 00:39:18,320
notion which is the cma1 security

1060
00:39:18,320 --> 00:39:22,240
instead of the normal cma security

1061
00:39:22,240 --> 00:39:24,880
and despite of these restrictions we are

1062
00:39:24,880 --> 00:39:26,880
able to use canonical reduction together

1063
00:39:26,880 --> 00:39:29,440
with a memory type pseudorandom function

1064
00:39:29,440 --> 00:39:32,320
to show a good result more precisely if

1065
00:39:32,320 --> 00:39:35,599
there is a reduction r which proves that

1066
00:39:35,599 --> 00:39:38,160
some signature scheme sigma prime has s

1067
00:39:38,160 --> 00:39:40,400
uf cma1 security

1068
00:39:40,400 --> 00:39:42,640
then we can build another reduction r

1069
00:39:42,640 --> 00:39:45,520
prime which proves that sigma prime has

1070
00:39:45,520 --> 00:39:49,760
memory type msuf cma's one security

1071
00:39:49,760 --> 00:39:52,079
and this is this result is nice because

1072
00:39:52,079 --> 00:39:53,920
we can go from single challenge setting

1073
00:39:53,920 --> 00:39:55,680
to the multi-channel setting memory

1074
00:39:55,680 --> 00:39:56,800
tightly

1075
00:39:56,800 --> 00:39:59,359
however we are still in the cma1

1076
00:39:59,359 --> 00:40:01,280
security case

1077
00:40:01,280 --> 00:40:04,880
and to upgrade the security from cma1 to

1078
00:40:04,880 --> 00:40:07,680
cma we take our second step

1079
00:40:07,680 --> 00:40:09,839
more precisely we choose an additional

1080
00:40:09,839 --> 00:40:10,800
nonce

1081
00:40:10,800 --> 00:40:13,440
of length 2 lambda and sign it together

1082
00:40:13,440 --> 00:40:15,200
with the message

1083
00:40:15,200 --> 00:40:16,720
we are able to show that the new

1084
00:40:16,720 --> 00:40:20,000
signature scheme is ms-uf cma secure if

1085
00:40:20,000 --> 00:40:22,599
the original signature scheme is

1086
00:40:22,599 --> 00:40:24,640
ms-ufcma1 secure

1087
00:40:24,640 --> 00:40:27,040
and this transformation preserves

1088
00:40:27,040 --> 00:40:30,960
also preserves memory tightness

1089
00:40:31,119 --> 00:40:34,160
so we achieve our goal via these two

1090
00:40:34,160 --> 00:40:36,560
steps

1091
00:40:36,720 --> 00:40:39,359
and to instantiate our approach we only

1092
00:40:39,359 --> 00:40:41,920
need to construct signature schemes with

1093
00:40:41,920 --> 00:40:45,119
suf cma security and show some canonical

1094
00:40:45,119 --> 00:40:47,839
reduction r for such schemes

1095
00:40:47,839 --> 00:40:50,319
and we are able to instantiate our

1096
00:40:50,319 --> 00:40:53,280
approach and get a concrete memory type

1097
00:40:53,280 --> 00:40:57,040
ms uscma security signature schemes

1098
00:40:57,040 --> 00:40:59,040
as you can see in this table we get

1099
00:40:59,040 --> 00:41:02,000
three fully tight signature speed

1100
00:41:02,000 --> 00:41:04,000
by fully tight we mean that they are

1101
00:41:04,000 --> 00:41:06,319
tight in terms of memory time and

1102
00:41:06,319 --> 00:41:08,640
advantage

1103
00:41:08,640 --> 00:41:10,720
and the three of them are a lossy

1104
00:41:10,720 --> 00:41:12,640
identification based digital signature

1105
00:41:12,640 --> 00:41:15,280
scheme and a variant of the rsa foodon

1106
00:41:15,280 --> 00:41:16,480
hash scheme

1107
00:41:16,480 --> 00:41:18,720
and the variant of the

1108
00:41:18,720 --> 00:41:21,200
bunin lin shattermanski

1109
00:41:21,200 --> 00:41:23,839
and the cost to achieve full tightness

1110
00:41:23,839 --> 00:41:26,640
is a two lambda expansion in the

1111
00:41:26,640 --> 00:41:29,119
signature size

1112
00:41:29,119 --> 00:41:32,079
and to summarize our work we propose we

1113
00:41:32,079 --> 00:41:34,400
propose a generic approach in getting a

1114
00:41:34,400 --> 00:41:37,599
memory type msuf cma signature scheme

1115
00:41:37,599 --> 00:41:39,920
and then we instantiate our approach and

1116
00:41:39,920 --> 00:41:42,160
get three digital signature schemes with

1117
00:41:42,160 --> 00:41:45,440
fully tight ms-us-cma security and our

1118
00:41:45,440 --> 00:41:47,280
results do not conflict with the

1119
00:41:47,280 --> 00:41:49,680
impossibility results by alberto or

1120
00:41:49,680 --> 00:41:52,079
vanetta because we can cook with these

1121
00:41:52,079 --> 00:41:54,160
lower bounds

1122
00:41:54,160 --> 00:41:56,240
since we focus on a special kind of

1123
00:41:56,240 --> 00:41:58,560
non-black box reductions which we call

1124
00:41:58,560 --> 00:42:00,640
canonical reductions

1125
00:42:00,640 --> 00:42:03,280
and a limitation of our work is that the

1126
00:42:03,280 --> 00:42:04,800
memory type signature scheme we

1127
00:42:04,800 --> 00:42:07,040
considered regardless of fully tied or

1128
00:42:07,040 --> 00:42:07,839
not

1129
00:42:07,839 --> 00:42:10,800
are proven in the random oracle model

1130
00:42:10,800 --> 00:42:12,800
so we think uh getting a memory tight

1131
00:42:12,800 --> 00:42:14,960
multi-challenge secure digital signage

1132
00:42:14,960 --> 00:42:17,200
scheme in the standard model is an

1133
00:42:17,200 --> 00:42:19,599
interesting open problem

1134
00:42:19,599 --> 00:42:21,440
so that's all from my talk thank you

1135
00:42:21,440 --> 00:42:23,920
very much i'm happy to answer any

1136
00:42:23,920 --> 00:42:25,359
questions

1137
00:42:25,359 --> 00:42:27,040
thank you lee so

1138
00:42:27,040 --> 00:42:31,560
any questions for the speaker

1139
00:42:33,280 --> 00:42:36,960
okay let me check

1140
00:42:37,839 --> 00:42:39,359
okay so i

1141
00:42:39,359 --> 00:42:42,960
have one simple one simple question

1142
00:42:42,960 --> 00:42:45,440
it is about about the

1143
00:42:45,440 --> 00:42:46,720
uh the

1144
00:42:46,720 --> 00:42:48,880
practical meaning of this uh kind of

1145
00:42:48,880 --> 00:42:51,119
digital signature so which kind of

1146
00:42:51,119 --> 00:42:52,800
scenario would

1147
00:42:52,800 --> 00:42:53,920
need these

1148
00:42:53,920 --> 00:42:55,680
digital signatures secure in the

1149
00:42:55,680 --> 00:42:59,640
multi-challenges setting

1150
00:42:59,760 --> 00:43:01,760
a very simple example

1151
00:43:01,760 --> 00:43:04,000
yeah thank you very much and uh i think

1152
00:43:04,000 --> 00:43:07,119
practically the uh the number of forged

1153
00:43:07,119 --> 00:43:09,680
queries for a practical adversary is

1154
00:43:09,680 --> 00:43:11,760
unbounded the adversary will always try

1155
00:43:11,760 --> 00:43:14,800
to force signatures

1156
00:43:14,800 --> 00:43:18,000
and a single challenge security

1157
00:43:18,000 --> 00:43:19,839
without considering memory single

1158
00:43:19,839 --> 00:43:22,240
challenge security tightly implies the

1159
00:43:22,240 --> 00:43:25,040
multi-challenge setting

1160
00:43:25,040 --> 00:43:27,839
and i think uh memory tightness uh has

1161
00:43:27,839 --> 00:43:28,640
uh

1162
00:43:28,640 --> 00:43:30,960
uh has some impact for

1163
00:43:30,960 --> 00:43:33,839
uh practical usage because uh in

1164
00:43:33,839 --> 00:43:36,319
practical world the number of

1165
00:43:36,319 --> 00:43:38,880
the number of forge attempts by the

1166
00:43:38,880 --> 00:43:42,400
anniversary is unbounded

1167
00:43:43,680 --> 00:43:46,000
okay

1168
00:43:46,079 --> 00:43:48,240
if there's no more questions so thank

1169
00:43:48,240 --> 00:43:50,560
you link so we'll go to the next talk

1170
00:43:50,560 --> 00:43:52,720
okay

1171
00:43:52,720 --> 00:43:54,480
uh the

1172
00:43:54,480 --> 00:43:57,680
the next paper is uh compact adaptively

1173
00:43:57,680 --> 00:44:01,280
secure fe for attribute where he starts

1174
00:44:01,280 --> 00:44:05,280
painting and the speaker is effort

1175
00:44:05,280 --> 00:44:07,200
okay

1176
00:44:07,200 --> 00:44:09,599
hi everyone i'm tapas from iit kharagpur

1177
00:44:09,599 --> 00:44:11,680
i'll be presenting your paper compact

1178
00:44:11,680 --> 00:44:13,599
activity secondary for attribute

1179
00:44:13,599 --> 00:44:15,760
rotations from kailin and this is joint

1180
00:44:15,760 --> 00:44:18,319
work with buddhist from entity research

1181
00:44:18,319 --> 00:44:19,680
so in fashion encryption there is a

1182
00:44:19,680 --> 00:44:21,280
setup authority who generates a master

1183
00:44:21,280 --> 00:44:23,440
secret key and a master public key using

1184
00:44:23,440 --> 00:44:24,960
master probability one can encrypt a

1185
00:44:24,960 --> 00:44:26,560
messaging and computes the ciphertext

1186
00:44:26,560 --> 00:44:28,720
city now a decrypter who wants to

1187
00:44:28,720 --> 00:44:30,480
decrypt the ciphertext city requires for

1188
00:44:30,480 --> 00:44:32,160
a functional security corresponding to

1189
00:44:32,160 --> 00:44:33,520
this function f

1190
00:44:33,520 --> 00:44:35,440
and the central authority will now

1191
00:44:35,440 --> 00:44:37,760
compute a secret kskf using the master

1192
00:44:37,760 --> 00:44:39,680
secret key and gives this to the

1193
00:44:39,680 --> 00:44:42,240
decryptor so that the decrypter will now

1194
00:44:42,240 --> 00:44:44,079
uh decrypt the separate city and learns

1195
00:44:44,079 --> 00:44:45,760
function of the messaging and nothing

1196
00:44:45,760 --> 00:44:46,960
else

1197
00:44:46,960 --> 00:44:49,520
so in this work we construct encryption

1198
00:44:49,520 --> 00:44:50,960
scheme for attribute rotation

1199
00:44:50,960 --> 00:44:53,839
functionality introduced in agw 20. so

1200
00:44:53,839 --> 00:44:55,680
in such a scheme message is divided into

1201
00:44:55,680 --> 00:44:57,359
two parts one is the public part first

1202
00:44:57,359 --> 00:44:59,680
one which is x i and the second one is

1203
00:44:59,680 --> 00:45:02,079
gi which is the private part so the

1204
00:45:02,079 --> 00:45:03,920
functionality is as follows the function

1205
00:45:03,920 --> 00:45:05,520
of the message m is equal to summation

1206
00:45:05,520 --> 00:45:08,640
over i f x i transpose g i and now say

1207
00:45:08,640 --> 00:45:10,400
this i is

1208
00:45:10,400 --> 00:45:12,720
not a pyramid bounded in the setup then

1209
00:45:12,720 --> 00:45:15,680
we call it environment slot scheme

1210
00:45:15,680 --> 00:45:17,599
so to get an idea about the importance

1211
00:45:17,599 --> 00:45:20,160
of this sort of functionality i will

1212
00:45:20,160 --> 00:45:22,640
discuss some special cases suppose if

1213
00:45:22,640 --> 00:45:24,640
outputs a fixed vector then it will

1214
00:45:24,640 --> 00:45:26,319
imply inner product function encryption

1215
00:45:26,319 --> 00:45:29,040
or ipfe and if z is a payload and a

1216
00:45:29,040 --> 00:45:30,960
feasible and function then it will be

1217
00:45:30,960 --> 00:45:32,800
attribute-based encryption

1218
00:45:32,800 --> 00:45:34,640
and thirdly if effects is of the form

1219
00:45:34,640 --> 00:45:36,560
white terms gx then it will be attribute

1220
00:45:36,560 --> 00:45:38,000
based inaccurate function encryption

1221
00:45:38,000 --> 00:45:41,359
recently explored in acgu20

1222
00:45:41,359 --> 00:45:43,599
so in agew20 they proposed a few for

1223
00:45:43,599 --> 00:45:45,280
attribution functionality with some

1224
00:45:45,280 --> 00:45:46,640
interesting features

1225
00:45:46,640 --> 00:45:47,920
the first one is that their scheme

1226
00:45:47,920 --> 00:45:49,599
support unbounded slot and the weight

1227
00:45:49,599 --> 00:45:51,839
functions are abb's or arithmetic

1228
00:45:51,839 --> 00:45:53,280
branching program

1229
00:45:53,280 --> 00:45:54,880
and their ciphertext size depends only

1230
00:45:54,880 --> 00:45:56,480
on the size of the private part of the

1231
00:45:56,480 --> 00:45:58,400
message and the security is based on

1232
00:45:58,400 --> 00:45:59,839
killing or mdds assumptions which are

1233
00:45:59,839 --> 00:46:02,160
known to be standard assumption however

1234
00:46:02,160 --> 00:46:04,319
they prove security uh only in the

1235
00:46:04,319 --> 00:46:06,319
semi-adaptive simulation security model

1236
00:46:06,319 --> 00:46:08,079
and we know that it is not a realistic

1237
00:46:08,079 --> 00:46:08,960
model

1238
00:46:08,960 --> 00:46:11,040
so uh it seems that c selective security

1239
00:46:11,040 --> 00:46:12,400
is weaker than semi-adaptive and

1240
00:46:12,400 --> 00:46:14,079
semiadoptive is weaker than adaptive

1241
00:46:14,079 --> 00:46:17,040
security however due to gkw 16 selective

1242
00:46:17,040 --> 00:46:18,800
security is kind of equivalent to

1243
00:46:18,800 --> 00:46:21,119
semi-adaptive security and known

1244
00:46:21,119 --> 00:46:23,200
customization from semi-adaptive to

1245
00:46:23,200 --> 00:46:25,119
adaptive security requires the

1246
00:46:25,119 --> 00:46:26,720
underlying symmetrically sql functional

1247
00:46:26,720 --> 00:46:28,560
encryption to support general

1248
00:46:28,560 --> 00:46:31,440
functionality so due to this fact egw20

1249
00:46:31,440 --> 00:46:33,359
posed open problem in the paper to

1250
00:46:33,359 --> 00:46:35,359
construct a fee for attribute rotation

1251
00:46:35,359 --> 00:46:37,359
functionality with unbounded slot for

1252
00:46:37,359 --> 00:46:39,599
evps to compact ciphertext and

1253
00:46:39,599 --> 00:46:41,520
adaptively simulation security based on

1254
00:46:41,520 --> 00:46:43,520
standard assumptions

1255
00:46:43,520 --> 00:46:45,680
so before going to uh discuss our work

1256
00:46:45,680 --> 00:46:47,520
let's uh see some previous works and

1257
00:46:47,520 --> 00:46:48,880
challenges in solving this different

1258
00:46:48,880 --> 00:46:51,280
problem so in the right hand side sorry

1259
00:46:51,280 --> 00:46:52,560
in the left hand side of the screen we

1260
00:46:52,560 --> 00:46:55,920
see that um some of the existing abe's

1261
00:46:55,920 --> 00:46:57,520
which are presented in the context of

1262
00:46:57,520 --> 00:46:59,599
partially attribute hiding setting first

1263
00:46:59,599 --> 00:47:01,280
two schemes are semi-adaptively secured

1264
00:47:01,280 --> 00:47:04,560
whereas the last one by duty uh

1265
00:47:04,560 --> 00:47:07,119
they they were able to prove this uh

1266
00:47:07,119 --> 00:47:09,280
adaptive simulation security for uh what

1267
00:47:09,280 --> 00:47:11,520
the policies are abps and in the right

1268
00:47:11,520 --> 00:47:12,800
hand side we see some functional

1269
00:47:12,800 --> 00:47:14,800
encryption schemes uh for different

1270
00:47:14,800 --> 00:47:17,040
functionalities the last two uh

1271
00:47:17,040 --> 00:47:18,880
fees are semi-actively secure whereas

1272
00:47:18,880 --> 00:47:21,040
the first one is uh adaptively secured

1273
00:47:21,040 --> 00:47:23,599
only in the indistinguishable base model

1274
00:47:23,599 --> 00:47:26,640
and lastly in a series of work we see a

1275
00:47:26,640 --> 00:47:27,839
functional encryption scheme for

1276
00:47:27,839 --> 00:47:30,240
interpreter functionality uh which is

1277
00:47:30,240 --> 00:47:31,760
proved secured in the adaptive

1278
00:47:31,760 --> 00:47:34,640
simulation the security model and

1279
00:47:34,640 --> 00:47:36,559
it supports unbounded collision so what

1280
00:47:36,559 --> 00:47:38,720
you can see that is that uh achieving uh

1281
00:47:38,720 --> 00:47:40,480
adaptive uh simulation security with

1282
00:47:40,480 --> 00:47:42,240
unbounded collision for function

1283
00:47:42,240 --> 00:47:44,640
encryption is really a challenging task

1284
00:47:44,640 --> 00:47:47,680
and till now i think we know it only for

1285
00:47:47,680 --> 00:47:49,119
linear functions

1286
00:47:49,119 --> 00:47:52,160
so in this work we present adaptively uh

1287
00:47:52,160 --> 00:47:53,839
simulation secure function incubation

1288
00:47:53,839 --> 00:47:55,119
scheme for attribute detection

1289
00:47:55,119 --> 00:47:57,200
functionality where the weight functions

1290
00:47:57,200 --> 00:47:58,319
are ebp

1291
00:47:58,319 --> 00:48:00,000
first we present a one slot scheme then

1292
00:48:00,000 --> 00:48:02,240
we uh convert it to a unbounded scheme

1293
00:48:02,240 --> 00:48:03,760
with a small caveat which i will explain

1294
00:48:03,760 --> 00:48:05,599
in the next slide our still support

1295
00:48:05,599 --> 00:48:07,520
complex ciphertext

1296
00:48:07,520 --> 00:48:09,200
meaning that the ciphertext size will

1297
00:48:09,200 --> 00:48:11,119
not grow with the multiple occurrence of

1298
00:48:11,119 --> 00:48:12,640
a particular attribute in the wait

1299
00:48:12,640 --> 00:48:15,359
function and also uh the security is

1300
00:48:15,359 --> 00:48:17,440
based on standard keying assumption and

1301
00:48:17,440 --> 00:48:19,920
from the technical ground we extend the

1302
00:48:19,920 --> 00:48:22,559
ll 20 framework from a b to a three ah

1303
00:48:22,559 --> 00:48:24,160
that means from payload hiding to

1304
00:48:24,160 --> 00:48:27,599
partially attribute hiding setting

1305
00:48:27,599 --> 00:48:30,400
so i will now discuss it uh our

1306
00:48:30,400 --> 00:48:32,160
a very

1307
00:48:32,160 --> 00:48:34,400
high level overview for a few scheme

1308
00:48:34,400 --> 00:48:36,800
so we consider two cryptographic tools

1309
00:48:36,800 --> 00:48:38,160
first one is the arithmetic key

1310
00:48:38,160 --> 00:48:40,000
governing scheme aka in short akgs which

1311
00:48:40,000 --> 00:48:41,599
is an information theory tool and it is

1312
00:48:41,599 --> 00:48:43,520
a particular type of randomized encoding

1313
00:48:43,520 --> 00:48:45,440
and the second one is function hiding

1314
00:48:45,440 --> 00:48:47,040
inner product function encryption which

1315
00:48:47,040 --> 00:48:48,960
is a computational two line in short i

1316
00:48:48,960 --> 00:48:51,839
will call it ipv so firstly using akgs

1317
00:48:51,839 --> 00:48:54,319
and ipfe we construct a one key one

1318
00:48:54,319 --> 00:48:55,920
ciphertext secure

1319
00:48:55,920 --> 00:48:58,160
one slot one f scheme in the uh secret

1320
00:48:58,160 --> 00:49:01,200
key setting and then we convert it to a

1321
00:49:01,200 --> 00:49:03,200
full-fledged one slot fes game in the

1322
00:49:03,200 --> 00:49:05,119
public key setting however for that we

1323
00:49:05,119 --> 00:49:07,760
require slotted version of the ipfe

1324
00:49:07,760 --> 00:49:09,920
next to convert our one slot 1f scheme

1325
00:49:09,920 --> 00:49:12,559
to a one slot one extf scheme which is

1326
00:49:12,559 --> 00:49:14,000
again in the secret key setting and it

1327
00:49:14,000 --> 00:49:15,680
supports single key and a single

1328
00:49:15,680 --> 00:49:17,440
ciphertext so what is the xtv

1329
00:49:17,440 --> 00:49:19,359
functionality so in this functionality

1330
00:49:19,359 --> 00:49:20,960
secret keys are generated for a function

1331
00:49:20,960 --> 00:49:22,880
f and effector y and the ciphertext is

1332
00:49:22,880 --> 00:49:25,440
computed for a public vector x and two

1333
00:49:25,440 --> 00:49:28,240
private vectors a z and w

1334
00:49:28,240 --> 00:49:30,480
and during decryption we learn f x

1335
00:49:30,480 --> 00:49:32,720
transpose j plus y transpose w

1336
00:49:32,720 --> 00:49:34,480
the next step is to extend this one slot

1337
00:49:34,480 --> 00:49:36,640
one extreme scheme to a full fledge one

1338
00:49:36,640 --> 00:49:39,680
ex one slot extf scheme and the idea uh

1339
00:49:39,680 --> 00:49:41,520
that we have used is the same as the

1340
00:49:41,520 --> 00:49:43,119
idea that were involved in the previous

1341
00:49:43,119 --> 00:49:44,240
transformation that means we need

1342
00:49:44,240 --> 00:49:46,240
slotted function of the ipv

1343
00:49:46,240 --> 00:49:48,960
and finally ah we use the transformation

1344
00:49:48,960 --> 00:49:52,160
of agw 20 with a little modification ah

1345
00:49:52,160 --> 00:49:54,559
to convert the one slot extp scheme into

1346
00:49:54,559 --> 00:49:57,200
an unbounded slot scheme

1347
00:49:57,200 --> 00:49:59,359
uh in our onslaught if you scheme uh

1348
00:49:59,359 --> 00:50:01,119
adversary can query any polynomial

1349
00:50:01,119 --> 00:50:02,960
number of secret keys both before and

1350
00:50:02,960 --> 00:50:05,440
after the chinese cipher text however in

1351
00:50:05,440 --> 00:50:07,280
the unbounded slot scheme the adversary

1352
00:50:07,280 --> 00:50:09,280
can query only a priori bounded number

1353
00:50:09,280 --> 00:50:11,200
of cipher text ah before the status

1354
00:50:11,200 --> 00:50:13,599
cipher text however uh after the chinese

1355
00:50:13,599 --> 00:50:15,280
effects it can query any polynomial

1356
00:50:15,280 --> 00:50:16,800
number of uh

1357
00:50:16,800 --> 00:50:18,559
secret queries

1358
00:50:18,559 --> 00:50:20,720
so yeah so this is a open problem to

1359
00:50:20,720 --> 00:50:23,440
construct this unbounded scheme with uh

1360
00:50:23,440 --> 00:50:26,160
poly poly uh security in the adaptive

1361
00:50:26,160 --> 00:50:28,160
security model

1362
00:50:28,160 --> 00:50:30,000
thank you and for more details please

1363
00:50:30,000 --> 00:50:32,960
look into our paper

1364
00:50:33,599 --> 00:50:36,400
and yeah i'm open to any question thank

1365
00:50:36,400 --> 00:50:37,440
you so much

1366
00:50:37,440 --> 00:50:41,839
do we have any questions for the speaker

1367
00:50:47,359 --> 00:50:50,319
okay so i got one one question for you

1368
00:50:50,319 --> 00:50:51,920
so

1369
00:50:51,920 --> 00:50:53,359
so

1370
00:50:53,359 --> 00:50:55,839
talking about the like performance of

1371
00:50:55,839 --> 00:50:56,800
the

1372
00:50:56,800 --> 00:51:00,160
algorithms like do we have have you ever

1373
00:51:00,160 --> 00:51:02,400
done some uh

1374
00:51:02,400 --> 00:51:05,440
experiments or to run run the algorithm

1375
00:51:05,440 --> 00:51:08,640
on the normal pc how is the performance

1376
00:51:08,640 --> 00:51:10,720
yeah

1377
00:51:10,720 --> 00:51:12,559
yeah this this work is completely based

1378
00:51:12,559 --> 00:51:15,440
on bi-linear pairing and i haven't done

1379
00:51:15,440 --> 00:51:18,640
any sort of implementation so i i will

1380
00:51:18,640 --> 00:51:20,960
not be able to tell how much run runtime

1381
00:51:20,960 --> 00:51:22,720
is and all

1382
00:51:22,720 --> 00:51:25,119
yeah okay okay okay that's fine so this

1383
00:51:25,119 --> 00:51:26,790
is completely the theory can work

1384
00:51:26,790 --> 00:51:29,680
[Laughter]

1385
00:51:29,680 --> 00:51:31,440
i haven't done it

1386
00:51:31,440 --> 00:51:32,400
from

1387
00:51:32,400 --> 00:51:36,319
the point of view of theoretically right

1388
00:51:43,280 --> 00:51:46,800
okay so our last talk is uh posting the

1389
00:51:46,800 --> 00:51:49,280
security of brian signature schemes and

1390
00:51:49,280 --> 00:51:51,839
the speaker is michael so michael could

1391
00:51:51,839 --> 00:51:55,040
you please hear the slides

1392
00:51:57,200 --> 00:51:59,200
michael are you

1393
00:51:59,200 --> 00:52:03,000
are you here in the room

1394
00:52:13,119 --> 00:52:16,160
okay is michael here

1395
00:52:16,160 --> 00:52:18,559
boosting the security of blind signature

1396
00:52:18,559 --> 00:52:21,040
schemes

1397
00:52:21,359 --> 00:52:25,680
and speaker is michael lawsonburg

1398
00:52:25,760 --> 00:52:28,720
is michael here

1399
00:52:30,480 --> 00:52:32,559
he appears not to be here

1400
00:52:32,559 --> 00:52:34,880
yeah yeah yeah

1401
00:52:34,880 --> 00:52:36,559
so

1402
00:52:36,559 --> 00:52:38,640
shall we close the section or shall we

1403
00:52:38,640 --> 00:52:41,279
keep waiting

1404
00:52:42,079 --> 00:52:44,319
uh we could wait a couple minutes but

1405
00:52:44,319 --> 00:52:46,480
okay i don't think he's been here at all

1406
00:52:46,480 --> 00:52:48,319
and i think he's on the east coast so it

1407
00:52:48,319 --> 00:52:51,280
would be 7 a.m

1408
00:52:51,280 --> 00:52:54,280
okay

1409
00:53:01,440 --> 00:53:03,440
i think it's unlikely he's going to show

1410
00:53:03,440 --> 00:53:06,440
up

1411
00:53:21,599 --> 00:53:24,599
okay

1412
00:53:28,800 --> 00:53:30,480
perhaps it's best just to close the

1413
00:53:30,480 --> 00:53:31,920
session then

1414
00:53:31,920 --> 00:53:33,839
okay

1415
00:53:33,839 --> 00:53:35,440
okay

1416
00:53:35,440 --> 00:53:37,040
okay so

1417
00:53:37,040 --> 00:53:38,559
i think we have a

1418
00:53:38,559 --> 00:53:40,800
down the job so

1419
00:53:40,800 --> 00:53:42,800
this is a station of the advanced

1420
00:53:42,800 --> 00:53:45,359
security and digital signatures yes

1421
00:53:45,359 --> 00:53:48,520
thank you

