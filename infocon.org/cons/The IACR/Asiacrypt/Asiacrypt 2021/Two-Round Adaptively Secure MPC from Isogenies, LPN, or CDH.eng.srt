1
00:00:01,280 --> 00:00:03,679
welcome everyone to my presentation my

2
00:00:03,679 --> 00:00:05,839
name is pratik today i'll talk about our

3
00:00:05,839 --> 00:00:07,839
recent work on two-round adaptively

4
00:00:07,839 --> 00:00:11,840
secured mpc from isogenes lpn or cdh

5
00:00:11,840 --> 00:00:14,320
this is a joint work with naveed from uc

6
00:00:14,320 --> 00:00:16,640
berkeley and visa research with hart

7
00:00:16,640 --> 00:00:18,320
from fujitsu lab

8
00:00:18,320 --> 00:00:20,880
and shikhar from eta zurich and visa

9
00:00:20,880 --> 00:00:23,279
research

10
00:00:23,519 --> 00:00:24,880
today we will talk about secure

11
00:00:24,880 --> 00:00:26,880
competition we consider the two-party

12
00:00:26,880 --> 00:00:28,720
setting there are two parties who have

13
00:00:28,720 --> 00:00:31,199
their private inputs x and y they want

14
00:00:31,199 --> 00:00:33,360
to jointly compute a function f on their

15
00:00:33,360 --> 00:00:34,640
inputs

16
00:00:34,640 --> 00:00:37,120
to do so they run a protocol pi on their

17
00:00:37,120 --> 00:00:39,760
inputs and outputs the protocol output

18
00:00:39,760 --> 00:00:41,200
the protocol should satisfy two

19
00:00:41,200 --> 00:00:43,840
properties mainly it should be correct

20
00:00:43,840 --> 00:00:45,360
that is the function output should be

21
00:00:45,360 --> 00:00:48,079
same as protocol output and the protocol

22
00:00:48,079 --> 00:00:50,640
should be secure that is the protocol

23
00:00:50,640 --> 00:00:52,559
should not leak anything about the

24
00:00:52,559 --> 00:00:55,840
private inputs besides the output

25
00:00:55,840 --> 00:00:58,320
the works of yao gold wright mikhail

26
00:00:58,320 --> 00:01:00,800
victorson beaver mikali rogoway

27
00:01:00,800 --> 00:01:02,559
presented the first few protocols for

28
00:01:02,559 --> 00:01:04,479
secure computation

29
00:01:04,479 --> 00:01:06,159
since then secure computation has found

30
00:01:06,159 --> 00:01:07,760
numerous applications in

31
00:01:07,760 --> 00:01:09,680
privacy-preserving machine learning

32
00:01:09,680 --> 00:01:12,400
blockchains and many more

33
00:01:12,400 --> 00:01:14,080
in this work we consider the primitive

34
00:01:14,080 --> 00:01:16,720
of oblivious transfer or ot

35
00:01:16,720 --> 00:01:18,320
it is a two-party protocol between a

36
00:01:18,320 --> 00:01:19,920
receiver under sender

37
00:01:19,920 --> 00:01:22,000
the receiver has an input choice bit b

38
00:01:22,000 --> 00:01:24,080
and sender has two choice

39
00:01:24,080 --> 00:01:26,799
two messages m0 and m1

40
00:01:26,799 --> 00:01:28,400
by performing the ot protocol the

41
00:01:28,400 --> 00:01:30,320
receiver obtains the message of his

42
00:01:30,320 --> 00:01:33,040
choice ot security ensures that a

43
00:01:33,040 --> 00:01:35,119
corrupt receiver should not know the

44
00:01:35,119 --> 00:01:36,479
other message

45
00:01:36,479 --> 00:01:39,280
m1 minus b and the corrupt sender should

46
00:01:39,280 --> 00:01:42,320
not know the choice bit b

47
00:01:42,320 --> 00:01:44,159
this simple primitive suffices for

48
00:01:44,159 --> 00:01:47,840
general secure computation it's complete

49
00:01:47,840 --> 00:01:50,240
we also know that round optimal ot

50
00:01:50,240 --> 00:01:52,799
enables round optimal secure computation

51
00:01:52,799 --> 00:01:55,520
hence in this work we focus on obtaining

52
00:01:55,520 --> 00:01:58,560
round optimal ot protocols

53
00:01:58,560 --> 00:02:00,560
ot also has other applications like

54
00:02:00,560 --> 00:02:02,719
private set intersection and zero

55
00:02:02,719 --> 00:02:04,799
knowledge

56
00:02:04,799 --> 00:02:07,759
and in this work uh we want to achieve

57
00:02:07,759 --> 00:02:10,479
universal composibility security uh

58
00:02:10,479 --> 00:02:13,440
based on canadia's rank entities model

59
00:02:13,440 --> 00:02:17,200
so we are gonna focus on uc security

60
00:02:17,200 --> 00:02:19,040
so let me briefly recall the security

61
00:02:19,040 --> 00:02:21,040
properties required from our ot

62
00:02:21,040 --> 00:02:23,760
protocols firstly the corrupt receiver

63
00:02:23,760 --> 00:02:25,840
should not know m1 minus b and the

64
00:02:25,840 --> 00:02:27,920
corrupt sender should not know

65
00:02:27,920 --> 00:02:28,640
b

66
00:02:28,640 --> 00:02:31,280
to get simulation based security we need

67
00:02:31,280 --> 00:02:33,040
probabilistically polynomial time

68
00:02:33,040 --> 00:02:34,560
simulator

69
00:02:34,560 --> 00:02:36,720
sim such that it can extract a corrupt

70
00:02:36,720 --> 00:02:39,120
sender and a corrupt receiver's input

71
00:02:39,120 --> 00:02:41,680
given the trapdoors of the setup stream

72
00:02:41,680 --> 00:02:43,760
or some extra power

73
00:02:43,760 --> 00:02:46,000
we model the security of the protocol by

74
00:02:46,000 --> 00:02:48,480
considering a ppt algorithm simulator

75
00:02:48,480 --> 00:02:50,080
the simulator interacts with the real

76
00:02:50,080 --> 00:02:51,440
world

77
00:02:51,440 --> 00:02:53,840
adversary algorithm to create an ideal

78
00:02:53,840 --> 00:02:55,760
world adversarial view

79
00:02:55,760 --> 00:02:58,480
given access to the functionality we say

80
00:02:58,480 --> 00:03:01,120
that security holds if the view of the

81
00:03:01,120 --> 00:03:02,959
adversary in the real world is

82
00:03:02,959 --> 00:03:05,040
indistinguishable from the view in the

83
00:03:05,040 --> 00:03:07,200
ideal world where it interacts with a

84
00:03:07,200 --> 00:03:09,360
simulator sim

85
00:03:09,360 --> 00:03:12,000
we also consider adaptive security which

86
00:03:12,000 --> 00:03:14,080
is the strongest security model in the

87
00:03:14,080 --> 00:03:16,239
setting the adversary can adaptively

88
00:03:16,239 --> 00:03:19,040
corrupt any of the honest parties before

89
00:03:19,040 --> 00:03:21,599
during or after protocol execution

90
00:03:21,599 --> 00:03:23,360
the adversary obtains the internal state

91
00:03:23,360 --> 00:03:25,599
of the honest party upon corruption in

92
00:03:25,599 --> 00:03:28,799
such a case the simulated honest party

93
00:03:28,799 --> 00:03:31,040
view has to be opened consistently to

94
00:03:31,040 --> 00:03:32,959
the honest party's input when the party

95
00:03:32,959 --> 00:03:35,040
gets corrupted in the ideal world that

96
00:03:35,040 --> 00:03:36,879
is non-trivial and really hard to

97
00:03:36,879 --> 00:03:40,560
achieve and that is the focus of our

98
00:03:40,560 --> 00:03:42,799
paper and we also consider malicious

99
00:03:42,799 --> 00:03:45,440
corruptions where the corrupt party can

100
00:03:45,440 --> 00:03:46,560
arbitrarily

101
00:03:46,560 --> 00:03:49,680
deviate from the protocol

102
00:03:49,760 --> 00:03:51,920
so let me briefly discuss the current

103
00:03:51,920 --> 00:03:53,680
works on adaptively secured mpc

104
00:03:53,680 --> 00:03:54,959
protocols

105
00:03:54,959 --> 00:03:57,200
it is known that

106
00:03:57,200 --> 00:03:59,599
constant round adaptively secured mpc is

107
00:03:59,599 --> 00:04:01,760
impossible from black box simulation

108
00:04:01,760 --> 00:04:04,000
duty guard against high

109
00:04:04,000 --> 00:04:06,560
so the works of gurg at all and the

110
00:04:06,560 --> 00:04:09,439
recent work by chakravati at all

111
00:04:09,439 --> 00:04:11,280
construct constant round adaptively

112
00:04:11,280 --> 00:04:13,840
secured npc protocols from non-black box

113
00:04:13,840 --> 00:04:15,439
techniques

114
00:04:15,439 --> 00:04:18,160
in the setup model the works of kennetti

115
00:04:18,160 --> 00:04:20,720
at all and subsequently choi atoll and

116
00:04:20,720 --> 00:04:23,120
gara at all constructed

117
00:04:23,120 --> 00:04:25,440
linear round protocols using the gmw

118
00:04:25,440 --> 00:04:26,560
paradigm

119
00:04:26,560 --> 00:04:29,280
the work of hazai at all showed that

120
00:04:29,280 --> 00:04:30,880
public key encryption

121
00:04:30,880 --> 00:04:33,199
with oblivious cipher text

122
00:04:33,199 --> 00:04:35,360
generation is the minimal assumption

123
00:04:35,360 --> 00:04:38,240
required for adaptively secured mpc

124
00:04:38,240 --> 00:04:41,280
however this protocols are not

125
00:04:41,280 --> 00:04:44,240
round optimal so the focus

126
00:04:44,240 --> 00:04:47,199
in this work is to obtain two round mpc

127
00:04:47,199 --> 00:04:49,520
which is adaptively secure in the setup

128
00:04:49,520 --> 00:04:50,720
string model

129
00:04:50,720 --> 00:04:53,280
in the setting there are a few works

130
00:04:53,280 --> 00:04:55,120
which used io

131
00:04:55,120 --> 00:04:58,400
uh and finally there are only two works

132
00:04:58,400 --> 00:05:00,960
which construct uh two round adaptively

133
00:05:00,960 --> 00:05:02,400
secured mpc

134
00:05:02,400 --> 00:05:03,680
from

135
00:05:03,680 --> 00:05:06,639
standard assumptions the work by ben

136
00:05:06,639 --> 00:05:07,919
muda at all

137
00:05:07,919 --> 00:05:10,560
constructed it from ddh lwe and

138
00:05:10,560 --> 00:05:12,320
quadratic residuosity in the common

139
00:05:12,320 --> 00:05:14,240
reference ring model

140
00:05:14,240 --> 00:05:16,639
the recent work by kennedy at all

141
00:05:16,639 --> 00:05:19,120
constructed uh

142
00:05:19,120 --> 00:05:22,479
uh the same construct achieved the same

143
00:05:22,479 --> 00:05:24,720
result from ddh in the common random

144
00:05:24,720 --> 00:05:26,160
string model

145
00:05:26,160 --> 00:05:28,000
but these are like only three

146
00:05:28,000 --> 00:05:30,400
assumptions that we know from so we ask

147
00:05:30,400 --> 00:05:32,479
the question whether can we construct it

148
00:05:32,479 --> 00:05:34,560
from more assumptions

149
00:05:34,560 --> 00:05:36,800
so we focus on constructing

150
00:05:36,800 --> 00:05:37,680
uh

151
00:05:37,680 --> 00:05:40,720
the mpc protocol from other assumptions

152
00:05:40,720 --> 00:05:43,520
so we demonstrate that a two round ot

153
00:05:43,520 --> 00:05:46,400
with indistinguishability based security

154
00:05:46,400 --> 00:05:48,560
and uh something called oblivious

155
00:05:48,560 --> 00:05:49,600
receiver

156
00:05:49,600 --> 00:05:52,400
message sample ability implies

157
00:05:52,400 --> 00:05:55,039
a two round adapted to secure mpc

158
00:05:55,039 --> 00:05:58,000
so we call this ot primitive as riot

159
00:05:58,000 --> 00:06:00,880
and this is a very weaker ots primitive

160
00:06:00,880 --> 00:06:04,560
compared to adaptively secure ot

161
00:06:04,800 --> 00:06:08,240
and then we built our iot from cdh lpn

162
00:06:08,240 --> 00:06:11,600
and isogenes so this yields the first

163
00:06:11,600 --> 00:06:14,160
two round adaptedly secured mpc protocol

164
00:06:14,160 --> 00:06:16,880
from cdh lpn and isogenes in the

165
00:06:16,880 --> 00:06:18,960
malicious setting and in the semi honest

166
00:06:18,960 --> 00:06:21,520
setting uh we considered the first

167
00:06:21,520 --> 00:06:24,560
uh two-round adaptively secure mpc

168
00:06:24,560 --> 00:06:28,319
protocol from lpn and isogenes uh ben

169
00:06:28,319 --> 00:06:30,639
muda at all constructed it from cdh in

170
00:06:30,639 --> 00:06:32,720
the seminar city

171
00:06:32,720 --> 00:06:36,080
and uh to be more specific uh for

172
00:06:36,080 --> 00:06:37,840
isogeny so we construct it from group

173
00:06:37,840 --> 00:06:41,120
actions uh which can be instantiated

174
00:06:41,120 --> 00:06:43,039
using the sea side and the sea fish

175
00:06:43,039 --> 00:06:44,639
assumption

176
00:06:44,639 --> 00:06:46,720
as a side result we also construct the

177
00:06:46,720 --> 00:06:49,759
first non-committing encryption from lpn

178
00:06:49,759 --> 00:06:52,880
in the setup string model

179
00:06:53,120 --> 00:06:56,080
so let us briefly go through

180
00:06:56,080 --> 00:06:58,160
so let me briefly go through the

181
00:06:58,160 --> 00:07:01,160
techniques

182
00:07:03,840 --> 00:07:05,520
let me briefly recall the security

183
00:07:05,520 --> 00:07:07,919
properties of indistinguishability based

184
00:07:07,919 --> 00:07:08,880
ot

185
00:07:08,880 --> 00:07:10,960
firstly the receiver corrupt receiver

186
00:07:10,960 --> 00:07:12,720
should not know

187
00:07:12,720 --> 00:07:14,639
m1 minus b and the corrupt center should

188
00:07:14,639 --> 00:07:18,160
not know b so this can be modeled as we

189
00:07:18,160 --> 00:07:19,360
can see here

190
00:07:19,360 --> 00:07:21,759
that suppose

191
00:07:21,759 --> 00:07:24,720
the receiver's choice bit is 0 then it

192
00:07:24,720 --> 00:07:27,759
should not distinguish between

193
00:07:27,759 --> 00:07:31,120
a sender's message when m1 is 0 from a

194
00:07:31,120 --> 00:07:33,039
case where m1 is 1

195
00:07:33,039 --> 00:07:34,639
and for the sender

196
00:07:34,639 --> 00:07:36,160
for a current sender

197
00:07:36,160 --> 00:07:37,759
it should not be able to distinguish

198
00:07:37,759 --> 00:07:38,560
when

199
00:07:38,560 --> 00:07:39,360
the

200
00:07:39,360 --> 00:07:41,759
receiver's choice bit is 0 from the case

201
00:07:41,759 --> 00:07:44,240
where the receiver's choice bit is one

202
00:07:44,240 --> 00:07:46,639
so this is iot or indistinguishability

203
00:07:46,639 --> 00:07:50,160
based ot next we will add sample ability

204
00:07:50,160 --> 00:07:51,599
properties for the sender and the

205
00:07:51,599 --> 00:07:54,400
receiver message

206
00:07:56,160 --> 00:07:57,440
so

207
00:07:57,440 --> 00:07:59,520
we will consider the ot protocol in the

208
00:07:59,520 --> 00:08:01,440
crs model where

209
00:08:01,440 --> 00:08:04,000
uh the setup string consists of the crs

210
00:08:04,000 --> 00:08:05,840
and it is generated along with the

211
00:08:05,840 --> 00:08:08,160
trapdoor so the trapdoor will be used by

212
00:08:08,160 --> 00:08:09,599
the simulator

213
00:08:09,599 --> 00:08:10,800
uh

214
00:08:10,800 --> 00:08:13,840
which we will see later

215
00:08:14,080 --> 00:08:16,960
so firstly uh let me describe receiver

216
00:08:16,960 --> 00:08:19,360
sample ability property very qui we

217
00:08:19,360 --> 00:08:21,199
require that there exists

218
00:08:21,199 --> 00:08:23,759
a probabilistically polynomial time uh

219
00:08:23,759 --> 00:08:27,919
algorithm ob1 which obliviously samples

220
00:08:27,919 --> 00:08:30,879
a receiver message pr okay

221
00:08:30,879 --> 00:08:32,958
so now a simulator can honestly

222
00:08:32,958 --> 00:08:35,039
construct a receiver message using the

223
00:08:35,039 --> 00:08:36,719
ot1 algorithm

224
00:08:36,719 --> 00:08:41,679
and the simulator can claim that this pr

225
00:08:41,679 --> 00:08:43,519
on the right hand

226
00:08:43,519 --> 00:08:46,959
right hand side is obliviously sampled

227
00:08:46,959 --> 00:08:49,440
in order to do that it needs to give a

228
00:08:49,440 --> 00:08:51,120
randomness for the

229
00:08:51,120 --> 00:08:54,320
like uh randomness which is consistent

230
00:08:54,320 --> 00:08:57,360
with the oblivious generation of pr

231
00:08:57,360 --> 00:09:00,560
so we require another algorithm inv

232
00:09:00,560 --> 00:09:01,920
invert one

233
00:09:01,920 --> 00:09:03,200
which

234
00:09:03,200 --> 00:09:06,399
uh inverts the randomness

235
00:09:06,399 --> 00:09:07,519
of the

236
00:09:07,519 --> 00:09:08,480
like

237
00:09:08,480 --> 00:09:11,040
simulator which was used to generate the

238
00:09:11,040 --> 00:09:13,920
actual ot message and it gives out

239
00:09:13,920 --> 00:09:16,240
randomness which is consistent with the

240
00:09:16,240 --> 00:09:18,320
oblivious sampling of the receiver

241
00:09:18,320 --> 00:09:19,760
message

242
00:09:19,760 --> 00:09:20,959
and the two distributions of the

243
00:09:20,959 --> 00:09:22,720
receiver message and the sampling

244
00:09:22,720 --> 00:09:24,640
randomness should be computationally

245
00:09:24,640 --> 00:09:26,480
indistinguishable and that is the

246
00:09:26,480 --> 00:09:28,959
receiver sample ability property

247
00:09:28,959 --> 00:09:30,160
next we need

248
00:09:30,160 --> 00:09:32,800
sender sampleability property we require

249
00:09:32,800 --> 00:09:34,640
that there exists probabilistically

250
00:09:34,640 --> 00:09:37,680
polynomial time algorithm ob2 which

251
00:09:37,680 --> 00:09:40,080
allows obliviously sampling a sender

252
00:09:40,080 --> 00:09:43,200
message ps corresponding to bit 1 minus

253
00:09:43,200 --> 00:09:44,240
w

254
00:09:44,240 --> 00:09:46,640
the adversary provides m0 and m1 as

255
00:09:46,640 --> 00:09:49,440
input messages and the algorithm is

256
00:09:49,440 --> 00:09:50,959
parameterized

257
00:09:50,959 --> 00:09:53,920
by the adversary's chosen branch

258
00:09:53,920 --> 00:09:55,440
1 minus b

259
00:09:55,440 --> 00:09:58,160
now a simulator can honestly construct a

260
00:09:58,160 --> 00:10:00,000
sender message using the ot-2 message

261
00:10:00,000 --> 00:10:01,200
algorithm

262
00:10:01,200 --> 00:10:03,040
the simulator can claim that it was

263
00:10:03,040 --> 00:10:05,440
obliviously sampled

264
00:10:05,440 --> 00:10:08,000
and in order to do so the simulator is

265
00:10:08,000 --> 00:10:09,360
required to provide the sampling

266
00:10:09,360 --> 00:10:12,240
randomness which he obtains by using the

267
00:10:12,240 --> 00:10:16,480
inv2 algorithm so that inverts

268
00:10:16,480 --> 00:10:17,279
the

269
00:10:17,279 --> 00:10:20,320
senders honestly generated senders

270
00:10:20,320 --> 00:10:22,399
uh message randomness into a sampling

271
00:10:22,399 --> 00:10:24,720
randomness and the two distributions

272
00:10:24,720 --> 00:10:26,399
over the sender message

273
00:10:26,399 --> 00:10:28,240
receive a message and the sampling

274
00:10:28,240 --> 00:10:30,399
randomness should be computationally

275
00:10:30,399 --> 00:10:32,640
indistinguishable by the center sample

276
00:10:32,640 --> 00:10:34,320
ability property

277
00:10:34,320 --> 00:10:36,399
so these are the two

278
00:10:36,399 --> 00:10:38,000
properties that we need

279
00:10:38,000 --> 00:10:39,680
and we denote an

280
00:10:39,680 --> 00:10:41,680
indistinguishability based ot with

281
00:10:41,680 --> 00:10:44,480
receiver sample ability as riot

282
00:10:44,480 --> 00:10:46,320
and we denote an indistinguishability

283
00:10:46,320 --> 00:10:48,640
based ot with both sender and receivers

284
00:10:48,640 --> 00:10:52,240
ample ability as rs iot

285
00:10:52,240 --> 00:10:53,920
now we will discuss our techniques in

286
00:10:53,920 --> 00:10:57,200
the crs model we start off with our iot

287
00:10:57,200 --> 00:10:58,959
we show that riot with a few other

288
00:10:58,959 --> 00:11:02,079
primitives imply rs iot these primitives

289
00:11:02,079 --> 00:11:04,160
are equivocal and obliviously sampleable

290
00:11:04,160 --> 00:11:06,079
gobbling and obliviously sampleable

291
00:11:06,079 --> 00:11:07,760
commitment scheme these are all

292
00:11:07,760 --> 00:11:10,000
instantiable from one way functions in

293
00:11:10,000 --> 00:11:11,440
the crs model

294
00:11:11,440 --> 00:11:14,800
our work also shows that rs iot suffices

295
00:11:14,800 --> 00:11:17,920
for trapdoor simulatable pke and crs

296
00:11:17,920 --> 00:11:19,440
model

297
00:11:19,440 --> 00:11:22,000
next we construct semi-adaptive ot from

298
00:11:22,000 --> 00:11:24,000
iors iot

299
00:11:24,000 --> 00:11:25,680
equivocal commitment scheme and

300
00:11:25,680 --> 00:11:28,000
oblivious ampliable gobbling and trapdos

301
00:11:28,000 --> 00:11:29,600
immutable pke

302
00:11:29,600 --> 00:11:31,279
combined with the result

303
00:11:31,279 --> 00:11:34,160
of cdmw we also get non-committing

304
00:11:34,160 --> 00:11:36,720
encryption from trapdoors immutable pke

305
00:11:36,720 --> 00:11:39,680
which can be obtained from riot

306
00:11:39,680 --> 00:11:42,640
finally we apply the result of blpv to

307
00:11:42,640 --> 00:11:45,680
get an adaptively secured mpc protocol

308
00:11:45,680 --> 00:11:48,240
from our iot

309
00:11:48,240 --> 00:11:51,120
finally we show that riot can be

310
00:11:51,120 --> 00:11:54,160
constructed from cdh lpn and group

311
00:11:54,160 --> 00:11:58,079
actions in the crs model

312
00:11:58,800 --> 00:12:00,880
so let me briefly go through the

313
00:12:00,880 --> 00:12:02,560
building blocks

314
00:12:02,560 --> 00:12:04,800
we require garbling schemes a garbling

315
00:12:04,800 --> 00:12:06,880
scheme consists of three algorithms it

316
00:12:06,880 --> 00:12:09,120
takes an input a circuit c and

317
00:12:09,120 --> 00:12:12,320
randomness r it outputs a garble circuit

318
00:12:12,320 --> 00:12:15,600
gc and the encoding table en

319
00:12:15,600 --> 00:12:17,600
the encoding algorithm takes an input

320
00:12:17,600 --> 00:12:20,880
the encoding information and input x and

321
00:12:20,880 --> 00:12:22,720
it outputs encoded

322
00:12:22,720 --> 00:12:25,600
input a capital x the evaluation

323
00:12:25,600 --> 00:12:27,519
algorithm takes a

324
00:12:27,519 --> 00:12:30,000
garble circuit and the encoded input and

325
00:12:30,000 --> 00:12:31,839
it computes the output y

326
00:12:31,839 --> 00:12:33,920
correctness of gobbling ensures that y

327
00:12:33,920 --> 00:12:37,040
is same as c of x privacy of the goblin

328
00:12:37,040 --> 00:12:39,200
scheme ensures that the encoded input

329
00:12:39,200 --> 00:12:41,360
does not leak anything about the in

330
00:12:41,360 --> 00:12:42,880
private input x

331
00:12:42,880 --> 00:12:45,680
this is captured using a ppt simulator

332
00:12:45,680 --> 00:12:47,440
which outputs a garble circuit and the

333
00:12:47,440 --> 00:12:50,959
encoded input given the output y without

334
00:12:50,959 --> 00:12:53,600
knowing what is x an adversary cannot

335
00:12:53,600 --> 00:12:56,160
distinguish a simulated carbon circuit

336
00:12:56,160 --> 00:12:58,480
and a simulated encoded input from an

337
00:12:58,480 --> 00:13:01,519
honestly generated one

338
00:13:01,760 --> 00:13:03,600
we also required equivocal goblin

339
00:13:03,600 --> 00:13:06,079
property where the simulator generates

340
00:13:06,079 --> 00:13:07,920
the simulated carbon circuit and the

341
00:13:07,920 --> 00:13:11,279
encoded input then later on it gets the

342
00:13:11,279 --> 00:13:13,279
input x and it has to produce the

343
00:13:13,279 --> 00:13:15,920
encoding information and the goblin

344
00:13:15,920 --> 00:13:18,639
state so given these information and

345
00:13:18,639 --> 00:13:20,560
adversary cannot distinguish

346
00:13:20,560 --> 00:13:22,959
these from an honestly generated one

347
00:13:22,959 --> 00:13:24,880
such goblin schemes are instrumental for

348
00:13:24,880 --> 00:13:27,040
adaptive security and they can be

349
00:13:27,040 --> 00:13:29,519
constructed from one-way functions as

350
00:13:29,519 --> 00:13:32,399
shown by kennedy at all

351
00:13:32,399 --> 00:13:34,639
finally we need oblivious gobbling

352
00:13:34,639 --> 00:13:37,440
schemes here an obliviously generated

353
00:13:37,440 --> 00:13:38,720
garble circuit

354
00:13:38,720 --> 00:13:41,600
always outputs y and can be sampled

355
00:13:41,600 --> 00:13:44,959
using an algorithm called ogb algorithm

356
00:13:44,959 --> 00:13:46,480
with randomness r

357
00:13:46,480 --> 00:13:48,480
and there exists a randomness inversion

358
00:13:48,480 --> 00:13:50,480
algorithm which outputs randomness r

359
00:13:50,480 --> 00:13:51,360
prime

360
00:13:51,360 --> 00:13:53,279
such that an honestly generated carbon

361
00:13:53,279 --> 00:13:56,000
circuit with randomness r can be shown

362
00:13:56,000 --> 00:13:58,160
to be obliviously garbled using random

363
00:13:58,160 --> 00:14:00,000
randomness r prime

364
00:14:00,000 --> 00:14:02,160
the difference from equivocal gobbling

365
00:14:02,160 --> 00:14:04,560
is that the adversary does not get the

366
00:14:04,560 --> 00:14:07,199
entire encoding information since the

367
00:14:07,199 --> 00:14:08,959
garbage circuit is supposed to be

368
00:14:08,959 --> 00:14:11,120
obliviously garbled and there is no

369
00:14:11,120 --> 00:14:13,199
encoding information when the garbage

370
00:14:13,199 --> 00:14:15,360
circuit is obliviously gobbled

371
00:14:15,360 --> 00:14:17,519
and

372
00:14:17,519 --> 00:14:20,000
the work by lindell at all

373
00:14:20,000 --> 00:14:22,320
obtained oblivious goblin schemes from

374
00:14:22,320 --> 00:14:25,120
one way functions

375
00:14:25,360 --> 00:14:27,360
next i will talk about commitment

376
00:14:27,360 --> 00:14:29,839
schemes in the crs model there are three

377
00:14:29,839 --> 00:14:32,160
algorithms the setup algorithm generates

378
00:14:32,160 --> 00:14:34,320
the crs and the trapdoor td the

379
00:14:34,320 --> 00:14:36,720
commitment algorithm generates the

380
00:14:36,720 --> 00:14:39,040
commitment c to message m using

381
00:14:39,040 --> 00:14:41,440
randomness r the verify algorithm

382
00:14:41,440 --> 00:14:43,600
decomputes the commitment to check it

383
00:14:43,600 --> 00:14:45,199
the commitment should satisfy binding

384
00:14:45,199 --> 00:14:46,800
and hiding properties

385
00:14:46,800 --> 00:14:49,680
uh finally we also need oblivious sample

386
00:14:49,680 --> 00:14:51,920
ability property where an honestly

387
00:14:51,920 --> 00:14:54,000
generated commitment can be claimed to

388
00:14:54,000 --> 00:14:56,240
be generated obliviously by inverting

389
00:14:56,240 --> 00:14:59,199
the randomness so oblivious and we know

390
00:14:59,199 --> 00:15:01,600
that oblivious available commitments can

391
00:15:01,600 --> 00:15:03,440
be obtained from one way functions due

392
00:15:03,440 --> 00:15:06,480
to an hour at all

393
00:15:10,320 --> 00:15:13,360
now i will go through our

394
00:15:13,360 --> 00:15:18,079
rsiot construction from riot

395
00:15:18,560 --> 00:15:22,240
we will try to construct our rsiot

396
00:15:22,240 --> 00:15:24,800
using an oblivious available goblin

397
00:15:24,800 --> 00:15:26,560
scheme oblivious available commitment

398
00:15:26,560 --> 00:15:28,240
scheme and riot

399
00:15:28,240 --> 00:15:30,800
the receiver commits to its choice bit b

400
00:15:30,800 --> 00:15:33,360
using randomness r to form a commitment

401
00:15:33,360 --> 00:15:34,160
c

402
00:15:34,160 --> 00:15:37,920
it computes riot receiver algorithm

403
00:15:37,920 --> 00:15:40,959
using the bits of r as choice bits

404
00:15:40,959 --> 00:15:43,360
the sender gobbles the circuit

405
00:15:43,360 --> 00:15:46,160
cir so the circuit has hard coded inside

406
00:15:46,160 --> 00:15:47,600
it the commitment c

407
00:15:47,600 --> 00:15:50,160
a bit e and a message m it takes in

408
00:15:50,160 --> 00:15:52,399
randomness

409
00:15:52,399 --> 00:15:55,759
r and outputs m is c is a commitment to

410
00:15:55,759 --> 00:15:58,160
bit e using randomness r

411
00:15:58,160 --> 00:16:01,040
now the sender will garble this circuit

412
00:16:01,040 --> 00:16:02,160
cir

413
00:16:02,160 --> 00:16:03,680
with e c

414
00:16:03,680 --> 00:16:07,600
and m e as hard coded inputs right and

415
00:16:07,600 --> 00:16:08,959
um he

416
00:16:08,959 --> 00:16:11,040
runs this for both e is equal to zero

417
00:16:11,040 --> 00:16:12,079
and one

418
00:16:12,079 --> 00:16:13,920
this way the sender computes two carbon

419
00:16:13,920 --> 00:16:17,199
circuits gc0 and gc one which encrypts

420
00:16:17,199 --> 00:16:20,240
m0 and m1 within it

421
00:16:20,240 --> 00:16:22,560
the receiver should be able to evaluate

422
00:16:22,560 --> 00:16:25,519
gcb correctly and obtain m b if c is a

423
00:16:25,519 --> 00:16:28,480
correct commitment to b using randomness

424
00:16:28,480 --> 00:16:29,120
r

425
00:16:29,120 --> 00:16:31,279
the sender also computes ot sender

426
00:16:31,279 --> 00:16:33,600
message using the encoding information

427
00:16:33,600 --> 00:16:35,600
of the gable circuits so the receiver

428
00:16:35,600 --> 00:16:37,199
gets the wire labels corresponding to

429
00:16:37,199 --> 00:16:38,959
the bits of ri

430
00:16:38,959 --> 00:16:40,880
the sender sends the garbage circuits

431
00:16:40,880 --> 00:16:43,600
and the riot sender messages

432
00:16:43,600 --> 00:16:45,199
now the receiver decrypts the wire

433
00:16:45,199 --> 00:16:47,360
labels for gcb corresponding to

434
00:16:47,360 --> 00:16:50,480
randomness r it evaluates gcb

435
00:16:50,480 --> 00:16:52,519
to obtain mb

436
00:16:52,519 --> 00:16:54,959
indistinguishability based security for

437
00:16:54,959 --> 00:16:55,680
a

438
00:16:55,680 --> 00:16:58,000
receiver follows from riot receiver

439
00:16:58,000 --> 00:17:01,360
security and hiding of commitment scheme

440
00:17:01,360 --> 00:17:03,680
and the sender security follows from

441
00:17:03,680 --> 00:17:06,720
binding of the commitment scheme uh riot

442
00:17:06,720 --> 00:17:08,559
center security and privacy of the

443
00:17:08,559 --> 00:17:10,559
goblin scheme

444
00:17:10,559 --> 00:17:13,199
uh also we can see that this protocol

445
00:17:13,199 --> 00:17:15,679
satisfies receiver oblivious sample

446
00:17:15,679 --> 00:17:18,000
ability because it follows from

447
00:17:18,000 --> 00:17:20,160
oblivious sampling of commitment scheme

448
00:17:20,160 --> 00:17:22,079
and receive your oblivious ample ability

449
00:17:22,079 --> 00:17:24,559
of the iot messages

450
00:17:24,559 --> 00:17:25,839
however

451
00:17:25,839 --> 00:17:28,079
we cannot argue sender oblivious sample

452
00:17:28,079 --> 00:17:30,400
ability since the sender is committed to

453
00:17:30,400 --> 00:17:32,480
the riot sender messages

454
00:17:32,480 --> 00:17:34,960
even if we use the oblivious

455
00:17:34,960 --> 00:17:36,559
goblin scheme

456
00:17:36,559 --> 00:17:39,360
instead of a regular goblin scheme here

457
00:17:39,360 --> 00:17:41,679
the adversary can distinguish

458
00:17:41,679 --> 00:17:43,760
since the encoding information is

459
00:17:43,760 --> 00:17:45,039
committed

460
00:17:45,039 --> 00:17:47,679
inside the riot sender messages

461
00:17:47,679 --> 00:17:50,160
if we use equivocal garble circuit then

462
00:17:50,160 --> 00:17:52,160
the output of the garble circuit needs

463
00:17:52,160 --> 00:17:54,480
to be set at the time of the goblin it

464
00:17:54,480 --> 00:17:57,360
cannot be changed when inverting the

465
00:17:57,360 --> 00:17:59,919
randomness and hence the riot sender

466
00:17:59,919 --> 00:18:01,600
messages will again help in

467
00:18:01,600 --> 00:18:04,080
distinguishing and obliviously sampled

468
00:18:04,080 --> 00:18:08,000
send a message from an actual one

469
00:18:08,000 --> 00:18:09,840
so we have to modify

470
00:18:09,840 --> 00:18:11,600
uh the

471
00:18:11,600 --> 00:18:13,760
previous construction so in the new

472
00:18:13,760 --> 00:18:15,280
construction or the our final

473
00:18:15,280 --> 00:18:17,360
construction the receiver algorithm

474
00:18:17,360 --> 00:18:19,280
remains the same

475
00:18:19,280 --> 00:18:21,760
the sender algorithm now consists of two

476
00:18:21,760 --> 00:18:23,200
levels of gobbling

477
00:18:23,200 --> 00:18:27,120
the sender gobbles the circuit cir

478
00:18:27,120 --> 00:18:29,679
the circuit cir has hardcoded inside it

479
00:18:29,679 --> 00:18:32,080
the commitment c and the bit e

480
00:18:32,080 --> 00:18:34,960
it takes in randomness r and some

481
00:18:34,960 --> 00:18:38,000
message capital t has input and outputs

482
00:18:38,000 --> 00:18:40,720
capital t if c is a commitment to bit e

483
00:18:40,720 --> 00:18:43,600
using randomness r so this is the outer

484
00:18:43,600 --> 00:18:44,880
gaba circuit

485
00:18:44,880 --> 00:18:46,960
there is anoth there is an inner global

486
00:18:46,960 --> 00:18:48,480
circuit gc prime

487
00:18:48,480 --> 00:18:50,640
that is going to encrypt the sender's

488
00:18:50,640 --> 00:18:51,679
message

489
00:18:51,679 --> 00:18:54,799
uh m so it takes an input a commitment c

490
00:18:54,799 --> 00:18:58,880
prime randomness s and a message m

491
00:18:58,880 --> 00:19:00,559
and g c

492
00:19:00,559 --> 00:19:02,400
uh e prime

493
00:19:02,400 --> 00:19:05,679
uh outputs m if c prime is a commitment

494
00:19:05,679 --> 00:19:08,320
to 0 using randomness using some

495
00:19:08,320 --> 00:19:12,000
randomness s so this is the circuit cir

496
00:19:12,000 --> 00:19:12,799
prime

497
00:19:12,799 --> 00:19:14,720
now the sender computes a commitment to

498
00:19:14,720 --> 00:19:16,000
zero

499
00:19:16,000 --> 00:19:18,320
using randomness and it computes the

500
00:19:18,320 --> 00:19:20,000
encoded input

501
00:19:20,000 --> 00:19:24,480
for c e prime in gce prime as te

502
00:19:24,480 --> 00:19:26,960
the sender computes the outer encoding

503
00:19:26,960 --> 00:19:30,080
of te and sends it to the receiver it

504
00:19:30,080 --> 00:19:32,480
also sends the inner encoding of

505
00:19:32,480 --> 00:19:35,679
sc and me to the receiver

506
00:19:35,679 --> 00:19:38,799
the sender also computes riot sender

507
00:19:38,799 --> 00:19:40,720
messages on the ri

508
00:19:40,720 --> 00:19:42,720
bits

509
00:19:42,720 --> 00:19:44,559
ri bits of receiver

510
00:19:44,559 --> 00:19:47,120
the two inner gaba circuits

511
00:19:47,120 --> 00:19:48,799
and the two outer garber circuits are

512
00:19:48,799 --> 00:19:51,280
also sent to the receiver

513
00:19:51,280 --> 00:19:52,880
now the receiver decrypts the ot

514
00:19:52,880 --> 00:19:56,240
messages to obtain wire labels for ri in

515
00:19:56,240 --> 00:19:57,360
gcb

516
00:19:57,360 --> 00:20:00,240
it has obtained the wire labels for tb

517
00:20:00,240 --> 00:20:03,919
already from the sender's message

518
00:20:03,919 --> 00:20:05,440
it computes

519
00:20:05,440 --> 00:20:08,000
gcb like the outer global circuit

520
00:20:08,000 --> 00:20:11,679
corresponding to bit b to obtain

521
00:20:11,679 --> 00:20:14,240
t b which is the inner encoding of c

522
00:20:14,240 --> 00:20:15,360
prime

523
00:20:15,360 --> 00:20:16,159
b

524
00:20:16,159 --> 00:20:16,960
right

525
00:20:16,960 --> 00:20:19,520
and it evaluates the inner

526
00:20:19,520 --> 00:20:21,039
gcb prime

527
00:20:21,039 --> 00:20:24,400
on tb and the inner encodings of

528
00:20:24,400 --> 00:20:26,000
sb and

529
00:20:26,000 --> 00:20:30,400
mb to obtain capital mb

530
00:20:30,400 --> 00:20:32,320
so we can

531
00:20:32,320 --> 00:20:33,280
again

532
00:20:33,280 --> 00:20:35,360
uh claim that receiver oblivious sample

533
00:20:35,360 --> 00:20:37,679
ability follows from oblivious sampling

534
00:20:37,679 --> 00:20:39,120
of commitment scheme

535
00:20:39,120 --> 00:20:42,320
and uh also from the receiver sample

536
00:20:42,320 --> 00:20:45,200
ability of the riot protocol this is

537
00:20:45,200 --> 00:20:47,200
similar to our

538
00:20:47,200 --> 00:20:50,240
previous construction

539
00:20:50,880 --> 00:20:53,039
center oblivious sample ability follows

540
00:20:53,039 --> 00:20:55,120
from oblivious sampling of c prime

541
00:20:55,120 --> 00:20:57,039
equivocal cobbling and oblivious

542
00:20:57,039 --> 00:21:00,240
amplibility of the inner garble circuit

543
00:21:00,240 --> 00:21:03,520
so here we require equivocal gobbling

544
00:21:03,520 --> 00:21:05,120
property from the outer global circuit

545
00:21:05,120 --> 00:21:06,640
and oblivious sample ability from the

546
00:21:06,640 --> 00:21:08,880
inner gap circuit suppose the receiver's

547
00:21:08,880 --> 00:21:11,280
choice bit is b which can be obtained

548
00:21:11,280 --> 00:21:13,360
from distinguished dependent simulation

549
00:21:13,360 --> 00:21:15,840
to obliviously sample the sender message

550
00:21:15,840 --> 00:21:17,840
corresponding to bit 1 minus b the

551
00:21:17,840 --> 00:21:20,320
sender obliviously gobbles the inner gc

552
00:21:20,320 --> 00:21:22,960
prime 1 minus b and provides obliviously

553
00:21:22,960 --> 00:21:25,840
generated encoded inputs instead of

554
00:21:25,840 --> 00:21:28,240
correct inner encodings for branch 1

555
00:21:28,240 --> 00:21:30,480
minus b on the carbon in a

556
00:21:30,480 --> 00:21:32,640
in a garbage circuit one minus b

557
00:21:32,640 --> 00:21:35,039
if we use the linear pincas construction

558
00:21:35,039 --> 00:21:37,679
then these are random values instead of

559
00:21:37,679 --> 00:21:40,880
uh obliviously generated encoded inputs

560
00:21:40,880 --> 00:21:43,200
so now an adversary cannot distinguish

561
00:21:43,200 --> 00:21:45,280
between an honestly sampled send a

562
00:21:45,280 --> 00:21:47,760
message from an obliviously sampled one

563
00:21:47,760 --> 00:21:50,480
since in both the real and ideal worlds

564
00:21:50,480 --> 00:21:53,039
the outer double circuit for one minus b

565
00:21:53,039 --> 00:21:55,760
branch always outputs a bot or a junk

566
00:21:55,760 --> 00:21:56,720
value

567
00:21:56,720 --> 00:21:59,200
this holds true even if the adversary

568
00:21:59,200 --> 00:22:01,039
obtains the outer goblin randomness due

569
00:22:01,039 --> 00:22:01,919
to

570
00:22:01,919 --> 00:22:02,720
uh

571
00:22:02,720 --> 00:22:04,400
due to the equivocal property of the

572
00:22:04,400 --> 00:22:05,919
outer garbage circuit

573
00:22:05,919 --> 00:22:07,919
so the simulator can claim that one

574
00:22:07,919 --> 00:22:10,240
minus b branch was obliviously sampled

575
00:22:10,240 --> 00:22:13,039
and this trick of two layering of

576
00:22:13,039 --> 00:22:16,480
gobbling allows us to obtain uh

577
00:22:16,480 --> 00:22:18,960
rs iot from our iot

578
00:22:18,960 --> 00:22:21,840
for more details i would suggest you to

579
00:22:21,840 --> 00:22:23,919
check our paper

580
00:22:23,919 --> 00:22:25,760
uh so

581
00:22:25,760 --> 00:22:27,440
let me summarize

582
00:22:27,440 --> 00:22:30,559
uh what we discuss so in this talk we

583
00:22:30,559 --> 00:22:32,480
just saw this construction that is

584
00:22:32,480 --> 00:22:34,000
highlighted for the rest of the

585
00:22:34,000 --> 00:22:37,919
protocols i would refer to the paper

586
00:22:38,880 --> 00:22:40,960
in this work we constructed two round

587
00:22:40,960 --> 00:22:43,520
adaptively maliciously secured mpc from

588
00:22:43,520 --> 00:22:47,600
riot and instantiated riot from cdh lpn

589
00:22:47,600 --> 00:22:49,360
and isogenics

590
00:22:49,360 --> 00:22:51,440
to end with an open with two open

591
00:22:51,440 --> 00:22:53,760
questions what is the minimal assumption

592
00:22:53,760 --> 00:22:57,120
for two round maliciously secured riot

593
00:22:57,120 --> 00:22:59,039
or more general

594
00:22:59,039 --> 00:23:01,039
what is the minimal assumption for two

595
00:23:01,039 --> 00:23:03,520
round adaptively maliciously secure mpc

596
00:23:03,520 --> 00:23:05,280
protocol

597
00:23:05,280 --> 00:23:08,520
thank you

