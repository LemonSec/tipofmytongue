1
00:00:01,439 --> 00:00:03,760
hello everyone and welcome to my

2
00:00:03,760 --> 00:00:06,480
presentation about secure and efficient

3
00:00:06,480 --> 00:00:09,040
software masking on superscalar pipeline

4
00:00:09,040 --> 00:00:12,000
processes my name is barbara and this

5
00:00:12,000 --> 00:00:15,200
work is joint work by my colleagues and

6
00:00:15,200 --> 00:00:19,759
me from grazia university of technology

7
00:00:19,920 --> 00:00:22,400
so first of all in the setting of

8
00:00:22,400 --> 00:00:24,720
physical side channel attacks we have a

9
00:00:24,720 --> 00:00:26,400
specific device

10
00:00:26,400 --> 00:00:29,279
for example a credit card sim card

11
00:00:29,279 --> 00:00:30,720
government id

12
00:00:30,720 --> 00:00:32,399
and this device has

13
00:00:32,399 --> 00:00:36,559
a certain asset like a cryptographic key

14
00:00:36,559 --> 00:00:38,879
on the other hand we have an attacker

15
00:00:38,879 --> 00:00:42,000
who has physically access to this device

16
00:00:42,000 --> 00:00:44,559
this means that the attacker can observe

17
00:00:44,559 --> 00:00:47,200
certain properties of the device

18
00:00:47,200 --> 00:00:50,160
for example the attacker might observe

19
00:00:50,160 --> 00:00:51,920
the power consumption

20
00:00:51,920 --> 00:00:54,480
of a microprocessor which executes

21
00:00:54,480 --> 00:00:57,440
cryptographic software

22
00:00:57,440 --> 00:01:00,160
what can the attacker then do with this

23
00:01:00,160 --> 00:01:01,680
information

24
00:01:01,680 --> 00:01:04,400
the power consumption of a cpu for

25
00:01:04,400 --> 00:01:06,960
example depends on two things first of

26
00:01:06,960 --> 00:01:07,680
all

27
00:01:07,680 --> 00:01:09,760
the instructions which are being

28
00:01:09,760 --> 00:01:11,760
executed by the cpu

29
00:01:11,760 --> 00:01:14,159
and second of all the data which is

30
00:01:14,159 --> 00:01:16,880
involved in this instructions

31
00:01:16,880 --> 00:01:19,759
which might be in the case of an aes

32
00:01:19,759 --> 00:01:22,640
implementation the key which is

33
00:01:22,640 --> 00:01:25,280
processed by the implementation

34
00:01:25,280 --> 00:01:27,520
in order to prevent power analysis

35
00:01:27,520 --> 00:01:30,320
attacks we have to break the dependency

36
00:01:30,320 --> 00:01:32,400
between the sphinx and the power

37
00:01:32,400 --> 00:01:34,240
consumption

38
00:01:34,240 --> 00:01:36,159
this can be done by applying a

39
00:01:36,159 --> 00:01:38,640
countermeasure which is called masking

40
00:01:38,640 --> 00:01:41,840
masking is a secret gearing technique

41
00:01:41,840 --> 00:01:44,640
where we split our sensitive value so

42
00:01:44,640 --> 00:01:47,280
the value we want to protect

43
00:01:47,280 --> 00:01:50,240
into multiple random shares

44
00:01:50,240 --> 00:01:52,799
if the attacker can now observe

45
00:01:52,799 --> 00:01:53,840
up to

46
00:01:53,840 --> 00:01:54,799
d

47
00:01:54,799 --> 00:01:57,759
of this d plus 1 shares

48
00:01:57,759 --> 00:02:00,320
it will not reveal any information about

49
00:02:00,320 --> 00:02:02,880
the sensitive value

50
00:02:02,880 --> 00:02:05,040
here i have one example

51
00:02:05,040 --> 00:02:06,399
this could be

52
00:02:06,399 --> 00:02:08,560
the attacker observing the power

53
00:02:08,560 --> 00:02:10,878
consumption of a

54
00:02:10,878 --> 00:02:14,160
masked aes implementation where we have

55
00:02:14,160 --> 00:02:17,520
split our key into three parts k1 k2 and

56
00:02:17,520 --> 00:02:18,640
k3

57
00:02:18,640 --> 00:02:21,040
then the power consumption at each point

58
00:02:21,040 --> 00:02:24,640
in time will only depend on one part of

59
00:02:24,640 --> 00:02:28,480
the key but never on the

60
00:02:28,480 --> 00:02:31,840
unshared key itself

61
00:02:32,879 --> 00:02:35,920
so masking is very nice but it has

62
00:02:35,920 --> 00:02:39,840
several problems one of it is that

63
00:02:39,840 --> 00:02:42,160
the assumption of a mask software

64
00:02:42,160 --> 00:02:44,080
implementation is

65
00:02:44,080 --> 00:02:46,959
that independent computations in the

66
00:02:46,959 --> 00:02:51,040
software result in independent leakage

67
00:02:51,040 --> 00:02:53,200
let me give you an example we have a

68
00:02:53,200 --> 00:02:55,760
microprocessor

69
00:02:55,760 --> 00:02:58,560
which executes a certain row of

70
00:02:58,560 --> 00:03:01,200
instructions and the assumption here

71
00:03:01,200 --> 00:03:04,480
would be that each instruction leads

72
00:03:04,480 --> 00:03:07,519
to independent leakage so there's only

73
00:03:07,519 --> 00:03:08,400
um

74
00:03:08,400 --> 00:03:09,280
cause

75
00:03:09,280 --> 00:03:12,000
leakage of the data which is processed

76
00:03:12,000 --> 00:03:14,239
by the instructions and this is

77
00:03:14,239 --> 00:03:19,599
unfortunately not the case in um yeah in

78
00:03:19,599 --> 00:03:21,760
some microprocessors

79
00:03:21,760 --> 00:03:24,400
how can we fix this first of all we can

80
00:03:24,400 --> 00:03:26,480
adapt our mask software

81
00:03:26,480 --> 00:03:30,159
to the microprocessor itself and

82
00:03:30,159 --> 00:03:32,480
we can do that if we know

83
00:03:32,480 --> 00:03:34,640
several things about our micro

84
00:03:34,640 --> 00:03:35,920
architecture

85
00:03:35,920 --> 00:03:38,720
and we know um the leakage behavior of

86
00:03:38,720 --> 00:03:40,959
the microarchitecture then we can fine

87
00:03:40,959 --> 00:03:44,400
tune our software such that

88
00:03:44,400 --> 00:03:46,239
leakage will not be caused during

89
00:03:46,239 --> 00:03:48,080
execution

90
00:03:48,080 --> 00:03:50,480
second we can also apply a laser

91
00:03:50,480 --> 00:03:53,680
engineering approach this means

92
00:03:53,680 --> 00:03:56,200
if we do not know that much about our

93
00:03:56,200 --> 00:03:59,840
microarchitecture we can simply say

94
00:03:59,840 --> 00:04:02,080
we use a protection order which is

95
00:04:02,080 --> 00:04:04,879
higher than theoretically required

96
00:04:04,879 --> 00:04:08,080
except a certain leakage and a certain

97
00:04:08,080 --> 00:04:09,360
loss of

98
00:04:09,360 --> 00:04:12,080
protection orders

99
00:04:12,080 --> 00:04:13,200
and

100
00:04:13,200 --> 00:04:14,400
yeah simply

101
00:04:14,400 --> 00:04:16,798
apply a masking scheme with higher order

102
00:04:16,798 --> 00:04:20,000
than actually require

103
00:04:20,478 --> 00:04:23,280
um these are two approaches but what

104
00:04:23,280 --> 00:04:26,080
they have in common is that the runtime

105
00:04:26,080 --> 00:04:28,160
of mask software when applying each

106
00:04:28,160 --> 00:04:29,199
approach

107
00:04:29,199 --> 00:04:32,000
is significantly increased

108
00:04:32,000 --> 00:04:33,919
and the second point is that it still

109
00:04:33,919 --> 00:04:37,440
requires manual leakage assessments

110
00:04:37,440 --> 00:04:39,280
which

111
00:04:39,280 --> 00:04:42,080
is done in order to make sure that there

112
00:04:42,080 --> 00:04:45,040
is really no exploitable leakage

113
00:04:45,040 --> 00:04:47,120
so that our um

114
00:04:47,120 --> 00:04:47,919
our

115
00:04:47,919 --> 00:04:49,600
fixes have really

116
00:04:49,600 --> 00:04:50,479
um

117
00:04:50,479 --> 00:04:54,080
yeah prevented the problem

118
00:04:54,800 --> 00:04:57,280
therefore in our work

119
00:04:57,280 --> 00:05:00,160
we want to evaluate

120
00:05:00,160 --> 00:05:02,720
the security of mask software on complex

121
00:05:02,720 --> 00:05:04,639
processes because

122
00:05:04,639 --> 00:05:07,680
manual leakage assessment is not so easy

123
00:05:07,680 --> 00:05:10,160
there anymore

124
00:05:10,160 --> 00:05:12,240
for example if you apply lazy

125
00:05:12,240 --> 00:05:14,240
engineering or

126
00:05:14,240 --> 00:05:17,120
fine-tune your mask software you might

127
00:05:17,120 --> 00:05:19,520
still get leakage in your manual

128
00:05:19,520 --> 00:05:22,880
assessments and you will not

129
00:05:22,880 --> 00:05:25,360
be able to find out so easy

130
00:05:25,360 --> 00:05:27,199
where this leakage comes from and how to

131
00:05:27,199 --> 00:05:29,840
fix it therefore we want to focus in our

132
00:05:29,840 --> 00:05:32,960
work on the security of mask software in

133
00:05:32,960 --> 00:05:35,360
such a complex processor by complex

134
00:05:35,360 --> 00:05:37,520
processor i mean processors with

135
00:05:37,520 --> 00:05:39,840
multiple pipeline stages

136
00:05:39,840 --> 00:05:43,440
with forwarding logic between the stages

137
00:05:43,440 --> 00:05:46,240
which are maybe super scalar and have

138
00:05:46,240 --> 00:05:48,880
even data caches

139
00:05:48,880 --> 00:05:51,280
and yeah as already said the analysis

140
00:05:51,280 --> 00:05:53,120
for these processes can

141
00:05:53,120 --> 00:05:55,360
barely be done manually anymore

142
00:05:55,360 --> 00:05:57,199
therefore we want to stick to a former

143
00:05:57,199 --> 00:05:59,600
approach

144
00:05:59,600 --> 00:06:01,840
in our case study we focus on the risk

145
00:06:01,840 --> 00:06:04,479
five swerve core which is exactly

146
00:06:04,479 --> 00:06:08,319
one core you would consider more complex

147
00:06:08,319 --> 00:06:11,120
and we focus on the following questions

148
00:06:11,120 --> 00:06:12,720
first of all

149
00:06:12,720 --> 00:06:16,240
which cpu components are the components

150
00:06:16,240 --> 00:06:18,560
which will cause problems in the context

151
00:06:18,560 --> 00:06:20,880
of masking and how can we deal with

152
00:06:20,880 --> 00:06:22,639
these problems

153
00:06:22,639 --> 00:06:24,560
second of all

154
00:06:24,560 --> 00:06:26,400
are there things we need to change in

155
00:06:26,400 --> 00:06:29,680
our software and which things do we need

156
00:06:29,680 --> 00:06:32,479
to change and are there general rules

157
00:06:32,479 --> 00:06:35,039
which you can apply to our software to

158
00:06:35,039 --> 00:06:36,319
get

159
00:06:36,319 --> 00:06:38,639
secure software in the end on such

160
00:06:38,639 --> 00:06:40,639
complex cores

161
00:06:40,639 --> 00:06:43,840
and last how can we still design

162
00:06:43,840 --> 00:06:46,880
efficient mask software so this rules of

163
00:06:46,880 --> 00:06:49,199
course add a certain overhead to the

164
00:06:49,199 --> 00:06:52,080
mask software but is there a way

165
00:06:52,080 --> 00:06:55,919
to keep this overhead low

166
00:06:56,319 --> 00:06:58,479
as already said we consider the swerve

167
00:06:58,479 --> 00:07:00,720
core as the target processor platform

168
00:07:00,720 --> 00:07:03,440
for our analysis this webcore is an open

169
00:07:03,440 --> 00:07:05,840
source risk 5 core which was designed by

170
00:07:05,840 --> 00:07:08,799
western digital

171
00:07:09,039 --> 00:07:12,000
the core is applied in i would say data

172
00:07:12,000 --> 00:07:13,440
intensive

173
00:07:13,440 --> 00:07:16,000
fields of applications for example for

174
00:07:16,000 --> 00:07:18,160
storage controllers

175
00:07:18,160 --> 00:07:22,000
it is comparable to an arm cortex a15

176
00:07:22,000 --> 00:07:24,800
the core is an in order core

177
00:07:24,800 --> 00:07:27,280
and features a dual issue pipeline this

178
00:07:27,280 --> 00:07:29,120
means that it can

179
00:07:29,120 --> 00:07:31,520
not only execute one instruction per

180
00:07:31,520 --> 00:07:33,599
clock cycle but two instructions per

181
00:07:33,599 --> 00:07:34,960
clock cycle

182
00:07:34,960 --> 00:07:37,360
and it has some load store buffers some

183
00:07:37,360 --> 00:07:40,240
of them can be compared to a small data

184
00:07:40,240 --> 00:07:41,520
cache

185
00:07:41,520 --> 00:07:44,400
this work core has nine pipeline stages

186
00:07:44,400 --> 00:07:46,800
here in the figure you can see them so

187
00:07:46,800 --> 00:07:48,720
the first three pipeline stages are

188
00:07:48,720 --> 00:07:51,199
responsible for fetching instructions

189
00:07:51,199 --> 00:07:52,720
from memory

190
00:07:52,720 --> 00:07:55,840
then these instructions are decoded and

191
00:07:55,840 --> 00:07:57,440
sent to

192
00:07:57,440 --> 00:08:00,960
one of the two alus for example

193
00:08:00,960 --> 00:08:02,800
and of course

194
00:08:02,800 --> 00:08:06,319
there is a certain part which handles

195
00:08:06,319 --> 00:08:09,039
forwarding between these pipeline stages

196
00:08:09,039 --> 00:08:10,720
such that we can

197
00:08:10,720 --> 00:08:12,960
for example forward a result from the

198
00:08:12,960 --> 00:08:15,759
sixth pipeline stage back to the input

199
00:08:15,759 --> 00:08:17,360
of the alu

200
00:08:17,360 --> 00:08:19,440
the last two stages are responsible for

201
00:08:19,440 --> 00:08:22,400
commit and right back

202
00:08:22,400 --> 00:08:25,360
our goal in our

203
00:08:25,360 --> 00:08:26,479
analysis

204
00:08:26,479 --> 00:08:28,639
is that we investigate the security of

205
00:08:28,639 --> 00:08:31,039
mask software when executed on the

206
00:08:31,039 --> 00:08:32,479
swerve core

207
00:08:32,479 --> 00:08:35,360
by using former methods

208
00:08:35,360 --> 00:08:36,640
and

209
00:08:36,640 --> 00:08:38,880
when it comes to such an analysis one

210
00:08:38,880 --> 00:08:40,479
has to think about

211
00:08:40,479 --> 00:08:43,279
the attacker's abilities and we do that

212
00:08:43,279 --> 00:08:45,920
by using a certain probing model

213
00:08:45,920 --> 00:08:48,240
the classical probing model which you

214
00:08:48,240 --> 00:08:49,200
apply

215
00:08:49,200 --> 00:08:52,160
for hardware because cpu is

216
00:08:52,160 --> 00:08:54,000
hardware

217
00:08:54,000 --> 00:08:55,360
um

218
00:08:55,360 --> 00:08:58,640
yeah equips the attacker with d probes

219
00:08:58,640 --> 00:09:00,480
so the attacker has the probes and can

220
00:09:00,480 --> 00:09:03,200
distributed these probes

221
00:09:03,200 --> 00:09:06,160
as the attacker likes in the hardware

222
00:09:06,160 --> 00:09:07,200
circuit

223
00:09:07,200 --> 00:09:10,160
and each probe will deliver the value of

224
00:09:10,160 --> 00:09:12,640
a specific gate or wire back to the

225
00:09:12,640 --> 00:09:14,640
attacker

226
00:09:14,640 --> 00:09:16,560
this is good because

227
00:09:16,560 --> 00:09:18,399
by using the classical problem model for

228
00:09:18,399 --> 00:09:19,839
hardware we can

229
00:09:19,839 --> 00:09:22,959
capture side effects like glitches

230
00:09:22,959 --> 00:09:24,160
transitions

231
00:09:24,160 --> 00:09:25,440
but

232
00:09:25,440 --> 00:09:27,920
it is actually not that suitable for

233
00:09:27,920 --> 00:09:29,440
mask software

234
00:09:29,440 --> 00:09:32,720
because the attacker is too powerful for

235
00:09:32,720 --> 00:09:34,880
example if the attacker places one of

236
00:09:34,880 --> 00:09:36,640
its probes

237
00:09:36,640 --> 00:09:39,519
to the output of the register file of

238
00:09:39,519 --> 00:09:41,519
the cpu

239
00:09:41,519 --> 00:09:44,080
the probe will still or will always

240
00:09:44,080 --> 00:09:45,920
deliver

241
00:09:45,920 --> 00:09:47,760
every value which is ever

242
00:09:47,760 --> 00:09:50,080
contained in any register and which is

243
00:09:50,080 --> 00:09:51,920
read in an instruction so this is

244
00:09:51,920 --> 00:09:54,000
immediately broken and we cannot really

245
00:09:54,000 --> 00:09:55,600
design a

246
00:09:55,600 --> 00:09:59,440
mask software with that probing model

247
00:10:00,480 --> 00:10:02,959
instead we decided to stick to the time

248
00:10:02,959 --> 00:10:06,160
constraint probing model

249
00:10:06,160 --> 00:10:08,720
where the attacker can use the d probe

250
00:10:08,720 --> 00:10:11,040
so this is the same as in the classical

251
00:10:11,040 --> 00:10:13,680
probing model to measure a specific gate

252
00:10:13,680 --> 00:10:16,240
of wire but only for the duration of one

253
00:10:16,240 --> 00:10:17,680
clock cycle

254
00:10:17,680 --> 00:10:20,240
and the attacker which is also important

255
00:10:20,240 --> 00:10:23,839
can distribute these probes

256
00:10:23,839 --> 00:10:25,760
as the attacker likes into multiple

257
00:10:25,760 --> 00:10:27,920
clock cycles or

258
00:10:27,920 --> 00:10:31,120
multiple wires and gates

259
00:10:31,120 --> 00:10:33,360
um the time constraint probing model is

260
00:10:33,360 --> 00:10:36,800
actually applied in a previous work

261
00:10:36,800 --> 00:10:38,000
in the

262
00:10:38,000 --> 00:10:41,680
work about the coco verification tool

263
00:10:41,680 --> 00:10:44,480
um which we will also apply for our

264
00:10:44,480 --> 00:10:47,360
analysis so the cocoa verification tool

265
00:10:47,360 --> 00:10:48,640
verifies

266
00:10:48,640 --> 00:10:51,600
that a certain piece of mask software

267
00:10:51,600 --> 00:10:54,000
when executed with a specific cpu

268
00:10:54,000 --> 00:10:55,040
netlist

269
00:10:55,040 --> 00:10:57,600
is secure in the time constraint probing

270
00:10:57,600 --> 00:10:58,480
model

271
00:10:58,480 --> 00:11:00,800
so you can see it here in the figure the

272
00:11:00,800 --> 00:11:02,880
coco tour takes as an input the mask

273
00:11:02,880 --> 00:11:05,440
software the cpu netlist

274
00:11:05,440 --> 00:11:07,040
and also

275
00:11:07,040 --> 00:11:08,800
a certain piece of background

276
00:11:08,800 --> 00:11:11,760
information for example the location of

277
00:11:11,760 --> 00:11:14,000
the shares

278
00:11:14,000 --> 00:11:17,040
when the execution starts so in which

279
00:11:17,040 --> 00:11:20,880
register is which share in which memory

280
00:11:20,880 --> 00:11:23,279
location is which share and so on

281
00:11:23,279 --> 00:11:24,959
and you give that information to the

282
00:11:24,959 --> 00:11:26,560
verifier

283
00:11:26,560 --> 00:11:28,480
and the verifier will check

284
00:11:28,480 --> 00:11:32,160
for each gate in the cpu nets list for

285
00:11:32,160 --> 00:11:36,560
each cycle in this execution whether

286
00:11:36,560 --> 00:11:39,360
an attacker can

287
00:11:39,360 --> 00:11:40,320
measure

288
00:11:40,320 --> 00:11:43,519
some information about any

289
00:11:43,519 --> 00:11:46,720
yeah any native unshared value there

290
00:11:46,720 --> 00:11:49,839
and if the verification is successful

291
00:11:49,839 --> 00:11:52,399
the verify that output yes secure

292
00:11:52,399 --> 00:11:54,959
otherwise it will say no it's not secure

293
00:11:54,959 --> 00:11:57,519
and it will give us

294
00:11:57,519 --> 00:12:00,399
the cycle and the gate

295
00:12:00,399 --> 00:12:01,680
which causes the leak in the

296
00:12:01,680 --> 00:12:04,479
implementation

297
00:12:06,079 --> 00:12:10,480
the work about coco also included a

298
00:12:10,480 --> 00:12:13,120
case study of the risc-5 ebex corm so

299
00:12:13,120 --> 00:12:16,320
the ebex core is a simpler and small

300
00:12:16,320 --> 00:12:17,440
core

301
00:12:17,440 --> 00:12:18,720
but it all

302
00:12:18,720 --> 00:12:20,959
already contains hardware components

303
00:12:20,959 --> 00:12:23,440
which is problematic

304
00:12:23,440 --> 00:12:25,760
for example the register file

305
00:12:25,760 --> 00:12:29,040
so the register file

306
00:12:29,040 --> 00:12:30,560
can

307
00:12:30,560 --> 00:12:31,680
actually

308
00:12:31,680 --> 00:12:33,839
be a thread to the security of masked

309
00:12:33,839 --> 00:12:36,560
software because there are parts which

310
00:12:36,560 --> 00:12:39,120
can cause glitches and transitions

311
00:12:39,120 --> 00:12:42,720
and which will lead into leaks

312
00:12:42,720 --> 00:12:45,680
the work also suggested some

313
00:12:45,680 --> 00:12:49,839
modifications to do um to the hardware

314
00:12:49,839 --> 00:12:52,639
so to the ebex core in order to obtain

315
00:12:52,639 --> 00:12:55,200
a secured e-bike score the secured

316
00:12:55,200 --> 00:12:57,040
e-bike square will then allow the

317
00:12:57,040 --> 00:12:59,519
execution of mask software without any

318
00:12:59,519 --> 00:13:00,639
leaks

319
00:13:00,639 --> 00:13:03,200
as long as

320
00:13:03,200 --> 00:13:04,880
certain software constraints are

321
00:13:04,880 --> 00:13:07,440
followed so the initial work about the

322
00:13:07,440 --> 00:13:10,399
risk-free ebooks course has suggested

323
00:13:10,399 --> 00:13:11,600
first of all

324
00:13:11,600 --> 00:13:14,560
fixes which can be applied to hardware

325
00:13:14,560 --> 00:13:17,040
to your microprocessor

326
00:13:17,040 --> 00:13:20,560
and constraints which has to be met by

327
00:13:20,560 --> 00:13:24,160
your software such that you can execute

328
00:13:24,160 --> 00:13:26,880
and guarantee that the execution of the

329
00:13:26,880 --> 00:13:29,760
software is secure

330
00:13:29,760 --> 00:13:32,560
um now we do not want to consider the

331
00:13:32,560 --> 00:13:35,120
evacs car but the more complex swerve

332
00:13:35,120 --> 00:13:36,320
core

333
00:13:36,320 --> 00:13:39,680
and our initial analysis with coco shows

334
00:13:39,680 --> 00:13:42,720
that the swerve has similar problems so

335
00:13:42,720 --> 00:13:45,120
one problematic component there is also

336
00:13:45,120 --> 00:13:46,880
the register file

337
00:13:46,880 --> 00:13:50,079
and we find out that we can simply map

338
00:13:50,079 --> 00:13:52,240
the hardware fixes which were suggested

339
00:13:52,240 --> 00:13:53,760
in this work

340
00:13:53,760 --> 00:13:55,839
to the swerve core

341
00:13:55,839 --> 00:13:58,880
to obtain the secured swerve core so to

342
00:13:58,880 --> 00:14:01,519
say and the secured swerve

343
00:14:01,519 --> 00:14:04,399
will be the base point for analysis for

344
00:14:04,399 --> 00:14:07,600
all our further experiments

345
00:14:07,600 --> 00:14:10,399
um yeah

346
00:14:10,399 --> 00:14:12,160
so now let's start with the actual

347
00:14:12,160 --> 00:14:14,720
former analysis so we have our secured

348
00:14:14,720 --> 00:14:17,040
swerf core and now we want to verify

349
00:14:17,040 --> 00:14:19,279
something

350
00:14:19,279 --> 00:14:22,000
we chose to verify software which is

351
00:14:22,000 --> 00:14:24,079
generated by tornado

352
00:14:24,079 --> 00:14:26,480
as a starting point so tornado is a nice

353
00:14:26,480 --> 00:14:29,199
tool which will generate mask c

354
00:14:29,199 --> 00:14:32,000
implementations based on unmasked high

355
00:14:32,000 --> 00:14:35,120
level descriptions of cyphers

356
00:14:35,120 --> 00:14:36,000
and

357
00:14:36,000 --> 00:14:38,320
not only that but it will also give you

358
00:14:38,320 --> 00:14:40,880
a security proof in the register probing

359
00:14:40,880 --> 00:14:43,199
model the register probing model is a

360
00:14:43,199 --> 00:14:44,720
problem model which is

361
00:14:44,720 --> 00:14:46,399
often chosen for

362
00:14:46,399 --> 00:14:49,279
software so for mask software in which

363
00:14:49,279 --> 00:14:51,920
an attacker can place the probe on a

364
00:14:51,920 --> 00:14:56,000
specific register for one cycle

365
00:14:56,079 --> 00:14:59,360
in our experiment we generate uh several

366
00:14:59,360 --> 00:15:02,800
masked ketchup s-box implementations

367
00:15:02,800 --> 00:15:05,279
with tornado with several i mean we

368
00:15:05,279 --> 00:15:08,079
generate four different implementations

369
00:15:08,079 --> 00:15:09,199
each

370
00:15:09,199 --> 00:15:11,279
implementation refers to one masking

371
00:15:11,279 --> 00:15:12,880
order

372
00:15:12,880 --> 00:15:15,519
and then we use coco to verify the

373
00:15:15,519 --> 00:15:18,240
execution of this software

374
00:15:18,240 --> 00:15:21,920
on the secured swerve core

375
00:15:22,240 --> 00:15:26,000
the result of this verification is that

376
00:15:26,000 --> 00:15:29,040
the implementations lose or protection

377
00:15:29,040 --> 00:15:30,959
orders because

378
00:15:30,959 --> 00:15:32,959
there are certain components in the

379
00:15:32,959 --> 00:15:35,519
swerf core which cause first of all big

380
00:15:35,519 --> 00:15:36,959
problems

381
00:15:36,959 --> 00:15:38,639
so by this we mean that there are

382
00:15:38,639 --> 00:15:40,480
components combining more than two

383
00:15:40,480 --> 00:15:41,920
shares

384
00:15:41,920 --> 00:15:43,600
and smaller problems so there are

385
00:15:43,600 --> 00:15:45,839
components which combine up to two

386
00:15:45,839 --> 00:15:47,199
shares

387
00:15:47,199 --> 00:15:49,680
let me give you one example of such a

388
00:15:49,680 --> 00:15:51,440
big problem

389
00:15:51,440 --> 00:15:52,399
so

390
00:15:52,399 --> 00:15:55,519
here we try to visualize

391
00:15:55,519 --> 00:15:58,560
the execution of software which contains

392
00:15:58,560 --> 00:16:01,040
10 shares and the shares are in the

393
00:16:01,040 --> 00:16:03,279
pipeline at the same time

394
00:16:03,279 --> 00:16:05,440
due to the masking scheme so the masking

395
00:16:05,440 --> 00:16:08,880
itself is correct on algorithmic clever

396
00:16:08,880 --> 00:16:10,800
then we perform a gate leveling timer

397
00:16:10,800 --> 00:16:12,959
simulation of this verve core

398
00:16:12,959 --> 00:16:15,199
to visualize

399
00:16:15,199 --> 00:16:17,680
where the glitches and transitions on a

400
00:16:17,680 --> 00:16:19,600
specific wire in the processor's

401
00:16:19,600 --> 00:16:24,560
forwarding logic can lead to any leaks

402
00:16:24,560 --> 00:16:27,120
of course for this experiment we use a

403
00:16:27,120 --> 00:16:29,120
specific cell library so the cell

404
00:16:29,120 --> 00:16:31,600
library will map

405
00:16:31,600 --> 00:16:34,399
timings and

406
00:16:34,399 --> 00:16:37,120
area constraints to each gate which is

407
00:16:37,120 --> 00:16:40,240
used in the swerve gate list and this is

408
00:16:40,240 --> 00:16:43,040
the result of the

409
00:16:43,040 --> 00:16:45,680
of the analysis so the question was

410
00:16:45,680 --> 00:16:47,120
again

411
00:16:47,120 --> 00:16:48,560
an attacker

412
00:16:48,560 --> 00:16:51,519
who probes a wire in the piper's logic

413
00:16:51,519 --> 00:16:54,240
of the swerve core for the duration of

414
00:16:54,240 --> 00:16:57,040
one clock cycle so this is important

415
00:16:57,040 --> 00:16:59,600
um what can the attacker see

416
00:16:59,600 --> 00:17:02,480
and we've visualized what the attacker

417
00:17:02,480 --> 00:17:05,199
could see here in this timing diagram so

418
00:17:05,199 --> 00:17:07,760
first of all for example there is a

419
00:17:07,760 --> 00:17:09,679
first chair then we have a combination

420
00:17:09,679 --> 00:17:11,280
of two shares

421
00:17:11,280 --> 00:17:13,760
then we see even combinations of up to

422
00:17:13,760 --> 00:17:15,760
three shares

423
00:17:15,760 --> 00:17:17,760
and the wire switching around before

424
00:17:17,760 --> 00:17:20,400
finally stabilizing to

425
00:17:20,400 --> 00:17:22,319
the value

426
00:17:22,319 --> 00:17:24,480
the wire should have

427
00:17:24,480 --> 00:17:26,160
so in the end we found out that the

428
00:17:26,160 --> 00:17:29,679
attacker can observe up to five shears

429
00:17:29,679 --> 00:17:32,160
when this specific cell library and this

430
00:17:32,160 --> 00:17:34,799
concrete timings are used so this would

431
00:17:34,799 --> 00:17:37,440
be a big problem

432
00:17:37,440 --> 00:17:39,919
um yeah so we saw this

433
00:17:39,919 --> 00:17:42,559
in the processors um

434
00:17:42,559 --> 00:17:46,080
forwarding logic and then we use coco to

435
00:17:46,080 --> 00:17:49,679
analyze what the exact problem is there

436
00:17:49,679 --> 00:17:51,919
so here you see a diagram

437
00:17:51,919 --> 00:17:54,240
of the forwarding logic of the swerve

438
00:17:54,240 --> 00:17:56,400
core you see

439
00:17:56,400 --> 00:17:59,280
here each pipeline stage

440
00:17:59,280 --> 00:18:02,400
so here's the decode stage the alu stage

441
00:18:02,400 --> 00:18:04,880
and the further execution stages

442
00:18:04,880 --> 00:18:07,679
and here we have a multiplexer

443
00:18:07,679 --> 00:18:10,559
which will forward the data from the

444
00:18:10,559 --> 00:18:15,430
correct pipeline stage to the alu

445
00:18:15,430 --> 00:18:16,640
[Music]

446
00:18:16,640 --> 00:18:17,760
yeah

447
00:18:17,760 --> 00:18:20,240
the multiplexer has a select signal

448
00:18:20,240 --> 00:18:22,960
which is called m1 select and the select

449
00:18:22,960 --> 00:18:24,240
signal

450
00:18:24,240 --> 00:18:27,520
is computed by combinatorial logic

451
00:18:27,520 --> 00:18:28,400
which means

452
00:18:28,400 --> 00:18:30,400
that it might glitch

453
00:18:30,400 --> 00:18:33,360
and if a glitch happens

454
00:18:33,360 --> 00:18:35,440
also the output of the multiplexer will

455
00:18:35,440 --> 00:18:36,400
glitch

456
00:18:36,400 --> 00:18:37,760
and if

457
00:18:37,760 --> 00:18:40,799
you imagine now a software where we have

458
00:18:40,799 --> 00:18:43,039
multiple shares of the same secret in

459
00:18:43,039 --> 00:18:45,200
each pipeline stage

460
00:18:45,200 --> 00:18:48,880
then forward data will

461
00:18:48,880 --> 00:18:50,480
kind of

462
00:18:50,480 --> 00:18:51,600
forward

463
00:18:51,600 --> 00:18:54,080
the result of each share

464
00:18:54,080 --> 00:18:57,760
to the aleu when m1 select bleaches and

465
00:18:57,760 --> 00:19:00,400
then we combine multiple shares and this

466
00:19:00,400 --> 00:19:03,120
is what we call a big problem

467
00:19:03,120 --> 00:19:05,760
now the question is how can we fix that

468
00:19:05,760 --> 00:19:08,080
um first of all we thought about fixing

469
00:19:08,080 --> 00:19:10,880
that in hardware similar to what was

470
00:19:10,880 --> 00:19:14,720
suggested in the work about the ebx core

471
00:19:14,720 --> 00:19:16,799
but

472
00:19:16,799 --> 00:19:19,360
yeah that would involve that we need to

473
00:19:19,360 --> 00:19:21,039
get each

474
00:19:21,039 --> 00:19:22,799
pipeline register

475
00:19:22,799 --> 00:19:25,600
with a bit indicating whether the value

476
00:19:25,600 --> 00:19:27,360
of the register should be forwarded to

477
00:19:27,360 --> 00:19:30,000
the alu or not

478
00:19:30,000 --> 00:19:30,880
um

479
00:19:30,880 --> 00:19:33,120
this could be done but the gate bits

480
00:19:33,120 --> 00:19:35,200
need to be glitch-free and this is not

481
00:19:35,200 --> 00:19:37,600
that easy to achieve and requires in the

482
00:19:37,600 --> 00:19:40,320
end a very large latency overhead which

483
00:19:40,320 --> 00:19:42,240
is impractical

484
00:19:42,240 --> 00:19:44,400
instead

485
00:19:44,400 --> 00:19:46,880
we need to find some solution in

486
00:19:46,880 --> 00:19:48,000
software

487
00:19:48,000 --> 00:19:50,080
um

488
00:19:50,080 --> 00:19:52,799
basically the software solution or the

489
00:19:52,799 --> 00:19:55,120
software constraint as we call it needs

490
00:19:55,120 --> 00:19:57,600
to ensure that at no time

491
00:19:57,600 --> 00:19:59,440
there are multiple shares of the same

492
00:19:59,440 --> 00:20:03,120
native value in the pipeline

493
00:20:03,120 --> 00:20:06,240
how can we do that we need to make sure

494
00:20:06,240 --> 00:20:07,200
that

495
00:20:07,200 --> 00:20:10,480
the distance between two instructions

496
00:20:10,480 --> 00:20:11,919
which

497
00:20:11,919 --> 00:20:14,640
process shares of the same native value

498
00:20:14,640 --> 00:20:15,520
is

499
00:20:15,520 --> 00:20:18,000
large enough so that there are enough

500
00:20:18,000 --> 00:20:20,640
unrelated instructions between them

501
00:20:20,640 --> 00:20:23,520
what do i mean by unrelated instructions

502
00:20:23,520 --> 00:20:25,760
well in the basic case this is an op

503
00:20:25,760 --> 00:20:27,120
operation

504
00:20:27,120 --> 00:20:30,480
but it can also be an instruction which

505
00:20:30,480 --> 00:20:33,440
processes a share from another secret

506
00:20:33,440 --> 00:20:37,280
or a alu operation on non-secret data

507
00:20:37,280 --> 00:20:42,480
like incrementing the counter of a loop

508
00:20:42,559 --> 00:20:43,520
um

509
00:20:43,520 --> 00:20:44,400
we

510
00:20:44,400 --> 00:20:47,760
performed further analysis and um it

511
00:20:47,760 --> 00:20:50,159
turns out that there are a lot of other

512
00:20:50,159 --> 00:20:51,440
components

513
00:20:51,440 --> 00:20:54,080
which cause leaks in this worth core if

514
00:20:54,080 --> 00:20:56,240
you're interested you can have a look at

515
00:20:56,240 --> 00:20:57,440
the paper

516
00:20:57,440 --> 00:20:59,200
i will now

517
00:20:59,200 --> 00:21:01,360
only give you one more example which are

518
00:21:01,360 --> 00:21:03,600
the management components of the data

519
00:21:03,600 --> 00:21:05,039
memory

520
00:21:05,039 --> 00:21:07,600
for example there is a component which

521
00:21:07,600 --> 00:21:09,679
is called the lsu bus buffer this is

522
00:21:09,679 --> 00:21:12,880
similar to a small data cache

523
00:21:12,880 --> 00:21:14,080
and

524
00:21:14,080 --> 00:21:17,919
there might happen a leak if the buffer

525
00:21:17,919 --> 00:21:20,559
contains a store

526
00:21:20,559 --> 00:21:21,679
and

527
00:21:21,679 --> 00:21:23,280
this

528
00:21:23,280 --> 00:21:26,159
if the buffer contains a shear sorry

529
00:21:26,159 --> 00:21:28,400
and the shear is overwritten by its

530
00:21:28,400 --> 00:21:30,400
counterpart by performing another load

531
00:21:30,400 --> 00:21:32,159
or store

532
00:21:32,159 --> 00:21:33,840
instruction

533
00:21:33,840 --> 00:21:36,480
so this is really bad and again the

534
00:21:36,480 --> 00:21:38,640
hardware solutions turned out to be

535
00:21:38,640 --> 00:21:40,960
impractical and we need more software

536
00:21:40,960 --> 00:21:42,240
constraints

537
00:21:42,240 --> 00:21:45,039
for example for the lsu bus buffer the

538
00:21:45,039 --> 00:21:47,120
software constraints would would be to

539
00:21:47,120 --> 00:21:50,080
flash the buffer

540
00:21:50,559 --> 00:21:52,960
between loading two shares of the same

541
00:21:52,960 --> 00:21:55,679
native value

542
00:21:57,200 --> 00:22:00,080
okay so this was uh the

543
00:22:00,080 --> 00:22:02,080
results we had for the swerve core and

544
00:22:02,080 --> 00:22:05,679
now we try to derive some generic rules

545
00:22:05,679 --> 00:22:07,280
for that

546
00:22:07,280 --> 00:22:10,640
um so our analysis clearly shows that

547
00:22:10,640 --> 00:22:13,760
software constraints are necessary

548
00:22:13,760 --> 00:22:16,159
even though we already work with a

549
00:22:16,159 --> 00:22:18,480
secured or hardened version of this

550
00:22:18,480 --> 00:22:20,720
worth core

551
00:22:20,720 --> 00:22:22,480
one effective software constraint turned

552
00:22:22,480 --> 00:22:24,400
out to be the insertion of unrelated

553
00:22:24,400 --> 00:22:28,320
instruction between two instructions

554
00:22:28,320 --> 00:22:29,200
and

555
00:22:29,200 --> 00:22:30,960
the question is now how many

556
00:22:30,960 --> 00:22:34,799
instructions need to be inserted there

557
00:22:34,799 --> 00:22:36,240
and

558
00:22:36,240 --> 00:22:39,280
this number can actually be expressed in

559
00:22:39,280 --> 00:22:40,890
terms of

560
00:22:40,890 --> 00:22:42,080
[Music]

561
00:22:42,080 --> 00:22:43,679
the length of the

562
00:22:43,679 --> 00:22:46,000
pipeline of the core and the amount of

563
00:22:46,000 --> 00:22:47,520
execution units

564
00:22:47,520 --> 00:22:49,200
so here i divide

565
00:22:49,200 --> 00:22:52,480
the amount of pipeline stages p into p i

566
00:22:52,480 --> 00:22:53,520
and p d

567
00:22:53,520 --> 00:22:56,159
p i is the number of stages um which

568
00:22:56,159 --> 00:22:58,559
deal with fetching the instructions so

569
00:22:58,559 --> 00:23:00,960
now no data is involved there

570
00:23:00,960 --> 00:23:02,159
npt

571
00:23:02,159 --> 00:23:04,240
is the number of instructions which

572
00:23:04,240 --> 00:23:06,799
actually processes data

573
00:23:06,799 --> 00:23:09,679
and uh it turns out that you need

574
00:23:09,679 --> 00:23:11,600
pd times e

575
00:23:11,600 --> 00:23:14,240
the amount of execution units

576
00:23:14,240 --> 00:23:15,440
um

577
00:23:15,440 --> 00:23:18,640
plus one unrelated instructions between

578
00:23:18,640 --> 00:23:22,799
uh yeah two dangerous instructions

579
00:23:22,799 --> 00:23:24,400
and

580
00:23:24,400 --> 00:23:27,120
we also try to formulate a factor for

581
00:23:27,120 --> 00:23:30,559
the order reduction so if we want to

582
00:23:30,559 --> 00:23:33,120
apply the laser engineering approach

583
00:23:33,120 --> 00:23:37,360
how many or how much more orders do i

584
00:23:37,360 --> 00:23:38,559
need

585
00:23:38,559 --> 00:23:41,039
in my masking scheme to still be secure

586
00:23:41,039 --> 00:23:43,120
on such a processor

587
00:23:43,120 --> 00:23:45,200
and the factor we computed here is

588
00:23:45,200 --> 00:23:49,120
actually the reduction factor of

589
00:23:49,120 --> 00:23:51,279
a lazily engineered mask software

590
00:23:51,279 --> 00:23:53,679
implementation when executed

591
00:23:53,679 --> 00:23:55,679
on such a complex

592
00:23:55,679 --> 00:23:58,960
pipeline processor

593
00:23:59,440 --> 00:24:02,159
okay so now i have told you that we need

594
00:24:02,159 --> 00:24:04,720
a lot of software constraints even on a

595
00:24:04,720 --> 00:24:08,159
secured swerve core

596
00:24:08,159 --> 00:24:10,240
and if one adapts this

597
00:24:10,240 --> 00:24:13,200
rules or constraints strictly

598
00:24:13,200 --> 00:24:15,039
you can imagine the overhead is really

599
00:24:15,039 --> 00:24:16,000
huge

600
00:24:16,000 --> 00:24:18,640
here i have a table which summarizes

601
00:24:18,640 --> 00:24:20,000
this

602
00:24:20,000 --> 00:24:20,960
so

603
00:24:20,960 --> 00:24:22,000
you see

604
00:24:22,000 --> 00:24:24,960
um a certain set of example programs we

605
00:24:24,960 --> 00:24:27,840
have here for example dom and gate

606
00:24:27,840 --> 00:24:29,919
then we compare

607
00:24:29,919 --> 00:24:32,400
the number of cycles and the number of

608
00:24:32,400 --> 00:24:35,520
instructions required by the software

609
00:24:35,520 --> 00:24:36,799
when we

610
00:24:36,799 --> 00:24:39,840
implement it without constraints

611
00:24:39,840 --> 00:24:41,120
and

612
00:24:41,120 --> 00:24:43,919
when we implement it

613
00:24:43,919 --> 00:24:46,480
with constraints so by applying the

614
00:24:46,480 --> 00:24:50,240
rules strictly so to say

615
00:24:50,240 --> 00:24:52,720
if we have constraints i also give you

616
00:24:52,720 --> 00:24:55,360
the number of total instructions and the

617
00:24:55,360 --> 00:24:57,360
number of knobs

618
00:24:57,360 --> 00:24:58,240
so

619
00:24:58,240 --> 00:25:00,400
knobs are kind of the unrelated

620
00:25:00,400 --> 00:25:02,559
instructions

621
00:25:02,559 --> 00:25:06,640
which had to be mapped to two knobs

622
00:25:06,640 --> 00:25:08,559
and as you see here for example for the

623
00:25:08,559 --> 00:25:11,440
dom and we need uh

624
00:25:11,440 --> 00:25:15,520
33 cycles instead of only 10 when we

625
00:25:15,520 --> 00:25:17,440
have no constraints

626
00:25:17,440 --> 00:25:19,440
or if we look at higher order

627
00:25:19,440 --> 00:25:21,919
implementations it's even worse so here

628
00:25:21,919 --> 00:25:25,200
we need 33 cycles without constraints

629
00:25:25,200 --> 00:25:28,880
but 250 cycles with constraints and

630
00:25:28,880 --> 00:25:32,080
considering the number of instructions

631
00:25:32,080 --> 00:25:34,559
we almost need 300 instruction

632
00:25:34,559 --> 00:25:35,919
instructions

633
00:25:35,919 --> 00:25:38,960
and the major amount of those is

634
00:25:38,960 --> 00:25:39,919
knobs

635
00:25:39,919 --> 00:25:40,880
so

636
00:25:40,880 --> 00:25:43,279
unrelated instructions where we cannot

637
00:25:43,279 --> 00:25:45,440
really do anything um

638
00:25:45,440 --> 00:25:46,799
which makes

639
00:25:46,799 --> 00:25:49,200
sense or anything useful

640
00:25:49,200 --> 00:25:50,880
can we change that

641
00:25:50,880 --> 00:25:52,320
yes

642
00:25:52,320 --> 00:25:55,360
the answer is yes so if we um

643
00:25:55,360 --> 00:25:57,440
we apply

644
00:25:57,440 --> 00:25:59,360
the right implementation techniques we

645
00:25:59,360 --> 00:26:01,840
can reduce this overhead

646
00:26:01,840 --> 00:26:04,400
fortunately

647
00:26:04,400 --> 00:26:06,880
one of these implementation techniques

648
00:26:06,880 --> 00:26:09,600
techniques is to stick to parallel

649
00:26:09,600 --> 00:26:11,520
implementations instead of serial

650
00:26:11,520 --> 00:26:13,520
implementations

651
00:26:13,520 --> 00:26:16,480
let me explain that based on an example

652
00:26:16,480 --> 00:26:18,880
assume we have a ketchup xbox and the

653
00:26:18,880 --> 00:26:21,600
state of this s box consists of five

654
00:26:21,600 --> 00:26:22,960
lanes

655
00:26:22,960 --> 00:26:26,320
each lane itself is again shared into

656
00:26:26,320 --> 00:26:27,919
these shares

657
00:26:27,919 --> 00:26:30,400
in a serial implementation

658
00:26:30,400 --> 00:26:32,720
we would take

659
00:26:32,720 --> 00:26:35,520
the d shares of three lanes

660
00:26:35,520 --> 00:26:38,559
process them and store the output lane

661
00:26:38,559 --> 00:26:41,120
then we would again take the d shares of

662
00:26:41,120 --> 00:26:44,080
the three lanes process them and store

663
00:26:44,080 --> 00:26:46,880
them in the output lane

664
00:26:46,880 --> 00:26:49,200
of course there are lots of unrelated

665
00:26:49,200 --> 00:26:51,840
instructions which would be needed to

666
00:26:51,840 --> 00:26:55,840
separate the processing of the d shares

667
00:26:55,840 --> 00:26:59,039
for the same native value

668
00:26:59,039 --> 00:27:01,840
in the case of parallel instructions on

669
00:27:01,840 --> 00:27:03,840
the parallel

670
00:27:03,840 --> 00:27:07,039
implementations on the other hand

671
00:27:07,039 --> 00:27:09,600
we use instead of the knobs which we

672
00:27:09,600 --> 00:27:11,840
would use in serial implementations

673
00:27:11,840 --> 00:27:14,720
computations of shares of other lanes so

674
00:27:14,720 --> 00:27:17,360
we kind of mix

675
00:27:17,360 --> 00:27:20,720
the computation of the lanes

676
00:27:20,720 --> 00:27:23,520
here you can see one example so here we

677
00:27:23,520 --> 00:27:25,679
have a serial implementation of a dom

678
00:27:25,679 --> 00:27:27,440
catcher s box

679
00:27:27,440 --> 00:27:30,880
compared to the parallel implementation

680
00:27:30,880 --> 00:27:32,399
and if we

681
00:27:32,399 --> 00:27:34,480
now compare compared overhead

682
00:27:34,480 --> 00:27:36,320
which the constraint constraints

683
00:27:36,320 --> 00:27:39,120
introduce for a serial implementation

684
00:27:39,120 --> 00:27:44,880
um we have uh 18 cycles compared to 240

685
00:27:44,880 --> 00:27:49,559
but if we do that in a parallel way

686
00:27:50,000 --> 00:27:52,720
the overhead is much smaller so we have

687
00:27:52,720 --> 00:27:55,919
36 cycles compared to 81 cycles

688
00:27:55,919 --> 00:27:59,039
and also here we have

689
00:27:59,039 --> 00:28:02,240
almost 100 instructions compared to 400

690
00:28:02,240 --> 00:28:05,679
with a lot of the 400 being knobs

691
00:28:05,679 --> 00:28:08,080
and here we can really um

692
00:28:08,080 --> 00:28:09,200
use

693
00:28:09,200 --> 00:28:10,880
seven

694
00:28:10,880 --> 00:28:13,279
use 79

695
00:28:13,279 --> 00:28:15,919
out of the 144 instructions are only

696
00:28:15,919 --> 00:28:18,000
knobs

697
00:28:18,000 --> 00:28:20,720
okay so let's have a look at another

698
00:28:20,720 --> 00:28:22,640
technique which is called threshold

699
00:28:22,640 --> 00:28:24,159
implementation so threshold

700
00:28:24,159 --> 00:28:26,960
implementations is a masking technique

701
00:28:26,960 --> 00:28:29,039
which is based on the property of

702
00:28:29,039 --> 00:28:31,760
non-complete component functions

703
00:28:31,760 --> 00:28:34,559
so non-completenen means that i can

704
00:28:34,559 --> 00:28:36,880
compute each component function in such

705
00:28:36,880 --> 00:28:39,679
a masking scheme

706
00:28:39,679 --> 00:28:44,640
and i need for the computation um

707
00:28:44,640 --> 00:28:46,559
all the shares except of one so the

708
00:28:46,559 --> 00:28:49,279
computation is independent of at least

709
00:28:49,279 --> 00:28:52,080
one of its input shares

710
00:28:52,080 --> 00:28:54,880
for the ti catcher s box this would mean

711
00:28:54,880 --> 00:28:55,679
that

712
00:28:55,679 --> 00:28:58,399
the linear layer can still be done in

713
00:28:58,399 --> 00:29:00,480
sequence for each year

714
00:29:00,480 --> 00:29:02,159
but when it comes to the non-linear

715
00:29:02,159 --> 00:29:04,320
layer where we will require multiple

716
00:29:04,320 --> 00:29:06,640
shears we will do it in sequence for

717
00:29:06,640 --> 00:29:09,840
each component function

718
00:29:09,919 --> 00:29:11,760
this means on the other hand that we can

719
00:29:11,760 --> 00:29:13,919
ignore smaller problems so small

720
00:29:13,919 --> 00:29:15,520
problems are the problems where we

721
00:29:15,520 --> 00:29:17,919
combine up to two shares because we have

722
00:29:17,919 --> 00:29:20,960
component functions which will only

723
00:29:20,960 --> 00:29:22,720
ever compute

724
00:29:22,720 --> 00:29:25,200
based on in the first order case two

725
00:29:25,200 --> 00:29:27,440
shares

726
00:29:27,440 --> 00:29:29,600
and we can therefore ignore this more

727
00:29:29,600 --> 00:29:32,080
problems but

728
00:29:32,080 --> 00:29:34,240
of course

729
00:29:34,240 --> 00:29:37,200
the downside is that we need free shares

730
00:29:37,200 --> 00:29:39,520
for first order security

731
00:29:39,520 --> 00:29:41,279
however the results were really

732
00:29:41,279 --> 00:29:43,679
promising here we have a ti ketchup

733
00:29:43,679 --> 00:29:45,760
s-box

734
00:29:45,760 --> 00:29:48,559
and we see that

735
00:29:48,559 --> 00:29:51,120
yeah 66 cycles are required without

736
00:29:51,120 --> 00:29:54,480
constraints but with constraints only 72

737
00:29:54,480 --> 00:29:56,320
cycles are

738
00:29:56,320 --> 00:29:58,480
required and from the unrelated

739
00:29:58,480 --> 00:30:02,480
instructions only 15 are knobs

740
00:30:02,480 --> 00:30:04,720
for the ascon implementation which we

741
00:30:04,720 --> 00:30:06,320
also did

742
00:30:06,320 --> 00:30:11,919
we have 70 uh 721 cycles compared to

743
00:30:11,919 --> 00:30:15,200
almost a thousand and 700 cycles

744
00:30:15,200 --> 00:30:18,880
here um the overhead is mainly to do

745
00:30:18,880 --> 00:30:22,640
register splitting and also

746
00:30:22,640 --> 00:30:23,760
due to

747
00:30:23,760 --> 00:30:26,399
memory overhead because the ascon state

748
00:30:26,399 --> 00:30:28,720
is much bigger than the ketchup state

749
00:30:28,720 --> 00:30:30,640
and therefore we cannot hold all our

750
00:30:30,640 --> 00:30:33,679
shares in the register file all the time

751
00:30:33,679 --> 00:30:35,679
so we have to load and store the shares

752
00:30:35,679 --> 00:30:37,520
and this introduces

753
00:30:37,520 --> 00:30:39,679
on the swerve core

754
00:30:39,679 --> 00:30:40,720
a lot of

755
00:30:40,720 --> 00:30:42,720
overhead because we have to clear the

756
00:30:42,720 --> 00:30:44,799
load store buffer

757
00:30:44,799 --> 00:30:46,399
so

758
00:30:46,399 --> 00:30:47,600
yeah

759
00:30:47,600 --> 00:30:50,000
but this actually already leads me to

760
00:30:50,000 --> 00:30:54,080
the end of my presentation so um

761
00:30:54,080 --> 00:30:56,240
we've discussed that architectural side

762
00:30:56,240 --> 00:30:59,279
effects of complex abuse can reduce the

763
00:30:59,279 --> 00:31:01,279
security of mask software

764
00:31:01,279 --> 00:31:03,919
by multiple orders and this is due to

765
00:31:03,919 --> 00:31:06,640
problematic components which cause big

766
00:31:06,640 --> 00:31:08,080
or small

767
00:31:08,080 --> 00:31:09,679
problems so

768
00:31:09,679 --> 00:31:12,640
the combination of

769
00:31:12,640 --> 00:31:15,600
of more than two or up to two shares and

770
00:31:15,600 --> 00:31:18,880
these components are mostly pipelines

771
00:31:18,880 --> 00:31:21,919
and memory management components

772
00:31:21,919 --> 00:31:22,720
and

773
00:31:22,720 --> 00:31:24,559
however we showed that it is still

774
00:31:24,559 --> 00:31:27,440
possible to have secure and efficient

775
00:31:27,440 --> 00:31:29,039
masking

776
00:31:29,039 --> 00:31:30,799
when we

777
00:31:30,799 --> 00:31:32,799
carefully consider both hardware and

778
00:31:32,799 --> 00:31:34,720
software

779
00:31:34,720 --> 00:31:38,320
so thank you all for listening

780
00:31:38,320 --> 00:31:43,240
and yeah thank you for your attention

