1
00:00:06,319 --> 00:00:07,200
okay

2
00:00:07,200 --> 00:00:10,240
welcome to the theory session

3
00:00:10,240 --> 00:00:14,559
i'm rio and shira and i uh is going to

4
00:00:14,559 --> 00:00:17,440
share this session we will have six

5
00:00:17,440 --> 00:00:19,680
stocks in this session

6
00:00:19,680 --> 00:00:22,480
the first talk is with security as

7
00:00:22,480 --> 00:00:24,640
computational costs for winning games

8
00:00:24,640 --> 00:00:28,000
with high probability by shun watanabe

9
00:00:28,000 --> 00:00:29,840
and kenji

10
00:00:29,840 --> 00:00:33,119
kenshi is going to speak

11
00:00:34,719 --> 00:00:37,760
oh can you hear me

12
00:00:37,760 --> 00:00:39,120
yes

13
00:00:39,120 --> 00:00:41,520
thank you for introduction

14
00:00:41,520 --> 00:00:43,360
my name is candy asanaga

15
00:00:43,360 --> 00:00:44,399
this talk

16
00:00:44,399 --> 00:00:46,640
is about the new framework of bit

17
00:00:46,640 --> 00:00:49,600
security this is a joint work with of

18
00:00:49,600 --> 00:00:52,320
chinwa david

19
00:00:52,320 --> 00:00:54,960
and big security is a well established

20
00:00:54,960 --> 00:00:56,640
measure of quantifying the security

21
00:00:56,640 --> 00:01:00,320
level of cryptographic primitives

22
00:01:00,320 --> 00:01:04,239
and we say a primitive p has kbit of

23
00:01:04,239 --> 00:01:07,360
security if every adversary needs to do

24
00:01:07,360 --> 00:01:10,840
this k operation to attack primitive

25
00:01:10,840 --> 00:01:13,680
p so the question is how can we define

26
00:01:13,680 --> 00:01:16,479
bit security

27
00:01:17,600 --> 00:01:19,200
let's consider the case of the wiring

28
00:01:19,200 --> 00:01:20,560
function

29
00:01:20,560 --> 00:01:24,000
f is the one f is a function and suppose

30
00:01:24,000 --> 00:01:26,080
that there is some adversary with

31
00:01:26,080 --> 00:01:28,799
computational cost t such that the

32
00:01:28,799 --> 00:01:31,280
probability and the adversary a breaks

33
00:01:31,280 --> 00:01:33,119
the one venus of f with probability

34
00:01:33,119 --> 00:01:35,759
decipion

35
00:01:35,759 --> 00:01:38,320
then we can see that security is

36
00:01:38,320 --> 00:01:43,439
at most log base 2 of t over epsilon

37
00:01:43,600 --> 00:01:45,040
the reason is that

38
00:01:45,040 --> 00:01:46,079
if

39
00:01:46,079 --> 00:01:50,799
we invoke a in total n times

40
00:01:50,799 --> 00:01:53,840
then the probability that some adversary

41
00:01:53,840 --> 00:01:56,240
a breaks one minus of f will be

42
00:01:56,240 --> 00:01:59,280
amplified to epsilon n

43
00:01:59,280 --> 00:02:02,000
so it is sufficient to choose n is equal

44
00:02:02,000 --> 00:02:04,079
to one over equation

45
00:02:04,079 --> 00:02:04,960
so

46
00:02:04,960 --> 00:02:08,239
the total cost of order n times t is

47
00:02:08,239 --> 00:02:12,560
equal to order t over epsilon

48
00:02:12,879 --> 00:02:14,959
so the which security should be defined

49
00:02:14,959 --> 00:02:18,239
as the minimum value of log 2 of t over

50
00:02:18,239 --> 00:02:21,239
epsilon

51
00:02:22,319 --> 00:02:23,760
this way of

52
00:02:23,760 --> 00:02:26,080
evaluating the security can be extended

53
00:02:26,080 --> 00:02:28,160
to other such like primitives and

54
00:02:28,160 --> 00:02:30,800
assumptions

55
00:02:30,800 --> 00:02:32,400
so the questions

56
00:02:32,400 --> 00:02:34,160
we want to ask in this work

57
00:02:34,160 --> 00:02:35,040
is

58
00:02:35,040 --> 00:02:37,360
how to define bit security of decision

59
00:02:37,360 --> 00:02:41,120
type premise and assumptions

60
00:02:41,120 --> 00:02:44,800
and in decision type edition games

61
00:02:44,800 --> 00:02:46,879
we designed the game such that the

62
00:02:46,879 --> 00:02:48,560
winning property of the adversary is

63
00:02:48,560 --> 00:02:50,560
close to one half

64
00:02:50,560 --> 00:02:52,080
so we use

65
00:02:52,080 --> 00:02:54,239
this value as the advantage of the

66
00:02:54,239 --> 00:02:55,599
adversary

67
00:02:55,599 --> 00:02:57,920
so the question is is this advantage is

68
00:02:57,920 --> 00:02:59,920
the light measure for evaluating bit

69
00:02:59,920 --> 00:03:02,920
security

70
00:03:04,000 --> 00:03:06,800
and in this work we introduced a new

71
00:03:06,800 --> 00:03:09,519
framework for divine beach security

72
00:03:09,519 --> 00:03:11,760
and we apply the same operational

73
00:03:11,760 --> 00:03:14,480
meaning for such and decision games

74
00:03:14,480 --> 00:03:17,519
the interpretation is that

75
00:03:17,519 --> 00:03:19,920
the game has captured security if every

76
00:03:19,920 --> 00:03:22,239
adversary is cost up to scale for

77
00:03:22,239 --> 00:03:26,319
winning the game with high probability

78
00:03:26,480 --> 00:03:28,959
and as the answer to the second question

79
00:03:28,959 --> 00:03:30,879
in the previous slide

80
00:03:30,879 --> 00:03:33,280
we showed that the learning advantage is

81
00:03:33,280 --> 00:03:35,440
the light measure for everything with

82
00:03:35,440 --> 00:03:38,239
security of decision games

83
00:03:38,239 --> 00:03:40,879
the reason is that in our framework the

84
00:03:40,879 --> 00:03:42,959
adversary plays the binary hypothesis

85
00:03:42,959 --> 00:03:45,120
testing

86
00:03:45,120 --> 00:03:47,519
and we show several natural reductions

87
00:03:47,519 --> 00:03:51,280
of its security between security gates

88
00:03:52,959 --> 00:03:55,519
other characterization of our bit

89
00:03:55,519 --> 00:03:56,720
security

90
00:03:56,720 --> 00:03:58,000
we show that

91
00:03:58,000 --> 00:03:59,200
for any

92
00:03:59,200 --> 00:04:02,879
decision game is the bit security is uh

93
00:04:02,879 --> 00:04:04,640
characterized as

94
00:04:04,640 --> 00:04:05,840
this

95
00:04:05,840 --> 00:04:07,840
this is a linear advantage of the

96
00:04:07,840 --> 00:04:09,439
adversary

97
00:04:09,439 --> 00:04:11,519
and which is defined as learning

98
00:04:11,519 --> 00:04:14,400
divergence of order one half between two

99
00:04:14,400 --> 00:04:18,959
distributions regarding the adversary

100
00:04:20,639 --> 00:04:24,320
and as a comparison we compare

101
00:04:24,320 --> 00:04:25,440
the

102
00:04:25,440 --> 00:04:28,320
advantage and the conventional advantage

103
00:04:28,320 --> 00:04:29,680
suppose that

104
00:04:29,680 --> 00:04:32,560
the advisor a has the combinational

105
00:04:32,560 --> 00:04:34,720
advantage of the diversion a is equal to

106
00:04:34,720 --> 00:04:36,240
epsilon

107
00:04:36,240 --> 00:04:38,800
then we show that linear advantage is

108
00:04:38,800 --> 00:04:41,280
lower bounded by epsilon squared and

109
00:04:41,280 --> 00:04:44,720
upper bound by school i option answering

110
00:04:44,720 --> 00:04:46,320
lower bounds by epsilon squared and

111
00:04:46,320 --> 00:04:48,479
upper bounded by egyptian so there is a

112
00:04:48,479 --> 00:04:50,720
gap between learning advantage under

113
00:04:50,720 --> 00:04:53,840
conventional advantage

114
00:04:55,360 --> 00:04:58,160
are we show several natural

115
00:04:58,160 --> 00:05:01,039
mutual security reduction

116
00:05:01,039 --> 00:05:03,360
one notice is that

117
00:05:03,360 --> 00:05:05,840
about the gold rush living theorem we

118
00:05:05,840 --> 00:05:08,320
show that cape to secure one function in

119
00:05:08,320 --> 00:05:10,720
price came to secure had a complicated

120
00:05:10,720 --> 00:05:14,639
for some district class of adversaries

121
00:05:14,639 --> 00:05:17,759
so to prove the general case remains an

122
00:05:17,759 --> 00:05:21,280
interesting open question

123
00:05:23,440 --> 00:05:27,520
so that's all thank you

124
00:05:37,039 --> 00:05:40,080
i don't see any questions right now so

125
00:05:40,080 --> 00:05:42,240
should

126
00:05:42,240 --> 00:05:44,479
does anybody else have any questions

127
00:05:44,479 --> 00:05:46,080
right now

128
00:05:46,080 --> 00:05:48,800
i don't see any on zoom or the

129
00:05:48,800 --> 00:05:52,360
asia good portal

130
00:05:54,240 --> 00:05:57,280
okay we can take questions after all

131
00:05:57,280 --> 00:05:58,639
talks so

132
00:05:58,639 --> 00:06:00,960
if you

133
00:06:01,360 --> 00:06:02,880
anyone

134
00:06:02,880 --> 00:06:07,039
doesn't have a question then we

135
00:06:07,039 --> 00:06:08,639
move to the

136
00:06:08,639 --> 00:06:10,639
second talk

137
00:06:10,639 --> 00:06:13,280
okay that's like one naive question then

138
00:06:13,280 --> 00:06:14,720
um

139
00:06:14,720 --> 00:06:16,960
so what do you mean by balanced

140
00:06:16,960 --> 00:06:18,800
adversaries

141
00:06:18,800 --> 00:06:21,680
yes in this sense we want to show that

142
00:06:21,680 --> 00:06:23,680
capture one functioning price capital

143
00:06:23,680 --> 00:06:25,840
signal how to copy that for

144
00:06:25,840 --> 00:06:29,360
any adversary but we prove this cell

145
00:06:29,360 --> 00:06:32,960
only for the balanced adversary

146
00:06:32,960 --> 00:06:35,360
the kb2 cabinetry is is tight in this

147
00:06:35,360 --> 00:06:36,720
case

148
00:06:36,720 --> 00:06:39,280
all right uh so what does balance mean

149
00:06:39,280 --> 00:06:41,680
like is it really restricted or what's

150
00:06:41,680 --> 00:06:43,039
the

151
00:06:43,039 --> 00:06:45,360
what kind of adversary

152
00:06:45,360 --> 00:06:47,680
should we imagine this to be

153
00:06:47,680 --> 00:06:50,800
balanced means the adversary output zero

154
00:06:50,800 --> 00:06:52,960
and one string with probability at least

155
00:06:52,960 --> 00:06:56,240
a constant probability

156
00:06:56,240 --> 00:06:59,120
okay so do you think it's like a caveat

157
00:06:59,120 --> 00:07:00,960
of the proof technique or is it like

158
00:07:00,960 --> 00:07:02,800
something fundamental

159
00:07:02,800 --> 00:07:04,479
because it sounds

160
00:07:04,479 --> 00:07:06,240
a bit artificial

161
00:07:06,240 --> 00:07:08,880
or i might be wrong might not i think

162
00:07:08,880 --> 00:07:11,919
it is too restrictive so we need to you

163
00:07:11,919 --> 00:07:15,360
want to prove it for general cases

164
00:07:15,360 --> 00:07:17,840
okay

165
00:07:17,919 --> 00:07:19,199
um

166
00:07:19,199 --> 00:07:21,039
all right so there's one question from

167
00:07:21,039 --> 00:07:23,680
julian uh how is tightness defined with

168
00:07:23,680 --> 00:07:26,080
respect to this definition

169
00:07:26,080 --> 00:07:28,319
yes titans means that kept secure while

170
00:07:28,319 --> 00:07:30,880
functioning plus keeps secure k2k is

171
00:07:30,880 --> 00:07:33,199
tight

172
00:07:34,960 --> 00:07:37,520
uh julian does that answer your question

173
00:07:37,520 --> 00:07:39,440
no no it doesn't actually my question

174
00:07:39,440 --> 00:07:42,160
was about um so so there are different

175
00:07:42,160 --> 00:07:45,039
ways of defining tightness for example

176
00:07:45,039 --> 00:07:46,800
you can define it using

177
00:07:46,800 --> 00:07:49,520
the advantage or the running time like

178
00:07:49,520 --> 00:07:52,000
considering them separately but

179
00:07:52,000 --> 00:07:53,360
there's also

180
00:07:53,360 --> 00:07:55,520
you know the possibility of

181
00:07:55,520 --> 00:07:57,599
of considering the fraction of the

182
00:07:57,599 --> 00:08:00,240
running time and the success probability

183
00:08:00,240 --> 00:08:02,080
so how would you define tightness here

184
00:08:02,080 --> 00:08:05,919
so if the if the the fraction of uh

185
00:08:05,919 --> 00:08:07,840
running time and success probability is

186
00:08:07,840 --> 00:08:10,840
equal for for both

187
00:08:10,840 --> 00:08:14,080
games yeah in this game

188
00:08:14,080 --> 00:08:14,960
we

189
00:08:14,960 --> 00:08:18,319
see that to this k the exponent k we

190
00:08:18,319 --> 00:08:21,599
only see the x month k

191
00:08:21,599 --> 00:08:23,520
to one value

192
00:08:23,520 --> 00:08:27,280
which is related to epsilon t

193
00:08:27,280 --> 00:08:29,759
in our grammar

194
00:08:29,759 --> 00:08:32,000
so you say the reduction is tight if the

195
00:08:32,000 --> 00:08:32,719
if

196
00:08:32,719 --> 00:08:34,640
the quotient of the running time and the

197
00:08:34,640 --> 00:08:36,640
success probability is the same

198
00:08:36,640 --> 00:08:39,039
for for both solvers of the original

199
00:08:39,039 --> 00:08:40,240
game and

200
00:08:40,240 --> 00:08:43,839
the game you you end up with or

201
00:08:43,919 --> 00:08:47,120
yes if the time and advantage is equal

202
00:08:47,120 --> 00:08:49,200
it is tight

203
00:08:49,200 --> 00:08:50,640
okay so it doesn't it doesn't change

204
00:08:50,640 --> 00:08:52,880
anything of how you refine it yeah

205
00:08:52,880 --> 00:08:55,440
if we lose some advantage

206
00:08:55,440 --> 00:08:57,360
we get a loose

207
00:08:57,360 --> 00:08:58,560
reduction

208
00:08:58,560 --> 00:09:00,800
okay

209
00:09:04,560 --> 00:09:06,720
all right i don't see any more questions

210
00:09:06,720 --> 00:09:09,200
right now so maybe we can come back if

211
00:09:09,200 --> 00:09:10,399
some

212
00:09:10,399 --> 00:09:12,640
somebody else has some questions we can

213
00:09:12,640 --> 00:09:15,439
go to the next talk

214
00:09:15,600 --> 00:09:17,519
all right then

215
00:09:17,519 --> 00:09:20,480
let's move to the second talk

216
00:09:20,480 --> 00:09:23,200
the second talk is uh giving an

217
00:09:23,200 --> 00:09:26,880
adversary guarantees or how to model

218
00:09:26,880 --> 00:09:29,360
designated verifier signature in

219
00:09:29,360 --> 00:09:31,200
composable framework

220
00:09:31,200 --> 00:09:32,160
by

221
00:09:32,160 --> 00:09:36,320
uh um little christopher portman willie

222
00:09:36,320 --> 00:09:37,920
mauler and

223
00:09:37,920 --> 00:09:39,440
greenman

224
00:09:39,440 --> 00:09:42,480
is going to speak

225
00:09:45,040 --> 00:09:48,839
oh you're muted

226
00:09:55,920 --> 00:09:58,240
okay sorry

227
00:09:58,240 --> 00:10:00,640
uh okay yes

228
00:10:00,640 --> 00:10:02,839
hi i'm german i'm going

229
00:10:02,839 --> 00:10:07,040
um to present you our paper on giving an

230
00:10:07,040 --> 00:10:09,519
adversary guarantees or how to model

231
00:10:09,519 --> 00:10:11,440
designated verifier signatures in a

232
00:10:11,440 --> 00:10:14,480
composable framework

233
00:10:15,040 --> 00:10:16,720
this is antwerp with william r and

234
00:10:16,720 --> 00:10:19,120
christopher portman

235
00:10:19,120 --> 00:10:20,959
so to start that

236
00:10:20,959 --> 00:10:23,440
have a look at the composable notion

237
00:10:23,440 --> 00:10:25,680
capturing authenticity

238
00:10:25,680 --> 00:10:27,680
so this comprises a real world and ideal

239
00:10:27,680 --> 00:10:29,760
world and we are going to assume a

240
00:10:29,760 --> 00:10:33,040
setting where we have five parties alice

241
00:10:33,040 --> 00:10:36,800
of one two and three and if

242
00:10:36,800 --> 00:10:38,800
we have to assume resources a key

243
00:10:38,800 --> 00:10:40,720
generation authority and an insecure

244
00:10:40,720 --> 00:10:41,760
channel

245
00:10:41,760 --> 00:10:43,200
the key generation authority just

246
00:10:43,200 --> 00:10:46,079
generates policies deeper and sends the

247
00:10:46,079 --> 00:10:48,640
policy office to everyone

248
00:10:48,640 --> 00:10:51,120
and essentially ali is being honest

249
00:10:51,120 --> 00:10:53,360
whenever at least input something

250
00:10:53,360 --> 00:10:55,519
she writes something into her son

251
00:10:55,519 --> 00:10:56,959
converter

252
00:10:56,959 --> 00:10:58,640
and essentially this converter just

253
00:10:58,640 --> 00:11:01,040
takes alice's secret key takes her

254
00:11:01,040 --> 00:11:03,519
message and just generates a signature

255
00:11:03,519 --> 00:11:05,120
for this message and writes message

256
00:11:05,120 --> 00:11:07,839
signature to this insecure channel

257
00:11:07,839 --> 00:11:09,760
each of these bulbs here is also honest

258
00:11:09,760 --> 00:11:12,320
so they also run some converter

259
00:11:12,320 --> 00:11:14,000
which allows them to read from this

260
00:11:14,000 --> 00:11:16,320
insecure channel so essentially

261
00:11:16,320 --> 00:11:19,040
um well this converter will read from

262
00:11:19,040 --> 00:11:20,880
from this channel a message signature

263
00:11:20,880 --> 00:11:23,440
will verify if the message signature is

264
00:11:23,440 --> 00:11:25,519
valid and if it is then it will output

265
00:11:25,519 --> 00:11:28,079
the message to one of these words

266
00:11:28,079 --> 00:11:30,480
finally there is who only gets access to

267
00:11:30,480 --> 00:11:33,120
this public key of alice

268
00:11:33,120 --> 00:11:35,920
now let's consider what if uh here bob 3

269
00:11:35,920 --> 00:11:37,279
is dishonest

270
00:11:37,279 --> 00:11:39,440
so in this case if observation is honest

271
00:11:39,440 --> 00:11:42,480
it simply does not run a converter

272
00:11:42,480 --> 00:11:44,720
okay so about the ideal world

273
00:11:44,720 --> 00:11:47,440
essentially we have uh an authenticated

274
00:11:47,440 --> 00:11:50,079
channel which alice can write and from

275
00:11:50,079 --> 00:11:52,240
which program and votes you can read and

276
00:11:52,240 --> 00:11:54,560
then because if and both are dishonest

277
00:11:54,560 --> 00:11:56,720
they interact with some simulator

278
00:11:56,720 --> 00:11:59,279
which well since we only want to capture

279
00:11:59,279 --> 00:12:01,040
authenticity can only read from this

280
00:12:01,040 --> 00:12:04,880
authentic authenticated channel

281
00:12:05,200 --> 00:12:07,440
okay so this kind of notions are

282
00:12:07,440 --> 00:12:09,600
normally composable security notions

283
00:12:09,600 --> 00:12:10,959
just

284
00:12:10,959 --> 00:12:13,200
say what dishonest parties cannot

285
00:12:13,200 --> 00:12:15,680
achieve for example here both 3 and if

286
00:12:15,680 --> 00:12:17,440
cannot write into this authenticated

287
00:12:17,440 --> 00:12:18,560
channel

288
00:12:18,560 --> 00:12:19,839
however

289
00:12:19,839 --> 00:12:22,079
some security notions actually

290
00:12:22,079 --> 00:12:24,320
rely on giving guarantees to dishonest

291
00:12:24,320 --> 00:12:25,519
parties

292
00:12:25,519 --> 00:12:28,240
for example let's have a look at mdvs

293
00:12:28,240 --> 00:12:30,480
signatures or multi-designated verifier

294
00:12:30,480 --> 00:12:31,760
signatures

295
00:12:31,760 --> 00:12:33,839
so for this type of signatures alice can

296
00:12:33,839 --> 00:12:36,880
now designate a bunch of receivers

297
00:12:36,880 --> 00:12:39,440
and destination volkswagen three

298
00:12:39,440 --> 00:12:41,440
as the recipients of our messages and

299
00:12:41,440 --> 00:12:42,160
then

300
00:12:42,160 --> 00:12:43,040
uh

301
00:12:43,040 --> 00:12:45,279
authenticity is given exclusively to

302
00:12:45,279 --> 00:12:47,040
this box so

303
00:12:47,040 --> 00:12:48,959
only each of these bobs can actually

304
00:12:48,959 --> 00:12:51,360
learn that alice is sending a message

305
00:12:51,360 --> 00:12:53,279
this is called of the record in

306
00:12:53,279 --> 00:12:56,399
particular if cannot tell if alice is

307
00:12:56,399 --> 00:12:57,839
sending a message

308
00:12:57,839 --> 00:13:00,720
even if any subset like any one of these

309
00:13:00,720 --> 00:13:02,560
bots of these designated receivers is

310
00:13:02,560 --> 00:13:04,800
dishonest

311
00:13:04,800 --> 00:13:06,639
well how is this possible

312
00:13:06,639 --> 00:13:07,920
essentially

313
00:13:07,920 --> 00:13:10,480
any dishonest party can pretend that

314
00:13:10,480 --> 00:13:12,800
alice is sending some message and if you

315
00:13:12,800 --> 00:13:13,920
cannot tell

316
00:13:13,920 --> 00:13:15,920
the difference whether it's actually ali

317
00:13:15,920 --> 00:13:17,519
sending a message or someone else is

318
00:13:17,519 --> 00:13:20,000
pretending the police sending a message

319
00:13:20,000 --> 00:13:22,240
and this must hold even if

320
00:13:22,240 --> 00:13:25,120
eve knows all the secrets of any

321
00:13:25,120 --> 00:13:28,800
possibly dishonest receivers

322
00:13:29,279 --> 00:13:32,160
okay so now let's just have a look at a

323
00:13:32,160 --> 00:13:34,480
naive attempt to capture uh the the

324
00:13:34,480 --> 00:13:36,320
office in the of the record properties

325
00:13:36,320 --> 00:13:38,480
of mdvs

326
00:13:38,480 --> 00:13:39,600
so what

327
00:13:39,600 --> 00:13:41,760
would what what one would have is

328
00:13:41,760 --> 00:13:43,760
something like well let's consider the

329
00:13:43,760 --> 00:13:46,480
previous real world from before

330
00:13:46,480 --> 00:13:50,160
and now every everyone has actually a

331
00:13:50,160 --> 00:13:52,720
keeper so every bulb also has a keeper

332
00:13:52,720 --> 00:13:55,519
so here alice receives everyone's public

333
00:13:55,519 --> 00:13:57,120
key and each of these votes also

334
00:13:57,120 --> 00:13:59,440
receives everyone's public key

335
00:13:59,440 --> 00:14:01,920
also of course he also gets the quality

336
00:14:01,920 --> 00:14:04,639
of everyone and now each party also gets

337
00:14:04,639 --> 00:14:07,120
its own secret key

338
00:14:07,120 --> 00:14:10,160
what if now boxer is dishonest well now

339
00:14:10,160 --> 00:14:12,160
not only does not run a converter but

340
00:14:12,160 --> 00:14:15,279
its secret key will also leak weave

341
00:14:15,279 --> 00:14:18,560
so here it's just linked with

342
00:14:18,560 --> 00:14:20,800
okay what about the ideal world well we

343
00:14:20,800 --> 00:14:23,120
want to capture authenticity

344
00:14:23,120 --> 00:14:24,800
also after record but we want to capture

345
00:14:24,800 --> 00:14:27,600
authenticity so essentially we capture

346
00:14:27,600 --> 00:14:30,320
this by by uh authenticated channel

347
00:14:30,320 --> 00:14:32,000
which alice can write them from which

348
00:14:32,000 --> 00:14:34,160
bob1 and both two can read

349
00:14:34,160 --> 00:14:36,959
here the tc guaranteed it says that if

350
00:14:36,959 --> 00:14:39,199
bob1 are about to read then it was ali's

351
00:14:39,199 --> 00:14:40,240
writing

352
00:14:40,240 --> 00:14:41,920
so in particular this means that these

353
00:14:41,920 --> 00:14:43,839
bob3 cannot be allowed to write into

354
00:14:43,839 --> 00:14:46,160
this authenticated channel

355
00:14:46,160 --> 00:14:48,000
but but this is actually a problem

356
00:14:48,000 --> 00:14:50,399
because any informationable signature

357
00:14:50,399 --> 00:14:52,480
scheme like any normal signature scheme

358
00:14:52,480 --> 00:14:55,440
actually satisfies composable notion

359
00:14:55,440 --> 00:14:57,839
so this ideal world is actually

360
00:14:57,839 --> 00:15:00,160
capturing only authenticity and cannot

361
00:15:00,160 --> 00:15:02,000
capture off the record

362
00:15:02,000 --> 00:15:04,160
the catcher of the record eve would not

363
00:15:04,160 --> 00:15:06,399
be able to tell if alice sent a message

364
00:15:06,399 --> 00:15:09,120
or is if he is dishonest box 3 is

365
00:15:09,120 --> 00:15:10,639
pretending that alice is sending a

366
00:15:10,639 --> 00:15:12,720
message

367
00:15:12,720 --> 00:15:14,399
okay

368
00:15:14,399 --> 00:15:16,720
so the problem is how can we guarantee

369
00:15:16,720 --> 00:15:18,959
that these dishonest parties that is on

370
00:15:18,959 --> 00:15:20,079
this box

371
00:15:20,079 --> 00:15:22,240
can write or more generally how can we

372
00:15:22,240 --> 00:15:23,680
give

373
00:15:23,680 --> 00:15:26,000
dishonest parties capability how can we

374
00:15:26,000 --> 00:15:28,880
guarantee that they have some capability

375
00:15:28,880 --> 00:15:31,199
and our approach to this is by using the

376
00:15:31,199 --> 00:15:33,279
notion of specifications introduced by

377
00:15:33,279 --> 00:15:35,440
maru and runner

378
00:15:35,440 --> 00:15:37,600
essentially one specification capturing

379
00:15:37,600 --> 00:15:40,399
what dishonest parties cannot do as as

380
00:15:40,399 --> 00:15:42,720
usual so authenticity if bonus forward

381
00:15:42,720 --> 00:15:44,560
is a message in alaska

382
00:15:44,560 --> 00:15:47,519
and the other specification

383
00:15:47,519 --> 00:15:50,560
states what dishonest parties can do in

384
00:15:50,560 --> 00:15:52,639
this case dishonest parties can write

385
00:15:52,639 --> 00:15:53,519
too

386
00:15:53,519 --> 00:15:55,199
and then the ideal world is in

387
00:15:55,199 --> 00:15:58,079
intersection of these specifications

388
00:15:58,079 --> 00:16:01,040
okay so our contributions are

389
00:16:01,040 --> 00:16:03,440
we show how to give guarantees to

390
00:16:03,440 --> 00:16:05,040
dishonest parties in a compostable

391
00:16:05,040 --> 00:16:08,160
framework in constructive photography

392
00:16:08,160 --> 00:16:10,240
and in particular we give the first

393
00:16:10,240 --> 00:16:12,079
composable notions capturing the

394
00:16:12,079 --> 00:16:14,320
security of multi-designated rafar

395
00:16:14,320 --> 00:16:16,000
signature schemes

396
00:16:16,000 --> 00:16:19,040
finally we give a comparison against

397
00:16:19,040 --> 00:16:20,800
existing security notions capturing the

398
00:16:20,800 --> 00:16:22,720
security of mdps

399
00:16:22,720 --> 00:16:24,959
and we find that actually only recently

400
00:16:24,959 --> 00:16:27,440
the notions introduced by dunbar people

401
00:16:27,440 --> 00:16:30,480
actually captured the security of mdps

402
00:16:30,480 --> 00:16:32,560
still these notions are strictly

403
00:16:32,560 --> 00:16:36,000
stronger than our composable notions

404
00:16:36,000 --> 00:16:37,759
okay thank you for your attention this

405
00:16:37,759 --> 00:16:41,199
is all and thanks

406
00:16:42,320 --> 00:16:44,720
thank you

407
00:16:44,880 --> 00:16:49,199
um right now we don't have any questions

408
00:16:49,199 --> 00:16:53,279
on the zoom chat or the asia portal

409
00:16:53,440 --> 00:16:55,680
does anybody have any online questions

410
00:16:55,680 --> 00:16:59,560
right now that they want to ask

411
00:17:08,079 --> 00:17:10,240
i actually have one question that i was

412
00:17:10,240 --> 00:17:12,240
uh interested in so

413
00:17:12,240 --> 00:17:14,079
uh when you mentioned that there's like

414
00:17:14,079 --> 00:17:15,679
several several

415
00:17:15,679 --> 00:17:17,679
uh strengths of dbs like in the last

416
00:17:17,679 --> 00:17:19,119
slide uh

417
00:17:19,119 --> 00:17:21,039
does it constitute like in a practical

418
00:17:21,039 --> 00:17:23,439
attack or i'm not i don't know much

419
00:17:23,439 --> 00:17:26,400
about dvs so like it's is the security

420
00:17:26,400 --> 00:17:28,480
property like not well formed right now

421
00:17:28,480 --> 00:17:30,000
or

422
00:17:30,000 --> 00:17:32,640
how should we understand this of which

423
00:17:32,640 --> 00:17:35,600
one sorry i did not for the multi

424
00:17:35,600 --> 00:17:37,039
i would assume that there's a lot of

425
00:17:37,039 --> 00:17:41,360
definitions for mdvs yes yes

426
00:17:41,360 --> 00:17:43,840
yes so there are many definitions um

427
00:17:43,840 --> 00:17:45,840
there is one which is sufficient so

428
00:17:45,840 --> 00:17:47,840
there is dude one introduced by dungard

429
00:17:47,840 --> 00:17:50,000
is actually sufficient to capture the

430
00:17:50,000 --> 00:17:52,400
security of mdps to capture the

431
00:17:52,400 --> 00:17:54,160
well our composable notions and our

432
00:17:54,160 --> 00:17:56,080
composed versions just give like a

433
00:17:56,080 --> 00:17:58,160
natural application so i would say they

434
00:17:58,160 --> 00:17:58,880
are

435
00:17:58,880 --> 00:18:01,760
currently like sufficient sufficiently

436
00:18:01,760 --> 00:18:04,799
strong security notions uh but previous

437
00:18:04,799 --> 00:18:06,720
ones actually were not sufficiently

438
00:18:06,720 --> 00:18:08,400
strong

439
00:18:08,400 --> 00:18:10,080
can you like explain at a very high

440
00:18:10,080 --> 00:18:11,600
level like

441
00:18:11,600 --> 00:18:14,080
why it won't be you know sufficient in

442
00:18:14,080 --> 00:18:15,760
practice like those like previous

443
00:18:15,760 --> 00:18:17,840
definitions or is that a bit difficult

444
00:18:17,840 --> 00:18:18,960
to explain

445
00:18:18,960 --> 00:18:20,559
um

446
00:18:20,559 --> 00:18:22,000
there are many different reasons for

447
00:18:22,000 --> 00:18:23,919
which they are not sufficient i can give

448
00:18:23,919 --> 00:18:25,520
you one reason

449
00:18:25,520 --> 00:18:28,799
for example um

450
00:18:28,799 --> 00:18:30,640
for the case of multi-designated

451
00:18:30,640 --> 00:18:32,400
verifier signatures

452
00:18:32,400 --> 00:18:35,200
um there can be well multiple designated

453
00:18:35,200 --> 00:18:38,400
verifiers so uh one thing is

454
00:18:38,400 --> 00:18:40,320
any subset of these verifiers might be

455
00:18:40,320 --> 00:18:44,080
dishonest and most previous notions well

456
00:18:44,080 --> 00:18:45,840
only dumb guard actually introduced

457
00:18:45,840 --> 00:18:47,600
something called

458
00:18:47,600 --> 00:18:49,120
any subset of the record that

459
00:18:49,120 --> 00:18:50,720
essentially with these guarantees is

460
00:18:50,720 --> 00:18:53,039
that any subset of the dishonest

461
00:18:53,039 --> 00:18:55,440
verifiers can pretend that alice is

462
00:18:55,440 --> 00:18:57,280
sending something or

463
00:18:57,280 --> 00:18:59,520
in his terms it would be it would read

464
00:18:59,520 --> 00:19:02,720
as any subset of the dishonest verifiers

465
00:19:02,720 --> 00:19:05,760
can simulate uh can forge signatures

466
00:19:05,760 --> 00:19:07,520
that look like alice's

467
00:19:07,520 --> 00:19:08,480
and

468
00:19:08,480 --> 00:19:10,720
yeah this is just an example

469
00:19:10,720 --> 00:19:12,559
okay great um

470
00:19:12,559 --> 00:19:15,200
any other questions uh

471
00:19:15,200 --> 00:19:16,720
i don't see any so maybe we can come

472
00:19:16,720 --> 00:19:18,400
back later then

473
00:19:18,400 --> 00:19:20,880
okay thanks

474
00:19:20,880 --> 00:19:22,559
okay uh

475
00:19:22,559 --> 00:19:26,080
the next talk is uh how to build a

476
00:19:26,080 --> 00:19:28,400
trapdoor function from an encryption

477
00:19:28,400 --> 00:19:29,360
scheme

478
00:19:29,360 --> 00:19:31,039
by sanjeem gag

479
00:19:31,039 --> 00:19:32,960
mohammed hajjavadhi

480
00:19:32,960 --> 00:19:36,080
omar voter nahal ossofsky

481
00:19:36,080 --> 00:19:39,840
muhammad is going to speak

482
00:19:40,000 --> 00:19:42,720
all right thank you

483
00:19:42,960 --> 00:19:45,200
so

484
00:19:45,840 --> 00:19:47,600
let me start by

485
00:19:47,600 --> 00:19:49,360
reviewing the notion of chapter

486
00:19:49,360 --> 00:19:50,559
functions

487
00:19:50,559 --> 00:19:52,960
um the character functions are a family

488
00:19:52,960 --> 00:19:55,760
of injective functions where each

489
00:19:55,760 --> 00:19:57,440
function in the family

490
00:19:57,440 --> 00:19:59,679
can be computed in the forward direction

491
00:19:59,679 --> 00:20:02,240
using an index key and can also be

492
00:20:02,240 --> 00:20:04,320
efficiently inverted using the

493
00:20:04,320 --> 00:20:07,520
corresponding tractor key

494
00:20:07,520 --> 00:20:10,480
and we have one witness which says

495
00:20:10,480 --> 00:20:12,559
a randomly chosen function from the

496
00:20:12,559 --> 00:20:15,120
family should be one way

497
00:20:15,120 --> 00:20:18,959
in the absence of a trapdoor key

498
00:20:19,440 --> 00:20:23,280
um in our work we are interested in

499
00:20:23,280 --> 00:20:26,400
realizing notions of trap door functions

500
00:20:26,400 --> 00:20:28,960
in advanced settings such as

501
00:20:28,960 --> 00:20:29,919
in

502
00:20:29,919 --> 00:20:31,679
attribute-based encryption predicate

503
00:20:31,679 --> 00:20:35,840
encryption and identity-based encryption

504
00:20:35,919 --> 00:20:37,280
why do we care

505
00:20:37,280 --> 00:20:40,880
well because um these um tdf notions

506
00:20:40,880 --> 00:20:43,840
enable applications which are not known

507
00:20:43,840 --> 00:20:46,480
uh from their

508
00:20:46,480 --> 00:20:49,520
randomized variants um in particular we

509
00:20:49,520 --> 00:20:52,720
know how to build um designated verifier

510
00:20:52,720 --> 00:20:55,600
music for all mp from single key

511
00:20:55,600 --> 00:20:58,159
attribute based tdfs but we don't know

512
00:20:58,159 --> 00:21:01,520
how to do this from randomized abes or

513
00:21:01,520 --> 00:21:04,320
from chapter functions along

514
00:21:04,320 --> 00:21:07,760
also single key security is a fairly

515
00:21:07,760 --> 00:21:09,679
weak notion

516
00:21:09,679 --> 00:21:12,480
for abes because in the

517
00:21:12,480 --> 00:21:14,880
randomized setting it is equivalent to

518
00:21:14,880 --> 00:21:15,840
um

519
00:21:15,840 --> 00:21:19,200
cpa secure public encryption

520
00:21:19,200 --> 00:21:20,159
so

521
00:21:20,159 --> 00:21:22,080
if it turns out that uh trapdoor

522
00:21:22,080 --> 00:21:24,799
functions imply single key attribute

523
00:21:24,799 --> 00:21:26,240
based tdfs

524
00:21:26,240 --> 00:21:29,520
like uh in in the randomized setting

525
00:21:29,520 --> 00:21:31,840
then we can build designated verifier

526
00:21:31,840 --> 00:21:34,799
music for all mp from trapdoor functions

527
00:21:34,799 --> 00:21:37,520
which would generalize a recent result

528
00:21:37,520 --> 00:21:39,120
by

529
00:21:39,120 --> 00:21:42,719
hamburger copula and waters

530
00:21:43,360 --> 00:21:44,799
also these

531
00:21:44,799 --> 00:21:46,480
tdf notions allow us to build

532
00:21:46,480 --> 00:21:48,559
deterministic public encryption schemes

533
00:21:48,559 --> 00:21:52,240
in the attribute based setting

534
00:21:52,960 --> 00:21:56,320
our results in a nutshell

535
00:21:56,320 --> 00:21:59,760
are as follows we show how to build

536
00:21:59,760 --> 00:22:02,559
chapter functions uh in advanced

537
00:22:02,559 --> 00:22:04,400
settings from

538
00:22:04,400 --> 00:22:06,880
their randomized encryption

539
00:22:06,880 --> 00:22:09,760
counterparts by also

540
00:22:09,760 --> 00:22:12,480
using hinting prgs

541
00:22:12,480 --> 00:22:14,000
where

542
00:22:14,000 --> 00:22:16,720
where we require that uh the randomized

543
00:22:16,720 --> 00:22:19,039
encryption schemes to have pseudo-random

544
00:22:19,039 --> 00:22:21,760
ciphertexts

545
00:22:21,760 --> 00:22:23,840
the tdfs data we build

546
00:22:23,840 --> 00:22:26,400
however only provide selective security

547
00:22:26,400 --> 00:22:30,080
in the choice of the attributes

548
00:22:30,080 --> 00:22:33,280
as our second result we

549
00:22:33,280 --> 00:22:35,919
we introduce and build a notion that we

550
00:22:35,919 --> 00:22:38,080
call trapdoor garbling

551
00:22:38,080 --> 00:22:40,720
which is a global circuit where if the

552
00:22:40,720 --> 00:22:43,039
output of the circuit is a zero we will

553
00:22:43,039 --> 00:22:45,520
have simulation security in the

554
00:22:45,520 --> 00:22:48,400
standard sense for global circuits

555
00:22:48,400 --> 00:22:51,520
and if the output of the circuit is one

556
00:22:51,520 --> 00:22:55,039
then a garbled circ a garbled circuit

557
00:22:55,039 --> 00:22:57,919
evaluator will not only learn the output

558
00:22:57,919 --> 00:23:00,480
but will also learn all the randomness r

559
00:23:00,480 --> 00:23:02,080
that went into the creation of the

560
00:23:02,080 --> 00:23:06,639
garble circuit and the garbled labels

561
00:23:06,880 --> 00:23:09,520
we show how to build trapdoor garbling

562
00:23:09,520 --> 00:23:12,640
from ddh or lwe and how to use this

563
00:23:12,640 --> 00:23:13,600
notion

564
00:23:13,600 --> 00:23:16,559
to build adaptively secure single key

565
00:23:16,559 --> 00:23:20,480
attribute based tdfs

566
00:23:21,200 --> 00:23:23,360
there's also some

567
00:23:23,360 --> 00:23:25,919
prior work uh the work of kitagawa

568
00:23:25,919 --> 00:23:29,200
matsuda and tanaka shows how to build

569
00:23:29,200 --> 00:23:31,039
trapdoor functions

570
00:23:31,039 --> 00:23:32,320
in the

571
00:23:32,320 --> 00:23:33,760
standard setting

572
00:23:33,760 --> 00:23:36,480
um from a combination of cpa secure

573
00:23:36,480 --> 00:23:38,159
public encryption with uh pseudorandom

574
00:23:38,159 --> 00:23:40,400
ciphertexts and kdm secure private key

575
00:23:40,400 --> 00:23:42,720
encryption schemes

576
00:23:42,720 --> 00:23:44,960
even though they didn't explicitly prove

577
00:23:44,960 --> 00:23:47,039
it but it but it seems that their

578
00:23:47,039 --> 00:23:50,240
results should generalize uh to the abe

579
00:23:50,240 --> 00:23:51,200
setting

580
00:23:51,200 --> 00:23:53,200
this would be very similar to our first

581
00:23:53,200 --> 00:23:54,640
result but

582
00:23:54,640 --> 00:23:57,919
the new thing in our work is the notion

583
00:23:57,919 --> 00:23:59,919
of trapdoor garbling which we believe

584
00:23:59,919 --> 00:24:01,039
might have

585
00:24:01,039 --> 00:24:02,720
further

586
00:24:02,720 --> 00:24:04,640
um

587
00:24:04,640 --> 00:24:07,120
applications

588
00:24:07,120 --> 00:24:08,320
so

589
00:24:08,320 --> 00:24:10,640
let me conclude uh the most interesting

590
00:24:10,640 --> 00:24:13,039
open problem here would be to build a

591
00:24:13,039 --> 00:24:15,360
single key attribute based trapdoor

592
00:24:15,360 --> 00:24:18,720
functions from trapdoor functions and if

593
00:24:18,720 --> 00:24:21,120
this question turns out to be difficult

594
00:24:21,120 --> 00:24:23,600
one can look at whether there exists

595
00:24:23,600 --> 00:24:25,200
some kind of separations between these

596
00:24:25,200 --> 00:24:27,840
two notions or whether we can possibly

597
00:24:27,840 --> 00:24:30,880
build weaker notions such as designated

598
00:24:30,880 --> 00:24:34,480
verifier nizik from trapdoor functions

599
00:24:34,480 --> 00:24:36,799
and uh that's all

600
00:24:36,799 --> 00:24:39,760
i have to say thank you

601
00:24:40,000 --> 00:24:42,320
thank you

602
00:24:44,400 --> 00:24:47,039
so there's one question on zoom i'll

603
00:24:47,039 --> 00:24:49,919
read it out and uh

604
00:24:49,919 --> 00:24:52,159
mccoy sorry if i'm mispronouncing uh

605
00:24:52,159 --> 00:24:55,120
mccoy is asking is the deviant uh smooth

606
00:24:55,120 --> 00:24:58,640
projective hash function in this case

607
00:24:58,640 --> 00:25:01,640
uh

608
00:25:02,159 --> 00:25:04,080
i'm not sure what that question

609
00:25:04,080 --> 00:25:05,760
what that question means can you

610
00:25:05,760 --> 00:25:07,520
elaborate what do you mean by yes uh

611
00:25:07,520 --> 00:25:09,120
earlier on you were talking about

612
00:25:09,120 --> 00:25:12,400
building uh designated verifier and icks

613
00:25:12,400 --> 00:25:14,480
i was curious if in that situation they

614
00:25:14,480 --> 00:25:17,039
were specifically an instantiation of a

615
00:25:17,039 --> 00:25:20,240
smooth projective hash function

616
00:25:21,200 --> 00:25:22,799
right so

617
00:25:22,799 --> 00:25:23,600
uh

618
00:25:23,600 --> 00:25:26,559
so the thing is

619
00:25:26,840 --> 00:25:29,360
um so are you asking whether these

620
00:25:29,360 --> 00:25:30,960
notions

621
00:25:30,960 --> 00:25:34,240
are equivalent uh yes

622
00:25:34,240 --> 00:25:35,200
and

623
00:25:35,200 --> 00:25:37,120
i'm not sure that's how these notions

624
00:25:37,120 --> 00:25:40,520
are equally balanced

625
00:25:43,520 --> 00:25:46,559
because um when we think about uh

626
00:25:46,559 --> 00:25:48,960
projective hash functions in the sense

627
00:25:48,960 --> 00:25:50,880
of um

628
00:25:50,880 --> 00:25:54,640
shoot then we require two modes they

629
00:25:54,640 --> 00:25:55,600
should be

630
00:25:55,600 --> 00:25:57,919
indistinguishable

631
00:25:57,919 --> 00:26:00,840
and uh we are kind of hoping that uh

632
00:26:00,840 --> 00:26:03,760
diviniska can be built

633
00:26:03,760 --> 00:26:05,120
from

634
00:26:05,120 --> 00:26:07,919
generic assumptions like uh

635
00:26:07,919 --> 00:26:10,480
trapdoor functions and so it's

636
00:26:10,480 --> 00:26:12,159
it's kind of hard

637
00:26:12,159 --> 00:26:14,960
uh to imagine how we can build such hash

638
00:26:14,960 --> 00:26:17,440
functions from generic primitives such

639
00:26:17,440 --> 00:26:18,960
as

640
00:26:18,960 --> 00:26:21,360
trapdoor functions

641
00:26:21,360 --> 00:26:24,840
okay thank you

642
00:26:27,200 --> 00:26:30,320
any other questions

643
00:26:33,520 --> 00:26:36,480
um if not i guess we could move on to

644
00:26:36,480 --> 00:26:40,320
the next speaker and come back later

645
00:26:40,640 --> 00:26:41,679
okay

646
00:26:41,679 --> 00:26:43,520
the next talk is

647
00:26:43,520 --> 00:26:46,080
beyond software watermarking trade

648
00:26:46,080 --> 00:26:48,880
addressing for student random functions

649
00:26:48,880 --> 00:26:52,960
by richard coyle some

650
00:26:57,360 --> 00:27:00,400
you can see the slides right rio

651
00:27:00,400 --> 00:27:01,520
yes

652
00:27:01,520 --> 00:27:03,600
perfect okay thanks a lot for the

653
00:27:03,600 --> 00:27:05,360
introduction and today i'll tell you how

654
00:27:05,360 --> 00:27:07,600
to trace pseudonym functions

655
00:27:07,600 --> 00:27:09,760
that helps us going beyond the perceived

656
00:27:09,760 --> 00:27:12,320
boundaries of software water market

657
00:27:12,320 --> 00:27:14,320
so as probably most of us have already

658
00:27:14,320 --> 00:27:16,080
seen or at least in this audience

659
00:27:16,080 --> 00:27:17,600
physical water marks they're prevalent

660
00:27:17,600 --> 00:27:19,360
everywhere what is software for water

661
00:27:19,360 --> 00:27:20,960
marketing software watermarking is just

662
00:27:20,960 --> 00:27:24,159
like uh is a is a software analog of

663
00:27:24,159 --> 00:27:26,240
physical watermarking where the point is

664
00:27:26,240 --> 00:27:28,240
you have a computer program and you want

665
00:27:28,240 --> 00:27:30,640
to embed uh information inside those

666
00:27:30,640 --> 00:27:33,039
computer programs such that anybody who

667
00:27:33,039 --> 00:27:34,159
tries to remove that particular

668
00:27:34,159 --> 00:27:37,039
watermark or this mark of crypto should

669
00:27:37,039 --> 00:27:38,799
also destroy the functionality of the

670
00:27:38,799 --> 00:27:40,960
program

671
00:27:40,960 --> 00:27:43,520
now watermarking is has had a tremendous

672
00:27:43,520 --> 00:27:45,279
amount of application since its

673
00:27:45,279 --> 00:27:47,919
development and the abstractly

674
00:27:47,919 --> 00:27:49,520
watermarking can be defined via two

675
00:27:49,520 --> 00:27:50,799
algorithms

676
00:27:50,799 --> 00:27:52,640
the marking and the extraction algorithm

677
00:27:52,640 --> 00:27:54,720
with the watermarking algorithm takes a

678
00:27:54,720 --> 00:27:56,720
circuit or a program description and a

679
00:27:56,720 --> 00:27:59,679
watermark value m and it gives you a

680
00:27:59,679 --> 00:28:01,039
watermark version of the particular

681
00:28:01,039 --> 00:28:02,480
circular program

682
00:28:02,480 --> 00:28:04,320
and we also have an extraction algorithm

683
00:28:04,320 --> 00:28:06,240
that takes input a particular circuit

684
00:28:06,240 --> 00:28:07,919
which could be watermark and tries to

685
00:28:07,919 --> 00:28:10,000
extract that watermark from that circuit

686
00:28:10,000 --> 00:28:12,559
as long as that circuit was not

687
00:28:12,559 --> 00:28:13,840
destroyed by

688
00:28:13,840 --> 00:28:17,080
the adversary

689
00:28:17,120 --> 00:28:18,000
now

690
00:28:18,000 --> 00:28:19,440
watermarking

691
00:28:19,440 --> 00:28:21,520
has two important guarantees that it

692
00:28:21,520 --> 00:28:22,640
provides first is called the

693
00:28:22,640 --> 00:28:24,320
functionality preserving it says if you

694
00:28:24,320 --> 00:28:26,080
start with the computer program and you

695
00:28:26,080 --> 00:28:28,799
try to watermark it by any particular

696
00:28:28,799 --> 00:28:30,159
message m then in that case the

697
00:28:30,159 --> 00:28:31,520
watermark program should also be

698
00:28:31,520 --> 00:28:32,880
functionally similar or functionally

699
00:28:32,880 --> 00:28:34,880
identical to the initial program it

700
00:28:34,880 --> 00:28:36,000
should preserve the functionality

701
00:28:36,000 --> 00:28:37,360
because if it doesn't preserve the

702
00:28:37,360 --> 00:28:39,919
functionality then it's not very useful

703
00:28:39,919 --> 00:28:40,960
in order to watermark because you're

704
00:28:40,960 --> 00:28:42,720
destroying the functionality but the

705
00:28:42,720 --> 00:28:44,000
more interesting property for

706
00:28:44,000 --> 00:28:45,360
watermarking is called the

707
00:28:45,360 --> 00:28:47,120
unremovability guarantee which is the

708
00:28:47,120 --> 00:28:49,039
security property here which basically

709
00:28:49,039 --> 00:28:51,520
says if an adversary given a watermark

710
00:28:51,520 --> 00:28:53,440
program tries to remove this particular

711
00:28:53,440 --> 00:28:55,279
watermark should also destroy the

712
00:28:55,279 --> 00:28:57,440
functionality of the program that means

713
00:28:57,440 --> 00:28:58,799
the university should not be able to

714
00:28:58,799 --> 00:29:01,200
compute a a

715
00:29:01,200 --> 00:29:03,440
circuit which does not have the

716
00:29:03,440 --> 00:29:06,080
watermark but is very similar to the

717
00:29:06,080 --> 00:29:08,159
initial program at least functionally

718
00:29:08,159 --> 00:29:10,559
similar

719
00:29:10,880 --> 00:29:12,880
software water marketing though is

720
00:29:12,880 --> 00:29:14,720
tremendous it can as you can see it can

721
00:29:14,720 --> 00:29:16,320
only be achieved for functions that are

722
00:29:16,320 --> 00:29:17,760
not learnable because if a function was

723
00:29:17,760 --> 00:29:19,200
learnable in that case the adversary

724
00:29:19,200 --> 00:29:20,880
will learn the function simply create or

725
00:29:20,880 --> 00:29:22,880
create a totally new function uh for

726
00:29:22,880 --> 00:29:25,039
that particular value so in order to do

727
00:29:25,039 --> 00:29:27,200
that uh watermarking has been widely

728
00:29:27,200 --> 00:29:28,880
studied for cryptographic programs

729
00:29:28,880 --> 00:29:30,480
because they are believed to be widely

730
00:29:30,480 --> 00:29:32,799
unlearnable and a bunch of work has

731
00:29:32,799 --> 00:29:34,559
followed in trying to study the notion

732
00:29:34,559 --> 00:29:36,159
of watermarking pseudorandom functions

733
00:29:36,159 --> 00:29:37,440
which is one of the most fundamental

734
00:29:37,440 --> 00:29:40,000
objects in typography so in watermarking

735
00:29:40,000 --> 00:29:42,000
brs you start with the prf key that is

736
00:29:42,000 --> 00:29:43,679
embedded inside a program that simply

737
00:29:43,679 --> 00:29:45,679
evaluates the surround function and try

738
00:29:45,679 --> 00:29:47,440
to watermark it and try to embed a

739
00:29:47,440 --> 00:29:49,919
particular information in so that it it

740
00:29:49,919 --> 00:29:51,440
prevents unauthorized sharing of that

741
00:29:51,440 --> 00:29:53,840
super random

742
00:29:53,840 --> 00:29:56,000
now let us look a little more closely at

743
00:29:56,000 --> 00:29:57,360
the water marking security property

744
00:29:57,360 --> 00:29:59,679
again so if you recall the unremovable

745
00:29:59,679 --> 00:30:02,080
security property says that the circuit

746
00:30:02,080 --> 00:30:04,480
must be the watermark circuit

747
00:30:04,480 --> 00:30:06,320
should be very similar to the circuit

748
00:30:06,320 --> 00:30:08,880
that the adversary generated so suppose

749
00:30:08,880 --> 00:30:10,240
i give you a watermark circuit for this

750
00:30:10,240 --> 00:30:13,039
par function and now as an adversary i

751
00:30:13,039 --> 00:30:16,320
create a following program my program

752
00:30:16,320 --> 00:30:18,559
is now only going to output the first n

753
00:30:18,559 --> 00:30:20,559
by 4 bits of this particular prf and

754
00:30:20,559 --> 00:30:22,480
nothing more

755
00:30:22,480 --> 00:30:25,120
now it turns out this particular program

756
00:30:25,120 --> 00:30:28,320
is not a valid program as per the

757
00:30:28,320 --> 00:30:29,760
unremovable guarantee that we have

758
00:30:29,760 --> 00:30:30,960
currently because the current

759
00:30:30,960 --> 00:30:32,720
unremovability guarantees what mark you

760
00:30:32,720 --> 00:30:34,880
say that the circuit that the adversary

761
00:30:34,880 --> 00:30:36,320
creates and the circuit that you started

762
00:30:36,320 --> 00:30:38,159
with they must be some identical

763
00:30:38,159 --> 00:30:40,480
function identical on almost all inputs

764
00:30:40,480 --> 00:30:41,600
okay

765
00:30:41,600 --> 00:30:43,440
we are not identical at all we are only

766
00:30:43,440 --> 00:30:45,039
identical in the first and by four bits

767
00:30:45,039 --> 00:30:47,600
but not at all so it seems like uh this

768
00:30:47,600 --> 00:30:49,760
particular program is not you can't

769
00:30:49,760 --> 00:30:51,200
prevent security against these

770
00:30:51,200 --> 00:30:52,720
particular attackers there's no

771
00:30:52,720 --> 00:30:54,640
guarantees but the mark is preserved or

772
00:30:54,640 --> 00:30:57,919
not once you sort of create it in a bank

773
00:30:57,919 --> 00:31:00,559
and it turns out a lot of or maybe all

774
00:31:00,559 --> 00:31:02,000
the existing water market constructions

775
00:31:02,000 --> 00:31:03,840
are unable to recover the watermark from

776
00:31:03,840 --> 00:31:06,080
this type of program if you sort of uh

777
00:31:06,080 --> 00:31:08,320
carry out this type of attack

778
00:31:08,320 --> 00:31:09,360
at this point you might be wondering

779
00:31:09,360 --> 00:31:11,519
okay maybe these attacks cannot be

780
00:31:11,519 --> 00:31:13,039
preventing they're using watermarking

781
00:31:13,039 --> 00:31:15,039
but are they actually meaningful can

782
00:31:15,039 --> 00:31:17,200
these attacks happen in practice

783
00:31:17,200 --> 00:31:18,799
so then let me explain a very simple

784
00:31:18,799 --> 00:31:21,039
example to you of our simple application

785
00:31:21,039 --> 00:31:22,640
of water marking prf suppose the water

786
00:31:22,640 --> 00:31:24,480
markable prf is used to protect

787
00:31:24,480 --> 00:31:25,919
unauthorized distribution of decryption

788
00:31:25,919 --> 00:31:27,440
keys because a prc could be used as a

789
00:31:27,440 --> 00:31:28,799
decryption key

790
00:31:28,799 --> 00:31:30,399
then the point is that the adversaries

791
00:31:30,399 --> 00:31:32,399
program if it is only good enough to

792
00:31:32,399 --> 00:31:36,240
break the application of decryption

793
00:31:36,240 --> 00:31:37,120
that

794
00:31:37,120 --> 00:31:38,720
can be done using this partial

795
00:31:38,720 --> 00:31:40,480
information about the prf key but it

796
00:31:40,480 --> 00:31:42,240
might not preserve water marking for

797
00:31:42,240 --> 00:31:43,919
example in this particular case if we

798
00:31:43,919 --> 00:31:46,159
use the prs key to encrypt the image and

799
00:31:46,159 --> 00:31:47,919
i use this particular program on the

800
00:31:47,919 --> 00:31:49,679
left side which only outputs the first

801
00:31:49,679 --> 00:31:51,840
the leading n by four bits then i can

802
00:31:51,840 --> 00:31:53,840
actually use this particular program to

803
00:31:53,840 --> 00:31:55,840
partially decrypt the underlying message

804
00:31:55,840 --> 00:31:57,120
and that will give me a lot of

805
00:31:57,120 --> 00:31:59,600
information about the underlying message

806
00:31:59,600 --> 00:32:01,120
so basically the point here is that for

807
00:32:01,120 --> 00:32:02,559
building blocks like prfs we don't

808
00:32:02,559 --> 00:32:03,919
necessarily need to

809
00:32:03,919 --> 00:32:06,080
recover the output precisely to break

810
00:32:06,080 --> 00:32:08,159
the functionality of prs

811
00:32:08,159 --> 00:32:09,919
and the larger point here is that

812
00:32:09,919 --> 00:32:11,760
typically in photography the adversary's

813
00:32:11,760 --> 00:32:12,960
goals and honest party schools are

814
00:32:12,960 --> 00:32:15,279
separate for honest parties you want

815
00:32:15,279 --> 00:32:16,720
that correctness should always hold you

816
00:32:16,720 --> 00:32:18,159
should be always be able to recover

817
00:32:18,159 --> 00:32:19,840
everything about the ciphertext in uh

818
00:32:19,840 --> 00:32:21,440
from the subjects about a message if

819
00:32:21,440 --> 00:32:22,960
you're talking about encryption but for

820
00:32:22,960 --> 00:32:24,559
security require you should not be able

821
00:32:24,559 --> 00:32:26,240
to learn anything from the self text

822
00:32:26,240 --> 00:32:27,360
nothing

823
00:32:27,360 --> 00:32:29,600
and that's a really large gap everything

824
00:32:29,600 --> 00:32:31,600
versus nothing

825
00:32:31,600 --> 00:32:33,600
now to that end in water marking

826
00:32:33,600 --> 00:32:35,360
cryptographic programs typically when we

827
00:32:35,360 --> 00:32:37,600
have started them so far we have studied

828
00:32:37,600 --> 00:32:39,360
exact functionality preserving for water

829
00:32:39,360 --> 00:32:41,279
marking schemes but it does not seem to

830
00:32:41,279 --> 00:32:42,960
be the right security notion if you want

831
00:32:42,960 --> 00:32:45,279
to get all possible applications

832
00:32:45,279 --> 00:32:46,640
and basically what happens is that the

833
00:32:46,640 --> 00:32:48,320
adversaries program might break the

834
00:32:48,320 --> 00:32:49,519
primitive

835
00:32:49,519 --> 00:32:51,760
but the watermark

836
00:32:51,760 --> 00:32:53,519
just uh it might it should happen the

837
00:32:53,519 --> 00:32:55,200
watermark should still be preserved

838
00:32:55,200 --> 00:32:56,640
whenever you break the perimeter it

839
00:32:56,640 --> 00:32:59,760
should not be the case that you only

840
00:32:59,760 --> 00:33:01,360
preserve the watermark when you're sort

841
00:33:01,360 --> 00:33:04,559
of almost similar to the initial program

842
00:33:04,559 --> 00:33:05,760
and to that and we introduced the

843
00:33:05,760 --> 00:33:07,679
concept of traceable pseudonym functions

844
00:33:07,679 --> 00:33:10,320
in this work and traceable pseudonym

845
00:33:10,320 --> 00:33:12,640
functions are aimed to fill this gap but

846
00:33:12,640 --> 00:33:14,880
the idea is that now the marking

847
00:33:14,880 --> 00:33:16,799
security or the unremovable security for

848
00:33:16,799 --> 00:33:17,760
the

849
00:33:17,760 --> 00:33:19,760
for the scheme is going to say if an

850
00:33:19,760 --> 00:33:22,399
adversary creates a program c

851
00:33:22,399 --> 00:33:24,799
that can distinguish the prf from random

852
00:33:24,799 --> 00:33:26,000
values can actually carry out a

853
00:33:26,000 --> 00:33:27,600
distinguishing attack

854
00:33:27,600 --> 00:33:29,120
then watermark can

855
00:33:29,120 --> 00:33:30,880
be extracted then the watermark should

856
00:33:30,880 --> 00:33:32,080
be preserved

857
00:33:32,080 --> 00:33:34,000
so rather than saying that the circuit

858
00:33:34,000 --> 00:33:35,519
see that the adversary creates is

859
00:33:35,519 --> 00:33:37,279
functionally almost similar to the

860
00:33:37,279 --> 00:33:38,480
initial program

861
00:33:38,480 --> 00:33:40,080
if it can be used to just perform a

862
00:33:40,080 --> 00:33:41,760
distinguishing attack then you should be

863
00:33:41,760 --> 00:33:43,760
able to extract watermark so it's a

864
00:33:43,760 --> 00:33:45,600
strengthening and trying to capture that

865
00:33:45,600 --> 00:33:47,440
even previous attack i showed to you in

866
00:33:47,440 --> 00:33:50,159
which we had only n by four of the bits

867
00:33:50,159 --> 00:33:52,720
that particular attackers can also be

868
00:33:52,720 --> 00:33:56,240
traced or can also be extracted

869
00:33:56,240 --> 00:33:58,880
and the analog basically the traceable

870
00:33:58,880 --> 00:34:00,399
pseudonym functions are an analog of the

871
00:34:00,399 --> 00:34:02,000
trader tracing systems which are

872
00:34:02,000 --> 00:34:03,519
encryption systems which have these

873
00:34:03,519 --> 00:34:05,679
tracing guarantees which basically say

874
00:34:05,679 --> 00:34:07,679
if you have a decoder that can decrypt

875
00:34:07,679 --> 00:34:09,440
subtext then i can from that decoder

876
00:34:09,440 --> 00:34:10,960
extract the information about the user

877
00:34:10,960 --> 00:34:13,199
secret keys and we basically are using

878
00:34:13,199 --> 00:34:15,839
the analog of uh trader tracing for

879
00:34:15,839 --> 00:34:17,040
pseudo random functions as well a

880
00:34:17,040 --> 00:34:20,599
symmetric key object

881
00:34:20,639 --> 00:34:23,040
just summarizing in this work we propose

882
00:34:23,040 --> 00:34:24,560
the concept of traceable pseudonym

883
00:34:24,560 --> 00:34:26,399
functions as a means to

884
00:34:26,399 --> 00:34:28,560
close this gap and possibly go for

885
00:34:28,560 --> 00:34:30,159
better definitions for water markings

886
00:34:30,159 --> 00:34:31,760
that can provide uh security from a

887
00:34:31,760 --> 00:34:34,000
wider a variety of attacks and we

888
00:34:34,000 --> 00:34:36,159
provide new results where we give a

889
00:34:36,159 --> 00:34:38,719
single key traceables uh prf in the

890
00:34:38,719 --> 00:34:40,639
secret key setting with security under

891
00:34:40,639 --> 00:34:41,839
the learning with that assumption and we

892
00:34:41,839 --> 00:34:43,839
also show if you assume distinguishably

893
00:34:43,839 --> 00:34:45,839
opposition then you can get all the best

894
00:34:45,839 --> 00:34:47,280
properties fully collusion resistant

895
00:34:47,280 --> 00:34:49,199
public tracing and everything

896
00:34:49,199 --> 00:34:50,879
now in the interest of time i won't tell

897
00:34:50,879 --> 00:34:52,480
you how to actually build it but just

898
00:34:52,480 --> 00:34:54,719
let me quickly mention that the higher

899
00:34:54,719 --> 00:34:56,879
level picture of building traceable prfs

900
00:34:56,879 --> 00:34:58,400
is similar to the story that has been

901
00:34:58,400 --> 00:35:00,800
carried for over i would say a decade

902
00:35:00,800 --> 00:35:02,480
and a half for traitor tracing where we

903
00:35:02,480 --> 00:35:04,480
started with uh something called private

904
00:35:04,480 --> 00:35:06,079
linear broadcast encryption which was a

905
00:35:06,079 --> 00:35:07,760
restricted notion of encryption and that

906
00:35:07,760 --> 00:35:09,599
gave us trader tracing here we rely on

907
00:35:09,599 --> 00:35:11,119
something that we call private linear

908
00:35:11,119 --> 00:35:13,359
constrained prefs that's the relaxation

909
00:35:13,359 --> 00:35:15,200
of constrained proofs and we show how to

910
00:35:15,200 --> 00:35:18,480
use that to perform traceability in prfs

911
00:35:18,480 --> 00:35:20,640
so just trying to summarize again uh in

912
00:35:20,640 --> 00:35:22,160
this work we propose a new

913
00:35:22,160 --> 00:35:23,440
unremovability guarantee for

914
00:35:23,440 --> 00:35:25,040
pseudo-random functions which says as

915
00:35:25,040 --> 00:35:27,119
long as the program can distinguish prf

916
00:35:27,119 --> 00:35:29,119
outputs

917
00:35:29,119 --> 00:35:31,119
then it should preserve the water

918
00:35:31,119 --> 00:35:32,720
marking in certain sensors we should be

919
00:35:32,720 --> 00:35:34,240
able to extract it

920
00:35:34,240 --> 00:35:36,000
and more generally what we're trying to

921
00:35:36,000 --> 00:35:38,000
claim is that in cryptography trying to

922
00:35:38,000 --> 00:35:40,000
watermark cryptographic functions we

923
00:35:40,000 --> 00:35:41,839
should not always tie functionality

924
00:35:41,839 --> 00:35:44,160
preserving to input output preservation

925
00:35:44,160 --> 00:35:45,680
functionality preserving for

926
00:35:45,680 --> 00:35:46,960
cryptographic functions when you have to

927
00:35:46,960 --> 00:35:48,720
extract something should be tied

928
00:35:48,720 --> 00:35:51,359
together to the security property or to

929
00:35:51,359 --> 00:35:53,440
the security of the underlying system

930
00:35:53,440 --> 00:35:54,720
and with that i would like to conclude

931
00:35:54,720 --> 00:35:58,520
and thanks for listening

932
00:35:59,359 --> 00:36:01,440
thank you

933
00:36:01,440 --> 00:36:04,880
um are there any questions

934
00:36:04,880 --> 00:36:07,839
so we don't currently have any on zoom

935
00:36:07,839 --> 00:36:12,800
or the azure portal site um if not i had

936
00:36:12,800 --> 00:36:16,720
one question or it might be two uh so

937
00:36:16,720 --> 00:36:18,800
this was a really interesting talk and i

938
00:36:18,800 --> 00:36:19,839
was

939
00:36:19,839 --> 00:36:21,680
um

940
00:36:21,680 --> 00:36:24,720
what i wanted to ask is so usually i

941
00:36:24,720 --> 00:36:26,160
don't know much about water marking but

942
00:36:26,160 --> 00:36:28,160
usually uh when i hear about water

943
00:36:28,160 --> 00:36:30,720
marking it's mainly about prfs and it's

944
00:36:30,720 --> 00:36:32,640
not because you know we can use prfs to

945
00:36:32,640 --> 00:36:35,440
construct signatures description keys is

946
00:36:35,440 --> 00:36:36,720
that like the

947
00:36:36,720 --> 00:36:38,560
main target or are there other

948
00:36:38,560 --> 00:36:40,560
primitives that we want to watermark

949
00:36:40,560 --> 00:36:41,839
which we can't

950
00:36:41,839 --> 00:36:45,040
do from prfs right now

951
00:36:45,040 --> 00:36:46,640
so the quest

952
00:36:46,640 --> 00:36:48,560
so do one of the reasons and i guess

953
00:36:48,560 --> 00:36:50,400
even real would be a good person to also

954
00:36:50,400 --> 00:36:51,760
answer that's a real feel free to chip

955
00:36:51,760 --> 00:36:52,480
in

956
00:36:52,480 --> 00:36:54,720
if you feel my answer is insufficient

957
00:36:54,720 --> 00:36:57,440
but the main reason why prfs has been

958
00:36:57,440 --> 00:36:58,960
started so far for watermarking is that

959
00:36:58,960 --> 00:37:01,359
watermarking is

960
00:37:01,359 --> 00:37:03,359
it's uh it's an advanced property to

961
00:37:03,359 --> 00:37:04,240
have

962
00:37:04,240 --> 00:37:06,640
it's not easy to prove uh watermarking

963
00:37:06,640 --> 00:37:08,640
security for cryptographic functions

964
00:37:08,640 --> 00:37:10,000
so the research started with the

965
00:37:10,000 --> 00:37:12,160
simplest possible object which was

966
00:37:12,160 --> 00:37:13,440
suited random function because the most

967
00:37:13,440 --> 00:37:15,839
fundamental object in cryptography and

968
00:37:15,839 --> 00:37:17,599
absolutely the question is that can we

969
00:37:17,599 --> 00:37:19,680
try to watermark more interesting types

970
00:37:19,680 --> 00:37:21,359
of functionalities and initially people

971
00:37:21,359 --> 00:37:23,119
believe that maybe if you go higher then

972
00:37:23,119 --> 00:37:24,880
you must it must get harder than student

973
00:37:24,880 --> 00:37:27,119
random functions although it's not

974
00:37:27,119 --> 00:37:28,400
unclear right now because for some

975
00:37:28,400 --> 00:37:30,079
advanced functions it's easier to

976
00:37:30,079 --> 00:37:31,680
watermark those particular functions

977
00:37:31,680 --> 00:37:33,280
like public key functions rather than

978
00:37:33,280 --> 00:37:35,520
secret key functions but initially when

979
00:37:35,520 --> 00:37:37,280
we when the reset started was mostly

980
00:37:37,280 --> 00:37:39,280
focused on prfs from the perspective

981
00:37:39,280 --> 00:37:41,680
trying to get feasible results where we

982
00:37:41,680 --> 00:37:44,240
had no feasible results so far and in

983
00:37:44,240 --> 00:37:46,160
the last i would say five years we've

984
00:37:46,160 --> 00:37:47,359
seen a lot of feasible results of

985
00:37:47,359 --> 00:37:49,280
watermarking prfs and that has opened

986
00:37:49,280 --> 00:37:50,720
what are the cryptographic functions we

987
00:37:50,720 --> 00:37:53,359
can watermark so the jury is still out

988
00:37:53,359 --> 00:37:55,520
there that what is the maximum class of

989
00:37:55,520 --> 00:37:57,200
function that we can watermark it

990
00:37:57,200 --> 00:37:59,440
typically depends as you said

991
00:37:59,440 --> 00:38:01,119
it depends upon the applications we can

992
00:38:01,119 --> 00:38:02,800
you can also always try to ask questions

993
00:38:02,800 --> 00:38:04,160
about watermarking different different

994
00:38:04,160 --> 00:38:06,000
things but there must be an application

995
00:38:06,000 --> 00:38:08,000
in mind that you should sort of focus in

996
00:38:08,000 --> 00:38:10,400
on and then maybe look at watermarking

997
00:38:10,400 --> 00:38:11,599
that particular functionality i'm not

998
00:38:11,599 --> 00:38:12,880
sure if that completely answers the

999
00:38:12,880 --> 00:38:15,040
question or not it does thank you yeah

1000
00:38:15,040 --> 00:38:17,200
so i guess like if we find like another

1001
00:38:17,200 --> 00:38:18,880
perimeter that we want to watermark then

1002
00:38:18,880 --> 00:38:20,720
at that point there's going to be a

1003
00:38:20,720 --> 00:38:22,640
question like can we make that traceable

1004
00:38:22,640 --> 00:38:24,320
in this setting that you expect

1005
00:38:24,320 --> 00:38:25,680
absolutely absolutely absolutely

1006
00:38:25,680 --> 00:38:28,400
absolutely absolutely yes yes great

1007
00:38:28,400 --> 00:38:32,440
are there any other questions

1008
00:38:33,839 --> 00:38:35,920
if not i guess we can move on to the

1009
00:38:35,920 --> 00:38:38,640
next talk

1010
00:38:38,640 --> 00:38:39,599
okay

1011
00:38:39,599 --> 00:38:40,560
uh

1012
00:38:40,560 --> 00:38:43,280
the next stock is

1013
00:38:43,280 --> 00:38:47,119
patching base of radius transfers by jan

1014
00:38:47,119 --> 00:38:49,359
mccoy michael jose

1015
00:38:49,359 --> 00:38:51,119
lawrence roy

1016
00:38:51,119 --> 00:38:55,160
ian is going to speak

1017
00:39:08,880 --> 00:39:11,119
yeah maybe you're muting

1018
00:39:11,119 --> 00:39:15,200
oh okay uh thank you um let's get right

1019
00:39:15,200 --> 00:39:17,680
to it then so uh oblivious transfers

1020
00:39:17,680 --> 00:39:19,920
what are they so in a very general sense

1021
00:39:19,920 --> 00:39:22,560
oblivious transfer is a protocol um

1022
00:39:22,560 --> 00:39:24,880
between two parties where one party

1023
00:39:24,880 --> 00:39:27,119
receives two messages another party

1024
00:39:27,119 --> 00:39:29,040
inputs a bit and receives one of those

1025
00:39:29,040 --> 00:39:32,640
messages corresponding to that bit

1026
00:39:32,720 --> 00:39:34,800
specifically when we're looking at the

1027
00:39:34,800 --> 00:39:36,720
security properties of these protocols

1028
00:39:36,720 --> 00:39:39,359
and in specifically uh uniform oblivious

1029
00:39:39,359 --> 00:39:40,400
transfer

1030
00:39:40,400 --> 00:39:42,240
we have that the receiver the one

1031
00:39:42,240 --> 00:39:43,920
inputting the bit

1032
00:39:43,920 --> 00:39:45,599
will learn nothing about the message

1033
00:39:45,599 --> 00:39:47,200
that they didn't receive so if they

1034
00:39:47,200 --> 00:39:49,520
input bit zero they receive message zero

1035
00:39:49,520 --> 00:39:51,839
and learn nothing about message one

1036
00:39:51,839 --> 00:39:53,440
sender on the other hand the one that

1037
00:39:53,440 --> 00:39:55,280
receives both messages

1038
00:39:55,280 --> 00:39:56,960
is going to learn nothing about the

1039
00:39:56,960 --> 00:40:00,079
receiver's choice bit

1040
00:40:00,960 --> 00:40:03,200
and where do we see oblivious transfer

1041
00:40:03,200 --> 00:40:06,000
or ot for short in the wild

1042
00:40:06,000 --> 00:40:07,760
we see it in garbled circuits where in

1043
00:40:07,760 --> 00:40:09,599
some constructions

1044
00:40:09,599 --> 00:40:11,440
garbled circuits require an abilities

1045
00:40:11,440 --> 00:40:12,720
transfer for each and gate in the

1046
00:40:12,720 --> 00:40:14,560
circuit and we also see oblivious

1047
00:40:14,560 --> 00:40:16,240
transfer come up in private set

1048
00:40:16,240 --> 00:40:18,079
intersection

1049
00:40:18,079 --> 00:40:20,240
in these applications we will see that

1050
00:40:20,240 --> 00:40:22,800
abilities transfer as needed millions of

1051
00:40:22,800 --> 00:40:25,119
times necessarily acquiring

1052
00:40:25,119 --> 00:40:28,000
asymmetric operations and so these

1053
00:40:28,000 --> 00:40:30,720
millions of ots will need to be

1054
00:40:30,720 --> 00:40:32,960
done with asymmetric operations which

1055
00:40:32,960 --> 00:40:34,560
are extremely expensive millions of

1056
00:40:34,560 --> 00:40:36,640
times

1057
00:40:36,640 --> 00:40:38,880
so how do we get around this

1058
00:40:38,880 --> 00:40:40,880
to get around this we want to have some

1059
00:40:40,880 --> 00:40:42,640
sort of protocol where we take in some

1060
00:40:42,640 --> 00:40:45,520
small number of ots which we have to do

1061
00:40:45,520 --> 00:40:48,079
with expensive asymmetric operations

1062
00:40:48,079 --> 00:40:50,480
and then we want to transform them into

1063
00:40:50,480 --> 00:40:53,119
a polynomial size in the previous cases

1064
00:40:53,119 --> 00:40:56,560
millions of actual realized ot's

1065
00:40:56,560 --> 00:40:58,319
but we don't want to use these expensive

1066
00:40:58,319 --> 00:40:59,839
operations we want to use some cheap

1067
00:40:59,839 --> 00:41:03,119
symmetric operations

1068
00:41:03,359 --> 00:41:04,319
and

1069
00:41:04,319 --> 00:41:06,160
we have a way to do that it's what we

1070
00:41:06,160 --> 00:41:09,200
call um oblivious transfer extension

1071
00:41:09,200 --> 00:41:11,040
roti extension

1072
00:41:11,040 --> 00:41:13,440
and in this situation we were able to do

1073
00:41:13,440 --> 00:41:15,839
that we're able to take a small number

1074
00:41:15,839 --> 00:41:19,040
of ots usually 128 or the security

1075
00:41:19,040 --> 00:41:21,520
parameter and extend them into millions

1076
00:41:21,520 --> 00:41:23,760
of actual realized ots

1077
00:41:23,760 --> 00:41:27,119
but since we have to make those base ots

1078
00:41:27,119 --> 00:41:28,560
at some point in time using these

1079
00:41:28,560 --> 00:41:30,480
asymmetric operations

1080
00:41:30,480 --> 00:41:32,160
we're going to want to look at how to

1081
00:41:32,160 --> 00:41:33,440
optimize

1082
00:41:33,440 --> 00:41:34,480
these

1083
00:41:34,480 --> 00:41:35,920
oblivious transfers that we actually

1084
00:41:35,920 --> 00:41:37,760
have to do

1085
00:41:37,760 --> 00:41:39,680
and in this situation

1086
00:41:39,680 --> 00:41:41,760
we're going to treat them as in a single

1087
00:41:41,760 --> 00:41:44,400
cohesive unit in a batch and refer to

1088
00:41:44,400 --> 00:41:48,079
this as the batch setting

1089
00:41:48,079 --> 00:41:50,880
as it turns out the natural way of

1090
00:41:50,880 --> 00:41:52,560
batching a lot of oblivious transfer

1091
00:41:52,560 --> 00:41:53,839
protocols that were out there in the

1092
00:41:53,839 --> 00:41:54,800
wild

1093
00:41:54,800 --> 00:41:56,560
lacked a principal treatment and

1094
00:41:56,560 --> 00:41:59,280
actually had security flaws that were in

1095
00:41:59,280 --> 00:42:02,560
real world libraries

1096
00:42:02,560 --> 00:42:04,960
so let's look at a

1097
00:42:04,960 --> 00:42:07,760
actual oblivious transfer protocol

1098
00:42:07,760 --> 00:42:09,760
so this is a protocol from our previous

1099
00:42:09,760 --> 00:42:12,160
paper from ccs2020

1100
00:42:12,160 --> 00:42:14,240
and how it works is we start off by the

1101
00:42:14,240 --> 00:42:16,640
sender sending a normal keygroup message

1102
00:42:16,640 --> 00:42:19,359
over to the receiver

1103
00:42:19,359 --> 00:42:21,839
the receiver samples their private key

1104
00:42:21,839 --> 00:42:23,839
and they send and they choose a choice

1105
00:42:23,839 --> 00:42:26,480
bit either zero or one

1106
00:42:26,480 --> 00:42:29,520
then they wrap their

1107
00:42:29,520 --> 00:42:31,680
protocol message uh in this case their

1108
00:42:31,680 --> 00:42:33,200
key great message

1109
00:42:33,200 --> 00:42:35,920
by encrypting it with an ideal cipher

1110
00:42:35,920 --> 00:42:38,000
and as their key they're going to use

1111
00:42:38,000 --> 00:42:39,599
their choice bit

1112
00:42:39,599 --> 00:42:42,839
so they send they send that over to the

1113
00:42:42,839 --> 00:42:46,560
sender then at the end

1114
00:42:46,560 --> 00:42:49,200
the sender is going to decrypt the

1115
00:42:49,200 --> 00:42:51,040
wrapped key group messages they got

1116
00:42:51,040 --> 00:42:51,839
under

1117
00:42:51,839 --> 00:42:54,560
both possible choice bits now what this

1118
00:42:54,560 --> 00:42:55,920
is going to do is it's going to give

1119
00:42:55,920 --> 00:42:58,720
them two possible key agreement message

1120
00:42:58,720 --> 00:43:00,720
outputs

1121
00:43:00,720 --> 00:43:02,480
then they're going to treat both of

1122
00:43:02,480 --> 00:43:04,960
those as separate keep your messages and

1123
00:43:04,960 --> 00:43:06,720
derive the

1124
00:43:06,720 --> 00:43:09,200
shared key for to those messages

1125
00:43:09,200 --> 00:43:11,200
the receiver on the other hand is just

1126
00:43:11,200 --> 00:43:13,440
going to do their normal key agreement

1127
00:43:13,440 --> 00:43:14,720
output

1128
00:43:14,720 --> 00:43:16,480
now as it turns out

1129
00:43:16,480 --> 00:43:17,440
the

1130
00:43:17,440 --> 00:43:18,319
only

1131
00:43:18,319 --> 00:43:20,160
key group message that the receiver

1132
00:43:20,160 --> 00:43:22,640
could have possibly learned in this case

1133
00:43:22,640 --> 00:43:24,160
is the one corresponding to their choice

1134
00:43:24,160 --> 00:43:25,040
bit

1135
00:43:25,040 --> 00:43:27,200
as let's say that the receiver choice

1136
00:43:27,200 --> 00:43:28,319
bit 1

1137
00:43:28,319 --> 00:43:31,359
then decrypting this wrapped key green

1138
00:43:31,359 --> 00:43:34,240
message under a key of one will give the

1139
00:43:34,240 --> 00:43:36,240
actual receiver's

1140
00:43:36,240 --> 00:43:38,400
keygroup message back to the sender

1141
00:43:38,400 --> 00:43:39,520
and then they'll arrive at the same

1142
00:43:39,520 --> 00:43:40,560
shared key

1143
00:43:40,560 --> 00:43:42,640
the other output the one that's

1144
00:43:42,640 --> 00:43:45,200
decrypted under a key of zero the

1145
00:43:45,200 --> 00:43:48,079
receiver's not chosen choice bit

1146
00:43:48,079 --> 00:43:50,480
the receiver can't possibly know the

1147
00:43:50,480 --> 00:43:52,160
secret to that key and so they won't be

1148
00:43:52,160 --> 00:43:54,000
able to derive the same keyground

1149
00:43:54,000 --> 00:43:56,319
message

1150
00:43:56,480 --> 00:43:57,839
so

1151
00:43:57,839 --> 00:44:00,319
what if we want to run these 128 base

1152
00:44:00,319 --> 00:44:02,960
ots that we need for ot extension

1153
00:44:02,960 --> 00:44:05,040
we'd have to run them in series we're

1154
00:44:05,040 --> 00:44:07,040
going to send our key grid message over

1155
00:44:07,040 --> 00:44:09,040
and we're going to resend a wrapped key

1156
00:44:09,040 --> 00:44:10,720
agreement message back this is going to

1157
00:44:10,720 --> 00:44:13,040
happen 128 times

1158
00:44:13,040 --> 00:44:14,240
well

1159
00:44:14,240 --> 00:44:16,880
in the real world we often reuse key

1160
00:44:16,880 --> 00:44:18,640
dream messages like you have a public

1161
00:44:18,640 --> 00:44:21,040
key that you use for multiple uh key

1162
00:44:21,040 --> 00:44:23,359
treatments uh outputs

1163
00:44:23,359 --> 00:44:24,160
then

1164
00:44:24,160 --> 00:44:26,880
what if we did the same thing here for

1165
00:44:26,880 --> 00:44:28,400
uh batching

1166
00:44:28,400 --> 00:44:30,640
oblivious transfers

1167
00:44:30,640 --> 00:44:32,480
well it looks something like this where

1168
00:44:32,480 --> 00:44:34,480
we just send one key message over from

1169
00:44:34,480 --> 00:44:35,599
the sender

1170
00:44:35,599 --> 00:44:37,280
and then the receiver

1171
00:44:37,280 --> 00:44:39,119
is going to sample there are uh it's

1172
00:44:39,119 --> 00:44:41,119
going to sample their keys

1173
00:44:41,119 --> 00:44:43,680
one for each of the individual

1174
00:44:43,680 --> 00:44:46,880
instances of the ot protocol on a batch

1175
00:44:46,880 --> 00:44:49,839
but they're going to use the first

1176
00:44:49,839 --> 00:44:51,760
message that the sender sent for every

1177
00:44:51,760 --> 00:44:54,240
single one of those when deriving their

1178
00:44:54,240 --> 00:44:56,879
shared key

1179
00:44:57,119 --> 00:44:59,280
well as it turns out there's actually an

1180
00:44:59,280 --> 00:45:02,079
attack on this protocol

1181
00:45:02,079 --> 00:45:03,280
first thing we're going to do is we're

1182
00:45:03,280 --> 00:45:04,800
going to carry through the protocols

1183
00:45:04,800 --> 00:45:06,400
normal the sender is going to send their

1184
00:45:06,400 --> 00:45:09,839
key green message over to the receiver

1185
00:45:09,839 --> 00:45:12,400
then as we did earlier in the actual in

1186
00:45:12,400 --> 00:45:14,480
the original protocol

1187
00:45:14,480 --> 00:45:17,119
the receiver is going to generate their

1188
00:45:17,119 --> 00:45:18,960
their corresponding

1189
00:45:18,960 --> 00:45:21,520
message in the protocol just by wrapping

1190
00:45:21,520 --> 00:45:24,079
their keyground message

1191
00:45:24,079 --> 00:45:26,319
under one of the two possible choice

1192
00:45:26,319 --> 00:45:27,280
bits

1193
00:45:27,280 --> 00:45:28,480
in this case we're just going to choose

1194
00:45:28,480 --> 00:45:30,839
zero

1195
00:45:30,839 --> 00:45:34,880
then in the actual protocol without

1196
00:45:34,880 --> 00:45:37,440
without this optimization

1197
00:45:37,440 --> 00:45:39,440
we would choose a different key

1198
00:45:39,440 --> 00:45:42,160
agreement message for each

1199
00:45:42,160 --> 00:45:44,240
message that we send over to the uh to

1200
00:45:44,240 --> 00:45:47,119
the sender but in this situation we're

1201
00:45:47,119 --> 00:45:49,040
talking the protocol we're going to

1202
00:45:49,040 --> 00:45:51,520
repeat the same message for every single

1203
00:45:51,520 --> 00:45:53,839
instance of the protocol instead of send

1204
00:45:53,839 --> 00:45:55,599
instead of sampling a new secret for

1205
00:45:55,599 --> 00:45:58,240
every message

1206
00:45:58,480 --> 00:46:00,720
what this ends up doing is it ends up

1207
00:46:00,720 --> 00:46:03,359
making it so that for every instance

1208
00:46:03,359 --> 00:46:07,040
inside of a batch of ots

1209
00:46:07,040 --> 00:46:09,359
the sender is going to get the same

1210
00:46:09,359 --> 00:46:11,920
message for each one so this doesn't

1211
00:46:11,920 --> 00:46:13,280
mean that you're going to get the same

1212
00:46:13,280 --> 00:46:15,119
message for a choice bit of 0 and choice

1213
00:46:15,119 --> 00:46:16,240
bit of 1

1214
00:46:16,240 --> 00:46:17,839
but rather it means

1215
00:46:17,839 --> 00:46:20,079
that the first ot instance is going to

1216
00:46:20,079 --> 00:46:22,960
have message 1 message 2 the second ot

1217
00:46:22,960 --> 00:46:24,640
instance is going to have the same

1218
00:46:24,640 --> 00:46:26,880
message one message to and this is going

1219
00:46:26,880 --> 00:46:28,960
to iterate through every single one of

1220
00:46:28,960 --> 00:46:32,240
the instances within an ot

1221
00:46:32,240 --> 00:46:34,880
within an ot batch

1222
00:46:34,880 --> 00:46:37,920
and this is something that can't um

1223
00:46:37,920 --> 00:46:39,680
can't happen in the situation where

1224
00:46:39,680 --> 00:46:42,960
we're not using this what we call naive

1225
00:46:42,960 --> 00:46:46,079
form of optimization

1226
00:46:46,079 --> 00:46:48,240
and as it turns out it affects ot

1227
00:46:48,240 --> 00:46:52,160
extension protocols in a devastating way

1228
00:46:52,720 --> 00:46:55,440
specifically when looking at the oos ot

1229
00:46:55,440 --> 00:46:56,720
extension

1230
00:46:56,720 --> 00:46:59,119
it allows us to or

1231
00:46:59,119 --> 00:47:00,720
allows the adversary

1232
00:47:00,720 --> 00:47:02,960
to extract all of the receiver's choice

1233
00:47:02,960 --> 00:47:05,359
bits in the protocol

1234
00:47:05,359 --> 00:47:06,319
however

1235
00:47:06,319 --> 00:47:09,200
this is something specific to oos as it

1236
00:47:09,200 --> 00:47:12,720
relies on the code words

1237
00:47:12,720 --> 00:47:15,440
when we're uh generating the error

1238
00:47:15,440 --> 00:47:16,560
correcting when we're using error

1239
00:47:16,560 --> 00:47:18,800
correcting codes for generating the

1240
00:47:18,800 --> 00:47:20,480
messages inside of an ot extension

1241
00:47:20,480 --> 00:47:23,440
protocol we need the codeword on zero

1242
00:47:23,440 --> 00:47:25,440
and the code word on one to not be

1243
00:47:25,440 --> 00:47:27,839
bitwise complements

1244
00:47:27,839 --> 00:47:30,480
but this is a very specific attack on a

1245
00:47:30,480 --> 00:47:32,720
very specific protocol and there may be

1246
00:47:32,720 --> 00:47:34,880
more complex correlations that can be

1247
00:47:34,880 --> 00:47:36,880
used to attack other

1248
00:47:36,880 --> 00:47:41,200
ot extension protocols such as kos

1249
00:47:41,200 --> 00:47:43,440
well how do we fix this problem

1250
00:47:43,440 --> 00:47:45,599
well the problem was is that we were

1251
00:47:45,599 --> 00:47:48,480
able to have correlations between each

1252
00:47:48,480 --> 00:47:50,480
of the protocol with each of these

1253
00:47:50,480 --> 00:47:53,760
single protocols within a batch

1254
00:47:53,760 --> 00:47:54,720
and so

1255
00:47:54,720 --> 00:47:57,280
we need to separate each of these ot

1256
00:47:57,280 --> 00:47:59,839
instances

1257
00:47:59,839 --> 00:48:02,640
there's an actual easy way of doing this

1258
00:48:02,640 --> 00:48:05,200
we're in the original protocol

1259
00:48:05,200 --> 00:48:07,359
we just sent a key grant message over

1260
00:48:07,359 --> 00:48:09,280
and they derived a key agreement message

1261
00:48:09,280 --> 00:48:11,440
from their output on tagged

1262
00:48:11,440 --> 00:48:13,359
we're now going to tag these key great

1263
00:48:13,359 --> 00:48:15,119
messages

1264
00:48:15,119 --> 00:48:17,680
so an easy way of doing this is by

1265
00:48:17,680 --> 00:48:19,599
instead of using just normal diphthong

1266
00:48:19,599 --> 00:48:22,000
key agreement to use a hashed divi

1267
00:48:22,000 --> 00:48:23,599
filming key agreement

1268
00:48:23,599 --> 00:48:26,319
where as one of the inputs to the final

1269
00:48:26,319 --> 00:48:27,280
hash

1270
00:48:27,280 --> 00:48:30,319
we're going to have a tag

1271
00:48:30,319 --> 00:48:31,520
and

1272
00:48:31,520 --> 00:48:32,839
in this specific

1273
00:48:32,839 --> 00:48:35,440
instance that tag is just going to be

1274
00:48:35,440 --> 00:48:37,440
which of the ot instances we're looking

1275
00:48:37,440 --> 00:48:40,160
at so the first time the first ot

1276
00:48:40,160 --> 00:48:42,079
instance is going to have a tag of one

1277
00:48:42,079 --> 00:48:44,240
and the nth ot instance is going to just

1278
00:48:44,240 --> 00:48:48,040
have a tag of n

1279
00:48:48,240 --> 00:48:49,040
then

1280
00:48:49,040 --> 00:48:52,960
we implemented our protocol with um

1281
00:48:52,960 --> 00:48:55,280
with this new form of batching and we

1282
00:48:55,280 --> 00:48:57,599
found that it gave us a market increase

1283
00:48:57,599 --> 00:48:59,760
in both the wireless area network and

1284
00:48:59,760 --> 00:49:02,880
local area network settings

1285
00:49:02,880 --> 00:49:04,400
and when we were testing this we were

1286
00:49:04,400 --> 00:49:07,359
testing it over the normal

1287
00:49:07,359 --> 00:49:09,280
way that we'd see being used for

1288
00:49:09,280 --> 00:49:13,280
instance 128 base ots

1289
00:49:13,280 --> 00:49:16,720
we also implemented a

1290
00:49:16,720 --> 00:49:19,119
optimization to be styled protocols to

1291
00:49:19,119 --> 00:49:20,400
get a

1292
00:49:20,400 --> 00:49:24,079
another market increase in performance

1293
00:49:24,079 --> 00:49:27,119
i wasn't able to go over some of the key

1294
00:49:27,119 --> 00:49:29,280
points from our full paper during this

1295
00:49:29,280 --> 00:49:32,720
time but just as a teaser

1296
00:49:32,720 --> 00:49:33,520
we

1297
00:49:33,520 --> 00:49:35,200
expanded some of the known ot

1298
00:49:35,200 --> 00:49:37,280
constructions from our previous paper

1299
00:49:37,280 --> 00:49:40,160
also including some optimizations as

1300
00:49:40,160 --> 00:49:41,599
well as

1301
00:49:41,599 --> 00:49:44,480
a generalization of mosni and rindel's

1302
00:49:44,480 --> 00:49:47,760
endemic ot protocol to the style of

1303
00:49:47,760 --> 00:49:49,599
ot as well as providing our

1304
00:49:49,599 --> 00:49:52,480
optimizations to it

1305
00:49:52,480 --> 00:49:54,800
and some open problems that we noticed

1306
00:49:54,800 --> 00:49:56,800
we're curious if other similar problems

1307
00:49:56,800 --> 00:49:59,359
arise in other ot extensions as a lot of

1308
00:49:59,359 --> 00:50:01,040
these proofs don't think about

1309
00:50:01,040 --> 00:50:03,040
correlations

1310
00:50:03,040 --> 00:50:04,319
we're also interested in seeing if

1311
00:50:04,319 --> 00:50:06,400
there's any post quantum key agreements

1312
00:50:06,400 --> 00:50:08,240
that meet the properties required for a

1313
00:50:08,240 --> 00:50:10,000
protocol specifically

1314
00:50:10,000 --> 00:50:12,079
this is built in a generic way that's

1315
00:50:12,079 --> 00:50:14,880
built for any uh key agreement but we

1316
00:50:14,880 --> 00:50:16,800
specifically instantiated it

1317
00:50:16,800 --> 00:50:20,079
with uh elliptic curve diffie-hellman

1318
00:50:20,079 --> 00:50:23,200
and we uh showed some new instances of a

1319
00:50:23,200 --> 00:50:24,880
primitive which we call programmer once

1320
00:50:24,880 --> 00:50:27,280
public functions which are very useful

1321
00:50:27,280 --> 00:50:28,960
for building these style of protocols

1322
00:50:28,960 --> 00:50:30,720
and we're curious what else they could

1323
00:50:30,720 --> 00:50:32,640
be used in other than

1324
00:50:32,640 --> 00:50:34,640
oblivious transfer and in our previous

1325
00:50:34,640 --> 00:50:36,800
paper we showed that they're used in

1326
00:50:36,800 --> 00:50:39,520
pake password then to key exchange

1327
00:50:39,520 --> 00:50:41,119
and oblivious random function

1328
00:50:41,119 --> 00:50:44,119
instantiation

1329
00:50:54,079 --> 00:50:56,480
thank you for the talk um

1330
00:50:56,480 --> 00:50:59,200
we currently do not have any questions

1331
00:50:59,200 --> 00:51:01,520
on zoom our agent portal are there any

1332
00:51:01,520 --> 00:51:03,040
online questions that people want to ask

1333
00:51:03,040 --> 00:51:05,359
right now

1334
00:51:05,440 --> 00:51:08,960
i think we are running out of time so

1335
00:51:08,960 --> 00:51:12,079
if you are having any questions please

1336
00:51:12,079 --> 00:51:13,680
write on uh

1337
00:51:13,680 --> 00:51:16,559
jerk chat and uh

1338
00:51:16,559 --> 00:51:20,880
receive answers on offline

1339
00:51:21,200 --> 00:51:25,200
okay uh the last talk of this session is

1340
00:51:25,200 --> 00:51:27,920
algebraic adversaries in the universal

1341
00:51:27,920 --> 00:51:30,240
composibility framework

1342
00:51:30,240 --> 00:51:32,000
by michel abdullah

1343
00:51:32,000 --> 00:51:33,680
manuel baucer

1344
00:51:33,680 --> 00:51:36,720
jonathan katz

1345
00:51:38,079 --> 00:51:42,000
and julian is going to speak

1346
00:51:43,440 --> 00:51:46,160
can you hear me

1347
00:51:46,720 --> 00:51:47,599
yes

1348
00:51:47,599 --> 00:51:50,160
okay

1349
00:51:50,160 --> 00:51:52,480
great

1350
00:51:52,559 --> 00:51:55,920
okay so in this work we consider two

1351
00:51:55,920 --> 00:51:57,359
very well known models from the

1352
00:51:57,359 --> 00:51:59,599
literature the first one is called the

1353
00:51:59,599 --> 00:52:02,160
universal composability framework was

1354
00:52:02,160 --> 00:52:04,880
introduced by in 2001 and it's

1355
00:52:04,880 --> 00:52:07,839
essentially a framework for proving uh

1356
00:52:07,839 --> 00:52:10,960
security properties of mpc protocols and

1357
00:52:10,960 --> 00:52:12,240
the idea is

1358
00:52:12,240 --> 00:52:14,160
that

1359
00:52:14,160 --> 00:52:16,720
we define the goal of an npc protocol

1360
00:52:16,720 --> 00:52:20,000
with respect to some ideal functionality

1361
00:52:20,000 --> 00:52:21,200
and then we show

1362
00:52:21,200 --> 00:52:22,240
that

1363
00:52:22,240 --> 00:52:24,960
for any real world adversary

1364
00:52:24,960 --> 00:52:28,079
there exists an ideal adversary let's

1365
00:52:28,079 --> 00:52:30,319
call that ideal adversary

1366
00:52:30,319 --> 00:52:31,839
s a simulator

1367
00:52:31,839 --> 00:52:34,640
such that for all environments

1368
00:52:34,640 --> 00:52:35,440
um

1369
00:52:35,440 --> 00:52:38,160
excuse me for all environments uh it is

1370
00:52:38,160 --> 00:52:40,800
impossible to distinguish whether or not

1371
00:52:40,800 --> 00:52:44,640
it's interacting with um

1372
00:52:44,640 --> 00:52:46,800
with the ideal functionality or protocol

1373
00:52:46,800 --> 00:52:49,760
realizing that ideal functionality and

1374
00:52:49,760 --> 00:52:51,599
if we can provide such a simulator then

1375
00:52:51,599 --> 00:52:53,520
we would say that this protocol

1376
00:52:53,520 --> 00:52:56,079
satisfies the uc security definition so

1377
00:52:56,079 --> 00:52:58,079
this model is very useful because it

1378
00:52:58,079 --> 00:53:01,200
provides a composition theorem which

1379
00:53:01,200 --> 00:53:03,440
essentially means that you can take

1380
00:53:03,440 --> 00:53:04,960
any

1381
00:53:04,960 --> 00:53:06,960
protocol that has been proven secure

1382
00:53:06,960 --> 00:53:09,280
with respect to this definition and

1383
00:53:09,280 --> 00:53:11,680
compose it in any

1384
00:53:11,680 --> 00:53:14,079
shape type or form with another protocol

1385
00:53:14,079 --> 00:53:15,839
that also satisfies this security

1386
00:53:15,839 --> 00:53:17,359
definition so it does not matter how you

1387
00:53:17,359 --> 00:53:19,280
interleave them whether you use one

1388
00:53:19,280 --> 00:53:22,240
protocol as a subroutine to another um

1389
00:53:22,240 --> 00:53:23,920
like any way you compose them will

1390
00:53:23,920 --> 00:53:25,359
remain secure by this composition

1391
00:53:25,359 --> 00:53:27,119
theorem so it's very very useful as a

1392
00:53:27,119 --> 00:53:29,599
security definition now the second model

1393
00:53:29,599 --> 00:53:31,599
that we consider here is the algebraic

1394
00:53:31,599 --> 00:53:33,359
group model which was introduced by

1395
00:53:33,359 --> 00:53:37,440
folks bio kills and myself in 2018 and

1396
00:53:37,440 --> 00:53:39,119
um

1397
00:53:39,119 --> 00:53:41,920
this model is essentially a model

1398
00:53:41,920 --> 00:53:43,920
of let's say

1399
00:53:43,920 --> 00:53:45,920
idealized computation that stands in

1400
00:53:45,920 --> 00:53:48,079
between the standard model and the

1401
00:53:48,079 --> 00:53:50,400
generic group model so here

1402
00:53:50,400 --> 00:53:52,240
adversaries are idealized in the

1403
00:53:52,240 --> 00:53:53,920
following sense

1404
00:53:53,920 --> 00:53:56,480
that they are restricted as to how they

1405
00:53:56,480 --> 00:53:58,240
compute their output

1406
00:53:58,240 --> 00:53:59,760
um

1407
00:53:59,760 --> 00:54:02,240
so if an adversary a gets a bunch of

1408
00:54:02,240 --> 00:54:03,839
group elements which i've denoted here

1409
00:54:03,839 --> 00:54:06,240
as x1 to xn

1410
00:54:06,240 --> 00:54:08,800
and it outputs a group element y in the

1411
00:54:08,800 --> 00:54:11,200
group then it also has to output these

1412
00:54:11,200 --> 00:54:13,760
algebraic coefficients lambda 1 into

1413
00:54:13,760 --> 00:54:15,920
lambda n which we call the algebraic

1414
00:54:15,920 --> 00:54:19,119
representation such that y can be

1415
00:54:19,119 --> 00:54:21,920
expressed as this product of group

1416
00:54:21,920 --> 00:54:24,640
elements to these algebraic coefficients

1417
00:54:24,640 --> 00:54:26,880
and so this essentially means that the

1418
00:54:26,880 --> 00:54:28,640
adversary is restricted to computing

1419
00:54:28,640 --> 00:54:31,040
these elements in sort of a semi-honest

1420
00:54:31,040 --> 00:54:33,520
way but in comparison to the generic

1421
00:54:33,520 --> 00:54:35,200
group model it actually sees the

1422
00:54:35,200 --> 00:54:38,000
concrete representations of these group

1423
00:54:38,000 --> 00:54:39,839
elements and

1424
00:54:39,839 --> 00:54:43,359
it can infer additional

1425
00:54:43,359 --> 00:54:46,079
information from those representations

1426
00:54:46,079 --> 00:54:48,720
however there is currently no way to

1427
00:54:48,720 --> 00:54:50,640
combine these two models with each other

1428
00:54:50,640 --> 00:54:53,440
so it's not clear what it means to

1429
00:54:53,440 --> 00:54:56,319
look at an algebraic adversary in the

1430
00:54:56,319 --> 00:54:58,720
universal composition composability

1431
00:54:58,720 --> 00:55:00,079
framework

1432
00:55:00,079 --> 00:55:01,760
so all of the

1433
00:55:01,760 --> 00:55:03,520
proofs that we currently have in the agm

1434
00:55:03,520 --> 00:55:04,799
are basically

1435
00:55:04,799 --> 00:55:06,720
game base then they don't carry over to

1436
00:55:06,720 --> 00:55:10,319
this uc framework and that is exactly

1437
00:55:10,319 --> 00:55:11,280
the

1438
00:55:11,280 --> 00:55:13,760
goal of our of our work to start to

1439
00:55:13,760 --> 00:55:15,599
formalize this

1440
00:55:15,599 --> 00:55:18,480
uc agm framework which sort of combines

1441
00:55:18,480 --> 00:55:21,599
these two frameworks and allows to

1442
00:55:21,599 --> 00:55:23,680
essentially use the best of both worlds

1443
00:55:23,680 --> 00:55:25,440
of these frameworks

1444
00:55:25,440 --> 00:55:27,520
to prove

1445
00:55:27,520 --> 00:55:29,200
theorems in the algebraic group model

1446
00:55:29,200 --> 00:55:31,119
which also satisfy some sort of

1447
00:55:31,119 --> 00:55:33,040
composability notion

1448
00:55:33,040 --> 00:55:34,799
okay so

1449
00:55:34,799 --> 00:55:36,400
again i mean what we what we provide

1450
00:55:36,400 --> 00:55:38,799
here essentially is an adaptation of

1451
00:55:38,799 --> 00:55:40,720
this uc

1452
00:55:40,720 --> 00:55:42,880
composability uh

1453
00:55:42,880 --> 00:55:43,920
theorem

1454
00:55:43,920 --> 00:55:46,640
which holds with respect to algebraic

1455
00:55:46,640 --> 00:55:49,760
entities so our version of the uc

1456
00:55:49,760 --> 00:55:52,960
composability theorem would be that uh

1457
00:55:52,960 --> 00:55:56,160
protocol real or uc agm realizes a

1458
00:55:56,160 --> 00:55:58,799
functionality f if for all algebraic

1459
00:55:58,799 --> 00:56:00,960
real adverse series a there exists an

1460
00:56:00,960 --> 00:56:03,839
algebraic simulator s such that for all

1461
00:56:03,839 --> 00:56:07,119
algebraic environments uh epsilon the

1462
00:56:07,119 --> 00:56:09,440
views in these two worlds the simulated

1463
00:56:09,440 --> 00:56:11,119
one in the real world

1464
00:56:11,119 --> 00:56:13,280
are indistinguishable

1465
00:56:13,280 --> 00:56:15,040
and so now uh this

1466
00:56:15,040 --> 00:56:16,720
you know sounds very intuitive but it

1467
00:56:16,720 --> 00:56:18,640
actually comes along with uh with a lot

1468
00:56:18,640 --> 00:56:20,720
of issues so first of all you have to

1469
00:56:20,720 --> 00:56:23,280
define what it means the formal level to

1470
00:56:23,280 --> 00:56:26,079
be algebraic in the uc framework um it's

1471
00:56:26,079 --> 00:56:29,680
actually a little subtle how to do that

1472
00:56:29,680 --> 00:56:31,839
and then also of course we have to adapt

1473
00:56:31,839 --> 00:56:34,640
this composition theorem which you which

1474
00:56:34,640 --> 00:56:37,200
we're using in this this framework to

1475
00:56:37,200 --> 00:56:38,319
prove things

1476
00:56:38,319 --> 00:56:39,599
and um

1477
00:56:39,599 --> 00:56:41,200
the the composition theorem of course

1478
00:56:41,200 --> 00:56:43,119
says the same thing but as it were

1479
00:56:43,119 --> 00:56:44,559
before so if you if you realize

1480
00:56:44,559 --> 00:56:46,480
something in the uc agm then you can

1481
00:56:46,480 --> 00:56:48,880
arbitrarily compose it uh

1482
00:56:48,880 --> 00:56:50,559
subject to this composition theorem of

1483
00:56:50,559 --> 00:56:52,559
course but uh here you get a lot of

1484
00:56:52,559 --> 00:56:55,280
subtle issues because uh group elements

1485
00:56:55,280 --> 00:56:59,359
can come from the protocols that

1486
00:56:59,359 --> 00:57:01,680
you run on the outside of these of these

1487
00:57:01,680 --> 00:57:06,078
subroutines and they can be provided as

1488
00:57:06,400 --> 00:57:08,960
as part of the algebraic adversaries

1489
00:57:08,960 --> 00:57:10,400
representation

1490
00:57:10,400 --> 00:57:12,079
when you run these protocols that you

1491
00:57:12,079 --> 00:57:14,160
previously realized as subroutines of

1492
00:57:14,160 --> 00:57:15,760
larger order protocols and that makes it

1493
00:57:15,760 --> 00:57:17,440
very subtle to prove this composition

1494
00:57:17,440 --> 00:57:19,760
theorem and uh if you're interested then

1495
00:57:19,760 --> 00:57:21,359
you can you can look how we do it in our

1496
00:57:21,359 --> 00:57:22,880
work

1497
00:57:22,880 --> 00:57:25,359
okay so now some results that we show in

1498
00:57:25,359 --> 00:57:28,640
this in this work um

1499
00:57:28,640 --> 00:57:31,359
actually some analyses of

1500
00:57:31,359 --> 00:57:33,760
uh very well-known protocols for example

1501
00:57:33,760 --> 00:57:36,720
the chu orlandi ot protocol so this was

1502
00:57:36,720 --> 00:57:39,359
proposed by june orlandy in 2015 and

1503
00:57:39,359 --> 00:57:42,720
it's very very simple and fast very

1504
00:57:42,720 --> 00:57:45,760
conceptually nice protocol and um it was

1505
00:57:45,760 --> 00:57:47,680
originally claimed to be uc secure but

1506
00:57:47,680 --> 00:57:49,920
it has a little bit of a complicated

1507
00:57:49,920 --> 00:57:52,640
history as you can see here so in 2017

1508
00:57:52,640 --> 00:57:54,400
there was a

1509
00:57:54,400 --> 00:57:57,599
work of gensh aptly named too simple to

1510
00:57:57,599 --> 00:57:59,440
be uc secure

1511
00:57:59,440 --> 00:58:01,040
and and they essentially showed that

1512
00:58:01,040 --> 00:58:02,960
there's a problem with adaptive

1513
00:58:02,960 --> 00:58:05,280
corruptions in the in the original proof

1514
00:58:05,280 --> 00:58:06,799
of chu and olandi

1515
00:58:06,799 --> 00:58:09,280
and um then later it was actually uh

1516
00:58:09,280 --> 00:58:11,520
worked by hauck and myself where we

1517
00:58:11,520 --> 00:58:14,160
patched these two these two flaws in cos

1518
00:58:14,160 --> 00:58:15,680
proof and showed adaptive corruption but

1519
00:58:15,680 --> 00:58:18,160
then later it was actually another bug

1520
00:58:18,160 --> 00:58:20,799
found in this in the co protocol

1521
00:58:20,799 --> 00:58:23,119
which stems from extraction which we

1522
00:58:23,119 --> 00:58:25,280
also heard about in the last talk

1523
00:58:25,280 --> 00:58:28,319
and our observation basically is that

1524
00:58:28,319 --> 00:58:30,480
if you look at this protocol in the uc

1525
00:58:30,480 --> 00:58:33,119
agm framework then the extraction is

1526
00:58:33,119 --> 00:58:34,640
very simple because you can basically

1527
00:58:34,640 --> 00:58:36,559
extract from the adversary's first

1528
00:58:36,559 --> 00:58:37,599
message

1529
00:58:37,599 --> 00:58:40,400
and so we managed to prove this protocol

1530
00:58:40,400 --> 00:58:44,079
secure in our uc agm context

1531
00:58:44,079 --> 00:58:47,200
um okay so another application that we

1532
00:58:47,200 --> 00:58:49,440
show is an analysis of several

1533
00:58:49,440 --> 00:58:51,200
password-based key authentication

1534
00:58:51,200 --> 00:58:56,480
protocols such as sp 1 and 2 and cpase

1535
00:58:56,480 --> 00:58:57,440
and

1536
00:58:57,440 --> 00:58:59,040
so here you can you can sort of see a

1537
00:58:59,040 --> 00:59:00,880
table of what is known

1538
00:59:00,880 --> 00:59:03,280
so we have game-based proofs for for

1539
00:59:03,280 --> 00:59:05,760
several of them uh we also have relaxed

1540
00:59:05,760 --> 00:59:07,920
uc proofs for some of them and and we

1541
00:59:07,920 --> 00:59:10,480
actually show that we can prove all of

1542
00:59:10,480 --> 00:59:11,520
them

1543
00:59:11,520 --> 00:59:14,240
secure in the in the uc agm

1544
00:59:14,240 --> 00:59:15,040
and

1545
00:59:15,040 --> 00:59:17,680
yeah good that concludes my talk here is

1546
00:59:17,680 --> 00:59:19,760
the link to our paper

1547
00:59:19,760 --> 00:59:21,119
if you have any questions i would be

1548
00:59:21,119 --> 00:59:24,160
happy to answer thanks

1549
00:59:29,680 --> 00:59:32,079
thank you for the talk so uh we don't

1550
00:59:32,079 --> 00:59:34,559
have any questions on zoom or the asia

1551
00:59:34,559 --> 00:59:36,000
group portal right now are there any

1552
00:59:36,000 --> 00:59:39,119
online questions that

1553
00:59:39,440 --> 00:59:42,400
somebody wants to ask

1554
00:59:45,119 --> 00:59:47,200
can i ask one question uh

1555
00:59:47,200 --> 00:59:48,880
when you said that you were able to

1556
00:59:48,880 --> 00:59:50,240
prove the

1557
00:59:50,240 --> 00:59:51,040
um

1558
00:59:51,040 --> 00:59:52,880
i forgot the name of this ot like the

1559
00:59:52,880 --> 00:59:55,680
really efficient one securing this uc

1560
00:59:55,680 --> 00:59:56,640
model

1561
00:59:56,640 --> 00:59:57,920
um you also mentioned that in the

1562
00:59:57,920 --> 01:00:00,079
previous talk there was like a subtle

1563
01:00:00,079 --> 01:00:02,720
attack or like an error in the batch ot

1564
01:00:02,720 --> 01:00:04,960
part like how do they relate to each

1565
01:00:04,960 --> 01:00:06,720
other

1566
01:00:06,720 --> 01:00:08,400
oh no i didn't mean that there was an

1567
01:00:08,400 --> 01:00:10,240
error in the previous in the paper

1568
01:00:10,240 --> 01:00:12,319
because then we just talked sorry that

1569
01:00:12,319 --> 01:00:13,680
was not what i was saying i was saying

1570
01:00:13,680 --> 01:00:16,240
that there was an error in um

1571
01:00:16,240 --> 01:00:18,079
in previous versions of the security

1572
01:00:18,079 --> 01:00:19,920
group for the specific choilandi

1573
01:00:19,920 --> 01:00:21,520
protocol

1574
01:00:21,520 --> 01:00:23,119
sorry is that uh

1575
01:00:23,119 --> 01:00:24,480
right okay

1576
01:00:24,480 --> 01:00:26,160
so when you mention that you were able

1577
01:00:26,160 --> 01:00:27,119
to

1578
01:00:27,119 --> 01:00:28,799
uh like

1579
01:00:28,799 --> 01:00:32,559
prove their ot and this uc uc agent

1580
01:00:32,559 --> 01:00:35,839
framework like which protocol were you

1581
01:00:35,839 --> 01:00:38,720
talking is it is it like a fix

1582
01:00:38,720 --> 01:00:41,119
fixed ot protocol or which scheme were

1583
01:00:41,119 --> 01:00:42,400
you mentioning

1584
01:00:42,400 --> 01:00:44,799
no no so so okay so i can what i was

1585
01:00:44,799 --> 01:00:46,559
saying in my my talk was that

1586
01:00:46,559 --> 01:00:48,559
essentially there was there was an issue

1587
01:00:48,559 --> 01:00:50,160
with extraction

1588
01:00:50,160 --> 01:00:52,799
uh in this ot protocol so that's always

1589
01:00:52,799 --> 01:00:54,880
something that you that you have to

1590
01:00:54,880 --> 01:00:56,720
um to prove when you're doing things in

1591
01:00:56,720 --> 01:00:58,319
the uc framework right that you have to

1592
01:00:58,319 --> 01:00:59,680
show that the

1593
01:00:59,680 --> 01:01:01,680
messages of the sender and the choice

1594
01:01:01,680 --> 01:01:03,440
bits of the receiver can be extracted so

1595
01:01:03,440 --> 01:01:05,440
it's always that the difficulty of these

1596
01:01:05,440 --> 01:01:08,160
proofs and in a previous version of a

1597
01:01:08,160 --> 01:01:10,079
proof of this paper this extraction was

1598
01:01:10,079 --> 01:01:11,760
not possible because

1599
01:01:11,760 --> 01:01:13,680
basically you do it using some random

1600
01:01:13,680 --> 01:01:15,440
oracle query and the adversary just

1601
01:01:15,440 --> 01:01:16,880
doesn't have to make that query and then

1602
01:01:16,880 --> 01:01:20,559
you cannot extract but here um

1603
01:01:20,559 --> 01:01:22,640
the point is that uh

1604
01:01:22,640 --> 01:01:25,200
from the adversary's very first message

1605
01:01:25,200 --> 01:01:26,720
in this protocol

1606
01:01:26,720 --> 01:01:28,640
you sort of see what the adversary's

1607
01:01:28,640 --> 01:01:29,920
choice bit is

1608
01:01:29,920 --> 01:01:31,920
um or if the adversary malforms this

1609
01:01:31,920 --> 01:01:34,000
message then you know that

1610
01:01:34,000 --> 01:01:35,950
it cannot distinguish

1611
01:01:35,950 --> 01:01:37,520
[Music]

1612
01:01:37,520 --> 01:01:39,119
whether or not you give it like the

1613
01:01:39,119 --> 01:01:40,640
correct message because it can never

1614
01:01:40,640 --> 01:01:43,119
recover it if it if it makes a

1615
01:01:43,119 --> 01:01:44,960
if it gives you a more form message and

1616
01:01:44,960 --> 01:01:46,640
that way you can you can always

1617
01:01:46,640 --> 01:01:48,559
faithfully carry out this simulation so

1618
01:01:48,559 --> 01:01:50,400
either you can you can really carry it

1619
01:01:50,400 --> 01:01:51,839
out with respect to the choice bit of

1620
01:01:51,839 --> 01:01:53,599
the receiver or you can just carry it

1621
01:01:53,599 --> 01:01:55,280
out in any way and you know that the

1622
01:01:55,280 --> 01:01:57,119
adversary will not be able to tell that

1623
01:01:57,119 --> 01:02:00,000
you've you've just you you were not able

1624
01:02:00,000 --> 01:02:02,079
to to extract

1625
01:02:02,079 --> 01:02:03,280
um

1626
01:02:03,280 --> 01:02:06,640
so that's the idea and um and we

1627
01:02:06,640 --> 01:02:08,319
actually managed to prove the original

1628
01:02:08,319 --> 01:02:10,640
ceo protocol secure here

1629
01:02:10,640 --> 01:02:11,920
okay great

1630
01:02:11,920 --> 01:02:12,450
thank you

1631
01:02:12,450 --> 01:02:15,529
[Music]

1632
01:02:17,760 --> 01:02:20,000
so we don't have any more questions and

1633
01:02:20,000 --> 01:02:22,160
i think we're out of time

1634
01:02:22,160 --> 01:02:23,280
real

1635
01:02:23,280 --> 01:02:24,079
yep

1636
01:02:24,079 --> 01:02:25,039
okay

1637
01:02:25,039 --> 01:02:26,240
uh

1638
01:02:26,240 --> 01:02:31,799
thank you uh for the great talks

1639
01:02:34,000 --> 01:02:37,039
this is the the end of the theory

1640
01:02:37,039 --> 01:02:38,160
session

1641
01:02:38,160 --> 01:02:40,880
thank you for the all participants

1642
01:02:40,880 --> 01:02:44,920
and talk uh speakers

1643
01:02:51,119 --> 01:02:53,200
you

