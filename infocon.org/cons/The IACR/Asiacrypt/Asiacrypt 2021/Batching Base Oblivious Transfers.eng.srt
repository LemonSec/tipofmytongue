1
00:00:00,000 --> 00:00:02,080
today i'll be giving a talk about how to

2
00:00:02,080 --> 00:00:04,240
batch base oblivious transfers correctly

3
00:00:04,240 --> 00:00:05,759
before we get into things i'd just like

4
00:00:05,759 --> 00:00:07,919
to thank my two co-authors mike frazelec

5
00:00:07,919 --> 00:00:10,080
and lance roy so what are we going to be

6
00:00:10,080 --> 00:00:11,519
talking about in this talk

7
00:00:11,519 --> 00:00:13,040
well we're going to largely be talking

8
00:00:13,040 --> 00:00:15,440
about oblivious transfer or we'll often

9
00:00:15,440 --> 00:00:17,760
use for shorthand ot some people may

10
00:00:17,760 --> 00:00:19,600
have heard of chosen message abilities

11
00:00:19,600 --> 00:00:21,439
transfer but for this talk we're going

12
00:00:21,439 --> 00:00:22,960
to be looking at uniform message

13
00:00:22,960 --> 00:00:24,800
abilities transfer

14
00:00:24,800 --> 00:00:27,199
in uniform message oblivious transfer we

15
00:00:27,199 --> 00:00:28,800
have a protocol where two parties

16
00:00:28,800 --> 00:00:30,480
interact with each other

17
00:00:30,480 --> 00:00:32,320
a sender who through the course of the

18
00:00:32,320 --> 00:00:35,280
protocol will receive two messages and

19
00:00:35,280 --> 00:00:38,239
the receiver will input a choice bit and

20
00:00:38,239 --> 00:00:40,559
then receive the message corresponding

21
00:00:40,559 --> 00:00:42,079
to that choice bit for instance if the

22
00:00:42,079 --> 00:00:44,000
receiver inputs a choice bit of zero

23
00:00:44,000 --> 00:00:45,840
they should receive message zero as the

24
00:00:45,840 --> 00:00:48,000
output what security properties do we

25
00:00:48,000 --> 00:00:50,719
see from this protocol well the receiver

26
00:00:50,719 --> 00:00:53,120
should learn no information about the

27
00:00:53,120 --> 00:00:55,680
message that they did not choose so for

28
00:00:55,680 --> 00:00:58,000
instance if the receiver inputs is zero

29
00:00:58,000 --> 00:01:00,399
they receive message zero but they learn

30
00:01:00,399 --> 00:01:02,399
no information about message one the

31
00:01:02,399 --> 00:01:04,239
sender should learn no information about

32
00:01:04,239 --> 00:01:06,560
the receiver's choice bit

33
00:01:06,560 --> 00:01:08,400
and finally as we stated we're

34
00:01:08,400 --> 00:01:11,280
interested in uniform oblivious transfer

35
00:01:11,280 --> 00:01:13,600
so both the messages output from the

36
00:01:13,600 --> 00:01:14,560
system

37
00:01:14,560 --> 00:01:16,960
will be uniformly and independently

38
00:01:16,960 --> 00:01:19,360
distributed where do we see oblivious

39
00:01:19,360 --> 00:01:21,119
transfer being used in the current

40
00:01:21,119 --> 00:01:22,479
landscape

41
00:01:22,479 --> 00:01:24,880
largely we see it being used in

42
00:01:24,880 --> 00:01:27,040
multi-party computation

43
00:01:27,040 --> 00:01:29,200
more specifically possibly in garbled

44
00:01:29,200 --> 00:01:31,360
circuits where certain constructions

45
00:01:31,360 --> 00:01:33,439
require an oblivious transfer for every

46
00:01:33,439 --> 00:01:34,799
and gate

47
00:01:34,799 --> 00:01:37,439
or private set intersection a lot of

48
00:01:37,439 --> 00:01:39,520
these situations require millions of

49
00:01:39,520 --> 00:01:41,360
oblivious transfers

50
00:01:41,360 --> 00:01:43,759
and we know that we can't realize

51
00:01:43,759 --> 00:01:45,360
oblivious transfer from symmetric

52
00:01:45,360 --> 00:01:47,759
operations alone we will eventually have

53
00:01:47,759 --> 00:01:49,759
to use these expensive asymmetric

54
00:01:49,759 --> 00:01:52,079
operations for instance key exchange in

55
00:01:52,079 --> 00:01:54,720
order to realize these millions of ots

56
00:01:54,720 --> 00:01:56,079
now before we get into the meat of

57
00:01:56,079 --> 00:01:57,200
things let's just talk a little bit

58
00:01:57,200 --> 00:01:58,560
about the notation we'll be seeing

59
00:01:58,560 --> 00:02:00,560
through these slides we often will use

60
00:02:00,560 --> 00:02:03,119
for key agreement protocols one of these

61
00:02:03,119 --> 00:02:05,520
two notations either the elliptic curve

62
00:02:05,520 --> 00:02:07,520
diffie-hellman notation where we're

63
00:02:07,520 --> 00:02:10,318
working over a usually prime order group

64
00:02:10,318 --> 00:02:13,280
the two parties have their corresponding

65
00:02:13,280 --> 00:02:15,599
private keys a lowercase a and lowercase

66
00:02:15,599 --> 00:02:16,400
b

67
00:02:16,400 --> 00:02:17,760
and then their two messages that they

68
00:02:17,760 --> 00:02:19,520
send to each other will be their

69
00:02:19,520 --> 00:02:21,200
privates multiplied by the generator for

70
00:02:21,200 --> 00:02:23,200
that group then finally using the

71
00:02:23,200 --> 00:02:25,440
properties of the underlying group they

72
00:02:25,440 --> 00:02:27,440
can arrive at the same key in the end

73
00:02:27,440 --> 00:02:29,599
now since this is really specific to a

74
00:02:29,599 --> 00:02:31,280
certain type of key agreement we

75
00:02:31,280 --> 00:02:34,319
sometimes want to be a bit more abstract

76
00:02:34,319 --> 00:02:36,879
and in that case we'll use just sending

77
00:02:36,879 --> 00:02:38,879
key agreement message 1 and key

78
00:02:38,879 --> 00:02:40,879
agreement message 2. now one thing to

79
00:02:40,879 --> 00:02:43,440
notice is that when we expand out into

80
00:02:43,440 --> 00:02:45,680
the generalized notation

81
00:02:45,680 --> 00:02:49,519
the second keygroup message may rely on

82
00:02:49,519 --> 00:02:52,000
the first message sent in the protocol

83
00:02:52,000 --> 00:02:53,920
now this is not the case for

84
00:02:53,920 --> 00:02:55,840
diffie-hellman but may be the case for

85
00:02:55,840 --> 00:02:58,080
other key agreement protocols now recall

86
00:02:58,080 --> 00:02:59,840
what i said earlier about

87
00:02:59,840 --> 00:03:02,080
a lot of the protocols we use ots in

88
00:03:02,080 --> 00:03:04,720
requiring millions of ots if we had to

89
00:03:04,720 --> 00:03:07,440
perform a key agreement um protocol for

90
00:03:07,440 --> 00:03:09,360
every single one of these ots a lot of

91
00:03:09,360 --> 00:03:11,280
these protocols would end up being

92
00:03:11,280 --> 00:03:13,200
prohibitively expensive so what we want

93
00:03:13,200 --> 00:03:16,159
to do is we want to take some small

94
00:03:16,159 --> 00:03:18,879
number of what we call base ots

95
00:03:18,879 --> 00:03:21,519
for instance 128 or the size of our

96
00:03:21,519 --> 00:03:23,040
security parameter

97
00:03:23,040 --> 00:03:24,640
and then we want to put those into a

98
00:03:24,640 --> 00:03:25,680
protocol

99
00:03:25,680 --> 00:03:28,959
and extend those into some polynomial

100
00:03:28,959 --> 00:03:31,760
size number of realized ots somewhere on

101
00:03:31,760 --> 00:03:33,280
the order of a million ots that we need

102
00:03:33,280 --> 00:03:35,680
for these protocols using cheap

103
00:03:35,680 --> 00:03:37,360
symmetric operations instead of the

104
00:03:37,360 --> 00:03:39,760
expensive asymmetric ones then of course

105
00:03:39,760 --> 00:03:41,360
since we're going to eventually have to

106
00:03:41,360 --> 00:03:43,120
do these expensive operations for our

107
00:03:43,120 --> 00:03:45,760
base ots we can think about optimizing

108
00:03:45,760 --> 00:03:48,640
them as a cohesive unit in what we call

109
00:03:48,640 --> 00:03:51,280
the batch setting where we're sending a

110
00:03:51,280 --> 00:03:54,720
batch of base ots that we extend into

111
00:03:54,720 --> 00:03:58,080
these polynomial sized realized ots as

112
00:03:58,080 --> 00:04:00,560
it turns out the natural way of

113
00:04:00,560 --> 00:04:02,480
optimizing these base oblivious

114
00:04:02,480 --> 00:04:04,080
transfers

115
00:04:04,080 --> 00:04:06,480
lacked a principal treatment even in the

116
00:04:06,480 --> 00:04:08,080
academic literature

117
00:04:08,080 --> 00:04:10,720
and that often led to incorrect

118
00:04:10,720 --> 00:04:12,400
implementations which had their own

119
00:04:12,400 --> 00:04:14,799
security holes what we will do in this

120
00:04:14,799 --> 00:04:17,440
talk is talk about the treatment of how

121
00:04:17,440 --> 00:04:20,238
we correctly optimize abilities

122
00:04:20,238 --> 00:04:21,918
transfers for the batch setting we also

123
00:04:21,918 --> 00:04:24,479
will expand on the known oblivious

124
00:04:24,479 --> 00:04:25,600
transverse construction from our

125
00:04:25,600 --> 00:04:28,400
previous paper in ccs 2020 and we will

126
00:04:28,400 --> 00:04:30,800
optimize the resulting ot

127
00:04:30,800 --> 00:04:32,960
constructions to the batch setting how

128
00:04:32,960 --> 00:04:34,479
we're going to do this is we're going to

129
00:04:34,479 --> 00:04:36,720
first introduce the original protocol

130
00:04:36,720 --> 00:04:38,880
from our ccs paper we're going to talk

131
00:04:38,880 --> 00:04:40,560
about the tools we use to build the

132
00:04:40,560 --> 00:04:43,680
protocol we're going to then talk about

133
00:04:43,680 --> 00:04:46,160
how the natural way of batching doesn't

134
00:04:46,160 --> 00:04:48,479
get the security guarantees that we need

135
00:04:48,479 --> 00:04:50,400
and then we're going to talk about how

136
00:04:50,400 --> 00:04:53,199
to fix this problem let's start off with

137
00:04:53,199 --> 00:04:54,000
a

138
00:04:54,000 --> 00:04:56,240
simple oblivious transfer protocol we

139
00:04:56,240 --> 00:04:58,240
start off just as we would normally

140
00:04:58,240 --> 00:05:00,240
sending a key agreement message between

141
00:05:00,240 --> 00:05:03,199
the two parties then the receiver

142
00:05:03,199 --> 00:05:05,199
is going to have their choice bit c and

143
00:05:05,199 --> 00:05:07,440
they're going to encrypt their key

144
00:05:07,440 --> 00:05:09,440
agreement message whereas in normal

145
00:05:09,440 --> 00:05:11,039
diffie-hellman we would just send the

146
00:05:11,039 --> 00:05:13,360
key grip message over in the plane we're

147
00:05:13,360 --> 00:05:14,960
now going to encrypt that key agreement

148
00:05:14,960 --> 00:05:17,440
message under our choice bit

149
00:05:17,440 --> 00:05:19,440
and send that over to the other party

150
00:05:19,440 --> 00:05:20,720
and then

151
00:05:20,720 --> 00:05:22,400
the receiver is going to treat this just

152
00:05:22,400 --> 00:05:24,800
as a normal iffy home and key agreement

153
00:05:24,800 --> 00:05:26,560
and they're going to output their key as

154
00:05:26,560 --> 00:05:28,160
they would normally sender on the other

155
00:05:28,160 --> 00:05:30,320
hand is going to have two possible key

156
00:05:30,320 --> 00:05:32,000
group messages from this protocol

157
00:05:32,000 --> 00:05:33,520
they're going to have the key agreement

158
00:05:33,520 --> 00:05:35,919
message decrypting under zero

159
00:05:35,919 --> 00:05:37,520
and the key group message decrypting

160
00:05:37,520 --> 00:05:40,960
under one now these are going to then be

161
00:05:40,960 --> 00:05:44,240
the outputs of of our oblivious transfer

162
00:05:44,240 --> 00:05:46,960
the receiver is going to have his choice

163
00:05:46,960 --> 00:05:50,000
bit which is going to correspond to his

164
00:05:50,000 --> 00:05:52,240
message and then the sender is going to

165
00:05:52,240 --> 00:05:54,400
have two possible key grid messages one

166
00:05:54,400 --> 00:05:56,000
of them corresponding to the one the

167
00:05:56,000 --> 00:05:58,560
receiver has and then the second one

168
00:05:58,560 --> 00:06:01,199
which is going to be a key rear message

169
00:06:01,199 --> 00:06:04,240
that the receiver can't have a

170
00:06:04,240 --> 00:06:06,319
knowledge of the secret to so in that

171
00:06:06,319 --> 00:06:08,639
situation the sender will end up with

172
00:06:08,639 --> 00:06:10,639
two key agreement key outputs whereas

173
00:06:10,639 --> 00:06:13,120
the receiver can only possibly have one

174
00:06:13,120 --> 00:06:15,199
what's actually going on here as we said

175
00:06:15,199 --> 00:06:16,960
earlier the sender is going to send

176
00:06:16,960 --> 00:06:18,800
their key drain message they're going to

177
00:06:18,800 --> 00:06:21,440
sample their secret and send their key

178
00:06:21,440 --> 00:06:23,360
grant message as they would normally the

179
00:06:23,360 --> 00:06:25,280
receiver is going to sample their key

180
00:06:25,280 --> 00:06:28,000
agreement message as they would normally

181
00:06:28,000 --> 00:06:29,120
and they're going to have their choice

182
00:06:29,120 --> 00:06:30,639
bit they're then going to

183
00:06:30,639 --> 00:06:33,120
wrap their key green message

184
00:06:33,120 --> 00:06:35,759
inside for instance in this case an

185
00:06:35,759 --> 00:06:37,520
ideal cipher and then they're going to

186
00:06:37,520 --> 00:06:40,160
send it over to the other party this is

187
00:06:40,160 --> 00:06:42,479
a very specific example but when we said

188
00:06:42,479 --> 00:06:44,319
earlier is that we're just taking our

189
00:06:44,319 --> 00:06:46,319
second key group message and wrapping it

190
00:06:46,319 --> 00:06:48,160
inside of something an ideal cipher is a

191
00:06:48,160 --> 00:06:51,280
very strong primitive that we can use

192
00:06:51,280 --> 00:06:53,440
but what about something a bit weaker

193
00:06:53,440 --> 00:06:56,560
what about something like a weak cipher

194
00:06:56,560 --> 00:06:58,400
in this situation we may want to change

195
00:06:58,400 --> 00:07:00,240
our notation a little bit instead of

196
00:07:00,240 --> 00:07:02,400
encrypting a message we're going to

197
00:07:02,400 --> 00:07:05,759
program a message basically we're saying

198
00:07:05,759 --> 00:07:08,479
that at this input we have this other

199
00:07:08,479 --> 00:07:10,319
output and then of course

200
00:07:10,319 --> 00:07:13,039
during the output time we're going to

201
00:07:13,039 --> 00:07:15,039
evaluate that function that we send

202
00:07:15,039 --> 00:07:17,039
across we're going to

203
00:07:17,039 --> 00:07:19,919
take our function programmed at c

204
00:07:19,919 --> 00:07:21,680
and we're going to evaluate it at the

205
00:07:21,680 --> 00:07:24,080
two possible choice bits what could some

206
00:07:24,080 --> 00:07:25,840
of the properties be that we need from

207
00:07:25,840 --> 00:07:28,400
this weaker ideal cipher on the first

208
00:07:28,400 --> 00:07:31,840
hand we have that we send a message

209
00:07:31,840 --> 00:07:33,599
specifically the key agreement message

210
00:07:33,599 --> 00:07:35,120
encrypted under c

211
00:07:35,120 --> 00:07:38,000
and then we output the corresponding key

212
00:07:38,000 --> 00:07:40,319
under each of the two choice bits

213
00:07:40,319 --> 00:07:42,000
looking at this again we're going to

214
00:07:42,000 --> 00:07:44,639
have our ideal ciphers encryption

215
00:07:44,639 --> 00:07:46,319
basically we're we're creating a

216
00:07:46,319 --> 00:07:47,680
ciphertext

217
00:07:47,680 --> 00:07:49,840
and we are sending it over to the other

218
00:07:49,840 --> 00:07:52,800
party in this case we just want to

219
00:07:52,800 --> 00:07:55,440
have some weak property to call

220
00:07:55,440 --> 00:07:56,639
programming

221
00:07:56,639 --> 00:07:59,759
where we say that at c we have our key

222
00:07:59,759 --> 00:08:01,680
agreement output and then finally as we

223
00:08:01,680 --> 00:08:03,039
saw earlier

224
00:08:03,039 --> 00:08:04,800
since we're thinking of this kind of as

225
00:08:04,800 --> 00:08:06,879
a a function that we're sending across

226
00:08:06,879 --> 00:08:09,840
or a representation of a function

227
00:08:09,840 --> 00:08:11,759
we program at an input and then we

228
00:08:11,759 --> 00:08:14,160
evaluate at another input so in this

229
00:08:14,160 --> 00:08:15,919
case we're going to

230
00:08:15,919 --> 00:08:19,120
evaluate our message at one of the

231
00:08:19,120 --> 00:08:20,639
possible keys

232
00:08:20,639 --> 00:08:22,319
and then we're going to treat it as we

233
00:08:22,319 --> 00:08:24,400
would normally as a keyground message

234
00:08:24,400 --> 00:08:26,960
well what do we actually need to make

235
00:08:26,960 --> 00:08:28,479
this proof work well if we recall

236
00:08:28,479 --> 00:08:30,479
correctly we have to hide the receiver's

237
00:08:30,479 --> 00:08:31,919
choice bit

238
00:08:31,919 --> 00:08:33,120
we have to

239
00:08:33,120 --> 00:08:35,360
hide the message that wasn't chosen from

240
00:08:35,360 --> 00:08:36,799
the receiver

241
00:08:36,799 --> 00:08:39,360
then for simulatability properties we

242
00:08:39,360 --> 00:08:41,200
need to extract the adversary's choice

243
00:08:41,200 --> 00:08:44,080
bit and have a back door so that we can

244
00:08:44,080 --> 00:08:47,040
program on both choice bits so for

245
00:08:47,040 --> 00:08:50,080
instance we can know the key current

246
00:08:50,080 --> 00:08:53,279
messages for both valuation at zero and

247
00:08:53,279 --> 00:08:55,279
evaluation at one for the first of these

248
00:08:55,279 --> 00:08:56,640
we need to hide the receiver's choice

249
00:08:56,640 --> 00:08:59,279
bit what we need is that if we program

250
00:08:59,279 --> 00:09:02,160
on or we create we construct

251
00:09:02,160 --> 00:09:04,320
this message we're sending across on a

252
00:09:04,320 --> 00:09:06,959
uniform keygroup message or a uniform

253
00:09:06,959 --> 00:09:09,200
bit string that when it comes to

254
00:09:09,200 --> 00:09:10,800
evaluation time

255
00:09:10,800 --> 00:09:12,480
both of the outputs

256
00:09:12,480 --> 00:09:14,480
look like a uniform function

257
00:09:14,480 --> 00:09:16,560
the reason this is important is because

258
00:09:16,560 --> 00:09:20,640
if the sender can distinguish between a

259
00:09:20,640 --> 00:09:22,480
key agreement message for instance

260
00:09:22,480 --> 00:09:24,800
and a non-key agreement message

261
00:09:24,800 --> 00:09:26,800
then it will be trivial for them to tell

262
00:09:26,800 --> 00:09:29,040
which of the two bits receiver chose as

263
00:09:29,040 --> 00:09:30,880
its choice bit we need to hide the

264
00:09:30,880 --> 00:09:33,440
non-chosen message so for instance if

265
00:09:33,440 --> 00:09:36,240
the receiver chooses the choice bit zero

266
00:09:36,240 --> 00:09:38,959
we need to hide the message they didn't

267
00:09:38,959 --> 00:09:41,120
choose we need to hide message one in

268
00:09:41,120 --> 00:09:43,519
this situation thinking of this still as

269
00:09:43,519 --> 00:09:46,800
key agreement we need it to be the case

270
00:09:46,800 --> 00:09:48,240
that the

271
00:09:48,240 --> 00:09:50,480
sender's output for instance after

272
00:09:50,480 --> 00:09:52,880
sending it through their the key phase

273
00:09:52,880 --> 00:09:54,880
of their key dream scheme

274
00:09:54,880 --> 00:09:58,080
we need that that message is uniform

275
00:09:58,080 --> 00:10:00,560
after they send it through their weak

276
00:10:00,560 --> 00:10:03,360
random function in this case the key

277
00:10:03,360 --> 00:10:05,279
output part of their key agreement if

278
00:10:05,279 --> 00:10:07,040
this weren't the case of course then the

279
00:10:07,040 --> 00:10:09,040
receiver may be able to learn extra

280
00:10:09,040 --> 00:10:11,600
information about the second message

281
00:10:11,600 --> 00:10:13,440
finally we need some simulation

282
00:10:13,440 --> 00:10:15,760
properties we need to be able to

283
00:10:15,760 --> 00:10:17,519
look at the message that we received

284
00:10:17,519 --> 00:10:20,079
from receiver and extract the choice bit

285
00:10:20,079 --> 00:10:23,120
even though we've hidden the choice bit

286
00:10:23,120 --> 00:10:25,680
by our other property similarly we need

287
00:10:25,680 --> 00:10:27,600
to have it so that we can affect the

288
00:10:27,600 --> 00:10:29,920
outputs of the

289
00:10:29,920 --> 00:10:32,320
evaluation of these functions even

290
00:10:32,320 --> 00:10:35,440
though we specifically stated that those

291
00:10:35,440 --> 00:10:38,000
outputs should be outside of our control

292
00:10:38,000 --> 00:10:40,399
now this is just simulator magic we can

293
00:10:40,399 --> 00:10:42,399
use the properties of for instance a

294
00:10:42,399 --> 00:10:44,880
random oracle or an ideal cipher for

295
00:10:44,880 --> 00:10:47,440
instance to achieve these now

296
00:10:47,440 --> 00:10:49,680
this tool that we've been working with

297
00:10:49,680 --> 00:10:51,760
is what we call a programmable once

298
00:10:51,760 --> 00:10:53,519
public function now this seems like a

299
00:10:53,519 --> 00:10:56,160
mouthful to start but let's break down

300
00:10:56,160 --> 00:10:58,399
why we call it this so we call it

301
00:10:58,399 --> 00:11:01,519
programmable once because as we saw

302
00:11:01,519 --> 00:11:04,160
earlier a party can program

303
00:11:04,160 --> 00:11:06,000
the output of the function for exactly

304
00:11:06,000 --> 00:11:07,360
one input

305
00:11:07,360 --> 00:11:10,320
in other words they choose an input

306
00:11:10,320 --> 00:11:12,959
and they choose the corresponding output

307
00:11:12,959 --> 00:11:15,440
but for any other input

308
00:11:15,440 --> 00:11:17,680
they should not be able to control the

309
00:11:17,680 --> 00:11:20,000
the output of the function finally it's

310
00:11:20,000 --> 00:11:22,240
a public function because as we saw in

311
00:11:22,240 --> 00:11:24,959
our protocol we send the function in the

312
00:11:24,959 --> 00:11:27,760
clear so to say so that anybody who sees

313
00:11:27,760 --> 00:11:29,440
the function can evaluate it on their

314
00:11:29,440 --> 00:11:30,959
own what are some of the restrictions we

315
00:11:30,959 --> 00:11:33,200
spoke earlier about some restrictions on

316
00:11:33,200 --> 00:11:36,560
the input output pairs for our oblivious

317
00:11:36,560 --> 00:11:39,040
transfer scheme as we stated earlier if

318
00:11:39,040 --> 00:11:41,839
the adversary can distinguish between a

319
00:11:41,839 --> 00:11:43,279
key grant message

320
00:11:43,279 --> 00:11:45,760
and a non-key agreement message for

321
00:11:45,760 --> 00:11:47,440
instance looking over uniform bid

322
00:11:47,440 --> 00:11:49,040
strings

323
00:11:49,040 --> 00:11:51,279
then they'll easily be able to determine

324
00:11:51,279 --> 00:11:54,480
whether or not the receiver chose one or

325
00:11:54,480 --> 00:11:57,120
the other choice bits what this means is

326
00:11:57,120 --> 00:12:00,000
is that the key error messages that we

327
00:12:00,000 --> 00:12:02,639
wrap before sending it across

328
00:12:02,639 --> 00:12:04,320
should be uniform so we can hide that

329
00:12:04,320 --> 00:12:06,240
choice bit the thing is here is that we

330
00:12:06,240 --> 00:12:08,480
need this to be the case looking at this

331
00:12:08,480 --> 00:12:11,279
for from our generalized key agreement

332
00:12:11,279 --> 00:12:13,519
schemes where the second message may

333
00:12:13,519 --> 00:12:14,880
rely on the

334
00:12:14,880 --> 00:12:16,399
first message that's sent in the key

335
00:12:16,399 --> 00:12:18,320
agreement this still needs to be the

336
00:12:18,320 --> 00:12:22,000
case even if there is some correlation

337
00:12:22,000 --> 00:12:24,240
between the first message sent in the

338
00:12:24,240 --> 00:12:26,800
protocol and the response message

339
00:12:26,800 --> 00:12:29,120
which is certainly the case for

340
00:12:29,120 --> 00:12:31,440
diffie-hellman where the two messages

341
00:12:31,440 --> 00:12:33,279
sent are independent of each other we've

342
00:12:33,279 --> 00:12:35,600
been talking a lot about this tool a

343
00:12:35,600 --> 00:12:37,760
programmable once public function but

344
00:12:37,760 --> 00:12:39,920
what do they look like uh well to start

345
00:12:39,920 --> 00:12:42,720
let's go over the seminal construction

346
00:12:42,720 --> 00:12:45,760
from our paper from ccs let's start with

347
00:12:45,760 --> 00:12:47,600
something we're familiar with let's

348
00:12:47,600 --> 00:12:50,000
start with just a normal two-round

349
00:12:50,000 --> 00:12:52,240
feistel network we have that this can

350
00:12:52,240 --> 00:12:54,880
realize an ideal cipher at eight rounds

351
00:12:54,880 --> 00:12:56,959
but of course with security loss now but

352
00:12:56,959 --> 00:12:58,880
remember we may not need the strong

353
00:12:58,880 --> 00:13:01,360
properties of an ideal cipher we may be

354
00:13:01,360 --> 00:13:03,440
looking at this from the direction of a

355
00:13:03,440 --> 00:13:06,639
weak cipher as it turns out we can take

356
00:13:06,639 --> 00:13:09,120
this two-round feistel network which we

357
00:13:09,120 --> 00:13:11,760
know doesn't realize an ideal cipher but

358
00:13:11,760 --> 00:13:13,760
since we have these weaker properties we

359
00:13:13,760 --> 00:13:16,240
need from the system we actually can use

360
00:13:16,240 --> 00:13:18,000
this to design

361
00:13:18,000 --> 00:13:20,399
the tools we need to realize this

362
00:13:20,399 --> 00:13:22,240
oblivious transfer protocol what we've

363
00:13:22,240 --> 00:13:23,920
done here is that in the original

364
00:13:23,920 --> 00:13:26,000
protocol we send in the first part of

365
00:13:26,000 --> 00:13:28,320
the key to the first and then the second

366
00:13:28,320 --> 00:13:30,240
part of the key to the second but in

367
00:13:30,240 --> 00:13:32,560
this situation we've replaced these with

368
00:13:32,560 --> 00:13:34,959
just random oracles two different random

369
00:13:34,959 --> 00:13:36,560
oracles to be specific

370
00:13:36,560 --> 00:13:38,240
and the keys have just been replaced

371
00:13:38,240 --> 00:13:41,680
with the choice bits for the receiver

372
00:13:41,680 --> 00:13:43,920
and then finally our output what we

373
00:13:43,920 --> 00:13:46,399
actually send from the receiver to the

374
00:13:46,399 --> 00:13:49,199
sender this wrapping of our key

375
00:13:49,199 --> 00:13:50,720
agreement message

376
00:13:50,720 --> 00:13:53,440
is just the two parts of the output of

377
00:13:53,440 --> 00:13:56,000
the feistel cipher what we've shown in

378
00:13:56,000 --> 00:13:59,040
our paper is that we can optimize this

379
00:13:59,040 --> 00:14:01,760
construction where in the original paper

380
00:14:01,760 --> 00:14:03,839
we were looking at the situation for

381
00:14:03,839 --> 00:14:05,440
large inputs

382
00:14:05,440 --> 00:14:08,880
specifically our keys that we use can be

383
00:14:08,880 --> 00:14:10,800
exponentially large

384
00:14:10,800 --> 00:14:13,360
but now that we're working with just two

385
00:14:13,360 --> 00:14:15,600
choices for our keys we've optimized

386
00:14:15,600 --> 00:14:18,000
this situation by replacing the second

387
00:14:18,000 --> 00:14:19,839
random oracle with an injection to the

388
00:14:19,839 --> 00:14:21,920
finite field which ends up giving us a

389
00:14:21,920 --> 00:14:23,760
much more efficient implementation

390
00:14:23,760 --> 00:14:25,600
here's a new one

391
00:14:25,600 --> 00:14:28,000
in this case we're looking at the usual

392
00:14:28,000 --> 00:14:31,440
double xor evan monsoor cipher and of

393
00:14:31,440 --> 00:14:33,279
course in this situation we're going to

394
00:14:33,279 --> 00:14:35,279
be instantiating with an ideal

395
00:14:35,279 --> 00:14:36,800
permutation

396
00:14:36,800 --> 00:14:39,279
and just as we saw earlier

397
00:14:39,279 --> 00:14:41,839
these stronger properties that we need

398
00:14:41,839 --> 00:14:44,560
aren't always going to be necessary when

399
00:14:44,560 --> 00:14:47,199
just building this weaker cipher this

400
00:14:47,199 --> 00:14:49,680
programmable once public function

401
00:14:49,680 --> 00:14:51,600
in this situation

402
00:14:51,600 --> 00:14:54,480
we can drop the first xor as we saw over

403
00:14:54,480 --> 00:14:56,880
here before we have two parts of the key

404
00:14:56,880 --> 00:14:59,440
which we send in different parts of the

405
00:14:59,440 --> 00:15:00,639
different points of the cipher in this

406
00:15:00,639 --> 00:15:01,839
situation

407
00:15:01,839 --> 00:15:04,000
we're replacing the key with just the

408
00:15:04,000 --> 00:15:07,440
choice bit that the receiver uses

409
00:15:07,440 --> 00:15:09,920
and then our output from the cipher is

410
00:15:09,920 --> 00:15:12,959
what we send is our message our wrapping

411
00:15:12,959 --> 00:15:14,959
of our key agreement message in our

412
00:15:14,959 --> 00:15:16,480
paper we actually showed that this

413
00:15:16,480 --> 00:15:19,199
construction realized the properties we

414
00:15:19,199 --> 00:15:21,519
need to give us our oblivious transfer

415
00:15:21,519 --> 00:15:23,040
protocol

416
00:15:23,040 --> 00:15:25,519
finally we have a construction that was

417
00:15:25,519 --> 00:15:26,480
introduced

418
00:15:26,480 --> 00:15:29,440
by mosny and rindahl in their endemic ot

419
00:15:29,440 --> 00:15:30,320
paper

420
00:15:30,320 --> 00:15:32,399
in this situation we have what looks

421
00:15:32,399 --> 00:15:35,920
like a one round feistel cipher however

422
00:15:35,920 --> 00:15:37,680
it extends a little bit differently

423
00:15:37,680 --> 00:15:40,399
basically this is looking for one out of

424
00:15:40,399 --> 00:15:41,680
two ot

425
00:15:41,680 --> 00:15:44,160
whereas if we want to extend this to one

426
00:15:44,160 --> 00:15:46,240
out of not it's going to expand

427
00:15:46,240 --> 00:15:48,240
differently than what we saw from the

428
00:15:48,240 --> 00:15:50,240
feistel construction as we see here

429
00:15:50,240 --> 00:15:52,720
there are two messages message one and

430
00:15:52,720 --> 00:15:54,560
message zero

431
00:15:54,560 --> 00:15:56,639
but when we extend this to one out of

432
00:15:56,639 --> 00:15:59,360
not we extend this to n messages

433
00:15:59,360 --> 00:16:01,040
which means that it doesn't efficiently

434
00:16:01,040 --> 00:16:04,639
extend to exponentially sized n as we

435
00:16:04,639 --> 00:16:06,639
may see for the two previous

436
00:16:06,639 --> 00:16:09,680
constructions then in our paper we

437
00:16:09,680 --> 00:16:11,120
showed this

438
00:16:11,120 --> 00:16:12,480
construction

439
00:16:12,480 --> 00:16:15,040
presented by bosnian rindell

440
00:16:15,040 --> 00:16:18,320
was actually a special case of

441
00:16:18,320 --> 00:16:21,519
the protocol from our previous paper now

442
00:16:21,519 --> 00:16:23,360
stepping back a little bit we talked

443
00:16:23,360 --> 00:16:24,720
about how

444
00:16:24,720 --> 00:16:27,120
often we need millions of ots in order

445
00:16:27,120 --> 00:16:29,600
to realize that these protocols that we

446
00:16:29,600 --> 00:16:32,079
want to use oblivious transfers in and

447
00:16:32,079 --> 00:16:34,639
as such we use this what we call ot

448
00:16:34,639 --> 00:16:36,720
extension to take a small number of ots

449
00:16:36,720 --> 00:16:39,199
in and output a large number of rotis

450
00:16:39,199 --> 00:16:41,279
then of course we're going to want to

451
00:16:41,279 --> 00:16:44,000
look at how do we optimize

452
00:16:44,000 --> 00:16:47,040
those base oblivious transfers in what

453
00:16:47,040 --> 00:16:49,199
we call the batch setting so looking

454
00:16:49,199 --> 00:16:51,519
looking just at our running protocol we

455
00:16:51,519 --> 00:16:53,759
notice that we're going to be sending a

456
00:16:53,759 --> 00:16:55,759
lot of messages back and forth we're

457
00:16:55,759 --> 00:16:57,600
going to have key agreement message one

458
00:16:57,600 --> 00:16:59,360
key here message two key agreement

459
00:16:59,360 --> 00:17:01,360
message three so on and so forth up to

460
00:17:01,360 --> 00:17:04,720
kappa uh or security parameter uh key

461
00:17:04,720 --> 00:17:07,119
group messages this is pretty expensive

462
00:17:07,119 --> 00:17:10,079
we're going to have to do kappa

463
00:17:10,079 --> 00:17:12,799
full key agreements but what's this

464
00:17:12,799 --> 00:17:14,559
we're sending a new

465
00:17:14,559 --> 00:17:16,400
keygram message for each of the

466
00:17:16,400 --> 00:17:19,359
individual transfers from the sender

467
00:17:19,359 --> 00:17:21,359
now we may recall

468
00:17:21,359 --> 00:17:24,160
that a lot of protocols for instance

469
00:17:24,160 --> 00:17:26,160
instantiations of the diffie-hellman

470
00:17:26,160 --> 00:17:29,280
protocol will reuse a public key for

471
00:17:29,280 --> 00:17:32,240
multiple connections and this of course

472
00:17:32,240 --> 00:17:34,799
leads to what we are going to call the

473
00:17:34,799 --> 00:17:37,280
naive way of batching the abilities

474
00:17:37,280 --> 00:17:39,520
transfer protocols where what we do is

475
00:17:39,520 --> 00:17:41,440
is we just send one key drain message

476
00:17:41,440 --> 00:17:43,520
which we then use across all of the

477
00:17:43,520 --> 00:17:45,120
oblivious transfers in the batch

478
00:17:45,120 --> 00:17:48,080
although the receiver may vary their key

479
00:17:48,080 --> 00:17:50,400
agreement message specifically sampling

480
00:17:50,400 --> 00:17:52,799
a new secret each time the sender only

481
00:17:52,799 --> 00:17:54,799
sends one key group message at the very

482
00:17:54,799 --> 00:17:57,360
beginning this not only drops the number

483
00:17:57,360 --> 00:18:00,000
of group elements sent from from two

484
00:18:00,000 --> 00:18:03,440
kappa to one kappa plus one but it also

485
00:18:03,440 --> 00:18:05,200
makes it so that the sender has to

486
00:18:05,200 --> 00:18:07,840
perform fewer group operations to start

487
00:18:07,840 --> 00:18:10,400
as we teased at earlier there is

488
00:18:10,400 --> 00:18:12,240
actually a problem with this style of

489
00:18:12,240 --> 00:18:15,280
naive or natural batching so let's walk

490
00:18:15,280 --> 00:18:17,200
through that as we saw earlier the

491
00:18:17,200 --> 00:18:18,640
sender is going to give their key

492
00:18:18,640 --> 00:18:20,799
agreement message over to the receiver

493
00:18:20,799 --> 00:18:23,360
this receiver is going to

494
00:18:23,360 --> 00:18:25,760
generate two key agreement messages as

495
00:18:25,760 --> 00:18:27,440
outputs then of course it's going to

496
00:18:27,440 --> 00:18:31,200
send the same message for each oblivious

497
00:18:31,200 --> 00:18:33,440
transfer instance in a batch

498
00:18:33,440 --> 00:18:36,240
so remember as we saw earlier the

499
00:18:36,240 --> 00:18:38,799
messages sent from the receiver had a

500
00:18:38,799 --> 00:18:40,960
different key each time in the honest

501
00:18:40,960 --> 00:18:43,600
evaluation but in this evaluation

502
00:18:43,600 --> 00:18:46,320
we're going to be sending the same

503
00:18:46,320 --> 00:18:48,799
secret so for instance

504
00:18:48,799 --> 00:18:51,200
the same key agreement message same

505
00:18:51,200 --> 00:18:53,120
wrapping of that key group message for

506
00:18:53,120 --> 00:18:55,440
each instance of oblivious transfer

507
00:18:55,440 --> 00:18:58,400
inside of a batch but wait a second this

508
00:18:58,400 --> 00:18:59,760
caused something weird to happen when

509
00:18:59,760 --> 00:19:02,880
the sender evaluates the message that i

510
00:19:02,880 --> 00:19:04,640
received from this from the

511
00:19:04,640 --> 00:19:06,480
receiver then the sender is going to get

512
00:19:06,480 --> 00:19:07,600
the same

513
00:19:07,600 --> 00:19:10,080
two outputs for each of the oblivious

514
00:19:10,080 --> 00:19:12,320
transfers now this is very different

515
00:19:12,320 --> 00:19:15,200
from our original situation where in the

516
00:19:15,200 --> 00:19:18,080
original without any optimization

517
00:19:18,080 --> 00:19:20,160
each of the oblivious transfer protocols

518
00:19:20,160 --> 00:19:21,840
that we had in the batch were

519
00:19:21,840 --> 00:19:24,400
independent there was no way to cause

520
00:19:24,400 --> 00:19:27,360
any hard correlations between each of

521
00:19:27,360 --> 00:19:29,520
the protocols now what we've done is

522
00:19:29,520 --> 00:19:33,840
allowed the receiver to cause every one

523
00:19:33,840 --> 00:19:36,400
of those ot outputs to be the same

524
00:19:36,400 --> 00:19:39,039
across each of the protocol instances

525
00:19:39,039 --> 00:19:41,440
which could be disastrous

526
00:19:41,440 --> 00:19:43,679
we could cause some more complex

527
00:19:43,679 --> 00:19:45,600
correlations if we wanted to but as it

528
00:19:45,600 --> 00:19:47,679
turns out this simple

529
00:19:47,679 --> 00:19:49,360
attack on the protocol

530
00:19:49,360 --> 00:19:51,039
affects certain oblivious transfer

531
00:19:51,039 --> 00:19:53,200
extension protocols in a devastating way

532
00:19:53,200 --> 00:19:55,600
let's actually see this in action

533
00:19:55,600 --> 00:19:57,120
we're going to be looking at a case

534
00:19:57,120 --> 00:20:00,480
study is the oos ot extension protocol

535
00:20:00,480 --> 00:20:01,840
in this situation

536
00:20:01,840 --> 00:20:04,799
as we saw earlier bob in this and the ot

537
00:20:04,799 --> 00:20:08,400
protocols acting as the sender but in

538
00:20:08,400 --> 00:20:10,880
the larger ot extension protocol acting

539
00:20:10,880 --> 00:20:12,880
as the receiver is going to engage with

540
00:20:12,880 --> 00:20:17,440
alice in a series of ot protocols then

541
00:20:17,440 --> 00:20:19,200
what bob is going to do is going to take

542
00:20:19,200 --> 00:20:20,559
the output

543
00:20:20,559 --> 00:20:22,159
of each of these

544
00:20:22,159 --> 00:20:25,120
protocol evaluations for instance

545
00:20:25,120 --> 00:20:28,400
of course in this in uniform ot bob is

546
00:20:28,400 --> 00:20:30,320
going to receive two uniform messages

547
00:20:30,320 --> 00:20:31,919
alice is going to receive one of them

548
00:20:31,919 --> 00:20:33,679
what bob's going to do is he's going to

549
00:20:33,679 --> 00:20:35,840
take his two received messages from each

550
00:20:35,840 --> 00:20:37,520
of the protocols he's going to shove

551
00:20:37,520 --> 00:20:41,039
them into two prgs xor the output and

552
00:20:41,039 --> 00:20:44,240
then put it in a column of an array so

553
00:20:44,240 --> 00:20:46,960
using our using our colors we have that

554
00:20:46,960 --> 00:20:49,440
the first ot protocol defines the first

555
00:20:49,440 --> 00:20:51,919
column of the matrix the second ot

556
00:20:51,919 --> 00:20:53,600
protocol defines the second column of

557
00:20:53,600 --> 00:20:54,720
the matrix

558
00:20:54,720 --> 00:20:56,960
and so on until we reach the last

559
00:20:56,960 --> 00:20:58,960
evaluation of the protocol

560
00:20:58,960 --> 00:21:01,520
which then defines the last column of

561
00:21:01,520 --> 00:21:02,400
the matrix

562
00:21:02,400 --> 00:21:04,799
using our attack that we have previously

563
00:21:04,799 --> 00:21:07,200
where bob can cause both the messages to

564
00:21:07,200 --> 00:21:09,280
be the same across all of the protocols

565
00:21:09,280 --> 00:21:11,440
so internally to a single ot protocol

566
00:21:11,440 --> 00:21:14,480
the messages are uniform and independent

567
00:21:14,480 --> 00:21:17,200
across all the protocol evaluations the

568
00:21:17,200 --> 00:21:19,200
messages are going to be the same it

569
00:21:19,200 --> 00:21:20,880
could be the same message zero across

570
00:21:20,880 --> 00:21:22,559
all the protocols and the same message

571
00:21:22,559 --> 00:21:24,240
one across all the protocols looking

572
00:21:24,240 --> 00:21:26,320
just at a single protocol we're still

573
00:21:26,320 --> 00:21:27,760
going to have that uniform and

574
00:21:27,760 --> 00:21:30,320
independence property what this causes

575
00:21:30,320 --> 00:21:32,400
is it causes all of the columns of our

576
00:21:32,400 --> 00:21:35,520
matrix to be the same what we then do is

577
00:21:35,520 --> 00:21:37,280
we're going to take another matrix of

578
00:21:37,280 --> 00:21:39,440
our choice bits in this case it's going

579
00:21:39,440 --> 00:21:41,520
to be an error correcting code of our

580
00:21:41,520 --> 00:21:42,720
choice bits

581
00:21:42,720 --> 00:21:44,000
so for instance an error correcting code

582
00:21:44,000 --> 00:21:45,840
evaluated at zero in our correcting code

583
00:21:45,840 --> 00:21:48,159
evaluated at one which then populate the

584
00:21:48,159 --> 00:21:50,799
rows of a second matrix and then we're

585
00:21:50,799 --> 00:21:53,760
going to send their xor over to alice

586
00:21:53,760 --> 00:21:57,760
but wait since every single column in k

587
00:21:57,760 --> 00:22:00,320
is the same then let's say column one

588
00:22:00,320 --> 00:22:02,799
has a zero in the first index

589
00:22:02,799 --> 00:22:04,480
then column two will have a zero in the

590
00:22:04,480 --> 00:22:06,480
first index since they're identical

591
00:22:06,480 --> 00:22:07,760
column three will have a zero in the

592
00:22:07,760 --> 00:22:10,080
first index so on and so forth which

593
00:22:10,080 --> 00:22:12,080
means that the first index across all

594
00:22:12,080 --> 00:22:14,799
columns will be zero but what that means

595
00:22:14,799 --> 00:22:16,720
is that every single

596
00:22:16,720 --> 00:22:18,720
row in this matrix is going to be

597
00:22:18,720 --> 00:22:21,280
identical so when we xor it with our

598
00:22:21,280 --> 00:22:23,840
choice bit matrix either if the row is

599
00:22:23,840 --> 00:22:26,799
all zeros it'll leave our choice bit

600
00:22:26,799 --> 00:22:29,280
code alone and if it's all ones it'll do

601
00:22:29,280 --> 00:22:32,080
the bitwise complement of the choice bit

602
00:22:32,080 --> 00:22:34,960
code but wait a second if the two

603
00:22:34,960 --> 00:22:37,440
messages are not bitwise complements

604
00:22:37,440 --> 00:22:39,760
then it's immediately obvious which of

605
00:22:39,760 --> 00:22:42,320
the two code words we're looking at in

606
00:22:42,320 --> 00:22:43,919
each of the rows we can use this

607
00:22:43,919 --> 00:22:45,440
information to

608
00:22:45,440 --> 00:22:47,760
learn which of the two choice bits

609
00:22:47,760 --> 00:22:50,880
corresponds to each row this

610
00:22:50,880 --> 00:22:54,320
specifically relies on the two code

611
00:22:54,320 --> 00:22:55,760
words the code word for zero and the

612
00:22:55,760 --> 00:22:58,720
code word for one not being complements

613
00:22:58,720 --> 00:23:01,200
because if they are complements then we

614
00:23:01,200 --> 00:23:03,360
learn either the code word or its

615
00:23:03,360 --> 00:23:04,960
complement for each one but since we

616
00:23:04,960 --> 00:23:07,360
can't discern between the two we aren't

617
00:23:07,360 --> 00:23:10,000
able to learn the choice bits this is a

618
00:23:10,000 --> 00:23:13,200
specific attack on the oos ot extension

619
00:23:13,200 --> 00:23:16,000
however the kosot extension does use

620
00:23:16,000 --> 00:23:19,039
repetition codes as their er correcting

621
00:23:19,039 --> 00:23:21,520
code which are complements of each other

622
00:23:21,520 --> 00:23:23,679
but maybe there could be more complex

623
00:23:23,679 --> 00:23:26,480
correlations that can be induced by a

624
00:23:26,480 --> 00:23:29,360
malicious receiver so how do we solve

625
00:23:29,360 --> 00:23:31,039
this problem what we did was is we

626
00:23:31,039 --> 00:23:33,360
bashed it in a naive way

627
00:23:33,360 --> 00:23:35,360
but we allowed for

628
00:23:35,360 --> 00:23:37,679
strong correlations between each of the

629
00:23:37,679 --> 00:23:40,640
ot instances specifically in this case

630
00:23:40,640 --> 00:23:43,120
we allowed each of the ot instances to

631
00:23:43,120 --> 00:23:45,120
be influenced in a way that they

632
00:23:45,120 --> 00:23:47,600
outputted the same value across each one

633
00:23:47,600 --> 00:23:49,360
of the ot instances this of course

634
00:23:49,360 --> 00:23:51,440
wasn't possible in the original case

635
00:23:51,440 --> 00:23:54,000
because in the original protocol we had

636
00:23:54,000 --> 00:23:56,400
each of the ot instances independent of

637
00:23:56,400 --> 00:23:58,320
each other what we want to do is we want

638
00:23:58,320 --> 00:24:00,960
to stop the adversary from creating

639
00:24:00,960 --> 00:24:03,679
these correlations by separating each of

640
00:24:03,679 --> 00:24:05,919
the oblivious transfer instances and how

641
00:24:05,919 --> 00:24:08,159
did we do this we just took our key

642
00:24:08,159 --> 00:24:10,480
agreement protocol and supplemented it

643
00:24:10,480 --> 00:24:11,279
with

644
00:24:11,279 --> 00:24:13,919
tagged key agreement specifically where

645
00:24:13,919 --> 00:24:15,520
we would originally just have key

646
00:24:15,520 --> 00:24:16,720
agreement of

647
00:24:16,720 --> 00:24:18,960
private public we now have it so that is

648
00:24:18,960 --> 00:24:22,080
key agreement of private public and tag

649
00:24:22,080 --> 00:24:24,000
just to look back at our notation here

650
00:24:24,000 --> 00:24:26,720
we have that the parties sample their

651
00:24:26,720 --> 00:24:29,360
privates they then send their

652
00:24:29,360 --> 00:24:31,919
public messages and then they get their

653
00:24:31,919 --> 00:24:34,480
keys output taking their private and the

654
00:24:34,480 --> 00:24:36,159
corresponding message from the other

655
00:24:36,159 --> 00:24:38,320
party with this new tag in the context

656
00:24:38,320 --> 00:24:40,720
of rot we're going to let this tag be

657
00:24:40,720 --> 00:24:43,760
the ot index in a batch

658
00:24:43,760 --> 00:24:46,960
so for instance if we're running 128 ots

659
00:24:46,960 --> 00:24:49,039
in a batch then the first ot will use

660
00:24:49,039 --> 00:24:52,080
the one tag second ot we'll use the two

661
00:24:52,080 --> 00:24:52,960
tag

662
00:24:52,960 --> 00:24:55,520
then so on and so forth till the last

663
00:24:55,520 --> 00:24:58,240
protocol for instance the kappa protocol

664
00:24:58,240 --> 00:25:00,799
we'll use kappa as its tag what this

665
00:25:00,799 --> 00:25:02,240
allows us to do

666
00:25:02,240 --> 00:25:04,400
is it allows the simulator to program

667
00:25:04,400 --> 00:25:06,480
each of the outputs separately to

668
00:25:06,480 --> 00:25:08,559
maintain the separation now that we know

669
00:25:08,559 --> 00:25:11,200
how to properly batch what can we do to

670
00:25:11,200 --> 00:25:14,320
further optimize the batching process

671
00:25:14,320 --> 00:25:16,559
what we saw earlier is that the original

672
00:25:16,559 --> 00:25:18,159
protocol from our previous paper

673
00:25:18,159 --> 00:25:20,240
required key agreement with uniform

674
00:25:20,240 --> 00:25:22,880
messages for both parties specifically

675
00:25:22,880 --> 00:25:24,799
this was in the context of password

676
00:25:24,799 --> 00:25:27,039
authenticated key exchange where both

677
00:25:27,039 --> 00:25:29,520
parties wrapped their key green messages

678
00:25:29,520 --> 00:25:31,200
before sending it to each other but what

679
00:25:31,200 --> 00:25:32,559
we were able to do in the previous

680
00:25:32,559 --> 00:25:35,440
protocol is take the stock elliptic

681
00:25:35,440 --> 00:25:37,679
curve diffie-homan protocol which does

682
00:25:37,679 --> 00:25:39,840
not satisfy this property and we were

683
00:25:39,840 --> 00:25:42,480
able to transform it into one that does

684
00:25:42,480 --> 00:25:44,640
specifically looking at an ideal cipher

685
00:25:44,640 --> 00:25:47,279
compatible process where the the cipher

686
00:25:47,279 --> 00:25:49,600
works over bit strings we were able to

687
00:25:49,600 --> 00:25:51,440
translate the

688
00:25:51,440 --> 00:25:53,760
elliptic curve diffie-homan messages

689
00:25:53,760 --> 00:25:56,640
into uniform bit strings using process

690
00:25:56,640 --> 00:25:59,120
uh known as alligator similarly to make

691
00:25:59,120 --> 00:26:01,279
it random oracle compatible we had to

692
00:26:01,279 --> 00:26:03,760
have a random article that hashed our

693
00:26:03,760 --> 00:26:05,919
output into the group that we were

694
00:26:05,919 --> 00:26:07,760
performing diffie-hellman over

695
00:26:07,760 --> 00:26:09,600
specifically in this case elliptic

696
00:26:09,600 --> 00:26:10,720
curves

697
00:26:10,720 --> 00:26:13,000
and we were able to use for instance

698
00:26:13,000 --> 00:26:16,080
sswu's hash to curve method now we're

699
00:26:16,080 --> 00:26:18,400
looking at ot and we no longer need that

700
00:26:18,400 --> 00:26:20,480
both parties wrap their key grant

701
00:26:20,480 --> 00:26:22,799
messages before sending it to each other

702
00:26:22,799 --> 00:26:25,679
now we only need that the receiver wraps

703
00:26:25,679 --> 00:26:27,440
their keygram message before sending it

704
00:26:27,440 --> 00:26:30,400
over the sender's message is sent in the

705
00:26:30,400 --> 00:26:32,240
clear unwrapped which means we now only

706
00:26:32,240 --> 00:26:34,400
need uniform bit strings for a single

707
00:26:34,400 --> 00:26:36,960
party this allows us to use a trick

708
00:26:36,960 --> 00:26:39,360
attributed to molar as we hinted at

709
00:26:39,360 --> 00:26:40,320
earlier

710
00:26:40,320 --> 00:26:42,400
elliptic curve elements really don't

711
00:26:42,400 --> 00:26:44,559
look like uniform bit strings even all

712
00:26:44,559 --> 00:26:47,039
of their x-coordinates don't lie on the

713
00:26:47,039 --> 00:26:49,440
curve so if you look at

714
00:26:49,440 --> 00:26:51,440
all the possible x-coordinates over a

715
00:26:51,440 --> 00:26:54,159
field it's not the case that all of

716
00:26:54,159 --> 00:26:55,039
those

717
00:26:55,039 --> 00:26:57,679
lie on a given curve in this situation

718
00:26:57,679 --> 00:26:59,600
thinking of this from our from the

719
00:26:59,600 --> 00:27:01,279
perspective of our ot protocol this

720
00:27:01,279 --> 00:27:02,960
would allow a

721
00:27:02,960 --> 00:27:06,080
adversary to discern between a key grant

722
00:27:06,080 --> 00:27:09,279
message and a non-key message and then

723
00:27:09,279 --> 00:27:10,240
of course

724
00:27:10,240 --> 00:27:13,120
learn the corresponding choice bit so

725
00:27:13,120 --> 00:27:16,080
where do all these other x coordinates

726
00:27:16,080 --> 00:27:17,520
end up where where do they lie well

727
00:27:17,520 --> 00:27:20,240
turns out they all lie on the curve's

728
00:27:20,240 --> 00:27:22,480
twist this means that if you were to

729
00:27:22,480 --> 00:27:25,360
take a bit string representation of one

730
00:27:25,360 --> 00:27:28,000
of the finite field elements this choice

731
00:27:28,000 --> 00:27:30,559
of a bit string interpreted of course

732
00:27:30,559 --> 00:27:33,679
will either lie on the curve itself

733
00:27:33,679 --> 00:27:36,960
or it will lie on the curve's twist so

734
00:27:36,960 --> 00:27:39,120
if both the curve and the curve's twist

735
00:27:39,120 --> 00:27:40,240
are secure

736
00:27:40,240 --> 00:27:43,440
and approximately the same size then we

737
00:27:43,440 --> 00:27:45,840
might be able to use uniform messages by

738
00:27:45,840 --> 00:27:47,919
sending the x chord so what does this

739
00:27:47,919 --> 00:27:49,600
key agreement look like using using this

740
00:27:49,600 --> 00:27:52,720
intuition of x coordinates for a curve

741
00:27:52,720 --> 00:27:55,200
and its twist well alice starts off by

742
00:27:55,200 --> 00:27:58,720
taking the base elliptic curve c0 and

743
00:27:58,720 --> 00:28:01,360
its twist it's a quadratic twist which

744
00:28:01,360 --> 00:28:03,039
we're going to call c1 and it's going to

745
00:28:03,039 --> 00:28:05,600
send a message for both of those so it's

746
00:28:05,600 --> 00:28:08,559
going to sample a private it's going to

747
00:28:08,559 --> 00:28:11,039
generate a element on the curve it's

748
00:28:11,039 --> 00:28:12,720
going to generate it's going to sample a

749
00:28:12,720 --> 00:28:13,840
private it's going to generate an

750
00:28:13,840 --> 00:28:15,520
element on the twist

751
00:28:15,520 --> 00:28:17,279
just like if it were doing two key

752
00:28:17,279 --> 00:28:19,120
agreements i'm just going to send both

753
00:28:19,120 --> 00:28:21,039
of those messages to bob bob on the

754
00:28:21,039 --> 00:28:22,720
other hand is going to flip a coin in

755
00:28:22,720 --> 00:28:25,440
his head and if it comes up heads then

756
00:28:25,440 --> 00:28:27,279
it's going to send a message on the base

757
00:28:27,279 --> 00:28:29,360
curve and if it comes up tails it's

758
00:28:29,360 --> 00:28:31,440
going to send a message on the twist

759
00:28:31,440 --> 00:28:33,440
finally

760
00:28:33,440 --> 00:28:35,760
since alice can determine whether a

761
00:28:35,760 --> 00:28:38,000
point is on the curve or its twist

762
00:28:38,000 --> 00:28:40,480
alice knows which private to use when

763
00:28:40,480 --> 00:28:42,960
generating its shared key

764
00:28:42,960 --> 00:28:45,440
and of course bob who flipped the coin

765
00:28:45,440 --> 00:28:46,480
himself

766
00:28:46,480 --> 00:28:48,559
will know whether or not the elements on

767
00:28:48,559 --> 00:28:50,399
the curve or the twist and can generate

768
00:28:50,399 --> 00:28:52,240
the same key that way

769
00:28:52,240 --> 00:28:54,480
so alice and bob either

770
00:28:54,480 --> 00:28:56,320
end up with a key on the on the base

771
00:28:56,320 --> 00:28:58,240
curve together or they end up with a key

772
00:28:58,240 --> 00:29:01,120
on the twist together because of this

773
00:29:01,120 --> 00:29:02,240
we need

774
00:29:02,240 --> 00:29:04,880
strong security for both the curve and

775
00:29:04,880 --> 00:29:06,080
for the twist

776
00:29:06,080 --> 00:29:07,600
at the end since we're still in the

777
00:29:07,600 --> 00:29:10,799
mindset of a tagged key agreement

778
00:29:10,799 --> 00:29:13,360
we're going to take the output and send

779
00:29:13,360 --> 00:29:16,080
it through a random oracle using the

780
00:29:16,080 --> 00:29:18,080
tag for the key exchange it's going to

781
00:29:18,080 --> 00:29:21,279
be the index of our ot before we go on

782
00:29:21,279 --> 00:29:24,080
further you may notice that

783
00:29:24,080 --> 00:29:25,279
we're actually

784
00:29:25,279 --> 00:29:28,000
increasing the number of group elements

785
00:29:28,000 --> 00:29:30,080
sent between the two parties if you

786
00:29:30,080 --> 00:29:31,200
recall

787
00:29:31,200 --> 00:29:32,080
the

788
00:29:32,080 --> 00:29:35,279
first message sent by alice is exactly

789
00:29:35,279 --> 00:29:38,080
the message that is reused across all of

790
00:29:38,080 --> 00:29:41,039
the oblivious transfer instances

791
00:29:41,039 --> 00:29:43,520
so instead of doubling the number of

792
00:29:43,520 --> 00:29:45,440
group elements sent by alice we're

793
00:29:45,440 --> 00:29:48,399
actually overall decreasing the number

794
00:29:48,399 --> 00:29:51,039
of elements sent by the

795
00:29:51,039 --> 00:29:54,480
security parameter up minus two

796
00:29:54,480 --> 00:29:57,360
looking at our protocol since b is just

797
00:29:57,360 --> 00:30:00,640
a random element chosen from the base

798
00:30:00,640 --> 00:30:03,760
field of course uh assuming that the

799
00:30:03,760 --> 00:30:05,919
size of the curve and its twist are

800
00:30:05,919 --> 00:30:07,760
approximately the same

801
00:30:07,760 --> 00:30:10,159
then b is going to be uniformly

802
00:30:10,159 --> 00:30:12,960
distributed in the base field now

803
00:30:12,960 --> 00:30:15,039
all of these optimizations together

804
00:30:15,039 --> 00:30:16,240
so

805
00:30:16,240 --> 00:30:19,039
first off we're going to be looking at

806
00:30:19,039 --> 00:30:20,480
reusing the sender's message

807
00:30:20,480 --> 00:30:22,480
specifically in the batch setting

808
00:30:22,480 --> 00:30:24,320
and then looking at taking these

809
00:30:24,320 --> 00:30:28,320
protocols that require uniform messages

810
00:30:28,320 --> 00:30:30,880
and supplementing them by using molar's

811
00:30:30,880 --> 00:30:33,279
key exchange what type of improvements

812
00:30:33,279 --> 00:30:35,120
are we going to see we measured the

813
00:30:35,120 --> 00:30:36,399
difference between

814
00:30:36,399 --> 00:30:38,480
different versions of our protocol using

815
00:30:38,480 --> 00:30:40,320
molar and using and not using molar as

816
00:30:40,320 --> 00:30:42,880
well as looking at other protocols that

817
00:30:42,880 --> 00:30:45,760
exist out in the wild we looked at both

818
00:30:45,760 --> 00:30:48,080
the the local area network setting where

819
00:30:48,080 --> 00:30:50,559
we have low latency and high bandwidth

820
00:30:50,559 --> 00:30:54,320
and we were looking over 128 of these

821
00:30:54,320 --> 00:30:57,600
base ots which is where we may see this

822
00:30:57,600 --> 00:30:59,919
batching process we also did the same

823
00:30:59,919 --> 00:31:01,440
evaluations

824
00:31:01,440 --> 00:31:04,080
for the wireless area network setting

825
00:31:04,080 --> 00:31:05,919
where we have

826
00:31:05,919 --> 00:31:08,480
high latency and low bandwidth and what

827
00:31:08,480 --> 00:31:09,679
we found is

828
00:31:09,679 --> 00:31:13,120
is that we had a 18 and 11 percent

829
00:31:13,120 --> 00:31:14,399
increase

830
00:31:14,399 --> 00:31:15,279
in

831
00:31:15,279 --> 00:31:18,320
performance when we decided to use

832
00:31:18,320 --> 00:31:21,600
optimization in batching where we resent

833
00:31:21,600 --> 00:31:22,399
the

834
00:31:22,399 --> 00:31:24,000
original message

835
00:31:24,000 --> 00:31:26,799
now why do we see an increase like this

836
00:31:26,799 --> 00:31:30,240
well of course we have 126

837
00:31:30,240 --> 00:31:33,279
fewer exponentiations from the sender

838
00:31:33,279 --> 00:31:36,320
and we have 126 fewer group elements

839
00:31:36,320 --> 00:31:38,640
sent from the sender we didn't use this

840
00:31:38,640 --> 00:31:39,840
optimization

841
00:31:39,840 --> 00:31:43,679
when we were testing our results however

842
00:31:43,679 --> 00:31:46,399
one may notice since the receiver is

843
00:31:46,399 --> 00:31:48,480
going to be performing exponentiations

844
00:31:48,480 --> 00:31:51,200
when deriving the keys using the same

845
00:31:51,200 --> 00:31:54,159
base key message from the sender then

846
00:31:54,159 --> 00:31:56,480
they can actually reuse some of their

847
00:31:56,480 --> 00:31:59,519
computation to reduce the amount of

848
00:31:59,519 --> 00:32:02,159
weight behind computing those keys then

849
00:32:02,159 --> 00:32:03,760
when moving from

850
00:32:03,760 --> 00:32:05,360
non-molars key agreement for instance

851
00:32:05,360 --> 00:32:07,360
using as we showed earlier hash to

852
00:32:07,360 --> 00:32:09,600
curves or alligator

853
00:32:09,600 --> 00:32:12,240
over to using molar we saw a

854
00:32:12,240 --> 00:32:15,200
increase of 31 12 respectively this is

855
00:32:15,200 --> 00:32:17,200
on the same order as

856
00:32:17,200 --> 00:32:20,399
what we saw as an increase from reusing

857
00:32:20,399 --> 00:32:23,039
the uh first message which is the

858
00:32:23,039 --> 00:32:24,880
original optimization for the batch

859
00:32:24,880 --> 00:32:26,720
setting now we see this because we no

860
00:32:26,720 --> 00:32:28,159
longer have to do these expensive

861
00:32:28,159 --> 00:32:30,399
mapping operations hash to curve is

862
00:32:30,399 --> 00:32:32,399
somewhere around the order of one

863
00:32:32,399 --> 00:32:34,159
quarter of a

864
00:32:34,159 --> 00:32:37,120
exponentiation or alligator and finally

865
00:32:37,120 --> 00:32:39,120
since we're working over curves that

866
00:32:39,120 --> 00:32:40,880
will likely support x-coordinate

867
00:32:40,880 --> 00:32:44,240
operations for instance curve25519

868
00:32:44,240 --> 00:32:46,240
we can take advantage of these

869
00:32:46,240 --> 00:32:48,480
montgomery ladders which allow us to

870
00:32:48,480 --> 00:32:51,039
perform faster computation

871
00:32:51,039 --> 00:32:52,720
what are some things that were left over

872
00:32:52,720 --> 00:32:53,440
from

873
00:32:53,440 --> 00:32:54,159
our

874
00:32:54,159 --> 00:32:56,480
studies as we pointed out earlier

875
00:32:56,480 --> 00:32:59,279
we have a specific attack on a specific

876
00:32:59,279 --> 00:33:02,000
protocol the main point was is that a

877
00:33:02,000 --> 00:33:04,640
lot of these protocols didn't think

878
00:33:04,640 --> 00:33:07,440
about um correlations between messages

879
00:33:07,440 --> 00:33:08,720
in the way that

880
00:33:08,720 --> 00:33:11,039
we could have induced could there be

881
00:33:11,039 --> 00:33:14,000
attacks on other ot extension protocols

882
00:33:14,000 --> 00:33:14,880
using

883
00:33:14,880 --> 00:33:18,320
these sorts of methods we also looked at

884
00:33:18,320 --> 00:33:20,240
instantiations of this protocol in all

885
00:33:20,240 --> 00:33:22,480
these situations we looked at

886
00:33:22,480 --> 00:33:24,000
elliptic curve diffie-hellman as the

887
00:33:24,000 --> 00:33:26,320
base key exchange for a protocol but are

888
00:33:26,320 --> 00:33:28,080
there any post-quantum key agreements

889
00:33:28,080 --> 00:33:30,399
that meet our properties specifically

890
00:33:30,399 --> 00:33:31,440
looking at

891
00:33:31,440 --> 00:33:33,279
strong randomness i mean are the other

892
00:33:33,279 --> 00:33:34,640
key agreements that meet these

893
00:33:34,640 --> 00:33:35,840
properties

894
00:33:35,840 --> 00:33:38,720
if so then we have easy candidates for

895
00:33:38,720 --> 00:33:41,840
post-quantum oblivious transfer

896
00:33:41,840 --> 00:33:44,320
and finally we've seen a lot of places

897
00:33:44,320 --> 00:33:46,159
that programmable once public functions

898
00:33:46,159 --> 00:33:48,960
can be used in this talk we looked at

899
00:33:48,960 --> 00:33:51,679
its use in oblivious transfer but in our

900
00:33:51,679 --> 00:33:54,159
previous paper we looked at

901
00:33:54,159 --> 00:33:56,559
its use in peg protocols password

902
00:33:56,559 --> 00:33:58,559
authenticated heat exchange

903
00:33:58,559 --> 00:34:00,159
and we also looked at its use in

904
00:34:00,159 --> 00:34:03,039
oblivious pseudorandom functions oprf

905
00:34:03,039 --> 00:34:04,240
protocols

906
00:34:04,240 --> 00:34:07,519
but where else can pops be used maybe

907
00:34:07,519 --> 00:34:09,440
there are situations where

908
00:34:09,440 --> 00:34:12,320
we normally use ideal ciphers these with

909
00:34:12,320 --> 00:34:13,760
very strong properties that we might be

910
00:34:13,760 --> 00:34:16,000
able to draw it back a little bit

911
00:34:16,000 --> 00:34:18,320
and use these weaker constructions for

912
00:34:18,320 --> 00:34:20,800
more efficient and often actually

913
00:34:20,800 --> 00:34:24,839
instantiable constructions

