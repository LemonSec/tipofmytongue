1
00:00:00,799 --> 00:00:02,320
hello everyone and welcome to this

2
00:00:02,320 --> 00:00:04,720
presentation my name is siareshree and

3
00:00:04,720 --> 00:00:06,560
today andreas erwig and i will present

4
00:00:06,560 --> 00:00:08,480
to you the paper generalized channels

5
00:00:08,480 --> 00:00:10,160
from limited blockchain scripts and

6
00:00:10,160 --> 00:00:12,400
adapter signatures this is a joint work

7
00:00:12,400 --> 00:00:15,280
with lucas almaya augustan erzoi andreas

8
00:00:15,280 --> 00:00:18,240
avec sebastian faust christina jostakova

9
00:00:18,240 --> 00:00:21,039
matto mafi pedro moreno sanchez and me

10
00:00:21,039 --> 00:00:22,480
sierra

11
00:00:22,480 --> 00:00:24,640
before i start let me give you a sneak

12
00:00:24,640 --> 00:00:27,279
peek into what we achieve in this paper

13
00:00:27,279 --> 00:00:28,560
we present

14
00:00:28,560 --> 00:00:31,359
an efficient application is agnostic

15
00:00:31,359 --> 00:00:33,680
cheap and interoperable off-chain

16
00:00:33,680 --> 00:00:35,920
solution for cryptocurrencies

17
00:00:35,920 --> 00:00:37,520
now let's start with some background and

18
00:00:37,520 --> 00:00:39,040
motivation

19
00:00:39,040 --> 00:00:41,040
blockchains were introduced as an

20
00:00:41,040 --> 00:00:43,280
infrastructure in order to enable

21
00:00:43,280 --> 00:00:45,600
parties to make payments or run

22
00:00:45,600 --> 00:00:48,719
applications in a decentralized manner

23
00:00:48,719 --> 00:00:50,879
so if alice wants to for example pay bob

24
00:00:50,879 --> 00:00:53,520
some coins let's say she would simply

25
00:00:53,520 --> 00:00:56,800
send the transaction to the blockchain

26
00:00:56,800 --> 00:00:59,359
however

27
00:00:59,359 --> 00:01:01,920
the size of each block in the blockchain

28
00:01:01,920 --> 00:01:05,199
is fixed and furthermore the average

29
00:01:05,199 --> 00:01:08,000
time during which a block is produced is

30
00:01:08,000 --> 00:01:11,119
also fixed this results in blockchains

31
00:01:11,119 --> 00:01:13,200
having limited throughput and parties

32
00:01:13,200 --> 00:01:15,520
having to pay high transaction fees for

33
00:01:15,520 --> 00:01:17,280
the transactions to be actually included

34
00:01:17,280 --> 00:01:19,040
in the blockchain

35
00:01:19,040 --> 00:01:22,640
in order to overcome this problem

36
00:01:22,640 --> 00:01:24,960
offchain protocols were introduced as

37
00:01:24,960 --> 00:01:27,600
scalability solutions

38
00:01:27,600 --> 00:01:31,520
the most prominent off-chain solution

39
00:01:31,520 --> 00:01:32,880
to improve scalability of the

40
00:01:32,880 --> 00:01:36,240
blockchains is called payment channels

41
00:01:36,240 --> 00:01:38,640
a payment channel executes in three or

42
00:01:38,640 --> 00:01:41,360
four phases the first phase is creation

43
00:01:41,360 --> 00:01:43,759
the second phase is update the third

44
00:01:43,759 --> 00:01:46,560
phase is closing a channel and finally

45
00:01:46,560 --> 00:01:49,360
punishment if necessary

46
00:01:49,360 --> 00:01:51,680
let's go through them one at a time in

47
00:01:51,680 --> 00:01:54,159
order to create a channel parties first

48
00:01:54,159 --> 00:01:56,240
on chain make some transactions in order

49
00:01:56,240 --> 00:01:59,680
to lock some coins

50
00:01:59,680 --> 00:02:01,840
after a successful creation these

51
00:02:01,840 --> 00:02:04,000
parties will now have an open channel

52
00:02:04,000 --> 00:02:06,079
and they can update it as many times as

53
00:02:06,079 --> 00:02:08,878
they want off-chain

54
00:02:08,878 --> 00:02:11,120
eventually if they want to close their

55
00:02:11,120 --> 00:02:12,640
channel they can send the latest state

56
00:02:12,640 --> 00:02:14,480
of the system of the channel to the

57
00:02:14,480 --> 00:02:16,000
blockchain

58
00:02:16,000 --> 00:02:17,760
and get their money back

59
00:02:17,760 --> 00:02:18,640
but

60
00:02:18,640 --> 00:02:21,120
what prevents bob

61
00:02:21,120 --> 00:02:23,360
from sending an older state which might

62
00:02:23,360 --> 00:02:25,040
be beneficial to him

63
00:02:25,040 --> 00:02:25,920
well

64
00:02:25,920 --> 00:02:28,080
on more advanced blockchains such as

65
00:02:28,080 --> 00:02:31,360
ethereum which allow execution of more

66
00:02:31,360 --> 00:02:33,599
complex programs

67
00:02:33,599 --> 00:02:36,400
you can compare the state numbers and

68
00:02:36,400 --> 00:02:39,200
alice can submit for example state sn

69
00:02:39,200 --> 00:02:40,640
and prove to the blockchain that there

70
00:02:40,640 --> 00:02:43,519
exists a newer state

71
00:02:43,519 --> 00:02:45,120
and they would be paid out based on the

72
00:02:45,120 --> 00:02:46,720
latest state however

73
00:02:46,720 --> 00:02:49,120
uh other blockchains such as bitcoin do

74
00:02:49,120 --> 00:02:52,160
not support execution of applications

75
00:02:52,160 --> 00:02:54,560
which would allow such a comparison

76
00:02:54,560 --> 00:02:56,800
in this case a punishment mechanism is

77
00:02:56,800 --> 00:02:58,959
used in order to prevent a party here

78
00:02:58,959 --> 00:03:02,239
bob to submit an older state

79
00:03:02,239 --> 00:03:04,400
more specifically the output of a state

80
00:03:04,400 --> 00:03:07,599
does not only specify the

81
00:03:07,599 --> 00:03:10,080
money payout to the parties but it also

82
00:03:10,080 --> 00:03:12,879
includes a punishment section where

83
00:03:12,879 --> 00:03:15,440
alice can use in order to punish bob if

84
00:03:15,440 --> 00:03:18,159
he misbehaves

85
00:03:18,159 --> 00:03:20,720
the most famous and actually widely used

86
00:03:20,720 --> 00:03:22,640
channel in practice are called lightning

87
00:03:22,640 --> 00:03:24,879
channels over bitcoin they were

88
00:03:24,879 --> 00:03:27,599
introduced in 2016 by pune and

89
00:03:27,599 --> 00:03:28,640
drija

90
00:03:28,640 --> 00:03:30,799
and i will here give you a simplified

91
00:03:30,799 --> 00:03:34,799
high-level overview of how they work

92
00:03:34,799 --> 00:03:36,480
in order to create the channel parties

93
00:03:36,480 --> 00:03:38,640
first lock let's say each of them 10

94
00:03:38,640 --> 00:03:41,120
coins in a so-called funding channel

95
00:03:41,120 --> 00:03:43,040
on the blockchain

96
00:03:43,040 --> 00:03:45,440
then each of the parties

97
00:03:45,440 --> 00:03:48,640
will have a commit transaction

98
00:03:48,640 --> 00:03:49,760
which

99
00:03:49,760 --> 00:03:52,959
specifies the payout here 10 and 10

100
00:03:52,959 --> 00:03:54,400
and

101
00:03:54,400 --> 00:03:55,760
a punishment

102
00:03:55,760 --> 00:03:58,159
payout where can be used by the other

103
00:03:58,159 --> 00:04:00,480
party if they know the secret

104
00:04:00,480 --> 00:04:02,640
of the publishing party so if alice

105
00:04:02,640 --> 00:04:05,680
publishes her commitment transaction

106
00:04:05,680 --> 00:04:09,120
and bob knows alice's secret here x1 bob

107
00:04:09,120 --> 00:04:11,360
would be able to punish alice the same

108
00:04:11,360 --> 00:04:14,840
holds for bob

109
00:04:15,120 --> 00:04:16,639
i would like to emphasize that these two

110
00:04:16,639 --> 00:04:18,399
transactions are not posted on the

111
00:04:18,399 --> 00:04:19,680
blockchain

112
00:04:19,680 --> 00:04:21,358
and both of these transactions must be

113
00:04:21,358 --> 00:04:24,960
signed by both alice empo

114
00:04:25,040 --> 00:04:27,360
furthermore note that

115
00:04:27,360 --> 00:04:29,680
parties cannot get the payout and

116
00:04:29,680 --> 00:04:31,360
punishment at the same time in other

117
00:04:31,360 --> 00:04:33,600
words either the payout would go through

118
00:04:33,600 --> 00:04:35,440
or the punishment this is because

119
00:04:35,440 --> 00:04:37,040
there's simply not enough funds in the

120
00:04:37,040 --> 00:04:39,759
original channel to here pay

121
00:04:39,759 --> 00:04:43,840
40 coins out instead of 20.

122
00:04:43,840 --> 00:04:46,400
now how would an update work well first

123
00:04:46,400 --> 00:04:48,000
parties would choose two different

124
00:04:48,000 --> 00:04:52,240
secrets here x2 and y2

125
00:04:52,240 --> 00:04:54,840
then they would generate a new commit

126
00:04:54,840 --> 00:04:58,800
transaction which now changes the payout

127
00:04:58,800 --> 00:05:01,199
conditions and also the punishment

128
00:05:01,199 --> 00:05:02,479
condition so now the punishment

129
00:05:02,479 --> 00:05:05,360
condition would be for bob to to know x2

130
00:05:05,360 --> 00:05:07,280
in order to publish punish alice if she

131
00:05:07,280 --> 00:05:11,479
publishes commit two

132
00:05:11,680 --> 00:05:14,080
and at this point they exchange the

133
00:05:14,080 --> 00:05:17,360
previous secrets x1 and y1 so if now

134
00:05:17,360 --> 00:05:19,680
alice publishes commit 1 onto the

135
00:05:19,680 --> 00:05:21,759
blockchain bob would be able to punish

136
00:05:21,759 --> 00:05:23,280
alice

137
00:05:23,280 --> 00:05:24,639
i would like to point out that this was

138
00:05:24,639 --> 00:05:26,479
a simplified explanation on how lighting

139
00:05:26,479 --> 00:05:28,880
works and in practice lighting actually

140
00:05:28,880 --> 00:05:29,680
needs

141
00:05:29,680 --> 00:05:32,160
time locks and hash locks

142
00:05:32,160 --> 00:05:34,639
this concept that i explained now can be

143
00:05:34,639 --> 00:05:36,000
generalized

144
00:05:36,000 --> 00:05:39,240
to allow

145
00:05:39,600 --> 00:05:41,840
the payout to be some application that

146
00:05:41,840 --> 00:05:43,440
will be run on the blockchain so like

147
00:05:43,440 --> 00:05:45,440
the scripting language that is supported

148
00:05:45,440 --> 00:05:47,280
by the blockchain can now be also

149
00:05:47,280 --> 00:05:49,520
supported off-chain

150
00:05:49,520 --> 00:05:51,919
furthermore we can run many applications

151
00:05:51,919 --> 00:05:55,840
of chain in just one comment transaction

152
00:05:55,840 --> 00:05:57,360
note that this is just a naive

153
00:05:57,360 --> 00:05:59,440
generalization and there will be some

154
00:05:59,440 --> 00:06:01,840
problems with it first

155
00:06:01,840 --> 00:06:04,400
we are now having punish per application

156
00:06:04,400 --> 00:06:06,400
i will later explain why this approach

157
00:06:06,400 --> 00:06:08,720
is not so efficient

158
00:06:08,720 --> 00:06:11,680
second we have state duplication

159
00:06:11,680 --> 00:06:12,639
which

160
00:06:12,639 --> 00:06:15,280
in case of nested applications would be

161
00:06:15,280 --> 00:06:17,360
quite problematic

162
00:06:17,360 --> 00:06:19,280
and i would like to point out that this

163
00:06:19,280 --> 00:06:20,479
generalization

164
00:06:20,479 --> 00:06:23,120
is not formally analyzed and i'm just

165
00:06:23,120 --> 00:06:25,360
mentioning it here to show that okay

166
00:06:25,360 --> 00:06:27,840
lighting can be generalized but we must

167
00:06:27,840 --> 00:06:31,680
do better to be efficient

168
00:06:31,680 --> 00:06:32,880
so let's see actually what is the

169
00:06:32,880 --> 00:06:34,400
problem with punish per application and

170
00:06:34,400 --> 00:06:37,198
state duplication

171
00:06:37,919 --> 00:06:40,479
punish per application significantly

172
00:06:40,479 --> 00:06:42,639
increases on-chain communication in case

173
00:06:42,639 --> 00:06:45,120
of disputes why because when a commit

174
00:06:45,120 --> 00:06:47,280
transaction is posted you're actually

175
00:06:47,280 --> 00:06:50,319
repeating many punishment conditions

176
00:06:50,319 --> 00:06:51,360
which could have been actually

177
00:06:51,360 --> 00:06:53,199
simplified in one

178
00:06:53,199 --> 00:06:55,520
namely a party has posted an outdated

179
00:06:55,520 --> 00:06:58,080
commit transaction

180
00:06:58,080 --> 00:07:00,800
state duplication increases the off

181
00:07:00,800 --> 00:07:03,120
chain overhead substantially which some

182
00:07:03,120 --> 00:07:06,720
applications need such as the virtual

183
00:07:06,720 --> 00:07:09,360
channels over bitcoin paper by aomaya at

184
00:07:09,360 --> 00:07:10,639
al

185
00:07:10,639 --> 00:07:12,960
what do i mean how how bad is it that

186
00:07:12,960 --> 00:07:16,000
the option communication increases well

187
00:07:16,000 --> 00:07:18,000
recall that we have

188
00:07:18,000 --> 00:07:20,400
two commit transactions

189
00:07:20,400 --> 00:07:22,800
and now opening applications on top of

190
00:07:22,800 --> 00:07:24,080
applications or having nested

191
00:07:24,080 --> 00:07:25,840
application will result in an

192
00:07:25,840 --> 00:07:28,000
exponential growth of the off chain

193
00:07:28,000 --> 00:07:30,960
communication

194
00:07:30,960 --> 00:07:33,520
in our work we try to tackle these

195
00:07:33,520 --> 00:07:34,720
issues

196
00:07:34,720 --> 00:07:37,199
we first formalize and give a definition

197
00:07:37,199 --> 00:07:40,160
of generalized channels in uc

198
00:07:40,160 --> 00:07:42,960
which does not require or does not have

199
00:07:42,960 --> 00:07:44,720
state duplication

200
00:07:44,720 --> 00:07:48,080
and punish per application

201
00:07:48,080 --> 00:07:50,560
we provide efficient constructions based

202
00:07:50,560 --> 00:07:54,960
on a primitive called adapter signatures

203
00:07:55,840 --> 00:07:58,160
in order to use adapter signatures we

204
00:07:58,160 --> 00:08:00,560
for the first time give a formalization

205
00:08:00,560 --> 00:08:02,479
a standalone formalization of this

206
00:08:02,479 --> 00:08:03,840
primitive

207
00:08:03,840 --> 00:08:05,520
and show how to instantiate them based

208
00:08:05,520 --> 00:08:08,879
on snore and ecdsa

209
00:08:08,879 --> 00:08:10,240
i would like to emphasize that schnorr

210
00:08:10,240 --> 00:08:11,680
and ecdsa

211
00:08:11,680 --> 00:08:13,120
are the two

212
00:08:13,120 --> 00:08:16,560
main signature schemes used on virtually

213
00:08:16,560 --> 00:08:20,160
any or more or less any blockchain

214
00:08:20,160 --> 00:08:22,960
that is used in practice

215
00:08:22,960 --> 00:08:25,360
and therefore it is important that we

216
00:08:25,360 --> 00:08:27,360
show how adapter signatures are

217
00:08:27,360 --> 00:08:28,800
instantiated

218
00:08:28,800 --> 00:08:30,639
using these two signatures to be

219
00:08:30,639 --> 00:08:32,880
compatible with as many different

220
00:08:32,880 --> 00:08:36,399
blockchains as possible

221
00:08:37,360 --> 00:08:40,240
we also implemented an evaluated our

222
00:08:40,240 --> 00:08:42,958
generalized channel protocol

223
00:08:42,958 --> 00:08:45,040
and we proved the generalized channel

224
00:08:45,040 --> 00:08:48,959
scheme to be secure in uc

225
00:08:49,360 --> 00:08:51,040
okay

226
00:08:51,040 --> 00:08:52,880
the outline of this talk would be as

227
00:08:52,880 --> 00:08:54,320
follows i by now i gave you the

228
00:08:54,320 --> 00:08:56,720
motivation motivation behind our paper i

229
00:08:56,720 --> 00:08:58,320
will continue with the definition of

230
00:08:58,320 --> 00:09:00,720
adapter signatures and constructions

231
00:09:00,720 --> 00:09:01,600
uh

232
00:09:01,600 --> 00:09:04,320
afterwards andreas evic will show you

233
00:09:04,320 --> 00:09:05,839
our generalized channel's definition and

234
00:09:05,839 --> 00:09:08,800
construction and we provide

235
00:09:08,800 --> 00:09:10,560
a performance evaluation and

236
00:09:10,560 --> 00:09:12,959
applications

237
00:09:12,959 --> 00:09:14,160
okay

238
00:09:14,160 --> 00:09:15,440
now let's see what our adapter

239
00:09:15,440 --> 00:09:17,680
signatures how we can define them and

240
00:09:17,680 --> 00:09:20,640
how we can instantiate them

241
00:09:20,640 --> 00:09:22,720
an adapter signature

242
00:09:22,720 --> 00:09:23,680
is

243
00:09:23,680 --> 00:09:26,000
defined based on an underlying signature

244
00:09:26,000 --> 00:09:28,480
in our case schnorr or ecdsa but

245
00:09:28,480 --> 00:09:32,240
consists of four additional procedures

246
00:09:32,240 --> 00:09:34,320
pre-sign which is which we show by p

247
00:09:34,320 --> 00:09:35,200
sign

248
00:09:35,200 --> 00:09:37,920
pre-verify which we showed by p verify

249
00:09:37,920 --> 00:09:40,240
adapt and extract

250
00:09:40,240 --> 00:09:42,320
let's see in a two-party scenario how

251
00:09:42,320 --> 00:09:44,240
adaptive signatures can be used

252
00:09:44,240 --> 00:09:46,080
we have on the left-hand side alice and

253
00:09:46,080 --> 00:09:47,760
the right-hand side paul

254
00:09:47,760 --> 00:09:50,560
bob is the party who is

255
00:09:50,560 --> 00:09:52,480
who has a secret republican for a

256
00:09:52,480 --> 00:09:53,920
signature scheme

257
00:09:53,920 --> 00:09:56,880
and alice has a statement witness pair

258
00:09:56,880 --> 00:09:59,040
for a hard relation and a message for

259
00:09:59,040 --> 00:10:02,480
which you want to receive a signature

260
00:10:02,480 --> 00:10:04,959
by heart relation i mean it is difficult

261
00:10:04,959 --> 00:10:06,800
given the statement to extract a witness

262
00:10:06,800 --> 00:10:09,440
for example this can be a d log relation

263
00:10:09,440 --> 00:10:12,079
d to the power of y and y

264
00:10:12,079 --> 00:10:15,040
alice sends the statement and message to

265
00:10:15,040 --> 00:10:16,000
bob

266
00:10:16,000 --> 00:10:17,839
and bob generates something called a

267
00:10:17,839 --> 00:10:19,760
pre-signature

268
00:10:19,760 --> 00:10:21,279
note that the pre-signature is an

269
00:10:21,279 --> 00:10:23,920
incomplete signature namely if you run

270
00:10:23,920 --> 00:10:25,760
the original verify algorithm of the

271
00:10:25,760 --> 00:10:27,519
signature scheme on it it will not

272
00:10:27,519 --> 00:10:29,360
verify

273
00:10:29,360 --> 00:10:30,880
bob sends this pre-signature back to

274
00:10:30,880 --> 00:10:33,200
alice and alice can now check if the

275
00:10:33,200 --> 00:10:35,200
pre-signature is actually valid by

276
00:10:35,200 --> 00:10:38,320
running the p-verify algorithm

277
00:10:38,320 --> 00:10:41,279
if so she can adapt the pre-signature

278
00:10:41,279 --> 00:10:44,079
into a valid full signature given her

279
00:10:44,079 --> 00:10:46,160
weakness so now she has a complete

280
00:10:46,160 --> 00:10:48,720
signature which looks identical

281
00:10:48,720 --> 00:10:50,720
to a signature generated by bob on

282
00:10:50,720 --> 00:10:54,399
message m using sk

283
00:10:54,399 --> 00:10:55,680
she can at this point post this

284
00:10:55,680 --> 00:10:56,880
signature to the blockchain we can

285
00:10:56,880 --> 00:10:58,640
assume that m is a transaction that will

286
00:10:58,640 --> 00:11:00,240
be supported by the blockchain accepted

287
00:11:00,240 --> 00:11:02,320
by the blockchain and upon its this

288
00:11:02,320 --> 00:11:03,440
signature being accepted by the

289
00:11:03,440 --> 00:11:05,680
blockchain bob can read it

290
00:11:05,680 --> 00:11:08,000
and can extract the witness

291
00:11:08,000 --> 00:11:10,160
given the pre-signature the full

292
00:11:10,160 --> 00:11:12,720
signature and the statement

293
00:11:12,720 --> 00:11:13,920
such that the statement and this

294
00:11:13,920 --> 00:11:16,079
extracted witnesses witness are in

295
00:11:16,079 --> 00:11:17,760
relation

296
00:11:17,760 --> 00:11:19,680
so as you can see we have four

297
00:11:19,680 --> 00:11:22,240
additional algorithms for adapter

298
00:11:22,240 --> 00:11:23,440
signatures

299
00:11:23,440 --> 00:11:25,200
the high level idea to build adapter

300
00:11:25,200 --> 00:11:27,920
signatures is to hide this witness w in

301
00:11:27,920 --> 00:11:30,480
the randomness used for signing we will

302
00:11:30,480 --> 00:11:32,160
see this later when i show you the

303
00:11:32,160 --> 00:11:33,920
instantiation of adapter signatures from

304
00:11:33,920 --> 00:11:35,440
schnorr signatures

305
00:11:35,440 --> 00:11:37,120
but before that let me give you the

306
00:11:37,120 --> 00:11:39,680
history of adapter signatures

307
00:11:39,680 --> 00:11:41,600
adapter signatures were first introduced

308
00:11:41,600 --> 00:11:44,720
in january 2017 by polstra in a mailing

309
00:11:44,720 --> 00:11:47,360
list and he presented a construction

310
00:11:47,360 --> 00:11:49,279
based on snore

311
00:11:49,279 --> 00:11:51,360
a year later

312
00:11:51,360 --> 00:11:53,600
mourinho sanchez and kate in a mailing

313
00:11:53,600 --> 00:11:55,440
list showed how we can actually build

314
00:11:55,440 --> 00:11:56,880
adapter signatures in a threshold

315
00:11:56,880 --> 00:12:00,560
setting from ecdsa

316
00:12:00,560 --> 00:12:04,079
in 2019 monovolta at all

317
00:12:04,079 --> 00:12:06,399
in in their ndss paper showed how one

318
00:12:06,399 --> 00:12:07,200
can

319
00:12:07,200 --> 00:12:09,760
build payment channels using the

320
00:12:09,760 --> 00:12:12,480
threshold variant of adapter signatures

321
00:12:12,480 --> 00:12:15,680
in this work we formalize a single party

322
00:12:15,680 --> 00:12:18,079
adapter signature and

323
00:12:18,079 --> 00:12:19,600
show schnorr and cdsa based

324
00:12:19,600 --> 00:12:21,680
constructions

325
00:12:21,680 --> 00:12:23,680
shortly after this works this work was

326
00:12:23,680 --> 00:12:26,959
put on on online uh eskin

327
00:12:26,959 --> 00:12:30,480
and tyri uh in two parallel works showed

328
00:12:30,480 --> 00:12:34,079
how one can produce uh two uh uh two

329
00:12:34,079 --> 00:12:36,800
post quantum secure adapter signatures

330
00:12:36,800 --> 00:12:39,440
from different underlying assumptions

331
00:12:39,440 --> 00:12:43,279
and finally in 2001 arabic at al in the

332
00:12:43,279 --> 00:12:45,200
pkc paper showed how one can build

333
00:12:45,200 --> 00:12:46,639
two-party adaption signatures

334
00:12:46,639 --> 00:12:47,839
generically

335
00:12:47,839 --> 00:12:50,480
from identification scheme which satisfy

336
00:12:50,480 --> 00:12:52,320
some properties

337
00:12:52,320 --> 00:12:54,399
okay

338
00:12:54,399 --> 00:12:56,320
now let's see what are the properties

339
00:12:56,320 --> 00:12:58,240
security properties that adapter

340
00:12:58,240 --> 00:13:01,440
signatures need to satisfy

341
00:13:01,440 --> 00:13:03,279
in short there are four properties

342
00:13:03,279 --> 00:13:05,760
correctness existential unforgeability

343
00:13:05,760 --> 00:13:07,839
pre-signature adaptability and weakness

344
00:13:07,839 --> 00:13:09,360
extractability let's start with

345
00:13:09,360 --> 00:13:10,800
correctness

346
00:13:10,800 --> 00:13:12,959
correctness simply states that if

347
00:13:12,959 --> 00:13:14,320
everybody behaves honestly the

348
00:13:14,320 --> 00:13:16,639
algorithms behave as i described

349
00:13:16,639 --> 00:13:18,639
previously uh when i gave the overview

350
00:13:18,639 --> 00:13:21,600
of other signatures more precisely

351
00:13:21,600 --> 00:13:23,360
alice sends the statement and message to

352
00:13:23,360 --> 00:13:25,279
bob bob generates honestly a

353
00:13:25,279 --> 00:13:28,399
pre-signature alice can verify this

354
00:13:28,399 --> 00:13:29,760
pre-signature so the verification

355
00:13:29,760 --> 00:13:33,440
returns one the p-verify returns one

356
00:13:33,440 --> 00:13:35,760
alice can then adapt this pre-signature

357
00:13:35,760 --> 00:13:37,680
to a full signature which is indeed

358
00:13:37,680 --> 00:13:39,839
valid so she can post it on the

359
00:13:39,839 --> 00:13:41,920
blockchain

360
00:13:41,920 --> 00:13:45,040
and bob by seeing the full signature

361
00:13:45,040 --> 00:13:47,040
can extract a witness which is in

362
00:13:47,040 --> 00:13:48,959
relation with the original statement

363
00:13:48,959 --> 00:13:51,839
shared by alice

364
00:13:52,000 --> 00:13:54,160
now let's continue to pre-signature

365
00:13:54,160 --> 00:13:56,320
adaptability pre-signature adaptability

366
00:13:56,320 --> 00:13:57,760
states that

367
00:13:57,760 --> 00:14:00,079
if alice is honest and sends her state a

368
00:14:00,079 --> 00:14:02,880
message to to the bob who is in this

369
00:14:02,880 --> 00:14:05,680
case malicious and bob somehow comes up

370
00:14:05,680 --> 00:14:08,160
with a pre-signature we don't know how

371
00:14:08,160 --> 00:14:09,680
but the point is that the pre-signature

372
00:14:09,680 --> 00:14:11,680
verifies so the running pre-verify

373
00:14:11,680 --> 00:14:12,720
algorithm

374
00:14:12,720 --> 00:14:15,440
on the pre-signature would return one

375
00:14:15,440 --> 00:14:18,079
if alice now adapts this pre-signature

376
00:14:18,079 --> 00:14:20,399
she would get a valid signature in other

377
00:14:20,399 --> 00:14:22,720
words if pre-verify returns one

378
00:14:22,720 --> 00:14:24,320
regardless of the adversity strategy

379
00:14:24,320 --> 00:14:26,720
alice would be able to adapt

380
00:14:26,720 --> 00:14:31,000
this pre-signature to a full signature

381
00:14:32,000 --> 00:14:33,440
the third property that i want to

382
00:14:33,440 --> 00:14:34,800
discuss is the existential

383
00:14:34,800 --> 00:14:36,880
approachability this property states

384
00:14:36,880 --> 00:14:38,800
that we have alice and bob for example

385
00:14:38,800 --> 00:14:41,839
who are communicating and the advisory

386
00:14:41,839 --> 00:14:42,880
can see

387
00:14:42,880 --> 00:14:45,120
many pre-signatures on many different

388
00:14:45,120 --> 00:14:47,600
messages

389
00:14:47,760 --> 00:14:49,199
eventually

390
00:14:49,199 --> 00:14:51,199
even if the adversary knows a

391
00:14:51,199 --> 00:14:53,279
pre-signature on a specific message of

392
00:14:53,279 --> 00:14:55,360
his choice he will not be able to

393
00:14:55,360 --> 00:14:57,519
produce a full signature such that the

394
00:14:57,519 --> 00:14:59,920
signature is valid unless

395
00:14:59,920 --> 00:15:01,120
and without

396
00:15:01,120 --> 00:15:02,880
having seen it previously a signature on

397
00:15:02,880 --> 00:15:03,839
m

398
00:15:03,839 --> 00:15:05,680
in other words even seeing a

399
00:15:05,680 --> 00:15:07,360
pre-signature

400
00:15:07,360 --> 00:15:09,600
on a fresh message m

401
00:15:09,600 --> 00:15:12,079
will not help the adversary to forge a

402
00:15:12,079 --> 00:15:14,638
signature

403
00:15:14,800 --> 00:15:17,279
finally

404
00:15:17,440 --> 00:15:20,480
we have weakness extractability

405
00:15:20,480 --> 00:15:23,199
in this case we have a malicious alice

406
00:15:23,199 --> 00:15:26,240
who sends a statement message to bob bob

407
00:15:26,240 --> 00:15:28,560
generates a pre-signature and alice

408
00:15:28,560 --> 00:15:29,680
comes up

409
00:15:29,680 --> 00:15:33,519
somehow with a full signature

410
00:15:34,320 --> 00:15:36,399
if the signature verifies

411
00:15:36,399 --> 00:15:38,880
namely alice can now publish this

412
00:15:38,880 --> 00:15:40,000
signature message paired to the

413
00:15:40,000 --> 00:15:42,320
blockchain it should not be the case

414
00:15:42,320 --> 00:15:45,839
that bob is not able to extract a valid

415
00:15:45,839 --> 00:15:47,040
witness

416
00:15:47,040 --> 00:15:49,440
in other words

417
00:15:49,440 --> 00:15:51,199
if this signature is published and this

418
00:15:51,199 --> 00:15:53,199
signature is valid bob will always be

419
00:15:53,199 --> 00:15:54,800
able to extract

420
00:15:54,800 --> 00:15:57,040
a valid witness

421
00:15:57,040 --> 00:15:57,920
okay

422
00:15:57,920 --> 00:16:00,079
for more details regarding how these

423
00:16:00,079 --> 00:16:02,399
properties are defined formally i would

424
00:16:02,399 --> 00:16:04,399
refer you to our paper

425
00:16:04,399 --> 00:16:06,079
at this point i would like to show how

426
00:16:06,079 --> 00:16:08,800
to transform schnorr signatures into

427
00:16:08,800 --> 00:16:12,079
adaptation or signatures

428
00:16:14,480 --> 00:16:16,240
let's shortly recall how actually

429
00:16:16,240 --> 00:16:18,720
schnorr signatures work

430
00:16:18,720 --> 00:16:19,680
first

431
00:16:19,680 --> 00:16:22,000
we know that we have a cyclic group g of

432
00:16:22,000 --> 00:16:24,320
prime order q and a hash function which

433
00:16:24,320 --> 00:16:27,360
maps messages to that queue

434
00:16:27,360 --> 00:16:29,279
the key generation works as follows the

435
00:16:29,279 --> 00:16:31,360
secret key is a random element from zq

436
00:16:31,360 --> 00:16:33,519
and the public key is g to the power of

437
00:16:33,519 --> 00:16:36,639
the secret key

438
00:16:36,639 --> 00:16:39,519
the signing algorithm chooses a random

439
00:16:39,519 --> 00:16:41,600
value r from zq

440
00:16:41,600 --> 00:16:43,360
and the

441
00:16:43,360 --> 00:16:45,360
public randomness would be g to the

442
00:16:45,360 --> 00:16:46,800
power of r

443
00:16:46,800 --> 00:16:48,880
then hash of g to the power of r carca

444
00:16:48,880 --> 00:16:51,600
with m is computed

445
00:16:51,600 --> 00:16:54,959
and s would be r plus h of x mod q

446
00:16:54,959 --> 00:16:57,040
the signature would be this hash value

447
00:16:57,040 --> 00:16:58,720
and s

448
00:16:58,720 --> 00:17:01,440
to verify

449
00:17:01,440 --> 00:17:04,240
we compute g to the power of s the

450
00:17:04,240 --> 00:17:06,400
public key to the power of minus h

451
00:17:06,400 --> 00:17:08,480
compute the public randomness and we

452
00:17:08,480 --> 00:17:09,839
check if

453
00:17:09,839 --> 00:17:12,160
the hash of this r prime concatenate

454
00:17:12,160 --> 00:17:14,480
with m is the accompanied hash

455
00:17:14,480 --> 00:17:16,640
in the sequence

456
00:17:16,640 --> 00:17:18,640
now how can we transform

457
00:17:18,640 --> 00:17:19,760
this

458
00:17:19,760 --> 00:17:22,880
schnorr signature into adaptation switch

459
00:17:22,880 --> 00:17:23,919
well

460
00:17:23,919 --> 00:17:26,400
the generation will stay the same

461
00:17:26,400 --> 00:17:28,480
and now what we have is the statement

462
00:17:28,480 --> 00:17:30,320
witness pair

463
00:17:30,320 --> 00:17:34,960
in this case w and g to the power of w

464
00:17:35,360 --> 00:17:36,960
all we need to do

465
00:17:36,960 --> 00:17:39,120
to build the present algorithm

466
00:17:39,120 --> 00:17:41,200
is to multiply

467
00:17:41,200 --> 00:17:43,120
the public randomness g to the power of

468
00:17:43,120 --> 00:17:46,240
r with g to the power of w the statement

469
00:17:46,240 --> 00:17:49,200
and that's it the rest stays the same

470
00:17:49,200 --> 00:17:51,440
and to verify

471
00:17:51,440 --> 00:17:53,840
when computing r prime we just multiply

472
00:17:53,840 --> 00:17:55,679
g to the power of w

473
00:17:55,679 --> 00:17:56,559
with

474
00:17:56,559 --> 00:17:58,240
g to the power of s times x to the power

475
00:17:58,240 --> 00:18:01,039
of minus h

476
00:18:01,039 --> 00:18:03,440
what would this change actually

477
00:18:03,440 --> 00:18:05,919
do to to the final result of the preset

478
00:18:05,919 --> 00:18:08,240
algorithm well what we get

479
00:18:08,240 --> 00:18:11,039
is s equal r plus h of g to the power of

480
00:18:11,039 --> 00:18:12,840
w g to the power of

481
00:18:12,840 --> 00:18:14,559
r

482
00:18:14,559 --> 00:18:17,360
this means that in order to adapt such

483
00:18:17,360 --> 00:18:19,840
an s into a full signature we just need

484
00:18:19,840 --> 00:18:21,520
to add w to it

485
00:18:21,520 --> 00:18:22,960
and then

486
00:18:22,960 --> 00:18:24,799
we would have a signature where the

487
00:18:24,799 --> 00:18:27,520
randomness the private randomness is r

488
00:18:27,520 --> 00:18:30,559
plus w and the public randomness is g to

489
00:18:30,559 --> 00:18:33,760
the power of r plus w

490
00:18:34,000 --> 00:18:36,720
as i said before the high level idea is

491
00:18:36,720 --> 00:18:39,679
to hide w in the randomness used for

492
00:18:39,679 --> 00:18:41,200
signing

493
00:18:41,200 --> 00:18:43,760
it is also easy to see that

494
00:18:43,760 --> 00:18:45,760
given the pre-signature and the edited

495
00:18:45,760 --> 00:18:47,760
signature w can be extracted the

496
00:18:47,760 --> 00:18:50,640
weakness can be extracted

497
00:18:50,640 --> 00:18:51,919
okay

498
00:18:51,919 --> 00:18:54,320
let me now summarize our contribution

499
00:18:54,320 --> 00:18:56,880
with respect to adapter signatures

500
00:18:56,880 --> 00:18:58,400
we gave the formal first formal

501
00:18:58,400 --> 00:19:00,640
definition of adapter signatures

502
00:19:00,640 --> 00:19:02,880
and proved schnorr and ecds adapter

503
00:19:02,880 --> 00:19:06,240
signatures in our model

504
00:19:06,480 --> 00:19:07,840
i would like to point out that

505
00:19:07,840 --> 00:19:09,760
additional zero knowledge proofs were

506
00:19:09,760 --> 00:19:12,320
required in order to make the ecdsa

507
00:19:12,320 --> 00:19:15,039
variant of adapter signatures secure

508
00:19:15,039 --> 00:19:16,720
therefore one interesting open problem

509
00:19:16,720 --> 00:19:17,760
would be if we can remove the

510
00:19:17,760 --> 00:19:20,160
zero-knowledge proofs and still prove

511
00:19:20,160 --> 00:19:22,400
the ecdsa variant of the adapter

512
00:19:22,400 --> 00:19:26,000
signatures secure in our model

513
00:19:26,000 --> 00:19:28,960
for more details please check out our

514
00:19:28,960 --> 00:19:30,640
full paper

515
00:19:30,640 --> 00:19:33,280
now i will hand it over to andreas

516
00:19:33,280 --> 00:19:34,400
aravik

517
00:19:34,400 --> 00:19:36,320
to give you our generalized channel

518
00:19:36,320 --> 00:19:39,840
definition and construction

519
00:19:40,480 --> 00:19:42,480
okay so i will now talk about our

520
00:19:42,480 --> 00:19:44,240
generalization definition and i will

521
00:19:44,240 --> 00:19:46,240
also give a high level overview of our

522
00:19:46,240 --> 00:19:47,919
construction

523
00:19:47,919 --> 00:19:50,400
um informally what a generalized channel

524
00:19:50,400 --> 00:19:51,120
is

525
00:19:51,120 --> 00:19:54,480
is it allows two parties to execute

526
00:19:54,480 --> 00:19:55,679
off-chain

527
00:19:55,679 --> 00:19:58,000
any two-party application that could

528
00:19:58,000 --> 00:20:00,880
otherwise be executed on the blockchain

529
00:20:00,880 --> 00:20:02,559
so basically it allows two parties to

530
00:20:02,559 --> 00:20:03,760
lift

531
00:20:03,760 --> 00:20:05,840
the execution of a two-party application

532
00:20:05,840 --> 00:20:09,039
from the blockchain off chain

533
00:20:09,039 --> 00:20:10,559
for this we of course require some

534
00:20:10,559 --> 00:20:12,640
properties and in fact we have three

535
00:20:12,640 --> 00:20:14,720
security properties and one

536
00:20:14,720 --> 00:20:16,960
efficiency property

537
00:20:16,960 --> 00:20:19,440
the first security property is consensus

538
00:20:19,440 --> 00:20:21,440
on creation that means that if two

539
00:20:21,440 --> 00:20:23,280
parties have a generalized channel with

540
00:20:23,280 --> 00:20:24,240
each other

541
00:20:24,240 --> 00:20:26,480
then both parties must have agreed to

542
00:20:26,480 --> 00:20:28,159
the creation of this channel so it

543
00:20:28,159 --> 00:20:29,760
cannot be the case that a malicious

544
00:20:29,760 --> 00:20:31,760
party opens a generalized channel with

545
00:20:31,760 --> 00:20:34,240
an honest party without the honest party

546
00:20:34,240 --> 00:20:36,320
agreeing to it

547
00:20:36,320 --> 00:20:38,400
the second

548
00:20:38,400 --> 00:20:40,640
the second property is very similar to

549
00:20:40,640 --> 00:20:42,559
the first one which is consensus on

550
00:20:42,559 --> 00:20:45,679
update so this means that a generation

551
00:20:45,679 --> 00:20:48,159
can only be updated if both parties

552
00:20:48,159 --> 00:20:51,039
agree to the update

553
00:20:51,360 --> 00:20:52,960
then we have the property of instant

554
00:20:52,960 --> 00:20:54,960
finality with punish which

555
00:20:54,960 --> 00:20:57,280
on a high level says that

556
00:20:57,280 --> 00:20:59,200
an honest party in a generalized channel

557
00:20:59,200 --> 00:21:01,679
has to guarantee that the late state of

558
00:21:01,679 --> 00:21:04,240
the generalized channel can always be

559
00:21:04,240 --> 00:21:05,440
enforced

560
00:21:05,440 --> 00:21:06,880
on the blockchain

561
00:21:06,880 --> 00:21:08,720
or if that's not the case because of

562
00:21:08,720 --> 00:21:10,799
some malicious behavior then at least

563
00:21:10,799 --> 00:21:13,440
the honest party can always punish the

564
00:21:13,440 --> 00:21:14,960
malicious party for the militia's

565
00:21:14,960 --> 00:21:17,360
behavior

566
00:21:17,360 --> 00:21:18,960
and then finally we have an efficiency

567
00:21:18,960 --> 00:21:21,440
property which we call optimistic update

568
00:21:21,440 --> 00:21:23,919
and that says that if both parties are

569
00:21:23,919 --> 00:21:25,840
behaving honestly during an update

570
00:21:25,840 --> 00:21:28,559
procedure then this procedure will

571
00:21:28,559 --> 00:21:30,559
terminate within a constant number of

572
00:21:30,559 --> 00:21:32,960
rounds

573
00:21:34,240 --> 00:21:36,080
i will now give a high level overview of

574
00:21:36,080 --> 00:21:38,400
our construction of generalized channels

575
00:21:38,400 --> 00:21:39,840
and for that i would like to first

576
00:21:39,840 --> 00:21:41,600
recall that

577
00:21:41,600 --> 00:21:43,440
we pointed out two issues with lightning

578
00:21:43,440 --> 00:21:45,760
channels and those two issues were that

579
00:21:45,760 --> 00:21:47,919
lightning channels required the punish

580
00:21:47,919 --> 00:21:50,400
punishment per application

581
00:21:50,400 --> 00:21:52,159
and also lightning channels were based

582
00:21:52,159 --> 00:21:53,120
on

583
00:21:53,120 --> 00:21:54,720
state duplication that means that

584
00:21:54,720 --> 00:21:56,960
lightning terms have two distinct

585
00:21:56,960 --> 00:22:00,720
commit transaction for each state

586
00:22:01,520 --> 00:22:03,039
now our idea for constructing

587
00:22:03,039 --> 00:22:06,400
generalized channels is to improve these

588
00:22:06,400 --> 00:22:08,240
issues so first we would like to

589
00:22:08,240 --> 00:22:10,400
decouple the punishment from the

590
00:22:10,400 --> 00:22:11,840
applications that are run in the

591
00:22:11,840 --> 00:22:14,320
generalized channel

592
00:22:14,320 --> 00:22:16,159
and also we would like to use

593
00:22:16,159 --> 00:22:17,760
adapter signatures

594
00:22:17,760 --> 00:22:18,480
to

595
00:22:18,480 --> 00:22:21,520
remove the state duplication

596
00:22:21,520 --> 00:22:23,440
and i'm first going to talk about this

597
00:22:23,440 --> 00:22:25,600
decoupling of the punishment from the

598
00:22:25,600 --> 00:22:28,240
applications

599
00:22:28,240 --> 00:22:29,120
so

600
00:22:29,120 --> 00:22:31,280
we introduce in our paper

601
00:22:31,280 --> 00:22:33,280
a paradigm that we call punish then

602
00:22:33,280 --> 00:22:37,200
split as a reminder this here is the

603
00:22:37,200 --> 00:22:38,799
transaction design of lightning channel

604
00:22:38,799 --> 00:22:40,480
so we have a funding transaction

605
00:22:40,480 --> 00:22:42,720
we have two commit transactions and the

606
00:22:42,720 --> 00:22:44,159
commit transactions hold all the

607
00:22:44,159 --> 00:22:46,000
applications and all the punishment

608
00:22:46,000 --> 00:22:47,760
outputs for

609
00:22:47,760 --> 00:22:49,919
these applications

610
00:22:49,919 --> 00:22:51,919
and what we we rather do for our

611
00:22:51,919 --> 00:22:53,840
generalized channels is that we have

612
00:22:53,840 --> 00:22:55,760
still a commit transaction

613
00:22:55,760 --> 00:22:56,960
but

614
00:22:56,960 --> 00:22:59,200
this commit transaction now only has two

615
00:22:59,200 --> 00:23:01,440
outputs one output for all the

616
00:23:01,440 --> 00:23:03,600
applications that run in the channel and

617
00:23:03,600 --> 00:23:06,159
one output for the punishment

618
00:23:06,159 --> 00:23:07,600
and then we have a second transaction

619
00:23:07,600 --> 00:23:09,760
which we call split transaction and the

620
00:23:09,760 --> 00:23:12,240
split transaction spends the application

621
00:23:12,240 --> 00:23:14,559
output from the commit transaction and

622
00:23:14,559 --> 00:23:16,720
holds actually all the applications that

623
00:23:16,720 --> 00:23:17,440
run

624
00:23:17,440 --> 00:23:20,080
in the channel

625
00:23:20,080 --> 00:23:21,919
so now if you consider the case that for

626
00:23:21,919 --> 00:23:24,480
example bob is cheating and he commits

627
00:23:24,480 --> 00:23:25,919
an old um

628
00:23:25,919 --> 00:23:28,559
commit transaction then alice can punish

629
00:23:28,559 --> 00:23:32,320
bob by spending uh the punishment output

630
00:23:32,320 --> 00:23:34,799
and by this alice punishes all the

631
00:23:34,799 --> 00:23:36,559
applications that run

632
00:23:36,559 --> 00:23:40,080
in the channel at the same time

633
00:23:40,400 --> 00:23:42,320
so with this we can decouple the

634
00:23:42,320 --> 00:23:44,720
punishment from the applications

635
00:23:44,720 --> 00:23:46,720
but we still have the state duplication

636
00:23:46,720 --> 00:23:48,880
so right now we still have two distinct

637
00:23:48,880 --> 00:23:52,640
commits and split transactions

638
00:23:53,120 --> 00:23:54,400
um

639
00:23:54,400 --> 00:23:55,360
so

640
00:23:55,360 --> 00:23:56,880
this is the situation that we have right

641
00:23:56,880 --> 00:23:58,720
now we have uh the funding transaction

642
00:23:58,720 --> 00:24:00,960
and two to um

643
00:24:00,960 --> 00:24:02,400
distinct commit transaction and we would

644
00:24:02,400 --> 00:24:04,559
like to remove the state duplication so

645
00:24:04,559 --> 00:24:06,799
what we would actually like to have is a

646
00:24:06,799 --> 00:24:08,320
transaction design that looks more like

647
00:24:08,320 --> 00:24:10,080
this where we have one funding

648
00:24:10,080 --> 00:24:11,919
transaction one commit transaction and

649
00:24:11,919 --> 00:24:14,080
one split transaction

650
00:24:14,080 --> 00:24:15,919
but how can we achieve this

651
00:24:15,919 --> 00:24:16,720
well

652
00:24:16,720 --> 00:24:20,960
our idea is to use adapter signatures

653
00:24:21,279 --> 00:24:23,520
and i will give a high level overview of

654
00:24:23,520 --> 00:24:25,200
how the update procedure of our

655
00:24:25,200 --> 00:24:27,520
generalized channel works

656
00:24:27,520 --> 00:24:30,320
so as to explain to

657
00:24:30,320 --> 00:24:32,640
how we use adapter signatures to have

658
00:24:32,640 --> 00:24:35,360
only one commit transaction

659
00:24:35,360 --> 00:24:37,039
so if we assume we have parties alice

660
00:24:37,039 --> 00:24:40,000
and bob and both of them have a key pair

661
00:24:40,000 --> 00:24:42,159
then in order to update a

662
00:24:42,159 --> 00:24:44,400
generalized channel between us and bob

663
00:24:44,400 --> 00:24:46,720
as a first step both of them

664
00:24:46,720 --> 00:24:48,960
agree on a new commit transaction and a

665
00:24:48,960 --> 00:24:52,159
new split transaction

666
00:24:52,159 --> 00:24:54,080
then both of the parties

667
00:24:54,080 --> 00:24:55,360
um

668
00:24:55,360 --> 00:24:58,240
sample a statement and witness pair

669
00:24:58,240 --> 00:25:01,360
from the adapter signature relation

670
00:25:01,360 --> 00:25:03,440
and they exchange the statements that

671
00:25:03,440 --> 00:25:06,400
they just sampled

672
00:25:07,679 --> 00:25:09,200
as a next step

673
00:25:09,200 --> 00:25:11,039
both of them

674
00:25:11,039 --> 00:25:12,640
create a pre-signature under their

675
00:25:12,640 --> 00:25:15,120
respective secret keys for the commit

676
00:25:15,120 --> 00:25:16,400
transaction

677
00:25:16,400 --> 00:25:19,360
and for the statement of the other party

678
00:25:19,360 --> 00:25:21,360
so for example alice creates a

679
00:25:21,360 --> 00:25:23,520
pre-signature under her secret key for

680
00:25:23,520 --> 00:25:25,679
the commit transaction and for the

681
00:25:25,679 --> 00:25:29,120
statement that bob sampled previously

682
00:25:29,120 --> 00:25:30,960
and then finally the two parties

683
00:25:30,960 --> 00:25:33,520
exchanged the pre-signatures

684
00:25:33,520 --> 00:25:34,880
so here

685
00:25:34,880 --> 00:25:37,200
i want to point out that now alice for

686
00:25:37,200 --> 00:25:38,240
example

687
00:25:38,240 --> 00:25:42,320
can adapt bob's pre-signature using her

688
00:25:42,320 --> 00:25:43,919
secret uh

689
00:25:43,919 --> 00:25:47,120
her witness wa to a full signature and

690
00:25:47,120 --> 00:25:49,279
she can then use this full signature to

691
00:25:49,279 --> 00:25:51,520
spend the commit transaction and bob can

692
00:25:51,520 --> 00:25:54,840
do the same thing with alice's

693
00:25:54,840 --> 00:25:56,960
pre-signature and then at the end of our

694
00:25:56,960 --> 00:25:58,720
update uh just like for lightning

695
00:25:58,720 --> 00:26:00,960
channels we have the

696
00:26:00,960 --> 00:26:02,559
usual revocation

697
00:26:02,559 --> 00:26:04,720
where parties exchange their revocation

698
00:26:04,720 --> 00:26:06,720
secrets

699
00:26:06,720 --> 00:26:08,240
and now the crucial point of this is

700
00:26:08,240 --> 00:26:08,960
that

701
00:26:08,960 --> 00:26:10,480
if alice publishes now the commit

702
00:26:10,480 --> 00:26:12,640
transaction with the signature that she

703
00:26:12,640 --> 00:26:15,440
adapted from bob then bob can extract

704
00:26:15,440 --> 00:26:19,360
the witness wa from alice

705
00:26:19,840 --> 00:26:21,840
and we can use this observation to

706
00:26:21,840 --> 00:26:24,080
require only one commit transaction in

707
00:26:24,080 --> 00:26:26,000
our transaction design

708
00:26:26,000 --> 00:26:28,480
so this is our actual transaction design

709
00:26:28,480 --> 00:26:30,080
for our construction

710
00:26:30,080 --> 00:26:32,080
um so we have one funding transaction

711
00:26:32,080 --> 00:26:34,159
one commit transaction one split

712
00:26:34,159 --> 00:26:35,360
transaction

713
00:26:35,360 --> 00:26:38,000
and now the commit transaction holds the

714
00:26:38,000 --> 00:26:40,159
punishment output which can be spent by

715
00:26:40,159 --> 00:26:42,240
either alice or bob

716
00:26:42,240 --> 00:26:43,919
and this output can be spent under the

717
00:26:43,919 --> 00:26:46,640
condition that first both parties or

718
00:26:46,640 --> 00:26:48,559
either of the party knows the revocation

719
00:26:48,559 --> 00:26:51,360
secret of the other party and it has to

720
00:26:51,360 --> 00:26:54,320
know the the witness of the other party

721
00:26:54,320 --> 00:26:57,200
so for example alice if she wants to

722
00:26:57,200 --> 00:26:59,279
um spend the punishment output of the

723
00:26:59,279 --> 00:27:02,320
commit transaction then she has to uh

724
00:27:02,320 --> 00:27:05,039
provide proof that she knows uh the

725
00:27:05,039 --> 00:27:07,679
revocation secret of bob y i

726
00:27:07,679 --> 00:27:11,600
and the witness of bob wb

727
00:27:11,600 --> 00:27:14,320
y i indicates that the commit

728
00:27:14,320 --> 00:27:17,200
transaction is actually a revoked sort

729
00:27:17,200 --> 00:27:20,320
an old commit transaction whereas wb

730
00:27:20,320 --> 00:27:22,399
indicates that bob was actually the

731
00:27:22,399 --> 00:27:24,799
party that published a commit

732
00:27:24,799 --> 00:27:27,039
transaction so bob was the malicious

733
00:27:27,039 --> 00:27:29,039
party that published an old commit

734
00:27:29,039 --> 00:27:31,600
transaction

735
00:27:31,600 --> 00:27:33,200
i want to

736
00:27:33,200 --> 00:27:35,520
note that this is an a simplified

737
00:27:35,520 --> 00:27:37,919
transaction design of our construction

738
00:27:37,919 --> 00:27:39,039
we actually

739
00:27:39,039 --> 00:27:41,279
require a little bit more than this so

740
00:27:41,279 --> 00:27:43,919
we require additionally time locks

741
00:27:43,919 --> 00:27:44,720
but

742
00:27:44,720 --> 00:27:46,480
that is all that we require

743
00:27:46,480 --> 00:27:48,640
so our construction works for

744
00:27:48,640 --> 00:27:53,279
blockchains that support time locks and

745
00:27:53,279 --> 00:27:55,840
signature verification

746
00:27:55,840 --> 00:27:58,399
whereas lightning channels for example

747
00:27:58,399 --> 00:27:59,760
require additionally to these

748
00:27:59,760 --> 00:28:01,120
assumptions

749
00:28:01,120 --> 00:28:03,760
hash hashlocks

750
00:28:04,480 --> 00:28:05,919
as a summary for our generalized

751
00:28:05,919 --> 00:28:07,440
channels

752
00:28:07,440 --> 00:28:09,279
we developed the first bi-directional

753
00:28:09,279 --> 00:28:11,679
channel protocol for utxo-based

754
00:28:11,679 --> 00:28:14,880
blockchains that require only one

755
00:28:14,880 --> 00:28:16,720
commit transaction

756
00:28:16,720 --> 00:28:18,399
that does not require this punish

757
00:28:18,399 --> 00:28:20,640
purplication mechanism but follows the

758
00:28:20,640 --> 00:28:23,679
punished and split paradigm

759
00:28:23,679 --> 00:28:25,840
and that only relies on minimal

760
00:28:25,840 --> 00:28:28,640
assumptions of the underlying blockchain

761
00:28:28,640 --> 00:28:30,480
that is signature verification and time

762
00:28:30,480 --> 00:28:32,640
blocks

763
00:28:32,640 --> 00:28:35,039
and for further details

764
00:28:35,039 --> 00:28:38,559
please go ahead and check our paper

765
00:28:38,559 --> 00:28:40,880
i want to now talk about our performance

766
00:28:40,880 --> 00:28:42,960
evaluation and about some applications

767
00:28:42,960 --> 00:28:44,880
for generalized channels

768
00:28:44,880 --> 00:28:45,919
so

769
00:28:45,919 --> 00:28:48,240
we implemented our generalized channel

770
00:28:48,240 --> 00:28:50,080
solution and we deployed it on the

771
00:28:50,080 --> 00:28:52,480
bitcoin test net in order to be able to

772
00:28:52,480 --> 00:28:54,799
compare it to lightning channels so what

773
00:28:54,799 --> 00:28:56,840
we wanted to see is how do generalized

774
00:28:56,840 --> 00:28:59,360
channels scale in comparison to

775
00:28:59,360 --> 00:29:00,799
lightning channels

776
00:29:00,799 --> 00:29:02,080
considering

777
00:29:02,080 --> 00:29:04,080
some number of applications that run in

778
00:29:04,080 --> 00:29:07,279
the channel and as applications we chose

779
00:29:07,279 --> 00:29:09,200
time log contracts because those are the

780
00:29:09,200 --> 00:29:10,880
most common applications that run in

781
00:29:10,880 --> 00:29:12,559
lightning channels

782
00:29:12,559 --> 00:29:14,399
so as a first step we

783
00:29:14,399 --> 00:29:16,799
evaluated

784
00:29:16,799 --> 00:29:17,919
how much

785
00:29:17,919 --> 00:29:20,640
byte overhead is incurred during an

786
00:29:20,640 --> 00:29:22,880
update procedure that happens off-chain

787
00:29:22,880 --> 00:29:24,960
[Music]

788
00:29:24,960 --> 00:29:26,480
in relation to the number of

789
00:29:26,480 --> 00:29:28,720
applications that run in the channel

790
00:29:28,720 --> 00:29:30,559
so what we can see here in this graph is

791
00:29:30,559 --> 00:29:33,120
on the x-axis is the number of

792
00:29:33,120 --> 00:29:34,960
of hashtag contracts that run in the

793
00:29:34,960 --> 00:29:36,799
channel and on the y-axis we see the

794
00:29:36,799 --> 00:29:39,279
byte overhead that is being incurred

795
00:29:39,279 --> 00:29:40,799
and what we can see is that already for

796
00:29:40,799 --> 00:29:43,840
one hashtag contract

797
00:29:43,840 --> 00:29:46,159
the divide overhead is better for

798
00:29:46,159 --> 00:29:47,760
generalized channels than for lightning

799
00:29:47,760 --> 00:29:50,080
channels and this gap

800
00:29:50,080 --> 00:29:52,640
increases with an increasing number of

801
00:29:52,640 --> 00:29:54,240
hash timer contracts running in the

802
00:29:54,240 --> 00:29:55,360
channel

803
00:29:55,360 --> 00:29:57,520
and this is because for lightning

804
00:29:57,520 --> 00:29:59,840
channels there are two plus two m

805
00:29:59,840 --> 00:30:02,159
transactions required to be exchanged

806
00:30:02,159 --> 00:30:05,200
for an update where m is the number of

807
00:30:05,200 --> 00:30:07,360
uh hash timer contracts

808
00:30:07,360 --> 00:30:09,039
whereas for generalized channels there

809
00:30:09,039 --> 00:30:10,799
are only two transactions that have to

810
00:30:10,799 --> 00:30:13,440
be exchanged

811
00:30:13,440 --> 00:30:15,200
we then also looked at the pessimistic

812
00:30:15,200 --> 00:30:17,360
case that means the case where a

813
00:30:17,360 --> 00:30:19,279
punishment actually has to happen on the

814
00:30:19,279 --> 00:30:20,399
blockchain

815
00:30:20,399 --> 00:30:22,799
so we looked at the on-chain course in

816
00:30:22,799 --> 00:30:24,880
bytes in comparison to the number of

817
00:30:24,880 --> 00:30:26,960
hashtag timelock contracts running in

818
00:30:26,960 --> 00:30:29,039
the channel and what we can see is that

819
00:30:29,039 --> 00:30:31,279
for generalized channels um

820
00:30:31,279 --> 00:30:33,600
the byte overhead is constant so it's

821
00:30:33,600 --> 00:30:35,440
independent of the number of time log

822
00:30:35,440 --> 00:30:37,039
contracts

823
00:30:37,039 --> 00:30:39,440
and this is just because of the fact

824
00:30:39,440 --> 00:30:40,159
that

825
00:30:40,159 --> 00:30:42,159
generalized channels

826
00:30:42,159 --> 00:30:46,559
follow the punished and split paradigm

827
00:30:47,200 --> 00:30:49,440
so more concretely for lightning

828
00:30:49,440 --> 00:30:50,799
channels we have

829
00:30:50,799 --> 00:30:52,960
two plus m transactions that have to be

830
00:30:52,960 --> 00:30:54,880
posted on the blockchain whereas for

831
00:30:54,880 --> 00:30:56,320
generous channels we only have two

832
00:30:56,320 --> 00:30:58,960
transactions

833
00:30:58,960 --> 00:31:00,640
i will now briefly talk also a little

834
00:31:00,640 --> 00:31:02,720
bit about applications for our generous

835
00:31:02,720 --> 00:31:03,679
channels

836
00:31:03,679 --> 00:31:06,480
so like i said before

837
00:31:06,480 --> 00:31:07,840
in general

838
00:31:07,840 --> 00:31:10,159
generalized channels can be

839
00:31:10,159 --> 00:31:11,919
used to execute any two-party

840
00:31:11,919 --> 00:31:13,840
application off-chain that could

841
00:31:13,840 --> 00:31:15,679
otherwise also be executed on the

842
00:31:15,679 --> 00:31:17,200
blockchain

843
00:31:17,200 --> 00:31:19,600
and a little bit more concretely

844
00:31:19,600 --> 00:31:21,360
generous channels could be used for

845
00:31:21,360 --> 00:31:24,000
example to execute the fair two-party

846
00:31:24,000 --> 00:31:26,320
computation protocol that was introduced

847
00:31:26,320 --> 00:31:29,360
by benthaven kumaresan in crypto

848
00:31:29,360 --> 00:31:31,279
2014

849
00:31:31,279 --> 00:31:33,120
or it could be used to

850
00:31:33,120 --> 00:31:35,200
execute the channel splitting protocol

851
00:31:35,200 --> 00:31:38,320
that was um introduced by aggregate all

852
00:31:38,320 --> 00:31:40,559
at ccs 2019

853
00:31:40,559 --> 00:31:42,799
where a channel can be split into two or

854
00:31:42,799 --> 00:31:46,240
even multiple channels of chain or it

855
00:31:46,240 --> 00:31:49,200
could be used for virtual channels where

856
00:31:49,200 --> 00:31:51,120
basically two generalized channels are

857
00:31:51,120 --> 00:31:52,799
used to

858
00:31:52,799 --> 00:31:54,640
build another channel a so-called

859
00:31:54,640 --> 00:31:58,000
virtual channel of chain

860
00:31:58,799 --> 00:32:00,880
so with this i want to sum up

861
00:32:00,880 --> 00:32:03,440
uh in our work we presented an efficient

862
00:32:03,440 --> 00:32:05,120
application agnostic cheap and

863
00:32:05,120 --> 00:32:07,200
interoperable

864
00:32:07,200 --> 00:32:09,919
channel solution that requires only one

865
00:32:09,919 --> 00:32:11,519
commit transaction

866
00:32:11,519 --> 00:32:13,360
is applica has application agnostic

867
00:32:13,360 --> 00:32:14,720
punishment

868
00:32:14,720 --> 00:32:15,519
and

869
00:32:15,519 --> 00:32:17,279
requires only minimal assumptions from

870
00:32:17,279 --> 00:32:20,399
the underlying blockchain

871
00:32:20,960 --> 00:32:23,039
thank you for your attention and we are

872
00:32:23,039 --> 00:32:27,440
looking forward to your questions

