1
00:01:00,680 --> 00:01:03,739
thank you

2
00:01:29,640 --> 00:01:31,880
foreign

3
00:02:04,560 --> 00:02:06,680
okay

4
00:02:27,740 --> 00:02:28,260
[Music]

5
00:02:28,260 --> 00:02:30,260
um

6
00:02:37,680 --> 00:02:40,680
foreign

7
00:02:44,590 --> 00:02:47,650
[Music]

8
00:03:13,500 --> 00:03:16,260
protocols

9
00:03:16,260 --> 00:03:18,360
um the first talk is on key scheduled

10
00:03:18,360 --> 00:03:22,400
security for the TLs 1.3 standards like

11
00:03:22,400 --> 00:03:25,560
Antoine delinio level sorry for

12
00:03:25,560 --> 00:03:28,920
butchering that uh Christopher Cedric

13
00:03:28,920 --> 00:03:31,440
funny Conrad cool book and Markov

14
00:03:31,440 --> 00:03:32,700
culvice

15
00:03:32,700 --> 00:03:35,459
and Christopher give the talk

16
00:03:35,459 --> 00:03:36,659
okay

17
00:03:36,659 --> 00:03:37,860
um

18
00:03:37,860 --> 00:03:40,260
so I'm going to talk about uh TLS

19
00:03:40,260 --> 00:03:43,200
schedule security and the first note

20
00:03:43,200 --> 00:03:45,959
maybe uh for me this uh project was a

21
00:03:45,959 --> 00:03:48,360
lot about figuring out how to work with

22
00:03:48,360 --> 00:03:51,480
complex protocols and how to build like

23
00:03:51,480 --> 00:03:53,519
modular proofs that allow us to handle

24
00:03:53,519 --> 00:03:56,040
this kind of protocol

25
00:03:56,040 --> 00:03:56,760
um

26
00:03:56,760 --> 00:03:59,099
if you like if you if you missed some

27
00:03:59,099 --> 00:04:00,200
key

28
00:04:00,200 --> 00:04:02,459
exchange-ish uh introduction there's

29
00:04:02,459 --> 00:04:03,720
also a very nice five minute

30
00:04:03,720 --> 00:04:06,120
introductory talk by Chris that is

31
00:04:06,120 --> 00:04:08,459
online so you can also check check this

32
00:04:08,459 --> 00:04:09,959
out

33
00:04:09,959 --> 00:04:11,700
um

34
00:04:11,700 --> 00:04:14,459
ah perfect that's actually working

35
00:04:14,459 --> 00:04:17,940
um so um at the very start uh so maybe

36
00:04:17,940 --> 00:04:19,199
first uh

37
00:04:19,199 --> 00:04:21,899
a revisit key exchange key exchange is

38
00:04:21,899 --> 00:04:24,120
just a protocol where um two parties uh

39
00:04:24,120 --> 00:04:25,680
execute a

40
00:04:25,680 --> 00:04:27,660
exchange messages

41
00:04:27,660 --> 00:04:28,199
um

42
00:04:28,199 --> 00:04:29,759
and in the end

43
00:04:29,759 --> 00:04:31,740
um they both derive some sort of

44
00:04:31,740 --> 00:04:34,199
symmetric key and this can then for

45
00:04:34,199 --> 00:04:36,479
example be used to create a secure

46
00:04:36,479 --> 00:04:38,880
Channel which allows the two parties to

47
00:04:38,880 --> 00:04:40,440
securely communicate

48
00:04:40,440 --> 00:04:42,800
and um

49
00:04:42,800 --> 00:04:45,240
heat exchange property costs may even

50
00:04:45,240 --> 00:04:48,240
derive more than one key they can come

51
00:04:48,240 --> 00:04:50,100
up with quite a lot of keys and one of

52
00:04:50,100 --> 00:04:52,560
the ideas why would you do that well one

53
00:04:52,560 --> 00:04:54,900
is that you can have different uses so

54
00:04:54,900 --> 00:04:56,759
you can have a second channel for the

55
00:04:56,759 --> 00:04:58,320
other direction

56
00:04:58,320 --> 00:05:01,139
or you can export these keys for

57
00:05:01,139 --> 00:05:03,540
external use and then be sure

58
00:05:03,540 --> 00:05:06,600
this concrete instance of a symmetric

59
00:05:06,600 --> 00:05:08,820
key will not be confused with one that

60
00:05:08,820 --> 00:05:10,979
will be that can be used for a secure

61
00:05:10,979 --> 00:05:13,440
Channel establishment

62
00:05:13,440 --> 00:05:14,280
um

63
00:05:14,280 --> 00:05:17,220
so it can be useful to have many keys

64
00:05:17,220 --> 00:05:19,259
now the question is if you have many

65
00:05:19,259 --> 00:05:21,479
keys how do you end up at having many

66
00:05:21,479 --> 00:05:24,539
keys and oh

67
00:05:24,539 --> 00:05:25,759
okay yeah

68
00:05:25,759 --> 00:05:28,560
note that I missed um

69
00:05:28,560 --> 00:05:31,020
uh we're looking at protocols and we

70
00:05:31,020 --> 00:05:32,759
want to have many executions in parallel

71
00:05:32,759 --> 00:05:35,820
so we also of course have some sessions

72
00:05:35,820 --> 00:05:38,039
some interactions in this key exchange

73
00:05:38,039 --> 00:05:40,199
where the adversary plays one of the

74
00:05:40,199 --> 00:05:43,139
rows so some of these keys

75
00:05:43,139 --> 00:05:45,120
will be known to the adversaries and

76
00:05:45,120 --> 00:05:47,820
some will not and I think this is kind

77
00:05:47,820 --> 00:05:49,740
of somewhat important to Kim but keep in

78
00:05:49,740 --> 00:05:51,840
mind that some of the keys that we

79
00:05:51,840 --> 00:05:53,460
produce in this protocol will be known

80
00:05:53,460 --> 00:05:54,780
to the adversary

81
00:05:54,780 --> 00:05:56,520
and we only want guarantees for the

82
00:05:56,520 --> 00:05:57,960
other keys

83
00:05:57,960 --> 00:06:01,560
so um this is where I was going to so

84
00:06:01,560 --> 00:06:04,620
how do you end up having many keys and

85
00:06:04,620 --> 00:06:06,780
this is essentially the key schedule

86
00:06:06,780 --> 00:06:10,259
and as you see at this example for TLS

87
00:06:10,259 --> 00:06:11,780
this can be quite a complicated

88
00:06:11,780 --> 00:06:15,120
cryptographic primitive in its own

89
00:06:15,120 --> 00:06:17,940
um all the Lower Keys are actually

90
00:06:17,940 --> 00:06:20,580
um well clicker so all these Keys here

91
00:06:20,580 --> 00:06:23,340
are actually keys that are exported by

92
00:06:23,340 --> 00:06:25,259
TLS

93
00:06:25,259 --> 00:06:25,979
um

94
00:06:25,979 --> 00:06:29,100
so um given that this is somewhat

95
00:06:29,100 --> 00:06:31,080
complicated in its own it might be a

96
00:06:31,080 --> 00:06:33,660
good question to think about uh can I

97
00:06:33,660 --> 00:06:35,400
reason about this primitive in its own

98
00:06:35,400 --> 00:06:36,120
right

99
00:06:36,120 --> 00:06:38,039
and then end up with something like this

100
00:06:38,039 --> 00:06:41,280
where I start from having a protocol

101
00:06:41,280 --> 00:06:43,680
and instead of analyzing this protocol

102
00:06:43,680 --> 00:06:46,199
as a whole thing I split this up and I

103
00:06:46,199 --> 00:06:48,720
have a part that only considers itself

104
00:06:48,720 --> 00:06:51,600
about message flows and all that kind of

105
00:06:51,600 --> 00:06:54,660
thing and as a second part that models

106
00:06:54,660 --> 00:06:56,100
the key schedule and its security

107
00:06:56,100 --> 00:06:58,380
properties and this is what we are

108
00:06:58,380 --> 00:07:00,840
trying to do in this way

109
00:07:00,840 --> 00:07:01,800
um

110
00:07:01,800 --> 00:07:04,020
and then you get a very nice modular

111
00:07:04,020 --> 00:07:05,340
proof

112
00:07:05,340 --> 00:07:08,699
so you have a first part here that talks

113
00:07:08,699 --> 00:07:11,400
about how this key schedule helps us to

114
00:07:11,400 --> 00:07:14,100
reach kick exchange security and you

115
00:07:14,100 --> 00:07:16,500
have a other part that

116
00:07:16,500 --> 00:07:18,720
um argue security of the key schedule

117
00:07:18,720 --> 00:07:21,720
and we do have a lot more

118
00:07:21,720 --> 00:07:24,360
structure in this as well

119
00:07:24,360 --> 00:07:26,220
um

120
00:07:26,220 --> 00:07:28,139
so um

121
00:07:28,139 --> 00:07:30,960
before we like go into the details of

122
00:07:30,960 --> 00:07:33,419
how you prove such a thing uh let's take

123
00:07:33,419 --> 00:07:37,500
a look at the model and um here this is

124
00:07:37,500 --> 00:07:39,780
um to explain how how this description

125
00:07:39,780 --> 00:07:42,539
Works uh there are packages here

126
00:07:42,539 --> 00:07:45,240
packages are just like objects that

127
00:07:45,240 --> 00:07:47,819
contain code so a package has like

128
00:07:47,819 --> 00:07:50,340
methods that you can call on it

129
00:07:50,340 --> 00:07:53,819
and we call them oracles and the arrows

130
00:07:53,819 --> 00:07:55,860
are just a requests

131
00:07:55,860 --> 00:07:58,860
so the adversary here calls an extract

132
00:07:58,860 --> 00:08:01,860
Oracle on this extract package which

133
00:08:01,860 --> 00:08:03,840
does then some operations

134
00:08:03,840 --> 00:08:06,660
and here you find also the Oracle names

135
00:08:06,660 --> 00:08:08,819
so no way this is just like a call graph

136
00:08:08,819 --> 00:08:10,139
that you would expect from object

137
00:08:10,139 --> 00:08:13,139
oriented programming and it also neatly

138
00:08:13,139 --> 00:08:16,440
fits into this design of uh code based

139
00:08:16,440 --> 00:08:19,680
proofs so we have like all for all of

140
00:08:19,680 --> 00:08:20,780
this

141
00:08:20,780 --> 00:08:24,360
elements on the slide we do have

142
00:08:24,360 --> 00:08:26,879
a code-based description it's just split

143
00:08:26,879 --> 00:08:29,160
up into manageable parts

144
00:08:29,160 --> 00:08:31,440
and then we can talk about this part

145
00:08:31,440 --> 00:08:33,240
individually

146
00:08:33,240 --> 00:08:35,419
so um the first part here that we have

147
00:08:35,419 --> 00:08:38,039
that has this check thing

148
00:08:38,039 --> 00:08:40,500
while we try to look at a key schedule

149
00:08:40,500 --> 00:08:43,020
in isolation we do want to import some

150
00:08:43,020 --> 00:08:44,399
security properties from the key

151
00:08:44,399 --> 00:08:47,160
exchange and here this check just

152
00:08:47,160 --> 00:08:50,040
disallows the adversary on the left to

153
00:08:50,040 --> 00:08:52,080
make some interaction with the key

154
00:08:52,080 --> 00:08:53,220
schedule

155
00:08:53,220 --> 00:08:55,200
um that it wouldn't be able to do in a

156
00:08:55,200 --> 00:08:57,360
key exchange protocol and that we need

157
00:08:57,360 --> 00:08:58,800
to prove properties

158
00:08:58,800 --> 00:09:01,380
and I will come back to that in uh in a

159
00:09:01,380 --> 00:09:02,640
bit

160
00:09:02,640 --> 00:09:04,740
um then we have um the part that

161
00:09:04,740 --> 00:09:06,480
actually computes the key schedule

162
00:09:06,480 --> 00:09:09,120
and if you remember the picture that we

163
00:09:09,120 --> 00:09:09,839
had

164
00:09:09,839 --> 00:09:11,880
here we have like this expand and

165
00:09:11,880 --> 00:09:13,800
extract functions

166
00:09:13,800 --> 00:09:14,940
um which are

167
00:09:14,940 --> 00:09:18,120
standard key derivation functions and we

168
00:09:18,120 --> 00:09:21,060
have for them we have here an extract

169
00:09:21,060 --> 00:09:23,640
and expand and we also do have

170
00:09:23,640 --> 00:09:26,339
diffie-hellman over here because we do

171
00:09:26,339 --> 00:09:29,760
model properties of different and

172
00:09:29,760 --> 00:09:32,160
finally we have what's called game here

173
00:09:32,160 --> 00:09:35,040
uh game is taking care of both storing

174
00:09:35,040 --> 00:09:36,360
information

175
00:09:36,360 --> 00:09:39,720
uh and for modeling security properties

176
00:09:39,720 --> 00:09:42,240
and um

177
00:09:42,240 --> 00:09:44,339
security properties I mean I probably

178
00:09:44,339 --> 00:09:46,380
don't need to explain this to you but

179
00:09:46,380 --> 00:09:47,940
you usually you have a game-based

180
00:09:47,940 --> 00:09:50,040
security definition so you have a real

181
00:09:50,040 --> 00:09:51,060
game

182
00:09:51,060 --> 00:09:53,820
and you compare this with an idealized

183
00:09:53,820 --> 00:09:55,560
version of this game

184
00:09:55,560 --> 00:09:57,600
and then you claim that or you require

185
00:09:57,600 --> 00:09:58,860
that they are computationally

186
00:09:58,860 --> 00:10:01,980
indistinguishable for an adversible

187
00:10:01,980 --> 00:10:04,140
um we allow ourselves a bit more freedom

188
00:10:04,140 --> 00:10:05,339
in the spec

189
00:10:05,339 --> 00:10:08,100
and do simulation-based security so we

190
00:10:08,100 --> 00:10:11,220
don't require that the protocol in the

191
00:10:11,220 --> 00:10:13,440
real and the ideal version are exactly

192
00:10:13,440 --> 00:10:14,459
the same

193
00:10:14,459 --> 00:10:16,279
but we just

194
00:10:16,279 --> 00:10:18,240
demand the existence of certain

195
00:10:18,240 --> 00:10:20,580
simulator and then have the security

196
00:10:20,580 --> 00:10:24,000
properties and functionality and

197
00:10:24,000 --> 00:10:26,040
let's talk about the security properties

198
00:10:26,040 --> 00:10:28,320
that we are looking at

199
00:10:28,320 --> 00:10:28,980
um

200
00:10:28,980 --> 00:10:31,440
so there's the adversary here that's

201
00:10:31,440 --> 00:10:33,779
interacting with the sket

202
00:10:33,779 --> 00:10:36,920
a method or get Oracle on this package

203
00:10:36,920 --> 00:10:39,959
and this is for retrieving output keys

204
00:10:39,959 --> 00:10:41,880
if you're familiar with key exchange you

205
00:10:41,880 --> 00:10:43,440
usually have something like a test query

206
00:10:43,440 --> 00:10:44,760
that um

207
00:10:44,760 --> 00:10:49,680
uh gives you the produced output key and

208
00:10:49,680 --> 00:10:51,240
this is kind of similar

209
00:10:51,240 --> 00:10:54,660
so um and what do we want uh first thing

210
00:10:54,660 --> 00:10:57,660
we want that these keys are pseudorandom

211
00:10:57,660 --> 00:11:00,600
uh and of course as I said like we only

212
00:11:00,600 --> 00:11:02,940
want them to be pseudonym for keys that

213
00:11:02,940 --> 00:11:05,579
are supposed to be like inaccessible to

214
00:11:05,579 --> 00:11:07,079
the adversary

215
00:11:07,079 --> 00:11:09,839
so this um that's exactly what we

216
00:11:09,839 --> 00:11:11,880
require here

217
00:11:11,880 --> 00:11:13,079
um

218
00:11:13,079 --> 00:11:16,980
so if the key was honest we don't store

219
00:11:16,980 --> 00:11:20,700
the key as produced by the key schedule

220
00:11:20,700 --> 00:11:23,339
protocol which is just store a pseudo

221
00:11:23,339 --> 00:11:25,800
random string and then the adversary

222
00:11:25,800 --> 00:11:29,040
needs to distinguish second property we

223
00:11:29,040 --> 00:11:31,980
want is a model in this lock part here

224
00:11:31,980 --> 00:11:36,000
and here we require that t is produced

225
00:11:36,000 --> 00:11:38,519
by different Trace execution traces

226
00:11:38,519 --> 00:11:41,339
through this key schedule will not end

227
00:11:41,339 --> 00:11:44,339
up at the same value so this H here is a

228
00:11:44,339 --> 00:11:47,519
handle and we come to that also in a

229
00:11:47,519 --> 00:11:49,620
second and it just models the execution

230
00:11:49,620 --> 00:11:52,380
Trace so how do I arrive at this key in

231
00:11:52,380 --> 00:11:56,519
the end and there should not be um two

232
00:11:56,519 --> 00:12:00,839
identical Keys derived in uh

233
00:12:00,839 --> 00:12:03,839
differ like or on different paths

234
00:12:03,839 --> 00:12:05,940
so this is the security properties that

235
00:12:05,940 --> 00:12:08,880
we have in that real model numbers but

236
00:12:08,880 --> 00:12:09,899
um

237
00:12:09,899 --> 00:12:13,140
now this game here is a big package

238
00:12:13,140 --> 00:12:15,720
in fact for

239
00:12:15,720 --> 00:12:17,519
for the first proof step that I'm

240
00:12:17,519 --> 00:12:19,079
showing in a minute it's way more

241
00:12:19,079 --> 00:12:21,060
convenient to have it split up

242
00:12:21,060 --> 00:12:22,860
and we have

243
00:12:22,860 --> 00:12:25,920
uh Key and Locks combinations for

244
00:12:25,920 --> 00:12:28,320
different types of keys so we have input

245
00:12:28,320 --> 00:12:30,600
Keys up here like intermediate Keys here

246
00:12:30,600 --> 00:12:33,360
and output keys and then we can and in

247
00:12:33,360 --> 00:12:37,560
game steps change Properties or like

248
00:12:37,560 --> 00:12:39,899
requirements we have on these keys until

249
00:12:39,899 --> 00:12:43,380
we arrive at the ideal security game

250
00:12:43,380 --> 00:12:45,720
and it's actually even a bit more

251
00:12:45,720 --> 00:12:48,120
complicated because we do have one of

252
00:12:48,120 --> 00:12:49,980
these packages for each key derivation

253
00:12:49,980 --> 00:12:53,100
operation and for each key name and then

254
00:12:53,100 --> 00:12:55,139
we can just like argue for a step by

255
00:12:55,139 --> 00:12:59,459
step and game steps over individual keys

256
00:12:59,459 --> 00:13:01,320
um and this will then end up being the

257
00:13:01,320 --> 00:13:03,360
functionality that we export and the

258
00:13:03,360 --> 00:13:06,120
rest will be the simulator

259
00:13:06,120 --> 00:13:07,019
um

260
00:13:07,019 --> 00:13:09,000
you know

261
00:13:09,000 --> 00:13:12,600
so um I introduced this concept of

262
00:13:12,600 --> 00:13:14,639
Handler but informally already so let's

263
00:13:14,639 --> 00:13:16,560
look at this in more detail so Handler

264
00:13:16,560 --> 00:13:18,839
is something that identifies the key

265
00:13:18,839 --> 00:13:21,660
and we use this when you set a key so

266
00:13:21,660 --> 00:13:23,880
when you first introduce a symmetric key

267
00:13:23,880 --> 00:13:26,820
the tlslrs and also like in

268
00:13:26,820 --> 00:13:28,260
diffie-helling Key

269
00:13:28,260 --> 00:13:31,200
um we have them for key derivation so if

270
00:13:31,200 --> 00:13:33,240
you there are if the adversary

271
00:13:33,240 --> 00:13:37,139
instructor this game to derive a key

272
00:13:37,139 --> 00:13:39,959
um it identifies the input keys by their

273
00:13:39,959 --> 00:13:41,160
handles

274
00:13:41,160 --> 00:13:44,160
and the game or the key schedule then

275
00:13:44,160 --> 00:13:45,839
returns to the adversary and a new

276
00:13:45,839 --> 00:13:47,940
identifier for for this key that was

277
00:13:47,940 --> 00:13:50,940
computed and this is the same for the

278
00:13:50,940 --> 00:13:52,500
other operations

279
00:13:52,500 --> 00:13:54,899
and this is also how you access output

280
00:13:54,899 --> 00:13:57,300
keys in the end

281
00:13:57,300 --> 00:13:59,220
um

282
00:13:59,220 --> 00:14:01,320
and the structure

283
00:14:01,320 --> 00:14:03,240
um we're looking here at one of these

284
00:14:03,240 --> 00:14:05,940
operations is done like this so it

285
00:14:05,940 --> 00:14:08,579
exactly encodes what you would or or

286
00:14:08,579 --> 00:14:11,339
what the adversary uses to call this key

287
00:14:11,339 --> 00:14:12,720
operation

288
00:14:12,720 --> 00:14:14,040
um so it's a bit string and then it

289
00:14:14,040 --> 00:14:15,779
codes the type of operation that we have

290
00:14:15,779 --> 00:14:19,579
it encodes what key uh this is deriving

291
00:14:19,579 --> 00:14:22,860
and the input or the parent

292
00:14:22,860 --> 00:14:25,680
and also additional arguments

293
00:14:25,680 --> 00:14:27,480
um

294
00:14:27,480 --> 00:14:28,920
and

295
00:14:28,920 --> 00:14:31,380
this is convenient and it also closely

296
00:14:31,380 --> 00:14:33,720
of course models how how this key is

297
00:14:33,720 --> 00:14:35,880
computed so

298
00:14:35,880 --> 00:14:38,519
key computation essentially

299
00:14:38,519 --> 00:14:40,680
only uses information that is also

300
00:14:40,680 --> 00:14:43,620
present in the Handler it just excludes

301
00:14:43,620 --> 00:14:47,339
the um the concrete secret values

302
00:14:47,339 --> 00:14:51,060
and if we remember like here the sandals

303
00:14:51,060 --> 00:14:53,459
that we use inside this is also of the

304
00:14:53,459 --> 00:14:55,800
same structure so this is a recursive

305
00:14:55,800 --> 00:14:59,100
data structure and it exactly tells us

306
00:14:59,100 --> 00:15:03,360
how we arrive at the output key from all

307
00:15:03,360 --> 00:15:05,519
those input key material

308
00:15:05,519 --> 00:15:08,100
without containing any secret

309
00:15:08,100 --> 00:15:10,459
information

310
00:15:10,500 --> 00:15:11,100
um

311
00:15:11,100 --> 00:15:13,920
you know so um

312
00:15:13,920 --> 00:15:16,500
now I I've talked a lot about what we do

313
00:15:16,500 --> 00:15:18,600
in the scale a key schedule

314
00:15:18,600 --> 00:15:20,820
and key schedule security is actually

315
00:15:20,820 --> 00:15:23,399
useful and you want uh two properties

316
00:15:23,399 --> 00:15:24,899
first of all you want that this is

317
00:15:24,899 --> 00:15:26,880
actually provable for any interesting

318
00:15:26,880 --> 00:15:28,019
instances

319
00:15:28,019 --> 00:15:31,199
and I'm telling you about our proof of

320
00:15:31,199 --> 00:15:34,500
TLS 1.3 so we do have key schedule

321
00:15:34,500 --> 00:15:37,920
security for TLS and in follow-up work

322
00:15:37,920 --> 00:15:40,079
there's also key schedule security for

323
00:15:40,079 --> 00:15:42,779
MLS which is a new group messaging

324
00:15:42,779 --> 00:15:46,019
protocol so we do have um

325
00:15:46,019 --> 00:15:47,940
key schedule proofs for interesting

326
00:15:47,940 --> 00:15:50,220
protocol instances

327
00:15:50,220 --> 00:15:52,199
um but you also want of course is that

328
00:15:52,199 --> 00:15:54,180
this actually helps you to prove a key

329
00:15:54,180 --> 00:15:57,180
key exchange security otherwise

330
00:15:57,180 --> 00:15:59,459
holy work is kind of useless and we also

331
00:15:59,459 --> 00:16:02,699
manage this so there we have a proof

332
00:16:02,699 --> 00:16:03,560
that

333
00:16:03,560 --> 00:16:06,360
reduces key exchange security properties

334
00:16:06,360 --> 00:16:08,820
of TLS to the key schedule

335
00:16:08,820 --> 00:16:12,180
and this will be on ePrint soon

336
00:16:12,180 --> 00:16:12,779
um

337
00:16:12,779 --> 00:16:14,579
so um

338
00:16:14,579 --> 00:16:16,800
this is then the picture of how you

339
00:16:16,800 --> 00:16:19,560
prove TLS security and we skip the key

340
00:16:19,560 --> 00:16:21,720
exchange because this is not part of the

341
00:16:21,720 --> 00:16:24,360
threat and look at the

342
00:16:24,360 --> 00:16:25,260
um

343
00:16:25,260 --> 00:16:27,300
core part of key schedule and this is

344
00:16:27,300 --> 00:16:30,420
where this structure

345
00:16:30,420 --> 00:16:32,940
um this detailed structure of the of

346
00:16:32,940 --> 00:16:36,060
this game is really handy and we need to

347
00:16:36,060 --> 00:16:38,880
First Take a short look at

348
00:16:38,880 --> 00:16:39,540
um

349
00:16:39,540 --> 00:16:42,540
expand security so this is one of the

350
00:16:42,540 --> 00:16:44,279
security properties that we use in this

351
00:16:44,279 --> 00:16:46,920
proof and this is in a way it's a PR

352
00:16:46,920 --> 00:16:50,720
security so the adversary sets a key

353
00:16:50,720 --> 00:16:53,699
then calls evaluation on the six pound

354
00:16:53,699 --> 00:16:56,040
function which then stores the output

355
00:16:56,040 --> 00:16:57,839
Keys here and the adversary can access

356
00:16:57,839 --> 00:16:58,680
it

357
00:16:58,680 --> 00:17:01,860
and the evaluation

358
00:17:01,860 --> 00:17:05,579
gets a key runs a function to asset

359
00:17:05,579 --> 00:17:07,740
and um

360
00:17:07,740 --> 00:17:10,140
important of course if we have a key

361
00:17:10,140 --> 00:17:11,699
that is supposed to be secret from the

362
00:17:11,699 --> 00:17:14,699
adversary uh the adversary can instruct

363
00:17:14,699 --> 00:17:16,619
keys to be sampled but of course it

364
00:17:16,619 --> 00:17:19,559
cannot know the value so instead when

365
00:17:19,559 --> 00:17:22,439
the adversary instructs us to produce a

366
00:17:22,439 --> 00:17:24,660
new key we produce a new random bit

367
00:17:24,660 --> 00:17:25,859
string

368
00:17:25,859 --> 00:17:30,360
and here we have two variants

369
00:17:30,360 --> 00:17:31,679
um

370
00:17:31,679 --> 00:17:34,320
also following I think standard modeling

371
00:17:34,320 --> 00:17:37,380
of like prf security so if this is a

372
00:17:37,380 --> 00:17:39,179
zero up here

373
00:17:39,179 --> 00:17:42,720
then we just store whatever the PLC

374
00:17:42,720 --> 00:17:46,200
expand function will produce and provide

375
00:17:46,200 --> 00:17:48,780
the studio adversary while if this is a

376
00:17:48,780 --> 00:17:51,539
one we also replace the output of this

377
00:17:51,539 --> 00:17:54,780
PF by random string or expand function

378
00:17:54,780 --> 00:17:58,380
so standard PR Security in a way just

379
00:17:58,380 --> 00:18:01,799
written a bit differently and

380
00:18:01,799 --> 00:18:04,520
then you have security

381
00:18:04,520 --> 00:18:06,299
requiring that the two are

382
00:18:06,299 --> 00:18:08,460
indistinguishable so the one where you

383
00:18:08,460 --> 00:18:11,520
um adversary that has access to this get

384
00:18:11,520 --> 00:18:14,100
in one case gets the string as computed

385
00:18:14,100 --> 00:18:16,260
by expand and in the other case gets a

386
00:18:16,260 --> 00:18:17,760
random string

387
00:18:17,760 --> 00:18:20,400
bit string and

388
00:18:20,400 --> 00:18:23,179
we can now apply this to this picture

389
00:18:23,179 --> 00:18:26,580
and remember that there's all stacks of

390
00:18:26,580 --> 00:18:28,559
packages here so there's many extracts

391
00:18:28,559 --> 00:18:31,260
and expands and many keys and then we

392
00:18:31,260 --> 00:18:33,299
can move things out a bit

393
00:18:33,299 --> 00:18:35,340
and then we see this is the security

394
00:18:35,340 --> 00:18:37,200
assumption that we are looking at and

395
00:18:37,200 --> 00:18:39,840
it's important we take one that has an

396
00:18:39,840 --> 00:18:42,539
already ideal

397
00:18:42,539 --> 00:18:46,799
so on one key package up there uh we can

398
00:18:46,799 --> 00:18:49,140
take everything else and as in reduction

399
00:18:49,140 --> 00:18:52,620
and then just switch this output key via

400
00:18:52,620 --> 00:18:54,900
security assumption from storing the

401
00:18:54,900 --> 00:18:56,940
concrete value to just restoring a

402
00:18:56,940 --> 00:18:58,380
random value

403
00:18:58,380 --> 00:19:01,500
and then you can iterate this

404
00:19:01,500 --> 00:19:04,919
so now you have another key package that

405
00:19:04,919 --> 00:19:06,840
was just storing real values and it's

406
00:19:06,840 --> 00:19:08,880
not storing running bit strings and I

407
00:19:08,880 --> 00:19:11,820
can apply the security property again

408
00:19:11,820 --> 00:19:14,760
and again on different steps on this key

409
00:19:14,760 --> 00:19:16,940
schedule

410
00:19:17,340 --> 00:19:20,760
um now this was if this was all this is

411
00:19:20,760 --> 00:19:22,440
very simple um but of course there's

412
00:19:22,440 --> 00:19:24,600
more to it and one of the problems is

413
00:19:24,600 --> 00:19:27,299
redundancy that we have in this model

414
00:19:27,299 --> 00:19:30,000
um one of the sources offered unanswer

415
00:19:30,000 --> 00:19:32,940
Stefan so we do have this nice

416
00:19:32,940 --> 00:19:35,520
homomorphic property that um

417
00:19:35,520 --> 00:19:39,000
like the Hellman of x to the alpha y is

418
00:19:39,000 --> 00:19:41,220
the same as the different value computed

419
00:19:41,220 --> 00:19:43,860
from X and Y to the alpha so if you take

420
00:19:43,860 --> 00:19:47,100
them plainly we have different sources

421
00:19:47,100 --> 00:19:50,220
at deriving at the same value and

422
00:19:50,220 --> 00:19:52,080
we want to prove uniqueness in the end

423
00:19:52,080 --> 00:19:54,780
so we kind of need to argue about that

424
00:19:54,780 --> 00:19:57,419
and let's take a look at what happens

425
00:19:57,419 --> 00:19:59,940
here in this model so the adversary asks

426
00:19:59,940 --> 00:20:02,640
for computation of this um

427
00:20:02,640 --> 00:20:05,280
value

428
00:20:05,280 --> 00:20:07,500
um if you have a package will compute

429
00:20:07,500 --> 00:20:08,760
the key and store this under this

430
00:20:08,760 --> 00:20:10,620
identifier and then we confirm things

431
00:20:10,620 --> 00:20:11,820
back

432
00:20:11,820 --> 00:20:15,240
and that's all okay but assume that the

433
00:20:15,240 --> 00:20:17,400
second value was also stored

434
00:20:17,400 --> 00:20:21,000
so there's a collision now and the most

435
00:20:21,000 --> 00:20:22,919
intuitive way that you maybe thinking

436
00:20:22,919 --> 00:20:26,460
about it is just uh at this point the

437
00:20:26,460 --> 00:20:28,200
key package notices there's a collision

438
00:20:28,200 --> 00:20:30,660
and then Returns the value of the the

439
00:20:30,660 --> 00:20:32,220
identifier of the value that it already

440
00:20:32,220 --> 00:20:33,299
knows

441
00:20:33,299 --> 00:20:35,520
and we'll turn this to the adversary but

442
00:20:35,520 --> 00:20:37,080
of course this is easily distinguishable

443
00:20:37,080 --> 00:20:39,600
so we can't really use this argument

444
00:20:39,600 --> 00:20:43,679
and we introduce here in translation

445
00:20:43,679 --> 00:20:45,360
so

446
00:20:45,360 --> 00:20:47,820
the key actually Returns the replaced

447
00:20:47,820 --> 00:20:49,500
value

448
00:20:49,500 --> 00:20:51,960
and then the map returns to the

449
00:20:51,960 --> 00:20:54,360
adversary what it expects and I mean it

450
00:20:54,360 --> 00:20:55,919
can easily verify that this is

451
00:20:55,919 --> 00:20:58,080
computable at the step without access to

452
00:20:58,080 --> 00:21:00,480
the secrets at all

453
00:21:00,480 --> 00:21:01,620
um

454
00:21:01,620 --> 00:21:03,419
now of course we don't want this for the

455
00:21:03,419 --> 00:21:05,039
output keys because we want to argue

456
00:21:05,039 --> 00:21:06,660
here that they are actually unique

457
00:21:06,660 --> 00:21:08,640
without any tricks

458
00:21:08,640 --> 00:21:11,280
and the map here also doesn't go there

459
00:21:11,280 --> 00:21:15,179
and this works via the restrictions we

460
00:21:15,179 --> 00:21:17,820
receive from the protocol and if you

461
00:21:17,820 --> 00:21:21,059
look at the key schedule before this

462
00:21:21,059 --> 00:21:23,340
arrows go down

463
00:21:23,340 --> 00:21:25,020
um the key exchange protocol will

464
00:21:25,020 --> 00:21:26,880
include a transcript in this key

465
00:21:26,880 --> 00:21:29,100
derivation operation

466
00:21:29,100 --> 00:21:30,539
so

467
00:21:30,539 --> 00:21:33,200
if I derive here a key

468
00:21:33,200 --> 00:21:35,600
I will have

469
00:21:35,600 --> 00:21:38,159
included a transcript and contains the

470
00:21:38,159 --> 00:21:39,840
shares in

471
00:21:39,840 --> 00:21:42,840
in this derivation of operation which

472
00:21:42,840 --> 00:21:44,700
creates

473
00:21:44,700 --> 00:21:46,640
um distinct values

474
00:21:46,640 --> 00:21:50,340
and therefore we don't need to have this

475
00:21:50,340 --> 00:21:53,220
translation on output keys and we arrive

476
00:21:53,220 --> 00:21:55,100
at um

477
00:21:55,100 --> 00:21:57,539
uniqueness of course this needs to be

478
00:21:57,539 --> 00:22:00,299
formally argued and as in the paper

479
00:22:00,299 --> 00:22:03,480
and um

480
00:22:03,480 --> 00:22:05,760
then you can just remove everything that

481
00:22:05,760 --> 00:22:07,740
does the map and left to it into a

482
00:22:07,740 --> 00:22:09,179
reduction and just care about the

483
00:22:09,179 --> 00:22:12,840
remaining schedule that has this neat

484
00:22:12,840 --> 00:22:16,740
unique feature kind of automatically

485
00:22:16,740 --> 00:22:17,700
um

486
00:22:17,700 --> 00:22:21,539
now in our last step uh this was what I

487
00:22:21,539 --> 00:22:23,700
said was like security assumption we

488
00:22:23,700 --> 00:22:27,480
used for the score proof and

489
00:22:27,480 --> 00:22:29,280
I mean you can describe security

490
00:22:29,280 --> 00:22:31,020
properties like this but it's kind of

491
00:22:31,020 --> 00:22:33,059
inconvenient we didn't even talk about

492
00:22:33,059 --> 00:22:35,940
what happens down down here

493
00:22:35,940 --> 00:22:38,340
so this is a security definition that

494
00:22:38,340 --> 00:22:40,679
has a lot of like unnecessary parts and

495
00:22:40,679 --> 00:22:43,500
what you would much rather have as a

496
00:22:43,500 --> 00:22:46,200
something like this so a security

497
00:22:46,200 --> 00:22:48,539
definition where on the one hand in a

498
00:22:48,539 --> 00:22:51,120
real case you just have an oracle a

499
00:22:51,120 --> 00:22:53,520
samples random key adversary submits

500
00:22:53,520 --> 00:22:56,460
inputs and gets evaluations out and in

501
00:22:56,460 --> 00:22:59,100
the ideal case the adversary always gets

502
00:22:59,100 --> 00:23:00,659
just random bit strings

503
00:23:00,659 --> 00:23:03,500
and

504
00:23:04,080 --> 00:23:06,840
in the full version we have a proof that

505
00:23:06,840 --> 00:23:09,360
actually we can reduce this security

506
00:23:09,360 --> 00:23:11,820
definition to uh the the more standard

507
00:23:11,820 --> 00:23:13,559
formulation

508
00:23:13,559 --> 00:23:16,020
um of course there's some more

509
00:23:16,020 --> 00:23:18,539
complexity as you can see first of all

510
00:23:18,539 --> 00:23:21,840
TLS of course allows algorithmic agility

511
00:23:21,840 --> 00:23:24,360
so you can have different Keys produced

512
00:23:24,360 --> 00:23:27,780
in a different algorithms and this one

513
00:23:27,780 --> 00:23:30,299
is just like one concrete algorithm so

514
00:23:30,299 --> 00:23:31,500
we need to

515
00:23:31,500 --> 00:23:34,740
uh argue like for for all um

516
00:23:34,740 --> 00:23:37,440
for all choices of hash functions and

517
00:23:37,440 --> 00:23:40,140
also we allow multiple

518
00:23:40,140 --> 00:23:42,900
uh Source Keys um whereas here we have

519
00:23:42,900 --> 00:23:45,419
exactly one key so there are some more

520
00:23:45,419 --> 00:23:47,220
factors if you look at concrete security

521
00:23:47,220 --> 00:23:51,480
that's hidden in in this um formulation

522
00:23:51,480 --> 00:23:52,980
and

523
00:23:52,980 --> 00:23:54,960
um

524
00:23:54,960 --> 00:23:58,679
I'm through with it now yes yes so so

525
00:23:58,679 --> 00:24:01,220
that's it

526
00:24:01,650 --> 00:24:04,799
[Applause]

527
00:24:07,020 --> 00:24:10,639
thanks a lot other questions

528
00:24:14,179 --> 00:24:17,400
hi I'm Matilda thanks for your talk

529
00:24:17,400 --> 00:24:18,600
um I have a question actually about

530
00:24:18,600 --> 00:24:19,919
something you said in your video

531
00:24:19,919 --> 00:24:22,140
abstract there you mentioned that a key

532
00:24:22,140 --> 00:24:24,299
takeaway from this analysis

533
00:24:24,299 --> 00:24:26,280
um was that it would have been useful to

534
00:24:26,280 --> 00:24:28,860
extract from the beefy Helman

535
00:24:28,860 --> 00:24:30,780
um part before mixing

536
00:24:30,780 --> 00:24:32,400
because you could have relied on less

537
00:24:32,400 --> 00:24:34,440
strong security assumptions and I was

538
00:24:34,440 --> 00:24:36,480
wondering in particular if what you

539
00:24:36,480 --> 00:24:38,000
meant by this was that you could have

540
00:24:38,000 --> 00:24:39,900
felt like you wouldn't have needed the

541
00:24:39,900 --> 00:24:42,780
Oracle the filament assumption and also

542
00:24:42,780 --> 00:24:44,640
my second question is is do you see any

543
00:24:44,640 --> 00:24:46,559
reason to keep it as it currently is or

544
00:24:46,559 --> 00:24:48,360
should we just move to always extracting

545
00:24:48,360 --> 00:24:50,340
before mixing

546
00:24:50,340 --> 00:24:51,659
um

547
00:24:51,659 --> 00:24:55,740
I think why it's this way it's just like

548
00:24:55,740 --> 00:24:59,039
it's saves another like

549
00:24:59,039 --> 00:25:01,620
key derivation operation and people are

550
00:25:01,620 --> 00:25:03,659
kind of sensitive about how many of

551
00:25:03,659 --> 00:25:04,620
these

552
00:25:04,620 --> 00:25:06,720
you include

553
00:25:06,720 --> 00:25:10,140
also also also um it doesn't show in in

554
00:25:10,140 --> 00:25:13,020
our slides so nicely but it does like

555
00:25:13,020 --> 00:25:14,940
the key schedule does have a regular

556
00:25:14,940 --> 00:25:17,340
structure that has like always one

557
00:25:17,340 --> 00:25:19,559
extract to expands

558
00:25:19,559 --> 00:25:22,020
and if you mix in

559
00:25:22,020 --> 00:25:23,039
yeah

560
00:25:23,039 --> 00:25:26,100
so yeah I think non-cryptographic

561
00:25:26,100 --> 00:25:28,440
reasons to keep it in the way it is

562
00:25:28,440 --> 00:25:31,760
and um

563
00:25:31,980 --> 00:25:36,600
where security properties uh

564
00:25:37,679 --> 00:25:41,039
you rely on Oracle we rely on not just

565
00:25:41,039 --> 00:25:43,320
like on Oracle for Hammond but we also

566
00:25:43,320 --> 00:25:44,760
have we have the Salted Oracle

567
00:25:44,760 --> 00:25:48,299
development uh I don't know if you if

568
00:25:48,299 --> 00:25:50,159
you if you've seen that part so the

569
00:25:50,159 --> 00:25:52,380
adversary not only like has like Oracle

570
00:25:52,380 --> 00:25:53,820
access to the stuff you haven't but it

571
00:25:53,820 --> 00:25:55,980
also can choose the salt under which

572
00:25:55,980 --> 00:25:57,179
it's extracted

573
00:25:57,179 --> 00:26:00,240
and that is kind of

574
00:26:00,240 --> 00:26:02,340
yeah you you would you would like to not

575
00:26:02,340 --> 00:26:04,559
have that at least from a cryptographic

576
00:26:04,559 --> 00:26:07,080
perspective and if you were to extract

577
00:26:07,080 --> 00:26:08,940
first could you get around that entirely

578
00:26:08,940 --> 00:26:13,860
then uh around assaulted for sure

579
00:26:13,860 --> 00:26:16,039
um

580
00:26:17,279 --> 00:26:19,320
I'm not sure about it yeah thank you

581
00:26:19,320 --> 00:26:21,620
very much

582
00:26:22,080 --> 00:26:25,039
any other questions

583
00:26:25,440 --> 00:26:28,620
I've got one question your paper has I

584
00:26:28,620 --> 00:26:32,940
just checked more than 80 Pages appendix

585
00:26:32,940 --> 00:26:34,559
um I mean this is a great careful work

586
00:26:34,559 --> 00:26:36,840
but what guarantees you that your proofs

587
00:26:36,840 --> 00:26:37,740
are

588
00:26:37,740 --> 00:26:40,799
correct I'm 100 sure none of the reviews

589
00:26:40,799 --> 00:26:45,120
read the full paper uh I'm betting also

590
00:26:45,120 --> 00:26:47,220
we didn't submit what what is now the

591
00:26:47,220 --> 00:26:50,100
full version and I think there's also

592
00:26:50,100 --> 00:26:53,520
like I have or we have uh

593
00:26:53,520 --> 00:26:55,919
extended version and a full version of

594
00:26:55,919 --> 00:26:58,620
this paper online uh

595
00:26:58,620 --> 00:27:00,900
it's quite annoying in a way

596
00:27:00,900 --> 00:27:04,200
and yeah 80 pages of appendix are too

597
00:27:04,200 --> 00:27:06,419
much so to speak

598
00:27:06,419 --> 00:27:08,539
um

599
00:27:09,240 --> 00:27:11,760
I mean one way around this at least

600
00:27:11,760 --> 00:27:13,860
Outsourcing part of verification of

601
00:27:13,860 --> 00:27:15,960
verification of this proves to like

602
00:27:15,960 --> 00:27:18,120
automated proof tools and that would be

603
00:27:18,120 --> 00:27:19,140
super nice

604
00:27:19,140 --> 00:27:22,020
uh we haven't done that

605
00:27:22,020 --> 00:27:23,520
at the moment

606
00:27:23,520 --> 00:27:26,039
uh I mean but

607
00:27:26,039 --> 00:27:30,000
something that that we have in mind

608
00:27:30,000 --> 00:27:33,960
okay and the other one is uh I mean

609
00:27:33,960 --> 00:27:36,059
like the last part I presented you can

610
00:27:36,059 --> 00:27:39,179
just look at how this is uh the security

611
00:27:39,179 --> 00:27:41,039
properties I described and convince

612
00:27:41,039 --> 00:27:43,440
yourself that those are also

613
00:27:43,440 --> 00:27:45,600
uh reasonable descriptions and then you

614
00:27:45,600 --> 00:27:47,460
save I don't know the 30 pages of the

615
00:27:47,460 --> 00:27:48,779
appendix already

616
00:27:48,779 --> 00:27:51,320
so

617
00:27:51,659 --> 00:27:54,659
yeah thanks a lot repetitive

618
00:27:54,659 --> 00:27:58,620
and it needs to be done I was hinting at

619
00:27:58,620 --> 00:28:00,779
the if you're planning to formally

620
00:28:00,779 --> 00:28:03,179
verify this because I think we consider

621
00:28:03,179 --> 00:28:06,600
the human checkable yeah actually thanks

622
00:28:06,600 --> 00:28:09,120
a lot I think then uh

623
00:28:09,120 --> 00:28:12,320
thank the speaker again

624
00:28:17,520 --> 00:28:20,940
then our next talk is online uh it's

625
00:28:20,940 --> 00:28:23,880
YOLO yoso fast and simple encryption and

626
00:28:23,880 --> 00:28:27,559
secret sharing in the user model

627
00:28:33,559 --> 00:28:37,760
and Ignatius giving the talk

628
00:28:39,320 --> 00:28:42,840
uh yes I think they can improve the

629
00:28:42,840 --> 00:28:45,120
audio a bit

630
00:28:45,120 --> 00:28:48,559
try a different microphone

631
00:28:50,100 --> 00:28:53,100
you can try with the laptop one but ah

632
00:28:53,100 --> 00:28:55,559
now not much better

633
00:28:55,559 --> 00:29:00,059
okay I didn't do anything so good

634
00:29:00,059 --> 00:29:03,179
um uh yeah so

635
00:29:03,179 --> 00:29:05,100
um yeah so thanks for the introduction

636
00:29:05,100 --> 00:29:08,159
and I'm sorry that I cannot be there

637
00:29:08,159 --> 00:29:10,440
um but I hope that you are having a

638
00:29:10,440 --> 00:29:13,799
great uh conference and uh yeah this is

639
00:29:13,799 --> 00:29:15,840
the this is the paper geology also fast

640
00:29:15,840 --> 00:29:18,360
and simple encryption and secret selling

641
00:29:18,360 --> 00:29:20,760
in the yoso model

642
00:29:20,760 --> 00:29:23,520
um and as the title suggests this is

643
00:29:23,520 --> 00:29:26,279
about the yozo model

644
00:29:26,279 --> 00:29:30,299
um so this is a secure computation uh

645
00:29:30,299 --> 00:29:33,419
security computation model

646
00:29:33,419 --> 00:29:35,460
um that is a little bit of an

647
00:29:35,460 --> 00:29:38,100
alternative to the traditional one so in

648
00:29:38,100 --> 00:29:40,320
the traditional multi-party computation

649
00:29:40,320 --> 00:29:44,039
model you have a fixed set of parties

650
00:29:44,039 --> 00:29:48,059
the uh the the protocol proceeds by

651
00:29:48,059 --> 00:29:50,820
rounds where at every round you have

652
00:29:50,820 --> 00:29:53,940
that well some parties can send messages

653
00:29:53,940 --> 00:29:55,919
to others and so on

654
00:29:55,919 --> 00:29:58,140
in the Uso model

655
00:29:58,140 --> 00:30:01,380
uh you have uh instead a very large pool

656
00:30:01,380 --> 00:30:05,159
of parties and then at every round or

657
00:30:05,159 --> 00:30:07,860
each round is being executed by a small

658
00:30:07,860 --> 00:30:10,140
subset of these parties by some

659
00:30:10,140 --> 00:30:11,279
committee

660
00:30:11,279 --> 00:30:14,100
and the the point here is that every

661
00:30:14,100 --> 00:30:17,820
party can be at most in one committee

662
00:30:17,820 --> 00:30:20,340
and most importantly the identity of the

663
00:30:20,340 --> 00:30:23,039
party is not known or the identity of

664
00:30:23,039 --> 00:30:25,380
each parties is not known until they

665
00:30:25,380 --> 00:30:30,179
speak uh so um essentially that that the

666
00:30:30,179 --> 00:30:32,760
motivation for this model is that this

667
00:30:32,760 --> 00:30:36,720
makes corruption by adversaries uh hard

668
00:30:36,720 --> 00:30:39,480
so um because well basically the

669
00:30:39,480 --> 00:30:42,779
adversary said don't know

670
00:30:42,779 --> 00:30:45,240
which parties are going to speak until

671
00:30:45,240 --> 00:30:47,640
they do and then when when they do then

672
00:30:47,640 --> 00:30:49,919
it's too late to corrupt them because

673
00:30:49,919 --> 00:30:52,260
well they have already spoken and they

674
00:30:52,260 --> 00:30:53,760
are not going to participate anymore in

675
00:30:53,760 --> 00:30:55,679
the protocol so that's the the

676
00:30:55,679 --> 00:30:58,200
motivation of this of this model

677
00:30:58,200 --> 00:31:01,020
and um but of course

678
00:31:01,020 --> 00:31:04,679
in this model we need to figure out how

679
00:31:04,679 --> 00:31:07,559
to uh to implement the communication

680
00:31:07,559 --> 00:31:10,159
between parties because in traditional

681
00:31:10,159 --> 00:31:13,500
MPC well you have that well parties are

682
00:31:13,500 --> 00:31:16,620
known and so you can essentially assume

683
00:31:16,620 --> 00:31:18,720
that there are a secure channels between

684
00:31:18,720 --> 00:31:22,320
each pair of parties because

685
00:31:22,320 --> 00:31:24,659
um you can instantiate that using public

686
00:31:24,659 --> 00:31:27,179
key encryption let everyone will have a

687
00:31:27,179 --> 00:31:29,399
public key and then as I said the

688
00:31:29,399 --> 00:31:31,740
identities of the parties are known so

689
00:31:31,740 --> 00:31:34,380
you know which public keys to use in

690
00:31:34,380 --> 00:31:37,320
order to encrypt towards uh a given

691
00:31:37,320 --> 00:31:42,179
party but in the uh in the Uso model uh

692
00:31:42,179 --> 00:31:44,220
the situation is a little bit different

693
00:31:44,220 --> 00:31:46,679
because here uh you have that every

694
00:31:46,679 --> 00:31:48,659
round is

695
00:31:48,659 --> 00:31:51,600
is run by some Anonymous committee so

696
00:31:51,600 --> 00:31:53,240
then the question is how do you encrypt

697
00:31:53,240 --> 00:31:56,220
information towards a party that you

698
00:31:56,220 --> 00:31:59,100
actually don't know and more generally

699
00:31:59,100 --> 00:32:01,440
also how do you for example secret share

700
00:32:01,440 --> 00:32:05,159
information among some committee uh that

701
00:32:05,159 --> 00:32:07,799
you still don't know

702
00:32:07,799 --> 00:32:10,320
um so there have been like several uh

703
00:32:10,320 --> 00:32:14,340
Works dealing with this uh type of

704
00:32:14,340 --> 00:32:18,179
problem and uh so the first one was this

705
00:32:18,179 --> 00:32:21,059
kind of public blockchain keep a secret

706
00:32:21,059 --> 00:32:23,580
library at all and there they were

707
00:32:23,580 --> 00:32:27,000
consent about how to uh keep a secret uh

708
00:32:27,000 --> 00:32:30,539
shared during a long time in a

709
00:32:30,539 --> 00:32:35,520
blockchain uh so by resetting it to uh

710
00:32:35,520 --> 00:32:40,260
different uh Anonymous comedies and the

711
00:32:40,260 --> 00:32:41,940
the anonymous the the sort of the

712
00:32:41,940 --> 00:32:44,340
appointment of these committees uh is a

713
00:32:44,340 --> 00:32:47,220
process that requires a

714
00:32:47,220 --> 00:32:50,299
some some bound on the corruption

715
00:32:50,299 --> 00:32:53,520
tolerance so basically you can at most

716
00:32:53,520 --> 00:32:57,000
have around 29 of their parties

717
00:32:57,000 --> 00:32:59,159
corrupted

718
00:32:59,159 --> 00:33:01,740
and then this was fixed in this paper

719
00:33:01,740 --> 00:33:05,399
called random index private information

720
00:33:05,399 --> 00:33:07,620
retrieval where

721
00:33:07,620 --> 00:33:10,380
um basically they could achieve any

722
00:33:10,380 --> 00:33:12,140
dishonest

723
00:33:12,140 --> 00:33:16,080
sorry any honest majority

724
00:33:16,080 --> 00:33:18,840
um by a technique that basically allows

725
00:33:18,840 --> 00:33:21,320
parties to

726
00:33:21,320 --> 00:33:24,360
sample Anonymous public keys from from

727
00:33:24,360 --> 00:33:26,779
some list and then encrypt towards that

728
00:33:26,779 --> 00:33:30,000
those keys uh now that the computational

729
00:33:30,000 --> 00:33:32,880
complexity of this is uh is a little bit

730
00:33:32,880 --> 00:33:35,519
uh High

731
00:33:35,519 --> 00:33:37,440
um so

732
00:33:37,440 --> 00:33:41,039
um later in this uh in this conference

733
00:33:41,039 --> 00:33:44,100
there will be this presentation about

734
00:33:44,100 --> 00:33:45,840
this paper encryption to the to the

735
00:33:45,840 --> 00:33:46,679
Future

736
00:33:46,679 --> 00:33:48,539
this is on Friday

737
00:33:48,539 --> 00:33:52,200
and this approach

738
00:33:52,200 --> 00:33:54,779
um consists in the following so here we

739
00:33:54,779 --> 00:33:57,240
have the that time is divided into slots

740
00:33:57,240 --> 00:34:00,620
that they are kept by uh by a blockchain

741
00:34:00,620 --> 00:34:04,679
and basically when you want to encrypt

742
00:34:04,679 --> 00:34:07,320
information towards a certain party what

743
00:34:07,320 --> 00:34:08,639
you are doing is actually encrypting

744
00:34:08,639 --> 00:34:10,859
towards a certain role in a certain slot

745
00:34:10,859 --> 00:34:15,179
of the uh of this time uh frame so so

746
00:34:15,179 --> 00:34:17,940
basically you could be like encrypting

747
00:34:17,940 --> 00:34:20,339
towards the second row the roll number

748
00:34:20,339 --> 00:34:24,060
two in in slot number six for example

749
00:34:24,060 --> 00:34:24,839
um

750
00:34:24,839 --> 00:34:27,480
and uh and then there is a lottery that

751
00:34:27,480 --> 00:34:29,460
checks if the owner of a certain secret

752
00:34:29,460 --> 00:34:33,000
key uh will be assigned to that role and

753
00:34:33,000 --> 00:34:35,520
if that is the case then then this party

754
00:34:35,520 --> 00:34:38,699
will be able to decrypt

755
00:34:38,699 --> 00:34:40,020
um so

756
00:34:40,020 --> 00:34:42,899
so this is uh encryption to the Future

757
00:34:42,899 --> 00:34:46,199
you will see more about that on Friday

758
00:34:46,199 --> 00:34:49,980
um but uh also in in that paper that is

759
00:34:49,980 --> 00:34:53,219
like a weaker version called encryption

760
00:34:53,219 --> 00:34:55,080
to the current winner

761
00:34:55,080 --> 00:34:57,180
and encryption to the current winner

762
00:34:57,180 --> 00:35:00,240
means that whenever you at the time of

763
00:35:00,240 --> 00:35:02,760
encryption uh the role is already

764
00:35:02,760 --> 00:35:05,040
assigned so basically the the party that

765
00:35:05,040 --> 00:35:08,280
is going to to be assigned this role is

766
00:35:08,280 --> 00:35:11,520
already like uh completely determined

767
00:35:11,520 --> 00:35:13,680
and um

768
00:35:13,680 --> 00:35:16,560
this is actually simple simpler case

769
00:35:16,560 --> 00:35:19,800
because while in the case of encryption

770
00:35:19,800 --> 00:35:22,260
to the Future the the communication that

771
00:35:22,260 --> 00:35:24,720
you need in in order to encrypt or to

772
00:35:24,720 --> 00:35:26,280
send an encryption of a message is

773
00:35:26,280 --> 00:35:29,339
linear in the number of total uh parties

774
00:35:29,339 --> 00:35:31,859
in the in the system uh here we will

775
00:35:31,859 --> 00:35:33,540
show that encryption to the current

776
00:35:33,540 --> 00:35:35,220
winner can be achieved with

777
00:35:35,220 --> 00:35:38,579
communication which is uh independent

778
00:35:38,579 --> 00:35:39,900
from the

779
00:35:39,900 --> 00:35:41,579
autonomous parties or at least the

780
00:35:41,579 --> 00:35:43,980
online communication

781
00:35:43,980 --> 00:35:44,940
um

782
00:35:44,940 --> 00:35:47,579
then there is a way of transforming this

783
00:35:47,579 --> 00:35:49,440
encryption to the current winner into

784
00:35:49,440 --> 00:35:51,180
full-blown encryption to the Future

785
00:35:51,180 --> 00:35:53,760
using identity based encryption you can

786
00:35:53,760 --> 00:35:56,520
uh refer to the refer you to the other

787
00:35:56,520 --> 00:36:00,720
paper and to the other offers which who

788
00:36:00,720 --> 00:36:03,359
know more about this than me

789
00:36:03,359 --> 00:36:06,599
um but uh so in this paper what we what

790
00:36:06,599 --> 00:36:09,119
we do is uh well several things so first

791
00:36:09,119 --> 00:36:11,220
of all we

792
00:36:11,220 --> 00:36:14,760
uh suggest a solution for for encryption

793
00:36:14,760 --> 00:36:17,579
to the current winner as I mentioned

794
00:36:17,579 --> 00:36:22,500
that uses uses shuffling and well where

795
00:36:22,500 --> 00:36:24,599
the ciphertext length is independent

796
00:36:24,599 --> 00:36:27,240
from the number of parties as I said

797
00:36:27,240 --> 00:36:29,700
um and then we also look into how to

798
00:36:29,700 --> 00:36:31,460
secret share information

799
00:36:31,460 --> 00:36:34,260
and in a way that is compatible with

800
00:36:34,260 --> 00:36:35,820
this encryption to the current winner

801
00:36:35,820 --> 00:36:38,760
and in particular uh we we come up with

802
00:36:38,760 --> 00:36:41,099
new uh publicly verifiable secret

803
00:36:41,099 --> 00:36:44,520
sharing schemes and

804
00:36:44,520 --> 00:36:47,960
uh yeah in particular one of uh of the

805
00:36:47,960 --> 00:36:50,579
proposals that we have is

806
00:36:50,579 --> 00:36:53,579
um the most efficient that we know uh in

807
00:36:53,579 --> 00:36:57,780
in terms of communication uh to date

808
00:36:57,780 --> 00:36:59,579
um it has a proof of setting correctness

809
00:36:59,579 --> 00:37:02,760
the length is independent from the

810
00:37:02,760 --> 00:37:04,079
number of parties

811
00:37:04,079 --> 00:37:07,560
and so this is interesting uh for uh

812
00:37:07,560 --> 00:37:11,400
also independent applications too as I

813
00:37:11,400 --> 00:37:13,680
will mentioned uh and then finally we

814
00:37:13,680 --> 00:37:16,020
also have like uh well generalizations

815
00:37:16,020 --> 00:37:19,920
of this PVSS in order to also reshare

816
00:37:19,920 --> 00:37:23,099
information not only share

817
00:37:23,099 --> 00:37:26,880
I will explain a little bit more of that

818
00:37:26,880 --> 00:37:27,599
um

819
00:37:27,599 --> 00:37:29,640
so first of all let me talk a little bit

820
00:37:29,640 --> 00:37:32,280
about the the encryption to the current

821
00:37:32,280 --> 00:37:36,480
winner through uh through shuffling

822
00:37:36,480 --> 00:37:39,060
um essentially the the approach that we

823
00:37:39,060 --> 00:37:42,359
propose is very simple so uh it's part

824
00:37:42,359 --> 00:37:45,740
in the system will select a keeper

825
00:37:45,740 --> 00:37:49,140
anonymously and then they will input the

826
00:37:49,140 --> 00:37:51,780
the public Keys into a mixed net and the

827
00:37:51,780 --> 00:37:54,500
mixnet will uh essentially like Shuffle

828
00:37:54,500 --> 00:37:57,960
this these keys and the resulting keys

829
00:37:57,960 --> 00:38:00,780
of the a resulting list of the public

830
00:38:00,780 --> 00:38:02,460
keys will be published in the blockchain

831
00:38:02,460 --> 00:38:04,859
and this all can be done in a

832
00:38:04,859 --> 00:38:07,680
in a preprocessing step and then once

833
00:38:07,680 --> 00:38:09,780
you have this list then an encryption to

834
00:38:09,780 --> 00:38:11,540
the current winner is is essentially

835
00:38:11,540 --> 00:38:15,420
trivial uh because uh well a lottery

836
00:38:15,420 --> 00:38:18,960
will essentially select uh which public

837
00:38:18,960 --> 00:38:20,040
key

838
00:38:20,040 --> 00:38:20,900
um

839
00:38:20,900 --> 00:38:24,119
corresponds to I mean we will select a

840
00:38:24,119 --> 00:38:26,099
random key in this list that has not

841
00:38:26,099 --> 00:38:31,260
been used yet and then uh

842
00:38:31,260 --> 00:38:32,880
the party that needs to encrypt the

843
00:38:32,880 --> 00:38:34,260
information will will just use that

844
00:38:34,260 --> 00:38:36,119
public key to encrypt

845
00:38:36,119 --> 00:38:38,400
so this is the solution for encryption

846
00:38:38,400 --> 00:38:39,660
to the current wind

847
00:38:39,660 --> 00:38:41,880
we have actually a more elaborated

848
00:38:41,880 --> 00:38:44,940
strategy that even allows to preserve

849
00:38:44,940 --> 00:38:48,359
some anonymity after uh

850
00:38:48,359 --> 00:38:50,339
um after speaking so basically what I

851
00:38:50,339 --> 00:38:53,520
mean by this is that you can encrypt or

852
00:38:53,520 --> 00:38:56,700
share information uh to a committee

853
00:38:56,700 --> 00:38:58,320
and then

854
00:38:58,320 --> 00:38:58,980
um

855
00:38:58,980 --> 00:39:01,980
have the property that that parties can

856
00:39:01,980 --> 00:39:02,960
actually

857
00:39:02,960 --> 00:39:06,119
uh later on when they speak they can

858
00:39:06,119 --> 00:39:08,099
reveal that that they belong to that

859
00:39:08,099 --> 00:39:09,839
committee but not

860
00:39:09,839 --> 00:39:12,060
without I mean without revealing which

861
00:39:12,060 --> 00:39:14,579
of the parties of the committee and they

862
00:39:14,579 --> 00:39:17,220
they are actually uh Associated to so

863
00:39:17,220 --> 00:39:19,140
basically which of the roles of in in

864
00:39:19,140 --> 00:39:20,760
that committee they were associated to

865
00:39:20,760 --> 00:39:22,320
so this

866
00:39:22,320 --> 00:39:24,000
could be interesting it doesn't really

867
00:39:24,000 --> 00:39:26,160
completely fit in the in this Jose model

868
00:39:26,160 --> 00:39:28,200
but but we think it could be an

869
00:39:28,200 --> 00:39:30,720
interesting uh I think maybe for some

870
00:39:30,720 --> 00:39:33,300
other applications

871
00:39:33,300 --> 00:39:34,200
um

872
00:39:34,200 --> 00:39:36,839
now this this

873
00:39:36,839 --> 00:39:39,720
um we think this is a good approach for

874
00:39:39,720 --> 00:39:41,880
encryption to the current winner but

875
00:39:41,880 --> 00:39:44,820
when it comes to a secret sharing uh

876
00:39:44,820 --> 00:39:48,720
this um we need to also guarantee other

877
00:39:48,720 --> 00:39:51,180
properties like when we are sequencing

878
00:39:51,180 --> 00:39:55,079
some value into a committee then we also

879
00:39:55,079 --> 00:39:58,980
need to prove uh that what we are doing

880
00:39:58,980 --> 00:40:01,680
is actually a consistent sharing of

881
00:40:01,680 --> 00:40:03,480
information so basically for example if

882
00:40:03,480 --> 00:40:05,700
we are using Shamir we would like to

883
00:40:05,700 --> 00:40:07,200
prove that the shares that we are

884
00:40:07,200 --> 00:40:09,720
sending are actually evaluations of the

885
00:40:09,720 --> 00:40:13,680
polynomial of of the right degree

886
00:40:13,680 --> 00:40:17,040
and so for that we we have the the

887
00:40:17,040 --> 00:40:19,079
notion of publicly verifiable secret

888
00:40:19,079 --> 00:40:21,240
sharing which was already introduced in

889
00:40:21,240 --> 00:40:23,460
the 90s and

890
00:40:23,460 --> 00:40:26,280
um and this is simply sequencing scheme

891
00:40:26,280 --> 00:40:28,940
that has a publicly verifiable or proof

892
00:40:28,940 --> 00:40:31,260
uh that's the sharing that we are doing

893
00:40:31,260 --> 00:40:33,720
is correct

894
00:40:33,720 --> 00:40:36,780
um so basically what is going to happen

895
00:40:36,780 --> 00:40:40,079
is that we are going to send or we are

896
00:40:40,079 --> 00:40:42,540
going to publish shares in an encrypted

897
00:40:42,540 --> 00:40:44,640
form and we are going to prove that the

898
00:40:44,640 --> 00:40:47,520
uh underlying plain texts are shares

899
00:40:47,520 --> 00:40:51,000
that are correct sharing of some Secret

900
00:40:51,000 --> 00:40:54,060
uh now this recently has had interesting

901
00:40:54,060 --> 00:40:57,859
applications uh so most notably for the

902
00:40:57,859 --> 00:41:02,359
construction of distributed randomness

903
00:41:02,780 --> 00:41:07,560
generators or Randomness beacons

904
00:41:07,560 --> 00:41:08,280
um

905
00:41:08,280 --> 00:41:11,700
but also it's a it's it's an important

906
00:41:11,700 --> 00:41:14,220
property if we want to keep uh secrets

907
00:41:14,220 --> 00:41:16,380
in a blockchain uh for a long time

908
00:41:16,380 --> 00:41:18,980
because if we are going to keep a

909
00:41:18,980 --> 00:41:21,240
Secrets being free shared in in

910
00:41:21,240 --> 00:41:24,480
successive committees uh but we want to

911
00:41:24,480 --> 00:41:28,500
make sure that this is doing that

912
00:41:28,500 --> 00:41:30,900
actually there is some Secrets being

913
00:41:30,900 --> 00:41:33,960
hidden by this by these shares we want

914
00:41:33,960 --> 00:41:35,820
to prove the correctness of

915
00:41:35,820 --> 00:41:40,020
the shedding and then the resettings

916
00:41:40,020 --> 00:41:41,000
um

917
00:41:41,000 --> 00:41:44,579
yeah so in this paper we can we present

918
00:41:44,579 --> 00:41:46,980
two constructions of uh publicly

919
00:41:46,980 --> 00:41:49,560
verifiable secretary and one is a

920
00:41:49,560 --> 00:41:52,619
genetic construction that

921
00:41:52,619 --> 00:41:56,280
um well is constructed from any

922
00:41:56,280 --> 00:41:59,339
um homomorphic encryption scheme

923
00:41:59,339 --> 00:42:01,980
well linearly homographic encryption

924
00:42:01,980 --> 00:42:05,579
scheme of the field and then uh we we

925
00:42:05,579 --> 00:42:09,960
propose this more efficient

926
00:42:09,980 --> 00:42:15,500
bvs says that is based on the well ddh

927
00:42:16,140 --> 00:42:20,099
um the first uh the first one is

928
00:42:20,099 --> 00:42:22,680
based on this notion of uh well linearly

929
00:42:22,680 --> 00:42:25,079
homomorphic encryption

930
00:42:25,079 --> 00:42:27,119
um essentially what what we want here is

931
00:42:27,119 --> 00:42:30,420
that an encryption scheme where both

932
00:42:30,420 --> 00:42:32,339
plain text Randomness and ciphertext

933
00:42:32,339 --> 00:42:35,640
spaces are a linear spaces over some

934
00:42:35,640 --> 00:42:36,420
field

935
00:42:36,420 --> 00:42:38,339
so for example there could be just

936
00:42:38,339 --> 00:42:42,359
groups of order of order B work visa

937
00:42:42,359 --> 00:42:43,020
brand

938
00:42:43,020 --> 00:42:45,540
and that the encryption is homomorphic

939
00:42:45,540 --> 00:42:49,560
in both the message and the randomness

940
00:42:49,560 --> 00:42:53,480
this basically allows for a simple

941
00:42:53,480 --> 00:42:56,820
proofs of knowledge of the plain text

942
00:42:56,820 --> 00:43:00,599
and another thing that we want from this

943
00:43:00,599 --> 00:43:03,660
encryption scheme is that it has a proof

944
00:43:03,660 --> 00:43:08,040
of correct decryption so there are we

945
00:43:08,040 --> 00:43:10,200
see two ways of of having such a proof

946
00:43:10,200 --> 00:43:14,700
one is that if if one can if the party

947
00:43:14,700 --> 00:43:16,440
that is decrypting can also recover

948
00:43:16,440 --> 00:43:20,240
Randomness that can give you ciphertext

949
00:43:20,240 --> 00:43:23,640
uh um then then you can use the

950
00:43:23,640 --> 00:43:25,200
homomorphic property of the encryption

951
00:43:25,200 --> 00:43:27,839
in order to prove the correct decryption

952
00:43:27,839 --> 00:43:30,780
uh but also uh you don't need that if

953
00:43:30,780 --> 00:43:34,200
you also have a decryption a decryption

954
00:43:34,200 --> 00:43:36,540
function which is linear in the secret

955
00:43:36,540 --> 00:43:38,700
key in that case you can also like

956
00:43:38,700 --> 00:43:40,560
construct proofs of correct decryption

957
00:43:40,560 --> 00:43:41,760
without needing to recover the

958
00:43:41,760 --> 00:43:44,579
randomness so if you have this uh any of

959
00:43:44,579 --> 00:43:47,099
these properties

960
00:43:47,099 --> 00:43:49,079
um in particular the second one is is

961
00:43:49,079 --> 00:43:52,500
Satisfied by your gamark

962
00:43:52,500 --> 00:43:56,640
um you can you can construct uh publicly

963
00:43:56,640 --> 00:43:58,619
verify or secret setting

964
00:43:58,619 --> 00:44:01,619
a scheme in the following way so the

965
00:44:01,619 --> 00:44:06,000
dealer will share a secret

966
00:44:06,000 --> 00:44:08,339
um like using a linear sequencing scheme

967
00:44:08,339 --> 00:44:10,859
for example Samir then we'll publish the

968
00:44:10,859 --> 00:44:15,259
the encryption of the of the shares

969
00:44:15,359 --> 00:44:17,400
um under the public keys of the of the

970
00:44:17,400 --> 00:44:18,839
parties that are going to receive these

971
00:44:18,839 --> 00:44:19,740
shares

972
00:44:19,740 --> 00:44:22,500
and then it's going to do uh the same

973
00:44:22,500 --> 00:44:25,560
thing but now with a random sharing so

974
00:44:25,560 --> 00:44:27,599
it's going to take some random secret

975
00:44:27,599 --> 00:44:31,079
create a random sharing and encrypt the

976
00:44:31,079 --> 00:44:35,940
shares and publish those those values

977
00:44:35,940 --> 00:44:38,819
and now uh we can see this this last

978
00:44:38,819 --> 00:44:41,520
thing as a first step of of a sigma

979
00:44:41,520 --> 00:44:42,599
protocol

980
00:44:42,599 --> 00:44:46,740
and and then

981
00:44:46,740 --> 00:44:49,560
we can uh essentially have a

982
00:44:49,560 --> 00:44:52,440
non-interactive signal knowledge proof

983
00:44:52,440 --> 00:44:55,680
uh by uh by using just the standard

984
00:44:55,680 --> 00:45:00,300
trick of taking a challenge constructed

985
00:45:00,300 --> 00:45:01,800
from

986
00:45:01,800 --> 00:45:06,540
from the the the public messages and

987
00:45:06,540 --> 00:45:09,359
then opening a linear combination of the

988
00:45:09,359 --> 00:45:13,680
uh of the shares and the randomness and

989
00:45:13,680 --> 00:45:15,660
then the verifier can check that the

990
00:45:15,660 --> 00:45:17,700
corresponding linear combination of this

991
00:45:17,700 --> 00:45:20,040
of the ciphertext are actually the

992
00:45:20,040 --> 00:45:22,560
encryptions of this linear uh

993
00:45:22,560 --> 00:45:25,500
combinations of of the that that have

994
00:45:25,500 --> 00:45:28,859
been opened and also that this value set

995
00:45:28,859 --> 00:45:31,800
eyes that you have here are a correct

996
00:45:31,800 --> 00:45:34,079
sharing in the same linear citizen

997
00:45:34,079 --> 00:45:36,780
scheme so this would be just

998
00:45:36,780 --> 00:45:39,960
the the publicly verify our secret

999
00:45:39,960 --> 00:45:42,240
setting and this is nice because it can

1000
00:45:42,240 --> 00:45:45,359
fit with any uh encryption that we are

1001
00:45:45,359 --> 00:45:46,800
using

1002
00:45:46,800 --> 00:45:48,780
um for the for our encryption to the

1003
00:45:48,780 --> 00:45:50,280
current winner

1004
00:45:50,280 --> 00:45:52,980
and this is secure if the encryption is

1005
00:45:52,980 --> 00:45:57,119
actually in CPA

1006
00:45:57,420 --> 00:46:00,380
uh we also have in the paper some

1007
00:46:00,380 --> 00:46:03,300
protocols to prove uh correctly

1008
00:46:03,300 --> 00:46:05,880
reselling and reconstruction of the

1009
00:46:05,880 --> 00:46:07,859
secret so

1010
00:46:07,859 --> 00:46:10,680
um essentially resetting is a little bit

1011
00:46:10,680 --> 00:46:13,380
more involved than proving correctness

1012
00:46:13,380 --> 00:46:14,819
of sharing because when you prove

1013
00:46:14,819 --> 00:46:17,760
correctness of resetting you needs to

1014
00:46:17,760 --> 00:46:19,859
prove that actually the secret that is

1015
00:46:19,859 --> 00:46:22,440
underlying your the the encrypted shares

1016
00:46:22,440 --> 00:46:25,079
that you are going to send is the share

1017
00:46:25,079 --> 00:46:26,880
that you had before which

1018
00:46:26,880 --> 00:46:29,220
for which the other parties only know a

1019
00:46:29,220 --> 00:46:31,440
cipher text so you need to to prove that

1020
00:46:31,440 --> 00:46:34,920
but you can do that from uh because of

1021
00:46:34,920 --> 00:46:36,660
the linearity of the

1022
00:46:36,660 --> 00:46:41,280
of of the encryption scheme and

1023
00:46:41,280 --> 00:46:43,800
um then if you can prove reselling you

1024
00:46:43,800 --> 00:46:45,599
can also prove correct reconstruction of

1025
00:46:45,599 --> 00:46:47,060
a secret because you can see

1026
00:46:47,060 --> 00:46:49,920
reconstruction in in fact that's just

1027
00:46:49,920 --> 00:46:53,000
resetting with a sequencing scheme of

1028
00:46:53,000 --> 00:46:55,920
threshold zero essentially that would be

1029
00:46:55,920 --> 00:46:59,819
like publishing the the your share of of

1030
00:46:59,819 --> 00:47:01,500
the secret and then if everyone does

1031
00:47:01,500 --> 00:47:03,240
that then then you can recover the the

1032
00:47:03,240 --> 00:47:05,760
secrets so that's the

1033
00:47:05,760 --> 00:47:07,680
um reshaving reconstruction

1034
00:47:07,680 --> 00:47:12,980
and yeah so finally we have this

1035
00:47:13,079 --> 00:47:15,900
secret new sequencing scheme that say as

1036
00:47:15,900 --> 00:47:16,920
we say

1037
00:47:16,920 --> 00:47:19,619
uh is the first

1038
00:47:19,619 --> 00:47:21,839
uh Secrets publicly verified or Security

1039
00:47:21,839 --> 00:47:24,420
in a scheme that has a constant size of

1040
00:47:24,420 --> 00:47:27,119
our head meaning that the size of the

1041
00:47:27,119 --> 00:47:29,099
proofs that we are sending

1042
00:47:29,099 --> 00:47:33,119
of correct sharing is are independent or

1043
00:47:33,119 --> 00:47:35,359
the length is independent from the

1044
00:47:35,359 --> 00:47:38,040
number of of shares

1045
00:47:38,040 --> 00:47:40,020
and

1046
00:47:40,020 --> 00:47:42,420
this exercise can be interesting for

1047
00:47:42,420 --> 00:47:44,160
other applications like Randomness

1048
00:47:44,160 --> 00:47:47,099
vehicles here in this case the the

1049
00:47:47,099 --> 00:47:49,440
secret is an element of some cyclic

1050
00:47:49,440 --> 00:47:51,960
group of prime order where the ddh is

1051
00:47:51,960 --> 00:47:53,040
hard

1052
00:47:53,040 --> 00:47:58,160
and the dealer will will publish a

1053
00:47:58,160 --> 00:48:00,599
shares an encryption that is one element

1054
00:48:00,599 --> 00:48:03,000
in the group and as correctness proof

1055
00:48:03,000 --> 00:48:08,280
just two elements in the field of size B

1056
00:48:08,280 --> 00:48:11,099
and the idea is that we have uh that we

1057
00:48:11,099 --> 00:48:13,920
combine in order to have this scheme are

1058
00:48:13,920 --> 00:48:17,520
essentially two so one is that while in

1059
00:48:17,520 --> 00:48:20,700
previous uh publicly verified or

1060
00:48:20,700 --> 00:48:23,160
secretary schemes we had that cell

1061
00:48:23,160 --> 00:48:25,680
receivers would have prepares for the

1062
00:48:25,680 --> 00:48:27,780
discrete lock

1063
00:48:27,780 --> 00:48:31,500
um in this new scheme then the dealer

1064
00:48:31,500 --> 00:48:33,839
will also have a public a key pair

1065
00:48:33,839 --> 00:48:36,960
that's the sort of novelty that we had

1066
00:48:36,960 --> 00:48:39,780
seen in in some constructions for

1067
00:48:39,780 --> 00:48:43,980
paliers uh so for uh sequestion scheme

1068
00:48:43,980 --> 00:48:45,540
based on value but not

1069
00:48:45,540 --> 00:48:48,599
in the case of the discrete log

1070
00:48:48,599 --> 00:48:52,619
um and then uh in order to prove or in

1071
00:48:52,619 --> 00:48:54,900
order to share an element of the group

1072
00:48:54,900 --> 00:48:56,839
what you do is to basically

1073
00:48:56,839 --> 00:48:59,579
share the discrete log

1074
00:48:59,579 --> 00:49:01,619
uh but you actually don't need to know

1075
00:49:01,619 --> 00:49:03,660
this discrete log so because you can

1076
00:49:03,660 --> 00:49:07,260
just essentially construct a sharing of

1077
00:49:07,260 --> 00:49:10,319
zero and then add that to the to the

1078
00:49:10,319 --> 00:49:12,839
secret that you have so so the idea

1079
00:49:12,839 --> 00:49:14,400
would be just to sample the polynomial

1080
00:49:14,400 --> 00:49:16,740
that's a

1081
00:49:16,740 --> 00:49:17,579
um

1082
00:49:17,579 --> 00:49:19,619
well like here it should say zero

1083
00:49:19,619 --> 00:49:22,020
actually that's a such that the

1084
00:49:22,020 --> 00:49:24,540
evaluation of of uh of this polynomial

1085
00:49:24,540 --> 00:49:26,940
instead of is zero and then you will add

1086
00:49:26,940 --> 00:49:30,359
that to the to the element of the of the

1087
00:49:30,359 --> 00:49:32,220
group

1088
00:49:32,220 --> 00:49:34,560
and then in order to encrypt the share

1089
00:49:34,560 --> 00:49:36,780
you add

1090
00:49:36,780 --> 00:49:37,440
um

1091
00:49:37,440 --> 00:49:38,900
the element

1092
00:49:38,900 --> 00:49:42,119
this should be a big a sub I so

1093
00:49:42,119 --> 00:49:45,440
essentially you you are um

1094
00:49:45,440 --> 00:49:50,119
a one-time padding your your share with

1095
00:49:50,119 --> 00:49:54,599
them difficult key that you would get

1096
00:49:54,599 --> 00:49:58,500
between the dealer and the ice receiver

1097
00:49:58,500 --> 00:50:01,920
so this should be a pki here

1098
00:50:01,920 --> 00:50:04,680
this is one idea it would give the

1099
00:50:04,680 --> 00:50:07,619
dealer a key pair and the other idea is

1100
00:50:07,619 --> 00:50:10,980
is that is to use this scribe check that

1101
00:50:10,980 --> 00:50:14,760
scrape check that we had in the paper

1102
00:50:14,760 --> 00:50:16,920
five years ago

1103
00:50:16,920 --> 00:50:18,720
um and the idea is that in order to test

1104
00:50:18,720 --> 00:50:22,079
that something is correct sharing in the

1105
00:50:22,079 --> 00:50:25,380
in in Samir scheme you can notice that

1106
00:50:25,380 --> 00:50:28,020
the set of all correct settings is a

1107
00:50:28,020 --> 00:50:30,740
linear code so it has a dual code

1108
00:50:30,740 --> 00:50:34,319
and whenever you have a vector of n

1109
00:50:34,319 --> 00:50:38,220
elements in order to have a test so that

1110
00:50:38,220 --> 00:50:40,560
to see that it is a correct sharing you

1111
00:50:40,560 --> 00:50:42,780
could sample an element from uh at

1112
00:50:42,780 --> 00:50:44,579
random from from the door from the Dual

1113
00:50:44,579 --> 00:50:45,359
code

1114
00:50:45,359 --> 00:50:48,119
and take the inner product if that in a

1115
00:50:48,119 --> 00:50:49,800
product is zero

1116
00:50:49,800 --> 00:50:51,900
or or let's say if this is this the

1117
00:50:51,900 --> 00:50:54,780
vector C is in the code then the inner

1118
00:50:54,780 --> 00:50:56,940
plot will always be zero if it's not in

1119
00:50:56,940 --> 00:50:58,920
the code then it will be zero with very

1120
00:50:58,920 --> 00:51:00,480
small probability

1121
00:51:00,480 --> 00:51:05,520
so if we Port that to groups uh then now

1122
00:51:05,520 --> 00:51:07,740
we have an a vector of n elements in the

1123
00:51:07,740 --> 00:51:11,460
group and we can test whether that's uh

1124
00:51:11,460 --> 00:51:16,079
those n elements are a Shamir uh so

1125
00:51:16,079 --> 00:51:19,319
meaning of the form F of I times the

1126
00:51:19,319 --> 00:51:21,660
generator with the polynomial of the

1127
00:51:21,660 --> 00:51:22,740
right degree

1128
00:51:22,740 --> 00:51:24,480
uh by just taking this linear

1129
00:51:24,480 --> 00:51:26,640
combination and seeing it that is zero

1130
00:51:26,640 --> 00:51:28,920
so that's the other trick so the

1131
00:51:28,920 --> 00:51:30,780
construction in the end that we have is

1132
00:51:30,780 --> 00:51:32,339
the following so we have that's the

1133
00:51:32,339 --> 00:51:35,160
dealer and and their cell receivers have

1134
00:51:35,160 --> 00:51:37,500
all uh keys

1135
00:51:37,500 --> 00:51:40,079
uh key pairs

1136
00:51:40,079 --> 00:51:42,839
um the the dealer constructs the the

1137
00:51:42,839 --> 00:51:46,140
shares for for the secrets then uh

1138
00:51:46,140 --> 00:51:48,839
encrypts the shares sends these

1139
00:51:48,839 --> 00:51:51,180
encryptions uh the ith party can

1140
00:51:51,180 --> 00:51:55,020
actually recover the The Ice share and

1141
00:51:55,020 --> 00:51:57,540
now the proof uh consists in the

1142
00:51:57,540 --> 00:52:01,079
following you you sample uh via uh well

1143
00:52:01,079 --> 00:52:05,280
sort of a field Samir technique

1144
00:52:05,280 --> 00:52:06,200
um

1145
00:52:06,200 --> 00:52:09,599
some random codeword in the Dual you

1146
00:52:09,599 --> 00:52:12,660
take uh the linear combination with uh

1147
00:52:12,660 --> 00:52:14,880
coordinates V in the the components of

1148
00:52:14,880 --> 00:52:17,819
that codeword and now the point is that

1149
00:52:17,819 --> 00:52:21,300
this this Factor here should go to zero

1150
00:52:21,300 --> 00:52:25,319
if if the setting is a correct one

1151
00:52:25,319 --> 00:52:28,140
and say and then you get an expression

1152
00:52:28,140 --> 00:52:30,480
where essentially

1153
00:52:30,480 --> 00:52:31,380
um

1154
00:52:31,380 --> 00:52:33,720
the linear combinations that you have in

1155
00:52:33,720 --> 00:52:36,240
left and right are public elements that

1156
00:52:36,240 --> 00:52:38,099
can be publicly computed

1157
00:52:38,099 --> 00:52:40,440
and they are related by the Signet key

1158
00:52:40,440 --> 00:52:41,700
of the dealer

1159
00:52:41,700 --> 00:52:44,160
but now the secret is now the dealer

1160
00:52:44,160 --> 00:52:47,400
only needs to to prove that her public

1161
00:52:47,400 --> 00:52:53,520
key is uh constructed or essentially the

1162
00:52:53,520 --> 00:52:55,800
discrete log of the public key with

1163
00:52:55,800 --> 00:52:58,260
respect to the generator is the same as

1164
00:52:58,260 --> 00:53:02,099
the discrete log of this week here uh in

1165
00:53:02,099 --> 00:53:03,240
base U

1166
00:53:03,240 --> 00:53:05,530
and that is enough that is a

1167
00:53:05,530 --> 00:53:06,720
[Music]

1168
00:53:06,720 --> 00:53:10,760
a very standard non-interactive proof

1169
00:53:10,760 --> 00:53:13,800
that only requires two elements in the

1170
00:53:13,800 --> 00:53:15,960
field and so we have this construction

1171
00:53:15,960 --> 00:53:18,720
finally that that only has two elements

1172
00:53:18,720 --> 00:53:22,819
of the field as a proof of correctness

1173
00:53:22,859 --> 00:53:27,839
um as remarks uh we have proofs in the

1174
00:53:27,839 --> 00:53:30,059
paper for for correct resetting two for

1175
00:53:30,059 --> 00:53:32,339
this for this scheme

1176
00:53:32,339 --> 00:53:35,280
um and one problem of this construction

1177
00:53:35,280 --> 00:53:38,760
is that parties can only reconstruct a

1178
00:53:38,760 --> 00:53:40,260
group element

1179
00:53:40,260 --> 00:53:43,339
and not the the discrete lock or the

1180
00:53:43,339 --> 00:53:46,500
exponent of the of the

1181
00:53:46,500 --> 00:53:48,540
elements

1182
00:53:48,540 --> 00:53:51,660
um which is not really nice for for NPC

1183
00:53:51,660 --> 00:53:54,660
so we think that to fix that we could

1184
00:53:54,660 --> 00:53:58,140
use the the scheme of castanus regular

1185
00:53:58,140 --> 00:53:59,940
me

1186
00:53:59,940 --> 00:54:02,579
um I think that there is

1187
00:54:02,579 --> 00:54:05,339
a a talk in this conference also based

1188
00:54:05,339 --> 00:54:08,640
on on this uh on this work but

1189
00:54:08,640 --> 00:54:11,160
um essentially the the work consistent

1190
00:54:11,160 --> 00:54:14,420
or the the the the encryption scheme

1191
00:54:14,420 --> 00:54:18,240
requires some group with hard ddh that

1192
00:54:18,240 --> 00:54:19,980
has an easy

1193
00:54:19,980 --> 00:54:22,440
or a subgroup with a easy discrete log

1194
00:54:22,440 --> 00:54:24,540
and that allows to reconstruct the

1195
00:54:24,540 --> 00:54:27,500
exponent there

1196
00:54:27,960 --> 00:54:28,920
um

1197
00:54:28,920 --> 00:54:32,640
so um as a conclusion then we propose a

1198
00:54:32,640 --> 00:54:34,980
efficient encryption and publicly

1199
00:54:34,980 --> 00:54:37,610
verifiable secret setting or for

1200
00:54:37,610 --> 00:54:37,920
[Music]

1201
00:54:37,920 --> 00:54:38,720
um

1202
00:54:38,720 --> 00:54:41,460
uh a current winner

1203
00:54:41,460 --> 00:54:44,339
in the context of the also model

1204
00:54:44,339 --> 00:54:48,300
and in particular we have this new PVSS

1205
00:54:48,300 --> 00:54:50,339
that is the most communication efficient

1206
00:54:50,339 --> 00:54:53,480
that we know to date and can be

1207
00:54:53,480 --> 00:54:55,740
interesting for other applications such

1208
00:54:55,740 --> 00:54:59,460
as construction of randomness weakons

1209
00:54:59,460 --> 00:55:00,180
um

1210
00:55:00,180 --> 00:55:02,940
and as a future work uh we would like to

1211
00:55:02,940 --> 00:55:06,540
have constructions that allows us to

1212
00:55:06,540 --> 00:55:09,300
parties to reconstruct not only group

1213
00:55:09,300 --> 00:55:12,140
elements but also like uh Fields

1214
00:55:12,140 --> 00:55:14,579
Associated field elements so that we can

1215
00:55:14,579 --> 00:55:17,220
use it more efficiently or use it for

1216
00:55:17,220 --> 00:55:20,220
for for MPC

1217
00:55:20,220 --> 00:55:23,579
um yeah so that's all

1218
00:55:23,579 --> 00:55:26,280
thank you thanks a lot for the talk

1219
00:55:26,280 --> 00:55:28,819
yeah

1220
00:55:31,319 --> 00:55:34,859
that took a bit longer so we switched

1221
00:55:34,859 --> 00:55:37,440
immediately to the next talk and uh

1222
00:55:37,440 --> 00:55:40,260
we'll have to take questions

1223
00:55:40,260 --> 00:55:42,540
offline

1224
00:55:42,540 --> 00:55:44,460
um the last Talk of the session is State

1225
00:55:44,460 --> 00:55:46,200
machine replication and the changing

1226
00:55:46,200 --> 00:55:48,780
Network conditions by Andrea Alexandro

1227
00:55:48,780 --> 00:55:51,660
Erica Bloom Jonathan Katz and Julian

1228
00:55:51,660 --> 00:55:54,660
loss and Erica will give the talk I

1229
00:55:54,660 --> 00:55:56,839
think

1230
00:55:57,980 --> 00:56:02,280
yes hello everyone let me just quickly

1231
00:56:02,280 --> 00:56:05,599
get this screen sharing up and working

1232
00:56:05,599 --> 00:56:08,960
and video

1233
00:56:23,599 --> 00:56:26,700
hopefully everyone is now seeing a a

1234
00:56:26,700 --> 00:56:28,680
presentation as they expect

1235
00:56:28,680 --> 00:56:30,359
yes okay

1236
00:56:30,359 --> 00:56:33,000
excellent so thank you for the

1237
00:56:33,000 --> 00:56:35,220
introduction uh without further Ado I'm

1238
00:56:35,220 --> 00:56:37,319
excited to talk to you today about some

1239
00:56:37,319 --> 00:56:39,660
of our recent work on reaching agreement

1240
00:56:39,660 --> 00:56:42,180
in unknown or changing Network

1241
00:56:42,180 --> 00:56:45,359
conditions this is a joint work as as

1242
00:56:45,359 --> 00:56:47,940
was just said with my co-authors are

1243
00:56:47,940 --> 00:56:50,579
Andrea alexandru Jonathan Katz and

1244
00:56:50,579 --> 00:56:52,319
Julian loss

1245
00:56:52,319 --> 00:56:55,200
foreign so I'll start with a quick

1246
00:56:55,200 --> 00:56:57,359
overview of the core problem State

1247
00:56:57,359 --> 00:56:59,040
machine replication

1248
00:56:59,040 --> 00:57:01,500
a state machine replication or SMR

1249
00:57:01,500 --> 00:57:03,660
protocol allows a set of parties to

1250
00:57:03,660 --> 00:57:05,700
agree on a growing ordered log of

1251
00:57:05,700 --> 00:57:08,520
transactions individual parties receive

1252
00:57:08,520 --> 00:57:11,040
unordered inputs and need to agree as a

1253
00:57:11,040 --> 00:57:13,140
group on an ordered sequence of outputs

1254
00:57:13,140 --> 00:57:15,839
in practice these outputs are often

1255
00:57:15,839 --> 00:57:17,700
batched so we'll think of parties logs

1256
00:57:17,700 --> 00:57:19,920
as sequences or arrays of these batches

1257
00:57:19,920 --> 00:57:23,240
which we'll call blocks

1258
00:57:23,940 --> 00:57:26,220
the key challenge here is that some of

1259
00:57:26,220 --> 00:57:28,079
the parties might be faulty or or

1260
00:57:28,079 --> 00:57:29,819
Byzantine which means that they might

1261
00:57:29,819 --> 00:57:32,880
deviate arbitrarily from the protocol

1262
00:57:32,880 --> 00:57:35,700
and for an honest part or for an SMR

1263
00:57:35,700 --> 00:57:37,740
protocol to be secure we require that

1264
00:57:37,740 --> 00:57:39,960
all honest parties agree on the sequence

1265
00:57:39,960 --> 00:57:41,760
of blocks that were output and the

1266
00:57:41,760 --> 00:57:45,000
transactions in those blocks even if the

1267
00:57:45,000 --> 00:57:47,160
faulty parties are being coordinated by

1268
00:57:47,160 --> 00:57:51,240
some uh single Mastermind adversary

1269
00:57:51,240 --> 00:57:53,579
we can view SMR as one of several

1270
00:57:53,579 --> 00:57:55,740
problems under the broader umbrella of

1271
00:57:55,740 --> 00:57:58,619
consensus problems another problem under

1272
00:57:58,619 --> 00:58:00,540
that umbrella is Byzantine agreement

1273
00:58:00,540 --> 00:58:03,359
where parties agree on a single value if

1274
00:58:03,359 --> 00:58:04,980
it helps for the purposes of this talk

1275
00:58:04,980 --> 00:58:07,140
you can think of Byzantine agreement as

1276
00:58:07,140 --> 00:58:09,660
single shot agreement on binary values

1277
00:58:09,660 --> 00:58:12,420
and SMR is a multi-shot agreement on

1278
00:58:12,420 --> 00:58:14,280
arbitrary values

1279
00:58:14,280 --> 00:58:17,460
SMR as a problem has a long history in

1280
00:58:17,460 --> 00:58:19,680
distributed computing and recently it's

1281
00:58:19,680 --> 00:58:21,359
received special attention because it

1282
00:58:21,359 --> 00:58:23,520
turns out to be a useful abstraction for

1283
00:58:23,520 --> 00:58:26,040
blockchain protocols under the hood many

1284
00:58:26,040 --> 00:58:28,200
blockchain protocols use some form of

1285
00:58:28,200 --> 00:58:30,359
consensus protocol in order to order

1286
00:58:30,359 --> 00:58:33,059
transactions as they enter the network

1287
00:58:33,059 --> 00:58:36,119
I say many and not all because people

1288
00:58:36,119 --> 00:58:38,220
call lots of things blockchains and I'm

1289
00:58:38,220 --> 00:58:39,599
sure somewhere out there there's a

1290
00:58:39,599 --> 00:58:41,099
there's a thing that someone is calling

1291
00:58:41,099 --> 00:58:42,299
a blockchain that does something

1292
00:58:42,299 --> 00:58:44,400
completely different but in this talk

1293
00:58:44,400 --> 00:58:46,079
we'll just make our lives easier and all

1294
00:58:46,079 --> 00:58:48,540
agree to treat blockchain and SMR as the

1295
00:58:48,540 --> 00:58:50,640
same thing

1296
00:58:50,640 --> 00:58:53,099
so that's the big picture in a little

1297
00:58:53,099 --> 00:58:55,380
more detail here are the properties that

1298
00:58:55,380 --> 00:58:57,720
we want from an SMR protocol throughout

1299
00:58:57,720 --> 00:58:59,400
we'll let N be the total number of

1300
00:58:59,400 --> 00:59:01,440
parties and let T denote the number of

1301
00:59:01,440 --> 00:59:03,900
faulty or Byzantine parties

1302
00:59:03,900 --> 00:59:06,000
so the first property that we require is

1303
00:59:06,000 --> 00:59:11,160
consistency which means that all parties

1304
00:59:11,160 --> 00:59:15,359
who have output the case block agree on

1305
00:59:15,359 --> 00:59:18,000
what's in that case block

1306
00:59:18,000 --> 00:59:20,099
the second property is completeness

1307
00:59:20,099 --> 00:59:21,839
which says that every honest party

1308
00:59:21,839 --> 00:59:23,700
eventually outputs a block at all

1309
00:59:23,700 --> 00:59:25,740
indices essentially this is just saying

1310
00:59:25,740 --> 00:59:27,480
that the protocol can't stall forever

1311
00:59:27,480 --> 00:59:29,460
eventually as long as you keep working

1312
00:59:29,460 --> 00:59:31,559
you'll eventually have something to put

1313
00:59:31,559 --> 00:59:34,020
at every index

1314
00:59:34,020 --> 00:59:37,020
next we have a property liveness which

1315
00:59:37,020 --> 00:59:39,059
says that if a transaction is input to

1316
00:59:39,059 --> 00:59:40,859
sufficiently many honest parties

1317
00:59:40,859 --> 00:59:43,500
sufficiently many here being at least n

1318
00:59:43,500 --> 00:59:45,960
minus t of them then all honest parties

1319
00:59:45,960 --> 00:59:47,760
eventually place that transaction

1320
00:59:47,760 --> 00:59:50,760
somewhere in some block

1321
00:59:50,760 --> 00:59:53,280
and finally the last property that we'll

1322
00:59:53,280 --> 00:59:55,740
consider is external external

1323
00:59:55,740 --> 00:59:57,299
verifiability

1324
00:59:57,299 --> 00:59:59,400
which means that given some public

1325
00:59:59,400 --> 01:00:00,900
parameters and some additional

1326
01:00:00,900 --> 01:00:04,020
information anyone even someone who was

1327
01:00:04,020 --> 01:00:05,880
not participating in the protocol but

1328
01:00:05,880 --> 01:00:08,099
was observing or maybe even someone who

1329
01:00:08,099 --> 01:00:10,440
was completely offline and just woke up

1330
01:00:10,440 --> 01:00:13,680
all of a sudden after the protocol can

1331
01:00:13,680 --> 01:00:16,260
verify that a block was honestly output

1332
01:00:16,260 --> 01:00:17,819
and that it was output at that

1333
01:00:17,819 --> 01:00:20,280
particular spot in the array and

1334
01:00:20,280 --> 01:00:22,200
furthermore we require that dishonest

1335
01:00:22,200 --> 01:00:24,540
parties can't generate a valid proof for

1336
01:00:24,540 --> 01:00:26,400
a block that wasn't actually output by

1337
01:00:26,400 --> 01:00:28,200
the honest parties

1338
01:00:28,200 --> 01:00:30,240
so a quick caveat there are lots of

1339
01:00:30,240 --> 01:00:32,339
different uh variations on this

1340
01:00:32,339 --> 01:00:34,619
definition but for our purposes we'll

1341
01:00:34,619 --> 01:00:36,780
say that an SMR protocol needs to meet

1342
01:00:36,780 --> 01:00:40,339
all four of these properties

1343
01:00:42,720 --> 01:00:44,940
so State machine replication protocols

1344
01:00:44,940 --> 01:00:46,980
and and consensus protocols as a whole

1345
01:00:46,980 --> 01:00:49,440
have been studied in a wide variety of

1346
01:00:49,440 --> 01:00:53,160
network synchrony models and here on on

1347
01:00:53,160 --> 01:00:55,980
the slide you'll see two extremes on on

1348
01:00:55,980 --> 01:00:58,099
your left we have the synchronous model

1349
01:00:58,099 --> 01:01:00,780
where uh

1350
01:01:00,780 --> 01:01:03,240
we assume that there are synchronous

1351
01:01:03,240 --> 01:01:05,579
that each party has synchronized clocks

1352
01:01:05,579 --> 01:01:07,980
and messages arrive after at most some

1353
01:01:07,980 --> 01:01:11,220
fixed delay usually denoted by a simple

1354
01:01:11,220 --> 01:01:14,520
Delta and under this model assuming uh

1355
01:01:14,520 --> 01:01:16,440
public key infrastructure it's known

1356
01:01:16,440 --> 01:01:18,119
that state machine replication is

1357
01:01:18,119 --> 01:01:20,339
feasible if and only if there are fewer

1358
01:01:20,339 --> 01:01:23,520
than n over 2 Corruptions at The Other

1359
01:01:23,520 --> 01:01:25,579
Extreme we have in terms of network

1360
01:01:25,579 --> 01:01:28,020
models we have the asynchronous model

1361
01:01:28,020 --> 01:01:30,059
where there are no synchronized clocks

1362
01:01:30,059 --> 01:01:32,520
and messages can be arbitrarily delayed

1363
01:01:32,520 --> 01:01:35,280
in the asynchronous model again assuming

1364
01:01:35,280 --> 01:01:37,500
public key infrastructure the optimal

1365
01:01:37,500 --> 01:01:39,780
corruption threshold is n over three

1366
01:01:39,780 --> 01:01:42,000
there's also the partially synchronous

1367
01:01:42,000 --> 01:01:45,000
Network and and many other flavors of

1368
01:01:45,000 --> 01:01:46,559
in-between models but they won't be

1369
01:01:46,559 --> 01:01:48,780
relevant to this talk

1370
01:01:48,780 --> 01:01:51,359
so in this paper we consider What's

1371
01:01:51,359 --> 01:01:53,700
called the network agnostic model where

1372
01:01:53,700 --> 01:01:55,559
the network might be either synchronous

1373
01:01:55,559 --> 01:01:58,200
or asynchronous it's parameterized by

1374
01:01:58,200 --> 01:02:00,960
thresholds TS and ta

1375
01:02:00,960 --> 01:02:02,940
so that if the network is synchronous we

1376
01:02:02,940 --> 01:02:04,799
allow the adversary to control TS

1377
01:02:04,799 --> 01:02:06,480
parties and if the network is

1378
01:02:06,480 --> 01:02:08,220
asynchronous the adversary gets to

1379
01:02:08,220 --> 01:02:10,799
control ta parties and what we want is

1380
01:02:10,799 --> 01:02:12,780
to design a single protocol that just

1381
01:02:12,780 --> 01:02:15,119
works even if the honest parties don't

1382
01:02:15,119 --> 01:02:17,339
know which mode they're in during a

1383
01:02:17,339 --> 01:02:19,680
particular execution

1384
01:02:19,680 --> 01:02:21,900
so this is a this is a model that would

1385
01:02:21,900 --> 01:02:24,299
reduce introduced in an in an earlier

1386
01:02:24,299 --> 01:02:25,859
work by myself and and some other

1387
01:02:25,859 --> 01:02:30,059
co-authors uh and uh has been since then

1388
01:02:30,059 --> 01:02:32,880
extended in a couple different ways and

1389
01:02:32,880 --> 01:02:34,559
one of the key questions that we address

1390
01:02:34,559 --> 01:02:37,020
in this work is how can we improve the

1391
01:02:37,020 --> 01:02:39,720
communication complexity of network

1392
01:02:39,720 --> 01:02:43,140
agnostic SMR to match the complexity of

1393
01:02:43,140 --> 01:02:47,900
similar fully asynchronous protocols

1394
01:02:48,180 --> 01:02:51,119
oh and just as a just as a lesson no

1395
01:02:51,119 --> 01:02:54,359
almost forgot uh one of the results in

1396
01:02:54,359 --> 01:02:56,099
these prior works that will refer back

1397
01:02:56,099 --> 01:02:59,720
to a few times is the fact that uh

1398
01:02:59,720 --> 01:03:01,859
consensus in general and state machine

1399
01:03:01,859 --> 01:03:04,500
replication specifically is feasible in

1400
01:03:04,500 --> 01:03:07,859
this model if and only if 2ts plus ta is

1401
01:03:07,859 --> 01:03:10,578
less than n

1402
01:03:10,740 --> 01:03:14,040
so just to help us gain some familiarity

1403
01:03:14,040 --> 01:03:16,020
with this model I like to think of it as

1404
01:03:16,020 --> 01:03:18,180
sort of an informal cryptographic game

1405
01:03:18,180 --> 01:03:20,520
between the adversary and an environment

1406
01:03:20,520 --> 01:03:22,140
who plays on behalf of the honest

1407
01:03:22,140 --> 01:03:24,660
parties for Simplicity I'll describe

1408
01:03:24,660 --> 01:03:26,460
this with static Corruptions but you can

1409
01:03:26,460 --> 01:03:28,440
also consider adaptive Corruptions and

1410
01:03:28,440 --> 01:03:30,359
we'll get to that shortly

1411
01:03:30,359 --> 01:03:32,940
so in this game the adversary has a

1412
01:03:32,940 --> 01:03:35,400
switch and at this before the start of

1413
01:03:35,400 --> 01:03:37,440
the protocol they secretly choose one of

1414
01:03:37,440 --> 01:03:39,299
these two modes that we've allowed them

1415
01:03:39,299 --> 01:03:41,339
either there's the synchronous network

1416
01:03:41,339 --> 01:03:43,140
with a higher number of Corruptions

1417
01:03:43,140 --> 01:03:45,059
where there's the asynchronous network

1418
01:03:45,059 --> 01:03:47,579
with a lower number of Corruptions so

1419
01:03:47,579 --> 01:03:49,319
before the protocol even starts the

1420
01:03:49,319 --> 01:03:51,359
adversary picks whichever setting they

1421
01:03:51,359 --> 01:03:54,240
want and since we're in the static World

1422
01:03:54,240 --> 01:03:55,680
a set of parties that they want to

1423
01:03:55,680 --> 01:03:57,660
corrupt let's say that they choose the

1424
01:03:57,660 --> 01:03:59,099
asynchronous network

1425
01:03:59,099 --> 01:04:01,559
so they tell the environment these are

1426
01:04:01,559 --> 01:04:04,260
my choices for this execution and then

1427
01:04:04,260 --> 01:04:07,140
they just run the protocol as normal

1428
01:04:07,140 --> 01:04:09,359
our security definition requires that

1429
01:04:09,359 --> 01:04:11,339
the adversary can't break Security even

1430
01:04:11,339 --> 01:04:13,319
if the honest parties don't know which

1431
01:04:13,319 --> 01:04:16,020
mode they're in

1432
01:04:16,020 --> 01:04:17,760
so that's the network agnostic model

1433
01:04:17,760 --> 01:04:19,500
which is actually the first of two

1434
01:04:19,500 --> 01:04:21,720
models that we're going to talk about uh

1435
01:04:21,720 --> 01:04:24,180
in this talk the second model is new in

1436
01:04:24,180 --> 01:04:26,460
this work and adds a new Twist on the

1437
01:04:26,460 --> 01:04:28,799
original Network agnostic model

1438
01:04:28,799 --> 01:04:30,900
so remember that in the network agnostic

1439
01:04:30,900 --> 01:04:32,880
model the the adversary is allowed to

1440
01:04:32,880 --> 01:04:35,280
choose the underlying mode exactly once

1441
01:04:35,280 --> 01:04:37,020
before the start of the protocol they

1442
01:04:37,020 --> 01:04:39,660
have to commit to it and a natural next

1443
01:04:39,660 --> 01:04:41,819
question is what can we hope to achieve

1444
01:04:41,819 --> 01:04:44,160
in a model where the adversary can

1445
01:04:44,160 --> 01:04:46,020
switch back and forth between these

1446
01:04:46,020 --> 01:04:47,460
nodes during the lifetime of the

1447
01:04:47,460 --> 01:04:49,619
protocol maybe we have some pattern

1448
01:04:49,619 --> 01:04:52,200
where it's switching back and forth

1449
01:04:52,200 --> 01:04:54,059
and we found that it's not at all

1450
01:04:54,059 --> 01:04:56,160
trivial to translate the results from

1451
01:04:56,160 --> 01:04:58,079
what I'll call the the original flavor

1452
01:04:58,079 --> 01:05:00,119
Network agnostic model to this new model

1453
01:05:00,119 --> 01:05:03,000
and to see one of the reasons why here

1454
01:05:03,000 --> 01:05:06,000
here's a a simple example suppose the

1455
01:05:06,000 --> 01:05:07,920
network is initially in the synchronous

1456
01:05:07,920 --> 01:05:09,900
mode and the adversary has control of

1457
01:05:09,900 --> 01:05:12,780
the higher number of parties TS where TS

1458
01:05:12,780 --> 01:05:15,480
is allowed to be greater than n over 3.

1459
01:05:15,480 --> 01:05:17,880
if the network becomes asynchronous

1460
01:05:17,880 --> 01:05:20,280
while the adversary still controls those

1461
01:05:20,280 --> 01:05:23,520
parties uh there's nothing that we can

1462
01:05:23,520 --> 01:05:25,200
do that will preserve security and we

1463
01:05:25,200 --> 01:05:26,720
know this because there's a classical

1464
01:05:26,720 --> 01:05:29,839
impossibility result that says uh

1465
01:05:29,839 --> 01:05:32,160
consensus is impossible for greater than

1466
01:05:32,160 --> 01:05:35,400
n over 3 Corruptions in the asynchronous

1467
01:05:35,400 --> 01:05:39,119
model so that's that's a lost cause and

1468
01:05:39,119 --> 01:05:40,799
so to get around this impossibility

1469
01:05:40,799 --> 01:05:43,380
result we need to assume somehow we need

1470
01:05:43,380 --> 01:05:46,040
to bake into our model that the

1471
01:05:46,040 --> 01:05:48,480
corruption capability of the adversary

1472
01:05:48,480 --> 01:05:52,140
also decreases uh whenever it flips that

1473
01:05:52,140 --> 01:05:56,940
which to to asynchronous so we'll get

1474
01:05:56,940 --> 01:05:59,040
into the details more later but

1475
01:05:59,040 --> 01:06:01,500
essentially in in this flavor in this

1476
01:06:01,500 --> 01:06:04,380
new exciting flavor of our model uh we

1477
01:06:04,380 --> 01:06:06,180
assume that parties have a capability

1478
01:06:06,180 --> 01:06:08,579
that allows them to periodically reboot

1479
01:06:08,579 --> 01:06:11,819
uh and and kick out the adversary

1480
01:06:11,819 --> 01:06:15,960
but this has a notable complication that

1481
01:06:15,960 --> 01:06:18,420
this doesn't remove the secret state

1482
01:06:18,420 --> 01:06:20,700
that those parties had from the view of

1483
01:06:20,700 --> 01:06:23,819
the adversary so even if uh an honest

1484
01:06:23,819 --> 01:06:25,819
party has say rebooted their computer

1485
01:06:25,819 --> 01:06:29,700
and reloaded from from safe state so

1486
01:06:29,700 --> 01:06:31,380
that the adversary is no longer in

1487
01:06:31,380 --> 01:06:34,140
control of the machine Any secret keys

1488
01:06:34,140 --> 01:06:35,760
and anything that was lying around while

1489
01:06:35,760 --> 01:06:37,799
the adversary was in that machine are

1490
01:06:37,799 --> 01:06:40,440
still are still compromised and so we'll

1491
01:06:40,440 --> 01:06:43,140
need to deal with that

1492
01:06:43,140 --> 01:06:45,119
so again to sort of get a little bit of

1493
01:06:45,119 --> 01:06:47,460
fluency with this new model let's let's

1494
01:06:47,460 --> 01:06:50,579
look at our informal cryptographic game

1495
01:06:50,579 --> 01:06:52,740
so like before the adversary has the

1496
01:06:52,740 --> 01:06:55,680
switch that lets them determine the the

1497
01:06:55,680 --> 01:06:56,819
mode

1498
01:06:56,819 --> 01:06:59,339
but now we're going to allow them to

1499
01:06:59,339 --> 01:07:02,280
sort of adaptively choose that setting

1500
01:07:02,280 --> 01:07:04,440
and and their Corruptions over the

1501
01:07:04,440 --> 01:07:07,160
course of the game uh however they like

1502
01:07:07,160 --> 01:07:10,500
as long as at each point they're obeying

1503
01:07:10,500 --> 01:07:14,640
this corruption threshold and uh we'll

1504
01:07:14,640 --> 01:07:16,740
again I'm sort of deliberately glossing

1505
01:07:16,740 --> 01:07:18,839
over some of the details but we're

1506
01:07:18,839 --> 01:07:21,539
assuming here that periodically parties

1507
01:07:21,539 --> 01:07:24,299
are caused by the protocol to refresh

1508
01:07:24,299 --> 01:07:26,099
booting out the adversary and then the

1509
01:07:26,099 --> 01:07:27,900
adversary gets to make further choices

1510
01:07:27,900 --> 01:07:29,940
about who to corrupt

1511
01:07:29,940 --> 01:07:33,119
more more on all that later

1512
01:07:33,119 --> 01:07:36,839
so here's just a brief uh overview of

1513
01:07:36,839 --> 01:07:40,200
some of the most related work there is a

1514
01:07:40,200 --> 01:07:44,099
really wide and deep uh body of work on

1515
01:07:44,099 --> 01:07:45,960
this topic so I'll I'll limit our view

1516
01:07:45,960 --> 01:07:48,420
to just sort of the the most closely

1517
01:07:48,420 --> 01:07:49,380
related

1518
01:07:49,380 --> 01:07:52,740
so if we look at the state of the art in

1519
01:07:52,740 --> 01:07:55,380
fully asynchronous protocols which are

1520
01:07:55,380 --> 01:07:57,660
sort of our our reference point here we

1521
01:07:57,660 --> 01:08:00,079
see that in both the static and adaptive

1522
01:08:00,079 --> 01:08:04,260
adversary models we know of Prior work

1523
01:08:04,260 --> 01:08:07,220
uh by these authors I've listed at left

1524
01:08:07,220 --> 01:08:11,400
that gives us a cubic complexity for

1525
01:08:11,400 --> 01:08:13,980
batches of end transactions so that's

1526
01:08:13,980 --> 01:08:16,020
going to be our our goal or the bar that

1527
01:08:16,020 --> 01:08:17,580
we've set

1528
01:08:17,580 --> 01:08:20,460
and then if we take a look down at these

1529
01:08:20,460 --> 01:08:22,560
bottom two rows you'll see these results

1530
01:08:22,560 --> 01:08:24,600
that I mentioned briefly from prior work

1531
01:08:24,600 --> 01:08:28,259
where we had these uh Network agnostic

1532
01:08:28,259 --> 01:08:30,600
SMR protocols that unfortunately fell a

1533
01:08:30,600 --> 01:08:32,640
little short of that bar uh you'll see

1534
01:08:32,640 --> 01:08:35,580
that in particular uh tardigrade which

1535
01:08:35,580 --> 01:08:38,520
is our adaptively secure protocol had n

1536
01:08:38,520 --> 01:08:41,279
to the fourth uh communication

1537
01:08:41,279 --> 01:08:43,560
complexity per batch of n transactions

1538
01:08:43,560 --> 01:08:46,380
which could be better and then you'll

1539
01:08:46,380 --> 01:08:49,560
see upgrade our second protocol uh

1540
01:08:49,560 --> 01:08:51,839
achieves security against a static

1541
01:08:51,839 --> 01:08:54,479
adversary and does a little better uh

1542
01:08:54,479 --> 01:08:58,198
amortized linear cost or cubic per batch

1543
01:08:58,198 --> 01:09:01,080
of N squared transactions but batches of

1544
01:09:01,080 --> 01:09:02,698
instrument transactions are quite large

1545
01:09:02,698 --> 01:09:04,799
and aren't going to be suitable for for

1546
01:09:04,799 --> 01:09:06,960
all use cases so we'd like to do a

1547
01:09:06,960 --> 01:09:09,479
little bit better if we can

1548
01:09:09,479 --> 01:09:11,238
foreign

1549
01:09:11,238 --> 01:09:14,640
so that brings us to this work where we

1550
01:09:14,640 --> 01:09:16,620
consider not only the network agnostic

1551
01:09:16,620 --> 01:09:19,500
world but also this sort of arbitrarily

1552
01:09:19,500 --> 01:09:22,198
changing Network world that I've just

1553
01:09:22,198 --> 01:09:25,439
that I've just mentioned and we're going

1554
01:09:25,439 --> 01:09:26,520
to

1555
01:09:26,520 --> 01:09:30,238
present two protocols update and Upstate

1556
01:09:30,238 --> 01:09:32,580
where update is our adaptively secure

1557
01:09:32,580 --> 01:09:35,939
protocol that gives us cubic uh

1558
01:09:35,939 --> 01:09:38,339
complexity for batches of n transactions

1559
01:09:38,339 --> 01:09:40,500
and then we're going to briefly talk

1560
01:09:40,500 --> 01:09:42,779
about Upstate which is a static version

1561
01:09:42,779 --> 01:09:46,020
uh with that nice linear this time for

1562
01:09:46,020 --> 01:09:49,319
batches of end transactions and the the

1563
01:09:49,319 --> 01:09:51,299
costs that we pay sort of as before is

1564
01:09:51,299 --> 01:09:52,738
this

1565
01:09:52,738 --> 01:09:53,399
um

1566
01:09:53,399 --> 01:09:55,739
is this almost optimal corruption

1567
01:09:55,739 --> 01:09:56,940
threshold

1568
01:09:56,940 --> 01:10:00,420
which is an open question to resolve

1569
01:10:00,420 --> 01:10:03,239
so let me quickly walk us through sort

1570
01:10:03,239 --> 01:10:04,800
of the roadmap of the rest of the talk

1571
01:10:04,800 --> 01:10:07,679
we're going to look at our adaptively

1572
01:10:07,679 --> 01:10:10,140
secure protocol update which has the

1573
01:10:10,140 --> 01:10:12,420
quadratic amortized communication

1574
01:10:12,420 --> 01:10:15,480
follow that with a quick look at Upstate

1575
01:10:15,480 --> 01:10:18,179
which is our statically secure SMR

1576
01:10:18,179 --> 01:10:20,400
protocol with linear amortized

1577
01:10:20,400 --> 01:10:22,199
communication

1578
01:10:22,199 --> 01:10:23,880
then we're going to take a bit of a

1579
01:10:23,880 --> 01:10:27,239
detour and start working in this new new

1580
01:10:27,239 --> 01:10:30,060
flavor of network agnostic model that I

1581
01:10:30,060 --> 01:10:31,380
that I mentioned

1582
01:10:31,380 --> 01:10:35,040
and then finally uh or sorry and that

1583
01:10:35,040 --> 01:10:38,400
will take us by way of a focal or

1584
01:10:38,400 --> 01:10:40,140
impossibility result of purely

1585
01:10:40,140 --> 01:10:42,120
asynchronous proactive secret sharing

1586
01:10:42,120 --> 01:10:43,380
with refresh

1587
01:10:43,380 --> 01:10:46,199
and that will motivate a slight

1588
01:10:46,199 --> 01:10:48,600
relaxation or a slight constraint that

1589
01:10:48,600 --> 01:10:51,360
we place on the adversary in order to

1590
01:10:51,360 --> 01:10:53,640
get sort of uh

1591
01:10:53,640 --> 01:10:55,860
the second best option or the next best

1592
01:10:55,860 --> 01:10:58,380
thing which is State machine replication

1593
01:10:58,380 --> 01:11:01,620
under those uh adaptive networks changes

1594
01:11:01,620 --> 01:11:03,239
but with a slightly constrained version

1595
01:11:03,239 --> 01:11:05,880
of a mobile adversary

1596
01:11:05,880 --> 01:11:07,800
and then finally I'll wrap up by just

1597
01:11:07,800 --> 01:11:10,380
mentioning a couple open problems

1598
01:11:10,380 --> 01:11:12,480
so we are here we've got some work to do

1599
01:11:12,480 --> 01:11:14,400
I see looking at my clock so I guess

1600
01:11:14,400 --> 01:11:16,080
we'll get moving

1601
01:11:16,080 --> 01:11:19,800
so just to quickly look at some uh model

1602
01:11:19,800 --> 01:11:24,239
and terminology that we'll need uh again

1603
01:11:24,239 --> 01:11:27,179
we have Byzantine faults where it's it's

1604
01:11:27,179 --> 01:11:30,600
bimodal or our binary depending on

1605
01:11:30,600 --> 01:11:32,520
the the state of the network or the mode

1606
01:11:32,520 --> 01:11:35,460
that the network is in and TS and ta can

1607
01:11:35,460 --> 01:11:37,679
be anything you like as long as two TS

1608
01:11:37,679 --> 01:11:41,040
plus ta is less than n and we at times

1609
01:11:41,040 --> 01:11:44,520
consider either an alternatively uh

1610
01:11:44,520 --> 01:11:47,520
adaptive or static adversary

1611
01:11:47,520 --> 01:11:50,640
so we have Atomic send operations which

1612
01:11:50,640 --> 01:11:52,860
uh you don't need to think too too much

1613
01:11:52,860 --> 01:11:54,840
about other than it just means the

1614
01:11:54,840 --> 01:11:57,239
adversary can't corrupt in the middle of

1615
01:11:57,239 --> 01:11:59,640
a multi-send

1616
01:11:59,640 --> 01:12:02,159
and then we're also throughout going to

1617
01:12:02,159 --> 01:12:04,020
assume that the parties have access to

1618
01:12:04,020 --> 01:12:06,000
public key infrastructure in particular

1619
01:12:06,000 --> 01:12:08,580
for a threshold signature scheme and

1620
01:12:08,580 --> 01:12:10,679
threshold encryption scheme

1621
01:12:10,679 --> 01:12:14,040
set up by some trusted dealer

1622
01:12:14,040 --> 01:12:16,860
and this is going to take us through our

1623
01:12:16,860 --> 01:12:20,219
protocols update and upstate

1624
01:12:20,219 --> 01:12:24,360
okay so our basic recipe for update uh

1625
01:12:24,360 --> 01:12:26,719
will look a bit familiar

1626
01:12:26,719 --> 01:12:28,440
to

1627
01:12:28,440 --> 01:12:30,300
those of you who are familiar with honey

1628
01:12:30,300 --> 01:12:33,659
badger bft and related protocols uh and

1629
01:12:33,659 --> 01:12:35,940
might look very familiar to any of you

1630
01:12:35,940 --> 01:12:38,159
who may have somehow or another seen

1631
01:12:38,159 --> 01:12:41,100
tardigrade our protocol from prior work

1632
01:12:41,100 --> 01:12:43,219
so each party

1633
01:12:43,219 --> 01:12:46,500
starts an Epoch at a at a fixed local

1634
01:12:46,500 --> 01:12:47,840
time

1635
01:12:47,840 --> 01:12:50,760
and the first thing that they do is they

1636
01:12:50,760 --> 01:12:52,320
take their buffer and they're going to

1637
01:12:52,320 --> 01:12:55,739
choose a random assortment of things in

1638
01:12:55,739 --> 01:12:57,960
their buffer and threshold encrypt them

1639
01:12:57,960 --> 01:12:59,880
and the reason for this is essentially

1640
01:12:59,880 --> 01:13:02,520
just so that the the specific

1641
01:13:02,520 --> 01:13:04,620
transactions chosen by each party are

1642
01:13:04,620 --> 01:13:07,620
hidden until until the very end all the

1643
01:13:07,620 --> 01:13:09,480
way up right where you see decryption we

1644
01:13:09,480 --> 01:13:11,280
want to just hide the the details of

1645
01:13:11,280 --> 01:13:12,780
which transactions were or weren't

1646
01:13:12,780 --> 01:13:14,460
chosen until the last possible second

1647
01:13:14,460 --> 01:13:15,540
when

1648
01:13:15,540 --> 01:13:17,760
the output has already been determined

1649
01:13:17,760 --> 01:13:20,520
that just sort of limits an adversary's

1650
01:13:20,520 --> 01:13:23,400
ability to manipulate whose transactions

1651
01:13:23,400 --> 01:13:25,500
are or aren't getting included this is a

1652
01:13:25,500 --> 01:13:26,820
relatively

1653
01:13:26,820 --> 01:13:28,380
standard known technique in the

1654
01:13:28,380 --> 01:13:30,020
literature

1655
01:13:30,020 --> 01:13:33,540
so the next thing that happens is that

1656
01:13:33,540 --> 01:13:38,580
parties sort of uh take these uh

1657
01:13:38,580 --> 01:13:40,380
take these samples that they've

1658
01:13:40,380 --> 01:13:42,300
encrypted and spread them around to all

1659
01:13:42,300 --> 01:13:44,460
of their friends multicast them and

1660
01:13:44,460 --> 01:13:46,580
assemble them into what we call

1661
01:13:46,580 --> 01:13:49,380
pre-blocks which is just sort of a fancy

1662
01:13:49,380 --> 01:13:51,920
word for an inter an intermediate value

1663
01:13:51,920 --> 01:13:55,140
of a bunch of people's inputs

1664
01:13:55,140 --> 01:13:58,440
that then gets put into sort of our

1665
01:13:58,440 --> 01:14:00,060
first major building block which is

1666
01:14:00,060 --> 01:14:01,920
called block agreement I'm not going to

1667
01:14:01,920 --> 01:14:03,920
get into all the details of that here

1668
01:14:03,920 --> 01:14:08,460
but uh I'll refer you to our previous

1669
01:14:08,460 --> 01:14:12,360
paper uh where we present tardigrade for

1670
01:14:12,360 --> 01:14:14,820
the details of that protocol essentially

1671
01:14:14,820 --> 01:14:17,760
if if you like you can think of it as a

1672
01:14:17,760 --> 01:14:20,100
a form of multi-valued

1673
01:14:20,100 --> 01:14:22,260
uh Byzantine agreement but for our

1674
01:14:22,260 --> 01:14:24,540
purposes it's just sort of the

1675
01:14:24,540 --> 01:14:27,239
synchronous building block it doesn't

1676
01:14:27,239 --> 01:14:29,040
necessarily do anything if the network

1677
01:14:29,040 --> 01:14:32,340
is asynchronous but it works very well

1678
01:14:32,340 --> 01:14:34,500
if all of the parties if if the network

1679
01:14:34,500 --> 01:14:37,880
happens to be synchronous

1680
01:14:38,460 --> 01:14:41,940
so let's see and then sort of our second

1681
01:14:41,940 --> 01:14:44,040
our second major building block is this

1682
01:14:44,040 --> 01:14:46,020
asynchronous common subset building

1683
01:14:46,020 --> 01:14:47,300
block

1684
01:14:47,300 --> 01:14:51,540
uh which we do a slight uh tweak or

1685
01:14:51,540 --> 01:14:53,280
modification to sort of the standard

1686
01:14:53,280 --> 01:14:55,080
recipe that uses error correcting codes

1687
01:14:55,080 --> 01:14:58,500
I think that's a pretty neat detail that

1688
01:14:58,500 --> 01:15:00,239
I I encourage you to check out in the

1689
01:15:00,239 --> 01:15:03,120
paper if you have the time and so the

1690
01:15:03,120 --> 01:15:05,940
the main idea here is that

1691
01:15:05,940 --> 01:15:09,540
uh whereas the block agreement is the

1692
01:15:09,540 --> 01:15:11,940
hero in the synchronous Network the

1693
01:15:11,940 --> 01:15:13,679
asynchronous common subset as you might

1694
01:15:13,679 --> 01:15:15,780
guess from the name is the hero if the

1695
01:15:15,780 --> 01:15:18,120
network happens to be asynchronous and

1696
01:15:18,120 --> 01:15:20,760
in either case in either setting without

1697
01:15:20,760 --> 01:15:22,739
knowing which setting we're in one of

1698
01:15:22,739 --> 01:15:24,239
them is going to do the heavy lifting

1699
01:15:24,239 --> 01:15:26,040
and the other one just has to stay out

1700
01:15:26,040 --> 01:15:28,260
of the way essentially

1701
01:15:28,260 --> 01:15:30,659
so I'll move through these in the

1702
01:15:30,659 --> 01:15:33,420
interest of time

1703
01:15:33,420 --> 01:15:35,880
so this is the the main idea behind our

1704
01:15:35,880 --> 01:15:38,880
Network agnostic SMR protocol with with

1705
01:15:38,880 --> 01:15:41,100
better efficiency

1706
01:15:41,100 --> 01:15:43,140
and we can get even better efficiency

1707
01:15:43,140 --> 01:15:45,120
versus static adversary

1708
01:15:45,120 --> 01:15:47,460
uh by using

1709
01:15:47,460 --> 01:15:49,920
a fairly a fairly common trick in the

1710
01:15:49,920 --> 01:15:51,659
literature which is to use techniques to

1711
01:15:51,659 --> 01:15:53,940
reduce the communication complexity or

1712
01:15:53,940 --> 01:15:55,800
sorry use committees to reduce the

1713
01:15:55,800 --> 01:15:57,840
communication complexity at the cost of

1714
01:15:57,840 --> 01:16:00,600
an Epsilon Factor loss in the corruption

1715
01:16:00,600 --> 01:16:03,020
threshold

1716
01:16:03,420 --> 01:16:06,960
okay so we are here and as I said I have

1717
01:16:06,960 --> 01:16:08,340
some more work to do

1718
01:16:08,340 --> 01:16:09,960
so

1719
01:16:09,960 --> 01:16:13,500
as I sort of alluded to earlier this uh

1720
01:16:13,500 --> 01:16:14,940
this model

1721
01:16:14,940 --> 01:16:18,360
where there's a fixed Network Mode

1722
01:16:18,360 --> 01:16:19,800
throughout the whole lifetime of the

1723
01:16:19,800 --> 01:16:21,480
protocol is a bit unsatisfying

1724
01:16:21,480 --> 01:16:23,460
especially when we think about a state

1725
01:16:23,460 --> 01:16:24,960
machine replication protocol that's

1726
01:16:24,960 --> 01:16:26,340
going to run for a large number of

1727
01:16:26,340 --> 01:16:30,960
epochs this motivates considering uh

1728
01:16:30,960 --> 01:16:37,080
a a mobile adversary uh

1729
01:16:38,100 --> 01:16:39,300
so

1730
01:16:39,300 --> 01:16:40,739
what we're going to do in order to

1731
01:16:40,739 --> 01:16:43,280
accommodate that mobile adversary is

1732
01:16:43,280 --> 01:16:46,140
assume that there is some code in

1733
01:16:46,140 --> 01:16:48,540
untamperable memory that restarts and

1734
01:16:48,540 --> 01:16:50,400
forcibly flushes out the adversary

1735
01:16:50,400 --> 01:16:52,380
because essentially

1736
01:16:52,380 --> 01:16:54,659
uh if we don't have something like this

1737
01:16:54,659 --> 01:16:56,520
in our model we're kind of stuck because

1738
01:16:56,520 --> 01:16:59,400
if we're ever in the synchronous setting

1739
01:16:59,400 --> 01:17:02,940
and the adversary corrupts more than the

1740
01:17:02,940 --> 01:17:05,940
N over three number of parties which is

1741
01:17:05,940 --> 01:17:07,800
sort of an important and interesting

1742
01:17:07,800 --> 01:17:09,659
part of our model and part of this part

1743
01:17:09,659 --> 01:17:10,860
of this problem

1744
01:17:10,860 --> 01:17:12,300
then

1745
01:17:12,300 --> 01:17:15,060
if the if the network ever in the future

1746
01:17:15,060 --> 01:17:17,040
switches back to asynchronous we know

1747
01:17:17,040 --> 01:17:19,199
that we run into that hard barrier that

1748
01:17:19,199 --> 01:17:21,239
impossibility result I mentioned earlier

1749
01:17:21,239 --> 01:17:23,880
so somehow our model needs to include

1750
01:17:23,880 --> 01:17:25,620
this reboot in order for us to get

1751
01:17:25,620 --> 01:17:27,980
anywhere

1752
01:17:28,140 --> 01:17:31,140
so is sort of is that enough say if

1753
01:17:31,140 --> 01:17:32,640
enough parties flush out the adversary

1754
01:17:32,640 --> 01:17:34,440
before a network change from synchronous

1755
01:17:34,440 --> 01:17:37,260
to asynchronous do does does that just

1756
01:17:37,260 --> 01:17:39,420
give us security and unfortunately the

1757
01:17:39,420 --> 01:17:41,880
answer is no because rebooting doesn't

1758
01:17:41,880 --> 01:17:44,400
erase our rebooted party is internal

1759
01:17:44,400 --> 01:17:46,800
state from The adversary's View and so

1760
01:17:46,800 --> 01:17:49,620
without somehow refreshing that internal

1761
01:17:49,620 --> 01:17:53,580
State uh bootstrapping the the party who

1762
01:17:53,580 --> 01:17:55,199
was corrupted back into the protocol

1763
01:17:55,199 --> 01:17:57,540
that rebooted party is going to remain

1764
01:17:57,540 --> 01:18:00,300
passively corrupted or exposed

1765
01:18:00,300 --> 01:18:04,040
so the protocol uses threshold schemes

1766
01:18:04,040 --> 01:18:07,020
uh as as we mentioned the protocol uses

1767
01:18:07,020 --> 01:18:09,000
threshold schemes and so in particular

1768
01:18:09,000 --> 01:18:11,520
the problem is that the adversary can

1769
01:18:11,520 --> 01:18:13,739
just continue hopping between parties

1770
01:18:13,739 --> 01:18:16,739
and never com uh never corrupting more

1771
01:18:16,739 --> 01:18:18,840
than the allowed number of parties at

1772
01:18:18,840 --> 01:18:21,420
any given time but it sort of just keeps

1773
01:18:21,420 --> 01:18:24,420
collecting keys until it has enough to

1774
01:18:24,420 --> 01:18:27,360
to cause problems and so we're going to

1775
01:18:27,360 --> 01:18:30,000
need to deal with that if we want if we

1776
01:18:30,000 --> 01:18:32,280
want any sort of interesting non-trivial

1777
01:18:32,280 --> 01:18:34,199
result

1778
01:18:34,199 --> 01:18:37,080
and along the way to to finding this

1779
01:18:37,080 --> 01:18:39,179
sort of sensible relaxation we proved

1780
01:18:39,179 --> 01:18:41,340
this folklore result the impossibility

1781
01:18:41,340 --> 01:18:43,440
of asynchronous proactive secret sharing

1782
01:18:43,440 --> 01:18:45,600
with refresh it turns out to be very

1783
01:18:45,600 --> 01:18:48,020
very sensitive to the exact definition

1784
01:18:48,020 --> 01:18:51,060
of what you mean by asynchronous

1785
01:18:51,060 --> 01:18:53,159
proactive secret sharing with refresh

1786
01:18:53,159 --> 01:18:55,980
and uh so I won't get into all of that

1787
01:18:55,980 --> 01:18:58,320
here but I think it is a neat a neat

1788
01:18:58,320 --> 01:18:59,940
thing to see you formally you've done

1789
01:18:59,940 --> 01:19:01,440
out and so I encourage you to look at

1790
01:19:01,440 --> 01:19:03,780
that in the paper if you're interested

1791
01:19:03,780 --> 01:19:06,780
and that impossibility then translates

1792
01:19:06,780 --> 01:19:09,120
directly to network agnostic so again

1793
01:19:09,120 --> 01:19:11,760
just the takeaway here is we can't get

1794
01:19:11,760 --> 01:19:13,620
sort of that nice natural definition of

1795
01:19:13,620 --> 01:19:15,540
security that we would want and so that

1796
01:19:15,540 --> 01:19:17,760
motivates this relaxation that I'm about

1797
01:19:17,760 --> 01:19:19,440
to tell you about

1798
01:19:19,440 --> 01:19:21,900
and the key relaxation here is we

1799
01:19:21,900 --> 01:19:24,000
consider a limited mobile adversary

1800
01:19:24,000 --> 01:19:27,060
where they can only hop around within a

1801
01:19:27,060 --> 01:19:31,560
set of at most TS parties so it's sort

1802
01:19:31,560 --> 01:19:33,659
of like initially they can hop to

1803
01:19:33,659 --> 01:19:35,940
whoever they want but eventually they've

1804
01:19:35,940 --> 01:19:39,420
sort of uh determined that set or

1805
01:19:39,420 --> 01:19:41,880
they've boxed themselves into that set

1806
01:19:41,880 --> 01:19:45,540
and so this is this is more general or

1807
01:19:45,540 --> 01:19:48,300
more powerful than than we originally

1808
01:19:48,300 --> 01:19:49,640
considered

1809
01:19:49,640 --> 01:19:53,640
but uh as we said we can't really def

1810
01:19:53,640 --> 01:19:55,860
hope to get anywhere against a fully

1811
01:19:55,860 --> 01:19:58,140
mobile adversary and we found that this

1812
01:19:58,140 --> 01:20:00,239
is this is sort of an interesting

1813
01:20:00,239 --> 01:20:03,678
non-trivial relaxation

1814
01:20:04,140 --> 01:20:06,060
the rest of the details of the model are

1815
01:20:06,060 --> 01:20:07,739
are largely the same except for that

1816
01:20:07,739 --> 01:20:10,639
reboot capability

1817
01:20:12,840 --> 01:20:16,140
uh yeah and so it turns out that we

1818
01:20:16,140 --> 01:20:18,060
really only need minor changes to the

1819
01:20:18,060 --> 01:20:20,159
protocol that I already showed you in

1820
01:20:20,159 --> 01:20:23,100
order to get this nice new definition of

1821
01:20:23,100 --> 01:20:25,620
security the main ideas just say really

1822
01:20:25,620 --> 01:20:27,800
quickly are to use an asynchronous

1823
01:20:27,800 --> 01:20:30,360
Byzantine agreement as a building block

1824
01:20:30,360 --> 01:20:33,960
with a higher internal threshold uh for

1825
01:20:33,960 --> 01:20:35,400
example here's one in the literature

1826
01:20:35,400 --> 01:20:37,320
from that also happens to be our prior

1827
01:20:37,320 --> 01:20:39,840
work and then finally we use a modified

1828
01:20:39,840 --> 01:20:42,600
ACS with error correcting codes that

1829
01:20:42,600 --> 01:20:44,040
help us sort of get around the fact that

1830
01:20:44,040 --> 01:20:46,860
we might have fewer fewer shares to

1831
01:20:46,860 --> 01:20:48,659
Recon to reconstruct than we would

1832
01:20:48,659 --> 01:20:51,620
otherwise hope

1833
01:20:51,780 --> 01:20:54,360
so finally I'll just leave these up

1834
01:20:54,360 --> 01:20:56,640
because I think I am properly out of

1835
01:20:56,640 --> 01:20:59,040
time now uh thank you very much here's

1836
01:20:59,040 --> 01:21:01,080
the link to our paper questions comments

1837
01:21:01,080 --> 01:21:03,000
come compliments and complaints can be

1838
01:21:03,000 --> 01:21:05,219
directed to my email which is here on

1839
01:21:05,219 --> 01:21:07,320
your screen so thank you very much I'll

1840
01:21:07,320 --> 01:21:09,900
wrap it up there

1841
01:21:09,900 --> 01:21:10,780
thanks a lot

1842
01:21:10,780 --> 01:21:13,910
[Applause]

1843
01:21:14,040 --> 01:21:16,080
we actually would have time for a quick

1844
01:21:16,080 --> 01:21:19,760
question if someone has one

1845
01:21:19,800 --> 01:21:23,820
I don't see any then uh thanks a lot and

1846
01:21:23,820 --> 01:21:26,400
uh the general chairs have an

1847
01:21:26,400 --> 01:21:27,960
announcement

1848
01:21:27,960 --> 01:21:32,159
uh yeah we regret to announce that uh Mr

1849
01:21:32,159 --> 01:21:37,020
Edward Hulk has tested positive and what

1850
01:21:37,020 --> 01:21:40,020
this does this mean for to you and

1851
01:21:40,020 --> 01:21:43,500
basically nothing unless you've been in

1852
01:21:43,500 --> 01:21:46,460
close contact with him

