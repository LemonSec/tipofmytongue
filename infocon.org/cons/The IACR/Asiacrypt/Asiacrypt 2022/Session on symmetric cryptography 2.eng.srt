1
00:00:01,100 --> 00:00:04,460
are you okay

2
00:00:45,440 --> 00:00:49,860
so welcome to question on film metric

3
00:00:49,860 --> 00:00:53,160
literally two so there will be three

4
00:00:53,160 --> 00:00:55,320
talks in session

5
00:00:55,320 --> 00:00:59,460
and the first presentation is a

6
00:00:59,460 --> 00:01:02,039
ability or strong credit foundation

7
00:01:02,039 --> 00:01:06,119
without initial barriers by

8
00:01:06,119 --> 00:01:10,860
building the graphy and automatic so we

9
00:01:10,860 --> 00:01:13,619
thought okay

10
00:01:13,619 --> 00:01:15,060
hello okay

11
00:01:15,060 --> 00:01:16,979
so thanks for the introduction

12
00:01:16,979 --> 00:01:19,500
I'm going to start this presentation

13
00:01:19,500 --> 00:01:22,320
with a bit of overview and motivation of

14
00:01:22,320 --> 00:01:23,720
this work

15
00:01:23,720 --> 00:01:26,640
so we know that if you apply a donkey

16
00:01:26,640 --> 00:01:29,340
permutation on the concatenation of an

17
00:01:29,340 --> 00:01:31,920
input value and a fixed initial value

18
00:01:31,920 --> 00:01:33,979
the function that we obtain is

19
00:01:33,979 --> 00:01:36,240
differentiable from a random function up

20
00:01:36,240 --> 00:01:38,939
to a certain bound

21
00:01:38,939 --> 00:01:41,040
so in this paper we proved that almost

22
00:01:41,040 --> 00:01:43,979
the same bound both if the initial value

23
00:01:43,979 --> 00:01:46,560
is replaced by randomized value

24
00:01:46,560 --> 00:01:48,240
and then we propose some concrete

25
00:01:48,240 --> 00:01:50,100
application in the context of parallel

26
00:01:50,100 --> 00:01:54,000
variable land digestive generation

27
00:01:54,000 --> 00:01:56,340
so the organization of this presentation

28
00:01:56,340 --> 00:01:58,200
is exactly like this one so I'm going to

29
00:01:58,200 --> 00:02:00,540
start with some preliminary about how to

30
00:02:00,540 --> 00:02:02,820
set up a random function from random

31
00:02:02,820 --> 00:02:03,899
permutation

32
00:02:03,899 --> 00:02:06,899
then I show our result of this paper and

33
00:02:06,899 --> 00:02:08,880
finally I consider I propose the

34
00:02:08,880 --> 00:02:11,660
concrete application

35
00:02:11,900 --> 00:02:15,140
so first of all many cmatic crypto

36
00:02:15,140 --> 00:02:17,160
Primitives are based on public

37
00:02:17,160 --> 00:02:20,160
implementation or public function just

38
00:02:20,160 --> 00:02:22,379
to give some example the even muscle

39
00:02:22,379 --> 00:02:23,940
reconstruction is based on a public

40
00:02:23,940 --> 00:02:26,780
permutation fee so we take an input X

41
00:02:26,780 --> 00:02:30,120
and the output is defined as the sum of

42
00:02:30,120 --> 00:02:32,340
the key plus implementation applied to

43
00:02:32,340 --> 00:02:34,920
the input X plus the key or for example

44
00:02:34,920 --> 00:02:38,760
H function make use of uh

45
00:02:38,760 --> 00:02:41,160
a random function of a public function

46
00:02:41,160 --> 00:02:43,019
for example the Mercury number

47
00:02:43,019 --> 00:02:44,940
construction is instantiated by a public

48
00:02:44,940 --> 00:02:47,519
compression function f or the sponges

49
00:02:47,519 --> 00:02:49,680
function can be instantiated either by a

50
00:02:49,680 --> 00:02:52,680
public limitation or a public function

51
00:02:52,680 --> 00:02:53,819
foreign

52
00:02:53,819 --> 00:02:55,920
now we know how to construct a public

53
00:02:55,920 --> 00:02:58,739
permutation B with good statistical and

54
00:02:58,739 --> 00:03:01,019
or electrified properties for example we

55
00:03:01,019 --> 00:03:03,720
can make use of the SPN strategy and we

56
00:03:03,720 --> 00:03:05,340
can choose a good as box a good linear

57
00:03:05,340 --> 00:03:06,840
laser and so on

58
00:03:06,840 --> 00:03:09,780
the same is not true for the case of

59
00:03:09,780 --> 00:03:12,060
public function so in this case what we

60
00:03:12,060 --> 00:03:13,800
do is to take a public permutation and

61
00:03:13,800 --> 00:03:16,260
to turn a public limitation into a

62
00:03:16,260 --> 00:03:18,540
public function

63
00:03:18,540 --> 00:03:20,519
for example consider the case in which

64
00:03:20,519 --> 00:03:23,220
we have two permutation P0 and P1 that

65
00:03:23,220 --> 00:03:26,220
are defined over ebits we can decide we

66
00:03:26,220 --> 00:03:29,700
can Define the sum of permutation as the

67
00:03:29,700 --> 00:03:31,200
sum of the two permutation applied to

68
00:03:31,200 --> 00:03:32,459
the input X

69
00:03:32,459 --> 00:03:35,040
and this function is shown to be is

70
00:03:35,040 --> 00:03:36,420
proved to be indifferentiable from a

71
00:03:36,420 --> 00:03:40,440
random function up to to the B queries

72
00:03:40,440 --> 00:03:42,659
a similar result holds if we have a

73
00:03:42,659 --> 00:03:44,519
single public permutation so in this

74
00:03:44,519 --> 00:03:46,739
case we lose one bit in the in the

75
00:03:46,739 --> 00:03:49,019
domain so we we have the first public

76
00:03:49,019 --> 00:03:51,540
limitation is applied on X concatenated

77
00:03:51,540 --> 00:03:53,519
with zero plus the Second Chance the

78
00:03:53,519 --> 00:03:55,080
same implementation applied to x

79
00:03:55,080 --> 00:03:58,080
concatenated with one

80
00:03:58,080 --> 00:03:59,760
now if you have a single permutation a

81
00:03:59,760 --> 00:04:02,580
single permutation we can also Define

82
00:04:02,580 --> 00:04:04,620
um other random function for example the

83
00:04:04,620 --> 00:04:07,080
truncated function

84
00:04:07,080 --> 00:04:09,060
uh in this case we have a function that

85
00:04:09,060 --> 00:04:11,700
takes an input B minus M bits and return

86
00:04:11,700 --> 00:04:13,860
and bits and is defined in this way so

87
00:04:13,860 --> 00:04:15,599
we take the concatenation of the initial

88
00:04:15,599 --> 00:04:18,060
value the input text we apply the

89
00:04:18,060 --> 00:04:21,060
permutation and then finally we truncate

90
00:04:21,060 --> 00:04:24,000
so the initial value is of 10 bits and

91
00:04:24,000 --> 00:04:26,400
we determination is of n bit so we take

92
00:04:26,400 --> 00:04:29,820
a and last one's bit of the output of

93
00:04:29,820 --> 00:04:32,599
the permutation p

94
00:04:34,139 --> 00:04:35,639
um now the security of this construction

95
00:04:35,639 --> 00:04:38,100
has been studied in the digital tour for

96
00:04:38,100 --> 00:04:40,380
example we have a first result by the

97
00:04:40,380 --> 00:04:43,680
digital at FSC 2009 and we have a more

98
00:04:43,680 --> 00:04:45,840
recent result by Cherry to get issue

99
00:04:45,840 --> 00:04:49,160
2019 that proved that this function is

100
00:04:49,160 --> 00:04:51,060
indifferentiable from a random function

101
00:04:51,060 --> 00:04:54,720
up to this number of queries

102
00:04:54,720 --> 00:04:57,300
and what is important to keep in mind is

103
00:04:57,300 --> 00:04:59,720
that

104
00:05:00,660 --> 00:05:03,419
is minimum we have three argument and

105
00:05:03,419 --> 00:05:05,220
this last one is to the power of M where

106
00:05:05,220 --> 00:05:08,960
m is the size of the initial value

107
00:05:09,240 --> 00:05:10,919
so what does it mean so the initial

108
00:05:10,919 --> 00:05:12,060
value is crucial for the

109
00:05:12,060 --> 00:05:14,220
indifferentiability so if m is equal to

110
00:05:14,220 --> 00:05:17,160
zero then we can easily distinguish the

111
00:05:17,160 --> 00:05:19,139
to negative permutation from a random

112
00:05:19,139 --> 00:05:21,320
function and the reason is very simple

113
00:05:21,320 --> 00:05:25,320
uh okay if we take this bound we have to

114
00:05:25,320 --> 00:05:27,360
the power of zero which is one so one

115
00:05:27,360 --> 00:05:29,340
query is sufficient to distinguish these

116
00:05:29,340 --> 00:05:31,698
two cases

117
00:05:31,979 --> 00:05:34,919
and it is very simple so we have we take

118
00:05:34,919 --> 00:05:38,880
Y which is a random argument of BBS we

119
00:05:38,880 --> 00:05:41,039
apply the investment mutation B and we

120
00:05:41,039 --> 00:05:43,860
get X and then we do our local query on

121
00:05:43,860 --> 00:05:48,300
X and if this inequality is not

122
00:05:48,300 --> 00:05:51,419
satisfied then we know that the Oracle

123
00:05:51,419 --> 00:05:53,280
is the random function with probability

124
00:05:53,280 --> 00:05:55,758
one

125
00:05:55,800 --> 00:05:57,539
so the initial value is crucial but at

126
00:05:57,539 --> 00:06:00,300
the same time is over here in the sense

127
00:06:00,300 --> 00:06:02,340
that there are some H function which are

128
00:06:02,340 --> 00:06:04,259
instantiated by a total permutation with

129
00:06:04,259 --> 00:06:07,320
m equal to zero let us C secure

130
00:06:07,320 --> 00:06:09,240
for example this is a sponge hash

131
00:06:09,240 --> 00:06:10,199
function

132
00:06:10,199 --> 00:06:12,120
so at the beginning here we have an

133
00:06:12,120 --> 00:06:14,520
initial value which is fixed but in all

134
00:06:14,520 --> 00:06:17,280
the other cases this initial value so

135
00:06:17,280 --> 00:06:19,080
the part that corresponds to the inner

136
00:06:19,080 --> 00:06:21,539
part is not fixed and this function is

137
00:06:21,539 --> 00:06:23,699
secure so the question point is that the

138
00:06:23,699 --> 00:06:25,620
attacker doesn't have access to the

139
00:06:25,620 --> 00:06:27,060
inner part you know it works with the

140
00:06:27,060 --> 00:06:28,500
outer part

141
00:06:28,500 --> 00:06:30,180
so there are some cases where we don't

142
00:06:30,180 --> 00:06:32,400
need a fixed initial value we can have

143
00:06:32,400 --> 00:06:35,100
something a bit more uh a weaker

144
00:06:35,100 --> 00:06:37,139
assumption

145
00:06:37,139 --> 00:06:39,000
so this exactly the idea that we have in

146
00:06:39,000 --> 00:06:40,800
this paper so the idea is to replace

147
00:06:40,800 --> 00:06:42,600
this fixed initial value with a

148
00:06:42,600 --> 00:06:44,940
randomized value

149
00:06:44,940 --> 00:06:47,699
so we start from these construction and

150
00:06:47,699 --> 00:06:49,860
we replace the initial value with the

151
00:06:49,860 --> 00:06:52,919
output of our H function apply to an

152
00:06:52,919 --> 00:06:56,759
input M and in this case the H function

153
00:06:56,759 --> 00:06:59,460
takes a message of arbitrary length and

154
00:06:59,460 --> 00:07:02,539
return M bits

155
00:07:03,600 --> 00:07:05,100
now in the paper we prove the security

156
00:07:05,100 --> 00:07:07,560
of this construction and we show that if

157
00:07:07,560 --> 00:07:10,560
H is a random Oracle it P is a random

158
00:07:10,560 --> 00:07:12,660
permutation then this construction is

159
00:07:12,660 --> 00:07:14,639
indifferentiable from a random Oracle up

160
00:07:14,639 --> 00:07:18,600
to this number of queries

161
00:07:18,600 --> 00:07:20,280
so just to better understand this bound

162
00:07:20,280 --> 00:07:22,919
so if you want a bit of security we need

163
00:07:22,919 --> 00:07:26,099
that m is slightly bigger than 2 times K

164
00:07:26,099 --> 00:07:29,220
so m is the size of the output of the H

165
00:07:29,220 --> 00:07:32,580
function MB which is the size of the

166
00:07:32,580 --> 00:07:34,500
permutation must satisfy these

167
00:07:34,500 --> 00:07:37,500
inequality

168
00:07:37,860 --> 00:07:40,080
now I'm not going into to into the

169
00:07:40,080 --> 00:07:43,319
details of the proof but the idea is to

170
00:07:43,319 --> 00:07:45,479
use the indifferentiable model so we

171
00:07:45,479 --> 00:07:47,400
have a distinguisher and we have two

172
00:07:47,400 --> 00:07:48,360
words

173
00:07:48,360 --> 00:07:51,840
uh one is the word of the random

174
00:07:51,840 --> 00:07:53,819
randomized truncation function and the

175
00:07:53,819 --> 00:07:55,380
other one is the one of the random

176
00:07:55,380 --> 00:07:57,180
Oracle and the distinguisher want to

177
00:07:57,180 --> 00:07:59,340
distinguish between these two words now

178
00:07:59,340 --> 00:08:01,800
in this word we also have the H function

179
00:08:01,800 --> 00:08:02,880
and implementation because the

180
00:08:02,880 --> 00:08:04,620
randomized location function is defined

181
00:08:04,620 --> 00:08:06,419
uh via the ash function and

182
00:08:06,419 --> 00:08:07,979
implementation

183
00:08:07,979 --> 00:08:11,900
and obviously in order to avoid previous

184
00:08:11,900 --> 00:08:14,340
pivot distinction we need to have

185
00:08:14,340 --> 00:08:16,259
simulators of the H function and of the

186
00:08:16,259 --> 00:08:18,419
permutation in the forward and in this

187
00:08:18,419 --> 00:08:20,580
in the inverse Direction in this world

188
00:08:20,580 --> 00:08:22,139
now the distinguisher can create

189
00:08:22,139 --> 00:08:24,300
everything in this case the randomized

190
00:08:24,300 --> 00:08:26,460
location function can create the hash

191
00:08:26,460 --> 00:08:28,080
function and implementation and in this

192
00:08:28,080 --> 00:08:30,840
case the simulator create the random

193
00:08:30,840 --> 00:08:33,020
model

194
00:08:33,599 --> 00:08:35,820
so the details are in the paper as you

195
00:08:35,820 --> 00:08:37,380
can imagine the strategy of the proof is

196
00:08:37,380 --> 00:08:39,899
similar to the one proposed by chayote

197
00:08:39,899 --> 00:08:42,659
at HQ 2019 but there are some project

198
00:08:42,659 --> 00:08:44,580
differences and if you are interested on

199
00:08:44,580 --> 00:08:47,240
them just have a look at the paper

200
00:08:47,240 --> 00:08:50,279
in particular the main difference so if

201
00:08:50,279 --> 00:08:52,320
you can have a look to the bound that we

202
00:08:52,320 --> 00:08:54,420
can get from the from the location

203
00:08:54,420 --> 00:08:55,860
function and the randomized location

204
00:08:55,860 --> 00:08:58,640
function the only difference is about is

205
00:08:58,640 --> 00:09:01,800
last term and the reason of this is that

206
00:09:01,800 --> 00:09:03,959
in our case we can have a collision at

207
00:09:03,959 --> 00:09:05,880
the output of the hash function and so

208
00:09:05,880 --> 00:09:10,160
that's the reason of these factors too

209
00:09:12,080 --> 00:09:16,500
now possible application is the parallel

210
00:09:16,500 --> 00:09:18,959
digest Generation

211
00:09:18,959 --> 00:09:20,640
Um so if you want to set up a h function

212
00:09:20,640 --> 00:09:22,380
we usually have two possible

213
00:09:22,380 --> 00:09:24,360
construction one is the micro dump

214
00:09:24,360 --> 00:09:26,160
construction and the other one is the

215
00:09:26,160 --> 00:09:28,440
sponge Construction

216
00:09:28,440 --> 00:09:32,820
and in both cases we don't have so the

217
00:09:32,820 --> 00:09:36,260
squeezing part is not uh

218
00:09:36,300 --> 00:09:39,120
is not done in parallel so in particular

219
00:09:39,120 --> 00:09:40,980
in the microdermal construction we

220
00:09:40,980 --> 00:09:44,040
output the fixed size digest by using

221
00:09:44,040 --> 00:09:46,019
this process in the sponge construction

222
00:09:46,019 --> 00:09:49,320
we allow for advertising size output but

223
00:09:49,320 --> 00:09:53,459
the output generation is sequential

224
00:09:53,459 --> 00:09:56,480
and in many cases we prefer to have a

225
00:09:56,480 --> 00:09:59,820
prior digest generation because in

226
00:09:59,820 --> 00:10:02,760
modern CPU working in parallel is faster

227
00:10:02,760 --> 00:10:04,920
than working sequentially

228
00:10:04,920 --> 00:10:08,160
now in the case of prf this problem was

229
00:10:08,160 --> 00:10:09,660
solved with the following construction

230
00:10:09,660 --> 00:10:12,600
proposed by Berton Neto that was 2017

231
00:10:12,600 --> 00:10:15,180
and for the case of Ash function we

232
00:10:15,180 --> 00:10:16,620
actually already have a solution and the

233
00:10:16,620 --> 00:10:18,540
solution is the mass generation

234
00:10:18,540 --> 00:10:20,760
functions

235
00:10:20,760 --> 00:10:22,740
so there are already some MGF

236
00:10:22,740 --> 00:10:24,300
construction indicator

237
00:10:24,300 --> 00:10:26,640
in this paper we propose a new MGF

238
00:10:26,640 --> 00:10:28,680
construction which is which is called

239
00:10:28,680 --> 00:10:31,740
Cascade MGF and it is based on these

240
00:10:31,740 --> 00:10:34,620
randomized location function

241
00:10:34,620 --> 00:10:35,279
um

242
00:10:35,279 --> 00:10:37,800
so it satisfy the goal to extend any

243
00:10:37,800 --> 00:10:40,140
Edge function into a parallel extendable

244
00:10:40,140 --> 00:10:42,540
out function that generate arbiting size

245
00:10:42,540 --> 00:10:44,959
output

246
00:10:45,180 --> 00:10:46,980
so the definition is very simple we have

247
00:10:46,980 --> 00:10:50,760
a h function that returns and bits in

248
00:10:50,760 --> 00:10:52,680
output and the permutation that works of

249
00:10:52,680 --> 00:10:54,360
the BBS

250
00:10:54,360 --> 00:10:57,240
and the Cascade MGF is simply defined as

251
00:10:57,240 --> 00:10:58,980
the randomized location function applied

252
00:10:58,980 --> 00:11:02,220
to the message and to an index I

253
00:11:02,220 --> 00:11:05,760
so this notation just means that the bit

254
00:11:05,760 --> 00:11:09,500
representation of zero of size

255
00:11:11,579 --> 00:11:14,459
so this function behaves as a random

256
00:11:14,459 --> 00:11:16,980
Oracle if the H function begins as a

257
00:11:16,980 --> 00:11:20,700
fixed output length random marker

258
00:11:20,700 --> 00:11:22,860
so just to have a complete example here

259
00:11:22,860 --> 00:11:25,560
we have a Cascade mhf instantiated with

260
00:11:25,560 --> 00:11:26,940
three Ash

261
00:11:26,940 --> 00:11:30,000
so we have parallelization in the

262
00:11:30,000 --> 00:11:31,980
absorption phase and parallelization

263
00:11:31,980 --> 00:11:34,500
displeasing phase

264
00:11:34,500 --> 00:11:36,180
um the pressure point here is that the

265
00:11:36,180 --> 00:11:38,579
squeezing phase we don't have any fixed

266
00:11:38,579 --> 00:11:41,300
values so we just have the output of the

267
00:11:41,300 --> 00:11:45,740
triage and then the index

268
00:11:46,680 --> 00:11:48,660
now to understand the advantages of this

269
00:11:48,660 --> 00:11:50,459
construction with respect to other MGF

270
00:11:50,459 --> 00:11:53,640
let me just be briefly record the

271
00:11:53,640 --> 00:11:57,540
counter MGF and the change MBR MGF so

272
00:11:57,540 --> 00:11:59,160
for the counter MGF we need the hash

273
00:11:59,160 --> 00:12:01,339
function the return and bits

274
00:12:01,339 --> 00:12:04,019
and the content I'm Jeff is defined in

275
00:12:04,019 --> 00:12:05,579
this way so we take the message we

276
00:12:05,579 --> 00:12:07,440
concatenate with the index and then we

277
00:12:07,440 --> 00:12:10,700
apply Dash function

278
00:12:10,700 --> 00:12:13,700
foreign

279
00:12:14,000 --> 00:12:16,920
MGF we need the ash function we need a

280
00:12:16,920 --> 00:12:17,959
function

281
00:12:17,959 --> 00:12:20,519
that takes an input M plus l b times

282
00:12:20,519 --> 00:12:23,399
return and Beats and here we first apply

283
00:12:23,399 --> 00:12:26,760
Dash function to the message then we

284
00:12:26,760 --> 00:12:28,320
concatenate with the counter and then

285
00:12:28,320 --> 00:12:33,000
finally we apply the function f

286
00:12:33,000 --> 00:12:35,700
so let's compare this construction with

287
00:12:35,700 --> 00:12:38,279
the Cascade MGF Construction

288
00:12:38,279 --> 00:12:41,519
so first of all indicates in which f is

289
00:12:41,519 --> 00:12:43,200
a truncated permutation

290
00:12:43,200 --> 00:12:45,240
and the advantage that you are going to

291
00:12:45,240 --> 00:12:49,680
see is about the size of the index l

292
00:12:49,680 --> 00:12:51,240
um so here we have K is the security

293
00:12:51,240 --> 00:12:54,019
level B is the public permutation and

294
00:12:54,019 --> 00:12:56,940
the output of the hash function is a is

295
00:12:56,940 --> 00:13:00,360
a piece of 2K bits

296
00:13:00,360 --> 00:13:02,579
so in the case of cascade MGF we have

297
00:13:02,579 --> 00:13:05,100
that the counter can be is of size B

298
00:13:05,100 --> 00:13:07,019
minus 2K bits

299
00:13:07,019 --> 00:13:09,660
because basically p is applying B bits

300
00:13:09,660 --> 00:13:13,139
and the size of these element is of 2K

301
00:13:13,139 --> 00:13:17,579
bits in the case of change MGF the size

302
00:13:17,579 --> 00:13:21,180
of L is B minus three a minus three k

303
00:13:21,180 --> 00:13:24,120
bits and the reason is that we have a

304
00:13:24,120 --> 00:13:25,680
counter we have Dash function but we

305
00:13:25,680 --> 00:13:29,820
also have this initial value of K bits

306
00:13:29,820 --> 00:13:33,240
so what is what does it mean in practice

307
00:13:33,240 --> 00:13:34,920
um this is very important in the case in

308
00:13:34,920 --> 00:13:36,600
which we have permutation that works

309
00:13:36,600 --> 00:13:39,779
over uh small fields for example we have

310
00:13:39,779 --> 00:13:43,860
kimly or sudo that work over 384 bits

311
00:13:43,860 --> 00:13:46,279
and as soon that we want

312
00:13:46,279 --> 00:13:49,320
128 bit of security then in the case of

313
00:13:49,320 --> 00:13:53,279
change MB MGF the size of the index

314
00:13:53,279 --> 00:13:56,100
L is just 0 bit so we can just have one

315
00:13:56,100 --> 00:13:58,800
digest block in the case of cascade MGF

316
00:13:58,800 --> 00:14:01,139
the size of value is 120 bits which

317
00:14:01,139 --> 00:14:03,360
means we can generate up to 2 to the

318
00:14:03,360 --> 00:14:06,420
power of 120 Pages blocks

319
00:14:06,420 --> 00:14:10,040
so the difference is YouTube

320
00:14:11,399 --> 00:14:12,660
so another possibility these two

321
00:14:12,660 --> 00:14:15,120
instances function f with the sum of two

322
00:14:15,120 --> 00:14:18,540
permutations bit 0 and P1

323
00:14:18,540 --> 00:14:21,060
and in this case

324
00:14:21,060 --> 00:14:22,380
um

325
00:14:22,380 --> 00:14:25,980
l so that the size of the index the size

326
00:14:25,980 --> 00:14:29,459
of the index I is p minus 2K because we

327
00:14:29,459 --> 00:14:31,860
don't have an initial value and we can

328
00:14:31,860 --> 00:14:35,519
output the pivots

329
00:14:35,820 --> 00:14:37,800
so here the advantage comes from the

330
00:14:37,800 --> 00:14:39,240
number of permutation code that we need

331
00:14:39,240 --> 00:14:42,180
to generate a certain amount of bits so

332
00:14:42,180 --> 00:14:43,920
in the case of cascade MGF we can

333
00:14:43,920 --> 00:14:46,680
generate the B minus K beats with one

334
00:14:46,680 --> 00:14:48,959
permutation code in the case of change

335
00:14:48,959 --> 00:14:52,079
and chain MGF we can generate PBS but we

336
00:14:52,079 --> 00:14:54,120
need two permutation codes

337
00:14:54,120 --> 00:14:56,339
and these inequalities always satisfied

338
00:14:56,339 --> 00:14:59,579
if B is greater than 2 times K but this

339
00:14:59,579 --> 00:15:02,060
condition is necessary because

340
00:15:02,060 --> 00:15:04,920
otherwise we can get a collision on dash

341
00:15:04,920 --> 00:15:07,139
function faster than the security

342
00:15:07,139 --> 00:15:09,620
gallery

343
00:15:09,720 --> 00:15:12,120
so the comparison between Cascade MGF

344
00:15:12,120 --> 00:15:13,680
and counter MGF can be found in the

345
00:15:13,680 --> 00:15:15,000
paper

346
00:15:15,000 --> 00:15:18,480
and with this one I am going to conclude

347
00:15:18,480 --> 00:15:20,339
so in this paper we proved that

348
00:15:20,339 --> 00:15:22,560
application permutation is associated by

349
00:15:22,560 --> 00:15:23,940
randomized value is seeing

350
00:15:23,940 --> 00:15:25,800
differentiable from a random function

351
00:15:25,800 --> 00:15:28,320
we propose a new MGF construction which

352
00:15:28,320 --> 00:15:30,600
is called Cascade MGF Construction

353
00:15:30,600 --> 00:15:33,660
and we showed that this construction has

354
00:15:33,660 --> 00:15:35,160
concrete practical advantages with

355
00:15:35,160 --> 00:15:36,899
respect to other MGS construction

356
00:15:36,899 --> 00:15:39,660
proposed into each other

357
00:15:39,660 --> 00:15:43,279
thank you very much for your attention

358
00:15:46,500 --> 00:15:48,240
thank you very much

359
00:15:48,240 --> 00:15:51,800
any questions or comments

360
00:15:55,800 --> 00:15:59,100
okay so I have one question oh

361
00:15:59,100 --> 00:16:00,300
baby

362
00:16:00,300 --> 00:16:04,019
possible to improve the security or our

363
00:16:04,019 --> 00:16:06,839
trunk from we can also touch functions

364
00:16:06,839 --> 00:16:10,940
like primage audio yes

365
00:16:10,940 --> 00:16:13,139
your assumption for hash functioning

366
00:16:13,139 --> 00:16:15,959
random work right oh

367
00:16:15,959 --> 00:16:17,880
uh is it possible to

368
00:16:17,880 --> 00:16:19,579
be the

369
00:16:19,579 --> 00:16:22,380
Assumption so for sure we need the

370
00:16:22,380 --> 00:16:25,040
Collision resistance about the payment

371
00:16:25,040 --> 00:16:28,199
uh I'm not sure I have to check honestly

372
00:16:28,199 --> 00:16:30,500
okay

373
00:16:35,760 --> 00:16:39,480
uh do you have any idea to make the

374
00:16:39,480 --> 00:16:41,459
Construction truncation Construction to

375
00:16:41,459 --> 00:16:43,560
be washed then

376
00:16:43,560 --> 00:16:45,899
uh beyond the

377
00:16:45,899 --> 00:16:49,259
initial value it

378
00:16:49,259 --> 00:16:51,839
so your your construction also start

379
00:16:51,839 --> 00:16:54,240
with the Collision probability

380
00:16:54,240 --> 00:16:58,980
M over 2 maybe is there any idea to take

381
00:16:58,980 --> 00:17:00,540
the better

382
00:17:00,540 --> 00:17:03,420
uh not tricky because uh I mean if you

383
00:17:03,420 --> 00:17:04,740
have a collision on the ash the

384
00:17:04,740 --> 00:17:06,540
construction is already broken

385
00:17:06,540 --> 00:17:09,119
uh

386
00:17:09,119 --> 00:17:10,859
not at the moment I have no idea to be

387
00:17:10,859 --> 00:17:14,479
honest okay thank you thank you

388
00:17:21,119 --> 00:17:24,020
another question

389
00:17:28,500 --> 00:17:33,260
no question from the room Zoom

390
00:17:34,799 --> 00:17:40,039
okay so yes Sound Speed again

391
00:17:57,080 --> 00:18:00,379
thank you

392
00:18:08,460 --> 00:18:10,740
Okay so we've done

393
00:18:10,740 --> 00:18:12,600
uh

394
00:18:12,600 --> 00:18:16,020
next prediction is the multi the

395
00:18:16,020 --> 00:18:19,140
security of the sum of drunk random

396
00:18:19,140 --> 00:18:20,220
Plantation

397
00:18:20,220 --> 00:18:27,059
by 163 uh he can King uh John Reed and

398
00:18:27,059 --> 00:18:30,660
uh your midi so uh

399
00:18:30,660 --> 00:18:32,240
one second

400
00:18:32,240 --> 00:18:34,980
thank you for introduction and let me

401
00:18:34,980 --> 00:18:36,720
start my presentation

402
00:18:36,720 --> 00:18:40,500
my topic is multi-user security of the

403
00:18:40,500 --> 00:18:44,539
sum of truncated and permutations

404
00:18:46,520 --> 00:18:50,000
so like this

405
00:18:50,000 --> 00:18:54,179
okay okay thank you my name is once up

406
00:18:54,179 --> 00:18:58,220
and my co-orders is

407
00:18:58,640 --> 00:19:02,419
and let me start

408
00:19:03,000 --> 00:19:06,600
so this is online for today and let's

409
00:19:06,600 --> 00:19:09,918
start with introduction first

410
00:19:11,059 --> 00:19:13,860
are one of the most common privileges in

411
00:19:13,860 --> 00:19:17,280
the world and for example yes

412
00:19:17,280 --> 00:19:20,100
is commonly used in many ways such as

413
00:19:20,100 --> 00:19:22,740
wireless security processor security

414
00:19:22,740 --> 00:19:29,000
fire encryption slcl tlsm and more

415
00:19:31,440 --> 00:19:35,100
so rock sniper takes NBT input and

416
00:19:35,100 --> 00:19:38,160
output embed strings so if you want to

417
00:19:38,160 --> 00:19:41,160
encrypt more than Ambit data you need

418
00:19:41,160 --> 00:19:46,160
repeatedly applied designer again and

419
00:19:48,720 --> 00:19:52,320
however knife construction based on a

420
00:19:52,320 --> 00:19:57,000
block type such as Max or aead

421
00:19:57,000 --> 00:19:59,039
they guarantee the obviously Bond

422
00:19:59,039 --> 00:20:03,179
security for example counter mode

423
00:20:03,179 --> 00:20:06,600
is commonly used in encryption skills

424
00:20:06,600 --> 00:20:10,639
but only guarantee double stability

425
00:20:12,480 --> 00:20:15,559
and there are it's a simple solution to

426
00:20:15,559 --> 00:20:19,679
replace the block Cipher with three

427
00:20:19,679 --> 00:20:22,799
random functions and this problem may

428
00:20:22,799 --> 00:20:26,720
cause Ruby level program

429
00:20:29,340 --> 00:20:32,100
there are two natural way to building

430
00:20:32,100 --> 00:20:36,179
curves from rock paper

431
00:20:36,179 --> 00:20:37,280
and

432
00:20:37,280 --> 00:20:41,460
trp and sop where trp means truncation

433
00:20:41,460 --> 00:20:46,919
construction and X sop means XL 2

434
00:20:46,919 --> 00:20:50,299
independent permutations

435
00:20:52,380 --> 00:20:57,059
the security of PRP was proven by global

436
00:20:57,059 --> 00:21:00,380
radar and they proved the tight security

437
00:21:00,380 --> 00:21:05,900
in the Journal of cryptology in 2018.

438
00:21:06,960 --> 00:21:09,780
they also showed that this

439
00:21:09,780 --> 00:21:11,460
type research

440
00:21:11,460 --> 00:21:14,100
actually follows from a result of stamps

441
00:21:14,100 --> 00:21:17,039
paper in 1978

442
00:21:17,039 --> 00:21:20,580
and recently Gucci and many introduced a

443
00:21:20,580 --> 00:21:22,799
new construction summation truncation

444
00:21:22,799 --> 00:21:24,480
hybrid Construction

445
00:21:24,480 --> 00:21:27,419
and this construction is made by

446
00:21:27,419 --> 00:21:29,940
concatenating outputs of two independent

447
00:21:29,940 --> 00:21:32,700
tlps and some of these card bits from

448
00:21:32,700 --> 00:21:34,100
those CRPS

449
00:21:34,100 --> 00:21:37,260
surprisingly those reusing bit does not

450
00:21:37,260 --> 00:21:39,720
degrade the security of sth and

451
00:21:39,720 --> 00:21:43,320
therefore sh has same security level

452
00:21:43,320 --> 00:21:46,220
with Therapies

453
00:21:47,820 --> 00:21:51,020
on the other hand the security of sop

454
00:21:51,020 --> 00:21:55,039
has a long history

455
00:21:56,299 --> 00:22:00,860
show the security of sop

456
00:22:00,860 --> 00:22:03,480
however the middle theory was not

457
00:22:03,480 --> 00:22:06,840
verifiable and tired

458
00:22:06,840 --> 00:22:09,600
is security again with different

459
00:22:09,600 --> 00:22:13,380
approaches yeah chi-skilled method

460
00:22:13,380 --> 00:22:15,740
and very recently

461
00:22:15,740 --> 00:22:18,179
and nandi

462
00:22:18,179 --> 00:22:21,120
so that sum of three permutations can be

463
00:22:21,120 --> 00:22:23,460
secured up to two to the inquiries for

464
00:22:23,460 --> 00:22:27,140
each of two to the end users

465
00:22:28,559 --> 00:22:33,240
now let's talk about secret definitions

466
00:22:33,240 --> 00:22:36,659
so our cryptographic systems are

467
00:22:36,659 --> 00:22:39,480
composed of secure cryptographic

468
00:22:39,480 --> 00:22:42,900
Primitives and supported by secure proof

469
00:22:42,900 --> 00:22:46,620
so in our case the crypto cryptographic

470
00:22:46,620 --> 00:22:51,179
system will be prf and this will be made

471
00:22:51,179 --> 00:22:54,440
with Brookside first

472
00:22:56,280 --> 00:22:59,340
and the key block cycle can be regarded

473
00:22:59,340 --> 00:23:02,760
as a structure kids random computation

474
00:23:02,760 --> 00:23:07,860
and security permutation is not be able

475
00:23:07,860 --> 00:23:09,720
to distinguish him from Australian

476
00:23:09,720 --> 00:23:12,440
implementation

477
00:23:13,440 --> 00:23:16,080
using this model how to show the

478
00:23:16,080 --> 00:23:19,220
structure of given Construction

479
00:23:21,120 --> 00:23:23,419
we will set the interest

480
00:23:23,419 --> 00:23:26,640
indistinguishable chain we are given to

481
00:23:26,640 --> 00:23:29,159
crypto system namely Ideal World and

482
00:23:29,159 --> 00:23:30,240
near world

483
00:23:30,240 --> 00:23:33,179
for our case Ideal World will be a

484
00:23:33,179 --> 00:23:34,980
trillion in the function and your word

485
00:23:34,980 --> 00:23:40,340
will be a prf algorithm we proposed

486
00:23:45,919 --> 00:23:51,500
Only Knows its queries and answer pairs

487
00:23:53,280 --> 00:23:55,860
in our case we will consider multi-usual

488
00:23:55,860 --> 00:23:58,440
security so there are new number of

489
00:23:58,440 --> 00:24:00,480
users each user

490
00:24:00,480 --> 00:24:03,480
have independent keys and for Ideal

491
00:24:03,480 --> 00:24:05,940
World they also have independent random

492
00:24:05,940 --> 00:24:08,419
functions

493
00:24:09,720 --> 00:24:11,460
so now let's

494
00:24:11,460 --> 00:24:14,520
talk about our research and this is the

495
00:24:14,520 --> 00:24:16,760
construction we propose

496
00:24:16,760 --> 00:24:21,840
s81 and s82 they are a kind of the sum

497
00:24:21,840 --> 00:24:25,679
of trunkage random permutations and sat1

498
00:24:25,679 --> 00:24:27,480
is the

499
00:24:27,480 --> 00:24:30,120
Little tune from single permutation with

500
00:24:30,120 --> 00:24:33,480
the domain separation and sat2 uses the

501
00:24:33,480 --> 00:24:37,880
independent two random permutations

502
00:24:39,720 --> 00:24:42,600
we also studied about the sum of three

503
00:24:42,600 --> 00:24:45,500
random permutation

504
00:24:46,380 --> 00:24:49,640
it doesn't work

505
00:24:49,679 --> 00:24:55,010
okay so sop three one is indeed

506
00:24:55,010 --> 00:24:56,419
[Music]

507
00:24:56,419 --> 00:24:59,840
studied in the rasta clip

508
00:24:59,840 --> 00:25:04,340
but they didn't study about sop32

509
00:25:04,340 --> 00:25:09,360
sop32 is a variant of sop31 using

510
00:25:09,360 --> 00:25:12,320
different permutations

511
00:25:13,200 --> 00:25:15,480
and this is our research

512
00:25:15,480 --> 00:25:18,120
where the security implies the upper

513
00:25:18,120 --> 00:25:20,039
bound of distinguishing advantage of

514
00:25:20,039 --> 00:25:22,860
each construction new is the number of

515
00:25:22,860 --> 00:25:26,039
users and qmx is the maximum number of

516
00:25:26,039 --> 00:25:27,960
qualities per users

517
00:25:27,960 --> 00:25:32,039
m is the output page and rate is a

518
00:25:32,039 --> 00:25:35,720
public permutation for as you can see

519
00:25:35,720 --> 00:25:39,000
sat1 and s82 are

520
00:25:39,000 --> 00:25:42,360
a picture of two to the end corresponds

521
00:25:42,360 --> 00:25:46,020
usually when mu is smaller than 2 to the

522
00:25:46,020 --> 00:25:48,120
N minus M users

523
00:25:48,120 --> 00:25:52,440
which is same security level with sop3

524
00:25:52,440 --> 00:25:55,320
and if the number of user is smaller

525
00:25:55,320 --> 00:25:58,380
than that sc82 can be more secure than

526
00:25:58,380 --> 00:25:59,820
sat1

527
00:25:59,820 --> 00:26:03,659
similarly so p32 can be more secure than

528
00:26:03,659 --> 00:26:08,960
sop31 when number of users are shoes

529
00:26:12,779 --> 00:26:15,120
so is our understanding

530
00:26:15,120 --> 00:26:18,539
let me explain about the multi-usual

531
00:26:18,539 --> 00:26:21,000
security of the sum of two random

532
00:26:21,000 --> 00:26:23,400
permutations

533
00:26:23,400 --> 00:26:27,720
if we use Bible approaches with previous

534
00:26:27,720 --> 00:26:31,559
results we can multiply number of users

535
00:26:31,559 --> 00:26:33,900
mu for the previous single user bound

536
00:26:33,900 --> 00:26:37,380
and obtain the this bound

537
00:26:37,380 --> 00:26:41,760
for this case when we let mu be 2 to the

538
00:26:41,760 --> 00:26:43,980
N then 2 max

539
00:26:43,980 --> 00:26:46,140
should be smaller than smaller than

540
00:26:46,140 --> 00:26:48,440
Boston

541
00:26:49,440 --> 00:26:52,500
however using our research

542
00:26:52,500 --> 00:26:56,880
our by obtaining our new Bound by

543
00:26:56,880 --> 00:27:01,020
letting m is it is a type of visual

544
00:27:01,020 --> 00:27:04,140
letting m equal to n

545
00:27:04,140 --> 00:27:07,620
so when we're getting m equal to n or

546
00:27:07,620 --> 00:27:11,460
s82 we will obtain this bound and it

547
00:27:11,460 --> 00:27:13,740
means that when mu is equal to 2 to the

548
00:27:13,740 --> 00:27:17,220
n two Max can be on the state bound and

549
00:27:17,220 --> 00:27:21,360
uh the the following is also typo and M

550
00:27:21,360 --> 00:27:24,720
is when smaller than n k shift

551
00:27:24,720 --> 00:27:27,539
this is the first bound because no one

552
00:27:27,539 --> 00:27:31,020
ever consider the security of thermal

553
00:27:31,020 --> 00:27:34,520
truncated random computations

554
00:27:37,080 --> 00:27:41,580
for technical contribution we used

555
00:27:41,580 --> 00:27:43,799
proof technique based on chi-skilled

556
00:27:43,799 --> 00:27:46,860
method and for chi-square method we

557
00:27:46,860 --> 00:27:48,539
should compute the expectation of the

558
00:27:48,539 --> 00:27:50,760
chi-square Divergence for sum of

559
00:27:50,760 --> 00:27:55,320
truncated values and it does not easy

560
00:27:55,320 --> 00:27:58,380
and almost impossible when your first

561
00:27:58,380 --> 00:28:01,440
attempt so we need to modify the domain

562
00:28:01,440 --> 00:28:05,580
over the expectation is taken so and you

563
00:28:05,580 --> 00:28:07,380
also need to using input counting

564
00:28:07,380 --> 00:28:10,860
because if you lose literally counting

565
00:28:10,860 --> 00:28:14,640
some numbers then it immediately make

566
00:28:14,640 --> 00:28:18,620
the whole bound loser

567
00:28:20,820 --> 00:28:24,659
for applications sat1 and sh2 can be

568
00:28:24,659 --> 00:28:27,059
placed the key generation algorithms in

569
00:28:27,059 --> 00:28:33,000
AES gcms survey or database Plus or sscm

570
00:28:33,000 --> 00:28:35,940
those constructions are using synthetic

571
00:28:35,940 --> 00:28:39,779
variables adapt from strf and sat1 and

572
00:28:39,779 --> 00:28:44,400
sh2 can replace those picture Theory

573
00:28:44,400 --> 00:28:46,860
so either be more secure in double

574
00:28:46,860 --> 00:28:49,639
Chooser setting

575
00:28:49,980 --> 00:28:52,200
now I will tell you about our security

576
00:28:52,200 --> 00:28:54,740
proof

577
00:28:54,900 --> 00:28:56,700
let's start with

578
00:28:56,700 --> 00:28:59,880
defining distinguished gain

579
00:28:59,880 --> 00:29:03,960
that the ideal world will be nearly

580
00:29:03,960 --> 00:29:07,380
random function and the real world will

581
00:29:07,380 --> 00:29:09,840
be summation and truncation Construction

582
00:29:09,840 --> 00:29:14,100
in this case we will consider about sat2

583
00:29:14,100 --> 00:29:16,679
and by defining the probability

584
00:29:16,679 --> 00:29:19,080
description we can

585
00:29:19,080 --> 00:29:21,720
Express the advantage or problem like

586
00:29:21,720 --> 00:29:23,899
this

587
00:29:26,399 --> 00:29:29,279
to ease our understanding we

588
00:29:29,279 --> 00:29:31,500
will also Define the new experiment

589
00:29:31,500 --> 00:29:34,460
which choose their output independently

590
00:29:34,460 --> 00:29:37,799
independently from given inputs I want

591
00:29:37,799 --> 00:29:40,320
to note that this setting is not

592
00:29:40,320 --> 00:29:42,539
necessary but it is only for either

593
00:29:42,539 --> 00:29:45,240
understanding so

594
00:29:45,240 --> 00:29:47,940
this Statistics consistency will be the

595
00:29:47,940 --> 00:29:50,120
same

596
00:29:50,880 --> 00:29:52,460
and finally

597
00:29:52,460 --> 00:29:56,220
we want to give some extra output let me

598
00:29:56,220 --> 00:29:59,820
out during the game and

599
00:29:59,820 --> 00:30:03,240
are in the real world is

600
00:30:03,240 --> 00:30:07,140
so the value of trunkage output of P1

601
00:30:07,140 --> 00:30:09,539
on the other hand in the ideal World

602
00:30:09,539 --> 00:30:13,740
there is no P1 so I should mimic adopts

603
00:30:13,740 --> 00:30:15,840
in the real world

604
00:30:15,840 --> 00:30:18,120
so it's the

605
00:30:18,120 --> 00:30:20,580
additional information so we can operate

606
00:30:20,580 --> 00:30:22,740
on the statistical distance like this

607
00:30:22,740 --> 00:30:27,380
and the advantage will be same

608
00:30:30,799 --> 00:30:33,899
to Upper bound the statistical distance

609
00:30:33,899 --> 00:30:37,020
we will use chi-square method by

610
00:30:37,020 --> 00:30:40,140
defining the probability of the ice

611
00:30:40,140 --> 00:30:42,240
answer obtained by your diversary

612
00:30:42,240 --> 00:30:45,240
interact with each wall like this then

613
00:30:45,240 --> 00:30:49,039
okay Square method makes us to able to

614
00:30:49,039 --> 00:30:52,320
bound the statistical distance like this

615
00:30:52,320 --> 00:30:55,140
where the crystal Divergence Define like

616
00:30:55,140 --> 00:30:56,039
this

617
00:30:56,039 --> 00:30:59,760
so we need to calculate the probability

618
00:30:59,760 --> 00:31:03,080
of the ice answer

619
00:31:04,440 --> 00:31:07,500
how to do this that

620
00:31:07,500 --> 00:31:09,600
the ice sensor

621
00:31:09,600 --> 00:31:15,120
the r and Y then we will Define the two

622
00:31:15,120 --> 00:31:19,500
random variable s i URI is the number of

623
00:31:19,500 --> 00:31:22,580
possible output pairs from P1 and P2

624
00:31:22,580 --> 00:31:25,500
consists to the previous answers

625
00:31:25,500 --> 00:31:28,620
and DIY is the number of possible

626
00:31:28,620 --> 00:31:32,100
outpair from P1 and Peter for NES

627
00:31:32,100 --> 00:31:35,100
then the probability obtaining the ice

628
00:31:35,100 --> 00:31:38,460
sensor in the ideal world and your word

629
00:31:38,460 --> 00:31:43,559
will be like this as you can see s i r y

630
00:31:43,559 --> 00:31:46,140
will be considered canceled out and we

631
00:31:46,140 --> 00:31:49,880
will only consider TIY

632
00:31:51,240 --> 00:31:54,600
so how to compute the expectation of

633
00:31:54,600 --> 00:31:58,500
giui and the variance of Qi since uh

634
00:31:58,500 --> 00:32:02,640
here we also compute the scale of tiui

635
00:32:02,640 --> 00:32:04,640
and it can be

636
00:32:04,640 --> 00:32:08,039
expressed by the variance

637
00:32:08,039 --> 00:32:13,200
uh we solve this problem by defining our

638
00:32:13,200 --> 00:32:17,100
gradual domain namely H is consistent

639
00:32:17,100 --> 00:32:21,360
with set so H contains I minus 0 output

640
00:32:21,360 --> 00:32:25,080
to p on and P2 before truncated and we

641
00:32:25,080 --> 00:32:29,399
successfully showed that the expectation

642
00:32:29,399 --> 00:32:33,000
we have same value even if the domain is

643
00:32:33,000 --> 00:32:34,580
changed

644
00:32:34,580 --> 00:32:39,980
and finally we can so the following them

645
00:32:39,980 --> 00:32:43,640
and from this member we can evaluate the

646
00:32:43,640 --> 00:32:48,380
expectation of high school Divergence

647
00:32:49,320 --> 00:32:53,039
so let me conclude my presentation

648
00:32:53,039 --> 00:32:57,740
and this is the open program so because

649
00:32:57,740 --> 00:33:01,559
uh there was a construction building

650
00:33:01,559 --> 00:33:03,299
truncated bits

651
00:33:03,299 --> 00:33:06,179
efficiently I think our construction

652
00:33:06,179 --> 00:33:10,260
also can use this idea and secondly

653
00:33:10,260 --> 00:33:13,919
application of aad is surely will be a

654
00:33:13,919 --> 00:33:16,700
good open program and finally

655
00:33:16,700 --> 00:33:19,740
generalization of this method to

656
00:33:19,740 --> 00:33:21,480
obtaining better multi-usual security

657
00:33:21,480 --> 00:33:24,779
balance for various construction will be

658
00:33:24,779 --> 00:33:28,559
also interesting work and I'm actually

659
00:33:28,559 --> 00:33:32,640
ongoing to work to do that

660
00:33:32,640 --> 00:33:35,159
so this is the end of presentation thank

661
00:33:35,159 --> 00:33:36,779
you for listening

662
00:33:36,779 --> 00:33:39,679
any questions

663
00:33:42,539 --> 00:33:45,720
thank you very much uh any question or

664
00:33:45,720 --> 00:33:47,960
comment

665
00:33:56,880 --> 00:34:00,630
hey just a quick question

666
00:34:00,630 --> 00:34:03,000
[Music]

667
00:34:03,000 --> 00:34:05,880
in one slide you'll say when you eat the

668
00:34:05,880 --> 00:34:10,260
end and it's a job

669
00:34:10,260 --> 00:34:12,440
after that they want some query again

670
00:34:12,440 --> 00:34:16,080
this land right what does that mean but

671
00:34:16,080 --> 00:34:18,839
more user than queries

672
00:34:18,839 --> 00:34:21,540
uh can you what does that mean

673
00:34:21,540 --> 00:34:23,520
concretely for the adversary that you

674
00:34:23,520 --> 00:34:26,219
have more users than queries

675
00:34:26,219 --> 00:34:28,619
that means there are users that you want

676
00:34:28,619 --> 00:34:30,899
two queries to or does that every

677
00:34:30,899 --> 00:34:32,699
address we are just

678
00:34:32,699 --> 00:34:35,820
also mu is the number of users and Q

679
00:34:35,820 --> 00:34:37,800
makes me implies the

680
00:34:37,800 --> 00:34:41,399
uh queries for each user so

681
00:34:41,399 --> 00:34:43,800
okay so effectively the industry does

682
00:34:43,800 --> 00:34:47,280
the Q times U query yeah yeah that's it

683
00:34:47,280 --> 00:34:50,000
okay thank you

684
00:34:53,159 --> 00:34:56,119
and you have a question

685
00:35:01,880 --> 00:35:05,040
there's no no

686
00:35:05,040 --> 00:35:09,859
okay this sound speaker okay thank you

687
00:35:23,359 --> 00:35:25,579
next

688
00:35:25,579 --> 00:35:27,680
is a

689
00:35:27,680 --> 00:35:30,599
functional key wrapping on each

690
00:35:30,599 --> 00:35:34,079
application by material

691
00:35:34,079 --> 00:35:37,079
uh

692
00:35:38,040 --> 00:35:42,420
Eric's uh Gunther and any better

693
00:35:42,420 --> 00:35:44,359
so

694
00:35:44,359 --> 00:35:49,279
motivator please give your talk

695
00:35:50,040 --> 00:35:51,300
thank you

696
00:35:51,300 --> 00:35:53,280
thank you for the introduction yes so my

697
00:35:53,280 --> 00:35:54,839
name is Matilda and this talk is about

698
00:35:54,839 --> 00:35:56,760
punctual key wrapping and its

699
00:35:56,760 --> 00:35:58,980
applications and this is Joint work with

700
00:35:58,980 --> 00:36:01,680
Felix gintel and Kenny Patterson from

701
00:36:01,680 --> 00:36:03,839
the applied cryptography group at eph

702
00:36:03,839 --> 00:36:05,880
sorry

703
00:36:05,880 --> 00:36:08,400
so in this talk I will try to tell you

704
00:36:08,400 --> 00:36:11,220
what punctual key wrapping is how it can

705
00:36:11,220 --> 00:36:12,599
be used and why we think it's

706
00:36:12,599 --> 00:36:15,119
interesting so starting with the what

707
00:36:15,119 --> 00:36:16,800
let's forget about puncturing for a

708
00:36:16,800 --> 00:36:19,260
moment and focus on key wrapping

709
00:36:19,260 --> 00:36:21,000
you can think of key wrapping as being

710
00:36:21,000 --> 00:36:24,119
authenticated symmetric encryption where

711
00:36:24,119 --> 00:36:26,940
the plaintexts are cryptographic keys

712
00:36:26,940 --> 00:36:29,280
and this can be used to protect these in

713
00:36:29,280 --> 00:36:31,380
storage and during transport

714
00:36:31,380 --> 00:36:33,599
it can also be used to build so-called

715
00:36:33,599 --> 00:36:36,240
key hierarchies which are systems where

716
00:36:36,240 --> 00:36:38,220
one key is used to protect multiple

717
00:36:38,220 --> 00:36:39,540
other keys

718
00:36:39,540 --> 00:36:41,579
and this is useful for example in

719
00:36:41,579 --> 00:36:44,460
applications that have a lot of keys to

720
00:36:44,460 --> 00:36:46,260
use Key Management

721
00:36:46,260 --> 00:36:49,260
so to take a concrete example let's look

722
00:36:49,260 --> 00:36:51,300
at file encryption

723
00:36:51,300 --> 00:36:53,099
so imagine that you have a bunch of

724
00:36:53,099 --> 00:36:55,440
files which you would like to Outsource

725
00:36:55,440 --> 00:36:57,660
to some untrusted storage

726
00:36:57,660 --> 00:36:59,820
and since the storage is untrusted you

727
00:36:59,820 --> 00:37:01,200
probably want to encrypt your files

728
00:37:01,200 --> 00:37:02,339
first

729
00:37:02,339 --> 00:37:04,680
now to do this I'm still adhere to best

730
00:37:04,680 --> 00:37:06,900
practices of key separation

731
00:37:06,900 --> 00:37:09,119
you'll probably want to generate a

732
00:37:09,119 --> 00:37:12,359
unique data encryption key per file to

733
00:37:12,359 --> 00:37:14,720
encrypt each file separately

734
00:37:14,720 --> 00:37:17,460
however you're now stuck with a bit of a

735
00:37:17,460 --> 00:37:19,320
key management overhead because you have

736
00:37:19,320 --> 00:37:21,060
to store all of the data encryption keys

737
00:37:21,060 --> 00:37:23,280
in some protected storage

738
00:37:23,280 --> 00:37:25,260
so to get around this you can generate

739
00:37:25,260 --> 00:37:27,240
what's known as a key encryption key or

740
00:37:27,240 --> 00:37:30,060
a kick and use this to wrap or

741
00:37:30,060 --> 00:37:32,040
essentially encrypt all of the data

742
00:37:32,040 --> 00:37:33,359
encryption keys

743
00:37:33,359 --> 00:37:35,099
and now you can Outsource also the

744
00:37:35,099 --> 00:37:37,020
storage of the rough data encryption

745
00:37:37,020 --> 00:37:40,579
keys for the untrusted search

746
00:37:41,099 --> 00:37:43,380
and in the setting the route data

747
00:37:43,380 --> 00:37:44,940
encryption keys are usually stored

748
00:37:44,940 --> 00:37:47,339
together with the encrypted files so if

749
00:37:47,339 --> 00:37:49,320
you want to delete some files you would

750
00:37:49,320 --> 00:37:51,000
also delete the corresponding data

751
00:37:51,000 --> 00:37:52,260
encryption keys

752
00:37:52,260 --> 00:37:54,300
and this is one example of a key

753
00:37:54,300 --> 00:37:55,920
hierarchy you can also have key

754
00:37:55,920 --> 00:37:59,040
hierarchies with multiple levels or Keys

755
00:37:59,040 --> 00:38:00,720
above the key encryption key level are

756
00:38:00,720 --> 00:38:02,579
used to protect the key encryption Keys

757
00:38:02,579 --> 00:38:04,339
Etc

758
00:38:04,339 --> 00:38:06,900
and key hierarchies are ubiquitous in

759
00:38:06,900 --> 00:38:09,660
practice so for example this figure is

760
00:38:09,660 --> 00:38:12,839
taken from Google clouds white paper or

761
00:38:12,839 --> 00:38:15,119
they show their encryption key hierarchy

762
00:38:15,119 --> 00:38:16,800
and it's slightly rotated compared to

763
00:38:16,800 --> 00:38:18,060
the illustration that I just showed you

764
00:38:18,060 --> 00:38:20,460
so you twist your head like this 90

765
00:38:20,460 --> 00:38:21,900
degrees you might see the similarities

766
00:38:21,900 --> 00:38:24,300
we have the Keck on the right the rough

767
00:38:24,300 --> 00:38:26,940
data encryption keys on the left and the

768
00:38:26,940 --> 00:38:28,800
encrypted files or data chunks in the

769
00:38:28,800 --> 00:38:30,920
middle

770
00:38:32,240 --> 00:38:35,400
so let's take an example of a Chiara key

771
00:38:35,400 --> 00:38:37,140
in a slightly different setting namely

772
00:38:37,140 --> 00:38:39,180
TLS session resumption

773
00:38:39,180 --> 00:38:41,880
here the scenario is that a bunch of

774
00:38:41,880 --> 00:38:43,380
clients

775
00:38:43,380 --> 00:38:45,720
um have shared a session with a server

776
00:38:45,720 --> 00:38:47,040
in the past

777
00:38:47,040 --> 00:38:49,020
during which they exchanged so-called

778
00:38:49,020 --> 00:38:52,200
pre-shared keys or psks

779
00:38:52,200 --> 00:38:53,760
and the pre-shared keys are symmetric

780
00:38:53,760 --> 00:38:57,540
Keys which can be used to bootstrap the

781
00:38:57,540 --> 00:38:59,820
security of our Zoom sessions in the

782
00:38:59,820 --> 00:39:01,200
future

783
00:39:01,200 --> 00:39:03,660
and the issue here is the same as uh in

784
00:39:03,660 --> 00:39:05,460
the case of file encryption namely Key

785
00:39:05,460 --> 00:39:06,540
Management

786
00:39:06,540 --> 00:39:08,099
because it might be the case that the

787
00:39:08,099 --> 00:39:09,720
server serves potentially millions of

788
00:39:09,720 --> 00:39:11,640
clients and it could be infeasible for

789
00:39:11,640 --> 00:39:14,359
it to store all of the pre-shared keys

790
00:39:14,359 --> 00:39:17,940
so to get around this TLS allows the

791
00:39:17,940 --> 00:39:20,460
server to use its long-term key to

792
00:39:20,460 --> 00:39:22,740
encrypt the pre-shared keys and

793
00:39:22,740 --> 00:39:24,960
Outsource the storage of them to the

794
00:39:24,960 --> 00:39:26,280
clients in what's known as session

795
00:39:26,280 --> 00:39:27,740
tickets

796
00:39:27,740 --> 00:39:30,119
and when a client wants to resume a

797
00:39:30,119 --> 00:39:32,160
session it simply sends the session

798
00:39:32,160 --> 00:39:34,260
ticket back to the server which uses

799
00:39:34,260 --> 00:39:35,820
this long-term key to decrypt the

800
00:39:35,820 --> 00:39:39,680
pre-shared key and start the session

801
00:39:40,099 --> 00:39:43,140
so now using two examples of key

802
00:39:43,140 --> 00:39:44,880
hierarchies let's have a look at what

803
00:39:44,880 --> 00:39:46,800
happens in the case that the main key is

804
00:39:46,800 --> 00:39:48,839
compromised

805
00:39:48,839 --> 00:39:50,280
so starting with the case of file

806
00:39:50,280 --> 00:39:52,920
encryption if the key encryption key

807
00:39:52,920 --> 00:39:55,560
gets compromised then all of the wrapped

808
00:39:55,560 --> 00:39:58,619
decks enhance also the files are

809
00:39:58,619 --> 00:40:01,079
decryptable

810
00:40:01,079 --> 00:40:03,839
and perhaps somewhat surprisingly this

811
00:40:03,839 --> 00:40:05,640
also includes the previously deleted

812
00:40:05,640 --> 00:40:07,680
files because as you'll recall these

813
00:40:07,680 --> 00:40:10,079
were placed in unprotected storage so it

814
00:40:10,079 --> 00:40:11,579
could be the case that some adversary

815
00:40:11,579 --> 00:40:14,099
had access to the storage and took a

816
00:40:14,099 --> 00:40:16,079
snapshot of the ciphertexts before the

817
00:40:16,079 --> 00:40:19,260
files were deleted and this violates the

818
00:40:19,260 --> 00:40:21,780
forward security of these deleted files

819
00:40:21,780 --> 00:40:23,700
so we cannot hope to protect the

820
00:40:23,700 --> 00:40:25,619
confidentiality of the files which are

821
00:40:25,619 --> 00:40:27,240
still in the storage when the key is

822
00:40:27,240 --> 00:40:29,579
compromised but we should provide

823
00:40:29,579 --> 00:40:31,680
security for the previously deleted

824
00:40:31,680 --> 00:40:33,599
files

825
00:40:33,599 --> 00:40:36,180
and one way of achieving this is to

826
00:40:36,180 --> 00:40:39,480
perform periodic key rotation

827
00:40:39,480 --> 00:40:41,280
key rotation is an operation in which

828
00:40:41,280 --> 00:40:44,040
you sample a new key encryption key and

829
00:40:44,040 --> 00:40:46,440
replace the previous one and you use the

830
00:40:46,440 --> 00:40:48,720
new key to re-wrap only the data

831
00:40:48,720 --> 00:40:50,400
encryption Keys corresponding to the

832
00:40:50,400 --> 00:40:53,460
non-deleted files now if the new key

833
00:40:53,460 --> 00:40:56,640
encryption key is compromised then the

834
00:40:56,640 --> 00:40:58,380
deleted files for which the data

835
00:40:58,380 --> 00:40:59,940
encryption keys were not re-wrapped

836
00:40:59,940 --> 00:41:02,160
remain secure

837
00:41:02,160 --> 00:41:04,380
however this comes with a drawback of

838
00:41:04,380 --> 00:41:06,000
the re-wrapping or re-encryption

839
00:41:06,000 --> 00:41:08,640
overhead because you have to reroute all

840
00:41:08,640 --> 00:41:09,780
of the data encryption keys that

841
00:41:09,780 --> 00:41:13,079
correspond to the non-deleted files

842
00:41:13,079 --> 00:41:15,180
hence you probably don't want to perform

843
00:41:15,180 --> 00:41:18,420
key rotation after every filed deletion

844
00:41:18,420 --> 00:41:22,079
but only at some fixed time interval

845
00:41:22,079 --> 00:41:23,640
so for example in the case of Google

846
00:41:23,640 --> 00:41:26,520
their standard key rotation time means

847
00:41:26,520 --> 00:41:28,500
that you only get forward security after

848
00:41:28,500 --> 00:41:30,680
about five years

849
00:41:30,680 --> 00:41:34,020
so key rotation provide provides a form

850
00:41:34,020 --> 00:41:36,660
of coarse grain the delayed forward

851
00:41:36,660 --> 00:41:39,020
security

852
00:41:39,020 --> 00:41:42,420
moving over to the setting of TLS if the

853
00:41:42,420 --> 00:41:43,740
long-term key of the server is

854
00:41:43,740 --> 00:41:46,619
compromised then um

855
00:41:46,619 --> 00:41:48,540
the pre-shared keys of all the past

856
00:41:48,540 --> 00:41:50,820
sessions including completed sessions

857
00:41:50,820 --> 00:41:53,339
are compromised and this is because the

858
00:41:53,339 --> 00:41:55,560
client sends the session tickets back to

859
00:41:55,560 --> 00:41:57,900
the server in the clear so an Eaves

860
00:41:57,900 --> 00:42:00,540
stopper on the network could store the

861
00:42:00,540 --> 00:42:02,040
session ticket and then use the

862
00:42:02,040 --> 00:42:04,500
compromise compromise long-term key to

863
00:42:04,500 --> 00:42:06,720
decrypt the preset key

864
00:42:06,720 --> 00:42:09,060
and again this violates forward security

865
00:42:09,060 --> 00:42:12,500
which is an outspoken goal of TLS

866
00:42:12,500 --> 00:42:15,480
and in this setting gear rotation is

867
00:42:15,480 --> 00:42:17,579
unfortunately not a possible solution

868
00:42:17,579 --> 00:42:20,480
can you think of why

869
00:42:21,240 --> 00:42:23,339
so the reason is that the server has no

870
00:42:23,339 --> 00:42:25,200
way of fetching the session tickets from

871
00:42:25,200 --> 00:42:27,780
the clients in order to re-encrypt the

872
00:42:27,780 --> 00:42:30,420
pre-shared keys

873
00:42:30,420 --> 00:42:33,619
but luckily at eurocrypt in 2019

874
00:42:33,619 --> 00:42:36,420
Jager proposed the solution

875
00:42:36,420 --> 00:42:38,520
they designed a forward secure session

876
00:42:38,520 --> 00:42:41,339
assumption protocol for TLS using what's

877
00:42:41,339 --> 00:42:44,579
known as puncturing and puncturing is an

878
00:42:44,579 --> 00:42:47,160
operation which updates the key in such

879
00:42:47,160 --> 00:42:49,020
a way that it can no longer be used to

880
00:42:49,020 --> 00:42:51,300
decrypt specific ciphertexts

881
00:42:51,300 --> 00:42:54,060
in the case of TLS this would be used to

882
00:42:54,060 --> 00:42:56,480
puncture the long-term key of the server

883
00:42:56,480 --> 00:42:59,160
on set on the tickets of completed

884
00:42:59,160 --> 00:43:01,200
sessions to get forward security for the

885
00:43:01,200 --> 00:43:03,359
pre-shared keys

886
00:43:03,359 --> 00:43:05,460
so this is great we have a way of

887
00:43:05,460 --> 00:43:07,020
getting forward security without key

888
00:43:07,020 --> 00:43:10,020
rotation however the solution is

889
00:43:10,020 --> 00:43:12,599
specific to the setting of TLS and it

890
00:43:12,599 --> 00:43:14,339
doesn't carry over for example to the

891
00:43:14,339 --> 00:43:16,440
case of file encryption where we would

892
00:43:16,440 --> 00:43:17,940
ideally like to have the same security

893
00:43:17,940 --> 00:43:19,380
guarantees

894
00:43:19,380 --> 00:43:22,560
so what can we do about that

895
00:43:22,560 --> 00:43:25,380
well if we zoom out enough we can see

896
00:43:25,380 --> 00:43:27,660
that these settings have a lot in common

897
00:43:27,660 --> 00:43:29,819
namely they both have a symmetric key

898
00:43:29,819 --> 00:43:30,900
hierarchy

899
00:43:30,900 --> 00:43:32,280
they would both benefit from forward

900
00:43:32,280 --> 00:43:34,920
security and key rotation is not ideal

901
00:43:34,920 --> 00:43:36,780
in either case

902
00:43:36,780 --> 00:43:38,640
and there are other applications which

903
00:43:38,640 --> 00:43:40,440
also fit this description

904
00:43:40,440 --> 00:43:42,119
so wouldn't it be nice if we could find

905
00:43:42,119 --> 00:43:45,240
a solution that works for all of them

906
00:43:45,240 --> 00:43:47,280
this question led us to look again at

907
00:43:47,280 --> 00:43:49,079
these common properties

908
00:43:49,079 --> 00:43:50,400
and

909
00:43:50,400 --> 00:43:54,359
in particular what we noted that you can

910
00:43:54,359 --> 00:43:56,040
build key hierarchies using key wrapping

911
00:43:56,040 --> 00:43:58,380
as in the case of file encryption and

912
00:43:58,380 --> 00:43:59,819
that you can get forward security from

913
00:43:59,819 --> 00:44:02,339
puncturing as in the case of TLS

914
00:44:02,339 --> 00:44:04,740
so we asked ourselves what happens if

915
00:44:04,740 --> 00:44:08,040
you combine puncturing with key wrapping

916
00:44:08,040 --> 00:44:11,040
and uh perhaps not surprisingly this led

917
00:44:11,040 --> 00:44:14,220
us to introduce punctual key wrapping

918
00:44:14,220 --> 00:44:16,040
which is a new cryptographic primitive

919
00:44:16,040 --> 00:44:18,300
which provides an abstraction layer

920
00:44:18,300 --> 00:44:19,880
between these high-level applications

921
00:44:19,880 --> 00:44:22,560
and the lower level Primitives such as

922
00:44:22,560 --> 00:44:24,480
puncturing and encryption which we build

923
00:44:24,480 --> 00:44:25,500
it from

924
00:44:25,500 --> 00:44:27,720
and it gives us exactly what we want

925
00:44:27,720 --> 00:44:29,760
namely find green forward security

926
00:44:29,760 --> 00:44:32,040
without the need for rewrapping or key

927
00:44:32,040 --> 00:44:35,040
rotation and its generic meaning it can

928
00:44:35,040 --> 00:44:36,780
be used anywhere where key wrapping is

929
00:44:36,780 --> 00:44:39,480
currently used and it's also generic in

930
00:44:39,480 --> 00:44:41,460
the way that we instantiate it from its

931
00:44:41,460 --> 00:44:43,440
building blocks as you'll see in a

932
00:44:43,440 --> 00:44:45,560
moment

933
00:44:46,020 --> 00:44:47,760
but first let's take a look at the

934
00:44:47,760 --> 00:44:49,560
syntax and security of punctual key

935
00:44:49,560 --> 00:44:50,660
wrapping

936
00:44:50,660 --> 00:44:53,099
so starting with the syntax of normal

937
00:44:53,099 --> 00:44:54,599
key wrapping

938
00:44:54,599 --> 00:44:57,119
we have a wrapping algorithm which takes

939
00:44:57,119 --> 00:44:59,220
us input the wrapping key and this would

940
00:44:59,220 --> 00:45:00,839
be the key encryption key in the case of

941
00:45:00,839 --> 00:45:03,060
file encryption or the server's

942
00:45:03,060 --> 00:45:05,220
long-term key in the case of TLS

943
00:45:05,220 --> 00:45:07,619
it also takes us input this black key

944
00:45:07,619 --> 00:45:10,079
which is the data key to be wrapped and

945
00:45:10,079 --> 00:45:11,520
some header with context information

946
00:45:11,520 --> 00:45:14,040
such as the permitted usage of the key

947
00:45:14,040 --> 00:45:17,160
or the expiration date

948
00:45:17,160 --> 00:45:19,140
and that outputs the ciphertext which

949
00:45:19,140 --> 00:45:21,960
authenticates the header

950
00:45:21,960 --> 00:45:24,300
and unwrapping simply undos this so it

951
00:45:24,300 --> 00:45:25,800
takes his input the header and the

952
00:45:25,800 --> 00:45:29,099
ciphertext and it outputs the unwrap key

953
00:45:29,099 --> 00:45:32,160
now to enable puncturing we add an

954
00:45:32,160 --> 00:45:33,660
additional input which we call a

955
00:45:33,660 --> 00:45:36,060
puncturing tag and you can think of this

956
00:45:36,060 --> 00:45:38,460
as being a unique identifier of the

957
00:45:38,460 --> 00:45:40,160
Cyber text

958
00:45:40,160 --> 00:45:43,260
and the puncturing tag is also the input

959
00:45:43,260 --> 00:45:46,079
to the puncturing algorithm which acts

960
00:45:46,079 --> 00:45:48,599
on the wrapping key and outputs a

961
00:45:48,599 --> 00:45:50,280
punctured wrapping key which you can

962
00:45:50,280 --> 00:45:51,839
think of as a wrapping key that just had

963
00:45:51,839 --> 00:45:54,180
a hole punched in it at the point of

964
00:45:54,180 --> 00:45:56,760
this um puncturing tag

965
00:45:56,760 --> 00:45:58,800
because now if you try to unwrap a

966
00:45:58,800 --> 00:46:00,000
cipher text

967
00:46:00,000 --> 00:46:02,280
with this puncturing tag that the

968
00:46:02,280 --> 00:46:04,140
wrapping key was punctured on then

969
00:46:04,140 --> 00:46:06,560
unwrapping will fail

970
00:46:06,560 --> 00:46:09,000
and puncturing is an operation that you

971
00:46:09,000 --> 00:46:11,280
can perform iteratively on the wrapping

972
00:46:11,280 --> 00:46:13,200
key so you can take the punctured key

973
00:46:13,200 --> 00:46:14,819
and then put it again to the puncturing

974
00:46:14,819 --> 00:46:16,920
algorithm to function it on a new tag

975
00:46:16,920 --> 00:46:19,140
and so on and for correctness we want

976
00:46:19,140 --> 00:46:21,839
that unwrapping still works on any

977
00:46:21,839 --> 00:46:23,300
puncturing tag

978
00:46:23,300 --> 00:46:25,800
that the wrapping key was not functioned

979
00:46:25,800 --> 00:46:28,380
on but that it fails

980
00:46:28,380 --> 00:46:30,480
um for those that it was punctured on

981
00:46:30,480 --> 00:46:32,099
so the latter already goes in the

982
00:46:32,099 --> 00:46:35,400
direction of security and a little bit

983
00:46:35,400 --> 00:46:36,780
more formally what we want in terms of

984
00:46:36,780 --> 00:46:38,280
security of a punctual key wrapping

985
00:46:38,280 --> 00:46:40,740
scheme is first and foremost the sort of

986
00:46:40,740 --> 00:46:42,960
basic security of key wrapping namely

987
00:46:42,960 --> 00:46:45,420
confidentiality of the ciphertext

988
00:46:45,420 --> 00:46:46,200
um

989
00:46:46,200 --> 00:46:48,240
in in the sense that ciphertexts are

990
00:46:48,240 --> 00:46:50,640
indistinguishable from random bits

991
00:46:50,640 --> 00:46:52,680
Integrity of ciphertexts in the sense

992
00:46:52,680 --> 00:46:54,900
that if you try to unwrap on a forged

993
00:46:54,900 --> 00:46:57,240
ciphertext then unwrapping will fail

994
00:46:57,240 --> 00:46:59,640
and forward security which is exactly

995
00:46:59,640 --> 00:47:02,520
this property that unwrapping using a

996
00:47:02,520 --> 00:47:04,440
puncture tag on the ciphertext with that

997
00:47:04,440 --> 00:47:06,920
puncture tag that will fail

998
00:47:06,920 --> 00:47:09,119
now it turns out that the applications

999
00:47:09,119 --> 00:47:11,700
that we're interested in need slightly

1000
00:47:11,700 --> 00:47:13,160
different flavors of the security

1001
00:47:13,160 --> 00:47:16,140
Notions or combinations thereof so in

1002
00:47:16,140 --> 00:47:18,720
our paper we explore various levels of

1003
00:47:18,720 --> 00:47:20,280
security for punctual key wrapping

1004
00:47:20,280 --> 00:47:24,079
schemes and also relate them

1005
00:47:26,339 --> 00:47:28,980
so moving on to an example of how you

1006
00:47:28,980 --> 00:47:31,380
can build functionable key wrapping and

1007
00:47:31,380 --> 00:47:32,839
this instantiation

1008
00:47:32,839 --> 00:47:35,940
follows the approach of aviram galat and

1009
00:47:35,940 --> 00:47:36,839
Jagger

1010
00:47:36,839 --> 00:47:39,599
and generalizes it

1011
00:47:39,599 --> 00:47:41,460
so starting with the wrapping algorithm

1012
00:47:41,460 --> 00:47:44,400
if we zoom in then inside we have a

1013
00:47:44,400 --> 00:47:47,040
puncture sorry a pseudorandom function

1014
00:47:47,040 --> 00:47:48,540
which I hope you're all familiar with

1015
00:47:48,540 --> 00:47:50,700
and it takes us input the wrapping key

1016
00:47:50,700 --> 00:47:52,260
as the prf key

1017
00:47:52,260 --> 00:47:55,500
and the puncturing tag is the prf label

1018
00:47:55,500 --> 00:47:57,900
and we treat the output as the key for

1019
00:47:57,900 --> 00:48:00,839
an aad scheme to which we input the

1020
00:48:00,839 --> 00:48:02,700
context information as the additional

1021
00:48:02,700 --> 00:48:05,280
data and the key to be wrapped as the

1022
00:48:05,280 --> 00:48:06,300
message

1023
00:48:06,300 --> 00:48:08,280
and we use the ciphertext as the wrap

1024
00:48:08,280 --> 00:48:09,619
key

1025
00:48:09,619 --> 00:48:12,119
and unwrapping starts the same way

1026
00:48:12,119 --> 00:48:14,220
namely it evaluates the prf on the

1027
00:48:14,220 --> 00:48:16,980
puncturing tag to get the aad key and

1028
00:48:16,980 --> 00:48:18,720
then uses the key to decrypt the

1029
00:48:18,720 --> 00:48:21,619
ciphertext and outputs the unwrapped key

1030
00:48:21,619 --> 00:48:25,020
but how do we get punctuary from this

1031
00:48:25,020 --> 00:48:27,119
well we don't actually use any kind of

1032
00:48:27,119 --> 00:48:29,460
pseudorandom function but a special type

1033
00:48:29,460 --> 00:48:31,680
known as a puncturable pseudorandom

1034
00:48:31,680 --> 00:48:34,980
function or a pprf and a pprf has

1035
00:48:34,980 --> 00:48:37,079
exactly what we need namely a puncturing

1036
00:48:37,079 --> 00:48:39,780
algorithm which shall input the prf key

1037
00:48:39,780 --> 00:48:43,560
and the label outputs a punctured pprf

1038
00:48:43,560 --> 00:48:45,900
key which can no longer be used to

1039
00:48:45,900 --> 00:48:47,960
evaluate this label

1040
00:48:47,960 --> 00:48:50,640
so again now if we try to use this

1041
00:48:50,640 --> 00:48:54,060
punctured pprf key in the unwrapping

1042
00:48:54,060 --> 00:48:56,640
algorithm to evaluate the puncture tag

1043
00:48:56,640 --> 00:48:59,160
the evaluation will fail and we won't

1044
00:48:59,160 --> 00:49:01,920
get the aad key which we need to decrypt

1045
00:49:01,920 --> 00:49:05,460
so unwrapping will also fail

1046
00:49:05,460 --> 00:49:07,740
hence the result of this instantiation

1047
00:49:07,740 --> 00:49:09,359
well it's an efficient construction

1048
00:49:09,359 --> 00:49:11,940
because we know how to build aad schemes

1049
00:49:11,940 --> 00:49:14,520
efficiently and punctual pseudorandom

1050
00:49:14,520 --> 00:49:16,440
functions can also be built efficiently

1051
00:49:16,440 --> 00:49:18,540
for example using the gold versus

1052
00:49:18,540 --> 00:49:21,500
reconstruction

1053
00:49:21,500 --> 00:49:24,000
and it inherits the basic security

1054
00:49:24,000 --> 00:49:26,099
properties such as confidentiality and

1055
00:49:26,099 --> 00:49:29,460
integrity directly from the aad scheme

1056
00:49:29,460 --> 00:49:31,560
and forward security from the punctual

1057
00:49:31,560 --> 00:49:34,578
pseudor atom function

1058
00:49:35,700 --> 00:49:38,040
so with this let's go back to an

1059
00:49:38,040 --> 00:49:39,599
application and have a look at how we

1060
00:49:39,599 --> 00:49:41,760
can use punctual key wrapping in the

1061
00:49:41,760 --> 00:49:43,619
setting of cloud storage to get

1062
00:49:43,619 --> 00:49:45,119
fine-grained forward security for

1063
00:49:45,119 --> 00:49:47,180
deleted files

1064
00:49:47,180 --> 00:49:49,920
as a reminder here are the here's the

1065
00:49:49,920 --> 00:49:51,660
Syntax for functionable key wrapping

1066
00:49:51,660 --> 00:49:53,579
skis

1067
00:49:53,579 --> 00:49:55,680
so the setting is that we have a user

1068
00:49:55,680 --> 00:49:57,420
which has a wrapping key and a bunch of

1069
00:49:57,420 --> 00:49:59,099
files which it would like to Outsource

1070
00:49:59,099 --> 00:50:00,300
to the cloud

1071
00:50:00,300 --> 00:50:02,760
and for each file it generates a data

1072
00:50:02,760 --> 00:50:04,920
encryption key uses this to encrypt the

1073
00:50:04,920 --> 00:50:08,339
file then samples a puncturing tag and

1074
00:50:08,339 --> 00:50:10,619
uses this to wrap up the data encryption

1075
00:50:10,619 --> 00:50:12,300
keys

1076
00:50:12,300 --> 00:50:14,040
and now we can Outsource all of this to

1077
00:50:14,040 --> 00:50:15,420
the cloud

1078
00:50:15,420 --> 00:50:17,040
and we're interested in the security of

1079
00:50:17,040 --> 00:50:19,859
deleted files so if the user sends the

1080
00:50:19,859 --> 00:50:21,540
request to the cloud that it would like

1081
00:50:21,540 --> 00:50:22,920
to delete file one

1082
00:50:22,920 --> 00:50:24,540
well the cloud might respond that the

1083
00:50:24,540 --> 00:50:26,040
file is deleted

1084
00:50:26,040 --> 00:50:28,500
um but since the cloud is not trusted we

1085
00:50:28,500 --> 00:50:30,000
don't actually have any guarantees that

1086
00:50:30,000 --> 00:50:31,020
this happened

1087
00:50:31,020 --> 00:50:33,180
so you know concretely the cloud might

1088
00:50:33,180 --> 00:50:34,920
be malicious and just ignore the request

1089
00:50:34,920 --> 00:50:37,079
to delete the file or even if the cloud

1090
00:50:37,079 --> 00:50:38,819
is honest it might have been compromised

1091
00:50:38,819 --> 00:50:40,740
by some external adversary that took a

1092
00:50:40,740 --> 00:50:43,079
snapshot of the ciphertext

1093
00:50:43,079 --> 00:50:44,819
it could also be the case that the file

1094
00:50:44,819 --> 00:50:46,740
is not properly deleted because of

1095
00:50:46,740 --> 00:50:49,260
backups or Disaster Recovery this is

1096
00:50:49,260 --> 00:50:51,599
actually often the case in practice or

1097
00:50:51,599 --> 00:50:52,980
that just you know it was kept around

1098
00:50:52,980 --> 00:50:55,020
because of faulty processes

1099
00:50:55,020 --> 00:50:57,660
so

1100
00:50:57,660 --> 00:50:59,520
um this is not great like we have the

1101
00:50:59,520 --> 00:51:01,619
same problem as before if the user's

1102
00:51:01,619 --> 00:51:03,660
wrapping key is is compromised then all

1103
00:51:03,660 --> 00:51:05,339
of the files including the deleted one

1104
00:51:05,339 --> 00:51:07,859
are potentially vulnerable and this is

1105
00:51:07,859 --> 00:51:09,960
not what we wanted right so that's where

1106
00:51:09,960 --> 00:51:11,460
punctual key wrapping comes to the

1107
00:51:11,460 --> 00:51:12,420
rescue

1108
00:51:12,420 --> 00:51:14,640
if the user wants to be sure that they

1109
00:51:14,640 --> 00:51:16,200
have forward security of their deleted

1110
00:51:16,200 --> 00:51:18,960
files they would generate the tag

1111
00:51:18,960 --> 00:51:20,579
corresponding to the file that they want

1112
00:51:20,579 --> 00:51:21,540
to delete

1113
00:51:21,540 --> 00:51:24,839
and then use the puncturing algorithm of

1114
00:51:24,839 --> 00:51:26,760
the punctual key wrapping scheme to

1115
00:51:26,760 --> 00:51:28,920
update the rapping key

1116
00:51:28,920 --> 00:51:31,859
and crucially replace the old copy of

1117
00:51:31,859 --> 00:51:33,420
the wrapping key with this punctured

1118
00:51:33,420 --> 00:51:34,980
version

1119
00:51:34,980 --> 00:51:37,500
because the new punctured version can no

1120
00:51:37,500 --> 00:51:39,540
longer be used to unwrap the data

1121
00:51:39,540 --> 00:51:41,099
encryption key that was used to encrypt

1122
00:51:41,099 --> 00:51:42,839
the file that you want to delete

1123
00:51:42,839 --> 00:51:45,839
so if the punctured wrapping Keys is

1124
00:51:45,839 --> 00:51:48,540
compromised then we have confidentiality

1125
00:51:48,540 --> 00:51:51,558
of the deleted file

1126
00:51:52,500 --> 00:51:54,660
so in conclusion we get fine-grained

1127
00:51:54,660 --> 00:51:56,280
forward security without the need for

1128
00:51:56,280 --> 00:51:58,859
key rotation or right rewrapping

1129
00:51:58,859 --> 00:52:00,960
and there's nothing specific about this

1130
00:52:00,960 --> 00:52:03,359
example of cloud storage punctual key

1131
00:52:03,359 --> 00:52:05,760
wrapping can be used in any place where

1132
00:52:05,760 --> 00:52:08,160
key wrapping is or key encryption is

1133
00:52:08,160 --> 00:52:10,879
currently being used

1134
00:52:11,300 --> 00:52:15,000
so with that let's wrap up

1135
00:52:15,000 --> 00:52:17,460
I presented to you punctual key wrapping

1136
00:52:17,460 --> 00:52:19,380
which is a new cryptographic primitive

1137
00:52:19,380 --> 00:52:21,480
that provides an abstraction layer

1138
00:52:21,480 --> 00:52:24,240
between these high-level applications

1139
00:52:24,240 --> 00:52:26,640
and Primitives such as puncturing and

1140
00:52:26,640 --> 00:52:28,020
encryption

1141
00:52:28,020 --> 00:52:30,000
it enables fine-grained forward security

1142
00:52:30,000 --> 00:52:32,640
and can be integrated into all

1143
00:52:32,640 --> 00:52:34,140
applications that have a key hierarchy

1144
00:52:34,140 --> 00:52:36,559
or use key wrapping

1145
00:52:36,559 --> 00:52:38,940
and if you're interested to learn more

1146
00:52:38,940 --> 00:52:41,460
in the paper we also explore various

1147
00:52:41,460 --> 00:52:43,140
security Notions for punctual

1148
00:52:43,140 --> 00:52:45,839
pseudorandom functions and the relations

1149
00:52:45,839 --> 00:52:47,819
as I said earlier we explore security

1150
00:52:47,819 --> 00:52:49,500
Notions for punctual key wrapping

1151
00:52:49,500 --> 00:52:52,260
schemes and relate them we also provide

1152
00:52:52,260 --> 00:52:54,420
an integration into TLS where we

1153
00:52:54,420 --> 00:52:56,880
recapture the work of aviram galat and

1154
00:52:56,880 --> 00:52:59,819
Jager and improve upon it

1155
00:52:59,819 --> 00:53:02,160
and we formalize all of the above in

1156
00:53:02,160 --> 00:53:03,960
security games and give proofs and

1157
00:53:03,960 --> 00:53:05,480
bounce

1158
00:53:05,480 --> 00:53:07,920
thank you for listening oh sorry yeah

1159
00:53:07,920 --> 00:53:09,540
we're full version of zombie print

1160
00:53:09,540 --> 00:53:11,040
here's the link

1161
00:53:11,040 --> 00:53:12,540
with that I want to say thank you for

1162
00:53:12,540 --> 00:53:16,099
listening and feel free to get in touch

1163
00:53:19,859 --> 00:53:21,180
thank you very much

1164
00:53:21,180 --> 00:53:26,180
uh there are any questions or comments

1165
00:53:27,960 --> 00:53:30,180
thanks for the great talk

1166
00:53:30,180 --> 00:53:31,500
um so

1167
00:53:31,500 --> 00:53:33,059
um how

1168
00:53:33,059 --> 00:53:36,359
how does the key size of the punctured

1169
00:53:36,359 --> 00:53:39,540
key grow in the number of deletions you

1170
00:53:39,540 --> 00:53:42,059
do I would assume you kind of carefully

1171
00:53:42,059 --> 00:53:45,599
choose the tech so so that deletions are

1172
00:53:45,599 --> 00:53:47,940
efficient or something like this this is

1173
00:53:47,940 --> 00:53:49,859
a really great question and

1174
00:53:49,859 --> 00:53:51,300
um of course it depends on how you

1175
00:53:51,300 --> 00:53:52,920
instantiate the punctual key wrapping

1176
00:53:52,920 --> 00:53:54,900
scheme but if you use

1177
00:53:54,900 --> 00:53:57,180
um the ggm construction for the pprf

1178
00:53:57,180 --> 00:53:59,160
then yeah you have a potentially

1179
00:53:59,160 --> 00:54:00,780
logarithmic growth

1180
00:54:00,780 --> 00:54:03,359
um in the size of the the key if you

1181
00:54:03,359 --> 00:54:05,520
choose random tags but you can choose

1182
00:54:05,520 --> 00:54:08,040
them sort of an order to get better

1183
00:54:08,040 --> 00:54:10,859
bounds on the size however

1184
00:54:10,859 --> 00:54:13,740
um at least in our treatment we we left

1185
00:54:13,740 --> 00:54:15,359
the application decide on this because

1186
00:54:15,359 --> 00:54:17,520
you can get better privacy if you choose

1187
00:54:17,520 --> 00:54:19,260
random tags

1188
00:54:19,260 --> 00:54:21,540
um than if you let it be in order so so

1189
00:54:21,540 --> 00:54:23,400
I would say that the application maybe

1190
00:54:23,400 --> 00:54:25,079
like the security is probably more

1191
00:54:25,079 --> 00:54:27,480
important than the size of the key or

1192
00:54:27,480 --> 00:54:29,280
perhaps the application besides which is

1193
00:54:29,280 --> 00:54:30,839
more important

1194
00:54:30,839 --> 00:54:34,200
um but yeah that's um that's uh sort of

1195
00:54:34,200 --> 00:54:36,300
the the generic answer is that it

1196
00:54:36,300 --> 00:54:38,040
depends on the application and on the

1197
00:54:38,040 --> 00:54:39,900
instantiation you can also think of

1198
00:54:39,900 --> 00:54:42,180
instantiating

1199
00:54:42,180 --> 00:54:44,760
um a punctual pseudorandom function for

1200
00:54:44,760 --> 00:54:46,980
example using a bloom filter in which

1201
00:54:46,980 --> 00:54:48,900
case the size of the key actually

1202
00:54:48,900 --> 00:54:51,240
decreases as you puncture because I mean

1203
00:54:51,240 --> 00:54:54,059
essentially you just throw away Keys

1204
00:54:54,059 --> 00:54:55,440
um to puncture

1205
00:54:55,440 --> 00:54:56,640
um but then you start with a large

1206
00:54:56,640 --> 00:55:00,319
secret key to begin with instead

1207
00:55:03,660 --> 00:55:06,558
any other questions

1208
00:55:12,000 --> 00:55:14,940
question from them no

1209
00:55:14,940 --> 00:55:18,820
okay so let's speak again

1210
00:55:18,820 --> 00:55:21,839
[Applause]

1211
00:55:21,839 --> 00:55:24,300
Let's Go Auto finished

1212
00:55:24,300 --> 00:55:27,079
thank you very much

