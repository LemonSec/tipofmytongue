1
00:00:01,199 --> 00:00:04,440
okay welcome to the functional and the

2
00:00:04,440 --> 00:00:07,020
witness encryption session we have four

3
00:00:07,020 --> 00:00:10,139
talks in this session the first talk is

4
00:00:10,139 --> 00:00:12,420
merge client functional encryption with

5
00:00:12,420 --> 00:00:15,179
the fine grained Access Control by key

6
00:00:15,179 --> 00:00:18,199
Gwen private points possible

7
00:00:18,199 --> 00:00:22,080
qq1 key is going to talk

8
00:00:22,080 --> 00:00:24,180
hello and thank you Rio for the

9
00:00:24,180 --> 00:00:26,939
introductions uh can you hear me well

10
00:00:26,939 --> 00:00:27,900
together

11
00:00:27,900 --> 00:00:30,300
yes so my name is key and today I would

12
00:00:30,300 --> 00:00:32,159
like to present a work on multi-plan

13
00:00:32,159 --> 00:00:34,140
functional encryption with a fire asset

14
00:00:34,140 --> 00:00:36,420
control so this is a joint work with you

15
00:00:36,420 --> 00:00:39,140
here fan and David

16
00:00:47,059 --> 00:00:49,739
okay so first I will give the

17
00:00:49,739 --> 00:00:51,420
motivations and the context of our paper

18
00:00:51,420 --> 00:00:54,120
and then the relative works in the

19
00:00:54,120 --> 00:00:56,460
literature followed by our contributions

20
00:00:56,460 --> 00:00:58,140
and in the second part of the talk I

21
00:00:58,140 --> 00:01:00,140
will give some technical overview of our

22
00:01:00,140 --> 00:01:03,660
constructions and uh some uh high-level

23
00:01:03,660 --> 00:01:06,320
technical ideas

24
00:01:06,780 --> 00:01:09,360
so the starting point is the owner

25
00:01:09,360 --> 00:01:11,159
signature of a public key encryption

26
00:01:11,159 --> 00:01:14,159
that is given a certification Key that

27
00:01:14,159 --> 00:01:17,340
you recruit and get the Hopeland Texas

28
00:01:17,340 --> 00:01:18,840
or nothing

29
00:01:18,840 --> 00:01:20,520
later there is the Notions of

30
00:01:20,520 --> 00:01:22,619
attribute-wise encryptions that give

31
00:01:22,619 --> 00:01:25,159
some control

32
00:01:25,740 --> 00:01:27,960
if the policy in the key is satisfied

33
00:01:27,960 --> 00:01:29,939
and you can decrypt and get the appendix

34
00:01:29,939 --> 00:01:33,780
as nothing and more than a decade ago

35
00:01:33,780 --> 00:01:34,979
there is notion of functional

36
00:01:34,979 --> 00:01:37,799
encryptions in which you control the

37
00:01:37,799 --> 00:01:39,659
quantity of information about the plant

38
00:01:39,659 --> 00:01:43,920
text through the function evaluation

39
00:01:43,920 --> 00:01:46,400
however one observation is that on this

40
00:01:46,400 --> 00:01:50,159
secret equipment is their usage can be

41
00:01:50,159 --> 00:01:52,560
Unlimited in the way that the recruiter

42
00:01:52,560 --> 00:01:56,240
can use them in whatever way he wants

43
00:01:56,640 --> 00:01:59,460
and in this work we focus on

44
00:01:59,460 --> 00:02:01,259
on functional encryptions in the

45
00:02:01,259 --> 00:02:02,820
multi-user setting

46
00:02:02,820 --> 00:02:05,399
so there are two main notable Notions

47
00:02:05,399 --> 00:02:06,719
that is the multi-input and the

48
00:02:06,719 --> 00:02:07,799
multi-client

49
00:02:07,799 --> 00:02:09,119
so there are various Notions of

50
00:02:09,119 --> 00:02:10,919
multi-input

51
00:02:10,919 --> 00:02:13,739
so but in this work we consider them to

52
00:02:13,739 --> 00:02:15,720
be the every schemes where the plant

53
00:02:15,720 --> 00:02:17,340
types can be encrypted

54
00:02:17,340 --> 00:02:19,319
component by components and their

55
00:02:19,319 --> 00:02:23,099
components can be combined arbitrary

56
00:02:23,099 --> 00:02:24,840
using a functional decryption key to get

57
00:02:24,840 --> 00:02:26,760
a functional evaluation

58
00:02:26,760 --> 00:02:28,680
on the other hand is also the notion of

59
00:02:28,680 --> 00:02:31,080
multi-client functional encryption that

60
00:02:31,080 --> 00:02:32,580
is there are multiple clients in the

61
00:02:32,580 --> 00:02:34,200
system each of them has their own

62
00:02:34,200 --> 00:02:35,940
private encryption key

63
00:02:35,940 --> 00:02:38,160
and they can increase the individual

64
00:02:38,160 --> 00:02:40,020
data independently

65
00:02:40,020 --> 00:02:42,900
under some specified type

66
00:02:42,900 --> 00:02:46,080
which can be some timestamp metadata for

67
00:02:46,080 --> 00:02:46,920
example

68
00:02:46,920 --> 00:02:49,140
and in the end a functional decryption

69
00:02:49,140 --> 00:02:50,220
key

70
00:02:50,220 --> 00:02:51,900
allows combining all the surface

71
00:02:51,900 --> 00:02:55,200
components only if on the partial

72
00:02:55,200 --> 00:02:57,599
ciphertext

73
00:02:57,599 --> 00:03:00,480
I encrypted using the the same type

74
00:03:00,480 --> 00:03:03,000
so this limits the absolute combinations

75
00:03:03,000 --> 00:03:06,900
resulted from the MIT for instance

76
00:03:06,900 --> 00:03:09,000
and the problem with the unlimited usage

77
00:03:09,000 --> 00:03:11,819
of the different Keys three boxes in

78
00:03:11,819 --> 00:03:14,238
this setting

79
00:03:15,000 --> 00:03:18,540
so our goal is to enforce

80
00:03:18,540 --> 00:03:20,519
some five grand control over the

81
00:03:20,519 --> 00:03:23,760
decryption keys that is we associate

82
00:03:23,760 --> 00:03:26,159
a policy in the key

83
00:03:26,159 --> 00:03:29,400
and at encryption timer explained in the

84
00:03:29,400 --> 00:03:32,239
MCV setting will encrypt the password

85
00:03:32,239 --> 00:03:35,940
text under some specified attributes

86
00:03:35,940 --> 00:03:39,360
and uh only when all clients attribute

87
00:03:39,360 --> 00:03:42,299
satisfy the keys policy we will be able

88
00:03:42,299 --> 00:03:45,000
to attend the function evaluation

89
00:03:45,000 --> 00:03:49,140
on this on the combined plan text

90
00:03:49,140 --> 00:03:52,700
otherwise we attend nothing

91
00:03:53,099 --> 00:03:55,019
in particular in this work we consider

92
00:03:55,019 --> 00:03:56,760
the function class that allows Computing

93
00:03:56,760 --> 00:03:59,220
inner products and a second tone can be

94
00:03:59,220 --> 00:04:02,840
expressed using linear security settings

95
00:04:06,680 --> 00:04:10,560
that this mcfe with firing a second term

96
00:04:10,560 --> 00:04:12,659
can be captured by the general Notions

97
00:04:12,659 --> 00:04:17,040
of ncf if the class of functions can

98
00:04:17,040 --> 00:04:20,540
express the the second term

99
00:04:21,660 --> 00:04:24,660
so once might by the way wonder why mcf

100
00:04:24,660 --> 00:04:27,960
why we focus on the multi-claim version

101
00:04:27,960 --> 00:04:31,080
so first of all in our

102
00:04:31,080 --> 00:04:32,880
particular constructions for inner

103
00:04:32,880 --> 00:04:35,280
products and LSS

104
00:04:35,280 --> 00:04:37,680
we treat the attack by hashing them and

105
00:04:37,680 --> 00:04:40,259
so if we fix and publish this this last

106
00:04:40,259 --> 00:04:41,100
value

107
00:04:41,100 --> 00:04:43,500
the notion of tag becomes somewhat

108
00:04:43,500 --> 00:04:47,660
transparent and we obtain an miscuit

109
00:04:48,780 --> 00:04:50,880
on the other hand

110
00:04:50,880 --> 00:04:55,080
in the outer reactions even mif or inner

111
00:04:55,080 --> 00:04:56,699
product with LSS

112
00:04:56,699 --> 00:05:01,199
if we want to to obtain an mcap scheme

113
00:05:01,199 --> 00:05:03,540
because and in the MIP there is no

114
00:05:03,540 --> 00:05:05,820
notion of time whatsoever we need to

115
00:05:05,820 --> 00:05:08,160
include some

116
00:05:08,160 --> 00:05:10,800
equality check for the tax

117
00:05:10,800 --> 00:05:12,780
and it turns out to be

118
00:05:12,780 --> 00:05:14,639
invisible in this case for this

119
00:05:14,639 --> 00:05:16,979
particular person class to compute inner

120
00:05:16,979 --> 00:05:18,419
products

121
00:05:18,419 --> 00:05:20,220
with the LSS

122
00:05:20,220 --> 00:05:22,940
asset control

123
00:05:23,520 --> 00:05:26,820
uh even in the case of simple policy

124
00:05:26,820 --> 00:05:29,639
like identity device and I refer to your

125
00:05:29,639 --> 00:05:32,100
paper for more details and discussion on

126
00:05:32,100 --> 00:05:35,120
this technical form

127
00:05:35,940 --> 00:05:37,680
so therefore I will now becomes

128
00:05:37,680 --> 00:05:40,020
constructing mcfe schemes to compute

129
00:05:40,020 --> 00:05:42,660
inner products with asset control using

130
00:05:42,660 --> 00:05:45,320
linear secretary

131
00:05:45,720 --> 00:05:49,460
in the literatures at icr320 uh

132
00:05:49,460 --> 00:05:52,320
sorry this problem of Fe plus a second

133
00:05:52,320 --> 00:05:54,240
drones

134
00:05:54,240 --> 00:05:56,580
and they propose several candidates

135
00:05:56,580 --> 00:05:59,160
using pairings and learning errors where

136
00:05:59,160 --> 00:06:00,600
their side controls can be expressed

137
00:06:00,600 --> 00:06:04,039
using monotone spine programs

138
00:06:04,440 --> 00:06:06,060
in the end the

139
00:06:06,060 --> 00:06:08,220
guys also a generic transformation from

140
00:06:08,220 --> 00:06:12,479
single clients f is key to mie scheme

141
00:06:12,479 --> 00:06:14,400
with adaptive security and quadratic

142
00:06:14,400 --> 00:06:17,100
total communication

143
00:06:17,100 --> 00:06:19,860
in this course we study this problem in

144
00:06:19,860 --> 00:06:21,479
the setting of mcfe

145
00:06:21,479 --> 00:06:23,340
where the asset control can be expressed

146
00:06:23,340 --> 00:06:26,639
using in a secretary schemes they can be

147
00:06:26,639 --> 00:06:28,199
identified with the underlying models of

148
00:06:28,199 --> 00:06:29,759
spine programs

149
00:06:29,759 --> 00:06:32,759
and uh we attend adaptive Security in

150
00:06:32,759 --> 00:06:34,199
the random article model and linear

151
00:06:34,199 --> 00:06:36,479
total Communications and as I've

152
00:06:36,479 --> 00:06:39,120
mentioned earlier we can reduce an MI

153
00:06:39,120 --> 00:06:41,340
away schema by fixing and Publishing the

154
00:06:41,340 --> 00:06:42,900
last value

155
00:06:42,900 --> 00:06:45,060
and while preserving on the advantage

156
00:06:45,060 --> 00:06:48,539
regarding the security level or

157
00:06:48,539 --> 00:06:52,400
other total communication

158
00:06:54,000 --> 00:06:55,620
so let's move on to the formal

159
00:06:55,620 --> 00:06:57,720
definitions of mcfe with a pattern

160
00:06:57,720 --> 00:06:59,120
Access Control

161
00:06:59,120 --> 00:07:02,280
is expressed using the relations between

162
00:07:02,280 --> 00:07:06,979
uh key policy and uh

163
00:07:06,979 --> 00:07:10,199
attributes put inside the independence

164
00:07:10,199 --> 00:07:13,560
and safety components by end clients

165
00:07:13,560 --> 00:07:16,020
so they exists and Authority given a

166
00:07:16,020 --> 00:07:17,639
function description

167
00:07:17,639 --> 00:07:20,419
and the policy we output the key

168
00:07:20,419 --> 00:07:22,680
corresponding to this policy and the

169
00:07:22,680 --> 00:07:24,479
functions

170
00:07:24,479 --> 00:07:27,479
and our own clients each of them having

171
00:07:27,479 --> 00:07:30,240
the private encryption key

172
00:07:30,240 --> 00:07:33,660
we'll use the AKA to encrypt the partial

173
00:07:33,660 --> 00:07:35,460
cyber attacks

174
00:07:35,460 --> 00:07:38,639
and the correctness requires that only

175
00:07:38,639 --> 00:07:40,919
when on client attributes satisfy the

176
00:07:40,919 --> 00:07:42,720
keys policies we will be able to obtain

177
00:07:42,720 --> 00:07:45,620
the functional evaluation

178
00:07:48,000 --> 00:07:50,580
furthermore about the security model is

179
00:07:50,580 --> 00:07:52,620
this an interactive security game

180
00:07:52,620 --> 00:07:55,020
between adversary

181
00:07:55,020 --> 00:07:58,020
and a challenger who picks a random

182
00:07:58,020 --> 00:07:58,759
Mission

183
00:07:58,759 --> 00:08:02,099
adversary is allowed to queries for

184
00:08:02,099 --> 00:08:04,380
multiple times functional decryption

185
00:08:04,380 --> 00:08:05,460
keys

186
00:08:05,460 --> 00:08:07,680
corresponding to

187
00:08:07,680 --> 00:08:11,340
policies and functions of his choice

188
00:08:11,340 --> 00:08:13,620
moreover in discussing of multi-client

189
00:08:13,620 --> 00:08:15,240
functional encryption there are multiple

190
00:08:15,240 --> 00:08:17,340
clients each of them has the private

191
00:08:17,340 --> 00:08:20,099
encryption key therefore the adversaries

192
00:08:20,099 --> 00:08:22,680
is also able to corrupt a client and

193
00:08:22,680 --> 00:08:26,099
receive the corresponding encryption key

194
00:08:26,099 --> 00:08:28,940
for multiple times

195
00:08:29,160 --> 00:08:31,919
and the diversary can also

196
00:08:31,919 --> 00:08:33,958
Remain the challenge of attacks or two

197
00:08:33,958 --> 00:08:36,599
channel factors x0x1 component by

198
00:08:36,599 --> 00:08:39,779
components under some specified tag and

199
00:08:39,779 --> 00:08:42,360
attributes to receive the general server

200
00:08:42,360 --> 00:08:43,740
text

201
00:08:43,740 --> 00:08:45,440
before the moon we restrict that

202
00:08:45,440 --> 00:08:50,279
diversity can only use one challenge

203
00:08:50,279 --> 00:08:54,060
but we allow him to query an encryption

204
00:08:54,060 --> 00:08:57,600
Oracle to encrypt data of his choice

205
00:08:57,600 --> 00:09:00,240
or

206
00:09:00,240 --> 00:09:02,160
arbitrary clients

207
00:09:02,160 --> 00:09:06,120
and uh you can do this multiple times

208
00:09:06,120 --> 00:09:08,480
so using a Sun hybrid argument is

209
00:09:08,480 --> 00:09:13,459
equivalent to the multi-challenge notion

210
00:09:13,500 --> 00:09:15,899
and in the anniversary I put again for

211
00:09:15,899 --> 00:09:18,800
the challenge with

212
00:09:19,200 --> 00:09:22,500
so we can have various weaker Notions by

213
00:09:22,500 --> 00:09:24,660
restricting the bursary to declare

214
00:09:24,660 --> 00:09:27,540
upfront return inquiries

215
00:09:27,540 --> 00:09:31,939
are the corruption queries

216
00:09:33,000 --> 00:09:36,360
and moreover in this security model

217
00:09:36,360 --> 00:09:39,060
the functional Keys might allow the

218
00:09:39,060 --> 00:09:41,220
adversary to decrypt the challenge type

219
00:09:41,220 --> 00:09:42,360
attacks

220
00:09:42,360 --> 00:09:46,040
and therefore if this is the case

221
00:09:46,080 --> 00:09:48,120
we constrained that the two inner

222
00:09:48,120 --> 00:09:49,680
products of the two challenge factors

223
00:09:49,680 --> 00:09:52,399
must be the same

224
00:09:54,540 --> 00:09:56,160
so before going to the technical

225
00:09:56,160 --> 00:09:58,260
overview I recall some technical tools

226
00:09:58,260 --> 00:10:00,600
that we use so maybe they do a pairing

227
00:10:00,600 --> 00:10:03,080
better spices

228
00:10:03,540 --> 00:10:05,940
so we're in a prime order really in a

229
00:10:05,940 --> 00:10:07,620
group written additively

230
00:10:07,620 --> 00:10:11,300
and we consider some basis Matrix

231
00:10:11,300 --> 00:10:13,740
with some public relatives and beverage

232
00:10:13,740 --> 00:10:16,339
providers

233
00:10:21,860 --> 00:10:25,320
G1 and G2 we have two

234
00:10:25,320 --> 00:10:29,700
matrices of elements in G1 and in G2

235
00:10:29,700 --> 00:10:32,580
so these are called the Dual basis quite

236
00:10:32,580 --> 00:10:34,860
spicy

237
00:10:34,860 --> 00:10:37,680
and given these two matrices we can have

238
00:10:37,680 --> 00:10:40,019
some notion of factors of elements and

239
00:10:40,019 --> 00:10:42,300
Define their products

240
00:10:42,300 --> 00:10:44,279
by simply taking the parents component

241
00:10:44,279 --> 00:10:48,420
by component and adding up together

242
00:10:48,420 --> 00:10:51,360
so in the end the result is the an

243
00:10:51,360 --> 00:10:53,220
element utility whose exponent is the

244
00:10:53,220 --> 00:10:54,480
inner product of the two underlying

245
00:10:54,480 --> 00:10:56,839
vectors

246
00:10:58,920 --> 00:11:01,019
so being equipped by these two let's

247
00:11:01,019 --> 00:11:03,779
move on to a single client scheme

248
00:11:03,779 --> 00:11:06,060
so there's only one client

249
00:11:06,060 --> 00:11:09,480
and the surface consists of

250
00:11:09,480 --> 00:11:12,839
multiple IRS

251
00:11:12,839 --> 00:11:15,959
effects that is from the celebrated in

252
00:11:15,959 --> 00:11:18,120
the product function encryption by uh

253
00:11:18,120 --> 00:11:21,120
foreign

254
00:11:34,830 --> 00:11:42,409
[Music]

255
00:11:42,839 --> 00:11:44,940
on the other hand in the key

256
00:11:44,940 --> 00:11:48,120
we use the ARs to secretly share a

257
00:11:48,120 --> 00:11:50,880
random Secrets I zero

258
00:11:50,880 --> 00:11:53,400
foreign

259
00:11:53,400 --> 00:11:56,539
[Music]

260
00:12:05,779 --> 00:12:08,640
operations between vectors if we're

261
00:12:08,640 --> 00:12:11,640
summing up the products over attributes

262
00:12:11,640 --> 00:12:14,040
in a reconstruction set for the AOS for

263
00:12:14,040 --> 00:12:16,440
the aosss

264
00:12:16,440 --> 00:12:18,779
we will have a PSI times I zero in the

265
00:12:18,779 --> 00:12:21,899
exponent of GT

266
00:12:21,899 --> 00:12:25,560
and uh we can recover the unmasking

267
00:12:25,560 --> 00:12:30,319
value of the IRS decryption procedure

268
00:12:30,660 --> 00:12:33,480
and in the end we can recover the inner

269
00:12:33,480 --> 00:12:35,760
product of ice

270
00:12:35,760 --> 00:12:39,200
using the user iOS

271
00:12:41,339 --> 00:12:42,980
about the security

272
00:12:42,980 --> 00:12:46,980
we we perform using a game-wise proof

273
00:12:46,980 --> 00:12:49,800
where the changes are done by basic

274
00:12:49,800 --> 00:12:50,639
change

275
00:12:50,639 --> 00:12:53,339
in the dpbs framework

276
00:12:53,339 --> 00:12:56,760
and the main idea is to embed a newly

277
00:12:56,760 --> 00:12:59,880
generated secret settings of another a0

278
00:12:59,880 --> 00:13:01,440
Prime security

279
00:13:01,440 --> 00:13:04,260
in uh the staff attacks and the key

280
00:13:04,260 --> 00:13:06,000
inspector

281
00:13:06,000 --> 00:13:09,920
and mass by some random values yeah

282
00:13:12,600 --> 00:13:14,760
so some subtlety is that in these

283
00:13:14,760 --> 00:13:17,279
scenarios we can be in two cases where

284
00:13:17,279 --> 00:13:18,839
the key can decrypt the channels of

285
00:13:18,839 --> 00:13:19,980
attacks

286
00:13:19,980 --> 00:13:22,380
and in that case we can apply some

287
00:13:22,380 --> 00:13:23,880
ability techniques such as the Dual

288
00:13:23,880 --> 00:13:26,600
system method

289
00:13:26,660 --> 00:13:29,399
oh it can recruit with general staff

290
00:13:29,399 --> 00:13:31,380
attacks but we constrained that the

291
00:13:31,380 --> 00:13:34,079
entires in the product would Y whereinx

292
00:13:34,079 --> 00:13:35,820
is the difference between the two

293
00:13:35,820 --> 00:13:37,380
channel vectors

294
00:13:37,380 --> 00:13:40,980
these inner products must be zero

295
00:13:40,980 --> 00:13:43,139
and in the Adaptive security setting we

296
00:13:43,139 --> 00:13:45,480
want to know which case we will be

297
00:13:45,480 --> 00:13:49,040
the cause of simulation

298
00:13:49,700 --> 00:13:53,579
is if this inverter is not zero

299
00:13:53,579 --> 00:13:55,980
then it

300
00:13:55,980 --> 00:13:58,320
this key cannot equip the challenge of

301
00:13:58,320 --> 00:14:00,060
attacks

302
00:14:00,060 --> 00:14:03,360
and therefore we invest term by terms

303
00:14:03,360 --> 00:14:06,660
the Delta x i times y i

304
00:14:06,660 --> 00:14:09,420
along with the secret settings in the

305
00:14:09,420 --> 00:14:12,060
the key and the ciphertext

306
00:14:12,060 --> 00:14:15,660
for both the the attributes vectors and

307
00:14:15,660 --> 00:14:19,459
the c0 k0 vectors

308
00:14:20,339 --> 00:14:22,560
and in the end

309
00:14:22,560 --> 00:14:24,959
thanks to this secret settings and the

310
00:14:24,959 --> 00:14:27,060
random Mass Effect

311
00:14:27,060 --> 00:14:29,760
we can randomize the iso Prime

312
00:14:29,760 --> 00:14:32,220
to a newly azero Prime independent

313
00:14:32,220 --> 00:14:34,019
Secret

314
00:14:34,019 --> 00:14:35,639
that allow us to modify the challenge

315
00:14:35,639 --> 00:14:37,920
server text to be independent of the of

316
00:14:37,920 --> 00:14:40,519
the channel bit

317
00:14:42,779 --> 00:14:45,779
and finally because we need to embed

318
00:14:45,779 --> 00:14:48,120
term by terms the inner products of

319
00:14:48,120 --> 00:14:50,579
dental X and Y we need at least n

320
00:14:50,579 --> 00:14:52,260
coordinates in the

321
00:14:52,260 --> 00:14:54,240
key and psychotic vectors

322
00:14:54,240 --> 00:14:55,860
and therefore that's self-attack size

323
00:14:55,860 --> 00:14:59,579
increases to linear in n

324
00:14:59,579 --> 00:15:01,920
and also depend depending on the number

325
00:15:01,920 --> 00:15:05,180
of attributes needed

326
00:15:07,320 --> 00:15:09,720
in particular if we are in a Soon

327
00:15:09,720 --> 00:15:12,420
non-trivial Simple a second term

328
00:15:12,420 --> 00:15:15,000
identity device D can be equal to one

329
00:15:15,000 --> 00:15:17,339
and we obtain something linear in m

330
00:15:17,339 --> 00:15:19,740
and more details can be found in session

331
00:15:19,740 --> 00:15:22,459
five above

332
00:15:25,620 --> 00:15:28,079
so that's for the single clients

333
00:15:28,079 --> 00:15:31,500
towards the multi-clens we use technical

334
00:15:31,500 --> 00:15:33,360
ideas that we call

335
00:15:33,360 --> 00:15:37,459
own compressed and lubricator

336
00:15:37,680 --> 00:15:40,139
so namely if we

337
00:15:40,139 --> 00:15:43,320
nicely duplicate all the format of the

338
00:15:43,320 --> 00:15:45,300
key and the ciphertext vectors

339
00:15:45,300 --> 00:15:47,940
from the single Clan to the multi-client

340
00:15:47,940 --> 00:15:50,399
then we will have something quadratic in

341
00:15:50,399 --> 00:15:52,199
end because the vectors are already

342
00:15:52,199 --> 00:15:56,719
observed size linear

343
00:15:56,880 --> 00:15:58,980
so the main

344
00:15:58,980 --> 00:16:01,500
observations is that we can compress the

345
00:16:01,500 --> 00:16:03,540
attribute

346
00:16:03,540 --> 00:16:07,320
vectors into the same basis F star and F

347
00:16:07,320 --> 00:16:08,940
for own clients

348
00:16:08,940 --> 00:16:11,880
thanks to the indexing technique in dpbs

349
00:16:11,880 --> 00:16:15,600
also introduced by okamoto and takashima

350
00:16:15,600 --> 00:16:18,300
and each client Aya

351
00:16:18,300 --> 00:16:20,279
will

352
00:16:20,279 --> 00:16:22,980
be embedded the newly Secret Sales

353
00:16:22,980 --> 00:16:26,820
together with Yi only and we do not need

354
00:16:26,820 --> 00:16:29,639
to accommodate on the end terms in one

355
00:16:29,639 --> 00:16:32,100
single vectors anymore

356
00:16:32,100 --> 00:16:35,399
and the same thing can be done for for

357
00:16:35,399 --> 00:16:37,920
the k0 and c0 vectors

358
00:16:37,920 --> 00:16:41,639
where we duplicate h i and h i star for

359
00:16:41,639 --> 00:16:43,680
each client

360
00:16:43,680 --> 00:16:46,560
and then HCL and I deal with the terms y

361
00:16:46,560 --> 00:16:51,018
i times Delta X Y Delta s i

362
00:16:51,300 --> 00:16:54,240
and we obtain a constant auxiliary

363
00:16:54,240 --> 00:16:57,360
number of coordinates for each client

364
00:16:57,360 --> 00:17:00,120
and each attribute if needed

365
00:17:00,120 --> 00:17:02,220
and in the end the total communication

366
00:17:02,220 --> 00:17:05,880
reduces to linear name

367
00:17:05,880 --> 00:17:08,160
so I refer also to the session 5 of

368
00:17:08,160 --> 00:17:11,959
paper for more details on this technique

369
00:17:12,480 --> 00:17:15,359
and to conclude we propose mCP

370
00:17:15,359 --> 00:17:17,280
candidates to compute inner products

371
00:17:17,280 --> 00:17:19,679
with asset controls using linear

372
00:17:19,679 --> 00:17:21,900
security settings achieving adaptive

373
00:17:21,900 --> 00:17:23,760
Security in the random Oracle model

374
00:17:23,760 --> 00:17:25,439
and uh

375
00:17:25,439 --> 00:17:27,599
linear total Communications

376
00:17:27,599 --> 00:17:29,340
and the letters is thanks to the

377
00:17:29,340 --> 00:17:31,020
compressed and duplicates to this

378
00:17:31,020 --> 00:17:33,360
technical idea we developed along the

379
00:17:33,360 --> 00:17:34,559
process

380
00:17:34,559 --> 00:17:37,580
thank you for your attention

381
00:17:43,260 --> 00:17:45,539
are there any question

382
00:17:45,539 --> 00:17:49,760
we have plenty of time for questions

383
00:17:56,400 --> 00:18:00,059
so I think see I see why do you need the

384
00:18:00,059 --> 00:18:04,020
the London why do you need uh

385
00:18:04,020 --> 00:18:05,520
pass

386
00:18:05,520 --> 00:18:07,080
or

387
00:18:07,080 --> 00:18:09,900
so is it crucial for achieving adaptive

388
00:18:09,900 --> 00:18:13,400
security or compressing communication

389
00:18:13,400 --> 00:18:17,760
complexity both because we use the the

390
00:18:17,760 --> 00:18:19,980
random model code to Hash the tank and

391
00:18:19,980 --> 00:18:22,020
derive the randomness to put in the sub

392
00:18:22,020 --> 00:18:24,080
attacks

393
00:18:24,080 --> 00:18:28,140
so yeah so okay so to

394
00:18:28,140 --> 00:18:31,500
from the data to data mystery uh

395
00:18:31,500 --> 00:18:35,580
generate uh common Randomness okay and

396
00:18:35,580 --> 00:18:37,140
uh in the literature they also exist

397
00:18:37,140 --> 00:18:40,860
works on mcfe that does not require a

398
00:18:40,860 --> 00:18:45,059
numerical and uh is using uh Adobe

399
00:18:45,059 --> 00:18:49,160
techniques and not the pairing device

400
00:18:50,820 --> 00:18:54,080
any other question

401
00:18:57,780 --> 00:19:00,620
no

402
00:19:00,780 --> 00:19:04,559
okay so let's let's speak again thank

403
00:19:04,559 --> 00:19:06,740
you

404
00:19:17,820 --> 00:19:21,059
the next talk is compact Fe for

405
00:19:21,059 --> 00:19:23,700
unbounded attribute weighted Sun for

406
00:19:23,700 --> 00:19:28,260
sums for log space from sxgh by pratish

407
00:19:28,260 --> 00:19:30,740
data

408
00:19:32,299 --> 00:19:35,900
is going to talk

409
00:20:08,160 --> 00:20:10,860
I am Tapas and I will present our paper

410
00:20:10,860 --> 00:20:13,559
compact Fe for unbounded attribute to

411
00:20:13,559 --> 00:20:16,440
edit sums for logspace from A6 page it's

412
00:20:16,440 --> 00:20:19,280
a joint work with

413
00:20:20,280 --> 00:20:22,559
so in functional encryption we have a

414
00:20:22,559 --> 00:20:24,480
setup Authority who generates a master

415
00:20:24,480 --> 00:20:27,660
public mpk and a master security using

416
00:20:27,660 --> 00:20:30,059
NSK The Authority can compute a secret

417
00:20:30,059 --> 00:20:32,580
key if corresponding to any article

418
00:20:32,580 --> 00:20:35,340
function if and distributes it to the

419
00:20:35,340 --> 00:20:38,418
users of the system

420
00:20:43,799 --> 00:20:48,059
a user now decrypts CTL using SKF and

421
00:20:48,059 --> 00:20:49,740
learns the functional value of the

422
00:20:49,740 --> 00:20:51,120
message

423
00:20:51,120 --> 00:20:53,460
the simulation security is the most

424
00:20:53,460 --> 00:20:56,220
recent notion of security at least

425
00:20:56,220 --> 00:20:58,559
according to the literature so it

426
00:20:58,559 --> 00:21:01,559
roughly says that uh given a set of uh

427
00:21:01,559 --> 00:21:04,020
secret Keys escape on escape to Escape 3

428
00:21:04,020 --> 00:21:07,440
so on the adversary can only recover the

429
00:21:07,440 --> 00:21:09,360
functional values of the messaging and

430
00:21:09,360 --> 00:21:11,460
nothing else about the message M from

431
00:21:11,460 --> 00:21:13,520
this hypertext CPM

432
00:21:13,520 --> 00:21:15,960
in this work we consider adaptive

433
00:21:15,960 --> 00:21:18,179
simulation security and it is uh

434
00:21:18,179 --> 00:21:20,039
formalized by the following set of

435
00:21:20,039 --> 00:21:21,179
algorithms

436
00:21:21,179 --> 00:21:23,340
so here pre-channel secret keys are

437
00:21:23,340 --> 00:21:25,679
generated using a simulated Master

438
00:21:25,679 --> 00:21:28,679
circuit chemistry star and the challenge

439
00:21:28,679 --> 00:21:30,840
Cipher text is computed using Ms Crystal

440
00:21:30,840 --> 00:21:33,600
and statisty which contains functional

441
00:21:33,600 --> 00:21:37,200
values of the message in that are query

442
00:21:37,200 --> 00:21:40,620
detail then the adversary can also query

443
00:21:40,620 --> 00:21:43,020
post challenge secret keys and these are

444
00:21:43,020 --> 00:21:45,419
answered using the functional values of

445
00:21:45,419 --> 00:21:46,799
the message

446
00:21:46,799 --> 00:21:50,039
and we say that if he is adaptively

447
00:21:50,039 --> 00:21:52,320
simulation secure if these two sets of

448
00:21:52,320 --> 00:21:54,659
algorithm are computationally

449
00:21:54,659 --> 00:21:56,580
indistinguishable

450
00:21:56,580 --> 00:21:58,260
so simulation security can also be

451
00:21:58,260 --> 00:22:00,179
classified into bounded or full

452
00:22:00,179 --> 00:22:02,280
correlation resonance setting in bounded

453
00:22:02,280 --> 00:22:04,380
Collision resistance uh adversity is

454
00:22:04,380 --> 00:22:06,539
only restricted to query a bounded

455
00:22:06,539 --> 00:22:09,179
number of Securities for us full

456
00:22:09,179 --> 00:22:11,760
Collision resistance setting gives the

457
00:22:11,760 --> 00:22:14,820
adversary of full Freedom uh where he

458
00:22:14,820 --> 00:22:17,460
can query any polynomial number of

459
00:22:17,460 --> 00:22:19,799
circuit is both before and after the

460
00:22:19,799 --> 00:22:21,860
challenge cycle text

461
00:22:21,860 --> 00:22:25,020
so um if he has been constructed for

462
00:22:25,020 --> 00:22:27,179
General class of functions for example

463
00:22:27,179 --> 00:22:29,760
during machines are all circuits however

464
00:22:29,760 --> 00:22:31,500
these constructions are mostly

465
00:22:31,500 --> 00:22:34,620
inefficient and or impractical these are

466
00:22:34,620 --> 00:22:37,020
bounded Collision resistant and security

467
00:22:37,020 --> 00:22:40,140
can be based on uh heavy cryptographic

468
00:22:40,140 --> 00:22:42,000
tools such as indistinguishability of a

469
00:22:42,000 --> 00:22:43,740
station or service initial security of

470
00:22:43,740 --> 00:22:44,760
Elder

471
00:22:44,760 --> 00:22:47,039
so as a result Community also Focus to

472
00:22:47,039 --> 00:22:48,840
build a fee for specific class of

473
00:22:48,840 --> 00:22:50,580
functions for example linear quadratic

474
00:22:50,580 --> 00:22:52,980
functions and their variants and these

475
00:22:52,980 --> 00:22:55,860
constructions are efficient simple they

476
00:22:55,860 --> 00:22:58,020
are full Collision resistant and the

477
00:22:58,020 --> 00:23:00,000
security can be based on simple and

478
00:23:00,000 --> 00:23:02,039
standard assumptions such as TDH scalene

479
00:23:02,039 --> 00:23:04,679
or LW and more importantly these

480
00:23:04,679 --> 00:23:07,080
constructions can be deployed in

481
00:23:07,080 --> 00:23:07,980
practice

482
00:23:07,980 --> 00:23:11,460
so this work focuses uh to advance the

483
00:23:11,460 --> 00:23:14,419
Fe for specific plus a function namely

484
00:23:14,419 --> 00:23:16,799
attributivated sums introduced by

485
00:23:16,799 --> 00:23:18,419
Abdullah gong and

486
00:23:18,419 --> 00:23:20,100
so here we generated secret key

487
00:23:20,100 --> 00:23:21,720
corresponding to a function f which

488
00:23:21,720 --> 00:23:23,940
takes input a vector of length name and

489
00:23:23,940 --> 00:23:26,340
outputs a vector of length n and message

490
00:23:26,340 --> 00:23:29,280
consists of a total x and z here we call

491
00:23:29,280 --> 00:23:32,220
Ax as public attribute and Z as a

492
00:23:32,220 --> 00:23:34,260
private attribute the functionality

493
00:23:34,260 --> 00:23:36,299
outputs in a product between two vectors

494
00:23:36,299 --> 00:23:38,900
f x and C

495
00:23:38,900 --> 00:23:42,240
so the state of the odd for a w is

496
00:23:42,240 --> 00:23:45,179
consider function class to be only ABP

497
00:23:45,179 --> 00:23:47,640
or arithmetic branching program Master

498
00:23:47,640 --> 00:23:50,520
public is size depends on both x and z

499
00:23:50,520 --> 00:23:52,919
ciphertric size depends on Z

500
00:23:52,919 --> 00:23:55,100
although the first work of of the later

501
00:23:55,100 --> 00:23:57,539
considered only uh semi-adaptive

502
00:23:57,539 --> 00:23:59,640
simulation security model which is

503
00:23:59,640 --> 00:24:01,200
little bit weaker than adaptive

504
00:24:01,200 --> 00:24:04,020
simulation model we last year showed

505
00:24:04,020 --> 00:24:05,700
that how to achieve adaptive simulation

506
00:24:05,700 --> 00:24:08,940
security for AWS but now cyphatic size

507
00:24:08,940 --> 00:24:11,220
depends on both X and C

508
00:24:11,220 --> 00:24:13,860
and why these AWS is interesting because

509
00:24:13,860 --> 00:24:16,500
it has many applications in the sense

510
00:24:16,500 --> 00:24:19,260
that it already captures existing

511
00:24:19,260 --> 00:24:21,840
important Fe schemes such as ipfe or

512
00:24:21,840 --> 00:24:23,580
inner product functional encryption ape

513
00:24:23,580 --> 00:24:25,980
or attribute based encryption a b ipfe

514
00:24:25,980 --> 00:24:27,299
or attribute based on our product

515
00:24:27,299 --> 00:24:28,919
functional inclusion

516
00:24:28,919 --> 00:24:31,860
however the current structure of AWS has

517
00:24:31,860 --> 00:24:34,559
several limitations so it is defined in

518
00:24:34,559 --> 00:24:36,780
non-uniform or non-dynamic model

519
00:24:36,780 --> 00:24:38,760
setup is kind of bounded that means

520
00:24:38,760 --> 00:24:40,919
Master public size not only depends on

521
00:24:40,919 --> 00:24:42,780
security parameter Lambda but also both

522
00:24:42,780 --> 00:24:46,440
on x and z and Cipher text is also not

523
00:24:46,440 --> 00:24:48,720
input specifically as a result it

524
00:24:48,720 --> 00:24:50,820
captures only bounded Fe schemes such as

525
00:24:50,820 --> 00:24:54,600
ipfe Abe where functions takes input or

526
00:24:54,600 --> 00:24:55,679
boundary

527
00:24:55,679 --> 00:24:57,600
so let's see how we can remove these

528
00:24:57,600 --> 00:24:59,280
limitations one by one

529
00:24:59,280 --> 00:25:01,799
so we can consider uniform or dynamic

530
00:25:01,799 --> 00:25:04,320
modular computation for example function

531
00:25:04,320 --> 00:25:06,659
plus can be turing machine and here

532
00:25:06,659 --> 00:25:08,760
attributes can be added or deleted at

533
00:25:08,760 --> 00:25:10,500
any point of time

534
00:25:10,500 --> 00:25:13,200
setup could be made uh unbounded

535
00:25:13,200 --> 00:25:14,940
that means Master public key size only

536
00:25:14,940 --> 00:25:17,100
depends on Lambda which is executive

537
00:25:17,100 --> 00:25:19,280
parameter psychotic size

538
00:25:19,280 --> 00:25:21,840
can be input specifically

539
00:25:21,840 --> 00:25:24,500
and with all these we can also

540
00:25:24,500 --> 00:25:28,020
have adaptive simulation security

541
00:25:28,020 --> 00:25:31,080
so this is exactly our work and due to

542
00:25:31,080 --> 00:25:33,360
the feature of uniformity we now capture

543
00:25:33,360 --> 00:25:35,940
unbounded AC schemes such as unbounded

544
00:25:35,940 --> 00:25:38,460
ipfe or unbounded AV

545
00:25:38,460 --> 00:25:39,539
Etc

546
00:25:39,539 --> 00:25:42,659
so in summary we Define Fe for unbounded

547
00:25:42,659 --> 00:25:47,820
AWS or uaws and we construct it for log

548
00:25:47,820 --> 00:25:50,820
space students and our construction has

549
00:25:50,820 --> 00:25:53,039
several exciting features for example it

550
00:25:53,039 --> 00:25:56,159
has complex meaning that it will not

551
00:25:56,159 --> 00:25:59,039
grow with respect to multiple occurrence

552
00:25:59,039 --> 00:26:00,659
of a particular attribute into it

553
00:26:00,659 --> 00:26:01,440
function

554
00:26:01,440 --> 00:26:03,299
also our scheme is full pollution

555
00:26:03,299 --> 00:26:06,480
resistance and it achieves adaptive

556
00:26:06,480 --> 00:26:09,299
solution security under oil known S6

557
00:26:09,299 --> 00:26:11,880
stage assumption

558
00:26:11,880 --> 00:26:14,580
so let's see how to define Fe for

559
00:26:14,580 --> 00:26:15,600
evidence

560
00:26:15,600 --> 00:26:18,419
here we first note that setup only

561
00:26:18,419 --> 00:26:21,539
depends on security parameter Lambda

562
00:26:21,539 --> 00:26:23,400
function is a couple of student machines

563
00:26:23,400 --> 00:26:24,360
MK

564
00:26:24,360 --> 00:26:27,380
uh where k run so far and index at I

565
00:26:27,380 --> 00:26:30,539
message is a tuple of x and z here x is

566
00:26:30,539 --> 00:26:33,900
a binary string and Z can be any Vector

567
00:26:33,900 --> 00:26:36,059
of arbitrary length so for example let's

568
00:26:36,059 --> 00:26:39,240
say n the functionality output sum of M

569
00:26:39,240 --> 00:26:43,260
K ax times z k per K transfer I if I is

570
00:26:43,260 --> 00:26:46,260
a subset of boxing and as previous we

571
00:26:46,260 --> 00:26:49,020
have X is public and Z is private

572
00:26:49,020 --> 00:26:51,960
so as a toy example if your index at I

573
00:26:51,960 --> 00:26:56,520
is 1 2 and 4 and Z has length 5 then the

574
00:26:56,520 --> 00:27:00,179
functionality outputs M1 x max Z1 plus

575
00:27:00,179 --> 00:27:04,799
M2 x e 2 plus M 4 x times equal

576
00:27:04,799 --> 00:27:07,320
okay so technically we started from a

577
00:27:07,320 --> 00:27:09,419
very nice work of linear luo where they

578
00:27:09,419 --> 00:27:12,299
build the Primitive of a b e for

579
00:27:12,299 --> 00:27:15,600
circuits and two emissions from ipfe and

580
00:27:15,600 --> 00:27:17,460
arithmetic key gardening scheme in short

581
00:27:17,460 --> 00:27:18,900
akgs

582
00:27:18,900 --> 00:27:22,559
last year we showed that how how to um

583
00:27:22,559 --> 00:27:24,360
extend their framework from payload

584
00:27:24,360 --> 00:27:27,059
hiding to attribute hiding setting in

585
00:27:27,059 --> 00:27:30,179
the context of AC for AWS and now we

586
00:27:30,179 --> 00:27:32,400
further extend the framework from a

587
00:27:32,400 --> 00:27:34,200
non-uniform model of computational to

588
00:27:34,200 --> 00:27:36,960
uniform model of computation by adding

589
00:27:36,960 --> 00:27:38,880
the feature of unboundedness

590
00:27:38,880 --> 00:27:42,240
so in particular we use akgs for

591
00:27:42,240 --> 00:27:45,240
terminations from 1120 and we also use

592
00:27:45,240 --> 00:27:48,900
index encoding mechanism with ipfe and

593
00:27:48,900 --> 00:27:50,880
we devise distributed Randomness

594
00:27:50,880 --> 00:27:53,460
mechanism to achieve our goal

595
00:27:53,460 --> 00:27:56,400
in the pathway we first construct 1 q1

596
00:27:56,400 --> 00:27:58,620
ciphertext secured security Fe for uws

597
00:27:58,620 --> 00:28:02,400
and then extend it to Fe 40 by WS in

598
00:28:02,400 --> 00:28:03,539
public

599
00:28:03,539 --> 00:28:05,279
in this talk I will mainly focus on

600
00:28:05,279 --> 00:28:07,740
these one key one ciphertext version of

601
00:28:07,740 --> 00:28:09,720
the unity

602
00:28:09,720 --> 00:28:12,659
so ipv is an important tool of our

603
00:28:12,659 --> 00:28:14,880
construction here function and messages

604
00:28:14,880 --> 00:28:17,039
are vectors and the functionality

605
00:28:17,039 --> 00:28:19,620
outputs in a product between the vectors

606
00:28:19,620 --> 00:28:22,440
in this work we consider ipv creating e

607
00:28:22,440 --> 00:28:24,960
G1 cross G2 to GT here function and

608
00:28:24,960 --> 00:28:27,299
messages are encoded in the exponent of

609
00:28:27,299 --> 00:28:29,340
the source group G1 G1 and the

610
00:28:29,340 --> 00:28:30,600
functionality compute standard product

611
00:28:30,600 --> 00:28:33,000
in the Target group GK

612
00:28:33,000 --> 00:28:35,100
the function heading security of ipfe

613
00:28:35,100 --> 00:28:38,640
says that two sets of Securities and

614
00:28:38,640 --> 00:28:39,659
cyber texture computational

615
00:28:39,659 --> 00:28:41,880
indistinguishable if inner product

616
00:28:41,880 --> 00:28:43,740
between the vectors for the two sets are

617
00:28:43,740 --> 00:28:45,600
equal

618
00:28:45,600 --> 00:28:48,960
and akgs is another important tool akgs

619
00:28:48,960 --> 00:28:52,080
over JP is a protocol between two party

620
00:28:52,080 --> 00:28:55,320
first party garbage function f with

621
00:28:55,320 --> 00:28:58,260
values G and beta and outputs a set of

622
00:28:58,260 --> 00:29:01,260
level functions l1. LT second party

623
00:29:01,260 --> 00:29:05,700
given FX and level values at input X

624
00:29:05,700 --> 00:29:09,539
efficiently computes uh z f x plus beta

625
00:29:09,539 --> 00:29:11,700
so here we want that F and X to be

626
00:29:11,700 --> 00:29:15,299
public and z and beta to be private and

627
00:29:15,299 --> 00:29:17,700
this is formalized by a simulator which

628
00:29:17,700 --> 00:29:20,760
given f x and the output values of X

629
00:29:20,760 --> 00:29:23,460
Plus beta simulates the level values l1.

630
00:29:23,460 --> 00:29:24,720
l k

631
00:29:24,720 --> 00:29:28,260
akgs has a nice property of linearity

632
00:29:28,260 --> 00:29:30,779
which tells that evil is linear in the

633
00:29:30,779 --> 00:29:33,899
level value cell 1. whereas the level

634
00:29:33,899 --> 00:29:36,779
functions are linear in the input X

635
00:29:36,779 --> 00:29:39,240
we consider akgs with piecewise security

636
00:29:39,240 --> 00:29:41,700
and it has two properties first

637
00:29:41,700 --> 00:29:44,460
properties is that given level values

638
00:29:44,460 --> 00:29:46,620
from L2 onwards we can reverse this

639
00:29:46,620 --> 00:29:49,080
reversely sample the first level value

640
00:29:49,080 --> 00:29:51,360
depending on the output values f x plus

641
00:29:51,360 --> 00:29:52,320
b

642
00:29:52,320 --> 00:29:54,720
the second properties is that given a

643
00:29:54,720 --> 00:29:57,899
level values from L3 onwards we can

644
00:29:57,899 --> 00:30:00,179
replace the second level value with

645
00:30:00,179 --> 00:30:02,520
uniformly random value R2

646
00:30:02,520 --> 00:30:04,620
and it can be continued till the last

647
00:30:04,620 --> 00:30:05,640
level

648
00:30:05,640 --> 00:30:08,100
this property is named as marginal

649
00:30:08,100 --> 00:30:09,240
randomness

650
00:30:09,240 --> 00:30:11,580
and marginal Randomness together with

651
00:30:11,580 --> 00:30:13,559
reverse sample ability is called

652
00:30:13,559 --> 00:30:15,960
piecewise security and it is very easy

653
00:30:15,960 --> 00:30:18,720
to see that PCS security implies normal

654
00:30:18,720 --> 00:30:21,059
simulation security

655
00:30:21,059 --> 00:30:22,919
okay so before going to our construction

656
00:30:22,919 --> 00:30:25,980
let's see the core idea of dp21 for

657
00:30:25,980 --> 00:30:29,340
building Fe for AWS for abps uh so for

658
00:30:29,340 --> 00:30:31,140
for this talk I consider a simple

659
00:30:31,140 --> 00:30:33,299
version of function input and output

660
00:30:33,299 --> 00:30:35,820
function consists of two avps iPhone F2

661
00:30:35,820 --> 00:30:38,399
input is x and z where Z has length 2

662
00:30:38,399 --> 00:30:42,059
and output will be Z1 F1 X Plus V2 X

663
00:30:42,059 --> 00:30:44,220
so in key generation F1 and F2 are first

664
00:30:44,220 --> 00:30:46,440
got available with Z1 beta 1 and Z2

665
00:30:46,440 --> 00:30:48,539
beta2 so RC one Z two are treated as

666
00:30:48,539 --> 00:30:51,539
variables the garveling algorithms uh

667
00:30:51,539 --> 00:30:53,820
algorithm outputs some set of vectors V

668
00:30:53,820 --> 00:30:57,240
where V K represents the level function

669
00:30:57,240 --> 00:31:00,299
cell k for K less than T which depends

670
00:31:00,299 --> 00:31:03,899
on input X and VT represents the level

671
00:31:03,899 --> 00:31:07,080
function LT which is a function of

672
00:31:07,080 --> 00:31:10,440
either c 1 over 52.

673
00:31:10,440 --> 00:31:12,899
accordingly we consider two ipfev one

674
00:31:12,899 --> 00:31:14,640
for computing the level values for K

675
00:31:14,640 --> 00:31:17,220
less than T and other is for computing

676
00:31:17,220 --> 00:31:20,159
the level value 40. generation algorithm

677
00:31:20,159 --> 00:31:22,200
finally outputs ipv security is

678
00:31:22,200 --> 00:31:24,419
corresponding to all these D vectors

679
00:31:24,419 --> 00:31:26,700
in encryption we first compute ipfe

680
00:31:26,700 --> 00:31:29,279
secret uh ciphert X TX corresponding to

681
00:31:29,279 --> 00:31:32,159
the vector 1 comma X and we also compute

682
00:31:32,159 --> 00:31:34,620
two ipfe ciphertech ct1 C2 corresponding

683
00:31:34,620 --> 00:31:37,740
to the vectors 1 comma Z1 and 1 comma C

684
00:31:37,740 --> 00:31:39,779
in decryption we first employee the ipv

685
00:31:39,779 --> 00:31:42,299
decryption algorithm to get the level

686
00:31:42,299 --> 00:31:44,580
values along dot LT corresponding to the

687
00:31:44,580 --> 00:31:47,220
function F1 and then given if One X we

688
00:31:47,220 --> 00:31:49,260
can employ the evaluation algorithm of a

689
00:31:49,260 --> 00:31:52,080
kgs to get the output of c one F1 X Plus

690
00:31:52,080 --> 00:31:55,140
beta 1. similarly we can get Z2 F2 X

691
00:31:55,140 --> 00:31:57,779
Plus beta 2. now these two values can be

692
00:31:57,779 --> 00:31:59,820
added to get the final result of

693
00:31:59,820 --> 00:32:02,700
physical F1 X Plus equal to x given the

694
00:32:02,700 --> 00:32:06,120
fact that beta 1 beta 2 or sugar

695
00:32:06,120 --> 00:32:09,539
to hide the partial decryption result

696
00:32:09,539 --> 00:32:11,880
okay so keeping this idea in back of our

697
00:32:11,880 --> 00:32:14,279
mind let's see how we can construct Fe

698
00:32:14,279 --> 00:32:16,320
for even WS for two minutes so these are

699
00:32:16,320 --> 00:32:18,360
the general form of function input and

700
00:32:18,360 --> 00:32:21,059
output however for this stock I only

701
00:32:21,059 --> 00:32:22,740
considered a simple version of function

702
00:32:22,740 --> 00:32:24,659
which consists of two different missions

703
00:32:24,659 --> 00:32:28,140
M1 M2 input is x and z where Z has

704
00:32:28,140 --> 00:32:29,700
length 3 and according to the

705
00:32:29,700 --> 00:32:31,860
functionality we will get output of c

706
00:32:31,860 --> 00:32:34,980
one M One X plus v 2 into X

707
00:32:34,980 --> 00:32:36,899
okay so as previous we want to guard

708
00:32:36,899 --> 00:32:40,260
well M1 M2 however we note that kgs for

709
00:32:40,260 --> 00:32:42,480
AVP will not work here because M1 M2 are

710
00:32:42,480 --> 00:32:45,779
two animations so we go for akgs for two

711
00:32:45,779 --> 00:32:47,640
International computation and let's see

712
00:32:47,640 --> 00:32:50,059
how it works for the FAA for con

713
00:32:50,059 --> 00:32:52,500
concreteness so in deterministic finite

714
00:32:52,500 --> 00:32:55,980
automata we have a set of states 12.

715
00:32:55,980 --> 00:32:58,919
one is the initial State and although we

716
00:32:58,919 --> 00:33:01,260
have we can have many accepting state

717
00:33:01,260 --> 00:33:03,240
but let's consider only one accepting

718
00:33:03,240 --> 00:33:05,460
state q accept and in this example it is

719
00:33:05,460 --> 00:33:06,659
three

720
00:33:06,659 --> 00:33:09,059
uh in DFA we also have a transition

721
00:33:09,059 --> 00:33:12,179
function Delta that defines a map by

722
00:33:12,179 --> 00:33:15,539
reading the input bits of the DSM

723
00:33:15,539 --> 00:33:18,779
DFA can also be emergent as a layered

724
00:33:18,779 --> 00:33:20,940
branching program here each layer

725
00:33:20,940 --> 00:33:23,340
consists of three nodes for this toy

726
00:33:23,340 --> 00:33:24,299
example

727
00:33:24,299 --> 00:33:27,299
and we have a total of n plus one layers

728
00:33:27,299 --> 00:33:31,559
if we consider a input length of n

729
00:33:31,559 --> 00:33:34,080
the edges between the layer J and J plus

730
00:33:34,080 --> 00:33:36,419
1 are defined by the transition function

731
00:33:36,419 --> 00:33:39,360
Delta and since Delta is fixed so we

732
00:33:39,360 --> 00:33:41,460
have the same set of edges for each pair

733
00:33:41,460 --> 00:33:43,679
of adjacent layers

734
00:33:43,679 --> 00:33:46,019
we can also consider

735
00:33:46,019 --> 00:33:48,059
matrices engineering one corresponding

736
00:33:48,059 --> 00:33:51,179
to the bit 0 and 1. and we Traverse from

737
00:33:51,179 --> 00:33:53,700
Level 1 to layer n plus 1 using these

738
00:33:53,700 --> 00:33:55,740
following matrix multiplication here E1

739
00:33:55,740 --> 00:33:58,500
indicates that it is a first basis

740
00:33:58,500 --> 00:34:01,080
vector and it indicates that we always

741
00:34:01,080 --> 00:34:03,539
start from initial state 1.

742
00:34:03,539 --> 00:34:07,200
so after we read the N bit of inputs we

743
00:34:07,200 --> 00:34:09,780
multiply it with another Vector if you

744
00:34:09,780 --> 00:34:13,139
accept which represent the acceptance

745
00:34:13,139 --> 00:34:15,300
and finally we will get a output of one

746
00:34:15,300 --> 00:34:18,719
or zero if the DFA I mean depending on

747
00:34:18,719 --> 00:34:22,440
the DFA accepts the input or not

748
00:34:22,440 --> 00:34:25,980
so therefore we want to garvel Z MX plus

749
00:34:25,980 --> 00:34:28,260
beta where MX is this matrix

750
00:34:28,260 --> 00:34:29,699
multiplication

751
00:34:29,699 --> 00:34:31,739
so let's consider one bit of input then

752
00:34:31,739 --> 00:34:33,599
it can be curved using the following

753
00:34:33,599 --> 00:34:37,500
equation here by by sampling uh random

754
00:34:37,500 --> 00:34:40,320
vectors R 0 or 1.

755
00:34:40,320 --> 00:34:43,500
and l0 L1 L2 are the level functions

756
00:34:43,500 --> 00:34:47,040
where L2 depends only on the private uh

757
00:34:47,040 --> 00:34:48,659
input you see

758
00:34:48,659 --> 00:34:51,060
if we extend the input length then we

759
00:34:51,060 --> 00:34:52,679
can actually extend the chained equation

760
00:34:52,679 --> 00:34:56,219
by sampling more and more random vectors

761
00:34:56,219 --> 00:34:58,200
so for example if we have n bit of

762
00:34:58,200 --> 00:35:01,980
inputs then the total size of barbelling

763
00:35:01,980 --> 00:35:04,380
will be in Q Plus 1.

764
00:35:04,380 --> 00:35:06,300
so now let's say we want to apply the

765
00:35:06,300 --> 00:35:08,040
strategy into our setting

766
00:35:08,040 --> 00:35:10,440
however we now see that

767
00:35:10,440 --> 00:35:12,780
um then we need to generate in Q Plus

768
00:35:12,780 --> 00:35:14,180
One Mini level

769
00:35:14,180 --> 00:35:16,380
functions at the time of key generation

770
00:35:16,380 --> 00:35:19,740
however n is the input length and we do

771
00:35:19,740 --> 00:35:21,900
not have it yet when we generate the

772
00:35:21,900 --> 00:35:22,980
security

773
00:35:22,980 --> 00:35:26,940
so let's look at the qjth level function

774
00:35:26,940 --> 00:35:29,460
in a bit more detail to recall that we

775
00:35:29,460 --> 00:35:31,020
sampled

776
00:35:31,020 --> 00:35:34,740
many random vectors r0. and Each of

777
00:35:34,740 --> 00:35:37,920
which has uh length Q

778
00:35:37,920 --> 00:35:41,220
we can represent this matrix by a tensor

779
00:35:41,220 --> 00:35:44,040
coded between two vectors and these

780
00:35:44,040 --> 00:35:46,020
vectors are M and RX can be sampled

781
00:35:46,020 --> 00:35:48,000
independently in particular we want to

782
00:35:48,000 --> 00:35:51,660
write r j to b r x a times RN where r x

783
00:35:51,660 --> 00:35:54,240
j denotes pjth into your products

784
00:35:54,240 --> 00:35:58,560
so this helps us to represent lqxj as in

785
00:35:58,560 --> 00:36:00,540
our product between two vectors one is

786
00:36:00,540 --> 00:36:02,280
known to the encryptor and other is

787
00:36:02,280 --> 00:36:03,720
known to the key generator

788
00:36:03,720 --> 00:36:06,420
let's call this vectors as user entry

789
00:36:06,420 --> 00:36:10,740
we can similarly represent l0 and the

790
00:36:10,740 --> 00:36:14,280
last few level functions lq

791
00:36:14,280 --> 00:36:16,980
so basically we distribute the process

792
00:36:16,980 --> 00:36:19,380
of gargling between key generator and

793
00:36:19,380 --> 00:36:20,700
entity

794
00:36:20,700 --> 00:36:22,980
so using this idea we can now directly

795
00:36:22,980 --> 00:36:25,980
encode these two animations into some

796
00:36:25,980 --> 00:36:28,680
three vectors and then generate ipf

797
00:36:28,680 --> 00:36:32,820
secretly in encryption we encode x and z

798
00:36:32,820 --> 00:36:35,820
in some U vectors and we compute ipfa

799
00:36:35,820 --> 00:36:37,140
Cipher text

800
00:36:37,140 --> 00:36:39,720
and decryption works as before

801
00:36:39,720 --> 00:36:42,440
however this simple scheme

802
00:36:42,440 --> 00:36:45,839
in this slide is not secure

803
00:36:45,839 --> 00:36:48,300
to see this let's look at two important

804
00:36:48,300 --> 00:36:51,960
steps of the security analysis so in the

805
00:36:51,960 --> 00:36:54,060
first step we use reverse

806
00:36:54,060 --> 00:36:57,780
samplingability to reversely sample l0 I

807
00:36:57,780 --> 00:37:00,960
depending on the output z i m i x plus

808
00:37:00,960 --> 00:37:03,900
beta e and if the secret key squared

809
00:37:03,900 --> 00:37:06,359
before the challenge Cipher text then we

810
00:37:06,359 --> 00:37:10,440
Hardware this l0i in u0 vector however

811
00:37:10,440 --> 00:37:12,119
we notice that we do not have enough

812
00:37:12,119 --> 00:37:16,740
space to uh place this l0i values for

813
00:37:16,740 --> 00:37:18,240
all I

814
00:37:18,240 --> 00:37:20,760
and in the second step when you try to

815
00:37:20,760 --> 00:37:23,400
randomize the other level values l j i

816
00:37:23,400 --> 00:37:26,940
for J greater than 1 uh we do it through

817
00:37:26,940 --> 00:37:29,339
the user vector and again we do not have

818
00:37:29,339 --> 00:37:30,960
enough space

819
00:37:30,960 --> 00:37:33,540
so what we do we make multiple copies of

820
00:37:33,540 --> 00:37:36,180
u0 and u j depending on the length of

821
00:37:36,180 --> 00:37:39,900
length of Z right but it opens though to

822
00:37:39,900 --> 00:37:41,760
a mix and match kind of attack now

823
00:37:41,760 --> 00:37:44,099
adversary can compute inner products

824
00:37:44,099 --> 00:37:46,079
between vectors related to the turing

825
00:37:46,079 --> 00:37:50,460
machine M2 M1 with uh vectors related to

826
00:37:50,460 --> 00:37:52,440
the input G2

827
00:37:52,440 --> 00:37:54,420
and vice versa

828
00:37:54,420 --> 00:37:56,339
and it will help the adversary to

829
00:37:56,339 --> 00:37:59,700
compute an unwanted output given m1x

830
00:37:59,700 --> 00:38:02,160
plus Z two a One X

831
00:38:02,160 --> 00:38:05,119
so to tackle this we apply index

832
00:38:05,119 --> 00:38:08,280
encoding mechanism so we encode the

833
00:38:08,280 --> 00:38:11,640
indices and append it to all the vectors

834
00:38:11,640 --> 00:38:13,740
in such a way that if you take inner

835
00:38:13,740 --> 00:38:15,900
product between the vectors having the

836
00:38:15,900 --> 00:38:18,560
same index we get a meaningful result

837
00:38:18,560 --> 00:38:21,420
otherwise we will get an garbage value

838
00:38:21,420 --> 00:38:23,579
so this prevents mix and match kind of

839
00:38:23,579 --> 00:38:26,400
better and we hope to get the correct

840
00:38:26,400 --> 00:38:27,359
output

841
00:38:27,359 --> 00:38:29,760
so let's see how we can actually use

842
00:38:29,760 --> 00:38:31,920
index encoding mechanism in this secret

843
00:38:31,920 --> 00:38:33,119
analysis

844
00:38:33,119 --> 00:38:36,119
so recall that we need to Hardware l0i

845
00:38:36,119 --> 00:38:38,460
in u0 vector

846
00:38:38,460 --> 00:38:40,680
and this can be done using function

847
00:38:40,680 --> 00:38:43,020
hiding security of ipfe

848
00:38:43,020 --> 00:38:45,599
now let's let's say we have one more two

849
00:38:45,599 --> 00:38:48,240
admission M4 in in into the function M

850
00:38:48,240 --> 00:38:50,640
so the inner product between the

851
00:38:50,640 --> 00:38:54,480
encodings rho I minus 1 I dot Pi four

852
00:38:54,480 --> 00:38:57,300
four comma 1 will not be equal to 0 for

853
00:38:57,300 --> 00:38:59,280
I equal to one two three here one two

854
00:38:59,280 --> 00:39:02,700
three means the indices of the input Z

855
00:39:02,700 --> 00:39:05,760
and this additional entropy will be

856
00:39:05,760 --> 00:39:08,700
provided by index encoding technique

857
00:39:08,700 --> 00:39:10,920
using the function hiding security of

858
00:39:10,920 --> 00:39:12,839
ipfe we can Now sample beta 4

859
00:39:12,839 --> 00:39:15,540
independent of beta1 and beta 2 and this

860
00:39:15,540 --> 00:39:18,060
make sure that beta 1 plus beta2 plus

861
00:39:18,060 --> 00:39:20,220
beta 4 will not be equal to 0 with

862
00:39:20,220 --> 00:39:23,099
hyperbly therefore the adversary will

863
00:39:23,099 --> 00:39:25,380
not get the output g 1 m 1 X Plus equal

864
00:39:25,380 --> 00:39:28,020
to X for such a function m

865
00:39:28,020 --> 00:39:31,440
right so in the next step what we want

866
00:39:31,440 --> 00:39:33,480
to do we try to randomize the other

867
00:39:33,480 --> 00:39:35,460
level values l j i for J greater than

868
00:39:35,460 --> 00:39:36,260
one

869
00:39:36,260 --> 00:39:39,060
recall that these vectors are encoded in

870
00:39:39,060 --> 00:39:41,280
the power of source groups because we

871
00:39:41,280 --> 00:39:44,579
considered ipfe with Theory

872
00:39:44,579 --> 00:39:47,160
as a first step we bring the partial

873
00:39:47,160 --> 00:39:49,619
guard building Randomness into the uji

874
00:39:49,619 --> 00:39:51,599
vector using the function hiding secret

875
00:39:51,599 --> 00:39:52,859
of IPA

876
00:39:52,859 --> 00:39:55,800
and then we again recall that this r j

877
00:39:55,800 --> 00:39:58,260
minus 1 is basically r x j minus 1 times

878
00:39:58,260 --> 00:39:59,640
RN

879
00:39:59,640 --> 00:40:02,760
and in the next step we hope to use the

880
00:40:02,760 --> 00:40:04,380
ddh in G1

881
00:40:04,380 --> 00:40:07,980
to replace all this r j minus 1 by s j

882
00:40:07,980 --> 00:40:10,619
minus 1 which are uniform very random

883
00:40:10,619 --> 00:40:13,619
independent of r j minus however to

884
00:40:13,619 --> 00:40:15,420
apply this step we need to make sure

885
00:40:15,420 --> 00:40:18,660
that r x j minus 1 and RMK are encoded

886
00:40:18,660 --> 00:40:21,540
only in the exponent of G1

887
00:40:21,540 --> 00:40:23,579
unfortunately it is not the case because

888
00:40:23,579 --> 00:40:26,700
RMK may appear in vqk

889
00:40:26,700 --> 00:40:29,160
which are encoded in the source group G2

890
00:40:29,160 --> 00:40:31,680
for any K it will appear right

891
00:40:31,680 --> 00:40:35,280
hence we cannot apply this ddh in G1 in

892
00:40:35,280 --> 00:40:36,359
this fashion

893
00:40:36,359 --> 00:40:39,060
so here we devise uh distributed

894
00:40:39,060 --> 00:40:41,040
Randomness mechanism which works well

895
00:40:41,040 --> 00:40:43,859
with the framework of your ws and it

896
00:40:43,859 --> 00:40:47,400
eventually helps us to randomize these

897
00:40:47,400 --> 00:40:50,339
level values l j i with uniformly random

898
00:40:50,339 --> 00:40:51,240
values

899
00:40:51,240 --> 00:40:54,060
and we can do it for other vectors that

900
00:40:54,060 --> 00:40:56,880
includes the private input scene

901
00:40:56,880 --> 00:40:59,160
okay so the actual proof is much more

902
00:40:59,160 --> 00:41:02,000
technical for this and also for the

903
00:41:02,000 --> 00:41:04,920
full-fledged Fe scheme I refer to our

904
00:41:04,920 --> 00:41:07,560
full version which is available at the

905
00:41:07,560 --> 00:41:09,180
event

906
00:41:09,180 --> 00:41:11,400
okay so I will conclude my talk with a

907
00:41:11,400 --> 00:41:13,800
few open problems

908
00:41:13,800 --> 00:41:15,720
so it will be interesting to see a

909
00:41:15,720 --> 00:41:18,900
construction of our Fe for WS with

910
00:41:18,900 --> 00:41:22,619
success means that ciphertech size will

911
00:41:22,619 --> 00:41:25,079
only depend on the private inputs not on

912
00:41:25,079 --> 00:41:27,900
x and also it will be interesting to

913
00:41:27,900 --> 00:41:29,760
have such a scheme with adaptive

914
00:41:29,760 --> 00:41:31,680
simulation security

915
00:41:31,680 --> 00:41:33,720
and the next open problem would be to

916
00:41:33,720 --> 00:41:37,140
have Fe for uawas from lattice based

917
00:41:37,140 --> 00:41:39,839
assumptions such as LW

918
00:41:39,839 --> 00:41:43,400
yeah thanks for your attention

919
00:41:50,280 --> 00:41:52,800
are there any question

920
00:41:52,800 --> 00:41:57,140
we have plenty of time for question

921
00:41:58,920 --> 00:42:00,839
so uh

922
00:42:00,839 --> 00:42:05,880
so this is uh for rogue space right yeah

923
00:42:05,880 --> 00:42:09,119
so but in the building block you use the

924
00:42:09,119 --> 00:42:11,700
akgs for turing machine it's a chewing

925
00:42:11,700 --> 00:42:13,380
machine but you need the robot yeah yeah

926
00:42:13,380 --> 00:42:16,560
we we have used uh akgs computation for

927
00:42:16,560 --> 00:42:18,140
logspace students

928
00:42:18,140 --> 00:42:20,960
so it is

929
00:42:20,960 --> 00:42:23,880
simply said in that cases that's awesome

930
00:42:23,880 --> 00:42:25,680
yeah

931
00:42:25,680 --> 00:42:28,879
any other question

932
00:42:29,280 --> 00:42:32,280
foreign

933
00:42:48,900 --> 00:42:52,200
yeah I mean uh you mean that uh from LW

934
00:42:52,200 --> 00:42:53,640
maybe uh

935
00:42:53,640 --> 00:42:56,900
the main problem would be to uh uh

936
00:42:56,900 --> 00:43:01,440
design the framework of dpvs or function

937
00:43:01,440 --> 00:43:03,319
hiding itfe

938
00:43:03,319 --> 00:43:05,280
with LW

939
00:43:05,280 --> 00:43:08,060
okay so uh it is

940
00:43:08,060 --> 00:43:15,119
uh maybe I miss something uh so

941
00:43:16,560 --> 00:43:22,740
it's ideal or pairings is uh is uh

942
00:43:22,740 --> 00:43:25,260
useful for achieving adaptive security

943
00:43:25,260 --> 00:43:28,319
but uh yeah uh also useful for

944
00:43:28,319 --> 00:43:32,460
functionality uh or or for this kind of

945
00:43:32,460 --> 00:43:35,400
battery yeah yeah yeah I mean

946
00:43:35,400 --> 00:43:38,099
um so even if we we do not consider

947
00:43:38,099 --> 00:43:40,920
adaptive security is it hard to achieve

948
00:43:40,920 --> 00:43:45,540
this kind of Fe skin from LW

949
00:43:45,540 --> 00:43:48,180
yeah I think so because

950
00:43:48,180 --> 00:43:52,560
um uh we we used I mean we need function

951
00:43:52,560 --> 00:43:55,380
hidings uh property of ipfe even if we

952
00:43:55,380 --> 00:43:57,900
consider selected security right okay so

953
00:43:57,900 --> 00:44:00,000
that's why I guess it will be hard okay

954
00:44:00,000 --> 00:44:02,720
thanks

955
00:44:04,200 --> 00:44:07,140
no question

956
00:44:07,140 --> 00:44:09,420
okay let's just let's explain to the

957
00:44:09,420 --> 00:44:12,260
speaker thanks again

958
00:44:23,280 --> 00:44:26,099
okay the next talk is Collision

959
00:44:26,099 --> 00:44:28,980
resistant functional encryption for Rams

960
00:44:28,980 --> 00:44:35,300
uh by propanja announced timing Jun uh

961
00:44:35,300 --> 00:44:40,440
and Leo is going to talk online

962
00:44:40,440 --> 00:44:43,339
uh

963
00:44:43,680 --> 00:44:45,839
are you ready Leo

964
00:44:45,839 --> 00:44:47,780
hello hi hi hi

965
00:44:47,780 --> 00:44:49,859
we can hear you

966
00:44:49,859 --> 00:44:53,460
okay okay please stop

967
00:44:53,460 --> 00:44:55,800
thanks a lot for the introduction uh my

968
00:44:55,800 --> 00:44:57,900
name is neon uh I'm here to present

969
00:44:57,900 --> 00:45:00,480
Collision of collusion with external

970
00:45:00,480 --> 00:45:01,859
functional encryption programs this is a

971
00:45:01,859 --> 00:45:06,000
joint work with Papa John Logan

972
00:45:09,359 --> 00:45:11,819
okay uh

973
00:45:11,819 --> 00:45:14,700
functional encryption is a very uh very

974
00:45:14,700 --> 00:45:16,859
very useful primitive it's a

975
00:45:16,859 --> 00:45:18,599
generalization of public key encryption

976
00:45:18,599 --> 00:45:19,560
identity-based encryption

977
00:45:19,560 --> 00:45:21,660
attribute-based encryption and it's very

978
00:45:21,660 --> 00:45:23,940
useful to construct other powerful

979
00:45:23,940 --> 00:45:26,819
crypto Primitives such as IO Autumn or

980
00:45:26,819 --> 00:45:28,940
watermarking schemes and succinct the

981
00:45:28,940 --> 00:45:31,859
randomize the encodings however prior

982
00:45:31,859 --> 00:45:34,440
works are named like model the functions

983
00:45:34,440 --> 00:45:36,780
like many as circuits or turning

984
00:45:36,780 --> 00:45:40,079
machines but in this paper we we focus

985
00:45:40,079 --> 00:45:41,520
on ramps

986
00:45:41,520 --> 00:45:44,280
uh so what what is a ram model so Ram

987
00:45:44,280 --> 00:45:46,680
stands for rent access machine like uh

988
00:45:46,680 --> 00:45:49,260
Suppose there is a like a huge memory uh

989
00:45:49,260 --> 00:45:52,020
starting from one to n and then there is

990
00:45:52,020 --> 00:45:55,020
a step circuit which reads like

991
00:45:55,020 --> 00:45:58,079
um which take the uh CPUs status inputs

992
00:45:58,079 --> 00:46:00,660
and it and also like one

993
00:46:00,660 --> 00:46:04,260
um uh one index of the memory and also

994
00:46:04,260 --> 00:46:07,079
the content that's as input and after

995
00:46:07,079 --> 00:46:09,660
the processing of the step circuit it

996
00:46:09,660 --> 00:46:12,240
will update the internal CPU stage and

997
00:46:12,240 --> 00:46:15,540
output the uh let's address to rates so

998
00:46:15,540 --> 00:46:17,400
that is only for the read online ramps

999
00:46:17,400 --> 00:46:19,800
right like think about like the binary

1000
00:46:19,800 --> 00:46:22,740
search like uh this memory could be a

1001
00:46:22,740 --> 00:46:25,560
very large sorted array and you can you

1002
00:46:25,560 --> 00:46:28,859
will use this next CPU uh the Rand uh

1003
00:46:28,859 --> 00:46:31,500
the final research to search the uh to

1004
00:46:31,500 --> 00:46:33,720
search the memory for for the device

1005
00:46:33,720 --> 00:46:37,440
value and uh yeah so the runtime of this

1006
00:46:37,440 --> 00:46:39,720
binary search is only a logarithmic to

1007
00:46:39,720 --> 00:46:41,400
the size of the memory so that's how

1008
00:46:41,400 --> 00:46:45,020
huge benefit of the ram program

1009
00:46:45,380 --> 00:46:48,119
s the syntax is something like this so

1010
00:46:48,119 --> 00:46:49,740
the setup we take will take the public

1011
00:46:49,740 --> 00:46:52,200
parameters as inputs and maybe also some

1012
00:46:52,200 --> 00:46:55,200
other parameters such as the uh the the

1013
00:46:55,200 --> 00:46:57,300
upper bound of the runtime and it will

1014
00:46:57,300 --> 00:46:59,040
output the public key and also Master

1015
00:46:59,040 --> 00:47:01,440
secret key the key chain will take the

1016
00:47:01,440 --> 00:47:04,079
master Circle key as input and also the

1017
00:47:04,079 --> 00:47:06,780
the Run programs inputs it outputs the

1018
00:47:06,780 --> 00:47:09,060
second key for the Run program the

1019
00:47:09,060 --> 00:47:11,400
encryption will take the public key the

1020
00:47:11,400 --> 00:47:13,560
database which could be very large I

1021
00:47:13,560 --> 00:47:16,619
think put an output the ciphertext and

1022
00:47:16,619 --> 00:47:19,440
the decryption what takes um the second

1023
00:47:19,440 --> 00:47:21,839
key and the server text and output the

1024
00:47:21,839 --> 00:47:24,920
uh the actual runtime of the Run program

1025
00:47:24,920 --> 00:47:27,900
uh actual result of the ram program so

1026
00:47:27,900 --> 00:47:29,819
here we will model this like uh

1027
00:47:29,819 --> 00:47:33,300
decryption as a run program like uh like

1028
00:47:33,300 --> 00:47:35,460
to avoid some trivial construction we

1029
00:47:35,460 --> 00:47:36,960
will have this like efficiency

1030
00:47:36,960 --> 00:47:39,240
requirements which means the runtime of

1031
00:47:39,240 --> 00:47:41,359
the keychain is is proportioned to the

1032
00:47:41,359 --> 00:47:44,220
polynomial in the size of the in the

1033
00:47:44,220 --> 00:47:46,680
size of program and the encryption

1034
00:47:46,680 --> 00:47:48,900
algorithm uh the runtime of the

1035
00:47:48,900 --> 00:47:50,520
encryption algorithm is also polynomial

1036
00:47:50,520 --> 00:47:54,599
is the size of the database and the the

1037
00:47:54,599 --> 00:47:56,400
most important one like the decryption

1038
00:47:56,400 --> 00:47:59,099
only is like a proportional to the input

1039
00:47:59,099 --> 00:48:01,880
prosthetic runtime instead of the the

1040
00:48:01,880 --> 00:48:04,440
worst case one time or it's like it's

1041
00:48:04,440 --> 00:48:07,020
independent of the size of the database

1042
00:48:07,020 --> 00:48:10,140
so that's um like the syntax and also

1043
00:48:10,140 --> 00:48:12,740
the efficiency requirement we want

1044
00:48:12,740 --> 00:48:15,780
and for the security we uh we only

1045
00:48:15,780 --> 00:48:18,720
consider selective security uh so it's

1046
00:48:18,720 --> 00:48:20,280
an interactive game between the

1047
00:48:20,280 --> 00:48:22,859
Challenger and the adversary uh the

1048
00:48:22,859 --> 00:48:24,780
challenge of a set of the skin by

1049
00:48:24,780 --> 00:48:26,819
running the set of algorithms and you it

1050
00:48:26,819 --> 00:48:29,400
was said it was sent the public key to

1051
00:48:29,400 --> 00:48:31,800
the adversary the adversary will choose

1052
00:48:31,800 --> 00:48:34,560
a database like d0 and D1 and then send

1053
00:48:34,560 --> 00:48:36,540
the database to the to the Challenger

1054
00:48:36,540 --> 00:48:39,119
who will then pick a random bit B and

1055
00:48:39,119 --> 00:48:41,700
then encrypt uh encrypted database

1056
00:48:41,700 --> 00:48:44,040
according to this random BP and then

1057
00:48:44,040 --> 00:48:46,740
send the send this as a change server

1058
00:48:46,740 --> 00:48:49,079
text to the adversary of the City Star

1059
00:48:49,079 --> 00:48:51,839
and then the then the adversary can like

1060
00:48:51,839 --> 00:48:54,119
query the Challenger as many times I see

1061
00:48:54,119 --> 00:48:56,579
who it wants uh for the for the function

1062
00:48:56,579 --> 00:48:59,460
key related to the to the program uh as

1063
00:48:59,460 --> 00:49:02,099
not as it satisfies the condition like P

1064
00:49:02,099 --> 00:49:04,800
to the d0 equal p to the D1 which means

1065
00:49:04,800 --> 00:49:07,740
the output of the Run program of the

1066
00:49:07,740 --> 00:49:10,200
query run program on these two uh two

1067
00:49:10,200 --> 00:49:13,380
changes database are the same and yeah

1068
00:49:13,380 --> 00:49:15,960
he can do this as many times as he wants

1069
00:49:15,960 --> 00:49:18,480
and at the end of the uh the security

1070
00:49:18,480 --> 00:49:21,420
experiment he needs to get the random

1071
00:49:21,420 --> 00:49:24,000
bit be chosen by diversary and we say

1072
00:49:24,000 --> 00:49:27,000
like the diversary wins US The Selective

1073
00:49:27,000 --> 00:49:29,579
security experiment if you can guess the

1074
00:49:29,579 --> 00:49:33,079
uh the bit B correctly

1075
00:49:33,900 --> 00:49:36,300
I'm as I mentioned before like prior

1076
00:49:36,300 --> 00:49:39,599
work I'm going to focus on round for

1077
00:49:39,599 --> 00:49:41,460
circuits where the decryption well

1078
00:49:41,460 --> 00:49:43,859
depends on the circuit size and as we

1079
00:49:43,859 --> 00:49:45,900
know that if you convert a ram program

1080
00:49:45,900 --> 00:49:48,359
to a circuit there will be like a huge

1081
00:49:48,359 --> 00:49:51,420
of uh overhead like the size of the

1082
00:49:51,420 --> 00:49:53,520
circuit will depends on the size of the

1083
00:49:53,520 --> 00:49:56,339
uh the database so that's not desirable

1084
00:49:56,339 --> 00:49:58,680
that's something like we don't want

1085
00:49:58,680 --> 00:50:01,260
and like so no one approaches to a

1086
00:50:01,260 --> 00:50:03,720
constructing Fe programs it's like uh

1087
00:50:03,720 --> 00:50:06,359
these two uh two work and there is a

1088
00:50:06,359 --> 00:50:08,460
very recent work I didn't include here

1089
00:50:08,460 --> 00:50:09,960
uh

1090
00:50:09,960 --> 00:50:12,839
the first one is like uh the the trivial

1091
00:50:12,839 --> 00:50:15,000
solution like if you have a few uh

1092
00:50:15,000 --> 00:50:17,099
functional encryption for circuits and

1093
00:50:17,099 --> 00:50:19,020
then you can convert this run program to

1094
00:50:19,020 --> 00:50:20,880
a circuits and then you can use the

1095
00:50:20,880 --> 00:50:22,859
functional encryption for circuit to

1096
00:50:22,859 --> 00:50:24,540
construct a functional encryption for

1097
00:50:24,540 --> 00:50:26,940
right but you you will have this like

1098
00:50:26,940 --> 00:50:29,760
polynomial uh so the runtime of this

1099
00:50:29,760 --> 00:50:32,099
like approach uh the decryption well

1100
00:50:32,099 --> 00:50:33,900
depends on the

1101
00:50:33,900 --> 00:50:36,720
um the the smart key which is input

1102
00:50:36,720 --> 00:50:39,780
specific uh runtime and also the uh the

1103
00:50:39,780 --> 00:50:42,000
capital end which is the size of the

1104
00:50:42,000 --> 00:50:44,280
database and if the size of database is

1105
00:50:44,280 --> 00:50:46,980
very large then this is not desirable

1106
00:50:46,980 --> 00:50:49,740
and the second approach is by James or

1107
00:50:49,740 --> 00:50:52,380
in 2014 that they show how to construct

1108
00:50:52,380 --> 00:50:55,500
single key Fe programs uh yeah so our

1109
00:50:55,500 --> 00:50:57,119
goal in this paper is to say like

1110
00:50:57,119 --> 00:51:00,000
whether like how to how can we like do

1111
00:51:00,000 --> 00:51:01,740
this like a collusion resistant Fe

1112
00:51:01,740 --> 00:51:04,200
programs with succinct the decryption so

1113
00:51:04,200 --> 00:51:06,900
I think that here means uh the

1114
00:51:06,900 --> 00:51:08,700
decryption only depends on the input

1115
00:51:08,700 --> 00:51:11,160
specific runtime of the Run program

1116
00:51:11,160 --> 00:51:12,500
okay

1117
00:51:12,500 --> 00:51:15,240
uh yeah the starting point is of course

1118
00:51:15,240 --> 00:51:17,880
the government so government the syntax

1119
00:51:17,880 --> 00:51:19,319
of the government in something like this

1120
00:51:19,319 --> 00:51:22,500
so there is exists a couple uh coupling

1121
00:51:22,500 --> 00:51:24,240
for the database which takes the

1122
00:51:24,240 --> 00:51:26,760
security parameter uh the database and

1123
00:51:26,760 --> 00:51:28,680
also the upper bound on the runtime for

1124
00:51:28,680 --> 00:51:31,680
uh of the runtime which is a capital T

1125
00:51:31,680 --> 00:51:33,960
and it will output the double database

1126
00:51:33,960 --> 00:51:36,359
that's deployed and also the circle key

1127
00:51:36,359 --> 00:51:38,160
which will be used to couple the program

1128
00:51:38,160 --> 00:51:40,619
the second algorithm the double uh

1129
00:51:40,619 --> 00:51:42,960
program takes the second key and also

1130
00:51:42,960 --> 00:51:44,400
the programs will output the double

1131
00:51:44,400 --> 00:51:47,220
program P1 and the evaluation which is

1132
00:51:47,220 --> 00:51:50,220
treated as a rent program uh uh so which

1133
00:51:50,220 --> 00:51:52,319
means it has like render access to the

1134
00:51:52,319 --> 00:51:53,180
double

1135
00:51:53,180 --> 00:51:56,160
database D Prime and it will take P

1136
00:51:56,160 --> 00:51:58,559
Point as input and it will output the P

1137
00:51:58,559 --> 00:52:01,500
to the D which is actual output and so

1138
00:52:01,500 --> 00:52:03,300
this can be treated as a one-time secret

1139
00:52:03,300 --> 00:52:07,319
key Fe for Ram I'm some like a normal

1140
00:52:07,319 --> 00:52:08,940
prioritize in constructing discover

1141
00:52:08,940 --> 00:52:11,280
rights to say like first we construct

1142
00:52:11,280 --> 00:52:14,280
the double run in the Uma setting which

1143
00:52:14,280 --> 00:52:16,920
is unprotected memory access setting

1144
00:52:16,920 --> 00:52:19,680
then we upgrade it to like full security

1145
00:52:19,680 --> 00:52:22,380
so like we use like basically all run to

1146
00:52:22,380 --> 00:52:26,880
cover the uh the rent access pattern uh

1147
00:52:26,880 --> 00:52:29,579
uh we we use orange to cover the memory

1148
00:52:29,579 --> 00:52:31,440
access pattern and we use second key

1149
00:52:31,440 --> 00:52:34,020
encryption to cover the extra memory

1150
00:52:34,020 --> 00:52:36,720
contents so that's a basic Paradigm

1151
00:52:36,720 --> 00:52:39,480
constructing uh government

1152
00:52:39,480 --> 00:52:42,660
and the challenges like if we if we want

1153
00:52:42,660 --> 00:52:45,059
to like go from a government to like a

1154
00:52:45,059 --> 00:52:47,460
functional encryption programs there are

1155
00:52:47,460 --> 00:52:49,800
some challenges in there the first the

1156
00:52:49,800 --> 00:52:51,780
first thing is like uh parallel

1157
00:52:51,780 --> 00:52:55,380
reusability like as shown by handling uh

1158
00:52:55,380 --> 00:52:59,040
at all in 20 uh 2019 like this existing

1159
00:52:59,040 --> 00:53:01,859
uh government I mean secure in parallel

1160
00:53:01,859 --> 00:53:04,260
reusability study they are only securing

1161
00:53:04,260 --> 00:53:06,240
this like a sequential visibility

1162
00:53:06,240 --> 00:53:09,660
setting uh yeah so maybe like we can use

1163
00:53:09,660 --> 00:53:12,119
FG for circuits uh to achieve this

1164
00:53:12,119 --> 00:53:15,300
parallel reusability which means like it

1165
00:53:15,300 --> 00:53:17,579
can be like run by a several like uh

1166
00:53:17,579 --> 00:53:20,460
decrypter uh in parallel and we still

1167
00:53:20,460 --> 00:53:23,099
can achieve security and second part is

1168
00:53:23,099 --> 00:53:26,119
like succinct so for such

1169
00:53:26,119 --> 00:53:29,400
we require the parameters neither go

1170
00:53:29,400 --> 00:53:32,280
with the database lens know the worst

1171
00:53:32,280 --> 00:53:34,260
case runtime and the decryption time

1172
00:53:34,260 --> 00:53:36,300
only goes to make a proportional to the

1173
00:53:36,300 --> 00:53:40,260
input specific uh time so we can perhaps

1174
00:53:40,260 --> 00:53:43,440
use succinct the government which will

1175
00:53:43,440 --> 00:53:45,839
be used here but it doesn't have this

1176
00:53:45,839 --> 00:53:49,500
like parallel reusability so our high

1177
00:53:49,500 --> 00:53:52,020
level ideas like we we can like combine

1178
00:53:52,020 --> 00:53:54,960
these Fe for circuits and also succinct

1179
00:53:54,960 --> 00:53:57,300
the double run with some special

1180
00:53:57,300 --> 00:53:59,700
properties to achieve fee for rent so

1181
00:53:59,700 --> 00:54:01,559
that's a high level idea

1182
00:54:01,559 --> 00:54:04,200
uh yeah so we start from this this like

1183
00:54:04,200 --> 00:54:08,280
non-succinct double RAM and yeah and and

1184
00:54:08,280 --> 00:54:12,359
using some tricks like like uh uh IO we

1185
00:54:12,359 --> 00:54:14,579
can get I think the double run and then

1186
00:54:14,579 --> 00:54:16,319
uh from the succinct double run we can

1187
00:54:16,319 --> 00:54:18,780
get the succincter and also reusable

1188
00:54:18,780 --> 00:54:21,900
government and then combining uh this I

1189
00:54:21,900 --> 00:54:23,700
think the reusable government one with

1190
00:54:23,700 --> 00:54:26,339
like SC for circuit we can get Fe for m

1191
00:54:26,339 --> 00:54:28,559
so that's the roadmap to achieve this

1192
00:54:28,559 --> 00:54:31,520
fee for run Construction

1193
00:54:32,339 --> 00:54:33,839
start from the beginning

1194
00:54:33,839 --> 00:54:35,040
uh

1195
00:54:35,040 --> 00:54:37,500
yeah so the uh we start from the

1196
00:54:37,500 --> 00:54:40,020
non-fiction government and this means

1197
00:54:40,020 --> 00:54:42,420
the parameters in the skin could grow

1198
00:54:42,420 --> 00:54:44,220
with a worst case runtime of the Run

1199
00:54:44,220 --> 00:54:46,500
program and for the for the evaluation

1200
00:54:46,500 --> 00:54:48,960
actually we require the time needed um

1201
00:54:48,960 --> 00:54:51,240
here is like only proportional to the

1202
00:54:51,240 --> 00:54:53,460
actual runtime of the computation and

1203
00:54:53,460 --> 00:54:55,920
it's independent of the database and

1204
00:54:55,920 --> 00:54:58,319
such as Skin can be constructed from a

1205
00:54:58,319 --> 00:54:59,819
double circuit which can be construct

1206
00:54:59,819 --> 00:55:01,859
called one-way function and for each

1207
00:55:01,859 --> 00:55:04,500
step like the the blueprint for

1208
00:55:04,500 --> 00:55:07,859
Constructor this thing the governance to

1209
00:55:07,859 --> 00:55:10,140
something like this like for each step

1210
00:55:10,140 --> 00:55:12,420
like we evaluate the ice double circuit

1211
00:55:12,420 --> 00:55:15,359
to get the ice step of the execution for

1212
00:55:15,359 --> 00:55:17,460
the P to the D which is a random

1213
00:55:17,460 --> 00:55:19,380
execution and then we compute the

1214
00:55:19,380 --> 00:55:21,720
recording step like we go from the ice

1215
00:55:21,720 --> 00:55:25,460
output encoding to the I plus one as uh

1216
00:55:25,460 --> 00:55:29,339
wire labels so through this way we can

1217
00:55:29,339 --> 00:55:32,040
like we can use a couple circuit to

1218
00:55:32,040 --> 00:55:34,920
translate from the uh the current step

1219
00:55:34,920 --> 00:55:36,960
to the next step and for full security

1220
00:55:36,960 --> 00:55:39,300
we can use Aura as I said before to hide

1221
00:55:39,300 --> 00:55:41,460
the memory access pattern and when we

1222
00:55:41,460 --> 00:55:43,140
will select key encryption to hide the

1223
00:55:43,140 --> 00:55:45,180
red uh to hide the memory content

1224
00:55:45,180 --> 00:55:47,899
basically

1225
00:55:48,660 --> 00:55:52,380
okay so like uh succinct like goes to go

1226
00:55:52,380 --> 00:55:55,200
from a non-succincter a couple run to

1227
00:55:55,200 --> 00:55:57,540
affecting the Gap around will use like

1228
00:55:57,540 --> 00:55:59,339
the obfuscation to dedicate the

1229
00:55:59,339 --> 00:56:02,579
execution of this non-succinct part I

1230
00:56:02,579 --> 00:56:04,440
think the governor means like the size

1231
00:56:04,440 --> 00:56:06,839
of the double uh double program is

1232
00:56:06,839 --> 00:56:09,180
independent of the worst case runtime

1233
00:56:09,180 --> 00:56:13,079
key capital T as as a record in the last

1234
00:56:13,079 --> 00:56:15,839
night like for each uh for each step we

1235
00:56:15,839 --> 00:56:18,000
need to generate a couple circuits uh

1236
00:56:18,000 --> 00:56:19,800
which means the size of the Govern

1237
00:56:19,800 --> 00:56:22,440
depends on the upper bound of the

1238
00:56:22,440 --> 00:56:24,900
runtime which is capital D so the idea

1239
00:56:24,900 --> 00:56:27,780
here is we use a obfuscated circuits

1240
00:56:27,780 --> 00:56:29,760
that will produce a non-succinct

1241
00:56:29,760 --> 00:56:32,579
governing of the program and then but

1242
00:56:32,579 --> 00:56:35,400
just obfuscating the lung succinct the

1243
00:56:35,400 --> 00:56:38,160
double procedure doesn't work since the

1244
00:56:38,160 --> 00:56:40,319
size of the obfuscating circuit will be

1245
00:56:40,319 --> 00:56:42,180
as large as the size of the non-fiction

1246
00:56:42,180 --> 00:56:44,579
the coupling program so we need some

1247
00:56:44,579 --> 00:56:46,619
property like we can we need to

1248
00:56:46,619 --> 00:56:49,319
decompose the double programming to

1249
00:56:49,319 --> 00:56:51,540
manage more components such as the

1250
00:56:51,540 --> 00:56:54,540
obfuscated circuit will only produce one

1251
00:56:54,540 --> 00:56:58,079
component at a time and yes so these two

1252
00:56:58,079 --> 00:56:59,880
properties we need here is like the

1253
00:56:59,880 --> 00:57:02,099
first taste like we can keep compose a

1254
00:57:02,099 --> 00:57:04,140
program into this small independent

1255
00:57:04,140 --> 00:57:07,440
components and to argue the security we

1256
00:57:07,440 --> 00:57:10,380
need to carry out the hybrid of the

1257
00:57:10,380 --> 00:57:11,720
non-fiction

1258
00:57:11,720 --> 00:57:15,960
by under high wire uh Hardware will

1259
00:57:15,960 --> 00:57:18,119
adjust the small subsets of the

1260
00:57:18,119 --> 00:57:21,440
component at a time and by the local

1261
00:57:21,440 --> 00:57:24,480
simulatability we can guarantee that in

1262
00:57:24,480 --> 00:57:27,420
each hybrid the um the amount of the hot

1263
00:57:27,420 --> 00:57:30,599
wired information is never too much and

1264
00:57:30,599 --> 00:57:32,099
therefore we can achieve the thickness

1265
00:57:32,099 --> 00:57:35,460
so that's a two necessary properties to

1266
00:57:35,460 --> 00:57:38,640
go from the non-succinct government to

1267
00:57:38,640 --> 00:57:41,099
uh to government to succinct the

1268
00:57:41,099 --> 00:57:43,280
government

1269
00:57:43,520 --> 00:57:47,520
uh yeah so so like for Uma security and

1270
00:57:47,520 --> 00:57:49,500
like uh so as I said before there's a

1271
00:57:49,500 --> 00:57:52,140
paradise like we first constructed the

1272
00:57:52,140 --> 00:57:54,180
Uma security then we go from the um

1273
00:57:54,180 --> 00:57:57,420
security to uh to full security and for

1274
00:57:57,420 --> 00:57:59,339
the um security we can actually use um

1275
00:57:59,339 --> 00:58:03,480
uh the the nice work uh in GEOS 18 to 35

1276
00:58:03,480 --> 00:58:05,220
they already satisfied the two

1277
00:58:05,220 --> 00:58:07,980
properties I mentioned before and two of

1278
00:58:07,980 --> 00:58:10,140
for full security we did this like

1279
00:58:10,140 --> 00:58:12,180
around with strong localized

1280
00:58:12,180 --> 00:58:13,680
surrenderness which will be used to

1281
00:58:13,680 --> 00:58:16,140
achieve this local simulatability and

1282
00:58:16,140 --> 00:58:18,240
then we use this like a Time encryption

1283
00:58:18,240 --> 00:58:21,000
so time encryption like at high level is

1284
00:58:21,000 --> 00:58:22,680
just an encryption scheme that are

1285
00:58:22,680 --> 00:58:24,960
allows you to issue the encryption

1286
00:58:24,960 --> 00:58:27,420
decryption keys with scoring power as a

1287
00:58:27,420 --> 00:58:30,720
evaluation goes down so like a case at a

1288
00:58:30,720 --> 00:58:32,520
time T can be decrypted anything that

1289
00:58:32,520 --> 00:58:34,500
was encrypted under time keep but it

1290
00:58:34,500 --> 00:58:37,440
cannot decrypt anything like uh upper uh

1291
00:58:37,440 --> 00:58:40,380
that is not larger than key so using

1292
00:58:40,380 --> 00:58:43,260
this like two um additional components

1293
00:58:43,260 --> 00:58:45,480
the around with strong no condenser

1294
00:58:45,480 --> 00:58:47,099
Randomness and the time encryption we

1295
00:58:47,099 --> 00:58:49,559
can achieve full security so that's for

1296
00:58:49,559 --> 00:58:52,559
the succincter double run part but the

1297
00:58:52,559 --> 00:58:54,599
succinct the double run itself is not

1298
00:58:54,599 --> 00:58:57,599
going to be sufficient to construct uh

1299
00:58:57,599 --> 00:59:00,540
the FPA programs like record like in Fe

1300
00:59:00,540 --> 00:59:03,420
and Fe for rent the adversary he can get

1301
00:59:03,420 --> 00:59:06,180
like many functional Keys as he wants

1302
00:59:06,180 --> 00:59:08,700
and he can do this like uh do this

1303
00:59:08,700 --> 00:59:11,280
decryption in parallel so we need this

1304
00:59:11,280 --> 00:59:14,460
like reusable I mean like uh parallel

1305
00:59:14,460 --> 00:59:17,940
really visible government so this means

1306
00:59:17,940 --> 00:59:19,579
like given this like a couple of

1307
00:59:19,579 --> 00:59:23,339
database D Prime and multiple and also

1308
00:59:23,339 --> 00:59:26,460
multiple double program P1 Prime to PK

1309
00:59:26,460 --> 00:59:29,099
Prime we can only learn this like P1 to

1310
00:59:29,099 --> 00:59:33,540
the D uh to PK to the D and we online

1311
00:59:33,540 --> 00:59:35,700
learn this like output instead of like

1312
00:59:35,700 --> 00:59:39,599
uh anything about the database

1313
00:59:39,599 --> 00:59:40,260
um

1314
00:59:40,260 --> 00:59:43,260
yeah so like uh to construct this like

1315
00:59:43,260 --> 00:59:45,960
succinct and also reducible double wrap

1316
00:59:45,960 --> 00:59:49,140
we also it is like very useful to split

1317
00:59:49,140 --> 00:59:51,420
this thing into two parts uh in the

1318
00:59:51,420 --> 00:59:53,040
first part we need to construct this

1319
00:59:53,040 --> 00:59:56,819
like succinct reusable double run with

1320
00:59:56,819 --> 00:59:59,819
Uma uh which is securing the Umi setting

1321
00:59:59,819 --> 01:00:01,079
and

1322
01:00:01,079 --> 01:00:03,119
and notes like in English like you

1323
01:00:03,119 --> 01:00:06,240
understand what we need to do is to

1324
01:00:06,240 --> 01:00:09,000
protect the memory execution and we do

1325
01:00:09,000 --> 01:00:11,460
not face any any like trouble in

1326
01:00:11,460 --> 01:00:13,859
adapting the skin like the GEOS 18 skin

1327
01:00:13,859 --> 01:00:17,700
into the real reasonable setting uh so

1328
01:00:17,700 --> 01:00:19,980
the first part is easy the Uma party is

1329
01:00:19,980 --> 01:00:23,099
easy and the second part is like we need

1330
01:00:23,099 --> 01:00:26,160
to use this like Uma secure a couple run

1331
01:00:26,160 --> 01:00:28,680
to construct a fully secure succinct the

1332
01:00:28,680 --> 01:00:30,599
reusable double wrap so that's the

1333
01:00:30,599 --> 01:00:32,280
second step

1334
01:00:32,280 --> 01:00:35,640
okay uh yeah so there are uh some

1335
01:00:35,640 --> 01:00:38,280
challenges in the Second Step uh the

1336
01:00:38,280 --> 01:00:40,140
first one is like we need to protect the

1337
01:00:40,140 --> 01:00:42,960
memory content uh so to protect the

1338
01:00:42,960 --> 01:00:45,599
content of the memory we need to encrypt

1339
01:00:45,599 --> 01:00:48,059
uh the encryption came into our Global

1340
01:00:48,059 --> 01:00:50,579
program but however like if we are

1341
01:00:50,579 --> 01:00:52,980
giving out one double program we can no

1342
01:00:52,980 --> 01:00:54,960
longer invoke the security of the

1343
01:00:54,960 --> 01:00:56,460
encryption scheme to see that the

1344
01:00:56,460 --> 01:00:58,799
adversary has no information about an

1345
01:00:58,799 --> 01:01:01,980
online database so uh since the the

1346
01:01:01,980 --> 01:01:04,079
couple program contains a hardware a

1347
01:01:04,079 --> 01:01:06,180
second key so therefore we need to

1348
01:01:06,180 --> 01:01:08,940
remove the encryption skin hybrid in the

1349
01:01:08,940 --> 01:01:11,280
hybrid very carefully so on a high level

1350
01:01:11,280 --> 01:01:13,440
the idea is to like remove the

1351
01:01:13,440 --> 01:01:15,480
encryption scheme one by one in each

1352
01:01:15,480 --> 01:01:18,299
hybrid like we start from the encryption

1353
01:01:18,299 --> 01:01:21,059
scheme for the master double program and

1354
01:01:21,059 --> 01:01:23,520
we just write this like junk in the

1355
01:01:23,520 --> 01:01:25,799
database instead and then we use the

1356
01:01:25,799 --> 01:01:29,339
index English indeed security to argue

1357
01:01:29,339 --> 01:01:32,220
that this is indistinguishable from the

1358
01:01:32,220 --> 01:01:34,920
previous type uh the previous the second

1359
01:01:34,920 --> 01:01:37,619
last hybrid and then we move from the

1360
01:01:37,619 --> 01:01:39,900
last hybrid to the second last hybrids

1361
01:01:39,900 --> 01:01:42,980
and so on so forth

1362
01:01:44,000 --> 01:01:47,220
doesn't work either reusable case things

1363
01:01:47,220 --> 01:01:50,339
like when we try to equivocate the

1364
01:01:50,339 --> 01:01:52,440
output or the database rights and remove

1365
01:01:52,440 --> 01:01:55,319
the encryption key the diversary action

1366
01:01:55,319 --> 01:01:57,119
and like he can in principle still be

1367
01:01:57,119 --> 01:01:58,680
able to distinguish the two

1368
01:01:58,680 --> 01:02:01,500
distributions I just like the same time

1369
01:02:01,500 --> 01:02:03,780
encryption was will appear in the other

1370
01:02:03,780 --> 01:02:06,299
Global program so that's like one issue

1371
01:02:06,299 --> 01:02:08,880
like we need to tackle and the second

1372
01:02:08,880 --> 01:02:11,220
issue like this like how to protect the

1373
01:02:11,220 --> 01:02:13,140
memory access pattern

1374
01:02:13,140 --> 01:02:15,839
like we need to like somehow change the

1375
01:02:15,839 --> 01:02:18,420
access pattern without hardwiring like

1376
01:02:18,420 --> 01:02:21,240
too much information so for that uh we

1377
01:02:21,240 --> 01:02:23,579
need to use the rewindable overrent with

1378
01:02:23,579 --> 01:02:25,700
strong localized randomness

1379
01:02:25,700 --> 01:02:29,040
uh you have to like like we designed

1380
01:02:29,040 --> 01:02:30,720
this like a rewindable or runs can

1381
01:02:30,720 --> 01:02:33,119
satisfy this like a strong localized

1382
01:02:33,119 --> 01:02:35,460
surrenderness which will be uh relying

1383
01:02:35,460 --> 01:02:39,660
on the public key double efficient peer

1384
01:02:39,660 --> 01:02:43,740
okay so so so to put teams together like

1385
01:02:43,740 --> 01:02:46,200
we show like we can construct the fear

1386
01:02:46,200 --> 01:02:48,000
for runs like this so it is a

1387
01:02:48,000 --> 01:02:50,460
combination of Fe for circuits and also

1388
01:02:50,460 --> 01:02:52,319
that's a thing the reusable government

1389
01:02:52,319 --> 01:02:56,280
so to encrypt a data a database D we

1390
01:02:56,280 --> 01:02:58,799
first use the succinct and the reusable

1391
01:02:58,799 --> 01:03:01,140
double run to double the database and

1392
01:03:01,140 --> 01:03:03,119
then we get the D Prime which is a

1393
01:03:03,119 --> 01:03:05,400
double database and the second key and

1394
01:03:05,400 --> 01:03:07,680
then we use a functional encryption for

1395
01:03:07,680 --> 01:03:08,940
circuits

1396
01:03:08,940 --> 01:03:11,700
to encrypt this security and to generate

1397
01:03:11,700 --> 01:03:14,520
a ciphertext and the perfect text for

1398
01:03:14,520 --> 01:03:16,680
the Fe for rent will be this next two

1399
01:03:16,680 --> 01:03:19,260
components the double database deploy

1400
01:03:19,260 --> 01:03:21,000
under the server text for the functional

1401
01:03:21,000 --> 01:03:23,940
encryption uh scheme for circuits

1402
01:03:23,940 --> 01:03:26,819
okay so that's the encryption part and

1403
01:03:26,819 --> 01:03:29,099
to generate the function key for for

1404
01:03:29,099 --> 01:03:32,160
program for run program P we first

1405
01:03:32,160 --> 01:03:35,040
design or Define this circuits G to be

1406
01:03:35,040 --> 01:03:39,000
the double to be the to be the coupling

1407
01:03:39,000 --> 01:03:42,599
of the program uh which will which has a

1408
01:03:42,599 --> 01:03:45,960
p uh hardwired but will take the second

1409
01:03:45,960 --> 01:03:49,079
key as input and then we generate

1410
01:03:49,079 --> 01:03:52,380
um we generate the thicker key for this

1411
01:03:52,380 --> 01:03:55,440
uh newly defined circuits and the second

1412
01:03:55,440 --> 01:03:58,500
key for the ram program will be the

1413
01:03:58,500 --> 01:04:01,859
second key the SK sub G

1414
01:04:01,859 --> 01:04:05,520
okay to decrease uh like to decrypt like

1415
01:04:05,520 --> 01:04:07,680
reference maybe to recover the

1416
01:04:07,680 --> 01:04:09,900
government program P Prime which will be

1417
01:04:09,900 --> 01:04:12,660
done by using the decryption algorithm

1418
01:04:12,660 --> 01:04:14,819
for the functional encryption uh for

1419
01:04:14,819 --> 01:04:17,520
circuits and then we can use the double

1420
01:04:17,520 --> 01:04:20,099
evaluation uh for the governor program

1421
01:04:20,099 --> 01:04:22,980
uh for the government to do the actual

1422
01:04:22,980 --> 01:04:25,619
evaluation and the security proof will

1423
01:04:25,619 --> 01:04:27,480
like if you wish first the hot wire as a

1424
01:04:27,480 --> 01:04:29,339
double program and then we use a

1425
01:04:29,339 --> 01:04:32,220
reusable security of the of the

1426
01:04:32,220 --> 01:04:34,020
government to argue the security proof

1427
01:04:34,020 --> 01:04:35,760
on like I won't talk about the security

1428
01:04:35,760 --> 01:04:37,980
proof here

1429
01:04:37,980 --> 01:04:41,339
okay so in summary like uh our results

1430
01:04:41,339 --> 01:04:43,440
like we've shown like our Fe for

1431
01:04:43,440 --> 01:04:45,900
circuits plus I think the reducible

1432
01:04:45,900 --> 01:04:48,079
double round then we can get Fe for rent

1433
01:04:48,079 --> 01:04:51,359
and uh compared with a trivial uh

1434
01:04:51,359 --> 01:04:54,299
solution which is the combination of Fe

1435
01:04:54,299 --> 01:04:58,200
for circuit uh with uh the rental

1436
01:04:58,200 --> 01:05:01,200
circuit conversion our work achieves the

1437
01:05:01,200 --> 01:05:04,859
succinct like in every perspective so

1438
01:05:04,859 --> 01:05:08,400
yeah so that's our result and there are

1439
01:05:08,400 --> 01:05:11,160
there are many missing details in this

1440
01:05:11,160 --> 01:05:13,559
talk and we also show like actually you

1441
01:05:13,559 --> 01:05:16,440
can do on this key for uh from the kfv4

1442
01:05:16,440 --> 01:05:19,859
brands uh also like in our paper like if

1443
01:05:19,859 --> 01:05:21,420
you are interested please take a look at

1444
01:05:21,420 --> 01:05:23,040
our paper thank you I'm happy to take

1445
01:05:23,040 --> 01:05:25,520
any questions

1446
01:05:29,540 --> 01:05:32,520
the time whole question uh are there any

1447
01:05:32,520 --> 01:05:34,880
question

1448
01:05:49,859 --> 01:05:53,819
my question is uh so finally you use IO

1449
01:05:53,819 --> 01:05:55,680
in the construction right

1450
01:05:55,680 --> 01:05:58,500
can you go to the previous slide

1451
01:05:58,500 --> 01:06:00,540
yeah like

1452
01:06:00,540 --> 01:06:03,180
uh like you yeah no no just the second

1453
01:06:03,180 --> 01:06:06,059
last the second last slide

1454
01:06:06,059 --> 01:06:09,180
the yeah yeah so the first succinct for

1455
01:06:09,180 --> 01:06:11,760
succinct reusable double Ram I believe

1456
01:06:11,760 --> 01:06:14,220
you're using uh you need IO is that

1457
01:06:14,220 --> 01:06:15,359
correct

1458
01:06:15,359 --> 01:06:16,760
uh

1459
01:06:16,760 --> 01:06:20,760
oh you also did the VPP obfuscation

1460
01:06:20,760 --> 01:06:23,160
yeah to achieve the we run the power

1461
01:06:23,160 --> 01:06:25,579
over and we found like the strong

1462
01:06:25,579 --> 01:06:28,980
localized brightness so like yeah

1463
01:06:28,980 --> 01:06:31,980
uh yeah you need vbb obfuscation for

1464
01:06:31,980 --> 01:06:35,240
which class of circuits

1465
01:06:35,700 --> 01:06:41,220
for uh for the uh or we need maybe for

1466
01:06:41,220 --> 01:06:43,940
the like uh the I guess the

1467
01:06:43,940 --> 01:06:47,220
logarithmic depth of circuits yeah we

1468
01:06:47,220 --> 01:06:49,980
yeah since we need to use that to

1469
01:06:49,980 --> 01:06:52,319
construct this rewindable overall with

1470
01:06:52,319 --> 01:06:54,780
some special like the strong localized

1471
01:06:54,780 --> 01:06:56,940
Randomness property

1472
01:06:56,940 --> 01:06:59,400
yeah we we actually we also think about

1473
01:06:59,400 --> 01:07:02,160
whether this is like avoidable

1474
01:07:02,160 --> 01:07:04,799
yeah but we don't know how to do it

1475
01:07:04,799 --> 01:07:07,980
without a vbp obfuscation but as like in

1476
01:07:07,980 --> 01:07:11,700
the uh in the fhe for ramps paper they

1477
01:07:11,700 --> 01:07:13,980
also use the vbd authentication to

1478
01:07:13,980 --> 01:07:18,180
construct fhe for rent so yeah we didn't

1479
01:07:18,180 --> 01:07:20,880
make much progress on that front all

1480
01:07:20,880 --> 01:07:23,039
right thank you

1481
01:07:23,039 --> 01:07:24,839
thank you

1482
01:07:24,839 --> 01:07:28,460
are there any questions

1483
01:07:29,160 --> 01:07:31,799
so is is a proposal scheme is

1484
01:07:31,799 --> 01:07:33,720
adaptability secure or selectively

1485
01:07:33,720 --> 01:07:38,400
secure if collectively secure okay so

1486
01:07:38,400 --> 01:07:41,940
okay I see yeah and we also don't know

1487
01:07:41,940 --> 01:07:45,380
how to do adaptive security

1488
01:07:45,720 --> 01:07:48,319
thanks

1489
01:07:48,420 --> 01:07:51,780
now what's that question

1490
01:07:51,780 --> 01:07:55,140
okay let's speak again

1491
01:07:55,140 --> 01:07:57,799
thank you

1492
01:08:00,500 --> 01:08:03,299
the last talk of this session is

1493
01:08:03,299 --> 01:08:05,460
knowledge encryption and its

1494
01:08:05,460 --> 01:08:07,799
applications to simulatable protocols

1495
01:08:07,799 --> 01:08:12,559
with low around the complexity by E Deng

1496
01:08:12,559 --> 01:08:16,920
and xinjiang is going to talk

1497
01:08:16,920 --> 01:08:19,520
online

1498
01:08:20,819 --> 01:08:24,380
uh can you hear me

1499
01:08:26,580 --> 01:08:28,799
okay

1500
01:08:28,799 --> 01:08:32,279
thank you for inspiration uh into the

1501
01:08:32,279 --> 01:08:34,439
top I would love to present our people

1502
01:08:34,439 --> 01:08:40,160
I'm assuming is a joint work with Eden

1503
01:08:43,859 --> 01:08:46,799
uh in this talk I will first introduce

1504
01:08:46,799 --> 01:08:50,100
the our motivation and the second I will

1505
01:08:50,100 --> 01:08:51,069
show the

1506
01:08:51,069 --> 01:08:54,188
[Music]

1507
01:08:54,738 --> 01:08:57,600
then I will present a higher idea about

1508
01:08:57,600 --> 01:09:00,359
how to construct a noise encryption and

1509
01:09:00,359 --> 01:09:02,819
finally I will give a simple

1510
01:09:02,819 --> 01:09:06,799
introduction about this applications

1511
01:09:08,580 --> 01:09:11,160
first let's consider the following

1512
01:09:11,160 --> 01:09:13,620
simple particle roughly the welfare

1513
01:09:13,620 --> 01:09:16,198
office is publicated to the approval and

1514
01:09:16,198 --> 01:09:18,839
approval will encrypt is developed print

1515
01:09:18,839 --> 01:09:21,299
that it knows the secret key or some

1516
01:09:21,299 --> 01:09:24,000
other instruments uh that's a toy

1517
01:09:24,000 --> 01:09:27,719
example and Let's ignore the thumbnails

1518
01:09:27,719 --> 01:09:30,179
is here and the only consider simulating

1519
01:09:30,179 --> 01:09:32,160
the approval

1520
01:09:32,160 --> 01:09:34,319
now as you can see if the welfare

1521
01:09:34,319 --> 01:09:36,540
doesn't know the degree key

1522
01:09:36,540 --> 01:09:39,479
and it can describe the distinguishes of

1523
01:09:39,479 --> 01:09:40,859
text

1524
01:09:40,859 --> 01:09:43,500
but you can't distinguisher or to craft

1525
01:09:43,500 --> 01:09:46,020
subtitles then the simulator can grab

1526
01:09:46,020 --> 01:09:50,420
the message to conclude the simulation

1527
01:09:52,460 --> 01:09:54,960
which means that it can describe or

1528
01:09:54,960 --> 01:09:57,300
distinguishes our tests then the

1529
01:09:57,300 --> 01:09:59,219
simulator can use the secret key as a

1530
01:09:59,219 --> 01:10:02,040
chapter to generate the double proof via

1531
01:10:02,040 --> 01:10:05,160
individual extraction

1532
01:10:05,160 --> 01:10:08,360
however this requests the underlying

1533
01:10:08,360 --> 01:10:11,640
encryption scheme satisfying that the

1534
01:10:11,640 --> 01:10:13,679
ability of distribution or description

1535
01:10:13,679 --> 01:10:16,080
the subtitles means the knowledge of the

1536
01:10:16,080 --> 01:10:19,080
secret key in other words what can

1537
01:10:19,080 --> 01:10:21,060
efficiently extract the secret key from

1538
01:10:21,060 --> 01:10:22,679
any decryption algorithm or

1539
01:10:22,679 --> 01:10:25,940
distinguishing algorithm

1540
01:10:27,780 --> 01:10:30,060
then consider the volume to encryption

1541
01:10:30,060 --> 01:10:33,300
schemes closing to our requirements that

1542
01:10:33,300 --> 01:10:35,280
written encryption and the conditional

1543
01:10:35,280 --> 01:10:36,900
disclosure scheme

1544
01:10:36,900 --> 01:10:39,540
which is increasing allows students to

1545
01:10:39,540 --> 01:10:42,300
use an MP instance as public key and the

1546
01:10:42,300 --> 01:10:45,120
corresponding within the secret key

1547
01:10:45,120 --> 01:10:47,580
and the CDs allows one to join the KPS

1548
01:10:47,580 --> 01:10:52,380
from an MP instance and its weakness

1549
01:10:52,380 --> 01:10:55,440
their security requested if the instance

1550
01:10:55,440 --> 01:10:58,380
is in wave no eventually no efficient

1551
01:10:58,380 --> 01:11:00,840
algorithms can craft a distinguished

1552
01:11:00,840 --> 01:11:03,179
subtitles

1553
01:11:03,179 --> 01:11:05,580
however neither of them provides any

1554
01:11:05,580 --> 01:11:07,860
security when using a willingness test

1555
01:11:07,860 --> 01:11:10,620
in other words the description algorithm

1556
01:11:10,620 --> 01:11:12,900
provides only a certain proof that the

1557
01:11:12,900 --> 01:11:16,519
corresponding public key is valid

1558
01:11:17,699 --> 01:11:20,040
now we have a question

1559
01:11:20,040 --> 01:11:22,320
can we construct a public key encryption

1560
01:11:22,320 --> 01:11:24,900
for which only algorithm that knows the

1561
01:11:24,900 --> 01:11:27,420
typical key can describe some text

1562
01:11:27,420 --> 01:11:29,580
in other words the description algorithm

1563
01:11:29,580 --> 01:11:31,560
provides a proof of knowledge of the

1564
01:11:31,560 --> 01:11:33,120
secret key

1565
01:11:33,120 --> 01:11:35,460
unfortunately most of existing

1566
01:11:35,460 --> 01:11:37,620
encryption schemes fail to certify these

1567
01:11:37,620 --> 01:11:39,060
requirements without knowledge of

1568
01:11:39,060 --> 01:11:40,020
substance

1569
01:11:40,020 --> 01:11:43,320
the only establishing aware of is the

1570
01:11:43,320 --> 01:11:45,300
average of roughness encryption

1571
01:11:45,300 --> 01:11:47,520
of which security is based on the

1572
01:11:47,520 --> 01:11:49,320
factory assumption

1573
01:11:49,320 --> 01:11:52,020
as shown in 2020 this consumption is

1574
01:11:52,020 --> 01:11:54,140
useful in construction tips and security

1575
01:11:54,140 --> 01:11:56,699
protocol protocols

1576
01:11:56,699 --> 01:11:59,159
such as selective opening secure

1577
01:11:59,159 --> 01:12:01,679
commitments and the concurrent zero

1578
01:12:01,679 --> 01:12:04,340
knowledge protocol

1579
01:12:06,420 --> 01:12:09,960
well motivated by this coaching we put

1580
01:12:09,960 --> 01:12:12,659
forward the notion of large encryption

1581
01:12:12,659 --> 01:12:15,000
like CDs another encryption is

1582
01:12:15,000 --> 01:12:17,460
associated with an MP language

1583
01:12:17,460 --> 01:12:20,520
the kpls are generated from an instance

1584
01:12:20,520 --> 01:12:22,280
and its Witness

1585
01:12:22,280 --> 01:12:24,900
related the public key and the secret

1586
01:12:24,900 --> 01:12:27,600
key contains the instance X and within

1587
01:12:27,600 --> 01:12:29,580
CW respectively

1588
01:12:29,580 --> 01:12:31,739
now the encryption should satisfy the

1589
01:12:31,739 --> 01:12:34,620
weakness accessibility in the

1590
01:12:34,620 --> 01:12:36,239
distinguishability and the public key

1591
01:12:36,239 --> 01:12:39,000
simulation properties

1592
01:12:39,000 --> 01:12:41,159
waiting this extractability claims that

1593
01:12:41,159 --> 01:12:43,679
if an efficient adulatory can

1594
01:12:43,679 --> 01:12:47,280
distinguish to craft level tests then

1595
01:12:47,280 --> 01:12:49,560
there is an efficient outcome extracting

1596
01:12:49,560 --> 01:12:51,780
the witness which is also part of the

1597
01:12:51,780 --> 01:12:55,380
security from the adversary

1598
01:12:55,380 --> 01:12:57,719
uh data should hold email from Malaysia

1599
01:12:57,719 --> 01:13:00,420
the generated probability

1600
01:13:00,420 --> 01:13:03,300
uh in distinguishability requested for

1601
01:13:03,300 --> 01:13:05,460
any fixed Final Fix for instance

1602
01:13:05,460 --> 01:13:08,159
weakness no efficient algorithm can

1603
01:13:08,159 --> 01:13:10,080
distinguish of attacks without the

1604
01:13:10,080 --> 01:13:11,159
duplicate

1605
01:13:11,159 --> 01:13:13,260
and the public key simulation requested

1606
01:13:13,260 --> 01:13:15,719
what can efficient assimilate publicly

1607
01:13:15,719 --> 01:13:18,179
for any valid incident without knowing

1608
01:13:18,179 --> 01:13:20,659
its weakness

1609
01:13:22,080 --> 01:13:24,060
in our paper we applied in two

1610
01:13:24,060 --> 01:13:26,219
conjunctions for another encryption

1611
01:13:26,219 --> 01:13:28,500
the first video based on RCBS and the

1612
01:13:28,500 --> 01:13:30,960
random cells reduced by encryption and

1613
01:13:30,960 --> 01:13:33,540
the second is based on CBS only

1614
01:13:33,540 --> 01:13:35,880
it means that the normal encryption can

1615
01:13:35,880 --> 01:13:38,159
be conducted from two round gambits to

1616
01:13:38,159 --> 01:13:40,560
secure by the way of transform which is

1617
01:13:40,560 --> 01:13:44,640
known from dth QR or LW assumptions

1618
01:13:44,640 --> 01:13:46,380
here we only give a higher idea about

1619
01:13:46,380 --> 01:13:49,340
the second Construction

1620
01:13:52,860 --> 01:13:55,320
remember that a CDF scheme can be

1621
01:13:55,320 --> 01:13:57,840
regarded as a special automatic secure

1622
01:13:57,840 --> 01:13:59,460
function evaluation

1623
01:13:59,460 --> 01:14:02,340
it can be Consolidated from a two rounds

1624
01:14:02,340 --> 01:14:04,980
of oblivious transfer with skin-based

1625
01:14:04,980 --> 01:14:06,960
security and governing secured scheme

1626
01:14:06,960 --> 01:14:10,380
for the security system on the slides

1627
01:14:10,380 --> 01:14:13,440
yeah this is a cute text inputs uh

1628
01:14:13,440 --> 01:14:15,840
instance as within this W and the

1629
01:14:15,840 --> 01:14:18,420
message M and the output the message you

1630
01:14:18,420 --> 01:14:21,420
find only if with W is a with the

1631
01:14:21,420 --> 01:14:23,940
witness files

1632
01:14:23,940 --> 01:14:26,820
our input X and the W the K generation

1633
01:14:26,820 --> 01:14:28,699
algorithm runs the first round of

1634
01:14:28,699 --> 01:14:31,040
obvious transfer to include the

1635
01:14:31,040 --> 01:14:33,360
witnessed bit by bit

1636
01:14:33,360 --> 01:14:36,840
it outputs and automatic is that as a

1637
01:14:36,840 --> 01:14:39,239
public key and the output W and the

1638
01:14:39,239 --> 01:14:42,960
randomness used in OT as the secret key

1639
01:14:42,960 --> 01:14:45,600
to encrypt a message the center of

1640
01:14:45,600 --> 01:14:48,060
discovers the circuit and since the

1641
01:14:48,060 --> 01:14:50,820
double execute and the corresponding

1642
01:14:50,820 --> 01:14:53,400
levels for x and M directly and the

1643
01:14:53,400 --> 01:14:56,100
signature levels for wyr

1644
01:14:56,100 --> 01:14:58,380
OT protocols

1645
01:14:58,380 --> 01:15:01,500
finally by retrieving the levels for w

1646
01:15:01,500 --> 01:15:05,400
from OT and uh and evaluating the double

1647
01:15:05,400 --> 01:15:08,100
circuit Circuit by Computing the method

1648
01:15:08,100 --> 01:15:10,699
encrypted

1649
01:15:11,340 --> 01:15:14,340
so to construct a large encryption

1650
01:15:14,340 --> 01:15:17,159
scheme uh we embed a simple decoding

1651
01:15:17,159 --> 01:15:19,679
mechanism in the security

1652
01:15:19,679 --> 01:15:22,800
unless you understand she has a extra

1653
01:15:22,800 --> 01:15:27,739
input y and the Y equals all zero string

1654
01:15:27,739 --> 01:15:30,840
same works in the same mannered before

1655
01:15:30,840 --> 01:15:33,840
whenever you call all zero string and

1656
01:15:33,840 --> 01:15:36,480
the W with it I believe the weakness

1657
01:15:36,480 --> 01:15:39,480
ywi

1658
01:15:40,199 --> 01:15:42,659
uh we modify the encryption the

1659
01:15:42,659 --> 01:15:45,060
decryption algorithms naturally

1660
01:15:45,060 --> 01:15:47,219
note that the honest encryption

1661
01:15:47,219 --> 01:15:49,620
algorithm always chooses why as all zero

1662
01:15:49,620 --> 01:15:52,040
string

1663
01:15:53,699 --> 01:15:55,980
uh here we only impressed into a hello

1664
01:15:55,980 --> 01:15:59,239
idea about the witness extra

1665
01:15:59,239 --> 01:16:01,199
extractability property of this

1666
01:16:01,199 --> 01:16:02,880
conjunction

1667
01:16:02,880 --> 01:16:06,780
okay okay observation here is that let's

1668
01:16:06,780 --> 01:16:09,120
run the slide we choose one as a string

1669
01:16:09,120 --> 01:16:12,600
of zero except suggest position

1670
01:16:12,600 --> 01:16:15,000
the result of the test will be

1671
01:16:15,000 --> 01:16:16,920
extinguishable from the encryption of

1672
01:16:16,920 --> 01:16:20,540
this partition of weakness

1673
01:16:21,420 --> 01:16:25,140
so an extractor can express the complete

1674
01:16:25,140 --> 01:16:28,020
witness a bit by bit by tracking that in

1675
01:16:28,020 --> 01:16:30,840
the view of adversary this subtitles is

1676
01:16:30,840 --> 01:16:33,840
closer to the subtext of which bit

1677
01:16:33,840 --> 01:16:38,300
we refer to our people for more details

1678
01:16:39,060 --> 01:16:42,300
now at the surrender slides knowledge

1679
01:16:42,300 --> 01:16:43,920
encryption is used for in the

1680
01:16:43,920 --> 01:16:46,620
construction of the first three round

1681
01:16:46,620 --> 01:16:48,780
tips on simulatable oblivious transfer

1682
01:16:48,780 --> 01:16:51,239
and lots of other protocols achieving

1683
01:16:51,239 --> 01:16:54,540
typical security such as data improve

1684
01:16:54,540 --> 01:16:57,360
their knowledge argument and

1685
01:16:57,360 --> 01:16:59,179
uh

1686
01:16:59,179 --> 01:17:01,880
two-party computation for independent

1687
01:17:01,880 --> 01:17:06,080
independent input function analysis

1688
01:17:07,940 --> 01:17:10,380
about the first Construction

1689
01:17:10,380 --> 01:17:12,480
and we refer to our people for more

1690
01:17:12,480 --> 01:17:16,099
teachers about other constructions

1691
01:17:19,380 --> 01:17:21,480
coverage transfer is a protocol between

1692
01:17:21,480 --> 01:17:24,360
a single holding two messages and a

1693
01:17:24,360 --> 01:17:26,340
receiver holding our choice speed

1694
01:17:26,340 --> 01:17:28,860
at the end of the protocol the receiver

1695
01:17:28,860 --> 01:17:30,840
should learn the message of its choice

1696
01:17:30,840 --> 01:17:32,520
but to learn nothing about the other

1697
01:17:32,520 --> 01:17:34,219
message

1698
01:17:34,219 --> 01:17:37,380
uh the center on the other hand should

1699
01:17:37,380 --> 01:17:39,360
learn nothing about the reservous choice

1700
01:17:39,360 --> 01:17:40,739
speech

1701
01:17:40,739 --> 01:17:43,980
using large encryption we construct the

1702
01:17:43,980 --> 01:17:45,840
fourth three round tips on a simulatable

1703
01:17:45,840 --> 01:17:49,580
unbelievous transfer satisfying the the

1704
01:17:49,580 --> 01:17:52,199
security for the receiver and the types

1705
01:17:52,199 --> 01:17:56,820
of simulatable security for the center

1706
01:17:56,820 --> 01:17:58,860
our construction relies on the

1707
01:17:58,860 --> 01:18:00,780
techniques including women conduction

1708
01:18:00,780 --> 01:18:03,239
and the individual reductions put

1709
01:18:03,239 --> 01:18:06,320
forward by them

1710
01:18:08,219 --> 01:18:10,980
uh a natural idea here is to have the

1711
01:18:10,980 --> 01:18:12,900
receiver during the appear of public

1712
01:18:12,900 --> 01:18:16,020
Keys pixel and pigment of not encryption

1713
01:18:16,020 --> 01:18:20,340
from two MP instance in instances F0 and

1714
01:18:20,340 --> 01:18:23,580
X1 and the receiver knows weapons for

1715
01:18:23,580 --> 01:18:25,560
one and the only one of these two

1716
01:18:25,560 --> 01:18:28,040
instances

1717
01:18:32,159 --> 01:18:35,699
under the so that it can receive one and

1718
01:18:35,699 --> 01:18:38,420
only one message encrypted by the single

1719
01:18:38,420 --> 01:18:41,580
amount is to public Keys one public key

1720
01:18:41,580 --> 01:18:43,560
is generated using the key generation

1721
01:18:43,560 --> 01:18:46,080
algorithm and the other issue is

1722
01:18:46,080 --> 01:18:48,360
generated using the public simulator

1723
01:18:48,360 --> 01:18:50,640
then for the center if you don't know

1724
01:18:50,640 --> 01:18:53,520
which one is simulated therefore it

1725
01:18:53,520 --> 01:18:57,840
doesn't know the input B of the receiver

1726
01:18:57,840 --> 01:19:00,659
now there are two major challenges first

1727
01:19:00,659 --> 01:19:02,880
we need to make sure that the receiver

1728
01:19:02,880 --> 01:19:05,219
knows which is for only one of these two

1729
01:19:05,219 --> 01:19:08,580
instances and second the estimation is

1730
01:19:08,580 --> 01:19:12,860
to extract the input of the adversaries

1731
01:19:13,260 --> 01:19:16,620
a 2004 challenge we require the center

1732
01:19:16,620 --> 01:19:19,380
to generate understand the hard NP

1733
01:19:19,380 --> 01:19:22,800
instance Y and the receiver uses a sigma

1734
01:19:22,800 --> 01:19:24,840
protocol to generate these two instances

1735
01:19:24,840 --> 01:19:28,199
F0 and X1

1736
01:19:28,199 --> 01:19:30,780
remind that a sigma protocol is a three

1737
01:19:30,780 --> 01:19:32,520
round probability coin protocol

1738
01:19:32,520 --> 01:19:34,860
certifies after finding the special

1739
01:19:34,860 --> 01:19:37,800
science and the special nice weather 09

1740
01:19:37,800 --> 01:19:40,199
properties the special sound is a

1741
01:19:40,199 --> 01:19:42,360
property request that given two

1742
01:19:42,360 --> 01:19:44,880
acceptable proofs with the same first

1743
01:19:44,880 --> 01:19:46,560
round message and different challenges

1744
01:19:46,560 --> 01:19:49,560
that can efficient efficiently extract

1745
01:19:49,560 --> 01:19:51,540
the weakness for the instance

1746
01:19:51,540 --> 01:19:54,480
as a special honestly welfare I don't

1747
01:19:54,480 --> 01:19:56,580
know the property request that give me a

1748
01:19:56,580 --> 01:19:58,800
challenge is easy to compute and

1749
01:19:58,800 --> 01:20:01,340
accepting transcript which is

1750
01:20:01,340 --> 01:20:05,340
indistinguishable from an honest one

1751
01:20:05,340 --> 01:20:09,199
now go back to our Construction

1752
01:20:11,659 --> 01:20:15,360
will prepare two instances Excel and

1753
01:20:15,360 --> 01:20:17,460
direct line in the following way

1754
01:20:17,460 --> 01:20:20,760
the first Trend with a random challenge

1755
01:20:20,760 --> 01:20:23,340
EP under runs the minister whatever

1756
01:20:23,340 --> 01:20:26,179
generation simulator to obtain a double

1757
01:20:26,179 --> 01:20:29,940
exceptional proof ABC for y

1758
01:20:29,940 --> 01:20:32,159
it shows there's another random change

1759
01:20:32,159 --> 01:20:34,640
the event must be

1760
01:20:34,640 --> 01:20:38,400
nothing calling to EP and says instances

1761
01:20:38,400 --> 01:20:43,020
x i in the form of Y AEI we coaxial yes

1762
01:20:43,020 --> 01:20:45,239
intensity you find only if there is a

1763
01:20:45,239 --> 01:20:48,540
strength C such that agic is a

1764
01:20:48,540 --> 01:20:51,360
acceptable proof for what

1765
01:20:51,360 --> 01:20:53,520
and from the special sign is of Sigma

1766
01:20:53,520 --> 01:20:55,920
protocol without the knowledge without

1767
01:20:55,920 --> 01:20:58,679
the weakness of Y anyone cannot change

1768
01:20:58,679 --> 01:21:01,620
the two acceptable proofs with a single

1769
01:21:01,620 --> 01:21:02,940
first round message about different

1770
01:21:02,940 --> 01:21:06,120
challenges therefore the receiver knows

1771
01:21:06,120 --> 01:21:10,640
which is for only one of XL and X1

1772
01:21:11,100 --> 01:21:13,679
and for the choice of why in our paper

1773
01:21:13,679 --> 01:21:17,340
we let y equals y zero y1 where y0 and Y

1774
01:21:17,340 --> 01:21:20,100
are emergence of when we function f why

1775
01:21:20,100 --> 01:21:22,320
it said to be a yes intense if there is

1776
01:21:22,320 --> 01:21:25,440
no such that f i equals y 0 or f i

1777
01:21:25,440 --> 01:21:28,020
equals YY

1778
01:21:28,020 --> 01:21:30,600
and finally the single approves to the

1779
01:21:30,600 --> 01:21:33,300
receiver that it knows when Prime image

1780
01:21:33,300 --> 01:21:37,020
of y 0 or 1 by a wi protocol certifying

1781
01:21:37,020 --> 01:21:39,719
special science this step is used for

1782
01:21:39,719 --> 01:21:43,340
the following security proof

1783
01:21:43,679 --> 01:21:47,460
uh to simulate the receiver roughly the

1784
01:21:47,460 --> 01:21:49,320
simulator Force which drags a weight

1785
01:21:49,320 --> 01:21:51,840
transfer y from the double approach by

1786
01:21:51,840 --> 01:21:54,719
rewinding then it can generate two years

1787
01:21:54,719 --> 01:21:58,440
instances f0x1 and therefore to win the

1788
01:21:58,440 --> 01:22:01,620
public Keys pk1 pixel or pick one with

1789
01:22:01,620 --> 01:22:04,219
their security case

1790
01:22:04,219 --> 01:22:07,920
when receiving the two-step attacks from

1791
01:22:07,920 --> 01:22:10,679
the center it can Equip to obtain both

1792
01:22:10,679 --> 01:22:13,040
messages and send them to the

1793
01:22:13,040 --> 01:22:16,380
functionality to conclude the simulation

1794
01:22:16,380 --> 01:22:19,380
from the fact that Simulator the public

1795
01:22:19,380 --> 01:22:21,659
key is indistinguishable from Honest One

1796
01:22:21,659 --> 01:22:24,659
the method is extracted by the simulator

1797
01:22:24,659 --> 01:22:26,820
in the ideal world are indistinguishable

1798
01:22:26,820 --> 01:22:29,100
from the output of receiver in the real

1799
01:22:29,100 --> 01:22:30,659
world

1800
01:22:30,659 --> 01:22:32,820
to manage that is a non-traditional

1801
01:22:32,820 --> 01:22:35,400
expression strategy the simulator

1802
01:22:35,400 --> 01:22:37,860
obtains message by property and rather

1803
01:22:37,860 --> 01:22:40,580
than rewinding

1804
01:22:41,340 --> 01:22:44,820
to simulate the finger the simulator

1805
01:22:44,820 --> 01:22:47,400
needs to extract the input bit of the

1806
01:22:47,400 --> 01:22:50,280
malicious receiver here we will use the

1807
01:22:50,280 --> 01:22:52,440
individual reduction technique for the

1808
01:22:52,440 --> 01:22:55,260
interpreting roughly this technique

1809
01:22:55,260 --> 01:22:58,020
shows that for any other stuff there is

1810
01:22:58,020 --> 01:23:00,719
a good explanatory outperforms all other

1811
01:23:00,719 --> 01:23:04,440
algorithms in excreting secret case or

1812
01:23:04,440 --> 01:23:07,099
Witnesses

1813
01:23:08,580 --> 01:23:12,179
the simulator runs this newly optimized

1814
01:23:12,179 --> 01:23:14,940
directory to extract the secret key or

1815
01:23:14,940 --> 01:23:16,800
in other words the weakness of the

1816
01:23:16,800 --> 01:23:19,500
instance are key public keys

1817
01:23:19,500 --> 01:23:22,500
receiver

1818
01:23:22,679 --> 01:23:25,860
according to the result of expansion the

1819
01:23:25,860 --> 01:23:28,500
simulator runs in different domains in

1820
01:23:28,500 --> 01:23:30,960
the case that it succeeds to extract

1821
01:23:30,960 --> 01:23:32,600
only one weakness

1822
01:23:32,600 --> 01:23:36,780
WB Prem the estimator that because B

1823
01:23:36,780 --> 01:23:40,020
Prime and sends it to the OT of

1824
01:23:40,020 --> 01:23:41,340
OT functionality

1825
01:23:41,340 --> 01:23:44,219
after obtaining the message MB the

1826
01:23:44,219 --> 01:23:46,620
simulator encrypts is using both public

1827
01:23:46,620 --> 01:23:49,080
Keys respectively to conclude the

1828
01:23:49,080 --> 01:23:50,580
simulation

1829
01:23:50,580 --> 01:23:53,460
in the case that it fails to extract

1830
01:23:53,460 --> 01:23:55,980
anything to Decay the simulator just

1831
01:23:55,980 --> 01:23:58,920
says because zero and continues and if

1832
01:23:58,920 --> 01:24:01,440
we succeed to extract both secret keys

1833
01:24:01,440 --> 01:24:06,199
the since the simulator does robots

1834
01:24:06,840 --> 01:24:08,760
now in the first case

1835
01:24:08,760 --> 01:24:11,159
it means that the auditory can only

1836
01:24:11,159 --> 01:24:13,560
describe the subjects under the public

1837
01:24:13,560 --> 01:24:15,000
KP

1838
01:24:15,000 --> 01:24:17,580
otherwise supposed to reward rate can

1839
01:24:17,580 --> 01:24:19,440
distribution the subtext on the public

1840
01:24:19,440 --> 01:24:22,699
key pk1 minus B same from the

1841
01:24:22,699 --> 01:24:24,719
extractability of another intribution

1842
01:24:24,719 --> 01:24:26,880
there is an efficient algorithm

1843
01:24:26,880 --> 01:24:30,960
extracting as extracting W1 minus B

1844
01:24:30,960 --> 01:24:33,960
breaking the optimality property of the

1845
01:24:33,960 --> 01:24:35,100
extractor

1846
01:24:35,100 --> 01:24:37,100
therefore

1847
01:24:37,100 --> 01:24:39,360
remember that the only difference

1848
01:24:39,360 --> 01:24:42,780
between an ideal execution and the real

1849
01:24:42,780 --> 01:24:44,640
one in this case is the message

1850
01:24:44,640 --> 01:24:47,400
encrypted using pk1 minus B

1851
01:24:47,400 --> 01:24:51,980
those three cannot distribution them

1852
01:24:53,820 --> 01:24:56,940
in the second case it means that the

1853
01:24:56,940 --> 01:24:59,880
auditory cannot describe a distribution

1854
01:24:59,880 --> 01:25:01,400
both subtitles

1855
01:25:01,400 --> 01:25:03,860
following a similar

1856
01:25:03,860 --> 01:25:07,320
analyst analytic analysis with both kids

1857
01:25:07,320 --> 01:25:10,140
it's easy to show that the military can

1858
01:25:10,140 --> 01:25:11,940
succeed for conclude the simulation in

1859
01:25:11,940 --> 01:25:14,219
this case

1860
01:25:14,219 --> 01:25:17,640
and I enter a third case if if it

1861
01:25:17,640 --> 01:25:20,640
accepts two weaknesses then from the

1862
01:25:20,640 --> 01:25:22,920
special science of Sigma protocol that

1863
01:25:22,920 --> 01:25:25,320
can efficiently extract a perimeter of

1864
01:25:25,320 --> 01:25:28,860
y0 or y1 which is the invisible from the

1865
01:25:28,860 --> 01:25:31,860
fact that a prime e Prime team Prime is

1866
01:25:31,860 --> 01:25:34,940
a weapons hiding

1867
01:25:35,280 --> 01:25:37,860
therefore the simulator will succeed in

1868
01:25:37,860 --> 01:25:40,739
all these cases in other words no matter

1869
01:25:40,739 --> 01:25:43,260
which strategies or those resources the

1870
01:25:43,260 --> 01:25:46,199
simulator will always win that's a

1871
01:25:46,199 --> 01:25:49,379
women's structure

1872
01:25:50,520 --> 01:25:53,400
at the end where at the end we present a

1873
01:25:53,400 --> 01:25:55,679
summary of our paper in our paper we

1874
01:25:55,679 --> 01:25:58,020
first introduced the notion of node

1875
01:25:58,020 --> 01:25:59,760
encryption and the president is

1876
01:25:59,760 --> 01:26:00,900
definition

1877
01:26:00,900 --> 01:26:03,420
then we press into two constructions for

1878
01:26:03,420 --> 01:26:05,580
another encryption which shows that now

1879
01:26:05,580 --> 01:26:07,560
the equation can be conducted from and

1880
01:26:07,560 --> 01:26:10,620
in two ranking with oblivious transfer

1881
01:26:10,620 --> 01:26:12,900
and finally we applied in some

1882
01:26:12,900 --> 01:26:14,940
applications of knowledge encryption

1883
01:26:14,940 --> 01:26:16,739
including the 4th Street around 50

1884
01:26:16,739 --> 01:26:19,020
percent multiple oblivious transfer and

1885
01:26:19,020 --> 01:26:22,219
a variety of protocols achieving typical

1886
01:26:22,219 --> 01:26:26,239
simulatable security which without

1887
01:26:26,239 --> 01:26:28,739
performance in either relying

1888
01:26:28,739 --> 01:26:32,178
establishing or security

1889
01:26:33,679 --> 01:26:37,340
thank you for your attention

1890
01:26:43,380 --> 01:26:46,639
are there any question

1891
01:26:50,280 --> 01:26:52,620
so knowledge encryption is very similar

1892
01:26:52,620 --> 01:26:55,920
to extra extractable witnessing equation

1893
01:26:55,920 --> 01:26:58,679
but the difference is uh knowledge

1894
01:26:58,679 --> 01:27:01,679
encryption has key Generations right

1895
01:27:01,679 --> 01:27:04,679
encryption

1896
01:27:16,860 --> 01:27:21,239
okay so on the uh there's a extractable

1897
01:27:21,239 --> 01:27:23,340
weakness encryption in prior knowledge

1898
01:27:23,340 --> 01:27:25,880
encryption there is there any

1899
01:27:25,880 --> 01:27:28,739
relationship between extractable witness

1900
01:27:28,739 --> 01:27:32,480
encryption and energy encryption

1901
01:27:32,480 --> 01:27:36,600
uh well uh extractable within the

1902
01:27:36,600 --> 01:27:37,980
encryption

1903
01:27:37,980 --> 01:27:40,020
uh

1904
01:27:40,020 --> 01:27:42,719
uh are very close to the non-encryption

1905
01:27:42,719 --> 01:27:44,659
except the

1906
01:27:44,659 --> 01:27:47,580
indistinguishability properties and in

1907
01:27:47,580 --> 01:27:50,159
some cases you can use extractable

1908
01:27:50,159 --> 01:27:53,659
weakness encryption replacement

1909
01:27:53,780 --> 01:27:56,900
and the

1910
01:27:56,900 --> 01:28:00,960
main idea of our paper is to is to

1911
01:28:00,960 --> 01:28:02,000
conduct

1912
01:28:02,000 --> 01:28:06,320
uh load render complexity protocols with

1913
01:28:06,320 --> 01:28:09,900
more standard assumptions such as TDS or

1914
01:28:09,900 --> 01:28:13,139
QR and I think the extractable which is

1915
01:28:13,139 --> 01:28:15,060
the encryption is hard to conduct from

1916
01:28:15,060 --> 01:28:16,560
these assumptions

1917
01:28:16,560 --> 01:28:19,199
thanks

1918
01:28:19,199 --> 01:28:23,120
are there any mission

1919
01:28:24,360 --> 01:28:25,739
no

1920
01:28:25,739 --> 01:28:29,839
okay let's thanks the speaker again

1921
01:28:33,320 --> 01:28:37,199
this is the end of this session and we

1922
01:28:37,199 --> 01:28:39,919
have lunch break

