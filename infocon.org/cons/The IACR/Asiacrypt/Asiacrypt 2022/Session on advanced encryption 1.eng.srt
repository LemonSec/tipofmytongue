1
00:00:00,000 --> 00:00:03,179
tests which they conducted at 10 30 on

2
00:00:03,179 --> 00:00:05,819
Wednesday every week so please do not be

3
00:00:05,819 --> 00:00:09,240
alarmed it's fine okay so we hand this

4
00:00:09,240 --> 00:00:12,420
to the session chair

5
00:00:12,420 --> 00:00:13,799
thank you

6
00:00:13,799 --> 00:00:16,619
okay so good morning and welcome back to

7
00:00:16,619 --> 00:00:19,199
the session on the advanced encryption

8
00:00:19,199 --> 00:00:21,840
and so the first talk in this session is

9
00:00:21,840 --> 00:00:24,840
about traceable receive free encryption

10
00:00:24,840 --> 00:00:30,019
by Angry deviled Olivia Pereira is

11
00:00:30,019 --> 00:00:33,500
a talk please

12
00:00:39,020 --> 00:00:42,200
thank you

13
00:00:42,660 --> 00:00:45,180
uh so yeah I'm originally from UC luvan

14
00:00:45,180 --> 00:00:47,280
and I'm going to talk about visible

15
00:00:47,280 --> 00:00:49,680
widget free encryption

16
00:00:49,680 --> 00:00:53,480
um it's a joint work with my supervisors

17
00:00:55,620 --> 00:00:57,899
so the main motivation and application

18
00:00:57,899 --> 00:01:00,500
is electron inverting and especially

19
00:01:00,500 --> 00:01:03,600
electronic building protocols that have

20
00:01:03,600 --> 00:01:07,200
a non-interactive ballot submission

21
00:01:07,200 --> 00:01:09,299
and that is we want electron exotic

22
00:01:09,299 --> 00:01:10,860
protocols in which for the ballot

23
00:01:10,860 --> 00:01:13,439
casting the voters come and only send

24
00:01:13,439 --> 00:01:16,380
one message to the voting server and so

25
00:01:16,380 --> 00:01:18,119
it's simple and easy they just send one

26
00:01:18,119 --> 00:01:21,799
message and the casting is done

27
00:01:22,259 --> 00:01:23,159
um

28
00:01:23,159 --> 00:01:26,580
so so when we Design Systems

29
00:01:26,580 --> 00:01:28,979
um we usually have a public building

30
00:01:28,979 --> 00:01:31,320
bolt on which uh people can post

31
00:01:31,320 --> 00:01:33,600
biblically on on this

32
00:01:33,600 --> 00:01:35,939
and this message they post are usually

33
00:01:35,939 --> 00:01:38,659
uh the encryption of the vote

34
00:01:38,659 --> 00:01:41,040
and uh to build the system we want some

35
00:01:41,040 --> 00:01:42,960
security properties and for electronic

36
00:01:42,960 --> 00:01:44,820
voting the two main properties are

37
00:01:44,820 --> 00:01:47,579
variability and about privacy

38
00:01:47,579 --> 00:01:50,759
in short vegetability means that a voter

39
00:01:50,759 --> 00:01:52,500
has some guarantee that the vote is

40
00:01:52,500 --> 00:01:54,960
currently recorded on the building board

41
00:01:54,960 --> 00:01:56,880
and that uh the result of the election

42
00:01:56,880 --> 00:01:59,040
of all the cyber attacks put on the

43
00:01:59,040 --> 00:02:01,560
building board is quickly computed

44
00:02:01,560 --> 00:02:05,040
while ballot privacy means that

45
00:02:05,040 --> 00:02:07,819
there is no leak about the information

46
00:02:07,819 --> 00:02:11,520
uh the vote of a voter except of what

47
00:02:11,520 --> 00:02:12,900
you can learn from the result of the

48
00:02:12,900 --> 00:02:14,280
election

49
00:02:14,280 --> 00:02:16,680
and so to achieve this uh to Securities

50
00:02:16,680 --> 00:02:19,080
we usually do some cryptographic tools

51
00:02:19,080 --> 00:02:21,900
for variability for example

52
00:02:21,900 --> 00:02:23,819
um we put on the building boards on zero

53
00:02:23,819 --> 00:02:25,200
knowledge proofs that everything is

54
00:02:25,200 --> 00:02:27,599
completed correctly and uh for developed

55
00:02:27,599 --> 00:02:30,599
privacy uh it is shown that if you have

56
00:02:30,599 --> 00:02:33,780
a nmcpa secure encryption scheme then

57
00:02:33,780 --> 00:02:36,300
it's possibly it's possible to get a

58
00:02:36,300 --> 00:02:39,540
ballot private elections

59
00:02:39,540 --> 00:02:42,120
but is that all actually there are other

60
00:02:42,120 --> 00:02:44,940
privacy issues uh if you use such a

61
00:02:44,940 --> 00:02:47,580
system uh the voters can prove to

62
00:02:47,580 --> 00:02:51,300
another party how they voted so if the

63
00:02:51,300 --> 00:02:54,840
voter is adversial also it can give to

64
00:02:54,840 --> 00:02:57,540
some adversary an opening of the

65
00:02:57,540 --> 00:02:58,500
encryption

66
00:02:58,500 --> 00:03:00,420
for example you can give the vote and

67
00:03:00,420 --> 00:03:03,120
the randomness uh of the encryption you

68
00:03:03,120 --> 00:03:04,379
put on the building board and the

69
00:03:04,379 --> 00:03:06,300
investor you can then check on the

70
00:03:06,300 --> 00:03:08,459
building board and verify how the voter

71
00:03:08,459 --> 00:03:09,500
voted

72
00:03:09,500 --> 00:03:13,500
so button policy is not enough and um we

73
00:03:13,500 --> 00:03:14,940
want also to build some protection

74
00:03:14,940 --> 00:03:18,379
against the attacks

75
00:03:18,599 --> 00:03:21,060
uh there are some ways uh some mechanism

76
00:03:21,060 --> 00:03:22,980
to protect this

77
00:03:22,980 --> 00:03:24,480
um the two

78
00:03:24,480 --> 00:03:26,819
possible ways is either to ensure that

79
00:03:26,819 --> 00:03:29,519
the voter cannot produce any opening of

80
00:03:29,519 --> 00:03:32,159
the vote in polynomial time well the

81
00:03:32,159 --> 00:03:34,620
other way on the contrary

82
00:03:34,620 --> 00:03:37,379
is to make it easy for the voter to

83
00:03:37,379 --> 00:03:40,440
provide an opening for any possible vote

84
00:03:40,440 --> 00:03:42,599
in this work we focus on an opening

85
00:03:42,599 --> 00:03:43,799
solution

86
00:03:43,799 --> 00:03:45,540
um because we want to build a

87
00:03:45,540 --> 00:03:48,540
non-interactive uh bullet testing and we

88
00:03:48,540 --> 00:03:50,580
do not want to rely on any pqi

89
00:03:50,580 --> 00:03:53,340
infrastructure before the election we

90
00:03:53,340 --> 00:03:55,379
want to keep things General and do not

91
00:03:55,379 --> 00:03:57,060
make such assumptions so we will focus

92
00:03:57,060 --> 00:03:59,400
on the opening solution

93
00:03:59,400 --> 00:04:03,440
um which does not require such things

94
00:04:03,480 --> 00:04:06,299
I know there's several ways again uh to

95
00:04:06,299 --> 00:04:09,480
do this opening solution and we focus on

96
00:04:09,480 --> 00:04:11,400
clear optimization of the psychotics

97
00:04:11,400 --> 00:04:14,280
solution uh so we assume there's another

98
00:04:14,280 --> 00:04:17,040
party the randomizer and the water can

99
00:04:17,040 --> 00:04:18,478
give a ciphertext with another

100
00:04:18,478 --> 00:04:21,120
additional party which will randomize

101
00:04:21,120 --> 00:04:23,040
the second text and put it on the

102
00:04:23,040 --> 00:04:24,000
building block

103
00:04:24,000 --> 00:04:26,160
and so now the randomness is refreshed

104
00:04:26,160 --> 00:04:28,440
and uh since the voter does not have any

105
00:04:28,440 --> 00:04:30,660
clue about what is the randomness of the

106
00:04:30,660 --> 00:04:33,540
anonymizer uh yes guarantee he does not

107
00:04:33,540 --> 00:04:35,520
have an opening of the encryption

108
00:04:35,520 --> 00:04:37,560
anymore

109
00:04:37,560 --> 00:04:40,560
but doing so we still need a verifiable

110
00:04:40,560 --> 00:04:43,500
election so if the atomizer put a new

111
00:04:43,500 --> 00:04:45,660
ciphertext with a new uh plain text a

112
00:04:45,660 --> 00:04:48,479
new vote on it uh the voter

113
00:04:48,479 --> 00:04:50,460
um we not have a guarantee that this

114
00:04:50,460 --> 00:04:52,680
vote is correctly counted

115
00:04:52,680 --> 00:04:54,240
and so to have this variability again

116
00:04:54,240 --> 00:04:56,220
there are some ways how you can make

117
00:04:56,220 --> 00:04:59,100
zero knowledge a sigma protocol uh to

118
00:04:59,100 --> 00:05:01,919
prove to the voter uh that the

119
00:05:01,919 --> 00:05:04,199
randomization is correctly done but this

120
00:05:04,199 --> 00:05:06,660
requires interaction or you can use a

121
00:05:06,660 --> 00:05:08,639
designated verifier

122
00:05:08,639 --> 00:05:09,780
um

123
00:05:09,780 --> 00:05:13,199
uh proof also but again it requires uh

124
00:05:13,199 --> 00:05:15,060
interaction or APK infrastructure in the

125
00:05:15,060 --> 00:05:15,960
beginning

126
00:05:15,960 --> 00:05:18,600
and so we will want to find a other

127
00:05:18,600 --> 00:05:20,340
solution that does not require these

128
00:05:20,340 --> 00:05:22,400
things

129
00:05:23,160 --> 00:05:26,759
so the existing solution back in the

130
00:05:26,759 --> 00:05:28,560
days so I think the first one using this

131
00:05:28,560 --> 00:05:31,080
part time of an amazing server is from

132
00:05:31,080 --> 00:05:34,259
Earth at all and it's based on this

133
00:05:34,259 --> 00:05:36,600
designated verify approved and more

134
00:05:36,600 --> 00:05:38,460
recently uh blessed and Al and

135
00:05:38,460 --> 00:05:39,660
especially the building yourself have

136
00:05:39,660 --> 00:05:41,900
voting systems use

137
00:05:41,900 --> 00:05:44,039
signatures and organized ciphertext

138
00:05:44,039 --> 00:05:47,820
which are a nice primitive that allows

139
00:05:47,820 --> 00:05:49,919
the voter to encrypt the ciphertext and

140
00:05:49,919 --> 00:05:52,340
using a signature key they received from

141
00:05:52,340 --> 00:05:56,940
the registration they can assign their

142
00:05:56,940 --> 00:05:59,280
separate text and send it to the amazing

143
00:05:59,280 --> 00:06:01,620
server and the signature has some

144
00:06:01,620 --> 00:06:04,380
updating property so when you randomize

145
00:06:04,380 --> 00:06:06,180
the cycle text you can also update the

146
00:06:06,180 --> 00:06:08,160
signature to randomize it

147
00:06:08,160 --> 00:06:11,039
and uh it's still a valid signature but

148
00:06:11,039 --> 00:06:12,720
on the other hand if the randomizing

149
00:06:12,720 --> 00:06:15,479
server wants to encrypt a new vote uh

150
00:06:15,479 --> 00:06:16,860
it's not possible because it does not

151
00:06:16,860 --> 00:06:19,199
have the the signature key

152
00:06:19,199 --> 00:06:22,199
and so this solution is fccs secure but

153
00:06:22,199 --> 00:06:24,840
actually we showed that we find out that

154
00:06:24,840 --> 00:06:26,699
it's not enough to grantify the printers

155
00:06:26,699 --> 00:06:29,580
so we need something stronger than fcca

156
00:06:29,580 --> 00:06:30,600
security

157
00:06:30,600 --> 00:06:33,539
and also uh about efficiency uh the

158
00:06:33,539 --> 00:06:36,600
construction is bit by bit encryption uh

159
00:06:36,600 --> 00:06:38,340
and uh yes we are looking for something

160
00:06:38,340 --> 00:06:40,620
more efficient

161
00:06:40,620 --> 00:06:43,319
and so in our solution we identified the

162
00:06:43,319 --> 00:06:44,580
exact security notion that we need for

163
00:06:44,580 --> 00:06:48,020
the premise a bit uh like nmcp security

164
00:06:48,020 --> 00:06:51,120
is enough for valid privacy we try to

165
00:06:51,120 --> 00:06:54,060
point out which exact security notion is

166
00:06:54,060 --> 00:06:56,280
required for synchronous

167
00:06:56,280 --> 00:06:59,340
and then uh we build

168
00:06:59,340 --> 00:07:01,500
um we construct uh for this new

169
00:07:01,500 --> 00:07:03,180
primitive

170
00:07:03,180 --> 00:07:05,819
um new constructions that support

171
00:07:05,819 --> 00:07:08,039
encryption of group elements that are

172
00:07:08,039 --> 00:07:09,240
more efficient that the bit by bit

173
00:07:09,240 --> 00:07:11,960
encryption

174
00:07:12,660 --> 00:07:14,520
but to do so

175
00:07:14,520 --> 00:07:18,000
um we introduce uh annual green Trace

176
00:07:18,000 --> 00:07:20,039
because we want to allow the voter uh

177
00:07:20,039 --> 00:07:22,139
formally to check on the building board

178
00:07:22,139 --> 00:07:25,380
uh where is the the cycle test and this

179
00:07:25,380 --> 00:07:26,819
Trace I'll go ahead

180
00:07:26,819 --> 00:07:30,300
um let's put it a safer text and outputs

181
00:07:30,300 --> 00:07:31,740
a tag

182
00:07:31,740 --> 00:07:34,199
and this Trace is environmental

183
00:07:34,199 --> 00:07:35,400
organization

184
00:07:35,400 --> 00:07:37,800
so when the randomizing server uh sends

185
00:07:37,800 --> 00:07:39,120
the randomization of the server text to

186
00:07:39,120 --> 00:07:41,400
the trace is preserved and so the voter

187
00:07:41,400 --> 00:07:43,020
can check on the building board if there

188
00:07:43,020 --> 00:07:44,280
is some cyber text with the initial

189
00:07:44,280 --> 00:07:47,099
Trace and if this is the case this is

190
00:07:47,099 --> 00:07:49,800
the second text of the water

191
00:07:49,800 --> 00:07:52,319
there's also a critical point here uh we

192
00:07:52,319 --> 00:07:54,960
need this stressor going to um so we

193
00:07:54,960 --> 00:07:58,259
need water to be able to encrypt any

194
00:07:58,259 --> 00:08:00,599
possible vote to to give some Trace um

195
00:08:00,599 --> 00:08:03,180
if the trace depends on the message

196
00:08:03,180 --> 00:08:05,639
uh then we have some issues because the

197
00:08:05,639 --> 00:08:08,880
trace would also be received uh for the

198
00:08:08,880 --> 00:08:12,720
the music printers attached the trade

199
00:08:12,720 --> 00:08:16,099
should not depend on the message

200
00:08:16,500 --> 00:08:19,139
and so for this Trace algorithms

201
00:08:19,139 --> 00:08:20,580
um we want to protect against the

202
00:08:20,580 --> 00:08:22,139
vegetability

203
00:08:22,139 --> 00:08:24,780
um attach and so

204
00:08:24,780 --> 00:08:27,360
hey we will introduced this uh kind of

205
00:08:27,360 --> 00:08:30,120
unfortability game uh in which uh the

206
00:08:30,120 --> 00:08:32,219
investor you can send some message to

207
00:08:32,219 --> 00:08:33,659
the to the changer and if we see the

208
00:08:33,659 --> 00:08:36,179
second text and then the adversary wins

209
00:08:36,179 --> 00:08:38,880
if we manage to to find a new Cipher

210
00:08:38,880 --> 00:08:41,219
text uh that has the same Trace

211
00:08:41,219 --> 00:08:44,880
with decrypts uh into a new uh vote

212
00:08:44,880 --> 00:08:47,399
and if this game uh is hard for the

213
00:08:47,399 --> 00:08:49,019
adversary uh then it's quite

214
00:08:49,019 --> 00:08:51,839
straightforward to show that uh the

215
00:08:51,839 --> 00:08:54,779
voter as good guarantees that when he

216
00:08:54,779 --> 00:08:58,560
sees uh his ballot on the building board

217
00:08:58,560 --> 00:09:01,500
with the trace then uh the vote is

218
00:09:01,500 --> 00:09:03,360
indeed uh the vote that it sends the

219
00:09:03,360 --> 00:09:05,100
adversary

220
00:09:05,100 --> 00:09:06,779
and you can see that we also send the

221
00:09:06,779 --> 00:09:09,300
secret key to the adversary

222
00:09:09,300 --> 00:09:12,120
um and this is also critical uh because

223
00:09:12,120 --> 00:09:14,339
even though in the real world uh the

224
00:09:14,339 --> 00:09:15,899
economy is the randomizing server does

225
00:09:15,899 --> 00:09:17,040
not have the secret key of the election

226
00:09:17,040 --> 00:09:19,500
it cannot decrypt the vote

227
00:09:19,500 --> 00:09:21,000
um we still want to have some protection

228
00:09:21,000 --> 00:09:24,180
uh if adversary and all the election

229
00:09:24,180 --> 00:09:26,700
officials are corrupted we still want

230
00:09:26,700 --> 00:09:28,620
the the ability to hold if everyone is

231
00:09:28,620 --> 00:09:31,980
corrupted and so we also put the secret

232
00:09:31,980 --> 00:09:34,500
key uh we also give the security secret

233
00:09:34,500 --> 00:09:36,899
key to the adversary uh to cover such

234
00:09:36,899 --> 00:09:39,360
cases

235
00:09:39,360 --> 00:09:42,420
and now that breathability is taken care

236
00:09:42,420 --> 00:09:46,019
of we also want the recent printers and

237
00:09:46,019 --> 00:09:49,620
um a bit like an mCP and then

238
00:09:49,620 --> 00:09:54,060
space security uh we introduce a new uh

239
00:09:54,060 --> 00:09:56,220
security game that is reminiscent of

240
00:09:56,220 --> 00:09:58,440
this CCA game

241
00:09:58,440 --> 00:10:01,740
um but usually in this CCA games

242
00:10:01,740 --> 00:10:04,320
um the anniversary can send messages to

243
00:10:04,320 --> 00:10:05,880
the Challenger and receive an encryption

244
00:10:05,880 --> 00:10:07,440
of these messages

245
00:10:07,440 --> 00:10:10,680
but in the recipient game actually what

246
00:10:10,680 --> 00:10:12,120
happens is the voter sends to the

247
00:10:12,120 --> 00:10:14,519
randomizing server is ciphertext and can

248
00:10:14,519 --> 00:10:16,019
see on the building board a

249
00:10:16,019 --> 00:10:18,540
randomization of this effort so this is

250
00:10:18,540 --> 00:10:20,820
a different blueprint and we cannot

251
00:10:20,820 --> 00:10:24,480
reduce this uh to this game to this um

252
00:10:24,480 --> 00:10:27,420
sending of plain text games

253
00:10:27,420 --> 00:10:30,480
and so instead and the the main

254
00:10:30,480 --> 00:10:34,620
uh core of this uh of this definition is

255
00:10:34,620 --> 00:10:37,680
that we send uh two ciphertext uh to the

256
00:10:37,680 --> 00:10:39,540
to the changer and we receive one

257
00:10:39,540 --> 00:10:41,700
organization of this second text

258
00:10:41,700 --> 00:10:43,740
so the game is at the moment easy uh

259
00:10:43,740 --> 00:10:45,300
because we have the choosing algorithm

260
00:10:45,300 --> 00:10:47,640
and so if the trades are different we

261
00:10:47,640 --> 00:10:49,680
can easily distinguish the ciphertext

262
00:10:49,680 --> 00:10:52,019
and so we put an event friction on the

263
00:10:52,019 --> 00:10:55,260
on the challenge and we make sure that

264
00:10:55,260 --> 00:10:57,540
the trades are equal otherwise it's too

265
00:10:57,540 --> 00:10:58,920
easy

266
00:10:58,920 --> 00:11:01,620
and also uh since the deceptic Summa

267
00:11:01,620 --> 00:11:02,760
label

268
00:11:02,760 --> 00:11:04,079
um if you're anonymize it it would be

269
00:11:04,079 --> 00:11:06,000
easy to win the game and so we ensure

270
00:11:06,000 --> 00:11:09,000
that the trace uh of the post Trend

271
00:11:09,000 --> 00:11:10,019
description

272
00:11:10,019 --> 00:11:12,660
are different that uh from The Challenge

273
00:11:12,660 --> 00:11:15,480
ciphertext

274
00:11:15,480 --> 00:11:19,380
so this is the the TCC security and uh

275
00:11:19,380 --> 00:11:21,060
using this game is actually quite easy

276
00:11:21,060 --> 00:11:24,140
to to show there is a print definition

277
00:11:24,140 --> 00:11:29,660
security if uh if this game is difficult

278
00:11:30,300 --> 00:11:32,160
and now I can Define uh this new

279
00:11:32,160 --> 00:11:33,600
primitive that is twistable with the

280
00:11:33,600 --> 00:11:36,720
pre-encryption or trench uh it's a

281
00:11:36,720 --> 00:11:39,839
normal usual encryption scheme with Gen

282
00:11:39,839 --> 00:11:43,019
Inc and deck we had rent and Trace which

283
00:11:43,019 --> 00:11:44,820
are the two algons I talked to you about

284
00:11:44,820 --> 00:11:47,700
also Elgin and LH which are a bit

285
00:11:47,700 --> 00:11:49,680
technical but this is to make sure that

286
00:11:49,680 --> 00:11:53,100
uh the voter have some way to encrypt

287
00:11:53,100 --> 00:11:55,740
any message to get a possible Trace so

288
00:11:55,740 --> 00:11:58,560
LK alone determines the trace so the

289
00:11:58,560 --> 00:12:01,019
trace is independent of the message and

290
00:12:01,019 --> 00:12:01,860
um

291
00:12:01,860 --> 00:12:04,260
using LK the link key you can just

292
00:12:04,260 --> 00:12:07,320
encrypt any message for one given Trace

293
00:12:07,320 --> 00:12:10,800
so if we have this primitive with PCC

294
00:12:10,800 --> 00:12:13,440
security testable security and also

295
00:12:13,440 --> 00:12:16,500
randomizability which ensures that the

296
00:12:16,500 --> 00:12:19,320
randomization of a ciphertext is is a

297
00:12:19,320 --> 00:12:23,040
indexable from a flash cycle text

298
00:12:23,040 --> 00:12:23,700
um

299
00:12:23,700 --> 00:12:25,800
then this is what we Define as a

300
00:12:25,800 --> 00:12:27,360
twistable logistic free encryption

301
00:12:27,360 --> 00:12:28,800
scheme

302
00:12:28,800 --> 00:12:30,959
so now that we've defined that we also

303
00:12:30,959 --> 00:12:33,180
want to construct it and so we gives a

304
00:12:33,180 --> 00:12:34,680
several constructions

305
00:12:34,680 --> 00:12:36,480
first uh we provide the general

306
00:12:36,480 --> 00:12:38,880
constructions using known tools of what

307
00:12:38,880 --> 00:12:42,540
we already know it use also a signatures

308
00:12:42,540 --> 00:12:45,000
on autonomous World ciphertext it uses a

309
00:12:45,000 --> 00:12:48,380
randomizable system called side pools

310
00:12:48,380 --> 00:12:50,519
linearly homomorphics structure

311
00:12:50,519 --> 00:12:52,139
preserving signatures

312
00:12:52,139 --> 00:12:54,240
but all the genetic constructions that

313
00:12:54,240 --> 00:12:56,579
we managed to achieve they give stronger

314
00:12:56,579 --> 00:12:59,459
security we do not manage to get exactly

315
00:12:59,459 --> 00:13:02,279
the tcca security

316
00:13:02,279 --> 00:13:04,980
um because we also need at some point in

317
00:13:04,980 --> 00:13:06,480
our constructions to extract the link

318
00:13:06,480 --> 00:13:09,060
key and so we need some additional

319
00:13:09,060 --> 00:13:11,040
properties using a

320
00:13:11,040 --> 00:13:13,079
the known tools

321
00:13:13,079 --> 00:13:15,360
and so we go forwards and we also built

322
00:13:15,360 --> 00:13:17,700
a direct construction

323
00:13:17,700 --> 00:13:19,680
um that do not need this additional

324
00:13:19,680 --> 00:13:21,720
property and this direct construction is

325
00:13:21,720 --> 00:13:24,120
being based and based on S6 Edge and

326
00:13:24,120 --> 00:13:26,820
user sgrs

327
00:13:26,820 --> 00:13:29,700
so I'll try to give um some intuition

328
00:13:29,700 --> 00:13:31,459
about this thread construction

329
00:13:31,459 --> 00:13:35,160
uh the first element of this uh is a CPA

330
00:13:35,160 --> 00:13:38,160
encryption a c0c1 and C2

331
00:13:38,160 --> 00:13:41,100
and uh now it's very malleable so we

332
00:13:41,100 --> 00:13:44,700
want to add some simulations on proof uh

333
00:13:44,700 --> 00:13:48,480
that this C1 and C2 are in uh the span

334
00:13:48,480 --> 00:13:49,860
of GH

335
00:13:49,860 --> 00:13:52,019
and we use techniques that are

336
00:13:52,019 --> 00:13:55,200
reminiscent of type-based encryption

337
00:13:55,200 --> 00:13:57,060
um and so we will use the tag as the

338
00:13:57,060 --> 00:14:00,420
trace which is the unmelible part of our

339
00:14:00,420 --> 00:14:02,579
ciphertext

340
00:14:02,579 --> 00:14:04,380
but uh there are some technical

341
00:14:04,380 --> 00:14:05,760
challenges we're going to choose

342
00:14:05,760 --> 00:14:09,560
selected encryption uh exactly because

343
00:14:09,560 --> 00:14:13,320
the tag is not chosen before everything

344
00:14:13,320 --> 00:14:16,139
that can be chosen uh at any time and

345
00:14:16,139 --> 00:14:19,019
especially during the the challenge

346
00:14:19,019 --> 00:14:22,260
and um yeah it makes the game more

347
00:14:22,260 --> 00:14:24,240
difficult the addiction more difficult

348
00:14:24,240 --> 00:14:25,500
and also the pretty challenge

349
00:14:25,500 --> 00:14:29,100
description decryption yes requests can

350
00:14:29,100 --> 00:14:31,920
use also the the tag the challenge tag

351
00:14:31,920 --> 00:14:33,240
uh

352
00:14:33,240 --> 00:14:36,180
and so um yes we managed to to solve

353
00:14:36,180 --> 00:14:38,639
that using again uh linearly

354
00:14:38,639 --> 00:14:39,380
um

355
00:14:39,380 --> 00:14:42,060
representing signatures to build the

356
00:14:42,060 --> 00:14:44,519
proof that this vectors C1 to the power

357
00:14:44,519 --> 00:14:47,220
two c equal to the portal C1 C2 is in

358
00:14:47,220 --> 00:14:48,540
this Pan

359
00:14:48,540 --> 00:14:49,620
um

360
00:14:49,620 --> 00:14:53,040
which is uh one step toward TCC security

361
00:14:53,040 --> 00:14:56,100
but we also want possibility and so to

362
00:14:56,100 --> 00:14:57,240
do so

363
00:14:57,240 --> 00:15:00,720
we have another lhsp signatures of this

364
00:15:00,720 --> 00:15:01,639
Matrix

365
00:15:01,639 --> 00:15:06,600
where the P are here and basically the

366
00:15:06,600 --> 00:15:09,360
the secret key is the link key of the

367
00:15:09,360 --> 00:15:12,360
signature scheme and the ash of the

368
00:15:12,360 --> 00:15:15,420
revision key can be seen as the trace

369
00:15:15,420 --> 00:15:18,000
and ask the two as the tag of the Attack

370
00:15:18,000 --> 00:15:19,920
Base encryption

371
00:15:19,920 --> 00:15:22,260
to give some nutrition uh the the first

372
00:15:22,260 --> 00:15:25,139
hole the signature of the first row uh

373
00:15:25,139 --> 00:15:27,060
this is a signature on a message

374
00:15:27,060 --> 00:15:30,060
but when you want to randomize the

375
00:15:30,060 --> 00:15:33,540
message the first signature is not valid

376
00:15:33,540 --> 00:15:35,339
anymore so you want to also update the

377
00:15:35,339 --> 00:15:37,440
the signature and so this is what the

378
00:15:37,440 --> 00:15:40,680
signal is for uh if you

379
00:15:40,680 --> 00:15:42,779
use the homomorphic properties of the

380
00:15:42,779 --> 00:15:46,680
signature you can obtain uh an updated

381
00:15:46,680 --> 00:15:49,500
signature for any optimization of the

382
00:15:49,500 --> 00:15:51,240
CPU encryption

383
00:15:51,240 --> 00:15:53,459
and the last hole is for technical

384
00:15:53,459 --> 00:15:54,600
reasons

385
00:15:54,600 --> 00:15:57,240
um this capital F and capital G are in

386
00:15:57,240 --> 00:16:00,000
the span of FG initially but in the

387
00:16:00,000 --> 00:16:03,839
reduction we embed a DDA challenge

388
00:16:03,839 --> 00:16:06,139
to um

389
00:16:06,139 --> 00:16:09,360
make it easy to to randomize the the CP

390
00:16:09,360 --> 00:16:11,579
encryption at some point to hide the

391
00:16:11,579 --> 00:16:13,079
message

392
00:16:13,079 --> 00:16:15,839
we also use Cosi proofs uh try some some

393
00:16:15,839 --> 00:16:17,519
elements in all of this

394
00:16:17,519 --> 00:16:19,500
and uh yes finally we have to make sure

395
00:16:19,500 --> 00:16:21,300
that everything there is randomizable

396
00:16:21,300 --> 00:16:23,880
except for the unvaluable part for the

397
00:16:23,880 --> 00:16:27,120
tracing part uh and in the end as you

398
00:16:27,120 --> 00:16:28,860
can see we do not use debate encryption

399
00:16:28,860 --> 00:16:30,959
we managed to only encrypt the group

400
00:16:30,959 --> 00:16:31,860
element

401
00:16:31,860 --> 00:16:34,079
um and we have ciphertext that are

402
00:16:34,079 --> 00:16:37,219
relatively small in size

403
00:16:38,459 --> 00:16:42,000
and once we have built uh this uh this

404
00:16:42,000 --> 00:16:43,860
strength uh it's not very easy to obtain

405
00:16:43,860 --> 00:16:46,500
with the voting system uh we have a

406
00:16:46,500 --> 00:16:48,600
generic transformation that take a

407
00:16:48,600 --> 00:16:50,579
trench and outputs a recent free protein

408
00:16:50,579 --> 00:16:51,660
system

409
00:16:51,660 --> 00:16:53,880
and the nice things is that all the

410
00:16:53,880 --> 00:16:55,560
usual properties forwarding system are

411
00:16:55,560 --> 00:16:57,839
preserved the repability still holds

412
00:16:57,839 --> 00:17:00,060
even if everyone is corrupted the

413
00:17:00,060 --> 00:17:02,160
regarding privacy even if the organizing

414
00:17:02,160 --> 00:17:03,540
server is corrupted

415
00:17:03,540 --> 00:17:06,179
it still cannot uh get any information

416
00:17:06,179 --> 00:17:08,520
about the vote of the user

417
00:17:08,520 --> 00:17:10,199
actually if the randomizing server is

418
00:17:10,199 --> 00:17:11,579
pointed the only thing that we lose is

419
00:17:11,579 --> 00:17:13,980
with the printers uh

420
00:17:13,980 --> 00:17:16,679
which we do not have either of

421
00:17:16,679 --> 00:17:18,359
accordingly randomizing server does not

422
00:17:18,359 --> 00:17:20,659
exist

423
00:17:21,000 --> 00:17:22,799
and so in conclusion uh we have three

424
00:17:22,799 --> 00:17:24,720
main

425
00:17:24,720 --> 00:17:27,119
um the first one is this new security

426
00:17:27,119 --> 00:17:30,600
this new primitive trench that capture

427
00:17:30,600 --> 00:17:33,120
the executive properties that we need to

428
00:17:33,120 --> 00:17:36,539
build receipt systems then we have

429
00:17:36,539 --> 00:17:38,160
construction and generate when a direct

430
00:17:38,160 --> 00:17:39,780
one under S6 Edge

431
00:17:39,780 --> 00:17:42,539
and finally a generic transformation uh

432
00:17:42,539 --> 00:17:46,500
that uh from a tank scheme uh outputs a

433
00:17:46,500 --> 00:17:49,620
requisite free voting system

434
00:17:49,620 --> 00:17:51,419
um thank you for your attention and I'm

435
00:17:51,419 --> 00:17:53,520
happy to answer any questions

436
00:17:53,520 --> 00:17:55,450
thank you for the presentation

437
00:17:55,450 --> 00:17:57,059
[Applause]

438
00:17:57,059 --> 00:18:01,220
so you have time for a question

439
00:18:03,059 --> 00:18:05,720
any question

440
00:18:10,799 --> 00:18:13,740
yes so you mentioned the existing work

441
00:18:13,740 --> 00:18:16,740
that we can use the signature on the

442
00:18:16,740 --> 00:18:20,220
randomized cycle protection yes and

443
00:18:20,220 --> 00:18:23,400
in these some disadvantage that we need

444
00:18:23,400 --> 00:18:27,000
to do interaction with the authority to

445
00:18:27,000 --> 00:18:29,940
to get the key or something like that uh

446
00:18:29,940 --> 00:18:33,360
not so we use it in our generation

447
00:18:33,360 --> 00:18:35,039
but we do not have to trust the

448
00:18:35,039 --> 00:18:37,380
authority so that's one nice thing about

449
00:18:37,380 --> 00:18:40,620
this new voting system is that

450
00:18:40,620 --> 00:18:42,900
could try to build in yourself uh we do

451
00:18:42,900 --> 00:18:44,160
not trust anyone

452
00:18:44,160 --> 00:18:46,799
so the user can generate the signing the

453
00:18:46,799 --> 00:18:49,500
verification key of the SRC primitive

454
00:18:49,500 --> 00:18:52,500
and uh use it for the trench so we do

455
00:18:52,500 --> 00:18:54,299
not trust anyone for the diffability or

456
00:18:54,299 --> 00:18:57,860
anything okay okay

457
00:18:58,400 --> 00:19:01,919
we have to trust this year has yes

458
00:19:01,919 --> 00:19:05,700
I guess there is some question online

459
00:19:05,700 --> 00:19:08,480
yes

460
00:19:15,150 --> 00:19:18,199
[Music]

461
00:19:19,140 --> 00:19:23,059
I cannot see the question online

462
00:19:24,720 --> 00:19:27,440
okay yeah

463
00:19:31,500 --> 00:19:35,700
okay so one question from Houston if not

464
00:19:35,700 --> 00:19:36,660
give

465
00:19:36,660 --> 00:19:42,000
original coins is not disapproved how he

466
00:19:42,000 --> 00:19:43,320
voted

467
00:19:43,320 --> 00:19:46,080
as the two dark would match

468
00:19:46,080 --> 00:19:48,960
I do not understand the question

469
00:19:48,960 --> 00:19:51,020
um

470
00:19:52,100 --> 00:19:55,140
sorry I'm not sure you can hear me but I

471
00:19:55,140 --> 00:19:57,179
probably misunderstood your primitive

472
00:19:57,179 --> 00:19:59,340
um but even though

473
00:19:59,340 --> 00:20:01,980
um you real minimize the ciphertext you

474
00:20:01,980 --> 00:20:04,500
don't have coins for the final Cipher

475
00:20:04,500 --> 00:20:07,620
text if I want to sell my vote can't I

476
00:20:07,620 --> 00:20:10,200
give my original coins and then because

477
00:20:10,200 --> 00:20:12,240
attacks are going to match everybody

478
00:20:12,240 --> 00:20:15,360
knows you know how I voted

479
00:20:15,360 --> 00:20:18,179
yes so you can give that uh but there is

480
00:20:18,179 --> 00:20:19,740
no proof that you do not like you could

481
00:20:19,740 --> 00:20:22,080
give any Cipher text with any coins

482
00:20:22,080 --> 00:20:24,539
and for the attacker there is a free

483
00:20:24,539 --> 00:20:27,480
attacker he cannot check that uh this

484
00:20:27,480 --> 00:20:29,160
Architects is indeed what you sent to

485
00:20:29,160 --> 00:20:31,880
the organizing server

486
00:20:31,980 --> 00:20:34,860
got it even though it has my signature

487
00:20:34,860 --> 00:20:37,740
on uh on the tag or something like that

488
00:20:37,740 --> 00:20:39,960
yeah yes so with

489
00:20:39,960 --> 00:20:42,660
the link key for example you can uh

490
00:20:42,660 --> 00:20:45,360
create a ciphertext for any message that

491
00:20:45,360 --> 00:20:46,799
has the same tag

492
00:20:46,799 --> 00:20:48,840
and so you could cheat and say okay this

493
00:20:48,840 --> 00:20:50,580
is a new a new cycle text for this vote

494
00:20:50,580 --> 00:20:53,880
well you send another ciphertext to the

495
00:20:53,880 --> 00:20:55,640
organizing server

496
00:20:55,640 --> 00:20:58,020
tag is not Collision resistant you can

497
00:20:58,020 --> 00:21:00,360
easily find intelligence for that yes

498
00:21:00,360 --> 00:21:02,820
yes and it's critical you have the you

499
00:21:02,820 --> 00:21:04,140
need this property otherwise uh

500
00:21:04,140 --> 00:21:06,179
reciprocal

501
00:21:06,179 --> 00:21:07,500
okay thank you

502
00:21:07,500 --> 00:21:11,179
yes so yeah

503
00:21:11,580 --> 00:21:14,418
another question

504
00:21:14,520 --> 00:21:17,880
so if not let's thank the speaker again

505
00:21:17,880 --> 00:21:20,539
thank you

506
00:21:27,960 --> 00:21:32,299
the second talkie will be online

507
00:21:40,740 --> 00:21:43,140
hi this is shikar can you hear me

508
00:21:43,140 --> 00:21:45,539
okay uh

509
00:21:45,539 --> 00:21:48,419
we can hear you oh great great okay so

510
00:21:48,419 --> 00:21:51,299
uh so the second talk in this session is

511
00:21:51,299 --> 00:21:54,659
about efficiency of symmetric encryption

512
00:21:54,659 --> 00:21:56,580
for Joy query

513
00:21:56,580 --> 00:21:59,720
uh by

514
00:22:00,799 --> 00:22:04,640
Judah because

515
00:22:04,640 --> 00:22:08,460
we give the talk so please

516
00:22:08,460 --> 00:22:10,620
yeah thank you very much for the

517
00:22:10,620 --> 00:22:12,179
introduction and hello and welcome

518
00:22:12,179 --> 00:22:14,400
everyone to this online presentation on

519
00:22:14,400 --> 00:22:15,780
efficient searchable symmetric

520
00:22:15,780 --> 00:22:17,880
encryption for join queries this is

521
00:22:17,880 --> 00:22:20,039
Joint work with challenge

522
00:22:20,039 --> 00:22:22,500
so the setting for this talk is that

523
00:22:22,500 --> 00:22:25,080
with the Advent of cloud computing uh

524
00:22:25,080 --> 00:22:27,360
organizations and clients can Outsource

525
00:22:27,360 --> 00:22:29,580
the storage and processing of extremely

526
00:22:29,580 --> 00:22:31,980
large databases to third-party cloud

527
00:22:31,980 --> 00:22:33,419
service providers

528
00:22:33,419 --> 00:22:35,520
and at a later point of time any

529
00:22:35,520 --> 00:22:37,799
organization could issue a query request

530
00:22:37,799 --> 00:22:39,840
to this data and obtain the

531
00:22:39,840 --> 00:22:41,340
corresponding result

532
00:22:41,340 --> 00:22:43,380
this would of course be very simple and

533
00:22:43,380 --> 00:22:45,480
efficient if the client trusted the

534
00:22:45,480 --> 00:22:48,360
third service provider to respect the

535
00:22:48,360 --> 00:22:50,580
privacy of their data but this is not

536
00:22:50,580 --> 00:22:52,980
always the case in today's world and the

537
00:22:52,980 --> 00:22:54,600
client might not trust the cloud service

538
00:22:54,600 --> 00:22:57,179
provider to respect the privacy of their

539
00:22:57,179 --> 00:22:59,940
potentially sensitive databases

540
00:22:59,940 --> 00:23:02,280
this leads us to the realm of what we

541
00:23:02,280 --> 00:23:04,320
call as Computing on encrypted data

542
00:23:04,320 --> 00:23:06,179
where the client can use a

543
00:23:06,179 --> 00:23:08,280
cryptographically secure scheme to

544
00:23:08,280 --> 00:23:10,559
encrypt the database before Outsourcing

545
00:23:10,559 --> 00:23:13,020
it to the cloud service provider but

546
00:23:13,020 --> 00:23:15,000
this then makes it challenging to issue

547
00:23:15,000 --> 00:23:16,860
query requests and obtain the

548
00:23:16,860 --> 00:23:19,320
corresponding results in particular the

549
00:23:19,320 --> 00:23:21,000
client might not only want to protect

550
00:23:21,000 --> 00:23:23,580
the privacy of their data but they might

551
00:23:23,580 --> 00:23:25,860
also want to hide the kinds of queries

552
00:23:25,860 --> 00:23:27,539
that they are issuing on the data

553
00:23:27,539 --> 00:23:29,039
because these queries might themselves

554
00:23:29,039 --> 00:23:31,919
be sensitive so the aim is to basically

555
00:23:31,919 --> 00:23:35,640
enable directly Computing queries on top

556
00:23:35,640 --> 00:23:37,559
of the encrypted database without

557
00:23:37,559 --> 00:23:39,900
revealing to the server either the data

558
00:23:39,900 --> 00:23:41,940
or the queries to the maximum extent

559
00:23:41,940 --> 00:23:43,799
possible

560
00:23:43,799 --> 00:23:46,380
now an ideal solution for computing an

561
00:23:46,380 --> 00:23:48,600
encrypted data would be one that would

562
00:23:48,600 --> 00:23:51,360
provide efficiency close to plain text

563
00:23:51,360 --> 00:23:53,640
searches for example while also leaking

564
00:23:53,640 --> 00:23:55,980
very little information to the server

565
00:23:55,980 --> 00:23:58,140
unfortunately the existing Solutions

566
00:23:58,140 --> 00:24:00,780
today lie at two opposite ends of the

567
00:24:00,780 --> 00:24:02,640
spectrum and don't quite achieve this

568
00:24:02,640 --> 00:24:04,860
ideal guarantee for example on the

569
00:24:04,860 --> 00:24:06,659
bottom left you have solutions that are

570
00:24:06,659 --> 00:24:08,340
cryptographically elegant and provide

571
00:24:08,340 --> 00:24:10,620
strong security guarantees but are

572
00:24:10,620 --> 00:24:13,140
unfortunately quite inefficient at least

573
00:24:13,140 --> 00:24:16,020
today and do not necessarily scale to

574
00:24:16,020 --> 00:24:18,600
extremely large databases in practice

575
00:24:18,600 --> 00:24:20,640
and on the upper right hand side you

576
00:24:20,640 --> 00:24:23,280
have schemes that are sort of motivated

577
00:24:23,280 --> 00:24:25,320
by database techniques and they are

578
00:24:25,320 --> 00:24:27,659
quite efficient and allow processing a

579
00:24:27,659 --> 00:24:29,340
rich set of queries on encrypted

580
00:24:29,340 --> 00:24:31,020
databases and they're also quite

581
00:24:31,020 --> 00:24:33,539
scalable but sometimes they tend to leak

582
00:24:33,539 --> 00:24:35,340
quite a bit of information about the

583
00:24:35,340 --> 00:24:37,200
database and have been subjected to

584
00:24:37,200 --> 00:24:39,419
certain leakage abuse attacks which can

585
00:24:39,419 --> 00:24:41,100
be used to break the query and in

586
00:24:41,100 --> 00:24:44,700
certain cases data privacy of these keys

587
00:24:44,700 --> 00:24:46,740
in this talk I'll be talking about a

588
00:24:46,740 --> 00:24:48,240
class of encryption schemes called

589
00:24:48,240 --> 00:24:50,460
searchable symmetric encryption or SSE

590
00:24:50,460 --> 00:24:52,919
in short that lies somewhere in the

591
00:24:52,919 --> 00:24:55,020
middle of the Spectrum in the sense that

592
00:24:55,020 --> 00:24:57,000
SSC provides some kind of trade-off

593
00:24:57,000 --> 00:24:59,760
between security and efficiency it leaks

594
00:24:59,760 --> 00:25:01,740
some information to the attacker and is

595
00:25:01,740 --> 00:25:04,020
hence not as secure as the schemes on

596
00:25:04,020 --> 00:25:06,000
the bottom left but at the same time

597
00:25:06,000 --> 00:25:08,520
this leakage is so not so much that it

598
00:25:08,520 --> 00:25:10,620
can be used to break the data or

599
00:25:10,620 --> 00:25:13,080
querying privacy of the schemes right so

600
00:25:13,080 --> 00:25:16,980
that's the aim of SSC and SSC uh you

601
00:25:16,980 --> 00:25:18,360
know is not alone in this spectrum

602
00:25:18,360 --> 00:25:20,700
there's also Solutions based on trusted

603
00:25:20,700 --> 00:25:22,080
Hardware or trusted execution

604
00:25:22,080 --> 00:25:25,020
environments for example Intel scx which

605
00:25:25,020 --> 00:25:28,440
also allow uh you know querying the data

606
00:25:28,440 --> 00:25:30,240
while by bringing it into a secure

607
00:25:30,240 --> 00:25:32,400
Enclave but in the case of these kinds

608
00:25:32,400 --> 00:25:34,260
of solutions we actually trust the

609
00:25:34,260 --> 00:25:36,600
hardware to serve as a black box which

610
00:25:36,600 --> 00:25:38,940
the adversary cannot peep into and this

611
00:25:38,940 --> 00:25:40,559
is sometimes not the case because of the

612
00:25:40,559 --> 00:25:42,419
presence of side channels and other

613
00:25:42,419 --> 00:25:44,400
mechanisms by which the adversary can

614
00:25:44,400 --> 00:25:46,919
get get some access to the data on the

615
00:25:46,919 --> 00:25:49,080
other hand in SSC even though we can

616
00:25:49,080 --> 00:25:51,779
probably support a slightly less Rich

617
00:25:51,779 --> 00:25:54,120
set of queries we rely purely on

618
00:25:54,120 --> 00:25:56,940
cryptographic security guarantees and do

619
00:25:56,940 --> 00:25:59,460
not trust the heart

620
00:25:59,460 --> 00:26:01,799
so here's a very brief one-slide summary

621
00:26:01,799 --> 00:26:03,900
of SSC I'm not going to go into any

622
00:26:03,900 --> 00:26:05,520
formal definitions for which I would

623
00:26:05,520 --> 00:26:07,080
refer you to the paper and also to the

624
00:26:07,080 --> 00:26:10,260
rich body of work on SSC so at a very

625
00:26:10,260 --> 00:26:12,960
high level we have a client which is the

626
00:26:12,960 --> 00:26:15,480
owner of the data and for Simplicity in

627
00:26:15,480 --> 00:26:17,279
this presentation I'll assume a single

628
00:26:17,279 --> 00:26:19,380
reader single writer setting but the

629
00:26:19,380 --> 00:26:21,179
client is the only entity which can

630
00:26:21,179 --> 00:26:23,340
actually issue queries on this data of

631
00:26:23,340 --> 00:26:25,380
course SSC can be generalized to other

632
00:26:25,380 --> 00:26:27,059
settings such as the single writer

633
00:26:27,059 --> 00:26:28,980
multi-reader setting where there's a

634
00:26:28,980 --> 00:26:31,260
single data owner but many other clients

635
00:26:31,260 --> 00:26:33,360
are allowed to issue queries but I will

636
00:26:33,360 --> 00:26:34,860
not go into that setting for this stock

637
00:26:34,860 --> 00:26:37,200
for Simplicity so the client typically

638
00:26:37,200 --> 00:26:39,600
holds a cryptographic key which it uses

639
00:26:39,600 --> 00:26:41,520
to encrypt the database and put it on

640
00:26:41,520 --> 00:26:43,620
the server and at a later point of time

641
00:26:43,620 --> 00:26:46,140
it uses the same key to issue queries

642
00:26:46,140 --> 00:26:47,940
which could either be search queries on

643
00:26:47,940 --> 00:26:50,460
the database or update queries to update

644
00:26:50,460 --> 00:26:53,220
the data and we typically assume for SSC

645
00:26:53,220 --> 00:26:56,039
again for Simplicity that the server is

646
00:26:56,039 --> 00:26:58,740
honest but curious or semi honest in the

647
00:26:58,740 --> 00:27:00,840
sense that it does not deviate from the

648
00:27:00,840 --> 00:27:02,820
protocol but tries to learn some

649
00:27:02,820 --> 00:27:04,679
information about the client's data and

650
00:27:04,679 --> 00:27:06,059
queries

651
00:27:06,059 --> 00:27:08,700
so with this setting I'll now go ahead

652
00:27:08,700 --> 00:27:11,760
and present our main contribution in

653
00:27:11,760 --> 00:27:14,340
this paper we present join cross tags or

654
00:27:14,340 --> 00:27:16,860
jxt in short which is a practically

655
00:27:16,860 --> 00:27:19,380
efficient SSC scheme for computing

656
00:27:19,380 --> 00:27:22,200
queries over equivalents of pairs of

657
00:27:22,200 --> 00:27:24,419
encrypted tables in encrypted relational

658
00:27:24,419 --> 00:27:25,799
databases

659
00:27:25,799 --> 00:27:28,080
so this is our main contribution and

660
00:27:28,080 --> 00:27:29,880
here is an outline for the rest of the

661
00:27:29,880 --> 00:27:32,220
talk so I'll first provide a background

662
00:27:32,220 --> 00:27:34,440
on what we mean by equi joints of tables

663
00:27:34,440 --> 00:27:36,659
in relational databases I will then

664
00:27:36,659 --> 00:27:38,640
provide a brief overview of our main

665
00:27:38,640 --> 00:27:41,279
contribution which is jxt I will then

666
00:27:41,279 --> 00:27:42,900
provide a brief overview of our

667
00:27:42,900 --> 00:27:43,980
techniques

668
00:27:43,980 --> 00:27:45,600
and finally I'll end with some open

669
00:27:45,600 --> 00:27:48,020
questions

670
00:27:48,299 --> 00:27:50,880
so here's an example of equi join

671
00:27:50,880 --> 00:27:53,640
queries over tables let's suppose that

672
00:27:53,640 --> 00:27:55,320
this is this is a toy example so I'll

673
00:27:55,320 --> 00:27:57,240
just present two very simple tables here

674
00:27:57,240 --> 00:27:59,340
let's say we have a transactions table

675
00:27:59,340 --> 00:28:01,679
and a merchant stable where each table

676
00:28:01,679 --> 00:28:04,919
has three columns or attributes and five

677
00:28:04,919 --> 00:28:07,200
rows or five records each

678
00:28:07,200 --> 00:28:09,600
and these two tables have a single

679
00:28:09,600 --> 00:28:12,000
column in common which is called a join

680
00:28:12,000 --> 00:28:13,620
attribute so in this case the join

681
00:28:13,620 --> 00:28:16,320
attribute is the transaction ID now what

682
00:28:16,320 --> 00:28:18,059
kinds of queries might we want to issue

683
00:28:18,059 --> 00:28:21,120
on joints of tables here's an example so

684
00:28:21,120 --> 00:28:23,340
suppose we say that select the pair of

685
00:28:23,340 --> 00:28:26,520
records from table 1 and table two

686
00:28:26,520 --> 00:28:28,919
so which are joined on the join

687
00:28:28,919 --> 00:28:31,440
attribute transaction ID so at the date

688
00:28:31,440 --> 00:28:34,620
is January 2022 and the merchant name is

689
00:28:34,620 --> 00:28:37,020
Apple right so this is an example of a

690
00:28:37,020 --> 00:28:39,480
query that cannot be answered by only

691
00:28:39,480 --> 00:28:41,700
searching within a single table and we

692
00:28:41,700 --> 00:28:42,900
would actually need to compute

693
00:28:42,900 --> 00:28:45,179
explicitly the join of two tables in

694
00:28:45,179 --> 00:28:46,679
order to be able to answer this query

695
00:28:46,679 --> 00:28:49,799
and so here in this case the matching uh

696
00:28:49,799 --> 00:28:52,380
you know pair of Records would be T5 and

697
00:28:52,380 --> 00:28:55,440
M1 note that in each table we have other

698
00:28:55,440 --> 00:28:57,179
records which match the individual

699
00:28:57,179 --> 00:28:59,520
queries for example T4 also has the date

700
00:28:59,520 --> 00:29:03,299
January 2022 and as you can see here

701
00:29:03,299 --> 00:29:05,760
that M4 also has Merchant name equals

702
00:29:05,760 --> 00:29:07,559
Apple but these pairs won't be

703
00:29:07,559 --> 00:29:09,240
considered as a matching record because

704
00:29:09,240 --> 00:29:12,539
the transaction IDs don't match

705
00:29:12,539 --> 00:29:14,820
now we'll provide a brief overview of

706
00:29:14,820 --> 00:29:17,220
our proposal which is join crosstags the

707
00:29:17,220 --> 00:29:19,440
main feature of joint crosstags is that

708
00:29:19,440 --> 00:29:22,140
it can handle queries over equivalents

709
00:29:22,140 --> 00:29:24,419
of tables without pre-processing any

710
00:29:24,419 --> 00:29:26,760
kind of joins Etc that is when you are

711
00:29:26,760 --> 00:29:28,740
generating the encrypted database as a

712
00:29:28,740 --> 00:29:30,779
client you don't have to prepare the

713
00:29:30,779 --> 00:29:33,059
joints of the tables explicitly it is

714
00:29:33,059 --> 00:29:35,279
sufficient that each table when being

715
00:29:35,279 --> 00:29:37,080
encrypted has a designated join

716
00:29:37,080 --> 00:29:39,299
attribute and any two tables which have

717
00:29:39,299 --> 00:29:41,520
a common designated join attribute can

718
00:29:41,520 --> 00:29:44,279
be joined dynamically and the query can

719
00:29:44,279 --> 00:29:46,919
be sort of executed over the encrypted

720
00:29:46,919 --> 00:29:48,899
versions of these tables

721
00:29:48,899 --> 00:29:51,720
the storage overhead for jxt is default

722
00:29:51,720 --> 00:29:54,179
if a particular table has the designated

723
00:29:54,179 --> 00:29:56,580
join attributes and as I will sort of

724
00:29:56,580 --> 00:29:59,100
argue a bit later that typically this T

725
00:29:59,100 --> 00:30:01,380
is expected to be small in practice for

726
00:30:01,380 --> 00:30:03,179
real world tables in real world

727
00:30:03,179 --> 00:30:06,200
relational databases

728
00:30:10,799 --> 00:30:12,840
which means in practice you can

729
00:30:12,840 --> 00:30:15,120
you can entire scheme just using you

730
00:30:15,120 --> 00:30:16,980
know a symmetric key Cipher such as AES

731
00:30:16,980 --> 00:30:21,240
in an appropriate mode and a jxt also

732
00:30:21,240 --> 00:30:23,100
happens to be fully compatible with the

733
00:30:23,100 --> 00:30:25,740
large body of SSC that supports other

734
00:30:25,740 --> 00:30:27,960
kinds of queries such as Boolean queries

735
00:30:27,960 --> 00:30:30,539
within tables this means that jxt can be

736
00:30:30,539 --> 00:30:32,580
combined with these kinds of schemes to

737
00:30:32,580 --> 00:30:34,980
support Rich classes of SQL queries over

738
00:30:34,980 --> 00:30:38,340
real-world relational databases

739
00:30:38,340 --> 00:30:40,860
here's a comparison of jxt with the

740
00:30:40,860 --> 00:30:44,220
prior art on SSC schemes for joints and

741
00:30:44,220 --> 00:30:46,320
really it has kind of you know two there

742
00:30:46,320 --> 00:30:47,820
are two previous schemes which were also

743
00:30:47,820 --> 00:30:49,380
capable of supporting joints over

744
00:30:49,380 --> 00:30:52,200
encrypted relational databases SPX due

745
00:30:52,200 --> 00:30:54,720
to Karma and marthas from Asia tip 2018

746
00:30:54,720 --> 00:30:56,820
and the more recent proposal from cash

747
00:30:56,820 --> 00:31:00,600
at all from acns 2021 and it had so

748
00:31:00,600 --> 00:31:02,880
happens that jxt is the only one among

749
00:31:02,880 --> 00:31:04,860
these which supports join queries

750
00:31:04,860 --> 00:31:07,260
without pre-processing of joins Etc

751
00:31:07,260 --> 00:31:09,600
right and one of the consequences of

752
00:31:09,600 --> 00:31:10,860
this which I will expand upon

753
00:31:10,860 --> 00:31:13,200
subsequently is that jxt allows

754
00:31:13,200 --> 00:31:15,720
extremely flexible table updates on the

755
00:31:15,720 --> 00:31:17,460
Fly

756
00:31:17,460 --> 00:31:19,679
so now I'll provide a brief overview of

757
00:31:19,679 --> 00:31:21,899
the features of jxt and as I already

758
00:31:21,899 --> 00:31:23,580
mentioned it's one of the most

759
00:31:23,580 --> 00:31:25,919
attractive features of jxt is that when

760
00:31:25,919 --> 00:31:27,720
processing the transactions table and

761
00:31:27,720 --> 00:31:30,059
the merchants table at setup you do not

762
00:31:30,059 --> 00:31:32,039
need to actually explicitly pre-process

763
00:31:32,039 --> 00:31:34,320
the equi join of these two tables you

764
00:31:34,320 --> 00:31:36,179
can process them individually in fact

765
00:31:36,179 --> 00:31:37,980
these tables can be set up and created

766
00:31:37,980 --> 00:31:39,779
independently they don't even need to

767
00:31:39,779 --> 00:31:42,179
exist at the same point of time it is

768
00:31:42,179 --> 00:31:44,100
only needed that when creating these

769
00:31:44,100 --> 00:31:46,440
tables we designate that transaction ID

770
00:31:46,440 --> 00:31:48,419
is a join attribute over which the

771
00:31:48,419 --> 00:31:50,159
transactions table can be joined with

772
00:31:50,159 --> 00:31:51,659
any other table that also has

773
00:31:51,659 --> 00:31:53,880
transaction ID as an attribute then the

774
00:31:53,880 --> 00:31:56,039
same for the margin state

775
00:31:56,039 --> 00:31:58,559
now what does this mean it means that in

776
00:31:58,559 --> 00:32:01,080
practice typically what we have is a

777
00:32:01,080 --> 00:32:03,000
small number of candidate attributes in

778
00:32:03,000 --> 00:32:05,039
a table with which with respect to which

779
00:32:05,039 --> 00:32:07,200
it is typically joined for example a

780
00:32:07,200 --> 00:32:09,659
join attribute is typically a primary or

781
00:32:09,659 --> 00:32:11,820
a secondary key which in relational

782
00:32:11,820 --> 00:32:14,580
database parlance means that you have a

783
00:32:14,580 --> 00:32:17,159
unique value for each record right yeah

784
00:32:17,159 --> 00:32:19,440
you know this is an attribute which does

785
00:32:19,440 --> 00:32:21,840
not repeat its values across records or

786
00:32:21,840 --> 00:32:23,700
it's a very very high entropy attribute

787
00:32:23,700 --> 00:32:26,220
in the sense that it has almost unique

788
00:32:26,220 --> 00:32:28,320
values for all records and typically

789
00:32:28,320 --> 00:32:31,939
such attributes are small in number

790
00:32:32,039 --> 00:32:34,260
now what are the advantages of avoiding

791
00:32:34,260 --> 00:32:35,820
pre-processing objects one of the

792
00:32:35,820 --> 00:32:38,039
biggest advantages is that you avoid

793
00:32:38,039 --> 00:32:39,720
potential storage blow ups due to

794
00:32:39,720 --> 00:32:41,640
explicit joint computation for example

795
00:32:41,640 --> 00:32:44,460
suppose that you have table T1 which is

796
00:32:44,460 --> 00:32:46,620
tall and skinny which means that it has

797
00:32:46,620 --> 00:32:49,020
many records and few attributes and you

798
00:32:49,020 --> 00:32:51,840
have table T2 which is short and white

799
00:32:51,840 --> 00:32:53,760
which means there are few records but

800
00:32:53,760 --> 00:32:55,320
many many attributes

801
00:32:55,320 --> 00:32:57,360
then they are equivalent over a common

802
00:32:57,360 --> 00:32:59,640
attribute is potentially tall and wide

803
00:32:59,640 --> 00:33:02,039
and so the storage required for

804
00:33:02,039 --> 00:33:04,679
explicitly storing this equation of

805
00:33:04,679 --> 00:33:06,899
these two tables is significantly larger

806
00:33:06,899 --> 00:33:08,640
than the sum of the storage required for

807
00:33:08,640 --> 00:33:10,980
each of the individual tables now in jxt

808
00:33:10,980 --> 00:33:13,320
you would basically have just a small

809
00:33:13,320 --> 00:33:15,419
storage overhead part table but you

810
00:33:15,419 --> 00:33:17,100
would not have the storage overhead of

811
00:33:17,100 --> 00:33:21,379
explicitly storing this equi jointly

812
00:33:21,419 --> 00:33:23,580
um and the other Advantage is that

813
00:33:23,580 --> 00:33:25,620
suppose that at some point of time you

814
00:33:25,620 --> 00:33:27,720
need to reset up a table or you need to

815
00:33:27,720 --> 00:33:29,820
update a particular table or maybe you

816
00:33:29,820 --> 00:33:31,559
lost a table and you need to recover it

817
00:33:31,559 --> 00:33:33,840
all of this can be done independently

818
00:33:33,840 --> 00:33:35,880
now in the prior schemes where you need

819
00:33:35,880 --> 00:33:37,860
to explicitly compute joints you would

820
00:33:37,860 --> 00:33:39,899
actually have to recompute the join of a

821
00:33:39,899 --> 00:33:41,519
table with every other table in the

822
00:33:41,519 --> 00:33:43,080
database with which it can be joined

823
00:33:43,080 --> 00:33:45,360
whereas in jxt you don't need to do this

824
00:33:45,360 --> 00:33:47,039
recomputation and you can reset up

825
00:33:47,039 --> 00:33:49,679
tables independently and finally when

826
00:33:49,679 --> 00:33:51,840
you join pairs of tables in the last

827
00:33:51,840 --> 00:33:53,340
case you could have a quadratic storage

828
00:33:53,340 --> 00:33:55,799
blow up in the number of tables which

829
00:33:55,799 --> 00:33:58,559
also jxt avoids

830
00:33:58,559 --> 00:34:00,960
and finally here's a very brief one

831
00:34:00,960 --> 00:34:03,419
slide summary of the storage and search

832
00:34:03,419 --> 00:34:05,580
overheads of jxt so as I already

833
00:34:05,580 --> 00:34:07,559
mentioned that suppose that a table has

834
00:34:07,559 --> 00:34:10,199
a total of n attributes and let's say t

835
00:34:10,199 --> 00:34:11,580
of these are designated as join

836
00:34:11,580 --> 00:34:12,780
attributes

837
00:34:12,780 --> 00:34:15,239
and I already argued earlier that t

838
00:34:15,239 --> 00:34:16,739
would typically be small in practice

839
00:34:16,739 --> 00:34:19,560
then the storage overhead of jxt is that

840
00:34:19,560 --> 00:34:22,260
you have an order T blow up and in terms

841
00:34:22,260 --> 00:34:24,000
of the search overheads as you can see

842
00:34:24,000 --> 00:34:26,280
the communication cost and the

843
00:34:26,280 --> 00:34:28,379
computation cost at the client are

844
00:34:28,379 --> 00:34:30,359
actually linear in the individual number

845
00:34:30,359 --> 00:34:33,119
of records from each table whereas we

846
00:34:33,119 --> 00:34:35,639
Outsource the expensive and kind of

847
00:34:35,639 --> 00:34:36,899
unavoidable

848
00:34:36,899 --> 00:34:39,719
uh multiplicative overhead of the search

849
00:34:39,719 --> 00:34:41,879
to the server and this is really sort of

850
00:34:41,879 --> 00:34:43,560
the spirit of outsourced computation

851
00:34:43,560 --> 00:34:45,418
where you have the server to the more

852
00:34:45,418 --> 00:34:48,918
expensive computation right

853
00:34:49,199 --> 00:34:50,280
so

854
00:34:50,280 --> 00:34:51,780
um and finally I would like to mention

855
00:34:51,780 --> 00:34:54,239
that as I mentioned jxt is compatible

856
00:34:54,239 --> 00:34:56,639
with a rich body of work on uh

857
00:34:56,639 --> 00:34:58,680
searchable symmetric encryption that

858
00:34:58,680 --> 00:35:00,900
supports uh Rich class of Boolean

859
00:35:00,900 --> 00:35:03,720
queries within tables now together for

860
00:35:03,720 --> 00:35:05,220
example one such scheme is oblivious

861
00:35:05,220 --> 00:35:07,320
crosstalk sort of XT from way back in

862
00:35:07,320 --> 00:35:10,260
crypto 2013 and now you can combine jxt

863
00:35:10,260 --> 00:35:12,660
with the schemes to support more General

864
00:35:12,660 --> 00:35:15,000
conjunctive queries over joint Softails

865
00:35:15,000 --> 00:35:17,220
right so for example you could now have

866
00:35:17,220 --> 00:35:19,320
I suppose that the transactions table

867
00:35:19,320 --> 00:35:20,700
and the merchants table had more

868
00:35:20,700 --> 00:35:22,500
attributes then you can now have a

869
00:35:22,500 --> 00:35:23,940
richer class of queries that you can

870
00:35:23,940 --> 00:35:26,700
support uh using jxt

871
00:35:26,700 --> 00:35:28,680
so now I'll give a very brief technical

872
00:35:28,680 --> 00:35:30,599
overview this will be very informal and

873
00:35:30,599 --> 00:35:32,640
I mainly do it with respect to this toy

874
00:35:32,640 --> 00:35:35,099
example for the details and the proofs I

875
00:35:35,099 --> 00:35:36,900
would refer to the paper so suppose

876
00:35:36,900 --> 00:35:38,460
again that we have the transactions

877
00:35:38,460 --> 00:35:40,680
table and the merchants table and let's

878
00:35:40,680 --> 00:35:43,560
say that but the only crypto primitive

879
00:35:43,560 --> 00:35:45,540
that I will use is a is a pseudo random

880
00:35:45,540 --> 00:35:47,040
function which I hope that you are

881
00:35:47,040 --> 00:35:49,320
familiar with and you know let's

882
00:35:49,320 --> 00:35:51,599
consider that f is a prf family and

883
00:35:51,599 --> 00:35:54,240
let's say that K1 K2 K3 and K4 are

884
00:35:54,240 --> 00:35:57,180
uniformly randomly sampled keys and I'll

885
00:35:57,180 --> 00:35:59,520
use this little F little G little H 0

886
00:35:59,520 --> 00:36:02,220
and little H1 to denote specific special

887
00:36:02,220 --> 00:36:04,140
instances of this prf with respect to

888
00:36:04,140 --> 00:36:05,700
these different keys right so for all

889
00:36:05,700 --> 00:36:07,740
practical purposes we can treat them as

890
00:36:07,740 --> 00:36:09,480
you know independently functioning

891
00:36:09,480 --> 00:36:11,640
random functions

892
00:36:11,640 --> 00:36:14,040
so what we do is as I already said in

893
00:36:14,040 --> 00:36:16,380
jxt we basically process each table in

894
00:36:16,380 --> 00:36:18,480
isolation so let's say we take the

895
00:36:18,480 --> 00:36:20,400
transactions table and we take the first

896
00:36:20,400 --> 00:36:23,099
record T1 we basically create three

897
00:36:23,099 --> 00:36:25,260
variables for this record an X variable

898
00:36:25,260 --> 00:36:28,140
a y variable and a z variable the X

899
00:36:28,140 --> 00:36:31,140
variable basically stores the IDE which

900
00:36:31,140 --> 00:36:33,180
is let's say T1 so it basically stores

901
00:36:33,180 --> 00:36:36,060
what the identity is along with the just

902
00:36:36,060 --> 00:36:37,619
the name of the join attribute right

903
00:36:37,619 --> 00:36:40,140
doesn't store the explicit value

904
00:36:40,140 --> 00:36:43,859
and uh similarly y1 it stores the actual

905
00:36:43,859 --> 00:36:46,980
uh you know the value which occurs in

906
00:36:46,980 --> 00:36:49,740
the uh join attribute field

907
00:36:49,740 --> 00:36:51,599
and then we have Z which is basically

908
00:36:51,599 --> 00:36:53,579
the xor of these two values okay so we

909
00:36:53,579 --> 00:36:54,960
have these three values I'll talk about

910
00:36:54,960 --> 00:36:56,940
what we do with this but let's just

911
00:36:56,940 --> 00:36:58,500
remember that for each record we have

912
00:36:58,500 --> 00:37:01,079
three values X Y and Z so we do this for

913
00:37:01,079 --> 00:37:03,000
the transactions table and we do this

914
00:37:03,000 --> 00:37:04,500
for the margins table right so remember

915
00:37:04,500 --> 00:37:06,180
that these two tables can be set up

916
00:37:06,180 --> 00:37:08,099
independently so we treat them in

917
00:37:08,099 --> 00:37:10,140
exactly the same way and we do this for

918
00:37:10,140 --> 00:37:11,700
each of the records in each of the

919
00:37:11,700 --> 00:37:13,500
tables okay

920
00:37:13,500 --> 00:37:16,440
so now let's consider what happened when

921
00:37:16,440 --> 00:37:17,940
you actually have a pair of matching

922
00:37:17,940 --> 00:37:20,220
entries right so this is kind of you

923
00:37:20,220 --> 00:37:21,660
know we are looking back at it from the

924
00:37:21,660 --> 00:37:23,339
point of view of the query but let's see

925
00:37:23,339 --> 00:37:25,440
what exactly happens so as you can see

926
00:37:25,440 --> 00:37:27,000
that each of these entries will have

927
00:37:27,000 --> 00:37:29,640
their own X Y and Z values but the

928
00:37:29,640 --> 00:37:31,380
interesting thing is that if they match

929
00:37:31,380 --> 00:37:34,200
in the join attribute then the Y values

930
00:37:34,200 --> 00:37:36,300
are actually identical on the other hand

931
00:37:36,300 --> 00:37:38,520
if there are a pair of entries that

932
00:37:38,520 --> 00:37:41,099
don't match in the uh join attribute

933
00:37:41,099 --> 00:37:43,200
field then their y values are distinct

934
00:37:43,200 --> 00:37:45,180
okay and in fact they are in a sort of

935
00:37:45,180 --> 00:37:47,339
randomly since pseudo random functions

936
00:37:47,339 --> 00:37:48,960
uh you know they are computationally

937
00:37:48,960 --> 00:37:50,520
indistinguishable from just to

938
00:37:50,520 --> 00:37:52,380
independently sampled random factors

939
00:37:52,380 --> 00:37:54,359
okay so this is also something that

940
00:37:54,359 --> 00:37:56,880
we'll keep in mind and now here's a very

941
00:37:56,880 --> 00:37:59,160
brief overview of what we do so

942
00:37:59,160 --> 00:38:02,220
essentially what we put on the server uh

943
00:38:02,220 --> 00:38:04,440
is a data structure that will for this

944
00:38:04,440 --> 00:38:06,119
purpose of this talk we'll just consider

945
00:38:06,119 --> 00:38:08,339
it abstractly as a key value store so

946
00:38:08,339 --> 00:38:10,020
this is a data structure that stores

947
00:38:10,020 --> 00:38:12,480
pairs of keys and values and given a

948
00:38:12,480 --> 00:38:14,400
valid key the associated value can be

949
00:38:14,400 --> 00:38:17,579
sort of retrieved very efficient okay so

950
00:38:17,579 --> 00:38:19,200
there are many realizations of this in

951
00:38:19,200 --> 00:38:20,940
practice but you know I won't go into

952
00:38:20,940 --> 00:38:22,380
the details of how you can implement

953
00:38:22,380 --> 00:38:23,280
this

954
00:38:23,280 --> 00:38:26,160
so what we'll do is for each record in

955
00:38:26,160 --> 00:38:27,660
the first table as well as for the

956
00:38:27,660 --> 00:38:29,520
second table we'll basically store a key

957
00:38:29,520 --> 00:38:32,040
value pair which is basically the uh you

958
00:38:32,040 --> 00:38:33,839
know the corresponding X and Y values

959
00:38:33,839 --> 00:38:35,880
but we won't store them in the clear

960
00:38:35,880 --> 00:38:39,180
okay what we'll do is we'll store a sort

961
00:38:39,180 --> 00:38:41,520
of one time added version of this I

962
00:38:41,520 --> 00:38:43,619
won't go into the details of uh you know

963
00:38:43,619 --> 00:38:45,720
like how why we do that but it will be

964
00:38:45,720 --> 00:38:47,400
clear as I showcase how we do the search

965
00:38:47,400 --> 00:38:49,980
but we'll just store some one-time added

966
00:38:49,980 --> 00:38:53,640
version of these of these entries in

967
00:38:53,640 --> 00:38:55,859
this key value store and we'll do a

968
00:38:55,859 --> 00:38:57,420
similar thing for the other table as

969
00:38:57,420 --> 00:38:59,460
well right so we will basically store

970
00:38:59,460 --> 00:39:02,339
one time added versions of these values

971
00:39:02,339 --> 00:39:05,220
now um yeah and this is like a brief

972
00:39:05,220 --> 00:39:07,020
overview of how you can actually do it

973
00:39:07,020 --> 00:39:09,060
so what you do is you store this masked

974
00:39:09,060 --> 00:39:11,400
X values and Y values uh in the

975
00:39:11,400 --> 00:39:13,800
encrypted key value store and suppose

976
00:39:13,800 --> 00:39:15,780
that I issue a query of the form date

977
00:39:15,780 --> 00:39:19,079
equals January 2022 then I can basically

978
00:39:19,079 --> 00:39:21,540
efficiently retrieve the masked X and Y

979
00:39:21,540 --> 00:39:24,060
values corresponding to T4 and T5 okay

980
00:39:24,060 --> 00:39:27,300
for table T1 separately similarly for

981
00:39:27,300 --> 00:39:29,160
the merchants table if I wanted to issue

982
00:39:29,160 --> 00:39:31,020
a query of the form okay give me all

983
00:39:31,020 --> 00:39:32,940
records corresponding to Merchant name

984
00:39:32,940 --> 00:39:35,160
equals Apple then I can again retrieve

985
00:39:35,160 --> 00:39:37,200
the one time added X and Y values

986
00:39:37,200 --> 00:39:38,700
corresponding to the records in the

987
00:39:38,700 --> 00:39:41,160
merchants Table and there are many sort

988
00:39:41,160 --> 00:39:42,839
of well-known techniques to do this in

989
00:39:42,839 --> 00:39:44,760
the SSC Literature Like G sets and

990
00:39:44,760 --> 00:39:47,339
encrypted multiples okay

991
00:39:47,339 --> 00:39:49,740
so now the trick is that we actually

992
00:39:49,740 --> 00:39:51,960
have also remember we have the Z values

993
00:39:51,960 --> 00:39:54,060
as well and now these Z values we

994
00:39:54,060 --> 00:39:56,880
basically store them in a data structure

995
00:39:56,880 --> 00:39:58,859
such as a blue filter which allows us

996
00:39:58,859 --> 00:40:00,960
for efficient membership testing so we

997
00:40:00,960 --> 00:40:02,579
are not really interested in retrieving

998
00:40:02,579 --> 00:40:04,560
the Z values we are just interested in

999
00:40:04,560 --> 00:40:06,480
testing the membership

1000
00:40:06,480 --> 00:40:08,940
so now here is an example of what you

1001
00:40:08,940 --> 00:40:10,560
know you what might happen right so

1002
00:40:10,560 --> 00:40:12,300
suppose we issued this query that you

1003
00:40:12,300 --> 00:40:13,800
know find all queries in the equation

1004
00:40:13,800 --> 00:40:16,020
where we have date equals uh January

1005
00:40:16,020 --> 00:40:18,960
2022 and margin name is up now suppose

1006
00:40:18,960 --> 00:40:20,820
that you retrieve the record T5 from the

1007
00:40:20,820 --> 00:40:22,800
transactions table so you have this

1008
00:40:22,800 --> 00:40:25,200
one-time added value of x and one time

1009
00:40:25,200 --> 00:40:27,540
added value corresponding to Y and then

1010
00:40:27,540 --> 00:40:29,400
you also retrieve the first record from

1011
00:40:29,400 --> 00:40:31,020
the margins table because it has margin

1012
00:40:31,020 --> 00:40:32,820
name equals apple and you have this mask

1013
00:40:32,820 --> 00:40:35,820
X Prime and Y Prime values okay and now

1014
00:40:35,820 --> 00:40:38,099
let's focus on one particular thing

1015
00:40:38,099 --> 00:40:40,440
which is that if you remember since they

1016
00:40:40,440 --> 00:40:42,060
have the same value in the transaction

1017
00:40:42,060 --> 00:40:44,520
ID field they will have the same y value

1018
00:40:44,520 --> 00:40:47,940
so we can replace y5 with Y prime one

1019
00:40:47,940 --> 00:40:50,640
and now the important thing to note here

1020
00:40:50,640 --> 00:40:52,560
is I will just focus on these three

1021
00:40:52,560 --> 00:40:54,780
values which are highlighted the masked

1022
00:40:54,780 --> 00:40:57,180
X1 Prime value The Mask y One Prime

1023
00:40:57,180 --> 00:40:59,099
value which comes from the transactions

1024
00:40:59,099 --> 00:41:01,440
table and this particular Z Prime value

1025
00:41:01,440 --> 00:41:04,380
which is the xor of X and Y okay

1026
00:41:04,380 --> 00:41:07,320
so if we are somehow able to check if X1

1027
00:41:07,320 --> 00:41:10,740
Prime X or Y 1 Prime occurs in the uh

1028
00:41:10,740 --> 00:41:12,599
blue filter we are done but we still

1029
00:41:12,599 --> 00:41:15,300
have these masks to get rid of and so at

1030
00:41:15,300 --> 00:41:16,920
a very high level what the client would

1031
00:41:16,920 --> 00:41:18,960
do is it would basically send to the

1032
00:41:18,960 --> 00:41:21,359
server the xor of these two masks right

1033
00:41:21,359 --> 00:41:23,339
and this it can do because it knows that

1034
00:41:23,339 --> 00:41:25,800
it is searching for the date and uh you

1035
00:41:25,800 --> 00:41:27,540
know what date it is searching for and

1036
00:41:27,540 --> 00:41:29,099
what merchant name it is searching for

1037
00:41:29,099 --> 00:41:31,140
what it doesn't know implicitly is what

1038
00:41:31,140 --> 00:41:33,359
the corresponding joint value is but now

1039
00:41:33,359 --> 00:41:34,980
we will rely on the fact that if you

1040
00:41:34,980 --> 00:41:36,900
exalt all these three things then you

1041
00:41:36,900 --> 00:41:39,119
basically recover the Z1 Prime and you

1042
00:41:39,119 --> 00:41:40,740
check its membership in the blue filter

1043
00:41:40,740 --> 00:41:42,839
and you would actually get true okay

1044
00:41:42,839 --> 00:41:44,579
which would indicate that these are a

1045
00:41:44,579 --> 00:41:46,740
pair of matching records which have the

1046
00:41:46,740 --> 00:41:48,960
same join attribute value

1047
00:41:48,960 --> 00:41:51,000
on the other hand consider a pair of

1048
00:41:51,000 --> 00:41:53,220
Records which match the individual

1049
00:41:53,220 --> 00:41:56,099
queries which is January 2022 and apple

1050
00:41:56,099 --> 00:41:58,260
but they don't match in the transaction

1051
00:41:58,260 --> 00:41:59,160
ID

1052
00:41:59,160 --> 00:42:01,380
now in this case you actually have to

1053
00:42:01,380 --> 00:42:03,960
distinct Y and Y Prime values which

1054
00:42:03,960 --> 00:42:06,480
means that when you exhort them you get

1055
00:42:06,480 --> 00:42:08,880
a random value which with very very high

1056
00:42:08,880 --> 00:42:10,800
probability does not occur in the bloom

1057
00:42:10,800 --> 00:42:12,780
filter and the membership test returns

1058
00:42:12,780 --> 00:42:15,359
false okay so this was of course a very

1059
00:42:15,359 --> 00:42:17,520
simplified overview and in particular if

1060
00:42:17,520 --> 00:42:19,920
you send this pairwise xor of masks then

1061
00:42:19,920 --> 00:42:21,420
the client has to do some amount of

1062
00:42:21,420 --> 00:42:23,880
quadratic work which we want to avoid so

1063
00:42:23,880 --> 00:42:25,260
in the paper we have additional

1064
00:42:25,260 --> 00:42:27,300
techniques where we further delegate

1065
00:42:27,300 --> 00:42:29,220
this pairwise xor computations to the

1066
00:42:29,220 --> 00:42:31,440
server while the client only does linear

1067
00:42:31,440 --> 00:42:33,720
amount of unfortunately I won't have

1068
00:42:33,720 --> 00:42:35,760
time to go into the details of this so I

1069
00:42:35,760 --> 00:42:37,980
will refer to the paper

1070
00:42:37,980 --> 00:42:40,020
and finally I just have a one slide

1071
00:42:40,020 --> 00:42:41,940
description of the leakage of this

1072
00:42:41,940 --> 00:42:44,220
particular scheme so one leakage that we

1073
00:42:44,220 --> 00:42:46,320
have is the joint attribute distribution

1074
00:42:46,320 --> 00:42:48,900
pattern so for example it leaks the

1075
00:42:48,900 --> 00:42:51,420
frequency distribution of the values

1076
00:42:51,420 --> 00:42:53,400
which are taken by the transaction ID

1077
00:42:53,400 --> 00:42:56,040
across records which are matching the

1078
00:42:56,040 --> 00:42:58,920
date equals January 2020. okay

1079
00:42:58,920 --> 00:43:01,140
so remember that transaction ID is the

1080
00:43:01,140 --> 00:43:03,119
join attribute and so in some sense you

1081
00:43:03,119 --> 00:43:05,400
get a histogram of the distribution of

1082
00:43:05,400 --> 00:43:07,260
the various values of the join attribute

1083
00:43:07,260 --> 00:43:09,300
across the different matching records in

1084
00:43:09,300 --> 00:43:11,400
each day now of course this would not be

1085
00:43:11,400 --> 00:43:13,380
a leakage if each of these values were

1086
00:43:13,380 --> 00:43:15,480
unique okay because this is typically

1087
00:43:15,480 --> 00:43:17,819
the case uh if the joint attribute is a

1088
00:43:17,819 --> 00:43:20,040
primary key in this case all you see is

1089
00:43:20,040 --> 00:43:21,300
that okay

1090
00:43:21,300 --> 00:43:23,700
it's it has a unique value in each field

1091
00:43:23,700 --> 00:43:25,740
and that's that's fine because you know

1092
00:43:25,740 --> 00:43:27,240
that this is a join attribute and you

1093
00:43:27,240 --> 00:43:29,760
expect it to be a primary key so if the

1094
00:43:29,760 --> 00:43:31,740
joint attribute is a primary key or it's

1095
00:43:31,740 --> 00:43:33,420
high entropy then this leakage is not

1096
00:43:33,420 --> 00:43:35,520
significant but if the joint attribute

1097
00:43:35,520 --> 00:43:37,560
is low entropy if in some case you

1098
00:43:37,560 --> 00:43:40,079
actually need to join two tables on an

1099
00:43:40,079 --> 00:43:42,599
attribute which is not a primary key in

1100
00:43:42,599 --> 00:43:44,339
this case uh you know there might be

1101
00:43:44,339 --> 00:43:46,680
issues there's one way to avoid it which

1102
00:43:46,680 --> 00:43:48,480
is you structure the query so I said the

1103
00:43:48,480 --> 00:43:50,280
join attribute is high entropy in the

1104
00:43:50,280 --> 00:43:52,500
first table because it is only from the

1105
00:43:52,500 --> 00:43:53,880
first table that the leakage happens

1106
00:43:53,880 --> 00:43:55,980
maybe the joint attribute is high

1107
00:43:55,980 --> 00:43:57,599
entropy in the first table and low

1108
00:43:57,599 --> 00:43:59,640
entropy in the second table

1109
00:43:59,640 --> 00:44:01,200
um in that case you have a strategy but

1110
00:44:01,200 --> 00:44:03,000
if it is low entropy in both tables then

1111
00:44:03,000 --> 00:44:04,859
this is a leakage and you know we leave

1112
00:44:04,859 --> 00:44:08,160
it open to further crypto analysis

1113
00:44:08,160 --> 00:44:10,020
and finally I would like to conclude

1114
00:44:10,020 --> 00:44:12,119
with some open questions so we leave it

1115
00:44:12,119 --> 00:44:14,640
open to extend jxt to flexibly support

1116
00:44:14,640 --> 00:44:18,540
join Over You Know arbitrary attributes

1117
00:44:18,540 --> 00:44:20,280
um for now we need a designated set of

1118
00:44:20,280 --> 00:44:22,079
join attributes at setup

1119
00:44:22,079 --> 00:44:23,760
um so it would be good to also remove

1120
00:44:23,760 --> 00:44:26,460
that restriction it is also sort of an

1121
00:44:26,460 --> 00:44:27,960
interesting future direction to support

1122
00:44:27,960 --> 00:44:29,940
queries over equations of three or more

1123
00:44:29,940 --> 00:44:31,319
tables because the techniques I

1124
00:44:31,319 --> 00:44:33,119
currently showed are for pairs of tables

1125
00:44:33,119 --> 00:44:35,520
and finally we leave it open to extend

1126
00:44:35,520 --> 00:44:38,040
and analyze jxt further for you know

1127
00:44:38,040 --> 00:44:40,380
Dynamic Addition deletion of records and

1128
00:44:40,380 --> 00:44:42,000
also to implement an experiment over

1129
00:44:42,000 --> 00:44:44,520
very large database foreign thank you

1130
00:44:44,520 --> 00:44:46,260
for your attention and I'll be happy to

1131
00:44:46,260 --> 00:44:48,980
answer any questions

1132
00:44:53,160 --> 00:44:56,000
so any question

1133
00:44:56,520 --> 00:45:00,119
you have a short time for one question

1134
00:45:00,119 --> 00:45:03,740
is there any online question

1135
00:45:08,460 --> 00:45:10,560
so there's no question so let's thank

1136
00:45:10,560 --> 00:45:12,660
the topic again

1137
00:45:12,660 --> 00:45:14,280
thank you

1138
00:45:14,280 --> 00:45:16,819
thank you

1139
00:45:46,339 --> 00:45:50,099
okay so the last talk in this session is

1140
00:45:50,099 --> 00:45:52,319
about witness encryption and doing IO

1141
00:45:52,319 --> 00:45:58,980
from AV LW by vinot by kutanagara or

1142
00:45:58,980 --> 00:46:01,319
degree and Daniel wish and we give the

1143
00:46:01,319 --> 00:46:04,020
talk please all right thank you um all

1144
00:46:04,020 --> 00:46:05,940
right so um right so I'm talking about

1145
00:46:05,940 --> 00:46:09,060
the witness encryption now I owe so uh

1146
00:46:09,060 --> 00:46:11,760
in a programming obfuscation IO your

1147
00:46:11,760 --> 00:46:15,060
goal is to convert a program C into a

1148
00:46:15,060 --> 00:46:16,920
functionally equivalent program for

1149
00:46:16,920 --> 00:46:19,680
obfuscater program with the requirements

1150
00:46:19,680 --> 00:46:21,359
that if you're given two programs that

1151
00:46:21,359 --> 00:46:23,460
are functional equivalent then the

1152
00:46:23,460 --> 00:46:25,079
obfuscated program should be

1153
00:46:25,079 --> 00:46:26,940
accommodation in distinguishable

1154
00:46:26,940 --> 00:46:30,359
okay so uh in this work we're going to

1155
00:46:30,359 --> 00:46:33,960
focus on a relaxation or weakening of IO

1156
00:46:33,960 --> 00:46:36,720
which is called now IO which has the

1157
00:46:36,720 --> 00:46:38,940
same correctness requirements but a

1158
00:46:38,940 --> 00:46:41,220
weaker security guarantee namely that

1159
00:46:41,220 --> 00:46:44,460
the indisvocability should call only for

1160
00:46:44,460 --> 00:46:46,800
uh now programs namely these are

1161
00:46:46,800 --> 00:46:48,480
programs that are rejecting on all

1162
00:46:48,480 --> 00:46:49,920
possible inputs

1163
00:46:49,920 --> 00:46:53,400
okay so one reason to study uh now I owe

1164
00:46:53,400 --> 00:46:55,319
is that the implied witness encryption

1165
00:46:55,319 --> 00:46:58,560
which is a powerful form of the public

1166
00:46:58,560 --> 00:47:01,319
encryption where you can use any MP

1167
00:47:01,319 --> 00:47:03,359
statement as a public key and you can

1168
00:47:03,359 --> 00:47:05,579
use any weakness for the statement as a

1169
00:47:05,579 --> 00:47:09,200
secret key to decryptus have attacks

1170
00:47:09,359 --> 00:47:12,000
so the main results of our paper is uh

1171
00:47:12,000 --> 00:47:13,740
simple now I owe and weakness encryption

1172
00:47:13,740 --> 00:47:15,900
schemes that are secure under lattice

1173
00:47:15,900 --> 00:47:17,760
assumptions

1174
00:47:17,760 --> 00:47:20,099
uh in particular our simple here means

1175
00:47:20,099 --> 00:47:21,420
that our schemes are reasonably

1176
00:47:21,420 --> 00:47:24,119
efficient and they avoid a complex Norm

1177
00:47:24,119 --> 00:47:26,640
that box recursion uh that comes that

1178
00:47:26,640 --> 00:47:28,680
are used in the state of uh in the state

1179
00:47:28,680 --> 00:47:30,780
of the Rio schemes from simple

1180
00:47:30,780 --> 00:47:33,000
assumptions

1181
00:47:33,000 --> 00:47:36,960
right specifically we analyze the uh now

1182
00:47:36,960 --> 00:47:38,640
or now i o n with this encryption

1183
00:47:38,640 --> 00:47:41,040
candidates from uh the uh an earlier

1184
00:47:41,040 --> 00:47:44,339
work with uh ilay and vinod the cvw

1185
00:47:44,339 --> 00:47:48,240
schemes uh and we show that the schemes

1186
00:47:48,240 --> 00:47:50,940
are secure under the evasive RW

1187
00:47:50,940 --> 00:47:54,720
assumption introducing my earlier paper

1188
00:47:54,720 --> 00:47:55,859
um let me just say that there's an

1189
00:47:55,859 --> 00:47:57,540
independent and concurrent work of

1190
00:47:57,540 --> 00:48:00,900
suburi with some 80 overlap in the

1191
00:48:00,900 --> 00:48:03,300
results though my buyer's opinion is

1192
00:48:03,300 --> 00:48:04,800
that our constructions are a bit simpler

1193
00:48:04,800 --> 00:48:06,180
and more modular

1194
00:48:06,180 --> 00:48:09,300
and for this talk I'm going to focus on

1195
00:48:09,300 --> 00:48:12,780
our uh now now I O uh schemes and

1196
00:48:12,780 --> 00:48:14,579
starting by telling you about this the

1197
00:48:14,579 --> 00:48:16,980
evasive of the assumption that we use uh

1198
00:48:16,980 --> 00:48:18,420
the description of the obfuscation

1199
00:48:18,420 --> 00:48:20,579
algorithms and uh which takes input

1200
00:48:20,579 --> 00:48:22,319
branching programs and then I'll provide

1201
00:48:22,319 --> 00:48:25,460
a sketch of the proof of security

1202
00:48:25,740 --> 00:48:28,980
so in evasive automation uh were given

1203
00:48:28,980 --> 00:48:33,960
to two distributions over matrices SMP

1204
00:48:33,960 --> 00:48:36,480
and we consider adversary that guesses

1205
00:48:36,480 --> 00:48:39,839
input uh SB plus e for a random Matrix

1206
00:48:39,839 --> 00:48:41,780
uniformly random Matrix B

1207
00:48:41,780 --> 00:48:44,940
and uh gaussian pre-images of p with

1208
00:48:44,940 --> 00:48:47,099
respect to this Matrix B

1209
00:48:47,099 --> 00:48:49,380
okay now that given this quantities the

1210
00:48:49,380 --> 00:48:51,359
adversary can compute

1211
00:48:51,359 --> 00:48:53,220
SP plus e Prime

1212
00:48:53,220 --> 00:48:55,619
and the Assumption basically says that

1213
00:48:55,619 --> 00:48:57,599
if the terms are given the first row of

1214
00:48:57,599 --> 00:49:00,540
the Assumption are pseudo-random then

1215
00:49:00,540 --> 00:49:02,520
the quality is given the bottom row are

1216
00:49:02,520 --> 00:49:05,300
also Sugar Ray

1217
00:49:05,339 --> 00:49:07,740
as a quick sanity check we note that the

1218
00:49:07,740 --> 00:49:10,020
evasive lwe assumption is true from the

1219
00:49:10,020 --> 00:49:12,900
LGBT assumption if S and P are uniform

1220
00:49:12,900 --> 00:49:15,480
distributions over matrices so in

1221
00:49:15,480 --> 00:49:17,940
general we'll be considering uh we'll be

1222
00:49:17,940 --> 00:49:19,500
using the Assumption on distributions

1223
00:49:19,500 --> 00:49:22,079
that are effect not uniform

1224
00:49:22,079 --> 00:49:24,000
for the applications we actually require

1225
00:49:24,000 --> 00:49:26,700
strengthening of this assumption where

1226
00:49:26,700 --> 00:49:29,280
the distinguishers as a additional input

1227
00:49:29,280 --> 00:49:32,160
some auxiliary inputs that can depend on

1228
00:49:32,160 --> 00:49:35,160
the matrices SMP but uh independent of

1229
00:49:35,160 --> 00:49:37,980
the random Matrix speed

1230
00:49:37,980 --> 00:49:42,240
so to describe our uh IO uh schemes we

1231
00:49:42,240 --> 00:49:43,200
first need to talk about branching

1232
00:49:43,200 --> 00:49:45,180
programs which are the inputs for our

1233
00:49:45,180 --> 00:49:47,660
obfuscation programs for our office

1234
00:49:47,660 --> 00:49:50,220
obfuscation schemes and here we're going

1235
00:49:50,220 --> 00:49:51,900
to work with a very simple uh definition

1236
00:49:51,900 --> 00:49:54,000
operation programs which are specified

1237
00:49:54,000 --> 00:49:57,000
by row Vector U and L pairs of square

1238
00:49:57,000 --> 00:49:59,640
matrices and when you evaluate this

1239
00:49:59,640 --> 00:50:02,640
function program on a lb input X we

1240
00:50:02,640 --> 00:50:04,020
basically take a subset product of the

1241
00:50:04,020 --> 00:50:06,720
Matrix of the M matrices multiplied by U

1242
00:50:06,720 --> 00:50:08,640
and check whether you get the all zeros

1243
00:50:08,640 --> 00:50:10,859
vector and if you get the audio Vector

1244
00:50:10,859 --> 00:50:14,540
you accept and otherwise you reject

1245
00:50:14,579 --> 00:50:16,619
and now prior Works already showed that

1246
00:50:16,619 --> 00:50:18,540
if you can obfuscate this very simple

1247
00:50:18,540 --> 00:50:21,960
class of once branching programs then uh

1248
00:50:21,960 --> 00:50:24,119
with a very small overhead you can also

1249
00:50:24,119 --> 00:50:27,180
get uh that now I O for uh General

1250
00:50:27,180 --> 00:50:29,040
branching programs as well as our

1251
00:50:29,040 --> 00:50:31,940
witness encryption Institution

1252
00:50:32,280 --> 00:50:34,319
actually let me now tell you about the

1253
00:50:34,319 --> 00:50:36,540
cvw obfuscation scheme for such

1254
00:50:36,540 --> 00:50:38,280
branching programs

1255
00:50:38,280 --> 00:50:41,520
so the uh right the uh the scheme takes

1256
00:50:41,520 --> 00:50:43,859
a simple operation program and outputs a

1257
00:50:43,859 --> 00:50:46,280
bunch of Matrix so c0 and L Passover

1258
00:50:46,280 --> 00:50:50,160
matrices uh bi sub BS where a c0

1259
00:50:50,160 --> 00:50:52,500
corresponds right uh informally to

1260
00:50:52,500 --> 00:50:54,960
encoding of u0 and the D Matrix

1261
00:50:54,960 --> 00:50:56,880
corresponds to a so-called encoding of

1262
00:50:56,880 --> 00:51:00,599
the M Matrix in fact the cvw candidate

1263
00:51:00,599 --> 00:51:03,720
is based on this uh h15 multi-linear

1264
00:51:03,720 --> 00:51:05,940
encodings

1265
00:51:05,940 --> 00:51:08,280
all right when we evaluate the uh

1266
00:51:08,280 --> 00:51:10,020
obfuscated program we're basically going

1267
00:51:10,020 --> 00:51:11,460
to take a sub separate obviously

1268
00:51:11,460 --> 00:51:14,160
matrices and multiply by c0 and then do

1269
00:51:14,160 --> 00:51:16,380
some additional checks okay let me now

1270
00:51:16,380 --> 00:51:17,880
tell you how you compute these encodings

1271
00:51:17,880 --> 00:51:19,619
the first thing you do is you're going

1272
00:51:19,619 --> 00:51:21,900
to pick a random Square matrices

1273
00:51:21,900 --> 00:51:25,079
uh we call them s and tensored by this n

1274
00:51:25,079 --> 00:51:27,540
matrices okay now if you try to take a

1275
00:51:27,540 --> 00:51:29,819
subset with that by the mixed tensor for

1276
00:51:29,819 --> 00:51:31,680
the property you get basically you have

1277
00:51:31,680 --> 00:51:33,839
F sub x tensored with this subset

1278
00:51:33,839 --> 00:51:35,940
product of the asymptotes

1279
00:51:35,940 --> 00:51:37,800
the next thing you do is you're going to

1280
00:51:37,800 --> 00:51:40,800
multiply the rightmost encodings by

1281
00:51:40,800 --> 00:51:43,200
white outwe images H sub l

1282
00:51:43,200 --> 00:51:45,240
and then the next thing you do and then

1283
00:51:45,240 --> 00:51:46,859
that's sort of your evaluation you are

1284
00:51:46,859 --> 00:51:48,240
also going to get this extra is about

1285
00:51:48,240 --> 00:51:50,280
term and finally you're going to uh

1286
00:51:50,280 --> 00:51:53,099
randomize this product by introducing a

1287
00:51:53,099 --> 00:51:55,619
random matrices Israel A1 up to L minus

1288
00:51:55,619 --> 00:51:57,420
one and then cancel them up with the

1289
00:51:57,420 --> 00:51:59,640
inverses so here this Matrix are going

1290
00:51:59,640 --> 00:52:01,740
to be white out of a matrix and by

1291
00:52:01,740 --> 00:52:03,780
inverse I don't mean uh Matrix inverse

1292
00:52:03,780 --> 00:52:05,579
but rather I'm going to do this uh

1293
00:52:05,579 --> 00:52:07,819
gaussian free images

1294
00:52:07,819 --> 00:52:09,839
and then finally you're going to

1295
00:52:09,839 --> 00:52:11,700
introduce additional noise terms into

1296
00:52:11,700 --> 00:52:13,559
all the D encodings and I'm going to

1297
00:52:13,559 --> 00:52:15,000
introduce this uh I'm going to denote

1298
00:52:15,000 --> 00:52:16,200
this noise terms by this quickly

1299
00:52:16,200 --> 00:52:18,839
underline right so when you take a sub

1300
00:52:18,839 --> 00:52:19,920
step with that you're going to get the

1301
00:52:19,920 --> 00:52:22,079
expression over there plus noise and

1302
00:52:22,079 --> 00:52:24,000
here you for correctness require that

1303
00:52:24,000 --> 00:52:27,000
the matrices uh M and SS low Norm but

1304
00:52:27,000 --> 00:52:28,319
that's fine

1305
00:52:28,319 --> 00:52:30,720
and it's a pretty easy to check that

1306
00:52:30,720 --> 00:52:32,160
when you do this subset without the

1307
00:52:32,160 --> 00:52:33,240
encoding you're going to get a small

1308
00:52:33,240 --> 00:52:37,380
value if the program accepts X and if

1309
00:52:37,380 --> 00:52:39,240
the program rejects X you're going to

1310
00:52:39,240 --> 00:52:41,700
get a uniformly random Matrix

1311
00:52:41,700 --> 00:52:43,440
so that gives you correctness and

1312
00:52:43,440 --> 00:52:45,960
functionality and now let's look at the

1313
00:52:45,960 --> 00:52:48,079
proof of security

1314
00:52:48,079 --> 00:52:50,280
waterproof security of the schema is now

1315
00:52:50,280 --> 00:52:53,160
now I O scheme which means that we want

1316
00:52:53,160 --> 00:52:55,980
to show that if you obfuscate a now

1317
00:52:55,980 --> 00:52:58,020
program which is a branching program

1318
00:52:58,020 --> 00:53:00,119
that is rejecting our office for inputs

1319
00:53:00,119 --> 00:53:02,700
so the subset product is non-zero for

1320
00:53:02,700 --> 00:53:05,099
all possible inputs then this encodings

1321
00:53:05,099 --> 00:53:06,540
are in fact going to be shoulder random

1322
00:53:06,540 --> 00:53:09,660
under the evasive other assumption uh

1323
00:53:09,660 --> 00:53:11,099
what do I do mean by shoulder random

1324
00:53:11,099 --> 00:53:13,200
here so the c0 encoding is going to look

1325
00:53:13,200 --> 00:53:15,900
like a uniformly random Matrix and the D

1326
00:53:15,900 --> 00:53:17,579
matrices are going to look like a

1327
00:53:17,579 --> 00:53:20,819
uniformly random gaussians

1328
00:53:20,819 --> 00:53:22,680
all right so uh here's how the proof

1329
00:53:22,680 --> 00:53:24,960
works the first step consider a mental

1330
00:53:24,960 --> 00:53:27,119
experiment where you take all possible

1331
00:53:27,119 --> 00:53:29,359
uh subset products of the encodings

1332
00:53:29,359 --> 00:53:31,140
corresponding to all possible

1333
00:53:31,140 --> 00:53:33,180
evaluations of the programmer or

1334
00:53:33,180 --> 00:53:35,339
possible inputs okay and you take these

1335
00:53:35,339 --> 00:53:37,140
subset products and you add a fresh

1336
00:53:37,140 --> 00:53:39,780
noise to all this subjects now what do

1337
00:53:39,780 --> 00:53:41,940
what do these two to the elk evaluation

1338
00:53:41,940 --> 00:53:43,020
look like

1339
00:53:43,020 --> 00:53:44,880
uh they're going to be looked like some

1340
00:53:44,880 --> 00:53:46,980
sort of uh like the expression in the on

1341
00:53:46,980 --> 00:53:49,140
the slide and what's nice about this

1342
00:53:49,140 --> 00:53:51,119
expression is that it decomposes into

1343
00:53:51,119 --> 00:53:53,160
the product of two matrices

1344
00:53:53,160 --> 00:53:54,960
where the first Matrix is going to be

1345
00:53:54,960 --> 00:53:56,460
non-zero in fact it's going to be a full

1346
00:53:56,460 --> 00:53:59,160
round Matrix uh because the uh we have a

1347
00:53:59,160 --> 00:54:00,359
now program

1348
00:54:00,359 --> 00:54:01,980
and the second Matrix actually

1349
00:54:01,980 --> 00:54:04,200
corresponds to the BLM or prf which

1350
00:54:04,200 --> 00:54:05,760
means the issue the random

1351
00:54:05,760 --> 00:54:07,740
and when you multiply a pseudo-render

1352
00:54:07,740 --> 00:54:10,500
matrices with uh a full Ram Matrix

1353
00:54:10,500 --> 00:54:12,420
you're going to get something to run so

1354
00:54:12,420 --> 00:54:14,940
this allows us to reduce that this 2 to

1355
00:54:14,940 --> 00:54:16,319
the L evaluations are going to be

1356
00:54:16,319 --> 00:54:17,900
shoulder random

1357
00:54:17,900 --> 00:54:21,000
okay so uh in The Next Step we're going

1358
00:54:21,000 --> 00:54:22,680
to consider all possible 2 to the L

1359
00:54:22,680 --> 00:54:25,020
minus 1 evaluations corresponding to all

1360
00:54:25,020 --> 00:54:27,420
possible L minus 1B inputs the drug

1361
00:54:27,420 --> 00:54:28,980
distribution of this to the L minus for

1362
00:54:28,980 --> 00:54:31,619
evaluations together with the two

1363
00:54:31,619 --> 00:54:34,319
rightmost encodings all right now

1364
00:54:34,319 --> 00:54:36,780
observe that the uh to the L minus one

1365
00:54:36,780 --> 00:54:38,579
evaluations are going to be able to form

1366
00:54:38,579 --> 00:54:40,559
something times a sub L minus 1 plus

1367
00:54:40,559 --> 00:54:41,400
noise

1368
00:54:41,400 --> 00:54:43,619
whereas the two uh rightmost encodings

1369
00:54:43,619 --> 00:54:45,420
are going to be uh gaussian pre-images

1370
00:54:45,420 --> 00:54:49,079
with respect to uh a sub L minus one

1371
00:54:49,079 --> 00:54:50,940
so this means that we can invoke our RW

1372
00:54:50,940 --> 00:54:54,240
assumption with the Matrix B being a sub

1373
00:54:54,240 --> 00:54:55,619
L minus 1.

1374
00:54:55,619 --> 00:54:58,920
and so now when we apply evasive rwe the

1375
00:54:58,920 --> 00:55:00,960
if condition corresponds to exactly what

1376
00:55:00,960 --> 00:55:03,240
we just showed in step one and therefore

1377
00:55:03,240 --> 00:55:06,059
we made the deals uh that the bending

1378
00:55:06,059 --> 00:55:08,280
condition is true which basically tells

1379
00:55:08,280 --> 00:55:10,740
us that this uh 2 to the L minus 1 and

1380
00:55:10,740 --> 00:55:12,240
Coatings are going to be pseudorandom

1381
00:55:12,240 --> 00:55:15,000
even given this uh uh the right modes

1382
00:55:15,000 --> 00:55:16,520
are the encoding

1383
00:55:16,520 --> 00:55:19,200
so you can repeat this argument uh

1384
00:55:19,200 --> 00:55:21,059
iterate this argument uh L minus one

1385
00:55:21,059 --> 00:55:22,559
more times with L minus one more

1386
00:55:22,559 --> 00:55:25,140
iterations of the invocations of the

1387
00:55:25,140 --> 00:55:27,540
invasive algebra assumption and you get

1388
00:55:27,540 --> 00:55:29,880
to a point where you can argue that c0

1389
00:55:29,880 --> 00:55:32,280
is true random given all of the B

1390
00:55:32,280 --> 00:55:33,900
encodings

1391
00:55:33,900 --> 00:55:37,319
okay at this point now c0 is a complete

1392
00:55:37,319 --> 00:55:39,300
random and which means that c0

1393
00:55:39,300 --> 00:55:40,920
completely catches a0

1394
00:55:40,920 --> 00:55:42,660
and then you can basically run an

1395
00:55:42,660 --> 00:55:44,579
argument from an earlier paper which

1396
00:55:44,579 --> 00:55:47,280
which allows you to deduce that all this

1397
00:55:47,280 --> 00:55:49,200
uh D matrices are going to be pseudo

1398
00:55:49,200 --> 00:55:51,480
random as well the basic idea is that

1399
00:55:51,480 --> 00:55:53,640
since c0 height a0 now you can

1400
00:55:53,640 --> 00:55:56,460
essentially three a0 out of a secret to

1401
00:55:56,460 --> 00:55:58,140
deduce that the first pair of the day

1402
00:55:58,140 --> 00:55:59,640
encoding has children

1403
00:55:59,640 --> 00:56:01,559
and that will hide the A1 Matrix and

1404
00:56:01,559 --> 00:56:04,260
then you can use the A1 lwc secret to

1405
00:56:04,260 --> 00:56:06,240
argue that the next two uh D matrices

1406
00:56:06,240 --> 00:56:08,760
are pseudo random and so on and so forth

1407
00:56:08,760 --> 00:56:10,800
so now everything is random and

1408
00:56:10,800 --> 00:56:11,940
therefore you completely hide the

1409
00:56:11,940 --> 00:56:13,140
problem

1410
00:56:13,140 --> 00:56:14,700
so this completes the proof of my own

1411
00:56:14,700 --> 00:56:18,180
security uh let me conclude uh so

1412
00:56:18,180 --> 00:56:20,400
basically we showed that now I O and

1413
00:56:20,400 --> 00:56:21,960
this encryption schemes from the evasive

1414
00:56:21,960 --> 00:56:23,460
algebra assumption

1415
00:56:23,460 --> 00:56:25,680
uh in particular we analyze the cvw

1416
00:56:25,680 --> 00:56:29,099
creditors our security proof is going to

1417
00:56:29,099 --> 00:56:30,839
require instantiated scheduled to

1418
00:56:30,839 --> 00:56:32,540
slightly larger

1419
00:56:32,540 --> 00:56:34,920
parameters uh than in the original

1420
00:56:34,920 --> 00:56:37,640
candidates

1421
00:56:38,720 --> 00:56:41,220
along the way we introduce a new proof

1422
00:56:41,220 --> 00:56:42,839
strategy for proving uh witness

1423
00:56:42,839 --> 00:56:45,660
encryption now I O security uh this

1424
00:56:45,660 --> 00:56:46,800
boost strategy is somewhat different

1425
00:56:46,800 --> 00:56:49,500
qualitatively different from say the

1426
00:56:49,500 --> 00:56:51,000
previous uh

1427
00:56:51,000 --> 00:56:54,540
work of uh Gentry leuko and Waters for

1428
00:56:54,540 --> 00:56:56,220
proving security of witness encryption

1429
00:56:56,220 --> 00:56:58,740
from multi-linear Maps where uh digital

1430
00:56:58,740 --> 00:57:01,619
positioner Paradigm where uh in the push

1431
00:57:01,619 --> 00:57:02,579
strategy they actually require

1432
00:57:02,579 --> 00:57:05,160
explanation number of hybrids whereas in

1433
00:57:05,160 --> 00:57:06,900
our proof we only require a linear

1434
00:57:06,900 --> 00:57:08,880
number of hybrids but what happens is

1435
00:57:08,880 --> 00:57:11,280
that when we invoke the LW the erasify

1436
00:57:11,280 --> 00:57:13,500
the Assumption the size of our instance

1437
00:57:13,500 --> 00:57:15,000
is actually going to grow exponentially

1438
00:57:15,000 --> 00:57:17,280
now in particular the dimensions of the

1439
00:57:17,280 --> 00:57:21,500
Matrix S is going to be exponential

1440
00:57:22,319 --> 00:57:23,940
um right so let me conclude with a

1441
00:57:23,940 --> 00:57:26,280
number of open questions uh the first is

1442
00:57:26,280 --> 00:57:27,599
to better understanding the events

1443
00:57:27,599 --> 00:57:29,760
probability assumption either via group

1444
00:57:29,760 --> 00:57:32,579
analysis or reductions uh the second uh

1445
00:57:32,579 --> 00:57:34,079
pertains to the fact that for our

1446
00:57:34,079 --> 00:57:36,660
analysis we actually require the evasive

1447
00:57:36,660 --> 00:57:38,700
lwe assumption with a private Point

1448
00:57:38,700 --> 00:57:40,740
auxiliary inputs and you can actually

1449
00:57:40,740 --> 00:57:44,359
show that you can construct a contrive

1450
00:57:44,359 --> 00:57:47,579
uh auxiliary input distributions based

1451
00:57:47,579 --> 00:57:49,920
on obfuscation for which the evasive LW

1452
00:57:49,920 --> 00:57:52,740
assumption is false now you can sort of

1453
00:57:52,740 --> 00:57:55,440
uh you can sort of uh the way we handle

1454
00:57:55,440 --> 00:57:56,579
approved you can argue that the

1455
00:57:56,579 --> 00:57:58,079
distributions we get are not contrived

1456
00:57:58,079 --> 00:58:00,180
but another way to get around this

1457
00:58:00,180 --> 00:58:03,119
contract issue is to only work with uh

1458
00:58:03,119 --> 00:58:05,640
public coin auxiliary inputs and here we

1459
00:58:05,640 --> 00:58:07,859
can still ask the questions whether from

1460
00:58:07,859 --> 00:58:10,140
evasive factors uh from evasive other

1461
00:58:10,140 --> 00:58:12,780
social public quite auxiliary inputs you

1462
00:58:12,780 --> 00:58:14,280
can still get some kind of non-trivial

1463
00:58:14,280 --> 00:58:16,559
now i o n videos encryption schemes and

1464
00:58:16,559 --> 00:58:18,000
a good starting point to Regional work

1465
00:58:18,000 --> 00:58:21,059
of agrawal from crypto Edition

1466
00:58:21,059 --> 00:58:22,980
and finally uh can you use a technical

1467
00:58:22,980 --> 00:58:25,559
paper to get to go beyond business

1468
00:58:25,559 --> 00:58:27,780
encryption and now I

1469
00:58:27,780 --> 00:58:30,740
uh thank you

1470
00:58:34,079 --> 00:58:37,079
thank you for the presentation and we

1471
00:58:37,079 --> 00:58:40,760
have plenty of time for questions

1472
00:58:45,380 --> 00:58:48,900
just what was this parameter L

1473
00:58:48,900 --> 00:58:51,000
um which is relevant for this

1474
00:58:51,000 --> 00:58:53,819
exponential growth of the evasively

1475
00:58:53,819 --> 00:58:56,359
instance

1476
00:58:56,359 --> 00:58:58,980
yeah this parameter L what is the

1477
00:58:58,980 --> 00:59:01,380
exponential growth in all right good so

1478
00:59:01,380 --> 00:59:03,660
the uh good so the the Assumption refers

1479
00:59:03,660 --> 00:59:06,420
to this matrices SMP

1480
00:59:06,420 --> 00:59:08,640
um when we invoke the Assumption the

1481
00:59:08,640 --> 00:59:11,220
dimension of this matrices are going to

1482
00:59:11,220 --> 00:59:15,240
be exponential so basically uh so the

1483
00:59:15,240 --> 00:59:16,500
initially when we involved the

1484
00:59:16,500 --> 00:59:18,599
Assumption the S corresponds to

1485
00:59:18,599 --> 00:59:20,520
essentially the concatenation of all of

1486
00:59:20,520 --> 00:59:23,640
the 2 to the L uh evaluations so our

1487
00:59:23,640 --> 00:59:25,859
Matrix S will actually have height to

1488
00:59:25,859 --> 00:59:27,059
the L

1489
00:59:27,059 --> 00:59:29,280
so this is so the size of our assumption

1490
00:59:29,280 --> 00:59:30,960
goes exponentially in l

1491
00:59:30,960 --> 00:59:33,299
so to for the final analysis you need to

1492
00:59:33,299 --> 00:59:35,700
have a very careful setting of security

1493
00:59:35,700 --> 00:59:37,980
parameters to account for the fact that

1494
00:59:37,980 --> 00:59:40,079
the size of the instance actually go

1495
00:59:40,079 --> 00:59:42,619
explanation

1496
00:59:45,079 --> 00:59:47,760
you went by pretty quickly but where

1497
00:59:47,760 --> 00:59:49,380
does the your construction break down

1498
00:59:49,380 --> 00:59:51,660
when uh where does your construction

1499
00:59:51,660 --> 00:59:54,240
break down when the input program is for

1500
00:59:54,240 --> 00:59:56,160
example one on let's say even just a

1501
00:59:56,160 --> 00:59:58,319
sparse number of inputs the question is

1502
00:59:58,319 --> 01:00:00,839
so why does the proof work for uh

1503
01:00:00,839 --> 01:00:03,059
for uh non-invasive that's a good

1504
01:00:03,059 --> 01:00:04,859
question so are there are two ways in

1505
01:00:04,859 --> 01:00:06,900
which it breaks but uh let me say the

1506
01:00:06,900 --> 01:00:09,900
first one so here we use the fact that

1507
01:00:09,900 --> 01:00:11,760
uh to argue that the to the L

1508
01:00:11,760 --> 01:00:13,619
evaluations that should go random we use

1509
01:00:13,619 --> 01:00:16,260
the fact that the program which uh is a

1510
01:00:16,260 --> 01:00:18,839
rejected won't be uh

1511
01:00:18,839 --> 01:00:23,240
people rank if uh that

1512
01:00:24,000 --> 01:00:25,740
yeah yeah if that is going to be small

1513
01:00:25,740 --> 01:00:28,079
so uh so you cannot hope for the

1514
01:00:28,079 --> 01:00:30,119
evaluation to be pseudo random the the

1515
01:00:30,119 --> 01:00:31,799
product is going to be a small value and

1516
01:00:31,799 --> 01:00:34,440
not a uniformly random Matrix

1517
01:00:34,440 --> 01:00:36,119
okay so that's one way in which it

1518
01:00:36,119 --> 01:00:37,980
breaks down

1519
01:00:37,980 --> 01:00:39,839
the other way in which it breaks down is

1520
01:00:39,839 --> 01:00:41,280
that the evasive files of your

1521
01:00:41,280 --> 01:00:44,700
assumption crucially requires that the

1522
01:00:44,700 --> 01:00:47,160
the distribution the if condition are

1523
01:00:47,160 --> 01:00:49,260
pseudo-random in fact the invasive LW

1524
01:00:49,260 --> 01:00:52,200
assumption is false if the distribution

1525
01:00:52,200 --> 01:00:54,420
if conditions are not pseudo random and

1526
01:00:54,420 --> 01:00:57,240
for a general uh programs the condition

1527
01:00:57,240 --> 01:00:59,520
in the if con if condition is going to

1528
01:00:59,520 --> 01:01:01,020
be not going to be sugar random

1529
01:01:01,020 --> 01:01:02,339
basically they're going to be small

1530
01:01:02,339 --> 01:01:04,260
values and this is where uh the

1531
01:01:04,260 --> 01:01:09,380
so-called zero Isaac attacks on iocated

1532
01:01:11,460 --> 01:01:14,280
as a question

1533
01:01:14,280 --> 01:01:17,160
and there is no other question and so

1534
01:01:17,160 --> 01:01:19,079
let's try or take and own the speaker

1535
01:01:19,079 --> 01:01:20,320
games

1536
01:01:20,320 --> 01:01:23,539
[Applause]

