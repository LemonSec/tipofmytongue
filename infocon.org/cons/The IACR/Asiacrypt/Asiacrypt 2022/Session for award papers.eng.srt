1
00:00:59,059 --> 00:01:03,539
and I also need to apologize to certain

2
00:01:03,539 --> 00:01:05,640
attendees

3
00:01:05,640 --> 00:01:10,979
and this entire hotel is under central

4
00:01:10,979 --> 00:01:13,020
air con Central

5
00:01:13,020 --> 00:01:17,340
air conditioning so it is uh essentially

6
00:01:17,340 --> 00:01:19,820
not possible to adjust the temperature

7
00:01:19,820 --> 00:01:24,360
so uh like if you came with the

8
00:01:24,360 --> 00:01:26,220
expectation that Taiwan is a very hot

9
00:01:26,220 --> 00:01:30,360
area we apologize but you know put on an

10
00:01:30,360 --> 00:01:34,560
extra shirt or something yeah

11
00:02:16,739 --> 00:02:19,860
good morning everybody Welcome to the

12
00:02:19,860 --> 00:02:22,739
first session of Asia Crypt and uh this

13
00:02:22,739 --> 00:02:24,300
session will feature all the award

14
00:02:24,300 --> 00:02:27,260
papers so I'm very happy to invite

15
00:02:27,260 --> 00:02:29,819
invite you all to the first the paper

16
00:02:29,819 --> 00:02:32,220
that won the best paper award at this

17
00:02:32,220 --> 00:02:34,980
Asia trip full Quantum equivalence of

18
00:02:34,980 --> 00:02:37,500
group action discrete log and CDH and

19
00:02:37,500 --> 00:02:40,140
more this is a paper by heart Montgomery

20
00:02:40,140 --> 00:02:41,819
and Mark zantry

21
00:02:41,819 --> 00:02:45,379
and heart will give the talk

22
00:02:53,280 --> 00:02:55,319
thanks a lot

23
00:02:55,319 --> 00:02:58,560
um hi everybody I'm heart and today I'm

24
00:02:58,560 --> 00:03:00,060
going to be talking about the full

25
00:03:00,060 --> 00:03:01,860
Quantum equivalence of group action

26
00:03:01,860 --> 00:03:04,560
discrete log and CDH as well as some

27
00:03:04,560 --> 00:03:06,660
other related results and this is a

28
00:03:06,660 --> 00:03:08,459
joint work with the always excellent

29
00:03:08,459 --> 00:03:10,200
mark zandry

30
00:03:10,200 --> 00:03:12,319
so let's get started

31
00:03:12,319 --> 00:03:15,420
uh so for a brief outline of what I'll

32
00:03:15,420 --> 00:03:17,099
go over today I'm going to start by

33
00:03:17,099 --> 00:03:18,599
discussing some background on group

34
00:03:18,599 --> 00:03:21,360
actions I'm going to argue why we should

35
00:03:21,360 --> 00:03:23,400
study group actions I'm going to go over

36
00:03:23,400 --> 00:03:26,040
our results and then I'll go over an

37
00:03:26,040 --> 00:03:27,360
overview of some of the techniques

38
00:03:27,360 --> 00:03:29,040
behind our main result which is the

39
00:03:29,040 --> 00:03:31,140
Quantum equivalence of group action CDH

40
00:03:31,140 --> 00:03:32,879
and discrete log and then I'll go over

41
00:03:32,879 --> 00:03:35,099
some open problems in future work

42
00:03:35,099 --> 00:03:37,680
so let's get started you are probably

43
00:03:37,680 --> 00:03:39,239
familiar with group actions who's used

44
00:03:39,239 --> 00:03:41,340
to group actions here

45
00:03:41,340 --> 00:03:44,459
some people awesome so it's really a

46
00:03:44,459 --> 00:03:46,620
pretty ancient mathematical primitive a

47
00:03:46,620 --> 00:03:48,900
group action is just a tuple of a group

48
00:03:48,900 --> 00:03:52,140
a set and a mapping that satisfies the

49
00:03:52,140 --> 00:03:53,640
identity and the composability

50
00:03:53,640 --> 00:03:55,799
properties and you can think of the

51
00:03:55,799 --> 00:03:57,780
composability property as sort of an

52
00:03:57,780 --> 00:04:01,459
analog of associativity in groups

53
00:04:01,459 --> 00:04:04,140
in this talk I'll mostly be focused on

54
00:04:04,140 --> 00:04:06,239
what's called regular group actions and

55
00:04:06,239 --> 00:04:07,519
these are sort of simpler to think about

56
00:04:07,519 --> 00:04:10,439
what a regular group action is it's a

57
00:04:10,439 --> 00:04:12,120
group action where for any two set

58
00:04:12,120 --> 00:04:14,939
elements X1 and X2 there's a unique

59
00:04:14,939 --> 00:04:17,699
group element such that X2 is equal to G

60
00:04:17,699 --> 00:04:19,738
Star X1 where star is of course to map

61
00:04:19,738 --> 00:04:20,579
it

62
00:04:20,579 --> 00:04:22,560
and this leads to a number of you know

63
00:04:22,560 --> 00:04:25,500
nice facts about the group action for

64
00:04:25,500 --> 00:04:27,479
instance the set and the group have to

65
00:04:27,479 --> 00:04:29,580
have the same number of elements and for

66
00:04:29,580 --> 00:04:32,880
a fixed set element Little X G Star X is

67
00:04:32,880 --> 00:04:35,040
a bijection on x

68
00:04:35,040 --> 00:04:37,259
most group actions used in cryptography

69
00:04:37,259 --> 00:04:39,419
are regular and we'll warn you when we

70
00:04:39,419 --> 00:04:41,699
use non-regular group actions

71
00:04:41,699 --> 00:04:44,340
so what about cryptographic group

72
00:04:44,340 --> 00:04:46,500
actions these have a long history in

73
00:04:46,500 --> 00:04:48,900
cryptography going back to the work of

74
00:04:48,900 --> 00:04:52,560
kuvinis in o6 and before we start by

75
00:04:52,560 --> 00:04:54,780
defining hardness let's think about you

76
00:04:54,780 --> 00:04:55,440
know

77
00:04:55,440 --> 00:04:57,720
some efficiency things that that math

78
00:04:57,720 --> 00:04:59,759
people don't really bother when they

79
00:04:59,759 --> 00:05:02,100
Define group actions so

80
00:05:02,100 --> 00:05:03,780
we're going to start by assuming what's

81
00:05:03,780 --> 00:05:05,460
called an effective group action and I

82
00:05:05,460 --> 00:05:06,720
don't really want to dig into this

83
00:05:06,720 --> 00:05:08,340
definition because it's a little bit

84
00:05:08,340 --> 00:05:10,740
tedious but what it basically means is

85
00:05:10,740 --> 00:05:13,320
that the group action works like you

86
00:05:13,320 --> 00:05:16,380
want it to work group action operations

87
00:05:16,380 --> 00:05:18,660
and group operations are efficient there

88
00:05:18,660 --> 00:05:20,520
are efficient ways to sample uniformly

89
00:05:20,520 --> 00:05:22,680
random group elements and set elements

90
00:05:22,680 --> 00:05:24,900
have unique representation

91
00:05:24,900 --> 00:05:27,000
we'll also assume a billion group

92
00:05:27,000 --> 00:05:29,880
actions because well our results only

93
00:05:29,880 --> 00:05:31,979
work for those and not a billion group

94
00:05:31,979 --> 00:05:33,600
actions are not very useful for

95
00:05:33,600 --> 00:05:35,639
cryptography particularly public key

96
00:05:35,639 --> 00:05:37,039
cryptography

97
00:05:37,039 --> 00:05:39,600
and finally since every a billion group

98
00:05:39,600 --> 00:05:41,400
can be mapped to the additive group of

99
00:05:41,400 --> 00:05:43,320
integers for sub integer P using a

100
00:05:43,320 --> 00:05:46,080
quantum computer we'll often just assume

101
00:05:46,080 --> 00:05:47,520
that our group is the additive group of

102
00:05:47,520 --> 00:05:48,840
integers because we can efficiently

103
00:05:48,840 --> 00:05:50,820
compute this mapping and if you want to

104
00:05:50,820 --> 00:05:52,259
see more on this there are a bunch of

105
00:05:52,259 --> 00:05:53,160
papers

106
00:05:53,160 --> 00:05:55,259
that have gone over what's called known

107
00:05:55,259 --> 00:05:57,960
Order Group actions

108
00:05:57,960 --> 00:06:00,060
so let's define some hardness problems

109
00:06:00,060 --> 00:06:02,460
for group actions so here I'll just put

110
00:06:02,460 --> 00:06:04,740
on the screen the group action discrete

111
00:06:04,740 --> 00:06:08,639
log CDH and ddh problems and I'll note

112
00:06:08,639 --> 00:06:10,740
that these are very analogous to the

113
00:06:10,740 --> 00:06:13,500
traditional definitions over groups you

114
00:06:13,500 --> 00:06:15,780
really just replace you know

115
00:06:15,780 --> 00:06:18,419
exponentiation with the group action

116
00:06:18,419 --> 00:06:20,580
operation and the definitions are

117
00:06:20,580 --> 00:06:22,139
similar like for discrete log for

118
00:06:22,139 --> 00:06:24,600
instance given two set elements X1 and

119
00:06:24,600 --> 00:06:26,880
X2 the problem is just to find some

120
00:06:26,880 --> 00:06:28,740
group elements such that G Star X1 is

121
00:06:28,740 --> 00:06:31,400
equal to X2

122
00:06:31,440 --> 00:06:33,419
um I'm going to ignore some of the

123
00:06:33,419 --> 00:06:36,539
subtleties with sampling elements uh so

124
00:06:36,539 --> 00:06:37,740
for now we'll just assume that

125
00:06:37,740 --> 00:06:40,800
everything is uniformly sampled

126
00:06:40,800 --> 00:06:44,039
now it turns out that you all have

127
00:06:44,039 --> 00:06:45,840
probably been using group actions for

128
00:06:45,840 --> 00:06:47,340
much longer than you've noticed group

129
00:06:47,340 --> 00:06:49,800
exponentiation is just a group action

130
00:06:49,800 --> 00:06:52,139
and how is this the case well if we set

131
00:06:52,139 --> 00:06:54,479
the set of our group action to be the

132
00:06:54,479 --> 00:06:57,240
group G and we set the group to be the

133
00:06:57,240 --> 00:07:00,539
exponent space zp then you know group

134
00:07:00,539 --> 00:07:03,360
exponentiation is just a mapping that

135
00:07:03,360 --> 00:07:06,840
obeys the axioms of the group actions uh

136
00:07:06,840 --> 00:07:08,880
and this is a little bit special and

137
00:07:08,880 --> 00:07:11,039
confusing because the set is a group and

138
00:07:11,039 --> 00:07:13,440
this causes the quantum and security

139
00:07:13,440 --> 00:07:15,600
and the main issue is that there's a set

140
00:07:15,600 --> 00:07:17,639
mapping for group exponentiation which

141
00:07:17,639 --> 00:07:19,860
is just group multiplication and in

142
00:07:19,860 --> 00:07:21,960
general for group actions there's no

143
00:07:21,960 --> 00:07:24,660
structure preserving set mapping

144
00:07:24,660 --> 00:07:26,819
so it turns out that many other

145
00:07:26,819 --> 00:07:28,979
cryptographic group actions excuse me

146
00:07:28,979 --> 00:07:30,360
assumptions are group actions in

147
00:07:30,360 --> 00:07:33,539
Disguise I'll talk about isogenes in

148
00:07:33,539 --> 00:07:34,580
just a second

149
00:07:34,580 --> 00:07:36,960
stickles key exchange protocol and

150
00:07:36,960 --> 00:07:39,479
related uh work if you've ever seen that

151
00:07:39,479 --> 00:07:42,120
as well as very recent work done on the

152
00:07:42,120 --> 00:07:44,099
semi-direct discrete logarithm problem

153
00:07:44,099 --> 00:07:46,680
are all group action based

154
00:07:46,680 --> 00:07:50,639
so let's talk about isogenes as I said

155
00:07:50,639 --> 00:07:52,680
before certain isogeny-based crypto

156
00:07:52,680 --> 00:07:53,940
Primitives can be modeled as group

157
00:07:53,940 --> 00:07:56,280
actions I don't really want to go into

158
00:07:56,280 --> 00:07:57,840
the Gory details of this because there

159
00:07:57,840 --> 00:07:59,340
have been a number of papers that are

160
00:07:59,340 --> 00:08:02,460
written specifically on this topic but

161
00:08:02,460 --> 00:08:04,080
I'll say that sci fish and its

162
00:08:04,080 --> 00:08:06,120
derivatives are effective group actions

163
00:08:06,120 --> 00:08:08,699
as we defined earlier and our work will

164
00:08:08,699 --> 00:08:10,199
directly apply to this

165
00:08:10,199 --> 00:08:12,240
Seaside is a bit more complicated

166
00:08:12,240 --> 00:08:14,099
classically it's something called a

167
00:08:14,099 --> 00:08:16,560
restricted effective group action our

168
00:08:16,560 --> 00:08:18,660
results apply here with some caveats and

169
00:08:18,660 --> 00:08:20,819
I'll explain this more in a minute uh

170
00:08:20,819 --> 00:08:23,720
and finally sidh and some recent

171
00:08:23,720 --> 00:08:26,520
follow-ups on that are not group actions

172
00:08:26,520 --> 00:08:30,300
uh and luckily for us here these uh

173
00:08:30,300 --> 00:08:33,120
recent attacks do not appear to apply to

174
00:08:33,120 --> 00:08:35,039
group action based

175
00:08:35,039 --> 00:08:36,958
by isogenies

176
00:08:36,958 --> 00:08:40,080
so one last thing on group actions you

177
00:08:40,080 --> 00:08:42,659
know sort of how do they work uh key

178
00:08:42,659 --> 00:08:44,279
exchange from group actions is very

179
00:08:44,279 --> 00:08:46,500
simple so if we have an a billion

180
00:08:46,500 --> 00:08:48,300
regular group action where the CDH

181
00:08:48,300 --> 00:08:51,420
problem is hard well setup is quite

182
00:08:51,420 --> 00:08:53,160
simple we just start with the group

183
00:08:53,160 --> 00:08:54,660
action and we pick an initial set

184
00:08:54,660 --> 00:08:57,360
element and Alice and Bob run a

185
00:08:57,360 --> 00:08:58,800
symmetric protocol where they each

186
00:08:58,800 --> 00:09:01,200
sample a secret group element they

187
00:09:01,200 --> 00:09:02,820
compute the action of the initial set

188
00:09:02,820 --> 00:09:04,100
element

189
00:09:04,100 --> 00:09:07,380
with their group element they send that

190
00:09:07,380 --> 00:09:09,300
to the other party and then they can

191
00:09:09,300 --> 00:09:11,459
generate a shared key using their own

192
00:09:11,459 --> 00:09:14,100
secret group element correctness holds

193
00:09:14,100 --> 00:09:15,660
by the properties of the group action

194
00:09:15,660 --> 00:09:17,580
and the hardness just follows almost

195
00:09:17,580 --> 00:09:20,040
immediately from group action CDH

196
00:09:20,040 --> 00:09:21,360
so

197
00:09:21,360 --> 00:09:23,700
you might be asking why should we study

198
00:09:23,700 --> 00:09:26,459
group actions well almost all of our

199
00:09:26,459 --> 00:09:28,200
post Quantum crypto systems are based on

200
00:09:28,200 --> 00:09:31,500
lattices and what if in advance in Lata

201
00:09:31,500 --> 00:09:34,080
script analysis say you know renders

202
00:09:34,080 --> 00:09:35,279
these schemes much more efficient

203
00:09:35,279 --> 00:09:38,880
because we have to use larger parameters

204
00:09:38,880 --> 00:09:42,120
as nist suggests in their

205
00:09:42,120 --> 00:09:44,459
updated call for post Quantum digital

206
00:09:44,459 --> 00:09:46,680
signatures we don't want to put all of

207
00:09:46,680 --> 00:09:49,560
our post Quantum eggs in one basket

208
00:09:49,560 --> 00:09:51,779
and it turns out a billion group action

209
00:09:51,779 --> 00:09:53,760
based key exchange protocols like those

210
00:09:53,760 --> 00:09:55,860
for misogynies are some of the most

211
00:09:55,860 --> 00:09:57,800
promising alternatives

212
00:09:57,800 --> 00:10:00,600
uh but these constructions are very new

213
00:10:00,600 --> 00:10:02,580
and the security is not super well

214
00:10:02,580 --> 00:10:04,800
understood and this has led to some

215
00:10:04,800 --> 00:10:07,260
surprising results like the excellent

216
00:10:07,260 --> 00:10:10,620
work done on attacking sidh recently so

217
00:10:10,620 --> 00:10:13,019
what can we do you know we're looking

218
00:10:13,019 --> 00:10:15,480
for ways that we can establish

219
00:10:15,480 --> 00:10:17,940
confidence in group actions

220
00:10:17,940 --> 00:10:20,160
that's sort of the point of our work our

221
00:10:20,160 --> 00:10:22,140
main result is that we show the group

222
00:10:22,140 --> 00:10:24,600
action CDH and discrete log problem are

223
00:10:24,600 --> 00:10:27,060
quantum polynomial time equivalent for a

224
00:10:27,060 --> 00:10:29,519
billion group actions and this is nice

225
00:10:29,519 --> 00:10:32,339
because key exchange requires CDH

226
00:10:32,339 --> 00:10:35,339
hardness but the security analysis is

227
00:10:35,339 --> 00:10:37,320
much easier and the security problems

228
00:10:37,320 --> 00:10:39,360
generally are much easier to state for

229
00:10:39,360 --> 00:10:41,040
discrete logs so this gives us sort of a

230
00:10:41,040 --> 00:10:44,279
Best of Both Worlds thing uh and we sort

231
00:10:44,279 --> 00:10:47,279
of solve this uh folklore problem stated

232
00:10:47,279 --> 00:10:48,839
by Renee and Lipton about the

233
00:10:48,839 --> 00:10:50,880
diffie-hellman protocol being equivalent

234
00:10:50,880 --> 00:10:53,220
to discrete log although we obviously

235
00:10:53,220 --> 00:10:56,940
only solve it for the quantum case and

236
00:10:56,940 --> 00:10:59,040
the much more famous and hard and

237
00:10:59,040 --> 00:11:01,019
interesting classical case is still wide

238
00:11:01,019 --> 00:11:01,860
open

239
00:11:01,860 --> 00:11:03,660
so why does this matter

240
00:11:03,660 --> 00:11:05,399
well you can probably guess what I'm

241
00:11:05,399 --> 00:11:08,220
going to say here but it's good to have

242
00:11:08,220 --> 00:11:09,779
confidence in existing group action

243
00:11:09,779 --> 00:11:12,420
protocols and simplify what's sort of

244
00:11:12,420 --> 00:11:14,339
needed for these big attacks

245
00:11:14,339 --> 00:11:16,980
and for theoretical security now we only

246
00:11:16,980 --> 00:11:18,660
need to focus on the discrete law

247
00:11:18,660 --> 00:11:21,240
problem not the CDH problem

248
00:11:21,240 --> 00:11:22,860
this also makes building new group

249
00:11:22,860 --> 00:11:24,600
action-based key exchange protocols

250
00:11:24,600 --> 00:11:26,940
easier because if you want to build a

251
00:11:26,940 --> 00:11:29,160
new group action based key exchange you

252
00:11:29,160 --> 00:11:30,420
really only need to focus on the

253
00:11:30,420 --> 00:11:33,000
hardness of the discrete log problem not

254
00:11:33,000 --> 00:11:36,180
the more complicated CDH problem and

255
00:11:36,180 --> 00:11:37,560
this has sort of already been used for

256
00:11:37,560 --> 00:11:40,019
some new constructions and finally you

257
00:11:40,019 --> 00:11:41,279
know I think it's just good to

258
00:11:41,279 --> 00:11:42,779
understand group action since they're so

259
00:11:42,779 --> 00:11:45,300
ubiquitousyncratography

260
00:11:45,300 --> 00:11:48,720
so some other results we have we show

261
00:11:48,720 --> 00:11:52,380
that generically uh group action ddh and

262
00:11:52,380 --> 00:11:56,220
CDH are not equivalent uh we construct a

263
00:11:56,220 --> 00:11:58,320
very basic generic group action model

264
00:11:58,320 --> 00:12:00,779
that we use in some of our other results

265
00:12:00,779 --> 00:12:03,000
we conjecture that the dihedral hidden

266
00:12:03,000 --> 00:12:04,560
subgroup problem is equivalent to

267
00:12:04,560 --> 00:12:06,180
discrete log on a generic group action

268
00:12:06,180 --> 00:12:08,100
we show a very little bit of evidence

269
00:12:08,100 --> 00:12:09,600
suggesting this

270
00:12:09,600 --> 00:12:11,339
uh and then we have a bunch of results

271
00:12:11,339 --> 00:12:13,200
on what's called restricted effective

272
00:12:13,200 --> 00:12:15,360
group actions and these are sort of used

273
00:12:15,360 --> 00:12:17,579
to model Seaside classically so

274
00:12:17,579 --> 00:12:20,100
informally speaking auriga is a group

275
00:12:20,100 --> 00:12:22,079
action where the action can only be

276
00:12:22,079 --> 00:12:24,779
computed on a fixed set of generators

277
00:12:24,779 --> 00:12:28,200
and we defined this uh problem that we

278
00:12:28,200 --> 00:12:31,440
call Riga CIS here and we show that if

279
00:12:31,440 --> 00:12:33,300
you can solve this problem then our

280
00:12:33,300 --> 00:12:35,700
reduction goes through but we also show

281
00:12:35,700 --> 00:12:37,079
a bunch of other connections between

282
00:12:37,079 --> 00:12:39,839
this problem and and rigas like if you

283
00:12:39,839 --> 00:12:42,540
can solve discrete log on rigas then you

284
00:12:42,540 --> 00:12:44,639
can solve this this kind of lattice

285
00:12:44,639 --> 00:12:46,100
problem in Disguise

286
00:12:46,100 --> 00:12:48,360
so we have a bunch of results on this

287
00:12:48,360 --> 00:12:49,980
but you know there's there's a lot of

288
00:12:49,980 --> 00:12:51,540
work left to be done to fully understand

289
00:12:51,540 --> 00:12:53,220
this connection

290
00:12:53,220 --> 00:12:55,260
so with that in mind

291
00:12:55,260 --> 00:12:57,420
let's go over some of the core

292
00:12:57,420 --> 00:12:59,339
techniques of our main reduction

293
00:12:59,339 --> 00:13:02,279
the starting point of our work is an

294
00:13:02,279 --> 00:13:04,920
ePrint note from Galbraith Penny Smith

295
00:13:04,920 --> 00:13:06,839
and verkaterin that essentially

296
00:13:06,839 --> 00:13:09,720
encapsulates the following idea suppose

297
00:13:09,720 --> 00:13:11,880
we have an abelian group action and we

298
00:13:11,880 --> 00:13:14,820
Define a CDH function relative to a base

299
00:13:14,820 --> 00:13:17,040
set of element X that just does exactly

300
00:13:17,040 --> 00:13:19,079
what you think it does it just outputs

301
00:13:19,079 --> 00:13:21,540
the CDH of two elements

302
00:13:21,540 --> 00:13:24,240
now suppose we had a perfect adversary

303
00:13:24,240 --> 00:13:26,940
for this CDH problem well

304
00:13:26,940 --> 00:13:29,040
the observation is that this adversary

305
00:13:29,040 --> 00:13:31,260
induces a group operation on the set X

306
00:13:31,260 --> 00:13:33,959
so that the Tuple of X and the adversary

307
00:13:33,959 --> 00:13:36,660
forms an obelian Group H and this is not

308
00:13:36,660 --> 00:13:38,519
too difficult to verify you know the

309
00:13:38,519 --> 00:13:40,380
elements of H are just the elements of x

310
00:13:40,380 --> 00:13:42,300
uh the group operation is the

311
00:13:42,300 --> 00:13:44,519
adversary's computation the identity

312
00:13:44,519 --> 00:13:46,620
element is the base set element

313
00:13:46,620 --> 00:13:49,860
inverses exist you can see that the the

314
00:13:49,860 --> 00:13:51,240
group would be a billion if the group

315
00:13:51,240 --> 00:13:53,220
action is a billion enclosure and

316
00:13:53,220 --> 00:13:54,480
associativity are also pretty

317
00:13:54,480 --> 00:13:56,000
straightforward

318
00:13:56,000 --> 00:14:00,480
it's also the case that if G is zp then

319
00:14:00,480 --> 00:14:03,000
discrete log is well defined over H you

320
00:14:03,000 --> 00:14:04,560
can sort of have a nice notion of

321
00:14:04,560 --> 00:14:07,079
exponentiation I just put up a couple of

322
00:14:07,079 --> 00:14:09,720
of examples why that you know might be

323
00:14:09,720 --> 00:14:12,420
visible there and we can assume this

324
00:14:12,420 --> 00:14:14,160
remember since we can compute this

325
00:14:14,160 --> 00:14:16,560
mapping for any ability in group G if we

326
00:14:16,560 --> 00:14:18,320
have a quantum computer

327
00:14:18,320 --> 00:14:22,139
so the core idea of GPS v18 is to

328
00:14:22,139 --> 00:14:23,940
consider this a induced a Building Group

329
00:14:23,940 --> 00:14:26,399
H and notice that a group action

330
00:14:26,399 --> 00:14:28,320
discrete log Challenge on the abelian

331
00:14:28,320 --> 00:14:30,480
group action is just a regular discrete

332
00:14:30,480 --> 00:14:33,300
log Challenge on this induced Group H

333
00:14:33,300 --> 00:14:35,100
and then we can just apply Shore's

334
00:14:35,100 --> 00:14:37,620
algorithm and solve for G

335
00:14:37,620 --> 00:14:40,500
the problem for this is that we need a

336
00:14:40,500 --> 00:14:42,839
very low error rate on our CDH adversary

337
00:14:42,839 --> 00:14:45,120
a for Shore's Albert to work so it could

338
00:14:45,120 --> 00:14:48,180
be possible that group action CDH was

339
00:14:48,180 --> 00:14:50,399
broken with probability 0.9 which would

340
00:14:50,399 --> 00:14:52,800
effectively break key exchange but the

341
00:14:52,800 --> 00:14:55,139
discrete log variant was still hard and

342
00:14:55,139 --> 00:14:57,240
so this problem was left open uh for

343
00:14:57,240 --> 00:14:59,220
non-perfect adversaries

344
00:14:59,220 --> 00:15:02,040
so the core approach of this work is to

345
00:15:02,040 --> 00:15:04,500
take a CDH adversary with non-negligible

346
00:15:04,500 --> 00:15:07,079
advantage and amplify it to essentially

347
00:15:07,079 --> 00:15:09,060
arbitrary advantage and then we can

348
00:15:09,060 --> 00:15:11,399
follow the roadmap suggested by GPS v18

349
00:15:11,399 --> 00:15:13,980
and complete the reduction

350
00:15:13,980 --> 00:15:16,139
to show how this works I'm going to

351
00:15:16,139 --> 00:15:18,180
start by explaining a method that

352
00:15:18,180 --> 00:15:19,920
doesn't work and one that you're all

353
00:15:19,920 --> 00:15:22,880
probably familiar with which is classic

354
00:15:22,880 --> 00:15:26,940
group based CDH amplification so you all

355
00:15:26,940 --> 00:15:28,320
have probably seen this in your

356
00:15:28,320 --> 00:15:31,199
introductory cryptography class many of

357
00:15:31,199 --> 00:15:33,139
you have probably taught this reduction

358
00:15:33,139 --> 00:15:36,120
but you know suppose we consider

359
00:15:36,120 --> 00:15:39,120
an adversary that on input G to the a g

360
00:15:39,120 --> 00:15:42,000
to the B outputs the correct CDH Tuple

361
00:15:42,000 --> 00:15:44,579
which is g to the a b with probability p

362
00:15:44,579 --> 00:15:47,579
and g to the UAB with probability one

363
00:15:47,579 --> 00:15:50,100
minus B for some element U now this is a

364
00:15:50,100 --> 00:15:51,660
simple adversary and it's a pretty good

365
00:15:51,660 --> 00:15:52,800
adversary

366
00:15:52,800 --> 00:15:56,760
but we'll it'll be useful to examine

367
00:15:56,760 --> 00:15:59,579
so obviously given a challenge instance

368
00:15:59,579 --> 00:16:01,199
we can re-randomize it right we can

369
00:16:01,199 --> 00:16:03,120
sample random integers we can multiply

370
00:16:03,120 --> 00:16:05,040
in random group elements

371
00:16:05,040 --> 00:16:07,620
uh you know we can call the adversary on

372
00:16:07,620 --> 00:16:11,279
these randomized terms sorry this is uh

373
00:16:11,279 --> 00:16:13,980
running over we can cancel out the

374
00:16:13,980 --> 00:16:16,980
re-randomization terms and then we get

375
00:16:16,980 --> 00:16:20,699
you know these the randomized terms uh

376
00:16:20,699 --> 00:16:22,500
you know with probability P we get the

377
00:16:22,500 --> 00:16:23,820
right answer and with probability one

378
00:16:23,820 --> 00:16:25,800
minus P we get something else

379
00:16:25,800 --> 00:16:28,500
and the key point is with probability P

380
00:16:28,500 --> 00:16:30,540
we get something fixed and with

381
00:16:30,540 --> 00:16:32,220
probability one minus P we get something

382
00:16:32,220 --> 00:16:34,380
that's uniformly random in you

383
00:16:34,380 --> 00:16:36,720
and so we can leverage our adversary

384
00:16:36,720 --> 00:16:39,060
into an almost perfect adversary through

385
00:16:39,060 --> 00:16:41,639
repetition as only the correct answer is

386
00:16:41,639 --> 00:16:43,920
likely to be repeated in any polynomial

387
00:16:43,920 --> 00:16:45,420
number of Trials

388
00:16:45,420 --> 00:16:47,519
the problem is this doesn't work for

389
00:16:47,519 --> 00:16:49,980
group actions we critically use the fact

390
00:16:49,980 --> 00:16:51,600
that we could multiply group elements

391
00:16:51,600 --> 00:16:53,759
and there's no analogous operation for

392
00:16:53,759 --> 00:16:56,339
set elements so if we try to go through

393
00:16:56,339 --> 00:16:58,139
this process for group actions you know

394
00:16:58,139 --> 00:16:59,699
we have an adversary that does almost

395
00:16:59,699 --> 00:17:02,940
exactly the same thing as before uh a b

396
00:17:02,940 --> 00:17:05,339
star x with probability p and uib star x

397
00:17:05,339 --> 00:17:07,380
with probability one minus P we could

398
00:17:07,380 --> 00:17:08,760
try a similar approach we could

399
00:17:08,760 --> 00:17:12,079
re-randomize you know call the adversary

400
00:17:12,079 --> 00:17:14,459
de-randomized and then get output but

401
00:17:14,459 --> 00:17:16,020
the problem is we're getting the same

402
00:17:16,020 --> 00:17:17,579
output here and we really don't get

403
00:17:17,579 --> 00:17:19,980
anything from RE randomization so what

404
00:17:19,980 --> 00:17:22,500
can we do with this well in the previous

405
00:17:22,500 --> 00:17:24,839
example sort of the obvious thing to do

406
00:17:24,839 --> 00:17:26,939
is to say well if p is not equals not

407
00:17:26,939 --> 00:17:29,100
too close to one-half we can just sample

408
00:17:29,100 --> 00:17:30,540
enough times right

409
00:17:30,540 --> 00:17:32,520
and then we can apply some statistical

410
00:17:32,520 --> 00:17:34,440
bound but what if p is equal to a half

411
00:17:34,440 --> 00:17:35,760
what do we do

412
00:17:35,760 --> 00:17:37,799
and here I'm going to introduce just a

413
00:17:37,799 --> 00:17:39,720
little bit of extra notation I'm going

414
00:17:39,720 --> 00:17:41,460
to overload the CDH function and I'm

415
00:17:41,460 --> 00:17:43,679
going to Define an identity element

416
00:17:43,679 --> 00:17:46,200
the first idea is the following suppose

417
00:17:46,200 --> 00:17:49,200
we run our adversary and get both a b

418
00:17:49,200 --> 00:17:51,720
star X and UAB star X and if we run it

419
00:17:51,720 --> 00:17:53,280
enough times presumably we'll get them

420
00:17:53,280 --> 00:17:54,539
both right

421
00:17:54,539 --> 00:17:56,280
we can get them both but we don't know

422
00:17:56,280 --> 00:17:57,840
which one is right and which one is

423
00:17:57,840 --> 00:17:59,880
wrong so what if we feed these back into

424
00:17:59,880 --> 00:18:00,780
a

425
00:18:00,780 --> 00:18:03,120
so the key observation is the CDH

426
00:18:03,120 --> 00:18:05,400
function is sort of invariance over

427
00:18:05,400 --> 00:18:08,340
feeding at the identity right if I send

428
00:18:08,340 --> 00:18:10,440
you a CDH function in classical groups

429
00:18:10,440 --> 00:18:12,720
of like G and G to the B it should

430
00:18:12,720 --> 00:18:15,120
respond G to the B right so we can apply

431
00:18:15,120 --> 00:18:17,760
this adversation and use it to sort of

432
00:18:17,760 --> 00:18:21,059
catch the adversary cheating so in this

433
00:18:21,059 --> 00:18:23,039
case right if we feed these terms back

434
00:18:23,039 --> 00:18:26,880
into the adversary a on X and A B Star X

435
00:18:26,880 --> 00:18:29,940
will output a b star X and UAB star X

436
00:18:29,940 --> 00:18:33,900
whereas a on X and UAB star X will

437
00:18:33,900 --> 00:18:36,480
output UAB star X and U squared a b star

438
00:18:36,480 --> 00:18:39,539
X and note that the second set of

439
00:18:39,539 --> 00:18:41,520
outputs is different from the first one

440
00:18:41,520 --> 00:18:44,100
If U squared is the identity whereas the

441
00:18:44,100 --> 00:18:45,900
same the first set of outputs is the

442
00:18:45,900 --> 00:18:46,880
same

443
00:18:46,880 --> 00:18:49,919
and so if U squared is not equal to the

444
00:18:49,919 --> 00:18:51,720
identity this allows us to tell which

445
00:18:51,720 --> 00:18:53,400
output is correct with probability one

446
00:18:53,400 --> 00:18:56,039
and we can naturally extend this idea to

447
00:18:56,039 --> 00:18:57,900
other distributions as well

448
00:18:57,900 --> 00:19:00,960
so this sort of leads into a strategy we

449
00:19:00,960 --> 00:19:03,299
use in our proof that's called shift

450
00:19:03,299 --> 00:19:06,600
invariance and for this slide suppose G

451
00:19:06,600 --> 00:19:09,059
is a prime order cyclic and little G is

452
00:19:09,059 --> 00:19:11,059
a generator of this group

453
00:19:11,059 --> 00:19:14,340
we can I emphasize not efficiently even

454
00:19:14,340 --> 00:19:16,200
quantumly we can't efficiently compute

455
00:19:16,200 --> 00:19:18,539
this uh ordering but we can order set

456
00:19:18,539 --> 00:19:21,240
elements such that the ith element is G

457
00:19:21,240 --> 00:19:22,799
of the I star X

458
00:19:22,799 --> 00:19:25,140
uh and this gives us sort of a picture

459
00:19:25,140 --> 00:19:27,419
of Shifting where if we let a prime

460
00:19:27,419 --> 00:19:29,760
denote the distribution of a sort of you

461
00:19:29,760 --> 00:19:32,100
know run many times you can either think

462
00:19:32,100 --> 00:19:33,600
of an empirical or imaginary

463
00:19:33,600 --> 00:19:34,740
distribution

464
00:19:34,740 --> 00:19:38,220
uh then we sort of put a prime of X X on

465
00:19:38,220 --> 00:19:40,320
the top then a prime of w x on the

466
00:19:40,320 --> 00:19:43,320
bottom where W is just G squared x

467
00:19:43,320 --> 00:19:45,000
and you can see that this is just a

468
00:19:45,000 --> 00:19:48,059
shift so as I said we can't use this

469
00:19:48,059 --> 00:19:49,679
ordering without solving discrete log

470
00:19:49,679 --> 00:19:51,720
but it's useful to think of shifts this

471
00:19:51,720 --> 00:19:52,860
way

472
00:19:52,860 --> 00:19:55,020
and the point is we can check for

473
00:19:55,020 --> 00:19:56,340
equality and matches across

474
00:19:56,340 --> 00:19:58,559
distributions and sort of we can see

475
00:19:58,559 --> 00:20:00,840
that only distributions that shifts to

476
00:20:00,840 --> 00:20:02,820
themselves cannot be distinguished from

477
00:20:02,820 --> 00:20:04,980
correct and this is sort of the The Core

478
00:20:04,980 --> 00:20:07,880
Fact of our proof

479
00:20:08,100 --> 00:20:08,760
um

480
00:20:08,760 --> 00:20:12,000
but I left out one important case so

481
00:20:12,000 --> 00:20:13,500
what if U squared is equal to the

482
00:20:13,500 --> 00:20:14,400
identity

483
00:20:14,400 --> 00:20:16,380
so our approach from the previous slides

484
00:20:16,380 --> 00:20:18,120
will not work since the distributions

485
00:20:18,120 --> 00:20:19,280
will be equal

486
00:20:19,280 --> 00:20:22,320
however in this case we can observe that

487
00:20:22,320 --> 00:20:25,020
the adversary essentially acts as a

488
00:20:25,020 --> 00:20:27,480
perfect CDH algorithm on the subgroup

489
00:20:27,480 --> 00:20:30,360
induced by Gmod to elements generated by

490
00:20:30,360 --> 00:20:33,419
U and we can just directly apply the

491
00:20:33,419 --> 00:20:35,820
approach from GPS v18 to this and then

492
00:20:35,820 --> 00:20:37,380
just Brute Force

493
00:20:37,380 --> 00:20:40,440
and again this idea can work for more

494
00:20:40,440 --> 00:20:42,120
General subgroups as long as they're

495
00:20:42,120 --> 00:20:43,799
polynomial size

496
00:20:43,799 --> 00:20:46,500
and that's about it we show that there's

497
00:20:46,500 --> 00:20:48,720
always a polynomially sized subgroup H

498
00:20:48,720 --> 00:20:51,299
such that we can amplify an adversary to

499
00:20:51,299 --> 00:20:54,000
have near perfect success probability on

500
00:20:54,000 --> 00:20:57,000
GMod H uh UL can probably recreate the

501
00:20:57,000 --> 00:20:58,919
reduction from here there are a couple

502
00:20:58,919 --> 00:21:01,020
of tricky parts we could have super

503
00:21:01,020 --> 00:21:03,660
polynomially many possible subgroups if

504
00:21:03,660 --> 00:21:06,240
we're given a degenerative enough G so

505
00:21:06,240 --> 00:21:07,799
we have to explicitly compute the

506
00:21:07,799 --> 00:21:10,320
subgroup rather than guess it there are

507
00:21:10,320 --> 00:21:11,820
also some tricky points with respect to

508
00:21:11,820 --> 00:21:13,320
thresholdization

509
00:21:13,320 --> 00:21:16,320
but this is really more tedious than

510
00:21:16,320 --> 00:21:17,700
interesting

511
00:21:17,700 --> 00:21:20,520
uh I'll finally say that we assume a

512
00:21:20,520 --> 00:21:22,080
regular billion group action in our

513
00:21:22,080 --> 00:21:24,179
reduction but we can expand it to any

514
00:21:24,179 --> 00:21:26,039
billion group action without too much

515
00:21:26,039 --> 00:21:26,940
pain

516
00:21:26,940 --> 00:21:28,380
and if you're interested in that it's

517
00:21:28,380 --> 00:21:30,780
all in the paper

518
00:21:30,780 --> 00:21:32,760
that being said there's a lot of room

519
00:21:32,760 --> 00:21:34,260
for improvement so our reduction is

520
00:21:34,260 --> 00:21:36,659
almost Black Box except the dependency

521
00:21:36,659 --> 00:21:38,640
on Q which is the adversary success

522
00:21:38,640 --> 00:21:39,780
probability

523
00:21:39,780 --> 00:21:41,880
uh the running time is polynomial but

524
00:21:41,880 --> 00:21:44,880
it's it's pretty bad uh it's 1 over Q to

525
00:21:44,880 --> 00:21:47,760
the 13 where you know that that's not

526
00:21:47,760 --> 00:21:48,900
great

527
00:21:48,900 --> 00:21:49,559
um

528
00:21:49,559 --> 00:21:51,659
so it's useful for ruling out Quantum

529
00:21:51,659 --> 00:21:53,460
polynomial time attacks but not

530
00:21:53,460 --> 00:21:55,200
necessarily for setting practical

531
00:21:55,200 --> 00:21:57,720
security parameters uh for practical

532
00:21:57,720 --> 00:21:59,159
parameter setting you know you probably

533
00:21:59,159 --> 00:22:01,440
need one over poly login the number of

534
00:22:01,440 --> 00:22:03,419
queries and this might rule out our

535
00:22:03,419 --> 00:22:04,980
shifting technique but maybe there's a

536
00:22:04,980 --> 00:22:07,620
better technique uh and finally in the

537
00:22:07,620 --> 00:22:09,780
same vein it might be possible to do

538
00:22:09,780 --> 00:22:11,700
substantially better for fixed groups

539
00:22:11,700 --> 00:22:13,740
known in advance particularly ones that

540
00:22:13,740 --> 00:22:16,260
don't have too many subgroups a smart

541
00:22:16,260 --> 00:22:18,600
Asia Crypt reviewer pointed this out for

542
00:22:18,600 --> 00:22:20,400
scifish

543
00:22:20,400 --> 00:22:21,780
um and it might be possible to have very

544
00:22:21,780 --> 00:22:23,880
tight instantiations for things like SCI

545
00:22:23,880 --> 00:22:26,340
fish and we leave this totally open and

546
00:22:26,340 --> 00:22:28,740
finally uh we think our work on rigas

547
00:22:28,740 --> 00:22:30,299
and the dihedral hidden subgroup problem

548
00:22:30,299 --> 00:22:33,539
uh really just scratch the surface

549
00:22:33,539 --> 00:22:35,340
um so on that uh thanks a lot for your

550
00:22:35,340 --> 00:22:36,900
time and I'll be happy to answer any

551
00:22:36,900 --> 00:22:39,140
questions

552
00:22:47,120 --> 00:22:49,380
we have a couple of minutes for

553
00:22:49,380 --> 00:22:51,620
questions

554
00:22:51,780 --> 00:22:53,580
anybody

555
00:22:53,580 --> 00:22:55,500
all right then let's thank the speaker

556
00:22:55,500 --> 00:22:57,860
again

557
00:23:08,220 --> 00:23:11,880
our next talk is uh remote so let's just

558
00:23:11,880 --> 00:23:15,799
take a minute to set that up

559
00:23:21,780 --> 00:23:23,760
can they hear us

560
00:23:23,760 --> 00:23:26,059
foreign

561
00:23:26,059 --> 00:23:28,020
can you hear me

562
00:23:28,020 --> 00:23:30,299
yes shekhar

563
00:23:30,299 --> 00:23:32,880
yeah hi can you hear me yes yes we can

564
00:23:32,880 --> 00:23:36,000
hear you so uh our next talk uh is

565
00:23:36,000 --> 00:23:37,799
cryptographic Primitives with hinting

566
00:23:37,799 --> 00:23:40,799
property and uh this paper won the best

567
00:23:40,799 --> 00:23:44,039
paper uh by early career researchers

568
00:23:44,039 --> 00:23:48,840
it's by uh Shikhar Patra Nabis and uh

569
00:23:48,840 --> 00:23:51,840
and uh Navid alamati and shekhar will

570
00:23:51,840 --> 00:23:53,940
give the talk

571
00:23:53,940 --> 00:23:55,860
please go on

572
00:23:55,860 --> 00:23:58,380
thanks a lot and my apologies for not

573
00:23:58,380 --> 00:23:59,700
being able to give this talk in person

574
00:23:59,700 --> 00:24:02,159
so welcome to this virtual presentation

575
00:24:02,159 --> 00:24:04,080
on cryptographic Primitives with hinting

576
00:24:04,080 --> 00:24:08,059
property this is Joint work with nabit

577
00:24:08,460 --> 00:24:10,440
so we encounter hints frequently in

578
00:24:10,440 --> 00:24:11,940
daily life for example when we forget

579
00:24:11,940 --> 00:24:14,580
passwords and the hint allows us uh to

580
00:24:14,580 --> 00:24:15,840
guess the password without actually

581
00:24:15,840 --> 00:24:18,720
revealing the entire password itself

582
00:24:18,720 --> 00:24:21,240
but it turns out that hints are actually

583
00:24:21,240 --> 00:24:23,520
also useful not only in real life but

584
00:24:23,520 --> 00:24:25,860
also in cryptography and in the context

585
00:24:25,860 --> 00:24:29,159
of a widely used and fundamental

586
00:24:29,159 --> 00:24:30,840
cryptographic primitive called a

587
00:24:30,840 --> 00:24:32,880
pseudorandom generator that I believe we

588
00:24:32,880 --> 00:24:34,320
are all familiar with

589
00:24:34,320 --> 00:24:37,440
now in the traditional prg game a

590
00:24:37,440 --> 00:24:40,140
distinguisher on adversary is not given

591
00:24:40,140 --> 00:24:42,600
any additional information about the

592
00:24:42,600 --> 00:24:45,600
seed of the pseudo-random generator

593
00:24:45,600 --> 00:24:48,960
but in crypto 2019 popular and Waters

594
00:24:48,960 --> 00:24:51,900
introduced a variant of prg which is

595
00:24:51,900 --> 00:24:53,820
called a hinting prg and which is the

596
00:24:53,820 --> 00:24:55,500
fundamental motivation for this talk

597
00:24:55,500 --> 00:24:57,900
where the distinguisher is actually

598
00:24:57,900 --> 00:25:00,360
given some additional information or

599
00:25:00,360 --> 00:25:03,539
hint about the seat of the prg

600
00:25:03,539 --> 00:25:06,240
more formally speaking let's say that we

601
00:25:06,240 --> 00:25:08,820
have the output of the prg as a sequence

602
00:25:08,820 --> 00:25:12,780
of n strings each of length n Bits and

603
00:25:12,780 --> 00:25:15,120
we also have a sequence of n random

604
00:25:15,120 --> 00:25:18,360
strings of length n Bits and then we

605
00:25:18,360 --> 00:25:20,580
swap these two strings in certain

606
00:25:20,580 --> 00:25:23,520
positions depending on whether a bit of

607
00:25:23,520 --> 00:25:25,980
the seat is zero or one in particular we

608
00:25:25,980 --> 00:25:28,620
swap them if the bit is one and we don't

609
00:25:28,620 --> 00:25:30,960
swap them if the bit is zero

610
00:25:30,960 --> 00:25:33,419
so here's a toy example for n equals six

611
00:25:33,419 --> 00:25:37,559
uh so you can see that the Y and Z

612
00:25:37,559 --> 00:25:39,480
vectors are swapped in the locations

613
00:25:39,480 --> 00:25:42,120
where the seed s is one

614
00:25:42,120 --> 00:25:44,340
now informally speaking what the hinting

615
00:25:44,340 --> 00:25:46,980
PRT guarantees is that despite embedding

616
00:25:46,980 --> 00:25:49,260
information about each bit of the seat

617
00:25:49,260 --> 00:25:52,440
in this two cross n Matrix this Ensemble

618
00:25:52,440 --> 00:25:54,600
of strings actually remains pseudo

619
00:25:54,600 --> 00:25:56,640
random that is it is computationally

620
00:25:56,640 --> 00:25:58,919
indistinguishable from a two cross n

621
00:25:58,919 --> 00:26:01,919
Matrix of random and bit strings and

622
00:26:01,919 --> 00:26:04,559
more formally speaking this is what the

623
00:26:04,559 --> 00:26:07,080
hinting prg game looks like where we

624
00:26:07,080 --> 00:26:10,559
have a two cross n Matrix Z and its

625
00:26:10,559 --> 00:26:12,720
elements are either the output of the

626
00:26:12,720 --> 00:26:15,419
prg or uniformly random and they are

627
00:26:15,419 --> 00:26:18,120
swapped depending upon whether each bit

628
00:26:18,120 --> 00:26:20,460
of the seed is 0 or 1 and despite

629
00:26:20,460 --> 00:26:22,500
encoding these additional hints about

630
00:26:22,500 --> 00:26:26,940
the seat this Matrix Z remains you'd run

631
00:26:26,940 --> 00:26:29,580
now why are hitting prgs interesting in

632
00:26:29,580 --> 00:26:31,380
the seminal work popular and Waters show

633
00:26:31,380 --> 00:26:32,940
that it is actually a cryptographic

634
00:26:32,940 --> 00:26:34,620
booster where we are all familiar with

635
00:26:34,620 --> 00:26:36,779
boosters in this area of covet but

636
00:26:36,779 --> 00:26:38,820
hinting prg is a cryptographic booster

637
00:26:38,820 --> 00:26:40,860
in the sense that it can be used for a

638
00:26:40,860 --> 00:26:43,080
genetic transformation from CPA to CCA

639
00:26:43,080 --> 00:26:45,659
security for public key encryption and

640
00:26:45,659 --> 00:26:48,179
other Advanced forms of encryption and

641
00:26:48,179 --> 00:26:50,279
in more recent years hinting prgs have

642
00:26:50,279 --> 00:26:51,539
been used in a myriad of other

643
00:26:51,539 --> 00:26:53,580
cryptographic applications in particular

644
00:26:53,580 --> 00:26:55,440
for new constructions of advanced

645
00:26:55,440 --> 00:26:57,240
cryptographic Primitives this makes

646
00:26:57,240 --> 00:26:59,220
hinting prgs a very interesting class of

647
00:26:59,220 --> 00:27:01,620
Primitives to study

648
00:27:01,620 --> 00:27:03,659
another interesting feature of hinting

649
00:27:03,659 --> 00:27:05,520
property is that it Bears some

650
00:27:05,520 --> 00:27:07,440
similarities to another property that we

651
00:27:07,440 --> 00:27:09,000
are probably familiar with which is

652
00:27:09,000 --> 00:27:10,799
circular Security in the context of

653
00:27:10,799 --> 00:27:13,380
symmetric key encryption in fact one

654
00:27:13,380 --> 00:27:15,659
could view the hinting property as a

655
00:27:15,659 --> 00:27:17,460
deterministic form of circular security

656
00:27:17,460 --> 00:27:20,820
with respect to the bits of the prg

657
00:27:20,820 --> 00:27:22,559
however there are some fundamental

658
00:27:22,559 --> 00:27:24,720
differences between the two historically

659
00:27:24,720 --> 00:27:27,059
circular secure symmetric key encryption

660
00:27:27,059 --> 00:27:29,400
has been extensively studied and we know

661
00:27:29,400 --> 00:27:30,900
how to realize them via simple

662
00:27:30,900 --> 00:27:32,880
constructions and proof techniques from

663
00:27:32,880 --> 00:27:34,500
certain standard decisional assumptions

664
00:27:34,500 --> 00:27:36,600
and it is also known that they are

665
00:27:36,600 --> 00:27:37,980
weaker than public key encryption

666
00:27:37,980 --> 00:27:39,779
because they can be realized from random

667
00:27:39,779 --> 00:27:41,279
oracles and that hence Black Box

668
00:27:41,279 --> 00:27:44,100
separated from public key encryption on

669
00:27:44,100 --> 00:27:45,779
the other hand the known constructions

670
00:27:45,779 --> 00:27:47,880
and proof techniques for hinting prgs

671
00:27:47,880 --> 00:27:50,580
are rather complicated and deeply rooted

672
00:27:50,580 --> 00:27:52,260
in algebraic or public key style

673
00:27:52,260 --> 00:27:54,600
mathematical assumptions which naturally

674
00:27:54,600 --> 00:27:56,460
leads to the question of whether such

675
00:27:56,460 --> 00:27:58,020
kinds of public key techniques are

676
00:27:58,020 --> 00:28:00,539
inherent to hinting prgs or whether we

677
00:28:00,539 --> 00:28:02,460
can have simpler constructions and

678
00:28:02,460 --> 00:28:04,440
potentially non-algebraic constructions

679
00:28:04,440 --> 00:28:06,480
as well

680
00:28:06,480 --> 00:28:08,880
so here's the one slide summary of the

681
00:28:08,880 --> 00:28:10,860
current landscape of hinting prgs and

682
00:28:10,860 --> 00:28:13,320
how we know to realize them in practice

683
00:28:13,320 --> 00:28:16,380
and what they imply versus what we ask

684
00:28:16,380 --> 00:28:17,580
in this paper

685
00:28:17,580 --> 00:28:19,679
so to summarize we ask three main

686
00:28:19,679 --> 00:28:21,840
questions one can we have simpler

687
00:28:21,840 --> 00:28:24,600
constructions and proofs of hinting prgs

688
00:28:24,600 --> 00:28:26,760
and can we realize these constructions

689
00:28:26,760 --> 00:28:29,039
from a wider class of assumptions for

690
00:28:29,039 --> 00:28:30,900
example isogeny based assumptions that

691
00:28:30,900 --> 00:28:33,659
heart gave us an excellent introduction

692
00:28:33,659 --> 00:28:35,700
then we ask whether we can extend the

693
00:28:35,700 --> 00:28:37,740
hinting property to other symmetric key

694
00:28:37,740 --> 00:28:39,720
Primitives and if such extensions are

695
00:28:39,720 --> 00:28:41,460
useful and realizable

696
00:28:41,460 --> 00:28:43,919
and finally we ask what exactly is the

697
00:28:43,919 --> 00:28:46,200
cryptography complexity of hinting prgs

698
00:28:46,200 --> 00:28:48,720
and more concretely can we establish

699
00:28:48,720 --> 00:28:50,460
whether mathematically structured public

700
00:28:50,460 --> 00:28:52,080
key style assumptions are truly

701
00:28:52,080 --> 00:28:55,799
necessary to realize these Primitives

702
00:28:55,799 --> 00:28:58,320
in this paper we propose new extensions

703
00:28:58,320 --> 00:29:00,179
of the hinting property to another

704
00:29:00,179 --> 00:29:01,980
well-studied class of symmetric key

705
00:29:01,980 --> 00:29:03,720
functions calls you to random functions

706
00:29:03,720 --> 00:29:05,940
and also there are weak variants where

707
00:29:05,940 --> 00:29:08,279
pseudo Randomness is only guaranteed on

708
00:29:08,279 --> 00:29:11,159
uniformly sampled inputs we also provide

709
00:29:11,159 --> 00:29:12,960
new security definitions for these

710
00:29:12,960 --> 00:29:14,880
Primitives where informally speaking the

711
00:29:14,880 --> 00:29:16,860
pseudo Randomness guarantee holds in the

712
00:29:16,860 --> 00:29:18,779
presence of hints about the secret key

713
00:29:18,779 --> 00:29:21,539
but an important feature is that the

714
00:29:21,539 --> 00:29:23,940
security notion here is multi-evaluation

715
00:29:23,940 --> 00:29:25,860
in the sense that the pseudo Randomness

716
00:29:25,860 --> 00:29:27,360
currently holds over multiple

717
00:29:27,360 --> 00:29:29,940
evaluations of the prf over different

718
00:29:29,940 --> 00:29:32,460
inputs and this is in contrast to the

719
00:29:32,460 --> 00:29:34,380
security definition for hinting prg

720
00:29:34,380 --> 00:29:36,059
which is kind of one shot in the sense

721
00:29:36,059 --> 00:29:37,980
that you only get to see the evaluation

722
00:29:37,980 --> 00:29:39,600
on a single seat

723
00:29:39,600 --> 00:29:42,480
so a hinting prf implies a hinting vprf

724
00:29:42,480 --> 00:29:44,460
which in turn implies a hinting prg all

725
00:29:44,460 --> 00:29:47,279
of these in a black box map

726
00:29:47,279 --> 00:29:49,500
next we show new stronger implications

727
00:29:49,500 --> 00:29:51,480
of the hinting property when extended to

728
00:29:51,480 --> 00:29:53,640
weak prfs in particular we show that a

729
00:29:53,640 --> 00:29:55,919
hinting weak prf implies a full-fledged

730
00:29:55,919 --> 00:29:58,260
circular secure symmetric key encryption

731
00:29:58,260 --> 00:30:00,840
scheme in a black box manner this is in

732
00:30:00,840 --> 00:30:02,820
contrast to a hinting prg which only

733
00:30:02,820 --> 00:30:04,919
implies a weak notion or a one-time

734
00:30:04,919 --> 00:30:06,899
notion of circular secure symmetric key

735
00:30:06,899 --> 00:30:09,260
encryption

736
00:30:09,419 --> 00:30:11,760
next we show this is the major

737
00:30:11,760 --> 00:30:13,919
contribution of this paper we show a new

738
00:30:13,919 --> 00:30:16,380
framework for Designing hinting weak

739
00:30:16,380 --> 00:30:19,500
prfs and by extension hinting prgs and

740
00:30:19,500 --> 00:30:21,000
our framework gives significantly

741
00:30:21,000 --> 00:30:23,100
simpler constructions and proofs as

742
00:30:23,100 --> 00:30:24,779
compared to the previous approaches like

743
00:30:24,779 --> 00:30:26,399
the missing blocks framework and the

744
00:30:26,399 --> 00:30:28,020
accumulation frame

745
00:30:28,020 --> 00:30:29,940
and the corality of this simple

746
00:30:29,940 --> 00:30:31,679
instantiation is that we can actually

747
00:30:31,679 --> 00:30:34,320
extend this to other assumptions such as

748
00:30:34,320 --> 00:30:36,360
isogeny based group actions which we

749
00:30:36,360 --> 00:30:38,880
already heard about

750
00:30:38,880 --> 00:30:41,220
finally we have an impossibility result

751
00:30:41,220 --> 00:30:43,500
where we show that

752
00:30:43,500 --> 00:30:45,600
hinting prfs and in particular this

753
00:30:45,600 --> 00:30:47,340
whole ensemble of cryptographic

754
00:30:47,340 --> 00:30:49,320
Primitives with hinting property is

755
00:30:49,320 --> 00:30:51,299
actually Black Box separated from public

756
00:30:51,299 --> 00:30:53,399
key encryption and so public key style

757
00:30:53,399 --> 00:30:54,960
assumptions are actually not necessary

758
00:30:54,960 --> 00:30:57,539
to realize and we show this by showing a

759
00:30:57,539 --> 00:30:59,399
non-algebraic construction of a heating

760
00:30:59,399 --> 00:31:03,860
prf given just a simple random order

761
00:31:03,899 --> 00:31:05,520
we also have some additional

762
00:31:05,520 --> 00:31:07,260
contributions wherein we show new

763
00:31:07,260 --> 00:31:08,940
strengthenings of the hinting property

764
00:31:08,940 --> 00:31:10,799
to what we call a functional heating

765
00:31:10,799 --> 00:31:13,200
property where the adversary is now

766
00:31:13,200 --> 00:31:15,360
given hints about each bit of some

767
00:31:15,360 --> 00:31:17,460
function of the sheet and this function

768
00:31:17,460 --> 00:31:19,320
can actually be chosen adversarially

769
00:31:19,320 --> 00:31:21,419
from a fixed function family

770
00:31:21,419 --> 00:31:23,820
so here's an example suppose we have an

771
00:31:23,820 --> 00:31:26,460
in which seat for a hinting prg and a

772
00:31:26,460 --> 00:31:28,380
functional hinting property for example

773
00:31:28,380 --> 00:31:30,240
allows the adversary to get information

774
00:31:30,240 --> 00:31:33,299
not only about s but also about each bit

775
00:31:33,299 --> 00:31:35,279
of this particular quadratic function of

776
00:31:35,279 --> 00:31:36,059
this

777
00:31:36,059 --> 00:31:37,260
right

778
00:31:37,260 --> 00:31:39,779
and we then show that the functional

779
00:31:39,779 --> 00:31:41,760
hinting property can have even stronger

780
00:31:41,760 --> 00:31:43,919
implications in particular we show that

781
00:31:43,919 --> 00:31:46,080
a functional hinting prf with respect to

782
00:31:46,080 --> 00:31:48,480
some function family F implies in a

783
00:31:48,480 --> 00:31:50,640
black box manner a KDM secure

784
00:31:50,640 --> 00:31:52,140
symmetricity encryption scheme with

785
00:31:52,140 --> 00:31:54,480
respect to the same function file recall

786
00:31:54,480 --> 00:31:56,460
that in the normal hinting with prf case

787
00:31:56,460 --> 00:31:58,500
we only got a black box construction of

788
00:31:58,500 --> 00:32:00,240
circular secure symmetricity encryption

789
00:32:00,240 --> 00:32:02,039
and the amplification to cadmium

790
00:32:02,039 --> 00:32:04,679
security was non-blackbox however the

791
00:32:04,679 --> 00:32:06,419
functional hinting property now gives us

792
00:32:06,419 --> 00:32:08,520
a new approach for achieving KDM secure

793
00:32:08,520 --> 00:32:10,140
symmetric key encryption in a black box

794
00:32:10,140 --> 00:32:12,179
manner with respect to Boolean function

795
00:32:12,179 --> 00:32:13,380
factors

796
00:32:13,380 --> 00:32:15,779
finally we also show that these kinds of

797
00:32:15,779 --> 00:32:17,640
functional hinting Primitives can

798
00:32:17,640 --> 00:32:19,260
actually be realized from certain

799
00:32:19,260 --> 00:32:21,539
standard assumptions in particular we

800
00:32:21,539 --> 00:32:23,279
build Upon Our construction of hinting

801
00:32:23,279 --> 00:32:26,340
with prf and hinting prgs from dth to

802
00:32:26,340 --> 00:32:27,600
show a construction of functional

803
00:32:27,600 --> 00:32:29,520
hinting weak prf and by extension

804
00:32:29,520 --> 00:32:32,220
functional hinting prg with respect to

805
00:32:32,220 --> 00:32:33,539
functional families containing

806
00:32:33,539 --> 00:32:35,580
projective quadratic functions and

807
00:32:35,580 --> 00:32:37,980
functions of higher degree over the bits

808
00:32:37,980 --> 00:32:40,080
of the secret key or the secret seed in

809
00:32:40,080 --> 00:32:41,940
case of the PFG

810
00:32:41,940 --> 00:32:44,279
so this is kind of a one slide summary

811
00:32:44,279 --> 00:32:47,840
of our contributions

812
00:32:48,600 --> 00:32:50,580
so here's an outline for the rest of the

813
00:32:50,580 --> 00:32:52,440
talk I'll spend the next few slides

814
00:32:52,440 --> 00:32:54,360
trying to outline how do we construct a

815
00:32:54,360 --> 00:32:56,159
simple hinting prg from the ddh

816
00:32:56,159 --> 00:32:58,500
Assumption I will then give a brief

817
00:32:58,500 --> 00:33:00,360
overview of how we extend the same

818
00:33:00,360 --> 00:33:02,159
techniques to build a hinting prg from

819
00:33:02,159 --> 00:33:04,140
cryptography group actions and I will

820
00:33:04,140 --> 00:33:06,120
give a very very brief introduction to

821
00:33:06,120 --> 00:33:08,340
hinting weekly ads and finally I will

822
00:33:08,340 --> 00:33:09,899
end with summary and some open questions

823
00:33:09,899 --> 00:33:13,520
and future directions of research

824
00:33:13,919 --> 00:33:17,519
right so the simple hinting prg from ddh

825
00:33:17,519 --> 00:33:19,500
is in fact incredibly simple I think

826
00:33:19,500 --> 00:33:21,120
that many of you are probably familiar

827
00:33:21,120 --> 00:33:23,220
with this construction it is a very very

828
00:33:23,220 --> 00:33:24,840
simple construction that literally

829
00:33:24,840 --> 00:33:27,059
consists of a matrix Vector

830
00:33:27,059 --> 00:33:29,220
multiplication in the exponent of the

831
00:33:29,220 --> 00:33:31,200
group element where the Matrix is a

832
00:33:31,200 --> 00:33:33,840
uniformly random Matrix of square

833
00:33:33,840 --> 00:33:36,960
dimensions and the vector is

834
00:33:36,960 --> 00:33:40,080
a binary Vector okay so remember that in

835
00:33:40,080 --> 00:33:41,820
the definition of hinting TRG the seed

836
00:33:41,820 --> 00:33:43,320
is typically considered a sequence of

837
00:33:43,320 --> 00:33:45,480
bits and we do the same

838
00:33:45,480 --> 00:33:47,640
now it has been implicitly or explicitly

839
00:33:47,640 --> 00:33:49,860
proved in a number of previous works

840
00:33:49,860 --> 00:33:51,899
that if we assume that the group G is

841
00:33:51,899 --> 00:33:54,360
dth hert then this particular function

842
00:33:54,360 --> 00:33:57,539
is in fact a prg and a hint is that the

843
00:33:57,539 --> 00:33:59,820
proof of security requires applying the

844
00:33:59,820 --> 00:34:02,340
leftover hashler

845
00:34:02,340 --> 00:34:04,740
now what we claim in this paper is that

846
00:34:04,740 --> 00:34:07,260
this prg this very very simple prg from

847
00:34:07,260 --> 00:34:09,659
dth in fact already has the hinting

848
00:34:09,659 --> 00:34:10,859
property

849
00:34:10,859 --> 00:34:13,320
and the way we prove that is that we

850
00:34:13,320 --> 00:34:15,719
reduce the hinting property of this prg

851
00:34:15,719 --> 00:34:17,879
to its fundamental pseudo Randomness

852
00:34:17,879 --> 00:34:20,040
characters

853
00:34:20,040 --> 00:34:22,379
so I'll try to briefly outline what our

854
00:34:22,379 --> 00:34:24,480
proof looks like our proof basically is

855
00:34:24,480 --> 00:34:26,760
a reduction that takes as input the

856
00:34:26,760 --> 00:34:29,219
public parameter M for this particular

857
00:34:29,219 --> 00:34:32,219
prg along with a sequence of n group

858
00:34:32,219 --> 00:34:34,440
elements which is the output of this prg

859
00:34:34,440 --> 00:34:36,359
or it's a uniformly random sequence of

860
00:34:36,359 --> 00:34:37,560
group elements

861
00:34:37,560 --> 00:34:40,739
and what this reduction outputs is a

862
00:34:40,739 --> 00:34:42,599
public parameter for the hinting prg

863
00:34:42,599 --> 00:34:43,560
which by the way is the same

864
00:34:43,560 --> 00:34:45,359
construction so it basically outputs a

865
00:34:45,359 --> 00:34:46,918
different public parameter from the same

866
00:34:46,918 --> 00:34:49,080
distribution and then it outputs this

867
00:34:49,080 --> 00:34:50,940
two cross n Matrix which if you recall

868
00:34:50,940 --> 00:34:52,800
is the output of the hinting prg game

869
00:34:52,800 --> 00:34:55,679
and this is either distributed as in the

870
00:34:55,679 --> 00:34:57,540
real hinting prg game which means that

871
00:34:57,540 --> 00:35:00,420
you know it is it is the interest pass

872
00:35:00,420 --> 00:35:03,599
of the real prg output and a uniformly

873
00:35:03,599 --> 00:35:05,580
random sequence of group elements where

874
00:35:05,580 --> 00:35:07,200
the positioning is done based on the

875
00:35:07,200 --> 00:35:09,839
seat or it's a uniformly random sequence

876
00:35:09,839 --> 00:35:12,240
and the main challenge here is that our

877
00:35:12,240 --> 00:35:14,160
deduction actually does not have any

878
00:35:14,160 --> 00:35:16,800
idea about the seat of the original prg

879
00:35:16,800 --> 00:35:19,079
because it only gets uh this public

880
00:35:19,079 --> 00:35:20,940
parameter and the output which is not

881
00:35:20,940 --> 00:35:22,500
supposed to reveal any information about

882
00:35:22,500 --> 00:35:25,560
the seat if the original prjcq and

883
00:35:25,560 --> 00:35:27,359
despite that we want what we want to do

884
00:35:27,359 --> 00:35:29,880
is that we want to ensure that when the

885
00:35:29,880 --> 00:35:32,160
input on the left is distributed as in a

886
00:35:32,160 --> 00:35:34,560
real prg game we want the output on the

887
00:35:34,560 --> 00:35:36,240
right to be distributed as in the real

888
00:35:36,240 --> 00:35:38,339
hinting prg game which means it needs to

889
00:35:38,339 --> 00:35:40,380
embed some information about the seed

890
00:35:40,380 --> 00:35:42,720
and the cracks of our proof is how we do

891
00:35:42,720 --> 00:35:44,220
this without knowing the seed in the

892
00:35:44,220 --> 00:35:46,140
first place okay

893
00:35:46,140 --> 00:35:48,960
and of course we also want random to map

894
00:35:48,960 --> 00:35:51,900
to random and this is in a nutshell what

895
00:35:51,900 --> 00:35:54,180
a reduction looks like it looks quite

896
00:35:54,180 --> 00:35:57,060
simple so what we do is we basically

897
00:35:57,060 --> 00:36:00,119
output the same public parameter except

898
00:36:00,119 --> 00:36:02,940
that we shift The Matrix in the diagonal

899
00:36:02,940 --> 00:36:05,940
by some uniformly random shift elements

900
00:36:05,940 --> 00:36:08,520
and then in the output sequence we

901
00:36:08,520 --> 00:36:10,619
basically set everything on the top row

902
00:36:10,619 --> 00:36:12,900
to be directly equal to the input from

903
00:36:12,900 --> 00:36:16,680
the prg gain and we shift the elements

904
00:36:16,680 --> 00:36:18,780
in the bottom row by these uniformly

905
00:36:18,780 --> 00:36:21,119
random shifts okay so in other words z i

906
00:36:21,119 --> 00:36:24,420
zero is equal to y i and Z i1 is equal

907
00:36:24,420 --> 00:36:26,460
to y i plus d i

908
00:36:26,460 --> 00:36:27,720
now this is a simple looking

909
00:36:27,720 --> 00:36:30,060
transformation but the interesting fact

910
00:36:30,060 --> 00:36:32,099
is that this implicitly allows us to

911
00:36:32,099 --> 00:36:34,200
embed information about the seed in the

912
00:36:34,200 --> 00:36:36,599
sequence on the right why well let's see

913
00:36:36,599 --> 00:36:38,700
that suppose that the Y i's are actually

914
00:36:38,700 --> 00:36:41,880
distributed as in the real prg game and

915
00:36:41,880 --> 00:36:43,859
uh you know the zi's are constructed as

916
00:36:43,859 --> 00:36:47,400
we said it turns out that you know if

917
00:36:47,400 --> 00:36:50,160
the bit s i is 0 then it is easy to

918
00:36:50,160 --> 00:36:52,020
prove that z i zero is actually

919
00:36:52,020 --> 00:36:54,300
distributed as it should be in the real

920
00:36:54,300 --> 00:36:56,640
hinting prg gains this is because the

921
00:36:56,640 --> 00:36:59,099
diagonal because when s i is 0 there is

922
00:36:59,099 --> 00:37:02,579
no contribution from uh you know the ith

923
00:37:02,579 --> 00:37:06,180
row of the Matrix into ZL and so since

924
00:37:06,180 --> 00:37:09,060
it only differs in the diagonal element

925
00:37:09,060 --> 00:37:11,099
for which the contribution is zero so z

926
00:37:11,099 --> 00:37:13,740
i zero is actually well distributed on

927
00:37:13,740 --> 00:37:15,900
the other hand CI 1 is randomly shifted

928
00:37:15,900 --> 00:37:19,079
and so it is distributed uniformly and

929
00:37:19,079 --> 00:37:22,020
similarly when s i is 1 we can argue

930
00:37:22,020 --> 00:37:24,359
that z i 1 is now actually distributed

931
00:37:24,359 --> 00:37:26,700
as the inner product of the ith row of

932
00:37:26,700 --> 00:37:29,820
the Matrix and the seed and z i zero is

933
00:37:29,820 --> 00:37:33,180
distributed uniformly diagram okay so in

934
00:37:33,180 --> 00:37:34,859
some sense we embed information about

935
00:37:34,859 --> 00:37:37,440
the seat into these elements uh without

936
00:37:37,440 --> 00:37:38,880
knowing the seed at all in the first

937
00:37:38,880 --> 00:37:41,700
place and of course it's uh and so you

938
00:37:41,700 --> 00:37:43,140
know we achieve this goal that when the

939
00:37:43,140 --> 00:37:45,180
wires are distributed as in the real prg

940
00:37:45,180 --> 00:37:47,460
games the zi's are distributed as in the

941
00:37:47,460 --> 00:37:49,560
real hinting prgk

942
00:37:49,560 --> 00:37:52,260
and of course it's easy to see that when

943
00:37:52,260 --> 00:37:54,000
the wires are distributed uniformly

944
00:37:54,000 --> 00:37:56,700
randomly then so are the zis and so you

945
00:37:56,700 --> 00:37:58,380
know when the input is random the output

946
00:37:58,380 --> 00:38:00,660
is also done and so that essentially

947
00:38:00,660 --> 00:38:03,180
concludes the proof of the fact that

948
00:38:03,180 --> 00:38:05,579
this prg is in fact

949
00:38:05,579 --> 00:38:07,260
and this construction is much more

950
00:38:07,260 --> 00:38:09,000
simple and direct as opposed to the

951
00:38:09,000 --> 00:38:10,619
existing approaches for constructing

952
00:38:10,619 --> 00:38:13,320
heating PHS

953
00:38:13,320 --> 00:38:15,839
so now I'll very briefly discuss the

954
00:38:15,839 --> 00:38:17,280
fact that our simple approach for

955
00:38:17,280 --> 00:38:19,020
constructing hinting TRG is readily

956
00:38:19,020 --> 00:38:20,640
generalizes to cryptography group

957
00:38:20,640 --> 00:38:22,200
actions which are commutative and

958
00:38:22,200 --> 00:38:24,480
regular and I think heart already did an

959
00:38:24,480 --> 00:38:26,160
excellent job of introducing group

960
00:38:26,160 --> 00:38:28,020
action so I won't go into the details

961
00:38:28,020 --> 00:38:30,480
except maybe again recall that group

962
00:38:30,480 --> 00:38:32,280
actions are useful because they can be

963
00:38:32,280 --> 00:38:34,200
instantiated in possibly post Quantum

964
00:38:34,200 --> 00:38:36,240
secure manner from certain families of

965
00:38:36,240 --> 00:38:37,920
eye surgery

966
00:38:37,920 --> 00:38:40,140
and I'll just throw the construction out

967
00:38:40,140 --> 00:38:42,119
there I won't go into the details but

968
00:38:42,119 --> 00:38:43,560
again what I would like to sort of

969
00:38:43,560 --> 00:38:45,720
stress is the fact that our simple

970
00:38:45,720 --> 00:38:47,700
approach allows us to get very simple

971
00:38:47,700 --> 00:38:50,460
and direct constructions of hinting prgs

972
00:38:50,460 --> 00:38:52,140
from group actions and this is

973
00:38:52,140 --> 00:38:54,240
essentially a generalization of the

974
00:38:54,240 --> 00:38:56,760
construction from plain dth that we can

975
00:38:56,760 --> 00:38:59,400
prove secure under a special assumption

976
00:38:59,400 --> 00:39:01,140
called the linear hit and shift

977
00:39:01,140 --> 00:39:03,180
assumption that we introduced way back

978
00:39:03,180 --> 00:39:05,700
in 2020 in our Asia cup paper I want to

979
00:39:05,700 --> 00:39:07,920
have time to go into the details so I

980
00:39:07,920 --> 00:39:09,240
would refer to the paper for more

981
00:39:09,240 --> 00:39:12,800
details on the construction and proof

982
00:39:12,800 --> 00:39:15,359
and finally I would like to provide a

983
00:39:15,359 --> 00:39:17,579
very brief overview of uh hinting week

984
00:39:17,579 --> 00:39:20,700
prf so you know as we already as I

985
00:39:20,700 --> 00:39:22,980
already mentioned earlier that uh you

986
00:39:22,980 --> 00:39:24,480
know when we extend the hinting property

987
00:39:24,480 --> 00:39:26,760
from prgs to prfs one thing we need to

988
00:39:26,760 --> 00:39:29,579
ensure is a multi-evaluation kind of

989
00:39:29,579 --> 00:39:31,980
definition where we now have the key of

990
00:39:31,980 --> 00:39:34,320
the prf which is an embed string but we

991
00:39:34,320 --> 00:39:36,180
also can have a sequence of any

992
00:39:36,180 --> 00:39:38,400
polynomial in many inputs which can be

993
00:39:38,400 --> 00:39:41,339
either arbitrarily sampled or you know

994
00:39:41,339 --> 00:39:43,140
uniformly sampled for a heating week

995
00:39:43,140 --> 00:39:45,960
Piaf and then what we do is we basically

996
00:39:45,960 --> 00:39:48,720
apply this swap to each of these output

997
00:39:48,720 --> 00:39:51,119
sequences and so in some sense what we

998
00:39:51,119 --> 00:39:53,099
have here is a multi evaluation hinting

999
00:39:53,099 --> 00:39:55,500
property where each evaluation leaks

1000
00:39:55,500 --> 00:39:57,240
some information about the secret key

1001
00:39:57,240 --> 00:40:00,060
and yet this whole ensemble of outputs

1002
00:40:00,060 --> 00:40:02,460
across multiple evaluations remains

1003
00:40:02,460 --> 00:40:04,500
computationally indistinguishable from

1004
00:40:04,500 --> 00:40:07,020
uniformly ranked so this is an informal

1005
00:40:07,020 --> 00:40:08,460
overview and I would refer to the paper

1006
00:40:08,460 --> 00:40:10,260
for the formal definition

1007
00:40:10,260 --> 00:40:12,240
and then this is kind of a one slide

1008
00:40:12,240 --> 00:40:14,040
summary of the fact that we can actually

1009
00:40:14,040 --> 00:40:16,140
take our simple approaches for

1010
00:40:16,140 --> 00:40:18,660
constructing hinting prgs from dth and

1011
00:40:18,660 --> 00:40:20,880
from group actions and we can very

1012
00:40:20,880 --> 00:40:22,920
naturally extend them to construct

1013
00:40:22,920 --> 00:40:24,599
hinting weak prfs from the same

1014
00:40:24,599 --> 00:40:26,880
assumptions in particular if you look at

1015
00:40:26,880 --> 00:40:28,920
the left you can see that our hinting

1016
00:40:28,920 --> 00:40:31,680
weak prf from ddh is nothing but the

1017
00:40:31,680 --> 00:40:34,200
same hinting prg construction where the

1018
00:40:34,200 --> 00:40:36,119
secret key is now acting like the seed

1019
00:40:36,119 --> 00:40:37,980
and the public parameter essentially

1020
00:40:37,980 --> 00:40:40,980
becomes the input and you know our proof

1021
00:40:40,980 --> 00:40:42,480
techniques are also very very similar

1022
00:40:42,480 --> 00:40:45,180
nonetheless this is a very kind of high

1023
00:40:45,180 --> 00:40:47,400
level overview and I would refer to the

1024
00:40:47,400 --> 00:40:48,480
paper for the more detailed

1025
00:40:48,480 --> 00:40:51,140
constructions

1026
00:40:51,240 --> 00:40:53,160
right so now I would like to conclude by

1027
00:40:53,160 --> 00:40:55,380
summarizing our results and stating some

1028
00:40:55,380 --> 00:40:56,940
open questions

1029
00:40:56,940 --> 00:40:59,460
so we ensured how to construct hinting

1030
00:40:59,460 --> 00:41:01,800
weak prfs and hinting prgs as well as

1031
00:41:01,800 --> 00:41:03,900
functional hinting vprfs and functional

1032
00:41:03,900 --> 00:41:06,240
hinting prgs from certain standard

1033
00:41:06,240 --> 00:41:08,339
assumptions but we do not have any

1034
00:41:08,339 --> 00:41:10,680
constructions of hinting prf or its

1035
00:41:10,680 --> 00:41:13,320
extension to functional hinting prf from

1036
00:41:13,320 --> 00:41:14,940
you know standard mathematical

1037
00:41:14,940 --> 00:41:17,300
assumptions so this is one open question

1038
00:41:17,300 --> 00:41:19,920
the other open question is whether we

1039
00:41:19,920 --> 00:41:21,420
can realize Primitives with the

1040
00:41:21,420 --> 00:41:23,760
functional heating property from a wider

1041
00:41:23,760 --> 00:41:25,500
set of quantum safe assumptions such as

1042
00:41:25,500 --> 00:41:27,780
lattices or isogenes in particular our

1043
00:41:27,780 --> 00:41:29,520
current constructions are kind of

1044
00:41:29,520 --> 00:41:31,980
specific to dth and we believe that some

1045
00:41:31,980 --> 00:41:34,020
more work will be required in order to

1046
00:41:34,020 --> 00:41:35,760
be able to build this from you know

1047
00:41:35,760 --> 00:41:37,680
lattices or isogeny based assumptions

1048
00:41:37,680 --> 00:41:40,079
and finally we leave it open to

1049
00:41:40,079 --> 00:41:42,599
investigate additional applications of

1050
00:41:42,599 --> 00:41:44,220
these New Primitives with hinting

1051
00:41:44,220 --> 00:41:46,020
property and functional hinting property

1052
00:41:46,020 --> 00:41:48,599
that we introduce in this paper of

1053
00:41:48,599 --> 00:41:50,160
course I didn't get time to go into the

1054
00:41:50,160 --> 00:41:52,079
details of certain results such as the

1055
00:41:52,079 --> 00:41:54,119
Black Box separation result as well as

1056
00:41:54,119 --> 00:41:55,680
the results on the functional hinting

1057
00:41:55,680 --> 00:41:57,660
property and I would again refer to the

1058
00:41:57,660 --> 00:41:59,579
paper for more details

1059
00:41:59,579 --> 00:42:01,680
thank you and I'll be happy to take any

1060
00:42:01,680 --> 00:42:03,919
questions

1061
00:42:08,579 --> 00:42:12,320
we have time for questions

1062
00:42:16,619 --> 00:42:18,420
all right then let's thank the speaker

1063
00:42:18,420 --> 00:42:20,400
again

1064
00:42:20,400 --> 00:42:24,859
thank you thank you thanks

1065
00:43:05,220 --> 00:43:08,220
foreign

1066
00:43:18,079 --> 00:43:21,780
so let's move to the last talk of this

1067
00:43:21,780 --> 00:43:26,160
session uh this is a work on Swift PC by

1068
00:43:26,160 --> 00:43:30,000
Jorge Francisco and mehdi and uh Harvey

1069
00:43:30,000 --> 00:43:32,400
will give the talk this is the paper

1070
00:43:32,400 --> 00:43:35,220
that won the runner-up best paper award

1071
00:43:35,220 --> 00:43:37,020
and was invited to the Journal of

1072
00:43:37,020 --> 00:43:39,500
cryptology

1073
00:43:41,480 --> 00:43:43,520
foreign

1074
00:43:43,520 --> 00:43:46,200
good morning everyone so I will be

1075
00:43:46,200 --> 00:43:51,020
talking uh can we go full screen

1076
00:43:58,140 --> 00:44:00,799
absolutely

1077
00:44:31,140 --> 00:44:34,200
okay uh so I'm gonna be talking about

1078
00:44:34,200 --> 00:44:36,119
swiftc which is uh the shallow and the

1079
00:44:36,119 --> 00:44:37,680
bush time in differential function to

1080
00:44:37,680 --> 00:44:38,940
let the curves

1081
00:44:38,940 --> 00:44:42,240
uh so the contribution of this work is

1082
00:44:42,240 --> 00:44:44,400
uh the most efficient constant time

1083
00:44:44,400 --> 00:44:46,260
admissible encoding that works for a

1084
00:44:46,260 --> 00:44:48,960
large set of ordinary elliptic curves so

1085
00:44:48,960 --> 00:44:50,460
what does this mean uh well in

1086
00:44:50,460 --> 00:44:52,200
particular it's a big leap for hashing

1087
00:44:52,200 --> 00:44:54,599
into this curves because it reserves uh

1088
00:44:54,599 --> 00:44:56,520
results in the first constant time

1089
00:44:56,520 --> 00:44:58,140
admissible uh sorry indifferentiable

1090
00:44:58,140 --> 00:45:00,180
hash function that requires a single

1091
00:45:00,180 --> 00:45:01,619
Square computation

1092
00:45:01,619 --> 00:45:04,800
as well as an efficient uh pointer

1093
00:45:04,800 --> 00:45:06,420
presentation algorithm which requires

1094
00:45:06,420 --> 00:45:09,599
only two square root computations

1095
00:45:09,599 --> 00:45:12,180
so uh just as a background a lot of

1096
00:45:12,180 --> 00:45:13,619
applications in cryptography are going

1097
00:45:13,619 --> 00:45:15,240
to require us to Hash into a

1098
00:45:15,240 --> 00:45:17,160
cryptographic group of interest and if

1099
00:45:17,160 --> 00:45:18,300
this is something like a final field

1100
00:45:18,300 --> 00:45:20,700
then it can be just a cc as a hashing

1101
00:45:20,700 --> 00:45:22,140
into a long bit string and interpreting

1102
00:45:22,140 --> 00:45:24,300
this mod queue but when I'm working with

1103
00:45:24,300 --> 00:45:26,220
elliptic first this can be

1104
00:45:26,220 --> 00:45:28,140
um not real at all so basically the

1105
00:45:28,140 --> 00:45:30,480
question that we're trying to tackle is

1106
00:45:30,480 --> 00:45:32,339
uh how can we get X and Y coordinates

1107
00:45:32,339 --> 00:45:35,400
that uh are random among the set of

1108
00:45:35,400 --> 00:45:37,380
points that satisfy this uh specific

1109
00:45:37,380 --> 00:45:39,480
curve equation

1110
00:45:39,480 --> 00:45:41,819
uh so let's first uh take a look at some

1111
00:45:41,819 --> 00:45:43,319
naive constructions that don't quite

1112
00:45:43,319 --> 00:45:45,240
make the cut so the first one and most

1113
00:45:45,240 --> 00:45:47,400
obvious that I can think of is I can

1114
00:45:47,400 --> 00:45:50,099
just hash into an x coordinate so this

1115
00:45:50,099 --> 00:45:51,480
is a field element so I know how to do

1116
00:45:51,480 --> 00:45:53,460
it and then I just have to ask whether

1117
00:45:53,460 --> 00:45:55,079
or not this is the x coordinate of a

1118
00:45:55,079 --> 00:45:57,300
point in the curve so the elliptic curve

1119
00:45:57,300 --> 00:45:59,640
is given by y square equals some

1120
00:45:59,640 --> 00:46:01,680
function of X so I can just evaluate

1121
00:46:01,680 --> 00:46:03,420
this function of X and try to take the

1122
00:46:03,420 --> 00:46:06,060
square root right so if it exists then I

1123
00:46:06,060 --> 00:46:07,619
found a point in the elliptic curve and

1124
00:46:07,619 --> 00:46:09,839
I am done but if it does not exist I

1125
00:46:09,839 --> 00:46:11,220
have to start over and start with a new

1126
00:46:11,220 --> 00:46:13,260
X so I have to implement some kind of

1127
00:46:13,260 --> 00:46:15,720
try and increment approach and obviously

1128
00:46:15,720 --> 00:46:17,160
the problem with this is it's not going

1129
00:46:17,160 --> 00:46:18,960
to be constant time and we're going to

1130
00:46:18,960 --> 00:46:21,420
be open to timing attacks so just the

1131
00:46:21,420 --> 00:46:23,339
knowledge of how many times I had to

1132
00:46:23,339 --> 00:46:25,200
restart can give away available

1133
00:46:25,200 --> 00:46:27,599
information about what was the set so we

1134
00:46:27,599 --> 00:46:29,700
don't like this uh another construction

1135
00:46:29,700 --> 00:46:31,680
we can think of is uh you may know that

1136
00:46:31,680 --> 00:46:34,020
points in the elliptic curves from a

1137
00:46:34,020 --> 00:46:35,760
group so I can pick the generator of

1138
00:46:35,760 --> 00:46:37,619
this group and hash into a random

1139
00:46:37,619 --> 00:46:40,140
multiple of this generator so I hash

1140
00:46:40,140 --> 00:46:42,900
into an integer n and then I compute the

1141
00:46:42,900 --> 00:46:45,540
point P equals n times the generator so

1142
00:46:45,540 --> 00:46:47,160
this looks like a very good idea but

1143
00:46:47,160 --> 00:46:49,740
it's actually a very bad idea uh because

1144
00:46:49,740 --> 00:46:51,960
it looks very sensitive information so

1145
00:46:51,960 --> 00:46:55,200
whoever computed this hash function not

1146
00:46:55,200 --> 00:46:57,599
only knows the value of the output P but

1147
00:46:57,599 --> 00:46:59,280
in the process he also learned the value

1148
00:46:59,280 --> 00:47:01,079
of n so this is what we call the

1149
00:47:01,079 --> 00:47:03,000
discrete logarithm and it's uh in most

1150
00:47:03,000 --> 00:47:04,980
applications it's precisely what we want

1151
00:47:04,980 --> 00:47:07,020
to keep secret and we assume that it is

1152
00:47:07,020 --> 00:47:08,819
hard to compute so you can easily see

1153
00:47:08,819 --> 00:47:11,040
how depending on the application if

1154
00:47:11,040 --> 00:47:12,720
we're not careful this can end up

1155
00:47:12,720 --> 00:47:15,599
compromising security very very badly

1156
00:47:15,599 --> 00:47:17,460
so we would like to get something uh

1157
00:47:17,460 --> 00:47:19,400
that works regardless of the application

1158
00:47:19,400 --> 00:47:22,800
and in general the strategies that tend

1159
00:47:22,800 --> 00:47:24,540
to work better are based on some kind of

1160
00:47:24,540 --> 00:47:27,599
modularity so I assume that I already

1161
00:47:27,599 --> 00:47:31,020
have a hash function into some set f it

1162
00:47:31,020 --> 00:47:32,460
can be something like a finite field or

1163
00:47:32,460 --> 00:47:34,680
anything different and then I compose

1164
00:47:34,680 --> 00:47:36,420
this with something that I call an

1165
00:47:36,420 --> 00:47:38,099
encoding so the encoding is just going

1166
00:47:38,099 --> 00:47:40,380
to be a function from my set of interest

1167
00:47:40,380 --> 00:47:42,839
uh in this case to the elliptic curve

1168
00:47:42,839 --> 00:47:44,760
and I'm going to assume also that I have

1169
00:47:44,760 --> 00:47:46,980
a inverse function that takes me from

1170
00:47:46,980 --> 00:47:49,020
the curve back to the settings usually

1171
00:47:49,020 --> 00:47:50,819
we call this uh the point representation

1172
00:47:50,819 --> 00:47:53,160
function and if you're familiar with the

1173
00:47:53,160 --> 00:47:54,780
alligator construction for example this

1174
00:47:54,780 --> 00:47:57,359
is precisely the idea uh that it's based

1175
00:47:57,359 --> 00:47:59,640
on so in our case we're going to present

1176
00:47:59,640 --> 00:48:02,760
algorithms for both of this we have the

1177
00:48:02,760 --> 00:48:05,040
encoding function that will close 50c as

1178
00:48:05,040 --> 00:48:06,119
well as the point representation

1179
00:48:06,119 --> 00:48:10,040
function which we call alligator shift

1180
00:48:10,200 --> 00:48:11,640
all right

1181
00:48:11,640 --> 00:48:13,440
um so what do we need for this

1182
00:48:13,440 --> 00:48:15,060
construction to be secure basically if

1183
00:48:15,060 --> 00:48:17,099
we already have our hash function into s

1184
00:48:17,099 --> 00:48:19,920
and compose that with the encoding one

1185
00:48:19,920 --> 00:48:22,319
is this composition uh sure to be a

1186
00:48:22,319 --> 00:48:24,359
secure hash function itself it turns out

1187
00:48:24,359 --> 00:48:27,000
that it is enough for uh the encoding to

1188
00:48:27,000 --> 00:48:29,400
satisfy three properties uh it has to be

1189
00:48:29,400 --> 00:48:31,800
efficiently computable of course uh it

1190
00:48:31,800 --> 00:48:34,140
also has to be regular meaning that uh

1191
00:48:34,140 --> 00:48:36,180
for uniformly random inputs the

1192
00:48:36,180 --> 00:48:38,460
distribution of images has to be also uh

1193
00:48:38,460 --> 00:48:40,500
statistically close to uniform

1194
00:48:40,500 --> 00:48:42,480
uh and also it has to be sampleable

1195
00:48:42,480 --> 00:48:44,099
meaning that I need to have this inverse

1196
00:48:44,099 --> 00:48:46,380
function that computes three images and

1197
00:48:46,380 --> 00:48:48,060
usually the encoding is not a one-to-one

1198
00:48:48,060 --> 00:48:49,380
function so there can be more than one

1199
00:48:49,380 --> 00:48:51,720
per image so in that case we just ask

1200
00:48:51,720 --> 00:48:54,060
that it returns uh any of the possible

1201
00:48:54,060 --> 00:48:56,579
per images but it has to do so uniformly

1202
00:48:56,579 --> 00:48:58,740
at random it cannot have any bias for a

1203
00:48:58,740 --> 00:49:00,359
certain uh pre-image

1204
00:49:00,359 --> 00:49:02,640
so if the encoding satisfies these three

1205
00:49:02,640 --> 00:49:04,020
properties we say that it is an

1206
00:49:04,020 --> 00:49:06,000
admissible encoding and it turns out

1207
00:49:06,000 --> 00:49:07,740
this is enough to allow us uh to just

1208
00:49:07,740 --> 00:49:09,660
use it as a black box and not have to

1209
00:49:09,660 --> 00:49:12,540
worry about compromising security

1210
00:49:12,540 --> 00:49:15,000
uh so let's uh first look at a very

1211
00:49:15,000 --> 00:49:17,220
simple example which is an encoding not

1212
00:49:17,220 --> 00:49:19,200
to an elliptic curve but to iconic so I

1213
00:49:19,200 --> 00:49:21,060
have plotted here I connect over the

1214
00:49:21,060 --> 00:49:22,200
real numbers

1215
00:49:22,200 --> 00:49:24,900
and iconics have this very interesting

1216
00:49:24,900 --> 00:49:26,700
uh property that any line that

1217
00:49:26,700 --> 00:49:28,500
intersects it is going to do so at

1218
00:49:28,500 --> 00:49:30,540
exactly two points

1219
00:49:30,540 --> 00:49:32,819
so I can exploit this to build that

1220
00:49:32,819 --> 00:49:35,099
encoding what I do is just fix a

1221
00:49:35,099 --> 00:49:37,740
reference point P0 and then for any

1222
00:49:37,740 --> 00:49:39,960
other points in the conic I can just

1223
00:49:39,960 --> 00:49:43,020
draw the line uh connecting P0 to P1 and

1224
00:49:43,020 --> 00:49:46,140
compute the slope of this line so um for

1225
00:49:46,140 --> 00:49:48,180
uh the point P1 it is going to be

1226
00:49:48,180 --> 00:49:50,099
associated with the slope T1 of this

1227
00:49:50,099 --> 00:49:52,260
line and I can do this for any other

1228
00:49:52,260 --> 00:49:54,420
point in the conic so this is actually

1229
00:49:54,420 --> 00:49:57,660
an encoding from slopes which are real

1230
00:49:57,660 --> 00:50:00,540
numbers two points in this phonic uh

1231
00:50:00,540 --> 00:50:02,339
turns out this is in fact an admissible

1232
00:50:02,339 --> 00:50:04,619
encoding and even better than that it is

1233
00:50:04,619 --> 00:50:06,420
a one-to-one function so it's going to

1234
00:50:06,420 --> 00:50:09,119
be very well behaved uh however keep in

1235
00:50:09,119 --> 00:50:12,060
mind that uh this works only as long as

1236
00:50:12,060 --> 00:50:15,119
I have a pre-computed or somehow know a

1237
00:50:15,119 --> 00:50:17,220
fixed reference point in this content so

1238
00:50:17,220 --> 00:50:18,660
just keep this in mind because it will

1239
00:50:18,660 --> 00:50:21,060
be important later on

1240
00:50:21,060 --> 00:50:23,339
all right so now let's move on uh to

1241
00:50:23,339 --> 00:50:25,260
encodings to elliptic curves which turn

1242
00:50:25,260 --> 00:50:27,720
out to be a little bit more complicated

1243
00:50:27,720 --> 00:50:29,940
and the main ingredient that we're going

1244
00:50:29,940 --> 00:50:31,859
to use is called the shalu Van de Bush

1245
00:50:31,859 --> 00:50:34,560
Time map uh this is actually a family of

1246
00:50:34,560 --> 00:50:36,780
encodies so for each choice of the

1247
00:50:36,780 --> 00:50:39,119
parameter U which is a field element I'm

1248
00:50:39,119 --> 00:50:41,339
going to get a different encoding and

1249
00:50:41,339 --> 00:50:43,440
the way it works is uh the salon and the

1250
00:50:43,440 --> 00:50:45,839
first time find a map that goes from a

1251
00:50:45,839 --> 00:50:48,480
certain point to a certain hyper surface

1252
00:50:48,480 --> 00:50:50,520
so the certain connections given by this

1253
00:50:50,520 --> 00:50:52,319
equation and it's a parameterized

1254
00:50:52,319 --> 00:50:54,119
connect because the coefficients are

1255
00:50:54,119 --> 00:50:55,859
given by these polynomials of the

1256
00:50:55,859 --> 00:50:57,240
parameter U

1257
00:50:57,240 --> 00:51:00,059
and this hyper surface is just uh this

1258
00:51:00,059 --> 00:51:01,680
hypersurface in a four-dimensional space

1259
00:51:01,680 --> 00:51:04,619
given by c squared equals g of X1 times

1260
00:51:04,619 --> 00:51:07,680
G of X2 times G of x3 where G of X is

1261
00:51:07,680 --> 00:51:09,059
just the polynomial of the elliptic

1262
00:51:09,059 --> 00:51:11,700
curve so this are the explicit uh

1263
00:51:11,700 --> 00:51:13,140
questions for the map you don't need to

1264
00:51:13,140 --> 00:51:14,640
worry too much about them just know that

1265
00:51:14,640 --> 00:51:16,740
there is a map from here to here

1266
00:51:16,740 --> 00:51:18,300
and at this point you might be wondering

1267
00:51:18,300 --> 00:51:21,420
okay but uh this is not analytic curve

1268
00:51:21,420 --> 00:51:24,119
and this is not an elliptical so why am

1269
00:51:24,119 --> 00:51:25,920
I talking about this

1270
00:51:25,920 --> 00:51:27,420
well it turns out that from here we're

1271
00:51:27,420 --> 00:51:29,520
very close uh to getting to a point you

1272
00:51:29,520 --> 00:51:31,680
know to an in an elliptic curve so if

1273
00:51:31,680 --> 00:51:33,720
you look at the question for B I have a

1274
00:51:33,720 --> 00:51:35,940
square which is equal to the product of

1275
00:51:35,940 --> 00:51:37,020
three things

1276
00:51:37,020 --> 00:51:39,720
so when this happens uh it must be the

1277
00:51:39,720 --> 00:51:41,520
case that at least one of those three

1278
00:51:41,520 --> 00:51:43,619
things is a square and in fact there's

1279
00:51:43,619 --> 00:51:45,599
only two possibilities it can be that

1280
00:51:45,599 --> 00:51:48,300
exactly one of them is a square or all

1281
00:51:48,300 --> 00:51:50,400
three of them are squares and remember

1282
00:51:50,400 --> 00:51:53,160
if I find an X such that g of X is a

1283
00:51:53,160 --> 00:51:54,839
square then I have actually found a

1284
00:51:54,839 --> 00:51:56,940
point in the elliptic curve so all that

1285
00:51:56,940 --> 00:51:59,099
we have to do after we get our values

1286
00:51:59,099 --> 00:52:01,319
for X1 X2 X3 is do a quadratic

1287
00:52:01,319 --> 00:52:03,480
residuality test to determine which one

1288
00:52:03,480 --> 00:52:05,460
of this is a spur and return that value

1289
00:52:05,460 --> 00:52:07,559
and in the case that all three R squares

1290
00:52:07,559 --> 00:52:09,119
uh we just have to do any arbitrary

1291
00:52:09,119 --> 00:52:10,800
choice so let's say for example there

1292
00:52:10,800 --> 00:52:12,660
are prioritize X3

1293
00:52:12,660 --> 00:52:14,700
and by the way the quadratic residuity

1294
00:52:14,700 --> 00:52:17,099
tests are much cheaper than a real

1295
00:52:17,099 --> 00:52:19,020
Square computation uh at least by an

1296
00:52:19,020 --> 00:52:21,300
order of magnitude so in the end we only

1297
00:52:21,300 --> 00:52:23,579
ever have to compute a single square

1298
00:52:23,579 --> 00:52:25,200
root for the value that is in fact a

1299
00:52:25,200 --> 00:52:27,000
square and this is actually going to be

1300
00:52:27,000 --> 00:52:29,460
the main cost of the algorithm a single

1301
00:52:29,460 --> 00:52:30,839
square root

1302
00:52:30,839 --> 00:52:32,940
now on the other hand we already know we

1303
00:52:32,940 --> 00:52:34,920
talked about how to uh encode into this

1304
00:52:34,920 --> 00:52:38,880
connect so uh we can actually build uh

1305
00:52:38,880 --> 00:52:40,260
the whole chain that is known as the

1306
00:52:40,260 --> 00:52:42,839
shallow and the Houston map we start

1307
00:52:42,839 --> 00:52:45,059
with a field element which is the slope

1308
00:52:45,059 --> 00:52:48,180
of the line uh we use the encoding that

1309
00:52:48,180 --> 00:52:49,920
we talked about first to get a point in

1310
00:52:49,920 --> 00:52:52,559
the connect cu then we apply the map

1311
00:52:52,559 --> 00:52:54,300
that I just mentioned to get a point in

1312
00:52:54,300 --> 00:52:56,760
B and then we do the quadratic residency

1313
00:52:56,760 --> 00:52:58,680
tests uh to figure out which one of

1314
00:52:58,680 --> 00:53:00,240
those is a point in the elliptic curve

1315
00:53:00,240 --> 00:53:02,520
so this whole path is uh what we know as

1316
00:53:02,520 --> 00:53:05,040
the shallow and the ocean encoding and

1317
00:53:05,040 --> 00:53:06,660
uh these are given by very simple

1318
00:53:06,660 --> 00:53:08,579
formulas explicit formulas so it's easy

1319
00:53:08,579 --> 00:53:10,740
to implement in question time and the

1320
00:53:10,740 --> 00:53:12,420
main cost as I said is as per

1321
00:53:12,420 --> 00:53:14,339
computation and this is just to recover

1322
00:53:14,339 --> 00:53:16,319
the y coordinate right so if I don't

1323
00:53:16,319 --> 00:53:18,000
care about the y coordinate which is the

1324
00:53:18,000 --> 00:53:20,099
case in some applications I can actually

1325
00:53:20,099 --> 00:53:21,660
skip that

1326
00:53:21,660 --> 00:53:24,359
and uh this works basically for all

1327
00:53:24,359 --> 00:53:26,220
elliptic curves and almost any choice of

1328
00:53:26,220 --> 00:53:28,200
the parameter you however the

1329
00:53:28,200 --> 00:53:30,720
disadvantage of this uh as beautiful as

1330
00:53:30,720 --> 00:53:33,000
this all is is that for any choice of

1331
00:53:33,000 --> 00:53:35,220
you uh the encoding fuel is actually not

1332
00:53:35,220 --> 00:53:37,200
regular so this is not an admissible

1333
00:53:37,200 --> 00:53:41,040
function and I cannot use it as a hash

1334
00:53:41,040 --> 00:53:43,680
so that's too unfortunate but there is a

1335
00:53:43,680 --> 00:53:45,540
solution that we call the squared

1336
00:53:45,540 --> 00:53:47,339
encoding construction

1337
00:53:47,339 --> 00:53:48,839
um so the way it works is okay one

1338
00:53:48,839 --> 00:53:51,900
evaluation of fu is not regular but it

1339
00:53:51,900 --> 00:53:53,460
turns out that if I take two independent

1340
00:53:53,460 --> 00:53:55,980
evaluations and add them together then

1341
00:53:55,980 --> 00:53:59,300
the result actually is regular okay

1342
00:53:59,300 --> 00:54:02,040
so now I'm going to have a domain set

1343
00:54:02,040 --> 00:54:04,319
that is twice as large but I'm actually

1344
00:54:04,319 --> 00:54:06,000
going to get an admissible encoding and

1345
00:54:06,000 --> 00:54:07,500
it's an admissible encoding that works

1346
00:54:07,500 --> 00:54:09,660
for basically all elliptic curves

1347
00:54:09,660 --> 00:54:12,540
however uh the disadvantage of this is

1348
00:54:12,540 --> 00:54:14,339
that now I have to compute two copies of

1349
00:54:14,339 --> 00:54:16,440
f therefore two square root computations

1350
00:54:16,440 --> 00:54:18,000
so it's going to be a little bit more

1351
00:54:18,000 --> 00:54:20,280
expensive but this was the best uh

1352
00:54:20,280 --> 00:54:23,099
previously known way of doing this

1353
00:54:23,099 --> 00:54:25,440
so this is uh where our new proposal

1354
00:54:25,440 --> 00:54:28,260
comes into play what we post 50c

1355
00:54:28,260 --> 00:54:29,880
and what we're doing is we're still

1356
00:54:29,880 --> 00:54:32,160
using a domain size that is twice as

1357
00:54:32,160 --> 00:54:34,200
large but now the second variable is

1358
00:54:34,200 --> 00:54:36,780
going to be U itself so before it used

1359
00:54:36,780 --> 00:54:39,119
to act as a global fixed parameter but

1360
00:54:39,119 --> 00:54:40,440
now it's actually going to be another

1361
00:54:40,440 --> 00:54:43,920
input so we're Computing a capital f of

1362
00:54:43,920 --> 00:54:47,940
UNT which is equal to lower test Fu of t

1363
00:54:47,940 --> 00:54:50,040
okay so if I tell you that this is uh

1364
00:54:50,040 --> 00:54:51,359
the whole idea of the construction maybe

1365
00:54:51,359 --> 00:54:52,800
it sounds a little bit underwhelming

1366
00:54:52,800 --> 00:54:53,940
like we're just changing The annotation

1367
00:54:53,940 --> 00:54:56,099
uh but of course this has very deep

1368
00:54:56,099 --> 00:54:58,200
implications so there are theoretical

1369
00:54:58,200 --> 00:55:00,780
implications because of course uh it

1370
00:55:00,780 --> 00:55:02,520
sounds reasonable that I if I randomize

1371
00:55:02,520 --> 00:55:04,980
you as well as T probably I'm going to

1372
00:55:04,980 --> 00:55:07,440
get more random looking boys uh but to

1373
00:55:07,440 --> 00:55:09,180
get a formal proof of regularity it's a

1374
00:55:09,180 --> 00:55:10,260
whole different thing

1375
00:55:10,260 --> 00:55:12,420
and there's also uh practical

1376
00:55:12,420 --> 00:55:14,099
implications because now I need an

1377
00:55:14,099 --> 00:55:16,319
algorithm that will be able to evaluate

1378
00:55:16,319 --> 00:55:19,260
Fu of t for any choice of U that will be

1379
00:55:19,260 --> 00:55:21,059
determined at runtime

1380
00:55:21,059 --> 00:55:24,119
okay uh however over the whole uh fq

1381
00:55:24,119 --> 00:55:26,040
Square domain this construction uh we

1382
00:55:26,040 --> 00:55:28,079
show that it is in fact admissible and

1383
00:55:28,079 --> 00:55:29,339
what we gain is that we're back to

1384
00:55:29,339 --> 00:55:31,380
having to compute a single copy of f

1385
00:55:31,380 --> 00:55:33,599
therefore a single Square computation so

1386
00:55:33,599 --> 00:55:36,599
this should be an is in fact uh roughly

1387
00:55:36,599 --> 00:55:38,640
twice as fast as the previous state of

1388
00:55:38,640 --> 00:55:40,879
the Earth

1389
00:55:42,960 --> 00:55:45,300
okay uh so let's first talk about this

1390
00:55:45,300 --> 00:55:47,460
uh practical implications of building

1391
00:55:47,460 --> 00:55:48,720
this algorithm

1392
00:55:48,720 --> 00:55:50,460
and the place where you're going to run

1393
00:55:50,460 --> 00:55:52,859
into trouble is uh for the encoding to

1394
00:55:52,859 --> 00:55:54,540
the connect so if you remember near the

1395
00:55:54,540 --> 00:55:56,220
beginning of the talk I mentioned for

1396
00:55:56,220 --> 00:55:57,960
this to work you have to know a

1397
00:55:57,960 --> 00:55:59,940
reference point in the connect it can be

1398
00:55:59,940 --> 00:56:01,380
any point but you have to have some way

1399
00:56:01,380 --> 00:56:03,660
of finding at least one point so this is

1400
00:56:03,660 --> 00:56:05,819
what I had called P0 before now I'm

1401
00:56:05,819 --> 00:56:08,940
calling it pu because it is the connect

1402
00:56:08,940 --> 00:56:10,619
itself is a function of the parameter U

1403
00:56:10,619 --> 00:56:13,440
so I need an algorithm that uh given the

1404
00:56:13,440 --> 00:56:15,720
connect CU will return some reference

1405
00:56:15,720 --> 00:56:18,240
points to you and it turns out that this

1406
00:56:18,240 --> 00:56:19,680
is a problem that has already been

1407
00:56:19,680 --> 00:56:22,079
studied by Bank Hoy shank Ramona and

1408
00:56:22,079 --> 00:56:23,880
they showed uh the following terms so if

1409
00:56:23,880 --> 00:56:25,980
I have disconnect that is parametrized

1410
00:56:25,980 --> 00:56:29,160
by this polynomial coefficients um h of

1411
00:56:29,160 --> 00:56:30,599
U and G of U

1412
00:56:30,599 --> 00:56:32,640
it turns out that there is an

1413
00:56:32,640 --> 00:56:34,260
efficiently computable point in this

1414
00:56:34,260 --> 00:56:37,079
planet given by rational equations if

1415
00:56:37,079 --> 00:56:38,940
and only if two conditions are satisfied

1416
00:56:38,940 --> 00:56:42,960
so minus H has to be a square mod f

1417
00:56:42,960 --> 00:56:45,180
mod H sorry minus G has to be a square

1418
00:56:45,180 --> 00:56:47,520
mod H and minus H has to be a square

1419
00:56:47,520 --> 00:56:49,619
modject so as long as these two

1420
00:56:49,619 --> 00:56:51,660
conditions are satisfied their proof is

1421
00:56:51,660 --> 00:56:52,920
constructive so I can use their

1422
00:56:52,920 --> 00:56:55,859
algorithm to Output a point pu and then

1423
00:56:55,859 --> 00:56:57,720
I just carry on how the rest of the

1424
00:56:57,720 --> 00:57:00,300
construction exactly as before

1425
00:57:00,300 --> 00:57:03,059
now in our case uh the polynomials H and

1426
00:57:03,059 --> 00:57:04,559
G are not General but they have this

1427
00:57:04,559 --> 00:57:07,500
very specific form so uh H is equal to

1428
00:57:07,500 --> 00:57:10,680
3u squared plus for a and minus D is

1429
00:57:10,680 --> 00:57:12,000
just the polynomial of the elliptic

1430
00:57:12,000 --> 00:57:14,940
curve so in this particular case I will

1431
00:57:14,940 --> 00:57:16,800
show in the paper that the conditions

1432
00:57:16,800 --> 00:57:17,880
that I just mentioned are actually

1433
00:57:17,880 --> 00:57:20,099
equivalent to another set of three

1434
00:57:20,099 --> 00:57:22,380
conditions uh namely that the size of

1435
00:57:22,380 --> 00:57:24,300
the field has to be

1436
00:57:24,300 --> 00:57:26,700
uh equal to one more three the

1437
00:57:26,700 --> 00:57:28,260
discriminant of the curve has to be a

1438
00:57:28,260 --> 00:57:29,040
square

1439
00:57:29,040 --> 00:57:31,319
and the third condition is that at least

1440
00:57:31,319 --> 00:57:33,480
one of these constants new Plus or new

1441
00:57:33,480 --> 00:57:35,640
minus has to be a square so if you look

1442
00:57:35,640 --> 00:57:37,500
carefully here uh condition one implies

1443
00:57:37,500 --> 00:57:39,420
that minus three is a square condition

1444
00:57:39,420 --> 00:57:41,280
two implies that Delta is a square so

1445
00:57:41,280 --> 00:57:43,500
this whole thing is always a square

1446
00:57:43,500 --> 00:57:45,240
and if I take the square root for at

1447
00:57:45,240 --> 00:57:47,339
least one of the choices of sine I

1448
00:57:47,339 --> 00:57:48,839
should get a quantity that is a square

1449
00:57:48,839 --> 00:57:50,760
so that is condition three

1450
00:57:50,760 --> 00:57:53,160
so it's not uh at all obvious that these

1451
00:57:53,160 --> 00:57:54,839
conditions are equivalent to the ones

1452
00:57:54,839 --> 00:57:56,339
that I mentioned before but it's a much

1453
00:57:56,339 --> 00:57:58,200
nicer characterization of the course

1454
00:57:58,200 --> 00:57:59,460
that are compatible with our

1455
00:57:59,460 --> 00:58:01,140
Construction

1456
00:58:01,140 --> 00:58:03,780
so uh notebookers that are compatible

1457
00:58:03,780 --> 00:58:07,640
include the nist p256 curve as well as

1458
00:58:07,640 --> 00:58:10,020
256k1 which is the one used for Bitcoin

1459
00:58:10,020 --> 00:58:12,839
and also all the BN and BLS burps which

1460
00:58:12,839 --> 00:58:14,760
are used for pairings uh those are all

1461
00:58:14,760 --> 00:58:16,619
immediately compatible as long as Q is

1462
00:58:16,619 --> 00:58:18,240
equal to one more three

1463
00:58:18,240 --> 00:58:19,859
and then there's a few other curves

1464
00:58:19,859 --> 00:58:22,140
which are not compatible but that we

1465
00:58:22,140 --> 00:58:24,540
managed to rescue using ice audience so

1466
00:58:24,540 --> 00:58:26,400
an Exogen is just a rational map that

1467
00:58:26,400 --> 00:58:28,140
takes me from pointing one curve to

1468
00:58:28,140 --> 00:58:31,020
points in another curve and so it may be

1469
00:58:31,020 --> 00:58:32,880
in some cases that the curve itself is

1470
00:58:32,880 --> 00:58:34,920
not compatible but I managed to find an

1471
00:58:34,920 --> 00:58:36,900
exogenous curve that is compatible so I

1472
00:58:36,900 --> 00:58:39,000
can just apply this 50c construction to

1473
00:58:39,000 --> 00:58:40,740
that other curve and then compose with

1474
00:58:40,740 --> 00:58:42,000
the I saw you need to get back to the

1475
00:58:42,000 --> 00:58:43,260
curve that I wanted

1476
00:58:43,260 --> 00:58:45,540
so this is the case for instance uh for

1477
00:58:45,540 --> 00:58:48,540
curb 25519 it is not compatible because

1478
00:58:48,540 --> 00:58:51,000
the experiment is not a square but we

1479
00:58:51,000 --> 00:58:52,920
found a curve that is compatible and is

1480
00:58:52,920 --> 00:58:54,960
related by an oxygen of degree2 which is

1481
00:58:54,960 --> 00:58:57,180
very very cheap to evaluate so it has a

1482
00:58:57,180 --> 00:58:59,460
very negligible overhead and the same is

1483
00:58:59,460 --> 00:59:02,339
the case uh for miss p521 it is not

1484
00:59:02,339 --> 00:59:04,200
compatible but we also managed to rescue

1485
00:59:04,200 --> 00:59:06,119
it this time through an isogeny of the

1486
00:59:06,119 --> 00:59:07,200
great tree

1487
00:59:07,200 --> 00:59:08,700
and then unfortunately there's another

1488
00:59:08,700 --> 00:59:11,520
case uh when Q is not equal to one mode

1489
00:59:11,520 --> 00:59:14,339
three here isogon is done really help us

1490
00:59:14,339 --> 00:59:17,640
and so far we have no good way no way at

1491
00:59:17,640 --> 00:59:19,619
all of rescuing this course and

1492
00:59:19,619 --> 00:59:21,420
unfortunately this does happen for some

1493
00:59:21,420 --> 00:59:24,599
popular curves including missed p384 and

1494
00:59:24,599 --> 00:59:26,520
the Goldilocks curve so those are not

1495
00:59:26,520 --> 00:59:28,940
compatible

1496
00:59:28,980 --> 00:59:31,500
okay so that covers uh the computability

1497
00:59:31,500 --> 00:59:33,660
of Swifty now let's talk about the

1498
00:59:33,660 --> 00:59:35,940
second property which was regularity and

1499
00:59:35,940 --> 00:59:37,500
let me be a little bit more specific

1500
00:59:37,500 --> 00:59:39,780
about what we want to show so if I have

1501
00:59:39,780 --> 00:59:41,880
a function that is perfectly random

1502
00:59:41,880 --> 00:59:43,260
and I want to compute the number of

1503
00:59:43,260 --> 00:59:45,720
pre-images on average this should just

1504
00:59:45,720 --> 00:59:47,339
be equal to the size of the domain

1505
00:59:47,339 --> 00:59:49,859
divided by the size of the codomain

1506
00:59:49,859 --> 00:59:52,079
so in our case the size of the domain is

1507
00:59:52,079 --> 00:59:53,400
Q squared because we have two field

1508
00:59:53,400 --> 00:59:56,040
elements U and T and the size of the

1509
00:59:56,040 --> 00:59:57,720
color domain is just the order of the

1510
00:59:57,720 --> 00:59:59,520
curve in this case divided by two

1511
00:59:59,520 --> 01:00:00,720
because we only care about the x

1512
01:00:00,720 --> 01:00:03,180
coordinate and not the y coordinate so

1513
01:00:03,180 --> 01:00:04,680
uh there's a popular theorem called

1514
01:00:04,680 --> 01:00:06,960
hasses theorem that tells you that the

1515
01:00:06,960 --> 01:00:09,180
order of the curve is roughly Q so if

1516
01:00:09,180 --> 01:00:10,980
you plug this in uh you'll find that the

1517
01:00:10,980 --> 01:00:13,020
number of free images should be roughly

1518
01:00:13,020 --> 01:00:14,460
equal to 2q

1519
01:00:14,460 --> 01:00:16,920
so this is uh the main theoretical

1520
01:00:16,920 --> 01:00:18,960
contribution in the paper I will show

1521
01:00:18,960 --> 01:00:21,299
this theorem that if you take this error

1522
01:00:21,299 --> 01:00:22,980
term which should be equal to zero if

1523
01:00:22,980 --> 01:00:24,240
you plug this in

1524
01:00:24,240 --> 01:00:25,680
I will show that of course it's not

1525
01:00:25,680 --> 01:00:28,079
exactly zero but the sum in absolute

1526
01:00:28,079 --> 01:00:31,020
value is bounded by this Epsilon which

1527
01:00:31,020 --> 01:00:32,280
is a function that vanishes

1528
01:00:32,280 --> 01:00:34,619
exponentially fast with the bit size of

1529
01:00:34,619 --> 01:00:36,780
cube so asymptotically the distribution

1530
01:00:36,780 --> 01:00:39,180
of CTC is going to be very close to our

1531
01:00:39,180 --> 01:00:41,460
uniform function

1532
01:00:41,460 --> 01:00:43,859
and finally let's talk about the sample

1533
01:00:43,859 --> 01:00:45,720
ability so remember this is being able

1534
01:00:45,720 --> 01:00:47,880
to compute for images and what we do is

1535
01:00:47,880 --> 01:00:50,760
explicitly propose uh this new algorithm

1536
01:00:50,760 --> 01:00:53,460
called alligator Swift which uh given

1537
01:00:53,460 --> 01:00:55,619
the x coordinate of a point will return

1538
01:00:55,619 --> 01:00:58,500
a pretty mesh UNT and the way it works

1539
01:00:58,500 --> 01:01:01,619
is basically just you fix a randomly

1540
01:01:01,619 --> 01:01:04,319
chosen value of U and try to invert Fe

1541
01:01:04,319 --> 01:01:06,720
of t so when you're trying to invert it

1542
01:01:06,720 --> 01:01:08,700
you should ask yourself from what point

1543
01:01:08,700 --> 01:01:11,220
in the conic could I have come from and

1544
01:01:11,220 --> 01:01:12,180
basically there's three different

1545
01:01:12,180 --> 01:01:14,460
branches so these are the equations for

1546
01:01:14,460 --> 01:01:16,440
the map that I had mentioned near the

1547
01:01:16,440 --> 01:01:18,240
beginning of the talk so there's three

1548
01:01:18,240 --> 01:01:20,099
choices either the square game from X1

1549
01:01:20,099 --> 01:01:22,680
in which case I have to invert the first

1550
01:01:22,680 --> 01:01:23,640
map

1551
01:01:23,640 --> 01:01:25,440
or the square going from x2 in which

1552
01:01:25,440 --> 01:01:27,000
case I have to invert the second map or

1553
01:01:27,000 --> 01:01:28,619
it came from X3 in which case I have to

1554
01:01:28,619 --> 01:01:31,380
invert the third map so I pick a random

1555
01:01:31,380 --> 01:01:33,480
value of U and then I pick one of these

1556
01:01:33,480 --> 01:01:35,520
three cases at random and I try to embed

1557
01:01:35,520 --> 01:01:38,220
that corresponding map so if this works

1558
01:01:38,220 --> 01:01:40,380
then I'm done and I hop on uh pre-image

1559
01:01:40,380 --> 01:01:42,240
but if it doesn't work then I just start

1560
01:01:42,240 --> 01:01:44,160
over so I pick a new u i pick another

1561
01:01:44,160 --> 01:01:45,900
one of these cases at random I try again

1562
01:01:45,900 --> 01:01:47,700
so basically we're doing some rejection

1563
01:01:47,700 --> 01:01:49,680
sampling to ensure that the distribution

1564
01:01:49,680 --> 01:01:52,319
is going to be uniform and it turns out

1565
01:01:52,319 --> 01:01:54,299
you can actually reject fail samples by

1566
01:01:54,299 --> 01:01:56,280
just doing quadratic reciprocity tests

1567
01:01:56,280 --> 01:01:58,680
before committing to real square root

1568
01:01:58,680 --> 01:02:00,720
computations so in the end you only have

1569
01:02:00,720 --> 01:02:02,460
to compute square roots for the one

1570
01:02:02,460 --> 01:02:04,260
successful case and this is a big

1571
01:02:04,260 --> 01:02:06,540
improvement over the squared encoding

1572
01:02:06,540 --> 01:02:09,180
variant where each failed attempt uh has

1573
01:02:09,180 --> 01:02:12,119
the cost of another square root

1574
01:02:12,119 --> 01:02:13,859
um and then of course uh once you get

1575
01:02:13,859 --> 01:02:15,299
your point in the clinic remember

1576
01:02:15,299 --> 01:02:17,160
according to the clinic was a one-to-one

1577
01:02:17,160 --> 01:02:18,839
function so that is very easy to invert

1578
01:02:18,839 --> 01:02:20,460
you can compute T from there which

1579
01:02:20,460 --> 01:02:22,380
remember was just the slope of the line

1580
01:02:22,380 --> 01:02:24,780
so the output is going to be the U that

1581
01:02:24,780 --> 01:02:26,940
you picked at random uh and the T that

1582
01:02:26,940 --> 01:02:28,859
you computed

1583
01:02:28,859 --> 01:02:31,440
okay uh so we have uh just a proof of

1584
01:02:31,440 --> 01:02:33,780
concept implementation in sash that is

1585
01:02:33,780 --> 01:02:36,599
freely available and what we do is count

1586
01:02:36,599 --> 01:02:38,220
the number of operations that it takes

1587
01:02:38,220 --> 01:02:39,599
so we have the number of additions

1588
01:02:39,599 --> 01:02:42,240
querings multiplications Jacobi symbols

1589
01:02:42,240 --> 01:02:44,160
which are the quadratic residency tests

1590
01:02:44,160 --> 01:02:46,440
as well as inverses and square roots and

1591
01:02:46,440 --> 01:02:48,480
as promised the main feature is that you

1592
01:02:48,480 --> 01:02:49,920
only have to compute one square root

1593
01:02:49,920 --> 01:02:51,839
along with one inverse which by the way

1594
01:02:51,839 --> 01:02:54,540
can be computed in batch and then of

1595
01:02:54,540 --> 01:02:56,520
course if you only care about X on the

1596
01:02:56,520 --> 01:02:57,720
projected coordinates then you don't

1597
01:02:57,720 --> 01:02:59,880
have to do either of them at all

1598
01:02:59,880 --> 01:03:03,059
and this is just a little uh test that

1599
01:03:03,059 --> 01:03:05,280
we run with our implementation so this

1600
01:03:05,280 --> 01:03:07,079
is counting the number of images of

1601
01:03:07,079 --> 01:03:09,059
every point in the elliptic curve so

1602
01:03:09,059 --> 01:03:10,619
each of these bins represents a

1603
01:03:10,619 --> 01:03:12,839
different point and we just exhaustively

1604
01:03:12,839 --> 01:03:15,059
evaluated uh Swift DC for every single

1605
01:03:15,059 --> 01:03:17,400
input obviously this has to do have to

1606
01:03:17,400 --> 01:03:19,740
be done with a very uh small Prime so

1607
01:03:19,740 --> 01:03:21,240
this is only attended Prime but already

1608
01:03:21,240 --> 01:03:23,579
for this small size you can see that the

1609
01:03:23,579 --> 01:03:25,319
distribution is looking very close to

1610
01:03:25,319 --> 01:03:27,720
uniforms it's a very good result

1611
01:03:27,720 --> 01:03:30,720
okay um so just to conclude uh Swift DC

1612
01:03:30,720 --> 01:03:32,880
is now the most efficient known way for

1613
01:03:32,880 --> 01:03:35,220
uh indifferentiable hashing in constant

1614
01:03:35,220 --> 01:03:37,260
time to a large set of ordinary elliptic

1615
01:03:37,260 --> 01:03:39,359
curves and alligator shift is the most

1616
01:03:39,359 --> 01:03:40,980
efficient Point representation algorithm

1617
01:03:40,980 --> 01:03:43,140
for the same set of Curves and that's

1618
01:03:43,140 --> 01:03:44,520
something to work that we still want to

1619
01:03:44,520 --> 01:03:46,740
do for this project is uh doing an

1620
01:03:46,740 --> 01:03:49,319
efficient uh constant time C

1621
01:03:49,319 --> 01:03:52,079
implementation for reference as well as

1622
01:03:52,079 --> 01:03:53,940
a theoretical work to further increase

1623
01:03:53,940 --> 01:03:56,400
the number of Curves that are compatible

1624
01:03:56,400 --> 01:03:58,380
so with that I would like to thank you

1625
01:03:58,380 --> 01:03:59,960
very much for your attention

1626
01:03:59,960 --> 01:04:02,960
thank you

1627
01:04:07,079 --> 01:04:10,579
are there any questions

1628
01:04:12,599 --> 01:04:14,520
all right so let's thank the speaker

1629
01:04:14,520 --> 01:04:16,880
again

1630
01:04:21,540 --> 01:04:25,579
I will now have the coffee break

1631
01:04:25,640 --> 01:04:29,400
and let me uh announce again that the

1632
01:04:29,400 --> 01:04:32,280
sponsor area is on the fourth floor and

1633
01:04:32,280 --> 01:04:37,400
uh and there is quite a bit of food

