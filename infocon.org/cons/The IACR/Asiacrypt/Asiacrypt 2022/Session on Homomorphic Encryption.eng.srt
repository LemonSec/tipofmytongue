1
00:00:00,000 --> 00:00:03,060
welcome to this session on the fully on

2
00:00:03,060 --> 00:00:04,799
a homomorphic encryption

3
00:00:04,799 --> 00:00:08,240
so the first book will be on the paper

4
00:00:08,240 --> 00:00:11,340
uh the status is a special linearly

5
00:00:11,340 --> 00:00:13,980
homographic encryption on Z over 2 to

6
00:00:13,980 --> 00:00:15,420
the KZ

7
00:00:15,420 --> 00:00:18,779
and the speaker will be I that occur

8
00:00:18,779 --> 00:00:22,759
so either flow is yours

9
00:00:22,880 --> 00:00:26,100
hey thanks for the introduction

10
00:00:26,100 --> 00:00:28,500
um so yeah I'm gonna tell you about a

11
00:00:28,500 --> 00:00:30,900
scheme that we developed which is called

12
00:00:30,900 --> 00:00:33,020
threshold linearly homomorphic

13
00:00:33,020 --> 00:00:35,820
encryption where the message space is

14
00:00:35,820 --> 00:00:38,219
set in which is a KZ and this is Joint

15
00:00:38,219 --> 00:00:42,480
work with Ian castanos and Fabian again

16
00:00:42,480 --> 00:00:46,320
so I'll stop by uh explaining how high

17
00:00:46,320 --> 00:00:48,120
level what threshold public key

18
00:00:48,120 --> 00:00:50,820
encryption is so the idea is it's just a

19
00:00:50,820 --> 00:00:53,280
public key encryption scheme where the

20
00:00:53,280 --> 00:00:55,559
secret decryption key is

21
00:00:55,559 --> 00:00:57,360
um shared According to some decryption

22
00:00:57,360 --> 00:01:00,480
policy among various decryption servers

23
00:01:00,480 --> 00:01:03,660
and as any public key encryption scheme

24
00:01:03,660 --> 00:01:07,439
the public key is public and so anyone

25
00:01:07,439 --> 00:01:09,780
can encrypt a message M with this public

26
00:01:09,780 --> 00:01:11,280
encryption key

27
00:01:11,280 --> 00:01:14,640
to produce a cyber text domain

28
00:01:14,640 --> 00:01:19,580
so this architect here is the red m

29
00:01:19,920 --> 00:01:22,799
M and then in thresholds uh public key

30
00:01:22,799 --> 00:01:25,020
encryption we have a partial decryption

31
00:01:25,020 --> 00:01:27,720
where each server is going to use their

32
00:01:27,720 --> 00:01:29,759
partial decryption key in order to

33
00:01:29,759 --> 00:01:33,600
compute partial decryption shares

34
00:01:33,600 --> 00:01:36,000
and in order to recover the initial

35
00:01:36,000 --> 00:01:38,600
plain text

36
00:01:39,000 --> 00:01:39,840
um

37
00:01:39,840 --> 00:01:42,180
we have another final decryption

38
00:01:42,180 --> 00:01:45,119
protocol which is public so anyone can

39
00:01:45,119 --> 00:01:47,880
perform this and if you have

40
00:01:47,880 --> 00:01:51,600
um a number of Cipher texts from Secret

41
00:01:51,600 --> 00:01:53,340
Keys which

42
00:01:53,340 --> 00:01:54,119
um

43
00:01:54,119 --> 00:01:56,399
satisfy the decryption policy so we'll

44
00:01:56,399 --> 00:01:58,340
say they're part of the qualified set

45
00:01:58,340 --> 00:02:01,439
then combining these ciphertexts will

46
00:02:01,439 --> 00:02:04,380
allow you to recover the message and if

47
00:02:04,380 --> 00:02:08,340
the secret keys don't satisfy the policy

48
00:02:08,340 --> 00:02:10,258
the

49
00:02:10,258 --> 00:02:13,099
the decryption will return an empty set

50
00:02:13,099 --> 00:02:17,599
not an error it should be an empty sense

51
00:02:17,819 --> 00:02:21,000
if we want this threshold public key

52
00:02:21,000 --> 00:02:23,220
encryption scheme to further be linearly

53
00:02:23,220 --> 00:02:25,560
homomorphic

54
00:02:25,560 --> 00:02:28,080
um I mean this means that one should

55
00:02:28,080 --> 00:02:30,420
also be able to perform

56
00:02:30,420 --> 00:02:31,319
um

57
00:02:31,319 --> 00:02:33,480
by by performing operations on the

58
00:02:33,480 --> 00:02:35,459
ciphertext you can perform linear

59
00:02:35,459 --> 00:02:38,160
operations on the underlying plaintexts

60
00:02:38,160 --> 00:02:40,860
so we have two efficient algorithms uh

61
00:02:40,860 --> 00:02:43,800
one which given the Cyber text of M and

62
00:02:43,800 --> 00:02:47,879
a side text decrypting to M Star you can

63
00:02:47,879 --> 00:02:49,860
produce nervous ciphertext which will

64
00:02:49,860 --> 00:02:52,379
decrypt to M plus n star

65
00:02:52,379 --> 00:02:57,720
and uh algorithm called evalscal which

66
00:02:57,720 --> 00:03:00,239
takes uh ciphertext which decrypts to m

67
00:03:00,239 --> 00:03:02,580
a scalar Alpha

68
00:03:02,580 --> 00:03:05,580
and produces a new ciphertext which will

69
00:03:05,580 --> 00:03:09,000
decrypt to Alpha science and stuff

70
00:03:09,000 --> 00:03:13,019
and uh linearly homomorphic public I

71
00:03:13,019 --> 00:03:15,900
mean threshold public key encryption on

72
00:03:15,900 --> 00:03:18,480
Z over G to the KZ is basically above

73
00:03:18,480 --> 00:03:21,540
but where the message space is Z over G

74
00:03:21,540 --> 00:03:22,920
to the KZ

75
00:03:22,920 --> 00:03:25,739
so we can encrypt any message modulo t

76
00:03:25,739 --> 00:03:28,200
to the K and the interesting thing here

77
00:03:28,200 --> 00:03:31,200
is that these um homomorphic operations

78
00:03:31,200 --> 00:03:33,060
I can't hear you anymore

79
00:03:33,060 --> 00:03:36,560
oh okay

80
00:03:38,400 --> 00:03:40,140
I can hear

81
00:03:40,140 --> 00:03:43,680
can you hear me yes okay great

82
00:03:43,680 --> 00:03:46,920
so the the interesting thing uh about

83
00:03:46,920 --> 00:03:48,239
having

84
00:03:48,239 --> 00:03:49,080
um

85
00:03:49,080 --> 00:03:51,659
an encryption modular due to the KZ here

86
00:03:51,659 --> 00:03:53,819
is that the um

87
00:03:53,819 --> 00:03:56,580
homomorphic operations that we do on the

88
00:03:56,580 --> 00:03:58,440
ciphertext under the hood on the

89
00:03:58,440 --> 00:04:00,239
plaintext they're performed modulo two

90
00:04:00,239 --> 00:04:02,340
to the k

91
00:04:02,340 --> 00:04:07,400
okay and so why is this interesting

92
00:04:08,340 --> 00:04:10,680
um so there are various applications but

93
00:04:10,680 --> 00:04:12,780
I'm going to just describe one of them

94
00:04:12,780 --> 00:04:15,299
uh how this can be applied to

95
00:04:15,299 --> 00:04:17,579
multi-party computation modularity to

96
00:04:17,579 --> 00:04:18,540
decay

97
00:04:18,540 --> 00:04:20,000
so

98
00:04:20,000 --> 00:04:22,979
briefly uh the idea of a secure

99
00:04:22,979 --> 00:04:25,259
multi-party computation is that we have

100
00:04:25,259 --> 00:04:28,500
like various parties here we have four

101
00:04:28,500 --> 00:04:32,040
um they all have secret inputs say X1 X2

102
00:04:32,040 --> 00:04:35,160
X3 and X4 and they all want to compute a

103
00:04:35,160 --> 00:04:38,460
function of their common of all of their

104
00:04:38,460 --> 00:04:40,860
inputs put together but they don't trust

105
00:04:40,860 --> 00:04:42,540
the other parties and they don't want to

106
00:04:42,540 --> 00:04:44,400
reveal their secret inputs to the other

107
00:04:44,400 --> 00:04:46,380
parties

108
00:04:46,380 --> 00:04:48,660
so one way of doing this would be having

109
00:04:48,660 --> 00:04:52,860
a trusted party like this Angel here

110
00:04:52,860 --> 00:04:53,820
um

111
00:04:53,820 --> 00:04:56,400
and all the parties send their secret

112
00:04:56,400 --> 00:04:58,259
inputs to this person that they all

113
00:04:58,259 --> 00:05:00,600
trust The Trusted person

114
00:05:00,600 --> 00:05:02,580
computes the result of the function and

115
00:05:02,580 --> 00:05:04,560
sends it back to everyone

116
00:05:04,560 --> 00:05:07,440
but of course in real life angels are

117
00:05:07,440 --> 00:05:09,960
kind of hard to come across

118
00:05:09,960 --> 00:05:13,199
and so uh the idea of secure multi-party

119
00:05:13,199 --> 00:05:15,740
computation is achieving the same goal

120
00:05:15,740 --> 00:05:19,020
but without a twisted party so all the

121
00:05:19,020 --> 00:05:21,120
participants should keep their secret

122
00:05:21,120 --> 00:05:23,400
inputs secret but at the end of the day

123
00:05:23,400 --> 00:05:24,960
they all want the result of this

124
00:05:24,960 --> 00:05:28,940
function on their private empaths

125
00:05:30,180 --> 00:05:31,680
um and there's been a lot of interest

126
00:05:31,680 --> 00:05:36,860
recently I mean fairly recently for um

127
00:05:36,860 --> 00:05:40,440
uh multi-party computation modulo two to

128
00:05:40,440 --> 00:05:43,740
Decay and this is mainly because uh on

129
00:05:43,740 --> 00:05:46,320
standard CPUs integral arithmetic is

130
00:05:46,320 --> 00:05:48,720
performed modulo two to the K so for

131
00:05:48,720 --> 00:05:53,400
instance 32 or 64-bit chips

132
00:05:53,400 --> 00:05:56,039
um and if we have secure multi

133
00:05:56,039 --> 00:05:57,900
computation multi-party computation

134
00:05:57,900 --> 00:06:00,720
modulator due to the K we mirror this

135
00:06:00,720 --> 00:06:05,100
design and it means uh that one has a

136
00:06:05,100 --> 00:06:07,560
simplified implementation of these MPC

137
00:06:07,560 --> 00:06:08,759
protocols

138
00:06:08,759 --> 00:06:10,500
we don't need to perform modular

139
00:06:10,500 --> 00:06:12,600
arithmetic or compensate for modular

140
00:06:12,600 --> 00:06:13,800
reductions

141
00:06:13,800 --> 00:06:16,259
and it also means that programmers

142
00:06:16,259 --> 00:06:19,020
they're implementing these protocols can

143
00:06:19,020 --> 00:06:24,380
use optimizations for CPUs directly

144
00:06:25,919 --> 00:06:29,639
and so how does one go about building a

145
00:06:29,639 --> 00:06:32,660
multi-party computation

146
00:06:32,660 --> 00:06:36,360
modulo 2 to Decay well there's a kind of

147
00:06:36,360 --> 00:06:39,259
common blueprint which is used to build

148
00:06:39,259 --> 00:06:41,400
maliciously secure multi-party

149
00:06:41,400 --> 00:06:45,240
computation protocols it divides the

150
00:06:45,240 --> 00:06:47,039
process in two phases so we have a

151
00:06:47,039 --> 00:06:49,139
pre-processing phase which is

152
00:06:49,139 --> 00:06:51,419
offline so this means the participants

153
00:06:51,419 --> 00:06:54,360
can do it without knowing the inputs

154
00:06:54,360 --> 00:06:56,280
that they're going to use for their

155
00:06:56,280 --> 00:06:58,020
computation or even the function that

156
00:06:58,020 --> 00:06:59,880
they're going to compute

157
00:06:59,880 --> 00:07:02,340
um and it's slow

158
00:07:02,340 --> 00:07:06,380
um and the idea is to compute

159
00:07:06,380 --> 00:07:09,900
many shares of triplets of the form a b

160
00:07:09,900 --> 00:07:13,139
a b where A and B are random in Z over 2

161
00:07:13,139 --> 00:07:15,479
to the KZ and these triplets are then

162
00:07:15,479 --> 00:07:18,900
going to be used to speed up the fast

163
00:07:18,900 --> 00:07:22,319
online phase and they're basically used

164
00:07:22,319 --> 00:07:24,780
as masks during this um this protocol

165
00:07:24,780 --> 00:07:26,880
and so this online phase is fast and

166
00:07:26,880 --> 00:07:30,360
information theoretically secure

167
00:07:30,360 --> 00:07:31,680
um

168
00:07:31,680 --> 00:07:35,699
so we'd like a way to improve the slow

169
00:07:35,699 --> 00:07:37,380
phase the pre-processing phase because

170
00:07:37,380 --> 00:07:38,699
the online phase is already very

171
00:07:38,699 --> 00:07:40,979
efficient

172
00:07:40,979 --> 00:07:44,280
um techniques that were used in the past

173
00:07:44,280 --> 00:07:47,819
um are notably oblivious transfer which

174
00:07:47,819 --> 00:07:50,639
was used in SPD z2k to create these

175
00:07:50,639 --> 00:07:52,740
triples

176
00:07:52,740 --> 00:07:54,599
um

177
00:07:54,599 --> 00:07:57,660
so oblivious transfer yields a fast

178
00:07:57,660 --> 00:07:59,340
solution but the bandwidth of

179
00:07:59,340 --> 00:08:01,440
consumption is quite High

180
00:08:01,440 --> 00:08:05,220
and then in overdrive 2K they use

181
00:08:05,220 --> 00:08:07,620
somewhat homomorphic encryption so this

182
00:08:07,620 --> 00:08:09,240
does improve the bandwidth consumption

183
00:08:09,240 --> 00:08:11,699
but the actual protocol itself is quite

184
00:08:11,699 --> 00:08:14,580
complex and so implementing it um for

185
00:08:14,580 --> 00:08:16,620
developers is quite hard and there's

186
00:08:16,620 --> 00:08:18,840
more risks of things of there being

187
00:08:18,840 --> 00:08:20,639
mistakes

188
00:08:20,639 --> 00:08:23,580
um and then another solution which is uh

189
00:08:23,580 --> 00:08:25,500
much closer to what I'm going to talk

190
00:08:25,500 --> 00:08:28,379
about is uh one by

191
00:08:28,379 --> 00:08:31,680
well in that they develop in Monza

192
00:08:31,680 --> 00:08:34,799
um which uses linearly homomorphic

193
00:08:34,799 --> 00:08:37,740
encryption modulo to to Decay to produce

194
00:08:37,740 --> 00:08:39,659
this raw material

195
00:08:39,659 --> 00:08:41,580
and in particular the scheme that they

196
00:08:41,580 --> 00:08:45,420
use is the israeliver encryption skin

197
00:08:45,420 --> 00:08:48,300
uh which is linearly homomorphic and has

198
00:08:48,300 --> 00:08:50,399
a message based of Z over 2 to the KZ

199
00:08:50,399 --> 00:08:51,959
which is great

200
00:08:51,959 --> 00:08:54,720
but there's no known threshold

201
00:08:54,720 --> 00:08:56,160
decryption

202
00:08:56,160 --> 00:08:58,019
um for this scheme

203
00:08:58,019 --> 00:09:01,380
uh and in well under standard

204
00:09:01,380 --> 00:09:03,899
assumptions and in particular this means

205
00:09:03,899 --> 00:09:07,080
uh the in Monza they only have a

206
00:09:07,080 --> 00:09:10,740
two-party MPC protocol and

207
00:09:10,740 --> 00:09:11,519
um

208
00:09:11,519 --> 00:09:13,800
because each party has their own secret

209
00:09:13,800 --> 00:09:15,660
and public key instead of sharing the

210
00:09:15,660 --> 00:09:17,279
decryption key

211
00:09:17,279 --> 00:09:18,779
um they need to use zero knowledge

212
00:09:18,779 --> 00:09:21,600
proofs to prove to the parties that the

213
00:09:21,600 --> 00:09:24,120
other party that what they're doing is

214
00:09:24,120 --> 00:09:26,100
correct and so obviously these zero

215
00:09:26,100 --> 00:09:27,660
knowledge proofs have a negative impact

216
00:09:27,660 --> 00:09:30,779
on bandwidth and so the efficiency gains

217
00:09:30,779 --> 00:09:33,420
that one would have expected uh compared

218
00:09:33,420 --> 00:09:36,720
to say speed is 2K and not as big as we

219
00:09:36,720 --> 00:09:38,580
would like

220
00:09:38,580 --> 00:09:41,279
and so in our work what we do

221
00:09:41,279 --> 00:09:43,740
um is we create a

222
00:09:43,740 --> 00:09:46,380
threshold linearly homomorphic

223
00:09:46,380 --> 00:09:48,420
encryption scheme with a message they

224
00:09:48,420 --> 00:09:50,160
said over to to the ksaid which is

225
00:09:50,160 --> 00:09:51,660
exactly

226
00:09:51,660 --> 00:09:54,060
um what we need to

227
00:09:54,060 --> 00:09:55,860
fill this Gap and

228
00:09:55,860 --> 00:09:59,519
efficiently produce these triples

229
00:09:59,519 --> 00:10:02,839
and save on Van rope

230
00:10:04,200 --> 00:10:06,240
so I'll um

231
00:10:06,240 --> 00:10:09,300
first kind of give an abstract view of

232
00:10:09,300 --> 00:10:10,320
the

233
00:10:10,320 --> 00:10:12,300
tools that we use

234
00:10:12,300 --> 00:10:15,540
um to build our construction and how we

235
00:10:15,540 --> 00:10:17,700
build our scheme from from these

236
00:10:17,700 --> 00:10:21,120
abstract tools and later on I'll explain

237
00:10:21,120 --> 00:10:23,899
briefly how we realize this framework

238
00:10:23,899 --> 00:10:28,040
from class groups

239
00:10:28,640 --> 00:10:32,040
so the framework is quite similar to

240
00:10:32,040 --> 00:10:36,540
that of Casino from ctrsa 2015. we have

241
00:10:36,540 --> 00:10:41,040
a cyclic Group G of order s times 2 to

242
00:10:41,040 --> 00:10:43,920
the K where the gcd of s and 2 to the K

243
00:10:43,920 --> 00:10:45,180
is one

244
00:10:45,180 --> 00:10:48,540
we have a subgroup of G called f

245
00:10:48,540 --> 00:10:51,300
which is the 2 to the K which is 2 to

246
00:10:51,300 --> 00:10:53,399
the K roots of unity of G

247
00:10:53,399 --> 00:10:55,820
and is avoided to the k

248
00:10:55,820 --> 00:10:58,560
and there also exists an efficient

249
00:10:58,560 --> 00:11:00,120
algorithm for computing discrete

250
00:11:00,120 --> 00:11:02,760
logarithms in F so it means Computing x

251
00:11:02,760 --> 00:11:06,120
given F to the power x

252
00:11:06,120 --> 00:11:08,760
um and finally we have another Group H

253
00:11:08,760 --> 00:11:11,279
which is uh the subgroup of two to the K

254
00:11:11,279 --> 00:11:14,700
powers of G and is of a known order s

255
00:11:14,700 --> 00:11:17,459
and it holds that g is isomorphic to a

256
00:11:17,459 --> 00:11:20,820
direct product of F and H and and

257
00:11:20,820 --> 00:11:22,980
finally even though we don't know the

258
00:11:22,980 --> 00:11:24,899
order of s

259
00:11:24,899 --> 00:11:27,660
I mean the order s which is the order of

260
00:11:27,660 --> 00:11:29,940
H and hence the order of G is also

261
00:11:29,940 --> 00:11:32,339
unknown we do know an upper bound s

262
00:11:32,339 --> 00:11:34,040
tilde phase

263
00:11:34,040 --> 00:11:37,620
and the security assumption that we use

264
00:11:37,620 --> 00:11:40,620
in this framework is a hard subgroup

265
00:11:40,620 --> 00:11:43,019
membership assumption which essentially

266
00:11:43,019 --> 00:11:45,060
states that F1

267
00:11:45,060 --> 00:11:47,940
um samples a random element from the

268
00:11:47,940 --> 00:11:51,540
subgroup H or a random element from the

269
00:11:51,540 --> 00:11:54,959
subgroup page multiplied by the

270
00:11:54,959 --> 00:11:57,180
generator F raised to the power some

271
00:11:57,180 --> 00:12:00,019
invertible elements modulo 2 to the k

272
00:12:00,019 --> 00:12:03,079
then both elements should be

273
00:12:03,079 --> 00:12:06,540
computationally indistinguishable

274
00:12:06,540 --> 00:12:09,140
foreign

275
00:12:10,339 --> 00:12:13,980
and so to build a

276
00:12:13,980 --> 00:12:16,200
public key encryption scheme funds that

277
00:12:16,200 --> 00:12:19,620
over to the KZ from this uh the scheme

278
00:12:19,620 --> 00:12:21,480
is fairly simple it looks like

279
00:12:21,480 --> 00:12:24,600
El gamma in the exponent uh so we we

280
00:12:24,600 --> 00:12:26,220
sample the secret key from a

281
00:12:26,220 --> 00:12:28,680
distribution uh which is close to

282
00:12:28,680 --> 00:12:31,860
uniform which induces a distribution

283
00:12:31,860 --> 00:12:35,040
close to uniform over h

284
00:12:35,040 --> 00:12:36,899
um and the public key is just the

285
00:12:36,899 --> 00:12:38,700
generator of H raised to the power of

286
00:12:38,700 --> 00:12:40,980
the secret key

287
00:12:40,980 --> 00:12:43,380
um to encrypt a message M instead over

288
00:12:43,380 --> 00:12:45,180
to the KZ

289
00:12:45,180 --> 00:12:48,800
we sample a random element R in this

290
00:12:48,800 --> 00:12:52,399
distribution DH

291
00:12:52,440 --> 00:12:55,139
um and then we compute uh first cycle

292
00:12:55,139 --> 00:12:57,000
text element which is

293
00:12:57,000 --> 00:12:59,820
H to the power R and the second in the

294
00:12:59,820 --> 00:13:01,500
second part of the ciphertext we encode

295
00:13:01,500 --> 00:13:04,200
the message in the exponent of the

296
00:13:04,200 --> 00:13:06,779
generator F and

297
00:13:06,779 --> 00:13:09,720
um we mask this with the public key

298
00:13:09,720 --> 00:13:12,540
raised to the power R and the ciphertext

299
00:13:12,540 --> 00:13:16,399
is both elements C1 and C2

300
00:13:16,440 --> 00:13:21,360
um finally to decrypt uh one multiplies

301
00:13:21,360 --> 00:13:23,760
the second part of the component C2 by

302
00:13:23,760 --> 00:13:27,000
C1 raised to the power minus s k

303
00:13:27,000 --> 00:13:30,000
and this should be equal if this is a

304
00:13:30,000 --> 00:13:33,959
correct ciphertext to F to the power M

305
00:13:33,959 --> 00:13:36,540
um and so here we check if the mess if

306
00:13:36,540 --> 00:13:38,820
the resulting capital M is in the

307
00:13:38,820 --> 00:13:40,680
subgroup f

308
00:13:40,680 --> 00:13:42,240
if not

309
00:13:42,240 --> 00:13:44,639
um then the ciphertext is badly formed

310
00:13:44,639 --> 00:13:47,760
and we the ciphertex have rejected and

311
00:13:47,760 --> 00:13:50,160
if so we return

312
00:13:50,160 --> 00:13:52,620
the discrete logarithm in base F of

313
00:13:52,620 --> 00:13:55,079
capital M which as I mentioned earlier

314
00:13:55,079 --> 00:13:58,699
is efficiently computable

315
00:13:59,639 --> 00:14:02,160
um and so it's quite easy to see that

316
00:14:02,160 --> 00:14:04,320
this scheme is also linearly homomorphic

317
00:14:04,320 --> 00:14:06,480
in order to

318
00:14:06,480 --> 00:14:09,360
add plain texts which are underlying to

319
00:14:09,360 --> 00:14:12,060
ciphertext you just multiply the two

320
00:14:12,060 --> 00:14:14,220
ciphertexts component wise and then

321
00:14:14,220 --> 00:14:17,880
re-randomize the resulting ciphertext

322
00:14:17,880 --> 00:14:21,480
and similarly to perform scalar

323
00:14:21,480 --> 00:14:24,300
multiplication wonders raises each

324
00:14:24,300 --> 00:14:26,040
ciphertext component

325
00:14:26,040 --> 00:14:28,260
to the power of the scalar Alpha and

326
00:14:28,260 --> 00:14:30,420
then re-randomizes the resulting

327
00:14:30,420 --> 00:14:33,079
ciphertext

328
00:14:33,839 --> 00:14:36,839
um for security I'm basically uh going

329
00:14:36,839 --> 00:14:40,320
to follow a kind of game based approach

330
00:14:40,320 --> 00:14:40,980
um

331
00:14:40,980 --> 00:14:44,100
so I'm going to perform little changes

332
00:14:44,100 --> 00:14:48,959
to the original encryption scheme which

333
00:14:48,959 --> 00:14:52,079
um I'm going to justify are noticeable

334
00:14:52,079 --> 00:14:54,959
to anyone who's looking at the

335
00:14:54,959 --> 00:14:56,699
scheme from an outsider's perspective

336
00:14:56,699 --> 00:14:59,820
who doesn't know the secret key

337
00:14:59,820 --> 00:15:00,540
um

338
00:15:00,540 --> 00:15:02,180
and um

339
00:15:02,180 --> 00:15:03,720
[Music]

340
00:15:03,720 --> 00:15:06,600
and then I'll get to a point where the

341
00:15:06,600 --> 00:15:10,920
message is statistically hidden um and

342
00:15:10,920 --> 00:15:12,480
since

343
00:15:12,480 --> 00:15:15,300
if we have a simulated game a simulated

344
00:15:15,300 --> 00:15:17,339
like encryption scheme where the message

345
00:15:17,339 --> 00:15:19,860
is statistically hidden and that's

346
00:15:19,860 --> 00:15:22,320
indistinguishable from the real scheme

347
00:15:22,320 --> 00:15:24,420
um then we'll be convinced that the real

348
00:15:24,420 --> 00:15:27,680
encryption scheme is secure

349
00:15:28,079 --> 00:15:30,420
um so the first change that we do from

350
00:15:30,420 --> 00:15:32,040
our original encryption scheme is

351
00:15:32,040 --> 00:15:33,720
instead of sampling the secret key from

352
00:15:33,720 --> 00:15:36,180
a distribution uh

353
00:15:36,180 --> 00:15:37,560
which

354
00:15:37,560 --> 00:15:40,260
induces a uniform distribution over H

355
00:15:40,260 --> 00:15:42,899
we're going to sample it from a

356
00:15:42,899 --> 00:15:45,600
distribution which is close to uniform

357
00:15:45,600 --> 00:15:48,360
modulo s times 2 to the K and so induces

358
00:15:48,360 --> 00:15:50,279
a distribution

359
00:15:50,279 --> 00:15:52,740
uniform over G

360
00:15:52,740 --> 00:15:56,040
and because uh the order of H divides

361
00:15:56,040 --> 00:15:58,620
the order of g s divides s times 2 to

362
00:15:58,620 --> 00:16:02,339
the K this changes a noticeable given

363
00:16:02,339 --> 00:16:05,459
only the public key and the rest of the

364
00:16:05,459 --> 00:16:07,260
scheme

365
00:16:07,260 --> 00:16:07,800
um

366
00:16:07,800 --> 00:16:10,260
the next change we do is purely

367
00:16:10,260 --> 00:16:12,959
conceptual so we compute C2 in a

368
00:16:12,959 --> 00:16:14,639
different way instead of computing the

369
00:16:14,639 --> 00:16:16,740
second part of the ciphertext as F to

370
00:16:16,740 --> 00:16:19,199
the power M times PK to the power R

371
00:16:19,199 --> 00:16:21,240
we're going to compute it as F to the

372
00:16:21,240 --> 00:16:24,540
power M times C1 to the power SK but

373
00:16:24,540 --> 00:16:26,220
these are actually exactly the same

374
00:16:26,220 --> 00:16:28,459
they're just computed in a different way

375
00:16:28,459 --> 00:16:30,019
because

376
00:16:30,019 --> 00:16:35,040
C1 is H to the power R and P K is K to

377
00:16:35,040 --> 00:16:37,860
the power s k so p k to the power R and

378
00:16:37,860 --> 00:16:41,779
C1 to the power SK are the same thing

379
00:16:42,240 --> 00:16:44,940
the final change we do is

380
00:16:44,940 --> 00:16:48,300
um we sample an extra element u in Z

381
00:16:48,300 --> 00:16:50,519
over 2 to the K in the invertables of Z

382
00:16:50,519 --> 00:16:53,279
over 2 to the KZ and we multiply the

383
00:16:53,279 --> 00:16:55,980
first part of the ciphertext

384
00:16:55,980 --> 00:16:58,620
um H which was H to the R by F to the

385
00:16:58,620 --> 00:16:59,759
power U

386
00:16:59,759 --> 00:17:04,380
H and so now we can notice that uh

387
00:17:04,380 --> 00:17:07,020
the first part of the ciphertext in our

388
00:17:07,020 --> 00:17:08,880
in our previous game and the first part

389
00:17:08,880 --> 00:17:10,339
of the slave takes now

390
00:17:10,339 --> 00:17:12,839
are um

391
00:17:12,839 --> 00:17:16,079
so basically the two elements that one

392
00:17:16,079 --> 00:17:19,799
tries to distinguish in uh the hs72k

393
00:17:19,799 --> 00:17:20,760
problem

394
00:17:20,760 --> 00:17:23,819
and so if there's hsm2k assumption holds

395
00:17:23,819 --> 00:17:25,380
uh

396
00:17:25,380 --> 00:17:27,660
which we assume it does we're ensured

397
00:17:27,660 --> 00:17:31,760
that this change is indistinguishable

398
00:17:32,040 --> 00:17:34,559
so now uh we're in this like final

399
00:17:34,559 --> 00:17:36,660
simulation game which we've established

400
00:17:36,660 --> 00:17:39,720
is like indistinguishable from the real

401
00:17:39,720 --> 00:17:43,679
encryption scheme and here we can see

402
00:17:43,679 --> 00:17:45,480
that the information it can potentially

403
00:17:45,480 --> 00:17:47,520
be leaked on the message is contained in

404
00:17:47,520 --> 00:17:51,120
C2 which is f to the power M plus u

405
00:17:51,120 --> 00:17:53,820
times s k times b k to the power R I've

406
00:17:53,820 --> 00:17:58,380
just Rewritten this by developing C1

407
00:17:58,380 --> 00:18:02,940
and so an unbounded adversary would at

408
00:18:02,940 --> 00:18:05,880
most uh be able to deduce from this uh

409
00:18:05,880 --> 00:18:09,660
the value of M plus u times s k modulo 2

410
00:18:09,660 --> 00:18:12,380
to the power k

411
00:18:14,160 --> 00:18:17,520
um and here the secret K the secret key

412
00:18:17,520 --> 00:18:20,880
SK was sampled from a distribution which

413
00:18:20,880 --> 00:18:24,480
was close to uniform modulo s times 2 to

414
00:18:24,480 --> 00:18:27,179
the K so even though the value of SK is

415
00:18:27,179 --> 00:18:30,120
information theoretically fixed modulo s

416
00:18:30,120 --> 00:18:32,220
because of the public key which reveals

417
00:18:32,220 --> 00:18:34,620
H to the power SK

418
00:18:34,620 --> 00:18:38,100
the value of SK remains close to uniform

419
00:18:38,100 --> 00:18:41,220
modulo 2 to the K because s and 2 to the

420
00:18:41,220 --> 00:18:43,080
K are Co Prime

421
00:18:43,080 --> 00:18:47,580
and 2 to the K divides the order of

422
00:18:47,580 --> 00:18:48,900
T

423
00:18:48,900 --> 00:18:51,120
um so we have SK which is close to

424
00:18:51,120 --> 00:18:53,880
uniform modulo 2K here we have U which

425
00:18:53,880 --> 00:18:56,520
is chosen to be invertible modulo 2K and

426
00:18:56,520 --> 00:19:00,679
so the product of U times SK

427
00:19:01,260 --> 00:19:04,679
um is uh close to uniform modulus UK and

428
00:19:04,679 --> 00:19:08,520
so perfectly oops masks are on our

429
00:19:08,520 --> 00:19:10,620
message or statistic emasks our message

430
00:19:10,620 --> 00:19:13,500
M and this is what we wanted to prove

431
00:19:13,500 --> 00:19:15,679
security

432
00:19:17,460 --> 00:19:21,299
um and finally uh to make this scheme uh

433
00:19:21,299 --> 00:19:23,340
not to obtain a threshold decryption for

434
00:19:23,340 --> 00:19:26,340
our scheme uh we just noticed that the

435
00:19:26,340 --> 00:19:28,679
decryption key SK is

436
00:19:28,679 --> 00:19:31,640
only used in decryption for explanation

437
00:19:31,640 --> 00:19:34,919
to this secret key in the group of a

438
00:19:34,919 --> 00:19:36,419
known order h

439
00:19:36,419 --> 00:19:38,400
and so we use

440
00:19:38,400 --> 00:19:42,120
um linear integer secret sharing uh to

441
00:19:42,120 --> 00:19:43,860
share the decryption key over the

442
00:19:43,860 --> 00:19:46,919
integers and um so our resulting scheme

443
00:19:46,919 --> 00:19:48,660
allows any access structure for the

444
00:19:48,660 --> 00:19:50,460
decryption policy and in particular

445
00:19:50,460 --> 00:19:53,600
threshold decryption

446
00:19:55,620 --> 00:19:57,840
um and so how do we realize this

447
00:19:57,840 --> 00:20:00,480
abstract framework from class groups

448
00:20:00,480 --> 00:20:03,720
well we start from uh the original CL

449
00:20:03,720 --> 00:20:05,160
framework

450
00:20:05,160 --> 00:20:07,500
um in their framework they provide us

451
00:20:07,500 --> 00:20:08,940
very similar abstraction the main

452
00:20:08,940 --> 00:20:10,679
difference being that the subgroup F

453
00:20:10,679 --> 00:20:12,900
which encodes messages is of prime order

454
00:20:12,900 --> 00:20:13,980
queue

455
00:20:13,980 --> 00:20:17,360
in their work they have two class groups

456
00:20:17,360 --> 00:20:21,780
uh one with the fundament of with the

457
00:20:21,780 --> 00:20:23,520
fundamental discriminant Delta K which

458
00:20:23,520 --> 00:20:26,160
is set to minus P times Q at p and Q at

459
00:20:26,160 --> 00:20:27,960
Prime and

460
00:20:27,960 --> 00:20:28,620
um

461
00:20:28,620 --> 00:20:30,900
the class group of non-maximal order of

462
00:20:30,900 --> 00:20:33,960
discriminant minus P times Q cubed

463
00:20:33,960 --> 00:20:37,520
in this setting we can

464
00:20:38,059 --> 00:20:40,980
create a subjection between the class

465
00:20:40,980 --> 00:20:42,539
group of the maximal order and the

466
00:20:42,539 --> 00:20:44,760
cluster of the non-max sorry the class

467
00:20:44,760 --> 00:20:46,020
group of the non-maximal order in the

468
00:20:46,020 --> 00:20:47,460
class group

469
00:20:47,460 --> 00:20:49,559
none and the Maxwell order

470
00:20:49,559 --> 00:20:53,220
um and whose kernel is um

471
00:20:53,220 --> 00:20:55,620
of order q and we're going to set the

472
00:20:55,620 --> 00:20:58,260
subgroup F to be

473
00:20:58,260 --> 00:21:02,400
um the this kernel of order q and it

474
00:21:02,400 --> 00:21:05,400
would be great if we could just plug Q

475
00:21:05,400 --> 00:21:07,500
equals 2 to the k

476
00:21:07,500 --> 00:21:12,360
um and get our resulting scheme

477
00:21:12,360 --> 00:21:14,039
I mean setting

478
00:21:14,039 --> 00:21:16,799
um but that unfortunately doesn't work

479
00:21:16,799 --> 00:21:19,320
for various reasons but the main problem

480
00:21:19,320 --> 00:21:21,720
is that um

481
00:21:21,720 --> 00:21:23,640
if you know the factorization of the

482
00:21:23,640 --> 00:21:26,039
discriminant which is the case uh in the

483
00:21:26,039 --> 00:21:28,620
original CL you can compute square roots

484
00:21:28,620 --> 00:21:30,299
and you can decide if elements are

485
00:21:30,299 --> 00:21:34,020
squares and if that's the case uh the

486
00:21:34,020 --> 00:21:36,900
hardness assumption hsm2k doesn't hold

487
00:21:36,900 --> 00:21:39,179
at all it's completely broken

488
00:21:39,179 --> 00:21:41,580
so we need to

489
00:21:41,580 --> 00:21:44,640
um have a setting where Computing square

490
00:21:44,640 --> 00:21:47,760
roots is hard and so that means that the

491
00:21:47,760 --> 00:21:50,039
factorization of the discriminant cannot

492
00:21:50,039 --> 00:21:51,539
be known and so we build our

493
00:21:51,539 --> 00:21:55,260
discriminant from an RSA integer n

494
00:21:55,260 --> 00:21:56,580
foreign

495
00:21:56,580 --> 00:21:59,400
but we can't choose any n we have to be

496
00:21:59,400 --> 00:22:01,799
careful in particular if we looking into

497
00:22:01,799 --> 00:22:05,220
the geosphere Associated to class groups

498
00:22:05,220 --> 00:22:06,360
um

499
00:22:06,360 --> 00:22:09,360
one can see that some Genera can leak

500
00:22:09,360 --> 00:22:12,120
information on discrete logarithms

501
00:22:12,120 --> 00:22:14,880
and so we have to carefully select the

502
00:22:14,880 --> 00:22:18,000
discriminants and hence uh the RSA

503
00:22:18,000 --> 00:22:20,220
integer n which will allow us to

504
00:22:20,220 --> 00:22:22,559
securely work with the group of squares

505
00:22:22,559 --> 00:22:25,399
of the class group

506
00:22:27,659 --> 00:22:30,860
um okay last but not least performance

507
00:22:30,860 --> 00:22:35,159
so we did do an implementation in our um

508
00:22:35,159 --> 00:22:39,799
paper but since then uh

509
00:22:42,500 --> 00:22:45,320
have implemented a

510
00:22:45,320 --> 00:22:48,179
library from scratch in CNC plus plus

511
00:22:48,179 --> 00:22:51,240
called bicycle which improves our

512
00:22:51,240 --> 00:22:54,720
timings so I'm providing these better

513
00:22:54,720 --> 00:22:55,980
timings

514
00:22:55,980 --> 00:22:57,120
um

515
00:22:57,120 --> 00:23:00,240
so yeah as you can see

516
00:23:00,240 --> 00:23:02,340
decryption is

517
00:23:02,340 --> 00:23:06,419
for like a message Space 2 to the 64 and

518
00:23:06,419 --> 00:23:09,419
128 bits of security our decryption is

519
00:23:09,419 --> 00:23:12,840
only like 40 milliseconds which is uh

520
00:23:12,840 --> 00:23:16,919
very efficient so yeah that's basically

521
00:23:16,919 --> 00:23:18,659
it thank you very much for your

522
00:23:18,659 --> 00:23:20,580
attention and uh if you have any

523
00:23:20,580 --> 00:23:22,080
questions I'd be

524
00:23:22,080 --> 00:23:25,460
happy to try and answer them

525
00:23:53,520 --> 00:23:55,320
or maybe there's not much time for

526
00:23:55,320 --> 00:23:58,020
questions because I went over time

527
00:23:58,020 --> 00:24:00,620
please

528
00:25:26,900 --> 00:25:30,980
hi uh can you hear me

529
00:25:52,980 --> 00:25:55,520
hello

530
00:26:01,500 --> 00:26:04,500
hello

531
00:26:14,279 --> 00:26:15,600
okay

532
00:26:15,600 --> 00:26:18,919
um I guess you can hear me uh

533
00:26:18,919 --> 00:26:22,980
okay thanks uh okay hi uh I'm sorry Elio

534
00:26:22,980 --> 00:26:25,380
today I'm gonna present large Precision

535
00:26:25,380 --> 00:26:28,200
homomorphic sign evaluation using a few

536
00:26:28,200 --> 00:26:30,659
TV sheep bootstrapping this is a short

537
00:26:30,659 --> 00:26:32,880
work with Daniela michancho and Yuri

538
00:26:32,880 --> 00:26:34,940
polakov

539
00:26:34,940 --> 00:26:37,919
let me start by some background

540
00:26:37,919 --> 00:26:40,679
information so uh what's functional or

541
00:26:40,679 --> 00:26:43,380
programmable bootstrapping basically

542
00:26:43,380 --> 00:26:45,659
means that we can evaluate in a cyclic

543
00:26:45,659 --> 00:26:47,820
function uh through lookup table for

544
00:26:47,820 --> 00:26:49,380
free while also performing some

545
00:26:49,380 --> 00:26:51,600
bootstrapping over some LTE server texts

546
00:26:51,600 --> 00:26:54,659
this is first introduced in dm15

547
00:26:54,659 --> 00:26:57,659
and it has two requirements or two

548
00:26:57,659 --> 00:26:59,460
constraints the first one is that it

549
00:26:59,460 --> 00:27:01,140
requires the function to be next cyclic

550
00:27:01,140 --> 00:27:03,299
and what does it mean by next cyclic

551
00:27:03,299 --> 00:27:06,440
basically means that for an input in zq

552
00:27:06,440 --> 00:27:09,779
the function needs to to satisfy that f

553
00:27:09,779 --> 00:27:13,020
of x equals to negative of f of x plus

554
00:27:13,020 --> 00:27:14,520
qr2

555
00:27:14,520 --> 00:27:17,100
the second constraint is that it can

556
00:27:17,100 --> 00:27:18,779
only evaluate functions over messages

557
00:27:18,779 --> 00:27:20,940
with Optical bits of precision and

558
00:27:20,940 --> 00:27:23,880
usually K is equal to 5 or 6. the reason

559
00:27:23,880 --> 00:27:26,820
is that uh its runtime is exponential in

560
00:27:26,820 --> 00:27:29,760
the number of bits and um for the number

561
00:27:29,760 --> 00:27:32,220
of bits Beyond 506 the runtime will

562
00:27:32,220 --> 00:27:35,600
become quite impractical

563
00:27:35,820 --> 00:27:38,520
and we will use this notation for uh

564
00:27:38,520 --> 00:27:40,500
bootstrapping so basically we use boot

565
00:27:40,500 --> 00:27:43,620
for some function f over X and it will

566
00:27:43,620 --> 00:27:45,380
output the

567
00:27:45,380 --> 00:27:48,539
ciphertext that's encrypting f of x for

568
00:27:48,539 --> 00:27:51,000
some neglect click function f from DP to

569
00:27:51,000 --> 00:27:54,120
zq and this p and Q can be different but

570
00:27:54,120 --> 00:27:56,400
for Simplicity you may assume that P and

571
00:27:56,400 --> 00:27:59,240
Q are the same number

572
00:27:59,240 --> 00:28:02,520
there are two uh bootstrapping methods

573
00:28:02,520 --> 00:28:04,740
available now and uh the the first one

574
00:28:04,740 --> 00:28:07,799
is a few introduced in dm15 it

575
00:28:07,799 --> 00:28:09,659
efficiently supports arbitrary Secrets

576
00:28:09,659 --> 00:28:11,520
but the constructing key size is

577
00:28:11,520 --> 00:28:14,279
relatively large and the second is tfhe

578
00:28:14,279 --> 00:28:17,400
introduced in ctgi 16 it provides a

579
00:28:17,400 --> 00:28:19,020
better runtime performance for small

580
00:28:19,020 --> 00:28:21,000
Secrets like like binary or ternary

581
00:28:21,000 --> 00:28:23,100
secret and the bootstrapping key size is

582
00:28:23,100 --> 00:28:24,419
much smaller

583
00:28:24,419 --> 00:28:27,659
please CMP uh 21 for a more detailed

584
00:28:27,659 --> 00:28:28,620
comparison

585
00:28:28,620 --> 00:28:30,480
and we use this functional bootstrapping

586
00:28:30,480 --> 00:28:32,940
methods as a black box so either of the

587
00:28:32,940 --> 00:28:35,159
two work for us uh it's the same state

588
00:28:35,159 --> 00:28:38,640
serves the exact same uh functionality

589
00:28:38,640 --> 00:28:40,320
there's another bootstrapping method

590
00:28:40,320 --> 00:28:42,360
that's recently developed and can be

591
00:28:42,360 --> 00:28:44,460
applied as well but it's not included in

592
00:28:44,460 --> 00:28:46,679
this work but because the the paper is

593
00:28:46,679 --> 00:28:48,960
published before the new method is

594
00:28:48,960 --> 00:28:51,500
proposed

595
00:28:52,559 --> 00:28:55,500
uh so the main results of our work so at

596
00:28:55,500 --> 00:28:58,140
a very high level we uh introduced some

597
00:28:58,140 --> 00:29:02,460
new tools uh to this a few TVG line of

598
00:29:02,460 --> 00:29:04,260
work to make the schemes more powerful

599
00:29:04,260 --> 00:29:06,659
more specifically first we introduce

600
00:29:06,659 --> 00:29:10,020
some large Precision comparisons so why

601
00:29:10,020 --> 00:29:12,480
comparisons uh comparisons are widely

602
00:29:12,480 --> 00:29:14,760
used in machine learning like in CN

603
00:29:14,760 --> 00:29:17,340
inference or DTC training and then and

604
00:29:17,340 --> 00:29:19,020
the data science

605
00:29:19,020 --> 00:29:21,059
and comparisons are usually considered

606
00:29:21,059 --> 00:29:23,760
hard for SVG schemes and privacy

607
00:29:23,760 --> 00:29:26,760
preserving ml or DS is an essential case

608
00:29:26,760 --> 00:29:28,799
for Fe

609
00:29:28,799 --> 00:29:32,279
currently the runtime for uh for uh this

610
00:29:32,279 --> 00:29:34,679
is exponential with the bits of

611
00:29:34,679 --> 00:29:36,179
precision and we want to make the

612
00:29:36,179 --> 00:29:38,700
runtime linear scale

613
00:29:38,700 --> 00:29:40,679
the second tool is more General and more

614
00:29:40,679 --> 00:29:42,960
powerful we provide the way to do a

615
00:29:42,960 --> 00:29:44,640
large Precision arbitrary function

616
00:29:44,640 --> 00:29:46,260
evaluation

617
00:29:46,260 --> 00:29:48,779
as mentioned before now it only supports

618
00:29:48,779 --> 00:29:51,179
phonak a cyclic function and only small

619
00:29:51,179 --> 00:29:53,480
supports for small precision

620
00:29:53,480 --> 00:29:56,039
uh we have implemented our schemes and

621
00:29:56,039 --> 00:29:57,899
the implementation is open source in

622
00:29:57,899 --> 00:30:01,760
open fvg and Palestine libraries

623
00:30:02,039 --> 00:30:03,960
so let's start from some high level

624
00:30:03,960 --> 00:30:04,860
ideas

625
00:30:04,860 --> 00:30:07,919
one of the one observation we have is

626
00:30:07,919 --> 00:30:09,720
that the comparison is equivalent to

627
00:30:09,720 --> 00:30:11,880
sign evaluation

628
00:30:11,880 --> 00:30:14,580
to compare two two numbers A and B we

629
00:30:14,580 --> 00:30:17,840
just need to find the sine of a minus B

630
00:30:17,840 --> 00:30:20,340
and another observation is that the sign

631
00:30:20,340 --> 00:30:22,200
evaluation is equivalent to Computing

632
00:30:22,200 --> 00:30:24,240
the most significant bits

633
00:30:24,240 --> 00:30:26,940
Computing the most significant bit is

634
00:30:26,940 --> 00:30:28,740
the central part of you or TV cheap

635
00:30:28,740 --> 00:30:30,480
bootstrapping but as mentioned that it

636
00:30:30,480 --> 00:30:34,340
only supports for up to say k bits

637
00:30:34,340 --> 00:30:36,960
therefore our uh key technique is that

638
00:30:36,960 --> 00:30:38,760
we try to remove the large number of

639
00:30:38,760 --> 00:30:40,140
stitches gradually

640
00:30:40,140 --> 00:30:41,940
for example if you take a look at this

641
00:30:41,940 --> 00:30:44,399
18-bit number we just remove the last

642
00:30:44,399 --> 00:30:46,620
six bits and then remove the middle six

643
00:30:46,620 --> 00:30:49,080
bits we have only six bits left we can

644
00:30:49,080 --> 00:30:51,779
uh we can perform some few or TV cheaper

645
00:30:51,779 --> 00:30:52,919
strapping to extract the most

646
00:30:52,919 --> 00:30:54,720
significant bits

647
00:30:54,720 --> 00:30:58,260
foreign so uh to do large Precision

648
00:30:58,260 --> 00:31:00,720
comparison we first used a floor

649
00:31:00,720 --> 00:31:02,940
function first to run down the last K

650
00:31:02,940 --> 00:31:05,580
bits so if we have this 12-bit number we

651
00:31:05,580 --> 00:31:08,640
just make the last six that's zeros and

652
00:31:08,640 --> 00:31:11,220
then we divide this result uh by

653
00:31:11,220 --> 00:31:13,500
teaching the K where to the case equal

654
00:31:13,500 --> 00:31:16,140
to 6 here using module switching and

655
00:31:16,140 --> 00:31:18,600
this will make this topic number into a

656
00:31:18,600 --> 00:31:20,279
six bit number

657
00:31:20,279 --> 00:31:22,799
we cannot directly use module switching

658
00:31:22,799 --> 00:31:25,679
to round down the original uh six bit uh

659
00:31:25,679 --> 00:31:28,500
12-bit number because a module switching

660
00:31:28,500 --> 00:31:30,360
is performing a rounding instead of

661
00:31:30,360 --> 00:31:32,580
flooring which will cause errors for

662
00:31:32,580 --> 00:31:35,779
some values near the boundary

663
00:31:35,779 --> 00:31:38,460
and then we repeat this procedure for

664
00:31:38,460 --> 00:31:40,620
each digit as mentioned before after

665
00:31:40,620 --> 00:31:42,720
there are at most like keep bits left we

666
00:31:42,720 --> 00:31:44,700
can perform a regular fuse shopping to

667
00:31:44,700 --> 00:31:47,779
extract the most significant bit

668
00:31:47,779 --> 00:31:50,640
this one question remains is that the

669
00:31:50,640 --> 00:31:53,159
flow function is not necessary so how

670
00:31:53,159 --> 00:31:56,179
can we evaluate it

671
00:31:57,419 --> 00:31:59,940
so let me ask a question what is really

672
00:31:59,940 --> 00:32:01,500
a flow function a flow function is

673
00:32:01,500 --> 00:32:03,059
basically would give you a number and

674
00:32:03,059 --> 00:32:05,899
you make the last case at zero

675
00:32:05,899 --> 00:32:09,240
uh so we achieved this functionality by

676
00:32:09,240 --> 00:32:11,100
invoking the function of the functional

677
00:32:11,100 --> 00:32:13,080
bootstrapping twice for uh with two

678
00:32:13,080 --> 00:32:16,620
different Mega cyclic functions

679
00:32:16,620 --> 00:32:18,840
we first clear the most significant bit

680
00:32:18,840 --> 00:32:21,899
of the last K bits so for a and the

681
00:32:21,899 --> 00:32:25,740
number from B1 to PN uh the last qubits

682
00:32:25,740 --> 00:32:27,659
are from here to here and we just clear

683
00:32:27,659 --> 00:32:29,760
the most significant bits of the elastic

684
00:32:29,760 --> 00:32:32,360
at last cables

685
00:32:32,360 --> 00:32:34,740
we cleared this up by using the

686
00:32:34,740 --> 00:32:36,299
following function you can double check

687
00:32:36,299 --> 00:32:38,880
that this is indeed Mega cyclic so this

688
00:32:38,880 --> 00:32:41,039
can be achieved by evoking one

689
00:32:41,039 --> 00:32:42,600
functional bootstrapping with this

690
00:32:42,600 --> 00:32:44,220
function

691
00:32:44,220 --> 00:32:46,860
and then we clear the the rest of the K

692
00:32:46,860 --> 00:32:49,799
minus one bits I.E the bits here uh and

693
00:32:49,799 --> 00:32:51,480
we achieve this by using the second

694
00:32:51,480 --> 00:32:53,159
function here and again you can double

695
00:32:53,159 --> 00:32:57,200
check this is indeed a mega cyclic

696
00:32:57,200 --> 00:33:00,419
uh this is our pseudo code uh as

697
00:33:00,419 --> 00:33:02,640
mentioned before for the floor function

698
00:33:02,640 --> 00:33:06,419
we first use the F0 to remove the most

699
00:33:06,419 --> 00:33:09,059
significant bit of the last key bits and

700
00:33:09,059 --> 00:33:11,279
then we used F1 to remove the last

701
00:33:11,279 --> 00:33:14,760
Cayman swamp bits and we we process this

702
00:33:14,760 --> 00:33:18,360
uh we use this floor function digit by

703
00:33:18,360 --> 00:33:22,080
digit until we have only log qubits I.E

704
00:33:22,080 --> 00:33:25,140
the K bits left and then we can use the

705
00:33:25,140 --> 00:33:29,279
original few or TVG bootstrapping to

706
00:33:29,279 --> 00:33:32,779
extract the most significant bit

707
00:33:32,779 --> 00:33:35,820
uh now let's talk about a uh the more

708
00:33:35,820 --> 00:33:37,980
General Tool uh the arbitrary function

709
00:33:37,980 --> 00:33:39,899
evaluation let's start with some small

710
00:33:39,899 --> 00:33:43,260
context module uh the the first

711
00:33:43,260 --> 00:33:45,659
constraint we need to get rid of is that

712
00:33:45,659 --> 00:33:48,179
the view or TV cheat bootstrapping will

713
00:33:48,179 --> 00:33:50,460
require the input function to be next I

714
00:33:50,460 --> 00:33:52,279
click

715
00:33:52,279 --> 00:33:55,140
so uh can we make the function arbitrary

716
00:33:55,140 --> 00:33:57,000
like remove the mega satellite property

717
00:33:57,000 --> 00:33:59,700
requirements uh similar to the flow

718
00:33:59,700 --> 00:34:01,320
function we can use two functions to

719
00:34:01,320 --> 00:34:03,779
achieve this functionality we first

720
00:34:03,779 --> 00:34:05,940
remove the most significant bits of the

721
00:34:05,940 --> 00:34:07,620
input

722
00:34:07,620 --> 00:34:08,940
sorry

723
00:34:08,940 --> 00:34:10,800
and then for the rest of the bits we'll

724
00:34:10,800 --> 00:34:12,659
be able to evaluate an arbitrary

725
00:34:12,659 --> 00:34:15,780
function upon because and uh after

726
00:34:15,780 --> 00:34:17,639
removing the most significant bit we can

727
00:34:17,639 --> 00:34:20,699
just use a mega secular function to with

728
00:34:20,699 --> 00:34:24,000
KPS to represent a an arbitrary function

729
00:34:24,000 --> 00:34:26,099
with K minus one bits

730
00:34:26,099 --> 00:34:27,839
but then how about the most significant

731
00:34:27,839 --> 00:34:28,918
bits

732
00:34:28,918 --> 00:34:31,379
uh we it turns out that we

733
00:34:31,379 --> 00:34:33,780
met with modulus from Q to the 2 to 2q

734
00:34:33,780 --> 00:34:36,179
then it will introduce a random most

735
00:34:36,179 --> 00:34:38,580
significant bit to the input so

736
00:34:38,580 --> 00:34:42,239
basically with a uh km cable input we

737
00:34:42,239 --> 00:34:45,119
will raise the modulus to uh Q from Q to

738
00:34:45,119 --> 00:34:47,760
q and then the input will become K plus

739
00:34:47,760 --> 00:34:49,980
1 bits and then we remove this redundant

740
00:34:49,980 --> 00:34:52,320
random bit and then we can perform a

741
00:34:52,320 --> 00:34:54,659
Nega cyclic function uh an arbitrary

742
00:34:54,659 --> 00:34:56,119
function evaluation

743
00:34:56,119 --> 00:34:58,980
using the original view or TVG plus

744
00:34:58,980 --> 00:35:02,099
dropping uh here's a pseudo code this is

745
00:35:02,099 --> 00:35:04,380
a function we use to remove the most

746
00:35:04,380 --> 00:35:06,060
significant bits again you can you can

747
00:35:06,060 --> 00:35:08,640
check that this is indeed negative

748
00:35:08,640 --> 00:35:11,339
cyclic and uh for the function for the

749
00:35:11,339 --> 00:35:12,960
input function we'll use a like a

750
00:35:12,960 --> 00:35:14,820
circular function to represent it but

751
00:35:14,820 --> 00:35:17,280
since the most significant bit is clear

752
00:35:17,280 --> 00:35:19,320
to zero one of the branches will not be

753
00:35:19,320 --> 00:35:20,460
used at all

754
00:35:20,460 --> 00:35:24,180
and here we first remove the one bit and

755
00:35:24,180 --> 00:35:26,520
then we evaluate this aperture function

756
00:35:26,520 --> 00:35:29,720
uh on the input

757
00:35:30,660 --> 00:35:33,180
uh so now let's talk about how can we

758
00:35:33,180 --> 00:35:36,240
make this uh the small Precision into

759
00:35:36,240 --> 00:35:37,980
large precision

760
00:35:37,980 --> 00:35:41,160
we did this first by uh breaking a large

761
00:35:41,160 --> 00:35:43,260
Precision ciphertext into several small

762
00:35:43,260 --> 00:35:44,880
separate texts

763
00:35:44,880 --> 00:35:47,520
this is done through uh what we call a

764
00:35:47,520 --> 00:35:49,500
ciphertext decomposition or homorphic

765
00:35:49,500 --> 00:35:51,260
digital decomposition

766
00:35:51,260 --> 00:35:53,579
this can be achieved by calling the

767
00:35:53,579 --> 00:35:55,619
large Precision sign evaluation as I

768
00:35:55,619 --> 00:35:57,180
mentioned before and we just need to

769
00:35:57,180 --> 00:35:59,099
collect the bits removed if you recall

770
00:35:59,099 --> 00:36:01,619
that in the large Precision PSI

771
00:36:01,619 --> 00:36:04,560
evaluation we need to remove kbits at a

772
00:36:04,560 --> 00:36:07,020
time we just need to collect the cables

773
00:36:07,020 --> 00:36:09,000
that we have end up with several small

774
00:36:09,000 --> 00:36:12,300
server texts that each encrypting kits

775
00:36:12,300 --> 00:36:14,280
of message

776
00:36:14,280 --> 00:36:16,740
this essentially has the same cost as

777
00:36:16,740 --> 00:36:19,859
the large Precision sign validation

778
00:36:19,859 --> 00:36:21,920
then we can evaluate each small

779
00:36:21,920 --> 00:36:24,780
ciphertext sequential using a change

780
00:36:24,780 --> 00:36:27,060
shape method or three ship method both

781
00:36:27,060 --> 00:36:28,980
of these methods are for first

782
00:36:28,980 --> 00:36:31,200
introduced in gbe21

783
00:36:31,200 --> 00:36:33,839
the change for the chinship method uh as

784
00:36:33,839 --> 00:36:36,660
you can see uh is like a chain so if we

785
00:36:36,660 --> 00:36:41,099
first use uh some uh a few functional

786
00:36:41,099 --> 00:36:44,160
bootstrapping to evaluate c0 and we will

787
00:36:44,160 --> 00:36:46,800
get a results out this carrying result

788
00:36:46,800 --> 00:36:48,839
will be processed with the second input

789
00:36:48,839 --> 00:36:52,500
and uh and together it will be evaluated

790
00:36:52,500 --> 00:36:54,300
using the second uh function of

791
00:36:54,300 --> 00:36:56,280
bootstrapping and sequentially we'll get

792
00:36:56,280 --> 00:36:57,359
some results

793
00:36:57,359 --> 00:37:00,260
but this this method is relatively

794
00:37:00,260 --> 00:37:02,579
restrictive because not all functions

795
00:37:02,579 --> 00:37:05,220
can be expressed in this way

796
00:37:05,220 --> 00:37:07,020
so they have the second method which is

797
00:37:07,020 --> 00:37:08,760
the three method uh the three methods

798
00:37:08,760 --> 00:37:10,859
basically saying that um for for first

799
00:37:10,859 --> 00:37:14,160
input instead of outputting a uh LW

800
00:37:14,160 --> 00:37:17,400
subtext it outputs some lookup table and

801
00:37:17,400 --> 00:37:18,900
this lookup table will be used to

802
00:37:18,900 --> 00:37:21,180
evaluate the second server text and so

803
00:37:21,180 --> 00:37:23,220
on and so forth uh this is much more

804
00:37:23,220 --> 00:37:25,380
General and much more powerful all of

805
00:37:25,380 --> 00:37:27,000
the functions can be expressed in this

806
00:37:27,000 --> 00:37:30,780
way uh but the catches that at the wrong

807
00:37:30,780 --> 00:37:32,220
time will be much worse than the first

808
00:37:32,220 --> 00:37:33,480
method

809
00:37:33,480 --> 00:37:35,940
but to sum up using The Cypher text

810
00:37:35,940 --> 00:37:38,940
decomposition uh we can use these two

811
00:37:38,940 --> 00:37:41,700
methods to to achieve arbitrary function

812
00:37:41,700 --> 00:37:45,439
evaluation over large precision

813
00:37:45,839 --> 00:37:47,579
there are two uh concurrent and

814
00:37:47,579 --> 00:37:49,859
independent Works uh both of the pro

815
00:37:49,859 --> 00:37:53,579
approaches uh use the observation that

816
00:37:53,579 --> 00:37:56,339
uh negative one times negative m equals

817
00:37:56,339 --> 00:37:58,140
to M and the extraction of most

818
00:37:58,140 --> 00:38:00,780
significant bits using few TV cheaper

819
00:38:00,780 --> 00:38:02,220
shopping

820
00:38:02,220 --> 00:38:05,520
uh both of these results both of these

821
00:38:05,520 --> 00:38:07,740
algorithms use uh multiplication and

822
00:38:07,740 --> 00:38:09,839
requires at least uh two bootstrapping

823
00:38:09,839 --> 00:38:11,780
invocations

824
00:38:11,780 --> 00:38:14,640
trot21 uses a BFE like multiplication

825
00:38:14,640 --> 00:38:17,820
and KS 21 uses a GSW like modification

826
00:38:17,820 --> 00:38:21,119
and the rule on the details we refer the

827
00:38:21,119 --> 00:38:24,060
audience to the those two papers to find

828
00:38:24,060 --> 00:38:27,060
out the details uh but our approach does

829
00:38:27,060 --> 00:38:29,040
not require any multiplication and can

830
00:38:29,040 --> 00:38:31,320
be instantiated using only addition and

831
00:38:31,320 --> 00:38:33,540
futility per circuit

832
00:38:33,540 --> 00:38:35,700
here's an uh

833
00:38:35,700 --> 00:38:38,579
is asymptotic comparisons as you can see

834
00:38:38,579 --> 00:38:41,460
the noise growth our noise growth has is

835
00:38:41,460 --> 00:38:44,700
the smallest and also we only we we have

836
00:38:44,700 --> 00:38:47,760
uh at less number of bootstrapping call

837
00:38:47,760 --> 00:38:50,280
invocations compared to ks21 and the

838
00:38:50,280 --> 00:38:53,940
same compared to clot21

839
00:38:54,320 --> 00:38:57,599
uh now let's talk about the experimental

840
00:38:57,599 --> 00:38:59,820
result in applications

841
00:38:59,820 --> 00:39:01,859
we have implemented our algorithms in

842
00:39:01,859 --> 00:39:04,320
Palisade and openfg libraries

843
00:39:04,320 --> 00:39:06,300
and we evaluate the large Precision

844
00:39:06,300 --> 00:39:08,700
comparison of for precision ranging from

845
00:39:08,700 --> 00:39:11,220
five bits to 21 bits

846
00:39:11,220 --> 00:39:14,220
uh the result is a single thread and

847
00:39:14,220 --> 00:39:16,680
with TV cheaper shopping using G plus

848
00:39:16,680 --> 00:39:19,260
plus 9.3.0

849
00:39:19,260 --> 00:39:22,079
uh here's the results I will not go into

850
00:39:22,079 --> 00:39:24,720
detail of all of them but as you can see

851
00:39:24,720 --> 00:39:27,359
the the runtime basically scales

852
00:39:27,359 --> 00:39:30,060
linearly with a number of bits we have

853
00:39:30,060 --> 00:39:32,040
also implemented the arbitrary function

854
00:39:32,040 --> 00:39:34,800
evaluation uh just to prove that it

855
00:39:34,800 --> 00:39:38,099
indeed works for only small precision

856
00:39:38,099 --> 00:39:40,320
we have also applied our techniques to

857
00:39:40,320 --> 00:39:43,020
have a site activation function over T56

858
00:39:43,020 --> 00:39:46,380
slots by using cks few tfvg scheme

859
00:39:46,380 --> 00:39:48,780
switching technique

860
00:39:48,780 --> 00:39:51,180
more generally one can use our large

861
00:39:51,180 --> 00:39:52,920
Precision comparison to perform an

862
00:39:52,920 --> 00:39:56,300
encrypted Branch evaluation

863
00:39:56,300 --> 00:39:58,020
uh

864
00:39:58,020 --> 00:40:00,240
there's another important line of work

865
00:40:00,240 --> 00:40:05,280
that uses cpts to to perform uh

866
00:40:05,280 --> 00:40:07,619
comparisons and those results are all

867
00:40:07,619 --> 00:40:10,619
based on uh polynomial approximation of

868
00:40:10,619 --> 00:40:14,640
the sine function and I would like to uh

869
00:40:14,640 --> 00:40:17,579
at a very high level compared to those

870
00:40:17,579 --> 00:40:19,260
two lines of work but the detailed

871
00:40:19,260 --> 00:40:21,720
comparison of course uh may may benefit

872
00:40:21,720 --> 00:40:24,980
from a more detailed survey paper

873
00:40:24,980 --> 00:40:28,320
uh so for state of the art success based

874
00:40:28,320 --> 00:40:30,420
comparisons uh it takes roughly 30

875
00:40:30,420 --> 00:40:33,540
seconds to compare for uh 64k slots

876
00:40:33,540 --> 00:40:35,640
where our method is uh six seconds for

877
00:40:35,640 --> 00:40:37,980
one slot so if the number of comparisons

878
00:40:37,980 --> 00:40:40,200
needed is very small our method will be

879
00:40:40,200 --> 00:40:42,500
faster

880
00:40:42,599 --> 00:40:45,540
also our method is easily paralyzable uh

881
00:40:45,540 --> 00:40:47,280
while cks supports only limited

882
00:40:47,280 --> 00:40:49,380
parallelization which means that if we

883
00:40:49,380 --> 00:40:51,780
have multiple cores that even if the

884
00:40:51,780 --> 00:40:53,760
number of comparisons are larger our

885
00:40:53,760 --> 00:40:57,300
method may still be uh preferred

886
00:40:57,300 --> 00:41:00,060
thank you uh another point is that

887
00:41:00,060 --> 00:41:02,400
higher Precision of cks method like 50

888
00:41:02,400 --> 00:41:04,680
bits can be very hard to support because

889
00:41:04,680 --> 00:41:07,500
the log queue can easily exist the lock

890
00:41:07,500 --> 00:41:09,980
use the Cyber text modulus for CTS

891
00:41:09,980 --> 00:41:13,740
schemes can easily see like 30 000 and

892
00:41:13,740 --> 00:41:15,300
this will also cause for ring Dimension

893
00:41:15,300 --> 00:41:17,640
to grow which will cause the performance

894
00:41:17,640 --> 00:41:20,579
to be much worse also uh to perform like

895
00:41:20,579 --> 00:41:23,160
a 50-bit a Precision comparison the

896
00:41:23,160 --> 00:41:25,260
scaling factor of ckks also needs to be

897
00:41:25,260 --> 00:41:29,160
increased from 64 64 bits to 128 bits

898
00:41:29,160 --> 00:41:30,540
which will further reduce the

899
00:41:30,540 --> 00:41:32,400
performance according to our our

900
00:41:32,400 --> 00:41:36,320
Benchmark using Palisade it can be as as

901
00:41:36,320 --> 00:41:40,280
bad as like eight times slower

902
00:41:40,280 --> 00:41:42,839
and of course our methods much simpler

903
00:41:42,839 --> 00:41:45,780
to implement and use and if multiple

904
00:41:45,780 --> 00:41:48,359
invocations of sign evaluations needed

905
00:41:48,359 --> 00:41:51,000
cks based method needs push dropping in

906
00:41:51,000 --> 00:41:52,800
between which will further reduce the

907
00:41:52,800 --> 00:41:56,119
runtime while hours do not

908
00:41:56,119 --> 00:41:58,500
uh there are of course some challenges

909
00:41:58,500 --> 00:42:02,760
and uh and potential promising and

910
00:42:02,760 --> 00:42:05,040
interesting future directions the

911
00:42:05,040 --> 00:42:07,740
map.net here for the runtime is the tfec

912
00:42:07,740 --> 00:42:10,619
or a few functional bootstrapping each

913
00:42:10,619 --> 00:42:13,920
comparison has to be done separately

914
00:42:13,920 --> 00:42:17,640
there's no CRT packing support and

915
00:42:17,640 --> 00:42:19,920
performance can be improved only by

916
00:42:19,920 --> 00:42:22,859
parallelization and like using multiple

917
00:42:22,859 --> 00:42:25,880
threats and or gpu-like parallelization

918
00:42:25,880 --> 00:42:29,400
so one very interesting uh question uh

919
00:42:29,400 --> 00:42:31,079
that can be asked is that can we develop

920
00:42:31,079 --> 00:42:32,700
other methods for functionable shopping

921
00:42:32,700 --> 00:42:34,380
with data efficiency

922
00:42:34,380 --> 00:42:36,420
and can we leverage pgb or BFE

923
00:42:36,420 --> 00:42:39,020
bootstrapping for this

924
00:42:39,020 --> 00:42:42,780
uh let me finish today's talk uh by with

925
00:42:42,780 --> 00:42:44,820
some conclusions and remarks

926
00:42:44,820 --> 00:42:47,640
so first in this work uh for the a few

927
00:42:47,640 --> 00:42:49,680
TVG line of work we have we have

928
00:42:49,680 --> 00:42:52,380
provided so far the most efficient large

929
00:42:52,380 --> 00:42:54,420
Precision comparison and more generally

930
00:42:54,420 --> 00:42:56,040
large Precision arbitrary function

931
00:42:56,040 --> 00:42:58,460
evaluation

932
00:42:58,460 --> 00:43:01,680
and moreover this methods can algorithm

933
00:43:01,680 --> 00:43:05,520
can be uh combined with cks one can use

934
00:43:05,520 --> 00:43:07,200
sticky gas for polynomial functioning

935
00:43:07,200 --> 00:43:09,540
valuation and use our algorithms for

936
00:43:09,540 --> 00:43:11,640
non-polynomial function evaluation like

937
00:43:11,640 --> 00:43:13,980
comparisons or like activation functions

938
00:43:13,980 --> 00:43:15,000
and so on

939
00:43:15,000 --> 00:43:17,700
uh of course this will need some uh some

940
00:43:17,700 --> 00:43:19,920
switch some switching technique between

941
00:43:19,920 --> 00:43:22,920
cks and few and this can be done from

942
00:43:22,920 --> 00:43:25,980
using cqs few TVG scheme switching

943
00:43:25,980 --> 00:43:27,839
technique first introducing Camilla

944
00:43:27,839 --> 00:43:32,240
paper and later improved in Texas

945
00:43:32,579 --> 00:43:35,099
and open Refugee is planning to include

946
00:43:35,099 --> 00:43:37,260
this scheme switching technique uh

947
00:43:37,260 --> 00:43:39,480
switching scheme a scheme switching

948
00:43:39,480 --> 00:43:42,900
feature in version 1.1 so after this is

949
00:43:42,900 --> 00:43:45,420
published or one can simply use the and

950
00:43:45,420 --> 00:43:47,700
and as mentioned that our organism and

951
00:43:47,700 --> 00:43:50,700
also CTS are both included in open fhg r

952
00:43:50,700 --> 00:43:53,280
d which means that if this feature is

953
00:43:53,280 --> 00:43:55,800
public one can simply use the open fishy

954
00:43:55,800 --> 00:43:57,960
library to perform what I mentioned

955
00:43:57,960 --> 00:44:01,140
above to incorporate our algorithm with

956
00:44:01,140 --> 00:44:03,200
the cks

957
00:44:03,200 --> 00:44:06,020
foreign

958
00:44:06,020 --> 00:44:08,760
references and that's pretty much it for

959
00:44:08,760 --> 00:44:10,619
my today's talk thank you all very much

960
00:44:10,619 --> 00:44:14,119
and I'm open to take questions

961
00:44:20,160 --> 00:44:22,440
all the questions from the audience so

962
00:44:22,440 --> 00:44:24,859
online

963
00:44:29,880 --> 00:44:33,180
no I don't I don't see any questions

964
00:44:33,180 --> 00:44:36,839
okay so let's thank the speaker again

965
00:44:36,839 --> 00:44:39,500
thank you

966
00:44:57,660 --> 00:45:02,099
is in person do we have the speaker

967
00:45:02,099 --> 00:45:05,119
ah excellent

968
00:45:05,339 --> 00:45:08,180
Facebook

969
00:46:08,420 --> 00:46:12,240
so the next talk is on the eval round

970
00:46:12,240 --> 00:46:15,599
algorithm in ckks bootstrapping and the

971
00:46:15,599 --> 00:46:17,780
talk will be given by

972
00:46:17,780 --> 00:46:20,780
Kim

973
00:46:20,780 --> 00:46:23,400
thank you for introducing my name is

974
00:46:23,400 --> 00:46:25,800
Sarah Kim and I'm going to introduce our

975
00:46:25,800 --> 00:46:27,780
paper over around algorithm means the

976
00:46:27,780 --> 00:46:30,859
kks bootstrapping

977
00:46:31,380 --> 00:46:33,900
so let me start by giving a brief

978
00:46:33,900 --> 00:46:35,640
overview of this talk

979
00:46:35,640 --> 00:46:39,240
the main topic is the kks which is a

980
00:46:39,240 --> 00:46:41,099
representative form of increasing skin

981
00:46:41,099 --> 00:46:44,400
which is widely known for its ability to

982
00:46:44,400 --> 00:46:46,500
deal with real numbers

983
00:46:46,500 --> 00:46:49,859
CK capable as bootstrapping is later

984
00:46:49,859 --> 00:46:53,400
suggests operation which recovers

985
00:46:53,400 --> 00:46:55,980
modulus of cyber text so it can be

986
00:46:55,980 --> 00:47:00,180
evaluated orbital arbitrary times

987
00:47:00,180 --> 00:47:03,780
our problem of this cks bootstrapping is

988
00:47:03,780 --> 00:47:06,240
it is an operational recovering those

989
00:47:06,240 --> 00:47:08,579
cyber text modulus but it consumes

990
00:47:08,579 --> 00:47:10,619
modulus at the same time

991
00:47:10,619 --> 00:47:14,280
what I missed is that uh

992
00:47:14,280 --> 00:47:16,680
it is another big combination of

993
00:47:16,680 --> 00:47:19,319
addition and multiplication so it

994
00:47:19,319 --> 00:47:22,500
consumes modulus and it directly

995
00:47:22,500 --> 00:47:23,700
determines

996
00:47:23,700 --> 00:47:27,240
how many evaluation depths are left

997
00:47:27,240 --> 00:47:31,260
after another after bootstrapping

998
00:47:31,260 --> 00:47:32,880
so

999
00:47:32,880 --> 00:47:35,220
we are focusing on reducing such model

1000
00:47:35,220 --> 00:47:38,400
as consumption by proposing a simple yet

1001
00:47:38,400 --> 00:47:41,099
effective variant of cks bootstrapping

1002
00:47:41,099 --> 00:47:46,440
which consumes less modulus modulus and

1003
00:47:46,440 --> 00:47:48,960
which can be implemented with

1004
00:47:48,960 --> 00:47:52,319
with a negligible cost on the existing

1005
00:47:52,319 --> 00:47:53,819
Convention of disturbing algorithm

1006
00:47:53,819 --> 00:47:56,359
implementation

1007
00:47:57,540 --> 00:48:00,240
the contents will be given as follows

1008
00:48:00,240 --> 00:48:02,280
I'll start by a giving up background

1009
00:48:02,280 --> 00:48:04,500
focusing on this modulus consumption of

1010
00:48:04,500 --> 00:48:06,060
kkks

1011
00:48:06,060 --> 00:48:10,680
and our as our algorithm is constructed

1012
00:48:10,680 --> 00:48:12,119
tightly on the combination of the

1013
00:48:12,119 --> 00:48:14,040
describing algorithm are spent some time

1014
00:48:14,040 --> 00:48:16,140
on reviewing the conventional algorithm

1015
00:48:16,140 --> 00:48:18,359
and I introduced the evil round

1016
00:48:18,359 --> 00:48:19,440
algorithm

1017
00:48:19,440 --> 00:48:22,440
in this talk I'm I'm focusing on the

1018
00:48:22,440 --> 00:48:25,200
delivering higher level ideas so please

1019
00:48:25,200 --> 00:48:29,000
check details on our paper

1020
00:48:30,300 --> 00:48:33,359
uh I'll not explained the whole concept

1021
00:48:33,359 --> 00:48:34,740
of homework being Christian but

1022
00:48:34,740 --> 00:48:36,900
homophone in Christian scheme can be

1023
00:48:36,900 --> 00:48:38,040
characterized

1024
00:48:38,040 --> 00:48:41,040
with three operations namely encryption

1025
00:48:41,040 --> 00:48:43,760
decryption and a method to

1026
00:48:43,760 --> 00:48:46,980
evaluate or desired function on homo

1027
00:48:46,980 --> 00:48:49,020
frequency on the Cyber text

1028
00:48:49,020 --> 00:48:50,940
so

1029
00:48:50,940 --> 00:48:53,220
let me look close

1030
00:48:53,220 --> 00:48:56,240
in the case of ckks

1031
00:48:56,240 --> 00:49:00,000
ckks provides three spaces message plain

1032
00:49:00,000 --> 00:49:02,579
text and cyber text

1033
00:49:02,579 --> 00:49:07,339
with encoding and encryption

1034
00:49:07,800 --> 00:49:10,380
so focusing on the plain text under on

1035
00:49:10,380 --> 00:49:13,200
the Cyber text these are constructed on

1036
00:49:13,200 --> 00:49:18,060
the wrong non-problem called rlwe so the

1037
00:49:18,060 --> 00:49:23,160
ckks can utilize its homophic structure

1038
00:49:23,160 --> 00:49:26,099
which is constructed on the polynomial

1039
00:49:26,099 --> 00:49:29,460
where the finite field coefficients

1040
00:49:29,460 --> 00:49:32,520
with this RW problem

1041
00:49:32,520 --> 00:49:34,380
the increasion of the plain text is

1042
00:49:34,380 --> 00:49:38,300
given as the equation below

1043
00:49:39,359 --> 00:49:41,900
on focusing on the message and plan text

1044
00:49:41,900 --> 00:49:45,599
the encoding and decoding map is defined

1045
00:49:45,599 --> 00:49:48,540
by discrete period transfer it is

1046
00:49:48,540 --> 00:49:52,020
natural to define the map by this since

1047
00:49:52,020 --> 00:49:55,319
they are polynomials and vectors and one

1048
00:49:55,319 --> 00:49:59,040
more thing on the cks is that the

1049
00:49:59,040 --> 00:50:00,839
message are complex vectors and plain

1050
00:50:00,839 --> 00:50:04,079
texts are integer polynomials so we have

1051
00:50:04,079 --> 00:50:07,800
to scaling up to encode the message and

1052
00:50:07,800 --> 00:50:11,640
scale down to decode the plain text

1053
00:50:11,640 --> 00:50:14,099
so in short the encoding and decoding

1054
00:50:14,099 --> 00:50:17,480
map is given as the below

1055
00:50:21,260 --> 00:50:25,200
one problem arises from the scaling up

1056
00:50:25,200 --> 00:50:27,660
it is the

1057
00:50:27,660 --> 00:50:30,420
size of encrypted plain text is growing

1058
00:50:30,420 --> 00:50:33,119
by each multiplications

1059
00:50:33,119 --> 00:50:35,460
in brief

1060
00:50:35,460 --> 00:50:39,420
suppose the plain text one is scaled up

1061
00:50:39,420 --> 00:50:41,400
by scale factor one

1062
00:50:41,400 --> 00:50:45,240
Delta one and plain text 2 is scared by

1063
00:50:45,240 --> 00:50:47,640
Delta 2 then the simple multiplicated

1064
00:50:47,640 --> 00:50:50,000
result will be scaled by Delta 1

1065
00:50:50,000 --> 00:50:53,640
multiplicate by Theta 2. so

1066
00:50:53,640 --> 00:50:57,200
if we nightly execute the important

1067
00:50:57,200 --> 00:51:00,180
evaluation circuit the size of the

1068
00:51:00,180 --> 00:51:01,619
encrypted plain text will grow

1069
00:51:01,619 --> 00:51:03,440
exponentially

1070
00:51:03,440 --> 00:51:06,599
actually main feature of the kkks is

1071
00:51:06,599 --> 00:51:07,980
dealing with

1072
00:51:07,980 --> 00:51:10,260
dealing with the size of being prepared

1073
00:51:10,260 --> 00:51:13,200
plain text efficiently it supports the

1074
00:51:13,200 --> 00:51:15,000
operation of rescaling to maintain the

1075
00:51:15,000 --> 00:51:17,640
size of encrypted plain text which is an

1076
00:51:17,640 --> 00:51:19,500
operation of dividing the Cyber text

1077
00:51:19,500 --> 00:51:21,960
modulus and the encrypted plain text at

1078
00:51:21,960 --> 00:51:24,000
the same time

1079
00:51:24,000 --> 00:51:26,579
so

1080
00:51:26,579 --> 00:51:28,440
rescaling

1081
00:51:28,440 --> 00:51:31,260
deals with the site so encrypted plain

1082
00:51:31,260 --> 00:51:33,780
text in exchange of consuming modulus

1083
00:51:33,780 --> 00:51:37,040
and the amount of motivates consumed is

1084
00:51:37,040 --> 00:51:39,240
exactly the same

1085
00:51:39,240 --> 00:51:42,300
as the encrypted plain text has scaled

1086
00:51:42,300 --> 00:51:43,800
down

1087
00:51:43,800 --> 00:51:48,420
it is open uh visualized by the diagram

1088
00:51:48,420 --> 00:51:50,640
on the right side

1089
00:51:50,640 --> 00:51:52,200
so we have

1090
00:51:52,200 --> 00:51:56,099
some plain text of size M1 and we have

1091
00:51:56,099 --> 00:51:59,640
another plain text of size M2

1092
00:51:59,640 --> 00:52:02,400
then the multiplicated result wave size

1093
00:52:02,400 --> 00:52:04,859
of M1 verticulate by

1094
00:52:04,859 --> 00:52:10,380
M2 and we just cut out the lsbs by

1095
00:52:10,380 --> 00:52:14,760
rescaling and the cutout or amount is

1096
00:52:14,760 --> 00:52:18,380
equals to the modulus consumption

1097
00:52:18,380 --> 00:52:21,119
such rescaling is a brilliant way to

1098
00:52:21,119 --> 00:52:22,440
deal with this

1099
00:52:22,440 --> 00:52:24,680
the size of encrypted plain text but

1100
00:52:24,680 --> 00:52:27,480
still there is a challenge

1101
00:52:27,480 --> 00:52:30,660
the challenge of all these kkks s is

1102
00:52:30,660 --> 00:52:34,380
that through evaluating the circuit

1103
00:52:34,380 --> 00:52:35,940
the Cyber tester will eventually

1104
00:52:35,940 --> 00:52:39,000
eventually run out the Cyber text model

1105
00:52:39,000 --> 00:52:40,440
so it can be

1106
00:52:40,440 --> 00:52:43,800
cannot be evaluated any further

1107
00:52:43,800 --> 00:52:47,040
so put the strapping is later suggests

1108
00:52:47,040 --> 00:52:51,920
to recover the Cyber text mode list

1109
00:52:52,319 --> 00:52:56,000
so we just

1110
00:52:56,300 --> 00:52:58,319
bootstrap the

1111
00:52:58,319 --> 00:53:01,440
cyber text at the bottom modulus and

1112
00:53:01,440 --> 00:53:03,720
continue the evaluating

1113
00:53:03,720 --> 00:53:05,099
cyber text

1114
00:53:05,099 --> 00:53:07,980
so it completes the cks at the fully

1115
00:53:07,980 --> 00:53:11,099
homophobic inflation scheme

1116
00:53:11,099 --> 00:53:14,160
the problem we are focusing on this CK

1117
00:53:14,160 --> 00:53:16,260
case bootstrapping is that

1118
00:53:16,260 --> 00:53:19,079
it consumes modulus

1119
00:53:19,079 --> 00:53:21,839
actually boost the first step of

1120
00:53:21,839 --> 00:53:24,180
bootstrapping is projecting to the

1121
00:53:24,180 --> 00:53:27,720
higher modulus so it is its modulus is

1122
00:53:27,720 --> 00:53:30,180
already recovered

1123
00:53:30,180 --> 00:53:32,099
but

1124
00:53:32,099 --> 00:53:35,599
we have to adjust the value of

1125
00:53:35,599 --> 00:53:37,980
protected cyber text to the original

1126
00:53:37,980 --> 00:53:39,720
message so

1127
00:53:39,720 --> 00:53:42,960
it consumes modulus from then so

1128
00:53:42,960 --> 00:53:44,819
after boost disrupting the Cyber test

1129
00:53:44,819 --> 00:53:47,040
modulus way goes down from the Fresh

1130
00:53:47,040 --> 00:53:49,440
modulus

1131
00:53:49,440 --> 00:53:51,000
and the

1132
00:53:51,000 --> 00:53:53,099
size of the

1133
00:53:53,099 --> 00:53:55,220
cyber text modulus after bootstrap

1134
00:53:55,220 --> 00:53:57,119
directly determines the possible

1135
00:53:57,119 --> 00:53:58,559
evaluation depth

1136
00:53:58,559 --> 00:54:01,880
till another bootstrap

1137
00:54:03,240 --> 00:54:05,579
so we'll go and uh

1138
00:54:05,579 --> 00:54:06,960
within the conventional approach

1139
00:54:06,960 --> 00:54:09,680
trapping algorithm

1140
00:54:09,960 --> 00:54:12,540
the input and desired output of

1141
00:54:12,540 --> 00:54:15,960
bootstrap can be defined as shown

1142
00:54:15,960 --> 00:54:18,359
so input is the Cyber text which is

1143
00:54:18,359 --> 00:54:20,099
encrypting a

1144
00:54:20,099 --> 00:54:22,020
these are the plain text

1145
00:54:22,020 --> 00:54:24,960
but it is on the bottom of the list

1146
00:54:24,960 --> 00:54:28,559
we desire on put to strap output to be

1147
00:54:28,559 --> 00:54:29,579
on

1148
00:54:29,579 --> 00:54:32,520
on other cyber text which is

1149
00:54:32,520 --> 00:54:34,859
encrypting the same plain text

1150
00:54:34,859 --> 00:54:36,599
you're going to ignoring the encryption

1151
00:54:36,599 --> 00:54:37,619
error

1152
00:54:37,619 --> 00:54:41,880
but on the greater ring

1153
00:54:41,880 --> 00:54:45,119
of Greater cyber test modulus

1154
00:54:45,119 --> 00:54:47,220
so the conventional to striping

1155
00:54:47,220 --> 00:54:50,280
algorithms is proposed with four steps

1156
00:54:50,280 --> 00:54:52,980
namely mode rates clip slot even more

1157
00:54:52,980 --> 00:54:57,359
than slot coiff so I'll go on briefly

1158
00:54:57,359 --> 00:54:59,900
explaining each steps

1159
00:54:59,900 --> 00:55:03,000
the fourth step of Mod race is just

1160
00:55:03,000 --> 00:55:04,680
projection

1161
00:55:04,680 --> 00:55:07,740
note that sector cyber text or bottom

1162
00:55:07,740 --> 00:55:11,520
alerts is also an element of higher

1163
00:55:11,520 --> 00:55:14,040
modulus so

1164
00:55:14,040 --> 00:55:18,059
we just regard it as an another modulus

1165
00:55:18,059 --> 00:55:19,559
on the

1166
00:55:19,559 --> 00:55:22,500
ring of higher modulus

1167
00:55:22,500 --> 00:55:26,280
recalling the definition of decryption

1168
00:55:26,280 --> 00:55:29,119
we can know that the

1169
00:55:29,119 --> 00:55:33,660
decrypted plain text of uh huh

1170
00:55:33,660 --> 00:55:36,500
motivated cyber text is somewhat

1171
00:55:36,500 --> 00:55:42,300
deteriorated with a q0i term

1172
00:55:42,300 --> 00:55:45,660
so the problem becomes to remove this

1173
00:55:45,660 --> 00:55:48,359
super plus Q 0i term

1174
00:55:48,359 --> 00:55:52,040
from to the

1175
00:55:53,940 --> 00:55:54,780
um

1176
00:55:54,780 --> 00:55:58,079
from the deteriorated subtext and

1177
00:55:58,079 --> 00:56:00,480
recover the original play encrypted

1178
00:56:00,480 --> 00:56:02,960
plain text

1179
00:56:05,160 --> 00:56:08,220
the following steps choose with it but

1180
00:56:08,220 --> 00:56:10,619
there is a problem that we want to

1181
00:56:10,619 --> 00:56:12,480
manipulate the confidence plain text

1182
00:56:12,480 --> 00:56:15,720
directly but we have only methods for

1183
00:56:15,720 --> 00:56:18,540
manipulating in creating messages

1184
00:56:18,540 --> 00:56:23,160
is also known as Dot and

1185
00:56:24,000 --> 00:56:25,220
the

1186
00:56:25,220 --> 00:56:27,660
operations deals with encrypted message

1187
00:56:27,660 --> 00:56:31,200
are playing homographic operations

1188
00:56:31,200 --> 00:56:33,799
but

1189
00:56:33,900 --> 00:56:36,500
we can think of sending those

1190
00:56:36,500 --> 00:56:39,780
coefficients to slots

1191
00:56:39,780 --> 00:56:43,079
by applying homework inquiry

1192
00:56:43,079 --> 00:56:44,640
so

1193
00:56:44,640 --> 00:56:46,920
recalling the definition of encoding

1194
00:56:46,920 --> 00:56:50,280
this is a linear map so we can just homo

1195
00:56:50,280 --> 00:56:53,240
frequently evaluate this

1196
00:56:53,780 --> 00:56:57,780
so after sending those questions to

1197
00:56:57,780 --> 00:57:01,260
slots we just don't deal with the PT

1198
00:57:01,260 --> 00:57:03,839
Plus Q 0i term by

1199
00:57:03,839 --> 00:57:07,440
holding evaluation and

1200
00:57:07,440 --> 00:57:09,720
uh

1201
00:57:09,720 --> 00:57:12,480
we covered the space by

1202
00:57:12,480 --> 00:57:16,520
applying inverse of the cut saw

1203
00:57:17,880 --> 00:57:21,480
so on the following step

1204
00:57:21,480 --> 00:57:24,420
we apply homorphing operation on PT Plus

1205
00:57:24,420 --> 00:57:26,040
Q 0i

1206
00:57:26,040 --> 00:57:29,339
to compute the original encrypted plain

1207
00:57:29,339 --> 00:57:33,020
text by applying modular reduction

1208
00:57:34,020 --> 00:57:36,319
this modular reduction is

1209
00:57:36,319 --> 00:57:39,359
simply approximated by sine function so

1210
00:57:39,359 --> 00:57:41,760
it is not hard to operate approximate

1211
00:57:41,760 --> 00:57:44,220
this function and there have have been

1212
00:57:44,220 --> 00:57:45,900
various approaches to

1213
00:57:45,900 --> 00:57:48,480
uh enhance this

1214
00:57:48,480 --> 00:57:51,960
but Arena covered those approaches as

1215
00:57:51,960 --> 00:57:56,760
because our suggestion can be applied on

1216
00:57:56,760 --> 00:58:01,520
any of the implementations on eBay mode

1217
00:58:02,339 --> 00:58:04,380
so I'm going to explain even around the

1218
00:58:04,380 --> 00:58:06,740
algorithm

1219
00:58:06,900 --> 00:58:08,579
the construction will be around the

1220
00:58:08,579 --> 00:58:11,220
algorithm is consisted of two minor

1221
00:58:11,220 --> 00:58:13,680
modifications on the conventional good

1222
00:58:13,680 --> 00:58:15,300
strapping algorithm

1223
00:58:15,300 --> 00:58:18,119
the first modification is on the cluster

1224
00:58:18,119 --> 00:58:19,859
start step

1225
00:58:19,859 --> 00:58:23,880
by alternating it to us

1226
00:58:23,880 --> 00:58:25,680
its variant

1227
00:58:25,680 --> 00:58:29,400
which is Computing in precise result

1228
00:58:29,400 --> 00:58:33,859
in exchange of consuming less modulus

1229
00:58:35,420 --> 00:58:38,760
by changing the step of coffee slot to

1230
00:58:38,760 --> 00:58:42,119
capture slash sharp we get an RNs wizard

1231
00:58:42,119 --> 00:58:45,319
but on the following modification of

1232
00:58:45,319 --> 00:58:48,240
alternating even more to even round

1233
00:58:48,240 --> 00:58:52,280
we can deal with the error effectively

1234
00:58:52,280 --> 00:58:55,559
so we'll look how can we how can it be

1235
00:58:55,559 --> 00:58:57,180
done

1236
00:58:57,180 --> 00:59:01,140
the first modification is uh

1237
00:59:01,140 --> 00:59:04,200
quarter slot which is don't can be done

1238
00:59:04,200 --> 00:59:06,920
by just or adjusting parameter

1239
00:59:06,920 --> 00:59:10,380
in detail we use lower scale factors to

1240
00:59:10,380 --> 00:59:11,760
scale up

1241
00:59:11,760 --> 00:59:15,900
Less on including idfp metrics

1242
00:59:15,900 --> 00:59:19,020
so looking on the coil of the slot which

1243
00:59:19,020 --> 00:59:21,420
is an homographic matrix multiplication

1244
00:59:21,420 --> 00:59:22,619
so

1245
00:59:22,619 --> 00:59:26,760
it is an inner product with encoded

1246
00:59:26,760 --> 00:59:29,940
diagonals and rotated plain texts

1247
00:59:29,940 --> 00:59:33,000
so I while I want to point to point out

1248
00:59:33,000 --> 00:59:34,079
is that

1249
00:59:34,079 --> 00:59:37,319
it is including such diagonals

1250
00:59:37,319 --> 00:59:41,280
by adjusting its scale factors we can

1251
00:59:41,280 --> 00:59:45,660
adjust its valid beats or Precision of

1252
00:59:45,660 --> 00:59:49,200
the identity coefficients so

1253
00:59:49,200 --> 00:59:51,480
by using lower scale factor we can

1254
00:59:51,480 --> 00:59:55,260
expect the imprecise result

1255
00:59:55,260 --> 00:59:58,559
but at the same time

1256
00:59:58,559 --> 01:00:01,260
because the rescaling consumes modulus

1257
01:00:01,260 --> 01:00:04,859
as much as the scale factor

1258
01:00:04,859 --> 01:00:06,839
scaled down

1259
01:00:06,839 --> 01:00:10,020
we consume less modulus

1260
01:00:10,020 --> 01:00:11,520
which is an

1261
01:00:11,520 --> 01:00:16,559
desired behavior of our algorithm

1262
01:00:16,559 --> 01:00:19,740
so after taking advantage of consuming

1263
01:00:19,740 --> 01:00:22,079
less modulus we have to deal with such

1264
01:00:22,079 --> 01:00:23,400
error

1265
01:00:23,400 --> 01:00:28,200
by alternating around

1266
01:00:28,799 --> 01:00:31,559
eBay round is an

1267
01:00:31,559 --> 01:00:34,260
uh systematically it is a homographic

1268
01:00:34,260 --> 01:00:37,079
evaluation of motor bounding and it can

1269
01:00:37,079 --> 01:00:39,559
be formally defined by

1270
01:00:39,559 --> 01:00:45,359
identity subtracted by either mode

1271
01:00:45,359 --> 01:00:48,359
so simply defining by this equation

1272
01:00:48,359 --> 01:00:53,180
hence uh since

1273
01:00:53,180 --> 01:00:57,599
revelation of modular reduction

1274
01:00:57,599 --> 01:01:01,160
the identity minus eBay mode is

1275
01:01:01,160 --> 01:01:04,020
mapping to the value to the closest

1276
01:01:04,020 --> 01:01:05,640
multiple of the

1277
01:01:05,640 --> 01:01:08,700
wanted integer

1278
01:01:08,700 --> 01:01:10,400
so

1279
01:01:10,400 --> 01:01:12,420
applying around

1280
01:01:12,420 --> 01:01:15,900
can completely alternate the existing

1281
01:01:15,900 --> 01:01:21,299
step and the proof is given as below

1282
01:01:21,299 --> 01:01:22,920
so

1283
01:01:22,920 --> 01:01:24,299
the

1284
01:01:24,299 --> 01:01:26,460
left side is the

1285
01:01:26,460 --> 01:01:29,160
step two three four of the convention of

1286
01:01:29,160 --> 01:01:30,780
the strapping algorithm

1287
01:01:30,780 --> 01:01:34,619
and we utilize the homorphic structure

1288
01:01:34,619 --> 01:01:38,160
of the slotcraft and even audience quite

1289
01:01:38,160 --> 01:01:40,260
slow so

1290
01:01:40,260 --> 01:01:45,299
if we rewrite the eBay mode by either by

1291
01:01:45,299 --> 01:01:48,599
identity minus around the identity can

1292
01:01:48,599 --> 01:01:51,660
be evaluated separately with either

1293
01:01:51,660 --> 01:01:54,780
round so we

1294
01:01:54,780 --> 01:02:00,440
get the equation of identity minus event

1295
01:02:01,880 --> 01:02:05,579
bootstrap is the same

1296
01:02:05,579 --> 01:02:07,559
compute the same result from the

1297
01:02:07,559 --> 01:02:10,160
conventional one

1298
01:02:16,140 --> 01:02:18,780
although the

1299
01:02:18,780 --> 01:02:20,819
even around the stack computes the same

1300
01:02:20,819 --> 01:02:22,799
result of the conventional one

1301
01:02:22,799 --> 01:02:25,380
there is an advantage of that

1302
01:02:25,380 --> 01:02:27,660
everyone is much more stable to the

1303
01:02:27,660 --> 01:02:29,220
input error

1304
01:02:29,220 --> 01:02:30,299
so

1305
01:02:30,299 --> 01:02:33,140
it can be directly seen that

1306
01:02:33,140 --> 01:02:36,240
as the input

1307
01:02:36,240 --> 01:02:37,740
changes

1308
01:02:37,740 --> 01:02:41,540
the modular reduction

1309
01:02:42,420 --> 01:02:45,079
the result of modular reduction changes

1310
01:02:45,079 --> 01:02:47,640
changes directly but

1311
01:02:47,640 --> 01:02:50,280
motor rounding does not so

1312
01:02:50,280 --> 01:02:52,380
it is much more stable to the input

1313
01:02:52,380 --> 01:02:55,500
error so we can take

1314
01:02:55,500 --> 01:02:57,900
advantages and Advantage from the

1315
01:02:57,900 --> 01:03:02,119
stability to consume less modulus

1316
01:03:04,440 --> 01:03:07,440
uh by applying the algorithm described

1317
01:03:07,440 --> 01:03:09,059
so far

1318
01:03:09,059 --> 01:03:13,880
we evaluated as on the table

1319
01:03:14,160 --> 01:03:17,118
we

1320
01:03:18,299 --> 01:03:22,380
developed our own ckks code to test the

1321
01:03:22,380 --> 01:03:24,960
algorithm on

1322
01:03:24,960 --> 01:03:27,240
practical parameters

1323
01:03:27,240 --> 01:03:29,339
so we give the size of message and bit

1324
01:03:29,339 --> 01:03:31,680
size of modulus with

1325
01:03:31,680 --> 01:03:33,960
practical means

1326
01:03:33,960 --> 01:03:36,760
but we

1327
01:03:36,760 --> 01:03:38,460
[Music]

1328
01:03:38,460 --> 01:03:42,020
maintaining the Precision we

1329
01:03:42,020 --> 01:03:44,940
obtained less modulus consensus by 84

1330
01:03:44,940 --> 01:03:48,299
bits so it is sufficient amount to

1331
01:03:48,299 --> 01:03:50,579
increase evaluation deaths after the

1332
01:03:50,579 --> 01:03:52,940
bootstrap

1333
01:03:52,940 --> 01:03:56,579
it becomes more and more effective when

1334
01:03:56,579 --> 01:03:59,160
it is applied on the parameters with

1335
01:03:59,160 --> 01:04:02,040
heavy root strap circuits so the

1336
01:04:02,040 --> 01:04:05,160
evaluation originally related evaluation

1337
01:04:05,160 --> 01:04:08,000
depth is small

1338
01:04:08,579 --> 01:04:10,740
the great advantage of this algorithm is

1339
01:04:10,740 --> 01:04:12,839
that it

1340
01:04:12,839 --> 01:04:15,900
does not require such assumption or

1341
01:04:15,900 --> 01:04:18,900
effort to evaluate

1342
01:04:18,900 --> 01:04:22,140
or Implement so it is

1343
01:04:22,140 --> 01:04:24,299
it is easy to upgrade on the original

1344
01:04:24,299 --> 01:04:28,140
Bluetooth strappinger algorithm and it

1345
01:04:28,140 --> 01:04:32,760
is super superior to the existing one

1346
01:04:32,760 --> 01:04:34,140
uh

1347
01:04:34,140 --> 01:04:37,859
what I want to point out is that

1348
01:04:37,859 --> 01:04:41,640
the hard thing is to set the scale

1349
01:04:41,640 --> 01:04:44,460
factor of course to slot as this

1350
01:04:44,460 --> 01:04:45,660
determines

1351
01:04:45,660 --> 01:04:50,220
the how much error on the equipment shop

1352
01:04:50,220 --> 01:04:55,619
step is occurred but the firm

1353
01:04:55,619 --> 01:04:59,220
setting on the scale factor will be

1354
01:04:59,220 --> 01:05:01,920
described on the paper

1355
01:05:01,920 --> 01:05:03,780
so

1356
01:05:03,780 --> 01:05:06,780
summing up we have

1357
01:05:06,780 --> 01:05:09,000
implemented

1358
01:05:09,000 --> 01:05:10,799
so

1359
01:05:10,799 --> 01:05:13,200
we have suggested on

1360
01:05:13,200 --> 01:05:15,000
normal algorithm or conventional

1361
01:05:15,000 --> 01:05:17,599
bootstrap

1362
01:05:17,780 --> 01:05:21,180
nowhere variant of commissioner

1363
01:05:21,180 --> 01:05:26,400
bootstrap to consume less modulus and

1364
01:05:26,400 --> 01:05:27,540
okay

1365
01:05:27,540 --> 01:05:30,059
is to implement on the conventional

1366
01:05:30,059 --> 01:05:33,599
bootstrap implementation

1367
01:05:34,260 --> 01:05:37,940
thank you for listening

1368
01:05:44,940 --> 01:05:48,500
are there any questions

1369
01:05:53,720 --> 01:05:56,880
thank you for your presentation I have a

1370
01:05:56,880 --> 01:05:59,160
question about either everyone so can

1371
01:05:59,160 --> 01:06:01,319
you show or gain the definition will be

1372
01:06:01,319 --> 01:06:04,420
very round so

1373
01:06:04,420 --> 01:06:06,180
[Music]

1374
01:06:06,180 --> 01:06:07,900
oh

1375
01:06:07,900 --> 01:06:09,660
[Music]

1376
01:06:09,660 --> 01:06:12,540
okay this is the second question anyway

1377
01:06:12,540 --> 01:06:15,420
so what I don't know is that I don't

1378
01:06:15,420 --> 01:06:17,280
know about the role of identity function

1379
01:06:17,280 --> 01:06:20,640
so so if I change the identity function

1380
01:06:20,640 --> 01:06:23,220
by or some don't present don't present

1381
01:06:23,220 --> 01:06:26,039
in functions such as some ultimate pgme

1382
01:06:26,039 --> 01:06:30,960
in kks so you know that this is just uh

1383
01:06:30,960 --> 01:06:35,299
change the the index of the question

1384
01:06:35,299 --> 01:06:39,599
then do you think it happens the same

1385
01:06:39,599 --> 01:06:43,500
effects uh as the identity dungeon

1386
01:06:43,500 --> 01:06:47,000
what do you think about that

1387
01:06:48,299 --> 01:06:50,780
I think there will be no problem on

1388
01:06:50,780 --> 01:06:53,640
changing such functions but

1389
01:06:53,640 --> 01:06:56,160
if

1390
01:06:56,160 --> 01:07:00,240
if you are talking about the uh

1391
01:07:00,240 --> 01:07:04,399
programmable Bluetooth strapping yeah

1392
01:07:04,559 --> 01:07:07,380
well just just the alternative so so you

1393
01:07:07,380 --> 01:07:10,760
you utilize the river around the S on uh

1394
01:07:10,760 --> 01:07:14,400
identity binders eBay mode so so then we

1395
01:07:14,400 --> 01:07:17,160
can redefine some such functions such as

1396
01:07:17,160 --> 01:07:18,859
uh automobile

1397
01:07:18,859 --> 01:07:22,920
mode so be be based on you function and

1398
01:07:22,920 --> 01:07:26,539
we can upload the function into the the

1399
01:07:26,539 --> 01:07:30,180
parenthesis and and the the obtain or

1400
01:07:30,180 --> 01:07:33,539
new new education and and so so the left

1401
01:07:33,539 --> 01:07:35,940
left side is is replaced I left the

1402
01:07:35,940 --> 01:07:37,920
identity function is replaced by some

1403
01:07:37,920 --> 01:07:40,920
alternative and and the right side is

1404
01:07:40,920 --> 01:07:43,799
some good station is awkward but but I

1405
01:07:43,799 --> 01:07:47,359
can I think uh the the effect

1406
01:07:47,359 --> 01:07:50,819
so so what I know what I want to know is

1407
01:07:50,819 --> 01:07:53,880
there is some differences between or

1408
01:07:53,880 --> 01:08:00,180
what I what I uh 13 and and your your or

1409
01:08:00,180 --> 01:08:02,540
yeah good works

1410
01:08:02,540 --> 01:08:05,909
[Music]

1411
01:08:06,299 --> 01:08:08,339
so

1412
01:08:08,339 --> 01:08:10,759
uh

1413
01:08:12,839 --> 01:08:15,119
as I understand your question is to

1414
01:08:15,119 --> 01:08:18,319
comparing Pro

1415
01:08:19,080 --> 01:08:21,839
your question that this work is what

1416
01:08:21,839 --> 01:08:23,399
other uh

1417
01:08:23,399 --> 01:08:25,920
instance of programmable bootstrapping

1418
01:08:25,920 --> 01:08:27,600
am I right

1419
01:08:27,600 --> 01:08:29,479
uh uh

1420
01:08:29,479 --> 01:08:33,380
I I think I I didn't focus on Justice

1421
01:08:33,380 --> 01:08:35,880
I didn't function is it's just my

1422
01:08:35,880 --> 01:08:38,698
thinking about just don't don't

1423
01:08:38,698 --> 01:08:44,179
preserving function so so it just uh uh

1424
01:08:44,179 --> 01:08:49,679
do that thing so so some some function I

1425
01:08:49,679 --> 01:08:51,479
think the same same work because they

1426
01:08:51,479 --> 01:08:55,439
just uh filter the room so so there's no

1427
01:08:55,439 --> 01:09:00,120
no or error error or application so I

1428
01:09:00,120 --> 01:09:02,339
think I can change so I did function to

1429
01:09:02,339 --> 01:09:04,140
some some boom printing function so

1430
01:09:04,140 --> 01:09:07,219
let's just also there are some famous

1431
01:09:07,219 --> 01:09:11,759
functions in CK case skks so so also

1432
01:09:11,759 --> 01:09:15,839
alsoever pigeon so so I I just curious

1433
01:09:15,839 --> 01:09:18,899
about there are some some of possibility

1434
01:09:18,899 --> 01:09:24,080
to optimize this is your your ideas

1435
01:09:28,259 --> 01:09:31,020
yes uh I think

1436
01:09:31,020 --> 01:09:33,120
I also think that applying such

1437
01:09:33,120 --> 01:09:36,719
technique on the eBay round is also

1438
01:09:36,719 --> 01:09:39,299
available same as the combination of

1439
01:09:39,299 --> 01:09:40,560
bootstrapping

1440
01:09:40,560 --> 01:09:42,540
so

1441
01:09:42,540 --> 01:09:44,759
if around can be applied to the program

1442
01:09:44,759 --> 01:09:47,160
I will put the struggle yeah

1443
01:09:47,160 --> 01:09:51,139
wow okay thank you

1444
01:09:52,380 --> 01:09:55,980
any other question from the audience

1445
01:09:55,980 --> 01:09:58,080
there was a question online yeah so let

1446
01:09:58,080 --> 01:10:00,980
me let me get it

1447
01:10:01,060 --> 01:10:03,120
[Music]

1448
01:10:03,120 --> 01:10:06,140
okay so it's a question by uh Hilda Vito

1449
01:10:06,140 --> 01:10:08,699
Lima Pereira

1450
01:10:08,699 --> 01:10:11,699
please could you comment more about the

1451
01:10:11,699 --> 01:10:14,640
column bootstrap bits Precision on Slide

1452
01:10:14,640 --> 01:10:18,960
22. if we start with scaling 2 to the 60

1453
01:10:18,960 --> 01:10:22,640
which is the final precision

1454
01:10:23,219 --> 01:10:25,699
foreign

1455
01:10:25,699 --> 01:10:28,380
addition to the question which is then

1456
01:10:28,380 --> 01:10:31,380
starting with small scaling Factor what

1457
01:10:31,380 --> 01:10:34,460
is the final precision

1458
01:10:36,580 --> 01:10:39,760
[Music]

1459
01:10:40,100 --> 01:10:43,980
uh I I'm not remembering the exact value

1460
01:10:43,980 --> 01:10:47,100
but it is much higher than the

1461
01:10:47,100 --> 01:10:49,140
conventional bootstrapping one it is

1462
01:10:49,140 --> 01:10:52,679
natural because uh

1463
01:10:52,860 --> 01:10:57,559
on this diagram we only

1464
01:10:58,140 --> 01:11:01,260
dealt with aerobical creative slash

1465
01:11:01,260 --> 01:11:03,659
sharp but actually there is some run

1466
01:11:03,659 --> 01:11:06,019
okay

1467
01:11:06,540 --> 01:11:10,020
existing rounding or quarter slot

1468
01:11:10,020 --> 01:11:12,620
and

1469
01:11:19,560 --> 01:11:22,739
and there is a polynomial evaluation

1470
01:11:22,739 --> 01:11:26,880
error on motor reduction so the blue

1471
01:11:26,880 --> 01:11:29,060
grab is not exactly

1472
01:11:29,060 --> 01:11:31,140
evaluated by

1473
01:11:31,140 --> 01:11:32,640
even mode

1474
01:11:32,640 --> 01:11:35,460
so even round defined by the identity

1475
01:11:35,460 --> 01:11:40,440
minus symbolt mode is not the is exactly

1476
01:11:40,440 --> 01:11:43,440
the same to the given rat graph so

1477
01:11:43,440 --> 01:11:46,159
uh

1478
01:11:49,380 --> 01:11:50,760
the

1479
01:11:50,760 --> 01:11:54,000
bootstrap priest will be somehow a

1480
01:11:54,000 --> 01:11:55,140
little higher

1481
01:11:55,140 --> 01:11:57,560
to the proposed

1482
01:11:57,560 --> 01:12:02,520
current proposed evaluation

1483
01:12:06,739 --> 01:12:11,959
I think we can sing a speaker again

1484
01:12:17,600 --> 01:12:22,880
the next book is a an online talk

1485
01:12:41,219 --> 01:12:42,710
hello

1486
01:12:42,710 --> 01:12:46,140
[Music]

1487
01:12:46,140 --> 01:12:48,120
we can hear you but we don't see your

1488
01:12:48,120 --> 01:12:49,380
slides yet

1489
01:12:49,380 --> 01:12:53,420
yeah okay let me try again

1490
01:13:03,120 --> 01:13:06,430
[Music]

1491
01:13:07,500 --> 01:13:10,500
wow

1492
01:13:16,040 --> 01:13:19,020
I'm not sure maybe you could stop this

1493
01:13:19,020 --> 01:13:21,060
sharing that is going on already I don't

1494
01:13:21,060 --> 01:13:24,560
know if this is blocking me somehow

1495
01:13:24,840 --> 01:13:26,640
yeah just a second

1496
01:13:26,640 --> 01:13:27,580
thank you

1497
01:13:27,580 --> 01:13:30,800
[Music]

1498
01:14:33,239 --> 01:14:35,839
foreign

1499
01:15:04,560 --> 01:15:07,280
you know

1500
01:15:13,860 --> 01:15:16,500
oh we can see your slides are you still

1501
01:15:16,500 --> 01:15:19,199
here these lights okay and we can hear

1502
01:15:19,199 --> 01:15:21,960
you excellent okay sorry for the

1503
01:15:21,960 --> 01:15:24,060
technical problems yeah sure no problem

1504
01:15:24,060 --> 01:15:26,340
so okay so the the last talk of this

1505
01:15:26,340 --> 01:15:28,320
session will be on the paper titled

1506
01:15:28,320 --> 01:15:31,560
final faster fhc instantiated with

1507
01:15:31,560 --> 01:15:34,980
Andrew and lwe and the talk will be

1508
01:15:34,980 --> 01:15:39,900
given by uh Hilder Pereira uh hilders

1509
01:15:39,900 --> 01:15:41,659
thank you very much for an introduction

1510
01:15:41,659 --> 01:15:44,580
so this paper is a joint to work with

1511
01:15:44,580 --> 01:15:46,940
Charlotte

1512
01:15:47,900 --> 01:15:51,179
please if there is any problem uh you

1513
01:15:51,179 --> 01:15:52,260
just

1514
01:15:52,260 --> 01:15:55,260
tell me you can turn on your microphone

1515
01:15:55,260 --> 01:15:57,920
and tell me okay

1516
01:15:58,199 --> 01:15:59,940
um so

1517
01:15:59,940 --> 01:16:03,060
the starting point here is

1518
01:16:03,060 --> 01:16:05,400
essentially comparison between these two

1519
01:16:05,400 --> 01:16:07,860
heart problems the rlwe the ring

1520
01:16:07,860 --> 01:16:09,840
learning reverse and the end true

1521
01:16:09,840 --> 01:16:11,820
problem right so the ring learning

1522
01:16:11,820 --> 01:16:14,820
reverse is very famous and it's used to

1523
01:16:14,820 --> 01:16:18,480
construct basically most of the fully

1524
01:16:18,480 --> 01:16:19,860
homomorphic encryption schemes that we

1525
01:16:19,860 --> 01:16:23,820
have and what the rlwe allow us to do is

1526
01:16:23,820 --> 01:16:26,219
to sample pairs of polynomials from a

1527
01:16:26,219 --> 01:16:28,739
polynomial ring so we can Define this

1528
01:16:28,739 --> 01:16:31,140
integer polynomials with degree bounded

1529
01:16:31,140 --> 01:16:33,600
by some parameter n and then we can

1530
01:16:33,600 --> 01:16:36,780
sample pairs of polynomials where

1531
01:16:36,780 --> 01:16:39,840
this second element here has a hidden

1532
01:16:39,840 --> 01:16:42,239
structure it actually hides the secret s

1533
01:16:42,239 --> 01:16:46,440
but they look uh uniformly random right

1534
01:16:46,440 --> 01:16:48,780
if we don't know s

1535
01:16:48,780 --> 01:16:51,600
but we have a c kind of similar problem

1536
01:16:51,600 --> 01:16:54,060
the entry problem that also allow us to

1537
01:16:54,060 --> 01:16:57,600
hide a small polynomial into another

1538
01:16:57,600 --> 01:16:59,699
element of this ring so another

1539
01:16:59,699 --> 01:17:03,620
polynomial and this is

1540
01:17:03,620 --> 01:17:06,600
we are yeah so we were stuck on the

1541
01:17:06,600 --> 01:17:08,340
first slide okay thank you

1542
01:17:08,340 --> 01:17:10,800
so now we can see the second slide okay

1543
01:17:10,800 --> 01:17:13,560
if I do this is it moving

1544
01:17:13,560 --> 01:17:16,920
uh no yes

1545
01:17:16,920 --> 01:17:20,640
there seems to be some delay

1546
01:17:20,640 --> 01:17:23,880
so now we're on the ring lwe and then

1547
01:17:23,880 --> 01:17:25,260
two problems later

1548
01:17:25,260 --> 01:17:28,400
yes okay thank you

1549
01:17:28,400 --> 01:17:31,199
so I was just saying that the end true

1550
01:17:31,199 --> 01:17:33,300
kind of give us the same we can

1551
01:17:33,300 --> 01:17:35,640
construct this polynomial

1552
01:17:35,640 --> 01:17:39,120
um b a ring element that hides this is

1553
01:17:39,120 --> 01:17:41,280
more secret and at the same time it

1554
01:17:41,280 --> 01:17:43,800
looks random but the difference is that

1555
01:17:43,800 --> 01:17:47,820
for the rlwe we need a pair of ring

1556
01:17:47,820 --> 01:17:50,040
elements while for DN true we just have

1557
01:17:50,040 --> 01:17:52,080
one polynomial right

1558
01:17:52,080 --> 01:17:56,900
so if we could somehow

1559
01:17:57,120 --> 01:17:58,679
um

1560
01:17:58,679 --> 01:18:01,260
it looks like these lights are stuck

1561
01:18:01,260 --> 01:18:03,500
again

1562
01:18:05,540 --> 01:18:09,120
okay so if we could somehow replace the

1563
01:18:09,120 --> 01:18:14,780
the rlw problem by the entry problem

1564
01:18:14,880 --> 01:18:16,920
uh

1565
01:18:16,920 --> 01:18:20,640
in the the fhc schemes

1566
01:18:20,640 --> 01:18:23,520
we should like the intuition is that we

1567
01:18:23,520 --> 01:18:26,280
would be able to use half of the memory

1568
01:18:26,280 --> 01:18:28,080
and half of the server text because of

1569
01:18:28,080 --> 01:18:30,300
instead of working with pairs of

1570
01:18:30,300 --> 01:18:32,100
polynomials we would work with a single

1571
01:18:32,100 --> 01:18:34,640
polynomial

1572
01:18:35,820 --> 01:18:37,860
um these these slides are not passing

1573
01:18:37,860 --> 01:18:39,980
right

1574
01:18:40,380 --> 01:18:42,300
we are still on the slide number three

1575
01:18:42,300 --> 01:18:44,659
yeah

1576
01:18:45,060 --> 01:18:48,620
I mean this is not good

1577
01:18:49,679 --> 01:18:53,280
okay I will just try one thing please

1578
01:18:53,280 --> 01:18:56,360
let me just do this

1579
01:19:11,659 --> 01:19:14,600
you are not seeing it no

1580
01:19:14,600 --> 01:19:17,869
[Music]

1581
01:20:06,800 --> 01:20:09,540
Hilder do you see how to solve the

1582
01:20:09,540 --> 01:20:12,600
problem or no I'm sorry I'm trying to

1583
01:20:12,600 --> 01:20:13,679
share but

1584
01:20:13,679 --> 01:20:17,840
I click on share and it's not sharing

1585
01:20:17,840 --> 01:20:21,120
otherwise we I I've been told that uh

1586
01:20:21,120 --> 01:20:24,360
you you gave us a prerequisite video so

1587
01:20:24,360 --> 01:20:26,520
in in the worst case we can uh just uh

1588
01:20:26,520 --> 01:20:28,320
yeah maybe it's better I'm sorry about

1589
01:20:28,320 --> 01:20:31,320
this yeah sure that that happened son

1590
01:20:31,320 --> 01:20:33,960
and uh so yeah I will stay online after

1591
01:20:33,960 --> 01:20:35,520
this we can answer the questions at

1592
01:20:35,520 --> 01:20:37,679
least if people have any questions yeah

1593
01:20:37,679 --> 01:20:41,060
okay so let's let's do this

1594
01:20:50,040 --> 01:20:52,280
foreign

1595
01:20:54,350 --> 01:20:57,629
[Music]

1596
01:21:26,300 --> 01:21:29,880
true and lwv this is a joint work with

1597
01:21:29,880 --> 01:21:32,760
Charlotte Bonte ileashinku chongyong

1598
01:21:32,760 --> 01:21:35,159
Park and Professor Nigel smart

1599
01:21:35,159 --> 01:21:38,520
so most fhe schemes are based on the

1600
01:21:38,520 --> 01:21:40,500
ring learning refers problem

1601
01:21:40,500 --> 01:21:43,199
this problem allow us to sample pairs of

1602
01:21:43,199 --> 01:21:47,040
polynomials from a polynomial ring so a

1603
01:21:47,040 --> 01:21:48,960
ring with integer polynomials with

1604
01:21:48,960 --> 01:21:51,140
degree is smaller than some parameter n

1605
01:21:51,140 --> 01:21:54,659
and although this pair of polynomials

1606
01:21:54,659 --> 01:22:00,000
hide the secret value s they look random

1607
01:22:00,000 --> 01:22:02,219
but actually there is another problem

1608
01:22:02,219 --> 01:22:04,620
defined over polynomial Rings which is

1609
01:22:04,620 --> 01:22:07,679
well known it's the entry problem and

1610
01:22:07,679 --> 01:22:10,380
with this problem we can hide a secret

1611
01:22:10,380 --> 01:22:11,960
polynomial f

1612
01:22:11,960 --> 01:22:15,780
into one single polynomial that also

1613
01:22:15,780 --> 01:22:17,219
looks random

1614
01:22:17,219 --> 01:22:18,840
so

1615
01:22:18,840 --> 01:22:21,560
you can see that the N true

1616
01:22:21,560 --> 01:22:24,600
allows us to use one single polynomial

1617
01:22:24,600 --> 01:22:27,179
instead of a pair of polynomials so if

1618
01:22:27,179 --> 01:22:30,840
we could somehow replace the iwv problem

1619
01:22:30,840 --> 01:22:35,120
by the entry problem in this fhe schemes

1620
01:22:35,120 --> 01:22:38,400
the intuition is that we should be able

1621
01:22:38,400 --> 01:22:40,679
to use half of the memory and maybe half

1622
01:22:40,679 --> 01:22:43,260
of the running time

1623
01:22:43,260 --> 01:22:45,719
and actually

1624
01:22:45,719 --> 01:22:47,760
this observation

1625
01:22:47,760 --> 01:22:50,600
has already been used in the past so

1626
01:22:50,600 --> 01:22:53,580
some authors try to construct fhe

1627
01:22:53,580 --> 01:22:55,980
schemes using the entry problem for

1628
01:22:55,980 --> 01:22:58,199
example there was this scheme Yash that

1629
01:22:58,199 --> 01:23:00,540
was more efficient than the than the

1630
01:23:00,540 --> 01:23:03,480
corresponding ilw based schemes at the

1631
01:23:03,480 --> 01:23:04,199
time

1632
01:23:04,199 --> 01:23:06,659
but the problem is that the ciphertext

1633
01:23:06,659 --> 01:23:09,659
modulus this parameter queue

1634
01:23:09,659 --> 01:23:12,120
that these schemes based on the intro

1635
01:23:12,120 --> 01:23:16,260
used were super polynomial in n

1636
01:23:16,260 --> 01:23:20,280
while the first intro ciphers they used

1637
01:23:20,280 --> 01:23:24,420
like intro encryption uh into Crypt they

1638
01:23:24,420 --> 01:23:26,120
used very small

1639
01:23:26,120 --> 01:23:30,900
uh values of Q just linearing in

1640
01:23:30,900 --> 01:23:34,140
and it turns out that the entry problem

1641
01:23:34,140 --> 01:23:36,659
is insecure when Q is too big in

1642
01:23:36,659 --> 01:23:38,640
comparison to n

1643
01:23:38,640 --> 01:23:40,980
now we understand well

1644
01:23:40,980 --> 01:23:44,159
why this is the case so before we

1645
01:23:44,159 --> 01:23:46,380
essentially just knew this ski recovery

1646
01:23:46,380 --> 01:23:49,800
attacks which have a Time exponential in

1647
01:23:49,800 --> 01:23:52,380
N but there are new attacks called

1648
01:23:52,380 --> 01:23:57,380
sublets attacks that whose hardness

1649
01:23:57,380 --> 01:23:59,880
depends very strongly on Q so the

1650
01:23:59,880 --> 01:24:02,340
situation is the following when Q is

1651
01:24:02,340 --> 01:24:05,040
linearing and the sublets attacks are

1652
01:24:05,040 --> 01:24:06,900
more expensive than the key recovery

1653
01:24:06,900 --> 01:24:10,020
attacks and then because the curricular

1654
01:24:10,020 --> 01:24:12,000
attack is already exponential time then

1655
01:24:12,000 --> 01:24:14,520
true problem is very hard

1656
01:24:14,520 --> 01:24:19,199
but as we increase Q the sublets attacks

1657
01:24:19,199 --> 01:24:22,199
becomes easier and easier and

1658
01:24:22,199 --> 01:24:25,020
at this point if Q is exponential in the

1659
01:24:25,020 --> 01:24:27,300
end in the sublets attack becomes

1660
01:24:27,300 --> 01:24:30,360
polynomial so if you have an attack that

1661
01:24:30,360 --> 01:24:32,100
runs in polynomial time this means that

1662
01:24:32,100 --> 01:24:34,260
n true problem is very easy

1663
01:24:34,260 --> 01:24:37,380
so the sublets attack has become easier

1664
01:24:37,380 --> 01:24:40,800
is easier at some so at some point it

1665
01:24:40,800 --> 01:24:42,360
costs essentially the same as the key

1666
01:24:42,360 --> 01:24:44,820
recovery attack and this point is called

1667
01:24:44,820 --> 01:24:46,679
the fatigue point

1668
01:24:46,679 --> 01:24:48,000
so

1669
01:24:48,000 --> 01:24:51,300
new uh results especially this paper

1670
01:24:51,300 --> 01:24:54,739
while auduca and pardon

1671
01:24:54,739 --> 01:24:58,620
computed the Point as n to the

1672
01:24:58,620 --> 01:25:01,260
power of two and a half essentially

1673
01:25:01,260 --> 01:25:05,460
so if we choose parameters with Q larger

1674
01:25:05,460 --> 01:25:07,679
than this we are in this version which

1675
01:25:07,679 --> 01:25:10,620
is known as overstretched and in this

1676
01:25:10,620 --> 01:25:12,960
version the entry problem is not as hard

1677
01:25:12,960 --> 01:25:14,100
as we want

1678
01:25:14,100 --> 01:25:17,100
because of the sublets attacks so when

1679
01:25:17,100 --> 01:25:20,400
we use the intro problem to instantiate

1680
01:25:20,400 --> 01:25:23,580
our schemes we have to restrict

1681
01:25:23,580 --> 01:25:26,640
ourselves to this version here

1682
01:25:26,640 --> 01:25:29,940
So Below the fatigue point

1683
01:25:29,940 --> 01:25:32,300
so the first contribution of the paper

1684
01:25:32,300 --> 01:25:36,300
is constructing a scheme that looks like

1685
01:25:36,300 --> 01:25:38,520
the GSW scheme

1686
01:25:38,520 --> 01:25:41,100
but it's based on the untrue and because

1687
01:25:41,100 --> 01:25:43,440
of this it has a faster external product

1688
01:25:43,440 --> 01:25:45,300
so the external products the main

1689
01:25:45,300 --> 01:25:47,699
operation of this type of schemes this

1690
01:25:47,699 --> 01:25:50,219
is GSW schemes

1691
01:25:50,219 --> 01:25:55,199
and then we use this NGS to bootstrap a

1692
01:25:55,199 --> 01:25:57,120
scheme that is based on the intro and

1693
01:25:57,120 --> 01:25:59,820
then because this scheme is based on N

1694
01:25:59,820 --> 01:26:02,820
true and NGS is also based on intro this

1695
01:26:02,820 --> 01:26:05,699
means that we are between fhe based only

1696
01:26:05,699 --> 01:26:07,380
on the entry problem

1697
01:26:07,380 --> 01:26:10,139
and with parameters below the fatigue

1698
01:26:10,139 --> 01:26:11,520
point

1699
01:26:11,520 --> 01:26:15,480
and also we use NGS to bootstrap a LW

1700
01:26:15,480 --> 01:26:19,500
based scheme and when we do this this

1701
01:26:19,500 --> 01:26:23,340
combination of lwe and then true give us

1702
01:26:23,340 --> 01:26:27,000
a bootstrapping that is 28 percent uh

1703
01:26:27,000 --> 01:26:29,580
faster than tfhe's bootstrapping and

1704
01:26:29,580 --> 01:26:32,100
uses about half of the memory that tfhe

1705
01:26:32,100 --> 01:26:34,580
uses

1706
01:26:34,860 --> 01:26:37,800
so now you explain a little about our

1707
01:26:37,800 --> 01:26:40,380
scheme NGS

1708
01:26:40,380 --> 01:26:43,380
so this secret is just the small

1709
01:26:43,380 --> 01:26:46,139
polynomial from the entry problem

1710
01:26:46,139 --> 01:26:48,540
and then we Define two types of Cipher

1711
01:26:48,540 --> 01:26:51,179
texts a scalar ciphertext which is just

1712
01:26:51,179 --> 01:26:52,980
a polynomial so we have a name through

1713
01:26:52,980 --> 01:26:55,679
sample and we add the message is scaled

1714
01:26:55,679 --> 01:26:58,080
by some integer Factor Delta

1715
01:26:58,080 --> 01:27:01,199
and the vector Cipher text

1716
01:27:01,199 --> 01:27:04,860
is composed by essentially a vector of

1717
01:27:04,860 --> 01:27:08,460
this uh scalar a ciphertext here but

1718
01:27:08,460 --> 01:27:12,239
this Delta instead of a single Delta now

1719
01:27:12,239 --> 01:27:14,760
is a vector with powers of some value B

1720
01:27:14,760 --> 01:27:18,719
right so we have a vector of n true

1721
01:27:18,719 --> 01:27:21,840
samples and then the message is

1722
01:27:21,840 --> 01:27:24,179
multiplied by the vector of powers of

1723
01:27:24,179 --> 01:27:26,219
some base we can choose this base B here

1724
01:27:26,219 --> 01:27:31,020
and then L is log of Q in this base B

1725
01:27:31,020 --> 01:27:34,739
so in the original GSW scheme

1726
01:27:34,739 --> 01:27:38,580
this instead of this Vector here what we

1727
01:27:38,580 --> 01:27:41,400
have is a matrix like this so you can

1728
01:27:41,400 --> 01:27:44,520
see that here we have l l again so 2

1729
01:27:44,520 --> 01:27:48,239
times L of rows and two columns right so

1730
01:27:48,239 --> 01:27:50,400
2 times L times two this means that we

1731
01:27:50,400 --> 01:27:53,400
have 4 times L elements and here we just

1732
01:27:53,400 --> 01:27:56,659
have Arrow elements

1733
01:27:56,940 --> 01:28:00,420
then to run an external product we just

1734
01:28:00,420 --> 01:28:04,620
have to take this the scalar ciphertext

1735
01:28:04,620 --> 01:28:07,440
we decompose it into a vector of L

1736
01:28:07,440 --> 01:28:11,100
entries and we multiply it by a vector

1737
01:28:11,100 --> 01:28:13,260
ciphertext right so this is just an

1738
01:28:13,260 --> 01:28:15,719
inner product so the external products

1739
01:28:15,719 --> 01:28:17,580
is an operation between a scalar and a

1740
01:28:17,580 --> 01:28:20,840
vector ciphertext and it costs just L

1741
01:28:20,840 --> 01:28:26,120
multiplications on this polynomial ring

1742
01:28:26,580 --> 01:28:30,260
so when we compare with with the GSW

1743
01:28:30,260 --> 01:28:34,500
scheme we have this the descaler server

1744
01:28:34,500 --> 01:28:36,960
text now is just one polynomial instead

1745
01:28:36,960 --> 01:28:38,280
of two

1746
01:28:38,280 --> 01:28:40,679
and the full Cipher text in our case is

1747
01:28:40,679 --> 01:28:43,620
a vector with L polynomials while doing

1748
01:28:43,620 --> 01:28:47,400
GSW it's a matrix with four times L

1749
01:28:47,400 --> 01:28:49,560
polynomials and then the external

1750
01:28:49,560 --> 01:28:51,719
product is just an inner product in our

1751
01:28:51,719 --> 01:28:54,420
case so it just costs L polynomial

1752
01:28:54,420 --> 01:28:57,960
multiplications but with the GSW scheme

1753
01:28:57,960 --> 01:29:00,239
the external product is a vector matrix

1754
01:29:00,239 --> 01:29:02,940
multiplication and then it costs 4 times

1755
01:29:02,940 --> 01:29:06,919
L polynomial multiplications

1756
01:29:07,080 --> 01:29:10,860
now we will explain how we use the NGS

1757
01:29:10,860 --> 01:29:15,059
to orbiting fastbootstrappings

1758
01:29:15,120 --> 01:29:18,719
so we used the framework from View and

1759
01:29:18,719 --> 01:29:22,679
tfhe which which is essentially this so

1760
01:29:22,679 --> 01:29:25,880
we start with an lwe encryption

1761
01:29:25,880 --> 01:29:29,880
of some message and with some large

1762
01:29:29,880 --> 01:29:33,000
noise e and we want to obtain an LW

1763
01:29:33,000 --> 01:29:34,800
encryption of the same message but with

1764
01:29:34,800 --> 01:29:38,820
a small noise so what tfhe and

1765
01:29:38,820 --> 01:29:42,780
essentially fuel does is this we have a

1766
01:29:42,780 --> 01:29:45,600
main Loop using external products and

1767
01:29:45,600 --> 01:29:48,060
this so this is evaluated with the GSW

1768
01:29:48,060 --> 01:29:51,120
because the jsw implements the external

1769
01:29:51,120 --> 01:29:54,120
products and in this main Loop we are

1770
01:29:54,120 --> 01:29:56,699
essentially running the linear part of

1771
01:29:56,699 --> 01:29:58,800
the decryption of this scheme in the

1772
01:29:58,800 --> 01:30:02,940
exponent of this monomial X so what we

1773
01:30:02,940 --> 01:30:04,920
will be thinking is m

1774
01:30:04,920 --> 01:30:08,940
I scaled message M plus some noise here

1775
01:30:08,940 --> 01:30:11,219
in the exponent and this is encrypted

1776
01:30:11,219 --> 01:30:15,000
under the ring lwe instead of the lwe

1777
01:30:15,000 --> 01:30:18,179
and then there is a extraction which

1778
01:30:18,179 --> 01:30:21,300
takes this M from the exponent and puts

1779
01:30:21,300 --> 01:30:23,940
it in the coefficient and also keeps

1780
01:30:23,940 --> 01:30:27,360
switching so that we go from the rlwe

1781
01:30:27,360 --> 01:30:30,420
back to the lwe again and then this

1782
01:30:30,420 --> 01:30:32,880
gives us LW encryption of the same

1783
01:30:32,880 --> 01:30:37,080
message M but now this noise e doesn't

1784
01:30:37,080 --> 01:30:39,900
exist anymore we just have a new noise e

1785
01:30:39,900 --> 01:30:41,940
Prime which is a smaller than the

1786
01:30:41,940 --> 01:30:44,460
original noise so this is how tfhe does

1787
01:30:44,460 --> 01:30:46,580
it

1788
01:30:47,159 --> 01:30:49,500
well we already have the external

1789
01:30:49,500 --> 01:30:52,980
products with the NGS so we can run this

1790
01:30:52,980 --> 01:30:54,000
part

1791
01:30:54,000 --> 01:30:58,159
but when we do this we are between

1792
01:30:58,159 --> 01:31:01,320
a monomial encrypting this same value

1793
01:31:01,320 --> 01:31:03,780
but encrypted under n true instead of

1794
01:31:03,780 --> 01:31:05,340
rlwe

1795
01:31:05,340 --> 01:31:06,780
and then

1796
01:31:06,780 --> 01:31:09,060
this means that we need somehow to

1797
01:31:09,060 --> 01:31:12,719
extract and key switch

1798
01:31:12,719 --> 01:31:16,199
for in true now right

1799
01:31:16,199 --> 01:31:18,659
and also if we want everything to be

1800
01:31:18,659 --> 01:31:21,179
based on the entry problem then we need

1801
01:31:21,179 --> 01:31:24,000
a new scheme based on the untrue instead

1802
01:31:24,000 --> 01:31:25,739
of the lwe

1803
01:31:25,739 --> 01:31:29,460
so we'll start with this we show how we

1804
01:31:29,460 --> 01:31:33,120
constructed the base scheme based on the

1805
01:31:33,120 --> 01:31:35,820
intro so we used this Matrix entry

1806
01:31:35,820 --> 01:31:38,280
problem which is

1807
01:31:38,280 --> 01:31:41,719
kind of the corresponding of the

1808
01:31:41,719 --> 01:31:45,360
lwe for the rlwe right this is in true

1809
01:31:45,360 --> 01:31:48,719
without the ring so what this MN truth

1810
01:31:48,719 --> 01:31:52,920
says is that if you have a random a

1811
01:31:52,920 --> 01:31:57,300
small Norm Matrix G and a small Norm

1812
01:31:57,300 --> 01:31:59,820
Matrix F you take the inverse of f in

1813
01:31:59,820 --> 01:32:02,580
with pi by 3 then you get this Matrix C

1814
01:32:02,580 --> 01:32:04,920
that looks random just like for the

1815
01:32:04,920 --> 01:32:07,800
polynomial case right

1816
01:32:07,800 --> 01:32:10,080
well but if you take the ciphertext to

1817
01:32:10,080 --> 01:32:12,659
be a matrix then to decrypt you have to

1818
01:32:12,659 --> 01:32:14,880
multiply by The Matrix F and we don't

1819
01:32:14,880 --> 01:32:17,040
want the decryption to be a matrix

1820
01:32:17,040 --> 01:32:18,840
matrix multiplication because this is

1821
01:32:18,840 --> 01:32:21,300
too complicated we want the decryption

1822
01:32:21,300 --> 01:32:24,659
to be simple so just an inner product a

1823
01:32:24,659 --> 01:32:26,460
vector vector multiplication right so

1824
01:32:26,460 --> 01:32:29,040
what we do is instead of considering the

1825
01:32:29,040 --> 01:32:31,500
whole Matrix C we just take the first

1826
01:32:31,500 --> 01:32:33,840
row of c and we use these as the cipher

1827
01:32:33,840 --> 01:32:36,659
text right and if you check it the first

1828
01:32:36,659 --> 01:32:39,540
row of C is actually the The Matrix G

1829
01:32:39,540 --> 01:32:41,820
times the first column of the inverse of

1830
01:32:41,820 --> 01:32:45,120
f right so now we have a vector of

1831
01:32:45,120 --> 01:32:49,560
Dimension n and then to decrypt now we

1832
01:32:49,560 --> 01:32:52,380
just encrypt the message in the first

1833
01:32:52,380 --> 01:32:55,739
entry of this Vector C so to decrypt we

1834
01:32:55,739 --> 01:32:58,679
just need to multiply by the First

1835
01:32:58,679 --> 01:33:01,860
Column of this Matrix F instead of by F

1836
01:33:01,860 --> 01:33:05,159
right so if they find this a small F

1837
01:33:05,159 --> 01:33:07,320
here is the First Column of f the

1838
01:33:07,320 --> 01:33:09,780
description is just this inner product c

1839
01:33:09,780 --> 01:33:11,159
times f

1840
01:33:11,159 --> 01:33:13,800
and then because this is just a inner

1841
01:33:13,800 --> 01:33:15,780
product we can compute it in the

1842
01:33:15,780 --> 01:33:18,300
exponent of X using the external

1843
01:33:18,300 --> 01:33:22,139
products of the NGS

1844
01:33:22,139 --> 01:33:24,420
scheme

1845
01:33:24,420 --> 01:33:29,040
so now uh the bootstrapping goes like

1846
01:33:29,040 --> 01:33:31,080
this we start with an encryption of some

1847
01:33:31,080 --> 01:33:35,699
message M under this Vector small F and

1848
01:33:35,699 --> 01:33:38,840
then we use an external products to

1849
01:33:38,840 --> 01:33:42,120
multiply this this Vector ciphertext

1850
01:33:42,120 --> 01:33:45,179
this by um

1851
01:33:45,179 --> 01:33:48,900
by this secret Vector F here so what we

1852
01:33:48,900 --> 01:33:52,020
will be telling is this monomial uh and

1853
01:33:52,020 --> 01:33:54,420
in the exponent of it we get the error

1854
01:33:54,420 --> 01:33:56,280
plus the scaled message right and this

1855
01:33:56,280 --> 01:33:58,860
is a normal entry encryption so it's

1856
01:33:58,860 --> 01:34:02,340
encrypted under this polynomial F and

1857
01:34:02,340 --> 01:34:05,219
belongs to this polynomial ring

1858
01:34:05,219 --> 01:34:07,440
and then we run the extraction

1859
01:34:07,440 --> 01:34:09,840
essentially in the same way as tfhe so

1860
01:34:09,840 --> 01:34:13,500
this eliminates this e here removes this

1861
01:34:13,500 --> 01:34:15,000
noise e that we had in the original

1862
01:34:15,000 --> 01:34:17,639
ciphertext and brings M from the

1863
01:34:17,639 --> 01:34:21,300
exponent to the coefficient here

1864
01:34:21,300 --> 01:34:23,540
and

1865
01:34:23,540 --> 01:34:27,179
then we propose a key switching for n

1866
01:34:27,179 --> 01:34:29,460
true Cipher texts right because this is

1867
01:34:29,460 --> 01:34:32,159
encrypted under Andrew

1868
01:34:32,159 --> 01:34:33,900
and

1869
01:34:33,900 --> 01:34:38,400
we apply this uh key switching to go

1870
01:34:38,400 --> 01:34:41,159
back from an encryption of Dimension

1871
01:34:41,159 --> 01:34:44,639
capital n two Dimension small n and also

1872
01:34:44,639 --> 01:34:48,360
to switch the key from this polynomial F

1873
01:34:48,360 --> 01:34:51,600
to the vector F that we had in the

1874
01:34:51,600 --> 01:34:54,780
beginning so the output has this has

1875
01:34:54,780 --> 01:34:58,020
exactly the same format as the input so

1876
01:34:58,020 --> 01:34:59,940
it's an encryption of the same message

1877
01:34:59,940 --> 01:35:03,420
but with a smaller noise right and then

1878
01:35:03,420 --> 01:35:06,719
we can set all the parameters below the

1879
01:35:06,719 --> 01:35:08,460
fatigue point

1880
01:35:08,460 --> 01:35:12,060
so now we have

1881
01:35:12,060 --> 01:35:13,040
um

1882
01:35:13,040 --> 01:35:16,620
fhe with fastbootstrapping based only on

1883
01:35:16,620 --> 01:35:18,300
the intro problem right so we start with

1884
01:35:18,300 --> 01:35:20,940
an intro encryption of some message M

1885
01:35:20,940 --> 01:35:23,520
with large noise e we use the external

1886
01:35:23,520 --> 01:35:25,800
products and we get an entry encryption

1887
01:35:25,800 --> 01:35:28,139
of this monomial with the message plus

1888
01:35:28,139 --> 01:35:30,360
some noise in the exponent and we have

1889
01:35:30,360 --> 01:35:31,920
the extraction and key switching which

1890
01:35:31,920 --> 01:35:35,280
give us an intro encryption of this same

1891
01:35:35,280 --> 01:35:37,980
message M again but with a smaller noise

1892
01:35:37,980 --> 01:35:40,638
e Prime

1893
01:35:41,219 --> 01:35:44,159
we also use the NGS to bootstrap a skin

1894
01:35:44,159 --> 01:35:46,980
based on the lwe so when we have a

1895
01:35:46,980 --> 01:35:50,219
scheme based on the lwe just like in few

1896
01:35:50,219 --> 01:35:53,639
or in the in tfhe the ciphertexts have

1897
01:35:53,639 --> 01:35:56,280
this form so to encrypt the message M

1898
01:35:56,280 --> 01:35:59,040
under secret key s we sample this

1899
01:35:59,040 --> 01:36:00,380
uniform

1900
01:36:00,380 --> 01:36:03,120
Vector a and then we compute this

1901
01:36:03,120 --> 01:36:05,460
integer b as the inner product of this

1902
01:36:05,460 --> 01:36:08,460
uniform a times the secret s we add some

1903
01:36:08,460 --> 01:36:10,800
noise in this scaled message right all

1904
01:36:10,800 --> 01:36:12,960
of this module Q

1905
01:36:12,960 --> 01:36:15,719
so to decrypt essentially you have to

1906
01:36:15,719 --> 01:36:19,440
take this public a multiply by S this is

1907
01:36:19,440 --> 01:36:21,719
an inner product just just before and

1908
01:36:21,719 --> 01:36:23,880
subtract from B so this we can already

1909
01:36:23,880 --> 01:36:27,120
do using the external products of NGS

1910
01:36:27,120 --> 01:36:29,159
right then we obtain an encryption of

1911
01:36:29,159 --> 01:36:33,000
this monomial B minus a times s which is

1912
01:36:33,000 --> 01:36:35,760
an encryption of the scaled message plus

1913
01:36:35,760 --> 01:36:37,500
some noise and all of this encrypted

1914
01:36:37,500 --> 01:36:40,500
under the secret polynomial F of the

1915
01:36:40,500 --> 01:36:42,239
entry problem

1916
01:36:42,239 --> 01:36:43,739
so

1917
01:36:43,739 --> 01:36:45,960
this means that we already have this

1918
01:36:45,960 --> 01:36:48,239
first step of the the bootstrapping

1919
01:36:48,239 --> 01:36:50,340
framework right we can start with LW

1920
01:36:50,340 --> 01:36:52,500
encryption of some message M with large

1921
01:36:52,500 --> 01:36:55,679
noise e we run the external products

1922
01:36:55,679 --> 01:36:59,040
using NGS and we get an entry encryption

1923
01:36:59,040 --> 01:37:02,340
of this power of x

1924
01:37:02,340 --> 01:37:03,719
now

1925
01:37:03,719 --> 01:37:07,560
uh to go back to lwe

1926
01:37:07,560 --> 01:37:11,280
we proposed a key switching that

1927
01:37:11,280 --> 01:37:13,679
switched from the end through to the LW

1928
01:37:13,679 --> 01:37:16,020
problem so we run the extraction as

1929
01:37:16,020 --> 01:37:18,360
before this give us an entry encryption

1930
01:37:18,360 --> 01:37:21,239
of M and removes this e and then we run

1931
01:37:21,239 --> 01:37:24,600
this new intro to lwe key switching to

1932
01:37:24,600 --> 01:37:26,940
switch from an encryption of M under N2

1933
01:37:26,940 --> 01:37:30,600
to an encryption of M under the lwe

1934
01:37:30,600 --> 01:37:33,360
problem and this closes the loop and

1935
01:37:33,360 --> 01:37:37,460
completes the bootstrapping procedure

1936
01:37:39,719 --> 01:37:42,060
so now we are going to see the Practical

1937
01:37:42,060 --> 01:37:43,880
results

1938
01:37:43,880 --> 01:37:47,940
we implemented everything in C plus and

1939
01:37:47,940 --> 01:37:49,320
this implementation is publicly

1940
01:37:49,320 --> 01:37:51,420
available so you can go to this git wrap

1941
01:37:51,420 --> 01:37:53,219
repository and download it and install

1942
01:37:53,219 --> 01:37:54,840
and play with it

1943
01:37:54,840 --> 01:37:58,980
and because we mainly wanted to compare

1944
01:37:58,980 --> 01:38:01,199
with tfhe which is the state of the art

1945
01:38:01,199 --> 01:38:02,540
for

1946
01:38:02,540 --> 01:38:04,860
binary circuits

1947
01:38:04,860 --> 01:38:08,400
we used the same fft Library as tfhe key

1948
01:38:08,400 --> 01:38:10,920
and then we compiled our code with the

1949
01:38:10,920 --> 01:38:13,800
same compilation flags as tfhe

1950
01:38:13,800 --> 01:38:17,580
and we try to use similar parameters as

1951
01:38:17,580 --> 01:38:20,040
the ones used in tfhe

1952
01:38:20,040 --> 01:38:21,780
so

1953
01:38:21,780 --> 01:38:26,699
we we have two is two fhe uh schemes now

1954
01:38:26,699 --> 01:38:28,620
we have one that is based on and true

1955
01:38:28,620 --> 01:38:31,260
that we call M and true here and one

1956
01:38:31,260 --> 01:38:33,420
that is based on the lwv right and then

1957
01:38:33,420 --> 01:38:35,880
we bootstrap both of them using NGS

1958
01:38:35,880 --> 01:38:40,080
which is based on true so these are the

1959
01:38:40,080 --> 01:38:43,139
parameters for these base schemes

1960
01:38:43,139 --> 01:38:45,659
so the dimension of the ciphertext that

1961
01:38:45,659 --> 01:38:47,520
we want to bootstrap with and true is

1962
01:38:47,520 --> 01:38:52,920
800 and with lwv is 610. so for tfhe

1963
01:38:52,920 --> 01:38:56,400
they use lwe ciphertexts and then the

1964
01:38:56,400 --> 01:38:59,100
dimension is about 600 as well

1965
01:38:59,100 --> 01:39:03,780
and for the NGS the degree of the

1966
01:39:03,780 --> 01:39:04,860
polynomials that we have in the

1967
01:39:04,860 --> 01:39:07,739
polynomial ring is always 2 to the 10.

1968
01:39:07,739 --> 01:39:10,920
in our case and what changes essentially

1969
01:39:10,920 --> 01:39:13,920
is the decomposition base from one case

1970
01:39:13,920 --> 01:39:16,820
to the other and for tfhe this Dimension

1971
01:39:16,820 --> 01:39:20,340
here is also 2 to the ten so this means

1972
01:39:20,340 --> 01:39:24,560
that RTF our ffts the Fourier transforms

1973
01:39:24,560 --> 01:39:27,600
are over the same Dimension as in tfhe

1974
01:39:27,600 --> 01:39:31,219
right so they are really comparable

1975
01:39:31,860 --> 01:39:34,980
and we have to

1976
01:39:34,980 --> 01:39:38,639
to remark that this value n here

1977
01:39:38,639 --> 01:39:41,820
this tells how many external products we

1978
01:39:41,820 --> 01:39:46,260
have to run so the thing is for MN true

1979
01:39:46,260 --> 01:39:48,780
we see that we have 800 this is much

1980
01:39:48,780 --> 01:39:53,880
more than in the lwe case so even if our

1981
01:39:53,880 --> 01:39:57,000
each of our external products is cheaper

1982
01:39:57,000 --> 01:39:59,340
than in the fhe because you have to run

1983
01:39:59,340 --> 01:40:03,120
much more of them at the end our end MN

1984
01:40:03,120 --> 01:40:07,800
true scheme is slower than the tfhe but

1985
01:40:07,800 --> 01:40:10,080
for the LW case because the number of

1986
01:40:10,080 --> 01:40:13,020
external products is similar to the tfhe

1987
01:40:13,020 --> 01:40:15,060
case and each external product is

1988
01:40:15,060 --> 01:40:19,500
cheaper than our lwe within true is

1989
01:40:19,500 --> 01:40:22,020
faster than in tfhe

1990
01:40:22,020 --> 01:40:25,679
so when we run tfhe in our experiments

1991
01:40:25,679 --> 01:40:28,980
we got that each bootstrapping takes

1992
01:40:28,980 --> 01:40:33,780
around six uh 66 milliseconds

1993
01:40:33,780 --> 01:40:37,980
and then for our MN true we got 92 so

1994
01:40:37,980 --> 01:40:39,480
this is

1995
01:40:39,480 --> 01:40:41,639
kind of similar same order of magnitude

1996
01:40:41,639 --> 01:40:45,000
but it's lower right but our combination

1997
01:40:45,000 --> 01:40:48,900
of lwv and in true runs the bootstrap in

1998
01:40:48,900 --> 01:40:51,060
48 milliseconds

1999
01:40:51,060 --> 01:40:53,880
and we can see here that that's the main

2000
01:40:53,880 --> 01:40:57,480
reason because the number of ffts is uh

2001
01:40:57,480 --> 01:41:01,139
much smaller in our case so essentially

2002
01:41:01,139 --> 01:41:04,800
what we got is that if we check here the

2003
01:41:04,800 --> 01:41:06,780
bootstrapping key and the key switching

2004
01:41:06,780 --> 01:41:09,239
key they are much smaller than in tfhe

2005
01:41:09,239 --> 01:41:11,100
so the key material that we need is

2006
01:41:11,100 --> 01:41:15,300
about uh half of what the fhe needs and

2007
01:41:15,300 --> 01:41:20,659
the bootstrap in time is about 28 faster

2008
01:41:22,560 --> 01:41:26,040
so to conclude we proposed an fhe scheme

2009
01:41:26,040 --> 01:41:29,580
based on in true with parameters that

2010
01:41:29,580 --> 01:41:33,600
lie uh below the fatigue point so

2011
01:41:33,600 --> 01:41:35,880
outside of this stretched regime

2012
01:41:35,880 --> 01:41:40,380
and so this brings back into FH it's the

2013
01:41:40,380 --> 01:41:42,300
game and we hope that this result will

2014
01:41:42,300 --> 01:41:45,420
bring more attention of the academic

2015
01:41:45,420 --> 01:41:49,560
community so that people can do further

2016
01:41:49,560 --> 01:41:52,739
researcher on Andrew based fhe

2017
01:41:52,739 --> 01:41:55,320
and maybe improve the efficience of our

2018
01:41:55,320 --> 01:41:57,840
scheme or create new schemes based on

2019
01:41:57,840 --> 01:42:00,300
intro

2020
01:42:00,300 --> 01:42:05,580
and well we proposed this a scheme that

2021
01:42:05,580 --> 01:42:09,900
looks like jsw but is based on N2 so we

2022
01:42:09,900 --> 01:42:12,360
called it NGS and it has a smaller

2023
01:42:12,360 --> 01:42:15,420
Cipher texts and faster homework

2024
01:42:15,420 --> 01:42:18,119
multiplication when compared to the rlw

2025
01:42:18,119 --> 01:42:21,300
based GSW so

2026
01:42:21,300 --> 01:42:23,880
we hope that this NGS will also be

2027
01:42:23,880 --> 01:42:25,980
useful for other applications so

2028
01:42:25,980 --> 01:42:29,159
essentially where GSW is used maybe we

2029
01:42:29,159 --> 01:42:32,760
can use NGS instead

2030
01:42:32,760 --> 01:42:36,900
and finally we proposed this uh

2031
01:42:36,900 --> 01:42:42,179
uh fhe scheme mixing and true and lwe

2032
01:42:42,179 --> 01:42:46,260
and we saw that this runs faster than

2033
01:42:46,260 --> 01:42:48,860
tfhe

2034
01:42:49,619 --> 01:42:52,380
so that's all if you have any questions

2035
01:42:52,380 --> 01:42:55,619
or comment please feel free to contact

2036
01:42:55,619 --> 01:42:57,780
me

2037
01:42:57,780 --> 01:43:00,500
thank you all

2038
01:43:05,639 --> 01:43:09,480
okay so we are running late and uh the

2039
01:43:09,480 --> 01:43:11,219
attendees from the other room are

2040
01:43:11,219 --> 01:43:14,400
starving in front of the footer so if if

2041
01:43:14,400 --> 01:43:16,260
there is a quick question we can take it

2042
01:43:16,260 --> 01:43:21,659
but otherwise I suggest we do it offline

2043
01:43:21,659 --> 01:43:24,739
any quick question

2044
01:43:26,100 --> 01:43:30,840
okay so let's thank uh Hilda again

2045
01:43:30,840 --> 01:43:33,739
thank you very much

2046
01:43:45,179 --> 01:43:49,320
the vegetarian options are I mean there

2047
01:43:49,320 --> 01:43:52,460
are more vegetarian options

