1
00:00:00,000 --> 00:00:05,279
parties we've inputs X1 to xn there is

2
00:00:05,279 --> 00:00:07,319
an adversary who corrupts at most tea

3
00:00:07,319 --> 00:00:09,360
parties where T is at most half of the

4
00:00:09,360 --> 00:00:12,300
parties typically in this setting and

5
00:00:12,300 --> 00:00:13,740
your goal is to compute some public

6
00:00:13,740 --> 00:00:15,719
function f without triggering anything

7
00:00:15,719 --> 00:00:18,900
more than the result of the function

8
00:00:18,900 --> 00:00:20,699
okay so information theoretic

9
00:00:20,699 --> 00:00:22,920
computation has been well studied and

10
00:00:22,920 --> 00:00:24,420
among the many things that are well

11
00:00:24,420 --> 00:00:27,240
known we know that it's impossible to

12
00:00:27,240 --> 00:00:29,220
securely compute a function if you don't

13
00:00:29,220 --> 00:00:31,560
use Randomness right deterministic

14
00:00:31,560 --> 00:00:33,780
secure computation is not possible you

15
00:00:33,780 --> 00:00:35,059
need the ability

16
00:00:35,059 --> 00:00:37,380
for the parties to toss

17
00:00:37,380 --> 00:00:40,379
cryptographically secure random coins

18
00:00:40,379 --> 00:00:42,480
so a well-stated question is to

19
00:00:42,480 --> 00:00:45,059
understand how much Randomness do we

20
00:00:45,059 --> 00:00:47,700
need to securely compute some arbitrary

21
00:00:47,700 --> 00:00:49,140
function f

22
00:00:49,140 --> 00:00:51,960
and the motivation for that is that it's

23
00:00:51,960 --> 00:00:53,879
not always easy in the real world to

24
00:00:53,879 --> 00:00:55,440
produce high quality cryptographic

25
00:00:55,440 --> 00:00:57,420
Randomness you need to use the proper

26
00:00:57,420 --> 00:00:59,100
piece of code you need to use a good

27
00:00:59,100 --> 00:01:02,520
Randomness generation strategy so it's

28
00:01:02,520 --> 00:01:05,400
natural to treat Randomness as a scarce

29
00:01:05,400 --> 00:01:08,220
resource and to attempt to minimize how

30
00:01:08,220 --> 00:01:10,920
much of it we need

31
00:01:10,920 --> 00:01:12,960
in this work we ask a different but

32
00:01:12,960 --> 00:01:15,000
related question which to our knowledge

33
00:01:15,000 --> 00:01:17,100
was never asked in the past

34
00:01:17,100 --> 00:01:19,860
what we ask is what is the minimum

35
00:01:19,860 --> 00:01:22,799
number of parties in a protocol that

36
00:01:22,799 --> 00:01:24,780
need to have the ability to toss coins

37
00:01:24,780 --> 00:01:27,119
in order to be able to evaluate an

38
00:01:27,119 --> 00:01:29,939
arbitrary function f

39
00:01:29,939 --> 00:01:31,860
so the motivation for this related

40
00:01:31,860 --> 00:01:34,860
question is slightly similar

41
00:01:34,860 --> 00:01:37,500
um in the real world our Randomness

42
00:01:37,500 --> 00:01:40,380
generation abilities might differ some

43
00:01:40,380 --> 00:01:42,720
may be using a powerful server with a

44
00:01:42,720 --> 00:01:44,280
proper implementation of the

45
00:01:44,280 --> 00:01:48,540
cryptographic mechanism and so This

46
00:01:48,540 --> 00:01:50,280
Server might be able to produce real

47
00:01:50,280 --> 00:01:52,320
reliably high quality Randomness and

48
00:01:52,320 --> 00:01:54,299
everyone might be okay trusting this

49
00:01:54,299 --> 00:01:56,720
Randomness but others might be using

50
00:01:56,720 --> 00:01:59,820
less trusted software or less powerful

51
00:01:59,820 --> 00:02:02,880
devices and we might not want to trust

52
00:02:02,880 --> 00:02:05,640
their ability to generate high quality

53
00:02:05,640 --> 00:02:07,320
Randomness throughout the protocol so

54
00:02:07,320 --> 00:02:09,899
for example in my example we might want

55
00:02:09,899 --> 00:02:13,440
to ask the two parties hold that user

56
00:02:13,440 --> 00:02:14,879
cell phone to participate to the

57
00:02:14,879 --> 00:02:17,700
protocol to not produce random coins

58
00:02:17,700 --> 00:02:18,840
during the protocol we don't want to

59
00:02:18,840 --> 00:02:20,580
trust their ability to toast

60
00:02:20,580 --> 00:02:22,860
cryptographically secure random coins so

61
00:02:22,860 --> 00:02:24,180
is it possible to run the protocol

62
00:02:24,180 --> 00:02:28,560
without having them sourcing any cons

63
00:02:28,560 --> 00:02:30,840
so that's the question we ask

64
00:02:30,840 --> 00:02:33,660
and our main results

65
00:02:33,660 --> 00:02:37,500
is a complete characterization of what

66
00:02:37,500 --> 00:02:40,319
we call the random Source complexity of

67
00:02:40,319 --> 00:02:42,900
T private computation where T stands for

68
00:02:42,900 --> 00:02:46,440
the number of corrupted parties

69
00:02:46,440 --> 00:02:49,080
so I'm giving you the picture here

70
00:02:49,080 --> 00:02:51,480
um what was known before was this result

71
00:02:51,480 --> 00:02:54,239
by Khushi Levitz and mensur from podc 96

72
00:02:54,239 --> 00:02:56,640
which shows that tea parties need to

73
00:02:56,640 --> 00:02:58,739
have the ability to those coins to be

74
00:02:58,739 --> 00:03:00,780
able to T privately compute some

75
00:03:00,780 --> 00:03:02,760
functions and in particular the xor

76
00:03:02,760 --> 00:03:04,500
function where the parties want to

77
00:03:04,500 --> 00:03:07,620
obtain the xor of other inputs so

78
00:03:07,620 --> 00:03:09,660
actually at the time Kush Levitz and

79
00:03:09,660 --> 00:03:12,720
Mentor wanted to prove a lower bound on

80
00:03:12,720 --> 00:03:15,120
the number of bits you need to chose to

81
00:03:15,120 --> 00:03:18,319
compute the xor functionality but

82
00:03:18,319 --> 00:03:22,260
sorry actually they're lower bound

83
00:03:22,260 --> 00:03:24,540
um is proven by showing that you need at

84
00:03:24,540 --> 00:03:26,099
least two different parties to have the

85
00:03:26,099 --> 00:03:29,040
ability to toss random coins so we

86
00:03:29,040 --> 00:03:31,080
observe that it in particular it extends

87
00:03:31,080 --> 00:03:33,239
to the stronger result uh that you need

88
00:03:33,239 --> 00:03:35,280
two different that you need at least T

89
00:03:35,280 --> 00:03:36,360
sources

90
00:03:36,360 --> 00:03:38,819
for any function for some simple

91
00:03:38,819 --> 00:03:42,120
functionality such as xor

92
00:03:42,120 --> 00:03:44,879
so that's for previous work so we start

93
00:03:44,879 --> 00:03:47,720
with two relatively easy results

94
00:03:47,720 --> 00:03:50,700
we show that you can actually slightly

95
00:03:50,700 --> 00:03:52,620
straighten the kushlovich and mens or

96
00:03:52,620 --> 00:03:54,540
lower Bound for some randomized

97
00:03:54,540 --> 00:03:56,099
functionalities you can show that you

98
00:03:56,099 --> 00:03:59,220
actually need t plus one parties with

99
00:03:59,220 --> 00:04:01,920
the ability to toss random coins

100
00:04:01,920 --> 00:04:04,319
and furthermore there is a matching

101
00:04:04,319 --> 00:04:05,519
upper bound

102
00:04:05,519 --> 00:04:08,340
showing that t plus one parties is

103
00:04:08,340 --> 00:04:10,739
sufficient to T privately compute any

104
00:04:10,739 --> 00:04:12,900
functionality so in the sense I call

105
00:04:12,900 --> 00:04:14,760
that the easy results because that's

106
00:04:14,760 --> 00:04:19,139
what makes sense right uh if uh if the

107
00:04:19,139 --> 00:04:22,260
parties can correct to T players then if

108
00:04:22,260 --> 00:04:23,940
you have t plus one parties who can

109
00:04:23,940 --> 00:04:26,639
those coins you will always have one

110
00:04:26,639 --> 00:04:28,800
non-corrupted party who can toss

111
00:04:28,800 --> 00:04:30,840
Randomness so someone will produce

112
00:04:30,840 --> 00:04:33,060
Randomness which cannot be corrupted and

113
00:04:33,060 --> 00:04:34,440
if you do it the right way you can use

114
00:04:34,440 --> 00:04:36,900
this Randomness for everyone in the

115
00:04:36,900 --> 00:04:38,940
protocol so that makes sense and that's

116
00:04:38,940 --> 00:04:41,040
actually not too hard to prove

117
00:04:41,040 --> 00:04:43,500
however is a really

118
00:04:43,500 --> 00:04:45,000
um non-trivial and interesting result

119
00:04:45,000 --> 00:04:47,940
which is our core result is this one on

120
00:04:47,940 --> 00:04:49,080
the bottom left

121
00:04:49,080 --> 00:04:51,300
we show that if we only look at

122
00:04:51,300 --> 00:04:53,100
deterministic functionalities so which

123
00:04:53,100 --> 00:04:55,560
is still a huge class of functionalities

124
00:04:55,560 --> 00:04:58,800
it actually suffices and that tea

125
00:04:58,800 --> 00:05:00,960
parties have the ability to toast coins

126
00:05:00,960 --> 00:05:04,139
to T privately compute any deterministic

127
00:05:04,139 --> 00:05:06,740
functionality

128
00:05:08,639 --> 00:05:10,800
so I want to

129
00:05:10,800 --> 00:05:13,560
um oops I want to let a minute to let

130
00:05:13,560 --> 00:05:15,840
this sink in because it should be

131
00:05:15,840 --> 00:05:18,419
surprising so what I'm saying is we know

132
00:05:18,419 --> 00:05:21,060
that secure computation is impossible if

133
00:05:21,060 --> 00:05:23,699
the parties are deterministic but here

134
00:05:23,699 --> 00:05:25,680
I'm claiming that secure computation for

135
00:05:25,680 --> 00:05:27,000
all deterministic functionalities

136
00:05:27,000 --> 00:05:30,060
becomes feasible even in a world where

137
00:05:30,060 --> 00:05:32,039
the adversary could potentially corrupt

138
00:05:32,039 --> 00:05:33,960
all the parties who can toss random

139
00:05:33,960 --> 00:05:37,199
coins so somehow it's possible to do

140
00:05:37,199 --> 00:05:39,360
secure computation with Randomness that

141
00:05:39,360 --> 00:05:42,180
could potentially be entirely seen by

142
00:05:42,180 --> 00:05:43,380
the adversary

143
00:05:43,380 --> 00:05:45,180
and I don't know for you but to me it

144
00:05:45,180 --> 00:05:46,919
really sounds uh surprising at first

145
00:05:46,919 --> 00:05:48,600
sight

146
00:05:48,600 --> 00:05:52,400
so that for our first results

147
00:05:53,419 --> 00:05:55,740
uh okay

148
00:05:55,740 --> 00:05:59,759
yeah so um our second results is to try

149
00:05:59,759 --> 00:06:01,380
to understand a bit better the relation

150
00:06:01,380 --> 00:06:03,720
between the randomness complexity and

151
00:06:03,720 --> 00:06:05,280
the random Source complexity so in

152
00:06:05,280 --> 00:06:06,900
particular if you want to use a minimal

153
00:06:06,900 --> 00:06:10,680
amount of random sources can you do it

154
00:06:10,680 --> 00:06:13,139
while using a not too much Randomness or

155
00:06:13,139 --> 00:06:14,580
do you need to blow up the amount of

156
00:06:14,580 --> 00:06:17,820
Randomness you need to use okay

157
00:06:17,820 --> 00:06:20,580
so it's typically very very hard to

158
00:06:20,580 --> 00:06:22,199
prove Randomness lower bounds in

159
00:06:22,199 --> 00:06:24,479
cryptography and in in general tight

160
00:06:24,479 --> 00:06:26,460
overbounds have only been proven for

161
00:06:26,460 --> 00:06:28,680
very simple functionalities so as is

162
00:06:28,680 --> 00:06:30,539
standard in the literature we focus on

163
00:06:30,539 --> 00:06:33,479
some very simple functionalities xor has

164
00:06:33,479 --> 00:06:35,340
been handled by Kush Levitz and mensor

165
00:06:35,340 --> 00:06:37,919
so we look into the end functionality

166
00:06:37,919 --> 00:06:40,080
and we look at the simplest case of one

167
00:06:40,080 --> 00:06:41,280
privacy

168
00:06:41,280 --> 00:06:43,800
and even in this very simple case we

169
00:06:43,800 --> 00:06:45,539
don't have tight upper and lower bounds

170
00:06:45,539 --> 00:06:47,819
uh it's a it's a hard problem it has

171
00:06:47,819 --> 00:06:49,020
been looked at

172
00:06:49,020 --> 00:06:51,060
a few times in the past

173
00:06:51,060 --> 00:06:53,520
So currently the best known protocol for

174
00:06:53,520 --> 00:06:57,600
one private and party end is a tcc-19

175
00:06:57,600 --> 00:07:00,240
paper that securely compute the end

176
00:07:00,240 --> 00:07:02,280
party end using eight bits of Randomness

177
00:07:02,280 --> 00:07:05,460
and two sources so we ask well if you

178
00:07:05,460 --> 00:07:06,960
want to use a minimum number of sources

179
00:07:06,960 --> 00:07:09,539
which by our previous result is one is

180
00:07:09,539 --> 00:07:11,220
it possible to match this lower bound

181
00:07:11,220 --> 00:07:13,380
and surprisingly we actually managed to

182
00:07:13,380 --> 00:07:15,539
improve simultaneously the randomness

183
00:07:15,539 --> 00:07:17,639
complexity of the protocol and we lower

184
00:07:17,639 --> 00:07:20,400
it to six bits and to use a single

185
00:07:20,400 --> 00:07:22,860
source so it's a result which is also of

186
00:07:22,860 --> 00:07:24,720
independent interest as the study of

187
00:07:24,720 --> 00:07:26,340
Randomness complexity for some simple

188
00:07:26,340 --> 00:07:29,119
function analysis

189
00:07:29,400 --> 00:07:30,720
so

190
00:07:30,720 --> 00:07:31,979
um

191
00:07:31,979 --> 00:07:34,440
as a starting point as a warm-up I'll

192
00:07:34,440 --> 00:07:36,419
explain why if you have t plus one

193
00:07:36,419 --> 00:07:39,240
sources you can t privately compute all

194
00:07:39,240 --> 00:07:41,160
functionalities which is a result that

195
00:07:41,160 --> 00:07:43,800
you should expect to hold

196
00:07:43,800 --> 00:07:45,840
and then I'll devote most of the

197
00:07:45,840 --> 00:07:48,720
presentation to our core result and the

198
00:07:48,720 --> 00:07:50,699
fact that if for deterministic

199
00:07:50,699 --> 00:07:52,199
functionality is actually T parties

200
00:07:52,199 --> 00:07:54,120
tossing coins are necessary if you want

201
00:07:54,120 --> 00:07:55,800
to see the lower Bond I encourage you to

202
00:07:55,800 --> 00:07:59,000
to see the the paper

203
00:07:59,940 --> 00:08:00,900
um

204
00:08:00,900 --> 00:08:03,539
so assume you have two plus one sources

205
00:08:03,539 --> 00:08:05,819
so here I take five parties I assume

206
00:08:05,819 --> 00:08:09,419
that t is uh um is two so we have a

207
00:08:09,419 --> 00:08:12,060
highness majority and so we have three

208
00:08:12,060 --> 00:08:13,860
parties who can those random coins the

209
00:08:13,860 --> 00:08:15,840
big deal here with those little coins

210
00:08:15,840 --> 00:08:17,759
and you want to compute some function f

211
00:08:17,759 --> 00:08:20,099
okay

212
00:08:20,099 --> 00:08:21,360
so

213
00:08:21,360 --> 00:08:26,460
um the ID is just to let all the parties

214
00:08:26,460 --> 00:08:27,240
um

215
00:08:27,240 --> 00:08:29,220
which can tell us from them coins we

216
00:08:29,220 --> 00:08:31,440
just want to let them all send a random

217
00:08:31,440 --> 00:08:33,360
tape to each party who cannot us random

218
00:08:33,360 --> 00:08:35,279
coins right so my first my party here

219
00:08:35,279 --> 00:08:37,860
will send a random tape to the two

220
00:08:37,860 --> 00:08:40,559
parties here uh who can adjust random

221
00:08:40,559 --> 00:08:42,599
coins and so we'll do everyone with the

222
00:08:42,599 --> 00:08:44,580
ability to those coins and in the end

223
00:08:44,580 --> 00:08:46,140
all the parties who did not have a

224
00:08:46,140 --> 00:08:48,540
random tape set their random tape to the

225
00:08:48,540 --> 00:08:51,839
xor of all random tape uh you uh

226
00:08:51,839 --> 00:08:53,760
received from all parties who can those

227
00:08:53,760 --> 00:08:56,339
coins and of course

228
00:08:56,339 --> 00:08:58,019
um afterwards with all these random

229
00:08:58,019 --> 00:08:59,540
tapes they can run any information

230
00:08:59,540 --> 00:09:03,360
certification they like for example bgw

231
00:09:03,360 --> 00:09:06,600
and um this works fine because since

232
00:09:06,600 --> 00:09:09,360
there are t plus one sources there will

233
00:09:09,360 --> 00:09:11,880
always be an uncorrected source so when

234
00:09:11,880 --> 00:09:13,500
you xsort the random tapes from the

235
00:09:13,500 --> 00:09:15,000
Viewpoint of the adversaries this random

236
00:09:15,000 --> 00:09:16,620
tapes will be truly random so we can

237
00:09:16,620 --> 00:09:18,300
just invoke the security for example of

238
00:09:18,300 --> 00:09:23,339
bgw right so that's simple

239
00:09:23,339 --> 00:09:26,040
um now how do we do if we actually want

240
00:09:26,040 --> 00:09:28,380
to have only T sources so now I go back

241
00:09:28,380 --> 00:09:30,180
to setting of computing F but I want to

242
00:09:30,180 --> 00:09:32,519
compute the deterministic function and I

243
00:09:32,519 --> 00:09:34,860
only have two parties who can toss

244
00:09:34,860 --> 00:09:36,120
random cards

245
00:09:36,120 --> 00:09:39,300
and here I have to deal with the fact

246
00:09:39,300 --> 00:09:41,040
that the adversary could potentially

247
00:09:41,040 --> 00:09:43,560
corrupt all the sources in which case

248
00:09:43,560 --> 00:09:45,720
you will see all the randomness ever

249
00:09:45,720 --> 00:09:47,519
used in the protocol

250
00:09:47,519 --> 00:09:51,120
so if I want to defend against that I

251
00:09:51,120 --> 00:09:53,399
have to isolate the sources

252
00:09:53,399 --> 00:09:56,880
in a sense I have to Shield uh the

253
00:09:56,880 --> 00:09:59,279
adversary from seeing things that these

254
00:09:59,279 --> 00:10:00,779
sources could see throughout the

255
00:10:00,779 --> 00:10:03,019
protocol

256
00:10:04,620 --> 00:10:08,519
hmm so we put the sources aside right

257
00:10:08,519 --> 00:10:11,399
and um because we don't want them to

258
00:10:11,399 --> 00:10:14,040
participate to the protocol we will let

259
00:10:14,040 --> 00:10:16,740
them share their inputs between the

260
00:10:16,740 --> 00:10:18,480
deterministic parties so that the

261
00:10:18,480 --> 00:10:20,040
deterministic parties will have all the

262
00:10:20,040 --> 00:10:21,839
information necessary to do to compute

263
00:10:21,839 --> 00:10:24,480
everything without using the sources

264
00:10:24,480 --> 00:10:27,300
which we want to keep isolated

265
00:10:27,300 --> 00:10:30,420
so uh the two sources show their inputs

266
00:10:30,420 --> 00:10:32,940
and then the the three deterministic

267
00:10:32,940 --> 00:10:34,920
parties here will replace the initial

268
00:10:34,920 --> 00:10:36,720
functionality by a new functionality F

269
00:10:36,720 --> 00:10:39,180
Prime that will first reconstruct the

270
00:10:39,180 --> 00:10:41,580
shared inputs of the sources and then

271
00:10:41,580 --> 00:10:43,320
apply the function f on the

272
00:10:43,320 --> 00:10:45,000
reconstructive input pressure joint

273
00:10:45,000 --> 00:10:46,920
inputs of the deterministic parties so

274
00:10:46,920 --> 00:10:49,560
what you would expect

275
00:10:49,560 --> 00:10:51,240
now

276
00:10:51,240 --> 00:10:53,279
our three parties need to be able to

277
00:10:53,279 --> 00:10:55,980
compute the function and they will do so

278
00:10:55,980 --> 00:10:58,500
using gmw so a very important thing to

279
00:10:58,500 --> 00:11:00,540
know is to to observe is that now that

280
00:11:00,540 --> 00:11:04,019
we've isolated the sources uh here there

281
00:11:04,019 --> 00:11:06,360
might be uh there might not be a

282
00:11:06,360 --> 00:11:07,860
highness majority anymore among those

283
00:11:07,860 --> 00:11:09,180
guys

284
00:11:09,180 --> 00:11:11,579
um but among those deterministic parties

285
00:11:11,579 --> 00:11:13,140
we know that there will always be at

286
00:11:13,140 --> 00:11:16,440
least one uncorrected party so we use a

287
00:11:16,440 --> 00:11:20,279
protocol like gnw that can tolerate up

288
00:11:20,279 --> 00:11:22,680
to n minus one Corruptions out of n

289
00:11:22,680 --> 00:11:25,920
so what's gmw it's a well-known secure

290
00:11:25,920 --> 00:11:28,200
computation protocol that allows you to

291
00:11:28,200 --> 00:11:30,240
securely compute any Boolean circuits

292
00:11:30,240 --> 00:11:33,779
and I'm uh skipping a few details but

293
00:11:33,779 --> 00:11:36,660
the core thing here is that

294
00:11:36,660 --> 00:11:38,459
um the parties maintained as environment

295
00:11:38,459 --> 00:11:40,860
the fact that they have shares of the um

296
00:11:40,860 --> 00:11:43,560
of the computation through the wires of

297
00:11:43,560 --> 00:11:45,540
the circuit Computing extra Gates

298
00:11:45,540 --> 00:11:47,579
uninvolved local computation and

299
00:11:47,579 --> 00:11:49,620
Computing end Gates can be done by

300
00:11:49,620 --> 00:11:51,480
consuming what's called a beaver triple

301
00:11:51,480 --> 00:11:53,640
so this is combining the standard gmw

302
00:11:53,640 --> 00:11:55,320
protocol with the well-known observation

303
00:11:55,320 --> 00:11:57,600
of beaver

304
00:11:57,600 --> 00:12:01,160
so none of this uses any Randomness

305
00:12:01,160 --> 00:12:04,380
except the part where we want to compute

306
00:12:04,380 --> 00:12:06,899
an and gate which is done by consuming a

307
00:12:06,899 --> 00:12:08,220
beaver triple

308
00:12:08,220 --> 00:12:12,420
so what we use is we use an inner

309
00:12:12,420 --> 00:12:14,279
protocol which will of course use the

310
00:12:14,279 --> 00:12:15,959
sources because that they are the one

311
00:12:15,959 --> 00:12:18,240
who can produce Randomness to compute

312
00:12:18,240 --> 00:12:21,060
those B vertebrals

313
00:12:21,060 --> 00:12:23,040
so whenever we want to complete the

314
00:12:23,040 --> 00:12:24,720
bigger triples we invoke this inner

315
00:12:24,720 --> 00:12:27,240
protocol where first The Source will

316
00:12:27,240 --> 00:12:29,279
send random tapes to the deterministic

317
00:12:29,279 --> 00:12:31,980
parties so as in my warm-up example the

318
00:12:31,980 --> 00:12:35,339
part is xor the tapes in order to uh to

319
00:12:35,339 --> 00:12:38,640
have their own random tape and then all

320
00:12:38,640 --> 00:12:41,459
parties together run a distributed bgw

321
00:12:41,459 --> 00:12:42,540
protocol

322
00:12:42,540 --> 00:12:45,779
uh where everyone uh for the randomized

323
00:12:45,779 --> 00:12:48,300
functionality that outputs random Beaver

324
00:12:48,300 --> 00:12:50,760
triples only to the three deterministic

325
00:12:50,760 --> 00:12:52,139
parties here

326
00:12:52,139 --> 00:12:54,480
so that's exactly like our warmer

327
00:12:54,480 --> 00:12:56,040
protocol the T Plus One Source protocol

328
00:12:56,040 --> 00:12:58,740
but the crucial thing is that no I'm

329
00:12:58,740 --> 00:13:02,220
only applying this protocol in a safe

330
00:13:02,220 --> 00:13:05,040
context because this functionality here

331
00:13:05,040 --> 00:13:07,980
is independent of the inputs so even in

332
00:13:07,980 --> 00:13:09,540
a world where the two sources will be

333
00:13:09,540 --> 00:13:11,519
corrupted nothing too bad can happen

334
00:13:11,519 --> 00:13:13,440
because nothing in this protocol will

335
00:13:13,440 --> 00:13:15,779
ever depend on the private inputs

336
00:13:15,779 --> 00:13:17,940
okay

337
00:13:17,940 --> 00:13:19,139
so

338
00:13:19,139 --> 00:13:22,920
the data music parties use gmw they do

339
00:13:22,920 --> 00:13:25,079
everything uh among themselves but

340
00:13:25,079 --> 00:13:27,720
whenever they need a beaver triple they

341
00:13:27,720 --> 00:13:30,180
go back to the sources they run a vgw

342
00:13:30,180 --> 00:13:32,279
protocol all together and at the end of

343
00:13:32,279 --> 00:13:34,260
this bgw protocol they get a bigger

344
00:13:34,260 --> 00:13:35,519
triple and they can use this before

345
00:13:35,519 --> 00:13:37,920
triple in gnw they do that until they

346
00:13:37,920 --> 00:13:39,420
get the output and then they send the

347
00:13:39,420 --> 00:13:42,560
output back to the sources

348
00:13:42,560 --> 00:13:45,660
why is this secure

349
00:13:45,660 --> 00:13:47,880
there are two observations there are two

350
00:13:47,880 --> 00:13:49,620
cases to study the first one is the case

351
00:13:49,620 --> 00:13:51,000
where at least one of the sources is

352
00:13:51,000 --> 00:13:53,339
honest and the second is the case or no

353
00:13:53,339 --> 00:13:55,260
sources are honest in which case we know

354
00:13:55,260 --> 00:13:57,240
that the adversary did corrupt all the

355
00:13:57,240 --> 00:14:00,560
sources but also only the sources

356
00:14:00,560 --> 00:14:02,160
so

357
00:14:02,160 --> 00:14:04,680
for the first case two observation if

358
00:14:04,680 --> 00:14:06,959
there is one on a source then in this

359
00:14:06,959 --> 00:14:09,779
third phase of the protocol here

360
00:14:09,779 --> 00:14:14,480
we know that the BDW protocol was Secure

361
00:14:14,480 --> 00:14:17,220
because the adversary cannot control all

362
00:14:17,220 --> 00:14:19,860
sources so the sharp tapes are tray

363
00:14:19,860 --> 00:14:21,480
random so we can invoke the security of

364
00:14:21,480 --> 00:14:25,079
bgw so the beaver triples we can think

365
00:14:25,079 --> 00:14:27,660
of the Beaver triple used in the gmw

366
00:14:27,660 --> 00:14:29,820
protocol as coming from a trusted source

367
00:14:29,820 --> 00:14:31,380
of beaver triples

368
00:14:31,380 --> 00:14:33,839
and also we know since there is a

369
00:14:33,839 --> 00:14:35,700
highness majority of parties because it

370
00:14:35,700 --> 00:14:38,100
is below n over two that there will be

371
00:14:38,100 --> 00:14:40,139
at least one honest party

372
00:14:40,139 --> 00:14:43,019
so we can invoke the security of gmw in

373
00:14:43,019 --> 00:14:46,680
the outer protocol and security follows

374
00:14:46,680 --> 00:14:49,560
in the other setting where the adversary

375
00:14:49,560 --> 00:14:51,720
will corrupt all sources then we know

376
00:14:51,720 --> 00:14:53,160
that the adversary records only

377
00:14:53,160 --> 00:14:55,500
resources and in this case we simply

378
00:14:55,500 --> 00:14:57,899
observe that no Source ever sees

379
00:14:57,899 --> 00:14:59,940
anything dangerous right in the input

380
00:14:59,940 --> 00:15:02,459
sharing phase they only the only the

381
00:15:02,459 --> 00:15:04,500
source communicate to the players in the

382
00:15:04,500 --> 00:15:05,880
outer protocols the sources are never

383
00:15:05,880 --> 00:15:07,860
involved in the tape sharing phase only

384
00:15:07,860 --> 00:15:10,079
sources communicate to the players and

385
00:15:10,079 --> 00:15:12,360
the bgw protocol as I said is input

386
00:15:12,360 --> 00:15:15,180
Independence so here nothing bad can

387
00:15:15,180 --> 00:15:17,519
happen the only thing they get is the

388
00:15:17,519 --> 00:15:20,300
output in the end

389
00:15:20,639 --> 00:15:23,399
that was for security

390
00:15:23,399 --> 00:15:25,860
um now in the five or four minutes that

391
00:15:25,860 --> 00:15:28,320
I have left maybe three minutes

392
00:15:28,320 --> 00:15:29,699
um I want to talk a bit about the second

393
00:15:29,699 --> 00:15:32,220
result so one private and party ends

394
00:15:32,220 --> 00:15:34,500
with six bits in one source so the

395
00:15:34,500 --> 00:15:36,000
motivation is that and is a basic

396
00:15:36,000 --> 00:15:38,519
building like a MPC and for the other

397
00:15:38,519 --> 00:15:39,839
basic building block which is actually

398
00:15:39,839 --> 00:15:43,699
already have tight lower bounds

399
00:15:43,980 --> 00:15:45,779
um the randomness complexity of one

400
00:15:45,779 --> 00:15:47,579
private and has been studied in previous

401
00:15:47,579 --> 00:15:49,019
works and we know that you can do it

402
00:15:49,019 --> 00:15:51,000
with eight bits and two sources so

403
00:15:51,000 --> 00:15:53,160
that's our setting uh parties have

404
00:15:53,160 --> 00:15:54,720
single bit each and they want to compute

405
00:15:54,720 --> 00:15:57,779
the end of all their bits

406
00:15:57,779 --> 00:16:00,540
so we have a budget of six random bits

407
00:16:00,540 --> 00:16:03,240
and the way we do it is we'll have P0

408
00:16:03,240 --> 00:16:04,980
those all around them going throughout

409
00:16:04,980 --> 00:16:06,540
the protocol the buttons will

410
00:16:06,540 --> 00:16:08,459
communicate in a line where our PC will

411
00:16:08,459 --> 00:16:10,500
communicate with P1 and P2 P1 will

412
00:16:10,500 --> 00:16:12,839
communicate with P2 and V3 and so on

413
00:16:12,839 --> 00:16:14,880
and we'll proceed as follow

414
00:16:14,880 --> 00:16:17,880
the protocol starts by having P0 share

415
00:16:17,880 --> 00:16:21,120
x0 and x0 times some mask which is a

416
00:16:21,120 --> 00:16:22,920
random mask that is that it produces so

417
00:16:22,920 --> 00:16:25,440
producing the mask and sharing x0 and x0

418
00:16:25,440 --> 00:16:27,420
times the mask that uses already three

419
00:16:27,420 --> 00:16:29,459
random bits

420
00:16:29,459 --> 00:16:31,800
and those two things here they will be

421
00:16:31,800 --> 00:16:34,320
our invariant throughout the protocol

422
00:16:34,320 --> 00:16:36,560
um meaning that the parties will always

423
00:16:36,560 --> 00:16:39,959
have shares of the products of all XIs

424
00:16:39,959 --> 00:16:42,660
so far and the product of all excise so

425
00:16:42,660 --> 00:16:45,360
far times a mask

426
00:16:45,360 --> 00:16:49,440
so now we just have P0 send uh the say

427
00:16:49,440 --> 00:16:51,480
the right hand side of the shares to P1

428
00:16:51,480 --> 00:16:52,860
on the left hand side of the shares to

429
00:16:52,860 --> 00:16:55,320
B2 so now P1 and P2 have the shares of

430
00:16:55,320 --> 00:16:57,360
this invariant and he also sends the

431
00:16:57,360 --> 00:16:59,600
mask to P1

432
00:16:59,600 --> 00:17:01,380
and

433
00:17:01,380 --> 00:17:04,980
um we have P1 mask his input X1 using

434
00:17:04,980 --> 00:17:06,359
the mask so that's why we call it the

435
00:17:06,359 --> 00:17:09,179
mask and send this to P2 and they the

436
00:17:09,179 --> 00:17:10,619
two parties do this this local

437
00:17:10,619 --> 00:17:12,000
computation so they use some kind of

438
00:17:12,000 --> 00:17:13,679
linear combination with this new mask

439
00:17:13,679 --> 00:17:16,319
this is what that masks X1 and the

440
00:17:16,319 --> 00:17:17,579
shares that they have

441
00:17:17,579 --> 00:17:19,679
and trust me on that if you write the

442
00:17:19,679 --> 00:17:21,660
calculation you can see that those two

443
00:17:21,660 --> 00:17:22,859
things here

444
00:17:22,859 --> 00:17:26,280
they form additive shares of x0 X1 and

445
00:17:26,280 --> 00:17:28,740
x0 X1 times the new mask

446
00:17:28,740 --> 00:17:31,140
so we successfully managed to maintain

447
00:17:31,140 --> 00:17:33,059
this invariants because now the party is

448
00:17:33,059 --> 00:17:35,520
P1 and B2 half shares of the product of

449
00:17:35,520 --> 00:17:37,320
the excise and the product of the excise

450
00:17:37,320 --> 00:17:40,200
times are mass where we only added the

451
00:17:40,200 --> 00:17:43,980
new X I like the X1 to this invariant

452
00:17:43,980 --> 00:17:46,559
however what goes wrong is that the

453
00:17:46,559 --> 00:17:47,820
first year is perfectly fine but the

454
00:17:47,820 --> 00:17:49,620
second one is biased because it was

455
00:17:49,620 --> 00:17:51,539
computed by doing a local product of

456
00:17:51,539 --> 00:17:54,059
values so the shares are not uniformly

457
00:17:54,059 --> 00:17:56,760
random they are biased towards zero so

458
00:17:56,760 --> 00:17:59,340
to randomize them we let P0 sample an

459
00:17:59,340 --> 00:18:01,500
additional randomizer bit which uses one

460
00:18:01,500 --> 00:18:03,780
more random coin from our budget and we

461
00:18:03,780 --> 00:18:07,440
let P1 and P2 use this random bits to

462
00:18:07,440 --> 00:18:09,960
randomize this share and if you do all

463
00:18:09,960 --> 00:18:12,660
of that you notice that the um that one

464
00:18:12,660 --> 00:18:14,640
of the shares this one here was never

465
00:18:14,640 --> 00:18:16,380
used I mean it's Randomness but you've

466
00:18:16,380 --> 00:18:18,360
never used anymore so we can reuse it

467
00:18:18,360 --> 00:18:21,320
recycle it to Define it as the next

468
00:18:21,320 --> 00:18:23,820
randomizer bit so as to mind in the

469
00:18:23,820 --> 00:18:24,840
invariant

470
00:18:24,840 --> 00:18:27,480
so that's how we propagate the share the

471
00:18:27,480 --> 00:18:29,820
the we propagate everything throughout

472
00:18:29,820 --> 00:18:32,160
the protocol until the end in the end

473
00:18:32,160 --> 00:18:34,020
what's left to do is just multiplying

474
00:18:34,020 --> 00:18:37,620
the last inputs of the last party to uh

475
00:18:37,620 --> 00:18:40,140
this product and uh if you look closely

476
00:18:40,140 --> 00:18:42,059
at what we want to do exactly what we

477
00:18:42,059 --> 00:18:43,620
want to do is exactly do in oblivious

478
00:18:43,620 --> 00:18:45,660
transfer actually and we know that

479
00:18:45,660 --> 00:18:47,460
obvious transfer can be done be with

480
00:18:47,460 --> 00:18:49,919
three random bits so we could do that

481
00:18:49,919 --> 00:18:52,440
and we actually also observed that the

482
00:18:52,440 --> 00:18:54,539
last randomizer bit is never used

483
00:18:54,539 --> 00:18:56,220
anymore so we can recycle it for the

484
00:18:56,220 --> 00:18:58,260
obvious transfer hence we do the full

485
00:18:58,260 --> 00:19:00,240
obuse run for only using two additional

486
00:19:00,240 --> 00:19:02,760
random bits and this way all buttons get

487
00:19:02,760 --> 00:19:03,840
the output

488
00:19:03,840 --> 00:19:06,240
yeah so that the end of my talk and I'll

489
00:19:06,240 --> 00:19:09,860
be happy to answer an equation

490
00:19:16,440 --> 00:19:18,919
questions

491
00:19:22,559 --> 00:19:26,059
so I have a couple of questions

492
00:19:26,100 --> 00:19:28,500
um yeah the last result that you showed

493
00:19:28,500 --> 00:19:30,720
is pretty interesting the uh paid off

494
00:19:30,720 --> 00:19:31,980
between

495
00:19:31,980 --> 00:19:34,440
uh the number of sources and the amount

496
00:19:34,440 --> 00:19:36,480
of Randomness that you need I'm curious

497
00:19:36,480 --> 00:19:38,820
if you could say anything more General

498
00:19:38,820 --> 00:19:41,220
um other than this specific case of one

499
00:19:41,220 --> 00:19:43,640
private Indian party

500
00:19:43,640 --> 00:19:47,160
so you uh oh so more General yeah so we

501
00:19:47,160 --> 00:19:48,840
actually do have a conjecture in the

502
00:19:48,840 --> 00:19:50,039
paper

503
00:19:50,039 --> 00:19:52,380
um I did not mention it in the talk

504
00:19:52,380 --> 00:19:55,080
because it's only this meaning it's a

505
00:19:55,080 --> 00:19:59,100
pure conjecture based on uh say

506
00:19:59,100 --> 00:20:01,559
and somewhat educated guess because we

507
00:20:01,559 --> 00:20:03,419
tried to do the best we can and we don't

508
00:20:03,419 --> 00:20:05,280
see an obvious reason why we should be

509
00:20:05,280 --> 00:20:07,140
able to do better so let me tell you

510
00:20:07,140 --> 00:20:08,760
what's a conjecture

511
00:20:08,760 --> 00:20:11,100
what I will conjecture but I'm not 100

512
00:20:11,100 --> 00:20:13,559
sure that my course or would conjecture

513
00:20:13,559 --> 00:20:15,480
exactly the same thing but what we will

514
00:20:15,480 --> 00:20:17,240
but what we're stating in the paper

515
00:20:17,240 --> 00:20:19,140
seems to work

516
00:20:19,140 --> 00:20:21,660
is that if you want to use a minimum

517
00:20:21,660 --> 00:20:24,720
number of sources which is T sources

518
00:20:24,720 --> 00:20:28,559
and then you need a factor T blow up in

519
00:20:28,559 --> 00:20:30,780
the randomness complexity meaning if you

520
00:20:30,780 --> 00:20:33,059
take any non-trivial functionality so

521
00:20:33,059 --> 00:20:35,100
sufficiently non-trail functionality so

522
00:20:35,100 --> 00:20:36,480
for example something that will involve

523
00:20:36,480 --> 00:20:38,220
multiplication Gates and the like so not

524
00:20:38,220 --> 00:20:39,720
just a simply simple linear

525
00:20:39,720 --> 00:20:40,860
functionality

526
00:20:40,860 --> 00:20:44,100
and you call R the best Randomness

527
00:20:44,100 --> 00:20:45,480
complexities that you could possibly

528
00:20:45,480 --> 00:20:47,280
achieve in a world where everyone can

529
00:20:47,280 --> 00:20:49,320
toss from them coins then if you only

530
00:20:49,320 --> 00:20:51,720
want the minimum number T of parties to

531
00:20:51,720 --> 00:20:54,419
those random cons you will need an

532
00:20:54,419 --> 00:20:56,220
amount of Randomness proportional to T

533
00:20:56,220 --> 00:20:58,799
times R to securely compute it and we

534
00:20:58,799 --> 00:21:00,299
know that t times R can be achieved

535
00:21:00,299 --> 00:21:03,299
because this is what our protocol

536
00:21:03,299 --> 00:21:06,780
achieves the the one for T sources for

537
00:21:06,780 --> 00:21:08,640
all deterministic functionalities and we

538
00:21:08,640 --> 00:21:12,919
conjecture that it's the best you can do

539
00:21:13,320 --> 00:21:15,000
and that's here that means that in the

540
00:21:15,000 --> 00:21:16,919
setting of one privacy we're expecting

541
00:21:16,919 --> 00:21:18,840
to be able to match actually the best

542
00:21:18,840 --> 00:21:20,760
possible uh Randomness lower bounds

543
00:21:20,760 --> 00:21:22,559
because the factor T is just a factor

544
00:21:22,559 --> 00:21:24,678
one

545
00:21:24,780 --> 00:21:26,460
interesting

546
00:21:26,460 --> 00:21:29,700
thanks that's pretty cool uh

547
00:21:29,700 --> 00:21:31,860
also I was wondering if you considered a

548
00:21:31,860 --> 00:21:34,140
model so in if I understand correctly in

549
00:21:34,140 --> 00:21:35,760
this model you sort of know ahead of

550
00:21:35,760 --> 00:21:38,720
time which parties are not going to be

551
00:21:38,720 --> 00:21:41,580
uh random sources and which ones are so

552
00:21:41,580 --> 00:21:44,280
yeah uh yeah I was wondering if you

553
00:21:44,280 --> 00:21:45,720
could say something about

554
00:21:45,720 --> 00:21:46,380
um

555
00:21:46,380 --> 00:21:48,780
a model in which you don't know who's

556
00:21:48,780 --> 00:21:51,539
going to have bad Randomness and yeah so

557
00:21:51,539 --> 00:21:53,039
if you have no idea it's a very natural

558
00:21:53,039 --> 00:21:54,900
question if you don't know in advance

559
00:21:54,900 --> 00:21:56,580
who could have background on this

560
00:21:56,580 --> 00:22:00,179
actually I don't think uh I'm pretty

561
00:22:00,179 --> 00:22:02,640
sure we can't say anything better than

562
00:22:02,640 --> 00:22:05,640
the easy results meaning

563
00:22:05,640 --> 00:22:06,299
um

564
00:22:06,299 --> 00:22:08,580
uh there is no way to do this strategy

565
00:22:08,580 --> 00:22:11,820
of isolating uh the the sources so

566
00:22:11,820 --> 00:22:13,679
isolating resources is also separating

567
00:22:13,679 --> 00:22:15,419
the people who could have bad Randomness

568
00:22:15,419 --> 00:22:17,580
and making them computer function on the

569
00:22:17,580 --> 00:22:19,860
side and if you can't do that and then

570
00:22:19,860 --> 00:22:21,179
there is nothing non-trivial can do

571
00:22:21,179 --> 00:22:22,679
meaning

572
00:22:22,679 --> 00:22:25,620
those upper bounds with t plus one they

573
00:22:25,620 --> 00:22:26,880
also hold if you don't know in advance

574
00:22:26,880 --> 00:22:29,460
who can toss random coins right so you

575
00:22:29,460 --> 00:22:32,159
will also uh have the ability to compute

576
00:22:32,159 --> 00:22:34,020
any functionality with t plus one random

577
00:22:34,020 --> 00:22:35,820
Source just by using this former

578
00:22:35,820 --> 00:22:38,880
protocol where everyone will share uh I

579
00:22:38,880 --> 00:22:41,700
mean all parties uh there you would ask

580
00:22:41,700 --> 00:22:43,860
all parties to share random tapes with

581
00:22:43,860 --> 00:22:45,960
everyone and then everyone will Define

582
00:22:45,960 --> 00:22:48,840
his own random tape to be the xor of all

583
00:22:48,840 --> 00:22:51,059
random tapes received by all buttons

584
00:22:51,059 --> 00:22:55,320
this way if at least t plus one

585
00:22:55,320 --> 00:22:56,299
um

586
00:22:56,299 --> 00:22:58,380
sources can produce high quality

587
00:22:58,380 --> 00:23:00,380
Randomness then you will have

588
00:23:00,380 --> 00:23:03,059
re-randomized properly or random types

589
00:23:03,059 --> 00:23:04,799
of everyone and that's the best you can

590
00:23:04,799 --> 00:23:06,900
do you cannot hope for better if you

591
00:23:06,900 --> 00:23:09,480
don't know who are the parties with uh

592
00:23:09,480 --> 00:23:12,659
the low quality randomness

593
00:23:12,659 --> 00:23:14,580
so yeah it's a setting where you can't

594
00:23:14,580 --> 00:23:16,980
say much the the setting that we

595
00:23:16,980 --> 00:23:18,659
consider is also well motivated by the

596
00:23:18,659 --> 00:23:20,039
fact that in the real world you might

597
00:23:20,039 --> 00:23:22,320
have a good idea of who's using a

598
00:23:22,320 --> 00:23:25,380
trusted device and who's you who's using

599
00:23:25,380 --> 00:23:28,159
I don't know his telephone

600
00:23:29,159 --> 00:23:32,539
much thanks for the talk

601
00:23:38,159 --> 00:23:41,280
Okay so the next talk will again be

602
00:23:41,280 --> 00:23:44,159
given by shaffra uh it's going to be on

603
00:23:44,159 --> 00:23:46,020
non-interactive secure computation of

604
00:23:46,020 --> 00:23:49,559
inner products from LPN and lwe this is

605
00:23:49,559 --> 00:23:52,460
Joint work between

606
00:23:54,299 --> 00:23:57,240
so hi again everyone uh I'm following

607
00:23:57,240 --> 00:24:00,600
directly with a second talk uh so as we

608
00:24:00,600 --> 00:24:02,280
said in the introduction it's a joint

609
00:24:02,280 --> 00:24:04,440
work with Mariam zareside and I'll be

610
00:24:04,440 --> 00:24:05,520
talking about an interactive secure

611
00:24:05,520 --> 00:24:07,679
computation of cleaner products from LPN

612
00:24:07,679 --> 00:24:08,940
and lwe

613
00:24:08,940 --> 00:24:11,659
foreign

614
00:24:14,100 --> 00:24:16,320
so let me start by recalling briefing on

615
00:24:16,320 --> 00:24:18,480
interactive key exchange non-interactive

616
00:24:18,480 --> 00:24:20,940
questions you all know what it is it's a

617
00:24:20,940 --> 00:24:22,620
protocol where end parties will

618
00:24:22,620 --> 00:24:24,659
simultaneously broadcast their public

619
00:24:24,659 --> 00:24:26,400
key I'm looking at me at like

620
00:24:26,400 --> 00:24:28,740
non-attractive exchange between Pairs of

621
00:24:28,740 --> 00:24:31,620
parties so um and so end parties will

622
00:24:31,620 --> 00:24:33,000
simultaneously broadcast a single

623
00:24:33,000 --> 00:24:33,960
message

624
00:24:33,960 --> 00:24:35,760
and then after broadcasting their single

625
00:24:35,760 --> 00:24:37,620
public key any pair of party without

626
00:24:37,620 --> 00:24:40,980
further interaction can locally compute

627
00:24:40,980 --> 00:24:43,080
from its states and the other party

628
00:24:43,080 --> 00:24:44,179
publicly

629
00:24:44,179 --> 00:24:47,280
their shared key right so you can do it

630
00:24:47,280 --> 00:24:49,320
here between P1 and P4 but you can also

631
00:24:49,320 --> 00:24:51,360
do it between any other pairs of parties

632
00:24:51,360 --> 00:24:53,340
and this is a very appealing interaction

633
00:24:53,340 --> 00:24:55,320
pattern you use really only one round of

634
00:24:55,320 --> 00:24:57,419
broadcast which is nice and also you

635
00:24:57,419 --> 00:24:59,760
avoid the N squared cost that you would

636
00:24:59,760 --> 00:25:01,799
have if you are using naive pairwise

637
00:25:01,799 --> 00:25:04,080
exchange so you're shaving a quadratic

638
00:25:04,080 --> 00:25:05,880
amount of communication compared to

639
00:25:05,880 --> 00:25:09,020
non-interactive Solutions

640
00:25:09,539 --> 00:25:12,299
so an actual question is to uh Wonder

641
00:25:12,299 --> 00:25:15,000
would it be possible to obtain a similar

642
00:25:15,000 --> 00:25:17,039
appealing interaction pattern for some

643
00:25:17,039 --> 00:25:19,440
simple NPC functionality that go beyond

644
00:25:19,440 --> 00:25:22,140
simply doing key exchange so here what I

645
00:25:22,140 --> 00:25:24,179
would want would would be to have n

646
00:25:24,179 --> 00:25:26,100
parties who broadcast an anchoring of

647
00:25:26,100 --> 00:25:28,679
their inputs and then any pair of

648
00:25:28,679 --> 00:25:31,440
parties uh could

649
00:25:31,440 --> 00:25:34,919
um uh securely locally compute without

650
00:25:34,919 --> 00:25:37,559
any further interaction their outputs

651
00:25:37,559 --> 00:25:40,980
from uh the their pairwise output right

652
00:25:40,980 --> 00:25:44,400
so for some pre-specified function fi of

653
00:25:44,400 --> 00:25:47,279
x i AJ and FJ of x i AJ

654
00:25:47,279 --> 00:25:50,220
and again if you could use that then you

655
00:25:50,220 --> 00:25:52,500
would have this uh nice feature of

656
00:25:52,500 --> 00:25:54,179
avoiding the end score overhead of

657
00:25:54,179 --> 00:25:56,400
having each pair of parties securely

658
00:25:56,400 --> 00:25:58,860
compute the function

659
00:25:58,860 --> 00:26:01,140
and in this work we show that it's

660
00:26:01,140 --> 00:26:02,760
possible to do non-interactive secure

661
00:26:02,760 --> 00:26:05,279
computation for shares of inner products

662
00:26:05,279 --> 00:26:09,659
between vectors held by by the parties

663
00:26:09,659 --> 00:26:12,240
um so where now the functions f i and FJ

664
00:26:12,240 --> 00:26:14,100
will form additive shares of the inner

665
00:26:14,100 --> 00:26:16,620
product between x i and XJ over any

666
00:26:16,620 --> 00:26:18,480
field F of your choice

667
00:26:18,480 --> 00:26:20,100
and so this is quite a meaning because

668
00:26:20,100 --> 00:26:21,779
even if you want to securely compute the

669
00:26:21,779 --> 00:26:23,400
inner product in the end then you don't

670
00:26:23,400 --> 00:26:25,260
have to send something whose lens depend

671
00:26:25,260 --> 00:26:28,140
on the vectors x i and AJ anymore you

672
00:26:28,140 --> 00:26:30,000
only have to send a single element of f

673
00:26:30,000 --> 00:26:32,640
to reconstruct the output so relates one

674
00:26:32,640 --> 00:26:34,380
round of broadcast you avoid the end

675
00:26:34,380 --> 00:26:36,299
score overhead on the big inputs and

676
00:26:36,299 --> 00:26:37,679
then if you want to reconstruct the

677
00:26:37,679 --> 00:26:39,179
output you just need to send a single

678
00:26:39,179 --> 00:26:41,600
field element

679
00:26:41,700 --> 00:26:43,559
so why not interactive in our products

680
00:26:43,559 --> 00:26:45,120
beyond the fact that we can do it well

681
00:26:45,120 --> 00:26:48,000
it has many natural applications it's a

682
00:26:48,000 --> 00:26:49,740
simple but super useful function I'm

683
00:26:49,740 --> 00:26:51,600
listing a few here diametric

684
00:26:51,600 --> 00:26:53,159
authentication pattern matching and many

685
00:26:53,159 --> 00:26:54,000
more

686
00:26:54,000 --> 00:26:56,419
uh just as a

687
00:26:56,419 --> 00:26:58,799
quick example let's look into what you

688
00:26:58,799 --> 00:27:00,840
could do for biometric authentication so

689
00:27:00,840 --> 00:27:02,159
it's known that inner product and

690
00:27:02,159 --> 00:27:03,600
harming distance that's basically the

691
00:27:03,600 --> 00:27:05,340
same thing right you can locally reduce

692
00:27:05,340 --> 00:27:08,460
uh Hamming distance to the computation

693
00:27:08,460 --> 00:27:09,960
of an inner product

694
00:27:09,960 --> 00:27:12,299
so that suffices for uh for computing

695
00:27:12,299 --> 00:27:14,340
having distance between strings so you

696
00:27:14,340 --> 00:27:15,900
could imagine that you have n clients

697
00:27:15,900 --> 00:27:17,400
and M servers each with their

698
00:27:17,400 --> 00:27:18,840
fingerprints told

699
00:27:18,840 --> 00:27:20,880
and ahead of time each party will

700
00:27:20,880 --> 00:27:22,799
publish an encoding of its fingerprint

701
00:27:22,799 --> 00:27:24,960
right so the parties will the clients

702
00:27:24,960 --> 00:27:26,340
will send their own fingerprint on the

703
00:27:26,340 --> 00:27:27,840
server will send the fingerprints that

704
00:27:27,840 --> 00:27:31,020
are stored and afterwards after this

705
00:27:31,020 --> 00:27:32,760
single round of publishing and encoding

706
00:27:32,760 --> 00:27:37,140
online uh any client and server pair can

707
00:27:37,140 --> 00:27:40,020
locally compute additive shares of the

708
00:27:40,020 --> 00:27:41,279
Hamming distance between the two

709
00:27:41,279 --> 00:27:43,080
fingerprints

710
00:27:43,080 --> 00:27:44,820
and afterwards to authenticate to a

711
00:27:44,820 --> 00:27:47,100
server the client only now has to send a

712
00:27:47,100 --> 00:27:49,440
single field element which is his share

713
00:27:49,440 --> 00:27:50,820
of the Hamming distance

714
00:27:50,820 --> 00:27:52,679
from which the server can check whether

715
00:27:52,679 --> 00:27:54,539
by reconstructing the Hamming distance

716
00:27:54,539 --> 00:27:56,460
the Hamming distance is below the

717
00:27:56,460 --> 00:27:59,039
threshold or not and uh allow for the

718
00:27:59,039 --> 00:28:01,620
Authentication

719
00:28:01,620 --> 00:28:05,340
so and that's quite appealing uh um

720
00:28:05,340 --> 00:28:07,140
instruction pattern in a setting where

721
00:28:07,140 --> 00:28:09,000
you will do and like biometric

722
00:28:09,000 --> 00:28:11,220
authentication between multiple clients

723
00:28:11,220 --> 00:28:13,799
and multiple servers with minimal

724
00:28:13,799 --> 00:28:15,120
interaction pattern and a low

725
00:28:15,120 --> 00:28:17,240
communication

726
00:28:17,240 --> 00:28:19,980
so how do uh how do we do that we'll use

727
00:28:19,980 --> 00:28:22,380
LPN and LW so I'm briefly recalling the

728
00:28:22,380 --> 00:28:26,039
assumptions in um semi-abstract way so

729
00:28:26,039 --> 00:28:27,720
what I call the Primal form of Alpine

730
00:28:27,720 --> 00:28:29,640
and LD Lu is the following you have some

731
00:28:29,640 --> 00:28:32,580
random Matrix and you have some noisy

732
00:28:32,580 --> 00:28:34,380
system of linear equations

733
00:28:34,380 --> 00:28:36,360
uh and the Assumption will be that this

734
00:28:36,360 --> 00:28:38,100
noisy system of linear equations is

735
00:28:38,100 --> 00:28:40,440
indistinguishable from random

736
00:28:40,440 --> 00:28:42,600
now if you set for example random Matrix

737
00:28:42,600 --> 00:28:45,000
to be random over F2 and you set the

738
00:28:45,000 --> 00:28:46,919
sharps required to build over F2 and the

739
00:28:46,919 --> 00:28:49,080
noise to be a sampled from a Bernoulli

740
00:28:49,080 --> 00:28:51,179
distribution meaning that it will have

741
00:28:51,179 --> 00:28:53,880
mostly zero entries and a few non-zero

742
00:28:53,880 --> 00:28:57,000
entries then uh you get the LPN

743
00:28:57,000 --> 00:28:58,260
assumption and you can actually Define

744
00:28:58,260 --> 00:29:00,600
natural variants of LP and over FP where

745
00:29:00,600 --> 00:29:02,400
everything's over FP and now the noise

746
00:29:02,400 --> 00:29:04,320
is uh from a burning distribution over

747
00:29:04,320 --> 00:29:06,539
FP so mostly zeros but a few random

748
00:29:06,539 --> 00:29:09,659
field elements uh here and there

749
00:29:09,659 --> 00:29:11,820
so that's what I'll call LPN where's the

750
00:29:11,820 --> 00:29:15,059
noisy sparse and you recover lwe by

751
00:29:15,059 --> 00:29:16,260
setting the noise to have small

752
00:29:16,260 --> 00:29:18,600
magnitude instead I'm here giving the

753
00:29:18,600 --> 00:29:21,179
example of picking the noise uniformly

754
00:29:21,179 --> 00:29:23,820
between some bounds but of course many

755
00:29:23,820 --> 00:29:28,220
other distributions are standard

756
00:29:28,320 --> 00:29:31,020
and I said Primal from because you can

757
00:29:31,020 --> 00:29:33,779
also consider a dual form for LPN and

758
00:29:33,779 --> 00:29:37,140
lwe encoding CRT terms you can view G as

759
00:29:37,140 --> 00:29:41,159
a generator Matrix of some linear code

760
00:29:41,159 --> 00:29:42,659
and you can multiply it on the left by

761
00:29:42,659 --> 00:29:44,399
its party check Matrix so it will cancel

762
00:29:44,399 --> 00:29:47,159
the The Matrix and then you'll be only

763
00:29:47,159 --> 00:29:49,500
left with some kind of random but now

764
00:29:49,500 --> 00:29:53,220
compressive Matrix H and your assumption

765
00:29:53,220 --> 00:29:55,200
is that if you multiply this compressive

766
00:29:55,200 --> 00:29:57,899
Matrix H by a noise which can be sparse

767
00:29:57,899 --> 00:30:00,419
for LPN or short for LW then you get

768
00:30:00,419 --> 00:30:02,039
something that looks random and actually

769
00:30:02,039 --> 00:30:04,140
I mean this is really for the sake of

770
00:30:04,140 --> 00:30:05,580
being abstract because in this in the

771
00:30:05,580 --> 00:30:07,080
case of Eligibility generally this will

772
00:30:07,080 --> 00:30:08,640
be an information theoreticalistic

773
00:30:08,640 --> 00:30:11,460
result by the leftover hash Lima but for

774
00:30:11,460 --> 00:30:13,919
LPN this will be an assumption which is

775
00:30:13,919 --> 00:30:16,740
equivalent to LPN

776
00:30:16,740 --> 00:30:19,279
foreign

777
00:30:24,440 --> 00:30:27,720
exchange I mean we want to do secure

778
00:30:27,720 --> 00:30:30,240
computation as easy as non-interactive

779
00:30:30,240 --> 00:30:31,740
key exchange so we start from a

780
00:30:31,740 --> 00:30:33,419
non-attractive exchange and we look at

781
00:30:33,419 --> 00:30:34,919
elevenovich which is a celebrated

782
00:30:34,919 --> 00:30:38,279
kitchen from LPN here uh Alice and Bob

783
00:30:38,279 --> 00:30:40,500
will both compute public Keys Bob will

784
00:30:40,500 --> 00:30:43,320
do that as some dual LPN sample and

785
00:30:43,320 --> 00:30:45,720
Alice will compute it as some Primal LP

786
00:30:45,720 --> 00:30:47,760
Ensemble the pro using the Primal form

787
00:30:47,760 --> 00:30:50,539
and the job form

788
00:30:51,059 --> 00:30:52,500
um

789
00:30:52,500 --> 00:30:55,440
okay so let me show you how correctness

790
00:30:55,440 --> 00:30:59,220
work we just uh compute the the keys K

791
00:30:59,220 --> 00:31:01,380
and K Prime by just doing the inner

792
00:31:01,380 --> 00:31:03,179
product between the public key and the

793
00:31:03,179 --> 00:31:05,940
the random uh the sparse random vectors

794
00:31:05,940 --> 00:31:09,120
located by the parties and to look at

795
00:31:09,120 --> 00:31:11,460
correctness we just open everything and

796
00:31:11,460 --> 00:31:13,860
so if you open everything uh what you

797
00:31:13,860 --> 00:31:16,140
get is just exactly the key of Alice

798
00:31:16,140 --> 00:31:16,860
here

799
00:31:16,860 --> 00:31:18,779
plus some inner product between two

800
00:31:18,779 --> 00:31:22,140
sparse vectors and because this is parse

801
00:31:22,140 --> 00:31:24,120
you can just view that as a noise term

802
00:31:24,120 --> 00:31:25,860
because this inner product will be zero

803
00:31:25,860 --> 00:31:28,740
high probability so roughly if those two

804
00:31:28,740 --> 00:31:31,080
things here are having weighted T and

805
00:31:31,080 --> 00:31:33,179
this thing is of size n and then the

806
00:31:33,179 --> 00:31:35,220
probability is that this noise term is

807
00:31:35,220 --> 00:31:37,679
one is roughly t squared over n which

808
00:31:37,679 --> 00:31:39,840
for sufficiently large n and the

809
00:31:39,840 --> 00:31:41,580
sufficiently small T is much more than

810
00:31:41,580 --> 00:31:43,260
one so that's a left navigation exchange

811
00:31:43,260 --> 00:31:44,520
of course if you want perfect

812
00:31:44,520 --> 00:31:46,020
correctness afterwards you need to do

813
00:31:46,020 --> 00:31:48,240
some reconciliation protocol uh to

814
00:31:48,240 --> 00:31:50,820
amplify uh the the correctness of your

815
00:31:50,820 --> 00:31:55,039
output key but that's a high level ID

816
00:31:56,640 --> 00:31:59,760
Associated for security we invoke the

817
00:31:59,760 --> 00:32:01,380
Dual LPN assumption which is equivalent

818
00:32:01,380 --> 00:32:03,840
to LPN on bobside and Primal Appian

819
00:32:03,840 --> 00:32:06,120
assumption on at this side proof is

820
00:32:06,120 --> 00:32:08,399
standard I'm skipping it

821
00:32:08,399 --> 00:32:10,140
so now our core question is the

822
00:32:10,140 --> 00:32:12,960
following we know that in order to

823
00:32:12,960 --> 00:32:15,240
compute their uh their keys the parties

824
00:32:15,240 --> 00:32:16,640
are already Computing and inner product

825
00:32:16,640 --> 00:32:20,340
so could we somehow use the fact that we

826
00:32:20,340 --> 00:32:22,620
have already this nice interpreter

827
00:32:22,620 --> 00:32:24,059
computation that's taking place in

828
00:32:24,059 --> 00:32:27,240
argument exchange to embed a more

829
00:32:27,240 --> 00:32:29,460
complex functionality inside our key

830
00:32:29,460 --> 00:32:32,100
exchange could we possibly embed the

831
00:32:32,100 --> 00:32:34,440
computation of an inner product inside

832
00:32:34,440 --> 00:32:36,600
Exchange

833
00:32:36,600 --> 00:32:39,480
so let's do a warm-up attempt but can

834
00:32:39,480 --> 00:32:41,279
have some Vector of input and can just

835
00:32:41,279 --> 00:32:45,240
add it to his public key uh right so now

836
00:32:45,240 --> 00:32:49,980
if we again open uh the computation uh

837
00:32:49,980 --> 00:32:51,960
yeah we open everything and we have the

838
00:32:51,960 --> 00:32:54,539
same thing as before except that now we

839
00:32:54,539 --> 00:32:57,779
have this s times x term here and I

840
00:32:57,779 --> 00:32:59,880
added a minus sign for Simplicity so now

841
00:32:59,880 --> 00:33:03,299
if you add Alison Bob's results the K

842
00:33:03,299 --> 00:33:05,340
terms can solve you have this noise term

843
00:33:05,340 --> 00:33:07,559
and you have this inner product here so

844
00:33:07,559 --> 00:33:10,380
now K and K Prime from noisy additive

845
00:33:10,380 --> 00:33:12,059
shares of the inner product between X

846
00:33:12,059 --> 00:33:13,080
and S

847
00:33:13,080 --> 00:33:15,299
so this is getting somewhere but this is

848
00:33:15,299 --> 00:33:17,340
still not an inner product because this

849
00:33:17,340 --> 00:33:19,799
s here is not uh something that can be

850
00:33:19,799 --> 00:33:22,320
Alice's input because it has to be true

851
00:33:22,320 --> 00:33:24,360
random if you want to ever invoke the

852
00:33:24,360 --> 00:33:25,919
security of L piano

853
00:33:25,919 --> 00:33:29,760
so you can't use S as the input of Alice

854
00:33:29,760 --> 00:33:32,519
so how do we embed Alice input inside

855
00:33:32,519 --> 00:33:36,899
this s well the second ID is uh just uh

856
00:33:36,899 --> 00:33:39,659
to split H vertically as the vertical

857
00:33:39,659 --> 00:33:41,820
concatenation of two matrices

858
00:33:41,820 --> 00:33:44,820
h0 and H1

859
00:33:44,820 --> 00:33:45,419
um

860
00:33:45,419 --> 00:33:46,980
here

861
00:33:46,980 --> 00:33:48,899
um the idea is the following if you

862
00:33:48,899 --> 00:33:50,640
write it this way then when you open the

863
00:33:50,640 --> 00:33:53,039
computation you can simply use the

864
00:33:53,039 --> 00:33:55,380
randomness inside s0

865
00:33:55,380 --> 00:33:59,039
to prove that everything here is secure

866
00:33:59,039 --> 00:34:00,720
is any signature performance because you

867
00:34:00,720 --> 00:34:04,380
will have a term h0 times s0 plus R1

868
00:34:04,380 --> 00:34:07,799
which is a primal form LPN sample so you

869
00:34:07,799 --> 00:34:10,320
can invoke LPN at the cost of losing a

870
00:34:10,320 --> 00:34:13,800
factor 2 in the rate of your code here

871
00:34:13,800 --> 00:34:16,440
and now this other part here is a part

872
00:34:16,440 --> 00:34:18,780
where you can put something and this

873
00:34:18,780 --> 00:34:20,159
something does not need to be random

874
00:34:20,159 --> 00:34:21,719
anymore so you can decide that it will

875
00:34:21,719 --> 00:34:24,799
be the input of Alice

876
00:34:24,960 --> 00:34:26,879
um and then when you open the entire

877
00:34:26,879 --> 00:34:28,918
computation here

878
00:34:28,918 --> 00:34:31,500
um you actually have this s0 temperature

879
00:34:31,500 --> 00:34:33,960
but by just by patting Bob's input with

880
00:34:33,960 --> 00:34:37,020
zeros on the top then you can cancel the

881
00:34:37,020 --> 00:34:39,719
part that invo that involves a zero

882
00:34:39,719 --> 00:34:42,839
and so now you just get uh some noisy

883
00:34:42,839 --> 00:34:45,418
additive shares of the inner product

884
00:34:45,418 --> 00:34:48,780
between uh X and Y so the inputs of

885
00:34:48,780 --> 00:34:51,119
Alice envo and so that's for the LPN

886
00:34:51,119 --> 00:34:52,980
based protocol it's a protocol that

887
00:34:52,980 --> 00:34:55,260
gives you non-interactive inner products

888
00:34:55,260 --> 00:34:57,900
with some uh inverse polynomial noise

889
00:34:57,900 --> 00:34:59,940
that you can make as small as you want

890
00:34:59,940 --> 00:35:02,280
by uh by increasing I mean for large

891
00:35:02,280 --> 00:35:05,000
enough vectors

892
00:35:06,720 --> 00:35:08,339
um what about efficiency well

893
00:35:08,339 --> 00:35:10,140
communication wise if you take if you

894
00:35:10,140 --> 00:35:12,119
pick standard parameters you'll have

895
00:35:12,119 --> 00:35:14,760
something like

896
00:35:14,760 --> 00:35:15,420
um

897
00:35:15,420 --> 00:35:17,760
two M bits from Bob and four M bits from

898
00:35:17,760 --> 00:35:20,760
Alice uh with a reasonable parameters so

899
00:35:20,760 --> 00:35:22,560
just exchanging the inputs in the clear

900
00:35:22,560 --> 00:35:24,480
will be two emits of communication here

901
00:35:24,480 --> 00:35:26,099
we're around six embeds of communication

902
00:35:26,099 --> 00:35:28,320
so just effect of three overhead over

903
00:35:28,320 --> 00:35:30,540
just extending inputs in the clear and

904
00:35:30,540 --> 00:35:33,240
asymptotically when the size M goes to

905
00:35:33,240 --> 00:35:34,680
Infinity

906
00:35:34,680 --> 00:35:36,720
um you can it actually suffice to send

907
00:35:36,720 --> 00:35:38,880
one plus Epsilon M bits from each party

908
00:35:38,880 --> 00:35:41,520
and you get nearly optimal communication

909
00:35:41,520 --> 00:35:44,040
overhead for for this inner product

910
00:35:44,040 --> 00:35:46,320
protocol so that's quite good and in

911
00:35:46,320 --> 00:35:47,820
computation the cost is of course

912
00:35:47,820 --> 00:35:49,200
dominated by the big matrix

913
00:35:49,200 --> 00:35:51,480
multiplication

914
00:35:51,480 --> 00:35:53,400
um if you take standard variants of LPN

915
00:35:53,400 --> 00:35:55,380
such as LPN using quasi-cyclic codes

916
00:35:55,380 --> 00:35:56,880
it's a standard variant that has been

917
00:35:56,880 --> 00:35:58,560
used in a bunch of nist emissions and

918
00:35:58,560 --> 00:36:00,480
many other works then you get

919
00:36:00,480 --> 00:36:03,780
quasi-linear computation m and using

920
00:36:03,780 --> 00:36:05,760
some slightly more exotic variance of

921
00:36:05,760 --> 00:36:10,020
LPN such as LPN for drug codes you can

922
00:36:10,020 --> 00:36:11,880
actually make it make it strictly linear

923
00:36:11,880 --> 00:36:13,800
in N so actually actually strictly in

924
00:36:13,800 --> 00:36:15,300
our computation which is also a nice

925
00:36:15,300 --> 00:36:17,339
feature that's not easy to have with

926
00:36:17,339 --> 00:36:20,160
other protocols and security is exactly

927
00:36:20,160 --> 00:36:22,800
as in Allah description

928
00:36:22,800 --> 00:36:25,140
so that's good but the protocol has t

929
00:36:25,140 --> 00:36:27,240
squared over n correctness error and now

930
00:36:27,240 --> 00:36:28,920
if we go back to our for example our

931
00:36:28,920 --> 00:36:31,200
example of biometric authentication if

932
00:36:31,200 --> 00:36:33,000
you want to use this protocol in an

933
00:36:33,000 --> 00:36:35,820
n-party setting this correctness error

934
00:36:35,820 --> 00:36:37,980
will actually translate to a security

935
00:36:37,980 --> 00:36:39,599
error

936
00:36:39,599 --> 00:36:42,300
um because each time an hour occurs then

937
00:36:42,300 --> 00:36:44,940
the server that sees the error will see

938
00:36:44,940 --> 00:36:47,099
we learn a linear equation of the form V

939
00:36:47,099 --> 00:36:50,339
times R where V is a non-vector and r is

940
00:36:50,339 --> 00:36:53,339
the noise Vector so the server wheel for

941
00:36:53,339 --> 00:36:55,140
each error accumulate one linear

942
00:36:55,140 --> 00:36:56,940
equation about the noise so if many

943
00:36:56,940 --> 00:36:59,099
server were to join their forces they

944
00:36:59,099 --> 00:37:01,320
could accumulate many linear equations

945
00:37:01,320 --> 00:37:03,060
about the noise

946
00:37:03,060 --> 00:37:05,040
as long as the number of servers is not

947
00:37:05,040 --> 00:37:08,280
too big uh so so you won't have too many

948
00:37:08,280 --> 00:37:11,400
errors overall then this is still a

949
00:37:11,400 --> 00:37:14,099
secure protocol uh but you but the

950
00:37:14,099 --> 00:37:15,960
security now only holds under some

951
00:37:15,960 --> 00:37:17,700
variant of LPN which is an LPN with

952
00:37:17,700 --> 00:37:19,440
leakage assumption and this one can be

953
00:37:19,440 --> 00:37:21,359
reduced to a standard LPN assumption

954
00:37:21,359 --> 00:37:23,960
that there is a loss

955
00:37:23,960 --> 00:37:26,760
alternatively if you might have a large

956
00:37:26,760 --> 00:37:28,260
number of errors or if you don't want a

957
00:37:28,260 --> 00:37:29,700
correctness error for example for

958
00:37:29,700 --> 00:37:31,740
barometric authentication maybe you

959
00:37:31,740 --> 00:37:33,300
don't want a failure with a one percent

960
00:37:33,300 --> 00:37:34,560
probability

961
00:37:34,560 --> 00:37:36,060
then

962
00:37:36,060 --> 00:37:36,960
um

963
00:37:36,960 --> 00:37:39,240
we give two Alternatives either an

964
00:37:39,240 --> 00:37:40,859
elderly based protocol that directly

965
00:37:40,859 --> 00:37:43,140
achieves negligible error probability at

966
00:37:43,140 --> 00:37:45,900
the cost of more communication or a way

967
00:37:45,900 --> 00:37:48,500
to remove errors via a sublinear

968
00:37:48,500 --> 00:37:51,720
preprocessing phase

969
00:37:51,720 --> 00:37:53,520
so I'm going to describe both

970
00:37:53,520 --> 00:37:55,859
Alternatives so

971
00:37:55,859 --> 00:37:58,140
um oh yeah let me just State also that

972
00:37:58,140 --> 00:38:01,260
so this pre-processing phase adds more

973
00:38:01,260 --> 00:38:02,460
interaction so it's not fully

974
00:38:02,460 --> 00:38:04,200
non-attractive anymore but it's

975
00:38:04,200 --> 00:38:05,760
independent of the inputs so this

976
00:38:05,760 --> 00:38:07,440
interaction only takes place ahead of

977
00:38:07,440 --> 00:38:10,140
time and the amount of communication and

978
00:38:10,140 --> 00:38:13,680
computation there is also logarithmic in

979
00:38:13,680 --> 00:38:15,240
the input side so it's a very small

980
00:38:15,240 --> 00:38:17,280
amount of communication and computation

981
00:38:17,280 --> 00:38:19,200
to the preprocessing and then everything

982
00:38:19,200 --> 00:38:21,599
is local work

983
00:38:21,599 --> 00:38:25,260
um in the online non-interactive phase

984
00:38:25,260 --> 00:38:28,820
so it's still quite interesting

985
00:38:30,060 --> 00:38:32,359
so we start again

986
00:38:32,359 --> 00:38:35,880
space in our products protocol and we

987
00:38:35,880 --> 00:38:38,400
convert it to be an awas protocol so we

988
00:38:38,400 --> 00:38:41,220
uh now have X over zp The Matrix is over

989
00:38:41,220 --> 00:38:45,119
some field zq summary zq and we scale

990
00:38:45,119 --> 00:38:47,700
the X and Y by a q over p

991
00:38:47,700 --> 00:38:50,280
and now when you open up everything you

992
00:38:50,280 --> 00:38:51,960
have the same thing as before except

993
00:38:51,960 --> 00:38:53,460
that

994
00:38:53,460 --> 00:38:57,180
um this uh thing here has been scaled by

995
00:38:57,180 --> 00:38:58,980
a qrp actually probably only one of the

996
00:38:58,980 --> 00:39:00,780
of them should have been scaled um

997
00:39:00,780 --> 00:39:03,480
whatever so now what you have is

998
00:39:03,480 --> 00:39:05,220
additive shares of some inner product

999
00:39:05,220 --> 00:39:08,040
scaled by some Factor plus some noise

1000
00:39:08,040 --> 00:39:10,260
term and now this noise term is small in

1001
00:39:10,260 --> 00:39:11,760
magnitude

1002
00:39:11,760 --> 00:39:13,800
um because it was computed the inner

1003
00:39:13,800 --> 00:39:15,240
product between two noise term which are

1004
00:39:15,240 --> 00:39:16,619
small and magnitude

1005
00:39:16,619 --> 00:39:18,839
and we can invoke at this stage a

1006
00:39:18,839 --> 00:39:21,359
well-known Lemma from uh which is called

1007
00:39:21,359 --> 00:39:23,940
the rounding Lemma which states that if

1008
00:39:23,940 --> 00:39:26,579
Q is definitely larger than p and the

1009
00:39:26,579 --> 00:39:29,160
noise magnitude then the parties can

1010
00:39:29,160 --> 00:39:32,760
just locally round their noisy shares of

1011
00:39:32,760 --> 00:39:35,040
the inner products and directly recover

1012
00:39:35,040 --> 00:39:37,260
additive features of the inner product

1013
00:39:37,260 --> 00:39:40,500
without any noise with overwhelming

1014
00:39:40,500 --> 00:39:42,180
probability and without using any

1015
00:39:42,180 --> 00:39:43,880
additional communication

1016
00:39:43,880 --> 00:39:46,560
so the bonus is that by doing so you

1017
00:39:46,560 --> 00:39:48,420
achieve directly negligible correctness

1018
00:39:48,420 --> 00:39:50,640
or any cage while staying fully

1019
00:39:50,640 --> 00:39:52,560
non-interactive one run on broadcast and

1020
00:39:52,560 --> 00:39:53,820
then you get those additive first of

1021
00:39:53,820 --> 00:39:56,940
inner products the the downside is that

1022
00:39:56,940 --> 00:39:58,380
you you get to use a larger

1023
00:39:58,380 --> 00:40:01,440
communication overhead because uh you

1024
00:40:01,440 --> 00:40:03,720
need Q to be sufficiently larger than p

1025
00:40:03,720 --> 00:40:06,119
and the noise bound

1026
00:40:06,119 --> 00:40:09,060
so that's for dlw based protocol

1027
00:40:09,060 --> 00:40:11,820
as for pre-processing the key ID is uh

1028
00:40:11,820 --> 00:40:15,000
so back to LPN the key idea is that we

1029
00:40:15,000 --> 00:40:16,380
want to

1030
00:40:16,380 --> 00:40:18,480
useful processing to pre-sample the

1031
00:40:18,480 --> 00:40:21,060
sparse vectors r0 on R1 together with

1032
00:40:21,060 --> 00:40:23,040
shares of these pause vectors

1033
00:40:23,040 --> 00:40:24,599
so that later when we do the online

1034
00:40:24,599 --> 00:40:26,760
phase if you look at the noise the noise

1035
00:40:26,760 --> 00:40:29,040
term is inner product between r0 and R1

1036
00:40:29,040 --> 00:40:31,260
so if the parties already have additive

1037
00:40:31,260 --> 00:40:33,839
shares of r0 and R1 by adding these

1038
00:40:33,839 --> 00:40:36,780
additive first to their output they can

1039
00:40:36,780 --> 00:40:38,880
just cancel this noise and obtain Noise

1040
00:40:38,880 --> 00:40:40,200
free output

1041
00:40:40,200 --> 00:40:42,300
so the only thing they need is prior to

1042
00:40:42,300 --> 00:40:45,119
executing the honest phase to obtain via

1043
00:40:45,119 --> 00:40:47,160
this processing functionality shares of

1044
00:40:47,160 --> 00:40:48,900
two sports vectors together together

1045
00:40:48,900 --> 00:40:51,060
with the corresponding spores vectors

1046
00:40:51,060 --> 00:40:53,400
and the cool thing about that is that if

1047
00:40:53,400 --> 00:40:55,440
you just open what a sparse Vector is

1048
00:40:55,440 --> 00:40:57,240
this can be done with very low

1049
00:40:57,240 --> 00:40:59,160
communication so if you just write a

1050
00:40:59,160 --> 00:41:00,900
sparse Vector as the sum of unit vector

1051
00:41:00,900 --> 00:41:02,820
and you open everything you get that

1052
00:41:02,820 --> 00:41:04,619
this inner product can be written as a

1053
00:41:04,619 --> 00:41:06,599
big sum of

1054
00:41:06,599 --> 00:41:09,000
um products between coordinates

1055
00:41:09,000 --> 00:41:10,920
multiplied by something which is zero or

1056
00:41:10,920 --> 00:41:12,960
one depending on whether the coordinates

1057
00:41:12,960 --> 00:41:14,760
are at the same position

1058
00:41:14,760 --> 00:41:17,220
and this can be securely computed using

1059
00:41:17,220 --> 00:41:18,960
some simple secret computation using a

1060
00:41:18,960 --> 00:41:20,760
bunch of equality tests to test equality

1061
00:41:20,760 --> 00:41:22,380
with the positions and obviously in our

1062
00:41:22,380 --> 00:41:24,839
evaluation for these products so overall

1063
00:41:24,839 --> 00:41:26,880
you can compute this functionality using

1064
00:41:26,880 --> 00:41:28,740
only T Square Times log n communication

1065
00:41:28,740 --> 00:41:30,720
when the size of the things are

1066
00:41:30,720 --> 00:41:32,880
proportional to n so you gain an

1067
00:41:32,880 --> 00:41:35,760
exponential Factor

1068
00:41:35,760 --> 00:41:38,820
um compared to doing things naively

1069
00:41:38,820 --> 00:41:40,920
and actually if you use a variant of LPN

1070
00:41:40,920 --> 00:41:42,660
which is also a standard variant of LPN

1071
00:41:42,660 --> 00:41:44,400
used in many previous work which is

1072
00:41:44,400 --> 00:41:46,140
helping with regular noise whereas the

1073
00:41:46,140 --> 00:41:48,240
noise is broken in blocks with a noisy

1074
00:41:48,240 --> 00:41:50,160
coordinate in each block then you can

1075
00:41:50,160 --> 00:41:52,140
further bring the cost down to T Times

1076
00:41:52,140 --> 00:41:53,700
log n so you can shave an additional

1077
00:41:53,700 --> 00:41:56,520
factorial factor of T and get to truly

1078
00:41:56,520 --> 00:41:59,160
truly low communication uh for this

1079
00:41:59,160 --> 00:42:01,879
processing

1080
00:42:01,920 --> 00:42:03,780
and the last thing I wanted to briefly

1081
00:42:03,780 --> 00:42:04,859
mention is that we also looked at

1082
00:42:04,859 --> 00:42:07,380
malicious security and if you uh break

1083
00:42:07,380 --> 00:42:09,420
things on the right way the thing we

1084
00:42:09,420 --> 00:42:11,040
would need for medical Security will be

1085
00:42:11,040 --> 00:42:12,839
to have the ability to prove that Alice

1086
00:42:12,839 --> 00:42:15,060
and Bob correctly generated their public

1087
00:42:15,060 --> 00:42:16,740
keys so we want a zero management

1088
00:42:16,740 --> 00:42:18,960
profile of knowledge of some sparse

1089
00:42:18,960 --> 00:42:21,900
vectors that satisfy some appropriate

1090
00:42:21,900 --> 00:42:23,820
linear equation

1091
00:42:23,820 --> 00:42:25,920
and we do introduce a new efficiency

1092
00:42:25,920 --> 00:42:27,900
organized proof of knowledge for such

1093
00:42:27,900 --> 00:42:30,540
LPN relation which has communication

1094
00:42:30,540 --> 00:42:33,359
which is exponentially smaller than the

1095
00:42:33,359 --> 00:42:36,119
dimension of the LPN instance because

1096
00:42:36,119 --> 00:42:38,040
it's only proportional to T Times log n

1097
00:42:38,040 --> 00:42:40,619
where T is the amount of noise and N is

1098
00:42:40,619 --> 00:42:43,619
the dimension of developing instance and

1099
00:42:43,619 --> 00:42:45,480
so whoops and the G80 here is that we

1100
00:42:45,480 --> 00:42:47,339
build on recent work on pseudonym

1101
00:42:47,339 --> 00:42:49,260
correlation generators which showed that

1102
00:42:49,260 --> 00:42:51,480
it's possible to generate with very low

1103
00:42:51,480 --> 00:42:52,740
communication

1104
00:42:52,740 --> 00:42:55,260
additive shares of

1105
00:42:55,260 --> 00:42:57,960
um of things of the form Delta times R

1106
00:42:57,960 --> 00:42:59,760
where Delta is an element of an

1107
00:42:59,760 --> 00:43:02,520
extension field and R is some random

1108
00:43:02,520 --> 00:43:05,520
sparse Vector so we use a protocol like

1109
00:43:05,520 --> 00:43:06,240
that

1110
00:43:06,240 --> 00:43:09,359
to share Delta times our protocol using

1111
00:43:09,359 --> 00:43:11,579
a functions equal sharing which can be

1112
00:43:11,579 --> 00:43:12,960
done very efficiently using a lens

1113
00:43:12,960 --> 00:43:14,579
doubling to the random generator so it

1114
00:43:14,579 --> 00:43:16,859
exists assuming any one-way function

1115
00:43:16,859 --> 00:43:19,319
and then we can use just standard secure

1116
00:43:19,319 --> 00:43:21,060
computation technique like speeds like

1117
00:43:21,060 --> 00:43:24,500
technique two um view this as a Mac

1118
00:43:24,500 --> 00:43:27,540
authentication of the noise Vector R so

1119
00:43:27,540 --> 00:43:29,339
now Delta is an information theoretic

1120
00:43:29,339 --> 00:43:31,800
Mac that authenticate noise vector and

1121
00:43:31,800 --> 00:43:33,480
we can use this Mac to check the

1122
00:43:33,480 --> 00:43:34,800
correctness of the computation of the

1123
00:43:34,800 --> 00:43:37,020
public keys and overall we only used

1124
00:43:37,020 --> 00:43:39,960
some logarithmic communication

1125
00:43:39,960 --> 00:43:42,540
and that's all for my talk I'll be happy

1126
00:43:42,540 --> 00:43:45,380
to answer any question

1127
00:43:50,339 --> 00:43:53,060
other questions

1128
00:43:55,579 --> 00:43:58,920
okay uh I have a quick question

1129
00:43:58,920 --> 00:44:01,680
um maybe this is The Superficial but uh

1130
00:44:01,680 --> 00:44:03,720
it seems like this non-attractive secure

1131
00:44:03,720 --> 00:44:05,220
computation Paradigm looks a bit like

1132
00:44:05,220 --> 00:44:08,640
this like uh public key PCF type thing

1133
00:44:08,640 --> 00:44:10,859
uh I'm curious if there's any connection

1134
00:44:10,859 --> 00:44:12,180
there or if there are other ways to

1135
00:44:12,180 --> 00:44:13,920
solve the same problem

1136
00:44:13,920 --> 00:44:17,760
yeah uh so public eptf for the audience

1137
00:44:17,760 --> 00:44:19,560
will be that everyone will broadcast

1138
00:44:19,560 --> 00:44:22,140
their public key and then

1139
00:44:22,140 --> 00:44:24,420
um parties can uh so for example two

1140
00:44:24,420 --> 00:44:25,740
parties will broadcast the Republic Key

1141
00:44:25,740 --> 00:44:27,060
and then the two parties can then

1142
00:44:27,060 --> 00:44:29,940
locally compute a long pseudo-random

1143
00:44:29,940 --> 00:44:31,800
quality Randomness

1144
00:44:31,800 --> 00:44:32,339
um

1145
00:44:32,339 --> 00:44:34,200
so the question can go in two directions

1146
00:44:34,200 --> 00:44:37,680
so first can you use pcfs public epcf to

1147
00:44:37,680 --> 00:44:39,359
do non-interactive

1148
00:44:39,359 --> 00:44:42,780
um a key exchange

1149
00:44:42,780 --> 00:44:45,000
um that's actually a good question and

1150
00:44:45,000 --> 00:44:46,079
I'm

1151
00:44:46,079 --> 00:44:48,300
uh not so sure because you would first

1152
00:44:48,300 --> 00:44:50,339
need to generate the correlated so you

1153
00:44:50,339 --> 00:44:52,200
would use the PCF to generate shares of

1154
00:44:52,200 --> 00:44:54,300
a random inner product in the first run

1155
00:44:54,300 --> 00:44:56,160
and then you will need the second run of

1156
00:44:56,160 --> 00:44:59,520
interaction uh to uh de-randomize these

1157
00:44:59,520 --> 00:45:02,160
random shares of inner products

1158
00:45:02,160 --> 00:45:04,800
um and to get IDT really your shares of

1159
00:45:04,800 --> 00:45:07,260
your inputs vectors so that naturally

1160
00:45:07,260 --> 00:45:09,359
that would be to runs maybe there is a

1161
00:45:09,359 --> 00:45:11,520
clever way to do it in one run I'm not

1162
00:45:11,520 --> 00:45:13,680
sure what's sure is that the best

1163
00:45:13,680 --> 00:45:15,720
non-construction of public PCF so far as

1164
00:45:15,720 --> 00:45:17,400
they are considerably less efficient

1165
00:45:17,400 --> 00:45:19,319
than what we can do here

1166
00:45:19,319 --> 00:45:22,200
uh the other way is whether we could see

1167
00:45:22,200 --> 00:45:24,960
this actually as some kind of

1168
00:45:24,960 --> 00:45:26,940
um cider random correlation generator or

1169
00:45:26,940 --> 00:45:30,540
a PCF and actually it doesn't it doesn't

1170
00:45:30,540 --> 00:45:34,200
seem so uh it's um uh I I tried a bit to

1171
00:45:34,200 --> 00:45:36,780
see whether I could view it as a way to

1172
00:45:36,780 --> 00:45:38,280
generate some inner product created

1173
00:45:38,280 --> 00:45:40,740
Randomness uh but that would not be a

1174
00:45:40,740 --> 00:45:41,819
good way to generate inner product

1175
00:45:41,819 --> 00:45:43,440
quality Randomness because it has

1176
00:45:43,440 --> 00:45:45,060
communication linear in the size of the

1177
00:45:45,060 --> 00:45:45,900
vectors

1178
00:45:45,900 --> 00:45:49,319
right so the magic of a PCF is that the

1179
00:45:49,319 --> 00:45:51,660
communication is almost independent of

1180
00:45:51,660 --> 00:45:53,339
the size of the correlation that you

1181
00:45:53,339 --> 00:45:55,500
will share between the parties if we're

1182
00:45:55,500 --> 00:45:57,300
using our protocol to generate inner

1183
00:45:57,300 --> 00:45:58,980
product creative Randomness the

1184
00:45:58,980 --> 00:46:00,839
communication will be linear in the size

1185
00:46:00,839 --> 00:46:05,119
of the vectors which will be much less

1186
00:46:05,119 --> 00:46:07,380
appealing than having communication say

1187
00:46:07,380 --> 00:46:08,940
logarithmic in the size of the vector

1188
00:46:08,940 --> 00:46:10,980
which is what you will get with PCF so

1189
00:46:10,980 --> 00:46:14,579
really what we gain here is uh not some

1190
00:46:14,579 --> 00:46:16,980
kind of PCF advantage of being souvenir

1191
00:46:16,980 --> 00:46:19,560
but it's really the fact that we

1192
00:46:19,560 --> 00:46:21,720
um Can directly without any further

1193
00:46:21,720 --> 00:46:24,000
interaction compute an inner product

1194
00:46:24,000 --> 00:46:26,220
between true inputs so not an inner

1195
00:46:26,220 --> 00:46:28,740
protected to run pseudonym inputs

1196
00:46:28,740 --> 00:46:31,140
so the two are not directly comparable I

1197
00:46:31,140 --> 00:46:31,980
would say

1198
00:46:31,980 --> 00:46:34,500
even though yeah we used fairly similar

1199
00:46:34,500 --> 00:46:36,900
ideas and techniques right using LPN

1200
00:46:36,900 --> 00:46:39,780
inside MPC uh using some kind of

1201
00:46:39,780 --> 00:46:42,660
function in the end to handle malicious

1202
00:46:42,660 --> 00:46:44,700
behavior it truly comes from the same

1203
00:46:44,700 --> 00:46:46,680
set of techniques and IDs but the

1204
00:46:46,680 --> 00:46:49,940
results are somewhat incomparable

1205
00:46:50,280 --> 00:46:52,740
thanks a lot for the answer and for the

1206
00:46:52,740 --> 00:46:56,419
talks stack this vehicle again

1207
00:47:00,420 --> 00:47:01,980
yeah

1208
00:47:01,980 --> 00:47:04,980
all right so now we have our next talk

1209
00:47:04,980 --> 00:47:06,960
which is efficient adaptively secure

1210
00:47:06,960 --> 00:47:08,220
basically and agreement for long

1211
00:47:08,220 --> 00:47:09,960
messages this is a joint work between

1212
00:47:09,960 --> 00:47:13,020
Army Bangla gender Liu Zhang Julian loss

1213
00:47:13,020 --> 00:47:14,700
and Karthik Nayak and Karthik will give

1214
00:47:14,700 --> 00:47:16,939
the talk

1215
00:47:19,319 --> 00:47:21,300
are you guys able to hear me

1216
00:47:21,300 --> 00:47:23,220
yes

1217
00:47:23,220 --> 00:47:26,280
all right thank you so much for the

1218
00:47:26,280 --> 00:47:27,660
introduction and I'm very happy to be

1219
00:47:27,660 --> 00:47:29,520
here so today I'll be talking about our

1220
00:47:29,520 --> 00:47:31,500
work on communication complexity of

1221
00:47:31,500 --> 00:47:33,060
Byzantine agreement under adaptive

1222
00:47:33,060 --> 00:47:35,339
adversaries this is John work with Amai

1223
00:47:35,339 --> 00:47:37,319
Chanda and Jillian

1224
00:47:37,319 --> 00:47:40,380
so this work actually follows a a rich

1225
00:47:40,380 --> 00:47:41,520
line of work

1226
00:47:41,520 --> 00:47:45,300
uh so I'll spend the first 30 of my time

1227
00:47:45,300 --> 00:47:47,160
trying to explain some of these prior

1228
00:47:47,160 --> 00:47:48,960
ideals because it's all actually very

1229
00:47:48,960 --> 00:47:51,060
helpful to to know these ideas because

1230
00:47:51,060 --> 00:47:54,119
they are used in our work as well

1231
00:47:54,119 --> 00:47:55,800
so the problem that we are talking about

1232
00:47:55,800 --> 00:47:57,780
is Byzantine or green vector and the

1233
00:47:57,780 --> 00:48:00,300
core idea is for in generals or in

1234
00:48:00,300 --> 00:48:03,240
parties to agree on some value agree on

1235
00:48:03,240 --> 00:48:05,160
a battle plan in this example

1236
00:48:05,160 --> 00:48:08,040
so at the end of it you want all of

1237
00:48:08,040 --> 00:48:09,359
these Byzantine generals who are

1238
00:48:09,359 --> 00:48:11,940
surrounding a castle to either attack or

1239
00:48:11,940 --> 00:48:13,380
territory

1240
00:48:13,380 --> 00:48:15,839
and you want to do this even if some of

1241
00:48:15,839 --> 00:48:17,940
these parties or some of these generals

1242
00:48:17,940 --> 00:48:20,460
can be malicious or what we call as

1243
00:48:20,460 --> 00:48:22,500
Byzantine over here so after two of them

1244
00:48:22,500 --> 00:48:24,540
can be Byzantine and yet you want the

1245
00:48:24,540 --> 00:48:26,700
rest of them to agree on on one of these

1246
00:48:26,700 --> 00:48:28,859
actions

1247
00:48:28,859 --> 00:48:30,420
so

1248
00:48:30,420 --> 00:48:33,000
said as different properties you need

1249
00:48:33,000 --> 00:48:35,280
three properties to hold the first one

1250
00:48:35,280 --> 00:48:36,900
is agreement which says that no to

1251
00:48:36,900 --> 00:48:39,300
honest General should disagree

1252
00:48:39,300 --> 00:48:41,640
second is validity which says that if

1253
00:48:41,640 --> 00:48:43,140
all generals start off in the same value

1254
00:48:43,140 --> 00:48:44,520
let's say all of them want to attack

1255
00:48:44,520 --> 00:48:46,800
then you actually output that value that

1256
00:48:46,800 --> 00:48:48,599
is you actually attack

1257
00:48:48,599 --> 00:48:50,460
and finally you want termination which

1258
00:48:50,460 --> 00:48:52,619
which means that you know all of these

1259
00:48:52,619 --> 00:48:54,420
parties eventually take one of these two

1260
00:48:54,420 --> 00:48:56,339
actions

1261
00:48:56,339 --> 00:48:58,260
so visiting agree ing agreement actually

1262
00:48:58,260 --> 00:49:00,660
finds applications in

1263
00:49:00,660 --> 00:49:03,359
modern day blockchains and with modern

1264
00:49:03,359 --> 00:49:05,099
day blockchains you have a large number

1265
00:49:05,099 --> 00:49:06,780
of parties trying to achieve consensus

1266
00:49:06,780 --> 00:49:08,099
among them

1267
00:49:08,099 --> 00:49:10,440
so one of the Key properties that you're

1268
00:49:10,440 --> 00:49:13,079
looking for is to reduce the amount of

1269
00:49:13,079 --> 00:49:14,700
communication or the number of messages

1270
00:49:14,700 --> 00:49:16,680
that are set by Honest parties of the

1271
00:49:16,680 --> 00:49:18,060
communication complexity of the entire

1272
00:49:18,060 --> 00:49:20,339
protocol

1273
00:49:20,339 --> 00:49:22,980
moreover the parties who speak typically

1274
00:49:22,980 --> 00:49:25,980
hold some position of power so if an

1275
00:49:25,980 --> 00:49:28,200
Adaptive adversity can actually corrupt

1276
00:49:28,200 --> 00:49:30,599
some of these parties then potentially

1277
00:49:30,599 --> 00:49:32,940
they can hurt the agreement validity or

1278
00:49:32,940 --> 00:49:34,740
termination properties of the overall

1279
00:49:34,740 --> 00:49:37,920
protocol so what you would want in such

1280
00:49:37,920 --> 00:49:40,079
protocols is for you to have security

1281
00:49:40,079 --> 00:49:42,720
under adaptive adversaries

1282
00:49:42,720 --> 00:49:44,280
there may be other properties that you

1283
00:49:44,280 --> 00:49:46,140
are also looking for for example better

1284
00:49:46,140 --> 00:49:48,300
latency Dynamic availability and so on

1285
00:49:48,300 --> 00:49:50,640
and so forth but in the for the context

1286
00:49:50,640 --> 00:49:52,980
of the stock and and with respect to

1287
00:49:52,980 --> 00:49:54,839
this work we are primarily concerned

1288
00:49:54,839 --> 00:49:55,859
with these two properties on

1289
00:49:55,859 --> 00:49:57,900
communication complex and complexity and

1290
00:49:57,900 --> 00:49:59,960
adaptive adversary

1291
00:49:59,960 --> 00:50:02,579
and very closely speaking the goal that

1292
00:50:02,579 --> 00:50:04,020
we want to achieve is the following the

1293
00:50:04,020 --> 00:50:05,400
question we are asking is the following

1294
00:50:05,400 --> 00:50:07,980
can we achieve a protocol a ba protocol

1295
00:50:07,980 --> 00:50:10,619
with low communication complexity

1296
00:50:10,619 --> 00:50:12,180
while still being secured under an

1297
00:50:12,180 --> 00:50:13,920
Adaptive adversary

1298
00:50:13,920 --> 00:50:16,140
okay so I'll qualify what I mean by low

1299
00:50:16,140 --> 00:50:17,640
communication complexity in the next few

1300
00:50:17,640 --> 00:50:20,060
slides

1301
00:50:21,599 --> 00:50:23,400
so

1302
00:50:23,400 --> 00:50:25,319
complexity is concerned you know even 40

1303
00:50:25,319 --> 00:50:26,819
years ago there was a very strong

1304
00:50:26,819 --> 00:50:28,500
statement made by Dollar van rishik who

1305
00:50:28,500 --> 00:50:30,060
said that you know any deterministic VA

1306
00:50:30,060 --> 00:50:32,400
protocol needs honest parties to send at

1307
00:50:32,400 --> 00:50:34,800
least t-squared messages over here Peak

1308
00:50:34,800 --> 00:50:37,200
is is the number of Byzantine parties

1309
00:50:37,200 --> 00:50:40,319
which typically is of the order of n so

1310
00:50:40,319 --> 00:50:42,420
you're sending You're Expecting

1311
00:50:42,420 --> 00:50:43,980
communication complexity to be order N

1312
00:50:43,980 --> 00:50:45,599
squared and they basically showed that

1313
00:50:45,599 --> 00:50:47,400
if fewer messages are said then there

1314
00:50:47,400 --> 00:50:48,720
exists some honest party who would

1315
00:50:48,720 --> 00:50:50,280
receive no messages and at that point

1316
00:50:50,280 --> 00:50:51,420
you know you would have a safety

1317
00:50:51,420 --> 00:50:53,400
violation

1318
00:50:53,400 --> 00:50:56,220
so does this mean we cannot do better

1319
00:50:56,220 --> 00:50:58,020
turns out we can and the keyword that

1320
00:50:58,020 --> 00:50:59,040
we're looking for over here is

1321
00:50:59,040 --> 00:51:00,599
deterministic

1322
00:51:00,599 --> 00:51:02,579
so the bound applies for deterministic

1323
00:51:02,579 --> 00:51:04,079
protocols if you use randomization

1324
00:51:04,079 --> 00:51:06,599
instead we can actually have a protocol

1325
00:51:06,599 --> 00:51:10,520
with sub quadratic number of messages

1326
00:51:11,220 --> 00:51:13,500
so how do we go about doing something

1327
00:51:13,500 --> 00:51:15,059
like this

1328
00:51:15,059 --> 00:51:18,059
atom the key idea behind you know

1329
00:51:18,059 --> 00:51:19,440
achieving a protocol with subordinating

1330
00:51:19,440 --> 00:51:21,599
messages is the following so you

1331
00:51:21,599 --> 00:51:23,400
basically elect

1332
00:51:23,400 --> 00:51:25,440
randomly a committee of some science

1333
00:51:25,440 --> 00:51:26,819
Kappa so let's say your original

1334
00:51:26,819 --> 00:51:29,160
population is size n this entire grade

1335
00:51:29,160 --> 00:51:30,839
of parties where each dot represents a

1336
00:51:30,839 --> 00:51:31,619
party

1337
00:51:31,619 --> 00:51:33,420
you elect a small Committee of size

1338
00:51:33,420 --> 00:51:34,800
Kappa

1339
00:51:34,800 --> 00:51:36,480
and

1340
00:51:36,480 --> 00:51:39,000
so so if you have a minority corruption

1341
00:51:39,000 --> 00:51:41,579
in the overall population even after you

1342
00:51:41,579 --> 00:51:44,099
elect you know except for some slack you

1343
00:51:44,099 --> 00:51:46,260
will still have a minority corruption in

1344
00:51:46,260 --> 00:51:47,760
in the overall committee so if I'm

1345
00:51:47,760 --> 00:51:48,900
glossing over some of the slack

1346
00:51:48,900 --> 00:51:51,059
parameters over here but the minority

1347
00:51:51,059 --> 00:51:53,220
would corruption would translate to the

1348
00:51:53,220 --> 00:51:55,939
committee as well

1349
00:51:56,579 --> 00:52:00,000
so at that point what you can do is just

1350
00:52:00,000 --> 00:52:02,160
require these parties in the committee

1351
00:52:02,160 --> 00:52:04,500
to send messages to everyone else and

1352
00:52:04,500 --> 00:52:05,880
they would actually run the agreement

1353
00:52:05,880 --> 00:52:07,260
protocol for you

1354
00:52:07,260 --> 00:52:09,480
and and eventually you'll have only

1355
00:52:09,480 --> 00:52:11,940
communication between the you'll only

1356
00:52:11,940 --> 00:52:13,559
have copper parties sending messages to

1357
00:52:13,559 --> 00:52:15,119
all and parties

1358
00:52:15,119 --> 00:52:16,500
and that overall communication

1359
00:52:16,500 --> 00:52:18,180
complexities that can then be bounded by

1360
00:52:18,180 --> 00:52:20,280
n polycarbon the reason why you have a

1361
00:52:20,280 --> 00:52:21,900
poly over here is because of the number

1362
00:52:21,900 --> 00:52:23,640
of routes of communication which may be

1363
00:52:23,640 --> 00:52:28,460
copper poly Kappa in such protocols

1364
00:52:29,339 --> 00:52:32,058
well

1365
00:52:32,940 --> 00:52:34,680
what what if you have an Adaptive

1366
00:52:34,680 --> 00:52:37,079
adversary no that Kappa which which

1367
00:52:37,079 --> 00:52:37,980
you're thinking of as a security

1368
00:52:37,980 --> 00:52:39,780
parameter is typically much smaller than

1369
00:52:39,780 --> 00:52:42,480
n or much smaller than T so an Adaptive

1370
00:52:42,480 --> 00:52:44,460
adversary actually has the capability of

1371
00:52:44,460 --> 00:52:47,400
you know corrupting the entire committee

1372
00:52:47,400 --> 00:52:49,559
how do we address this concern there was

1373
00:52:49,559 --> 00:52:51,180
this very very nice Solution by Chen and

1374
00:52:51,180 --> 00:52:54,480
nikali in their work on Al Quran where

1375
00:52:54,480 --> 00:52:56,579
database player this property are called

1376
00:52:56,579 --> 00:52:57,900
player replaceability where they said

1377
00:52:57,900 --> 00:53:00,480
instead of having one fixed static

1378
00:53:00,480 --> 00:53:02,339
committee let's keep changing this

1379
00:53:02,339 --> 00:53:04,859
committee after every round

1380
00:53:04,859 --> 00:53:07,380
so in a given round are among n parties

1381
00:53:07,380 --> 00:53:09,420
you can have a committee of science

1382
00:53:09,420 --> 00:53:12,300
Kappa these committee members would send

1383
00:53:12,300 --> 00:53:15,180
messages to everyone all the parties and

1384
00:53:15,180 --> 00:53:17,640
in the next round the role of these

1385
00:53:17,640 --> 00:53:19,920
parties would be played by a different

1386
00:53:19,920 --> 00:53:21,900
set of parties so the committee would be

1387
00:53:21,900 --> 00:53:24,359
replaced and it's clear replaceable to a

1388
00:53:24,359 --> 00:53:26,339
different set of parties so in R plus

1389
00:53:26,339 --> 00:53:27,900
one you will have a new committee who

1390
00:53:27,900 --> 00:53:29,460
would be sending messages

1391
00:53:29,460 --> 00:53:32,040
to everyone and and you keep electing

1392
00:53:32,040 --> 00:53:34,619
newer and newer committees each time

1393
00:53:34,619 --> 00:53:36,540
so if you're thinking of this from the

1394
00:53:36,540 --> 00:53:38,099
perspective of communication complexity

1395
00:53:38,099 --> 00:53:39,660
you still have Kappa parties sending

1396
00:53:39,660 --> 00:53:41,040
messages to all in people so you still

1397
00:53:41,040 --> 00:53:44,040
have empani Kappa communication

1398
00:53:44,040 --> 00:53:47,160
the advantage here though is that if the

1399
00:53:47,160 --> 00:53:49,260
adversary does not know who to corrupt

1400
00:53:49,260 --> 00:53:51,180
or who is going to speak at any given

1401
00:53:51,180 --> 00:53:53,339
round before the round starts or before

1402
00:53:53,339 --> 00:53:55,440
these parties speak

1403
00:53:55,440 --> 00:53:58,619
then then you can use this uh to your

1404
00:53:58,619 --> 00:54:00,960
advantage

1405
00:54:00,960 --> 00:54:03,660
so in particular if parties in round are

1406
00:54:03,660 --> 00:54:05,819
the committee members and rounder speak

1407
00:54:05,819 --> 00:54:07,140
and they would send all of these

1408
00:54:07,140 --> 00:54:08,400
messages

1409
00:54:08,400 --> 00:54:10,500
then if even if an adversary actually

1410
00:54:10,500 --> 00:54:12,240
corrupts these parties subsequently

1411
00:54:12,240 --> 00:54:14,520
these parties are no longer useful from

1412
00:54:14,520 --> 00:54:16,260
the adversary standpoint because in the

1413
00:54:16,260 --> 00:54:17,760
next round someone else is going to

1414
00:54:17,760 --> 00:54:19,319
speak and someone else is going to hold

1415
00:54:19,319 --> 00:54:21,300
this position of power and if the

1416
00:54:21,300 --> 00:54:23,220
Odyssey does not know who is going to be

1417
00:54:23,220 --> 00:54:26,220
going to speak in round R plus one then

1418
00:54:26,220 --> 00:54:28,500
then you have security under an active

1419
00:54:28,500 --> 00:54:29,579
adversary

1420
00:54:29,579 --> 00:54:31,380
so what you do need though is you know

1421
00:54:31,380 --> 00:54:33,059
for parties to know that they are they

1422
00:54:33,059 --> 00:54:34,980
can self-select themselves and they can

1423
00:54:34,980 --> 00:54:37,079
prove to the world that they are indeed

1424
00:54:37,079 --> 00:54:38,520
in the committee and it turns out that

1425
00:54:38,520 --> 00:54:39,780
you can actually achieve this using

1426
00:54:39,780 --> 00:54:43,099
verifiable random functions

1427
00:54:43,859 --> 00:54:46,380
well

1428
00:54:46,380 --> 00:54:48,720
now we do have an adaptively secure VA

1429
00:54:48,720 --> 00:54:50,819
protocol with order and polycarpa

1430
00:54:50,819 --> 00:54:54,359
messages right so are we done

1431
00:54:54,359 --> 00:54:56,280
Well turns out we are not I still have

1432
00:54:56,280 --> 00:55:00,480
about 10 minutes to speak in the stock

1433
00:55:00,480 --> 00:55:03,720
so what else can go wrong over here

1434
00:55:03,720 --> 00:55:06,420
well let's think about the size of

1435
00:55:06,420 --> 00:55:09,480
your input value to begin with so so if

1436
00:55:09,480 --> 00:55:11,880
we have an l-bit input you know so we

1437
00:55:11,880 --> 00:55:13,559
have n polycarpa number of messages but

1438
00:55:13,559 --> 00:55:15,300
if we have an L bit input the

1439
00:55:15,300 --> 00:55:17,040
communication complexity really would be

1440
00:55:17,040 --> 00:55:20,480
NL polycopper bits

1441
00:55:21,240 --> 00:55:24,839
what happens if this LS you know the

1442
00:55:24,839 --> 00:55:27,180
your input size is slot for example LS

1443
00:55:27,180 --> 00:55:29,640
Omega L squared or you know if you're

1444
00:55:29,640 --> 00:55:31,920
thinking of it in a blockchain sense you

1445
00:55:31,920 --> 00:55:34,559
know your L is is your block size and

1446
00:55:34,559 --> 00:55:36,540
and if it is a large block 10 megabyte

1447
00:55:36,540 --> 00:55:38,520
slice block then this multiplicative

1448
00:55:38,520 --> 00:55:41,040
overhead of n times polycarpa can

1449
00:55:41,040 --> 00:55:43,380
actually be very large

1450
00:55:43,380 --> 00:55:45,960
so this is actually addressed in a

1451
00:55:45,960 --> 00:55:47,880
different line of work

1452
00:55:47,880 --> 00:55:50,880
called ba extension protocols where

1453
00:55:50,880 --> 00:55:55,260
you're trying to split the agreement of

1454
00:55:55,260 --> 00:55:57,660
the block with the size of the message

1455
00:55:57,660 --> 00:55:59,940
itself

1456
00:55:59,940 --> 00:56:03,359
so you try to express Byzantine

1457
00:56:03,359 --> 00:56:05,339
agreement of a large message as a

1458
00:56:05,339 --> 00:56:06,960
function of visiting agreement for small

1459
00:56:06,960 --> 00:56:09,260
messages

1460
00:56:09,839 --> 00:56:11,400
so the key intention over here is to

1461
00:56:11,400 --> 00:56:13,619
break the problem in two steps

1462
00:56:13,619 --> 00:56:16,559
one you agree on a Kappa bit

1463
00:56:16,559 --> 00:56:18,480
accumulative value corresponding to one

1464
00:56:18,480 --> 00:56:20,099
of the inputs

1465
00:56:20,099 --> 00:56:22,619
and and this typically using a standard

1466
00:56:22,619 --> 00:56:24,119
Byzantine agreement protocol the state

1467
00:56:24,119 --> 00:56:25,980
of the art would require copile Square

1468
00:56:25,980 --> 00:56:28,440
communication

1469
00:56:28,440 --> 00:56:32,099
and second you would share the L bit

1470
00:56:32,099 --> 00:56:34,319
value separately using Erasure coding

1471
00:56:34,319 --> 00:56:35,339
techniques

1472
00:56:35,339 --> 00:56:36,900
we need to ensure that real bit value

1473
00:56:36,900 --> 00:56:38,400
that you're sharing you know corresponds

1474
00:56:38,400 --> 00:56:40,140
to the compartment accumulative value

1475
00:56:40,140 --> 00:56:41,460
that you're agreeing upon and these

1476
00:56:41,460 --> 00:56:43,680
details that I'm glossing over here but

1477
00:56:43,680 --> 00:56:45,540
the key idea is you want to share this

1478
00:56:45,540 --> 00:56:47,760
element value efficiently because L can

1479
00:56:47,760 --> 00:56:49,140
be large

1480
00:56:49,140 --> 00:56:51,660
how do you go about doing that so note

1481
00:56:51,660 --> 00:56:53,339
that Erasure coding techniques give you

1482
00:56:53,339 --> 00:56:56,040
allow you to split a message into

1483
00:56:56,040 --> 00:56:57,720
smaller chunks in such a way that even

1484
00:56:57,720 --> 00:56:59,220
if you receive some subset of these

1485
00:56:59,220 --> 00:57:00,599
chunks for example a majority of the

1486
00:57:00,599 --> 00:57:02,460
chunks or some parameter value that you

1487
00:57:02,460 --> 00:57:04,020
set so if you receive sufficient mini

1488
00:57:04,020 --> 00:57:06,420
chunks you can reconstruct this message

1489
00:57:06,420 --> 00:57:09,420
so a sender can just create sufficiently

1490
00:57:09,420 --> 00:57:11,700
mini chunks let's say n different uh

1491
00:57:11,700 --> 00:57:14,099
shares of these messages S1 to SF each

1492
00:57:14,099 --> 00:57:16,440
of size order L over n

1493
00:57:16,440 --> 00:57:19,559
and these parties in a separate step in

1494
00:57:19,559 --> 00:57:21,300
in The Next Step let's call it a reshare

1495
00:57:21,300 --> 00:57:23,579
step can share this message with

1496
00:57:23,579 --> 00:57:24,960
everyone else

1497
00:57:24,960 --> 00:57:26,880
okay so at the end of the reshare step

1498
00:57:26,880 --> 00:57:29,339
if you're thinking of a party so far as

1499
00:57:29,339 --> 00:57:31,079
it receives sufficiently many shares it

1500
00:57:31,079 --> 00:57:33,240
can reconstruct this value and I know

1501
00:57:33,240 --> 00:57:34,619
that you know even if some parties are

1502
00:57:34,619 --> 00:57:36,119
Byzantine and they do not show this

1503
00:57:36,119 --> 00:57:38,819
value it is okay because you do not need

1504
00:57:38,819 --> 00:57:42,140
all of the shares to reconstruct

1505
00:57:42,420 --> 00:57:44,579
so

1506
00:57:44,579 --> 00:57:46,079
how much communication do we need in

1507
00:57:46,079 --> 00:57:47,520
such a protocol so if you're thinking of

1508
00:57:47,520 --> 00:57:48,960
the distribute phase the first phase

1509
00:57:48,960 --> 00:57:52,319
over here each party is sharing with n

1510
00:57:52,319 --> 00:57:53,880
different parties a message of size L

1511
00:57:53,880 --> 00:57:56,040
Over N so the communication is Alter L

1512
00:57:56,040 --> 00:57:58,140
but n different parties can actually be

1513
00:57:58,140 --> 00:57:59,760
running the distribute phase in in

1514
00:57:59,760 --> 00:58:01,440
parallel so your communication is

1515
00:58:01,440 --> 00:58:03,059
elements

1516
00:58:03,059 --> 00:58:05,160
in the research phase you are engaging

1517
00:58:05,160 --> 00:58:07,619
in an all-to-all communication

1518
00:58:07,619 --> 00:58:09,720
and the message that you're sharing is

1519
00:58:09,720 --> 00:58:11,460
of size L Over N so the total

1520
00:58:11,460 --> 00:58:12,720
communication that you're incurring is

1521
00:58:12,720 --> 00:58:15,200
Ln

1522
00:58:16,559 --> 00:58:19,079
and you're also incurring a Kappa and

1523
00:58:19,079 --> 00:58:21,480
squared communication for agreeing on on

1524
00:58:21,480 --> 00:58:23,220
the accumulator value so the total

1525
00:58:23,220 --> 00:58:24,900
communication that you have is Ln plus

1526
00:58:24,900 --> 00:58:26,640
carpine Square bits

1527
00:58:26,640 --> 00:58:28,800
so note that the first term over here is

1528
00:58:28,800 --> 00:58:31,200
optimal because if you're sharing a

1529
00:58:31,200 --> 00:58:32,400
little bit message with 10 different

1530
00:58:32,400 --> 00:58:33,839
parties you have to incur a

1531
00:58:33,839 --> 00:58:36,299
communication of at least teller so what

1532
00:58:36,299 --> 00:58:37,799
you're trying to improve upon is the

1533
00:58:37,799 --> 00:58:40,640
second term over here

1534
00:58:40,799 --> 00:58:43,079
so what have we learned so here's here's

1535
00:58:43,079 --> 00:58:44,940
what the state of the art looks like

1536
00:58:44,940 --> 00:58:46,079
so

1537
00:58:46,079 --> 00:58:47,880
on the one hand you have sub quadratic

1538
00:58:47,880 --> 00:58:49,500
communication complexity protocols and

1539
00:58:49,500 --> 00:58:52,140
adaptive adversaries which require uh

1540
00:58:52,140 --> 00:58:55,380
sending Ln couples Kappa bets

1541
00:58:55,380 --> 00:58:58,200
so this is not optimal when L is very

1542
00:58:58,200 --> 00:58:59,880
large

1543
00:58:59,880 --> 00:59:01,619
on the other hand we have big extension

1544
00:59:01,619 --> 00:59:03,599
protocols specifically designed for long

1545
00:59:03,599 --> 00:59:06,299
messages right so the communication

1546
00:59:06,299 --> 00:59:08,040
complexity is Ln plus Kappa N squared

1547
00:59:08,040 --> 00:59:10,380
bits and when L is very large actually

1548
00:59:10,380 --> 00:59:12,960
the the copper and squared actually gets

1549
00:59:12,960 --> 00:59:14,940
folded into Ln

1550
00:59:14,940 --> 00:59:19,380
but when LS large but not that large

1551
00:59:19,380 --> 00:59:22,579
this is not optimal

1552
00:59:24,059 --> 00:59:26,160
so the natural question is well can we

1553
00:59:26,160 --> 00:59:28,859
get the best of both words that is

1554
00:59:28,859 --> 00:59:31,559
can we have a VA protocol with the

1555
00:59:31,559 --> 00:59:33,240
communication complexity of Ln poly

1556
00:59:33,240 --> 00:59:35,400
Kappa and bits

1557
00:59:35,400 --> 00:59:37,200
while still being secure under an

1558
00:59:37,200 --> 00:59:39,540
Adaptive adversary

1559
00:59:39,540 --> 00:59:41,700
so electromis is optimal over here and

1560
00:59:41,700 --> 00:59:43,020
the second term over here is the best

1561
00:59:43,020 --> 00:59:44,220
you can get

1562
00:59:44,220 --> 00:59:45,900
uh

1563
00:59:45,900 --> 00:59:49,099
uh as of now

1564
00:59:49,260 --> 00:59:50,940
so in the next sequence of slides I'll

1565
00:59:50,940 --> 00:59:54,119
present a high level idea of how we uh

1566
00:59:54,119 --> 00:59:55,740
actually achieve this

1567
00:59:55,740 --> 00:59:57,839
and I think what we learned until now

1568
00:59:57,839 --> 01:00:00,359
would be very useful uh in in

1569
01:00:00,359 --> 01:00:02,640
understanding what we are trying to do

1570
01:00:02,640 --> 01:00:05,220
so we'll start off with uh using the ba

1571
01:00:05,220 --> 01:00:06,900
extension protocol line of work that's

1572
01:00:06,900 --> 01:00:09,660
the Baseline way of thinking

1573
01:00:09,660 --> 01:00:11,040
so we'll still break down the problem

1574
01:00:11,040 --> 01:00:13,200
into two steps the first part agreeing

1575
01:00:13,200 --> 01:00:15,000
on Kappa bit accumulator value now

1576
01:00:15,000 --> 01:00:17,220
instead of using you know protocol with

1577
01:00:17,220 --> 01:00:19,140
copy and Squad communication we can use

1578
01:00:19,140 --> 01:00:21,359
a shin McCully like protocol which would

1579
01:00:21,359 --> 01:00:23,160
require you know order polycarp Island

1580
01:00:23,160 --> 01:00:25,980
communication so that's easy

1581
01:00:25,980 --> 01:00:28,200
the concern is how will you share the

1582
01:00:28,200 --> 01:00:31,020
self-bit value a little bit input with

1583
01:00:31,020 --> 01:00:33,900
all parties using Erasure coding

1584
01:00:33,900 --> 01:00:36,180
observe that with the approach earlier

1585
01:00:36,180 --> 01:00:38,460
if you concentrate on let's say we

1586
01:00:38,460 --> 01:00:41,280
concentrate on the ratio step so reach a

1587
01:00:41,280 --> 01:00:42,599
step requires an all to all

1588
01:00:42,599 --> 01:00:45,540
communication and even if each of these

1589
01:00:45,540 --> 01:00:48,480
parties send at least one bit value then

1590
01:00:48,480 --> 01:00:50,640
the total communication incurred is

1591
01:00:50,640 --> 01:00:53,160
Omega N squared and that's too high for

1592
01:00:53,160 --> 01:00:55,079
us we want everything to be sub

1593
01:00:55,079 --> 01:00:56,700
quadratic

1594
01:00:56,700 --> 01:00:58,920
so in general if there are in different

1595
01:00:58,920 --> 01:01:00,299
shares this is always going to happen

1596
01:01:00,299 --> 01:01:03,059
right so

1597
01:01:03,059 --> 01:01:05,040
a key learning over here is you know the

1598
01:01:05,040 --> 01:01:07,680
number of shares should be smaller than

1599
01:01:07,680 --> 01:01:11,339
n so maybe the number of shares the we

1600
01:01:11,339 --> 01:01:12,720
split the message into some copper

1601
01:01:12,720 --> 01:01:14,880
number of shares and then ensure that

1602
01:01:14,880 --> 01:01:16,859
this is in the reshare phase it is

1603
01:01:16,859 --> 01:01:18,900
reshared with sufficiently many parties

1604
01:01:18,900 --> 01:01:21,480
in particular there's at least some

1605
01:01:21,480 --> 01:01:23,339
honest party who would be re-sharing it

1606
01:01:23,339 --> 01:01:25,700
for us

1607
01:01:27,359 --> 01:01:29,640
one approach to actually achieving this

1608
01:01:29,640 --> 01:01:33,180
is to use a copper sized committee for

1609
01:01:33,180 --> 01:01:35,819
resharing its share okay the intuition

1610
01:01:35,819 --> 01:01:37,740
behind a cup assessed committee is the

1611
01:01:37,740 --> 01:01:39,180
following you know you want some honest

1612
01:01:39,180 --> 01:01:41,640
party to reshare a share and if you

1613
01:01:41,640 --> 01:01:43,440
elect a compasses committee hopefully

1614
01:01:43,440 --> 01:01:44,940
one of these parties is going to be

1615
01:01:44,940 --> 01:01:47,640
honest and uh the reshare will be

1616
01:01:47,640 --> 01:01:49,680
successful

1617
01:01:49,680 --> 01:01:52,079
but while this is one of the approaches

1618
01:01:52,079 --> 01:01:54,299
that we thought of it turns out that it

1619
01:01:54,299 --> 01:01:56,940
actually does not do the job for us

1620
01:01:56,940 --> 01:01:58,680
in particular it actually just does not

1621
01:01:58,680 --> 01:02:00,420
achieve the communication complexity

1622
01:02:00,420 --> 01:02:04,619
goal that we that we sought after

1623
01:02:04,619 --> 01:02:06,839
right so if you're thinking of you know

1624
01:02:06,839 --> 01:02:09,119
Kappa parties sending to end messages

1625
01:02:09,119 --> 01:02:11,520
messages of size hello or Kappa that in

1626
01:02:11,520 --> 01:02:13,559
itself for each share encourse NL

1627
01:02:13,559 --> 01:02:15,180
communication and if you extend it to

1628
01:02:15,180 --> 01:02:16,740
Kappa shares your communication

1629
01:02:16,740 --> 01:02:18,540
complexity has blown up by a factor of

1630
01:02:18,540 --> 01:02:22,140
copper then what we are looking for

1631
01:02:22,140 --> 01:02:23,579
moreover

1632
01:02:23,579 --> 01:02:25,859
it's unclear as to you know how these

1633
01:02:25,859 --> 01:02:27,839
committees are formed and how do we

1634
01:02:27,839 --> 01:02:29,819
distribute these shares with the copper

1635
01:02:29,819 --> 01:02:31,319
different committees because in the

1636
01:02:31,319 --> 01:02:32,579
sharing phase we do not know who these

1637
01:02:32,579 --> 01:02:34,440
committee members are otherwise an

1638
01:02:34,440 --> 01:02:36,059
Adaptive adversary will just corrupt all

1639
01:02:36,059 --> 01:02:38,960
of these committee members

1640
01:02:39,540 --> 01:02:41,940
it turns out that we can address both of

1641
01:02:41,940 --> 01:02:44,700
these questions or challenges in a

1642
01:02:44,700 --> 01:02:46,980
rather clean fashion and then here's

1643
01:02:46,980 --> 01:02:50,900
exactly what we do in our approach

1644
01:02:51,480 --> 01:02:53,940
Republic is split all of the parties

1645
01:02:53,940 --> 01:02:56,280
into copper different buckets

1646
01:02:56,280 --> 01:02:58,740
each of size n over Kappa

1647
01:02:58,740 --> 01:03:00,960
so in this grid over here the grid

1648
01:03:00,960 --> 01:03:02,579
represents all of the N parties each of

1649
01:03:02,579 --> 01:03:04,319
these rows represent Kappa different

1650
01:03:04,319 --> 01:03:07,079
buckets B1 to B Kappa and each bucket

1651
01:03:07,079 --> 01:03:10,400
has size n over carbon

1652
01:03:11,579 --> 01:03:14,040
in the distributed phase we require

1653
01:03:14,040 --> 01:03:16,680
share I to be shared with parties in

1654
01:03:16,680 --> 01:03:18,960
bucket type okay so we're splitting the

1655
01:03:18,960 --> 01:03:21,119
message into Kappa different shares S1

1656
01:03:21,119 --> 01:03:23,640
to S Kappa and

1657
01:03:23,640 --> 01:03:27,119
each share share i s i is being shared

1658
01:03:27,119 --> 01:03:30,920
with all parties in bucket VR

1659
01:03:31,160 --> 01:03:34,319
in the reshare phase we elect a single

1660
01:03:34,319 --> 01:03:36,660
node that we left just one Committee of

1661
01:03:36,660 --> 01:03:38,940
size order copper

1662
01:03:38,940 --> 01:03:41,460
and these committee members would

1663
01:03:41,460 --> 01:03:43,260
re-share the shares that they have

1664
01:03:43,260 --> 01:03:45,059
received with everyone else

1665
01:03:45,059 --> 01:03:48,780
so in particular if I am a party in in

1666
01:03:48,780 --> 01:03:51,420
bucket I and I am also in this order

1667
01:03:51,420 --> 01:03:53,640
copper sized committee then I would

1668
01:03:53,640 --> 01:03:56,099
engage in the research step for share

1669
01:03:56,099 --> 01:03:57,000
aside

1670
01:03:57,000 --> 01:03:59,040
okay so in this in the graphic over here

1671
01:03:59,040 --> 01:04:01,859
we're representing all of the committee

1672
01:04:01,859 --> 01:04:04,140
members in squares honest parties in in

1673
01:04:04,140 --> 01:04:06,660
black squares and Byzantine parties and

1674
01:04:06,660 --> 01:04:09,000
daughter trade squads

1675
01:04:09,000 --> 01:04:11,339
so first let us convince ourselves that

1676
01:04:11,339 --> 01:04:14,700
you know the solution actually gives us

1677
01:04:14,700 --> 01:04:18,078
better communication complexity

1678
01:04:18,119 --> 01:04:19,740
so if you're looking at the distribute

1679
01:04:19,740 --> 01:04:23,040
phase uh in in particular then

1680
01:04:23,040 --> 01:04:25,079
you have a set of parties who are

1681
01:04:25,079 --> 01:04:27,059
Distributing and and this can be bounded

1682
01:04:27,059 --> 01:04:29,160
to order Kappa

1683
01:04:29,160 --> 01:04:31,680
so you have other copper parties sharing

1684
01:04:31,680 --> 01:04:34,079
all over Kappa side shares to n over

1685
01:04:34,079 --> 01:04:36,480
Kappa parties for a given share

1686
01:04:36,480 --> 01:04:39,480
and and that by itself will incur uh Ln

1687
01:04:39,480 --> 01:04:41,760
over Kappa bits per share

1688
01:04:41,760 --> 01:04:43,619
and if we do this for copper different

1689
01:04:43,619 --> 01:04:45,240
shares it will incur a communication

1690
01:04:45,240 --> 01:04:47,700
complexity of order elements so we're

1691
01:04:47,700 --> 01:04:49,500
good there

1692
01:04:49,500 --> 01:04:52,500
in the reshare phase you have just a

1693
01:04:52,500 --> 01:04:54,240
single Committee of size order copper

1694
01:04:54,240 --> 01:04:55,920
and they are sharing an a lower

1695
01:04:55,920 --> 01:04:59,520
capacized message to all n parties

1696
01:04:59,520 --> 01:05:01,859
so that would incur a communication

1697
01:05:01,859 --> 01:05:04,260
complexity of Alan bits so that's good

1698
01:05:04,260 --> 01:05:06,440
too

1699
01:05:09,540 --> 01:05:11,880
but if you're thinking through this you

1700
01:05:11,880 --> 01:05:13,559
know

1701
01:05:13,559 --> 01:05:16,200
then you you may think of hey are there

1702
01:05:16,200 --> 01:05:18,059
potential concerns over here in

1703
01:05:18,059 --> 01:05:19,980
particular we are electing one Committee

1704
01:05:19,980 --> 01:05:23,040
of science order Kappa which means

1705
01:05:23,040 --> 01:05:26,579
each bucket I has in expectation of the

1706
01:05:26,579 --> 01:05:28,559
order one parties who can reshare and

1707
01:05:28,559 --> 01:05:29,880
there may be because of the

1708
01:05:29,880 --> 01:05:31,859
stochasticity there may be buckets which

1709
01:05:31,859 --> 01:05:34,319
have no honest parties and there may be

1710
01:05:34,319 --> 01:05:35,819
buckets which have you know only

1711
01:05:35,819 --> 01:05:39,720
Byzantine members in them

1712
01:05:39,720 --> 01:05:41,400
and moreover if you're thinking of this

1713
01:05:41,400 --> 01:05:44,700
from the perspective of the adversary

1714
01:05:44,700 --> 01:05:46,500
diversary can actually perhaps

1715
01:05:46,500 --> 01:05:48,599
adaptively corrupt parties in different

1716
01:05:48,599 --> 01:05:50,940
public buckets so that not enough Shares

1717
01:05:50,940 --> 01:05:52,980
are reset so so if you're thinking of

1718
01:05:52,980 --> 01:05:56,059
this uh from the adversary standpoint

1719
01:05:56,059 --> 01:05:58,380
observe that for any bucket of some

1720
01:05:58,380 --> 01:06:00,720
honest party re-shares a message then

1721
01:06:00,720 --> 01:06:03,180
all honest parties are satisfied you

1722
01:06:03,180 --> 01:06:04,619
know that's no good for the adversary

1723
01:06:04,619 --> 01:06:07,440
but if so what the adversary is trying

1724
01:06:07,440 --> 01:06:08,940
to maximize is the total number of

1725
01:06:08,940 --> 01:06:11,220
buckets where there exists no honors

1726
01:06:11,220 --> 01:06:13,440
parties who can perform this reshare

1727
01:06:13,440 --> 01:06:15,680
step

1728
01:06:15,839 --> 01:06:17,760
it turns out that we actually address

1729
01:06:17,760 --> 01:06:21,059
these concerns using a very subtle

1730
01:06:21,059 --> 01:06:23,280
analysis of a balls and bins analysis

1731
01:06:23,280 --> 01:06:25,980
using mcdr meds inequality

1732
01:06:25,980 --> 01:06:27,599
so the ball sentence analysis

1733
01:06:27,599 --> 01:06:29,460
essentially says that you know if you

1734
01:06:29,460 --> 01:06:32,039
throw C Kappa balls referring to you

1735
01:06:32,039 --> 01:06:33,960
know these committee members into Kappa

1736
01:06:33,960 --> 01:06:36,059
bills in such a way that a minority of

1737
01:06:36,059 --> 01:06:38,520
them can be corrupt

1738
01:06:38,520 --> 01:06:40,920
then our goal is to ensure that there

1739
01:06:40,920 --> 01:06:43,859
exists some constant C such that you

1740
01:06:43,859 --> 01:06:46,020
have sufficiently many buckets or

1741
01:06:46,020 --> 01:06:47,640
members in sufficiently many buckets

1742
01:06:47,640 --> 01:06:49,980
that are honest and these members can

1743
01:06:49,980 --> 01:06:53,460
perform the necessary reshare step

1744
01:06:53,460 --> 01:06:56,280
and and I invite you to take a look at

1745
01:06:56,280 --> 01:07:00,299
our work uh to understand these details

1746
01:07:00,299 --> 01:07:02,700
so I must also mention that I'm glossing

1747
01:07:02,700 --> 01:07:03,960
a lot of other details and other

1748
01:07:03,960 --> 01:07:06,900
subtleties in the protocol over here as

1749
01:07:06,900 --> 01:07:08,220
an example you know when you're

1750
01:07:08,220 --> 01:07:10,920
performing this distribute step

1751
01:07:10,920 --> 01:07:12,720
there are these committees that are

1752
01:07:12,720 --> 01:07:15,839
performing these distributes step and

1753
01:07:15,839 --> 01:07:18,359
you want to ensure that the committee so

1754
01:07:18,359 --> 01:07:20,700
when you're agreeing upon uh these

1755
01:07:20,700 --> 01:07:22,079
messages in a ba protocol you're

1756
01:07:22,079 --> 01:07:24,539
agreeing upon one of the inputs right so

1757
01:07:24,539 --> 01:07:25,920
if a committee is sending these messages

1758
01:07:25,920 --> 01:07:28,140
to everyone you want to ensure that at

1759
01:07:28,140 --> 01:07:30,420
least one Committee Member knows or has

1760
01:07:30,420 --> 01:07:31,980
access to the message who is to

1761
01:07:31,980 --> 01:07:34,319
distribute in the first place so there

1762
01:07:34,319 --> 01:07:36,059
are certainties involved with how

1763
01:07:36,059 --> 01:07:37,920
different you know sub Protocols are

1764
01:07:37,920 --> 01:07:40,319
invoked and so on and again for for

1765
01:07:40,319 --> 01:07:42,900
those aspects I I invite you to look at

1766
01:07:42,900 --> 01:07:45,359
look at our work

1767
01:07:45,359 --> 01:07:48,119
so let me conclude by by presenting the

1768
01:07:48,119 --> 01:07:50,280
key result that we achieve

1769
01:07:50,280 --> 01:07:52,619
so we say that you know for any Epsilon

1770
01:07:52,619 --> 01:07:55,500
greater than 0 we show and we show that

1771
01:07:55,500 --> 01:07:57,240
there exists an adaptively secure ba

1772
01:07:57,240 --> 01:07:58,559
protocol achieving a communication

1773
01:07:58,559 --> 01:08:01,680
complexity of NL plus and polycarpa

1774
01:08:01,680 --> 01:08:04,500
for L bet inputs and then we show it

1775
01:08:04,500 --> 01:08:06,240
under two different conditions you know

1776
01:08:06,240 --> 01:08:07,740
under a synchronous Network we can show

1777
01:08:07,740 --> 01:08:09,539
that we can tolerate a minority

1778
01:08:09,539 --> 01:08:12,000
corruption and under an asynchronous

1779
01:08:12,000 --> 01:08:14,180
Network we can show that we can tolerate

1780
01:08:14,180 --> 01:08:17,698
uh at n over three corruption so there's

1781
01:08:17,698 --> 01:08:19,679
an Epsilon slack over here which we get

1782
01:08:19,679 --> 01:08:21,299
because of because of the sampling

1783
01:08:21,299 --> 01:08:22,620
process

1784
01:08:22,620 --> 01:08:24,479
and note that all through the talk I I

1785
01:08:24,479 --> 01:08:25,799
never spoke about the network condition

1786
01:08:25,799 --> 01:08:27,779
synchronous or recent news partly

1787
01:08:27,779 --> 01:08:28,979
because

1788
01:08:28,979 --> 01:08:31,319
all of these complexities related to

1789
01:08:31,319 --> 01:08:33,660
synchrony or asynchini is kind of

1790
01:08:33,660 --> 01:08:36,120
absorbed by the underlying ba protocol

1791
01:08:36,120 --> 01:08:38,698
and and it does not really affect the

1792
01:08:38,698 --> 01:08:40,859
core content of the core ideas of that

1793
01:08:40,859 --> 01:08:43,620
we are presenting over here

1794
01:08:43,620 --> 01:08:44,939
so

1795
01:08:44,939 --> 01:08:47,040
with that I'd be happy to take questions

1796
01:08:47,040 --> 01:08:49,040
and then here's a link to our paper

1797
01:08:49,040 --> 01:08:52,160
thank you

1798
01:08:52,319 --> 01:08:55,319
questions

1799
01:08:58,040 --> 01:09:01,339
other questions

1800
01:09:06,238 --> 01:09:09,600
okay uh I have a question so

1801
01:09:09,600 --> 01:09:11,399
I mean a fairly minor one I'm curious

1802
01:09:11,399 --> 01:09:14,339
about the uh poly K comes from is it

1803
01:09:14,339 --> 01:09:16,500
from your combinatorial analysis or is

1804
01:09:16,500 --> 01:09:17,880
it some sort of cryptography that's

1805
01:09:17,880 --> 01:09:20,420
hiding there

1806
01:09:21,238 --> 01:09:23,520
but uh that's a good question so so

1807
01:09:23,520 --> 01:09:26,640
under asynchrony there is uh

1808
01:09:26,640 --> 01:09:28,738
cryptography hidden over there

1809
01:09:28,738 --> 01:09:31,080
uh so so that so it basically comes from

1810
01:09:31,080 --> 01:09:32,580
the underlying ba protocol the state of

1811
01:09:32,580 --> 01:09:34,859
the art for asynchronous the poly is

1812
01:09:34,859 --> 01:09:36,779
actually copper to the six

1813
01:09:36,779 --> 01:09:39,839
uh for synchrony it comes from uh sort

1814
01:09:39,839 --> 01:09:42,540
of the actual poly is Kappa cubed

1815
01:09:42,540 --> 01:09:44,939
uh and I think it says it comes from the

1816
01:09:44,939 --> 01:09:45,960
size of the message because we're

1817
01:09:45,960 --> 01:09:48,479
talking about the number of bits so uh

1818
01:09:48,479 --> 01:09:50,939
so if you're sending you know vrf values

1819
01:09:50,939 --> 01:09:53,520
so that that's Kappa bits as well as the

1820
01:09:53,520 --> 01:09:56,340
number of rounds of communication so

1821
01:09:56,340 --> 01:09:58,739
it's Kappa people sending copper sized

1822
01:09:58,739 --> 01:10:01,620
messages I believe for Kappa routes or

1823
01:10:01,620 --> 01:10:03,420
not but I think so so those are the two

1824
01:10:03,420 --> 01:10:04,860
kappas I don't remember off the top of

1825
01:10:04,860 --> 01:10:07,820
my head what the third is

1826
01:10:09,780 --> 01:10:12,660
in terms of cryptographic assumptions uh

1827
01:10:12,660 --> 01:10:15,360
do you uh you presented your work as

1828
01:10:15,360 --> 01:10:17,100
combining two different approaches is

1829
01:10:17,100 --> 01:10:18,780
the assumptions that you use basically

1830
01:10:18,780 --> 01:10:21,239
just a combination of those two or is

1831
01:10:21,239 --> 01:10:22,980
there something new in this

1832
01:10:22,980 --> 01:10:26,100
uh so so it kind of comes in from the

1833
01:10:26,100 --> 01:10:28,080
underlying ba protocol

1834
01:10:28,080 --> 01:10:30,659
so in the case of synchrony you would

1835
01:10:30,659 --> 01:10:31,920
use whatever setup assumption is

1836
01:10:31,920 --> 01:10:34,380
required for for a vrf uh under

1837
01:10:34,380 --> 01:10:36,420
asynchrony I think the best underlying

1838
01:10:36,420 --> 01:10:38,400
ba protocol requires a lot of other

1839
01:10:38,400 --> 01:10:40,860
assumptions so but but everything comes

1840
01:10:40,860 --> 01:10:42,420
from from underneath we're not

1841
01:10:42,420 --> 01:10:45,739
introducing anything more

1842
01:10:46,260 --> 01:10:48,300
yeah uh thanks for the answers and

1843
01:10:48,300 --> 01:10:49,739
thanks for the talk

1844
01:10:49,739 --> 01:10:51,420
thank you so much

1845
01:10:51,420 --> 01:10:53,520
and that wraps up this session let's

1846
01:10:53,520 --> 01:10:56,719
thank Karthik again

1847
01:11:08,219 --> 01:11:11,699
this is uh bound to happen at some point

1848
01:11:11,699 --> 01:11:15,440
and like uh Mr

1849
01:11:15,440 --> 01:11:17,699
eduard Hulk

1850
01:11:17,699 --> 01:11:21,600
and test positive and he kindly let us

1851
01:11:21,600 --> 01:11:25,080
disclose his name so if you were in

1852
01:11:25,080 --> 01:11:27,020
close contact with him

1853
01:11:27,020 --> 01:11:30,600
please take a rapid test I mean you do

1854
01:11:30,600 --> 01:11:33,360
not need to do anything else right now

1855
01:11:33,360 --> 01:11:35,040
I mean so

1856
01:11:35,040 --> 01:11:38,460
the the person who tests positive is

1857
01:11:38,460 --> 01:11:39,679
basically

1858
01:11:39,679 --> 01:11:42,840
confined for five days but if you have

1859
01:11:42,840 --> 01:11:45,780
contact with him there's you do not need

1860
01:11:45,780 --> 01:11:48,120
to do anything more than what you are

1861
01:11:48,120 --> 01:11:50,420
doing now you should take a test today

1862
01:11:50,420 --> 01:11:53,880
and do a test every two days after that

1863
01:11:53,880 --> 01:11:58,920
just like we announced during the uh

1864
01:11:58,920 --> 01:12:02,580
information email so if you need any

1865
01:12:02,580 --> 01:12:06,960
tests please come to the uh registration

1866
01:12:06,960 --> 01:12:11,460
desk and uh and get get yourself tested

1867
01:12:11,460 --> 01:12:14,520
and kindly inform us if you are positive

1868
01:12:14,520 --> 01:12:18,120
of course and uh try not to get into

1869
01:12:18,120 --> 01:12:20,340
contact with more people

1870
01:12:20,340 --> 01:12:21,800
and

1871
01:12:21,800 --> 01:12:25,440
otherwise uh I mean uh sorry to bring

1872
01:12:25,440 --> 01:12:28,020
this news but uh I mean it's

1873
01:12:28,020 --> 01:12:30,920
a common place happenstance nowadays so

1874
01:12:30,920 --> 01:12:34,020
uh you know we try to continue with the

1875
01:12:34,020 --> 01:12:36,440
conference

1876
01:12:36,780 --> 01:12:39,860
thanks everybody

1877
01:12:40,739 --> 01:12:43,400
foreign

