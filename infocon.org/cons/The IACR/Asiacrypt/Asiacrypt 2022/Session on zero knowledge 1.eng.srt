1
00:00:00,539 --> 00:00:02,639
in other words what does it mean to make

2
00:00:02,639 --> 00:00:05,580
a digital signature or a digital proof

3
00:00:05,580 --> 00:00:07,080
vanish

4
00:00:07,080 --> 00:00:10,139
so the way we think about this is with

5
00:00:10,139 --> 00:00:12,059
uh

6
00:00:12,059 --> 00:00:13,860
the way we think about this is making

7
00:00:13,860 --> 00:00:15,780
the soundness of the proof or the

8
00:00:15,780 --> 00:00:19,038
soundness of the signature disappear

9
00:00:19,800 --> 00:00:22,020
so consider Alice who signed something

10
00:00:22,020 --> 00:00:25,140
at time T is equal to zero uh and we

11
00:00:25,140 --> 00:00:28,859
wanted a signature to uh the sound up to

12
00:00:28,859 --> 00:00:31,260
time P but then after time P it

13
00:00:31,260 --> 00:00:34,260
shouldn't be sound uh verifier looking

14
00:00:34,260 --> 00:00:35,940
at the signature wouldn't be convinced

15
00:00:35,940 --> 00:00:38,760
that it's analysis so this also gives us

16
00:00:38,760 --> 00:00:41,160
the notion of liability if someone sees

17
00:00:41,160 --> 00:00:44,219
the signature After Time t uh Alice

18
00:00:44,219 --> 00:00:46,020
could possibly claim that she never

19
00:00:46,020 --> 00:00:47,040
signed

20
00:00:47,040 --> 00:00:48,480
that could have been made by someone who

21
00:00:48,480 --> 00:00:50,460
had no knowledge of her privacy

22
00:00:50,460 --> 00:00:51,899
right

23
00:00:51,899 --> 00:00:54,539
so how do we do this uh the underlying

24
00:00:54,539 --> 00:00:55,680
technique behind all of our

25
00:00:55,680 --> 00:00:58,379
constructions is to allow for signatures

26
00:00:58,379 --> 00:01:01,320
to be forged through a slow computation

27
00:01:01,320 --> 00:01:03,719
and similarly proofs can be sure uh

28
00:01:03,719 --> 00:01:06,180
words like that so here we have a forger

29
00:01:06,180 --> 00:01:08,880
who uh does a long sequential

30
00:01:08,880 --> 00:01:10,920
computation of these steps and finally

31
00:01:10,920 --> 00:01:14,520
produces the Forger and uh to any

32
00:01:14,520 --> 00:01:16,080
distinguishers seeing the real signature

33
00:01:16,080 --> 00:01:20,600
by Alice and the port signature uh

34
00:01:23,220 --> 00:01:25,979
uh all of this requires some notion of

35
00:01:25,979 --> 00:01:27,060
time

36
00:01:27,060 --> 00:01:30,540
so someone uh is getting a signature

37
00:01:30,540 --> 00:01:31,920
should know if it was made within the

38
00:01:31,920 --> 00:01:35,040
past time or not and it's hard to time

39
00:01:35,040 --> 00:01:37,079
stamp every single signature it's

40
00:01:37,079 --> 00:01:39,420
magnetically possible so without like a

41
00:01:39,420 --> 00:01:41,820
global block or anything so what we use

42
00:01:41,820 --> 00:01:45,299
instead are beacons so consider like a

43
00:01:45,299 --> 00:01:47,579
global Beacon over here which emits uh

44
00:01:47,579 --> 00:01:51,000
some bits of Randomness every uh uh

45
00:01:51,000 --> 00:01:53,759
Delta steps or time over here uh and

46
00:01:53,759 --> 00:01:55,320
this Randomness is unpredictable

47
00:01:55,320 --> 00:01:57,899
uncontrollable

48
00:01:57,899 --> 00:02:00,119
so uh beacons have been made using

49
00:02:00,119 --> 00:02:02,159
Randomness from stock prices blockchain

50
00:02:02,159 --> 00:02:04,380
block hashes and distributed protocols

51
00:02:04,380 --> 00:02:07,979
with multiple parties like the events

52
00:02:07,979 --> 00:02:10,619
so how would a solution with a beacon

53
00:02:10,619 --> 00:02:13,500
look like uh if uh say the beacon value

54
00:02:13,500 --> 00:02:17,400
B was emitted at Time Zero uh and we

55
00:02:17,400 --> 00:02:19,379
want the signature or proof for whatever

56
00:02:19,379 --> 00:02:21,959
was created to expire at time P after

57
00:02:21,959 --> 00:02:24,720
the beginning was released uh so here

58
00:02:24,720 --> 00:02:27,720
say I'll sign something after the beacon

59
00:02:27,720 --> 00:02:30,120
was released this signing algorithm that

60
00:02:30,120 --> 00:02:33,300
Alice uses would specify the beacon

61
00:02:33,300 --> 00:02:34,200
value

62
00:02:34,200 --> 00:02:36,959
in the protocol and similarly

63
00:02:36,959 --> 00:02:39,540
and uh once time T is reached regardless

64
00:02:39,540 --> 00:02:41,640
of when exactly Alice made her signature

65
00:02:41,640 --> 00:02:44,160
the soundness would be lost over there

66
00:02:44,160 --> 00:02:47,640
right uh so without a timestamping

67
00:02:47,640 --> 00:02:50,640
mechanism or a global clock we can uh

68
00:02:50,640 --> 00:02:55,440
use beacons to uh make significance

69
00:02:55,440 --> 00:02:58,099
come on

70
00:03:01,500 --> 00:03:03,239
yeah so the rest of the stock I'll go

71
00:03:03,239 --> 00:03:04,680
over some applications or short-lived

72
00:03:04,680 --> 00:03:08,640
proofs and short-lived signatures and uh

73
00:03:08,640 --> 00:03:10,200
then go over construction which is

74
00:03:10,200 --> 00:03:12,540
verifiable delay functions as a key tool

75
00:03:12,540 --> 00:03:16,400
and a briefly go over there

76
00:03:16,560 --> 00:03:19,980
okay so uh in denial so when uh email

77
00:03:19,980 --> 00:03:23,659
servers exchange emails they sign out to

78
00:03:23,659 --> 00:03:26,159
authenticate them so this is required

79
00:03:26,159 --> 00:03:27,840
for security and it's only really needed

80
00:03:27,840 --> 00:03:29,700
during Transit so when the second server

81
00:03:29,700 --> 00:03:31,319
receives the email and verifies the

82
00:03:31,319 --> 00:03:34,140
signature it's no longer but these

83
00:03:34,140 --> 00:03:36,000
signatures do last forever and

84
00:03:36,000 --> 00:03:38,340
undesirable side effect of this is that

85
00:03:38,340 --> 00:03:40,739
they can be used to validate

86
00:03:40,739 --> 00:03:44,280
so here's like a picture of a uh a

87
00:03:44,280 --> 00:03:47,340
famous Wikileaks in 2016 where all of

88
00:03:47,340 --> 00:03:48,900
the emails were actually kept their

89
00:03:48,900 --> 00:03:50,340
Google Furniture

90
00:03:50,340 --> 00:03:51,440
um

91
00:03:51,440 --> 00:03:54,900
uh the main thing is identified

92
00:03:54,900 --> 00:03:58,560
um so this is not uh at the intended use

93
00:03:58,560 --> 00:04:01,019
of these signatures and um this problem

94
00:04:01,019 --> 00:04:02,299
is

95
00:04:02,299 --> 00:04:05,819
one solution he suggested was uh Google

96
00:04:05,819 --> 00:04:07,500
would like periodically release their

97
00:04:07,500 --> 00:04:11,159
signing keys so uh Republic and so any

98
00:04:11,159 --> 00:04:13,579
signatures

99
00:04:15,180 --> 00:04:15,959
um

100
00:04:15,959 --> 00:04:18,720
one uh so shortened signatures are like

101
00:04:18,720 --> 00:04:22,500
a natural solution problem where uh when

102
00:04:22,500 --> 00:04:24,960
uh investor wants to send an email they

103
00:04:24,960 --> 00:04:29,599
sign it with a short uh it'll be valid

104
00:04:34,860 --> 00:04:37,500
uh over here uh you can show the

105
00:04:37,500 --> 00:04:39,000
signature after thank you to the whole

106
00:04:39,000 --> 00:04:42,560
world anyone could have made it

107
00:04:42,660 --> 00:04:45,240
and with this the advantage here is that

108
00:04:45,240 --> 00:04:47,400
uh the signer no longer has to do any

109
00:04:47,400 --> 00:04:49,199
actions like releasing their key they

110
00:04:49,199 --> 00:04:51,660
can keep one key they don't have this or

111
00:04:51,660 --> 00:04:53,820
anything if you like your private key

112
00:04:53,820 --> 00:04:56,100
you can keep

113
00:04:56,100 --> 00:04:59,280
it uh if it certainly proves

114
00:04:59,280 --> 00:05:02,580
the rewarding system so uh suppose

115
00:05:02,580 --> 00:05:04,699
someone makes a vote

116
00:05:04,699 --> 00:05:07,020
and The Ballot Box gives them their

117
00:05:07,020 --> 00:05:09,300
proof that they their vote was included

118
00:05:09,300 --> 00:05:11,940
correctly right an undesirable side

119
00:05:11,940 --> 00:05:14,820
effect of this is that this proof can be

120
00:05:14,820 --> 00:05:17,580
used to get like

121
00:05:17,580 --> 00:05:19,860
that and it's like a receipt of what

122
00:05:19,860 --> 00:05:22,320
they did so e-boarding systems want to

123
00:05:22,320 --> 00:05:24,180
have a receipts

124
00:05:24,180 --> 00:05:26,520
uh

125
00:05:26,520 --> 00:05:28,500
the proof lasts for a few minutes while

126
00:05:28,500 --> 00:05:31,620
they're in the ballot group and after

127
00:05:31,620 --> 00:05:34,220
that uh

128
00:05:34,220 --> 00:05:37,699
it doesn't function

129
00:05:39,180 --> 00:05:41,699
so uh there have been other lots of

130
00:05:41,699 --> 00:05:44,900
related work on this area

131
00:05:45,060 --> 00:05:47,639
I just needed verifier groups or proofs

132
00:05:47,639 --> 00:05:49,500
that make sense to one verifier but no

133
00:05:49,500 --> 00:05:51,740
one else

134
00:05:51,740 --> 00:05:55,100
it makes sense

135
00:05:56,039 --> 00:05:59,180
uh time signatures

136
00:05:59,180 --> 00:06:03,180
we can solve the inverse problems

137
00:06:03,180 --> 00:06:04,620
as signatures are like locked Central

138
00:06:04,620 --> 00:06:06,840
Time

139
00:06:06,840 --> 00:06:09,960
where we want signatures to be valid

140
00:06:09,960 --> 00:06:12,320
uh

141
00:06:14,280 --> 00:06:16,860
actions from the sign or third party to

142
00:06:16,860 --> 00:06:20,060
for uh

143
00:06:20,360 --> 00:06:22,740
proof of worker knowledge also solves a

144
00:06:22,740 --> 00:06:25,139
problem where uh if someone either knows

145
00:06:25,139 --> 00:06:27,960
a witness to a proof or uh did a long

146
00:06:27,960 --> 00:06:30,660
time but they used to work and it's

147
00:06:30,660 --> 00:06:32,340
paralyzable and not really a notion of

148
00:06:32,340 --> 00:06:34,580
time

149
00:06:35,639 --> 00:06:37,979
uh so just a quick note on formalizing

150
00:06:37,979 --> 00:06:39,720
uh sure so when the rest of stock I'll

151
00:06:39,720 --> 00:06:41,460
stick with short little truth and so in

152
00:06:41,460 --> 00:06:43,259
formalizing them they have like a

153
00:06:43,259 --> 00:06:45,000
approved algorithm and a verify

154
00:06:45,000 --> 00:06:46,919
algorithm additionally we have a forge

155
00:06:46,919 --> 00:06:50,240
algorithm and all of these things

156
00:06:50,940 --> 00:06:55,039
and completely set the two uh

157
00:06:55,039 --> 00:06:57,720
uh the portability the forging time

158
00:06:57,720 --> 00:07:00,780
should be just overwritten uh in this

159
00:07:00,780 --> 00:07:02,100
inducibility means that the proof is

160
00:07:02,100 --> 00:07:05,580
generated by imperative report

161
00:07:05,580 --> 00:07:10,400
and this business you know this uh

162
00:07:10,979 --> 00:07:13,500
and uh we need a new notion of soundness

163
00:07:13,500 --> 00:07:16,759
for key soundness where you can expect

164
00:07:16,759 --> 00:07:19,020
that uh can produce groups in time

165
00:07:19,020 --> 00:07:21,180
listening but after time T this

166
00:07:21,180 --> 00:07:24,500
extraction guarantee is lost

167
00:07:24,900 --> 00:07:26,819
so all the constructions will be

168
00:07:26,819 --> 00:07:29,300
translated

169
00:07:33,660 --> 00:07:37,220
uh we have four translations

170
00:07:39,300 --> 00:07:42,380
uh and uh

171
00:07:43,740 --> 00:07:46,440
for a vdf a function that takes a fixed

172
00:07:46,440 --> 00:07:49,620
number of sequential steps to compute uh

173
00:07:49,620 --> 00:07:51,900
but once this application is done it's

174
00:07:51,900 --> 00:07:54,300
easy to convince a verifier that the

175
00:07:54,300 --> 00:07:56,699
computation was done correctly

176
00:07:56,699 --> 00:07:58,199
uh

177
00:07:58,199 --> 00:08:00,240
so here an example or repeat its current

178
00:08:00,240 --> 00:08:02,880
PDFs where the input is an element in a

179
00:08:02,880 --> 00:08:04,099
group

180
00:08:04,099 --> 00:08:07,620
and the output is

181
00:08:07,620 --> 00:08:10,639
and the fastest

182
00:08:12,120 --> 00:08:14,759
uh but once these sets are done you they

183
00:08:14,759 --> 00:08:16,440
can generate a proof that producers are

184
00:08:16,440 --> 00:08:19,639
verified that Y is indeed

185
00:08:20,340 --> 00:08:24,138
uh so um

186
00:08:31,680 --> 00:08:34,380
the security property

187
00:08:34,380 --> 00:08:35,940
it's hard to convince it verifier

188
00:08:35,940 --> 00:08:39,380
without spending time

189
00:08:39,839 --> 00:08:41,339
okay so the most straightforward

190
00:08:41,339 --> 00:08:43,200
construction to get effective to the

191
00:08:43,200 --> 00:08:46,740
specific or the whatever you want to

192
00:08:46,740 --> 00:08:48,899
prove and

193
00:08:48,899 --> 00:08:52,339
here uh if you have a relational

194
00:08:52,339 --> 00:08:55,140
input X which is W that's one branch of

195
00:08:55,140 --> 00:08:58,200
the or and the other branches the media

196
00:08:58,200 --> 00:09:02,120
taking the beacon value is

197
00:09:02,899 --> 00:09:05,160
completeness because an honest viewer

198
00:09:05,160 --> 00:09:06,660
can ignore the vdf branch and just

199
00:09:06,660 --> 00:09:09,420
satisfy the relationship

200
00:09:09,420 --> 00:09:11,040
and a forger who doesn't know the

201
00:09:11,040 --> 00:09:12,600
witness and I have to satisfy the PDF

202
00:09:12,600 --> 00:09:15,060
Branch by actually Computing the vdf

203
00:09:15,060 --> 00:09:17,339
and uh since the PDF takes these steps

204
00:09:17,339 --> 00:09:20,420
to do you get

205
00:09:21,260 --> 00:09:23,279
also proven distinguishably and

206
00:09:23,279 --> 00:09:25,640
soundness

207
00:09:27,420 --> 00:09:29,580
note here that only one person has to

208
00:09:29,580 --> 00:09:31,980
compute the vdf output and proof on the

209
00:09:31,980 --> 00:09:34,560
beacon value and everybody can use their

210
00:09:34,560 --> 00:09:38,459
Y and pi to forge groups on uh any

211
00:09:38,459 --> 00:09:39,660
relation

212
00:09:39,660 --> 00:09:41,760
thank you

213
00:09:41,760 --> 00:09:43,560
and so this stronger notion of

214
00:09:43,560 --> 00:09:45,300
portability we're calling reusable

215
00:09:45,300 --> 00:09:48,420
forageability where the first quarter uh

216
00:09:48,420 --> 00:09:51,420
additionally produces an advice that

217
00:09:51,420 --> 00:09:55,200
helps make more fun

218
00:09:55,200 --> 00:09:57,120
so here uh this is really good in

219
00:09:57,120 --> 00:10:00,120
practice because one long computation

220
00:10:00,120 --> 00:10:03,060
uh can help uh generate multiple chords

221
00:10:03,060 --> 00:10:06,800
and the more versions there are

222
00:10:08,580 --> 00:10:12,860
uh it enhances

223
00:10:13,620 --> 00:10:16,880
uh where there are the main Construction

224
00:10:16,880 --> 00:10:19,860
so just to establishment you have a

225
00:10:19,860 --> 00:10:22,019
sigma protocol for relation r with uh

226
00:10:22,019 --> 00:10:25,860
input x uh and uh the first step of the

227
00:10:25,860 --> 00:10:28,440
signal protocol a uh gets a challenge C

228
00:10:28,440 --> 00:10:30,800
and since

229
00:10:31,200 --> 00:10:33,480
and uh signal protocols have a simulate

230
00:10:33,480 --> 00:10:35,700
function where uh

231
00:10:35,700 --> 00:10:38,100
without knowing the witness you can

232
00:10:38,100 --> 00:10:40,440
simulate a realistic

233
00:10:40,440 --> 00:10:41,820
all right

234
00:10:41,820 --> 00:10:44,700
but so uh how do we make a sigma

235
00:10:44,700 --> 00:10:46,079
protocol

236
00:10:46,079 --> 00:10:49,260
so the first step over here

237
00:10:49,260 --> 00:10:51,300
C1 and

238
00:10:51,300 --> 00:10:57,480
and uh what we're going to do is use and

239
00:10:57,480 --> 00:10:59,040
what we're going to do is

240
00:10:59,040 --> 00:11:01,860
uh use C1 as a challenge for the

241
00:11:01,860 --> 00:11:03,420
relationship

242
00:11:03,420 --> 00:11:07,920
and CPU as the challenge because

243
00:11:11,279 --> 00:11:14,399
right so why does the inclusion is that

244
00:11:14,399 --> 00:11:16,860
the forger and the viewer will each beat

245
00:11:16,860 --> 00:11:19,680
on different branches of this sand and

246
00:11:19,680 --> 00:11:22,320
uh and honestly

247
00:11:22,320 --> 00:11:24,180
so the forger can simulate the

248
00:11:24,180 --> 00:11:28,079
relationship but then they'll have

249
00:11:28,079 --> 00:11:29,519
problems

250
00:11:29,519 --> 00:11:31,560
and the honest viewer can cheat on the

251
00:11:31,560 --> 00:11:35,420
relation Grant by sorry on the video

252
00:11:39,920 --> 00:11:43,079
so that's the intuition

253
00:11:43,079 --> 00:11:45,240
because of the protocol just want to

254
00:11:45,240 --> 00:11:46,980
note here that the input of the video

255
00:11:46,980 --> 00:11:50,180
clarifier is

256
00:11:51,540 --> 00:11:54,860
so we don't get reusable

257
00:11:55,079 --> 00:11:56,940
right so to get

258
00:11:56,940 --> 00:11:59,540
the design a new type of detail

259
00:11:59,540 --> 00:12:01,260
s

260
00:12:01,260 --> 00:12:03,240
which are similar figures except that

261
00:12:03,240 --> 00:12:05,579
the output y isn't revealed

262
00:12:05,579 --> 00:12:10,699
uh you have again it's very videos

263
00:12:11,160 --> 00:12:12,899
but you just give a proof that you know

264
00:12:12,899 --> 00:12:15,360
why you don't have to go right and to

265
00:12:15,360 --> 00:12:18,660
verify that you do know yeah

266
00:12:18,660 --> 00:12:20,640
uh the neat thing here is that this

267
00:12:20,640 --> 00:12:21,959
could actually be represented as an

268
00:12:21,959 --> 00:12:26,819
efficient Sigma protocol with foreign

269
00:12:51,660 --> 00:12:55,260
of uh the relationship

270
00:12:55,260 --> 00:12:56,700
yes

271
00:12:56,700 --> 00:12:58,920
and just like some more competitions you

272
00:12:58,920 --> 00:13:01,620
can simulate one uh one branch and

273
00:13:01,620 --> 00:13:03,240
honestly

274
00:13:03,240 --> 00:13:06,180
uh so the Uber can simulate the ztb

275
00:13:06,180 --> 00:13:08,639
effect without actually

276
00:13:08,639 --> 00:13:11,220
and they just uh they can run the signal

277
00:13:11,220 --> 00:13:14,480
or their relationships

278
00:13:15,000 --> 00:13:17,100
but the forger since they don't know the

279
00:13:17,100 --> 00:13:19,260
witness they'll have to simulate the

280
00:13:19,260 --> 00:13:21,839
relations branch and then uh honestly

281
00:13:21,839 --> 00:13:24,320
completely

282
00:13:26,100 --> 00:13:28,579
foreign

283
00:13:57,240 --> 00:13:59,760
uh and uh just briefly going over the

284
00:13:59,760 --> 00:14:02,399
implementation we use vespowski vdfs

285
00:14:02,399 --> 00:14:04,620
which with rsa2048 groups which are

286
00:14:04,620 --> 00:14:06,540
pretty large but even with that the

287
00:14:06,540 --> 00:14:08,339
overhead for transforming signal

288
00:14:08,339 --> 00:14:10,560
protocol into a short-term protocol is

289
00:14:10,560 --> 00:14:12,779
pretty low it's only by half a kilobyte

290
00:14:12,779 --> 00:14:14,660
for the tubes and even less than that

291
00:14:14,660 --> 00:14:17,760
RSA signatures and the clear time

292
00:14:17,760 --> 00:14:20,700
overhead is 120 milliseconds not that

293
00:14:20,700 --> 00:14:24,600
much and much lower signature uh so just

294
00:14:24,600 --> 00:14:25,740
wanted to highlight here that these

295
00:14:25,740 --> 00:14:29,339
transitions are practical and uh

296
00:14:29,339 --> 00:14:31,139
right so with that I'd like to conclude

297
00:14:31,139 --> 00:14:35,120
and if you have any questions thank you

298
00:14:43,459 --> 00:14:44,930
any questions

299
00:14:44,930 --> 00:14:48,130
[Music]

300
00:14:53,279 --> 00:14:54,860
I have one

301
00:14:54,860 --> 00:14:57,720
how fine

302
00:14:57,720 --> 00:15:00,899
um how fine grain can you control the

303
00:15:00,899 --> 00:15:02,399
the period

304
00:15:02,399 --> 00:15:05,040
at the time yeah that theory depend on

305
00:15:05,040 --> 00:15:06,240
the beacon

306
00:15:06,240 --> 00:15:08,579
uh it's actually dependent on the vdf so

307
00:15:08,579 --> 00:15:10,740
here our vdf is y is equal to X bar 2

308
00:15:10,740 --> 00:15:13,980
per T and it takes exactly three steps

309
00:15:13,980 --> 00:15:16,440
so the Practical time would depend on

310
00:15:16,440 --> 00:15:18,660
the proving Hardware uh and all that but

311
00:15:18,660 --> 00:15:20,519
uh the vdfs are becoming very

312
00:15:20,519 --> 00:15:22,079
standardized

313
00:15:22,079 --> 00:15:25,440
like a specific Asics to compute this so

314
00:15:25,440 --> 00:15:27,720
it's likely that it won't get any faster

315
00:15:27,720 --> 00:15:29,220
Beyond a point like there will be fast

316
00:15:29,220 --> 00:15:30,540
Hardware that does it really fast so

317
00:15:30,540 --> 00:15:32,519
we'll have to that'll probably be the

318
00:15:32,519 --> 00:15:36,300
Benchmark for the actual physical time

319
00:15:36,300 --> 00:15:39,060
that it takes but yeah this number of

320
00:15:39,060 --> 00:15:40,800
theoretical steps is fixed but the

321
00:15:40,800 --> 00:15:43,579
hardware depends

322
00:15:45,139 --> 00:15:49,560
other questions ready

323
00:15:53,820 --> 00:15:56,459
hi thanks for your talk uh so I just

324
00:15:56,459 --> 00:15:58,260
have a quick question so are there any

325
00:15:58,260 --> 00:16:00,959
technical difficulties when extending

326
00:16:00,959 --> 00:16:02,459
from signal protocols to multi-round

327
00:16:02,459 --> 00:16:04,079
protocols

328
00:16:04,079 --> 00:16:05,880
yeah we haven't thought about that but

329
00:16:05,880 --> 00:16:07,860
yeah that would be interesting because

330
00:16:07,860 --> 00:16:10,740
um for us uh if they can be composed

331
00:16:10,740 --> 00:16:12,420
like a uh if they have a composition

332
00:16:12,420 --> 00:16:14,100
available I think it would be easy to do

333
00:16:14,100 --> 00:16:17,160
so that might be underlying uh thing you

334
00:16:17,160 --> 00:16:18,600
can always try to compose with the video

335
00:16:18,600 --> 00:16:20,880
and the original signal protocol so

336
00:16:20,880 --> 00:16:22,199
that's something that will come down to

337
00:16:22,199 --> 00:16:26,839
that okay thanks yeah that's interesting

338
00:16:28,279 --> 00:16:33,500
okay so let's thank the speaker again

339
00:16:40,079 --> 00:16:42,540
the second talk in this session is uh

340
00:16:42,540 --> 00:16:44,940
rotatable

341
00:16:44,940 --> 00:16:47,519
rotatable zero knowledge sets

342
00:16:47,519 --> 00:16:49,620
post compromise secure

343
00:16:49,620 --> 00:16:52,079
auditable dictionaries with the

344
00:16:52,079 --> 00:16:55,939
application to key transparency

345
00:16:59,579 --> 00:17:04,638
and the speaker is uh Li golden

346
00:17:11,119 --> 00:17:14,599
please go ahead

347
00:17:16,619 --> 00:17:18,780
hello everyone I'm Eli and I'm going to

348
00:17:18,780 --> 00:17:20,339
be talking about rotatable zero

349
00:17:20,339 --> 00:17:22,619
knowledge sets uh this is Joint work

350
00:17:22,619 --> 00:17:24,720
between Zoom NYU and Microsoft research

351
00:17:24,720 --> 00:17:26,459
uh with Brian Chen you have any notice

352
00:17:26,459 --> 00:17:28,880
ishagosh myself

353
00:17:28,880 --> 00:17:32,340
Antonio marcedon and Marianne burmell

354
00:17:32,340 --> 00:17:34,679
uh our motivation is for end-to-end

355
00:17:34,679 --> 00:17:36,480
encrypted communication systems whereby

356
00:17:36,480 --> 00:17:38,160
parties want to communicate securely

357
00:17:38,160 --> 00:17:39,900
with each other but all messages must

358
00:17:39,900 --> 00:17:41,880
pass through some untrusted server this

359
00:17:41,880 --> 00:17:43,380
is typically done using public key

360
00:17:43,380 --> 00:17:44,940
encryption but the problem is that users

361
00:17:44,940 --> 00:17:46,799
need some way to agree on each other's

362
00:17:46,799 --> 00:17:49,919
public keys uh if for example the user

363
00:17:49,919 --> 00:17:53,720
were to host a database of public keys

364
00:17:53,720 --> 00:17:56,580
if for example the server were to host a

365
00:17:56,580 --> 00:17:59,039
database of public Keys uh then this

366
00:17:59,039 --> 00:18:00,360
could lead to man in the middle attacks

367
00:18:00,360 --> 00:18:01,860
whereby the server could respond with a

368
00:18:01,860 --> 00:18:03,360
compromised public key

369
00:18:03,360 --> 00:18:04,980
uh to prevent this the most common

370
00:18:04,980 --> 00:18:06,799
solution is to use security codes

371
00:18:06,799 --> 00:18:09,120
whereby users will send each other

372
00:18:09,120 --> 00:18:11,340
directly a QR code that can be used to

373
00:18:11,340 --> 00:18:13,380
verify that the public key returned by

374
00:18:13,380 --> 00:18:15,900
the server is in fact correct this is

375
00:18:15,900 --> 00:18:19,200
TDS and requires manual verification and

376
00:18:19,200 --> 00:18:20,940
so it can be audited can be automated

377
00:18:20,940 --> 00:18:22,260
with something called a key transparency

378
00:18:22,260 --> 00:18:23,760
system otherwise known as an audible

379
00:18:23,760 --> 00:18:25,020
dictionary

380
00:18:25,020 --> 00:18:27,419
uh in a key transparency system the

381
00:18:27,419 --> 00:18:29,760
server will provide a commitment comp to

382
00:18:29,760 --> 00:18:32,640
the database of public keys and whenever

383
00:18:32,640 --> 00:18:34,500
a public key is queried the server will

384
00:18:34,500 --> 00:18:36,900
in addition to the public key uh provide

385
00:18:36,900 --> 00:18:39,360
a proof pie that the given identity

386
00:18:39,360 --> 00:18:41,340
public key pair is in fact in the

387
00:18:41,340 --> 00:18:43,679
committed database uh note that we also

388
00:18:43,679 --> 00:18:45,840
require a uniqueness property that is

389
00:18:45,840 --> 00:18:47,400
for every identity there should be at

390
00:18:47,400 --> 00:18:49,440
most one public key that can be proved

391
00:18:49,440 --> 00:18:51,240
to be stored in the database

392
00:18:51,240 --> 00:18:53,940
uh then as long as all users agree on

393
00:18:53,940 --> 00:18:56,039
the commitment men in the middle attacks

394
00:18:56,039 --> 00:18:58,200
can be detected by users verifying that

395
00:18:58,200 --> 00:19:00,059
their public key is stored correctly

396
00:19:00,059 --> 00:19:03,000
the database may also update and perhaps

397
00:19:03,000 --> 00:19:04,620
frequently as users update their public

398
00:19:04,620 --> 00:19:06,900
keys and we would not necessarily want

399
00:19:06,900 --> 00:19:08,340
user staff to check that they're

400
00:19:08,340 --> 00:19:10,320
publicly is stored correctly for each

401
00:19:10,320 --> 00:19:11,700
commitment

402
00:19:11,700 --> 00:19:14,640
so uh every time the server updates the

403
00:19:14,640 --> 00:19:16,440
commitment it will also produce a proof

404
00:19:16,440 --> 00:19:17,940
pie that the update has been done

405
00:19:17,940 --> 00:19:19,799
consistently which can be independently

406
00:19:19,799 --> 00:19:21,539
audited not by the users themselves both

407
00:19:21,539 --> 00:19:23,700
by some trusted third parties and this

408
00:19:23,700 --> 00:19:25,919
increases the efficiency as users no

409
00:19:25,919 --> 00:19:27,120
longer need to check that their public

410
00:19:27,120 --> 00:19:28,220
use

411
00:19:28,220 --> 00:19:31,799
correct every single update

412
00:19:31,799 --> 00:19:33,660
uh by default this does not preserve

413
00:19:33,660 --> 00:19:35,760
privacy that is the proofs May leak

414
00:19:35,760 --> 00:19:37,620
information about the database but there

415
00:19:37,620 --> 00:19:39,840
are privacy preserving solutions for key

416
00:19:39,840 --> 00:19:42,120
transparency namely uh conics and

417
00:19:42,120 --> 00:19:44,520
seamless as examples I will be focusing

418
00:19:44,520 --> 00:19:45,900
on seamless since that is what our

419
00:19:45,900 --> 00:19:48,720
contribution builds off of

420
00:19:48,720 --> 00:19:50,059
um seamless

421
00:19:50,059 --> 00:19:52,320
achieves keep private key transparency

422
00:19:52,320 --> 00:19:54,720
using a primitive that they call append

423
00:19:54,720 --> 00:19:57,059
only zero knowledge sets and append only

424
00:19:57,059 --> 00:19:59,220
zero knowledge set or azks is

425
00:19:59,220 --> 00:20:00,960
essentially a key transparency system

426
00:20:00,960 --> 00:20:03,360
but for generalized databases for any

427
00:20:03,360 --> 00:20:05,580
label value pairs the consistency

428
00:20:05,580 --> 00:20:07,740
property that the proofs verify is that

429
00:20:07,740 --> 00:20:09,660
the database is a pendant that is the

430
00:20:09,660 --> 00:20:13,200
proof uh the update proof shows that uh

431
00:20:13,200 --> 00:20:15,179
no database entries have been either

432
00:20:15,179 --> 00:20:16,980
deleted or changed

433
00:20:16,980 --> 00:20:20,700
uh the proofs in ezekiel's are privacy

434
00:20:20,700 --> 00:20:22,740
preserving that is there zero knowledge

435
00:20:22,740 --> 00:20:25,200
um the proofs uh both query and update

436
00:20:25,200 --> 00:20:26,700
prints reveal no more information than

437
00:20:26,700 --> 00:20:27,780
necessary

438
00:20:27,780 --> 00:20:30,480
and it turns out that to achieve azks

439
00:20:30,480 --> 00:20:32,280
the construction in the seamless paper

440
00:20:32,280 --> 00:20:35,280
uh really requires some sort of uh

441
00:20:35,280 --> 00:20:37,860
secret key public key primitive that is

442
00:20:37,860 --> 00:20:39,780
the database the server storing the

443
00:20:39,780 --> 00:20:41,460
database will also have some secret key

444
00:20:41,460 --> 00:20:44,700
that they will use to hide the data and

445
00:20:44,700 --> 00:20:46,020
there will be a published public key

446
00:20:46,020 --> 00:20:48,600
that will be used to verify the proofs

447
00:20:48,600 --> 00:20:51,240
uh note that seamless and neither is

448
00:20:51,240 --> 00:20:52,919
conics or any existing key transparency

449
00:20:52,919 --> 00:20:54,720
system that decides post compromise

450
00:20:54,720 --> 00:20:57,480
security that is if the secret key is

451
00:20:57,480 --> 00:21:00,179
revealed during say commitment one

452
00:21:00,179 --> 00:21:01,740
um then for all label value pairs

453
00:21:01,740 --> 00:21:03,240
including those added in later

454
00:21:03,240 --> 00:21:05,520
generations uh privacy will still be

455
00:21:05,520 --> 00:21:06,960
lost

456
00:21:06,960 --> 00:21:09,000
our contribution is to add post

457
00:21:09,000 --> 00:21:10,980
compromise security to keep private

458
00:21:10,980 --> 00:21:14,400
transparency systems uh in particular we

459
00:21:14,400 --> 00:21:15,660
Define a new primitive called the

460
00:21:15,660 --> 00:21:17,640
rotatable zero knowledge set which is

461
00:21:17,640 --> 00:21:19,860
the same as a pandemic zero knowledge

462
00:21:19,860 --> 00:21:21,600
set with an addition of a rotate

463
00:21:21,600 --> 00:21:23,460
operation which will change the public

464
00:21:23,460 --> 00:21:25,080
key and provide a proof that the

465
00:21:25,080 --> 00:21:27,660
rotation has been done correctly

466
00:21:27,660 --> 00:21:30,059
um the idea is that even if the old

467
00:21:30,059 --> 00:21:32,039
secret key is compromised all label

468
00:21:32,039 --> 00:21:34,440
value pairs under the new Pro private

469
00:21:34,440 --> 00:21:37,679
key will maintain private

470
00:21:37,679 --> 00:21:39,720
uh let me Begin by talking about a basic

471
00:21:39,720 --> 00:21:41,700
construction of the transparency systems

472
00:21:41,700 --> 00:21:43,980
uh without the Privacy guarantee and

473
00:21:43,980 --> 00:21:45,960
I'll show that how seamless extends on

474
00:21:45,960 --> 00:21:47,400
this to add privacy and then our

475
00:21:47,400 --> 00:21:49,500
contribution on top of that

476
00:21:49,500 --> 00:21:51,419
uh so the basic contribution is that the

477
00:21:51,419 --> 00:21:53,039
commitment to the database will be the

478
00:21:53,039 --> 00:21:55,200
root of some sparse Merkle tree where

479
00:21:55,200 --> 00:21:57,000
for every label value pair in the

480
00:21:57,000 --> 00:21:59,460
database uh there will be a leaf

481
00:21:59,460 --> 00:22:02,700
corresponding to the value at the index

482
00:22:02,700 --> 00:22:06,900
at the point indexed by the tree path

483
00:22:06,900 --> 00:22:09,179
um corresponding to its label

484
00:22:09,179 --> 00:22:12,539
uh then a label value pair can be proven

485
00:22:12,539 --> 00:22:14,159
to be stored in the commitment just by

486
00:22:14,159 --> 00:22:15,720
giving the Merkel open

487
00:22:15,720 --> 00:22:17,760
note that this does not maintain privacy

488
00:22:17,760 --> 00:22:20,039
as if for example the Merkel opening

489
00:22:20,039 --> 00:22:21,780
contains some other Leaf some adjacent

490
00:22:21,780 --> 00:22:23,820
Leaf then it will reveal the fact that

491
00:22:23,820 --> 00:22:25,740
the corresponding adjacent label value

492
00:22:25,740 --> 00:22:28,500
pair is stored in the database

493
00:22:28,500 --> 00:22:30,539
uh to add some privacy onto this the

494
00:22:30,539 --> 00:22:32,640
first thing seamless does is replaces

495
00:22:32,640 --> 00:22:33,960
the value stored at the leaf with a

496
00:22:33,960 --> 00:22:37,080
commitment to the values uh this then

497
00:22:37,080 --> 00:22:39,900
does hide the privacy of the values uh

498
00:22:39,900 --> 00:22:41,159
and in fact

499
00:22:41,159 --> 00:22:43,500
um and so now the new opening uh for the

500
00:22:43,500 --> 00:22:45,419
commitment will be the Merkel the Merkel

501
00:22:45,419 --> 00:22:47,460
opening as well as an opening for the uh

502
00:22:47,460 --> 00:22:49,500
at least the commitment on the leaf so

503
00:22:49,500 --> 00:22:51,780
uh but note that this still does not

504
00:22:51,780 --> 00:22:54,600
achieve total privacy uh since if there

505
00:22:54,600 --> 00:22:56,760
is an adjacent Leaf it will reveal the

506
00:22:56,760 --> 00:22:58,080
fact that the adjacent label is stored

507
00:22:58,080 --> 00:22:59,820
in the database for some value even

508
00:22:59,820 --> 00:23:02,100
though it doesn't leak the value itself

509
00:23:02,100 --> 00:23:05,280
uh so we know that we need to so the

510
00:23:05,280 --> 00:23:06,600
first approach the approach that

511
00:23:06,600 --> 00:23:08,880
seamlessly use is to replace the label

512
00:23:08,880 --> 00:23:11,820
indexing the leaf uh with some other

513
00:23:11,820 --> 00:23:14,340
value associated with the label note

514
00:23:14,340 --> 00:23:15,780
that this could not be deterministic as

515
00:23:15,780 --> 00:23:16,919
then it will leak too much information

516
00:23:16,919 --> 00:23:18,600
about the label

517
00:23:18,600 --> 00:23:20,940
um but we may hope that okay what if we

518
00:23:20,940 --> 00:23:22,679
replace this path with say a commitment

519
00:23:22,679 --> 00:23:24,360
to the label

520
00:23:24,360 --> 00:23:26,100
um this is getting close uh this does

521
00:23:26,100 --> 00:23:27,720
preserve the privacy but the problem is

522
00:23:27,720 --> 00:23:30,240
now we lose the uniqueness property that

523
00:23:30,240 --> 00:23:32,220
is uh for one label there may be two

524
00:23:32,220 --> 00:23:33,659
commitments that correspond to that

525
00:23:33,659 --> 00:23:36,000
label and so therefore uh as if there

526
00:23:36,000 --> 00:23:37,679
are two commitments there may be two

527
00:23:37,679 --> 00:23:39,240
values stored in the database uh

528
00:23:39,240 --> 00:23:42,059
corresponding to the same commitment

529
00:23:42,059 --> 00:23:44,400
um which would be a problem

530
00:23:44,400 --> 00:23:46,740
uh but so we know that we want some

531
00:23:46,740 --> 00:23:49,620
Randomness uh in this path uh but we

532
00:23:49,620 --> 00:23:52,860
need also uniqueness so the uh correct

533
00:23:52,860 --> 00:23:54,299
approach it turns out is to use

534
00:23:54,299 --> 00:23:56,880
something like a PRS

535
00:23:56,880 --> 00:23:58,919
um which will

536
00:23:58,919 --> 00:24:00,539
will guarantee that there is only one

537
00:24:00,539 --> 00:24:02,520
prf output for each label

538
00:24:02,520 --> 00:24:03,840
um but we'll still maintain the privacy

539
00:24:03,840 --> 00:24:05,220
of the label itself

540
00:24:05,220 --> 00:24:07,020
uh the problem here uh the problem with

541
00:24:07,020 --> 00:24:09,419
just using a prf directly is that there

542
00:24:09,419 --> 00:24:12,539
is no way for verifiers to tell that the

543
00:24:12,539 --> 00:24:14,580
Merkel opening in fact corresponds to

544
00:24:14,580 --> 00:24:16,500
the label that is there is no way to

545
00:24:16,500 --> 00:24:18,179
associate the output of the prf on a

546
00:24:18,179 --> 00:24:21,360
label with its input so the key trick

547
00:24:21,360 --> 00:24:24,000
that seamless uses is to index instead

548
00:24:24,000 --> 00:24:26,340
with the vrf with a vrf replied to label

549
00:24:26,340 --> 00:24:27,919
or a verifiable random function

550
00:24:27,919 --> 00:24:31,620
intuitively vrf is just a prf where you

551
00:24:31,620 --> 00:24:33,000
can prove that an output corresponds

552
00:24:33,000 --> 00:24:34,559
with the template

553
00:24:34,559 --> 00:24:37,260
more formally a vrf is a triplet of

554
00:24:37,260 --> 00:24:39,780
algorithms Egen query and verify where

555
00:24:39,780 --> 00:24:41,460
key gen outputs a secret key public key

556
00:24:41,460 --> 00:24:42,240
pair

557
00:24:42,240 --> 00:24:44,760
query uh takes in a secret key and some

558
00:24:44,760 --> 00:24:46,500
input and gives an output and a proof Pi

559
00:24:46,500 --> 00:24:48,000
here I'm going to call the output of the

560
00:24:48,000 --> 00:24:50,039
vrf the Box containing X for visual

561
00:24:50,039 --> 00:24:51,299
reasons

562
00:24:51,299 --> 00:24:53,700
and finally uh verify we'll take in the

563
00:24:53,700 --> 00:24:55,679
public key and then put an output and a

564
00:24:55,679 --> 00:24:58,140
proof and output 0 1. to security

565
00:24:58,140 --> 00:25:00,059
properties we require are uniqueness

566
00:25:00,059 --> 00:25:02,159
that verify should output one if and

567
00:25:02,159 --> 00:25:04,919
only if Y is in fact the Box containing

568
00:25:04,919 --> 00:25:07,260
X and pseudor Randomness that is the Box

569
00:25:07,260 --> 00:25:09,179
containing X should look random as long

570
00:25:09,179 --> 00:25:11,100
as the secret key is not revealed note

571
00:25:11,100 --> 00:25:12,539
that pseudoranomis should still hold

572
00:25:12,539 --> 00:25:14,880
even if query proofs or some other

573
00:25:14,880 --> 00:25:16,820
inputs are given

574
00:25:16,820 --> 00:25:20,520
so to add key rotation onto seamless we

575
00:25:20,520 --> 00:25:21,780
are going to do the simplest possible

576
00:25:21,780 --> 00:25:24,960
thing which is we will come up with a

577
00:25:24,960 --> 00:25:26,640
new secret key in public key and

578
00:25:26,640 --> 00:25:28,140
completely rebuild the Merkle tree from

579
00:25:28,140 --> 00:25:29,220
scratch

580
00:25:29,220 --> 00:25:31,380
uh this works since new label value

581
00:25:31,380 --> 00:25:32,820
pairs are going to be under some new

582
00:25:32,820 --> 00:25:35,400
really new secret public key pair

583
00:25:35,400 --> 00:25:37,679
um but it remains to be shown to prove

584
00:25:37,679 --> 00:25:39,179
that this rotation is done consistently

585
00:25:39,179 --> 00:25:40,740
without revealing information about the

586
00:25:40,740 --> 00:25:42,600
database

587
00:25:42,600 --> 00:25:45,000
uh what this boils down to is that we

588
00:25:45,000 --> 00:25:47,700
have two sets of vrf outputs and we need

589
00:25:47,700 --> 00:25:49,380
some way to prove that they come from

590
00:25:49,380 --> 00:25:51,240
the same set of inputs

591
00:25:51,240 --> 00:25:54,059
uh and so to do this what we do is we

592
00:25:54,059 --> 00:25:55,559
Define a new primitive called a

593
00:25:55,559 --> 00:25:58,320
rotatable vrs uh which will have this

594
00:25:58,320 --> 00:25:59,760
property that you can produce these

595
00:25:59,760 --> 00:26:01,440
rotation proofs and we'll show how to

596
00:26:01,440 --> 00:26:03,000
construct it

597
00:26:03,000 --> 00:26:05,520
uh more formally a rotatable vrs will be

598
00:26:05,520 --> 00:26:07,200
a vrf with two additional algorithms

599
00:26:07,200 --> 00:26:10,020
rotate and verotate rotate we'll take in

600
00:26:10,020 --> 00:26:12,120
a secret key as well as some set of

601
00:26:12,120 --> 00:26:14,400
inputs uh produce a new secret key

602
00:26:14,400 --> 00:26:17,100
public key pair as well as a proof of

603
00:26:17,100 --> 00:26:18,120
rotation

604
00:26:18,120 --> 00:26:20,760
and verote we'll take in two public keys

605
00:26:20,760 --> 00:26:22,500
and two sets of outputs under the

606
00:26:22,500 --> 00:26:24,299
corresponding public keys and output 0

607
00:26:24,299 --> 00:26:25,860
or 1.

608
00:26:25,860 --> 00:26:28,860
uh intuitively we want verito to succeed

609
00:26:28,860 --> 00:26:31,919
if and only if for each eye a y i in

610
00:26:31,919 --> 00:26:33,900
response to say the blue box containing

611
00:26:33,900 --> 00:26:36,840
x i and y i Prime corresponds to the

612
00:26:36,840 --> 00:26:38,760
green box containing x i

613
00:26:38,760 --> 00:26:40,679
uh and also we want to model post

614
00:26:40,679 --> 00:26:43,320
compromise security uh that is the green

615
00:26:43,320 --> 00:26:45,240
box contain ax should be pseudorandom

616
00:26:45,240 --> 00:26:49,279
even given the old secret key

617
00:26:49,740 --> 00:26:51,779
um to model more formally our security

618
00:26:51,779 --> 00:26:53,940
we're going to strengthen the security

619
00:26:53,940 --> 00:26:56,159
of the underlying vrs and build up on

620
00:26:56,159 --> 00:26:57,960
top of that just because the stronger

621
00:26:57,960 --> 00:26:59,820
security requirements on vref will make

622
00:26:59,820 --> 00:27:02,039
it easier to add more complicated

623
00:27:02,039 --> 00:27:04,020
definitions or more advanced definitions

624
00:27:04,020 --> 00:27:06,059
uh we're going to strengthen uniqueness

625
00:27:06,059 --> 00:27:07,559
and extractability condition which I

626
00:27:07,559 --> 00:27:09,539
will not talk in detail about here

627
00:27:09,539 --> 00:27:11,039
and we're also going to strengthen the

628
00:27:11,039 --> 00:27:13,320
pseudorandoms requirement for vs do a

629
00:27:13,320 --> 00:27:15,240
zero knowledge condition that is the

630
00:27:15,240 --> 00:27:17,659
proofs for the vrf should be simulatable

631
00:27:17,659 --> 00:27:20,940
uh even if the output of the vrf is

632
00:27:20,940 --> 00:27:22,260
replaced with the output of a truly

633
00:27:22,260 --> 00:27:23,940
random function

634
00:27:23,940 --> 00:27:26,100
then to Define rotatable vrf security

635
00:27:26,100 --> 00:27:28,620
we're just going to combine this post

636
00:27:28,620 --> 00:27:31,020
compromised security property into the

637
00:27:31,020 --> 00:27:33,360
zero knowledge requirement

638
00:27:33,360 --> 00:27:35,700
more formally we're going to model zero

639
00:27:35,700 --> 00:27:38,880
knowledge as a different as the idea

640
00:27:38,880 --> 00:27:41,100
that a real and ideal game are

641
00:27:41,100 --> 00:27:43,200
indistinguishable and in the real world

642
00:27:43,200 --> 00:27:45,240
we can imagine some Alice interacting

643
00:27:45,240 --> 00:27:47,640
with a server hosting a vrf as follows

644
00:27:47,640 --> 00:27:49,799
Alice will receive a public key at the

645
00:27:49,799 --> 00:27:51,900
beginning and can make any number of

646
00:27:51,900 --> 00:27:54,720
queries to the vrf Alice may ask also

647
00:27:54,720 --> 00:27:57,120
that the server prove that some correct

648
00:27:57,120 --> 00:27:59,100
input output pairs of the Vera are in

649
00:27:59,100 --> 00:28:01,860
fact correct and may ask for rotation

650
00:28:01,860 --> 00:28:04,860
proofs where Alice will pass in some set

651
00:28:04,860 --> 00:28:07,200
of inputs and the server will provide

652
00:28:07,200 --> 00:28:09,240
the new public key as well as a proof

653
00:28:09,240 --> 00:28:11,760
that the rotation was correct

654
00:28:11,760 --> 00:28:13,440
um note that implicitly the server will

655
00:28:13,440 --> 00:28:16,320
also receive the vrf outputs on both the

656
00:28:16,320 --> 00:28:18,480
old public key and the new public key

657
00:28:18,480 --> 00:28:20,279
and finally to model post compromise

658
00:28:20,279 --> 00:28:21,960
Security will allow us to make

659
00:28:21,960 --> 00:28:23,940
corruption queries which will return the

660
00:28:23,940 --> 00:28:26,940
old see we'll return the currency

661
00:28:26,940 --> 00:28:29,520
uh in addition we also uh model some

662
00:28:29,520 --> 00:28:31,320
idealized object or perhaps a random

663
00:28:31,320 --> 00:28:33,659
Oracle or near a group and we'll allow

664
00:28:33,659 --> 00:28:35,400
us to make queries to the idealized

665
00:28:35,400 --> 00:28:36,360
option

666
00:28:36,360 --> 00:28:38,640
uh to Define zero knowledge um zero

667
00:28:38,640 --> 00:28:40,799
knowledge will state that this world is

668
00:28:40,799 --> 00:28:42,360
indistinguishable from the world where

669
00:28:42,360 --> 00:28:43,740
all these oracles are replaced with the

670
00:28:43,740 --> 00:28:46,799
simulator even when the vrf outputs are

671
00:28:46,799 --> 00:28:48,480
all replaced with the outputs of a truly

672
00:28:48,480 --> 00:28:50,400
random function indexed by the public

673
00:28:50,400 --> 00:28:51,419
key

674
00:28:51,419 --> 00:28:54,059
uh note that to model that rotate proofs

675
00:28:54,059 --> 00:28:56,880
uh do not reveal anything about the

676
00:28:56,880 --> 00:28:59,520
inputs uh we require that the rotate

677
00:28:59,520 --> 00:29:01,980
proofs be simulatable only given the vrf

678
00:29:01,980 --> 00:29:03,539
outputs under both the old new and old

679
00:29:03,539 --> 00:29:05,279
public keys

680
00:29:05,279 --> 00:29:07,020
uh to make this possible the simulator

681
00:29:07,020 --> 00:29:09,360
has three capabilities first it can

682
00:29:09,360 --> 00:29:11,039
control the initialization of the public

683
00:29:11,039 --> 00:29:11,820
key

684
00:29:11,820 --> 00:29:14,100
it has full control over the idealized

685
00:29:14,100 --> 00:29:15,659
object that is it can program the random

686
00:29:15,659 --> 00:29:18,179
Oracle and finally whenever a corrupt

687
00:29:18,179 --> 00:29:20,399
query is made the simulator will gain

688
00:29:20,399 --> 00:29:22,740
access to all queries made to the random

689
00:29:22,740 --> 00:29:23,580
function

690
00:29:23,580 --> 00:29:26,159
uh this is to model the idea that once

691
00:29:26,159 --> 00:29:28,260
the secret key is revealed the viewf

692
00:29:28,260 --> 00:29:31,440
should no longer be pseudo-random

693
00:29:31,440 --> 00:29:33,480
uh before I get to our construction I'll

694
00:29:33,480 --> 00:29:36,000
give a brief preliminary on ddh doubles

695
00:29:36,000 --> 00:29:38,760
a ddh tuple is a four Tuple of group

696
00:29:38,760 --> 00:29:41,940
elements GH G to the ahda where the last

697
00:29:41,940 --> 00:29:43,380
two elements are the first two elements

698
00:29:43,380 --> 00:29:45,059
raised to the same exponent

699
00:29:45,059 --> 00:29:48,299
uh Tom Peterson in 93 show how to give a

700
00:29:48,299 --> 00:29:49,799
zero knowledge proof that a given Tuple

701
00:29:49,799 --> 00:29:51,659
is a ddh tuple and this can be made

702
00:29:51,659 --> 00:29:53,100
non-interactive with the CIA Shamir

703
00:29:53,100 --> 00:29:55,459
transform

704
00:29:55,620 --> 00:29:57,659
um our construction for rotatable vrfs

705
00:29:57,659 --> 00:29:59,159
will be based on a standardized

706
00:29:59,159 --> 00:30:01,919
construction of vrs push forward by both

707
00:30:01,919 --> 00:30:04,679
seamless and nist this is an efficient

708
00:30:04,679 --> 00:30:07,140
uh and simple construction and our

709
00:30:07,140 --> 00:30:09,179
addition will be also simple so this

710
00:30:09,179 --> 00:30:12,659
really is useful for practical purposes

711
00:30:12,659 --> 00:30:13,320
um

712
00:30:13,320 --> 00:30:14,960
in this simple standardized construction

713
00:30:14,960 --> 00:30:17,520
uh there will be a random Oracle F from

714
00:30:17,520 --> 00:30:19,620
the message space to some group as well

715
00:30:19,620 --> 00:30:21,840
as a group generator little G

716
00:30:21,840 --> 00:30:23,340
and how the construction will work is

717
00:30:23,340 --> 00:30:25,260
that Keygen will sample you secret key

718
00:30:25,260 --> 00:30:27,120
uniformly at random and the public key

719
00:30:27,120 --> 00:30:28,620
will be equal to G raised to the power

720
00:30:28,620 --> 00:30:29,940
of the C

721
00:30:29,940 --> 00:30:32,820
then the vrf output on some input X will

722
00:30:32,820 --> 00:30:34,860
be the random Oracle applied text raised

723
00:30:34,860 --> 00:30:37,200
to the power of the secret

724
00:30:37,200 --> 00:30:39,059
to give a query proof to give a proof

725
00:30:39,059 --> 00:30:40,380
that some given output corresponds to

726
00:30:40,380 --> 00:30:42,779
its input all that will be necessary is

727
00:30:42,779 --> 00:30:45,600
to give a proof that g f of x p k y is a

728
00:30:45,600 --> 00:30:46,919
ddh double

729
00:30:46,919 --> 00:30:49,080
why does this work well if this is a ddh

730
00:30:49,080 --> 00:30:51,179
tuple and the public key is equal to T

731
00:30:51,179 --> 00:30:53,039
to the secret key then that definitely

732
00:30:53,039 --> 00:30:55,559
means that the output y will be equal to

733
00:30:55,559 --> 00:30:57,779
f of x to the s k which is exactly the

734
00:30:57,779 --> 00:30:59,880
same as saying that Y is the vrf applied

735
00:30:59,880 --> 00:31:02,179
to X

736
00:31:02,820 --> 00:31:05,159
um this is satisfies all of your uh

737
00:31:05,159 --> 00:31:07,080
requirements and is satisfies both

738
00:31:07,080 --> 00:31:08,460
uniqueness and pseudo Randomness and it

739
00:31:08,460 --> 00:31:10,559
works totally

740
00:31:10,559 --> 00:31:12,960
to add on to this we then Define uh the

741
00:31:12,960 --> 00:31:16,260
rotate algorithm uh to Simply sample the

742
00:31:16,260 --> 00:31:17,880
new secret key in public key uniformly

743
00:31:17,880 --> 00:31:19,679
at random that is the secret key will be

744
00:31:19,679 --> 00:31:20,880
sampled uniformly at random and the

745
00:31:20,880 --> 00:31:22,260
public key will be accepted to the SK

746
00:31:22,260 --> 00:31:24,000
just as before

747
00:31:24,000 --> 00:31:27,059
we will model this for purposes of the

748
00:31:27,059 --> 00:31:28,200
proof

749
00:31:28,200 --> 00:31:30,600
um by saying that the new secret key

750
00:31:30,600 --> 00:31:33,360
will be the old secret key to times some

751
00:31:33,360 --> 00:31:36,000
randomized exponent a uh and the reason

752
00:31:36,000 --> 00:31:37,620
that this is nice is because this means

753
00:31:37,620 --> 00:31:39,480
that the new public key will be equal to

754
00:31:39,480 --> 00:31:42,059
the old public key raised to the a oh

755
00:31:42,059 --> 00:31:43,559
but this is exactly the same as just

756
00:31:43,559 --> 00:31:44,940
sampling the secret key uniformly at

757
00:31:44,940 --> 00:31:46,679
random

758
00:31:46,679 --> 00:31:49,140
then to provide a rotate proof all that

759
00:31:49,140 --> 00:31:50,760
we do is provide a proof that the public

760
00:31:50,760 --> 00:31:52,980
key uh as well as the first output and

761
00:31:52,980 --> 00:31:54,179
the second public key and the second

762
00:31:54,179 --> 00:31:57,120
output is a ddh tuple and why does this

763
00:31:57,120 --> 00:32:00,240
work well if the first output is the

764
00:32:00,240 --> 00:32:02,039
output of the vrf under the first secret

765
00:32:02,039 --> 00:32:04,559
key that is if y equals f of x the s k

766
00:32:04,559 --> 00:32:06,659
uh and just the second public key is the

767
00:32:06,659 --> 00:32:08,520
first public erase the a the DK Prime

768
00:32:08,520 --> 00:32:10,559
equals DK to the a then that means that

769
00:32:10,559 --> 00:32:13,320
y Prime must be y to the a which is the

770
00:32:13,320 --> 00:32:15,299
same thing as the random Oracle raise

771
00:32:15,299 --> 00:32:18,120
the secret key times x but since the new

772
00:32:18,120 --> 00:32:19,980
secret key is the old secret key times a

773
00:32:19,980 --> 00:32:21,659
this is exactly the same as saying that

774
00:32:21,659 --> 00:32:24,419
y Prime is the vrf apply to X under the

775
00:32:24,419 --> 00:32:27,020
new secret key

776
00:32:27,120 --> 00:32:29,039
and ignoring rotations under the ddh

777
00:32:29,039 --> 00:32:30,299
assumption and programmable random

778
00:32:30,299 --> 00:32:31,679
Oracle model

779
00:32:31,679 --> 00:32:33,539
um this vrf is zero knowledge that's by

780
00:32:33,539 --> 00:32:35,100
zero knowledge

781
00:32:35,100 --> 00:32:37,860
um and the idea behind this proof uh is

782
00:32:37,860 --> 00:32:39,779
that you can program the random Oracle

783
00:32:39,779 --> 00:32:43,380
so that the randomized output Y is

784
00:32:43,380 --> 00:32:45,779
equals f of x to the S10 so once we know

785
00:32:45,779 --> 00:32:47,159
the randomized output and the secret key

786
00:32:47,159 --> 00:32:49,440
we can choose f of x so that this all

787
00:32:49,440 --> 00:32:51,799
works out

788
00:32:51,960 --> 00:32:53,880
um but the problem is that this proof

789
00:32:53,880 --> 00:32:55,860
approach no longer works once we bring

790
00:32:55,860 --> 00:32:57,120
in rotations

791
00:32:57,120 --> 00:32:58,980
and the reason for this is that if we

792
00:32:58,980 --> 00:33:01,200
say publish to public Keys PK and PK

793
00:33:01,200 --> 00:33:01,980
Prime

794
00:33:01,980 --> 00:33:03,600
we are going to informationally

795
00:33:03,600 --> 00:33:06,299
theoretically commit to two secrets

796
00:33:06,299 --> 00:33:08,340
then after we publish these public Keys

797
00:33:08,340 --> 00:33:12,000
we may get some input x queried to the

798
00:33:12,000 --> 00:33:14,340
random function and so we'll get some

799
00:33:14,340 --> 00:33:16,980
uniformly at random chosen Y and Y Prime

800
00:33:16,980 --> 00:33:19,740
and we're going to need f of x to

801
00:33:19,740 --> 00:33:21,779
satisfy both the equation f of x to the

802
00:33:21,779 --> 00:33:24,059
s k equals y and f of x the s k Prime

803
00:33:24,059 --> 00:33:25,380
equals y Prime

804
00:33:25,380 --> 00:33:26,760
since the public key information

805
00:33:26,760 --> 00:33:29,059
theoretically commits the secret key

806
00:33:29,059 --> 00:33:31,860
and X is going to be chosen after the

807
00:33:31,860 --> 00:33:34,380
public keys are chosen these equations

808
00:33:34,380 --> 00:33:37,440
may be impossible to satisfy uh just by

809
00:33:37,440 --> 00:33:39,480
programming the random Oracle so what

810
00:33:39,480 --> 00:33:40,980
does this mean this means that the proof

811
00:33:40,980 --> 00:33:43,019
approach for the standardized vrf does

812
00:33:43,019 --> 00:33:45,000
not apply when we're dealing with

813
00:33:45,000 --> 00:33:46,980
rotations but that doesn't necessarily

814
00:33:46,980 --> 00:33:49,260
mean at least set in time and we tried

815
00:33:49,260 --> 00:33:51,539
for a bit and we could not find anything

816
00:33:51,539 --> 00:33:54,480
uh so what we managed to do is we show

817
00:33:54,480 --> 00:33:57,179
that this uh rotatable verif is in fact

818
00:33:57,179 --> 00:33:58,380
zero knowledge under a stronger

819
00:33:58,380 --> 00:34:00,480
idealized model namely generic group

820
00:34:00,480 --> 00:34:01,380
model

821
00:34:01,380 --> 00:34:03,179
uh and Chief's generic crew model our

822
00:34:03,179 --> 00:34:04,919
policies are given access to a random

823
00:34:04,919 --> 00:34:06,960
Oracle exp modeling group exponentiation

824
00:34:06,960 --> 00:34:09,960
as well as an addition Oracle star which

825
00:34:09,960 --> 00:34:12,540
takes uh two outputs of the EXP Oracle

826
00:34:12,540 --> 00:34:16,020
and multiplies them uh as if it were

827
00:34:16,020 --> 00:34:18,659
actually group exponentiation

828
00:34:18,659 --> 00:34:21,899
uh importantly we allow our simulator to

829
00:34:21,899 --> 00:34:23,639
program the generic group just as it

830
00:34:23,639 --> 00:34:26,280
could a random Oracle

831
00:34:26,280 --> 00:34:28,260
uh the key trick is that in the generic

832
00:34:28,260 --> 00:34:30,119
group model giving out the public key

833
00:34:30,119 --> 00:34:31,679
does not necessarily commit to its

834
00:34:31,679 --> 00:34:32,760
discrete block

835
00:34:32,760 --> 00:34:34,560
that is we don't need to Define discrete

836
00:34:34,560 --> 00:34:36,300
logs until a corruption happens

837
00:34:36,300 --> 00:34:38,399
and as when a corruption happens all

838
00:34:38,399 --> 00:34:40,918
queries are revealed uh to the simulator

839
00:34:40,918 --> 00:34:43,020
this means that we can choose the secret

840
00:34:43,020 --> 00:34:45,960
keys after we choose after we find out

841
00:34:45,960 --> 00:34:49,320
the uniformly random Y and Y plan

842
00:34:49,320 --> 00:34:51,418
uh now I'll go through a little bit more

843
00:34:51,418 --> 00:34:53,639
formally what exactly the simulator do

844
00:34:53,639 --> 00:34:56,820
when keeping track of the generic group

845
00:34:56,820 --> 00:34:59,160
uh so we can think of this exp Oracle as

846
00:34:59,160 --> 00:35:00,720
really a table of group elements in

847
00:35:00,720 --> 00:35:02,460
discrete logs where each group element

848
00:35:02,460 --> 00:35:05,820
query corresponds to some value tracked

849
00:35:05,820 --> 00:35:09,560
by the distinguisher Alice

850
00:35:10,200 --> 00:35:12,180
um so what our simulator do the key

851
00:35:12,180 --> 00:35:14,520
trick is that we'll replace the discrete

852
00:35:14,520 --> 00:35:16,980
logs um with a uniformly random number

853
00:35:16,980 --> 00:35:19,619
with polynomials and some special uh

854
00:35:19,619 --> 00:35:21,599
variables and in particular discrete

855
00:35:21,599 --> 00:35:24,359
logs um will be stored this way for

856
00:35:24,359 --> 00:35:26,040
group elements that do not come from the

857
00:35:26,040 --> 00:35:28,140
EXP Oracle like the output of the random

858
00:35:28,140 --> 00:35:31,440
Oracle and the public Keys themselves

859
00:35:31,440 --> 00:35:33,599
um so the variables uh that we will use

860
00:35:33,599 --> 00:35:35,760
is we will set that the output of the

861
00:35:35,760 --> 00:35:37,320
random Oracle will always have discrete

862
00:35:37,320 --> 00:35:39,300
log of variable corresponding to its

863
00:35:39,300 --> 00:35:41,700
input that is the output of the random

864
00:35:41,700 --> 00:35:42,780
Oracle f of x the group element

865
00:35:42,780 --> 00:35:44,220
corresponding to that we'll have

866
00:35:44,220 --> 00:35:47,460
discrete log a variable B of x

867
00:35:47,460 --> 00:35:49,260
and similarly we will create new

868
00:35:49,260 --> 00:35:51,000
variables for each of the A's from the

869
00:35:51,000 --> 00:35:54,599
rotation proofs and in particular pki

870
00:35:54,599 --> 00:35:57,780
will have discrete log the product of A1

871
00:35:57,780 --> 00:36:00,119
through AI

872
00:36:00,119 --> 00:36:03,180
then once we have set the public keys

873
00:36:03,180 --> 00:36:04,980
and random oracles to have these

874
00:36:04,980 --> 00:36:07,140
discrete logs we can make sure that the

875
00:36:07,140 --> 00:36:10,020
output of the CRF has corresponding

876
00:36:10,020 --> 00:36:12,540
discrete logs that is the output of the

877
00:36:12,540 --> 00:36:14,280
vrf under some public key and some input

878
00:36:14,280 --> 00:36:16,560
should be equal should have discrete log

879
00:36:16,560 --> 00:36:19,140
equal to the product of the discrete log

880
00:36:19,140 --> 00:36:20,760
of the public key and the discrete log

881
00:36:20,760 --> 00:36:24,420
of the random Oracle of that input

882
00:36:24,420 --> 00:36:26,900
we can then Define all other addition

883
00:36:26,900 --> 00:36:29,820
queries made by distinguisher to be

884
00:36:29,820 --> 00:36:31,920
consistent with what we set the discrete

885
00:36:31,920 --> 00:36:35,240
logs to be for these other variables

886
00:36:35,760 --> 00:36:38,760
then when a corrupt query is made we

887
00:36:38,760 --> 00:36:40,500
will simply replace each of these AIS

888
00:36:40,500 --> 00:36:42,960
with a unit value chosen uniformly at

889
00:36:42,960 --> 00:36:44,040
random

890
00:36:44,040 --> 00:36:46,680
uh and this and then we will return that

891
00:36:46,680 --> 00:36:48,780
the secret key that has been corrupted

892
00:36:48,780 --> 00:36:50,640
will just be the discrete log of the

893
00:36:50,640 --> 00:36:52,260
current public key

894
00:36:52,260 --> 00:36:54,599
and what this guarantees is that the

895
00:36:54,599 --> 00:36:56,880
viewer that the output y um that is

896
00:36:56,880 --> 00:36:58,920
supposed to correspond to vrf of the

897
00:36:58,920 --> 00:37:01,260
secret key on X will be equal to f of x

898
00:37:01,260 --> 00:37:04,500
to the SK for all SK and X

899
00:37:04,500 --> 00:37:07,200
the key idea here is that

900
00:37:07,200 --> 00:37:10,380
um the degree of these polynomials only

901
00:37:10,380 --> 00:37:12,119
increases on rotation

902
00:37:12,119 --> 00:37:14,280
and since the only issue that could

903
00:37:14,280 --> 00:37:17,220
occur really is that um

904
00:37:17,220 --> 00:37:19,380
sampling these AIS induces the Collision

905
00:37:19,380 --> 00:37:21,480
on the polynomials and since the

906
00:37:21,480 --> 00:37:24,180
polynomials are have found a degree the

907
00:37:24,180 --> 00:37:27,540
schwarzipalama tells us that a collision

908
00:37:27,540 --> 00:37:28,859
will happen with negligible probability

909
00:37:28,859 --> 00:37:32,299
and so this works

910
00:37:32,579 --> 00:37:34,560
um so in conclusion uh using this

911
00:37:34,560 --> 00:37:36,540
generic group model uh polynomial

912
00:37:36,540 --> 00:37:38,339
programming Technique we show that

913
00:37:38,339 --> 00:37:41,339
rotatable vrfs satisfy zero knowledge a

914
00:37:41,339 --> 00:37:42,839
rotatable vrs then give us Post

915
00:37:42,839 --> 00:37:44,460
compromise secure auditable dictionaries

916
00:37:44,460 --> 00:37:47,099
in particular RZ chaos as we Define it

917
00:37:47,099 --> 00:37:48,839
there are many additional subtleties and

918
00:37:48,839 --> 00:37:50,880
small improvements in both parts so for

919
00:37:50,880 --> 00:37:53,220
more details read our paper feel free to

920
00:37:53,220 --> 00:37:54,839
come talk to me afterwards

921
00:37:54,839 --> 00:37:57,380
thank you

922
00:38:04,740 --> 00:38:07,160
questions

923
00:38:22,740 --> 00:38:25,020
hey uh have you thought about like uh

924
00:38:25,020 --> 00:38:27,240
how this would work for pairing based

925
00:38:27,240 --> 00:38:28,680
prf

926
00:38:28,680 --> 00:38:30,380
starting base

927
00:38:30,380 --> 00:38:32,820
stir UPS um kind of use the same

928
00:38:32,820 --> 00:38:34,560
construction as a VR after the pairing

929
00:38:34,560 --> 00:38:36,900
group and then you know kind of verify

930
00:38:36,900 --> 00:38:38,460
with the pairing

931
00:38:38,460 --> 00:38:40,020
I have not thought about it at all but

932
00:38:40,020 --> 00:38:41,700
come talk to me afterwards and you can

933
00:38:41,700 --> 00:38:44,480
discuss yeah

934
00:38:53,760 --> 00:38:57,980
okay then let's thank the speaker again

935
00:39:02,940 --> 00:39:05,280
okay the final thought in this session

936
00:39:05,280 --> 00:39:08,660
is uh buy online

937
00:39:14,040 --> 00:39:16,520
foreign

938
00:39:23,480 --> 00:39:27,540
protocol for relations in CNF the

939
00:39:27,540 --> 00:39:30,500
speaker is gonji and then

940
00:39:30,500 --> 00:39:33,300
okay are you ready

941
00:39:33,300 --> 00:39:35,640
yeah I'm really can hear me please

942
00:39:35,640 --> 00:39:38,520
proceed yes we can hear

943
00:39:38,520 --> 00:39:42,800
okay there's an alarming started

944
00:39:43,380 --> 00:39:46,560
uh thank you for attending this talk at

945
00:39:46,560 --> 00:39:50,099
least today I would like to

946
00:39:50,099 --> 00:39:52,980
I would like to present my paper dng

947
00:39:52,980 --> 00:39:54,000
Sigma

948
00:39:54,000 --> 00:39:56,760
a deity based stigma protocol for

949
00:39:56,760 --> 00:40:00,000
relations in CF other co-authors are

950
00:40:00,000 --> 00:40:01,320
General light

951
00:40:01,320 --> 00:40:04,419
[Music]

952
00:40:05,640 --> 00:40:07,380
the presentation will count the

953
00:40:07,380 --> 00:40:09,900
following aspects the background and the

954
00:40:09,900 --> 00:40:11,040
motivation

955
00:40:11,040 --> 00:40:13,440
then the contributions of this paper

956
00:40:13,440 --> 00:40:15,900
after that I will introduce the main

957
00:40:15,900 --> 00:40:18,599
idea of the construction

958
00:40:18,599 --> 00:40:21,119
so let me introduce the backgrounds and

959
00:40:21,119 --> 00:40:23,099
show you what problem we have studied

960
00:40:23,099 --> 00:40:26,180
and why we studied

961
00:40:26,339 --> 00:40:28,500
Sigma Protocols are popular and widely

962
00:40:28,500 --> 00:40:30,420
used as a building block in many

963
00:40:30,420 --> 00:40:32,640
cryptographic protocols

964
00:40:32,640 --> 00:40:34,980
given a binary and the polynomial time

965
00:40:34,980 --> 00:40:38,640
relation and an instance X Y belonging

966
00:40:38,640 --> 00:40:41,579
to R the sigma protocol is run between

967
00:40:41,579 --> 00:40:45,060
the proof and the verify in three steps

968
00:40:45,060 --> 00:40:48,240
a commitment a challenge and a response

969
00:40:48,240 --> 00:40:51,180
are sent intent by the approval and the

970
00:40:51,180 --> 00:40:54,000
verifier where the challenge is randomly

971
00:40:54,000 --> 00:40:56,460
picked by the verifier

972
00:40:56,460 --> 00:40:59,220
finally the verify checks whether the

973
00:40:59,220 --> 00:41:02,839
transcript is valid or not

974
00:41:02,880 --> 00:41:04,980
Sigma protocols have been designed to

975
00:41:04,980 --> 00:41:07,320
prove kinds of relations among these

976
00:41:07,320 --> 00:41:09,839
relations K Auto and partial knowledge

977
00:41:09,839 --> 00:41:11,820
is well studied

978
00:41:11,820 --> 00:41:15,839
as early as 1994 Karama dang and the

979
00:41:15,839 --> 00:41:18,599
Shoemaker showed a general method in

980
00:41:18,599 --> 00:41:21,720
2015 gross and the covenants show how to

981
00:41:21,720 --> 00:41:24,119
achieve local Mystic communication when

982
00:41:24,119 --> 00:41:26,099
k equals 1

983
00:41:26,099 --> 00:41:28,980
very recently a 10 gram and fair

984
00:41:28,980 --> 00:41:30,960
achieved local domestic communication

985
00:41:30,960 --> 00:41:34,380
for General K and N in the discrete log

986
00:41:34,380 --> 00:41:36,540
region setting

987
00:41:36,540 --> 00:41:39,300
a relation about K Auto and passion

988
00:41:39,300 --> 00:41:41,700
knowledge can be expressed in this jump

989
00:41:41,700 --> 00:41:43,800
to normal formula and we call it

990
00:41:43,800 --> 00:41:47,700
complete kdlf relations since the number

991
00:41:47,700 --> 00:41:50,760
of the crosses is a binomial coefficient

992
00:41:50,760 --> 00:41:53,520
Kom

993
00:41:53,520 --> 00:41:57,060
it's natural to consider some extensions

994
00:41:57,060 --> 00:41:59,820
the first one is to reduce the number of

995
00:41:59,820 --> 00:42:03,060
Clauses and we call such relations in

996
00:42:03,060 --> 00:42:05,940
complete kdnf relations

997
00:42:05,940 --> 00:42:08,520
the second one is to reverse the symbol

998
00:42:08,520 --> 00:42:12,119
or logic end and logic or and then we

999
00:42:12,119 --> 00:42:14,339
get a relation in conjunction normal

1000
00:42:14,339 --> 00:42:17,760
formula so because such relations K C

1001
00:42:17,760 --> 00:42:19,380
and F relations

1002
00:42:19,380 --> 00:42:22,619
our paper may be focuses on KCF

1003
00:42:22,619 --> 00:42:24,780
relations in the discrete logarithm

1004
00:42:24,780 --> 00:42:27,119
setting

1005
00:42:27,119 --> 00:42:30,300
relations expressed in CNF are an

1006
00:42:30,300 --> 00:42:32,460
important correction of relations in

1007
00:42:32,460 --> 00:42:35,579
practice for example many Access Control

1008
00:42:35,579 --> 00:42:38,820
policies are naturally set in CNF and

1009
00:42:38,820 --> 00:42:41,160
they have been discussed in some AB

1010
00:42:41,160 --> 00:42:42,359
skins

1011
00:42:42,359 --> 00:42:44,640
in addition the instance of the case

1012
00:42:44,640 --> 00:42:47,400
site program expressed in CNF

1013
00:42:47,400 --> 00:42:50,040
we also provide a potential application

1014
00:42:50,040 --> 00:42:51,000
here

1015
00:42:51,000 --> 00:42:52,160
a

1016
00:42:52,160 --> 00:42:55,440
startup company wants to shoot investors

1017
00:42:55,440 --> 00:42:57,720
a business plan which is about building

1018
00:42:57,720 --> 00:43:00,119
at least a shopping mall in every key

1019
00:43:00,119 --> 00:43:01,740
neighboring blocks

1020
00:43:01,740 --> 00:43:04,200
the startup company also wants to show

1021
00:43:04,200 --> 00:43:06,480
it in a general knowledge way in order

1022
00:43:06,480 --> 00:43:08,940
to avoid the exact business load map

1023
00:43:08,940 --> 00:43:11,819
being leaked you can find the relation

1024
00:43:11,819 --> 00:43:14,880
is also in CNF

1025
00:43:14,880 --> 00:43:17,520
to the best of our knowledge we find the

1026
00:43:17,520 --> 00:43:19,619
following schemes working for KCF

1027
00:43:19,619 --> 00:43:20,700
relations

1028
00:43:20,700 --> 00:43:23,220
the first one is proposed by chroma

1029
00:43:23,220 --> 00:43:27,359
Adair here we call it CDs 94 however it

1030
00:43:27,359 --> 00:43:29,240
may lead to Super polynomial

1031
00:43:29,240 --> 00:43:31,740
communication costs

1032
00:43:31,740 --> 00:43:33,660
the second one is

1033
00:43:33,660 --> 00:43:36,140
the second one is a cyclicity program

1034
00:43:36,140 --> 00:43:38,579
proposed by ABR

1035
00:43:38,579 --> 00:43:41,520
but it is designed for and not an actual

1036
00:43:41,520 --> 00:43:44,460
technological and it seems impossible to

1037
00:43:44,460 --> 00:43:47,579
transfer the cyclicity program into a

1038
00:43:47,579 --> 00:43:50,700
standard Sigma protocol so it loses some

1039
00:43:50,700 --> 00:43:53,520
advantages of Sigma protocols for

1040
00:43:53,520 --> 00:43:55,800
example lowest organisms error by Design

1041
00:43:55,800 --> 00:43:59,280
high efficiency and more flexibility

1042
00:43:59,280 --> 00:44:01,859
therefore a course a question is

1043
00:44:01,859 --> 00:44:03,359
arranged naturally

1044
00:44:03,359 --> 00:44:05,880
is it possible to construct a more

1045
00:44:05,880 --> 00:44:08,099
efficient stigma protocol for KCF

1046
00:44:08,099 --> 00:44:09,060
relations

1047
00:44:09,060 --> 00:44:12,540
our paper gives an affirmative answer to

1048
00:44:12,540 --> 00:44:15,000
this question in the discrete logarithm

1049
00:44:15,000 --> 00:44:16,319
setting

1050
00:44:16,319 --> 00:44:18,300
next we are going to introduce

1051
00:44:18,300 --> 00:44:21,660
contributions on this paper

1052
00:44:21,660 --> 00:44:23,520
the contributions of this paper are

1053
00:44:23,520 --> 00:44:25,980
listed as follows first of all we

1054
00:44:25,980 --> 00:44:28,079
formally Define the partial knowledge of

1055
00:44:28,079 --> 00:44:29,760
KCF relations

1056
00:44:29,760 --> 00:44:32,460
we also propose a construction in the

1057
00:44:32,460 --> 00:44:34,440
discrete logarithm setting by

1058
00:44:34,440 --> 00:44:37,740
transferring the KCF relations to direct

1059
00:44:37,740 --> 00:44:40,380
it a cyclic graphics

1060
00:44:40,380 --> 00:44:43,560
that's why we call our method the AG

1061
00:44:43,560 --> 00:44:45,300
Sigma protocol

1062
00:44:45,300 --> 00:44:47,880
secondly we apply our dhg Sigma

1063
00:44:47,880 --> 00:44:50,940
protocols to construct similar protocols

1064
00:44:50,940 --> 00:44:54,660
for incomplete kdf relations due to the

1065
00:44:54,660 --> 00:44:56,880
time limitation we will not talk the

1066
00:44:56,880 --> 00:44:58,200
details here

1067
00:44:58,200 --> 00:45:01,380
finally we Pro we provide an

1068
00:45:01,380 --> 00:45:04,200
implementation based on elliptic curve

1069
00:45:04,200 --> 00:45:05,160
groups

1070
00:45:05,160 --> 00:45:07,859
it assures that when proving the example

1071
00:45:07,859 --> 00:45:10,260
relations in our experiments and

1072
00:45:10,260 --> 00:45:14,640
combined with cs94 the our dhg stigma

1073
00:45:14,640 --> 00:45:17,599
protocols say saves more than 95

1074
00:45:17,599 --> 00:45:20,640
communication cost and more than 90

1075
00:45:20,640 --> 00:45:23,839
percent running time

1076
00:45:24,240 --> 00:45:27,300
here is our theoretical compressor to

1077
00:45:27,300 --> 00:45:29,220
same time here I only pick the

1078
00:45:29,220 --> 00:45:32,339
conversion about KCF relations you can

1079
00:45:32,339 --> 00:45:34,680
see that the communication cost of our

1080
00:45:34,680 --> 00:45:38,220
skin is Big O and minus K element in

1081
00:45:38,220 --> 00:45:40,619
group G and the Big O absolute V

1082
00:45:40,619 --> 00:45:42,960
elements in group t p star

1083
00:45:42,960 --> 00:45:46,140
note that big red denotes the vertices

1084
00:45:46,140 --> 00:45:48,839
of the graphic in our dhg Sigma protocol

1085
00:45:48,839 --> 00:45:51,599
a discussion on upper bound of the

1086
00:45:51,599 --> 00:45:54,720
number of the vertices shows that the

1087
00:45:54,720 --> 00:45:57,480
size of our solution is smaller actually

1088
00:45:57,480 --> 00:46:01,020
is much smaller than that of CDs 94

1089
00:46:01,020 --> 00:46:04,140
which implies our skin enjoys a better

1090
00:46:04,140 --> 00:46:06,300
performance

1091
00:46:06,300 --> 00:46:09,240
here are the experimental results we

1092
00:46:09,240 --> 00:46:11,400
firstly issued experimental results when

1093
00:46:11,400 --> 00:46:15,300
k equals 4 the region the ratio shows

1094
00:46:15,300 --> 00:46:17,400
how much communication cost and the

1095
00:46:17,400 --> 00:46:19,859
running time our skin saves is clear

1096
00:46:19,859 --> 00:46:23,520
that there is a remarkable Improvement

1097
00:46:23,520 --> 00:46:25,260
list fingers are the experiment

1098
00:46:25,260 --> 00:46:27,540
experimental result about different

1099
00:46:27,540 --> 00:46:29,940
values okay according to this

1100
00:46:29,940 --> 00:46:32,579
experimental result we can draw such a

1101
00:46:32,579 --> 00:46:35,579
conclusion that when combined with CTS

1102
00:46:35,579 --> 00:46:37,980
94 our skin achieves a remarkable

1103
00:46:37,980 --> 00:46:41,160
performance Improvement on proving KCF

1104
00:46:41,160 --> 00:46:44,040
relations no matter from the view of

1105
00:46:44,040 --> 00:46:48,200
communication costs or running time

1106
00:46:48,300 --> 00:46:50,880
next let me introduce the main idea of

1107
00:46:50,880 --> 00:46:53,420
our Construction

1108
00:46:53,460 --> 00:46:56,160
here is a format definition or KCM

1109
00:46:56,160 --> 00:46:59,940
relations in short every cross contains

1110
00:46:59,940 --> 00:47:02,760
K different statements with logic or

1111
00:47:02,760 --> 00:47:06,359
then we combine these Clauses with logic

1112
00:47:06,359 --> 00:47:07,680
end

1113
00:47:07,680 --> 00:47:11,099
a valid business statement pair for such

1114
00:47:11,099 --> 00:47:14,099
relation requires that every Clause

1115
00:47:14,099 --> 00:47:17,460
contains at least a true statement

1116
00:47:17,460 --> 00:47:21,119
in other words for every cross among the

1117
00:47:21,119 --> 00:47:23,700
case statements the prover knows at

1118
00:47:23,700 --> 00:47:26,579
least one weakness of them

1119
00:47:26,579 --> 00:47:28,560
then we are going to introduce two

1120
00:47:28,560 --> 00:47:31,140
building blocks the first one is the is

1121
00:47:31,140 --> 00:47:35,040
an algorithm KCF to JG as the name

1122
00:47:35,040 --> 00:47:38,339
implies the algorithm is to transfer a

1123
00:47:38,339 --> 00:47:41,220
KCF relation to a daisy

1124
00:47:41,220 --> 00:47:43,260
there are two properties of the dag

1125
00:47:43,260 --> 00:47:46,440
output by this algorithm the properties

1126
00:47:46,440 --> 00:47:48,660
guarantees the correctness of our skin

1127
00:47:48,660 --> 00:47:53,700
firstly every node in some parts maps to

1128
00:47:53,700 --> 00:47:56,300
a statement in some corresponding Clause

1129
00:47:56,300 --> 00:47:59,520
secondly the number of passes with

1130
00:47:59,520 --> 00:48:03,119
length k equals to equals the number of

1131
00:48:03,119 --> 00:48:04,319
across

1132
00:48:04,319 --> 00:48:07,800
we take relation R1 for example it

1133
00:48:07,800 --> 00:48:11,220
contains four Clauses and each Clause

1134
00:48:11,220 --> 00:48:14,099
has three statements

1135
00:48:14,099 --> 00:48:17,819
finger 5 shows a simple idea to transfer

1136
00:48:17,819 --> 00:48:20,940
the relation R1 and you can find that

1137
00:48:20,940 --> 00:48:24,119
there are four passes and each path maps

1138
00:48:24,119 --> 00:48:27,180
to a clause in R1

1139
00:48:27,180 --> 00:48:30,720
in finger 6 we introduce three kinds of

1140
00:48:30,720 --> 00:48:33,900
states with respect to the in degree and

1141
00:48:33,900 --> 00:48:37,079
auto degree of the nose and they are

1142
00:48:37,079 --> 00:48:42,060
denoted as a b and e we can merge those

1143
00:48:42,060 --> 00:48:45,359
nodes which represent the same statement

1144
00:48:45,359 --> 00:48:49,020
and have the same state as a result is

1145
00:48:49,020 --> 00:48:52,980
clear that finger 6 contains less nodes

1146
00:48:52,980 --> 00:48:55,940
than finger five

1147
00:48:56,099 --> 00:48:58,680
but the simple operation show in finger

1148
00:48:58,680 --> 00:49:00,720
sticks cannot work for some relations

1149
00:49:00,720 --> 00:49:03,480
for example we present another relation

1150
00:49:03,480 --> 00:49:07,500
R2 combined with R1 R2 has one more

1151
00:49:07,500 --> 00:49:10,319
cross here we marked it in red

1152
00:49:10,319 --> 00:49:13,380
using the same method of finger 6 we get

1153
00:49:13,380 --> 00:49:16,680
a result in finger seven and the Clause

1154
00:49:16,680 --> 00:49:19,260
marked in red is transferred to the path

1155
00:49:19,260 --> 00:49:22,319
with dotted lines more exactly the path

1156
00:49:22,319 --> 00:49:27,180
is A4 B3 and E1

1157
00:49:27,180 --> 00:49:30,839
then you can find that lay is a Crossing

1158
00:49:30,839 --> 00:49:34,020
in finger seven more exactly there is a

1159
00:49:34,020 --> 00:49:36,300
Crossing in node B3

1160
00:49:36,300 --> 00:49:39,540
then you can find other new passes

1161
00:49:39,540 --> 00:49:44,579
for example A4 B3 and E2

1162
00:49:44,579 --> 00:49:47,700
which should maps to across Sigma 2

1163
00:49:47,700 --> 00:49:51,599
Sigma 3 and sigma 4. however we cannot

1164
00:49:51,599 --> 00:49:54,960
find such clause in relation R2

1165
00:49:54,960 --> 00:49:57,780
therefore the number of passes in finger

1166
00:49:57,780 --> 00:50:00,000
seven is not equal to the numbers or

1167
00:50:00,000 --> 00:50:02,880
Clauses or relation R2 then it's

1168
00:50:02,880 --> 00:50:05,220
contradictory to the properties we

1169
00:50:05,220 --> 00:50:06,660
mentioned before

1170
00:50:06,660 --> 00:50:10,740
a solution is shown in finger 8. more

1171
00:50:10,740 --> 00:50:14,339
exactly the node P3 is divided into two

1172
00:50:14,339 --> 00:50:17,819
nodes b31 and p32

1173
00:50:17,819 --> 00:50:21,359
the example tests us that the tig output

1174
00:50:21,359 --> 00:50:24,780
by kcf2 dag should not contain any

1175
00:50:24,780 --> 00:50:27,380
closings

1176
00:50:28,800 --> 00:50:32,460
in fact the algorithm KCF to JG is

1177
00:50:32,460 --> 00:50:35,280
simple and only contains three steps

1178
00:50:35,280 --> 00:50:39,000
preparing node merging pre-physics and

1179
00:50:39,000 --> 00:50:40,920
emerging substance

1180
00:50:40,920 --> 00:50:42,839
for the details of algorithm please

1181
00:50:42,839 --> 00:50:46,260
refer to our paper here we take the

1182
00:50:46,260 --> 00:50:49,440
relation R2 for example and show how the

1183
00:50:49,440 --> 00:50:53,160
algorithm works finger 9 shows the first

1184
00:50:53,160 --> 00:50:57,059
step more exactly for each cross in R2

1185
00:50:57,059 --> 00:51:01,319
we generate a path then in finger 10 we

1186
00:51:01,319 --> 00:51:06,180
show how we merge prefixes here note A51

1187
00:51:06,180 --> 00:51:10,440
and the node A52 emerged into one node

1188
00:51:10,440 --> 00:51:16,319
A5 similarly if node A4 1 and node a42

1189
00:51:16,319 --> 00:51:19,559
are merged into node A4

1190
00:51:19,559 --> 00:51:22,440
Finger Eleven and finger tail show how

1191
00:51:22,440 --> 00:51:27,319
to merge subsets similarly node E11

1192
00:51:27,319 --> 00:51:32,640
E12 and e13 emerge into node E1 after

1193
00:51:32,640 --> 00:51:36,780
that the surface of the node B21 and the

1194
00:51:36,780 --> 00:51:40,380
node B22 are the same in other words the

1195
00:51:40,380 --> 00:51:43,980
surfaces are not node E1 then we can

1196
00:51:43,980 --> 00:51:47,579
merge node B21 and the node B22 into

1197
00:51:47,579 --> 00:51:51,780
node B2 finally we get a dag and we can

1198
00:51:51,780 --> 00:51:54,480
check that the dag satisfies properties

1199
00:51:54,480 --> 00:51:57,020
we want

1200
00:51:57,119 --> 00:51:59,400
here is the upbound of the number of

1201
00:51:59,400 --> 00:52:00,720
vertices

1202
00:52:00,720 --> 00:52:04,680
we can know one item is the binomial

1203
00:52:04,680 --> 00:52:09,300
coefficient D divided by 2 o n

1204
00:52:09,300 --> 00:52:12,000
note that in the original expression our

1205
00:52:12,000 --> 00:52:14,579
KCF relation the number of statements

1206
00:52:14,579 --> 00:52:17,760
can be K times number where number

1207
00:52:17,760 --> 00:52:20,520
denotes the number of crosses the

1208
00:52:20,520 --> 00:52:22,980
maximum of the number is the binomial

1209
00:52:22,980 --> 00:52:26,339
coefficient K Over N therefore the

1210
00:52:26,339 --> 00:52:28,680
theory implies that our method can

1211
00:52:28,680 --> 00:52:32,579
achieve a good Improvement

1212
00:52:32,579 --> 00:52:35,819
we also provide another method to

1213
00:52:35,819 --> 00:52:37,980
analyze the upper Bound in our full

1214
00:52:37,980 --> 00:52:40,140
paper maybe it's easier for you to

1215
00:52:40,140 --> 00:52:41,280
understand

1216
00:52:41,280 --> 00:52:44,819
first we prepare two same stamp graphics

1217
00:52:44,819 --> 00:52:47,640
the dance of the passes in the sub

1218
00:52:47,640 --> 00:52:52,260
Graphics is K divided by two lists

1219
00:52:52,260 --> 00:52:55,940
and the number of the passes in each sub

1220
00:52:55,940 --> 00:52:59,700
graphy is the binomial coefficient K

1221
00:52:59,700 --> 00:53:01,800
divided by 2 of n

1222
00:53:01,800 --> 00:53:04,619
then for each cross we divide the cross

1223
00:53:04,619 --> 00:53:07,680
into two parts for each parts

1224
00:53:07,680 --> 00:53:11,700
we find the corresponding path in the

1225
00:53:11,700 --> 00:53:14,280
corresponding subgraphy and we add an

1226
00:53:14,280 --> 00:53:16,800
arrow between the two parts is

1227
00:53:16,800 --> 00:53:19,319
finally we remove those passes with

1228
00:53:19,319 --> 00:53:21,780
length K divided by two we can track

1229
00:53:21,780 --> 00:53:25,020
that the dang satisfy the properties we

1230
00:53:25,020 --> 00:53:28,260
defined before and is easier to get that

1231
00:53:28,260 --> 00:53:31,440
the number of vertices is K times the

1232
00:53:31,440 --> 00:53:34,859
binomial efficient okay divided by 2 o n

1233
00:53:34,859 --> 00:53:37,920
which is similar to the result in our

1234
00:53:37,920 --> 00:53:41,040
theorem you can find that in some cases

1235
00:53:41,040 --> 00:53:43,619
the result in our theory is a title

1236
00:53:43,619 --> 00:53:45,859
bound

1237
00:53:46,079 --> 00:53:48,540
next to introduce another building block

1238
00:53:48,540 --> 00:53:51,720
is a sigma protocol for One auto okay

1239
00:53:51,720 --> 00:53:53,819
partial knowledge in the discrete

1240
00:53:53,819 --> 00:53:56,520
logarithm the relation is shown in

1241
00:53:56,520 --> 00:54:00,180
equation 3 in short the pover knows at

1242
00:54:00,180 --> 00:54:04,559
least one discrete logarithm of them

1243
00:54:04,559 --> 00:54:08,400
then we record the chameleon mode of the

1244
00:54:08,400 --> 00:54:11,520
snow Sigma protocol note that in the

1245
00:54:11,520 --> 00:54:14,099
standard model the approval in this

1246
00:54:14,099 --> 00:54:17,640
first step picks a random number R and

1247
00:54:17,640 --> 00:54:21,059
computes the commitment using r

1248
00:54:21,059 --> 00:54:24,540
is different in the chameleon mode

1249
00:54:24,540 --> 00:54:27,660
what exactly the plural in the first

1250
00:54:27,660 --> 00:54:29,160
steps

1251
00:54:29,160 --> 00:54:32,760
caused us the simulator to generate the

1252
00:54:32,760 --> 00:54:35,640
commitment in other words besides a

1253
00:54:35,640 --> 00:54:38,339
random number are the proverb also

1254
00:54:38,339 --> 00:54:40,680
computes the commitment using another

1255
00:54:40,680 --> 00:54:44,400
random challenge C pi

1256
00:54:44,400 --> 00:54:47,040
here is our Sigma protocol for One auto

1257
00:54:47,040 --> 00:54:49,680
K partial knowledge based on Snow's

1258
00:54:49,680 --> 00:54:53,160
Sigma protocol the main idea is that for

1259
00:54:53,160 --> 00:54:56,040
each statement we compute the hash value

1260
00:54:56,040 --> 00:54:59,940
of its commitment and the hash value is

1261
00:54:59,940 --> 00:55:02,760
a challenge for the next statement such

1262
00:55:02,760 --> 00:55:05,040
that we can call the simulator to

1263
00:55:05,040 --> 00:55:07,440
generate the commitment for the next

1264
00:55:07,440 --> 00:55:08,940
statement

1265
00:55:08,940 --> 00:55:11,880
one of the advantages is that the

1266
00:55:11,880 --> 00:55:14,579
approver only needs to send one

1267
00:55:14,579 --> 00:55:17,400
commitment of the case statements to the

1268
00:55:17,400 --> 00:55:20,460
verify in other words we only need to

1269
00:55:20,460 --> 00:55:24,180
send A1 to the verifier therefore we can

1270
00:55:24,180 --> 00:55:28,339
reduce the communication cost a lot

1271
00:55:28,440 --> 00:55:31,200
finally we show our dhg Sigma protocol

1272
00:55:31,200 --> 00:55:33,599
in the discrete logarithm using the

1273
00:55:33,599 --> 00:55:36,420
about two building blocks here is the

1274
00:55:36,420 --> 00:55:38,940
KCF relation in the discrete logarithm

1275
00:55:38,940 --> 00:55:40,920
setting

1276
00:55:40,920 --> 00:55:46,079
and our TIG Sigma has two steps the

1277
00:55:46,079 --> 00:55:49,260
first step is to run the algorithm KCF

1278
00:55:49,260 --> 00:55:52,920
to Dag and get a dag

1279
00:55:52,920 --> 00:55:56,339
we can know that the dense of each path

1280
00:55:56,339 --> 00:56:00,359
in the dag is K so the second step for

1281
00:56:00,359 --> 00:56:03,720
each this kind of step is that for each

1282
00:56:03,720 --> 00:56:06,300
path in the dag we run a proving

1283
00:56:06,300 --> 00:56:09,240
algorithm which is similar to that of

1284
00:56:09,240 --> 00:56:12,960
one out of K partial knowledge

1285
00:56:12,960 --> 00:56:13,800
yeah

1286
00:56:13,800 --> 00:56:16,260
there are some differences between our

1287
00:56:16,260 --> 00:56:18,960
skin and the protocol for one other okay

1288
00:56:18,960 --> 00:56:21,720
passion knowledge in the One auto okay

1289
00:56:21,720 --> 00:56:24,119
partial knowledge the relation is

1290
00:56:24,119 --> 00:56:27,420
translated to into one pass is the

1291
00:56:27,420 --> 00:56:28,440
landscape

1292
00:56:28,440 --> 00:56:30,900
the hash function only takes one

1293
00:56:30,900 --> 00:56:33,960
commitment as input as the corresponding

1294
00:56:33,960 --> 00:56:38,339
node has only one arrow pointing to it

1295
00:56:38,339 --> 00:56:41,819
however it becomes a bit complicated in

1296
00:56:41,819 --> 00:56:43,680
the KCF relations

1297
00:56:43,680 --> 00:56:46,859
we're taking the relation R1 for example

1298
00:56:46,859 --> 00:56:51,000
and its corresponding dag issue here

1299
00:56:51,000 --> 00:56:53,640
we can find that there are two arrows

1300
00:56:53,640 --> 00:56:58,260
pointing to node B2 then using the same

1301
00:56:58,260 --> 00:57:01,079
method we can know that the challenge

1302
00:57:01,079 --> 00:57:04,619
for node B2 will be influenced by two

1303
00:57:04,619 --> 00:57:07,500
commitments in other words it will be

1304
00:57:07,500 --> 00:57:10,859
influenced by the commitment of node A3

1305
00:57:10,859 --> 00:57:12,660
and the node A4

1306
00:57:12,660 --> 00:57:16,380
so the hash function takes as input

1307
00:57:16,380 --> 00:57:21,180
the commitment of node A3 and node A4

1308
00:57:21,180 --> 00:57:23,700
finally in our paper we proved that the

1309
00:57:23,700 --> 00:57:25,500
dhg sigma protocol provides

1310
00:57:25,500 --> 00:57:28,020
computational knowledge soundness and is

1311
00:57:28,020 --> 00:57:30,000
special hvjk

1312
00:57:30,000 --> 00:57:32,760
for the communication complexity we

1313
00:57:32,760 --> 00:57:34,980
prove that it depends on the number of

1314
00:57:34,980 --> 00:57:37,619
the vertices of the Dag

1315
00:57:37,619 --> 00:57:40,319
and we show that front view of the

1316
00:57:40,319 --> 00:57:42,960
communication complexity our skin is

1317
00:57:42,960 --> 00:57:46,760
better than CDs 94.

1318
00:57:46,980 --> 00:57:49,500
here are some references of this

1319
00:57:49,500 --> 00:57:51,599
presentation

1320
00:57:51,599 --> 00:57:55,940
that's all for my presentation thank you

1321
00:58:02,400 --> 00:58:04,020
thanks for the talk

1322
00:58:04,020 --> 00:58:06,859
any questions

1323
00:58:12,090 --> 00:58:15,059
[Music]

1324
00:58:15,059 --> 00:58:18,720
okay so uh it looks at uh

1325
00:58:18,720 --> 00:58:22,680
when you're when you're a protocol is

1326
00:58:22,680 --> 00:58:26,339
turned into a non-interactive using a

1327
00:58:26,339 --> 00:58:29,339
heuristics

1328
00:58:29,520 --> 00:58:32,819
it looks like it looks like very similar

1329
00:58:32,819 --> 00:58:36,059
to the to the one that you introduced in

1330
00:58:36,059 --> 00:58:39,480
the body part of your torque which is uh

1331
00:58:39,480 --> 00:58:43,140
a single a cyclicity programming

1332
00:58:43,140 --> 00:58:44,819
approach

1333
00:58:44,819 --> 00:58:47,280
do you how do you compare

1334
00:58:47,280 --> 00:58:51,299
those two uh approaches

1335
00:58:51,299 --> 00:58:55,319
with respect to the non-interactive case

1336
00:58:55,319 --> 00:58:58,920
uh yes exactly our method is similar to

1337
00:58:58,920 --> 00:59:03,839
the cyclicity program uh in fact we

1338
00:59:03,839 --> 00:59:07,799
compare combat it with our method in the

1339
00:59:07,799 --> 00:59:11,359
in our papers and the cyclicity program

1340
00:59:11,359 --> 00:59:14,880
is designed for non-inactive Journal

1341
00:59:14,880 --> 00:59:17,880
knowledge and we try to

1342
00:59:17,880 --> 00:59:20,940
convert it into a standard Sigma

1343
00:59:20,940 --> 00:59:24,480
protocol however we fed so that we

1344
00:59:24,480 --> 00:59:29,839
propose the dag Sigma protocol

1345
00:59:31,140 --> 00:59:32,400
okay

1346
00:59:32,400 --> 00:59:35,040
okay thank you very much

1347
00:59:35,040 --> 00:59:38,299
any other comments questions

1348
00:59:38,760 --> 00:59:41,160
then let's thank the speakers and all

1349
00:59:41,160 --> 00:59:45,200
speakers in this session thanks

1350
00:59:45,780 --> 00:59:48,559
thank you very much

