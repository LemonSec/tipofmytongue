1
00:01:24,600 --> 00:01:27,600
foreign

2
00:01:51,450 --> 00:01:54,519
[Music]

3
00:01:57,439 --> 00:02:00,479
so welcome to the first session of the

4
00:02:00,479 --> 00:02:02,159
day

5
00:02:02,159 --> 00:02:04,740
the first the first talk will be about

6
00:02:04,740 --> 00:02:06,840
optimizing linear key recovery attacks

7
00:02:06,840 --> 00:02:09,780
with a fine Workshop I find worse comes

8
00:02:09,780 --> 00:02:13,760
from tuning by the new fries

9
00:02:15,360 --> 00:02:18,420
so uh thank you for the introduction

10
00:02:18,420 --> 00:02:20,280
and as you said the topic of this

11
00:02:20,280 --> 00:02:23,459
presentation will be the Improvement of

12
00:02:23,459 --> 00:02:25,319
words transform based linear key

13
00:02:25,319 --> 00:02:27,959
recovery attacks using some novel was

14
00:02:27,959 --> 00:02:30,780
Transformer pruning techniques

15
00:02:30,780 --> 00:02:33,660
first I will briefly describe a linear

16
00:02:33,660 --> 00:02:35,879
key recovery attacks and the context of

17
00:02:35,879 --> 00:02:37,440
this problem

18
00:02:37,440 --> 00:02:40,440
so in a linear key recovery attack

19
00:02:40,440 --> 00:02:42,480
we consider a linear approximation of

20
00:02:42,480 --> 00:02:45,799
some part of a block Cipher

21
00:02:45,900 --> 00:02:47,700
and we will extend this linear

22
00:02:47,700 --> 00:02:49,620
approximation by adding a key recovery

23
00:02:49,620 --> 00:02:51,840
path usually a few rounds at the top and

24
00:02:51,840 --> 00:02:53,700
a few rounds at the bottom

25
00:02:53,700 --> 00:02:55,560
and we use the what we call the key

26
00:02:55,560 --> 00:02:57,060
recovery map

27
00:02:57,060 --> 00:02:59,040
in order to describe the value of the

28
00:02:59,040 --> 00:03:00,900
linear approximation as a function of

29
00:03:00,900 --> 00:03:02,700
the plain text to the cipher text and

30
00:03:02,700 --> 00:03:03,900
the key

31
00:03:03,900 --> 00:03:06,780
so normally what we do is we divide the

32
00:03:06,780 --> 00:03:08,280
plain text the ciphertext and the key

33
00:03:08,280 --> 00:03:10,860
into several segments and we will ignore

34
00:03:10,860 --> 00:03:12,659
those which have no influence on the

35
00:03:12,659 --> 00:03:15,300
value of the linear approximation

36
00:03:15,300 --> 00:03:18,239
in this paper specifically we also

37
00:03:18,239 --> 00:03:20,459
consider two types of key gas we have

38
00:03:20,459 --> 00:03:24,360
both outer key SS which are parts of the

39
00:03:24,360 --> 00:03:25,800
key which are so directly to the

40
00:03:25,800 --> 00:03:28,140
plaintext and ciphertext material and we

41
00:03:28,140 --> 00:03:31,940
have inner key guesses which are not

42
00:03:32,220 --> 00:03:35,819
so the aim of an attacker is to compute

43
00:03:35,819 --> 00:03:37,860
the experimental correlation

44
00:03:37,860 --> 00:03:40,379
for all key guesses for some given data

45
00:03:40,379 --> 00:03:42,299
samples so they get a list of plain text

46
00:03:42,299 --> 00:03:44,760
hypertext Pairs and they want to compute

47
00:03:44,760 --> 00:03:46,019
the correlation of the linear

48
00:03:46,019 --> 00:03:48,540
approximation within this set for each

49
00:03:48,540 --> 00:03:51,360
possible guess of the key

50
00:03:51,360 --> 00:03:54,900
so in the case of uh the form for the

51
00:03:54,900 --> 00:03:56,640
linear key recovery map which we have

52
00:03:56,640 --> 00:03:58,799
considered in the previous slide this

53
00:03:58,799 --> 00:04:01,860
experimental correlation looks like this

54
00:04:01,860 --> 00:04:04,379
and originally we knew of two algorithms

55
00:04:04,379 --> 00:04:06,299
to compute this vector

56
00:04:06,299 --> 00:04:08,459
the original one which has complexity

57
00:04:08,459 --> 00:04:10,379
which is the product of the size of the

58
00:04:10,379 --> 00:04:13,379
data sample times the total number of

59
00:04:13,379 --> 00:04:14,519
key guesses

60
00:04:14,519 --> 00:04:16,320
and a second one which uses a

61
00:04:16,320 --> 00:04:18,540
distillation step and whose complexity

62
00:04:18,540 --> 00:04:20,298
has two terms the first one is

63
00:04:20,298 --> 00:04:22,440
proportional to the size of the data

64
00:04:22,440 --> 00:04:24,840
sample and the second

65
00:04:24,840 --> 00:04:27,540
is only dependent on the size of the key

66
00:04:27,540 --> 00:04:29,580
guess but the outer key bits have to be

67
00:04:29,580 --> 00:04:30,840
paid twice

68
00:04:30,840 --> 00:04:33,919
the factor two

69
00:04:34,860 --> 00:04:37,500
a major development was the introduction

70
00:04:37,500 --> 00:04:40,680
of the fft or was transform technique

71
00:04:40,680 --> 00:04:44,400
and we start the same way we built some

72
00:04:44,400 --> 00:04:46,560
distillation table from

73
00:04:46,560 --> 00:04:48,840
the data sample and then we process this

74
00:04:48,840 --> 00:04:51,120
Vector in the following way first we

75
00:04:51,120 --> 00:04:52,860
apply it the first was transform on this

76
00:04:52,860 --> 00:04:54,060
vector

77
00:04:54,060 --> 00:04:57,660
and then for each guess of the inner key

78
00:04:57,660 --> 00:05:00,960
we will multiply this vector by the word

79
00:05:00,960 --> 00:05:03,360
spectrum of the key recovery map

80
00:05:03,360 --> 00:05:05,040
we apply the first words Transformer

81
00:05:05,040 --> 00:05:07,199
again and we obtain all the experimental

82
00:05:07,199 --> 00:05:08,460
correlations

83
00:05:08,460 --> 00:05:10,979
for this inner key guess

84
00:05:10,979 --> 00:05:15,000
so let us go over this a bit more slowly

85
00:05:15,000 --> 00:05:17,699
we start from a data sample

86
00:05:17,699 --> 00:05:20,340
and we build the distillation table

87
00:05:20,340 --> 00:05:22,139
in essence we just count the number of

88
00:05:22,139 --> 00:05:24,000
occurrences of the different possible

89
00:05:24,000 --> 00:05:25,860
values for the plain text Cipher text

90
00:05:25,860 --> 00:05:28,800
bar of the input to the category map

91
00:05:28,800 --> 00:05:32,580
then we apply the first wash transform

92
00:05:32,580 --> 00:05:34,979
and then we multiply element twice by

93
00:05:34,979 --> 00:05:36,900
this Vector which is actually the world

94
00:05:36,900 --> 00:05:40,500
spectrum of the recovery map

95
00:05:40,500 --> 00:05:42,419
and finally we just have to apply the

96
00:05:42,419 --> 00:05:43,620
first watch transform again on the

97
00:05:43,620 --> 00:05:45,660
resulting vector

98
00:05:45,660 --> 00:05:47,940
so the total complexity of this version

99
00:05:47,940 --> 00:05:49,560
of the attack

100
00:05:49,560 --> 00:05:51,660
has two terms the first is proportional

101
00:05:51,660 --> 00:05:53,340
to the size of the sample that is the

102
00:05:53,340 --> 00:05:55,199
cost of the distillation phase

103
00:05:55,199 --> 00:05:57,300
and then the cost of the worst transform

104
00:05:57,300 --> 00:06:00,380
steps is the total number of key guesses

105
00:06:00,380 --> 00:06:04,139
times the number of uh bits in the outer

106
00:06:04,139 --> 00:06:06,300
key guys

107
00:06:06,300 --> 00:06:08,400
so the problem that we want to solve is

108
00:06:08,400 --> 00:06:10,560
that in the Crypt analysis of real

109
00:06:10,560 --> 00:06:13,020
ciphers there may be some specific

110
00:06:13,020 --> 00:06:15,900
properties that we think should be able

111
00:06:15,900 --> 00:06:18,419
to reduce the time complexity but we

112
00:06:18,419 --> 00:06:20,039
don't know how how to

113
00:06:20,039 --> 00:06:21,740
for example

114
00:06:21,740 --> 00:06:24,360
if the size of the data sample is

115
00:06:24,360 --> 00:06:25,979
relatively small compared to the number

116
00:06:25,979 --> 00:06:28,199
of other key guesses then the

117
00:06:28,199 --> 00:06:30,780
distillation table is a sparse vector so

118
00:06:30,780 --> 00:06:33,620
we ask do we really have to build it

119
00:06:33,620 --> 00:06:36,240
we also consider that the cipher

120
00:06:36,240 --> 00:06:37,860
probably has some kind of key schedule

121
00:06:37,860 --> 00:06:40,259
which will induce relationships between

122
00:06:40,259 --> 00:06:42,600
the bits of the key guess

123
00:06:42,600 --> 00:06:44,460
so connect we actually use this to

124
00:06:44,460 --> 00:06:46,500
reduce the size of the gas

125
00:06:46,500 --> 00:06:49,979
effectively in terms of the algorithm

126
00:06:49,979 --> 00:06:51,539
and finally

127
00:06:51,539 --> 00:06:54,120
uh we noticed that previous versions of

128
00:06:54,120 --> 00:06:56,340
this attack algorithm consider that the

129
00:06:56,340 --> 00:06:58,740
key recovery map is an arbitrary volume

130
00:06:58,740 --> 00:07:00,000
function which

131
00:07:00,000 --> 00:07:03,120
uh uh normally it's we can deduce it

132
00:07:03,120 --> 00:07:05,520
from the construction of the cipher and

133
00:07:05,520 --> 00:07:07,919
we may have some properties which are

134
00:07:07,919 --> 00:07:10,580
useful to us

135
00:07:11,160 --> 00:07:14,759
so uh in this paper we consider that uh

136
00:07:14,759 --> 00:07:17,100
these redundancies can be expressed as

137
00:07:17,100 --> 00:07:18,840
spacity properties

138
00:07:18,840 --> 00:07:22,080
of either the non-zero input or the

139
00:07:22,080 --> 00:07:23,520
desired outputs of the two was

140
00:07:23,520 --> 00:07:25,979
transformed steps of the attack

141
00:07:25,979 --> 00:07:27,780
but this raises the following question

142
00:07:27,780 --> 00:07:30,240
which is uh how can we actually reduce

143
00:07:30,240 --> 00:07:31,919
the time complexity of the first words

144
00:07:31,919 --> 00:07:34,319
transform when we restrict the inputs or

145
00:07:34,319 --> 00:07:36,919
the outputs

146
00:07:36,960 --> 00:07:38,699
so the rest of this presentation will

147
00:07:38,699 --> 00:07:40,199
proceed as follows

148
00:07:40,199 --> 00:07:44,400
first we will discuss uh the pruning

149
00:07:44,400 --> 00:07:45,900
problem for the first words transform

150
00:07:45,900 --> 00:07:48,419
from a theoretical point of view

151
00:07:48,419 --> 00:07:52,259
then we will propose uh some solution to

152
00:07:52,259 --> 00:07:55,319
this problem and explain how to use it

153
00:07:55,319 --> 00:07:58,440
in the context of linear crypto analysis

154
00:07:58,440 --> 00:08:00,900
and finally I will briefly discuss the

155
00:08:00,900 --> 00:08:03,240
applications which are described in the

156
00:08:03,240 --> 00:08:05,400
paper

157
00:08:05,400 --> 00:08:07,440
so let's forget cryptanalysis for a

158
00:08:07,440 --> 00:08:08,520
moment

159
00:08:08,520 --> 00:08:10,380
and consider the following theoretical

160
00:08:10,380 --> 00:08:11,220
problem

161
00:08:11,220 --> 00:08:13,440
we are given a vector of length 2 to the

162
00:08:13,440 --> 00:08:14,819
n

163
00:08:14,819 --> 00:08:18,020
and we are guaranteed that there is some

164
00:08:18,020 --> 00:08:21,360
known affine Subspace X which will

165
00:08:21,360 --> 00:08:24,060
contain all the non-zero values in this

166
00:08:24,060 --> 00:08:26,160
vector

167
00:08:26,160 --> 00:08:30,419
we were also given some affine Subspace

168
00:08:30,419 --> 00:08:33,779
and we are tasked with Computing all the

169
00:08:33,779 --> 00:08:35,640
outputs of the first was transform of

170
00:08:35,640 --> 00:08:38,039
the initial Vector which lie within this

171
00:08:38,039 --> 00:08:39,719
affine Subspace U

172
00:08:39,719 --> 00:08:41,520
and of course uh

173
00:08:41,520 --> 00:08:43,140
the question that we want to answer is

174
00:08:43,140 --> 00:08:44,640
how can we do this as efficiently as

175
00:08:44,640 --> 00:08:46,320
possible

176
00:08:46,320 --> 00:08:48,060
and we are able to prove the following

177
00:08:48,060 --> 00:08:49,200
theorem

178
00:08:49,200 --> 00:08:50,760
which is that there is an algorithm

179
00:08:50,760 --> 00:08:52,339
which can

180
00:08:52,339 --> 00:08:54,839
solve this problem if

181
00:08:54,839 --> 00:08:56,760
with complexity which is essentially

182
00:08:56,760 --> 00:08:58,560
three terms

183
00:08:58,560 --> 00:09:01,500
the first is proportional to the total

184
00:09:01,500 --> 00:09:03,899
number of non-zero inputs of the

185
00:09:03,899 --> 00:09:06,360
transform the last is proportional to

186
00:09:06,360 --> 00:09:08,820
the number of desired outputs and there

187
00:09:08,820 --> 00:09:11,220
is also a middle term whose complexity

188
00:09:11,220 --> 00:09:14,160
is that of first world transform of size

189
00:09:14,160 --> 00:09:16,980
2 to the T where this parameter T is

190
00:09:16,980 --> 00:09:21,959
determined from the Subspace SX and u

191
00:09:21,959 --> 00:09:23,940
I think this and result is best

192
00:09:23,940 --> 00:09:25,980
understood with an example

193
00:09:25,980 --> 00:09:29,160
so we look at the affine subspaces which

194
00:09:29,160 --> 00:09:31,440
are shown on this live

195
00:09:31,440 --> 00:09:34,080
and they are also represented in the

196
00:09:34,080 --> 00:09:37,920
picture we've highlighted

197
00:09:37,920 --> 00:09:42,480
positions so for comparison the standard

198
00:09:42,480 --> 00:09:44,640
who first was transform algorithm we

199
00:09:44,640 --> 00:09:47,519
take 64 additions and subtractions in

200
00:09:47,519 --> 00:09:50,760
order to compute all the outputs and if

201
00:09:50,760 --> 00:09:52,980
we remove the unnecessary computations

202
00:09:52,980 --> 00:09:55,440
from this diagram we can reduce that to

203
00:09:55,440 --> 00:09:57,540
40.

204
00:09:57,540 --> 00:10:00,240
we can also reorder the steps of the

205
00:10:00,240 --> 00:10:01,980
fast towards transform

206
00:10:01,980 --> 00:10:04,320
and in this way we can achieve a

207
00:10:04,320 --> 00:10:06,959
complexity of just 32 additions and

208
00:10:06,959 --> 00:10:10,440
subtractions however

209
00:10:10,440 --> 00:10:13,320
if we look at this Matrix H which

210
00:10:13,320 --> 00:10:16,620
corresponds just to the sub Matrix of

211
00:10:16,620 --> 00:10:18,779
the other math matrix

212
00:10:18,779 --> 00:10:21,899
corresponding to the non-zero inputs

213
00:10:21,899 --> 00:10:24,060
under the side outputs

214
00:10:24,060 --> 00:10:26,940
big notice the following properties

215
00:10:26,940 --> 00:10:28,440
the first

216
00:10:28,440 --> 00:10:31,279
is that the pairs of columns

217
00:10:31,279 --> 00:10:34,320
corresponding to inputs which differ by

218
00:10:34,320 --> 00:10:36,720
a vector which is orthogonal to you

219
00:10:36,720 --> 00:10:39,000
always appear with opposite signs so

220
00:10:39,000 --> 00:10:41,640
this suggests that our algorithm should

221
00:10:41,640 --> 00:10:43,680
start by simply subtracting the specs of

222
00:10:43,680 --> 00:10:45,120
inputs

223
00:10:45,120 --> 00:10:47,519
next we look at the rows and we notice

224
00:10:47,519 --> 00:10:49,740
it notice a similar property

225
00:10:49,740 --> 00:10:52,440
which is that the best of rows which

226
00:10:52,440 --> 00:10:54,959
differ by vectors orthogonal 2X

227
00:10:54,959 --> 00:10:57,480
are always opposite so this suggests

228
00:10:57,480 --> 00:10:59,519
that the algorithm should end simply by

229
00:10:59,519 --> 00:11:01,440
copying some register

230
00:11:01,440 --> 00:11:03,060
to two different positions of the

231
00:11:03,060 --> 00:11:04,920
outputs

232
00:11:04,920 --> 00:11:07,380
and it turns out that we can actually

233
00:11:07,380 --> 00:11:10,019
complete this algorithm with a smaller

234
00:11:10,019 --> 00:11:11,880
fast forward transform of size 2 to the

235
00:11:11,880 --> 00:11:14,880
4. and in total this version of the

236
00:11:14,880 --> 00:11:16,860
algorithm just requires 16 operations

237
00:11:16,860 --> 00:11:19,740
and this is the basic idea behind the

238
00:11:19,740 --> 00:11:22,620
proof of the full result

239
00:11:22,620 --> 00:11:25,140
so there are two things I would like to

240
00:11:25,140 --> 00:11:27,420
highlight about uh these more General

241
00:11:27,420 --> 00:11:28,620
result

242
00:11:28,620 --> 00:11:31,440
the first is that the complexity of the

243
00:11:31,440 --> 00:11:33,540
algorithm doesn't just depend on the

244
00:11:33,540 --> 00:11:35,459
dimensions of X and u

245
00:11:35,459 --> 00:11:40,740
but also on the orthogonality on the two

246
00:11:40,740 --> 00:11:43,260
spaces the larger the orthogonal path

247
00:11:43,260 --> 00:11:44,459
that they share

248
00:11:44,459 --> 00:11:46,500
the lower the time complexity of the

249
00:11:46,500 --> 00:11:48,779
resulting fast was transform

250
00:11:48,779 --> 00:11:51,540
and also I would like to uh briefly

251
00:11:51,540 --> 00:11:53,700
describe the general algorithm which has

252
00:11:53,700 --> 00:11:56,519
three steps as we saw in the example the

253
00:11:56,519 --> 00:11:58,740
first is a compression step where we

254
00:11:58,740 --> 00:12:01,500
take all the non-zero inputs

255
00:12:01,500 --> 00:12:03,839
and map them to a smaller Vector of size

256
00:12:03,839 --> 00:12:05,700
2 to the T

257
00:12:05,700 --> 00:12:09,060
then we apply the first was transform in

258
00:12:09,060 --> 00:12:11,399
this smaller vector

259
00:12:11,399 --> 00:12:13,440
and finally we have an expansion step

260
00:12:13,440 --> 00:12:14,640
where we just

261
00:12:14,640 --> 00:12:17,459
copy the outputs of this model transform

262
00:12:17,459 --> 00:12:20,459
with some science science shops in some

263
00:12:20,459 --> 00:12:22,200
cases

264
00:12:22,200 --> 00:12:25,740
so now let's return to crypto analysis

265
00:12:25,740 --> 00:12:28,380
and look at an example of the kind of

266
00:12:28,380 --> 00:12:31,019
properties that we can exploit in the

267
00:12:31,019 --> 00:12:33,060
world spectrum of the key recovery map

268
00:12:33,060 --> 00:12:35,880
so we consider a recovery map which

269
00:12:35,880 --> 00:12:37,019
looks like this

270
00:12:37,019 --> 00:12:39,180
which might appear for example if we

271
00:12:39,180 --> 00:12:43,320
have an SPN log Cipher with a 4-bit test

272
00:12:43,320 --> 00:12:46,139
box and a bit permutation as the linear

273
00:12:46,139 --> 00:12:47,700
layer

274
00:12:47,700 --> 00:12:49,920
and we can compute its watch

275
00:12:49,920 --> 00:12:53,160
coefficients simply by multiplying the

276
00:12:53,160 --> 00:12:55,040
worst coefficient of the s-box

277
00:12:55,040 --> 00:12:58,880
corresponding to each part of the input

278
00:12:58,880 --> 00:13:01,440
mask to the watch coefficient

279
00:13:01,440 --> 00:13:04,680
and a fifth was coefficient of the s-box

280
00:13:04,680 --> 00:13:06,660
which corresponds to the Xbox in the

281
00:13:06,660 --> 00:13:07,680
second round

282
00:13:07,680 --> 00:13:10,019
and which takes this

283
00:13:10,019 --> 00:13:12,660
input mask beta which is actually

284
00:13:12,660 --> 00:13:15,360
determined bit by bit by whether each

285
00:13:15,360 --> 00:13:17,820
part of the full input mask is equal to

286
00:13:17,820 --> 00:13:20,100
zero or not this has an interesting

287
00:13:20,100 --> 00:13:21,300
consequence

288
00:13:21,300 --> 00:13:24,060
which is that when the world's

289
00:13:24,060 --> 00:13:25,800
coefficient corresponding to the all

290
00:13:25,800 --> 00:13:26,959
ones

291
00:13:26,959 --> 00:13:29,519
input mask for the s box is equal to

292
00:13:29,519 --> 00:13:30,779
zero

293
00:13:30,779 --> 00:13:34,380
then any non-zero was coefficient for

294
00:13:34,380 --> 00:13:36,420
the full key recovery map will

295
00:13:36,420 --> 00:13:39,300
necessarily have one of these four parts

296
00:13:39,300 --> 00:13:42,000
of the Mask equal to zero

297
00:13:42,000 --> 00:13:44,760
and this is quite interesting to us

298
00:13:44,760 --> 00:13:46,200
because it means

299
00:13:46,200 --> 00:13:49,380
that there was the support of the world

300
00:13:49,380 --> 00:13:52,019
spectrum of f is contained in four

301
00:13:52,019 --> 00:13:55,320
Vector subspaces of Dimension 12 instead

302
00:13:55,320 --> 00:13:57,420
of the full ambient Subspace of

303
00:13:57,420 --> 00:13:59,820
dimension 16.

304
00:13:59,820 --> 00:14:03,000
there are two uh additional things that

305
00:14:03,000 --> 00:14:04,560
we would have to consider the first is

306
00:14:04,560 --> 00:14:07,019
what happens when this was coefficient

307
00:14:07,019 --> 00:14:09,360
is not equal not equal to zero

308
00:14:09,360 --> 00:14:13,200
so what we can do is uh select some

309
00:14:13,200 --> 00:14:16,079
appropriate shows an inputs to the s box

310
00:14:16,079 --> 00:14:18,720
that we can reject so that this watch

311
00:14:18,720 --> 00:14:21,660
coefficient becomes zero

312
00:14:21,660 --> 00:14:23,760
and in terms of the attack what this

313
00:14:23,760 --> 00:14:26,279
means is that we reject some small

314
00:14:26,279 --> 00:14:29,180
portion of the data

315
00:14:29,220 --> 00:14:31,680
next we wonder what happens if we have

316
00:14:31,680 --> 00:14:34,139
the addition of an inner key

317
00:14:34,139 --> 00:14:36,779
and it turns out that we can just write

318
00:14:36,779 --> 00:14:39,300
the words coefficient

319
00:14:39,300 --> 00:14:41,760
for the of the recovery map for any

320
00:14:41,760 --> 00:14:43,980
inner key guess in terms

321
00:14:43,980 --> 00:14:46,980
of the worst coefficient

322
00:14:46,980 --> 00:14:50,040
or the zero key guys this has two

323
00:14:50,040 --> 00:14:51,300
consequences

324
00:14:51,300 --> 00:14:54,480
the first is that the vector subspaces

325
00:14:54,480 --> 00:14:56,480
we described in the previous slides

326
00:14:56,480 --> 00:14:59,160
applied to all

327
00:14:59,160 --> 00:15:01,079
energy gases

328
00:15:01,079 --> 00:15:04,079
and the second is that uh we can

329
00:15:04,079 --> 00:15:06,120
actually compute the word spectrum for

330
00:15:06,120 --> 00:15:08,820
F0 and then just did use the word

331
00:15:08,820 --> 00:15:10,440
spectrum for all the other keys with

332
00:15:10,440 --> 00:15:12,660
some sign drops

333
00:15:12,660 --> 00:15:14,760
so now we return

334
00:15:14,760 --> 00:15:17,100
to the worst transform algorithm in and

335
00:15:17,100 --> 00:15:18,720
we will apply everything that we have

336
00:15:18,720 --> 00:15:21,240
learned so far

337
00:15:21,240 --> 00:15:24,480
so the first thing we do is uh using

338
00:15:24,480 --> 00:15:27,120
this property of the inner key gas

339
00:15:27,120 --> 00:15:28,380
we can

340
00:15:28,380 --> 00:15:31,440
avoid the Computing the multiplication

341
00:15:31,440 --> 00:15:33,779
step separately for each energy gas we

342
00:15:33,779 --> 00:15:34,920
can just

343
00:15:34,920 --> 00:15:38,279
absorb the sign swaps in the first in

344
00:15:38,279 --> 00:15:39,180
this

345
00:15:39,180 --> 00:15:41,699
in the worst transform step which

346
00:15:41,699 --> 00:15:44,120
follows

347
00:15:44,339 --> 00:15:45,839
and now we will look at the support

348
00:15:45,839 --> 00:15:47,940
support of the world spectrum of the

349
00:15:47,940 --> 00:15:50,660
recovery map

350
00:15:51,480 --> 00:15:54,260
so we note that whenever we multiply

351
00:15:54,260 --> 00:15:57,300
this value in this vector by zero we

352
00:15:57,300 --> 00:15:59,339
obtain zero which means that the

353
00:15:59,339 --> 00:16:00,959
non-zero inputs to the second was

354
00:16:00,959 --> 00:16:03,660
transform step must also be contained in

355
00:16:03,660 --> 00:16:05,579
this support

356
00:16:05,579 --> 00:16:07,139
of the world spectrum of the key

357
00:16:07,139 --> 00:16:08,760
recovery map

358
00:16:08,760 --> 00:16:10,440
and we will assume that there is some

359
00:16:10,440 --> 00:16:12,540
Subspace U which covers

360
00:16:12,540 --> 00:16:16,519
this uh support

361
00:16:16,560 --> 00:16:19,800
next we consider the output side

362
00:16:19,800 --> 00:16:21,260
and we

363
00:16:21,260 --> 00:16:23,100
consider that because of the key

364
00:16:23,100 --> 00:16:25,800
schedule there is some Subspace V

365
00:16:25,800 --> 00:16:29,040
which covers all the possible values of

366
00:16:29,040 --> 00:16:31,939
the outer keygas

367
00:16:32,100 --> 00:16:36,000
so what we can do is simply apply the

368
00:16:36,000 --> 00:16:38,880
prune first was transform algorithm

369
00:16:38,880 --> 00:16:41,100
in this second was transform step and

370
00:16:41,100 --> 00:16:43,199
reduce the complexity

371
00:16:43,199 --> 00:16:45,300
to a one which depends on this parameter

372
00:16:45,300 --> 00:16:46,680
R which is

373
00:16:46,680 --> 00:16:49,199
determined by the orthogonality of u and

374
00:16:49,199 --> 00:16:51,319
v

375
00:16:52,500 --> 00:16:54,839
if we find ourselves in a situation like

376
00:16:54,839 --> 00:16:56,639
the one we actually described in which

377
00:16:56,639 --> 00:16:57,779
uh

378
00:16:57,779 --> 00:16:59,820
the support is not covered by a single

379
00:16:59,820 --> 00:17:01,680
find Subspace but a union of a fine

380
00:17:01,680 --> 00:17:04,559
Subspace we can just use the linearity

381
00:17:04,559 --> 00:17:06,419
of the words transform to separate it

382
00:17:06,419 --> 00:17:08,520
into several parts which are a lot

383
00:17:08,520 --> 00:17:11,040
easier to compute

384
00:17:11,040 --> 00:17:13,260
and then we just have to add the results

385
00:17:13,260 --> 00:17:15,359
at the end

386
00:17:15,359 --> 00:17:17,640
next we look at the first was transform

387
00:17:17,640 --> 00:17:20,459
step which again is restricted at the

388
00:17:20,459 --> 00:17:23,359
output side by the

389
00:17:23,359 --> 00:17:26,699
support of the word spectrum because we

390
00:17:26,699 --> 00:17:28,079
don't need to compute something which is

391
00:17:28,079 --> 00:17:31,460
going to be multiplied by zero

392
00:17:31,500 --> 00:17:32,940
and again

393
00:17:32,940 --> 00:17:35,039
we can use the prune the first words

394
00:17:35,039 --> 00:17:36,539
transform algorithm

395
00:17:36,539 --> 00:17:39,120
in this step

396
00:17:39,120 --> 00:17:41,039
and there is one final thing that we can

397
00:17:41,039 --> 00:17:42,000
do

398
00:17:42,000 --> 00:17:44,400
and it is uh based on the fact that we

399
00:17:44,400 --> 00:17:47,280
noticed that for each pair in the data

400
00:17:47,280 --> 00:17:48,480
sample

401
00:17:48,480 --> 00:17:51,960
we are going to modify just one position

402
00:17:51,960 --> 00:17:54,600
in one of in each one of the compressed

403
00:17:54,600 --> 00:17:56,580
arrays which are built in this first was

404
00:17:56,580 --> 00:17:58,620
transform step

405
00:17:58,620 --> 00:18:00,360
and what this means is that we can

406
00:18:00,360 --> 00:18:02,700
actually combine the distillation phase

407
00:18:02,700 --> 00:18:05,520
and the compression step of the first

408
00:18:05,520 --> 00:18:07,500
was transformed

409
00:18:07,500 --> 00:18:09,240
so the final algorithm looks something

410
00:18:09,240 --> 00:18:10,559
like this

411
00:18:10,559 --> 00:18:13,440
and what I'd like to point out is that

412
00:18:13,440 --> 00:18:16,080
uh in the right circumstances

413
00:18:16,080 --> 00:18:18,299
this complexity is completely

414
00:18:18,299 --> 00:18:19,740
independent

415
00:18:19,740 --> 00:18:22,320
from the actual dimension of the input

416
00:18:22,320 --> 00:18:24,600
space to the key recovery map which is

417
00:18:24,600 --> 00:18:26,460
something which was not true of previous

418
00:18:26,460 --> 00:18:29,299
versions of the attack

419
00:18:29,700 --> 00:18:32,700
finally I will briefly sketch the two

420
00:18:32,700 --> 00:18:34,140
applications which are described in the

421
00:18:34,140 --> 00:18:35,220
paper

422
00:18:35,220 --> 00:18:37,260
the first one is the application to the

423
00:18:37,260 --> 00:18:41,100
Des so we take matsui's attack on the

424
00:18:41,100 --> 00:18:42,660
full Des

425
00:18:42,660 --> 00:18:45,480
and consider the 14 Round linear

426
00:18:45,480 --> 00:18:46,740
approximation which is used in this

427
00:18:46,740 --> 00:18:47,460
attack

428
00:18:47,460 --> 00:18:49,799
and we remove the last round of this

429
00:18:49,799 --> 00:18:51,000
approximation

430
00:18:51,000 --> 00:18:53,460
and we'll cover it with key recovery

431
00:18:53,460 --> 00:18:56,400
instead so normally what would happen

432
00:18:56,400 --> 00:18:58,620
is that the cost of the key recovery for

433
00:18:58,620 --> 00:19:00,780
this version of the attack is too large

434
00:19:00,780 --> 00:19:02,760
however we can Leverage The Wall

435
00:19:02,760 --> 00:19:04,679
spectrum of S5

436
00:19:04,679 --> 00:19:06,480
in order to keep the time complexity

437
00:19:06,480 --> 00:19:08,100
down

438
00:19:08,100 --> 00:19:10,020
and the result is that we obtain the

439
00:19:10,020 --> 00:19:11,940
best known attack in the literature in

440
00:19:11,940 --> 00:19:14,940
terms of data complexity

441
00:19:14,940 --> 00:19:17,700
we next look at presents so we take an

442
00:19:17,700 --> 00:19:21,240
existing attack on 28 rounds of the 80

443
00:19:21,240 --> 00:19:23,940
bit key variant and we are able to add

444
00:19:23,940 --> 00:19:26,940
an additional round to this attack

445
00:19:26,940 --> 00:19:27,720
um

446
00:19:27,720 --> 00:19:30,600
so we obtained the first attack on 29

447
00:19:30,600 --> 00:19:34,380
rounds for the 128 bit key version

448
00:19:34,380 --> 00:19:37,080
again this uh this attack would not be

449
00:19:37,080 --> 00:19:38,400
possible where it's not for these

450
00:19:38,400 --> 00:19:40,940
optimization

451
00:19:41,880 --> 00:19:43,980
finally I would like to discuss some

452
00:19:43,980 --> 00:19:46,679
open problems related to this technique

453
00:19:46,679 --> 00:19:49,020
the first would be to apply it in other

454
00:19:49,020 --> 00:19:51,840
scenarios in particular we think that

455
00:19:51,840 --> 00:19:55,080
differential linear Crypt analysis is a

456
00:19:55,080 --> 00:19:58,260
good Target because uh in a differential

457
00:19:58,260 --> 00:20:00,299
linear attack we have to consider

458
00:20:00,299 --> 00:20:02,160
essentially the same key guess for each

459
00:20:02,160 --> 00:20:05,400
true ciphertext in a pair so already we

460
00:20:05,400 --> 00:20:07,020
have a lot of redundancy on the kigas

461
00:20:07,020 --> 00:20:08,460
side

462
00:20:08,460 --> 00:20:11,820
we also think that uh designing linear

463
00:20:11,820 --> 00:20:13,980
attacks which use this technique is

464
00:20:13,980 --> 00:20:16,740
quite Technical and involved process

465
00:20:16,740 --> 00:20:18,240
so it would be nice to have some

466
00:20:18,240 --> 00:20:20,460
automatic tools which are able to

467
00:20:20,460 --> 00:20:22,679
compute the time complexity of the

468
00:20:22,679 --> 00:20:25,200
resulting attack automatically

469
00:20:25,200 --> 00:20:27,539
on a more theoretical side

470
00:20:27,539 --> 00:20:30,299
uh we still think that there is a lot of

471
00:20:30,299 --> 00:20:32,880
redundancy and spacity in the arrays

472
00:20:32,880 --> 00:20:35,100
which appear during the attack

473
00:20:35,100 --> 00:20:37,799
and uh we believe that this might still

474
00:20:37,799 --> 00:20:39,780
be used to reduce the time complexity

475
00:20:39,780 --> 00:20:42,179
and especially the memory complexity of

476
00:20:42,179 --> 00:20:44,039
the attack

477
00:20:44,039 --> 00:20:46,500
and finally the big question

478
00:20:46,500 --> 00:20:49,140
is whether this technique can also be

479
00:20:49,140 --> 00:20:52,620
applied to a more General linear layers

480
00:20:52,620 --> 00:20:54,900
and not just speed permutations

481
00:20:54,900 --> 00:20:57,000
so thank you for your attention and I'm

482
00:20:57,000 --> 00:20:58,679
open for questions

483
00:20:58,679 --> 00:21:01,679
foreign

484
00:21:14,480 --> 00:21:17,920
[Music]

485
00:21:24,000 --> 00:21:28,500
does it affect the memory no uh just the

486
00:21:28,500 --> 00:21:30,539
the memories the memory cost is in fact

487
00:21:30,539 --> 00:21:34,879
reduced to uh

488
00:21:43,740 --> 00:21:46,620
so uh we can actually reduce the memory

489
00:21:46,620 --> 00:21:48,900
basically to this dimension of these

490
00:21:48,900 --> 00:21:50,820
smaller spaces

491
00:21:50,820 --> 00:21:53,220
um however

492
00:21:53,220 --> 00:21:55,500
in real examples we still notice that

493
00:21:55,500 --> 00:21:57,539
there is a lot of repetition for example

494
00:21:57,539 --> 00:22:00,120
if you look at the work spectrum of

495
00:22:00,120 --> 00:22:01,559
of this map

496
00:22:01,559 --> 00:22:03,240
uh do you find that there is a lot of

497
00:22:03,240 --> 00:22:06,120
repeated values things like this so one

498
00:22:06,120 --> 00:22:09,120
wonders if there is some compact way of

499
00:22:09,120 --> 00:22:10,919
writing these arrays

500
00:22:10,919 --> 00:22:14,340
which uh saves us some memory perhaps at

501
00:22:14,340 --> 00:22:15,600
the cost of

502
00:22:15,600 --> 00:22:18,299
some overhead in the time complexity

503
00:22:18,299 --> 00:22:21,539
but uh I mean for example if you look at

504
00:22:21,539 --> 00:22:23,159
the DS attack

505
00:22:23,159 --> 00:22:25,320
it's clear that the ball technique here

506
00:22:25,320 --> 00:22:26,720
is the memory

507
00:22:26,720 --> 00:22:29,820
toughest part okay thank you

508
00:22:29,820 --> 00:22:32,120
no question

509
00:22:32,120 --> 00:22:35,880
so let's thank the speaker again

510
00:22:35,880 --> 00:22:38,120
foreign

511
00:23:12,679 --> 00:23:15,840
so Net stock is about statistical

512
00:23:15,840 --> 00:23:20,539
decoding 2.0 reducing decoding to LPN

513
00:23:20,539 --> 00:23:24,980
by Kevin carrier Thomas

514
00:23:30,380 --> 00:23:33,480
so hello so I'm Charles and I will

515
00:23:33,480 --> 00:23:36,659
present statistical recording 2.0 so

516
00:23:36,659 --> 00:23:40,400
this is a joint work with Stephen Curry

517
00:23:40,400 --> 00:23:43,440
so in our paper we introduce a new

518
00:23:43,440 --> 00:23:46,620
algorithm to decode random linear codes

519
00:23:46,620 --> 00:23:51,240
okay so uh first I'm going to be to give

520
00:23:51,240 --> 00:23:53,340
a bit of context so why it is an

521
00:23:53,340 --> 00:23:54,860
important problem the decoding problem

522
00:23:54,860 --> 00:23:57,659
uh it is because the security of all

523
00:23:57,659 --> 00:23:59,700
code-based primitive rely on the

524
00:23:59,700 --> 00:24:01,740
hardness of decoding linear codes okay

525
00:24:01,740 --> 00:24:04,919
here for example I've put in uh putting

526
00:24:04,919 --> 00:24:06,960
some cut-based Primitives you have

527
00:24:06,960 --> 00:24:08,700
Mercedes by you can ask you say for

528
00:24:08,700 --> 00:24:10,620
example that are in the first round of

529
00:24:10,620 --> 00:24:13,320
this standardization competition

530
00:24:13,320 --> 00:24:16,860
and so all these Primitives are based on

531
00:24:16,860 --> 00:24:20,280
error collecting codes okay and thus the

532
00:24:20,280 --> 00:24:21,659
complexity of the best decoding

533
00:24:21,659 --> 00:24:22,740
algorithm

534
00:24:22,740 --> 00:24:24,900
um are going to be an essential tool for

535
00:24:24,900 --> 00:24:28,940
setting a parameters of such Primitives

536
00:24:29,220 --> 00:24:32,700
okay so uh I'm just going to recall what

537
00:24:32,700 --> 00:24:35,280
I'm going to use here first a linear

538
00:24:35,280 --> 00:24:38,580
code so here I'm going to be placed in a

539
00:24:38,580 --> 00:24:41,520
binary space a binary code of length n

540
00:24:41,520 --> 00:24:44,280
and dimension K is just a linear

541
00:24:44,280 --> 00:24:46,380
Subspace of F2 to the power of n of

542
00:24:46,380 --> 00:24:49,799
Dimension K okay and we will call R the

543
00:24:49,799 --> 00:24:51,480
weight of the code

544
00:24:51,480 --> 00:24:53,640
and so now we can Define formally the

545
00:24:53,640 --> 00:24:55,620
decoding distance at distance T which

546
00:24:55,620 --> 00:24:58,380
can be stated as follow so I give you a

547
00:24:58,380 --> 00:25:00,960
noisy card word Y which is equal to C

548
00:25:00,960 --> 00:25:04,620
plus e where C is a code word and E is

549
00:25:04,620 --> 00:25:08,039
an error Vector performing white t along

550
00:25:08,039 --> 00:25:10,559
here the Hamming weight of e is just the

551
00:25:10,559 --> 00:25:12,480
number of non-zero coordinates of the

552
00:25:12,480 --> 00:25:14,760
vector so basically here the error

553
00:25:14,760 --> 00:25:16,860
Vector will be a sparse Vector so T will

554
00:25:16,860 --> 00:25:17,700
be small

555
00:25:17,700 --> 00:25:20,400
and I ask you to find a codeword C

556
00:25:20,400 --> 00:25:23,940
between the to the code such that c

557
00:25:23,940 --> 00:25:27,600
minus y is affirming white t

558
00:25:27,600 --> 00:25:30,779
so this is a hard problem and all the

559
00:25:30,779 --> 00:25:34,020
code base primitive relay on that

560
00:25:34,020 --> 00:25:36,900
so here let's talk a bit about the state

561
00:25:36,900 --> 00:25:39,179
of the Arts we are going to interest

562
00:25:39,179 --> 00:25:41,940
ourselves at the decoding problem at its

563
00:25:41,940 --> 00:25:44,159
hardest distance namely when T is equal

564
00:25:44,159 --> 00:25:46,340
to the real version of distance

565
00:25:46,340 --> 00:25:48,900
just to give a bit of context this

566
00:25:48,900 --> 00:25:51,299
distance is the distance where you have

567
00:25:51,299 --> 00:25:53,580
typically one solution of your decoding

568
00:25:53,580 --> 00:25:56,039
problem so if you take T bigger than

569
00:25:56,039 --> 00:25:57,480
this distance you will have many

570
00:25:57,480 --> 00:25:59,520
solution and thus you will be able to

571
00:25:59,520 --> 00:26:02,100
speed up your algorithm to take into

572
00:26:02,100 --> 00:26:03,840
account this if you you will try to find

573
00:26:03,840 --> 00:26:06,960
one solution so we place a t toward this

574
00:26:06,960 --> 00:26:07,740
distance

575
00:26:07,740 --> 00:26:10,500
and I have put it here uh the complexity

576
00:26:10,500 --> 00:26:12,779
exponent of some algorithm that exists

577
00:26:12,779 --> 00:26:15,539
today to record random linear codes so

578
00:26:15,539 --> 00:26:17,460
the first thing you can see here is that

579
00:26:17,460 --> 00:26:19,620
the main family of algorithm are called

580
00:26:19,620 --> 00:26:22,919
information settings algorithm ISD

581
00:26:22,919 --> 00:26:26,460
the first ID was made by project in 1962

582
00:26:26,460 --> 00:26:29,820
and then it has been improved over the

583
00:26:29,820 --> 00:26:32,039
years and the last algorithm the

584
00:26:32,039 --> 00:26:35,279
lifestyle is D is made by bot and May in

585
00:26:35,279 --> 00:26:37,500
2018 okay

586
00:26:37,500 --> 00:26:39,480
but you can also see that there is

587
00:26:39,480 --> 00:26:41,820
another algorithm which does not belong

588
00:26:41,820 --> 00:26:43,620
to this big family which is called

589
00:26:43,620 --> 00:26:45,419
statistical decoding and it was

590
00:26:45,419 --> 00:26:48,840
introduced by algebra in 2001. so the

591
00:26:48,840 --> 00:26:50,400
first thing you can see is that

592
00:26:50,400 --> 00:26:53,940
statistical decoding is a completely

593
00:26:53,940 --> 00:26:57,000
incompetitive against ISD so here you

594
00:26:57,000 --> 00:26:58,980
see the complexity exponent of this

595
00:26:58,980 --> 00:27:00,779
algorithm and so you see that

596
00:27:00,779 --> 00:27:02,580
statistical decoding complexity exponent

597
00:27:02,580 --> 00:27:05,700
is three times higher than the simplest

598
00:27:05,700 --> 00:27:08,159
of the ISD

599
00:27:08,159 --> 00:27:11,520
so you also see that it's been like

600
00:27:11,520 --> 00:27:13,200
after 60 years of research on this

601
00:27:13,200 --> 00:27:14,940
problem the complexity exponents have

602
00:27:14,940 --> 00:27:17,880
only been improved by a factor of 20 so

603
00:27:17,880 --> 00:27:21,980
this is kind of really a hard problem

604
00:27:22,080 --> 00:27:25,200
so no what is our contribution so we

605
00:27:25,200 --> 00:27:26,820
introduced a new algorithm called erl

606
00:27:26,820 --> 00:27:28,740
pen which will be based on statistical

607
00:27:28,740 --> 00:27:30,480
decoding 1.0

608
00:27:30,480 --> 00:27:34,140
but in statistical recording 1.0 uh we

609
00:27:34,140 --> 00:27:36,120
will make use of parity check to decode

610
00:27:36,120 --> 00:27:39,740
one bit uh of the error okay

611
00:27:39,740 --> 00:27:42,720
we will use parity check to reduce our

612
00:27:42,720 --> 00:27:44,520
decoding problem into an airplane

613
00:27:44,520 --> 00:27:46,980
problem and then we'll solve this

614
00:27:46,980 --> 00:27:50,520
problem with typical solvers usual

615
00:27:50,520 --> 00:27:52,919
solvers and this will lead to a

616
00:27:52,919 --> 00:27:54,360
groundbreaking improvement over

617
00:27:54,360 --> 00:27:56,880
statistical decoding 1.0

618
00:27:56,880 --> 00:27:59,720
more specifically here are our results

619
00:27:59,720 --> 00:28:02,940
so uh I've plotted here the complexity

620
00:28:02,940 --> 00:28:05,279
exponent of some decoding algorithm so

621
00:28:05,279 --> 00:28:06,779
in green here I don't know if you can

622
00:28:06,779 --> 00:28:10,140
see it but you have a statistically

623
00:28:10,140 --> 00:28:13,679
running 1.0 okay so it's the complexity

624
00:28:13,679 --> 00:28:15,360
exponent in function of the rate of the

625
00:28:15,360 --> 00:28:17,520
code so you see that it's completely

626
00:28:17,520 --> 00:28:19,860
incompetitive in Black here you have

627
00:28:19,860 --> 00:28:22,559
crunch algorithm which is the simplest

628
00:28:22,559 --> 00:28:24,840
of the ASD in blue you have button may

629
00:28:24,840 --> 00:28:26,640
algorithm which is the state of the art

630
00:28:26,640 --> 00:28:31,200
and in red you have a new algorithm

631
00:28:31,200 --> 00:28:34,320
so you see that we did all of the

632
00:28:34,320 --> 00:28:36,179
Prejudice existing decoding algorithm

633
00:28:36,179 --> 00:28:38,940
for weight smaller than 0.3 and you can

634
00:28:38,940 --> 00:28:41,520
also see that actually for weight close

635
00:28:41,520 --> 00:28:44,400
to zero our algorithm performed in the

636
00:28:44,400 --> 00:28:47,220
square roots of the knife search where

637
00:28:47,220 --> 00:28:50,039
all the the isds are performed in the

638
00:28:50,039 --> 00:28:52,200
comp of the complexity of the naive

639
00:28:52,200 --> 00:28:54,000
search so here when I'm talking about

640
00:28:54,000 --> 00:28:55,799
the the complexity of the niche search

641
00:28:55,799 --> 00:28:58,260
it's just enumerating all the code words

642
00:28:58,260 --> 00:29:00,900
and trying to look for one that is at

643
00:29:00,900 --> 00:29:03,120
distance T of my musical world

644
00:29:03,120 --> 00:29:06,240
so it is important to notice that it's

645
00:29:06,240 --> 00:29:09,539
been 60 years since the isds have not

646
00:29:09,539 --> 00:29:11,700
been improved for the for a significant

647
00:29:11,700 --> 00:29:15,919
range of parameters of rate

648
00:29:16,020 --> 00:29:18,480
so now um before presenting our new

649
00:29:18,480 --> 00:29:20,580
algorithm and to give a bit more context

650
00:29:20,580 --> 00:29:24,960
I will present statistical decoding 1.0

651
00:29:24,960 --> 00:29:28,320
so the main IDE first before talking

652
00:29:28,320 --> 00:29:30,600
about that rely on the fact that if you

653
00:29:30,600 --> 00:29:33,240
have a code C of length n and dimension

654
00:29:33,240 --> 00:29:36,240
K you can consider its dual okay what is

655
00:29:36,240 --> 00:29:38,279
this dual it's just the elements that

656
00:29:38,279 --> 00:29:41,340
are orthogonal to see here you see it's

657
00:29:41,340 --> 00:29:43,980
all the age so that see that H is equal

658
00:29:43,980 --> 00:29:46,500
to zero for all codewords

659
00:29:46,500 --> 00:29:49,200
so the Dual of C is actually a code

660
00:29:49,200 --> 00:29:51,539
itself of length n and dimension and

661
00:29:51,539 --> 00:29:53,640
minor scale and we will call the element

662
00:29:53,640 --> 00:29:56,279
of the Dual the parity checks of C

663
00:29:56,279 --> 00:29:58,919
and so here what can you see is that if

664
00:29:58,919 --> 00:30:00,840
you have a noise equal word or why so

665
00:30:00,840 --> 00:30:03,419
you don't know C you don't know e and

666
00:30:03,419 --> 00:30:06,840
you compute the dot product of Y and H H

667
00:30:06,840 --> 00:30:09,360
being a parity check you have that it is

668
00:30:09,360 --> 00:30:11,580
equal to C dot product h plus e dot

669
00:30:11,580 --> 00:30:13,980
product H which is equal to e dot

670
00:30:13,980 --> 00:30:17,100
product H because this term here cancels

671
00:30:17,100 --> 00:30:20,460
out because C and H are orthogonal

672
00:30:20,460 --> 00:30:22,740
and so what will happen is that

673
00:30:22,740 --> 00:30:25,620
statistical decoding will make use of

674
00:30:25,620 --> 00:30:29,460
thus of that Mark okay so what it will

675
00:30:29,460 --> 00:30:31,980
try to do it will try to recover one

676
00:30:31,980 --> 00:30:34,200
coordinate of the error at a time for

677
00:30:34,200 --> 00:30:36,480
example let's say here that we will want

678
00:30:36,480 --> 00:30:38,580
to try to recover the first coordinator

679
00:30:38,580 --> 00:30:43,080
of e E1 so if we consider variety check

680
00:30:43,080 --> 00:30:47,399
H such that H1 is equal to 1 as before I

681
00:30:47,399 --> 00:30:49,500
can compute y dot product H which is

682
00:30:49,500 --> 00:30:52,140
equal to e dot product H which is equal

683
00:30:52,140 --> 00:30:55,380
to This n so this is either zero either

684
00:30:55,380 --> 00:30:58,500
one and so this is equal to this sum and

685
00:30:58,500 --> 00:31:00,480
I can extract the first term of this

686
00:31:00,480 --> 00:31:04,620
term in E1 and plus the rest of the sum

687
00:31:04,620 --> 00:31:07,740
so the main remark here is that this sum

688
00:31:07,740 --> 00:31:11,220
here will be biased toward zero we will

689
00:31:11,220 --> 00:31:14,159
call it a noise term so why will it be

690
00:31:14,159 --> 00:31:16,919
biased towards you it's because e is an

691
00:31:16,919 --> 00:31:20,460
error Vector so it is pass and H will be

692
00:31:20,460 --> 00:31:22,799
computed such that it is passed so H

693
00:31:22,799 --> 00:31:25,260
will be a parity check of low I mean

694
00:31:25,260 --> 00:31:27,179
weight okay so this explains what this

695
00:31:27,179 --> 00:31:29,640
will be biased so if you want to recover

696
00:31:29,640 --> 00:31:32,279
E1 you will just complete manipulity

697
00:31:32,279 --> 00:31:34,860
check and you will compute y dot product

698
00:31:34,860 --> 00:31:37,380
H and what you will do is you just do

699
00:31:37,380 --> 00:31:40,200
majority routine to recover even

700
00:31:40,200 --> 00:31:43,080
so you have two cases either E1 is equal

701
00:31:43,080 --> 00:31:46,320
to zero then why that predict H follow a

702
00:31:46,320 --> 00:31:48,179
binary of parameter one minus Epsilon

703
00:31:48,179 --> 00:31:51,059
over two for some Epsilon by us

704
00:31:51,059 --> 00:31:54,299
and if E1 is equal to one then y dot

705
00:31:54,299 --> 00:31:56,520
product H is equal to this and it

706
00:31:56,520 --> 00:31:58,200
follows the binary distribution of

707
00:31:58,200 --> 00:32:01,320
parameter one plus Epsilon over two

708
00:32:01,320 --> 00:32:03,600
so here you notice that there is a small

709
00:32:03,600 --> 00:32:05,880
difference between the two distribution

710
00:32:05,880 --> 00:32:08,700
and it is a classical result that you

711
00:32:08,700 --> 00:32:10,679
need one over Epsilon Square sample to

712
00:32:10,679 --> 00:32:12,720
distinguish the two distribution okay so

713
00:32:12,720 --> 00:32:14,460
you need to compute one over Epsilon

714
00:32:14,460 --> 00:32:17,460
Square H to distinguish

715
00:32:17,460 --> 00:32:19,919
so here Epsilon is absolute

716
00:32:19,919 --> 00:32:21,840
exponentially smaller and it will be a

717
00:32:21,840 --> 00:32:24,480
function of n t the weight of the error

718
00:32:24,480 --> 00:32:26,700
and w

719
00:32:26,700 --> 00:32:30,919
where I don't have the pointer

720
00:32:31,080 --> 00:32:35,539
okay of w the weight of H

721
00:32:36,559 --> 00:32:39,659
so here to be a bit more precise a

722
00:32:39,659 --> 00:32:42,000
floated the number of needed parity

723
00:32:42,000 --> 00:32:44,820
check H uh to be able to distinguish the

724
00:32:44,820 --> 00:32:46,020
two distribution

725
00:32:46,020 --> 00:32:50,279
so uh here uh in function of w the

726
00:32:50,279 --> 00:32:53,100
weight of H so in Black here you have

727
00:32:53,100 --> 00:32:55,260
the the curve which represents the

728
00:32:55,260 --> 00:32:57,419
number of needed priority check and you

729
00:32:57,419 --> 00:33:00,840
see that U1 W as small as possible for

730
00:33:00,840 --> 00:33:04,200
example here you see that when w is

731
00:33:04,200 --> 00:33:07,500
small you need less parity checks but

732
00:33:07,500 --> 00:33:10,440
one thing you can see is that you have

733
00:33:10,440 --> 00:33:12,779
an implicit constraint because you need

734
00:33:12,779 --> 00:33:15,120
that the number of parity check of a

735
00:33:15,120 --> 00:33:18,120
certain way W uh in your code is

736
00:33:18,120 --> 00:33:20,399
superior to the number of needed by the

737
00:33:20,399 --> 00:33:21,500
check

738
00:33:21,500 --> 00:33:24,840
of the number of needed by to check so

739
00:33:24,840 --> 00:33:26,880
actually you want W as small as possible

740
00:33:26,880 --> 00:33:29,399
because you because this will be a lower

741
00:33:29,399 --> 00:33:31,440
Bond on your complexity whenever Epsilon

742
00:33:31,440 --> 00:33:33,120
Square will be a lower volume on your

743
00:33:33,120 --> 00:33:35,519
complexity but you cannot here you

744
00:33:35,519 --> 00:33:39,179
cannot take W smaller than 0.2 okay

745
00:33:39,179 --> 00:33:41,760
because you see that 0.2 is the crossing

746
00:33:41,760 --> 00:33:43,559
point because the number variable and

747
00:33:43,559 --> 00:33:44,880
the numbers

748
00:33:44,880 --> 00:33:47,340
so you will need approximately due to

749
00:33:47,340 --> 00:33:52,340
the power of 0.2 n priority checks

750
00:33:52,559 --> 00:33:56,039
so now we are ready to present a real

751
00:33:56,039 --> 00:33:58,220
pen

752
00:33:58,980 --> 00:34:01,980
so the main idea of LPN is instead of

753
00:34:01,980 --> 00:34:04,260
recovering one coordinate of the error

754
00:34:04,260 --> 00:34:06,779
at the time we will try to recover many

755
00:34:06,779 --> 00:34:09,300
coordinates of the error at the time so

756
00:34:09,300 --> 00:34:10,918
for example here I will choose the set

757
00:34:10,918 --> 00:34:14,159
of position P of size s and I will call

758
00:34:14,159 --> 00:34:16,859
n it's complementary and I will try to

759
00:34:16,859 --> 00:34:18,239
recover EP

760
00:34:18,239 --> 00:34:21,239
so as before I can make the same remark

761
00:34:21,239 --> 00:34:23,760
if I take a party check h i can compute

762
00:34:23,760 --> 00:34:26,159
y.product H which is equal to e dot

763
00:34:26,159 --> 00:34:28,679
product H and then I can split this dot

764
00:34:28,679 --> 00:34:33,300
product between uh okay thank you

765
00:34:33,300 --> 00:34:36,300
perfect so I can split this dot products

766
00:34:36,300 --> 00:34:40,699
e dot product H between EP dot HP and

767
00:34:40,699 --> 00:34:45,659
EP dot HP plus hn dot product e n so

768
00:34:45,659 --> 00:34:48,540
this will be biased towards zero and we

769
00:34:48,540 --> 00:34:51,359
will call it a noise term okay and what

770
00:34:51,359 --> 00:34:53,099
you will want to try to do is to recover

771
00:34:53,099 --> 00:34:56,639
EP for many samples while the product H

772
00:34:56,639 --> 00:34:58,740
where the samples are given by the body

773
00:34:58,740 --> 00:34:59,820
checks

774
00:34:59,820 --> 00:35:01,920
so I have put it here the main

775
00:35:01,920 --> 00:35:03,359
difference between statistically going

776
00:35:03,359 --> 00:35:06,480
1.0 and level in statistical legal in

777
00:35:06,480 --> 00:35:09,180
1.0 you will take P of size 1 so you

778
00:35:09,180 --> 00:35:11,220
will want to try to recover one

779
00:35:11,220 --> 00:35:13,440
coordinate of the error at the time and

780
00:35:13,440 --> 00:35:15,720
you will compute parity checks of way W

781
00:35:15,720 --> 00:35:18,200
and N okay

782
00:35:18,200 --> 00:35:21,599
you will take P bigger and thus n will

783
00:35:21,599 --> 00:35:24,900
be smaller and you you will compute h of

784
00:35:24,900 --> 00:35:28,800
a fixed weight uh on N okay and the main

785
00:35:28,800 --> 00:35:31,500
effect of that will be that P because p

786
00:35:31,500 --> 00:35:34,440
is bigger and is smaller and thus the

787
00:35:34,440 --> 00:35:38,099
noise here will become smaller so in the

788
00:35:38,099 --> 00:35:40,680
next slide I'm going to try to give a

789
00:35:40,680 --> 00:35:43,320
small intuition on why it is true

790
00:35:43,320 --> 00:35:45,780
so here for example let's consider

791
00:35:45,780 --> 00:35:47,820
statistical legaling 1.0

792
00:35:47,820 --> 00:35:50,460
suppose you have a package check of wave

793
00:35:50,460 --> 00:35:54,599
W and N so H is of weight w on this part

794
00:35:54,599 --> 00:35:58,079
you can split H in hn in two parts hn1

795
00:35:58,079 --> 00:36:01,320
here and H and one and send two here and

796
00:36:01,320 --> 00:36:04,200
thus e n dot product hn are equal to U

797
00:36:04,200 --> 00:36:06,599
that this is a noise term I want it as

798
00:36:06,599 --> 00:36:07,800
small as possible

799
00:36:07,800 --> 00:36:12,060
the nwhn is equal to hn1 the product en1

800
00:36:12,060 --> 00:36:17,520
plus en2 the predict hn2 okay but then

801
00:36:17,520 --> 00:36:21,240
because I took H uh I took P of size

802
00:36:21,240 --> 00:36:25,079
bigger I this term here the hn1 the

803
00:36:25,079 --> 00:36:29,460
project h e n one will not appear in the

804
00:36:29,460 --> 00:36:32,160
noise term so e dot product e n the

805
00:36:32,160 --> 00:36:35,400
product h n will be equal to e and two

806
00:36:35,400 --> 00:36:38,460
the product hn2 so we'll just have this

807
00:36:38,460 --> 00:36:40,680
sum here and not this term and this is

808
00:36:40,680 --> 00:36:42,780
why automatically you will have your

809
00:36:42,780 --> 00:36:47,880
bias uh your noise that will be smaller

810
00:36:47,880 --> 00:36:51,480
so to compare a bit the two firsts I

811
00:36:51,480 --> 00:36:54,440
need to say that when your noise term

812
00:36:54,440 --> 00:36:57,660
n dot product hn have a probability of

813
00:36:57,660 --> 00:37:00,119
being one of one minus Epsilon over two

814
00:37:00,119 --> 00:37:03,240
then information Theory tells us that we

815
00:37:03,240 --> 00:37:05,820
need one over Epsilon Square sample to

816
00:37:05,820 --> 00:37:08,400
recover EP it does not tell you how you

817
00:37:08,400 --> 00:37:10,260
can do that but it just tell you that

818
00:37:10,260 --> 00:37:12,720
you need at least this number of samples

819
00:37:12,720 --> 00:37:15,660
I want to go into the details here but

820
00:37:15,660 --> 00:37:17,040
you can trust me

821
00:37:17,040 --> 00:37:19,740
so in statistical according to 1.0 with

822
00:37:19,740 --> 00:37:22,859
a p of size 1 and I recall here the

823
00:37:22,859 --> 00:37:25,320
graph that plots the number of needed

824
00:37:25,320 --> 00:37:26,760
priority checks and the number of

825
00:37:26,760 --> 00:37:30,660
available biodejection function of w and

826
00:37:30,660 --> 00:37:33,480
W the weight of H and here you can see

827
00:37:33,480 --> 00:37:36,060
that you need 2 to the power of 0.2 n

828
00:37:36,060 --> 00:37:38,180
priority check

829
00:37:38,180 --> 00:37:42,720
when p is of size s of size bigger

830
00:37:42,720 --> 00:37:45,119
um you see here that the crossing points

831
00:37:45,119 --> 00:37:47,099
between between the number variable of a

832
00:37:47,099 --> 00:37:48,960
variable parity check and the number of

833
00:37:48,960 --> 00:37:52,500
needed by to check to decoder will lead

834
00:37:52,500 --> 00:37:55,079
to a match you you will need a much

835
00:37:55,079 --> 00:37:57,420
lower number to check here the crossing

836
00:37:57,420 --> 00:38:00,420
point is at you need around 2 to the

837
00:38:00,420 --> 00:38:04,560
power of 0.1 n parity check so actually

838
00:38:04,560 --> 00:38:06,359
here what you have done is you have

839
00:38:06,359 --> 00:38:08,460
gained for example here a square root

840
00:38:08,460 --> 00:38:13,260
factor in in regard to a statistical

841
00:38:13,260 --> 00:38:15,900
recording 1.0 so this is in terms of

842
00:38:15,900 --> 00:38:17,940
information Theory it is quite good

843
00:38:17,940 --> 00:38:19,440
okay

844
00:38:19,440 --> 00:38:22,140
so now there is a problem because in

845
00:38:22,140 --> 00:38:24,480
statistical recording 1.0 P was of size

846
00:38:24,480 --> 00:38:27,060
one and thus to recover EP I could just

847
00:38:27,060 --> 00:38:30,300
do majority voting okay but no when p is

848
00:38:30,300 --> 00:38:33,180
of size s the question is how can I

849
00:38:33,180 --> 00:38:35,160
recover EP

850
00:38:35,160 --> 00:38:38,280
and so now what can we see is that in

851
00:38:38,280 --> 00:38:41,099
fact our problem is a well-known well

852
00:38:41,099 --> 00:38:43,680
studied problem in codebase cryptography

853
00:38:43,680 --> 00:38:47,339
it can be seen as a LPN problem so it is

854
00:38:47,339 --> 00:38:49,140
here that you will understand why we are

855
00:38:49,140 --> 00:38:52,740
reducing decoding to an Alban problem

856
00:38:52,740 --> 00:38:55,200
and the thing is to recover EP we will

857
00:38:55,200 --> 00:38:57,480
solve this Alban problem so you can see

858
00:38:57,480 --> 00:39:00,119
actually this why the product H has an

859
00:39:00,119 --> 00:39:03,119
LPN sample okay and so what is an LPN

860
00:39:03,119 --> 00:39:05,520
sample it's something where you have a

861
00:39:05,520 --> 00:39:07,320
secret s that you will want to try to

862
00:39:07,320 --> 00:39:10,380
recover and you have access to s dot

863
00:39:10,380 --> 00:39:13,380
product a plus uh an error term which

864
00:39:13,380 --> 00:39:15,660
will be biased towards zero okay and you

865
00:39:15,660 --> 00:39:17,820
have access to that and you have access

866
00:39:17,820 --> 00:39:18,780
to a

867
00:39:18,780 --> 00:39:21,599
and you try to recognize in our precise

868
00:39:21,599 --> 00:39:23,700
case s will be equal to EP

869
00:39:23,700 --> 00:39:26,339
a is will be equal to HP so this is

870
00:39:26,339 --> 00:39:28,020
known because you compute the body check

871
00:39:28,020 --> 00:39:31,200
and you can just take hnp and the noise

872
00:39:31,200 --> 00:39:34,260
term will be the end product hn and so

873
00:39:34,260 --> 00:39:35,880
it will follow a burner year parameter

874
00:39:35,880 --> 00:39:37,800
one minus Epsilon over two

875
00:39:37,800 --> 00:39:40,680
and so if you compute n parity check you

876
00:39:40,680 --> 00:39:43,980
have access to n LPN sample

877
00:39:43,980 --> 00:39:47,579
so one strategy you could make to solve

878
00:39:47,579 --> 00:39:49,859
this open problem is the most simple one

879
00:39:49,859 --> 00:39:51,839
it's you will try this you will do a

880
00:39:51,839 --> 00:39:53,400
naive search over the space of the

881
00:39:53,400 --> 00:39:56,520
solution so here you do an existing

882
00:39:56,520 --> 00:39:59,520
search other space of 2 to the power of

883
00:39:59,520 --> 00:40:02,099
s which is the length of your secret

884
00:40:02,099 --> 00:40:05,099
and what is it it corresponds to juice

885
00:40:05,099 --> 00:40:08,880
finding X such that y dot product H is

886
00:40:08,880 --> 00:40:13,200
equal to x dot HP the most often so here

887
00:40:13,200 --> 00:40:15,359
the most often in regard to all the

888
00:40:15,359 --> 00:40:17,760
samples you have so all the H you have

889
00:40:17,760 --> 00:40:20,040
and so the complexity of this algorithm

890
00:40:20,040 --> 00:40:23,700
is In N times 2 to the power of s so 2

891
00:40:23,700 --> 00:40:25,380
to the power of s here because you have

892
00:40:25,380 --> 00:40:28,260
to test 2 to the power of s vectors and

893
00:40:28,260 --> 00:40:30,780
N is because you have n samples so for

894
00:40:30,780 --> 00:40:33,960
each Vector here you have to compute

895
00:40:33,960 --> 00:40:36,480
this for n vectors

896
00:40:36,480 --> 00:40:37,980
and so

897
00:40:37,980 --> 00:40:40,740
um what you can do is actually this

898
00:40:40,740 --> 00:40:43,260
exhaustive search can be sped up with a

899
00:40:43,260 --> 00:40:45,240
fast Fourier transform okay I won't

900
00:40:45,240 --> 00:40:46,859
enter the detail but it's a standard

901
00:40:46,859 --> 00:40:49,380
thing a standard technique in your based

902
00:40:49,380 --> 00:40:51,720
cryptography and so your overall

903
00:40:51,720 --> 00:40:54,480
complexity is going to be S times 2 to

904
00:40:54,480 --> 00:40:55,859
the power of s

905
00:40:55,859 --> 00:40:58,079
so one thing which is important to

906
00:40:58,079 --> 00:41:01,380
mention here is that why you have a big

907
00:41:01,380 --> 00:41:04,140
gain between the naive search and the

908
00:41:04,140 --> 00:41:06,359
sped up native search is because n here

909
00:41:06,359 --> 00:41:09,900
will typically be will be exponential so

910
00:41:09,900 --> 00:41:11,760
it will be one of our Epsilon Square the

911
00:41:11,760 --> 00:41:13,980
number of samples you needed and when

912
00:41:13,980 --> 00:41:16,560
you optimize our parameters and you look

913
00:41:16,560 --> 00:41:19,740
at them you see that n will be around 2

914
00:41:19,740 --> 00:41:22,500
to the power of s so the nice search

915
00:41:22,500 --> 00:41:25,740
here will be of a complexity of 2 to the

916
00:41:25,740 --> 00:41:28,680
power of s square and so our first

917
00:41:28,680 --> 00:41:30,839
Fourier transform gain a square roots

918
00:41:30,839 --> 00:41:33,660
Factor uh in regard of the name search

919
00:41:33,660 --> 00:41:37,220
so this is quite a big gain

920
00:41:42,680 --> 00:41:46,079
which are complementary uh and we'll try

921
00:41:46,079 --> 00:41:49,200
to recovery p and we compute uh one of

922
00:41:49,200 --> 00:41:52,440
our Epsilon Square party check h of a w

923
00:41:52,440 --> 00:41:55,200
and N we will do that using standard

924
00:41:55,200 --> 00:41:57,599
techniques that come from the ISD that I

925
00:41:57,599 --> 00:41:59,040
will describe later

926
00:41:59,040 --> 00:42:01,380
and then you recover EP with fast

927
00:42:01,380 --> 00:42:02,880
forward Transformer and there's the

928
00:42:02,880 --> 00:42:05,460
complexity of your algorithm is used the

929
00:42:05,460 --> 00:42:07,440
cost of computing there's a priority

930
00:42:07,440 --> 00:42:09,119
checks and the cost of fast forward

931
00:42:09,119 --> 00:42:11,160
Transformer

932
00:42:11,160 --> 00:42:15,420
I know lastly I'm going to to present

933
00:42:15,420 --> 00:42:17,160
briefly a technique to compute low-wide

934
00:42:17,160 --> 00:42:20,460
parity checks on the part n okay

935
00:42:20,460 --> 00:42:22,680
so this technique was introduced by

936
00:42:22,680 --> 00:42:28,020
dumer in 86 and so uh the main idea is

937
00:42:28,020 --> 00:42:30,480
that if you take your priority check and

938
00:42:30,480 --> 00:42:32,280
you consider the parity checks that are

939
00:42:32,280 --> 00:42:34,260
restrained on any so you control this

940
00:42:34,260 --> 00:42:36,540
space you can notice that this space is

941
00:42:36,540 --> 00:42:38,760
a code of length n minus s and dimension

942
00:42:38,760 --> 00:42:41,520
and minus K okay so it can be written as

943
00:42:41,520 --> 00:42:44,520
the kernel of the Matrix H Prime

944
00:42:44,520 --> 00:42:47,700
so basically what it means it means that

945
00:42:47,700 --> 00:42:49,440
if you want to find the priority checks

946
00:42:49,440 --> 00:42:52,140
of Ray W on N the thing that you are

947
00:42:52,140 --> 00:42:54,359
going to try to do is to find a vector

948
00:42:54,359 --> 00:42:58,619
to find vectors H Prime of a w such that

949
00:42:58,619 --> 00:43:01,619
H Prime is in the kernel of that Matrix

950
00:43:01,619 --> 00:43:06,119
okay and so the main the ID to do that

951
00:43:06,119 --> 00:43:08,579
is just to animate all the vectors of aw

952
00:43:08,579 --> 00:43:11,700
but the merge ID is to use Collision

953
00:43:11,700 --> 00:43:14,280
so he will split the Matrix H Prime in

954
00:43:14,280 --> 00:43:16,560
two equal parts H1 Prime and H2 Prime

955
00:43:16,560 --> 00:43:20,099
and then he will notice that if you have

956
00:43:20,099 --> 00:43:23,460
two vectors of Y W over two H1 Prime and

957
00:43:23,460 --> 00:43:24,660
H2 Prime

958
00:43:24,660 --> 00:43:27,540
and you have a collision like that you

959
00:43:27,540 --> 00:43:30,300
have this then you can then you

960
00:43:30,300 --> 00:43:32,520
automatically have a vector H Prime

961
00:43:32,520 --> 00:43:35,099
which is a concatenation of H1 Prime and

962
00:43:35,099 --> 00:43:38,339
H2 Prime and it will be of YW such that

963
00:43:38,339 --> 00:43:42,180
H Prime is in the kernel of the Matrix H

964
00:43:42,180 --> 00:43:44,819
Prime okay so meaning that if you have a

965
00:43:44,819 --> 00:43:47,640
collision then you have you have a pi to

966
00:43:47,640 --> 00:43:50,819
check software W uh on end okay

967
00:43:50,819 --> 00:43:52,740
so the complexity of this method is

968
00:43:52,740 --> 00:43:55,079
basically the cost of enumerating all

969
00:43:55,079 --> 00:43:58,140
the vectors of a w over 2 plus the

970
00:43:58,140 --> 00:44:00,119
number of equation that will be produced

971
00:44:00,119 --> 00:44:01,859
by this method so basically the number

972
00:44:01,859 --> 00:44:03,839
of collision you will find

973
00:44:03,839 --> 00:44:05,400
and so

974
00:44:05,400 --> 00:44:07,680
um weight is interesting to look at that

975
00:44:07,680 --> 00:44:10,500
is because I can give you

976
00:44:10,500 --> 00:44:13,500
um an intuition on how or parameters

977
00:44:13,500 --> 00:44:16,920
will uh will be for when the rates are

978
00:44:16,920 --> 00:44:19,740
is smaller here for example

979
00:44:19,740 --> 00:44:22,140
uh what I can do and it is really

980
00:44:22,140 --> 00:44:25,500
interesting is that I can take W such

981
00:44:25,500 --> 00:44:28,079
that the cost of the enumeration will be

982
00:44:28,079 --> 00:44:29,760
equal to the number of equations

983
00:44:29,760 --> 00:44:33,720
produced so basically producing a one

984
00:44:33,720 --> 00:44:36,060
parity check will cost you one if you

985
00:44:36,060 --> 00:44:37,920
have those two terms that balances

986
00:44:37,920 --> 00:44:40,800
and so here you choose this with which

987
00:44:40,800 --> 00:44:42,420
is equal to this to balance these two

988
00:44:42,420 --> 00:44:44,760
terms and you take s which is equal to K

989
00:44:44,760 --> 00:44:47,220
over 2. so this is the choice just trust

990
00:44:47,220 --> 00:44:49,800
me and if you look at the complexity of

991
00:44:49,800 --> 00:44:52,560
Errol pen with this parameters you see

992
00:44:52,560 --> 00:44:54,060
that it will be

993
00:44:54,060 --> 00:44:57,839
in a square root of 2 to the power of so

994
00:44:57,839 --> 00:45:00,420
this gives you an intuition on y or

995
00:45:00,420 --> 00:45:02,220
algorithm is in the square root of the

996
00:45:02,220 --> 00:45:04,079
name search when air is smaller because

997
00:45:04,079 --> 00:45:05,460
you just you can just take this

998
00:45:05,460 --> 00:45:06,599
parameters

999
00:45:06,599 --> 00:45:09,240
and now to conclude

1000
00:45:09,240 --> 00:45:12,480
uh it is the first time in 60 years that

1001
00:45:12,480 --> 00:45:17,040
uh yes this is okay we use in fact we

1002
00:45:17,040 --> 00:45:18,720
use more advanced technique to compute

1003
00:45:18,720 --> 00:45:20,339
The Weight by the checks and W I've

1004
00:45:20,339 --> 00:45:22,920
presented here Doomer but we will use a

1005
00:45:22,920 --> 00:45:25,440
typically the best algorithm we use is

1006
00:45:25,440 --> 00:45:27,900
Beijing M12 come from Beijing M12 which

1007
00:45:27,900 --> 00:45:31,400
is uh which which is

1008
00:45:31,400 --> 00:45:34,079
which is something that is used in ISD

1009
00:45:34,079 --> 00:45:36,780
and it is important to notice that

1010
00:45:36,780 --> 00:45:39,359
similar techniques are used in lattice

1011
00:45:39,359 --> 00:45:41,579
in dual attacks in lattice and actually

1012
00:45:41,579 --> 00:45:44,520
you can really see that that's uh or

1013
00:45:44,520 --> 00:45:48,780
algorithm dualized the ISD and so why is

1014
00:45:48,780 --> 00:45:50,640
that is because the ISD compute lowered

1015
00:45:50,640 --> 00:45:52,920
codewords rely on Computing low weight

1016
00:45:52,920 --> 00:45:55,339
code words

1017
00:45:55,880 --> 00:45:58,500
parity checks and the resulting effect

1018
00:45:58,500 --> 00:46:02,940
is that when the ISD our algorithm is

1019
00:46:02,940 --> 00:46:05,579
good we gain a square root Factor when

1020
00:46:05,579 --> 00:46:11,119
the isds are good our algorithm

1021
00:46:15,680 --> 00:46:19,098
thank you very much

1022
00:46:24,200 --> 00:46:27,740
you have questions

1023
00:46:32,220 --> 00:46:36,060
so I'll ask a question uh you talk at

1024
00:46:36,060 --> 00:46:37,500
the beginning that you are focusing on

1025
00:46:37,500 --> 00:46:40,920
the other distance yeah uh where does it

1026
00:46:40,920 --> 00:46:42,960
come in your

1027
00:46:42,960 --> 00:46:44,819
EE

1028
00:46:44,819 --> 00:46:46,859
why do you focus on the other listening

1029
00:46:46,859 --> 00:46:49,140
oh that's coming in your algorithm well

1030
00:46:49,140 --> 00:46:52,200
uh it's so it's because so why do we

1031
00:46:52,200 --> 00:46:55,859
focus on those distance in fact all the

1032
00:46:55,859 --> 00:46:58,619
algorithms the isds and the everything

1033
00:46:58,619 --> 00:47:02,760
has been studied uh historically okay

1034
00:47:02,760 --> 00:47:04,380
I'm going here here yeah all those

1035
00:47:04,380 --> 00:47:07,440
algorithms and Etc have been studied at

1036
00:47:07,440 --> 00:47:09,060
this distance so it's kind of the

1037
00:47:09,060 --> 00:47:11,460
historical way of doing things and

1038
00:47:11,460 --> 00:47:13,680
actually there is also uh another

1039
00:47:13,680 --> 00:47:16,680
important point it is that

1040
00:47:16,680 --> 00:47:19,619
um typically when you look at signature

1041
00:47:19,619 --> 00:47:22,520
schemes for example Stern and charging

1042
00:47:22,520 --> 00:47:26,220
they place the the the security will

1043
00:47:26,220 --> 00:47:29,579
rely at uh on decoding uh decoding a

1044
00:47:29,579 --> 00:47:30,800
linear code

1045
00:47:30,800 --> 00:47:34,140
distance so it is it will be very very

1046
00:47:34,140 --> 00:47:35,760
interesting to study the Arsenal

1047
00:47:35,760 --> 00:47:37,920
distance for uh estimating the security

1048
00:47:37,920 --> 00:47:40,380
of a code-based signature and so with

1049
00:47:40,380 --> 00:47:44,160
the nist caller that will go in a few

1050
00:47:44,160 --> 00:47:46,380
months it's is going to be a major thing

1051
00:47:46,380 --> 00:47:48,920
to look at

1052
00:48:00,540 --> 00:48:02,210
okay

1053
00:48:02,210 --> 00:48:03,900
[Music]

1054
00:48:03,900 --> 00:48:06,240
let's go on with the next Talk of the

1055
00:48:06,240 --> 00:48:08,479
session

1056
00:48:08,520 --> 00:48:11,720
it will be online

1057
00:48:41,780 --> 00:48:45,560
good morning everyone

1058
00:48:46,740 --> 00:48:49,140
hi

1059
00:48:49,140 --> 00:48:51,660
sorry can I start already

1060
00:48:51,660 --> 00:48:54,240
yes yes sorry we we didn't have the

1061
00:48:54,240 --> 00:48:56,819
deals like now we have so the next stock

1062
00:48:56,819 --> 00:48:59,880
is a third is all you need extended

1063
00:48:59,880 --> 00:49:02,880
partial key exposure attack on CRT RSA

1064
00:49:02,880 --> 00:49:04,920
with additive excellent branding

1065
00:49:04,920 --> 00:49:09,859
by uh you are new and zoo zoo

1066
00:49:09,859 --> 00:49:13,859
and franzania standards and uh you are

1067
00:49:13,859 --> 00:49:16,140
Indian will give the talk please go

1068
00:49:16,140 --> 00:49:17,599
ahead

1069
00:49:17,599 --> 00:49:20,160
thank you

1070
00:49:20,160 --> 00:49:22,380
um thank you for your introduction

1071
00:49:22,380 --> 00:49:26,339
uh good morning welcome to this talk

1072
00:49:26,339 --> 00:49:28,980
um this is John to work with uh Napoli

1073
00:49:28,980 --> 00:49:31,260
and the sons of their standards it's

1074
00:49:31,260 --> 00:49:33,599
about the extended partial key Explorer

1075
00:49:33,599 --> 00:49:36,540
attack on crtrc it's addictive exponent

1076
00:49:36,540 --> 00:49:39,020
blending

1077
00:49:39,839 --> 00:49:42,900
so this talk consists of four parts the

1078
00:49:42,900 --> 00:49:45,599
first part is about the state of art the

1079
00:49:45,599 --> 00:49:47,760
Azure key Explorer attack

1080
00:49:47,760 --> 00:49:50,280
then next I will introduce you the

1081
00:49:50,280 --> 00:49:52,980
principle this uh extended departure key

1082
00:49:52,980 --> 00:49:55,560
Explorer attack the third part is about

1083
00:49:55,560 --> 00:49:58,680
the experimental results of this work

1084
00:49:58,680 --> 00:50:03,780
and in the end I will conclude this talk

1085
00:50:03,780 --> 00:50:06,540
so first of all I will just give you

1086
00:50:06,540 --> 00:50:09,060
some basic concepts related to this work

1087
00:50:09,060 --> 00:50:12,960
as you know for RSA and crprc they have

1088
00:50:12,960 --> 00:50:14,640
a different key components like a

1089
00:50:14,640 --> 00:50:18,000
private exponents modulus uh public

1090
00:50:18,000 --> 00:50:19,740
exponents

1091
00:50:19,740 --> 00:50:21,920
and

1092
00:50:21,920 --> 00:50:27,800
uh as an as a very widely used uh

1093
00:50:30,140 --> 00:50:33,599
blending it's just add a random multiple

1094
00:50:33,599 --> 00:50:35,900
of the group order to the private

1095
00:50:35,900 --> 00:50:39,240
exponent to hide the

1096
00:50:39,240 --> 00:50:44,220
private exponents and pay attention to

1097
00:50:44,220 --> 00:50:48,540
this RP and RQ this is the two uh

1098
00:50:48,540 --> 00:50:51,180
random blending factors we will need

1099
00:50:51,180 --> 00:50:55,980
this the next slides

1100
00:50:55,980 --> 00:50:58,680
and in general pke makes use of the

1101
00:50:58,680 --> 00:51:01,380
Redundant information among this uh

1102
00:51:01,380 --> 00:51:03,599
different components

1103
00:51:03,599 --> 00:51:07,500
and also here in please pay attention to

1104
00:51:07,500 --> 00:51:10,260
the K constants we call this a p or

1105
00:51:10,260 --> 00:51:14,040
error or k Prime on the L Prime

1106
00:51:14,040 --> 00:51:14,880
um

1107
00:51:14,880 --> 00:51:17,780
basically the pkes

1108
00:51:17,780 --> 00:51:21,859
use partial leakage either a consecutive

1109
00:51:21,859 --> 00:51:25,440
MSB or ilsp bits so for the key

1110
00:51:25,440 --> 00:51:28,859
components like a p or D or DP Prime DQ

1111
00:51:28,859 --> 00:51:31,020
Prime that's what we were using this

1112
00:51:31,020 --> 00:51:33,319
work

1113
00:51:33,420 --> 00:51:37,260
and the state of art of the pke attack

1114
00:51:37,260 --> 00:51:40,940
we categorized into two uh

1115
00:51:40,940 --> 00:51:44,460
categories so the on the left side you

1116
00:51:44,460 --> 00:51:47,400
can see the case there's no exponents

1117
00:51:47,400 --> 00:51:49,859
blending the current student world is

1118
00:51:49,859 --> 00:51:54,140
published at the Euro crypto this year

1119
00:51:54,140 --> 00:51:57,780
may at all the put forward the state of

1120
00:51:57,780 --> 00:52:00,660
art the managed to recover the full CRT

1121
00:52:00,660 --> 00:52:05,160
key with one third of the unbalanded DP

1122
00:52:05,160 --> 00:52:09,300
and the DQ either MSB or LSP bits

1123
00:52:09,300 --> 00:52:11,880
and on the right side as you can see

1124
00:52:11,880 --> 00:52:15,900
there are not too much Works been done

1125
00:52:15,900 --> 00:52:19,140
regarding the the database experiment

1126
00:52:19,140 --> 00:52:21,180
branding countermeier presence

1127
00:52:21,180 --> 00:52:25,559
so in this work we try to uh say in this

1128
00:52:25,559 --> 00:52:29,180
Gap we also managed to recover the full

1129
00:52:29,180 --> 00:52:34,020
30k using one third of a lmsp or LSP of

1130
00:52:34,020 --> 00:52:36,079
the Blended

1131
00:52:36,079 --> 00:52:39,119
exponents DP Prime and the decode Prime

1132
00:52:39,119 --> 00:52:43,760
I wish you the late next slides

1133
00:52:43,760 --> 00:52:48,480
uh also I need to First recap this Euro

1134
00:52:48,480 --> 00:52:50,760
crypto work because this is the base of

1135
00:52:50,760 --> 00:52:52,260
our work

1136
00:52:52,260 --> 00:52:55,079
so this your crypto work is uh

1137
00:52:55,079 --> 00:52:59,160
two-step approach first uh

1138
00:52:59,160 --> 00:53:03,180
they try to find the crtk constant okay

1139
00:53:03,180 --> 00:53:04,020
um

1140
00:53:04,020 --> 00:53:07,559
and then the second step is use this uh

1141
00:53:07,559 --> 00:53:11,720
found okay Constantine key to estimate

1142
00:53:11,720 --> 00:53:15,900
uh K times p and then a factor n to get

1143
00:53:15,900 --> 00:53:21,300
P using this also called approximate CCD

1144
00:53:21,300 --> 00:53:24,660
um and for the first step in the MSP

1145
00:53:24,660 --> 00:53:28,079
case it's a very simple to just resolve

1146
00:53:28,079 --> 00:53:30,839
a quadratic polynomial equation

1147
00:53:30,839 --> 00:53:35,520
and to get the key constant key

1148
00:53:35,520 --> 00:53:37,859
but in the LSP case

1149
00:53:37,859 --> 00:53:40,680
um they use the Cooper's mix method to

1150
00:53:40,680 --> 00:53:43,980
find the roots of a private polynomial

1151
00:53:43,980 --> 00:53:47,460
to get to the K constant K the second

1152
00:53:47,460 --> 00:53:52,859
step of for both MSB and RCB cases they

1153
00:53:52,859 --> 00:53:56,339
are very similar as just to perform the

1154
00:53:56,339 --> 00:53:58,559
lattice basis reduction and then solve

1155
00:53:58,559 --> 00:54:01,200
the root of a universe polynomial to get

1156
00:54:01,200 --> 00:54:04,380
the unknown parts of a DP and then

1157
00:54:04,380 --> 00:54:06,000
factor and

1158
00:54:06,000 --> 00:54:10,079
for both steps for both cases they can

1159
00:54:10,079 --> 00:54:15,200
manage to do this in polynomial time

1160
00:54:16,800 --> 00:54:20,040
so now I will introduce you the basic

1161
00:54:20,040 --> 00:54:24,000
idea of this epku attack so this is our

1162
00:54:24,000 --> 00:54:24,960
work

1163
00:54:24,960 --> 00:54:28,740
we follow this two-step approach but in

1164
00:54:28,740 --> 00:54:32,700
this case we need to first get the 30k

1165
00:54:32,700 --> 00:54:35,819
constant K Prime as I mentioned before

1166
00:54:35,819 --> 00:54:38,780
so this is a

1167
00:54:38,780 --> 00:54:43,200
depends on the plan Factor RP and RQ

1168
00:54:43,200 --> 00:54:44,819
um all right

1169
00:54:44,819 --> 00:54:46,980
uh

1170
00:54:46,980 --> 00:54:51,720
so the difference here is the MSP case

1171
00:54:51,720 --> 00:54:54,059
um we consider the two different

1172
00:54:54,059 --> 00:54:56,059
scenarios

1173
00:54:56,059 --> 00:54:59,339
the first scenarios that we have for

1174
00:54:59,339 --> 00:55:03,540
any a single uh the co-prime available

1175
00:55:03,540 --> 00:55:07,319
and then we have to factor uh

1176
00:55:07,319 --> 00:55:10,980
okay Prime Times L Prime then we can get

1177
00:55:10,980 --> 00:55:12,540
a k Prime

1178
00:55:12,540 --> 00:55:16,680
and this is a product of uh K Prime

1179
00:55:16,680 --> 00:55:20,400
Times L Prime is at the size of 1 6 of

1180
00:55:20,400 --> 00:55:23,520
the modulus and we have experimented

1181
00:55:23,520 --> 00:55:25,400
verified is uh

1182
00:55:25,400 --> 00:55:29,640
very feasible for and you know with a

1183
00:55:29,640 --> 00:55:31,920
very average PC

1184
00:55:31,920 --> 00:55:35,760
within like minutes or at most some

1185
00:55:35,760 --> 00:55:37,079
hours

1186
00:55:37,079 --> 00:55:41,400
and for the second scenario in the msap

1187
00:55:41,400 --> 00:55:45,059
case uh imagine we have like multiple DQ

1188
00:55:45,059 --> 00:55:47,880
Prime available and then wages computed

1189
00:55:47,880 --> 00:55:51,599
the GCT to get the K Prime

1190
00:55:51,599 --> 00:55:53,780
foreign

1191
00:55:53,780 --> 00:55:57,540
case it's very similar to the euro

1192
00:55:57,540 --> 00:56:00,180
crypto work we also use the Cooper's

1193
00:56:00,180 --> 00:56:03,180
Miss method to get P Prime so anything

1194
00:56:03,180 --> 00:56:06,119
is the polynomials different from the

1195
00:56:06,119 --> 00:56:08,160
Euro crypto one

1196
00:56:08,160 --> 00:56:11,598
and um

1197
00:56:12,300 --> 00:56:15,720
the second step of this APK attack the

1198
00:56:15,720 --> 00:56:18,300
similar to the euro crypto work so I

1199
00:56:18,300 --> 00:56:20,599
also use this uh

1200
00:56:20,599 --> 00:56:23,780
approximate gcda methods

1201
00:56:23,780 --> 00:56:27,480
based on the founded P consonant K Prime

1202
00:56:27,480 --> 00:56:31,500
we estimate K Prime Times P then we

1203
00:56:31,500 --> 00:56:34,220
Factor n to get through p

1204
00:56:34,220 --> 00:56:39,300
and for both MSP and the aerosp cases we

1205
00:56:39,300 --> 00:56:41,819
can do this step in a polynomial time

1206
00:56:41,819 --> 00:56:44,579
because it's similar to the your group

1207
00:56:44,579 --> 00:56:48,000
work the difference here is the LSB case

1208
00:56:48,000 --> 00:56:52,260
because we need to use uh model inverse

1209
00:56:52,260 --> 00:56:54,500
of a

1210
00:56:54,500 --> 00:56:58,200
item but the thing is that modular

1211
00:56:58,200 --> 00:57:00,960
inverse doesn't always exist so we need

1212
00:57:00,960 --> 00:57:04,140
to do some small trick there I'll show

1213
00:57:04,140 --> 00:57:07,559
you in a later slice

1214
00:57:07,559 --> 00:57:08,460
thank you

1215
00:57:08,460 --> 00:57:11,579
so the third parties about the

1216
00:57:11,579 --> 00:57:13,800
experimental results

1217
00:57:13,800 --> 00:57:16,500
as I said we need to verify whether it

1218
00:57:16,500 --> 00:57:20,220
is a factorization of a p Prime uh times

1219
00:57:20,220 --> 00:57:23,480
R Prime is a feasible

1220
00:57:23,480 --> 00:57:27,500
and so this is the first uh

1221
00:57:27,500 --> 00:57:30,480
scenario where we have any symbol decode

1222
00:57:30,480 --> 00:57:32,280
Prime available so we do this

1223
00:57:32,280 --> 00:57:37,079
factorization we experiment with three

1224
00:57:37,079 --> 00:57:41,839
different uh Cadence 1024 2048 and the

1225
00:57:41,839 --> 00:57:45,780
372 bits and also three typical blending

1226
00:57:45,780 --> 00:57:51,180
Factor lens 3264 and 128 bits and as you

1227
00:57:51,180 --> 00:57:53,940
can see for the factor in time so this

1228
00:57:53,940 --> 00:57:55,260
is the step one

1229
00:57:55,260 --> 00:57:59,700
we were talking about and uh yeah uh as

1230
00:57:59,700 --> 00:58:02,599
I said so with seconds minutes or hours

1231
00:58:02,599 --> 00:58:05,700
the set step two is the next basis

1232
00:58:05,700 --> 00:58:10,380
reductions like uh within seconds

1233
00:58:10,380 --> 00:58:13,200
more specifically for this factor in

1234
00:58:13,200 --> 00:58:16,140
time the picture I showed here is about

1235
00:58:16,140 --> 00:58:19,140
the 100 of this uh experiments with

1236
00:58:19,140 --> 00:58:22,500
different K and different uh blending

1237
00:58:22,500 --> 00:58:23,819
factors

1238
00:58:23,819 --> 00:58:27,000
and as you can see the factor in time in

1239
00:58:27,000 --> 00:58:28,640
this case is

1240
00:58:28,640 --> 00:58:32,760
n't uh seconds it was like 30 seconds or

1241
00:58:32,760 --> 00:58:34,319
so

1242
00:58:34,319 --> 00:58:39,540
and this was just a very average uh PC

1243
00:58:39,540 --> 00:58:44,760
and uh for the 2048 bits key uh the

1244
00:58:44,760 --> 00:58:47,460
factor in time uh becomes longer but

1245
00:58:47,460 --> 00:58:49,980
still like you know within minutes and

1246
00:58:49,980 --> 00:58:53,400
most 100 one and a half hours

1247
00:58:53,400 --> 00:58:57,000
but it was very rarely happens

1248
00:58:57,000 --> 00:59:01,260
and the longest K uh 3072

1249
00:59:01,260 --> 00:59:04,260
um in this case we need like hour so

1250
00:59:04,260 --> 00:59:07,819
dozens of hours

1251
00:59:08,460 --> 00:59:10,619
and then this is the second scenario

1252
00:59:10,619 --> 00:59:13,260
where we have multiple decode primer

1253
00:59:13,260 --> 00:59:14,119
available

1254
00:59:14,119 --> 00:59:19,140
uh as you can see uh the result here uh

1255
00:59:19,140 --> 00:59:23,220
this step for one uh depending on how

1256
00:59:23,220 --> 00:59:25,200
many difficult Prime available the

1257
00:59:25,200 --> 00:59:28,799
successful probability is different we

1258
00:59:28,799 --> 00:59:33,540
tried from 2 to 10 uh Deco primer

1259
00:59:33,540 --> 00:59:37,140
available as you can see if you have

1260
00:59:37,140 --> 00:59:40,619
more than like five Deco Prime available

1261
00:59:40,619 --> 00:59:44,059
then the success probability is about

1262
00:59:44,059 --> 00:59:48,180
uh already reach one

1263
00:59:48,180 --> 00:59:52,260
and we also did some uh theoretical uh

1264
00:59:52,260 --> 00:59:55,500
calculation and the experiments as you

1265
00:59:55,500 --> 00:59:58,020
can see this red wines the expected

1266
00:59:58,020 --> 01:00:01,040
values of this successful probability

1267
01:00:01,040 --> 01:00:05,460
and our experiments are very close to

1268
01:00:05,460 --> 01:00:08,700
the expected values

1269
01:00:08,700 --> 01:00:12,980
and to be more specific

1270
01:00:13,200 --> 01:00:16,980
imagine if you only have two uh Deco

1271
01:00:16,980 --> 01:00:20,400
primer available uh actually we can do

1272
01:00:20,400 --> 01:00:23,160
this with a small Brute Force efforts

1273
01:00:23,160 --> 01:00:27,000
without uh more Deco primer available

1274
01:00:27,000 --> 01:00:31,799
and that's called we have uh two okay

1275
01:00:31,799 --> 01:00:35,040
constants L1 Prime and error two Prime

1276
01:00:35,040 --> 01:00:38,000
from these two decode Prime

1277
01:00:38,000 --> 01:00:41,880
and we calculate the gcd of them we

1278
01:00:41,880 --> 01:00:44,520
experiment to verified because of this F

1279
01:00:44,520 --> 01:00:47,400
value is very small so basically after

1280
01:00:47,400 --> 01:00:48,980
we uh

1281
01:00:48,980 --> 01:00:53,220
calculate our Prime and uh

1282
01:00:53,220 --> 01:00:57,480
R2 Prime we can do brute force of this F

1283
01:00:57,480 --> 01:01:01,140
then we don't need the more article

1284
01:01:01,140 --> 01:01:03,059
Prime

1285
01:01:03,059 --> 01:01:07,079
also for 2048 bits as you can see uh

1286
01:01:07,079 --> 01:01:10,559
most of them are below 50

1287
01:01:10,559 --> 01:01:15,619
and so even with the longest key also uh

1288
01:01:15,619 --> 01:01:20,420
uh for most of them they are below 100

1289
01:01:21,000 --> 01:01:24,420
and this is the third scenario uh the

1290
01:01:24,420 --> 01:01:27,020
LSP case there's not too much to say

1291
01:01:27,020 --> 01:01:30,440
because both step one and step with two

1292
01:01:30,440 --> 01:01:33,680
uh they're using unless spaces reduction

1293
01:01:33,680 --> 01:01:37,020
and as you can see basically they are

1294
01:01:37,020 --> 01:01:41,119
like within uh minutes or seconds

1295
01:01:42,780 --> 01:01:46,440
but it's a way of further looking to uh

1296
01:01:46,440 --> 01:01:48,540
what will uh

1297
01:01:48,540 --> 01:01:52,619
uh be the impacts on the real world

1298
01:01:52,619 --> 01:01:57,540
uh how well this Epp attack uh behave in

1299
01:01:57,540 --> 01:02:02,700
the real life so we consider to

1300
01:02:02,700 --> 01:02:04,920
demonstrate an application of this

1301
01:02:04,920 --> 01:02:08,400
Eppley attack the real world's uh as I

1302
01:02:08,400 --> 01:02:11,339
show you in the next slides

1303
01:02:11,339 --> 01:02:13,799
because as you know the partial K

1304
01:02:13,799 --> 01:02:17,720
leakage sources for

1305
01:02:17,720 --> 01:02:20,460
particular Explorer attacks mainly from

1306
01:02:20,460 --> 01:02:23,520
like a channel text or code boots or

1307
01:02:23,520 --> 01:02:26,760
micro architecture attacks and in this

1308
01:02:26,760 --> 01:02:29,299
work we were considering side Channel

1309
01:02:29,299 --> 01:02:32,579
leakage and just give you some

1310
01:02:32,579 --> 01:02:35,940
background of research Channel text that

1311
01:02:35,940 --> 01:02:38,099
there are different such channels like

1312
01:02:38,099 --> 01:02:39,839
the execution timing or power

1313
01:02:39,839 --> 01:02:43,680
consumption uh in the song and we

1314
01:02:43,680 --> 01:02:45,359
normally consider there are four

1315
01:02:45,359 --> 01:02:48,660
different uh stages like firstly you

1316
01:02:48,660 --> 01:02:51,359
need to marry the size analysis uh and

1317
01:02:51,359 --> 01:02:54,020
then you do pre-processing like

1318
01:02:54,020 --> 01:02:58,020
alignment or filtering and then you can

1319
01:02:58,020 --> 01:03:00,299
do the session analysis

1320
01:03:00,299 --> 01:03:03,780
the last step was our last stages so we

1321
01:03:03,780 --> 01:03:06,119
call the Post analysis that's what we do

1322
01:03:06,119 --> 01:03:09,420
this uh EPT attack after you get the

1323
01:03:09,420 --> 01:03:13,859
partial uh such a leakage how can you uh

1324
01:03:13,859 --> 01:03:16,440
get the full key

1325
01:03:16,440 --> 01:03:19,020
and there are also different session uh

1326
01:03:19,020 --> 01:03:21,780
Tech measures like simple power analysis

1327
01:03:21,780 --> 01:03:24,299
or differential power analysis terminal

1328
01:03:24,299 --> 01:03:26,520
attack or people learning basis such as

1329
01:03:26,520 --> 01:03:28,619
attacks that's what we will use in this

1330
01:03:28,619 --> 01:03:30,119
work

1331
01:03:30,119 --> 01:03:33,420
there are also two types of uh

1332
01:03:33,420 --> 01:03:36,480
attacks we call the profanium ones and

1333
01:03:36,480 --> 01:03:39,900
long performance in this work we

1334
01:03:39,900 --> 01:03:42,359
consider the profaning ones

1335
01:03:42,359 --> 01:03:44,400
and

1336
01:03:44,400 --> 01:03:46,740
regarding the potential impacts on our

1337
01:03:46,740 --> 01:03:48,780
real life

1338
01:03:48,780 --> 01:03:51,839
especially for embedded devices the

1339
01:03:51,839 --> 01:03:55,520
often use CRT for performance

1340
01:03:55,520 --> 01:03:59,099
consideration and also most of them are

1341
01:03:59,099 --> 01:04:01,319
using this addictive experiment because

1342
01:04:01,319 --> 01:04:04,380
it's very easy to implement and also the

1343
01:04:04,380 --> 01:04:06,740
cost is not too much

1344
01:04:06,740 --> 01:04:09,780
as I said it is a very common continent

1345
01:04:09,780 --> 01:04:11,760
against such an attacks

1346
01:04:11,760 --> 01:04:16,140
and also by the end of last year uh

1347
01:04:16,140 --> 01:04:20,220
based on the data from a young vehicle

1348
01:04:20,220 --> 01:04:23,099
they circulates uh more than around

1349
01:04:23,099 --> 01:04:26,180
about 12 winning cheap cars

1350
01:04:26,180 --> 01:04:31,380
internationally and for those cars uh RC

1351
01:04:31,380 --> 01:04:34,680
or crtrc are used by default

1352
01:04:34,680 --> 01:04:38,940
so uh can you imagine what if an

1353
01:04:38,940 --> 01:04:43,400
attacker can obtain one sort of this uh

1354
01:04:43,400 --> 01:04:46,859
MSP or LCP if the Blended the DP Prime

1355
01:04:46,859 --> 01:04:48,960
and the co-prime

1356
01:04:48,960 --> 01:04:52,799
I will show you now so uh in this work

1357
01:04:52,799 --> 01:04:54,680
we consider a Montgomery letter

1358
01:04:54,680 --> 01:04:58,460
explanation of uh secure

1359
01:04:58,460 --> 01:05:02,160
microcontroller the Cadence is 2048 and

1360
01:05:02,160 --> 01:05:05,640
the user identical planning factor is 64

1361
01:05:05,640 --> 01:05:06,780
bits alone

1362
01:05:06,780 --> 01:05:10,319
and we use this deep learning such a

1363
01:05:10,319 --> 01:05:17,220
text to recover uh uh 411 bit MSB or 441

1364
01:05:17,220 --> 01:05:21,960
bits aerosp of the Blended DP primary Co

1365
01:05:21,960 --> 01:05:24,440
Prime uh we consider

1366
01:05:24,440 --> 01:05:28,920
10 attack case in each scenario

1367
01:05:28,920 --> 01:05:32,220
as you can see this picture shows the

1368
01:05:32,220 --> 01:05:35,280
Pinnacles and validation accuracy of

1369
01:05:35,280 --> 01:05:38,640
this deep learning such attacks and

1370
01:05:38,640 --> 01:05:42,720
after this we got the MSP the one

1371
01:05:42,720 --> 01:05:46,500
certain MSB or l-speed DP program and

1372
01:05:46,500 --> 01:05:49,380
the decagram normally apply this EPA

1373
01:05:49,380 --> 01:05:53,520
attack to recover the full uh crtk so

1374
01:05:53,520 --> 01:05:58,440
for all these 10 MSP case we recover the

1375
01:05:58,440 --> 01:06:01,260
4K the step one the factoring time is

1376
01:06:01,260 --> 01:06:05,220
within like seconds or minutes

1377
01:06:05,220 --> 01:06:06,570
foreign

1378
01:06:06,570 --> 01:06:07,819
[Music]

1379
01:06:07,819 --> 01:06:11,700
s because we managed to recover all the

1380
01:06:11,700 --> 01:06:14,540
full case

1381
01:06:14,640 --> 01:06:17,880
so to conclude my talk uh in this work

1382
01:06:17,880 --> 01:06:20,640
we managed to Pro to forward the state

1383
01:06:20,640 --> 01:06:22,920
about uh regarding the this way

1384
01:06:22,920 --> 01:06:25,260
experiment Blended using only one third

1385
01:06:25,260 --> 01:06:29,400
MSB or iosp of addictive landed GP

1386
01:06:29,400 --> 01:06:32,579
primer under the Q Prime to uh recover

1387
01:06:32,579 --> 01:06:34,140
the 4K

1388
01:06:34,140 --> 01:06:36,900
the results are similar to the European

1389
01:06:36,900 --> 01:06:42,420
one uh where Landing is not present so

1390
01:06:42,420 --> 01:06:45,059
in this sense we don't need more bits

1391
01:06:45,059 --> 01:06:47,819
but of course there's a price to pay so

1392
01:06:47,819 --> 01:06:50,400
we either need to factor an integer at

1393
01:06:50,400 --> 01:06:53,760
the size of 1 6 of the modulus or we do

1394
01:06:53,760 --> 01:06:55,140
uh

1395
01:06:55,140 --> 01:07:00,839
she said using multiple Deco Prime

1396
01:07:00,839 --> 01:07:05,339
and when we apply this eurocode for idea

1397
01:07:05,339 --> 01:07:07,920
to this additive blending scenario where

1398
01:07:07,920 --> 01:07:11,280
we had to overcome some difficulties

1399
01:07:11,280 --> 01:07:14,220
uh because based on the loan information

1400
01:07:14,220 --> 01:07:18,839
we can calculate the modular sum P prime

1401
01:07:18,839 --> 01:07:21,480
plus r Prime of the e but we

1402
01:07:21,480 --> 01:07:25,260
uh it's not trivial to derive K Prime

1403
01:07:25,260 --> 01:07:28,799
Times uh plus L Prime

1404
01:07:28,799 --> 01:07:33,480
also it's not uh travel to derive a p

1405
01:07:33,480 --> 01:07:36,359
times L from the

1406
01:07:36,359 --> 01:07:38,960
modular

1407
01:07:38,960 --> 01:07:43,799
products uh K Prime Times L Prime

1408
01:07:43,799 --> 01:07:47,700
in the LCP case as I mentioned before uh

1409
01:07:47,700 --> 01:07:52,859
this gcd of two known Parts

1410
01:07:52,859 --> 01:07:56,940
um it's not always equal to one so we

1411
01:07:56,940 --> 01:08:01,920
had to find out the trick to uh solve

1412
01:08:01,920 --> 01:08:03,260
this problem

1413
01:08:03,260 --> 01:08:06,780
and the last thing is about the

1414
01:08:06,780 --> 01:08:10,020
advantage of this Epp attack especially

1415
01:08:10,020 --> 01:08:13,500
for uh embedded devices because as I

1416
01:08:13,500 --> 01:08:16,859
said uh imagine uh you only need to

1417
01:08:16,859 --> 01:08:20,160
mirror one serve the exponentiation uh

1418
01:08:20,160 --> 01:08:23,460
you don't need to capture because for

1419
01:08:23,460 --> 01:08:26,060
such an attacks the summer months uh

1420
01:08:26,060 --> 01:08:30,779
times uh very uh significant

1421
01:08:30,779 --> 01:08:33,420
um so this will greatly speed up the

1422
01:08:33,420 --> 01:08:34,880
acquisition

1423
01:08:34,880 --> 01:08:37,859
uh based on our experiments we uh

1424
01:08:37,859 --> 01:08:40,620
practically verify this

1425
01:08:40,620 --> 01:08:43,500
we don't need to use the

1426
01:08:43,500 --> 01:08:46,439
same measurement for DP Prime and decode

1427
01:08:46,439 --> 01:08:48,540
Prime we can use different environments

1428
01:08:48,540 --> 01:08:53,640
targets DP Prime and or the co-prime

1429
01:08:53,640 --> 01:08:57,719
there's an open problem left it's uh how

1430
01:08:57,719 --> 01:09:00,299
can we deal with the early space of the

1431
01:09:00,299 --> 01:09:03,420
BP Prime and the co Prime in this search

1432
01:09:03,420 --> 01:09:06,198
Channel application we did here we just

1433
01:09:06,198 --> 01:09:12,859
recover more traces and then we try to

1434
01:09:12,859 --> 01:09:16,580
solve this problem but we need

1435
01:09:16,580 --> 01:09:21,060
uh Aaron is error-free DP prominent D Co

1436
01:09:21,060 --> 01:09:23,299
Prime

1437
01:09:23,640 --> 01:09:26,279
thanks for your attention I'd like to

1438
01:09:26,279 --> 01:09:29,179
take your questions

1439
01:09:33,479 --> 01:09:35,219
thank you for the talk do you have

1440
01:09:35,219 --> 01:09:37,698
questions

1441
01:09:40,140 --> 01:09:42,238
no question

1442
01:09:42,238 --> 01:09:46,160
okay then thanks the picture again

1443
01:09:46,799 --> 01:09:49,519
thank you

1444
01:09:51,660 --> 01:09:54,440
thank you

1445
01:10:17,820 --> 01:10:22,040
so now is the last Talk of the session

1446
01:10:22,679 --> 01:10:25,340
foreign

1447
01:10:26,360 --> 01:10:29,940
yes we can hear you okay can you see my

1448
01:10:29,940 --> 01:10:32,400
slides right now we can see your slice

1449
01:10:32,400 --> 01:10:34,440
we cannot see you but we can see your

1450
01:10:34,440 --> 01:10:38,159
studies yes okay okay so can I start now

1451
01:10:38,159 --> 01:10:40,920
yeah so now we're gonna talk about

1452
01:10:40,920 --> 01:10:43,020
strength stretching Cube attacks

1453
01:10:43,020 --> 01:10:45,060
improved methods to recover massive

1454
01:10:45,060 --> 01:10:48,679
scrappies but it's

1455
01:10:48,920 --> 01:10:54,120
making one and uh give the talk please

1456
01:10:54,120 --> 01:10:55,340
go ahead

1457
01:10:55,340 --> 01:10:58,140
okay thanks for the intro thanks for the

1458
01:10:58,140 --> 01:11:00,540
introduction and hello everyone my name

1459
01:11:00,540 --> 01:11:03,840
is and today I will present our work in

1460
01:11:03,840 --> 01:11:05,219
the administrating Cube attacks

1461
01:11:05,219 --> 01:11:07,260
including videos to recover massive

1462
01:11:07,260 --> 01:11:09,480
super products and this is a joint work

1463
01:11:09,480 --> 01:11:11,820
with Kai who but Korean and the amazing

1464
01:11:11,820 --> 01:11:13,620
one

1465
01:11:13,620 --> 01:11:16,080
uh this is the outline of our

1466
01:11:16,080 --> 01:11:18,060
presentation I will introduce our work

1467
01:11:18,060 --> 01:11:20,940
from the following family specs first

1468
01:11:20,940 --> 01:11:23,580
our graphically introduce us some

1469
01:11:23,580 --> 01:11:25,980
background knowledge about a cube attack

1470
01:11:25,980 --> 01:11:28,980
and the super quality recovery so then I

1471
01:11:28,980 --> 01:11:31,380
will analyze the alternator of the

1472
01:11:31,380 --> 01:11:33,960
National Monument predictions and show

1473
01:11:33,960 --> 01:11:36,179
our improvements finally our

1474
01:11:36,179 --> 01:11:38,820
improvements lead to new results of

1475
01:11:38,820 --> 01:11:40,920
super popular recovery and this further

1476
01:11:40,920 --> 01:11:43,920
requires us to design a new method for

1477
01:11:43,920 --> 01:11:46,020
recovering keys from a massive silver

1478
01:11:46,020 --> 01:11:47,540
pod

1479
01:11:47,540 --> 01:11:50,760
okay so the Cuban talk was proposed by

1480
01:11:50,760 --> 01:11:53,280
Dina and xiaomi at eurogram to Jerusalem

1481
01:11:53,280 --> 01:11:56,940
and I and yeah symmetric server can be

1482
01:11:56,940 --> 01:11:59,760
expressed as a Boolean function of the

1483
01:11:59,760 --> 01:12:02,040
secret secret arrivals okay under the

1484
01:12:02,040 --> 01:12:05,219
public of Rivals X the coefficient of a

1485
01:12:05,219 --> 01:12:08,159
cube term xq in this building function

1486
01:12:08,159 --> 01:12:10,380
is called the supercalia and its value

1487
01:12:10,380 --> 01:12:12,179
can be calculated according to the

1488
01:12:12,179 --> 01:12:16,020
Mobius trust flow in the online phase of

1489
01:12:16,020 --> 01:12:18,780
the Cuban tiger the attacker can fix the

1490
01:12:18,780 --> 01:12:21,300
non-cube of variables to constants and

1491
01:12:21,300 --> 01:12:23,699
recover the interactive expression of

1492
01:12:23,699 --> 01:12:26,219
the super poly saying in the RFA is he

1493
01:12:26,219 --> 01:12:28,140
can calculate the value of the super

1494
01:12:28,140 --> 01:12:30,719
quality and establish an equation for

1495
01:12:30,719 --> 01:12:32,940
okay and some information okay can be

1496
01:12:32,940 --> 01:12:36,440
extracted by solving the equation

1497
01:12:36,440 --> 01:12:39,239
uh in the early stage of the cube attack

1498
01:12:39,239 --> 01:12:42,840
only linear or quadratic or credential

1499
01:12:42,840 --> 01:12:46,080
is many targeted later thanks to the

1500
01:12:46,080 --> 01:12:48,300
introduction of the division property

1501
01:12:48,300 --> 01:12:50,940
and the under the MRT modeling method

1502
01:12:50,940 --> 01:12:53,280
even complex super qualities can be

1503
01:12:53,280 --> 01:12:56,100
recovered practically the division

1504
01:12:56,100 --> 01:12:59,239
property can also be remedicated from

1505
01:12:59,239 --> 01:13:01,860
algebraic perspective and this leads

1506
01:13:01,860 --> 01:13:03,960
assisted to the so-called monomial

1507
01:13:03,960 --> 01:13:07,440
prediction technique at Asia Crypt 2021

1508
01:13:07,440 --> 01:13:10,340
way to propose the framework called

1509
01:13:10,340 --> 01:13:12,960
National monomer predictions

1510
01:13:12,960 --> 01:13:14,940
back to menu the event and the

1511
01:13:14,940 --> 01:13:17,400
conquerors strategy with the monomial

1512
01:13:17,400 --> 01:13:20,040
prediction technique and our work is the

1513
01:13:20,040 --> 01:13:23,100
natural follow-up to their work

1514
01:13:23,100 --> 01:13:24,960
the conventional database the duration

1515
01:13:24,960 --> 01:13:27,659
property was originally proposed by the

1516
01:13:27,659 --> 01:13:29,520
beta Lab at other bit level

1517
01:13:29,520 --> 01:13:32,040
generalization of the integral property

1518
01:13:32,040 --> 01:13:34,440
and later to the error showed that it

1519
01:13:34,440 --> 01:13:36,719
can achieve perfect like it can achieve

1520
01:13:36,719 --> 01:13:40,100
perfect accuracy in claiming the

1521
01:13:40,100 --> 01:13:42,719
e-claiming and that specific set of

1522
01:13:42,719 --> 01:13:45,600
monomials of the import is not contained

1523
01:13:45,600 --> 01:13:49,920
by the area of output bit however cbdp

1524
01:13:49,920 --> 01:13:52,980
cannot be used to predict the presence

1525
01:13:52,980 --> 01:13:57,860
of a monomial of the Imports foreign

1526
01:14:03,140 --> 01:14:06,420
function setting xq y for monomial the

1527
01:14:06,420 --> 01:14:08,520
monomial prediction our division

1528
01:14:08,520 --> 01:14:11,280
property allows two predictive for X2

1529
01:14:11,280 --> 01:14:15,060
appears in the F of Y to V by counting

1530
01:14:15,060 --> 01:14:17,880
the number of monomial or division shows

1531
01:14:17,880 --> 01:14:20,340
and for cubicle next to you if we can

1532
01:14:20,340 --> 01:14:23,340
determine all the all the possible GK

1533
01:14:23,340 --> 01:14:25,679
xpu contained by F then one can

1534
01:14:25,679 --> 01:14:28,500
determine the super poly accordingly

1535
01:14:28,500 --> 01:14:30,179
foreign

1536
01:14:30,179 --> 01:14:33,179
structure

1537
01:14:40,500 --> 01:14:42,360
actually the last genome monomial

1538
01:14:42,360 --> 01:14:45,060
predictions consists of two components

1539
01:14:45,060 --> 01:14:47,280
which we call the coefficient of solver

1540
01:14:47,280 --> 01:14:49,920
and the atomic expander the coefficient

1541
01:14:49,920 --> 01:14:51,620
is so very smelly

1542
01:14:51,620 --> 01:14:53,940
responsible for computing the super

1543
01:14:53,940 --> 01:14:57,780
quality for for term waiting on a time

1544
01:14:57,780 --> 01:15:00,239
limit while the term expander is to

1545
01:15:00,239 --> 01:15:03,000
expand the uh also of the terms into

1546
01:15:03,000 --> 01:15:05,880
terms of very different I think CO2

1547
01:15:05,880 --> 01:15:07,980
parts are run iteratively until no

1548
01:15:07,980 --> 01:15:11,239
answer the term is remain

1549
01:15:12,620 --> 01:15:15,360
in particular the next genome on our

1550
01:15:15,360 --> 01:15:18,719
predictions utilizes mono prediction to

1551
01:15:18,719 --> 01:15:20,400
build a term expander and the

1552
01:15:20,400 --> 01:15:22,980
coefficient dissolver however as the

1553
01:15:22,980 --> 01:15:25,860
name of Branch grows counting the number

1554
01:15:25,860 --> 01:15:28,620
of monomial trails that was will become

1555
01:15:28,620 --> 01:15:31,620
impractical so consequently during each

1556
01:15:31,620 --> 01:15:34,020
iteration too many terms are determined

1557
01:15:34,020 --> 01:15:37,260
as unsolved by the coefficient solver

1558
01:15:37,260 --> 01:15:40,440
and this is at the cost of wasting a lot

1559
01:15:40,440 --> 01:15:41,480
of time

1560
01:15:41,480 --> 01:15:44,640
example we would like to regionalize the

1561
01:15:44,640 --> 01:15:46,920
coefficients over next I will introduce

1562
01:15:46,920 --> 01:15:49,199
the magnitude I will introduce the main

1563
01:15:49,199 --> 01:15:52,140
contribution of our work namely the few

1564
01:15:52,140 --> 01:15:55,520
stage coefficient of solver

1565
01:15:55,640 --> 01:15:58,440
for clarity the target of our

1566
01:15:58,440 --> 01:16:01,560
coefficient server is always us is

1567
01:16:01,560 --> 01:16:04,860
always around the cryptographic function

1568
01:16:04,860 --> 01:16:09,500
f with excellent KL Imports and K

1569
01:16:09,500 --> 01:16:12,480
here K and X you know to the secret and

1570
01:16:12,480 --> 01:16:15,360
the public variables respectively the

1571
01:16:15,360 --> 01:16:19,620
output of the Iceland is determined as S

1572
01:16:19,620 --> 01:16:23,880
Plus s i plus y we always fix x2u as the

1573
01:16:23,880 --> 01:16:27,600
cubital and the pi u r Sr as as the

1574
01:16:27,600 --> 01:16:30,480
output monomial of astronaut so

1575
01:16:30,480 --> 01:16:34,199
non-cable variables is set to a scenario

1576
01:16:34,199 --> 01:16:37,080
variables as they're 2-0 and the goal of

1577
01:16:37,080 --> 01:16:39,120
our coefficients so various to compute

1578
01:16:39,120 --> 01:16:42,600
the super quality of XTU in pi over Isa

1579
01:16:42,600 --> 01:16:45,360
in particular where it should kill us

1580
01:16:45,360 --> 01:16:48,620
now the other constants

1581
01:16:50,360 --> 01:16:52,800
inspired by the Divine and Conquest

1582
01:16:52,800 --> 01:16:55,020
strategy we would like first would like

1583
01:16:55,020 --> 01:16:58,860
to divide the piers are into terms of

1584
01:16:58,860 --> 01:17:01,320
items around and of course I am sure to

1585
01:17:01,320 --> 01:17:04,739
be less than r with first investigate

1586
01:17:04,739 --> 01:17:07,199
which terms of items around will

1587
01:17:07,199 --> 01:17:09,480
contribute to the delighted Super Body

1588
01:17:09,480 --> 01:17:12,179
and this directly gives rise to the

1589
01:17:12,179 --> 01:17:15,900
concept of variable terms a term of I am

1590
01:17:15,900 --> 01:17:20,159
strong a term of RMS term of rms1 is

1591
01:17:20,159 --> 01:17:22,920
valuable term if there are other number

1592
01:17:22,920 --> 01:17:26,580
of monomial shows from this term to iOS

1593
01:17:26,580 --> 01:17:28,800
and we call this condition connection

1594
01:17:28,800 --> 01:17:30,179
condition a

1595
01:17:30,179 --> 01:17:32,880
and they are showing this Vector W such

1596
01:17:32,880 --> 01:17:36,239
as q2w XTU has a monomial show to this

1597
01:17:36,239 --> 01:17:38,699
term and this is called condition B it

1598
01:17:38,699 --> 01:17:41,940
should be noted that I am here is a

1599
01:17:41,940 --> 01:17:44,159
fixed value for specific server for

1600
01:17:44,159 --> 01:17:47,280
example we message I am to 90 for

1601
01:17:47,280 --> 01:17:49,519
children

1602
01:17:53,100 --> 01:17:55,199
and and now we can divide our

1603
01:17:55,199 --> 01:17:57,600
coefficient server into two stages

1604
01:17:57,600 --> 01:18:00,000
after the first stage we try to recover

1605
01:18:00,000 --> 01:18:02,760
the valuable terms of IMS around within

1606
01:18:02,760 --> 01:18:05,640
our time limit and at the second stage

1607
01:18:05,640 --> 01:18:08,040
we use the monomial prediction technique

1608
01:18:08,040 --> 01:18:10,080
to recover the super quality for each

1609
01:18:10,080 --> 01:18:12,179
valuable term and we then collect the

1610
01:18:12,179 --> 01:18:13,739
results

1611
01:18:13,739 --> 01:18:16,260
since I am is usually very small the

1612
01:18:16,260 --> 01:18:18,000
second stage can always be done very

1613
01:18:18,000 --> 01:18:20,699
quickly so so most of the time consuming

1614
01:18:20,699 --> 01:18:23,219
Parts should be the first stage and here

1615
01:18:23,219 --> 01:18:25,400
for the first stage is not completed

1616
01:18:25,400 --> 01:18:28,620
within the time limit we say the with

1617
01:18:28,620 --> 01:18:33,540
the term igr is unsolved

1618
01:18:35,400 --> 01:18:38,100
now the remaining problem is how to

1619
01:18:38,100 --> 01:18:41,040
model valuable terms condition a can be

1620
01:18:41,040 --> 01:18:43,320
modeled by the model by the monomial

1621
01:18:43,320 --> 01:18:45,179
prediction perfectly well for condition

1622
01:18:45,179 --> 01:18:47,699
B you'll need a monomial prediction

1623
01:18:47,699 --> 01:18:51,120
seems only precise this inspires us to

1624
01:18:51,120 --> 01:18:54,800
trade some accuracy for efficiency

1625
01:18:54,800 --> 01:18:59,360
and this is also our motivation

1626
01:19:00,840 --> 01:19:03,659
before introducing our new modeling

1627
01:19:03,659 --> 01:19:06,360
method let me first reintroduce our flag

1628
01:19:06,360 --> 01:19:08,699
technique this is quite similar to the

1629
01:19:08,699 --> 01:19:11,219
one proposed by one idle art crypto

1630
01:19:11,219 --> 01:19:15,659
2018. specifically for each beat b of

1631
01:19:15,659 --> 01:19:18,060
the output state of ice round we

1632
01:19:18,060 --> 01:19:20,880
assigned an additional flat there are

1633
01:19:20,880 --> 01:19:22,980
three choices for the flag

1634
01:19:22,980 --> 01:19:26,300
zero c means B is a constant zero bit

1635
01:19:26,300 --> 01:19:30,300
Delta means the F of B involves at least

1636
01:19:30,300 --> 01:19:32,280
one tube of variable

1637
01:19:32,280 --> 01:19:36,659
1C means B is now zero and if NF doesn't

1638
01:19:36,659 --> 01:19:40,759
involve any cube of variables

1639
01:19:40,800 --> 01:19:43,739
we can also Define the following basic

1640
01:19:43,739 --> 01:19:45,960
we can also Define the following basic

1641
01:19:45,960 --> 01:19:47,340
operations

1642
01:19:47,340 --> 01:19:50,280
for the computation of flux and when the

1643
01:19:50,280 --> 01:19:52,440
help of these rules we can compute the

1644
01:19:52,440 --> 01:19:54,420
flags for each speed to run by run

1645
01:19:54,420 --> 01:19:56,699
immediately and this does not require

1646
01:19:56,699 --> 01:20:00,678
the help of an MRP server

1647
01:20:01,340 --> 01:20:05,880
for term you know to divide ITT SDF in

1648
01:20:05,880 --> 01:20:07,800
the just round we can divide the vector

1649
01:20:07,800 --> 01:20:11,040
GJ into three bit vectors according to

1650
01:20:11,040 --> 01:20:14,280
the flags of SGA for the sake of

1651
01:20:14,280 --> 01:20:16,020
understanding and temporary causes

1652
01:20:16,020 --> 01:20:20,280
predictors 1C vector 0c vector and Delta

1653
01:20:20,280 --> 01:20:21,300
vector

1654
01:20:21,300 --> 01:20:25,080
for example if the flag of the eye speed

1655
01:20:25,080 --> 01:20:27,659
of the of the vector SGA is Georgia

1656
01:20:27,659 --> 01:20:30,120
since the high speed of the Delta Vector

1657
01:20:30,120 --> 01:20:33,000
is equal to the eye speed of the vector

1658
01:20:33,000 --> 01:20:36,480
TG otherwise it is zero

1659
01:20:36,480 --> 01:20:38,580
further according to these three vectors

1660
01:20:38,580 --> 01:20:42,000
we can we can express itgsga as the

1661
01:20:42,000 --> 01:20:44,880
product of season three parts which will

1662
01:20:44,880 --> 01:20:48,659
call the lasting Parts uh zero C part

1663
01:20:48,659 --> 01:20:51,480
and the third part of the monomial

1664
01:20:51,480 --> 01:20:54,659
hi tjsg

1665
01:20:54,659 --> 01:20:56,940
so now it's time to introduce how to

1666
01:20:56,940 --> 01:20:59,400
model condition B our first attempt is

1667
01:20:59,400 --> 01:21:02,280
to exclude the propagation variety of

1668
01:21:02,280 --> 01:21:05,580
constant zero beats for the cbep and

1669
01:21:05,580 --> 01:21:09,540
this gives rise to to the mddp and it

1670
01:21:09,540 --> 01:21:12,060
can be shown that whether condition B

1671
01:21:12,060 --> 01:21:14,400
holds is equivalent to whether there

1672
01:21:14,400 --> 01:21:17,760
exists Vector here I am less than GI

1673
01:21:17,760 --> 01:21:20,159
such that all the other Vector Cascade

1674
01:21:20,159 --> 01:21:26,420
EU as an mvdp division show to Kia

1675
01:21:28,080 --> 01:21:31,020
by connecting mbdp us to MP we can

1676
01:21:31,020 --> 01:21:34,080
construct an MLG model called mbdpmp

1677
01:21:34,080 --> 01:21:35,760
model

1678
01:21:35,760 --> 01:21:38,280
and the propagation of the first time

1679
01:21:38,280 --> 01:21:40,679
launch is described according to the

1680
01:21:40,679 --> 01:21:44,040
rules of mbdp the propagation of the

1681
01:21:44,040 --> 01:21:46,800
next minus RM runs is described

1682
01:21:46,800 --> 01:21:49,739
according to the rules of mg in the

1683
01:21:49,739 --> 01:21:51,360
middle two constraints and hosts

1684
01:21:51,360 --> 01:21:54,420
according to the definition of mbdp

1685
01:21:54,420 --> 01:21:56,699
no matter whether the term expander of

1686
01:21:56,699 --> 01:22:00,600
OMG this mbdp based system VDP based

1687
01:22:00,600 --> 01:22:02,940
coefficient of solver allowed to recover

1688
01:22:02,940 --> 01:22:06,000
the super poly of 15 for dimensional

1689
01:22:06,000 --> 01:22:07,940
Cube for

1690
01:22:07,940 --> 01:22:12,120
846 rounds of children in about two days

1691
01:22:12,120 --> 01:22:14,520
however a platform is throughout no

1692
01:22:14,520 --> 01:22:18,260
other simple police were recovered

1693
01:22:22,400 --> 01:22:25,140
note that the two solutions of an

1694
01:22:25,140 --> 01:22:26,760
anarchy model are considered different

1695
01:22:26,760 --> 01:22:29,880
if they take a different values at least

1696
01:22:29,880 --> 01:22:33,540
to one of the involved one of the

1697
01:22:33,540 --> 01:22:36,600
environment MRP variables

1698
01:22:36,600 --> 01:22:39,600
for Vector GI with a higher heavyweight

1699
01:22:39,600 --> 01:22:41,820
so there may be many choices for the

1700
01:22:41,820 --> 01:22:45,060
vector Ki and this makes the number of

1701
01:22:45,060 --> 01:22:47,400
solutions of the mpvpnp model

1702
01:22:47,400 --> 01:22:49,679
extraordinarily large and this is

1703
01:22:49,679 --> 01:22:52,739
exactly where the bottleneck of the mbdp

1704
01:22:52,739 --> 01:22:55,759
MP model lies

1705
01:22:56,040 --> 01:22:59,219
to address the bottleneck of mpgp will

1706
01:22:59,219 --> 01:23:01,800
propose a technique called homonymous

1707
01:23:01,800 --> 01:23:02,940
prediction

1708
01:23:02,940 --> 01:23:05,040
now consider a factorial Boolean

1709
01:23:05,040 --> 01:23:07,940
function G involved in the graphical

1710
01:23:07,940 --> 01:23:11,159
involved in the cryptographic function f

1711
01:23:11,159 --> 01:23:14,820
with c and Y busy input and output of g

1712
01:23:14,820 --> 01:23:17,159
once the cube term with your children

1713
01:23:17,159 --> 01:23:19,560
and the nuclear variables are set to

1714
01:23:19,560 --> 01:23:23,159
zero the flags of say and Y can be

1715
01:23:23,159 --> 01:23:25,040
calculated immediately

1716
01:23:25,040 --> 01:23:30,120
uh next we consider the monomial y2v

1717
01:23:30,120 --> 01:23:33,840
we express the other part of ygv as a

1718
01:23:33,840 --> 01:23:36,800
polynomial of say if a non-zero monomial

1719
01:23:36,800 --> 01:23:39,840
occurs in the in this polynomial which

1720
01:23:39,840 --> 01:23:42,840
is the Delta part of state two mu can

1721
01:23:42,840 --> 01:23:45,840
propagate to the Delta part of Y to V by

1722
01:23:45,840 --> 01:23:48,060
the common number of prediction and we

1723
01:23:48,060 --> 01:23:50,580
denote this Factor by this

1724
01:23:50,580 --> 01:23:52,380
as you can see the common normal

1725
01:23:52,380 --> 01:23:55,080
prediction only captures the propagation

1726
01:23:55,080 --> 01:24:00,080
of the dirt part of each navier monomial

1727
01:24:01,100 --> 01:24:04,080
similar to the definition of our

1728
01:24:04,080 --> 01:24:06,179
monomial Trail we can also give you a

1729
01:24:06,179 --> 01:24:08,400
definition of common mixture

1730
01:24:08,400 --> 01:24:10,620
and as a result condition B is the

1731
01:24:10,620 --> 01:24:13,320
equivalently reduced to the problem of

1732
01:24:13,320 --> 01:24:15,780
whether there exists a common mixture

1733
01:24:15,780 --> 01:24:20,340
from K20 xq to the third part of high

1734
01:24:20,340 --> 01:24:23,340
tiimsi

1735
01:24:24,120 --> 01:24:27,120
to make it more clear to make it clear

1736
01:24:27,120 --> 01:24:30,060
we is showing example let's say and why

1737
01:24:30,060 --> 01:24:33,739
be defined like this

1738
01:24:34,620 --> 01:24:38,520
and let the cube term be x0 X Y this

1739
01:24:38,520 --> 01:24:41,640
means X2 is set to zero first we can

1740
01:24:41,640 --> 01:24:45,659
compute the flux for x k y z

1741
01:24:45,659 --> 01:24:49,739
then we can compute all monomial uh we

1742
01:24:49,739 --> 01:24:52,739
can compute all monomials are Y and we

1743
01:24:52,739 --> 01:24:55,320
find the only common only common

1744
01:24:55,320 --> 01:25:01,460
monomial from X 0 x 1 to y 0 y

1745
01:25:02,580 --> 01:25:05,159
Again by Computing all monomials I'll

1746
01:25:05,159 --> 01:25:07,440
say we find the two common mutuals from

1747
01:25:07,440 --> 01:25:10,440
y zero y one to the third part of

1748
01:25:10,440 --> 01:25:13,679
monomials out there finally we find the

1749
01:25:13,679 --> 01:25:15,780
two common mutuals around the other part

1750
01:25:15,780 --> 01:25:19,320
of monomials of x to the other parts of

1751
01:25:19,320 --> 01:25:22,519
monomials of the

1752
01:25:22,860 --> 01:25:25,800
this may sound a bit complicated so next

1753
01:25:25,800 --> 01:25:28,199
time we give a generation we give the

1754
01:25:28,199 --> 01:25:30,179
general General propagation rules for

1755
01:25:30,179 --> 01:25:32,699
CMG as mentioned before the common

1756
01:25:32,699 --> 01:25:35,460
normal prediction is always considered

1757
01:25:35,460 --> 01:25:38,940
on the cryptographic function f and the

1758
01:25:38,940 --> 01:25:41,820
cubital maxq still we consider the

1759
01:25:41,820 --> 01:25:45,360
oxygen G sending link to what now given

1760
01:25:45,360 --> 01:25:48,659
the third part of YTV are this

1761
01:25:48,659 --> 01:25:51,420
we want to determine which monomials are

1762
01:25:51,420 --> 01:25:55,320
they can propagate to treat it by CMP

1763
01:25:55,320 --> 01:25:57,840
first we can express that that part of

1764
01:25:57,840 --> 01:26:02,480
y2v are the polynomial of Z

1765
01:26:04,219 --> 01:26:07,260
therefore stand for each non-zerial

1766
01:26:07,260 --> 01:26:10,260
monomial object in this polynomial we

1767
01:26:10,260 --> 01:26:11,760
see that the other parts of this

1768
01:26:11,760 --> 01:26:13,920
monomial and propagates to the dirt

1769
01:26:13,920 --> 01:26:17,420
parts of Y to V by CMP

1770
01:26:17,420 --> 01:26:20,040
based on this general rule we also give

1771
01:26:20,040 --> 01:26:23,400
the propagation rules of copy Excel and

1772
01:26:23,400 --> 01:26:28,339
end operations for cmper wallpaper

1773
01:26:28,820 --> 01:26:33,120
similar to the MBD PMP model units using

1774
01:26:33,120 --> 01:26:36,000
CMG we can also construct an option

1775
01:26:36,000 --> 01:26:38,580
model called cmpmg model and the

1776
01:26:38,580 --> 01:26:40,920
propagation of the first time launch is

1777
01:26:40,920 --> 01:26:43,800
described by CMG in the middle part we

1778
01:26:43,800 --> 01:26:47,639
require the direct part of ikm asset

1779
01:26:47,639 --> 01:26:51,260
we're apply the other part of pikip

1780
01:26:51,260 --> 01:26:55,320
is equal to the other parts of Pi TI MSI

1781
01:26:55,320 --> 01:26:58,320
and of course the propagation related to

1782
01:26:58,320 --> 01:27:01,560
constant 0ps is still not allowed

1783
01:27:01,560 --> 01:27:03,780
if we use the monomial prediction to

1784
01:27:03,780 --> 01:27:06,659
recover the valuable terms the MRP model

1785
01:27:06,659 --> 01:27:09,540
should be like this and we call this

1786
01:27:09,540 --> 01:27:13,020
model MGMT model and we can prove that

1787
01:27:13,020 --> 01:27:15,840
the number of solutions our cmgmp model

1788
01:27:15,840 --> 01:27:18,540
will not be larger than that of the

1789
01:27:18,540 --> 01:27:21,239
image we are not to be larger than that

1790
01:27:21,239 --> 01:27:24,620
of the mkmt model

1791
01:27:28,020 --> 01:27:31,440
so CMP based coefficient server greatly

1792
01:27:31,440 --> 01:27:33,420
speeds up the simple quality recovery

1793
01:27:33,420 --> 01:27:36,239
and other results we are able to recover

1794
01:27:36,239 --> 01:27:38,400
the super polish for more runs of

1795
01:27:38,400 --> 01:27:40,980
several string samples considering the

1796
01:27:40,980 --> 01:27:44,340
super polish of Icon do not involve do

1797
01:27:44,340 --> 01:27:46,199
not involve fossil control variables

1798
01:27:46,199 --> 01:27:50,340
actually it only involve less than 125

1799
01:27:50,340 --> 01:27:52,800
secretive Rivals so

1800
01:27:52,800 --> 01:27:55,260
so we can directly derive a cube attack

1801
01:27:55,260 --> 01:27:56,900
on

1802
01:27:56,900 --> 01:28:00,739
776 round level Echo with the time time

1803
01:28:00,739 --> 01:28:05,880
with the time count was due to the 127

1804
01:28:05,880 --> 01:28:09,199
icon calls

1805
01:28:09,560 --> 01:28:12,179
there are many problems is how to

1806
01:28:12,179 --> 01:28:14,340
monitor Cube attack using super police

1807
01:28:14,340 --> 01:28:18,300
involving four qubits first we also that

1808
01:28:18,300 --> 01:28:21,659
during the Mobius platform from aof to

1809
01:28:21,659 --> 01:28:24,060
shoes level a pattern of truth table are

1810
01:28:24,060 --> 01:28:27,120
already has already been determined

1811
01:28:27,120 --> 01:28:30,179
excess observation allows us not only to

1812
01:28:30,179 --> 01:28:32,760
determine our candidate key during the

1813
01:28:32,760 --> 01:28:34,679
Mobius transform but also to check

1814
01:28:34,679 --> 01:28:37,139
whether the candidate key is the correct

1815
01:28:37,139 --> 01:28:40,320
key compared to the conventional method

1816
01:28:40,320 --> 01:28:43,940
that if that

1817
01:28:43,940 --> 01:28:46,500
compared to the conventional method of

1818
01:28:46,500 --> 01:28:48,659
creating a table first and then querying

1819
01:28:48,659 --> 01:28:51,360
it system observation can help us save

1820
01:28:51,360 --> 01:28:54,199
the querying cost

1821
01:28:57,860 --> 01:29:01,139
create our calculator key recovery

1822
01:29:01,139 --> 01:29:02,840
method by taking

1823
01:29:02,840 --> 01:29:07,020
848 rounds of Trivium as an example

1824
01:29:07,020 --> 01:29:08,760
let's say the expression let's say the

1825
01:29:08,760 --> 01:29:10,980
equation is published by the superpolic

1826
01:29:10,980 --> 01:29:16,440
b t k the arrow to k79 equals a

1827
01:29:16,440 --> 01:29:20,780
and here a is a binary value

1828
01:29:21,540 --> 01:29:24,540
according to our test the p is a 25

1829
01:29:24,540 --> 01:29:28,199
degree polynomial continuous containing

1830
01:29:28,199 --> 01:29:31,639
about 2 to 30.5 terms

1831
01:29:31,639 --> 01:29:34,920
first of all we can guess the values of

1832
01:29:34,920 --> 01:29:37,920
the last 40 secretive variables and the

1833
01:29:37,920 --> 01:29:40,380
radio speed to a polynomial P Prime

1834
01:29:40,380 --> 01:29:42,900
involving only the first 46 proton

1835
01:29:42,900 --> 01:29:45,239
variables and then apply the Mobius

1836
01:29:45,239 --> 01:29:48,239
transform to the G Prime when some value

1837
01:29:48,239 --> 01:29:50,880
of P Prime is determined equal to a

1838
01:29:50,880 --> 01:29:53,100
during the Mobius transform we can

1839
01:29:53,100 --> 01:29:56,340
obtain a what kind of a candidate fee we

1840
01:29:56,340 --> 01:29:58,199
then check if this candidate key is

1841
01:29:58,199 --> 01:30:00,840
correct by a single children color and

1842
01:30:00,840 --> 01:30:02,820
the due to the velocity of the super

1843
01:30:02,820 --> 01:30:06,480
poly second the time the time complexity

1844
01:30:06,480 --> 01:30:08,880
of the first step should be should be

1845
01:30:08,880 --> 01:30:10,139
negligible

1846
01:30:10,139 --> 01:30:12,120
and it's such a key recovery method only

1847
01:30:12,120 --> 01:30:16,139
requires to only requires two to the 40

1848
01:30:16,139 --> 01:30:18,780
to the 40 piece memory and certainly

1849
01:30:18,780 --> 01:30:23,659
more than 2279 treatment costs

1850
01:30:25,080 --> 01:30:27,840
and it is these are the results of our

1851
01:30:27,840 --> 01:30:31,020
final cable attacks

1852
01:30:31,020 --> 01:30:34,199
to summarize our work thanks to the

1853
01:30:34,199 --> 01:30:36,060
proposal of a two-stage coefficient

1854
01:30:36,060 --> 01:30:38,580
solver where the first stage is

1855
01:30:38,580 --> 01:30:40,679
accelerated with a common number

1856
01:30:40,679 --> 01:30:43,199
prediction or succeeded in recovering

1857
01:30:43,199 --> 01:30:45,060
the superfully for four round radio

1858
01:30:45,060 --> 01:30:47,880
system servers and and improving the

1859
01:30:47,880 --> 01:30:49,920
cube attacks on them

1860
01:30:49,920 --> 01:30:52,080
finally thanks for your attention and if

1861
01:30:52,080 --> 01:30:54,360
you have any questions you have you can

1862
01:30:54,360 --> 01:30:56,639
ask you can ask you guys can be right

1863
01:30:56,639 --> 01:30:59,820
now or contact me later by the following

1864
01:30:59,820 --> 01:31:00,659
email

1865
01:31:00,659 --> 01:31:03,138
okay

1866
01:31:09,000 --> 01:31:12,860
thank you do you have any questions

1867
01:31:14,400 --> 01:31:19,580
no okay then let's exit speaker again

1868
01:31:20,940 --> 01:31:23,599
thank you

1869
01:31:25,380 --> 01:31:26,520
hey

1870
01:31:26,520 --> 01:31:28,920
um some showed announcements

1871
01:31:28,920 --> 01:31:32,940
and for those who need it and Luggage

1872
01:31:32,940 --> 01:31:36,320
may be left behind

