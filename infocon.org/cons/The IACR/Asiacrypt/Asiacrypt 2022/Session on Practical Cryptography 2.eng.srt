1
00:00:00,000 --> 00:00:03,060
the lunch break on this last day of Asia

2
00:00:03,060 --> 00:00:04,680
Crypt 2022

3
00:00:04,680 --> 00:00:07,319
and welcome to the session on the second

4
00:00:07,319 --> 00:00:09,720
session on practical cryptography it's

5
00:00:09,720 --> 00:00:11,219
my pleasure to announce the first

6
00:00:11,219 --> 00:00:13,559
Speaker Julia Lan from Cornell Tech and

7
00:00:13,559 --> 00:00:15,420
Julia the floor is all yours

8
00:00:15,420 --> 00:00:17,780
thank you

9
00:00:18,480 --> 00:00:22,279
so my name is Julia and today I'll be

10
00:00:22,380 --> 00:00:23,820
happy

11
00:00:23,820 --> 00:00:25,740
and this is Joint work with Paul Grubbs

12
00:00:25,740 --> 00:00:28,320
and John Weston Park

13
00:00:28,320 --> 00:00:30,119
so let's begin by recalling the

14
00:00:30,119 --> 00:00:31,800
definition for authenticated encryption

15
00:00:31,800 --> 00:00:35,100
with Associated data or aad

16
00:00:35,100 --> 00:00:37,440
so here in the setting we have two

17
00:00:37,440 --> 00:00:40,079
parties and they share a Super Key the

18
00:00:40,079 --> 00:00:41,640
sender wants to send a message to the

19
00:00:41,640 --> 00:00:44,100
recipient so they choose a nonce and

20
00:00:44,100 --> 00:00:47,280
Associated data a plain text message and

21
00:00:47,280 --> 00:00:49,260
then they encrypt the message using

22
00:00:49,260 --> 00:00:50,820
their secret key to produce the cycle

23
00:00:50,820 --> 00:00:52,320
text

24
00:00:52,320 --> 00:00:53,940
the sender can then send the

25
00:00:53,940 --> 00:00:56,460
non-associated data and ciphertext to

26
00:00:56,460 --> 00:00:59,039
the recipient who can then decrypt using

27
00:00:59,039 --> 00:01:00,600
their secret key to recover the

28
00:01:00,600 --> 00:01:02,039
plaintext message

29
00:01:02,039 --> 00:01:03,840
and in this setting of course we expect

30
00:01:03,840 --> 00:01:07,020
or we require that an adversary who sees

31
00:01:07,020 --> 00:01:09,360
a ciphertext and doesn't know the super

32
00:01:09,360 --> 00:01:11,100
key won't be able to recover the same

33
00:01:11,100 --> 00:01:12,600
text message

34
00:01:12,600 --> 00:01:14,280
but notice that there are a couple of

35
00:01:14,280 --> 00:01:18,900
assumptions we're making with this model

36
00:01:18,900 --> 00:01:20,580
the first assumption was that the

37
00:01:20,580 --> 00:01:22,740
adversary has no way of knowing or even

38
00:01:22,740 --> 00:01:24,960
guessing the secret key so typically the

39
00:01:24,960 --> 00:01:26,520
security definitions we require in the

40
00:01:26,520 --> 00:01:28,799
setting are confidentiality and

41
00:01:28,799 --> 00:01:31,500
authenticity which model uh the

42
00:01:31,500 --> 00:01:34,740
adversary is not knowing the secret key

43
00:01:34,740 --> 00:01:36,600
and also the second assumption here is

44
00:01:36,600 --> 00:01:39,000
that decryption only ever gets a single

45
00:01:39,000 --> 00:01:41,700
super key as input

46
00:01:41,700 --> 00:01:43,799
but this model does not always capture

47
00:01:43,799 --> 00:01:46,380
how is

48
00:01:46,380 --> 00:01:48,299
so for example

49
00:01:48,299 --> 00:01:50,520
this first assumption about the adverse

50
00:01:50,520 --> 00:01:52,680
about the adversary not knowing the

51
00:01:52,680 --> 00:01:54,659
super key doesn't capture the security

52
00:01:54,659 --> 00:01:57,240
goal of the robustness and this was

53
00:01:57,240 --> 00:01:59,460
first introduced for the symmetric

54
00:01:59,460 --> 00:02:01,380
encryption setting by farshan University

55
00:02:01,380 --> 00:02:04,579
in 2017.

56
00:02:05,040 --> 00:02:09,119
oh can you hear me okay thanks uh so

57
00:02:09,119 --> 00:02:09,840
um

58
00:02:09,840 --> 00:02:12,720
at a high level the security uh property

59
00:02:12,720 --> 00:02:16,200
states are an AED scheme is not uh key

60
00:02:16,200 --> 00:02:18,840
robust or key committing if an adversary

61
00:02:18,840 --> 00:02:21,000
can compute a non-associated data in

62
00:02:21,000 --> 00:02:23,520
ciphertext such that two different keys

63
00:02:23,520 --> 00:02:27,920
can can successfully decrypt the site

64
00:02:27,920 --> 00:02:31,140
and um recent work has shown that many

65
00:02:31,140 --> 00:02:33,660
aad schemes do not meet the security

66
00:02:33,660 --> 00:02:35,879
property and that this has shown real

67
00:02:35,879 --> 00:02:38,220
vulnerabilities in practice and notice

68
00:02:38,220 --> 00:02:39,959
that this key robust in school does not

69
00:02:39,959 --> 00:02:41,760
meet our first assumption because the

70
00:02:41,760 --> 00:02:44,940
adversary continues the secrets

71
00:02:44,940 --> 00:02:46,260
so to go over some of these

72
00:02:46,260 --> 00:02:47,760
vulnerabilities

73
00:02:47,760 --> 00:02:50,459
uh grubs at all and notice it all showed

74
00:02:50,459 --> 00:02:51,840
a tax against Facebook Messengers

75
00:02:51,840 --> 00:02:53,700
message ranking protocol

76
00:02:53,700 --> 00:02:56,519
in Prior work we described a new class

77
00:02:56,519 --> 00:02:58,319
of a taxi called practitioning Oracle

78
00:02:58,319 --> 00:03:00,360
texts and showed how to exploit key

79
00:03:00,360 --> 00:03:04,260
robustness uh attacks in

80
00:03:04,260 --> 00:03:05,940
um the

81
00:03:05,940 --> 00:03:08,640
uh opaque and implementations of the

82
00:03:08,640 --> 00:03:10,140
opaque password authenticated key

83
00:03:10,140 --> 00:03:12,599
exchange protocol as well as Shadow soft

84
00:03:12,599 --> 00:03:15,540
proxy servers and lastly albertini at

85
00:03:15,540 --> 00:03:16,860
all showed here how to exploit

86
00:03:16,860 --> 00:03:19,019
kirobasa's vulnerabilities and envelope

87
00:03:19,019 --> 00:03:21,300
encryption And subscribe with Google so

88
00:03:21,300 --> 00:03:23,340
overall we're seeing that there's no

89
00:03:23,340 --> 00:03:24,900
vulnerabilities in practice and that

90
00:03:24,900 --> 00:03:27,720
this model isn't capitalism

91
00:03:27,720 --> 00:03:29,400
moreover when we look at the second

92
00:03:29,400 --> 00:03:31,080
assumption that decryption only ever

93
00:03:31,080 --> 00:03:34,440
gets a single Super Key we see that this

94
00:03:34,440 --> 00:03:37,080
doesn't actually model how aad is used

95
00:03:37,080 --> 00:03:38,400
in practice

96
00:03:38,400 --> 00:03:40,379
so as one example let's take a look at

97
00:03:40,379 --> 00:03:42,659
the Google Sync API this is an open

98
00:03:42,659 --> 00:03:44,879
source cryptography Library developer

99
00:03:44,879 --> 00:03:46,200
Google

100
00:03:46,200 --> 00:03:48,360
and we look when we look at how key

101
00:03:48,360 --> 00:03:50,700
management works in Tink

102
00:03:50,700 --> 00:03:52,920
we'll see that Tink actually has users

103
00:03:52,920 --> 00:03:55,680
work not with single keys but with key

104
00:03:55,680 --> 00:03:56,819
sets

105
00:03:56,819 --> 00:04:00,120
and so decryption takes in a set of keys

106
00:04:00,120 --> 00:04:01,980
but how does decryption know which key

107
00:04:01,980 --> 00:04:03,180
to use

108
00:04:03,180 --> 00:04:05,220
so tink's approach to this is to add a

109
00:04:05,220 --> 00:04:07,140
five byte prefix to each ciphertext

110
00:04:07,140 --> 00:04:09,480
which acts as a key identifier

111
00:04:09,480 --> 00:04:11,580
and Tink will then try to decrypt this

112
00:04:11,580 --> 00:04:14,159
key specified by the identifier first if

113
00:04:14,159 --> 00:04:16,139
decryption fails Tink will attempt to

114
00:04:16,139 --> 00:04:18,839
trial decrypt with raw Keys which in its

115
00:04:18,839 --> 00:04:21,000
model are keys without identifiers until

116
00:04:21,000 --> 00:04:22,800
it finds a key that successfully

117
00:04:22,800 --> 00:04:25,380
decrypts but it's unclear what security

118
00:04:25,380 --> 00:04:28,020
goals this achieves because this doesn't

119
00:04:28,020 --> 00:04:31,139
align with our model of aad

120
00:04:31,139 --> 00:04:34,199
furthermore we've seen attacks on these

121
00:04:34,199 --> 00:04:37,620
ad hoc implementations on sets of keys

122
00:04:37,620 --> 00:04:39,479
so for instance we showed that there

123
00:04:39,479 --> 00:04:41,400
were vulnerability vulnerabilities with

124
00:04:41,400 --> 00:04:44,220
multi-user data sets and albertine at

125
00:04:44,220 --> 00:04:44,880
all showed that there are

126
00:04:44,880 --> 00:04:46,139
vulnerabilities with Key Management

127
00:04:46,139 --> 00:04:49,380
Services when they use sets of peace

128
00:04:49,380 --> 00:04:51,660
so all together it's really unclear what

129
00:04:51,660 --> 00:04:53,280
security properties these approaches

130
00:04:53,280 --> 00:04:54,240
achieve

131
00:04:54,240 --> 00:04:55,919
and to date there's been no formal

132
00:04:55,919 --> 00:04:58,320
investigation of key identification in

133
00:04:58,320 --> 00:05:00,800
the setting

134
00:05:01,020 --> 00:05:02,940
so we remedy this by initiating the

135
00:05:02,940 --> 00:05:05,100
formal study of aad that supports key

136
00:05:05,100 --> 00:05:07,680
identification by extending non-spaced

137
00:05:07,680 --> 00:05:10,320
aad into the setting

138
00:05:10,320 --> 00:05:12,000
and this talk will formalize a new

139
00:05:12,000 --> 00:05:14,160
cryptographic primitive that we call aad

140
00:05:14,160 --> 00:05:17,759
with key identification or aadki so now

141
00:05:17,759 --> 00:05:19,620
decryption takes in a vector of secret

142
00:05:19,620 --> 00:05:22,199
keys and part of the decryption task is

143
00:05:22,199 --> 00:05:24,120
to identify the correct key before

144
00:05:24,120 --> 00:05:26,160
decrypting

145
00:05:26,160 --> 00:05:27,840
we'll also introduce new security

146
00:05:27,840 --> 00:05:31,020
definitions for the aadki setting so in

147
00:05:31,020 --> 00:05:32,580
particular our definitions allow an

148
00:05:32,580 --> 00:05:35,280
adversary to specify malicious to better

149
00:05:35,280 --> 00:05:37,259
model possible attacks

150
00:05:37,259 --> 00:05:39,539
and finally we'll analyze security of

151
00:05:39,539 --> 00:05:41,340
existing key identification approaches

152
00:05:41,340 --> 00:05:43,680
and suggestions

153
00:05:43,680 --> 00:05:46,440
so let's begin by looking at this aadki

154
00:05:46,440 --> 00:05:47,520
primitive

155
00:05:47,520 --> 00:05:49,620
an aadki scheme is a triple of

156
00:05:49,620 --> 00:05:52,680
algorithms the first is a key generation

157
00:05:52,680 --> 00:05:53,880
algorithm

158
00:05:53,880 --> 00:05:57,360
so this takes as input a key label and

159
00:05:57,360 --> 00:05:59,820
this can be a public application defined

160
00:05:59,820 --> 00:06:01,800
string such as a uniform resource

161
00:06:01,800 --> 00:06:03,780
identifier that Key Management Services

162
00:06:03,780 --> 00:06:07,080
might use it outputs a key which in our

163
00:06:07,080 --> 00:06:10,979
setting is a key label secret key tool

164
00:06:10,979 --> 00:06:13,199
encryption takes its input a key nonce

165
00:06:13,199 --> 00:06:15,300
Associated data and message and it

166
00:06:15,300 --> 00:06:17,639
outputs in addition to the ciphertext a

167
00:06:17,639 --> 00:06:20,100
specialty tag so this can be used to

168
00:06:20,100 --> 00:06:21,900
help with identifying the key dirt

169
00:06:21,900 --> 00:06:24,180
decryption

170
00:06:24,180 --> 00:06:26,819
and lastly decryption takes as input a

171
00:06:26,819 --> 00:06:29,880
vector of keys a nonce Associated data a

172
00:06:29,880 --> 00:06:32,160
key tag and a ciphertext so in

173
00:06:32,160 --> 00:06:34,080
particular notice here that we choose to

174
00:06:34,080 --> 00:06:36,060
model a vector of keys rather than a set

175
00:06:36,060 --> 00:06:38,039
of keys this is to preserve information

176
00:06:38,039 --> 00:06:40,440
about The Ordering of these which might

177
00:06:40,440 --> 00:06:42,960
affect the decryption outcome

178
00:06:42,960 --> 00:06:45,300
if decryption succeeds it Returns the

179
00:06:45,300 --> 00:06:46,860
key that produce the results in plain

180
00:06:46,860 --> 00:06:48,660
text in addition to the plain text

181
00:06:48,660 --> 00:06:49,620
itself

182
00:06:49,620 --> 00:06:51,660
otherwise it Returns the special error

183
00:06:51,660 --> 00:06:53,699
symbol Bots

184
00:06:53,699 --> 00:06:56,100
so now let's talk about what aadki

185
00:06:56,100 --> 00:06:57,900
reckon is

186
00:06:57,900 --> 00:07:00,360
let's first recall that an aad scheme is

187
00:07:00,360 --> 00:07:02,639
correct if for any key nonsense data

188
00:07:02,639 --> 00:07:04,620
message it holds that when we encrypt

189
00:07:04,620 --> 00:07:07,259
over these inputs and then decrypt the

190
00:07:07,259 --> 00:07:08,699
resulting Cipher text with the original

191
00:07:08,699 --> 00:07:11,520
key we get back the original plain text

192
00:07:11,520 --> 00:07:14,220
with probability one

193
00:07:14,220 --> 00:07:17,280
but what is a correct aadki student mean

194
00:07:17,280 --> 00:07:20,580
how do we extend this into our setting

195
00:07:20,580 --> 00:07:23,460
well as a straw man proposal let's try

196
00:07:23,460 --> 00:07:27,419
this at AAA and aadpi scheme is correct

197
00:07:27,419 --> 00:07:30,660
if for any key key Vector not associated

198
00:07:30,660 --> 00:07:32,880
data and message where in particular the

199
00:07:32,880 --> 00:07:35,819
key is in the key Vector it holds that

200
00:07:35,819 --> 00:07:38,460
when we encrypt the message with the key

201
00:07:38,460 --> 00:07:40,520
and then decrypt the resulting

202
00:07:40,520 --> 00:07:43,020
ciphertext using the key Vector we get

203
00:07:43,020 --> 00:07:44,400
back to the original key and message

204
00:07:44,400 --> 00:07:46,259
with probability one

205
00:07:46,259 --> 00:07:48,599
but there's a problem here which is that

206
00:07:48,599 --> 00:07:49,919
there could be another key in the key

207
00:07:49,919 --> 00:07:51,720
Vector that can decrypt the ciphertext

208
00:07:51,720 --> 00:07:53,400
so this cannot be an information

209
00:07:53,400 --> 00:07:56,220
theoretic entity

210
00:07:56,220 --> 00:07:58,860
we expect overall an aadki scheme

211
00:07:58,860 --> 00:08:01,199
therefore to function correctly if it

212
00:08:01,199 --> 00:08:03,539
Returns the correct key but this

213
00:08:03,539 --> 00:08:05,819
requires a computational definition

214
00:08:05,819 --> 00:08:08,340
we therefore provide a simpler absolute

215
00:08:08,340 --> 00:08:10,800
correctness definition and rely on a key

216
00:08:10,800 --> 00:08:12,479
robustness definition to model this

217
00:08:12,479 --> 00:08:14,180
Behavior instead

218
00:08:14,180 --> 00:08:17,580
so an aadki scheme is correct if the

219
00:08:17,580 --> 00:08:20,220
following conditions hold

220
00:08:20,220 --> 00:08:22,259
the first says that for any key

221
00:08:22,259 --> 00:08:24,720
non-associated data and message if we

222
00:08:24,720 --> 00:08:26,940
encrypt over these inputs and then

223
00:08:26,940 --> 00:08:29,160
decrypt the cipher text with a key

224
00:08:29,160 --> 00:08:32,339
Vector including just that key then we

225
00:08:32,339 --> 00:08:34,140
get back to the original PN message with

226
00:08:34,140 --> 00:08:36,000
probability one so this really just

227
00:08:36,000 --> 00:08:37,860
translates to the traditional Aid

228
00:08:37,860 --> 00:08:41,219
correctness to the syntax of aea DKI for

229
00:08:41,219 --> 00:08:44,159
decryption with a single key

230
00:08:44,159 --> 00:08:46,680
our next correctness condition simply

231
00:08:46,680 --> 00:08:48,300
says that decryption should only output

232
00:08:48,300 --> 00:08:51,420
a key that was from the key vector

233
00:08:51,420 --> 00:08:54,420
and next um our last correctness

234
00:08:54,420 --> 00:08:56,700
condition says that if the decryption of

235
00:08:56,700 --> 00:08:59,160
the non-associated data keytag and

236
00:08:59,160 --> 00:09:02,459
ciphertext outputs in PK any other key

237
00:09:02,459 --> 00:09:04,980
Vector containing that keykay should not

238
00:09:04,980 --> 00:09:07,019
fail to deprive the ciphertext this

239
00:09:07,019 --> 00:09:08,279
doesn't mean that decryption might

240
00:09:08,279 --> 00:09:10,200
return that key just that decryption

241
00:09:10,200 --> 00:09:12,420
should not fail

242
00:09:12,420 --> 00:09:13,860
so now that we've covered our

243
00:09:13,860 --> 00:09:16,080
correctness conditions let's take a look

244
00:09:16,080 --> 00:09:18,360
at our key robustness definition in this

245
00:09:18,360 --> 00:09:20,760
setting we extend the full robustness

246
00:09:20,760 --> 00:09:24,540
definition from partial metal into the

247
00:09:24,540 --> 00:09:26,700
setting and we our new definition is

248
00:09:26,700 --> 00:09:28,500
called

249
00:09:28,500 --> 00:09:30,720
so here in our security game we required

250
00:09:30,720 --> 00:09:33,180
the adversary to return two key vectors

251
00:09:33,180 --> 00:09:34,680
k0 and K1

252
00:09:34,680 --> 00:09:36,959
and the non-associate data key tag and

253
00:09:36,959 --> 00:09:40,019
cycle test adversary wins if when

254
00:09:40,019 --> 00:09:42,540
decrypting the ciphertext under the two

255
00:09:42,540 --> 00:09:45,839
different key vectors uh decryption is

256
00:09:45,839 --> 00:09:48,420
successful under both key vectors and

257
00:09:48,420 --> 00:09:52,080
the keys that were returned are distinct

258
00:09:52,080 --> 00:09:54,000
so notice that here bustness guarantees

259
00:09:54,000 --> 00:09:56,160
that only a single key can be used to

260
00:09:56,160 --> 00:09:58,740
decrypt a given ciphertext

261
00:09:58,740 --> 00:10:00,980
this functions partly as a correctness

262
00:10:00,980 --> 00:10:03,839
definition in the setting in a way we

263
00:10:03,839 --> 00:10:06,120
expect that the key used to encrypt a

264
00:10:06,120 --> 00:10:07,740
plain text should be the only one to

265
00:10:07,740 --> 00:10:09,000
correctly detect the resulting

266
00:10:09,000 --> 00:10:10,680
ciphertext

267
00:10:10,680 --> 00:10:13,019
and also if different orderings of the

268
00:10:13,019 --> 00:10:15,000
same key Vector cause different keys to

269
00:10:15,000 --> 00:10:17,160
be output these two key vectors would

270
00:10:17,160 --> 00:10:20,100
give a kis lab when the important Point

271
00:10:20,100 --> 00:10:21,779
here is that two different keys are

272
00:10:21,779 --> 00:10:24,060
turned it doesn't matter the ordering of

273
00:10:24,060 --> 00:10:27,199
the set of keys as input

274
00:10:27,959 --> 00:10:30,060
so our next security definition in this

275
00:10:30,060 --> 00:10:32,700
setting is an all-in-one confidentiality

276
00:10:32,700 --> 00:10:34,560
and integrity definition that we call

277
00:10:34,560 --> 00:10:36,720
Kine this extends an

278
00:10:36,720 --> 00:10:38,100
indistinguishability cell security

279
00:10:38,100 --> 00:10:43,339
definition or aad to aapki foreign

280
00:10:43,339 --> 00:10:45,720
we allow adversaries to query the

281
00:10:45,720 --> 00:10:48,000
decryption Oracle with a key Vector that

282
00:10:48,000 --> 00:10:50,760
includes both honest and malicious keys

283
00:10:50,760 --> 00:10:52,800
in any order to better calculate the

284
00:10:52,800 --> 00:10:53,700
setting

285
00:10:53,700 --> 00:10:55,800
we use a simulator based definition to

286
00:10:55,800 --> 00:10:56,880
model this

287
00:10:56,880 --> 00:10:58,920
we also specify a key Anonymous version

288
00:10:58,920 --> 00:11:00,959
called kinek

289
00:11:00,959 --> 00:11:02,640
so let's take out some let's look at

290
00:11:02,640 --> 00:11:05,940
some more specifics on this definition

291
00:11:05,940 --> 00:11:08,040
the adversary goal here is to

292
00:11:08,040 --> 00:11:09,959
distinguish between a real and simulated

293
00:11:09,959 --> 00:11:10,860
world

294
00:11:10,860 --> 00:11:13,200
the adversary has access to oracles to

295
00:11:13,200 --> 00:11:15,779
generate honest views to encrypt and to

296
00:11:15,779 --> 00:11:17,040
decrease

297
00:11:17,040 --> 00:11:19,680
so we have two games here and A1 okay

298
00:11:19,680 --> 00:11:22,500
and a0 the first is the real world game

299
00:11:22,500 --> 00:11:24,720
okay any one and this model's

300
00:11:24,720 --> 00:11:26,700
interactions with the real scheme

301
00:11:26,700 --> 00:11:30,000
k and a e0 our Ideal World game uses a

302
00:11:30,000 --> 00:11:31,680
staple simulator to generate Oracle

303
00:11:31,680 --> 00:11:34,160
outputs

304
00:11:34,560 --> 00:11:37,019
so let's take a look also some more at

305
00:11:37,019 --> 00:11:39,779
the ideal game k n a zero

306
00:11:39,779 --> 00:11:43,140
during encryption we have two possible

307
00:11:43,140 --> 00:11:45,180
um leakage functions the first is a

308
00:11:45,180 --> 00:11:48,120
non-canonymous leakage function uh here

309
00:11:48,120 --> 00:11:49,560
the simulator receives both the game

310
00:11:49,560 --> 00:11:51,899
generated identifier and the plain text

311
00:11:51,899 --> 00:11:52,860
size

312
00:11:52,860 --> 00:11:54,720
in our key Anonymous leakage function

313
00:11:54,720 --> 00:11:56,940
the simulator receives only the point

314
00:11:56,940 --> 00:11:58,920
size so the simulator doesn't know which

315
00:11:58,920 --> 00:12:01,880
key is being used to encrypt

316
00:12:01,880 --> 00:12:05,880
decryption recall Texas input the vector

317
00:12:05,880 --> 00:12:07,860
of keys which could be honest or

318
00:12:07,860 --> 00:12:09,779
malicious in any order

319
00:12:09,779 --> 00:12:12,060
so here we simulate this by first

320
00:12:12,060 --> 00:12:13,740
scanning through honest keys in the

321
00:12:13,740 --> 00:12:15,899
query key Vector if the key and

322
00:12:15,899 --> 00:12:17,880
ciphertext were output from a prior call

323
00:12:17,880 --> 00:12:19,620
to the encryption Oracle then the

324
00:12:19,620 --> 00:12:21,800
associated plain text is returned

325
00:12:21,800 --> 00:12:24,320
otherwise if this fails to find the key

326
00:12:24,320 --> 00:12:26,579
and there are malicious keys in the key

327
00:12:26,579 --> 00:12:28,920
Vector the simulator is given ciphertext

328
00:12:28,920 --> 00:12:31,620
and remaining malicious piece of decrypt

329
00:12:31,620 --> 00:12:33,660
so doing this allows our definition to

330
00:12:33,660 --> 00:12:35,880
imply a variant of ciphertext Integrity

331
00:12:35,880 --> 00:12:37,760
for this setting

332
00:12:37,760 --> 00:12:40,440
now that we've covered our security

333
00:12:40,440 --> 00:12:42,959
definitions here let's describe our

334
00:12:42,959 --> 00:12:45,839
approaches to Aid Ki we specifically

335
00:12:45,839 --> 00:12:47,820
divide key identification into several

336
00:12:47,820 --> 00:12:51,120
categories and analyze their security

337
00:12:51,120 --> 00:12:54,180
our first approach is key labels this

338
00:12:54,180 --> 00:12:56,160
assigns each key of static label then

339
00:12:56,160 --> 00:12:58,139
prepends the label to each ciphertext it

340
00:12:58,139 --> 00:13:00,000
produces and this is specifically

341
00:13:00,000 --> 00:13:02,880
parametrized by an aad scheme and there

342
00:13:02,880 --> 00:13:04,200
are a couple of examples of this in

343
00:13:04,200 --> 00:13:05,880
practice so we talked about Google think

344
00:13:05,880 --> 00:13:08,100
before there's also the Amazon web

345
00:13:08,100 --> 00:13:10,139
services Key Management Service they use

346
00:13:10,139 --> 00:13:12,180
a URL indicating where to fetch the key

347
00:13:12,180 --> 00:13:13,980
this can be considered a type of key

348
00:13:13,980 --> 00:13:15,360
label

349
00:13:15,360 --> 00:13:18,240
so more specifically encryption

350
00:13:18,240 --> 00:13:19,200
um

351
00:13:19,200 --> 00:13:22,200
has caused the aad scheme on the plain

352
00:13:22,200 --> 00:13:23,760
text message and as part of the

353
00:13:23,760 --> 00:13:26,399
associate data we include the key label

354
00:13:26,399 --> 00:13:28,980
the key label itself forms our key tag

355
00:13:28,980 --> 00:13:30,240
which I'll put together with the

356
00:13:30,240 --> 00:13:31,800
ciphertext

357
00:13:31,800 --> 00:13:33,899
decryption then iterates through the key

358
00:13:33,899 --> 00:13:36,660
vector and checks if the key label for

359
00:13:36,660 --> 00:13:39,000
the key matches the key tag in which

360
00:13:39,000 --> 00:13:41,579
case we'll try to decrypt with the aid

361
00:13:41,579 --> 00:13:44,100
scheme if the six seats then will simply

362
00:13:44,100 --> 00:13:47,060
return the key and message

363
00:13:47,220 --> 00:13:49,920
so key labels are Ki afrob secure if and

364
00:13:49,920 --> 00:13:53,639
only if the AIDS used is too robust

365
00:13:53,639 --> 00:13:55,800
key labels especially might not be

366
00:13:55,800 --> 00:13:57,720
unique and therefore we can't use them

367
00:13:57,720 --> 00:13:59,519
for key commitment

368
00:13:59,519 --> 00:14:02,820
he labels our k and a secure if the aad

369
00:14:02,820 --> 00:14:05,100
scheme is key robust and multi-user AE

370
00:14:05,100 --> 00:14:06,000
secure

371
00:14:06,000 --> 00:14:07,980
and in particular cybertechs are

372
00:14:07,980 --> 00:14:09,540
prepended with static strings so there's

373
00:14:09,540 --> 00:14:11,940
no key anonymity if that's desired

374
00:14:11,940 --> 00:14:14,220
however you could use instead of trial

375
00:14:14,220 --> 00:14:16,260
decryption scheme which is where key

376
00:14:16,260 --> 00:14:17,940
labels are simply empty and you iterate

377
00:14:17,940 --> 00:14:20,220
through every single key this adds extra

378
00:14:20,220 --> 00:14:22,620
overhead but it is provides can

379
00:14:22,620 --> 00:14:25,040
anonymity

380
00:14:25,920 --> 00:14:28,800
okay our next approach is static key

381
00:14:28,800 --> 00:14:31,139
identifiers this computes a static

382
00:14:31,139 --> 00:14:33,420
identifier from the key and uses this

383
00:14:33,420 --> 00:14:36,360
with the key label as the key tag this

384
00:14:36,360 --> 00:14:38,279
is also known as a key check value in

385
00:14:38,279 --> 00:14:39,420
practice

386
00:14:39,420 --> 00:14:41,339
and this is parametrized by a key check

387
00:14:41,339 --> 00:14:43,139
value function an encryption key

388
00:14:43,139 --> 00:14:45,060
derivation function which is distinct

389
00:14:45,060 --> 00:14:47,820
from the key check value function and an

390
00:14:47,820 --> 00:14:49,199
aid scheme

391
00:14:49,199 --> 00:14:51,779
so here during encryption we compute

392
00:14:51,779 --> 00:14:55,620
from the key the key check value and the

393
00:14:55,620 --> 00:14:57,720
encryption key using the key derivation

394
00:14:57,720 --> 00:15:00,899
function our key tag is now formed by a

395
00:15:00,899 --> 00:15:02,760
concatenating the key label together

396
00:15:02,760 --> 00:15:04,800
with the key check value

397
00:15:04,800 --> 00:15:07,980
we encrypt using the aad scheme and then

398
00:15:07,980 --> 00:15:09,839
we return the key tag together the

399
00:15:09,839 --> 00:15:12,540
ciphertext for decryption we iterate

400
00:15:12,540 --> 00:15:14,519
through the key Vector we compute the

401
00:15:14,519 --> 00:15:16,740
key check value and encryption key from

402
00:15:16,740 --> 00:15:17,940
each key

403
00:15:17,940 --> 00:15:20,279
and then if the key label and key check

404
00:15:20,279 --> 00:15:23,040
value together for that key matches the

405
00:15:23,040 --> 00:15:25,560
input keypad we'll attempt to decrypt

406
00:15:25,560 --> 00:15:27,899
with the AED scheme if that succeeds we

407
00:15:27,899 --> 00:15:30,899
simply return the CM message

408
00:15:30,899 --> 00:15:33,000
and we specifically divide static key

409
00:15:33,000 --> 00:15:35,220
identifiers into two subcategories

410
00:15:35,220 --> 00:15:38,459
static key hints and static equipments

411
00:15:38,459 --> 00:15:40,560
for static key hints the key check value

412
00:15:40,560 --> 00:15:43,380
is computed using KRS so these can be

413
00:15:43,380 --> 00:15:46,139
short and efficiently computed however

414
00:15:46,139 --> 00:15:47,880
they cannot be used to commit to a key

415
00:15:47,880 --> 00:15:49,740
so they need to be used with the key

416
00:15:49,740 --> 00:15:52,139
robust aad screen to achieve care from

417
00:15:52,139 --> 00:15:54,600
the benefit of static key hints however

418
00:15:54,600 --> 00:15:56,279
is that they can be used in more

419
00:15:56,279 --> 00:15:58,320
bandwidth constrained environments when

420
00:15:58,320 --> 00:15:59,940
ciphertext links might need to be

421
00:15:59,940 --> 00:16:01,560
shorter

422
00:16:01,560 --> 00:16:02,940
and of course they don't provide

423
00:16:02,940 --> 00:16:07,139
anonymity since uh the key the key label

424
00:16:07,139 --> 00:16:09,420
and kitago themselves are static

425
00:16:09,420 --> 00:16:11,220
so there's a couple of examples of this

426
00:16:11,220 --> 00:16:12,899
Eastern practice

427
00:16:12,899 --> 00:16:15,660
in general they use something like AES

428
00:16:15,660 --> 00:16:17,880
and sha-1 computation and then from

429
00:16:17,880 --> 00:16:19,800
capab

430
00:16:19,800 --> 00:16:22,680
e commitments instead compute the key

431
00:16:22,680 --> 00:16:24,240
check value using a collision resistant

432
00:16:24,240 --> 00:16:26,220
tariff and these are longer and less

433
00:16:26,220 --> 00:16:27,839
efficient to compete than key hints

434
00:16:27,839 --> 00:16:29,699
however they can be used to commit to

435
00:16:29,699 --> 00:16:31,920
the key so they can be used with a

436
00:16:31,920 --> 00:16:35,579
non-care bus ADC to achieve a problem

437
00:16:35,579 --> 00:16:38,399
these again do not provide anonymity

438
00:16:38,399 --> 00:16:40,199
and one example of this season practice

439
00:16:40,199 --> 00:16:43,079
is the AWS encryption sdk's use of shot

440
00:16:43,079 --> 00:16:47,100
256 uh over the key

441
00:16:47,100 --> 00:16:49,560
and our Final Approach is the dynamic

442
00:16:49,560 --> 00:16:51,899
key identifiers approach this computes a

443
00:16:51,899 --> 00:16:54,420
dynamic identifier from the key and a

444
00:16:54,420 --> 00:16:56,459
nonce and uses this as the key tab so

445
00:16:56,459 --> 00:16:58,139
notice that each time during decryption

446
00:16:58,139 --> 00:17:00,779
we use a key we'll output a distinct key

447
00:17:00,779 --> 00:17:03,480
tag this is the key Anonymous

448
00:17:03,480 --> 00:17:04,799
counterpart to the static key

449
00:17:04,799 --> 00:17:07,319
identifiers approach and to preserve to

450
00:17:07,319 --> 00:17:09,599
preserve anonymity uh key labels will be

451
00:17:09,599 --> 00:17:10,559
empty

452
00:17:10,559 --> 00:17:12,540
this is Again parameterized by key check

453
00:17:12,540 --> 00:17:14,579
value function and encryption key direct

454
00:17:14,579 --> 00:17:17,699
derivation function and an aad scheme

455
00:17:17,699 --> 00:17:20,819
so encryption uh now uh computes the key

456
00:17:20,819 --> 00:17:22,799
check value using an ounce and the key

457
00:17:22,799 --> 00:17:26,220
check value itself is the key tab

458
00:17:26,220 --> 00:17:27,900
decryption will iterate again through

459
00:17:27,900 --> 00:17:29,940
the key Vector compute the key check

460
00:17:29,940 --> 00:17:32,940
value and compare that to the input key

461
00:17:32,940 --> 00:17:35,880
tag and if that matches we'll try to

462
00:17:35,880 --> 00:17:39,179
decrypt with the AAP scheme

463
00:17:39,179 --> 00:17:41,820
we again

464
00:17:41,820 --> 00:17:44,700
we can divide Dynamic um key identifiers

465
00:17:44,700 --> 00:17:47,039
into key hints and key commitments as

466
00:17:47,039 --> 00:17:49,559
before he hints are computed using a prf

467
00:17:49,559 --> 00:17:51,419
and can be shorter and more efficiently

468
00:17:51,419 --> 00:17:53,580
computed however they cannot be used to

469
00:17:53,580 --> 00:17:56,280
commit to a key so you need to use Acura

470
00:17:56,280 --> 00:17:59,340
bust a ABC with this Dynamic equipments

471
00:17:59,340 --> 00:18:01,799
alternatively are computed using a

472
00:18:01,799 --> 00:18:03,960
collision resistant prf and are longer

473
00:18:03,960 --> 00:18:05,460
and less sufficient to keep thinking

474
00:18:05,460 --> 00:18:07,620
hints however they can be used to commit

475
00:18:07,620 --> 00:18:09,120
to the key so you can safely use a

476
00:18:09,120 --> 00:18:11,580
non-kira bust AED scheme with them

477
00:18:11,580 --> 00:18:15,720
both approaches do provide anonymity

478
00:18:15,720 --> 00:18:18,059
so here's a summary of our various

479
00:18:18,059 --> 00:18:20,460
approaches and in particular staticky

480
00:18:20,460 --> 00:18:22,740
commitments and dynamic commitments are

481
00:18:22,740 --> 00:18:24,780
to approaches that do not need to be

482
00:18:24,780 --> 00:18:28,140
used uh with a hero bust aad scheme

483
00:18:28,140 --> 00:18:30,240
and trial decryption and dynamic key

484
00:18:30,240 --> 00:18:31,860
identifiers are of course our key

485
00:18:31,860 --> 00:18:34,860
Anonymous approaches

486
00:18:34,860 --> 00:18:37,260
so to conclude the current model for aad

487
00:18:37,260 --> 00:18:40,020
does not always capture how aad is used

488
00:18:40,020 --> 00:18:42,320
in practice we therefore introduce

489
00:18:42,320 --> 00:18:44,039
authenticated encryption with key

490
00:18:44,039 --> 00:18:46,200
identification which allows key

491
00:18:46,200 --> 00:18:48,000
identification during the decryption

492
00:18:48,000 --> 00:18:49,140
step

493
00:18:49,140 --> 00:18:51,179
we introduced new security definitions

494
00:18:51,179 --> 00:18:53,940
for the aadki setting and we analyze the

495
00:18:53,940 --> 00:18:55,679
security of existing key identification

496
00:18:55,679 --> 00:18:58,440
searches as well as suggesting new ones

497
00:18:58,440 --> 00:19:00,720
thank you and I have my email on here in

498
00:19:00,720 --> 00:19:01,980
case you want to chat more about this

499
00:19:01,980 --> 00:19:03,539
you can also read the full version of

500
00:19:03,539 --> 00:19:05,460
this work on ePrint I'm happy to take

501
00:19:05,460 --> 00:19:07,940
any questions

502
00:19:12,660 --> 00:19:16,100
other questions for Julia

503
00:19:23,280 --> 00:19:25,799
hi um thank you for your talk

504
00:19:25,799 --> 00:19:27,600
um you would mention that key labels can

505
00:19:27,600 --> 00:19:30,419
be used for key identification and that

506
00:19:30,419 --> 00:19:34,140
for that to be aadki it would demand

507
00:19:34,140 --> 00:19:36,360
that the underlying AED screen BK robot

508
00:19:36,360 --> 00:19:37,620
keto bus

509
00:19:37,620 --> 00:19:39,000
um do we know of any schemes that

510
00:19:39,000 --> 00:19:42,120
achieve this we spoke with tank a tink

511
00:19:42,120 --> 00:19:44,640
by Google is that keto burst the aad

512
00:19:44,640 --> 00:19:48,360
scheme it depends if they're using uh in

513
00:19:48,360 --> 00:19:51,900
bulk key robust ad scheme so in think

514
00:19:51,900 --> 00:19:54,299
for instance you might use it with ASG

515
00:19:54,299 --> 00:19:56,700
CM which is known to not be be robust

516
00:19:56,700 --> 00:19:59,039
and in that case you can't rely on the

517
00:19:59,039 --> 00:20:00,960
label to

518
00:20:00,960 --> 00:20:03,660
um permit to the key okay okay I'm sorry

519
00:20:03,660 --> 00:20:05,640
I have a follow-up question is there a

520
00:20:05,640 --> 00:20:07,860
way that we can convert an AED scheme to

521
00:20:07,860 --> 00:20:10,559
be robustly

522
00:20:10,559 --> 00:20:13,320
are there a couple of techniques

523
00:20:13,320 --> 00:20:16,860
um so like one is for instance the key

524
00:20:16,860 --> 00:20:19,140
and then attend that today do you seem

525
00:20:19,140 --> 00:20:21,000
some other approaches I've said to use

526
00:20:21,000 --> 00:20:23,100
for instance a plain text

527
00:20:23,100 --> 00:20:23,820
um

528
00:20:23,820 --> 00:20:26,280
like a block of zeros that you prepend

529
00:20:26,280 --> 00:20:27,900
to your text message and then you cut

530
00:20:27,900 --> 00:20:30,179
that actually description we can also

531
00:20:30,179 --> 00:20:31,799
talk online about various offline

532
00:20:31,799 --> 00:20:34,260
categories thank you

533
00:20:34,260 --> 00:20:38,840
there any more questions yes oh yeah

534
00:20:40,520 --> 00:20:43,140
one question when I thought right that

535
00:20:43,140 --> 00:20:47,100
the in syntax you separate those uh key

536
00:20:47,100 --> 00:20:49,919
tags from the ciphertax can you maybe

537
00:20:49,919 --> 00:20:52,740
comment on on why like why would we not

538
00:20:52,740 --> 00:20:54,660
want to consider

539
00:20:54,660 --> 00:20:57,539
um the key type part of the ciphertext

540
00:20:57,539 --> 00:20:59,160
and it's kind of like a task of the

541
00:20:59,160 --> 00:21:01,200
decryption scheme to figure it out where

542
00:21:01,200 --> 00:21:02,760
to pull it from

543
00:21:02,760 --> 00:21:04,200
so this is

544
00:21:04,200 --> 00:21:06,720
um following some of the aead syntax in

545
00:21:06,720 --> 00:21:08,160
authenticator encryption which might

546
00:21:08,160 --> 00:21:10,260
have the authentication tag is separate

547
00:21:10,260 --> 00:21:12,840
from the ciphertext

548
00:21:12,840 --> 00:21:14,280
um you could

549
00:21:14,280 --> 00:21:17,160
change this so that uh you just output a

550
00:21:17,160 --> 00:21:19,320
ciphertext but we wanted to like be more

551
00:21:19,320 --> 00:21:21,720
explicit about that you're outputting a

552
00:21:21,720 --> 00:21:23,220
special

553
00:21:23,220 --> 00:21:25,740
the tag as part of the ciphertext that

554
00:21:25,740 --> 00:21:27,840
should be used as part of the encryption

555
00:21:27,840 --> 00:21:28,799
set

556
00:21:28,799 --> 00:21:31,380
okay does any of your construction kind

557
00:21:31,380 --> 00:21:33,360
of like meet that it's been tactically

558
00:21:33,360 --> 00:21:35,520
spelled out or could they all in

559
00:21:35,520 --> 00:21:36,900
principle retrieve it from the

560
00:21:36,900 --> 00:21:39,179
ciphertext you could also do retrieve it

561
00:21:39,179 --> 00:21:40,500
from the ciphertext I think we just

562
00:21:40,500 --> 00:21:42,780
wanted to be more explicit uh in order

563
00:21:42,780 --> 00:21:46,440
to highlight that this is an extra

564
00:21:46,440 --> 00:21:51,140
um part of the cipher cats okay thanks

565
00:21:51,780 --> 00:21:54,360
any more questions let me take a quick

566
00:21:54,360 --> 00:21:57,000
look if I can see any questions in the

567
00:21:57,000 --> 00:22:00,179
chat here I don't see any I have one

568
00:22:00,179 --> 00:22:02,340
question I mean this um this work is

569
00:22:02,340 --> 00:22:03,780
clearly very much motivated from real

570
00:22:03,780 --> 00:22:05,159
world examples so you mentioned Google

571
00:22:05,159 --> 00:22:08,220
thing AWS KMS did you contact the teams

572
00:22:08,220 --> 00:22:10,740
at say Google and AWS and if so what was

573
00:22:10,740 --> 00:22:13,500
their reaction on this work oh we hadn't

574
00:22:13,500 --> 00:22:16,919
contacted them I think um

575
00:22:16,919 --> 00:22:20,400
it's not like we didn't find an actual

576
00:22:20,400 --> 00:22:22,980
vulnerability so um it didn't seem

577
00:22:22,980 --> 00:22:26,299
necessary to contact them but we can

578
00:22:26,299 --> 00:22:28,200
maybe they're interested to hear that

579
00:22:28,200 --> 00:22:29,460
but you're actually looking at this I

580
00:22:29,460 --> 00:22:30,840
mean it's also positive results they

581
00:22:30,840 --> 00:22:32,460
might actually be happy to be here right

582
00:22:32,460 --> 00:22:35,100
so definitely yeah we should definitely

583
00:22:35,100 --> 00:22:37,020
consider that in the future okay thanks

584
00:22:37,020 --> 00:22:39,299
thanks

585
00:22:39,299 --> 00:22:41,039
um as I don't see any further questions

586
00:22:41,039 --> 00:22:43,140
please join me in thanking Julia again

587
00:22:43,140 --> 00:22:46,140
exactly

588
00:22:48,299 --> 00:22:51,139
and then

589
00:22:55,559 --> 00:22:57,960
our

590
00:22:57,960 --> 00:23:00,419
next speaker the next talk will be given

591
00:23:00,419 --> 00:23:03,960
remotely by yolu from Shanghai

592
00:23:03,960 --> 00:23:07,440
University and you know the floor is all

593
00:23:07,440 --> 00:23:08,400
yours

594
00:23:08,400 --> 00:23:11,220
oh okay can you hear me

595
00:23:11,220 --> 00:23:15,419
yes okay hello everyone I'm Julie from

596
00:23:15,419 --> 00:23:18,299
Shanghai University today I will share

597
00:23:18,299 --> 00:23:20,100
our work privacy preserving

598
00:23:20,100 --> 00:23:22,200
authenticated key change in the standard

599
00:23:22,200 --> 00:23:23,100
model

600
00:23:23,100 --> 00:23:25,620
this is a joint work with Sean Liu

601
00:23:25,620 --> 00:23:28,260
schreichan and tawuku

602
00:23:28,260 --> 00:23:30,600
I will introduce our work from the

603
00:23:30,600 --> 00:23:32,039
following perspectives

604
00:23:32,039 --> 00:23:34,080
first I will talk about the definition

605
00:23:34,080 --> 00:23:37,919
of PPA ke and its security next we will

606
00:23:37,919 --> 00:23:40,380
give our construction and analyze its

607
00:23:40,380 --> 00:23:42,600
security finally we will give the

608
00:23:42,600 --> 00:23:45,780
conclusion and some future work

609
00:23:45,780 --> 00:23:48,000
now we recall the authenticated key

610
00:23:48,000 --> 00:23:51,179
exchange first ake allows two parties to

611
00:23:51,179 --> 00:23:53,100
authenticate each other and securely

612
00:23:53,100 --> 00:23:56,039
share a session key it has been widely

613
00:23:56,039 --> 00:23:58,020
used in data sharing electronic

614
00:23:58,020 --> 00:24:00,679
notebooks as shown in the left figure

615
00:24:00,679 --> 00:24:04,440
user UI has long-term key as ski and

616
00:24:04,440 --> 00:24:08,100
user ug has long-term key sskg when they

617
00:24:08,100 --> 00:24:10,380
want to share a session key they will

618
00:24:10,380 --> 00:24:13,320
send some messages to each other and at

619
00:24:13,320 --> 00:24:17,460
last they will agree on the session key

620
00:24:17,460 --> 00:24:21,120
however there is a problem in some cases

621
00:24:21,120 --> 00:24:23,580
the interacting parties may want their

622
00:24:23,580 --> 00:24:27,299
identity kept secret from others however

623
00:24:27,299 --> 00:24:29,400
their transcripts sent in the channel

624
00:24:29,400 --> 00:24:31,440
may contain information about their

625
00:24:31,440 --> 00:24:32,760
identities

626
00:24:32,760 --> 00:24:35,880
thus the concept of privacy preserving

627
00:24:35,880 --> 00:24:39,299
authenticated key change is proposed it

628
00:24:39,299 --> 00:24:40,919
requires anonymity

629
00:24:40,919 --> 00:24:43,020
which means the adversary cannot

630
00:24:43,020 --> 00:24:46,080
identify the users who are communicating

631
00:24:46,080 --> 00:24:50,059
even seeing their transcripts

632
00:24:50,460 --> 00:24:53,520
actually most AKA Protocols are not

633
00:24:53,520 --> 00:24:56,640
privacy preserving for example the

634
00:24:56,640 --> 00:24:59,100
well-known science GH protocol is not

635
00:24:59,100 --> 00:25:01,799
privacy preserving in sand different

636
00:25:01,799 --> 00:25:05,400
human protocol each party uses a

637
00:25:05,400 --> 00:25:07,919
different human key exchange to agree on

638
00:25:07,919 --> 00:25:11,460
a session key and use its signatures to

639
00:25:11,460 --> 00:25:13,620
authenticate each other

640
00:25:13,620 --> 00:25:16,740
the signature leaks the identity of both

641
00:25:16,740 --> 00:25:19,980
initiator and responder the adversary

642
00:25:19,980 --> 00:25:22,380
can guess the initiator and responders

643
00:25:22,380 --> 00:25:25,620
identity and check his guys by verifying

644
00:25:25,620 --> 00:25:28,340
the signature

645
00:25:28,559 --> 00:25:30,679
who saw this problem

646
00:25:30,679 --> 00:25:33,600
ssl20 proposed a way to protect the

647
00:25:33,600 --> 00:25:37,320
identity of users with PPA ke

648
00:25:37,320 --> 00:25:40,140
it can it considers the server to server

649
00:25:40,140 --> 00:25:41,279
scenario

650
00:25:41,279 --> 00:25:43,980
let's focus on the left figure

651
00:25:43,980 --> 00:25:46,620
in a server to server setting both the

652
00:25:46,620 --> 00:25:48,960
initiator and the responder are agent

653
00:25:48,960 --> 00:25:52,320
servers and behind each agent server

654
00:25:52,320 --> 00:25:55,020
there says many users

655
00:25:55,020 --> 00:25:57,360
the adversary controls the server to

656
00:25:57,360 --> 00:26:00,120
server Channel but does not controls the

657
00:26:00,120 --> 00:26:02,460
user to server Channel

658
00:26:02,460 --> 00:26:06,539
for example if user U1 wants to start a

659
00:26:06,539 --> 00:26:09,539
session with user UFO instead of sending

660
00:26:09,539 --> 00:26:13,380
messages to u4 directly it will send its

661
00:26:13,380 --> 00:26:16,559
message to the to its agent server a

662
00:26:16,559 --> 00:26:18,779
then the agent server a commutes

663
00:26:18,779 --> 00:26:22,260
commutes communicates with server B and

664
00:26:22,260 --> 00:26:24,960
server B finally passes the message to

665
00:26:24,960 --> 00:26:28,140
the Target user u4

666
00:26:28,140 --> 00:26:31,260
anonymity in this setting requires the

667
00:26:31,260 --> 00:26:34,500
adversary cannot distinguish which user

668
00:26:34,500 --> 00:26:37,320
says behind the agent server if even if

669
00:26:37,320 --> 00:26:39,360
they can control the server to server

670
00:26:39,360 --> 00:26:41,539
Channel

671
00:26:42,240 --> 00:26:45,419
now we recall the construction idea of

672
00:26:45,419 --> 00:26:48,059
SSL PPA key

673
00:26:48,059 --> 00:26:50,220
the protocol is also based on the

674
00:26:50,220 --> 00:26:52,380
different element key exchange

675
00:26:52,380 --> 00:26:55,919
where session starts both users first do

676
00:26:55,919 --> 00:26:59,100
an anonymous DFA helmetry exchange to

677
00:26:59,100 --> 00:27:02,820
get a ephemeral key then they use this

678
00:27:02,820 --> 00:27:05,580
defeat human key to encrypt the

679
00:27:05,580 --> 00:27:08,159
signature to hide their identity and

680
00:27:08,159 --> 00:27:11,299
authenticate each other

681
00:27:11,659 --> 00:27:15,179
however due to the lack of authenticity

682
00:27:15,179 --> 00:27:17,580
in the first two runs It suffers an

683
00:27:17,580 --> 00:27:19,020
active attack

684
00:27:19,020 --> 00:27:21,840
if an adversary modifies the second

685
00:27:21,840 --> 00:27:24,299
message then it shares the same

686
00:27:24,299 --> 00:27:27,299
different element key with the initiator

687
00:27:27,299 --> 00:27:29,580
after the initiators sent the third

688
00:27:29,580 --> 00:27:32,220
message the adversary can decrypt the

689
00:27:32,220 --> 00:27:35,159
server text and get the identity of the

690
00:27:35,159 --> 00:27:36,720
initiator

691
00:27:36,720 --> 00:27:40,559
besides SSL PPA ke considers the server

692
00:27:40,559 --> 00:27:43,679
to server scenario and does not apply to

693
00:27:43,679 --> 00:27:46,620
the user to user scenario like what the

694
00:27:46,620 --> 00:27:49,500
scenario of violin Bluetooth or Apple's

695
00:27:49,500 --> 00:27:51,799
airdrop

696
00:27:51,799 --> 00:27:55,980
hence a question is how to design a ppke

697
00:27:55,980 --> 00:28:00,299
protocol for the user to user scenario

698
00:28:00,299 --> 00:28:03,299
in the user to user scenario there are

699
00:28:03,299 --> 00:28:06,120
no agent servers we also consider the

700
00:28:06,120 --> 00:28:08,400
broadcast channel just like the scenario

701
00:28:08,400 --> 00:28:11,520
of Bluetooth wireless and air job

702
00:28:11,520 --> 00:28:14,400
the adversary can see the message in the

703
00:28:14,400 --> 00:28:17,400
broadcast channel and you will in the

704
00:28:17,400 --> 00:28:20,580
communication of users

705
00:28:20,580 --> 00:28:23,299
next we introduce the security

706
00:28:23,299 --> 00:28:26,279
requirements for PPA ke in the user to

707
00:28:26,279 --> 00:28:29,179
user scenario

708
00:28:29,360 --> 00:28:32,700
the explicit authentication means the

709
00:28:32,700 --> 00:28:35,100
active attack can be identified

710
00:28:35,100 --> 00:28:38,460
for example if the adversary changes the

711
00:28:38,460 --> 00:28:41,820
first message sent from UI to ug

712
00:28:41,820 --> 00:28:43,140
then

713
00:28:43,140 --> 00:28:45,480
ug will reject this station at last with

714
00:28:45,480 --> 00:28:47,520
overwhelming probability

715
00:28:47,520 --> 00:28:51,299
and for each accepted user UI there is a

716
00:28:51,299 --> 00:28:54,600
unique partner ug such that the output

717
00:28:54,600 --> 00:28:58,140
of UI is the input of UG and the output

718
00:28:58,140 --> 00:29:01,200
of u j is the input of UI

719
00:29:01,200 --> 00:29:04,980
in this example if user UI and ug are

720
00:29:04,980 --> 00:29:08,580
accepted then it must hold M1 equal to

721
00:29:08,580 --> 00:29:12,419
M1 Prime and M2 Prime M2 equal to M2

722
00:29:12,419 --> 00:29:14,659
Prime

723
00:29:15,659 --> 00:29:19,140
okay forward security for session key

724
00:29:19,140 --> 00:29:21,840
means the session key is pseudely random

725
00:29:21,840 --> 00:29:24,899
if there are no active attacks even if

726
00:29:24,899 --> 00:29:28,200
the long-term key of users are linked to

727
00:29:28,200 --> 00:29:30,860
the adversary

728
00:29:32,460 --> 00:29:35,159
a non-limitary requires given the

729
00:29:35,159 --> 00:29:37,260
transcript the adversary cannot

730
00:29:37,260 --> 00:29:39,240
distinguish which two users are

731
00:29:39,240 --> 00:29:40,980
communicating

732
00:29:40,980 --> 00:29:43,679
so adversary can also involve in their

733
00:29:43,679 --> 00:29:46,620
communication by sending messages in the

734
00:29:46,620 --> 00:29:48,539
broadcast channel

735
00:29:48,539 --> 00:29:51,360
forward anonymity means the anonymity

736
00:29:51,360 --> 00:29:53,640
still holds even if the adversary

737
00:29:53,640 --> 00:29:56,640
corrupts these users after the adversary

738
00:29:56,640 --> 00:29:59,659
gets the transcript

739
00:30:00,600 --> 00:30:03,899
for example suppose the adversary gets a

740
00:30:03,899 --> 00:30:07,080
long-term key of user ug-1 and the

741
00:30:07,080 --> 00:30:08,820
transcript

742
00:30:08,820 --> 00:30:11,279
forward and on he requires the adversary

743
00:30:11,279 --> 00:30:13,919
cannot determine whether user ug-1 was

744
00:30:13,919 --> 00:30:18,440
involved in the previous communication

745
00:30:20,960 --> 00:30:24,960
now let's see what happens if we use SSL

746
00:30:24,960 --> 00:30:29,580
PPA in the user to user setting directly

747
00:30:29,580 --> 00:30:32,399
suppose user UI wants to communicate

748
00:30:32,399 --> 00:30:34,620
with user ug2

749
00:30:34,620 --> 00:30:37,080
she will first broadcast a g to the

750
00:30:37,080 --> 00:30:39,960
power of a to all of users

751
00:30:39,960 --> 00:30:43,260
and to keep anonymity the first message

752
00:30:43,260 --> 00:30:45,960
does not contain any information about

753
00:30:45,960 --> 00:30:48,179
its Target recipient

754
00:30:48,179 --> 00:30:51,240
each user is not sure whether he is the

755
00:30:51,240 --> 00:30:53,220
target recipient after receiving the

756
00:30:53,220 --> 00:30:54,659
first message

757
00:30:54,659 --> 00:30:58,200
so each user must reply with a g to the

758
00:30:58,200 --> 00:31:00,919
power of B

759
00:31:02,580 --> 00:31:05,159
now user UI receives all the messages

760
00:31:05,159 --> 00:31:08,220
but she is still not able to identify

761
00:31:08,220 --> 00:31:11,220
the right message sent from the intended

762
00:31:11,220 --> 00:31:13,140
party ug2

763
00:31:13,140 --> 00:31:16,559
to continue UI has to compute all

764
00:31:16,559 --> 00:31:18,779
development keys and encrypt the

765
00:31:18,779 --> 00:31:20,640
signature with each different element

766
00:31:20,640 --> 00:31:21,659
key

767
00:31:21,659 --> 00:31:24,600
this will cause large communication and

768
00:31:24,600 --> 00:31:26,580
computation complexity

769
00:31:26,580 --> 00:31:29,340
moreover the anniversary can also send a

770
00:31:29,340 --> 00:31:31,380
g to the power of B

771
00:31:31,380 --> 00:31:34,260
and then it can always decrypt once

772
00:31:34,260 --> 00:31:36,539
advertised and then determines the

773
00:31:36,539 --> 00:31:39,980
initiator's identity

774
00:31:42,600 --> 00:31:45,779
so we need to design a new PPA ke

775
00:31:45,779 --> 00:31:48,779
protocol for the user to user citing our

776
00:31:48,779 --> 00:31:52,860
approach is to make PPA ke robust

777
00:31:52,860 --> 00:31:57,059
we see a ppke protocol is robust if each

778
00:31:57,059 --> 00:31:59,580
user is able to ascertain that the

779
00:31:59,580 --> 00:32:02,399
message in the first round is for him or

780
00:32:02,399 --> 00:32:03,240
her

781
00:32:03,240 --> 00:32:06,179
any user accepts the target recipients

782
00:32:06,179 --> 00:32:08,520
will output failure when they receive

783
00:32:08,520 --> 00:32:12,000
the first round message of PPA ke

784
00:32:12,000 --> 00:32:15,720
in this figure user UI wants to talk to

785
00:32:15,720 --> 00:32:20,100
uj2 and broadcasts the first message

786
00:32:20,100 --> 00:32:22,380
then after receiving the first round

787
00:32:22,380 --> 00:32:25,799
message only user ug2 will reply for

788
00:32:25,799 --> 00:32:28,919
this message and other users will keep

789
00:32:28,919 --> 00:32:30,419
silent

790
00:32:30,419 --> 00:32:32,700
with the robustness the communication

791
00:32:32,700 --> 00:32:34,919
and computation complexity can be

792
00:32:34,919 --> 00:32:37,340
reduced

793
00:32:38,399 --> 00:32:42,979
next we will introduce our Construction

794
00:32:43,559 --> 00:32:46,620
we propose a generic construction from a

795
00:32:46,620 --> 00:32:49,200
signatures game a key encapsulation

796
00:32:49,200 --> 00:32:52,440
mechanism a message authentication code

797
00:32:52,440 --> 00:32:55,880
and symmetric encryption

798
00:32:55,880 --> 00:32:59,399
we will talk a bit more about cam

799
00:32:59,399 --> 00:33:01,799
we require the cam for two more

800
00:33:01,799 --> 00:33:05,039
properties one is anonymity

801
00:33:05,039 --> 00:33:08,279
which means given the server type c and

802
00:33:08,279 --> 00:33:11,580
two public keys the adversary cannot

803
00:33:11,580 --> 00:33:14,159
determine the safety type c is generated

804
00:33:14,159 --> 00:33:16,260
by which public key

805
00:33:16,260 --> 00:33:19,740
and the other property is robustness

806
00:33:19,740 --> 00:33:22,620
if a server test is generated by one

807
00:33:22,620 --> 00:33:25,919
public key then using another secret key

808
00:33:25,919 --> 00:33:28,559
to decrypt it will output failure with

809
00:33:28,559 --> 00:33:31,820
overwhelming probability

810
00:33:31,820 --> 00:33:35,159
now we will introduce our Construction

811
00:33:35,159 --> 00:33:39,000
suppose user UI is the initiator and its

812
00:33:39,000 --> 00:33:41,880
Target recipient is user ug2

813
00:33:41,880 --> 00:33:45,600
it will first encapsulate a key K1 using

814
00:33:45,600 --> 00:33:48,840
the target's public key then it will

815
00:33:48,840 --> 00:33:52,080
broadcast a g to the power of a and the

816
00:33:52,080 --> 00:33:54,980
several types C

817
00:33:55,080 --> 00:33:58,019
after receiving the first message each

818
00:33:58,019 --> 00:34:00,240
user tries to decapsulate the server

819
00:34:00,240 --> 00:34:03,480
test C using its own secret key

820
00:34:03,480 --> 00:34:07,740
and only user ug2 will get K1 other

821
00:34:07,740 --> 00:34:09,780
users will get a failure by the

822
00:34:09,780 --> 00:34:12,859
robustness of Cam

823
00:34:13,159 --> 00:34:17,219
next user ug2 computes a default Helmet

824
00:34:17,219 --> 00:34:21,000
Key and uses K1 to authenticate the

825
00:34:21,000 --> 00:34:23,280
message it receives and the message it

826
00:34:23,280 --> 00:34:24,418
sends

827
00:34:24,418 --> 00:34:27,000
the other users will keep silent during

828
00:34:27,000 --> 00:34:29,040
the precise since they are not the

829
00:34:29,040 --> 00:34:32,159
target recipients then user ug2 will

830
00:34:32,159 --> 00:34:36,740
broadcast G to the power of B and sigma

831
00:34:36,918 --> 00:34:40,260
in the third round user UI will check

832
00:34:40,260 --> 00:34:44,159
the wallet the validity of Sigma and

833
00:34:44,159 --> 00:34:47,300
computes the same difficult monkey

834
00:34:47,300 --> 00:34:51,540
derives key K2 to encrypt its identity

835
00:34:51,540 --> 00:34:54,480
and a signature and then it will

836
00:34:54,480 --> 00:34:57,660
broadcast several times C

837
00:34:57,660 --> 00:35:00,960
after receiving the several types user

838
00:35:00,960 --> 00:35:03,839
ug2 decrypts C using K2 to get the

839
00:35:03,839 --> 00:35:06,900
identity of its initiator and the

840
00:35:06,900 --> 00:35:08,099
signature

841
00:35:08,099 --> 00:35:12,060
and verify the signature finally user UI

842
00:35:12,060 --> 00:35:14,640
and user ut2 will share the same session

843
00:35:14,640 --> 00:35:17,420
key K3

844
00:35:18,420 --> 00:35:22,800
now we analyze our broadcast security

845
00:35:22,800 --> 00:35:25,859
the authentication of responder relies

846
00:35:25,859 --> 00:35:30,300
on cam and Mac in this example only user

847
00:35:30,300 --> 00:35:34,079
ug2 can decrypt C to get K1 and

848
00:35:34,079 --> 00:35:39,380
generates the same Sigma with user UI

849
00:35:41,280 --> 00:35:43,800
and the authentication of initiator

850
00:35:43,800 --> 00:35:47,220
release on the signature only user UI

851
00:35:47,220 --> 00:35:50,040
can generate the valid signature in the

852
00:35:50,040 --> 00:35:51,060
search round

853
00:35:51,060 --> 00:35:54,480
and since all transcripts is signed by

854
00:35:54,480 --> 00:35:57,660
signature or targeted by Mac the

855
00:35:57,660 --> 00:36:00,240
explicit authentication is insured by

856
00:36:00,240 --> 00:36:02,779
our Construction

857
00:36:03,500 --> 00:36:06,720
also due to the explicit authentication

858
00:36:06,720 --> 00:36:10,680
now there are no active attacks then the

859
00:36:10,680 --> 00:36:13,440
key studio Randomness is generated by

860
00:36:13,440 --> 00:36:17,720
the default human key exchange protocol

861
00:36:18,660 --> 00:36:22,020
more not that the session key is

862
00:36:22,020 --> 00:36:24,300
independent with the long-term key of

863
00:36:24,300 --> 00:36:25,680
both users

864
00:36:25,680 --> 00:36:27,839
or construction also has forward

865
00:36:27,839 --> 00:36:30,259
security

866
00:36:31,859 --> 00:36:34,320
now we discussed the anonymity of our

867
00:36:34,320 --> 00:36:37,680
construction the initiators identity

868
00:36:37,680 --> 00:36:40,140
information is only contained in the

869
00:36:40,140 --> 00:36:43,140
search run message and this message is

870
00:36:43,140 --> 00:36:45,599
encrypted by the different element key

871
00:36:45,599 --> 00:36:48,300
so it is protected well

872
00:36:48,300 --> 00:36:51,660
the responder's identity is only

873
00:36:51,660 --> 00:36:54,540
contained in the first round message and

874
00:36:54,540 --> 00:36:57,119
due to the anonymity of Cam the

875
00:36:57,119 --> 00:36:59,820
adversary cannot know the server test C

876
00:36:59,820 --> 00:37:04,040
is encrypted by which public key

877
00:37:04,400 --> 00:37:07,140
however our construction can only

878
00:37:07,140 --> 00:37:09,780
achieve seeming forward anonymity for

879
00:37:09,780 --> 00:37:12,720
the responder if the long-term key of

880
00:37:12,720 --> 00:37:16,320
user ug2 is leaked the adversary can

881
00:37:16,320 --> 00:37:19,260
decrypt the safety C successfully

882
00:37:19,260 --> 00:37:23,220
then it can determine uj2 is one of the

883
00:37:23,220 --> 00:37:26,940
responders in previous Communications

884
00:37:26,940 --> 00:37:30,320
this is a common problem for robust ppak

885
00:37:30,320 --> 00:37:33,300
to achieve robustness

886
00:37:33,300 --> 00:37:35,940
the first message must bind to the

887
00:37:35,940 --> 00:37:38,160
long-term key of the responder

888
00:37:38,160 --> 00:37:41,099
then if the long-term key of user J is

889
00:37:41,099 --> 00:37:43,619
leakied the diversary can check whether

890
00:37:43,619 --> 00:37:47,780
G is a target responder

891
00:37:48,300 --> 00:37:51,420
at last we will compare our work with

892
00:37:51,420 --> 00:37:53,700
some related work and give some future

893
00:37:53,700 --> 00:37:55,980
directions

894
00:37:55,980 --> 00:37:58,079
let's look at the table

895
00:37:58,079 --> 00:38:01,079
this column means the communication

896
00:38:01,079 --> 00:38:04,380
complexity of the broadcast and this

897
00:38:04,380 --> 00:38:07,280
means the computation complexity of

898
00:38:07,280 --> 00:38:10,740
protocols this means the number of runs

899
00:38:10,740 --> 00:38:14,099
of the protocols and this means whether

900
00:38:14,099 --> 00:38:17,220
the protocol has a forward security

901
00:38:17,220 --> 00:38:19,099
this means

902
00:38:19,099 --> 00:38:22,380
whether the protocol has anonymity for

903
00:38:22,380 --> 00:38:26,280
initiator and for responder

904
00:38:26,280 --> 00:38:30,359
this Canon this column means if the

905
00:38:30,359 --> 00:38:35,220
initiator was corrupted then whether the

906
00:38:35,220 --> 00:38:37,980
anonymity still holds for the initiator

907
00:38:37,980 --> 00:38:41,339
and for the responder

908
00:38:41,339 --> 00:38:44,640
and this means whether the protocol has

909
00:38:44,640 --> 00:38:47,040
virtual authentication and this means

910
00:38:47,040 --> 00:38:50,460
the protocol is proved by its proved in

911
00:38:50,460 --> 00:38:53,040
the standard model or the random Oracle

912
00:38:53,040 --> 00:38:54,900
model

913
00:38:54,900 --> 00:38:58,320
okay compared with the first scheme or

914
00:38:58,320 --> 00:39:00,660
or protocol

915
00:39:00,660 --> 00:39:03,960
has Mutual authentication and full

916
00:39:03,960 --> 00:39:05,400
anonymity

917
00:39:05,400 --> 00:39:08,460
and the second protocol has no forward

918
00:39:08,460 --> 00:39:10,140
anonymity

919
00:39:10,140 --> 00:39:14,579
and the ssl20 and rsw21 has large

920
00:39:14,579 --> 00:39:19,160
communication and computation complexity

921
00:39:19,920 --> 00:39:23,820
to conclude we propose a PPA ke scheme

922
00:39:23,820 --> 00:39:26,460
especially for the broadcast channel and

923
00:39:26,460 --> 00:39:29,220
user to user setting we also give a

924
00:39:29,220 --> 00:39:31,619
concrete installation based on ddh

925
00:39:31,619 --> 00:39:33,720
assumption

926
00:39:33,720 --> 00:39:36,900
and we also leave an interesting problem

927
00:39:36,900 --> 00:39:40,020
that can reconstruct a PPA scheme that

928
00:39:40,020 --> 00:39:42,660
satisfied full forward non-meteria or

929
00:39:42,660 --> 00:39:43,859
model

930
00:39:43,859 --> 00:39:46,920
okay thank you that's all thank you for

931
00:39:46,920 --> 00:39:48,420
your attention

932
00:39:48,420 --> 00:39:50,579
if there are any questions

933
00:39:50,579 --> 00:39:53,960
we'll come to questions

934
00:39:54,900 --> 00:39:57,000
thank you very much for the nice talk I

935
00:39:57,000 --> 00:39:58,140
hope that you can could hear the

936
00:39:58,140 --> 00:40:00,420
Applause are there questions from the

937
00:40:00,420 --> 00:40:02,720
audience

938
00:40:05,700 --> 00:40:07,560
well while people are still raising

939
00:40:07,560 --> 00:40:08,880
their hands and I have actually two

940
00:40:08,880 --> 00:40:10,380
questions so one is just from my

941
00:40:10,380 --> 00:40:12,119
understanding the robustness notion that

942
00:40:12,119 --> 00:40:14,579
you need for the cam you said

943
00:40:14,579 --> 00:40:16,560
um that the probability that another

944
00:40:16,560 --> 00:40:19,440
public key is able to

945
00:40:19,440 --> 00:40:21,240
um sorry another secret key is able to

946
00:40:21,240 --> 00:40:23,700
decrypt

947
00:40:23,700 --> 00:40:26,359
is

948
00:40:26,359 --> 00:40:29,520
so is that sort of a is that a statistic

949
00:40:29,520 --> 00:40:31,740
notion or is that an adversarial notion

950
00:40:31,740 --> 00:40:33,300
as in

951
00:40:33,300 --> 00:40:35,280
um can I construct a different public

952
00:40:35,280 --> 00:40:38,040
key or is that a statistic

953
00:40:38,040 --> 00:40:40,640
yeah does that question make sense

954
00:40:40,640 --> 00:40:45,599
actually I think uh in in our

955
00:40:45,599 --> 00:40:48,660
construction we only need the weak

956
00:40:48,660 --> 00:40:50,099
robustness

957
00:40:50,099 --> 00:40:52,140
and we only

958
00:40:52,140 --> 00:40:55,079
uh

959
00:40:55,079 --> 00:40:57,060
um I think

960
00:40:57,060 --> 00:40:58,760
um

961
00:40:58,760 --> 00:41:03,480
okay it just means we need to

962
00:41:03,480 --> 00:41:05,599
if you encrypt the

963
00:41:05,599 --> 00:41:09,240
server tester using one public key and

964
00:41:09,240 --> 00:41:13,500
then other you use other secret key to

965
00:41:13,500 --> 00:41:16,980
decrypt it will output failure

966
00:41:16,980 --> 00:41:20,960
and with overwhelming probability

967
00:41:21,200 --> 00:41:23,700
okay I got it sorry

968
00:41:23,700 --> 00:41:25,800
um I had let me see if there's more

969
00:41:25,800 --> 00:41:27,660
questions

970
00:41:27,660 --> 00:41:29,579
don't see any there's one question

971
00:41:29,579 --> 00:41:30,780
that's maybe a bit of a mean question

972
00:41:30,780 --> 00:41:32,760
but um usually when you're doing

973
00:41:32,760 --> 00:41:35,339
anonymity protocols in like on the

974
00:41:35,339 --> 00:41:37,619
internet right then you assume that

975
00:41:37,619 --> 00:41:39,839
sort of the network anonymity is given

976
00:41:39,839 --> 00:41:42,359
for example by people using Tor and then

977
00:41:42,359 --> 00:41:44,339
you use the assumption that this the

978
00:41:44,339 --> 00:41:46,560
network layer is anonymous yeah there's

979
00:41:46,560 --> 00:41:48,300
something that you sketched

980
00:41:48,300 --> 00:41:50,099
um is a local area network where just

981
00:41:50,099 --> 00:41:51,839
everyone is on the same Wi-Fi

982
00:41:51,839 --> 00:41:53,760
yes in the network layer you would just

983
00:41:53,760 --> 00:41:55,140
send your messages and they have a MAC

984
00:41:55,140 --> 00:41:57,000
address and well usually that identifies

985
00:41:57,000 --> 00:41:58,920
you except if you randomize that one and

986
00:41:58,920 --> 00:42:00,540
probably do some more things

987
00:42:00,540 --> 00:42:01,980
um are you aware of approaches that

988
00:42:01,980 --> 00:42:04,500
would sort of composed with the protocol

989
00:42:04,500 --> 00:42:06,300
layer anonymity and if you're also

990
00:42:06,300 --> 00:42:08,220
Network layer anonymity for

991
00:42:08,220 --> 00:42:11,460
say Wi-Fi or airdrop or what's the

992
00:42:11,460 --> 00:42:14,420
status there do you know

993
00:42:14,420 --> 00:42:18,619
I think our protocol

994
00:42:18,720 --> 00:42:22,520
needs a MAC address does not

995
00:42:22,520 --> 00:42:27,660
review the user's Identity or okay yeah

996
00:42:27,660 --> 00:42:32,220
I think we rely on this or maybe you can

997
00:42:32,220 --> 00:42:37,320
not use the MAC address maybe since you

998
00:42:37,320 --> 00:42:39,740
yeah

999
00:42:40,140 --> 00:42:42,420
all right

1000
00:42:42,420 --> 00:42:45,060
um okay I don't see

1001
00:42:45,060 --> 00:42:47,099
any further questions so please join me

1002
00:42:47,099 --> 00:42:48,660
in thanking you again

1003
00:42:48,660 --> 00:42:50,720
thank you

1004
00:42:50,720 --> 00:42:55,560
thank you for your talk okay and we

1005
00:42:55,560 --> 00:42:57,420
will move to the last Talk of the

1006
00:42:57,420 --> 00:42:58,800
session which will also be given

1007
00:42:58,800 --> 00:43:00,060
remotely

1008
00:43:00,060 --> 00:43:02,579
and I will wait

1009
00:43:02,579 --> 00:43:04,500
for technology follow-up it will be

1010
00:43:04,500 --> 00:43:06,780
given by Jamin Sue

1011
00:43:06,780 --> 00:43:09,720
um from Shandong University

1012
00:43:09,720 --> 00:43:12,720
and

1013
00:43:14,819 --> 00:43:18,359
we'll see them yet oh okay

1014
00:43:18,359 --> 00:43:20,160
all right so the floor is all yours

1015
00:43:20,160 --> 00:43:21,540
thank you

1016
00:43:21,540 --> 00:43:24,540
oh thanks for the introduction I will

1017
00:43:24,540 --> 00:43:26,520
give the talk on the field-based

1018
00:43:26,520 --> 00:43:29,280
division property applications to Mimi

1019
00:43:29,280 --> 00:43:32,700
say first to me say and Jimmy Missy

1020
00:43:32,700 --> 00:43:36,980
umizoi and it is a joint work with

1021
00:43:39,300 --> 00:43:42,000
so this presentation consists of four

1022
00:43:42,000 --> 00:43:44,220
parts and I will first give some

1023
00:43:44,220 --> 00:43:45,599
background knowledge about the

1024
00:43:45,599 --> 00:43:47,640
algebraically simple metric key

1025
00:43:47,640 --> 00:43:49,500
Primitives

1026
00:43:49,500 --> 00:43:52,500
so the main topics is the symmetric key

1027
00:43:52,500 --> 00:43:55,200
Primitives that are efficient in several

1028
00:43:55,200 --> 00:43:57,119
applications like multi-party

1029
00:43:57,119 --> 00:43:59,339
computation for the homomorphic

1030
00:43:59,339 --> 00:44:02,400
encryption and there are knowledge proof

1031
00:44:02,400 --> 00:44:05,700
instead of the optimization for Speed or

1032
00:44:05,700 --> 00:44:08,640
memory consumption we need to reconsider

1033
00:44:08,640 --> 00:44:11,760
which operations are costly and which

1034
00:44:11,760 --> 00:44:15,359
costs almost free in this case

1035
00:44:15,359 --> 00:44:18,359
so new cost metrics like low number of

1036
00:44:18,359 --> 00:44:20,220
multiplications and the low

1037
00:44:20,220 --> 00:44:23,460
multiplicative depths are developed and

1038
00:44:23,460 --> 00:44:26,160
to be efficient these Primitives usually

1039
00:44:26,160 --> 00:44:28,200
works over large boundary extension

1040
00:44:28,200 --> 00:44:32,160
field F2 to the N or large Prime field

1041
00:44:32,160 --> 00:44:35,220
since the size of the field is large the

1042
00:44:35,220 --> 00:44:38,099
Xbox cannot be pre-compute or pre-stored

1043
00:44:38,099 --> 00:44:41,280
as in the traditional Cipher so we have

1044
00:44:41,280 --> 00:44:43,440
a simple algebraic representation like

1045
00:44:43,440 --> 00:44:47,220
power maps x-maps to x to the D or the

1046
00:44:47,220 --> 00:44:50,460
inverse of X so as a result these New

1047
00:44:50,460 --> 00:44:52,260
Primitives are often algebraically

1048
00:44:52,260 --> 00:44:53,400
simple

1049
00:44:53,400 --> 00:44:56,280
there are a lot of examples like the

1050
00:44:56,280 --> 00:44:59,099
mimicy family head is mimicing vision

1051
00:44:59,099 --> 00:45:03,500
and rescue seminia and more

1052
00:45:03,500 --> 00:45:06,599
well the impact of the property of

1053
00:45:06,599 --> 00:45:09,359
arithmetic operations over large finite

1054
00:45:09,359 --> 00:45:12,720
Fields need for the study basically this

1055
00:45:12,720 --> 00:45:15,300
premium these Primitives are represented

1056
00:45:15,300 --> 00:45:18,240
by simple algebraic representations so

1057
00:45:18,240 --> 00:45:20,819
they are vulnerable to algebraic attacks

1058
00:45:20,819 --> 00:45:22,200
naturally

1059
00:45:22,200 --> 00:45:25,619
and attacks like group in a basis attack

1060
00:45:25,619 --> 00:45:28,440
and high order differential attacks have

1061
00:45:28,440 --> 00:45:30,380
some powerful against these Primitives

1062
00:45:30,380 --> 00:45:34,020
we have Groupon basis attack on full run

1063
00:45:34,020 --> 00:45:36,720
Javas and Friday and high order

1064
00:45:36,720 --> 00:45:40,879
differential attack on foreign

1065
00:45:41,160 --> 00:45:43,500
so we came up with some natural question

1066
00:45:43,500 --> 00:45:46,260
that since the algebraic representation

1067
00:45:46,260 --> 00:45:50,280
is significant to the crypto analysis of

1068
00:45:50,280 --> 00:45:52,980
these novel Primitives how can we better

1069
00:45:52,980 --> 00:45:55,500
understand it

1070
00:45:55,500 --> 00:45:58,500
in this paper we carefully study the

1071
00:45:58,500 --> 00:46:00,839
transition of the monomials and we

1072
00:46:00,839 --> 00:46:03,540
propose a new technique of studying the

1073
00:46:03,540 --> 00:46:06,240
polynomial representation it is called

1074
00:46:06,240 --> 00:46:09,540
General monomial prediction and it is an

1075
00:46:09,540 --> 00:46:12,540
extension of division property of a

1076
00:46:12,540 --> 00:46:15,359
binary field to Banner extension field

1077
00:46:15,359 --> 00:46:18,780
and using general monomial prediction we

1078
00:46:18,780 --> 00:46:21,540
propose a new algorithm dedicated for

1079
00:46:21,540 --> 00:46:24,720
degree evaluation and basically this is

1080
00:46:24,720 --> 00:46:27,240
benefit from the link between the panel

1081
00:46:27,240 --> 00:46:30,420
field and the banner extension field

1082
00:46:30,420 --> 00:46:32,700
this leads to the improved integral

1083
00:46:32,700 --> 00:46:35,280
distinguisher and zero sum distinguisher

1084
00:46:35,280 --> 00:46:38,280
on different instance of mimicy first

1085
00:46:38,280 --> 00:46:41,700
mimicy and Jimmy Missy

1086
00:46:41,700 --> 00:46:44,640
so first we need to take a closer look

1087
00:46:44,640 --> 00:46:46,980
at the polynomial representation

1088
00:46:46,980 --> 00:46:50,220
and see the function f over f 2 to the N

1089
00:46:50,220 --> 00:46:53,160
the input is about two variables and

1090
00:46:53,160 --> 00:46:55,440
output is a single variable

1091
00:46:55,440 --> 00:46:57,599
the function can be described by a

1092
00:46:57,599 --> 00:46:59,760
polynomial like this

1093
00:46:59,760 --> 00:47:03,780
Pi u x or we call it x to the U denotes

1094
00:47:03,780 --> 00:47:06,780
and monomial and the value denotes a

1095
00:47:06,780 --> 00:47:07,920
coefficient

1096
00:47:07,920 --> 00:47:11,220
with a non-zero coefficient we see that

1097
00:47:11,220 --> 00:47:15,240
the binomial pi x is contained by F and

1098
00:47:15,240 --> 00:47:19,319
otherwise pi x is not contained by f

1099
00:47:19,319 --> 00:47:22,020
we were using the following example to

1100
00:47:22,020 --> 00:47:23,460
explain this

1101
00:47:23,460 --> 00:47:27,780
given a polynomial F of x0 and X1 you

1102
00:47:27,780 --> 00:47:30,599
can get the following two observations

1103
00:47:30,599 --> 00:47:34,380
x0 to the seventh times X1 to the 10th

1104
00:47:34,380 --> 00:47:38,579
is contained by F and x0 to the 11 times

1105
00:47:38,579 --> 00:47:41,880
X1 is not contained by f

1106
00:47:41,880 --> 00:47:43,980
if the polynomial representation is

1107
00:47:43,980 --> 00:47:47,760
simple the problem to decide if x to the

1108
00:47:47,760 --> 00:47:50,400
U is contained by y to the V is a

1109
00:47:50,400 --> 00:47:51,780
trivial problem

1110
00:47:51,780 --> 00:47:55,380
oh just biasing per calculation but when

1111
00:47:55,380 --> 00:47:57,240
the polynomial representation is

1112
00:47:57,240 --> 00:48:00,780
complexed or it is not available as

1113
00:48:00,780 --> 00:48:03,900
usual in this metric key Primitives this

1114
00:48:03,900 --> 00:48:06,000
problem this problem is a difficult

1115
00:48:06,000 --> 00:48:08,160
problem

1116
00:48:08,160 --> 00:48:10,260
so this is why we propose General

1117
00:48:10,260 --> 00:48:11,940
monomial prediction

1118
00:48:11,940 --> 00:48:14,880
the goal is to check whether x to the U

1119
00:48:14,880 --> 00:48:17,700
is contained by y to the V when the

1120
00:48:17,700 --> 00:48:19,380
polynomial representation is not

1121
00:48:19,380 --> 00:48:20,400
available

1122
00:48:20,400 --> 00:48:24,119
this is achieved by decomposed a complex

1123
00:48:24,119 --> 00:48:25,800
function to a sequence of simple

1124
00:48:25,800 --> 00:48:27,420
function

1125
00:48:27,420 --> 00:48:31,619
let x i and x x i plus 1 denote input

1126
00:48:31,619 --> 00:48:34,140
and output of the function f

1127
00:48:34,140 --> 00:48:35,700
since we know the polynomial

1128
00:48:35,700 --> 00:48:38,819
representation of f i we can easily tell

1129
00:48:38,819 --> 00:48:41,700
whether a monomial of x i is contained

1130
00:48:41,700 --> 00:48:45,240
by the monomials of x i plus 1 and we

1131
00:48:45,240 --> 00:48:47,400
can find the local transition

1132
00:48:47,400 --> 00:48:50,220
for an iron Cipher if we can

1133
00:48:50,220 --> 00:48:51,839
successfully connect the local

1134
00:48:51,839 --> 00:48:53,099
transition

1135
00:48:53,099 --> 00:48:56,339
we can found an R1 transition and it is

1136
00:48:56,339 --> 00:48:59,520
called the general monomial trial

1137
00:48:59,520 --> 00:49:02,099
if we can detect one trail from the

1138
00:49:02,099 --> 00:49:04,980
beginning to the end we see that we do

1139
00:49:04,980 --> 00:49:07,200
not know about whether there is some

1140
00:49:07,200 --> 00:49:09,480
monomials of the beginning contained by

1141
00:49:09,480 --> 00:49:12,599
the monomials of the end due to that the

1142
00:49:12,599 --> 00:49:15,480
trials May cancel each other out but for

1143
00:49:15,480 --> 00:49:19,260
example if these trails are removed in

1144
00:49:19,260 --> 00:49:21,720
this case there is no trail from the

1145
00:49:21,720 --> 00:49:23,880
beginning to the end and we know that

1146
00:49:23,880 --> 00:49:26,400
there must be no monomials of the

1147
00:49:26,400 --> 00:49:28,980
beginning in the monomials of the end so

1148
00:49:28,980 --> 00:49:32,300
we found a missing monomial

1149
00:49:32,460 --> 00:49:35,160
so let me explain General monomial

1150
00:49:35,160 --> 00:49:38,460
prediction with the example here let's

1151
00:49:38,460 --> 00:49:42,060
see equals to 2 times y cubed and Y is a

1152
00:49:42,060 --> 00:49:45,119
function of x0 and and X1

1153
00:49:45,119 --> 00:49:47,819
we can compute the representation of Y

1154
00:49:47,819 --> 00:49:52,140
to the power of 3 4 5 and 7 and they all

1155
00:49:52,140 --> 00:49:54,720
contain the monomials X zero to the

1156
00:49:54,720 --> 00:49:57,900
power of 5.

1157
00:49:57,900 --> 00:50:00,720
we can also compute the monomials of Z

1158
00:50:00,720 --> 00:50:03,300
and here is the full monomial trials

1159
00:50:03,300 --> 00:50:06,720
connecting x0 to the power of 5 and the

1160
00:50:06,720 --> 00:50:09,740
monomials of the

1161
00:50:10,319 --> 00:50:13,079
next we show the propagation rules of

1162
00:50:13,079 --> 00:50:15,599
General monomial prediction and the

1163
00:50:15,599 --> 00:50:17,579
propagation actually model the

1164
00:50:17,579 --> 00:50:20,339
transition of the monomials so it can be

1165
00:50:20,339 --> 00:50:24,060
concluded as you can propagate to V if

1166
00:50:24,060 --> 00:50:26,940
and only if the monomial x to the U is

1167
00:50:26,940 --> 00:50:28,920
contained by y to the V

1168
00:50:28,920 --> 00:50:31,680
for the propagation we have four rules

1169
00:50:31,680 --> 00:50:35,819
for basic operations xor and copy copy

1170
00:50:35,819 --> 00:50:37,020
power

1171
00:50:37,020 --> 00:50:40,319
for the actual rules we have the input X

1172
00:50:40,319 --> 00:50:44,400
is x0 and X1 and the output is y

1173
00:50:44,400 --> 00:50:48,059
their corresponding propagation is u0 U1

1174
00:50:48,059 --> 00:50:49,200
and V

1175
00:50:49,200 --> 00:50:52,380
if we consider a valid propagation it

1176
00:50:52,380 --> 00:50:55,200
essentially means that the monomial x0

1177
00:50:55,200 --> 00:50:58,500
to the u0 times X1 to the U1 is

1178
00:50:58,500 --> 00:51:01,740
contained by the monomial y to the V so

1179
00:51:01,740 --> 00:51:03,839
by simple calculation we can know that

1180
00:51:03,839 --> 00:51:07,859
the propagation rules is like here

1181
00:51:07,859 --> 00:51:11,460
and for n rows we have V is equal to u0

1182
00:51:11,460 --> 00:51:15,300
and U1 for copy rules U is equal to a

1183
00:51:15,300 --> 00:51:19,500
different modular addition of V 0 and V1

1184
00:51:19,500 --> 00:51:22,380
power rules is a specific rules over

1185
00:51:22,380 --> 00:51:26,400
funded field and why is defined as this

1186
00:51:26,400 --> 00:51:28,140
power of x

1187
00:51:28,140 --> 00:51:30,780
as in the Boolean function the highest

1188
00:51:30,780 --> 00:51:32,940
degree is one so we do not have the

1189
00:51:32,940 --> 00:51:36,780
power rule and we have U is equal to the

1190
00:51:36,780 --> 00:51:40,520
same module of D times V

1191
00:51:41,819 --> 00:51:44,700
so there is a comparison of our general

1192
00:51:44,700 --> 00:51:47,220
monomial prediction and the word base

1193
00:51:47,220 --> 00:51:50,280
and bit based division prop 2. for the

1194
00:51:50,280 --> 00:51:51,900
word based and bit-based division

1195
00:51:51,900 --> 00:51:54,540
property the variables are often defined

1196
00:51:54,540 --> 00:51:56,700
in bit level and for our general

1197
00:51:56,700 --> 00:51:59,099
monomial prediction the variables are

1198
00:51:59,099 --> 00:52:01,020
defined over fields

1199
00:52:01,020 --> 00:52:03,000
since the world-based division property

1200
00:52:03,000 --> 00:52:05,760
actually works at what level it only

1201
00:52:05,760 --> 00:52:07,680
exploits the algebraic degree

1202
00:52:07,680 --> 00:52:10,800
information of the local components so

1203
00:52:10,800 --> 00:52:13,559
the local the local propagation is not

1204
00:52:13,559 --> 00:52:15,300
so accurate

1205
00:52:15,300 --> 00:52:18,300
and for the bit based division property

1206
00:52:18,300 --> 00:52:21,300
it views the information of the NF of

1207
00:52:21,300 --> 00:52:23,760
the Boolean function and for our general

1208
00:52:23,760 --> 00:52:26,339
monomial prediction we also use the

1209
00:52:26,339 --> 00:52:28,559
polynomial representation and the local

1210
00:52:28,559 --> 00:52:32,059
propagation is accurate

1211
00:52:32,760 --> 00:52:35,460
before going to the evaluation of the

1212
00:52:35,460 --> 00:52:37,619
algebraic degree I want to talk about

1213
00:52:37,619 --> 00:52:40,440
the high order differential attack

1214
00:52:40,440 --> 00:52:42,660
high order differential tag was proposed

1215
00:52:42,660 --> 00:52:46,140
by fideli EK is a function with

1216
00:52:46,140 --> 00:52:48,240
algebraic degree of Delta

1217
00:52:48,240 --> 00:52:50,819
and P is a plain text state

1218
00:52:50,819 --> 00:52:53,099
is the dimension of p is greater than

1219
00:52:53,099 --> 00:52:55,859
Delta we have that the sum of all

1220
00:52:55,859 --> 00:53:00,300
plaintiffs over the set p is zero so the

1221
00:53:00,300 --> 00:53:02,339
goal is to detect the algebraic degree

1222
00:53:02,339 --> 00:53:05,839
of the function intake

1223
00:53:06,359 --> 00:53:10,079
so the basic strategy of how we detect

1224
00:53:10,079 --> 00:53:13,319
the algebraic degree is that we observe

1225
00:53:13,319 --> 00:53:15,420
the polynomial representation of the

1226
00:53:15,420 --> 00:53:18,119
cipher and then convert the polynomial

1227
00:53:18,119 --> 00:53:20,760
degree to the algebraic degree

1228
00:53:20,760 --> 00:53:22,859
the connection between the two kinds of

1229
00:53:22,859 --> 00:53:24,119
degree is

1230
00:53:24,119 --> 00:53:27,119
given a polynomial F here

1231
00:53:27,119 --> 00:53:29,940
the polynomial degree denoted by the

1232
00:53:29,940 --> 00:53:33,059
Jack of f is just the usual degree of

1233
00:53:33,059 --> 00:53:34,859
the polynomial

1234
00:53:34,859 --> 00:53:38,220
the algebraic degree denoted by Delta f

1235
00:53:38,220 --> 00:53:41,819
is given by the maximum of the Hemingway

1236
00:53:41,819 --> 00:53:46,140
of exponents with non-zero coefficients

1237
00:53:46,140 --> 00:53:50,099
for example let F be a function of x0

1238
00:53:50,099 --> 00:53:52,079
and X1

1239
00:53:52,079 --> 00:53:54,300
the polynomial degree is just the

1240
00:53:54,300 --> 00:53:59,099
ordinary degree 7 plus 10 that is 17.

1241
00:53:59,099 --> 00:54:01,559
and since the Heming weight of the two

1242
00:54:01,559 --> 00:54:06,059
monomials is four and five the algebraic

1243
00:54:06,059 --> 00:54:09,380
degree is 5.

1244
00:54:10,740 --> 00:54:13,800
uh Central can be represented by acute

1245
00:54:13,800 --> 00:54:17,940
polynomial y of plain text X and the

1246
00:54:17,940 --> 00:54:21,540
secret key K so basically our goal is to

1247
00:54:21,540 --> 00:54:24,780
check whether y to the V contains the

1248
00:54:24,780 --> 00:54:28,140
kid monomial key to the W Times x to the

1249
00:54:28,140 --> 00:54:31,920
U of algebraic degree greater than d

1250
00:54:31,920 --> 00:54:36,900
the degree of K that is the W is that

1251
00:54:36,900 --> 00:54:39,000
arbitrary since we only care about the

1252
00:54:39,000 --> 00:54:42,059
degree of X and if there is no such

1253
00:54:42,059 --> 00:54:44,940
trial there is no such monomials and we

1254
00:54:44,940 --> 00:54:46,859
know that the algebraic degree is less

1255
00:54:46,859 --> 00:54:50,160
than or equal to D that if there is a

1256
00:54:50,160 --> 00:54:51,960
trial we do not know any information

1257
00:54:51,960 --> 00:54:55,160
about the monomial

1258
00:54:56,040 --> 00:54:58,619
when using STP servers to detect the

1259
00:54:58,619 --> 00:55:01,260
algebraic degree we need to create the

1260
00:55:01,260 --> 00:55:03,420
initial property and the final division

1261
00:55:03,420 --> 00:55:04,619
blockchain

1262
00:55:04,619 --> 00:55:07,200
the initial property is prepared as T

1263
00:55:07,200 --> 00:55:10,200
variables each variable is a bit Vector

1264
00:55:10,200 --> 00:55:11,760
with length n

1265
00:55:11,760 --> 00:55:15,000
it actually means what kind of monomials

1266
00:55:15,000 --> 00:55:16,740
you want to detect

1267
00:55:16,740 --> 00:55:19,200
suppose if we want to check whether

1268
00:55:19,200 --> 00:55:21,059
there is a kind of monomials with

1269
00:55:21,059 --> 00:55:23,520
algebraic degree greater than d

1270
00:55:23,520 --> 00:55:26,040
we then set the sum of each page of the

1271
00:55:26,040 --> 00:55:27,900
initial property to be greater than D

1272
00:55:27,900 --> 00:55:30,960
and for the variable w we set it

1273
00:55:30,960 --> 00:55:32,460
arbitrary

1274
00:55:32,460 --> 00:55:35,099
the final division property is also T

1275
00:55:35,099 --> 00:55:37,260
bit vectors of length n

1276
00:55:37,260 --> 00:55:39,839
the ice variable is set to 1 if we focus

1277
00:55:39,839 --> 00:55:42,420
on the ice variable of the ciphertext

1278
00:55:42,420 --> 00:55:45,420
and other variables are zero

1279
00:55:45,420 --> 00:55:47,760
and the Run by the solvers we can check

1280
00:55:47,760 --> 00:55:49,619
if there is a monomial trial from the

1281
00:55:49,619 --> 00:55:51,180
beginning to the end

1282
00:55:51,180 --> 00:55:54,420
if the servers cannot run entrails we

1283
00:55:54,420 --> 00:55:56,099
know that the upper bound of the

1284
00:55:56,099 --> 00:55:59,280
algebraic degree is D and we can set the

1285
00:55:59,280 --> 00:56:01,740
initial property to D minus 1 and

1286
00:56:01,740 --> 00:56:06,259
continue to check to get a better bound

1287
00:56:08,220 --> 00:56:10,920
the applications of our algorithm is the

1288
00:56:10,920 --> 00:56:13,800
mimicy family they all use x to the

1289
00:56:13,800 --> 00:56:17,280
power of d as a round function for

1290
00:56:17,280 --> 00:56:20,520
mimicy we have the input X and sum key K

1291
00:56:20,520 --> 00:56:23,460
and the Run function is consists of the

1292
00:56:23,460 --> 00:56:26,460
addition constant addition and usually a

1293
00:56:26,460 --> 00:56:28,740
cube function as Xbox

1294
00:56:28,740 --> 00:56:31,079
professional BBC it follows the first

1295
00:56:31,079 --> 00:56:34,260
structure and for Jimmy CIF it follows

1296
00:56:34,260 --> 00:56:37,319
the unbalanced vessel structure uh well

1297
00:56:37,319 --> 00:56:41,900
the Xbox is also a cubing function

1298
00:56:42,900 --> 00:56:45,359
this is a visualization of our results

1299
00:56:45,359 --> 00:56:50,220
on Vestal mimicy with block size 129 and

1300
00:56:50,220 --> 00:56:52,440
this line shows several bounds on the

1301
00:56:52,440 --> 00:56:55,260
algebraic degree for Vestal Ministry

1302
00:56:55,260 --> 00:56:58,260
this horizontal red dashed line shows

1303
00:56:58,260 --> 00:57:01,200
the maximum algebraic degree and the red

1304
00:57:01,200 --> 00:57:04,020
line shows the trivial upper bound and

1305
00:57:04,020 --> 00:57:05,700
the green line shows the trivial lower

1306
00:57:05,700 --> 00:57:08,460
bound and the blue line shows the band

1307
00:57:08,460 --> 00:57:11,160
detect by our algorithm using general

1308
00:57:11,160 --> 00:57:13,079
monomial prediction

1309
00:57:13,079 --> 00:57:16,380
you can see that there are two phase of

1310
00:57:16,380 --> 00:57:19,140
the degree growth a face of linear

1311
00:57:19,140 --> 00:57:21,960
growth for the first stage and followed

1312
00:57:21,960 --> 00:57:24,540
by a face with several large plators

1313
00:57:24,540 --> 00:57:28,020
until reaching the maximal degree

1314
00:57:28,020 --> 00:57:30,720
some platers only covers for a few

1315
00:57:30,720 --> 00:57:33,300
rounds where there is a largest Plateau

1316
00:57:33,300 --> 00:57:36,599
just before the maximal degree

1317
00:57:36,599 --> 00:57:38,579
the stage of the slow growth

1318
00:57:38,579 --> 00:57:40,800
significantly includes the growth of the

1319
00:57:40,800 --> 00:57:43,559
algebraic degree and morons than

1320
00:57:43,559 --> 00:57:45,900
previous products are necessary to

1321
00:57:45,900 --> 00:57:48,420
guarantee the security

1322
00:57:48,420 --> 00:57:51,780
so Orange Line shows a new theoretic

1323
00:57:51,780 --> 00:57:52,700
bound

1324
00:57:52,700 --> 00:57:56,579
proved in our paper on the algebraic

1325
00:57:56,579 --> 00:57:59,520
degree of astronomy Miss likes games it

1326
00:57:59,520 --> 00:58:01,740
also depicts the first phase of the

1327
00:58:01,740 --> 00:58:04,399
linear growth

1328
00:58:06,119 --> 00:58:09,420
so here is the results of our algorithm

1329
00:58:09,420 --> 00:58:13,260
for mimicy with block size 129 we

1330
00:58:13,260 --> 00:58:15,839
present the exact algebraic degree when

1331
00:58:15,839 --> 00:58:19,020
D is equal to three it is the same as

1332
00:58:19,020 --> 00:58:23,160
the theoretic proof in the recent paper

1333
00:58:23,160 --> 00:58:26,280
when the air goes to 2 to the L minus 1

1334
00:58:26,280 --> 00:58:29,339
we extended we extend the distinguisher

1335
00:58:29,339 --> 00:58:32,040
for one optimal rounds compared to the

1336
00:58:32,040 --> 00:58:36,480
previous best work in Asia Crypt 2020.

1337
00:58:36,480 --> 00:58:39,599
and for the equals to 2 to the L plus 1

1338
00:58:39,599 --> 00:58:42,299
we find distinguishers with lower data

1339
00:58:42,299 --> 00:58:44,520
complexity

1340
00:58:44,520 --> 00:58:48,780
profession with box size 129 the

1341
00:58:48,780 --> 00:58:51,599
previous only attack for 83 rounds but

1342
00:58:51,599 --> 00:58:55,559
we can check for 124 rounds and we can

1343
00:58:55,559 --> 00:58:57,900
also give a four round nine key zero

1344
00:58:57,900 --> 00:58:59,400
sound distinguisher

1345
00:58:59,400 --> 00:59:01,799
for Jimmy missy we searched for a 50

1346
00:59:01,799 --> 00:59:04,200
round high order distinguisher for the

1347
00:59:04,200 --> 00:59:08,040
instance with block size 33 and 8

1348
00:59:08,040 --> 00:59:10,640
branches

1349
00:59:10,980 --> 00:59:12,960
so this is the summary of our

1350
00:59:12,960 --> 00:59:17,520
applications and I will conclude my talk

1351
00:59:17,520 --> 00:59:20,220
we propose General monomial prediction

1352
00:59:20,220 --> 00:59:22,680
and this tool is used to detect

1353
00:59:22,680 --> 00:59:24,839
algebraic degree algebraic

1354
00:59:24,839 --> 00:59:28,440
representation of the ciphers over F2 to

1355
00:59:28,440 --> 00:59:32,220
the n and by using this to repropos a

1356
00:59:32,220 --> 00:59:34,980
new framework for degree evaluation and

1357
00:59:34,980 --> 00:59:37,260
we can no longer only rely on the

1358
00:59:37,260 --> 00:59:39,660
theoretic proof to estimate the

1359
00:59:39,660 --> 00:59:43,020
algebraic degree over the final fields

1360
00:59:43,020 --> 00:59:45,240
so if you are the best high order

1361
00:59:45,240 --> 00:59:47,520
distinguisher and zero sum distinguisher

1362
00:59:47,520 --> 00:59:50,460
for different instance of mimisa effect

1363
00:59:50,460 --> 00:59:53,280
and Jimmy Missy

1364
00:59:53,280 --> 00:59:56,579
the open problem is that can we further

1365
00:59:56,579 --> 00:59:58,980
optimize the performance of the general

1366
00:59:58,980 --> 01:00:02,220
monomial prediction or we use the number

1367
01:00:02,220 --> 01:00:04,079
of the trials to do more accurate

1368
01:00:04,079 --> 01:00:07,980
products also except for the algebraic

1369
01:00:07,980 --> 01:00:10,380
degree how can we use the information of

1370
01:00:10,380 --> 01:00:12,420
the algebraic structure to be design

1371
01:00:12,420 --> 01:00:15,380
more powerful attack

1372
01:00:15,599 --> 01:00:17,819
so this is the end of the presentation

1373
01:00:17,819 --> 01:00:21,200
and thanks for the listening

1374
01:00:25,079 --> 01:00:27,240
thank you very much are the questions

1375
01:00:27,240 --> 01:00:29,839
for coming

1376
01:00:33,299 --> 01:00:35,400
because this talk is slightly outside my

1377
01:00:35,400 --> 01:00:37,500
area of expertise but I do have a

1378
01:00:37,500 --> 01:00:39,960
question so you said that you're um that

1379
01:00:39,960 --> 01:00:41,700
you've been using smt solvers and I was

1380
01:00:41,700 --> 01:00:43,619
wondering in

1381
01:00:43,619 --> 01:00:46,020
um two outcomes that you can get is sat

1382
01:00:46,020 --> 01:00:48,119
or unsat and then you're happy and the

1383
01:00:48,119 --> 01:00:49,319
other outcome is that you're running out

1384
01:00:49,319 --> 01:00:50,880
of memory or that you're running out of

1385
01:00:50,880 --> 01:00:52,740
like getting into a timeout which is a

1386
01:00:52,740 --> 01:00:55,859
actually quite often the case so I was

1387
01:00:55,859 --> 01:00:57,480
wondering what was your experience on on

1388
01:00:57,480 --> 01:00:59,640
running those and and how long did it

1389
01:00:59,640 --> 01:01:01,380
take and how often did you run into this

1390
01:01:01,380 --> 01:01:03,480
trouble of actually well running out of

1391
01:01:03,480 --> 01:01:05,819
memory or running for weeks and not

1392
01:01:05,819 --> 01:01:08,480
getting any results

1393
01:01:08,960 --> 01:01:13,440
uh so for music and Festival it takes

1394
01:01:13,440 --> 01:01:18,180
around five minutes to run the code uh

1395
01:01:18,180 --> 01:01:21,900
with uh with eight threads and for Jimmy

1396
01:01:21,900 --> 01:01:24,859
missile it takes around

1397
01:01:24,859 --> 01:01:29,160
uh one day to run the code

1398
01:01:29,160 --> 01:01:31,079
okay that looks like that's with

1399
01:01:31,079 --> 01:01:33,720
reasonable memory requirements like I

1400
01:01:33,720 --> 01:01:35,880
know a couple of gigabytes or is that

1401
01:01:35,880 --> 01:01:37,799
with a with a big machine with terabytes

1402
01:01:37,799 --> 01:01:39,720
of memory

1403
01:01:39,720 --> 01:01:45,180
uh yes the memory is uh reasonable okay

1404
01:01:45,180 --> 01:01:47,040
thank you very much

1405
01:01:47,040 --> 01:01:50,660
any more questions what I mean

1406
01:01:51,420 --> 01:01:53,400
if not then please join me in thanking

1407
01:01:53,400 --> 01:01:54,900
Jamin and all speakers of the session

1408
01:01:54,900 --> 01:01:57,200
again

