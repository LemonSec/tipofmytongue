1
00:00:02,280 --> 00:00:04,820
foreign

2
00:00:52,020 --> 00:00:54,559
foreign

3
00:01:31,439 --> 00:01:34,439
foreign

4
00:01:57,659 --> 00:02:00,659
okay

5
00:02:01,079 --> 00:02:04,680
can you start Usher Yeah

6
00:02:04,680 --> 00:02:07,200
hi yeah sure okay thank you I can't hear

7
00:02:07,200 --> 00:02:09,598
you yeah thank you for uh the

8
00:02:09,598 --> 00:02:11,640
introduction uh

9
00:02:11,640 --> 00:02:15,239
so uh as the title says uh this talk is

10
00:02:15,239 --> 00:02:17,580
about uh the tight security bounds for

11
00:02:17,580 --> 00:02:21,239
Omak xcbc and tmacc so uh I'll first

12
00:02:21,239 --> 00:02:24,060
give you a quick introduction of Max and

13
00:02:24,060 --> 00:02:27,480
their security uh and then Define CBC

14
00:02:27,480 --> 00:02:30,440
Max basically xcbc tmac and domac

15
00:02:30,440 --> 00:02:33,900
then I'll uh give you a discussion about

16
00:02:33,900 --> 00:02:35,819
the existing security results

17
00:02:35,819 --> 00:02:38,340
and finally I'll build up the main proof

18
00:02:38,340 --> 00:02:39,660
of course leading to the main results of

19
00:02:39,660 --> 00:02:41,640
the paper

20
00:02:41,640 --> 00:02:44,220
uh so Master uh message authentication

21
00:02:44,220 --> 00:02:45,780
codes or Macs are symmetric key

22
00:02:45,780 --> 00:02:48,120
algorithms so in this we have two

23
00:02:48,120 --> 00:02:49,980
parties Alice and Bob

24
00:02:49,980 --> 00:02:53,400
they first agree on a shared secret key

25
00:02:53,400 --> 00:02:55,560
and then uh suppose Alice wants to send

26
00:02:55,560 --> 00:02:57,120
a message to Bob with the added

27
00:02:57,120 --> 00:02:59,340
condition that Bob can authenticate that

28
00:02:59,340 --> 00:03:02,300
message is from Alice

29
00:03:02,300 --> 00:03:06,180
so what Alish can do is she can take her

30
00:03:06,180 --> 00:03:09,680
key and the message and compute a

31
00:03:09,680 --> 00:03:12,659
authentication tag a short tag and then

32
00:03:12,659 --> 00:03:15,120
send this message and tag here to Bob

33
00:03:15,120 --> 00:03:17,340
now Bob has the secret key so he can

34
00:03:17,340 --> 00:03:20,580
recompute the tag and check if uh the

35
00:03:20,580 --> 00:03:23,580
received tag matches with this or not if

36
00:03:23,580 --> 00:03:25,980
it does then he accepts the message if

37
00:03:25,980 --> 00:03:28,920
it does not then he just rejects it

38
00:03:28,920 --> 00:03:32,459
so uh this is the usual protocol for mac

39
00:03:32,459 --> 00:03:35,700
and uh what security means so for

40
00:03:35,700 --> 00:03:37,620
security we have another party called

41
00:03:37,620 --> 00:03:39,959
Eve who is sitting between Alice and Bob

42
00:03:39,959 --> 00:03:42,060
and listening to all the communications

43
00:03:42,060 --> 00:03:45,599
and Eve's goal is to forge Alice Alice's

44
00:03:45,599 --> 00:03:46,860
identity

45
00:03:46,860 --> 00:03:50,459
so uh basically if we listen to all the

46
00:03:50,459 --> 00:03:53,220
communication from Alice to Bob and uh

47
00:03:53,220 --> 00:03:55,860
do some homework at her end and then

48
00:03:55,860 --> 00:03:59,099
prepare a forged messaging tag pair so

49
00:03:59,099 --> 00:04:01,379
the uh the condition is that this

50
00:04:01,379 --> 00:04:05,000
message intact page should be fresh

51
00:04:05,519 --> 00:04:09,360
so that was a passive adversary where he

52
00:04:09,360 --> 00:04:11,159
was not actually choosing her messages

53
00:04:11,159 --> 00:04:15,120
uh in in standard uh proofs we generally

54
00:04:15,120 --> 00:04:17,040
have a more stronger setting where Eve

55
00:04:17,040 --> 00:04:18,720
can receive the tag outputs on her

56
00:04:18,720 --> 00:04:19,978
choice of messages

57
00:04:19,978 --> 00:04:22,199
but in both cases uh she finally

58
00:04:22,199 --> 00:04:25,080
produces a forced but fresh message

59
00:04:25,080 --> 00:04:27,419
intact here

60
00:04:27,419 --> 00:04:30,360
and then we say that events if Bob

61
00:04:30,360 --> 00:04:33,660
accepts the message finally

62
00:04:33,660 --> 00:04:35,940
uh interesting thing is uh so back

63
00:04:35,940 --> 00:04:39,000
security is uh defined uh as this the

64
00:04:39,000 --> 00:04:42,900
probability of uh forgery

65
00:04:42,900 --> 00:04:46,320
and the interesting thing is that if

66
00:04:46,320 --> 00:04:49,199
Alice has a pure perfect random function

67
00:04:49,199 --> 00:04:52,680
then the best Eve can do is to guess so

68
00:04:52,680 --> 00:04:55,560
she can just guess uh the tag output for

69
00:04:55,560 --> 00:04:57,180
a fresh message

70
00:04:57,180 --> 00:05:01,440
and often uh what we do is uh the for

71
00:05:01,440 --> 00:05:03,479
the security of Mac Construction uh we

72
00:05:03,479 --> 00:05:06,360
quantify it via the uh its ability to

73
00:05:06,360 --> 00:05:08,100
mimic a perfect random function and this

74
00:05:08,100 --> 00:05:09,780
is done by a game called the

75
00:05:09,780 --> 00:05:12,300
pseudorandom function security here we

76
00:05:12,300 --> 00:05:13,979
have the ideal world where Alice has a

77
00:05:13,979 --> 00:05:15,960
perfect random function

78
00:05:15,960 --> 00:05:18,060
and the real world where Alice has a

79
00:05:18,060 --> 00:05:21,240
keyed function and the goal for Eve is

80
00:05:21,240 --> 00:05:23,479
uh

81
00:05:23,479 --> 00:05:26,520
to uh distinguish between the two words

82
00:05:26,520 --> 00:05:30,060
so as usual if interacts with Alice but

83
00:05:30,060 --> 00:05:32,100
now instead of a message tag pair she

84
00:05:32,100 --> 00:05:33,900
just returns a bit B at the end of the

85
00:05:33,900 --> 00:05:35,520
game

86
00:05:35,520 --> 00:05:39,139
and then the goal for uh then the

87
00:05:39,139 --> 00:05:42,360
advantage of Eve is defined as this

88
00:05:42,360 --> 00:05:44,280
absolute difference of the probability

89
00:05:44,280 --> 00:05:48,000
that Eve returns one in the Two Worlds

90
00:05:48,000 --> 00:05:50,940
a popular way of constructing Max

91
00:05:50,940 --> 00:05:55,199
or prf's uh is the CBC Mac

92
00:05:55,199 --> 00:05:57,660
which is also one of the earliest PR of

93
00:05:57,660 --> 00:05:59,699
construction in this construction you

94
00:05:59,699 --> 00:06:02,660
first have a message M that we pass into

95
00:06:02,660 --> 00:06:05,340
blocks of n Bits where n is the block

96
00:06:05,340 --> 00:06:06,180
size

97
00:06:06,180 --> 00:06:09,360
of the underlying block Cipher so the

98
00:06:09,360 --> 00:06:10,680
important thing is that the meshes

99
00:06:10,680 --> 00:06:13,919
length must be a multiple of n

100
00:06:13,919 --> 00:06:17,520
so once we have this pass message uh you

101
00:06:17,520 --> 00:06:20,639
uh start encrypting uh the blocks uh

102
00:06:20,639 --> 00:06:23,220
iteratively so first we encrypt the

103
00:06:23,220 --> 00:06:25,680
first message block then we X out the

104
00:06:25,680 --> 00:06:28,560
second message block and uh encrypt and

105
00:06:28,560 --> 00:06:30,600
so on and we do it for the for all the

106
00:06:30,600 --> 00:06:32,759
blocks and finally we uh get the tag

107
00:06:32,759 --> 00:06:33,900
output

108
00:06:33,900 --> 00:06:36,419
so as you can see CBC Mac encryption is

109
00:06:36,419 --> 00:06:38,460
very uh

110
00:06:38,460 --> 00:06:40,080
in a simple

111
00:06:40,080 --> 00:06:42,419
however it has two major issues first it

112
00:06:42,419 --> 00:06:44,100
is susceptible to length extension

113
00:06:44,100 --> 00:06:47,580
attacks so uh given that you have the

114
00:06:47,580 --> 00:06:50,639
CVC Mac for message m

115
00:06:50,639 --> 00:06:53,300
you can compute CBC Mac for message M

116
00:06:53,300 --> 00:06:57,539
concatenated with any other uh string

117
00:06:57,539 --> 00:07:00,180
and this gives you a full stream

118
00:07:00,180 --> 00:07:03,780
and the second and more uh offer issue

119
00:07:03,780 --> 00:07:05,400
from the implementation point of view is

120
00:07:05,400 --> 00:07:07,919
that the input length must be a non-zero

121
00:07:07,919 --> 00:07:09,720
multiple of n

122
00:07:09,720 --> 00:07:13,080
so to uh you know we Rectify these two

123
00:07:13,080 --> 00:07:15,240
issues several variants of CBC Mac were

124
00:07:15,240 --> 00:07:18,419
proposed and we will I will concentrate

125
00:07:18,419 --> 00:07:21,419
on three uh constructions Omak xcbc and

126
00:07:21,419 --> 00:07:22,500
tmac

127
00:07:22,500 --> 00:07:24,599
and in all three constructions as a

128
00:07:24,599 --> 00:07:26,099
pre-processing step

129
00:07:26,099 --> 00:07:28,620
what you do is uh you take a message M

130
00:07:28,620 --> 00:07:31,020
Prime which is of arbitrary length and

131
00:07:31,020 --> 00:07:33,960
you pad it to make a message M of uh

132
00:07:33,960 --> 00:07:36,180
length a multiple of n

133
00:07:36,180 --> 00:07:38,639
so this padding is very simple that if M

134
00:07:38,639 --> 00:07:42,419
Prime is uh already a message of length

135
00:07:42,419 --> 00:07:45,180
multiple of n then you simply put m

136
00:07:45,180 --> 00:07:49,620
equals m prime otherwise you append a 1

137
00:07:49,620 --> 00:07:51,660
followed by a minimum number of zeros to

138
00:07:51,660 --> 00:07:54,660
make the updated length a multiple of n

139
00:07:54,660 --> 00:07:57,720
once we have done this preprocessing uh

140
00:07:57,720 --> 00:08:00,300
in xcbc we first

141
00:08:00,300 --> 00:08:04,199
uh take the first L minus 1 blocks apply

142
00:08:04,199 --> 00:08:06,780
CBC Mac and then on in the output we

143
00:08:06,780 --> 00:08:08,460
extort the last block

144
00:08:08,460 --> 00:08:10,919
and we extort our key depending on the

145
00:08:10,919 --> 00:08:12,960
type of message so if the message length

146
00:08:12,960 --> 00:08:15,300
is a multiple of n then we X or k0

147
00:08:15,300 --> 00:08:18,479
otherwise we xor K1 so in a way B

148
00:08:18,479 --> 00:08:20,039
differentiates between the two different

149
00:08:20,039 --> 00:08:22,919
types of messages that we can see

150
00:08:22,919 --> 00:08:24,960
and finally the updated state is

151
00:08:24,960 --> 00:08:28,740
encrypted again to get the tag output

152
00:08:28,740 --> 00:08:30,139
tmac

153
00:08:30,139 --> 00:08:34,440
does the same thing but now it uses a

154
00:08:34,440 --> 00:08:36,659
constant element from the field instead

155
00:08:36,659 --> 00:08:39,479
of two different auxiliary keys

156
00:08:39,479 --> 00:08:43,140
and uh the the entire process is exactly

157
00:08:43,140 --> 00:08:46,519
similar omac is even better in that it

158
00:08:46,519 --> 00:08:49,740
completely eliminates the key

159
00:08:49,740 --> 00:08:54,240
and adds to constant as before

160
00:08:54,240 --> 00:08:58,019
and uh here I would like to note that uh

161
00:08:58,019 --> 00:09:01,080
CMAC a standard ISO standard and nist

162
00:09:01,080 --> 00:09:03,000
recommended Mac algorithm is just a

163
00:09:03,000 --> 00:09:05,279
variant of omax so whatever I say about

164
00:09:05,279 --> 00:09:08,580
umac is also applicable to CMAC and uh

165
00:09:08,580 --> 00:09:11,399
because Omak is the is the best in terms

166
00:09:11,399 --> 00:09:13,800
of the number of keys uh I'll mainly

167
00:09:13,800 --> 00:09:16,200
concentrate on omac in this talk

168
00:09:16,200 --> 00:09:19,440
so uh now that I have given you an

169
00:09:19,440 --> 00:09:21,360
introduction about omac let me give you

170
00:09:21,360 --> 00:09:23,519
a quick tour of the prf security offer

171
00:09:23,519 --> 00:09:26,820
Mac so the best bound till now is this

172
00:09:26,820 --> 00:09:31,500
expression that we have here and uh

173
00:09:31,500 --> 00:09:34,019
it roughly says the that Eve needs

174
00:09:34,019 --> 00:09:36,000
roughly square root of 2 to the N over L

175
00:09:36,000 --> 00:09:38,399
queries to either distinguish or Forge

176
00:09:38,399 --> 00:09:39,899
omac

177
00:09:39,899 --> 00:09:41,940
but the interesting thing is that there

178
00:09:41,940 --> 00:09:44,459
is no matching attack uh that achieves

179
00:09:44,459 --> 00:09:48,420
this bound and in fact all the folklore

180
00:09:48,420 --> 00:09:49,980
attacks are actually of collision

181
00:09:49,980 --> 00:09:52,920
finding nature and then need roughly

182
00:09:52,920 --> 00:09:56,660
square root of 2 to the N queries

183
00:09:57,420 --> 00:10:00,120
so uh the main bottleneck in getting an

184
00:10:00,120 --> 00:10:02,459
improved bound is the so-called full

185
00:10:02,459 --> 00:10:05,339
Collision event so uh let me describe it

186
00:10:05,339 --> 00:10:07,560
for you so uh

187
00:10:07,560 --> 00:10:10,620
suppose the adversary made Q queries one

188
00:10:10,620 --> 00:10:13,380
two queue and we are concentrating on

189
00:10:13,380 --> 00:10:16,500
the ith query so in the ith query uh the

190
00:10:16,500 --> 00:10:17,940
tag value t

191
00:10:17,940 --> 00:10:21,420
is uh is uniform at random it's uh so we

192
00:10:21,420 --> 00:10:23,279
are in the ideal world right now so the

193
00:10:23,279 --> 00:10:27,240
tag value 2 is T is uniform at random

194
00:10:27,240 --> 00:10:29,160
and now in the ideal world we want to

195
00:10:29,160 --> 00:10:32,820
mimic the real world uh uh competition

196
00:10:32,820 --> 00:10:37,200
so we sample some E1 and we compute the

197
00:10:37,200 --> 00:10:39,060
omac

198
00:10:39,060 --> 00:10:41,760
so because this tag value was uh already

199
00:10:41,760 --> 00:10:44,220
fixed there is no guarantee that these

200
00:10:44,220 --> 00:10:45,860
two will match

201
00:10:45,860 --> 00:10:48,540
these two will uh satisfy the

202
00:10:48,540 --> 00:10:50,880
permutation compatibility

203
00:10:50,880 --> 00:10:54,000
so and this is what uh causes this full

204
00:10:54,000 --> 00:10:56,279
Collision event as well so suppose uh

205
00:10:56,279 --> 00:10:59,339
you have a condition like this where uh

206
00:10:59,339 --> 00:11:01,920
there is another query J

207
00:11:01,920 --> 00:11:05,519
for which uh the final input of the ith

208
00:11:05,519 --> 00:11:07,680
query matches with an inter intermediate

209
00:11:07,680 --> 00:11:10,920
input of the GTH query so here xj2

210
00:11:10,920 --> 00:11:14,519
collides with x i l but now because Tia

211
00:11:14,519 --> 00:11:16,200
is completely independent of this

212
00:11:16,200 --> 00:11:18,899
processing it might be possible that TI

213
00:11:18,899 --> 00:11:21,060
is not with high probability it will be

214
00:11:21,060 --> 00:11:23,220
it will be the case that TI is not equal

215
00:11:23,220 --> 00:11:24,959
to y z

216
00:11:24,959 --> 00:11:28,500
so which is a issue so uh in more

217
00:11:28,500 --> 00:11:31,680
generally what we have is uh we have two

218
00:11:31,680 --> 00:11:34,620
different uh queries I and J and a block

219
00:11:34,620 --> 00:11:37,740
a such that x j is equal to x i l and

220
00:11:37,740 --> 00:11:41,459
this is a issue that has to be handled

221
00:11:41,459 --> 00:11:44,040
and there is a very simple way to handle

222
00:11:44,040 --> 00:11:46,680
it is uh we have two different queries

223
00:11:46,680 --> 00:11:49,860
so Q choose two times the number of

224
00:11:49,860 --> 00:11:52,860
blocks which is L so it's roughly Q

225
00:11:52,860 --> 00:11:56,880
Square L and then each such Collision uh

226
00:11:56,880 --> 00:11:59,519
results in a 1 over 2 to the N

227
00:11:59,519 --> 00:12:01,740
probability so this probability can be

228
00:12:01,740 --> 00:12:06,140
easily bounded by this uh order

229
00:12:06,140 --> 00:12:09,560
but and this is the main bottleneck uh

230
00:12:09,560 --> 00:12:12,240
in the Min in the security bound as well

231
00:12:12,240 --> 00:12:15,480
so if if we want to improve over this

232
00:12:15,480 --> 00:12:17,519
bound and this uh particular event has

233
00:12:17,519 --> 00:12:19,880
to be handled differently

234
00:12:19,880 --> 00:12:22,740
and actually at Asia grip last year we

235
00:12:22,740 --> 00:12:24,600
presented a new proof approach uh called

236
00:12:24,600 --> 00:12:27,120
reset sampling that solved a similar

237
00:12:27,120 --> 00:12:29,339
issue for light Mac as well

238
00:12:29,339 --> 00:12:31,560
and actually in the same paper we also

239
00:12:31,560 --> 00:12:33,060
hinted that this technique might be

240
00:12:33,060 --> 00:12:36,019
useful for omac as well

241
00:12:36,019 --> 00:12:39,959
and how we do this so uh suppose we have

242
00:12:39,959 --> 00:12:41,519
this event so instead of this full

243
00:12:41,519 --> 00:12:45,000
Collision event what we bomb or what we

244
00:12:45,000 --> 00:12:48,120
disallow is this compound event where

245
00:12:48,120 --> 00:12:51,779
the subsequent input here xj3 is also

246
00:12:51,779 --> 00:12:53,880
colliding with some other input

247
00:12:53,880 --> 00:12:57,000
so although a bit tedious to handle this

248
00:12:57,000 --> 00:13:00,240
actually gives us another n bit entropy

249
00:13:00,240 --> 00:13:02,519
and in the paper we have shown that this

250
00:13:02,519 --> 00:13:05,399
can be uh easily bounded to

251
00:13:05,399 --> 00:13:08,399
this expression and uh which is straight

252
00:13:08,399 --> 00:13:12,060
away better than the existing bond

253
00:13:12,060 --> 00:13:15,000
so uh now that we disallowed those

254
00:13:15,000 --> 00:13:17,040
events uh we can go back to the full

255
00:13:17,040 --> 00:13:20,040
condition event and for this we simply

256
00:13:20,040 --> 00:13:24,240
reset this yj2 with ti so because these

257
00:13:24,240 --> 00:13:27,060
are equality on the inputs we just make

258
00:13:27,060 --> 00:13:29,839
the outputs equal

259
00:13:31,680 --> 00:13:35,100
and as soon as we change the output it

260
00:13:35,100 --> 00:13:37,860
changes the next input and what can

261
00:13:37,860 --> 00:13:39,540
happen is that this next input might

262
00:13:39,540 --> 00:13:42,480
collide with something else

263
00:13:42,480 --> 00:13:44,639
and if this kind of Correction happens

264
00:13:44,639 --> 00:13:48,360
uh this is a bit trickier to handle uh

265
00:13:48,360 --> 00:13:50,339
as compared to light Max so in light Mac

266
00:13:50,339 --> 00:13:54,060
also we had the same issues but it was

267
00:13:54,060 --> 00:13:56,399
easy to handle there

268
00:13:56,399 --> 00:13:58,320
whereas in this case we have to do

269
00:13:58,320 --> 00:14:01,440
something extra so let's discuss this

270
00:14:01,440 --> 00:14:05,459
issue in a in detail so first the simple

271
00:14:05,459 --> 00:14:06,600
case

272
00:14:06,600 --> 00:14:09,779
suppose this Collision happens at uh in

273
00:14:09,779 --> 00:14:11,880
the KF query at somewhere in the middle

274
00:14:11,880 --> 00:14:14,339
uh except for the so more importantly

275
00:14:14,339 --> 00:14:16,139
not at the first block

276
00:14:16,139 --> 00:14:19,320
then it can be handled uh as before and

277
00:14:19,320 --> 00:14:23,639
because you have two equalities and uh

278
00:14:23,639 --> 00:14:25,740
three queries and two blocks you get a

279
00:14:25,740 --> 00:14:27,480
bound like this

280
00:14:27,480 --> 00:14:28,620
but

281
00:14:28,620 --> 00:14:31,560
if it happens at the first block

282
00:14:31,560 --> 00:14:35,100
and additionally suppose uh the kth

283
00:14:35,100 --> 00:14:38,040
query occurs after the in ith and jth

284
00:14:38,040 --> 00:14:40,440
query then adversary can easily fix this

285
00:14:40,440 --> 00:14:43,380
first block uh by this relation so you

286
00:14:43,380 --> 00:14:49,279
can make MK1 equal t i x or mj3

287
00:14:49,339 --> 00:14:52,980
which uh in a way uh

288
00:14:52,980 --> 00:14:56,339
com like makes this second equality a

289
00:14:56,339 --> 00:14:58,199
consequence of the first equality so as

290
00:14:58,199 --> 00:15:00,420
soon as the first equality holds this

291
00:15:00,420 --> 00:15:03,660
second equality holds uh trivially

292
00:15:03,660 --> 00:15:06,720
and this is an issue so what I'm trying

293
00:15:06,720 --> 00:15:08,880
to hint at is that we need another round

294
00:15:08,880 --> 00:15:11,220
of resetting uh something that we call

295
00:15:11,220 --> 00:15:14,040
induced resetting in the paper

296
00:15:14,040 --> 00:15:17,459
so how industry setting work so I've

297
00:15:17,459 --> 00:15:19,920
I have added uh two more blocks here

298
00:15:19,920 --> 00:15:22,980
just to uh describe the induced

299
00:15:22,980 --> 00:15:26,100
resetting so obviously the inputs are

300
00:15:26,100 --> 00:15:28,260
colliding here so what we have to do is

301
00:15:28,260 --> 00:15:31,320
we have to reset the next output

302
00:15:31,320 --> 00:15:33,600
so the resetting is happening on the JS

303
00:15:33,600 --> 00:15:36,779
query and the kth queries basically

304
00:15:36,779 --> 00:15:40,380
providing the values for each setting so

305
00:15:40,380 --> 00:15:43,320
we have to reset uh the next output

306
00:15:43,320 --> 00:15:46,860
now uh ordinarily it might it should be

307
00:15:46,860 --> 00:15:49,620
enough but now uh what can happen is uh

308
00:15:49,620 --> 00:15:53,820
MK2 might be equal to mj4 right so the

309
00:15:53,820 --> 00:15:55,860
next block next message block might be

310
00:15:55,860 --> 00:15:58,199
equal so in that case the next input is

311
00:15:58,199 --> 00:16:00,720
all also equal and that means we have to

312
00:16:00,720 --> 00:16:02,040
again reset

313
00:16:02,040 --> 00:16:04,260
and in this way we have to keep on going

314
00:16:04,260 --> 00:16:07,320
until uh the two message blocks differ

315
00:16:07,320 --> 00:16:10,440
so in this case MK3 and mj5 are

316
00:16:10,440 --> 00:16:14,779
different so xk3 and xj5 are different

317
00:16:14,779 --> 00:16:17,639
so here we can stop

318
00:16:17,639 --> 00:16:19,860
but as soon as you stop you have to

319
00:16:19,860 --> 00:16:21,839
again perform another sanity check

320
00:16:21,839 --> 00:16:25,019
whether xj5 matches something or not

321
00:16:25,019 --> 00:16:29,279
so uh this is again like a second level

322
00:16:29,279 --> 00:16:31,440
of Sentry check so first we checked

323
00:16:31,440 --> 00:16:33,600
something like this and now there is

324
00:16:33,600 --> 00:16:35,339
another check where xj5 might equal

325
00:16:35,339 --> 00:16:38,459
something uh something else

326
00:16:38,459 --> 00:16:42,660
but uh the good news is that this can be

327
00:16:42,660 --> 00:16:45,420
bounded easily and uh after handling

328
00:16:45,420 --> 00:16:48,660
these tricky case and some Case by case

329
00:16:48,660 --> 00:16:51,000
analysis we can actually get our main

330
00:16:51,000 --> 00:16:54,660
result which is uh this expression

331
00:16:54,660 --> 00:16:58,560
and uh if you translate it into the into

332
00:16:58,560 --> 00:17:00,420
a statement then basically it says that

333
00:17:00,420 --> 00:17:02,339
Eve needs minimum of square root of 2 to

334
00:17:02,339 --> 00:17:05,040
the n and 2 to the N over L squared

335
00:17:05,040 --> 00:17:07,980
queries so it's not exactly the minimum

336
00:17:07,980 --> 00:17:09,959
but if you attack you generally attack

337
00:17:09,959 --> 00:17:13,020
via one of the two techniques so that's

338
00:17:13,020 --> 00:17:14,699
why it's a minimum of square root of 2

339
00:17:14,699 --> 00:17:15,839
to the n

340
00:17:15,839 --> 00:17:18,780
and 2 to the N over L squared queries

341
00:17:18,780 --> 00:17:21,599
and if you want to compare with the

342
00:17:21,599 --> 00:17:24,900
existing bounds or the photo bound then

343
00:17:24,900 --> 00:17:28,020
it's it's clear that we while we do not

344
00:17:28,020 --> 00:17:29,580
quite achieve the focal bound it is

345
00:17:29,580 --> 00:17:32,100
still a step towards a tighter Bond

346
00:17:32,100 --> 00:17:35,700
so for instance if we take n equals 128

347
00:17:35,700 --> 00:17:37,919
and consider a graph of number of

348
00:17:37,919 --> 00:17:39,660
queries Q versus the maximum message

349
00:17:39,660 --> 00:17:41,700
length l

350
00:17:41,700 --> 00:17:43,320
there is a clear daylight between the

351
00:17:43,320 --> 00:17:46,200
folklore and the existing bounds but if

352
00:17:46,200 --> 00:17:50,340
we now put our bound here it is uh very

353
00:17:50,340 --> 00:17:53,160
close to the fourth load bound uh in

354
00:17:53,160 --> 00:17:56,400
fact up to the message lengths of

355
00:17:56,400 --> 00:17:59,400
almost 64 gigabytes uh it's very close

356
00:17:59,400 --> 00:18:01,980
to uh the four core bound and it

357
00:18:01,980 --> 00:18:04,080
performs uh better than the existing

358
00:18:04,080 --> 00:18:07,500
bounce up to 64 terabytes so it's it's

359
00:18:07,500 --> 00:18:10,860
almost like uh I mean messages generally

360
00:18:10,860 --> 00:18:14,460
are much smaller than a gigabyte so the

361
00:18:14,460 --> 00:18:17,340
Bound in general is quite good

362
00:18:17,340 --> 00:18:19,679
so in conclusion what we have shown is

363
00:18:19,679 --> 00:18:21,660
that omac is almost birthday bound

364
00:18:21,660 --> 00:18:22,860
secure

365
00:18:22,860 --> 00:18:24,500
foreign

366
00:18:24,500 --> 00:18:26,940
like in the full paper we have shown

367
00:18:26,940 --> 00:18:28,980
similar results for xcbc and tmac as

368
00:18:28,980 --> 00:18:30,419
well

369
00:18:30,419 --> 00:18:34,080
so I will conclude uh with some future

370
00:18:34,080 --> 00:18:36,840
directions of research so first and

371
00:18:36,840 --> 00:18:38,700
obvious direction is of course the new

372
00:18:38,700 --> 00:18:41,460
application of reset sampling uh

373
00:18:41,460 --> 00:18:42,980
particularly towards

374
00:18:42,980 --> 00:18:45,960
the Beyond birthday bound single kid

375
00:18:45,960 --> 00:18:47,520
constructions how to improve their

376
00:18:47,520 --> 00:18:48,900
security

377
00:18:48,900 --> 00:18:50,640
uh and the second direction is to

378
00:18:50,640 --> 00:18:52,740
explore the possibility of improving the

379
00:18:52,740 --> 00:18:55,679
bounce in this paper so our bounds uh

380
00:18:55,679 --> 00:18:58,200
the the L value for example here it's L

381
00:18:58,200 --> 00:19:00,780
squared in the denominator so how we can

382
00:19:00,780 --> 00:19:03,000
improve it uh further so that the

383
00:19:03,000 --> 00:19:05,400
relaxation on the message length can be

384
00:19:05,400 --> 00:19:07,559
uh the restriction on the message length

385
00:19:07,559 --> 00:19:09,679
can be relaxed

386
00:19:09,679 --> 00:19:13,160
and finally our

387
00:19:13,160 --> 00:19:16,380
approach towards reset sampling is uh

388
00:19:16,380 --> 00:19:18,780
quite ad-hoc to be honest uh for now

389
00:19:18,780 --> 00:19:21,600
both in case of light Mac and in case of

390
00:19:21,600 --> 00:19:23,039
Omak

391
00:19:23,039 --> 00:19:26,100
so uh what would be interesting is to

392
00:19:26,100 --> 00:19:28,140
see an abstract formalization of this

393
00:19:28,140 --> 00:19:31,740
tool so that uh it might be easier to

394
00:19:31,740 --> 00:19:34,679
apply to other constructions as well so

395
00:19:34,679 --> 00:19:37,740
with this I will end my talk thank you

396
00:19:37,740 --> 00:19:40,320
for your attention Okay thank you for

397
00:19:40,320 --> 00:19:43,100
speakers

398
00:19:45,380 --> 00:19:49,640
educations or comments

399
00:19:52,380 --> 00:19:55,440
can you check online question no no

400
00:19:55,440 --> 00:19:57,919
question

401
00:19:58,080 --> 00:20:01,260
okay it seems there's no question yeah

402
00:20:01,260 --> 00:20:05,000
okay thanks because again

403
00:20:05,880 --> 00:20:08,400
thank you

404
00:20:08,400 --> 00:20:11,280
okay next talk is

405
00:20:11,280 --> 00:20:15,299
uh it's all nine other in person the aim

406
00:20:15,299 --> 00:20:18,360
model approach to the secret analysis of

407
00:20:18,360 --> 00:20:22,320
two permutation construction by yudong

408
00:20:22,320 --> 00:20:23,640
Chen

409
00:20:23,640 --> 00:20:25,880
foreign

410
00:20:42,799 --> 00:20:47,360
okay thank you for the introduction

411
00:20:48,660 --> 00:20:53,039
okay so yeah as the title says this

412
00:20:53,039 --> 00:20:54,780
paper is about permutation-based

413
00:20:54,780 --> 00:20:57,000
constructions so that's due to the

414
00:20:57,000 --> 00:20:58,919
announcements of shell 3 hash function

415
00:20:58,919 --> 00:21:02,940
competition in 2007 which makes ketchak

416
00:21:02,940 --> 00:21:05,760
an a Serena in 2012.

417
00:21:05,760 --> 00:21:07,860
and then since schedule is

418
00:21:07,860 --> 00:21:09,799
supplementation based hash function

419
00:21:09,799 --> 00:21:13,559
which makes a implementation yeah it

420
00:21:13,559 --> 00:21:15,000
leads to popularization of

421
00:21:15,000 --> 00:21:18,600
communication-based constructions

422
00:21:18,600 --> 00:21:20,659
um

423
00:21:21,740 --> 00:21:24,240
so indeed it's not only for hash

424
00:21:24,240 --> 00:21:25,980
functions there are different type of

425
00:21:25,980 --> 00:21:27,419
constructions based on primary

426
00:21:27,419 --> 00:21:30,000
permutations for example here we have a

427
00:21:30,000 --> 00:21:32,940
block Cipher uh yeah it's a Twitter box

428
00:21:32,940 --> 00:21:34,020
Cipher

429
00:21:34,020 --> 00:21:38,340
and this is a pif that we introduced in

430
00:21:38,340 --> 00:21:41,940
crypto 2019 and here's another type of

431
00:21:41,940 --> 00:21:45,059
pif and we also have a Mac algorithm

432
00:21:45,059 --> 00:21:48,000
based on public presentations and this

433
00:21:48,000 --> 00:21:50,760
is also something that's closer tccr

434
00:21:50,760 --> 00:21:53,700
hash function which we introduce in Asia

435
00:21:53,700 --> 00:21:56,159
Crypt last year and that's more suitable

436
00:21:56,159 --> 00:22:00,059
for the MPC applications you may not be

437
00:22:00,059 --> 00:22:01,799
familiar with all those constructions

438
00:22:01,799 --> 00:22:03,480
but you can see that actually all those

439
00:22:03,480 --> 00:22:05,640
constructions are based on two

440
00:22:05,640 --> 00:22:07,980
permutation and two permutation calls

441
00:22:07,980 --> 00:22:10,620
the reason therefore is that yeah that's

442
00:22:10,620 --> 00:22:12,840
actually the minimum number of primitive

443
00:22:12,840 --> 00:22:15,240
fraction needed to achieve young

444
00:22:15,240 --> 00:22:18,240
birthday Bond security when lightweight

445
00:22:18,240 --> 00:22:20,960
um yeah application is considered

446
00:22:20,960 --> 00:22:25,440
so maybe it's good to first go to the

447
00:22:25,440 --> 00:22:27,780
security notion of fermentation based

448
00:22:27,780 --> 00:22:30,240
constructions so in order to do that

449
00:22:30,240 --> 00:22:31,679
very first you should Define an attack

450
00:22:31,679 --> 00:22:33,900
game so at the beginning of the game one

451
00:22:33,900 --> 00:22:36,659
of those two worlds is chosen either the

452
00:22:36,659 --> 00:22:39,539
real world on the left side or the idea

453
00:22:39,539 --> 00:22:42,120
was on the right side so then this

454
00:22:42,120 --> 00:22:43,919
attacker here should

455
00:22:43,919 --> 00:22:46,799
um it's given query access to one of

456
00:22:46,799 --> 00:22:49,559
those two and it should state which of

457
00:22:49,559 --> 00:22:51,419
the Two Worlds it was interacting with

458
00:22:51,419 --> 00:22:54,960
at the end of the game so the attacker a

459
00:22:54,960 --> 00:22:57,299
can make two queries to the construction

460
00:22:57,299 --> 00:22:59,159
Oracle

461
00:22:59,159 --> 00:23:01,080
um yeah it's either on the left side

462
00:23:01,080 --> 00:23:03,960
it's the proposed construction or the

463
00:23:03,960 --> 00:23:05,820
idealized version of the proposed

464
00:23:05,820 --> 00:23:08,120
Consortium on the on the ideal side

465
00:23:08,120 --> 00:23:11,940
besides construction Oracle and precise

466
00:23:11,940 --> 00:23:13,919
construction query the attacker can also

467
00:23:13,919 --> 00:23:16,200
make p primitive query to each of the

468
00:23:16,200 --> 00:23:19,679
Primitive Oracle Pi one two pi r those

469
00:23:19,679 --> 00:23:21,559
are actually the Primitive where the

470
00:23:21,559 --> 00:23:24,480
construction in the real world is is

471
00:23:24,480 --> 00:23:27,960
built on well it is independent of the

472
00:23:27,960 --> 00:23:32,220
ideal world production Oracle now yeah

473
00:23:32,220 --> 00:23:34,440
the security in this case is measured by

474
00:23:34,440 --> 00:23:36,480
the probability that the attacker can

475
00:23:36,480 --> 00:23:38,580
distinguish the Two Worlds so it's

476
00:23:38,580 --> 00:23:40,799
denoted by this Advantage function which

477
00:23:40,799 --> 00:23:42,780
is actually a function of p and Q the

478
00:23:42,780 --> 00:23:45,000
more queries that you can ask the higher

479
00:23:45,000 --> 00:23:47,520
the probability that that hacker can

480
00:23:47,520 --> 00:23:50,159
distinguish into a systems then the

481
00:23:50,159 --> 00:23:52,140
different construction is only secure if

482
00:23:52,140 --> 00:23:54,120
this Advantage function is negligible

483
00:23:54,120 --> 00:23:56,700
however that's only the case when a

484
00:23:56,700 --> 00:23:59,340
single user is considered when we move

485
00:23:59,340 --> 00:24:02,159
to a more practical situation where

486
00:24:02,159 --> 00:24:04,200
there are mutable users each using the

487
00:24:04,200 --> 00:24:06,840
independence key then yeah the situation

488
00:24:06,840 --> 00:24:08,520
is a little bit different because the

489
00:24:08,520 --> 00:24:11,580
attacker makes skill queries to new

490
00:24:11,580 --> 00:24:13,860
construction Oracles in the real world

491
00:24:13,860 --> 00:24:16,620
that represents you users using the same

492
00:24:16,620 --> 00:24:18,720
construction each with the independent

493
00:24:18,720 --> 00:24:21,059
Key Well in the ideal World those are

494
00:24:21,059 --> 00:24:25,140
just independently draw random Arc ideal

495
00:24:25,140 --> 00:24:26,880
version of the construction

496
00:24:26,880 --> 00:24:29,580
the case for the Primitive queries are

497
00:24:29,580 --> 00:24:32,039
still the same however this time the

498
00:24:32,039 --> 00:24:34,080
attackers succeed as long as it can

499
00:24:34,080 --> 00:24:36,299
compromise one of the user key

500
00:24:36,299 --> 00:24:38,880
now in this case we can we can actually

501
00:24:38,880 --> 00:24:40,860
obtain the mute the user security from

502
00:24:40,860 --> 00:24:43,140
the single user security by simply

503
00:24:43,140 --> 00:24:47,640
multiply it with a factor U but when

504
00:24:47,640 --> 00:24:49,799
um this year the number of uses is very

505
00:24:49,799 --> 00:24:52,080
large than the security Bond becomes

506
00:24:52,080 --> 00:24:55,340
yeah very impractical

507
00:24:55,340 --> 00:24:59,100
then okay so in order to solve this

508
00:24:59,100 --> 00:25:01,860
problem maybe it's good to look at

509
00:25:01,860 --> 00:25:04,200
um yeah how the security proofs are

510
00:25:04,200 --> 00:25:07,500
performed in the Symmetry key world I

511
00:25:07,500 --> 00:25:09,980
would say so one of the most

512
00:25:09,980 --> 00:25:13,380
used methods to to prove the security of

513
00:25:13,380 --> 00:25:16,320
symmetry key constructions is Edge

514
00:25:16,320 --> 00:25:17,940
coefficient technique which is stated

515
00:25:17,940 --> 00:25:20,460
here I'm not going to experience it into

516
00:25:20,460 --> 00:25:23,039
detail but the idea behind this just a

517
00:25:23,039 --> 00:25:25,679
small set of transcripts that appears

518
00:25:25,679 --> 00:25:27,480
with very high probability than the

519
00:25:27,480 --> 00:25:29,940
other transcript and then the advantage

520
00:25:29,940 --> 00:25:32,039
of the artificer is I can actually

521
00:25:32,039 --> 00:25:34,440
bonded by those two terms this through

522
00:25:34,440 --> 00:25:38,400
Epsilon or this green probability there

523
00:25:38,400 --> 00:25:39,799
are three steps that need to be

524
00:25:39,799 --> 00:25:42,179
performed and the first one is of course

525
00:25:42,179 --> 00:25:43,919
sorry

526
00:25:43,919 --> 00:25:46,860
Define those bad transcripts that's

527
00:25:46,860 --> 00:25:49,140
appears with very high probability and

528
00:25:49,140 --> 00:25:51,120
the second one is we want to bond with

529
00:25:51,120 --> 00:25:53,220
this probability of those bad

530
00:25:53,220 --> 00:25:55,980
transcripts in the ideal world and the

531
00:25:55,980 --> 00:25:57,960
last one is this episode term which is

532
00:25:57,960 --> 00:26:01,559
related to the good transcripts that are

533
00:26:01,559 --> 00:26:03,240
the transcripts that

534
00:26:03,240 --> 00:26:06,720
um yeah excluding the bad ones that's

535
00:26:06,720 --> 00:26:09,360
um yeah in the real world and the ratio

536
00:26:09,360 --> 00:26:11,279
of the good transcript in the real world

537
00:26:11,279 --> 00:26:13,860
with that in the ideal world now we can

538
00:26:13,860 --> 00:26:16,260
see that actually by the definition the

539
00:26:16,260 --> 00:26:18,539
first and the last steps are actually

540
00:26:18,539 --> 00:26:20,340
totally depends on how the construction

541
00:26:20,340 --> 00:26:23,580
is designed well the second step is

542
00:26:23,580 --> 00:26:25,860
actually a purely combinatorial problem

543
00:26:25,860 --> 00:26:28,320
and only depends on the randomness of

544
00:26:28,320 --> 00:26:30,120
the key then that means the more key

545
00:26:30,120 --> 00:26:33,419
that you use in the construction the the

546
00:26:33,419 --> 00:26:37,919
easier to to perform this analysis now

547
00:26:37,919 --> 00:26:40,140
the question arises whether it's

548
00:26:40,140 --> 00:26:42,419
possible to have a model approach for

549
00:26:42,419 --> 00:26:45,000
the first and the last step since um

550
00:26:45,000 --> 00:26:46,919
that this is a totally different problem

551
00:26:46,919 --> 00:26:49,919
than the Second Step In order to give

552
00:26:49,919 --> 00:26:52,860
yeah if we have a model approach then

553
00:26:52,860 --> 00:26:55,620
yeah I would say that's much easier that

554
00:26:55,620 --> 00:26:57,840
we don't need to perform dedicated proof

555
00:26:57,840 --> 00:26:59,700
every time and new construction is

556
00:26:59,700 --> 00:27:02,820
designed in order to do that

557
00:27:02,820 --> 00:27:05,220
um yeah we first need to look at this

558
00:27:05,220 --> 00:27:07,140
problem here where

559
00:27:07,140 --> 00:27:09,720
um yeah we consider two sets of unknowns

560
00:27:09,720 --> 00:27:13,740
u and v and y and then we also consider

561
00:27:13,740 --> 00:27:16,140
system of variety equations and genome

562
00:27:16,140 --> 00:27:19,440
migrations where those V and V Y and

563
00:27:19,440 --> 00:27:21,480
three dots and Y dots are unknown value

564
00:27:21,480 --> 00:27:24,900
of more values and those Lambda and

565
00:27:24,900 --> 00:27:27,200
Lambda dots are actually the non-virus

566
00:27:27,200 --> 00:27:29,880
then there are two index mapping that we

567
00:27:29,880 --> 00:27:33,000
can Define that's maths the omnomes in

568
00:27:33,000 --> 00:27:35,460
the system through those two sets of

569
00:27:35,460 --> 00:27:38,580
norms then one of the

570
00:27:38,580 --> 00:27:41,100
um yeah one of the way to uh sorry then

571
00:27:41,100 --> 00:27:43,320
the goal here is actually to yeah

572
00:27:43,320 --> 00:27:45,539
determine a low amount of number of

573
00:27:45,539 --> 00:27:47,580
solutions to those systems

574
00:27:47,580 --> 00:27:50,039
then one of the solution is actually

575
00:27:50,039 --> 00:27:53,159
patents meal Theory which is also

576
00:27:53,159 --> 00:27:55,320
um talked about yeah it's also discussed

577
00:27:55,320 --> 00:27:57,960
during the talks in this morning then

578
00:27:57,960 --> 00:28:00,779
there we need to represent a system of

579
00:28:00,779 --> 00:28:05,039
equations and non-egrations by a graph

580
00:28:05,039 --> 00:28:07,559
um so here the

581
00:28:07,559 --> 00:28:08,159
um

582
00:28:08,159 --> 00:28:10,620
now so each distinct oh no is

583
00:28:10,620 --> 00:28:12,779
represented by a Vertex with the unknown

584
00:28:12,779 --> 00:28:14,520
value while each regression is

585
00:28:14,520 --> 00:28:17,460
represented by a number labeled h and a

586
00:28:17,460 --> 00:28:19,440
normal equation is by a number dot

587
00:28:19,440 --> 00:28:22,500
labeled Edge now the thing is that there

588
00:28:22,500 --> 00:28:24,480
are some properties that the transcript

589
00:28:24,480 --> 00:28:27,480
should satisfy for example it shouldn't

590
00:28:27,480 --> 00:28:29,820
contain a circle if this case happens

591
00:28:29,820 --> 00:28:31,500
then it actually says the distance

592
00:28:31,500 --> 00:28:33,120
between those two notes is equal to

593
00:28:33,120 --> 00:28:35,279
Lambda 1. well at the same time it's

594
00:28:35,279 --> 00:28:37,140
equal to number two that is actually

595
00:28:37,140 --> 00:28:40,200
very inconsistent and the second choice

596
00:28:40,200 --> 00:28:41,820
that it shouldn't compare in the

597
00:28:41,820 --> 00:28:44,640
seropath label because yeah according to

598
00:28:44,640 --> 00:28:46,559
this distance between those two nodes

599
00:28:46,559 --> 00:28:48,720
are Lambda which is also equal to the

600
00:28:48,720 --> 00:28:50,400
distance between those two notes well

601
00:28:50,400 --> 00:28:53,159
those two nodes are not not the same

602
00:28:53,159 --> 00:28:55,740
the last property is related to the norm

603
00:28:55,740 --> 00:28:57,779
equations it says that shouldn't be any

604
00:28:57,779 --> 00:29:00,600
circle with Lambda not labeled Edge such

605
00:29:00,600 --> 00:29:03,059
that Safari of Lambda dots is equal to

606
00:29:03,059 --> 00:29:05,039
the sum of all the slam number values

607
00:29:05,039 --> 00:29:07,860
look at this example here so this

608
00:29:07,860 --> 00:29:09,720
components actually says the distance

609
00:29:09,720 --> 00:29:11,460
between those two nodes is equal to

610
00:29:11,460 --> 00:29:14,100
Lambda well the distance between those

611
00:29:14,100 --> 00:29:16,320
two notes cannot be Lambda dots because

612
00:29:16,320 --> 00:29:18,899
that is a normal equation once this

613
00:29:18,899 --> 00:29:21,299
Lambda dot is equal to Lambda then of

614
00:29:21,299 --> 00:29:22,980
course the components yeah that's

615
00:29:22,980 --> 00:29:26,419
inconsistency so those are actually the

616
00:29:26,419 --> 00:29:28,740
properties that needed to define the

617
00:29:28,740 --> 00:29:30,240
batch transcripts in the security

618
00:29:30,240 --> 00:29:32,760
analysis however the problem is but the

619
00:29:32,760 --> 00:29:35,220
rest middle theory is actually for Block

620
00:29:35,220 --> 00:29:38,100
Cipher based prf constructions so if we

621
00:29:38,100 --> 00:29:39,539
want to use it through the permutation

622
00:29:39,539 --> 00:29:41,520
based setting and we want to extend it

623
00:29:41,520 --> 00:29:44,039
to a different type of motions we need

624
00:29:44,039 --> 00:29:45,360
to

625
00:29:45,360 --> 00:29:47,820
um yeah go a little bit further so in

626
00:29:47,820 --> 00:29:49,740
this work we'll focus mainly on all

627
00:29:49,740 --> 00:29:52,080
constructions that can be filled like

628
00:29:52,080 --> 00:29:53,100
this

629
00:29:53,100 --> 00:29:55,799
a b and we can it's actually the

630
00:29:55,799 --> 00:29:57,899
functions of secret key inputs and the

631
00:29:57,899 --> 00:29:59,220
output

632
00:29:59,220 --> 00:30:02,100
now I said before the security analysis

633
00:30:02,100 --> 00:30:03,659
analysis is performed in either

634
00:30:03,659 --> 00:30:06,659
permutation model and therefore the

635
00:30:06,659 --> 00:30:08,399
attacker has query access to the

636
00:30:08,399 --> 00:30:10,740
underlying primitive Supply one and Pi 2

637
00:30:10,740 --> 00:30:14,159
which are models as random now uh which

638
00:30:14,159 --> 00:30:15,840
that means we should also take the

639
00:30:15,840 --> 00:30:17,880
Primitive queries in this form into

640
00:30:17,880 --> 00:30:19,020
account

641
00:30:19,020 --> 00:30:22,440
if we try to add those primitive queries

642
00:30:22,440 --> 00:30:25,020
into the system then we can see that the

643
00:30:25,020 --> 00:30:29,940
system of equations is extended by two P

644
00:30:29,940 --> 00:30:32,940
unified equations that means that the

645
00:30:32,940 --> 00:30:35,840
index mapping is also different however

646
00:30:35,840 --> 00:30:38,520
because the fact that we know all those

647
00:30:38,520 --> 00:30:42,679
Lambda values then those yeah additional

648
00:30:42,679 --> 00:30:47,580
yeah I would say p almost V and this P

649
00:30:47,580 --> 00:30:50,820
equations on y so there the the amount v

650
00:30:50,820 --> 00:30:53,880
and y are well defined that means a part

651
00:30:53,880 --> 00:30:58,140
of the um of the sets of or no v and y

652
00:30:58,140 --> 00:30:59,820
is also defined

653
00:30:59,820 --> 00:31:03,600
now if we move on this um those system

654
00:31:03,600 --> 00:31:06,059
of equations and no migrations to the

655
00:31:06,059 --> 00:31:08,640
transcript graph so those are the um

656
00:31:08,640 --> 00:31:11,100
things that's needed to for the general

657
00:31:11,100 --> 00:31:14,100
setting and here we need to add a

658
00:31:14,100 --> 00:31:16,440
primitive query then it is represented

659
00:31:16,440 --> 00:31:20,100
by a Vertex with non-farou which we will

660
00:31:20,100 --> 00:31:23,100
denote by a white vertex and then

661
00:31:23,100 --> 00:31:26,520
there's also extra components that need

662
00:31:26,520 --> 00:31:28,919
to be introduced that's called colliding

663
00:31:28,919 --> 00:31:31,159
components that means a component that

664
00:31:31,159 --> 00:31:34,620
contains a Vertex with no value for

665
00:31:34,620 --> 00:31:37,500
those type of components all vertex the

666
00:31:37,500 --> 00:31:40,380
form of all vertex are well defined it's

667
00:31:40,380 --> 00:31:42,600
very easy to see because let's say here

668
00:31:42,600 --> 00:31:45,299
we have on those components By ignoring

669
00:31:45,299 --> 00:31:48,360
all components with path length of three

670
00:31:48,360 --> 00:31:50,940
or higher then we can see that and those

671
00:31:50,940 --> 00:31:52,980
are actually the colliding components if

672
00:31:52,980 --> 00:31:54,779
we know the value of the white vertex

673
00:31:54,779 --> 00:31:58,620
and so we know the value of the labels

674
00:31:58,620 --> 00:32:01,320
in the edge those are the a Lambda virus

675
00:32:01,320 --> 00:32:03,840
then we can perfectly Define those black

676
00:32:03,840 --> 00:32:06,120
nodes

677
00:32:06,120 --> 00:32:09,360
so okay so however there are some

678
00:32:09,360 --> 00:32:11,220
properties that's

679
00:32:11,220 --> 00:32:13,980
um yeah the graph should satisfy in

680
00:32:13,980 --> 00:32:16,740
order to to apply the theory for example

681
00:32:16,740 --> 00:32:19,380
there cannot be any components with more

682
00:32:19,380 --> 00:32:22,260
than one colliding or one white vertex

683
00:32:22,260 --> 00:32:24,360
the reason it's very simple because we

684
00:32:24,360 --> 00:32:26,640
know exactly the value of this node we

685
00:32:26,640 --> 00:32:28,380
know also know exactly the value of this

686
00:32:28,380 --> 00:32:31,200
node and we also know the file of the

687
00:32:31,200 --> 00:32:34,260
the age label so there's no guarantee

688
00:32:34,260 --> 00:32:36,659
that the actual between those two nodes

689
00:32:36,659 --> 00:32:40,320
is equal to the um the this Lambda for

690
00:32:40,320 --> 00:32:43,620
in in this in this Edge then the second

691
00:32:43,620 --> 00:32:46,140
property that it should satisfy is that

692
00:32:46,140 --> 00:32:48,779
there cannot be um I would say

693
00:32:48,779 --> 00:32:51,539
non-egrations that's connecting two

694
00:32:51,539 --> 00:32:53,940
colliding components such that the

695
00:32:53,940 --> 00:32:56,700
distance between the two Collide two

696
00:32:56,700 --> 00:32:59,100
connected vertex is equal to this Lambda

697
00:32:59,100 --> 00:33:01,200
dots the reason is also very simple

698
00:33:01,200 --> 00:33:03,779
because as mentioned before we know

699
00:33:03,779 --> 00:33:06,059
exactly all the values of all those

700
00:33:06,059 --> 00:33:09,480
notes in a colliding component then

701
00:33:09,480 --> 00:33:12,779
suppose the two connected vertices and

702
00:33:12,779 --> 00:33:15,840
their value is equal to a and b then the

703
00:33:15,840 --> 00:33:17,399
fact that they are connected with the

704
00:33:17,399 --> 00:33:19,200
norm equation means that they should

705
00:33:19,200 --> 00:33:21,600
satisfy the property ax or B is not

706
00:33:21,600 --> 00:33:24,299
equal to Lambda however if the fact that

707
00:33:24,299 --> 00:33:26,519
we know exactly the value of a and b and

708
00:33:26,519 --> 00:33:29,399
Lambda dot then suppose Lambda dot is

709
00:33:29,399 --> 00:33:32,279
equal to a X or B then of course that is

710
00:33:32,279 --> 00:33:33,659
inconsistency

711
00:33:33,659 --> 00:33:36,659
so take to all those properties into

712
00:33:36,659 --> 00:33:39,960
account we can derive or extend the

713
00:33:39,960 --> 00:33:41,640
traditional mere theory in the

714
00:33:41,640 --> 00:33:43,200
permutation based setting and we can

715
00:33:43,200 --> 00:33:44,760
apply those two different type of

716
00:33:44,760 --> 00:33:46,440
constructions with different security

717
00:33:46,440 --> 00:33:50,100
Notions and maybe first to explain a

718
00:33:50,100 --> 00:33:52,320
single framework to use those

719
00:33:52,320 --> 00:33:55,019
um not to use a technique given a

720
00:33:55,019 --> 00:33:57,299
construction that can be filled like

721
00:33:57,299 --> 00:34:00,419
this and we can we have a query

722
00:34:00,419 --> 00:34:03,000
transcripts involving form including the

723
00:34:03,000 --> 00:34:05,220
Primitive queries and the keys are given

724
00:34:05,220 --> 00:34:08,399
at the end of the interaction then we

725
00:34:08,399 --> 00:34:10,739
can represent the query transcripts by

726
00:34:10,739 --> 00:34:12,719
this system of equations and gnome

727
00:34:12,719 --> 00:34:16,440
migrations and using the those systems

728
00:34:16,440 --> 00:34:19,619
we can Define the batch transcripts then

729
00:34:19,619 --> 00:34:21,780
when we have the bachelor script we can

730
00:34:21,780 --> 00:34:24,780
easily use the new Theory to obtain this

731
00:34:24,780 --> 00:34:28,500
Epsilon problem now some examples so we

732
00:34:28,500 --> 00:34:30,480
applied to three different constructions

733
00:34:30,480 --> 00:34:32,099
to obtain the mute the user security of

734
00:34:32,099 --> 00:34:34,260
those constructions the first one is

735
00:34:34,260 --> 00:34:35,699
actually the typical block side vertical

736
00:34:35,699 --> 00:34:38,940
if a monster by goshniadiator in 2015.

737
00:34:38,940 --> 00:34:41,040
so they show the single user security is

738
00:34:41,040 --> 00:34:43,739
2N over three however here we can show

739
00:34:43,739 --> 00:34:46,080
the multi-user security by for example

740
00:34:46,080 --> 00:34:49,080
replacing this by two by by 2 inverse in

741
00:34:49,080 --> 00:34:51,480
order to apply the theory that can be

742
00:34:51,480 --> 00:34:52,980
done since we are working in the ideal

743
00:34:52,980 --> 00:34:54,839
computation model and implementations

744
00:34:54,839 --> 00:34:58,320
are assumed to be a perfectly random and

745
00:34:58,320 --> 00:35:01,080
then this is a and this is B well this

746
00:35:01,080 --> 00:35:02,839
middle value is actually

747
00:35:02,839 --> 00:35:07,680
it's equal to H1 xoh2 and yeah we can

748
00:35:07,680 --> 00:35:09,540
show with our model approach that it

749
00:35:09,540 --> 00:35:12,000
have two n over three bits Moody and

750
00:35:12,000 --> 00:35:13,859
security user setting which is

751
00:35:13,859 --> 00:35:16,740
comparable to the single user case the

752
00:35:16,740 --> 00:35:19,740
second example is actually the pif

753
00:35:19,740 --> 00:35:21,660
um implementation based EDM proposed by

754
00:35:21,660 --> 00:35:25,079
two diatom in 2021 where and they also

755
00:35:25,079 --> 00:35:27,060
show two and over three bits simple uses

756
00:35:27,060 --> 00:35:29,400
security then we use the same three cups

757
00:35:29,400 --> 00:35:31,020
before and then

758
00:35:31,020 --> 00:35:33,960
um that this part is a and this is B and

759
00:35:33,960 --> 00:35:36,480
the the middle part is actually k2x or

760
00:35:36,480 --> 00:35:39,420
with it's feet forward so the security

761
00:35:39,420 --> 00:35:42,180
analysis of the medioces I think is

762
00:35:42,180 --> 00:35:43,680
actually more complex than the single

763
00:35:43,680 --> 00:35:45,780
uses of these things in the single user

764
00:35:45,780 --> 00:35:48,060
case um the input to Pi one is always

765
00:35:48,060 --> 00:35:50,700
fresh since uh this image should always

766
00:35:50,700 --> 00:35:52,800
be fresh but for the when buildable

767
00:35:52,800 --> 00:35:54,839
users are considered there's no

768
00:35:54,839 --> 00:35:57,000
guarantee that the input through Pi one

769
00:35:57,000 --> 00:36:00,300
across mutable uses are still Fresh So

770
00:36:00,300 --> 00:36:03,240
the analysis is a bit more complex but

771
00:36:03,240 --> 00:36:06,839
we can still obtain two n over three bit

772
00:36:06,839 --> 00:36:09,060
Security in medios Security in the movie

773
00:36:09,060 --> 00:36:11,940
user setting and using of multiple

774
00:36:11,940 --> 00:36:13,619
security technique which is also

775
00:36:13,619 --> 00:36:15,920
comparable to a single use case

776
00:36:15,920 --> 00:36:20,040
and the last one is actually the Mac

777
00:36:20,040 --> 00:36:21,900
algorithm which is supplementation based

778
00:36:21,900 --> 00:36:24,660
in the HTM construction proposed by do

779
00:36:24,660 --> 00:36:27,960
that 90 in 2020 where they show that it

780
00:36:27,960 --> 00:36:30,119
has two and over three bit Security in

781
00:36:30,119 --> 00:36:33,000
the single user setting however uh using

782
00:36:33,000 --> 00:36:34,980
our approach we can see there's actually

783
00:36:34,980 --> 00:36:38,040
a flow in the security analysis since um

784
00:36:38,040 --> 00:36:40,680
the others missed some bad events and

785
00:36:40,680 --> 00:36:42,240
those are actually the bad events that

786
00:36:42,240 --> 00:36:44,579
they are missing I represent this by the

787
00:36:44,579 --> 00:36:47,099
form of the components that they should

788
00:36:47,099 --> 00:36:50,579
have been and excluded I'm not going to

789
00:36:50,579 --> 00:36:53,700
talk in detail about those components

790
00:36:53,700 --> 00:36:55,619
you can find the details in in the paper

791
00:36:55,619 --> 00:36:59,040
but then the consequence is that due to

792
00:36:59,040 --> 00:37:01,740
the fact that those events are missing

793
00:37:01,740 --> 00:37:04,440
the good transcript analysis is also

794
00:37:04,440 --> 00:37:07,560
incomplete and therefore in this work

795
00:37:07,560 --> 00:37:09,839
also with my other work with the authors

796
00:37:09,839 --> 00:37:12,240
we find two different ways to solve this

797
00:37:12,240 --> 00:37:14,700
problem so the left hand side you see

798
00:37:14,700 --> 00:37:18,359
the way that I have with the um artists

799
00:37:18,359 --> 00:37:20,700
in my other paper where we just make a

800
00:37:20,700 --> 00:37:21,960
very simple

801
00:37:21,960 --> 00:37:24,540
um modification by xoring the key on the

802
00:37:24,540 --> 00:37:27,180
right hand side however this leads to

803
00:37:27,180 --> 00:37:29,220
have much more difficult security proof

804
00:37:29,220 --> 00:37:32,700
well in this work we since we're only

805
00:37:32,700 --> 00:37:34,920
focused on Modern approach I just simply

806
00:37:34,920 --> 00:37:37,440
add more Randomness at the ends and then

807
00:37:37,440 --> 00:37:41,099
we can apply our technique in order to

808
00:37:41,099 --> 00:37:43,940
stop it in a very simple way and then

809
00:37:43,940 --> 00:37:47,880
hit this a this B and this part is the

810
00:37:47,880 --> 00:37:49,680
middle part and we can show the

811
00:37:49,680 --> 00:37:51,420
construction in data trip two and over

812
00:37:51,420 --> 00:37:54,780
three bits multi-user security and us

813
00:37:54,780 --> 00:37:57,300
change that order for the single user

814
00:37:57,300 --> 00:37:59,579
setting so

815
00:37:59,579 --> 00:38:02,880
um yeah so those are the application on

816
00:38:02,880 --> 00:38:06,060
the new technique so here comes the of

817
00:38:06,060 --> 00:38:08,520
my presentation the new result of this

818
00:38:08,520 --> 00:38:10,140
work is a waterproof technique for

819
00:38:10,140 --> 00:38:12,140
permutation-based constructions based on

820
00:38:12,140 --> 00:38:14,820
traditional meal Theory and represent a

821
00:38:14,820 --> 00:38:17,099
framework to use this new technique and

822
00:38:17,099 --> 00:38:18,960
to apply this new technique to prove to

823
00:38:18,960 --> 00:38:21,180
the new the user security of three iron

824
00:38:21,180 --> 00:38:22,740
constructions

825
00:38:22,740 --> 00:38:25,440
and then some future research directions

826
00:38:25,440 --> 00:38:28,320
for um that the ones maybe we can

827
00:38:28,320 --> 00:38:31,619
descended the municipants AES based on

828
00:38:31,619 --> 00:38:34,020
public plantations using our new

829
00:38:34,020 --> 00:38:37,800
technique and yeah there's also we maybe

830
00:38:37,800 --> 00:38:39,720
find the model approach for the mid-use

831
00:38:39,720 --> 00:38:41,640
security proof for the permutation-based

832
00:38:41,640 --> 00:38:43,800
constructions and generalizing audio

833
00:38:43,800 --> 00:38:46,020
proof technique for more difficult

834
00:38:46,020 --> 00:38:47,700
constructions

835
00:38:47,700 --> 00:38:50,400
so that's the ends and thank you for

836
00:38:50,400 --> 00:38:54,560
your attention okay thank you

837
00:38:55,020 --> 00:38:58,160
education please

838
00:39:00,000 --> 00:39:02,900
I have a question anyway so your

839
00:39:02,900 --> 00:39:06,660
approached it seems very easy to analyze

840
00:39:06,660 --> 00:39:08,780
by combining modular

841
00:39:08,780 --> 00:39:12,359
Trader yeah but you are assumed that

842
00:39:12,359 --> 00:39:15,900
multi-user case multi-user can use this

843
00:39:15,900 --> 00:39:21,000
together but in crypto scenario the

844
00:39:21,000 --> 00:39:24,540
world to user is are always honest or

845
00:39:24,540 --> 00:39:27,599
dishonest you know so we need some

846
00:39:27,599 --> 00:39:32,060
assumption users are or equal

847
00:39:32,060 --> 00:39:35,660
probability to join this

848
00:39:35,660 --> 00:39:40,640
dysfunction or any other non

849
00:39:40,640 --> 00:39:44,700
dishonest users if they join what's

850
00:39:44,700 --> 00:39:47,820
happening yeah you're assume that all

851
00:39:47,820 --> 00:39:50,640
users are honest right and so the

852
00:39:50,640 --> 00:39:52,440
definition here is just that the

853
00:39:52,440 --> 00:39:56,040
attacker yeah it has access to all those

854
00:39:56,040 --> 00:39:59,339
user and miracles so it can query

855
00:39:59,339 --> 00:40:01,920
through all those user oracles that's

856
00:40:01,920 --> 00:40:03,960
actually the the Assumption of the

857
00:40:03,960 --> 00:40:06,660
beauty usage Security in this work so

858
00:40:06,660 --> 00:40:09,300
the attacker have access to to all those

859
00:40:09,300 --> 00:40:13,260
those oracles but then the Oracle the

860
00:40:13,260 --> 00:40:14,880
Oracle the oracles use either

861
00:40:14,880 --> 00:40:16,920
Independence keys in the real world

862
00:40:16,920 --> 00:40:19,740
order and it's randomly drawn in the

863
00:40:19,740 --> 00:40:22,680
ideal world so there's um yeah that the

864
00:40:22,680 --> 00:40:25,320
lesson so the assumption that that the

865
00:40:25,320 --> 00:40:28,380
randomness in the Oracle is still um I

866
00:40:28,380 --> 00:40:29,280
would say

867
00:40:29,280 --> 00:40:31,920
um yeah totally independence from each

868
00:40:31,920 --> 00:40:34,260
other so you should assume that the

869
00:40:34,260 --> 00:40:38,400
attacker is outside outside

870
00:40:39,119 --> 00:40:41,160
an inside attacker

871
00:40:41,160 --> 00:40:43,619
inside the hack assumption

872
00:40:43,619 --> 00:40:48,300
you mean that so any part of moisture

873
00:40:48,300 --> 00:40:50,940
he is very honestly

874
00:40:50,940 --> 00:40:53,160
you can assume otherwise

875
00:40:53,160 --> 00:40:56,040
what happened yeah it's

876
00:40:56,040 --> 00:40:57,839
um

877
00:40:57,839 --> 00:41:01,020
yeah that I think that that's uh in this

878
00:41:01,020 --> 00:41:02,579
a very

879
00:41:02,579 --> 00:41:04,940
yeah it is a little bit experience

880
00:41:04,940 --> 00:41:08,099
assumption and that that's used in in

881
00:41:08,099 --> 00:41:09,660
this work here

882
00:41:09,660 --> 00:41:10,440
um

883
00:41:10,440 --> 00:41:13,440
yeah I think that therefore that that's

884
00:41:13,440 --> 00:41:15,660
probably something that's um need to be

885
00:41:15,660 --> 00:41:19,140
discussed um okay yeah it's since um the

886
00:41:19,140 --> 00:41:21,000
other security notion in this work is

887
00:41:21,000 --> 00:41:23,880
just assuming that um that attack have

888
00:41:23,880 --> 00:41:26,400
the Black Box access to the to all those

889
00:41:26,400 --> 00:41:29,040
oracles and then

890
00:41:29,040 --> 00:41:32,280
um with independent keys so

891
00:41:32,280 --> 00:41:34,619
um your assumption is probably a little

892
00:41:34,619 --> 00:41:37,560
bit different than here so I'm not sure

893
00:41:37,560 --> 00:41:40,740
how how it can behave that's

894
00:41:40,740 --> 00:41:43,800
um yeah okay so any other questions no

895
00:41:43,800 --> 00:41:46,320
or no can you

896
00:41:46,320 --> 00:41:50,060
okay one more question over there

897
00:41:56,220 --> 00:41:57,780
hi uh

898
00:41:57,780 --> 00:41:59,700
you wrong

899
00:41:59,700 --> 00:42:01,760
um yes

900
00:42:01,760 --> 00:42:05,280
there's to someone else who want to ask

901
00:42:05,280 --> 00:42:07,020
questions or

902
00:42:07,020 --> 00:42:10,140
yeah yeah I would like to ask one

903
00:42:10,140 --> 00:42:13,320
question about the Bound for any HDM can

904
00:42:13,320 --> 00:42:16,500
you go to that slide may I think the

905
00:42:16,500 --> 00:42:17,940
a

906
00:42:17,940 --> 00:42:22,079
the previous slider yeah so this so here

907
00:42:22,079 --> 00:42:24,240
you have this for the multi-user you

908
00:42:24,240 --> 00:42:25,920
have this you choose two over two to the

909
00:42:25,920 --> 00:42:28,740
N bound uh yeah can you describe like

910
00:42:28,740 --> 00:42:31,740
how this is uh like achieved or why this

911
00:42:31,740 --> 00:42:33,119
is coming up

912
00:42:33,119 --> 00:42:36,060
yeah and that's up here seeing one of

913
00:42:36,060 --> 00:42:36,839
the

914
00:42:36,839 --> 00:42:39,720
um bad defense that I analyzed so

915
00:42:39,720 --> 00:42:43,200
they're there for um so I think that's

916
00:42:43,200 --> 00:42:46,500
um I think that that's Coalition in the

917
00:42:46,500 --> 00:42:48,540
keys or something but I cannot remember

918
00:42:48,540 --> 00:42:51,000
all the details but it's a piece that

919
00:42:51,000 --> 00:42:53,960
there is such bonds but

920
00:42:53,960 --> 00:42:57,660
sorry yeah you please come back so so in

921
00:42:57,660 --> 00:42:59,579
the case when single user security is

922
00:42:59,579 --> 00:43:01,740
considered then yeah this bonds become

923
00:43:01,740 --> 00:43:04,859
zero right because if you that's it's U

924
00:43:04,859 --> 00:43:07,980
times U minus one then if U is equal to

925
00:43:07,980 --> 00:43:10,500
one then this bonds disappears

926
00:43:10,500 --> 00:43:13,619
so um yeah so I was thinking that

927
00:43:13,619 --> 00:43:16,260
because here you have two different Keys

928
00:43:16,260 --> 00:43:19,380
three different Keys uh the key K the

929
00:43:19,380 --> 00:43:22,220
hash function H and then H star so

930
00:43:22,220 --> 00:43:25,200
shouldn't uh the bound to be better than

931
00:43:25,200 --> 00:43:26,400
this like

932
00:43:26,400 --> 00:43:29,040
even for multi-user

933
00:43:29,040 --> 00:43:31,680
because now it's saying that uh there's

934
00:43:31,680 --> 00:43:33,660
a birthday bound so do you have a attack

935
00:43:33,660 --> 00:43:35,099
that uh

936
00:43:35,099 --> 00:43:38,400
you're not kept as respond or

937
00:43:38,400 --> 00:43:40,400
um

938
00:43:42,800 --> 00:43:46,619
yes but the reason that's uh I use this

939
00:43:46,619 --> 00:43:49,500
H star is because otherwise

940
00:43:49,500 --> 00:43:50,520
um they are much more difficult

941
00:43:50,520 --> 00:43:52,380
techniques needed to bomb the bad

942
00:43:52,380 --> 00:43:55,980
defense but uh I I don't think this is

943
00:43:55,980 --> 00:43:58,140
really I can be really called the

944
00:43:58,140 --> 00:44:00,720
birthday Bond security since the number

945
00:44:00,720 --> 00:44:04,319
of users is usually to um to assume to

946
00:44:04,319 --> 00:44:07,859
not be more than the total number of

947
00:44:07,859 --> 00:44:11,520
queries that can be made here and

948
00:44:11,520 --> 00:44:13,800
um the total number of queries here can

949
00:44:13,800 --> 00:44:17,760
be made to still this um the Q term and

950
00:44:17,760 --> 00:44:21,000
it's CO2 and over three it did that

951
00:44:21,000 --> 00:44:24,180
there's a birthday Bond Security in in

952
00:44:24,180 --> 00:44:27,420
the relation with the number of users

953
00:44:27,420 --> 00:44:30,000
that that's is correct but I think that

954
00:44:30,000 --> 00:44:32,700
if I remember that's correctly because

955
00:44:32,700 --> 00:44:34,680
yeah it's a little bit a long time ago

956
00:44:34,680 --> 00:44:36,780
that this is the last Point comes from

957
00:44:36,780 --> 00:44:39,780
some bad event that I'm bonding I'm not

958
00:44:39,780 --> 00:44:43,260
saying that this bond this term is

959
00:44:43,260 --> 00:44:46,140
necessary so it's probably if you use

960
00:44:46,140 --> 00:44:49,980
some more involved technique or

961
00:44:49,980 --> 00:44:52,740
something you there is a maybe there is

962
00:44:52,740 --> 00:44:55,800
a way to have a better Bonds in the bad

963
00:44:55,800 --> 00:44:58,560
transcripts and and avoid the last term

964
00:44:58,560 --> 00:45:01,260
but yeah that's something that that's um

965
00:45:01,260 --> 00:45:04,680
yeah that I cannot guarantee so but

966
00:45:04,680 --> 00:45:08,760
um just using um just using simple

967
00:45:08,760 --> 00:45:11,160
um yeah yeah without using special

968
00:45:11,160 --> 00:45:14,640
technique and I I obtain this new um new

969
00:45:14,640 --> 00:45:16,800
bombs in the in the security analysis

970
00:45:16,800 --> 00:45:19,800
okay thank you thank you for the thank

971
00:45:19,800 --> 00:45:21,180
you okay

972
00:45:21,180 --> 00:45:24,180
okay thank you for your presentation I

973
00:45:24,180 --> 00:45:28,380
think it's a more advantages

974
00:45:28,380 --> 00:45:31,380
some interpretation over security

975
00:45:31,380 --> 00:45:34,400
analysis in terms of

976
00:45:34,400 --> 00:45:38,400
more increasable

977
00:45:40,619 --> 00:45:44,160
is there some button for generating uh

978
00:45:44,160 --> 00:45:49,859
some kind of correct form of the

979
00:45:49,859 --> 00:45:50,839
um

980
00:45:50,839 --> 00:45:55,160
these these equations uh compared to

981
00:45:55,160 --> 00:45:58,460
traditional security analysis techniques

982
00:45:58,460 --> 00:46:01,619
and so so let me understand your

983
00:46:01,619 --> 00:46:03,780
question clearly so you mean is there

984
00:46:03,780 --> 00:46:06,720
any relations between the generalization

985
00:46:06,720 --> 00:46:08,880
of the considerations with traditional

986
00:46:08,880 --> 00:46:11,640
techniques and yeah actually so in the

987
00:46:11,640 --> 00:46:14,099
traditional techniques you actually yeah

988
00:46:14,099 --> 00:46:16,440
so you actually perform more or less the

989
00:46:16,440 --> 00:46:18,960
same thing but you don't really

990
00:46:18,960 --> 00:46:22,140
um yeah go yeah set the those things

991
00:46:22,140 --> 00:46:24,720
into the system of equations and snow

992
00:46:24,720 --> 00:46:27,720
migrations but apparently if you

993
00:46:27,720 --> 00:46:29,640
um if you move to the system of

994
00:46:29,640 --> 00:46:32,640
equations and non-egrations then there

995
00:46:32,640 --> 00:46:35,339
can be yeah I'll say that there can be a

996
00:46:35,339 --> 00:46:38,579
more yeah better relationship with

997
00:46:38,579 --> 00:46:41,880
um the good transcript analysis and um

998
00:46:41,880 --> 00:46:44,640
and the real Theory here and that the

999
00:46:44,640 --> 00:46:46,020
thing is that

1000
00:46:46,020 --> 00:46:49,800
um once we can represent this um yeah

1001
00:46:49,800 --> 00:46:53,040
this Reason by all the transcripts by a

1002
00:46:53,040 --> 00:46:56,460
graph then and you've seen something a

1003
00:46:56,460 --> 00:46:58,619
simple technique or some definitions in

1004
00:46:58,619 --> 00:47:00,359
the graph Theory we can obtain much

1005
00:47:00,359 --> 00:47:02,099
better bonds

1006
00:47:02,099 --> 00:47:04,500
um I'm not sure if that's will be the

1007
00:47:04,500 --> 00:47:06,500
case for much more involved

1008
00:47:06,500 --> 00:47:09,180
constructions but for the constructions

1009
00:47:09,180 --> 00:47:11,700
that can be filled in this in this way

1010
00:47:11,700 --> 00:47:14,160
then that's definitely the case so maybe

1011
00:47:14,160 --> 00:47:16,319
it's for future research to consider

1012
00:47:16,319 --> 00:47:19,920
difficult constructions okay less things

1013
00:47:19,920 --> 00:47:21,060
go again

1014
00:47:21,060 --> 00:47:22,440
okay

1015
00:47:22,440 --> 00:47:24,119
thank you

1016
00:47:24,119 --> 00:47:27,060
next tool is

1017
00:47:27,060 --> 00:47:29,280
you can leave it there okay

1018
00:47:29,280 --> 00:47:31,880
thank you

1019
00:47:37,200 --> 00:47:40,380
optimizing rectangular attacks a unified

1020
00:47:40,380 --> 00:47:42,960
and a general framework for key recovery

1021
00:47:42,960 --> 00:47:46,700
also is by doing song NaNa

1022
00:47:46,700 --> 00:47:50,060
or young

1023
00:47:53,300 --> 00:47:57,359
and the Nana Chinese

1024
00:47:57,359 --> 00:48:00,560
now that's ready

1025
00:48:01,140 --> 00:48:05,359
I see the screen

1026
00:48:06,680 --> 00:48:11,160
thanks for the introduction okay we are

1027
00:48:11,160 --> 00:48:13,339
ready

1028
00:48:14,700 --> 00:48:17,819
okay thanks for the introduction

1029
00:48:17,819 --> 00:48:20,420
hello everyone my name is

1030
00:48:20,420 --> 00:48:23,780
in this talk I will introduce our paper

1031
00:48:23,780 --> 00:48:26,880
optimizing rectangle attacks a unified

1032
00:48:26,880 --> 00:48:31,260
and generic framework for key recovery

1033
00:48:31,260 --> 00:48:35,280
foreign parts

1034
00:48:37,980 --> 00:48:40,920
first I will start with some preliminary

1035
00:48:40,920 --> 00:48:42,839
knowledge

1036
00:48:42,839 --> 00:48:46,079
Boomerang attack is a differential stale

1037
00:48:46,079 --> 00:48:48,720
attack to construct a long differential

1038
00:48:48,720 --> 00:48:51,839
utilizing two short ones of high

1039
00:48:51,839 --> 00:48:53,220
probability

1040
00:48:53,220 --> 00:48:55,380
as shown in the figure

1041
00:48:55,380 --> 00:48:58,700
informal attack will encrypt a pair of

1042
00:48:58,700 --> 00:49:02,640
plane tests P1 P2 with a difference

1043
00:49:02,640 --> 00:49:05,880
Alpha to corresponding pair of silver

1044
00:49:05,880 --> 00:49:10,380
tests C1 C2 and each civil test is X

1045
00:49:10,380 --> 00:49:14,760
always difference data then the modified

1046
00:49:14,760 --> 00:49:19,260
silver test c3c4 are decrypted to a new

1047
00:49:19,260 --> 00:49:22,319
plane test pair P3 P4

1048
00:49:22,319 --> 00:49:25,140
if the difference of the new pair is

1049
00:49:25,140 --> 00:49:29,640
exactly Alpha though quote the quoted P1

1050
00:49:29,640 --> 00:49:34,040
P2 P3 P4 is a red cortex

1051
00:49:34,040 --> 00:49:36,960
rectangle attack is the chosen plane

1052
00:49:36,960 --> 00:49:39,960
test variant of boomerang and in this

1053
00:49:39,960 --> 00:49:42,359
work we mainly focus on mounting

1054
00:49:42,359 --> 00:49:45,480
rectangle key recovery attacks as

1055
00:49:45,480 --> 00:49:48,359
efficiently as possible

1056
00:49:48,359 --> 00:49:51,078
foreign

1057
00:49:53,359 --> 00:49:56,819
and some specific parameters for

1058
00:49:56,819 --> 00:49:59,640
rectangle key recovery attacks

1059
00:49:59,640 --> 00:50:02,460
this figure shows the author line of

1060
00:50:02,460 --> 00:50:06,060
rectangle K recovery or tab the Notions

1061
00:50:06,060 --> 00:50:08,640
in the figure are borrowed from previous

1062
00:50:08,640 --> 00:50:12,240
works on the rectangle or text which are

1063
00:50:12,240 --> 00:50:14,460
used frequently

1064
00:50:14,460 --> 00:50:18,240
here we highlight some new parameters

1065
00:50:18,240 --> 00:50:21,060
used in our paper

1066
00:50:21,060 --> 00:50:25,260
a b prime it refers to part of KB to be

1067
00:50:25,260 --> 00:50:28,319
guessed in this work and the MB Prime

1068
00:50:28,319 --> 00:50:31,740
refers to the number of sub-key bits of

1069
00:50:31,740 --> 00:50:33,359
KB Prime

1070
00:50:33,359 --> 00:50:37,020
RB denote RB Prime denotes the condition

1071
00:50:37,020 --> 00:50:40,140
can be verified under the gas of KB

1072
00:50:40,140 --> 00:50:42,660
Prime for plane test

1073
00:50:42,660 --> 00:50:46,800
in EB when we get all the MB sub K beats

1074
00:50:46,800 --> 00:50:50,460
we can verify the total rbb's conditions

1075
00:50:50,460 --> 00:50:54,720
for opening test pair then if we guess

1076
00:50:54,720 --> 00:50:59,520
guess the potential MB Prime sub KPS the

1077
00:50:59,520 --> 00:51:02,280
corresponding RB Prime these conditions

1078
00:51:02,280 --> 00:51:04,980
will be verified

1079
00:51:04,980 --> 00:51:08,099
and the way further denote MB star and

1080
00:51:08,099 --> 00:51:11,460
RB star and the rest of the involved sub

1081
00:51:11,460 --> 00:51:14,460
key and the filtering conditions in EB

1082
00:51:14,460 --> 00:51:16,980
respectively

1083
00:51:16,980 --> 00:51:19,980
the above definitions can be applied to

1084
00:51:19,980 --> 00:51:23,940
pattern EF completely and we don't make

1085
00:51:23,940 --> 00:51:27,559
redundant descriptions

1086
00:51:28,980 --> 00:51:33,059
before specify our work we provide some

1087
00:51:33,059 --> 00:51:35,880
new insights into the rectangle key

1088
00:51:35,880 --> 00:51:39,599
recovery attacks the key recovery of

1089
00:51:39,599 --> 00:51:42,780
rectangle attacks always include steps

1090
00:51:42,780 --> 00:51:46,500
of constructing pairs from single

1091
00:51:46,500 --> 00:51:47,480
messages

1092
00:51:47,480 --> 00:51:52,020
and constructing quartets from pairs

1093
00:51:52,020 --> 00:51:55,020
and there's a hurricane recovery can

1094
00:51:55,020 --> 00:51:58,200
always be split into four steps

1095
00:51:58,200 --> 00:52:00,180
data collection

1096
00:52:00,180 --> 00:52:04,559
quoted pair construction quarters quoted

1097
00:52:04,559 --> 00:52:06,800
constructing and processing and

1098
00:52:06,800 --> 00:52:09,240
exhaustive search

1099
00:52:09,240 --> 00:52:11,880
following these procedures four

1100
00:52:11,880 --> 00:52:15,540
rectangle K recovery algorithms have

1101
00:52:15,540 --> 00:52:18,180
been presented using four kinds of

1102
00:52:18,180 --> 00:52:21,300
different sub-key guessing strategies in

1103
00:52:21,300 --> 00:52:23,099
previous works

1104
00:52:23,099 --> 00:52:26,220
we investigate this rectangle key

1105
00:52:26,220 --> 00:52:29,099
recovery algorithms in depth and

1106
00:52:29,099 --> 00:52:30,780
observed that

1107
00:52:30,780 --> 00:52:33,900
these algorithms differ mainly in

1108
00:52:33,900 --> 00:52:37,800
strategy of getting some case and the

1109
00:52:37,800 --> 00:52:40,859
ways of constructing cortex

1110
00:52:40,859 --> 00:52:43,980
actually we can construct pairs either

1111
00:52:43,980 --> 00:52:49,099
in plane test size or in safer test side

1112
00:52:50,839 --> 00:52:54,420
then the first question came into our

1113
00:52:54,420 --> 00:52:57,059
minds is whether there are any other

1114
00:52:57,059 --> 00:53:00,300
ways to mount rectangle key recovery

1115
00:53:00,300 --> 00:53:02,480
attack

1116
00:53:02,480 --> 00:53:06,540
the answer is yes from the point of view

1117
00:53:06,540 --> 00:53:10,280
of subject guessing there are five new

1118
00:53:10,280 --> 00:53:14,160
types of key recovery take guessing

1119
00:53:14,160 --> 00:53:16,640
strategies

1120
00:53:19,200 --> 00:53:21,420
okay guessing strategies in previous

1121
00:53:21,420 --> 00:53:24,359
works the four algorithms were treated

1122
00:53:24,359 --> 00:53:27,780
as separated ones and their performances

1123
00:53:27,780 --> 00:53:30,180
vary from case to case

1124
00:53:30,180 --> 00:53:33,540
but in this paper we attempt to mount

1125
00:53:33,540 --> 00:53:36,839
rectangle key recovery attacks in a

1126
00:53:36,839 --> 00:53:38,280
unified way

1127
00:53:38,280 --> 00:53:41,520
first of all we consider a generic way

1128
00:53:41,520 --> 00:53:45,900
of guessing sub cape sub KB Prime and KF

1129
00:53:45,900 --> 00:53:48,200
Prime

1130
00:53:48,420 --> 00:53:54,240
which is part of KB and KF respectively

1131
00:53:55,920 --> 00:53:59,520
then it comes to question two how does

1132
00:53:59,520 --> 00:54:02,940
the K recovery algorithm proceed when KB

1133
00:54:02,940 --> 00:54:07,680
Prime and PF Prime are guessed

1134
00:54:07,680 --> 00:54:11,579
taking the ways of guessing sub keys and

1135
00:54:11,579 --> 00:54:14,839
the ways of constructing quotas together

1136
00:54:14,839 --> 00:54:18,000
we present or generic and unified

1137
00:54:18,000 --> 00:54:21,119
algorithm which supports any possible

1138
00:54:21,119 --> 00:54:24,440
attacking parameters

1139
00:54:27,200 --> 00:54:30,599
and I will now introduce our generic and

1140
00:54:30,599 --> 00:54:33,420
unified algorithm which is the most

1141
00:54:33,420 --> 00:54:36,059
important work in our paper

1142
00:54:36,059 --> 00:54:39,300
in data collection phase collect and

1143
00:54:39,300 --> 00:54:42,300
store why structures of 2 to the power

1144
00:54:42,300 --> 00:54:44,760
RB plane tests each

1145
00:54:44,760 --> 00:54:48,000
then we get part of the sub capits

1146
00:54:48,000 --> 00:54:51,480
involved in key recovery part and we

1147
00:54:51,480 --> 00:54:55,079
will obtain RB Prime beat and RF Prime

1148
00:54:55,079 --> 00:54:58,920
beat filtering conditions Eep and EF

1149
00:54:58,920 --> 00:55:00,960
respectively

1150
00:55:00,960 --> 00:55:04,500
totally we can get a manners RB star

1151
00:55:04,500 --> 00:55:06,000
manners mu

1152
00:55:06,000 --> 00:55:10,220
speed filtering conditions in EB and

1153
00:55:10,220 --> 00:55:14,520
unmanned RF star filters in EF

1154
00:55:14,520 --> 00:55:17,220
note that the number of filtering

1155
00:55:17,220 --> 00:55:20,220
conditions are also related to the

1156
00:55:20,220 --> 00:55:24,500
number of the structure or the data

1157
00:55:24,720 --> 00:55:27,720
using these conditions we construct

1158
00:55:27,720 --> 00:55:30,720
pairs when we construct pairs we can

1159
00:55:30,720 --> 00:55:35,180
filter the wrong pairs in advance

1160
00:55:35,700 --> 00:55:38,359
foreign

1161
00:55:39,140 --> 00:55:42,599
filters in both playing test aside and

1162
00:55:42,599 --> 00:55:45,180
the safer tested side we can construct

1163
00:55:45,180 --> 00:55:48,839
the pairs from other plane test sites or

1164
00:55:48,839 --> 00:55:51,780
several test site and the filtering

1165
00:55:51,780 --> 00:55:54,599
condition in another side will be used

1166
00:55:54,599 --> 00:55:58,140
in jail in generating cortex

1167
00:55:58,140 --> 00:56:00,900
then we need to decide which side to

1168
00:56:00,900 --> 00:56:02,280
start with

1169
00:56:02,280 --> 00:56:05,220
to reduce the time complexity of

1170
00:56:05,220 --> 00:56:08,280
constructing Pairs and the quartets

1171
00:56:08,280 --> 00:56:12,000
we expect to filter the wrong pairs as

1172
00:56:12,000 --> 00:56:15,000
many as possible at the beginning

1173
00:56:15,000 --> 00:56:18,180
with this demand We compare the number

1174
00:56:18,180 --> 00:56:21,359
of filtering conditions in plain test

1175
00:56:21,359 --> 00:56:24,200
site with the number in the civil test

1176
00:56:24,200 --> 00:56:28,140
site to decide the way of quartet

1177
00:56:28,140 --> 00:56:30,119
Construction

1178
00:56:30,119 --> 00:56:33,359
if there are more filters in the print

1179
00:56:33,359 --> 00:56:37,079
test side we construct pairs in the

1180
00:56:37,079 --> 00:56:39,540
plane test site using the filtering

1181
00:56:39,540 --> 00:56:43,500
conditions by constructing set as

1182
00:56:43,500 --> 00:56:47,280
with hash tables in which the pairs have

1183
00:56:47,280 --> 00:56:52,200
different only RP's Star Bits

1184
00:56:52,200 --> 00:56:55,859
then we generate quartets from the

1185
00:56:55,859 --> 00:56:58,619
remaining pairs inside as

1186
00:56:58,619 --> 00:57:01,619
and the number of quartets we will

1187
00:57:01,619 --> 00:57:04,260
obtain can be calculated from the

1188
00:57:04,260 --> 00:57:07,280
following expression

1189
00:57:08,220 --> 00:57:11,760
if there are more filters in the C4 test

1190
00:57:11,760 --> 00:57:15,359
site we construct pairs from the zipper

1191
00:57:15,359 --> 00:57:18,359
tests and the general quartets in the

1192
00:57:18,359 --> 00:57:19,380
other side

1193
00:57:19,380 --> 00:57:24,380
which is similar with the formal case

1194
00:57:27,180 --> 00:57:30,920
after constructing quartets we need to

1195
00:57:30,920 --> 00:57:34,800
determine the K candidates in EB and the

1196
00:57:34,800 --> 00:57:37,680
EF with the remaining cortex

1197
00:57:37,680 --> 00:57:40,980
finally we get the remaining unknown K

1198
00:57:40,980 --> 00:57:43,920
bits according to the case schedule and

1199
00:57:43,920 --> 00:57:46,800
recover the correct Key by exhaustive

1200
00:57:46,800 --> 00:57:49,099
search

1201
00:57:51,260 --> 00:57:55,559
according to our detailed algorithm we

1202
00:57:55,559 --> 00:57:58,319
can compute the data memory and time

1203
00:57:58,319 --> 00:58:02,119
complexity of the algorithm

1204
00:58:04,740 --> 00:58:08,880
and from the United algorithm it is

1205
00:58:08,880 --> 00:58:11,520
clear that any possible guessing

1206
00:58:11,520 --> 00:58:13,940
strategy should be allowed and that

1207
00:58:13,940 --> 00:58:17,220
there must be a guessing strategy

1208
00:58:17,220 --> 00:58:20,940
leading to the optimal complexity of the

1209
00:58:20,940 --> 00:58:22,920
key recovery attack

1210
00:58:22,920 --> 00:58:26,819
then there comes a question what is the

1211
00:58:26,819 --> 00:58:30,720
best choice for KB Prime KF Prime so

1212
00:58:30,720 --> 00:58:33,300
that the overall time complexity is

1213
00:58:33,300 --> 00:58:35,900
minimized

1214
00:58:37,260 --> 00:58:40,920
to answer this question we present a

1215
00:58:40,920 --> 00:58:43,500
framework to automatically finding the

1216
00:58:43,500 --> 00:58:46,020
best attacking parameters and the

1217
00:58:46,020 --> 00:58:48,480
minimal time complexities as a

1218
00:58:48,480 --> 00:58:50,000
complement

1219
00:58:50,000 --> 00:58:54,180
the automatic framework takes related

1220
00:58:54,180 --> 00:58:57,299
parameters on Boomer our Boomerang or

1221
00:58:57,299 --> 00:59:00,780
rectangle distinguisher and extended key

1222
00:59:00,780 --> 00:59:03,359
recovery runs as input

1223
00:59:03,359 --> 00:59:07,980
and returns KB Prime KF Prime and the

1224
00:59:07,980 --> 00:59:11,339
minimum time complexity

1225
00:59:11,339 --> 00:59:16,020
in essence this is an optimization

1226
00:59:16,020 --> 00:59:19,500
problem when it comes to a specific

1227
00:59:19,500 --> 00:59:23,700
server one can instantiate it and solve

1228
00:59:23,700 --> 00:59:29,839
it with MLP servers or set source

1229
00:59:32,520 --> 00:59:36,299
our framework is a modular and we

1230
00:59:36,299 --> 00:59:39,540
describe it as a as a template

1231
00:59:39,540 --> 00:59:41,520
the first module is difference

1232
00:59:41,520 --> 00:59:44,339
propagation we model the differentials

1233
00:59:44,339 --> 00:59:47,339
and compute RB and RF

1234
00:59:47,339 --> 00:59:50,339
the when your True Value Pass

1235
00:59:50,339 --> 00:59:53,460
marks the state sales will value are

1236
00:59:53,460 --> 00:59:55,740
needed and compute the

1237
00:59:55,740 --> 00:59:59,640
sub key involved in EB and EF

1238
00:59:59,640 --> 01:00:03,059
in gas and determine model the relation

1239
01:00:03,059 --> 01:00:06,180
between the sub capits and the internal

1240
01:00:06,180 --> 01:00:07,500
state sales

1241
01:00:07,500 --> 01:00:12,079
that is to say model the filters

1242
01:00:12,920 --> 01:00:15,420
considering Cape region

1243
01:00:15,420 --> 01:00:18,720
where models the relation between sub

1244
01:00:18,720 --> 01:00:21,359
capits according to the case schedule

1245
01:00:21,359 --> 01:00:24,420
algorithm and compute the number of

1246
01:00:24,420 --> 01:00:27,720
independent guest sub-key bits

1247
01:00:27,720 --> 01:00:31,920
last we compute the term complexity and

1248
01:00:31,920 --> 01:00:34,740
set the objective function to minimize

1249
01:00:34,740 --> 01:00:39,180
the overall term complexity

1250
01:00:39,180 --> 01:00:41,819
combining the algorithm and the

1251
01:00:41,819 --> 01:00:44,579
framework we are able to find the most

1252
01:00:44,579 --> 01:00:49,819
efficient rectangle K recovery attack

1253
01:00:56,880 --> 01:01:00,420
or our new algorithm unifies all the

1254
01:01:00,420 --> 01:01:02,940
previous rectangle key recovery

1255
01:01:02,940 --> 01:01:06,960
algorithms that is to see any of the

1256
01:01:06,960 --> 01:01:10,079
previous four algorithms is a special

1257
01:01:10,079 --> 01:01:14,280
case of our algorithm by replacing the

1258
01:01:14,280 --> 01:01:17,220
corresponding parameters the exact

1259
01:01:17,220 --> 01:01:20,280
number of guest sub key bits and the

1260
01:01:20,280 --> 01:01:23,640
number of reloaded filters in our

1261
01:01:23,640 --> 01:01:27,540
formula of complexity our algorithm can

1262
01:01:27,540 --> 01:01:30,059
be converted into corresponding special

1263
01:01:30,059 --> 01:01:32,339
cases

1264
01:01:32,339 --> 01:01:37,079
favor or rectangle distinguisher one can

1265
01:01:37,079 --> 01:01:39,960
compute the complexities for different

1266
01:01:39,960 --> 01:01:43,500
algorithms and pick the one with the

1267
01:01:43,500 --> 01:01:47,760
lowest complexity but with our algorithm

1268
01:01:47,760 --> 01:01:52,339
we can work with this one only

1269
01:01:53,400 --> 01:01:56,700
the best parameters to minimize the term

1270
01:01:56,700 --> 01:01:59,400
complexity May lie outside the four

1271
01:01:59,400 --> 01:02:04,020
previous cases and we find that the best

1272
01:02:04,020 --> 01:02:05,900
attacking parameters differ

1273
01:02:05,900 --> 01:02:09,119
significantly from this which were used

1274
01:02:09,119 --> 01:02:12,599
in previous Works including the setting

1275
01:02:12,599 --> 01:02:16,200
for MB Prime and MF Prime

1276
01:02:16,200 --> 01:02:19,920
the set of constructing Pairs and even

1277
01:02:19,920 --> 01:02:23,099
the number of rounds added around the

1278
01:02:23,099 --> 01:02:24,540
distinguisher

1279
01:02:24,540 --> 01:02:28,079
it is likely that previous rectangle

1280
01:02:28,079 --> 01:02:31,020
attacks can be improved to some extent

1281
01:02:31,020 --> 01:02:36,980
using our new key recovery algorithm

1282
01:02:39,660 --> 01:02:42,420
and then to demonstrate the efficiency

1283
01:02:42,420 --> 01:02:46,020
of our new key recovery algorithm we

1284
01:02:46,020 --> 01:02:48,839
apply it to four block servers using

1285
01:02:48,839 --> 01:02:50,880
existing distinguishers

1286
01:02:50,880 --> 01:02:54,059
we give better attacks on turn around

1287
01:02:54,059 --> 01:02:57,540
serpent improve some of the best attacks

1288
01:02:57,540 --> 01:03:01,260
for skinny in previous Works extend the

1289
01:03:01,260 --> 01:03:05,040
rectangle attack on Craft by one round

1290
01:03:05,040 --> 01:03:08,700
and give the first 19 round attack

1291
01:03:08,700 --> 01:03:09,900
and

1292
01:03:09,900 --> 01:03:13,740
and we improve the 11 round rectangle

1293
01:03:13,740 --> 01:03:15,960
attack and the extends the boomerang

1294
01:03:15,960 --> 01:03:18,359
Attack by One round in the related

1295
01:03:18,359 --> 01:03:21,359
ticket setting for Deoxys

1296
01:03:21,359 --> 01:03:24,059
our results are summarized in the table

1297
01:03:24,059 --> 01:03:26,700
and the results of this work are

1298
01:03:26,700 --> 01:03:29,779
highlighted in the table

1299
01:03:32,160 --> 01:03:35,280
in addition to the aforementioned works

1300
01:03:35,280 --> 01:03:37,859
we developed several variants of the new

1301
01:03:37,859 --> 01:03:40,260
key recovery algorithm for related

1302
01:03:40,260 --> 01:03:45,000
attacks 4 case RB equals and which is

1303
01:03:45,000 --> 01:03:47,400
the way of choosing plane test

1304
01:03:47,400 --> 01:03:51,960
and our algorithm can easily adapt it to

1305
01:03:51,960 --> 01:03:54,599
the related case setting for surface

1306
01:03:54,599 --> 01:03:57,859
with a linear key schedule

1307
01:03:57,859 --> 01:04:01,920
considering funeral attack we specially

1308
01:04:01,920 --> 01:04:04,799
proposed variants of the key recovery

1309
01:04:04,799 --> 01:04:07,799
for the case extending rocks in only one

1310
01:04:07,799 --> 01:04:10,040
set

1311
01:04:12,480 --> 01:04:16,260
in conclusion in our work we propose a

1312
01:04:16,260 --> 01:04:18,900
unified and generic rectangle key

1313
01:04:18,900 --> 01:04:22,200
recovery algorithm it can support any

1314
01:04:22,200 --> 01:04:25,140
number of guest key bits covering four

1315
01:04:25,140 --> 01:04:28,559
previous algorithms and unveiling file

1316
01:04:28,559 --> 01:04:31,980
types of new algorithms as a complement

1317
01:04:31,980 --> 01:04:35,280
we present a framework for automatically

1318
01:04:35,280 --> 01:04:38,040
finding the best parameters for the new

1319
01:04:38,040 --> 01:04:39,319
algorithm

1320
01:04:39,319 --> 01:04:42,599
besides we apply it to four block

1321
01:04:42,599 --> 01:04:45,780
servers using existing distinguishers

1322
01:04:45,780 --> 01:04:52,220
and obtain a series of improved results

1323
01:04:53,099 --> 01:04:57,200
that's all thank you for listening

1324
01:04:59,040 --> 01:05:01,140
thank you

1325
01:05:01,140 --> 01:05:04,339
education please

1326
01:05:04,799 --> 01:05:09,319
okay over there so can you hand it

1327
01:05:11,400 --> 01:05:14,520
thank you for your presentation I have

1328
01:05:14,520 --> 01:05:18,599
one question by any chance or

1329
01:05:18,599 --> 01:05:23,220
this uh this framework uh can this

1330
01:05:23,220 --> 01:05:26,579
framework uh be applied to key recovery

1331
01:05:26,579 --> 01:05:29,280
of literacy in women over Tech uh

1332
01:05:29,280 --> 01:05:34,200
proposed bureaucrated to 2020.

1333
01:05:34,380 --> 01:05:38,460
because uh in the case of reiteration

1334
01:05:38,460 --> 01:05:41,220
familiarity there is a specific uh

1335
01:05:41,220 --> 01:05:45,480
returning of returning process so I just

1336
01:05:45,480 --> 01:05:47,660
wonder

1337
01:05:48,180 --> 01:05:52,619
sorry came apparent pieces the question

1338
01:05:52,619 --> 01:05:57,000
here is can you Opera your assault to

1339
01:05:57,000 --> 01:06:00,660
the euro crypto 2022 paper

1340
01:06:00,660 --> 01:06:05,520
to key recovery attack alliteration

1341
01:06:06,000 --> 01:06:09,180
can this framework be applied to a

1342
01:06:09,180 --> 01:06:12,440
literacy metal attack

1343
01:06:13,380 --> 01:06:15,180
and to what

1344
01:06:15,180 --> 01:06:18,180
reiteration

1345
01:06:19,460 --> 01:06:21,920
attack something like that right

1346
01:06:21,920 --> 01:06:25,920
literacing deterioration

1347
01:06:27,000 --> 01:06:30,240
you have never heard about that I was

1348
01:06:30,240 --> 01:06:32,640
chasing Puma

1349
01:06:32,640 --> 01:06:35,240
yes

1350
01:06:35,700 --> 01:06:38,099
uh wait wait

1351
01:06:38,099 --> 01:06:41,220
and thanks for a question we are not

1352
01:06:41,220 --> 01:06:42,420
on

1353
01:06:42,420 --> 01:06:43,920
uh

1354
01:06:43,920 --> 01:06:47,099
we are doing this work and that's the

1355
01:06:47,099 --> 01:06:51,359
but this work was not included in this

1356
01:06:51,359 --> 01:06:52,380
paper

1357
01:06:52,380 --> 01:06:56,339
okay okay thank you any other

1358
01:06:56,339 --> 01:06:59,180
foreign

1359
01:07:00,900 --> 01:07:02,339
okay

1360
01:07:02,339 --> 01:07:04,619
so your vessel

1361
01:07:04,619 --> 01:07:09,740
improved previous poor algorithm right

1362
01:07:12,420 --> 01:07:15,980
you you your idea

1363
01:07:16,500 --> 01:07:20,700
improved for previous algorithm I'll go

1364
01:07:20,700 --> 01:07:23,280
to the one through three four

1365
01:07:23,280 --> 01:07:24,720
yes right

1366
01:07:24,720 --> 01:07:27,020
yes

1367
01:07:27,240 --> 01:07:30,660
you're in your presentation

1368
01:07:30,660 --> 01:07:33,420
you mentioned that

1369
01:07:33,420 --> 01:07:36,480
if previous attack

1370
01:07:36,480 --> 01:07:39,140
can be improved

1371
01:07:39,140 --> 01:07:41,640
combining your attack

1372
01:07:41,640 --> 01:07:44,220
some extent

1373
01:07:44,220 --> 01:07:47,240
so each algorithm mostly

1374
01:07:47,240 --> 01:07:48,900
improved

1375
01:07:48,900 --> 01:07:52,559
by you by using your method

1376
01:07:52,559 --> 01:07:55,760
one two three four

1377
01:08:02,760 --> 01:08:05,280
can you hear me Nana

1378
01:08:05,280 --> 01:08:09,539
so sorry I okay it seems difficult to

1379
01:08:09,539 --> 01:08:12,359
understand anyway so if there's location

1380
01:08:12,359 --> 01:08:16,080
let me conclude this session okay so

1381
01:08:16,080 --> 01:08:19,679
okay okay thanks speakers and questions

1382
01:08:19,679 --> 01:08:22,198
thank you

1383
01:08:22,198 --> 01:08:25,399
we can take a break

1384
01:08:25,620 --> 01:08:29,000
okay thank you

