1
00:00:00,000 --> 00:00:02,340
so my name is Maxwell

2
00:00:02,340 --> 00:00:03,120
um

3
00:00:03,120 --> 00:00:05,520
I have the pleasure to to share this

4
00:00:05,520 --> 00:00:07,140
session so this is the first one on

5
00:00:07,140 --> 00:00:10,019
practical cryptography uh there will be

6
00:00:10,019 --> 00:00:11,880
three talks in this session and the

7
00:00:11,880 --> 00:00:14,639
first one is on some preserving

8
00:00:14,639 --> 00:00:16,859
encryption and two could be given by by

9
00:00:16,859 --> 00:00:20,880
Sarah I see online sorry can you hear us

10
00:00:20,880 --> 00:00:23,640
yes I can perfect so you can start

11
00:00:23,640 --> 00:00:25,680
whenever you want all right well thank

12
00:00:25,680 --> 00:00:28,080
you so welcome everyone

13
00:00:28,080 --> 00:00:29,460
um so I'm going to talk about new

14
00:00:29,460 --> 00:00:31,439
algorithms and Analysis for some

15
00:00:31,439 --> 00:00:33,899
preserving encryption and this is Joint

16
00:00:33,899 --> 00:00:35,760
work with Scott yellick

17
00:00:35,760 --> 00:00:37,920
uh so I'm going to start by introducing

18
00:00:37,920 --> 00:00:39,300
the problem of some preserving

19
00:00:39,300 --> 00:00:40,500
encryption

20
00:00:40,500 --> 00:00:41,700
um so the idea is we're going to create

21
00:00:41,700 --> 00:00:43,020
an encryption scheme where the

22
00:00:43,020 --> 00:00:45,300
ciphertext and plain texts are both

23
00:00:45,300 --> 00:00:47,040
going to be integer vectors and they're

24
00:00:47,040 --> 00:00:49,200
going to have the same sum so if we sum

25
00:00:49,200 --> 00:00:51,180
up all the points in the vector for the

26
00:00:51,180 --> 00:00:54,000
plain text and the cipher text they're

27
00:00:54,000 --> 00:00:56,280
both going to have the same sum in

28
00:00:56,280 --> 00:00:58,860
addition each of the components of the

29
00:00:58,860 --> 00:01:00,660
vector are typically going to be bounded

30
00:01:00,660 --> 00:01:04,860
between 0 and some maximum of D and this

31
00:01:04,860 --> 00:01:06,900
problem was introduced by tajik at all

32
00:01:06,900 --> 00:01:11,100
in 2019 and they looked at a particular

33
00:01:11,100 --> 00:01:13,799
application of some preserving

34
00:01:13,799 --> 00:01:16,619
encryption specifically thumbnail

35
00:01:16,619 --> 00:01:19,560
preserving encryption so the idea is you

36
00:01:19,560 --> 00:01:21,960
want to create a encryption scheme where

37
00:01:21,960 --> 00:01:25,259
the thumbnail of the original image and

38
00:01:25,259 --> 00:01:27,900
the encrypted image are the same so

39
00:01:27,900 --> 00:01:30,060
we'll create that just to go over we

40
00:01:30,060 --> 00:01:32,640
create the thumbnail by dividing an

41
00:01:32,640 --> 00:01:35,700
image into B by B blocks of pixels and

42
00:01:35,700 --> 00:01:37,740
then we're going to replace each block

43
00:01:37,740 --> 00:01:40,320
by the mean pixel values the average of

44
00:01:40,320 --> 00:01:42,180
all the pixel values within the block to

45
00:01:42,180 --> 00:01:45,180
create a smaller image so if we take

46
00:01:45,180 --> 00:01:47,880
each each of these same blocks and we

47
00:01:47,880 --> 00:01:50,640
apply some preserving encryption to the

48
00:01:50,640 --> 00:01:55,860
blocks then the sum of the pixels in the

49
00:01:55,860 --> 00:01:57,720
original image and the encrypted image

50
00:01:57,720 --> 00:02:00,119
will be the same thus the amino be the

51
00:02:00,119 --> 00:02:03,119
same and we've preserved the thumbnail

52
00:02:03,119 --> 00:02:04,860
between the original image and the

53
00:02:04,860 --> 00:02:07,640
encrypted image

54
00:02:07,740 --> 00:02:09,598
all right so I'm going to give a little

55
00:02:09,598 --> 00:02:11,280
background on this problem and and then

56
00:02:11,280 --> 00:02:14,340
discuss our new algorithms uh so you can

57
00:02:14,340 --> 00:02:16,200
think of some preserving encryption as

58
00:02:16,200 --> 00:02:18,360
it's a special type of format preserving

59
00:02:18,360 --> 00:02:20,940
encryption and there's been a lot of

60
00:02:20,940 --> 00:02:23,400
work on format preserving encryption it

61
00:02:23,400 --> 00:02:25,680
was originally studied by Brightwell and

62
00:02:25,680 --> 00:02:28,800
Smith in 97.

63
00:02:28,800 --> 00:02:31,560
uh it was formally defined and analyzed

64
00:02:31,560 --> 00:02:34,260
by Bellaire uh riston part Rockaway and

65
00:02:34,260 --> 00:02:37,440
speakers and 09 and they used a rank and

66
00:02:37,440 --> 00:02:40,440
Cipher unrank construction which I'll

67
00:02:40,440 --> 00:02:42,599
talk about uh further examples of that

68
00:02:42,599 --> 00:02:43,920
here today

69
00:02:43,920 --> 00:02:46,500
and again it's widely studied uh and

70
00:02:46,500 --> 00:02:48,060
even standardized

71
00:02:48,060 --> 00:02:50,640
so to Jake at all introduced

72
00:02:50,640 --> 00:02:52,620
um this idea of some preserving

73
00:02:52,620 --> 00:02:54,540
encryption as I said before and they

74
00:02:54,540 --> 00:02:56,280
focused on the problem of creating a

75
00:02:56,280 --> 00:02:58,620
thumbnail encryption scheme

76
00:02:58,620 --> 00:03:01,260
okay so I I mentioned that this idea of

77
00:03:01,260 --> 00:03:02,819
rank and Cipher unrank is going to be

78
00:03:02,819 --> 00:03:04,560
important so let me just uh review that

79
00:03:04,560 --> 00:03:06,900
real quickly in case you haven't seen it

80
00:03:06,900 --> 00:03:08,760
um so the idea is we're going to start

81
00:03:08,760 --> 00:03:11,159
with a plain text then we're going to

82
00:03:11,159 --> 00:03:13,440
apply a rank algorithm so we're going to

83
00:03:13,440 --> 00:03:17,099
rank each possible plain text between 0

84
00:03:17,099 --> 00:03:19,800
and N minus one where n is going to be

85
00:03:19,800 --> 00:03:22,140
the total number of possible plain texts

86
00:03:22,140 --> 00:03:25,319
so we first start by ranking it then we

87
00:03:25,319 --> 00:03:27,300
have an integer and we can apply a

88
00:03:27,300 --> 00:03:29,640
standard Cipher to get another integer

89
00:03:29,640 --> 00:03:32,159
right this is our encrypted integer and

90
00:03:32,159 --> 00:03:34,680
then we apply an unranked algorithm to

91
00:03:34,680 --> 00:03:37,140
get back to a ciphertext and this is a

92
00:03:37,140 --> 00:03:38,700
standard technique in format preserving

93
00:03:38,700 --> 00:03:40,400
encryption

94
00:03:40,400 --> 00:03:43,739
so did you get all um realize that we

95
00:03:43,739 --> 00:03:46,319
could use this approach um in for the

96
00:03:46,319 --> 00:03:48,299
problem of some preserving encryption um

97
00:03:48,299 --> 00:03:50,819
and so they proposed um this idea of

98
00:03:50,819 --> 00:03:52,680
representing a string

99
00:03:52,680 --> 00:03:55,019
um or sorry representing a vector as a

100
00:03:55,019 --> 00:03:57,000
string of ones and zeros so this is the

101
00:03:57,000 --> 00:03:59,220
stars and bars construction from

102
00:03:59,220 --> 00:04:01,920
combinatorics if you've seen that before

103
00:04:01,920 --> 00:04:05,280
um so we're basically going to uh for if

104
00:04:05,280 --> 00:04:07,019
let's say look at our example the first

105
00:04:07,019 --> 00:04:08,459
number is five we're going to replace

106
00:04:08,459 --> 00:04:10,860
that with five ones and then a zero so

107
00:04:10,860 --> 00:04:12,360
the zeros are going to serve as our

108
00:04:12,360 --> 00:04:13,560
separators

109
00:04:13,560 --> 00:04:15,540
um so we'll have one less zero than

110
00:04:15,540 --> 00:04:18,238
there are points in our vector

111
00:04:18,238 --> 00:04:19,380
um and then our second number is three

112
00:04:19,380 --> 00:04:21,478
we would have three ones followed by our

113
00:04:21,478 --> 00:04:23,880
separator and then our final one

114
00:04:23,880 --> 00:04:26,580
um so if we uh represent our vectors of

115
00:04:26,580 --> 00:04:29,160
integers um as binary strings in this

116
00:04:29,160 --> 00:04:30,120
fashion

117
00:04:30,120 --> 00:04:31,979
um then this is a regular language and

118
00:04:31,979 --> 00:04:34,320
there's some known techniques we can use

119
00:04:34,320 --> 00:04:36,540
um to to turn this into an encryption

120
00:04:36,540 --> 00:04:38,280
scheme however

121
00:04:38,280 --> 00:04:41,520
um this uh has high time complexity and

122
00:04:41,520 --> 00:04:43,560
it's it's relatively impractical in this

123
00:04:43,560 --> 00:04:44,820
situation

124
00:04:44,820 --> 00:04:48,419
however uh tiju got all realized that if

125
00:04:48,419 --> 00:04:50,040
we do this with just vectors that have

126
00:04:50,040 --> 00:04:52,620
two points so if we just have a link two

127
00:04:52,620 --> 00:04:54,360
then this is pretty straightforward and

128
00:04:54,360 --> 00:04:55,860
you know if you've got some downtime

129
00:04:55,860 --> 00:04:57,720
during the next break between talks you

130
00:04:57,720 --> 00:05:00,000
could work out how we could rank uh

131
00:05:00,000 --> 00:05:02,220
vectors of length two and with a fixed

132
00:05:02,220 --> 00:05:03,060
sum

133
00:05:03,060 --> 00:05:05,460
uh and so they use this idea to create

134
00:05:05,460 --> 00:05:07,979
as some preserving encryption scheme

135
00:05:07,979 --> 00:05:10,560
and it actually can be thought of as a

136
00:05:10,560 --> 00:05:12,000
Markov chain and so I'm going to talk a

137
00:05:12,000 --> 00:05:13,500
little bit more about it from the Markov

138
00:05:13,500 --> 00:05:15,180
chain perspective in a little bit so I'm

139
00:05:15,180 --> 00:05:16,860
going to present their algorithm

140
00:05:16,860 --> 00:05:19,199
um not exactly how they presented it but

141
00:05:19,199 --> 00:05:21,360
um as a Markov chain which they they did

142
00:05:21,360 --> 00:05:23,580
realize they did um point out that this

143
00:05:23,580 --> 00:05:26,100
is a Markov chain so the idea is they're

144
00:05:26,100 --> 00:05:27,840
going to repeat this algorithm in

145
00:05:27,840 --> 00:05:29,580
multiple rounds so they're going to

146
00:05:29,580 --> 00:05:31,139
start again you're starting

147
00:05:31,139 --> 00:05:33,539
from the vector of integers and they're

148
00:05:33,539 --> 00:05:35,520
going to randomly Shuffle Shuffle those

149
00:05:35,520 --> 00:05:37,320
points all right so you randomly Shuffle

150
00:05:37,320 --> 00:05:40,020
the points and then we're going to pair

151
00:05:40,020 --> 00:05:42,180
adjacent points to get a perfect

152
00:05:42,180 --> 00:05:45,300
matching all right randomly shuffled

153
00:05:45,300 --> 00:05:47,280
pair adjacent points to get a perfect

154
00:05:47,280 --> 00:05:50,340
matching and then now within our

155
00:05:50,340 --> 00:05:52,199
matching we have pairs of points and we

156
00:05:52,199 --> 00:05:53,880
just I just mentioned that we could rank

157
00:05:53,880 --> 00:05:57,120
in Cipher unrank these points and so

158
00:05:57,120 --> 00:05:58,860
we're going to replace

159
00:05:58,860 --> 00:06:00,539
um using this Rank and Cipher unrank

160
00:06:00,539 --> 00:06:01,860
approach we're going to replace each

161
00:06:01,860 --> 00:06:04,919
pair of integers uniformly at random

162
00:06:04,919 --> 00:06:07,020
from all the possible valid choices

163
00:06:07,020 --> 00:06:10,139
right so we have to preserve the sum and

164
00:06:10,139 --> 00:06:12,000
we have to preserve that component bound

165
00:06:12,000 --> 00:06:13,680
all right so for each pair in our

166
00:06:13,680 --> 00:06:16,020
matching we're going to replace

167
00:06:16,020 --> 00:06:18,180
uniformly at random

168
00:06:18,180 --> 00:06:20,820
um from the possible choices and then we

169
00:06:20,820 --> 00:06:23,220
get another Vector that's going to have

170
00:06:23,220 --> 00:06:25,440
the same sum and respect those component

171
00:06:25,440 --> 00:06:27,860
bounds

172
00:06:28,020 --> 00:06:29,520
all right so so

173
00:06:29,520 --> 00:06:30,300
um

174
00:06:30,300 --> 00:06:32,280
today our results

175
00:06:32,280 --> 00:06:34,979
um we give the first proof bounding the

176
00:06:34,979 --> 00:06:36,660
mixing time of the tajik add-all

177
00:06:36,660 --> 00:06:37,860
algorithm

178
00:06:37,860 --> 00:06:39,720
um so you know the natural question you

179
00:06:39,720 --> 00:06:41,460
might ask uh when presented with an

180
00:06:41,460 --> 00:06:42,960
algorithm like this is how many rounds

181
00:06:42,960 --> 00:06:44,460
is sufficient right how many times do we

182
00:06:44,460 --> 00:06:45,960
have to repeat this

183
00:06:45,960 --> 00:06:47,340
um so we're going to we give the first

184
00:06:47,340 --> 00:06:49,800
formal bound on the mixing time and in

185
00:06:49,800 --> 00:06:52,680
addition we give two uh practical Rank

186
00:06:52,680 --> 00:06:54,419
and unranked algorithms that we can use

187
00:06:54,419 --> 00:06:56,460
for some preserving encryption

188
00:06:56,460 --> 00:06:58,380
and we also create prototype

189
00:06:58,380 --> 00:07:00,979
implementations uh with performance

190
00:07:00,979 --> 00:07:02,940
comparisons comparing these three

191
00:07:02,940 --> 00:07:05,400
different algorithms all right so so in

192
00:07:05,400 --> 00:07:07,259
the rest of my talk today I'm going to

193
00:07:07,259 --> 00:07:09,479
go over briefly our mixing time bound

194
00:07:09,479 --> 00:07:11,400
and some of the proof techniques behind

195
00:07:11,400 --> 00:07:14,160
it and then I'll present uh the two rank

196
00:07:14,160 --> 00:07:15,660
um well I'll describe at a high level

197
00:07:15,660 --> 00:07:18,240
the rank and unrank algorithms and then

198
00:07:18,240 --> 00:07:20,460
show you briefly the uh performance

199
00:07:20,460 --> 00:07:22,860
comparisons

200
00:07:22,860 --> 00:07:24,840
okay um so we're going to ask this

201
00:07:24,840 --> 00:07:26,759
question for for the mixing time bound

202
00:07:26,759 --> 00:07:28,380
of how many times do we need to repeat

203
00:07:28,380 --> 00:07:30,300
this algorithm

204
00:07:30,300 --> 00:07:32,460
um and I'll give a heuristic algorithms

205
00:07:32,460 --> 00:07:34,919
for what secure um choices round choices

206
00:07:34,919 --> 00:07:36,720
would be uh but no formal proof and so

207
00:07:36,720 --> 00:07:38,099
that's what I what I'm going to present

208
00:07:38,099 --> 00:07:38,880
today

209
00:07:38,880 --> 00:07:40,500
um and they tested performance with a

210
00:07:40,500 --> 00:07:41,880
thousand three thousand and five

211
00:07:41,880 --> 00:07:43,620
thousand rounds

212
00:07:43,620 --> 00:07:46,319
uh just to formalize I'm going to talk

213
00:07:46,319 --> 00:07:48,000
about the mixing time

214
00:07:48,000 --> 00:07:50,160
um and here the mixing time is going to

215
00:07:50,160 --> 00:07:51,300
be

216
00:07:51,300 --> 00:07:53,460
um the amount of time until the

217
00:07:53,460 --> 00:07:55,259
difference between the distribution at

218
00:07:55,259 --> 00:07:57,240
time T and the stationary distribution

219
00:07:57,240 --> 00:07:59,580
is less than Epsilon all right so we're

220
00:07:59,580 --> 00:08:02,479
going to parameterize this by Epsilon

221
00:08:02,479 --> 00:08:05,160
all right um and we show that if n is

222
00:08:05,160 --> 00:08:06,840
the vector length D is the component

223
00:08:06,840 --> 00:08:09,240
bound and S is the fixed sum then the

224
00:08:09,240 --> 00:08:10,319
mixing time

225
00:08:10,319 --> 00:08:13,020
um is upper bounded by n log of the

226
00:08:13,020 --> 00:08:16,860
minimum of DN 2s and one over Epsilon

227
00:08:16,860 --> 00:08:19,020
all right so how do we do this well

228
00:08:19,020 --> 00:08:20,940
we're going to use a half cup we use a

229
00:08:20,940 --> 00:08:23,340
path coupling technique due to Dyer and

230
00:08:23,340 --> 00:08:25,919
green hill and 98 and this is a standard

231
00:08:25,919 --> 00:08:29,039
technique in the Markov chain community

232
00:08:29,039 --> 00:08:30,960
so before I I'm going to kind of give

233
00:08:30,960 --> 00:08:32,700
you a high level

234
00:08:32,700 --> 00:08:35,099
um view of what the proof looks like and

235
00:08:35,099 --> 00:08:36,659
before I jump into that though let me

236
00:08:36,659 --> 00:08:37,919
just kind of tell you a little bit about

237
00:08:37,919 --> 00:08:40,020
the techniques that we use um I know I'm

238
00:08:40,020 --> 00:08:41,940
sure not everyone's familiar with them

239
00:08:41,940 --> 00:08:45,180
um so we we use path coupling which kind

240
00:08:45,180 --> 00:08:47,100
of followed on to coupling so the idea

241
00:08:47,100 --> 00:08:49,620
of coupling is we're going to simulate

242
00:08:49,620 --> 00:08:51,899
um two processes X and Y and each of

243
00:08:51,899 --> 00:08:54,600
them if we view it in isolation it looks

244
00:08:54,600 --> 00:08:57,060
just like that Markov chain

245
00:08:57,060 --> 00:08:58,320
um and so we're going to simulate these

246
00:08:58,320 --> 00:09:00,180
processes until they agree and once they

247
00:09:00,180 --> 00:09:03,480
agree they stay together and it turns

248
00:09:03,480 --> 00:09:04,140
out

249
00:09:04,140 --> 00:09:06,959
um if we can bound

250
00:09:06,959 --> 00:09:09,420
um if we can bound how long it takes

251
00:09:09,420 --> 00:09:10,800
before

252
00:09:10,800 --> 00:09:12,300
um these processes agree this is called

253
00:09:12,300 --> 00:09:13,740
the coupling time

254
00:09:13,740 --> 00:09:15,720
um and this will give us a bound on the

255
00:09:15,720 --> 00:09:17,100
mixing time so we can use the coupling

256
00:09:17,100 --> 00:09:19,500
time to bound the mixing time

257
00:09:19,500 --> 00:09:22,080
and how we do this is we generally show

258
00:09:22,080 --> 00:09:24,660
that at each step of the Markov chain

259
00:09:24,660 --> 00:09:27,420
the distance between the two chains is

260
00:09:27,420 --> 00:09:29,160
getting closer in expectation so the

261
00:09:29,160 --> 00:09:31,200
expected distance between the two chains

262
00:09:31,200 --> 00:09:33,839
X and Y is decreasing

263
00:09:33,839 --> 00:09:35,880
um and here um we're going to use the

264
00:09:35,880 --> 00:09:38,779
Manhattan distance

265
00:09:39,839 --> 00:09:41,519
all right so in coupling again we want

266
00:09:41,519 --> 00:09:42,959
to show that the expected change over

267
00:09:42,959 --> 00:09:45,360
one step um from any arbitrary pair of

268
00:09:45,360 --> 00:09:47,100
configurations so we have to we have to

269
00:09:47,100 --> 00:09:48,600
show that this happens for any two

270
00:09:48,600 --> 00:09:50,279
configurations in our state space any

271
00:09:50,279 --> 00:09:53,839
two possible you know vectors

272
00:09:53,940 --> 00:09:55,560
um path coupling makes this process a

273
00:09:55,560 --> 00:09:58,800
lot easier because we can just look at a

274
00:09:58,800 --> 00:10:00,660
restricted set of pairs of

275
00:10:00,660 --> 00:10:02,279
configurations all right so we don't

276
00:10:02,279 --> 00:10:03,660
have to look at all pairs we can just

277
00:10:03,660 --> 00:10:06,120
look at a subset and in this particular

278
00:10:06,120 --> 00:10:07,620
case we're going to choose to only look

279
00:10:07,620 --> 00:10:10,080
at pairs that differ on exactly two

280
00:10:10,080 --> 00:10:12,000
points so every single other pair in the

281
00:10:12,000 --> 00:10:14,820
vector is this every single you know X

282
00:10:14,820 --> 00:10:16,680
and Y match on every single other point

283
00:10:16,680 --> 00:10:18,959
except for Just Two

284
00:10:18,959 --> 00:10:20,399
um and so we only have to look at these

285
00:10:20,399 --> 00:10:22,440
special vectors that only differ on

286
00:10:22,440 --> 00:10:24,060
these two points

287
00:10:24,060 --> 00:10:25,560
uh and just to kind of give you an idea

288
00:10:25,560 --> 00:10:28,440
why this works um if we can um we show

289
00:10:28,440 --> 00:10:30,540
that you can find between any arbitrary

290
00:10:30,540 --> 00:10:32,399
pairs of configurations you can find

291
00:10:32,399 --> 00:10:34,080
Paris

292
00:10:34,080 --> 00:10:35,339
um that are in this special set right

293
00:10:35,339 --> 00:10:38,220
that only differ on two points uh and so

294
00:10:38,220 --> 00:10:39,959
the expected change in distance between

295
00:10:39,959 --> 00:10:42,300
any two arbitrary configurations is

296
00:10:42,300 --> 00:10:44,220
bounded by the sum of the expected

297
00:10:44,220 --> 00:10:46,260
changes between those special Pairs and

298
00:10:46,260 --> 00:10:48,300
so we can use those to get a bound

299
00:10:48,300 --> 00:10:51,420
um to get to get our bound overall

300
00:10:51,420 --> 00:10:53,399
okay so so just to give you an idea how

301
00:10:53,399 --> 00:10:54,959
this works um so again we're using the

302
00:10:54,959 --> 00:10:57,000
Manhattan distance uh and we're looking

303
00:10:57,000 --> 00:10:58,980
at vectors that just differ on two

304
00:10:58,980 --> 00:11:01,560
points so um right so here there's again

305
00:11:01,560 --> 00:11:03,839
X and Y agree on every everything else

306
00:11:03,839 --> 00:11:06,180
except for these two special points and

307
00:11:06,180 --> 00:11:08,579
we want to show that after a single step

308
00:11:08,579 --> 00:11:10,620
of the Markov chain the expected change

309
00:11:10,620 --> 00:11:12,300
in distance is going to right the

310
00:11:12,300 --> 00:11:15,180
distance is going to decrease

311
00:11:15,180 --> 00:11:18,360
all right so so just to remember our

312
00:11:18,360 --> 00:11:20,220
Markov chain right it starts by randomly

313
00:11:20,220 --> 00:11:22,440
randomly shuffling the points um and

314
00:11:22,440 --> 00:11:25,019
then it pairs adjacent points so if

315
00:11:25,019 --> 00:11:27,300
after our random shuffling if these two

316
00:11:27,300 --> 00:11:29,399
points that differ if these happen to be

317
00:11:29,399 --> 00:11:30,480
adjacent

318
00:11:30,480 --> 00:11:32,040
right

319
00:11:32,040 --> 00:11:34,800
um then uh we our distance decreases to

320
00:11:34,800 --> 00:11:37,860
zero right that we can choose the same

321
00:11:37,860 --> 00:11:40,140
um pairs of new pairs of points in each

322
00:11:40,140 --> 00:11:42,480
of our chain X and Y and the distance

323
00:11:42,480 --> 00:11:44,040
decreases to zero so this is the good

324
00:11:44,040 --> 00:11:45,360
case right this is this is going to

325
00:11:45,360 --> 00:11:46,620
solve everything

326
00:11:46,620 --> 00:11:48,660
the downside though is that if these

327
00:11:48,660 --> 00:11:50,760
pairs of points right if these match

328
00:11:50,760 --> 00:11:52,260
with other

329
00:11:52,260 --> 00:11:53,820
points

330
00:11:53,820 --> 00:11:56,220
um then it's much trickier and one of

331
00:11:56,220 --> 00:11:57,600
the things that makes this really tricky

332
00:11:57,600 --> 00:11:59,940
is that now if we look at the two chains

333
00:11:59,940 --> 00:12:02,339
X and Y the sums are going to be

334
00:12:02,339 --> 00:12:03,240
different

335
00:12:03,240 --> 00:12:05,940
and so that means that in many cases the

336
00:12:05,940 --> 00:12:07,920
number of possible Right remember we're

337
00:12:07,920 --> 00:12:09,899
choosing uniform formally at random from

338
00:12:09,899 --> 00:12:12,240
all the possible ways to replace these

339
00:12:12,240 --> 00:12:14,220
points and so they're going to have a

340
00:12:14,220 --> 00:12:16,079
different number of choices which means

341
00:12:16,079 --> 00:12:17,040
that we're going to move to the

342
00:12:17,040 --> 00:12:17,820
different

343
00:12:17,820 --> 00:12:19,440
um the different the different choices

344
00:12:19,440 --> 00:12:21,000
with different probabilities in the two

345
00:12:21,000 --> 00:12:23,279
chains it turns out we can still show

346
00:12:23,279 --> 00:12:25,140
that the expected change in distance

347
00:12:25,140 --> 00:12:28,019
that we can come up with a coupling

348
00:12:28,019 --> 00:12:29,339
right so we come up with a coupling and

349
00:12:29,339 --> 00:12:30,420
we show

350
00:12:30,420 --> 00:12:32,100
um that we can all the distance will

351
00:12:32,100 --> 00:12:33,000
always

352
00:12:33,000 --> 00:12:35,579
um stay the same or decrease but it's

353
00:12:35,579 --> 00:12:36,720
quite tricky and there's a lot of

354
00:12:36,720 --> 00:12:38,220
details that I'm hiding so I'm not going

355
00:12:38,220 --> 00:12:39,420
to go into those details but that that's

356
00:12:39,420 --> 00:12:40,560
what makes it

357
00:12:40,560 --> 00:12:42,779
interesting I guess or tricky is that

358
00:12:42,779 --> 00:12:44,339
part

359
00:12:44,339 --> 00:12:45,600
um all right

360
00:12:45,600 --> 00:12:47,339
okay so I told you we had kind of two

361
00:12:47,339 --> 00:12:48,839
types of results one was this mixing

362
00:12:48,839 --> 00:12:50,760
time um bound and the other one was the

363
00:12:50,760 --> 00:12:52,500
rank insight for unring

364
00:12:52,500 --> 00:12:54,899
okay so we have two algorithms um for

365
00:12:54,899 --> 00:12:56,339
ranking and unranking and I'm going to

366
00:12:56,339 --> 00:12:57,839
talk about the first one just a little

367
00:12:57,839 --> 00:12:59,459
more quickly because it's not quite as

368
00:12:59,459 --> 00:13:01,260
as um interesting

369
00:13:01,260 --> 00:13:03,600
um so the first uh algorithm for ranking

370
00:13:03,600 --> 00:13:05,459
um is going to rank the vectors uh

371
00:13:05,459 --> 00:13:08,399
directly using lexographical order and

372
00:13:08,399 --> 00:13:10,260
here we're going to build on algorithms

373
00:13:10,260 --> 00:13:11,820
for unranking that were developed by

374
00:13:11,820 --> 00:13:14,639
Stein for use in random sampling so it

375
00:13:14,639 --> 00:13:16,200
was trying to do something different and

376
00:13:16,200 --> 00:13:17,519
he gave an algorithm for unranking

377
00:13:17,519 --> 00:13:19,139
according to lexicographical order and

378
00:13:19,139 --> 00:13:21,959
we came up with added on to that one for

379
00:13:21,959 --> 00:13:23,760
ranking

380
00:13:23,760 --> 00:13:25,980
um the this algorithm is going to rely

381
00:13:25,980 --> 00:13:28,380
uh heavily on a table which we can

382
00:13:28,380 --> 00:13:30,720
pre-compute and that's going to store so

383
00:13:30,720 --> 00:13:32,639
every point in the table and S is going

384
00:13:32,639 --> 00:13:34,380
to store the number of vectors of

385
00:13:34,380 --> 00:13:37,200
LinkedIn with some s and the table all

386
00:13:37,200 --> 00:13:38,760
entries across the table will have the

387
00:13:38,760 --> 00:13:40,380
same component found

388
00:13:40,380 --> 00:13:42,540
and with this pre-computed information

389
00:13:42,540 --> 00:13:44,519
uh we can rank according to

390
00:13:44,519 --> 00:13:46,860
lexographical order and I'll if you're

391
00:13:46,860 --> 00:13:47,940
if you're interested in the details you

392
00:13:47,940 --> 00:13:50,899
can take a look at the paper

393
00:13:51,240 --> 00:13:53,820
um the other ranking algorithm

394
00:13:53,820 --> 00:13:56,339
um is based on what's called we well we

395
00:13:56,339 --> 00:13:58,560
call recursive block order and I as far

396
00:13:58,560 --> 00:14:00,240
as we know this is is not an ordering

397
00:14:00,240 --> 00:14:03,959
that has been been used before and so uh

398
00:14:03,959 --> 00:14:06,000
to describe this order so if you want to

399
00:14:06,000 --> 00:14:07,019
order

400
00:14:07,019 --> 00:14:08,880
um two vectors according to recursive

401
00:14:08,880 --> 00:14:10,620
black order

402
00:14:10,620 --> 00:14:11,700
um you're going to look you're going to

403
00:14:11,700 --> 00:14:13,800
divide the vector in half and you're

404
00:14:13,800 --> 00:14:15,420
going to look at the left sum and the

405
00:14:15,420 --> 00:14:18,600
right sum and if the left sum is smaller

406
00:14:18,600 --> 00:14:20,700
it's going to have smaller it's going to

407
00:14:20,700 --> 00:14:22,680
be smaller in the order

408
00:14:22,680 --> 00:14:24,779
if the left sum is greater it's going to

409
00:14:24,779 --> 00:14:26,880
be later in the order and if they're

410
00:14:26,880 --> 00:14:29,040
equal and this is where the recursive

411
00:14:29,040 --> 00:14:31,260
part comes in if the sum the left sums

412
00:14:31,260 --> 00:14:33,959
are equal well then we're going to we're

413
00:14:33,959 --> 00:14:36,300
going to take a look and work it's how

414
00:14:36,300 --> 00:14:38,459
the vectors relate depends recursively

415
00:14:38,459 --> 00:14:41,639
on how the left half relates to the the

416
00:14:41,639 --> 00:14:43,199
right half according to recursive block

417
00:14:43,199 --> 00:14:45,439
order

418
00:14:47,639 --> 00:14:49,380
all right and so here's an example so

419
00:14:49,380 --> 00:14:50,639
this is different than likes a graphical

420
00:14:50,639 --> 00:14:52,260
order again we're looking at we're going

421
00:14:52,260 --> 00:14:53,459
to split the vector in half and we're

422
00:14:53,459 --> 00:14:55,620
comparing the left sums to see where it

423
00:14:55,620 --> 00:14:57,120
falls and if they're equal then we

424
00:14:57,120 --> 00:14:59,420
repeat

425
00:14:59,639 --> 00:15:01,740
all right if we want to rank according

426
00:15:01,740 --> 00:15:03,420
to recursive block order and I'm going

427
00:15:03,420 --> 00:15:05,579
to go through this a little bit quickly

428
00:15:05,579 --> 00:15:08,100
um but uh so if we want to come up with

429
00:15:08,100 --> 00:15:10,260
a ranking based on this ordering we need

430
00:15:10,260 --> 00:15:12,360
to determine if we have a particular

431
00:15:12,360 --> 00:15:14,279
configuration we need to determine how

432
00:15:14,279 --> 00:15:16,260
many configurations are smaller in the

433
00:15:16,260 --> 00:15:17,279
order

434
00:15:17,279 --> 00:15:18,660
all right

435
00:15:18,660 --> 00:15:19,920
um and so there's basically three

436
00:15:19,920 --> 00:15:21,660
different ways that a configuration can

437
00:15:21,660 --> 00:15:24,480
be smaller in the order and so we need

438
00:15:24,480 --> 00:15:26,519
to count how many there are in order to

439
00:15:26,519 --> 00:15:29,519
rank uh and so we can do this using a

440
00:15:29,519 --> 00:15:31,500
combination of recursion and the table

441
00:15:31,500 --> 00:15:33,959
values that are stored um so if we look

442
00:15:33,959 --> 00:15:35,940
at this first the piece in yellow right

443
00:15:35,940 --> 00:15:38,100
the number that have a smaller left sum

444
00:15:38,100 --> 00:15:41,579
well we can count this up using

445
00:15:41,579 --> 00:15:43,380
table values

446
00:15:43,380 --> 00:15:45,420
uh the second one if they have an equal

447
00:15:45,420 --> 00:15:49,860
left sum but Exile is less than yl right

448
00:15:49,860 --> 00:15:53,639
then we need to determine the rank of x

449
00:15:53,639 --> 00:15:56,459
l and then for each of those right every

450
00:15:56,459 --> 00:15:58,560
for everything that's smaller in rank

451
00:15:58,560 --> 00:16:00,839
the number of configurations there are

452
00:16:00,839 --> 00:16:02,339
right we multiply the number of ways

453
00:16:02,339 --> 00:16:04,980
there are to fill in the right half

454
00:16:04,980 --> 00:16:06,779
um and then to get that final piece in

455
00:16:06,779 --> 00:16:08,579
green um we're going to take the rank of

456
00:16:08,579 --> 00:16:10,260
the right hand side and if we add these

457
00:16:10,260 --> 00:16:12,420
three things up we get the rank of a

458
00:16:12,420 --> 00:16:14,220
configuration and and you can take that

459
00:16:14,220 --> 00:16:15,899
recurrence and turn it into an ad it's

460
00:16:15,899 --> 00:16:17,040
pretty straightforward to go from there

461
00:16:17,040 --> 00:16:18,480
to an algorithm

462
00:16:18,480 --> 00:16:20,940
the nice thing about recursive uh block

463
00:16:20,940 --> 00:16:22,920
order is if you see here we're only

464
00:16:22,920 --> 00:16:24,600
looking at

465
00:16:24,600 --> 00:16:26,940
um when we make recursive calls we're

466
00:16:26,940 --> 00:16:29,279
dividing in half each time so we

467
00:16:29,279 --> 00:16:31,500
actually only need to see two Lo we only

468
00:16:31,500 --> 00:16:34,800
need to compute to log in rows of that

469
00:16:34,800 --> 00:16:37,320
table versus lexicographical order so we

470
00:16:37,320 --> 00:16:40,019
need much fewer rows which is going to

471
00:16:40,019 --> 00:16:43,199
give us some performance improvements

472
00:16:43,199 --> 00:16:45,859
foreign

473
00:16:48,540 --> 00:16:51,839
so both of these algorithms rely on this

474
00:16:51,839 --> 00:16:54,120
c table and so I'm just going to

475
00:16:54,120 --> 00:16:55,740
describe quickly we come up with two

476
00:16:55,740 --> 00:16:57,240
different ways to fill this table and

477
00:16:57,240 --> 00:16:59,639
the first one is similar to what Stein

478
00:16:59,639 --> 00:17:02,519
does but in fact um we so he doesn't

479
00:17:02,519 --> 00:17:04,260
frame it as dynamic programming which is

480
00:17:04,260 --> 00:17:06,540
what I'm doing here but it essentially

481
00:17:06,540 --> 00:17:08,220
is the same technique for filling the

482
00:17:08,220 --> 00:17:11,160
table we actually use a cumulative sum

483
00:17:11,160 --> 00:17:13,319
instead of storing the C values directly

484
00:17:13,319 --> 00:17:15,599
because it leads to some improvements in

485
00:17:15,599 --> 00:17:17,339
the algorithm

486
00:17:17,339 --> 00:17:18,959
um and so you can come up with a

487
00:17:18,959 --> 00:17:21,059
recurrence for this table

488
00:17:21,059 --> 00:17:23,880
um you the idea here um is we're going

489
00:17:23,880 --> 00:17:26,280
to look at the very first uh Vector the

490
00:17:26,280 --> 00:17:28,199
very first point in our Vector

491
00:17:28,199 --> 00:17:30,419
um and so if it starts with zero we can

492
00:17:30,419 --> 00:17:32,280
count those recursively as shown on the

493
00:17:32,280 --> 00:17:33,419
slide

494
00:17:33,419 --> 00:17:35,160
um and if it starts with some number

495
00:17:35,160 --> 00:17:37,679
that's greater than zero right so if it

496
00:17:37,679 --> 00:17:38,880
starts with something that's greater

497
00:17:38,880 --> 00:17:40,980
than zero then we can just look at the

498
00:17:40,980 --> 00:17:43,380
number of configurations within points

499
00:17:43,380 --> 00:17:45,360
and some one less

500
00:17:45,360 --> 00:17:47,280
and then we take each of those and we

501
00:17:47,280 --> 00:17:48,780
add one and that gives us something

502
00:17:48,780 --> 00:17:50,400
right that gives us something in the

503
00:17:50,400 --> 00:17:52,200
original C of n s

504
00:17:52,200 --> 00:17:55,140
however um we're gonna in some cases

505
00:17:55,140 --> 00:17:56,580
we're going to be over counting here

506
00:17:56,580 --> 00:17:58,679
because adding 1 to the first point in

507
00:17:58,679 --> 00:18:00,299
the vector might take us above our

508
00:18:00,299 --> 00:18:02,340
component bound and so that's where this

509
00:18:02,340 --> 00:18:04,320
third term comes in

510
00:18:04,320 --> 00:18:06,480
I mentioned that in the last right in

511
00:18:06,480 --> 00:18:09,000
the um in our second uh ranking

512
00:18:09,000 --> 00:18:11,940
algorithm uh we only need to look at log

513
00:18:11,940 --> 00:18:14,400
n rows of the table or two log n at most

514
00:18:14,400 --> 00:18:16,679
log n if it's a power of two

515
00:18:16,679 --> 00:18:19,020
um and but our you know the the dynamic

516
00:18:19,020 --> 00:18:21,000
programming version of filling the table

517
00:18:21,000 --> 00:18:22,860
actually you would need to fill out all

518
00:18:22,860 --> 00:18:25,140
all rows right and so you wouldn't get

519
00:18:25,140 --> 00:18:28,320
that that Improvement so we also can

520
00:18:28,320 --> 00:18:30,059
fill the table uh using generating

521
00:18:30,059 --> 00:18:31,679
functions as well and that allows us to

522
00:18:31,679 --> 00:18:33,419
only fill the rows that we need and we

523
00:18:33,419 --> 00:18:34,799
can take advantage of the fact that we

524
00:18:34,799 --> 00:18:38,600
only need those log n rows of the table

525
00:18:40,380 --> 00:18:42,900
right so in addition to the the mixing

526
00:18:42,900 --> 00:18:45,539
time bound and the ranking algorithms we

527
00:18:45,539 --> 00:18:48,059
did prototype implementations uh and

528
00:18:48,059 --> 00:18:49,740
compared the running time of these three

529
00:18:49,740 --> 00:18:51,960
different algorithms I'm not going to go

530
00:18:51,960 --> 00:18:54,480
over uh the the sliding you know that

531
00:18:54,480 --> 00:18:56,039
the numbers are up there

532
00:18:56,039 --> 00:18:58,140
um I will say that uh for the specific

533
00:18:58,140 --> 00:18:59,640
example of thumbnail preserving

534
00:18:59,640 --> 00:19:01,559
encryption it seems like the ranking

535
00:19:01,559 --> 00:19:02,820
algorithms aren't going to get us an

536
00:19:02,820 --> 00:19:05,280
improvement uh but again which algorithm

537
00:19:05,280 --> 00:19:06,480
is better is going to depend on your

538
00:19:06,480 --> 00:19:09,900
particular sources of ND and S uh and as

539
00:19:09,900 --> 00:19:12,539
we get to larger values of n the ranking

540
00:19:12,539 --> 00:19:14,940
Solutions uh have struggle because we

541
00:19:14,940 --> 00:19:16,559
have to pre-compute this table and that

542
00:19:16,559 --> 00:19:19,820
table starts to get really large

543
00:19:20,700 --> 00:19:23,280
all right so in summary I showed you

544
00:19:23,280 --> 00:19:26,100
um boy basically I hand waved a lot um a

545
00:19:26,100 --> 00:19:28,380
proof of the bounding the mixing time of

546
00:19:28,380 --> 00:19:30,419
the at all algorithm

547
00:19:30,419 --> 00:19:32,880
um and I showed you or we gave two

548
00:19:32,880 --> 00:19:34,799
practical Rank and unranked algorithms

549
00:19:34,799 --> 00:19:36,660
for some preserving encryption one based

550
00:19:36,660 --> 00:19:38,100
on lexographical order and the other

551
00:19:38,100 --> 00:19:41,580
based on this new recursive block order

552
00:19:41,580 --> 00:19:44,039
and uh we created prototype

553
00:19:44,039 --> 00:19:45,360
implementations with performance

554
00:19:45,360 --> 00:19:47,640
comparisons

555
00:19:47,640 --> 00:19:50,220
that's it thank you

556
00:19:50,220 --> 00:19:53,220
foreign

557
00:19:58,140 --> 00:20:01,140
speaker

558
00:20:06,380 --> 00:20:10,400
commit maybe online I don't know

559
00:20:10,700 --> 00:20:14,100
so maybe so I saw celery as one of the

560
00:20:14,100 --> 00:20:16,679
application uh what is preserved in that

561
00:20:16,679 --> 00:20:18,919
case

562
00:20:20,539 --> 00:20:23,100
sorry I saw in one of his slide that

563
00:20:23,100 --> 00:20:27,059
salaries was one of the application

564
00:20:27,059 --> 00:20:28,500
um so what do you preserve in that case

565
00:20:28,500 --> 00:20:30,840
so the sum of the salaries

566
00:20:30,840 --> 00:20:32,760
oh yeah that we're preserving this time

567
00:20:32,760 --> 00:20:34,799
yeah so all of our work preserves the

568
00:20:34,799 --> 00:20:36,179
sun I think you could definitely

569
00:20:36,179 --> 00:20:37,980
possibly generalize some of these

570
00:20:37,980 --> 00:20:40,500
methods if there was a a different

571
00:20:40,500 --> 00:20:42,419
um parameter that you wanted to uh

572
00:20:42,419 --> 00:20:44,220
preserve uh but we only looked at some

573
00:20:44,220 --> 00:20:45,780
preserving a lot of the ranking

574
00:20:45,780 --> 00:20:48,860
algorithms are very specific to the song

575
00:20:48,860 --> 00:20:51,120
assume that someone new joined the

576
00:20:51,120 --> 00:20:52,140
company

577
00:20:52,140 --> 00:20:54,179
and so in that case so the sum will

578
00:20:54,179 --> 00:20:56,160
change but then you can deduce the

579
00:20:56,160 --> 00:20:58,940
salary of that person

580
00:20:59,460 --> 00:21:01,080
is that correct

581
00:21:01,080 --> 00:21:03,360
so assume that someone new join a

582
00:21:03,360 --> 00:21:04,980
company oh yeah there's some would

583
00:21:04,980 --> 00:21:07,880
change you would have to yeah

584
00:21:09,059 --> 00:21:11,700
and just the last question so is there a

585
00:21:11,700 --> 00:21:13,620
plan to make a product of what you

586
00:21:13,620 --> 00:21:14,880
presented

587
00:21:14,880 --> 00:21:16,740
not as far as I know I would love it if

588
00:21:16,740 --> 00:21:19,200
there was but okay

589
00:21:19,200 --> 00:21:21,919
so thank you

590
00:21:30,000 --> 00:21:32,159
okay so we can move to the to the next

591
00:21:32,159 --> 00:21:35,179
talk thank you Sarah

592
00:21:36,600 --> 00:21:38,760
um so next talk will be on the Elizabeth

593
00:21:38,760 --> 00:21:41,700
string Cipher and the torque will be

594
00:21:41,700 --> 00:21:45,140
given by uh by orl

595
00:21:59,760 --> 00:22:02,059
foreign

596
00:22:08,360 --> 00:22:11,640
which from now on I will call ATT and

597
00:22:11,640 --> 00:22:13,380
which is a tool used in a fully

598
00:22:13,380 --> 00:22:15,720
automatic encryption to solve the

599
00:22:15,720 --> 00:22:18,360
problem caused by the extension ratio

600
00:22:18,360 --> 00:22:20,640
when you're doing the fhe you have to

601
00:22:20,640 --> 00:22:22,559
deal with a huge equivalent ratio so

602
00:22:22,559 --> 00:22:24,980
this is a illustration of it

603
00:22:24,980 --> 00:22:30,059
so if you want to send some data on on

604
00:22:30,059 --> 00:22:33,120
the network and you have a small plan

605
00:22:33,120 --> 00:22:35,640
text the corresponding type attack is

606
00:22:35,640 --> 00:22:38,240
going to be huge

607
00:22:38,700 --> 00:22:39,659
um

608
00:22:39,659 --> 00:22:43,440
so um we are going to try to use uh what

609
00:22:43,440 --> 00:22:46,440
comes with fhe to uh to reduce this so

610
00:22:46,440 --> 00:22:48,840
on the screen you have a usual setup of

611
00:22:48,840 --> 00:22:49,799
fhe

612
00:22:49,799 --> 00:22:51,600
where someone is trying to send some

613
00:22:51,600 --> 00:22:53,640
data to a server to do some computation

614
00:22:53,640 --> 00:22:56,400
but doesn't want to Revenge them

615
00:22:56,400 --> 00:22:58,620
on the server is going to compute a

616
00:22:58,620 --> 00:23:01,200
modifically on them but once again uh

617
00:23:01,200 --> 00:23:03,799
sending this data requires a lot of

618
00:23:03,799 --> 00:23:06,120
bandwidth so what we would like to do

619
00:23:06,120 --> 00:23:07,860
instead is use another crypto system

620
00:23:07,860 --> 00:23:11,000
much later with a small extension ratio

621
00:23:11,000 --> 00:23:13,620
and then since the server can compute

622
00:23:13,620 --> 00:23:16,140
whatever you want it can also decrypt

623
00:23:16,140 --> 00:23:19,320
the this small cycle text to obtain the

624
00:23:19,320 --> 00:23:21,600
the frequency encryption it would have

625
00:23:21,600 --> 00:23:23,820
other without that and then compute

626
00:23:23,820 --> 00:23:25,860
whatever you want but to do so you need

627
00:23:25,860 --> 00:23:27,900
to have you need it needs to have the

628
00:23:27,900 --> 00:23:29,159
secret key

629
00:23:29,159 --> 00:23:31,620
of the new schema so we also have to do

630
00:23:31,620 --> 00:23:35,460
one uh sending in Freedom of encryption

631
00:23:35,460 --> 00:23:38,340
at uh at the setup which contains a

632
00:23:38,340 --> 00:23:40,380
secret key

633
00:23:40,380 --> 00:23:42,840
so several HH schemes have appeared over

634
00:23:42,840 --> 00:23:43,860
the year

635
00:23:43,860 --> 00:23:46,380
uh and they are trying to optimize their

636
00:23:46,380 --> 00:23:48,659
own different criteria the main three

637
00:23:48,659 --> 00:23:51,360
being the the economy in terms of

638
00:23:51,360 --> 00:23:53,100
countries uh in itself

639
00:23:53,100 --> 00:23:55,140
and the other two being the latency and

640
00:23:55,140 --> 00:23:57,480
the circuit and nobody really agrees on

641
00:23:57,480 --> 00:24:00,539
which one is the best so the latency is

642
00:24:00,539 --> 00:24:04,260
the time you have to wait uh to uh

643
00:24:04,260 --> 00:24:07,980
to to go from a small symmetric scheme

644
00:24:07,980 --> 00:24:11,760
so my gray box here to a red one on the

645
00:24:11,760 --> 00:24:12,600
server

646
00:24:12,600 --> 00:24:13,919
on the passion that is called

647
00:24:13,919 --> 00:24:16,700
transferring

648
00:24:17,600 --> 00:24:20,460
so it's the time that it takes to uh to

649
00:24:20,460 --> 00:24:22,140
translator only one bit

650
00:24:22,140 --> 00:24:25,200
and it makes sense when you use packing

651
00:24:25,200 --> 00:24:27,480
in FH here which is the ability to store

652
00:24:27,480 --> 00:24:30,539
several message in a single Cipher text

653
00:24:30,539 --> 00:24:33,200
so we wanted to uh we

654
00:24:33,200 --> 00:24:36,419
and we have to introduce a new scheme

655
00:24:36,419 --> 00:24:37,799
called Elizabeth

656
00:24:37,799 --> 00:24:40,919
which will be here on the schema but the

657
00:24:40,919 --> 00:24:42,840
main idea that we want to introduce is

658
00:24:42,840 --> 00:24:44,280
that it doesn't really make sense to

659
00:24:44,280 --> 00:24:46,919
compare all these scheme uh in terms of

660
00:24:46,919 --> 00:24:51,360
I don't see our throughput sorry

661
00:24:52,500 --> 00:24:55,679
so in the current state of the art

662
00:24:55,679 --> 00:24:57,360
scheme are designed to optimize some

663
00:24:57,360 --> 00:24:59,760
aspect of the hhe so some aspect of the

664
00:24:59,760 --> 00:25:01,679
transfer in time

665
00:25:01,679 --> 00:25:04,620
and then the comparison are done as this

666
00:25:04,620 --> 00:25:07,799
team were Standalone and we don't we

667
00:25:07,799 --> 00:25:09,600
don't think it makes sense in fhc since

668
00:25:09,600 --> 00:25:11,940
uh it's within the site of the fact that

669
00:25:11,940 --> 00:25:15,000
in fhc we want to compute something with

670
00:25:15,000 --> 00:25:18,480
output of the ht's camera

671
00:25:18,480 --> 00:25:22,320
so what we did instead was to start by

672
00:25:22,320 --> 00:25:24,240
thinking in terms of use case what we

673
00:25:24,240 --> 00:25:26,760
want to do once we have transferred and

674
00:25:26,760 --> 00:25:28,620
then design a scheme that will be

675
00:25:28,620 --> 00:25:31,559
optimal for that kind of use case

676
00:25:31,559 --> 00:25:34,440
so uh to evaluate an HTT scheme with the

677
00:25:34,440 --> 00:25:36,900
use case we need a use case

678
00:25:36,900 --> 00:25:39,659
and we choose a one that is a very

679
00:25:39,659 --> 00:25:42,299
common in uh in fhc and it's machine

680
00:25:42,299 --> 00:25:43,320
learning

681
00:25:43,320 --> 00:25:45,179
so it comes with its own set of

682
00:25:45,179 --> 00:25:46,380
constraints

683
00:25:46,380 --> 00:25:48,779
first off in machine learning we want to

684
00:25:48,779 --> 00:25:51,020
use as many bits as possible because

685
00:25:51,020 --> 00:25:54,299
neural networks usually work with 32 or

686
00:25:54,299 --> 00:25:56,279
64 bits input

687
00:25:56,279 --> 00:25:58,020
and then we want to be able to compute

688
00:25:58,020 --> 00:25:59,820
fast because when you do machine

689
00:25:59,820 --> 00:26:01,500
learning you don't want to wait a long

690
00:26:01,500 --> 00:26:04,080
time to have an answer and what you're

691
00:26:04,080 --> 00:26:06,360
trying to compute

692
00:26:06,360 --> 00:26:08,940
and then fht come with its own set of

693
00:26:08,940 --> 00:26:12,779
constraints so we choose to use a tfhe

694
00:26:12,779 --> 00:26:14,820
that is a state of the art computer

695
00:26:14,820 --> 00:26:17,279
system for your memory

696
00:26:17,279 --> 00:26:20,039
and in tfat you don't have the ability

697
00:26:20,039 --> 00:26:22,080
to pack messages so that was something

698
00:26:22,080 --> 00:26:25,740
that we knew we would like to deal with

699
00:26:25,740 --> 00:26:29,940
the gfhe is useful when you want to do

700
00:26:29,940 --> 00:26:32,520
modular editions on the evaluation of

701
00:26:32,520 --> 00:26:35,880
negative tables that use uh lookup

702
00:26:35,880 --> 00:26:38,220
tables in which the second half of the

703
00:26:38,220 --> 00:26:39,720
values are the opposite of the first

704
00:26:39,720 --> 00:26:40,559
half

705
00:26:40,559 --> 00:26:43,679
another missing item on my side is that

706
00:26:43,679 --> 00:26:45,900
in tfhe you cannot store very large

707
00:26:45,900 --> 00:26:48,840
messages uh in a single Circle text so

708
00:26:48,840 --> 00:26:50,640
we knew that we would have to to work

709
00:26:50,640 --> 00:26:53,340
with a few bits so the trade-off was to

710
00:26:53,340 --> 00:26:55,140
use 4-bit messages that was the best we

711
00:26:55,140 --> 00:26:58,140
could do to have a small crypto system a

712
00:26:58,140 --> 00:27:00,860
faster system to evaluate

713
00:27:00,860 --> 00:27:03,360
while storing as many bits as possible

714
00:27:03,360 --> 00:27:05,940
you know tfhe type of text

715
00:27:05,940 --> 00:27:08,700
and for the first evaluation we uh we

716
00:27:08,700 --> 00:27:11,220
made it so that the operator system will

717
00:27:11,220 --> 00:27:12,900
be easy to evaluate and multiple thread

718
00:27:12,900 --> 00:27:13,980
at the same time

719
00:27:13,980 --> 00:27:16,620
and regarding the consummator because

720
00:27:16,620 --> 00:27:19,919
the tfhe uh we just chose to call them a

721
00:27:19,919 --> 00:27:22,500
toolbox inside of a constraints and we

722
00:27:22,500 --> 00:27:24,779
use them to design the scheme

723
00:27:24,779 --> 00:27:28,559
okay so now let's dive into a horror or

724
00:27:28,559 --> 00:27:30,779
scanner is done so it's called Elizabeth

725
00:27:30,779 --> 00:27:33,299
and it's uh

726
00:27:33,299 --> 00:27:36,240
sold as a successor for crypto system

727
00:27:36,240 --> 00:27:39,360
called Philip which has all uh state of

728
00:27:39,360 --> 00:27:41,820
the art HH scheme is biased uh is based

729
00:27:41,820 --> 00:27:43,980
on the filter permutation introduced by

730
00:27:43,980 --> 00:27:47,760
ship so the idea is that when you want

731
00:27:47,760 --> 00:27:50,100
to generate a key stream

732
00:27:50,100 --> 00:27:52,620
you start from an internal State and

733
00:27:52,620 --> 00:27:54,299
then you do some computation over it but

734
00:27:54,299 --> 00:27:56,400
when you do so in sat you add some noise

735
00:27:56,400 --> 00:27:59,520
in the output and if you do it too too

736
00:27:59,520 --> 00:28:01,799
much at some point your your kitchen

737
00:28:01,799 --> 00:28:03,360
will be so noisy that you won't be able

738
00:28:03,360 --> 00:28:04,679
to use it anymore

739
00:28:04,679 --> 00:28:07,200
with the filter permit data padding you

740
00:28:07,200 --> 00:28:09,900
start from an internet State and you

741
00:28:09,900 --> 00:28:12,000
apply a key stream generator function

742
00:28:12,000 --> 00:28:14,220
and you will always use the the same

743
00:28:14,220 --> 00:28:16,140
function on the same internal state so

744
00:28:16,140 --> 00:28:17,580
the bit that you produce will always

745
00:28:17,580 --> 00:28:21,620
contain a fixed amount of noise

746
00:28:21,620 --> 00:28:24,779
so are we going to do that by adapting

747
00:28:24,779 --> 00:28:26,820
the feature parameter padding to the

748
00:28:26,820 --> 00:28:28,799
group heater parameter as a group inter

749
00:28:28,799 --> 00:28:31,620
parameter padding so we start from a key

750
00:28:31,620 --> 00:28:34,919
register and using a public prng we are

751
00:28:34,919 --> 00:28:36,900
going to choose a subset in it on the

752
00:28:36,900 --> 00:28:39,539
shuffle it and then add some modernized

753
00:28:39,539 --> 00:28:40,380
in it

754
00:28:40,380 --> 00:28:42,480
so all of this operations are now is

755
00:28:42,480 --> 00:28:44,520
less because choosing a subset I'm

756
00:28:44,520 --> 00:28:46,620
Shuffling it it's not fhc just moving

757
00:28:46,620 --> 00:28:49,039
box around

758
00:28:52,919 --> 00:28:55,080
so at this point nothing is noisier in

759
00:28:55,080 --> 00:28:56,039
what we did

760
00:28:56,039 --> 00:28:57,900
and then we are going to apply a filter

761
00:28:57,900 --> 00:29:00,000
function and only in the feature

762
00:29:00,000 --> 00:29:04,260
function will be a noise to a ciphertext

763
00:29:04,260 --> 00:29:07,860
so uh in the end Elizabeth is a entirely

764
00:29:07,860 --> 00:29:11,900
defined by its filter so here it is

765
00:29:11,900 --> 00:29:16,740
I do realize there's a lot of slides so

766
00:29:16,740 --> 00:29:19,080
we're going to break it up the first

767
00:29:19,080 --> 00:29:20,760
thing you have to notice is that there's

768
00:29:20,760 --> 00:29:24,000
only three different things uh on this

769
00:29:24,000 --> 00:29:26,779
you have five inputs or equivalent to X5

770
00:29:26,779 --> 00:29:30,779
modular editions and the eight boxes S12

771
00:29:30,779 --> 00:29:33,779
S8 that are negative Equitable and that

772
00:29:33,779 --> 00:29:35,659
are computed through through a bootstrap

773
00:29:35,659 --> 00:29:38,399
in a homographically

774
00:29:38,399 --> 00:29:41,159
and these lookup tables are the costic

775
00:29:41,159 --> 00:29:42,360
part of the operation

776
00:29:42,360 --> 00:29:46,320
luckily the first four can be a computed

777
00:29:46,320 --> 00:29:48,000
separately because you don't need the

778
00:29:48,000 --> 00:29:51,000
output of a trend to compute yourself so

779
00:29:51,000 --> 00:29:52,919
you can do that in a first step by trade

780
00:29:52,919 --> 00:29:54,960
then you have an addition because you

781
00:29:54,960 --> 00:29:57,960
have to wait and synchronize but the the

782
00:29:57,960 --> 00:30:00,779
next four can also be done separately in

783
00:30:00,779 --> 00:30:03,899
Traditions Trading so in the end to a

784
00:30:03,899 --> 00:30:06,240
computer it is a

785
00:30:06,240 --> 00:30:08,700
this box you only have to pay for two

786
00:30:08,700 --> 00:30:11,520
bootstraps and you can compute eight of

787
00:30:11,520 --> 00:30:14,100
them and it is just a part of the full

788
00:30:14,100 --> 00:30:16,500
filter and the actual filter is the

789
00:30:16,500 --> 00:30:18,899
tissue version then 12 times in parallel

790
00:30:18,899 --> 00:30:21,480
so the the entire filter of exhibit

791
00:30:21,480 --> 00:30:23,580
consists in 96

792
00:30:23,580 --> 00:30:26,640
bootstraps but you only pay for for two

793
00:30:26,640 --> 00:30:30,539
of them sounds to a community thread

794
00:30:30,539 --> 00:30:34,620
so now let's have a look at our use case

795
00:30:34,620 --> 00:30:37,380
so this is a neural network that uh we

796
00:30:37,380 --> 00:30:40,080
uh we used for the use case which is

797
00:30:40,080 --> 00:30:43,679
rather small I think I was told so by

798
00:30:43,679 --> 00:30:45,240
people that do understand what the

799
00:30:45,240 --> 00:30:47,240
machine learning is

800
00:30:47,240 --> 00:30:50,580
uh and what this does it's uh

801
00:30:50,580 --> 00:30:52,020
classifying

802
00:30:52,020 --> 00:30:54,720
um pictures of classes

803
00:30:54,720 --> 00:30:56,520
and believe it or not but this picture

804
00:30:56,520 --> 00:30:59,460
is actually to a high def to be used in

805
00:30:59,460 --> 00:31:03,539
fhe because it uses eight bits of Gray

806
00:31:03,539 --> 00:31:07,140
and we can only use three the Y3 are not

807
00:31:07,140 --> 00:31:09,360
far even so uh is a bad kind of stuff

808
00:31:09,360 --> 00:31:12,120
for bits messages it's because uh to

809
00:31:12,120 --> 00:31:14,399
enable first computation with jfhe you

810
00:31:14,399 --> 00:31:16,080
need to set the machine different bits

811
00:31:16,080 --> 00:31:18,899
to zero so we can only write in the the

812
00:31:18,899 --> 00:31:21,720
three uh next bits

813
00:31:21,720 --> 00:31:25,500
so by doing so the the neural network uh

814
00:31:25,500 --> 00:31:27,960
lose a bit of accuracy so it can only

815
00:31:27,960 --> 00:31:32,279
answer quite clear 97 or no 90 of the

816
00:31:32,279 --> 00:31:33,720
time

817
00:31:33,720 --> 00:31:37,919
but uh it's a it's okay for us so

818
00:31:37,919 --> 00:31:40,679
because uh we know that with FH here we

819
00:31:40,679 --> 00:31:43,980
are going to lose a bit of accuracy

820
00:31:43,980 --> 00:31:45,179
so

821
00:31:45,179 --> 00:31:47,460
no regarding the timing of Elizabeth

822
00:31:47,460 --> 00:31:49,919
uh it has been designed to be

823
00:31:49,919 --> 00:31:53,880
to use less constraining uh parameters

824
00:31:53,880 --> 00:31:55,260
than any use case that it could be

825
00:31:55,260 --> 00:31:58,380
useful so actually in this table I'm

826
00:31:58,380 --> 00:32:01,080
only interested in these three values so

827
00:32:01,080 --> 00:32:03,240
if you use Elizabeth with the optimal

828
00:32:03,240 --> 00:32:07,260
parameters it's going to be a

829
00:32:07,260 --> 00:32:09,600
so if you don't see efficient so the

830
00:32:09,600 --> 00:32:12,419
timing doesn't mean much because it

831
00:32:12,419 --> 00:32:15,360
depends on what computer or otherwise

832
00:32:15,360 --> 00:32:16,500
you're going to use

833
00:32:16,500 --> 00:32:18,960
uh but what you can see is that if you

834
00:32:18,960 --> 00:32:21,240
use Elizabeth with the use case then the

835
00:32:21,240 --> 00:32:23,340
time I uh the timing are multiplied by a

836
00:32:23,340 --> 00:32:25,320
factor five and it comes from the fact

837
00:32:25,320 --> 00:32:28,260
that the parameters of the use case uh

838
00:32:28,260 --> 00:32:30,480
yes of the use case are going to be much

839
00:32:30,480 --> 00:32:33,179
bigger than the parameters of Elizabeth

840
00:32:33,179 --> 00:32:35,700
uh and uh for every different set of

841
00:32:35,700 --> 00:32:36,899
parameters that you want to use in

842
00:32:36,899 --> 00:32:38,460
effect here you have to send another key

843
00:32:38,460 --> 00:32:41,399
to the server so you could choose to uh

844
00:32:41,399 --> 00:32:44,580
use Elizabeth as a plug-and-player with

845
00:32:44,580 --> 00:32:46,260
the system and turn missing to the

846
00:32:46,260 --> 00:32:48,419
server and then determine they are going

847
00:32:48,419 --> 00:32:50,880
to be a bit bigger but you could also

848
00:32:50,880 --> 00:32:52,380
choose to send the its own set of

849
00:32:52,380 --> 00:32:54,899
parameters for either that and gain some

850
00:32:54,899 --> 00:32:56,340
time

851
00:32:56,340 --> 00:32:59,580
so if you just do an intern that is an

852
00:32:59,580 --> 00:33:01,980
evaluation of the neural network in fhe

853
00:33:01,980 --> 00:33:05,220
without hhe it's going to takes five

854
00:33:05,220 --> 00:33:07,440
seconds and if you use Elizabeth with

855
00:33:07,440 --> 00:33:10,020
the parameters of the neural network is

856
00:33:10,020 --> 00:33:12,779
going to be a much larger but once again

857
00:33:12,779 --> 00:33:15,840
it can be a much reduced if you use the

858
00:33:15,840 --> 00:33:18,600
parameters for example 30 firms and the

859
00:33:18,600 --> 00:33:20,779
one from the neural network

860
00:33:20,779 --> 00:33:23,399
and in terms of efficiency bandwidth

861
00:33:23,399 --> 00:33:25,760
wise Elizabeth

862
00:33:25,760 --> 00:33:28,260
is a

863
00:33:28,260 --> 00:33:30,539
we will reduce the bandwidth youth uh

864
00:33:30,539 --> 00:33:32,940
since the very first influence

865
00:33:32,940 --> 00:33:35,340
and if you choose to use the two set of

866
00:33:35,340 --> 00:33:38,220
parameters uh it's going to take a bit

867
00:33:38,220 --> 00:33:41,399
more influences so around 2000 in front

868
00:33:41,399 --> 00:33:43,860
years but it only takes 40 hours and so

869
00:33:43,860 --> 00:33:47,480
it's not much in a SAT time

870
00:33:47,480 --> 00:33:49,799
so friends there what do we want to do

871
00:33:49,799 --> 00:33:52,019
well first off we would like to be able

872
00:33:52,019 --> 00:33:55,559
to transfer much bigger message at the

873
00:33:55,559 --> 00:33:57,720
same time because with forbids we have

874
00:33:57,720 --> 00:33:59,159
seen that there's not much that we can

875
00:33:59,159 --> 00:33:59,960
do

876
00:33:59,960 --> 00:34:03,419
we also think that uh we should look at

877
00:34:03,419 --> 00:34:04,919
that from the machine learning point of

878
00:34:04,919 --> 00:34:07,019
view so without even using cryptography

879
00:34:07,019 --> 00:34:11,099
or can we do a better neural networks

880
00:34:11,099 --> 00:34:12,000
that are

881
00:34:12,000 --> 00:34:15,119
easier to evaluate with a fhe

882
00:34:15,119 --> 00:34:18,480
on the left three we should look for

883
00:34:18,480 --> 00:34:20,280
more relevant use case because once

884
00:34:20,280 --> 00:34:21,899
again we think it's uh it doesn't make

885
00:34:21,899 --> 00:34:23,639
sense to consider Itachi without a use

886
00:34:23,639 --> 00:34:25,679
case but we also think that we need to

887
00:34:25,679 --> 00:34:28,440
find use case that are relevant to uh to

888
00:34:28,440 --> 00:34:31,859
hhe so we chose to to use teacher's case

889
00:34:31,859 --> 00:34:34,260
because fmnist is a very common data set

890
00:34:34,260 --> 00:34:36,899
in machine learning but maybe it's not

891
00:34:36,899 --> 00:34:39,418
what you want to do when you use akt and

892
00:34:39,418 --> 00:34:40,918
we think that people that do understand

893
00:34:40,918 --> 00:34:42,480
what is machine learning should look

894
00:34:42,480 --> 00:34:44,699
into hht and find a

895
00:34:44,699 --> 00:34:47,219
relevant challenge that will help

896
00:34:47,219 --> 00:34:49,580
compare feature schemes

897
00:34:49,580 --> 00:34:51,960
thank you very much for your for your

898
00:34:51,960 --> 00:34:54,239
attention and sharing this channel I'd

899
00:34:54,239 --> 00:34:56,839
be happy to answer

900
00:35:08,400 --> 00:35:11,000
it doesn't drop out okay

901
00:35:11,000 --> 00:35:12,960
the questions

902
00:35:12,960 --> 00:35:15,800
remarks

903
00:35:16,940 --> 00:35:20,780
online do you have questions

904
00:35:21,119 --> 00:35:23,880
um so he told us that uh Elizabeth was

905
00:35:23,880 --> 00:35:26,400
the successor of Philip yes that's the

906
00:35:26,400 --> 00:35:28,500
main difference between the two ciphers

907
00:35:28,500 --> 00:35:31,980
Philippe work in one bit messages on the

908
00:35:31,980 --> 00:35:34,140
with Elizabeth we are able to encrypt

909
00:35:34,140 --> 00:35:36,180
the four bits at a time so that the main

910
00:35:36,180 --> 00:35:38,160
difference between Philip and Elizabeth

911
00:35:38,160 --> 00:35:40,619
on the training between isibetan Master

912
00:35:40,619 --> 00:35:43,380
hhe schemes with the ability to work on

913
00:35:43,380 --> 00:35:45,859
4 bit messages

914
00:35:45,859 --> 00:35:48,599
just one bit messages and there are some

915
00:35:48,599 --> 00:35:49,920
other activities things that work with

916
00:35:49,920 --> 00:35:52,260
several bit messages but then the output

917
00:35:52,260 --> 00:35:56,300
are in a infinite field rather than a

918
00:35:56,300 --> 00:35:59,339
Z16 so it's less easier to do any

919
00:35:59,339 --> 00:36:02,099
computation on them after a while

920
00:36:02,099 --> 00:36:04,380
okay thank you

921
00:36:04,380 --> 00:36:06,240
Okay so we've done no more questions

922
00:36:06,240 --> 00:36:08,520
let's thank the speaker

923
00:36:08,520 --> 00:36:11,359
thank you very much

924
00:36:45,000 --> 00:36:47,660
Google

925
00:36:49,320 --> 00:36:52,260
so next talk is some related key

926
00:36:52,260 --> 00:36:56,119
Boomerang attacks on AES

927
00:37:13,859 --> 00:37:15,960
hello

928
00:37:15,960 --> 00:37:17,520
so

929
00:37:17,520 --> 00:37:22,400
hello everyone let's get started

930
00:37:25,079 --> 00:37:27,660
so as you can see here this table

931
00:37:27,660 --> 00:37:30,060
summarizer existing attack again a year

932
00:37:30,060 --> 00:37:34,200
1992 and note that here by click not

933
00:37:34,200 --> 00:37:36,420
really an effect it's not improves it's

934
00:37:36,420 --> 00:37:38,400
not desert with a complete look on the

935
00:37:38,400 --> 00:37:40,200
display and

936
00:37:40,200 --> 00:37:42,780
the current met time complexity on

937
00:37:42,780 --> 00:37:45,560
Attack on Route is total

938
00:37:45,560 --> 00:37:48,420
176 for a relatively Boomerang of

939
00:37:48,420 --> 00:37:51,540
pericope and hobartovic and

940
00:37:51,540 --> 00:37:55,520
in this book we found a new related

941
00:37:55,520 --> 00:37:58,380
time complexity in two to three people

942
00:37:58,380 --> 00:38:00,599
come lower than the Batman attack

943
00:38:00,599 --> 00:38:03,079
so

944
00:38:03,240 --> 00:38:07,200
here is the boomerang attack in the lab

945
00:38:07,200 --> 00:38:09,740
is a random attack

946
00:38:09,740 --> 00:38:12,900
and in the right is our type

947
00:38:12,900 --> 00:38:16,320
going by here is that means no different

948
00:38:16,320 --> 00:38:18,060
and

949
00:38:18,060 --> 00:38:20,760
we have our attack has the probability

950
00:38:20,760 --> 00:38:24,900
is two to minus 108 instead of two to

951
00:38:24,900 --> 00:38:28,320
minus 110 is a bit better but it's

952
00:38:28,320 --> 00:38:31,140
almost the same probability

953
00:38:31,140 --> 00:38:33,960
here is a zoom and map input of blood

954
00:38:33,960 --> 00:38:34,980
attack

955
00:38:34,980 --> 00:38:38,160
so in our type we have the modeling by

956
00:38:38,160 --> 00:38:40,680
zombies attack doesn't mean we know much

957
00:38:40,680 --> 00:38:43,619
more information than the type of

958
00:38:43,619 --> 00:38:46,440
protocol and combative

959
00:38:46,440 --> 00:38:49,380
and since the rest of this talk I will

960
00:38:49,380 --> 00:38:51,720
need balance in detail how we found the

961
00:38:51,720 --> 00:38:53,760
attack

962
00:38:53,760 --> 00:38:56,700
so anyone here knows a boomerang attack

963
00:38:56,700 --> 00:39:00,540
before raise your hand okay

964
00:39:00,540 --> 00:39:03,079
of

965
00:39:08,000 --> 00:39:11,400
and first the study here it's the

966
00:39:11,400 --> 00:39:13,980
different will be combined or not

967
00:39:13,980 --> 00:39:16,920
so I will land in a basic form of

968
00:39:16,920 --> 00:39:19,800
boomerang distinguisher had an attacker

969
00:39:19,800 --> 00:39:22,260
as the art staff for about ingression

970
00:39:22,260 --> 00:39:25,500
and decreasing cycle so first the

971
00:39:25,500 --> 00:39:28,079
attacker picked the big one at random

972
00:39:28,079 --> 00:39:31,320
and ask for the Cyber text C1

973
00:39:31,320 --> 00:39:35,460
and secondly he composed Vito as by

974
00:39:35,460 --> 00:39:38,700
adding a different answer and get the

975
00:39:38,700 --> 00:39:40,560
psychotic C2

976
00:39:40,560 --> 00:39:44,280
and after that he completely free and C4

977
00:39:44,280 --> 00:39:47,160
by adding the different than fat to C1

978
00:39:47,160 --> 00:39:49,200
and C2

979
00:39:49,200 --> 00:39:52,700
and next he obtains the corresponding

980
00:39:52,700 --> 00:39:55,920
Atlantic P3 and E4

981
00:39:55,920 --> 00:39:59,220
and finally he asked he checked it be

982
00:39:59,220 --> 00:40:01,920
free and before he differ by the same

983
00:40:01,920 --> 00:40:04,260
different answer or not

984
00:40:04,260 --> 00:40:05,339
and

985
00:40:05,339 --> 00:40:08,220
we will keep answer combat more often

986
00:40:08,220 --> 00:40:10,680
than a random permutation we will have a

987
00:40:10,680 --> 00:40:13,320
distinguisher

988
00:40:13,320 --> 00:40:14,520
and

989
00:40:14,520 --> 00:40:16,740
false the artists didn't know approach

990
00:40:16,740 --> 00:40:19,500
the stifle e defined into two parts

991
00:40:19,500 --> 00:40:22,440
P0 and E1 and we miss the good

992
00:40:22,440 --> 00:40:25,260
difference so for its path and

993
00:40:25,260 --> 00:40:26,820
puzzle

994
00:40:26,820 --> 00:40:28,920
input different and style it was the

995
00:40:28,920 --> 00:40:31,740
outputation data with high probability B

996
00:40:31,740 --> 00:40:36,660
and over e0 and the mileage with the

997
00:40:36,660 --> 00:40:41,099
high property Q over E1 and we need the

998
00:40:41,099 --> 00:40:44,400
then the expected property is P Square Q

999
00:40:44,400 --> 00:40:46,380
Square which the asymptoms that's

1000
00:40:46,380 --> 00:40:48,900
crucial are independent but

1001
00:40:48,900 --> 00:40:52,440
think directly this Essence does not

1002
00:40:52,440 --> 00:40:55,500
allow it correct and

1003
00:40:55,500 --> 00:40:57,359
who had

1004
00:40:57,359 --> 00:41:00,720
in 2011 movie shows up the boomerang

1005
00:41:00,720 --> 00:41:04,200
never come back and the problem comes

1006
00:41:04,200 --> 00:41:05,780
from the assistant

1007
00:41:05,780 --> 00:41:10,020
that's my dependent may exist so

1008
00:41:10,020 --> 00:41:14,700
to handle the dependency that money and

1009
00:41:14,700 --> 00:41:17,640
propose a sandwich attack now disciple

1010
00:41:17,640 --> 00:41:19,680
divide into three parts instead of two

1011
00:41:19,680 --> 00:41:22,140
parts is zero and you want to stay here

1012
00:41:22,140 --> 00:41:25,740
but we have a new middle pass em and the

1013
00:41:25,740 --> 00:41:29,400
em with high property and now the

1014
00:41:29,400 --> 00:41:31,859
expected probability is distance Square

1015
00:41:31,859 --> 00:41:34,079
building square and uh

1016
00:41:34,079 --> 00:41:36,660
and

1017
00:41:36,660 --> 00:41:42,020
so how we can compose the property of em

1018
00:41:44,720 --> 00:41:48,078
PTY 2018

1019
00:41:49,280 --> 00:41:53,160
table that reduce the problem of

1020
00:41:53,160 --> 00:41:55,560
computing the property of the numerous

1021
00:41:55,560 --> 00:41:59,760
to to the one of computing it over its

1022
00:41:59,760 --> 00:42:01,859
exploit and

1023
00:42:01,859 --> 00:42:03,000
so

1024
00:42:03,000 --> 00:42:06,960
VCT mode here is the number of solutions

1025
00:42:06,960 --> 00:42:10,339
as boomerang come back

1026
00:42:16,400 --> 00:42:19,800
mystery framework this computes the

1027
00:42:19,800 --> 00:42:22,920
property of Boomerang distinguisher with

1028
00:42:22,920 --> 00:42:27,180
a considering the dependency

1029
00:42:27,180 --> 00:42:28,859
and

1030
00:42:28,859 --> 00:42:31,859
to search for the move around attack we

1031
00:42:31,859 --> 00:42:34,740
typically use some automatic tune also

1032
00:42:34,740 --> 00:42:37,680
because the boomerang distinguisher and

1033
00:42:37,680 --> 00:42:40,920
sit there and use MLP model to study

1034
00:42:40,920 --> 00:42:44,099
this level speak to aspects the belcy

1035
00:42:44,099 --> 00:42:47,700
blue and Sasaki use an IOP model to

1036
00:42:47,700 --> 00:42:49,740
direct research for the women around

1037
00:42:49,740 --> 00:42:53,339
this ticket user on the hip but this

1038
00:42:53,339 --> 00:42:56,579
works only rigid em plus only one rail

1039
00:42:56,579 --> 00:43:00,480
and recently the land and introduced a

1040
00:43:00,480 --> 00:43:02,339
set of table to calculate the

1041
00:43:02,339 --> 00:43:04,619
probability

1042
00:43:04,619 --> 00:43:08,160
and they use an IOP CP and other

1043
00:43:08,160 --> 00:43:10,200
approach to search for the boom language

1044
00:43:10,200 --> 00:43:14,700
industry on skinny and now what is based

1045
00:43:14,700 --> 00:43:16,680
on this book

1046
00:43:16,680 --> 00:43:18,660
so

1047
00:43:18,660 --> 00:43:21,960
this technical had to understand the

1048
00:43:21,960 --> 00:43:25,460
notation view in the definition

1049
00:43:25,500 --> 00:43:28,260
to surface the boomerang characteristic

1050
00:43:28,260 --> 00:43:30,480
to serve as a woman listening leader you

1051
00:43:30,480 --> 00:43:32,400
need to be able to compose the property

1052
00:43:32,400 --> 00:43:35,180
of the boomerang characteristic

1053
00:43:35,180 --> 00:43:38,880
visiting not enough so we need to mask

1054
00:43:38,880 --> 00:43:41,880
the different cell table we need a chart

1055
00:43:41,880 --> 00:43:45,839
three table here we have the UBC pays

1056
00:43:45,839 --> 00:43:48,720
for the upper basicity lbcp for the

1057
00:43:48,720 --> 00:43:52,759
lower obesity and obesity

1058
00:43:53,339 --> 00:43:56,000
and

1059
00:43:56,160 --> 00:43:59,220
so when given a boomerang characteristic

1060
00:43:59,220 --> 00:44:01,859
how to propose the volatility last

1061
00:44:01,859 --> 00:44:04,819
Boomerang Twitter

1062
00:44:04,819 --> 00:44:06,359
life

1063
00:44:06,359 --> 00:44:08,040
many people like the property of

1064
00:44:08,040 --> 00:44:11,760
assistance but how we can Comfort the

1065
00:44:11,760 --> 00:44:14,579
property of transition for one

1066
00:44:14,579 --> 00:44:17,640
particular Expo that's gives a different

1067
00:44:17,640 --> 00:44:19,859
suitable

1068
00:44:19,859 --> 00:44:25,740
so here we give an characteristics

1069
00:44:26,099 --> 00:44:28,020
on three well

1070
00:44:28,020 --> 00:44:32,339
and we need to compose the variety of

1071
00:44:32,339 --> 00:44:34,440
this Boomer characteristics that's the

1072
00:44:34,440 --> 00:44:35,220
woman

1073
00:44:35,220 --> 00:44:37,079
returns

1074
00:44:37,079 --> 00:44:39,480
what we need to do here is that

1075
00:44:39,480 --> 00:44:43,680
look at where the we have

1076
00:44:43,680 --> 00:44:46,578
for sale

1077
00:44:46,880 --> 00:44:48,920
and

1078
00:44:48,920 --> 00:44:51,240
we will address

1079
00:44:51,240 --> 00:44:54,180
so this is where they are the input of

1080
00:44:54,180 --> 00:44:56,040
the output in the upper of the lower

1081
00:44:56,040 --> 00:44:58,400
Trail

1082
00:45:01,400 --> 00:45:03,780
best value

1083
00:45:03,780 --> 00:45:06,780
and after that we looked at some light

1084
00:45:06,780 --> 00:45:09,500
tables yet

1085
00:45:19,500 --> 00:45:24,260
input and the outputation uh

1086
00:45:29,420 --> 00:45:32,839
zero and

1087
00:45:35,720 --> 00:45:37,500
lead to

1088
00:45:37,500 --> 00:45:40,440
one another particulars

1089
00:45:40,440 --> 00:45:42,420
let's look here

1090
00:45:42,420 --> 00:45:47,180
the input as output of the cells

1091
00:45:47,180 --> 00:45:50,760
and for the input of the lower are

1092
00:45:50,760 --> 00:45:53,099
substitution and the output of the lower

1093
00:45:53,099 --> 00:45:54,960
shell has

1094
00:45:54,960 --> 00:45:56,119
Etc

1095
00:45:56,119 --> 00:46:00,900
and it correspond to the ebcc guys so

1096
00:46:00,900 --> 00:46:04,079
you can compute the probability of UBC

1097
00:46:04,079 --> 00:46:07,040
statistics

1098
00:46:10,160 --> 00:46:14,420
model to serve for the chances

1099
00:46:15,030 --> 00:46:18,129
[Music]

1100
00:46:18,180 --> 00:46:21,180
and

1101
00:46:23,760 --> 00:46:26,280
that makes some new variable for the

1102
00:46:26,280 --> 00:46:28,500
known variable

1103
00:46:28,500 --> 00:46:30,420
variable

1104
00:46:30,420 --> 00:46:33,780
and add some new content to new

1105
00:46:33,780 --> 00:46:36,480
variables for the function of three

1106
00:46:36,480 --> 00:46:40,319
variables and let us I think there are

1107
00:46:40,319 --> 00:46:43,560
some the best content for the select the

1108
00:46:43,560 --> 00:46:46,740
table to know which table are you in the

1109
00:46:46,740 --> 00:46:50,479
computation of the property

1110
00:47:01,280 --> 00:47:03,540
how many

1111
00:47:03,540 --> 00:47:07,560
people are important language

1112
00:47:08,290 --> 00:47:11,400
[Music]

1113
00:47:13,520 --> 00:47:16,520
department

1114
00:47:20,240 --> 00:47:24,839
is very generous so we want to use model

1115
00:47:24,839 --> 00:47:26,160
to

1116
00:47:26,160 --> 00:47:30,300
write a yes to apply the ASAP but first

1117
00:47:30,300 --> 00:47:32,060
why is

1118
00:47:32,060 --> 00:47:35,099
one of the most I'm just gonna hold them

1119
00:47:35,099 --> 00:47:37,319
in the world so

1120
00:47:37,319 --> 00:47:39,619
block style has the one

1121
00:47:39,619 --> 00:47:45,380
it can be used to Magic of four times

1122
00:47:45,380 --> 00:47:49,200
to have the four operators

1123
00:47:49,200 --> 00:47:52,079
to our routing Supply should go and

1124
00:47:52,079 --> 00:47:54,540
follow the steps a lot well there are

1125
00:47:54,540 --> 00:47:59,640
three versions of ESP 128 a year 192 and

1126
00:47:59,640 --> 00:48:02,160
8. so 100

1127
00:48:02,160 --> 00:48:04,619
and

1128
00:48:04,619 --> 00:48:09,599
our model is robust we use a app 1992f

1129
00:48:09,599 --> 00:48:11,940
an example because you have a look

1130
00:48:11,940 --> 00:48:14,220
wasn't

1131
00:48:14,220 --> 00:48:17,118
so here is

1132
00:48:18,780 --> 00:48:20,579
so

1133
00:48:20,579 --> 00:48:22,079
uh

1134
00:48:22,079 --> 00:48:26,099
but this password and

1135
00:48:28,319 --> 00:48:31,260
the problem here is that statistical in

1136
00:48:31,260 --> 00:48:34,079
non-linear and cannot control solution

1137
00:48:34,079 --> 00:48:37,079
and between such a loud thing and we

1138
00:48:37,079 --> 00:48:38,880
need a new model

1139
00:48:38,880 --> 00:48:40,440
so

1140
00:48:40,440 --> 00:48:43,560
what we will add into new model

1141
00:48:43,560 --> 00:48:46,260
to handle the non-linear Keys as well we

1142
00:48:46,260 --> 00:48:48,800
use related feed conditional

1143
00:48:48,800 --> 00:48:52,920
and not slightly a small chain on the

1144
00:48:52,920 --> 00:48:54,780
distinguisher may lead to a better

1145
00:48:54,780 --> 00:48:57,660
attack so we want to really resource the

1146
00:48:57,660 --> 00:49:01,440
attack not only possible distinguisher

1147
00:49:01,440 --> 00:49:02,819
and

1148
00:49:02,819 --> 00:49:05,520
actually you cannot control the this one

1149
00:49:05,520 --> 00:49:07,800
on the thing because if we start the

1150
00:49:07,800 --> 00:49:09,900
different for most input and output of

1151
00:49:09,900 --> 00:49:12,839
an output then it rejects the possible

1152
00:49:12,839 --> 00:49:15,780
value and we look at the

1153
00:49:15,780 --> 00:49:18,780
and

1154
00:49:25,619 --> 00:49:28,160
for our time

1155
00:49:28,160 --> 00:49:30,319
so

1156
00:49:30,319 --> 00:49:34,099
this one as though

1157
00:49:35,780 --> 00:49:39,680
as opposal

1158
00:49:40,319 --> 00:49:45,020
so pause the new model we

1159
00:49:46,040 --> 00:49:48,240
new variables

1160
00:49:48,240 --> 00:49:52,759
to know what's this one is the distance

1161
00:49:56,480 --> 00:50:00,000
by the variable if there are variables

1162
00:50:00,000 --> 00:50:03,599
belongs to the best variable if it can

1163
00:50:03,599 --> 00:50:05,880
be zero and type variable is the

1164
00:50:05,880 --> 00:50:08,579
difference is known and S if the reason

1165
00:50:08,579 --> 00:50:11,579
is bad to us that type of value

1166
00:50:11,579 --> 00:50:14,940
and we are doing some pressing the

1167
00:50:14,940 --> 00:50:19,200
profiles monthly and S and

1168
00:50:19,200 --> 00:50:22,440
well there are some problems for the

1169
00:50:22,440 --> 00:50:25,380
known variable in the case as a plus

1170
00:50:25,380 --> 00:50:27,960
like with when we search for the

1171
00:50:27,960 --> 00:50:30,780
uh differential characteristics on a yes

1172
00:50:30,780 --> 00:50:35,180
many of them are impossible because

1173
00:50:37,740 --> 00:50:40,800
the linear relations in the

1174
00:50:40,800 --> 00:50:44,040
other system of a person this right yes

1175
00:50:44,040 --> 00:50:45,420
so

1176
00:50:45,420 --> 00:50:49,880
actually one yeah

1177
00:50:51,500 --> 00:50:54,800
so what

1178
00:50:56,599 --> 00:50:59,960
who will be

1179
00:51:00,119 --> 00:51:03,180
this time when with our solution and we

1180
00:51:03,180 --> 00:51:05,280
take it the solution is satisfies the

1181
00:51:05,280 --> 00:51:08,579
content or not so we're having some lazy

1182
00:51:08,579 --> 00:51:10,619
content to our model

1183
00:51:10,619 --> 00:51:13,140
that's done

1184
00:51:13,140 --> 00:51:15,440
yeah

1185
00:51:22,380 --> 00:51:24,980
and

1186
00:51:31,880 --> 00:51:34,380
than just

1187
00:51:34,380 --> 00:51:35,640
and

1188
00:51:35,640 --> 00:51:38,760
so how to compose the probability the

1189
00:51:38,760 --> 00:51:40,680
property is depends on the Travel

1190
00:51:40,680 --> 00:51:42,359
variables for absolute

1191
00:51:42,359 --> 00:51:45,119
the upper and the lower terms of input

1192
00:51:45,119 --> 00:51:46,440
and outputation

1193
00:51:46,440 --> 00:51:48,140
is the best

1194
00:51:48,140 --> 00:51:52,859
variable and infected we found in my

1195
00:51:52,859 --> 00:51:55,020
possible okay and we need to compose the

1196
00:51:55,020 --> 00:51:58,460
social foreign

1197
00:51:58,579 --> 00:52:01,020
possible probability

1198
00:52:01,020 --> 00:52:04,260
and we work both on includes the

1199
00:52:04,260 --> 00:52:06,920
value the probability

1200
00:52:06,920 --> 00:52:11,420
five binary variable and 33

1201
00:52:11,420 --> 00:52:14,280
and we also add a

1202
00:52:14,280 --> 00:52:17,960
function to answer that the probability

1203
00:52:17,960 --> 00:52:22,400
is greater than total minus

1204
00:52:22,579 --> 00:52:24,420
527

1205
00:52:24,420 --> 00:52:26,839
and

1206
00:52:27,980 --> 00:52:30,900
for the objective function we want to

1207
00:52:30,900 --> 00:52:34,380
optimize the complexity object but I

1208
00:52:34,380 --> 00:52:36,720
have to conclude so we can use an

1209
00:52:36,720 --> 00:52:38,819
approximation

1210
00:52:38,819 --> 00:52:43,500
so what's them faster to the complexity

1211
00:52:43,500 --> 00:52:46,680
here in our opinion if the vectors type

1212
00:52:46,680 --> 00:52:49,440
of the Blendtec and the property of the

1213
00:52:49,440 --> 00:52:53,760
Mysteries so we will maximize the this

1214
00:52:53,760 --> 00:52:57,300
function for the

1215
00:52:57,300 --> 00:53:00,559
or the optical function

1216
00:53:01,800 --> 00:53:04,859
actually our model is very slow and we

1217
00:53:04,859 --> 00:53:07,559
impossible to serve as a better part so

1218
00:53:07,559 --> 00:53:11,220
we need to reject the first way by

1219
00:53:11,220 --> 00:53:13,500
reject the

1220
00:53:13,500 --> 00:53:17,880
number of accidents so

1221
00:53:17,880 --> 00:53:21,780
yes statistics

1222
00:53:25,740 --> 00:53:29,640
so we found a better attack and

1223
00:53:29,640 --> 00:53:32,299
sometimes

1224
00:53:37,859 --> 00:53:40,400
and

1225
00:53:41,900 --> 00:53:45,740
so we use the same lowercase

1226
00:53:45,740 --> 00:53:47,960
that's cause

1227
00:53:47,960 --> 00:53:51,740
it's a better friend

1228
00:53:51,740 --> 00:53:53,280
help

1229
00:53:53,280 --> 00:53:56,400
and that's the reason why the small

1230
00:53:56,400 --> 00:54:01,280
chain is the may lead to a better type

1231
00:54:02,040 --> 00:54:06,300
finally I will summarize our football a

1232
00:54:06,300 --> 00:54:08,780
new advice

1233
00:54:09,619 --> 00:54:12,540
to build with non-linear Keys as well

1234
00:54:12,540 --> 00:54:16,260
and without a need to effect again 298

1235
00:54:16,260 --> 00:54:20,640
1992 it's comparables 3252 I'm lower

1236
00:54:20,640 --> 00:54:22,859
than the 10 members of the equipment

1237
00:54:22,859 --> 00:54:26,339
over two weeks and we also recovery on

1238
00:54:26,339 --> 00:54:29,759
AES 266

1239
00:54:29,880 --> 00:54:31,619
and defense

1240
00:54:31,619 --> 00:54:34,380
a little more detail

1241
00:54:34,380 --> 00:54:37,319
how people are yes

1242
00:54:37,319 --> 00:54:39,240
and every

1243
00:54:39,240 --> 00:54:40,680
so

1244
00:54:40,680 --> 00:54:45,440
puzzle advancements or any questions

1245
00:54:58,890 --> 00:55:01,989
[Music]

1246
00:55:02,400 --> 00:55:06,260
okay so then oh

1247
00:55:07,079 --> 00:55:09,599
can I ask is this possible to apply your

1248
00:55:09,599 --> 00:55:12,420
Technique to as128 or other AES based

1249
00:55:12,420 --> 00:55:13,800
Cipher

1250
00:55:13,800 --> 00:55:15,660
because that was the question so

1251
00:55:15,660 --> 00:55:18,859
actually our model is

1252
00:55:18,859 --> 00:55:25,220
but for a year 1990 yes so it's it's

1253
00:55:25,220 --> 00:55:28,260
very slow and you don't know how to

1254
00:55:28,260 --> 00:55:32,240
reset the suspective files

1255
00:55:34,020 --> 00:55:37,200
they're not values but they are in order

1256
00:55:37,200 --> 00:55:40,939
to improve this model because

1257
00:55:44,220 --> 00:55:46,559
okay so let's thanks the speaker and all

1258
00:55:46,559 --> 00:55:49,400
the speaker of this session

1259
00:56:52,200 --> 00:56:54,919
foreign

1260
01:01:08,640 --> 01:01:11,180
foreign

1261
01:09:39,540 --> 01:09:42,540
foreign

1262
01:11:28,700 --> 01:11:30,800
[Music]

1263
01:11:30,800 --> 01:11:34,219
and you can see

1264
01:12:16,679 --> 01:12:20,540
foreign foreign

1265
01:12:22,000 --> 01:12:25,119
[Music]

1266
01:12:54,900 --> 01:12:55,960
foreign

1267
01:12:55,960 --> 01:12:59,119
[Music]

1268
01:13:14,810 --> 01:13:18,009
[Music]

1269
01:13:29,340 --> 01:13:30,980
[Music]

1270
01:13:30,980 --> 01:13:34,040
each other

1271
01:13:35,810 --> 01:13:38,979
[Music]

1272
01:13:41,239 --> 01:13:44,718
so how do I

1273
01:13:50,940 --> 01:13:54,780
okay hello it's time to start uh welcome

1274
01:13:54,780 --> 01:13:56,820
to the session

1275
01:13:56,820 --> 01:13:58,679
um this is a session for zero knowledge

1276
01:13:58,679 --> 01:14:00,239
one

1277
01:14:00,239 --> 01:14:04,040
and then we have three talks here

1278
01:14:04,460 --> 01:14:07,199
during this session

1279
01:14:07,199 --> 01:14:11,340
okay we start with uh should leave zero

1280
01:14:11,340 --> 01:14:15,000
knowledge proofs and signatures by ARA

1281
01:14:15,000 --> 01:14:17,420
Saloon

1282
01:14:18,900 --> 01:14:21,179
thank you for the introduction uh so

1283
01:14:21,179 --> 01:14:22,860
this is Joint work

1284
01:14:22,860 --> 01:14:25,140
this is Joint work with Joseph Bono and

1285
01:14:25,140 --> 01:14:27,659
Jeremy Clark

1286
01:14:27,659 --> 01:14:29,760
so imagine you signed something on a

1287
01:14:29,760 --> 01:14:32,760
piece of paper with disappearing ink

1288
01:14:32,760 --> 01:14:34,560
um whatever you signed would vanish

1289
01:14:34,560 --> 01:14:36,719
after some time right you could write a

1290
01:14:36,719 --> 01:14:39,060
proof on a paper with disappearing ink

1291
01:14:39,060 --> 01:14:40,860
and showed someone that it could vanish

1292
01:14:40,860 --> 01:14:43,199
before they show it to someone else so

1293
01:14:43,199 --> 01:14:47,000
the goal of our work is to emulate this

