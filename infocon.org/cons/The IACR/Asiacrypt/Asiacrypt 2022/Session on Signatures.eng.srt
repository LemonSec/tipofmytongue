1
00:00:00,000 --> 00:00:02,639
to the signatures session the second

2
00:00:02,639 --> 00:00:05,339
session this morning that will consist

3
00:00:05,339 --> 00:00:06,660
of four talks

4
00:00:06,660 --> 00:00:08,760
um so the first talk is going to be on

5
00:00:08,760 --> 00:00:10,260
rejection something in yubashes

6
00:00:10,260 --> 00:00:15,440
signature scheme uh by uh

7
00:00:17,240 --> 00:00:20,820
and uh Julia is going to give the talk

8
00:00:20,820 --> 00:00:23,660
please go ahead

9
00:00:28,880 --> 00:00:32,460
so thank you for the introduction so

10
00:00:32,460 --> 00:00:36,140
this is Joint work with honorable

11
00:00:36,140 --> 00:00:38,700
and this time you understand what

12
00:00:38,700 --> 00:00:41,219
remains with the Target and plastic gun

13
00:00:41,219 --> 00:00:43,219
in the abstract video

14
00:00:43,219 --> 00:00:46,379
so just to Briefly summarize the work

15
00:00:46,379 --> 00:00:50,579
what we tried to do is optimize the

16
00:00:50,579 --> 00:00:54,239
fiately Bots Paradigm in the lattice

17
00:00:54,239 --> 00:00:55,320
setting

18
00:00:55,320 --> 00:00:57,780
uh we basically try to optimize

19
00:00:57,780 --> 00:01:00,120
everything we could think of so the

20
00:01:00,120 --> 00:01:04,319
runtime and the signature size is

21
00:01:04,319 --> 00:01:07,439
we did so by formally studying how

22
00:01:07,439 --> 00:01:10,080
rejection sampling is used in this

23
00:01:10,080 --> 00:01:11,420
setting

24
00:01:11,420 --> 00:01:14,720
and spoiler alerts here are our results

25
00:01:14,720 --> 00:01:18,540
so basically runtime is optimal and

26
00:01:18,540 --> 00:01:20,580
compactness we have some lower bounds

27
00:01:20,580 --> 00:01:22,439
and how to reach them because they were

28
00:01:22,439 --> 00:01:25,220
not reached

29
00:01:25,220 --> 00:01:28,560
uh and last question is why we were

30
00:01:28,560 --> 00:01:31,080
interested in this product in the first

31
00:01:31,080 --> 00:01:32,100
place

32
00:01:32,100 --> 00:01:35,939
so generic motivation is delicium which

33
00:01:35,939 --> 00:01:39,540
is a future PQ standard from the list

34
00:01:39,540 --> 00:01:41,939
it's implementing this feature here with

35
00:01:41,939 --> 00:01:43,860
the words paradigm

36
00:01:43,860 --> 00:01:47,400
and more broadly rejection sampling is

37
00:01:47,400 --> 00:01:50,460
an interesting uh technique that's been

38
00:01:50,460 --> 00:01:52,500
used in cryptography in lots of

39
00:01:52,500 --> 00:01:54,720
different places so we thought that it

40
00:01:54,720 --> 00:01:56,939
could be interesting to like open the

41
00:01:56,939 --> 00:02:00,720
black box to see how it was working and

42
00:02:00,720 --> 00:02:04,700
if it was actually suited to our needs

43
00:02:04,700 --> 00:02:07,979
so I'm going to briefly recall the

44
00:02:07,979 --> 00:02:09,959
signature scheme

45
00:02:09,959 --> 00:02:13,080
uh then I move to how we minimize the

46
00:02:13,080 --> 00:02:15,480
number of rejects so how to optimize the

47
00:02:15,480 --> 00:02:18,239
runtime and then I'll show you how to

48
00:02:18,239 --> 00:02:21,120
minimize this image or size

49
00:02:21,120 --> 00:02:23,520
okay so let's start with the signature

50
00:02:23,520 --> 00:02:26,099
scheme which will be a bit more generic

51
00:02:26,099 --> 00:02:27,959
than when we that's what we could you

52
00:02:27,959 --> 00:02:30,599
could have seen before

53
00:02:30,599 --> 00:02:32,879
um so the scheme is relying on the short

54
00:02:32,879 --> 00:02:35,160
integer solution problem the most

55
00:02:35,160 --> 00:02:37,260
important thing here is basically that

56
00:02:37,260 --> 00:02:39,900
this problem relies on the shortness of

57
00:02:39,900 --> 00:02:42,140
some vector

58
00:02:42,140 --> 00:02:45,840
and the smaller this Vector is smaller

59
00:02:45,840 --> 00:02:48,120
the bound beta is well the harder the

60
00:02:48,120 --> 00:02:50,760
problems become it will have some effect

61
00:02:50,760 --> 00:02:54,120
in the following of the talk

62
00:02:54,120 --> 00:02:56,459
so let's go uh here's the key generation

63
00:02:56,459 --> 00:03:00,180
algorithm you take a random Matrix a a

64
00:03:00,180 --> 00:03:02,760
small a small Matrix S or some meaning

65
00:03:02,760 --> 00:03:06,140
of small and you get the secret key

66
00:03:06,140 --> 00:03:08,580
verification key will be a and an a

67
00:03:08,580 --> 00:03:10,500
times s

68
00:03:10,500 --> 00:03:14,400
okay this signing algorithm asks you to

69
00:03:14,400 --> 00:03:17,640
First Take a short vector or Y from some

70
00:03:17,640 --> 00:03:20,159
generic distribution so that's where

71
00:03:20,159 --> 00:03:22,860
we'll be able then to play uh by

72
00:03:22,860 --> 00:03:25,260
changing the distribution Q will get

73
00:03:25,260 --> 00:03:27,180
different signature sizes so it's really

74
00:03:27,180 --> 00:03:28,560
important

75
00:03:28,560 --> 00:03:31,860
and then you have the following formula

76
00:03:31,860 --> 00:03:35,519
for the signature uh most importantly so

77
00:03:35,519 --> 00:03:37,319
you're going to compute some challenge C

78
00:03:37,319 --> 00:03:40,080
and the answer to the challenge is the

79
00:03:40,080 --> 00:03:44,459
vector Z which is y plus s times C

80
00:03:44,459 --> 00:03:48,000
I don't have a very time not a need to

81
00:03:48,000 --> 00:03:51,599
show you the verification algorithm but

82
00:03:51,599 --> 00:03:53,879
the only thing I need to we need to know

83
00:03:53,879 --> 00:03:56,940
is that as long as this Vector Z has

84
00:03:56,940 --> 00:03:58,980
some bounded Norm

85
00:03:58,980 --> 00:04:00,959
then we can make a verification

86
00:04:00,959 --> 00:04:03,780
algorithm that makes the scheme correct

87
00:04:03,780 --> 00:04:06,379
if you want some concrete instantiation

88
00:04:06,379 --> 00:04:09,299
well previous Works instantiated queue

89
00:04:09,299 --> 00:04:11,099
with gaussian distributions or what I

90
00:04:11,099 --> 00:04:12,480
will call hypercube uniform

91
00:04:12,480 --> 00:04:14,099
distributions

92
00:04:14,099 --> 00:04:16,798
and if we keep it like that then the

93
00:04:16,798 --> 00:04:20,040
scheme is not secure okay because we

94
00:04:20,040 --> 00:04:21,918
don't have a Bots yet

95
00:04:21,918 --> 00:04:25,020
and as you can see Z is leaking the

96
00:04:25,020 --> 00:04:26,220
secret key

97
00:04:26,220 --> 00:04:27,600
yeah

98
00:04:27,600 --> 00:04:29,280
so

99
00:04:29,280 --> 00:04:31,800
ideally what we would like to have is to

100
00:04:31,800 --> 00:04:34,440
make sure that Z is independent from the

101
00:04:34,440 --> 00:04:37,020
secret so we would like z to follow some

102
00:04:37,020 --> 00:04:39,180
kind of Target distribution B which is

103
00:04:39,180 --> 00:04:40,800
independent from s

104
00:04:40,800 --> 00:04:43,259
and there are two main ways to achieve

105
00:04:43,259 --> 00:04:46,380
that uh the first technique is flooding

106
00:04:46,380 --> 00:04:48,780
if you take Q with a very large standard

107
00:04:48,780 --> 00:04:51,900
deviation then the shift as time C is

108
00:04:51,900 --> 00:04:57,180
almost unnoticeable and then uh yeah Z

109
00:04:57,180 --> 00:04:58,860
is almost independent from the secrets

110
00:04:58,860 --> 00:05:01,800
but then you get a very large gamma

111
00:05:01,800 --> 00:05:03,960
which basically drives the size of the

112
00:05:03,960 --> 00:05:06,000
signature so that's not what we want

113
00:05:06,000 --> 00:05:08,400
the other technique that we will discuss

114
00:05:08,400 --> 00:05:10,620
is rejection sampling

115
00:05:10,620 --> 00:05:13,740
but in both cases as soon as signature

116
00:05:13,740 --> 00:05:17,340
is uncorrelated with the secret key then

117
00:05:17,340 --> 00:05:20,580
it basically means that you cannot query

118
00:05:20,580 --> 00:05:22,680
the signature algorithm because those

119
00:05:22,680 --> 00:05:25,979
two signatures are uninteresting and

120
00:05:25,979 --> 00:05:28,560
then uh the signature

121
00:05:28,560 --> 00:05:30,780
is secure

122
00:05:30,780 --> 00:05:32,820
okay

123
00:05:32,820 --> 00:05:35,940
so now let's move to how we use

124
00:05:35,940 --> 00:05:37,680
rejection sampling how it's defined and

125
00:05:37,680 --> 00:05:40,199
everything so in the following I will

126
00:05:40,199 --> 00:05:42,840
give some kind of broader setting which

127
00:05:42,840 --> 00:05:46,080
which can applies to actually

128
00:05:46,080 --> 00:05:49,919
anything and it can be not related to

129
00:05:49,919 --> 00:05:51,720
signatures

130
00:05:51,720 --> 00:05:54,539
so the boiler context is as follows I

131
00:05:54,539 --> 00:05:56,940
give you access to lots of samples that

132
00:05:56,940 --> 00:06:00,120
all follows the same Source distribution

133
00:06:00,120 --> 00:06:04,380
and your task is to find any sample that

134
00:06:04,380 --> 00:06:08,280
is following some targets distribution

135
00:06:08,280 --> 00:06:10,860
and of course you want to use as few

136
00:06:10,860 --> 00:06:12,960
samples as possible because each sample

137
00:06:12,960 --> 00:06:15,300
will be one signature

138
00:06:15,300 --> 00:06:17,100
and of course you're not allowed to

139
00:06:17,100 --> 00:06:18,960
modify the samples because those are

140
00:06:18,960 --> 00:06:20,699
signatures so I mean at some point you

141
00:06:20,699 --> 00:06:22,500
will verify them so if you modify the

142
00:06:22,500 --> 00:06:23,940
signatures maybe the verification

143
00:06:23,940 --> 00:06:26,759
algorithm will not pass anymore

144
00:06:26,759 --> 00:06:29,819
and so while I explain how to do so we

145
00:06:29,819 --> 00:06:32,340
will also see how to so minimize the

146
00:06:32,340 --> 00:06:34,680
average number of samples you need which

147
00:06:34,680 --> 00:06:36,720
basically drives the runtime of the

148
00:06:36,720 --> 00:06:40,500
signing algorithm in your HTTP signature

149
00:06:40,500 --> 00:06:44,160
uh so the technique the generic

150
00:06:44,160 --> 00:06:46,800
technique which we will call imperfect

151
00:06:46,800 --> 00:06:48,360
rejection sampling

152
00:06:48,360 --> 00:06:51,600
is as follows so you have the source

153
00:06:51,600 --> 00:06:53,819
distribution detailed up and you're

154
00:06:53,819 --> 00:06:56,660
going to scale it by some Factor M until

155
00:06:56,660 --> 00:06:59,759
almost all of the blue curve is over the

156
00:06:59,759 --> 00:07:01,860
green gel okay

157
00:07:01,860 --> 00:07:04,979
then imperfect rejection sampling it

158
00:07:04,979 --> 00:07:07,139
tells you it can be seen as some kind of

159
00:07:07,139 --> 00:07:09,419
Monte Carlo technique

160
00:07:09,419 --> 00:07:12,000
so you get a sample X it gives you some

161
00:07:12,000 --> 00:07:13,440
ad system

162
00:07:13,440 --> 00:07:16,080
and with some probability which

163
00:07:16,080 --> 00:07:18,720
represents sampling and Alternate

164
00:07:18,720 --> 00:07:20,340
you will keep it or not

165
00:07:20,340 --> 00:07:23,580
to keep it it you only keep it if it's

166
00:07:23,580 --> 00:07:26,099
under the green card here or else should

167
00:07:26,099 --> 00:07:28,860
we start okay and you will get something

168
00:07:28,860 --> 00:07:31,199
that almost follows the distribution B

169
00:07:31,199 --> 00:07:35,360
and operate will be close enough

170
00:07:35,699 --> 00:07:39,900
uh to study how Big M must be we

171
00:07:39,900 --> 00:07:42,060
introduced something that we call the

172
00:07:42,060 --> 00:07:43,979
smooth string Divergence it can be seen

173
00:07:43,979 --> 00:07:46,139
as generalization of the Rainy

174
00:07:46,139 --> 00:07:48,479
Divergence uh it there's a lot of math

175
00:07:48,479 --> 00:07:51,780
here but it just means you you take the

176
00:07:51,780 --> 00:07:53,479
smallest and possible such that

177
00:07:53,479 --> 00:07:57,539
everything up to some Epsilon Parts is

178
00:07:57,539 --> 00:08:00,599
under the blue count

179
00:08:00,599 --> 00:08:04,080
okay we can take an example for instance

180
00:08:04,080 --> 00:08:06,479
to see what is going on so if you take

181
00:08:06,479 --> 00:08:08,880
two gaussian distributions but one is

182
00:08:08,880 --> 00:08:10,800
slightly shifted with respect to the

183
00:08:10,800 --> 00:08:11,720
over

184
00:08:11,720 --> 00:08:13,800
what you can

185
00:08:13,800 --> 00:08:16,740
do is remove the left part the tail on

186
00:08:16,740 --> 00:08:17,580
the left

187
00:08:17,580 --> 00:08:20,340
and then you can slightly shift the blue

188
00:08:20,340 --> 00:08:24,180
one until it's over the the green one

189
00:08:24,180 --> 00:08:27,479
and of course the larger Epsilon will be

190
00:08:27,479 --> 00:08:30,240
the more of the tail you remove and so

191
00:08:30,240 --> 00:08:34,339
the smaller and you will need to take

192
00:08:34,659 --> 00:08:35,880
[Music]

193
00:08:35,880 --> 00:08:38,640
we actually have a concrete formula that

194
00:08:38,640 --> 00:08:41,399
we compute or it's just that it's it's

195
00:08:41,399 --> 00:08:44,839
too big right here

196
00:08:44,880 --> 00:08:48,060
okay uh so then we can so then we

197
00:08:48,060 --> 00:08:50,899
studied how efficient this technique is

198
00:08:50,899 --> 00:08:53,880
so first we look at the runtime so there

199
00:08:53,880 --> 00:08:56,820
we have this computation so assuming

200
00:08:56,820 --> 00:08:57,600
that

201
00:08:57,600 --> 00:09:01,200
you are doing things correctly so you

202
00:09:01,200 --> 00:09:03,660
took M big enough

203
00:09:03,660 --> 00:09:05,820
then your average number of samples will

204
00:09:05,820 --> 00:09:09,360
be at most M over 1 minus Epsilon and if

205
00:09:09,360 --> 00:09:11,279
you focus on the case where Epsilon is

206
00:09:11,279 --> 00:09:15,180
zero then this is actually optimal even

207
00:09:15,180 --> 00:09:17,040
if you were to do different strategies

208
00:09:17,040 --> 00:09:19,740
maybe go back to previous samples or

209
00:09:19,740 --> 00:09:23,760
whatever this would not be faster and we

210
00:09:23,760 --> 00:09:26,040
don't really have a

211
00:09:26,040 --> 00:09:28,800
uh the same result for non-zero Epsilon

212
00:09:28,800 --> 00:09:29,700
but

213
00:09:29,700 --> 00:09:32,040
Epsilon will typically be 2 to the minus

214
00:09:32,040 --> 00:09:35,640
64 so it should even if

215
00:09:35,640 --> 00:09:37,680
imperfect rejection sampling is not

216
00:09:37,680 --> 00:09:39,360
optimal

217
00:09:39,360 --> 00:09:41,640
um we don't think it's worth looking for

218
00:09:41,640 --> 00:09:44,940
a more optimal strategy

219
00:09:44,940 --> 00:09:46,860
and something that will help me move to

220
00:09:46,860 --> 00:09:49,320
the next part is we study the quality of

221
00:09:49,320 --> 00:09:51,899
the resulting distribution which is not

222
00:09:51,899 --> 00:09:53,899
exactly the target's deep

223
00:09:53,899 --> 00:09:56,220
previously people looked at the

224
00:09:56,220 --> 00:09:58,260
statistical distance between the two

225
00:09:58,260 --> 00:10:00,360
distributions we choose to look at the

226
00:10:00,360 --> 00:10:01,800
Rainy Divergence because running

227
00:10:01,800 --> 00:10:03,500
Divergence is

228
00:10:03,500 --> 00:10:06,779
uh in general more have more helpful and

229
00:10:06,779 --> 00:10:08,760
leads to tighter security proofs in the

230
00:10:08,760 --> 00:10:10,200
case of signatures

231
00:10:10,200 --> 00:10:12,959
so that's what we did

232
00:10:12,959 --> 00:10:16,200
okay so now we move to we move back to

233
00:10:16,200 --> 00:10:17,700
the signature and we move to a different

234
00:10:17,700 --> 00:10:19,860
topic because now we know that rejection

235
00:10:19,860 --> 00:10:23,100
sampling uh works and that is

236
00:10:23,100 --> 00:10:25,740
it is quite fast

237
00:10:25,740 --> 00:10:27,779
so we have the following optimization

238
00:10:27,779 --> 00:10:29,160
problem

239
00:10:29,160 --> 00:10:30,540
okay

240
00:10:30,540 --> 00:10:33,899
I'm going to details all of those terms

241
00:10:33,899 --> 00:10:36,240
so

242
00:10:36,240 --> 00:10:38,899
first we are going to fix some value M

243
00:10:38,899 --> 00:10:42,480
it represents actually how much resource

244
00:10:42,480 --> 00:10:44,220
you want to put inside the signature

245
00:10:44,220 --> 00:10:46,620
skin it will be the average number of

246
00:10:46,620 --> 00:10:48,000
Rejects

247
00:10:48,000 --> 00:10:50,399
and you want rejection sampling to work

248
00:10:50,399 --> 00:10:53,279
whatever shift you will have so you need

249
00:10:53,279 --> 00:10:55,680
to take the maximum need to take M

250
00:10:55,680 --> 00:10:58,440
bigger than the maximum uh

251
00:10:58,440 --> 00:11:00,480
of all possible shifts that you will

252
00:11:00,480 --> 00:11:02,940
have okay

253
00:11:02,940 --> 00:11:06,420
next is why do we take Epsilon at most

254
00:11:06,420 --> 00:11:08,760
one over Qs which is the number of

255
00:11:08,760 --> 00:11:11,279
signature queries it's because if you

256
00:11:11,279 --> 00:11:15,000
remember the quality analysis uh when

257
00:11:15,000 --> 00:11:17,579
you plug in the fact that you will do Qs

258
00:11:17,579 --> 00:11:20,040
signatures and everything then you do

259
00:11:20,040 --> 00:11:22,800
the security proof so you indeed find

260
00:11:22,800 --> 00:11:24,720
the title security proof with rainy

261
00:11:24,720 --> 00:11:26,279
Divergence rather than statistical

262
00:11:26,279 --> 00:11:28,440
distance and it allows you to take

263
00:11:28,440 --> 00:11:32,720
Epsilon a bigger phone over Qs

264
00:11:33,000 --> 00:11:34,740
okay

265
00:11:34,740 --> 00:11:37,440
uh then the first condition that we have

266
00:11:37,440 --> 00:11:40,079
here if you remember it's actually the

267
00:11:40,079 --> 00:11:43,939
condition that you need for correctness

268
00:11:43,980 --> 00:11:46,560
okay so this defines the gamma and

269
00:11:46,560 --> 00:11:48,240
actually you want to minimize it because

270
00:11:48,240 --> 00:11:51,060
it's really what drives uh the signature

271
00:11:51,060 --> 00:11:52,860
size

272
00:11:52,860 --> 00:11:55,860
uh because here we just omit the size of

273
00:11:55,860 --> 00:11:58,440
the challenge because it's just a hash

274
00:11:58,440 --> 00:12:00,300
so we don't have anything already

275
00:12:00,300 --> 00:12:02,579
anything we can do on it

276
00:12:02,579 --> 00:12:05,240
so we're just going to minimize camera

277
00:12:05,240 --> 00:12:07,920
and there is some kind of disco effect

278
00:12:07,920 --> 00:12:10,860
because when you minimize gamma if you

279
00:12:10,860 --> 00:12:11,839
remember

280
00:12:11,839 --> 00:12:14,880
uh I said that the CIS problem gets

281
00:12:14,880 --> 00:12:17,220
harder when you have a smaller bound

282
00:12:17,220 --> 00:12:19,740
so you have a smaller gamma crypto

283
00:12:19,740 --> 00:12:23,279
analysis becomes harder and then you can

284
00:12:23,279 --> 00:12:25,320
actually drop some Dimensions or

285
00:12:25,320 --> 00:12:26,820
something to keep the same level of

286
00:12:26,820 --> 00:12:32,000
security so it gets even better

287
00:12:32,060 --> 00:12:35,579
okay and our lower bound is that when

288
00:12:35,579 --> 00:12:38,279
you say zero Epsilon equals zero

289
00:12:38,279 --> 00:12:40,700
then if you want to satisfy everything

290
00:12:40,700 --> 00:12:43,380
you have the following lower bound which

291
00:12:43,380 --> 00:12:45,899
is related to the maximum size of the

292
00:12:45,899 --> 00:12:48,959
bound of the shift

293
00:12:48,959 --> 00:12:51,779
and we can now take a look at the

294
00:12:51,779 --> 00:12:54,779
choices of distributions that were done

295
00:12:54,779 --> 00:12:57,380
in previous works to see if they reach

296
00:12:57,380 --> 00:13:01,019
this lower bound or nuts

297
00:13:01,019 --> 00:13:04,560
uh so the two two choices that were made

298
00:13:04,560 --> 00:13:06,600
if you remember it's hypercubule form

299
00:13:06,600 --> 00:13:08,480
which is the choice made in division

300
00:13:08,480 --> 00:13:11,579
because you have an easy I mean it's

301
00:13:11,579 --> 00:13:16,200
easy to sample from ranges it's easy to

302
00:13:16,200 --> 00:13:19,260
check if you have to reject or not but

303
00:13:19,260 --> 00:13:22,320
you have a bad

304
00:13:22,320 --> 00:13:25,200
uh compactness and this compactness is

305
00:13:25,200 --> 00:13:29,040
not even scaling when Epsilon grows

306
00:13:29,040 --> 00:13:30,540
so it's

307
00:13:30,540 --> 00:13:33,019
not the distribution we are looking for

308
00:13:33,019 --> 00:13:36,240
uh so maybe gaussian is better uh

309
00:13:36,240 --> 00:13:38,639
because here it's a bit harder to sample

310
00:13:38,639 --> 00:13:40,440
and reject you need to compute some

311
00:13:40,440 --> 00:13:44,639
exponential Etc and actually you can't

312
00:13:44,639 --> 00:13:47,220
use gaussians in a perfect setting when

313
00:13:47,220 --> 00:13:49,019
Epsilon is zero so you don't switch the

314
00:13:49,019 --> 00:13:50,399
lower bound either

315
00:13:50,399 --> 00:13:53,040
so we don't really know we have a much

316
00:13:53,040 --> 00:13:54,959
better value it's scaling very well with

317
00:13:54,959 --> 00:13:57,420
Epsilon but since we're starting from

318
00:13:57,420 --> 00:13:59,519
plus infinity we don't know if the

319
00:13:59,519 --> 00:14:01,980
scaling is optimal or not

320
00:14:01,980 --> 00:14:03,300
okay

321
00:14:03,300 --> 00:14:06,060
so we actually have a proposal which is

322
00:14:06,060 --> 00:14:08,940
to use the uh

323
00:14:08,940 --> 00:14:12,360
uniform distribution in hyperboles

324
00:14:12,360 --> 00:14:15,060
because if we do so so

325
00:14:15,060 --> 00:14:16,860
we see that when Epsilon is zero we

326
00:14:16,860 --> 00:14:19,620
reached we reached the lower bound

327
00:14:19,620 --> 00:14:22,079
and when Epsilon and it's actually

328
00:14:22,079 --> 00:14:24,360
scaling with Epsilon at least as good as

329
00:14:24,360 --> 00:14:27,720
the aggression so it's quite interesting

330
00:14:27,720 --> 00:14:29,880
uh we also keep the deterministic

331
00:14:29,880 --> 00:14:32,579
rejection test so that's also that's

332
00:14:32,579 --> 00:14:34,700
like a good bonus

333
00:14:34,700 --> 00:14:37,860
and to give you some intuition onto why

334
00:14:37,860 --> 00:14:39,600
we do this choice

335
00:14:39,600 --> 00:14:42,300
well it's because we are looking at

336
00:14:42,300 --> 00:14:44,279
euclidian norms so it's natural to

337
00:14:44,279 --> 00:14:47,220
replace hypercubes which are fitting

338
00:14:47,220 --> 00:14:48,959
with infinite Norm

339
00:14:48,959 --> 00:14:51,420
with hyperboles which are good for

340
00:14:51,420 --> 00:14:53,220
nuclear unknown

341
00:14:53,220 --> 00:14:56,220
uh and also it is scaling well with

342
00:14:56,220 --> 00:14:58,019
Epsilon because we have some kind of

343
00:14:58,019 --> 00:14:59,579
nice geometry going on with

344
00:14:59,579 --> 00:15:03,138
hypospherical Caps or everything

345
00:15:03,360 --> 00:15:05,519
uh and then to put things into

346
00:15:05,519 --> 00:15:07,860
perspective we also looked at some

347
00:15:07,860 --> 00:15:10,320
practical parameters because just it's

348
00:15:10,320 --> 00:15:12,180
asymptotics could not let us determine

349
00:15:12,180 --> 00:15:14,760
what what was better between oceans and

350
00:15:14,760 --> 00:15:17,519
hyperboles and actually practical

351
00:15:17,519 --> 00:15:20,160
parameters don't help either because

352
00:15:20,160 --> 00:15:22,320
they are very similar

353
00:15:22,320 --> 00:15:25,980
uh to compute these parameters we based

354
00:15:25,980 --> 00:15:28,079
our computations on Division and the

355
00:15:28,079 --> 00:15:29,699
gaussian variants we introduced a

356
00:15:29,699 --> 00:15:32,880
hyperbole diagram just for computations

357
00:15:32,880 --> 00:15:34,760
of sizes

358
00:15:34,760 --> 00:15:37,199
and also those

359
00:15:37,199 --> 00:15:40,440
two last lines uh plug some all the

360
00:15:40,440 --> 00:15:41,459
improvements we've made in the

361
00:15:41,459 --> 00:15:42,660
computations

362
00:15:42,660 --> 00:15:45,720
so we have later Epsilon and also

363
00:15:45,720 --> 00:15:47,279
something I didn't say is that we

364
00:15:47,279 --> 00:15:49,139
slightly improved the computation of the

365
00:15:49,139 --> 00:15:51,420
smooth Divergence for gaussians so we

366
00:15:51,420 --> 00:15:54,600
can take them little bit smaller

367
00:15:54,600 --> 00:15:58,920
okay uh to wrap things up we have even

368
00:15:58,920 --> 00:16:01,560
more results in the paper so for

369
00:16:01,560 --> 00:16:03,839
instance we look at Bliss

370
00:16:03,839 --> 00:16:06,300
we also have some kind of compromise

371
00:16:06,300 --> 00:16:09,779
between rejection sampling and flooding

372
00:16:09,779 --> 00:16:11,940
and we also look at what we can do if we

373
00:16:11,940 --> 00:16:14,880
use continuous distributions

374
00:16:14,880 --> 00:16:17,160
uh because then we have even more

375
00:16:17,160 --> 00:16:20,100
choices for pmq so we looked at whether

376
00:16:20,100 --> 00:16:22,100
that was interesting or not

377
00:16:22,100 --> 00:16:24,660
so thank you for your attention and if

378
00:16:24,660 --> 00:16:25,980
you have any question I'll be happy to

379
00:16:25,980 --> 00:16:27,660
answer them

380
00:16:27,660 --> 00:16:30,660
foreign

381
00:16:42,360 --> 00:16:45,360
so maybe I'll start so we have a

382
00:16:45,360 --> 00:16:46,860
concrete proposal for actually

383
00:16:46,860 --> 00:16:50,040
instantiating the the sampling in

384
00:16:50,040 --> 00:16:52,320
so I guess it's the intersection between

385
00:16:52,320 --> 00:16:55,440
uh between the euclidean goal and the

386
00:16:55,440 --> 00:17:00,300
and the Z to the N that is

387
00:17:00,300 --> 00:17:03,540
so actually uh when we looked at those

388
00:17:03,540 --> 00:17:05,040
sizes

389
00:17:05,040 --> 00:17:07,859
uh so we are actually using

390
00:17:07,859 --> 00:17:11,459
wait okay we are actually using uh the

391
00:17:11,459 --> 00:17:13,500
uniform continuous ball

392
00:17:13,500 --> 00:17:15,720
and then when you want to instantiate

393
00:17:15,720 --> 00:17:18,540
that indeed you will I mean you have

394
00:17:18,540 --> 00:17:19,919
different ways of doing it you can

395
00:17:19,919 --> 00:17:23,939
either just uh intersect with c2dn or

396
00:17:23,939 --> 00:17:25,079
you can

397
00:17:25,079 --> 00:17:27,660
do some kind of discretization with

398
00:17:27,660 --> 00:17:31,260
maybe one over some big n is it to the n

399
00:17:31,260 --> 00:17:34,500
and of course the larger begin will be

400
00:17:34,500 --> 00:17:37,620
the closer you will be to this uh to

401
00:17:37,620 --> 00:17:39,840
this optimal sizes from the uniformical

402
00:17:39,840 --> 00:17:42,500
hyperbole

403
00:17:42,780 --> 00:17:44,400
thank you

404
00:17:44,400 --> 00:17:47,240
um any other questions

405
00:17:51,419 --> 00:17:53,160
okay if not then let's thank the speaker

406
00:17:53,160 --> 00:17:55,460
again

407
00:18:14,179 --> 00:18:17,100
so our next talk is entitled

408
00:18:17,100 --> 00:18:20,820
um hook uh module module lip makes

409
00:18:20,820 --> 00:18:23,220
lattice signatures fast Compact and

410
00:18:23,220 --> 00:18:25,820
simpler

411
00:18:29,400 --> 00:18:32,940
oh no sorry it's a sphinx plus okay my

412
00:18:32,940 --> 00:18:35,400
apologies so it's uh recovering the

413
00:18:35,400 --> 00:18:39,140
tight security proof of sphinx Plus

414
00:18:45,980 --> 00:18:50,419
thing and I will get the talk

415
00:19:23,400 --> 00:19:25,440
thank you very much for the introduction

416
00:19:25,440 --> 00:19:28,140
so today I'm going to present a joint

417
00:19:28,140 --> 00:19:30,240
work with Andres Wilson on the

418
00:19:30,240 --> 00:19:32,160
recovering the tight security proof of

419
00:19:32,160 --> 00:19:34,980
strings plus so first we give we will

420
00:19:34,980 --> 00:19:38,700
give a brief disc uh description of uh

421
00:19:38,700 --> 00:19:41,340
things Pass construction and then we

422
00:19:41,340 --> 00:19:43,980
will analyze the security flow in the

423
00:19:43,980 --> 00:19:45,480
previous proof of security of things

424
00:19:45,480 --> 00:19:48,360
plus then we will discuss the key ideas

425
00:19:48,360 --> 00:19:51,900
that helps us to fix the proof and we

426
00:19:51,900 --> 00:19:55,080
will finish our talk uh by analysis of

427
00:19:55,080 --> 00:19:57,120
hash functions and the properties used

428
00:19:57,120 --> 00:20:00,240
to prove the security of sphinx

429
00:20:00,240 --> 00:20:02,160
so for those who don't know strings

430
00:20:02,160 --> 00:20:04,200
first is a hash based digital signature

431
00:20:04,200 --> 00:20:07,620
scheme and it was recently chosen by

432
00:20:07,620 --> 00:20:09,660
list for standardization as a post

433
00:20:09,660 --> 00:20:11,820
Quantum alternative for Signature

434
00:20:11,820 --> 00:20:14,179
schemes

435
00:20:14,179 --> 00:20:17,820
the main uh the main reason why it was

436
00:20:17,820 --> 00:20:20,700
chosen since it is a very conservative

437
00:20:20,700 --> 00:20:25,100
and a secure choice and uh uh other

438
00:20:25,100 --> 00:20:27,780
signature schemes still rely on hashing

439
00:20:27,780 --> 00:20:30,720
and in strings plus nothing but a secure

440
00:20:30,720 --> 00:20:32,580
hash function is required

441
00:20:32,580 --> 00:20:37,700
uh so during the third round there was a

442
00:20:37,700 --> 00:20:40,440
there was a security flow found in the

443
00:20:40,440 --> 00:20:43,140
proof of security this law didn't lead

444
00:20:43,140 --> 00:20:46,140
to an attack uh there was still an

445
00:20:46,140 --> 00:20:48,500
untied proof which was still applicable

446
00:20:48,500 --> 00:20:50,360
but

447
00:20:50,360 --> 00:20:53,340
using that proof will lead to around 60

448
00:20:53,340 --> 00:20:55,320
bits of security loss

449
00:20:55,320 --> 00:20:57,720
so our aim was to recover a tight

450
00:20:57,720 --> 00:21:00,780
security proof and now we will discuss

451
00:21:00,780 --> 00:21:03,720
the strings plus construction how

452
00:21:03,720 --> 00:21:06,780
different building blocks are combined

453
00:21:06,780 --> 00:21:09,720
to obtain a more effective scheme and

454
00:21:09,720 --> 00:21:11,100
then we will come back to the security

455
00:21:11,100 --> 00:21:13,440
flow and how we fixed it

456
00:21:13,440 --> 00:21:15,780
so the first building block is the

457
00:21:15,780 --> 00:21:18,720
one-time signature scheme uh everything

458
00:21:18,720 --> 00:21:21,900
started with the Lampard scheme which is

459
00:21:21,900 --> 00:21:23,700
a one-time signature scheme we used to

460
00:21:23,700 --> 00:21:26,160
sign a one bit of information you have

461
00:21:26,160 --> 00:21:29,880
two secret values which are hashed the

462
00:21:29,880 --> 00:21:32,640
secret values from the secret key the

463
00:21:32,640 --> 00:21:34,919
hash values from the public key and to

464
00:21:34,919 --> 00:21:37,200
sign one bit of information you just use

465
00:21:37,200 --> 00:21:40,919
corresponding part of the secret key uh

466
00:21:40,919 --> 00:21:44,700
to verify the signature you hash it and

467
00:21:44,700 --> 00:21:45,960
check if it is equal to the

468
00:21:45,960 --> 00:21:47,700
corresponding part of the public key

469
00:21:47,700 --> 00:21:51,179
this can be expanded to get a signature

470
00:21:51,179 --> 00:21:54,000
scheme for m-bit messages but then you

471
00:21:54,000 --> 00:21:57,780
will need two n-bit uh secret values

472
00:21:57,780 --> 00:22:01,440
uh winter needs found a way to optimize

473
00:22:01,440 --> 00:22:05,820
this so in lemper scheme you have two

474
00:22:05,820 --> 00:22:07,799
hash values to sign one bit of

475
00:22:07,799 --> 00:22:10,080
information and then leverage him you

476
00:22:10,080 --> 00:22:11,100
have

477
00:22:11,100 --> 00:22:15,059
one has value design log W bits of

478
00:22:15,059 --> 00:22:16,140
information

479
00:22:16,140 --> 00:22:20,159
so here we have L secret values each of

480
00:22:20,159 --> 00:22:23,280
them I used to form a hash chain this is

481
00:22:23,280 --> 00:22:25,740
done by sequence sequentially hashing

482
00:22:25,740 --> 00:22:28,860
the secret value W minus one times

483
00:22:28,860 --> 00:22:31,320
and to send the message especially

484
00:22:31,320 --> 00:22:33,659
encoding is performed which is then

485
00:22:33,659 --> 00:22:36,600
represented as early values between 0

486
00:22:36,600 --> 00:22:40,140
and W minus 1 and the signature reveals

487
00:22:40,140 --> 00:22:42,659
the corresponding blocks in each of the

488
00:22:42,659 --> 00:22:45,360
chains to verify the signature you again

489
00:22:45,360 --> 00:22:47,700
perform the encoding it's base W

490
00:22:47,700 --> 00:22:50,580
representation that's that way you

491
00:22:50,580 --> 00:22:53,039
understand which positions are the

492
00:22:53,039 --> 00:22:55,919
signature blocks and you do the rest of

493
00:22:55,919 --> 00:22:57,900
the hashing to obtain the ends of the

494
00:22:57,900 --> 00:23:00,179
chains then you check if the ends of the

495
00:23:00,179 --> 00:23:02,159
chains are equal to the public key and

496
00:23:02,159 --> 00:23:05,299
if it's so then the signature is valid

497
00:23:05,299 --> 00:23:08,880
so the main security idea behind the

498
00:23:08,880 --> 00:23:11,520
what signature is that if you will if

499
00:23:11,520 --> 00:23:14,159
the attacker will Forge the signature he

500
00:23:14,159 --> 00:23:17,700
will need to find at least one block uh

501
00:23:17,700 --> 00:23:21,480
on a lower level in at least one chain

502
00:23:21,480 --> 00:23:24,240
uh so the second building block is the

503
00:23:24,240 --> 00:23:26,220
miracle trees so on this side you can

504
00:23:26,220 --> 00:23:28,860
see how they built they're built from

505
00:23:28,860 --> 00:23:31,320
the leaves you hash two values together

506
00:23:31,320 --> 00:23:33,840
and you do so until you get to the root

507
00:23:33,840 --> 00:23:37,620
of the tree in strings plus the leaves

508
00:23:37,620 --> 00:23:40,620
uh public use of one-time signature

509
00:23:40,620 --> 00:23:43,159
scheme in our case what's

510
00:23:43,159 --> 00:23:46,559
yes and another key feature of medical

511
00:23:46,559 --> 00:23:48,380
trees is authentication pass

512
00:23:48,380 --> 00:23:51,360
notification pass campaign nodes that

513
00:23:51,360 --> 00:23:53,700
help you to compute the root of the tree

514
00:23:53,700 --> 00:23:55,880
so on this slide

515
00:23:55,880 --> 00:23:58,740
you can see the purple leaf and the

516
00:23:58,740 --> 00:24:00,600
outification press for that leaf will

517
00:24:00,600 --> 00:24:03,720
contain the yellow nodes

518
00:24:03,720 --> 00:24:07,260
uh so using medical trees we can obtain

519
00:24:07,260 --> 00:24:09,480
multiple time signature scheme that

520
00:24:09,480 --> 00:24:12,419
allows us to sign the mess several

521
00:24:12,419 --> 00:24:16,140
messages uh you use an instance of

522
00:24:16,140 --> 00:24:18,000
one-time signature to sign the message

523
00:24:18,000 --> 00:24:22,200
and you also uh put the notification bus

524
00:24:22,200 --> 00:24:24,480
into the signature but this is a

525
00:24:24,480 --> 00:24:26,820
stateful scheme that means you have to

526
00:24:26,820 --> 00:24:28,620
keep track which instances you have

527
00:24:28,620 --> 00:24:31,320
already used and you should not use them

528
00:24:31,320 --> 00:24:32,419
twice

529
00:24:32,419 --> 00:24:35,700
now we're ready to get the whole things

530
00:24:35,700 --> 00:24:38,159
plus construction so

531
00:24:38,159 --> 00:24:40,140
uh Miracle trees are combined in

532
00:24:40,140 --> 00:24:42,299
so-called hyper tree so you have

533
00:24:42,299 --> 00:24:44,700
different different players and let's

534
00:24:44,700 --> 00:24:46,860
look at the top layer there you have the

535
00:24:46,860 --> 00:24:49,380
miracle tree which is built from uh one

536
00:24:49,380 --> 00:24:52,080
time signature instances they are used

537
00:24:52,080 --> 00:24:54,360
to sign the roots of the miracle trees

538
00:24:54,360 --> 00:24:58,320
from on the lower level and this goes on

539
00:24:58,320 --> 00:25:00,480
for example on the picture you can see

540
00:25:00,480 --> 00:25:03,600
two layers but this can be more layers

541
00:25:03,600 --> 00:25:06,179
there and the one-time signature

542
00:25:06,179 --> 00:25:08,220
instance is from the bottom layer I used

543
00:25:08,220 --> 00:25:11,159
to sign a few times signature public

544
00:25:11,159 --> 00:25:15,059
keys so few times signature scheme is a

545
00:25:15,059 --> 00:25:17,880
stateless scheme where you can assign a

546
00:25:17,880 --> 00:25:21,000
few signatures usually for example in

547
00:25:21,000 --> 00:25:23,760
things around eight times you can use it

548
00:25:23,760 --> 00:25:26,580
and then the security slowly decreases

549
00:25:26,580 --> 00:25:29,220
and then a few times signature scheme is

550
00:25:29,220 --> 00:25:31,679
then used to say in the message so the

551
00:25:31,679 --> 00:25:34,380
digest of the message determines which

552
00:25:34,380 --> 00:25:36,480
instance of few times signature schema

553
00:25:36,480 --> 00:25:38,880
is actually used and then the signature

554
00:25:38,880 --> 00:25:42,600
contains the fuel time signature uh the

555
00:25:42,600 --> 00:25:44,580
what signatures and the corresponding

556
00:25:44,580 --> 00:25:47,520
calcification pass to check the

557
00:25:47,520 --> 00:25:50,460
signature the verifier tries to compute

558
00:25:50,460 --> 00:25:53,460
the root of the miracle tree at the top

559
00:25:53,460 --> 00:25:56,880
level and if it's equal then the

560
00:25:56,880 --> 00:25:59,220
signature is valid

561
00:25:59,220 --> 00:26:01,500
so again this is there was a security

562
00:26:01,500 --> 00:26:04,559
flow in the proof and uh the secure the

563
00:26:04,559 --> 00:26:07,320
floor was in the part that proved what

564
00:26:07,320 --> 00:26:08,299
security

565
00:26:08,299 --> 00:26:12,840
uh so let's uh look at this in more

566
00:26:12,840 --> 00:26:14,640
details

567
00:26:14,640 --> 00:26:17,279
so first let's discuss how hashing is

568
00:26:17,279 --> 00:26:19,860
done in Sphinx Plus instead of using kit

569
00:26:19,860 --> 00:26:21,840
hash function so-called tweakable hash

570
00:26:21,840 --> 00:26:24,419
functions I used they take three inputs

571
00:26:24,419 --> 00:26:26,820
public parameter tweaks and the message

572
00:26:26,820 --> 00:26:29,640
and produce a Digest so the public

573
00:26:29,640 --> 00:26:31,799
parameter is a bit string that is a part

574
00:26:31,799 --> 00:26:34,460
of things plus public key

575
00:26:34,460 --> 00:26:38,159
and the same public parameter used in

576
00:26:38,159 --> 00:26:40,919
every tweakable hash function call for

577
00:26:40,919 --> 00:26:43,140
the same key pair

578
00:26:43,140 --> 00:26:47,220
and uh yes so the public parameter is

579
00:26:47,220 --> 00:26:50,039
there to separate different keys of

580
00:26:50,039 --> 00:26:52,919
different users and this is a step

581
00:26:52,919 --> 00:26:55,919
towards multi-user security then the

582
00:26:55,919 --> 00:26:58,039
second parameter is tweak

583
00:26:58,039 --> 00:27:00,960
the main idea of tweaker is that is

584
00:27:00,960 --> 00:27:03,000
different in every tweakable hash

585
00:27:03,000 --> 00:27:04,260
function call

586
00:27:04,260 --> 00:27:09,360
uh so uh it helps uh for to mitigate

587
00:27:09,360 --> 00:27:12,360
multi-target attacks so it performs kind

588
00:27:12,360 --> 00:27:15,000
of a domain separation so imagine we had

589
00:27:15,000 --> 00:27:17,520
only just one simple hash function to do

590
00:27:17,520 --> 00:27:21,000
all the hashing in swings plus then for

591
00:27:21,000 --> 00:27:22,919
example finding a pre-image for at least

592
00:27:22,919 --> 00:27:25,679
one value in this big construction would

593
00:27:25,679 --> 00:27:29,400
be much easier and The Tweak helps us to

594
00:27:29,400 --> 00:27:32,179
separate these calls

595
00:27:32,179 --> 00:27:34,860
uh so

596
00:27:34,860 --> 00:27:37,380
let's first take a look at the non-paid

597
00:27:37,380 --> 00:27:40,799
proof first the idea was the following

598
00:27:40,799 --> 00:27:46,500
uh you guess what message uh will be

599
00:27:46,500 --> 00:27:49,860
asked for the signing the signing query

600
00:27:49,860 --> 00:27:52,679
and you place a pretty much challenge at

601
00:27:52,679 --> 00:27:55,500
the position of in one chain at the

602
00:27:55,500 --> 00:27:57,360
position that you guess that the block

603
00:27:57,360 --> 00:28:00,240
will be that you will need to reveal in

604
00:28:00,240 --> 00:28:01,679
the signing query

605
00:28:01,679 --> 00:28:05,279
and then if there is a forgery as we

606
00:28:05,279 --> 00:28:08,880
mentioned before the adversary will have

607
00:28:08,880 --> 00:28:11,580
to reveal a block which is uh lower so

608
00:28:11,580 --> 00:28:14,279
he will have to make a longer chain for

609
00:28:14,279 --> 00:28:18,179
that for that uh part of the signature

610
00:28:18,179 --> 00:28:21,000
and there are two possible ways either

611
00:28:21,000 --> 00:28:23,220
either the forgery will collide before

612
00:28:23,220 --> 00:28:26,159
uh your signature block or it will

613
00:28:26,159 --> 00:28:28,500
collide afterwards and if it collides

614
00:28:28,500 --> 00:28:30,779
before then we found the pre-image uh

615
00:28:30,779 --> 00:28:33,059
for that block if it collides afterwards

616
00:28:33,059 --> 00:28:35,159
this can be handled with the second

617
00:28:35,159 --> 00:28:37,620
pre-image resistance property

618
00:28:37,620 --> 00:28:40,320
but yes here uh the problem is that we

619
00:28:40,320 --> 00:28:42,720
have to guess which block we will have

620
00:28:42,720 --> 00:28:46,320
to reveal in the signature and uh for

621
00:28:46,320 --> 00:28:48,720
one instance of what's the the guessing

622
00:28:48,720 --> 00:28:53,340
probability is one over L times W but in

623
00:28:53,340 --> 00:28:55,260
Sphinx plus we have a lot of instances

624
00:28:55,260 --> 00:28:57,960
of what's and then we will have to guess

625
00:28:57,960 --> 00:29:01,140
not only the position in the instance in

626
00:29:01,140 --> 00:29:03,779
the watch instance but also which what's

627
00:29:03,779 --> 00:29:06,360
will be forged so this is where the 60

628
00:29:06,360 --> 00:29:10,159
bits loss of security comes from

629
00:29:10,159 --> 00:29:12,600
so to

630
00:29:12,600 --> 00:29:15,720
um to avoid this guessing the idea was

631
00:29:15,720 --> 00:29:18,600
to construct the whole chain from the

632
00:29:18,600 --> 00:29:20,279
second pre-image resistance challenges

633
00:29:20,279 --> 00:29:22,200
and the idea was the following let's

634
00:29:22,200 --> 00:29:24,059
assume that the tweakable hash function

635
00:29:24,059 --> 00:29:27,299
uh has this property that for every

636
00:29:27,299 --> 00:29:30,779
output we have two pre-images yes real

637
00:29:30,779 --> 00:29:32,700
world hash functions doesn't have this

638
00:29:32,700 --> 00:29:35,100
property but there are ways to overcome

639
00:29:35,100 --> 00:29:37,860
this and just for the easy explanation

640
00:29:37,860 --> 00:29:40,860
just assume that yes we have for every

641
00:29:40,860 --> 00:29:43,919
output we have two pre images and assume

642
00:29:43,919 --> 00:29:45,779
we have a perfect adversary that can

643
00:29:45,779 --> 00:29:49,140
find pre images with 100 probability

644
00:29:49,140 --> 00:29:52,020
then when I have my second pre-image

645
00:29:52,020 --> 00:29:53,700
resistance challenge

646
00:29:53,700 --> 00:29:56,520
I can just submit the output to our

647
00:29:56,520 --> 00:29:59,340
pre-image finder and with probability at

648
00:29:59,340 --> 00:30:01,200
least one half he will produce the

649
00:30:01,200 --> 00:30:03,600
solution for our pre-image

650
00:30:03,600 --> 00:30:06,600
this is due to the fact that the input

651
00:30:06,600 --> 00:30:08,279
that I already know is information

652
00:30:08,279 --> 00:30:10,980
theoretically hidden from the adversary

653
00:30:10,980 --> 00:30:15,960
and this idea was used in the proof and

654
00:30:15,960 --> 00:30:18,720
so we construct our chain with this

655
00:30:18,720 --> 00:30:21,659
second pre-image challenges and hope

656
00:30:21,659 --> 00:30:23,760
that when the adversary will Forge our

657
00:30:23,760 --> 00:30:26,100
signature we will find a solution for

658
00:30:26,100 --> 00:30:27,720
the second primage resistance challenge

659
00:30:27,720 --> 00:30:30,960
but the problem is now that since we

660
00:30:30,960 --> 00:30:35,460
have this chaining of hashes the primage

661
00:30:35,460 --> 00:30:37,440
that we already know might not be hidden

662
00:30:37,440 --> 00:30:39,419
from the adversary so assume the

663
00:30:39,419 --> 00:30:41,880
situation that one of the pre-images is

664
00:30:41,880 --> 00:30:44,820
in the range of hash function outputs

665
00:30:44,820 --> 00:30:47,279
and the second Prim which is not then

666
00:30:47,279 --> 00:30:49,380
the adversary can determine which one

667
00:30:49,380 --> 00:30:51,720
you already know and give that solution

668
00:30:51,720 --> 00:30:53,360
to you

669
00:30:53,360 --> 00:30:56,580
uh so

670
00:30:56,580 --> 00:31:00,899
so yes uh the key idea that helped us to

671
00:31:00,899 --> 00:31:03,840
obtain a tight security proof was to

672
00:31:03,840 --> 00:31:07,200
observe that what is used to sign the

673
00:31:07,200 --> 00:31:08,940
roots of the miracle trees in the spring

674
00:31:08,940 --> 00:31:11,460
structure so the adversary doesn't have

675
00:31:11,460 --> 00:31:14,760
any control on those values and that's

676
00:31:14,760 --> 00:31:16,620
why we can prove the security of what's

677
00:31:16,620 --> 00:31:19,140
in a weaker model which is called U and

678
00:31:19,140 --> 00:31:22,440
acma and in this model the adversary has

679
00:31:22,440 --> 00:31:24,539
to perform all the signing queries

680
00:31:24,539 --> 00:31:27,179
before he sees the public key

681
00:31:27,179 --> 00:31:29,520
so in this case we don't have to guess

682
00:31:29,520 --> 00:31:32,220
anymore we place uh pretty much

683
00:31:32,220 --> 00:31:34,679
challenges for each position in the

684
00:31:34,679 --> 00:31:37,260
chain and again there are two possible

685
00:31:37,260 --> 00:31:39,480
ways either the Collision happens before

686
00:31:39,480 --> 00:31:43,260
uh the signature block then we we find

687
00:31:43,260 --> 00:31:45,480
the pretty much solution or it happens

688
00:31:45,480 --> 00:31:48,179
afterwards that will handle with

689
00:31:48,179 --> 00:31:50,399
multi-target Target Collision resistance

690
00:31:50,399 --> 00:31:52,919
which is can be viewed as yes second

691
00:31:52,919 --> 00:31:56,399
premature resistance kind but yeah some

692
00:31:56,399 --> 00:31:58,260
of you may notice that due to our

693
00:31:58,260 --> 00:32:00,779
challenge placement the distribution of

694
00:32:00,779 --> 00:32:03,539
the blocks and the public Keys could

695
00:32:03,539 --> 00:32:06,120
have changed this will handle with the

696
00:32:06,120 --> 00:32:08,580
notion called undetectability which

697
00:32:08,580 --> 00:32:11,240
essentially declares that

698
00:32:11,240 --> 00:32:13,799
the output of a tweakable hash function

699
00:32:13,799 --> 00:32:16,080
on the random input is computationally

700
00:32:16,080 --> 00:32:19,440
indistinguishable from a random string

701
00:32:19,440 --> 00:32:22,679
uh another underlying problem uh

702
00:32:22,679 --> 00:32:26,159
improving uh things plus is that uh

703
00:32:26,159 --> 00:32:28,080
again in strings plus we have multiple

704
00:32:28,080 --> 00:32:32,640
instances of what's and um they oh they

705
00:32:32,640 --> 00:32:34,980
all share the same public parameter and

706
00:32:34,980 --> 00:32:37,799
some of them are used to sign the

707
00:32:37,799 --> 00:32:40,080
messages which are

708
00:32:40,080 --> 00:32:40,679
um

709
00:32:40,679 --> 00:32:44,640
dependent on what's public keys of other

710
00:32:44,640 --> 00:32:45,779
instances

711
00:32:45,779 --> 00:32:50,520
and since we cannot we don't know the

712
00:32:50,520 --> 00:32:52,320
public parameter until we place all the

713
00:32:52,320 --> 00:32:54,179
challenges we cannot compute those

714
00:32:54,179 --> 00:32:57,480
dependencies just as it is so we

715
00:32:57,480 --> 00:33:00,120
introduce a th dump the Oracle which is

716
00:33:00,120 --> 00:33:01,620
initialized with the same public

717
00:33:01,620 --> 00:33:03,679
parameters in the as in the challenges

718
00:33:03,679 --> 00:33:07,380
and the diversary can query this Oracle

719
00:33:07,380 --> 00:33:09,779
with tweaks and messages but there are

720
00:33:09,779 --> 00:33:12,179
restrictions the adversity cannot query

721
00:33:12,179 --> 00:33:14,700
it with the same tweaks that are used in

722
00:33:14,700 --> 00:33:17,220
the challenges so the idea behind this

723
00:33:17,220 --> 00:33:19,320
is that we allow the adversity to query

724
00:33:19,320 --> 00:33:21,480
our tweakable hash function but only for

725
00:33:21,480 --> 00:33:23,340
the tweaks that are not useful for the

726
00:33:23,340 --> 00:33:25,260
challenges so this can be viewed as

727
00:33:25,260 --> 00:33:29,419
squaring just independent hash function

728
00:33:29,419 --> 00:33:31,799
uh so on the slide you can see the final

729
00:33:31,799 --> 00:33:34,320
theorems we proved these multiple

730
00:33:34,320 --> 00:33:37,679
instances of what's uh security and then

731
00:33:37,679 --> 00:33:40,019
when we proved it we could just plug in

732
00:33:40,019 --> 00:33:43,679
that part in the sinks plus security uh

733
00:33:43,679 --> 00:33:45,559
the rest of the proof remained the same

734
00:33:45,559 --> 00:33:48,419
on the slide you can also see there is a

735
00:33:48,419 --> 00:33:51,299
w factor in in front of undredictability

736
00:33:51,299 --> 00:33:52,500
notion

737
00:33:52,500 --> 00:33:55,080
this is due to the hybrid argument but

738
00:33:55,080 --> 00:33:58,919
the W is very usually a small value

739
00:33:58,919 --> 00:34:03,840
which is either 16 maybe 256 at most so

740
00:34:03,840 --> 00:34:07,099
this is just a tiny loss

741
00:34:07,099 --> 00:34:09,659
uh another important thing that we did

742
00:34:09,659 --> 00:34:14,179
is we updated the status of uh

743
00:34:14,179 --> 00:34:19,080
security properties uh so uh in our

744
00:34:19,080 --> 00:34:20,699
proof we're using we're using

745
00:34:20,699 --> 00:34:22,440
non-standard properties like typical

746
00:34:22,440 --> 00:34:24,480
Collision resistance or pre-image

747
00:34:24,480 --> 00:34:26,699
resistance for one target we're using a

748
00:34:26,699 --> 00:34:29,219
more complex ones so we have to analyze

749
00:34:29,219 --> 00:34:31,500
uh how hard it will be for the adversary

750
00:34:31,500 --> 00:34:34,679
to break them to do so we analyze how

751
00:34:34,679 --> 00:34:36,839
hard it will be to break such properties

752
00:34:36,839 --> 00:34:39,000
for random functions

753
00:34:39,000 --> 00:34:42,480
and uh we update the bounce for uh

754
00:34:42,480 --> 00:34:44,580
multi-target Target Collision resistance

755
00:34:44,580 --> 00:34:48,199
and the multi-target and detectability

756
00:34:48,199 --> 00:34:50,760
another thing to look at is the

757
00:34:50,760 --> 00:34:52,379
constructions of tweakable hash

758
00:34:52,379 --> 00:34:54,300
functions so

759
00:34:54,300 --> 00:34:55,980
um tweakable hash functions that

760
00:34:55,980 --> 00:34:57,720
syncsplus propose two possible

761
00:34:57,720 --> 00:34:59,160
constructions of tweetable hash

762
00:34:59,160 --> 00:35:01,680
functions from kit hash functions and

763
00:35:01,680 --> 00:35:04,560
there was an analysis uh what are the

764
00:35:04,560 --> 00:35:06,599
requirements on the kit hash functions

765
00:35:06,599 --> 00:35:08,760
to obtain the needed properties of

766
00:35:08,760 --> 00:35:11,280
tweakable hash functions but since plus

767
00:35:11,280 --> 00:35:14,000
didn't use pre-image resistance and the

768
00:35:14,000 --> 00:35:17,099
detectability in their proof so we also

769
00:35:17,099 --> 00:35:19,820
had to complete this part

770
00:35:19,820 --> 00:35:24,240
uh so yes in our work we recovered the

771
00:35:24,240 --> 00:35:27,540
uh types proof of security for Sphinx

772
00:35:27,540 --> 00:35:30,359
plus we updated the quantum generic

773
00:35:30,359 --> 00:35:32,160
security of used properties for

774
00:35:32,160 --> 00:35:34,260
multi-target Target collusion resistance

775
00:35:34,260 --> 00:35:37,200
and multi-target and detectability we

776
00:35:37,200 --> 00:35:38,940
also analyzed the constructions of

777
00:35:38,940 --> 00:35:40,740
tweakable hash functions and the

778
00:35:40,740 --> 00:35:43,260
connections between the properties and

779
00:35:43,260 --> 00:35:46,619
uh some ideas for the future work is

780
00:35:46,619 --> 00:35:48,900
that they can be done in computer aided

781
00:35:48,900 --> 00:35:52,500
proof and so my colleagues already done

782
00:35:52,500 --> 00:35:56,040
a crucial part of security proof and

783
00:35:56,040 --> 00:35:57,660
verified so the update is already

784
00:35:57,660 --> 00:36:01,800
verified in easycrypt and also what you

785
00:36:01,800 --> 00:36:04,380
could do is you could analyze the used

786
00:36:04,380 --> 00:36:06,359
properties regarding the hash function

787
00:36:06,359 --> 00:36:08,339
construction maybe Miracle dumb grad

788
00:36:08,339 --> 00:36:11,579
maybe sponge functions so and analyze

789
00:36:11,579 --> 00:36:13,500
what are the requirements there to

790
00:36:13,500 --> 00:36:16,079
obtain the needed properties

791
00:36:16,079 --> 00:36:18,900
so thank you for your attention

792
00:36:18,900 --> 00:36:21,680
any questions

793
00:36:26,160 --> 00:36:30,319
so we have time for questions anyone

794
00:36:41,339 --> 00:36:43,500
we don't have this don't seem to have

795
00:36:43,500 --> 00:36:45,300
any questions so let's take the speaker

796
00:36:45,300 --> 00:36:47,660
again

797
00:36:55,320 --> 00:36:57,839
okay so this time the next stock is

798
00:36:57,839 --> 00:36:59,940
going to be a hawk

799
00:36:59,940 --> 00:37:03,420
uh so modulip makes lazy signatures fast

800
00:37:03,420 --> 00:37:04,980
Compact and simple

801
00:37:04,980 --> 00:37:08,820
the paper is by uh leodica Iman pastel

802
00:37:08,820 --> 00:37:13,820
wave uh Ludo pules and uh

803
00:37:13,820 --> 00:37:18,859
and uh Ludo is going to give the talk

804
00:37:19,140 --> 00:37:21,560
things

805
00:37:34,859 --> 00:37:37,760
all right okay yeah I will talk about

806
00:37:37,760 --> 00:37:40,140
the signature scheme and its abilities

807
00:37:40,140 --> 00:37:43,320
on a module version of the lattice

808
00:37:43,320 --> 00:37:46,339
isomorphism problem

809
00:37:46,500 --> 00:37:48,599
um so first let's start off with the

810
00:37:48,599 --> 00:37:51,180
speaker C signature finalists

811
00:37:51,180 --> 00:37:52,260
um

812
00:37:52,260 --> 00:37:55,680
of these Falcon is the smallest that

813
00:37:55,680 --> 00:37:56,220
um

814
00:37:56,220 --> 00:37:58,440
despite this Nest still recommended the

815
00:37:58,440 --> 00:37:59,940
lithium

816
00:37:59,940 --> 00:38:04,440
and yeah why is this so falcon

817
00:38:04,440 --> 00:38:06,660
it's a Hessian sign

818
00:38:06,660 --> 00:38:08,400
um signature scheme

819
00:38:08,400 --> 00:38:10,859
and what this means

820
00:38:10,859 --> 00:38:11,940
um

821
00:38:11,940 --> 00:38:14,820
is that for signing you have a message

822
00:38:14,820 --> 00:38:16,980
when you hatch this message do some

823
00:38:16,980 --> 00:38:18,920
Target in the letters

824
00:38:18,920 --> 00:38:22,859
or just in a space and then signing is

825
00:38:22,859 --> 00:38:26,099
sampling and thereby lettuce point

826
00:38:26,099 --> 00:38:28,800
um with a good basis chapter basis

827
00:38:28,800 --> 00:38:32,400
and then verification is checking the

828
00:38:32,400 --> 00:38:35,760
same targets you acquire is first of all

829
00:38:35,760 --> 00:38:38,460
in the letters and you can check this

830
00:38:38,460 --> 00:38:41,820
with a bad basis and then you check if

831
00:38:41,820 --> 00:38:46,200
this targets is close to the signature

832
00:38:46,200 --> 00:38:47,940
and

833
00:38:47,940 --> 00:38:50,940
yeah so it has a small piece and

834
00:38:50,940 --> 00:38:53,460
signatures Falcon however this sampling

835
00:38:53,460 --> 00:38:56,460
step in signing that's a bit complicated

836
00:38:56,460 --> 00:38:58,800
because this requires High Precision

837
00:38:58,800 --> 00:39:00,599
floats for the

838
00:39:00,599 --> 00:39:04,020
discrete gaussian step they use and

839
00:39:04,020 --> 00:39:06,359
if you want to emulate these floats so

840
00:39:06,359 --> 00:39:08,460
this is on constraint devices that don't

841
00:39:08,460 --> 00:39:10,920
have floating points support

842
00:39:10,920 --> 00:39:14,820
and this emulation step is quite slow

843
00:39:14,820 --> 00:39:18,180
and that gives it a Slowdown for falcon

844
00:39:18,180 --> 00:39:19,920
in these devices

845
00:39:19,920 --> 00:39:23,520
and also if you want to mask this kind

846
00:39:23,520 --> 00:39:26,160
of stuff it also becomes difficult

847
00:39:26,160 --> 00:39:29,640
and this this comes from the the fact of

848
00:39:29,640 --> 00:39:32,040
the class of lattices they use the entry

849
00:39:32,040 --> 00:39:33,859
lattices

850
00:39:33,859 --> 00:39:37,079
and yeah was kind of the starting point

851
00:39:37,079 --> 00:39:39,359
for a project was that we just wanted to

852
00:39:39,359 --> 00:39:41,640
have like an easy lattice to sample from

853
00:39:41,640 --> 00:39:43,920
such as said to the end it's your

854
00:39:43,920 --> 00:39:45,599
lattice and this is almost like the

855
00:39:45,599 --> 00:39:47,940
easiest letters you can think of to to

856
00:39:47,940 --> 00:39:50,280
sample from

857
00:39:50,280 --> 00:39:52,980
um however everybody knows the the good

858
00:39:52,980 --> 00:39:55,680
basis on the interior letters so how can

859
00:39:55,680 --> 00:39:57,900
you build a signature scheme out of this

860
00:39:57,900 --> 00:39:59,940
uh that's a good question

861
00:39:59,940 --> 00:40:01,320
so

862
00:40:01,320 --> 00:40:03,599
I already did us to hide against your

863
00:40:03,599 --> 00:40:05,520
lattice by rotation

864
00:40:05,520 --> 00:40:09,300
and make this rotation for me

865
00:40:09,300 --> 00:40:10,619
so

866
00:40:10,619 --> 00:40:12,420
this is kind of the normal picture on

867
00:40:12,420 --> 00:40:14,040
the left you have the the chapter basis

868
00:40:14,040 --> 00:40:17,160
in green and on the right you construct

869
00:40:17,160 --> 00:40:20,220
a bad basis red and that becomes public

870
00:40:20,220 --> 00:40:23,220
key but now this this good basis is not

871
00:40:23,220 --> 00:40:25,980
the secret P anymore

872
00:40:25,980 --> 00:40:27,839
um but instead

873
00:40:27,839 --> 00:40:29,760
the road dates

874
00:40:29,760 --> 00:40:31,640
the public key

875
00:40:31,640 --> 00:40:35,040
and now the secret is the rotation that

876
00:40:35,040 --> 00:40:36,599
is used

877
00:40:36,599 --> 00:40:38,940
and

878
00:40:38,940 --> 00:40:43,859
right and so the security

879
00:40:43,859 --> 00:40:46,619
is based now on the lattice isomorphism

880
00:40:46,619 --> 00:40:48,240
problem

881
00:40:48,240 --> 00:40:50,040
and this is when you know the two

882
00:40:50,040 --> 00:40:52,500
lattices are isomorphic

883
00:40:52,500 --> 00:40:55,260
I have some basis that describes them

884
00:40:55,260 --> 00:40:57,660
you have to find a rotation that Maps

885
00:40:57,660 --> 00:40:59,040
one left to the other

886
00:40:59,040 --> 00:41:01,560
and in terms of bases

887
00:41:01,560 --> 00:41:03,839
this becomes uh

888
00:41:03,839 --> 00:41:05,880
this equation where you have to find

889
00:41:05,880 --> 00:41:09,119
also a unimodular transformation you

890
00:41:09,119 --> 00:41:11,820
that Maps one basis to the other after

891
00:41:11,820 --> 00:41:14,220
the rotation

892
00:41:14,220 --> 00:41:15,720
so

893
00:41:15,720 --> 00:41:17,940
now it seems like the problem has become

894
00:41:17,940 --> 00:41:20,099
worse we introduced more floating board

895
00:41:20,099 --> 00:41:22,680
numbers in the rotation therefore also P

896
00:41:22,680 --> 00:41:25,800
Prime also has floating points

897
00:41:25,800 --> 00:41:28,800
um but we can also fix this we

898
00:41:28,800 --> 00:41:32,820
by making this embedding implicit so the

899
00:41:32,820 --> 00:41:34,980
this B Prime

900
00:41:34,980 --> 00:41:39,300
we don't actually make this a public key

901
00:41:39,300 --> 00:41:41,280
keep it implicit but we keep the

902
00:41:41,280 --> 00:41:43,380
geometry of the letters

903
00:41:43,380 --> 00:41:46,079
and what I mean with this is that we

904
00:41:46,079 --> 00:41:47,339
look at the

905
00:41:47,339 --> 00:41:50,160
gram Matrix of B Prime

906
00:41:50,160 --> 00:41:52,619
so if you perform a rotation of your

907
00:41:52,619 --> 00:41:54,119
lattice

908
00:41:54,119 --> 00:41:56,880
Square Matrix containing all the the

909
00:41:56,880 --> 00:41:59,760
inner products of the basis vectors

910
00:41:59,760 --> 00:42:03,800
and this stays the same

911
00:42:04,079 --> 00:42:06,780
as you can see and

912
00:42:06,780 --> 00:42:11,040
describe Matrix can be made public

913
00:42:11,040 --> 00:42:14,579
and this transformation is now kept as a

914
00:42:14,579 --> 00:42:16,380
secret

915
00:42:16,380 --> 00:42:19,099
and

916
00:42:19,140 --> 00:42:21,780
when you ever want to get back to the

917
00:42:21,780 --> 00:42:23,720
basis

918
00:42:23,720 --> 00:42:26,640
uh described by this Q Prime you can

919
00:42:26,640 --> 00:42:28,140
take this to a live speaking composition

920
00:42:28,140 --> 00:42:30,960
this is giving you a basis that is upper

921
00:42:30,960 --> 00:42:35,060
triangular if you use column notation

922
00:42:35,700 --> 00:42:37,920
and there was a previous work and last

923
00:42:37,920 --> 00:42:40,440
year request that show the generic way

924
00:42:40,440 --> 00:42:43,260
to if you have a lattice where you can

925
00:42:43,260 --> 00:42:45,740
sample from

926
00:42:45,960 --> 00:42:47,700
um they provide a way to make a

927
00:42:47,700 --> 00:42:50,820
signature scheme on this lattice

928
00:42:50,820 --> 00:42:53,520
where the security is based on some

929
00:42:53,520 --> 00:42:56,400
variant of lip where you have to decide

930
00:42:56,400 --> 00:42:59,040
if some letters is isomorphic to one or

931
00:42:59,040 --> 00:43:00,900
the other

932
00:43:00,900 --> 00:43:01,810
um however

933
00:43:01,810 --> 00:43:03,060
[Music]

934
00:43:03,060 --> 00:43:05,700
yeah so in the case of set to the end

935
00:43:05,700 --> 00:43:07,740
here the secret key is this

936
00:43:07,740 --> 00:43:09,660
transformation

937
00:43:09,660 --> 00:43:11,640
and the public Keys then you translate

938
00:43:11,640 --> 00:43:13,859
those times you because the initial

939
00:43:13,859 --> 00:43:16,380
basis for that was the identity Matrix

940
00:43:16,380 --> 00:43:20,280
it becomes somewhat simpler

941
00:43:20,280 --> 00:43:22,920
um but the question is now to make this

942
00:43:22,920 --> 00:43:25,140
this

943
00:43:25,140 --> 00:43:27,599
previous work competitive

944
00:43:27,599 --> 00:43:31,619
to the modernist candidates uh that's

945
00:43:31,619 --> 00:43:34,619
that's where this work comes in

946
00:43:34,619 --> 00:43:38,160
so how do yeah how do you do this

947
00:43:38,160 --> 00:43:41,280
what are the steps uh so first of all

948
00:43:41,280 --> 00:43:44,400
uh we had to add extra structure to the

949
00:43:44,400 --> 00:43:45,839
industry lattice

950
00:43:45,839 --> 00:43:48,599
and so we are the ring structure to this

951
00:43:48,599 --> 00:43:52,260
and it makes everything better

952
00:43:52,260 --> 00:43:54,540
and we also have some compression

953
00:43:54,540 --> 00:43:57,300
techniques we used the keys and also the

954
00:43:57,300 --> 00:43:58,920
signature

955
00:43:58,920 --> 00:44:02,400
and last but not least we hashed The

956
00:44:02,400 --> 00:44:04,800
Targets in of the integer lattice

957
00:44:04,800 --> 00:44:09,359
and this allows us to use two samplers

958
00:44:09,359 --> 00:44:11,700
the one for Zeds and one for Zed was off

959
00:44:11,700 --> 00:44:13,200
and

960
00:44:13,200 --> 00:44:15,660
this is quite a major Improvement

961
00:44:15,660 --> 00:44:16,859
because then

962
00:44:16,859 --> 00:44:18,900
we have a constant time sampler you

963
00:44:18,900 --> 00:44:21,900
sample just from both and then depending

964
00:44:21,900 --> 00:44:24,420
on which one you need it you actually

965
00:44:24,420 --> 00:44:26,280
use

966
00:44:26,280 --> 00:44:30,720
so yeah that gives quite a speed up in

967
00:44:30,720 --> 00:44:32,400
practice

968
00:44:32,400 --> 00:44:36,720
so first points the extra structure

969
00:44:36,720 --> 00:44:40,319
that's that we go to a ring version and

970
00:44:40,319 --> 00:44:43,079
you don't think

971
00:44:43,079 --> 00:44:45,960
a module of rank one let's go for rank

972
00:44:45,960 --> 00:44:49,140
two so we do the standard trick of

973
00:44:49,140 --> 00:44:52,920
taking a cyclotomic wing of power of two

974
00:44:52,920 --> 00:44:55,640
degree

975
00:44:55,640 --> 00:44:59,160
and here the secrets

976
00:44:59,160 --> 00:45:02,640
the unit modular transformation is

977
00:45:02,640 --> 00:45:05,400
two basis vectors so they're all all

978
00:45:05,400 --> 00:45:07,200
left in the ring

979
00:45:07,200 --> 00:45:09,720
the first the small FNG are sampled from

980
00:45:09,720 --> 00:45:12,540
a discrete the ocean with a small Sigma

981
00:45:12,540 --> 00:45:15,599
and then to find the

982
00:45:15,599 --> 00:45:20,000
capital f and g we want to complete

983
00:45:20,000 --> 00:45:22,800
this this matrix by solving the entry

984
00:45:22,800 --> 00:45:23,940
equation

985
00:45:23,940 --> 00:45:25,200
and

986
00:45:25,200 --> 00:45:27,420
and this determinant has to be one to

987
00:45:27,420 --> 00:45:30,260
make some different domain

988
00:45:30,260 --> 00:45:33,480
and the solving this equation was

989
00:45:33,480 --> 00:45:36,180
actually done before so we can use Focus

990
00:45:36,180 --> 00:45:38,579
B generation codes

991
00:45:38,579 --> 00:45:40,500
and apply it to our case by only

992
00:45:40,500 --> 00:45:45,180
changing but I had a prime cue

993
00:45:45,180 --> 00:45:47,040
we change that to one

994
00:45:47,040 --> 00:45:50,099
so it kind of loses its meaning

995
00:45:50,099 --> 00:45:52,440
in our case

996
00:45:52,440 --> 00:45:54,839
also because we don't use a few wearing

997
00:45:54,839 --> 00:45:57,319
letters anymore

998
00:45:59,460 --> 00:46:01,920
and now

999
00:46:01,920 --> 00:46:04,920
yeah this public key is taken by you

1000
00:46:04,920 --> 00:46:06,839
Staryu and

1001
00:46:06,839 --> 00:46:09,060
kind of can think about this star as

1002
00:46:09,060 --> 00:46:13,260
being the transpose in the module case

1003
00:46:13,260 --> 00:46:16,800
so next step compression

1004
00:46:16,800 --> 00:46:17,520
um

1005
00:46:17,520 --> 00:46:19,859
also like Falcon we can drop one of the

1006
00:46:19,859 --> 00:46:23,280
secret key Parts the capital G

1007
00:46:23,280 --> 00:46:25,500
because the determinant was one

1008
00:46:25,500 --> 00:46:27,119
in our case

1009
00:46:27,119 --> 00:46:28,859
and

1010
00:46:28,859 --> 00:46:30,420
in the public key

1011
00:46:30,420 --> 00:46:34,619
we now have the two by two Matrix and

1012
00:46:34,619 --> 00:46:37,380
this may sound big but we have a

1013
00:46:37,380 --> 00:46:39,660
symmetry property

1014
00:46:39,660 --> 00:46:42,300
so we can drop one of the four

1015
00:46:42,300 --> 00:46:46,859
and then we can also drop the q11

1016
00:46:46,859 --> 00:46:49,500
and this is because the terminals of U

1017
00:46:49,500 --> 00:46:51,720
was one also the determinant of this

1018
00:46:51,720 --> 00:46:55,200
quadratic form Q this one

1019
00:46:55,200 --> 00:46:57,180
and that allows us

1020
00:46:57,180 --> 00:47:00,180
this q11 as well

1021
00:47:00,180 --> 00:47:04,079
so now you only have half left

1022
00:47:04,079 --> 00:47:06,920
and

1023
00:47:07,140 --> 00:47:09,240
we can also drop

1024
00:47:09,240 --> 00:47:12,180
off of the signature

1025
00:47:12,180 --> 00:47:14,400
and

1026
00:47:14,400 --> 00:47:17,780
this can be done by

1027
00:47:17,780 --> 00:47:21,599
a roundoff algorithm

1028
00:47:21,599 --> 00:47:22,740
so

1029
00:47:22,740 --> 00:47:25,440
from hash inside the signature is a

1030
00:47:25,440 --> 00:47:28,020
nearby lattice point

1031
00:47:28,020 --> 00:47:30,780
and if we have fixed half of the

1032
00:47:30,780 --> 00:47:33,060
signature the other part of the

1033
00:47:33,060 --> 00:47:35,099
signature has to be

1034
00:47:35,099 --> 00:47:36,839
some

1035
00:47:36,839 --> 00:47:39,060
let this point that makes the signature

1036
00:47:39,060 --> 00:47:40,680
close to the Target

1037
00:47:40,680 --> 00:47:43,920
and this can be used in verification and

1038
00:47:43,920 --> 00:47:45,839
what's more important is that we can

1039
00:47:45,839 --> 00:47:48,180
also do this only with the public

1040
00:47:48,180 --> 00:47:50,040
data available so only with the

1041
00:47:50,040 --> 00:47:53,220
quadratic form and motivated transfer

1042
00:47:53,220 --> 00:47:54,480
so

1043
00:47:54,480 --> 00:47:57,660
let's go into that so outsiding works

1044
00:47:57,660 --> 00:48:00,359
exactly is that we hash the message

1045
00:48:00,359 --> 00:48:04,500
to a Target and is ages then the bit

1046
00:48:04,500 --> 00:48:07,520
string length to n

1047
00:48:07,520 --> 00:48:11,700
and this becomes an element of the

1048
00:48:11,700 --> 00:48:15,060
the ring by seeing it

1049
00:48:15,060 --> 00:48:16,020
um

1050
00:48:16,020 --> 00:48:19,619
as a polynomial of leg and and two

1051
00:48:19,619 --> 00:48:21,960
copies of this

1052
00:48:21,960 --> 00:48:23,220
and then

1053
00:48:23,220 --> 00:48:26,040
you sample

1054
00:48:26,040 --> 00:48:31,020
a lattice point so X that is close to

1055
00:48:31,020 --> 00:48:34,500
what is this U times H over 2

1056
00:48:34,500 --> 00:48:37,140
so H over 2 is

1057
00:48:37,140 --> 00:48:38,540
um

1058
00:48:38,540 --> 00:48:43,380
targets when you multiply it with you

1059
00:48:43,380 --> 00:48:47,220
so then if you take the U inverse again

1060
00:48:47,220 --> 00:48:49,319
this gives you the

1061
00:48:49,319 --> 00:48:53,040
like the coefficients describing

1062
00:48:53,040 --> 00:48:56,720
the points that's nearby

1063
00:48:57,000 --> 00:49:00,359
and what you can see now is so U times s

1064
00:49:00,359 --> 00:49:03,180
is close to a half U times eight

1065
00:49:03,180 --> 00:49:05,940
and if you fix S1

1066
00:49:05,940 --> 00:49:09,599
this makes s0 times u0 has to be close

1067
00:49:09,599 --> 00:49:12,720
to this this thing here

1068
00:49:12,720 --> 00:49:16,440
and for this we know how to

1069
00:49:16,440 --> 00:49:20,280
do this reasonably well so you have the

1070
00:49:20,280 --> 00:49:23,700
round off algorithm or the nearest plane

1071
00:49:23,700 --> 00:49:27,000
and we use the round off

1072
00:49:27,000 --> 00:49:28,800
so

1073
00:49:28,800 --> 00:49:31,560
if you do the math you get this formula

1074
00:49:31,560 --> 00:49:35,040
you have to ground some quantity

1075
00:49:35,040 --> 00:49:38,460
and although this view was Secret

1076
00:49:38,460 --> 00:49:40,980
this cube is public

1077
00:49:40,980 --> 00:49:41,579
um

1078
00:49:41,579 --> 00:49:45,200
so this can be done in verification

1079
00:49:45,200 --> 00:49:48,599
and what we had to do here is reject

1080
00:49:48,599 --> 00:49:49,680
some

1081
00:49:49,680 --> 00:49:53,760
bad key Pairs and where this Q zero zero

1082
00:49:53,760 --> 00:49:56,040
was too small

1083
00:49:56,040 --> 00:49:57,420
and

1084
00:49:57,420 --> 00:49:59,280
that made it

1085
00:49:59,280 --> 00:50:02,460
like this uh this roundoff made it feel

1086
00:50:02,460 --> 00:50:04,859
like once in a million times

1087
00:50:04,859 --> 00:50:06,960
so we had to reject these sweepers and

1088
00:50:06,960 --> 00:50:10,380
it's like 10 of Keepers let's be

1089
00:50:10,380 --> 00:50:13,560
rejected and in that case the recovery

1090
00:50:13,560 --> 00:50:17,599
Works practically always

1091
00:50:18,060 --> 00:50:21,780
and this half like the signature size by

1092
00:50:21,780 --> 00:50:25,079
two I think even more than two because

1093
00:50:25,079 --> 00:50:28,020
the distribution is a bit different

1094
00:50:28,020 --> 00:50:30,180
between the small f and g and the

1095
00:50:30,180 --> 00:50:32,760
capital f g

1096
00:50:32,760 --> 00:50:35,099
so uh

1097
00:50:35,099 --> 00:50:37,940
how does it perform

1098
00:50:37,980 --> 00:50:39,180
um

1099
00:50:39,180 --> 00:50:41,579
yeah we wrote The implementation in C

1100
00:50:41,579 --> 00:50:43,680
using some parts of Falcon

1101
00:50:43,680 --> 00:50:47,599
and this is isopenis so

1102
00:50:47,599 --> 00:50:50,819
almost constant time except for the

1103
00:50:50,819 --> 00:50:53,040
encoding and decoding of signatures of

1104
00:50:53,040 --> 00:50:54,480
public use

1105
00:50:54,480 --> 00:50:57,480
and as you can see so everything is

1106
00:50:57,480 --> 00:51:01,079
almost like twice as fast as falcon

1107
00:51:01,079 --> 00:51:02,880
and

1108
00:51:02,880 --> 00:51:06,180
the signatures are 20 smaller

1109
00:51:06,180 --> 00:51:10,200
and this is in the in the case of

1110
00:51:10,200 --> 00:51:14,040
the processor having avx2 support so

1111
00:51:14,040 --> 00:51:16,500
that's like high-end devices or just

1112
00:51:16,500 --> 00:51:19,079
normal desktop PCS

1113
00:51:19,079 --> 00:51:21,599
and

1114
00:51:21,599 --> 00:51:24,059
you know falcon

1115
00:51:24,059 --> 00:51:26,460
it's worse when there's no floating

1116
00:51:26,460 --> 00:51:27,780
Point Sports

1117
00:51:27,780 --> 00:51:32,119
on the processor and in that case

1118
00:51:32,400 --> 00:51:34,740
get this performance

1119
00:51:34,740 --> 00:51:37,260
so because we only have to multiply

1120
00:51:37,260 --> 00:51:39,180
things

1121
00:51:39,180 --> 00:51:42,059
in this in this ring

1122
00:51:42,059 --> 00:51:46,800
uh the talk you can use the entities

1123
00:51:46,800 --> 00:51:50,099
in signing there's also in verification

1124
00:51:50,099 --> 00:51:54,059
and there we get this Vector 15 speed up

1125
00:51:54,059 --> 00:51:55,500
for signing

1126
00:51:55,500 --> 00:51:56,760
and

1127
00:51:56,760 --> 00:51:58,500
yeah this is

1128
00:51:58,500 --> 00:52:01,680
even for the for the batch mode to open

1129
00:52:01,680 --> 00:52:03,720
the Falcon considers this performance

1130
00:52:03,720 --> 00:52:06,300
with designing in a case where you have

1131
00:52:06,300 --> 00:52:07,260
a lot of

1132
00:52:07,260 --> 00:52:10,800
signatures and signs

1133
00:52:10,800 --> 00:52:13,079
and it kind of takes the average of this

1134
00:52:13,079 --> 00:52:14,819
it's some free computation on the

1135
00:52:14,819 --> 00:52:15,540
security

1136
00:52:15,540 --> 00:52:19,380
and we we haven't done this yet

1137
00:52:19,380 --> 00:52:20,099
um

1138
00:52:20,099 --> 00:52:23,160
but we still compare it so if you take

1139
00:52:23,160 --> 00:52:25,619
the unboxed version of token that we

1140
00:52:25,619 --> 00:52:29,720
have a factor 30 speed up

1141
00:52:29,819 --> 00:52:30,960
um

1142
00:52:30,960 --> 00:52:33,500
yeah

1143
00:52:35,160 --> 00:52:39,359
so yeah some remaining questions

1144
00:52:39,359 --> 00:52:41,280
um first of all maybe their older

1145
00:52:41,280 --> 00:52:43,260
lattices where

1146
00:52:43,260 --> 00:52:44,040
um

1147
00:52:44,040 --> 00:52:48,240
kind of can sample closer to the targets

1148
00:52:48,240 --> 00:52:51,000
and maybe

1149
00:52:51,000 --> 00:52:54,540
get some smaller signatures or

1150
00:52:54,540 --> 00:52:55,500
um

1151
00:52:55,500 --> 00:52:57,119
this kind of stuff

1152
00:52:57,119 --> 00:52:59,880
but then the main question is that we

1153
00:52:59,880 --> 00:53:01,980
want more equipment analysis

1154
00:53:01,980 --> 00:53:05,640
on this lattice isomorphism problem

1155
00:53:05,640 --> 00:53:08,940
and how it's like harder reductions to

1156
00:53:08,940 --> 00:53:10,380
other problems

1157
00:53:10,380 --> 00:53:14,880
so we know that if you solve SVP

1158
00:53:14,880 --> 00:53:16,619
you found

1159
00:53:16,619 --> 00:53:18,660
you have the key recovery

1160
00:53:18,660 --> 00:53:21,300
but yeah is there more

1161
00:53:21,300 --> 00:53:26,480
uh it's quite yeah interesting you know

1162
00:53:27,240 --> 00:53:31,020
so to wrap up

1163
00:53:31,020 --> 00:53:31,800
um

1164
00:53:31,800 --> 00:53:34,140
yeah I've shown a signature scheme that

1165
00:53:34,140 --> 00:53:35,880
ties the rotation of set to the end and

1166
00:53:35,880 --> 00:53:38,099
on this lattice

1167
00:53:38,099 --> 00:53:40,920
uh the sampling becomes easier

1168
00:53:40,920 --> 00:53:43,440
and we don't have to work with any

1169
00:53:43,440 --> 00:53:45,059
floating points

1170
00:53:45,059 --> 00:53:48,839
and that makes it the personal compact

1171
00:53:48,839 --> 00:53:52,819
that's it thanks

1172
00:53:59,160 --> 00:54:01,940
so any questions

1173
00:54:06,619 --> 00:54:11,819
so it's a very good proposal I guess so

1174
00:54:11,819 --> 00:54:14,780
but compared to the bitter girl

1175
00:54:14,780 --> 00:54:19,500
so I like as two point in the Hulk it

1176
00:54:19,500 --> 00:54:22,020
can be parallel computation is possible

1177
00:54:22,020 --> 00:54:24,000
this is the first question

1178
00:54:24,000 --> 00:54:26,760
the command is what is your idea against

1179
00:54:26,760 --> 00:54:28,200
a channel

1180
00:54:28,200 --> 00:54:30,420
attacks

1181
00:54:30,420 --> 00:54:32,700
sorry what was the first question

1182
00:54:32,700 --> 00:54:36,899
parallel computation paralyzed

1183
00:54:37,079 --> 00:54:40,700
you mean that all computation is serious

1184
00:54:40,700 --> 00:54:43,680
serialized contribution so if you have

1185
00:54:43,680 --> 00:54:48,839
any idea a parent competition and Hope

1186
00:54:48,839 --> 00:54:53,119
well sir sir

1187
00:54:53,220 --> 00:54:55,260
what do you mean so in your

1188
00:54:55,260 --> 00:54:57,480
implementation or better performance

1189
00:54:57,480 --> 00:54:58,700
verification

1190
00:54:58,700 --> 00:55:05,640
or operation is done by step by step

1191
00:55:05,640 --> 00:55:08,220
right yeah so you don't have no idea in

1192
00:55:08,220 --> 00:55:11,540
the parallel competition

1193
00:55:11,640 --> 00:55:15,180
um yeah

1194
00:55:15,180 --> 00:55:16,260
um

1195
00:55:16,260 --> 00:55:19,079
I guess you can like do some sampling

1196
00:55:19,079 --> 00:55:20,640
beforehand

1197
00:55:20,640 --> 00:55:24,900
for every go set and okay that is

1198
00:55:24,900 --> 00:55:27,710
possible okay

1199
00:55:27,710 --> 00:55:28,020
[Music]

1200
00:55:28,020 --> 00:55:28,980
um

1201
00:55:28,980 --> 00:55:31,619
yeah okay second question is any

1202
00:55:31,619 --> 00:55:34,339
registers against

1203
00:55:34,339 --> 00:55:38,760
us the constant time implementation or

1204
00:55:38,760 --> 00:55:40,680
others

1205
00:55:40,680 --> 00:55:42,420
uh yeah so

1206
00:55:42,420 --> 00:55:45,480
yeah we already have uh isochronous

1207
00:55:45,480 --> 00:55:47,760
implementation

1208
00:55:47,760 --> 00:55:49,619
and

1209
00:55:49,619 --> 00:55:52,680
it's basically like yeah

1210
00:55:52,680 --> 00:55:55,680
we we said we say this because that's

1211
00:55:55,680 --> 00:55:58,079
like more accurate than

1212
00:55:58,079 --> 00:56:01,559
saying it's constant time because this

1213
00:56:01,559 --> 00:56:04,800
um like this signing is so fast that

1214
00:56:04,800 --> 00:56:09,599
maybe like some 10 to spent on encoding

1215
00:56:09,599 --> 00:56:10,440
um

1216
00:56:10,440 --> 00:56:13,460
the signatures

1217
00:56:13,500 --> 00:56:17,460
and so yeah like technically it's not

1218
00:56:17,460 --> 00:56:18,839
most of the time because of this

1219
00:56:18,839 --> 00:56:22,200
encoding but this doesn't matter because

1220
00:56:22,200 --> 00:56:25,079
these signatures pick up public so no

1221
00:56:25,079 --> 00:56:29,220
yeah anyone cannot learn more about

1222
00:56:29,220 --> 00:56:31,559
how long this encoding to

1223
00:56:31,559 --> 00:56:34,760
okay thank you

1224
00:56:35,220 --> 00:56:38,000
other questions

1225
00:56:38,520 --> 00:56:40,559
hi thanks for the talk

1226
00:56:40,559 --> 00:56:41,819
um

1227
00:56:41,819 --> 00:56:44,579
so for this looks a bit like what an mq

1228
00:56:44,579 --> 00:56:46,440
was done the whole time and what got

1229
00:56:46,440 --> 00:56:49,440
rainbow broken like many schemes because

1230
00:56:49,440 --> 00:56:51,960
they also relied on ASMR personal

1231
00:56:51,960 --> 00:56:54,660
polynomics problems so if you have any

1232
00:56:54,660 --> 00:56:56,040
idea of

1233
00:56:56,040 --> 00:56:59,940
how secure this next isomorphism problem

1234
00:56:59,940 --> 00:57:01,500
is

1235
00:57:01,500 --> 00:57:05,339
yeah so we know it's broken for codes

1236
00:57:05,339 --> 00:57:08,579
but for lattices this

1237
00:57:08,579 --> 00:57:12,000
yeah this kind of popped up I think like

1238
00:57:12,000 --> 00:57:14,040
one year or two years ago

1239
00:57:14,040 --> 00:57:16,619
that it's like already quite difficult

1240
00:57:16,619 --> 00:57:18,839
to

1241
00:57:18,839 --> 00:57:21,839
uh to do in dimension nine

1242
00:57:21,839 --> 00:57:24,900
where uh like vessel he computed a lot

1243
00:57:24,900 --> 00:57:27,839
of different uh lattices and he wanted

1244
00:57:27,839 --> 00:57:30,240
to know if they were isomorphic this was

1245
00:57:30,240 --> 00:57:34,079
like quite difficult it seems so it

1246
00:57:34,079 --> 00:57:37,260
looks more promising than like these

1247
00:57:37,260 --> 00:57:40,260
attacks on goats and kind of stuff

1248
00:57:40,260 --> 00:57:42,540
okay so you don't have any reduction

1249
00:57:42,540 --> 00:57:45,000
that shows that this is uh

1250
00:57:45,000 --> 00:57:47,520
maybe as hard as

1251
00:57:47,520 --> 00:57:51,000
some form of photos like a problem also

1252
00:57:51,000 --> 00:57:53,940
uh no we don't have this yet

1253
00:57:53,940 --> 00:57:56,480
thanks thanks

1254
00:57:58,559 --> 00:58:00,480
we still have a bit of time for

1255
00:58:00,480 --> 00:58:04,040
questions if there are more

1256
00:58:05,880 --> 00:58:09,559
otherwise let's thank the speaker again

1257
00:58:13,800 --> 00:58:16,400
foreign

1258
00:58:22,680 --> 00:58:24,859
[Music]

1259
00:58:24,859 --> 00:58:29,059
out of many proofs and applications by

1260
00:58:29,059 --> 00:58:32,420
vladimirshipsky and uh

1261
00:58:32,420 --> 00:58:37,099
and Khan is going to give that off

1262
00:58:53,460 --> 00:58:56,480
like to check

1263
00:58:57,960 --> 00:58:59,780
um yeah

1264
00:58:59,780 --> 00:59:01,740
So yeah thank you very much for the

1265
00:59:01,740 --> 00:59:03,000
introduction and thanks everyone for

1266
00:59:03,000 --> 00:59:04,740
staying here

1267
00:59:04,740 --> 00:59:06,359
um my name is Khan and I'm gonna talk

1268
00:59:06,359 --> 00:59:08,640
about Bloom my model that is one of the

1269
00:59:08,640 --> 00:59:11,339
many proofs and applications

1270
00:59:11,339 --> 00:59:13,140
so we have seen many lattice based your

1271
00:59:13,140 --> 00:59:15,000
knowledge Frameworks in the recent years

1272
00:59:15,000 --> 00:59:17,819
and the usual well naturally they come

1273
00:59:17,819 --> 00:59:19,819
with applications for example we had

1274
00:59:19,819 --> 00:59:22,500
approximate proofs or like the Shamir

1275
00:59:22,500 --> 00:59:24,599
with a boards which was hinted in the

1276
00:59:24,599 --> 00:59:26,760
first talk by Julian and they naturally

1277
00:59:26,760 --> 00:59:28,079
come with some nice applications for

1278
00:59:28,079 --> 00:59:30,119
example the delithium signature and we

1279
00:59:30,119 --> 00:59:32,040
also have like verifiable encryption

1280
00:59:32,040 --> 00:59:34,319
group signatures and so on

1281
00:59:34,319 --> 00:59:37,619
and then you know in 2019

1282
00:59:37,619 --> 00:59:40,680
um we had like algebraic exact proofs

1283
00:59:40,680 --> 00:59:42,299
and they could also come with nice

1284
00:59:42,299 --> 00:59:46,140
applications with exotic signatures with

1285
00:59:46,140 --> 00:59:48,599
um much better signature sizes and so on

1286
00:59:48,599 --> 00:59:51,599
and then you know then we had more and

1287
00:59:51,599 --> 00:59:54,000
more Frameworks with with you know with

1288
00:59:54,000 --> 00:59:57,000
other applications where you just in in

1289
00:59:57,000 --> 00:59:58,680
many cases you can just substitute the

1290
00:59:58,680 --> 01:00:00,599
framework like below and then you get

1291
01:00:00,599 --> 01:00:03,480
because the framework itself is

1292
01:00:03,480 --> 01:00:06,119
much better than before then naturally

1293
01:00:06,119 --> 01:00:09,059
these these uh Primitives this privacy

1294
01:00:09,059 --> 01:00:11,520
preserving applications they are also

1295
01:00:11,520 --> 01:00:13,319
more efficient than before

1296
01:00:13,319 --> 01:00:15,359
however it's you know it's interesting

1297
01:00:15,359 --> 01:00:18,000
more interesting to

1298
01:00:18,000 --> 01:00:20,460
um to kind of make use of the framework

1299
01:00:20,460 --> 01:00:22,200
and not just use it in the black box

1300
01:00:22,200 --> 01:00:24,180
Manner and that's kind of what we will

1301
01:00:24,180 --> 01:00:26,160
show with the

1302
01:00:26,160 --> 01:00:27,780
um

1303
01:00:27,780 --> 01:00:28,920
here

1304
01:00:28,920 --> 01:00:31,140
um so in in this paper we show efficient

1305
01:00:31,140 --> 01:00:33,119
one out of many proofs where we really

1306
01:00:33,119 --> 01:00:35,819
make use of this of the newest lmp22

1307
01:00:35,819 --> 01:00:39,119
framework from crypto this year

1308
01:00:39,119 --> 01:00:42,180
um another contribution is we saw

1309
01:00:42,180 --> 01:00:44,280
um how to prove integer relations such

1310
01:00:44,280 --> 01:00:46,740
as addition and multiplication and the

1311
01:00:46,740 --> 01:00:48,299
nice thing about this compared to

1312
01:00:48,299 --> 01:00:50,040
previous works is that you we don't need

1313
01:00:50,040 --> 01:00:52,799
to commit to the carry vectors

1314
01:00:52,799 --> 01:00:55,140
and that's like a significant

1315
01:00:55,140 --> 01:00:56,160
Improvement

1316
01:00:56,160 --> 01:00:59,040
and also well because we had the name by

1317
01:00:59,040 --> 01:01:02,220
model in the title or we use the um we

1318
01:01:02,220 --> 01:01:04,799
improved this framework using by model

1319
01:01:04,799 --> 01:01:06,540
gaussians but it's around 10 to 50

1320
01:01:06,540 --> 01:01:08,700
percent gain

1321
01:01:08,700 --> 01:01:11,460
and well obviously one might think that

1322
01:01:11,460 --> 01:01:14,160
all these uh you know the all these

1323
01:01:14,160 --> 01:01:15,780
things are not really useful in real

1324
01:01:15,780 --> 01:01:18,299
life well I hope this the music video

1325
01:01:18,299 --> 01:01:21,420
has some impact in your life but um in

1326
01:01:21,420 --> 01:01:23,220
this talk I will only focus on the first

1327
01:01:23,220 --> 01:01:26,299
bullet points

1328
01:01:27,480 --> 01:01:28,859
okay so let's start with some

1329
01:01:28,859 --> 01:01:31,680
preliminaries as uh hinted already in

1330
01:01:31,680 --> 01:01:34,440
the previous talk uh we will focus on

1331
01:01:34,440 --> 01:01:37,200
these psychotomic rings so let our QB

1332
01:01:37,200 --> 01:01:40,200
the Q of X module x d plus one where D

1333
01:01:40,200 --> 01:01:42,420
is the Power of Two

1334
01:01:42,420 --> 01:01:45,000
and then we defined the automorphism

1335
01:01:45,000 --> 01:01:47,520
sigma to be the one which Maps x to the

1336
01:01:47,520 --> 01:01:49,740
X inverse

1337
01:01:49,740 --> 01:01:51,299
so we will have we have some weird

1338
01:01:51,299 --> 01:01:53,460
definitions here and I'll show you in

1339
01:01:53,460 --> 01:01:54,660
the next few slides where they're

1340
01:01:54,660 --> 01:01:57,480
interesting hopefully

1341
01:01:57,480 --> 01:01:59,339
um so yeah so the the next weird thing

1342
01:01:59,339 --> 01:02:01,920
is that for a fixed number of variables

1343
01:02:01,920 --> 01:02:05,339
let's say k i defined this uh quadratic

1344
01:02:05,339 --> 01:02:08,819
automorphic polynomial is QA polynomial

1345
01:02:08,819 --> 01:02:11,040
P to be a function for which there

1346
01:02:11,040 --> 01:02:13,200
exists at 2K various quadratic

1347
01:02:13,200 --> 01:02:16,980
polynomial t such that P of M1 up TMK is

1348
01:02:16,980 --> 01:02:18,960
equal to T of M1

1349
01:02:18,960 --> 01:02:22,740
Sigma of M1 M2 Sigma of M2 up to MK

1350
01:02:22,740 --> 01:02:24,240
Sigma of m k

1351
01:02:24,240 --> 01:02:27,240
so informally just think of these QA

1352
01:02:27,240 --> 01:02:29,339
polynomials as this quadratic

1353
01:02:29,339 --> 01:02:32,280
polynomials but we also introduced some

1354
01:02:32,280 --> 01:02:34,740
there might be just some segments around

1355
01:02:34,740 --> 01:02:37,319
for example M1 times M2 minus Sigma of

1356
01:02:37,319 --> 01:02:41,280
M3 or M1 times Sigma of M1 minus x to

1357
01:02:41,280 --> 01:02:43,980
the D over 2 plus 2.

1358
01:02:43,980 --> 01:02:45,960
so okay so why are they useful or what

1359
01:02:45,960 --> 01:02:48,480
okay so that's for the next slide

1360
01:02:48,480 --> 01:02:52,020
so this simplified LNP 22 framework can

1361
01:02:52,020 --> 01:02:55,260
be uh well can be described like this

1362
01:02:55,260 --> 01:02:57,299
so suppose I want to prove knowledge of

1363
01:02:57,299 --> 01:02:59,700
some short polynomials in RQ and one up

1364
01:02:59,700 --> 01:03:03,059
to MK which satisfy some relations

1365
01:03:03,059 --> 01:03:06,119
so for public QA polynomials P1 up to pl

1366
01:03:06,119 --> 01:03:09,420
we want to prove that for each eye Pi of

1367
01:03:09,420 --> 01:03:14,280
M1 M2 up to MK is equal to 0 over Q

1368
01:03:14,280 --> 01:03:16,559
the second one is let's say more

1369
01:03:16,559 --> 01:03:18,240
interesting but it's also

1370
01:03:18,240 --> 01:03:21,059
also not really intuitive so for public

1371
01:03:21,059 --> 01:03:23,780
QA polynomials P1 Prime up to PN Prime

1372
01:03:23,780 --> 01:03:26,400
for each eye the constant coefficient of

1373
01:03:26,400 --> 01:03:30,119
p i Prime of M1 up 10 K is equal to zero

1374
01:03:30,119 --> 01:03:33,180
so recall that Pi Prime of M1 up to MK

1375
01:03:33,180 --> 01:03:35,819
is a polynomial over RQ and we want to

1376
01:03:35,819 --> 01:03:37,319
prove that the constant coefficient is

1377
01:03:37,319 --> 01:03:39,839
equal to let's say zero but if because

1378
01:03:39,839 --> 01:03:41,700
we are interested in zero knowledge we

1379
01:03:41,700 --> 01:03:42,660
don't want to reveal any information

1380
01:03:42,660 --> 01:03:45,720
about the other coefficients

1381
01:03:45,720 --> 01:03:47,700
uh and then yeah the third thing is

1382
01:03:47,700 --> 01:03:49,740
proving some various Norm bounds so you

1383
01:03:49,740 --> 01:03:51,420
want to prove if you want to prove some

1384
01:03:51,420 --> 01:03:53,099
L2 Norm or we want to prove some

1385
01:03:53,099 --> 01:03:54,299
binaries

1386
01:03:54,299 --> 01:03:56,160
yeah

1387
01:03:56,160 --> 01:03:57,480
Okay so

1388
01:03:57,480 --> 01:04:00,000
one might okay so now you know I guess

1389
01:04:00,000 --> 01:04:02,220
maybe half of the majority of the

1390
01:04:02,220 --> 01:04:03,599
audience here thinks like well what's

1391
01:04:03,599 --> 01:04:05,880
the point of all these of all the sigma

1392
01:04:05,880 --> 01:04:08,760
why do we need Sigma why do we need QA

1393
01:04:08,760 --> 01:04:10,619
polynomials why am I here and what time

1394
01:04:10,619 --> 01:04:13,920
is the launch so um well so I hope in

1395
01:04:13,920 --> 01:04:17,460
the next slide I can explain a bit

1396
01:04:17,460 --> 01:04:18,299
um

1397
01:04:18,299 --> 01:04:20,880
so suppose I want to prove some basic

1398
01:04:20,880 --> 01:04:23,579
relations over integers or over Z q

1399
01:04:23,579 --> 01:04:25,619
for example I want to prove binary so I

1400
01:04:25,619 --> 01:04:27,720
have a polynomial M I want to prove that

1401
01:04:27,720 --> 01:04:30,119
it has binary coefficients

1402
01:04:30,119 --> 01:04:32,220
so the first observation is that this is

1403
01:04:32,220 --> 01:04:33,960
the case if and only if the inner

1404
01:04:33,960 --> 01:04:37,380
product of M and M minus 1 is equal to

1405
01:04:37,380 --> 01:04:39,599
zero over integers so basically we would

1406
01:04:39,599 --> 01:04:41,760
just want to prove the this inner

1407
01:04:41,760 --> 01:04:43,680
product relation

1408
01:04:43,680 --> 01:04:45,480
and then to prove that we use the

1409
01:04:45,480 --> 01:04:48,359
following Lemma which says that if we

1410
01:04:48,359 --> 01:04:50,059
have the problem

1411
01:04:50,059 --> 01:04:52,680
polynomial vectors x y

1412
01:04:52,680 --> 01:04:54,599
then the constant coefficient of x

1413
01:04:54,599 --> 01:04:58,020
transport Sigma of Y is equal to this

1414
01:04:58,020 --> 01:05:00,059
exactly the inner product of these

1415
01:05:00,059 --> 01:05:03,240
coefficient vectors X and Y

1416
01:05:03,240 --> 01:05:05,220
this means in particular that if we want

1417
01:05:05,220 --> 01:05:06,420
to prove

1418
01:05:06,420 --> 01:05:08,940
the inner product let's say of M and M

1419
01:05:08,940 --> 01:05:11,220
minus 1 we are interested in the

1420
01:05:11,220 --> 01:05:12,900
constant coefficient of if it doesn't

1421
01:05:12,900 --> 01:05:15,140
work

1422
01:05:15,540 --> 01:05:18,780
I'll just use my mouse and this is

1423
01:05:18,780 --> 01:05:20,960
equivalent to showing that the constant

1424
01:05:20,960 --> 01:05:24,920
coefficient of M oh

1425
01:05:26,160 --> 01:05:28,500
um yeah the constant coefficient of M

1426
01:05:28,500 --> 01:05:30,540
times Sigma of M minus the sum of

1427
01:05:30,540 --> 01:05:33,240
monomials is equal to zero because the

1428
01:05:33,240 --> 01:05:35,460
coefficient of coefficient Vector of M

1429
01:05:35,460 --> 01:05:38,280
is M with an arrow and the coefficient

1430
01:05:38,280 --> 01:05:40,619
Vector of M minus the sum of monomials

1431
01:05:40,619 --> 01:05:44,960
is exactly M minus the one vector

1432
01:05:46,140 --> 01:05:48,180
so yeah and for that we can just use the

1433
01:05:48,180 --> 01:05:50,339
second bullet point of the framework

1434
01:05:50,339 --> 01:05:53,220
so that's the intuition

1435
01:05:53,220 --> 01:05:55,500
and similarly with proving linear

1436
01:05:55,500 --> 01:05:57,240
relations well if I want to prove that

1437
01:05:57,240 --> 01:05:59,220
the inner product of A and M is equal to

1438
01:05:59,220 --> 01:06:00,059
U

1439
01:06:00,059 --> 01:06:02,040
for public Anu

1440
01:06:02,040 --> 01:06:04,020
then we're just using dilemma we just

1441
01:06:04,020 --> 01:06:05,160
need to prove that the constant

1442
01:06:05,160 --> 01:06:08,339
coefficient of Sigma of a times M minus

1443
01:06:08,339 --> 01:06:11,420
U is equal to zero

1444
01:06:12,180 --> 01:06:14,460
okay so now we are ready to discuss some

1445
01:06:14,460 --> 01:06:17,160
to discuss the one out of many proofs

1446
01:06:17,160 --> 01:06:19,980
so intuitively we can think of it as

1447
01:06:19,980 --> 01:06:22,680
some set membership proof

1448
01:06:22,680 --> 01:06:25,799
so suppose we have some n values he want

1449
01:06:25,799 --> 01:06:27,299
up to DN

1450
01:06:27,299 --> 01:06:30,480
and um well in our case we will pick n

1451
01:06:30,480 --> 01:06:33,720
to B from base beta to the L

1452
01:06:33,720 --> 01:06:35,520
so we want to prove that we know some

1453
01:06:35,520 --> 01:06:37,380
opening M and R

1454
01:06:37,380 --> 01:06:39,839
such that for some index I commitment of

1455
01:06:39,839 --> 01:06:42,599
M and R is equal to TI and obviously

1456
01:06:42,599 --> 01:06:46,020
because we want it to be formed we want

1457
01:06:46,020 --> 01:06:47,460
the proof to be zero knowledge so in

1458
01:06:47,460 --> 01:06:49,200
particular we don't want to reveal any

1459
01:06:49,200 --> 01:06:50,579
information about

1460
01:06:50,579 --> 01:06:53,900
uh the indexer

1461
01:06:55,020 --> 01:06:57,119
so yeah so it's time for some technical

1462
01:06:57,119 --> 01:06:59,220
overview put the members The Matrix call

1463
01:06:59,220 --> 01:07:02,940
it U so we put these values as a Columns

1464
01:07:02,940 --> 01:07:04,559
of that Matrix

1465
01:07:04,559 --> 01:07:07,200
uh multiplied by the selector name it B

1466
01:07:07,200 --> 01:07:09,599
so we would Define this vector v to be

1467
01:07:09,599 --> 01:07:12,180
the the vector the binary Vector which

1468
01:07:12,180 --> 01:07:15,720
has one in the I position

1469
01:07:15,720 --> 01:07:17,520
and that's a linear equation it's easy

1470
01:07:17,520 --> 01:07:19,319
to see well now it's not really easy to

1471
01:07:19,319 --> 01:07:21,420
see but if we Define the lattice based

1472
01:07:21,420 --> 01:07:24,539
commitment then maybe it's easier so if

1473
01:07:24,539 --> 01:07:26,520
we Define the commitment to be a n plus

1474
01:07:26,520 --> 01:07:28,020
br

1475
01:07:28,020 --> 01:07:31,579
then the right hand side is the Matrix

1476
01:07:31,579 --> 01:07:34,260
The Matrix U which consists of these

1477
01:07:34,260 --> 01:07:37,319
columns you want to up to TN times the

1478
01:07:37,319 --> 01:07:39,780
selector Vector which has one in the ice

1479
01:07:39,780 --> 01:07:41,400
position

1480
01:07:41,400 --> 01:07:43,260
so the right hand side is just U times

1481
01:07:43,260 --> 01:07:45,500
two

1482
01:07:47,039 --> 01:07:49,140
so we don't want to commit to it that's

1483
01:07:49,140 --> 01:07:52,380
linear size so the the vector v has

1484
01:07:52,380 --> 01:07:53,940
length n

1485
01:07:53,940 --> 01:07:56,579
so we recall n is B to the L

1486
01:07:56,579 --> 01:07:58,859
so we cancel decomposing to small VI's

1487
01:07:58,859 --> 01:08:01,680
so here the trick which was used in the

1488
01:08:01,680 --> 01:08:03,599
original paper by growth and cold wise

1489
01:08:03,599 --> 01:08:05,819
and then in Matrix Matrix plus smile and

1490
01:08:05,819 --> 01:08:07,440
so on

1491
01:08:07,440 --> 01:08:10,319
um the the key idea is that if we have

1492
01:08:10,319 --> 01:08:11,640
this Vector I

1493
01:08:11,640 --> 01:08:13,980
which has exactly one one and all zeros

1494
01:08:13,980 --> 01:08:15,539
in all the other places then we can

1495
01:08:15,539 --> 01:08:18,359
tensor decompose it into smaller vectors

1496
01:08:18,359 --> 01:08:21,299
VI's where each Di has Dimension has

1497
01:08:21,299 --> 01:08:22,679
length beta

1498
01:08:22,679 --> 01:08:26,460
it's binary and it has exactly one one

1499
01:08:26,460 --> 01:08:28,198
so for example

1500
01:08:28,198 --> 01:08:30,359
yeah it's a very small example the zero

1501
01:08:30,359 --> 01:08:32,880
one zero zero Vector can be decomposed

1502
01:08:32,880 --> 01:08:36,500
as one zero ten zero zero one

1503
01:08:38,460 --> 01:08:41,939
so okay if I put M and R together and a

1504
01:08:41,939 --> 01:08:43,859
and b together then basically we just

1505
01:08:43,859 --> 01:08:46,439
want to prove equations like a s is

1506
01:08:46,439 --> 01:08:49,560
equal to U times V1 tensor V2 tensor up

1507
01:08:49,560 --> 01:08:52,100
to VL

1508
01:08:53,339 --> 01:08:54,660
so

1509
01:08:54,660 --> 01:08:57,359
to do this first we we do the standard

1510
01:08:57,359 --> 01:08:59,339
trick well if I want to prove this

1511
01:08:59,339 --> 01:09:01,020
equation I will just

1512
01:09:01,020 --> 01:09:03,000
I will get the random Vector as a

1513
01:09:03,000 --> 01:09:04,439
challenge and I will do the inner

1514
01:09:04,439 --> 01:09:05,759
product and prove that the inner product

1515
01:09:05,759 --> 01:09:08,219
is equal to zero

1516
01:09:08,219 --> 01:09:10,259
so what do we get so

1517
01:09:10,259 --> 01:09:12,179
so what I described is the first line of

1518
01:09:12,179 --> 01:09:14,660
this equation

1519
01:09:15,060 --> 01:09:17,399
um where the Phi is this random vector

1520
01:09:17,399 --> 01:09:20,040
and then the second line is I will just

1521
01:09:20,040 --> 01:09:22,439
move the matrices around from the left

1522
01:09:22,439 --> 01:09:24,000
to right so

1523
01:09:24,000 --> 01:09:25,979
at the beginning I had the U on the left

1524
01:09:25,979 --> 01:09:27,479
hand side now I have you on the right

1525
01:09:27,479 --> 01:09:28,560
hand side

1526
01:09:28,560 --> 01:09:30,600
uh the same with a

1527
01:09:30,600 --> 01:09:33,479
and then the third line is a little bit

1528
01:09:33,479 --> 01:09:35,399
more complicated

1529
01:09:35,399 --> 01:09:37,080
so for the third line we will use the

1530
01:09:37,080 --> 01:09:39,299
following Lemma which says that

1531
01:09:39,299 --> 01:09:42,299
if I have some vectors A and B

1532
01:09:42,299 --> 01:09:45,238
a has Dimension n and B has Dimension M

1533
01:09:45,238 --> 01:09:49,319
and W has length n times M and I can

1534
01:09:49,319 --> 01:09:53,399
write this as sub vectors W1 up to WN

1535
01:09:53,399 --> 01:09:56,040
then the inner product of a answer B

1536
01:09:56,040 --> 01:09:58,380
with W is equal to the inner product of

1537
01:09:58,380 --> 01:10:01,320
a and the Matrix W1 transpose W2

1538
01:10:01,320 --> 01:10:05,480
transpose up to w n transpose times B

1539
01:10:05,520 --> 01:10:07,800
so it just

1540
01:10:07,800 --> 01:10:10,860
well nothing too complicated

1541
01:10:10,860 --> 01:10:11,520
um

1542
01:10:11,520 --> 01:10:15,840
so to use this Lemo well we set a to bb1

1543
01:10:15,840 --> 01:10:19,500
we set B to be V2 transpose V2 tensor up

1544
01:10:19,500 --> 01:10:20,760
to VL

1545
01:10:20,760 --> 01:10:24,719
yeah to be uh to be B and W is the U

1546
01:10:24,719 --> 01:10:27,540
transpose file

1547
01:10:27,540 --> 01:10:32,100
so so that's um so we get the U Bar

1548
01:10:32,100 --> 01:10:34,980
okay so now the idea is that we will

1549
01:10:34,980 --> 01:10:37,800
we'll commit well informally we will

1550
01:10:37,800 --> 01:10:40,380
commit to X1 which is that complicated

1551
01:10:40,380 --> 01:10:41,580
term

1552
01:10:41,580 --> 01:10:43,380
in the inner product

1553
01:10:43,380 --> 01:10:47,219
which is new bar times V2 tensor V3 up

1554
01:10:47,219 --> 01:10:48,540
to VL

1555
01:10:48,540 --> 01:10:50,219
and then there are two things to prove

1556
01:10:50,219 --> 01:10:51,960
so I mean the first one is to prove well

1557
01:10:51,960 --> 01:10:54,480
formless of X1 so you want to prove that

1558
01:10:54,480 --> 01:10:57,480
X1 is indeed equal to U Bar times EQ

1559
01:10:57,480 --> 01:10:58,880
transfer

1560
01:10:58,880 --> 01:11:01,260
up to the L

1561
01:11:01,260 --> 01:11:03,300
and basically we want to prove the

1562
01:11:03,300 --> 01:11:04,800
equation right so we want to prove that

1563
01:11:04,800 --> 01:11:08,300
0 is equal to the inner product of B1 X1

1564
01:11:08,300 --> 01:11:12,679
minus S A transpose five

1565
01:11:14,100 --> 01:11:17,340
so okay let's focus on the case beta is

1566
01:11:17,340 --> 01:11:18,900
equal to D

1567
01:11:18,900 --> 01:11:20,880
so that we have these two equations to

1568
01:11:20,880 --> 01:11:23,280
prove and okay so the second one

1569
01:11:23,280 --> 01:11:25,380
uh we can see that it's

1570
01:11:25,380 --> 01:11:28,080
it's kind of equivalent to proving that

1571
01:11:28,080 --> 01:11:30,360
the constant coefficient of Sigma of V1

1572
01:11:30,360 --> 01:11:33,780
times X1 minus Sigma of a transpose by

1573
01:11:33,780 --> 01:11:37,199
transpose s is equal to zero

1574
01:11:37,199 --> 01:11:39,179
um yeah here I have used the notation a

1575
01:11:39,179 --> 01:11:41,940
bit because a transpose Phi is a vector

1576
01:11:41,940 --> 01:11:43,800
but what I would do is just I'll just

1577
01:11:43,800 --> 01:11:46,860
map it to the polynomial vector and then

1578
01:11:46,860 --> 01:11:49,620
take the transverse

1579
01:11:49,620 --> 01:11:51,000
um

1580
01:11:51,000 --> 01:11:53,460
okay but for the first one well it's

1581
01:11:53,460 --> 01:11:55,500
still it still looks complicated however

1582
01:11:55,500 --> 01:11:58,620
it's kind of very very similar statement

1583
01:11:58,620 --> 01:12:01,080
to what we are actually started from

1584
01:12:01,080 --> 01:12:03,060
and we can use the same idea by

1585
01:12:03,060 --> 01:12:04,260
recursion

1586
01:12:04,260 --> 01:12:07,560
so so maybe so now I've had some X1 but

1587
01:12:07,560 --> 01:12:10,320
later on I will get the X2 X3 up to X

1588
01:12:10,320 --> 01:12:11,640
Theta

1589
01:12:11,640 --> 01:12:13,980
it's a typo but each of each of them has

1590
01:12:13,980 --> 01:12:16,699
length B

1591
01:12:17,760 --> 01:12:20,000
okay

1592
01:12:21,360 --> 01:12:23,699
it should be l

1593
01:12:23,699 --> 01:12:25,260
um

1594
01:12:25,260 --> 01:12:26,940
but yeah obviously we still need to

1595
01:12:26,940 --> 01:12:29,159
prove I don't know that the S has short

1596
01:12:29,159 --> 01:12:31,880
Norm or the vi is have binary

1597
01:12:31,880 --> 01:12:34,800
coefficients and all VI's have exactly

1598
01:12:34,800 --> 01:12:36,960
one one but this can be covered by the

1599
01:12:36,960 --> 01:12:39,320
framework

1600
01:12:40,320 --> 01:12:42,360
so if we if we just consider the

1601
01:12:42,360 --> 01:12:44,580
soundness error then

1602
01:12:44,580 --> 01:12:46,620
well if this original statement wasn't

1603
01:12:46,620 --> 01:12:50,040
true then this inner product uh this uh

1604
01:12:50,040 --> 01:12:52,500
yeah inner product check with a linear

1605
01:12:52,500 --> 01:12:54,420
random combination

1606
01:12:54,420 --> 01:12:57,480
this basically this equation uh would be

1607
01:12:57,480 --> 01:12:59,219
true with probability at most one over Q

1608
01:12:59,219 --> 01:13:01,980
so what happens if it's not negligible

1609
01:13:01,980 --> 01:13:05,100
for example if Q is 2 to the 64 then

1610
01:13:05,100 --> 01:13:07,380
do we need to repeat it twice it would

1611
01:13:07,380 --> 01:13:10,159
be a bit fancy

1612
01:13:10,199 --> 01:13:13,560
so we will We briefly describe how how

1613
01:13:13,560 --> 01:13:16,500
to achieve this one for property

1614
01:13:16,500 --> 01:13:19,800
um so let's set the base to BDO over two

1615
01:13:19,800 --> 01:13:23,640
and I will commit to polynomials WI

1616
01:13:23,640 --> 01:13:26,520
which for which the coefficient Vector

1617
01:13:26,520 --> 01:13:29,580
consists of the vi and the zero so let's

1618
01:13:29,580 --> 01:13:31,020
look at the right hand

1619
01:13:31,020 --> 01:13:33,600
yeah the right hand side of the of the

1620
01:13:33,600 --> 01:13:36,600
slide so I have the W1 the coefficient

1621
01:13:36,600 --> 01:13:38,880
Vector I know the top

1622
01:13:38,880 --> 01:13:41,280
right the first part of the coefficient

1623
01:13:41,280 --> 01:13:45,000
Vector is V1 and the rest are is zeros

1624
01:13:45,000 --> 01:13:46,860
and the nice thing of that which we will

1625
01:13:46,860 --> 01:13:48,900
use is that if I multiply

1626
01:13:48,900 --> 01:13:51,420
W1 of x to the D over two

1627
01:13:51,420 --> 01:13:53,880
then the second part will shift to the

1628
01:13:53,880 --> 01:13:56,100
first part but with the minus but it's

1629
01:13:56,100 --> 01:13:58,380
still zero and then the top part will

1630
01:13:58,380 --> 01:14:00,719
move to the bottom part so it will be

1631
01:14:00,719 --> 01:14:03,020
the one

1632
01:14:03,840 --> 01:14:07,920
okay so let me just run the proof with

1633
01:14:07,920 --> 01:14:10,380
two random uh vectors five zero and Phi

1634
01:14:10,380 --> 01:14:11,520
one

1635
01:14:11,520 --> 01:14:13,860
and I will end up with these two two

1636
01:14:13,860 --> 01:14:16,380
systems of of equations

1637
01:14:16,380 --> 01:14:18,900
so let me just focus okay and I will

1638
01:14:18,900 --> 01:14:20,940
also commit to X1

1639
01:14:20,940 --> 01:14:25,460
which now contains x 1 0 and X11

1640
01:14:27,480 --> 01:14:29,640
so we want to prove these four equations

1641
01:14:29,640 --> 01:14:31,920
so let's just go step by step

1642
01:14:31,920 --> 01:14:35,280
so let's start with the blue one so what

1643
01:14:35,280 --> 01:14:38,219
I claim is that the blue equation is

1644
01:14:38,219 --> 01:14:40,140
equivalent to proving well it's

1645
01:14:40,140 --> 01:14:41,760
equivalent to the constant coefficient

1646
01:14:41,760 --> 01:14:43,020
of this

1647
01:14:43,020 --> 01:14:45,900
blue polynomial is equal to zero which

1648
01:14:45,900 --> 01:14:49,800
is Sigma of W1 X1 minus Sigma of a

1649
01:14:49,800 --> 01:14:52,620
transpose by zero transpose s

1650
01:14:52,620 --> 01:14:54,780
and why why is it the case well the main

1651
01:14:54,780 --> 01:14:57,000
observation is that the inner product of

1652
01:14:57,000 --> 01:15:00,060
V1 x 1 0 is equal to the inner product

1653
01:15:00,060 --> 01:15:02,280
of W1 X1

1654
01:15:02,280 --> 01:15:05,219
so why because if we just look at the W1

1655
01:15:05,219 --> 01:15:07,140
the next one the coefficient vectors of

1656
01:15:07,140 --> 01:15:07,860
it

1657
01:15:07,860 --> 01:15:10,260
and the inner product will be exactly V1

1658
01:15:10,260 --> 01:15:12,480
times x one zero

1659
01:15:12,480 --> 01:15:14,760
plus zero

1660
01:15:14,760 --> 01:15:16,920
times x 1 1.

1661
01:15:16,920 --> 01:15:20,179
which is exactly what we wanted

1662
01:15:20,760 --> 01:15:23,280
and then to prove the then we focus on

1663
01:15:23,280 --> 01:15:25,020
the orange part

1664
01:15:25,020 --> 01:15:27,360
so I want to say that this orange

1665
01:15:27,360 --> 01:15:30,780
equation is equivalent to the constant

1666
01:15:30,780 --> 01:15:33,780
coefficient of the sigma of x to the to

1667
01:15:33,780 --> 01:15:37,679
the D over 2 times W1 times X1 minus

1668
01:15:37,679 --> 01:15:40,560
Sigma of a transpose by one transpose s

1669
01:15:40,560 --> 01:15:42,540
is equal to zero

1670
01:15:42,540 --> 01:15:45,420
and here it's kind of similar idea so we

1671
01:15:45,420 --> 01:15:48,300
want so we claim that we just need to

1672
01:15:48,300 --> 01:15:50,640
show that the inner product of V1 and

1673
01:15:50,640 --> 01:15:53,640
X11 is equal to the inner product of x

1674
01:15:53,640 --> 01:15:56,219
to the D over 2 times W one and one and

1675
01:15:56,219 --> 01:15:57,540
X1

1676
01:15:57,540 --> 01:15:59,460
and we can see it here so if we look at

1677
01:15:59,460 --> 01:16:00,300
the

1678
01:16:00,300 --> 01:16:03,540
the uh the coefficient vectors of x to

1679
01:16:03,540 --> 01:16:06,719
the D over 2 times W1 and X1

1680
01:16:06,719 --> 01:16:10,500
and it's zero times x 1 0 plus B1 times

1681
01:16:10,500 --> 01:16:12,600
X11

1682
01:16:12,600 --> 01:16:14,880
so yes

1683
01:16:14,880 --> 01:16:17,219
and then to prove these these things we

1684
01:16:17,219 --> 01:16:20,100
can just use the framework

1685
01:16:20,100 --> 01:16:22,080
um so yes the last part is the purple

1686
01:16:22,080 --> 01:16:23,880
equations

1687
01:16:23,880 --> 01:16:26,159
uh just by combining them we can see

1688
01:16:26,159 --> 01:16:30,360
that uh it's equivalent to X1 being u0

1689
01:16:30,360 --> 01:16:34,199
bar U1 Bar times V2 tensor V3 tensor up

1690
01:16:34,199 --> 01:16:35,640
to VL

1691
01:16:35,640 --> 01:16:37,679
and because we have one less tensor we

1692
01:16:37,679 --> 01:16:39,239
can just continue with the strategy with

1693
01:16:39,239 --> 01:16:41,718
because

1694
01:16:44,040 --> 01:16:46,620
so yeah so um just briefly about

1695
01:16:46,620 --> 01:16:48,120
performance I guess

1696
01:16:48,120 --> 01:16:49,860
all this time

1697
01:16:49,860 --> 01:16:50,520
um

1698
01:16:50,520 --> 01:16:53,219
but yeah so one of the many proofs can

1699
01:16:53,219 --> 01:16:54,719
be used directly to build free

1700
01:16:54,719 --> 01:16:57,780
signatures and group signatures

1701
01:16:57,780 --> 01:17:00,960
um this work uh our steam really scales

1702
01:17:00,960 --> 01:17:03,480
well with big sizes bring signature

1703
01:17:03,480 --> 01:17:04,679
sizes

1704
01:17:04,679 --> 01:17:08,820
so even for more than or around 221

1705
01:17:08,820 --> 01:17:10,080
um

1706
01:17:10,080 --> 01:17:11,880
it's moderately better than smile and

1707
01:17:11,880 --> 01:17:14,520
all the other Falafel Matrix and

1708
01:17:14,520 --> 01:17:17,340
calamari and the nice thing compared to

1709
01:17:17,340 --> 01:17:19,860
the lattice ones is that we have very

1710
01:17:19,860 --> 01:17:22,440
small public key sizes

1711
01:17:22,440 --> 01:17:26,760
so around 0.1 kilobytes

1712
01:17:26,760 --> 01:17:28,380
um just to showcase the integer

1713
01:17:28,380 --> 01:17:30,960
relations uh proves

1714
01:17:30,960 --> 01:17:32,460
um thanks to the fact that we don't need

1715
01:17:32,460 --> 01:17:34,380
to commit to these carry vectors we get

1716
01:17:34,380 --> 01:17:36,179
more than a factor to Improvement

1717
01:17:36,179 --> 01:17:37,679
compared to

1718
01:17:37,679 --> 01:17:40,020
the prior works

1719
01:17:40,020 --> 01:17:42,659
So yeah thank you very much and that

1720
01:17:42,659 --> 01:17:45,440
concludes my talk

1721
01:17:52,440 --> 01:17:56,000
so we have some questions

1722
01:18:01,739 --> 01:18:05,000
so apparently yeah people are hungry so

1723
01:18:05,000 --> 01:18:08,840
let's thank this figure again

