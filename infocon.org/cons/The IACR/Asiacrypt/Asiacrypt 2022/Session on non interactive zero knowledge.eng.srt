1
00:00:05,460 --> 00:00:08,220
um next I will talk about how we compile

2
00:00:08,220 --> 00:00:11,280
this music to anal proof

3
00:00:11,280 --> 00:00:14,299
for Simplicity

4
00:00:14,340 --> 00:00:16,619
um I will first talk about how we

5
00:00:16,619 --> 00:00:18,720
achieve the approve for one note of two

6
00:00:18,720 --> 00:00:19,859
disjunction

7
00:00:19,859 --> 00:00:22,320
in this construction the approver wants

8
00:00:22,320 --> 00:00:25,380
to prove that for two matrices m0 and M1

9
00:00:25,380 --> 00:00:28,019
and two statements x 0 and x one there

10
00:00:28,019 --> 00:00:30,180
exists sum J which is zero or one and

11
00:00:30,180 --> 00:00:33,420
some wind is W such that x j is equal to

12
00:00:33,420 --> 00:00:37,860
mjw the CRS is the same as before

13
00:00:37,860 --> 00:00:40,379
and to generate the proof the proof of

14
00:00:40,379 --> 00:00:43,500
our speed the original CRS are into a

15
00:00:43,500 --> 00:00:47,100
binding CRS RJ and hiding CRS R1 minus G

16
00:00:47,100 --> 00:00:49,680
such that the sum of these two CRS is

17
00:00:49,680 --> 00:00:52,379
equal to the original one and the

18
00:00:52,379 --> 00:00:58,020
trouble of the hiding CRS is uh is T

19
00:00:58,020 --> 00:00:59,760
Prime

20
00:00:59,760 --> 00:01:02,039
then the proverb generates the proofs

21
00:01:02,039 --> 00:01:07,439
for XJ and X1 minus J with the with wnt

22
00:01:07,439 --> 00:01:09,299
Prime with respective B by making use of

23
00:01:09,299 --> 00:01:11,220
the proverb and the simulator of the

24
00:01:11,220 --> 00:01:14,280
nisk of for the linear languages we

25
00:01:14,280 --> 00:01:16,260
talked about before

26
00:01:16,260 --> 00:01:18,659
the sun is follows from that when the

27
00:01:18,659 --> 00:01:22,799
party of R is one the either r0 and R1

28
00:01:22,799 --> 00:01:25,200
has Priority One which means that one of

29
00:01:25,200 --> 00:01:27,060
them must be biting

30
00:01:27,060 --> 00:01:30,000
and there's a the zero knowledge follows

31
00:01:30,000 --> 00:01:32,520
from that when the parity of bar is zero

32
00:01:32,520 --> 00:01:35,700
then both r0 and R1 will have Priority

33
00:01:35,700 --> 00:01:37,799
One uh we'll have parity zero which

34
00:01:37,799 --> 00:01:41,960
means that both of them will be hiding

35
00:01:42,360 --> 00:01:45,720
um two uh convert this or proof two are

36
00:01:45,720 --> 00:01:48,119
no proof for one out of n disjunction

37
00:01:48,119 --> 00:01:51,659
the natural anterior is just is just to

38
00:01:51,659 --> 00:01:55,380
split the CRS in a more General way uh

39
00:01:55,380 --> 00:01:58,140
at first uh assuming the JS statement is

40
00:01:58,140 --> 00:02:00,320
true at first we led the approval to

41
00:02:00,320 --> 00:02:03,600
speed the original fighting crsr into

42
00:02:03,600 --> 00:02:06,299
ncrs such that the sum of them is equal

43
00:02:06,299 --> 00:02:10,440
to the original one and only the JS CRS

44
00:02:10,440 --> 00:02:13,260
has the parity being one and the

45
00:02:13,260 --> 00:02:15,540
verifier will check whether the sum of

46
00:02:15,540 --> 00:02:17,879
all the CRS is equal to the original one

47
00:02:17,879 --> 00:02:20,580
however none of them can be performed in

48
00:02:20,580 --> 00:02:22,200
ac0

49
00:02:22,200 --> 00:02:25,020
so our solution is to propose a double

50
00:02:25,020 --> 00:02:28,500
layer sampler to sample and CRS with the

51
00:02:28,500 --> 00:02:32,580
sum being R uh and this and this sampler

52
00:02:32,580 --> 00:02:36,440
can be run in AC 0.

53
00:02:36,440 --> 00:02:39,300
the first layer we just sample entrop

54
00:02:39,300 --> 00:02:41,640
doors with the sum being a zero Vector

55
00:02:41,640 --> 00:02:44,459
this can be easily done by sampling MB

56
00:02:44,459 --> 00:02:47,099
strings with the priority being zero

57
00:02:47,099 --> 00:02:50,040
next in the second layer we just sample

58
00:02:50,040 --> 00:02:54,060
and hiding CRS which are run vectors in

59
00:02:54,060 --> 00:02:57,840
the span of E and we will sample these

60
00:02:57,840 --> 00:03:00,120
vectors by making use of the trapdos we

61
00:03:00,120 --> 00:03:01,920
talked about before and now we can

62
00:03:01,920 --> 00:03:04,680
obtain n hiding CIS with the sum being

63
00:03:04,680 --> 00:03:06,420
zero

64
00:03:06,420 --> 00:03:11,099
and next we will add the jscrs with with

65
00:03:11,099 --> 00:03:14,400
the original CRS which is r and now we

66
00:03:14,400 --> 00:03:17,340
obtain any random random CRS with the

67
00:03:17,340 --> 00:03:22,260
sum being R and the jscrs beam binding

68
00:03:22,260 --> 00:03:25,620
and we can see that this sampler allows

69
00:03:25,620 --> 00:03:28,980
approver to split the original CRS into

70
00:03:28,980 --> 00:03:33,540
ncrs satisfying our requirements in C in

71
00:03:33,540 --> 00:03:35,580
AC 0.

72
00:03:35,580 --> 00:03:38,519
and we also need an additional step for

73
00:03:38,519 --> 00:03:40,739
verification specifically we use the

74
00:03:40,739 --> 00:03:42,720
needs for linear languages to prove that

75
00:03:42,720 --> 00:03:46,080
the sum of all the split CRS is equal to

76
00:03:46,080 --> 00:03:48,540
the origin one and by making use of this

77
00:03:48,540 --> 00:03:50,340
proof the verifier can check the

78
00:03:50,340 --> 00:03:53,340
validity of the spleen CRS in ac0 since

79
00:03:53,340 --> 00:03:55,200
our needs for linear languages can be

80
00:03:55,200 --> 00:03:59,519
run in AC 0. here we need an ac0

81
00:03:59,519 --> 00:04:02,099
extractor which can extract the witness

82
00:04:02,099 --> 00:04:03,680
from the

83
00:04:03,680 --> 00:04:06,659
n-typos we talked about before and I

84
00:04:06,659 --> 00:04:08,879
will escape the details in this sort

85
00:04:08,879 --> 00:04:11,000
please see our paper for the details

86
00:04:11,000 --> 00:04:14,519
next I will talk about how we convert

87
00:04:14,519 --> 00:04:16,680
this all proof for multiple dysfunction

88
00:04:16,680 --> 00:04:19,680
to the new score ac0 circuit

89
00:04:19,680 --> 00:04:22,340
satisfiability

90
00:04:22,560 --> 00:04:24,960
um in our construction approval Texas

91
00:04:24,960 --> 00:04:28,259
improved awareness and the statement

92
00:04:28,259 --> 00:04:32,220
circuit which is in ac0 and it first

93
00:04:32,220 --> 00:04:34,020
extends the

94
00:04:34,020 --> 00:04:36,180
awareness to contain the bits of all

95
00:04:36,180 --> 00:04:37,259
wires

96
00:04:37,259 --> 00:04:40,080
if the win is is valid then the output

97
00:04:40,080 --> 00:04:42,060
must be one

98
00:04:42,060 --> 00:04:45,540
and then the Puba encodes each wire wi

99
00:04:45,540 --> 00:04:48,180
as a run Vector CTI with the parity

100
00:04:48,180 --> 00:04:50,220
being WI

101
00:04:50,220 --> 00:04:53,520
we can see that CTI is in the form that

102
00:04:53,520 --> 00:04:58,919
uh is in the form of E times r i plus

103
00:04:58,919 --> 00:05:03,180
the lowercase e times wi and RI is just

104
00:05:03,180 --> 00:05:05,460
some random vector

105
00:05:05,460 --> 00:05:08,580
and for each unbondifying and gate we

106
00:05:08,580 --> 00:05:10,320
just use the output for multiple this

107
00:05:10,320 --> 00:05:13,380
Junction to prove that either CTI minus

108
00:05:13,380 --> 00:05:16,800
E is in the span of e for some for all I

109
00:05:16,800 --> 00:05:22,139
or ctj and ctm plus M plus 1 which is

110
00:05:22,139 --> 00:05:24,780
the encoding for the output

111
00:05:24,780 --> 00:05:28,320
or in the spanovi for something and this

112
00:05:28,320 --> 00:05:30,539
is enough to ensure the consistence of

113
00:05:30,539 --> 00:05:33,000
the encoded wires

114
00:05:33,000 --> 00:05:36,120
uh here there's a change that to get the

115
00:05:36,120 --> 00:05:38,220
witness the approver has to decide which

116
00:05:38,220 --> 00:05:40,620
uh which wire corresponds to zero when

117
00:05:40,620 --> 00:05:44,039
the output is zero and we can see that

118
00:05:44,039 --> 00:05:45,960
the proofer cannot find such Wire by

119
00:05:45,960 --> 00:05:47,940
searching each wiring order otherwise

120
00:05:47,940 --> 00:05:51,660
the complexity will go beyond ac0.

121
00:05:51,660 --> 00:05:56,280
so we proved the existence open uh ac0

122
00:05:56,280 --> 00:05:58,440
algorithm that can output the index of

123
00:05:58,440 --> 00:06:02,520
the first zero bit or one bit amongst m

124
00:06:02,520 --> 00:06:06,120
beats and uh PCR paper for the details

125
00:06:06,120 --> 00:06:09,240
of the construction of this algorithm

126
00:06:09,240 --> 00:06:12,000
and for the or Gates we can prove the

127
00:06:12,000 --> 00:06:14,340
consistency in a similar way and for the

128
00:06:14,340 --> 00:06:17,520
Nuggets we just proved that the sum of e

129
00:06:17,520 --> 00:06:20,340
the lowercase e and the input and output

130
00:06:20,340 --> 00:06:22,860
encodings of the gate are in this

131
00:06:22,860 --> 00:06:25,080
penalty

132
00:06:25,080 --> 00:06:27,720
so this is how we get the target

133
00:06:27,720 --> 00:06:29,759
construction of our needs and we can

134
00:06:29,759 --> 00:06:31,919
also extend our needs to the

135
00:06:31,919 --> 00:06:36,120
non-interactive zaps uh which are the uh

136
00:06:36,120 --> 00:06:38,819
which is equal which doesn't mean the

137
00:06:38,819 --> 00:06:40,919
miw in the plane model

138
00:06:40,919 --> 00:06:43,740
uh to achieve this converging we just

139
00:06:43,740 --> 00:06:45,960
proved that our needs have their very

140
00:06:45,960 --> 00:06:48,479
viable currently GP generation and with

141
00:06:48,479 --> 00:06:49,620
this property

142
00:06:49,620 --> 00:06:52,319
we can just use the gos converging

143
00:06:52,319 --> 00:06:55,020
technique to transform our disk to

144
00:06:55,020 --> 00:06:57,240
non-interactive types

145
00:06:57,240 --> 00:06:59,819
and we can also convert our needs to

146
00:06:59,819 --> 00:07:03,240
Once In A URS model for doing this we

147
00:07:03,240 --> 00:07:06,360
just we can just see that the Run Vector

148
00:07:06,360 --> 00:07:09,180
is a binding CRS and hiding on CRS with

149
00:07:09,180 --> 00:07:11,160
the half of probability and by running

150
00:07:11,160 --> 00:07:13,500
our needs with the random CRS in

151
00:07:13,500 --> 00:07:15,479
parallel we can just achieve our needs

152
00:07:15,479 --> 00:07:18,060
in the URS model the zero knowledge of

153
00:07:18,060 --> 00:07:20,819
the resulting disk just follows from

154
00:07:20,819 --> 00:07:23,160
that of the underlying it's in the CRS

155
00:07:23,160 --> 00:07:25,800
model and the statistical soundness just

156
00:07:25,800 --> 00:07:28,199
follows from that form many random

157
00:07:28,199 --> 00:07:30,300
streams at least one should be binding

158
00:07:30,300 --> 00:07:33,419
with overwhelming probability so this is

159
00:07:33,419 --> 00:07:35,580
how we get the converging and this is

160
00:07:35,580 --> 00:07:38,400
the conclusion of our work we proposed

161
00:07:38,400 --> 00:07:40,440
fanguine proof systems that are

162
00:07:40,440 --> 00:07:42,660
unconditionally secure against ac0

163
00:07:42,660 --> 00:07:45,720
adversaries and all of them can be run

164
00:07:45,720 --> 00:07:50,520
in ac0 the proof system includes disks

165
00:07:50,520 --> 00:07:54,479
for ac0 1365 BG non-interactive zaps and

166
00:07:54,479 --> 00:07:57,599
it's in the uis model thank you that's

167
00:07:57,599 --> 00:07:59,900
all

168
00:08:05,759 --> 00:08:08,300
question

169
00:08:18,550 --> 00:08:20,639
[Music]

170
00:08:20,639 --> 00:08:23,400
I just great talk a quick question about

171
00:08:23,400 --> 00:08:25,440
how you sample in the OR composition

172
00:08:25,440 --> 00:08:28,500
construction you said you sample T of

173
00:08:28,500 --> 00:08:30,479
these vectors that sum to zero they have

174
00:08:30,479 --> 00:08:33,059
to be sparse right so how exactly do you

175
00:08:33,059 --> 00:08:35,820
sample those in ac0 N vectors that sum

176
00:08:35,820 --> 00:08:37,700
to zero

177
00:08:37,700 --> 00:08:39,360
okay

178
00:08:39,360 --> 00:08:41,940
um let me see so uh are you talking

179
00:08:41,940 --> 00:08:44,700
about these two distributions uh can you

180
00:08:44,700 --> 00:08:46,200
see the screen

181
00:08:46,200 --> 00:08:48,959
no no this is this was in the OR

182
00:08:48,959 --> 00:08:50,459
composition Construction

183
00:08:50,459 --> 00:08:52,320
how you can't just split you have to

184
00:08:52,320 --> 00:08:56,760
pick T1 through TN okay okay okay I see

185
00:08:56,760 --> 00:08:58,440
uh so

186
00:08:58,440 --> 00:09:00,839
um actually in the first in the first

187
00:09:00,839 --> 00:09:04,380
step we just sample n trapdos with the

188
00:09:04,380 --> 00:09:07,380
sum being a zero vector and this can be

189
00:09:07,380 --> 00:09:10,080
done in ac0 since we just make use of

190
00:09:10,080 --> 00:09:13,260
the d0 and D1 uh the the d0 distribution

191
00:09:13,260 --> 00:09:16,080
we talked about before uh and this is in

192
00:09:16,080 --> 00:09:19,940
AC zero and in the second layer we just

193
00:09:19,940 --> 00:09:21,860
sample the

194
00:09:21,860 --> 00:09:24,899
ncrs by making use of the trapdos we

195
00:09:24,899 --> 00:09:27,360
talked about before and in this step we

196
00:09:27,360 --> 00:09:28,800
just Computing

197
00:09:28,800 --> 00:09:32,940
et1 to etn and since e is sparse so the

198
00:09:32,940 --> 00:09:36,480
multiplication can be performed in AC 0.

199
00:09:36,480 --> 00:09:39,959
so this step can also be done in ac0 and

200
00:09:39,959 --> 00:09:44,120
we will also add the JS statement with r

201
00:09:44,120 --> 00:09:47,040
which is the original crsc and this step

202
00:09:47,040 --> 00:09:50,700
is also in ac0 since we just make an

203
00:09:50,700 --> 00:09:51,720
addition

204
00:09:51,720 --> 00:09:55,800
so all of the steps can be done in ac0

205
00:09:55,800 --> 00:09:59,640
and uh of course we should also generate

206
00:09:59,640 --> 00:10:01,980
the proof of the in these for linear

207
00:10:01,980 --> 00:10:05,160
languages and in this in this case we

208
00:10:05,160 --> 00:10:08,220
have to extract awareness

209
00:10:08,220 --> 00:10:10,620
that can be used to prove that the sum

210
00:10:10,620 --> 00:10:13,200
of the split CRS is equal to the origin

211
00:10:13,200 --> 00:10:16,800
one and uh we can also do this by making

212
00:10:16,800 --> 00:10:19,140
use of the entry blocks with some in the

213
00:10:19,140 --> 00:10:20,519
first layer

214
00:10:20,519 --> 00:10:23,899
so basically all the multiplications

215
00:10:23,899 --> 00:10:27,959
uh just involves the multiple uh just

216
00:10:27,959 --> 00:10:31,260
involves the Matrix e which is sparse

217
00:10:31,260 --> 00:10:34,200
and run Vector so all of them can be

218
00:10:34,200 --> 00:10:37,980
computed in ac0

219
00:10:42,440 --> 00:10:45,800
great application

220
00:10:48,500 --> 00:10:52,100
but is there any question

221
00:10:55,200 --> 00:10:57,660
from Zoom

222
00:10:57,660 --> 00:10:59,820
uh no question so let's thank the

223
00:10:59,820 --> 00:11:01,079
speaker again

224
00:11:01,079 --> 00:11:03,680
thanks

225
00:11:09,600 --> 00:11:13,279
the next talk is briefly adaptive using

226
00:11:13,279 --> 00:11:17,579
nizk by rankinetti pratik soccer Xiao

227
00:11:17,579 --> 00:11:21,920
one and practic will give the talk

228
00:11:23,100 --> 00:11:24,779
hi can you hear me

229
00:11:24,779 --> 00:11:28,339
yes okay

230
00:11:35,760 --> 00:11:37,620
so you can start whenever you're ready

231
00:11:37,620 --> 00:11:41,459
yeah I'm ready okay hi my name is pratik

232
00:11:41,459 --> 00:11:43,079
and today I'm gonna talk about triply

233
00:11:43,079 --> 00:11:45,600
adaptive using music so this is a joint

234
00:11:45,600 --> 00:11:49,459
work with Ron Kennedy and xiawang

235
00:11:49,560 --> 00:11:52,019
so I will first briefly introduce uh

236
00:11:52,019 --> 00:11:53,760
Netflix

237
00:11:53,760 --> 00:11:55,680
so in a non-interactive zero knowledge

238
00:11:55,680 --> 00:11:58,560
this approval P who has inputs NP

239
00:11:58,560 --> 00:12:00,839
statement X and the witness W and the

240
00:12:00,839 --> 00:12:03,300
verifier has the same NP statement X and

241
00:12:03,300 --> 00:12:05,339
they also have access to a setup which

242
00:12:05,339 --> 00:12:08,040
is a CRS and then the approval computes

243
00:12:08,040 --> 00:12:11,279
a proof pi as attesting the fact that X

244
00:12:11,279 --> 00:12:13,860
is in the language L and W is a valid

245
00:12:13,860 --> 00:12:16,200
witness so correctness says that if x is

246
00:12:16,200 --> 00:12:17,940
in the language and W is valid then

247
00:12:17,940 --> 00:12:21,060
verify outputs one soundness says that

248
00:12:21,060 --> 00:12:23,279
if X is not in the language then the

249
00:12:23,279 --> 00:12:25,440
verified output 0 with high probability

250
00:12:25,440 --> 00:12:27,720
and then we have non-adaptive you know

251
00:12:27,720 --> 00:12:30,480
knowledge which is as follows so here

252
00:12:30,480 --> 00:12:33,660
the simulator first samples a CRS and

253
00:12:33,660 --> 00:12:36,420
the trapdoor and it and the verifier

254
00:12:36,420 --> 00:12:39,740
obtains this CRS I mean the verifier

255
00:12:39,740 --> 00:12:42,540
obtains has an NP statement and the

256
00:12:42,540 --> 00:12:45,060
simulator also has an NP State print and

257
00:12:45,060 --> 00:12:46,920
the simulator comes up with a simulated

258
00:12:46,920 --> 00:12:49,260
proof and the simulate and it sends the

259
00:12:49,260 --> 00:12:51,540
simulated proof to the verifier and

260
00:12:51,540 --> 00:12:53,339
non-adaptive zero analysis

261
00:12:53,339 --> 00:12:55,260
that this simulated proof should be

262
00:12:55,260 --> 00:12:57,779
indistinguishable from a real proof

263
00:12:57,779 --> 00:13:00,660
and then this is the non-interactive

264
00:13:00,660 --> 00:13:02,820
zero knowledge that we know it satisfies

265
00:13:02,820 --> 00:13:04,079
these properties

266
00:13:04,079 --> 00:13:06,000
so we introduce the notion of triply

267
00:13:06,000 --> 00:13:08,639
adaptive music which uh adds three

268
00:13:08,639 --> 00:13:10,920
additional properties on top of the

269
00:13:10,920 --> 00:13:12,959
previous properties mainly we require

270
00:13:12,959 --> 00:13:14,940
adaptive soundness adaptive zero

271
00:13:14,940 --> 00:13:16,980
knowledge and adaptive security so let

272
00:13:16,980 --> 00:13:19,139
me Define these primitive these

273
00:13:19,139 --> 00:13:21,300
properties and then I'm gonna talk why

274
00:13:21,300 --> 00:13:22,680
they are interesting

275
00:13:22,680 --> 00:13:25,740
so adaptive soundness uh there's a

276
00:13:25,740 --> 00:13:27,600
challenger who samples the CRS and

277
00:13:27,600 --> 00:13:29,519
provides it to the prover and the cut

278
00:13:29,519 --> 00:13:32,399
approver now samples a NP statement and

279
00:13:32,399 --> 00:13:34,860
a proof to the Challenger and adaptive

280
00:13:34,860 --> 00:13:37,079
soundness says that if X is not in the

281
00:13:37,079 --> 00:13:38,639
language then the Challenger should

282
00:13:38,639 --> 00:13:41,220
output 0 with high probability where the

283
00:13:41,220 --> 00:13:43,500
Challenger runs the verified algorithm

284
00:13:43,500 --> 00:13:45,839
on the NP statement chosen by the

285
00:13:45,839 --> 00:13:48,300
proverb and the proof

286
00:13:48,300 --> 00:13:51,000
and note that adaptive soundness is

287
00:13:51,000 --> 00:13:54,060
stronger than like regular soundness in

288
00:13:54,060 --> 00:13:57,779
fact the growth or the gos paper is

289
00:13:57,779 --> 00:14:00,139
sound but not adaptively sound

290
00:14:00,139 --> 00:14:03,060
then uh we have like adaptive zero

291
00:14:03,060 --> 00:14:07,200
knowledge uh where uh the simulated

292
00:14:07,200 --> 00:14:09,480
samples the CRS and trapdoor and it

293
00:14:09,480 --> 00:14:12,060
sends the CRS to the corrupt verifier

294
00:14:12,060 --> 00:14:14,639
now the verifier comes up uh with a

295
00:14:14,639 --> 00:14:17,459
sample I mean samples X and W in the

296
00:14:17,459 --> 00:14:19,740
language after obtaining the CRS and it

297
00:14:19,740 --> 00:14:21,360
sends the statement text to the

298
00:14:21,360 --> 00:14:23,760
simulator so the statement takes is

299
00:14:23,760 --> 00:14:25,440
adaptively chosen based on the CRS

300
00:14:25,440 --> 00:14:26,459
distribution

301
00:14:26,459 --> 00:14:29,279
now the simulator uh again computes a

302
00:14:29,279 --> 00:14:31,200
simulated proof and sends it to the

303
00:14:31,200 --> 00:14:33,420
corrupt verifier and adaptives we don't

304
00:14:33,420 --> 00:14:35,820
know let's see that this simulated proof

305
00:14:35,820 --> 00:14:37,440
should be indistinguishable from a real

306
00:14:37,440 --> 00:14:40,019
proof even though the statement is

307
00:14:40,019 --> 00:14:43,019
adaptively chosen based on the CRS

308
00:14:43,019 --> 00:14:45,120
so this is adaptive zero knowledge and

309
00:14:45,120 --> 00:14:47,220
finally we need adaptive security

310
00:14:47,220 --> 00:14:50,820
against adaptive Corruptions so here uh

311
00:14:50,820 --> 00:14:53,220
suppose initially the proofer is honest

312
00:14:53,220 --> 00:14:55,560
and the simulator against samples the

313
00:14:55,560 --> 00:14:57,360
CRS and trapdoor not the verified

314
00:14:57,360 --> 00:14:59,940
obtains the CRS and again samples NP

315
00:14:59,940 --> 00:15:01,980
statement X and W in the language and

316
00:15:01,980 --> 00:15:04,500
sends a statement to the stimulator now

317
00:15:04,500 --> 00:15:06,779
the simulator comes up with a simulated

318
00:15:06,779 --> 00:15:08,820
proof similar to the Zeno knowledge game

319
00:15:08,820 --> 00:15:10,860
and sells the simulated proof to the

320
00:15:10,860 --> 00:15:14,579
verify but now suppose the proofer gets

321
00:15:14,579 --> 00:15:16,620
adaptively corrupted after the protocol

322
00:15:16,620 --> 00:15:19,079
execution in such a situation the

323
00:15:19,079 --> 00:15:21,660
simulator has to come up uh with a

324
00:15:21,660 --> 00:15:23,940
Randomness which is consistent with the

325
00:15:23,940 --> 00:15:27,420
witness W and the simulated proof so

326
00:15:27,420 --> 00:15:28,920
security against adaptive correction

327
00:15:28,920 --> 00:15:31,920
says that this simulated proof should be

328
00:15:31,920 --> 00:15:35,760
uh consistent with the witness uh like

329
00:15:35,760 --> 00:15:38,279
the honest witness and some Randomness

330
00:15:38,279 --> 00:15:41,279
provided by the simulator so if you have

331
00:15:41,279 --> 00:15:43,199
this indistinguishability then you have

332
00:15:43,199 --> 00:15:45,839
security against adaptive corruption

333
00:15:45,839 --> 00:15:48,180
so a triple adaptive music is a type of

334
00:15:48,180 --> 00:15:49,740
music which satisfies these three

335
00:15:49,740 --> 00:15:51,660
properties adaptive soundness adaptive

336
00:15:51,660 --> 00:15:53,100
zero knowledge and adaptive security

337
00:15:53,100 --> 00:15:55,560
against corruption that is soundness and

338
00:15:55,560 --> 00:15:57,959
zero knowledge should hold even when the

339
00:15:57,959 --> 00:15:59,820
statements are chosen by the adversary

340
00:15:59,820 --> 00:16:03,060
uh based on the CRS distribution and

341
00:16:03,060 --> 00:16:04,620
adaptive security is security against

342
00:16:04,620 --> 00:16:06,720
adaptive Corruption of Google

343
00:16:06,720 --> 00:16:09,899
so why is this interesting because this

344
00:16:09,899 --> 00:16:13,620
notion of triply triple adaptivity uh

345
00:16:13,620 --> 00:16:15,720
provides realistic security guarantees

346
00:16:15,720 --> 00:16:18,180
here the proofer can basically use the

347
00:16:18,180 --> 00:16:20,519
same CRS to prove adaptively chosen

348
00:16:20,519 --> 00:16:23,279
statements and we need security against

349
00:16:23,279 --> 00:16:24,959
adaptive Corruptions because this is

350
00:16:24,959 --> 00:16:27,600
very useful for real-life MPC protocols

351
00:16:27,600 --> 00:16:29,760
where you are going to plug in your

352
00:16:29,760 --> 00:16:31,740
music protocol inside a bigger NPC

353
00:16:31,740 --> 00:16:32,880
protocol

354
00:16:32,880 --> 00:16:36,420
and finally we also extend our uh music

355
00:16:36,420 --> 00:16:39,959
to obtain UC security and we also extend

356
00:16:39,959 --> 00:16:42,540
it to the reusable CRS model so that you

357
00:16:42,540 --> 00:16:44,579
can use the same theaters across

358
00:16:44,579 --> 00:16:45,959
multiple sessions between different

359
00:16:45,959 --> 00:16:48,120
parties so this part is done using

360
00:16:48,120 --> 00:16:51,180
standard techniques from the literature

361
00:16:51,180 --> 00:16:53,759
so let me now briefly describe the state

362
00:16:53,759 --> 00:16:56,160
of the art and how it how they compare

363
00:16:56,160 --> 00:16:59,160
with our main result so the first work

364
00:16:59,160 --> 00:17:03,180
on adaptively secure nesic was initiated

365
00:17:03,180 --> 00:17:07,199
by growth I the GEOS people

366
00:17:07,199 --> 00:17:09,660
um so they construct it from pairings

367
00:17:09,660 --> 00:17:12,000
they obtain adaptive security and

368
00:17:12,000 --> 00:17:13,679
adaptive zero knowledge but they fail to

369
00:17:13,679 --> 00:17:15,540
get adaptive soundness in fact they

370
00:17:15,540 --> 00:17:16,980
obtain a weaker notion of soundness

371
00:17:16,980 --> 00:17:18,799
called adaptive culture the soundness

372
00:17:18,799 --> 00:17:23,400
because the real and Ideal World CRS is

373
00:17:23,400 --> 00:17:24,959
just computationally uh

374
00:17:24,959 --> 00:17:26,760
indistinguishable because they are in

375
00:17:26,760 --> 00:17:28,740
the Dual mode setting dual mode CRS

376
00:17:28,740 --> 00:17:30,960
settings and then there was this work by

377
00:17:30,960 --> 00:17:33,299
katsu Mata who extended the GEOS work

378
00:17:33,299 --> 00:17:36,419
for compact music they also achieved

379
00:17:36,419 --> 00:17:38,940
similar Notions of security in terms of

380
00:17:38,940 --> 00:17:40,980
triple adaptivity and they're also based

381
00:17:40,980 --> 00:17:42,480
on parents

382
00:17:42,480 --> 00:17:44,940
and then was there was a work by Abe and

383
00:17:44,940 --> 00:17:47,100
fur so they constructed the first triply

384
00:17:47,100 --> 00:17:51,120
adaptive and they were they I mean their

385
00:17:51,120 --> 00:17:52,740
protocol relied on knowledge assumptions

386
00:17:52,740 --> 00:17:56,460
so our task is to obtain triple

387
00:17:56,460 --> 00:17:58,620
adaptivity from standard Notions where

388
00:17:58,620 --> 00:18:01,380
we don't need knowledge assumptions

389
00:18:01,380 --> 00:18:03,780
then there's a recent line of work uh

390
00:18:03,780 --> 00:18:04,799
which is based on correlation

391
00:18:04,799 --> 00:18:07,500
interactable hash functions so this has

392
00:18:07,500 --> 00:18:10,020
been started by Kennedy at all piket at

393
00:18:10,020 --> 00:18:11,820
all and Records k at all so they obtain

394
00:18:11,820 --> 00:18:13,559
adaptive soundness and adaptive zero

395
00:18:13,559 --> 00:18:15,660
knowledge and they can instantiate their

396
00:18:15,660 --> 00:18:19,980
digits from lwe or ddh plus LPN however

397
00:18:19,980 --> 00:18:21,840
they fail to achieve adaptive security

398
00:18:21,840 --> 00:18:24,600
corruption so our work is the first one

399
00:18:24,600 --> 00:18:26,720
which obtains triple adaptive security

400
00:18:26,720 --> 00:18:30,960
and we obtain it from lwe and DDS plus

401
00:18:30,960 --> 00:18:33,780
LPN assumption and we are also in the CI

402
00:18:33,780 --> 00:18:37,799
based uh CI based domain

403
00:18:37,799 --> 00:18:39,720
so let's see some of the challenges and

404
00:18:39,720 --> 00:18:42,720
ideas so our protocol is in this

405
00:18:42,720 --> 00:18:44,160
correlation interactable hash function

406
00:18:44,160 --> 00:18:46,860
based protocol domain so the cids

407
00:18:46,860 --> 00:18:48,539
protocols actually required the

408
00:18:48,539 --> 00:18:50,460
interactive protocol to be statistically

409
00:18:50,460 --> 00:18:52,320
sound so that you can apply the CI

410
00:18:52,320 --> 00:18:54,720
argument however this contradicts

411
00:18:54,720 --> 00:18:56,940
adaptive security as in security against

412
00:18:56,940 --> 00:18:59,520
adaptive Corruptions since uh a

413
00:18:59,520 --> 00:19:01,320
statistically sound protocol cannot be

414
00:19:01,320 --> 00:19:04,140
equivocated upon adaptive corruption

415
00:19:04,140 --> 00:19:06,360
also previous adaptively secure

416
00:19:06,360 --> 00:19:09,140
protocols like gos

417
00:19:09,140 --> 00:19:12,120
use switch the CRS mode to perform

418
00:19:12,120 --> 00:19:14,160
equitocation as a result they only

419
00:19:14,160 --> 00:19:16,679
achieve non-adaptive from this so you

420
00:19:16,679 --> 00:19:18,419
cannot adapt it you cannot achieve

421
00:19:18,419 --> 00:19:20,400
adaptive soundness if you switch the

422
00:19:20,400 --> 00:19:21,960
mode of the CRS

423
00:19:21,960 --> 00:19:26,580
so we overcome these uh like this these

424
00:19:26,580 --> 00:19:28,500
problems so by showing that you can

425
00:19:28,500 --> 00:19:30,960
apply for hme for interactive arguments

426
00:19:30,960 --> 00:19:33,660
instead of an interactive proof system

427
00:19:33,660 --> 00:19:36,720
so we do this by relying on CI in the

428
00:19:36,720 --> 00:19:38,160
hybrids

429
00:19:38,160 --> 00:19:40,980
and our underlying uh proof system is an

430
00:19:40,980 --> 00:19:42,480
argument as a result it's

431
00:19:42,480 --> 00:19:44,160
computationally binding and hence

432
00:19:44,160 --> 00:19:46,440
equivocal and this allows us to get

433
00:19:46,440 --> 00:19:48,919
adaptive security corruption

434
00:19:48,919 --> 00:19:51,720
and finally we perform our soundness

435
00:19:51,720 --> 00:19:53,580
argument without switching the mode of

436
00:19:53,580 --> 00:19:56,340
the CRS as a result we obtain a full

437
00:19:56,340 --> 00:19:59,100
adaptive soundness

438
00:19:59,100 --> 00:20:01,740
and now let me formally Define our

439
00:20:01,740 --> 00:20:04,919
contributions so we first Define a new

440
00:20:04,919 --> 00:20:06,299
non-interactive user commitment

441
00:20:06,299 --> 00:20:08,880
functionality which is uh which we

442
00:20:08,880 --> 00:20:12,240
denote is as if Nikon so the current uh

443
00:20:12,240 --> 00:20:14,460
UC commitment non-interactive UC

444
00:20:14,460 --> 00:20:16,080
commitment functionalities require

445
00:20:16,080 --> 00:20:19,500
interaction between the parties even if

446
00:20:19,500 --> 00:20:21,840
uh even for like local commitment

447
00:20:21,840 --> 00:20:24,240
generation and verification and that is

448
00:20:24,240 --> 00:20:27,480
very incompatible with MPC protocols so

449
00:20:27,480 --> 00:20:30,120
we overcome that by introducing this

450
00:20:30,120 --> 00:20:31,320
non-interactive user commitment

451
00:20:31,320 --> 00:20:34,020
functionality and here the parties can

452
00:20:34,020 --> 00:20:36,539
access the fnicom locally for commitment

453
00:20:36,539 --> 00:20:37,980
verification I mean commitment

454
00:20:37,980 --> 00:20:39,840
generation and commitment verification

455
00:20:39,840 --> 00:20:42,840
and our functionality also outputs the

456
00:20:42,840 --> 00:20:44,520
commitment string during the commit

457
00:20:44,520 --> 00:20:47,460
phase so this is this models a

458
00:20:47,460 --> 00:20:50,160
non-interactive commitment more uh and

459
00:20:50,160 --> 00:20:55,080
also it's very friendly to MPC protocols

460
00:20:55,080 --> 00:20:57,419
and then uh we introduced the notion of

461
00:20:57,419 --> 00:20:59,580
triply adaptive Sigma protocol in the if

462
00:20:59,580 --> 00:21:02,520
Nikon Model and then we show how to

463
00:21:02,520 --> 00:21:04,919
compile such Sigma protocols to obtain

464
00:21:04,919 --> 00:21:07,260
triply adaptive music by using

465
00:21:07,260 --> 00:21:09,179
correlation interactable hash functions

466
00:21:09,179 --> 00:21:13,559
and inside this compilation we are

467
00:21:13,559 --> 00:21:15,299
actually applying correlation

468
00:21:15,299 --> 00:21:18,480
interactivity for nissic arguments

469
00:21:18,480 --> 00:21:21,840
and finally we instantiate our compiler

470
00:21:21,840 --> 00:21:24,419
by showing that most Sigma Protocols are

471
00:21:24,419 --> 00:21:26,460
typically adaptive in the F Nikon Model

472
00:21:26,460 --> 00:21:29,159
and finally we implement the if Nikon

473
00:21:29,159 --> 00:21:31,020
with commitment schemes with a current

474
00:21:31,020 --> 00:21:33,539
efficient commitment scheme and we can

475
00:21:33,539 --> 00:21:36,120
Implement our like these two

476
00:21:36,120 --> 00:21:40,620
instantiations from lwe or ddh plus LPN

477
00:21:40,620 --> 00:21:44,340
and we can extend our uh protocol to

478
00:21:44,340 --> 00:21:46,559
obtain UC security using standard tricks

479
00:21:46,559 --> 00:21:48,419
from the literature

480
00:21:48,419 --> 00:21:50,940
now let me briefly Define this uh UC

481
00:21:50,940 --> 00:21:53,760
commitment functionality

482
00:21:53,760 --> 00:21:58,799
so uh here uh the like then uh you see

483
00:21:58,799 --> 00:22:00,419
non-interactive commitment functionality

484
00:22:00,419 --> 00:22:02,520
is first initialized by the ideal World

485
00:22:02,520 --> 00:22:04,860
adversary with a simulation algorithm s

486
00:22:04,860 --> 00:22:07,260
this algorithm is hard coded inside the

487
00:22:07,260 --> 00:22:09,360
commitment functionality and that allows

488
00:22:09,360 --> 00:22:11,340
helps us to generate commitment strings

489
00:22:11,340 --> 00:22:13,679
and verify so now when a committer wants

490
00:22:13,679 --> 00:22:15,480
to commit to a message M it invokes a

491
00:22:15,480 --> 00:22:17,400
commitment functionality with a with the

492
00:22:17,400 --> 00:22:18,900
message M and it receives a commitment

493
00:22:18,900 --> 00:22:20,340
string C

494
00:22:20,340 --> 00:22:22,620
and now the verifier obtains the string

495
00:22:22,620 --> 00:22:25,080
C from somewhere maybe from an MPC

496
00:22:25,080 --> 00:22:27,240
protocol or directly from the proverb

497
00:22:27,240 --> 00:22:30,000
which we don't know and now to verify

498
00:22:30,000 --> 00:22:31,860
the verify just need to invoke the

499
00:22:31,860 --> 00:22:33,659
commitment functionality with the string

500
00:22:33,659 --> 00:22:36,539
C and it obtains the output as 0r1

501
00:22:36,539 --> 00:22:39,299
indicating verification has failed or

502
00:22:39,299 --> 00:22:41,640
verification has succeeded and the

503
00:22:41,640 --> 00:22:43,980
verifier outputs the same bit

504
00:22:43,980 --> 00:22:47,039
and uh we show that uh the kinet

505
00:22:47,039 --> 00:22:50,400
efficient commitment uh suffices to

506
00:22:50,400 --> 00:22:52,260
instantiate this commitment

507
00:22:52,260 --> 00:22:55,140
functionality and if there exists an

508
00:22:55,140 --> 00:22:56,880
equivalent commitment scheme and a CCA

509
00:22:56,880 --> 00:22:59,039
to secure public encryption scheme with

510
00:22:59,039 --> 00:23:01,080
oblivious ciphertext sampling then there

511
00:23:01,080 --> 00:23:02,940
exists a commitment scheme implementing

512
00:23:02,940 --> 00:23:05,460
this functionality and we can we build

513
00:23:05,460 --> 00:23:08,340
these from lwe or ddh

514
00:23:08,340 --> 00:23:11,580
now uh let me uh Define the notion of

515
00:23:11,580 --> 00:23:13,320
triply adaptive Sigma protocol in the

516
00:23:13,320 --> 00:23:15,360
fnicer model

517
00:23:15,360 --> 00:23:17,520
but before that let me briefly talk

518
00:23:17,520 --> 00:23:19,740
about what is the sigma protocol so in a

519
00:23:19,740 --> 00:23:21,900
sigma protocol there it's a public coin

520
00:23:21,900 --> 00:23:23,520
three down protocol where the prover

521
00:23:23,520 --> 00:23:25,080
computes the first message a which

522
00:23:25,080 --> 00:23:27,299
mainly consists of commitments and now

523
00:23:27,299 --> 00:23:30,000
the verifier uh samples a random

524
00:23:30,000 --> 00:23:31,320
Challenge and sends it to the proverb

525
00:23:31,320 --> 00:23:33,419
and the proverb computes the response

526
00:23:33,419 --> 00:23:35,159
and sends it to the verifier and now it

527
00:23:35,159 --> 00:23:37,320
should satisfy correctness and it should

528
00:23:37,320 --> 00:23:38,880
satisfy some property called special

529
00:23:38,880 --> 00:23:41,159
soundness that is if a curve approver

530
00:23:41,159 --> 00:23:44,880
outputs to accepting proofs a e z and AE

531
00:23:44,880 --> 00:23:47,159
Prime Z Prime that is for the same first

532
00:23:47,159 --> 00:23:49,260
message a if the proverb has computed

533
00:23:49,260 --> 00:23:51,360
two valid responses for two different

534
00:23:51,360 --> 00:23:54,720
challenges then you can uh extract a

535
00:23:54,720 --> 00:23:57,960
valid witness from the transcripts from

536
00:23:57,960 --> 00:24:00,059
the two African groups so this is

537
00:24:00,059 --> 00:24:02,039
special soundness and then you require

538
00:24:02,039 --> 00:24:04,080
honest verified zero knowledge which

539
00:24:04,080 --> 00:24:06,120
says that there exists a simulator which

540
00:24:06,120 --> 00:24:08,280
on obtaining a random challenge can come

541
00:24:08,280 --> 00:24:10,799
up with a honest verifies their

542
00:24:10,799 --> 00:24:13,020
knowledge proof that is an assimilated

543
00:24:13,020 --> 00:24:16,020
AEG which looks indistinguishable from a

544
00:24:16,020 --> 00:24:18,000
real proof so this is uh the honor 35

545
00:24:18,000 --> 00:24:19,380
zero knowledge

546
00:24:19,380 --> 00:24:21,600
now let me Define the adaptively secure

547
00:24:21,600 --> 00:24:24,299
Sigma protocol in the fnicom model here

548
00:24:24,299 --> 00:24:26,520
we assume that the proofer and the

549
00:24:26,520 --> 00:24:28,799
verifier algorithm have access to the

550
00:24:28,799 --> 00:24:32,280
fnicom functionality to compute this a

551
00:24:32,280 --> 00:24:34,740
and z messages so

552
00:24:34,740 --> 00:24:36,960
under the hood it's like the prover can

553
00:24:36,960 --> 00:24:38,880
use the iPhone icon to perform the

554
00:24:38,880 --> 00:24:42,539
commitments in a and uh it can decommit

555
00:24:42,539 --> 00:24:45,960
uh to I mean the it can compute the D

556
00:24:45,960 --> 00:24:47,640
commitments to Z and send it to the

557
00:24:47,640 --> 00:24:49,679
verifier and the verifier can verify Z

558
00:24:49,679 --> 00:24:52,380
using the F1 code

559
00:24:52,380 --> 00:24:54,179
and now it should satisfy correctness

560
00:24:54,179 --> 00:24:55,740
and special soundness same as the sigma

561
00:24:55,740 --> 00:24:58,200
protocol in addition we also need the

562
00:24:58,200 --> 00:24:59,880
honest verified zero knowledge here

563
00:24:59,880 --> 00:25:02,460
again uh we assume that there exists a

564
00:25:02,460 --> 00:25:04,980
simulator algorithm denoted as Sim 1

565
00:25:04,980 --> 00:25:06,960
which has access to the simulation

566
00:25:06,960 --> 00:25:09,840
algorithm of the commitment string and

567
00:25:09,840 --> 00:25:11,400
it can compute as honest verifies the

568
00:25:11,400 --> 00:25:12,600
knowledge proof

569
00:25:12,600 --> 00:25:15,179
and we also require adaptive corruption

570
00:25:15,179 --> 00:25:17,940
security that is suppose the prover gets

571
00:25:17,940 --> 00:25:19,799
corrupted after the protocol execution

572
00:25:19,799 --> 00:25:22,440
then uh there exists a simulated

573
00:25:22,440 --> 00:25:25,559
algorithm Sim 2 which upon obtaining the

574
00:25:25,559 --> 00:25:28,740
witness and the randomness of the first

575
00:25:28,740 --> 00:25:31,260
simulator can come up with a Randomness

576
00:25:31,260 --> 00:25:32,760
which is consistent with the simulated

577
00:25:32,760 --> 00:25:37,200
proof and uh the witness

578
00:25:37,200 --> 00:25:40,260
so uh to summarize this is the type of

579
00:25:40,260 --> 00:25:42,840
security that we need adapter secure uh

580
00:25:42,840 --> 00:25:44,700
hvck

581
00:25:44,700 --> 00:25:46,860
and this is the rapid pcq Sigma protocol

582
00:25:46,860 --> 00:25:49,559
in the fnicom model now the next step is

583
00:25:49,559 --> 00:25:51,059
to compile it to an adaptively secure

584
00:25:51,059 --> 00:25:51,960
music

585
00:25:51,960 --> 00:25:55,200
so we are going to do this by using the

586
00:25:55,200 --> 00:25:59,039
correlation interactable hash functions

587
00:25:59,039 --> 00:26:01,919
so before that let me show the feature

588
00:26:01,919 --> 00:26:03,840
me transform so suppose you have a sigma

589
00:26:03,840 --> 00:26:07,380
protocol to make it an is it uh you use

590
00:26:07,380 --> 00:26:09,840
a hash function H where the proverb

591
00:26:09,840 --> 00:26:12,779
computes uh the first message a and then

592
00:26:12,779 --> 00:26:16,020
it computes a challenge e by applying

593
00:26:16,020 --> 00:26:19,020
the hash function h on the message a and

594
00:26:19,020 --> 00:26:21,720
you can sometimes you can also compute

595
00:26:21,720 --> 00:26:25,200
like uh in a parameterize this with the

596
00:26:25,200 --> 00:26:27,120
statement X but here we don't need that

597
00:26:27,120 --> 00:26:29,640
and then you send compute the response

598
00:26:29,640 --> 00:26:32,100
and send a and z as the proof to the

599
00:26:32,100 --> 00:26:34,400
verifier now the the verifier can

600
00:26:34,400 --> 00:26:37,200
compute recompute The Challenge and then

601
00:26:37,200 --> 00:26:40,140
perform the sigma verification

602
00:26:40,140 --> 00:26:43,919
and now uh this hash function can be

603
00:26:43,919 --> 00:26:45,840
instantiated using a correlation

604
00:26:45,840 --> 00:26:48,360
interactable hash function so what is

605
00:26:48,360 --> 00:26:49,440
the correlation interactable hash

606
00:26:49,440 --> 00:26:51,720
function so a hash family H is called

607
00:26:51,720 --> 00:26:53,279
correlation interactable whereas

608
00:26:53,279 --> 00:26:55,799
particulation R if given a hash function

609
00:26:55,799 --> 00:26:58,500
H from the hash family it is infeasible

610
00:26:58,500 --> 00:27:01,799
to find X such that X comma h of X is in

611
00:27:01,799 --> 00:27:03,539
the relation that is for all

612
00:27:03,539 --> 00:27:05,100
probabilistically political time

613
00:27:05,100 --> 00:27:07,679
adversaries a uh

614
00:27:07,679 --> 00:27:11,340
it's infeasible to some computer X such

615
00:27:11,340 --> 00:27:13,320
that X comma h of X is in the relation

616
00:27:13,320 --> 00:27:15,480
for a random hash function from the hash

617
00:27:15,480 --> 00:27:19,320
family and for a function f we denote uh

618
00:27:19,320 --> 00:27:23,520
the relation R of s as X comma f of x

619
00:27:23,520 --> 00:27:26,159
so now we can

620
00:27:26,159 --> 00:27:30,240
we can replace the hash previous hash

621
00:27:30,240 --> 00:27:33,059
function with a CI hash for relation R

622
00:27:33,059 --> 00:27:35,940
Pi where R Pi consists of a comma e such

623
00:27:35,940 --> 00:27:39,299
that that exists of V where verify x e

624
00:27:39,299 --> 00:27:41,580
and z so this is the correlation

625
00:27:41,580 --> 00:27:43,980
interactable hash function and these are

626
00:27:43,980 --> 00:27:45,779
like standard this is like very standard

627
00:27:45,779 --> 00:27:49,140
from the CI based literature and this

628
00:27:49,140 --> 00:27:51,120
then this music again has to satisfy

629
00:27:51,120 --> 00:27:53,400
correctness and soundness but here in

630
00:27:53,400 --> 00:27:55,320
the zero knowledge setting we assume

631
00:27:55,320 --> 00:27:57,059
that the simulator samples the hash

632
00:27:57,059 --> 00:27:59,580
function uh in the ideal world

633
00:27:59,580 --> 00:28:03,059
now uh that was uh preliminaries prelims

634
00:28:03,059 --> 00:28:05,640
for future me now we are going to show

635
00:28:05,640 --> 00:28:07,320
our triply adaptable secure music

636
00:28:07,320 --> 00:28:10,919
protocol so uh our native protocol is

637
00:28:10,919 --> 00:28:13,020
the scholars so we have the prover X

638
00:28:13,020 --> 00:28:15,480
comma W and it will compute the first

639
00:28:15,480 --> 00:28:18,659
message Alpha and then and also the

640
00:28:18,659 --> 00:28:21,059
response gamma so let's see how it

641
00:28:21,059 --> 00:28:23,820
computes this Alpha so first it computes

642
00:28:23,820 --> 00:28:27,240
two transcripts ac0 and zero and ac1 and

643
00:28:27,240 --> 00:28:30,480
Z1 for the same first message for two

644
00:28:30,480 --> 00:28:32,700
different prover chosen challenges c0

645
00:28:32,700 --> 00:28:35,940
not equal to C1 so it computes the two

646
00:28:35,940 --> 00:28:37,679
different transcripts for two different

647
00:28:37,679 --> 00:28:39,840
challenges for the same first message a

648
00:28:39,840 --> 00:28:43,020
and then it commits to the challenges uh

649
00:28:43,020 --> 00:28:45,299
using the F Nikon and it commits to the

650
00:28:45,299 --> 00:28:50,400
responses uh z31 Z1 using the F N icon

651
00:28:50,400 --> 00:28:53,100
then it considers the first message

652
00:28:53,100 --> 00:28:57,419
Alpha as a and the three commitments and

653
00:28:57,419 --> 00:28:59,460
then it constructs a challenge by

654
00:28:59,460 --> 00:29:02,220
invoking uh the hash function on Alpha

655
00:29:02,220 --> 00:29:05,700
so the hash function uh is a CI hash for

656
00:29:05,700 --> 00:29:08,400
the relation RF where f is the function

657
00:29:08,400 --> 00:29:12,000
where F of alpha is equal to 0 if and

658
00:29:12,000 --> 00:29:16,020
only if the verified algorithm on a c0

659
00:29:16,020 --> 00:29:19,740
and v 0 is equal to 1 where these c0 and

660
00:29:19,740 --> 00:29:22,440
zero are extracted from this Alpha that

661
00:29:22,440 --> 00:29:25,260
is from Capital C and Z 0 using the

662
00:29:25,260 --> 00:29:27,059
simulator algorithm of the commitment

663
00:29:27,059 --> 00:29:30,059
scheme so as you can see this uh s

664
00:29:30,059 --> 00:29:34,200
algorithm is inside the CI hash and now

665
00:29:34,200 --> 00:29:35,940
you construct The Challenge and finally

666
00:29:35,940 --> 00:29:40,320
the Rover can compute the response as by

667
00:29:40,320 --> 00:29:42,899
decommitting to the challenges c0 and C1

668
00:29:42,899 --> 00:29:45,419
and also to the response ready

669
00:29:45,419 --> 00:29:48,059
corresponding to the pit e and the

670
00:29:48,059 --> 00:29:50,220
commitment to Delta e

671
00:29:50,220 --> 00:29:52,860
now uh it sends uh now the approver is

672
00:29:52,860 --> 00:29:55,260
going to send this response Alpha I mean

673
00:29:55,260 --> 00:29:57,539
the first message Alpha and the response

674
00:29:57,539 --> 00:30:00,240
gamma and now the verified is going to

675
00:30:00,240 --> 00:30:03,480
compute the challenge e by invoking the

676
00:30:03,480 --> 00:30:05,520
hash function so this is going to be

677
00:30:05,520 --> 00:30:08,460
actually h of s this is a typo so this

678
00:30:08,460 --> 00:30:10,740
is the verifier is going to compute the

679
00:30:10,740 --> 00:30:13,080
challenge by invoking the same hash

680
00:30:13,080 --> 00:30:15,480
function on Alpha and now it's going to

681
00:30:15,480 --> 00:30:17,460
verify the D commitments to the two

682
00:30:17,460 --> 00:30:20,880
challenges and z in gamma and it also

683
00:30:20,880 --> 00:30:22,440
has to verify that the two challenges

684
00:30:22,440 --> 00:30:25,080
are different uh this is because we

685
00:30:25,080 --> 00:30:27,720
allow the prover to come up with the two

686
00:30:27,720 --> 00:30:29,880
challenges so if the two challenges are

687
00:30:29,880 --> 00:30:32,399
same then the approver can always uh

688
00:30:32,399 --> 00:30:34,200
construct like consider the two

689
00:30:34,200 --> 00:30:36,059
challenges to be the same back challenge

690
00:30:36,059 --> 00:30:38,340
so as a result we need two different

691
00:30:38,340 --> 00:30:40,440
challenges and the verified checks that

692
00:30:40,440 --> 00:30:41,460
over you

693
00:30:41,460 --> 00:30:43,740
and then the verifier just runs the

694
00:30:43,740 --> 00:30:47,460
sigma protocol verification on a c e and

695
00:30:47,460 --> 00:30:49,980
z z e and

696
00:30:49,980 --> 00:30:53,419
uh as you can and so this is our music

697
00:30:53,419 --> 00:30:55,919
compiler from our triply adaptive Sigma

698
00:30:55,919 --> 00:30:58,740
protocol I mean I mean from a adapting

699
00:30:58,740 --> 00:31:00,179
to secure Sigma protocol to an adapter

700
00:31:00,179 --> 00:31:02,279
to secure music and we can also argue

701
00:31:02,279 --> 00:31:05,220
that uh if the sigma protocol is triply

702
00:31:05,220 --> 00:31:08,000
adaptive then it's the nesicacy Adaptive

703
00:31:08,000 --> 00:31:11,100
and uh the adapter security and adaptive

704
00:31:11,100 --> 00:31:13,140
knowledge of the music follows from

705
00:31:13,140 --> 00:31:15,179
adaptive security of the sigma protocol

706
00:31:15,179 --> 00:31:18,840
in the F Nikon Model and soundness of

707
00:31:18,840 --> 00:31:21,059
the protocol relies on special soundness

708
00:31:21,059 --> 00:31:23,880
of Sigma protocol in if Nikon Model and

709
00:31:23,880 --> 00:31:26,039
the correlation interactability for the

710
00:31:26,039 --> 00:31:28,919
RF relation also the soundness of this

711
00:31:28,919 --> 00:31:35,039
protocol is half uh yeah and uh so

712
00:31:35,039 --> 00:31:38,940
uh regarding the CI we argue CI inside

713
00:31:38,940 --> 00:31:43,440
the uh hybrids uh yeah so we first show

714
00:31:43,440 --> 00:31:45,419
that in the F9 com model these

715
00:31:45,419 --> 00:31:47,279
commitments are statistically binding

716
00:31:47,279 --> 00:31:50,340
and then in the next hybrid by relying

717
00:31:50,340 --> 00:31:52,380
on special soundness we argue that the

718
00:31:52,380 --> 00:31:53,880
sigma protocol transcript is

719
00:31:53,880 --> 00:31:56,279
statistically binding and then in the

720
00:31:56,279 --> 00:31:58,919
final hybrid we rely on the statistical

721
00:31:58,919 --> 00:32:03,899
CI to argue Founders and the CI hash in

722
00:32:03,899 --> 00:32:07,440
our protocol is uh statistically I mean

723
00:32:07,440 --> 00:32:09,360
is defined in the statistical mode in

724
00:32:09,360 --> 00:32:10,620
real world

725
00:32:10,620 --> 00:32:13,500
so now uh let me talk about the

726
00:32:13,500 --> 00:32:14,700
instantiations

727
00:32:14,700 --> 00:32:18,000
uh so we show that uh most Sigma

728
00:32:18,000 --> 00:32:20,220
protocols like schnot type protocols or

729
00:32:20,220 --> 00:32:23,159
the protocols in the model framework are

730
00:32:23,159 --> 00:32:25,860
adaptively secure in the uh if micro

731
00:32:25,860 --> 00:32:27,960
model uh the gobble circuit based

732
00:32:27,960 --> 00:32:31,520
protocol of hazai at all uh is also

733
00:32:31,520 --> 00:32:34,440
adaptively secure and it avoids

734
00:32:34,440 --> 00:32:36,120
expensive car Productions even the

735
00:32:36,120 --> 00:32:38,580
protocols for graph hamiltonicity are

736
00:32:38,580 --> 00:32:40,799
adaptive physical and all of these can

737
00:32:40,799 --> 00:32:43,860
be implemented from lwe or ddh

738
00:32:43,860 --> 00:32:47,399
and finally we Implement a the current

739
00:32:47,399 --> 00:32:49,320
efficiently commitment and the equivocal

740
00:32:49,320 --> 00:32:51,480
commitments uh I mean current official

741
00:32:51,480 --> 00:32:53,399
commitment based on equivocal commitment

742
00:32:53,399 --> 00:32:56,039
and CC to secure encryption scheme and

743
00:32:56,039 --> 00:32:59,100
these can be instantiated from LW or ddh

744
00:32:59,100 --> 00:33:02,159
and note that for adaptive soundness we

745
00:33:02,159 --> 00:33:04,200
need the CRS distribution of real and

746
00:33:04,200 --> 00:33:06,120
Ideal World to be identical or

747
00:33:06,120 --> 00:33:07,380
statistically close for the commitment

748
00:33:07,380 --> 00:33:08,460
scheme

749
00:33:08,460 --> 00:33:13,440
so to finally summarize our uh result we

750
00:33:13,440 --> 00:33:15,240
proposed a new commitment functionality

751
00:33:15,240 --> 00:33:17,760
which is more protocol friendly and it

752
00:33:17,760 --> 00:33:20,940
has the use cases Beyond just music it

753
00:33:20,940 --> 00:33:23,760
can be useful for generic MPC then we

754
00:33:23,760 --> 00:33:25,140
propose the definition and provide a

755
00:33:25,140 --> 00:33:28,740
generic compiler for adaptive for using

756
00:33:28,740 --> 00:33:31,380
music with triple adaptivity then we

757
00:33:31,380 --> 00:33:34,440
instantiated the fnicom from cf01 and we

758
00:33:34,440 --> 00:33:36,600
instantiated our music compiler based on

759
00:33:36,600 --> 00:33:40,380
lwe or ddh plus LPN by instantiating the

760
00:33:40,380 --> 00:33:44,100
underlying CI hash so if you can obtain

761
00:33:44,100 --> 00:33:46,740
more instantiations of CI hash then you

762
00:33:46,740 --> 00:33:48,960
can obtain more instantiations of our

763
00:33:48,960 --> 00:33:51,320
music compiler for example you can also

764
00:33:51,320 --> 00:33:54,299
instantiate our music from sub

765
00:33:54,299 --> 00:33:57,240
exponential ddh by relying on the state

766
00:33:57,240 --> 00:34:00,539
of the art CI hash function from service

767
00:34:00,539 --> 00:34:05,000
so that's all uh thank you

768
00:34:18,619 --> 00:34:22,980
hey uh thanks for the great talk and uh

769
00:34:22,980 --> 00:34:25,199
you said that the adoptive zero

770
00:34:25,199 --> 00:34:29,000
knowledge mainly came from the

771
00:34:29,000 --> 00:34:32,040
umesque but it looks at uh in the paper

772
00:34:32,040 --> 00:34:35,940
you also state that the CIA hash with

773
00:34:35,940 --> 00:34:37,619
programmability

774
00:34:37,619 --> 00:34:40,080
so I wonder where this programmability

775
00:34:40,080 --> 00:34:43,320
of CIA hash is needed

776
00:34:43,320 --> 00:34:45,300
okay so we need the programmability of

777
00:34:45,300 --> 00:34:49,139
the CI hash uh in the hybrids to argue

778
00:34:49,139 --> 00:34:51,899
uh like uh we don't need it for

779
00:34:51,899 --> 00:34:53,339
simulation we need it for the reduction

780
00:34:53,339 --> 00:34:56,339
in the zero knowledge setting so that's

781
00:34:56,339 --> 00:34:57,540
fine

782
00:34:57,540 --> 00:35:00,420
and uh okay and as far as I remember

783
00:35:00,420 --> 00:35:03,200
this kind of this uh program

784
00:35:03,200 --> 00:35:06,060
programmability of hash is kind of one

785
00:35:06,060 --> 00:35:07,339
time

786
00:35:07,339 --> 00:35:11,280
so but uh it looks that you are reusing

787
00:35:11,280 --> 00:35:13,500
the CRS

788
00:35:13,500 --> 00:35:16,680
right how how is it possible to use

789
00:35:16,680 --> 00:35:19,680
continue using the same CRS for many

790
00:35:19,680 --> 00:35:22,440
different theorems

791
00:35:22,440 --> 00:35:24,780
right uh so you can

792
00:35:24,780 --> 00:35:26,760
so there are like a bunch of uh

793
00:35:26,760 --> 00:35:29,400
different Transformations so first we go

794
00:35:29,400 --> 00:35:33,300
from here to a short CRS model where we

795
00:35:33,300 --> 00:35:35,280
rely on the GEOS result and then we go

796
00:35:35,280 --> 00:35:38,700
to the result uh like we make it UC

797
00:35:38,700 --> 00:35:41,820
compatible by relying us on uh the

798
00:35:41,820 --> 00:35:45,119
special commitment uh uh called uh

799
00:35:45,119 --> 00:35:47,820
simulation sound uh chapter commitment

800
00:35:47,820 --> 00:35:50,339
so we rely on that to move to that

801
00:35:50,339 --> 00:35:52,560
setting right and the CI hash is

802
00:35:52,560 --> 00:35:55,020
programmed only for the reduction we

803
00:35:55,020 --> 00:35:58,140
don't need it for simulation so uh it's

804
00:35:58,140 --> 00:35:59,520
fine in that way

805
00:35:59,520 --> 00:36:02,839
does that make sense

806
00:36:04,320 --> 00:36:06,960
so to to go from like single session to

807
00:36:06,960 --> 00:36:09,839
multi-session you can use some

808
00:36:09,839 --> 00:36:11,820
simulation sound uh

809
00:36:11,820 --> 00:36:13,740
um acceptable commitment schemes uh

810
00:36:13,740 --> 00:36:16,079
which is there in the guest paper and

811
00:36:16,079 --> 00:36:17,880
also some signatures like one-time

812
00:36:17,880 --> 00:36:19,859
signatures so that's a like a very

813
00:36:19,859 --> 00:36:22,320
standard technique to uplift to UC

814
00:36:22,320 --> 00:36:24,660
security so that is there in the gos

815
00:36:24,660 --> 00:36:28,619
paper and also the paper by uh ran Cohen

816
00:36:28,619 --> 00:36:33,680
and abhishalot and Daniel weeks so yeah

817
00:36:34,020 --> 00:36:36,720
so time to move to the next thought so

818
00:36:36,720 --> 00:36:40,279
let's thank the speaker again thank you

819
00:36:54,240 --> 00:36:56,959
can you hear me

820
00:36:57,180 --> 00:37:00,660
so the next talk is efficient and IDK

821
00:37:00,660 --> 00:37:03,359
from nwe via polynomial reconstruction

822
00:37:03,359 --> 00:37:06,720
and NPC in the head by Paul low ready

823
00:37:06,720 --> 00:37:09,839
Gothard Amit sahai and Paul is going to

824
00:37:09,839 --> 00:37:12,020
talk

825
00:37:28,680 --> 00:37:30,119
all right

826
00:37:30,119 --> 00:37:30,660
um

827
00:37:30,660 --> 00:37:33,780
hi I'm Paul and this will be efficient

828
00:37:33,780 --> 00:37:36,359
physics from lwe via polynomial

829
00:37:36,359 --> 00:37:39,960
reconstruction and empathy in the head

830
00:37:39,960 --> 00:37:41,820
and this is Joint work with ready go

831
00:37:41,820 --> 00:37:45,599
shawl and amidst the high

832
00:37:45,599 --> 00:37:48,359
so our starting point is that prior to

833
00:37:48,359 --> 00:37:51,900
our work all no music Arguments for NP

834
00:37:51,900 --> 00:37:54,119
from the hardness of learning with

835
00:37:54,119 --> 00:37:55,020
errors

836
00:37:55,020 --> 00:37:57,000
considered instantiating the future near

837
00:37:57,000 --> 00:37:58,859
Paradigm based on a parallel repetition

838
00:37:58,859 --> 00:38:02,040
of a public coin honest verifier zero

839
00:38:02,040 --> 00:38:04,440
knowledge interactive proof so for ex

840
00:38:04,440 --> 00:38:06,599
and this is largely due to two Works CCH

841
00:38:06,599 --> 00:38:08,760
plus 19 and ps19

842
00:38:08,760 --> 00:38:11,040
so if you start with some anti-language

843
00:38:11,040 --> 00:38:12,000
l

844
00:38:12,000 --> 00:38:14,700
and consider some statement X in the

845
00:38:14,700 --> 00:38:15,540
language

846
00:38:15,540 --> 00:38:18,780
the way you would get an isik for L is

847
00:38:18,780 --> 00:38:21,300
first you'd apply the scar production on

848
00:38:21,300 --> 00:38:24,540
your statement X to some NP complete

849
00:38:24,540 --> 00:38:27,000
language such as graph hamiltonicity

850
00:38:27,000 --> 00:38:30,180
and the work of CCH plus 19 and ps19

851
00:38:30,180 --> 00:38:33,000
show us how to get a nizzic argument uh

852
00:38:33,000 --> 00:38:35,520
in the common random string model based

853
00:38:35,520 --> 00:38:36,720
off of some

854
00:38:36,720 --> 00:38:39,240
underlying protocol for hamiltonicity

855
00:38:39,240 --> 00:38:41,839
such as fls 90.

856
00:38:41,839 --> 00:38:45,119
and the work of hlr 21 shows how to

857
00:38:45,119 --> 00:38:46,680
extend this to any commit in open

858
00:38:46,680 --> 00:38:48,900
protocol such as the three coding

859
00:38:48,900 --> 00:38:52,740
protocol for gmw 86.

860
00:38:52,740 --> 00:38:54,960
and in all these underlying protocols

861
00:38:54,960 --> 00:38:56,820
you generally have a large proof size

862
00:38:56,820 --> 00:38:58,800
due to parallel repetition which is

863
00:38:58,800 --> 00:39:01,200
performed to reduce the soundness error

864
00:39:01,200 --> 00:39:04,040
down to negligible

865
00:39:04,920 --> 00:39:06,900
and in general this car production is

866
00:39:06,900 --> 00:39:08,520
computationally expensive so you also

867
00:39:08,520 --> 00:39:11,599
have this overhead as well

868
00:39:11,940 --> 00:39:14,640
and in our work we give an efficient

869
00:39:14,640 --> 00:39:17,940
base music construction for NP from lwe

870
00:39:17,940 --> 00:39:20,520
without parallel repetition and without

871
00:39:20,520 --> 00:39:23,640
car Productions and our tool of choice

872
00:39:23,640 --> 00:39:26,280
is NPC in the head which was done by

873
00:39:26,280 --> 00:39:29,040
icos of seven let me know if the there's

874
00:39:29,040 --> 00:39:32,900
like some fluctuation in the volume

875
00:39:33,300 --> 00:39:36,180
okay and in particular this allows us to

876
00:39:36,180 --> 00:39:38,040
translate work done on efficiently

877
00:39:38,040 --> 00:39:41,640
perfectly robust MPC protocols which

878
00:39:41,640 --> 00:39:44,579
exists from uh several works to

879
00:39:44,579 --> 00:39:47,820
efficient musics from lwe so you can

880
00:39:47,820 --> 00:39:49,680
think of our work as initiating the

881
00:39:49,680 --> 00:39:51,900
study of efficient musics from the

882
00:39:51,900 --> 00:39:54,980
hardness of learning Within

883
00:39:55,560 --> 00:39:58,140
and our main informal theorem is

884
00:39:58,140 --> 00:40:01,560
assuming the hardness of lwe

885
00:40:01,560 --> 00:40:03,480
there exists nizzix with computational

886
00:40:03,480 --> 00:40:05,940
soundness for all of NP

887
00:40:05,940 --> 00:40:08,579
whose proof size is O of C plus Q times

888
00:40:08,579 --> 00:40:11,160
depth of C plus poly K field elements in

889
00:40:11,160 --> 00:40:12,900
some finite field f

890
00:40:12,900 --> 00:40:15,119
where K is a security parameter

891
00:40:15,119 --> 00:40:16,980
Q is quasi-linear and the security

892
00:40:16,980 --> 00:40:19,619
parameter the size of the field is as

893
00:40:19,619 --> 00:40:22,079
large as two times Q

894
00:40:22,079 --> 00:40:24,720
and C is an arithmetic circuit for the

895
00:40:24,720 --> 00:40:27,119
MP verification function for some NP

896
00:40:27,119 --> 00:40:29,339
language l

897
00:40:29,339 --> 00:40:32,520
and here what we mean by a base is it

898
00:40:32,520 --> 00:40:34,560
construction is that the work of GGI

899
00:40:34,560 --> 00:40:35,820
plus 15

900
00:40:35,820 --> 00:40:38,520
show how to use fully homomorphic

901
00:40:38,520 --> 00:40:41,160
encryption the bootstrap and underlying

902
00:40:41,160 --> 00:40:43,859
music to an anizzic this proof size is

903
00:40:43,859 --> 00:40:46,020
effectively linear in the witness size

904
00:40:46,020 --> 00:40:48,000
so you can think of our main theorem as

905
00:40:48,000 --> 00:40:50,220
providing a music a more efficient

906
00:40:50,220 --> 00:40:52,680
underlying is it from the hardness of

907
00:40:52,680 --> 00:40:55,460
learning with errors

908
00:40:56,099 --> 00:40:58,380
as an overview of our technique we're

909
00:40:58,380 --> 00:41:00,839
going to follow hlr 21's coding

910
00:41:00,839 --> 00:41:03,599
theoretic approach to instantiating the

911
00:41:03,599 --> 00:41:05,160
fiatrimir transform

912
00:41:05,160 --> 00:41:07,619
and in particular their work shows how

913
00:41:07,619 --> 00:41:10,079
to use list recoverable error correcting

914
00:41:10,079 --> 00:41:11,099
codes

915
00:41:11,099 --> 00:41:13,140
to address the case of exponentially

916
00:41:13,140 --> 00:41:14,940
many bad challenges

917
00:41:14,940 --> 00:41:17,820
uh where the bad challenges have some

918
00:41:17,820 --> 00:41:19,859
product relation structure

919
00:41:19,859 --> 00:41:23,700
and in this approach the block size of

920
00:41:23,700 --> 00:41:25,200
this list recoverable error correcting

921
00:41:25,200 --> 00:41:26,760
code determines the efficiency of the

922
00:41:26,760 --> 00:41:29,040
proof here what we mean by efficiency of

923
00:41:29,040 --> 00:41:31,920
course is the proof size

924
00:41:31,920 --> 00:41:34,740
and in particular the list recoverable

925
00:41:34,740 --> 00:41:38,040
code they construct uses a part of a

926
00:41:38,040 --> 00:41:40,619
rashvardi code concatenated with a

927
00:41:40,619 --> 00:41:42,300
single random code

928
00:41:42,300 --> 00:41:45,480
and they achieve a block size of Big O

929
00:41:45,480 --> 00:41:48,480
of K to the one plus Epsilon for any

930
00:41:48,480 --> 00:41:50,760
small constant uh positive constant

931
00:41:50,760 --> 00:41:52,800
Epsilon

932
00:41:52,800 --> 00:41:55,680
and you can ask does the work of hlr 21

933
00:41:55,680 --> 00:41:57,780
generically apply to the setting of MPC

934
00:41:57,780 --> 00:41:58,859
in the head

935
00:41:58,859 --> 00:42:01,140
and indeed it does using the very

936
00:42:01,140 --> 00:42:03,359
specific properties of this parvovesh

937
00:42:03,359 --> 00:42:04,859
party code

938
00:42:04,859 --> 00:42:07,680
but we observe that this notion of

939
00:42:07,680 --> 00:42:09,900
General list recoverability doesn't take

940
00:42:09,900 --> 00:42:11,760
advantage of some structure that's

941
00:42:11,760 --> 00:42:14,280
actually present in the NPC in the head

942
00:42:14,280 --> 00:42:16,140
setting and we can actually do much

943
00:42:16,140 --> 00:42:17,280
better

944
00:42:17,280 --> 00:42:19,619
uh yeah so we show that this yields less

945
00:42:19,619 --> 00:42:20,940
efficient proofs

946
00:42:20,940 --> 00:42:23,880
and in our work uh we observe that a

947
00:42:23,880 --> 00:42:26,760
modification of the original icoso 7

948
00:42:26,760 --> 00:42:29,040
protocol for NPC in the head

949
00:42:29,040 --> 00:42:31,380
allows us to use a strictly weaker

950
00:42:31,380 --> 00:42:33,839
notion of list recoverability namely

951
00:42:33,839 --> 00:42:35,400
something we call recurrentless

952
00:42:35,400 --> 00:42:37,980
recoverability which we'll Define

953
00:42:37,980 --> 00:42:40,260
and this allows us to use qualitatively

954
00:42:40,260 --> 00:42:42,900
simpler codes namely read Solomon codes

955
00:42:42,900 --> 00:42:46,140
concatenated with multiple random codes

956
00:42:46,140 --> 00:42:48,839
and allows us to use aggregate size

957
00:42:48,839 --> 00:42:51,599
analysis and appeal to direct directly

958
00:42:51,599 --> 00:42:54,079
appeal to the polynomial reconstruction

959
00:42:54,079 --> 00:42:56,760
polynomial reconstruction algorithm to

960
00:42:56,760 --> 00:42:59,099
achieve and improve block size of O

961
00:42:59,099 --> 00:43:03,079
tilde of K so quasi-linear k

962
00:43:04,380 --> 00:43:07,800
all right so uh let's do a review of MPC

963
00:43:07,800 --> 00:43:10,859
in the head from Microsoft seven you

964
00:43:10,859 --> 00:43:13,260
have a prover and a verifier

965
00:43:13,260 --> 00:43:16,619
and the prover uh you want to build a ZK

966
00:43:16,619 --> 00:43:19,680
protocol or a hvck protocol

967
00:43:19,680 --> 00:43:23,640
an approver in her head imagines a empty

968
00:43:23,640 --> 00:43:25,920
carrying out an NPC protocol for some

969
00:43:25,920 --> 00:43:28,800
function f sub L which is really the MP

970
00:43:28,800 --> 00:43:30,599
verification function for some MP

971
00:43:30,599 --> 00:43:31,800
language l

972
00:43:31,800 --> 00:43:34,319
where the input here is the statement X

973
00:43:34,319 --> 00:43:37,020
and A Witness W which I expressed here

974
00:43:37,020 --> 00:43:40,560
as the as Q secret shares uh with secret

975
00:43:40,560 --> 00:43:42,540
shares W sub I

976
00:43:42,540 --> 00:43:45,599
and you can imagine Q parties who each

977
00:43:45,599 --> 00:43:48,900
get one share of the witness and the

978
00:43:48,900 --> 00:43:49,859
statement

979
00:43:49,859 --> 00:43:53,099
and we say the view of this party is its

980
00:43:53,099 --> 00:43:56,700
inputs its Randomness and its incoming

981
00:43:56,700 --> 00:43:58,140
messages though without loss of

982
00:43:58,140 --> 00:44:00,000
generality you can also think about and

983
00:44:00,000 --> 00:44:04,079
that's including the messages it sends

984
00:44:04,079 --> 00:44:06,420
and approver will in the first round

985
00:44:06,420 --> 00:44:10,440
send a commitment to all these views

986
00:44:10,440 --> 00:44:13,140
and note that these views also contain

987
00:44:13,140 --> 00:44:16,140
uh like Randomness and inputs and the

988
00:44:16,140 --> 00:44:18,300
verifier will then specify a random pair

989
00:44:18,300 --> 00:44:21,839
of parties pipj the approver will open

990
00:44:21,839 --> 00:44:24,660
to view I view J and the verifier will

991
00:44:24,660 --> 00:44:26,819
then just check the consistency of these

992
00:44:26,819 --> 00:44:29,160
views in the sense that the incoming

993
00:44:29,160 --> 00:44:30,540
messages and outgoing messages between

994
00:44:30,540 --> 00:44:33,480
these two views should be consistent

995
00:44:33,480 --> 00:44:36,900
and this is a black box use of the MPC

996
00:44:36,900 --> 00:44:39,119
protocol

997
00:44:39,119 --> 00:44:42,060
so let's unblockbox this

998
00:44:42,060 --> 00:44:45,119
so from if we take a look at the view of

999
00:44:45,119 --> 00:44:48,300
let's say P1 who has input X W1 and some

1000
00:44:48,300 --> 00:44:50,900
Randomness R perhaps in the first round

1001
00:44:50,900 --> 00:44:54,180
the P1 sent message one to P2 and

1002
00:44:54,180 --> 00:44:56,760
received message two from P3

1003
00:44:56,760 --> 00:45:00,119
for us to compute uh the next round's

1004
00:45:00,119 --> 00:45:02,400
messages namely the messages that P1

1005
00:45:02,400 --> 00:45:03,599
will send out

1006
00:45:03,599 --> 00:45:05,940
there's a deterministic next message

1007
00:45:05,940 --> 00:45:08,160
function next which takes in the

1008
00:45:08,160 --> 00:45:10,380
identity of the party one in this case

1009
00:45:10,380 --> 00:45:13,319
it's inputs X and W1

1010
00:45:13,319 --> 00:45:15,720
it's randoms R and all its previously

1011
00:45:15,720 --> 00:45:17,160
received messages because you can always

1012
00:45:17,160 --> 00:45:18,480
just recompete all the sent messages

1013
00:45:18,480 --> 00:45:20,400
from the receive messages

1014
00:45:20,400 --> 00:45:21,960
and it computes all the next round

1015
00:45:21,960 --> 00:45:23,579
messages that this party would send out

1016
00:45:23,579 --> 00:45:26,339
so here in round three the next function

1017
00:45:26,339 --> 00:45:29,760
would say that P1 sends M3 to P2 and M4

1018
00:45:29,760 --> 00:45:32,099
to P3

1019
00:45:32,099 --> 00:45:35,579
and this allows us this non-black boxing

1020
00:45:35,579 --> 00:45:37,380
of the MPC protocol allows us to define

1021
00:45:37,380 --> 00:45:39,180
a modification of the icos protocol

1022
00:45:39,180 --> 00:45:41,760
which will be important for how we

1023
00:45:41,760 --> 00:45:44,400
instantiate fiatrimir later on in

1024
00:45:44,400 --> 00:45:45,660
particular what we're going to do is

1025
00:45:45,660 --> 00:45:47,099
we're going to have the prover

1026
00:45:47,099 --> 00:45:51,060
commit once to a transcript of the MPC

1027
00:45:51,060 --> 00:45:53,579
protocol including all the inputs and

1028
00:45:53,579 --> 00:45:55,140
randomness

1029
00:45:55,140 --> 00:45:57,060
and now the verify instead of specing a

1030
00:45:57,060 --> 00:45:58,680
pair of parties will just specify a

1031
00:45:58,680 --> 00:46:00,599
single-party p sub I

1032
00:46:00,599 --> 00:46:03,180
and approver will open all the incident

1033
00:46:03,180 --> 00:46:05,520
messages the randomness and the inputs

1034
00:46:05,520 --> 00:46:06,960
for a piece of I

1035
00:46:06,960 --> 00:46:08,520
and the verifier will now use this

1036
00:46:08,520 --> 00:46:10,680
non-black box usage of the MPC protocol

1037
00:46:10,680 --> 00:46:12,060
in that it's going to use the next

1038
00:46:12,060 --> 00:46:14,460
function itself to check the consistency

1039
00:46:14,460 --> 00:46:17,359
of these messages

1040
00:46:18,599 --> 00:46:21,780
and to do soundness you can specify that

1041
00:46:21,780 --> 00:46:24,420
the verifier instead specifies up to XC

1042
00:46:24,420 --> 00:46:26,940
many random parties in some set s

1043
00:46:26,940 --> 00:46:28,619
and this will boost the soundness and

1044
00:46:28,619 --> 00:46:30,420
you can specify as as much up to the

1045
00:46:30,420 --> 00:46:34,220
robustness parameter of the MPC protocol

1046
00:46:34,680 --> 00:46:36,780
and of course MPC in the head directly

1047
00:46:36,780 --> 00:46:38,760
computes the MP verification circuit so

1048
00:46:38,760 --> 00:46:41,280
we avoid any car Productions

1049
00:46:41,280 --> 00:46:43,380
here it's not a parallel repetition you

1050
00:46:43,380 --> 00:46:45,119
only commit once to this to this

1051
00:46:45,119 --> 00:46:46,980
transcript

1052
00:46:46,980 --> 00:46:48,960
and now each party's view is now

1053
00:46:48,960 --> 00:46:51,240
independently verifiable and this allows

1054
00:46:51,240 --> 00:46:53,339
us to define a very clean bad challenge

1055
00:46:53,339 --> 00:46:55,500
to that structure which I'll Define in

1056
00:46:55,500 --> 00:46:57,540
just a bit

1057
00:46:57,540 --> 00:47:00,300
so now here's uh how we're gonna we're

1058
00:47:00,300 --> 00:47:02,339
gonna follow hlr 21's coding theory

1059
00:47:02,339 --> 00:47:05,720
constantiation in a fiatrimir

1060
00:47:05,880 --> 00:47:08,940
so recall that uh how we're going to

1061
00:47:08,940 --> 00:47:10,380
recall this works you're going to start

1062
00:47:10,380 --> 00:47:12,300
with an interactive proof for some MP

1063
00:47:12,300 --> 00:47:14,640
language L which satisfies completeness

1064
00:47:14,640 --> 00:47:17,460
statistical soundness honest verifiers

1065
00:47:17,460 --> 00:47:19,380
your knowledge in a public coin property

1066
00:47:19,380 --> 00:47:21,660
and here you have the proofer sending T

1067
00:47:21,660 --> 00:47:23,220
rounds of messages alpha one through

1068
00:47:23,220 --> 00:47:27,000
Alpha T the verifying verifier sending T

1069
00:47:27,000 --> 00:47:28,859
rounds of challenges beta 1 through beta

1070
00:47:28,859 --> 00:47:30,660
T and then there's openings gamma one

1071
00:47:30,660 --> 00:47:32,640
through gamma t

1072
00:47:32,640 --> 00:47:34,680
and the future mirror prayer time shows

1073
00:47:34,680 --> 00:47:37,140
us how to uh compress this into a

1074
00:47:37,140 --> 00:47:38,940
non-interactive protocol via some hash

1075
00:47:38,940 --> 00:47:41,420
function h

1076
00:47:41,640 --> 00:47:44,640
and we would like that this usage of the

1077
00:47:44,640 --> 00:47:47,040
hash function H preserves soundness to

1078
00:47:47,040 --> 00:47:48,480
some degree namely we can ask that it

1079
00:47:48,480 --> 00:47:50,579
preserves computational soundness

1080
00:47:50,579 --> 00:47:52,859
and this happens if H is sampled from

1081
00:47:52,859 --> 00:47:54,599
some correlation tractable hash friendly

1082
00:47:54,599 --> 00:47:58,640
for for an appropriate relation r

1083
00:47:59,040 --> 00:48:02,779
and what relation do we consider

1084
00:48:03,060 --> 00:48:05,099
uh we consider the following naive

1085
00:48:05,099 --> 00:48:06,900
relation for any statement on the

1086
00:48:06,900 --> 00:48:09,960
language we want to consider all pairs

1087
00:48:09,960 --> 00:48:11,460
of first round and second round messages

1088
00:48:11,460 --> 00:48:15,300
for which there does not exist a opening

1089
00:48:15,300 --> 00:48:18,540
that would uh convince the verifier to

1090
00:48:18,540 --> 00:48:21,180
wrongly accept this this uh the

1091
00:48:21,180 --> 00:48:23,640
membership of the statement

1092
00:48:23,640 --> 00:48:25,740
and these beta 1 through beta T's are

1093
00:48:25,740 --> 00:48:27,960
what we call bad challenges namely that

1094
00:48:27,960 --> 00:48:30,240
these are challenges that would allow

1095
00:48:30,240 --> 00:48:32,520
the prover to send a third round message

1096
00:48:32,520 --> 00:48:34,560
that would fool the verifier into

1097
00:48:34,560 --> 00:48:35,940
accepting the membership of the

1098
00:48:35,940 --> 00:48:37,200
statement which is not actually the

1099
00:48:37,200 --> 00:48:39,439
language

1100
00:48:39,720 --> 00:48:43,260
and the work of ps19 closes the case of

1101
00:48:43,260 --> 00:48:45,780
this for using the hardness of lwe for

1102
00:48:45,780 --> 00:48:48,180
the case of functions namely circuits

1103
00:48:48,180 --> 00:48:51,420
and in particular if every what I mean

1104
00:48:51,420 --> 00:48:53,220
by that is if the relation is a function

1105
00:48:53,220 --> 00:48:56,040
meaning namely for every Alpha One to

1106
00:48:56,040 --> 00:48:58,560
Alpha T there's at most one

1107
00:48:58,560 --> 00:49:01,440
a bad challenge beta went through beta t

1108
00:49:01,440 --> 00:49:03,720
then the work of ps19 addresses this

1109
00:49:03,720 --> 00:49:05,819
case where we can instantiate a

1110
00:49:05,819 --> 00:49:07,260
correlation practical hash family for

1111
00:49:07,260 --> 00:49:08,460
this relation

1112
00:49:08,460 --> 00:49:11,040
from the hardness of lwe

1113
00:49:11,040 --> 00:49:13,740
and by guessing reduction uh it also

1114
00:49:13,740 --> 00:49:15,720
addresses the case of polynomially many

1115
00:49:15,720 --> 00:49:17,579
bad challenges where for every Alpha One

1116
00:49:17,579 --> 00:49:19,560
for Alpha T first round message there's

1117
00:49:19,560 --> 00:49:21,420
only polynomially many beta 1 through

1118
00:49:21,420 --> 00:49:23,640
beta t

1119
00:49:23,640 --> 00:49:25,740
and this is just by guessing you incur

1120
00:49:25,740 --> 00:49:27,240
polynomial loss by just guessing which

1121
00:49:27,240 --> 00:49:29,700
of the tuples beta what the beta T is

1122
00:49:29,700 --> 00:49:33,540
the one is the correct one in some sense

1123
00:49:33,540 --> 00:49:35,940
but the moment you go to exponentially

1124
00:49:35,940 --> 00:49:38,520
uh exponentially many bad challenges you

1125
00:49:38,520 --> 00:49:40,200
run into a problem because of guessing

1126
00:49:40,200 --> 00:49:42,240
reduction will Now fail you'll incur an

1127
00:49:42,240 --> 00:49:44,280
exponential loss

1128
00:49:44,280 --> 00:49:47,099
and the work of hlr 21 says that for

1129
00:49:47,099 --> 00:49:49,500
pillow repetition protocols

1130
00:49:49,500 --> 00:49:51,839
you have a nice product structure

1131
00:49:51,839 --> 00:49:53,460
so let's use this combinatorial

1132
00:49:53,460 --> 00:49:55,859
structure to our advantage

1133
00:49:55,859 --> 00:49:57,839
so here's an alternate depiction of the

1134
00:49:57,839 --> 00:50:00,839
exponentially bad uh challenge set you

1135
00:50:00,839 --> 00:50:02,819
just break it up into its T components

1136
00:50:02,819 --> 00:50:06,780
and each of these sets so S1 instead of

1137
00:50:06,780 --> 00:50:08,460
all the beta ones like the projections

1138
00:50:08,460 --> 00:50:10,800
basically and these are all polynomial

1139
00:50:10,800 --> 00:50:12,240
size sets

1140
00:50:12,240 --> 00:50:14,280
and what you would applying the

1141
00:50:14,280 --> 00:50:16,020
principle of wishful thinking you would

1142
00:50:16,020 --> 00:50:19,020
like that these T polynomial size sets

1143
00:50:19,020 --> 00:50:21,900
Define another polynomial size set some

1144
00:50:21,900 --> 00:50:23,579
this pink shaded set

1145
00:50:23,579 --> 00:50:25,319
for which we could have a another

1146
00:50:25,319 --> 00:50:28,140
relation for which we could instantiate

1147
00:50:28,140 --> 00:50:32,900
the previous slides CI hash function for

1148
00:50:33,480 --> 00:50:36,420
so this is uh exactly list recovery

1149
00:50:36,420 --> 00:50:39,180
which is observed by hlr 21 so this is

1150
00:50:39,180 --> 00:50:40,920
kind of miraculous

1151
00:50:40,920 --> 00:50:43,380
uh and what we can do therefore is use

1152
00:50:43,380 --> 00:50:45,240
list recoverable code and consider the

1153
00:50:45,240 --> 00:50:47,339
following relation alpha one through

1154
00:50:47,339 --> 00:50:50,579
Alpha T and some R and consider the

1155
00:50:50,579 --> 00:50:52,740
relation where we just specify that the

1156
00:50:52,740 --> 00:50:56,460
I component of the encoding of R sits in

1157
00:50:56,460 --> 00:50:57,960
the set s i

1158
00:50:57,960 --> 00:51:00,180
so this is a de-vandimization tech this

1159
00:51:00,180 --> 00:51:02,520
is a de-randomized uh

1160
00:51:02,520 --> 00:51:05,160
um relation a product a relation for the

1161
00:51:05,160 --> 00:51:08,099
randomized parallel repetition protocol

1162
00:51:08,099 --> 00:51:09,900
okay

1163
00:51:09,900 --> 00:51:12,720
and in particular what what coding uh

1164
00:51:12,720 --> 00:51:14,540
what list recoverable code should we use

1165
00:51:14,540 --> 00:51:17,099
hlr21 says we can use part of Ash vardy

1166
00:51:17,099 --> 00:51:19,020
code concatenate with a single random

1167
00:51:19,020 --> 00:51:21,000
code

1168
00:51:21,000 --> 00:51:22,380
and let me tell you how this code

1169
00:51:22,380 --> 00:51:24,540
concatenation works you start with an

1170
00:51:24,540 --> 00:51:26,280
algebraic code

1171
00:51:26,280 --> 00:51:30,420
um uh from some message base M to Z big

1172
00:51:30,420 --> 00:51:33,420
Q to the T and for every when you send a

1173
00:51:33,420 --> 00:51:34,920
message through for every one of these

1174
00:51:34,920 --> 00:51:36,359
two components you're going to apply a

1175
00:51:36,359 --> 00:51:39,119
random code on it and this will give you

1176
00:51:39,119 --> 00:51:41,359
for each of these components

1177
00:51:41,359 --> 00:51:45,720
m z little Q elements to get this and

1178
00:51:45,720 --> 00:51:46,859
and therefore you get this code that

1179
00:51:46,859 --> 00:51:49,380
goes from your message space m to Z

1180
00:51:49,380 --> 00:51:53,460
little Q to the N where n is M times t

1181
00:51:53,460 --> 00:51:55,920
and the list recovery just says that uh

1182
00:51:55,920 --> 00:51:58,020
go the other way

1183
00:51:58,020 --> 00:52:00,780
um you specify your sets S11 through s1m

1184
00:52:00,780 --> 00:52:03,119
apply less recovery to get subset S1

1185
00:52:03,119 --> 00:52:07,619
then apply uh apply this for uh all your

1186
00:52:07,619 --> 00:52:10,859
T mini random code recoveries and then

1187
00:52:10,859 --> 00:52:12,420
finally apply the algebraic the list

1188
00:52:12,420 --> 00:52:14,400
recovery for the algebraic code

1189
00:52:14,400 --> 00:52:15,900
and this gives you the set of all

1190
00:52:15,900 --> 00:52:17,640
messages for which the code word sits in

1191
00:52:17,640 --> 00:52:19,440
the correspond the the ijth component

1192
00:52:19,440 --> 00:52:22,460
sits in the corresponding set

1193
00:52:23,040 --> 00:52:26,280
and hlr 21 then showed this is a CI hash

1194
00:52:26,280 --> 00:52:28,020
function for desired relation

1195
00:52:28,020 --> 00:52:31,200
first you have the ps19ci hash for the

1196
00:52:31,200 --> 00:52:32,940
encoding relation that we showed on the

1197
00:52:32,940 --> 00:52:35,579
previous slide then you apply list

1198
00:52:35,579 --> 00:52:36,900
recoverable you apply the list

1199
00:52:36,900 --> 00:52:38,880
recoverable code

1200
00:52:38,880 --> 00:52:41,940
and just observe here that the block

1201
00:52:41,940 --> 00:52:45,180
length of this list recoverable code

1202
00:52:45,180 --> 00:52:47,339
affects the proof size so here you start

1203
00:52:47,339 --> 00:52:49,440
with the alpha 1 through Alpha T's after

1204
00:52:49,440 --> 00:52:51,660
applying this Con this uh this new CI

1205
00:52:51,660 --> 00:52:53,579
hash function you get your beta 1

1206
00:52:53,579 --> 00:52:54,720
through beta t

1207
00:52:54,720 --> 00:52:56,460
and using a part of Ash vardy and single

1208
00:52:56,460 --> 00:52:58,440
random code you get a block size of size

1209
00:52:58,440 --> 00:53:00,359
o to the K1 plus Epsilon for Epsilon

1210
00:53:00,359 --> 00:53:03,078
greater than zero

1211
00:53:04,559 --> 00:53:06,660
and in general this recovery you have to

1212
00:53:06,660 --> 00:53:10,500
be worried on uh whether or not every

1213
00:53:10,500 --> 00:53:12,540
one of these sets S1 through St might be

1214
00:53:12,540 --> 00:53:14,760
large so you actually have to consider

1215
00:53:14,760 --> 00:53:18,619
SI where SI May differ

1216
00:53:19,020 --> 00:53:20,819
and you may ask is General list

1217
00:53:20,819 --> 00:53:22,740
recoverability necessary for the setting

1218
00:53:22,740 --> 00:53:25,578
of NPC in the head

1219
00:53:25,800 --> 00:53:28,079
and we actually observed that it's not

1220
00:53:28,079 --> 00:53:31,500
necessary why is this the case well in

1221
00:53:31,500 --> 00:53:33,480
the in the in our modification of the

1222
00:53:33,480 --> 00:53:35,880
icos protocol we actually have a single

1223
00:53:35,880 --> 00:53:37,859
bad challenge set which is determined by

1224
00:53:37,859 --> 00:53:39,359
this first round message commitment of

1225
00:53:39,359 --> 00:53:42,359
Tau the command to the transcript where

1226
00:53:42,359 --> 00:53:45,180
uh s comp tell is just the set of all

1227
00:53:45,180 --> 00:53:47,940
indices I for which UI is consistent

1228
00:53:47,940 --> 00:53:50,099
meaning that the proverb could convince

1229
00:53:50,099 --> 00:53:53,640
the verifier to accept correctly

1230
00:53:53,640 --> 00:53:55,500
so now if you've seen the head protocol

1231
00:53:55,500 --> 00:53:57,960
we just have product sets s cross s

1232
00:53:57,960 --> 00:53:59,940
cross s cross s and this critically uses

1233
00:53:59,940 --> 00:54:02,880
the idea that uh we have independent

1234
00:54:02,880 --> 00:54:04,800
verifiability for each of these parties

1235
00:54:04,800 --> 00:54:07,800
specified by the verifier

1236
00:54:07,800 --> 00:54:09,960
and this is a much simpler structure and

1237
00:54:09,960 --> 00:54:11,880
we'll show how to use exploit the

1238
00:54:11,880 --> 00:54:14,720
simpler structure

1239
00:54:15,119 --> 00:54:17,640
right so uh one may ask does a simpler

1240
00:54:17,640 --> 00:54:18,960
batch sound structure allow the usage of

1241
00:54:18,960 --> 00:54:20,760
a de-vandimization technique both

1242
00:54:20,760 --> 00:54:22,079
simpler and more efficient than General

1243
00:54:22,079 --> 00:54:23,579
list recoverability and the answer is

1244
00:54:23,579 --> 00:54:25,079
yes

1245
00:54:25,079 --> 00:54:28,079
uh so here's a term we call recurrent

1246
00:54:28,079 --> 00:54:29,520
list recoverability a strictly weaker

1247
00:54:29,520 --> 00:54:30,900
notion of generalist recoverability

1248
00:54:30,900 --> 00:54:33,480
where instead of having arbitrary sets

1249
00:54:33,480 --> 00:54:36,359
S11 through STM you just have the same

1250
00:54:36,359 --> 00:54:39,859
step reoccurring over and over again

1251
00:54:40,440 --> 00:54:43,260
and let's try to instantiate uh

1252
00:54:43,260 --> 00:54:44,940
recurring list to cover list

1253
00:54:44,940 --> 00:54:46,200
recoverability with the simplest

1254
00:54:46,200 --> 00:54:47,940
algebraic code we can think of

1255
00:54:47,940 --> 00:54:51,540
let's just use the read Solomon code

1256
00:54:51,540 --> 00:54:53,400
and we actually run into an issue for

1257
00:54:53,400 --> 00:54:55,260
general for for General list

1258
00:54:55,260 --> 00:54:57,059
recoverability in a sense or

1259
00:54:57,059 --> 00:54:58,559
instantiating recurring list of

1260
00:54:58,559 --> 00:55:00,480
probability in viewing it from the lens

1261
00:55:00,480 --> 00:55:02,160
of generalist recoverability

1262
00:55:02,160 --> 00:55:04,140
in a sense that list recoverability for

1263
00:55:04,140 --> 00:55:07,200
single code may result in an output set

1264
00:55:07,200 --> 00:55:08,819
as tilde that's too large for the red

1265
00:55:08,819 --> 00:55:10,619
Solomon list recovery list

1266
00:55:10,619 --> 00:55:12,599
recoverability

1267
00:55:12,599 --> 00:55:14,099
um and this for fixed random code this

1268
00:55:14,099 --> 00:55:15,599
happens with non-negligible probability

1269
00:55:15,599 --> 00:55:17,400
of the prover's choice of s it's not the

1270
00:55:17,400 --> 00:55:20,780
verified's choice that's a typo

1271
00:55:21,839 --> 00:55:24,119
um and in particular to remedy this

1272
00:55:24,119 --> 00:55:25,559
we're going to make the following

1273
00:55:25,559 --> 00:55:27,180
observation

1274
00:55:27,180 --> 00:55:28,859
the read column in list decoding

1275
00:55:28,859 --> 00:55:31,619
algorithm actually boils down to just

1276
00:55:31,619 --> 00:55:33,540
polynomial reconstruction which is a

1277
00:55:33,540 --> 00:55:35,040
really simple algorithm given by Sudan

1278
00:55:35,040 --> 00:55:38,220
97 and Guru Swami Sudan 98

1279
00:55:38,220 --> 00:55:40,200
and polynomial reconstruction only

1280
00:55:40,200 --> 00:55:43,140
relies on the aggregate list size so the

1281
00:55:43,140 --> 00:55:46,260
sum of all these s tildas and we observe

1282
00:55:46,260 --> 00:55:47,579
here that in the worst case these

1283
00:55:47,579 --> 00:55:50,460
estilos could be as large as s times T

1284
00:55:50,460 --> 00:55:54,720
because a single set s tilde could be at

1285
00:55:54,720 --> 00:55:56,700
least the size of it must be at least it

1286
00:55:56,700 --> 00:55:58,680
could be at least the size of s because

1287
00:55:58,680 --> 00:56:01,260
s could correspond to separate code

1288
00:56:01,260 --> 00:56:03,180
words

1289
00:56:03,180 --> 00:56:04,980
um right could you just correspond to

1290
00:56:04,980 --> 00:56:06,599
separate code words so when you do list

1291
00:56:06,599 --> 00:56:08,700
recovery you'll get as many messages as

1292
00:56:08,700 --> 00:56:11,839
the number of code words are

1293
00:56:13,619 --> 00:56:16,020
and our solution is therefore to use

1294
00:56:16,020 --> 00:56:17,700
multiple random codes if you use

1295
00:56:17,700 --> 00:56:19,319
multiple random codes then while some

1296
00:56:19,319 --> 00:56:22,440
output sets s tilde 1 might be large

1297
00:56:22,440 --> 00:56:25,140
others may be small so you might have S

1298
00:56:25,140 --> 00:56:28,079
tilde T be very small

1299
00:56:28,079 --> 00:56:31,680
and we show that the in this regime uh

1300
00:56:31,680 --> 00:56:34,079
the sum of the S tilde I's is actually

1301
00:56:34,079 --> 00:56:36,119
about we get we get the cost of T mini

1302
00:56:36,119 --> 00:56:38,520
output list for the cost of effectively

1303
00:56:38,520 --> 00:56:39,500
one

1304
00:56:39,500 --> 00:56:42,839
we get the sum of the S till the eyes is

1305
00:56:42,839 --> 00:56:46,880
less than o till of just s

1306
00:56:48,599 --> 00:56:50,579
and this allows us to show that

1307
00:56:50,579 --> 00:56:52,380
polynomial reconstruction succeeds for

1308
00:56:52,380 --> 00:56:54,240
every choice of the set s with all but

1309
00:56:54,240 --> 00:56:57,200
negligible probability

1310
00:56:58,140 --> 00:57:00,720
so in summary we modify the MPC in the

1311
00:57:00,720 --> 00:57:02,940
head protocol so that has a very nice

1312
00:57:02,940 --> 00:57:05,520
bad challenge set structure amenable to

1313
00:57:05,520 --> 00:57:08,040
a strictly weaker notion of recurrent

1314
00:57:08,040 --> 00:57:10,020
list recovery list recurrent list

1315
00:57:10,020 --> 00:57:11,339
recoverability

1316
00:57:11,339 --> 00:57:13,440
and we instantiate this recurrent list

1317
00:57:13,440 --> 00:57:15,780
recoverable code using a read Solomon

1318
00:57:15,780 --> 00:57:17,339
code concatenated with multiple random

1319
00:57:17,339 --> 00:57:18,240
codes

1320
00:57:18,240 --> 00:57:20,040
and finally we show how to use aggregate

1321
00:57:20,040 --> 00:57:22,680
size analysis to obtain uh something

1322
00:57:22,680 --> 00:57:24,900
that's amenable to

1323
00:57:24,900 --> 00:57:26,700
um polynomial polynomial reconstruction

1324
00:57:26,700 --> 00:57:29,040
algorithm and achieves quasi-linear

1325
00:57:29,040 --> 00:57:32,220
block length and uh the final picture is

1326
00:57:32,220 --> 00:57:34,800
effectively you take your ps19 hash

1327
00:57:34,800 --> 00:57:36,300
concatenated with a recurrentless

1328
00:57:36,300 --> 00:57:37,800
recoverable code which is actually read

1329
00:57:37,800 --> 00:57:39,839
Solomon plus multiple random codes

1330
00:57:39,839 --> 00:57:41,400
and

1331
00:57:41,400 --> 00:57:42,180
um

1332
00:57:42,180 --> 00:57:43,859
finally you get a reduced block length

1333
00:57:43,859 --> 00:57:47,000
of just go till of K

1334
00:57:47,700 --> 00:57:49,859
and that's it thank you

1335
00:57:49,859 --> 00:57:52,859
foreign

1336
00:58:05,740 --> 00:58:08,420
[Music]

1337
00:58:08,420 --> 00:58:12,059
for mp3 in the head but uh if we don't

1338
00:58:12,059 --> 00:58:14,819
care about the efficiency it is easy to

1339
00:58:14,819 --> 00:58:17,099
give refraction here for empathy in the

1340
00:58:17,099 --> 00:58:19,319
head by using the existing work of har

1341
00:58:19,319 --> 00:58:21,599
yes so if you don't care about

1342
00:58:21,599 --> 00:58:23,900
efficiency you can directly use hlr 21

1343
00:58:23,900 --> 00:58:26,880
they the MPC in the head Paradigm falls

1344
00:58:26,880 --> 00:58:28,980
under the commit and open protocol I

1345
00:58:28,980 --> 00:58:30,359
think thank you

1346
00:58:30,359 --> 00:58:32,160
huh

1347
00:58:32,160 --> 00:58:34,819
oh yeah

1348
00:58:36,900 --> 00:58:40,520
yeah I can hear you

1349
00:58:46,400 --> 00:58:49,619
right how do you break uh structure that

1350
00:58:49,619 --> 00:58:52,020
we built right so this is in the sense

1351
00:58:52,020 --> 00:58:53,760
we're reduced we're using the work of

1352
00:58:53,760 --> 00:58:56,880
ps19 and CCH plus 19 under under the

1353
00:58:56,880 --> 00:58:59,970
hood right because uh

1354
00:58:59,970 --> 00:59:03,089
[Music]

1355
00:59:03,299 --> 00:59:06,240
oh no so we don't use fhe we just note

1356
00:59:06,240 --> 00:59:08,700
that there's an additional work

1357
00:59:08,700 --> 00:59:11,700
that bootstraps any music protocol

1358
00:59:11,700 --> 00:59:14,220
to another music protocol using

1359
00:59:14,220 --> 00:59:17,400
whose proof size is just linear the

1360
00:59:17,400 --> 00:59:19,740
witness size so but what what our work

1361
00:59:19,740 --> 00:59:21,020
shows is that we're not actually

1362
00:59:21,020 --> 00:59:23,099
assuming the existence of the music in

1363
00:59:23,099 --> 00:59:24,780
the first place we're building it from

1364
00:59:24,780 --> 00:59:26,640
strap scratch so this is a base

1365
00:59:26,640 --> 00:59:29,960
construction oh okay

1366
00:59:33,059 --> 00:59:35,960
any other question

1367
00:59:36,660 --> 00:59:38,579
no question so left hand the speaker

1368
00:59:38,579 --> 00:59:38,940
again

1369
00:59:38,940 --> 00:59:40,319
[Music]

1370
00:59:40,319 --> 00:59:42,859
because

1371
00:59:43,020 --> 00:59:46,520
there are some announcements

