1
00:00:00,079 --> 00:00:02,460
instructions while preserving its

2
00:00:02,460 --> 00:00:03,300
security

3
00:00:03,300 --> 00:00:05,460
for instance I can take a transaction

4
00:00:05,460 --> 00:00:07,560
transaction one another transaction

5
00:00:07,560 --> 00:00:10,200
transaction two and mix them together

6
00:00:10,200 --> 00:00:12,300
into a new transaction that contains the

7
00:00:12,300 --> 00:00:14,240
information from both

8
00:00:14,240 --> 00:00:15,839
and

9
00:00:15,839 --> 00:00:17,580
is the second thing that's very

10
00:00:17,580 --> 00:00:20,400
particular wimble if an output is being

11
00:00:20,400 --> 00:00:23,279
spent as a new input in transaction two

12
00:00:23,279 --> 00:00:26,340
then these entries in both transactions

13
00:00:26,340 --> 00:00:28,500
can be removed once the transaction is

14
00:00:28,500 --> 00:00:30,720
immersed so we can really remove

15
00:00:30,720 --> 00:00:33,480
information that is not necessary for uh

16
00:00:33,480 --> 00:00:36,120
holding the information this is the cut

17
00:00:36,120 --> 00:00:38,700
through thing that was mentioning before

18
00:00:38,700 --> 00:00:41,460
and uh this is really peculiar we don't

19
00:00:41,460 --> 00:00:42,899
have anything like this in other

20
00:00:42,899 --> 00:00:44,399
cryptocurrencies

21
00:00:44,399 --> 00:00:47,040
however one of the problems with having

22
00:00:47,040 --> 00:00:49,200
movable is that the society aggregation

23
00:00:49,200 --> 00:00:51,899
is non-interactive both are the center

24
00:00:51,899 --> 00:00:54,000
and recipient need to be online when we

25
00:00:54,000 --> 00:00:56,820
make a simple transaction

26
00:00:56,820 --> 00:00:59,640
there is no concept of address or wallet

27
00:00:59,640 --> 00:01:01,800
to send money to and this is also very

28
00:01:01,800 --> 00:01:03,359
different from other cryptocurrencies

29
00:01:03,359 --> 00:01:04,920
and it's the first problem that we

30
00:01:04,920 --> 00:01:07,339
tackle

31
00:01:08,100 --> 00:01:11,100
the second problem is that some metadata

32
00:01:11,100 --> 00:01:13,500
information in transactions that we call

33
00:01:13,500 --> 00:01:16,680
the access that essentially says that

34
00:01:16,680 --> 00:01:18,840
transaction is balanced you know the sum

35
00:01:18,840 --> 00:01:20,460
of the outputs manages some of the

36
00:01:20,460 --> 00:01:21,420
inputs

37
00:01:21,420 --> 00:01:23,580
well when we merge the transactions

38
00:01:23,580 --> 00:01:26,220
together these success holds information

39
00:01:26,220 --> 00:01:28,439
about the composing transactions and it

40
00:01:28,439 --> 00:01:30,299
leaks information about them

41
00:01:30,299 --> 00:01:31,920
this is the second problem that we

42
00:01:31,920 --> 00:01:34,080
tackled in terms of adding privacy on

43
00:01:34,080 --> 00:01:36,619
the top of network

44
00:01:37,259 --> 00:01:39,600
more specifically we give two new

45
00:01:39,600 --> 00:01:41,520
security definition

46
00:01:41,520 --> 00:01:43,140
um one of them is transaction binding

47
00:01:43,140 --> 00:01:45,360
which covers something that was not

48
00:01:45,360 --> 00:01:46,159
really

49
00:01:46,159 --> 00:01:49,020
thought of in the first model in our

50
00:01:49,020 --> 00:01:52,380
work of a euroclick 2019. what happens

51
00:01:52,380 --> 00:01:54,840
for a transaction before it goes to The

52
00:01:54,840 --> 00:01:57,720
Ledger with transaction binding we say

53
00:01:57,720 --> 00:01:59,600
essentially that once a transaction is

54
00:01:59,600 --> 00:02:02,399
broadcasted only the intended recipient

55
00:02:02,399 --> 00:02:04,979
can spend enough that was a honestly

56
00:02:04,979 --> 00:02:07,460
generated

57
00:02:08,119 --> 00:02:10,560
this protection for example against

58
00:02:10,560 --> 00:02:12,959
malicious miners that might try to

59
00:02:12,959 --> 00:02:14,760
tamper with transactions before they

60
00:02:14,760 --> 00:02:17,040
reach the Ledger and are in the mempool

61
00:02:17,040 --> 00:02:19,080
OR for instance against adversaries they

62
00:02:19,080 --> 00:02:20,879
might change their mind about the

63
00:02:20,879 --> 00:02:22,739
transaction that they sent and they

64
00:02:22,739 --> 00:02:26,040
might want to set to expand the output

65
00:02:26,040 --> 00:02:29,660
before their honest recipient pool

66
00:02:30,900 --> 00:02:33,120
additionally we introduce this new

67
00:02:33,120 --> 00:02:35,280
notion of transaction privacy where

68
00:02:35,280 --> 00:02:37,319
essentially we say that from a

69
00:02:37,319 --> 00:02:39,480
transaction you cannot learn anything

70
00:02:39,480 --> 00:02:41,400
about the transaction amount so the

71
00:02:41,400 --> 00:02:43,319
values are hidden the recipient

72
00:02:43,319 --> 00:02:46,080
addresses or which inputs and outputs

73
00:02:46,080 --> 00:02:47,819
belong to the same constituent

74
00:02:47,819 --> 00:02:50,220
transaction once aggregated with another

75
00:02:50,220 --> 00:02:52,819
transaction

76
00:02:54,840 --> 00:02:57,480
in order to do so we use two key ideas

77
00:02:57,480 --> 00:03:01,019
one of them is help addresses and the

78
00:03:01,019 --> 00:03:03,480
second one is transaction offsets Health

79
00:03:03,480 --> 00:03:06,300
addresses are key for non-interactive

80
00:03:06,300 --> 00:03:08,900
transactions

81
00:03:09,480 --> 00:03:12,360
they work roughly as follows when Alice

82
00:03:12,360 --> 00:03:14,640
want to send some money to Pub it will

83
00:03:14,640 --> 00:03:17,280
use the public key of Bob to derive a

84
00:03:17,280 --> 00:03:19,680
new one-time public key

85
00:03:19,680 --> 00:03:22,019
an observer cannot learn this one-time

86
00:03:22,019 --> 00:03:24,120
group cannot link this one-time public

87
00:03:24,120 --> 00:03:26,840
key to the public key of Bob

88
00:03:26,840 --> 00:03:30,360
now Bob on the other hand as Associated

89
00:03:30,360 --> 00:03:33,360
to the public key secretly and a view

90
00:03:33,360 --> 00:03:36,540
key from The View key it is possible to

91
00:03:36,540 --> 00:03:39,180
regenerate the one-time public key

92
00:03:39,180 --> 00:03:41,340
so Bob just has to scan the blockchain

93
00:03:41,340 --> 00:03:43,260
in order to find outputs that are

94
00:03:43,260 --> 00:03:47,040
destinated to him using the view key

95
00:03:47,040 --> 00:03:49,739
and using this the secret key it is

96
00:03:49,739 --> 00:03:51,720
possible to generate a one-time secret

97
00:03:51,720 --> 00:03:54,599
key that you will be able to spend the

98
00:03:54,599 --> 00:03:56,519
output Associated to the one-time

99
00:03:56,519 --> 00:03:59,120
publicity

100
00:04:03,000 --> 00:04:05,220
now transactional opposite instead add

101
00:04:05,220 --> 00:04:08,099
privacy to these um feature of being a

102
00:04:08,099 --> 00:04:09,900
wimble called non-interactive content

103
00:04:09,900 --> 00:04:11,900
disaggregation

104
00:04:11,900 --> 00:04:14,939
is simply to add some random offset that

105
00:04:14,939 --> 00:04:17,519
I'm displaying here in yellow and um

106
00:04:17,519 --> 00:04:19,440
when we all create transaction we will

107
00:04:19,440 --> 00:04:21,600
simply re-randomize this offset in such

108
00:04:21,600 --> 00:04:24,120
a way that no information about the

109
00:04:24,120 --> 00:04:26,460
component transaction is leaked

110
00:04:26,460 --> 00:04:28,979
this feature was already available in

111
00:04:28,979 --> 00:04:30,840
green for a few years but we provide the

112
00:04:30,840 --> 00:04:32,820
first study that guarantees its security

113
00:04:32,820 --> 00:04:35,960
properties in rainbow

114
00:04:37,699 --> 00:04:40,620
the resulting transactions in our new

115
00:04:40,620 --> 00:04:42,540
scheme look as well look like the

116
00:04:42,540 --> 00:04:45,120
following pretty much we have these um

117
00:04:45,120 --> 00:04:46,919
one-time public keys that are introduced

118
00:04:46,919 --> 00:04:49,139
by stealth addresses

119
00:04:49,139 --> 00:04:50,880
um and we have signatures authorizing

120
00:04:50,880 --> 00:04:53,520
the spending under these public Keys now

121
00:04:53,520 --> 00:04:55,500
these signatures do not link input and

122
00:04:55,500 --> 00:04:57,540
output together as one would normally

123
00:04:57,540 --> 00:05:00,479
imagine in Bitcoin instead we opt for

124
00:05:00,479 --> 00:05:02,160
something very similar to the access

125
00:05:02,160 --> 00:05:04,259
equations that we saw before and we

126
00:05:04,259 --> 00:05:06,300
introduce a new access so it depends on

127
00:05:06,300 --> 00:05:09,560
this public is called stealth access

128
00:05:09,560 --> 00:05:12,479
now this type says slightly weakers

129
00:05:12,479 --> 00:05:14,580
unfortunately another property of member

130
00:05:14,580 --> 00:05:16,500
wimble called the cut through

131
00:05:16,500 --> 00:05:18,120
we

132
00:05:18,120 --> 00:05:20,520
however discussing the paper trade-offs

133
00:05:20,520 --> 00:05:22,320
that can be made so that some product

134
00:05:22,320 --> 00:05:25,320
some some sort of cut through can still

135
00:05:25,320 --> 00:05:27,840
be achieved

136
00:05:27,840 --> 00:05:30,180
we also have the offset that just as we

137
00:05:30,180 --> 00:05:32,699
saw provide privacy and finally as

138
00:05:32,699 --> 00:05:35,400
normal in Bitcoin in in Bitcoins

139
00:05:35,400 --> 00:05:37,620
confidential transaction and in vanilla

140
00:05:37,620 --> 00:05:39,479
may we will we don't have plain text

141
00:05:39,479 --> 00:05:42,240
values the credit public key instead we

142
00:05:42,240 --> 00:05:43,800
have commitments to those values

143
00:05:43,800 --> 00:05:45,960
together with range groups that have

144
00:05:45,960 --> 00:05:48,419
passed it these values are small and

145
00:05:48,419 --> 00:05:49,979
they don't wrap around the integer

146
00:05:49,979 --> 00:05:52,520
arithmetic

147
00:05:52,919 --> 00:05:54,120
okay

148
00:05:54,120 --> 00:05:56,160
to conclude

149
00:05:56,160 --> 00:05:58,860
um in this work we strengthen and

150
00:05:58,860 --> 00:06:00,960
Notions of security and anonymity that

151
00:06:00,960 --> 00:06:04,259
we provided in Europe 2019 and we

152
00:06:04,259 --> 00:06:05,880
provide a new scheme that satisfies

153
00:06:05,880 --> 00:06:07,860
those and that supports non-interactive

154
00:06:07,860 --> 00:06:10,259
transactions our scheme is now in use

155
00:06:10,259 --> 00:06:12,240
both by me moving the coin and by

156
00:06:12,240 --> 00:06:15,620
Litecoin thank you

157
00:06:20,360 --> 00:06:22,740
okay thanks do we have any questions

158
00:06:22,740 --> 00:06:25,580
from the audience

159
00:06:27,720 --> 00:06:29,639
uh okay looks like we don't have any

160
00:06:29,639 --> 00:06:32,280
questions so we'll move to uh the next

161
00:06:32,280 --> 00:06:34,020
speaker

162
00:06:34,020 --> 00:06:34,979
um who's going to be talking about

163
00:06:34,979 --> 00:06:37,080
universally composable non-interactive

164
00:06:37,080 --> 00:06:38,819
aggregate cache

165
00:06:38,819 --> 00:06:42,300
and that speaker is Jan Schweizer who

166
00:06:42,300 --> 00:06:46,039
hopefully is online

167
00:06:46,259 --> 00:06:47,300
yeah

168
00:06:47,300 --> 00:06:50,100
okay great we can hear you so you can uh

169
00:06:50,100 --> 00:06:52,800
you can take it away okay okay and can

170
00:06:52,800 --> 00:06:55,080
you see myself

171
00:06:55,080 --> 00:06:58,800
yes we can see your sides okay oh

172
00:06:58,800 --> 00:07:00,960
okay I was

173
00:07:00,960 --> 00:07:03,620
start

174
00:07:07,080 --> 00:07:08,100
okay

175
00:07:08,100 --> 00:07:12,660
uh hello everyone from University and I

176
00:07:12,660 --> 00:07:14,400
got present to our work our University

177
00:07:14,400 --> 00:07:16,500
comes to grow now interactive aggregate

178
00:07:16,500 --> 00:07:21,020
Cash System this is a joint work with

179
00:07:21,230 --> 00:07:22,620
[Music]

180
00:07:22,620 --> 00:07:24,660
I'm breaking my presentation down into

181
00:07:24,660 --> 00:07:27,259
four parts and because Michaela has

182
00:07:27,259 --> 00:07:30,419
introduced the member wimble so here I

183
00:07:30,419 --> 00:07:32,340
just mentioned something related to our

184
00:07:32,340 --> 00:07:34,740
paper and I will summarize our

185
00:07:34,740 --> 00:07:37,319
contributions and give more details

186
00:07:37,319 --> 00:07:39,120
about our first game and the ideal

187
00:07:39,120 --> 00:07:41,280
functionality

188
00:07:41,280 --> 00:07:44,819
oh I'm always good with carbs okay uh

189
00:07:44,819 --> 00:07:47,340
and and I will mention that the mingle

190
00:07:47,340 --> 00:07:49,860
rainbow has a beautiful feature called

191
00:07:49,860 --> 00:07:53,280
kazoo and which means that if this coin

192
00:07:53,280 --> 00:07:56,759
is by Bitcoin this coin then the two

193
00:07:56,759 --> 00:07:58,740
points uh

194
00:07:58,740 --> 00:08:00,840
can be deleted in the aggregate

195
00:08:00,840 --> 00:08:02,160
transaction

196
00:08:02,160 --> 00:08:05,460
and which is called cancel and it can

197
00:08:05,460 --> 00:08:10,039
save the storage first

198
00:08:10,520 --> 00:08:12,720
has a drawback

199
00:08:12,720 --> 00:08:16,020
and it might entice the usage in

200
00:08:16,020 --> 00:08:16,979
practice

201
00:08:16,979 --> 00:08:19,979
more specifically those the sender and

202
00:08:19,979 --> 00:08:22,440
the receiver must interact to generate a

203
00:08:22,440 --> 00:08:23,639
transaction

204
00:08:23,639 --> 00:08:26,099
which means that the two parties have to

205
00:08:26,099 --> 00:08:28,740
be online at the same time this is

206
00:08:28,740 --> 00:08:31,440
because in limbo rainbow in each

207
00:08:31,440 --> 00:08:34,020
transaction there must be a signature

208
00:08:34,020 --> 00:08:36,000
under the exercise e

209
00:08:36,000 --> 00:08:38,700
however each party holds a part of the

210
00:08:38,700 --> 00:08:41,099
signing key

211
00:08:41,099 --> 00:08:44,520
so our work aims to avoid the drawback

212
00:08:44,520 --> 00:08:47,459
of Nimbo wimble so we designed a

213
00:08:47,459 --> 00:08:50,120
non-interactive aggregate cache system

214
00:08:50,120 --> 00:08:54,480
we call it an isas for short

215
00:08:54,480 --> 00:08:56,880
and we formalized an ideal functionality

216
00:08:56,880 --> 00:09:00,779
for an ISS and finally we prove that our

217
00:09:00,779 --> 00:09:03,660
protocol can usually realize our ideal

218
00:09:03,660 --> 00:09:07,399
functionality in a hybrid model

219
00:09:09,120 --> 00:09:12,240
uh in the original memory boards in such

220
00:09:12,240 --> 00:09:14,519
a reason why each party holds a part of

221
00:09:14,519 --> 00:09:17,279
the signing key it's a it's the sender

222
00:09:17,279 --> 00:09:19,560
can also know the randomness of the

223
00:09:19,560 --> 00:09:22,860
output commitments because because the

224
00:09:22,860 --> 00:09:25,740
remnants act as the spanning key of the

225
00:09:25,740 --> 00:09:27,240
output points

226
00:09:27,240 --> 00:09:30,660
and the excise e computed from the input

227
00:09:30,660 --> 00:09:33,360
commitments and output commitments

228
00:09:33,360 --> 00:09:36,959
and the signature has two functions the

229
00:09:36,959 --> 00:09:39,360
first is to prove that the transaction

230
00:09:39,360 --> 00:09:42,300
is balanced and the second is to prove

231
00:09:42,300 --> 00:09:44,279
that the sender knows the spanning case

232
00:09:44,279 --> 00:09:46,380
of the input coins

233
00:09:46,380 --> 00:09:48,839
so the core idea of our work is to

234
00:09:48,839 --> 00:09:51,180
either the notion of address to achieve

235
00:09:51,180 --> 00:09:52,860
now interaction

236
00:09:52,860 --> 00:09:55,820
such such that the secret key of address

237
00:09:55,820 --> 00:09:59,399
acts as the Spanish key and the sender

238
00:09:59,399 --> 00:10:02,580
can know some the sender can know the

239
00:10:02,580 --> 00:10:05,519
vendors of the output points

240
00:10:05,519 --> 00:10:07,620
so the standard can generate the

241
00:10:07,620 --> 00:10:10,800
signature and excise alone and this

242
00:10:10,800 --> 00:10:13,560
signature adjuster used to to prove that

243
00:10:13,560 --> 00:10:15,720
the transaction is balanced

244
00:10:15,720 --> 00:10:18,899
and the signature and the address is

245
00:10:18,899 --> 00:10:21,660
used to prove that the sender knows the

246
00:10:21,660 --> 00:10:25,399
spanning key of the input point

247
00:10:26,279 --> 00:10:29,220
given the initial idea of ending address

248
00:10:29,220 --> 00:10:31,920
to achieve no interaction there are also

249
00:10:31,920 --> 00:10:33,420
some challenges

250
00:10:33,420 --> 00:10:35,760
first how to bind on commitment and

251
00:10:35,760 --> 00:10:36,839
address

252
00:10:36,839 --> 00:10:40,140
second how to bind the proof of of the

253
00:10:40,140 --> 00:10:42,360
ownership of the input coins with the

254
00:10:42,360 --> 00:10:43,680
transaction

255
00:10:43,680 --> 00:10:46,620
and how to now interactively transfer

256
00:10:46,620 --> 00:10:48,720
the private information of the output

257
00:10:48,720 --> 00:10:50,399
points to the receiver

258
00:10:50,399 --> 00:10:52,380
finally how to maintain the important

259
00:10:52,380 --> 00:10:54,300
feature pass through

260
00:10:54,300 --> 00:10:57,420
so let's first see how to bind our

261
00:10:57,420 --> 00:11:00,000
commitment and I address

262
00:11:00,000 --> 00:11:02,519
because the holder of the secret key of

263
00:11:02,519 --> 00:11:05,700
the address can spend the uh can spend

264
00:11:05,700 --> 00:11:09,060
the coin so we must we must guarantee

265
00:11:09,060 --> 00:11:11,100
that for each commitment

266
00:11:11,100 --> 00:11:13,620
uh its address cannot be changed by

267
00:11:13,620 --> 00:11:16,320
others in the Privacy preserving

268
00:11:16,320 --> 00:11:19,320
cryptocurrencies the range proof is

269
00:11:19,320 --> 00:11:22,200
necessary so in our work we modify the

270
00:11:22,200 --> 00:11:24,120
range proof into a signature of

271
00:11:24,120 --> 00:11:25,320
knowledge

272
00:11:25,320 --> 00:11:27,300
the signature of knowledge is a

273
00:11:27,300 --> 00:11:29,820
generalized notion of signature

274
00:11:29,820 --> 00:11:32,760
we are the verification key is is a

275
00:11:32,760 --> 00:11:34,980
statement and the signing key is the

276
00:11:34,980 --> 00:11:36,060
witness

277
00:11:36,060 --> 00:11:38,880
in our work we use the commitment as the

278
00:11:38,880 --> 00:11:42,120
verification key and the randomness and

279
00:11:42,120 --> 00:11:44,940
value as the signing key and the sender

280
00:11:44,940 --> 00:11:48,420
can use the signing key to to sign on

281
00:11:48,420 --> 00:11:50,040
the address

282
00:11:50,040 --> 00:11:52,079
in other words the address is the

283
00:11:52,079 --> 00:11:53,040
message

284
00:11:53,040 --> 00:11:55,200
so we can generate the signature of

285
00:11:55,200 --> 00:11:57,540
knowledge to bind the commitment and the

286
00:11:57,540 --> 00:11:59,839
address

287
00:12:01,260 --> 00:12:03,600
the center needs to prove that he knows

288
00:12:03,600 --> 00:12:07,380
the spanning key of each input point

289
00:12:07,380 --> 00:12:09,720
or however if the sender just to

290
00:12:09,720 --> 00:12:12,540
generate this proofs The Others May

291
00:12:12,540 --> 00:12:15,000
still these groups and use them in other

292
00:12:15,000 --> 00:12:16,260
transactions

293
00:12:16,260 --> 00:12:18,959
so we need to bind the proofs and the

294
00:12:18,959 --> 00:12:20,700
transaction

295
00:12:20,700 --> 00:12:24,180
uh and our uh our first attempt is to

296
00:12:24,180 --> 00:12:27,000
let the light of the center to sign the

297
00:12:27,000 --> 00:12:30,000
whole transaction use this uh spanning

298
00:12:30,000 --> 00:12:31,079
case

299
00:12:31,079 --> 00:12:34,019
however if the transaction is signed as

300
00:12:34,019 --> 00:12:36,660
a whole then it cannot be aggregated

301
00:12:36,660 --> 00:12:39,420
with other transactions to break the

302
00:12:39,420 --> 00:12:42,120
linkability because others can figure

303
00:12:42,120 --> 00:12:44,760
out that or there is a individual

304
00:12:44,760 --> 00:12:46,200
transaction

305
00:12:46,200 --> 00:12:49,019
so we want to July the standard to sign

306
00:12:49,019 --> 00:12:52,260
and Abstract of the transaction and we

307
00:12:52,260 --> 00:12:55,200
found that the excise is computed from

308
00:12:55,200 --> 00:12:57,420
the input commitments and output

309
00:12:57,420 --> 00:13:00,600
commitments so we can regard the excise

310
00:13:00,600 --> 00:13:04,920
as the abstract of the transaction

311
00:13:04,920 --> 00:13:08,399
so we like the standard like the center

312
00:13:08,399 --> 00:13:10,279
signs excise

313
00:13:10,279 --> 00:13:13,800
using the using this spanning case

314
00:13:13,800 --> 00:13:15,240
however

315
00:13:15,240 --> 00:13:18,480
if in this way others can find that this

316
00:13:18,480 --> 00:13:20,519
input coins belong to the same

317
00:13:20,519 --> 00:13:22,760
transaction

318
00:13:22,760 --> 00:13:26,579
split the exercise into one Parts where

319
00:13:26,579 --> 00:13:29,579
n is the number of input points and like

320
00:13:29,579 --> 00:13:33,300
the standard sign each part using uh by

321
00:13:33,300 --> 00:13:36,380
using or spending key

322
00:13:38,220 --> 00:13:40,440
um then the center because the sender

323
00:13:40,440 --> 00:13:43,500
generates the transaction alone and the

324
00:13:43,500 --> 00:13:47,639
receiver needs to obtain the uh private

325
00:13:47,639 --> 00:13:50,160
information such as the receiver can

326
00:13:50,160 --> 00:13:53,279
spend this output coins later

327
00:13:53,279 --> 00:13:55,860
uh most specifically the receiver needs

328
00:13:55,860 --> 00:13:58,740
to obtain the redness and value and the

329
00:13:58,740 --> 00:14:00,000
spanning key

330
00:14:00,000 --> 00:14:02,279
as for the spending key if it directly

331
00:14:02,279 --> 00:14:05,100
use the skills address such such that

332
00:14:05,100 --> 00:14:07,200
the receiver can use the permanent

333
00:14:07,200 --> 00:14:09,899
secret key to recover the one-time

334
00:14:09,899 --> 00:14:11,519
spending key

335
00:14:11,519 --> 00:14:13,980
I suppose a Randomness and value we

336
00:14:13,980 --> 00:14:17,339
propose a new variant of Algoma

337
00:14:17,339 --> 00:14:20,880
the server text includes two parts and

338
00:14:20,880 --> 00:14:23,940
the second part is is the Peterson

339
00:14:23,940 --> 00:14:27,360
commitment and the first part

340
00:14:27,360 --> 00:14:30,060
and the use of the receiver can use the

341
00:14:30,060 --> 00:14:32,579
first part and the and the description

342
00:14:32,579 --> 00:14:36,600
key to uh to obtain the g2r and then

343
00:14:36,600 --> 00:14:40,160
obtain the remnants artifact

344
00:14:41,880 --> 00:14:46,199
so receiver can obtain the h2a and once

345
00:14:46,199 --> 00:14:48,779
the receiver the message space is small

346
00:14:48,779 --> 00:14:51,300
enough the receiver can recover the

347
00:14:51,300 --> 00:14:54,920
value away from h2a

348
00:14:54,920 --> 00:14:58,260
okay finally let's see how to still

349
00:14:58,260 --> 00:15:00,180
sponsor capsule

350
00:15:00,180 --> 00:15:03,420
in the original member member for

351
00:15:03,420 --> 00:15:06,660
example we assume that E1 is the is the

352
00:15:06,660 --> 00:15:07,699
transaction

353
00:15:07,699 --> 00:15:12,360
once uh excise and E2 uh is the exercise

354
00:15:12,360 --> 00:15:14,459
of transaction two

355
00:15:14,459 --> 00:15:17,519
and we assume that the C1 hat is equal

356
00:15:17,519 --> 00:15:19,199
to C3

357
00:15:19,199 --> 00:15:21,420
then if the transaction one and the

358
00:15:21,420 --> 00:15:24,180
transaction two are aggregated into a

359
00:15:24,180 --> 00:15:27,180
big aggregated transaction then the

360
00:15:27,180 --> 00:15:29,940
excise of the aggregate transaction is

361
00:15:29,940 --> 00:15:34,199
E1 times E2 then the seven hash and C3

362
00:15:34,199 --> 00:15:36,180
can be cut

363
00:15:36,180 --> 00:15:39,600
then the output points can be deleted

364
00:15:39,600 --> 00:15:41,060
from the

365
00:15:41,060 --> 00:15:44,220
aggregate transaction so which is called

366
00:15:44,220 --> 00:15:45,540
kazoo

367
00:15:45,540 --> 00:15:49,019
uh in our work the exercise is computed

368
00:15:49,019 --> 00:15:51,839
in the same way so our skin still

369
00:15:51,839 --> 00:15:55,100
supports the pencil

370
00:15:55,139 --> 00:15:57,720
moreover we Define an ideal

371
00:15:57,720 --> 00:16:01,320
functionality for an isas to capture its

372
00:16:01,320 --> 00:16:02,339
security

373
00:16:02,339 --> 00:16:06,500
unlock the original Ledger in our uh

374
00:16:06,500 --> 00:16:09,300
niacs functionality

375
00:16:09,300 --> 00:16:12,000
uh this functionality submits the

376
00:16:12,000 --> 00:16:14,699
aggregated transaction to The Ledger now

377
00:16:14,699 --> 00:16:16,920
it's the individual transaction

378
00:16:16,920 --> 00:16:19,560
and our idle functionality can capture

379
00:16:19,560 --> 00:16:23,360
the security properties proposed before

380
00:16:23,360 --> 00:16:26,639
and also our other functionality can

381
00:16:26,639 --> 00:16:29,459
additionally capture the unlinkability

382
00:16:29,459 --> 00:16:33,899
because we Define the coin ID the coin

383
00:16:33,899 --> 00:16:36,360
ID is pursued a random

384
00:16:36,360 --> 00:16:39,000
so in an aggregation aggregate

385
00:16:39,000 --> 00:16:42,300
transaction will adjust some uh

386
00:16:42,300 --> 00:16:44,880
procedural random coin identifiers

387
00:16:44,880 --> 00:16:47,820
which hides the values and the relevant

388
00:16:47,820 --> 00:16:50,699
parties so others cannot figure out

389
00:16:50,699 --> 00:16:53,339
which coins belong to the same

390
00:16:53,339 --> 00:16:55,920
transaction so which means the

391
00:16:55,920 --> 00:16:58,199
unlinkability

392
00:16:58,199 --> 00:17:01,199
and we can use the ideal functionality

393
00:17:01,199 --> 00:17:05,760
to analyze the security of an isas in

394
00:17:05,760 --> 00:17:09,059
complex execution environment which is

395
00:17:09,059 --> 00:17:11,819
important in blockchain

396
00:17:11,819 --> 00:17:14,899
that's all thank you

397
00:17:30,020 --> 00:17:32,160
okay I guess we don't have a very

398
00:17:32,160 --> 00:17:34,620
inquisitive crowd today so thanks again

399
00:17:34,620 --> 00:17:37,679
for the the talk and our next speaker

400
00:17:37,679 --> 00:17:41,179
uh is actually in person

401
00:17:41,820 --> 00:17:44,120
yeah you're next right

402
00:17:44,120 --> 00:17:48,799
oh okay sorry uh

403
00:17:48,900 --> 00:17:51,480
yeah sorry I thought you were third

404
00:17:51,480 --> 00:17:55,140
uh okay indeed in person so

405
00:17:55,140 --> 00:17:56,760
yeah

406
00:17:56,760 --> 00:17:59,360
all good

407
00:18:00,299 --> 00:18:02,720
okay

408
00:18:03,299 --> 00:18:07,140
uh well our next speaker is uh

409
00:18:07,140 --> 00:18:11,480
yeah it's Soren uh Thompson

410
00:18:22,860 --> 00:18:25,340
okay

411
00:18:25,880 --> 00:18:27,220
thank you

412
00:18:27,220 --> 00:18:30,470
[Music]

413
00:18:38,340 --> 00:18:40,679
all right so hi my name is Sean Thompson

414
00:18:40,679 --> 00:18:42,900
and I'm going to present the next work

415
00:18:42,900 --> 00:18:44,820
which is

416
00:18:44,820 --> 00:18:46,919
tactical probably secure flooding for

417
00:18:46,919 --> 00:18:49,140
blockchains this is Joint work with

418
00:18:49,140 --> 00:18:53,820
gender liosang Christian mattito

419
00:18:54,660 --> 00:18:57,360
so to motivate this work I like to use

420
00:18:57,360 --> 00:18:59,880
blockchain as an example and for the

421
00:18:59,880 --> 00:19:01,740
purpose of this talk blockchain protocol

422
00:19:01,740 --> 00:19:04,260
is just a protocol that group parties

423
00:19:04,260 --> 00:19:09,120
interact in order to build a total order

424
00:19:09,120 --> 00:19:10,320
however

425
00:19:10,320 --> 00:19:12,000
such blockchain protocols does not

426
00:19:12,000 --> 00:19:13,799
guarantee this total order under all

427
00:19:13,799 --> 00:19:15,059
circumstances

428
00:19:15,059 --> 00:19:16,980
the only guarantees that the order is

429
00:19:16,980 --> 00:19:20,580
built when each party owns some resource

430
00:19:20,580 --> 00:19:24,240
and a majority of these resources and

431
00:19:24,240 --> 00:19:26,100
here you can think of three sources as

432
00:19:26,100 --> 00:19:29,640
being either computing power or stake

433
00:19:29,640 --> 00:19:31,980
and it only works when the majority of

434
00:19:31,980 --> 00:19:35,880
these resources actually behave honestly

435
00:19:35,880 --> 00:19:37,919
however there's one of an overlooked

436
00:19:37,919 --> 00:19:39,900
assumption for blockchain protocols that

437
00:19:39,900 --> 00:19:42,900
is they run on top of a floating Network

438
00:19:42,900 --> 00:19:45,299
so for them to function correctly we

439
00:19:45,299 --> 00:19:47,280
need both the majority of stake or

440
00:19:47,280 --> 00:19:49,320
resources assumption and the touch

441
00:19:49,320 --> 00:19:51,660
flooding Network actually exists

442
00:19:51,660 --> 00:19:53,340
so

443
00:19:53,340 --> 00:19:54,419
um

444
00:19:54,419 --> 00:19:56,160
let's have a look at what this flooding

445
00:19:56,160 --> 00:19:57,539
critical actually is

446
00:19:57,539 --> 00:19:59,880
so a floating protocol or in this case a

447
00:19:59,880 --> 00:20:01,380
built a flooding protocol it's very

448
00:20:01,380 --> 00:20:03,720
simple protocol which ensures that any

449
00:20:03,720 --> 00:20:06,480
party is allowed to input a message and

450
00:20:06,480 --> 00:20:08,220
that this message will be spread out to

451
00:20:08,220 --> 00:20:11,460
all other parties within Delta time

452
00:20:11,460 --> 00:20:13,140
and this is what is assumed to prove the

453
00:20:13,140 --> 00:20:15,000
security of blockchains

454
00:20:15,000 --> 00:20:17,880
in a wide range of work

455
00:20:17,880 --> 00:20:20,039
so such flooding networks aren't

456
00:20:20,039 --> 00:20:21,780
practice implemented by a very simple

457
00:20:21,780 --> 00:20:24,780
procedure where each party now for

458
00:20:24,780 --> 00:20:27,419
example P1 if P1 wishes to forward the

459
00:20:27,419 --> 00:20:30,360
message it will select a subset of of

460
00:20:30,360 --> 00:20:32,600
the tool of the parties as his neighbor

461
00:20:32,600 --> 00:20:34,559
Neighbors and then forward the message

462
00:20:34,559 --> 00:20:36,780
only to those parties

463
00:20:36,780 --> 00:20:39,179
then again those parties was for what

464
00:20:39,179 --> 00:20:40,679
the message to a random chosen

465
00:20:40,679 --> 00:20:43,620
neighborhood their choice until all

466
00:20:43,620 --> 00:20:46,140
parties have received the message

467
00:20:46,140 --> 00:20:47,940
this works all well and good as long as

468
00:20:47,940 --> 00:20:50,039
all parties remain honest

469
00:20:50,039 --> 00:20:52,740
however if a lot of the parties are

470
00:20:52,740 --> 00:20:55,799
corrupted then either P1 has to send to

471
00:20:55,799 --> 00:20:57,240
a lot of parties

472
00:20:57,240 --> 00:20:59,520
or otherwise there will be some parties

473
00:20:59,520 --> 00:21:02,520
that does not receive the message

474
00:21:02,520 --> 00:21:05,460
okay so looking back to our

475
00:21:05,460 --> 00:21:07,799
blockchain example from before this

476
00:21:07,799 --> 00:21:09,179
means that when we actually wish to

477
00:21:09,179 --> 00:21:11,100
realize such flooding Network

478
00:21:11,100 --> 00:21:14,160
then you need to rely on some assumption

479
00:21:14,160 --> 00:21:16,260
on the number of parties to be honest

480
00:21:16,260 --> 00:21:18,419
and that is to build the total order you

481
00:21:18,419 --> 00:21:21,120
need to rely on both assumptions

482
00:21:21,120 --> 00:21:22,799
really would be better if you could just

483
00:21:22,799 --> 00:21:24,660
do with one assumption maybe the

484
00:21:24,660 --> 00:21:27,980
majority of honest resources

485
00:21:29,460 --> 00:21:32,760
so in this work we ask the question can

486
00:21:32,760 --> 00:21:34,500
efficient flooding be realized assuming

487
00:21:34,500 --> 00:21:36,299
a constant fraction of honest resources

488
00:21:36,299 --> 00:21:37,320
a weight

489
00:21:37,320 --> 00:21:39,360
and give an affirmative answer yes we

490
00:21:39,360 --> 00:21:40,260
can

491
00:21:40,260 --> 00:21:42,299
and a bit more detail our contributions

492
00:21:42,299 --> 00:21:43,320
are

493
00:21:43,320 --> 00:21:45,299
represent a new floating protocol called

494
00:21:45,299 --> 00:21:47,400
weighted fan out flooding

495
00:21:47,400 --> 00:21:49,919
and we will abbreviate this wff

496
00:21:49,919 --> 00:21:51,960
this is secure assuming any constant

497
00:21:51,960 --> 00:21:55,080
fraction resources being honest has a

498
00:21:55,080 --> 00:21:57,840
logarithmic diameter for in parties

499
00:21:57,840 --> 00:21:59,760
and

500
00:21:59,760 --> 00:22:01,440
it has a message complexity that is

501
00:22:01,440 --> 00:22:03,500
comparable to state-of-the-art

502
00:22:03,500 --> 00:22:06,179
firm or we do extensive simulations of

503
00:22:06,179 --> 00:22:07,679
this new flooding protocol which

504
00:22:07,679 --> 00:22:11,480
confirms that this impact is practical

505
00:22:12,240 --> 00:22:15,000
all right so the model we use for for

506
00:22:15,000 --> 00:22:16,860
our results is where we have a static

507
00:22:16,860 --> 00:22:19,559
set of parties where each party is

508
00:22:19,559 --> 00:22:22,919
assigned some positive number of weight

509
00:22:22,919 --> 00:22:26,280
now as for an adversary is allowed to

510
00:22:26,280 --> 00:22:28,740
corrupt a subset of the parties

511
00:22:28,740 --> 00:22:31,320
but the adversary will only put our

512
00:22:31,320 --> 00:22:33,419
assumption is that adversary is only

513
00:22:33,419 --> 00:22:37,080
able to corrupt a um

514
00:22:37,080 --> 00:22:38,240
a

515
00:22:38,240 --> 00:22:41,700
raw party such that a majority of the

516
00:22:41,700 --> 00:22:45,179
resources is left honest

517
00:22:45,179 --> 00:22:48,059
uh and this formally right there exists

518
00:22:48,059 --> 00:22:51,179
some gamma such that this majority this

519
00:22:51,179 --> 00:22:53,340
fraction of resources owned by owner's

520
00:22:53,340 --> 00:22:55,380
party is larger than the total fraction

521
00:22:55,380 --> 00:22:58,520
of a total number of resources

522
00:22:58,520 --> 00:23:00,960
uh and we note that this is implied by

523
00:23:00,960 --> 00:23:04,340
the standoff proof stake assumption

524
00:23:04,740 --> 00:23:06,059
all right

525
00:23:06,059 --> 00:23:07,740
so

526
00:23:07,740 --> 00:23:08,400
um

527
00:23:08,400 --> 00:23:10,500
now let's try to develop a protocol that

528
00:23:10,500 --> 00:23:11,820
actually realizes flooding in this

529
00:23:11,820 --> 00:23:12,720
setting

530
00:23:12,720 --> 00:23:14,820
so what we will do a very simple but

531
00:23:14,820 --> 00:23:16,320
inefficient protocol

532
00:23:16,320 --> 00:23:18,480
and we will use the idea well how about

533
00:23:18,480 --> 00:23:21,360
take some existing flooding protocol and

534
00:23:21,360 --> 00:23:22,980
actually try to embed this to make

535
00:23:22,980 --> 00:23:24,780
parties behave proportionate to that

536
00:23:24,780 --> 00:23:26,640
weight

537
00:23:26,640 --> 00:23:28,860
and as an existing plotting protocol

538
00:23:28,860 --> 00:23:31,020
which was protocol by Matt Nielsen

539
00:23:31,020 --> 00:23:33,780
Thompson from 2022 where each party

540
00:23:33,780 --> 00:23:35,880
forward to each other party with the

541
00:23:35,880 --> 00:23:38,039
probability row as we know this will

542
00:23:38,039 --> 00:23:39,600
ensure our logarithmic diamonds are for

543
00:23:39,600 --> 00:23:42,419
reasonable for parameters or reasonable

544
00:23:42,419 --> 00:23:43,980
parameter row

545
00:23:43,980 --> 00:23:46,559
so we can depict this as this thing

546
00:23:46,559 --> 00:23:48,240
right so if you want to forwards the

547
00:23:48,240 --> 00:23:50,700
message to P2 probability row

548
00:23:50,700 --> 00:23:52,559
now to accommodate this to the weighted

549
00:23:52,559 --> 00:23:54,780
setting what you could do is to let each

550
00:23:54,780 --> 00:23:57,659
party behave proportionally meaning that

551
00:23:57,659 --> 00:24:01,679
P1 will instantiate four sub parties one

552
00:24:01,679 --> 00:24:03,539
for each discrete unit of weight you all

553
00:24:03,539 --> 00:24:06,299
knows and the two will do the same thing

554
00:24:06,299 --> 00:24:09,000
and now when P1 wishes to decide whether

555
00:24:09,000 --> 00:24:11,280
or not to forward a message to P2 what

556
00:24:11,280 --> 00:24:14,539
P2 P1 can do is to let each party

557
00:24:14,539 --> 00:24:17,760
behave as a as a party in the existing

558
00:24:17,760 --> 00:24:20,340
protocol so that is each sub-party will

559
00:24:20,340 --> 00:24:24,120
flip a coin for each subparty of P2

560
00:24:24,120 --> 00:24:26,820
now the total probability forward will

561
00:24:26,820 --> 00:24:29,880
be 1 minus one minus 0 to the power of

562
00:24:29,880 --> 00:24:31,020
the weight of the two parts is

563
00:24:31,020 --> 00:24:31,700
multiplied together

564
00:24:31,700 --> 00:24:33,419
[Music]

565
00:24:33,419 --> 00:24:35,220
however this has a few unfortunate

566
00:24:35,220 --> 00:24:36,539
properties

567
00:24:36,539 --> 00:24:39,720
so uh if we double the total amount of

568
00:24:39,720 --> 00:24:41,880
weight in the system then this

569
00:24:41,880 --> 00:24:43,980
probability will increase by by quite a

570
00:24:43,980 --> 00:24:44,880
bit

571
00:24:44,880 --> 00:24:48,179
so what we intuitively want is that even

572
00:24:48,179 --> 00:24:49,980
though that we double the amount of

573
00:24:49,980 --> 00:24:52,919
weight this this probability shouldn't

574
00:24:52,919 --> 00:24:54,659
change so our protocol should be

575
00:24:54,659 --> 00:24:57,900
invariant to scaling of weights

576
00:24:57,900 --> 00:25:00,120
okay so let's try to develop this idea a

577
00:25:00,120 --> 00:25:00,960
bit

578
00:25:00,960 --> 00:25:02,700
so instead of letting each party

579
00:25:02,700 --> 00:25:04,260
directly

580
00:25:04,260 --> 00:25:06,360
um emulate a number of nodes proportions

581
00:25:06,360 --> 00:25:08,220
now wait what we'll do is to let

582
00:25:08,220 --> 00:25:09,960
introduce a function which we'll call

583
00:25:09,960 --> 00:25:12,360
the emulation function to decide how

584
00:25:12,360 --> 00:25:15,600
many parties each each node should

585
00:25:15,600 --> 00:25:17,520
emulate

586
00:25:17,520 --> 00:25:20,220
so if this was the picture before what

587
00:25:20,220 --> 00:25:23,280
we now has have is that P1 uses

588
00:25:23,280 --> 00:25:25,140
simulation function to decide how many

589
00:25:25,140 --> 00:25:27,240
nodes you should emulate and he will

590
00:25:27,240 --> 00:25:30,020
forward only to M flip a coin to forward

591
00:25:30,020 --> 00:25:32,880
for each of the tools emulated nodes as

592
00:25:32,880 --> 00:25:35,039
well the total probability will be

593
00:25:35,039 --> 00:25:36,240
something like this

594
00:25:36,240 --> 00:25:38,100
foreign

595
00:25:38,100 --> 00:25:39,539
okay

596
00:25:39,539 --> 00:25:42,059
so let's think about what property you

597
00:25:42,059 --> 00:25:44,100
would like from such a emulation

598
00:25:44,100 --> 00:25:45,960
function if it has if it should

599
00:25:45,960 --> 00:25:48,600
introduce a practical protocol

600
00:25:48,600 --> 00:25:51,120
so as we established before we need to

601
00:25:51,120 --> 00:25:53,880
that the emulation function should be

602
00:25:53,880 --> 00:25:56,100
invariant to scaling of weights

603
00:25:56,100 --> 00:25:59,220
we want that all parties should emulate

604
00:25:59,220 --> 00:26:01,380
at least one node and that is because we

605
00:26:01,380 --> 00:26:04,799
want each parties to to inherit the

606
00:26:04,799 --> 00:26:07,919
delivery guarantees from the original

607
00:26:07,919 --> 00:26:09,840
protocol

608
00:26:09,840 --> 00:26:11,880
and then if you have a closer look at

609
00:26:11,880 --> 00:26:15,120
this magnesium Thompson 2022 paper then

610
00:26:15,120 --> 00:26:18,240
we note that the message complexes in

611
00:26:18,240 --> 00:26:20,820
the number of nodes in this case it will

612
00:26:20,820 --> 00:26:23,400
be in the number of emulated nodes so we

613
00:26:23,400 --> 00:26:25,200
also warned that the number of emulators

614
00:26:25,200 --> 00:26:27,720
nodes are low in order to keep the

615
00:26:27,720 --> 00:26:29,340
message complexity low

616
00:26:29,340 --> 00:26:31,320
and then this message complexity is also

617
00:26:31,320 --> 00:26:35,520
linear in the fraction of Honest Weight

618
00:26:35,520 --> 00:26:37,679
sorry in the inverse of the fraction of

619
00:26:37,679 --> 00:26:39,059
the Honest Weight

620
00:26:39,059 --> 00:26:41,460
so we kind of want that fraction of

621
00:26:41,460 --> 00:26:43,620
honestly emanated emulated nodes should

622
00:26:43,620 --> 00:26:46,020
also be high

623
00:26:46,020 --> 00:26:49,380
okay so uh what candidates do we have

624
00:26:49,380 --> 00:26:51,000
well

625
00:26:51,000 --> 00:26:52,980
we had a look at this just assigning

626
00:26:52,980 --> 00:26:54,419
each party to emulate the number of

627
00:26:54,419 --> 00:26:55,980
weight they had before

628
00:26:55,980 --> 00:26:57,539
this was how early modern variant

629
00:26:57,539 --> 00:26:59,100
scaling of weight

630
00:26:59,100 --> 00:27:01,740
so to fix this what we could do is to

631
00:27:01,740 --> 00:27:04,260
let each party emulate just a fraction

632
00:27:04,260 --> 00:27:06,840
of weight owned by a party p

633
00:27:06,840 --> 00:27:08,640
so this is naturally invariant to

634
00:27:08,640 --> 00:27:10,020
scaling of weight if you double the

635
00:27:10,020 --> 00:27:13,340
weight the fraction Remains the Same

636
00:27:13,340 --> 00:27:15,600
however it doesn't fulfill the

637
00:27:15,600 --> 00:27:16,860
requirement that each party should

638
00:27:16,860 --> 00:27:19,260
emulate at least one note

639
00:27:19,260 --> 00:27:21,179
so what could we do well we could take

640
00:27:21,179 --> 00:27:23,159
the ceiling they're still invariant to

641
00:27:23,159 --> 00:27:24,419
scaling of weight

642
00:27:24,419 --> 00:27:26,640
and any party now aim is at least one

643
00:27:26,640 --> 00:27:27,720
note

644
00:27:27,720 --> 00:27:29,400
furthermore the number of emulators

645
00:27:29,400 --> 00:27:32,100
nodes are reasonably low in fact this is

646
00:27:32,100 --> 00:27:33,480
just in

647
00:27:33,480 --> 00:27:35,340
however it fails to compile with the

648
00:27:35,340 --> 00:27:37,320
last requirement the fraction of

649
00:27:37,320 --> 00:27:40,140
honestly emulated notes are not high in

650
00:27:40,140 --> 00:27:42,299
fact this is similar to just let each

651
00:27:42,299 --> 00:27:45,419
party emulate one node but it doesn't

652
00:27:45,419 --> 00:27:46,980
work either right then we're back to the

653
00:27:46,980 --> 00:27:49,820
non-weighted setting

654
00:27:49,980 --> 00:27:53,880
okay so as a final thing try to take the

655
00:27:53,880 --> 00:27:55,500
ceiling off the fraction of stake um

656
00:27:55,500 --> 00:27:58,559
party P now multiply this by the number

657
00:27:58,559 --> 00:28:01,380
of parties so what do we get well it's

658
00:28:01,380 --> 00:28:03,600
still invariant to scaling wait and all

659
00:28:03,600 --> 00:28:06,000
parties emulate at least one node the

660
00:28:06,000 --> 00:28:07,980
number of loads nodes is reasonably low

661
00:28:07,980 --> 00:28:10,620
this is less than 2N but now the

662
00:28:10,620 --> 00:28:13,500
fraction of honestly emanated nodes are

663
00:28:13,500 --> 00:28:15,240
now less than

664
00:28:15,240 --> 00:28:17,100
um if gamma here is the fraction of

665
00:28:17,100 --> 00:28:20,279
honest weight then fraction of honestly

666
00:28:20,279 --> 00:28:23,159
emulated node will now be larger than or

667
00:28:23,159 --> 00:28:27,000
equal to gamma divided by two

668
00:28:27,000 --> 00:28:29,159
so this actually constitutes a fairly

669
00:28:29,159 --> 00:28:30,240
good protocol

670
00:28:30,240 --> 00:28:33,240
however there is a few issues remaining

671
00:28:33,240 --> 00:28:36,240
first of all to select the neighbors

672
00:28:36,240 --> 00:28:38,760
well P1 needs to flip a coin that comes

673
00:28:38,760 --> 00:28:40,500
out heads with this probability for each

674
00:28:40,500 --> 00:28:41,880
of his neighbors

675
00:28:41,880 --> 00:28:43,679
this is kind of Impractical as we've

676
00:28:43,679 --> 00:28:45,779
heard before that Randomness is a scarce

677
00:28:45,779 --> 00:28:47,340
resource

678
00:28:47,340 --> 00:28:48,779
furthermore

679
00:28:48,779 --> 00:28:50,100
um it's not very practical that there's

680
00:28:50,100 --> 00:28:52,200
an unknown number of levers for each

681
00:28:52,200 --> 00:28:54,120
message

682
00:28:54,120 --> 00:28:56,940
so in order to remedy this we introduced

683
00:28:56,940 --> 00:28:58,799
this weight of fan art floating which

684
00:28:58,799 --> 00:29:00,419
uses some of the same intuitions we had

685
00:29:00,419 --> 00:29:03,000
before again you use an emulation

686
00:29:03,000 --> 00:29:05,520
function for each party use the same one

687
00:29:05,520 --> 00:29:09,240
which we just gained intuition for

688
00:29:09,240 --> 00:29:12,000
um then we will let each party select a

689
00:29:12,000 --> 00:29:14,279
fixed number of neighbors this will be

690
00:29:14,279 --> 00:29:17,100
some parameter of our protocol K times

691
00:29:17,100 --> 00:29:18,960
the number of nodes this party should

692
00:29:18,960 --> 00:29:20,880
emulate

693
00:29:20,880 --> 00:29:23,880
now neighbors of a party are selected by

694
00:29:23,880 --> 00:29:25,380
weight same thing without replacement

695
00:29:25,380 --> 00:29:27,480
where each party again is rated by the

696
00:29:27,480 --> 00:29:28,919
emulation

697
00:29:28,919 --> 00:29:30,659
let's just have a quick look at how this

698
00:29:30,659 --> 00:29:33,240
works so if you want me to send a

699
00:29:33,240 --> 00:29:34,919
message well then you'll decide this

700
00:29:34,919 --> 00:29:36,720
neighborhood by first calculating how

701
00:29:36,720 --> 00:29:39,720
many modes each party should emulate

702
00:29:39,720 --> 00:29:42,960
so in this case P1 emulates two nodes P2

703
00:29:42,960 --> 00:29:46,200
emulate five nodes and so on so forth

704
00:29:46,200 --> 00:29:47,039
um

705
00:29:47,039 --> 00:29:51,380
and now at random let's just do it for

706
00:29:51,380 --> 00:29:54,600
lowercase k being equal to one and then

707
00:29:54,600 --> 00:29:58,140
P1 initially selects one node one sub

708
00:29:58,140 --> 00:30:00,000
note party at random

709
00:30:00,000 --> 00:30:02,100
and then chooses to send the message to

710
00:30:02,100 --> 00:30:06,360
the party emulating this sub party

711
00:30:06,360 --> 00:30:08,940
and the next one is selected by this

712
00:30:08,940 --> 00:30:11,039
regarding those the path denote

713
00:30:11,039 --> 00:30:14,039
simulated by the party that already has

714
00:30:14,039 --> 00:30:16,080
been selected as a neighbor and then

715
00:30:16,080 --> 00:30:18,779
selecting a new node at random then the

716
00:30:18,779 --> 00:30:24,080
final neighborhood just those parties

717
00:30:24,659 --> 00:30:28,740
okay so the main result our theorem of

718
00:30:28,740 --> 00:30:31,080
our paper is that if we set this

719
00:30:31,080 --> 00:30:33,240
parameter of the vertical k

720
00:30:33,240 --> 00:30:34,980
be logarithmic in the number of

721
00:30:34,980 --> 00:30:37,440
neighbors plus some security parameter

722
00:30:37,440 --> 00:30:41,039
and we divide by the fraction of weight

723
00:30:41,039 --> 00:30:42,960
then we actually achieve a Delta

724
00:30:42,960 --> 00:30:46,200
floating protocol for a local delivery

725
00:30:46,200 --> 00:30:49,260
time Delta that is logarithmic

726
00:30:49,260 --> 00:30:52,080
um in the number of parties

727
00:30:52,080 --> 00:30:55,020
and this has message complexity which is

728
00:30:55,020 --> 00:30:57,779
just this lowercase k times n

729
00:30:57,779 --> 00:31:01,260
and each part here will have roughly

730
00:31:01,260 --> 00:31:04,500
um it will have K times the stimulation

731
00:31:04,500 --> 00:31:08,220
function uh number of emulated nodes as

732
00:31:08,220 --> 00:31:10,820
their neighbors

733
00:31:12,000 --> 00:31:14,760
okay so um in order to test the

734
00:31:14,760 --> 00:31:17,279
practicality of our protocol what we did

735
00:31:17,279 --> 00:31:20,340
was to implement it then

736
00:31:20,340 --> 00:31:23,460
um among a thousand nodes simulate how

737
00:31:23,460 --> 00:31:24,779
often

738
00:31:24,779 --> 00:31:25,740
um

739
00:31:25,740 --> 00:31:28,380
how often all parties have the message

740
00:31:28,380 --> 00:31:30,899
delivered for an increasing parameter

741
00:31:30,899 --> 00:31:33,419
lowercase k

742
00:31:33,419 --> 00:31:36,480
um and then counted how many neighbors

743
00:31:36,480 --> 00:31:38,820
each party on average had to choose

744
00:31:38,820 --> 00:31:41,880
and this is what is depicted here

745
00:31:41,880 --> 00:31:43,860
and additionally we had an adversary

746
00:31:43,860 --> 00:31:47,640
that corrupted half of the weight and

747
00:31:47,640 --> 00:31:48,779
the weight was assigned to an

748
00:31:48,779 --> 00:31:51,840
exponential distribution where each The

749
00:31:51,840 --> 00:31:54,659
Ridges sorry the heaviest party weighed

750
00:31:54,659 --> 00:31:58,279
approximately weighted a million times

751
00:31:58,279 --> 00:32:01,260
the weight of the lowest party

752
00:32:01,260 --> 00:32:03,600
let me write the the brain the

753
00:32:03,600 --> 00:32:05,640
corruption strategy by the adversary to

754
00:32:05,640 --> 00:32:07,799
either be random Corruptions corrupt

755
00:32:07,799 --> 00:32:10,260
heaviest parties first or corrupt the

756
00:32:10,260 --> 00:32:12,000
light parties first

757
00:32:12,000 --> 00:32:14,880
and what we see here is that uh

758
00:32:14,880 --> 00:32:16,799
independently of all these parameters

759
00:32:16,799 --> 00:32:19,860
and if each party on average sends to

760
00:32:19,860 --> 00:32:22,860
roughly 45 parties then the protocol

761
00:32:22,860 --> 00:32:25,919
succeeds with roughly 100 success rate

762
00:32:25,919 --> 00:32:28,500
this number may seem I don't know if it

763
00:32:28,500 --> 00:32:30,480
says anything to you

764
00:32:30,480 --> 00:32:31,919
um but what you could do is to compare

765
00:32:31,919 --> 00:32:35,279
this with existing protocols which we'll

766
00:32:35,279 --> 00:32:37,740
refer to as

767
00:32:37,740 --> 00:32:40,620
weight oblivious protocols

768
00:32:40,620 --> 00:32:43,320
so we did the same experiment we had an

769
00:32:43,320 --> 00:32:45,419
exponential distribution which now had a

770
00:32:45,419 --> 00:32:48,720
parameter where the parameter refers to

771
00:32:48,720 --> 00:32:53,940
how the amount of time the the previous

772
00:32:53,940 --> 00:32:54,960
party

773
00:32:54,960 --> 00:32:56,820
the weight of the heaviest part is

774
00:32:56,820 --> 00:32:58,399
compared to the

775
00:32:58,399 --> 00:33:00,419
lightest party

776
00:33:00,419 --> 00:33:02,940
and what we see that if we actually just

777
00:33:02,940 --> 00:33:04,919
have a constant distribution of weight

778
00:33:04,919 --> 00:33:07,020
responding to the non-weighted setting

779
00:33:07,020 --> 00:33:09,299
well then our protocol performs exactly

780
00:33:09,299 --> 00:33:13,380
equal to the original weight oblivious

781
00:33:13,380 --> 00:33:14,880
flooding protocol wage party simply

782
00:33:14,880 --> 00:33:17,840
sends to K Neighbors

783
00:33:17,940 --> 00:33:21,600
um but as the weight distribution gets

784
00:33:21,600 --> 00:33:24,659
more and more skewed well then the

785
00:33:24,659 --> 00:33:26,399
success probability of the weight

786
00:33:26,399 --> 00:33:28,019
oblivious flooding protocol drops

787
00:33:28,019 --> 00:33:30,240
dramatically however

788
00:33:30,240 --> 00:33:31,919
our weighted fan out floating protocol

789
00:33:31,919 --> 00:33:34,880
remains secure for these 45

790
00:33:34,880 --> 00:33:40,700
parties that that are sent to on average

791
00:33:41,880 --> 00:33:44,340
all right so in conclusion

792
00:33:44,340 --> 00:33:46,260
we present the first proof of the secure

793
00:33:46,260 --> 00:33:47,519
flooding protocol in the weighted

794
00:33:47,519 --> 00:33:49,320
setting and demonstrate practicality

795
00:33:49,320 --> 00:33:51,899
using probabilistic simulations

796
00:33:51,899 --> 00:33:53,820
and there are many more details and

797
00:33:53,820 --> 00:33:55,399
additional results

798
00:33:55,399 --> 00:33:58,200
among those are necessity of increasing

799
00:33:58,200 --> 00:34:00,360
neighborhood for heavy parties necessity

800
00:34:00,360 --> 00:34:01,860
of logarithmic number neighborhood for

801
00:34:01,860 --> 00:34:03,419
faint out flooding

802
00:34:03,419 --> 00:34:07,679
we show how to deliver the message to

803
00:34:07,679 --> 00:34:09,659
parties even with zero weight

804
00:34:09,659 --> 00:34:13,260
and we do additional simulations

805
00:34:13,260 --> 00:34:16,280
thank you for your attention

806
00:34:23,639 --> 00:34:25,739
for uh we're running ahead of schedule

807
00:34:25,739 --> 00:34:28,320
so somebody should ask a question and

808
00:34:28,320 --> 00:34:31,280
get us back on track

809
00:34:35,040 --> 00:34:38,040
foreign

810
00:34:39,260 --> 00:34:43,199
I'll ask actually like uh how does this

811
00:34:43,199 --> 00:34:44,879
I mean have you thought about kind of

812
00:34:44,879 --> 00:34:47,399
incentives and economic analysis and

813
00:34:47,399 --> 00:34:49,560
people potentially like manipulating

814
00:34:49,560 --> 00:34:51,119
their weight or

815
00:34:51,119 --> 00:34:53,520
reporting it truthfully

816
00:34:53,520 --> 00:34:57,119
right so so you're right this this

817
00:34:57,119 --> 00:34:59,940
um this protocol depends on the weights

818
00:34:59,940 --> 00:35:02,040
being accurate

819
00:35:02,040 --> 00:35:04,440
um and and therefore we just kind of

820
00:35:04,440 --> 00:35:06,839
need to realize this somehow from an

821
00:35:06,839 --> 00:35:10,619
existing assumption so I think the the

822
00:35:10,619 --> 00:35:12,780
it's fairly easy to see how to do this

823
00:35:12,780 --> 00:35:14,700
from a proof of stake assumption where

824
00:35:14,700 --> 00:35:16,980
all parties already know how many coins

825
00:35:16,980 --> 00:35:19,140
each party owns but this is more

826
00:35:19,140 --> 00:35:21,380
difficult for uh say a proof of

827
00:35:21,380 --> 00:35:25,020
computational power proof of work

828
00:35:25,020 --> 00:35:27,119
um where you have to estimate this in

829
00:35:27,119 --> 00:35:28,980
some reliable manner

830
00:35:28,980 --> 00:35:30,240
um as otherwise we will not guarantee

831
00:35:30,240 --> 00:35:32,760
security of the protocol

832
00:35:32,760 --> 00:35:35,400
thanks

833
00:35:35,400 --> 00:35:39,480
um okay well let's thank uh Soren again

834
00:35:39,480 --> 00:35:41,660
um

835
00:35:41,700 --> 00:35:44,280
and uh yeah we'll move on to our last

836
00:35:44,280 --> 00:35:46,579
talk

837
00:35:47,220 --> 00:35:48,540
uh

838
00:35:48,540 --> 00:35:49,740
so

839
00:35:49,740 --> 00:35:51,480
um

840
00:35:51,480 --> 00:35:56,160
our uh our last talk is

841
00:35:56,160 --> 00:35:58,800
snacks

842
00:35:58,800 --> 00:36:00,180
uh

843
00:36:00,180 --> 00:36:03,740
with a Hamza absala

844
00:36:03,740 --> 00:36:10,578
uh who hopefully is ready to uh to share

845
00:36:11,280 --> 00:36:13,740
two seconds great yeah if you're ready

846
00:36:13,740 --> 00:36:15,960
Hamza we can see your slides and hear

847
00:36:15,960 --> 00:36:19,380
you so do you actually also see me I

848
00:36:19,380 --> 00:36:21,480
don't yes we see you and your slides

849
00:36:21,480 --> 00:36:24,660
yeah it works great okay great

850
00:36:24,660 --> 00:36:27,599
okay so welcome everybody to to my talk

851
00:36:27,599 --> 00:36:29,880
about snacks this work is jointly done

852
00:36:29,880 --> 00:36:32,160
with York Fox power Peter gaju and Karen

853
00:36:32,160 --> 00:36:34,200
Klein

854
00:36:34,200 --> 00:36:35,579
um I'll start off by talking about

855
00:36:35,579 --> 00:36:38,520
lightline blockchain bootstrapping as as

856
00:36:38,520 --> 00:36:41,040
a problem and then Define snacks uh

857
00:36:41,040 --> 00:36:42,960
succinct and interactive arguments of

858
00:36:42,960 --> 00:36:44,180
chain knowledge

859
00:36:44,180 --> 00:36:46,859
construct snacks generically from proofs

860
00:36:46,859 --> 00:36:48,839
of sequential work schemes and then get

861
00:36:48,839 --> 00:36:50,700
back to post trapping and show you how

862
00:36:50,700 --> 00:36:55,200
to realize them generically from snacks

863
00:36:55,200 --> 00:36:58,020
in light land blockchain protocols you

864
00:36:58,020 --> 00:37:01,260
have full node proofers that store the

865
00:37:01,260 --> 00:37:03,060
entirety of the blockchain and you have

866
00:37:03,060 --> 00:37:05,640
like client verifiers that have minimal

867
00:37:05,640 --> 00:37:07,500
information about the blockchain

868
00:37:07,500 --> 00:37:10,619
optimally the Genesis block

869
00:37:10,619 --> 00:37:12,839
the protocol we would like it to satisfy

870
00:37:12,839 --> 00:37:14,640
a few properties we would like the

871
00:37:14,640 --> 00:37:16,859
verifier to have some linear effort the

872
00:37:16,859 --> 00:37:18,900
communication to be sub-linear and the

873
00:37:18,900 --> 00:37:20,880
protocol non-interactive

874
00:37:20,880 --> 00:37:22,800
if Additionally the protocol achieves

875
00:37:22,800 --> 00:37:25,200
sublinear approver and no setup

876
00:37:25,200 --> 00:37:27,839
assumptions that's a plus and our

877
00:37:27,839 --> 00:37:29,820
protocol achieve or achieves all of

878
00:37:29,820 --> 00:37:31,740
these properties

879
00:37:31,740 --> 00:37:33,839
so informally in a bootstrapping

880
00:37:33,839 --> 00:37:35,940
protocol is a verifier depicted here on

881
00:37:35,940 --> 00:37:37,440
the right side

882
00:37:37,440 --> 00:37:40,500
who has the Genesis block P0 of the

883
00:37:40,500 --> 00:37:42,960
blockchain in question

884
00:37:42,960 --> 00:37:45,060
potentially after reading a bunch of

885
00:37:45,060 --> 00:37:48,480
proofs from different approvers its goal

886
00:37:48,480 --> 00:37:51,660
is to Output Phi I a commitment to the

887
00:37:51,660 --> 00:37:54,720
stable prefix of the blockchain

888
00:37:54,720 --> 00:37:56,640
while this is interesting with this

889
00:37:56,640 --> 00:37:59,820
verifier can become a full Miner itself

890
00:37:59,820 --> 00:38:02,579
if it wishes to okay assume that it went

891
00:38:02,579 --> 00:38:05,339
asleep for some time and then now it

892
00:38:05,339 --> 00:38:06,780
catches up with the state of the

893
00:38:06,780 --> 00:38:09,240
blockchain and can continue mining but

894
00:38:09,240 --> 00:38:11,460
additionally assume that you have

895
00:38:11,460 --> 00:38:13,920
a bootstrap verifier and therefore

896
00:38:13,920 --> 00:38:15,480
different blockchains so you have a

897
00:38:15,480 --> 00:38:18,240
proof of work Bitcoin blockchain and the

898
00:38:18,240 --> 00:38:21,660
proof of space uh Chia blockchain and we

899
00:38:21,660 --> 00:38:23,640
have a bootstrap verifier that has

900
00:38:23,640 --> 00:38:25,800
commitments to these blockchains then

901
00:38:25,800 --> 00:38:28,560
any approver can prove statements about

902
00:38:28,560 --> 00:38:32,820
say the transactions in the I uh Bitcoin

903
00:38:32,820 --> 00:38:35,640
block and the JS Chia block by opening

904
00:38:35,640 --> 00:38:37,260
commitments to these blocks and then

905
00:38:37,260 --> 00:38:40,140
carrying out the proofs so the idea of

906
00:38:40,140 --> 00:38:42,960
having a commitment to a blockchain is a

907
00:38:42,960 --> 00:38:44,760
very powerful tool

908
00:38:44,760 --> 00:38:48,380
so this problem has a few Solutions

909
00:38:48,380 --> 00:38:51,300
so there's the generic snark solution

910
00:38:51,300 --> 00:38:53,579
and there is the non-interactive proofs

911
00:38:53,579 --> 00:38:56,040
of proofs of work the powers and there's

912
00:38:56,040 --> 00:38:58,500
a flag client some limitations of these

913
00:38:58,500 --> 00:39:00,660
Works exist some of them require set of

914
00:39:00,660 --> 00:39:02,520
assumptions some of them have limited

915
00:39:02,520 --> 00:39:04,619
applicability say apply for proof of

916
00:39:04,619 --> 00:39:07,560
work blockchains but say don't or we

917
00:39:07,560 --> 00:39:09,540
don't know how to do them for proof of

918
00:39:09,540 --> 00:39:11,220
space blockchains some of them have

919
00:39:11,220 --> 00:39:14,280
limited usefulness or even the notion of

920
00:39:14,280 --> 00:39:16,079
commitment doesn't come up in in the

921
00:39:16,079 --> 00:39:18,839
construction but more interestingly for

922
00:39:18,839 --> 00:39:22,260
Nepal nepals and fly client they work in

923
00:39:22,260 --> 00:39:24,480
a non-standard model where you assume

924
00:39:24,480 --> 00:39:26,040
that you're interacting with multiple

925
00:39:26,040 --> 00:39:28,560
proofers one of them is honest

926
00:39:28,560 --> 00:39:30,720
if you are outside of this model there

927
00:39:30,720 --> 00:39:32,820
are no probable guarantees

928
00:39:32,820 --> 00:39:35,220
and that's a limitation

929
00:39:35,220 --> 00:39:37,500
in this work we Define a classical proof

930
00:39:37,500 --> 00:39:40,220
system that underlies

931
00:39:40,220 --> 00:39:42,720
some some light client blockchain

932
00:39:42,720 --> 00:39:45,720
applications in particular bootstrapping

933
00:39:45,720 --> 00:39:48,119
we construct snacks from graph labeling

934
00:39:48,119 --> 00:39:50,280
proof of sequential work schemes and

935
00:39:50,280 --> 00:39:51,599
along the way we give a new construction

936
00:39:51,599 --> 00:39:54,420
and generalizing unify existing ones and

937
00:39:54,420 --> 00:39:56,880
we then show how these Stacks as a tool

938
00:39:56,880 --> 00:40:00,780
can be used to realize bootstrapping the

939
00:40:00,780 --> 00:40:02,460
advantage of this work is that you have

940
00:40:02,460 --> 00:40:04,859
a classical soundness guarantees in the

941
00:40:04,859 --> 00:40:07,020
sense that if the verifier is reading a

942
00:40:07,020 --> 00:40:09,180
malicious proof then it has a meaningful

943
00:40:09,180 --> 00:40:10,579
measurable

944
00:40:10,579 --> 00:40:12,960
guarantees that I will talk about in a

945
00:40:12,960 --> 00:40:13,680
bit

946
00:40:13,680 --> 00:40:16,079
this is in contrast to the universe

947
00:40:16,079 --> 00:40:18,780
client protocols our protocol is simple

948
00:40:18,780 --> 00:40:21,000
generic and modular and it allows for

949
00:40:21,000 --> 00:40:24,060
exchange of ideas from the area of proof

950
00:40:24,060 --> 00:40:25,859
of sequential Works proof is equal to

951
00:40:25,859 --> 00:40:29,280
our schemes and like client blockchains

952
00:40:29,280 --> 00:40:31,859
so in one in one slide pictorially how

953
00:40:31,859 --> 00:40:34,260
do we do this so we assume that we start

954
00:40:34,260 --> 00:40:37,260
with a blockchain depicted here it has

955
00:40:37,260 --> 00:40:39,960
the typical chain that you expect and a

956
00:40:39,960 --> 00:40:41,960
few extra

957
00:40:41,960 --> 00:40:44,240
edges

958
00:40:44,240 --> 00:40:48,599
and if we start with the graph of of any

959
00:40:48,599 --> 00:40:50,460
graph labeling proof of sequential work

960
00:40:50,460 --> 00:40:52,980
scheme here's an example then what we

961
00:40:52,980 --> 00:40:55,260
show is that we build an augmented

962
00:40:55,260 --> 00:40:56,280
blockchain

963
00:40:56,280 --> 00:40:59,099
we started from the chain on top and we

964
00:40:59,099 --> 00:41:01,560
we get the chain on the bottom which is

965
00:41:01,560 --> 00:41:03,060
the union of these two graphs

966
00:41:03,060 --> 00:41:04,980
essentially

967
00:41:04,980 --> 00:41:07,859
and then we show how to do to build an

968
00:41:07,859 --> 00:41:11,220
augmented mining that labels the graph

969
00:41:11,220 --> 00:41:13,980
so the mining in for this talk will be

970
00:41:13,980 --> 00:41:16,380
generating the labels of the nodes of

971
00:41:16,380 --> 00:41:18,240
the graph

972
00:41:18,240 --> 00:41:21,540
then we Define some witness relation and

973
00:41:21,540 --> 00:41:23,940
then we Define a proof system over this

974
00:41:23,940 --> 00:41:26,099
graph and the proof system will be very

975
00:41:26,099 --> 00:41:28,200
similar to the underlying buffer

976
00:41:28,200 --> 00:41:31,079
sequential work proof system so the idea

977
00:41:31,079 --> 00:41:33,839
is that we absorb the the blockchain

978
00:41:33,839 --> 00:41:36,540
data into the computation of the proof

979
00:41:36,540 --> 00:41:38,940
of sequential work scheme such that the

980
00:41:38,940 --> 00:41:41,460
sequentiality guarantees of the proof of

981
00:41:41,460 --> 00:41:43,500
sequential work scheme translate into

982
00:41:43,500 --> 00:41:45,660
sequentiality guarantees on the

983
00:41:45,660 --> 00:41:48,359
blockchain so this is the main general

984
00:41:48,359 --> 00:41:49,560
idea

985
00:41:49,560 --> 00:41:52,079
so with this slide in mind let's dig

986
00:41:52,079 --> 00:41:53,640
into it

987
00:41:53,640 --> 00:41:55,859
so before defining proofs of sequential

988
00:41:55,859 --> 00:41:58,260
work schemes we need this notion of

989
00:41:58,260 --> 00:42:01,140
graph labeling so you have a graph like

990
00:42:01,140 --> 00:42:03,180
this and to label the graph we generally

991
00:42:03,180 --> 00:42:05,520
use a hash function model as a random

992
00:42:05,520 --> 00:42:08,760
Oracle depicted here as Tau and the

993
00:42:08,760 --> 00:42:12,599
label of a Vertex is is the label of the

994
00:42:12,599 --> 00:42:16,020
is the hash of the labels of its parents

995
00:42:16,020 --> 00:42:18,119
concatenated with this index so for

996
00:42:18,119 --> 00:42:22,500
example the um the label of five will be

997
00:42:22,500 --> 00:42:24,540
the the hash of five concatenated with

998
00:42:24,540 --> 00:42:26,880
the labels of its parents namely the

999
00:42:26,880 --> 00:42:29,940
label of four and the label of one

1000
00:42:29,940 --> 00:42:33,180
very standard notation so graph labeling

1001
00:42:33,180 --> 00:42:35,220
both sequential schemes were introduced

1002
00:42:35,220 --> 00:42:37,140
by Mahmoud

1003
00:42:37,140 --> 00:42:39,540
it's an interactive protocol

1004
00:42:39,540 --> 00:42:41,579
between a program verifier where

1005
00:42:41,579 --> 00:42:43,680
completeness says that an honest prover

1006
00:42:43,680 --> 00:42:46,619
that makes n sequential queries to its

1007
00:42:46,619 --> 00:42:48,720
Oracle makes the verifier except with

1008
00:42:48,720 --> 00:42:50,460
probability one

1009
00:42:50,460 --> 00:42:52,740
succinctness is what you expect proofs

1010
00:42:52,740 --> 00:42:53,579
are

1011
00:42:53,579 --> 00:42:55,320
buddy logarithmic and they can be

1012
00:42:55,320 --> 00:42:57,540
verified in bullet algorithmic time

1013
00:42:57,540 --> 00:42:59,640
the interesting property is soundness

1014
00:42:59,640 --> 00:43:02,640
Alpha Epsilon soundness says even a

1015
00:43:02,640 --> 00:43:06,540
massively parallel malicious prover that

1016
00:43:06,540 --> 00:43:09,119
makes an alpha fraction sequential

1017
00:43:09,119 --> 00:43:11,640
queries for Alpha between zero and one

1018
00:43:11,640 --> 00:43:14,339
then it will make the verifier fail with

1019
00:43:14,339 --> 00:43:16,140
a very large probability one minus

1020
00:43:16,140 --> 00:43:18,000
Epsilon

1021
00:43:18,000 --> 00:43:21,060
so that says that parallelism does not

1022
00:43:21,060 --> 00:43:22,980
help a malicious proof and convincing

1023
00:43:22,980 --> 00:43:25,380
the verifier unless it actually hit

1024
00:43:25,380 --> 00:43:27,000
these sequential work that was supposed

1025
00:43:27,000 --> 00:43:28,079
to do

1026
00:43:28,079 --> 00:43:30,119
okay so this is gonna intuitively what

1027
00:43:30,119 --> 00:43:32,579
the notion of sequentiality is

1028
00:43:32,579 --> 00:43:35,700
a simple proof of SQL Server scheme that

1029
00:43:35,700 --> 00:43:37,140
we give in this work and it's a simple

1030
00:43:37,140 --> 00:43:40,619
variation on on existing ski and an

1031
00:43:40,619 --> 00:43:42,300
existing scheme

1032
00:43:42,300 --> 00:43:44,480
is this where the the schemess

1033
00:43:44,480 --> 00:43:48,240
parameterized by a family of graphs uh

1034
00:43:48,240 --> 00:43:51,180
that look like this a skipless graph the

1035
00:43:51,180 --> 00:43:54,119
the proverb upon receiving

1036
00:43:54,119 --> 00:43:56,880
um Chi from the verify I will use it to

1037
00:43:56,880 --> 00:44:00,060
solve its hash function and build uh and

1038
00:44:00,060 --> 00:44:04,260
then here will be Tau and then compute

1039
00:44:04,260 --> 00:44:06,060
the labels of the of the graph in

1040
00:44:06,060 --> 00:44:07,920
topological order

1041
00:44:07,920 --> 00:44:10,500
he was using this uh salted hash

1042
00:44:10,500 --> 00:44:11,579
function

1043
00:44:11,579 --> 00:44:13,740
and then since the the level of the sync

1044
00:44:13,740 --> 00:44:16,640
to the verifier which will

1045
00:44:16,640 --> 00:44:19,319
serve as a position binding commitment

1046
00:44:19,319 --> 00:44:21,599
to the labels of the graph and then

1047
00:44:21,599 --> 00:44:24,180
these two parties run a challenge

1048
00:44:24,180 --> 00:44:27,540
response phase 40 minute times in each

1049
00:44:27,540 --> 00:44:31,440
in each round say here for example the

1050
00:44:31,440 --> 00:44:33,900
verifier sends okay give me the

1051
00:44:33,900 --> 00:44:36,480
something related to the index five

1052
00:44:36,480 --> 00:44:38,220
what the approva does in this particular

1053
00:44:38,220 --> 00:44:40,140
prophecy commercial work schemes that it

1054
00:44:40,140 --> 00:44:42,660
locates the shortest path that goes from

1055
00:44:42,660 --> 00:44:44,640
the source to the sink and passing

1056
00:44:44,640 --> 00:44:48,300
through the challenge five here and then

1057
00:44:48,300 --> 00:44:51,619
it gives the the verifier the labels of

1058
00:44:51,619 --> 00:44:55,020
this path and its parents okay in

1059
00:44:55,020 --> 00:44:57,300
particular we say it opens this path

1060
00:44:57,300 --> 00:44:59,339
and the verifier will check the

1061
00:44:59,339 --> 00:45:01,440
consistency of the labels of this path

1062
00:45:01,440 --> 00:45:05,819
and and this path I'm although in this

1063
00:45:05,819 --> 00:45:07,859
in this picture it looks like the Rover

1064
00:45:07,859 --> 00:45:09,839
is giving the entirety of the graph it's

1065
00:45:09,839 --> 00:45:12,660
actually still boiling algorithmic uh

1066
00:45:12,660 --> 00:45:14,339
and notice that the shortest path is

1067
00:45:14,339 --> 00:45:15,780
logarithmic

1068
00:45:15,780 --> 00:45:17,819
and the in degree of the graph is

1069
00:45:17,819 --> 00:45:19,859
logarithmic so all is good but this is

1070
00:45:19,859 --> 00:45:22,200
just a small example okay

1071
00:45:22,200 --> 00:45:25,200
so succinct this is is achieved and and

1072
00:45:25,200 --> 00:45:27,599
the and soundness is actually also

1073
00:45:27,599 --> 00:45:29,940
achieved with I would not bother reading

1074
00:45:29,940 --> 00:45:31,980
the the whole theorem statement but

1075
00:45:31,980 --> 00:45:34,020
we'll highlight Epsilon in in the

1076
00:45:34,020 --> 00:45:35,640
previous Slide the probability of

1077
00:45:35,640 --> 00:45:40,560
failure it depends on Alpha and and T as

1078
00:45:40,560 --> 00:45:42,720
expected which is Alpha to the power of

1079
00:45:42,720 --> 00:45:45,960
t plus some negligible term that amounts

1080
00:45:45,960 --> 00:45:48,240
of finding collisions in in the hash

1081
00:45:48,240 --> 00:45:51,660
function the random Oracle here in Q

1082
00:45:51,660 --> 00:45:53,579
mini queries in Twitter

1083
00:45:53,579 --> 00:45:55,800
okay so this is a simple proof of

1084
00:45:55,800 --> 00:45:57,720
sequential by scheme that I will carry

1085
00:45:57,720 --> 00:45:59,880
on with me in and for the rest of the

1086
00:45:59,880 --> 00:46:01,380
talk

1087
00:46:01,380 --> 00:46:06,119
um so we we're coming close to defining

1088
00:46:06,119 --> 00:46:09,540
snacks and then materializing them we

1089
00:46:09,540 --> 00:46:12,540
need one more notion for that we use

1090
00:46:12,540 --> 00:46:14,819
with the notion of weighted graphs where

1091
00:46:14,819 --> 00:46:17,040
a graph say just an example like this

1092
00:46:17,040 --> 00:46:20,099
each node has a weight and the sum of

1093
00:46:20,099 --> 00:46:22,800
the weights of all the nodes is one

1094
00:46:22,800 --> 00:46:25,339
okay

1095
00:46:26,280 --> 00:46:28,339
foreign

1096
00:46:28,339 --> 00:46:31,800
tended to absorb the blockchain data

1097
00:46:31,800 --> 00:46:33,060
into the computation of the proof

1098
00:46:33,060 --> 00:46:35,160
sequential work scheme now the labeling

1099
00:46:35,160 --> 00:46:37,800
the graph labeling we need to adapt it a

1100
00:46:37,800 --> 00:46:40,680
bit and we absorb the the blue data here

1101
00:46:40,680 --> 00:46:43,440
x I's which will be blockchain data that

1102
00:46:43,440 --> 00:46:45,240
I will show in a bit into the

1103
00:46:45,240 --> 00:46:48,420
computation of of the label of um of of

1104
00:46:48,420 --> 00:46:52,460
the vertex in a very simple way but now

1105
00:46:52,460 --> 00:46:54,660
the verifier in the previous slide

1106
00:46:54,660 --> 00:46:56,339
improved sequential scheme was verifying

1107
00:46:56,339 --> 00:46:58,619
the consistency of the opened path but

1108
00:46:58,619 --> 00:47:00,720
now we have an arbitrary data that we

1109
00:47:00,720 --> 00:47:02,780
need to be able to verify as consistency

1110
00:47:02,780 --> 00:47:06,900
and and we assume that this arbitrary

1111
00:47:06,900 --> 00:47:10,260
blue data can be verified for validity

1112
00:47:10,260 --> 00:47:14,220
by by a relation ARB PSI ARP PSI is is a

1113
00:47:14,220 --> 00:47:15,660
relation that comes with the blockchain

1114
00:47:15,660 --> 00:47:18,000
say you have the initial blockchain is a

1115
00:47:18,000 --> 00:47:21,119
proof of work blockchain and to verify

1116
00:47:21,119 --> 00:47:23,819
the validity of the eyes block or the

1117
00:47:23,819 --> 00:47:26,940
ice label you have a relation that tells

1118
00:47:26,940 --> 00:47:29,940
you okay given the level of Life block

1119
00:47:29,940 --> 00:47:31,980
and the level of the parent blocks you

1120
00:47:31,980 --> 00:47:34,319
should be able to verify whether this

1121
00:47:34,319 --> 00:47:35,819
block is valid or not say if it's a

1122
00:47:35,819 --> 00:47:37,440
proof of work you verify that the proof

1123
00:47:37,440 --> 00:47:38,760
of work is valid

1124
00:47:38,760 --> 00:47:42,119
okay very simple and with the notion of

1125
00:47:42,119 --> 00:47:44,579
valid labels you can define a valid path

1126
00:47:44,579 --> 00:47:48,660
uh a valid pass we call it Alpha are

1127
00:47:48,660 --> 00:47:50,880
valid if it's valid with respect to this

1128
00:47:50,880 --> 00:47:53,520
relation or and it has weight Alpha

1129
00:47:53,520 --> 00:47:56,700
small details for the definition and now

1130
00:47:56,700 --> 00:47:58,740
we're ready to Define snacks

1131
00:47:58,740 --> 00:48:01,500
and and the way I'm building it up is

1132
00:48:01,500 --> 00:48:03,300
that you see that a snack is essentially

1133
00:48:03,300 --> 00:48:04,680
a generalization of a proof of

1134
00:48:04,680 --> 00:48:07,200
sequential work scheme

1135
00:48:07,200 --> 00:48:08,700
um it is as we Define it not

1136
00:48:08,700 --> 00:48:11,220
interactively uh so there's a proof bias

1137
00:48:11,220 --> 00:48:13,079
and from the pro to the verifier and we

1138
00:48:13,079 --> 00:48:14,460
defined with respect to this witness

1139
00:48:14,460 --> 00:48:18,000
relation where the statement is a tuple

1140
00:48:18,000 --> 00:48:21,000
Phi n where Phi is a position binding

1141
00:48:21,000 --> 00:48:24,720
commitment to a chain of length n and

1142
00:48:24,720 --> 00:48:28,400
the the witness is an alpha R valid path

1143
00:48:28,400 --> 00:48:34,319
in in this graph and an opening uh of

1144
00:48:34,319 --> 00:48:36,300
this of the labels on this path with

1145
00:48:36,300 --> 00:48:38,339
respect to the commitment Phi

1146
00:48:38,339 --> 00:48:41,520
okay so this is the our witness relation

1147
00:48:41,520 --> 00:48:45,900
and completeness is what uh is that an

1148
00:48:45,900 --> 00:48:47,640
honest prover that has the labels of the

1149
00:48:47,640 --> 00:48:49,560
entirety of the blockchain for Alpha is

1150
00:48:49,560 --> 00:48:52,200
equal to one the path is full weight

1151
00:48:52,200 --> 00:48:55,380
we'll manage to convince the verifier

1152
00:48:55,380 --> 00:48:57,060
of course you can think of it as the

1153
00:48:57,060 --> 00:48:59,520
labeled blockchain or any any graph so

1154
00:48:59,520 --> 00:49:02,220
the blockchain is just an example of it

1155
00:49:02,220 --> 00:49:04,940
succinctness is what we expect

1156
00:49:04,940 --> 00:49:07,380
soundness is also what we expect but

1157
00:49:07,380 --> 00:49:09,300
here we would like to Define knowledge

1158
00:49:09,300 --> 00:49:11,099
soundness Alpha Epsilon knowledge

1159
00:49:11,099 --> 00:49:13,980
sinuses for for every convincing prover

1160
00:49:13,980 --> 00:49:17,880
we can extract a path in this relation

1161
00:49:17,880 --> 00:49:21,300
that is Alpha R valid with very high

1162
00:49:21,300 --> 00:49:23,460
probability 1 minus Epsilon

1163
00:49:23,460 --> 00:49:25,859
okay so here I'm giving an example again

1164
00:49:25,859 --> 00:49:28,380
the the blue thing is something that you

1165
00:49:28,380 --> 00:49:30,240
can extract

1166
00:49:30,240 --> 00:49:32,640
and I would highlight the extractability

1167
00:49:32,640 --> 00:49:34,859
guarantees are important because this

1168
00:49:34,859 --> 00:49:36,420
witness relation is polynomial time

1169
00:49:36,420 --> 00:49:41,040
relation so tip ordinary soundness would

1170
00:49:41,040 --> 00:49:43,859
would be vacuous we need to be able to

1171
00:49:43,859 --> 00:49:47,520
extract from any convincing approver

1172
00:49:47,520 --> 00:49:49,500
okay

1173
00:49:49,500 --> 00:49:51,660
um so now coming back to to the

1174
00:49:51,660 --> 00:49:53,760
construction so we had we started

1175
00:49:53,760 --> 00:49:56,099
remember the with a with a blockchain

1176
00:49:56,099 --> 00:49:58,260
that was simple and now we enriched it

1177
00:49:58,260 --> 00:50:02,060
we gave it this uh enrich Rich structure

1178
00:50:02,060 --> 00:50:04,740
uh inherited from the book of sequential

1179
00:50:04,740 --> 00:50:07,380
work scheme this is an example

1180
00:50:07,380 --> 00:50:10,260
and I wanted to show you how to do the

1181
00:50:10,260 --> 00:50:12,960
labeling or the augmented mining so

1182
00:50:12,960 --> 00:50:14,819
assume you're a miner and you want to to

1183
00:50:14,819 --> 00:50:18,720
mine the the fifth block given the the

1184
00:50:18,720 --> 00:50:21,720
blockchain so far and more important the

1185
00:50:21,720 --> 00:50:23,819
layers of the blockchain and the the

1186
00:50:23,819 --> 00:50:26,099
data the transactions that you need to

1187
00:50:26,099 --> 00:50:28,319
include in in your blog

1188
00:50:28,319 --> 00:50:33,060
so you want to compute G5 and H5 G will

1189
00:50:33,060 --> 00:50:36,599
be the will have two components L which

1190
00:50:36,599 --> 00:50:40,380
will be a hash of the parents and Phi

1191
00:50:40,380 --> 00:50:42,660
will be the commitment to the to the

1192
00:50:42,660 --> 00:50:46,619
blockchain so far including this hash

1193
00:50:46,619 --> 00:50:50,099
okay easy computation and then you need

1194
00:50:50,099 --> 00:50:51,720
to to do what the block original

1195
00:50:51,720 --> 00:50:53,940
blockchain wanted you to do generate a

1196
00:50:53,940 --> 00:50:55,800
publicly verifiable proof say in a proof

1197
00:50:55,800 --> 00:50:57,839
of work you need to generate a proof of

1198
00:50:57,839 --> 00:50:59,940
work that is valid in a proof of space

1199
00:50:59,940 --> 00:51:01,200
you need to generate a group of space

1200
00:51:01,200 --> 00:51:03,839
that is valid and so on and this is pi

1201
00:51:03,839 --> 00:51:06,119
and this is valid with respect to to our

1202
00:51:06,119 --> 00:51:07,079
website

1203
00:51:07,079 --> 00:51:09,240
once you have that you have your label

1204
00:51:09,240 --> 00:51:12,540
and you propose your new block okay

1205
00:51:12,540 --> 00:51:15,359
so I would like to say that in in the

1206
00:51:15,359 --> 00:51:16,800
efficient proof of sequential work

1207
00:51:16,800 --> 00:51:18,599
schemes that that you could potentially

1208
00:51:18,599 --> 00:51:21,540
use to realize the snack namely this

1209
00:51:21,540 --> 00:51:25,079
construction that I I show or the CP

1210
00:51:25,079 --> 00:51:26,300
Construction

1211
00:51:26,300 --> 00:51:30,359
you you you have the LI the hash of the

1212
00:51:30,359 --> 00:51:32,819
parents serve as the commitment so you

1213
00:51:32,819 --> 00:51:34,500
don't really need the extra commitment

1214
00:51:34,500 --> 00:51:36,480
part so this treatment is just generic

1215
00:51:36,480 --> 00:51:38,819
but in these particular schemes you

1216
00:51:38,819 --> 00:51:41,579
don't need an extra Phi I so the cost of

1217
00:51:41,579 --> 00:51:45,180
this augmentation is an extra hash value

1218
00:51:45,180 --> 00:51:46,859
in each block

1219
00:51:46,859 --> 00:51:49,740
if at the cost of this enrichment of the

1220
00:51:49,740 --> 00:51:51,900
structure of the blockchain and then

1221
00:51:51,900 --> 00:51:54,540
additional say 256 bits in each block

1222
00:51:54,540 --> 00:51:56,760
you will have a rich structure that

1223
00:51:56,760 --> 00:51:59,280
allows you to build proofs of of chain

1224
00:51:59,280 --> 00:52:00,420
knowledge

1225
00:52:00,420 --> 00:52:03,720
so the approver and verify as said

1226
00:52:03,720 --> 00:52:05,460
they're almost identical to the

1227
00:52:05,460 --> 00:52:06,839
underlying proof of sequential work

1228
00:52:06,839 --> 00:52:09,119
scheme proven verifier

1229
00:52:09,119 --> 00:52:11,880
except for a small change that one has

1230
00:52:11,880 --> 00:52:13,500
to be a bit careful with these extra

1231
00:52:13,500 --> 00:52:16,140
edges that kind of become part of the

1232
00:52:16,140 --> 00:52:17,940
proof of sequential work scheme graph

1233
00:52:17,940 --> 00:52:21,059
and they come from the blockchain they

1234
00:52:21,059 --> 00:52:23,640
may allow for shortcuts and to violate

1235
00:52:23,640 --> 00:52:25,500
soundness so one has to treat them

1236
00:52:25,500 --> 00:52:27,839
carefully and this can be done easily

1237
00:52:27,839 --> 00:52:29,880
and assembly this is the only small

1238
00:52:29,880 --> 00:52:32,700
change between the the snack proofer

1239
00:52:32,700 --> 00:52:34,740
verifier system and then and its

1240
00:52:34,740 --> 00:52:36,720
underlying improves equals our scheme

1241
00:52:36,720 --> 00:52:39,900
but this can be done and what we prove

1242
00:52:39,900 --> 00:52:41,760
is that if the underlying proof of

1243
00:52:41,760 --> 00:52:43,800
sequential work scheme is Alpha Epsilon

1244
00:52:43,800 --> 00:52:47,099
knowledge sound then so is the snack

1245
00:52:47,099 --> 00:52:49,680
and this is not by accident it's by

1246
00:52:49,680 --> 00:52:50,579
Design

1247
00:52:50,579 --> 00:52:53,339
and the security of our scheme is in the

1248
00:52:53,339 --> 00:52:55,559
random Oracle model we apply the Via

1249
00:52:55,559 --> 00:52:56,940
chamir to the interactive proof of

1250
00:52:56,940 --> 00:52:59,400
sequential work protocol and anyway the

1251
00:52:59,400 --> 00:53:01,200
graph labeling proofs equation by

1252
00:53:01,200 --> 00:53:03,000
schemes are also in the random Oracle so

1253
00:53:03,000 --> 00:53:05,880
there's no extra assumptions there

1254
00:53:05,880 --> 00:53:08,520
so this is me the the construction of

1255
00:53:08,520 --> 00:53:10,020
the snack and how we recommend the

1256
00:53:10,020 --> 00:53:11,880
blockchain

1257
00:53:11,880 --> 00:53:14,940
um and now we go back to essentially my

1258
00:53:14,940 --> 00:53:17,220
last two slides about how to solve

1259
00:53:17,220 --> 00:53:19,140
bootstrapping from this abstract object

1260
00:53:19,140 --> 00:53:21,300
so this object is an interesting on its

1261
00:53:21,300 --> 00:53:23,640
own and you can potentially use it in

1262
00:53:23,640 --> 00:53:25,559
other applications here is one

1263
00:53:25,559 --> 00:53:27,420
motivating applications that we wanted

1264
00:53:27,420 --> 00:53:28,800
to use

1265
00:53:28,800 --> 00:53:31,680
so here's where we started and now if

1266
00:53:31,680 --> 00:53:33,540
you have I'll show you how an

1267
00:53:33,540 --> 00:53:37,559
unexproofer generates a proof in the

1268
00:53:37,559 --> 00:53:39,300
bootstrapping protocol so here the

1269
00:53:39,300 --> 00:53:41,160
honest guy is the green guy

1270
00:53:41,160 --> 00:53:44,280
I think green bird so what it does it

1271
00:53:44,280 --> 00:53:46,680
looks at uh it has a blockchain of some

1272
00:53:46,680 --> 00:53:50,400
length and an eye it looks at the L

1273
00:53:50,400 --> 00:53:52,680
suffix of a blockchain l is a fixed

1274
00:53:52,680 --> 00:53:54,240
number that I will talk about in a bit

1275
00:53:54,240 --> 00:53:56,940
and it sends these L blocks in the clear

1276
00:53:56,940 --> 00:54:00,059
this is s i and for the rest of the

1277
00:54:00,059 --> 00:54:03,059
blockchain it generates a snack proof

1278
00:54:03,059 --> 00:54:05,339
okay so this is you know a blockchain

1279
00:54:05,339 --> 00:54:08,460
that is labeled like I I shot before and

1280
00:54:08,460 --> 00:54:10,800
you can generate a snack a proof for it

1281
00:54:10,800 --> 00:54:12,599
generically

1282
00:54:12,599 --> 00:54:15,900
and that will be uh the honest proof and

1283
00:54:15,900 --> 00:54:18,420
what does the verifier get from this

1284
00:54:18,420 --> 00:54:20,940
proof completeness says if at least one

1285
00:54:20,940 --> 00:54:24,720
of these provers is honest then the then

1286
00:54:24,720 --> 00:54:26,760
it will end up the verify will end up

1287
00:54:26,760 --> 00:54:28,380
outputting

1288
00:54:28,380 --> 00:54:30,780
a commitment to the honest L command

1289
00:54:30,780 --> 00:54:32,819
prefix of the blockchain

1290
00:54:32,819 --> 00:54:35,700
and L is is a number bigger than a fixed

1291
00:54:35,700 --> 00:54:38,700
number bigger than K Kappa where Kappa

1292
00:54:38,700 --> 00:54:41,700
is the K common prefix property of the

1293
00:54:41,700 --> 00:54:44,099
underlying Block Chain which we assume

1294
00:54:44,099 --> 00:54:46,079
that it's satisfied

1295
00:54:46,079 --> 00:54:48,720
how large is this ill and what what kind

1296
00:54:48,720 --> 00:54:51,359
of number is that so this comes from an

1297
00:54:51,359 --> 00:54:54,180
assumption uh that we make on the

1298
00:54:54,180 --> 00:54:56,579
adversary and adversary and its

1299
00:54:56,579 --> 00:54:58,440
computational power this assumption was

1300
00:54:58,440 --> 00:55:00,119
initially made by the flight land

1301
00:55:00,119 --> 00:55:02,099
protocol it's called the CL assumption

1302
00:55:02,099 --> 00:55:04,559
where you find it and adapt it to to our

1303
00:55:04,559 --> 00:55:07,559
work and it essentially says that an

1304
00:55:07,559 --> 00:55:10,319
adversary cannot create a fork of of

1305
00:55:10,319 --> 00:55:13,740
length L such that a c fraction of of

1306
00:55:13,740 --> 00:55:16,400
the fork is valid

1307
00:55:16,400 --> 00:55:17,940
so

1308
00:55:17,940 --> 00:55:20,880
um you can see if FC is one for example

1309
00:55:20,880 --> 00:55:23,460
this collapses to

1310
00:55:23,460 --> 00:55:26,040
um the L command prefix violation

1311
00:55:26,040 --> 00:55:29,640
assumption but the generality of this uh

1312
00:55:29,640 --> 00:55:31,740
the range of the parameters for which

1313
00:55:31,740 --> 00:55:33,599
this assumption holds is not really that

1314
00:55:33,599 --> 00:55:35,520
well understood and it's it's it will be

1315
00:55:35,520 --> 00:55:38,099
interesting to to analyze but with this

1316
00:55:38,099 --> 00:55:40,020
assumption and the guarantees that we

1317
00:55:40,020 --> 00:55:41,640
get from the proof of sequential work

1318
00:55:41,640 --> 00:55:44,579
scheme we get to the Crux of the

1319
00:55:44,579 --> 00:55:46,500
soundness guarantees that we have here

1320
00:55:46,500 --> 00:55:49,579
which as I promise they are

1321
00:55:49,579 --> 00:55:53,579
classical soundness guarantees and their

1322
00:55:53,579 --> 00:55:55,200
knowledge

1323
00:55:55,200 --> 00:55:57,480
in terms of Alpha Epsilon knowledge

1324
00:55:57,480 --> 00:56:00,599
soundness what it says is that from any

1325
00:56:00,599 --> 00:56:02,760
assume that all these provers that are

1326
00:56:02,760 --> 00:56:06,059
controlled by a malicious uh approver

1327
00:56:06,059 --> 00:56:09,059
um that is respecting the CL assumption

1328
00:56:09,059 --> 00:56:12,780
then from any verifying proof we can

1329
00:56:12,780 --> 00:56:16,140
extract a path that is uh that is of

1330
00:56:16,140 --> 00:56:18,359
weight alpha alpha in here

1331
00:56:18,359 --> 00:56:20,760
and this Alpha depends I'm just showing

1332
00:56:20,760 --> 00:56:21,960
the formula without needing to

1333
00:56:21,960 --> 00:56:25,260
discussing it here it depends on N the

1334
00:56:25,260 --> 00:56:27,300
the length of the blockchain depends on

1335
00:56:27,300 --> 00:56:30,240
the C and L from the CL assumption

1336
00:56:30,240 --> 00:56:32,400
we can extract such a path except with

1337
00:56:32,400 --> 00:56:34,920
probability Epsilon

1338
00:56:34,920 --> 00:56:38,579
um and of course the closer Alpha to one

1339
00:56:38,579 --> 00:56:40,200
the better you can if somebody is

1340
00:56:40,200 --> 00:56:41,700
claiming that they know the entirety of

1341
00:56:41,700 --> 00:56:43,200
blockchain then you can extract the

1342
00:56:43,200 --> 00:56:45,480
entirety of the blockchain but you can

1343
00:56:45,480 --> 00:56:48,380
probably afford uh

1344
00:56:48,380 --> 00:56:50,940
extracting 95 percent or whatever the

1345
00:56:50,940 --> 00:56:52,440
number is that you you need to plug in

1346
00:56:52,440 --> 00:56:54,780
it here and the larger Alpha is the

1347
00:56:54,780 --> 00:56:57,900
stronger the CL assumption should become

1348
00:56:57,900 --> 00:57:00,599
uh so these guarantees are essentially

1349
00:57:00,599 --> 00:57:02,520
almost as possible their extractability

1350
00:57:02,520 --> 00:57:05,040
guarantees except that Alpha is not one

1351
00:57:05,040 --> 00:57:07,380
but it's close to one and this is

1352
00:57:07,380 --> 00:57:09,240
actually what allows us to have a much

1353
00:57:09,240 --> 00:57:11,420
more efficient construction than than

1354
00:57:11,420 --> 00:57:14,099
snarks the proofers are sub-linear they

1355
00:57:14,099 --> 00:57:16,800
do just look up lookup table

1356
00:57:16,800 --> 00:57:19,380
and finally I would like to say that the

1357
00:57:19,380 --> 00:57:21,359
guarantees of the snack system are

1358
00:57:21,359 --> 00:57:23,700
extraction guarantees correct but what

1359
00:57:23,700 --> 00:57:25,619
do they say how meaningful they are in

1360
00:57:25,619 --> 00:57:28,020
different blockchains if the blockchain

1361
00:57:28,020 --> 00:57:30,839
is moderately hard to mine then these

1362
00:57:30,839 --> 00:57:32,640
guarantees are meaningful saying in a

1363
00:57:32,640 --> 00:57:34,380
proof of work blockchain where

1364
00:57:34,380 --> 00:57:38,700
generating a sequence of blocks a long

1365
00:57:38,700 --> 00:57:40,559
sequence of blocks that are computed

1366
00:57:40,559 --> 00:57:42,660
sequentially and have valid proof of

1367
00:57:42,660 --> 00:57:44,819
work is a heavy computation and it's a

1368
00:57:44,819 --> 00:57:47,339
heavy price to to pay if you want to

1369
00:57:47,339 --> 00:57:50,520
cheat a verifier and this is uh so this

1370
00:57:50,520 --> 00:57:51,660
is kind of

1371
00:57:51,660 --> 00:57:54,960
because has value and me and meaning but

1372
00:57:54,960 --> 00:57:57,300
if your blockchain is proof of stake

1373
00:57:57,300 --> 00:57:59,819
then it's not clear if if the snack

1374
00:57:59,819 --> 00:58:01,440
system that we develop although it

1375
00:58:01,440 --> 00:58:03,180
applies for it you can the construction

1376
00:58:03,180 --> 00:58:05,400
does not care about the underlying group

1377
00:58:05,400 --> 00:58:07,619
Channel what it is as long as it has

1378
00:58:07,619 --> 00:58:09,660
a witness relation that verifies

1379
00:58:09,660 --> 00:58:12,119
validity in polynomial time it applies

1380
00:58:12,119 --> 00:58:14,099
but the guarantee is I don't see that

1381
00:58:14,099 --> 00:58:15,660
they have any meaningful guarantees for

1382
00:58:15,660 --> 00:58:18,059
say proof of Stack blockchain

1383
00:58:18,059 --> 00:58:20,400
so with this I thank you very much and I

1384
00:58:20,400 --> 00:58:21,540
will be happy to take some questions

1385
00:58:21,540 --> 00:58:24,359
thank you

1386
00:58:24,359 --> 00:58:27,020
foreign

1387
00:58:29,880 --> 00:58:32,400
thanks a lot and yeah we have time for

1388
00:58:32,400 --> 00:58:34,700
questions

1389
00:58:38,900 --> 00:58:41,280
uh okay

1390
00:58:41,280 --> 00:58:43,559
like uh again there's no questions from

1391
00:58:43,559 --> 00:58:45,180
before

1392
00:58:45,180 --> 00:58:49,680
um so uh that was our last speaker so

1393
00:58:49,680 --> 00:58:53,700
um we will uh conclude there the uh next

1394
00:58:53,700 --> 00:58:55,859
session started about 10 minutes so it's

1395
00:58:55,859 --> 00:58:59,040
I guess not a full break

1396
00:58:59,040 --> 00:58:59,819
um

1397
00:58:59,819 --> 00:59:01,619
and if you

1398
00:59:01,619 --> 00:59:04,140
let's see so if you stay here there's a

1399
00:59:04,140 --> 00:59:06,240
session on allomorphic encryption and

1400
00:59:06,240 --> 00:59:07,799
proofs and snarks is in the other

1401
00:59:07,799 --> 00:59:10,880
Ballroom thanks a lot

