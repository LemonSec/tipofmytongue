1
00:01:42,600 --> 00:01:45,380
thank you

2
00:02:25,319 --> 00:02:26,879
foreign

3
00:02:26,879 --> 00:02:29,480
okay

4
00:04:10,500 --> 00:04:13,500
foreign

5
00:04:29,280 --> 00:04:31,820
foreign

6
00:04:47,280 --> 00:04:50,369
[Music]

7
00:04:51,860 --> 00:04:54,900
extractors in a plane model uh by Daniel

8
00:04:54,900 --> 00:04:56,720
Apen

9
00:04:56,720 --> 00:04:59,699
Peter Holland

10
00:04:59,699 --> 00:05:02,040
and Peter will give the talk

11
00:05:02,040 --> 00:05:04,380
all right hello thank you all uh thank

12
00:05:04,380 --> 00:05:06,419
you for coming to the last session uh

13
00:05:06,419 --> 00:05:08,699
let's jump right into it but before we

14
00:05:08,699 --> 00:05:10,979
can talk about digital lockers and fuzzy

15
00:05:10,979 --> 00:05:13,560
extractors uh I first want to talk about

16
00:05:13,560 --> 00:05:16,620
the random Oracle model of brief bit so

17
00:05:16,620 --> 00:05:19,139
as far you are all probably somewhat

18
00:05:19,139 --> 00:05:24,180
aware uh RAM Oracle is a beloved model

19
00:05:24,180 --> 00:05:28,440
used by all sorts of uh proofs and

20
00:05:28,440 --> 00:05:30,900
constructions all around

21
00:05:30,900 --> 00:05:34,380
um the problem though is that it is uh

22
00:05:34,380 --> 00:05:37,199
unsustainable in general they're uh

23
00:05:37,199 --> 00:05:39,479
unsaturated results

24
00:05:39,479 --> 00:05:41,580
um the most common way around this is to

25
00:05:41,580 --> 00:05:43,680
just replace the random Oracle with uh

26
00:05:43,680 --> 00:05:46,560
heuristic hash function but we want

27
00:05:46,560 --> 00:05:48,960
provable security perhaps and so the

28
00:05:48,960 --> 00:05:52,080
idea kind of motivating this talk uh is

29
00:05:52,080 --> 00:05:53,759
really that if we isolate certain

30
00:05:53,759 --> 00:05:56,100
properties of the random Oracle that we

31
00:05:56,100 --> 00:05:59,160
need for our application then we may be

32
00:05:59,160 --> 00:06:01,620
able to kind of get provable security by

33
00:06:01,620 --> 00:06:04,740
focusing on only realizing these and in

34
00:06:04,740 --> 00:06:06,479
particular in this work we're going to

35
00:06:06,479 --> 00:06:09,000
focus on realizing Oracle hashing and

36
00:06:09,000 --> 00:06:10,919
non-maleability

37
00:06:10,919 --> 00:06:13,199
so first of all Oracle hashing also

38
00:06:13,199 --> 00:06:15,960
known as Point function obfuscation is

39
00:06:15,960 --> 00:06:17,520
essentially obfuscating the point

40
00:06:17,520 --> 00:06:21,020
function you see on here uh it is

41
00:06:21,020 --> 00:06:24,000
initialized with some value vowel and

42
00:06:24,000 --> 00:06:25,560
then on use with some value vowel Prime

43
00:06:25,560 --> 00:06:27,180
should output one and if and only if

44
00:06:27,180 --> 00:06:29,240
those are equal

45
00:06:29,240 --> 00:06:32,160
uh obfuscation should hide everything

46
00:06:32,160 --> 00:06:34,560
about this function except for its input

47
00:06:34,560 --> 00:06:36,479
output behavior and this work we're

48
00:06:36,479 --> 00:06:38,520
specifically considering vbb obfuscation

49
00:06:38,520 --> 00:06:40,919
so essentially the simulator based

50
00:06:40,919 --> 00:06:44,039
definition here where uh the simulator

51
00:06:44,039 --> 00:06:46,080
will perform almost as well with only

52
00:06:46,080 --> 00:06:50,100
Oracle access to the point function

53
00:06:50,100 --> 00:06:54,000
now uh Point function obfuscation has

54
00:06:54,000 --> 00:06:56,580
been known for a long long time but we

55
00:06:56,580 --> 00:06:59,639
wanted an additional property here uh

56
00:06:59,639 --> 00:07:01,440
and that is to kind of protect against

57
00:07:01,440 --> 00:07:04,380
the following attack uh in particular an

58
00:07:04,380 --> 00:07:06,300
adversary might be given an obfuscation

59
00:07:06,300 --> 00:07:08,340
of some point though and might be able

60
00:07:08,340 --> 00:07:10,139
to kind of obliviously tamper it to an

61
00:07:10,139 --> 00:07:13,979
obfuscation of some function of Val

62
00:07:13,979 --> 00:07:15,180
um preventing this is called

63
00:07:15,180 --> 00:07:18,419
non-maleability however uh while

64
00:07:18,419 --> 00:07:20,759
defining kind of preventing and related

65
00:07:20,759 --> 00:07:23,280
can make a lot of sense with some sort

66
00:07:23,280 --> 00:07:25,680
of trusted setup it can be less clear to

67
00:07:25,680 --> 00:07:28,139
Define in the plane model and so I'll

68
00:07:28,139 --> 00:07:30,000
get back to this later but put a pin in

69
00:07:30,000 --> 00:07:31,639
that for now

70
00:07:31,639 --> 00:07:35,400
uh additionally uh well one day output

71
00:07:35,400 --> 00:07:37,979
is all fine and good we might want some

72
00:07:37,979 --> 00:07:39,900
sort of multi-bit output notion so

73
00:07:39,900 --> 00:07:42,000
instead of outputting a one or a zero if

74
00:07:42,000 --> 00:07:45,000
we either output the full key uh or no

75
00:07:45,000 --> 00:07:46,919
information on it

76
00:07:46,919 --> 00:07:49,860
this is called the digital Locker or a

77
00:07:49,860 --> 00:07:51,419
non-magual point obfuscation with

78
00:07:51,419 --> 00:07:53,039
multi-bit output

79
00:07:53,039 --> 00:07:55,620
uh digital lockers are very useful in

80
00:07:55,620 --> 00:07:58,020
their own right uh in this work we're

81
00:07:58,020 --> 00:08:00,180
going to consider one application of

82
00:08:00,180 --> 00:08:02,819
digital lockers and that is

83
00:08:02,819 --> 00:08:07,740
fuzzy extractors uh fuzzy extractors uh

84
00:08:07,740 --> 00:08:10,259
are a tuple of algorithms here uh gen

85
00:08:10,259 --> 00:08:11,699
and rep

86
00:08:11,699 --> 00:08:14,520
um Jen takes in some sort of noisy

87
00:08:14,520 --> 00:08:18,000
secret and outputs some random value and

88
00:08:18,000 --> 00:08:20,759
a public helper string and then later on

89
00:08:20,759 --> 00:08:23,639
if you want to reproduce that random

90
00:08:23,639 --> 00:08:25,680
value you can use the public helper

91
00:08:25,680 --> 00:08:27,780
string along with another reading in

92
00:08:27,780 --> 00:08:30,720
particular this reading can be noisy as

93
00:08:30,720 --> 00:08:32,279
long as it's within a certain distance

94
00:08:32,279 --> 00:08:35,339
from the original enrollment this is

95
00:08:35,339 --> 00:08:37,380
useful in for example Biometrics which

96
00:08:37,380 --> 00:08:39,679
is why we have irises here

97
00:08:39,679 --> 00:08:42,839
additionally uh fairly straightforwardly

98
00:08:42,839 --> 00:08:45,000
we don't want anything that's far from

99
00:08:45,000 --> 00:08:47,040
the original enrollment to Output any

100
00:08:47,040 --> 00:08:49,320
information on kind of this random value

101
00:08:49,320 --> 00:08:50,820
r

102
00:08:50,820 --> 00:08:53,839
robustness is an additional guarantee

103
00:08:53,839 --> 00:08:56,940
which uh essentially says that it should

104
00:08:56,940 --> 00:09:00,480
be hard for an adversary to take Pub and

105
00:09:00,480 --> 00:09:03,060
output some Pub Prime such that Pub

106
00:09:03,060 --> 00:09:05,640
Prime now reproduces to a new value R

107
00:09:05,640 --> 00:09:07,740
Prime

108
00:09:07,740 --> 00:09:09,720
um and this it's considered a break to

109
00:09:09,720 --> 00:09:12,420
robustness if it's on kind of the exact

110
00:09:12,420 --> 00:09:15,360
same uh distribution or if it's on maybe

111
00:09:15,360 --> 00:09:18,060
a related one uh and so we want to

112
00:09:18,060 --> 00:09:20,040
prevent this as well as you can see

113
00:09:20,040 --> 00:09:21,480
there might be some connections to

114
00:09:21,480 --> 00:09:24,060
non-alleability but we will get back to

115
00:09:24,060 --> 00:09:26,760
that in a moment uh for now I want to

116
00:09:26,760 --> 00:09:29,220
mention the robust fizzy extractors have

117
00:09:29,220 --> 00:09:30,839
been studied for quite a long while

118
00:09:30,839 --> 00:09:33,899
there's a large body of work on them and

119
00:09:33,899 --> 00:09:35,880
while really good constructions are

120
00:09:35,880 --> 00:09:37,260
known in the random Oracle and the

121
00:09:37,260 --> 00:09:40,019
common reference string model uh

122
00:09:40,019 --> 00:09:42,600
uh there's been a long-standing barrier

123
00:09:42,600 --> 00:09:44,880
for plain model constructions namely

124
00:09:44,880 --> 00:09:47,339
non-existing ones in the literature can

125
00:09:47,339 --> 00:09:49,680
handle input sources with entropy less

126
00:09:49,680 --> 00:09:52,140
than half their length so so lower

127
00:09:52,140 --> 00:09:54,360
entropy is very hard for these fuzzy

128
00:09:54,360 --> 00:09:55,680
extractors

129
00:09:55,680 --> 00:09:57,899
in this work we overcome this with

130
00:09:57,899 --> 00:10:00,600
actually two separate constructions uh

131
00:10:00,600 --> 00:10:02,399
that achieve this property

132
00:10:02,399 --> 00:10:05,940
So the plan for this oh it's an old

133
00:10:05,940 --> 00:10:08,880
version the plan for this uh

134
00:10:08,880 --> 00:10:10,980
construction here I just want to skip to

135
00:10:10,980 --> 00:10:13,580
the end is essentially we will be

136
00:10:13,580 --> 00:10:15,899
constructing these non-miable point

137
00:10:15,899 --> 00:10:18,120
obfuscations in particular we'll Define

138
00:10:18,120 --> 00:10:21,120
a new object with Associated data we'll

139
00:10:21,120 --> 00:10:23,940
show their composability uh in order to

140
00:10:23,940 --> 00:10:25,680
form a whole non-malleable digital

141
00:10:25,680 --> 00:10:27,779
locker and then we'll use that alongside

142
00:10:27,779 --> 00:10:30,420
A syndrome secure sketch to build our

143
00:10:30,420 --> 00:10:33,060
better robust fuzzy extractors

144
00:10:33,060 --> 00:10:36,180
so of course to start this off let's go

145
00:10:36,180 --> 00:10:39,000
into non-maleable digital lockers

146
00:10:39,000 --> 00:10:41,399
uh before we get to that as I mentioned

147
00:10:41,399 --> 00:10:43,200
we're going to construct these digital

148
00:10:43,200 --> 00:10:45,540
lockers from point obfuscations so it's

149
00:10:45,540 --> 00:10:46,980
helpful to talk about them for a little

150
00:10:46,980 --> 00:10:48,120
bit first

151
00:10:48,120 --> 00:10:50,820
uh non-maluable Point obfuscation in the

152
00:10:50,820 --> 00:10:53,279
plane model was first studied by

153
00:10:53,279 --> 00:10:56,279
komagotsky and yoga in 2018 and there

154
00:10:56,279 --> 00:10:58,200
they presented this definition of non

155
00:10:58,200 --> 00:11:00,480
malleability which is a little

156
00:11:00,480 --> 00:11:03,000
non-standard essentially given an

157
00:11:03,000 --> 00:11:05,700
obfuscation of some point x the

158
00:11:05,700 --> 00:11:07,500
challenge or the goal of the adversary

159
00:11:07,500 --> 00:11:10,040
is to Output some obfuscation of f of x

160
00:11:10,040 --> 00:11:12,240
alongside outputting the specific

161
00:11:12,240 --> 00:11:14,220
tampering function that they are

162
00:11:14,220 --> 00:11:18,180
tampering to in particular we will uh

163
00:11:18,180 --> 00:11:20,700
parametrize this by having our function

164
00:11:20,700 --> 00:11:23,519
be from some function family in this

165
00:11:23,519 --> 00:11:25,320
work in all prior works this function

166
00:11:25,320 --> 00:11:28,200
family has been low degree polynomials

167
00:11:28,200 --> 00:11:31,440
now this is a huge limitation here uh

168
00:11:31,440 --> 00:11:34,740
but as we see that in the play model not

169
00:11:34,740 --> 00:11:36,420
having this leads to some kind of easy

170
00:11:36,420 --> 00:11:40,860
attacks namely an adversary who doesn't

171
00:11:40,860 --> 00:11:42,420
have to Output the tampering function

172
00:11:42,420 --> 00:11:44,700
could easily just take a new random

173
00:11:44,700 --> 00:11:48,420
string and try to pass it off uh as an

174
00:11:48,420 --> 00:11:51,839
obfuscation of kind of a related one and

175
00:11:51,839 --> 00:11:54,060
in fact this is related by some linear

176
00:11:54,060 --> 00:11:56,459
function to the original point it's just

177
00:11:56,459 --> 00:11:58,519
that the adversary doesn't know it

178
00:11:58,519 --> 00:12:01,079
however in the play model if they don't

179
00:12:01,079 --> 00:12:02,459
have to prove that they do know it

180
00:12:02,459 --> 00:12:05,760
somehow then uh there's not much we can

181
00:12:05,760 --> 00:12:08,880
do against an attack like this and so we

182
00:12:08,880 --> 00:12:11,339
use this version where they output the

183
00:12:11,339 --> 00:12:12,720
tampering function but as we'll see

184
00:12:12,720 --> 00:12:14,820
later they can get around this in some

185
00:12:14,820 --> 00:12:16,380
ways we can get around this in our

186
00:12:16,380 --> 00:12:18,560
design

187
00:12:20,160 --> 00:12:22,620
here we go uh

188
00:12:22,620 --> 00:12:25,560
uh to get to multi-bit Output uh the

189
00:12:25,560 --> 00:12:27,480
common method is to kind of use this

190
00:12:27,480 --> 00:12:29,880
real or random composition of point

191
00:12:29,880 --> 00:12:32,760
obfuscations to digital lockers uh

192
00:12:32,760 --> 00:12:34,380
namely for each kind of bit of our

193
00:12:34,380 --> 00:12:36,600
output key we're going to either

194
00:12:36,600 --> 00:12:39,899
obfuscate the real value vowel if the

195
00:12:39,899 --> 00:12:42,779
key bit is one and some random junk R

196
00:12:42,779 --> 00:12:46,800
otherwise now uh of course you know

197
00:12:46,800 --> 00:12:49,200
given when they try and reconstruct with

198
00:12:49,200 --> 00:12:51,600
Val Prime equals Val they'll get one on

199
00:12:51,600 --> 00:12:53,820
all of the obfuscation of vowels and

200
00:12:53,820 --> 00:12:56,220
zero and all the obfuscation of ours and

201
00:12:56,220 --> 00:12:59,220
so in fact our digital Locker will let

202
00:12:59,220 --> 00:13:00,779
us reconstruct the key bit by bit

203
00:13:00,779 --> 00:13:02,519
essentially

204
00:13:02,519 --> 00:13:05,760
however this requires two important

205
00:13:05,760 --> 00:13:07,200
things first we need some sort of

206
00:13:07,200 --> 00:13:08,940
composability for our Point function

207
00:13:08,940 --> 00:13:11,100
obfuscations this isn't trivial and in

208
00:13:11,100 --> 00:13:12,959
fact is not true in many constructions

209
00:13:12,959 --> 00:13:15,480
uh We additionally need some way to

210
00:13:15,480 --> 00:13:19,019
protect the key from any tampering uh

211
00:13:19,019 --> 00:13:21,079
previous work by myself and a co-author

212
00:13:21,079 --> 00:13:24,720
required a CRS to achieve keynote

213
00:13:24,720 --> 00:13:26,579
malleability and so really one of the

214
00:13:26,579 --> 00:13:29,040
motivations for uh the way we approach

215
00:13:29,040 --> 00:13:31,920
this problem this time was to see how we

216
00:13:31,920 --> 00:13:34,680
could remove the CRS to kind of pull the

217
00:13:34,680 --> 00:13:37,920
digital lockers into the plane model

218
00:13:37,920 --> 00:13:40,800
and so to that we Define this new

219
00:13:40,800 --> 00:13:43,019
primitive here called non-maluable Point

220
00:13:43,019 --> 00:13:46,139
obfuscation with Associated data the key

221
00:13:46,139 --> 00:13:48,899
thing about this uh construction or I

222
00:13:48,899 --> 00:13:51,600
mean this definition is that not only do

223
00:13:51,600 --> 00:13:53,459
we have kind of this obfuscation that we

224
00:13:53,459 --> 00:13:57,120
call lock point and unlock Point uh not

225
00:13:57,120 --> 00:13:58,680
only do we have kind of an obfuscation

226
00:13:58,680 --> 00:14:01,019
of our Point function but we also

227
00:14:01,019 --> 00:14:03,540
include this Associated data now this

228
00:14:03,540 --> 00:14:05,639
Associated data is completely public

229
00:14:05,639 --> 00:14:08,040
it's known to all users but what we're

230
00:14:08,040 --> 00:14:09,540
going to want is we're going to want

231
00:14:09,540 --> 00:14:12,480
some sort of tamper-proof quality on it

232
00:14:12,480 --> 00:14:14,899
as well

233
00:14:15,120 --> 00:14:17,579
um and so you know we take in some

234
00:14:17,579 --> 00:14:20,519
underlying Point function Bell and some

235
00:14:20,519 --> 00:14:23,040
Associated data which is just a row bit

236
00:14:23,040 --> 00:14:24,980
long string

237
00:14:24,980 --> 00:14:27,480
completeness says that we want it to

238
00:14:27,480 --> 00:14:30,899
function the same as kind of this uh

239
00:14:30,899 --> 00:14:34,920
ideal functionality on most inputs

240
00:14:34,920 --> 00:14:37,079
virtual Black Box security is as we

241
00:14:37,079 --> 00:14:38,940
stated before I won't get into it in

242
00:14:38,940 --> 00:14:40,139
this talk much

243
00:14:40,139 --> 00:14:43,320
and non-maluability uh is what I want to

244
00:14:43,320 --> 00:14:44,639
focus most of my time on for this

245
00:14:44,639 --> 00:14:45,600
definition

246
00:14:45,600 --> 00:14:49,560
so not malleability here is we note that

247
00:14:49,560 --> 00:14:51,839
we have two kind of attacks here first

248
00:14:51,839 --> 00:14:55,620
the adversary could output some uh

249
00:14:55,620 --> 00:14:58,860
obfuscation of f of x for f being some

250
00:14:58,860 --> 00:15:01,440
function in our tampering family

251
00:15:01,440 --> 00:15:04,440
but also the adversary can win if they

252
00:15:04,440 --> 00:15:06,899
tamper the associated data to some other

253
00:15:06,899 --> 00:15:09,300
Associated data ad Prime

254
00:15:09,300 --> 00:15:12,300
and so in this definition we really have

255
00:15:12,300 --> 00:15:14,699
to consider that the adversary succeeds

256
00:15:14,699 --> 00:15:17,339
if they can tamper either X to some f of

257
00:15:17,339 --> 00:15:19,980
x or they can tamper the associated data

258
00:15:19,980 --> 00:15:23,220
to some new Associated data and we also

259
00:15:23,220 --> 00:15:24,300
have to consider you know if they could

260
00:15:24,300 --> 00:15:26,339
do both

261
00:15:26,339 --> 00:15:29,100
so I want to get into our construction

262
00:15:29,100 --> 00:15:31,560
for this now but before that I want to

263
00:15:31,560 --> 00:15:33,420
make a quick mention on the Assumption

264
00:15:33,420 --> 00:15:36,839
oh old version on the assumption that we

265
00:15:36,839 --> 00:15:38,600
are going to use

266
00:15:38,600 --> 00:15:43,320
uh so barter secondary in 2019 uh

267
00:15:43,320 --> 00:15:45,180
studied kind of these fixed generator

268
00:15:45,180 --> 00:15:47,279
assumptions in the generic group model

269
00:15:47,279 --> 00:15:50,279
and they introduced these uh two

270
00:15:50,279 --> 00:15:51,899
assumptions here the second one implied

271
00:15:51,899 --> 00:15:54,360
by the first uh

272
00:15:54,360 --> 00:15:56,220
I'm going to focus on the first switch

273
00:15:56,220 --> 00:16:00,120
has an unfortunate little typo there uh

274
00:16:00,120 --> 00:16:03,540
in particular uh we are given kind of

275
00:16:03,540 --> 00:16:07,560
this Ensemble of Ki G to the k i x plus

276
00:16:07,560 --> 00:16:10,740
X the I where Ki are all just some

277
00:16:10,740 --> 00:16:14,760
random values and uh X is some kind of

278
00:16:14,760 --> 00:16:16,620
well spread there's some point taken

279
00:16:16,620 --> 00:16:18,899
from a well spread distribution

280
00:16:18,899 --> 00:16:20,339
um so essentially we have these kind of

281
00:16:20,339 --> 00:16:24,360
like increasing powers of X that are all

282
00:16:24,360 --> 00:16:27,000
kind of blinded by these random terms in

283
00:16:27,000 --> 00:16:29,760
particular they will also get uh you

284
00:16:29,760 --> 00:16:32,220
know given these Ki and what the

285
00:16:32,220 --> 00:16:34,139
Assumption says is that it's hard for an

286
00:16:34,139 --> 00:16:36,959
adversary to receive G to the X from

287
00:16:36,959 --> 00:16:38,940
that again there should be a little X up

288
00:16:38,940 --> 00:16:41,040
there but essentially it's hard for them

289
00:16:41,040 --> 00:16:43,199
to kind of extract just like the linear

290
00:16:43,199 --> 00:16:46,259
term in in isolation

291
00:16:46,259 --> 00:16:49,019
so given this I will now kind of present

292
00:16:49,019 --> 00:16:52,220
our Construction

293
00:16:53,339 --> 00:16:56,000
there we go

294
00:16:56,040 --> 00:16:59,300
it's not updating on there

295
00:17:00,360 --> 00:17:02,279
I think there's a slight issue oh there

296
00:17:02,279 --> 00:17:05,339
we go okay so uh our construction

297
00:17:05,339 --> 00:17:08,280
requires us to First sample some random

298
00:17:08,280 --> 00:17:10,619
values C1 through C5

299
00:17:10,619 --> 00:17:12,660
then we are going to form these

300
00:17:12,660 --> 00:17:14,760
polynomials you don't have to care too

301
00:17:14,760 --> 00:17:17,119
too much about them they are color coded

302
00:17:17,119 --> 00:17:21,299
uh the blue values here are all for our

303
00:17:21,299 --> 00:17:24,480
vbb security the magenta terms are

304
00:17:24,480 --> 00:17:26,520
actually all for correctness in

305
00:17:26,520 --> 00:17:28,199
particular our second through fifth

306
00:17:28,199 --> 00:17:30,480
polynomial are only used to prove

307
00:17:30,480 --> 00:17:32,520
correctness they don't benefit us for

308
00:17:32,520 --> 00:17:35,160
non-malleability or virtual Black Box

309
00:17:35,160 --> 00:17:38,340
and the orange term up here is for our

310
00:17:38,340 --> 00:17:40,260
Associated data Nom malleability and

311
00:17:40,260 --> 00:17:42,900
finally the olive term over here is for

312
00:17:42,900 --> 00:17:44,580
our underlying kind of vowel

313
00:17:44,580 --> 00:17:46,020
non-malleability

314
00:17:46,020 --> 00:17:48,480
so we have all these different powers

315
00:17:48,480 --> 00:17:52,860
here uh we're going to essentially

316
00:17:52,860 --> 00:17:56,220
put them all in the exponent of this

317
00:17:56,220 --> 00:17:57,900
fixed generator G

318
00:17:57,900 --> 00:17:59,700
and that's going to be our construction

319
00:17:59,700 --> 00:18:02,340
giving the C1 through C5

320
00:18:02,340 --> 00:18:03,720
um in addition

321
00:18:03,720 --> 00:18:05,700
it should hopefully be somewhat clear

322
00:18:05,700 --> 00:18:09,120
how to construct this from these Ki G to

323
00:18:09,120 --> 00:18:12,600
the k i x plus x to the I but we won't

324
00:18:12,600 --> 00:18:15,480
get into it in this

325
00:18:15,480 --> 00:18:18,799
what we will do

326
00:18:20,880 --> 00:18:24,720
well we will focus on instead is uh our

327
00:18:24,720 --> 00:18:28,200
non-malleability proof here so uh as a

328
00:18:28,200 --> 00:18:30,600
reminder our non-malleability

329
00:18:30,600 --> 00:18:33,480
requirement is that we want to be

330
00:18:33,480 --> 00:18:35,520
non-malieable against adversaries that

331
00:18:35,520 --> 00:18:38,059
either output F in some function family

332
00:18:38,059 --> 00:18:41,820
or they Maul the associated data and let

333
00:18:41,820 --> 00:18:44,640
the function f be the identity

334
00:18:44,640 --> 00:18:47,280
so the way that we approach this is we

335
00:18:47,280 --> 00:18:50,340
have uh two kind of lemmas here the

336
00:18:50,340 --> 00:18:52,919
first one being this obfuscation

337
00:18:52,919 --> 00:18:56,400
parametrized by a polynomial where we

338
00:18:56,400 --> 00:18:59,580
show that it is hard to Maul obfuscation

339
00:18:59,580 --> 00:19:03,360
except P of x to any obfuscation P Prime

340
00:19:03,360 --> 00:19:04,740
of f of x

341
00:19:04,740 --> 00:19:06,960
essentially even if you can change this

342
00:19:06,960 --> 00:19:09,240
polynomial arbitrarily it should be hard

343
00:19:09,240 --> 00:19:13,160
to Tamper X to f of x

344
00:19:13,200 --> 00:19:17,280
then we will restrict the associate the

345
00:19:17,280 --> 00:19:21,120
polynomial to be binary vectors uh

346
00:19:21,120 --> 00:19:22,620
thereby making it this kind of

347
00:19:22,620 --> 00:19:25,260
associated data and we will assume that

348
00:19:25,260 --> 00:19:27,539
X is not tampered with and we'll show

349
00:19:27,539 --> 00:19:28,980
that it's hard to Tamper from

350
00:19:28,980 --> 00:19:32,280
obfuscation sub a d of x to obfuscation

351
00:19:32,280 --> 00:19:35,100
of 80 Prime for any 80 Prime not equal

352
00:19:35,100 --> 00:19:37,760
to 80.

353
00:19:39,140 --> 00:19:42,900
uh Lemma 4.3 the first one with the

354
00:19:42,900 --> 00:19:45,480
polynomials is fairly similar to our

355
00:19:45,480 --> 00:19:48,900
previous work uh it's a little more

356
00:19:48,900 --> 00:19:52,380
technical uh but the kind of key idea

357
00:19:52,380 --> 00:19:54,840
here is that we'll show that any

358
00:19:54,840 --> 00:19:58,080
obfuscation of f of x is either going to

359
00:19:58,080 --> 00:20:01,320
let you recover G to the x or it's going

360
00:20:01,320 --> 00:20:04,740
to let you uh find some let the

361
00:20:04,740 --> 00:20:06,299
adversary find something outside of the

362
00:20:06,299 --> 00:20:08,840
span of the elements it's given

363
00:20:08,840 --> 00:20:10,820
essentially

364
00:20:10,820 --> 00:20:13,740
uh in our reduction it's hard for them

365
00:20:13,740 --> 00:20:15,720
to find uh that

366
00:20:15,720 --> 00:20:19,440
Lemma 4.5 on the other hand ensures uh

367
00:20:19,440 --> 00:20:22,380
that any mulling of associated data are

368
00:20:22,380 --> 00:20:24,660
hard to reach for that I want to touch a

369
00:20:24,660 --> 00:20:27,120
little bit on uh

370
00:20:27,120 --> 00:20:29,280
because it's a little more new and

371
00:20:29,280 --> 00:20:32,880
interesting so as a reminder uh in our

372
00:20:32,880 --> 00:20:35,160
reduction our adversary will be given an

373
00:20:35,160 --> 00:20:37,799
obfuscation of X and it'll mull to an

374
00:20:37,799 --> 00:20:43,200
obfuscation of X with the new ad Prime

375
00:20:43,200 --> 00:20:46,140
in particular this new Associated data

376
00:20:46,140 --> 00:20:48,720
will have to differ from this from the

377
00:20:48,720 --> 00:20:51,179
original by at least one bit

378
00:20:51,179 --> 00:20:53,880
and here we look at if it changes from a

379
00:20:53,880 --> 00:20:57,179
zero to a one then in order for the

380
00:20:57,179 --> 00:21:00,059
adversary to not allow us to kind of

381
00:21:00,059 --> 00:21:02,640
reconstruct G to the X they will have to

382
00:21:02,640 --> 00:21:06,539
essentially uh found and input this Ki

383
00:21:06,539 --> 00:21:09,840
term that they were never even given uh

384
00:21:09,840 --> 00:21:14,059
into this kind of linear C1 Prime term

385
00:21:14,720 --> 00:21:17,700
and a sort of kind of inverse is true if

386
00:21:17,700 --> 00:21:20,460
they're changing a one to a zero uh in

387
00:21:20,460 --> 00:21:21,900
which case they must have kind of

388
00:21:21,900 --> 00:21:25,320
extracted a Ki from the original C1 and

389
00:21:25,320 --> 00:21:27,299
taken it out for the C1 Prime

390
00:21:27,299 --> 00:21:31,140
and so we argue that in either case the

391
00:21:31,140 --> 00:21:33,059
uh probability that they are able to do

392
00:21:33,059 --> 00:21:36,299
this is very small and so the reduction

393
00:21:36,299 --> 00:21:38,720
goes through

394
00:21:39,780 --> 00:21:42,900
so for constructing non-maluable digital

395
00:21:42,900 --> 00:21:45,720
lockers uh what we will do is we will

396
00:21:45,720 --> 00:21:48,720
encode a CRS into the associated data

397
00:21:48,720 --> 00:21:51,000
we'll be pretty sure that it's tamper

398
00:21:51,000 --> 00:21:54,960
proof and we will append uh an

399
00:21:54,960 --> 00:21:56,580
appropriate non-interactive zero

400
00:21:56,580 --> 00:21:59,760
knowledge argument to uh

401
00:21:59,760 --> 00:22:01,860
uh achieve kind of non-malleability over

402
00:22:01,860 --> 00:22:05,100
our output uh I'm not going to get into

403
00:22:05,100 --> 00:22:07,320
this in this talk but there are a few

404
00:22:07,320 --> 00:22:08,820
kind of subtleties with this argument

405
00:22:08,820 --> 00:22:11,580
and so I you know welcome any questions

406
00:22:11,580 --> 00:22:15,120
uh about this part it's very interesting

407
00:22:15,120 --> 00:22:17,400
but for now I want to get into kind of

408
00:22:17,400 --> 00:22:20,940
an application of this uh non-mallieable

409
00:22:20,940 --> 00:22:23,340
digital locker and that is uh these

410
00:22:23,340 --> 00:22:25,679
better robust fuzzy extractors

411
00:22:25,679 --> 00:22:27,900
so as a reminder a fuzzy extractor

412
00:22:27,900 --> 00:22:30,440
should essentially take an enrollment W

413
00:22:30,440 --> 00:22:33,000
and anything that's within a small

414
00:22:33,000 --> 00:22:36,299
Hamming ball of w should reproduce to

415
00:22:36,299 --> 00:22:38,940
this uh random stable key anything

416
00:22:38,940 --> 00:22:40,860
outside of this Hamming ball should give

417
00:22:40,860 --> 00:22:43,380
you no information about it

418
00:22:43,380 --> 00:22:46,320
in particular it's a tuple of algorithms

419
00:22:46,320 --> 00:22:49,620
that obey these properties right here to

420
00:22:49,620 --> 00:22:51,539
focus on the third one this is our kind

421
00:22:51,539 --> 00:22:53,760
of robustness guarantee which is that

422
00:22:53,760 --> 00:22:55,140
you know no adversary with high

423
00:22:55,140 --> 00:22:59,340
probability can Mall Pub to produce and

424
00:22:59,340 --> 00:23:02,880
to reproduce to a new key Prime

425
00:23:02,880 --> 00:23:05,880
a secure sketch is a very related object

426
00:23:05,880 --> 00:23:08,340
essentially instead of in the fuzzy

427
00:23:08,340 --> 00:23:10,860
extractor reproducing to this kind of

428
00:23:10,860 --> 00:23:14,159
stored key now we're trying to get back

429
00:23:14,159 --> 00:23:16,919
to kind of our original enrollment so

430
00:23:16,919 --> 00:23:19,559
essentially these same kind of factors

431
00:23:19,559 --> 00:23:21,600
hold especially for a robust secure

432
00:23:21,600 --> 00:23:25,500
sketch but now uh W double Prime should

433
00:23:25,500 --> 00:23:28,380
equal W if and only if this W Prime is

434
00:23:28,380 --> 00:23:30,480
close to the original w

435
00:23:30,480 --> 00:23:32,220
and the reason I bring this up is

436
00:23:32,220 --> 00:23:34,020
because this is actually how we can use

437
00:23:34,020 --> 00:23:37,860
a digital Locker to construct a a fuzzy

438
00:23:37,860 --> 00:23:41,159
extractor essentially you store in the

439
00:23:41,159 --> 00:23:43,140
digital Locker your original enrollment

440
00:23:43,140 --> 00:23:45,980
W and your target output key

441
00:23:45,980 --> 00:23:49,200
uh into your digital locker and so then

442
00:23:49,200 --> 00:23:52,440
on use of the secure sketch if your

443
00:23:52,440 --> 00:23:54,299
reading is close then you should be able

444
00:23:54,299 --> 00:23:55,980
to get back w send it through the

445
00:23:55,980 --> 00:23:59,720
digital locker and get out the key

446
00:24:00,120 --> 00:24:01,679
so

447
00:24:01,679 --> 00:24:03,960
there we go uh

448
00:24:03,960 --> 00:24:06,480
so in particular here in our

449
00:24:06,480 --> 00:24:09,659
malleability definition we require the

450
00:24:09,659 --> 00:24:12,360
adversary who wants to the tampering

451
00:24:12,360 --> 00:24:13,919
adversary to Output the function that

452
00:24:13,919 --> 00:24:15,240
they're tampering to

453
00:24:15,240 --> 00:24:18,480
and as I mentioned then this is a pretty

454
00:24:18,480 --> 00:24:19,980
strong kind of assumption on the

455
00:24:19,980 --> 00:24:23,640
behavior of the adversary uh however uh

456
00:24:23,640 --> 00:24:26,100
with a correct kind of secure sketch we

457
00:24:26,100 --> 00:24:28,980
can actually overcome this limitation uh

458
00:24:28,980 --> 00:24:31,620
in particular we look at syndrome

459
00:24:31,620 --> 00:24:34,340
decoding and syndrome secure sketches

460
00:24:34,340 --> 00:24:38,460
uh the specific syntax of the syndrome

461
00:24:38,460 --> 00:24:40,080
is up there but what the two things I

462
00:24:40,080 --> 00:24:41,520
really want to focus on is that there's

463
00:24:41,520 --> 00:24:44,580
this sort of uh commutation with the

464
00:24:44,580 --> 00:24:47,520
subtraction up here such that syndrome

465
00:24:47,520 --> 00:24:50,159
of S Prime minus syndrome of s is equal

466
00:24:50,159 --> 00:24:52,500
to the syndrome of S Prime minus s

467
00:24:52,500 --> 00:24:54,840
and in addition there's this kind of

468
00:24:54,840 --> 00:24:57,539
unique inversion for small Hamming

469
00:24:57,539 --> 00:24:59,400
weight values

470
00:24:59,400 --> 00:25:01,679
um and what these two together are

471
00:25:01,679 --> 00:25:05,659
really going to give us is essentially

472
00:25:05,659 --> 00:25:07,559
that

473
00:25:07,559 --> 00:25:10,799
uh any adversary who tries to tamper

474
00:25:10,799 --> 00:25:13,260
with the digital Locker

475
00:25:13,260 --> 00:25:15,419
we can figure out what they tried to

476
00:25:15,419 --> 00:25:17,820
Tamper it to by finding the small shift

477
00:25:17,820 --> 00:25:20,039
in our secure sketch that they tried to

478
00:25:20,039 --> 00:25:22,500
Tamper that to

479
00:25:22,500 --> 00:25:24,779
in particular we can kind of extract the

480
00:25:24,779 --> 00:25:26,460
difference in the original secure sketch

481
00:25:26,460 --> 00:25:28,559
and the one that they tampered to in

482
00:25:28,559 --> 00:25:30,059
order to find the difference between

483
00:25:30,059 --> 00:25:31,380
these

484
00:25:31,380 --> 00:25:33,600
which will let us kind of extract out

485
00:25:33,600 --> 00:25:35,820
what this tampering function is and so

486
00:25:35,820 --> 00:25:38,400
therefore we can get robustness from the

487
00:25:38,400 --> 00:25:41,460
non-maluable guarantee

488
00:25:41,460 --> 00:25:42,480
okay

489
00:25:42,480 --> 00:25:45,179
so just as a quick refresher of our

490
00:25:45,179 --> 00:25:46,980
results we defined a new primitive this

491
00:25:46,980 --> 00:25:49,500
non-malleable uh Point obfuscation with

492
00:25:49,500 --> 00:25:52,260
Associated data we constructed this and

493
00:25:52,260 --> 00:25:53,880
made the first non-malleable digital

494
00:25:53,880 --> 00:25:56,159
Locker in the play model and then we use

495
00:25:56,159 --> 00:25:58,740
that to kind of pull robust fuzzy

496
00:25:58,740 --> 00:26:01,740
extractors with low input entropy uh

497
00:26:01,740 --> 00:26:03,960
also into the plane model

498
00:26:03,960 --> 00:26:06,179
there's plenty of future directions that

499
00:26:06,179 --> 00:26:09,059
I think are interesting for it uh not

500
00:26:09,059 --> 00:26:11,460
malleable obfuscation so BBB obfuscation

501
00:26:11,460 --> 00:26:13,620
is impossible in general uh for General

502
00:26:13,620 --> 00:26:16,679
circuits but it might be interesting to

503
00:26:16,679 --> 00:26:18,600
look into non-allible obfuscation for

504
00:26:18,600 --> 00:26:20,940
other kind of evasive functions

505
00:26:20,940 --> 00:26:23,760
uh we also want to achieve more broad

506
00:26:23,760 --> 00:26:26,159
Notions of composability in this work we

507
00:26:26,159 --> 00:26:28,080
only achieve same point composability

508
00:26:28,080 --> 00:26:30,960
for Point obfuscations uh generalizing

509
00:26:30,960 --> 00:26:32,100
this would actually help in the next

510
00:26:32,100 --> 00:26:34,500
property which might be constructing

511
00:26:34,500 --> 00:26:38,220
reusable uh fuzzy extractors or other

512
00:26:38,220 --> 00:26:40,980
such applications hopefully all at once

513
00:26:40,980 --> 00:26:43,679
finally I personally believe that there

514
00:26:43,679 --> 00:26:45,659
are other interesting applications of

515
00:26:45,659 --> 00:26:47,340
non-miable point obfuscations with

516
00:26:47,340 --> 00:26:50,340
Associated data uh especially in kind of

517
00:26:50,340 --> 00:26:52,740
this CRS encoding method I think it's

518
00:26:52,740 --> 00:26:54,419
very interesting

519
00:26:54,419 --> 00:26:58,860
and with that I am done so thank you for

520
00:26:58,860 --> 00:27:01,158
your time

521
00:27:06,179 --> 00:27:09,380
so any questions

522
00:27:15,000 --> 00:27:16,919
what is the

523
00:27:16,919 --> 00:27:19,320
um function of the set of tempering

524
00:27:19,320 --> 00:27:21,179
functions that you consider yeah so the

525
00:27:21,179 --> 00:27:23,640
set of tampering functions is just a low

526
00:27:23,640 --> 00:27:25,679
degree polynomials in fact the degree of

527
00:27:25,679 --> 00:27:27,980
them is dependent on the Assumption

528
00:27:27,980 --> 00:27:30,600
depending on how many kind of this

529
00:27:30,600 --> 00:27:34,200
Ensemble they get but in our application

530
00:27:34,200 --> 00:27:35,460
for example it doesn't matter because

531
00:27:35,460 --> 00:27:38,240
they're going to be linear

532
00:27:43,200 --> 00:27:46,700
any more thank you questions

533
00:27:47,159 --> 00:27:48,299
all right

534
00:27:48,299 --> 00:27:50,340
um let's let's thank the speaker again

535
00:27:50,340 --> 00:27:52,820
and

536
00:28:14,120 --> 00:28:17,178
thank you

537
00:28:18,539 --> 00:28:21,020
yes

538
00:28:25,620 --> 00:28:28,500
so uh the second talk for today is

539
00:28:28,500 --> 00:28:30,240
continuous non-malayable codes against

540
00:28:30,240 --> 00:28:32,960
phone adapt tempering by

541
00:28:32,960 --> 00:28:35,880
Sebastian Elena michali and Daniel

542
00:28:35,880 --> 00:28:38,820
inventory and Illinois

543
00:28:38,820 --> 00:28:41,220
thank you for the nice introduction and

544
00:28:41,220 --> 00:28:43,799
thank you all for being here so let's

545
00:28:43,799 --> 00:28:46,260
start and let's start by seeing what is

546
00:28:46,260 --> 00:28:49,559
anomalia board so anomaliable code is a

547
00:28:49,559 --> 00:28:51,419
coding scheme which means that it's a

548
00:28:51,419 --> 00:28:53,700
couple of algorithms encode and decode

549
00:28:53,700 --> 00:28:56,340
that are public and keyless

550
00:28:56,340 --> 00:28:58,380
for normal ability we require two

551
00:28:58,380 --> 00:29:00,299
properties the first one of course is

552
00:29:00,299 --> 00:29:02,820
correctness and here we require that for

553
00:29:02,820 --> 00:29:05,640
every message when we encode it into a

554
00:29:05,640 --> 00:29:07,980
codeword C and then we decode C we

555
00:29:07,980 --> 00:29:10,140
should get the original message the

556
00:29:10,140 --> 00:29:11,760
second property is called fnormal

557
00:29:11,760 --> 00:29:14,100
liability and this and it has a

558
00:29:14,100 --> 00:29:16,380
parameter this family of functions F

559
00:29:16,380 --> 00:29:19,559
that Peter already nicely defined

560
00:29:19,559 --> 00:29:21,480
so when we require the abnormal

561
00:29:21,480 --> 00:29:24,720
liability we require that uh whenever an

562
00:29:24,720 --> 00:29:26,820
attacker is allowed to specify a

563
00:29:26,820 --> 00:29:28,919
tampering function within this family F

564
00:29:28,919 --> 00:29:31,559
and then can observe the tamper message

565
00:29:31,559 --> 00:29:33,779
corresponding to the evaluation of this

566
00:29:33,779 --> 00:29:36,600
function over a codeword C then the

567
00:29:36,600 --> 00:29:38,520
standard message should be either equal

568
00:29:38,520 --> 00:29:41,100
to the original one or independent of it

569
00:29:41,100 --> 00:29:43,559
or tampering should be detected meaning

570
00:29:43,559 --> 00:29:45,720
that the decoding algorithm should

571
00:29:45,720 --> 00:29:47,760
return a special symbol

572
00:29:47,760 --> 00:29:50,159
of course as you can see abnormal

573
00:29:50,159 --> 00:29:53,100
ability gets a stronger property when

574
00:29:53,100 --> 00:29:55,260
the family gets larger so we would like

575
00:29:55,260 --> 00:29:57,840
to get abnormal codes for families that

576
00:29:57,840 --> 00:29:59,700
are as large as possible

577
00:29:59,700 --> 00:30:01,860
unfortunately some limitations were

578
00:30:01,860 --> 00:30:04,200
proven already and in particular we can

579
00:30:04,200 --> 00:30:05,940
never get normal ability against

580
00:30:05,940 --> 00:30:08,039
families that include every probability

581
00:30:08,039 --> 00:30:10,799
polynomial time functions so it's

582
00:30:10,799 --> 00:30:12,539
interesting to understand but which

583
00:30:12,539 --> 00:30:14,820
families we can get normal ability and

584
00:30:14,820 --> 00:30:17,100
under which assumption

585
00:30:17,100 --> 00:30:19,740
another generalization of normal codes

586
00:30:19,740 --> 00:30:22,320
is that of continuous

587
00:30:22,320 --> 00:30:24,240
in this case the attacker is actually

588
00:30:24,240 --> 00:30:26,220
allowed to specify a polynomial amount

589
00:30:26,220 --> 00:30:28,200
of comparing functions and of course

590
00:30:28,200 --> 00:30:30,720
observe the corresponding messages

591
00:30:30,720 --> 00:30:33,240
to give a bit more details

592
00:30:33,240 --> 00:30:35,220
um uh we assume the attacker to be

593
00:30:35,220 --> 00:30:37,940
adaptive so the attacker can actually

594
00:30:37,940 --> 00:30:40,620
select every tampering function based on

595
00:30:40,620 --> 00:30:43,020
the outcome of format tampering attempts

596
00:30:43,020 --> 00:30:45,480
and we are additionally restrict the

597
00:30:45,480 --> 00:30:47,880
experiment to perform some form of

598
00:30:47,880 --> 00:30:50,340
self-destruction mechanism in particular

599
00:30:50,340 --> 00:30:52,740
we assume that as soon as the coding is

600
00:30:52,740 --> 00:30:55,919
detected tampering is detected once then

601
00:30:55,919 --> 00:30:57,840
all the following tampering attempts

602
00:30:57,840 --> 00:31:00,120
will be answered with both independently

603
00:31:00,120 --> 00:31:02,520
on the actual outcome of the tampering

604
00:31:02,520 --> 00:31:03,899
attempts

605
00:31:03,899 --> 00:31:05,640
when talking about continuous normal

606
00:31:05,640 --> 00:31:08,640
liability we can consider two flavors so

607
00:31:08,640 --> 00:31:10,740
the first one is that of non-persistent

608
00:31:10,740 --> 00:31:13,260
tampering and in this case each sampling

609
00:31:13,260 --> 00:31:15,299
function is always applied to the

610
00:31:15,299 --> 00:31:17,700
original codeword and the second is that

611
00:31:17,700 --> 00:31:19,860
of persistent tampering and in this case

612
00:31:19,860 --> 00:31:22,140
each sampling function is actually

613
00:31:22,140 --> 00:31:24,299
always applied to the latest version of

614
00:31:24,299 --> 00:31:25,559
the codeword

615
00:31:25,559 --> 00:31:27,840
so when talking about the former

616
00:31:27,840 --> 00:31:29,700
definition of normal ability let's say

617
00:31:29,700 --> 00:31:32,520
the classic one we will usually use the

618
00:31:32,520 --> 00:31:35,279
term one-time normalable that represents

619
00:31:35,279 --> 00:31:37,799
the fact that the attacker only selects

620
00:31:37,799 --> 00:31:40,559
one tampering function and in general it

621
00:31:40,559 --> 00:31:42,779
can be proven that one-time normal

622
00:31:42,779 --> 00:31:44,820
liability is strictly weaker than

623
00:31:44,820 --> 00:31:47,039
continuous normal ability

624
00:31:47,039 --> 00:31:49,559
this is even more evident when one looks

625
00:31:49,559 --> 00:31:51,299
at the state of the art of abnormal

626
00:31:51,299 --> 00:31:54,659
codes so to discuss it it makes sense to

627
00:31:54,659 --> 00:31:57,419
divide all the possible uh tampering

628
00:31:57,419 --> 00:31:59,820
families into to subclasses

629
00:31:59,820 --> 00:32:01,500
the first one is that of granular

630
00:32:01,500 --> 00:32:03,659
tampering and the second one is that of

631
00:32:03,659 --> 00:32:05,720
global tampering

632
00:32:05,720 --> 00:32:08,340
tampering we refer to all the families

633
00:32:08,340 --> 00:32:10,380
where the codeword is splitted into

634
00:32:10,380 --> 00:32:13,020
predefined blocks and each of this block

635
00:32:13,020 --> 00:32:14,880
is tampered individually

636
00:32:14,880 --> 00:32:16,799
for Global tampering we just don't put

637
00:32:16,799 --> 00:32:18,899
this restriction so we consider all the

638
00:32:18,899 --> 00:32:22,140
families uh that are not granular

639
00:32:22,140 --> 00:32:24,179
for granular tampering we have a large

640
00:32:24,179 --> 00:32:26,220
variety of one terminal malleable codes

641
00:32:26,220 --> 00:32:29,340
and Through Time many of them were

642
00:32:29,340 --> 00:32:31,620
extended to The Continuous setting

643
00:32:31,620 --> 00:32:33,899
for Global tampering again we have a

644
00:32:33,899 --> 00:32:36,539
very large variety of constructions and

645
00:32:36,539 --> 00:32:39,840
also for very large and um and general

646
00:32:39,840 --> 00:32:43,260
families such as local ac0 and bounded

647
00:32:43,260 --> 00:32:44,640
depth function

648
00:32:44,640 --> 00:32:46,980
on the other hand not many of them were

649
00:32:46,980 --> 00:32:49,320
actually extended so what we do in our

650
00:32:49,320 --> 00:32:52,500
work is to investigate the possibility

651
00:32:52,500 --> 00:32:55,020
of continuous normal ability for those

652
00:32:55,020 --> 00:32:57,600
missing functions for this those missing

653
00:32:57,600 --> 00:32:58,860
families

654
00:32:58,860 --> 00:33:01,799
in particular our first result is an

655
00:33:01,799 --> 00:33:03,659
impossibility result in the

656
00:33:03,659 --> 00:33:06,360
non-persistent setting that concerns a

657
00:33:06,360 --> 00:33:08,159
very large amount of global tampering

658
00:33:08,159 --> 00:33:09,120
families

659
00:33:09,120 --> 00:33:12,179
and in particular it includes ac0 local

660
00:33:12,179 --> 00:33:14,940
functions even with minimum locality 1

661
00:33:14,940 --> 00:33:17,700
and Boundary depth functions

662
00:33:17,700 --> 00:33:19,500
the next result is then in the

663
00:33:19,500 --> 00:33:22,019
persistent model in this case we provide

664
00:33:22,019 --> 00:33:23,880
the first construction of a decision

665
00:33:23,880 --> 00:33:25,919
trinomial code

666
00:33:25,919 --> 00:33:28,019
why decision please because decision

667
00:33:28,019 --> 00:33:30,360
tree is actually General generalized

668
00:33:30,360 --> 00:33:32,820
local functions so this provides a

669
00:33:32,820 --> 00:33:34,320
larger family

670
00:33:34,320 --> 00:33:36,720
and as for the Assumption here we have

671
00:33:36,720 --> 00:33:38,519
to introduce computational assumptions

672
00:33:38,519 --> 00:33:40,380
in particular we require the existence

673
00:33:40,380 --> 00:33:42,179
of one-way functions

674
00:33:42,179 --> 00:33:44,640
we provide another construction uh

675
00:33:44,640 --> 00:33:46,440
always in the persistent setting and

676
00:33:46,440 --> 00:33:48,720
this time for bounded that tampering

677
00:33:48,720 --> 00:33:51,840
in this proof we need to use the CRS

678
00:33:51,840 --> 00:33:52,799
model

679
00:33:52,799 --> 00:33:55,740
and the building blocks are template

680
00:33:55,740 --> 00:33:58,980
puzzles and simulation extractable zero

681
00:33:58,980 --> 00:34:00,360
knowledge proofs

682
00:34:00,360 --> 00:34:02,100
so during this talk we will actually

683
00:34:02,100 --> 00:34:03,720
focus on the decision tree construction

684
00:34:03,720 --> 00:34:06,539
but of course uh details on anything

685
00:34:06,539 --> 00:34:09,000
else are available on the paper that is

686
00:34:09,000 --> 00:34:11,339
already on ePrint and of course you can

687
00:34:11,339 --> 00:34:13,379
ask me anytime

688
00:34:13,379 --> 00:34:16,199
so let's start let's let's go a bit more

689
00:34:16,199 --> 00:34:19,199
into detail and a good ways to see uh

690
00:34:19,199 --> 00:34:20,940
the formal definition of normal level

691
00:34:20,940 --> 00:34:22,199
thoughts

692
00:34:22,199 --> 00:34:24,480
so the experiment for abnormal ability

693
00:34:24,480 --> 00:34:26,879
is defined through an interaction of an

694
00:34:26,879 --> 00:34:29,580
adversary and a Challenger the adversary

695
00:34:29,580 --> 00:34:32,099
specifies a couple of messages and the

696
00:34:32,099 --> 00:34:34,260
Challenger includes one of them by

697
00:34:34,260 --> 00:34:37,139
keeping both his choice and the code

698
00:34:37,139 --> 00:34:38,839
word Secret

699
00:34:38,839 --> 00:34:41,940
then specifies a dampering function

700
00:34:41,940 --> 00:34:43,320
within the family

701
00:34:43,320 --> 00:34:45,418
and the Challenger will then evaluate it

702
00:34:45,418 --> 00:34:47,399
on the codeword recover the sample

703
00:34:47,399 --> 00:34:50,040
message and then return a special symbol

704
00:34:50,040 --> 00:34:52,800
same whenever the tamper message equals

705
00:34:52,800 --> 00:34:55,320
either m0 or M1 and this is something

706
00:34:55,320 --> 00:34:57,060
that we have to assume otherwise the

707
00:34:57,060 --> 00:34:59,520
experiment would be trivial

708
00:34:59,520 --> 00:35:01,680
um and otherwise it just Returns the

709
00:35:01,680 --> 00:35:03,300
thumper message

710
00:35:03,300 --> 00:35:04,800
at the end of the experiment the

711
00:35:04,800 --> 00:35:06,900
adversary will use this information to

712
00:35:06,900 --> 00:35:09,240
try to guess uh the the choice of the

713
00:35:09,240 --> 00:35:12,300
Challenger and we say that um normal

714
00:35:12,300 --> 00:35:14,640
ability happens whenever the probability

715
00:35:14,640 --> 00:35:17,099
that this gas is correct is actually

716
00:35:17,099 --> 00:35:19,680
upper bounded by half plus something

717
00:35:19,680 --> 00:35:22,640
that is negligible

718
00:35:23,300 --> 00:35:26,160
we don't need so many details so all you

719
00:35:26,160 --> 00:35:28,800
all that you need to know again is that

720
00:35:28,800 --> 00:35:31,440
the adversary specifies now a polynomial

721
00:35:31,440 --> 00:35:33,180
amount of tampering functions and this

722
00:35:33,180 --> 00:35:35,700
selection is adaptive

723
00:35:35,700 --> 00:35:37,859
um also that since we are in the

724
00:35:37,859 --> 00:35:39,780
persistent setting each sampling

725
00:35:39,780 --> 00:35:41,339
function is applied to the latest

726
00:35:41,339 --> 00:35:43,140
version of the codeword

727
00:35:43,140 --> 00:35:44,940
and we assume it's a destruction

728
00:35:44,940 --> 00:35:47,820
mechanism so as soon as the adversary is

729
00:35:47,820 --> 00:35:49,980
set as soon as tampering is detected

730
00:35:49,980 --> 00:35:52,320
once then all the following tampering

731
00:35:52,320 --> 00:35:55,260
attempts will be answered with both

732
00:35:55,260 --> 00:35:57,780
actually there are there are many

733
00:35:57,780 --> 00:35:59,700
intermediate Notions between one time

734
00:35:59,700 --> 00:36:01,800
and continuous normal ability in this

735
00:36:01,800 --> 00:36:04,260
work we consider some of them and all

736
00:36:04,260 --> 00:36:07,320
that and and those Notions are like or

737
00:36:07,320 --> 00:36:09,420
one time but still they are stronger

738
00:36:09,420 --> 00:36:12,000
than the classic one-time definition

739
00:36:12,000 --> 00:36:15,240
so let's start seeing them and uh to

740
00:36:15,240 --> 00:36:16,800
understand them I will just leave for

741
00:36:16,800 --> 00:36:19,079
reference the experiment for classic uh

742
00:36:19,079 --> 00:36:21,180
one time normal ability

743
00:36:21,180 --> 00:36:23,520
so the first stronger variant is that of

744
00:36:23,520 --> 00:36:25,200
abnormal ability with respect to

745
00:36:25,200 --> 00:36:27,540
Boardwalk in this case the main

746
00:36:27,540 --> 00:36:30,180
modification is that the adversary only

747
00:36:30,180 --> 00:36:33,540
gets same when the temperature equals

748
00:36:33,540 --> 00:36:36,420
the original one so not in general when

749
00:36:36,420 --> 00:36:38,040
the tamper message equals the original

750
00:36:38,040 --> 00:36:40,560
message in this sense this provides a

751
00:36:40,560 --> 00:36:42,720
stronger guarantee because the adversary

752
00:36:42,720 --> 00:36:45,180
is less likely to get same

753
00:36:45,180 --> 00:36:47,700
um which means that it's more likely to

754
00:36:47,700 --> 00:36:49,380
get the tamper message which which

755
00:36:49,380 --> 00:36:51,480
provides more information that than just

756
00:36:51,480 --> 00:36:53,880
a teamwork

757
00:36:53,880 --> 00:36:55,859
um the next stronger variant is that of

758
00:36:55,859 --> 00:36:58,079
supernormal ability

759
00:36:58,079 --> 00:37:00,960
uh in this case the main modification is

760
00:37:00,960 --> 00:37:03,180
that whenever tampering does not help

761
00:37:03,180 --> 00:37:06,119
same or both the adversary actually gets

762
00:37:06,119 --> 00:37:08,460
the whole temperature and not only the

763
00:37:08,460 --> 00:37:10,320
dump that message

764
00:37:10,320 --> 00:37:12,240
the stronger variant instead of G

765
00:37:12,240 --> 00:37:15,000
linkage resilient abnormal liability

766
00:37:15,000 --> 00:37:16,859
in this case the adversary is also

767
00:37:16,859 --> 00:37:19,079
allowed to specify a leakage function

768
00:37:19,079 --> 00:37:21,480
within a family and observe the

769
00:37:21,480 --> 00:37:23,220
evaluation of this leakage function over

770
00:37:23,220 --> 00:37:25,560
the codeword then the tampering function

771
00:37:25,560 --> 00:37:28,440
can be selected accordingly

772
00:37:28,440 --> 00:37:30,660
the reason why we consider all these

773
00:37:30,660 --> 00:37:33,300
intermediate Notions is this prior

774
00:37:33,300 --> 00:37:35,400
result from the far golden weeks that

775
00:37:35,400 --> 00:37:37,260
proved that whenever a one-time normal

776
00:37:37,260 --> 00:37:39,359
labor code satisfies at the same time

777
00:37:39,359 --> 00:37:41,940
it's Uber with respect to code and geely

778
00:37:41,940 --> 00:37:43,440
get your resilient for a large enough

779
00:37:43,440 --> 00:37:46,140
family G then this one terminal

780
00:37:46,140 --> 00:37:48,660
malleable code is is already continuous

781
00:37:48,660 --> 00:37:51,180
persistent

782
00:37:51,180 --> 00:37:53,220
so before we we look into the actual

783
00:37:53,220 --> 00:37:55,680
techniques uh we said that we were going

784
00:37:55,680 --> 00:37:57,780
we were going to talk about the decision

785
00:37:57,780 --> 00:38:00,119
pre-construction so it makes sense to

786
00:38:00,119 --> 00:38:02,460
understand what decision trees are

787
00:38:02,460 --> 00:38:04,740
and the best way is to start from local

788
00:38:04,740 --> 00:38:06,119
functions

789
00:38:06,119 --> 00:38:08,040
so we say that a function is the local

790
00:38:08,040 --> 00:38:10,500
whenever each output depends on at most

791
00:38:10,500 --> 00:38:13,200
the input bits and this selection is

792
00:38:13,200 --> 00:38:16,800
actually done like only depends on the

793
00:38:16,800 --> 00:38:18,780
on the description of the function and

794
00:38:18,780 --> 00:38:20,760
it's therefore independent of the input

795
00:38:20,760 --> 00:38:22,740
bits that are read

796
00:38:22,740 --> 00:38:25,560
when we move to D decision trees again

797
00:38:25,560 --> 00:38:27,780
we have that each output bit somehow

798
00:38:27,780 --> 00:38:30,839
depends on at most the input bits but in

799
00:38:30,839 --> 00:38:32,160
this case the selection happened

800
00:38:32,160 --> 00:38:34,800
adaptively based on the input bits that

801
00:38:34,800 --> 00:38:36,060
are read

802
00:38:36,060 --> 00:38:39,720
in particular we can see this process as

803
00:38:39,720 --> 00:38:42,180
a binary tree that is Step D and

804
00:38:42,180 --> 00:38:44,579
therefore 2 today release

805
00:38:44,579 --> 00:38:46,800
and why because we choose the second bit

806
00:38:46,800 --> 00:38:48,900
based on the first the third is based on

807
00:38:48,900 --> 00:38:51,119
the second and the first and so on

808
00:38:51,119 --> 00:38:52,980
so now it should be more clear where

809
00:38:52,980 --> 00:38:54,960
decision trees generalize local

810
00:38:54,960 --> 00:38:57,599
functions and in particular they are an

811
00:38:57,599 --> 00:38:59,820
intermediate class between the local and

812
00:38:59,820 --> 00:39:02,660
two to the D log

813
00:39:07,140 --> 00:39:11,660
okay yeah so

814
00:39:11,700 --> 00:39:15,119
okay yes our construction

815
00:39:15,119 --> 00:39:15,960
um

816
00:39:15,960 --> 00:39:18,540
is uh the starting point of our

817
00:39:18,540 --> 00:39:21,119
construction is a prior one-time normal

818
00:39:21,119 --> 00:39:23,579
labor code always against decision trees

819
00:39:23,579 --> 00:39:26,220
by ball going weeks so let's start by

820
00:39:26,220 --> 00:39:28,320
seeing the main building blocks the

821
00:39:28,320 --> 00:39:30,420
first is a two split State normal code

822
00:39:30,420 --> 00:39:33,240
that is a normal level code with

823
00:39:33,240 --> 00:39:35,040
resilience against functions that divide

824
00:39:35,040 --> 00:39:37,079
the codeword into two predefined blocks

825
00:39:37,079 --> 00:39:39,000
and tamper with each of these Blocks

826
00:39:39,000 --> 00:39:40,440
individually

827
00:39:40,440 --> 00:39:42,480
the second building block is a key Ram

828
00:39:42,480 --> 00:39:44,700
secret sharing scheme which is a coding

829
00:39:44,700 --> 00:39:46,740
scheme and therefore satisfies the usual

830
00:39:46,740 --> 00:39:48,900
definition of correctness but

831
00:39:48,900 --> 00:39:51,000
additionally satisfies the property of

832
00:39:51,000 --> 00:39:53,220
this secrecy from partial views which

833
00:39:53,220 --> 00:39:54,599
say it's something that we would expect

834
00:39:54,599 --> 00:39:56,820
from a scheme that has secret sharing in

835
00:39:56,820 --> 00:39:57,780
his name

836
00:39:57,780 --> 00:40:00,599
in particular it states that whenever an

837
00:40:00,599 --> 00:40:02,700
attacker is allowed to observe at most

838
00:40:02,700 --> 00:40:05,820
CBS of of a quarter then those beats

839
00:40:05,820 --> 00:40:07,260
will actually look undistinguishable

840
00:40:07,260 --> 00:40:09,180
from random

841
00:40:09,180 --> 00:40:11,099
the last building block is a function

842
00:40:11,099 --> 00:40:14,640
that takes a string of K beats and

843
00:40:14,640 --> 00:40:17,220
expands it into a binary string of like

844
00:40:17,220 --> 00:40:19,740
length n that is longer

845
00:40:19,740 --> 00:40:22,020
so in particular this function takes as

846
00:40:22,020 --> 00:40:24,720
input this binary string of like K that

847
00:40:24,720 --> 00:40:28,560
we call C as well as an index set of

848
00:40:28,560 --> 00:40:32,400
indexes that vary from 1 to n but are

849
00:40:32,400 --> 00:40:35,640
like only K and then constructs the

850
00:40:35,640 --> 00:40:38,940
binary string that that has C in the

851
00:40:38,940 --> 00:40:41,339
positions indexed by I and zeros

852
00:40:41,339 --> 00:40:43,500
everywhere else

853
00:40:43,500 --> 00:40:45,240
now that we have all the ingredients

854
00:40:45,240 --> 00:40:48,140
let's present uh one time normally

855
00:40:48,140 --> 00:40:51,540
going weeds the recording algorithm

856
00:40:51,540 --> 00:40:54,960
takes his input a message and encodes it

857
00:40:54,960 --> 00:40:58,140
via the split State encoding algorithm

858
00:40:58,140 --> 00:41:01,079
then each state of the coder is expanded

859
00:41:01,079 --> 00:41:04,440
using uniformly random index sets

860
00:41:04,440 --> 00:41:07,500
and then the final codeword is achieved

861
00:41:07,500 --> 00:41:09,300
by appending Ram secret sharing

862
00:41:09,300 --> 00:41:12,180
encodings of these index sets

863
00:41:12,180 --> 00:41:16,200
as for decoding then one only needs to

864
00:41:16,200 --> 00:41:18,000
start by decoding the ram secret

865
00:41:18,000 --> 00:41:22,260
sharings to recover the index sets then

866
00:41:22,260 --> 00:41:25,680
read the positions indexed by i1 and I2

867
00:41:25,680 --> 00:41:28,020
in the expanded codor to recover the

868
00:41:28,020 --> 00:41:29,520
speed safe codeword

869
00:41:29,520 --> 00:41:31,740
and when one has the spirit State

870
00:41:31,740 --> 00:41:33,720
codeword it can just recover the message

871
00:41:33,720 --> 00:41:35,579
by using the split State recording

872
00:41:35,579 --> 00:41:37,260
algorithm

873
00:41:37,260 --> 00:41:39,599
as for the assumptions for the ram

874
00:41:39,599 --> 00:41:41,760
signaturing scheme they assume that the

875
00:41:41,760 --> 00:41:44,280
secrecy parameter T is large enough

876
00:41:44,280 --> 00:41:46,320
and as for the split State normal level

877
00:41:46,320 --> 00:41:49,140
code they assume l-bounded leakage

878
00:41:49,140 --> 00:41:51,000
resilience on each block and against

879
00:41:51,000 --> 00:41:53,220
this parameter should be large enough

880
00:41:53,220 --> 00:41:54,960
and also they assume information

881
00:41:54,960 --> 00:41:56,760
theoretic security

882
00:41:56,760 --> 00:41:59,400
uh for the purpose of this this talk you

883
00:41:59,400 --> 00:42:01,440
shouldn't know more about it

884
00:42:01,440 --> 00:42:04,079
and what they get is that this is

885
00:42:04,079 --> 00:42:05,579
actually a one-time normal labor board

886
00:42:05,579 --> 00:42:08,040
against decision trees added the

887
00:42:08,040 --> 00:42:10,619
information theoretic security of the

888
00:42:10,619 --> 00:42:12,180
split State normal level code is

889
00:42:12,180 --> 00:42:14,880
actually preserved

890
00:42:14,880 --> 00:42:17,040
so in our paper we proved that this is

891
00:42:17,040 --> 00:42:19,619
only one time so what we do is to

892
00:42:19,619 --> 00:42:21,480
actually extend it to continuous

893
00:42:21,480 --> 00:42:23,700
persistent normal ability and we do it

894
00:42:23,700 --> 00:42:25,560
following the framework of Jafar bowling

895
00:42:25,560 --> 00:42:27,900
weeds therefore we prove with respect to

896
00:42:27,900 --> 00:42:31,320
codeword super Angelica resilience so

897
00:42:31,320 --> 00:42:33,060
let's start

898
00:42:33,060 --> 00:42:35,880
uh let's start by adding normal ability

899
00:42:35,880 --> 00:42:38,460
with respect to order that means that we

900
00:42:38,460 --> 00:42:39,780
want to prove that whenever the

901
00:42:39,780 --> 00:42:41,760
temperature differs from the original

902
00:42:41,760 --> 00:42:45,000
one then uh the underlying tamper

903
00:42:45,000 --> 00:42:46,680
message is independent of the original

904
00:42:46,680 --> 00:42:48,000
message

905
00:42:48,000 --> 00:42:49,800
to do it we consider the additional

906
00:42:49,800 --> 00:42:52,020
building block of a strongly affordable

907
00:42:52,020 --> 00:42:54,839
one-time signature scheme that is a

908
00:42:54,839 --> 00:42:57,359
signature scheme where we extend the

909
00:42:57,359 --> 00:42:59,520
notion of forgery to include all the

910
00:42:59,520 --> 00:43:01,619
couples message signature that differ

911
00:43:01,619 --> 00:43:03,839
from the given one

912
00:43:03,839 --> 00:43:07,079
so we modified encoding by first

913
00:43:07,079 --> 00:43:10,140
sampling two pairs of keys for the

914
00:43:10,140 --> 00:43:11,640
signature skin

915
00:43:11,640 --> 00:43:13,680
we encode the verification Keys together

916
00:43:13,680 --> 00:43:15,599
with the message via the split State

917
00:43:15,599 --> 00:43:18,540
normal level code and we append to the

918
00:43:18,540 --> 00:43:21,480
codeword signatures of the two Alps of

919
00:43:21,480 --> 00:43:23,220
the original folder

920
00:43:23,220 --> 00:43:25,560
as for decoding it's enough to require

921
00:43:25,560 --> 00:43:28,500
the decoding fails whenever verification

922
00:43:28,500 --> 00:43:30,540
fails

923
00:43:30,540 --> 00:43:32,940
so to have an intuition on why this is

924
00:43:32,940 --> 00:43:34,800
now a normal level with respect to

925
00:43:34,800 --> 00:43:36,420
codeword you should observe that

926
00:43:36,420 --> 00:43:39,060
whenever the final codeword changes then

927
00:43:39,060 --> 00:43:41,400
a forgery for the underlying signature

928
00:43:41,400 --> 00:43:43,740
scheme happens but if a forgery happens

929
00:43:43,740 --> 00:43:45,780
this means that either verification

930
00:43:45,780 --> 00:43:48,000
fails and in this case recording returns

931
00:43:48,000 --> 00:43:50,280
both or

932
00:43:50,280 --> 00:43:52,260
um the underlying verification Keys

933
00:43:52,260 --> 00:43:54,359
changed as well but if the verification

934
00:43:54,359 --> 00:43:58,020
Keys change then since they are encoded

935
00:43:58,020 --> 00:44:00,240
together with the message with a split

936
00:44:00,240 --> 00:44:02,640
State normally above code then the

937
00:44:02,640 --> 00:44:04,800
message has changed as well and in

938
00:44:04,800 --> 00:44:07,079
particular it has become independent due

939
00:44:07,079 --> 00:44:09,300
to normal level

940
00:44:09,300 --> 00:44:13,500
so now let's add super normal ability so

941
00:44:13,500 --> 00:44:15,540
what what we want to get here is that

942
00:44:15,540 --> 00:44:17,640
whenever sampling does not yell same or

943
00:44:17,640 --> 00:44:20,040
bought then the attacker actually gets

944
00:44:20,040 --> 00:44:22,200
the tamper codeword and not only the

945
00:44:22,200 --> 00:44:23,819
template message

946
00:44:23,819 --> 00:44:25,680
to do it we consider a modified

947
00:44:25,680 --> 00:44:28,079
according algorithm and the only

948
00:44:28,079 --> 00:44:30,300
modification that we require here is

949
00:44:30,300 --> 00:44:31,440
that

950
00:44:31,440 --> 00:44:34,380
um decoding returns bought whenever in

951
00:44:34,380 --> 00:44:36,540
the expanded codeword in the positions

952
00:44:36,540 --> 00:44:38,760
that should contain zeros there is

953
00:44:38,760 --> 00:44:40,500
someone appearing

954
00:44:40,500 --> 00:44:43,980
as for the assumptions we we make

955
00:44:43,980 --> 00:44:45,960
additional assumptions on the underlying

956
00:44:45,960 --> 00:44:49,020
to split statements and the first one is

957
00:44:49,020 --> 00:44:51,960
super normal ability here

958
00:44:51,960 --> 00:44:54,480
um and here the English the intuition is

959
00:44:54,480 --> 00:44:56,280
that to reconstruct the dumper codeword

960
00:44:56,280 --> 00:44:58,380
we actually need the split state number

961
00:44:58,380 --> 00:45:00,060
codeword

962
00:45:00,060 --> 00:45:02,220
and the second assumption is that we

963
00:45:02,220 --> 00:45:05,220
need additional leakage resilience the

964
00:45:05,220 --> 00:45:07,079
reason here again is that to simulate

965
00:45:07,079 --> 00:45:09,240
the temperature we need to leak the

966
00:45:09,240 --> 00:45:12,420
temperature in order the temperature and

967
00:45:12,420 --> 00:45:14,220
also we have to perform some validity

968
00:45:14,220 --> 00:45:15,960
checks

969
00:45:15,960 --> 00:45:18,480
finally we would like to prove deleted

970
00:45:18,480 --> 00:45:20,460
resilience and to know a bit more about

971
00:45:20,460 --> 00:45:22,740
this family this family should include

972
00:45:22,740 --> 00:45:25,619
the function that given an index I star

973
00:45:25,619 --> 00:45:28,260
guesses whether this is the index of the

974
00:45:28,260 --> 00:45:30,300
first sampling function then that

975
00:45:30,300 --> 00:45:33,440
modifies the codeword

976
00:45:33,660 --> 00:45:35,760
um and the reason why G needs to have

977
00:45:35,760 --> 00:45:38,099
this function is that in that in that

978
00:45:38,099 --> 00:45:41,040
simulation uh it happens that this eye

979
00:45:41,040 --> 00:45:43,260
star is correct if and only if the

980
00:45:43,260 --> 00:45:45,119
reduction is performed in a correct

981
00:45:45,119 --> 00:45:46,619
simulation

982
00:45:46,619 --> 00:45:49,920
but not then in our case this requires

983
00:45:49,920 --> 00:45:51,180
Computing

984
00:45:51,180 --> 00:45:52,680
um the composition of a polynomial

985
00:45:52,680 --> 00:45:54,900
amount of dampering pump of decision

986
00:45:54,900 --> 00:45:57,180
trees that are Global

987
00:45:57,180 --> 00:45:58,920
um while reducing to split State normal

988
00:45:58,920 --> 00:46:00,960
ability that only provides granular

989
00:46:00,960 --> 00:46:03,660
guarantees

990
00:46:03,660 --> 00:46:05,579
um as you can imagine here this is

991
00:46:05,579 --> 00:46:08,339
something very hard to do and indeed we

992
00:46:08,339 --> 00:46:10,140
don't manage to do it we are not even

993
00:46:10,140 --> 00:46:12,660
sure whether this is possible so what we

994
00:46:12,660 --> 00:46:15,060
do is to move to an alternative approach

995
00:46:15,060 --> 00:46:17,040
so we don't check anymore whether this

996
00:46:17,040 --> 00:46:19,920
simulation is correct but we use a prior

997
00:46:19,920 --> 00:46:22,260
observation from ostrosky personal

998
00:46:22,260 --> 00:46:24,720
Venturian Visconti who noticed that

999
00:46:24,720 --> 00:46:26,520
sometimes one doesn't one doesn't need

1000
00:46:26,520 --> 00:46:28,319
to check whether a simulation is correct

1001
00:46:28,319 --> 00:46:31,500
it's enough to check whether an attacker

1002
00:46:31,500 --> 00:46:34,380
cancels its own Advantage due to a bad

1003
00:46:34,380 --> 00:46:36,980
simulation

1004
00:46:37,260 --> 00:46:39,420
um as you can see here we need to use

1005
00:46:39,420 --> 00:46:41,579
the information theoretic security of

1006
00:46:41,579 --> 00:46:43,020
the underlying to split State normal

1007
00:46:43,020 --> 00:46:45,300
level code because our reduction needs

1008
00:46:45,300 --> 00:46:47,339
to compute an advantage that involves

1009
00:46:47,339 --> 00:46:49,740
computation overall uh the possible

1010
00:46:49,740 --> 00:46:51,780
randomness

1011
00:46:51,780 --> 00:46:54,119
so to conclude the talk

1012
00:46:54,119 --> 00:46:56,280
um our first contribution is an

1013
00:46:56,280 --> 00:46:57,900
impossibility result in the

1014
00:46:57,900 --> 00:47:00,060
non-persistent setting that involves a

1015
00:47:00,060 --> 00:47:03,180
large amount of global sampling classes

1016
00:47:03,180 --> 00:47:05,160
therefore we move to the persistent

1017
00:47:05,160 --> 00:47:06,540
setting and that we provide two

1018
00:47:06,540 --> 00:47:09,420
constructions one for decision trees and

1019
00:47:09,420 --> 00:47:11,700
one for bounded depth tampering

1020
00:47:11,700 --> 00:47:15,119
as for open problem first note that our

1021
00:47:15,119 --> 00:47:17,579
decision pre-construction requires

1022
00:47:17,579 --> 00:47:19,260
computational assumption because it

1023
00:47:19,260 --> 00:47:21,599
involves signatures and as we said

1024
00:47:21,599 --> 00:47:23,040
before the bounded that construction

1025
00:47:23,040 --> 00:47:26,040
actually assumes address Etc so it would

1026
00:47:26,040 --> 00:47:28,140
be interesting to understand whether

1027
00:47:28,140 --> 00:47:30,540
these assumptions can be relaxed

1028
00:47:30,540 --> 00:47:32,640
and finally of course our bounded that

1029
00:47:32,640 --> 00:47:34,880
construction implies resilience against

1030
00:47:34,880 --> 00:47:39,119
constant constant tampering but it would

1031
00:47:39,119 --> 00:47:40,319
be interesting to have another

1032
00:47:40,319 --> 00:47:44,400
construction for ac0 that has improved

1033
00:47:44,400 --> 00:47:47,880
in efficiency and minimal assumptions

1034
00:47:47,880 --> 00:47:51,119
so uh this is the end of my thought uh

1035
00:47:51,119 --> 00:47:53,099
thanks a lot for listening and I'll be

1036
00:47:53,099 --> 00:47:56,000
happy to take questions

1037
00:48:02,280 --> 00:48:05,540
so questions

1038
00:48:07,260 --> 00:48:09,839
uh thank you can you briefly comment on

1039
00:48:09,839 --> 00:48:12,800
the impossibility result what kind of

1040
00:48:12,800 --> 00:48:15,060
approach to use there

1041
00:48:15,060 --> 00:48:18,720
yeah so actually this result is uh quite

1042
00:48:18,720 --> 00:48:21,720
of an an easy attack

1043
00:48:21,720 --> 00:48:23,880
um so the idea is that when you have

1044
00:48:23,880 --> 00:48:26,640
Global functions and you have the so the

1045
00:48:26,640 --> 00:48:29,700
non-persistent setting kind of always

1046
00:48:29,700 --> 00:48:32,339
um representates the old codeword okay

1047
00:48:32,339 --> 00:48:35,040
so the idea is that every tampering

1048
00:48:35,040 --> 00:48:36,599
function since we are in the continuous

1049
00:48:36,599 --> 00:48:38,819
setting reads like the eye tampering

1050
00:48:38,819 --> 00:48:41,280
function reads the height beat and

1051
00:48:41,280 --> 00:48:44,640
returns a codeword c0 if this bit is

1052
00:48:44,640 --> 00:48:47,880
zero and C1 if the bit is one

1053
00:48:47,880 --> 00:48:50,700
so the idea is that whenever you do this

1054
00:48:50,700 --> 00:48:53,700
attack then you you can get to know all

1055
00:48:53,700 --> 00:48:57,240
the bits of the quarter and then decode

1056
00:48:57,240 --> 00:48:59,839
okay

1057
00:49:00,720 --> 00:49:03,560
other questions

1058
00:49:12,060 --> 00:49:14,520
okay I think that's it then

1059
00:49:14,520 --> 00:49:17,579
um let's thank Elena again

1060
00:49:17,579 --> 00:49:20,720
switch to the last talk

1061
00:49:43,920 --> 00:49:46,520
foreign

1062
00:49:56,180 --> 00:49:59,160
so the last talk for this conference is

1063
00:49:59,160 --> 00:50:01,319
failing gracefully decrypting failures

1064
00:50:01,319 --> 00:50:04,920
in the fuchisaki OR okamoto transform uh

1065
00:50:04,920 --> 00:50:07,260
by Catherine Hermann Andreas Herzing and

1066
00:50:07,260 --> 00:50:11,599
Christian Mayans and Catherine

1067
00:50:12,380 --> 00:50:15,180
hey everyone can you hear me fine

1068
00:50:15,180 --> 00:50:17,700
okay perfect yeah thanks for the

1069
00:50:17,700 --> 00:50:19,680
introduction and for sticking around for

1070
00:50:19,680 --> 00:50:23,540
the last time of this conference

1071
00:50:24,859 --> 00:50:27,480
this work was motivated by taking

1072
00:50:27,480 --> 00:50:30,780
another look at how um encapsulation

1073
00:50:30,780 --> 00:50:32,940
mechanisms were constructed and proven

1074
00:50:32,940 --> 00:50:35,700
secure during the standardization

1075
00:50:35,700 --> 00:50:38,040
process

1076
00:50:38,040 --> 00:50:39,960
and what all of the constructions have

1077
00:50:39,960 --> 00:50:42,780
in common is that they start from a

1078
00:50:42,780 --> 00:50:44,700
computational problem there is a

1079
00:50:44,700 --> 00:50:46,619
passively secure pke scheme on that

1080
00:50:46,619 --> 00:50:47,819
problem

1081
00:50:47,819 --> 00:50:51,180
and that then um apply a sequence of

1082
00:50:51,180 --> 00:50:52,680
modifications

1083
00:50:52,680 --> 00:50:55,400
to achieve an actively secure

1084
00:50:55,400 --> 00:50:58,800
encapsulation mechanism and the sequence

1085
00:50:58,800 --> 00:51:02,300
of modifications is known as the

1086
00:51:02,300 --> 00:51:05,660
fujizakiokamoto transformation

1087
00:51:07,380 --> 00:51:10,440
um yeah originally the analysis was

1088
00:51:10,440 --> 00:51:12,119
performed under the assumption that

1089
00:51:12,119 --> 00:51:15,059
public encryption schemes always decrypt

1090
00:51:15,059 --> 00:51:16,680
correctly

1091
00:51:16,680 --> 00:51:19,980
which limited the applicability to

1092
00:51:19,980 --> 00:51:24,079
letters-based and code-based schemes

1093
00:51:24,119 --> 00:51:26,280
this is why the transformation was

1094
00:51:26,280 --> 00:51:29,520
Revisited in 2017.

1095
00:51:29,520 --> 00:51:32,460
where the impact of

1096
00:51:32,460 --> 00:51:34,920
correctness errors are decryption

1097
00:51:34,920 --> 00:51:37,740
failures was analyzed

1098
00:51:37,740 --> 00:51:40,380
and the publication also considered

1099
00:51:40,380 --> 00:51:41,400
different

1100
00:51:41,400 --> 00:51:45,119
um variants of how decapsulation could

1101
00:51:45,119 --> 00:51:49,260
handle invalid Cipher texts

1102
00:51:49,260 --> 00:51:51,540
yeah since we are now aiming for both

1103
00:51:51,540 --> 00:51:54,300
Quantum security and since Fuji

1104
00:51:54,300 --> 00:51:56,760
zakyokamoto was proven secure in the

1105
00:51:56,760 --> 00:51:58,380
random Oracle model

1106
00:51:58,380 --> 00:52:01,079
there has been an ongoing body of work

1107
00:52:01,079 --> 00:52:03,300
on proving fo secure and the quantum

1108
00:52:03,300 --> 00:52:04,859
random Oracle model

1109
00:52:04,859 --> 00:52:07,380
and this is where staff gets um kind of

1110
00:52:07,380 --> 00:52:09,720
surprising

1111
00:52:09,720 --> 00:52:13,680
so the first observation we made that is

1112
00:52:13,680 --> 00:52:16,079
that while the results in the random

1113
00:52:16,079 --> 00:52:19,680
Oracle model are kind of agnostic to how

1114
00:52:19,680 --> 00:52:23,220
we deal with um in valid sci-fi texts in

1115
00:52:23,220 --> 00:52:25,680
the quantum random Oracle model no

1116
00:52:25,680 --> 00:52:28,500
result was known for explicit rejection

1117
00:52:28,500 --> 00:52:30,540
for quite a long time

1118
00:52:30,540 --> 00:52:33,119
and even when such a Teresa become

1119
00:52:33,119 --> 00:52:34,619
became available

1120
00:52:34,619 --> 00:52:37,980
the bound was uh vastly different from

1121
00:52:37,980 --> 00:52:42,380
um the variant with implicit rejection

1122
00:52:43,559 --> 00:52:46,319
and the the second surprising thing is

1123
00:52:46,319 --> 00:52:48,839
that the quantum and Oracle model bound

1124
00:52:48,839 --> 00:52:50,960
contains a grover-like search term

1125
00:52:50,960 --> 00:52:54,599
relative to the failure probability

1126
00:52:54,599 --> 00:52:57,180
even though it was not apparent to us

1127
00:52:57,180 --> 00:53:00,059
that an attacker against NCCA security

1128
00:53:00,059 --> 00:53:02,940
since he doesn't have the secret key

1129
00:53:02,940 --> 00:53:06,180
can actually perform a Quantum search so

1130
00:53:06,180 --> 00:53:07,920
we were wondering whether these bounds

1131
00:53:07,920 --> 00:53:09,780
might be sub-optimal

1132
00:53:09,780 --> 00:53:13,079
and a more critical thing that holds

1133
00:53:13,079 --> 00:53:15,180
regardless of whether attackers are

1134
00:53:15,180 --> 00:53:17,640
classical or quantum

1135
00:53:17,640 --> 00:53:21,020
is that it was brought to our attention

1136
00:53:21,020 --> 00:53:24,240
that the concrete estimations for this

1137
00:53:24,240 --> 00:53:26,220
failure probability

1138
00:53:26,220 --> 00:53:30,300
are somewhat mismatching with what is

1139
00:53:30,300 --> 00:53:34,260
required during security proofs

1140
00:53:34,260 --> 00:53:36,780
and I will elaborate on this a bit more

1141
00:53:36,780 --> 00:53:40,680
so intuitively on a high level this um

1142
00:53:40,680 --> 00:53:43,380
error probability term corresponds to

1143
00:53:43,380 --> 00:53:45,780
the advantage in a correctness game or

1144
00:53:45,780 --> 00:53:48,000
failure finding game in which the

1145
00:53:48,000 --> 00:53:49,920
attacker is presented with a full key

1146
00:53:49,920 --> 00:53:52,920
pair has to find a message

1147
00:53:52,920 --> 00:53:55,440
that gets then encrypted decrypted and

1148
00:53:55,440 --> 00:53:59,280
we take a look whether decryption failed

1149
00:53:59,280 --> 00:54:01,260
so the first thing you might observe is

1150
00:54:01,260 --> 00:54:03,059
that this is kind of counterintuitive

1151
00:54:03,059 --> 00:54:05,520
because it contains the secret key

1152
00:54:05,520 --> 00:54:08,099
and in the NCCA game the attacker

1153
00:54:08,099 --> 00:54:11,180
certainly does not get that

1154
00:54:11,819 --> 00:54:15,599
and if you look at how these data terms

1155
00:54:15,599 --> 00:54:18,660
are estimated by specific schemes

1156
00:54:18,660 --> 00:54:21,599
the estimations follow this intuition

1157
00:54:21,599 --> 00:54:24,380
and bound the term

1158
00:54:24,380 --> 00:54:27,300
relative to a game that does without the

1159
00:54:27,300 --> 00:54:29,040
secret key

1160
00:54:29,040 --> 00:54:32,160
and this has as a consequence

1161
00:54:32,160 --> 00:54:35,460
that you might be able to use this um

1162
00:54:35,460 --> 00:54:38,099
estimation as a heuristic Bond

1163
00:54:38,099 --> 00:54:42,619
but not to formally verify it

1164
00:54:43,800 --> 00:54:46,260
yeah this is why we tried to tackle

1165
00:54:46,260 --> 00:54:49,140
these issues and uh our results in a

1166
00:54:49,140 --> 00:54:51,780
nutshell are tighter bounds for the

1167
00:54:51,780 --> 00:54:53,640
variant with explicit rejection for

1168
00:54:53,640 --> 00:54:55,200
randomized schemes

1169
00:54:55,200 --> 00:54:56,640
might quickly point out that

1170
00:54:56,640 --> 00:54:58,440
deterministic schemes were of little

1171
00:54:58,440 --> 00:55:00,420
interest to us because they are usually

1172
00:55:00,420 --> 00:55:02,700
perfectly correct anyways

1173
00:55:02,700 --> 00:55:04,920
these results align the Quran results

1174
00:55:04,920 --> 00:55:07,079
for the two rejection types which is

1175
00:55:07,079 --> 00:55:08,940
kind of nice from a conceptual point of

1176
00:55:08,940 --> 00:55:09,900
view

1177
00:55:09,900 --> 00:55:13,859
and the bonds we achieved work

1178
00:55:13,859 --> 00:55:16,859
without the secret key meaning that they

1179
00:55:16,859 --> 00:55:21,779
are compatible with estimated Scripts

1180
00:55:23,240 --> 00:55:27,540
in a bit more detail uh the NCCA bound

1181
00:55:27,540 --> 00:55:31,500
we obtain for the fo transformed chem by

1182
00:55:31,500 --> 00:55:34,920
down into a sum of three terms

1183
00:55:34,920 --> 00:55:39,300
the first term is just the um

1184
00:55:39,300 --> 00:55:41,400
the key and distinguishability term if

1185
00:55:41,400 --> 00:55:45,240
an attacker would not have a CCA Oracle

1186
00:55:45,240 --> 00:55:48,240
and it boils down to a bound that is not

1187
00:55:48,240 --> 00:55:49,980
very surprising to people who are

1188
00:55:49,980 --> 00:55:53,160
familiar with previous fo bounds in the

1189
00:55:53,160 --> 00:55:54,960
Quran

1190
00:55:54,960 --> 00:55:56,880
so essentially it boils down to the

1191
00:55:56,880 --> 00:55:58,619
square root of the number of queries

1192
00:55:58,619 --> 00:56:01,200
posed by the attacker times uh the

1193
00:56:01,200 --> 00:56:04,440
advantage against the underlying scheme

1194
00:56:04,440 --> 00:56:07,500
and the way we obtained this bound is by

1195
00:56:07,500 --> 00:56:09,240
applying see my classical one-way to

1196
00:56:09,240 --> 00:56:11,700
hiding we had to tailor it a bit but I

1197
00:56:11,700 --> 00:56:13,740
will talk about this later

1198
00:56:13,740 --> 00:56:16,200
and people who know previous results

1199
00:56:16,200 --> 00:56:18,240
might be wondering why we did not use

1200
00:56:18,240 --> 00:56:21,119
double-sided one way to hiding

1201
00:56:21,119 --> 00:56:23,579
or metal rewind measure because they are

1202
00:56:23,579 --> 00:56:27,079
usually um assumed to be

1203
00:56:27,079 --> 00:56:30,319
tighter than

1204
00:56:31,260 --> 00:56:34,440
I'm sorry they usually are assumed to be

1205
00:56:34,440 --> 00:56:37,140
tighter than um see my classical one way

1206
00:56:37,140 --> 00:56:38,940
to hiding but um

1207
00:56:38,940 --> 00:56:41,220
the problem is that we are only

1208
00:56:41,220 --> 00:56:43,020
considering randomized schemes and in

1209
00:56:43,020 --> 00:56:46,559
this scenario uh one way to hiding in

1210
00:56:46,559 --> 00:56:50,760
these tighter versions is not applicable

1211
00:56:50,760 --> 00:56:52,740
and we would obtain a bound that is

1212
00:56:52,740 --> 00:56:55,440
essentially the same or even

1213
00:56:55,440 --> 00:56:57,119
um probably worse for practical

1214
00:56:57,119 --> 00:56:59,780
parameters

1215
00:57:02,460 --> 00:57:06,240
okay the second term is a term in um in

1216
00:57:06,240 --> 00:57:10,260
terms of entropy of the pke scheme this

1217
00:57:10,260 --> 00:57:13,140
is usually quite PK is redness and you

1218
00:57:13,140 --> 00:57:15,300
can Envision it as the entropy of the

1219
00:57:15,300 --> 00:57:17,160
encryption algorithm

1220
00:57:17,160 --> 00:57:20,040
and um as I already mentioned we only

1221
00:57:20,040 --> 00:57:24,300
know of one uh CCA Bond against explicit

1222
00:57:24,300 --> 00:57:25,740
fo

1223
00:57:25,740 --> 00:57:28,680
and if we compare our spreadness term

1224
00:57:28,680 --> 00:57:30,599
with the one that was previously

1225
00:57:30,599 --> 00:57:33,420
available carbon Compares quite

1226
00:57:33,420 --> 00:57:35,960
favorably

1227
00:57:37,260 --> 00:57:39,240
yeah now we're going

1228
00:57:39,240 --> 00:57:41,520
to the term I find most interesting

1229
00:57:41,520 --> 00:57:44,700
which is oh sorry I wanted to mention

1230
00:57:44,700 --> 00:57:47,460
first that the boundary obtain also

1231
00:57:47,460 --> 00:57:49,200
works for the version with implicit

1232
00:57:49,200 --> 00:57:51,540
rejection due to an implication result

1233
00:57:51,540 --> 00:57:56,400
that was present presented at TCC 2019.

1234
00:57:56,400 --> 00:57:59,040
and we would conjecture that for for

1235
00:57:59,040 --> 00:58:01,559
this case a smaller T spread would be

1236
00:58:01,559 --> 00:58:04,020
possible by doing a direct proof instead

1237
00:58:04,020 --> 00:58:08,240
of relying on the implication result

1238
00:58:08,420 --> 00:58:11,880
okay now now comes the term that might

1239
00:58:11,880 --> 00:58:14,460
be most interesting the failure term

1240
00:58:14,460 --> 00:58:16,380
uh essentially

1241
00:58:16,380 --> 00:58:18,900
um we will give different variants to

1242
00:58:18,900 --> 00:58:21,660
bond this term but all of them are

1243
00:58:21,660 --> 00:58:24,000
defined as the game advantage in a

1244
00:58:24,000 --> 00:58:26,160
failure finding game without having the

1245
00:58:26,160 --> 00:58:28,079
secret key and if we compare to previous

1246
00:58:28,079 --> 00:58:29,220
work

1247
00:58:29,220 --> 00:58:31,440
we see a grover-like pound as I already

1248
00:58:31,440 --> 00:58:35,400
mentioned and we see uh that a data pops

1249
00:58:35,400 --> 00:58:37,319
up which is this failure finding

1250
00:58:37,319 --> 00:58:39,119
probability when the attacker has the

1251
00:58:39,119 --> 00:58:40,619
secret key

1252
00:58:40,619 --> 00:58:43,859
so a first contribution is to get rid of

1253
00:58:43,859 --> 00:58:48,619
this secret key thingy and data

1254
00:58:51,299 --> 00:58:54,720
yeah the first way to bound it is uh the

1255
00:58:54,720 --> 00:58:56,160
most natural way when it comes to

1256
00:58:56,160 --> 00:58:58,200
plugging in the bound into our security

1257
00:58:58,200 --> 00:58:59,520
proof

1258
00:58:59,520 --> 00:59:02,040
there we have a failure Checker like we

1259
00:59:02,040 --> 00:59:04,559
saw on one of the first slides

1260
00:59:04,559 --> 00:59:07,559
with a CCA Oracle instead of the secret

1261
00:59:07,559 --> 00:59:09,720
key

1262
00:59:09,720 --> 00:59:13,020
um however the notion is performed in a

1263
00:59:13,020 --> 00:59:15,000
somewhat contrived Quantum random Oracle

1264
00:59:15,000 --> 00:59:15,780
model

1265
00:59:15,780 --> 00:59:19,440
and we do not bound yet against

1266
00:59:19,440 --> 00:59:22,140
um a property of the underlying pke

1267
00:59:22,140 --> 00:59:23,819
scheme but rather

1268
00:59:23,819 --> 00:59:26,700
the pke scheme when it's being

1269
00:59:26,700 --> 00:59:29,160
derandomized which is a common step in

1270
00:59:29,160 --> 00:59:32,839
the fujizaki okamoto transformation

1271
00:59:34,500 --> 00:59:37,020
yeah so this is a tight Bond however

1272
00:59:37,020 --> 00:59:40,440
it's not very handy for people who are

1273
00:59:40,440 --> 00:59:43,380
actually designing schemes

1274
00:59:43,380 --> 00:59:46,079
and might want to bounce something in a

1275
00:59:46,079 --> 00:59:48,900
more simple way

1276
00:59:48,900 --> 00:59:51,780
so the first idea was to get rid of the

1277
00:59:51,780 --> 00:59:53,579
CCA article

1278
00:59:53,579 --> 00:59:56,700
by doing a reduction towards a game in

1279
00:59:56,700 --> 00:59:58,619
which the attacker only is presented

1280
00:59:58,619 --> 01:00:01,920
with a public key not the CCA Oracle but

1281
01:00:01,920 --> 01:00:03,420
we're still stuck with the somewhat

1282
01:00:03,420 --> 01:00:06,799
contrived random Oracle model

1283
01:00:10,559 --> 01:00:12,660
this is why we decided to break down

1284
01:00:12,660 --> 01:00:15,359
this term in a generic way to make it

1285
01:00:15,359 --> 01:00:17,640
more accessible to skin designers

1286
01:00:17,640 --> 01:00:20,040
so the goal of this further breaking

1287
01:00:20,040 --> 01:00:22,559
down is to give bounce in terms of the

1288
01:00:22,559 --> 01:00:24,780
underlying pke scheme not the randomized

1289
01:00:24,780 --> 01:00:25,920
version

1290
01:00:25,920 --> 01:00:28,020
and with no contrived random Oracle

1291
01:00:28,020 --> 01:00:29,280
model anymore

1292
01:00:29,280 --> 01:00:32,339
and this is when we will end up with a

1293
01:00:32,339 --> 01:00:34,859
term that is compatible with existing

1294
01:00:34,859 --> 01:00:38,598
data estimator Scripts

1295
01:00:39,480 --> 01:00:42,119
so intuitively if you think about how

1296
01:00:42,119 --> 01:00:45,480
you could attack such a pke scheme where

1297
01:00:45,480 --> 01:00:49,020
the encryptions are um directly tied to

1298
01:00:49,020 --> 01:00:50,119
message

1299
01:00:50,119 --> 01:00:53,280
because the randomness used is the hash

1300
01:00:53,280 --> 01:00:54,960
value of the message

1301
01:00:54,960 --> 01:00:57,119
you could do two things you could try to

1302
01:00:57,119 --> 01:00:59,819
look for um message Randomness pairs

1303
01:00:59,819 --> 01:01:01,799
that are particularly bad for a

1304
01:01:01,799 --> 01:01:04,740
particular publicly secret key pair

1305
01:01:04,740 --> 01:01:06,720
or you could try to look for Randomness

1306
01:01:06,720 --> 01:01:08,640
that is just so large that it will

1307
01:01:08,640 --> 01:01:11,779
always mess things up

1308
01:01:12,119 --> 01:01:15,359
the first the first case corresponds to

1309
01:01:15,359 --> 01:01:17,819
finding non-generic or key dependent

1310
01:01:17,819 --> 01:01:20,760
failures for pkes which we encapsulate

1311
01:01:20,760 --> 01:01:22,319
in this game

1312
01:01:22,319 --> 01:01:24,839
where the task of the attacker is to

1313
01:01:24,839 --> 01:01:26,880
take Keepers approach with a single

1314
01:01:26,880 --> 01:01:29,579
that's the sphere query so we have two

1315
01:01:29,579 --> 01:01:31,619
key pairs the attacker only gets one

1316
01:01:31,619 --> 01:01:34,260
public key and has to craft a message

1317
01:01:34,260 --> 01:01:35,640
and a randomness

1318
01:01:35,640 --> 01:01:38,940
that will fail to decrypt for this key

1319
01:01:38,940 --> 01:01:42,260
pair but not the other

1320
01:01:45,799 --> 01:01:48,540
intuitively we assume that this

1321
01:01:48,540 --> 01:01:51,180
probability can be related to ncpa

1322
01:01:51,180 --> 01:01:53,460
security for a letters-based schemes

1323
01:01:53,460 --> 01:01:57,240
because crafting such a randomness

1324
01:01:57,240 --> 01:02:01,740
would probably be um useful to to solve

1325
01:02:01,740 --> 01:02:05,098
decision lwe

1326
01:02:07,020 --> 01:02:10,799
the second probability we are using here

1327
01:02:10,799 --> 01:02:14,220
is um finding generic failures meaning

1328
01:02:14,220 --> 01:02:17,640
uh yeah searching for for large

1329
01:02:17,640 --> 01:02:19,740
randomnesses that will trigger

1330
01:02:19,740 --> 01:02:22,079
decryption failure and we encapsulate

1331
01:02:22,079 --> 01:02:23,880
this and again where the attacker gets a

1332
01:02:23,880 --> 01:02:25,200
message

1333
01:02:25,200 --> 01:02:27,960
and only afterwards a key pair is even

1334
01:02:27,960 --> 01:02:30,480
generated so the only attack menu really

1335
01:02:30,480 --> 01:02:31,319
is

1336
01:02:31,319 --> 01:02:35,160
to search the randomness generating hash

1337
01:02:35,160 --> 01:02:39,440
function for a large randomness

1338
01:02:39,660 --> 01:02:43,400
and Via a new analysis and the Quran

1339
01:02:43,400 --> 01:02:46,740
that analyzes how easy it is to find

1340
01:02:46,740 --> 01:02:49,799
large value bounds

1341
01:02:49,799 --> 01:02:53,280
we achieved the following bounds

1342
01:02:53,280 --> 01:02:57,380
so the generic failure term is a sum of

1343
01:02:57,380 --> 01:03:00,500
Delta tilde where digital filter can be

1344
01:03:00,500 --> 01:03:03,780
where you can plug in a computer data

1345
01:03:03,780 --> 01:03:06,960
data estimations for data Etc

1346
01:03:06,960 --> 01:03:09,299
thus an additional term which is also

1347
01:03:09,299 --> 01:03:11,579
relative to data tilde

1348
01:03:11,579 --> 01:03:14,040
and if you already know that your

1349
01:03:14,040 --> 01:03:17,160
failure envelope has a gaussian tailbond

1350
01:03:17,160 --> 01:03:19,400
you can plug in for a

1351
01:03:19,400 --> 01:03:21,660
t t Delta

1352
01:03:21,660 --> 01:03:24,839
the sub logarithmic bound you see in the

1353
01:03:24,839 --> 01:03:27,240
second line

1354
01:03:27,240 --> 01:03:29,400
and otherwise we give an alternative

1355
01:03:29,400 --> 01:03:32,220
bound which has a loss of the number of

1356
01:03:32,220 --> 01:03:34,559
random Oracle queries

1357
01:03:34,559 --> 01:03:36,599
and is in terms of the decryption

1358
01:03:36,599 --> 01:03:38,579
failure rate variance which

1359
01:03:38,579 --> 01:03:40,319
pessimistically you can upper Bound by

1360
01:03:40,319 --> 01:03:44,099
Delta tilde as well but we believe that

1361
01:03:44,099 --> 01:03:46,020
for letters-based schemes this Bond

1362
01:03:46,020 --> 01:03:48,799
might be way better

1363
01:03:50,700 --> 01:03:52,680
yeah before wrapping up I will just

1364
01:03:52,680 --> 01:03:55,020
quickly uh sketch the proof technique

1365
01:03:55,020 --> 01:03:56,760
that we were using

1366
01:03:56,760 --> 01:03:59,700
so the idea for foofs usually goes as

1367
01:03:59,700 --> 01:04:02,160
follows we have this Randomness

1368
01:04:02,160 --> 01:04:04,319
generating hash function

1369
01:04:04,319 --> 01:04:07,319
that will type messages to sci-fi texts

1370
01:04:07,319 --> 01:04:08,640
implicitly

1371
01:04:08,640 --> 01:04:12,119
and why we are doing a simulation of the

1372
01:04:12,119 --> 01:04:14,400
CCA Oracle

1373
01:04:14,400 --> 01:04:17,099
we can make use of the fact that we are

1374
01:04:17,099 --> 01:04:20,040
able to book a patient queries that

1375
01:04:20,040 --> 01:04:22,020
workforced by the attacker

1376
01:04:22,020 --> 01:04:24,960
that will allow us to find free images

1377
01:04:24,960 --> 01:04:28,079
for sci-fi texts on which the CCA Oracle

1378
01:04:28,079 --> 01:04:29,400
is queried

1379
01:04:29,400 --> 01:04:31,980
so we keep every Everything consistent

1380
01:04:31,980 --> 01:04:35,520
by extracting a pre-image intuitively

1381
01:04:35,520 --> 01:04:38,700
and the qram idea now is to

1382
01:04:38,700 --> 01:04:41,040
um translate this technique to the

1383
01:04:41,040 --> 01:04:44,299
quantum random Oracle model

1384
01:04:44,700 --> 01:04:47,940
yeah the first Technique we are using is

1385
01:04:47,940 --> 01:04:49,980
simulating the Quantum random Oracle

1386
01:04:49,980 --> 01:04:52,380
model by a compressed or rexner

1387
01:04:52,380 --> 01:04:55,819
in the style of Sentry

1388
01:04:56,160 --> 01:04:59,880
but we extend this technique by the

1389
01:04:59,880 --> 01:05:03,540
technique that was given in dfms 2020

1390
01:05:03,540 --> 01:05:05,400
in which

1391
01:05:05,400 --> 01:05:07,799
extractable Quantum random Oracle models

1392
01:05:07,799 --> 01:05:09,119
were introduced

1393
01:05:09,119 --> 01:05:11,460
and why is it quite extractable Quantum

1394
01:05:11,460 --> 01:05:16,380
random Oracle because in our reduction

1395
01:05:16,380 --> 01:05:19,740
we do not only obtain access to the

1396
01:05:19,740 --> 01:05:22,140
quantum random marker but also to an

1397
01:05:22,140 --> 01:05:24,720
extraction interface that is defined

1398
01:05:24,720 --> 01:05:27,720
relative to a function f that Maps

1399
01:05:27,720 --> 01:05:30,180
Oracle input output space to a Target

1400
01:05:30,180 --> 01:05:32,099
space t

1401
01:05:32,099 --> 01:05:36,059
and whenever the extraction interface is

1402
01:05:36,059 --> 01:05:38,640
queried on a Target value T it will

1403
01:05:38,640 --> 01:05:40,920
perform a dedicated measurement

1404
01:05:40,920 --> 01:05:42,839
which has the consequence that the

1405
01:05:42,839 --> 01:05:45,480
Oracle database collapses in such a way

1406
01:05:45,480 --> 01:05:49,160
that for one of the input values

1407
01:05:49,160 --> 01:05:51,200
there are no

1408
01:05:51,200 --> 01:05:53,700
possible output values contained in the

1409
01:05:53,700 --> 01:05:55,980
database superposition anymore that

1410
01:05:55,980 --> 01:05:58,920
would not be mapped to t under f

1411
01:05:58,920 --> 01:06:01,619
and afterwards we return the input value

1412
01:06:01,619 --> 01:06:04,020
for which this happened why is this

1413
01:06:04,020 --> 01:06:06,500
useful

1414
01:06:06,660 --> 01:06:09,420
in rfo proof we can

1415
01:06:09,420 --> 01:06:13,200
identify f with the encryption function

1416
01:06:13,200 --> 01:06:15,839
and this has the as a consequence that

1417
01:06:15,839 --> 01:06:17,880
the extraction interface when queried on

1418
01:06:17,880 --> 01:06:19,440
the site for txc

1419
01:06:19,440 --> 01:06:22,380
will always return a pre-image m

1420
01:06:22,380 --> 01:06:25,140
and this is a pretty compatible with

1421
01:06:25,140 --> 01:06:26,700
what we did in the random Oracle model

1422
01:06:26,700 --> 01:06:29,760
before where we only did bookkeeping and

1423
01:06:29,760 --> 01:06:33,720
used this to to look at the messages

1424
01:06:33,720 --> 01:06:36,660
what we need during the proof is that

1425
01:06:36,660 --> 01:06:38,819
this extraction interface commutes

1426
01:06:38,819 --> 01:06:43,099
nicely with the random Oracle operations

1427
01:06:44,039 --> 01:06:47,760
and luckily um those who

1428
01:06:47,760 --> 01:06:50,280
um functions commute nicely if ever

1429
01:06:50,280 --> 01:06:52,200
sufficiently surprising which in our

1430
01:06:52,200 --> 01:06:54,299
case translates to the spreadness of the

1431
01:06:54,299 --> 01:06:57,180
pke scheme

1432
01:06:57,180 --> 01:07:00,960
our contribution in this area is that we

1433
01:07:00,960 --> 01:07:02,220
approved

1434
01:07:02,220 --> 01:07:04,920
one way to hiding in the extractable

1435
01:07:04,920 --> 01:07:07,440
Quran one way to hiding is the common

1436
01:07:07,440 --> 01:07:09,059
technique to argue key

1437
01:07:09,059 --> 01:07:11,900
indistinguishability

1438
01:07:12,720 --> 01:07:15,780
yeah wrapping up we achieved a tighter

1439
01:07:15,780 --> 01:07:18,359
Bound for fujizaki okamoto with explicit

1440
01:07:18,359 --> 01:07:19,619
rejection

1441
01:07:19,619 --> 01:07:21,660
and gave an alternative bond for

1442
01:07:21,660 --> 01:07:23,400
implicit rejection

1443
01:07:23,400 --> 01:07:26,180
we analyzed the impact of

1444
01:07:26,180 --> 01:07:29,280
decryption failures on security in a way

1445
01:07:29,280 --> 01:07:31,500
that is more fine print and hopefully

1446
01:07:31,500 --> 01:07:34,079
more accessible to skin designers

1447
01:07:34,079 --> 01:07:36,839
and that does without heuristic bonds

1448
01:07:36,839 --> 01:07:39,660
and on the way we also proved some Quran

1449
01:07:39,660 --> 01:07:41,700
tools that might be of independent

1450
01:07:41,700 --> 01:07:43,319
interest

1451
01:07:43,319 --> 01:07:45,599
yeah thanks for the attention and I'm

1452
01:07:45,599 --> 01:07:49,039
happy to take any questions

1453
01:08:02,400 --> 01:08:05,240
any questions

1454
01:08:23,040 --> 01:08:27,479
well if there aren't aren't any then

1455
01:08:27,479 --> 01:08:33,000
oh let's thank Katrina again and

1456
01:08:37,799 --> 01:08:40,560
uh and I should remind everyone that the

1457
01:08:40,560 --> 01:08:42,779
closing ceremony is now in the other

1458
01:08:42,779 --> 01:08:44,640
other Hall

1459
01:08:44,640 --> 01:08:47,120
so

1460
01:09:02,339 --> 01:09:05,339
foreign

1461
01:09:07,420 --> 01:09:10,520
[Music]

1462
01:09:29,939 --> 01:09:32,778
thank you

1463
01:10:02,280 --> 01:10:04,759
foreign

1464
01:10:37,440 --> 01:10:40,339
foreign

