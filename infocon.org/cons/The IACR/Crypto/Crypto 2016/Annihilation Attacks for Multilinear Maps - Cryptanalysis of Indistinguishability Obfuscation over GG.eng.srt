1
00:00:04,069 --> 00:00:06,540
okay thanks for the introduction hi

2
00:00:06,540 --> 00:00:08,970
everyone so yeah so this is joint work

3
00:00:08,970 --> 00:00:12,509
with with Amit and mark so if you've

4
00:00:12,509 --> 00:00:13,769
been in this room today you probably

5
00:00:13,769 --> 00:00:16,049
already know what IO is but let me let

6
00:00:16,049 --> 00:00:18,260
me just say one slide about it anyway so

7
00:00:18,260 --> 00:00:21,810
IO is this notion of of compiling a

8
00:00:21,810 --> 00:00:24,480
program P in a way that preserves its

9
00:00:24,480 --> 00:00:28,620
functionality but for any program P PI P

10
00:00:28,620 --> 00:00:29,970
prime which is equivalent to it

11
00:00:29,970 --> 00:00:31,380
the compilations of these two are

12
00:00:31,380 --> 00:00:33,079
indistinguishable from each other hence

13
00:00:33,079 --> 00:00:35,820
indistinguishability obfuscation so this

14
00:00:35,820 --> 00:00:38,399
was first proposed by Barak at all in

15
00:00:38,399 --> 00:00:41,640
2001 but the first candidate didn't come

16
00:00:41,640 --> 00:00:44,159
until twelve years later on the work of

17
00:00:44,159 --> 00:00:47,999
Gargan all hmm so at this point we have

18
00:00:47,999 --> 00:00:51,510
many many applications of IO and it has

19
00:00:51,510 --> 00:00:54,120
become a central hub of crypto a holy

20
00:00:54,120 --> 00:00:55,679
grail of crypto whatever you want to

21
00:00:55,679 --> 00:00:57,719
call it it's become a very important

22
00:00:57,719 --> 00:01:00,899
thing and we have many candidates for it

23
00:01:00,899 --> 00:01:03,749
but the security of these is not very

24
00:01:03,749 --> 00:01:07,470
well understood right now okay so you

25
00:01:07,470 --> 00:01:09,090
just sort of talk about multi linear

26
00:01:09,090 --> 00:01:11,820
maps so indeed all of the i/o candidates

27
00:01:11,820 --> 00:01:15,479
we have rely on multi linear maps you

28
00:01:15,479 --> 00:01:17,399
can think of multilinear maps at a very

29
00:01:17,399 --> 00:01:19,350
high level sort of like homomorphic

30
00:01:19,350 --> 00:01:21,840
encryption in the sense that you have a

31
00:01:21,840 --> 00:01:23,460
bunch of encoded elements and you can do

32
00:01:23,460 --> 00:01:25,979
arithmetic on them the difference is

33
00:01:25,979 --> 00:01:28,380
that in multilinear maps there's no

34
00:01:28,380 --> 00:01:30,000
decryption instead we have this thing

35
00:01:30,000 --> 00:01:33,960
called a zero test procedure and and you

36
00:01:33,960 --> 00:01:35,640
can't zero test everything only certain

37
00:01:35,640 --> 00:01:37,590
encodings that are well-formed can be

38
00:01:37,590 --> 00:01:39,329
zero tested I'll say what well-formed

39
00:01:39,329 --> 00:01:42,450
means when it becomes important so yeah

40
00:01:42,450 --> 00:01:44,030
we have several M map candidates

41
00:01:44,030 --> 00:01:46,950
tancredi's just talking about the the

42
00:01:46,950 --> 00:01:49,079
last of these and in this talk I'm going

43
00:01:49,079 --> 00:01:51,689
to focus on the the first of these which

44
00:01:51,689 --> 00:01:54,060
was the original candidate due to guard

45
00:01:54,060 --> 00:01:58,079
gentry and Halevi okay so I just

46
00:01:58,079 --> 00:02:01,710
mentioned the zero testing so ideally in

47
00:02:01,710 --> 00:02:03,060
these in these multi linear map

48
00:02:03,060 --> 00:02:05,399
candidates zero test should just reveal

49
00:02:05,399 --> 00:02:07,590
whether an encoding is zero or not and

50
00:02:07,590 --> 00:02:08,610
that's it

51
00:02:08,610 --> 00:02:10,710
but in practice all of the zero test

52
00:02:10,710 --> 00:02:13,140
procedures actually reveal some sort of

53
00:02:13,140 --> 00:02:15,180
leakage so you can you can visualize

54
00:02:15,180 --> 00:02:17,129
this as follows you have some initial

55
00:02:17,129 --> 00:02:17,520
set

56
00:02:17,520 --> 00:02:20,100
in coatings you do some home amorphic

57
00:02:20,100 --> 00:02:23,250
computation on them and you get a top

58
00:02:23,250 --> 00:02:24,630
level encoding here a top level

59
00:02:24,630 --> 00:02:28,920
well-formed it's the same thing and and

60
00:02:28,920 --> 00:02:30,210
then you might feed that through the

61
00:02:30,210 --> 00:02:33,510
zero test and indeed you will get out a

62
00:02:33,510 --> 00:02:36,360
bit that says zero one but you also get

63
00:02:36,360 --> 00:02:40,080
some some leakage and I'll say more what

64
00:02:40,080 --> 00:02:42,870
that leakage looks like okay but let me

65
00:02:42,870 --> 00:02:44,640
let me first tell you what our results

66
00:02:44,640 --> 00:02:47,280
in this paper are so we give the first

67
00:02:47,280 --> 00:02:49,290
polynomial time crypt analysis of

68
00:02:49,290 --> 00:02:52,650
several i/o candidates and so this is a

69
00:02:52,650 --> 00:02:54,450
distinguishing attack so we you know we

70
00:02:54,450 --> 00:02:56,310
produce two equivalent programs and we

71
00:02:56,310 --> 00:02:58,080
show how to distinguish their

72
00:02:58,080 --> 00:03:00,510
obfuscation and in this paper we also

73
00:03:00,510 --> 00:03:02,310
have an attack on the order revealing

74
00:03:02,310 --> 00:03:04,650
encryption scheme due to Bonet at all

75
00:03:04,650 --> 00:03:05,790
I'm not going to go into those details

76
00:03:05,790 --> 00:03:07,440
because it's very similar to the attack

77
00:03:07,440 --> 00:03:12,060
on i/o also in this paper we propose a

78
00:03:12,060 --> 00:03:14,760
new security model which for the first

79
00:03:14,760 --> 00:03:18,030
time actually captures all of the known

80
00:03:18,030 --> 00:03:21,600
polynomial time attacks on ggh 13 and

81
00:03:21,600 --> 00:03:23,040
I'll say more about the model at the

82
00:03:23,040 --> 00:03:25,950
very end but just to give you a sense of

83
00:03:25,950 --> 00:03:28,110
the high-level structure of the attack

84
00:03:28,110 --> 00:03:31,440
is a very high level so we observed that

85
00:03:31,440 --> 00:03:34,440
the leakage produced by zero test can be

86
00:03:34,440 --> 00:03:35,790
represented or can be thought of as an

87
00:03:35,790 --> 00:03:38,280
explicit polynomial which is computed

88
00:03:38,280 --> 00:03:40,620
over the underlying multi linear map

89
00:03:40,620 --> 00:03:44,190
variables so we you know we take the

90
00:03:44,190 --> 00:03:46,230
obfuscation we evaluate it on many

91
00:03:46,230 --> 00:03:48,209
inputs and 0 tests the result and

92
00:03:48,209 --> 00:03:50,430
collect all the leakage and then we find

93
00:03:50,430 --> 00:03:51,810
what's known as an annihilating

94
00:03:51,810 --> 00:03:54,000
polynomial that basically that cancels

95
00:03:54,000 --> 00:03:55,260
all of this leakage so it takes all of

96
00:03:55,260 --> 00:03:57,450
the results of the leakage and you feed

97
00:03:57,450 --> 00:03:58,860
it through this annihilating polynomial

98
00:03:58,860 --> 00:04:01,410
and it spits out 0 if you had one of the

99
00:04:01,410 --> 00:04:03,150
programs and if instead the Optio

100
00:04:03,150 --> 00:04:04,620
obfuscation was of the other program

101
00:04:04,620 --> 00:04:06,540
then the annihilating polynomial will

102
00:04:06,540 --> 00:04:07,890
spit out something else so in this way

103
00:04:07,890 --> 00:04:13,170
we get a distinguishing attack ok so

104
00:04:13,170 --> 00:04:14,670
this is a let me this is the outline for

105
00:04:14,670 --> 00:04:16,350
the rest of the talk first I'm going to

106
00:04:16,350 --> 00:04:18,720
give a little bit of background on Io

107
00:04:18,720 --> 00:04:21,209
and multilinear maps and then I'm going

108
00:04:21,209 --> 00:04:22,890
to give an overview of the attack and

109
00:04:22,890 --> 00:04:24,360
then finally I'll talk about the new

110
00:04:24,360 --> 00:04:26,520
security model I mentioned and some

111
00:04:26,520 --> 00:04:27,890
subsequent work that's already been done

112
00:04:27,890 --> 00:04:31,139
regarding this model

113
00:04:31,139 --> 00:04:34,679
okay so first of all the sort of model

114
00:04:34,679 --> 00:04:36,209
of computation in this talk I'm going to

115
00:04:36,209 --> 00:04:37,619
care about is what's called matrix

116
00:04:37,619 --> 00:04:40,679
branching programs so there are many

117
00:04:40,679 --> 00:04:43,979
candidates for 4io starting from matrix

118
00:04:43,979 --> 00:04:46,379
branching programs there's also many

119
00:04:46,379 --> 00:04:49,739
candidates for i/o a growing body that

120
00:04:49,739 --> 00:04:52,229
start from just circuits I'm not going

121
00:04:52,229 --> 00:04:53,429
to talk about the ones that start from

122
00:04:53,429 --> 00:04:55,309
circuits at all I'm just gonna focus on

123
00:04:55,309 --> 00:04:59,909
io4 matrix branching programs and this

124
00:04:59,909 --> 00:05:02,249
is enough to to get i/o for all

125
00:05:02,249 --> 00:05:04,709
polynomial time computation via some

126
00:05:04,709 --> 00:05:06,149
bootstrapping theorems but I'm just

127
00:05:06,149 --> 00:05:09,360
gonna focus on on branching programs so

128
00:05:09,360 --> 00:05:11,939
a matrix branching program is is

129
00:05:11,939 --> 00:05:13,829
basically a set of matrices that are

130
00:05:13,829 --> 00:05:16,229
sorted into layers and then you have to

131
00:05:16,229 --> 00:05:19,469
bookend vectors okay and each layer is

132
00:05:19,469 --> 00:05:23,669
associated with some input bit okay so

133
00:05:23,669 --> 00:05:25,439
that's it is just matrices and and two

134
00:05:25,439 --> 00:05:27,659
vectors on the end and the way you

135
00:05:27,659 --> 00:05:30,059
evaluate the matrix parenting program on

136
00:05:30,059 --> 00:05:33,659
some input X so you always have the you

137
00:05:33,659 --> 00:05:34,829
know the first book end and the last

138
00:05:34,829 --> 00:05:36,899
book in vector there and then for the

139
00:05:36,899 --> 00:05:38,699
middle ones you you just pick the matrix

140
00:05:38,699 --> 00:05:41,009
that corresponds to the the value of the

141
00:05:41,009 --> 00:05:44,849
bit that that you're reading right so if

142
00:05:44,849 --> 00:05:47,729
x i1 was 0 then then the first one would

143
00:05:47,729 --> 00:05:49,949
be this matrix and if x i2 was 1 then

144
00:05:49,949 --> 00:05:50,969
you get this one and so on

145
00:05:50,969 --> 00:05:53,399
so each input selects a subset of the

146
00:05:53,399 --> 00:05:54,479
matrices and you and you multiply

147
00:05:54,479 --> 00:05:59,009
through okay and in particular the

148
00:05:59,009 --> 00:06:01,229
output of this function is 0 or 1

149
00:06:01,229 --> 00:06:03,599
depending on whether this product is 0

150
00:06:03,599 --> 00:06:05,249
or 1 right so we just care if it's 0 or

151
00:06:05,249 --> 00:06:08,610
not not not what the actual value is

152
00:06:08,610 --> 00:06:13,739
beyond that okay so what's the standard

153
00:06:13,739 --> 00:06:17,039
recipe for fry Oh at this point most of

154
00:06:17,039 --> 00:06:18,869
the matrix branching program io

155
00:06:18,869 --> 00:06:22,169
candidates follow this recipe with some

156
00:06:22,169 --> 00:06:24,269
different bells and whistles on on each

157
00:06:24,269 --> 00:06:25,709
one but this is sort of the core

158
00:06:25,709 --> 00:06:27,929
technique here so we start with the

159
00:06:27,929 --> 00:06:29,489
branching programs I just described

160
00:06:29,489 --> 00:06:32,279
first we randomized the matrices and

161
00:06:32,279 --> 00:06:34,139
this is a two-step process

162
00:06:34,139 --> 00:06:36,029
the first one is Killians technique

163
00:06:36,029 --> 00:06:38,339
where you we sort of put these random

164
00:06:38,339 --> 00:06:40,700
matrices between the layers

165
00:06:40,700 --> 00:06:44,120
and multiply on on either side and and

166
00:06:44,120 --> 00:06:45,320
then you also multiply with these

167
00:06:45,320 --> 00:06:46,850
independent scalars where there's one

168
00:06:46,850 --> 00:06:50,360
per matrix okay so you can see that this

169
00:06:50,360 --> 00:06:52,010
doesn't change the functionality right

170
00:06:52,010 --> 00:06:55,340
because these will cancel and the alphas

171
00:06:55,340 --> 00:06:56,930
will not change something from zero to

172
00:06:56,930 --> 00:06:59,540
nonzero so so randomizing that way

173
00:06:59,540 --> 00:07:01,550
preserves the functionality and then the

174
00:07:01,550 --> 00:07:03,200
second step is to encode each of these

175
00:07:03,200 --> 00:07:05,510
matrices I skewing the each element of

176
00:07:05,510 --> 00:07:08,480
each matrix in an M map scheme so again

177
00:07:08,480 --> 00:07:10,400
I'm gonna focus on GG h13 but you can

178
00:07:10,400 --> 00:07:13,430
think of in terms of you know I and I Oh

179
00:07:13,430 --> 00:07:15,890
candidate you can think of the other the

180
00:07:15,890 --> 00:07:17,600
other end maps as well and the only

181
00:07:17,600 --> 00:07:19,820
important thing here is that this

182
00:07:19,820 --> 00:07:22,100
encoding is done in a way such that I

183
00:07:22,100 --> 00:07:24,610
can evaluate the branching program so

184
00:07:24,610 --> 00:07:28,130
specifically each honest evaluation of

185
00:07:28,130 --> 00:07:30,380
the encoded branching program gives you

186
00:07:30,380 --> 00:07:32,390
an encoding that's well-formed which

187
00:07:32,390 --> 00:07:34,430
means I can test if it's 0 or not so

188
00:07:34,430 --> 00:07:37,360
that so this is all I was functionality

189
00:07:37,360 --> 00:07:38,600
okay

190
00:07:38,600 --> 00:07:41,210
so I want to have two slides on the ggh

191
00:07:41,210 --> 00:07:46,160
13m map scheme so these these encoding

192
00:07:46,160 --> 00:07:48,290
x' live in a ring of polynomials which

193
00:07:48,290 --> 00:07:50,780
is this I believe the same ring as the

194
00:07:50,780 --> 00:07:52,640
one time crate was talking about so this

195
00:07:52,640 --> 00:07:55,520
is a ring of polynomial has mod some

196
00:07:55,520 --> 00:07:59,810
cyclotomic polynomial and GG h13 has has

197
00:07:59,810 --> 00:08:03,350
basically two sort of important classes

198
00:08:03,350 --> 00:08:05,480
of secret parameters the most important

199
00:08:05,480 --> 00:08:07,880
is is this parameter G and this defines

200
00:08:07,880 --> 00:08:10,310
the the plaintext space okay so in

201
00:08:10,310 --> 00:08:12,910
particular if you take the ideal

202
00:08:12,910 --> 00:08:16,970
generated by G and you mod R by that

203
00:08:16,970 --> 00:08:19,280
that's gonna be our plaintext space and

204
00:08:19,280 --> 00:08:21,380
by choosing G appropriately you can show

205
00:08:21,380 --> 00:08:23,570
that this is isomorphic to a prime field

206
00:08:23,570 --> 00:08:24,950
so you can think of the plaintext space

207
00:08:24,950 --> 00:08:27,200
as a prime field and then the other

208
00:08:27,200 --> 00:08:30,290
important secret parameter is these the

209
00:08:30,290 --> 00:08:32,809
Zi which are gonna define the level of

210
00:08:32,809 --> 00:08:34,970
each encoding okay so what do you do

211
00:08:34,970 --> 00:08:37,849
with these you have a value a plaintext

212
00:08:37,849 --> 00:08:39,770
value and you want to encode it at some

213
00:08:39,770 --> 00:08:42,110
level s and here the levels are going to

214
00:08:42,110 --> 00:08:45,080
be a subset of 1 through K and note this

215
00:08:45,080 --> 00:08:48,590
K here and this K here are the same okay

216
00:08:48,590 --> 00:08:53,540
and to encode a at level s we we

217
00:08:53,540 --> 00:08:56,300
put a in the numerator plus a small

218
00:08:56,300 --> 00:08:58,280
multiple of G so we choose some small

219
00:08:58,280 --> 00:09:00,710
randomness multiply it by G and add a to

220
00:09:00,710 --> 00:09:02,360
it and then in the denominator we

221
00:09:02,360 --> 00:09:06,410
multiply the Z is corresponding to to

222
00:09:06,410 --> 00:09:08,630
the level okay and and we're doing all

223
00:09:08,630 --> 00:09:11,570
of this mod Q where Q is some big

224
00:09:11,570 --> 00:09:14,330
integer so we're taking the coefficients

225
00:09:14,330 --> 00:09:16,280
mod Q and note that without that you

226
00:09:16,280 --> 00:09:17,750
know this this division might not even

227
00:09:17,750 --> 00:09:23,320
be well defined and in the ring are okay

228
00:09:23,320 --> 00:09:26,030
good so so that was the sort of set up

229
00:09:26,030 --> 00:09:29,420
for GG age 13 so how does the arithmetic

230
00:09:29,420 --> 00:09:31,490
work so I'm not gonna I'll spare you the

231
00:09:31,490 --> 00:09:33,770
technical details here but it's exactly

232
00:09:33,770 --> 00:09:36,020
the same as what 10 Craig was saying you

233
00:09:36,020 --> 00:09:38,240
can add at the same level and you can

234
00:09:38,240 --> 00:09:40,880
multiply at walk' this part is a little

235
00:09:40,880 --> 00:09:42,710
different you can multiply a disjoint

236
00:09:42,710 --> 00:09:44,150
level so if you're if you're two levels

237
00:09:44,150 --> 00:09:46,220
are disjoint sets then you can multiply

238
00:09:46,220 --> 00:09:48,950
otherwise you're not allowed to and in

239
00:09:48,950 --> 00:09:51,860
both cases the the new level is the is

240
00:09:51,860 --> 00:09:54,500
the union of the operands level so if

241
00:09:54,500 --> 00:09:55,670
you are adding at the same level you

242
00:09:55,670 --> 00:09:57,320
just keep that same level otherwise you

243
00:09:57,320 --> 00:09:58,880
take the union of the things that you're

244
00:09:58,880 --> 00:10:02,060
multiplying okay and so this when you do

245
00:10:02,060 --> 00:10:04,310
this the sort of randomness grows a

246
00:10:04,310 --> 00:10:06,800
little bit but you can tolerate up to a

247
00:10:06,800 --> 00:10:09,320
certain degree of the computation and

248
00:10:09,320 --> 00:10:10,880
and specifically you can tolerate up to

249
00:10:10,880 --> 00:10:13,040
degree K and again these parameters are

250
00:10:13,040 --> 00:10:15,920
all chosen such that functionality is is

251
00:10:15,920 --> 00:10:19,970
preserved okay so for zero testing what

252
00:10:19,970 --> 00:10:21,350
does it look like so you have this zero

253
00:10:21,350 --> 00:10:22,970
testing parameter which is this kind of

254
00:10:22,970 --> 00:10:25,970
funny-looking thing here and you can see

255
00:10:25,970 --> 00:10:28,460
the reason for it when you look at the

256
00:10:28,460 --> 00:10:30,380
zero test procedure so the procedure is

257
00:10:30,380 --> 00:10:33,290
just taken encoding of zero so note that

258
00:10:33,290 --> 00:10:34,940
it's zero because I'm not adding

259
00:10:34,940 --> 00:10:38,480
anything in the numerator here okay and

260
00:10:38,480 --> 00:10:41,120
also crucially this encoding of zero is

261
00:10:41,120 --> 00:10:43,990
at level K right it's at the top level

262
00:10:43,990 --> 00:10:46,880
and I multiplied by the zero test

263
00:10:46,880 --> 00:10:49,730
parameter disease cancel the G's cancel

264
00:10:49,730 --> 00:10:52,580
and I'm left with R and then this value

265
00:10:52,580 --> 00:10:55,100
H which is just a some small randomness

266
00:10:55,100 --> 00:10:56,570
that we put in the zero test parameter

267
00:10:56,570 --> 00:10:59,360
okay but the point here is that if

268
00:10:59,360 --> 00:11:02,870
you've done this right these two things

269
00:11:02,870 --> 00:11:05,000
are very small relative to the module is

270
00:11:05,000 --> 00:11:07,040
Q right and if

271
00:11:07,040 --> 00:11:10,190
not so if your encoding was not zero or

272
00:11:10,190 --> 00:11:12,440
it was not at the top level then the

273
00:11:12,440 --> 00:11:15,800
output would would have size roughly Q

274
00:11:15,800 --> 00:11:17,180
so you can you can tell if something is

275
00:11:17,180 --> 00:11:18,589
zero or not by checking if it's smaller

276
00:11:18,589 --> 00:11:24,980
or not okay good so what are the attacks

277
00:11:24,980 --> 00:11:27,259
that we know of on ggh 13 so there's

278
00:11:27,259 --> 00:11:29,209
only three including the current work I

279
00:11:29,209 --> 00:11:31,790
believe the first one is actually due to

280
00:11:31,790 --> 00:11:34,250
ggh their team they they observed that

281
00:11:34,250 --> 00:11:37,069
for some distributions on initial

282
00:11:37,069 --> 00:11:39,589
encoding you can actually recover some

283
00:11:39,589 --> 00:11:41,990
of the you can either recover some of

284
00:11:41,990 --> 00:11:43,069
the secret parameters or some

285
00:11:43,069 --> 00:11:44,089
information that you would hope to be

286
00:11:44,089 --> 00:11:45,949
hidden so even in the first paper there

287
00:11:45,949 --> 00:11:47,810
was already an observation that some of

288
00:11:47,810 --> 00:11:50,899
these encoding czar attackable there was

289
00:11:50,899 --> 00:11:53,329
a work by who and gia which attacked

290
00:11:53,329 --> 00:11:55,970
specifically the key exchange protocol

291
00:11:55,970 --> 00:11:58,009
so tenth-grade showed you an attack on

292
00:11:58,009 --> 00:12:00,170
the key exchange protocol using G G H 15

293
00:12:00,170 --> 00:12:04,279
who and gia have one using GG h 13 and

294
00:12:04,279 --> 00:12:05,870
then in this work we would give an

295
00:12:05,870 --> 00:12:08,180
attack on io but all of these works have

296
00:12:08,180 --> 00:12:12,199
the same high level structure first you

297
00:12:12,199 --> 00:12:13,699
start with a set of initial encoding and

298
00:12:13,699 --> 00:12:15,680
you compute some top level zero

299
00:12:15,680 --> 00:12:18,350
encodings using the allowed arithmetic

300
00:12:18,350 --> 00:12:20,000
right though the add at the same level

301
00:12:20,000 --> 00:12:22,220
multiplied two disjoint levels you then

302
00:12:22,220 --> 00:12:24,139
zero test each top level zero encoding

303
00:12:24,139 --> 00:12:26,540
and you you collect the the leakage and

304
00:12:26,540 --> 00:12:29,269
then you perform some arithmetic on this

305
00:12:29,269 --> 00:12:33,019
leakage to to recover an element in the

306
00:12:33,019 --> 00:12:35,660
ideal G right so at the very beginning

307
00:12:35,660 --> 00:12:37,069
when I was saying we're gonna cancel the

308
00:12:37,069 --> 00:12:38,930
leakage this is really what canceling

309
00:12:38,930 --> 00:12:40,940
means is it means you take these these

310
00:12:40,940 --> 00:12:42,470
ring elements that are produced by the

311
00:12:42,470 --> 00:12:45,740
zero test and you you do some arithmetic

312
00:12:45,740 --> 00:12:47,779
over them to recover something in the

313
00:12:47,779 --> 00:12:49,760
ideal G okay so that's the kind of

314
00:12:49,760 --> 00:12:52,040
crucial step in each of these attacks

315
00:12:52,040 --> 00:12:54,589
that element is then used in various

316
00:12:54,589 --> 00:12:57,019
like application specific ways to to

317
00:12:57,019 --> 00:12:58,550
break whatever you're looking at but

318
00:12:58,550 --> 00:13:01,069
recovering the element recovering an

319
00:13:01,069 --> 00:13:02,540
element of the ideal G is kind of the

320
00:13:02,540 --> 00:13:07,310
the core step there okay so let me let

321
00:13:07,310 --> 00:13:11,810
me say what our attack is so think of a

322
00:13:11,810 --> 00:13:13,939
branching program in which every matrix

323
00:13:13,939 --> 00:13:16,760
is the identity matrix okay so this is

324
00:13:16,760 --> 00:13:17,990
probably the simplest branching program

325
00:13:17,990 --> 00:13:20,360
you can think of and this computes the

326
00:13:20,360 --> 00:13:20,900
Aussie

327
00:13:20,900 --> 00:13:22,010
function if you if you choose the

328
00:13:22,010 --> 00:13:23,270
bookend vectors right this computes the

329
00:13:23,270 --> 00:13:25,040
all zeros function this is good for us

330
00:13:25,040 --> 00:13:26,660
as an attacker because we can get as

331
00:13:26,660 --> 00:13:28,760
many top-level zeros as we want by just

332
00:13:28,760 --> 00:13:30,650
evaluating the branching program on on

333
00:13:30,650 --> 00:13:34,490
any input okay so if we called it in GG

334
00:13:34,490 --> 00:13:37,850
h13 the output of the zero test it for a

335
00:13:37,850 --> 00:13:40,370
successful zero test right is this this

336
00:13:40,370 --> 00:13:43,400
element H times the randomness R of the

337
00:13:43,400 --> 00:13:46,790
of the top-level encoding okay so in our

338
00:13:46,790 --> 00:13:49,460
attack the first thing that we do is we

339
00:13:49,460 --> 00:13:51,890
sort of examine what is the structure of

340
00:13:51,890 --> 00:13:55,790
that randomness and we write it we sort

341
00:13:55,790 --> 00:13:58,339
of stratify by this variable G right so

342
00:13:58,339 --> 00:14:01,790
we we write the randomness as everything

343
00:14:01,790 --> 00:14:03,800
that's divisible by G Plus everything

344
00:14:03,800 --> 00:14:04,880
else okay

345
00:14:04,880 --> 00:14:08,060
and so what are these p1 and p2 these

346
00:14:08,060 --> 00:14:10,370
are polynomials over the underlying

347
00:14:10,370 --> 00:14:12,980
multi linear map variables so both over

348
00:14:12,980 --> 00:14:15,260
the the input branching program but also

349
00:14:15,260 --> 00:14:16,970
over all of the randomness that was

350
00:14:16,970 --> 00:14:19,700
chosen by the multi linear map and right

351
00:14:19,700 --> 00:14:21,980
we as the attacker we don't know what

352
00:14:21,980 --> 00:14:24,529
those random values are but we do know

353
00:14:24,529 --> 00:14:27,830
we can you know compute explicitly what

354
00:14:27,830 --> 00:14:30,110
is the polynomial over those random

355
00:14:30,110 --> 00:14:32,750
values that is output by the zero test

356
00:14:32,750 --> 00:14:37,070
procedure okay so once we compute these

357
00:14:37,070 --> 00:14:40,250
polynomials we then find this polynomial

358
00:14:40,250 --> 00:14:42,170
Q and this is our annihilating

359
00:14:42,170 --> 00:14:45,230
polynomial okay and what does it do it

360
00:14:45,230 --> 00:14:47,450
has a property that if you evaluate Q on

361
00:14:47,450 --> 00:14:50,750
the set of all these P ones times the

362
00:14:50,750 --> 00:14:53,029
age it will output the zero polynomial

363
00:14:53,029 --> 00:14:57,080
okay and if given such a Q it's easy to

364
00:14:57,080 --> 00:14:59,089
observe that if I then just evaluate on

365
00:14:59,089 --> 00:15:02,810
H times R this part is gonna go away and

366
00:15:02,810 --> 00:15:04,070
I'm gonna be left with something that's

367
00:15:04,070 --> 00:15:06,500
divisible by G which by definition is

368
00:15:06,500 --> 00:15:08,870
something in the ideal G okay so that

369
00:15:08,870 --> 00:15:10,490
that's kind of the structure of the

370
00:15:10,490 --> 00:15:13,040
attack but saying it this way I'm

371
00:15:13,040 --> 00:15:14,839
actually sweeping kind of all of the

372
00:15:14,839 --> 00:15:17,510
hard stuff under the rug because the

373
00:15:17,510 --> 00:15:19,640
core task is actually finding that

374
00:15:19,640 --> 00:15:22,550
annihilating polynomial right so given a

375
00:15:22,550 --> 00:15:26,890
set of polynomials where I'm calling p1

376
00:15:26,890 --> 00:15:30,260
p1 are the goal is to compute an

377
00:15:30,260 --> 00:15:33,260
annihilating polynomial Q that cancels

378
00:15:33,260 --> 00:15:33,720
them all

379
00:15:33,720 --> 00:15:35,280
right that that that evaluates to the

380
00:15:35,280 --> 00:15:37,830
zero polynomial okay so in general this

381
00:15:37,830 --> 00:15:39,690
is actually seems to be an intractable

382
00:15:39,690 --> 00:15:41,910
problem and if you could solve this

383
00:15:41,910 --> 00:15:43,380
problem in general it implies the

384
00:15:43,380 --> 00:15:44,640
collapse of the polynomial time

385
00:15:44,640 --> 00:15:47,190
hierarchy this is due to kya but you

386
00:15:47,190 --> 00:15:49,230
know it's it's actually easy to see how

387
00:15:49,230 --> 00:15:52,950
to break many crypto applications you

388
00:15:52,950 --> 00:15:54,090
know if you if you could solve this task

389
00:15:54,090 --> 00:15:57,480
right so that you know that seems bad

390
00:15:57,480 --> 00:15:59,940
for us as the attacker but but it turns

391
00:15:59,940 --> 00:16:01,230
out that our polynomials that we're

392
00:16:01,230 --> 00:16:03,060
working with here are highly structured

393
00:16:03,060 --> 00:16:05,700
and in fact they are also simplified by

394
00:16:05,700 --> 00:16:09,450
the by the Cho of our choice of the the

395
00:16:09,450 --> 00:16:13,230
identity matrix branching program but in

396
00:16:13,230 --> 00:16:14,760
general these polynomials have roughly

397
00:16:14,760 --> 00:16:16,470
the structure of iterated multiple

398
00:16:16,470 --> 00:16:18,000
matrix multiplication which is a very

399
00:16:18,000 --> 00:16:21,060
you know explicit well-defined

400
00:16:21,060 --> 00:16:24,720
polynomial but still you know it has

401
00:16:24,720 --> 00:16:26,310
many variables and we still don't know

402
00:16:26,310 --> 00:16:28,050
just you know at first glance how to

403
00:16:28,050 --> 00:16:29,820
find the annihilating polynomial for

404
00:16:29,820 --> 00:16:33,210
that so our technique here is to use

405
00:16:33,210 --> 00:16:35,340
change of variables basically so we take

406
00:16:35,340 --> 00:16:37,080
these polynomials over the underlying

407
00:16:37,080 --> 00:16:39,510
multi linear map variables and we apply

408
00:16:39,510 --> 00:16:41,430
a series of changes of variables that

409
00:16:41,430 --> 00:16:44,790
actually reduce the task to to

410
00:16:44,790 --> 00:16:46,170
annihilating a constant number of

411
00:16:46,170 --> 00:16:48,300
polynomials over a constant number of

412
00:16:48,300 --> 00:16:51,090
variables okay and then we can we can

413
00:16:51,090 --> 00:16:53,370
apply brute-force search which is what

414
00:16:53,370 --> 00:16:56,330
we did and we find a polynomial Q which

415
00:16:56,330 --> 00:16:58,170
so you know even though we're using

416
00:16:58,170 --> 00:17:00,630
computer search here this polynomial Q

417
00:17:00,630 --> 00:17:03,750
provably annihilates the the polynomials

418
00:17:03,750 --> 00:17:06,380
that arise from the zero test procedure

419
00:17:06,380 --> 00:17:09,030
okay so I'm gonna I'm leaving out the

420
00:17:09,030 --> 00:17:10,710
technical details here they're they're a

421
00:17:10,710 --> 00:17:13,020
little technical for this short talk but

422
00:17:13,020 --> 00:17:14,579
I encourage you to look at the paper

423
00:17:14,579 --> 00:17:16,470
it's not it's not that complicated when

424
00:17:16,470 --> 00:17:20,280
you're sitting down looking at it okay

425
00:17:20,280 --> 00:17:23,700
oops oh no oh I just stepped on my joke

426
00:17:23,700 --> 00:17:29,550
okay yeah anyway right so okay so I just

427
00:17:29,550 --> 00:17:32,370
mentioned how we how we recover an

428
00:17:32,370 --> 00:17:35,010
element of the ideal G but we actually

429
00:17:35,010 --> 00:17:36,420
want to distinguish the programs right

430
00:17:36,420 --> 00:17:38,400
so for the second branching program we

431
00:17:38,400 --> 00:17:40,950
choose almost the same thing except we

432
00:17:40,950 --> 00:17:42,870
flipped some of the matrices to be this

433
00:17:42,870 --> 00:17:44,340
reverse identity instead

434
00:17:44,340 --> 00:17:46,740
standard identity this still computes

435
00:17:46,740 --> 00:17:48,360
the all zeros function because this

436
00:17:48,360 --> 00:17:50,340
thing is its own inverse so as long as

437
00:17:50,340 --> 00:17:51,750
you're always multiplying an even number

438
00:17:51,750 --> 00:17:54,210
of these it's still still the all zeros

439
00:17:54,210 --> 00:17:57,240
function right which which is important

440
00:17:57,240 --> 00:17:58,770
because we need to distinguish two

441
00:17:58,770 --> 00:18:02,309
equivalent programs and we show that you

442
00:18:02,309 --> 00:18:03,600
know in the same way that this

443
00:18:03,600 --> 00:18:05,610
polynomial q dozen aisle eight the first

444
00:18:05,610 --> 00:18:07,710
branching program it does not annihilate

445
00:18:07,710 --> 00:18:11,250
the second okay and so if we repeat this

446
00:18:11,250 --> 00:18:13,770
process many times we get many ring

447
00:18:13,770 --> 00:18:15,179
elements that are either all in the

448
00:18:15,179 --> 00:18:17,580
ideal G or they're not all in the ideal

449
00:18:17,580 --> 00:18:19,919
G and then we can heuristic ly test this

450
00:18:19,919 --> 00:18:22,710
with a Gaussian elimination I guess

451
00:18:22,710 --> 00:18:23,940
because these are you can think of these

452
00:18:23,940 --> 00:18:28,559
as lattices basically okay so so you

453
00:18:28,559 --> 00:18:30,450
know by doing this we we distinguish the

454
00:18:30,450 --> 00:18:32,190
programs right so we as the attacker

455
00:18:32,190 --> 00:18:34,679
have one right but we're we're not

456
00:18:34,679 --> 00:18:37,140
attackers where you know we're

457
00:18:37,140 --> 00:18:38,640
cryptographers want to be secure and

458
00:18:38,640 --> 00:18:40,110
this is really bad because we're not

459
00:18:40,110 --> 00:18:42,299
we're not winning anymore right so we

460
00:18:42,299 --> 00:18:44,850
need to do something about this and so

461
00:18:44,850 --> 00:18:46,350
let's make confiscation great again I

462
00:18:46,350 --> 00:18:47,730
wish I hadn't stepped on my joke there

463
00:18:47,730 --> 00:18:51,270
but I did okay so I just have a few

464
00:18:51,270 --> 00:18:53,730
minutes left let me let me say what we

465
00:18:53,730 --> 00:18:57,809
can hope to do in the face of this okay

466
00:18:57,809 --> 00:19:00,630
so how have we modeled multi linear maps

467
00:19:00,630 --> 00:19:02,909
so far actually before I say that let me

468
00:19:02,909 --> 00:19:05,610
let me say a quick caveat about the

469
00:19:05,610 --> 00:19:06,630
about the attack

470
00:19:06,630 --> 00:19:09,690
so our attack we don't know that it

471
00:19:09,690 --> 00:19:11,580
breaks all of the candidate IO schemes

472
00:19:11,580 --> 00:19:14,039
there are many schemes that we can break

473
00:19:14,039 --> 00:19:15,330
with it but there are some that we can't

474
00:19:15,330 --> 00:19:16,940
and in particularly the original

475
00:19:16,940 --> 00:19:19,080
candidate we don't know how to break and

476
00:19:19,080 --> 00:19:21,539
similarly candidates that sort of start

477
00:19:21,539 --> 00:19:22,679
by converting a circuit from

478
00:19:22,679 --> 00:19:24,480
Barrington's theorem we also don't know

479
00:19:24,480 --> 00:19:27,149
how to break these but the point is that

480
00:19:27,149 --> 00:19:30,179
for all of these candidates both the

481
00:19:30,179 --> 00:19:31,679
ones that we have broken and the ones

482
00:19:31,679 --> 00:19:33,450
that we haven't these are all proven

483
00:19:33,450 --> 00:19:35,909
secure in this ideal multi linear map

484
00:19:35,909 --> 00:19:39,840
model right so so even though you know

485
00:19:39,840 --> 00:19:41,399
you have some candidates that are you

486
00:19:41,399 --> 00:19:42,690
can prove secure in this model that we

487
00:19:42,690 --> 00:19:44,309
don't know how to break we know that

488
00:19:44,309 --> 00:19:46,320
this model is inadequate in fact we

489
00:19:46,320 --> 00:19:48,120
already knew this for M maps in general

490
00:19:48,120 --> 00:19:50,130
but we now know it for IO in particular

491
00:19:50,130 --> 00:19:51,690
right there are i/o candidates that are

492
00:19:51,690 --> 00:19:54,450
secure in this ideal model but which are

493
00:19:54,450 --> 00:19:55,450
broken in the real world

494
00:19:55,450 --> 00:19:58,600
so that's clearly a problem so what is

495
00:19:58,600 --> 00:20:00,760
actually the problem with the model and

496
00:20:00,760 --> 00:20:02,200
the the problem is that the model

497
00:20:02,200 --> 00:20:04,360
assumes that the zero test just outputs

498
00:20:04,360 --> 00:20:05,799
a bit right it kind of pretends that

499
00:20:05,799 --> 00:20:07,750
this leakage is not there and so it

500
00:20:07,750 --> 00:20:09,880
artificially prohibits this kind of

501
00:20:09,880 --> 00:20:12,549
attack that uses this leakage okay and

502
00:20:12,549 --> 00:20:14,799
so our solution is to provide a new weak

503
00:20:14,799 --> 00:20:17,110
multi linear map model that actually

504
00:20:17,110 --> 00:20:19,029
allows the adversary to perform these

505
00:20:19,029 --> 00:20:25,240
post zero test computations ok so what

506
00:20:25,240 --> 00:20:27,549
does the model do roughly basically the

507
00:20:27,549 --> 00:20:29,950
model actually keeps track of the formal

508
00:20:29,950 --> 00:20:31,690
polynomials over these underlying

509
00:20:31,690 --> 00:20:34,419
variables throughout all of the encoding

510
00:20:34,419 --> 00:20:36,789
so the standard model kind of just keeps

511
00:20:36,789 --> 00:20:39,070
track of the ring element and basically

512
00:20:39,070 --> 00:20:42,070
forgets how it got there right but but

513
00:20:42,070 --> 00:20:43,600
this this new model keeps track of

514
00:20:43,600 --> 00:20:45,870
exactly how each of these computations

515
00:20:45,870 --> 00:20:49,809
were encoded or we're computed and the

516
00:20:49,809 --> 00:20:50,980
key new feature of this model is that

517
00:20:50,980 --> 00:20:54,130
when you do a zero test you actually get

518
00:20:54,130 --> 00:20:56,919
back a pointer to that polynomial and

519
00:20:56,919 --> 00:20:58,960
you can do some further arithmetic on it

520
00:20:58,960 --> 00:21:00,909
and in this model we say that the

521
00:21:00,909 --> 00:21:03,580
adversary wins if it finds some some

522
00:21:03,580 --> 00:21:07,090
post zero test polynomial Q whose output

523
00:21:07,090 --> 00:21:09,970
is the zero polynomial mod G so so Q is

524
00:21:09,970 --> 00:21:11,590
evaluated on all these post zero test

525
00:21:11,590 --> 00:21:14,019
polynomials and the adversary wins if it

526
00:21:14,019 --> 00:21:16,539
if it gets something Maji which again

527
00:21:16,539 --> 00:21:18,909
corresponds to something living in the

528
00:21:18,909 --> 00:21:22,510
ideal G which as I mentioned all of the

529
00:21:22,510 --> 00:21:23,860
attacks that we know of have to go

530
00:21:23,860 --> 00:21:25,450
through this right so so this model

531
00:21:25,450 --> 00:21:28,210
really captures a crucial part of each

532
00:21:28,210 --> 00:21:31,000
of the attacks that we know of okay and

533
00:21:31,000 --> 00:21:33,659
then in subsequent work there's been two

534
00:21:33,659 --> 00:21:37,059
new i/o candidates in that are proven

535
00:21:37,059 --> 00:21:39,039
secure in this weak multi linear map

536
00:21:39,039 --> 00:21:41,080
model so there's there's the first one

537
00:21:41,080 --> 00:21:42,700
is due to guard Mukherjee and sort of

538
00:21:42,700 --> 00:21:44,830
asan and the second one is due to the

539
00:21:44,830 --> 00:21:47,080
same authors of this paper and again

540
00:21:47,080 --> 00:21:49,440
these are provably secure in this model

541
00:21:49,440 --> 00:21:52,899
assuming a pseudo-random function in NC

542
00:21:52,899 --> 00:21:55,690
one in in ours the assumption can may be

543
00:21:55,690 --> 00:21:57,159
made slightly more general but again

544
00:21:57,159 --> 00:21:59,080
this is a this is a you know standard

545
00:21:59,080 --> 00:22:01,990
crypto assumption and so these are the

546
00:22:01,990 --> 00:22:03,519
secure against all of the attacks that

547
00:22:03,519 --> 00:22:04,360
we know of

548
00:22:04,360 --> 00:22:07,820
against GG h13 okay so

549
00:22:07,820 --> 00:22:10,520
I will I will conclude there and thank

550
00:22:10,520 --> 00:22:12,850
you very much

