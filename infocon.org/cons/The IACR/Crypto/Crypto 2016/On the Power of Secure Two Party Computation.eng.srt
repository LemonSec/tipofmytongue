1
00:00:04,059 --> 00:00:06,740
thanks Ange I'm glad to be here I'm

2
00:00:06,740 --> 00:00:08,600
going to talk about our work on the

3
00:00:08,600 --> 00:00:10,210
power of secure two-party computation

4
00:00:10,210 --> 00:00:13,610
this is joint work with Kermit azide

5
00:00:13,610 --> 00:00:17,619
from bar-ilan can everyone hear me okay

6
00:00:17,619 --> 00:00:19,940
all right so this talk is going to be

7
00:00:19,940 --> 00:00:22,160
about zero knowledge proof it's always

8
00:00:22,160 --> 00:00:23,600
nice to begin with the definition of

9
00:00:23,600 --> 00:00:25,820
zero knowledge it's an interactive

10
00:00:25,820 --> 00:00:27,860
protocol between a proven and a verifier

11
00:00:27,860 --> 00:00:29,539
that basically satisfies three

12
00:00:29,539 --> 00:00:33,260
properties first approval can convince a

13
00:00:33,260 --> 00:00:35,980
verifier of a true statement to

14
00:00:35,980 --> 00:00:38,450
soundness which says that no cheating

15
00:00:38,450 --> 00:00:40,850
prover even if computationally unbounded

16
00:00:40,850 --> 00:00:43,100
can convince a verifier of a false

17
00:00:43,100 --> 00:00:47,329
statement and the zero knowledge which

18
00:00:47,329 --> 00:00:50,360
is centered to this definition says that

19
00:00:50,360 --> 00:00:53,600
no efficient verifier can learn anything

20
00:00:53,600 --> 00:00:55,460
more than the validity of the statement

21
00:00:55,460 --> 00:00:58,430
the zero knowledge property is further I

22
00:00:58,430 --> 00:01:00,680
mean to be a little more precise is to

23
00:01:00,680 --> 00:01:02,629
say that for every probabilistic

24
00:01:02,629 --> 00:01:05,840
polynomial-time adversary we start there

25
00:01:05,840 --> 00:01:09,109
is a PPT simulator s that can produce

26
00:01:09,109 --> 00:01:12,649
views that are indistinguishable to what

27
00:01:12,649 --> 00:01:15,219
the verifier sees in a real interaction

28
00:01:15,219 --> 00:01:18,200
so just pictorially what the verifier

29
00:01:18,200 --> 00:01:20,600
sees in the real interaction are

30
00:01:20,600 --> 00:01:22,279
basically the transcript of the messages

31
00:01:22,279 --> 00:01:24,170
and the random points and the simulator

32
00:01:24,170 --> 00:01:25,819
must be able to generate them

33
00:01:25,819 --> 00:01:28,880
indistinguishable okay so for what

34
00:01:28,880 --> 00:01:30,439
languages do we know how to construct

35
00:01:30,439 --> 00:01:33,020
zero knowledge actually all of I P but

36
00:01:33,020 --> 00:01:36,649
in this talk I am more interested in the

37
00:01:36,649 --> 00:01:39,109
class of NP and it was shown early on

38
00:01:39,109 --> 00:01:42,619
that assuming I should say the first

39
00:01:42,619 --> 00:01:44,060
paper didn't do it based on one-way

40
00:01:44,060 --> 00:01:45,740
functions but I'm just going to say that

41
00:01:45,740 --> 00:01:47,599
assuming one-way functions that exist

42
00:01:47,599 --> 00:01:51,319
zero knowledge proves for all of NP a

43
00:01:51,319 --> 00:01:53,929
little bit of a biased history here I'm

44
00:01:53,929 --> 00:01:55,490
not going to list all the words a little

45
00:01:55,490 --> 00:01:59,509
bit that's relevant to my talk initially

46
00:01:59,509 --> 00:02:03,049
the zero knowledge groups for general NP

47
00:02:03,049 --> 00:02:05,569
statements were constructed for specific

48
00:02:05,569 --> 00:02:08,030
NP complete land like graph tree

49
00:02:08,030 --> 00:02:10,310
coloring for hamiltonicity this also

50
00:02:10,310 --> 00:02:13,100
worked the does for satisfiability but

51
00:02:13,100 --> 00:02:14,590
it was not based on

52
00:02:14,590 --> 00:02:16,120
general assumptions it was based on the

53
00:02:16,120 --> 00:02:18,790
quadratic reciprocity but along this

54
00:02:18,790 --> 00:02:20,860
line of work a major big breakthrough

55
00:02:20,860 --> 00:02:24,640
was achieved by ish official Evitts

56
00:02:24,640 --> 00:02:27,040
Ostrovsky and Sahai where they show that

57
00:02:27,040 --> 00:02:29,440
you can construct a zero knowledge proof

58
00:02:29,440 --> 00:02:33,160
for any MP relation starting from an

59
00:02:33,160 --> 00:02:36,209
honest majority MPC protocol for a

60
00:02:36,209 --> 00:02:39,700
related function RF honest majority this

61
00:02:39,700 --> 00:02:41,019
is just one of the results there are

62
00:02:41,019 --> 00:02:44,019
many more of this flavor in their paper

63
00:02:44,019 --> 00:02:46,870
but the core to their approach here is

64
00:02:46,870 --> 00:02:51,519
to use was to introduce this idea of MPC

65
00:02:51,519 --> 00:02:52,380
in the head

66
00:02:52,380 --> 00:02:55,209
besides introducing this powerful

67
00:02:55,209 --> 00:02:58,000
technique this work actually constructed

68
00:02:58,000 --> 00:02:59,829
one of the first simplest zero knowledge

69
00:02:59,829 --> 00:03:02,680
proof for general MP statements without

70
00:03:02,680 --> 00:03:05,500
expensive card productions by

71
00:03:05,500 --> 00:03:08,560
instantiating the MPC with a simple and

72
00:03:08,560 --> 00:03:11,980
PC protocol also in this in the same

73
00:03:11,980 --> 00:03:15,730
work using very clever ideas of how to

74
00:03:15,730 --> 00:03:17,530
choose the MPC protocol they even

75
00:03:17,530 --> 00:03:19,989
construct asymptotically communication

76
00:03:19,989 --> 00:03:22,450
efficient or even optimal in some sense

77
00:03:22,450 --> 00:03:25,900
zero knowledge proof and more recently

78
00:03:25,900 --> 00:03:28,269
gia comely at all extend this framework

79
00:03:28,269 --> 00:03:31,030
can also give practical implementations

80
00:03:31,030 --> 00:03:36,430
of these proofs ok so our work is sort

81
00:03:36,430 --> 00:03:38,470
of similar in spirit in this line of

82
00:03:38,470 --> 00:03:41,950
work and our main result in formally

83
00:03:41,950 --> 00:03:45,609
stated shows that starting from any two

84
00:03:45,609 --> 00:03:49,650
party protocol in the OT hybrid we can

85
00:03:49,650 --> 00:03:52,900
construct a zero knowledge proof for any

86
00:03:52,900 --> 00:03:55,239
NP relation now I mean to party is

87
00:03:55,239 --> 00:03:57,400
supposed to be a specific case of MPC so

88
00:03:57,400 --> 00:03:58,750
something is going on here

89
00:03:58,750 --> 00:04:01,150
first we show for any two party

90
00:04:01,150 --> 00:04:03,220
computation in the oblivious transfer

91
00:04:03,220 --> 00:04:04,840
hybrid which means the parties have

92
00:04:04,840 --> 00:04:08,769
access to an OT functionality and I'll

93
00:04:08,769 --> 00:04:10,569
also argue like in a couple of slides

94
00:04:10,569 --> 00:04:13,030
down why the I cost approach does not

95
00:04:13,030 --> 00:04:15,940
work for at least directly work for two

96
00:04:15,940 --> 00:04:20,168
party protocols now I'm going to list

97
00:04:20,168 --> 00:04:21,430
some corollary they are not quite

98
00:04:21,430 --> 00:04:23,590
corollaries it needs extra work but just

99
00:04:23,590 --> 00:04:25,870
to illustrate that this technique what

100
00:04:25,870 --> 00:04:28,120
additionally does it give us that

101
00:04:28,120 --> 00:04:31,419
i--'cause does not already give is one

102
00:04:31,419 --> 00:04:33,400
we show actually a very simple zero

103
00:04:33,400 --> 00:04:35,650
knowledge proof using garbled circuits

104
00:04:35,650 --> 00:04:37,090
garbled circuits can be seen as an

105
00:04:37,090 --> 00:04:38,919
instantiation of a two-party computation

106
00:04:38,919 --> 00:04:41,290
protocol and previously we only knew how

107
00:04:41,290 --> 00:04:44,020
to get zero knowledge arguments from

108
00:04:44,020 --> 00:04:47,199
garbled circuits a second one we show

109
00:04:47,199 --> 00:04:49,180
that we can strengthen this definition

110
00:04:49,180 --> 00:04:51,040
of zero knowledge proof and get this

111
00:04:51,040 --> 00:04:54,340
property called input Delaney's I'll

112
00:04:54,340 --> 00:04:56,580
talk about this a little later but very

113
00:04:56,580 --> 00:04:59,620
informally it says that the statement

114
00:04:59,620 --> 00:05:01,360
and witness is made available to the

115
00:05:01,360 --> 00:05:04,389
prover only in the last round so the the

116
00:05:04,389 --> 00:05:07,380
input is delayed to the proved and

117
00:05:07,380 --> 00:05:11,039
previously actually even quite recently

118
00:05:11,039 --> 00:05:14,139
such protocols were constructed for very

119
00:05:14,139 --> 00:05:17,229
specific Sigma protocols and if you want

120
00:05:17,229 --> 00:05:19,720
it for general NP statement the work

121
00:05:19,720 --> 00:05:22,930
that we know of is traces back to the

122
00:05:22,930 --> 00:05:25,300
90s and requires expensive car

123
00:05:25,300 --> 00:05:29,410
productions so ours is black box and

124
00:05:29,410 --> 00:05:31,539
I'll tell you what this means in a sense

125
00:05:31,539 --> 00:05:32,950
you can read it as saying it does not

126
00:05:32,950 --> 00:05:37,240
require car productions and the third

127
00:05:37,240 --> 00:05:39,639
and the technically most involved which

128
00:05:39,639 --> 00:05:43,030
I probably won't have time today is we

129
00:05:43,030 --> 00:05:44,919
also construct adaptive zero knowledge

130
00:05:44,919 --> 00:05:48,039
proof and adaptive here means that the

131
00:05:48,039 --> 00:05:50,349
simulator not only needs to simulate the

132
00:05:50,349 --> 00:05:53,500
view of the verifier but at the end say

133
00:05:53,500 --> 00:05:55,090
it should also if the prover is

134
00:05:55,090 --> 00:05:57,760
corrupted produce a view for the prover

135
00:05:57,760 --> 00:05:59,710
consistent with the transcript generated

136
00:05:59,710 --> 00:06:01,479
okay so that's adaptive zero knowledge

137
00:06:01,479 --> 00:06:03,070
and we show starting from two PC

138
00:06:03,070 --> 00:06:05,110
protocols again I'm simplifying things

139
00:06:05,110 --> 00:06:07,750
here we need additional things that need

140
00:06:07,750 --> 00:06:10,449
to be additional properties that the

141
00:06:10,449 --> 00:06:12,220
two-party computation need to satisfy

142
00:06:12,220 --> 00:06:14,979
for these to work but essentially we get

143
00:06:14,979 --> 00:06:18,340
these results using our compilation

144
00:06:18,340 --> 00:06:21,849
technique now before I go into how we do

145
00:06:21,849 --> 00:06:25,210
this I want to start off with and one

146
00:06:25,210 --> 00:06:27,160
more thing previously to construct

147
00:06:27,160 --> 00:06:29,229
adaptive zero knowledge again required

148
00:06:29,229 --> 00:06:32,770
car productions and was done by Linda

149
00:06:32,770 --> 00:06:35,650
lens aerosol okay so before you get into

150
00:06:35,650 --> 00:06:38,289
our approach I'm going to start with the

151
00:06:38,289 --> 00:06:40,270
high cost approach

152
00:06:40,270 --> 00:06:43,669
so here basically you start off with an

153
00:06:43,669 --> 00:06:46,400
MPC protocol so given an NP relation R

154
00:06:46,400 --> 00:06:48,370
you're going to start off with an MPC

155
00:06:48,370 --> 00:06:50,960
protocol for a related function f this

156
00:06:50,960 --> 00:06:53,539
function f is basically it has the

157
00:06:53,539 --> 00:06:56,360
statement hard-coded and computes the

158
00:06:56,360 --> 00:06:59,690
relation on the XR of the inputs of all

159
00:06:59,690 --> 00:07:02,900
the end parties ok so what happens here

160
00:07:02,900 --> 00:07:06,530
the prover in her head will emulate an

161
00:07:06,530 --> 00:07:09,889
instance of this MPC protocol giving

162
00:07:09,889 --> 00:07:13,220
inputs to the parties and generates view

163
00:07:13,220 --> 00:07:16,069
according to this MPC protocol then in

164
00:07:16,069 --> 00:07:18,050
the first round the prover commits to

165
00:07:18,050 --> 00:07:20,509
the views of each of these parties in

166
00:07:20,509 --> 00:07:22,940
the second round the verifier challenges

167
00:07:22,940 --> 00:07:25,729
to prove err on two of these parties for

168
00:07:25,729 --> 00:07:28,699
which the prover needs to open the views

169
00:07:28,699 --> 00:07:31,099
basically D commit the views and the

170
00:07:31,099 --> 00:07:32,840
verifier checks that these views are

171
00:07:32,840 --> 00:07:35,810
consistent and also that the output

172
00:07:35,810 --> 00:07:38,810
computed in this MPC protocol is one

173
00:07:38,810 --> 00:07:42,530
namely that the relation holds now if

174
00:07:42,530 --> 00:07:44,210
you look at this approach actually if

175
00:07:44,210 --> 00:07:46,729
you instantiate this MPC protocol with

176
00:07:46,729 --> 00:07:49,009
known information theoretic protocols

177
00:07:49,009 --> 00:07:50,419
that we know in literature we need at

178
00:07:50,419 --> 00:07:52,940
least three parties because of honest

179
00:07:52,940 --> 00:07:55,099
majority they also have an instantiation

180
00:07:55,099 --> 00:07:59,180
based on gmw and as written in the work

181
00:07:59,180 --> 00:08:03,490
this also requires three parties because

182
00:08:03,490 --> 00:08:07,219
gmw is in the OT hybrid and to ensure

183
00:08:07,219 --> 00:08:10,960
consistency of how these OT channels are

184
00:08:10,960 --> 00:08:13,460
used by the parties they need to open

185
00:08:13,460 --> 00:08:16,099
two views okay so they need at least

186
00:08:16,099 --> 00:08:18,469
three parties for privacy

187
00:08:18,469 --> 00:08:21,259
now I said as it was written there

188
00:08:21,259 --> 00:08:23,479
because in the very next dot you're

189
00:08:23,479 --> 00:08:26,060
going to see how this can be extended to

190
00:08:26,060 --> 00:08:29,419
also work for two parties in the OT

191
00:08:29,419 --> 00:08:32,809
hybrid however I want to say that the

192
00:08:32,809 --> 00:08:34,700
remaining two results that we have which

193
00:08:34,700 --> 00:08:39,110
is delayed input Ness and adaptive zero

194
00:08:39,110 --> 00:08:41,630
knowledge cannot be cashed in this

195
00:08:41,630 --> 00:08:43,309
framework and roughly speaking the

196
00:08:43,309 --> 00:08:45,140
intuition is that when the prover

197
00:08:45,140 --> 00:08:47,360
commits to all the views it sort of

198
00:08:47,360 --> 00:08:49,339
binds everything the statement the

199
00:08:49,339 --> 00:08:51,560
witness everything is bound I mean if

200
00:08:51,560 --> 00:08:52,730
you use statistically by

201
00:08:52,730 --> 00:08:54,560
committments it's literally bound to the

202
00:08:54,560 --> 00:08:58,010
first first message and you can't get

203
00:08:58,010 --> 00:09:00,890
any delayed input okay so this is sort

204
00:09:00,890 --> 00:09:03,830
of the the limit of my course and now

205
00:09:03,830 --> 00:09:06,170
I'm gonna give our construction of zero

206
00:09:06,170 --> 00:09:08,990
knowledge based on garbled circuits

207
00:09:08,990 --> 00:09:11,930
first let me just define what garbled

208
00:09:11,930 --> 00:09:13,820
circuits are very briefly I'm sure most

209
00:09:13,820 --> 00:09:15,530
of you know something that we love and

210
00:09:15,530 --> 00:09:18,710
care about gargling can be think thought

211
00:09:18,710 --> 00:09:22,070
of as a set of four algorithms there is

212
00:09:22,070 --> 00:09:23,990
a garbling algorithm that takes the

213
00:09:23,990 --> 00:09:26,920
circuit outputs the garbled circuit a

214
00:09:26,920 --> 00:09:31,130
translation table and key labels and I'm

215
00:09:31,130 --> 00:09:33,140
going to call DK the decryption key or

216
00:09:33,140 --> 00:09:36,020
the translation table SK the secret key

217
00:09:36,020 --> 00:09:37,850
or you can think of it as the randomness

218
00:09:37,850 --> 00:09:40,880
used to garbled the circuit and then

219
00:09:40,880 --> 00:09:42,500
there is an encoding procedure that

220
00:09:42,500 --> 00:09:45,290
shows how to encode any input to a

221
00:09:45,290 --> 00:09:47,270
garbled input then there is an

222
00:09:47,270 --> 00:09:49,220
evaluation procedure that takes a gobble

223
00:09:49,220 --> 00:09:51,380
circuit and a garbled input and outputs

224
00:09:51,380 --> 00:09:55,310
a garbled output which the decoder using

225
00:09:55,310 --> 00:09:57,200
the translation table can give the final

226
00:09:57,200 --> 00:09:59,570
output okay the two properties that we

227
00:09:59,570 --> 00:10:01,640
need here are correctness namely y must

228
00:10:01,640 --> 00:10:03,530
be equal to C of X where C is the

229
00:10:03,530 --> 00:10:06,320
original so cute and security says that

230
00:10:06,320 --> 00:10:09,640
there is a simulation that can produce

231
00:10:09,640 --> 00:10:14,180
the garbled circuit and consistent

232
00:10:14,180 --> 00:10:16,640
garbled inputs and translation table

233
00:10:16,640 --> 00:10:18,680
just from the circuit and the output

234
00:10:18,680 --> 00:10:21,260
that is basically without the input so

235
00:10:21,260 --> 00:10:24,140
this is the security of a garbled my

236
00:10:24,140 --> 00:10:26,690
formulation of the garbled so cute now

237
00:10:26,690 --> 00:10:28,160
let's construct a zero knowledge proof

238
00:10:28,160 --> 00:10:31,190
from this so the circuit that we are

239
00:10:31,190 --> 00:10:33,740
going to take is similar to anything

240
00:10:33,740 --> 00:10:35,540
else we're going to have X hard-coded in

241
00:10:35,540 --> 00:10:37,010
the circuit and it's going to evaluate

242
00:10:37,010 --> 00:10:42,170
the relation on the witness W now what

243
00:10:42,170 --> 00:10:43,760
is the prover do the period approver

244
00:10:43,760 --> 00:10:45,860
gobbles the circuit also gobbles the

245
00:10:45,860 --> 00:10:48,650
input witness that she knows in the

246
00:10:48,650 --> 00:10:51,800
first message the prover gives the

247
00:10:51,800 --> 00:10:54,590
garbled circuit the translation table

248
00:10:54,590 --> 00:10:57,590
and commits to escape which is the

249
00:10:57,590 --> 00:11:01,010
randomness used to garble now the

250
00:11:01,010 --> 00:11:02,450
verifier is going to challenge with a

251
00:11:02,450 --> 00:11:05,240
bit B now depending on whether it's 0 or

252
00:11:05,240 --> 00:11:06,180
1 the

253
00:11:06,180 --> 00:11:08,850
truer if it's zero is going to D commit

254
00:11:08,850 --> 00:11:10,770
and give the randomness used to gobble

255
00:11:10,770 --> 00:11:13,680
the circuit and if it's one she's just

256
00:11:13,680 --> 00:11:15,720
going to give the garbled input

257
00:11:15,720 --> 00:11:18,240
corresponding to the witness now what

258
00:11:18,240 --> 00:11:20,250
does the way the verifier do if B is

259
00:11:20,250 --> 00:11:20,850
zero

260
00:11:20,850 --> 00:11:23,040
he checks if the circuit was garbled

261
00:11:23,040 --> 00:11:27,000
correctly and if B is 1 he's just going

262
00:11:27,000 --> 00:11:29,399
to evaluate the circuit and check if the

263
00:11:29,399 --> 00:11:31,380
output of the relation is 1 according to

264
00:11:31,380 --> 00:11:33,750
this computation now why is this

265
00:11:33,750 --> 00:11:35,760
protocol sound the soul of this protocol

266
00:11:35,760 --> 00:11:37,920
is sound basically by the correctness of

267
00:11:37,920 --> 00:11:41,399
the garbling if you can give valid

268
00:11:41,399 --> 00:11:43,260
randomness for the gobbling and a

269
00:11:43,260 --> 00:11:47,160
garbled input that gives that outputs 1

270
00:11:47,160 --> 00:11:49,620
then you actually can show that the

271
00:11:49,620 --> 00:11:52,440
statement is true in fact it satisfies

272
00:11:52,440 --> 00:11:54,330
what is known as special soundness that

273
00:11:54,330 --> 00:11:55,970
I'll get to in a minute and

274
00:11:55,970 --> 00:11:57,180
zero-knowledge

275
00:11:57,180 --> 00:11:58,950
essentially follows from the simulation

276
00:11:58,950 --> 00:12:00,990
of garbled circuit the simulator guest

277
00:12:00,990 --> 00:12:04,740
guesses whether B is 0 or 1 if it's 0 it

278
00:12:04,740 --> 00:12:06,750
just needs to proceed honestly and if B

279
00:12:06,750 --> 00:12:11,370
is 1 it uses the simulation ok so this

280
00:12:11,370 --> 00:12:12,570
is a very simple zero knowledge proof

281
00:12:12,570 --> 00:12:18,589
starting from garbled circuits now

282
00:12:18,890 --> 00:12:22,350
before I go to the so this is basic zero

283
00:12:22,350 --> 00:12:24,690
knowledge proof I'm going to modify it

284
00:12:24,690 --> 00:12:26,430
so that it also gives the input delayed

285
00:12:26,430 --> 00:12:28,320
property but first let me go over this

286
00:12:28,320 --> 00:12:30,660
definition very quickly of what input

287
00:12:30,660 --> 00:12:33,600
delay leanness means means ok so this is

288
00:12:33,600 --> 00:12:34,740
the definition of zero knowledge proof

289
00:12:34,740 --> 00:12:37,770
first I'm going to discuss what special

290
00:12:37,770 --> 00:12:39,270
soundness this special soundness

291
00:12:39,270 --> 00:12:42,240
basically says for this is defined for

292
00:12:42,240 --> 00:12:43,770
three round protocols which is going to

293
00:12:43,770 --> 00:12:46,230
be the case for us for a given first

294
00:12:46,230 --> 00:12:48,570
message and to convincing transcripts

295
00:12:48,570 --> 00:12:50,550
with different second and third messages

296
00:12:50,550 --> 00:12:52,860
you can extract the witness that's what

297
00:12:52,860 --> 00:12:57,690
special summon is this and so what

298
00:12:57,690 --> 00:12:59,910
happens in a delayed input zero

299
00:12:59,910 --> 00:13:01,560
knowledge proof is that they don't have

300
00:13:01,560 --> 00:13:03,720
the input X comma W and X at the

301
00:13:03,720 --> 00:13:08,910
beginning of the protocol so that is

302
00:13:08,910 --> 00:13:11,640
actually revealed after the second

303
00:13:11,640 --> 00:13:15,450
message now we need to change the

304
00:13:15,450 --> 00:13:16,980
definitions accordingly because the

305
00:13:16,980 --> 00:13:19,680
input is revealed only later first via

306
00:13:19,680 --> 00:13:21,149
spend the the special soundness

307
00:13:21,149 --> 00:13:24,089
guarantee because these two transcript

308
00:13:24,089 --> 00:13:26,279
might not even talk about the same

309
00:13:26,279 --> 00:13:29,399
statement so to enhance this definition

310
00:13:29,399 --> 00:13:31,200
we take the approach of chumpy at all

311
00:13:31,200 --> 00:13:33,690
where basically we say that given to

312
00:13:33,690 --> 00:13:35,730
accepting transcripts you need to output

313
00:13:35,730 --> 00:13:38,370
the witness for both the transcripts the

314
00:13:38,370 --> 00:13:40,620
statements corresponding to both these

315
00:13:40,620 --> 00:13:43,709
transcripts and simulation I am NOT

316
00:13:43,709 --> 00:13:46,200
going to talk about but essentially it

317
00:13:46,200 --> 00:13:47,820
should be able to simulate even if the

318
00:13:47,820 --> 00:13:49,529
statement is revealed after the second

319
00:13:49,529 --> 00:13:52,620
message okay so how am I going to modify

320
00:13:52,620 --> 00:13:54,570
this protocol to get input Delana s--

321
00:13:54,570 --> 00:13:57,870
first we can't hard code X into the

322
00:13:57,870 --> 00:14:00,089
circuit before we guarded so how do we

323
00:14:00,089 --> 00:14:02,100
fix it we're just going to put X as an

324
00:14:02,100 --> 00:14:04,589
input to the circuit in addition we are

325
00:14:04,589 --> 00:14:06,570
also going to make X part of the output

326
00:14:06,570 --> 00:14:08,610
because in one of the cases the verifier

327
00:14:08,610 --> 00:14:10,709
should know what statement is being

328
00:14:10,709 --> 00:14:12,690
proved otherwise the prover will be able

329
00:14:12,690 --> 00:14:14,880
to prove any true statement so X has to

330
00:14:14,880 --> 00:14:17,010
be part of the output to specifically

331
00:14:17,010 --> 00:14:18,930
show which statement the prover is

332
00:14:18,930 --> 00:14:22,020
trying to prove okay so we modify the

333
00:14:22,020 --> 00:14:24,120
circuit to have X as the input and

334
00:14:24,120 --> 00:14:26,370
instead of garbling once we are actually

335
00:14:26,370 --> 00:14:29,820
going to garble twice so just two

336
00:14:29,820 --> 00:14:31,800
independent garbling of the same circuit

337
00:14:31,800 --> 00:14:34,350
it's going to send that now the verifier

338
00:14:34,350 --> 00:14:38,510
still asks just a single bit zero or one

339
00:14:38,510 --> 00:14:40,980
the statement and witness is revealed

340
00:14:40,980 --> 00:14:45,529
after the second round now if B is zero

341
00:14:45,529 --> 00:14:49,589
the prover shows that the first garbling

342
00:14:49,589 --> 00:14:52,529
was done correctly and gives input key

343
00:14:52,529 --> 00:14:54,750
labels according to the statement and

344
00:14:54,750 --> 00:14:57,390
witness for the second gardling and if B

345
00:14:57,390 --> 00:14:59,279
is one he's good she's going to do it

346
00:14:59,279 --> 00:15:01,230
the other way around now why is this

347
00:15:01,230 --> 00:15:03,690
protocol what is the verifier do the

348
00:15:03,690 --> 00:15:05,400
verifier does what he was doing before

349
00:15:05,400 --> 00:15:08,190
basically he's going to verify that this

350
00:15:08,190 --> 00:15:10,740
the first instance if B is zero that the

351
00:15:10,740 --> 00:15:12,360
first instance was constructed correctly

352
00:15:12,360 --> 00:15:15,060
and the second instance evaluates to X

353
00:15:15,060 --> 00:15:19,170
comma one okay and if B is B is one he

354
00:15:19,170 --> 00:15:21,240
does it the other way round now why is

355
00:15:21,240 --> 00:15:23,250
the sound if the prove it can convince

356
00:15:23,250 --> 00:15:25,980
to in two different transcript for the

357
00:15:25,980 --> 00:15:28,470
same first message it means that you can

358
00:15:28,470 --> 00:15:31,230
obtain two valid garb links and two

359
00:15:31,230 --> 00:15:33,090
valid inputs

360
00:15:33,090 --> 00:15:36,840
give the answer one okay so you get this

361
00:15:36,840 --> 00:15:39,330
adaptive special saunas property just by

362
00:15:39,330 --> 00:15:42,030
this simple modification that we do to

363
00:15:42,030 --> 00:15:43,650
the circuit and simulation is

364
00:15:43,650 --> 00:15:46,350
essentially the same as before so this

365
00:15:46,350 --> 00:15:48,180
technique because of the way we use

366
00:15:48,180 --> 00:15:50,430
garbled circuit easily extends to

367
00:15:50,430 --> 00:15:52,410
getting something that is input delayed

368
00:15:52,410 --> 00:15:55,050
okay in our paper we also show how to

369
00:15:55,050 --> 00:15:58,110
get negligible soundness but for now if

370
00:15:58,110 --> 00:16:01,830
you want you can just be satisfied with

371
00:16:01,830 --> 00:16:06,030
soundness half in some sense okay all

372
00:16:06,030 --> 00:16:09,780
right so one more point if for people

373
00:16:09,780 --> 00:16:11,430
familiar with the garbled circuit

374
00:16:11,430 --> 00:16:13,320
literature is that if you choose the

375
00:16:13,320 --> 00:16:15,540
input and witness or inputs to the

376
00:16:15,540 --> 00:16:17,460
garbled circuit after the circuit has

377
00:16:17,460 --> 00:16:19,500
been revealed you need a stronger

378
00:16:19,500 --> 00:16:21,450
property you actually need adaptive

379
00:16:21,450 --> 00:16:23,490
input garbling you're going to see in

380
00:16:23,490 --> 00:16:27,300
this crypto one such construction that

381
00:16:27,300 --> 00:16:32,060
we use in our work as well alright so I

382
00:16:32,060 --> 00:16:36,000
have three minutes I promised you that

383
00:16:36,000 --> 00:16:37,290
I'm going to construct a zero knowledge

384
00:16:37,290 --> 00:16:39,060
proof starting from any two-party

385
00:16:39,060 --> 00:16:41,670
computation in the OT hybrid but you

386
00:16:41,670 --> 00:16:43,530
know I went on about getting everything

387
00:16:43,530 --> 00:16:46,470
from double circuits okay but garbled

388
00:16:46,470 --> 00:16:48,120
circuits themselves can be seen as an

389
00:16:48,120 --> 00:16:50,700
instance of a two-party computation in

390
00:16:50,700 --> 00:16:53,250
the OT hybrid as well as a randomized

391
00:16:53,250 --> 00:16:54,720
encoding these are two interpretations

392
00:16:54,720 --> 00:16:57,390
of garbling and we show in our work how

393
00:16:57,390 --> 00:16:59,100
to construct a zero knowledge from both

394
00:16:59,100 --> 00:17:01,710
of them just using one wavefunction

395
00:17:01,710 --> 00:17:03,900
actually we we show a Lewis

396
00:17:03,900 --> 00:17:05,550
transformation from two party

397
00:17:05,550 --> 00:17:07,050
computation in the OT hybrid to

398
00:17:07,050 --> 00:17:09,810
randomized encoding and then to zero

399
00:17:09,810 --> 00:17:11,430
knowledge now what I'm going to do in

400
00:17:11,430 --> 00:17:13,200
the next couple of minutes is actually

401
00:17:13,200 --> 00:17:15,780
to show this direct construction from

402
00:17:15,780 --> 00:17:19,319
two PC in the OT hybrid to zero

403
00:17:19,319 --> 00:17:22,700
knowledge so this is the main theorem

404
00:17:22,700 --> 00:17:26,339
stated more formally for any NP relation

405
00:17:26,339 --> 00:17:29,880
are consider a two-party computation in

406
00:17:29,880 --> 00:17:33,240
the OT hybrid for a function f such that

407
00:17:33,240 --> 00:17:36,330
these two properties satisfy it should

408
00:17:36,330 --> 00:17:39,210
be perfectly correct and it should admit

409
00:17:39,210 --> 00:17:42,090
you see security against honest but

410
00:17:42,090 --> 00:17:43,220
curious adversary

411
00:17:43,220 --> 00:17:45,860
and then you can show us you mean one

412
00:17:45,860 --> 00:17:47,270
wavefunction there is a zero knowledge

413
00:17:47,270 --> 00:17:50,480
proof for art where f is black box in

414
00:17:50,480 --> 00:17:52,820
our again I'm not going to define this

415
00:17:52,820 --> 00:17:55,280
formally but stay tuned for the next dot

416
00:17:55,280 --> 00:17:58,780
for how this is formally defined okay

417
00:17:58,780 --> 00:18:01,010
alright so static zero knowledge from

418
00:18:01,010 --> 00:18:04,160
two party computation the function that

419
00:18:04,160 --> 00:18:05,810
we are going to do is analogous to what

420
00:18:05,810 --> 00:18:08,090
the i--'cause approach it's going to

421
00:18:08,090 --> 00:18:10,610
evaluate the function on the XOR of the

422
00:18:10,610 --> 00:18:12,590
inputs of the two parties I'm not going

423
00:18:12,590 --> 00:18:13,940
to do the input delayed part I'm just

424
00:18:13,940 --> 00:18:15,590
going to do basic zero knowledge proof

425
00:18:15,590 --> 00:18:19,400
from two party computation so what is

426
00:18:19,400 --> 00:18:21,050
the prover do the prover in her head

427
00:18:21,050 --> 00:18:23,720
computes emulates this two-party

428
00:18:23,720 --> 00:18:25,820
computation and in the first round

429
00:18:25,820 --> 00:18:27,800
instead of committing to the view

430
00:18:27,800 --> 00:18:30,530
actually shares the transcript now you

431
00:18:30,530 --> 00:18:31,940
can't do this in an information

432
00:18:31,940 --> 00:18:33,590
theoretic MPC protocol because the

433
00:18:33,590 --> 00:18:35,720
transcript actually binds everything but

434
00:18:35,720 --> 00:18:37,070
in a two-party computation the

435
00:18:37,070 --> 00:18:39,620
transcript does not reveal information

436
00:18:39,620 --> 00:18:41,930
and that's what the prover gives in the

437
00:18:41,930 --> 00:18:42,560
first round

438
00:18:42,560 --> 00:18:45,410
now the verifier challenges with says

439
00:18:45,410 --> 00:18:48,680
open either party ones view which is

440
00:18:48,680 --> 00:18:51,290
basically its input or randomness or

441
00:18:51,290 --> 00:18:55,610
party choose view okay now this is the

442
00:18:55,610 --> 00:18:59,030
zero knowledge proof why is it sound

443
00:18:59,030 --> 00:19:01,070
because if you can open consistent views

444
00:19:01,070 --> 00:19:03,110
for both parties by perfect correctness

445
00:19:03,110 --> 00:19:07,390
that is a witness for the statement and

446
00:19:07,390 --> 00:19:10,070
simulation because I have assumed you

447
00:19:10,070 --> 00:19:11,990
see simulation of both parties it just

448
00:19:11,990 --> 00:19:13,700
guesses the bit B and simulates

449
00:19:13,700 --> 00:19:17,150
according to that okay now I've cheated

450
00:19:17,150 --> 00:19:20,270
a little bit over here I said to PC in

451
00:19:20,270 --> 00:19:22,070
the OT hybrid and the way I've written

452
00:19:22,070 --> 00:19:24,710
it here you cannot do it based on

453
00:19:24,710 --> 00:19:26,540
one-way function because the transcript

454
00:19:26,540 --> 00:19:29,210
here I must assume some instantiation of

455
00:19:29,210 --> 00:19:32,330
the oblivious transfer okay we in fact

456
00:19:32,330 --> 00:19:34,430
show that we don't need to do that we

457
00:19:34,430 --> 00:19:36,770
can encode the calls made to the

458
00:19:36,770 --> 00:19:40,630
oblivious transfer in a different way so

459
00:19:40,630 --> 00:19:43,250
let me tell you how we do that so let's

460
00:19:43,250 --> 00:19:46,010
say that there is an instance of the

461
00:19:46,010 --> 00:19:48,200
oblivious transfer where tyonne's input

462
00:19:48,200 --> 00:19:50,960
is s 0 s 1 and P 2 is input st how are

463
00:19:50,960 --> 00:19:52,970
we going to incorporate this in the

464
00:19:52,970 --> 00:19:55,390
emulation how is the prove are going to

465
00:19:55,390 --> 00:19:56,900
incorporate it in

466
00:19:56,900 --> 00:19:59,660
transcript basically the prover is going

467
00:19:59,660 --> 00:20:02,420
to commit to s0 and s1 but every

468
00:20:02,420 --> 00:20:04,460
oblivious transfer she is going to

469
00:20:04,460 --> 00:20:07,070
commit to both these inputs now remember

470
00:20:07,070 --> 00:20:08,690
that the verifier challenges to open

471
00:20:08,690 --> 00:20:11,540
either p ones view or p2 his view now if

472
00:20:11,540 --> 00:20:15,020
he asks for t ones view he/she D commits

473
00:20:15,020 --> 00:20:19,070
both as 0 and s 1 and if the verifier

474
00:20:19,070 --> 00:20:23,060
asks the second since the prover is

475
00:20:23,060 --> 00:20:27,790
emulated the actions of peek to the

476
00:20:27,790 --> 00:20:30,560
approval knows exactly which of these

477
00:20:30,560 --> 00:20:34,820
two inputs the p2 is going to C and D

478
00:20:34,820 --> 00:20:38,510
commits only that particular oblivious

479
00:20:38,510 --> 00:20:41,840
transferring okay so commitments just

480
00:20:41,840 --> 00:20:43,460
require one wave function so if you

481
00:20:43,460 --> 00:20:45,110
encode the oblivious transfers this way

482
00:20:45,110 --> 00:20:47,420
you don't need anything more than one

483
00:20:47,420 --> 00:20:50,330
wave function I know I'm out of time I

484
00:20:50,330 --> 00:20:54,050
also had a slide on how to get adaptive

485
00:20:54,050 --> 00:20:56,120
0 knowledge but I'm going to skip that

486
00:20:56,120 --> 00:21:05,570
and I'm just going to go to know I heard

487
00:21:05,570 --> 00:21:07,910
that the first session finished early so

488
00:21:07,910 --> 00:21:13,880
I thought I'd have extra time but that

489
00:21:13,880 --> 00:21:14,960
was not the case

490
00:21:14,960 --> 00:21:18,290
all right quickly one minute about what

491
00:21:18,290 --> 00:21:20,360
we do we actually not only construct

492
00:21:20,360 --> 00:21:23,270
adaptive 0 knowledge we also show one

493
00:21:23,270 --> 00:21:25,460
that has very good communication

494
00:21:25,460 --> 00:21:28,070
complexity ok and this is sort of the

495
00:21:28,070 --> 00:21:30,110
technically most challenging part we

496
00:21:30,110 --> 00:21:31,610
need to use malicious to party

497
00:21:31,610 --> 00:21:33,740
computation and we need an adaptive

498
00:21:33,740 --> 00:21:37,370
version of interactive hashing and now

499
00:21:37,370 --> 00:21:39,860
to my final slide so a general

500
00:21:39,860 --> 00:21:41,690
perspective of what we did here was our

501
00:21:41,690 --> 00:21:44,030
work was more like in the spirit of how

502
00:21:44,030 --> 00:21:46,220
I caused constructed zero knowledge

503
00:21:46,220 --> 00:21:48,890
proof except we started from two party

504
00:21:48,890 --> 00:21:51,100
computation to zero knowledge proof and

505
00:21:51,100 --> 00:21:53,660
we were able to get based on garbled

506
00:21:53,660 --> 00:21:55,430
circuits simple proofs based on garbled

507
00:21:55,430 --> 00:21:57,710
circuits we could get this additional

508
00:21:57,710 --> 00:21:59,680
property of input delay Ness and

509
00:21:59,680 --> 00:22:03,500
adaptive security and another way to see

510
00:22:03,500 --> 00:22:06,200
is that with MPC in the head techniques

511
00:22:06,200 --> 00:22:08,720
you can get like static versions of zero

512
00:22:08,720 --> 00:22:10,590
knowledge if you go to two PC

513
00:22:10,590 --> 00:22:12,360
the head you can also get adaptive

514
00:22:12,360 --> 00:22:14,010
zero-knowledge routes without any

515
00:22:14,010 --> 00:22:17,100
additional assumptions and one more

516
00:22:17,100 --> 00:22:18,480
point that I just want to tell you here

517
00:22:18,480 --> 00:22:20,760
is that this sort of reconciles the cut

518
00:22:20,760 --> 00:22:23,070
and choose approach of garbled circuits

519
00:22:23,070 --> 00:22:25,110
by Lyndell thinkers they actually show

520
00:22:25,110 --> 00:22:27,480
how to get malicious security without

521
00:22:27,480 --> 00:22:29,370
zero knowledge and what this work

522
00:22:29,370 --> 00:22:31,679
essentially says is that they're cut and

523
00:22:31,679 --> 00:22:34,529
choose does in fact give a zero

524
00:22:34,529 --> 00:22:37,049
knowledge proof and that's our basic

525
00:22:37,049 --> 00:22:38,909
construction of our gobble circuits and

526
00:22:38,909 --> 00:22:42,299
finally some future work MPC in the head

527
00:22:42,299 --> 00:22:45,539
was instrumental in the compiler of

528
00:22:45,539 --> 00:22:48,000
chakra Baccarin and Sahai you can ask

529
00:22:48,000 --> 00:22:49,919
the same question for two PC in the head

530
00:22:49,919 --> 00:22:51,809
come and ask me after the talk and I'll

531
00:22:51,809 --> 00:22:55,639
tell you what is it thank you

