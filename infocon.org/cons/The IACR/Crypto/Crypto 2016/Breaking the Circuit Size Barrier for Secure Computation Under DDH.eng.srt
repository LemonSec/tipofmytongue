1
00:00:04,920 --> 00:00:06,540
so this is a joint work together with

2
00:00:06,540 --> 00:00:08,519
you kill boy and you volley shy right

3
00:00:08,519 --> 00:00:10,710
here okay

4
00:00:10,710 --> 00:00:13,200
and the focus is on what's referred to

5
00:00:13,200 --> 00:00:15,240
as the circuit sized barrier okay

6
00:00:15,240 --> 00:00:17,340
so here suppose I have Alice and Bob

7
00:00:17,340 --> 00:00:19,590
with some inputs I want to compute some

8
00:00:19,590 --> 00:00:22,320
circuit scene so if we don't care about

9
00:00:22,320 --> 00:00:24,300
security the the communication that's

10
00:00:24,300 --> 00:00:26,400
required here is very minimal okay I can

11
00:00:26,400 --> 00:00:28,680
just send my input over computationally

12
00:00:28,680 --> 00:00:31,530
performed and the output sent back but

13
00:00:31,530 --> 00:00:33,450
interestingly enough is a you know

14
00:00:33,450 --> 00:00:35,489
crypto conference we want to do this

15
00:00:35,489 --> 00:00:39,510
securely and so by security here I mean

16
00:00:39,510 --> 00:00:41,309
that nothing beyond the output is

17
00:00:41,309 --> 00:00:43,620
revealed so interestingly enough when we

18
00:00:43,620 --> 00:00:45,870
go to this security set in Oh

19
00:00:45,870 --> 00:00:48,210
essentially all known techniques for

20
00:00:48,210 --> 00:00:49,980
achieving this require communication

21
00:00:49,980 --> 00:00:51,780
that grows with the entire circuit size

22
00:00:51,780 --> 00:00:54,690
here as opposed to the inputs and

23
00:00:54,690 --> 00:00:56,760
outputs there can be a very large gap

24
00:00:56,760 --> 00:00:59,429
here and this is what I mean by the

25
00:00:59,429 --> 00:01:02,550
circuit size barrier so essentially all

26
00:01:02,550 --> 00:01:04,580
of the tools that we know how to use

27
00:01:04,580 --> 00:01:06,510
even if you consider for example

28
00:01:06,510 --> 00:01:08,640
restricted classes of programs things

29
00:01:08,640 --> 00:01:10,649
just like branching programs boolean

30
00:01:10,649 --> 00:01:13,799
formulas still require this entire

31
00:01:13,799 --> 00:01:16,020
circuit size and that computation unic

32
00:01:16,020 --> 00:01:19,829
ation so the one exception to this is

33
00:01:19,829 --> 00:01:21,450
the recent breakthrough works and fully

34
00:01:21,450 --> 00:01:24,060
homomorphic encryption which essentially

35
00:01:24,060 --> 00:01:25,530
allows you to get security while

36
00:01:25,530 --> 00:01:28,530
mimicking the original procedure but

37
00:01:28,530 --> 00:01:31,560
underneath a layer of encryption so here

38
00:01:31,560 --> 00:01:33,030
this this breaks the circuit size

39
00:01:33,030 --> 00:01:34,380
barrier it gives you something

40
00:01:34,380 --> 00:01:36,270
comparable again to just inputs and

41
00:01:36,270 --> 00:01:38,759
outputs but of course fully homomorphic

42
00:01:38,759 --> 00:01:41,670
encryption is also non-ideal in a

43
00:01:41,670 --> 00:01:44,880
certain different ways for example even

44
00:01:44,880 --> 00:01:46,259
though we get these great asymptotics

45
00:01:46,259 --> 00:01:48,570
concretely these have very heavy

46
00:01:48,570 --> 00:01:53,729
machinery high concrete costs and in

47
00:01:53,729 --> 00:01:55,679
addition despite a lot of work and a lot

48
00:01:55,679 --> 00:01:57,030
of different candidates that have come

49
00:01:57,030 --> 00:01:58,859
up over the years essentially all of

50
00:01:58,859 --> 00:02:00,600
them rely on the same class of

51
00:02:00,600 --> 00:02:03,390
assumptions boiling down in one or the

52
00:02:03,390 --> 00:02:05,700
other to some sort of noisy encoding /

53
00:02:05,700 --> 00:02:08,660
lattices and in particular there's no

54
00:02:08,660 --> 00:02:11,849
candidates to date based on and sort of

55
00:02:11,849 --> 00:02:16,819
retro 20th century assumptions

56
00:02:16,959 --> 00:02:21,379
okay so let's rewind one year ago your

57
00:02:21,379 --> 00:02:24,620
crypt - 2015 Y presented exactly this

58
00:02:24,620 --> 00:02:27,799
flood on a work in fact with the same

59
00:02:27,799 --> 00:02:30,200
authors on what's known as function

60
00:02:30,200 --> 00:02:32,239
secret sharing so don't worry about what

61
00:02:32,239 --> 00:02:33,799
that is now of course you should look it

62
00:02:33,799 --> 00:02:37,430
up afterward but the important part that

63
00:02:37,430 --> 00:02:39,950
I want to say here is this giant region

64
00:02:39,950 --> 00:02:43,220
in red which is essentially one of the

65
00:02:43,220 --> 00:02:44,810
things we showed is that if they were

66
00:02:44,810 --> 00:02:46,640
able to construct this object this

67
00:02:46,640 --> 00:02:49,340
function secret sharing tool for our

68
00:02:49,340 --> 00:02:51,950
classes of programs sufficiently rich

69
00:02:51,950 --> 00:02:54,829
for example mc1 and above but this would

70
00:02:54,829 --> 00:02:57,260
give you a succinct two-party

71
00:02:57,260 --> 00:02:59,540
computation protocols essentially

72
00:02:59,540 --> 00:03:02,000
breaking the circuit size barrier for

73
00:03:02,000 --> 00:03:06,560
comparable classes of circuits so you'll

74
00:03:06,560 --> 00:03:08,780
see this and this is in red we took this

75
00:03:08,780 --> 00:03:11,540
in fact as a negative result is some

76
00:03:11,540 --> 00:03:13,639
sort of barrier but essentially if if

77
00:03:13,639 --> 00:03:15,109
you wanted to build this kind of

78
00:03:15,109 --> 00:03:17,329
function secret sharing then probably

79
00:03:17,329 --> 00:03:18,829
you you're going to need to use

80
00:03:18,829 --> 00:03:20,239
something like fully homomorphic

81
00:03:20,239 --> 00:03:24,139
encryption so I'm happy to report in

82
00:03:24,139 --> 00:03:26,120
this work we essentially turned the

83
00:03:26,120 --> 00:03:29,840
tables on this negative results and by

84
00:03:29,840 --> 00:03:32,389
constructing exactly this notion this

85
00:03:32,389 --> 00:03:35,659
function secret sharing based not on

86
00:03:35,659 --> 00:03:37,639
fully homomorphic encryption but base

87
00:03:37,639 --> 00:03:39,109
just don't stand our decisional

88
00:03:39,109 --> 00:03:41,540
diffie-hellman okay so we achieve this

89
00:03:41,540 --> 00:03:42,919
for the class of branching programs

90
00:03:42,919 --> 00:03:45,709
which in particular includes this nc1

91
00:03:45,709 --> 00:03:48,139
log space a number of different things

92
00:03:48,139 --> 00:03:51,739
and actually i should take what half

93
00:03:51,739 --> 00:03:53,150
step back so what we achieve is not

94
00:03:53,150 --> 00:03:54,979
exactly the same thing is function

95
00:03:54,979 --> 00:03:57,349
secret sharing and since we have a small

96
00:03:57,349 --> 00:03:59,780
probability of error in the

97
00:03:59,780 --> 00:04:02,120
reconstruction procedure but as it turns

98
00:04:02,120 --> 00:04:04,069
out this is still enough if you boost

99
00:04:04,069 --> 00:04:06,530
within the application and there's still

100
00:04:06,530 --> 00:04:08,180
enough to give you four examples to sync

101
00:04:08,180 --> 00:04:12,799
to MPC ok so the core serum of this work

102
00:04:12,799 --> 00:04:14,449
it's actually going to be a little bit

103
00:04:14,449 --> 00:04:16,220
more convenient to talk about the dual

104
00:04:16,220 --> 00:04:18,589
notion of function secret sharing which

105
00:04:18,589 --> 00:04:21,289
is that a homomorphic secret sharing so

106
00:04:21,289 --> 00:04:24,020
keep in mind I come with some secret and

107
00:04:24,020 --> 00:04:26,570
I have a secret sharing scheme

108
00:04:26,570 --> 00:04:29,630
such that if I want to - now get secret

109
00:04:29,630 --> 00:04:34,400
shares of a function of this secret that

110
00:04:34,400 --> 00:04:36,830
there's some procedure of homomorphic ly

111
00:04:36,830 --> 00:04:38,210
evaluating on the secret shares

112
00:04:38,210 --> 00:04:40,430
independently without communicating back

113
00:04:40,430 --> 00:04:44,690
and forth ok the resulting values these

114
00:04:44,690 --> 00:04:46,670
output shares are exactly an additive

115
00:04:46,670 --> 00:04:49,670
secret sharing of this target function

116
00:04:49,670 --> 00:04:52,250
evaluation as on my input so here

117
00:04:52,250 --> 00:04:53,810
throughout the talk w is going to

118
00:04:53,810 --> 00:04:57,650
represent an input ok so a couple of

119
00:04:57,650 --> 00:04:59,510
notes here first of all you can actually

120
00:04:59,510 --> 00:05:02,540
consider more general reconstruction

121
00:05:02,540 --> 00:05:04,220
procedures here it'll be a bit

122
00:05:04,220 --> 00:05:05,630
convenient for us and gives us some

123
00:05:05,630 --> 00:05:07,070
further applications to consider

124
00:05:07,070 --> 00:05:10,970
explicitly just edition and one of the

125
00:05:10,970 --> 00:05:13,400
benefits of that is that so these

126
00:05:13,400 --> 00:05:15,200
elements these output shares really are

127
00:05:15,200 --> 00:05:17,120
elements of the output space of the

128
00:05:17,120 --> 00:05:19,130
function so for example my branching

129
00:05:19,130 --> 00:05:21,320
function my function f outputs a single

130
00:05:21,320 --> 00:05:24,080
bit then these shares that we have to

131
00:05:24,080 --> 00:05:26,480
exchange are literally one bit not even

132
00:05:26,480 --> 00:05:30,530
encryption they're just one bit okay so

133
00:05:30,530 --> 00:05:32,840
this is homomorphic secret sharing and

134
00:05:32,840 --> 00:05:34,730
as I mentioned we achieve this for the

135
00:05:34,730 --> 00:05:37,670
class of branching programs so X coming

136
00:05:37,670 --> 00:05:39,860
from branching programs with this

137
00:05:39,860 --> 00:05:42,800
noticeable failure probability and this

138
00:05:42,800 --> 00:05:44,840
failure probability is you can trade it

139
00:05:44,840 --> 00:05:49,310
off here in exchange for runtime so note

140
00:05:49,310 --> 00:05:50,990
in particular that this Delta is gonna

141
00:05:50,990 --> 00:05:54,700
have to be noticeable 1 over polynomial

142
00:05:54,700 --> 00:05:57,800
ok so in the rest by the way lambda is

143
00:05:57,800 --> 00:06:01,750
also the security parameter for the DDH

144
00:06:01,750 --> 00:06:05,450
ok so as a function of this core result

145
00:06:05,450 --> 00:06:06,740
we get a collection of different

146
00:06:06,740 --> 00:06:09,680
applications following from DDH the

147
00:06:09,680 --> 00:06:12,440
first of which is of course a secure

148
00:06:12,440 --> 00:06:15,860
two-party computation and here with the

149
00:06:15,860 --> 00:06:17,780
for for the class of branching programs

150
00:06:17,780 --> 00:06:20,360
we essentially can match basically what

151
00:06:20,360 --> 00:06:22,070
you you could hope for in terms of

152
00:06:22,070 --> 00:06:26,110
secure computation for the communication

153
00:06:26,110 --> 00:06:30,140
okay going beyond branching programs for

154
00:06:30,140 --> 00:06:32,810
a much much richer class of circuits we

155
00:06:32,810 --> 00:06:35,150
can basically use this branching program

156
00:06:35,150 --> 00:06:37,060
as a mini tool

157
00:06:37,060 --> 00:06:38,500
in order to shape the communication

158
00:06:38,500 --> 00:06:41,370
complexity to sublinear okay so this

159
00:06:41,370 --> 00:06:43,810
even for this large class of circuits

160
00:06:43,810 --> 00:06:46,210
we'll talk a bit about afterward we can

161
00:06:46,210 --> 00:06:48,390
kind of break this circuit sized barrier

162
00:06:48,390 --> 00:06:51,520
an additional application that I won't

163
00:06:51,520 --> 00:06:52,960
have much time to talk about but

164
00:06:52,960 --> 00:06:54,700
actually this is one of the applications

165
00:06:54,700 --> 00:06:56,080
that does require additive

166
00:06:56,080 --> 00:06:58,720
reconstruction at the end is that a two

167
00:06:58,720 --> 00:07:00,550
server private information retrieval

168
00:07:00,550 --> 00:07:04,000
okay so here you have basically a client

169
00:07:04,000 --> 00:07:05,590
who wants to make secret to branching

170
00:07:05,590 --> 00:07:10,570
program queries onto a database so I've

171
00:07:10,570 --> 00:07:11,770
mentioned this a couple times but I

172
00:07:11,770 --> 00:07:12,940
really want to drive this point home

173
00:07:12,940 --> 00:07:15,670
that branching programs are actually a

174
00:07:15,670 --> 00:07:19,900
pretty rich class of computations so for

175
00:07:19,900 --> 00:07:21,520
example if somebody tomorrow made it

176
00:07:21,520 --> 00:07:24,460
illegal to do any computation beyond

177
00:07:24,460 --> 00:07:26,470
this I would still be pretty happy to

178
00:07:26,470 --> 00:07:30,430
live in this world for example for

179
00:07:30,430 --> 00:07:32,310
example things like approximations

180
00:07:32,310 --> 00:07:34,480
essentially all cryptographic primitives

181
00:07:34,480 --> 00:07:36,520
have some sort of instantiation within

182
00:07:36,520 --> 00:07:40,300
this okay so for the remainder of the

183
00:07:40,300 --> 00:07:42,850
talk I'll I'll go through the

184
00:07:42,850 --> 00:07:44,830
construction I'll actually talk mostly

185
00:07:44,830 --> 00:07:46,450
about a simplified version and then a

186
00:07:46,450 --> 00:07:48,270
little bit about how we get beyond that

187
00:07:48,270 --> 00:07:50,590
and go through applications and then

188
00:07:50,590 --> 00:07:53,830
I'll conclude okay so let's let's get

189
00:07:53,830 --> 00:07:57,430
started okay so it's going to be

190
00:07:57,430 --> 00:07:59,290
convenient for us to instead of going

191
00:07:59,290 --> 00:08:00,790
directly and working with branching

192
00:08:00,790 --> 00:08:02,500
programs to work with the following

193
00:08:02,500 --> 00:08:05,230
class of programs known as restricted

194
00:08:05,230 --> 00:08:07,540
multiplication straight line programs or

195
00:08:07,540 --> 00:08:12,160
RMS okay so these programs have you know

196
00:08:12,160 --> 00:08:14,860
various values in memory and you have

197
00:08:14,860 --> 00:08:16,660
inputs and you were a lot to do for

198
00:08:16,660 --> 00:08:19,120
different types of instructions the

199
00:08:19,120 --> 00:08:21,130
first is to take an input value and load

200
00:08:21,130 --> 00:08:23,710
it into memory you could take two values

201
00:08:23,710 --> 00:08:25,390
in memory and add them together you

202
00:08:25,390 --> 00:08:27,250
could take a value of memory and

203
00:08:27,250 --> 00:08:30,070
multiply it by an input or you can

204
00:08:30,070 --> 00:08:31,870
output a value that's currently held in

205
00:08:31,870 --> 00:08:34,179
memory as an element of a museum of your

206
00:08:34,179 --> 00:08:38,440
choice for example okay so what we're

207
00:08:38,440 --> 00:08:39,520
going to do is we're going to build

208
00:08:39,520 --> 00:08:42,309
homomorphic secret sharing that supports

209
00:08:42,309 --> 00:08:44,230
evaluation of these types of a

210
00:08:44,230 --> 00:08:46,450
restricted multiplication programs over

211
00:08:46,450 --> 00:08:49,070
the integers and we'll get corrected

212
00:08:49,070 --> 00:08:51,200
to hold as long as all of the

213
00:08:51,200 --> 00:08:52,820
intermediate computation values these

214
00:08:52,820 --> 00:08:54,890
integers as you go along are

215
00:08:54,890 --> 00:08:57,380
sufficiently small in magnitude so is a

216
00:08:57,380 --> 00:08:59,060
special case of this if you just think

217
00:08:59,060 --> 00:09:01,220
about zero one binary values through a

218
00:09:01,220 --> 00:09:03,200
computation this is already at rich

219
00:09:03,200 --> 00:09:05,990
enough to capture log space and

220
00:09:05,990 --> 00:09:08,450
branching programs have a very cool site

221
00:09:08,450 --> 00:09:10,070
about that but definitely no time to go

222
00:09:10,070 --> 00:09:12,200
through it okay

223
00:09:12,200 --> 00:09:14,980
but even if you so even if you want to

224
00:09:14,980 --> 00:09:17,150
just compute one of these benching

225
00:09:17,150 --> 00:09:19,280
programs for example you can get some

226
00:09:19,280 --> 00:09:22,640
benefits by by working with the larger

227
00:09:22,640 --> 00:09:25,930
plaintext space than just zero one and

228
00:09:25,930 --> 00:09:29,450
also out of interest so this if you

229
00:09:29,450 --> 00:09:32,720
allow these larger plaintext space this

230
00:09:32,720 --> 00:09:35,450
now captures an entire exotica

231
00:09:35,450 --> 00:09:40,390
complexity class known as reach few l ok

232
00:09:40,390 --> 00:09:43,490
so let's do this warm-up remember we're

233
00:09:43,490 --> 00:09:45,530
in the world of DDH so we have seven DDH

234
00:09:45,530 --> 00:09:48,440
group and a generator and for the time

235
00:09:48,440 --> 00:09:48,830
being

236
00:09:48,830 --> 00:09:51,230
suppose that it were the case that if I

237
00:09:51,230 --> 00:09:54,050
take G to the W but this is a secure

238
00:09:54,050 --> 00:09:57,200
encryption of W it's it's not I hate to

239
00:09:57,200 --> 00:09:59,360
break that to you but suppose for the

240
00:09:59,360 --> 00:10:02,540
time being that it is so here's how

241
00:10:02,540 --> 00:10:03,710
we're going to generate the secret

242
00:10:03,710 --> 00:10:07,670
shares so I come with my input W the

243
00:10:07,670 --> 00:10:08,960
first thing I'm going to do by the way

244
00:10:08,960 --> 00:10:10,790
this line denotes that this will be one

245
00:10:10,790 --> 00:10:12,440
guy's share this will be the other guy's

246
00:10:12,440 --> 00:10:14,960
share first thing I'll do is give

247
00:10:14,960 --> 00:10:16,790
additive secret shares of each of the

248
00:10:16,790 --> 00:10:19,850
values so just random values that add to

249
00:10:19,850 --> 00:10:23,150
the correct value and the second piece

250
00:10:23,150 --> 00:10:25,460
will be to give this sort of pseudo

251
00:10:25,460 --> 00:10:27,770
encryption of my input to each of the

252
00:10:27,770 --> 00:10:29,870
parties and note here that this is the

253
00:10:29,870 --> 00:10:34,580
same value on both sides okay so how can

254
00:10:34,580 --> 00:10:36,710
we do have a morphic evaluation on this

255
00:10:36,710 --> 00:10:38,420
let's step through the four different

256
00:10:38,420 --> 00:10:39,770
things that we have to be able to

257
00:10:39,770 --> 00:10:43,100
support so loading a value into memory

258
00:10:43,100 --> 00:10:45,320
we're going to think about the the

259
00:10:45,320 --> 00:10:47,090
invariant that will maintain is any

260
00:10:47,090 --> 00:10:49,640
value in memory is currently held as an

261
00:10:49,640 --> 00:10:52,280
additive secret share between us ok so

262
00:10:52,280 --> 00:10:54,110
loading an input is already tribute

263
00:10:54,110 --> 00:10:55,760
taken care of because this is part of

264
00:10:55,760 --> 00:10:59,960
the original secret sharing now that

265
00:10:59,960 --> 00:11:01,760
we're that we have this it's

266
00:11:01,760 --> 00:11:04,010
forward to see how can we add values and

267
00:11:04,010 --> 00:11:05,840
memory I have an additive share of this

268
00:11:05,840 --> 00:11:07,790
an additive share of this I can just add

269
00:11:07,790 --> 00:11:09,110
them locally and that gives me an

270
00:11:09,110 --> 00:11:12,200
additive share of this um okay so

271
00:11:12,200 --> 00:11:13,910
multiplication let's skip over this for

272
00:11:13,910 --> 00:11:16,010
a second and let me just say that that

273
00:11:16,010 --> 00:11:17,900
out putting the value of memory is also

274
00:11:17,900 --> 00:11:20,000
reasonably straightforward with a little

275
00:11:20,000 --> 00:11:21,500
bit of a twist you basically need to

276
00:11:21,500 --> 00:11:24,130
just output your additive secret share

277
00:11:24,130 --> 00:11:26,420
okay so the tricky part is how do we do

278
00:11:26,420 --> 00:11:29,480
this multiplication and remember that

279
00:11:29,480 --> 00:11:30,920
here this is where we're going to use

280
00:11:30,920 --> 00:11:33,680
the fact that we have as part of this

281
00:11:33,680 --> 00:11:36,980
input value W we have this encryption or

282
00:11:36,980 --> 00:11:44,030
pseudo encryption okay so we'll take

283
00:11:44,030 --> 00:11:46,280
this G to the W that each of us hold and

284
00:11:46,280 --> 00:11:49,220
raise it to the additive secret share of

285
00:11:49,220 --> 00:11:53,240
our in our memory value X okay so take a

286
00:11:53,240 --> 00:11:55,310
look at this if I multiply these two

287
00:11:55,310 --> 00:12:00,950
values what do I get quite audience all

288
00:12:00,950 --> 00:12:03,140
right I'll tell you the answer you get

289
00:12:03,140 --> 00:12:06,470
shares multiplicative shares now of G to

290
00:12:06,470 --> 00:12:09,920
the product G to the WX here this is

291
00:12:09,920 --> 00:12:10,880
good this is progress

292
00:12:10,880 --> 00:12:13,580
in fact we're trying to get this WX we

293
00:12:13,580 --> 00:12:16,010
want to get shares of it somehow but

294
00:12:16,010 --> 00:12:17,480
what we want to get in order to continue

295
00:12:17,480 --> 00:12:19,190
with with computation is that we need

296
00:12:19,190 --> 00:12:22,280
additive secret shares so how can we get

297
00:12:22,280 --> 00:12:23,780
from these multiplicative shares to

298
00:12:23,780 --> 00:12:25,580
additive it sort of seems like we're

299
00:12:25,580 --> 00:12:28,220
stuck right essentially this would

300
00:12:28,220 --> 00:12:31,880
require us to take discrete log or does

301
00:12:31,880 --> 00:12:37,520
it okay so again our goal now is to get

302
00:12:37,520 --> 00:12:39,760
back to these additive secret shares and

303
00:12:39,760 --> 00:12:42,860
one of the core technical ideas in this

304
00:12:42,860 --> 00:12:44,840
work is the following share conversion

305
00:12:44,840 --> 00:12:48,260
procedure okay so our goal again we have

306
00:12:48,260 --> 00:12:49,970
these multiplicative shares of Jesus

307
00:12:49,970 --> 00:12:52,070
seen and we want to somehow get to

308
00:12:52,070 --> 00:12:54,200
additive secret sharing of this exponent

309
00:12:54,200 --> 00:12:58,670
C okay so let's look at this graphically

310
00:12:58,670 --> 00:13:00,560
the top part and the bottom part are

311
00:13:00,560 --> 00:13:01,790
going to represent the viewers of the

312
00:13:01,790 --> 00:13:05,390
two different parties and each of us and

313
00:13:05,390 --> 00:13:07,190
so here graphically think about this as

314
00:13:07,190 --> 00:13:08,780
stepping along the different powers of

315
00:13:08,780 --> 00:13:13,250
this cyclic group D th group G and

316
00:13:13,250 --> 00:13:14,540
fact that we have a multiplicative

317
00:13:14,540 --> 00:13:17,120
sharing of G to the Z means that we can

318
00:13:17,120 --> 00:13:20,270
drive values that here differ on this

319
00:13:20,270 --> 00:13:28,160
path along by exactly the steps okay so

320
00:13:28,160 --> 00:13:32,240
what we're going to do is to consider a

321
00:13:32,240 --> 00:13:35,960
set of special random points these red

322
00:13:35,960 --> 00:13:38,000
points here whose density is

323
00:13:38,000 --> 00:13:41,240
approximately Delta and whose identity

324
00:13:41,240 --> 00:13:42,920
we can efficiently test and agree upon

325
00:13:42,920 --> 00:13:45,230
so this can be achieved for example just

326
00:13:45,230 --> 00:13:47,060
by sharing a pseudo-random function and

327
00:13:47,060 --> 00:13:51,530
a point some G to the AI is said to be a

328
00:13:51,530 --> 00:13:55,250
red point if this evaluation of the PRF

329
00:13:55,250 --> 00:14:00,770
is zero okay so now our conversion

330
00:14:00,770 --> 00:14:03,410
procedure is going to be as follows so

331
00:14:03,410 --> 00:14:05,570
starting with whatever your share is say

332
00:14:05,570 --> 00:14:07,010
this guy starts here this guy starts

333
00:14:07,010 --> 00:14:11,390
here just iterally we step along on this

334
00:14:11,390 --> 00:14:13,730
path each time multiplying by one copy

335
00:14:13,730 --> 00:14:16,910
of the generator G until you hit a point

336
00:14:16,910 --> 00:14:18,860
that's a special point one of these red

337
00:14:18,860 --> 00:14:21,830
points and the output of this will be

338
00:14:21,830 --> 00:14:23,930
exactly the number of steps that it took

339
00:14:23,930 --> 00:14:27,350
for you to reach that point okay

340
00:14:27,350 --> 00:14:29,540
unless of course so we have this escape

341
00:14:29,540 --> 00:14:31,730
condition that if you go beyond a

342
00:14:31,730 --> 00:14:33,620
certain amount of point and you didn't

343
00:14:33,620 --> 00:14:35,630
see one of the the special points then

344
00:14:35,630 --> 00:14:39,560
just output zero for example okay so why

345
00:14:39,560 --> 00:14:41,540
does this help us well there's three

346
00:14:41,540 --> 00:14:44,030
different cases about where are these

347
00:14:44,030 --> 00:14:46,370
points which potentially could lie as

348
00:14:46,370 --> 00:14:49,250
opposed to where our values are the

349
00:14:49,250 --> 00:14:51,589
first case is the good case for us where

350
00:14:51,589 --> 00:14:53,990
there's no no point in this Zone in

351
00:14:53,990 --> 00:14:56,990
between our values and there is a point

352
00:14:56,990 --> 00:15:01,970
in this zone before abort so in this

353
00:15:01,970 --> 00:15:05,900
case essentially this is good because

354
00:15:05,900 --> 00:15:07,490
each of us is going to output our

355
00:15:07,490 --> 00:15:09,380
distance with respect to the same

356
00:15:09,380 --> 00:15:12,050
special point which means that the

357
00:15:12,050 --> 00:15:13,490
values that we output will differ

358
00:15:13,490 --> 00:15:17,900
additively exactly by this value Z so

359
00:15:17,900 --> 00:15:19,790
this is the good case but there's two

360
00:15:19,790 --> 00:15:21,589
additional cases that would be bad for

361
00:15:21,589 --> 00:15:24,350
us so the first is if there is a point

362
00:15:24,350 --> 00:15:25,790
in this red zone

363
00:15:25,790 --> 00:15:27,650
and the second is if there's no points

364
00:15:27,650 --> 00:15:29,450
in either the zone in which case at

365
00:15:29,450 --> 00:15:30,980
least one of us is going to have to

366
00:15:30,980 --> 00:15:37,820
abort but I never fear so you can set

367
00:15:37,820 --> 00:15:40,460
leave the probability of these events to

368
00:15:40,460 --> 00:15:42,710
be essentially as low as you want okay

369
00:15:42,710 --> 00:15:45,350
so here what is this probability space

370
00:15:45,350 --> 00:15:47,090
correspond to it's roughly going to

371
00:15:47,090 --> 00:15:49,520
scale with the size of this window times

372
00:15:49,520 --> 00:15:52,670
the density of these red points so for

373
00:15:52,670 --> 00:15:55,160
any value that I want to shrink this

374
00:15:55,160 --> 00:15:57,350
error down to what I can do is I can

375
00:15:57,350 --> 00:15:59,210
just make these points less and less

376
00:15:59,210 --> 00:16:02,090
dense and as a trade-off I'll shrink the

377
00:16:02,090 --> 00:16:03,740
error in exchange for needing to take

378
00:16:03,740 --> 00:16:06,260
additional steps so to travel further

379
00:16:06,260 --> 00:16:08,450
along this path before you're expected

380
00:16:08,450 --> 00:16:11,900
to hit one of these points okay so this

381
00:16:11,900 --> 00:16:14,030
is the share conversion procedure and

382
00:16:14,030 --> 00:16:16,340
actually kind of a note out of interest

383
00:16:16,340 --> 00:16:18,410
is that this procedure is a little bit

384
00:16:18,410 --> 00:16:20,750
reminiscent to some applications or some

385
00:16:20,750 --> 00:16:22,910
techniques and crypt analysis and for

386
00:16:22,910 --> 00:16:24,920
example is the technique of N or shot

387
00:16:24,920 --> 00:16:26,960
and wiener and I think it's kind of cool

388
00:16:26,960 --> 00:16:28,160
that we actually turn this into a

389
00:16:28,160 --> 00:16:34,270
constructive technique okay so

390
00:16:34,270 --> 00:16:37,760
summarizing this warm-up construction as

391
00:16:37,760 --> 00:16:40,070
you may recall so loading to memory

392
00:16:40,070 --> 00:16:42,590
Edition and during output we're not a

393
00:16:42,590 --> 00:16:43,100
problem

394
00:16:43,100 --> 00:16:45,740
and to do this procedure of multiplying

395
00:16:45,740 --> 00:16:48,590
an input together with a memory value we

396
00:16:48,590 --> 00:16:50,570
first started by taking you to the W

397
00:16:50,570 --> 00:16:53,030
raising it to the additive share of X

398
00:16:53,030 --> 00:16:55,160
and then running the share conversion

399
00:16:55,160 --> 00:16:58,340
procedure and note by the way so the

400
00:16:58,340 --> 00:16:59,720
error of the share conversion skills

401
00:16:59,720 --> 00:17:02,450
also with the size of the payload so

402
00:17:02,450 --> 00:17:03,710
it's important when you're designing the

403
00:17:03,710 --> 00:17:05,569
scheme this is where we get this

404
00:17:05,569 --> 00:17:07,579
restriction of correctness only as long

405
00:17:07,579 --> 00:17:12,440
as the plain text remains small okay so

406
00:17:12,440 --> 00:17:15,619
this is fantastic I hope you think so

407
00:17:15,619 --> 00:17:19,670
too but of course this is assuming in

408
00:17:19,670 --> 00:17:21,410
this kind of magical land where G to the

409
00:17:21,410 --> 00:17:25,849
W was actually secure encryption so I'm

410
00:17:25,849 --> 00:17:27,530
not going to spend too much time talking

411
00:17:27,530 --> 00:17:29,150
about how we get this beyond because I

412
00:17:29,150 --> 00:17:31,340
think that this this warm-up actually

413
00:17:31,340 --> 00:17:33,080
gives most of the core technical ideas

414
00:17:33,080 --> 00:17:34,730
but let me just give you a little bit of

415
00:17:34,730 --> 00:17:36,470
a flavor of how we remove these

416
00:17:36,470 --> 00:17:39,299
restrictions so the first step

417
00:17:39,299 --> 00:17:41,129
is that instead of taking this G to the

418
00:17:41,129 --> 00:17:43,739
W as some sort of encryption we replace

419
00:17:43,739 --> 00:17:46,350
this with l-jamaa and it will be the

420
00:17:46,350 --> 00:17:49,249
case that we can mimic a similar sort of

421
00:17:49,249 --> 00:17:52,529
step of going from this this encryption

422
00:17:52,529 --> 00:17:54,480
using the additive shares this time

423
00:17:54,480 --> 00:17:57,029
using sort of linear algebra in the

424
00:17:57,029 --> 00:17:59,789
exponent by giving together not only

425
00:17:59,789 --> 00:18:03,659
shares of X the memory value itself but

426
00:18:03,659 --> 00:18:05,279
also will end up maintaining as an

427
00:18:05,279 --> 00:18:07,259
invariant that you have additive shares

428
00:18:07,259 --> 00:18:10,129
of the the secret key for the el-gamal

429
00:18:10,129 --> 00:18:14,159
times X ok and then so I'm not going to

430
00:18:14,159 --> 00:18:16,889
explain why hopefully I will pique your

431
00:18:16,889 --> 00:18:20,220
interest so we'll also need an

432
00:18:20,220 --> 00:18:23,129
encryption now of the input times the

433
00:18:23,129 --> 00:18:25,529
secret key and in order to make the

434
00:18:25,529 --> 00:18:27,690
share conversion procedure work out we

435
00:18:27,690 --> 00:18:29,549
need to keep the payload small and so we

436
00:18:29,549 --> 00:18:33,359
use some bit decomposition tricks okay

437
00:18:33,359 --> 00:18:36,600
so kind of combining these tools in with

438
00:18:36,600 --> 00:18:38,639
a little bit at work gives us a scheme

439
00:18:38,639 --> 00:18:41,669
that's secure but now so we've shifted

440
00:18:41,669 --> 00:18:44,220
the assumption and now we have ldml

441
00:18:44,220 --> 00:18:46,710
which is great but note that we're still

442
00:18:46,710 --> 00:18:50,179
giving an encryption of the secret key

443
00:18:50,179 --> 00:18:52,830
so here this is secure assuming that

444
00:18:52,830 --> 00:18:56,639
l-jamaa is circular secure the final

445
00:18:56,639 --> 00:18:58,739
step is removing this circular security

446
00:18:58,739 --> 00:19:00,749
assumption and there's two potential

447
00:19:00,749 --> 00:19:03,059
ways you can do this so the first is

448
00:19:03,059 --> 00:19:05,129
sort of a typical approach in fully

449
00:19:05,129 --> 00:19:07,320
homomorphic encryption where instead of

450
00:19:07,320 --> 00:19:09,239
giving an encryption of the secret key

451
00:19:09,239 --> 00:19:11,429
under itself you can consider a sequence

452
00:19:11,429 --> 00:19:13,940
sort of a leveled version where in each

453
00:19:13,940 --> 00:19:16,470
each one i give you an encryption of one

454
00:19:16,470 --> 00:19:19,919
key under the next and this so this

455
00:19:19,919 --> 00:19:22,169
blows up the sheer size now by the depth

456
00:19:22,169 --> 00:19:23,820
of computation you need a new key for

457
00:19:23,820 --> 00:19:26,450
each multiplication methyl

458
00:19:26,450 --> 00:19:29,070
however unlike fully homomorphic

459
00:19:29,070 --> 00:19:32,309
encryption actually in our our

460
00:19:32,309 --> 00:19:34,859
construction we can get rid of circular

461
00:19:34,859 --> 00:19:37,499
security altogether basically instead of

462
00:19:37,499 --> 00:19:38,850
in the place of l-jamaa

463
00:19:38,850 --> 00:19:40,889
turns out we can use the encryption

464
00:19:40,889 --> 00:19:42,929
encryption scheme of beaune Halevi

465
00:19:42,929 --> 00:19:45,389
Hamburg and Ostrovsky which is provably

466
00:19:45,389 --> 00:19:47,369
circular secure exactly in the way that

467
00:19:47,369 --> 00:19:49,149
we need based on standard

468
00:19:49,149 --> 00:19:53,979
gdh okay so one last comment before I

469
00:19:53,979 --> 00:19:57,339
move on to applications as I've

470
00:19:57,339 --> 00:19:59,799
described it this secret sharing scheme

471
00:19:59,799 --> 00:20:03,190
is individual for each person okay so if

472
00:20:03,190 --> 00:20:05,019
I want to generate shares of my input I

473
00:20:05,019 --> 00:20:06,279
need to for example generate my own

474
00:20:06,279 --> 00:20:09,700
Alchemist secret key and do things with

475
00:20:09,700 --> 00:20:12,039
respect to that key and the question is

476
00:20:12,039 --> 00:20:14,049
can you hope to get something with

477
00:20:14,049 --> 00:20:16,299
homomorphic computation across different

478
00:20:16,299 --> 00:20:19,149
parties inputs so for example say that I

479
00:20:19,149 --> 00:20:21,009
have some sort of general generation

480
00:20:21,009 --> 00:20:24,070
procedure that gives us a public key and

481
00:20:24,070 --> 00:20:27,039
shared so shared public key and separate

482
00:20:27,039 --> 00:20:30,429
evaluation Keys such that any party who

483
00:20:30,429 --> 00:20:32,799
comes along can now use this public key

484
00:20:32,799 --> 00:20:35,619
in order to share his input so that

485
00:20:35,619 --> 00:20:37,809
later on these servers for example can

486
00:20:37,809 --> 00:20:40,559
can compute across the different shares

487
00:20:40,559 --> 00:20:44,559
okay so this will be important for the

488
00:20:44,559 --> 00:20:47,289
next piece which is now let's shift

489
00:20:47,289 --> 00:20:50,830
gears and talk about applications okay

490
00:20:50,830 --> 00:20:54,609
so kind of the whole thing that brought

491
00:20:54,609 --> 00:20:57,249
us into all this is this question of

492
00:20:57,249 --> 00:20:59,710
secure two-party computation and suppose

493
00:20:59,710 --> 00:21:00,940
that what we want to evaluate is a

494
00:21:00,940 --> 00:21:04,359
branching program so using this public

495
00:21:04,359 --> 00:21:07,179
key version of HSS the first thing that

496
00:21:07,179 --> 00:21:09,009
we'll do is jointly run the key

497
00:21:09,009 --> 00:21:11,109
generation procedure so now we share a

498
00:21:11,109 --> 00:21:13,539
public key and each of us will take one

499
00:21:13,539 --> 00:21:16,769
of the evaluation cues now given this

500
00:21:16,769 --> 00:21:20,200
the parties will secret share using the

501
00:21:20,200 --> 00:21:22,269
homomorphic secret sharing scheme their

502
00:21:22,269 --> 00:21:25,749
inputs and now we can locally evaluate

503
00:21:25,749 --> 00:21:27,489
using the homomorphic evaluation

504
00:21:27,489 --> 00:21:31,330
procedure so remember what we results in

505
00:21:31,330 --> 00:21:35,950
here our secret shares that agree are

506
00:21:35,950 --> 00:21:37,960
the correct values except with some

507
00:21:37,960 --> 00:21:41,349
probability Delta so of course one thing

508
00:21:41,349 --> 00:21:43,479
that we can do is just run this multiple

509
00:21:43,479 --> 00:21:46,749
times independently and interestingly in

510
00:21:46,749 --> 00:21:48,759
the case of secure two-party computation

511
00:21:48,759 --> 00:21:50,739
here we have an issue not only with

512
00:21:50,739 --> 00:21:54,450
correctness so it's but also with

513
00:21:54,450 --> 00:21:57,219
potentially with security if you reveal

514
00:21:57,219 --> 00:22:00,700
whether or not there's errors so but

515
00:22:00,700 --> 00:22:02,710
don't worry you can take care of that

516
00:22:02,710 --> 00:22:04,240
by essentially taking each of these

517
00:22:04,240 --> 00:22:06,580
multiple copies and running another NPC

518
00:22:06,580 --> 00:22:10,510
just to securely output the majority

519
00:22:10,510 --> 00:22:14,470
belly okay a quick taking a look at the

520
00:22:14,470 --> 00:22:17,110
communication required for these three

521
00:22:17,110 --> 00:22:19,450
different parts and using a little bit

522
00:22:19,450 --> 00:22:21,159
of tricks with hybrid encryption

523
00:22:21,159 --> 00:22:23,799
techniques so that we can cut down some

524
00:22:23,799 --> 00:22:25,840
of the costs here essentially we get

525
00:22:25,840 --> 00:22:29,049
back down to what I promised so scaling

526
00:22:29,049 --> 00:22:32,110
is inputs plus poly and the security

527
00:22:32,110 --> 00:22:37,510
parameter times the output okay so going

528
00:22:37,510 --> 00:22:40,149
if you're going beyond branching

529
00:22:40,149 --> 00:22:42,279
programs we can actually apply these

530
00:22:42,279 --> 00:22:44,649
sorts of techniques directly into larger

531
00:22:44,649 --> 00:22:47,140
classes of circuits okay so the

532
00:22:47,140 --> 00:22:50,649
intuition is that I want to view my more

533
00:22:50,649 --> 00:22:53,710
general more general circuit structure

534
00:22:53,710 --> 00:22:56,799
here as a collection of larger branching

535
00:22:56,799 --> 00:22:59,559
program gates and if I have a circuit

536
00:22:59,559 --> 00:23:01,480
for which I can do this for example

537
00:23:01,480 --> 00:23:03,270
essentially all natural natural

538
00:23:03,270 --> 00:23:06,940
non-canonical diabolical circuits can be

539
00:23:06,940 --> 00:23:11,020
put in this form then now by running

540
00:23:11,020 --> 00:23:12,940
exactly what's what I told you in the

541
00:23:12,940 --> 00:23:16,029
previous slide we only need to pay for

542
00:23:16,029 --> 00:23:17,890
the size of the inputs and the outputs

543
00:23:17,890 --> 00:23:20,140
for each of these gates we don't have to

544
00:23:20,140 --> 00:23:21,730
communicate with respect to the entire

545
00:23:21,730 --> 00:23:25,779
branching program science okay and of

546
00:23:25,779 --> 00:23:27,450
course there's a little bit more work

547
00:23:27,450 --> 00:23:29,799
you have to add take care of the error

548
00:23:29,799 --> 00:23:31,929
but we can basically take care of that

549
00:23:31,929 --> 00:23:33,490
by adding the error

550
00:23:33,490 --> 00:23:36,669
encoding and decoding straight into this

551
00:23:36,669 --> 00:23:41,500
branching program gate here okay so to

552
00:23:41,500 --> 00:23:43,419
summarize our results we give a

553
00:23:43,419 --> 00:23:45,789
construction of this Delta homomorphic

554
00:23:45,789 --> 00:23:48,490
secret sharing based on DDH for the

555
00:23:48,490 --> 00:23:50,740
class of branching programs this gives

556
00:23:50,740 --> 00:23:53,409
us various sorts of low communication

557
00:23:53,409 --> 00:23:55,390
secure two-party protocols for

558
00:23:55,390 --> 00:23:58,600
computation and also gives this to

559
00:23:58,600 --> 00:24:00,399
server generalized private information

560
00:24:00,399 --> 00:24:03,520
retrieval so a couple just reflective

561
00:24:03,520 --> 00:24:05,500
comments before I talk about open

562
00:24:05,500 --> 00:24:08,020
questions I think it's very interesting

563
00:24:08,020 --> 00:24:11,559
this error parameter Delta in some sense

564
00:24:11,559 --> 00:24:13,360
maybe it can be viewed as an analog to

565
00:24:13,360 --> 00:24:14,040
the

566
00:24:14,040 --> 00:24:16,620
that occurs in fhe indeed it gives some

567
00:24:16,620 --> 00:24:18,540
sort of limit as far as how you can

568
00:24:18,540 --> 00:24:21,810
compute but interestingly so for fhe if

569
00:24:21,810 --> 00:24:25,380
you want to be able to handle to improve

570
00:24:25,380 --> 00:24:28,590
the error you you increase the size of

571
00:24:28,590 --> 00:24:30,840
the ciphertext typically wears an R

572
00:24:30,840 --> 00:24:32,940
construction in order to battle the

573
00:24:32,940 --> 00:24:34,740
error you actually will just increase

574
00:24:34,740 --> 00:24:38,520
your runtime another note is that this

575
00:24:38,520 --> 00:24:41,100
public key HSS version can actually be

576
00:24:41,100 --> 00:24:43,260
viewed is sort of a weak form of

577
00:24:43,260 --> 00:24:44,160
threshold to fully homomorphic

578
00:24:44,160 --> 00:24:46,740
encryption okay so the difference the

579
00:24:46,740 --> 00:24:48,720
why is this a weak version is that the

580
00:24:48,720 --> 00:24:51,210
parties have secret about secret

581
00:24:51,210 --> 00:24:56,430
evaluation keys okay but sort of one of

582
00:24:56,430 --> 00:24:57,900
the things I guess that we show is that

583
00:24:57,900 --> 00:25:00,120
standard threshold fhe is maybe a little

584
00:25:00,120 --> 00:25:01,500
bit of an overkill for these

585
00:25:01,500 --> 00:25:03,300
applications of secure two-party

586
00:25:03,300 --> 00:25:07,560
computation okay so very quickly some

587
00:25:07,560 --> 00:25:08,970
some open questions I think it's a

588
00:25:08,970 --> 00:25:12,060
really fascinating area that's really

589
00:25:12,060 --> 00:25:14,250
just being opened up right now as far as

590
00:25:14,250 --> 00:25:17,280
we can tell so beyond branching programs

591
00:25:17,280 --> 00:25:19,170
this is an obvious question is there

592
00:25:19,170 --> 00:25:21,470
some way of supporting for example

593
00:25:21,470 --> 00:25:23,430
multiplications of two memory values

594
00:25:23,430 --> 00:25:25,950
directly or doing some sort of fhe style

595
00:25:25,950 --> 00:25:30,180
branching bootstrapping procedure our so

596
00:25:30,180 --> 00:25:31,590
our construction is really limited to

597
00:25:31,590 --> 00:25:33,750
two parties and the reason is exactly

598
00:25:33,750 --> 00:25:35,100
because of this share conversion

599
00:25:35,100 --> 00:25:38,250
procedure this the stepping along really

600
00:25:38,250 --> 00:25:40,500
relies on the fact that we have values

601
00:25:40,500 --> 00:25:44,210
that are differing by Z but the payload

602
00:25:44,210 --> 00:25:46,350
there are there ways that you can extend

603
00:25:46,350 --> 00:25:48,540
beyond two parties if you guys were in a

604
00:25:48,540 --> 00:25:52,140
spooky section in just before here there

605
00:25:52,140 --> 00:25:54,300
they showed some gmw style techniques

606
00:25:54,300 --> 00:25:56,700
that allowed them to go to additional

607
00:25:56,700 --> 00:25:58,290
parties partially it seems that those

608
00:25:58,290 --> 00:26:01,920
don't quite work in this case can you do

609
00:26:01,920 --> 00:26:03,180
a similar approach but under different

610
00:26:03,180 --> 00:26:05,480
assumptions factoring for example RSA

611
00:26:05,480 --> 00:26:08,460
seem very in line with this and of

612
00:26:08,460 --> 00:26:09,630
course all sorts of optimizing

613
00:26:09,630 --> 00:26:12,420
complexity improving the error there's a

614
00:26:12,420 --> 00:26:16,290
lot to be done there and so with that

615
00:26:16,290 --> 00:26:18,330
I'm happy to report that as of yesterday

616
00:26:18,330 --> 00:26:20,670
we have a complete full version of the

617
00:26:20,670 --> 00:26:22,800
paper up on ePrint and I invite you to

618
00:26:22,800 --> 00:26:24,760
take a look thank you

619
00:26:24,760 --> 00:26:26,820
you

