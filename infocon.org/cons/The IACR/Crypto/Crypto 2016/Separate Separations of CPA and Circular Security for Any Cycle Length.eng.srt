1
00:00:04,109 --> 00:00:07,029
thanks for the introduction hi everyone

2
00:00:07,029 --> 00:00:08,950
I'm nervous and I'm gonna talk about

3
00:00:08,950 --> 00:00:11,139
separate separations of CPM circular

4
00:00:11,139 --> 00:00:14,290
security for any cycle length this talk

5
00:00:14,290 --> 00:00:16,420
is based on two independent works one by

6
00:00:16,420 --> 00:00:18,340
me and Chris by cart and one by and when

7
00:00:18,340 --> 00:00:21,550
cata Cocula and Brent waters ok let's

8
00:00:21,550 --> 00:00:22,329
get started

9
00:00:22,329 --> 00:00:24,759
back to classical notions of security we

10
00:00:24,759 --> 00:00:26,739
have two well-known definitions one is

11
00:00:26,739 --> 00:00:28,840
CPA security which says that encryptions

12
00:00:28,840 --> 00:00:31,360
of adversarially choose a message are

13
00:00:31,360 --> 00:00:33,430
computationally indistinguishable you

14
00:00:33,430 --> 00:00:35,260
know the attacker submits to message and

15
00:00:35,260 --> 00:00:37,180
receive the challenge ciphertext and it

16
00:00:37,180 --> 00:00:39,250
has to determine which one is encrypted

17
00:00:39,250 --> 00:00:42,760
under public key and one is CC security

18
00:00:42,760 --> 00:00:44,560
which is defined similarly except that

19
00:00:44,560 --> 00:00:46,990
the attacker has access to the exception

20
00:00:46,990 --> 00:00:50,230
Oracle so the question is what is common

21
00:00:50,230 --> 00:00:52,630
in both of these definitions and the

22
00:00:52,630 --> 00:00:54,880
point is that both of these notions only

23
00:00:54,880 --> 00:00:56,410
consider the message that can be

24
00:00:56,410 --> 00:01:00,250
generated by the attacker so let's

25
00:01:00,250 --> 00:01:01,870
consider a situation in which we have

26
00:01:01,870 --> 00:01:04,509
encryption of secret keys in this figure

27
00:01:04,509 --> 00:01:07,149
each directed edge shows that tail

28
00:01:07,149 --> 00:01:09,130
secret key is encrypted under heads

29
00:01:09,130 --> 00:01:11,620
public key for example an edge from Bob

30
00:01:11,620 --> 00:01:13,659
- Alice shows that Bob secret key is

31
00:01:13,659 --> 00:01:17,800
encrypted under Alice's public key so as

32
00:01:17,800 --> 00:01:20,320
long as there is no cycle we can say

33
00:01:20,320 --> 00:01:22,510
that CK security of each individual

34
00:01:22,510 --> 00:01:23,590
encryption scheme

35
00:01:23,590 --> 00:01:25,870
devices for the CPA security of whole

36
00:01:25,870 --> 00:01:28,360
system this is observed by Goldwasser

37
00:01:28,360 --> 00:01:32,470
and Macaulay and now the question

38
00:01:32,470 --> 00:01:36,658
becomes what if we have a cycle

39
00:01:44,030 --> 00:01:48,770
okay to answer the question what if we

40
00:01:48,770 --> 00:01:50,690
have a cycle it turns out that Hybrid

41
00:01:50,690 --> 00:01:52,460
argument breaks in this setting and we

42
00:01:52,460 --> 00:01:54,890
have uncertain security in general so it

43
00:01:54,890 --> 00:01:59,990
might be secure or it might be not to

44
00:01:59,990 --> 00:02:01,910
see that this example is not just a

45
00:02:01,910 --> 00:02:04,070
superficial thing we have a few

46
00:02:04,070 --> 00:02:05,990
applications which use key cycles like

47
00:02:05,990 --> 00:02:07,760
password managers and disk encryption

48
00:02:07,760 --> 00:02:10,580
utilities anonymous credential schemes

49
00:02:10,580 --> 00:02:13,220
which was introduced by combination

50
00:02:13,220 --> 00:02:15,620
license kya and proven competition on

51
00:02:15,620 --> 00:02:18,260
some soft symbolic protocols by Dowell

52
00:02:18,260 --> 00:02:22,610
at all and more recently and maybe the

53
00:02:22,610 --> 00:02:25,520
most famous example is bootstrapping

54
00:02:25,520 --> 00:02:27,709
technique for obtaining unbounded fully

55
00:02:27,709 --> 00:02:32,750
amorphic encryption by gentry so what

56
00:02:32,750 --> 00:02:35,030
kind of definition captures this

57
00:02:35,030 --> 00:02:38,360
requirement let's see we say that the

58
00:02:38,360 --> 00:02:41,720
public encryption scheme is casar pule

59
00:02:41,720 --> 00:02:43,760
are secure if an encryption cycle is

60
00:02:43,760 --> 00:02:45,590
indistinguishable from encryption of

61
00:02:45,590 --> 00:02:47,900
junk message so in other words if you

62
00:02:47,900 --> 00:02:49,880
encrypt a first secret country sacred

63
00:02:49,880 --> 00:02:52,700
second public key second secret calendar

64
00:02:52,700 --> 00:02:54,440
third public and so forth and then

65
00:02:54,440 --> 00:02:57,739
cycling back case secret can the first

66
00:02:57,739 --> 00:02:59,900
public key should be indistinguishable

67
00:02:59,900 --> 00:03:02,560
from encryption of all zeros

68
00:03:02,560 --> 00:03:05,269
this definition can also be strengthened

69
00:03:05,269 --> 00:03:07,489
to key dependent message security which

70
00:03:07,489 --> 00:03:09,440
considers functions of one or more

71
00:03:09,440 --> 00:03:11,630
secret keys now the main question

72
00:03:11,630 --> 00:03:15,019
becomes does CPA or CCA into like a

73
00:03:15,019 --> 00:03:17,510
circular security the answer is negative

74
00:03:17,510 --> 00:03:20,000
and we have a few separations based on

75
00:03:20,000 --> 00:03:23,000
different assumptions let's have a look

76
00:03:23,000 --> 00:03:25,459
on price operations we have this photo

77
00:03:25,459 --> 00:03:28,130
result for one circular security which

78
00:03:28,130 --> 00:03:31,100
says that any CPA secure scheme can be

79
00:03:31,100 --> 00:03:33,560
transformed one that is still CPA secure

80
00:03:33,560 --> 00:03:37,549
but not one circular secure for cake was

81
00:03:37,549 --> 00:03:39,670
too there are separations based on

82
00:03:39,670 --> 00:03:42,110
standard assumptions earlier works were

83
00:03:42,110 --> 00:03:44,840
based on a 6 th assumption and bilinear

84
00:03:44,840 --> 00:03:48,470
groups and more recently we have tons of

85
00:03:48,470 --> 00:03:50,450
examples from learning with errors and

86
00:03:50,450 --> 00:03:54,020
decision linear assumption and then this

87
00:03:54,020 --> 00:03:57,410
what good progress for K equals 2

88
00:03:57,410 --> 00:03:59,570
only non-separation sport a greater than

89
00:03:59,570 --> 00:04:01,940
two are based on somewhat strong

90
00:04:01,940 --> 00:04:04,670
application assumption one uses virtual

91
00:04:04,670 --> 00:04:08,570
black box up Fisk Asian which later they

92
00:04:08,570 --> 00:04:11,540
refine their scheme to rely on IO and

93
00:04:11,540 --> 00:04:13,300
one users in distinguishability

94
00:04:13,300 --> 00:04:19,190
obfuscation okay the question is can we

95
00:04:19,190 --> 00:04:21,649
get rid of obfuscation assumption for

96
00:04:21,649 --> 00:04:25,160
the case say greater than do and here is

97
00:04:25,160 --> 00:04:28,100
the main theorem which says that for any

98
00:04:28,100 --> 00:04:30,770
K greater than one there exists CPA

99
00:04:30,770 --> 00:04:32,480
security schemes which are not

100
00:04:32,480 --> 00:04:35,690
recirculate secure based on learning

101
00:04:35,690 --> 00:04:37,820
with errors and it's ring variate

102
00:04:37,820 --> 00:04:41,860
variant for n2 DK approximation factors

103
00:04:41,860 --> 00:04:44,300
these are first operations for K greater

104
00:04:44,300 --> 00:04:46,040
than dude that do not rely on

105
00:04:46,040 --> 00:04:47,830
obfuscation assumptions and

106
00:04:47,830 --> 00:04:50,270
constructions are not specific for just

107
00:04:50,270 --> 00:04:52,010
K they are also K prime circular

108
00:04:52,010 --> 00:04:56,990
insecure for K prime less than J we used

109
00:04:56,990 --> 00:04:58,490
a few new techniques to achieve this

110
00:04:58,490 --> 00:05:00,710
result such as telescoping products for

111
00:05:00,710 --> 00:05:02,420
learning with errors which is sort of

112
00:05:02,420 --> 00:05:05,660
the main idea in both works and tensors

113
00:05:05,660 --> 00:05:08,480
lwe to get commutativity of the lwe

114
00:05:08,480 --> 00:05:13,010
secrets here we see features of both

115
00:05:13,010 --> 00:05:16,160
constructions at a glance allow

116
00:05:16,160 --> 00:05:18,080
mattifier constructions which we also

117
00:05:18,080 --> 00:05:19,790
call it a few constructions are somewhat

118
00:05:19,790 --> 00:05:20,750
simple and direct

119
00:05:20,750 --> 00:05:22,700
especially in ring setting we will see

120
00:05:22,700 --> 00:05:25,670
it soon various KW constructions are

121
00:05:25,670 --> 00:05:28,010
more complicated however it comes with

122
00:05:28,010 --> 00:05:33,260
some benefits ap constructions has

123
00:05:33,260 --> 00:05:35,300
smaller public keys secret keys and

124
00:05:35,300 --> 00:05:37,970
ciphertext in ring setting whereas kW

125
00:05:37,970 --> 00:05:40,340
constructions is more efficient in plane

126
00:05:40,340 --> 00:05:43,310
LW version and ap constructions use

127
00:05:43,310 --> 00:05:45,530
common random string whereas kW

128
00:05:45,530 --> 00:05:48,440
construction has no common random string

129
00:05:48,440 --> 00:05:53,120
and finally AP constructions handles

130
00:05:53,120 --> 00:05:56,450
just constant cycle length in plane LW

131
00:05:56,450 --> 00:05:59,140
version various kW constructions handles

132
00:05:59,140 --> 00:06:04,700
polynomial cycle length okay people

133
00:06:04,700 --> 00:06:06,620
going into the construction let's say

134
00:06:06,620 --> 00:06:09,380
useful abstraction which is called cycle

135
00:06:09,380 --> 00:06:10,389
cluster and

136
00:06:10,389 --> 00:06:13,360
introduced by Bishop along burger and

137
00:06:13,360 --> 00:06:15,610
waters we say that the tuple of

138
00:06:15,610 --> 00:06:18,370
randomized algorithms Jen and can test

139
00:06:18,370 --> 00:06:21,340
together is a cycle tester when Jen an

140
00:06:21,340 --> 00:06:24,009
egg is CPA secure note that definition

141
00:06:24,009 --> 00:06:26,409
of CP security does not involve any

142
00:06:26,409 --> 00:06:29,500
decryption algorithm so we are not

143
00:06:29,500 --> 00:06:33,069
concerned with decryption and given K

144
00:06:33,069 --> 00:06:34,979
public keys and corresponding ciphertext

145
00:06:34,979 --> 00:06:38,319
test distinguishes cycles from cycles

146
00:06:38,319 --> 00:06:42,340
with a noticeable advantage here is the

147
00:06:42,340 --> 00:06:44,830
theorem from beach w15 which simplifies

148
00:06:44,830 --> 00:06:47,139
our job to make a counter example it

149
00:06:47,139 --> 00:06:49,199
says that a case I can tester plus

150
00:06:49,199 --> 00:06:51,849
essentially any CPA secure or CCA

151
00:06:51,849 --> 00:06:55,360
security scheme implies separation of K

152
00:06:55,360 --> 00:06:58,029
circular from CPA or CCA security and

153
00:06:58,029 --> 00:07:00,460
again by separation we mean a scheme

154
00:07:00,460 --> 00:07:03,520
which is CPA or CCA secure but not K

155
00:07:03,520 --> 00:07:08,500
circular secure ok let's have a quick

156
00:07:08,500 --> 00:07:11,770
review on latest Raptors Gen trap is a

157
00:07:11,770 --> 00:07:14,050
randomized algorithm which uses a bar as

158
00:07:14,050 --> 00:07:16,900
common random string and or as random

159
00:07:16,900 --> 00:07:19,120
coins which also we call it trapdoors to

160
00:07:19,120 --> 00:07:22,479
generate matrix a where a has a bar as

161
00:07:22,479 --> 00:07:26,020
its prefix once you know the trapdoor

162
00:07:26,020 --> 00:07:28,089
for matrix a it allows you to compute

163
00:07:28,089 --> 00:07:31,870
short random X such that ax equals any

164
00:07:31,870 --> 00:07:34,150
right hand any arbitrary right hand side

165
00:07:34,150 --> 00:07:36,909
note that is inverse operation is not a

166
00:07:36,909 --> 00:07:39,279
normal inverse operation and it's rather

167
00:07:39,279 --> 00:07:42,939
a randomized procedure and finally this

168
00:07:42,939 --> 00:07:45,490
inverse operation is also known as

169
00:07:45,490 --> 00:07:47,620
Gaussian preimage sampling which has

170
00:07:47,620 --> 00:07:50,849
been used in many cryptography contexts

171
00:07:50,849 --> 00:07:54,250
now let's get into the construction here

172
00:07:54,250 --> 00:07:56,289
the message space is identical to the

173
00:07:56,289 --> 00:07:59,529
sacred key space first to set up we

174
00:07:59,529 --> 00:08:01,779
sample a uniform a bar as common random

175
00:08:01,779 --> 00:08:08,339
string so key generation is very simple

176
00:08:08,339 --> 00:08:11,500
to generate a key you sample a trapdoor

177
00:08:11,500 --> 00:08:13,900
from random space and then you run gen

178
00:08:13,900 --> 00:08:17,139
trap on a bar and R so a is our public

179
00:08:17,139 --> 00:08:20,949
key and R is our secret key encryption

180
00:08:20,949 --> 00:08:23,800
algorithm is more

181
00:08:23,800 --> 00:08:26,680
to encrypt a message which we viewed as

182
00:08:26,680 --> 00:08:30,220
a trap door under public GA we run Jen

183
00:08:30,220 --> 00:08:32,320
trap on a bar and message to get the

184
00:08:32,320 --> 00:08:36,250
matrix a tilde and then we choose short

185
00:08:36,250 --> 00:08:38,470
matrix s so the ciphertext would be a

186
00:08:38,470 --> 00:08:41,559
tilde inverse of noisy si or we can view

187
00:08:41,559 --> 00:08:45,070
it as Gaussian preimage of lwe sample

188
00:08:45,070 --> 00:08:49,450
for which s is short secret and finally

189
00:08:49,450 --> 00:08:53,110
to test the cycle we simply compare

190
00:08:53,110 --> 00:08:55,600
prefixes of two products where each

191
00:08:55,600 --> 00:08:59,050
product is one public key multiplied by

192
00:08:59,050 --> 00:09:06,070
all of the ciphertext not that here two

193
00:09:06,070 --> 00:09:09,040
public keys are arbitrary and we can use

194
00:09:09,040 --> 00:09:11,740
any two different public keys as long as

195
00:09:11,740 --> 00:09:15,520
they have different index okay let's see

196
00:09:15,520 --> 00:09:19,510
why cycle tester works first we when we

197
00:09:19,510 --> 00:09:21,850
encrypt secret key or I minus one on the

198
00:09:21,850 --> 00:09:25,570
next public key AI we run Jen trap on a

199
00:09:25,570 --> 00:09:28,600
bar and RI minus one to get AI minus 1

200
00:09:28,600 --> 00:09:31,300
and then the ciphertext would be a I

201
00:09:31,300 --> 00:09:34,300
minus 1 inverse off know is the SI AI or

202
00:09:34,300 --> 00:09:38,650
again the ciphertext can be viewed as a

203
00:09:38,650 --> 00:09:44,250
Gaussian trim age of noisy lwe sample

204
00:09:46,020 --> 00:09:49,120
okay let's see what cycle tester

205
00:09:49,120 --> 00:09:50,980
computes if you have a look on

206
00:09:50,980 --> 00:09:53,380
telescoping product for K equals 3 in

207
00:09:53,380 --> 00:09:56,260
the first line we could rewrite c0 as a2

208
00:09:56,260 --> 00:10:00,190
inverse of s 0 a0 here we see that a 2

209
00:10:00,190 --> 00:10:02,350
and a 2 inverse annihilate each other

210
00:10:02,350 --> 00:10:08,050
and what left is a 0 a 0 C 1 C 2 up to

211
00:10:08,050 --> 00:10:10,240
small nose in the second line again we

212
00:10:10,240 --> 00:10:13,000
can rewrite C 1 as a 0 inverse of s 1 a

213
00:10:13,000 --> 00:10:16,090
1 and then a 0 and a 0 in western Iowa

214
00:10:16,090 --> 00:10:18,190
to each other and then doing similarly

215
00:10:18,190 --> 00:10:22,480
finally we get s 0 s 1 s 2 a 2 if we do

216
00:10:22,480 --> 00:10:24,160
the same thing similarly for the other

217
00:10:24,160 --> 00:10:31,590
chunk what we get is s 1 s 2 s 0 a 0 so

218
00:10:31,590 --> 00:10:35,440
tester gets almost equal chunks except

219
00:10:35,440 --> 00:10:36,470
with differ

220
00:10:36,470 --> 00:10:39,470
public keys and different order but it's

221
00:10:39,470 --> 00:10:41,240
not so difficult to address these issues

222
00:10:41,240 --> 00:10:45,560
the first point is that thanks to James

223
00:10:45,560 --> 00:10:47,540
wrap all of the public keys have common

224
00:10:47,540 --> 00:10:49,550
prefix a bar and the second point is

225
00:10:49,550 --> 00:10:52,370
that in ring LW we know that this are

226
00:10:52,370 --> 00:10:54,500
corresponding elements so they commute

227
00:10:54,500 --> 00:10:58,250
under multiplication so that's why cycle

228
00:10:58,250 --> 00:11:02,360
tester works in ring setting however

229
00:11:02,360 --> 00:11:04,960
unlike other cryptographic constructions

230
00:11:04,960 --> 00:11:08,180
the ring based version does not

231
00:11:08,180 --> 00:11:10,610
immediately train translate into plain

232
00:11:10,610 --> 00:11:14,300
lwe mainly because matrices as i do not

233
00:11:14,300 --> 00:11:18,320
commute using ten string technique for

234
00:11:18,320 --> 00:11:21,110
LW we get commutativity of this I and

235
00:11:21,110 --> 00:11:24,290
then consequently we get plain LW

236
00:11:24,290 --> 00:11:26,000
construction I'm not going to get into

237
00:11:26,000 --> 00:11:27,740
that because of time but you can refer

238
00:11:27,740 --> 00:11:32,840
to the paper to see more details and now

239
00:11:32,840 --> 00:11:34,850
I want to encode to continue the talk on

240
00:11:34,850 --> 00:11:40,970
kW construction thanks all right so this

241
00:11:40,970 --> 00:11:42,890
separation will be based on joint work

242
00:11:42,890 --> 00:11:45,590
with Brent waters and in this part we

243
00:11:45,590 --> 00:11:48,800
show an LW based encryption scheme which

244
00:11:48,800 --> 00:11:52,520
is not K so kilo secure and this K could

245
00:11:52,520 --> 00:11:54,320
be any polynomial in the security

246
00:11:54,320 --> 00:11:56,930
parameter and while both separations

247
00:11:56,930 --> 00:11:59,360
have some common features the two

248
00:11:59,360 --> 00:12:00,830
constructions are inherently different

249
00:12:00,830 --> 00:12:02,960
and as a result each has its own pros

250
00:12:02,960 --> 00:12:04,970
and cons in particular our scheme is

251
00:12:04,970 --> 00:12:07,610
more complicated but it does not require

252
00:12:07,610 --> 00:12:08,990
the common random string does not

253
00:12:08,990 --> 00:12:11,060
require commutativity and can handle

254
00:12:11,060 --> 00:12:14,840
poly poly length cycles so as a warm-up

255
00:12:14,840 --> 00:12:16,850
I'll first present a separation for K

256
00:12:16,850 --> 00:12:20,050
equals to 1 and as now it mentioned

257
00:12:20,050 --> 00:12:22,220
separation for k equals to 1 is pretty

258
00:12:22,220 --> 00:12:24,380
trivial you can convert any in CPA

259
00:12:24,380 --> 00:12:26,630
scheme into one that is still in CP

260
00:12:26,630 --> 00:12:28,730
secure but not case one circular secure

261
00:12:28,730 --> 00:12:30,350
but the reason I'm presenting this is

262
00:12:30,350 --> 00:12:32,600
because it has more structure and it

263
00:12:32,600 --> 00:12:34,430
will lead to a more general case

264
00:12:34,430 --> 00:12:38,210
circular secure conquer example so we

265
00:12:38,210 --> 00:12:40,220
need to present three algorithms the key

266
00:12:40,220 --> 00:12:42,140
generation encryption and the testing

267
00:12:42,140 --> 00:12:45,260
algorithm first the key generation this

268
00:12:45,260 --> 00:12:46,850
chooses a large number of random

269
00:12:46,850 --> 00:12:48,760
matrices r1 2 RL

270
00:12:48,760 --> 00:12:50,920
uses each of these matrices as

271
00:12:50,920 --> 00:12:53,050
randomness for generating the AI

272
00:12:53,050 --> 00:12:55,090
matrices using the Gen trap algorithm

273
00:12:55,090 --> 00:12:58,030
next it chooses a large number of

274
00:12:58,030 --> 00:13:02,260
matrices x1 to xn + + - 1 scalars why I

275
00:13:02,260 --> 00:13:04,510
went to yl which are random subject to

276
00:13:04,510 --> 00:13:06,580
the condition that summation Y I times X

277
00:13:06,580 --> 00:13:07,600
I is equal to 0

278
00:13:07,600 --> 00:13:10,570
the public key consists of 2 l matrices

279
00:13:10,570 --> 00:13:14,260
the first LR VI times a is and the

280
00:13:14,260 --> 00:13:15,940
remaining L are the X I I excite

281
00:13:15,940 --> 00:13:18,340
matrices and the secret key is simply

282
00:13:18,340 --> 00:13:20,320
the randomness used for generating the a

283
00:13:20,320 --> 00:13:24,790
is given this public key let's see how

284
00:13:24,790 --> 00:13:27,340
the encryption works the encryption also

285
00:13:27,340 --> 00:13:29,710
consists of for each message consists of

286
00:13:29,710 --> 00:13:31,660
L components and each of these

287
00:13:31,660 --> 00:13:33,520
components is used as randomness fortune

288
00:13:33,520 --> 00:13:36,160
trap so each of these components mi

289
00:13:36,160 --> 00:13:39,670
gives us a matrix zi next you choose a

290
00:13:39,670 --> 00:13:42,940
short matrix S and the ciphertext

291
00:13:42,940 --> 00:13:45,280
consists of L components where the I ate

292
00:13:45,280 --> 00:13:47,080
component is zi inverse of an

293
00:13:47,080 --> 00:13:51,370
approximation of s times X I so given

294
00:13:51,370 --> 00:13:53,530
this public key and ciphertext let's now

295
00:13:53,530 --> 00:13:55,930
see how the test algorithm works the

296
00:13:55,930 --> 00:13:58,360
test algorithm is really simple it takes

297
00:13:58,360 --> 00:14:02,530
the it takes the IH component of the

298
00:14:02,530 --> 00:14:04,120
public key multiplied with the I ate

299
00:14:04,120 --> 00:14:06,280
component of the ciphertext and then

300
00:14:06,280 --> 00:14:11,200
checks if the Sun is close to 0 to see

301
00:14:11,200 --> 00:14:12,700
why this works let us look at the

302
00:14:12,700 --> 00:14:14,110
encryption of the secret key

303
00:14:14,110 --> 00:14:17,770
so the IH component is AI inverse of an

304
00:14:17,770 --> 00:14:20,980
approximation of s times X I so now if

305
00:14:20,980 --> 00:14:24,130
you multiply this I ate component with

306
00:14:24,130 --> 00:14:25,930
the I ate Cawood component of the public

307
00:14:25,930 --> 00:14:29,890
key you'll get Y I times a by I times a

308
00:14:29,890 --> 00:14:32,440
I inverse Y a by I times AI times AI

309
00:14:32,440 --> 00:14:36,580
inverse of s times X I so this is

310
00:14:36,580 --> 00:14:39,880
nothing but Y I times s times X I so if

311
00:14:39,880 --> 00:14:42,430
you sum them all up it is approximately

312
00:14:42,430 --> 00:14:44,830
s times summation Y I X I which is equal

313
00:14:44,830 --> 00:14:48,070
to 0 so in this way if you have an

314
00:14:48,070 --> 00:14:50,470
encryption of the secret key then the

315
00:14:50,470 --> 00:14:53,410
test algorithm outputs 0 or a short

316
00:14:53,410 --> 00:14:55,300
matrix and instead if you have an

317
00:14:55,300 --> 00:14:57,820
encryption of zeroes then the final

318
00:14:57,820 --> 00:14:59,740
matrix that you get is some large matrix

319
00:14:59,740 --> 00:15:00,760
and hence you can distinguish between

320
00:15:00,760 --> 00:15:01,089
the

321
00:15:01,089 --> 00:15:05,259
two scenarios so now how do we go from k

322
00:15:05,259 --> 00:15:08,949
equal to 1 to k greater than 1 so for

323
00:15:08,949 --> 00:15:11,889
this we need to modify our construction

324
00:15:11,889 --> 00:15:16,629
and for this scheme will have the keygen

325
00:15:16,629 --> 00:15:18,100
and the encryption algorithms will have

326
00:15:18,100 --> 00:15:21,279
two modes of operation and the test

327
00:15:21,279 --> 00:15:22,779
algorithm we'll be using the first

328
00:15:22,779 --> 00:15:25,199
public key and the case ifotx

329
00:15:25,199 --> 00:15:29,379
so this is what will look like and for

330
00:15:29,379 --> 00:15:31,180
simplicity for now let's assume that the

331
00:15:31,180 --> 00:15:32,199
first public key and the first

332
00:15:32,199 --> 00:15:33,939
ciphertext are of the form that we have

333
00:15:33,939 --> 00:15:37,180
already seen the remaining cipher texts

334
00:15:37,180 --> 00:15:40,240
are not computed in such a manner such

335
00:15:40,240 --> 00:15:42,009
that if they form an encryption of the

336
00:15:42,009 --> 00:15:44,290
secret key then if you combine each

337
00:15:44,290 --> 00:15:48,579
column then you get VI times X I for

338
00:15:48,579 --> 00:15:51,970
each column so if if these form

339
00:15:51,970 --> 00:15:54,129
encryptions are the secret key then if

340
00:15:54,129 --> 00:15:56,019
you combine each column then at the

341
00:15:56,019 --> 00:15:58,389
bottom you get via some matrix x of i I

342
00:15:58,389 --> 00:16:02,230
times X I so actually the main action is

343
00:16:02,230 --> 00:16:03,670
happening with only with the first

344
00:16:03,670 --> 00:16:05,410
public key in the first cipher text the

345
00:16:05,410 --> 00:16:06,490
other cipher texts are merely

346
00:16:06,490 --> 00:16:10,360
propagating the by I've al use so let's

347
00:16:10,360 --> 00:16:13,449
see how to implement this for this we

348
00:16:13,449 --> 00:16:16,089
will first extend the cycle test

349
00:16:16,089 --> 00:16:19,509
framework of bhw to have two two special

350
00:16:19,509 --> 00:16:20,949
modes called the leader mode and the

351
00:16:20,949 --> 00:16:23,499
follower mode and the leader mode is

352
00:16:23,499 --> 00:16:24,600
what we have already seen

353
00:16:24,600 --> 00:16:27,879
so in this abstraction we have five

354
00:16:27,879 --> 00:16:30,910
algorithms and two for the leader mode

355
00:16:30,910 --> 00:16:32,230
two for the follower mode and one the

356
00:16:32,230 --> 00:16:35,110
tester algorithm the keygen and the

357
00:16:35,110 --> 00:16:36,579
encryption algorithms work as expected

358
00:16:36,579 --> 00:16:38,920
the keygen gives out public keys and

359
00:16:38,920 --> 00:16:40,360
secret keys and the encryption gives out

360
00:16:40,360 --> 00:16:43,899
ciphertext and we require in CPA

361
00:16:43,899 --> 00:16:45,699
security for both the leader Moore and

362
00:16:45,699 --> 00:16:48,670
the follower mode and the test algorithm

363
00:16:48,670 --> 00:16:50,410
must be able to distinguish between K

364
00:16:50,410 --> 00:16:52,329
cycles and encryptions of non cycles if

365
00:16:52,329 --> 00:16:54,339
the first public key and the ciphertext

366
00:16:54,339 --> 00:16:58,720
I on the leader mole so if we can

367
00:16:58,720 --> 00:17:01,120
construct these five algorithms then

368
00:17:01,120 --> 00:17:04,148
it's easy to see how it's either you see

369
00:17:04,148 --> 00:17:06,159
how this implies a K cycle tester I

370
00:17:06,159 --> 00:17:08,770
won't talk about the and the stuff but

371
00:17:08,770 --> 00:17:11,289
it's easy to transform the case I go

372
00:17:11,289 --> 00:17:13,059
tester with leader follower set up to

373
00:17:13,059 --> 00:17:15,599
1/2 DB hwk

374
00:17:15,599 --> 00:17:18,930
so let's now look at the five algorithms

375
00:17:18,930 --> 00:17:21,819
first we look at the leader mode which

376
00:17:21,819 --> 00:17:24,069
is very similar to the once one cycle

377
00:17:24,069 --> 00:17:26,950
separation that we already seen the key

378
00:17:26,950 --> 00:17:28,720
generation algorithm chooses a bunch of

379
00:17:28,720 --> 00:17:30,640
matrices using the general algorithm and

380
00:17:30,640 --> 00:17:33,400
then chooses the X I matrices these VI

381
00:17:33,400 --> 00:17:35,860
scalars and construct the public here as

382
00:17:35,860 --> 00:17:39,640
shown and the leader encryption

383
00:17:39,640 --> 00:17:42,460
algorithm is also as we've seen will use

384
00:17:42,460 --> 00:17:44,320
the message components as randomness for

385
00:17:44,320 --> 00:17:46,630
Gen trap compute zi matrices should

386
00:17:46,630 --> 00:17:49,420
choose a short matrix and the ciphertext

387
00:17:49,420 --> 00:17:51,550
consists of zi inverse of an

388
00:17:51,550 --> 00:17:55,390
approximation of x times X I the

389
00:17:55,390 --> 00:17:59,070
follower mode is also really simple to

390
00:17:59,070 --> 00:18:01,720
generate a follower mode public key you

391
00:18:01,720 --> 00:18:04,090
first choose L matrices using the gen

392
00:18:04,090 --> 00:18:06,340
trap algorithm these matrix matrices

393
00:18:06,340 --> 00:18:08,710
correspond the public key and the

394
00:18:08,710 --> 00:18:12,670
randomness is the secret key and finally

395
00:18:12,670 --> 00:18:15,460
the encryption algorithm uses the

396
00:18:15,460 --> 00:18:17,410
message components as the randomness for

397
00:18:17,410 --> 00:18:19,960
Jen trap it computes the matrix zi

398
00:18:19,960 --> 00:18:22,330
chooses a short matrix S and a

399
00:18:22,330 --> 00:18:24,880
ciphertext is consists of zi inverse of

400
00:18:24,880 --> 00:18:27,160
s times AI so know that this is very

401
00:18:27,160 --> 00:18:29,620
similar to the leader encryption except

402
00:18:29,620 --> 00:18:32,170
that we are using s times AI instead of

403
00:18:32,170 --> 00:18:37,150
x times X ID for the test algorithm we

404
00:18:37,150 --> 00:18:39,310
have these we have the first public key

405
00:18:39,310 --> 00:18:41,740
and the case ifotx we compute the

406
00:18:41,740 --> 00:18:44,290
product of each column and then check if

407
00:18:44,290 --> 00:18:47,760
the sum of the products is close to zero

408
00:18:47,760 --> 00:18:50,290
to see why this works let's look at the

409
00:18:50,290 --> 00:18:53,200
case for K equals to three and we have

410
00:18:53,200 --> 00:18:54,670
the three public keys where the first

411
00:18:54,670 --> 00:18:56,200
one is in the leader mode the remaining

412
00:18:56,200 --> 00:18:59,770
two are in the follower mode and we have

413
00:18:59,770 --> 00:19:01,930
the three ciphertext where the first two

414
00:19:01,930 --> 00:19:04,360
cipher ticks are in the follower mode

415
00:19:04,360 --> 00:19:06,300
and the last one is in the leader mode

416
00:19:06,300 --> 00:19:08,800
so now let's look at the first cipher

417
00:19:08,800 --> 00:19:10,240
text which is an encryption of SK 1

418
00:19:10,240 --> 00:19:13,300
using PK 2 this is nothing but a 1 I

419
00:19:13,300 --> 00:19:15,760
inverse of an approximation of s 2 times

420
00:19:15,760 --> 00:19:19,900
a 2 1 similarly the second ciphertext C

421
00:19:19,900 --> 00:19:23,200
C T 3 is consists of components of the

422
00:19:23,200 --> 00:19:25,930
form a 2 I inverse of an approximation

423
00:19:25,930 --> 00:19:28,600
of s 3 times a 3 1 the

424
00:19:28,600 --> 00:19:31,450
last one is in the leader mode and it is

425
00:19:31,450 --> 00:19:35,080
a 3-1 inverse of a 3i inverse of an

426
00:19:35,080 --> 00:19:39,640
approximation of s2 s1 times X I so now

427
00:19:39,640 --> 00:19:41,230
if you multiply each column let's look

428
00:19:41,230 --> 00:19:43,330
at the first column then if you multiply

429
00:19:43,330 --> 00:19:45,370
the first two terms you get y1 times s2

430
00:19:45,370 --> 00:19:47,980
x a 2-1 then multiply that with the

431
00:19:47,980 --> 00:19:51,220
third term you get y1 times s 2 s 3

432
00:19:51,220 --> 00:19:53,290
times a 3 1 and then if you multiply all

433
00:19:53,290 --> 00:19:56,380
of them you get y1 times s 2 s 3 s 1

434
00:19:56,380 --> 00:19:58,570
times x1 and so on

435
00:19:58,570 --> 00:20:02,260
yl times s to s trace 1 times X a so if

436
00:20:02,260 --> 00:20:05,200
you sum these all up the sum is close to

437
00:20:05,200 --> 00:20:09,790
0 because summation Y I times X is 0 so

438
00:20:09,790 --> 00:20:12,040
that concludes the construction I won't

439
00:20:12,040 --> 00:20:15,220
talk about the proof to conclude we show

440
00:20:15,220 --> 00:20:17,620
separations between CP and CCS security

441
00:20:17,620 --> 00:20:20,860
and K circular security and some of the

442
00:20:20,860 --> 00:20:22,900
techniques used are telescoping products

443
00:20:22,900 --> 00:20:27,010
and entering l w and looking back so

444
00:20:27,010 --> 00:20:28,450
testing cycles can be seen as a very

445
00:20:28,450 --> 00:20:31,120
simple form of computation on encrypted

446
00:20:31,120 --> 00:20:33,490
data so a question natural question is

447
00:20:33,490 --> 00:20:35,200
can we use these techniques for richer

448
00:20:35,200 --> 00:20:37,450
computations on encrypted data that

449
00:20:37,450 --> 00:20:40,890
concludes a talk thank you

