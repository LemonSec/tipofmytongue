1
00:00:03,830 --> 00:00:06,229
so this particular research project

2
00:00:06,229 --> 00:00:08,389
started when we were looking at TLS and

3
00:00:08,389 --> 00:00:10,250
in particular the news the upcoming

4
00:00:10,250 --> 00:00:13,550
version TLS 1.3 I guess since you all

5
00:00:13,550 --> 00:00:15,500
attended Brian's great lecture this

6
00:00:15,500 --> 00:00:17,269
morning I don't really have to motivate

7
00:00:17,269 --> 00:00:20,210
more TLS s about but let me just say as

8
00:00:20,210 --> 00:00:22,249
a photographer I envision it usually

9
00:00:22,249 --> 00:00:24,499
starting with the following all the

10
00:00:24,499 --> 00:00:29,199
Clippers would with the following idea

11
00:00:29,199 --> 00:00:31,220
which I'm going to show you on the next

12
00:00:31,220 --> 00:00:33,519
slide

13
00:00:36,820 --> 00:00:41,239
ok great ok so I assume that this here

14
00:00:41,239 --> 00:00:42,829
is my my laptop computer and I'm going

15
00:00:42,829 --> 00:00:44,989
to access some some secure web site so

16
00:00:44,989 --> 00:00:46,940
there's a web server and I want to

17
00:00:46,940 --> 00:00:48,739
secure connection between my laptop my

18
00:00:48,739 --> 00:00:50,629
client computer and the server but of

19
00:00:50,629 --> 00:00:52,489
course there might be attackers that try

20
00:00:52,489 --> 00:00:55,339
to well degrade my security try to

21
00:00:55,339 --> 00:00:57,039
attack my connection

22
00:00:57,039 --> 00:01:00,469
well actually this isn't quite how the

23
00:01:00,469 --> 00:01:02,539
world looks like because there's about a

24
00:01:02,539 --> 00:01:04,640
billion of other people maybe using

25
00:01:04,640 --> 00:01:07,820
their web to web browsers as well to it

26
00:01:07,820 --> 00:01:10,790
to connect web servers there's mail

27
00:01:10,790 --> 00:01:13,610
servers using TLS database servers

28
00:01:13,610 --> 00:01:15,590
there's embedded devices and sensors

29
00:01:15,590 --> 00:01:18,230
that use TLS to communicate their data

30
00:01:18,230 --> 00:01:20,000
to whatever service they want to

31
00:01:20,000 --> 00:01:22,490
communicate to so the word looks a bit

32
00:01:22,490 --> 00:01:25,670
more like this and actually even that's

33
00:01:25,670 --> 00:01:27,110
not quite how the world looks like

34
00:01:27,110 --> 00:01:29,120
because there are adversaries that are

35
00:01:29,120 --> 00:01:31,970
not actually interested in breaking my

36
00:01:31,970 --> 00:01:33,860
specific connection but they do massive

37
00:01:33,860 --> 00:01:38,420
aliens so they have huge capacity who's

38
00:01:38,420 --> 00:01:40,580
in storage and computation and they do

39
00:01:40,580 --> 00:01:42,200
massive Arinze on the internet and try

40
00:01:42,200 --> 00:01:44,360
to attack as soon well we have to assume

41
00:01:44,360 --> 00:01:46,160
that they try to attack whatever that

42
00:01:46,160 --> 00:01:50,360
can so let's have a bit more of a closer

43
00:01:50,360 --> 00:01:53,660
look to TLS so from like 10,000 foot

44
00:01:53,660 --> 00:01:56,030
perspective here s looks like this it

45
00:01:56,030 --> 00:01:58,550
starts with a with one protocol phase

46
00:01:58,550 --> 00:02:00,290
which is usually called the handshake

47
00:02:00,290 --> 00:02:02,060
and uses a symmetric cryptography and

48
00:02:02,060 --> 00:02:04,160
the role of this is to create a

49
00:02:04,160 --> 00:02:06,170
symmetric key which is shared between

50
00:02:06,170 --> 00:02:08,538
the two parties that take part in

51
00:02:08,538 --> 00:02:10,970
protocol and they use this key in the

52
00:02:10,970 --> 00:02:12,860
second protocol phase usually referred

53
00:02:12,860 --> 00:02:16,020
to as the record layer protocol to

54
00:02:16,020 --> 00:02:18,480
protect the actual payload data and this

55
00:02:18,480 --> 00:02:20,660
is based on authenticated encryption

56
00:02:20,660 --> 00:02:23,040
until has one point three at least

57
00:02:23,040 --> 00:02:25,770
so in particular it's nonce based

58
00:02:25,770 --> 00:02:27,990
authentication encryption and I just

59
00:02:27,990 --> 00:02:29,700
want to remind you what that means it

60
00:02:29,700 --> 00:02:31,380
means we have two algorithms and

61
00:02:31,380 --> 00:02:34,350
encryption and a decryption both

62
00:02:34,350 --> 00:02:35,880
obviously take the key

63
00:02:35,880 --> 00:02:38,640
the encryption takes the method and an

64
00:02:38,640 --> 00:02:40,650
additional message that moms and as long

65
00:02:40,650 --> 00:02:44,370
as the nonce is unique this is going to

66
00:02:44,370 --> 00:02:46,230
achieve some good notion of security

67
00:02:46,230 --> 00:02:47,730
which I'm going to explain them in a

68
00:02:47,730 --> 00:02:49,260
minute but the important property is we

69
00:02:49,260 --> 00:02:50,640
want this nonce to be unique we don't

70
00:02:50,640 --> 00:02:51,960
need to be random there's a

71
00:02:51,960 --> 00:02:53,760
deterministic algorithm and the

72
00:02:53,760 --> 00:02:55,350
non-stressed has to be remain unique

73
00:02:55,350 --> 00:02:57,300
until we switch the key then we can

74
00:02:57,300 --> 00:03:00,090
reduce the monsters the decryption also

75
00:03:00,090 --> 00:03:03,030
takes the key and the nonce and also of

76
00:03:03,030 --> 00:03:04,650
course the cipher takes to generate a

77
00:03:04,650 --> 00:03:06,690
message or maybe an error symbol so we

78
00:03:06,690 --> 00:03:08,850
want confidentiality which means the

79
00:03:08,850 --> 00:03:10,710
ciphertext shouldn't tell you more about

80
00:03:10,710 --> 00:03:12,720
the plaintext there may be the length of

81
00:03:12,720 --> 00:03:15,000
the plate X and we want integrity which

82
00:03:15,000 --> 00:03:16,860
is usually described as if you don't

83
00:03:16,860 --> 00:03:18,780
have the key you won't be able to come

84
00:03:18,780 --> 00:03:20,580
up with ciphertext that is going to be

85
00:03:20,580 --> 00:03:25,650
accepted by the receiver so DL as a

86
00:03:25,650 --> 00:03:27,330
principle can use different types of

87
00:03:27,330 --> 00:03:29,040
non-space authentication encryption but

88
00:03:29,040 --> 00:03:30,450
the one that is kind of in the pole

89
00:03:30,450 --> 00:03:32,610
position to be used in most connections

90
00:03:32,610 --> 00:03:36,120
is AES GCM which I've tried to draw on

91
00:03:36,120 --> 00:03:38,520
this slide so there's some important

92
00:03:38,520 --> 00:03:40,320
properties here first the key to the

93
00:03:40,320 --> 00:03:42,360
authenticated encryption is going to be

94
00:03:42,360 --> 00:03:45,060
used as a key to the AES block cipher

95
00:03:45,060 --> 00:03:46,830
and it's used only there okay so

96
00:03:46,830 --> 00:03:48,750
whenever we use the key it is to be a

97
00:03:48,750 --> 00:03:52,740
EES the nonce TLS only uses ninety-six

98
00:03:52,740 --> 00:03:54,510
bit announcers and for those nonsense

99
00:03:54,510 --> 00:03:56,610
GCM words we work as follows it will

100
00:03:56,610 --> 00:03:59,730
take those 96 bits and append another 32

101
00:03:59,730 --> 00:04:02,880
bits before it a 96 bits and 32 before

102
00:04:02,880 --> 00:04:05,130
it gives them to two AES and basically

103
00:04:05,130 --> 00:04:07,200
this part of the scheme here is then

104
00:04:07,200 --> 00:04:09,330
just a counter mode encryption that

105
00:04:09,330 --> 00:04:13,770
starts at the nonce okay over here we

106
00:04:13,770 --> 00:04:16,019
just evaluate AES with a key that we got

107
00:04:16,019 --> 00:04:18,420
on an all-zero bit string this is just

108
00:04:18,420 --> 00:04:20,190
to generate another like uniformly

109
00:04:20,190 --> 00:04:21,660
random value which we are going to use

110
00:04:21,660 --> 00:04:24,330
as a key and in a hash function so this

111
00:04:24,330 --> 00:04:26,220
is an almost XOR a universal hash

112
00:04:26,220 --> 00:04:27,900
function it's based on finitely

113
00:04:27,900 --> 00:04:28,599
everything

114
00:04:28,599 --> 00:04:29,919
but that's not important for us today

115
00:04:29,919 --> 00:04:32,770
and basically what we do is we hash the

116
00:04:32,770 --> 00:04:35,259
ciphertext that we computed we computed

117
00:04:35,259 --> 00:04:38,349
it here using counter mode meaning we

118
00:04:38,349 --> 00:04:41,259
XOR the message blocks to to the output

119
00:04:41,259 --> 00:04:44,499
of the block cipher and we hash this and

120
00:04:44,499 --> 00:04:47,439
then again apply another like mask value

121
00:04:47,439 --> 00:04:50,409
that we obtained from AES too to obtain

122
00:04:50,409 --> 00:04:51,849
the last part of ciphertext this is

123
00:04:51,849 --> 00:04:53,770
basically a Mac so you can think of this

124
00:04:53,770 --> 00:04:55,749
as being an authenticate than angry

125
00:04:55,749 --> 00:04:57,909
sorry encrypt-then-mac scheme with

126
00:04:57,909 --> 00:05:01,180
counter mode and a almost EXO Universal

127
00:05:01,180 --> 00:05:05,949
hash function based so how would this be

128
00:05:05,949 --> 00:05:09,089
used in TLS how would terrorists use

129
00:05:09,089 --> 00:05:11,110
authenticated encryption to predict the

130
00:05:11,110 --> 00:05:13,479
data so first of all there's two

131
00:05:13,479 --> 00:05:14,949
directions one from the client to the

132
00:05:14,949 --> 00:05:16,389
server one from the server to the client

133
00:05:16,389 --> 00:05:18,610
they use completely independent keys so

134
00:05:18,610 --> 00:05:20,349
we can focus at them independently I'm

135
00:05:20,349 --> 00:05:22,149
only talking about one direction on the

136
00:05:22,149 --> 00:05:25,899
following slide and the goal of TLS is

137
00:05:25,899 --> 00:05:29,469
to actually transmit like a sequence of

138
00:05:29,469 --> 00:05:30,039
messages

139
00:05:30,039 --> 00:05:32,110
okay so client and server may

140
00:05:32,110 --> 00:05:34,029
communicate for some time and we want to

141
00:05:34,029 --> 00:05:35,800
communicate those messages in sequence

142
00:05:35,800 --> 00:05:37,509
it's a sequence of bytes stream the byte

143
00:05:37,509 --> 00:05:41,860
strings so what we would do then is we

144
00:05:41,860 --> 00:05:43,389
use the authenticated encryption of

145
00:05:43,389 --> 00:05:44,800
course with a key that we got in the

146
00:05:44,800 --> 00:05:47,139
first phase the message that we want to

147
00:05:47,139 --> 00:05:50,319
transmit and the sequence number of that

148
00:05:50,319 --> 00:05:51,669
particular message so we count the

149
00:05:51,669 --> 00:05:53,319
messages and just use the sequence

150
00:05:53,319 --> 00:05:55,089
number to encrypt the message we use

151
00:05:55,089 --> 00:05:55,990
that as an ox

152
00:05:55,990 --> 00:05:58,959
and of course like the nonces are 96 bit

153
00:05:58,959 --> 00:06:00,129
long as they are not going to overflow

154
00:06:00,129 --> 00:06:03,039
so this value is going to be unique and

155
00:06:03,039 --> 00:06:05,740
it's going to be a very good Knox and as

156
00:06:05,740 --> 00:06:08,079
long as we're in the kind of a single

157
00:06:08,079 --> 00:06:09,819
connection domain we only look at the

158
00:06:09,819 --> 00:06:11,349
security of the signal kind of eight

159
00:06:11,349 --> 00:06:13,149
single connection this is a perfectly

160
00:06:13,149 --> 00:06:18,430
good scheme okay but now so this is all

161
00:06:18,430 --> 00:06:21,459
discussion which happened on like before

162
00:06:21,459 --> 00:06:23,499
our research project even started so I'm

163
00:06:23,499 --> 00:06:26,559
basically just recap English there is a

164
00:06:26,559 --> 00:06:28,959
possible attack that a very powell and

165
00:06:28,959 --> 00:06:30,369
computationally and storage wise

166
00:06:30,369 --> 00:06:32,439
powerful entity could run and this is as

167
00:06:32,439 --> 00:06:35,499
follows I'll include the first part of a

168
00:06:35,499 --> 00:06:37,839
es PCM here okay so I'm going to look at

169
00:06:37,839 --> 00:06:38,820
the first of the

170
00:06:38,820 --> 00:06:42,780
of the first block of the first message

171
00:06:42,780 --> 00:06:44,370
of the channel now the first sequence

172
00:06:44,370 --> 00:06:47,070
number is all zero so the first nonce we

173
00:06:47,070 --> 00:06:50,400
use is all 0 so the nonce that we input

174
00:06:50,400 --> 00:06:56,610
here turns out to be actually 126 zeros

175
00:06:56,610 --> 00:06:57,990
than one and ten is zero

176
00:06:57,990 --> 00:06:59,430
I don't know why I put it to here it

177
00:06:59,430 --> 00:07:03,750
should be one zero and also let's look

178
00:07:03,750 --> 00:07:06,510
at the output here because for most

179
00:07:06,510 --> 00:07:08,670
protocols for example agent if you if

180
00:07:08,670 --> 00:07:10,350
you encrypt an HTTP connection

181
00:07:10,350 --> 00:07:13,080
the first message that the client is

182
00:07:13,080 --> 00:07:14,490
going to send to the server is going to

183
00:07:14,490 --> 00:07:17,490
be it's going to be HTTP GET and then

184
00:07:17,490 --> 00:07:20,220
URL and protocol so we know what this

185
00:07:20,220 --> 00:07:22,680
plaintext is going to be the same holds

186
00:07:22,680 --> 00:07:25,020
for almost like any other protocol that

187
00:07:25,020 --> 00:07:26,670
is specified they start with some kind

188
00:07:26,670 --> 00:07:28,800
of header information which is paste so

189
00:07:28,800 --> 00:07:30,840
by just looking at the traffic we will

190
00:07:30,840 --> 00:07:32,100
actually be pretty good in predicting

191
00:07:32,100 --> 00:07:34,800
the first blocks of the plaintext okay

192
00:07:34,800 --> 00:07:37,320
so when we attack a connection we can

193
00:07:37,320 --> 00:07:39,540
just assume that this isn't there we can

194
00:07:39,540 --> 00:07:45,000
kind of uncomputable that must have been

195
00:07:45,000 --> 00:07:47,850
used to encrypt that part of the

196
00:07:47,850 --> 00:07:51,000
plaintext and now if you are a very

197
00:07:51,000 --> 00:07:53,130
powerful entity with a huge storage and

198
00:07:53,130 --> 00:07:54,870
computation center maybe in the desert

199
00:07:54,870 --> 00:07:57,450
of Utah then you could have the idea to

200
00:07:57,450 --> 00:08:01,170
compute a huge table for this input okay

201
00:08:01,170 --> 00:08:04,080
and this table contains some huge

202
00:08:04,080 --> 00:08:06,030
selection of keys however much you can

203
00:08:06,030 --> 00:08:08,250
store and the corresponding output of

204
00:08:08,250 --> 00:08:10,890
the block cipher using that key on that

205
00:08:10,890 --> 00:08:15,390
input okay now if you once you see a

206
00:08:15,390 --> 00:08:17,970
connection you try to compute this this

207
00:08:17,970 --> 00:08:19,740
output value by by kind of predicting

208
00:08:19,740 --> 00:08:21,420
the head about you that is encrypted and

209
00:08:21,420 --> 00:08:24,360
you look at them in your table you look

210
00:08:24,360 --> 00:08:26,190
at you look up the key that might be

211
00:08:26,190 --> 00:08:27,900
used in that connection and you might

212
00:08:27,900 --> 00:08:29,910
have the key I mean there may be several

213
00:08:29,910 --> 00:08:32,010
keys or so but there's a pretty good

214
00:08:32,010 --> 00:08:33,570
probability that if you find the key

215
00:08:33,570 --> 00:08:36,030
that is actually the correct one now is

216
00:08:36,030 --> 00:08:39,990
this attack realistic so let's make some

217
00:08:39,990 --> 00:08:42,990
bold assumptions here maybe the NSA can

218
00:08:42,990 --> 00:08:45,360
store two to the 64 of those ropes it's

219
00:08:45,360 --> 00:08:46,380
probably a bit more than they can

220
00:08:46,380 --> 00:08:49,080
actually store but it's not too far away

221
00:08:49,080 --> 00:08:52,270
then we have some billions of devices

222
00:08:52,270 --> 00:08:55,450
that run TLS sessions every day and by

223
00:08:55,450 --> 00:08:56,980
just assuming each of them runs a

224
00:08:56,980 --> 00:08:58,870
hundred sessions we arrive at pretty

225
00:08:58,870 --> 00:09:02,260
much two to the poori sessions okay so a

226
00:09:02,260 --> 00:09:06,280
s has a 128-bit key so we still have a

227
00:09:06,280 --> 00:09:07,900
security margin of something like two to

228
00:09:07,900 --> 00:09:11,020
the twenty one in a million chance so is

229
00:09:11,020 --> 00:09:13,150
this really a problem well I'm not sure

230
00:09:13,150 --> 00:09:14,800
and kind of undecided because on the one

231
00:09:14,800 --> 00:09:17,350
hand it's the NSA is going to see one

232
00:09:17,350 --> 00:09:19,420
purely random connection so most likely

233
00:09:19,420 --> 00:09:20,890
a picture of a cat or something like

234
00:09:20,890 --> 00:09:23,470
that but on the other hand has not used

235
00:09:23,470 --> 00:09:25,750
any particular property of AES maybe

236
00:09:25,750 --> 00:09:27,580
they know something about AES where they

237
00:09:27,580 --> 00:09:29,260
can slice off some additional bids of

238
00:09:29,260 --> 00:09:31,960
this can store a bit less or they can I

239
00:09:31,960 --> 00:09:34,120
don't know optimize this attack in some

240
00:09:34,120 --> 00:09:36,280
way and then it becomes kind of close to

241
00:09:36,280 --> 00:09:38,230
being uncomfortable right it becomes

242
00:09:38,230 --> 00:09:40,870
kind of close to being they can actually

243
00:09:40,870 --> 00:09:44,410
break connections okay so what the TLS

244
00:09:44,410 --> 00:09:48,460
working group then did is they said well

245
00:09:48,460 --> 00:09:50,260
a very important property of this attack

246
00:09:50,260 --> 00:09:52,090
is we all use the same value here

247
00:09:52,090 --> 00:09:53,920
because if we wouldn't use all the or

248
00:09:53,920 --> 00:09:55,810
use the same value we wouldn't be able

249
00:09:55,810 --> 00:09:58,930
to pre-compute the table okay so let's

250
00:09:58,930 --> 00:10:01,210
just not all use the same value instead

251
00:10:01,210 --> 00:10:03,340
let's add some kind of a randomizer here

252
00:10:03,340 --> 00:10:05,650
and randomize the nonce before we

253
00:10:05,650 --> 00:10:08,140
actually give it to a yes okay so

254
00:10:08,140 --> 00:10:10,720
they're doing a random value 96 bits

255
00:10:10,720 --> 00:10:12,880
random value that they don't change

256
00:10:12,880 --> 00:10:14,530
during a connection so they choose it

257
00:10:14,530 --> 00:10:16,300
basically when at the same time they

258
00:10:16,300 --> 00:10:17,920
they get the key it's actually derived

259
00:10:17,920 --> 00:10:22,420
from the same key material and they just

260
00:10:22,420 --> 00:10:24,700
use what I explained before it's just

261
00:10:24,700 --> 00:10:26,740
randomizing the sequence number with

262
00:10:26,740 --> 00:10:30,340
this amount before they give it to B so

263
00:10:30,340 --> 00:10:32,740
the authenticated encryption and now

264
00:10:32,740 --> 00:10:34,090
there are some obvious questions the

265
00:10:34,090 --> 00:10:35,980
first one is well formally what did they

266
00:10:35,980 --> 00:10:38,050
want to achieve with this second didn't

267
00:10:38,050 --> 00:10:40,000
they did they achieve it and the third

268
00:10:40,000 --> 00:10:42,580
if they did or if they did not quite

269
00:10:42,580 --> 00:10:46,420
can we do it better okay the answer to

270
00:10:46,420 --> 00:10:48,100
the first question in our opinion is

271
00:10:48,100 --> 00:10:49,530
what they want to have is kind of

272
00:10:49,530 --> 00:10:52,570
multi-user authenticated encryption

273
00:10:52,570 --> 00:10:54,580
security so authenticated encryption

274
00:10:54,580 --> 00:10:56,770
security where we do not only care about

275
00:10:56,770 --> 00:10:58,570
the security of one connection but of

276
00:10:58,570 --> 00:11:01,240
the we care about the security of the

277
00:11:01,240 --> 00:11:04,420
multitude of connections then we show

278
00:11:04,420 --> 00:11:06,490
that actually this TLS countermeasure

279
00:11:06,490 --> 00:11:09,310
can be seen as kind of building a new of

280
00:11:09,310 --> 00:11:10,930
inicated encryption scheme from the one

281
00:11:10,930 --> 00:11:13,750
we started prom and finally we analyze

282
00:11:13,750 --> 00:11:16,360
in the model that we we provide in the

283
00:11:16,360 --> 00:11:20,050
paper the plane AES JCM then the mode

284
00:11:20,050 --> 00:11:23,470
that is proposal TLS 1.3 boo boo call it

285
00:11:23,470 --> 00:11:26,550
our GCM for the rest of the talk and

286
00:11:26,550 --> 00:11:29,200
also we're going to propose a mode that

287
00:11:29,200 --> 00:11:31,480
is called X Jesus that we call X PCM

288
00:11:31,480 --> 00:11:34,750
which is basically GCM using AES X where

289
00:11:34,750 --> 00:11:38,650
yes X means we apply a mask before and

290
00:11:38,650 --> 00:11:41,500
after using AES I'll show that on one of

291
00:11:41,500 --> 00:11:43,750
the next slides two important things

292
00:11:43,750 --> 00:11:45,880
here one is all the statements are in

293
00:11:45,880 --> 00:11:47,800
the idea cipher model and for the

294
00:11:47,800 --> 00:11:49,360
purpose of the talk we focus on key

295
00:11:49,360 --> 00:11:51,340
recovery security the main reason is

296
00:11:51,340 --> 00:11:53,830
it's a bit simpler and the full

297
00:11:53,830 --> 00:11:55,450
authenticated encryption security is

298
00:11:55,450 --> 00:11:57,250
basically do the same as for here

299
00:11:57,250 --> 00:11:59,980
recovery security and then standard AES

300
00:11:59,980 --> 00:12:02,170
GCM analysis so you wouldn't learn

301
00:12:02,170 --> 00:12:03,670
anything new if you're at the edge of

302
00:12:03,670 --> 00:12:09,490
paper GCM papers anyway ok so those are

303
00:12:09,490 --> 00:12:12,640
the schemes and on one slide kind of

304
00:12:12,640 --> 00:12:16,270
what we show is that in GCM basically if

305
00:12:16,270 --> 00:12:18,790
you increase the number of users you're

306
00:12:18,790 --> 00:12:21,250
losing what you would expect by the

307
00:12:21,250 --> 00:12:25,360
hybrid argument and our GCM achieved

308
00:12:25,360 --> 00:12:27,360
something which is better so basically

309
00:12:27,360 --> 00:12:30,370
you start at the same security forcing a

310
00:12:30,370 --> 00:12:33,460
user but then your security degrades a

311
00:12:33,460 --> 00:12:36,970
bit slower and X GCM the one that we

312
00:12:36,970 --> 00:12:39,700
described basically it has it has just

313
00:12:39,700 --> 00:12:41,740
better security overall so we also

314
00:12:41,740 --> 00:12:44,080
increase this or improve the security in

315
00:12:44,080 --> 00:12:46,030
the single user case and that kind of

316
00:12:46,030 --> 00:12:48,580
goes on for as many useless as would

317
00:12:48,580 --> 00:12:50,070
possibly want to happen

318
00:12:50,070 --> 00:12:52,480
ok so let's first talk about a

319
00:12:52,480 --> 00:12:56,050
multi-user key recovery security so we

320
00:12:56,050 --> 00:12:57,910
formalized this as a game where we give

321
00:12:57,910 --> 00:12:59,560
the adversary well for now three

322
00:12:59,560 --> 00:13:02,230
Oracle's the first one allows him to

323
00:13:02,230 --> 00:13:05,440
create new user instances and be the

324
00:13:05,440 --> 00:13:07,030
only thing that happens is there will be

325
00:13:07,030 --> 00:13:09,550
a new key sample in the game then we

326
00:13:09,550 --> 00:13:11,699
give it an encryption oracle use

327
00:13:11,699 --> 00:13:13,949
the instance they choose supplying

328
00:13:13,949 --> 00:13:15,569
Ananse and message obtaining a

329
00:13:15,569 --> 00:13:17,939
ciphertext and accordingly decryption

330
00:13:17,939 --> 00:13:19,980
Oracle they can again choose the

331
00:13:19,980 --> 00:13:22,169
instance the nonce and the ciphertext

332
00:13:22,169 --> 00:13:24,869
and we return whether it was a valid

333
00:13:24,869 --> 00:13:27,419
ciphertext or not and the goal of the

334
00:13:27,419 --> 00:13:31,699
adversary is to guess one any one of the

335
00:13:31,699 --> 00:13:34,799
honest users keys okay so if there's one

336
00:13:34,799 --> 00:13:36,809
key which the adversary guesses you want

337
00:13:36,809 --> 00:13:39,569
this is kind of why it's multi-user

338
00:13:39,569 --> 00:13:45,600
security as I said before all we do is

339
00:13:45,600 --> 00:13:47,759
in the ivy cipher model an ideal cipher

340
00:13:47,759 --> 00:13:50,279
you can see it as basically a family of

341
00:13:50,279 --> 00:13:53,220
uniformly random permutations indexed by

342
00:13:53,220 --> 00:13:54,929
this key so for each key you get a

343
00:13:54,929 --> 00:13:56,579
uniformly random permutation that you

344
00:13:56,579 --> 00:13:59,429
can query forward or backward whatever

345
00:13:59,429 --> 00:14:02,850
you want both the scheme and the

346
00:14:02,850 --> 00:14:05,189
adversary have access to this ideal

347
00:14:05,189 --> 00:14:06,839
cipher basically we formalize it as an

348
00:14:06,839 --> 00:14:08,129
Oracle that can be queried by the

349
00:14:08,129 --> 00:14:10,319
statement by the adversary and it

350
00:14:10,319 --> 00:14:12,329
idealized this block ciphers such as for

351
00:14:12,329 --> 00:14:18,269
example a so the full multi-user key

352
00:14:18,269 --> 00:14:20,459
recovery security model in the I

353
00:14:20,459 --> 00:14:22,679
decipher model looks as follows we have

354
00:14:22,679 --> 00:14:25,079
the same three oracle as before and now

355
00:14:25,079 --> 00:14:28,499
we also have the Oracles to to query

356
00:14:28,499 --> 00:14:31,109
both directions of bi decipher the goal

357
00:14:31,109 --> 00:14:36,539
is stochastic okay I'll have to speed up

358
00:14:36,539 --> 00:14:39,149
a bit so let's now look at the

359
00:14:39,149 --> 00:14:41,369
multi-user key recovery security of GCM

360
00:14:41,369 --> 00:14:44,369
so the proof idea is as follows all the

361
00:14:44,369 --> 00:14:46,769
proofs we do follow this same structure

362
00:14:46,769 --> 00:14:49,289
first we kind of we have the ideal

363
00:14:49,289 --> 00:14:51,209
cipher here and here so the the states

364
00:14:51,209 --> 00:14:53,600
of these Oracle's are kind of entangled

365
00:14:53,600 --> 00:14:56,459
so the first step is going to be then

366
00:14:56,459 --> 00:14:59,459
that we say this is almost the same as

367
00:14:59,459 --> 00:15:01,410
if we were using a different idea cipher

368
00:15:01,410 --> 00:15:03,449
here and here and this is where the main

369
00:15:03,449 --> 00:15:05,519
part of the problem actually occurs and

370
00:15:05,519 --> 00:15:08,699
then once we did this these Oracle's are

371
00:15:08,699 --> 00:15:10,649
of no help because they don't have any

372
00:15:10,649 --> 00:15:12,239
correlation with the rest of the random

373
00:15:12,239 --> 00:15:16,769
experiment so but also remember that the

374
00:15:16,769 --> 00:15:19,230
key is only used as a key to the idea

375
00:15:19,230 --> 00:15:20,220
cipher nowhere else

376
00:15:20,220 --> 00:15:22,529
so the actual value of the key never

377
00:15:22,529 --> 00:15:23,770
appears in the game

378
00:15:23,770 --> 00:15:26,060
so what your act what the adversary

379
00:15:26,060 --> 00:15:28,100
actually has to do is he has to guess

380
00:15:28,100 --> 00:15:30,560
one out of you where use the number of

381
00:15:30,560 --> 00:15:33,470
users uniformly random keys and overall

382
00:15:33,470 --> 00:15:36,650
he's going to resolve this or two to

383
00:15:36,650 --> 00:15:38,450
solve this with a probability you over

384
00:15:38,450 --> 00:15:40,280
two to the Kappa where Kappa is the

385
00:15:40,280 --> 00:15:44,510
length of the key okay now in a bit more

386
00:15:44,510 --> 00:15:48,380
detail you can envision the ideal cipher

387
00:15:48,380 --> 00:15:50,030
as follows it's basically a table where

388
00:15:50,030 --> 00:15:51,710
we have the keys here so each key

389
00:15:51,710 --> 00:15:53,270
describes one column each input

390
00:15:53,270 --> 00:15:58,160
describes one row and assume that the

391
00:15:58,160 --> 00:16:00,410
user used these or the honest user

392
00:16:00,410 --> 00:16:04,730
instances use these two keys now we're

393
00:16:04,730 --> 00:16:06,230
in the step where we want to detangle

394
00:16:06,230 --> 00:16:07,700
these Oracle's I should have explained

395
00:16:07,700 --> 00:16:09,140
this before okay so we're in the first

396
00:16:09,140 --> 00:16:10,880
proof step we're basically want to show

397
00:16:10,880 --> 00:16:13,220
that these are irrelevant and we want to

398
00:16:13,220 --> 00:16:15,770
replace the ideal cipher that is used by

399
00:16:15,770 --> 00:16:18,080
both sides by different ideal ciphers

400
00:16:18,080 --> 00:16:20,450
the only way for the for the adversary

401
00:16:20,450 --> 00:16:22,250
to detect this is to basically make a

402
00:16:22,250 --> 00:16:24,110
call to the ideal cipher which is a call

403
00:16:24,110 --> 00:16:27,380
both here and here and see that there's

404
00:16:27,380 --> 00:16:29,180
a difference otherwise he's just going

405
00:16:29,180 --> 00:16:33,050
to get like independent values okay so

406
00:16:33,050 --> 00:16:35,690
the only way he can do this in that case

407
00:16:35,690 --> 00:16:37,730
is by guessing a correct key of a user

408
00:16:37,730 --> 00:16:40,850
okay so he will guess one of these

409
00:16:40,850 --> 00:16:43,070
whatever number of users we actually

410
00:16:43,070 --> 00:16:46,070
have rows and the probability for him to

411
00:16:46,070 --> 00:16:48,140
do this you can I mean it's it's a

412
00:16:48,140 --> 00:16:51,020
probability theory computation we have

413
00:16:51,020 --> 00:16:53,060
to do so it's it will end up to be u

414
00:16:53,060 --> 00:16:54,800
times P we use the number of user

415
00:16:54,800 --> 00:16:56,870
instances P is the number of idea cipher

416
00:16:56,870 --> 00:16:58,820
queries of the adversary over to the

417
00:16:58,820 --> 00:16:59,440
kaepa

418
00:16:59,440 --> 00:17:02,540
okay once we have done that we are in

419
00:17:02,540 --> 00:17:04,579
the step that basically we can replace

420
00:17:04,579 --> 00:17:07,010
the two idea cipher the one I decipher

421
00:17:07,010 --> 00:17:08,660
by two independent ones and we can use

422
00:17:08,660 --> 00:17:10,730
the same argument as before and the over

423
00:17:10,730 --> 00:17:12,260
probability that we are the over

424
00:17:12,260 --> 00:17:14,329
advantage of the episode that we get is

425
00:17:14,329 --> 00:17:17,329
U times P plus one this is one from the

426
00:17:17,329 --> 00:17:20,829
guessing the key over

427
00:17:20,829 --> 00:17:23,810
okay we showed an adversary strategy

428
00:17:23,810 --> 00:17:25,849
that actually shows this bond is pretty

429
00:17:25,849 --> 00:17:28,640
much tight so this is a smaller constant

430
00:17:28,640 --> 00:17:30,560
it's probably like 1 over 10 for

431
00:17:30,560 --> 00:17:32,480
realistic parameters and otherwise we

432
00:17:32,480 --> 00:17:34,700
get the same we describe an adversary

433
00:17:34,700 --> 00:17:36,920
strategy that basically just implements

434
00:17:36,920 --> 00:17:39,980
what I've explained on the very on one

435
00:17:39,980 --> 00:17:43,420
of the first slides which just checks

436
00:17:43,420 --> 00:17:46,490
which encrypts the same value with the

437
00:17:46,490 --> 00:17:48,050
same noms and then it just does this

438
00:17:48,050 --> 00:17:50,600
recomputation and this adversary

439
00:17:50,600 --> 00:17:53,060
strategy will pretty much achieve the

440
00:17:53,060 --> 00:17:56,690
the bound that we gave for this game so

441
00:17:56,690 --> 00:17:59,360
now let's look at how we can view the

442
00:17:59,360 --> 00:18:01,070
our GCM scheme as an authenticated

443
00:18:01,070 --> 00:18:03,170
encryption scheme basically we view the

444
00:18:03,170 --> 00:18:05,330
randomizer as a part of the key and then

445
00:18:05,330 --> 00:18:08,180
we just inside the scheme so this - box

446
00:18:08,180 --> 00:18:10,520
shows our TCM we just XOR it to the

447
00:18:10,520 --> 00:18:12,260
nonce okay now it's an authenticated

448
00:18:12,260 --> 00:18:14,300
encryption scheme as before it just uses

449
00:18:14,300 --> 00:18:19,550
a longer key okay and now we follow the

450
00:18:19,550 --> 00:18:21,650
same proof structure as before but it's

451
00:18:21,650 --> 00:18:23,720
going to be more intricate because now

452
00:18:23,720 --> 00:18:26,030
we cannot give up once the adversary

453
00:18:26,030 --> 00:18:28,640
just guessed one of the honors keys we

454
00:18:28,640 --> 00:18:31,040
used because otherwise we would end up

455
00:18:31,040 --> 00:18:34,100
with a very same bound as before so we

456
00:18:34,100 --> 00:18:36,190
look at what are GCM actually does and

457
00:18:36,190 --> 00:18:39,110
basically the the part of the idea

458
00:18:39,110 --> 00:18:41,240
cipher used by the honest guys they look

459
00:18:41,240 --> 00:18:44,120
somehow more like this so for one key

460
00:18:44,120 --> 00:18:46,520
this is one user instance there will be

461
00:18:46,520 --> 00:18:48,860
patches in here right because this is

462
00:18:48,860 --> 00:18:51,380
basically we do a counter mode

463
00:18:51,380 --> 00:18:53,930
encryption so we use some part of the

464
00:18:53,930 --> 00:18:56,390
idea cipher one that is kind of

465
00:18:56,390 --> 00:18:59,180
continuous and this is one message this

466
00:18:59,180 --> 00:19:00,940
is one message this one message enter

467
00:19:00,940 --> 00:19:03,440
now we can do is similar arguments

468
00:19:03,440 --> 00:19:05,240
before we can count the adversary

469
00:19:05,240 --> 00:19:08,420
queries we can count basically the

470
00:19:08,420 --> 00:19:09,920
number of queries done by the honest

471
00:19:09,920 --> 00:19:13,340
users and estimate what the probability

472
00:19:13,340 --> 00:19:15,680
of the adversary is to actually guess in

473
00:19:15,680 --> 00:19:18,680
one of those regions ok and now this is

474
00:19:18,680 --> 00:19:21,680
you times number of users times number

475
00:19:21,680 --> 00:19:25,240
of adversary queries times basically the

476
00:19:25,240 --> 00:19:29,060
area of these patches and but now the

477
00:19:29,060 --> 00:19:31,200
overall

478
00:19:31,200 --> 00:19:33,940
the denominator here becomes bigger

479
00:19:33,940 --> 00:19:36,129
because we don't only have to guess one

480
00:19:36,129 --> 00:19:38,019
of the rows we have to guess one of the

481
00:19:38,019 --> 00:19:40,149
row and column combination combinations

482
00:19:40,149 --> 00:19:42,909
of one of those red petrol okay that's

483
00:19:42,909 --> 00:19:46,450
why we get improved security here okay

484
00:19:46,450 --> 00:19:48,340
but we also have backward crates because

485
00:19:48,340 --> 00:19:51,600
the output of the cipher is not

486
00:19:51,600 --> 00:19:55,210
randomized we can basically just view

487
00:19:55,210 --> 00:19:56,769
part of the ciphertext so the adversary

488
00:19:56,769 --> 00:19:58,299
can take a part of the ciphertext which

489
00:19:58,299 --> 00:20:00,419
is an object of an Aes block and try to

490
00:20:00,419 --> 00:20:04,899
basically invert the random permutation

491
00:20:04,899 --> 00:20:07,269
invert yes we try to figure out this

492
00:20:07,269 --> 00:20:11,889
heads figure out the keys by this so if

493
00:20:11,889 --> 00:20:13,539
we look at the outputs of the ideas

494
00:20:13,539 --> 00:20:15,009
hyper so this is now the back of the

495
00:20:15,009 --> 00:20:17,919
inverse direction basically it's much

496
00:20:17,919 --> 00:20:20,350
more sprinkled out so it's some random

497
00:20:20,350 --> 00:20:22,960
we for each key we see some random

498
00:20:22,960 --> 00:20:27,190
ciphertext here okay and now we can the

499
00:20:27,190 --> 00:20:29,289
adversary can guess any one of those

500
00:20:29,289 --> 00:20:31,210
lines and can try to find a key

501
00:20:31,210 --> 00:20:34,059
corresponding to this but in contrast to

502
00:20:34,059 --> 00:20:37,330
the very first attack this doesn't scale

503
00:20:37,330 --> 00:20:39,340
anymore because most likely if he sees

504
00:20:39,340 --> 00:20:41,799
some ciphertext block it has been used

505
00:20:41,799 --> 00:20:44,710
by one or only a few users so whenever

506
00:20:44,710 --> 00:20:46,600
he does an inverse query to the block

507
00:20:46,600 --> 00:20:48,850
cipher is going to attack only a very

508
00:20:48,850 --> 00:20:50,950
few number of user keys so the attack

509
00:20:50,950 --> 00:20:54,600
doesn't scale as I did in the first okay

510
00:20:54,600 --> 00:20:57,639
so this ends up to be a small constant

511
00:20:57,639 --> 00:21:00,039
times P over two to the Kappa but this

512
00:21:00,039 --> 00:21:04,389
is independent of the number of use okay

513
00:21:04,389 --> 00:21:05,889
is that all and the answer is

514
00:21:05,889 --> 00:21:07,600
unfortunately no but I have to be quick

515
00:21:07,600 --> 00:21:10,119
on this and the reason is here this this

516
00:21:10,119 --> 00:21:13,059
occurred to the block cipher is not

517
00:21:13,059 --> 00:21:16,960
randomized okay so we cannot replace

518
00:21:16,960 --> 00:21:18,879
this dependent ideal cipher by a

519
00:21:18,879 --> 00:21:20,649
completely independent one at this step

520
00:21:20,649 --> 00:21:22,960
unless we also make this part here

521
00:21:22,960 --> 00:21:25,960
independent but this is one fixed input

522
00:21:25,960 --> 00:21:27,820
to the ideal cipher that the adversary

523
00:21:27,820 --> 00:21:29,980
can easily give as well so this is just

524
00:21:29,980 --> 00:21:33,340
as this we have to take care of this in

525
00:21:33,340 --> 00:21:36,100
the proof and we basically do this so

526
00:21:36,100 --> 00:21:37,899
this is also why the proof I show here

527
00:21:37,899 --> 00:21:41,710
only holds for for passive adversaries

528
00:21:41,710 --> 00:21:44,710
that do not use the verification or

529
00:21:44,710 --> 00:21:48,580
we do this by basically saying we do

530
00:21:48,580 --> 00:21:51,850
this X or here so we as we kind of

531
00:21:51,850 --> 00:21:54,480
changed the distribution here a bit

532
00:21:54,480 --> 00:21:56,559
gathering some error in the in the

533
00:21:56,559 --> 00:21:58,779
security bound to be uniformly random

534
00:21:58,779 --> 00:22:00,279
and then you don't get any information

535
00:22:00,279 --> 00:22:02,619
about this value here whatsoever so

536
00:22:02,619 --> 00:22:04,779
that's how we deal basically with with

537
00:22:04,779 --> 00:22:07,929
this stupid grade so that's your Volpone

538
00:22:07,929 --> 00:22:10,419
it's pretty complicated but what I want

539
00:22:10,419 --> 00:22:12,669
to highlight is we have u times P here

540
00:22:12,669 --> 00:22:15,100
which was the problematic term but the

541
00:22:15,100 --> 00:22:16,899
denominators are pretty big and here

542
00:22:16,899 --> 00:22:19,359
with the smaller denominators we do

543
00:22:19,359 --> 00:22:21,730
never have u times P we have peas and

544
00:22:21,730 --> 00:22:23,350
used but only addition so these terms

545
00:22:23,350 --> 00:22:25,840
are much much smaller and that's why so

546
00:22:25,840 --> 00:22:28,899
these are kind of fun for the actual

547
00:22:28,899 --> 00:22:30,549
security these are very relevant and

548
00:22:30,549 --> 00:22:33,820
they don't like they don't grow with the

549
00:22:33,820 --> 00:22:38,529
hybrid argument linear growth okay we we

550
00:22:38,529 --> 00:22:40,690
show but we show that this term here for

551
00:22:40,690 --> 00:22:42,369
example is necessary so there is an

552
00:22:42,369 --> 00:22:44,499
adversary strategy that actually works

553
00:22:44,499 --> 00:22:46,690
on inverting particular cipher text

554
00:22:46,690 --> 00:22:50,679
output or cipher text part and the bound

555
00:22:50,679 --> 00:22:53,590
is that part of the bound is tied okay

556
00:22:53,590 --> 00:22:57,129
I'll just explain that this here is

557
00:22:57,129 --> 00:23:01,029
basically X a or AES X so this is not a

558
00:23:01,029 --> 00:23:03,639
part of like 128 bit of randomness which

559
00:23:03,639 --> 00:23:05,350
we use to mask the input and the output

560
00:23:05,350 --> 00:23:07,869
of the block cipher and so this entire

561
00:23:07,869 --> 00:23:11,369
scheme is what we would call a SX GCM

562
00:23:11,369 --> 00:23:14,950
okay and the idea is we can basically

563
00:23:14,950 --> 00:23:17,259
use the result of Qian on Android away

564
00:23:17,259 --> 00:23:21,249
who analyzed where they analyzed SX so

565
00:23:21,249 --> 00:23:23,919
used in death we have to kind of adapt

566
00:23:23,919 --> 00:23:25,450
it a bit to the multi user setting and

567
00:23:25,450 --> 00:23:26,679
then we basically get in

568
00:23:26,679 --> 00:23:29,169
differentiability of the construction

569
00:23:29,169 --> 00:23:31,090
and query in the component from these

570
00:23:31,090 --> 00:23:33,460
two independent ciphers which is exactly

571
00:23:33,460 --> 00:23:34,899
what we are going to need in our next

572
00:23:34,899 --> 00:23:37,840
proof so that proof is actually being a

573
00:23:37,840 --> 00:23:39,340
combination of this in differentiability

574
00:23:39,340 --> 00:23:41,259
argument together with the proof of JCM

575
00:23:41,259 --> 00:23:43,480
and we see that this bound is much nicer

576
00:23:43,480 --> 00:23:45,340
and also much much better than the proof

577
00:23:45,340 --> 00:23:49,299
of our GCM and it works for all types of

578
00:23:49,299 --> 00:23:53,789
also activate a series so the

579
00:23:53,789 --> 00:23:56,169
authenticated encryption scenario or

580
00:23:56,169 --> 00:23:57,460
security is

581
00:23:57,460 --> 00:24:01,420
basically the same women Wow okay is

582
00:24:01,420 --> 00:24:02,920
basically the same is standard

583
00:24:02,920 --> 00:24:04,900
authenticated encryption with multi

584
00:24:04,900 --> 00:24:06,430
users so we have the new Oracle and

585
00:24:06,430 --> 00:24:07,960
various instances in encryption and

586
00:24:07,960 --> 00:24:09,940
decryption and we are in the ideal

587
00:24:09,940 --> 00:24:11,470
cipher model so we give value cipher

588
00:24:11,470 --> 00:24:13,690
okay and the results that we obtain

589
00:24:13,690 --> 00:24:15,820
there are basically this is the real

590
00:24:15,820 --> 00:24:17,710
type or GC and so this is the key

591
00:24:17,710 --> 00:24:20,290
recovery term and these terms all stem

592
00:24:20,290 --> 00:24:22,870
from the analysis of a SPC and standard

593
00:24:22,870 --> 00:24:25,060
analysis single user model answer so

594
00:24:25,060 --> 00:24:28,180
that's how then we obtain all the actual

595
00:24:28,180 --> 00:24:31,000
authentication encryption thank you okay

596
00:24:31,000 --> 00:24:33,370
I'll have to stop here so I just say

597
00:24:33,370 --> 00:24:36,090
thanks for your

