1
00:00:04,940 --> 00:00:09,480
thank you very much for the introduction

2
00:00:06,960 --> 00:00:12,139
so hi everyone I'm Lisa and happy to be

3
00:00:09,480 --> 00:00:14,429
here today to talk about pseudo-random

4
00:00:12,139 --> 00:00:18,750
correlation generators and why they're

5
00:00:14,429 --> 00:00:21,270
useful this is joint work with the led

6
00:00:18,750 --> 00:00:24,600
policy for cuto nifty boy usually

7
00:00:21,270 --> 00:00:27,480
scientist all so the setting we're in is

8
00:00:24,600 --> 00:00:29,609
secure two-party computation where Alice

9
00:00:27,480 --> 00:00:32,340
and Bob want to securely evaluate a

10
00:00:29,609 --> 00:00:35,070
function on the inputs without leaking

11
00:00:32,340 --> 00:00:37,589
anything more than the function output

12
00:00:35,070 --> 00:00:39,120
and this is great we know how to do this

13
00:00:37,589 --> 00:00:42,720
for a long time but the problem is

14
00:00:39,120 --> 00:00:45,030
always efficiency so one one way to deal

15
00:00:42,720 --> 00:00:47,720
with this is to push the expensive

16
00:00:45,030 --> 00:00:52,229
cryptographic part to an offline

17
00:00:47,720 --> 00:00:54,119
computation phase which can be done long

18
00:00:52,229 --> 00:00:55,920
before the inputs are known and then one

19
00:00:54,119 --> 00:00:59,129
once the inputs are known the inland

20
00:00:55,920 --> 00:01:01,650
face is very efficient and has lots of

21
00:00:59,129 --> 00:01:04,199
nice properties but the problem is like

22
00:01:01,650 --> 00:01:06,720
or now we kind of shifted the expensive

23
00:01:04,199 --> 00:01:08,490
part to the pre-processing phase so in

24
00:01:06,720 --> 00:01:11,250
particular even though the parties can

25
00:01:08,490 --> 00:01:13,229
generate like generate this correlated

26
00:01:11,250 --> 00:01:15,180
randomness that they need long ahead

27
00:01:13,230 --> 00:01:18,360
they have to store it for a long time

28
00:01:15,180 --> 00:01:22,530
and it requires lots of communication so

29
00:01:18,360 --> 00:01:24,960
what we do in this talk is or what we

30
00:01:22,530 --> 00:01:27,420
did in wood we did in this in this work

31
00:01:24,960 --> 00:01:30,899
is how to significantly reduce the cost

32
00:01:27,420 --> 00:01:33,060
for communication and storage and the

33
00:01:30,900 --> 00:01:35,400
correlation I want to focus on today so

34
00:01:33,060 --> 00:01:38,190
oblivious transport transfer we already

35
00:01:35,400 --> 00:01:42,409
seen it in all the talks before today I

36
00:01:38,190 --> 00:01:45,390
flee so I'm just to briefly recall

37
00:01:42,409 --> 00:01:47,580
Ellison pop executes a protocol such

38
00:01:45,390 --> 00:01:49,560
that LS learns exactly one messages of

39
00:01:47,580 --> 00:01:53,929
Bob and Bob doesn't learn anything about

40
00:01:49,560 --> 00:01:56,340
which of the two she learned and the

41
00:01:53,930 --> 00:01:58,620
correlated random strings will look then

42
00:01:56,340 --> 00:02:01,140
something like like the blue parts that

43
00:01:58,620 --> 00:02:04,560
you see here where you have the input

44
00:02:01,140 --> 00:02:06,450
and the output of Ellison Bob and those

45
00:02:04,560 --> 00:02:08,878
strings have to be long typically to

46
00:02:06,450 --> 00:02:10,799
compute circuits because why is that for

47
00:02:08,878 --> 00:02:13,620
example if you consider the team W

48
00:02:10,799 --> 00:02:16,860
protocol and you cry - Oh T spur and

49
00:02:13,620 --> 00:02:17,970
gate so for like a huge circuit you will

50
00:02:16,860 --> 00:02:21,270
need a huge number

51
00:02:17,970 --> 00:02:23,220
of those correlated or teased and so the

52
00:02:21,270 --> 00:02:24,900
problem so this is theoretical if you

53
00:02:23,220 --> 00:02:27,180
have our team we can do this but this is

54
00:02:24,900 --> 00:02:29,850
very expensive it's computationally

55
00:02:27,180 --> 00:02:32,130
expensive because ot is it lives in the

56
00:02:29,850 --> 00:02:34,470
public key vote so it's expensive and

57
00:02:32,130 --> 00:02:35,299
this is already this already has a

58
00:02:34,470 --> 00:02:38,940
solution

59
00:02:35,300 --> 00:02:41,190
so the solution towards this is as we've

60
00:02:38,940 --> 00:02:43,950
already also seen the first talk today

61
00:02:41,190 --> 00:02:45,960
is a hybrid approach where you use a few

62
00:02:43,950 --> 00:02:48,890
basic tees and then the rest you do with

63
00:02:45,960 --> 00:02:51,690
cheap symmetric key cryptography and

64
00:02:48,890 --> 00:02:53,519
this is super nice this solves the

65
00:02:51,690 --> 00:02:55,770
problem from like a computational

66
00:02:53,520 --> 00:02:57,810
viewpoint but still what I said before

67
00:02:55,770 --> 00:03:00,000
we still have the problem that the

68
00:02:57,810 --> 00:03:02,100
communication and the storage required

69
00:03:00,000 --> 00:03:04,590
is linear in the number of or T's we

70
00:03:02,100 --> 00:03:06,540
want to we want to generate and of

71
00:03:04,590 --> 00:03:10,220
course this is inherent if we care about

72
00:03:06,540 --> 00:03:14,310
chosen ot we're actually Alice and Bob

73
00:03:10,220 --> 00:03:15,870
mmm chose their messages but for for the

74
00:03:14,310 --> 00:03:18,360
setting we're in for a secure

75
00:03:15,870 --> 00:03:19,980
computation we actually we actually we

76
00:03:18,360 --> 00:03:23,489
actually find we just need this to be

77
00:03:19,980 --> 00:03:25,290
random and as you like for example if

78
00:03:23,489 --> 00:03:27,840
you if you think about computation

79
00:03:25,290 --> 00:03:29,760
communication for communication if you

80
00:03:27,840 --> 00:03:32,550
just care about random messages you

81
00:03:29,760 --> 00:03:34,260
don't need communication linear in the

82
00:03:32,550 --> 00:03:37,860
number of messages you can just exchange

83
00:03:34,260 --> 00:03:40,320
a short seat for for P or T and then you

84
00:03:37,860 --> 00:03:42,510
can locally extend and this is exactly

85
00:03:40,320 --> 00:03:45,530
what we did in this work we got rid of

86
00:03:42,510 --> 00:03:48,060
this part of the communication so um

87
00:03:45,530 --> 00:03:50,160
this is what we call silent or T

88
00:03:48,060 --> 00:03:52,200
extension where the extension is local

89
00:03:50,160 --> 00:03:54,299
so and which will make the communication

90
00:03:52,200 --> 00:04:00,480
in the storage sub linear in the number

91
00:03:54,299 --> 00:04:02,760
of or T's to be generated and how do we

92
00:04:00,480 --> 00:04:05,310
do this what's the tool to achieve this

93
00:04:02,760 --> 00:04:08,548
so this is so-called pseudo random

94
00:04:05,310 --> 00:04:11,070
correlation generators where Alice and

95
00:04:08,549 --> 00:04:14,130
Bob have short correlated seeds that are

96
00:04:11,070 --> 00:04:16,380
correlated in some way and then they can

97
00:04:14,130 --> 00:04:20,430
locally expand them to get long

98
00:04:16,380 --> 00:04:22,560
correlated pseudo-random strings and how

99
00:04:20,430 --> 00:04:26,340
does this help us for what we want to

100
00:04:22,560 --> 00:04:29,370
achieve well if you think about it

101
00:04:26,340 --> 00:04:31,020
because the seeds are only short a few

102
00:04:29,370 --> 00:04:31,740
our T's are sufficient we only need a

103
00:04:31,020 --> 00:04:33,870
few at East

104
00:04:31,740 --> 00:04:36,229
exchange the seats and then the parties

105
00:04:33,870 --> 00:04:39,750
can locally expand them so without any

106
00:04:36,229 --> 00:04:43,830
communication and then if we if the

107
00:04:39,750 --> 00:04:45,539
correlation we have a PP cg4 is the OT

108
00:04:43,830 --> 00:04:47,729
correlation then what the long strings

109
00:04:45,539 --> 00:04:49,830
will be will be many many or T's that

110
00:04:47,729 --> 00:04:51,630
then can be used in by the online face

111
00:04:49,830 --> 00:04:55,740
that then can be used for efficient

112
00:04:51,630 --> 00:04:58,050
online computation and what I want to

113
00:04:55,740 --> 00:05:00,720
stress in particular is that a PCG have

114
00:04:58,050 --> 00:05:02,789
the silent feature so the the only thing

115
00:05:00,720 --> 00:05:05,639
communication is necessary for is the

116
00:05:02,789 --> 00:05:07,880
short seats so in particular and the

117
00:05:05,639 --> 00:05:10,830
storage and the communication now only

118
00:05:07,880 --> 00:05:13,409
only depends on the seed size and not or

119
00:05:10,830 --> 00:05:14,520
not on the M and there's no for

120
00:05:13,409 --> 00:05:18,569
expansion there's no more communication

121
00:05:14,520 --> 00:05:21,090
necessary so you can even for for a

122
00:05:18,569 --> 00:05:22,830
multi-party for for protocols you can

123
00:05:21,090 --> 00:05:24,599
even you can even do this with many

124
00:05:22,830 --> 00:05:27,270
parties even if you're not sure if you

125
00:05:24,599 --> 00:05:28,770
are if you will engage in a secure

126
00:05:27,270 --> 00:05:30,539
computation in the future because all

127
00:05:28,770 --> 00:05:35,310
you have to do is to store this very

128
00:05:30,539 --> 00:05:37,199
short seat and there has been some

129
00:05:35,310 --> 00:05:39,860
construction of PSG's around for very

130
00:05:37,199 --> 00:05:42,270
simple correlations like multi linear

131
00:05:39,860 --> 00:05:45,479
correlations from one-way functions

132
00:05:42,270 --> 00:05:48,479
already since 20 years ago and there has

133
00:05:45,479 --> 00:05:52,370
been also for more complex and

134
00:05:48,479 --> 00:05:54,900
correlation there were constructions but

135
00:05:52,370 --> 00:05:57,150
but but but not what not really

136
00:05:54,900 --> 00:05:59,758
practical and the first one that was

137
00:05:57,150 --> 00:06:02,849
like a complex correlation and practical

138
00:05:59,759 --> 00:06:05,219
was was from from last year a vector

139
00:06:02,849 --> 00:06:07,020
oblivious linear function evolution from

140
00:06:05,219 --> 00:06:09,750
the learning parity with nice assumption

141
00:06:07,020 --> 00:06:12,330
and yeah and this work actually builds

142
00:06:09,750 --> 00:06:16,069
on built on builds on this work so what

143
00:06:12,330 --> 00:06:18,719
we did in this work was we defined

144
00:06:16,069 --> 00:06:21,449
pseudo-random correlation generators so

145
00:06:18,719 --> 00:06:24,960
we formally define it for general

146
00:06:21,449 --> 00:06:27,270
correlations we gave connections to

147
00:06:24,960 --> 00:06:31,169
homomorphic secret sharing two-way

148
00:06:27,270 --> 00:06:33,568
connections and we concrete constructed

149
00:06:31,169 --> 00:06:35,609
like concrete constructions for

150
00:06:33,569 --> 00:06:37,380
oblivious transfer from the learning

151
00:06:35,610 --> 00:06:41,120
parody with noise assumption or more

152
00:06:37,380 --> 00:06:44,219
generally constant degree correlations

153
00:06:41,120 --> 00:06:45,450
we gave construction for one time truth

154
00:06:44,219 --> 00:06:47,909
tables just based on

155
00:06:45,450 --> 00:06:49,560
my functions and for low degree

156
00:06:47,910 --> 00:06:51,600
correlations in the two-party in the

157
00:06:49,560 --> 00:06:53,430
multi-party setting from either the

158
00:06:51,600 --> 00:06:56,010
multivariate quadratic assumption or

159
00:06:53,430 --> 00:06:58,190
again the LP an assumption together with

160
00:06:56,010 --> 00:07:01,250
learning with errors or rings or the

161
00:06:58,190 --> 00:07:06,930
symmetric external defy human assumption

162
00:07:01,250 --> 00:07:11,190
and in the talk today I want to focus on

163
00:07:06,930 --> 00:07:15,000
giving the definition of PCG for general

164
00:07:11,190 --> 00:07:16,980
correlations and on oblivious transfer

165
00:07:15,000 --> 00:07:25,680
from the learning party with noise

166
00:07:16,980 --> 00:07:28,170
assumption okay so yes so how can you

167
00:07:25,680 --> 00:07:31,710
define and pseudo random correlation

168
00:07:28,170 --> 00:07:34,890
generators so you have two algorithms

169
00:07:31,710 --> 00:07:36,960
you have a heat generation algorithm

170
00:07:34,890 --> 00:07:39,180
that that generates short correlated

171
00:07:36,960 --> 00:07:42,960
seeds and then you have an expansion

172
00:07:39,180 --> 00:07:45,330
algorithm that you can use to that you

173
00:07:42,960 --> 00:07:47,520
can use to expand like locally expand

174
00:07:45,330 --> 00:07:49,919
those seeds to long correlated strings

175
00:07:47,520 --> 00:07:53,969
and of course we want correctness so we

176
00:07:49,920 --> 00:07:56,670
want these two strings to be correlated

177
00:07:53,970 --> 00:07:58,470
in whatever like for example satisfy the

178
00:07:56,670 --> 00:08:01,260
OT correlation that we care about in

179
00:07:58,470 --> 00:08:05,070
this setting and we want security and

180
00:08:01,260 --> 00:08:07,980
how we define security and is that we

181
00:08:05,070 --> 00:08:10,680
want and basically how we define

182
00:08:07,980 --> 00:08:13,050
security is to say that either party can

183
00:08:10,680 --> 00:08:14,670
can learn nothing more from from from

184
00:08:13,050 --> 00:08:17,910
their own see that they can trivially

185
00:08:14,670 --> 00:08:19,860
derive from knowing that the long the

186
00:08:17,910 --> 00:08:22,380
old long string will be in correlation

187
00:08:19,860 --> 00:08:24,300
with the other party string and this is

188
00:08:22,380 --> 00:08:26,280
not the most natural definition that you

189
00:08:24,300 --> 00:08:29,330
can think of because we said we want to

190
00:08:26,280 --> 00:08:32,250
use this as a as a as a replacement in

191
00:08:29,330 --> 00:08:33,960
protocols for secure computation so more

192
00:08:32,250 --> 00:08:37,260
natural definition would be a simulation

193
00:08:33,960 --> 00:08:39,479
based definition to say like for every

194
00:08:37,260 --> 00:08:42,689
protocol you can you can plug this in

195
00:08:39,479 --> 00:08:44,910
but unfortunately this is impossible to

196
00:08:42,690 --> 00:08:48,120
achieve we show this even even for

197
00:08:44,910 --> 00:08:50,010
deterministic functionalities but we

198
00:08:48,120 --> 00:08:51,990
also show that the definition we give

199
00:08:50,010 --> 00:08:55,110
the indistinct service the definition is

200
00:08:51,990 --> 00:08:57,089
good enough for like a a lot of

201
00:08:55,110 --> 00:08:59,509
protocols

202
00:08:57,089 --> 00:09:02,009
that satisfies slightly stronger

203
00:08:59,509 --> 00:09:04,379
security requirement this is the case

204
00:09:02,009 --> 00:09:06,719
for example the tmw protocol that I

205
00:09:04,379 --> 00:09:08,909
mentioned also the speeds protocol so in

206
00:09:06,719 --> 00:09:14,309
many you can actually just directly plug

207
00:09:08,909 --> 00:09:18,679
this dis Buddhist in and yes

208
00:09:14,309 --> 00:09:23,999
so we talked about the definition and

209
00:09:18,679 --> 00:09:25,529
now the not now I want to give you a

210
00:09:23,999 --> 00:09:28,159
construction how can you actually

211
00:09:25,529 --> 00:09:31,769
instantiate this for the correlation of

212
00:09:28,159 --> 00:09:34,649
of oblivious transfer so what we

213
00:09:31,769 --> 00:09:38,869
actually will give is not a PCG directly

214
00:09:34,649 --> 00:09:41,069
for abilities transfer but a PCG for

215
00:09:38,869 --> 00:09:43,499
correlated or two oblivious transfer

216
00:09:41,069 --> 00:09:47,779
which is exactly the same like oblivious

217
00:09:43,499 --> 00:09:50,969
transfer but instead of having two two

218
00:09:47,779 --> 00:09:52,919
unrelated messages but will the messages

219
00:09:50,969 --> 00:09:54,179
of Bob will be always that the first

220
00:09:52,919 --> 00:09:56,489
message the second message will be

221
00:09:54,179 --> 00:09:59,939
always the first message plus some

222
00:09:56,489 --> 00:10:03,029
constant offset and yeah then you can

223
00:09:59,939 --> 00:10:04,978
rewrite LS messages as as being as being

224
00:10:03,029 --> 00:10:08,459
the first message plus either this

225
00:10:04,979 --> 00:10:10,319
offset or not and as it Shia Cillian

226
00:10:08,459 --> 00:10:11,638
Issam and patterning showed if you have

227
00:10:10,319 --> 00:10:13,289
correlated or T and you have a

228
00:10:11,639 --> 00:10:15,299
correlation robust hash function this

229
00:10:13,289 --> 00:10:17,189
actually gives you ot so the idea is

230
00:10:15,299 --> 00:10:18,779
basically just you can have and then

231
00:10:17,189 --> 00:10:20,608
this breaks the correlation and then you

232
00:10:18,779 --> 00:10:24,359
have just a normal or T that you want

233
00:10:20,609 --> 00:10:26,549
and so if you look at this and if you

234
00:10:24,359 --> 00:10:30,119
refresh that like another way to say

235
00:10:26,549 --> 00:10:32,489
what correlated ot is is saying so now

236
00:10:30,119 --> 00:10:35,249
like putting many together so having

237
00:10:32,489 --> 00:10:37,229
like a random vector we can say so so

238
00:10:35,249 --> 00:10:40,409
Alice and Bob get a secret sharing of

239
00:10:37,229 --> 00:10:43,049
this choice bit of Ellis times this

240
00:10:40,409 --> 00:10:45,119
offset Delta so this is another way so

241
00:10:43,049 --> 00:10:47,159
what we have to generate is actually

242
00:10:45,119 --> 00:10:51,959
this kind of secret sharing additive

243
00:10:47,159 --> 00:10:54,869
secret sharing so in order to two

244
00:10:51,959 --> 00:10:56,758
together K the PCG for that we need a

245
00:10:54,869 --> 00:11:01,409
compression of the vectors so we need a

246
00:10:56,759 --> 00:11:03,599
compression of Q and B for Ellis and we

247
00:11:01,409 --> 00:11:06,839
need a compression of the vector R for

248
00:11:03,599 --> 00:11:10,199
Bob such that Q plus R is this Delta

249
00:11:06,839 --> 00:11:10,450
times P and we will show how to do this

250
00:11:10,199 --> 00:11:13,479
in

251
00:11:10,450 --> 00:11:16,090
three steps so the first step is we use

252
00:11:13,480 --> 00:11:18,300
so-called distributed point functions to

253
00:11:16,090 --> 00:11:24,010
get a PCT whenever B is a unit vector

254
00:11:18,300 --> 00:11:28,449
then the next step is actually the next

255
00:11:24,010 --> 00:11:30,370
step is is just V so that you can

256
00:11:28,450 --> 00:11:31,990
locally like it's it's super

257
00:11:30,370 --> 00:11:33,760
straightforward to go from a unit vector

258
00:11:31,990 --> 00:11:35,710
to response vector and then the

259
00:11:33,760 --> 00:11:37,630
interesting part is once we have a

260
00:11:35,710 --> 00:11:43,470
sparse vector how can we get to AB

261
00:11:37,630 --> 00:11:46,060
pseudo random vector and so as I said

262
00:11:43,470 --> 00:11:47,770
the main like the main tool for it for

263
00:11:46,060 --> 00:11:49,900
the first part I distributed point

264
00:11:47,770 --> 00:11:51,760
function so what is the point function a

265
00:11:49,900 --> 00:11:57,880
point function is a function that is

266
00:11:51,760 --> 00:12:00,550
zero everywhere exactly except at at one

267
00:11:57,880 --> 00:12:03,160
single point where it will be some some

268
00:12:00,550 --> 00:12:04,990
some value Y and the distributed point

269
00:12:03,160 --> 00:12:07,839
function is just distributing the

270
00:12:04,990 --> 00:12:11,200
function between two parties such that

271
00:12:07,840 --> 00:12:12,850
the parties alone don't learn about what

272
00:12:11,200 --> 00:12:15,130
the value alpha is and what the value Y

273
00:12:12,850 --> 00:12:17,680
is but together they can recover so they

274
00:12:15,130 --> 00:12:19,930
can locally evaluate every input X on

275
00:12:17,680 --> 00:12:23,079
the keys to it to evaluate the output of

276
00:12:19,930 --> 00:12:25,839
the function and if you like right as

277
00:12:23,080 --> 00:12:28,900
graphically then then then if Alice has

278
00:12:25,840 --> 00:12:32,050
this key K 0 and and Bob has this key K

279
00:12:28,900 --> 00:12:33,490
1 they can expand it and by expansion

280
00:12:32,050 --> 00:12:35,920
here I mean evaluating the point

281
00:12:33,490 --> 00:12:38,170
function on every point of the input so

282
00:12:35,920 --> 00:12:39,969
here we assume a polynomial input space

283
00:12:38,170 --> 00:12:42,099
so that you can actually do this so you

284
00:12:39,970 --> 00:12:44,740
evaluate on every point on the input and

285
00:12:42,100 --> 00:12:48,760
then if you add it up you get a you get

286
00:12:44,740 --> 00:12:52,090
the unit vector x times the Y at exactly

287
00:12:48,760 --> 00:12:54,189
the position alpha and why why are the

288
00:12:52,090 --> 00:12:56,470
superior point functions a good a good

289
00:12:54,190 --> 00:12:58,300
starting point for two reasons first

290
00:12:56,470 --> 00:12:59,980
years if there exists efficient

291
00:12:58,300 --> 00:13:03,459
constructions from one my functions and

292
00:12:59,980 --> 00:13:06,160
second by Derna and shallot and it's

293
00:13:03,460 --> 00:13:07,810
it's possible to efficiently do a

294
00:13:06,160 --> 00:13:09,610
distributed set up which will be

295
00:13:07,810 --> 00:13:15,010
necessary to set up the seed that we

296
00:13:09,610 --> 00:13:17,410
actually need to expand and once we have

297
00:13:15,010 --> 00:13:19,510
distributed point function then the PCG

298
00:13:17,410 --> 00:13:21,670
for unit vector you can it's it's it's

299
00:13:19,510 --> 00:13:23,890
it's very straightforward so all you

300
00:13:21,670 --> 00:13:24,290
give two parties is the keys for the

301
00:13:23,890 --> 00:13:26,600
district

302
00:13:24,290 --> 00:13:29,029
point function ELISA dish newly gets

303
00:13:26,600 --> 00:13:32,589
this point alpha so she knows where it's

304
00:13:29,029 --> 00:13:34,850
punctured and she gets the value Delta

305
00:13:32,589 --> 00:13:37,610
blinded by their by the point of the

306
00:13:34,850 --> 00:13:39,500
distributed point function and this will

307
00:13:37,610 --> 00:13:41,300
be good for her to replace the output

308
00:13:39,500 --> 00:13:44,620
value of the distributed point function

309
00:13:41,300 --> 00:13:47,389
by Delta and so what the parties will do

310
00:13:44,620 --> 00:13:49,790
so this is the this is the this is the

311
00:13:47,389 --> 00:13:51,649
seed and then the expansion is simply

312
00:13:49,790 --> 00:13:55,160
evaluating that this rooted point

313
00:13:51,649 --> 00:13:57,350
function at every point Ellis will add

314
00:13:55,160 --> 00:14:00,680
at the green part at the alpha part she

315
00:13:57,350 --> 00:14:02,180
will add this y plus Delta and then

316
00:14:00,680 --> 00:14:04,069
because of the properties of the

317
00:14:02,180 --> 00:14:06,560
distributed point function we will have

318
00:14:04,069 --> 00:14:09,620
that if you add up Q and R this will be

319
00:14:06,560 --> 00:14:11,420
Delta times the unit vector and so so V

320
00:14:09,620 --> 00:14:13,850
is this unit vector that is that is

321
00:14:11,420 --> 00:14:15,949
alpha at this point so we have a PCT we

322
00:14:13,850 --> 00:14:21,410
can expand we have a PC GFP is the unit

323
00:14:15,949 --> 00:14:23,180
vector but of course we want more like

324
00:14:21,410 --> 00:14:24,709
we won't be not to be the unit vector we

325
00:14:23,180 --> 00:14:28,130
won't be to be a random vector in the

326
00:14:24,709 --> 00:14:31,399
other so how can we go from how can we

327
00:14:28,130 --> 00:14:33,829
go from a unit vector to torando make

328
00:14:31,399 --> 00:14:35,569
the world's first a sparse vector and if

329
00:14:33,829 --> 00:14:37,819
you take a look at the correlation again

330
00:14:35,569 --> 00:14:39,889
this is a this is a linear this is this

331
00:14:37,819 --> 00:14:42,170
is a linear term everything is linear so

332
00:14:39,889 --> 00:14:44,209
only all terms so we have a secret

333
00:14:42,170 --> 00:14:45,920
earring all linear operations can just

334
00:14:44,209 --> 00:14:48,319
be performed in the shares so the

335
00:14:45,920 --> 00:14:51,290
addition if we want we can just repeat

336
00:14:48,319 --> 00:14:53,240
the same procedure T times and then add

337
00:14:51,290 --> 00:14:56,660
it all up and L is a true output above

338
00:14:53,240 --> 00:14:59,680
edster her his output up and then we get

339
00:14:56,660 --> 00:15:02,870
we get the same for sparse vector and

340
00:14:59,680 --> 00:15:04,638
then the interesting part is to go from

341
00:15:02,870 --> 00:15:07,730
the sparse vector to the pseudo random

342
00:15:04,639 --> 00:15:10,010
vector and for this we use the learning

343
00:15:07,730 --> 00:15:13,449
parity with noise assumption which

344
00:15:10,010 --> 00:15:17,420
basically states that if you have like

345
00:15:13,449 --> 00:15:18,939
an over determined set of linear

346
00:15:17,420 --> 00:15:21,469
equations or you have this matrix

347
00:15:18,939 --> 00:15:23,449
product with a small secret vector and

348
00:15:21,470 --> 00:15:26,120
then you add the sparse noise so the

349
00:15:23,449 --> 00:15:28,189
noise is zero except for a few points

350
00:15:26,120 --> 00:15:30,800
then this will look this will look

351
00:15:28,189 --> 00:15:32,569
random and what we actually need is the

352
00:15:30,800 --> 00:15:36,139
dual version of this where you multiply

353
00:15:32,569 --> 00:15:36,969
the that the left kernel of this pink

354
00:15:36,139 --> 00:15:38,890
matrix

355
00:15:36,970 --> 00:15:41,560
and then you will see here in this

356
00:15:38,890 --> 00:15:44,050
equation what it will do it will take a

357
00:15:41,560 --> 00:15:45,760
random sparse vector and it will shrink

358
00:15:44,050 --> 00:15:48,010
it a bit but then you get something you

359
00:15:45,760 --> 00:15:50,200
will get something pseudo-random and

360
00:15:48,010 --> 00:15:54,220
this is exactly what we what we want and

361
00:15:50,200 --> 00:15:56,170
why why this is so useful for our for

362
00:15:54,220 --> 00:15:57,970
our construction because again matrix

363
00:15:56,170 --> 00:15:59,560
multiplication is something linear so

364
00:15:57,970 --> 00:16:02,020
the parties can perform this linearly

365
00:15:59,560 --> 00:16:05,979
there's no no no communication required

366
00:16:02,020 --> 00:16:08,290
and the main challenge you have here is

367
00:16:05,980 --> 00:16:10,420
now in terms of of computation because

368
00:16:08,290 --> 00:16:11,770
this because this matrix is big it will

369
00:16:10,420 --> 00:16:13,810
be linear in the number of our T's and

370
00:16:11,770 --> 00:16:15,610
often if we're interested in in

371
00:16:13,810 --> 00:16:18,040
generating 10 million Ortiz then this

372
00:16:15,610 --> 00:16:20,500
will this will be a big matrix so what

373
00:16:18,040 --> 00:16:23,469
we do is we use quasi cyclic codes where

374
00:16:20,500 --> 00:16:25,420
the multiplication basically becomes a

375
00:16:23,470 --> 00:16:27,700
polynomial multiplication so quasi

376
00:16:25,420 --> 00:16:31,750
linear in the in the number of or T's

377
00:16:27,700 --> 00:16:33,610
and the security that we get is similar

378
00:16:31,750 --> 00:16:39,570
to post quantum crypto systems like

379
00:16:33,610 --> 00:16:42,700
pikey bike or hqc and um something

380
00:16:39,570 --> 00:16:45,640
something like I also want to mention so

381
00:16:42,700 --> 00:16:48,190
LP n is some kind of symmetric style

382
00:16:45,640 --> 00:16:50,590
assumption for two reasons so first of

383
00:16:48,190 --> 00:16:52,210
all it does not imply a public key

384
00:16:50,590 --> 00:16:55,000
encryption for certain noise rates also

385
00:16:52,210 --> 00:16:57,070
noise rates were for our like which you

386
00:16:55,000 --> 00:16:59,560
can use for our construction and second

387
00:16:57,070 --> 00:17:02,290
of all it's very efficient so so again

388
00:16:59,560 --> 00:17:04,359
we get an OT extension where it like we

389
00:17:02,290 --> 00:17:08,199
only use symmetric style cryptography

390
00:17:04,359 --> 00:17:12,819
and now just putting everything together

391
00:17:08,199 --> 00:17:15,010
and the last step is to multiply so take

392
00:17:12,819 --> 00:17:17,409
this this matrix and again just locally

393
00:17:15,010 --> 00:17:19,390
apply it to to to to to to the the

394
00:17:17,410 --> 00:17:22,060
results we have from the previous

395
00:17:19,390 --> 00:17:23,740
operation and then and then we get the q

396
00:17:22,060 --> 00:17:27,550
and the B and the R this will be

397
00:17:23,740 --> 00:17:29,800
actually the output of the of our PC G

398
00:17:27,550 --> 00:17:31,560
and by because we have correctness of

399
00:17:29,800 --> 00:17:34,120
the distributed point function and

400
00:17:31,560 --> 00:17:35,800
addition is linear and the matrix

401
00:17:34,120 --> 00:17:38,229
multiplication is linear this will

402
00:17:35,800 --> 00:17:40,090
actually give us what we want and even

403
00:17:38,230 --> 00:17:42,220
though this might look I mean a bit

404
00:17:40,090 --> 00:17:44,290
small now on slides what we get in the

405
00:17:42,220 --> 00:17:45,880
end I mean this is it is a big

406
00:17:44,290 --> 00:17:49,980
compression like we we have a bit of

407
00:17:45,880 --> 00:17:51,750
shrinkage by the LPN matrix but but it's

408
00:17:49,980 --> 00:17:56,790
instead of having if the output here is

409
00:17:51,750 --> 00:17:59,100
and the the keys um what we need to

410
00:17:56,790 --> 00:18:03,059
exchange so the keys are only our only

411
00:17:59,100 --> 00:18:05,879
lambda malla times log n so we have we

412
00:18:03,059 --> 00:18:09,030
have a we have a big achievement here

413
00:18:05,880 --> 00:18:11,490
and yeah to come to a comparison to

414
00:18:09,030 --> 00:18:13,879
previous ot extension protocols I said

415
00:18:11,490 --> 00:18:15,120
in the beginning that what we have I

416
00:18:13,880 --> 00:18:16,500
forgot that

417
00:18:15,120 --> 00:18:18,330
if you do it with the addition you

418
00:18:16,500 --> 00:18:23,190
actually also have to factor T because

419
00:18:18,330 --> 00:18:25,168
you have to 2t times but if you compared

420
00:18:23,190 --> 00:18:26,820
with previous or T extension protocols I

421
00:18:25,169 --> 00:18:28,620
said it's linear the number of OTUs

422
00:18:26,820 --> 00:18:31,830
but it's actually even worse if you look

423
00:18:28,620 --> 00:18:35,969
at the concrete numbers the

424
00:18:31,830 --> 00:18:38,040
communication is like for a single T

425
00:18:35,970 --> 00:18:40,049
even a bid or T you you get something

426
00:18:38,040 --> 00:18:43,080
like 70 at least seventy eight seventy

427
00:18:40,049 --> 00:18:45,389
eight bits per Perot T and we bring this

428
00:18:43,080 --> 00:18:49,740
down with this approach to two zero to

429
00:18:45,390 --> 00:18:53,370
three bits per random random or T so so

430
00:18:49,740 --> 00:18:55,980
significantly less and I'm like maybe on

431
00:18:53,370 --> 00:18:58,110
the downside of having a logarithmic in

432
00:18:55,980 --> 00:19:00,330
the number of n in the number of output

433
00:18:58,110 --> 00:19:02,610
lengths number of rounds and we don't

434
00:19:00,330 --> 00:19:05,189
have active security but actually both

435
00:19:02,610 --> 00:19:07,260
of this we solve in a follow-up work

436
00:19:05,190 --> 00:19:09,480
with together with Peter in DES

437
00:19:07,260 --> 00:19:11,700
where we get it down to two rounds so

438
00:19:09,480 --> 00:19:14,460
actually the first efficient two round

439
00:19:11,700 --> 00:19:16,020
OT extension we back up the

440
00:19:14,460 --> 00:19:18,270
communication with a with an

441
00:19:16,020 --> 00:19:20,910
implementation so there we get zero

442
00:19:18,270 --> 00:19:23,429
point one communication for random ot

443
00:19:20,910 --> 00:19:26,940
for generating ten million or teeth and

444
00:19:23,429 --> 00:19:30,390
we also get an get an active get active

445
00:19:26,940 --> 00:19:32,250
security and what does it mean for the

446
00:19:30,390 --> 00:19:36,600
team W protocol that we had at the

447
00:19:32,250 --> 00:19:39,570
beginning so if you use the team W

448
00:19:36,600 --> 00:19:42,510
protocol with for example the ikm P you

449
00:19:39,570 --> 00:19:44,790
get more than a hundred bits per n gates

450
00:19:42,510 --> 00:19:47,070
so with all previous approaches and we

451
00:19:44,790 --> 00:19:49,409
print it down to four so four is

452
00:19:47,070 --> 00:19:51,659
actually the cost of the online face so

453
00:19:49,410 --> 00:19:58,020
we make and pre-processing almost for

454
00:19:51,660 --> 00:19:59,820
free in terms of communication and on

455
00:19:58,020 --> 00:20:02,520
the other hand so talking about

456
00:19:59,820 --> 00:20:03,580
computation so our approach needs we can

457
00:20:02,520 --> 00:20:08,379
generate

458
00:20:03,580 --> 00:20:11,260
about a million ortiz per second so this

459
00:20:08,380 --> 00:20:14,070
is slower than i can pee but over slow

460
00:20:11,260 --> 00:20:16,870
networks because we have huge it's huge

461
00:20:14,070 --> 00:20:20,830
saving in terms of communication will be

462
00:20:16,870 --> 00:20:26,290
output form i can pee and so how to

463
00:20:20,830 --> 00:20:28,360
conclude this talk pseudo-random

464
00:20:26,290 --> 00:20:31,960
correlation generators are useful so

465
00:20:28,360 --> 00:20:34,709
they give multiple secure multi-party

466
00:20:31,960 --> 00:20:38,230
computation with silent pre-processing

467
00:20:34,710 --> 00:20:39,790
we have a silent or t extension from the

468
00:20:38,230 --> 00:20:42,610
learning party with noise assumption

469
00:20:39,790 --> 00:20:45,970
which is concretely efficient and the

470
00:20:42,610 --> 00:20:48,280
idea is you take few beso T's and then

471
00:20:45,970 --> 00:20:50,320
you locally expand and the only thing

472
00:20:48,280 --> 00:20:55,930
you need is symmetric symmetric style

473
00:20:50,320 --> 00:20:57,639
crypto and we we also achieve like we

474
00:20:55,930 --> 00:20:59,410
improved this to actually get the two

475
00:20:57,640 --> 00:21:02,100
round or T extension and also malicious

476
00:20:59,410 --> 00:21:05,020
security with with the same techniques

477
00:21:02,100 --> 00:21:09,280
but but getting a better better setup

478
00:21:05,020 --> 00:21:11,740
face basically and from what is also

479
00:21:09,280 --> 00:21:13,720
interesting to mention what this line of

480
00:21:11,740 --> 00:21:15,820
four gives it gives new feasibility

481
00:21:13,720 --> 00:21:18,280
results and and practical instantiation

482
00:21:15,820 --> 00:21:23,310
from learning parity with nice and and

483
00:21:18,280 --> 00:21:27,010
this is interesting because because

484
00:21:23,310 --> 00:21:28,720
because if a in particular for the

485
00:21:27,010 --> 00:21:30,430
practical instantiation we're not we

486
00:21:28,720 --> 00:21:31,870
don't know how to do is from from from

487
00:21:30,430 --> 00:21:33,280
stronger from seemingly stronger

488
00:21:31,870 --> 00:21:34,810
assumption like you like learning with

489
00:21:33,280 --> 00:21:38,080
arrows so this is actually gives

490
00:21:34,810 --> 00:21:40,419
something new and yes this is there's

491
00:21:38,080 --> 00:21:43,000
lots of things to do a lot of operand

492
00:21:40,420 --> 00:21:44,950
problems to work on so and we have

493
00:21:43,000 --> 00:21:48,100
within our paper we give construction

494
00:21:44,950 --> 00:21:50,020
for beaver triples for oblivious linear

495
00:21:48,100 --> 00:21:52,300
function evolution and but they're not

496
00:21:50,020 --> 00:21:54,340
as efficient as the OT construction that

497
00:21:52,300 --> 00:21:56,200
I showed you so like can we can we use

498
00:21:54,340 --> 00:21:58,240
similar techniques can we do things to

499
00:21:56,200 --> 00:22:01,450
get to get it actually as efficient as

500
00:21:58,240 --> 00:22:04,540
the OT construction what would be super

501
00:22:01,450 --> 00:22:06,580
cool to achieve is a PCG where we don't

502
00:22:04,540 --> 00:22:09,720
have to expand it all at once but only

503
00:22:06,580 --> 00:22:11,679
expand it like however much much we need

504
00:22:09,720 --> 00:22:14,380
to extend

505
00:22:11,680 --> 00:22:16,450
and because like a big part or like it's

506
00:22:14,380 --> 00:22:19,180
very central part to our construction is

507
00:22:16,450 --> 00:22:21,370
learning parity with nice so so so

508
00:22:19,180 --> 00:22:23,290
further further study the learning

509
00:22:21,370 --> 00:22:26,889
parity with noise assumption which code

510
00:22:23,290 --> 00:22:30,129
noise combinations are friendly RL pian

511
00:22:26,890 --> 00:22:32,200
okay and friendly what is what is the

512
00:22:30,130 --> 00:22:33,610
best way of implementing learning parity

513
00:22:32,200 --> 00:22:35,830
with noise in large scale because

514
00:22:33,610 --> 00:22:38,500
generally like people look more into

515
00:22:35,830 --> 00:22:40,540
when you have where when you have a

516
00:22:38,500 --> 00:22:42,400
smaller or smaller than smaller matrix

517
00:22:40,540 --> 00:22:44,409
but we really interested we want to have

518
00:22:42,400 --> 00:22:47,830
like as big as possible because then we

519
00:22:44,410 --> 00:22:49,960
can get more Ortiz what is the best way

520
00:22:47,830 --> 00:22:52,379
to do so computationally efficiently and

521
00:22:49,960 --> 00:22:56,980
more from the theoretical side I'm

522
00:22:52,380 --> 00:22:59,350
giving a generic LP n model because our

523
00:22:56,980 --> 00:23:00,940
construction and it's of course not a

524
00:22:59,350 --> 00:23:02,679
blackboard construction but it has some

525
00:23:00,940 --> 00:23:04,870
black box flavor and maybe giving a

526
00:23:02,680 --> 00:23:08,110
model where we can capture deflect black

527
00:23:04,870 --> 00:23:10,719
box flavor of our construction so yeah

528
00:23:08,110 --> 00:23:12,659
that's it for me so thank you very much

529
00:23:10,720 --> 00:23:20,540
for attention

530
00:23:12,660 --> 00:23:25,770
[Applause]

531
00:23:20,540 --> 00:23:27,720
any questions thanks for the talk

532
00:23:25,770 --> 00:23:30,900
so I was wondering and if you apply this

533
00:23:27,720 --> 00:23:33,300
protocol to the gmw you get very small

534
00:23:30,900 --> 00:23:35,040
communication the pre-processing can you

535
00:23:33,300 --> 00:23:39,030
comment on the local computation cost

536
00:23:35,040 --> 00:23:42,240
for the parties so the as I said so the

537
00:23:39,030 --> 00:23:46,320
local computation cost you have you have

538
00:23:42,240 --> 00:23:49,980
you have a million or T's per second so

539
00:23:46,320 --> 00:23:51,990
we studied so for the so for and so

540
00:23:49,980 --> 00:23:54,480
forth T extension like if you just

541
00:23:51,990 --> 00:23:58,860
consider the if you just consider the ot

542
00:23:54,480 --> 00:24:02,760
extension part four in our follow wake

543
00:23:58,860 --> 00:24:06,300
up work if if you do this over like over

544
00:24:02,760 --> 00:24:10,800
over white area network with 10 megabyte

545
00:24:06,300 --> 00:24:12,629
megabits per second you get almost 50

546
00:24:10,800 --> 00:24:15,510
times improvement so even if you if you

547
00:24:12,630 --> 00:24:17,790
factor in the the the computation you

548
00:24:15,510 --> 00:24:22,560
can get improvements over like replacing

549
00:24:17,790 --> 00:24:24,600
I can people can Anna as a second so um

550
00:24:22,560 --> 00:24:27,780
you mentioned that for the LPN you used

551
00:24:24,600 --> 00:24:30,389
quasi cyclic code for the improvement so

552
00:24:27,780 --> 00:24:32,760
I was wondering like why does it not add

553
00:24:30,390 --> 00:24:35,820
another coding Theory like coal-based

554
00:24:32,760 --> 00:24:38,129
cryptography assumption but so does your

555
00:24:35,820 --> 00:24:41,340
protocol security still reduces to LPN

556
00:24:38,130 --> 00:24:47,490
itself with with no additional code base

557
00:24:41,340 --> 00:24:49,580
cryptography assumption that is secure

558
00:24:47,490 --> 00:24:52,080
for you using this kind you for using

559
00:24:49,580 --> 00:24:53,760
this kind of code so as I said it's

560
00:24:52,080 --> 00:24:57,270
similar to the assumption that that

561
00:24:53,760 --> 00:25:00,960
people post like quantum crypto system

562
00:24:57,270 --> 00:25:07,470
so it is is it equivalent to playing LPM

563
00:25:00,960 --> 00:25:10,220
or is it not it's it's no it's not so

564
00:25:07,470 --> 00:25:11,490
for for random matrices so that's not

565
00:25:10,220 --> 00:25:15,450
equivalent

566
00:25:11,490 --> 00:25:17,310
ok thank you

567
00:25:15,450 --> 00:25:17,650
yeah let's thank the speaker again and

568
00:25:17,310 --> 00:25:22,129
ever

569
00:25:17,650 --> 00:25:22,130
[Applause]

