1
00:00:04,970 --> 00:00:11,160
thanks for the introduction so yeah I'm

2
00:00:08,969 --> 00:00:13,200
gonna talk about this new thing that we

3
00:00:11,160 --> 00:00:14,610
call chapter hash functions and as I'm

4
00:00:13,200 --> 00:00:16,970
gonna show really soon it has lots of

5
00:00:14,610 --> 00:00:18,960
interesting applications so let's start

6
00:00:16,970 --> 00:00:20,759
and in order to give you some motivation

7
00:00:18,960 --> 00:00:25,289
I'm gonna actually begin with the

8
00:00:20,759 --> 00:00:26,760
application of a chapter hash so all of

9
00:00:25,289 --> 00:00:28,439
our applications they fall in the

10
00:00:26,760 --> 00:00:31,019
following context we have a public

11
00:00:28,439 --> 00:00:33,150
function f that takes two inputs and we

12
00:00:31,019 --> 00:00:35,640
have two parties a receiver Bob with an

13
00:00:33,150 --> 00:00:38,100
input X and we have a sender Alice with

14
00:00:35,640 --> 00:00:39,930
an input Y and the world essentially is

15
00:00:38,100 --> 00:00:41,159
to let these two parties communicate and

16
00:00:39,930 --> 00:00:43,680
at the end we want that the receiver

17
00:00:41,159 --> 00:00:47,460
learns the output of of the function on

18
00:00:43,680 --> 00:00:49,110
the two inputs okay so I will focus for

19
00:00:47,460 --> 00:00:51,360
this talk is going to be on protocols

20
00:00:49,110 --> 00:00:53,129
that consist only of two messages so at

21
00:00:51,360 --> 00:00:56,580
first the receiver sends a message and

22
00:00:53,129 --> 00:00:57,839
then the sender responds and our goal is

23
00:00:56,580 --> 00:00:59,369
going to be to minimize the

24
00:00:57,839 --> 00:01:01,799
communication complexity of such

25
00:00:59,369 --> 00:01:05,850
protocols or in other words to minimize

26
00:01:01,799 --> 00:01:07,710
the length of these two messages good so

27
00:01:05,850 --> 00:01:09,839
in an ideal world where Alice and Bob

28
00:01:07,710 --> 00:01:11,850
love and trust each other we we can

29
00:01:09,840 --> 00:01:14,280
construct a very simple protocols that

30
00:01:11,850 --> 00:01:16,050
have optimal communication but we

31
00:01:14,280 --> 00:01:18,240
encrypt also we're interested in a

32
00:01:16,050 --> 00:01:19,500
scenario where the parties do not trust

33
00:01:18,240 --> 00:01:21,839
each other and each of them wants to

34
00:01:19,500 --> 00:01:23,910
keep his inputs private and we're going

35
00:01:21,840 --> 00:01:26,820
to consider the same honest notion of

36
00:01:23,910 --> 00:01:29,250
security and the main question we were

37
00:01:26,820 --> 00:01:31,380
going to ask is whether a protocols that

38
00:01:29,250 --> 00:01:35,040
guarantee security can be as efficient

39
00:01:31,380 --> 00:01:36,929
as protocols from the ideal world so in

40
00:01:35,040 --> 00:01:39,270
other words we're asking what's the cost

41
00:01:36,930 --> 00:01:42,960
of security in terms of communication in

42
00:01:39,270 --> 00:01:44,520
such a setting perfect so in order to

43
00:01:42,960 --> 00:01:46,529
give a meaningful answer to this

44
00:01:44,520 --> 00:01:48,720
question we have to distinct between two

45
00:01:46,530 --> 00:01:51,000
different cases and the first case is

46
00:01:48,720 --> 00:01:53,158
when the senders input is much larger

47
00:01:51,000 --> 00:01:55,740
than the receiver the Nativity than the

48
00:01:53,159 --> 00:01:57,690
receivers input and the very common and

49
00:01:55,740 --> 00:01:59,610
useful example is oblivious transfer

50
00:01:57,690 --> 00:02:02,250
where the sender has two long messages

51
00:01:59,610 --> 00:02:04,590
say of a length n and the receiver Bob

52
00:02:02,250 --> 00:02:06,479
wants to learn one of these messages and

53
00:02:04,590 --> 00:02:10,049
we want to achieve this while keeping

54
00:02:06,479 --> 00:02:11,819
Bob choice private against Alice and we

55
00:02:10,049 --> 00:02:13,350
don't want to give any information to

56
00:02:11,819 --> 00:02:16,319
Bob about the other string interesting

57
00:02:13,350 --> 00:02:18,640
that he did not choose to get so if we

58
00:02:16,319 --> 00:02:22,720
do not need security then we can let Bob

59
00:02:18,640 --> 00:02:24,640
his choice bit X and then Alice can

60
00:02:22,720 --> 00:02:26,230
respond with the chosen string so the

61
00:02:24,640 --> 00:02:28,480
communication here is dominated by the

62
00:02:26,230 --> 00:02:31,299
length of the second message which is n

63
00:02:28,480 --> 00:02:33,130
in this case so I will go further

64
00:02:31,300 --> 00:02:35,350
execute protocols is going to be to

65
00:02:33,130 --> 00:02:37,630
optimize the length of the second

66
00:02:35,350 --> 00:02:39,549
message and this means we want to

67
00:02:37,630 --> 00:02:42,430
optimize the download rate of a protocol

68
00:02:39,550 --> 00:02:44,410
which we define as the ratio between the

69
00:02:42,430 --> 00:02:47,320
output length of the function which is n

70
00:02:44,410 --> 00:02:49,569
in such functions and the length of the

71
00:02:47,320 --> 00:02:54,160
second message of the protocol we're

72
00:02:49,569 --> 00:02:56,589
analyzing cool so again without security

73
00:02:54,160 --> 00:02:59,350
we can get optimal download rate of

74
00:02:56,590 --> 00:03:03,430
exactly one so now we ask whether we can

75
00:02:59,350 --> 00:03:05,739
match that in insecure protocols and the

76
00:03:03,430 --> 00:03:08,830
bad news is that we cannot and this is

77
00:03:05,739 --> 00:03:10,330
not surprising and more specifically we

78
00:03:08,830 --> 00:03:12,370
show that if lambda is our security

79
00:03:10,330 --> 00:03:14,920
parameter then the length of the second

80
00:03:12,370 --> 00:03:18,760
message has to be larger by an N by at

81
00:03:14,920 --> 00:03:20,799
least a twice lambda so the best we can

82
00:03:18,760 --> 00:03:22,840
hope for in some sense is download rate

83
00:03:20,800 --> 00:03:25,540
that at least approaches 1 when n grows

84
00:03:22,840 --> 00:03:29,410
larger and larger and this is exactly

85
00:03:25,540 --> 00:03:30,700
what we get with a trapdoor hash so

86
00:03:29,410 --> 00:03:34,239
let's see what we could do before

87
00:03:30,700 --> 00:03:36,190
trapdoor hash so we could get a rate 1/2

88
00:03:34,239 --> 00:03:38,350
reverse transfer using generic

89
00:03:36,190 --> 00:03:40,450
assumptions so these are protocols where

90
00:03:38,350 --> 00:03:43,540
the sender had to send at least 2n bits

91
00:03:40,450 --> 00:03:45,010
and the only way to get a higher rate

92
00:03:43,540 --> 00:03:48,190
was to use high rate homomorphic

93
00:03:45,010 --> 00:03:49,810
encryption schemes and the only such

94
00:03:48,190 --> 00:03:51,880
encryption scheme that was known as the

95
00:03:49,810 --> 00:03:53,530
damge Durak scheme which with security

96
00:03:51,880 --> 00:03:55,329
based on the destroyer assumption so

97
00:03:53,530 --> 00:03:57,280
from all standard assumptions other than

98
00:03:55,329 --> 00:03:59,829
the DC or assumption the best we could

99
00:03:57,280 --> 00:04:01,870
do is rate half British transfer and the

100
00:03:59,829 --> 00:04:04,810
only exception to this statement is two

101
00:04:01,870 --> 00:04:06,700
very recent papers the one by one by

102
00:04:04,810 --> 00:04:08,829
Gentry and Halevi the other Birkett are

103
00:04:06,700 --> 00:04:11,109
where they show how to construct optimal

104
00:04:08,829 --> 00:04:16,299
rate a volume of encryption schemes

105
00:04:11,110 --> 00:04:18,310
under the lwe assumption good so using

106
00:04:16,298 --> 00:04:20,010
trapdoor hash we get the first optimal

107
00:04:18,310 --> 00:04:23,979
rate previous transferred protocols

108
00:04:20,010 --> 00:04:26,020
under the DD h QR lwe assumptions and we

109
00:04:23,979 --> 00:04:28,360
also get a new construction from d CR

110
00:04:26,020 --> 00:04:31,930
with nicer properties compared to the

111
00:04:28,360 --> 00:04:32,409
dongle Jurek so more specifically we get

112
00:04:31,930 --> 00:04:34,029
statistic

113
00:04:32,409 --> 00:04:35,979
send their privacy and such protocols

114
00:04:34,029 --> 00:04:38,519
and we get receiver privacy which is

115
00:04:35,979 --> 00:04:42,058
computational under these assumptions

116
00:04:38,519 --> 00:04:45,879
and the sender and such protocols

117
00:04:42,059 --> 00:04:49,300
she sends n plus a poly lambda a bits in

118
00:04:45,879 --> 00:04:51,069
the second message good so we can

119
00:04:49,300 --> 00:04:53,889
further get protocols for more general

120
00:04:51,069 --> 00:04:56,709
functions such as a batch ot batch Oh an

121
00:04:53,889 --> 00:04:59,879
E and mass fix vector a matrix vector

122
00:04:56,709 --> 00:05:02,919
product perfect

123
00:04:59,879 --> 00:05:04,899
so besides rate 100 T being interesting

124
00:05:02,919 --> 00:05:08,769
by its own it also has lots of powerful

125
00:05:04,899 --> 00:05:11,559
applications so the first application is

126
00:05:08,769 --> 00:05:13,869
in private information retrieval using

127
00:05:11,559 --> 00:05:16,179
our a rate one with the sastras

128
00:05:13,869 --> 00:05:18,159
protocols we get the first protocols for

129
00:05:16,179 --> 00:05:20,169
single cell repealed that have both

130
00:05:18,159 --> 00:05:22,659
polar Paula braveman communication and

131
00:05:20,169 --> 00:05:25,149
optimal download rate so we get the

132
00:05:22,659 --> 00:05:27,610
first ask instruction from lead HQ r and

133
00:05:25,149 --> 00:05:30,129
LW e and in particular we finally solve

134
00:05:27,610 --> 00:05:32,319
the open question of constructing a peer

135
00:05:30,129 --> 00:05:37,089
with poly log communication from b th or

136
00:05:32,319 --> 00:05:38,800
AQ r the second application can be seen

137
00:05:37,089 --> 00:05:40,539
as a generalization of the above and

138
00:05:38,800 --> 00:05:42,369
here we get from or encryption scheme

139
00:05:40,539 --> 00:05:44,529
for branching program where the length

140
00:05:42,369 --> 00:05:45,999
of the cipher text grows only with the

141
00:05:44,529 --> 00:05:48,369
length width of the branching program

142
00:05:45,999 --> 00:05:50,860
but is independent of its width and both

143
00:05:48,369 --> 00:05:52,839
of these applications are based on a

144
00:05:50,860 --> 00:05:56,679
transformation from the work of Fisher

145
00:05:52,839 --> 00:05:59,169
and Pascal in all seven in the third

146
00:05:56,679 --> 00:06:01,599
application I'm going to mention we get

147
00:05:59,169 --> 00:06:04,089
the first optimal rate constructions for

148
00:06:01,599 --> 00:06:08,349
lossy trapdoor functions from again did

149
00:06:04,089 --> 00:06:10,929
the hqr and lwe good

150
00:06:08,349 --> 00:06:12,998
so the second scenario I'm going to

151
00:06:10,929 --> 00:06:15,248
consider for our for our applications is

152
00:06:12,999 --> 00:06:17,110
going to be when the receiver input is

153
00:06:15,249 --> 00:06:20,739
actually the largest input of the tool

154
00:06:17,110 --> 00:06:22,809
and the very general example is when Bob

155
00:06:20,739 --> 00:06:25,719
the receiver has a huge database of size

156
00:06:22,809 --> 00:06:27,669
n and the sender Alice has a small ray

157
00:06:25,719 --> 00:06:30,339
machine with running time much smaller

158
00:06:27,669 --> 00:06:32,619
than n and the goal here is to let Bob

159
00:06:30,339 --> 00:06:35,919
learn the output of M when we run it on

160
00:06:32,619 --> 00:06:38,409
on his database X and notice that

161
00:06:35,919 --> 00:06:40,389
because the running time of M is much

162
00:06:38,409 --> 00:06:42,519
smaller than and in particular when we

163
00:06:40,389 --> 00:06:46,600
run it on the database X then it looks

164
00:06:42,519 --> 00:06:50,260
at very few allocations of the database

165
00:06:46,600 --> 00:06:53,020
so again we want to achieve this this

166
00:06:50,260 --> 00:06:56,380
functionality while keeping both M and X

167
00:06:53,020 --> 00:06:58,060
private and there are lots of you life

168
00:06:56,380 --> 00:07:02,320
applications for those of you who care

169
00:06:58,060 --> 00:07:03,940
so with our security again we can let

170
00:07:02,320 --> 00:07:08,680
Alice just send the description of the

171
00:07:03,940 --> 00:07:10,780
Machine M this is very and if we assume

172
00:07:08,680 --> 00:07:12,910
that M is more than the communication it

173
00:07:10,780 --> 00:07:16,479
is independent of N and actually much

174
00:07:12,910 --> 00:07:19,180
smaller often by than n so our goal for

175
00:07:16,480 --> 00:07:21,550
secure protocols is going to achieve

176
00:07:19,180 --> 00:07:24,370
communication that somehow smaller than

177
00:07:21,550 --> 00:07:26,350
n and this is already a non-trivial task

178
00:07:24,370 --> 00:07:30,130
when we strict ourselves to protocols

179
00:07:26,350 --> 00:07:32,080
with two messages only and another thing

180
00:07:30,130 --> 00:07:33,880
I want to mention is that if we want

181
00:07:32,080 --> 00:07:35,710
security then we need to work in a model

182
00:07:33,880 --> 00:07:37,180
where we assume that there is a common

183
00:07:35,710 --> 00:07:43,479
reference string that the two parties

184
00:07:37,180 --> 00:07:45,130
can access okay so before having type 2

185
00:07:43,480 --> 00:07:47,110
hash the only solution to this problem

186
00:07:45,130 --> 00:07:48,670
that could get you a sub linear

187
00:07:47,110 --> 00:07:50,740
communication was to use laconic

188
00:07:48,670 --> 00:07:52,480
function evaluation where you would get

189
00:07:50,740 --> 00:07:55,390
communication proportional only to the

190
00:07:52,480 --> 00:07:57,190
running time of n of M and this is in

191
00:07:55,390 --> 00:07:59,890
some sense optimal up to a poly lambda

192
00:07:57,190 --> 00:08:01,420
factors so laconic function evaluation

193
00:07:59,890 --> 00:08:04,950
would give you security security under

194
00:08:01,420 --> 00:08:07,330
the l w assumption and if lattice best

195
00:08:04,950 --> 00:08:08,979
security was not good for you then you

196
00:08:07,330 --> 00:08:10,900
could leave it and another thing you

197
00:08:08,980 --> 00:08:13,540
could do is you could use a laconic

198
00:08:10,900 --> 00:08:14,799
oblivious transfer which gave you a more

199
00:08:13,540 --> 00:08:18,100
or less the same communication

200
00:08:14,800 --> 00:08:20,260
complexity and security based on the DDH

201
00:08:18,100 --> 00:08:22,090
assumption however the problem with

202
00:08:20,260 --> 00:08:24,219
laconic OT was that it would not

203
00:08:22,090 --> 00:08:27,520
guarantee the full notion of security

204
00:08:24,220 --> 00:08:29,290
and in particular the access pattern of

205
00:08:27,520 --> 00:08:31,560
the machine m is revealed to the

206
00:08:29,290 --> 00:08:34,539
receiver Bob

207
00:08:31,560 --> 00:08:37,270
so using trapdoor hash we get the first

208
00:08:34,539 --> 00:08:39,370
fully secure solution with a sub inner

209
00:08:37,270 --> 00:08:40,689
communication and security based on a

210
00:08:39,370 --> 00:08:43,960
number theoretic assumptions

211
00:08:40,690 --> 00:08:45,520
so in particular we get using as

212
00:08:43,960 --> 00:08:47,650
something we call private laconic of T

213
00:08:45,520 --> 00:08:49,900
we get a protocol with communication

214
00:08:47,650 --> 00:08:52,120
complex complexity proportional to T

215
00:08:49,900 --> 00:08:54,069
times square root n under the DDH

216
00:08:52,120 --> 00:08:56,020
assumption and if we want to use

217
00:08:54,070 --> 00:08:59,560
bilinear groups with pairings then we

218
00:08:56,020 --> 00:09:00,730
could reduce that to cube root of n

219
00:08:59,560 --> 00:09:02,319
I'm already gonna give you an open

220
00:09:00,730 --> 00:09:05,500
question and it's whether we can close

221
00:09:02,320 --> 00:09:08,140
this gap between efficiency gap between

222
00:09:05,500 --> 00:09:10,270
a lattice based solutions and solutions

223
00:09:08,140 --> 00:09:14,650
based on assumptions like the DDH

224
00:09:10,270 --> 00:09:16,449
assumption okay so now that you know

225
00:09:14,650 --> 00:09:18,459
what are the applications of tableau

226
00:09:16,450 --> 00:09:21,760
hash let's talk about a trapdoor hash

227
00:09:18,460 --> 00:09:23,830
and in order to define tab the hash i'm

228
00:09:21,760 --> 00:09:26,860
going actually to begin with a trapdoor

229
00:09:23,830 --> 00:09:28,240
functions that we all know and i'm going

230
00:09:26,860 --> 00:09:30,670
to take you back to the two party

231
00:09:28,240 --> 00:09:33,370
context so trapdoor functions allow some

232
00:09:30,670 --> 00:09:36,040
party Bob to generate a pair of a key

233
00:09:33,370 --> 00:09:38,230
and a trapdoor and then Bob can publish

234
00:09:36,040 --> 00:09:40,839
the key and in particulars and send it

235
00:09:38,230 --> 00:09:42,550
to his friend Alice and now Alice given

236
00:09:40,839 --> 00:09:46,240
the key can take her input X and

237
00:09:42,550 --> 00:09:49,060
evaluate saw the trapdoor function given

238
00:09:46,240 --> 00:09:51,940
this key and get some image Y and the

239
00:09:49,060 --> 00:09:55,000
only one who can take Y and invert it

240
00:09:51,940 --> 00:09:56,230
back to X is Bob who has the trapdoor so

241
00:09:55,000 --> 00:09:57,910
using the key you could evaluate a

242
00:09:56,230 --> 00:10:02,170
function in using the trapdoor you can

243
00:09:57,910 --> 00:10:04,780
invert it so Tabler functions allow Bob

244
00:10:02,170 --> 00:10:08,319
to recover the entire pre image of Y X

245
00:10:04,780 --> 00:10:10,329
and information theoretically if he

246
00:10:08,320 --> 00:10:12,670
wants to do that then he will have to

247
00:10:10,330 --> 00:10:15,250
see the information which is at least

248
00:10:12,670 --> 00:10:18,270
larger at least larger than X so what

249
00:10:15,250 --> 00:10:20,650
has to be at least as large as as X here

250
00:10:18,270 --> 00:10:22,780
however now in our applications we need

251
00:10:20,650 --> 00:10:24,939
something a bit different it's enough

252
00:10:22,780 --> 00:10:27,310
for us that Bob learns only a small part

253
00:10:24,940 --> 00:10:29,410
of X we don't need him to learn the

254
00:10:27,310 --> 00:10:31,650
entire pre image but on the other hand

255
00:10:29,410 --> 00:10:35,650
we want to minimize communication and

256
00:10:31,650 --> 00:10:37,600
that's what tablet hash are useful so

257
00:10:35,650 --> 00:10:39,910
tablet hash functions allow Alice to

258
00:10:37,600 --> 00:10:42,400
compute a very small image of her input

259
00:10:39,910 --> 00:10:45,610
X which we call the hash value of of X

260
00:10:42,400 --> 00:10:47,380
and we denoted by H and now Bob wants to

261
00:10:45,610 --> 00:10:49,120
learn only a small part of X so let's

262
00:10:47,380 --> 00:10:51,700
assume he wants to learn the eyes bit of

263
00:10:49,120 --> 00:10:53,740
X so information theoretically he's

264
00:10:51,700 --> 00:10:57,970
gonna need something more than the hash

265
00:10:53,740 --> 00:11:00,160
value so the trapdoor part of trap door

266
00:10:57,970 --> 00:11:02,260
has functions will allow Bob to generate

267
00:11:00,160 --> 00:11:03,910
again a key and a trapdoor and he's

268
00:11:02,260 --> 00:11:06,010
going to publish the key and send it and

269
00:11:03,910 --> 00:11:08,290
send it to Alice and now given the key

270
00:11:06,010 --> 00:11:10,839
Alice can compute a really small image

271
00:11:08,290 --> 00:11:12,649
of her input edge which we call the hint

272
00:11:10,839 --> 00:11:14,839
and now

273
00:11:12,649 --> 00:11:17,899
nabob who has a trapdoor can use this

274
00:11:14,839 --> 00:11:22,910
hint and the hash value to recover exile

275
00:11:17,899 --> 00:11:24,559
so again Bob recovers only exile but he

276
00:11:22,910 --> 00:11:27,730
needs much less information which

277
00:11:24,559 --> 00:11:30,439
consists on the hint and the hash only

278
00:11:27,730 --> 00:11:32,449
so the syntax of trapdoor hash consists

279
00:11:30,439 --> 00:11:33,679
of four algorithms the hashing function

280
00:11:32,449 --> 00:11:36,050
that takes the input X and the

281
00:11:33,679 --> 00:11:37,579
randomness are the key generation which

282
00:11:36,050 --> 00:11:39,769
allows both to generate a key on the

283
00:11:37,579 --> 00:11:42,559
trapdoor we have the hinting function

284
00:11:39,769 --> 00:11:45,529
and the decoding which inverts the hash

285
00:11:42,559 --> 00:11:49,069
value and the hint back to and recovers

286
00:11:45,529 --> 00:11:51,139
X i given trouble and we're going to

287
00:11:49,069 --> 00:11:53,300
require security for both parties so we

288
00:11:51,139 --> 00:11:54,860
want that Alice's input X remains

289
00:11:53,300 --> 00:11:56,929
private so the hash should not reveal

290
00:11:54,860 --> 00:11:58,809
any information about it and on the

291
00:11:56,929 --> 00:12:01,339
other hand we want that Bob's input I

292
00:11:58,809 --> 00:12:02,749
remains also private so the key that he

293
00:12:01,339 --> 00:12:03,800
sends to Alice should not reveal an

294
00:12:02,749 --> 00:12:07,459
information about it

295
00:12:03,800 --> 00:12:09,889
and our main efficiency goal here is

296
00:12:07,459 --> 00:12:11,420
first we want the hash to be small and

297
00:12:09,889 --> 00:12:14,209
in particular its size would be

298
00:12:11,420 --> 00:12:18,170
independent of N and we also want that

299
00:12:14,209 --> 00:12:19,758
the hints are small and in other words

300
00:12:18,170 --> 00:12:22,160
we want that the rate of the Tabler hash

301
00:12:19,759 --> 00:12:24,050
is is actually high where we define the

302
00:12:22,160 --> 00:12:26,689
rate the rate as the inverse of the

303
00:12:24,050 --> 00:12:28,429
length of the hint and the to make some

304
00:12:26,689 --> 00:12:30,439
some sense out of this rate definition

305
00:12:28,429 --> 00:12:33,350
notice that Bob can generate multiple

306
00:12:30,439 --> 00:12:37,219
keys in order to recover multiple bits

307
00:12:33,350 --> 00:12:39,470
of the database and you can see that the

308
00:12:37,220 --> 00:12:41,120
rate here as we defined it is

309
00:12:39,470 --> 00:12:43,009
asymptotically equal to the ratio

310
00:12:41,120 --> 00:12:45,769
between the information that Bob

311
00:12:43,009 --> 00:12:47,509
recovers and the length of the hands

312
00:12:45,769 --> 00:12:52,309
that Bob needs in order to recover this

313
00:12:47,509 --> 00:12:54,050
information so the main technical

314
00:12:52,309 --> 00:12:56,179
contribution of our paper is

315
00:12:54,050 --> 00:13:00,170
constructions for trapdoor hash with

316
00:12:56,179 --> 00:13:05,509
optimal rate under the DD h QR LW e and

317
00:13:00,170 --> 00:13:06,799
these are assumptions so next I'm going

318
00:13:05,509 --> 00:13:11,329
to show you that the tableau has

319
00:13:06,799 --> 00:13:13,100
construction from added age and I want

320
00:13:11,329 --> 00:13:15,769
to say that we use techniques that were

321
00:13:13,100 --> 00:13:18,589
used before to construct a schemes for

322
00:13:15,769 --> 00:13:21,559
ibe laconic ot and trapdoor functions

323
00:13:18,589 --> 00:13:23,749
with very nice properties and we're

324
00:13:21,559 --> 00:13:26,420
going to work over a multiplicative

325
00:13:23,749 --> 00:13:28,100
abelian group G of prime order

326
00:13:26,420 --> 00:13:29,959
and we're going to have a public

327
00:13:28,100 --> 00:13:33,110
generator of this group which we are

328
00:13:29,960 --> 00:13:35,060
going to denote by small G let's record

329
00:13:33,110 --> 00:13:38,150
the DTH assumption which says that if we

330
00:13:35,060 --> 00:13:40,640
take two random integers a and B from GP

331
00:13:38,150 --> 00:13:43,250
then G to the a B it looks like a

332
00:13:40,640 --> 00:13:49,189
uniform group element even given G to

333
00:13:43,250 --> 00:13:51,080
the a and G to the B so let's proceed to

334
00:13:49,190 --> 00:13:55,250
the construction so again Alice has an

335
00:13:51,080 --> 00:13:57,020
input X and the first and okay so so

336
00:13:55,250 --> 00:14:00,710
we're going to have public parameters

337
00:13:57,020 --> 00:14:02,660
for our construction and this will be 2n

338
00:14:00,710 --> 00:14:07,190
uniform group element which we are going

339
00:14:02,660 --> 00:14:08,900
to order in a matrix of 2 over n uniform

340
00:14:07,190 --> 00:14:10,820
group elements so again these are the

341
00:14:08,900 --> 00:14:14,840
public parameters and now let's define

342
00:14:10,820 --> 00:14:16,640
the hash function so the way that ice is

343
00:14:14,840 --> 00:14:19,010
going to compute at hash is as follows

344
00:14:16,640 --> 00:14:21,680
so Alice is going to go over every

345
00:14:19,010 --> 00:14:24,080
column in the public matrix and she's

346
00:14:21,680 --> 00:14:26,540
going to take the top a group element if

347
00:14:24,080 --> 00:14:27,980
the corresponding input bit is 0 and

348
00:14:26,540 --> 00:14:29,449
she's going to take the bottom group

349
00:14:27,980 --> 00:14:32,240
element if the corresponding bit is

350
00:14:29,450 --> 00:14:34,130
equal to 1 so she collects this and

351
00:14:32,240 --> 00:14:36,200
group elements she multiplies them all

352
00:14:34,130 --> 00:14:38,990
and get a hash value which is

353
00:14:36,200 --> 00:14:40,760
essentially a group element here so

354
00:14:38,990 --> 00:14:44,030
again the hash value is defined as this

355
00:14:40,760 --> 00:14:48,950
product and now she since the hash to

356
00:14:44,030 --> 00:14:51,199
Bob like we said we were expecting this

357
00:14:48,950 --> 00:14:53,600
hash value to be a private however here

358
00:14:51,200 --> 00:14:55,580
we do not use randomness so this hash

359
00:14:53,600 --> 00:14:57,530
function of course cannot be private but

360
00:14:55,580 --> 00:14:59,360
you will have to believe me that with a

361
00:14:57,530 --> 00:15:03,470
bit more effort we can get statistical

362
00:14:59,360 --> 00:15:07,240
privacy for Alice okay so now Bob wants

363
00:15:03,470 --> 00:15:09,710
to learn the ice bit of the database and

364
00:15:07,240 --> 00:15:11,960
for that is going to generate a pair of

365
00:15:09,710 --> 00:15:14,330
trapdoor and the key and the trapdoor is

366
00:15:11,960 --> 00:15:16,100
going to be just a uniform integer in CP

367
00:15:14,330 --> 00:15:18,920
which are which were going to denote a

368
00:15:16,100 --> 00:15:20,450
by T here and he's going to generate the

369
00:15:18,920 --> 00:15:22,069
key as follows he's going to take the

370
00:15:20,450 --> 00:15:24,230
matrix from the public parameters and

371
00:15:22,070 --> 00:15:26,780
he's going to raise every group element

372
00:15:24,230 --> 00:15:28,970
there to the power of T the trapdoor and

373
00:15:26,780 --> 00:15:30,410
then he's going to go to the bottom

374
00:15:28,970 --> 00:15:33,350
element at the earth column and

375
00:15:30,410 --> 00:15:36,530
multiplied by G so the key looks like

376
00:15:33,350 --> 00:15:38,800
that and we're going to denote the group

377
00:15:36,530 --> 00:15:43,540
elements there by the G Childers

378
00:15:38,800 --> 00:15:46,118
and under the DTH assumption we can show

379
00:15:43,540 --> 00:15:48,129
that the G til does they look like

380
00:15:46,119 --> 00:15:50,319
uniform metrics even given the public

381
00:15:48,129 --> 00:15:55,899
parameters and therefore they hide the

382
00:15:50,319 --> 00:15:57,368
value of I from Alice so now I want to

383
00:15:55,899 --> 00:15:59,889
show you how Alice can compute a hint

384
00:15:57,369 --> 00:16:02,679
that will eventually let Bob recover X I

385
00:15:59,889 --> 00:16:04,629
and the way she's going to do it is very

386
00:16:02,679 --> 00:16:06,639
similar to the way she computed the hash

387
00:16:04,629 --> 00:16:09,269
before except now she's going to use the

388
00:16:06,639 --> 00:16:11,829
did that util does rather than the AG's

389
00:16:09,269 --> 00:16:14,230
so again she's going to go over the

390
00:16:11,829 --> 00:16:16,269
matrix and take the corresponding group

391
00:16:14,230 --> 00:16:18,459
element from every column she's going to

392
00:16:16,269 --> 00:16:22,329
multiply everything and get this a group

393
00:16:18,459 --> 00:16:26,170
element which is the hint e so again we

394
00:16:22,329 --> 00:16:27,699
define it as this product and we can

395
00:16:26,170 --> 00:16:30,339
already analyze the rate of this

396
00:16:27,699 --> 00:16:32,649
construction so again we define the rate

397
00:16:30,339 --> 00:16:35,139
as the inverse of the length of the hand

398
00:16:32,649 --> 00:16:36,670
and we know that if we wanted a security

399
00:16:35,139 --> 00:16:38,499
from the edge then the length of the

400
00:16:36,670 --> 00:16:40,628
hint has to be proportional to the

401
00:16:38,499 --> 00:16:44,079
security parameters so roughly speaking

402
00:16:40,629 --> 00:16:47,850
that the rate of this construction is

403
00:16:44,079 --> 00:16:50,769
going to be 1 over lambda okay so now

404
00:16:47,850 --> 00:16:53,019
Alice sends the hint to Bob and also

405
00:16:50,769 --> 00:16:56,439
means to show you is how Bob given the

406
00:16:53,019 --> 00:16:59,740
hash age the hint e and the trapdoor can

407
00:16:56,439 --> 00:17:01,540
be covered the value of x I and I claim

408
00:16:59,740 --> 00:17:04,839
that all Bob has to do is to compare

409
00:17:01,540 --> 00:17:10,500
eetu H to the T and H to the T times G

410
00:17:04,839 --> 00:17:12,730
and and Bob can learn the value of x I

411
00:17:10,500 --> 00:17:15,039
according to this comparison so if E is

412
00:17:12,730 --> 00:17:17,199
equal to H to the T Bob can conclude

413
00:17:15,039 --> 00:17:20,199
that X is 0 and otherwise he can learn

414
00:17:17,199 --> 00:17:21,459
that X is actually 1 and I'm going to

415
00:17:20,199 --> 00:17:24,549
convince you now why this is actually

416
00:17:21,459 --> 00:17:28,870
true so let's assume for now that we

417
00:17:24,549 --> 00:17:31,450
define the detail does as the teeth

418
00:17:28,870 --> 00:17:34,090
power of the group the public group

419
00:17:31,450 --> 00:17:36,580
elements so if the G tilde are defined

420
00:17:34,090 --> 00:17:39,100
this way then it's easy to see that the

421
00:17:36,580 --> 00:17:43,110
hint is going to be equal to H to the T

422
00:17:39,100 --> 00:17:45,399
in all cases right we just multiply the

423
00:17:43,110 --> 00:17:48,250
same group elements raised to the power

424
00:17:45,399 --> 00:17:49,629
of T but in our construction we do

425
00:17:48,250 --> 00:17:52,030
something a bit different we actually

426
00:17:49,630 --> 00:17:54,730
multiply G tilde 1 by

427
00:17:52,030 --> 00:17:56,470
after of G and now notice that the hash

428
00:17:54,730 --> 00:17:59,530
value is still computed as before but

429
00:17:56,470 --> 00:18:02,830
the hint e now depends on whether we use

430
00:17:59,530 --> 00:18:05,170
the group element to detail the I 0 or

431
00:18:02,830 --> 00:18:07,570
we used due to the I 1 in our

432
00:18:05,170 --> 00:18:09,100
computation of the hint and this depends

433
00:18:07,570 --> 00:18:12,189
of course on the ithe bit of the

434
00:18:09,100 --> 00:18:13,719
database X so notice that if x is 0 then

435
00:18:12,190 --> 00:18:15,790
we don't we're not going to take this G

436
00:18:13,720 --> 00:18:18,850
factor and if X is 1 we're going to

437
00:18:15,790 --> 00:18:20,830
actually take it and therefore the the

438
00:18:18,850 --> 00:18:24,780
element E is going to be always equal to

439
00:18:20,830 --> 00:18:29,020
H to the T multiplied by G to the X I I

440
00:18:24,780 --> 00:18:30,910
hope I convinced you so this is our time

441
00:18:29,020 --> 00:18:34,030
to hash a construction formed from the

442
00:18:30,910 --> 00:18:35,560
edge but I promise to an optimal rate

443
00:18:34,030 --> 00:18:37,629
construction and this is clearly not an

444
00:18:35,560 --> 00:18:39,780
optimal construction because the rate

445
00:18:37,630 --> 00:18:42,130
here is 1 over lambda like I said so

446
00:18:39,780 --> 00:18:44,139
what I'm going to show you next or at

447
00:18:42,130 --> 00:18:47,320
least explain high level how to optimize

448
00:18:44,140 --> 00:18:53,800
the rate of this construction and get a

449
00:18:47,320 --> 00:18:56,889
rate 1 a trapdoor hash good so the our

450
00:18:53,800 --> 00:18:58,629
goal essentially is to take this hint

451
00:18:56,890 --> 00:19:01,570
which is a group element and compress it

452
00:18:58,630 --> 00:19:06,190
to a single bit if we do that we get a

453
00:19:01,570 --> 00:19:09,100
rate 1 trapdoor hash but to to keep the

454
00:19:06,190 --> 00:19:11,080
construction correct we have to be able

455
00:19:09,100 --> 00:19:13,090
to distinct between the compression of H

456
00:19:11,080 --> 00:19:14,919
to the T and the compression of H to the

457
00:19:13,090 --> 00:19:16,629
T times G because otherwise Bob will not

458
00:19:14,920 --> 00:19:19,750
be able to make the comparison and

459
00:19:16,630 --> 00:19:22,810
during the value of x time so we want

460
00:19:19,750 --> 00:19:24,430
some encoding to a single bit that will

461
00:19:22,810 --> 00:19:27,639
distinct between these two values and

462
00:19:24,430 --> 00:19:29,530
the very natural candidate is to take

463
00:19:27,640 --> 00:19:31,570
the back the parity of the district that

464
00:19:29,530 --> 00:19:33,879
discrete log of the hint because notice

465
00:19:31,570 --> 00:19:36,399
that the discrete log of H to the T

466
00:19:33,880 --> 00:19:38,590
times G and H to the T it always D first

467
00:19:36,400 --> 00:19:41,350
by 1 and therefore the parity will

468
00:19:38,590 --> 00:19:43,000
always be different however if we could

469
00:19:41,350 --> 00:19:44,980
actually compute discrete log we could

470
00:19:43,000 --> 00:19:49,030
also break the security of the scheme so

471
00:19:44,980 --> 00:19:51,460
this is inefficient obviously so the

472
00:19:49,030 --> 00:19:53,500
alternative to the to this is to use a

473
00:19:51,460 --> 00:19:55,360
very useful tool called distributed

474
00:19:53,500 --> 00:19:56,110
discrete log which was first introduced

475
00:19:55,360 --> 00:19:59,800
by BGI

476
00:19:56,110 --> 00:20:01,030
in a totally different context and the

477
00:19:59,800 --> 00:20:02,950
suti discrete log is actually an

478
00:20:01,030 --> 00:20:06,180
efficient algorithm but it still

479
00:20:02,950 --> 00:20:08,460
satisfies the property we need so

480
00:20:06,180 --> 00:20:12,030
what we essentially need is that if two

481
00:20:08,460 --> 00:20:16,350
group elements have discrete log that

482
00:20:12,030 --> 00:20:18,930
the first by one by one then the their

483
00:20:16,350 --> 00:20:21,439
encoding is going to be different so so

484
00:20:18,930 --> 00:20:23,700
the encoding that we're going to use is

485
00:20:21,440 --> 00:20:26,130
we're just going to take the parity of

486
00:20:23,700 --> 00:20:28,560
the distributed discrete log of our

487
00:20:26,130 --> 00:20:30,030
group element and distributed the siglo

488
00:20:28,560 --> 00:20:34,379
discrete world again satisfies this

489
00:20:30,030 --> 00:20:36,750
property and will and will give us this

490
00:20:34,380 --> 00:20:41,580
inequality which we need for secure for

491
00:20:36,750 --> 00:20:43,710
correctness okay so with the time I have

492
00:20:41,580 --> 00:20:46,199
left I'm just gonna give you some open

493
00:20:43,710 --> 00:20:48,120
questions so again to conclude we

494
00:20:46,200 --> 00:20:50,760
introduced this new primitive it's very

495
00:20:48,120 --> 00:20:52,709
simple and easy to realize using many

496
00:20:50,760 --> 00:20:55,230
standard assumptions but on the other

497
00:20:52,710 --> 00:21:00,270
hand it's super powerful we get lots of

498
00:20:55,230 --> 00:21:02,340
new stuff we couldn't get before and so

499
00:21:00,270 --> 00:21:05,010
we will show the applications in two

500
00:21:02,340 --> 00:21:09,449
scenarios and one can ask lots of

501
00:21:05,010 --> 00:21:11,220
interesting interesting questions and I

502
00:21:09,450 --> 00:21:13,380
think the more important question we can

503
00:21:11,220 --> 00:21:17,180
ask is whether these techniques and this

504
00:21:13,380 --> 00:21:20,220
primitive can be used to get other stuff

505
00:21:17,180 --> 00:21:27,690
yes thanks for listening

506
00:21:20,220 --> 00:21:30,609
[Applause]

507
00:21:27,690 --> 00:21:33,070
so wait time for a brief question and

508
00:21:30,609 --> 00:21:37,869
the next speaker please come to the

509
00:21:33,070 --> 00:21:39,939
podium in the mean time so there are no

510
00:21:37,869 --> 00:21:42,009
questions from the audience and asking

511
00:21:39,940 --> 00:21:46,200
questions om you know I'm fine with

512
00:21:42,009 --> 00:21:49,359
lattice assumptions and lwe but so right

513
00:21:46,200 --> 00:21:53,320
can be a critical issue in practice from

514
00:21:49,359 --> 00:21:56,080
an efficiency point of view so are these

515
00:21:53,320 --> 00:22:00,399
techniques to reduce the rate something

516
00:21:56,080 --> 00:22:02,918
is potentially interesting also in terms

517
00:22:00,399 --> 00:22:05,008
of practical performance schemes so we

518
00:22:02,919 --> 00:22:09,970
get communication that's like really

519
00:22:05,009 --> 00:22:13,479
really tight that's really so the so we

520
00:22:09,970 --> 00:22:16,359
get rate one but the the extra a bunch

521
00:22:13,479 --> 00:22:18,190
of bits that we pay are actually they're

522
00:22:16,359 --> 00:22:20,080
actually fuel and manifold constructions

523
00:22:18,190 --> 00:22:25,269
I'm not sure I can say that the

524
00:22:20,080 --> 00:22:27,279
computational complexity can match the

525
00:22:25,269 --> 00:22:30,309
practical requirements but speaking of

526
00:22:27,279 --> 00:22:31,840
the communication which is already good

527
00:22:30,309 --> 00:22:33,519
but you think there is potential for

528
00:22:31,840 --> 00:22:35,789
these techniques to lead also to

529
00:22:33,519 --> 00:22:39,009
something that people may want to do

530
00:22:35,789 --> 00:22:41,349
it's a good question we'll have to think

531
00:22:39,009 --> 00:22:42,070
about it okay so let's thank the speaker

532
00:22:41,349 --> 00:22:46,139
again

533
00:22:42,070 --> 00:22:46,139
[Applause]

