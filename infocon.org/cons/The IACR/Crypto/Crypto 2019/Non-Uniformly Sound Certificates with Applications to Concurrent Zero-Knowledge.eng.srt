1
00:00:04,850 --> 00:00:08,480
so my name is Cody Freitag today we'll

2
00:00:07,160 --> 00:00:10,639
be talking about non-uniform sound

3
00:00:08,480 --> 00:00:13,790
certificates and their applications to

4
00:00:10,639 --> 00:00:15,079
concurrency or knowledge so to motivate

5
00:00:13,790 --> 00:00:16,308
this notion of non uniformly sound

6
00:00:15,080 --> 00:00:19,070
certificates I want to start with the

7
00:00:16,309 --> 00:00:20,510
problem of computational delegation so

8
00:00:19,070 --> 00:00:23,480
this is the setting where we have some

9
00:00:20,510 --> 00:00:26,029
say programmer Bob who wants to compute

10
00:00:23,480 --> 00:00:28,070
some function but this function is the

11
00:00:26,029 --> 00:00:30,140
kind of an expensive polynomial time to

12
00:00:28,070 --> 00:00:32,659
mean computation so he wants to

13
00:00:30,140 --> 00:00:33,080
outsource it to the cloud so what he

14
00:00:32,659 --> 00:00:34,760
does

15
00:00:33,080 --> 00:00:37,849
he asked the cloud to compute this

16
00:00:34,760 --> 00:00:39,468
machine M on some input X and he gets

17
00:00:37,850 --> 00:00:41,480
and the cloud computes some output Y

18
00:00:39,469 --> 00:00:43,629
which it then returns back to the

19
00:00:41,480 --> 00:00:45,410
programmer as well as this proof PI

20
00:00:43,629 --> 00:00:48,079
certifying the correctness of the

21
00:00:45,410 --> 00:00:49,190
computation and the idea here is that

22
00:00:48,079 --> 00:00:52,399
the proof should be short and

23
00:00:49,190 --> 00:00:53,870
efficiently verifiable otherwise the

24
00:00:52,399 --> 00:00:55,879
programmer could have just computed this

25
00:00:53,870 --> 00:00:57,169
function on his computer himself and

26
00:00:55,879 --> 00:01:00,680
figured out the output so we want this

27
00:00:57,170 --> 00:01:02,090
kind of proof to be as efficient in much

28
00:01:00,680 --> 00:01:04,640
less time than to compute the function

29
00:01:02,090 --> 00:01:06,770
itself and you can ask the same question

30
00:01:04,640 --> 00:01:08,810
for NP as well so here you have some

31
00:01:06,770 --> 00:01:10,280
non-deterministic computation and maybe

32
00:01:08,810 --> 00:01:12,799
we want to know does there exist some

33
00:01:10,280 --> 00:01:15,009
witness that causes the verification

34
00:01:12,799 --> 00:01:17,540
circuit for the language to output one

35
00:01:15,009 --> 00:01:19,810
and so in the same setting you want to

36
00:01:17,540 --> 00:01:22,430
proof that's kind of much more efficient

37
00:01:19,810 --> 00:01:25,340
that says that there exists some witness

38
00:01:22,430 --> 00:01:27,229
causing machine to accept and here the

39
00:01:25,340 --> 00:01:29,390
witness can be even as large as the

40
00:01:27,229 --> 00:01:30,650
running time of the machine because each

41
00:01:29,390 --> 00:01:32,420
kind of step of the machine it could

42
00:01:30,650 --> 00:01:37,220
make some different non-deterministic

43
00:01:32,420 --> 00:01:39,409
choice so to get this to satisfy the

44
00:01:37,220 --> 00:01:42,380
efficiency requirements of this protocol

45
00:01:39,409 --> 00:01:44,509
we can use succinct arguments which were

46
00:01:42,380 --> 00:01:47,570
developed by Killian and then later by

47
00:01:44,509 --> 00:01:49,579
Brock and goldrock in 2002 where you

48
00:01:47,570 --> 00:01:52,070
have some prove ER talks to a verifier

49
00:01:49,579 --> 00:01:54,529
and a certain number of rounds of

50
00:01:52,070 --> 00:01:56,570
interaction to the whether or not some

51
00:01:54,530 --> 00:01:57,920
statement is in a language and we

52
00:01:56,570 --> 00:02:00,408
require kind of the three standard

53
00:01:57,920 --> 00:02:02,000
properties or so first its completeness

54
00:02:00,409 --> 00:02:04,130
so if the statement is in the language

55
00:02:02,000 --> 00:02:06,200
then an efficient provers to be able to

56
00:02:04,130 --> 00:02:08,090
convince the verifier we require a

57
00:02:06,200 --> 00:02:10,130
computational notion of soundness so the

58
00:02:08,090 --> 00:02:12,230
statement is not in the language then no

59
00:02:10,130 --> 00:02:13,579
non uniform kind of efficient attacker

60
00:02:12,230 --> 00:02:16,579
should be able to convince the verifier

61
00:02:13,580 --> 00:02:18,620
and then lastly is the sync Ness so the

62
00:02:16,580 --> 00:02:20,540
communication in this protocol should

63
00:02:18,620 --> 00:02:22,430
the poly logarithmic so almost

64
00:02:20,540 --> 00:02:25,459
independent of the size of the statement

65
00:02:22,430 --> 00:02:27,860
and the size of the witness so what is

66
00:02:25,459 --> 00:02:30,500
this and assuming just collision

67
00:02:27,860 --> 00:02:32,420
resistance Killian and then later Brock

68
00:02:30,500 --> 00:02:33,950
and goal-directed 2002 show that

69
00:02:32,420 --> 00:02:36,530
assuming corrosion resistance there

70
00:02:33,950 --> 00:02:38,929
exists distinct Universal arguments for

71
00:02:36,530 --> 00:02:40,519
all of NP this universality means that

72
00:02:38,930 --> 00:02:42,980
there's one protocol that works for any

73
00:02:40,519 --> 00:02:45,560
NP language and so what does this look

74
00:02:42,980 --> 00:02:48,409
like for this delegation problem

75
00:02:45,560 --> 00:02:51,530
well now the server and the programmer

76
00:02:48,409 --> 00:02:53,569
can interact through a number of rounds

77
00:02:51,530 --> 00:02:57,829
and the programmer will be convinced

78
00:02:53,569 --> 00:02:59,780
that the statement is correct but the

79
00:02:57,829 --> 00:03:01,910
problem with the setting is if there's

80
00:02:59,780 --> 00:03:03,310
another person who comes along and also

81
00:03:01,910 --> 00:03:06,920
wants to be convinced of this statement

82
00:03:03,310 --> 00:03:08,569
say she asked the programmer Bob what

83
00:03:06,920 --> 00:03:10,369
the result is Bob's not able to just

84
00:03:08,569 --> 00:03:12,048
forward this proof over she would have

85
00:03:10,370 --> 00:03:15,230
to kind of ask the server to redo the

86
00:03:12,049 --> 00:03:18,109
computation maybe redo this interaction

87
00:03:15,230 --> 00:03:20,209
with the server and so ideally what we

88
00:03:18,109 --> 00:03:22,910
want is succinct non interactive

89
00:03:20,209 --> 00:03:24,950
arguments where the prover just can the

90
00:03:22,910 --> 00:03:26,389
provers message to the verifier or the

91
00:03:24,950 --> 00:03:28,849
Pervis communication the verifier is

92
00:03:26,389 --> 00:03:30,769
just a single message which we'll call

93
00:03:28,849 --> 00:03:32,780
the proof pie which should convince the

94
00:03:30,769 --> 00:03:34,700
verifier still satisfying the same

95
00:03:32,780 --> 00:03:39,109
notion of completeness soundness and

96
00:03:34,700 --> 00:03:40,849
succinct Ness so in the setting now the

97
00:03:39,109 --> 00:03:44,900
programmer is able to just send a proof

98
00:03:40,849 --> 00:03:47,238
over to Alice and she'll be convinced so

99
00:03:44,900 --> 00:03:50,060
the question we ask in this work is can

100
00:03:47,239 --> 00:03:52,510
these kind of ideal objects the sink

101
00:03:50,060 --> 00:03:54,829
nonreactive arguments actually exist and

102
00:03:52,510 --> 00:03:56,239
the problem is that this notion of

103
00:03:54,829 --> 00:03:58,660
computational soundness that we want to

104
00:03:56,239 --> 00:04:01,609
achieve actually collapses to

105
00:03:58,660 --> 00:04:03,739
statistical soundness where we're saying

106
00:04:01,609 --> 00:04:06,470
if any computationally unbounded prover

107
00:04:03,739 --> 00:04:08,569
can find a false proof that convinces a

108
00:04:06,470 --> 00:04:12,049
verifier of a statement that's not in

109
00:04:08,569 --> 00:04:13,578
the language so this notion of

110
00:04:12,049 --> 00:04:15,919
statistical soundness is the question of

111
00:04:13,579 --> 00:04:18,019
does there exist such a false proof so

112
00:04:15,919 --> 00:04:20,150
if there does exist such a false proof

113
00:04:18,019 --> 00:04:22,099
and statistics on us is broken then a

114
00:04:20,149 --> 00:04:23,630
non uniform adversary can just receive

115
00:04:22,099 --> 00:04:26,030
this accepting proof or a false

116
00:04:23,630 --> 00:04:28,280
statement hard-coded into its advice and

117
00:04:26,030 --> 00:04:29,900
so because it can receive this cheating

118
00:04:28,280 --> 00:04:32,799
proof this would just break the notion

119
00:04:29,900 --> 00:04:32,799
of computational soundness

120
00:04:35,830 --> 00:04:40,669
so the question is can these

121
00:04:38,599 --> 00:04:41,240
statistically sound protocols actually

122
00:04:40,669 --> 00:04:43,758
exist

123
00:04:41,240 --> 00:04:46,520
and unfortunately for NP languages the

124
00:04:43,759 --> 00:04:48,349
answer is no assuming at least the NP

125
00:04:46,520 --> 00:04:51,438
can't be decided in sub exponential time

126
00:04:48,349 --> 00:04:52,938
and then even for P we have kind of the

127
00:04:51,439 --> 00:04:55,360
same negative results that given

128
00:04:52,939 --> 00:04:59,479
standard D randomization assumptions

129
00:04:55,360 --> 00:05:01,939
this notion is impossible to achieve so

130
00:04:59,479 --> 00:05:04,370
one way around this is to introduce like

131
00:05:01,939 --> 00:05:06,289
a trusted set up in the sky which could

132
00:05:04,370 --> 00:05:08,210
be some structured set up with a common

133
00:05:06,289 --> 00:05:10,729
reference string or unstructured set up

134
00:05:08,210 --> 00:05:13,580
with a common random string which this

135
00:05:10,729 --> 00:05:18,169
notion we usually refer to as snarks

136
00:05:13,580 --> 00:05:20,180
and Macaulay in 1994 showed with his

137
00:05:18,169 --> 00:05:21,740
computationally sound proofs that this

138
00:05:20,180 --> 00:05:23,659
notion is actually possible in the

139
00:05:21,740 --> 00:05:27,620
random Oracle model assuming just an

140
00:05:23,659 --> 00:05:29,719
unstructured common random string and

141
00:05:27,620 --> 00:05:31,129
then because this notion is so useful

142
00:05:29,719 --> 00:05:33,020
and has so many applications in so many

143
00:05:31,129 --> 00:05:35,000
areas there are many more practical

144
00:05:33,020 --> 00:05:38,870
constructions assuming either structured

145
00:05:35,000 --> 00:05:40,490
or unstructured set up but the problem

146
00:05:38,870 --> 00:05:42,139
in all of these scenarios is that the

147
00:05:40,490 --> 00:05:43,759
trust the set up needs to be trusted in

148
00:05:42,139 --> 00:05:45,740
some way although it could have been

149
00:05:43,759 --> 00:05:48,800
adversarially generated in a way that

150
00:05:45,740 --> 00:05:50,659
could introduce a trapdoor so what we

151
00:05:48,800 --> 00:05:53,560
really want is some way to get a

152
00:05:50,659 --> 00:05:56,330
guarantee without any possible set up

153
00:05:53,560 --> 00:05:58,159
where recall we want the soundness even

154
00:05:56,330 --> 00:06:00,199
against non uniform attackers but from

155
00:05:58,159 --> 00:06:01,460
what I said before it seems that we must

156
00:06:00,199 --> 00:06:02,779
be out of luck because this is

157
00:06:01,460 --> 00:06:07,460
equivalent to statistical soundness

158
00:06:02,779 --> 00:06:09,229
which we think is impossible so another

159
00:06:07,460 --> 00:06:11,568
way around this was considered by Chun

160
00:06:09,229 --> 00:06:13,430
Lin and passed in 2013 by the name of

161
00:06:11,569 --> 00:06:17,270
certificates which are snogs without any

162
00:06:13,430 --> 00:06:18,860
setup but they realized that we can't

163
00:06:17,270 --> 00:06:20,719
hope for non-uniform soundness but at

164
00:06:18,860 --> 00:06:22,789
least this can be achieved for uniform

165
00:06:20,719 --> 00:06:24,889
soundness where again this is just the

166
00:06:22,789 --> 00:06:27,259
same notion where a statement not in the

167
00:06:24,889 --> 00:06:29,180
language no uniform polynomial time

168
00:06:27,259 --> 00:06:32,560
attacker can convince the verifier and

169
00:06:29,180 --> 00:06:34,759
the idea here is that because this

170
00:06:32,560 --> 00:06:37,039
attacker is kind of a constant size

171
00:06:34,759 --> 00:06:38,419
Turing machine you can think of it

172
00:06:37,039 --> 00:06:40,990
doesn't have the ability to hard-code

173
00:06:38,419 --> 00:06:44,448
these false proofs even if they exist

174
00:06:40,990 --> 00:06:45,620
and so they observe in this work the

175
00:06:44,449 --> 00:06:48,050
Macaulay CS proof

176
00:06:45,620 --> 00:06:51,470
actually does satisfy this notion in the

177
00:06:48,050 --> 00:06:53,360
random Oracle model but there's a reason

178
00:06:51,470 --> 00:06:56,120
that non-uniform security has kind of

179
00:06:53,360 --> 00:06:58,040
become the de facto standard in our

180
00:06:56,120 --> 00:07:00,890
community because it captures kind of

181
00:06:58,040 --> 00:07:03,770
targeted pre-processing phase any

182
00:07:00,890 --> 00:07:05,570
unknown future attack or arbitrary kind

183
00:07:03,770 --> 00:07:08,930
of side information you may have before

184
00:07:05,570 --> 00:07:10,490
the protocol started one such example is

185
00:07:08,930 --> 00:07:13,820
with rainbow tables where you can kind

186
00:07:10,490 --> 00:07:16,760
of spend a long time computing a large

187
00:07:13,820 --> 00:07:18,140
pre-computation puted table to attack

188
00:07:16,760 --> 00:07:21,440
specific instances of a hash function

189
00:07:18,140 --> 00:07:23,060
and in the random Oracle model we can

190
00:07:21,440 --> 00:07:24,800
consider kind of a similar notion of

191
00:07:23,060 --> 00:07:26,720
non-uniform security where you have an

192
00:07:24,800 --> 00:07:28,790
unbounded pre-processing of the random

193
00:07:26,720 --> 00:07:30,650
Oracle as long as the resulting output

194
00:07:28,790 --> 00:07:32,540
that you get whenever you're kind of

195
00:07:30,650 --> 00:07:34,400
performing the attack has bounded size

196
00:07:32,540 --> 00:07:35,930
and so this model is known as the

197
00:07:34,400 --> 00:07:38,570
exhibit input random Oracle model and

198
00:07:35,930 --> 00:07:42,920
was introduced and formalized by Unruh

199
00:07:38,570 --> 00:07:45,530
in 2008 so in this work we're asking the

200
00:07:42,920 --> 00:07:46,790
question in this setting where we want

201
00:07:45,530 --> 00:07:48,559
to sink non-interactive arguments

202
00:07:46,790 --> 00:07:49,840
without any setup what's the best

203
00:07:48,560 --> 00:07:54,560
possible soundness we could hope for

204
00:07:49,840 --> 00:07:57,409
against non universe against non uniform

205
00:07:54,560 --> 00:07:59,330
attackers and so the first thing to note

206
00:07:57,410 --> 00:08:00,590
is that there's kind of this trivial

207
00:07:59,330 --> 00:08:02,479
attack which is similar to what I

208
00:08:00,590 --> 00:08:04,669
described before so if your proof length

209
00:08:02,480 --> 00:08:06,890
this size you then you can just hard

210
00:08:04,670 --> 00:08:08,900
code s over you different accepting

211
00:08:06,890 --> 00:08:13,640
proofs for false statement directly into

212
00:08:08,900 --> 00:08:15,890
your advice so what we want is to say

213
00:08:13,640 --> 00:08:18,320
that the no adversary can do any better

214
00:08:15,890 --> 00:08:20,630
so an attacker with some fixed amount of

215
00:08:18,320 --> 00:08:23,150
s bits of advice can't find more than a

216
00:08:20,630 --> 00:08:26,750
polynomial in s number of accepting

217
00:08:23,150 --> 00:08:29,120
proofs for false statements so this is

218
00:08:26,750 --> 00:08:31,070
very similar to a recent notion of

219
00:08:29,120 --> 00:08:32,390
Heelys multi collision resistance where

220
00:08:31,070 --> 00:08:34,309
they're asking the same question about

221
00:08:32,390 --> 00:08:36,080
can you guarantee you can't find more

222
00:08:34,309 --> 00:08:38,209
collisions in your than the size of your

223
00:08:36,080 --> 00:08:40,610
advice and also a similar soundness

224
00:08:38,210 --> 00:08:42,890
notion was used in this work by baton

225
00:08:40,610 --> 00:08:46,340
ski and Lin in 2018 for one message

226
00:08:42,890 --> 00:08:47,569
during knowledge so just to recap this

227
00:08:46,340 --> 00:08:50,270
notion of non uniformly sound

228
00:08:47,570 --> 00:08:51,980
certificates we require completeness and

229
00:08:50,270 --> 00:08:54,079
succinct Ness and also this best

230
00:08:51,980 --> 00:08:57,200
possible soundness notion against non

231
00:08:54,080 --> 00:08:58,670
uniform attackers before moving on I

232
00:08:57,200 --> 00:08:59,510
want to kind of look at this problem

233
00:08:58,670 --> 00:09:02,510
through a

234
00:08:59,510 --> 00:09:06,290
lenz so the question of can we compress

235
00:09:02,510 --> 00:09:08,680
and P witnesses so completeness says

236
00:09:06,290 --> 00:09:11,329
that valid statements should still be

237
00:09:08,680 --> 00:09:13,849
verified even with a very short proof

238
00:09:11,330 --> 00:09:16,160
only poly logarithmic in the size of the

239
00:09:13,850 --> 00:09:18,410
witness and then this best possible

240
00:09:16,160 --> 00:09:19,819
soundness notion translates into this

241
00:09:18,410 --> 00:09:22,640
kind of question of computational

242
00:09:19,820 --> 00:09:26,090
Kolmogorov complexity of large sets of

243
00:09:22,640 --> 00:09:27,740
cheating proofs in other words if a

244
00:09:26,090 --> 00:09:29,480
large set of cheating proofs could be

245
00:09:27,740 --> 00:09:32,000
compressed in a way that could be easily

246
00:09:29,480 --> 00:09:33,710
decompressed easily and efficiently

247
00:09:32,000 --> 00:09:36,950
decompressed then a non uniform

248
00:09:33,710 --> 00:09:38,420
adversary could receive kind of this

249
00:09:36,950 --> 00:09:40,580
compressed version of a large set of

250
00:09:38,420 --> 00:09:43,640
cheating proofs in its advice and then

251
00:09:40,580 --> 00:09:45,740
efficiently decompress this to break

252
00:09:43,640 --> 00:09:47,540
this best possible soundness so really

253
00:09:45,740 --> 00:09:49,940
kind of these notion of non uniformly

254
00:09:47,540 --> 00:09:51,620
signed certificates can be seen through

255
00:09:49,940 --> 00:09:54,230
this kind of complexity theoretic

256
00:09:51,620 --> 00:09:58,520
language of can we compress NP witnesses

257
00:09:54,230 --> 00:10:00,800
in a meaningful way so what we achieve

258
00:09:58,520 --> 00:10:02,480
in this work well first we observe that

259
00:10:00,800 --> 00:10:04,760
the known candidates of snogs without

260
00:10:02,480 --> 00:10:07,420
setup for example Macaulay si s proofs

261
00:10:04,760 --> 00:10:09,920
do not achieve best possible soundness

262
00:10:07,420 --> 00:10:11,959
in the case Macaulay si s proofs in the

263
00:10:09,920 --> 00:10:13,219
auxiliary input random Oracle where the

264
00:10:11,960 --> 00:10:15,980
advice is allowed to depend on the

265
00:10:13,220 --> 00:10:17,300
random Oracle specifically we show that

266
00:10:15,980 --> 00:10:19,520
with just a small amount of non uniform

267
00:10:17,300 --> 00:10:22,150
advice this can be used to generate an

268
00:10:19,520 --> 00:10:24,949
exponential number of false proofs

269
00:10:22,150 --> 00:10:26,569
however all is not lost because we show

270
00:10:24,950 --> 00:10:28,610
in the exhilarating put random work

271
00:10:26,570 --> 00:10:31,030
model there actually do exist non your

272
00:10:28,610 --> 00:10:33,050
formally sound certificates for NP and

273
00:10:31,030 --> 00:10:35,990
we show that these are actually useful

274
00:10:33,050 --> 00:10:37,520
so as our main application we show how

275
00:10:35,990 --> 00:10:39,920
to construct constant around concurrency

276
00:10:37,520 --> 00:10:43,010
row knowledge from these primitives so

277
00:10:39,920 --> 00:10:45,890
for the next bit I will talk about this

278
00:10:43,010 --> 00:10:47,660
application to zero knowledge so let's

279
00:10:45,890 --> 00:10:48,740
just recall real quick in zero knowledge

280
00:10:47,660 --> 00:10:50,959
you have two parties that are

281
00:10:48,740 --> 00:10:52,310
interacting approving a verifier and the

282
00:10:50,960 --> 00:10:54,110
provers should be able to convince the

283
00:10:52,310 --> 00:10:55,160
verifier that the statement is in the

284
00:10:54,110 --> 00:10:57,140
language while we're feeling nothing

285
00:10:55,160 --> 00:10:59,810
else so even if the verifier is

286
00:10:57,140 --> 00:11:01,280
adversary adversarial and is trying to

287
00:10:59,810 --> 00:11:04,849
extract some information from the vet

288
00:11:01,280 --> 00:11:06,709
from the prover it should fail in the

289
00:11:04,850 --> 00:11:08,420
state of affairs zero knowledge has kind

290
00:11:06,710 --> 00:11:10,210
of been well known at least from a

291
00:11:08,420 --> 00:11:12,620
theoretical perspective for a long time

292
00:11:10,210 --> 00:11:13,130
because just from one way functions

293
00:11:12,620 --> 00:11:14,960
we've known

294
00:11:13,130 --> 00:11:16,970
how to construct constant around zero

295
00:11:14,960 --> 00:11:18,640
knowledge arguments for all of NP for

296
00:11:16,970 --> 00:11:21,380
almost 30 years now

297
00:11:18,640 --> 00:11:23,449
however the such situation is a bit more

298
00:11:21,380 --> 00:11:24,770
messy in this concurrent setting where

299
00:11:23,450 --> 00:11:26,840
maybe you have many verifiers

300
00:11:24,770 --> 00:11:29,449
interacting with many provers in this

301
00:11:26,840 --> 00:11:31,460
distributed complicated fashion we want

302
00:11:29,450 --> 00:11:34,010
to guarantee still that even if all the

303
00:11:31,460 --> 00:11:35,900
verifiers are colluding trying to

304
00:11:34,010 --> 00:11:38,330
extract information from possibly many

305
00:11:35,900 --> 00:11:41,329
independent provers that they'll still

306
00:11:38,330 --> 00:11:43,730
not be able to learn anything extra and

307
00:11:41,330 --> 00:11:46,010
kind of the holy grail problem in this

308
00:11:43,730 --> 00:11:47,900
area has been to construct constant

309
00:11:46,010 --> 00:11:50,900
round zero knowledge protocols with this

310
00:11:47,900 --> 00:11:52,550
conditional concurrent security and up

311
00:11:50,900 --> 00:11:55,100
until very recently not much has been

312
00:11:52,550 --> 00:11:57,079
known and then in 2015 there were some

313
00:11:55,100 --> 00:11:58,610
recent constructions based on

314
00:11:57,080 --> 00:12:02,240
obfuscation specifically in

315
00:11:58,610 --> 00:12:04,520
distinguishability obfuscation and so in

316
00:12:02,240 --> 00:12:06,200
this work we show that given non

317
00:12:04,520 --> 00:12:08,600
uniformly sound certificates for P as

318
00:12:06,200 --> 00:12:10,490
well as collision resistance we

319
00:12:08,600 --> 00:12:12,620
construct constant round concurrency Oh

320
00:12:10,490 --> 00:12:13,790
knowledge arguments for all event P so

321
00:12:12,620 --> 00:12:15,710
this is kind of a different flavor of

322
00:12:13,790 --> 00:12:18,410
assumption from the obfuscation type

323
00:12:15,710 --> 00:12:20,420
assumptions that were in 2015

324
00:12:18,410 --> 00:12:22,490
particular this is a kind of a random

325
00:12:20,420 --> 00:12:23,930
Oracle model type assumption at least

326
00:12:22,490 --> 00:12:28,400
given our current construction of non

327
00:12:23,930 --> 00:12:30,260
uniformly sound certificates and so just

328
00:12:28,400 --> 00:12:32,329
to contrast these two assumptions off

329
00:12:30,260 --> 00:12:34,300
eustachian kind of is still being

330
00:12:32,330 --> 00:12:37,070
studied is a relatively new primitive

331
00:12:34,300 --> 00:12:39,199
current candidates are based on kind of

332
00:12:37,070 --> 00:12:41,330
not well understood not completely well

333
00:12:39,200 --> 00:12:43,910
understood assumptions and random Oracle

334
00:12:41,330 --> 00:12:46,130
model kind of gives a more heuristic

335
00:12:43,910 --> 00:12:49,969
Elise ounds argument that can maybe be

336
00:12:46,130 --> 00:12:51,380
more practically instantiated and also I

337
00:12:49,970 --> 00:12:53,450
want to emphasize this public coin

338
00:12:51,380 --> 00:12:55,730
aspect of our protocol which wasn't

339
00:12:53,450 --> 00:12:57,740
known before under any assumptions even

340
00:12:55,730 --> 00:13:00,200
in the random Oracle model and public

341
00:12:57,740 --> 00:13:02,120
when protocols have many benefits

342
00:13:00,200 --> 00:13:04,880
whenever the verifier has no private

343
00:13:02,120 --> 00:13:07,820
state I mean is just sending random

344
00:13:04,880 --> 00:13:10,240
messages to the prover it has

345
00:13:07,820 --> 00:13:11,990
applications and leakage resilience and

346
00:13:10,240 --> 00:13:14,420
public verifiability

347
00:13:11,990 --> 00:13:18,410
and other kind of transformations to

348
00:13:14,420 --> 00:13:20,000
other protocols and kind of the last

349
00:13:18,410 --> 00:13:22,160
thing I'll say about our protocol is

350
00:13:20,000 --> 00:13:24,790
that at a high level it follows from

351
00:13:22,160 --> 00:13:26,880
this work in 2013 from chun-lin and pass

352
00:13:24,790 --> 00:13:29,040
where they they

353
00:13:26,880 --> 00:13:31,470
she've kind of a uniform notion of

354
00:13:29,040 --> 00:13:32,969
soundness because they're using kind of

355
00:13:31,470 --> 00:13:34,830
the certificates that I talked about

356
00:13:32,970 --> 00:13:36,660
before which only had kind of the

357
00:13:34,830 --> 00:13:39,170
capability of cheating uniform soundness

358
00:13:36,660 --> 00:13:41,430
and we show that with this kind of

359
00:13:39,170 --> 00:13:43,860
stronger notion of non-uniformly sound

360
00:13:41,430 --> 00:13:46,020
certificates we can improve this to get

361
00:13:43,860 --> 00:13:50,730
kind of the full notion of soundness for

362
00:13:46,020 --> 00:13:51,990
a concurrent zero knowledge protocol so

363
00:13:50,730 --> 00:13:54,060
for the rest of the talk I want to focus

364
00:13:51,990 --> 00:13:55,740
on our construction of non uniformly

365
00:13:54,060 --> 00:13:58,829
sound certificates and give kind of a

366
00:13:55,740 --> 00:14:00,450
high-level idea of how it works and what

367
00:13:58,830 --> 00:14:03,270
we kind of have to go through to

368
00:14:00,450 --> 00:14:05,640
construct these so first I want to talk

369
00:14:03,270 --> 00:14:07,680
about Macaulay SES proofs in general and

370
00:14:05,640 --> 00:14:08,730
why they don't satisfy best possible

371
00:14:07,680 --> 00:14:11,040
soundness where you can think of

372
00:14:08,730 --> 00:14:13,290
Macaulay SES proofs as applying kind of

373
00:14:11,040 --> 00:14:16,260
a Fiat Samir type transformation to kill

374
00:14:13,290 --> 00:14:18,030
Killian succinct argument and then I'll

375
00:14:16,260 --> 00:14:20,730
show how to modify this fiat ramier

376
00:14:18,030 --> 00:14:23,430
transformation so that when you apply it

377
00:14:20,730 --> 00:14:26,210
to Killians protocol it will actually

378
00:14:23,430 --> 00:14:28,589
satisfy best possible soundness

379
00:14:26,210 --> 00:14:31,830
so just to recap I want to quickly go

380
00:14:28,590 --> 00:14:33,570
over a Killian succinct argument so this

381
00:14:31,830 --> 00:14:39,290
is where the verifier first sends a

382
00:14:33,570 --> 00:14:39,290
description of a hash function okay

383
00:14:39,950 --> 00:14:45,050
the approver computes a PCP proof for

384
00:14:43,260 --> 00:14:47,550
the statement and then Merkel tree

385
00:14:45,050 --> 00:14:50,729
computes the digests using a Merkel tree

386
00:14:47,550 --> 00:14:53,280
with this hash function H sends the

387
00:14:50,730 --> 00:14:55,530
digest over the verifier responds with a

388
00:14:53,280 --> 00:14:57,420
random challenge using this random

389
00:14:55,530 --> 00:15:00,000
challenge the prover opens up the Merkel

390
00:14:57,420 --> 00:15:01,890
tree in certain locations sending them

391
00:15:00,000 --> 00:15:04,290
over to the authentication pass over to

392
00:15:01,890 --> 00:15:07,530
the verifier who verifies these openings

393
00:15:04,290 --> 00:15:09,030
and as well as the PCP proof and the

394
00:15:07,530 --> 00:15:10,620
idea is to get a certificate system out

395
00:15:09,030 --> 00:15:12,900
of this you can just apply Fiat schmear

396
00:15:10,620 --> 00:15:15,900
which is exactly what Macaulay CS proofs

397
00:15:12,900 --> 00:15:17,490
look like so here first you use the

398
00:15:15,900 --> 00:15:19,319
random Oracle to compute this Merkel

399
00:15:17,490 --> 00:15:20,910
tree and then you also use the random

400
00:15:19,320 --> 00:15:23,040
Oracle to generate the random challenge

401
00:15:20,910 --> 00:15:24,660
yourself then the verifier just checks

402
00:15:23,040 --> 00:15:27,030
as it would in the interactive case as

403
00:15:24,660 --> 00:15:30,900
well as checking the kind of correctness

404
00:15:27,030 --> 00:15:34,170
of the random challenge so how do we

405
00:15:30,900 --> 00:15:35,910
actually cheat in this protocol whenever

406
00:15:34,170 --> 00:15:38,949
you have advice that may be based on the

407
00:15:35,910 --> 00:15:41,949
random Oracle so the FIR

408
00:15:38,950 --> 00:15:44,560
step just as we saw in general you can

409
00:15:41,950 --> 00:15:46,810
just hard-code an accepting proof for

410
00:15:44,560 --> 00:15:50,920
any invalid statement you want so let's

411
00:15:46,810 --> 00:15:52,300
start with that next we can look at the

412
00:15:50,920 --> 00:15:54,400
Merkel tree that's used and we can

413
00:15:52,300 --> 00:15:56,500
actually hard code collisions at each

414
00:15:54,400 --> 00:15:59,590
leaf in the Merkel tree that leads to

415
00:15:56,500 --> 00:16:00,940
the same digest a and then we can mix

416
00:15:59,590 --> 00:16:03,760
and match these collisions to get an

417
00:16:00,940 --> 00:16:06,220
exponential number of openings so what

418
00:16:03,760 --> 00:16:08,470
this looks like is we have our PCP proof

419
00:16:06,220 --> 00:16:10,330
at the leaves of our Merkel tree if we

420
00:16:08,470 --> 00:16:12,430
open up kind of the first block into n

421
00:16:10,330 --> 00:16:13,870
different options and then with a few

422
00:16:12,430 --> 00:16:15,189
more bits we can open up the second

423
00:16:13,870 --> 00:16:17,020
block and end open up different options

424
00:16:15,190 --> 00:16:18,760
and then we can mix and match them and

425
00:16:17,020 --> 00:16:21,579
now get a quadratic number of options

426
00:16:18,760 --> 00:16:23,200
and if we continue this throughout the

427
00:16:21,580 --> 00:16:25,060
whole PCP proof we can get an

428
00:16:23,200 --> 00:16:27,340
exponential number of ways to open up to

429
00:16:25,060 --> 00:16:28,660
the same statement a which we can then

430
00:16:27,340 --> 00:16:32,800
use to cheat on many different

431
00:16:28,660 --> 00:16:35,410
statements so what's a first step to get

432
00:16:32,800 --> 00:16:38,020
away from this attack well we observe

433
00:16:35,410 --> 00:16:39,730
that if this statement is short enough

434
00:16:38,020 --> 00:16:43,449
we can actually just index the random

435
00:16:39,730 --> 00:16:44,920
Oracle by this statement so now if the

436
00:16:43,450 --> 00:16:47,110
random Oracle's indexed by the

437
00:16:44,920 --> 00:16:48,490
statements at a high level this forces

438
00:16:47,110 --> 00:16:51,040
the adversary to kind of use some

439
00:16:48,490 --> 00:16:54,390
knowledge for each new statement at

440
00:16:51,040 --> 00:16:56,589
cheats on so we formalized this idea

441
00:16:54,390 --> 00:16:58,510
with a compression argument and show

442
00:16:56,590 --> 00:17:00,520
that this resulting protocol actually

443
00:16:58,510 --> 00:17:04,329
satisfies this best possible notion of

444
00:17:00,520 --> 00:17:06,069
soundness I put forth before and the

445
00:17:04,329 --> 00:17:07,869
details are a bit messy with this

446
00:17:06,069 --> 00:17:10,208
compression argument but I want to just

447
00:17:07,869 --> 00:17:11,708
mention the kind of the reason we were

448
00:17:10,209 --> 00:17:13,990
able to do this is because we index the

449
00:17:11,709 --> 00:17:15,430
random Oracle by the statement and now

450
00:17:13,990 --> 00:17:17,949
whenever the adversary queries the

451
00:17:15,430 --> 00:17:19,240
random Oracle we can kind of use the

452
00:17:17,949 --> 00:17:23,290
fact that it must have known the

453
00:17:19,240 --> 00:17:27,000
statement at hand so how do we extend

454
00:17:23,290 --> 00:17:31,000
this to deal with long statements so as

455
00:17:27,000 --> 00:17:32,500
normal one idea is to just index the

456
00:17:31,000 --> 00:17:35,680
random Oracle with the short commitments

457
00:17:32,500 --> 00:17:37,180
to the statement and we need a way to

458
00:17:35,680 --> 00:17:38,740
guarantee that this short commitment can

459
00:17:37,180 --> 00:17:40,720
be opened in too many ways because then

460
00:17:38,740 --> 00:17:42,760
if the adversary can just cheat on the

461
00:17:40,720 --> 00:17:46,660
sort commitment and open it in different

462
00:17:42,760 --> 00:17:48,370
ways then it could then it could find

463
00:17:46,660 --> 00:17:51,250
cheating proofs for many different

464
00:17:48,370 --> 00:17:53,110
statements and for example if we just

465
00:17:51,250 --> 00:17:54,670
use a Merkel tree for the shortcoming

466
00:17:53,110 --> 00:17:56,169
then we're back to square one because we

467
00:17:54,670 --> 00:18:00,070
have the same mix-and-match attack from

468
00:17:56,170 --> 00:18:02,080
before so our solution is to first apply

469
00:18:00,070 --> 00:18:04,330
a suitable encoding and then apply the

470
00:18:02,080 --> 00:18:05,860
Merkel tree where this encoding we use

471
00:18:04,330 --> 00:18:07,770
is what's called a list recoverable code

472
00:18:05,860 --> 00:18:10,149
similar to work by komak rot scat all

473
00:18:07,770 --> 00:18:13,809
related to multi collision resistance in

474
00:18:10,150 --> 00:18:15,730
2018 and so our commitment looks like

475
00:18:13,809 --> 00:18:18,639
applying a list recoverable codes of the

476
00:18:15,730 --> 00:18:20,650
statements and then a Merkel tree and so

477
00:18:18,640 --> 00:18:23,080
what this code guarantees is if these

478
00:18:20,650 --> 00:18:25,110
are kind of the high-level blocks of the

479
00:18:23,080 --> 00:18:28,240
encoding in the Leafs of the Merkel tree

480
00:18:25,110 --> 00:18:30,189
if the adversary can only open up each

481
00:18:28,240 --> 00:18:33,010
of these blocks and a bounded number of

482
00:18:30,190 --> 00:18:34,540
ways say L different ways then it

483
00:18:33,010 --> 00:18:36,370
guarantees that the number of vowed

484
00:18:34,540 --> 00:18:39,070
encodings is only polynomial in this

485
00:18:36,370 --> 00:18:42,550
list size l and furthermore we can bound

486
00:18:39,070 --> 00:18:44,020
this list size by a argument about multi

487
00:18:42,550 --> 00:18:46,480
collision resistance because eventually

488
00:18:44,020 --> 00:18:49,690
all the blocks the encoding will be

489
00:18:46,480 --> 00:18:56,740
Merkel tree will hash down to a single

490
00:18:49,690 --> 00:18:58,030
digest a so as I said before the

491
00:18:56,740 --> 00:19:00,010
compression argument required us

492
00:18:58,030 --> 00:19:02,050
actually to know what the statement was

493
00:19:00,010 --> 00:19:04,660
whenever the adversary queries the

494
00:19:02,050 --> 00:19:05,830
random Oracle and so this introduces a

495
00:19:04,660 --> 00:19:08,650
new problem because now we're only

496
00:19:05,830 --> 00:19:11,949
querying where the random Oracle is

497
00:19:08,650 --> 00:19:13,120
indexed by the commitment and so the

498
00:19:11,950 --> 00:19:15,280
problem is we may not be able to

499
00:19:13,120 --> 00:19:18,340
actually extract out the statements from

500
00:19:15,280 --> 00:19:20,800
these queries so what we do now is we

501
00:19:18,340 --> 00:19:23,169
need a way to tie the commitment to the

502
00:19:20,800 --> 00:19:26,080
statement X and we do this kind of with

503
00:19:23,170 --> 00:19:27,429
another Merkel tree where we're using as

504
00:19:26,080 --> 00:19:29,409
the hash function in this Merkel tree

505
00:19:27,429 --> 00:19:32,920
the random Oracle which is indexed by

506
00:19:29,410 --> 00:19:34,750
this commitment and at a very high level

507
00:19:32,920 --> 00:19:36,730
this forces by forcing a cheating

508
00:19:34,750 --> 00:19:38,920
approver to do this we're able to either

509
00:19:36,730 --> 00:19:40,600
extract out the statements by tying them

510
00:19:38,920 --> 00:19:41,740
together or in the compression argument

511
00:19:40,600 --> 00:19:45,730
we'll be able to compress at a different

512
00:19:41,740 --> 00:19:47,440
point so that was all quick but I just

513
00:19:45,730 --> 00:19:49,300
want to give kind of a high-level idea

514
00:19:47,440 --> 00:19:52,330
of what this transformation we propose

515
00:19:49,300 --> 00:19:53,919
looks like so first there's kind of a

516
00:19:52,330 --> 00:19:56,050
commitment phase where both approver and

517
00:19:53,920 --> 00:19:59,230
the verifier are able to commit to the

518
00:19:56,050 --> 00:20:00,490
statement X the first part with this

519
00:19:59,230 --> 00:20:02,470
Merkel tree applied to a list

520
00:20:00,490 --> 00:20:05,350
recoverable encoding of X and then the

521
00:20:02,470 --> 00:20:06,610
second tree the second part by applying

522
00:20:05,350 --> 00:20:09,939
a Merkel tree to X you

523
00:20:06,610 --> 00:20:12,040
using this previous commitment and then

524
00:20:09,940 --> 00:20:13,660
in the proof phase you can think we're

525
00:20:12,040 --> 00:20:15,370
just doing Macaulay SES proofs or

526
00:20:13,660 --> 00:20:18,309
whatever protocol you want we're

527
00:20:15,370 --> 00:20:20,739
replacing the random Oracle and indexing

528
00:20:18,309 --> 00:20:24,879
it with these two kind of commitments

529
00:20:20,740 --> 00:20:26,740
from the commitment phase and at a high

530
00:20:24,880 --> 00:20:28,750
level what we're showing in this paper

531
00:20:26,740 --> 00:20:31,059
is that this modified Fiat ramier

532
00:20:28,750 --> 00:20:33,429
transformation when applied to Killians

533
00:20:31,059 --> 00:20:35,920
computationally sound argument satisfies

534
00:20:33,429 --> 00:20:37,030
best possible soundness and in general

535
00:20:35,920 --> 00:20:39,429
this isn't going to work for all

536
00:20:37,030 --> 00:20:41,379
arguments but in the paper we actually

537
00:20:39,429 --> 00:20:43,510
show that if you just restrict to three

538
00:20:41,380 --> 00:20:45,460
round proofs you can kind of use the

539
00:20:43,510 --> 00:20:47,080
statistical properties of the proofs to

540
00:20:45,460 --> 00:20:49,960
make this to show that this satisfies

541
00:20:47,080 --> 00:20:51,760
best possible soundness and in fact it's

542
00:20:49,960 --> 00:20:55,299
the statistical properties of the

543
00:20:51,760 --> 00:20:57,690
underlying PCP and Macaulay CS proofs is

544
00:20:55,299 --> 00:21:03,220
what allows us to kind of prove this

545
00:20:57,690 --> 00:21:05,620
result so to conclude I just want to

546
00:21:03,220 --> 00:21:07,030
overview that we gave kind of this new

547
00:21:05,620 --> 00:21:08,379
notion of non uniformly sound

548
00:21:07,030 --> 00:21:11,559
certificates so what's the best possible

549
00:21:08,380 --> 00:21:14,980
thing we could achieve against realistic

550
00:21:11,559 --> 00:21:18,790
attackers which can be seen kind of this

551
00:21:14,980 --> 00:21:21,190
language of proof or komagawa of

552
00:21:18,790 --> 00:21:24,190
complexity we show that they're actually

553
00:21:21,190 --> 00:21:25,840
useful so we can or they exist we can

554
00:21:24,190 --> 00:21:27,880
construct them and furthermore they're

555
00:21:25,840 --> 00:21:29,860
also useful and can used to be to

556
00:21:27,880 --> 00:21:32,770
construct concurrent constant around

557
00:21:29,860 --> 00:21:36,540
concurrency or knowledge protocols so

558
00:21:32,770 --> 00:21:36,540
with that thank to you for listening

559
00:21:40,269 --> 00:21:48,409
Thank You Cody any questions so I was

560
00:21:46,340 --> 00:21:51,379
wondering whether you you said this

561
00:21:48,409 --> 00:21:52,610
already at the end but why don't the

562
00:21:51,380 --> 00:21:54,799
technique so do you think it's

563
00:21:52,610 --> 00:21:57,260
impossible to apply these techniques to

564
00:21:54,799 --> 00:22:00,470
say logarithmic on protocols like I

565
00:21:57,260 --> 00:22:02,990
appease or other you know other

566
00:22:00,470 --> 00:22:07,090
protocols where we use via chiminea

567
00:22:02,990 --> 00:22:10,750
transform to make them non interactive

568
00:22:07,090 --> 00:22:13,519
so you're saying like play the same

569
00:22:10,750 --> 00:22:16,370
adapted here to show me a heuristic to

570
00:22:13,519 --> 00:22:18,559
make them adept like get this notion of

571
00:22:16,370 --> 00:22:20,330
soundness this adaptive yeah so there's

572
00:22:18,559 --> 00:22:22,178
no reason say if you had kind of a

573
00:22:20,330 --> 00:22:24,500
stronger her soundness per round

574
00:22:22,179 --> 00:22:25,820
there's no reason necessarily why this

575
00:22:24,500 --> 00:22:28,600
wouldn't work okay

576
00:22:25,820 --> 00:22:30,678
I do you have arguments in general where

577
00:22:28,600 --> 00:22:32,719
you maybe don't have this kind of

578
00:22:30,679 --> 00:22:33,980
statistical properties we don't have any

579
00:22:32,720 --> 00:22:35,779
evidence that this kind of

580
00:22:33,980 --> 00:22:37,490
transformation would work okay but for

581
00:22:35,779 --> 00:22:43,519
proofs it probably would I said okay

582
00:22:37,490 --> 00:22:45,409
thank you Thanks great work but isn't

583
00:22:43,519 --> 00:22:50,899
and concurrency or knowledge is random

584
00:22:45,409 --> 00:22:52,970
work all three friends your knowledge in

585
00:22:50,899 --> 00:22:58,479
the random Oracle is in a model isn't it

586
00:22:52,970 --> 00:23:07,610
trivial it's an application just music

587
00:22:58,480 --> 00:23:08,779
so in music you have some oh don't play

588
00:23:07,610 --> 00:23:12,469
the rest is great which is this

589
00:23:08,779 --> 00:23:13,850
application doesn't make sense yeah I'm

590
00:23:12,470 --> 00:23:21,080
not sure we can maybe talk about it

591
00:23:13,850 --> 00:23:25,010
later offline but all right

592
00:23:21,080 --> 00:23:25,010
[Applause]

