1
00:00:05,070 --> 00:00:09,790
thanks for the introduction so this is

2
00:00:07,360 --> 00:00:11,889
joint work with game Castaignos do

3
00:00:09,790 --> 00:00:14,849
Catherine or Fabiana you me and Federico

4
00:00:11,889 --> 00:00:17,290
semester so I'm going to explain how we

5
00:00:14,850 --> 00:00:19,660
build a generic construction for two

6
00:00:17,290 --> 00:00:21,640
party ECDSA from hashed roof systems and

7
00:00:19,660 --> 00:00:24,250
how we efficiently instantiate these

8
00:00:21,640 --> 00:00:25,630
from class groups so before I go into

9
00:00:24,250 --> 00:00:27,430
the details let me give you some

10
00:00:25,630 --> 00:00:33,519
intuition for why this work is of

11
00:00:27,430 --> 00:00:35,650
practical interest so ECDSA stands for

12
00:00:33,520 --> 00:00:38,110
elliptic curve digital signature

13
00:00:35,650 --> 00:00:41,589
algorithm so it's a standardized digital

14
00:00:38,110 --> 00:00:44,500
signature algorithm which relies on

15
00:00:41,590 --> 00:00:47,829
elliptic curve cryptography and it's the

16
00:00:44,500 --> 00:00:49,750
signature which is used in Bitcoin

17
00:00:47,829 --> 00:00:51,579
cryptocurrency to validate transactions

18
00:00:49,750 --> 00:00:53,500
in particular this means that if someone

19
00:00:51,579 --> 00:00:55,809
steals your secret signing key they can

20
00:00:53,500 --> 00:00:57,280
spend your bitcoins so we have this

21
00:00:55,809 --> 00:01:00,339
single point of failure which we'd like

22
00:00:57,280 --> 00:01:03,129
to avoid and this is where a distributed

23
00:01:00,340 --> 00:01:05,259
version of ECDSA saves the day so by

24
00:01:03,129 --> 00:01:07,270
sharing the key among multiple devices

25
00:01:05,259 --> 00:01:10,119
we not only reduce the risk of key theft

26
00:01:07,270 --> 00:01:13,090
but we also enable cryptocurrency

27
00:01:10,119 --> 00:01:15,280
custody solutions where you could where

28
00:01:13,090 --> 00:01:18,149
you need multiple parties to cooperate

29
00:01:15,280 --> 00:01:21,819
in order to perform sensitive operations

30
00:01:18,149 --> 00:01:23,259
so we focus on the two party setting so

31
00:01:21,819 --> 00:01:25,240
this would allow you for instance to

32
00:01:23,259 --> 00:01:28,090
share your secret key between your phone

33
00:01:25,240 --> 00:01:30,490
and your laptop so the secret signing

34
00:01:28,090 --> 00:01:33,160
key is shared between two parties p1 and

35
00:01:30,490 --> 00:01:36,130
p2 such that collaboratively p1 and p2

36
00:01:33,160 --> 00:01:39,098
can sign any message but alone neither

37
00:01:36,130 --> 00:01:40,300
party should be able to forge signatures

38
00:01:39,099 --> 00:01:44,110
or learn anything about the

39
00:01:40,300 --> 00:01:46,240
reconstructed secret key so forever

40
00:01:44,110 --> 00:01:48,190
signature algorithms efficient solutions

41
00:01:46,240 --> 00:01:50,229
have been around for a long time in

42
00:01:48,190 --> 00:01:52,539
particular fish nor algorithms whose

43
00:01:50,229 --> 00:01:53,349
elliptic curve Aryan is very similar to

44
00:01:52,539 --> 00:01:55,090
ECDSA

45
00:01:53,349 --> 00:01:58,959
efficient solutions have been around

46
00:01:55,090 --> 00:02:01,569
since the 90s but devising a two-party

47
00:01:58,959 --> 00:02:03,069
ECDSA scheme has proved much more

48
00:02:01,569 --> 00:02:07,530
challenging and let me give you some

49
00:02:03,069 --> 00:02:10,209
intuition why so we'll compare the snore

50
00:02:07,530 --> 00:02:12,700
signing algorithm to the ECDSA signing

51
00:02:10,209 --> 00:02:14,799
algorithm for both schemes the public

52
00:02:12,700 --> 00:02:17,589
parameters are the group of points of an

53
00:02:14,799 --> 00:02:19,150
elliptic curve G of prime order Q and

54
00:02:17,590 --> 00:02:21,370
generated by P

55
00:02:19,150 --> 00:02:23,140
the secret key is the random X I'm

56
00:02:21,370 --> 00:02:27,069
pulled from Z queue and the public key

57
00:02:23,140 --> 00:02:28,569
is X multiplied by the generator P so as

58
00:02:27,069 --> 00:02:31,540
you can see in the snow signing

59
00:02:28,569 --> 00:02:33,310
algorithm all the steps are linear the

60
00:02:31,540 --> 00:02:35,590
only nonlinear step is the hashing of

61
00:02:33,310 --> 00:02:37,060
the message but since both parties know

62
00:02:35,590 --> 00:02:40,150
the message this isn't going to be a

63
00:02:37,060 --> 00:02:41,860
problem however if we look at the ECDSA

64
00:02:40,150 --> 00:02:45,849
signing algorithm so things are very

65
00:02:41,860 --> 00:02:47,709
similar up until we compute s here and

66
00:02:45,849 --> 00:02:50,170
we need to multiply by the inverse of K

67
00:02:47,709 --> 00:02:52,720
and computing this inverse of K is what

68
00:02:50,170 --> 00:02:54,910
makes things really complicated so

69
00:02:52,720 --> 00:02:57,129
imagine we wanted to just additively

70
00:02:54,910 --> 00:03:01,660
share X and K first nor everything works

71
00:02:57,129 --> 00:03:04,659
fine each party can compute Kench sorry

72
00:03:01,660 --> 00:03:07,810
each party can sample share of X and a

73
00:03:04,659 --> 00:03:09,940
share of K and they can each compute a

74
00:03:07,810 --> 00:03:11,769
share of the signature which they just

75
00:03:09,940 --> 00:03:14,470
then need to add up to get the overall

76
00:03:11,769 --> 00:03:16,599
signature on the other hand for ECDSA

77
00:03:14,470 --> 00:03:19,269
it's really unclear how we can

78
00:03:16,599 --> 00:03:23,970
efficiently compute K minus 1 I mean the

79
00:03:19,269 --> 00:03:23,970
inverse of K from additive shares of K

80
00:03:24,090 --> 00:03:29,019
so before I go any further let me give

81
00:03:27,400 --> 00:03:31,030
you an idea of where we're heading so

82
00:03:29,019 --> 00:03:32,650
I'll first talk about previous work in

83
00:03:31,030 --> 00:03:36,609
this field and in particular that which

84
00:03:32,650 --> 00:03:39,519
we build upon and I'll outline the the

85
00:03:36,609 --> 00:03:40,810
drawbacks that this these works have in

86
00:03:39,519 --> 00:03:43,720
particular the reliance on a

87
00:03:40,810 --> 00:03:45,849
non-standard interactive assumption I'll

88
00:03:43,720 --> 00:03:50,829
explain how we remove this assumption by

89
00:03:45,849 --> 00:03:53,980
using hash proof systems and I'll

90
00:03:50,829 --> 00:03:58,690
provide the generic construction that we

91
00:03:53,980 --> 00:04:01,629
give and prove its security and finally

92
00:03:58,690 --> 00:04:05,099
I'll explain how we instantiate this

93
00:04:01,629 --> 00:04:08,078
generic construction from class groups

94
00:04:05,099 --> 00:04:09,660
which allows us to remove range proofs

95
00:04:08,079 --> 00:04:12,489
and significally

96
00:04:09,660 --> 00:04:18,608
significantly improve our communication

97
00:04:12,489 --> 00:04:21,160
custom so previous work in gray on this

98
00:04:18,608 --> 00:04:24,280
timeline there's some working the full

99
00:04:21,160 --> 00:04:26,169
threshold case so some great work has

100
00:04:24,280 --> 00:04:27,940
been done in this field recently but

101
00:04:26,169 --> 00:04:29,650
since once restricted to the two party

102
00:04:27,940 --> 00:04:31,690
setting these yield less efficient

103
00:04:29,650 --> 00:04:33,340
protocols I won't go into the details

104
00:04:31,690 --> 00:04:38,020
here

105
00:04:33,340 --> 00:04:41,320
I Triple E S&P Donnell and I'll put

106
00:04:38,020 --> 00:04:43,690
forth a scheme in a two out of n scheme

107
00:04:41,320 --> 00:04:45,070
which is fast but it relies on oblivious

108
00:04:43,690 --> 00:04:48,790
transfer so it has quite high

109
00:04:45,070 --> 00:04:50,469
communication cost and we wanted to

110
00:04:48,790 --> 00:04:53,080
avoid that so the work that we build

111
00:04:50,470 --> 00:04:55,270
upon essentially started at crypto 2001

112
00:04:53,080 --> 00:04:58,229
with meccans generator so they had the

113
00:04:55,270 --> 00:05:01,450
idea of multiplicatively sharing X and K

114
00:04:58,230 --> 00:05:02,920
and then they use the linear Himal

115
00:05:01,450 --> 00:05:04,120
morphic properties of the value

116
00:05:02,920 --> 00:05:07,660
encryption scheme in order to

117
00:05:04,120 --> 00:05:09,670
reconstruct the signature the problem of

118
00:05:07,660 --> 00:05:12,100
their work is that for each signature

119
00:05:09,670 --> 00:05:13,780
they need to perform expensive zero

120
00:05:12,100 --> 00:05:16,450
knowledge proof of knowledge in order to

121
00:05:13,780 --> 00:05:20,679
prove that the cipher texts are

122
00:05:16,450 --> 00:05:23,200
well-formed much more recently at crypto

123
00:05:20,680 --> 00:05:25,420
2017 Lindell came up with a great idea

124
00:05:23,200 --> 00:05:27,039
which allows to remove all expensive

125
00:05:25,420 --> 00:05:29,410
zero knowledge proof from the signature

126
00:05:27,040 --> 00:05:32,110
algorithm so that they're only done once

127
00:05:29,410 --> 00:05:33,730
at key generation this is great

128
00:05:32,110 --> 00:05:35,860
improvement but there are still some

129
00:05:33,730 --> 00:05:37,720
drawbacks in his work in particular due

130
00:05:35,860 --> 00:05:39,910
to the fact that the value encryption

131
00:05:37,720 --> 00:05:41,680
scheme has a composite order message

132
00:05:39,910 --> 00:05:45,150
space whereas the elements were going to

133
00:05:41,680 --> 00:05:48,700
be encrypted live encrypting live mod Q

134
00:05:45,150 --> 00:05:52,150
he needs to use range proofs and he also

135
00:05:48,700 --> 00:05:57,280
needs to introduce in his security proof

136
00:05:52,150 --> 00:05:59,380
artificial aborts and when he's proving

137
00:05:57,280 --> 00:06:01,330
security in the simulation based model

138
00:05:59,380 --> 00:06:03,490
he also actually introduces a very ad

139
00:06:01,330 --> 00:06:07,240
hoc interactive assumption which I'll

140
00:06:03,490 --> 00:06:08,980
talk a bit more about later so since we

141
00:06:07,240 --> 00:06:10,770
build upon lindell's work I'll explain

142
00:06:08,980 --> 00:06:13,840
at a high level how his protocol works

143
00:06:10,770 --> 00:06:18,039
so recall that our problem is that of

144
00:06:13,840 --> 00:06:21,219
jointly computing s and so p1 and p2

145
00:06:18,040 --> 00:06:23,890
each have multiplicative share of X and

146
00:06:21,220 --> 00:06:26,170
K and they can set up the public key q

147
00:06:23,890 --> 00:06:30,669
and the randomness are via simulated all

148
00:06:26,170 --> 00:06:33,220
diffie-hellman key exchanges and if we

149
00:06:30,670 --> 00:06:35,440
call this part of the message here as

150
00:06:33,220 --> 00:06:39,820
prime notice that all operations

151
00:06:35,440 --> 00:06:41,710
relative to x1 linear so if P 2 has an

152
00:06:39,820 --> 00:06:45,250
encryption of x1 that was sent to him by

153
00:06:41,710 --> 00:06:45,760
p1 it can compute an encryption of s

154
00:06:45,250 --> 00:06:47,200
Prime

155
00:06:45,760 --> 00:06:49,719
using the linear hammam Orphic

156
00:06:47,200 --> 00:06:51,789
properties of valium and then if it

157
00:06:49,720 --> 00:06:56,380
sends this encryption of s Prime back to

158
00:06:51,790 --> 00:06:59,890
p1 p1 can decrypt x his share of K and

159
00:06:56,380 --> 00:07:02,800
then he gets s and it gets better

160
00:06:59,890 --> 00:07:06,250
because actually since x1 is somehow

161
00:07:02,800 --> 00:07:08,410
that key generation p1 is going to send

162
00:07:06,250 --> 00:07:10,390
an encryption of x1 I prove it what he

163
00:07:08,410 --> 00:07:13,150
encrypted is indeed the same x1 as that

164
00:07:10,390 --> 00:07:15,280
used to compute Q and arrange proof to

165
00:07:13,150 --> 00:07:17,739
p2 but he only needs to do these proofs

166
00:07:15,280 --> 00:07:20,859
once at key generation he doesn't have

167
00:07:17,740 --> 00:07:23,080
to do anything afterwards and now every

168
00:07:20,860 --> 00:07:25,690
time that p1 and p2 wants to

169
00:07:23,080 --> 00:07:27,940
collaboratively sign a message p1 can

170
00:07:25,690 --> 00:07:31,240
just compute an encryption of s Prime

171
00:07:27,940 --> 00:07:33,130
using his freshly samples K to send this

172
00:07:31,240 --> 00:07:35,680
encryption of s Prime to P one who can

173
00:07:33,130 --> 00:07:38,380
decrypt to recover s Prime nabe his

174
00:07:35,680 --> 00:07:40,480
share of K and he gets the signature and

175
00:07:38,380 --> 00:07:42,040
p2 doesn't have to perform any proofs

176
00:07:40,480 --> 00:07:45,520
that he performed the correct

177
00:07:42,040 --> 00:07:46,900
homomorphic operations because p1 can

178
00:07:45,520 --> 00:07:49,000
just use the public verification

179
00:07:46,900 --> 00:07:51,310
algorithm to check that the signature is

180
00:07:49,000 --> 00:07:56,500
valid if it's valid then he just outputs

181
00:07:51,310 --> 00:07:57,940
this signature a voice here boards ok so

182
00:07:56,500 --> 00:08:01,630
this is great but there are still some

183
00:07:57,940 --> 00:08:04,690
issues in particular due to the fact

184
00:08:01,630 --> 00:08:06,400
that we're using value in the value

185
00:08:04,690 --> 00:08:08,440
crypto system your Challenger isn't

186
00:08:06,400 --> 00:08:10,299
allowed to use the isn't allowed to know

187
00:08:08,440 --> 00:08:11,980
the secret key otherwise the algorithm

188
00:08:10,300 --> 00:08:14,350
is an algorithmic assumption doesn't

189
00:08:11,980 --> 00:08:16,720
hold anymore and so in the security

190
00:08:14,350 --> 00:08:19,450
proof when we're simulating p1 against a

191
00:08:16,720 --> 00:08:23,410
malicious p2 we can't actually decrypt

192
00:08:19,450 --> 00:08:25,840
to check whether the signature is valid

193
00:08:23,410 --> 00:08:28,000
and we can't check that p2 performed the

194
00:08:25,840 --> 00:08:30,099
correct operations and so in the game

195
00:08:28,000 --> 00:08:32,200
based proof the way Lindell deals with

196
00:08:30,100 --> 00:08:35,470
this is he just guesses if and when

197
00:08:32,200 --> 00:08:37,120
player to choose so we have a security

198
00:08:35,470 --> 00:08:41,290
loss which is proportional to the number

199
00:08:37,120 --> 00:08:44,260
of signatures that are ECDSA adversary's

200
00:08:41,289 --> 00:08:46,030
allowed to query from its Oracle in the

201
00:08:44,260 --> 00:08:48,850
simulation based proof this guessing

202
00:08:46,030 --> 00:08:50,020
doesn't work so Lindell introduces a

203
00:08:48,850 --> 00:08:52,300
non-interactive

204
00:08:50,020 --> 00:08:58,100
sorry an interactive and non-standard

205
00:08:52,300 --> 00:08:59,990
assumption which basically states that

206
00:08:58,100 --> 00:09:02,900
security for the ballet encryption

207
00:08:59,990 --> 00:09:04,970
scheme still holds even if the adversary

208
00:09:02,900 --> 00:09:07,550
has access to an Oracle which tells you

209
00:09:04,970 --> 00:09:09,290
if a given ciphertext is a linear

210
00:09:07,550 --> 00:09:13,670
combination of the challenge ciphertext

211
00:09:09,290 --> 00:09:16,250
and then the other problem is that as

212
00:09:13,670 --> 00:09:18,680
mentioned earlier the per year message

213
00:09:16,250 --> 00:09:21,230
spaces of composite order whereas we're

214
00:09:18,680 --> 00:09:22,640
encrypting elements mod Q and so we need

215
00:09:21,230 --> 00:09:29,030
range proofs to ensure that no wrap

216
00:09:22,640 --> 00:09:32,390
arounds occur so in our work we wanted

217
00:09:29,030 --> 00:09:38,209
to provide a two party protocol for

218
00:09:32,390 --> 00:09:39,830
ECDSA which doesn't rely well which is

219
00:09:38,210 --> 00:09:42,020
efficient both in terms of computational

220
00:09:39,830 --> 00:09:44,240
complexity and in terms of bandwidth

221
00:09:42,020 --> 00:09:46,880
which doesn't require any non-standard

222
00:09:44,240 --> 00:09:49,190
interactive assumptions and which has a

223
00:09:46,880 --> 00:09:50,510
tight security proof so to this end we

224
00:09:49,190 --> 00:09:53,200
need a linearly homomorphic encryption

225
00:09:50,510 --> 00:09:55,760
scheme where security doesn't rely on

226
00:09:53,200 --> 00:09:58,520
the Challenger not knowing the secret

227
00:09:55,760 --> 00:09:59,780
key and if we can further have an

228
00:09:58,520 --> 00:10:03,560
encryption scheme where the message

229
00:09:59,780 --> 00:10:06,949
spaces of prime order then we can remove

230
00:10:03,560 --> 00:10:10,459
the range previously so we achieve this

231
00:10:06,950 --> 00:10:11,840
by using homomorphic encryption amorphic

232
00:10:10,460 --> 00:10:15,050
encryption schemes from hash proof

233
00:10:11,840 --> 00:10:18,320
systems and when we instantiate this

234
00:10:15,050 --> 00:10:21,939
generic construction with a hash proof

235
00:10:18,320 --> 00:10:27,740
system from class groups we can also

236
00:10:21,940 --> 00:10:29,810
remove the range proofs so let's first

237
00:10:27,740 --> 00:10:33,740
see how we remove this interactive

238
00:10:29,810 --> 00:10:35,390
assumption so we do this using hash

239
00:10:33,740 --> 00:10:38,150
proof systems has proof systems were

240
00:10:35,390 --> 00:10:42,370
introduced by kana honcho at Yura crypt

241
00:10:38,150 --> 00:10:44,540
2002 as a means of efficiently computing

242
00:10:42,370 --> 00:10:48,560
both trays and plaintext and chosen

243
00:10:44,540 --> 00:10:50,300
ciphertext secure encryption schemes so

244
00:10:48,560 --> 00:10:51,739
security in this setting relies on the

245
00:10:50,300 --> 00:10:53,990
hardness of a sub group membership

246
00:10:51,740 --> 00:10:56,930
problem so we have this finite abelian

247
00:10:53,990 --> 00:11:00,050
group X which contains a sub group L

248
00:10:56,930 --> 00:11:03,170
which defines an NP language and as such

249
00:11:00,050 --> 00:11:08,089
there's the witness set W which defines

250
00:11:03,170 --> 00:11:10,339
this NP language and the hardness of the

251
00:11:08,090 --> 00:11:11,600
problem requires that given a random

252
00:11:10,340 --> 00:11:13,459
element sampled from

253
00:11:11,600 --> 00:11:17,329
it's hard to tell if it's in the

254
00:11:13,459 --> 00:11:20,029
language or not and so in this context

255
00:11:17,329 --> 00:11:22,219
we have to have hashing algorithms one

256
00:11:20,029 --> 00:11:24,829
which works over any element in the

257
00:11:22,220 --> 00:11:27,440
whole group X and which takes as input a

258
00:11:24,829 --> 00:11:32,439
secret key and hash is an element in X

259
00:11:27,440 --> 00:11:35,389
and another hashing algorithm here which

260
00:11:32,440 --> 00:11:36,920
takes as input a public key an element

261
00:11:35,389 --> 00:11:39,380
in the language and The Associated

262
00:11:36,920 --> 00:11:43,189
witness and outputs a hash and

263
00:11:39,380 --> 00:11:45,500
correctness imposes that's both

264
00:11:43,190 --> 00:11:47,540
algorithms should evaluate to the same

265
00:11:45,500 --> 00:11:51,740
value if they're evaluated over elements

266
00:11:47,540 --> 00:11:55,370
in the language so from this we can well

267
00:11:51,740 --> 00:11:57,110
be devised a encryption schemes so to

268
00:11:55,370 --> 00:11:59,959
encrypt an element basically you just

269
00:11:57,110 --> 00:12:02,690
sample random element from the language

270
00:11:59,959 --> 00:12:05,660
with The Associated witness you use the

271
00:12:02,690 --> 00:12:08,779
public projective hashing algorithm to

272
00:12:05,660 --> 00:12:11,569
compute a hash of X and you use this to

273
00:12:08,779 --> 00:12:13,009
mask your encoding of the message so

274
00:12:11,569 --> 00:12:15,229
I've encoded the message in the exponent

275
00:12:13,009 --> 00:12:17,120
of F because we want a linearly

276
00:12:15,230 --> 00:12:18,500
homomorphic encryption scheme but the

277
00:12:17,120 --> 00:12:22,819
idea is just that you're masking the

278
00:12:18,500 --> 00:12:25,160
message and then you return your masked

279
00:12:22,819 --> 00:12:27,589
message and the element of the language

280
00:12:25,160 --> 00:12:29,810
but not the witness and so now the

281
00:12:27,589 --> 00:12:31,880
Decrypter who knows the secret key can

282
00:12:29,810 --> 00:12:34,550
compute the same hash value using the

283
00:12:31,880 --> 00:12:37,269
secret key and the element X and can

284
00:12:34,550 --> 00:12:41,089
remove this mask to recover the message

285
00:12:37,269 --> 00:12:42,980
and clearly knowing the secret key here

286
00:12:41,089 --> 00:12:45,290
doesn't actually help solve the

287
00:12:42,980 --> 00:12:47,029
underlying algorithmic assumption with

288
00:12:45,290 --> 00:12:49,639
the secret key you can evaluate the hash

289
00:12:47,029 --> 00:12:50,810
function over any element in X but it

290
00:12:49,639 --> 00:12:53,860
doesn't help you tell if a random

291
00:12:50,810 --> 00:12:57,258
element in X is in the language or not

292
00:12:53,860 --> 00:12:59,180
conversely in the by a crypto system

293
00:12:57,259 --> 00:13:00,860
which relies on the decisional composite

294
00:12:59,180 --> 00:13:03,800
residue so the assumption knowing the

295
00:13:00,860 --> 00:13:04,699
factorization of n actually makes the

296
00:13:03,800 --> 00:13:08,180
problem easy

297
00:13:04,699 --> 00:13:10,399
so if we use an encryption scheme from

298
00:13:08,180 --> 00:13:11,870
hash proof systems our simulator can use

299
00:13:10,399 --> 00:13:14,259
the secret key and it won't compromise

300
00:13:11,870 --> 00:13:14,259
security

301
00:13:15,410 --> 00:13:21,329
so now I can present our three party

302
00:13:19,200 --> 00:13:22,590
protocol it's very similar to that of

303
00:13:21,330 --> 00:13:26,700
lindell's except for the aforementioned

304
00:13:22,590 --> 00:13:29,250
changes so player one and player two

305
00:13:26,700 --> 00:13:31,380
each sample random share of X what of X

306
00:13:29,250 --> 00:13:33,120
they can perform a simulated ball

307
00:13:31,380 --> 00:13:35,939
diffie-hellman key exchange to set up

308
00:13:33,120 --> 00:13:39,210
the public key Q then P one is going to

309
00:13:35,940 --> 00:13:40,590
sample the secret and public key for the

310
00:13:39,210 --> 00:13:43,710
encryption scheme from hash proof

311
00:13:40,590 --> 00:13:45,720
systems it encrypts x1 sends this

312
00:13:43,710 --> 00:13:48,330
encryption of x1 along with a proof that

313
00:13:45,720 --> 00:13:50,640
it knows the encrypted value x1 and the

314
00:13:48,330 --> 00:13:52,380
randomness used for encryption and that

315
00:13:50,640 --> 00:13:55,410
the encrypted value is indeed the same

316
00:13:52,380 --> 00:13:57,630
x1 is that used to compute Q both

317
00:13:55,410 --> 00:14:00,420
parties store the public key q their

318
00:13:57,630 --> 00:14:03,060
share of X P 1 also stores his

319
00:14:00,420 --> 00:14:06,410
decryption key and P 2 also stores the

320
00:14:03,060 --> 00:14:09,089
encryption of X 1 that it got from P 1

321
00:14:06,410 --> 00:14:13,469
and then in order to sign a message

322
00:14:09,090 --> 00:14:15,090
each party samples their share of K they

323
00:14:13,470 --> 00:14:19,040
perform simulator vol diffie-hellman key

324
00:14:15,090 --> 00:14:23,480
exchange to set up the randomness r p2

325
00:14:19,040 --> 00:14:27,300
can compute an encryption of s Prime and

326
00:14:23,480 --> 00:14:31,320
send this to p1 p2 decrypts multiplies

327
00:14:27,300 --> 00:14:33,120
by his share of K and verifies the

328
00:14:31,320 --> 00:14:36,860
signature if it's valid it outputs it

329
00:14:33,120 --> 00:14:40,380
otherwise that boss ok so to prove

330
00:14:36,860 --> 00:14:43,530
security in this setting so for a two

331
00:14:40,380 --> 00:14:47,250
party ECDSA protocol what we do is we

332
00:14:43,530 --> 00:14:49,770
demonstrate that if a party alone can

333
00:14:47,250 --> 00:14:51,690
forge signatures then a simulator which

334
00:14:49,770 --> 00:14:53,520
is going to simulate the environment for

335
00:14:51,690 --> 00:14:56,940
this corrupted player can output a

336
00:14:53,520 --> 00:14:59,310
signature a forgery for a standard ECDSA

337
00:14:56,940 --> 00:15:02,420
and so we reduce the security of the two

338
00:14:59,310 --> 00:15:06,510
party protocol to that of standard ECDSA

339
00:15:02,420 --> 00:15:09,329
so in standard ECDSA a forger gets as

340
00:15:06,510 --> 00:15:12,480
input a public key q which is x times P

341
00:15:09,330 --> 00:15:14,550
and it has access to an Oracle from

342
00:15:12,480 --> 00:15:16,920
which will sign messages of its choice

343
00:15:14,550 --> 00:15:18,689
and then it has to output a message and

344
00:15:16,920 --> 00:15:24,260
a signature which it didn't get from its

345
00:15:18,690 --> 00:15:26,520
Oracle so if I don't know P I star our

346
00:15:24,260 --> 00:15:28,630
corrupted party for the two party

347
00:15:26,520 --> 00:15:30,760
protocol if I see

348
00:15:28,630 --> 00:15:34,990
you later can set up the same public key

349
00:15:30,760 --> 00:15:37,630
queue as it got as input from like from

350
00:15:34,990 --> 00:15:39,790
its challenge then every time the

351
00:15:37,630 --> 00:15:42,640
corrupted player asks to collaboratively

352
00:15:39,790 --> 00:15:44,500
sign a message with the simulator it can

353
00:15:42,640 --> 00:15:47,350
just request a signature of this message

354
00:15:44,500 --> 00:15:50,710
from its Oracle and then it's going to

355
00:15:47,350 --> 00:15:52,540
simulate the signing phase to output the

356
00:15:50,710 --> 00:15:56,080
same signature as it received from its

357
00:15:52,540 --> 00:15:59,380
Oracle and now if our party PI star

358
00:15:56,080 --> 00:16:01,090
outputs a forgery for the two-party

359
00:15:59,380 --> 00:16:03,850
protocol since they set up the same

360
00:16:01,090 --> 00:16:06,010
public key the simulator can use this

361
00:16:03,850 --> 00:16:11,710
forgery as its own forgery and he's

362
00:16:06,010 --> 00:16:16,420
broken standard ECDSA so I'll now

363
00:16:11,710 --> 00:16:18,190
justify the security of askew so I'll

364
00:16:16,420 --> 00:16:19,689
only talk about the part where our

365
00:16:18,190 --> 00:16:21,880
techniques kick in which is when we're

366
00:16:19,690 --> 00:16:27,430
considering a corrupted player 2 and so

367
00:16:21,880 --> 00:16:29,080
we need to simulate player 1 so the

368
00:16:27,430 --> 00:16:31,390
simulator gets us input this public key

369
00:16:29,080 --> 00:16:34,000
cue it can simulate the diffie-hellman

370
00:16:31,390 --> 00:16:35,830
key exchange with the corrupted player 2

371
00:16:34,000 --> 00:16:38,350
and from this simulated diffie-hellman

372
00:16:35,830 --> 00:16:41,590
key exchange it can extract the value X

373
00:16:38,350 --> 00:16:43,900
2 there was input by player 2 then the

374
00:16:41,590 --> 00:16:47,020
simulator samples our secret key and a

375
00:16:43,900 --> 00:16:48,790
public key for the encryption scheme and

376
00:16:47,020 --> 00:16:51,699
notice that it doesn't actually know the

377
00:16:48,790 --> 00:16:54,790
value X such that Q is equal to x times

378
00:16:51,700 --> 00:16:57,280
P and so it doesn't know the x1 that it

379
00:16:54,790 --> 00:16:59,469
should be sending an encryption of to P

380
00:16:57,280 --> 00:17:01,329
2 so it just samples a random X 1 star

381
00:16:59,470 --> 00:17:03,610
encrypts this value and sends it along

382
00:17:01,330 --> 00:17:07,270
with the simulated proof to their

383
00:17:03,610 --> 00:17:09,640
corrupted player 2 and then they store

384
00:17:07,270 --> 00:17:10,660
the values that they remain to store and

385
00:17:09,640 --> 00:17:13,060
so this is where the

386
00:17:10,660 --> 00:17:14,949
indistinguishability of the encryption

387
00:17:13,060 --> 00:17:16,569
scheme is important because our

388
00:17:14,949 --> 00:17:20,860
simulator is just sending the encryption

389
00:17:16,569 --> 00:17:24,520
of a random value next to simulate the

390
00:17:20,859 --> 00:17:25,030
signing step so P 2 asks to sign a

391
00:17:24,520 --> 00:17:28,150
message

392
00:17:25,030 --> 00:17:29,860
M the simulator is going to request a

393
00:17:28,150 --> 00:17:33,880
signature of this message from its

394
00:17:29,860 --> 00:17:37,570
oracle RS from this signature it can

395
00:17:33,880 --> 00:17:39,670
extract the randomness are used for for

396
00:17:37,570 --> 00:17:41,760
this signature and then it can perform

397
00:17:39,670 --> 00:17:45,090
the simulated diffie-hellman

398
00:17:41,760 --> 00:17:47,160
exchange with the corrupted fair - in

399
00:17:45,090 --> 00:17:49,949
order to set up the same randomness our

400
00:17:47,160 --> 00:17:52,350
and it extracts the value K - that was

401
00:17:49,950 --> 00:17:54,330
input by P - and now when it gets the

402
00:17:52,350 --> 00:17:57,449
encrypted value C Prime from the

403
00:17:54,330 --> 00:17:58,919
corrupted player - it can decrypt using

404
00:17:57,450 --> 00:18:02,610
the secret key which it's now allowed to

405
00:17:58,920 --> 00:18:06,800
decrypt to use and check that player -

406
00:18:02,610 --> 00:18:09,360
performs the correct operations if so it

407
00:18:06,800 --> 00:18:12,120
returns the signature they received from

408
00:18:09,360 --> 00:18:14,040
its Oracle and if not abort so thanks to

409
00:18:12,120 --> 00:18:16,110
this simple change we don't need to

410
00:18:14,040 --> 00:18:19,020
guess if player 2 cheats we don't need

411
00:18:16,110 --> 00:18:25,379
to use any non-standard or interactive

412
00:18:19,020 --> 00:18:28,280
assumptions and yeah so now that I've

413
00:18:25,380 --> 00:18:30,600
shown how to get rid of the strange

414
00:18:28,280 --> 00:18:33,090
assumption let's now see how we can

415
00:18:30,600 --> 00:18:35,100
remove range proofs so to do this we

416
00:18:33,090 --> 00:18:36,990
need an encryption scheme which relies

417
00:18:35,100 --> 00:18:38,429
on hash proof systems which has a prime

418
00:18:36,990 --> 00:18:40,230
order message space where we can

419
00:18:38,430 --> 00:18:43,530
actually choose this order to be the

420
00:18:40,230 --> 00:18:45,150
order of the group of points of the

421
00:18:43,530 --> 00:18:47,610
elliptic curve which is used for ECDSA

422
00:18:45,150 --> 00:18:50,100
so this isn't common but we can achieve

423
00:18:47,610 --> 00:18:51,959
this from the framework which was

424
00:18:50,100 --> 00:18:55,439
introduced by ksenia son led you and me

425
00:18:51,960 --> 00:18:58,470
at CTR say 2015 so that of a group with

426
00:18:55,440 --> 00:19:00,930
an easy discrete logarithm subgroup so

427
00:18:58,470 --> 00:19:03,720
we have a cyclic group G of order Q

428
00:19:00,930 --> 00:19:06,270
times s where the GCD of Q and s is 1

429
00:19:03,720 --> 00:19:08,730
here is a large prime and we have a

430
00:19:06,270 --> 00:19:11,850
subgroup F of G generated by little F

431
00:19:08,730 --> 00:19:14,790
which is of order Q and another subgroup

432
00:19:11,850 --> 00:19:18,179
G Q which consists of the Q powers in G

433
00:19:14,790 --> 00:19:19,950
which is of order s and we require that

434
00:19:18,180 --> 00:19:24,450
the discrete logarithm problem be easy

435
00:19:19,950 --> 00:19:28,200
in F in this framework Castaignos Leggio

436
00:19:24,450 --> 00:19:29,550
me and myself introduced a the hsm hard

437
00:19:28,200 --> 00:19:31,620
sub group membership problem which

438
00:19:29,550 --> 00:19:35,340
essentially states that it's hard to

439
00:19:31,620 --> 00:19:37,469
distinguish random elements of the group

440
00:19:35,340 --> 00:19:40,010
G from random elements of the subgroup

441
00:19:37,470 --> 00:19:40,010
GQ

442
00:19:40,320 --> 00:19:46,740
and so from if I compare to the

443
00:19:43,950 --> 00:19:49,950
framework of coming untrue that I talked

444
00:19:46,740 --> 00:19:53,480
about earlier so here the language is GQ

445
00:19:49,950 --> 00:19:57,390
and the whole group is the group G and

446
00:19:53,480 --> 00:19:59,760
so if we a witness for an element in the

447
00:19:57,390 --> 00:20:02,550
language is going to be a W such there X

448
00:19:59,760 --> 00:20:04,290
is GQ to the particle and so we can

449
00:20:02,550 --> 00:20:07,530
create a linearly homomorphic encryption

450
00:20:04,290 --> 00:20:09,480
scheme from this setting and the secret

451
00:20:07,530 --> 00:20:16,050
key doesn't help distinguish to pass in

452
00:20:09,480 --> 00:20:18,600
G gastón yes and legume he also provided

453
00:20:16,050 --> 00:20:23,460
an concrete instantiation for this

454
00:20:18,600 --> 00:20:27,530
framework from class groups so here K is

455
00:20:23,460 --> 00:20:30,660
our imaginary quadratic field of

456
00:20:27,530 --> 00:20:35,060
discriminant Delta K and if we choose

457
00:20:30,660 --> 00:20:39,990
this discriminant to be divisible by Q

458
00:20:35,060 --> 00:20:42,750
then denoting a Delta the non maximal

459
00:20:39,990 --> 00:20:45,270
order of discriminant q squared Delta K

460
00:20:42,750 --> 00:20:47,880
then we can exhibit a cyclic group of

461
00:20:45,270 --> 00:20:49,020
order Q in this in the class group of

462
00:20:47,880 --> 00:20:53,880
this non maximal order where the

463
00:20:49,020 --> 00:20:57,690
discrete logarithm problem is easy and

464
00:20:53,880 --> 00:21:00,060
in this setting the security of solving

465
00:20:57,690 --> 00:21:01,500
the hsm assumption that i talked of

466
00:21:00,060 --> 00:21:03,600
earlier reduces to the problem of

467
00:21:01,500 --> 00:21:05,760
computing the class number and best

468
00:21:03,600 --> 00:21:09,419
number the best known algorithm sorry

469
00:21:05,760 --> 00:21:12,200
for this problem our have complex DL one

470
00:21:09,420 --> 00:21:15,090
half as opposed to L one-third for

471
00:21:12,200 --> 00:21:17,010
factorization or discrete logarithm in

472
00:21:15,090 --> 00:21:18,419
traditional finite fields so in

473
00:21:17,010 --> 00:21:21,300
particular this means that we can use

474
00:21:18,420 --> 00:21:24,120
shorter elements than those used in the

475
00:21:21,300 --> 00:21:29,430
belly encryption scheme which further

476
00:21:24,120 --> 00:21:32,010
reduces communication cost so we

477
00:21:29,430 --> 00:21:34,410
implemented both our scheme and I mean

478
00:21:32,010 --> 00:21:39,720
our protocol and that of Lindell to

479
00:21:34,410 --> 00:21:41,190
compare speed and bandwidth so yeah in

480
00:21:39,720 --> 00:21:43,740
terms of speed for lower levels of

481
00:21:41,190 --> 00:21:45,660
security we're slower but the more you

482
00:21:43,740 --> 00:21:47,640
increase security the better we perform

483
00:21:45,660 --> 00:21:50,390
and in terms of bandwidth we do

484
00:21:47,640 --> 00:21:50,390
consistently better

485
00:21:51,730 --> 00:21:58,119
so to conclude we provided a generic

486
00:21:55,149 --> 00:21:59,289
two-party ECDSA protocol from hash proof

487
00:21:58,119 --> 00:22:01,619
systems where we don't have any

488
00:21:59,289 --> 00:22:03,489
interactive or non-standard assumptions

489
00:22:01,619 --> 00:22:04,689
there's one thing that I didn't really

490
00:22:03,489 --> 00:22:07,389
mention is that the zero knowledge proof

491
00:22:04,690 --> 00:22:10,509
isn't completely generic it kind of

492
00:22:07,389 --> 00:22:12,850
depends on the instance of hash proof

493
00:22:10,509 --> 00:22:16,629
system that we use and we provide an

494
00:22:12,850 --> 00:22:20,379
instantiation in class groups which is

495
00:22:16,629 --> 00:22:23,769
practical and has very low bandwidth and

496
00:22:20,379 --> 00:22:25,809
we're currently working on extending

497
00:22:23,769 --> 00:22:27,519
this to the full threshold setting so

498
00:22:25,809 --> 00:22:36,009
thank you for your attention and if you

499
00:22:27,519 --> 00:22:39,220
have any questions all right thank you

500
00:22:36,009 --> 00:22:40,960
des we would have time for only a quick

501
00:22:39,220 --> 00:22:56,679
question if you have one at the mic

502
00:22:40,960 --> 00:22:58,509
while the next speaker sets up okay

503
00:22:56,679 --> 00:22:59,970
there's no question that's thank you

504
00:22:58,509 --> 00:23:03,910
again

505
00:22:59,970 --> 00:23:03,910
[Applause]

