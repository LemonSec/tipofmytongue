1
00:00:04,940 --> 00:00:10,980
thank you my co-authors are Ron Cohen

2
00:00:09,120 --> 00:00:12,570
and Daniel wicks Ron would have liked to

3
00:00:10,980 --> 00:00:16,490
give this talk but he didn't receive a

4
00:00:12,570 --> 00:00:20,730
visa in time so I'm very sad about that

5
00:00:16,490 --> 00:00:24,150
yeah so the talks is about adaptive

6
00:00:20,730 --> 00:00:26,699
security so in normal MPC the standard

7
00:00:24,150 --> 00:00:28,590
model for static corruptions allows an

8
00:00:26,699 --> 00:00:30,510
adversary to pick the corrupted part of

9
00:00:28,590 --> 00:00:33,059
our T's before protocol begins so an

10
00:00:30,510 --> 00:00:35,180
adversary can for example say this set

11
00:00:33,059 --> 00:00:37,440
of parties are corrupted at that point

12
00:00:35,180 --> 00:00:40,080
sort of in the ideal real simulation

13
00:00:37,440 --> 00:00:41,909
paradigm the adversaries given the

14
00:00:40,080 --> 00:00:43,350
inputs of these particular parties and

15
00:00:41,909 --> 00:00:45,360
then can basically cheat as it wishes

16
00:00:43,350 --> 00:00:47,040
and the simulator is required to

17
00:00:45,360 --> 00:00:49,710
basically produce for the transcript of

18
00:00:47,040 --> 00:00:51,299
the of that protocol but this

19
00:00:49,710 --> 00:00:52,920
unfortunately is unrealistic in the

20
00:00:51,299 --> 00:00:54,059
sense that the adversary has to pick the

21
00:00:52,920 --> 00:00:55,979
set of corrupted parties at the

22
00:00:54,059 --> 00:00:59,430
beginning of the protocol and perhaps

23
00:00:55,979 --> 00:01:00,750
that's that's overly optimistic so in

24
00:00:59,430 --> 00:01:02,580
the adaptive corruption model the

25
00:01:00,750 --> 00:01:08,610
adversary gets to pick the corrupted

26
00:01:02,580 --> 00:01:09,990
parties at any time so for example the

27
00:01:08,610 --> 00:01:11,550
adversary could corrupt this party and

28
00:01:09,990 --> 00:01:13,289
then at some later point in the

29
00:01:11,550 --> 00:01:15,330
execution it can corrupt another party

30
00:01:13,290 --> 00:01:19,260
or another set of parties and so forth

31
00:01:15,330 --> 00:01:21,509
and in particular it can corrupt the

32
00:01:19,260 --> 00:01:23,730
parties after the end of the protocol so

33
00:01:21,510 --> 00:01:26,850
for example the entire protocol can run

34
00:01:23,730 --> 00:01:28,560
so at this point the simulator of an NPC

35
00:01:26,850 --> 00:01:30,990
needs to produce a transcript of that

36
00:01:28,560 --> 00:01:32,820
protocol and then after the execution of

37
00:01:30,990 --> 00:01:35,369
the protocol is finished the adversary

38
00:01:32,820 --> 00:01:37,500
then decides to corrupt all of the

39
00:01:35,370 --> 00:01:39,750
parties and at this point the simulator

40
00:01:37,500 --> 00:01:42,120
then needs to give explain the

41
00:01:39,750 --> 00:01:44,400
transcript that it produced to the

42
00:01:42,120 --> 00:01:46,170
adversary so in particular at this point

43
00:01:44,400 --> 00:01:48,240
the simulator is given the inputs but it

44
00:01:46,170 --> 00:01:50,210
has to explain how the transcript that

45
00:01:48,240 --> 00:01:51,960
it produced before seeing the inputs

46
00:01:50,210 --> 00:01:55,559
corresponds to the inputs and the

47
00:01:51,960 --> 00:01:58,770
randomness that that the honest parties

48
00:01:55,560 --> 00:02:01,650
would have chosen and so this is

49
00:01:58,770 --> 00:02:04,649
naturally a much harder task than than

50
00:02:01,650 --> 00:02:07,770
the static corruption model and it yet

51
00:02:04,650 --> 00:02:09,599
represents a realistic model for for

52
00:02:07,770 --> 00:02:11,340
protocol composition in the sense that

53
00:02:09,598 --> 00:02:13,560
adversary can attack a protocol at any

54
00:02:11,340 --> 00:02:15,209
point moreover it's very important in

55
00:02:13,560 --> 00:02:17,130
composition theorem so for example in

56
00:02:15,209 --> 00:02:18,810
the UC composition theorem

57
00:02:17,130 --> 00:02:21,870
in order to make the entire thing work

58
00:02:18,810 --> 00:02:24,660
oftentimes sub protocols get you know

59
00:02:21,870 --> 00:02:26,460
parties get corrupted and a sub protocol

60
00:02:24,660 --> 00:02:28,770
that involves that set of parties has to

61
00:02:26,460 --> 00:02:30,840
then be explained to give a better

62
00:02:28,770 --> 00:02:35,850
explanation I've created a little video

63
00:02:30,840 --> 00:02:37,680
emoji that explains exactly why it's

64
00:02:35,850 --> 00:02:41,690
important to study adaptive security

65
00:02:37,680 --> 00:02:41,690
here so let you take a look at that here

66
00:02:49,070 --> 00:03:00,750
so this right here is what I consider to

67
00:02:51,660 --> 00:03:04,079
be the study of adaptive security the

68
00:03:00,750 --> 00:03:08,100
sound is not there but in this video the

69
00:03:04,080 --> 00:03:10,260
the skier is explaining why this creates

70
00:03:08,100 --> 00:03:12,269
a rush of adrenaline and I get the same

71
00:03:10,260 --> 00:03:18,600
rush of adrenaline when I study adaptive

72
00:03:12,270 --> 00:03:20,190
security so you might consider the

73
00:03:18,600 --> 00:03:22,710
static corruption model is one way of

74
00:03:20,190 --> 00:03:25,079
skiing down a mountain and the adaptive

75
00:03:22,710 --> 00:03:27,090
security model is another way of skiing

76
00:03:25,080 --> 00:03:28,170
down the mountain and so if you if you

77
00:03:27,090 --> 00:03:29,880
ever dream of skiing down a mountain

78
00:03:28,170 --> 00:03:32,489
like this you can understand why

79
00:03:29,880 --> 00:03:35,430
studying and achieving what you can

80
00:03:32,490 --> 00:03:39,170
achieve with the depth of security could

81
00:03:35,430 --> 00:03:42,240
be could be exhilarating so personally

82
00:03:39,170 --> 00:03:44,429
the if you ask me why I study this you

83
00:03:42,240 --> 00:03:48,480
can it's the same reason why this person

84
00:03:44,430 --> 00:03:51,000
skis this way and if you ask any funding

85
00:03:48,480 --> 00:03:54,660
agency why they should fund the research

86
00:03:51,000 --> 00:03:57,180
into secure adaptive security then then

87
00:03:54,660 --> 00:03:59,609
you might as well ask any any funder of

88
00:03:57,180 --> 00:04:04,080
this skier why they fund why they fund

89
00:03:59,610 --> 00:04:06,090
that activity it's the same answer so

90
00:04:04,080 --> 00:04:08,610
the scientific question of the talk is

91
00:04:06,090 --> 00:04:10,950
at what cost do we achieve adaptive

92
00:04:08,610 --> 00:04:15,660
security so let me give you a slight

93
00:04:10,950 --> 00:04:18,000
summary of NPC work so this blue line

94
00:04:15,660 --> 00:04:21,899
right here represents the n minus one

95
00:04:18,000 --> 00:04:24,690
security for NPC meaning that that the

96
00:04:21,899 --> 00:04:27,539
protocol tolerates n minus one

97
00:04:24,690 --> 00:04:29,580
corruptions and if you sort of see

98
00:04:27,540 --> 00:04:30,939
starting from gmw eighty-seven all the

99
00:04:29,580 --> 00:04:33,878
way to last year

100
00:04:30,939 --> 00:04:36,189
at Fox essentially we've achieved quite

101
00:04:33,879 --> 00:04:37,960
a bit in this particular model we've the

102
00:04:36,189 --> 00:04:40,449
the state of the art is two rounds of

103
00:04:37,960 --> 00:04:43,870
communication with communication right

104
00:04:40,449 --> 00:04:46,150
here that is sub linear so since the few

105
00:04:43,870 --> 00:04:48,279
years after the advent of fhe we were

106
00:04:46,150 --> 00:04:50,080
able to achieve multi-party computation

107
00:04:48,279 --> 00:04:51,909
that requires sub linear communication

108
00:04:50,080 --> 00:04:55,270
in the size of the circuit which is

109
00:04:51,909 --> 00:04:56,770
quite remarkable and a few years later

110
00:04:55,270 --> 00:04:58,900
were actually able to achieve that with

111
00:04:56,770 --> 00:05:01,210
two rounds with communication that's sub

112
00:04:58,900 --> 00:05:02,830
linear and also in various settings

113
00:05:01,210 --> 00:05:04,448
online work for one of the parties

114
00:05:02,830 --> 00:05:06,310
that's also some linear in the circuit

115
00:05:04,449 --> 00:05:09,219
so that's really an epitome of what one

116
00:05:06,310 --> 00:05:11,139
can achieve with standard n minus one

117
00:05:09,219 --> 00:05:16,180
security now when we consider the

118
00:05:11,139 --> 00:05:18,840
adaptive model we actually go from

119
00:05:16,180 --> 00:05:21,669
having sort of like the first sort of

120
00:05:18,840 --> 00:05:23,229
protocols in this model took sort of

121
00:05:21,669 --> 00:05:25,359
order D rounds reduce the depth of the

122
00:05:23,229 --> 00:05:26,859
circuit but recently we're actually been

123
00:05:25,360 --> 00:05:29,289
able to achieve two rounds but

124
00:05:26,860 --> 00:05:32,289
unfortunately not succinct communication

125
00:05:29,289 --> 00:05:34,300
so order C where C's the side of circuit

126
00:05:32,289 --> 00:05:37,469
communication there was a prior work

127
00:05:34,300 --> 00:05:40,300
right here by Garg and poly caronia do

128
00:05:37,469 --> 00:05:41,830
that achieved two rounds and sub linear

129
00:05:40,300 --> 00:05:44,139
communication but the way that they

130
00:05:41,830 --> 00:05:45,729
achieve it is by putting a reference

131
00:05:44,139 --> 00:05:49,379
string that has to be the size of the

132
00:05:45,729 --> 00:05:51,520
circuit and so these are the two first

133
00:05:49,379 --> 00:05:54,099
targets of this research can we achieve

134
00:05:51,520 --> 00:05:56,438
two round communication with sub linear

135
00:05:54,099 --> 00:05:58,120
communication and also a reference

136
00:05:56,439 --> 00:05:59,439
string that's sub linear in the circuit

137
00:05:58,120 --> 00:06:00,819
so there's really no cheating and in the

138
00:05:59,439 --> 00:06:03,539
answer to that question is yes I'll show

139
00:06:00,819 --> 00:06:06,490
you how we can achieve that another

140
00:06:03,539 --> 00:06:09,610
thing to study is the honest majority

141
00:06:06,490 --> 00:06:11,770
case right here so in assuming assuming

142
00:06:09,610 --> 00:06:14,199
an honest majority we can achieve MPC

143
00:06:11,770 --> 00:06:16,270
with either two rounds with sub linear

144
00:06:14,199 --> 00:06:20,740
communication or three rounds with fewer

145
00:06:16,270 --> 00:06:22,599
assumptions but in the adaptive case it

146
00:06:20,740 --> 00:06:24,009
actually takes three rounds to let the

147
00:06:22,599 --> 00:06:25,389
latest result right here takes three

148
00:06:24,009 --> 00:06:27,490
rounds and that achieved sub linear

149
00:06:25,389 --> 00:06:28,810
communication that's what every time I

150
00:06:27,490 --> 00:06:30,729
see that blue thing right there that's

151
00:06:28,810 --> 00:06:32,770
sub linear communication and so the

152
00:06:30,729 --> 00:06:35,620
question is can we actually achieve two

153
00:06:32,770 --> 00:06:36,909
rounds just like we can do in the static

154
00:06:35,620 --> 00:06:38,680
setting right so these two are the

155
00:06:36,909 --> 00:06:40,209
static settings and the outer ones are

156
00:06:38,680 --> 00:06:42,879
the adaptive settings and in fact we can

157
00:06:40,209 --> 00:06:44,080
do that and so that that'll be the the

158
00:06:42,879 --> 00:06:46,539
set of results that I want

159
00:06:44,080 --> 00:06:48,280
Blayne so to understand why this is

160
00:06:46,539 --> 00:06:50,889
actually difficult let me explain the

161
00:06:48,280 --> 00:06:53,530
bottleneck to achieving two rounds sub

162
00:06:50,889 --> 00:06:55,629
linear adaptive security for MPC so the

163
00:06:53,530 --> 00:06:57,849
framework for achieving MPC is basically

164
00:06:55,629 --> 00:06:59,590
work something like this all of the

165
00:06:57,849 --> 00:07:01,449
parties encrypt so everybody has

166
00:06:59,590 --> 00:07:03,969
basically a public key to some sort of

167
00:07:01,449 --> 00:07:06,250
threshold fhe scheme as well as some

168
00:07:03,969 --> 00:07:07,780
component of their secret key and in

169
00:07:06,250 --> 00:07:09,389
this model we can assume that is

170
00:07:07,780 --> 00:07:13,448
basically part of the setup model

171
00:07:09,389 --> 00:07:14,169
everybody encrypts their input with with

172
00:07:13,449 --> 00:07:17,080
this fhe

173
00:07:14,169 --> 00:07:18,969
and and then they broadcast that to

174
00:07:17,080 --> 00:07:21,909
everybody so after the first round

175
00:07:18,969 --> 00:07:26,229
everybody receives encryptions of

176
00:07:21,909 --> 00:07:28,539
everybody's input and then everybody

177
00:07:26,229 --> 00:07:30,039
runs the evaluation of the fhe to

178
00:07:28,539 --> 00:07:31,330
compute the function and this gives an

179
00:07:30,039 --> 00:07:32,949
encrypted version of the output

180
00:07:31,330 --> 00:07:35,169
everybody should have received the same

181
00:07:32,949 --> 00:07:37,719
why because they're computing the same

182
00:07:35,169 --> 00:07:40,389
function then they can use their secret

183
00:07:37,719 --> 00:07:42,759
key right here to decrypt why to produce

184
00:07:40,389 --> 00:07:44,560
some decryption share and then finally

185
00:07:42,759 --> 00:07:46,539
they can broadcast that and then given

186
00:07:44,560 --> 00:07:49,659
everybody else's decryption share of the

187
00:07:46,539 --> 00:07:51,550
output they can then compute the in the

188
00:07:49,659 --> 00:07:54,069
final value of the function right here

189
00:07:51,550 --> 00:07:56,139
by just using fu G so that's basically

190
00:07:54,069 --> 00:07:57,699
two rounds you can see why it's sub

191
00:07:56,139 --> 00:07:59,589
linear in communication because the only

192
00:07:57,699 --> 00:08:01,270
thing that's sent is basically an

193
00:07:59,589 --> 00:08:03,360
encryption of the input right here an

194
00:08:01,270 --> 00:08:07,930
encryption of the output right here in D

195
00:08:03,360 --> 00:08:09,639
and so basically a very good recipe for

196
00:08:07,930 --> 00:08:11,259
achieving the goal that we want is to

197
00:08:09,639 --> 00:08:14,259
basically come up with an adaptive lis

198
00:08:11,259 --> 00:08:16,180
secure fhe and so what would an adaptive

199
00:08:14,259 --> 00:08:17,710
lis secure fhe look like well

200
00:08:16,180 --> 00:08:20,919
essentially it needs to support the

201
00:08:17,710 --> 00:08:23,049
following features so basically after so

202
00:08:20,919 --> 00:08:25,120
a secret key is generated and then

203
00:08:23,050 --> 00:08:27,849
essentially a simulator needs to produce

204
00:08:25,120 --> 00:08:30,550
for the public key a set of ciphertext

205
00:08:27,849 --> 00:08:32,049
for a set of messages and again since

206
00:08:30,550 --> 00:08:33,549
it's adaptively secure the simulator

207
00:08:32,049 --> 00:08:36,250
doesn't know what these messages have to

208
00:08:33,549 --> 00:08:38,169
correspond to then later an adversary

209
00:08:36,250 --> 00:08:40,990
says you know what these messages need

210
00:08:38,169 --> 00:08:42,698
to correspond to M 1 through m l and so

211
00:08:40,990 --> 00:08:45,130
the adversary gets to basically select

212
00:08:42,698 --> 00:08:47,760
those in particular after seeing this

213
00:08:45,130 --> 00:08:50,079
adversary also gets the ciphertext and

214
00:08:47,760 --> 00:08:52,510
finally the simulator then needs to give

215
00:08:50,079 --> 00:08:54,520
an explanation of its ciphertext right

216
00:08:52,510 --> 00:08:56,709
so it basically needs to say given these

217
00:08:54,520 --> 00:08:57,790
messages m1 through ml I'm gonna produce

218
00:08:56,709 --> 00:09:00,880
a short seek

219
00:08:57,790 --> 00:09:03,790
that basically decrypts each of these

220
00:09:00,880 --> 00:09:05,650
ciphertext to m1 and so that's expressed

221
00:09:03,790 --> 00:09:07,689
in this formal experiment where now the

222
00:09:05,650 --> 00:09:10,060
adversary is given these cipher texts as

223
00:09:07,690 --> 00:09:11,650
well as the m1 there and basically can

224
00:09:10,060 --> 00:09:15,300
check that the decryption actually works

225
00:09:11,650 --> 00:09:17,500
out so that's the primitive that we need

226
00:09:15,300 --> 00:09:19,660
unfortunately as Katz

227
00:09:17,500 --> 00:09:21,190
thoreau Venga themand zu show this is

228
00:09:19,660 --> 00:09:23,110
actually impossible so this is the

229
00:09:21,190 --> 00:09:25,780
bottleneck for the the main problem that

230
00:09:23,110 --> 00:09:27,730
I study right here is that adaptively

231
00:09:25,780 --> 00:09:29,439
secure fhe is impossible and there's a

232
00:09:27,730 --> 00:09:29,950
really nice clever argument for why this

233
00:09:29,440 --> 00:09:32,050
wholes

234
00:09:29,950 --> 00:09:34,150
so imagine so if you recall from the

235
00:09:32,050 --> 00:09:36,130
previous experiment essentially s1 has

236
00:09:34,150 --> 00:09:39,310
to produce a bunch of cipher texts and

237
00:09:36,130 --> 00:09:41,800
now for any particular circuit CF for

238
00:09:39,310 --> 00:09:45,550
any function f we can basically run the

239
00:09:41,800 --> 00:09:47,290
evaluation of the fhe

240
00:09:45,550 --> 00:09:49,120
on this to produce basically a very

241
00:09:47,290 --> 00:09:50,980
short ciphertext right so this is

242
00:09:49,120 --> 00:09:53,260
basically a short ciphertext that

243
00:09:50,980 --> 00:09:56,320
supposedly represents the output of this

244
00:09:53,260 --> 00:09:59,050
function if this were if adaptive F if

245
00:09:56,320 --> 00:10:00,580
adaptively secure fhe was possible well

246
00:09:59,050 --> 00:10:03,760
then what we could do is compute the

247
00:10:00,580 --> 00:10:05,710
function f of m in this very sort of

248
00:10:03,760 --> 00:10:07,780
clever way so we could then run the

249
00:10:05,710 --> 00:10:10,060
second simulator that given each of

250
00:10:07,780 --> 00:10:12,430
these messages produces a short secret

251
00:10:10,060 --> 00:10:14,650
key right there and then we could

252
00:10:12,430 --> 00:10:17,050
basically decrypt this ciphertext using

253
00:10:14,650 --> 00:10:18,970
that short secret key and now you can

254
00:10:17,050 --> 00:10:21,040
sort of see why this is impossible

255
00:10:18,970 --> 00:10:24,100
because take a look at this blue box

256
00:10:21,040 --> 00:10:26,680
right here this blue box is a circuit

257
00:10:24,100 --> 00:10:29,050
that computes f of M the size of this

258
00:10:26,680 --> 00:10:32,199
circuit all it did it take basically it

259
00:10:29,050 --> 00:10:35,439
took C right here and since fhe is is

260
00:10:32,200 --> 00:10:37,150
naturally succinct then this is a short

261
00:10:35,440 --> 00:10:39,130
ciphertext that's basically the size of

262
00:10:37,150 --> 00:10:40,870
the output and the size of this circuit

263
00:10:39,130 --> 00:10:43,300
is basically the size of the simulator

264
00:10:40,870 --> 00:10:45,460
which only takes this input and 1

265
00:10:43,300 --> 00:10:47,380
through ml in for example it doesn't

266
00:10:45,460 --> 00:10:49,120
involve the circuit right there and then

267
00:10:47,380 --> 00:10:50,800
this decryption of the fhe which only

268
00:10:49,120 --> 00:10:53,320
takes the secret key that's coded in

269
00:10:50,800 --> 00:10:55,300
there so this entire circuit is really

270
00:10:53,320 --> 00:10:57,640
really small it's the size of the input

271
00:10:55,300 --> 00:10:59,829
and the output and if adaptively secure

272
00:10:57,640 --> 00:11:03,550
fhe was possible then one could compute

273
00:10:59,830 --> 00:11:05,680
F of M I eat any function in basically a

274
00:11:03,550 --> 00:11:08,740
circuit that has the size of its input

275
00:11:05,680 --> 00:11:10,390
and output and that basically ktz

276
00:11:08,740 --> 00:11:11,200
basically shows impossible there are

277
00:11:10,390 --> 00:11:13,210
certain

278
00:11:11,200 --> 00:11:15,070
functions for which this cannot hold and

279
00:11:13,210 --> 00:11:16,570
so therefore adaptively secure fhe

280
00:11:15,070 --> 00:11:18,700
cannot hold in general it's a very nice

281
00:11:16,570 --> 00:11:20,560
argument but it basically represents a

282
00:11:18,700 --> 00:11:23,410
bottleneck for using all of the prior

283
00:11:20,560 --> 00:11:24,939
work on MPC for this particular problem

284
00:11:23,410 --> 00:11:26,740
so we actually have to do something

285
00:11:24,940 --> 00:11:28,690
slightly different in fact the story

286
00:11:26,740 --> 00:11:30,940
gets even worse because erasers don't

287
00:11:28,690 --> 00:11:32,710
even help so erasers are this trick and

288
00:11:30,940 --> 00:11:34,810
adaptive security it's a natural

289
00:11:32,710 --> 00:11:36,640
assumption that says you know what each

290
00:11:34,810 --> 00:11:39,250
party can erase some of their random

291
00:11:36,640 --> 00:11:41,800
coins so that the simulator never has to

292
00:11:39,250 --> 00:11:43,840
produce them at a later point they don't

293
00:11:41,800 --> 00:11:45,609
help in this model for example we could

294
00:11:43,840 --> 00:11:48,010
erase the coins right after we encrypt

295
00:11:45,610 --> 00:11:51,400
and then erase the SK right after we

296
00:11:48,010 --> 00:11:53,950
decrypt it but the cats the ktz

297
00:11:51,400 --> 00:11:55,930
impossibility still plugs in because if

298
00:11:53,950 --> 00:11:57,820
we again draw the green box around

299
00:11:55,930 --> 00:12:00,189
things that happen before and the blue

300
00:11:57,820 --> 00:12:02,440
box that things that happen after the

301
00:12:00,190 --> 00:12:04,330
inputs are known then essentially the

302
00:12:02,440 --> 00:12:07,360
same argument is going to hold this

303
00:12:04,330 --> 00:12:09,730
would basically the the problem is of

304
00:12:07,360 --> 00:12:14,230
course if a corruption happens right

305
00:12:09,730 --> 00:12:16,150
here okay the the party right here still

306
00:12:14,230 --> 00:12:18,040
needs to keep its SK I in order to

307
00:12:16,150 --> 00:12:20,380
complete this the function and so if the

308
00:12:18,040 --> 00:12:22,060
corruption happens right here then the

309
00:12:20,380 --> 00:12:23,710
simulator would need to create a secret

310
00:12:22,060 --> 00:12:26,079
key that explains the ciphertext and

311
00:12:23,710 --> 00:12:29,680
then that invokes essentially the the

312
00:12:26,080 --> 00:12:31,300
ktz impossibility so two rounds

313
00:12:29,680 --> 00:12:33,579
sublinear and PC that's adaptively

314
00:12:31,300 --> 00:12:35,380
secure it has a bottleneck and we need a

315
00:12:33,580 --> 00:12:37,630
new idea to basically achieve it and

316
00:12:35,380 --> 00:12:38,830
essentially it's going to be the same

317
00:12:37,630 --> 00:12:41,470
technique that we use all over

318
00:12:38,830 --> 00:12:43,210
cryptography it with a different twist

319
00:12:41,470 --> 00:12:45,070
so we're gonna take basically two

320
00:12:43,210 --> 00:12:47,620
primitives one primitive that is

321
00:12:45,070 --> 00:12:49,540
succinct but not adaptively secure one

322
00:12:47,620 --> 00:12:51,490
that is adaptive but not succinct and

323
00:12:49,540 --> 00:12:53,050
then we are going to basically combine

324
00:12:51,490 --> 00:12:54,730
them in several ways and we do this for

325
00:12:53,050 --> 00:12:56,680
all of their basic results you can look

326
00:12:54,730 --> 00:12:58,870
at our paper is essentially applying

327
00:12:56,680 --> 00:13:02,020
this with various components that we

328
00:12:58,870 --> 00:13:03,760
need the first for our main result the

329
00:13:02,020 --> 00:13:07,480
major component that we need is this new

330
00:13:03,760 --> 00:13:09,460
technique from Willie Howe Tech and

331
00:13:07,480 --> 00:13:11,770
Daniel from last year it's called

332
00:13:09,460 --> 00:13:14,350
laconic function evaluation so it's a

333
00:13:11,770 --> 00:13:17,079
kind of a dual of fhe and essentially

334
00:13:14,350 --> 00:13:20,530
what it allows us to do is to generate a

335
00:13:17,080 --> 00:13:23,570
very compact CRS that basically depends

336
00:13:20,530 --> 00:13:25,850
on the depth of function

337
00:13:23,570 --> 00:13:27,680
that we would like to compute so if we

338
00:13:25,850 --> 00:13:30,620
want to compute depth 8e functions we

339
00:13:27,680 --> 00:13:34,219
can just run create a CRS that basically

340
00:13:30,620 --> 00:13:36,769
handles all depth 8e functions then one

341
00:13:34,220 --> 00:13:39,079
can basically take essentially any

342
00:13:36,769 --> 00:13:41,420
circuit right here that is of the right

343
00:13:39,079 --> 00:13:43,399
depth and compress it to create a very

344
00:13:41,420 --> 00:13:48,319
small digest see of that particular

345
00:13:43,399 --> 00:13:50,509
circuit next one can basically encrypt a

346
00:13:48,319 --> 00:13:52,790
particular input right here using the

347
00:13:50,509 --> 00:13:54,949
digest in the CRS and that produces

348
00:13:52,790 --> 00:13:58,269
ciphertext which basically encodes that

349
00:13:54,949 --> 00:14:01,160
input and finally one can decrypt that

350
00:13:58,269 --> 00:14:03,529
ciphertext using this circuit and

351
00:14:01,160 --> 00:14:07,069
essentially the CRS to basically produce

352
00:14:03,529 --> 00:14:09,470
the output Y and notice why this avoids

353
00:14:07,069 --> 00:14:11,740
the impossibility right here because if

354
00:14:09,470 --> 00:14:14,810
we basically plug these components in

355
00:14:11,740 --> 00:14:17,029
when we actually decrypt here unlike fhe

356
00:14:14,810 --> 00:14:19,518
which just takes the SK and the C right

357
00:14:17,029 --> 00:14:21,860
here the laconic function evaluation

358
00:14:19,519 --> 00:14:24,350
decryption actually takes the circuit as

359
00:14:21,860 --> 00:14:26,180
the input so this box which computes the

360
00:14:24,350 --> 00:14:27,680
circuit is in fact the size of the

361
00:14:26,180 --> 00:14:30,620
circuit and therefore avoids the

362
00:14:27,680 --> 00:14:32,180
impossibility of ktz all right so this

363
00:14:30,620 --> 00:14:34,430
is going to be our new primitive and

364
00:14:32,180 --> 00:14:36,949
thus we're going to use it in the

365
00:14:34,430 --> 00:14:40,370
following way so we're going to generate

366
00:14:36,949 --> 00:14:42,050
a c RS everybody is then going to

367
00:14:40,370 --> 00:14:43,339
compute once we know the circuit the

368
00:14:42,050 --> 00:14:44,689
circuit that we want to compute all of

369
00:14:43,339 --> 00:14:46,579
the parties are going to compute this

370
00:14:44,690 --> 00:14:48,079
digest which at this point can is

371
00:14:46,579 --> 00:14:51,079
deterministic it doesn't require any

372
00:14:48,079 --> 00:14:53,239
random points to compress and then we

373
00:14:51,079 --> 00:14:55,430
are going to basically jointly encrypt

374
00:14:53,240 --> 00:14:57,230
all of the inputs of all of the parties

375
00:14:55,430 --> 00:14:59,000
and the way we're going to do that is

376
00:14:57,230 --> 00:15:02,810
we're actually going to use if you saw

377
00:14:59,000 --> 00:15:05,660
that BL p.m. the result from 18 that is

378
00:15:02,810 --> 00:15:08,029
a two-round NPC that's adaptively secure

379
00:15:05,660 --> 00:15:11,540
but not succinct and we're going to use

380
00:15:08,029 --> 00:15:14,420
that to compute the cipher text for the

381
00:15:11,540 --> 00:15:15,980
LFE scheme and then once we know the

382
00:15:14,420 --> 00:15:18,380
cipher text everybody will basically

383
00:15:15,980 --> 00:15:22,790
erase the random coins that they used in

384
00:15:18,380 --> 00:15:25,009
this and basically decrypt the the

385
00:15:22,790 --> 00:15:28,819
ciphertext and so therefore since this

386
00:15:25,009 --> 00:15:30,589
one is adaptively secure and we use in

387
00:15:28,819 --> 00:15:32,029
our security proof one more property we

388
00:15:30,589 --> 00:15:34,819
showed that the LFE is all but one

389
00:15:32,029 --> 00:15:37,310
secure adaptive all but one adaptively

390
00:15:34,819 --> 00:15:39,560
secure with with an erasure we

391
00:15:37,310 --> 00:15:41,150
can basically prove the result that we

392
00:15:39,560 --> 00:15:43,069
want to prove

393
00:15:41,150 --> 00:15:45,380
basically composing something that is

394
00:15:43,070 --> 00:15:47,000
adaptive but not succinct with something

395
00:15:45,380 --> 00:15:48,620
that is succinct but not adaptive to get

396
00:15:47,000 --> 00:15:51,410
the basically the best of both worlds

397
00:15:48,620 --> 00:15:53,750
there and now one can ask how do we

398
00:15:51,410 --> 00:15:56,360
remove erasers and one can actually do

399
00:15:53,750 --> 00:15:58,430
that using a result by document solid

400
00:15:56,360 --> 00:16:00,020
Katzen rao which is called the

401
00:15:58,430 --> 00:16:02,989
explaining ability compiler framework

402
00:16:00,020 --> 00:16:04,550
and this can basically this can

403
00:16:02,990 --> 00:16:07,040
basically transform the previous

404
00:16:04,550 --> 00:16:09,349
protocol we have to explain those random

405
00:16:07,040 --> 00:16:12,290
coins RI but unfortunately it requires

406
00:16:09,350 --> 00:16:14,390
IO but unlike the prior results that use

407
00:16:12,290 --> 00:16:15,680
IO this will not require a common

408
00:16:14,390 --> 00:16:17,740
reference string that's the size of the

409
00:16:15,680 --> 00:16:21,979
circuit I'll actually be a very small

410
00:16:17,740 --> 00:16:24,560
explanation for the LFE random coins so

411
00:16:21,980 --> 00:16:26,510
essentially a summary of this part of a

412
00:16:24,560 --> 00:16:28,760
results we basically achieve a two round

413
00:16:26,510 --> 00:16:31,069
protocol and notice it's going to be

414
00:16:28,760 --> 00:16:33,050
succinct in the communication it's going

415
00:16:31,070 --> 00:16:34,850
to be succinct in the online computation

416
00:16:33,050 --> 00:16:36,050
and it's also going to be succinct in

417
00:16:34,850 --> 00:16:38,300
the setup right here

418
00:16:36,050 --> 00:16:40,729
in contrast essentially the prior work

419
00:16:38,300 --> 00:16:44,240
from from last year it also achieves two

420
00:16:40,730 --> 00:16:46,370
rounds but wasn't succinct and and Garg

421
00:16:44,240 --> 00:16:49,100
and Antigone basically have a result

422
00:16:46,370 --> 00:16:50,560
that is two rounds and succinct but

423
00:16:49,100 --> 00:16:52,610
requires a set up size that's

424
00:16:50,560 --> 00:16:54,410
essentially the same size of the circuit

425
00:16:52,610 --> 00:16:56,089
and that's why we basically improve upon

426
00:16:54,410 --> 00:16:58,370
both of them to achieve the best of both

427
00:16:56,089 --> 00:17:00,650
worlds in the fully adaptive in the

428
00:16:58,370 --> 00:17:03,140
fully adaptive case we also consider

429
00:17:00,650 --> 00:17:05,810
special cases in two party protocols

430
00:17:03,140 --> 00:17:07,609
where essentially Alice and Bob can be

431
00:17:05,810 --> 00:17:09,770
optimal in terms of communication and

432
00:17:07,609 --> 00:17:11,500
computation so this is kind of an

433
00:17:09,770 --> 00:17:14,030
amazing thing that we can we can achieve

434
00:17:11,500 --> 00:17:16,550
alice optimal and Bob optimal protocols

435
00:17:14,030 --> 00:17:18,560
using just fhe but once we add adaptive

436
00:17:16,550 --> 00:17:20,629
security we can basically only do it for

437
00:17:18,560 --> 00:17:22,730
Bob optimal protocols we can show that

438
00:17:20,630 --> 00:17:26,030
essentially alice optimal protocols are

439
00:17:22,730 --> 00:17:27,410
impossible for more information I refer

440
00:17:26,030 --> 00:17:29,870
you to the paper there I want to

441
00:17:27,410 --> 00:17:32,000
basically summarize the rest of the

442
00:17:29,870 --> 00:17:34,820
results in the paper which basically

443
00:17:32,000 --> 00:17:36,860
consider how we can achieve lesser

444
00:17:34,820 --> 00:17:38,240
versions of adaptive security so that's

445
00:17:36,860 --> 00:17:41,178
in the case of for example honest

446
00:17:38,240 --> 00:17:43,910
majority and all but one corruptions and

447
00:17:41,179 --> 00:17:46,970
as an example of one of the building

448
00:17:43,910 --> 00:17:50,140
blocks right there we consider non

449
00:17:46,970 --> 00:17:51,550
interactive xur knowledge so gos

450
00:17:50,140 --> 00:17:54,700
basically show

451
00:17:51,550 --> 00:17:56,620
to achieve adaptive ni ZK but again it's

452
00:17:54,700 --> 00:17:58,300
not succinct because the size of the

453
00:17:56,620 --> 00:18:01,830
proof is going to be related to the size

454
00:17:58,300 --> 00:18:01,830
of the circuit that you're considering

455
00:18:02,160 --> 00:18:07,780
GG IPSS they show how to achieve

456
00:18:04,840 --> 00:18:10,389
succinct ni ZK and the way they do it is

457
00:18:07,780 --> 00:18:12,460
basically what you do is you the prover

458
00:18:10,390 --> 00:18:14,860
generates a secret key in a public key

459
00:18:12,460 --> 00:18:17,020
for an fhe scheme and then you basically

460
00:18:14,860 --> 00:18:19,240
encrypt the witness to produce

461
00:18:17,020 --> 00:18:21,040
essentially these are encryptions of the

462
00:18:19,240 --> 00:18:24,280
witness right here and then you can

463
00:18:21,040 --> 00:18:25,540
basically fhe evaluate the the predicate

464
00:18:24,280 --> 00:18:27,910
of the language that you want to do to

465
00:18:25,540 --> 00:18:30,159
produce essentially the result this

466
00:18:27,910 --> 00:18:32,200
right here is an encryption of one if if

467
00:18:30,160 --> 00:18:33,580
X was in the language then this right

468
00:18:32,200 --> 00:18:35,830
here is the the predicate for the

469
00:18:33,580 --> 00:18:37,210
language then this would be an

470
00:18:35,830 --> 00:18:40,710
encryption of one and then all you need

471
00:18:37,210 --> 00:18:43,330
to do is show basically an ni zk that

472
00:18:40,710 --> 00:18:46,330
essentially that the fhe decryption of

473
00:18:43,330 --> 00:18:48,250
this is basically 1 the problem here is

474
00:18:46,330 --> 00:18:50,649
that it can't be adaptively secure

475
00:18:48,250 --> 00:18:53,950
because of the prior fhe impossibility

476
00:18:50,650 --> 00:18:55,690
so to get around that we basically have

477
00:18:53,950 --> 00:18:57,700
to apply our same methodology right here

478
00:18:55,690 --> 00:18:59,770
and we're going to use this new

479
00:18:57,700 --> 00:19:02,560
technique or this older technique from

480
00:18:59,770 --> 00:19:04,450
GVW which is a homomorphic trapdoor

481
00:19:02,560 --> 00:19:06,190
functions and they're essentially you

482
00:19:04,450 --> 00:19:07,750
can think of them as homomorphic

483
00:19:06,190 --> 00:19:10,150
commitments and that's kind of the

484
00:19:07,750 --> 00:19:13,330
easiest way to show that essentially

485
00:19:10,150 --> 00:19:15,130
there's a way to evaluate most like

486
00:19:13,330 --> 00:19:16,750
essentially an inner approach to

487
00:19:15,130 --> 00:19:18,640
evaluation and an outer approach to

488
00:19:16,750 --> 00:19:19,960
evaluation and of course there's a way

489
00:19:18,640 --> 00:19:23,440
to have trapdoor way of basically

490
00:19:19,960 --> 00:19:25,000
inverting a particular image that of

491
00:19:23,440 --> 00:19:27,490
course this part will only be used in

492
00:19:25,000 --> 00:19:29,770
the security proof so essentially the

493
00:19:27,490 --> 00:19:31,870
method of our protocol is to work as

494
00:19:29,770 --> 00:19:33,700
follows so just like before what we're

495
00:19:31,870 --> 00:19:35,500
going to basically do is commit to our

496
00:19:33,700 --> 00:19:37,840
witness so these are the commitments to

497
00:19:35,500 --> 00:19:39,310
each of the bits and then we're and then

498
00:19:37,840 --> 00:19:42,100
we're basically going to produce an

499
00:19:39,310 --> 00:19:43,510
inner and an outer evaluation the outer

500
00:19:42,100 --> 00:19:45,370
evaluation is something that the

501
00:19:43,510 --> 00:19:47,320
verifier can do can just use these

502
00:19:45,370 --> 00:19:50,370
commitments to the bits and basically

503
00:19:47,320 --> 00:19:52,659
get a commitment to the output bit and

504
00:19:50,370 --> 00:19:55,179
and then basically what we're going to

505
00:19:52,660 --> 00:19:57,700
use is an adaptive enigk the one that

506
00:19:55,180 --> 00:19:59,680
the gos one that i just discussed to

507
00:19:57,700 --> 00:20:03,040
basically show that this commitment

508
00:19:59,680 --> 00:20:05,200
opens to one okay so that again is a way

509
00:20:03,040 --> 00:20:06,730
of using something that's

510
00:20:05,200 --> 00:20:08,410
something that's adaptive but not

511
00:20:06,730 --> 00:20:09,790
succinct and something that's distinct

512
00:20:08,410 --> 00:20:12,100
but not adaptive and combining them to

513
00:20:09,790 --> 00:20:14,320
get this we can use this now succinct

514
00:20:12,100 --> 00:20:19,840
adaptive ni ck for a number of other

515
00:20:14,320 --> 00:20:22,689
results so for example um in the all but

516
00:20:19,840 --> 00:20:25,360
one corruption model we can basically

517
00:20:22,690 --> 00:20:27,190
achieve a two round protocol matching

518
00:20:25,360 --> 00:20:30,100
the best static model right here that

519
00:20:27,190 --> 00:20:33,120
only requires basically succinct

520
00:20:30,100 --> 00:20:36,429
communication and requires essentially

521
00:20:33,120 --> 00:20:38,050
a threshold PK we can basically remove

522
00:20:36,430 --> 00:20:41,800
the assumption of the threshold PKI

523
00:20:38,050 --> 00:20:44,800
by by basically expanding the number of

524
00:20:41,800 --> 00:20:46,389
rounds so essentially that's an

525
00:20:44,800 --> 00:20:48,370
improvement of the prior work which

526
00:20:46,390 --> 00:20:51,430
required three rounds right here and

527
00:20:48,370 --> 00:20:53,860
this basically matches the static case

528
00:20:51,430 --> 00:20:55,900
right there in the honest majority case

529
00:20:53,860 --> 00:20:58,120
we can essentially apply similar

530
00:20:55,900 --> 00:21:01,120
techniques and get again a two round

531
00:20:58,120 --> 00:21:03,669
protocol that matches the the best

532
00:21:01,120 --> 00:21:05,679
static model protocol and that

533
00:21:03,670 --> 00:21:08,080
essentially requires essentially the

534
00:21:05,680 --> 00:21:10,240
same the same assumptions right here and

535
00:21:08,080 --> 00:21:14,409
we can of course remove the need for a

536
00:21:10,240 --> 00:21:16,960
threshold PKI by by basically requiring

537
00:21:14,410 --> 00:21:20,290
by combining it with this damn cardi shy

538
00:21:16,960 --> 00:21:23,200
protocol that that that's constant

539
00:21:20,290 --> 00:21:24,580
constant number of rounds okay so what I

540
00:21:23,200 --> 00:21:26,680
want to do in the last few minutes is

541
00:21:24,580 --> 00:21:28,570
explain some of the open questions here

542
00:21:26,680 --> 00:21:31,240
the sort of gaps that are still left in

543
00:21:28,570 --> 00:21:34,060
this elegant study of adaptive security

544
00:21:31,240 --> 00:21:37,000
or the the field essentially and if you

545
00:21:34,060 --> 00:21:38,950
the first basic question is essentially

546
00:21:37,000 --> 00:21:43,570
the the all prior techniques that are

547
00:21:38,950 --> 00:21:46,720
succinct and that are basically succinct

548
00:21:43,570 --> 00:21:49,480
if we ignore everything else basically

549
00:21:46,720 --> 00:21:52,360
require either IO or they require

550
00:21:49,480 --> 00:21:54,760
erasers and that's a question of whether

551
00:21:52,360 --> 00:21:56,740
one can get around that so I or erasers

552
00:21:54,760 --> 00:22:01,629
are they necessary for adaptively

553
00:21:56,740 --> 00:22:03,430
succinct MPC the next question is

554
00:22:01,630 --> 00:22:05,650
essentially reference strings and

555
00:22:03,430 --> 00:22:08,470
erasers so either we use a ratios right

556
00:22:05,650 --> 00:22:10,420
here or we use reference drinks again

557
00:22:08,470 --> 00:22:12,700
that's related to the question of IO but

558
00:22:10,420 --> 00:22:15,010
much simpler can we actually reduce the

559
00:22:12,700 --> 00:22:17,860
reference string to a random string and

560
00:22:15,010 --> 00:22:19,690
and and basically

561
00:22:17,860 --> 00:22:23,740
remove that basic bottleneck and really

562
00:22:19,690 --> 00:22:25,900
achieve parity and and finally the the

563
00:22:23,740 --> 00:22:28,150
last question is can we consider setup

564
00:22:25,900 --> 00:22:30,010
relaxations so in the all but one

565
00:22:28,150 --> 00:22:32,740
adaptive case we basically need this

566
00:22:30,010 --> 00:22:34,809
threshold PKI right here and is that

567
00:22:32,740 --> 00:22:36,940
basically necessary here all of the

568
00:22:34,809 --> 00:22:38,830
results that that have two or three

569
00:22:36,940 --> 00:22:42,549
rounds basically require this threshold

570
00:22:38,830 --> 00:22:43,840
PKI and the the prior results basically

571
00:22:42,549 --> 00:22:45,820
that have constant number of rounds

572
00:22:43,840 --> 00:22:47,709
don't and so can you achieve basically

573
00:22:45,820 --> 00:22:49,780
optimal round complexity without these

574
00:22:47,710 --> 00:22:54,610
this basic set of assumptions these I

575
00:22:49,780 --> 00:22:56,379
think are addressable and basically one

576
00:22:54,610 --> 00:22:58,629
can basically attack these particular

577
00:22:56,380 --> 00:23:00,160
questions we thought about them but I

578
00:22:58,630 --> 00:23:02,049
think they're there they're basically

579
00:23:00,160 --> 00:23:05,590
the next in line to fall from from this

580
00:23:02,049 --> 00:23:06,460
basic question and I'll basically leave

581
00:23:05,590 --> 00:23:08,639
you with that thank you for your

582
00:23:06,460 --> 00:23:08,640
attention

583
00:23:13,500 --> 00:23:27,130
questions just comment so it's a great

584
00:23:23,140 --> 00:23:27,850
working great talking animation this is

585
00:23:27,130 --> 00:23:31,289
no comment

586
00:23:27,850 --> 00:23:34,750
it actually is a work on you know

587
00:23:31,289 --> 00:23:36,929
extinct theories 16 communication Ram

588
00:23:34,750 --> 00:23:41,970
Quebec City to ground adaptive secure

589
00:23:36,929 --> 00:23:45,820
empathy pkc 2017 with Roxanna and Muto

590
00:23:41,970 --> 00:23:49,570
it's based on the of the work of German

591
00:23:45,820 --> 00:23:54,580
Antigone I just make the mission are you

592
00:23:49,570 --> 00:23:56,020
talking to a CPV yes yeah so that's

593
00:23:54,580 --> 00:23:57,879
constant number of rounds there right no

594
00:23:56,020 --> 00:24:01,029
no it's one it's two rounds it's two

595
00:23:57,880 --> 00:24:03,520
rounds but but it's see through these hi

596
00:24:01,029 --> 00:24:07,659
you know it's of exponential io and the

597
00:24:03,520 --> 00:24:09,279
same framework so okay we basically miss

598
00:24:07,659 --> 00:24:10,929
sighted you here in this in this result

599
00:24:09,279 --> 00:24:13,059
because we're aware of the work but I

600
00:24:10,929 --> 00:24:18,899
guess yeah but never mind but then you

601
00:24:13,059 --> 00:24:23,200
you protocol is much better thank you

602
00:24:18,899 --> 00:24:25,649
thanks for the citation any other

603
00:24:23,200 --> 00:24:25,649
questions

604
00:24:27,360 --> 00:24:31,919
[Applause]

