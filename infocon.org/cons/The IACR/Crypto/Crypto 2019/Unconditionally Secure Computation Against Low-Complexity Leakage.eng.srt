1
00:00:04,920 --> 00:00:08,430
thanks for the introduction and I'm

2
00:00:06,960 --> 00:00:09,930
going to talk about unconditionally

3
00:00:08,430 --> 00:00:12,450
secure computation against low

4
00:00:09,930 --> 00:00:15,510
complexity leakage so let me start this

5
00:00:12,450 --> 00:00:16,500
talk by giving you a scenario so let's

6
00:00:15,510 --> 00:00:18,600
say that you have a piece of

7
00:00:16,500 --> 00:00:20,970
cryptographic Hardware with some secret

8
00:00:18,600 --> 00:00:22,740
key embedded inside and this Hardware

9
00:00:20,970 --> 00:00:24,599
might be used to perform some sensitive

10
00:00:22,740 --> 00:00:27,150
computation such as digitally signing

11
00:00:24,600 --> 00:00:28,950
your financial transactions so even

12
00:00:27,150 --> 00:00:30,689
though this Hardware may not be faulty

13
00:00:28,950 --> 00:00:32,519
and the cryptographic algorithms

14
00:00:30,690 --> 00:00:34,620
implemented by this Hardware are in fact

15
00:00:32,520 --> 00:00:36,390
secure there might be other means

16
00:00:34,620 --> 00:00:38,760
through which an attacker might be able

17
00:00:36,390 --> 00:00:41,280
to extract information about the secret

18
00:00:38,760 --> 00:00:42,989
key inside this Hardware so these class

19
00:00:41,280 --> 00:00:44,760
of attacks are called as side-channel

20
00:00:42,989 --> 00:00:47,250
attacks and there has been a lot of work

21
00:00:44,760 --> 00:00:49,800
in our community space studying specific

22
00:00:47,250 --> 00:00:51,930
side channels so the question we would

23
00:00:49,800 --> 00:00:53,819
like to answer is that how do we protect

24
00:00:51,930 --> 00:00:56,610
our sensitive computations against

25
00:00:53,820 --> 00:00:58,590
leakage from these side channels so one

26
00:00:56,610 --> 00:01:00,930
way to do this is to use adopt measures

27
00:00:58,590 --> 00:01:02,100
for example using a Faraday cage to

28
00:01:00,930 --> 00:01:04,890
protect against electromagnetic

29
00:01:02,100 --> 00:01:06,810
radiation leakage however a major

30
00:01:04,890 --> 00:01:09,390
drawback of this approach is that for

31
00:01:06,810 --> 00:01:11,549
every new kind of attack you must come

32
00:01:09,390 --> 00:01:13,790
up with a new kind of countermeasure and

33
00:01:11,549 --> 00:01:16,470
this is usually infeasible in practice

34
00:01:13,790 --> 00:01:18,330
so on the other hand a clean and a

35
00:01:16,470 --> 00:01:20,310
theoretically sound way to protect

36
00:01:18,330 --> 00:01:22,830
against ID channel leakage is to use a

37
00:01:20,310 --> 00:01:26,100
primitive called as leakage resilient

38
00:01:22,830 --> 00:01:27,780
circuit compilers and this primitive was

39
00:01:26,100 --> 00:01:30,030
introduced in this highly influential

40
00:01:27,780 --> 00:01:32,670
work of Asia is a high-end partner and

41
00:01:30,030 --> 00:01:34,950
in this work will focus on this approach

42
00:01:32,670 --> 00:01:37,920
to protect against side-channel leakage

43
00:01:34,950 --> 00:01:40,799
so let me now explain what is meant by

44
00:01:37,920 --> 00:01:43,320
alligator salient circuit compiler so

45
00:01:40,799 --> 00:01:47,520
let's model the sensitive computation as

46
00:01:43,320 --> 00:01:49,048
a boolean circuit C along with that

47
00:01:47,520 --> 00:01:52,048
takes in a secret input and produces

48
00:01:49,049 --> 00:01:53,549
some output so a leakage resilient

49
00:01:52,049 --> 00:01:56,610
circuit compiler as the name suggests

50
00:01:53,549 --> 00:01:59,850
takes in this circuit and transforms

51
00:01:56,610 --> 00:02:04,049
this into a randomized circuit C hat

52
00:01:59,850 --> 00:02:06,839
along with an encoder and a decoder so

53
00:02:04,049 --> 00:02:09,000
this encoder takes in this secret input

54
00:02:06,840 --> 00:02:11,459
and produces an encoded version of this

55
00:02:09,000 --> 00:02:13,530
input and when we run this randomized

56
00:02:11,459 --> 00:02:15,900
circuit C hat on the encoded input it

57
00:02:13,530 --> 00:02:17,940
produces the encoded output and which

58
00:02:15,900 --> 00:02:20,790
will pass through the decoder produces

59
00:02:17,940 --> 00:02:22,380
output in the clear so this is the

60
00:02:20,790 --> 00:02:24,359
functionality and we require two

61
00:02:22,380 --> 00:02:26,130
properties to be satisfied from the leak

62
00:02:24,360 --> 00:02:28,290
a resilient circuit compiler so the

63
00:02:26,130 --> 00:02:30,060
first is the correctness property which

64
00:02:28,290 --> 00:02:32,340
says that the output that we obtain by

65
00:02:30,060 --> 00:02:34,500
running C hat on some secret input is

66
00:02:32,340 --> 00:02:36,450
the same as the output that we obtained

67
00:02:34,500 --> 00:02:38,190
when running the original circuit C on

68
00:02:36,450 --> 00:02:40,440
the same input in other words the

69
00:02:38,190 --> 00:02:42,720
functionality is preserved and the

70
00:02:40,440 --> 00:02:44,940
second property is the security property

71
00:02:42,720 --> 00:02:47,609
which roughly states that any leakage

72
00:02:44,940 --> 00:02:49,290
acting on the wires of C hat does not

73
00:02:47,610 --> 00:02:52,860
learn any information about the

74
00:02:49,290 --> 00:02:55,620
underlying secret input so this security

75
00:02:52,860 --> 00:02:57,660
notion is formalized using a notion

76
00:02:55,620 --> 00:03:00,480
called as one short leakage security and

77
00:02:57,660 --> 00:03:03,750
let me now explain this notion so let's

78
00:03:00,480 --> 00:03:05,970
say that we have a C hat executed on

79
00:03:03,750 --> 00:03:08,400
some secret input X and let's say that

80
00:03:05,970 --> 00:03:11,250
we have some leakage function acting on

81
00:03:08,400 --> 00:03:13,590
the wires of this C hat so one-shot

82
00:03:11,250 --> 00:03:15,590
leakage security states that the output

83
00:03:13,590 --> 00:03:18,660
of this leakage function is

84
00:03:15,590 --> 00:03:20,820
statistically close to its output when C

85
00:03:18,660 --> 00:03:23,010
hat is run on a different input X Prime

86
00:03:20,820 --> 00:03:25,079
so in other words what the security

87
00:03:23,010 --> 00:03:27,120
notion states is that any leakage

88
00:03:25,080 --> 00:03:31,020
function cannot distinguish whether the

89
00:03:27,120 --> 00:03:33,090
secret input was X or explain so here we

90
00:03:31,020 --> 00:03:35,280
implicitly assume that there is no

91
00:03:33,090 --> 00:03:38,459
leakage acting on the wires of both the

92
00:03:35,280 --> 00:03:41,160
encoder as well as the decoder so notice

93
00:03:38,459 --> 00:03:43,140
that assuming that the encoder is leak

94
00:03:41,160 --> 00:03:45,329
free is in fact necessary because if you

95
00:03:43,140 --> 00:03:47,549
allow any sort of liquid on the encoder

96
00:03:45,330 --> 00:03:50,790
then it can the leakage function can

97
00:03:47,550 --> 00:03:52,590
just look at a few bits of the input and

98
00:03:50,790 --> 00:03:56,179
then output it so there is no hope of

99
00:03:52,590 --> 00:03:58,620
giving any sort of security however this

100
00:03:56,180 --> 00:04:00,750
security notion additionally assumes

101
00:03:58,620 --> 00:04:03,930
that the decoder is also leak free this

102
00:04:00,750 --> 00:04:06,690
is somewhat a strong assumption so given

103
00:04:03,930 --> 00:04:08,880
this that the encoder and decoder ZAR

104
00:04:06,690 --> 00:04:11,190
leak free we in order to disallow some

105
00:04:08,880 --> 00:04:13,470
trivial solutions we need both the

106
00:04:11,190 --> 00:04:15,959
encoder and the decoder to be universal

107
00:04:13,470 --> 00:04:19,769
and their sizes must be independent of

108
00:04:15,959 --> 00:04:21,209
the size of the circuit however as I had

109
00:04:19,769 --> 00:04:23,100
mentioned before there are some

110
00:04:21,209 --> 00:04:25,200
drawbacks of this security notions

111
00:04:23,100 --> 00:04:27,240
firstly it assumes the existence of a

112
00:04:25,200 --> 00:04:30,210
trusted decoder which is a fairly strong

113
00:04:27,240 --> 00:04:31,550
assumption and additionally the leakage

114
00:04:30,210 --> 00:04:33,590
is only happening from

115
00:04:31,550 --> 00:04:36,500
single execution of the circuit she had

116
00:04:33,590 --> 00:04:38,390
so to overcome both these limitations a

117
00:04:36,500 --> 00:04:40,190
stronger notion of security called as

118
00:04:38,390 --> 00:04:42,409
continuously gate security has been

119
00:04:40,190 --> 00:04:44,420
proposed in the same work of Ishay Sahai

120
00:04:42,410 --> 00:04:46,310
and Wagner and I would just give you a

121
00:04:44,420 --> 00:04:48,020
brief overview of the continuous leakage

122
00:04:46,310 --> 00:04:50,480
model without going into the formal

123
00:04:48,020 --> 00:04:52,219
details so in the continuous leakage

124
00:04:50,480 --> 00:04:54,800
setting the boolean circuits that we

125
00:04:52,220 --> 00:04:57,080
want to protect our models to to store

126
00:04:54,800 --> 00:05:00,320
secrets and such circuits are called as

127
00:04:57,080 --> 00:05:02,150
stateful circuits and the security

128
00:05:00,320 --> 00:05:05,659
definition is modeled as a game between

129
00:05:02,150 --> 00:05:08,210
an adversary and a challenger so the

130
00:05:05,660 --> 00:05:10,370
adversary is now allowed to get leakage

131
00:05:08,210 --> 00:05:13,729
from many different executions of the

132
00:05:10,370 --> 00:05:16,040
circuit on which stores the same secret

133
00:05:13,730 --> 00:05:18,470
so there is a continuous notion of

134
00:05:16,040 --> 00:05:20,450
leakage which is happening and in each

135
00:05:18,470 --> 00:05:22,850
of these executions the leakage function

136
00:05:20,450 --> 00:05:24,590
can be adaptively chosen based on the

137
00:05:22,850 --> 00:05:26,840
prior information available with the

138
00:05:24,590 --> 00:05:29,630
adversary and most importantly there is

139
00:05:26,840 --> 00:05:32,510
no trusted decoder so even the wires of

140
00:05:29,630 --> 00:05:34,159
the decoder can be subject to leakage so

141
00:05:32,510 --> 00:05:35,750
at the end of this game we require that

142
00:05:34,160 --> 00:05:38,780
the adversary not to learn any

143
00:05:35,750 --> 00:05:40,640
information about the stored secret so

144
00:05:38,780 --> 00:05:43,520
when compared to the one-shot leakage

145
00:05:40,640 --> 00:05:46,490
security setting the definition here is

146
00:05:43,520 --> 00:05:48,109
the leakage is continuous it is that

147
00:05:46,490 --> 00:05:50,810
leakage functions can be adaptively

148
00:05:48,110 --> 00:05:53,150
chosen and there is no trusted decoder

149
00:05:50,810 --> 00:05:54,800
so this is the strongest notion of

150
00:05:53,150 --> 00:05:56,539
security that has been considered

151
00:05:54,800 --> 00:06:01,070
indicators in in circuit compilers

152
00:05:56,540 --> 00:06:03,020
literature ok so given this security

153
00:06:01,070 --> 00:06:04,730
definitions - the next big question to

154
00:06:03,020 --> 00:06:06,409
ask is that what are the classes of

155
00:06:04,730 --> 00:06:09,050
leakage functions that we can protect

156
00:06:06,410 --> 00:06:11,360
against so in this work we focus on

157
00:06:09,050 --> 00:06:13,040
global leakage functions meaning that

158
00:06:11,360 --> 00:06:16,250
the leakage function can view all the

159
00:06:13,040 --> 00:06:18,470
wires of the circuit C hat so ideally we

160
00:06:16,250 --> 00:06:19,970
would like to protect against arbitrary

161
00:06:18,470 --> 00:06:22,610
polynomial time leakage

162
00:06:19,970 --> 00:06:24,980
however given this model of global

163
00:06:22,610 --> 00:06:27,170
leakage it follows from the seminal

164
00:06:24,980 --> 00:06:29,540
works with respect to impossibility of

165
00:06:27,170 --> 00:06:31,190
program obfuscation that if we allow the

166
00:06:29,540 --> 00:06:33,590
leakage functions to be arbitrary

167
00:06:31,190 --> 00:06:37,610
polynomial time then there is no hope of

168
00:06:33,590 --> 00:06:40,130
giving any sort of security so in order

169
00:06:37,610 --> 00:06:41,750
to circumvent this impossibility result

170
00:06:40,130 --> 00:06:43,730
we have to restrict the classes of

171
00:06:41,750 --> 00:06:44,480
leakage and in this work we restrict

172
00:06:43,730 --> 00:06:46,730
them to have a

173
00:06:44,480 --> 00:06:49,460
constant depth somewhat like AC zero

174
00:06:46,730 --> 00:06:51,680
circuits so recall that AC zero is the

175
00:06:49,460 --> 00:06:54,650
class of polynomial size circuits with

176
00:06:51,680 --> 00:06:57,530
unbounded fanon and or and not gates and

177
00:06:54,650 --> 00:06:59,000
the cell kids have a constant depth so

178
00:06:57,530 --> 00:07:00,260
the next question that you might be

179
00:06:59,000 --> 00:07:03,050
wondering is that why is this

180
00:07:00,260 --> 00:07:05,000
restriction interesting so this

181
00:07:03,050 --> 00:07:06,890
restriction is interesting because AC

182
00:07:05,000 --> 00:07:10,100
zero already captures many natural

183
00:07:06,890 --> 00:07:12,830
leakage attacks for example AC zero can

184
00:07:10,100 --> 00:07:15,380
compute a CNF or a DNF of a set of wires

185
00:07:12,830 --> 00:07:18,109
it can check if a set of wires is in a

186
00:07:15,380 --> 00:07:20,300
certain range it can also do comparison

187
00:07:18,110 --> 00:07:22,700
it can do compute maximum or a minimum

188
00:07:20,300 --> 00:07:25,390
of a set of values so AC zero is already

189
00:07:22,700 --> 00:07:27,920
a rich classes of leakage functions and

190
00:07:25,390 --> 00:07:30,349
interestingly it is not implied by a

191
00:07:27,920 --> 00:07:33,530
weaker notion of leakage called as wire

192
00:07:30,350 --> 00:07:35,690
probe leakage and this shows that AC

193
00:07:33,530 --> 00:07:39,500
zero is strictly stronger than the wire

194
00:07:35,690 --> 00:07:41,270
probe leakage model however AC zero has

195
00:07:39,500 --> 00:07:43,160
its own limitations it does not capture

196
00:07:41,270 --> 00:07:45,830
a certain leakage attack such as taking

197
00:07:43,160 --> 00:07:47,720
a weighted sum of wire values so the

198
00:07:45,830 --> 00:07:49,400
essence of this slide is that AC zero is

199
00:07:47,720 --> 00:07:51,320
already an interesting class of leakage

200
00:07:49,400 --> 00:07:53,390
functions it is not implied by wire

201
00:07:51,320 --> 00:07:55,340
probe leakage however it does not

202
00:07:53,390 --> 00:07:58,360
capture certain leakage a test such as

203
00:07:55,340 --> 00:08:01,159
taking a weighted sum of wire values

204
00:07:58,360 --> 00:08:03,440
okay so given our focus on AC zero

205
00:08:01,160 --> 00:08:06,010
leakages let me now give you a brief

206
00:08:03,440 --> 00:08:09,469
overview of the prior work in this area

207
00:08:06,010 --> 00:08:12,170
first at all in 2010 and the subsequent

208
00:08:09,470 --> 00:08:14,270
white work of miles and viola in 2013

209
00:08:12,170 --> 00:08:17,030
gave leakage resilient circuit compilers

210
00:08:14,270 --> 00:08:19,180
against AC zero circuits assuming the

211
00:08:17,030 --> 00:08:21,590
existence of leak free Hardware tokens

212
00:08:19,180 --> 00:08:23,380
however this is a fairly strong

213
00:08:21,590 --> 00:08:26,599
assumption that we would like to avoid

214
00:08:23,380 --> 00:08:29,240
so in 2012 Ratlam gave a construction

215
00:08:26,600 --> 00:08:31,580
that does not use any leak free hardware

216
00:08:29,240 --> 00:08:33,530
tokens however the security analysis

217
00:08:31,580 --> 00:08:35,240
relied on an unproven complexity

218
00:08:33,530 --> 00:08:38,030
theoretical check sure with regard to AC

219
00:08:35,240 --> 00:08:40,130
zero circuits so a long-standing open

220
00:08:38,030 --> 00:08:42,799
problem in this area is to construct an

221
00:08:40,130 --> 00:08:44,179
unconditional Connor's construction of

222
00:08:42,799 --> 00:08:47,569
leak a resilient circuit compiler

223
00:08:44,179 --> 00:08:49,370
against AC zero leakages and in this

224
00:08:47,570 --> 00:08:52,070
work we resolved this question in the

225
00:08:49,370 --> 00:08:54,380
positive by showing that a construction

226
00:08:52,070 --> 00:08:56,540
of leaky resilient circuit compiler that

227
00:08:54,380 --> 00:08:58,460
has unconditional security against AC

228
00:08:56,540 --> 00:08:59,810
zero leakages

229
00:08:58,460 --> 00:09:02,030
so what's more interesting is that in

230
00:08:59,810 --> 00:09:04,010
the the one-shot setting we show that

231
00:09:02,030 --> 00:09:06,260
the original construction of Asia is a

232
00:09:04,010 --> 00:09:08,480
high and Waggoner that was only proved

233
00:09:06,260 --> 00:09:10,970
secured against us weaker model a wire

234
00:09:08,480 --> 00:09:12,890
probe leakage is in fact secured against

235
00:09:10,970 --> 00:09:14,630
the stronger AC zero leakage so we show

236
00:09:12,890 --> 00:09:18,319
that the exact same construction is in

237
00:09:14,630 --> 00:09:21,260
fact secured against AC zero leakage and

238
00:09:18,320 --> 00:09:23,270
in the continuous setting we modify the

239
00:09:21,260 --> 00:09:25,430
construction of rotblum and remove this

240
00:09:23,270 --> 00:09:28,030
need for this unproven complexity theory

241
00:09:25,430 --> 00:09:32,060
conjecture from the security analysis

242
00:09:28,030 --> 00:09:34,670
okay so these are the results and in the

243
00:09:32,060 --> 00:09:36,890
rest of the talk I'll give you a brief

244
00:09:34,670 --> 00:09:39,020
description of the ISW construction and

245
00:09:36,890 --> 00:09:41,449
give you the high-level overview of the

246
00:09:39,020 --> 00:09:43,130
proof that it is in fact secured against

247
00:09:41,450 --> 00:09:43,960
AC zero leakages in the one short

248
00:09:43,130 --> 00:09:46,250
setting

249
00:09:43,960 --> 00:09:48,050
unfortunately I wouldn't have time to go

250
00:09:46,250 --> 00:09:49,490
into the details of our construction the

251
00:09:48,050 --> 00:09:51,800
continuous setting and I would encourage

252
00:09:49,490 --> 00:09:54,430
you to look into our paper and I'll

253
00:09:51,800 --> 00:09:57,709
finally conclude with some open problems

254
00:09:54,430 --> 00:09:59,660
okay so let's begin with the description

255
00:09:57,710 --> 00:10:01,880
of the ISW construction and let's start

256
00:09:59,660 --> 00:10:03,980
with the encoder so recall that the

257
00:10:01,880 --> 00:10:05,750
encoder takes in some secret input and

258
00:10:03,980 --> 00:10:08,870
produces an encoded version of this

259
00:10:05,750 --> 00:10:11,420
input so let's call the secret input to

260
00:10:08,870 --> 00:10:15,260
be X which is K bits long the encoding

261
00:10:11,420 --> 00:10:18,530
is simple so every bit of this in secret

262
00:10:15,260 --> 00:10:20,990
input is encoded using a lambda random

263
00:10:18,530 --> 00:10:23,810
string of length lambda whose parity is

264
00:10:20,990 --> 00:10:26,450
equal to this particular bit so X is

265
00:10:23,810 --> 00:10:28,400
encoded using X I 1/2 X a lambda which I

266
00:10:26,450 --> 00:10:30,830
have just random bits except that the

267
00:10:28,400 --> 00:10:34,490
parity of these bits is equal to X I and

268
00:10:30,830 --> 00:10:38,480
this is done for every bit of the secret

269
00:10:34,490 --> 00:10:40,550
input so let's see how the the

270
00:10:38,480 --> 00:10:42,100
randomized circuit C hat is constructed

271
00:10:40,550 --> 00:10:45,500
so at a high level

272
00:10:42,100 --> 00:10:47,930
every wire of the original circuit is

273
00:10:45,500 --> 00:10:50,870
transformed into a bundle of lambda

274
00:10:47,930 --> 00:10:52,520
wires in this C hat such that the parity

275
00:10:50,870 --> 00:10:54,890
of this bundle is equal to the value

276
00:10:52,520 --> 00:10:57,050
carried by this wire so let's say that

277
00:10:54,890 --> 00:10:58,520
if the value carried by this wire is 0

278
00:10:57,050 --> 00:11:01,400
then in Sealand

279
00:10:58,520 --> 00:11:04,100
C hat the parity of this bundle of wires

280
00:11:01,400 --> 00:11:08,120
representing this wire will have will be

281
00:11:04,100 --> 00:11:10,970
0 the and this invariant is maintained

282
00:11:08,120 --> 00:11:11,790
for the output of each gate so given two

283
00:11:10,970 --> 00:11:14,010
bundles

284
00:11:11,790 --> 00:11:16,260
asperities a and B then the output of

285
00:11:14,010 --> 00:11:18,060
the bundle is G of a comma B so this

286
00:11:16,260 --> 00:11:20,580
invariant is maintained for each gate

287
00:11:18,060 --> 00:11:22,589
and given this the decoder is fairly

288
00:11:20,580 --> 00:11:26,250
simple it just computes the parity and

289
00:11:22,590 --> 00:11:29,610
outputs it okay so this is the

290
00:11:26,250 --> 00:11:31,650
construction and the so let's see how is

291
00:11:29,610 --> 00:11:33,150
this invariant maintained for each gate

292
00:11:31,650 --> 00:11:35,280
so that that is the most interesting

293
00:11:33,150 --> 00:11:38,310
part and let's start with the addition

294
00:11:35,280 --> 00:11:40,230
gate and C hat so the addition gate in C

295
00:11:38,310 --> 00:11:42,239
hat takes in two bundles the first

296
00:11:40,230 --> 00:11:44,640
bundle lose parity is a second bundle

297
00:11:42,240 --> 00:11:47,270
asperities B and it has to output a

298
00:11:44,640 --> 00:11:50,160
bundle whose parity is a eggs or with

299
00:11:47,270 --> 00:11:53,100
okay so this is straightforward so you

300
00:11:50,160 --> 00:11:54,959
just compute the bitwise parity of these

301
00:11:53,100 --> 00:11:57,360
two bundles and output the resultant

302
00:11:54,960 --> 00:11:59,970
bundle so the parity of the resultant

303
00:11:57,360 --> 00:12:03,810
bundle will precisely be equal to ax or

304
00:11:59,970 --> 00:12:05,880
with the now the interesting point is

305
00:12:03,810 --> 00:12:07,859
the multiplication gate so the

306
00:12:05,880 --> 00:12:10,140
multiplication gate has to take in two

307
00:12:07,860 --> 00:12:12,330
bundles again one knows parity is he

308
00:12:10,140 --> 00:12:15,650
another whose parity is B and it has to

309
00:12:12,330 --> 00:12:18,960
output a bundle whose parities a times c

310
00:12:15,650 --> 00:12:22,079
so to do this Dyess w construction first

311
00:12:18,960 --> 00:12:23,850
defines a boolean matrix e of lambda

312
00:12:22,080 --> 00:12:26,340
rows and lambda columns where lambda is

313
00:12:23,850 --> 00:12:28,380
the length of each bundle and the

314
00:12:26,340 --> 00:12:31,920
entries of this matrix are populated as

315
00:12:28,380 --> 00:12:33,510
follows so every entry in the upper

316
00:12:31,920 --> 00:12:36,300
triangular part of this matrix is a

317
00:12:33,510 --> 00:12:39,720
random bit so for every I less than J Z

318
00:12:36,300 --> 00:12:42,780
IJ is chosen to be a random bit and the

319
00:12:39,720 --> 00:12:45,360
kate diagonal entry will be a k times BK

320
00:12:42,780 --> 00:12:48,150
and every entry along the lower

321
00:12:45,360 --> 00:12:50,340
triangular part is chosen as follows so

322
00:12:48,150 --> 00:12:51,870
it is the eggs are of the corresponding

323
00:12:50,340 --> 00:12:56,340
entry in the upper triangular part with

324
00:12:51,870 --> 00:12:59,490
a ib j and aj bi okay so this is how the

325
00:12:56,340 --> 00:13:01,830
matrix is defined and once this matrix

326
00:12:59,490 --> 00:13:03,780
is defined you just take the sum of each

327
00:13:01,830 --> 00:13:06,570
column of this matrix to output the

328
00:13:03,780 --> 00:13:08,699
resultant bundle now the claim is that

329
00:13:06,570 --> 00:13:10,380
the parity of this resultant bundle is

330
00:13:08,700 --> 00:13:12,870
equal to a times B which is the

331
00:13:10,380 --> 00:13:14,790
invariant that we wanted to maintain so

332
00:13:12,870 --> 00:13:16,620
to see why this is the case notice that

333
00:13:14,790 --> 00:13:18,150
the parity of this bundle is equal to

334
00:13:16,620 --> 00:13:20,670
the sum of all the entries of this

335
00:13:18,150 --> 00:13:21,720
matrix and the sum of the upper

336
00:13:20,670 --> 00:13:23,579
triangular entry and the lower

337
00:13:21,720 --> 00:13:26,459
triangular entry will be a ABG

338
00:13:23,580 --> 00:13:29,130
exert with a jbi that's summing over all

339
00:13:26,459 --> 00:13:31,380
the entries of this matrix will be sum

340
00:13:29,130 --> 00:13:34,709
over IJ of AI times BJ and this is

341
00:13:31,380 --> 00:13:39,839
precisely equal to a times V so this is

342
00:13:34,709 --> 00:13:42,959
how the ISW multiplication gate works so

343
00:13:39,839 --> 00:13:46,019
in the rest of the talk I will give you

344
00:13:42,959 --> 00:13:48,119
the brief overview of the proof that

345
00:13:46,019 --> 00:13:51,570
this is in fact secured against AC 0

346
00:13:48,120 --> 00:13:53,459
leakages in the one short setting okay

347
00:13:51,570 --> 00:13:55,440
so the main tool that we use in the

348
00:13:53,459 --> 00:13:57,719
proof is something called as a local

349
00:13:55,440 --> 00:13:59,940
sampler so let me start with the

350
00:13:57,720 --> 00:14:03,089
definition of a local sampler so a

351
00:13:59,940 --> 00:14:05,700
circuit s that takes an irregular input

352
00:14:03,089 --> 00:14:06,870
X and some random input R is said to be

353
00:14:05,700 --> 00:14:09,390
a local sampler

354
00:14:06,870 --> 00:14:11,370
if each output bit of the circuit

355
00:14:09,390 --> 00:14:13,680
depends on at most one bit of this

356
00:14:11,370 --> 00:14:16,230
regular input X however it can depend on

357
00:14:13,680 --> 00:14:18,329
an arbitrary function of R so for

358
00:14:16,230 --> 00:14:20,279
example the first output bit could be X

359
00:14:18,329 --> 00:14:24,989
I times some arbitrary function of our

360
00:14:20,279 --> 00:14:27,480
and so on ok so given this definition so

361
00:14:24,990 --> 00:14:29,040
a lemma which straightforward which

362
00:14:27,480 --> 00:14:31,649
follows in a straightforward manner is

363
00:14:29,040 --> 00:14:34,319
as follows so let's say that s is a

364
00:14:31,649 --> 00:14:38,060
local sampler then for any choice of the

365
00:14:34,320 --> 00:14:41,010
random input R the output of s on d0 is

366
00:14:38,060 --> 00:14:44,189
indistinguishable to AC zero circuits to

367
00:14:41,010 --> 00:14:46,230
the output of s on d1 so here DB is a

368
00:14:44,190 --> 00:14:48,660
uniform distribution on lambda bit

369
00:14:46,230 --> 00:14:50,940
string whose parities be so what this

370
00:14:48,660 --> 00:14:53,569
lemma states is that AC zero circuits

371
00:14:50,940 --> 00:14:55,529
cannot distinguish whether s was

372
00:14:53,570 --> 00:14:58,829
evaluated on a random string whose

373
00:14:55,529 --> 00:15:02,820
parity was 0 or s was evaluated on a

374
00:14:58,829 --> 00:15:04,620
random string whose parity was 1 ok so

375
00:15:02,820 --> 00:15:06,870
the proof of this lemma is just two

376
00:15:04,620 --> 00:15:08,970
lines so notice that d0 is

377
00:15:06,870 --> 00:15:13,230
indistinguishable to d1 and this follows

378
00:15:08,970 --> 00:15:15,899
from the starts famous result and since

379
00:15:13,230 --> 00:15:19,110
s is a local sampler and for any choice

380
00:15:15,899 --> 00:15:22,170
of randomness our s of d be on R is non

381
00:15:19,110 --> 00:15:24,300
uniform in c0 computable so these two

382
00:15:22,170 --> 00:15:28,529
observations put together directly gives

383
00:15:24,300 --> 00:15:30,599
this lemma ok so given this lemma let's

384
00:15:28,529 --> 00:15:32,910
see how do we prove that is w

385
00:15:30,600 --> 00:15:35,850
construction is in fact secure against a

386
00:15:32,910 --> 00:15:37,540
c0 leakages in the one short set so

387
00:15:35,850 --> 00:15:39,820
recall that we have to prove

388
00:15:37,540 --> 00:15:42,010
any AC zero leakage function acting on

389
00:15:39,820 --> 00:15:45,630
the wires of C hat cannot distinguish

390
00:15:42,010 --> 00:15:48,160
whether the input was X or from X prime

391
00:15:45,630 --> 00:15:50,890
okay so the proof the main steps in the

392
00:15:48,160 --> 00:15:53,589
proof is as follows so we fix the

393
00:15:50,890 --> 00:15:55,630
encoding x' of all the bits of X except

394
00:15:53,590 --> 00:15:59,200
the i 8 bit and we call the encoding to

395
00:15:55,630 --> 00:16:03,370
be T I recall that T is a lambda bit

396
00:15:59,200 --> 00:16:06,070
string whose parity is equal to X I the

397
00:16:03,370 --> 00:16:09,220
main step in the proof is that we show

398
00:16:06,070 --> 00:16:12,100
the existence of a local sampler s such

399
00:16:09,220 --> 00:16:14,170
that the output of s on regular input T

400
00:16:12,100 --> 00:16:17,500
I and for a uniform choice of randomness

401
00:16:14,170 --> 00:16:20,740
R is in fact identical to the wires of C

402
00:16:17,500 --> 00:16:23,920
hat so in what we show is that the wires

403
00:16:20,740 --> 00:16:25,930
of C hat can be locally sampled so from

404
00:16:23,920 --> 00:16:28,420
the previous lemma what this directly

405
00:16:25,930 --> 00:16:30,819
implies that any AC zero function acting

406
00:16:28,420 --> 00:16:33,490
on the wires of C hat cannot distinguish

407
00:16:30,820 --> 00:16:36,640
whether PA was an encoding of the bit 0

408
00:16:33,490 --> 00:16:38,620
or it was an encoding of the bit 1 so

409
00:16:36,640 --> 00:16:42,910
this follows directly from the previous

410
00:16:38,620 --> 00:16:44,710
lemma so to show this we first show that

411
00:16:42,910 --> 00:16:46,719
the wires of the addition and the

412
00:16:44,710 --> 00:16:49,480
multiplication gadgets in the ISW

413
00:16:46,720 --> 00:16:51,310
construction are locally sample and then

414
00:16:49,480 --> 00:16:53,290
we use a straightforward inductive

415
00:16:51,310 --> 00:16:55,359
induction or a gate elimination argument

416
00:16:53,290 --> 00:16:59,620
to show that all the wires of C hat are

417
00:16:55,360 --> 00:17:01,540
locally sample so given this key step

418
00:16:59,620 --> 00:17:03,400
the the rest of the proof just follows

419
00:17:01,540 --> 00:17:06,760
from a straightforward hybrid argument

420
00:17:03,400 --> 00:17:09,369
so we fix all the encoding except the

421
00:17:06,760 --> 00:17:13,209
first bit we change this from encoding

422
00:17:09,369 --> 00:17:17,290
of x1 to X prime 1 and we do this for

423
00:17:13,209 --> 00:17:19,000
every bit of this input X so the most

424
00:17:17,290 --> 00:17:21,069
interesting part of the proof is that

425
00:17:19,000 --> 00:17:22,900
how do we show that the addition and the

426
00:17:21,069 --> 00:17:26,220
multiplication gadgets are locally

427
00:17:22,900 --> 00:17:29,500
sample okay so let's start with the

428
00:17:26,220 --> 00:17:31,570
addition gadget recall that the addition

429
00:17:29,500 --> 00:17:34,990
gadget takes in two bundles and outputs

430
00:17:31,570 --> 00:17:36,610
the bitwise parity or a bundle who which

431
00:17:34,990 --> 00:17:39,280
is just a bitwise parity of these two

432
00:17:36,610 --> 00:17:41,290
bundles and since we have fixed the

433
00:17:39,280 --> 00:17:44,379
encoding x' of all the bundles except

434
00:17:41,290 --> 00:17:45,670
once let's fix the second bundle and we

435
00:17:44,380 --> 00:17:48,120
want to show that the wires of the

436
00:17:45,670 --> 00:17:50,800
addition gate are a local function of is

437
00:17:48,120 --> 00:17:51,409
notice that since it's just going to be

438
00:17:50,800 --> 00:17:53,930
a bit twice

439
00:17:51,410 --> 00:17:56,360
paraty this directly is a local function

440
00:17:53,930 --> 00:17:58,400
so we don't have to do anything so

441
00:17:56,360 --> 00:18:00,189
addition the wires of the addition gate

442
00:17:58,400 --> 00:18:01,390
are already a local function of this

443
00:18:00,190 --> 00:18:04,160
bundle

444
00:18:01,390 --> 00:18:08,780
so the interesting point is for the

445
00:18:04,160 --> 00:18:10,970
multiplication gate so notice that the

446
00:18:08,780 --> 00:18:15,200
multiplication gadget has to take in two

447
00:18:10,970 --> 00:18:17,210
bundles defines this matrix Z and whose

448
00:18:15,200 --> 00:18:18,890
entries are populated as follows and it

449
00:18:17,210 --> 00:18:21,050
has to take in the sum of all the

450
00:18:18,890 --> 00:18:25,040
columns of this matrix and outputs this

451
00:18:21,050 --> 00:18:27,649
resultant bundle and let's ask before

452
00:18:25,040 --> 00:18:29,050
let's fix this second bundle and we want

453
00:18:27,650 --> 00:18:31,370
to show that the wires of the

454
00:18:29,050 --> 00:18:34,730
multiplication gadget are in fact a

455
00:18:31,370 --> 00:18:37,820
local function of Ace however if you

456
00:18:34,730 --> 00:18:40,370
notice that the all the entries of the

457
00:18:37,820 --> 00:18:43,490
last row of Z which is used to computing

458
00:18:40,370 --> 00:18:46,929
lambda these entries depend on all the

459
00:18:43,490 --> 00:18:52,370
bits of a because it is a function of

460
00:18:46,930 --> 00:18:55,190
Ages so Zi ji so for J is substituted to

461
00:18:52,370 --> 00:18:57,649
lambda depends on all the bits of s and

462
00:18:55,190 --> 00:19:01,850
hence summing over all the bits of s

463
00:18:57,650 --> 00:19:05,000
will is necessary to compute C lambda

464
00:19:01,850 --> 00:19:09,649
and hence this will be a non-local

465
00:19:05,000 --> 00:19:11,720
function of s so we seem to be stuck now

466
00:19:09,650 --> 00:19:13,610
so we wanted to show that the wires of

467
00:19:11,720 --> 00:19:17,300
the multiplication gate are locally

468
00:19:13,610 --> 00:19:19,699
sample however we just observed that the

469
00:19:17,300 --> 00:19:23,169
the wires are in fact non-local function

470
00:19:19,700 --> 00:19:26,270
of s so we need we seem to be stuck

471
00:19:23,170 --> 00:19:28,550
however the key inside that allows us to

472
00:19:26,270 --> 00:19:31,850
get around this is that even though this

473
00:19:28,550 --> 00:19:34,430
distribution of the wires may not be

474
00:19:31,850 --> 00:19:36,590
locally sample able be sure that this

475
00:19:34,430 --> 00:19:39,470
distribution is in fact identical to a

476
00:19:36,590 --> 00:19:41,379
locally Sam palpable distribution okay

477
00:19:39,470 --> 00:19:43,610
so this allows us to get around this

478
00:19:41,380 --> 00:19:46,280
okay so how do we show that this is

479
00:19:43,610 --> 00:19:49,310
identically distributed to a locally

480
00:19:46,280 --> 00:19:51,710
sample distribution so so the there is

481
00:19:49,310 --> 00:19:55,370
just one small change so instead of

482
00:19:51,710 --> 00:19:57,680
choosing zi j's to be a random bit as in

483
00:19:55,370 --> 00:20:01,340
the previous case we choose it to be a

484
00:19:57,680 --> 00:20:03,230
random bit exhort with AI BJ's so this

485
00:20:01,340 --> 00:20:05,059
does not change the distribution so this

486
00:20:03,230 --> 00:20:07,340
distribution is identical to the

487
00:20:05,059 --> 00:20:10,370
previous distribution however if you

488
00:20:07,340 --> 00:20:13,939
substitute this value of Z IJ with this

489
00:20:10,370 --> 00:20:17,418
equation you'll notice that this AI BDS

490
00:20:13,940 --> 00:20:23,299
will just cancel out and ZJ I will be a

491
00:20:17,419 --> 00:20:27,279
random bit exorbitant ocol function why

492
00:20:23,299 --> 00:20:30,980
because Z J is for every J depends on a

493
00:20:27,279 --> 00:20:33,769
just one bit of a so even summing over

494
00:20:30,980 --> 00:20:35,720
all the entries of a row just depends on

495
00:20:33,769 --> 00:20:40,820
a single bit of a and this by definition

496
00:20:35,720 --> 00:20:44,269
is a local function okay so this is the

497
00:20:40,820 --> 00:20:47,570
main insight on how we show that the ISW

498
00:20:44,269 --> 00:20:49,730
construction is in fact leaky resilient

499
00:20:47,570 --> 00:20:51,168
in the one-shot setting against AC zero

500
00:20:49,730 --> 00:20:55,690
leakage this and the main tool that we

501
00:20:51,169 --> 00:20:58,970
used was this local sample ability and

502
00:20:55,690 --> 00:21:00,980
to conclude the main result in a talk

503
00:20:58,970 --> 00:21:02,450
was to give a construction of leaky

504
00:21:00,980 --> 00:21:04,820
resilient circuit compilers that are

505
00:21:02,450 --> 00:21:07,909
unconditionally secured against AC 0

506
00:21:04,820 --> 00:21:09,590
leakages in the continuous setting in

507
00:21:07,909 --> 00:21:12,110
the one charge setting we show that the

508
00:21:09,590 --> 00:21:15,168
ISW construction as such is AC zero

509
00:21:12,110 --> 00:21:17,959
leakage resilient and some of the

510
00:21:15,169 --> 00:21:20,299
interesting open problems are to show

511
00:21:17,960 --> 00:21:23,299
whether the ISW construction is secure

512
00:21:20,299 --> 00:21:25,158
against continuous leakage so currently

513
00:21:23,299 --> 00:21:27,679
we don't have an attack nor a proof that

514
00:21:25,159 --> 00:21:30,559
it is secure and it would be interesting

515
00:21:27,679 --> 00:21:32,330
to resolve this problem another a very

516
00:21:30,559 --> 00:21:34,009
interesting problem is to give a

517
00:21:32,330 --> 00:21:35,928
construction of leakage a resilient

518
00:21:34,009 --> 00:21:39,200
circuit compiler for richer complexity

519
00:21:35,929 --> 00:21:41,269
classes moving beyond AC zeros and they

520
00:21:39,200 --> 00:21:43,759
it would be interesting if we can do it

521
00:21:41,269 --> 00:21:45,470
without using trusted hardware and this

522
00:21:43,759 --> 00:21:49,759
would directly improve the result of

523
00:21:45,470 --> 00:21:52,779
miles and viola from 2013 and that's it

524
00:21:49,759 --> 00:21:52,779
thank you for your attention

525
00:21:56,420 --> 00:22:01,560
thank you we have time for questions

526
00:21:58,520 --> 00:22:09,420
there are microphones on the both aisles

527
00:22:01,560 --> 00:22:11,220
please step after them to be heard well

528
00:22:09,420 --> 00:22:14,850
while you ponder yours I have one of

529
00:22:11,220 --> 00:22:17,250
mine this construction elegantly

530
00:22:14,850 --> 00:22:19,949
resolves an open question for the past

531
00:22:17,250 --> 00:22:22,560
decade and meanwhile people have been

532
00:22:19,950 --> 00:22:25,320
wondering about using it in practice and

533
00:22:22,560 --> 00:22:28,740
efficiency considerations what are your

534
00:22:25,320 --> 00:22:34,169
thoughts on optimizations or optimality

535
00:22:28,740 --> 00:22:37,050
of this construction so in terms of

536
00:22:34,170 --> 00:22:38,670
optimality I think there is there is a

537
00:22:37,050 --> 00:22:41,370
lot of thing that can be done because

538
00:22:38,670 --> 00:22:44,760
this the overhead of the circuit size is

539
00:22:41,370 --> 00:22:48,300
roughly scales it's K squared where K is

540
00:22:44,760 --> 00:22:50,370
the security parameter but if you just

541
00:22:48,300 --> 00:22:52,050
focus on the wire probe leakage you have

542
00:22:50,370 --> 00:22:53,850
better constructions which are just

543
00:22:52,050 --> 00:22:55,790
scaling linearly or even poly

544
00:22:53,850 --> 00:22:58,379
logarithmic ly in the security parameter

545
00:22:55,790 --> 00:23:00,750
currently we don't know whether we can

546
00:22:58,380 --> 00:23:03,720
do those optimizations for the wire

547
00:23:00,750 --> 00:23:05,270
probe leakage for the AC zero setting so

548
00:23:03,720 --> 00:23:13,860
that would be very interesting I say

549
00:23:05,270 --> 00:23:16,430
thank you yes go ahead so let's think

550
00:23:13,860 --> 00:23:16,429
this peak here again

