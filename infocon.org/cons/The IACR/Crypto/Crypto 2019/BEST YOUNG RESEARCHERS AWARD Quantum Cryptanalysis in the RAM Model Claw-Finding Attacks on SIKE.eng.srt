1
00:00:04,870 --> 00:00:10,660
hi everyone so this work is crypt

2
00:00:08,800 --> 00:00:14,860
analyzing and I saw Jenny based crypto

3
00:00:10,660 --> 00:00:17,259
scheme called psych so we take a bit of

4
00:00:14,860 --> 00:00:18,910
a long road to get there and to put this

5
00:00:17,260 --> 00:00:21,430
in context right now nest is

6
00:00:18,910 --> 00:00:24,520
standardizing post quantum crypto

7
00:00:21,430 --> 00:00:27,100
schemes just to say that something is

8
00:00:24,520 --> 00:00:29,470
post quantum means that it's secure

9
00:00:27,100 --> 00:00:32,320
against a quantum adversary meaning that

10
00:00:29,470 --> 00:00:35,019
any algorithm to break it is infeasible

11
00:00:32,320 --> 00:00:36,489
to run on a quantum computer to even

12
00:00:35,019 --> 00:00:38,230
make a statement like that to claim

13
00:00:36,489 --> 00:00:40,209
something like that we need to be able

14
00:00:38,230 --> 00:00:42,010
to decide how much does it cost for a

15
00:00:40,210 --> 00:00:45,250
quantum computer to run certain things

16
00:00:42,010 --> 00:00:47,379
so everyone in this field sort of has to

17
00:00:45,250 --> 00:00:49,629
have a model somewhere in their head

18
00:00:47,380 --> 00:00:51,910
that says what a quantum computer is and

19
00:00:49,629 --> 00:00:53,739
is not capable of so how do you imagine

20
00:00:51,910 --> 00:00:56,230
a quantum computer what does it look

21
00:00:53,739 --> 00:00:58,239
like what can it do is it actually just

22
00:00:56,230 --> 00:00:59,620
a classical computer but maybe you've

23
00:00:58,239 --> 00:01:01,510
sprinkled in some magic quantum

24
00:00:59,620 --> 00:01:05,500
operations in addition to the other ones

25
00:01:01,510 --> 00:01:07,600
and so maybe you think you'd like to do

26
00:01:05,500 --> 00:01:10,720
a bit better and so you think there's

27
00:01:07,600 --> 00:01:12,699
this enormous body of literature already

28
00:01:10,720 --> 00:01:15,459
existing on quantum computers and you

29
00:01:12,700 --> 00:01:17,410
want to draw from this so here we're

30
00:01:15,459 --> 00:01:20,470
going from realism to generality in

31
00:01:17,410 --> 00:01:22,179
these models as cryptographers we can

32
00:01:20,470 --> 00:01:24,940
draw from these very general results in

33
00:01:22,179 --> 00:01:26,880
complexity theory and query costs but we

34
00:01:24,940 --> 00:01:30,610
end up having schemes that are too big

35
00:01:26,880 --> 00:01:33,660
because this is too conservative so we

36
00:01:30,610 --> 00:01:37,690
think maybe instead we draw from these

37
00:01:33,660 --> 00:01:39,220
realistic approaches where people are

38
00:01:37,690 --> 00:01:42,009
worrying about what can we run on

39
00:01:39,220 --> 00:01:44,830
quantum computers very soon on immediate

40
00:01:42,009 --> 00:01:47,500
technologies but these results don't

41
00:01:44,830 --> 00:01:50,679
worry if a new quantum computer will

42
00:01:47,500 --> 00:01:51,849
come along that their algorithms don't

43
00:01:50,679 --> 00:01:52,239
run on because they'll just write new

44
00:01:51,849 --> 00:01:54,190
ones

45
00:01:52,239 --> 00:01:55,899
but if cryptographers we need to worry

46
00:01:54,190 --> 00:01:57,940
about that because if our security was

47
00:01:55,899 --> 00:02:01,179
invalidated we might have an insecure

48
00:01:57,940 --> 00:02:04,090
scheme so cryptography is need to be

49
00:02:01,179 --> 00:02:05,950
somewhere in the middle and that sort of

50
00:02:04,090 --> 00:02:07,750
gives the the overall context for what

51
00:02:05,950 --> 00:02:11,349
we're going for with this work and how

52
00:02:07,750 --> 00:02:13,060
we tried to analyze psych so in this

53
00:02:11,349 --> 00:02:15,700
talk I'll give some of our motivation

54
00:02:13,060 --> 00:02:17,620
and what we tried to do with our new

55
00:02:15,700 --> 00:02:20,018
model for quantum computers

56
00:02:17,620 --> 00:02:21,940
and then introduce the main contribution

57
00:02:20,019 --> 00:02:23,620
of our paper this memory peripheral

58
00:02:21,940 --> 00:02:25,629
framework and this framework

59
00:02:23,620 --> 00:02:27,940
accommodates different cost models we

60
00:02:25,629 --> 00:02:30,819
provide two we use those cost models to

61
00:02:27,940 --> 00:02:34,299
analyze psyche and I'll conclude after

62
00:02:30,819 --> 00:02:36,548
that so the first thing we want to be

63
00:02:34,299 --> 00:02:39,250
able to do is to fairly compare a

64
00:02:36,549 --> 00:02:42,610
classical and a quantum algorithm so we

65
00:02:39,250 --> 00:02:43,989
want to be able to say if something is

66
00:02:42,610 --> 00:02:45,610
easier to attack with the classical

67
00:02:43,989 --> 00:02:48,160
algorithm or easy to easier to attack

68
00:02:45,610 --> 00:02:49,930
but the quantum algorithm and sometimes

69
00:02:48,160 --> 00:02:52,060
with algorithms that have both classical

70
00:02:49,930 --> 00:02:54,579
and quantum components and this is a

71
00:02:52,060 --> 00:02:57,819
problem that has come up before and is

72
00:02:54,579 --> 00:03:00,220
well known so there is this quantum

73
00:02:57,819 --> 00:03:03,700
collision finding algorithm by press our

74
00:03:00,220 --> 00:03:06,000
Hoyer and tap that requires a lot of

75
00:03:03,700 --> 00:03:08,470
classical memory with quantum access and

76
00:03:06,000 --> 00:03:10,239
Bernstein argued that if you fully

77
00:03:08,470 --> 00:03:12,489
account for the memory costs then

78
00:03:10,239 --> 00:03:18,010
actually a classical algorithm is less

79
00:03:12,489 --> 00:03:19,989
expensive and another thing we want to

80
00:03:18,010 --> 00:03:23,858
incorporate into this is a view that

81
00:03:19,989 --> 00:03:25,480
gates are processes so in a quantum

82
00:03:23,859 --> 00:03:27,910
circuit diagram you have different wires

83
00:03:25,480 --> 00:03:30,010
and they represent qubits and time goes

84
00:03:27,910 --> 00:03:31,209
from left to right so when you look at

85
00:03:30,010 --> 00:03:32,649
this what's happening is each of these

86
00:03:31,209 --> 00:03:35,319
symbols represents a gate that is

87
00:03:32,650 --> 00:03:37,120
applied to that qubit at that time these

88
00:03:35,319 --> 00:03:40,030
deliberately resemble classical circuit

89
00:03:37,120 --> 00:03:43,269
diagrams where each wire is a bit and

90
00:03:40,030 --> 00:03:45,160
time goes from left to right the thing

91
00:03:43,269 --> 00:03:47,440
about the classical diagram is the

92
00:03:45,160 --> 00:03:49,239
diagram represents this formal boolean

93
00:03:47,440 --> 00:03:52,120
circuit model that doesn't account for

94
00:03:49,239 --> 00:03:54,280
space at all but typically we equivocate

95
00:03:52,120 --> 00:03:56,049
between time and space because we think

96
00:03:54,280 --> 00:03:57,760
well we can take the circuit and we can

97
00:03:56,049 --> 00:04:00,370
print and non-print it on to a physical

98
00:03:57,760 --> 00:04:01,840
chip and when we do that the signals

99
00:04:00,370 --> 00:04:04,120
will propagate from left to right

100
00:04:01,840 --> 00:04:06,010
through the gates as time progresses so

101
00:04:04,120 --> 00:04:07,900
time and space intuitively feel

102
00:04:06,010 --> 00:04:10,810
equivalent here and we don't usually

103
00:04:07,900 --> 00:04:12,340
worry about this but that's not formally

104
00:04:10,810 --> 00:04:14,109
implied by the model and it's especially

105
00:04:12,340 --> 00:04:16,690
not implied by the models quantum

106
00:04:14,109 --> 00:04:18,280
computing where this may not hold

107
00:04:16,690 --> 00:04:20,738
because the technology may not have this

108
00:04:18,279 --> 00:04:23,080
property and right now the promising

109
00:04:20,738 --> 00:04:25,450
quantum technologies do not look like

110
00:04:23,080 --> 00:04:27,400
the classical two dimensional circuits

111
00:04:25,450 --> 00:04:28,840
it's that the qubits themselves are

112
00:04:27,400 --> 00:04:31,179
stationary they're not a signal moving

113
00:04:28,840 --> 00:04:32,890
and you have to apply a gate to it

114
00:04:31,180 --> 00:04:36,910
so we want our model to accommodate that

115
00:04:32,890 --> 00:04:40,469
and finally we want to include error

116
00:04:36,910 --> 00:04:43,020
correction so in classical computers

117
00:04:40,470 --> 00:04:45,220
there's we have error correction and

118
00:04:43,020 --> 00:04:47,109
usually we don't worry too much about it

119
00:04:45,220 --> 00:04:48,820
because it's not that much of an expense

120
00:04:47,110 --> 00:04:51,400
but in quantum computers it's a bigger

121
00:04:48,820 --> 00:04:52,900
deal and in fact quantum errors are just

122
00:04:51,400 --> 00:04:54,669
fundamentally more complicated than

123
00:04:52,900 --> 00:04:56,560
classical errors so we need to include

124
00:04:54,670 --> 00:05:00,490
this in the model if we want an accurate

125
00:04:56,560 --> 00:05:03,190
reflection of cost so this leads us to

126
00:05:00,490 --> 00:05:04,660
our memory peripheral framework and the

127
00:05:03,190 --> 00:05:06,700
main idea is we want to model a

128
00:05:04,660 --> 00:05:09,070
computation as having some physical

129
00:05:06,700 --> 00:05:11,590
memory and some memory controller that

130
00:05:09,070 --> 00:05:13,719
acts on that memory so as some examples

131
00:05:11,590 --> 00:05:15,700
a Turing machine fits in this if we view

132
00:05:13,720 --> 00:05:18,370
the tape as the memory and the head as

133
00:05:15,700 --> 00:05:20,380
the memory controller a random access

134
00:05:18,370 --> 00:05:24,220
machine also fits in this the CPU is the

135
00:05:20,380 --> 00:05:26,110
controller and the RAM is the memory for

136
00:05:24,220 --> 00:05:28,960
quantum circuits we can use a random

137
00:05:26,110 --> 00:05:32,110
access machine classical as a controller

138
00:05:28,960 --> 00:05:34,780
and use qubits as the memory we have

139
00:05:32,110 --> 00:05:36,670
three main premises for these one that

140
00:05:34,780 --> 00:05:38,739
the memory is a physical system that can

141
00:05:36,670 --> 00:05:40,120
change over time to that the memory

142
00:05:38,740 --> 00:05:42,250
controller interacts at the memory

143
00:05:40,120 --> 00:05:44,050
number three that the cost is the number

144
00:05:42,250 --> 00:05:48,310
of interactions so I'll go into the even

145
00:05:44,050 --> 00:05:51,490
more detail so because it's a physical

146
00:05:48,310 --> 00:05:53,830
system memory is a physical system it

147
00:05:51,490 --> 00:05:55,540
will change over time and we can model

148
00:05:53,830 --> 00:05:57,159
this in different ways we can imagine

149
00:05:55,540 --> 00:05:58,900
that when we're not intervening with it

150
00:05:57,160 --> 00:06:01,480
when we sort of just let it do its own

151
00:05:58,900 --> 00:06:04,780
thing it sometimes might change and this

152
00:06:01,480 --> 00:06:06,190
could be noise and could sort of degrade

153
00:06:04,780 --> 00:06:07,719
over time or it could even do

154
00:06:06,190 --> 00:06:10,990
computation if we've set it up very

155
00:06:07,720 --> 00:06:14,290
carefully alternatively it could change

156
00:06:10,990 --> 00:06:16,210
because our memory controller has done

157
00:06:14,290 --> 00:06:20,470
something to change it and we consider

158
00:06:16,210 --> 00:06:22,299
these the costly changes to memory more

159
00:06:20,470 --> 00:06:26,170
specifically we model a quantum computer

160
00:06:22,300 --> 00:06:27,820
as a parallel random access machine that

161
00:06:26,170 --> 00:06:31,210
has these qubits associated with it and

162
00:06:27,820 --> 00:06:32,770
so take the RAM model take your favorite

163
00:06:31,210 --> 00:06:35,710
instruction set and add in some

164
00:06:32,770 --> 00:06:38,640
instructions that are effectively apply

165
00:06:35,710 --> 00:06:41,289
some gate to some qubit at some time and

166
00:06:38,640 --> 00:06:44,830
the effect of this is now a quantum

167
00:06:41,290 --> 00:06:47,500
algorithm becomes a classical program

168
00:06:44,830 --> 00:06:50,109
and so this is what this looks like this

169
00:06:47,500 --> 00:06:51,820
is one way that you can imagine what a

170
00:06:50,110 --> 00:06:54,970
quantum computer looks like you have a

171
00:06:51,820 --> 00:06:56,770
big lattice of qubits and to every qubit

172
00:06:54,970 --> 00:06:59,700
or maybe every small group of qubits

173
00:06:56,770 --> 00:07:01,900
you've associated a classical controller

174
00:06:59,700 --> 00:07:03,640
and that does things like corrects

175
00:07:01,900 --> 00:07:05,739
errors applies gates performs

176
00:07:03,640 --> 00:07:08,590
measurements and all of these classical

177
00:07:05,740 --> 00:07:11,710
controllers are coordinated by some

178
00:07:08,590 --> 00:07:14,799
central memory controller and viewed in

179
00:07:11,710 --> 00:07:16,479
this way this gives a cost of quantum

180
00:07:14,800 --> 00:07:18,730
algorithms in the number of interactions

181
00:07:16,480 --> 00:07:20,200
so a quantum computer will definitely be

182
00:07:18,730 --> 00:07:21,730
very expensive to build it'll be

183
00:07:20,200 --> 00:07:24,580
expensive to keep it cool and maintain

184
00:07:21,730 --> 00:07:26,950
it and we ignore all of that we only

185
00:07:24,580 --> 00:07:28,570
focus on the cost to the classical

186
00:07:26,950 --> 00:07:30,969
controller and the computations it must

187
00:07:28,570 --> 00:07:31,930
do and you can think of this as an

188
00:07:30,970 --> 00:07:34,360
opportunity cost

189
00:07:31,930 --> 00:07:36,610
we have this big classical computer that

190
00:07:34,360 --> 00:07:37,810
we need to run the quantum computer what

191
00:07:36,610 --> 00:07:39,550
else could we do with that classical

192
00:07:37,810 --> 00:07:45,340
computer if it wasn't busy running the

193
00:07:39,550 --> 00:07:48,370
quantum algorithm and so this is a very

194
00:07:45,340 --> 00:07:49,929
a general framework and we could fit

195
00:07:48,370 --> 00:07:53,050
different cost models and different

196
00:07:49,930 --> 00:07:54,400
assumptions into it and so we provide

197
00:07:53,050 --> 00:07:56,050
two different assumptions which lead to

198
00:07:54,400 --> 00:07:59,380
these two costs what we call the G cost

199
00:07:56,050 --> 00:08:01,570
and the DW cost in both cases we imagine

200
00:07:59,380 --> 00:08:03,790
qubit memories and standard quantum

201
00:08:01,570 --> 00:08:05,290
gates and the difference between them is

202
00:08:03,790 --> 00:08:08,640
our assumption on error correction

203
00:08:05,290 --> 00:08:12,220
whether it's passive or active and

204
00:08:08,640 --> 00:08:15,580
passive error correction is roughly na

205
00:08:12,220 --> 00:08:17,770
involved o non-volatile memory you can

206
00:08:15,580 --> 00:08:19,270
imagine if you have a piece of paper you

207
00:08:17,770 --> 00:08:21,909
write a bit on it you keep the paper

208
00:08:19,270 --> 00:08:24,010
cool your bit will last for a really

209
00:08:21,910 --> 00:08:25,630
long time similarly if you have a

210
00:08:24,010 --> 00:08:27,010
magnetic disk you can write a bit to it

211
00:08:25,630 --> 00:08:30,280
and just keep the disk cool and you're

212
00:08:27,010 --> 00:08:32,470
fine active memory needs to be

213
00:08:30,280 --> 00:08:34,720
continuously refreshed to preserve it so

214
00:08:32,470 --> 00:08:37,240
DRAM is a should be a very familiar

215
00:08:34,720 --> 00:08:39,820
example and quantum surface codes are

216
00:08:37,240 --> 00:08:41,440
another example on the slide there's no

217
00:08:39,820 --> 00:08:43,060
examples of a passively corrected

218
00:08:41,440 --> 00:08:47,590
quantum memory and this is not a

219
00:08:43,059 --> 00:08:50,020
accident so imagine this quantum

220
00:08:47,590 --> 00:08:52,240
computer and has a - of qubits

221
00:08:50,020 --> 00:08:54,310
in some number of dimensions and these

222
00:08:52,240 --> 00:08:56,790
qubits are limited to local interactions

223
00:08:54,310 --> 00:08:59,069
in this lattice to try to correct

224
00:08:56,790 --> 00:09:01,439
their errors and so can we build

225
00:08:59,070 --> 00:09:03,600
different kinds of memory in this we

226
00:09:01,440 --> 00:09:05,090
know how to build actively corrected

227
00:09:03,600 --> 00:09:08,550
memory and dimensions 2 and higher

228
00:09:05,090 --> 00:09:09,930
surface codes are an example of this we

229
00:09:08,550 --> 00:09:12,209
know how to build passively corrected

230
00:09:09,930 --> 00:09:13,680
memory and dimensions 4 and higher with

231
00:09:12,210 --> 00:09:16,170
a similar construction to surface codes

232
00:09:13,680 --> 00:09:21,300
but dimension 3 and under is an open

233
00:09:16,170 --> 00:09:23,339
problem and there are actually an

234
00:09:21,300 --> 00:09:25,020
impossibility result for a large family

235
00:09:23,340 --> 00:09:28,100
of error correcting codes that include

236
00:09:25,020 --> 00:09:31,020
surface codes and three dimensions is

237
00:09:28,100 --> 00:09:33,270
almost totally open the thing to

238
00:09:31,020 --> 00:09:34,680
remember about this is the dimension

239
00:09:33,270 --> 00:09:36,480
that we're referring to is the lattice

240
00:09:34,680 --> 00:09:38,520
of the lattice of qubits in the computer

241
00:09:36,480 --> 00:09:40,530
the physical dimension of the computer

242
00:09:38,520 --> 00:09:41,970
that we built we're limited to three

243
00:09:40,530 --> 00:09:45,689
dimensions that's the universe we live

244
00:09:41,970 --> 00:09:47,070
in so if we want to make a passively

245
00:09:45,690 --> 00:09:49,830
corrected quantum memory we have to

246
00:09:47,070 --> 00:09:54,150
solve this issue and right now this is

247
00:09:49,830 --> 00:09:56,460
open so if we want to take this g cost

248
00:09:54,150 --> 00:09:57,689
and assume a passively corrected memory

249
00:09:56,460 --> 00:09:59,640
we have to make a pretty strong

250
00:09:57,690 --> 00:10:02,580
assumption that our universe even allows

251
00:09:59,640 --> 00:10:06,540
this to happen and that at some point we

252
00:10:02,580 --> 00:10:07,950
will figure out how to do it but this

253
00:10:06,540 --> 00:10:10,620
might be possible so we can make this

254
00:10:07,950 --> 00:10:12,360
assumption so we don't need to spend any

255
00:10:10,620 --> 00:10:14,400
computation to preserve memory we only

256
00:10:12,360 --> 00:10:16,290
need to spend computation to change it

257
00:10:14,400 --> 00:10:18,480
and this is one Ram operation per gate

258
00:10:16,290 --> 00:10:19,860
is what this would be equivalent to so

259
00:10:18,480 --> 00:10:23,340
the total cost is just the number of

260
00:10:19,860 --> 00:10:24,630
gates so we called it G actively correct

261
00:10:23,340 --> 00:10:27,510
memory is going to be more difficult

262
00:10:24,630 --> 00:10:29,400
because at every qubit at every time

263
00:10:27,510 --> 00:10:31,650
step we have to do some computation to

264
00:10:29,400 --> 00:10:33,180
fix the errors that have occurred so we

265
00:10:31,650 --> 00:10:35,340
end up with one where I'm operation for

266
00:10:33,180 --> 00:10:38,370
qubit for time step so the total number

267
00:10:35,340 --> 00:10:40,050
of RAM operations for the algorithm is

268
00:10:38,370 --> 00:10:42,000
the depth of the number of sequential

269
00:10:40,050 --> 00:10:46,260
gates times of the width the number of

270
00:10:42,000 --> 00:10:48,780
qubits and DW cost so looking at these

271
00:10:46,260 --> 00:10:50,610
we might look at high memory algorithms

272
00:10:48,780 --> 00:10:53,040
to try to see somewhere where these two

273
00:10:50,610 --> 00:10:56,910
will be different and I saw Janine based

274
00:10:53,040 --> 00:10:59,280
cryptography is where we looked and so

275
00:10:56,910 --> 00:11:02,310
to give a very brief overview of I saw

276
00:10:59,280 --> 00:11:05,160
Janine based cryptography we have a

277
00:11:02,310 --> 00:11:07,380
large prime P maybe it's got 434 bits

278
00:11:05,160 --> 00:11:09,120
and we have a public parameter a zero

279
00:11:07,380 --> 00:11:13,800
and a public

280
00:11:09,120 --> 00:11:17,970
he over a and we it lives in some graph

281
00:11:13,800 --> 00:11:19,709
and this red path is the secret key you

282
00:11:17,970 --> 00:11:22,500
can find this red path you've broken the

283
00:11:19,710 --> 00:11:24,240
scheme so this is vulnerable to a meet

284
00:11:22,500 --> 00:11:26,730
in the middle attack we look for paths

285
00:11:24,240 --> 00:11:28,050
going forward from the public parameter

286
00:11:26,730 --> 00:11:30,270
and paths going backwards from the

287
00:11:28,050 --> 00:11:33,359
public key and we look for a collision

288
00:11:30,270 --> 00:11:35,400
between these two paths so hence the

289
00:11:33,360 --> 00:11:38,580
quantum algorithm that was previously

290
00:11:35,400 --> 00:11:41,339
viewed as the best attack is a generic

291
00:11:38,580 --> 00:11:43,490
collision finding algorithm by canny so

292
00:11:41,339 --> 00:11:46,830
it uses a random walk on a Johnson graph

293
00:11:43,490 --> 00:11:48,810
so a Johnson graph is you take a set X

294
00:11:46,830 --> 00:11:51,810
and you make vertices out of every

295
00:11:48,810 --> 00:11:53,969
subset of a size R and they're adjacent

296
00:11:51,810 --> 00:11:55,890
if they differ in exactly one element so

297
00:11:53,970 --> 00:11:58,140
if you take a random walk on this graph

298
00:11:55,890 --> 00:12:00,750
this is completely equivalent to taking

299
00:11:58,140 --> 00:12:02,730
your set removing an element at random

300
00:12:00,750 --> 00:12:05,310
and inserting a new element at random

301
00:12:02,730 --> 00:12:07,890
and that will be one step so for tenis

302
00:12:05,310 --> 00:12:09,750
algorithm you make one Johnson graph out

303
00:12:07,890 --> 00:12:11,850
of the set of paths going forward from

304
00:12:09,750 --> 00:12:13,470
the public parameter and another Johnson

305
00:12:11,850 --> 00:12:16,050
grass out of the paths going backwards

306
00:12:13,470 --> 00:12:17,820
and so you take it random walk on both

307
00:12:16,050 --> 00:12:19,529
and every time you insert a new element

308
00:12:17,820 --> 00:12:22,050
you look for a collision in the other

309
00:12:19,529 --> 00:12:24,029
set and you take this whole thing and

310
00:12:22,050 --> 00:12:25,650
you make it quantum with a standard

311
00:12:24,029 --> 00:12:29,430
construction very similar to Grover's

312
00:12:25,650 --> 00:12:33,390
algorithm so what happens with this is

313
00:12:29,430 --> 00:12:35,640
that the lengths of the random walk the

314
00:12:33,390 --> 00:12:39,480
random walk gets faster if the sets are

315
00:12:35,640 --> 00:12:41,640
bigger and Kenny optimized for the query

316
00:12:39,480 --> 00:12:43,080
optimal where you actually have to

317
00:12:41,640 --> 00:12:44,550
balance that with the set up cost to

318
00:12:43,080 --> 00:12:46,320
originally construct this list and

319
00:12:44,550 --> 00:12:49,469
balance that with the total length of

320
00:12:46,320 --> 00:12:50,850
the walk and this is where the size of

321
00:12:49,470 --> 00:12:52,050
the set is proportional to the number of

322
00:12:50,850 --> 00:12:54,810
queries which is proportional to the

323
00:12:52,050 --> 00:12:56,729
time for I saw Jenny based cryptography

324
00:12:54,810 --> 00:12:58,949
for psych these are all equal to P to

325
00:12:56,730 --> 00:13:01,950
the 1/6 so previously the security was

326
00:12:58,950 --> 00:13:06,959
given as P to the 1/6 of the for the

327
00:13:01,950 --> 00:13:10,110
prime P but this is these use a lot of

328
00:13:06,959 --> 00:13:12,719
memories this algorithm and quantum

329
00:13:10,110 --> 00:13:14,820
memory is unusually expensive so in

330
00:13:12,720 --> 00:13:17,700
imagine you've got this array of memory

331
00:13:14,820 --> 00:13:19,560
and these cells at the bottom you can

332
00:13:17,700 --> 00:13:21,089
imagine maybe this is a full chip of

333
00:13:19,560 --> 00:13:22,589
memory or maybe it's a hard drive or

334
00:13:21,089 --> 00:13:24,480
maybe even a tape

335
00:13:22,590 --> 00:13:27,210
and you've got some circuit to access

336
00:13:24,480 --> 00:13:30,810
them so we have a classical query we

337
00:13:27,210 --> 00:13:33,060
want the ninth element of memory we can

338
00:13:30,810 --> 00:13:35,459
follow this red path and at each point

339
00:13:33,060 --> 00:13:37,500
the memory controller can look at the

340
00:13:35,460 --> 00:13:39,180
input and say I only need to take the

341
00:13:37,500 --> 00:13:40,350
left path I don't need to go to the

342
00:13:39,180 --> 00:13:41,849
right I don't need to use any of those

343
00:13:40,350 --> 00:13:44,100
gates I don't need to turn on any of

344
00:13:41,850 --> 00:13:48,210
those memory addresses and so on and

345
00:13:44,100 --> 00:13:51,510
only needs to spend log and gates to

346
00:13:48,210 --> 00:13:54,200
accomplish this task with a quantum

347
00:13:51,510 --> 00:13:58,380
query it might be in superposition and

348
00:13:54,200 --> 00:14:02,190
so the classical controller cannot tell

349
00:13:58,380 --> 00:14:04,080
what memory access they need to return

350
00:14:02,190 --> 00:14:06,200
because they cannot read anything about

351
00:14:04,080 --> 00:14:08,910
the input without destroying the input

352
00:14:06,200 --> 00:14:10,680
so what they have to do the memory

353
00:14:08,910 --> 00:14:12,630
controller has to apply gates for every

354
00:14:10,680 --> 00:14:13,979
possible input because they don't know

355
00:14:12,630 --> 00:14:16,020
what they're getting and it might be a

356
00:14:13,980 --> 00:14:18,240
superposition of every possible access

357
00:14:16,020 --> 00:14:21,300
so this is now a linear number of gates

358
00:14:18,240 --> 00:14:22,770
in the size of the memory and this

359
00:14:21,300 --> 00:14:25,949
should actually be very familiar to

360
00:14:22,770 --> 00:14:29,150
cryptographers because making a fairly

361
00:14:25,950 --> 00:14:31,020
loose analogy here a quantum state is

362
00:14:29,150 --> 00:14:32,790
kind of needs to be side-channel

363
00:14:31,020 --> 00:14:35,370
resistant because if any information

364
00:14:32,790 --> 00:14:37,290
leaks about the state that will decohere

365
00:14:35,370 --> 00:14:39,450
and destroy the state so the circuit

366
00:14:37,290 --> 00:14:41,569
that we use to operate on that state has

367
00:14:39,450 --> 00:14:44,310
to you in it again waving my hands here

368
00:14:41,570 --> 00:14:46,200
be sort of perfectly physically

369
00:14:44,310 --> 00:14:48,030
side-channel resistant and so we need

370
00:14:46,200 --> 00:14:52,170
circuits like this one that works for

371
00:14:48,030 --> 00:14:54,180
all possible inputs and so this can give

372
00:14:52,170 --> 00:14:56,250
us a cost for memory in terms of gates

373
00:14:54,180 --> 00:14:58,170
if the memory is idle if we're not

374
00:14:56,250 --> 00:14:59,730
actually accessing it of course if it's

375
00:14:58,170 --> 00:15:00,780
passively corrected it's free and it

376
00:14:59,730 --> 00:15:04,560
wouldn't be free if it's actively

377
00:15:00,780 --> 00:15:06,750
corrected and for random access we pay

378
00:15:04,560 --> 00:15:10,500
at least a linear cost in both of these

379
00:15:06,750 --> 00:15:13,320
cost models but for Tenney's algorithm

380
00:15:10,500 --> 00:15:14,730
it's actually even worse because we need

381
00:15:13,320 --> 00:15:17,540
some structure to this data to

382
00:15:14,730 --> 00:15:19,500
facilitate insertions and deletions and

383
00:15:17,540 --> 00:15:21,449
for quantum algorithms we need

384
00:15:19,500 --> 00:15:23,610
interference we're doing a random walk

385
00:15:21,450 --> 00:15:26,370
on this Johnson graph and what we need

386
00:15:23,610 --> 00:15:28,140
is that for a particular vertex the

387
00:15:26,370 --> 00:15:30,060
representation of that vertex in our

388
00:15:28,140 --> 00:15:31,650
quantum computer cannot depend on the

389
00:15:30,060 --> 00:15:34,800
path that we took or else it will not

390
00:15:31,650 --> 00:15:36,108
interfere with other paths the light to

391
00:15:34,800 --> 00:15:38,819
the same vertex

392
00:15:36,109 --> 00:15:40,709
but on a Johnson grass a vertex is a set

393
00:15:38,819 --> 00:15:42,719
and a path of the sequence of insertions

394
00:15:40,709 --> 00:15:45,419
and deletions so we need insertions and

395
00:15:42,720 --> 00:15:48,479
deletions to lead to the same

396
00:15:45,419 --> 00:15:51,269
representation of the data our favorite

397
00:15:48,479 --> 00:15:54,839
data structure classically to represent

398
00:15:51,269 --> 00:15:56,489
a list to represent a set is a binary

399
00:15:54,839 --> 00:15:59,909
tree that would we would implement as a

400
00:15:56,489 --> 00:16:02,459
linked list but this doesn't work

401
00:15:59,909 --> 00:16:04,709
because we have fragmentation we have

402
00:16:02,459 --> 00:16:08,549
the layout changing depending on the

403
00:16:04,709 --> 00:16:12,179
order so for history independent data

404
00:16:08,549 --> 00:16:13,739
structures the previous quantum approach

405
00:16:12,179 --> 00:16:15,238
was what's called a quantum radix tree

406
00:16:13,739 --> 00:16:19,139
where you take a binary tree and make a

407
00:16:15,239 --> 00:16:20,909
superposition over all inputs but we

408
00:16:19,139 --> 00:16:22,739
could also have used a sorted array and

409
00:16:20,909 --> 00:16:24,239
so if the elements in an array are

410
00:16:22,739 --> 00:16:25,709
physically in order usually we don't

411
00:16:24,239 --> 00:16:26,939
like this because if we want to insert

412
00:16:25,709 --> 00:16:29,488
it in the middle we have to move

413
00:16:26,939 --> 00:16:30,779
everything after that element down but

414
00:16:29,489 --> 00:16:32,249
we're already paying a linear cost for

415
00:16:30,779 --> 00:16:34,919
memory access so this becomes more

416
00:16:32,249 --> 00:16:36,989
appealing so this is the data structure

417
00:16:34,919 --> 00:16:39,989
we provided in our paper we call today

418
00:16:36,989 --> 00:16:43,049
Johnson vertex and it's just a sorted

419
00:16:39,989 --> 00:16:44,729
array and so to insert into this I'll

420
00:16:43,049 --> 00:16:45,839
walk through what this looks like we've

421
00:16:44,729 --> 00:16:48,509
got all these elements on the bottom

422
00:16:45,839 --> 00:16:51,149
here and we also have an Ansel array of

423
00:16:48,509 --> 00:16:53,519
all zeros so the first thing we do is we

424
00:16:51,149 --> 00:16:55,859
fan out an input X so we use this tree

425
00:16:53,519 --> 00:16:57,749
to copy X to every element so this has

426
00:16:55,859 --> 00:17:01,589
logarithmic depth and your number of

427
00:16:57,749 --> 00:17:06,389
gates we end up with X in every element

428
00:17:01,589 --> 00:17:09,120
and we compare all the elements

429
00:17:06,388 --> 00:17:11,490
simultaneously with the one above them

430
00:17:09,119 --> 00:17:14,219
to see if the element is larger than X

431
00:17:11,490 --> 00:17:16,199
and we end up with zeros and ones in the

432
00:17:14,220 --> 00:17:17,850
top row the shift between zero and one

433
00:17:16,199 --> 00:17:19,620
happens exactly where the elements in

434
00:17:17,849 --> 00:17:22,349
the array became larger than X so that's

435
00:17:19,619 --> 00:17:24,958
exactly where X needs to go so we use

436
00:17:22,349 --> 00:17:27,750
those bits to control a swap that goes

437
00:17:24,959 --> 00:17:29,429
up and to the right and that ends up

438
00:17:27,750 --> 00:17:32,490
shifting the right half of the array up

439
00:17:29,429 --> 00:17:34,139
and to the right and then we swap them

440
00:17:32,490 --> 00:17:36,600
back down controlled on the same bits

441
00:17:34,139 --> 00:17:38,879
and now we have shifted half of the

442
00:17:36,600 --> 00:17:41,070
array down and it's only took two steps

443
00:17:38,879 --> 00:17:45,830
of depth and we've inserted X into the

444
00:17:41,070 --> 00:17:47,279
right spot now we need to uncomputable

445
00:17:45,830 --> 00:17:48,270
we fan out

446
00:17:47,279 --> 00:17:50,850
X

447
00:17:48,270 --> 00:17:52,290
and we have nothing so we have correctly

448
00:17:50,850 --> 00:17:56,820
inserted into our array with this

449
00:17:52,290 --> 00:17:59,520
structure and so this is actually this

450
00:17:56,820 --> 00:18:01,800
Johnson vertex is actually the lowest

451
00:17:59,520 --> 00:18:03,540
gate cost to do the things that we need

452
00:18:01,800 --> 00:18:05,940
a quantum data structure to do for these

453
00:18:03,540 --> 00:18:08,220
random walks so we go back to Tiny's

454
00:18:05,940 --> 00:18:09,900
algorithm and previously was the speed

455
00:18:08,220 --> 00:18:13,410
of the one six query cost they used P to

456
00:18:09,900 --> 00:18:16,309
the one-sixth memory and so immediately

457
00:18:13,410 --> 00:18:18,510
this has a DW cost of P to the one third

458
00:18:16,309 --> 00:18:20,280
but using our data structure we show

459
00:18:18,510 --> 00:18:23,160
that the gates are actually also P to

460
00:18:20,280 --> 00:18:24,780
the one-third now maybe this isn't fair

461
00:18:23,160 --> 00:18:28,410
to Tony's algorithm which was optimized

462
00:18:24,780 --> 00:18:30,720
our queries so if we re optimize for G

463
00:18:28,410 --> 00:18:33,770
cost or DW cost we can bring both the

464
00:18:30,720 --> 00:18:36,179
gate and DW costs down to P to the 1/4

465
00:18:33,770 --> 00:18:37,650
but this is actually the same as

466
00:18:36,179 --> 00:18:40,050
Grover's algorithm up to paly

467
00:18:37,650 --> 00:18:42,710
logarithmic factors so here what we've

468
00:18:40,050 --> 00:18:45,178
shown is that Tandy does not provide

469
00:18:42,710 --> 00:18:49,170
anything beyond a poly log advantage

470
00:18:45,179 --> 00:18:50,460
over Grover for either of these costs to

471
00:18:49,170 --> 00:18:52,860
give a little more intuition on why this

472
00:18:50,460 --> 00:18:54,750
makes sense we use an argument of grover

473
00:18:52,860 --> 00:18:56,760
and rudolf and they say that if you've

474
00:18:54,750 --> 00:18:59,250
got this big quantum computer so for

475
00:18:56,760 --> 00:19:03,150
Tenney's query optimal algorithm we've

476
00:18:59,250 --> 00:19:04,980
got P to the one-sixth qubits we're

477
00:19:03,150 --> 00:19:07,080
ready to apply any gate we want to any

478
00:19:04,980 --> 00:19:08,280
qubit we want at every time step so we

479
00:19:07,080 --> 00:19:09,870
could do anything else with these qubits

480
00:19:08,280 --> 00:19:12,690
that we wanted we could group them

481
00:19:09,870 --> 00:19:15,090
together into a little arrays and run

482
00:19:12,690 --> 00:19:16,920
Grover on each of them so now we've got

483
00:19:15,090 --> 00:19:18,389
P to the 1 6 copies of Grover's

484
00:19:16,920 --> 00:19:20,880
algorithm they're all running in

485
00:19:18,390 --> 00:19:22,800
parallel and we do the math on this and

486
00:19:20,880 --> 00:19:25,140
they find the iso journey in time p to

487
00:19:22,800 --> 00:19:26,909
the 1/6 so this is the same time as

488
00:19:25,140 --> 00:19:28,559
Tanya's algorithm so this is saying is

489
00:19:26,910 --> 00:19:30,030
that this hardware to run the query

490
00:19:28,559 --> 00:19:32,040
optimal version of Tani's algorithm

491
00:19:30,030 --> 00:19:35,970
could be repurposed to run Grover and

492
00:19:32,040 --> 00:19:38,520
get the same time but it's actually even

493
00:19:35,970 --> 00:19:40,740
worse because if you remember a quantum

494
00:19:38,520 --> 00:19:42,600
computer has a classical controller and

495
00:19:40,740 --> 00:19:44,820
so it will have P to the one-sixth

496
00:19:42,600 --> 00:19:46,919
classical control processors associated

497
00:19:44,820 --> 00:19:48,360
to all the qubits what if instead of

498
00:19:46,920 --> 00:19:51,510
running the quantum algorithm we sort of

499
00:19:48,360 --> 00:19:52,889
turned the qubits off and we repurpose

500
00:19:51,510 --> 00:19:54,660
the controllers to run vanish at Wiener

501
00:19:52,890 --> 00:19:57,179
so this is a lot of classical

502
00:19:54,660 --> 00:19:59,460
controllers this is P to the 1/6 when

503
00:19:57,179 --> 00:20:01,080
they run van oorschot wiener they won't

504
00:19:59,460 --> 00:20:01,930
find the Asajj in the in time P to the

505
00:20:01,080 --> 00:20:05,230
1/8

506
00:20:01,930 --> 00:20:07,120
so our conclusion here is that if you

507
00:20:05,230 --> 00:20:10,330
had an adversary who actually built this

508
00:20:07,120 --> 00:20:13,780
enormous quantum computer to run tanny's

509
00:20:10,330 --> 00:20:15,760
algorithm they have implicitly built

510
00:20:13,780 --> 00:20:17,290
such a large classical computer to run

511
00:20:15,760 --> 00:20:18,730
this quantum algorithm that they'd be

512
00:20:17,290 --> 00:20:22,180
better served just using the classical

513
00:20:18,730 --> 00:20:25,930
computer to begin with and so this is

514
00:20:22,180 --> 00:20:28,570
the big conclusion of our paper but our

515
00:20:25,930 --> 00:20:30,520
main contribution here is this memory

516
00:20:28,570 --> 00:20:32,889
peripheral framework and so what we want

517
00:20:30,520 --> 00:20:34,750
you to take away is thinking of quantum

518
00:20:32,890 --> 00:20:36,520
computers as peripherals to classical

519
00:20:34,750 --> 00:20:38,530
computers and thinking that everything

520
00:20:36,520 --> 00:20:40,060
you do on the quantum computer was

521
00:20:38,530 --> 00:20:40,960
controlled by the classical computer and

522
00:20:40,060 --> 00:20:42,970
you can think in terms of those

523
00:20:40,960 --> 00:20:44,740
classical costs which are now directly

524
00:20:42,970 --> 00:20:49,510
comparable to any classical algorithm

525
00:20:44,740 --> 00:20:51,700
and so from this you can give a linear

526
00:20:49,510 --> 00:20:55,150
gate cost to memory access for quantum

527
00:20:51,700 --> 00:20:56,680
algorithms and even further if you're

528
00:20:55,150 --> 00:20:59,320
skeptical about this passively corrected

529
00:20:56,680 --> 00:21:03,790
memory you can use this DW cost and give

530
00:20:59,320 --> 00:21:06,100
it cost of the identity gate so that's

531
00:21:03,790 --> 00:21:18,340
everything thank you for your listening

532
00:21:06,100 --> 00:21:21,559
[Applause]

533
00:21:18,340 --> 00:21:26,320
if you have any questions so please come

534
00:21:21,559 --> 00:21:26,320
down to the front to the microphone now

535
00:21:28,360 --> 00:21:34,248
if there are no questions we'll move to

536
00:21:30,950 --> 00:21:34,680
the second talk let's thank the speaker

537
00:21:34,249 --> 00:21:39,289
again

538
00:21:34,680 --> 00:21:39,289
[Applause]

