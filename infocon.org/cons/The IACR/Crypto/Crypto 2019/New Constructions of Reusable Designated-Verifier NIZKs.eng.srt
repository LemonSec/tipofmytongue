1
00:00:05,390 --> 00:00:10,379
hey everyone thanks for coming I'm

2
00:00:08,219 --> 00:00:12,719
presenting joint work with Willie Ron

3
00:00:10,379 --> 00:00:15,000
Daniel and David and I'm gonna be

4
00:00:12,719 --> 00:00:16,740
talking about reusable designated

5
00:00:15,000 --> 00:00:19,349
verifier non-interactive zero-knowledge

6
00:00:16,740 --> 00:00:21,599
arguments so I'd like to thank David for

7
00:00:19,349 --> 00:00:22,920
giving me his slides so the usual

8
00:00:21,600 --> 00:00:26,340
disclaimer all the good things are his

9
00:00:22,920 --> 00:00:29,640
all the bad things are mine and on that

10
00:00:26,340 --> 00:00:31,080
note let's get started so I'm going to

11
00:00:29,640 --> 00:00:32,940
be talking about non interactive

12
00:00:31,080 --> 00:00:34,559
zero-knowledge arguments and just to

13
00:00:32,940 --> 00:00:36,180
remind you this is a setting where

14
00:00:34,559 --> 00:00:38,430
approver wants to convince a

15
00:00:36,180 --> 00:00:40,949
computationally bounded verifier that

16
00:00:38,430 --> 00:00:43,710
some statement X is in some NP language

17
00:00:40,949 --> 00:00:47,549
l he's allowed to send a single message

18
00:00:43,710 --> 00:00:51,239
so the proof is one message and it

19
00:00:47,549 --> 00:00:52,920
should satisfy completeness so a correct

20
00:00:51,239 --> 00:00:57,360
proof on a true statement should

21
00:00:52,920 --> 00:00:59,460
convince the verifier soundness a even

22
00:00:57,360 --> 00:01:01,110
maliciously generated proof on a false

23
00:00:59,460 --> 00:01:03,540
statement should still not convinced the

24
00:01:01,110 --> 00:01:06,210
verifier and to satisfy zero knowledge

25
00:01:03,540 --> 00:01:09,330
namely that a correct proof on a true

26
00:01:06,210 --> 00:01:11,039
statement should be simulated given only

27
00:01:09,330 --> 00:01:14,280
the instance it should be simulated well

28
00:01:11,040 --> 00:01:17,160
in polynomial time and the simulator

29
00:01:14,280 --> 00:01:19,830
isn't given any sort of witness for X

30
00:01:17,160 --> 00:01:21,210
being in the language so this is a non

31
00:01:19,830 --> 00:01:22,679
interactive zero knowledge proof or

32
00:01:21,210 --> 00:01:26,250
arguments if the soundness is only

33
00:01:22,680 --> 00:01:29,340
computational and just to remind you on

34
00:01:26,250 --> 00:01:31,380
the state of the Arts on this object we

35
00:01:29,340 --> 00:01:33,630
can construct it if the prover and

36
00:01:31,380 --> 00:01:36,570
verifier have access to a random Oracle

37
00:01:33,630 --> 00:01:38,190
and we can also construct it if the

38
00:01:36,570 --> 00:01:40,350
prover and verifier have access to a

39
00:01:38,190 --> 00:01:43,020
common reference string under certain

40
00:01:40,350 --> 00:01:44,429
computational assumptions so it's been

41
00:01:43,020 --> 00:01:46,530
known for a long time that you can do

42
00:01:44,430 --> 00:01:49,110
this under Q our factoring assumptions

43
00:01:46,530 --> 00:01:51,090
are from bilinear maps and then just

44
00:01:49,110 --> 00:01:52,290
this year it was shown that variants of

45
00:01:51,090 --> 00:01:53,700
the learning with errors assumption

46
00:01:52,290 --> 00:01:55,820
first with the circular security

47
00:01:53,700 --> 00:01:58,110
assumption thrown in and then without

48
00:01:55,820 --> 00:02:00,389
also suffice to construct non

49
00:01:58,110 --> 00:02:03,360
interactive zero knowledge so this is

50
00:02:00,390 --> 00:02:06,299
the state of the Arts on music and just

51
00:02:03,360 --> 00:02:07,979
a couple of remarks on this so the

52
00:02:06,299 --> 00:02:10,440
constructions are all fairly ad-hoc and

53
00:02:07,979 --> 00:02:12,659
different from each other and there are

54
00:02:10,440 --> 00:02:14,670
notable computational assumptions that

55
00:02:12,659 --> 00:02:16,090
we don't know how to use to construct

56
00:02:14,670 --> 00:02:18,849
musics at the moments the

57
00:02:16,090 --> 00:02:21,280
the clearest examples are diffie-hellman

58
00:02:18,849 --> 00:02:23,769
style assumptions along with the

59
00:02:21,280 --> 00:02:26,620
learning parody with noise assumption so

60
00:02:23,770 --> 00:02:29,500
in contrast to the state of affairs on

61
00:02:26,620 --> 00:02:32,980
music that I just described what we ask

62
00:02:29,500 --> 00:02:35,440
in this work is if is there a general

63
00:02:32,980 --> 00:02:38,200
framework for constructing musics and

64
00:02:35,440 --> 00:02:40,329
the setting that we consider this

65
00:02:38,200 --> 00:02:42,339
question in is that of a designated

66
00:02:40,330 --> 00:02:46,660
verifier music so this is a relaxation

67
00:02:42,340 --> 00:02:48,340
of music in which we make a stronger set

68
00:02:46,660 --> 00:02:50,709
of assumption so instead of just

69
00:02:48,340 --> 00:02:53,170
generating a common reference string we

70
00:02:50,709 --> 00:02:54,519
now elect the setup algorithm to

71
00:02:53,170 --> 00:02:57,280
generate the common reference string

72
00:02:54,519 --> 00:02:59,680
along with a secret verification key

73
00:02:57,280 --> 00:03:02,650
that only the verifier gets so this

74
00:02:59,680 --> 00:03:04,630
helps the verifier to verify proofs and

75
00:03:02,650 --> 00:03:06,790
soundness is only guaranteed to hold

76
00:03:04,630 --> 00:03:10,840
when the prover doesn't know what the

77
00:03:06,790 --> 00:03:11,980
secret verification key is and so I'd

78
00:03:10,840 --> 00:03:14,410
also like to point out there's some

79
00:03:11,980 --> 00:03:16,179
subtlety here because the verifier has a

80
00:03:14,410 --> 00:03:18,370
secret there's a question of whether or

81
00:03:16,180 --> 00:03:20,170
not you allow the prover to interact

82
00:03:18,370 --> 00:03:21,609
with the verifier in multiple times this

83
00:03:20,170 --> 00:03:24,760
kind of interaction might give something

84
00:03:21,609 --> 00:03:27,040
away about the verifier secrets so in

85
00:03:24,760 --> 00:03:29,108
this work we're considering a soundness

86
00:03:27,040 --> 00:03:33,910
notion in which the prover gets query

87
00:03:29,109 --> 00:03:35,920
access to a verifier and therefore we

88
00:03:33,910 --> 00:03:37,359
have to rule out these sorts of attacks

89
00:03:35,920 --> 00:03:39,608
where you learn the secret key by

90
00:03:37,359 --> 00:03:44,019
querying the verifier so we don't want

91
00:03:39,609 --> 00:03:45,819
we don't want to have this so okay this

92
00:03:44,019 --> 00:03:47,980
is this is a kind of music you can

93
00:03:45,819 --> 00:03:50,679
define it it's not clear necessarily why

94
00:03:47,980 --> 00:03:53,410
you should care so so two things I want

95
00:03:50,680 --> 00:03:54,850
to say are that first of all it turns

96
00:03:53,410 --> 00:03:56,769
out these kind of physics are still

97
00:03:54,850 --> 00:03:59,319
useful for some of the classical

98
00:03:56,769 --> 00:04:01,720
applications of musics so the clearest

99
00:03:59,319 --> 00:04:03,970
example of this is the CPE to see see a

100
00:04:01,720 --> 00:04:06,069
security transformation for public key

101
00:04:03,970 --> 00:04:08,769
encryption so that still works with this

102
00:04:06,069 --> 00:04:11,950
kind of music and additionally depending

103
00:04:08,769 --> 00:04:13,900
on your setup assumptions and in the

104
00:04:11,950 --> 00:04:16,329
kind of NPC that you're doing this also

105
00:04:13,900 --> 00:04:20,019
might suffice to boost semi honest to

106
00:04:16,329 --> 00:04:23,310
malicious security for MPC and I'll

107
00:04:20,019 --> 00:04:25,930
touch upon that a little bit more later

108
00:04:23,310 --> 00:04:27,010
in addition just from a theoretical

109
00:04:25,930 --> 00:04:28,510
perspective you know this is a

110
00:04:27,010 --> 00:04:29,770
relaxation of a music it's

111
00:04:28,510 --> 00:04:32,260
like it should be easier to construct

112
00:04:29,770 --> 00:04:34,240
you can ask well is it really easier to

113
00:04:32,260 --> 00:04:36,099
construct do we do we know how to do it

114
00:04:34,240 --> 00:04:38,020
in other ways besides just constructing

115
00:04:36,100 --> 00:04:40,210
and music and then still very recently

116
00:04:38,020 --> 00:04:41,469
the answer was no any construction of it

117
00:04:40,210 --> 00:04:43,630
designated to verify our music that we

118
00:04:41,470 --> 00:04:46,810
had was effectively just constructing a

119
00:04:43,630 --> 00:04:50,140
publicly verifiable music so in the last

120
00:04:46,810 --> 00:04:52,770
year or Crypt this with the things

121
00:04:50,140 --> 00:04:55,180
changed so we there was a construction

122
00:04:52,770 --> 00:04:57,729
there were constructions from the scene

123
00:04:55,180 --> 00:04:58,870
eh or indeed eh assumptions which we

124
00:04:57,730 --> 00:05:00,760
don't know how to use to get

125
00:04:58,870 --> 00:05:03,040
non-interactive zero knowledge and in

126
00:05:00,760 --> 00:05:04,060
the publicly verifiable setting again

127
00:05:03,040 --> 00:05:07,270
this is uh this is an ad hoc

128
00:05:04,060 --> 00:05:09,250
construction and in this work we're

129
00:05:07,270 --> 00:05:13,500
interested in you know how generically

130
00:05:09,250 --> 00:05:16,090
we can construct this object and finally

131
00:05:13,500 --> 00:05:19,240
what I want to say is that if you relax

132
00:05:16,090 --> 00:05:21,239
even further and only ask soundness to

133
00:05:19,240 --> 00:05:24,250
holds when the prover doesn't have any

134
00:05:21,240 --> 00:05:26,740
Oracle access to the verifier then the

135
00:05:24,250 --> 00:05:29,080
problem becomes easy you can construct

136
00:05:26,740 --> 00:05:30,820
that kind of designated verifier music

137
00:05:29,080 --> 00:05:33,640
from any public key encryption scheme

138
00:05:30,820 --> 00:05:35,440
which is significantly more general than

139
00:05:33,640 --> 00:05:38,560
our construction then these other

140
00:05:35,440 --> 00:05:41,430
objects so if you relax far enough the

141
00:05:38,560 --> 00:05:44,230
problem becomes easy but it's not clear

142
00:05:41,430 --> 00:05:46,780
how difficult constructing this object

143
00:05:44,230 --> 00:05:48,520
should be in the specific setting that

144
00:05:46,780 --> 00:05:51,969
turns out to be useful for example in

145
00:05:48,520 --> 00:05:53,770
these transformations so that's where we

146
00:05:51,970 --> 00:05:56,290
are that's the that's the question

147
00:05:53,770 --> 00:05:59,650
that's why you might care and in this

148
00:05:56,290 --> 00:06:02,650
work we give a generic construction of

149
00:05:59,650 --> 00:06:05,830
designated verifier in isaacs satisfying

150
00:06:02,650 --> 00:06:07,570
this reusable soundness from a form of

151
00:06:05,830 --> 00:06:10,270
attribute based encryption and I'll

152
00:06:07,570 --> 00:06:13,510
define exactly what kind of a b/e we use

153
00:06:10,270 --> 00:06:15,820
later but I'd like to note that is that

154
00:06:13,510 --> 00:06:17,980
it is a single key a B E and not a

155
00:06:15,820 --> 00:06:21,460
collision resistant a B II so this is

156
00:06:17,980 --> 00:06:22,360
not like this is not a difficult object

157
00:06:21,460 --> 00:06:24,219
to construct there are many

158
00:06:22,360 --> 00:06:29,290
constructions of the objects that we

159
00:06:24,220 --> 00:06:32,230
that we that we use so this a B

160
00:06:29,290 --> 00:06:34,330
satisfies some sort of CCA like security

161
00:06:32,230 --> 00:06:36,490
property so the main takeaway point that

162
00:06:34,330 --> 00:06:39,729
I want you all to get is that through

163
00:06:36,490 --> 00:06:41,920
this transformation we're able to apply

164
00:06:39,730 --> 00:06:42,220
some recent techniques for constructing

165
00:06:41,920 --> 00:06:44,710
C

166
00:06:42,220 --> 00:06:46,960
see a secure encryption in order to get

167
00:06:44,710 --> 00:06:50,650
designated verify our NICs as well and

168
00:06:46,960 --> 00:06:52,479
so on an intuition level like a CCA

169
00:06:50,650 --> 00:06:55,120
secure encryption is sort of like a

170
00:06:52,480 --> 00:06:57,370
standard public key encryption along

171
00:06:55,120 --> 00:06:59,830
with some sort of designated verifier

172
00:06:57,370 --> 00:07:02,950
and music proof of some consistency

173
00:06:59,830 --> 00:07:04,419
about the ciphertext so so what we're

174
00:07:02,950 --> 00:07:06,610
able to do in this work is use the

175
00:07:04,420 --> 00:07:08,380
techniques for constructing CCA secure

176
00:07:06,610 --> 00:07:10,990
encryption in order to get a

177
00:07:08,380 --> 00:07:13,480
general-purpose designated verifier

178
00:07:10,990 --> 00:07:15,460
music as opposed to morally a designated

179
00:07:13,480 --> 00:07:19,090
verifier music for a specific plaintext

180
00:07:15,460 --> 00:07:21,880
or cipher text language so this is the

181
00:07:19,090 --> 00:07:24,460
main takeaway in a little more detail we

182
00:07:21,880 --> 00:07:26,890
define this objects that we call weak

183
00:07:24,460 --> 00:07:29,200
function hiding single key a b e and we

184
00:07:26,890 --> 00:07:31,870
show it implies doesn't need to verify

185
00:07:29,200 --> 00:07:33,760
our Nozick's in addition we actually

186
00:07:31,870 --> 00:07:35,200
show that assuming public encryption the

187
00:07:33,760 --> 00:07:37,300
two objects are equivalent so this is a

188
00:07:35,200 --> 00:07:40,870
actually a reformulation of the problem

189
00:07:37,300 --> 00:07:45,610
just a complete reformulation and then

190
00:07:40,870 --> 00:07:48,160
on top of that we note that standard lwe

191
00:07:45,610 --> 00:07:50,560
based Ashley based encryption almost

192
00:07:48,160 --> 00:07:52,990
satisfies the security definition that

193
00:07:50,560 --> 00:07:55,240
we care about and a slight tweak to the

194
00:07:52,990 --> 00:07:56,020
standard scheme will get us the security

195
00:07:55,240 --> 00:07:59,160
property we want

196
00:07:56,020 --> 00:08:03,010
so once we've proved this equivalence

197
00:07:59,160 --> 00:08:05,110
this gives us an easy way to to

198
00:08:03,010 --> 00:08:06,490
construct but yeah assuming the

199
00:08:05,110 --> 00:08:07,990
equivalence this gives us an easy way to

200
00:08:06,490 --> 00:08:11,860
construct designated verifier in his

201
00:08:07,990 --> 00:08:13,960
extramural w/e so you could of course

202
00:08:11,860 --> 00:08:16,180
asked for a lot more right like I was

203
00:08:13,960 --> 00:08:19,239
saying like single key a V E is not too

204
00:08:16,180 --> 00:08:21,490
hard to construct so you could ask if

205
00:08:19,240 --> 00:08:23,169
this function hiding single P AV e could

206
00:08:21,490 --> 00:08:25,030
could be constructed from any public key

207
00:08:23,169 --> 00:08:27,010
encryption so that would resolve a big

208
00:08:25,030 --> 00:08:30,340
open problem and that would be super

209
00:08:27,010 --> 00:08:32,650
nice we weren't able to do that but we

210
00:08:30,340 --> 00:08:34,209
were able to show that this kind of AV e

211
00:08:32,650 --> 00:08:37,449
can be constructed from public key

212
00:08:34,210 --> 00:08:39,400
encryption along with any secret key

213
00:08:37,450 --> 00:08:43,000
encryption scheme satisfying a weak form

214
00:08:39,400 --> 00:08:44,620
of KDM or circular security so if this

215
00:08:43,000 --> 00:08:46,710
looks familiar it's because this is the

216
00:08:44,620 --> 00:08:50,410
same pair of assumptions that were used

217
00:08:46,710 --> 00:08:52,420
yesterday by Kitagawa macedon tanaka in

218
00:08:50,410 --> 00:08:54,790
order to construct CCA secure public key

219
00:08:52,420 --> 00:08:56,469
encryption so we show that the same

220
00:08:54,790 --> 00:09:00,000
assumptions suffice to get full-fledged

221
00:08:56,470 --> 00:09:02,590
doesn't it verify our music and then

222
00:09:00,000 --> 00:09:05,110
there are instantiation of these object

223
00:09:02,590 --> 00:09:07,960
of these two building blocks from all

224
00:09:05,110 --> 00:09:09,580
the usual suspects in terms of public

225
00:09:07,960 --> 00:09:11,500
key assumptions and so this gives a

226
00:09:09,580 --> 00:09:13,030
unified approach for getting designated

227
00:09:11,500 --> 00:09:16,920
verifier musics from all the assumptions

228
00:09:13,030 --> 00:09:18,579
that you would probably think about and

229
00:09:16,920 --> 00:09:21,910
among these three

230
00:09:18,580 --> 00:09:23,410
there was like LP n specifically we

231
00:09:21,910 --> 00:09:26,199
didn't know how to construct designated

232
00:09:23,410 --> 00:09:30,120
verifier musics from LP n at all and so

233
00:09:26,200 --> 00:09:32,950
this approach gives the first such so

234
00:09:30,120 --> 00:09:36,940
this is these are our results on

235
00:09:32,950 --> 00:09:39,880
designated verifier musics i do want to

236
00:09:36,940 --> 00:09:43,660
talk about one of our extensions to a

237
00:09:39,880 --> 00:09:45,580
sort of malicious setting so one problem

238
00:09:43,660 --> 00:09:48,040
that you might have with designated

239
00:09:45,580 --> 00:09:50,410
verifier musics is that it makes a very

240
00:09:48,040 --> 00:09:51,730
strong set up assumption not only do you

241
00:09:50,410 --> 00:09:53,410
have to set up a common reference string

242
00:09:51,730 --> 00:09:54,970
but you have this strange set up in

243
00:09:53,410 --> 00:09:57,520
which you have to give the verifier a

244
00:09:54,970 --> 00:09:59,320
secret key and make sure the prover

245
00:09:57,520 --> 00:10:04,870
doesn't know anything about it which is

246
00:09:59,320 --> 00:10:07,570
a little strange so one way to mitigate

247
00:10:04,870 --> 00:10:13,080
this problem is to change the model and

248
00:10:07,570 --> 00:10:16,330
so in the in a year craft this past year

249
00:10:13,080 --> 00:10:18,640
command and wix defines the malicious

250
00:10:16,330 --> 00:10:20,410
designated verifier in musics so the

251
00:10:18,640 --> 00:10:24,100
model is that the prover and verifier

252
00:10:20,410 --> 00:10:27,130
have a common random string the verifier

253
00:10:24,100 --> 00:10:29,770
is allowed to pick his own secret key

254
00:10:27,130 --> 00:10:31,780
and send some public key to the prover

255
00:10:29,770 --> 00:10:34,510
and then the prover should be able to

256
00:10:31,780 --> 00:10:36,130
prove arbitrary statements given just

257
00:10:34,510 --> 00:10:38,230
the common random string and the public

258
00:10:36,130 --> 00:10:39,730
key that the verifier picked so

259
00:10:38,230 --> 00:10:41,500
zero-knowledge should hold against

260
00:10:39,730 --> 00:10:43,930
malicious verifiers here and soundness

261
00:10:41,500 --> 00:10:46,360
should hold as before so this is a

262
00:10:43,930 --> 00:10:49,780
strictly stronger object than a

263
00:10:46,360 --> 00:10:51,430
designated verifier music and it's

264
00:10:49,780 --> 00:10:53,290
affected like by another name this thing

265
00:10:51,430 --> 00:10:55,359
is just a two message zero-knowledge

266
00:10:53,290 --> 00:10:57,490
arguments in the common random string

267
00:10:55,360 --> 00:10:59,050
model where we want to be able to reuse

268
00:10:57,490 --> 00:11:04,120
the first message across many executions

269
00:10:59,050 --> 00:11:07,390
so so our results for designated

270
00:11:04,120 --> 00:11:08,500
verifier music translates entirely to

271
00:11:07,390 --> 00:11:10,120
the malicious setting

272
00:11:08,500 --> 00:11:11,980
all you have to do is take every

273
00:11:10,120 --> 00:11:14,500
instance of encryption from before and

274
00:11:11,980 --> 00:11:16,630
replace it by an OT I'm of course

275
00:11:14,500 --> 00:11:18,280
skipping over a lot of details there but

276
00:11:16,630 --> 00:11:20,620
that's the that's the main that's the

277
00:11:18,280 --> 00:11:22,750
main point so we get a generic

278
00:11:20,620 --> 00:11:25,990
construction of this malicious

279
00:11:22,750 --> 00:11:29,590
designated verifier in music from a to

280
00:11:25,990 --> 00:11:31,810
message along with KDM secure secret key

281
00:11:29,590 --> 00:11:34,000
encryption and again this can be

282
00:11:31,810 --> 00:11:36,900
instantiated from the usual suspects

283
00:11:34,000 --> 00:11:39,940
concrete assumptions and in this setting

284
00:11:36,900 --> 00:11:42,370
both the constructions from CD age and

285
00:11:39,940 --> 00:11:43,870
LPN are entirely new there were no

286
00:11:42,370 --> 00:11:50,170
constructions of this object from either

287
00:11:43,870 --> 00:11:53,800
of those before so and finally I want to

288
00:11:50,170 --> 00:11:55,740
mention that this malicious designated

289
00:11:53,800 --> 00:11:57,729
verifier music has connections to

290
00:11:55,740 --> 00:12:00,280
reusable non interactive secure

291
00:11:57,730 --> 00:12:03,010
computation and in particular it allows

292
00:12:00,280 --> 00:12:04,689
you to do reusable non interactive C or

293
00:12:03,010 --> 00:12:07,210
secure computation from any of these

294
00:12:04,690 --> 00:12:10,060
assumptions I'll refer to the paper for

295
00:12:07,210 --> 00:12:12,880
more details on that so that's all I

296
00:12:10,060 --> 00:12:14,079
want to say on our results for the rest

297
00:12:12,880 --> 00:12:16,810
of the time I want to tell you a little

298
00:12:14,080 --> 00:12:19,690
bit about how we prove it in particular

299
00:12:16,810 --> 00:12:22,479
I want to focus on this first on this

300
00:12:19,690 --> 00:12:24,070
first arrow which I think of as the like

301
00:12:22,480 --> 00:12:25,870
the main contribution being this arrow

302
00:12:24,070 --> 00:12:27,400
and the formulation of the a B that

303
00:12:25,870 --> 00:12:32,020
turns out to be useful so I'm gonna tell

304
00:12:27,400 --> 00:12:34,870
you both of this so to start I want to

305
00:12:32,020 --> 00:12:36,880
recall the designated verifier music

306
00:12:34,870 --> 00:12:38,950
from any public key encryption scheme

307
00:12:36,880 --> 00:12:40,900
that satisfies the weaker form of

308
00:12:38,950 --> 00:12:42,760
soundness the one-time soundness so this

309
00:12:40,900 --> 00:12:45,430
is due to postulate and Vikings anitha

310
00:12:42,760 --> 00:12:48,010
and it works like this we're going to

311
00:12:45,430 --> 00:12:50,020
start with a three message protocol and

312
00:12:48,010 --> 00:12:52,420
we're going to compress it into a one

313
00:12:50,020 --> 00:12:56,199
message protocol so the three message

314
00:12:52,420 --> 00:13:00,430
protocol should have a 1 bit challenge

315
00:12:56,200 --> 00:13:02,860
just for the purposes of this talk we

316
00:13:00,430 --> 00:13:05,530
can we can compile more generally and we

317
00:13:02,860 --> 00:13:07,570
do in the paper but for explaining let's

318
00:13:05,530 --> 00:13:08,829
assume we have a single bit challenge so

319
00:13:07,570 --> 00:13:11,470
the three methods protocol is some

320
00:13:08,830 --> 00:13:14,230
commitment some one bit challenge from

321
00:13:11,470 --> 00:13:17,080
the verifier and then some response from

322
00:13:14,230 --> 00:13:18,760
the prover given the challenge we're

323
00:13:17,080 --> 00:13:22,389
going to compress this into a one

324
00:13:18,760 --> 00:13:24,999
message protocol so here's what we do

325
00:13:22,389 --> 00:13:27,040
we're gonna give the prover two public

326
00:13:24,999 --> 00:13:29,499
keys for a public key encryption scheme

327
00:13:27,040 --> 00:13:33,238
and we're gonna give the verifier a

328
00:13:29,499 --> 00:13:36,189
random that'd be along with exactly one

329
00:13:33,239 --> 00:13:38,799
secret key out of the two corresponding

330
00:13:36,189 --> 00:13:40,238
to those two public keys and we're gonna

331
00:13:38,799 --> 00:13:43,209
give them a secret key so B where B is

332
00:13:40,239 --> 00:13:45,429
the random bits so so why would we do

333
00:13:43,209 --> 00:13:47,109
this well we're going to use this to

334
00:13:45,429 --> 00:13:50,769
sort of simulates the three message

335
00:13:47,110 --> 00:13:52,899
protocol with challenge bit B the

336
00:13:50,769 --> 00:13:54,730
verifier is going to be able to obtain a

337
00:13:52,899 --> 00:13:57,610
transcript of the three message protocol

338
00:13:54,730 --> 00:13:59,079
using challenge bit B so the way we

339
00:13:57,610 --> 00:14:02,079
implement this is that we have the

340
00:13:59,079 --> 00:14:06,189
prover send over a commitment along with

341
00:14:02,079 --> 00:14:08,349
two cipher texts cipher texts zero is

342
00:14:06,189 --> 00:14:10,299
going to be an encryption of the

343
00:14:08,350 --> 00:14:11,709
response for challenge zero and cipher

344
00:14:10,299 --> 00:14:14,319
text one is going to be an encryption of

345
00:14:11,709 --> 00:14:16,809
the response for challenge one under the

346
00:14:14,319 --> 00:14:19,929
two different public keys so then the

347
00:14:16,809 --> 00:14:21,759
verifier is able to decrypt exactly one

348
00:14:19,929 --> 00:14:24,999
of these two cipher texts the one

349
00:14:21,759 --> 00:14:28,809
corresponding to B this will give him a

350
00:14:24,999 --> 00:14:31,299
transcript a C Z of the three message

351
00:14:28,809 --> 00:14:34,299
protocol with with with challenge bit

352
00:14:31,299 --> 00:14:37,889
and B and then he can accept if that

353
00:14:34,299 --> 00:14:40,600
three message transcript looks good so

354
00:14:37,889 --> 00:14:43,480
this will give you soundness one half

355
00:14:40,600 --> 00:14:45,309
you can repeat many times in parallel to

356
00:14:43,480 --> 00:14:46,869
get negligible soundness but I'm gonna

357
00:14:45,309 --> 00:14:48,459
forget this for the rest of the talk and

358
00:14:46,869 --> 00:14:52,869
just think about the soundness one half

359
00:14:48,459 --> 00:14:55,479
case so here it is you can show that one

360
00:14:52,869 --> 00:14:57,429
it satisfies zero knowledge and two that

361
00:14:55,480 --> 00:14:59,679
it satisfies soundness if you don't give

362
00:14:57,429 --> 00:15:02,049
the prover query access to the verifier

363
00:14:59,679 --> 00:15:03,730
and and the reason for this that that

364
00:15:02,049 --> 00:15:05,230
soundness holds is essentially the prove

365
00:15:03,730 --> 00:15:07,059
it doesn't know what this bit B is it's

366
00:15:05,230 --> 00:15:08,799
just a random bit and so you can reduce

367
00:15:07,059 --> 00:15:11,279
from the soundness of the three message

368
00:15:08,799 --> 00:15:14,499
protocol because of that

369
00:15:11,279 --> 00:15:17,199
however this protocol does not satisfy

370
00:15:14,499 --> 00:15:19,749
the kind of soundness that we want and

371
00:15:17,199 --> 00:15:22,209
the reason is that by querying the

372
00:15:19,749 --> 00:15:25,689
verifier you can actually learn what

373
00:15:22,209 --> 00:15:27,248
this bit B is and once you learn what

374
00:15:25,689 --> 00:15:28,719
the bit B is soundness is entirely

375
00:15:27,249 --> 00:15:30,100
compromised if you think about the three

376
00:15:28,720 --> 00:15:31,179
message case this is clear if you know

377
00:15:30,100 --> 00:15:32,589
what the challenge is going to be in

378
00:15:31,179 --> 00:15:34,410
advance then then you don't have

379
00:15:32,589 --> 00:15:36,250
soundness

380
00:15:34,410 --> 00:15:39,310
so Oh

381
00:15:36,250 --> 00:15:41,170
okay so so what's the issue I want to

382
00:15:39,310 --> 00:15:43,209
say that fundamentally the problem is

383
00:15:41,170 --> 00:15:46,660
that the verifier has this fixed random

384
00:15:43,210 --> 00:15:48,640
bit B that he's stuck using for every

385
00:15:46,660 --> 00:15:51,430
proof that the prover sends over this is

386
00:15:48,640 --> 00:15:54,340
fundamentally the problem so the way

387
00:15:51,430 --> 00:15:56,260
that we get around it is we set things

388
00:15:54,340 --> 00:15:59,590
up so that there isn't a single random

389
00:15:56,260 --> 00:16:02,380
bit B but actually an independent random

390
00:15:59,590 --> 00:16:05,280
bit B for every possible statements that

391
00:16:02,380 --> 00:16:07,630
the prover could be trying to proof and

392
00:16:05,280 --> 00:16:08,650
intuitively at least it might seem

393
00:16:07,630 --> 00:16:10,060
reasonable that if you could do

394
00:16:08,650 --> 00:16:13,840
something like that then you might get

395
00:16:10,060 --> 00:16:16,000
reusable soundness so the way that we

396
00:16:13,840 --> 00:16:18,700
implement this is by using a form of

397
00:16:16,000 --> 00:16:20,980
attribute based encryption which very

398
00:16:18,700 --> 00:16:25,620
briefly is a way to encrypt a message M

399
00:16:20,980 --> 00:16:28,330
under an attribute X so that a decrypter

400
00:16:25,620 --> 00:16:31,050
can have a secret key associated to a

401
00:16:28,330 --> 00:16:33,580
function on attribute space a function f

402
00:16:31,050 --> 00:16:36,520
so that the Decrypter can learn the

403
00:16:33,580 --> 00:16:39,010
message if f of X is equal to 1 and the

404
00:16:36,520 --> 00:16:41,860
Decrypter learns nothing and you in fact

405
00:16:39,010 --> 00:16:44,110
have a form of semantic security if f of

406
00:16:41,860 --> 00:16:46,630
X is equal to 0 so this is after you

407
00:16:44,110 --> 00:16:49,030
based encryption so here's how we're

408
00:16:46,630 --> 00:16:52,390
going to use it to compile the Sigma

409
00:16:49,030 --> 00:16:54,310
protocol so again recall we want to

410
00:16:52,390 --> 00:16:56,319
somehow have a different bit B for every

411
00:16:54,310 --> 00:16:57,609
statement so the way we're going to do

412
00:16:56,320 --> 00:17:00,760
this is we're going to give the verifier

413
00:16:57,610 --> 00:17:03,360
the seed s to a PRF and in our heads

414
00:17:00,760 --> 00:17:05,650
we're gonna think that the bit B

415
00:17:03,360 --> 00:17:07,959
correspondent statement X should be the

416
00:17:05,650 --> 00:17:11,050
PRF evaluated on X that's what we want

417
00:17:07,959 --> 00:17:13,000
we want to implement this somehow so

418
00:17:11,050 --> 00:17:14,859
we're going to give the prover the

419
00:17:13,000 --> 00:17:17,410
master public key to the ABA scheme and

420
00:17:14,859 --> 00:17:19,899
then we're going to again have the

421
00:17:17,410 --> 00:17:22,209
prover send a commitment along with two

422
00:17:19,900 --> 00:17:23,589
cipher texts and the cipher texts are

423
00:17:22,209 --> 00:17:26,170
going to be encrypted under different

424
00:17:23,589 --> 00:17:27,879
attributes so ciphertext 0 will be

425
00:17:26,170 --> 00:17:30,490
encrypted under attribute X comma 0

426
00:17:27,880 --> 00:17:32,710
where X is the statement and ciphertext

427
00:17:30,490 --> 00:17:36,220
1 will be encrypted under attribute X

428
00:17:32,710 --> 00:17:38,590
comma 1 the verifier is going to have an

429
00:17:36,220 --> 00:17:41,470
EBE secret key that allows him to

430
00:17:38,590 --> 00:17:44,260
decrypt and obtain the message if the

431
00:17:41,470 --> 00:17:46,900
attribute pair X comma B respects the

432
00:17:44,260 --> 00:17:48,129
PRF if B is equal to PR f of X then the

433
00:17:46,900 --> 00:17:48,870
verifier is going to be able to decrypt

434
00:17:48,130 --> 00:17:51,720
and

435
00:17:48,870 --> 00:17:54,270
not then he won't be able to decrypt so

436
00:17:51,720 --> 00:17:56,730
that's the basic idea and right off the

437
00:17:54,270 --> 00:17:58,500
bat you can show just assuming that the

438
00:17:56,730 --> 00:18:01,110
AVG scheme is semantically secure

439
00:17:58,500 --> 00:18:03,620
that's this gives you zero knowledge is

440
00:18:01,110 --> 00:18:07,770
enough to give you zero knowledge

441
00:18:03,620 --> 00:18:10,820
soundness is trickier intuitively we

442
00:18:07,770 --> 00:18:13,980
want to say that hey you know each bits

443
00:18:10,820 --> 00:18:16,050
four in the bit for each X is coming

444
00:18:13,980 --> 00:18:18,330
from a PRF it looks it looks random and

445
00:18:16,050 --> 00:18:20,639
independent of the others and so as long

446
00:18:18,330 --> 00:18:24,240
as the prover doesn't query the verifier

447
00:18:20,640 --> 00:18:26,280
on the statement X one could hope that

448
00:18:24,240 --> 00:18:27,390
the PRF security would guarantee you or

449
00:18:26,280 --> 00:18:29,670
the prover doesn't know anything about

450
00:18:27,390 --> 00:18:31,770
that bit B and therefore that sound this

451
00:18:29,670 --> 00:18:33,960
should hold on that statement that's

452
00:18:31,770 --> 00:18:35,970
that's the hope so

453
00:18:33,960 --> 00:18:37,950
this doesn't actually work and in

454
00:18:35,970 --> 00:18:39,540
particular for specific ad schemes you

455
00:18:37,950 --> 00:18:42,809
can write down attacks that break

456
00:18:39,540 --> 00:18:45,450
soundness fundamentally the problem is

457
00:18:42,809 --> 00:18:47,940
that because you have query access to

458
00:18:45,450 --> 00:18:50,429
the verifier this effectively means you

459
00:18:47,940 --> 00:18:53,010
have query access to an AV e decryption

460
00:18:50,429 --> 00:18:55,950
circuit's sorry sorry query access to an

461
00:18:53,010 --> 00:18:58,020
AV decryption Oracle and this and the AV

462
00:18:55,950 --> 00:19:01,500
decryption oracle is using a secret key

463
00:18:58,020 --> 00:19:03,750
that knows what the PRF seed is so in

464
00:19:01,500 --> 00:19:07,200
principle this could leak information

465
00:19:03,750 --> 00:19:10,800
about the PRF seed so this won't happen

466
00:19:07,200 --> 00:19:13,110
if you feed the decryption Oracle or the

467
00:19:10,800 --> 00:19:14,879
verification Oracle well-formed ad

468
00:19:13,110 --> 00:19:17,070
ciphertext because if you give it

469
00:19:14,880 --> 00:19:18,570
well-formed ad cipher texts then the

470
00:19:17,070 --> 00:19:21,149
correctness of a Vedic rip ssin will

471
00:19:18,570 --> 00:19:23,928
tell you that the that's nothing about

472
00:19:21,150 --> 00:19:27,059
the seed is leaked but if you feed it

473
00:19:23,929 --> 00:19:28,620
malformed a de cipher texts it's

474
00:19:27,059 --> 00:19:31,080
actually possible to implement the tax

475
00:19:28,620 --> 00:19:34,199
where you leak the seed of the PRF and

476
00:19:31,080 --> 00:19:35,760
therefore you compromise soundness so

477
00:19:34,200 --> 00:19:36,900
that's the problem

478
00:19:35,760 --> 00:19:38,820
and that's why we don't get a

479
00:19:36,900 --> 00:19:42,540
construction from any old attribute

480
00:19:38,820 --> 00:19:45,120
based encryption but what we then do is

481
00:19:42,540 --> 00:19:48,389
we define a stronger form of security on

482
00:19:45,120 --> 00:19:50,760
the EBE that rules out this attack this

483
00:19:48,390 --> 00:19:53,010
particular attack and then we show that

484
00:19:50,760 --> 00:19:54,300
this form of security is actually enough

485
00:19:53,010 --> 00:19:55,410
to make the soundness analysis go

486
00:19:54,300 --> 00:19:57,240
through that if you have the security

487
00:19:55,410 --> 00:20:01,140
then the protocol I wrote down is

488
00:19:57,240 --> 00:20:03,690
actually sound so intuitively it's it's

489
00:20:01,140 --> 00:20:07,290
effectively what I just said so we have

490
00:20:03,690 --> 00:20:08,790
some security game where you have query

491
00:20:07,290 --> 00:20:10,409
access where an adversary has query

492
00:20:08,790 --> 00:20:13,139
access to a decryption Oracle the

493
00:20:10,410 --> 00:20:15,870
decryption Oracle is using an AV secret

494
00:20:13,140 --> 00:20:17,400
key associated to a function f so you

495
00:20:15,870 --> 00:20:20,489
can ask well what can what can this

496
00:20:17,400 --> 00:20:23,370
adversary learn well if you query on a

497
00:20:20,490 --> 00:20:25,650
ciphertext with attribute X you're

498
00:20:23,370 --> 00:20:27,889
definitely going to learn whether f of X

499
00:20:25,650 --> 00:20:30,929
is equal to 1 or equal to 0 because

500
00:20:27,890 --> 00:20:34,710
because if you get out a valid answer

501
00:20:30,929 --> 00:20:36,270
you know f of X is equal to 1 so the

502
00:20:34,710 --> 00:20:38,130
security property that we asked for is

503
00:20:36,270 --> 00:20:40,530
that effectively this is all that you

504
00:20:38,130 --> 00:20:42,840
learn about the function so we want to

505
00:20:40,530 --> 00:20:45,450
argue or we want we want to assume that

506
00:20:42,840 --> 00:20:47,550
that this entire interaction that I'm

507
00:20:45,450 --> 00:20:49,320
talking about could be simulated just

508
00:20:47,550 --> 00:20:51,960
knowing the input-output behavior of the

509
00:20:49,320 --> 00:20:54,060
function f along with the master secret

510
00:20:51,960 --> 00:20:56,010
key of the ABA scheme so the thing that

511
00:20:54,060 --> 00:20:58,379
we care about not compromising here is

512
00:20:56,010 --> 00:21:00,420
the implementation of the function and

513
00:20:58,380 --> 00:21:03,450
in particular the input-output behavior

514
00:21:00,420 --> 00:21:05,820
of the function on in on on attributes

515
00:21:03,450 --> 00:21:06,870
that you haven't queried that's a that's

516
00:21:05,820 --> 00:21:11,850
the kind of security that we're looking

517
00:21:06,870 --> 00:21:14,010
for so so then we show that if you have

518
00:21:11,850 --> 00:21:15,990
an AV scheme satisfying this form of

519
00:21:14,010 --> 00:21:17,610
security then the soundness analysis

520
00:21:15,990 --> 00:21:19,440
goes through that the function hiding of

521
00:21:17,610 --> 00:21:21,149
the a B II that I just described along

522
00:21:19,440 --> 00:21:23,340
with the PRF security and the soundness

523
00:21:21,150 --> 00:21:25,380
of the 3 message protocol together will

524
00:21:23,340 --> 00:21:26,668
give you soundness of the one message

525
00:21:25,380 --> 00:21:30,990
protocol that I've written down for you

526
00:21:26,669 --> 00:21:34,669
here so that's a that's a simplified

527
00:21:30,990 --> 00:21:37,620
variance of our of our main construction

528
00:21:34,669 --> 00:21:40,530
then as I said before we can implement

529
00:21:37,620 --> 00:21:43,530
this kind of a ve from lwe using a

530
00:21:40,530 --> 00:21:46,350
basically unknown scheme and in addition

531
00:21:43,530 --> 00:21:47,820
we can construct this kind of a ve from

532
00:21:46,350 --> 00:21:50,189
quite generically from public key

533
00:21:47,820 --> 00:21:52,980
encryption and KDM secure secure key

534
00:21:50,190 --> 00:21:55,410
encryption and very briefly the way this

535
00:21:52,980 --> 00:21:57,000
is done is we first construct plain

536
00:21:55,410 --> 00:22:00,570
single key AV from public key encryption

537
00:21:57,000 --> 00:22:02,429
this is old and then we amplify the

538
00:22:00,570 --> 00:22:05,340
security of the a b e

539
00:22:02,429 --> 00:22:07,230
so that's it will satisfy this kind of

540
00:22:05,340 --> 00:22:09,120
function hiding that we care about after

541
00:22:07,230 --> 00:22:13,080
throwing in the Katie and secure secret

542
00:22:09,120 --> 00:22:14,610
key encryption and this is very similar

543
00:22:13,080 --> 00:22:16,199
to the construction of CC

544
00:22:14,610 --> 00:22:17,790
a secure encryption or the two

545
00:22:16,200 --> 00:22:20,220
constructions given by Coppola and

546
00:22:17,790 --> 00:22:25,110
waters and by kids Ogawa macedon Tonica

547
00:22:20,220 --> 00:22:27,179
both in both in this conference so so

548
00:22:25,110 --> 00:22:30,059
that's all I want to say on our results

549
00:22:27,179 --> 00:22:33,840
just to conclude you know our question

550
00:22:30,059 --> 00:22:35,070
was is there a generic framework for

551
00:22:33,840 --> 00:22:36,990
constructing designated verify our

552
00:22:35,070 --> 00:22:39,510
musics and we make progress on this

553
00:22:36,990 --> 00:22:41,370
question by reformulating the problem in

554
00:22:39,510 --> 00:22:44,220
terms of constructing a certain kind of

555
00:22:41,370 --> 00:22:46,260
a tree based encryption in terms of open

556
00:22:44,220 --> 00:22:47,490
questions you know you could ask well

557
00:22:46,260 --> 00:22:49,650
the big question is can we construct

558
00:22:47,490 --> 00:22:50,940
this form of ABC from any public key

559
00:22:49,650 --> 00:22:52,830
encryption that would resolve the big

560
00:22:50,940 --> 00:22:55,679
open problem you might say well look

561
00:22:52,830 --> 00:22:57,149
we're using a CCA like security property

562
00:22:55,679 --> 00:22:59,610
so why why would you why would you

563
00:22:57,150 --> 00:23:01,950
expect this to help but I'm happy to

564
00:22:59,610 --> 00:23:03,479
talk offline on some some thoughts about

565
00:23:01,950 --> 00:23:07,770
why this formulation might still be

566
00:23:03,480 --> 00:23:10,020
useful more modestly you could ask if

567
00:23:07,770 --> 00:23:12,629
you could construct this kind of a VE

568
00:23:10,020 --> 00:23:14,280
from CCA secure public key encryption so

569
00:23:12,630 --> 00:23:16,559
that would be like a converse then our

570
00:23:14,280 --> 00:23:18,870
young theorem saying that CCA security

571
00:23:16,559 --> 00:23:21,750
and doesn't even verify our music are

572
00:23:18,870 --> 00:23:23,879
really the same object and then finally

573
00:23:21,750 --> 00:23:26,669
I want to ask if we can do anything

574
00:23:23,880 --> 00:23:28,500
based on one-way functions so maybe not

575
00:23:26,669 --> 00:23:31,860
constructing a designated verifier music

576
00:23:28,500 --> 00:23:33,809
but some weak form of music satisfying

577
00:23:31,860 --> 00:23:35,040
reusable soundness form only functions I

578
00:23:33,809 --> 00:23:36,809
think that the techniques from this

579
00:23:35,040 --> 00:23:39,360
paper might also be useful for answering

580
00:23:36,809 --> 00:23:40,290
that sort of question that's it thank

581
00:23:39,360 --> 00:23:47,290
you

582
00:23:40,290 --> 00:23:55,129
[Applause]

583
00:23:47,290 --> 00:23:58,610
and questions okay yeah if you have

584
00:23:55,130 --> 00:23:59,990
question you can ask him offline let's

585
00:23:58,610 --> 00:24:00,250
thank the speaker again

586
00:23:59,990 --> 00:24:03,509
[Applause]

587
00:24:00,250 --> 00:24:03,509
[Music]

