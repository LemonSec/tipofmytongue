1
00:00:04,970 --> 00:00:08,960
very much for the introduction and I

2
00:00:07,370 --> 00:00:10,580
actually wanted to begin by thanking the

3
00:00:08,960 --> 00:00:13,160
program committee and the program shows

4
00:00:10,580 --> 00:00:15,260
for the invitation it turns out I

5
00:00:13,160 --> 00:00:16,699
actually did enjoy putting together the

6
00:00:15,260 --> 00:00:18,980
slides and thinking about what I wanted

7
00:00:16,699 --> 00:00:22,240
to say in this talk though initially I

8
00:00:18,980 --> 00:00:24,830
do have to admit that I kind of dreaded

9
00:00:22,240 --> 00:00:26,060
you know giving this talk and I tried to

10
00:00:24,830 --> 00:00:28,459
decline sort of I don't know if you

11
00:00:26,060 --> 00:00:31,400
realize but anyway they didn't let me

12
00:00:28,460 --> 00:00:33,860
and why was I in part dreading this talk

13
00:00:31,400 --> 00:00:35,839
well part of the difficulty is exactly

14
00:00:33,860 --> 00:00:37,280
what Daniella talked about is deciding

15
00:00:35,840 --> 00:00:40,269
what to speak about and the program

16
00:00:37,280 --> 00:00:42,170
chairs gave me no help in that matter

17
00:00:40,269 --> 00:00:43,909
they said yeah whatever you want to

18
00:00:42,170 --> 00:00:46,789
speak about is fine okay great so what's

19
00:00:43,909 --> 00:00:49,339
the first thing I thought about to speak

20
00:00:46,789 --> 00:00:51,979
about is well my my initial thoughts

21
00:00:49,339 --> 00:00:54,979
turn to talking about secure multi-party

22
00:00:51,979 --> 00:00:56,539
computation and that's a really

23
00:00:54,979 --> 00:00:58,339
interesting topic and the problem with

24
00:00:56,539 --> 00:01:01,670
that is that I really didn't want to

25
00:00:58,339 --> 00:01:04,010
bore half the audience usually if I if I

26
00:01:01,670 --> 00:01:07,190
can only bore about 1/3 or 1/4 of the

27
00:01:04,010 --> 00:01:10,100
audience that's what I aim for so what I

28
00:01:07,190 --> 00:01:12,380
what I try to think about is well ok the

29
00:01:10,100 --> 00:01:14,869
idea should be that what I should talk

30
00:01:12,380 --> 00:01:18,320
about is maybe some connections between

31
00:01:14,870 --> 00:01:20,750
the theory of secure computation and

32
00:01:18,320 --> 00:01:22,100
something ok well what should I connect

33
00:01:20,750 --> 00:01:24,290
the theory with well that's kind of the

34
00:01:22,100 --> 00:01:26,149
obvious I should try to connect the

35
00:01:24,290 --> 00:01:28,970
theory of secure computation with all

36
00:01:26,150 --> 00:01:31,130
the recent work going on in on the

37
00:01:28,970 --> 00:01:32,870
practical side of secure computation and

38
00:01:31,130 --> 00:01:35,619
talk about the bridges that are being

39
00:01:32,870 --> 00:01:38,570
built between these two communities and

40
00:01:35,620 --> 00:01:40,100
this is a great topic to talk about

41
00:01:38,570 --> 00:01:41,389
actually in general the intersection or

42
00:01:40,100 --> 00:01:43,580
the interplay between theory and

43
00:01:41,390 --> 00:01:44,990
practice and cryptography is a great

44
00:01:43,580 --> 00:01:47,990
topic to talk about if I do say so

45
00:01:44,990 --> 00:01:50,240
myself and the problem with this is that

46
00:01:47,990 --> 00:01:52,220
many other people have realized this and

47
00:01:50,240 --> 00:01:54,710
many other people have talked about this

48
00:01:52,220 --> 00:01:56,900
before and in particular I went back and

49
00:01:54,710 --> 00:01:58,580
took a look at the previous invited

50
00:01:56,900 --> 00:02:00,260
talks at crypto Europe crypt and Asia

51
00:01:58,580 --> 00:02:03,140
crypt just to get a sense of what people

52
00:02:00,260 --> 00:02:04,640
spoke about and many many people have

53
00:02:03,140 --> 00:02:07,190
spoken about theory and practice in

54
00:02:04,640 --> 00:02:08,568
different guises and I this is my own my

55
00:02:07,190 --> 00:02:09,800
own opinion about whether the talk was

56
00:02:08,568 --> 00:02:13,480
theory and practice some people in the

57
00:02:09,800 --> 00:02:16,670
list may disagree and in particular in

58
00:02:13,480 --> 00:02:18,619
2017 and Nigel smart talked about secure

59
00:02:16,670 --> 00:02:20,359
computation theory and practice ok

60
00:02:18,620 --> 00:02:21,769
well that gives me a little bit of pause

61
00:02:20,360 --> 00:02:25,700
I can come up with something else

62
00:02:21,769 --> 00:02:29,000
so uh yeah and I could just agree with

63
00:02:25,700 --> 00:02:30,319
everything he said and I I don't think

64
00:02:29,000 --> 00:02:31,459
he's here actually which is too bad I

65
00:02:30,319 --> 00:02:34,310
thought he might enjoy this talk but

66
00:02:31,459 --> 00:02:36,379
anyway I could agree with everything he

67
00:02:34,310 --> 00:02:38,599
said and then and in five minutes I will

68
00:02:36,379 --> 00:02:39,739
add a few thoughts of my own but okay I

69
00:02:38,599 --> 00:02:42,530
better come up with something else

70
00:02:39,739 --> 00:02:43,970
so what I decided to talk about instead

71
00:02:42,530 --> 00:02:47,900
actually are some there's some recent

72
00:02:43,970 --> 00:02:49,670
work connecting theory and practice of

73
00:02:47,900 --> 00:02:52,010
secure computation was something that I

74
00:02:49,670 --> 00:02:54,470
hope will be of interest to other people

75
00:02:52,010 --> 00:02:57,470
in the audience namely a symmetric key

76
00:02:54,470 --> 00:02:59,060
crypto and crypt analysis and we'll see

77
00:02:57,470 --> 00:03:00,560
how actually these communities that are

78
00:02:59,060 --> 00:03:03,430
usually thought of as being relatively

79
00:03:00,560 --> 00:03:05,239
far apart and I think unfortunately so

80
00:03:03,430 --> 00:03:08,239
really there there are some nice

81
00:03:05,239 --> 00:03:09,680
connections between the two of them let

82
00:03:08,239 --> 00:03:12,290
me just step back a little bit and spend

83
00:03:09,680 --> 00:03:14,959
maybe five minutes talking about theory

84
00:03:12,290 --> 00:03:17,540
and practice I should start maybe by by

85
00:03:14,959 --> 00:03:18,980
giving my biases right so I started out

86
00:03:17,540 --> 00:03:22,790
well I started out I guess as a chemist

87
00:03:18,980 --> 00:03:25,668
so thanks for reminding everybody my my

88
00:03:22,790 --> 00:03:28,668
but my roots of a PhD a cryptographer

89
00:03:25,669 --> 00:03:30,590
are in the theory community and what I

90
00:03:28,669 --> 00:03:31,660
found I guess over time and maybe many

91
00:03:30,590 --> 00:03:33,950
of us have this feeling is that

92
00:03:31,660 --> 00:03:35,569
gradually over my career I became

93
00:03:33,950 --> 00:03:37,608
jealous of practitioners they seemed to

94
00:03:35,569 --> 00:03:39,108
have a lot of the fun not all the fun

95
00:03:37,609 --> 00:03:41,569
but they seem to have a lot of the fun

96
00:03:39,109 --> 00:03:43,970
and you know the standard kind of joke

97
00:03:41,569 --> 00:03:45,798
right is that practitioners consider me

98
00:03:43,970 --> 00:03:48,980
a theorist and and basically theorists

99
00:03:45,799 --> 00:03:50,540
consider me a sellout and and

100
00:03:48,980 --> 00:03:54,828
unfortunately nobody considers me a

101
00:03:50,540 --> 00:03:56,388
practitioner but that's okay but but

102
00:03:54,829 --> 00:03:57,560
let's actually define terms a little bit

103
00:03:56,389 --> 00:04:00,049
actually me here or bellari gave a

104
00:03:57,560 --> 00:04:02,359
really nice talk here at crypto in 2014

105
00:04:00,049 --> 00:04:04,010
also talking about among other things

106
00:04:02,359 --> 00:04:06,049
theory and practice from his point of

107
00:04:04,010 --> 00:04:08,120
view and he actually had a nice taxonomy

108
00:04:06,049 --> 00:04:10,639
of what exactly it means for something

109
00:04:08,120 --> 00:04:12,919
to be practical and he gave basically

110
00:04:10,639 --> 00:04:14,810
four criteria that you can use perhaps

111
00:04:12,919 --> 00:04:17,030
to evaluate whether some technology was

112
00:04:14,810 --> 00:04:18,829
practical or not and he didn't actually

113
00:04:17,029 --> 00:04:20,358
order them he actually claimed that

114
00:04:18,829 --> 00:04:22,160
there was a connect you know they were

115
00:04:20,358 --> 00:04:24,530
not strictly ordered but but in any

116
00:04:22,160 --> 00:04:26,659
event I put them in this order you can

117
00:04:24,530 --> 00:04:27,799
you can talk about whether something can

118
00:04:26,659 --> 00:04:30,409
be implemented you can talk about

119
00:04:27,800 --> 00:04:32,600
whether that implementation is efficient

120
00:04:30,409 --> 00:04:35,390
and maybe that's the theory

121
00:04:32,600 --> 00:04:36,740
point of view of what practice means you

122
00:04:35,390 --> 00:04:39,349
can also ask what they were given

123
00:04:36,740 --> 00:04:40,970
technology is worth money to somebody

124
00:04:39,350 --> 00:04:43,160
will somebody pay for it will somebody

125
00:04:40,970 --> 00:04:45,560
pay to implement it and of course

126
00:04:43,160 --> 00:04:47,900
whether or not it has utility I would

127
00:04:45,560 --> 00:04:49,850
add to this list a little bit you can

128
00:04:47,900 --> 00:04:52,039
also ask whether things are either

129
00:04:49,850 --> 00:04:53,330
standardized or perhaps in the process

130
00:04:52,040 --> 00:04:55,100
of being standardized or being thought

131
00:04:53,330 --> 00:04:56,810
about as being standardized that is a

132
00:04:55,100 --> 00:04:58,610
useful indication of whether or not

133
00:04:56,810 --> 00:05:00,710
people believe that something has

134
00:04:58,610 --> 00:05:02,180
practical utility and then of course you

135
00:05:00,710 --> 00:05:03,919
can you can also ask whether something

136
00:05:02,180 --> 00:05:05,900
is actually used right it's interesting

137
00:05:03,920 --> 00:05:07,700
because I think there are examples of

138
00:05:05,900 --> 00:05:09,590
things that are used that have no

139
00:05:07,700 --> 00:05:11,690
utility and things that have utility but

140
00:05:09,590 --> 00:05:14,960
or not so it's not the case that they

141
00:05:11,690 --> 00:05:16,460
that they are equivalent and you know if

142
00:05:14,960 --> 00:05:19,489
this were maybe a different kind of talk

143
00:05:16,460 --> 00:05:22,460
I would focus on the fact that nowadays

144
00:05:19,490 --> 00:05:23,960
secure computation is worth money

145
00:05:22,460 --> 00:05:27,049
because you can look at different

146
00:05:23,960 --> 00:05:29,330
companies and and funding agencies who

147
00:05:27,050 --> 00:05:30,860
are investing in this technology and I

148
00:05:29,330 --> 00:05:32,810
would claim that it also has utility and

149
00:05:30,860 --> 00:05:34,520
there are actually examples here of

150
00:05:32,810 --> 00:05:35,930
people using this for various things in

151
00:05:34,520 --> 00:05:38,840
the real world even though it hasn't yet

152
00:05:35,930 --> 00:05:40,130
seen widespread deployment but for the

153
00:05:38,840 --> 00:05:42,739
purposes of this talk I'm going to be

154
00:05:40,130 --> 00:05:46,490
focusing more on implementations and the

155
00:05:42,740 --> 00:05:49,460
efficiency of those implementations as

156
00:05:46,490 --> 00:05:51,770
far as defining theory it turns out it's

157
00:05:49,460 --> 00:05:54,320
actually not quite clear how to define

158
00:05:51,770 --> 00:05:56,030
it you can think perhaps about defining

159
00:05:54,320 --> 00:05:57,320
theory in terms of definitions improves

160
00:05:56,030 --> 00:05:59,510
but I think actually to the theory

161
00:05:57,320 --> 00:06:00,830
communities credit you know their focus

162
00:05:59,510 --> 00:06:02,750
on definitions and proofs might have

163
00:06:00,830 --> 00:06:04,400
been enough to characterize theory in

164
00:06:02,750 --> 00:06:06,910
the 80s and the early 90s but by now

165
00:06:04,400 --> 00:06:09,080
they've really permeated much of crypto

166
00:06:06,910 --> 00:06:10,970
you can talk about reliance on

167
00:06:09,080 --> 00:06:13,099
mathematical techniques but that also

168
00:06:10,970 --> 00:06:14,960
really characterizes most of the work

169
00:06:13,100 --> 00:06:16,370
that cryptographers that everybody in

170
00:06:14,960 --> 00:06:19,400
this room does and so it doesn't really

171
00:06:16,370 --> 00:06:21,590
quite pin down what exactly separates

172
00:06:19,400 --> 00:06:24,650
theory from more practical aspects of

173
00:06:21,590 --> 00:06:28,429
cryptography I found this actually in

174
00:06:24,650 --> 00:06:29,870
the manifesto of TCC I read how do they

175
00:06:28,430 --> 00:06:32,870
define themselves as the theory

176
00:06:29,870 --> 00:06:34,610
community and what they say there among

177
00:06:32,870 --> 00:06:36,790
other things I just told it to these two

178
00:06:34,610 --> 00:06:40,370
is that they focus on the study of

179
00:06:36,790 --> 00:06:43,100
paradigms and techniques and formulating

180
00:06:40,370 --> 00:06:44,780
new problems or ultimately you can take

181
00:06:43,100 --> 00:06:46,160
this as basically working on problems

182
00:06:44,780 --> 00:06:49,280
without caring whether or not there

183
00:06:46,160 --> 00:06:53,330
practical which which is not necessarily

184
00:06:49,280 --> 00:06:56,299
a a negative because what one thing I I

185
00:06:53,330 --> 00:07:00,320
have found is really there's been an

186
00:06:56,300 --> 00:07:03,650
amazing it's it's amazing to me how

187
00:07:00,320 --> 00:07:05,480
actually effective theory has been for

188
00:07:03,650 --> 00:07:09,109
practice really perhaps unreasonably so

189
00:07:05,480 --> 00:07:10,640
and I you know consider myself a cynic

190
00:07:09,110 --> 00:07:12,440
in this regard I you know sometimes I

191
00:07:10,640 --> 00:07:13,820
see working I think oh you know that has

192
00:07:12,440 --> 00:07:15,680
no hope of ever being practical why are

193
00:07:13,820 --> 00:07:17,570
people working on that problem but time

194
00:07:15,680 --> 00:07:19,160
and again I've been proven wrong and I

195
00:07:17,570 --> 00:07:21,590
think secure computation is a great

196
00:07:19,160 --> 00:07:24,110
example of this the early work in the

197
00:07:21,590 --> 00:07:25,969
80s and the 90s building these protocols

198
00:07:24,110 --> 00:07:28,280
showing feasibility results building up

199
00:07:25,970 --> 00:07:30,830
definitions and foundations and now we

200
00:07:28,280 --> 00:07:32,059
see this transitioning into practice but

201
00:07:30,830 --> 00:07:34,460
there are many other examples actually

202
00:07:32,060 --> 00:07:35,720
and I'll just list a couple and I know

203
00:07:34,460 --> 00:07:36,979
and I'll mention the first one in

204
00:07:35,720 --> 00:07:38,860
particular the first one I think it's a

205
00:07:36,980 --> 00:07:41,720
fantastic example right you have these

206
00:07:38,860 --> 00:07:42,860
verifiable random functions also known

207
00:07:41,720 --> 00:07:45,590
as unique signatures that were

208
00:07:42,860 --> 00:07:47,180
introduced in 1999 you know it's a

209
00:07:45,590 --> 00:07:49,010
wonderful idea but it doesn't seem to

210
00:07:47,180 --> 00:07:52,100
have any you know potential practical

211
00:07:49,010 --> 00:07:54,830
use and now you see what is it 20 years

212
00:07:52,100 --> 00:07:56,960
later roughly you see that these are a

213
00:07:54,830 --> 00:07:58,460
fundamental building block for proof of

214
00:07:56,960 --> 00:07:59,989
stake blockchain protocols it's really

215
00:07:58,460 --> 00:08:01,460
unbelievable right I mean who would have

216
00:07:59,990 --> 00:08:05,030
thought that you would come around and

217
00:08:01,460 --> 00:08:06,620
have this kind of an application but I

218
00:08:05,030 --> 00:08:08,059
want to also highlight the other side

219
00:08:06,620 --> 00:08:10,750
which I think many of us in the theory

220
00:08:08,060 --> 00:08:14,930
community often disregard is that the

221
00:08:10,750 --> 00:08:17,480
practice or the deployment or the usage

222
00:08:14,930 --> 00:08:19,070
of different technologies can also be

223
00:08:17,480 --> 00:08:21,470
interesting from a theoretical point of

224
00:08:19,070 --> 00:08:24,680
view because it can raise all sorts of

225
00:08:21,470 --> 00:08:26,360
interesting theoretical questions and in

226
00:08:24,680 --> 00:08:29,360
this talk in particular I'm gonna focus

227
00:08:26,360 --> 00:08:31,940
on two questions that arose from looking

228
00:08:29,360 --> 00:08:33,890
more carefully at implementations and

229
00:08:31,940 --> 00:08:37,039
and deployments I guess of a secure

230
00:08:33,890 --> 00:08:39,650
computation looking first of all at how

231
00:08:37,039 --> 00:08:41,479
hash functions can be are implemented or

232
00:08:39,650 --> 00:08:42,799
how they're instantiated in existing MPC

233
00:08:41,479 --> 00:08:45,830
implementations and how they should be

234
00:08:42,799 --> 00:08:47,959
instantiated in implementations and also

235
00:08:45,830 --> 00:08:49,520
looking at the concrete security of

236
00:08:47,960 --> 00:08:51,470
secure computation and that actually

237
00:08:49,520 --> 00:08:53,150
connects to the first bullet because

238
00:08:51,470 --> 00:08:54,470
that turns out to be dependent on how

239
00:08:53,150 --> 00:08:57,620
exactly the hash functions are

240
00:08:54,470 --> 00:08:59,510
instantiated and both of these results

241
00:08:57,620 --> 00:09:01,790
that I'm going to talk about

242
00:08:59,510 --> 00:09:03,200
really rely on insights from the

243
00:09:01,790 --> 00:09:04,339
symmetric-key world and this is the

244
00:09:03,200 --> 00:09:06,800
connection to symmetric key cryptography

245
00:09:04,340 --> 00:09:09,050
that I talked about a couple of slides

246
00:09:06,800 --> 00:09:11,209
ago and and you know I felt it

247
00:09:09,050 --> 00:09:14,120
particularly apropos here to include a

248
00:09:11,210 --> 00:09:15,530
quote from Nigel from his talk here he

249
00:09:14,120 --> 00:09:17,030
said it as part of his talk that you

250
00:09:15,530 --> 00:09:18,140
should always pay attention to all talks

251
00:09:17,030 --> 00:09:20,240
and I think this is great advice

252
00:09:18,140 --> 00:09:21,920
actually right it's a because you never

253
00:09:20,240 --> 00:09:24,170
know when the next idea or where the

254
00:09:21,920 --> 00:09:26,449
next idea will come from if you stay

255
00:09:24,170 --> 00:09:27,770
isolated and only attend one kind of

256
00:09:26,450 --> 00:09:29,030
talk you're missing out on ideas from

257
00:09:27,770 --> 00:09:30,770
other from other people other

258
00:09:29,030 --> 00:09:32,180
communities that can potentially be

259
00:09:30,770 --> 00:09:36,430
beneficial to you so I think it's useful

260
00:09:32,180 --> 00:09:38,810
a good advice so I wanted to give a

261
00:09:36,430 --> 00:09:40,430
little bit of NPC background I don't

262
00:09:38,810 --> 00:09:43,400
know actually well I don't expect that

263
00:09:40,430 --> 00:09:44,930
most of the audience are experts in

264
00:09:43,400 --> 00:09:46,280
secure computation and I wanted to give

265
00:09:44,930 --> 00:09:47,359
kind of enough information the first

266
00:09:46,280 --> 00:09:48,680
tool you would get something out of the

267
00:09:47,360 --> 00:09:51,890
talk and second of all you'll be able to

268
00:09:48,680 --> 00:09:54,620
follow the second half of the talk so

269
00:09:51,890 --> 00:09:57,020
I'm going to talk about secure two-party

270
00:09:54,620 --> 00:09:59,930
computation in particular it's just

271
00:09:57,020 --> 00:10:02,210
cleaner and it's a it's much easier to

272
00:09:59,930 --> 00:10:04,069
explain for one thing and it'll in it

273
00:10:02,210 --> 00:10:05,620
and it kind of is enough to describe all

274
00:10:04,070 --> 00:10:07,880
the results I'm going to tell you about

275
00:10:05,620 --> 00:10:10,400
so in the setting of secure two-party

276
00:10:07,880 --> 00:10:13,430
computation we have two parties with

277
00:10:10,400 --> 00:10:16,699
inputs X and y and they want to jointly

278
00:10:13,430 --> 00:10:18,109
compute some function f of their of

279
00:10:16,700 --> 00:10:20,660
their mutual inputs they want to compute

280
00:10:18,110 --> 00:10:22,220
the result F X Y and they would like to

281
00:10:20,660 --> 00:10:23,660
do this while maintaining various

282
00:10:22,220 --> 00:10:26,930
security properties right the one we

283
00:10:23,660 --> 00:10:27,890
think about the most is privacy right

284
00:10:26,930 --> 00:10:29,689
that they should be able to get the

285
00:10:27,890 --> 00:10:31,280
result F X Y without either side

286
00:10:29,690 --> 00:10:33,260
revealing their input to the other side

287
00:10:31,280 --> 00:10:35,000
and also they may be concerned about

288
00:10:33,260 --> 00:10:37,280
other properties for example correctness

289
00:10:35,000 --> 00:10:39,380
ie knowing that the result they compute

290
00:10:37,280 --> 00:10:42,439
corresponds to some valid input of each

291
00:10:39,380 --> 00:10:44,360
of the parties you can consider both the

292
00:10:42,440 --> 00:10:46,280
semi honest setting and the malicious

293
00:10:44,360 --> 00:10:47,780
setting in the semi honest setting the

294
00:10:46,280 --> 00:10:49,730
idea is that both parties are running

295
00:10:47,780 --> 00:10:52,180
the protocol as prescribed and they're

296
00:10:49,730 --> 00:10:54,470
only potentially trying to learn

297
00:10:52,180 --> 00:10:56,630
disallowed information from the protocol

298
00:10:54,470 --> 00:10:58,310
execution and in the malicious setting

299
00:10:56,630 --> 00:10:59,510
the parties can behave or the or the

300
00:10:58,310 --> 00:11:02,209
corrupted party rather can behave

301
00:10:59,510 --> 00:11:03,920
arbitrarily and I'm going to focus most

302
00:11:02,210 --> 00:11:07,190
of the time in this talk on the on the

303
00:11:03,920 --> 00:11:10,310
semi honest setting it turns out that

304
00:11:07,190 --> 00:11:12,350
that semi honest two-party computation I

305
00:11:10,310 --> 00:11:13,599
think is at this point relatively simple

306
00:11:12,350 --> 00:11:15,970
to describe

307
00:11:13,600 --> 00:11:17,470
I've described this in and like an hour

308
00:11:15,970 --> 00:11:19,630
well something like this in an hour-long

309
00:11:17,470 --> 00:11:20,800
talk to undergraduates I can you know

310
00:11:19,630 --> 00:11:22,959
claim to know how much they understood

311
00:11:20,800 --> 00:11:25,240
but but I think you can it's nice yeah

312
00:11:22,959 --> 00:11:28,859
encapsulated now

313
00:11:25,240 --> 00:11:32,639
it relies essentially on two primitives

314
00:11:28,860 --> 00:11:34,600
oblivious transfer and circuit garbling

315
00:11:32,639 --> 00:11:37,029
and by the way those are both also

316
00:11:34,600 --> 00:11:38,470
wonderful examples of theory impacting

317
00:11:37,029 --> 00:11:39,970
practice many years later right when

318
00:11:38,470 --> 00:11:43,360
when oblivious transfer was introduced

319
00:11:39,970 --> 00:11:44,740
in 1981 I don't think Robin had had the

320
00:11:43,360 --> 00:11:48,000
idea in his mind perhaps that it would

321
00:11:44,740 --> 00:11:51,519
develop to the point where it did today

322
00:11:48,000 --> 00:11:53,949
so oblivious transfer is in the fight

323
00:11:51,519 --> 00:11:56,019
and the version I'll talk about here has

324
00:11:53,949 --> 00:11:57,459
a sender and receiver the sender has two

325
00:11:56,019 --> 00:12:00,610
inputs let's think of them as strings

326
00:11:57,459 --> 00:12:03,239
here X 0 and X 1 the receiver on the

327
00:12:00,610 --> 00:12:07,240
right hand side has a selector bit B and

328
00:12:03,240 --> 00:12:08,709
we can define what we want by defining

329
00:12:07,240 --> 00:12:10,089
what we would want in an ideal world

330
00:12:08,709 --> 00:12:12,758
where the parties had a trusted

331
00:12:10,089 --> 00:12:14,649
incorruptible third party to rely on I

332
00:12:12,759 --> 00:12:15,790
have to say whenever I give a talk like

333
00:12:14,649 --> 00:12:17,560
this that it becomes harder and harder

334
00:12:15,790 --> 00:12:19,870
to find something that people might view

335
00:12:17,560 --> 00:12:24,369
was an incorruptible trusted party but

336
00:12:19,870 --> 00:12:25,959
let's take the IAC R as an example so

337
00:12:24,370 --> 00:12:27,250
what's the what's the ideal

338
00:12:25,959 --> 00:12:28,930
functionality going to do it's going to

339
00:12:27,250 --> 00:12:30,699
accept the inputs from both parties it's

340
00:12:28,930 --> 00:12:32,199
going to accept X 0 and X 1 from the

341
00:12:30,699 --> 00:12:34,959
sender and the bit B from the receiver

342
00:12:32,199 --> 00:12:37,420
and then it will return only the string

343
00:12:34,959 --> 00:12:38,709
selected right the string X sub B to the

344
00:12:37,420 --> 00:12:40,479
receiver and so the receiver learns

345
00:12:38,709 --> 00:12:42,010
nothing about the other string and the

346
00:12:40,480 --> 00:12:44,889
sender learns nothing about the selector

347
00:12:42,010 --> 00:12:45,910
bit of the receiver great circuit

348
00:12:44,889 --> 00:12:48,579
garbling is a little bit more

349
00:12:45,910 --> 00:12:52,360
complicated this was introduced by Yau

350
00:12:48,579 --> 00:12:53,920
in 1986 the idea here is that we there's

351
00:12:52,360 --> 00:12:57,819
gonna be one party that's so called a

352
00:12:53,920 --> 00:13:00,430
circuit gar blur who for every gate in

353
00:12:57,819 --> 00:13:02,949
some circuit and for every wire going in

354
00:13:00,430 --> 00:13:06,219
and out of that gate will choose two

355
00:13:02,949 --> 00:13:08,079
strings to label each wire so here I've

356
00:13:06,220 --> 00:13:10,240
just shown a 0 a 1 on the top wire and

357
00:13:08,079 --> 00:13:13,508
then B 0 B 1 and then C 0 C 1 on the

358
00:13:10,240 --> 00:13:15,310
output wire and the those strings will

359
00:13:13,509 --> 00:13:17,259
correspond to each of the possible

360
00:13:15,310 --> 00:13:19,449
underlying bits on that wire so say a 0

361
00:13:17,259 --> 00:13:22,510
corresponds to the bit 0 on that

362
00:13:19,449 --> 00:13:24,339
particular wire and then what you want

363
00:13:22,510 --> 00:13:25,899
to ensure and you can then hook these up

364
00:13:24,339 --> 00:13:27,370
right you can connect that output wire

365
00:13:25,899 --> 00:13:29,410
to another gate and continue this

366
00:13:27,370 --> 00:13:30,970
as long as you like and if you just want

367
00:13:29,410 --> 00:13:32,140
to ensure correctness you want to ensure

368
00:13:30,970 --> 00:13:35,080
that somebody can now use this to

369
00:13:32,140 --> 00:13:36,460
evaluate the circuit what you what you

370
00:13:35,080 --> 00:13:38,620
need to do is you need to first of all

371
00:13:36,460 --> 00:13:41,650
ensure that the evaluator the other

372
00:13:38,620 --> 00:13:43,870
party is going to learn one label on

373
00:13:41,650 --> 00:13:45,339
each input wire of the circuit okay so

374
00:13:43,870 --> 00:13:46,839
they're going to learn either say a zero

375
00:13:45,339 --> 00:13:49,839
or a one if that's an input wire of the

376
00:13:46,839 --> 00:13:51,970
circuit and then you need to ensure that

377
00:13:49,839 --> 00:13:54,010
you can maintain the following invariant

378
00:13:51,970 --> 00:13:57,460
that every time you're at a gate at a

379
00:13:54,010 --> 00:13:59,140
garbled gate and you have one label on

380
00:13:57,460 --> 00:14:02,020
each of the two input wires to that gate

381
00:13:59,140 --> 00:14:05,040
say a sub R and B sub s you can somehow

382
00:14:02,020 --> 00:14:07,180
or another compute the string

383
00:14:05,040 --> 00:14:08,709
corresponding to the correct bit on the

384
00:14:07,180 --> 00:14:09,819
output wire so in this case we're

385
00:14:08,710 --> 00:14:11,320
talking about a NAND gate

386
00:14:09,820 --> 00:14:15,100
you should be able to compute from a R

387
00:14:11,320 --> 00:14:18,520
and B s the string C of the bit R and s

388
00:14:15,100 --> 00:14:20,290
and if you can do that then you can go

389
00:14:18,520 --> 00:14:22,930
from the input wires down to the output

390
00:14:20,290 --> 00:14:25,029
wires you can gradually learn every one

391
00:14:22,930 --> 00:14:26,949
one label one string on every wire all

392
00:14:25,029 --> 00:14:28,600
the way till the output wire and then

393
00:14:26,950 --> 00:14:30,550
magar blur can also provide some kind of

394
00:14:28,600 --> 00:14:32,440
a translation table telling you which

395
00:14:30,550 --> 00:14:35,140
actual bit the strings on the output

396
00:14:32,440 --> 00:14:37,570
wires correspond to from the point of

397
00:14:35,140 --> 00:14:40,360
security what we need to do is we need

398
00:14:37,570 --> 00:14:43,029
to ensure first of all that when the

399
00:14:40,360 --> 00:14:45,070
evaluator learns a label on some wire it

400
00:14:43,029 --> 00:14:47,110
shouldn't reveal what the underlying bit

401
00:14:45,070 --> 00:14:50,110
on that wire is right so if the if the

402
00:14:47,110 --> 00:14:52,180
if the a wire for example corresponds to

403
00:14:50,110 --> 00:14:54,490
an input of the garb ler then when the

404
00:14:52,180 --> 00:14:55,810
garb ler gives a zero to the evaluator

405
00:14:54,490 --> 00:14:57,430
the evaluator shouldn't learn that that

406
00:14:55,810 --> 00:14:58,900
corresponds to the zero bit otherwise it

407
00:14:57,430 --> 00:15:00,430
would leak the bit of their input and

408
00:14:58,900 --> 00:15:01,959
you also need to ensure that the

409
00:15:00,430 --> 00:15:04,510
evaluator will only ever be able to

410
00:15:01,959 --> 00:15:06,819
learn one label or one string per wire

411
00:15:04,510 --> 00:15:08,800
because if it can learn both then it can

412
00:15:06,820 --> 00:15:11,910
actually from that deduce potentially

413
00:15:08,800 --> 00:15:14,500
what bit each string corresponds to and

414
00:15:11,910 --> 00:15:15,730
this sounds perhaps very complicated but

415
00:15:14,500 --> 00:15:19,270
it turns out to be very easy to

416
00:15:15,730 --> 00:15:21,400
implement at least in some naive way you

417
00:15:19,270 --> 00:15:25,089
can simply have this idea of a garbled

418
00:15:21,400 --> 00:15:27,819
table corresponding to every gate where

419
00:15:25,089 --> 00:15:30,400
you simply include encryptions of the

420
00:15:27,820 --> 00:15:32,020
appropriate output wire under keys

421
00:15:30,400 --> 00:15:34,120
corresponding to the appropriate input

422
00:15:32,020 --> 00:15:35,680
wires so for example let's look here you

423
00:15:34,120 --> 00:15:37,780
see that there's only one encryption of

424
00:15:35,680 --> 00:15:39,370
the string c1 and that's going to

425
00:15:37,780 --> 00:15:40,780
correspond to something that can be

426
00:15:39,370 --> 00:15:44,110
decrypted only if the

427
00:15:40,780 --> 00:15:45,880
valuator has the strings corresponding

428
00:15:44,110 --> 00:15:47,980
to the one inputs on both of the input

429
00:15:45,880 --> 00:15:50,110
wires rights only if they have a1 and b1

430
00:15:47,980 --> 00:15:54,670
do they recover c1 in any other case

431
00:15:50,110 --> 00:15:56,380
they're going to recover c0 great and we

432
00:15:54,670 --> 00:15:59,439
can now couple these together and build

433
00:15:56,380 --> 00:16:01,960
a semi honest to PC protocol so let's

434
00:15:59,440 --> 00:16:03,190
consider the case where X and y bits for

435
00:16:01,960 --> 00:16:05,440
simplicity

436
00:16:03,190 --> 00:16:08,140
what p1 will do is it will garble that

437
00:16:05,440 --> 00:16:10,780
gate it will then send that garble gate

438
00:16:08,140 --> 00:16:12,910
over to the other side and now it has to

439
00:16:10,780 --> 00:16:14,439
ensure that the other side p2 is going

440
00:16:12,910 --> 00:16:17,410
to learn exactly one string on each

441
00:16:14,440 --> 00:16:18,850
input wire so if a corresponds to P ones

442
00:16:17,410 --> 00:16:20,650
input then what it will do is it will

443
00:16:18,850 --> 00:16:24,400
simply send the string corresponding to

444
00:16:20,650 --> 00:16:26,380
its input bit X so it will send a X and

445
00:16:24,400 --> 00:16:27,760
now it has to also make sure that p2 can

446
00:16:26,380 --> 00:16:31,120
learn the string on the B wire

447
00:16:27,760 --> 00:16:32,350
corresponding to p2 xinput well what can

448
00:16:31,120 --> 00:16:34,960
they use to do that they can use

449
00:16:32,350 --> 00:16:38,080
oblivious transfer right p2 can use the

450
00:16:34,960 --> 00:16:40,090
selector bit why the strings that p1

451
00:16:38,080 --> 00:16:43,180
will input are exactly the strings b0

452
00:16:40,090 --> 00:16:46,060
and b1 p2 will learn only the string B

453
00:16:43,180 --> 00:16:47,770
sub y and then it can go ahead and from

454
00:16:46,060 --> 00:16:50,290
that and from the garbled gate compute

455
00:16:47,770 --> 00:16:52,480
the string corresponding to x and y

456
00:16:50,290 --> 00:16:55,420
which they can then decode and recover

457
00:16:52,480 --> 00:17:00,400
the actual output bit x and y okay so

458
00:16:55,420 --> 00:17:01,900
quite simple and clean now let's look a

459
00:17:00,400 --> 00:17:03,939
little bit at some interplay here

460
00:17:01,900 --> 00:17:05,020
between theory and practice in

461
00:17:03,940 --> 00:17:07,720
particularly through the lens of

462
00:17:05,020 --> 00:17:09,790
symmetric key cryptography and the main

463
00:17:07,720 --> 00:17:13,030
takeaway point of this part of the talk

464
00:17:09,790 --> 00:17:16,389
is that as secure computation moves from

465
00:17:13,030 --> 00:17:18,970
theory to practice there's a real need

466
00:17:16,390 --> 00:17:20,980
to understand the real world security

467
00:17:18,970 --> 00:17:22,839
not just of abstract protocols as

468
00:17:20,980 --> 00:17:25,360
written in a paper but of the actual

469
00:17:22,839 --> 00:17:27,730
implementations themselves and in

470
00:17:25,359 --> 00:17:29,050
particular this is not really a surprise

471
00:17:27,730 --> 00:17:30,280
to anybody perhaps who's ever

472
00:17:29,050 --> 00:17:32,110
implemented anything or looked at

473
00:17:30,280 --> 00:17:35,320
implementations is that there's very

474
00:17:32,110 --> 00:17:37,270
often a gap between protocols and theory

475
00:17:35,320 --> 00:17:40,000
or protocols as written in a paper or as

476
00:17:37,270 --> 00:17:41,650
not written in the paper and in practice

477
00:17:40,000 --> 00:17:43,990
right so for example they're very very

478
00:17:41,650 --> 00:17:46,120
often lots of low-level details that are

479
00:17:43,990 --> 00:17:47,440
emitted sometimes because they're

480
00:17:46,120 --> 00:17:48,820
assumed to be folklore or they're

481
00:17:47,440 --> 00:17:49,840
assumed to be obvious but then you sit

482
00:17:48,820 --> 00:17:51,370
down and somebody's going to implement

483
00:17:49,840 --> 00:17:53,590
it and they may miss out on those subtle

484
00:17:51,370 --> 00:17:54,639
points there are often implementation

485
00:17:53,590 --> 00:17:56,020
level details that are

486
00:17:54,640 --> 00:17:58,600
specified that are left up to the

487
00:17:56,020 --> 00:18:01,060
programmer there are various performance

488
00:17:58,600 --> 00:18:03,969
optimizations that people may employ

489
00:18:01,060 --> 00:18:05,320
during the implementation phase and what

490
00:18:03,970 --> 00:18:07,210
you get in the end is that you

491
00:18:05,320 --> 00:18:08,770
implemented something that was close to

492
00:18:07,210 --> 00:18:10,870
the protocol as specified in the paper

493
00:18:08,770 --> 00:18:12,400
and the protocol on the paper may even

494
00:18:10,870 --> 00:18:14,830
have been proven secure under some

495
00:18:12,400 --> 00:18:16,900
assumptions but you're missing now an

496
00:18:14,830 --> 00:18:20,679
end-to-end security proof for the

497
00:18:16,900 --> 00:18:23,290
protocol as implemented and if we're

498
00:18:20,680 --> 00:18:26,110
going to move toward greater deployment

499
00:18:23,290 --> 00:18:27,810
of secure computation or towards

500
00:18:26,110 --> 00:18:30,429
standardization of secure computation

501
00:18:27,810 --> 00:18:34,929
it's going to be critical to address

502
00:18:30,430 --> 00:18:37,270
this gap if you look at efficient

503
00:18:34,930 --> 00:18:39,520
implementations of semi honest secure

504
00:18:37,270 --> 00:18:41,770
two-party computation the efficiency

505
00:18:39,520 --> 00:18:43,360
improvements over the last you know you

506
00:18:41,770 --> 00:18:45,400
can you can count since the hour you can

507
00:18:43,360 --> 00:18:47,110
look at the last 10 years they've been

508
00:18:45,400 --> 00:18:49,630
driven by improvements in the underlying

509
00:18:47,110 --> 00:18:52,780
building blocks the particular ones I

510
00:18:49,630 --> 00:18:54,730
want to highlight are OT extension I'll

511
00:18:52,780 --> 00:18:57,370
talk about it more in a few in a few

512
00:18:54,730 --> 00:18:59,200
slides and also improve garbling schemes

513
00:18:57,370 --> 00:19:00,669
there are many different optimizations

514
00:18:59,200 --> 00:19:04,870
that people have come up with for the

515
00:19:00,670 --> 00:19:06,730
garbling step and all of these protocols

516
00:19:04,870 --> 00:19:08,110
all these improvements both the OT

517
00:19:06,730 --> 00:19:11,200
extension and the various improvements

518
00:19:08,110 --> 00:19:13,300
to garbling schemes all ultimately rely

519
00:19:11,200 --> 00:19:14,620
on some hash function h this is

520
00:19:13,300 --> 00:19:18,370
basically how they're written in the

521
00:19:14,620 --> 00:19:20,110
paper and sometimes the protocol is

522
00:19:18,370 --> 00:19:21,669
proven secure based on certain

523
00:19:20,110 --> 00:19:23,770
assumptions about the hash function

524
00:19:21,670 --> 00:19:25,690
other times the protocol may be proven

525
00:19:23,770 --> 00:19:29,170
secure when the hash function H is

526
00:19:25,690 --> 00:19:31,750
modeled as a random Oracle but the

527
00:19:29,170 --> 00:19:33,670
question remains perhaps well that's

528
00:19:31,750 --> 00:19:35,080
good but how doesn't should we implement

529
00:19:33,670 --> 00:19:36,100
the protocol and when we and in

530
00:19:35,080 --> 00:19:38,080
particular when we implement the

531
00:19:36,100 --> 00:19:40,659
protocol how should we instantiate this

532
00:19:38,080 --> 00:19:42,250
hash function H and when we choose to

533
00:19:40,660 --> 00:19:44,110
instantiate that hash function in a

534
00:19:42,250 --> 00:19:47,550
particular way is that implementation

535
00:19:44,110 --> 00:19:49,719
secure and then you can ask also well

536
00:19:47,550 --> 00:19:51,220
even if that's secure or there may be

537
00:19:49,720 --> 00:19:54,250
better ways that you can go about doing

538
00:19:51,220 --> 00:19:55,780
that and of course these kind of

539
00:19:54,250 --> 00:19:57,010
questions are not specific to secure

540
00:19:55,780 --> 00:20:00,430
computation the difficulties of

541
00:19:57,010 --> 00:20:02,500
instantiating a random Oracle are kind

542
00:20:00,430 --> 00:20:04,540
of well-known I don't think they've

543
00:20:02,500 --> 00:20:08,070
really been looked at extensively in the

544
00:20:04,540 --> 00:20:08,070
context of secure computation before

545
00:20:08,420 --> 00:20:11,800
now many of you may be sitting there

546
00:20:09,710 --> 00:20:14,540
thinking well what's the problem right

547
00:20:11,800 --> 00:20:15,710
so the natural thing to say is well look

548
00:20:14,540 --> 00:20:17,030
we know how to instantiate a hash

549
00:20:15,710 --> 00:20:19,640
function we'll just we're just going to

550
00:20:17,030 --> 00:20:20,870
use shot okay so first of all you have

551
00:20:19,640 --> 00:20:22,460
to be a little bit careful right I mean

552
00:20:20,870 --> 00:20:23,989
shot two is not in differentiable from a

553
00:20:22,460 --> 00:20:26,750
random Oracle you can patch it so that

554
00:20:23,990 --> 00:20:28,460
it is that's fine that that's great the

555
00:20:26,750 --> 00:20:31,010
real problem is that there's a

556
00:20:28,460 --> 00:20:33,530
preference for using something other

557
00:20:31,010 --> 00:20:35,740
than sha in these most efficient

558
00:20:33,530 --> 00:20:37,790
protocol implementations and

559
00:20:35,740 --> 00:20:41,240
specifically there's a preference for

560
00:20:37,790 --> 00:20:43,850
using a fixed key AES this is actually

561
00:20:41,240 --> 00:20:47,630
inspired by some work by bellari at all

562
00:20:43,850 --> 00:20:48,770
in 2013 who showed basically that you

563
00:20:47,630 --> 00:20:50,690
can in the context of garbling

564
00:20:48,770 --> 00:20:53,150
specifically that you can get tremendous

565
00:20:50,690 --> 00:20:54,560
efficiency improvements by relying on

566
00:20:53,150 --> 00:20:57,290
fixed key a AES rather than a

567
00:20:54,560 --> 00:20:58,940
cryptographic hash function like sha and

568
00:20:57,290 --> 00:21:01,070
the reasons for that are first of all

569
00:20:58,940 --> 00:21:04,280
you can exploit a hardware support for

570
00:21:01,070 --> 00:21:06,320
AES you can also avoid the cost of key

571
00:21:04,280 --> 00:21:07,730
scheduling if you fix the key right so

572
00:21:06,320 --> 00:21:09,560
if you I'll talk about this more in the

573
00:21:07,730 --> 00:21:11,690
next slide but basically if you're not

574
00:21:09,560 --> 00:21:14,270
rekeying the rekeying operation in a yes

575
00:21:11,690 --> 00:21:17,990
as a significant overhead to the total

576
00:21:14,270 --> 00:21:19,670
computational cost and if you look at

577
00:21:17,990 --> 00:21:20,990
the numbers you see that the hash

578
00:21:19,670 --> 00:21:22,310
functions if you just were going to use

579
00:21:20,990 --> 00:21:24,800
an off-the-shelf cryptographic hash

580
00:21:22,310 --> 00:21:27,409
function like shot or sha-3 they're

581
00:21:24,800 --> 00:21:30,310
basically 15 to 50 times slower than

582
00:21:27,410 --> 00:21:32,540
using fixed key a yes so yes you can use

583
00:21:30,310 --> 00:21:36,320
sha but then you're going to be paying a

584
00:21:32,540 --> 00:21:38,240
significant performance penalty it's a

585
00:21:36,320 --> 00:21:39,980
good point for a digression about fixed

586
00:21:38,240 --> 00:21:42,470
key a es and the random permutation

587
00:21:39,980 --> 00:21:44,300
model which I'll be talking about so if

588
00:21:42,470 --> 00:21:46,520
we fix some key K and for now I don't

589
00:21:44,300 --> 00:21:48,379
really care how the key is chosen we can

590
00:21:46,520 --> 00:21:50,810
consider the fixed permutation that I'll

591
00:21:48,380 --> 00:21:53,180
call Pi which is just the AES block

592
00:21:50,810 --> 00:21:55,340
cipher with that key hard-coded right

593
00:21:53,180 --> 00:21:59,990
this is now giving us a fixed

594
00:21:55,340 --> 00:22:01,879
permutation on 128-bit strings and what

595
00:21:59,990 --> 00:22:04,040
is sometimes done and what we're gonna

596
00:22:01,880 --> 00:22:06,890
do in this talk is to model that

597
00:22:04,040 --> 00:22:08,120
permutation PI as a random permutation

598
00:22:06,890 --> 00:22:10,610
and we're going to work in the so called

599
00:22:08,120 --> 00:22:12,199
random permutation model which is really

600
00:22:10,610 --> 00:22:13,760
completely analogous to the random

601
00:22:12,200 --> 00:22:15,110
Oracle model really the difference is

602
00:22:13,760 --> 00:22:17,090
that in the random Oracle model you're

603
00:22:15,110 --> 00:22:18,199
given access to a random function here

604
00:22:17,090 --> 00:22:20,209
you're going to be given access to a

605
00:22:18,200 --> 00:22:21,980
random permutation as well as the

606
00:22:20,210 --> 00:22:23,720
inverse of that permutation so

607
00:22:21,980 --> 00:22:25,730
course anybody who has the key K can

608
00:22:23,720 --> 00:22:27,290
compute a es inverse so we have to allow

609
00:22:25,730 --> 00:22:31,580
the attacker to compute the inverse as

610
00:22:27,290 --> 00:22:33,620
well and even though this may seem maybe

611
00:22:31,580 --> 00:22:35,299
it is even a strong assumption I'll just

612
00:22:33,620 --> 00:22:38,330
point out that it's weaker than modeling

613
00:22:35,299 --> 00:22:40,070
AES is a deal cipher there may be other

614
00:22:38,330 --> 00:22:41,840
reasons to believe that AES may not act

615
00:22:40,070 --> 00:22:43,760
as an ideal cipher but modeling block

616
00:22:41,840 --> 00:22:45,620
ciphers in general as ideal ciphers is

617
00:22:43,760 --> 00:22:47,000
also a common approach that people take

618
00:22:45,620 --> 00:22:51,709
when trying to prove security of

619
00:22:47,000 --> 00:22:53,059
constructions based on block ciphers so

620
00:22:51,710 --> 00:22:55,820
coming back to the problem of

621
00:22:53,059 --> 00:22:56,990
instantiating hash functions many people

622
00:22:55,820 --> 00:22:58,490
in the audience may say well you know

623
00:22:56,990 --> 00:22:59,780
what we still don't have a problem

624
00:22:58,490 --> 00:23:01,460
because what we can do is simply

625
00:22:59,780 --> 00:23:03,200
construct a random Oracle from a random

626
00:23:01,460 --> 00:23:04,960
permutation right and that gives us our

627
00:23:03,200 --> 00:23:07,760
way to instantiate the hash function H

628
00:23:04,960 --> 00:23:10,400
and it is true that there are some

629
00:23:07,760 --> 00:23:12,590
constructions of a random Oracle from a

630
00:23:10,400 --> 00:23:15,380
random permutation we discussed them in

631
00:23:12,590 --> 00:23:18,139
the paper the short answer is that they

632
00:23:15,380 --> 00:23:20,030
have drawbacks inefficiency or concrete

633
00:23:18,140 --> 00:23:22,520
security or have difficulty handling

634
00:23:20,030 --> 00:23:25,070
long inputs and I would say actually

635
00:23:22,520 --> 00:23:27,530
it's a good open question to come up

636
00:23:25,070 --> 00:23:28,879
with a suitable way to instantiate a

637
00:23:27,530 --> 00:23:30,379
random Oracle from a random permutation

638
00:23:28,880 --> 00:23:33,110
where suitable here just means for the

639
00:23:30,380 --> 00:23:34,730
context of of the specific applications

640
00:23:33,110 --> 00:23:38,719
to secure computation that I'm focusing

641
00:23:34,730 --> 00:23:40,340
on so in this talk right I'm going to

642
00:23:38,720 --> 00:23:41,900
talk like I said about how to hash how

643
00:23:40,340 --> 00:23:44,059
to instantiate these hash functions and

644
00:23:41,900 --> 00:23:45,919
implementations I'll just mention

645
00:23:44,059 --> 00:23:47,540
briefly about some empirical study of

646
00:23:45,919 --> 00:23:49,910
existing implementations and then talk

647
00:23:47,540 --> 00:23:52,549
about instantiating hash functions

648
00:23:49,910 --> 00:23:55,100
securely in this talk I'll focus on the

649
00:23:52,549 --> 00:23:56,690
particular case of ot extension in the

650
00:23:55,100 --> 00:23:59,240
paper we talked about garbling and some

651
00:23:56,690 --> 00:24:00,650
other applications and mailing me to

652
00:23:59,240 --> 00:24:03,020
talk about instantiating a hash function

653
00:24:00,650 --> 00:24:05,090
while ensuring good concrete security

654
00:24:03,020 --> 00:24:09,080
here I'm going to focus on the case of

655
00:24:05,090 --> 00:24:13,389
garbling and both of these are based on

656
00:24:09,080 --> 00:24:15,949
joint work with Chango shell Wang and uu

657
00:24:13,390 --> 00:24:20,630
combining expertise from symmetric key

658
00:24:15,950 --> 00:24:22,340
world on the in the protocol world okay

659
00:24:20,630 --> 00:24:23,990
so let me talk first about secure

660
00:24:22,340 --> 00:24:29,899
hashing from fixed key a AES in the

661
00:24:23,990 --> 00:24:31,820
context of oblivious transfer so so I

662
00:24:29,900 --> 00:24:33,470
talked I mentioned that the extension

663
00:24:31,820 --> 00:24:35,720
before I didn't explain what it was oh

664
00:24:33,470 --> 00:24:37,940
gee extension is basically a

665
00:24:35,720 --> 00:24:39,890
a powerful technique for converting a

666
00:24:37,940 --> 00:24:44,299
small number of what are called base

667
00:24:39,890 --> 00:24:46,370
ot's so think about say 128 beso T's and

668
00:24:44,299 --> 00:24:48,110
then taking those and converting them

669
00:24:46,370 --> 00:24:51,770
into essentially an unlimited number of

670
00:24:48,110 --> 00:24:54,039
o T's and this is fantastic because it

671
00:24:51,770 --> 00:24:56,389
turns out that the beso T's that you

672
00:24:54,039 --> 00:24:59,210
implement require public key

673
00:24:56,390 --> 00:25:02,270
cryptography but the additional low T's

674
00:24:59,210 --> 00:25:04,100
that you can then obtain from those beso

675
00:25:02,270 --> 00:25:06,830
T's rely on symmetric key cryptography

676
00:25:04,100 --> 00:25:08,689
only so this essentially means that if

677
00:25:06,830 --> 00:25:11,889
you want to do a million oblivious

678
00:25:08,690 --> 00:25:15,470
transfers you're paying the cost of 128

679
00:25:11,890 --> 00:25:17,230
public key beso T's and then all the

680
00:25:15,470 --> 00:25:19,549
remaining o TS are going to only be

681
00:25:17,230 --> 00:25:21,169
relying on symmetric key operations it

682
00:25:19,549 --> 00:25:25,129
has a huge performance impact in

683
00:25:21,169 --> 00:25:27,559
practice and the existing paradigm for

684
00:25:25,130 --> 00:25:28,580
efficient OD extension works a little

685
00:25:27,559 --> 00:25:31,100
bit differently from what I've been

686
00:25:28,580 --> 00:25:32,928
describing essentially what it does is

687
00:25:31,100 --> 00:25:35,030
it relies on a protocol for what I'll

688
00:25:32,929 --> 00:25:37,130
call random OT and I'll show exactly

689
00:25:35,030 --> 00:25:38,570
what that is on the next slide and then

690
00:25:37,130 --> 00:25:40,520
you basically take what you get from the

691
00:25:38,570 --> 00:25:43,189
random OTE and you bootstrap that in

692
00:25:40,520 --> 00:25:46,100
some way to obtain the the one out of

693
00:25:43,190 --> 00:25:48,140
two OT that you actually want so let me

694
00:25:46,100 --> 00:25:50,539
show what that looks like so here we

695
00:25:48,140 --> 00:25:52,340
have a party on the left a sender but

696
00:25:50,539 --> 00:25:54,379
they now have actually multiple pairs of

697
00:25:52,340 --> 00:25:57,080
inputs and the party on the right has

698
00:25:54,380 --> 00:25:59,510
multiple selection bits think of them as

699
00:25:57,080 --> 00:26:01,309
a vector if you like they're going to

700
00:25:59,510 --> 00:26:03,879
rely on this random OT functionality

701
00:26:01,309 --> 00:26:07,549
that I talked about there are some

702
00:26:03,880 --> 00:26:09,350
details here that I'm lighting but

703
00:26:07,549 --> 00:26:11,650
essentially the idea is that the

704
00:26:09,350 --> 00:26:14,240
receiver will input its selection bits

705
00:26:11,650 --> 00:26:15,980
and then what will happen is that the

706
00:26:14,240 --> 00:26:17,870
random OT functionality is going to pick

707
00:26:15,980 --> 00:26:20,330
a bunch of random values that satisfy

708
00:26:17,870 --> 00:26:22,879
certain constraints and in particular

709
00:26:20,330 --> 00:26:26,030
what it will do is it'll choose a random

710
00:26:22,880 --> 00:26:30,140
shift Delta and a bunch of random

711
00:26:26,030 --> 00:26:33,678
strings X I and give those to the to the

712
00:26:30,140 --> 00:26:37,909
sender and the receiver will obtain as

713
00:26:33,679 --> 00:26:41,720
its values Y I the random strings X I X

714
00:26:37,909 --> 00:26:43,010
sword with be I times Delta okay so

715
00:26:41,720 --> 00:26:45,110
either the shift is applied or not

716
00:26:43,010 --> 00:26:49,730
depending on whether bi is equal to 0 or

717
00:26:45,110 --> 00:26:51,590
1 and now of course the

718
00:26:49,730 --> 00:26:53,630
wants to transmit one of his actual

719
00:26:51,590 --> 00:26:56,090
strings so what it will do is it will

720
00:26:53,630 --> 00:26:57,680
compute these masked values that I

721
00:26:56,090 --> 00:27:00,500
called M Prime isube

722
00:26:57,680 --> 00:27:03,680
that are computed by masking its actual

723
00:27:00,500 --> 00:27:07,820
strings MIB with the result of

724
00:27:03,680 --> 00:27:10,220
evaluating a hash function on X I X Ord

725
00:27:07,820 --> 00:27:13,340
with B Delta for both values of B okay

726
00:27:10,220 --> 00:27:15,200
so the the sender has Delta the sender

727
00:27:13,340 --> 00:27:16,970
has X I it can it can compute both

728
00:27:15,200 --> 00:27:19,670
options you know both with and without

729
00:27:16,970 --> 00:27:22,550
the shift use that as a mask and then

730
00:27:19,670 --> 00:27:25,640
send the masked values over to the other

731
00:27:22,550 --> 00:27:28,990
party that party can then strip off

732
00:27:25,640 --> 00:27:31,010
exactly one mask per pair and recover

733
00:27:28,990 --> 00:27:32,480
exactly one of this one of the two

734
00:27:31,010 --> 00:27:35,780
strings for every one of these pairs

735
00:27:32,480 --> 00:27:37,790
here and the important thing to focus on

736
00:27:35,780 --> 00:27:40,070
here is the masking that's being applied

737
00:27:37,790 --> 00:27:42,620
which as I said as a result of computing

738
00:27:40,070 --> 00:27:44,510
a hash on these various values here

739
00:27:42,620 --> 00:27:49,280
twice times L values if there are L

740
00:27:44,510 --> 00:27:51,830
pairs here so you can prove that this

741
00:27:49,280 --> 00:27:54,230
protocol is secure even for malicious

742
00:27:51,830 --> 00:27:56,629
attackers if H is modeled as a random

743
00:27:54,230 --> 00:27:58,100
Oracle and I'll just mention since it'll

744
00:27:56,630 --> 00:27:59,780
come up later that if you're only

745
00:27:58,100 --> 00:28:02,389
concerned about semi honest attackers

746
00:27:59,780 --> 00:28:04,100
then it you can actually omit the the

747
00:28:02,390 --> 00:28:06,350
second argument here the the I that I

748
00:28:04,100 --> 00:28:08,840
had and you can simply send or use that

749
00:28:06,350 --> 00:28:10,550
as a mask but as I said before this

750
00:28:08,840 --> 00:28:17,209
leaves open the question of how exactly

751
00:28:10,550 --> 00:28:19,629
H should be implemented and when we went

752
00:28:17,210 --> 00:28:23,810
to look at existing implementations of

753
00:28:19,630 --> 00:28:26,180
the so T extension protocol we observed

754
00:28:23,810 --> 00:28:28,730
that in many of the current libraries

755
00:28:26,180 --> 00:28:30,950
the hash function H is as I said before

756
00:28:28,730 --> 00:28:34,670
actually implemented using fixed key a

757
00:28:30,950 --> 00:28:39,380
yes so how do people choose to implement

758
00:28:34,670 --> 00:28:41,510
it well basically they made it up as I

759
00:28:39,380 --> 00:28:43,550
went along I guess what one can say you

760
00:28:41,510 --> 00:28:46,820
see different types of implementations

761
00:28:43,550 --> 00:28:48,020
different types of of choices here this

762
00:28:46,820 --> 00:28:49,730
actually just shows what kind of

763
00:28:48,020 --> 00:28:52,760
security the implementation was

764
00:28:49,730 --> 00:28:54,320
targeting and the problem in the end

765
00:28:52,760 --> 00:28:56,270
with all of this is that it turns out

766
00:28:54,320 --> 00:28:58,460
these are all insecure at least insecure

767
00:28:56,270 --> 00:29:01,400
as realizations of the OT extension

768
00:28:58,460 --> 00:29:03,350
functionality let me actually give a a

769
00:29:01,400 --> 00:29:07,160
simple example

770
00:29:03,350 --> 00:29:09,379
so consider the case where you implement

771
00:29:07,160 --> 00:29:11,600
you instantiate H of X maybe maybe I

772
00:29:09,380 --> 00:29:14,390
should have left out the I here H of X

773
00:29:11,600 --> 00:29:15,770
equals PI of X in the semi on a setting

774
00:29:14,390 --> 00:29:18,830
if H were a random Oracle that would be

775
00:29:15,770 --> 00:29:21,080
fine and assume for example that the

776
00:29:18,830 --> 00:29:23,929
receiver happens to know two of the

777
00:29:21,080 --> 00:29:25,520
messages in one particular index so it

778
00:29:23,930 --> 00:29:27,800
knows m 1 0 and M 1 1

779
00:29:25,520 --> 00:29:31,070
well then from the two masked messages

780
00:29:27,800 --> 00:29:36,350
the receiver can actually compute PI of

781
00:29:31,070 --> 00:29:38,540
a 1 and PI of a 1 X or Delta and since

782
00:29:36,350 --> 00:29:41,330
pi is invertible this allows recovery of

783
00:29:38,540 --> 00:29:42,820
Delta ok and once it recovers Delta it

784
00:29:41,330 --> 00:29:45,620
can then learn everything

785
00:29:42,820 --> 00:29:47,810
now that's an attack on the OT protocol

786
00:29:45,620 --> 00:29:49,639
it turns out that in some cases not all

787
00:29:47,810 --> 00:29:52,879
cases but in some cases you can actually

788
00:29:49,640 --> 00:29:58,130
extend that to an attack on the full on

789
00:29:52,880 --> 00:29:59,210
the full 2pc protocol so we thought

790
00:29:58,130 --> 00:30:00,800
about you know what would be a

791
00:29:59,210 --> 00:30:02,390
principled way forward well what we can

792
00:30:00,800 --> 00:30:05,149
do is we can try to define security

793
00:30:02,390 --> 00:30:07,280
properties for this hash function H that

794
00:30:05,150 --> 00:30:08,690
would say be weaker than asking for in

795
00:30:07,280 --> 00:30:11,720
differentiability from a random Oracle

796
00:30:08,690 --> 00:30:13,610
in particular we focus here on the

797
00:30:11,720 --> 00:30:15,260
security property that we call tweakable

798
00:30:13,610 --> 00:30:18,679
correlation robustness that I'll define

799
00:30:15,260 --> 00:30:21,050
on another slide and then prove that the

800
00:30:18,680 --> 00:30:22,730
OT extension protocol is secure when H

801
00:30:21,050 --> 00:30:24,470
satisfies those properties you don't

802
00:30:22,730 --> 00:30:26,630
actually require H to be a random Oracle

803
00:30:24,470 --> 00:30:29,270
it's enough for it to satisfy this more

804
00:30:26,630 --> 00:30:31,040
limited set of properties and then show

805
00:30:29,270 --> 00:30:33,560
how to provably realize those properties

806
00:30:31,040 --> 00:30:37,820
from a fixed key cipher you know modeled

807
00:30:33,560 --> 00:30:39,649
as a random permutation PI so the notion

808
00:30:37,820 --> 00:30:41,510
of correlation robustness was actually

809
00:30:39,650 --> 00:30:44,000
introduced in the context of the

810
00:30:41,510 --> 00:30:45,650
original OT extension protocol or our

811
00:30:44,000 --> 00:30:47,450
definition is not exactly equivalent to

812
00:30:45,650 --> 00:30:50,300
theirs but it's certainly inspired by it

813
00:30:47,450 --> 00:30:52,460
and without giving the the you no longer

814
00:30:50,300 --> 00:30:54,320
formal definition I'll just say that a

815
00:30:52,460 --> 00:30:57,950
hash function H we defined to be

816
00:30:54,320 --> 00:30:59,510
correlation robust if the keyed function

817
00:30:57,950 --> 00:31:01,640
defined in this way is a pseudo-random

818
00:30:59,510 --> 00:31:03,170
function so basically what you're doing

819
00:31:01,640 --> 00:31:06,710
is you're just using the key as a shift

820
00:31:03,170 --> 00:31:08,200
on the input and then we define this

821
00:31:06,710 --> 00:31:10,390
stronger notion of a tweakable

822
00:31:08,200 --> 00:31:12,740
correlation robust hash function

823
00:31:10,390 --> 00:31:14,960
inspired by tweakable block ciphers in

824
00:31:12,740 --> 00:31:17,159
that line of work if you just allow the

825
00:31:14,960 --> 00:31:20,669
secondary input this tweak we

826
00:31:17,159 --> 00:31:21,690
is not masked at all and we still

827
00:31:20,669 --> 00:31:25,379
require that F be a pseudo-random

828
00:31:21,690 --> 00:31:26,970
function in that case and it's not too

829
00:31:25,379 --> 00:31:30,299
hard to show that the OT extension

830
00:31:26,970 --> 00:31:32,279
protocol on the previous slide remains

831
00:31:30,299 --> 00:31:34,408
secure in the Semyon is betting if H is

832
00:31:32,279 --> 00:31:36,239
correlation robust and is secure in the

833
00:31:34,409 --> 00:31:40,409
militia setting if your hash function is

834
00:31:36,239 --> 00:31:42,869
tweakable correlation robust so how can

835
00:31:40,409 --> 00:31:45,809
you then construct a correlation robust

836
00:31:42,869 --> 00:31:48,449
hash function so it turns out that we

837
00:31:45,809 --> 00:31:50,609
can come up with this construction I've

838
00:31:48,450 --> 00:31:52,619
called it here MMO prime because it

839
00:31:50,609 --> 00:31:55,080
looks very similar for people who are

840
00:31:52,619 --> 00:31:56,609
familiar with the matías mayoress 'is a

841
00:31:55,080 --> 00:31:58,529
construction of a hash function from a

842
00:31:56,609 --> 00:32:00,570
block cipher this is very similar to

843
00:31:58,529 --> 00:32:02,399
what they do I'll just point out that

844
00:32:00,570 --> 00:32:03,450
it's not equivalent because in that case

845
00:32:02,399 --> 00:32:05,428
they're actually trying to get

846
00:32:03,450 --> 00:32:07,109
compression here we're not looking for

847
00:32:05,429 --> 00:32:09,720
compression so we just have a single

848
00:32:07,109 --> 00:32:11,460
input X coming in and a single input

849
00:32:09,720 --> 00:32:15,779
going out there's no compression going

850
00:32:11,460 --> 00:32:18,389
on here for the case of the tweakable

851
00:32:15,779 --> 00:32:20,039
correlation robust it's actually more

852
00:32:18,389 --> 00:32:21,869
difficult and the difficulty really

853
00:32:20,039 --> 00:32:24,840
comes in in terms of where to where to

854
00:32:21,869 --> 00:32:26,459
fit in this tweak and this is you know

855
00:32:24,840 --> 00:32:28,168
part of the challenge here is what I

856
00:32:26,460 --> 00:32:29,460
mentioned earlier that like I said

857
00:32:28,169 --> 00:32:31,320
there's known work on constructing

858
00:32:29,460 --> 00:32:34,859
things that are in differentiable from a

859
00:32:31,320 --> 00:32:37,439
random Oracle from from a random

860
00:32:34,859 --> 00:32:39,720
permutation but they will will not

861
00:32:37,440 --> 00:32:42,599
always be able to handle an input that's

862
00:32:39,720 --> 00:32:43,830
of length twice the block size but this

863
00:32:42,599 --> 00:32:48,330
construction here that we call a

864
00:32:43,830 --> 00:32:52,499
tweakable MMO T MMO is the construction

865
00:32:48,330 --> 00:32:54,539
we have and what we're able to show is

866
00:32:52,499 --> 00:32:57,599
that if you model this permutation pie

867
00:32:54,539 --> 00:32:59,669
as a random permutation then the MMO

868
00:32:57,599 --> 00:33:03,299
prime construction of the hash function

869
00:32:59,669 --> 00:33:06,149
is correlation robust and T MMO is

870
00:33:03,299 --> 00:33:08,279
tweakable correlation robust both of

871
00:33:06,149 --> 00:33:10,349
these rely on the H coefficient

872
00:33:08,279 --> 00:33:12,389
technique I mentioned that because it's

873
00:33:10,349 --> 00:33:14,279
another really beautiful technique that

874
00:33:12,389 --> 00:33:16,408
arose from the symmetric key world that

875
00:33:14,279 --> 00:33:17,669
I don't know if people perhaps who don't

876
00:33:16,409 --> 00:33:20,340
work in that field are familiar with

877
00:33:17,669 --> 00:33:24,779
it's really quite beautiful and should

878
00:33:20,340 --> 00:33:27,779
be perhaps more widely known and so

879
00:33:24,779 --> 00:33:30,450
overall we obtain an OT extension

880
00:33:27,779 --> 00:33:30,809
protocol or ot extension protocols one

881
00:33:30,450 --> 00:33:32,970
in the

882
00:33:30,809 --> 00:33:36,240
setting one in the militia setting that

883
00:33:32,970 --> 00:33:38,460
have end-to-end security proofs based on

884
00:33:36,240 --> 00:33:41,309
fixed key AES modeled as a random

885
00:33:38,460 --> 00:33:43,259
permutation and what I'm showing here is

886
00:33:41,309 --> 00:33:45,029
just the efficiency of the resulting

887
00:33:43,259 --> 00:33:46,620
construction so I mentioned in

888
00:33:45,029 --> 00:33:48,779
particular at the beginning that if you

889
00:33:46,620 --> 00:33:52,049
wanted to you could implement the hash

890
00:33:48,779 --> 00:33:55,080
function in those protocols with with

891
00:33:52,049 --> 00:33:56,220
sha sha 3 or sha 256 but if you do that

892
00:33:55,080 --> 00:34:00,889
you're going to pay a significant

893
00:33:56,220 --> 00:34:03,960
performance penalty this shows what the

894
00:34:00,889 --> 00:34:06,178
the performance essentially of AES with

895
00:34:03,960 --> 00:34:07,619
and without key scheduling those are

896
00:34:06,179 --> 00:34:09,149
shaded because those actually would not

897
00:34:07,619 --> 00:34:11,520
give you a secure instantiation of the

898
00:34:09,149 --> 00:34:13,828
hash function but you can see here that

899
00:34:11,520 --> 00:34:17,009
our resulting constructions the MMO

900
00:34:13,829 --> 00:34:18,960
Prime and the TM mo are you know in the

901
00:34:17,010 --> 00:34:20,460
case of MMO prime essentially paying the

902
00:34:18,960 --> 00:34:23,790
cost of a single fixed key AES

903
00:34:20,460 --> 00:34:26,040
evaluation in the case of T MMO we're

904
00:34:23,790 --> 00:34:27,810
paying to cut two calls to the

905
00:34:26,040 --> 00:34:29,879
permutation essentially which is why

906
00:34:27,810 --> 00:34:34,739
it's essentially twice of what you pay

907
00:34:29,879 --> 00:34:36,719
for fixed key AES so what I wanted to

908
00:34:34,739 --> 00:34:39,270
look at next was some work on the

909
00:34:36,719 --> 00:34:42,359
concrete security of the circuit

910
00:34:39,270 --> 00:34:44,369
garbling this is kind of well known

911
00:34:42,359 --> 00:34:45,750
right we have two two notions of

912
00:34:44,369 --> 00:34:48,240
security that we often look at in

913
00:34:45,750 --> 00:34:50,280
cryptography asymptotic security and

914
00:34:48,239 --> 00:34:52,649
concrete security where asymptotic

915
00:34:50,280 --> 00:34:54,419
security in a nutshell basically claims

916
00:34:52,649 --> 00:34:56,399
that something is secure if no

917
00:34:54,418 --> 00:34:58,109
polynomial time attacker can break the

918
00:34:56,399 --> 00:35:00,150
scheme with better than negligible

919
00:34:58,109 --> 00:35:01,619
probability whereas in the case of

920
00:35:00,150 --> 00:35:04,200
concrete security what we're interested

921
00:35:01,619 --> 00:35:06,810
in is explicitly bounding the success

922
00:35:04,200 --> 00:35:07,890
probability of an adversary in terms of

923
00:35:06,810 --> 00:35:09,869
the resources that they have available

924
00:35:07,890 --> 00:35:11,368
and in particular in terms of the

925
00:35:09,869 --> 00:35:15,960
complexity of the attack or the running

926
00:35:11,369 --> 00:35:17,760
time for example and surprisingly I

927
00:35:15,960 --> 00:35:19,619
would say there's been little focus on

928
00:35:17,760 --> 00:35:22,260
concrete security in the context of

929
00:35:19,619 --> 00:35:23,339
secure communication it doesn't mean

930
00:35:22,260 --> 00:35:25,079
that there's no focus there are

931
00:35:23,339 --> 00:35:27,089
certainly papers that will give a

932
00:35:25,079 --> 00:35:29,069
concrete security bound but it hasn't

933
00:35:27,089 --> 00:35:31,500
received the amount of attention I would

934
00:35:29,069 --> 00:35:36,420
say as concrete security in the context

935
00:35:31,500 --> 00:35:38,490
of signature schemes for example and I

936
00:35:36,420 --> 00:35:40,319
wanted to look at concrete security in

937
00:35:38,490 --> 00:35:42,779
particular in the context of some of the

938
00:35:40,319 --> 00:35:44,440
more recent and more highly optimized

939
00:35:42,780 --> 00:35:46,000
circuit gargling schemes

940
00:35:44,440 --> 00:35:48,039
and so for that I need to introduce

941
00:35:46,000 --> 00:35:50,650
actually two of the optimizations that

942
00:35:48,039 --> 00:35:52,510
are now commonly used so I talked

943
00:35:50,650 --> 00:35:56,200
earlier about a very simple garbling

944
00:35:52,510 --> 00:35:57,730
technique where you associate I didn't

945
00:35:56,200 --> 00:36:00,118
say it at the time but I was perhaps

946
00:35:57,730 --> 00:36:04,390
thinking in terms of letting a 0 and a 1

947
00:36:00,119 --> 00:36:05,650
B be independent random strings and then

948
00:36:04,390 --> 00:36:07,569
you compute the garbled table in this

949
00:36:05,650 --> 00:36:10,180
way it ends up having four cipher texts

950
00:36:07,569 --> 00:36:13,450
and doing potentially eight encryptions

951
00:36:10,180 --> 00:36:15,220
if you do this naively and the free XOR

952
00:36:13,450 --> 00:36:16,750
and the half gates optimization or two

953
00:36:15,220 --> 00:36:20,558
different ways people have come up with

954
00:36:16,750 --> 00:36:22,150
in order to improve the communication

955
00:36:20,559 --> 00:36:24,849
complexity and also computational

956
00:36:22,150 --> 00:36:28,480
complexity of circuit garbling so the

957
00:36:24,849 --> 00:36:31,690
free XOR technique is actually simple to

958
00:36:28,480 --> 00:36:34,480
describe the basic idea is rather than

959
00:36:31,690 --> 00:36:37,089
choosing the two strings associated with

960
00:36:34,480 --> 00:36:39,280
any given wire independently at random

961
00:36:37,089 --> 00:36:41,650
we're going to maintain them or we're

962
00:36:39,280 --> 00:36:45,190
gonna have them be correlated through a

963
00:36:41,650 --> 00:36:46,839
global random shift R so you see here

964
00:36:45,190 --> 00:36:49,869
that we are going to choose the garbha

965
00:36:46,839 --> 00:36:52,150
we'll choose a random string for each

966
00:36:49,869 --> 00:36:54,849
wire that'll represents a the zero wire

967
00:36:52,150 --> 00:36:56,950
and then the one wire on every or the

968
00:36:54,849 --> 00:36:59,789
one label on every wire will just be the

969
00:36:56,950 --> 00:37:02,980
zero label shifted by the same shift R

970
00:36:59,789 --> 00:37:04,869
and this is useful because then as the

971
00:37:02,980 --> 00:37:07,510
name suggests it allows you actually to

972
00:37:04,869 --> 00:37:09,609
support XOR gates in your circuit

973
00:37:07,510 --> 00:37:11,200
without paying any computational cost at

974
00:37:09,609 --> 00:37:12,819
all so essentially they become free and

975
00:37:11,200 --> 00:37:17,770
the only cost in your circuit is

976
00:37:12,819 --> 00:37:23,339
handling and gates and or gates the

977
00:37:17,770 --> 00:37:25,630
second optimization is a very clever

978
00:37:23,339 --> 00:37:28,869
optimization that allows you to reduce

979
00:37:25,630 --> 00:37:30,849
the communication complexity of a

980
00:37:28,869 --> 00:37:33,339
garbled table so as I said here on the

981
00:37:30,849 --> 00:37:35,529
Left we have essentially four different

982
00:37:33,339 --> 00:37:37,359
cipher texts so if you're if your labels

983
00:37:35,529 --> 00:37:41,470
are Kappa bits long you're paying

984
00:37:37,359 --> 00:37:43,869
roughly essentially four Kappa here the

985
00:37:41,470 --> 00:37:46,149
half gates protocol replaces that with

986
00:37:43,869 --> 00:37:47,829
only what I'll call two cipher texts and

987
00:37:46,150 --> 00:37:49,270
I'm not going to go through the details

988
00:37:47,829 --> 00:37:52,150
of how it works or prove correctness

989
00:37:49,270 --> 00:37:53,440
it's quite quite involved what I wanted

990
00:37:52,150 --> 00:37:55,000
to just highlight here is something

991
00:37:53,440 --> 00:37:56,500
we're gonna focus in on the next slide

992
00:37:55,000 --> 00:37:58,330
is that one of the values that's being

993
00:37:56,500 --> 00:38:01,480
sent is this value that here

994
00:37:58,330 --> 00:38:03,220
called t1 ok and I claim again without

995
00:38:01,480 --> 00:38:04,990
going through the details that this will

996
00:38:03,220 --> 00:38:07,060
preserve the property I talked about

997
00:38:04,990 --> 00:38:09,279
earlier namely that if the evaluator has

998
00:38:07,060 --> 00:38:11,049
one of the two labels on each of the

999
00:38:09,280 --> 00:38:12,430
input wires of a gate they can then

1000
00:38:11,050 --> 00:38:15,160
successfully compute the corresponding

1001
00:38:12,430 --> 00:38:16,270
output wire on that gate and moreover

1002
00:38:15,160 --> 00:38:18,730
what's nice about the half gates

1003
00:38:16,270 --> 00:38:21,700
protocol is that it's compatible with

1004
00:38:18,730 --> 00:38:23,530
the free xor optimization and i've

1005
00:38:21,700 --> 00:38:25,299
indicated that here actually that you

1006
00:38:23,530 --> 00:38:28,150
have the label a1 for example is

1007
00:38:25,300 --> 00:38:33,640
actually still a 0 XOR with our as it is

1008
00:38:28,150 --> 00:38:35,620
in the free xor optimization and it's

1009
00:38:33,640 --> 00:38:39,549
natural to ask well what's the concrete

1010
00:38:35,620 --> 00:38:42,370
security of garbling in this way or is

1011
00:38:39,550 --> 00:38:43,810
essentially a uniform k bit value may

1012
00:38:42,370 --> 00:38:46,029
actually be K minus 1 bits but we can

1013
00:38:43,810 --> 00:38:48,490
ignore that for now you want to actually

1014
00:38:46,030 --> 00:38:50,770
make Kappa as small as possible

1015
00:38:48,490 --> 00:38:53,560
because the communication complexity is

1016
00:38:50,770 --> 00:38:55,240
going to be exactly twice Kappa ok so if

1017
00:38:53,560 --> 00:38:56,950
you're satisfied with say 80 bit

1018
00:38:55,240 --> 00:38:59,140
security you prefer to say Kappa equal

1019
00:38:56,950 --> 00:39:02,080
80 and then send only 160 bits per

1020
00:38:59,140 --> 00:39:03,850
garbled gate and you can show actually

1021
00:39:02,080 --> 00:39:07,360
that if you model the hash function H

1022
00:39:03,850 --> 00:39:08,920
that you use to compute the those two

1023
00:39:07,360 --> 00:39:12,460
cipher texts in the new garbling scheme

1024
00:39:08,920 --> 00:39:15,400
that this actually is Kappa gives you

1025
00:39:12,460 --> 00:39:19,000
gives you Kappa bit security and many

1026
00:39:15,400 --> 00:39:22,150
papers and implementations set Kappa

1027
00:39:19,000 --> 00:39:23,830
equals 80 this is maybe targeting one of

1028
00:39:22,150 --> 00:39:24,880
the NIST recommended security levels and

1029
00:39:23,830 --> 00:39:26,860
obviously people are trying to make

1030
00:39:24,880 --> 00:39:28,840
their there the results in their paper

1031
00:39:26,860 --> 00:39:30,580
look as good as possible so they choose

1032
00:39:28,840 --> 00:39:35,050
Kappa to be the smallest reasonable

1033
00:39:30,580 --> 00:39:37,900
value which is 80 and we can again ask

1034
00:39:35,050 --> 00:39:39,250
well those results are fine if we're

1035
00:39:37,900 --> 00:39:41,830
willing to model H as a random Oracle

1036
00:39:39,250 --> 00:39:44,020
and use something like sha but if you

1037
00:39:41,830 --> 00:39:47,020
look in fact that how H is implemented

1038
00:39:44,020 --> 00:39:52,770
it's again typically based on six key

1039
00:39:47,020 --> 00:39:52,770
AES and one common choice is this

1040
00:39:52,980 --> 00:39:59,680
essentially computing H of X I as mm oh

1041
00:39:57,160 --> 00:40:01,930
I guess it should be mm o prime of 2 X

1042
00:39:59,680 --> 00:40:03,339
XOR I and there's two here made like odd

1043
00:40:01,930 --> 00:40:05,259
maybe we'll come back to that later and

1044
00:40:03,340 --> 00:40:07,900
say why people did that but this is a

1045
00:40:05,260 --> 00:40:09,400
one popular choice and if you look at

1046
00:40:07,900 --> 00:40:10,930
this you can see that clearly it's no

1047
00:40:09,400 --> 00:40:12,130
longer in differentiable from a random

1048
00:40:10,930 --> 00:40:15,269
Oracle

1049
00:40:12,130 --> 00:40:18,279
so essentially this leaves a gap between

1050
00:40:15,269 --> 00:40:19,629
what we're able to prove and and what's

1051
00:40:18,279 --> 00:40:20,920
prove you know what was proved for the

1052
00:40:19,630 --> 00:40:23,229
implementation and what's proved in the

1053
00:40:20,920 --> 00:40:24,549
paper and in particular leaves open what

1054
00:40:23,229 --> 00:40:28,569
the concrete security of this choice

1055
00:40:24,549 --> 00:40:31,299
might be and it turns out that when H is

1056
00:40:28,569 --> 00:40:33,579
implemented in this way there's an

1057
00:40:31,299 --> 00:40:36,219
attack that has complexly to to the

1058
00:40:33,579 --> 00:40:38,259
Kappa / C where C is the number of gates

1059
00:40:36,219 --> 00:40:39,880
that your garbling so what that means is

1060
00:40:38,259 --> 00:40:43,229
that if your garbling 1 billion gates

1061
00:40:39,880 --> 00:40:45,670
which is now a popular number to target

1062
00:40:43,229 --> 00:40:46,029
based on a paper oven of five six years

1063
00:40:45,670 --> 00:40:48,579
ago

1064
00:40:46,029 --> 00:40:50,890
if you gobble 1 billion gates with kappa

1065
00:40:48,579 --> 00:40:54,249
equals 80 then you can break the scheme

1066
00:40:50,890 --> 00:40:57,129
in essentially time two to the fifty and

1067
00:40:54,249 --> 00:41:00,279
the attack is really bad because when

1068
00:40:57,130 --> 00:41:02,199
you implement the attack successfully it

1069
00:41:00,279 --> 00:41:04,479
allows the attacker to recover our and

1070
00:41:02,199 --> 00:41:04,989
once you recover our you can reveal

1071
00:41:04,479 --> 00:41:07,058
everything

1072
00:41:04,989 --> 00:41:10,809
so you basically learn the the you learn

1073
00:41:07,059 --> 00:41:13,209
you learn all the inputs and the attack

1074
00:41:10,809 --> 00:41:15,549
also extends to the multi instance or

1075
00:41:13,209 --> 00:41:18,399
multi-user setting where either the same

1076
00:41:15,549 --> 00:41:19,479
user is garbling many different times or

1077
00:41:18,400 --> 00:41:21,009
you have different users who are

1078
00:41:19,479 --> 00:41:22,419
garbling in the attack who succeeds if

1079
00:41:21,009 --> 00:41:23,949
they're able to attack any one of them

1080
00:41:22,420 --> 00:41:25,930
this is something also that's gotten a

1081
00:41:23,949 --> 00:41:27,519
lot of attention recently in the context

1082
00:41:25,930 --> 00:41:29,799
of symmetric key cryptography and hasn't

1083
00:41:27,519 --> 00:41:32,019
really seen perhaps a lot of attention

1084
00:41:29,799 --> 00:41:34,089
in the context of secure computation and

1085
00:41:32,019 --> 00:41:36,160
so here's just kind of some numbers like

1086
00:41:34,089 --> 00:41:38,799
I played around with if you garble a

1087
00:41:36,160 --> 00:41:40,690
billion gates every day for a year using

1088
00:41:38,799 --> 00:41:44,109
copy equals 80 then you can break one of

1089
00:41:40,690 --> 00:41:48,849
those instances with in time about two

1090
00:41:44,109 --> 00:41:51,308
to the 42 so let me try to describe the

1091
00:41:48,849 --> 00:41:53,229
main ideas behind the attack

1092
00:41:51,309 --> 00:41:56,979
so the evaluator is going to be learning

1093
00:41:53,229 --> 00:41:59,140
one of the labels on every wire so it's

1094
00:41:56,979 --> 00:42:02,078
learning in particular one value a star

1095
00:41:59,140 --> 00:42:04,989
in this set which is either a 0 or a 0 X

1096
00:42:02,079 --> 00:42:07,749
or R the evaluator doesn't know which is

1097
00:42:04,989 --> 00:42:09,339
the case but it also learns this value

1098
00:42:07,749 --> 00:42:10,718
t1 that was one of the values that's

1099
00:42:09,339 --> 00:42:13,420
being sent as part of the half gate

1100
00:42:10,719 --> 00:42:15,249
scheme and it learns that value t1 for

1101
00:42:13,420 --> 00:42:18,910
each of C different gates of C different

1102
00:42:15,249 --> 00:42:22,299
gates are being garbled the evaluator or

1103
00:42:18,910 --> 00:42:24,069
the attacker can then compute it can

1104
00:42:22,299 --> 00:42:25,890
hash the value a star that it received

1105
00:42:24,069 --> 00:42:30,060
it can explore that

1106
00:42:25,890 --> 00:42:35,700
he won and obtained this value here oops

1107
00:42:30,060 --> 00:42:38,640
and the observation is that this value

1108
00:42:35,700 --> 00:42:40,319
PA which I didn't actually define it's a

1109
00:42:38,640 --> 00:42:42,210
bit that in the construction of the half

1110
00:42:40,320 --> 00:42:46,350
gates protocol is zero with probability

1111
00:42:42,210 --> 00:42:48,240
half okay it's just a random bit and so

1112
00:42:46,350 --> 00:42:50,759
what that means is that the evaluator

1113
00:42:48,240 --> 00:42:53,490
has an expectation write C over two

1114
00:42:50,760 --> 00:42:57,420
values of the following form that I put

1115
00:42:53,490 --> 00:43:01,890
in this list l it has basically a memo

1116
00:42:57,420 --> 00:43:03,720
applied to to a star J X or R X or J and

1117
00:43:01,890 --> 00:43:05,279
here actually I'm just instantiating the

1118
00:43:03,720 --> 00:43:09,899
hash function H with that MMO

1119
00:43:05,280 --> 00:43:11,700
construction from the previous slide so

1120
00:43:09,900 --> 00:43:13,800
now what the attacker can do is just

1121
00:43:11,700 --> 00:43:16,080
evaluate this MMO hash function on its

1122
00:43:13,800 --> 00:43:18,720
own on a bunch of random values W 1

1123
00:43:16,080 --> 00:43:21,660
through W Q until it finds an evaluation

1124
00:43:18,720 --> 00:43:23,490
that lands in that list ok this is going

1125
00:43:21,660 --> 00:43:26,580
to occur with probability Q times C

1126
00:43:23,490 --> 00:43:28,529
divided by 2 to the kaepa and then with

1127
00:43:26,580 --> 00:43:32,130
constant probability it will hold that

1128
00:43:28,530 --> 00:43:34,920
the WI is equal to the input 2 to the

1129
00:43:32,130 --> 00:43:40,200
MMO and from there you can solve for R

1130
00:43:34,920 --> 00:43:42,150
and then you're done ok so again with

1131
00:43:40,200 --> 00:43:43,529
Kappa equals 80 and garbling 1 billion

1132
00:43:42,150 --> 00:43:44,730
gates it turns out you can actually

1133
00:43:43,530 --> 00:43:46,800
implement this attack for about a

1134
00:43:44,730 --> 00:43:51,270
thousand dollars in a few weeks in the

1135
00:43:46,800 --> 00:43:55,020
cloud so if we're trying to get better

1136
00:43:51,270 --> 00:43:56,850
concrete security for garbling what we

1137
00:43:55,020 --> 00:43:58,530
need is to look at the properties we

1138
00:43:56,850 --> 00:44:00,990
require of the underlying hash function

1139
00:43:58,530 --> 00:44:03,210
and it turns out that what you need for

1140
00:44:00,990 --> 00:44:05,100
garbling is a stronger notion of

1141
00:44:03,210 --> 00:44:06,600
correlation robustness that we call a

1142
00:44:05,100 --> 00:44:08,190
tweakable circular correlation

1143
00:44:06,600 --> 00:44:09,750
robustness actually the notion of

1144
00:44:08,190 --> 00:44:12,750
circular correlation robustness was a

1145
00:44:09,750 --> 00:44:16,110
notion that myself and some colleagues

1146
00:44:12,750 --> 00:44:18,690
introduced in 2012 here we define a

1147
00:44:16,110 --> 00:44:20,940
tweakable notion of that of that

1148
00:44:18,690 --> 00:44:22,440
definition and moreover if you want good

1149
00:44:20,940 --> 00:44:24,150
concrete security then we're gonna want

1150
00:44:22,440 --> 00:44:26,370
a construction of a TCC our hash

1151
00:44:24,150 --> 00:44:30,830
function that itself have good concrete

1152
00:44:26,370 --> 00:44:35,819
security and we show that this

1153
00:44:30,830 --> 00:44:38,100
construction that we call MMO star is is

1154
00:44:35,820 --> 00:44:39,720
going to be such a construction I want

1155
00:44:38,100 --> 00:44:41,279
to point out a couple of things here so

1156
00:44:39,720 --> 00:44:42,720
first of all right we have two inputs we

1157
00:44:41,280 --> 00:44:46,410
have the input and then the tsoukalos

1158
00:44:42,720 --> 00:44:47,848
this index or this nonce we also here

1159
00:44:46,410 --> 00:44:50,160
are moving away from the random

1160
00:44:47,849 --> 00:44:52,230
permutation model this represents

1161
00:44:50,160 --> 00:44:54,690
actually now AES itself or some block

1162
00:44:52,230 --> 00:44:56,910
cipher and this represents the key

1163
00:44:54,690 --> 00:44:58,770
whereas this left input here represents

1164
00:44:56,910 --> 00:45:00,240
the input so we're no longer working in

1165
00:44:58,770 --> 00:45:03,710
the random permutation model now we're

1166
00:45:00,240 --> 00:45:06,529
working in the ideal cypher model this

1167
00:45:03,710 --> 00:45:09,119
permutation here or this function Sigma

1168
00:45:06,530 --> 00:45:10,200
I'll talk about on the next slide but

1169
00:45:09,119 --> 00:45:11,820
it's basically going to need some

1170
00:45:10,200 --> 00:45:15,089
combinatorial properties in order to

1171
00:45:11,820 --> 00:45:16,230
prove the construction secure and in

1172
00:45:15,090 --> 00:45:17,820
particular what we're going to require

1173
00:45:16,230 --> 00:45:23,010
is that Sigma be what's called a linear

1174
00:45:17,820 --> 00:45:24,840
ortho morphism we define for any given

1175
00:45:23,010 --> 00:45:28,830
Sigma we can define this function Sigma

1176
00:45:24,840 --> 00:45:30,570
prime to be Sigma xx or X and then we'll

1177
00:45:28,830 --> 00:45:32,549
say that Sigma is an ortho morphism if

1178
00:45:30,570 --> 00:45:36,359
both Sigma and Sigma prime are

1179
00:45:32,550 --> 00:45:39,480
permutations and then Sigma is linear if

1180
00:45:36,359 --> 00:45:41,069
the standard property holds and these

1181
00:45:39,480 --> 00:45:42,630
functions turn out to have received a

1182
00:45:41,070 --> 00:45:44,070
lot of attention in the symmetric key

1183
00:45:42,630 --> 00:45:46,950
literature and they have also been

1184
00:45:44,070 --> 00:45:49,349
imported to some extent into secure

1185
00:45:46,950 --> 00:45:51,270
computation in particular the

1186
00:45:49,349 --> 00:45:54,240
multiplying by two that I showed earlier

1187
00:45:51,270 --> 00:45:57,089
I think arises from the fact that this

1188
00:45:54,240 --> 00:46:00,689
is a is a linear ortho morphism it was

1189
00:45:57,089 --> 00:46:03,540
suggested in the I believe in the just

1190
00:46:00,690 --> 00:46:06,000
garble paper we find actually a

1191
00:46:03,540 --> 00:46:07,349
different construction is it's actually

1192
00:46:06,000 --> 00:46:09,150
much more efficient can be implemented

1193
00:46:07,349 --> 00:46:11,220
in a very small number of instructions

1194
00:46:09,150 --> 00:46:15,420
and it's better than doing than paying

1195
00:46:11,220 --> 00:46:16,890
the cost of a field multiplication so

1196
00:46:15,420 --> 00:46:18,720
the theorem then is that if Sigma is a

1197
00:46:16,890 --> 00:46:20,819
linear ortho morphism and if we model

1198
00:46:18,720 --> 00:46:25,770
the block cipher F as an ideal cipher

1199
00:46:20,820 --> 00:46:28,560
then MMO star is a tweakable circular

1200
00:46:25,770 --> 00:46:31,710
correlation robust and moreover it has a

1201
00:46:28,560 --> 00:46:33,779
kappa bit security so this is true only

1202
00:46:31,710 --> 00:46:37,470
in the case where every tweak the second

1203
00:46:33,780 --> 00:46:39,570
input I is used once and that will be

1204
00:46:37,470 --> 00:46:41,279
the case when we apply it to the context

1205
00:46:39,570 --> 00:46:47,220
of garbling when we apply to the context

1206
00:46:41,280 --> 00:46:48,660
of secure computation so overall then we

1207
00:46:47,220 --> 00:46:51,000
obtain a garbling scheme with the same

1208
00:46:48,660 --> 00:46:53,549
communication complexity as free XOR

1209
00:46:51,000 --> 00:46:55,860
plus half gates but with a tight secure

1210
00:46:53,550 --> 00:46:58,080
reduction based on a yes modeled as an

1211
00:46:55,860 --> 00:46:59,670
ideal cipher and I was talking earlier

1212
00:46:58,080 --> 00:47:03,450
about how in general people like to

1213
00:46:59,670 --> 00:47:05,610
avoid their the the the paying the cost

1214
00:47:03,450 --> 00:47:07,160
of rekeying for AES so it's true that

1215
00:47:05,610 --> 00:47:09,240
you do pay some penalty for that

1216
00:47:07,160 --> 00:47:10,680
thankfully there's been some other work

1217
00:47:09,240 --> 00:47:12,419
also in the context of secure

1218
00:47:10,680 --> 00:47:13,560
computation showing that you can at

1219
00:47:12,420 --> 00:47:15,150
least do a little bit better and the

1220
00:47:13,560 --> 00:47:18,990
cost of rekeying is not as bad as you

1221
00:47:15,150 --> 00:47:20,820
might expect I'll just mention also that

1222
00:47:18,990 --> 00:47:23,339
we can extend these results to obtain

1223
00:47:20,820 --> 00:47:27,120
tighter security also for garbling even

1224
00:47:23,340 --> 00:47:28,770
in the multi instance setting so let me

1225
00:47:27,120 --> 00:47:30,120
just conclude with a couple of thoughts

1226
00:47:28,770 --> 00:47:34,230
and then we'll have time for some

1227
00:47:30,120 --> 00:47:36,120
questions so I think there's been a lot

1228
00:47:34,230 --> 00:47:38,340
of work on secure computation

1229
00:47:36,120 --> 00:47:40,799
in the last thirty years and of course

1230
00:47:38,340 --> 00:47:42,720
most of the initial work in that field

1231
00:47:40,800 --> 00:47:44,430
was focusing on the theory of secure

1232
00:47:42,720 --> 00:47:46,709
computation focusing on definitions

1233
00:47:44,430 --> 00:47:49,470
focusing on feasibility results focusing

1234
00:47:46,710 --> 00:47:52,640
on different models and in the last 15

1235
00:47:49,470 --> 00:47:54,990
years say since the fair play paper

1236
00:47:52,640 --> 00:47:58,020
there's been an increased focus on

1237
00:47:54,990 --> 00:47:59,759
implementing secure computation and in

1238
00:47:58,020 --> 00:48:02,610
improving the practical efficiency of

1239
00:47:59,760 --> 00:48:04,910
secure computation protocols and I would

1240
00:48:02,610 --> 00:48:07,500
say this has been mainly a theory

1241
00:48:04,910 --> 00:48:09,149
driving the practice with of course the

1242
00:48:07,500 --> 00:48:11,040
fury being motivated by real-world

1243
00:48:09,150 --> 00:48:13,620
efficiency but it's really been more

1244
00:48:11,040 --> 00:48:14,940
theoretical work that then turns out to

1245
00:48:13,620 --> 00:48:18,480
be to lead to these efficiency

1246
00:48:14,940 --> 00:48:20,600
improvements and perhaps in the next 15

1247
00:48:18,480 --> 00:48:24,930
years we'll see a little bit of a flip

1248
00:48:20,600 --> 00:48:27,060
and see more practical issues driving

1249
00:48:24,930 --> 00:48:29,669
the theory and I think that will

1250
00:48:27,060 --> 00:48:32,340
especially be the case as not only there

1251
00:48:29,670 --> 00:48:33,630
are more secure computation libraries

1252
00:48:32,340 --> 00:48:35,820
out there that people are experimenting

1253
00:48:33,630 --> 00:48:38,070
with but when there start to be

1254
00:48:35,820 --> 00:48:39,720
deployments of secure computation in

1255
00:48:38,070 --> 00:48:41,430
real-world use cases and as companies

1256
00:48:39,720 --> 00:48:44,459
are beginning to deploy and sell these

1257
00:48:41,430 --> 00:48:45,899
things in the real world that I think

1258
00:48:44,460 --> 00:48:48,330
will bring up many interesting questions

1259
00:48:45,900 --> 00:48:50,550
that will then need a new theory to

1260
00:48:48,330 --> 00:48:53,910
address and I think these kind of things

1261
00:48:50,550 --> 00:48:56,100
are very important to think about as we

1262
00:48:53,910 --> 00:48:58,319
perhaps move toward developing standards

1263
00:48:56,100 --> 00:49:01,380
for things like zero knowledge or secure

1264
00:48:58,320 --> 00:49:03,510
computation so I just thought I would

1265
00:49:01,380 --> 00:49:05,310
list maybe a couple of open directions I

1266
00:49:03,510 --> 00:49:07,200
put a question mark there because I'm

1267
00:49:05,310 --> 00:49:09,509
sure I actually I know that many of

1268
00:49:07,200 --> 00:49:11,790
these are addressed at least in part by

1269
00:49:09,510 --> 00:49:13,410
various papers I would say there's still

1270
00:49:11,790 --> 00:49:16,319
more work to be done in those directions

1271
00:49:13,410 --> 00:49:18,420
though so I think first of all maybe an

1272
00:49:16,319 --> 00:49:21,359
increased attention to concrete security

1273
00:49:18,420 --> 00:49:23,940
is called for and in particular I'm not

1274
00:49:21,359 --> 00:49:25,529
aware of any composition theorem that

1275
00:49:23,940 --> 00:49:27,180
actually deals with concrete security

1276
00:49:25,530 --> 00:49:28,380
and if you start thinking about it you

1277
00:49:27,180 --> 00:49:29,879
realize that there are good reasons for

1278
00:49:28,380 --> 00:49:31,799
that because it's not as trivial as you

1279
00:49:29,880 --> 00:49:33,990
might think you can even start thinking

1280
00:49:31,799 --> 00:49:35,490
about what what a a version of Universal

1281
00:49:33,990 --> 00:49:39,270
composability would look like with a

1282
00:49:35,490 --> 00:49:41,129
concrete security treatment a better

1283
00:49:39,270 --> 00:49:43,799
understanding of ideal primitives and

1284
00:49:41,130 --> 00:49:45,839
protocols right here I talked about two

1285
00:49:43,799 --> 00:49:47,549
lines of work using the random

1286
00:49:45,839 --> 00:49:49,290
permutation model or the ideal cypher

1287
00:49:47,549 --> 00:49:51,480
model there's lots of protocols

1288
00:49:49,290 --> 00:49:53,940
developed in the random Oracle model I I

1289
00:49:51,480 --> 00:49:55,319
would say maybe it's maybe it's my own

1290
00:49:53,940 --> 00:49:57,030
take on things I think we still don't

1291
00:49:55,319 --> 00:50:00,210
have a full understanding of what

1292
00:49:57,030 --> 00:50:02,280
exactly what sort of composition results

1293
00:50:00,210 --> 00:50:03,900
hold when we talk about composing

1294
00:50:02,280 --> 00:50:05,490
protocols that rely on these ideal

1295
00:50:03,900 --> 00:50:07,200
primitives and there are very often

1296
00:50:05,490 --> 00:50:08,790
cases where things don't satisfy the

1297
00:50:07,200 --> 00:50:11,009
properties you might expect by naively

1298
00:50:08,790 --> 00:50:12,569
applying existing composition theorems

1299
00:50:11,010 --> 00:50:13,920
that mainly talk about composition in

1300
00:50:12,569 --> 00:50:15,420
the absence of these ideal primitives

1301
00:50:13,920 --> 00:50:20,369
certainly that's true in the standalone

1302
00:50:15,420 --> 00:50:24,660
setting what about post quantum NPC as

1303
00:50:20,369 --> 00:50:26,849
far as I can tell there's been you know

1304
00:50:24,660 --> 00:50:28,710
less than five papers looking at

1305
00:50:26,849 --> 00:50:30,390
constructions of post quantum oblivious

1306
00:50:28,710 --> 00:50:32,130
transfer but this is something that

1307
00:50:30,390 --> 00:50:34,020
people are paying a lot of attention to

1308
00:50:32,130 --> 00:50:35,430
in the public key world in general in

1309
00:50:34,020 --> 00:50:37,109
the context of encryption and signatures

1310
00:50:35,430 --> 00:50:38,460
and we need to start looking at that in

1311
00:50:37,109 --> 00:50:40,440
the context of things like oblivious

1312
00:50:38,460 --> 00:50:42,000
transfer as well and we can also ask

1313
00:50:40,440 --> 00:50:43,589
about the concrete security of these

1314
00:50:42,000 --> 00:50:47,930
various symmetric key components of the

1315
00:50:43,589 --> 00:50:50,308
protocols against quantum attackers I

1316
00:50:47,930 --> 00:50:52,680
think also there's a lot of work to be

1317
00:50:50,309 --> 00:50:54,809
done on mapping some of our theoretical

1318
00:50:52,680 --> 00:50:57,480
models to the way things actually work

1319
00:50:54,809 --> 00:50:59,339
in practice just as that you know some

1320
00:50:57,480 --> 00:51:00,630
examples right I mean we assume that

1321
00:50:59,339 --> 00:51:02,609
there's some fixed set of parties right

1322
00:51:00,630 --> 00:51:03,839
there's end parties and they all agree T

1323
00:51:02,609 --> 00:51:05,400
equals zero to start running the

1324
00:51:03,839 --> 00:51:07,799
protocol but how is that actually going

1325
00:51:05,400 --> 00:51:09,150
to work in the real world right if you

1326
00:51:07,799 --> 00:51:10,680
think about applications of this to

1327
00:51:09,150 --> 00:51:12,119
something like voting you realize that

1328
00:51:10,680 --> 00:51:15,480
that model doesn't translate very well

1329
00:51:12,119 --> 00:51:17,040
to that kind of a setting you can talk

1330
00:51:15,480 --> 00:51:18,630
about session IDs this is something

1331
00:51:17,040 --> 00:51:20,279
that's needed for composition for

1332
00:51:18,630 --> 00:51:23,190
universal composability and for

1333
00:51:20,280 --> 00:51:24,600
reasons and I think generally people

1334
00:51:23,190 --> 00:51:27,630
ignore that when they implement their

1335
00:51:24,600 --> 00:51:28,500
protocols and it's you know there you

1336
00:51:27,630 --> 00:51:30,500
are make it for a good reason because

1337
00:51:28,500 --> 00:51:32,670
it's not so always so simple to

1338
00:51:30,500 --> 00:51:34,110
establish agreement on the section IDs

1339
00:51:32,670 --> 00:51:36,330
and it can add some complexity to the

1340
00:51:34,110 --> 00:51:38,310
protocol looking at how these various

1341
00:51:36,330 --> 00:51:40,710
setups actually would be implemented and

1342
00:51:38,310 --> 00:51:42,570
used in practice I think considering

1343
00:51:40,710 --> 00:51:43,980
more complex just models right so again

1344
00:51:42,570 --> 00:51:45,390
this is something that goes back decades

1345
00:51:43,980 --> 00:51:47,280
people have looked at generalized

1346
00:51:45,390 --> 00:51:48,900
adversary models but if you look at the

1347
00:51:47,280 --> 00:51:51,420
work on efficient secure computation

1348
00:51:48,900 --> 00:51:53,970
people have generally stayed with the

1349
00:51:51,420 --> 00:51:56,210
more classical threshold adversary but

1350
00:51:53,970 --> 00:51:58,649
you can it's also interesting to look

1351
00:51:56,210 --> 00:52:01,680
for optimized protocols that are secure

1352
00:51:58,650 --> 00:52:03,150
in these more complex settings another

1353
00:52:01,680 --> 00:52:05,040
thing that's interesting to me recently

1354
00:52:03,150 --> 00:52:07,770
is a more more accurate modeling of the

1355
00:52:05,040 --> 00:52:08,759
network we have basically two models or

1356
00:52:07,770 --> 00:52:11,100
at a synchronous model and an

1357
00:52:08,760 --> 00:52:12,810
asynchronous model and it turns you know

1358
00:52:11,100 --> 00:52:14,700
I think neither of those may be a very

1359
00:52:12,810 --> 00:52:16,230
good model for the way real-world

1360
00:52:14,700 --> 00:52:18,029
communication networks work especially

1361
00:52:16,230 --> 00:52:19,590
when you're talking about parties where

1362
00:52:18,030 --> 00:52:20,820
some of them may be located in the same

1363
00:52:19,590 --> 00:52:22,440
data center but some of them may be

1364
00:52:20,820 --> 00:52:25,170
located across the world

1365
00:52:22,440 --> 00:52:29,220
similarly we always we generally think

1366
00:52:25,170 --> 00:52:30,720
about a complete topology but in many in

1367
00:52:29,220 --> 00:52:32,549
many real world applications of secure

1368
00:52:30,720 --> 00:52:34,709
computation you mean you either may not

1369
00:52:32,550 --> 00:52:36,990
have a complete topology meaning meaning

1370
00:52:34,710 --> 00:52:38,370
links between all pairs of players or it

1371
00:52:36,990 --> 00:52:39,930
may be the case that some links are much

1372
00:52:38,370 --> 00:52:41,460
more expensive to use than others and so

1373
00:52:39,930 --> 00:52:44,339
you'd like to minimize the amount of

1374
00:52:41,460 --> 00:52:46,860
data you send across those links I think

1375
00:52:44,340 --> 00:52:50,460
also in a slightly different direction

1376
00:52:46,860 --> 00:52:52,410
the formal verification of MPC implement

1377
00:52:50,460 --> 00:52:53,640
key implementations is something that's

1378
00:52:52,410 --> 00:52:55,140
also going to be important as we talk

1379
00:52:53,640 --> 00:52:58,920
about deploying these things in the real

1380
00:52:55,140 --> 00:53:00,270
world it's very easy to look at a proof

1381
00:52:58,920 --> 00:53:01,680
in the paper and be convinced that it's

1382
00:53:00,270 --> 00:53:03,360
correct sometimes they turn out to be

1383
00:53:01,680 --> 00:53:05,609
wrong maybe just for subtle subtle

1384
00:53:03,360 --> 00:53:06,900
errors then when you take that protocol

1385
00:53:05,610 --> 00:53:08,640
from the paper and implement it it's

1386
00:53:06,900 --> 00:53:11,180
very easy I mean as I've shown here to

1387
00:53:08,640 --> 00:53:13,319
get some details wrong and then

1388
00:53:11,180 --> 00:53:15,870
invalidate the end-to-end security proof

1389
00:53:13,320 --> 00:53:18,450
and I think formal verification can help

1390
00:53:15,870 --> 00:53:19,859
you're at least even if we can't do an

1391
00:53:18,450 --> 00:53:21,509
end-to-end verification of a full

1392
00:53:19,860 --> 00:53:23,820
implementation at least verifying parts

1393
00:53:21,510 --> 00:53:27,000
of it will give us confidence in in

1394
00:53:23,820 --> 00:53:28,680
different parts of the protocol so with

1395
00:53:27,000 --> 00:53:30,210
that I'll conclude I think we have you

1396
00:53:28,680 --> 00:53:32,279
know one to five minutes for questions

1397
00:53:30,210 --> 00:53:33,480
depending on how hungry people are but

1398
00:53:32,280 --> 00:53:35,720
I'm happy to take any questions people

1399
00:53:33,480 --> 00:53:35,720
have

1400
00:53:44,740 --> 00:53:50,720
yes please if you have questions come

1401
00:53:47,030 --> 00:53:54,650
down the aisle and and use the

1402
00:53:50,720 --> 00:53:58,609
microphone and in the meantime let me

1403
00:53:54,650 --> 00:54:00,410
ask a question so these so from your

1404
00:53:58,610 --> 00:54:02,390
presentation it seems that the random

1405
00:54:00,410 --> 00:54:05,240
articles can be a great way to make

1406
00:54:02,390 --> 00:54:08,390
things efficient but in practice they

1407
00:54:05,240 --> 00:54:11,569
can be also very error-prone and tricky

1408
00:54:08,390 --> 00:54:13,210
to use which also from a practical point

1409
00:54:11,570 --> 00:54:18,680
of view is not good

1410
00:54:13,210 --> 00:54:20,480
how much would you lose by trying to not

1411
00:54:18,680 --> 00:54:22,850
use the random Oracle model and try to

1412
00:54:20,480 --> 00:54:25,010
get secure multi-party computation in

1413
00:54:22,850 --> 00:54:26,750
the standard model primarily for a user

1414
00:54:25,010 --> 00:54:29,540
believed to make it easier to design a

1415
00:54:26,750 --> 00:54:30,890
program yeah it's a good question I mean

1416
00:54:29,540 --> 00:54:33,890
I don't have the answer of hand it so

1417
00:54:30,890 --> 00:54:38,569
it's an open question I would say you

1418
00:54:33,890 --> 00:54:39,950
know yeah I mean it's a research

1419
00:54:38,570 --> 00:54:41,780
question right so you could look at that

1420
00:54:39,950 --> 00:54:43,460
garble the garbling protocol I showed

1421
00:54:41,780 --> 00:54:46,490
and the trivial garbling protocol for

1422
00:54:43,460 --> 00:54:47,660
example can be implemented based on a es

1423
00:54:46,490 --> 00:54:49,939
just treating it as a pseudo-random

1424
00:54:47,660 --> 00:54:51,710
function without making any idealized

1425
00:54:49,940 --> 00:54:54,200
assumptions at all so that gives you

1426
00:54:51,710 --> 00:54:55,670
maybe something to compare to in general

1427
00:54:54,200 --> 00:54:57,710
though we like to squeeze as much

1428
00:54:55,670 --> 00:54:58,670
efficiency out as possible and it seems

1429
00:54:57,710 --> 00:55:00,980
like you're always going to do better

1430
00:54:58,670 --> 00:55:05,300
the more the stronger assumptions you're

1431
00:55:00,980 --> 00:55:11,960
willing to make in G has anyone looked

1432
00:55:05,300 --> 00:55:13,340
at using for proof of work not that I'm

1433
00:55:11,960 --> 00:55:16,460
aware of but it wasn't surprise me if

1434
00:55:13,340 --> 00:55:17,690
somebody had I think you know if you're

1435
00:55:16,460 --> 00:55:19,400
talking about just replacing the hash

1436
00:55:17,690 --> 00:55:20,960
function using Bitcoin with AES or

1437
00:55:19,400 --> 00:55:22,100
something like that I mean I'm not sure

1438
00:55:20,960 --> 00:55:23,420
what the advantage would be because

1439
00:55:22,100 --> 00:55:24,980
you'd want to keep the work the same so

1440
00:55:23,420 --> 00:55:26,900
you maybe have to increase the number of

1441
00:55:24,980 --> 00:55:29,330
AES calls you do to make it consistent

1442
00:55:26,900 --> 00:55:34,400
it may be because then I'd be able to

1443
00:55:29,330 --> 00:55:36,970
use video ah ok yeah so well now you

1444
00:55:34,400 --> 00:55:36,970
have a company

1445
00:55:37,410 --> 00:55:50,549
I also agree with everything you said

1446
00:55:42,870 --> 00:55:52,830
the other way so when I agree with your

1447
00:55:50,550 --> 00:55:55,050
concrete security type approach well

1448
00:55:52,830 --> 00:55:57,000
what about the composition theorem just

1449
00:55:55,050 --> 00:56:00,240
a pointer that we got some paper

1450
00:55:57,000 --> 00:56:01,560
features back on resource fairness or we

1451
00:56:00,240 --> 00:56:05,430
have to reprove you know we have a

1452
00:56:01,560 --> 00:56:08,250
composition theorem this give you clean

1453
00:56:05,430 --> 00:56:10,470
concrete bounds lightly like for

1454
00:56:08,250 --> 00:56:13,110
resource fairness but it's an excel file

1455
00:56:10,470 --> 00:56:27,750
you have to go into the concrete okay so

1456
00:56:13,110 --> 00:56:30,600
that's a good point I came but okay so

1457
00:56:27,750 --> 00:56:34,370
firstly just to say that in the UC

1458
00:56:30,600 --> 00:56:40,610
monster there is also a definition with

1459
00:56:34,370 --> 00:56:40,609
yeah so it's a definition and actually

1460
00:56:43,080 --> 00:56:46,139
[Music]

1461
00:56:46,490 --> 00:56:52,410
there is no paper that came out lap here

1462
00:56:48,840 --> 00:57:01,290
yeah but I think it's been there for ya

1463
00:56:52,410 --> 00:57:02,520
so the my composition you lose argument

1464
00:57:01,290 --> 00:57:04,980
right but I think the issue is that you

1465
00:57:02,520 --> 00:57:06,030
have this extra term of the simulator

1466
00:57:04,980 --> 00:57:07,620
right cuz you can you can trade off

1467
00:57:06,030 --> 00:57:10,110
attacker complexity for simulator

1468
00:57:07,620 --> 00:57:13,920
complexity no so the simulator convexity

1469
00:57:10,110 --> 00:57:16,140
actually remains the same I mean I need

1470
00:57:13,920 --> 00:57:17,460
to turn you but I mean when you're

1471
00:57:16,140 --> 00:57:18,750
proving protocols right you can have a

1472
00:57:17,460 --> 00:57:20,100
protocol that's secure against one

1473
00:57:18,750 --> 00:57:21,540
adversary with this running time of a

1474
00:57:20,100 --> 00:57:28,560
simulator and get better bounds with a

1475
00:57:21,540 --> 00:57:32,730
different but the other point regarding

1476
00:57:28,560 --> 00:57:36,620
the fork and and and and yes so just to

1477
00:57:32,730 --> 00:57:40,380
say that there is this recent work that

1478
00:57:36,620 --> 00:57:45,690
we actually show that if you think about

1479
00:57:40,380 --> 00:57:47,610
correlation activity of big ski yes and

1480
00:57:45,690 --> 00:57:49,440
if you assume you know I didn't secure

1481
00:57:47,610 --> 00:57:55,710
not ideal but you know it's

1482
00:57:49,440 --> 00:58:04,470
security for yes then it actually gives

1483
00:57:55,710 --> 00:58:05,880
some concrete bounds yes maybe tying

1484
00:58:04,470 --> 00:58:07,799
that back to Danielle if question right

1485
00:58:05,880 --> 00:58:09,599
that may be a type of assumption under

1486
00:58:07,800 --> 00:58:11,069
which is assuming you know that a yes

1487
00:58:09,599 --> 00:58:12,630
the PRF but you need this much

1488
00:58:11,069 --> 00:58:14,130
complexity to attack it may be a slight

1489
00:58:12,630 --> 00:58:15,839
weakening of the ideal cipher model that

1490
00:58:14,130 --> 00:58:19,170
where you can prove self yeah absolutely

1491
00:58:15,839 --> 00:58:26,900
and actually in this case a yes is much

1492
00:58:19,170 --> 00:58:26,900
better than Shah you know it's a vision

1493
00:58:27,319 --> 00:58:54,359
and you think of it as in so this

1494
00:58:35,790 --> 00:58:55,680
particular it's it's okay so let's thank

1495
00:58:54,359 --> 00:58:57,009
Jonathan again

1496
00:58:55,680 --> 00:59:00,269
[Applause]

1497
00:58:57,010 --> 00:59:00,269
[Music]

