1
00:00:05,000 --> 00:00:11,760
everyone so I guess

2
00:00:08,820 --> 00:00:13,650
mark mostly won over the the

3
00:00:11,760 --> 00:00:17,130
introductory material on this with you

4
00:00:13,650 --> 00:00:18,810
know somewhat better slides but so as

5
00:00:17,130 --> 00:00:23,369
you know we used the random Oracle model

6
00:00:18,810 --> 00:00:24,720
a lot to model protocols where we still

7
00:00:23,370 --> 00:00:26,130
don't know how to prove things in the

8
00:00:24,720 --> 00:00:30,930
standard model under standard

9
00:00:26,130 --> 00:00:34,559
assumptions and in the quantum world we

10
00:00:30,930 --> 00:00:35,879
want to be able to port this over so for

11
00:00:34,559 --> 00:00:38,280
which purpose we have the quantum random

12
00:00:35,879 --> 00:00:40,199
Oracle model but the proofs in that

13
00:00:38,280 --> 00:00:43,710
model are much more difficult and often

14
00:00:40,200 --> 00:00:44,940
give looser bounds and we would like to

15
00:00:43,710 --> 00:00:47,730
of course be able to distinguish between

16
00:00:44,940 --> 00:00:48,900
some cases the proofs give looser bounds

17
00:00:47,730 --> 00:00:51,720
in some cases the attacks are actually

18
00:00:48,900 --> 00:00:57,839
better so I mean the the most well-known

19
00:00:51,720 --> 00:01:01,769
example is Grover's algorithm and so in

20
00:00:57,840 --> 00:01:03,420
in that direction we want to sort of

21
00:01:01,770 --> 00:01:05,729
develop techniques that worked in the

22
00:01:03,420 --> 00:01:10,470
classic rom that that still work in the

23
00:01:05,729 --> 00:01:12,600
q rom so you heard in the last talk how

24
00:01:10,470 --> 00:01:14,340
to do this for recording the adversaries

25
00:01:12,600 --> 00:01:16,350
queries and responding adaptively but

26
00:01:14,340 --> 00:01:19,799
there's still a large number of caveats

27
00:01:16,350 --> 00:01:21,570
on that and so it requires quite a lot

28
00:01:19,799 --> 00:01:24,810
of expertise to wield so a simpler

29
00:01:21,570 --> 00:01:26,250
technique but a weaker one is this one

30
00:01:24,810 --> 00:01:29,210
way to hiding technique that sort of

31
00:01:26,250 --> 00:01:32,130
still works in the q rom so here were

32
00:01:29,210 --> 00:01:35,009
trying to make that easier to use apply

33
00:01:32,130 --> 00:01:37,589
to more cases and have at least in some

34
00:01:35,010 --> 00:01:40,290
cases a lower security loss so the the

35
00:01:37,590 --> 00:01:43,530
original work comes from Unruh who's one

36
00:01:40,290 --> 00:01:45,840
of the authors on this paper in 2015 but

37
00:01:43,530 --> 00:01:47,820
his one way to hiding only works in very

38
00:01:45,840 --> 00:01:49,950
restrictive settings and has quadratic

39
00:01:47,820 --> 00:01:52,490
security loss in the number of queries q

40
00:01:49,950 --> 00:01:57,509
that the adversary makes to the Oracle

41
00:01:52,490 --> 00:01:59,100
and in here we sort of generalized it

42
00:01:57,509 --> 00:02:03,270
removed a bunch of the restrictions and

43
00:01:59,100 --> 00:02:05,759
tightened it so that it can be as low as

44
00:02:03,270 --> 00:02:07,470
linear loss and linear in the depth of

45
00:02:05,759 --> 00:02:09,720
the queries that the adversary makes to

46
00:02:07,470 --> 00:02:12,349
the Oracle which practically speaking

47
00:02:09,720 --> 00:02:15,239
could be much less than the total number

48
00:02:12,349 --> 00:02:17,130
so an outline of the talk is a brief

49
00:02:15,239 --> 00:02:18,720
brief discussion of the differences

50
00:02:17,130 --> 00:02:20,880
between the the classical

51
00:02:18,720 --> 00:02:22,500
the quantum Rahm and these new one way

52
00:02:20,880 --> 00:02:26,010
to hiding results and then some examples

53
00:02:22,500 --> 00:02:27,480
how you can use them to prove things

54
00:02:26,010 --> 00:02:33,179
sort of time permitting in a relatively

55
00:02:27,480 --> 00:02:36,690
sane way so you know how the random

56
00:02:33,180 --> 00:02:38,040
Oracle works so most attacks either are

57
00:02:36,690 --> 00:02:39,480
attacking a hash function or they're

58
00:02:38,040 --> 00:02:41,070
just treating it as a black box that

59
00:02:39,480 --> 00:02:44,340
returns random numbers you might call

60
00:02:41,070 --> 00:02:45,959
them generic and so you suppose that the

61
00:02:44,340 --> 00:02:47,910
attack would still work if the hash

62
00:02:45,960 --> 00:02:50,130
function really were a black box or a

63
00:02:47,910 --> 00:02:51,720
magic 8-ball or something

64
00:02:50,130 --> 00:02:53,040
and so this formalizes a lot of

65
00:02:51,720 --> 00:02:54,780
intuition that you might have when

66
00:02:53,040 --> 00:02:57,840
designing a protocol such as you know

67
00:02:54,780 --> 00:02:59,580
the attacker can't know anything about

68
00:02:57,840 --> 00:03:02,490
the hash of a message without actually

69
00:02:59,580 --> 00:03:04,140
knowing what that message is and it

70
00:03:02,490 --> 00:03:05,670
allows you to furthermore extract the

71
00:03:04,140 --> 00:03:07,410
message because it has to be presented

72
00:03:05,670 --> 00:03:10,109
as an Oracle query before the adversary

73
00:03:07,410 --> 00:03:11,310
knows anything about it and so you have

74
00:03:10,110 --> 00:03:13,800
all these proof techniques right where

75
00:03:11,310 --> 00:03:15,420
the simulator can can control the random

76
00:03:13,800 --> 00:03:18,060
Oracle can see all the queries can

77
00:03:15,420 --> 00:03:21,269
choose answers adaptively can rewind the

78
00:03:18,060 --> 00:03:23,130
adversary and so on and furthermore you

79
00:03:21,270 --> 00:03:25,260
get some very simple information

80
00:03:23,130 --> 00:03:27,510
theoretic limits about what adversaries

81
00:03:25,260 --> 00:03:31,049
can do on uncertain problems so for

82
00:03:27,510 --> 00:03:33,269
example if you're given H of X then the

83
00:03:31,050 --> 00:03:35,900
adversary can't find X with probability

84
00:03:33,269 --> 00:03:38,910
more than Q plus 1 over the domain size

85
00:03:35,900 --> 00:03:41,640
because while he's good gets Q shots to

86
00:03:38,910 --> 00:03:43,680
query it on random Oracle queries and

87
00:03:41,640 --> 00:03:46,829
then you know maybe one guess with his

88
00:03:43,680 --> 00:03:48,390
output and so there's a there's a sort

89
00:03:46,830 --> 00:03:51,450
of trivial proof of that almost in the

90
00:03:48,390 --> 00:03:52,559
in the classical random Oracle model but

91
00:03:51,450 --> 00:03:54,000
in the quantum random Oracle model

92
00:03:52,560 --> 00:03:58,410
things get a little bit more complicated

93
00:03:54,000 --> 00:04:01,320
so the adversary can now query the hash

94
00:03:58,410 --> 00:04:02,790
function and quantum superposition so as

95
00:04:01,320 --> 00:04:07,140
Mark said right you could imagine like

96
00:04:02,790 --> 00:04:08,970
he puts in the sum of amplitude times X

97
00:04:07,140 --> 00:04:10,950
and gets out the sum of amplitude times

98
00:04:08,970 --> 00:04:12,660
hash of X but that doesn't actually work

99
00:04:10,950 --> 00:04:16,168
because it's got to be reversible so

100
00:04:12,660 --> 00:04:19,668
it's actually this you know X Y and and

101
00:04:16,168 --> 00:04:23,520
then hash of X gets XOR it in to Y but

102
00:04:19,668 --> 00:04:25,710
same basic idea and so it's been shown

103
00:04:23,520 --> 00:04:28,950
that the quantum adversaries can do more

104
00:04:25,710 --> 00:04:30,690
in this model with fewer queries on some

105
00:04:28,950 --> 00:04:32,010
problems and on some they can't and so

106
00:04:30,690 --> 00:04:32,820
it's and it's kind of hard to tell

107
00:04:32,010 --> 00:04:35,310
intuitively what

108
00:04:32,820 --> 00:04:37,230
ones those are going to be and it's also

109
00:04:35,310 --> 00:04:39,330
very difficult to record queries to

110
00:04:37,230 --> 00:04:41,730
Oracle's so if the Oracle is a uniformly

111
00:04:39,330 --> 00:04:44,640
random quantum Oracle then the previous

112
00:04:41,730 --> 00:04:46,110
talk says you can sort of record the

113
00:04:44,640 --> 00:04:47,930
queries approximately and there's a

114
00:04:46,110 --> 00:04:50,670
little bit of loss in recovering them

115
00:04:47,930 --> 00:04:52,770
the simulator can in some cases respond

116
00:04:50,670 --> 00:04:57,630
adaptively but again there's a lot of

117
00:04:52,770 --> 00:05:02,370
caveats on that so we're gonna show a

118
00:04:57,630 --> 00:05:04,860
technique that that can recover some

119
00:05:02,370 --> 00:05:07,620
semblance of tightness and proofs

120
00:05:04,860 --> 00:05:12,990
without necessarily getting into the

121
00:05:07,620 --> 00:05:15,630
analysis required to figure out quantum

122
00:05:12,990 --> 00:05:18,390
recording of queries or to analyze too

123
00:05:15,630 --> 00:05:20,010
much into the quantum states but before

124
00:05:18,390 --> 00:05:24,450
we do that one note on depth

125
00:05:20,010 --> 00:05:26,550
restrictions so a realistic adversary if

126
00:05:24,450 --> 00:05:27,960
it's querying an Oracle many times is

127
00:05:26,550 --> 00:05:29,730
like practically gonna have to do this

128
00:05:27,960 --> 00:05:31,590
in parallel right so you want to make

129
00:05:29,730 --> 00:05:35,520
two to the 64 queries to an Oracle for

130
00:05:31,590 --> 00:05:38,179
your attack if you're Bitcoin then

131
00:05:35,520 --> 00:05:42,000
you're doing this four times a second

132
00:05:38,180 --> 00:05:44,460
every second and that works because

133
00:05:42,000 --> 00:05:46,320
Bitcoin the Bitcoin network has a huge

134
00:05:44,460 --> 00:05:48,120
number of computers that are operating

135
00:05:46,320 --> 00:05:49,620
in parallel or rather Asics operating in

136
00:05:48,120 --> 00:05:51,270
parallel but if you were to do this

137
00:05:49,620 --> 00:05:53,550
sequentially even if you could do it

138
00:05:51,270 --> 00:05:55,440
every clock cycle at five gigahertz it

139
00:05:53,550 --> 00:05:58,530
would take more than a hundred years so

140
00:05:55,440 --> 00:06:00,420
practically you can say essentially no

141
00:05:58,530 --> 00:06:02,520
adversary on computers that we know

142
00:06:00,420 --> 00:06:05,100
about is going to be able to do two to

143
00:06:02,520 --> 00:06:07,289
the 64 sequential work but they might

144
00:06:05,100 --> 00:06:10,440
very well easily be able to do two to

145
00:06:07,290 --> 00:06:12,560
the 64 parallel work so in addition to

146
00:06:10,440 --> 00:06:15,780
the number of queries we're going to use

147
00:06:12,560 --> 00:06:18,330
depth of queries sort of a circuit depth

148
00:06:15,780 --> 00:06:21,840
where the things that add to the depth

149
00:06:18,330 --> 00:06:24,570
are Oracle queries which isn't

150
00:06:21,840 --> 00:06:26,729
necessarily less than or equal to Q and

151
00:06:24,570 --> 00:06:28,590
all this really does is in the analysis

152
00:06:26,730 --> 00:06:29,970
it replaces you know query with round of

153
00:06:28,590 --> 00:06:31,409
queries and the reason we're doing this

154
00:06:29,970 --> 00:06:33,030
is that while in the classical random

155
00:06:31,410 --> 00:06:34,380
Oracle model it doesn't necessarily help

156
00:06:33,030 --> 00:06:35,909
you like you still end up with a queue

157
00:06:34,380 --> 00:06:39,180
out front instead of a D out front in

158
00:06:35,910 --> 00:06:40,980
most cases in the queue ROM it will help

159
00:06:39,180 --> 00:06:43,169
so for example Grover's algorithm is

160
00:06:40,980 --> 00:06:45,090
going to depend on the depth of the

161
00:06:43,169 --> 00:06:46,729
quantum queries and not just the number

162
00:06:45,090 --> 00:06:50,748
of

163
00:06:46,729 --> 00:06:52,818
so onward to one way to hiding so the

164
00:06:50,749 --> 00:06:55,999
classic version of this idea is very

165
00:06:52,819 --> 00:06:58,039
simple so if you're doing a proof by a

166
00:06:55,999 --> 00:06:59,719
series of games then you're you know

167
00:06:58,039 --> 00:07:02,419
sort of cheating the adversary a little

168
00:06:59,719 --> 00:07:04,099
bit more in each game step and one way

169
00:07:02,419 --> 00:07:05,869
that you might do that is by replacing

170
00:07:04,099 --> 00:07:07,580
you know the previous random Oracle with

171
00:07:05,869 --> 00:07:12,529
a slightly different possibly less

172
00:07:07,580 --> 00:07:14,959
random Oracle so if you have two

173
00:07:12,529 --> 00:07:16,639
Oracle's actually but they don't have to

174
00:07:14,959 --> 00:07:20,079
be random they can just be any any

175
00:07:16,639 --> 00:07:22,639
Oracle's classically that agree

176
00:07:20,079 --> 00:07:26,509
everywhere except on some like possibly

177
00:07:22,639 --> 00:07:28,279
small set s then an adversary can't tell

178
00:07:26,509 --> 00:07:31,879
them apart without querying an element

179
00:07:28,279 --> 00:07:33,709
of that set classically it's pretty

180
00:07:31,879 --> 00:07:36,829
obvious right because they they have the

181
00:07:33,709 --> 00:07:38,209
same everywhere else and so in

182
00:07:36,829 --> 00:07:41,929
particular if you have a simulator

183
00:07:38,209 --> 00:07:45,349
that's observing the Oracle queries then

184
00:07:41,929 --> 00:07:47,929
they can extract some X in that set if

185
00:07:45,349 --> 00:07:49,639
they can recognize it and the the

186
00:07:47,929 --> 00:07:52,998
adversaries probability of telling the

187
00:07:49,639 --> 00:07:54,259
two Oracle's apart is necessarily less

188
00:07:52,999 --> 00:07:57,619
than or equal to the probability that

189
00:07:54,259 --> 00:07:59,809
the simulator extracts an S and so this

190
00:07:57,619 --> 00:08:01,699
is how you'll do you know the simulator

191
00:07:59,809 --> 00:08:05,929
can't tell apart the encryption of two

192
00:08:01,699 --> 00:08:07,729
messages unless he can tell the the the

193
00:08:05,929 --> 00:08:09,558
syn sorry the adversary can't tell apart

194
00:08:07,729 --> 00:08:12,558
the encryption of two messages unless he

195
00:08:09,559 --> 00:08:14,719
can tell the simulator you know the RSA

196
00:08:12,559 --> 00:08:15,379
problem answer or whatever the discrete

197
00:08:14,719 --> 00:08:18,589
log of something

198
00:08:15,379 --> 00:08:21,979
CDH problem this is how you're gonna

199
00:08:18,589 --> 00:08:24,019
construct your your proofs in general of

200
00:08:21,979 --> 00:08:25,699
course it's also possible that the the

201
00:08:24,019 --> 00:08:28,339
simulator is not able to recognize

202
00:08:25,699 --> 00:08:31,969
elements of s like if it's a CDH problem

203
00:08:28,339 --> 00:08:34,750
for example and in that case at worst it

204
00:08:31,969 --> 00:08:39,289
can randomly choose one of those queries

205
00:08:34,750 --> 00:08:41,750
and guess that that was the element of s

206
00:08:39,289 --> 00:08:42,708
and then if the adversary is telling

207
00:08:41,750 --> 00:08:44,809
things apart with some probability

208
00:08:42,708 --> 00:08:49,550
that's less than the number of queries

209
00:08:44,809 --> 00:08:52,730
times the the probability that the

210
00:08:49,550 --> 00:08:54,559
simulator is extracting things so again

211
00:08:52,730 --> 00:08:56,630
while this talk is sort of nominally in

212
00:08:54,559 --> 00:08:58,579
the in the random Oracle model this is

213
00:08:56,630 --> 00:08:59,640
going to work with things that are not

214
00:08:58,579 --> 00:09:03,270
necessarily random

215
00:08:59,640 --> 00:09:05,280
Oracle's they can be Oracle's drawn from

216
00:09:03,270 --> 00:09:09,150
any any sort of arbitrary distribution

217
00:09:05,280 --> 00:09:10,350
they can be fixed Oracle's you know the

218
00:09:09,150 --> 00:09:11,850
adversary still can't tell them apart

219
00:09:10,350 --> 00:09:17,880
without querying the place where they

220
00:09:11,850 --> 00:09:19,410
differ so the quantum case is a little

221
00:09:17,880 --> 00:09:21,120
bit similar so this appeared in owner's

222
00:09:19,410 --> 00:09:26,010
work in 2015 but with a lot of

223
00:09:21,120 --> 00:09:27,870
restrictions so again if if two Oracle's

224
00:09:26,010 --> 00:09:29,460
are the same except on some set s the

225
00:09:27,870 --> 00:09:33,120
adversary can't tell them apart without

226
00:09:29,460 --> 00:09:35,340
querying that said but it might query a

227
00:09:33,120 --> 00:09:36,390
superposition of many inputs some of

228
00:09:35,340 --> 00:09:37,740
which are in the set and some of which

229
00:09:36,390 --> 00:09:39,330
are not and they might have you know

230
00:09:37,740 --> 00:09:41,910
certain amplitudes you know it's

231
00:09:39,330 --> 00:09:43,140
possibly small amplitudes on the set and

232
00:09:41,910 --> 00:09:46,890
that would give some chance of telling

233
00:09:43,140 --> 00:09:50,520
them apart and so on so the the one way

234
00:09:46,890 --> 00:09:52,350
to hiding theorem says that again this

235
00:09:50,520 --> 00:09:54,750
is assuming to start with it the

236
00:09:52,350 --> 00:09:58,500
simulator cannot recognize the elements

237
00:09:54,750 --> 00:10:01,020
of this set so it will randomly choose

238
00:09:58,500 --> 00:10:02,610
some query or since we're doing the this

239
00:10:01,020 --> 00:10:05,760
depth restricted model randomly choose a

240
00:10:02,610 --> 00:10:10,370
round of queries measure all the queries

241
00:10:05,760 --> 00:10:13,260
in that round and then output them and

242
00:10:10,370 --> 00:10:16,410
it's possible that one of these is in

243
00:10:13,260 --> 00:10:18,660
fact in this in this set and call that

244
00:10:16,410 --> 00:10:22,439
call that event guess so

245
00:10:18,660 --> 00:10:24,630
whereas before the probability was the

246
00:10:22,440 --> 00:10:28,110
distinguishing probability was at most Q

247
00:10:24,630 --> 00:10:30,960
times the guessing probability here it's

248
00:10:28,110 --> 00:10:32,970
at most two D times the square root of

249
00:10:30,960 --> 00:10:34,140
the guessing probability and this will

250
00:10:32,970 --> 00:10:38,190
end up actually sort of being more like

251
00:10:34,140 --> 00:10:40,410
two times rad QD guessing probability

252
00:10:38,190 --> 00:10:42,990
because this here we're outputting like

253
00:10:40,410 --> 00:10:45,469
multiple possible guesses and the

254
00:10:42,990 --> 00:10:49,560
previous one we were only outputting one

255
00:10:45,470 --> 00:10:51,630
another fact that that comes from the

256
00:10:49,560 --> 00:10:54,089
same theorem is that the difference of

257
00:10:51,630 --> 00:10:56,040
square roots of probabilities of of two

258
00:10:54,090 --> 00:10:57,630
events occurring not just the

259
00:10:56,040 --> 00:10:59,130
distinguishing probability this is also

260
00:10:57,630 --> 00:11:01,260
bounded by the same value and that's

261
00:10:59,130 --> 00:11:02,970
going to be true for the other theorems

262
00:11:01,260 --> 00:11:05,819
in this work as well because of the the

263
00:11:02,970 --> 00:11:07,980
structure of the proof and the the main

264
00:11:05,820 --> 00:11:09,420
point of this is that usually in these

265
00:11:07,980 --> 00:11:10,970
Oracle proofs at some point you cheat

266
00:11:09,420 --> 00:11:13,920
the adversary so hard that he can't win

267
00:11:10,970 --> 00:11:15,600
so if for example

268
00:11:13,920 --> 00:11:17,370
the adversary can't win here and this

269
00:11:15,600 --> 00:11:18,600
probability is zero then you can clear

270
00:11:17,370 --> 00:11:20,430
the square roots and you won't have this

271
00:11:18,600 --> 00:11:21,900
obnoxious square root whereas up here if

272
00:11:20,430 --> 00:11:26,449
you if you clear this then you still

273
00:11:21,900 --> 00:11:30,030
have a square root in the in the bound

274
00:11:26,450 --> 00:11:31,470
so this raises the question of like well

275
00:11:30,030 --> 00:11:35,839
what happens if the simulator can

276
00:11:31,470 --> 00:11:37,980
recognize the set being queried and so

277
00:11:35,840 --> 00:11:39,870
you could imagine well you just measure

278
00:11:37,980 --> 00:11:41,250
whether it's whether the input is in

279
00:11:39,870 --> 00:11:44,130
that set or not and that's that's what

280
00:11:41,250 --> 00:11:46,140
we do but you can't you can't do it

281
00:11:44,130 --> 00:11:48,720
exactly like that right so suppose you

282
00:11:46,140 --> 00:11:50,400
have some quantum algorithm that

283
00:11:48,720 --> 00:11:52,320
recognizes an element of the set the

284
00:11:50,400 --> 00:11:54,150
idea is that you take you get this

285
00:11:52,320 --> 00:11:56,340
quantum input X and then you run the

286
00:11:54,150 --> 00:11:59,699
recognizer on it and you measure only

287
00:11:56,340 --> 00:12:03,480
the output of the recognition function

288
00:11:59,700 --> 00:12:04,860
and not the element X and then that

289
00:12:03,480 --> 00:12:07,470
tells you whether it's in the set or not

290
00:12:04,860 --> 00:12:08,790
and probably once that you you've

291
00:12:07,470 --> 00:12:10,830
recognized that it is in the set then

292
00:12:08,790 --> 00:12:12,719
you're going to measure the X and output

293
00:12:10,830 --> 00:12:14,310
it but if it's not in the set if it's

294
00:12:12,720 --> 00:12:19,950
not the thing that the simulator is

295
00:12:14,310 --> 00:12:21,569
looking for then you just return you

296
00:12:19,950 --> 00:12:24,330
just return the output of the Oracle and

297
00:12:21,570 --> 00:12:26,160
continue on and so this this is what we

298
00:12:24,330 --> 00:12:27,690
call a punctured Oracle it's the the

299
00:12:26,160 --> 00:12:29,640
hash punctured by this set that you're

300
00:12:27,690 --> 00:12:32,610
recognizing and the the reason it's

301
00:12:29,640 --> 00:12:34,980
called punctured is that if as long as

302
00:12:32,610 --> 00:12:36,900
you're the adversary meit makes queries

303
00:12:34,980 --> 00:12:38,640
that are you know measured not to be in

304
00:12:36,900 --> 00:12:41,520
the set then his behavior doesn't depend

305
00:12:38,640 --> 00:12:43,650
on the value of the Oracle there so it

306
00:12:41,520 --> 00:12:46,920
sort of effectively removes those inputs

307
00:12:43,650 --> 00:12:50,370
from the domain of the random Oracle and

308
00:12:46,920 --> 00:12:56,069
it also follows interestingly that here

309
00:12:50,370 --> 00:12:58,980
we had you know a guess given be talking

310
00:12:56,070 --> 00:13:00,930
to H in this bound and it's since its

311
00:12:58,980 --> 00:13:02,880
symmetric it's obviously also true with

312
00:13:00,930 --> 00:13:05,609
be talking to G but those bounds are not

313
00:13:02,880 --> 00:13:07,770
actually the same it could be that you

314
00:13:05,610 --> 00:13:09,180
know in one case the the adversary finds

315
00:13:07,770 --> 00:13:10,560
a thing and then he keeps querying it

316
00:13:09,180 --> 00:13:13,140
over and over and over again so if you

317
00:13:10,560 --> 00:13:15,290
guess a random query to look at then

318
00:13:13,140 --> 00:13:17,939
he's then you're always going to get yes

319
00:13:15,290 --> 00:13:19,740
on the one side and on the other side he

320
00:13:17,940 --> 00:13:22,020
doesn't query it over and over again but

321
00:13:19,740 --> 00:13:27,540
here the the finding probability is

322
00:13:22,020 --> 00:13:28,980
actually the same on both sides so

323
00:13:27,540 --> 00:13:30,839
the main lemma that we have on this so

324
00:13:28,980 --> 00:13:32,280
that was that slide was just the the

325
00:13:30,840 --> 00:13:36,030
description right so the main lemma is

326
00:13:32,280 --> 00:13:40,800
that if you if you have these two sets

327
00:13:36,030 --> 00:13:42,870
then the bound now has D or rather D

328
00:13:40,800 --> 00:13:44,910
plus one inside the square root so

329
00:13:42,870 --> 00:13:48,030
before it was two d square root of p

330
00:13:44,910 --> 00:13:50,670
guess now it's two square root of d plus

331
00:13:48,030 --> 00:13:52,530
1 P find and you can actually this is

332
00:13:50,670 --> 00:13:56,120
not in the paper but it's not difficult

333
00:13:52,530 --> 00:13:58,890
to tighten this D plus 1 to a D in here

334
00:13:56,120 --> 00:14:03,510
but it not not in here this one is still

335
00:13:58,890 --> 00:14:08,660
D plus 1 actually also the the

336
00:14:03,510 --> 00:14:13,020
difference between a H and a H punctured

337
00:14:08,660 --> 00:14:15,660
is is bounded by this smaller term as

338
00:14:13,020 --> 00:14:18,750
our you know a H punctured and not find

339
00:14:15,660 --> 00:14:21,060
a G punctured a G puncture did not find

340
00:14:18,750 --> 00:14:22,410
some some fairly large number of things

341
00:14:21,060 --> 00:14:30,930
there really only differ in the case

342
00:14:22,410 --> 00:14:33,780
where you found an element of s and so

343
00:14:30,930 --> 00:14:35,250
what this is saying so up leveling a

344
00:14:33,780 --> 00:14:38,010
minute from the equations what this is

345
00:14:35,250 --> 00:14:41,520
saying is that measuring whether the

346
00:14:38,010 --> 00:14:45,360
adversaries queries are in this set will

347
00:14:41,520 --> 00:14:48,090
disturb the adversary state that's

348
00:14:45,360 --> 00:14:50,220
unavoidable because that's that's the

349
00:14:48,090 --> 00:14:52,140
observer effect in quantum mechanics but

350
00:14:50,220 --> 00:14:53,580
it only it only will disturb the

351
00:14:52,140 --> 00:14:54,990
adversary state by an amount that's

352
00:14:53,580 --> 00:14:56,670
proportional to the chance that he

353
00:14:54,990 --> 00:15:00,510
actually was querying an element of this

354
00:14:56,670 --> 00:15:02,010
set and therefore proportional to or the

355
00:15:00,510 --> 00:15:03,630
square root of that actually the but

356
00:15:02,010 --> 00:15:05,069
proportional to the square root of the

357
00:15:03,630 --> 00:15:06,030
chance that he was he was querying an

358
00:15:05,070 --> 00:15:07,650
element of the set and therefore

359
00:15:06,030 --> 00:15:09,030
proportional to the square root of the

360
00:15:07,650 --> 00:15:13,439
chance that you got your the answer that

361
00:15:09,030 --> 00:15:15,060
you were looking for if the adversary is

362
00:15:13,440 --> 00:15:18,170
not very good at finding elements of

363
00:15:15,060 --> 00:15:20,459
this set and querying them than

364
00:15:18,170 --> 00:15:21,900
measuring measuring the queries or

365
00:15:20,460 --> 00:15:25,710
measuring whether they're in the set

366
00:15:21,900 --> 00:15:27,500
doesn't change it very much so I don't

367
00:15:25,710 --> 00:15:29,430
want to go into the the proofs of these

368
00:15:27,500 --> 00:15:32,700
theorems they're not terribly difficult

369
00:15:29,430 --> 00:15:34,859
but the basic idea is that that they are

370
00:15:32,700 --> 00:15:37,290
based on the sort of geometry of quantum

371
00:15:34,860 --> 00:15:39,840
states that quantum states are like unit

372
00:15:37,290 --> 00:15:41,010
vectors in this high dimensional complex

373
00:15:39,840 --> 00:15:42,180
vector space

374
00:15:41,010 --> 00:15:44,819
basically you can think of them as just

375
00:15:42,180 --> 00:15:48,900
being like vectors right and so the idea

376
00:15:44,820 --> 00:15:51,480
is that you can bound the the

377
00:15:48,900 --> 00:15:53,300
probabilities of you know differences in

378
00:15:51,480 --> 00:15:57,570
probabilities of final measurements

379
00:15:53,300 --> 00:15:59,479
having having some like distinguishing

380
00:15:57,570 --> 00:16:04,080
probability or whatever based on the

381
00:15:59,480 --> 00:16:07,110
distance between those quantum states in

382
00:16:04,080 --> 00:16:09,540
a Euclidean measurement so like it's

383
00:16:07,110 --> 00:16:11,490
it's well known if you do quantum

384
00:16:09,540 --> 00:16:12,719
computation that that this thing is

385
00:16:11,490 --> 00:16:14,220
bounded by something called the trace

386
00:16:12,720 --> 00:16:17,090
distance in fact that's basically the

387
00:16:14,220 --> 00:16:19,950
definition of the trace distance and

388
00:16:17,090 --> 00:16:21,630
both that and this difference of square

389
00:16:19,950 --> 00:16:23,370
roots are bounded by another quantity

390
00:16:21,630 --> 00:16:26,460
called the boar's distance which is more

391
00:16:23,370 --> 00:16:27,900
complicated but is roughly the expected

392
00:16:26,460 --> 00:16:30,630
Euclidean distance between the two

393
00:16:27,900 --> 00:16:32,189
states or at least is bounded by that so

394
00:16:30,630 --> 00:16:33,900
that means that if you can prove

395
00:16:32,190 --> 00:16:36,330
something in geometry about how far

396
00:16:33,900 --> 00:16:38,100
apart these states are or how how far

397
00:16:36,330 --> 00:16:39,840
apart they can be for a given value of

398
00:16:38,100 --> 00:16:43,410
probability of find or probability of

399
00:16:39,840 --> 00:16:47,570
guess then you will get these bounds on

400
00:16:43,410 --> 00:16:50,850
the on the distinguishing probabilities

401
00:16:47,570 --> 00:16:52,290
so a final question that is actually

402
00:16:50,850 --> 00:16:55,830
pretty interesting to me

403
00:16:52,290 --> 00:16:58,680
but is an important detail in these

404
00:16:55,830 --> 00:17:00,600
proofs on using semi classical Oracle's

405
00:16:58,680 --> 00:17:02,250
is what what is the finding probability

406
00:17:00,600 --> 00:17:04,079
right so if you have a classical Oracle

407
00:17:02,250 --> 00:17:09,119
takes classical input gives classical

408
00:17:04,079 --> 00:17:10,649
output and you have a criterion that

409
00:17:09,119 --> 00:17:13,889
holds with probability epsilon

410
00:17:10,650 --> 00:17:15,089
everywhere then and the in the adversary

411
00:17:13,890 --> 00:17:16,470
has no other information about where to

412
00:17:15,089 --> 00:17:18,569
find it

413
00:17:16,470 --> 00:17:20,459
then the finding probability is

414
00:17:18,569 --> 00:17:22,139
necessarily less than Q epsilon that's

415
00:17:20,459 --> 00:17:23,640
less than the number of queries he makes

416
00:17:22,140 --> 00:17:26,610
times the probability that I name one of

417
00:17:23,640 --> 00:17:30,180
them succeeds but if the the Oracle

418
00:17:26,609 --> 00:17:34,139
gives quantum output then it could be up

419
00:17:30,180 --> 00:17:38,040
to Q squared epsilon or I guess DQ

420
00:17:34,140 --> 00:17:39,300
Epsilon as we'll see later but and that

421
00:17:38,040 --> 00:17:41,000
that's because of Grover's algorithm

422
00:17:39,300 --> 00:17:43,440
right Grover's algorithm lets you get a

423
00:17:41,000 --> 00:17:48,720
quadratic or almost quadratic speed-up

424
00:17:43,440 --> 00:17:52,730
on on searching for some you know rare

425
00:17:48,720 --> 00:17:55,190
property in an unstructured function but

426
00:17:52,730 --> 00:17:58,310
in this case you have a situation where

427
00:17:55,190 --> 00:18:00,980
the adversary makes a quantum query and

428
00:17:58,310 --> 00:18:04,040
he gets a classical output right is this

429
00:18:00,980 --> 00:18:05,840
in the set or not and so it's not clear

430
00:18:04,040 --> 00:18:07,250
intuitively whether this is more like

431
00:18:05,840 --> 00:18:09,050
the classical case or more like the

432
00:18:07,250 --> 00:18:10,760
quantum case it turns out to be more

433
00:18:09,050 --> 00:18:13,370
like the the classical case so it turns

434
00:18:10,760 --> 00:18:15,220
out that this can speed up over the the

435
00:18:13,370 --> 00:18:17,929
classical case by a factor of

436
00:18:15,220 --> 00:18:20,030
asymptotically exactly four so there's

437
00:18:17,930 --> 00:18:21,620
some algorithm that will search at least

438
00:18:20,030 --> 00:18:25,820
in some cases of you know unstructured

439
00:18:21,620 --> 00:18:27,739
function for a value satisfying a

440
00:18:25,820 --> 00:18:29,659
predicate with a semi-classical Oracle

441
00:18:27,740 --> 00:18:34,010
for it that's four times faster than the

442
00:18:29,660 --> 00:18:35,870
classical case but not more than that so

443
00:18:34,010 --> 00:18:37,670
a result of this is that actually the

444
00:18:35,870 --> 00:18:40,580
the fully quantum case of one way to

445
00:18:37,670 --> 00:18:43,100
hiding can be factored into this search

446
00:18:40,580 --> 00:18:45,800
theorem plus the the semi classical case

447
00:18:43,100 --> 00:18:48,260
with a loss of about two and the bound

448
00:18:45,800 --> 00:18:51,169
but it's interesting to note that SM

449
00:18:48,260 --> 00:18:55,370
tonically at least it follows from the

450
00:18:51,170 --> 00:18:57,140
the other two theorems in the paper so

451
00:18:55,370 --> 00:18:59,810
as a summary of these various one way to

452
00:18:57,140 --> 00:19:02,330
hiding met methods like imagine you're

453
00:18:59,810 --> 00:19:03,770
trying to distinguish the adversary is

454
00:19:02,330 --> 00:19:05,899
trying to distinguish two Oracle's he

455
00:19:03,770 --> 00:19:07,970
does it with probability Delta and the

456
00:19:05,900 --> 00:19:09,650
the simulator is trying to extract a

457
00:19:07,970 --> 00:19:11,900
value of the set where they differ and

458
00:19:09,650 --> 00:19:13,400
and does it with probability epsilon

459
00:19:11,900 --> 00:19:15,260
then we have these these various bounds

460
00:19:13,400 --> 00:19:16,820
so in the classic case you know if you

461
00:19:15,260 --> 00:19:18,920
can recognize it then you get Delta is

462
00:19:16,820 --> 00:19:22,939
less than Epsilon and if you can't you

463
00:19:18,920 --> 00:19:26,900
get Delta is less than Q epsilon in the

464
00:19:22,940 --> 00:19:29,660
the quantum case we've improved une ruse

465
00:19:26,900 --> 00:19:33,140
bound from to Q R at epsilon to

466
00:19:29,660 --> 00:19:35,870
something like to read DQ Epsilon but I

467
00:19:33,140 --> 00:19:38,750
guess we'll get to that in a minute but

468
00:19:35,870 --> 00:19:41,020
the the difference is that the bigger

469
00:19:38,750 --> 00:19:44,060
difference is that instead of having to

470
00:19:41,020 --> 00:19:46,580
be uniformly random Oracle's that differ

471
00:19:44,060 --> 00:19:49,730
in one uniformly random place now they

472
00:19:46,580 --> 00:19:51,409
can be arbitrary Oracle's possibly

473
00:19:49,730 --> 00:19:55,340
jointly distributed in some complicated

474
00:19:51,410 --> 00:19:57,620
way that differ in some arbitrary set of

475
00:19:55,340 --> 00:19:59,780
places so we've removed a lot of

476
00:19:57,620 --> 00:20:01,639
restrictions on that additionally if the

477
00:19:59,780 --> 00:20:03,840
simulator can recognize the set that

478
00:20:01,640 --> 00:20:06,820
you're looking for then

479
00:20:03,840 --> 00:20:10,600
it improves to D plus one inside the

480
00:20:06,820 --> 00:20:13,720
square root and then is it interesting

481
00:20:10,600 --> 00:20:16,090
corollary this was proved after after

482
00:20:13,720 --> 00:20:19,480
this work but it's based on chandri's

483
00:20:16,090 --> 00:20:21,639
talk you can use this or Oracle

484
00:20:19,480 --> 00:20:23,350
recording technique to if if the

485
00:20:21,640 --> 00:20:25,420
simulator can simulate both of the

486
00:20:23,350 --> 00:20:27,310
Oracles like for example if they differ

487
00:20:25,420 --> 00:20:29,830
only at the preimage of some function

488
00:20:27,310 --> 00:20:31,120
and the the simulator knows the function

489
00:20:29,830 --> 00:20:31,990
but they don't know and they know the

490
00:20:31,120 --> 00:20:36,820
difference but they don't know the

491
00:20:31,990 --> 00:20:38,080
preimage then then you can get a bound

492
00:20:36,820 --> 00:20:41,080
that doesn't depend on the number of

493
00:20:38,080 --> 00:20:42,490
queries the adversary makes so that's

494
00:20:41,080 --> 00:20:43,810
kind of nice but they have to there's a

495
00:20:42,490 --> 00:20:46,530
still a restriction on that they have to

496
00:20:43,810 --> 00:20:46,530
differ in only one place

497
00:20:47,010 --> 00:20:55,420
so finally time check okay let's get to

498
00:20:53,320 --> 00:20:56,439
a couple of applications I guess I

499
00:20:55,420 --> 00:21:00,430
probably won't get to all of them with

500
00:20:56,440 --> 00:21:02,170
four minutes of these techniques so the

501
00:21:00,430 --> 00:21:05,410
the simple one is let's reprove bounds

502
00:21:02,170 --> 00:21:06,580
on Grover's algorithm so suppose that

503
00:21:05,410 --> 00:21:07,930
you have a function that you're

504
00:21:06,580 --> 00:21:09,929
searching for it's got some property

505
00:21:07,930 --> 00:21:12,760
with probability Epsilon at every point

506
00:21:09,930 --> 00:21:14,380
and let's compare this to with to a

507
00:21:12,760 --> 00:21:18,250
function that doesn't have that property

508
00:21:14,380 --> 00:21:20,440
anywhere so H is zero everywhere so

509
00:21:18,250 --> 00:21:23,470
these differ at the set s which is

510
00:21:20,440 --> 00:21:25,660
exactly where you know G of X is one and

511
00:21:23,470 --> 00:21:28,750
the adversary wants to output an element

512
00:21:25,660 --> 00:21:30,280
of that set or just to simplify the

513
00:21:28,750 --> 00:21:32,110
analysis you might say that you want

514
00:21:30,280 --> 00:21:33,520
that if you take the adversary and then

515
00:21:32,110 --> 00:21:37,540
you run G afterwards which you could

516
00:21:33,520 --> 00:21:39,760
call a a sub 1 of G then you get 1 and

517
00:21:37,540 --> 00:21:42,460
so the one way to hiding theorem tells

518
00:21:39,760 --> 00:21:44,379
us that the square root of the

519
00:21:42,460 --> 00:21:46,840
probability that that happens minus the

520
00:21:44,380 --> 00:21:49,360
probability to happens for H is bounded

521
00:21:46,840 --> 00:21:51,159
by the guessing probability but in fact

522
00:21:49,360 --> 00:21:53,379
it can't happen for H because H is 0

523
00:21:51,160 --> 00:21:55,720
everywhere it doesn't have that property

524
00:21:53,380 --> 00:21:57,600
anywhere and also H has no information

525
00:21:55,720 --> 00:22:00,480
about this set because it's 0 everywhere

526
00:21:57,600 --> 00:22:02,800
so the guessing probability is at most

527
00:22:00,480 --> 00:22:05,020
like the number of queries although we

528
00:22:02,800 --> 00:22:07,990
edit a query here and a depth the number

529
00:22:05,020 --> 00:22:09,160
of queries over the depth because that's

530
00:22:07,990 --> 00:22:12,310
the average number of queries the

531
00:22:09,160 --> 00:22:14,920
adversary is making every round and so

532
00:22:12,310 --> 00:22:16,629
when you plug that into this this

533
00:22:14,920 --> 00:22:17,539
equation above and remove the square

534
00:22:16,630 --> 00:22:20,629
roots

535
00:22:17,539 --> 00:22:22,729
you get the the probability that you

536
00:22:20,629 --> 00:22:25,279
find an element with this property in

537
00:22:22,729 --> 00:22:29,179
the sparse random function is in most 4

538
00:22:25,279 --> 00:22:30,710
D plus 1 Q plus 1 epsilon so in other

539
00:22:29,179 --> 00:22:32,539
words and I think this was well known

540
00:22:30,710 --> 00:22:35,809
before but it's it's bounded by the

541
00:22:32,539 --> 00:22:37,700
depth of the the adversaries computation

542
00:22:35,809 --> 00:22:41,658
times the number of queries he can make

543
00:22:37,700 --> 00:22:43,100
not just by the number of queries

544
00:22:41,659 --> 00:22:45,739
squared for example so it doesn't

545
00:22:43,100 --> 00:22:50,029
parallelized very well

546
00:22:45,739 --> 00:22:51,950
another simple application maybe I'll

547
00:22:50,029 --> 00:22:54,559
skim over this is that if you have a

548
00:22:51,950 --> 00:22:57,049
function f K of X which is H of K comma

549
00:22:54,559 --> 00:22:58,789
X where H is a random Oracle then this

550
00:22:57,049 --> 00:23:00,979
is a pseudo-random function so this is

551
00:22:58,789 --> 00:23:04,070
fairly obvious in the in the classical

552
00:23:00,979 --> 00:23:06,470
world and in the quantum world indeed

553
00:23:04,070 --> 00:23:09,200
you can get the PRF advantage is sort of

554
00:23:06,470 --> 00:23:10,970
less than then this bound and this bound

555
00:23:09,200 --> 00:23:15,139
is also very similar to the cost of a

556
00:23:10,970 --> 00:23:16,519
grover attack on on the the seed of this

557
00:23:15,139 --> 00:23:17,748
pseudo-random function or the key of

558
00:23:16,519 --> 00:23:19,759
this pseudo-random function so it's

559
00:23:17,749 --> 00:23:21,679
about what you would expect and this

560
00:23:19,759 --> 00:23:23,720
comes just sort of straight from the one

561
00:23:21,679 --> 00:23:26,509
way to hiding lemma so then I want to

562
00:23:23,720 --> 00:23:27,950
mention also briefly the the Fujisaki

563
00:23:26,509 --> 00:23:31,159
Okamoto proof which is slightly more

564
00:23:27,950 --> 00:23:33,859
involved but the basic idea is so

565
00:23:31,159 --> 00:23:35,509
suppose that you have a an NCP a secure

566
00:23:33,859 --> 00:23:37,220
public key encryption algorithm that's

567
00:23:35,509 --> 00:23:39,229
randomized so it takes an input of coins

568
00:23:37,220 --> 00:23:40,999
and you want to dear an demise it

569
00:23:39,229 --> 00:23:43,549
because you need to use it in Fujisaki

570
00:23:40,999 --> 00:23:44,929
Okamoto or whatever and so you'll set

571
00:23:43,549 --> 00:23:47,599
the coins equal to the hash of the

572
00:23:44,929 --> 00:23:49,879
message and since it's in CPA secure

573
00:23:47,599 --> 00:23:51,529
it's hard if you have two messages and a

574
00:23:49,879 --> 00:23:53,269
challenge that's the encryption of one

575
00:23:51,529 --> 00:23:54,529
of them with some unknown coins to

576
00:23:53,269 --> 00:23:57,379
figure out which which one of these

577
00:23:54,529 --> 00:24:01,099
messages it is and so the the proof

578
00:23:57,379 --> 00:24:02,988
technique is that you can you have your

579
00:24:01,099 --> 00:24:05,210
hash H and you can also define a hash G

580
00:24:02,989 --> 00:24:07,099
that is you know a variant of H that

581
00:24:05,210 --> 00:24:09,169
actually returns those coins but you

582
00:24:07,099 --> 00:24:10,729
don't know what they are when the when

583
00:24:09,169 --> 00:24:13,940
the adversary queries the right message

584
00:24:10,729 --> 00:24:15,200
so you can't simulate this Oracle but

585
00:24:13,940 --> 00:24:17,690
you do know where it differs from the

586
00:24:15,200 --> 00:24:19,580
Oracle H it differs it like at most m0

587
00:24:17,690 --> 00:24:21,950
and m1 actually only one of those but

588
00:24:19,580 --> 00:24:23,869
you don't know which one and so if you

589
00:24:21,950 --> 00:24:27,350
plug this into the the semi-classical

590
00:24:23,869 --> 00:24:30,199
one way to hiding lemma you get that the

591
00:24:27,350 --> 00:24:36,740
one way advantage the square root of it

592
00:24:30,200 --> 00:24:38,870
- the chance that you that it returns em

593
00:24:36,740 --> 00:24:41,020
and doesn't find you know in a punctured

594
00:24:38,870 --> 00:24:45,669
version which you can arrange to be zero

595
00:24:41,020 --> 00:24:48,110
is bounded by this finding probability

596
00:24:45,670 --> 00:24:49,910
which expands out to the one way

597
00:24:48,110 --> 00:24:51,860
advantage is less than D plus 2 times

598
00:24:49,910 --> 00:24:54,380
the finding probability and this is the

599
00:24:51,860 --> 00:24:56,750
probability that that the sort of fine

600
00:24:54,380 --> 00:24:59,510
thing either measures M 0 or it measures

601
00:24:56,750 --> 00:25:02,270
M 1 and so this is the distinguisher on

602
00:24:59,510 --> 00:25:03,650
the classical I mean there's a quantum

603
00:25:02,270 --> 00:25:06,980
computer but it returns a classical

604
00:25:03,650 --> 00:25:10,280
result a distinguisher on on this n CPA

605
00:25:06,980 --> 00:25:12,140
secure encryption system because it

606
00:25:10,280 --> 00:25:13,190
returns either m0 or m1 but the

607
00:25:12,140 --> 00:25:14,450
adversary doesn't actually have any

608
00:25:13,190 --> 00:25:18,440
information about the one that wasn't

609
00:25:14,450 --> 00:25:20,600
the encryption that you got and so that

610
00:25:18,440 --> 00:25:22,250
means that on the by the search theorem

611
00:25:20,600 --> 00:25:26,090
there's a small chance that he finds it

612
00:25:22,250 --> 00:25:27,650
and on the there's the chance that he

613
00:25:26,090 --> 00:25:30,980
finds the other one is bounded by that

614
00:25:27,650 --> 00:25:33,320
plus the the ended Vantage because it's

615
00:25:30,980 --> 00:25:35,930
a distinguisher against the against the

616
00:25:33,320 --> 00:25:38,750
the randomized encryption scheme and so

617
00:25:35,930 --> 00:25:40,370
in sum he has this limited advantage

618
00:25:38,750 --> 00:25:41,690
that's like d plus 2 times the end

619
00:25:40,370 --> 00:25:43,360
advantage so that's not good that's not

620
00:25:41,690 --> 00:25:46,520
hopefully not tight but we don't know

621
00:25:43,360 --> 00:25:48,469
Plus this term which is actually just a

622
00:25:46,520 --> 00:25:50,780
grover attacked on the the message which

623
00:25:48,470 --> 00:25:54,410
is what you would expect times two or

624
00:25:50,780 --> 00:25:56,780
something so anyway so this is a this is

625
00:25:54,410 --> 00:25:59,540
a useful technique it's been used

626
00:25:56,780 --> 00:26:02,750
already in a few papers doing mostly

627
00:25:59,540 --> 00:26:04,129
Fujisaki Okamoto kind of stuff and i

628
00:26:02,750 --> 00:26:05,990
hope that we can sort of simplify it

629
00:26:04,130 --> 00:26:08,420
further and like synthesize this with

630
00:26:05,990 --> 00:26:10,790
the other techniques that we have like

631
00:26:08,420 --> 00:26:11,990
recording Oracle queries so that they

632
00:26:10,790 --> 00:26:17,320
can be sort of more accessible and

633
00:26:11,990 --> 00:26:17,320
easier to use so that's all

634
00:26:23,680 --> 00:26:29,140
you don't have time for questions but

635
00:26:25,730 --> 00:26:29,140
Mike will be around us

