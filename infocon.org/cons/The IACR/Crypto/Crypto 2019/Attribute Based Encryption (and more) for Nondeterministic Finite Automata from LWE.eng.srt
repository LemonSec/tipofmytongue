1
00:00:05,070 --> 00:00:13,219
you so hello all I'll talk about

2
00:00:11,430 --> 00:00:15,450
attribute based encryption and it's

3
00:00:13,219 --> 00:00:17,279
generalizations for non-deterministic

4
00:00:15,450 --> 00:00:20,070
finite automata from the learning with

5
00:00:17,279 --> 00:00:22,649
errors assumption it's a joint work with

6
00:00:20,070 --> 00:00:24,329
photographer and shota Yamada and this

7
00:00:22,649 --> 00:00:28,140
got initiated well why shota was

8
00:00:24,329 --> 00:00:30,059
visiting ID Madras back last year so

9
00:00:28,140 --> 00:00:31,919
let's start with the notion of attribute

10
00:00:30,059 --> 00:00:35,960
based encryption introduced by SIA and

11
00:00:31,919 --> 00:00:37,830
waters in 2005 where it's a

12
00:00:35,960 --> 00:00:39,840
generalization of public key encryption

13
00:00:37,830 --> 00:00:41,370
and where the goal is really to provide

14
00:00:39,840 --> 00:00:43,650
an expressive access control over

15
00:00:41,370 --> 00:00:46,199
encrypted data we have seen this from

16
00:00:43,650 --> 00:00:49,339
this morning so the setting is like this

17
00:00:46,200 --> 00:00:52,260
that let's say we have a server where we

18
00:00:49,340 --> 00:00:54,360
store encrypted files these files are

19
00:00:52,260 --> 00:00:56,519
encrypted with respect to public user

20
00:00:54,360 --> 00:00:58,829
attributes and accordingly there should

21
00:00:56,520 --> 00:01:01,410
be a key Authority which should be able

22
00:00:58,829 --> 00:01:03,300
to generate restricted secret keys these

23
00:01:01,410 --> 00:01:05,429
restrictions come in terms of policies

24
00:01:03,300 --> 00:01:08,850
or boolean functions embedded inside the

25
00:01:05,430 --> 00:01:10,350
security keys in such a way that these

26
00:01:08,850 --> 00:01:11,990
keys would be able to decrypt any of

27
00:01:10,350 --> 00:01:14,550
these ciphertexts

28
00:01:11,990 --> 00:01:15,630
if and only if the attributes with

29
00:01:14,550 --> 00:01:17,780
respect to which the files were

30
00:01:15,630 --> 00:01:20,820
encrypted satisfy the embedded policies

31
00:01:17,780 --> 00:01:22,920
further we want to also ensure that any

32
00:01:20,820 --> 00:01:25,889
set of colluding users should not be

33
00:01:22,920 --> 00:01:28,290
able to decrypt any of these files as

34
00:01:25,890 --> 00:01:29,850
long as at least one of these users are

35
00:01:28,290 --> 00:01:33,510
not individually authorized to decrypt

36
00:01:29,850 --> 00:01:35,669
them so this is actually formalized by

37
00:01:33,510 --> 00:01:37,950
the following set of 4 algorithms can

38
00:01:35,670 --> 00:01:39,330
set up encrypt keygen and decrypt so it

39
00:01:37,950 --> 00:01:40,950
takes the second the setup takes the

40
00:01:39,330 --> 00:01:43,080
security parameter and our outputs a

41
00:01:40,950 --> 00:01:45,000
public key and a master secret key the

42
00:01:43,080 --> 00:01:47,548
encryption takes the public key and an

43
00:01:45,000 --> 00:01:49,049
attribute X and of message M to output

44
00:01:47,549 --> 00:01:52,380
the cipher text encoding the message

45
00:01:49,049 --> 00:01:54,210
with respect to the attribute X the key

46
00:01:52,380 --> 00:01:57,210
generation algorithm takes the master

47
00:01:54,210 --> 00:01:58,350
secret key and a circuit F to output the

48
00:01:57,210 --> 00:02:00,809
secret key corresponding to this

49
00:01:58,350 --> 00:02:02,158
functionality and the secret key when it

50
00:02:00,810 --> 00:02:04,860
acts upon the cipher text to the

51
00:02:02,159 --> 00:02:07,530
decryption box it outputs the hidden

52
00:02:04,860 --> 00:02:09,239
payload M if the attribute if and only

53
00:02:07,530 --> 00:02:11,790
if the attribute satisfies the function

54
00:02:09,239 --> 00:02:14,579
and security goes like this for any

55
00:02:11,790 --> 00:02:16,888
couple of a challenge attribute and a

56
00:02:14,579 --> 00:02:18,870
pair of messages m0 m1 and all the

57
00:02:16,889 --> 00:02:21,599
secret keys for functionalities FC

58
00:02:18,870 --> 00:02:23,849
by the adversary their cipher takes the

59
00:02:21,599 --> 00:02:25,980
pair of the ciphertext for these pair of

60
00:02:23,849 --> 00:02:27,200
messages m0 and m1 with respect to the

61
00:02:25,980 --> 00:02:29,069
attribute X should remain

62
00:02:27,200 --> 00:02:30,810
computationally indistinguishable as

63
00:02:29,069 --> 00:02:33,119
long as these secret keys are

64
00:02:30,810 --> 00:02:36,930
individually unable to decrypt any of

65
00:02:33,120 --> 00:02:39,780
these ciphertext cipher texts so this

66
00:02:36,930 --> 00:02:42,379
notion of attribute based encryption has

67
00:02:39,780 --> 00:02:45,930
seen an elegant sequence of works from

68
00:02:42,379 --> 00:02:47,819
2005 onward with restricted

69
00:02:45,930 --> 00:02:51,629
I mean constructions for restricted

70
00:02:47,819 --> 00:02:53,608
circuit classes till in 2013 mode one of

71
00:02:51,629 --> 00:02:55,828
it all first showed how to support all

72
00:02:53,609 --> 00:02:59,310
circuits from the learning with errors

73
00:02:55,829 --> 00:03:01,109
assumption now even if learning a B for

74
00:02:59,310 --> 00:03:03,420
all circuits was realized and circuits

75
00:03:01,109 --> 00:03:05,819
are a powerful model of computation they

76
00:03:03,420 --> 00:03:08,250
have their own inherent drawbacks namely

77
00:03:05,819 --> 00:03:09,659
they have I mean sockets always provide

78
00:03:08,250 --> 00:03:11,340
fixed length input support and their

79
00:03:09,659 --> 00:03:14,010
description changes based on input

80
00:03:11,340 --> 00:03:17,220
lengths they also incur worst-case

81
00:03:14,010 --> 00:03:19,170
runtime based on all inputs of certain

82
00:03:17,220 --> 00:03:21,390
lengths so naturally our attention turns

83
00:03:19,170 --> 00:03:23,190
towards uniform models of computation

84
00:03:21,390 --> 00:03:25,380
like at finite automata or Turing

85
00:03:23,190 --> 00:03:26,880
machine or Ram where we have arbitrary

86
00:03:25,380 --> 00:03:29,099
length input support with a fixed

87
00:03:26,880 --> 00:03:30,530
description size which also incur input

88
00:03:29,099 --> 00:03:34,138
specific run times

89
00:03:30,530 --> 00:03:36,750
moreover we if we have an a/b support

90
00:03:34,139 --> 00:03:39,000
for I mean a B for supporting a uniform

91
00:03:36,750 --> 00:03:40,889
model of computation then that gives us

92
00:03:39,000 --> 00:03:42,709
the flexibility of giving out a single

93
00:03:40,889 --> 00:03:45,870
key power functionality because the

94
00:03:42,709 --> 00:03:49,290
description doesn't change now based on

95
00:03:45,870 --> 00:03:51,030
the input length so the question is now

96
00:03:49,290 --> 00:03:53,040
that what do we know so far about a B

97
00:03:51,030 --> 00:03:59,129
for uniform models from standard

98
00:03:53,040 --> 00:04:01,319
assumptions so as we talk so as we saw

99
00:03:59,129 --> 00:04:03,120
in the last talk the construction the

100
00:04:01,319 --> 00:04:06,030
first construction probably why was

101
00:04:03,120 --> 00:04:07,829
given by Brent it was for a B for DFA

102
00:04:06,030 --> 00:04:09,629
with unbounded attribute lengths and

103
00:04:07,829 --> 00:04:10,260
unbounded number of keys from the q type

104
00:04:09,629 --> 00:04:11,989
assumption

105
00:04:10,260 --> 00:04:16,019
it's a parameterised assumption

106
00:04:11,989 --> 00:04:19,168
subsequently in 2017 Agrawal and seeing

107
00:04:16,019 --> 00:04:21,449
gave a construction supporting I mean

108
00:04:19,168 --> 00:04:23,969
for the same primitive with unbounded

109
00:04:21,449 --> 00:04:27,780
attribute length support from the lwe

110
00:04:23,970 --> 00:04:31,770
assumption but restricted to the single

111
00:04:27,780 --> 00:04:34,530
key setting so and concurrently just

112
00:04:31,770 --> 00:04:36,030
now we saw the the work by Gong it all

113
00:04:34,530 --> 00:04:37,679
it constructs the same primitive from

114
00:04:36,030 --> 00:04:40,229
the standard K linear assumption static

115
00:04:37,680 --> 00:04:43,320
assumption with unbounded input length

116
00:04:40,230 --> 00:04:46,560
and unbounded number of keys in this

117
00:04:43,320 --> 00:04:49,290
context our work constructs a B for

118
00:04:46,560 --> 00:04:51,510
non-deterministic finite automata with

119
00:04:49,290 --> 00:04:54,480
unbounded number of keys and unbounded

120
00:04:51,510 --> 00:04:56,820
length attributes from the learning with

121
00:04:54,480 --> 00:05:00,450
our assumption our construction works in

122
00:04:56,820 --> 00:05:04,530
the symmetric key setting but I mean for

123
00:05:00,450 --> 00:05:06,450
all these years after from 2012 there

124
00:05:04,530 --> 00:05:08,669
was no progress on how to support

125
00:05:06,450 --> 00:05:10,320
non-deterministic finite automata and it

126
00:05:08,670 --> 00:05:15,180
was explicitly left as an open problem

127
00:05:10,320 --> 00:05:20,550
by Brent in 2012 so we construct it for

128
00:05:15,180 --> 00:05:23,190
the first time and we also additionally

129
00:05:20,550 --> 00:05:24,690
leverage our techniques to generalize it

130
00:05:23,190 --> 00:05:26,370
to predicate encryption bounded key

131
00:05:24,690 --> 00:05:29,550
functional encryption and usable

132
00:05:26,370 --> 00:05:32,490
garbling for NFS from lwe additionally

133
00:05:29,550 --> 00:05:36,150
we show a barrier in obtaining fully

134
00:05:32,490 --> 00:05:39,660
collision resistant Fe for DFS in that

135
00:05:36,150 --> 00:05:43,440
in the in the sense that it implies it

136
00:05:39,660 --> 00:05:45,360
IO from standard assumption so it's it

137
00:05:43,440 --> 00:05:51,030
highlights a barrier in obtaining fully

138
00:05:45,360 --> 00:05:53,820
collision resistant DFA Fe so we also

139
00:05:51,030 --> 00:05:56,969
have a concurrent work with Gong at all

140
00:05:53,820 --> 00:05:58,380
and subsequent to our work also I'm

141
00:05:56,970 --> 00:06:00,150
taking the techniques from our work

142
00:05:58,380 --> 00:06:03,360
which constructs the same primitive for

143
00:06:00,150 --> 00:06:05,070
DFA based on the same assumption but we

144
00:06:03,360 --> 00:06:08,340
have very different techniques while

145
00:06:05,070 --> 00:06:11,520
gong at all achieves key policy ABV our

146
00:06:08,340 --> 00:06:14,429
techniques are generic and run in a

147
00:06:11,520 --> 00:06:16,500
modular fashion which which allows us to

148
00:06:14,430 --> 00:06:21,260
get both ciphertext and key policy a b

149
00:06:16,500 --> 00:06:26,820
and this will appear in TCC this year so

150
00:06:21,260 --> 00:06:28,260
in context of the current talk i want to

151
00:06:26,820 --> 00:06:30,150
highlight this fact that our

152
00:06:28,260 --> 00:06:32,760
construction doesn't only support NFA

153
00:06:30,150 --> 00:06:34,530
but it also supports this generalized

154
00:06:32,760 --> 00:06:38,190
class of uniform circuits with bounded

155
00:06:34,530 --> 00:06:41,219
depth actually so NFS are a particular

156
00:06:38,190 --> 00:06:42,810
instantiation of this class and we can I

157
00:06:41,220 --> 00:06:45,930
mean NFS are more practically relevant

158
00:06:42,810 --> 00:06:49,830
actually so we will restrict our

159
00:06:45,930 --> 00:06:52,590
to NFS only for this stock so let's look

160
00:06:49,830 --> 00:06:55,229
at the techniques to construct this

161
00:06:52,590 --> 00:06:57,479
primitive let us look at how do we model

162
00:06:55,229 --> 00:07:00,210
this secret key a B for nfa it's done in

163
00:06:57,479 --> 00:07:01,590
the same way just that only there will

164
00:07:00,210 --> 00:07:03,030
be only a master secret key which will

165
00:07:01,590 --> 00:07:05,130
be used for both key generation and

166
00:07:03,030 --> 00:07:07,109
encryption the main differences are that

167
00:07:05,130 --> 00:07:09,120
the attribute length will be of an

168
00:07:07,110 --> 00:07:12,090
unbounded attribute will be an unbounded

169
00:07:09,120 --> 00:07:14,160
polynomial length and the key generation

170
00:07:12,090 --> 00:07:16,500
takes the NFA description as an input

171
00:07:14,160 --> 00:07:18,810
more importantly the key generator

172
00:07:16,500 --> 00:07:21,330
doesn't know the input length now and it

173
00:07:18,810 --> 00:07:22,770
has still - still output a secret key

174
00:07:21,330 --> 00:07:26,039
which should work with arbitrary input

175
00:07:22,770 --> 00:07:27,840
lengths security is modeled in the same

176
00:07:26,039 --> 00:07:30,030
way as before so let's look at how do we

177
00:07:27,840 --> 00:07:32,130
construct it we have a two step solution

178
00:07:30,030 --> 00:07:33,510
to construct this pivot of the first

179
00:07:32,130 --> 00:07:35,270
step consists of constructing this

180
00:07:33,510 --> 00:07:38,250
yellow box yellow and the red boxes

181
00:07:35,270 --> 00:07:40,770
where we have an a B for NFS scheme with

182
00:07:38,250 --> 00:07:43,320
unbounded attribute length and width

183
00:07:40,770 --> 00:07:45,870
bounded size NFS and the red box

184
00:07:43,320 --> 00:07:47,550
constructs a B for NFA with bounded

185
00:07:45,870 --> 00:07:51,030
attribute lengths and unbounded size

186
00:07:47,550 --> 00:07:53,310
interface and in step two we have a way

187
00:07:51,030 --> 00:07:54,929
to combine them to get both unbound

188
00:07:53,310 --> 00:07:56,970
unbounded in both these coordinates as

189
00:07:54,930 --> 00:08:00,539
in unbounded attributes and unbounded

190
00:07:56,970 --> 00:08:02,580
NFA machines so let's for ease of speech

191
00:08:00,539 --> 00:08:05,130
I will refer to this yellow box su comma

192
00:08:02,580 --> 00:08:08,520
B the other one has B comma U and the

193
00:08:05,130 --> 00:08:10,229
green one is you just you so let us look

194
00:08:08,520 --> 00:08:13,409
at how to construct this u comma B

195
00:08:10,229 --> 00:08:15,449
primitive so since we are working in the

196
00:08:13,409 --> 00:08:20,219
symmetric setting let us take the master

197
00:08:15,449 --> 00:08:21,960
secret he has a PRF key for now so the

198
00:08:20,220 --> 00:08:24,060
naive idea to construct such a primitive

199
00:08:21,960 --> 00:08:25,680
will be you just take an NFA and convert

200
00:08:24,060 --> 00:08:28,199
it into a circuit and employ an a/b for

201
00:08:25,680 --> 00:08:31,440
circuits scheme since we know how to

202
00:08:28,199 --> 00:08:32,940
construct them but the thing is that key

203
00:08:31,440 --> 00:08:34,708
generator doesn't know the input length

204
00:08:32,940 --> 00:08:36,990
and therefore it cannot just convert it

205
00:08:34,708 --> 00:08:39,510
into a circuit so at this point we note

206
00:08:36,990 --> 00:08:42,510
that the attribute length which is as

207
00:08:39,510 --> 00:08:44,490
which has unbounded polynomial length is

208
00:08:42,510 --> 00:08:47,100
upper bounded by two power lambda where

209
00:08:44,490 --> 00:08:49,050
lambda is the security parameter now

210
00:08:47,100 --> 00:08:50,730
based on this what we can do is that we

211
00:08:49,050 --> 00:08:52,979
can have a circuit heavy scheme and

212
00:08:50,730 --> 00:08:55,050
instantiate to power lambda many key

213
00:08:52,980 --> 00:08:57,720
pairs from the circuit a B scheme where

214
00:08:55,050 --> 00:08:59,640
each such key pair will support inputs

215
00:08:57,720 --> 00:09:02,060
I mean attributes of length I

216
00:08:59,640 --> 00:09:05,550
ranging from one to two power lambda and

217
00:09:02,060 --> 00:09:08,160
then we can encrypt a message under the

218
00:09:05,550 --> 00:09:11,430
proper public key based on the length of

219
00:09:08,160 --> 00:09:13,170
the attribute for the key generation we

220
00:09:11,430 --> 00:09:14,760
will convert the nfm to a set of two

221
00:09:13,170 --> 00:09:15,899
Paul lambda circuits where each such

222
00:09:14,760 --> 00:09:18,450
circuit will be capable of handling

223
00:09:15,899 --> 00:09:21,839
input length I ranging from again one to

224
00:09:18,450 --> 00:09:24,380
two power lambda and use these a B

225
00:09:21,839 --> 00:09:27,329
master secret keys to generate a B keys

226
00:09:24,380 --> 00:09:30,029
for each of these circuits individually

227
00:09:27,329 --> 00:09:32,370
and get them in a bunch to output as the

228
00:09:30,029 --> 00:09:34,110
secret key for the NFA machine M

229
00:09:32,370 --> 00:09:35,670
why does decryption work because

230
00:09:34,110 --> 00:09:39,510
decrypted knows the length of the

231
00:09:35,670 --> 00:09:41,060
attribute at least it can choose which

232
00:09:39,510 --> 00:09:44,339
particular secret key to use

233
00:09:41,060 --> 00:09:46,109
corresponding to the machine I mean

234
00:09:44,339 --> 00:09:49,200
circuit equivalent of the NFA and

235
00:09:46,110 --> 00:09:50,820
decrypt to get back M if M except 6 now

236
00:09:49,200 --> 00:09:52,920
the first problem here is that the key

237
00:09:50,820 --> 00:09:54,810
size is actually too long it's

238
00:09:52,920 --> 00:09:57,510
exponentially in security parameter and

239
00:09:54,810 --> 00:09:59,160
to reduce this we use a simple trick we

240
00:09:57,510 --> 00:10:02,010
handle the inputs of length the

241
00:09:59,160 --> 00:10:04,469
attributes of length only to power I so

242
00:10:02,010 --> 00:10:06,510
we instantiate the a B scheme instead of

243
00:10:04,470 --> 00:10:08,760
2 power lambda times we instantiate it

244
00:10:06,510 --> 00:10:12,510
lambda plus 1 times where we handle

245
00:10:08,760 --> 00:10:15,300
attributes of length 2 power I only as

246
00:10:12,510 --> 00:10:16,620
in when when and if and when the

247
00:10:15,300 --> 00:10:19,019
attribute comes during the encryption

248
00:10:16,620 --> 00:10:20,760
algorithm deity which see the nearest

249
00:10:19,019 --> 00:10:22,620
power of 2 and padded with sufficient

250
00:10:20,760 --> 00:10:24,689
number of bots and we encrypt the

251
00:10:22,620 --> 00:10:26,430
message under this new attribute for key

252
00:10:24,690 --> 00:10:28,440
generation we convert this machine m to

253
00:10:26,430 --> 00:10:30,870
a set of lambdas circuits lambda plus 1

254
00:10:28,440 --> 00:10:33,570
circuits which are individually capable

255
00:10:30,870 --> 00:10:35,670
of handling inputs of length 2 power I

256
00:10:33,570 --> 00:10:37,920
and then use the a B master secret keys

257
00:10:35,670 --> 00:10:42,839
again to generate keys for these

258
00:10:37,920 --> 00:10:44,790
circuits so while this works now the

259
00:10:42,839 --> 00:10:46,019
next problem is that I mean we have

260
00:10:44,790 --> 00:10:48,510
reduced the number of keys to a

261
00:10:46,019 --> 00:10:51,390
polynomial count but the next problem is

262
00:10:48,510 --> 00:10:54,120
that each individual circuit a B

263
00:10:51,390 --> 00:10:56,970
secretly can can have an arbitrary size

264
00:10:54,120 --> 00:10:59,070
I mean they can blow up by too much we

265
00:10:56,970 --> 00:11:01,399
don't have a proper bound on the

266
00:10:59,070 --> 00:11:04,230
underlying circuit sizes M hats of

267
00:11:01,399 --> 00:11:07,709
equivalent NF is I mean the NF is

268
00:11:04,230 --> 00:11:09,420
equivalent circuits so they may have

269
00:11:07,709 --> 00:11:12,449
arbitrary sizes we need to bound and

270
00:11:09,420 --> 00:11:13,530
somehow so to bound them our first idea

271
00:11:12,449 --> 00:11:16,140
is to use these

272
00:11:13,530 --> 00:11:19,589
by Boni at all from 2014 euro crypt

273
00:11:16,140 --> 00:11:21,930
which relies on lwe which says that it

274
00:11:19,590 --> 00:11:23,400
can ensure that the size of the circuit

275
00:11:21,930 --> 00:11:26,010
every secret kiss grows only with the

276
00:11:23,400 --> 00:11:28,650
depth of these underlying circuits now

277
00:11:26,010 --> 00:11:32,310
once we have only this depth dependency

278
00:11:28,650 --> 00:11:35,520
we need to have a bound on the depth of

279
00:11:32,310 --> 00:11:39,569
these underlying circuits so a knife way

280
00:11:35,520 --> 00:11:41,579
to convert any nfm to any circuit will

281
00:11:39,570 --> 00:11:44,700
actually I mean it can be done like this

282
00:11:41,580 --> 00:11:46,650
that you can track all the inputs States

283
00:11:44,700 --> 00:11:48,780
while reading every input symbol and

284
00:11:46,650 --> 00:11:51,510
this can actually lead to a circuit of

285
00:11:48,780 --> 00:11:54,510
depth polynomial in the length of the

286
00:11:51,510 --> 00:11:56,220
input and that's what we don't want so

287
00:11:54,510 --> 00:11:59,310
we actually employ a divide and conquer

288
00:11:56,220 --> 00:12:01,890
strategy from the literature complexity

289
00:11:59,310 --> 00:12:04,290
literature to evaluate these NFA em and

290
00:12:01,890 --> 00:12:06,510
this ensures that the circuit that we

291
00:12:04,290 --> 00:12:09,060
have here employing this divide and

292
00:12:06,510 --> 00:12:11,220
conquer technique the the depth of the

293
00:12:09,060 --> 00:12:13,319
circuit scales as poly logarithmically

294
00:12:11,220 --> 00:12:15,390
in the machine size and the input size

295
00:12:13,320 --> 00:12:17,220
which in turn ensures that the circuit

296
00:12:15,390 --> 00:12:20,580
every secret key grows only as a

297
00:12:17,220 --> 00:12:23,630
polynomial in the security parameter the

298
00:12:20,580 --> 00:12:27,480
third and the most crucial probably the

299
00:12:23,630 --> 00:12:29,130
problem in our naive way of constructing

300
00:12:27,480 --> 00:12:33,270
is that we had an inefficient key

301
00:12:29,130 --> 00:12:34,710
generation note that our u comma b key

302
00:12:33,270 --> 00:12:36,630
generation algorithm takes a machine

303
00:12:34,710 --> 00:12:38,550
name and converts it into a circuit but

304
00:12:36,630 --> 00:12:40,430
this circuit may be too large for even

305
00:12:38,550 --> 00:12:43,800
the for the keygen to even read it

306
00:12:40,430 --> 00:12:45,479
actually and idea it the time for keygen

307
00:12:43,800 --> 00:12:49,949
should not also depend on the input

308
00:12:45,480 --> 00:12:51,450
length now so the solution to get to get

309
00:12:49,950 --> 00:12:53,940
around this the solution is to somehow

310
00:12:51,450 --> 00:12:57,720
redistribute the computation in a way

311
00:12:53,940 --> 00:12:59,400
that we delegate the inefficient part to

312
00:12:57,720 --> 00:13:03,180
the encryption and decryption algorithms

313
00:12:59,400 --> 00:13:04,740
of the u comma B primitive now why

314
00:13:03,180 --> 00:13:06,209
encryption and decryption because these

315
00:13:04,740 --> 00:13:07,890
two are the only algorithms that can

316
00:13:06,210 --> 00:13:11,130
still run in time polynomial in the

317
00:13:07,890 --> 00:13:12,480
length of the attribute so thankfully

318
00:13:11,130 --> 00:13:13,770
functional encryption comes to our

319
00:13:12,480 --> 00:13:17,580
rescue here

320
00:13:13,770 --> 00:13:19,470
so EFI as we already have seen in the

321
00:13:17,580 --> 00:13:22,380
previous talks it's a generalization of

322
00:13:19,470 --> 00:13:25,020
a b ii and where secret key corresponds

323
00:13:22,380 --> 00:13:27,390
to a circuit and ciphertext encodes the

324
00:13:25,020 --> 00:13:29,819
message which i mean

325
00:13:27,390 --> 00:13:31,470
these secret keys when used to decrypt

326
00:13:29,820 --> 00:13:32,250
the ciphertext reveals only the function

327
00:13:31,470 --> 00:13:35,550
of the plaintext

328
00:13:32,250 --> 00:13:37,230
and nothing else in our context we only

329
00:13:35,550 --> 00:13:38,790
need a single key secure functional

330
00:13:37,230 --> 00:13:40,560
encryption which can be again

331
00:13:38,790 --> 00:13:44,819
instantiated from the works of gold wash

332
00:13:40,560 --> 00:13:48,689
return and Agrawal and based on lwv can

333
00:13:44,820 --> 00:13:51,000
be still based on lwe so let us see how

334
00:13:48,690 --> 00:13:53,070
efi helps this helps us here to delegate

335
00:13:51,000 --> 00:13:54,810
the computation of nfe to circuit

336
00:13:53,070 --> 00:13:58,470
transformation and a B secret key

337
00:13:54,810 --> 00:14:00,569
generation so the idea is that instead

338
00:13:58,470 --> 00:14:02,399
of converting to a circuit the key

339
00:14:00,570 --> 00:14:05,779
generator now takes the input machine

340
00:14:02,399 --> 00:14:08,220
and encodes it into an EFI ciphertext

341
00:14:05,779 --> 00:14:11,459
parallely the encryption algorithm takes

342
00:14:08,220 --> 00:14:14,250
the attribute and the message m and it

343
00:14:11,459 --> 00:14:16,319
converts I mean it generates an EFI

344
00:14:14,250 --> 00:14:17,550
secret key for a circuit which embeds

345
00:14:16,320 --> 00:14:19,290
this input length

346
00:14:17,550 --> 00:14:21,449
I mean attribute length hardwired in it

347
00:14:19,290 --> 00:14:24,240
now given these two are available to the

348
00:14:21,450 --> 00:14:26,910
Decrypter it can run the efi decryption

349
00:14:24,240 --> 00:14:29,220
on-the-fly to get back C sub X of M by

350
00:14:26,910 --> 00:14:31,709
the functionality guarantee of Fe where

351
00:14:29,220 --> 00:14:34,260
C sub X of M is described as follows

352
00:14:31,709 --> 00:14:36,149
it takes the Machine M as input it

353
00:14:34,260 --> 00:14:38,010
computes based on the hard-wired input

354
00:14:36,149 --> 00:14:42,089
length of the attribute it computes a

355
00:14:38,010 --> 00:14:45,630
suitable AV keep here which can handle

356
00:14:42,089 --> 00:14:47,730
inputs of length X mod X and convert the

357
00:14:45,630 --> 00:14:52,290
NFA m do a circuit actually inside the

358
00:14:47,730 --> 00:14:55,050
circuit to this circuit M hat which has

359
00:14:52,290 --> 00:14:56,939
input length mod X and then use the ABI

360
00:14:55,050 --> 00:14:58,829
master secret key to compute and output

361
00:14:56,940 --> 00:15:02,670
da B master a B secretly for this

362
00:14:58,829 --> 00:15:05,550
circuit now once this is output by the

363
00:15:02,670 --> 00:15:09,420
efi decryption the encryption algorithm

364
00:15:05,550 --> 00:15:11,430
also actually encrypts as a part of the

365
00:15:09,420 --> 00:15:14,010
ciphertext it actually outputs the a B

366
00:15:11,430 --> 00:15:16,829
encryption of the message M under the

367
00:15:14,010 --> 00:15:18,870
proper public key under the same public

368
00:15:16,829 --> 00:15:20,760
key actually with which Dima for which

369
00:15:18,870 --> 00:15:26,820
the same master secret key was used to

370
00:15:20,760 --> 00:15:29,550
compute the secret key for the nfa sir

371
00:15:26,820 --> 00:15:31,230
circuit equivalent of nfa and when these

372
00:15:29,550 --> 00:15:33,029
two are available to the Decrypter it

373
00:15:31,230 --> 00:15:35,670
can actually run the a/b decryption

374
00:15:33,029 --> 00:15:38,899
algorithm to output the message if I'm

375
00:15:35,670 --> 00:15:41,189
accepted X now while this template works

376
00:15:38,899 --> 00:15:43,610
we still need to be a bit clearer

377
00:15:41,190 --> 00:15:46,200
all about the implementation of EFI here

378
00:15:43,610 --> 00:15:48,150
we don't need this I fir text to scale

379
00:15:46,200 --> 00:15:51,300
up with the input size again otherwise

380
00:15:48,150 --> 00:15:53,340
we fall in the same trap again so for

381
00:15:51,300 --> 00:15:55,530
this we use a we use the single key

382
00:15:53,340 --> 00:15:57,840
succinct Fe scheme by goldwater at all

383
00:15:55,530 --> 00:15:59,459
where it's ensured that Fe cipher text

384
00:15:57,840 --> 00:16:01,800
scales only with the depth input and

385
00:15:59,460 --> 00:16:03,570
output of the circuit and not with the

386
00:16:01,800 --> 00:16:05,490
size and we carefully bound the depth

387
00:16:03,570 --> 00:16:09,870
into input and output to be polynomials

388
00:16:05,490 --> 00:16:12,210
in security parameter and as a result

389
00:16:09,870 --> 00:16:13,890
what we have here is that the u comma b

390
00:16:12,210 --> 00:16:16,290
key generation and encryption algorithms

391
00:16:13,890 --> 00:16:17,430
runs in time proportional to the size of

392
00:16:16,290 --> 00:16:21,959
the machine and the size of the

393
00:16:17,430 --> 00:16:23,699
attribute further we have the Decrypter

394
00:16:21,960 --> 00:16:25,860
generate the a/b secret key on the fly

395
00:16:23,700 --> 00:16:29,580
which is needed for the final decryption

396
00:16:25,860 --> 00:16:33,090
and but at the same time because this Fe

397
00:16:29,580 --> 00:16:34,830
secret is supports the circuit and this

398
00:16:33,090 --> 00:16:37,050
circuit takes the NFA machine as input

399
00:16:34,830 --> 00:16:39,060
the machine we need a bound on the

400
00:16:37,050 --> 00:16:40,800
machine that's why we have support for

401
00:16:39,060 --> 00:16:44,219
unbounded attributes but with bounded

402
00:16:40,800 --> 00:16:46,469
size machines so we need a bound on the

403
00:16:44,220 --> 00:16:48,090
machine and this works this is the

404
00:16:46,470 --> 00:16:51,960
high-level idea of how we construct the

405
00:16:48,090 --> 00:16:53,010
u comma B scheme so as a summary let us

406
00:16:51,960 --> 00:16:55,980
look at the problems and their solutions

407
00:16:53,010 --> 00:16:57,810
that we face from the nice solution we

408
00:16:55,980 --> 00:16:59,100
had an exponentially long key for which

409
00:16:57,810 --> 00:17:02,189
we used attributes of length through

410
00:16:59,100 --> 00:17:04,740
power I the individual any secret keys

411
00:17:02,190 --> 00:17:06,689
could be too large to handle this we

412
00:17:04,740 --> 00:17:09,240
instantiated with a suitable a/b scheme

413
00:17:06,689 --> 00:17:11,760
and ensured that the circuit depth is

414
00:17:09,240 --> 00:17:13,620
polynomial in security parameter thirdly

415
00:17:11,760 --> 00:17:16,470
we had an inefficient key generation

416
00:17:13,619 --> 00:17:18,419
where we used the succinct FE scheme to

417
00:17:16,470 --> 00:17:19,439
delegate this inefficiency inefficiency

418
00:17:18,420 --> 00:17:22,709
to the encryption and decryption

419
00:17:19,439 --> 00:17:24,510
algorithms so now let us look at how do

420
00:17:22,709 --> 00:17:27,959
you construct this B comma u primitive

421
00:17:24,510 --> 00:17:31,020
note that this attribute length is now

422
00:17:27,959 --> 00:17:32,570
bounded since it is bounded it it can be

423
00:17:31,020 --> 00:17:34,680
known to the setup algorithm and

424
00:17:32,570 --> 00:17:36,899
therefore it is thrown to the key

425
00:17:34,680 --> 00:17:38,700
generator and the encrypter and

426
00:17:36,900 --> 00:17:40,440
therefore we can actually employ a

427
00:17:38,700 --> 00:17:43,410
circuit every scheme directly to convert

428
00:17:40,440 --> 00:17:46,080
nFA's into circuits and instantiate it

429
00:17:43,410 --> 00:17:49,170
just we need to ensure that because we

430
00:17:46,080 --> 00:17:52,860
are we have we want to handle unbounded

431
00:17:49,170 --> 00:17:54,300
size NFS we have we need a depth

432
00:17:52,860 --> 00:17:58,139
guarantee on these

433
00:17:54,300 --> 00:18:00,210
over NFS of any arbitrary size for that

434
00:17:58,140 --> 00:18:02,430
we can again use the same divide and

435
00:18:00,210 --> 00:18:05,550
conquer technique to have a depth

436
00:18:02,430 --> 00:18:08,160
guarantee on these circuits so once this

437
00:18:05,550 --> 00:18:11,370
is done we now see how to construct this

438
00:18:08,160 --> 00:18:13,350
new primitive unbounded length inputs

439
00:18:11,370 --> 00:18:14,969
and unbounded and FM machines the high

440
00:18:13,350 --> 00:18:17,219
level idea is again to break up the

441
00:18:14,970 --> 00:18:18,630
computation in two parts where the size

442
00:18:17,220 --> 00:18:20,850
of the attribute is greater than the

443
00:18:18,630 --> 00:18:22,200
size of the machine and vice versa we

444
00:18:20,850 --> 00:18:24,840
are working in the symmetric key setting

445
00:18:22,200 --> 00:18:26,910
so therefore we will again have a master

446
00:18:24,840 --> 00:18:28,830
security as a PRF key which can now

447
00:18:26,910 --> 00:18:30,900
inherently define a sequence of master

448
00:18:28,830 --> 00:18:33,899
secret keys from the underlying u comma

449
00:18:30,900 --> 00:18:36,150
B scheme each such master secret key is

450
00:18:33,900 --> 00:18:40,770
capable of handling in a phase of size i

451
00:18:36,150 --> 00:18:43,980
ranging from 1 to 2 ba lambda parallely

452
00:18:40,770 --> 00:18:45,780
this we can have a PRF key which is able

453
00:18:43,980 --> 00:18:48,110
to define all these master secret keys

454
00:18:45,780 --> 00:18:51,180
from the b comma u scheme which are

455
00:18:48,110 --> 00:18:54,209
capable of handling inputs of length 2

456
00:18:51,180 --> 00:18:55,830
power lambda as an input attributes of

457
00:18:54,210 --> 00:18:57,420
length 2 power lambda now how does the

458
00:18:55,830 --> 00:19:00,810
encryptor and key generator work let's

459
00:18:57,420 --> 00:19:02,070
look at them parallel e because

460
00:19:00,810 --> 00:19:04,350
encryptor knows the length of the

461
00:19:02,070 --> 00:19:05,700
attribute but it but not the size of the

462
00:19:04,350 --> 00:19:07,050
machine and key generator knows the

463
00:19:05,700 --> 00:19:11,900
length of the machine but not the

464
00:19:07,050 --> 00:19:14,580
attribute what encrypter can do it

465
00:19:11,900 --> 00:19:19,680
samples master secret keys from this u

466
00:19:14,580 --> 00:19:22,470
comma b scheme mod of fixed with NFS of

467
00:19:19,680 --> 00:19:24,660
size supporting mod of X I mean 1 2 mod

468
00:19:22,470 --> 00:19:28,680
of X and generate ciphertext under each

469
00:19:24,660 --> 00:19:31,020
of these master secret keys accordingly

470
00:19:28,680 --> 00:19:33,570
the Decrypter can actually sample a

471
00:19:31,020 --> 00:19:37,610
secret key with the size of the machine

472
00:19:33,570 --> 00:19:40,649
m from the unbounded scheme and we can

473
00:19:37,610 --> 00:19:43,199
once we know that the size of the

474
00:19:40,650 --> 00:19:45,360
attribute X is greater than the size of

475
00:19:43,200 --> 00:19:47,910
the machine we know that one of these

476
00:19:45,360 --> 00:19:49,500
ciphertexts actually corresponds to I

477
00:19:47,910 --> 00:19:52,320
mean was generated with the master

478
00:19:49,500 --> 00:19:55,170
secret key capable of handling NFS of

479
00:19:52,320 --> 00:19:57,659
size m and therefore we can actually

480
00:19:55,170 --> 00:20:00,960
pair this key with the one of that one

481
00:19:57,660 --> 00:20:03,090
of those cipher texts so what what what

482
00:20:00,960 --> 00:20:04,320
if the other thing happens as in the

483
00:20:03,090 --> 00:20:07,340
size of the machine

484
00:20:04,320 --> 00:20:09,020
grows more than the size of the is

485
00:20:07,340 --> 00:20:13,040
than the size of the attribute then we

486
00:20:09,020 --> 00:20:15,230
just roll this swab the role of the two

487
00:20:13,040 --> 00:20:16,870
new comma B and become a new skin so

488
00:20:15,230 --> 00:20:19,520
where the key generator now produces

489
00:20:16,870 --> 00:20:21,560
modern secret keys modern secret keys

490
00:20:19,520 --> 00:20:24,680
each capable of handling I sized

491
00:20:21,560 --> 00:20:29,139
attributes where I ranges from 1 to mod

492
00:20:24,680 --> 00:20:31,520
of him and encrypter gives a ciphertext

493
00:20:29,140 --> 00:20:33,170
with the b comma u scheme which is

494
00:20:31,520 --> 00:20:37,370
capable of handling on the mod excised

495
00:20:33,170 --> 00:20:40,970
attributes so once this is done the

496
00:20:37,370 --> 00:20:42,530
decryption compares what I mean

497
00:20:40,970 --> 00:20:44,420
compares the length of this machine and

498
00:20:42,530 --> 00:20:46,610
the length of the attribute if they may

499
00:20:44,420 --> 00:20:48,530
attribute size is greater then it uses

500
00:20:46,610 --> 00:20:51,050
the unbounded scheme to combine it

501
00:20:48,530 --> 00:20:53,030
unbounded attribute scheme otherwise it

502
00:20:51,050 --> 00:20:54,649
uses the unbounded machine scheme to

503
00:20:53,030 --> 00:20:57,980
combine these ciphertexts and attributes

504
00:20:54,650 --> 00:21:01,850
this ciphertext and secret keys and run

505
00:20:57,980 --> 00:21:03,860
the decryption so in summary we we run

506
00:21:01,850 --> 00:21:06,050
these two underlying schemes u comma B

507
00:21:03,860 --> 00:21:08,810
and B comma u in parallel to make the

508
00:21:06,050 --> 00:21:10,790
decryption work and to which supports

509
00:21:08,810 --> 00:21:15,590
both unbounded X unbounded attributes

510
00:21:10,790 --> 00:21:17,510
and unbounded him now using the same

511
00:21:15,590 --> 00:21:19,129
techniques we can generalize it to get

512
00:21:17,510 --> 00:21:21,200
predicates encryption bounded key

513
00:21:19,130 --> 00:21:23,450
functional encryption and usable

514
00:21:21,200 --> 00:21:25,550
garbling for NFS from learning with

515
00:21:23,450 --> 00:21:29,470
errors assumption and last but not the

516
00:21:25,550 --> 00:21:31,730
least let's see how to get io from the

517
00:21:29,470 --> 00:21:34,820
secret key D FF II the high level idea

518
00:21:31,730 --> 00:21:36,800
is to again look at this way look at it

519
00:21:34,820 --> 00:21:39,320
this way we if we have an NC one circuit

520
00:21:36,800 --> 00:21:41,149
we can actually use Barrington's theorem

521
00:21:39,320 --> 00:21:43,310
to convert into a branching program and

522
00:21:41,150 --> 00:21:46,130
then leverage the similarities between a

523
00:21:43,310 --> 00:21:48,260
branching program and a DFA so while the

524
00:21:46,130 --> 00:21:50,570
input length is fixed to convert it into

525
00:21:48,260 --> 00:21:53,060
a DFA actually and once we have this

526
00:21:50,570 --> 00:21:57,169
tool with us if we have a secret key Fe

527
00:21:53,060 --> 00:21:59,210
for DFA we can employ this tool with

528
00:21:57,170 --> 00:22:01,550
this thing to obtain secret key Fe for

529
00:21:59,210 --> 00:22:03,320
NC one circuits and this as recent

530
00:22:01,550 --> 00:22:04,790
results have shown this is good enough

531
00:22:03,320 --> 00:22:06,710
to imply in distinguishability office

532
00:22:04,790 --> 00:22:08,810
keishon which actually highlights a

533
00:22:06,710 --> 00:22:09,430
barrier in obtaining fully collusion

534
00:22:08,810 --> 00:22:13,159
resistant

535
00:22:09,430 --> 00:22:17,150
functional encryption for DFS

536
00:22:13,160 --> 00:22:18,680
so let me conclude by saying that we

537
00:22:17,150 --> 00:22:21,270
have the first constructions of a/b and

538
00:22:18,680 --> 00:22:23,790
it's generalizations of NFA from ender

539
00:22:21,270 --> 00:22:26,100
we also illuminate a barrier and our

540
00:22:23,790 --> 00:22:27,810
techniques are new we hope that they may

541
00:22:26,100 --> 00:22:30,899
find more applications in similar and

542
00:22:27,810 --> 00:22:32,720
different contexts we also want to see

543
00:22:30,900 --> 00:22:35,460
how to support during machine and RAM

544
00:22:32,720 --> 00:22:37,230
and last but not the least again our

545
00:22:35,460 --> 00:22:38,490
sirs primitive is restricted to the

546
00:22:37,230 --> 00:22:40,710
secret key setting we want a

547
00:22:38,490 --> 00:22:48,870
generalization to the public key one so

548
00:22:40,710 --> 00:22:52,520
thanks for your attention if you have a

549
00:22:48,870 --> 00:22:52,520
question please come to the microphone

550
00:23:05,750 --> 00:23:09,380
okay let's thanks this all speakers

551
00:23:08,640 --> 00:23:13,469
again

552
00:23:09,380 --> 00:23:13,469
[Applause]

