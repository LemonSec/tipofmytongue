1
00:00:04,940 --> 00:00:07,970
thanks for coming so this is some drink

2
00:00:07,520 --> 00:00:10,570
work

3
00:00:07,970 --> 00:00:13,670
yeah with Danna let's NIV and you've all

4
00:00:10,570 --> 00:00:15,590
the topic of this talk is zero knowledge

5
00:00:13,670 --> 00:00:17,300
proof so as you know as your knowledge

6
00:00:15,590 --> 00:00:19,610
proof is a two-party protocol between

7
00:00:17,300 --> 00:00:21,439
approver and a verifier so think of the

8
00:00:19,610 --> 00:00:23,779
verifier as taking as input a graph and

9
00:00:21,439 --> 00:00:25,430
the prover is gonna try to convince the

10
00:00:23,779 --> 00:00:27,349
verifier say that this graph is 3

11
00:00:25,430 --> 00:00:28,880
colorable so they'll exchange some

12
00:00:27,349 --> 00:00:30,259
messages and at the end of this protocol

13
00:00:28,880 --> 00:00:33,170
the verifier should be convinced that

14
00:00:30,259 --> 00:00:34,550
this graph is indeed 3 colorable so for

15
00:00:33,170 --> 00:00:36,500
this proof system to be useful it should

16
00:00:34,550 --> 00:00:38,569
satisfy a number of properties it should

17
00:00:36,500 --> 00:00:39,590
be complete in the sense that an honest

18
00:00:38,570 --> 00:00:42,050
provers should convince an honest

19
00:00:39,590 --> 00:00:43,340
verifier it should be sound in the sense

20
00:00:42,050 --> 00:00:46,160
that a cheating provers should rarely

21
00:00:43,340 --> 00:00:47,180
fool an honest verifier and it should be

22
00:00:46,160 --> 00:00:48,319
zero knowledge in the sense that a

23
00:00:47,180 --> 00:00:49,940
cheating verifier shouldn't learn

24
00:00:48,320 --> 00:00:52,940
anything about the graph apart from the

25
00:00:49,940 --> 00:00:54,110
fact that it's 3 colorable so in this

26
00:00:52,940 --> 00:00:55,580
talk we're going to be looking at a

27
00:00:54,110 --> 00:00:56,570
different type a new type of zero

28
00:00:55,580 --> 00:00:58,970
knowledge proof that we call zero

29
00:00:56,570 --> 00:01:00,410
knowledge groups on distributed data so

30
00:00:58,970 --> 00:01:01,760
the setting is different and that

31
00:01:00,410 --> 00:01:04,069
there's multiple verifiers

32
00:01:01,760 --> 00:01:05,600
and now each verifier takes his input

33
00:01:04,069 --> 00:01:07,369
only a piece of the statement that's

34
00:01:05,600 --> 00:01:09,079
being proved so if we're looking at

35
00:01:07,369 --> 00:01:11,539
graphs each verifier state could take in

36
00:01:09,079 --> 00:01:13,158
as input a piece of the graph and the

37
00:01:11,539 --> 00:01:13,880
prover is going to try to convince these

38
00:01:13,159 --> 00:01:15,140
verifiers

39
00:01:13,880 --> 00:01:16,609
that are holding this graph in

40
00:01:15,140 --> 00:01:18,310
distributed fashion that they're

41
00:01:16,609 --> 00:01:20,658
actually looking at a 3 colorable graph

42
00:01:18,310 --> 00:01:22,789
so the prover and the verifiers will

43
00:01:20,659 --> 00:01:24,229
interact over private channels and the

44
00:01:22,789 --> 00:01:26,030
verifiers can even interact with each

45
00:01:24,229 --> 00:01:27,319
other and at the end of this interaction

46
00:01:26,030 --> 00:01:29,479
the verifier should be convinced that

47
00:01:27,319 --> 00:01:31,069
yes we're holding a graph that's 3

48
00:01:29,479 --> 00:01:34,009
colorable even if I don't know what the

49
00:01:31,069 --> 00:01:35,959
other part of the graphic is and we can

50
00:01:34,009 --> 00:01:37,549
define natural notions of completeness

51
00:01:35,959 --> 00:01:40,759
and soundness and zero knowledge in this

52
00:01:37,549 --> 00:01:42,380
setting so for us we'll say the protocol

53
00:01:40,759 --> 00:01:44,030
is complete if an honest prove or

54
00:01:42,380 --> 00:01:46,130
convinces an honest pair of verifiers

55
00:01:44,030 --> 00:01:47,810
it's sound if the cheating prove are

56
00:01:46,130 --> 00:01:50,270
rarely convinces an honest pair of

57
00:01:47,810 --> 00:01:52,219
verifiers and we'll say it satisfies

58
00:01:50,270 --> 00:01:54,380
what we call strong zero knowledge if

59
00:01:52,219 --> 00:01:56,568
the cheating verifier doesn't learn

60
00:01:54,380 --> 00:01:58,189
anything else about the other verifiers

61
00:01:56,569 --> 00:02:00,649
input apart from the graph the fact that

62
00:01:58,189 --> 00:02:03,619
the joint graph is 3 colorable so in

63
00:02:00,649 --> 00:02:05,659
essence verifier v1 only learns its

64
00:02:03,619 --> 00:02:06,979
input g1 and the fact that the entire

65
00:02:05,659 --> 00:02:08,569
graph is 3 colorable it doesn't learn

66
00:02:06,979 --> 00:02:12,020
anything else about the other verifiers

67
00:02:08,568 --> 00:02:13,910
input and we can define in the setting

68
00:02:12,020 --> 00:02:16,220
kind of natural notions of round

69
00:02:13,910 --> 00:02:17,660
complexity and public kindness for these

70
00:02:16,220 --> 00:02:20,000
protocols as we do in

71
00:02:17,660 --> 00:02:21,230
any multi-party protocol and we can also

72
00:02:20,000 --> 00:02:23,150
look at the setting in which there's

73
00:02:21,230 --> 00:02:26,119
more than two verifiers so any number of

74
00:02:23,150 --> 00:02:27,890
verifies you like in the cryptographic

75
00:02:26,120 --> 00:02:29,780
context there's one type of zero

76
00:02:27,890 --> 00:02:32,299
knowledge proof on distributed data that

77
00:02:29,780 --> 00:02:33,830
comes up all the time and these are what

78
00:02:32,300 --> 00:02:36,560
we call zero knowledge proof saan secret

79
00:02:33,830 --> 00:02:38,690
shared data the setting here is is one

80
00:02:36,560 --> 00:02:40,790
in which the prover has a vector and the

81
00:02:38,690 --> 00:02:42,170
verifiers each have secret shares of the

82
00:02:40,790 --> 00:02:44,299
vector according to some say linear

83
00:02:42,170 --> 00:02:46,640
secret sharing scheme so neither

84
00:02:44,300 --> 00:02:48,230
verifier actually sees the the data in

85
00:02:46,640 --> 00:02:49,700
the clear they only have shares of the

86
00:02:48,230 --> 00:02:51,649
data and yet the prover should be able

87
00:02:49,700 --> 00:02:54,530
to convince the verifiers that this

88
00:02:51,650 --> 00:02:56,510
vector is in some language so this may

89
00:02:54,530 --> 00:02:57,860
seem a little bit contrived or a little

90
00:02:56,510 --> 00:02:59,209
bit theoretical but it turns out that

91
00:02:57,860 --> 00:03:01,280
these zero knowledge groups on this tree

92
00:02:59,210 --> 00:03:02,540
but it did actually have applications to

93
00:03:01,280 --> 00:03:04,640
a bunch of different privacy-preserving

94
00:03:02,540 --> 00:03:07,190
systems that are already have already

95
00:03:04,640 --> 00:03:09,200
been built so systems for PIR writing

96
00:03:07,190 --> 00:03:10,940
and private messaging private

97
00:03:09,200 --> 00:03:13,640
computation of aggregate statistics and

98
00:03:10,940 --> 00:03:15,650
private ad targeting all use these ideas

99
00:03:13,640 --> 00:03:18,079
kind of implicitly and many of these

100
00:03:15,650 --> 00:03:21,020
systems actually implicitly construct 0

101
00:03:18,080 --> 00:03:22,820
non proofs on distributed data so the

102
00:03:21,020 --> 00:03:24,980
goal of this work was to give sort of

103
00:03:22,820 --> 00:03:26,570
unified definitions for this this idea

104
00:03:24,980 --> 00:03:27,859
and also new more efficient

105
00:03:26,570 --> 00:03:30,680
constructions for zero knowledge proof

106
00:03:27,860 --> 00:03:33,140
on distributed data so in particular if

107
00:03:30,680 --> 00:03:35,060
we look at the applications that are on

108
00:03:33,140 --> 00:03:36,529
this slide we get kind of exponential

109
00:03:35,060 --> 00:03:38,720
improvement in the communication

110
00:03:36,530 --> 00:03:41,750
complexity of the proof systems and I'll

111
00:03:38,720 --> 00:03:43,400
explain how that works the other thing

112
00:03:41,750 --> 00:03:44,750
that we do is give a new application of

113
00:03:43,400 --> 00:03:46,190
journal and proofs on distributed data

114
00:03:44,750 --> 00:03:49,790
so malicious secure multi-party

115
00:03:46,190 --> 00:03:50,810
computation and just to point out that

116
00:03:49,790 --> 00:03:52,519
these things are actually used in

117
00:03:50,810 --> 00:03:54,110
practice one of these systems is

118
00:03:52,520 --> 00:03:55,670
implemented in the Firefox browser and

119
00:03:54,110 --> 00:03:57,770
we're hoping support some of these

120
00:03:55,670 --> 00:04:01,700
efficiency improvements that come out of

121
00:03:57,770 --> 00:04:03,770
this work into that setting as well so

122
00:04:01,700 --> 00:04:05,660
the first type of result I want to talk

123
00:04:03,770 --> 00:04:07,070
about are new zero knowledge groups on

124
00:04:05,660 --> 00:04:09,380
distributed data that we construct in

125
00:04:07,070 --> 00:04:11,060
this paper so the first theorem here is

126
00:04:09,380 --> 00:04:12,829
kind of a general feasibility result

127
00:04:11,060 --> 00:04:14,870
that says that if you have a language

128
00:04:12,830 --> 00:04:17,570
and our languages here are going to be

129
00:04:14,870 --> 00:04:19,430
vectors in a vector space that are that

130
00:04:17,570 --> 00:04:22,280
that's recognized by say an arithmetic

131
00:04:19,430 --> 00:04:23,540
circuit of size C then there's going to

132
00:04:22,280 --> 00:04:25,099
be a public point zero knowledge proof

133
00:04:23,540 --> 00:04:27,500
on distributed data for this language

134
00:04:25,100 --> 00:04:29,510
that has a constant number of rounds and

135
00:04:27,500 --> 00:04:32,260
has communication cost that grows

136
00:04:29,510 --> 00:04:35,090
linearly with the size of this

137
00:04:32,260 --> 00:04:36,500
so this kind of generalizes some of the

138
00:04:35,090 --> 00:04:38,869
special-purpose schemes that people have

139
00:04:36,500 --> 00:04:40,610
constructed implicitly before and we

140
00:04:38,870 --> 00:04:42,139
also give non-trivial extensions to the

141
00:04:40,610 --> 00:04:45,680
setting in which the prover and some of

142
00:04:42,139 --> 00:04:47,150
the verifiers collude so this is

143
00:04:45,680 --> 00:04:48,440
essentially says that for any language

144
00:04:47,150 --> 00:04:50,359
you want we can construct a zero

145
00:04:48,440 --> 00:04:51,830
knowledge proof on distributed data and

146
00:04:50,360 --> 00:04:53,150
I should say this first result is

147
00:04:51,830 --> 00:04:56,180
actually information theoretic so

148
00:04:53,150 --> 00:04:57,979
there's no assumptions required here the

149
00:04:56,180 --> 00:04:59,780
second type of result we have and here's

150
00:04:57,980 --> 00:05:01,700
one example is that if your language has

151
00:04:59,780 --> 00:05:03,289
structure so for example if your

152
00:05:01,700 --> 00:05:05,870
language is recognized by a low degree

153
00:05:03,290 --> 00:05:06,830
arithmetic circuit then there's a public

154
00:05:05,870 --> 00:05:08,690
coins your knowledge crew fund

155
00:05:06,830 --> 00:05:10,280
distributed data for this language that

156
00:05:08,690 --> 00:05:12,620
requires only kind of logarithmic lis

157
00:05:10,280 --> 00:05:13,909
many rounds of communication and has

158
00:05:12,620 --> 00:05:16,100
communication cost that grows

159
00:05:13,910 --> 00:05:18,650
logarithmically with the size of the

160
00:05:16,100 --> 00:05:21,110
inputs and this approach improves on the

161
00:05:18,650 --> 00:05:22,820
linear communication cost of the prior

162
00:05:21,110 --> 00:05:25,370
schemes that were implicitly constructed

163
00:05:22,820 --> 00:05:27,020
I should mention there's a bunch of ways

164
00:05:25,370 --> 00:05:28,610
we generalize this result and the paper

165
00:05:27,020 --> 00:05:29,690
so for example you can look at a smaller

166
00:05:28,610 --> 00:05:31,280
number of rounds and get a different

167
00:05:29,690 --> 00:05:33,950
trade-off in terms of communication

168
00:05:31,280 --> 00:05:36,289
complexity and you can also look at a

169
00:05:33,950 --> 00:05:38,360
wider class of structured languages like

170
00:05:36,290 --> 00:05:40,130
circuits of constant degree or circuits

171
00:05:38,360 --> 00:05:42,169
with repeated structure and so on so

172
00:05:40,130 --> 00:05:44,800
I'll point you to the paper for details

173
00:05:42,169 --> 00:05:47,180
on on the theorem statement

174
00:05:44,800 --> 00:05:48,710
so having defines what a zero knowledge

175
00:05:47,180 --> 00:05:49,580
proof on distributed data is I now want

176
00:05:48,710 --> 00:05:51,469
to give you a little bit of intuition

177
00:05:49,580 --> 00:05:54,500
about how we construct these objects and

178
00:05:51,470 --> 00:05:57,590
we do so using a new type of proof

179
00:05:54,500 --> 00:05:59,120
system called fully linear PC peas so

180
00:05:57,590 --> 00:06:01,190
constructing a journal and proof system

181
00:05:59,120 --> 00:06:03,440
on distributed data as we do kind of

182
00:06:01,190 --> 00:06:05,570
works in two steps the first thing we do

183
00:06:03,440 --> 00:06:08,510
is we define this notion of a fully

184
00:06:05,570 --> 00:06:10,550
linear PCP and then we show an efficient

185
00:06:08,510 --> 00:06:13,490
transformation that takes a fully linear

186
00:06:10,550 --> 00:06:14,690
PCP for some language and constructs an

187
00:06:13,490 --> 00:06:17,780
efficient zero knowledge proof for

188
00:06:14,690 --> 00:06:19,250
distributed data for that language so

189
00:06:17,780 --> 00:06:21,080
after we have this first step done then

190
00:06:19,250 --> 00:06:22,580
all we need to do is construct new more

191
00:06:21,080 --> 00:06:24,440
efficient fully linear PCPs for

192
00:06:22,580 --> 00:06:26,479
languages of interest and that that

193
00:06:24,440 --> 00:06:30,830
completes that gives us new proofs on

194
00:06:26,479 --> 00:06:32,270
distributed data so I want to I think

195
00:06:30,830 --> 00:06:34,669
the easiest way for me to describe what

196
00:06:32,270 --> 00:06:37,789
a fully linear PCP is is first to recall

197
00:06:34,669 --> 00:06:39,950
what a linear PCP is so this is a notion

198
00:06:37,789 --> 00:06:41,300
of proof that's been around for more

199
00:06:39,950 --> 00:06:43,090
than 10 years and has been used in a

200
00:06:41,300 --> 00:06:46,419
bunch of cryptographic constructions

201
00:06:43,090 --> 00:06:48,549
and what it is what a linear PCP proof

202
00:06:46,419 --> 00:06:51,760
is is just a vector that's what the

203
00:06:48,550 --> 00:06:53,260
proof looks like and the way that you

204
00:06:51,760 --> 00:06:55,030
check this proof essentially this vector

205
00:06:53,260 --> 00:06:58,060
this proof is asserting that some input

206
00:06:55,030 --> 00:06:59,500
X's in some language L and the way the

207
00:06:58,060 --> 00:07:01,240
verifier checks the proof is kind of

208
00:06:59,500 --> 00:07:03,520
unusual rather than reading the entire

209
00:07:01,240 --> 00:07:05,800
proof and reading the entire input and

210
00:07:03,520 --> 00:07:08,260
then accepting or rejecting what the

211
00:07:05,800 --> 00:07:10,150
verifier does is it makes a constant

212
00:07:08,260 --> 00:07:12,880
number of what we call linear queries to

213
00:07:10,150 --> 00:07:16,210
the proof so this vector this verifier

214
00:07:12,880 --> 00:07:17,770
down here outputs a query and this query

215
00:07:16,210 --> 00:07:21,099
is a vector that's as long as the entire

216
00:07:17,770 --> 00:07:23,020
proof and this verifier gives us query

217
00:07:21,100 --> 00:07:24,700
to the oracle this proof oracle and the

218
00:07:23,020 --> 00:07:26,799
oracle responds with the inner product

219
00:07:24,700 --> 00:07:28,690
of the the query and the proof so this

220
00:07:26,800 --> 00:07:31,360
answer is kind of a constant size answer

221
00:07:28,690 --> 00:07:33,669
one field element size and after making

222
00:07:31,360 --> 00:07:35,380
a constant number of these queries the

223
00:07:33,669 --> 00:07:38,440
linear PCP verifier should accept or

224
00:07:35,380 --> 00:07:39,880
reject so even though the the verifier

225
00:07:38,440 --> 00:07:41,590
can't kind of explicitly read the proof

226
00:07:39,880 --> 00:07:44,830
it can it has implicit access through

227
00:07:41,590 --> 00:07:46,270
these Oracle queries and this type of

228
00:07:44,830 --> 00:07:47,440
proof system should satisfy natural

229
00:07:46,270 --> 00:07:50,020
notions of completeness and soundness

230
00:07:47,440 --> 00:07:52,930
since your knowledge okay so that's what

231
00:07:50,020 --> 00:07:54,520
a linear PCP is what a fully linear PCP

232
00:07:52,930 --> 00:07:56,200
is which is the new idea and this work

233
00:07:54,520 --> 00:07:59,020
is the new abstraction it's very very

234
00:07:56,200 --> 00:08:00,490
similar except now the verifier doesn't

235
00:07:59,020 --> 00:08:03,609
actually have explicit access to the

236
00:08:00,490 --> 00:08:06,400
input either so what a fully linear PCP

237
00:08:03,610 --> 00:08:08,470
verifier does is it outputs some queries

238
00:08:06,400 --> 00:08:10,299
it gets to make linear queries but it's

239
00:08:08,470 --> 00:08:13,240
linear queries are - the combination of

240
00:08:10,300 --> 00:08:14,680
the input and the proof and after making

241
00:08:13,240 --> 00:08:16,539
a constant number of these linear

242
00:08:14,680 --> 00:08:18,880
queries the verifier is supposed to

243
00:08:16,539 --> 00:08:20,469
decide whether this this X to which it

244
00:08:18,880 --> 00:08:22,300
has only implicit access through this

245
00:08:20,470 --> 00:08:25,000
Oracle is either in the language or not

246
00:08:22,300 --> 00:08:26,350
and again we can we can define

247
00:08:25,000 --> 00:08:29,410
completeness and soundness in to your

248
00:08:26,350 --> 00:08:31,750
knowledge in this setting so if you

249
00:08:29,410 --> 00:08:32,800
believe that fully linear PCP is exists

250
00:08:31,750 --> 00:08:34,360
for your language then I'm going to

251
00:08:32,799 --> 00:08:35,530
explain to you how you use them to

252
00:08:34,360 --> 00:08:36,940
construct an efficient zero knowledge

253
00:08:35,530 --> 00:08:39,640
proof on distributed data for this

254
00:08:36,940 --> 00:08:40,479
language so the way this works again the

255
00:08:39,640 --> 00:08:42,580
setting is that we have multiple

256
00:08:40,479 --> 00:08:45,190
verifiers and each verifier has a piece

257
00:08:42,580 --> 00:08:47,080
of the input X and the prover who has

258
00:08:45,190 --> 00:08:49,720
all of X is going to try to convince the

259
00:08:47,080 --> 00:08:52,390
verifiers that this X is in some

260
00:08:49,720 --> 00:08:55,270
language so what the prover does is it

261
00:08:52,390 --> 00:08:56,319
produces a fully linear PCP proof that

262
00:08:55,270 --> 00:08:59,110
attests to the fact

263
00:08:56,320 --> 00:09:00,820
X's in the language it then splits this

264
00:08:59,110 --> 00:09:03,550
proof using a linear secret sharing

265
00:09:00,820 --> 00:09:07,120
scheme into two pieces and it sends one

266
00:09:03,550 --> 00:09:08,469
piece to each of the two verifiers so at

267
00:09:07,120 --> 00:09:10,150
this point the verifiers now have a

268
00:09:08,470 --> 00:09:12,310
piece of the input and they have a piece

269
00:09:10,150 --> 00:09:13,900
of the proof and what they want to do to

270
00:09:12,310 --> 00:09:16,930
check the proof is essentially simulate

271
00:09:13,900 --> 00:09:19,750
the process of asking these oracle

272
00:09:16,930 --> 00:09:22,359
quarry queries to the linear PCP proof

273
00:09:19,750 --> 00:09:23,800
Oracle so what the verifiers will do is

274
00:09:22,360 --> 00:09:25,870
they'll use common randomness between

275
00:09:23,800 --> 00:09:29,740
themselves to sample a series of these

276
00:09:25,870 --> 00:09:31,690
fully linear PCP queries and then by the

277
00:09:29,740 --> 00:09:33,610
using the fact that they can compute say

278
00:09:31,690 --> 00:09:36,160
an inner product on secret shared data

279
00:09:33,610 --> 00:09:38,470
the verifiers can publish shares of the

280
00:09:36,160 --> 00:09:40,360
answers to this query that the fully

281
00:09:38,470 --> 00:09:43,180
linear PCP proof Oracle would have given

282
00:09:40,360 --> 00:09:44,920
so what the verifier is essentially

283
00:09:43,180 --> 00:09:47,050
published the take the inner product of

284
00:09:44,920 --> 00:09:48,760
this query with their piece of the input

285
00:09:47,050 --> 00:09:50,800
and their share of the proof both

286
00:09:48,760 --> 00:09:52,630
verifiers do this and by publishing

287
00:09:50,800 --> 00:09:54,219
these values they can recover the answer

288
00:09:52,630 --> 00:09:57,670
to this query that the Oracle would have

289
00:09:54,220 --> 00:09:59,950
given so by simulating this these

290
00:09:57,670 --> 00:10:03,339
process of asking the Oracle queries in

291
00:09:59,950 --> 00:10:05,410
this way after a constant number of sort

292
00:10:03,340 --> 00:10:07,090
of elements of communication the

293
00:10:05,410 --> 00:10:08,350
verifiers can recover the answers to

294
00:10:07,090 --> 00:10:10,000
these queries that the Oracle would have

295
00:10:08,350 --> 00:10:12,430
given and then they can just run the

296
00:10:10,000 --> 00:10:14,080
Felipe's linear PCP verifier on these

297
00:10:12,430 --> 00:10:17,709
answers to check whether the proof is

298
00:10:14,080 --> 00:10:19,060
valid or not and the communication here

299
00:10:17,710 --> 00:10:21,010
that was required between all of the

300
00:10:19,060 --> 00:10:23,430
parties was essentially twice the size

301
00:10:21,010 --> 00:10:26,350
of the proof plus a constant number of

302
00:10:23,430 --> 00:10:31,900
elements for computing these Oracle

303
00:10:26,350 --> 00:10:33,130
query answers so I hope I've convinced

304
00:10:31,900 --> 00:10:34,689
you that if you can construct such a

305
00:10:33,130 --> 00:10:35,740
thing called the full of linear PCP for

306
00:10:34,690 --> 00:10:37,240
your language then you can use this

307
00:10:35,740 --> 00:10:38,200
transformation I just showed to get an

308
00:10:37,240 --> 00:10:40,510
efficiency or knowledge proof on

309
00:10:38,200 --> 00:10:41,590
distributed data for that language so

310
00:10:40,510 --> 00:10:43,240
now the question is how do you construct

311
00:10:41,590 --> 00:10:45,250
these fully linear pcbs well it turns

312
00:10:43,240 --> 00:10:47,590
out that many existing constructions of

313
00:10:45,250 --> 00:10:49,630
linear PC peas also satisfy this notion

314
00:10:47,590 --> 00:10:52,300
of fully linearity where the verifier

315
00:10:49,630 --> 00:10:54,010
only makes linear access to the input so

316
00:10:52,300 --> 00:10:55,359
the linear PCP is that people use for

317
00:10:54,010 --> 00:10:57,910
cryptographic instructions already

318
00:10:55,360 --> 00:10:59,830
satisfy this property but they have a

319
00:10:57,910 --> 00:11:02,620
limitation which is that the size of the

320
00:10:59,830 --> 00:11:04,360
proof grows with the size of the circuit

321
00:11:02,620 --> 00:11:06,520
linearly in the size of the circuit and

322
00:11:04,360 --> 00:11:09,460
in many applications we'd like sub

323
00:11:06,520 --> 00:11:10,030
linear size proofs so our idea here is

324
00:11:09,460 --> 00:11:12,040
to get

325
00:11:10,030 --> 00:11:14,410
proofs using interaction between the

326
00:11:12,040 --> 00:11:16,510
prover and the verifiers and this this

327
00:11:14,410 --> 00:11:18,130
this set of techniques we have works

328
00:11:16,510 --> 00:11:21,910
when your language is is simple in the

329
00:11:18,130 --> 00:11:23,110
in a way I'll describe this notion of

330
00:11:21,910 --> 00:11:25,390
using interaction to shrink the proof

331
00:11:23,110 --> 00:11:27,250
size is used in a bunch of different

332
00:11:25,390 --> 00:11:29,830
places and in kind of related ways so

333
00:11:27,250 --> 00:11:31,720
communication communication complexity

334
00:11:29,830 --> 00:11:33,520
protocols and interactive Oracle proofs

335
00:11:31,720 --> 00:11:36,220
and some check like proof systems all

336
00:11:33,520 --> 00:11:39,460
use very similar ideas to to the ones

337
00:11:36,220 --> 00:11:41,110
that I'll describe so I don't have time

338
00:11:39,460 --> 00:11:42,760
to go into the full details of how this

339
00:11:41,110 --> 00:11:45,010
works but I want to give you a flavor of

340
00:11:42,760 --> 00:11:47,980
how we get sublinear sized proofs using

341
00:11:45,010 --> 00:11:50,020
interaction so taking just the example

342
00:11:47,980 --> 00:11:51,790
of a degree two circuits so so your

343
00:11:50,020 --> 00:11:53,920
language is recognized by a degree two

344
00:11:51,790 --> 00:11:55,390
circuit and the prover is trying to

345
00:11:53,920 --> 00:11:57,160
convince the verifiers again who hold

346
00:11:55,390 --> 00:11:59,080
pieces of the input in distributed

347
00:11:57,160 --> 00:12:02,260
fashion that some degree two circuit

348
00:11:59,080 --> 00:12:05,440
recognizes this accepts this input so

349
00:12:02,260 --> 00:12:07,120
what the prover can do is we show that

350
00:12:05,440 --> 00:12:09,520
the prover can send each verifier a

351
00:12:07,120 --> 00:12:11,770
short proof like a constant size proof

352
00:12:09,520 --> 00:12:13,900
and this proof has the property that

353
00:12:11,770 --> 00:12:16,360
checking the proof only requires the

354
00:12:13,900 --> 00:12:18,069
verifiers to apply a random linear

355
00:12:16,360 --> 00:12:20,440
mapping to the in their piece of the

356
00:12:18,070 --> 00:12:23,380
input and the proof and then it evaluate

357
00:12:20,440 --> 00:12:24,670
a degree two circuit on the result so

358
00:12:23,380 --> 00:12:27,070
you'll have to believe me that this is

359
00:12:24,670 --> 00:12:29,319
true actually proving this requires a

360
00:12:27,070 --> 00:12:30,760
little bit of technical work but

361
00:12:29,320 --> 00:12:32,350
essentially what the verifiers can do is

362
00:12:30,760 --> 00:12:34,689
they can apply this randomized linear

363
00:12:32,350 --> 00:12:36,790
map on their piece of the input in their

364
00:12:34,690 --> 00:12:39,520
piece of the proof and then once they

365
00:12:36,790 --> 00:12:41,620
have they just need to check that there

366
00:12:39,520 --> 00:12:43,600
this kind of new squished input

367
00:12:41,620 --> 00:12:46,750
satisfies this new degree two circuit

368
00:12:43,600 --> 00:12:48,430
and rather than evaluating the circuit

369
00:12:46,750 --> 00:12:50,410
themselves they can outsource the work

370
00:12:48,430 --> 00:12:52,510
of evaluating this circuit to the prover

371
00:12:50,410 --> 00:12:55,030
and recursively invoke our proof system

372
00:12:52,510 --> 00:12:57,340
so the verifiers send the coins that

373
00:12:55,030 --> 00:12:58,750
they use to sample this random mapping

374
00:12:57,340 --> 00:13:00,310
to the prover and then the prover

375
00:12:58,750 --> 00:13:02,200
convinces the verifiers that they would

376
00:13:00,310 --> 00:13:04,930
have accepted had they actually computed

377
00:13:02,200 --> 00:13:07,120
this circuit on their their inputs so in

378
00:13:04,930 --> 00:13:08,979
this way when when your language has

379
00:13:07,120 --> 00:13:11,350
structure like this you can use this

380
00:13:08,980 --> 00:13:13,060
interactive trick to reduce the the size

381
00:13:11,350 --> 00:13:15,340
of the proofs so after logarithmically

382
00:13:13,060 --> 00:13:19,569
many rounds the verifiers will will

383
00:13:15,340 --> 00:13:21,280
accept or reject okay so the last thing

384
00:13:19,570 --> 00:13:22,930
i want to do is talk about an

385
00:13:21,280 --> 00:13:24,160
application of zero knowledge proof on

386
00:13:22,930 --> 00:13:25,930
distributed data

387
00:13:24,160 --> 00:13:29,410
to multi-party computation or in

388
00:13:25,930 --> 00:13:30,760
particular three party computation what

389
00:13:29,410 --> 00:13:33,040
we show is that for any arithmetic

390
00:13:30,760 --> 00:13:34,689
circuit you have over a field F there's

391
00:13:33,040 --> 00:13:36,610
a secure three party protocol for

392
00:13:34,690 --> 00:13:39,190
computing this circuit that tolerates

393
00:13:36,610 --> 00:13:41,380
one malicious party is computationally

394
00:13:39,190 --> 00:13:44,440
secure with abort and we make only

395
00:13:41,380 --> 00:13:46,330
blackbox use of a PRG for this and it

396
00:13:44,440 --> 00:13:48,520
has amortized communication cost one

397
00:13:46,330 --> 00:13:51,310
field element per party per gate in the

398
00:13:48,520 --> 00:13:52,600
circuit so this is interesting kind of

399
00:13:51,310 --> 00:13:54,489
for two reasons so one reason is it

400
00:13:52,600 --> 00:13:56,140
gives constant factor improvements over

401
00:13:54,490 --> 00:13:58,060
the communication complexity of Prior

402
00:13:56,140 --> 00:14:01,240
and PC protocols that satisfy these

403
00:13:58,060 --> 00:14:03,310
properties but more interesting is that

404
00:14:01,240 --> 00:14:05,620
with this work we essentially match the

405
00:14:03,310 --> 00:14:07,180
cost of the best three party computation

406
00:14:05,620 --> 00:14:09,850
protocols that only have semi honest

407
00:14:07,180 --> 00:14:11,530
security so you get malicious security

408
00:14:09,850 --> 00:14:12,820
for the cost of semi honest security

409
00:14:11,530 --> 00:14:16,480
essentially using these this

410
00:14:12,820 --> 00:14:19,120
transformation so I want to give you

411
00:14:16,480 --> 00:14:20,230
some sense of how we actually use these

412
00:14:19,120 --> 00:14:23,710
your knowledge groups on distributed

413
00:14:20,230 --> 00:14:26,350
data to get malicious secure NPC so our

414
00:14:23,710 --> 00:14:28,870
starting point is we take a semi honest

415
00:14:26,350 --> 00:14:31,450
NPC protocol that I'll call Phi that has

416
00:14:28,870 --> 00:14:32,620
two extra properties so this NPC

417
00:14:31,450 --> 00:14:34,870
protocol should have the property that

418
00:14:32,620 --> 00:14:37,210
the protocol reveals nothing is kind of

419
00:14:34,870 --> 00:14:39,940
perfectly secure until the players send

420
00:14:37,210 --> 00:14:41,590
their last messages and this should hold

421
00:14:39,940 --> 00:14:43,030
this kind of perfect security property

422
00:14:41,590 --> 00:14:44,950
should hold even if parties deviate from

423
00:14:43,030 --> 00:14:47,470
the protocol while they're executing it

424
00:14:44,950 --> 00:14:48,940
and furthermore that if the parties

425
00:14:47,470 --> 00:14:51,300
misbehave at the very last message the

426
00:14:48,940 --> 00:14:54,250
worst that can happen should be an abort

427
00:14:51,300 --> 00:14:55,990
the second property is that it should be

428
00:14:54,250 --> 00:14:58,390
a degree two protocol in the sense that

429
00:14:55,990 --> 00:15:00,400
every one of each player's messages

430
00:14:58,390 --> 00:15:02,680
should be a degree two function of their

431
00:15:00,400 --> 00:15:05,740
inputs their randomness and the messages

432
00:15:02,680 --> 00:15:06,969
that they've received so far these may

433
00:15:05,740 --> 00:15:08,890
seem like kind of onerous restrictions

434
00:15:06,970 --> 00:15:10,420
but it turns out that a number of the

435
00:15:08,890 --> 00:15:12,069
NPC protocols that are already in the

436
00:15:10,420 --> 00:15:14,140
literature satisfy these properties so

437
00:15:12,070 --> 00:15:17,410
I've mentioned two here but I'm sure

438
00:15:14,140 --> 00:15:19,780
that there's more so if we're given one

439
00:15:17,410 --> 00:15:21,010
semi honest NPC protocol that satisfies

440
00:15:19,780 --> 00:15:22,959
these properties I'm going to explain

441
00:15:21,010 --> 00:15:25,000
how we use distributed proofs on

442
00:15:22,960 --> 00:15:28,330
distributed data to sort of lift it into

443
00:15:25,000 --> 00:15:30,790
a malicious secure one the way this

444
00:15:28,330 --> 00:15:32,920
works is the players first run this

445
00:15:30,790 --> 00:15:34,990
malicious secure NPC amongst these three

446
00:15:32,920 --> 00:15:37,390
players but before they publish their

447
00:15:34,990 --> 00:15:37,740
last message they halt so they run the

448
00:15:37,390 --> 00:15:39,060
proto

449
00:15:37,740 --> 00:15:40,500
all the way to the very end but then

450
00:15:39,060 --> 00:15:43,589
stop before they publish their last

451
00:15:40,500 --> 00:15:46,530
message at this point the players each

452
00:15:43,590 --> 00:15:48,420
prove to each other that the messages

453
00:15:46,530 --> 00:15:50,790
they send so far complied with the

454
00:15:48,420 --> 00:15:52,740
protocol so in particular player one

455
00:15:50,790 --> 00:15:54,900
proves the players two and three the

456
00:15:52,740 --> 00:15:57,150
messages that I sent you observed the

457
00:15:54,900 --> 00:16:00,540
the protocol five that I did the right

458
00:15:57,150 --> 00:16:02,250
thing now notice this is a zero

459
00:16:00,540 --> 00:16:03,540
knowledge proof on distributed data this

460
00:16:02,250 --> 00:16:05,310
is what the tool that's called for

461
00:16:03,540 --> 00:16:08,189
because the message is that player one

462
00:16:05,310 --> 00:16:10,140
sent during this execution or were

463
00:16:08,190 --> 00:16:12,150
received by players two and three and

464
00:16:10,140 --> 00:16:13,350
player 2 doesn't know what player three

465
00:16:12,150 --> 00:16:15,270
received and player three doesn't know

466
00:16:13,350 --> 00:16:17,390
what to receive so these messages are

467
00:16:15,270 --> 00:16:19,860
kind of held in distributed fashion and

468
00:16:17,390 --> 00:16:22,170
because this protocol has the degree to

469
00:16:19,860 --> 00:16:23,820
property that I mentioned this language

470
00:16:22,170 --> 00:16:26,760
is actually recognized by a degree two

471
00:16:23,820 --> 00:16:28,200
circuit so player one completes this

472
00:16:26,760 --> 00:16:30,450
proof players two and three check the

473
00:16:28,200 --> 00:16:31,920
proof then player two proves the same

474
00:16:30,450 --> 00:16:33,900
thing two players one and three and

475
00:16:31,920 --> 00:16:35,550
players player three proves the same

476
00:16:33,900 --> 00:16:37,620
thing two players one and two so we do

477
00:16:35,550 --> 00:16:39,359
three of these proofs and the

478
00:16:37,620 --> 00:16:42,180
communication complexity of this step is

479
00:16:39,360 --> 00:16:43,290
is logarithmic in the size of the

480
00:16:42,180 --> 00:16:45,209
circuit so this is how many field

481
00:16:43,290 --> 00:16:46,860
elements are required and the reason

482
00:16:45,210 --> 00:16:48,420
that this is only a logarithmic cost is

483
00:16:46,860 --> 00:16:50,250
because of these new zero knowledge

484
00:16:48,420 --> 00:16:52,860
proof some distributed data for degree

485
00:16:50,250 --> 00:16:54,570
two relations that I mentioned so

486
00:16:52,860 --> 00:16:56,220
finally if all the proofs check out the

487
00:16:54,570 --> 00:16:57,930
players can reveal their last message

488
00:16:56,220 --> 00:17:01,500
from the underlying semi honest NPC and

489
00:16:57,930 --> 00:17:03,959
they get the output so just to give you

490
00:17:01,500 --> 00:17:06,810
a summary of what the cost is well there

491
00:17:03,960 --> 00:17:10,410
is C plus little of C messages from the

492
00:17:06,810 --> 00:17:12,750
underlying NPC protocol the proofs that

493
00:17:10,410 --> 00:17:15,090
the step of proving things to each other

494
00:17:12,750 --> 00:17:17,670
just required log C number of field

495
00:17:15,089 --> 00:17:19,560
elements so on average per party per

496
00:17:17,670 --> 00:17:22,710
gate we're looking at 1 plus little o of

497
00:17:19,560 --> 00:17:24,329
1 field elements and in the paper we go

498
00:17:22,710 --> 00:17:26,280
through a number of generalizations to

499
00:17:24,329 --> 00:17:28,439
say a constant number of parties with

500
00:17:26,280 --> 00:17:30,899
any honest majority or two arbitrary

501
00:17:28,440 --> 00:17:32,910
rings so if you want to work over 32-bit

502
00:17:30,900 --> 00:17:37,950
integers or 64-bit integers similar

503
00:17:32,910 --> 00:17:40,380
ideas apply for those of you who know a

504
00:17:37,950 --> 00:17:42,180
lot about MPC you know about the gmw

505
00:17:40,380 --> 00:17:43,800
compiler which is another way to go from

506
00:17:42,180 --> 00:17:46,470
a semi honest protocol to a malicious

507
00:17:43,800 --> 00:17:47,970
secure protocol I wanted to mention just

508
00:17:46,470 --> 00:17:50,640
a few of the the differences between

509
00:17:47,970 --> 00:17:51,630
these two approaches the first is that

510
00:17:50,640 --> 00:17:53,340
gmw use

511
00:17:51,630 --> 00:17:55,140
is message by message zero knowledge

512
00:17:53,340 --> 00:17:56,550
proof so with each step of the protocol

513
00:17:55,140 --> 00:17:58,380
every party proves said the other is

514
00:17:56,550 --> 00:18:00,930
that this next message I'm sending is

515
00:17:58,380 --> 00:18:02,730
actually well-formed what we do is we

516
00:18:00,930 --> 00:18:04,560
defer the proofs into the very end of

517
00:18:02,730 --> 00:18:06,780
the protocol and do use one big

518
00:18:04,560 --> 00:18:09,720
sublinear size proof for this one big

519
00:18:06,780 --> 00:18:11,160
statement at the end the second

520
00:18:09,720 --> 00:18:13,230
difference is the gmw requires

521
00:18:11,160 --> 00:18:14,880
commitments and therefore assumptions

522
00:18:13,230 --> 00:18:16,770
whereas the the compiler that i

523
00:18:14,880 --> 00:18:18,150
mentioned just now is information

524
00:18:16,770 --> 00:18:21,389
theoretically secure so you don't need

525
00:18:18,150 --> 00:18:23,400
any assumptions and then finally gmw

526
00:18:21,390 --> 00:18:25,140
requires that all players see all the

527
00:18:23,400 --> 00:18:26,340
messages because to verify a proof i

528
00:18:25,140 --> 00:18:28,650
kind of need to know what you sent to

529
00:18:26,340 --> 00:18:30,300
everybody else so this compiler makes

530
00:18:28,650 --> 00:18:32,070
the most sense in the setting in which

531
00:18:30,300 --> 00:18:34,320
players communicate over a broadcast

532
00:18:32,070 --> 00:18:36,629
channel whereas with these distributed

533
00:18:34,320 --> 00:18:38,310
zero knowledge proof the this compiler

534
00:18:36,630 --> 00:18:39,930
makes sense even when players only have

535
00:18:38,310 --> 00:18:41,340
point-to-point channels and that's

536
00:18:39,930 --> 00:18:42,660
because we're able to prove things about

537
00:18:41,340 --> 00:18:47,429
data that's held in distributed

538
00:18:42,660 --> 00:18:48,690
distributed fashion so this talk has

539
00:18:47,430 --> 00:18:50,580
been about these new zero knowledge

540
00:18:48,690 --> 00:18:52,200
proof saan distributed data and the

541
00:18:50,580 --> 00:18:53,879
setting again is one prover and many

542
00:18:52,200 --> 00:18:55,590
verifiers with each verify are having a

543
00:18:53,880 --> 00:18:57,120
different input and the goal of the

544
00:18:55,590 --> 00:18:59,129
protocol is really to hide each

545
00:18:57,120 --> 00:19:01,770
verifiers input from the other the

546
00:18:59,130 --> 00:19:03,660
others the proof systems we get out of

547
00:19:01,770 --> 00:19:06,629
this approach are information theoretic

548
00:19:03,660 --> 00:19:08,250
and lightweight and we construct them

549
00:19:06,630 --> 00:19:10,860
using this new tool tool called fully

550
00:19:08,250 --> 00:19:13,110
linear proof systems the applications I

551
00:19:10,860 --> 00:19:14,639
mentioned to MPC also two other types of

552
00:19:13,110 --> 00:19:15,929
privacy-preserving systems and we're

553
00:19:14,640 --> 00:19:18,990
hoping to many other systems in the

554
00:19:15,930 --> 00:19:20,850
future and I think there's still a bunch

555
00:19:18,990 --> 00:19:22,140
of work to do and comparing these proof

556
00:19:20,850 --> 00:19:23,189
systems and building them from other

557
00:19:22,140 --> 00:19:25,770
types of ideas in the cryptographic

558
00:19:23,190 --> 00:19:26,910
literature and also trying to understand

559
00:19:25,770 --> 00:19:29,550
the connections to other models of

560
00:19:26,910 --> 00:19:32,570
distributed proofs so with that happy to

561
00:19:29,550 --> 00:19:32,570
take your questions Thanks

562
00:19:37,970 --> 00:19:49,320
questions yes so can you extend this to

563
00:19:47,460 --> 00:19:51,630
the case well so the prover is trying to

564
00:19:49,320 --> 00:19:52,620
hide things from the verifies likely can

565
00:19:51,630 --> 00:19:54,180
you extend this is the case where

566
00:19:52,620 --> 00:19:55,679
there's also a witness yes yes

567
00:19:54,180 --> 00:19:56,910
absolutely okay but then you need some

568
00:19:55,680 --> 00:19:59,550
cryptographic of somebody's presumably

569
00:19:56,910 --> 00:20:02,460
bit if you want a sublinear proof size

570
00:19:59,550 --> 00:20:03,840
than you do but if you essentially what

571
00:20:02,460 --> 00:20:05,460
the prover can do is it can send the

572
00:20:03,840 --> 00:20:07,290
verifier shares of the witness and then

573
00:20:05,460 --> 00:20:08,520
you're looking at the essentially the

574
00:20:07,290 --> 00:20:16,830
same situation that we're looking at

575
00:20:08,520 --> 00:20:19,500
here thanks for the presentation I was

576
00:20:16,830 --> 00:20:21,500
wondering if you can comment on is there

577
00:20:19,500 --> 00:20:23,940
some kind of natural barrier if you are

578
00:20:21,500 --> 00:20:28,950
trying to apply this result to achieve

579
00:20:23,940 --> 00:20:30,330
dishonest majority MPC I think you would

580
00:20:28,950 --> 00:20:33,059
you would require a different set of

581
00:20:30,330 --> 00:20:34,889
techniques yeah because these

582
00:20:33,059 --> 00:20:36,120
information theoretic proof systems are

583
00:20:34,890 --> 00:20:37,860
not gonna not going to apply in that

584
00:20:36,120 --> 00:20:39,809
setting but yeah it's an interesting

585
00:20:37,860 --> 00:20:43,580
question about what what would work and

586
00:20:39,809 --> 00:20:43,580
what you could do along these lines

587
00:20:46,910 --> 00:20:50,220
okay let's engage weekend

588
00:20:49,470 --> 00:20:53,369
[Applause]

589
00:20:50,220 --> 00:20:53,369
[Music]

