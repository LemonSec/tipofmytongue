1
00:00:05,240 --> 00:00:11,070
hello hello alright alright so thank you

2
00:00:08,309 --> 00:00:12,928
very much for the introduction so this

3
00:00:11,070 --> 00:00:14,280
session is on cryptographic watermarking

4
00:00:12,929 --> 00:00:16,830
so let's begin by discussing what

5
00:00:14,280 --> 00:00:18,960
watermarking actually is so watermarking

6
00:00:16,830 --> 00:00:20,849
generally refers to a way of embedding a

7
00:00:18,960 --> 00:00:23,039
mark into some digital content like

8
00:00:20,850 --> 00:00:24,930
photos or images and this is often used

9
00:00:23,039 --> 00:00:26,850
for people to identify who the owner of

10
00:00:24,930 --> 00:00:28,198
the content is and also to prevent

11
00:00:26,850 --> 00:00:31,230
unauthorized distribution of this

12
00:00:28,199 --> 00:00:33,449
content so you may have seen a version

13
00:00:31,230 --> 00:00:36,090
of a photo or an image that has the word

14
00:00:33,449 --> 00:00:36,989
sample embedded on top of the photo so

15
00:00:36,090 --> 00:00:39,570
this is an example of a digital

16
00:00:36,989 --> 00:00:41,159
watermarking so if you look at this

17
00:00:39,570 --> 00:00:42,780
photo and if you really like this photo

18
00:00:41,159 --> 00:00:44,460
then you can pay the photographer and

19
00:00:42,780 --> 00:00:47,339
the photographer vide you with the

20
00:00:44,460 --> 00:00:49,409
original image that is not watermark so

21
00:00:47,339 --> 00:00:51,510
for these type of scenarios our

22
00:00:49,409 --> 00:00:52,970
watermarking scheme is useful only if it

23
00:00:51,510 --> 00:00:56,070
satisfies the following two properties

24
00:00:52,970 --> 00:00:58,049
well first it must be the case that even

25
00:00:56,070 --> 00:01:00,059
after embedded mark into some photo or

26
00:00:58,049 --> 00:01:02,400
an image most of its original content

27
00:01:00,059 --> 00:01:05,188
should still be viewable at the same

28
00:01:02,400 --> 00:01:07,260
time it should be very difficult for

29
00:01:05,188 --> 00:01:09,089
anyone to remove this watermark without

30
00:01:07,260 --> 00:01:10,830
security altering or essentially

31
00:01:09,090 --> 00:01:13,050
destroying the original content of the

32
00:01:10,830 --> 00:01:15,300
image so just like how we can talk about

33
00:01:13,050 --> 00:01:16,800
water marking for photos or images we

34
00:01:15,300 --> 00:01:19,649
can also talk about water marking for

35
00:01:16,800 --> 00:01:22,740
our software so in this scenario we want

36
00:01:19,650 --> 00:01:25,410
a way to embed a mark into some into

37
00:01:22,740 --> 00:01:27,000
some program or some piece of code while

38
00:01:25,410 --> 00:01:29,880
preserving the functionality of the

39
00:01:27,000 --> 00:01:32,190
program so we want mark circa we want

40
00:01:29,880 --> 00:01:35,158
the final marks program to still be

41
00:01:32,190 --> 00:01:36,600
executable is to still be executable and

42
00:01:35,159 --> 00:01:38,970
have the same input and output behavior

43
00:01:36,600 --> 00:01:40,830
as the original program but at the same

44
00:01:38,970 --> 00:01:42,810
time if an adversary comes along and

45
00:01:40,830 --> 00:01:44,158
gets access to this marked program they

46
00:01:42,810 --> 00:01:44,850
should be very difficult to remove this

47
00:01:44,159 --> 00:01:46,830
watermark

48
00:01:44,850 --> 00:01:48,390
without significantly altering or

49
00:01:46,830 --> 00:01:52,110
essentially destroying the original

50
00:01:48,390 --> 00:01:54,090
program so more formally we define a

51
00:01:52,110 --> 00:01:57,120
water marking scheme with respect to two

52
00:01:54,090 --> 00:01:58,710
algorithms so mark and verify the

53
00:01:57,120 --> 00:02:00,720
marking algorithm basically takes in the

54
00:01:58,710 --> 00:02:02,640
marking key and some program which we're

55
00:02:00,720 --> 00:02:03,990
gonna model as a circuit so it's going

56
00:02:02,640 --> 00:02:05,880
to take in a marking key and some

57
00:02:03,990 --> 00:02:07,860
circuit and some message and it will

58
00:02:05,880 --> 00:02:10,139
output some circuit C prime that has the

59
00:02:07,860 --> 00:02:11,730
message embedded inside it and the

60
00:02:10,139 --> 00:02:13,559
verification algorithm will take in some

61
00:02:11,730 --> 00:02:15,179
verification key and some circuits C

62
00:02:13,560 --> 00:02:16,560
prime and it will basically extract this

63
00:02:15,180 --> 00:02:18,390
message that's embedded inside the

64
00:02:16,560 --> 00:02:21,060
circuit or output bot

65
00:02:18,390 --> 00:02:23,760
so this is the syntax of a traditional

66
00:02:21,060 --> 00:02:25,220
message embedding watermarking scheme so

67
00:02:23,760 --> 00:02:28,649
for this talk though I'll focus on a

68
00:02:25,220 --> 00:02:29,730
simpler simpler a variant where the

69
00:02:28,650 --> 00:02:33,030
message to be embedded inside the

70
00:02:29,730 --> 00:02:34,500
circuit is just a binary stop it so all

71
00:02:33,030 --> 00:02:36,120
the circuits are either marked or

72
00:02:34,500 --> 00:02:39,480
unmarked so in this case the

73
00:02:36,120 --> 00:02:42,440
verification algorithm sorry the

74
00:02:39,480 --> 00:02:42,440
variation algorithm

75
00:03:36,459 --> 00:03:41,329
all right where was I yeah so so for

76
00:03:39,470 --> 00:03:44,540
this talk will focus on a simpler

77
00:03:41,329 --> 00:03:46,849
version of this of the water Marcos game

78
00:03:44,540 --> 00:03:48,260
where all the circuits are either marked

79
00:03:46,849 --> 00:03:50,268
or marked so the verification algorithm

80
00:03:48,260 --> 00:03:52,189
basically takes in a circuit and outputs

81
00:03:50,269 --> 00:03:55,280
0 or 1 depending on whether the circuit

82
00:03:52,189 --> 00:03:57,349
is marked or not so form so this is the

83
00:03:55,280 --> 00:03:59,420
syntax for this is the traditional

84
00:03:57,349 --> 00:04:00,409
syntax for our water marking scheme so

85
00:03:59,420 --> 00:04:02,958
what are some of the properties that

86
00:04:00,409 --> 00:04:04,640
these two operators are satisfied well

87
00:04:02,959 --> 00:04:06,799
the first property is functionally

88
00:04:04,640 --> 00:04:08,238
preserving which basically says that the

89
00:04:06,799 --> 00:04:09,739
mark circuit that's output by the

90
00:04:08,239 --> 00:04:11,690
marking algorithm should behave

91
00:04:09,739 --> 00:04:13,250
essentially like the original program so

92
00:04:11,690 --> 00:04:15,109
I should so how do we formalize this

93
00:04:13,250 --> 00:04:16,699
well we require that the input and

94
00:04:15,109 --> 00:04:18,918
output behavior of the marked and

95
00:04:16,699 --> 00:04:20,810
unmarked circuits to be the same on all

96
00:04:18,918 --> 00:04:23,659
but a negligible fraction of the inputs

97
00:04:20,810 --> 00:04:25,610
in the domain the second property is on

98
00:04:23,660 --> 00:04:27,979
removability which basically says that

99
00:04:25,610 --> 00:04:30,110
no efficient adversary who is given some

100
00:04:27,979 --> 00:04:32,508
mark circuit C prime can produce another

101
00:04:30,110 --> 00:04:34,490
circuit let's say C soda that have the

102
00:04:32,509 --> 00:04:36,410
same input that have almost exact same

103
00:04:34,490 --> 00:04:39,500
input and behavior input-output behavior

104
00:04:36,410 --> 00:04:41,210
as the mark circuit C prime but are the

105
00:04:39,500 --> 00:04:44,150
verification algorithm fails to detect

106
00:04:41,210 --> 00:04:45,620
it as a mark circuit all right so these

107
00:04:44,150 --> 00:04:47,479
are the form definitions for a

108
00:04:45,620 --> 00:04:49,099
watermarking scheme so let's see what we

109
00:04:47,479 --> 00:04:51,199
currently know about cryptographic

110
00:04:49,099 --> 00:04:52,969
watermarking well the first question

111
00:04:51,199 --> 00:04:55,030
that we should ask is you know what type

112
00:04:52,970 --> 00:04:57,320
of programs can we actually water mark

113
00:04:55,030 --> 00:04:58,789
can we actually construct a watermarking

114
00:04:57,320 --> 00:05:01,669
scheme that works over arbitrary

115
00:04:58,789 --> 00:05:04,280
programs and still satisfied functional

116
00:05:01,669 --> 00:05:06,590
preserving and on removability well it

117
00:05:04,280 --> 00:05:09,559
turns out that the answer is no the work

118
00:05:06,590 --> 00:05:11,090
of Kona tell in 2016 so the water

119
00:05:09,560 --> 00:05:13,039
marking is actually impossible for a

120
00:05:11,090 --> 00:05:14,448
large class of programs specifically

121
00:05:13,039 --> 00:05:16,699
programs that implement learn about

122
00:05:14,449 --> 00:05:18,320
functions so functions whose canonical

123
00:05:16,699 --> 00:05:19,789
representation can be easily deduced

124
00:05:18,320 --> 00:05:23,180
from the implant output behavior of the

125
00:05:19,789 --> 00:05:24,830
functions so due to this impossibility

126
00:05:23,180 --> 00:05:26,750
a lot of the research effort in this

127
00:05:24,830 --> 00:05:28,159
area has focused on constructing a

128
00:05:26,750 --> 00:05:30,590
watermarking scheme for cryptographic

129
00:05:28,159 --> 00:05:32,000
functions programs that implement

130
00:05:30,590 --> 00:05:33,619
cryptographic functions because

131
00:05:32,000 --> 00:05:35,690
cryptographic functions represent a

132
00:05:33,620 --> 00:05:38,060
large class of learn about unlearn about

133
00:05:35,690 --> 00:05:41,479
our functions so in this talk we'll also

134
00:05:38,060 --> 00:05:43,010
focus on water or constructing a water

135
00:05:41,479 --> 00:05:44,690
marking scheme for cryptographic

136
00:05:43,010 --> 00:05:46,550
functions and specifically for

137
00:05:44,690 --> 00:05:48,139
pseudo-random functions so in the next

138
00:05:46,550 --> 00:05:49,580
stop you'll hear more about

139
00:05:48,139 --> 00:05:51,770
how we go about constructing a

140
00:05:49,580 --> 00:05:55,128
watermarking scheme for other Couture

141
00:05:51,770 --> 00:05:57,529
functions like digital signatures or for

142
00:05:55,129 --> 00:05:59,509
public key encryption schemes all right

143
00:05:57,529 --> 00:06:03,080
so what's also what do we currently know

144
00:05:59,509 --> 00:06:05,330
about watermarking for our PRS well the

145
00:06:03,080 --> 00:06:07,430
first positive result came in 2016 by

146
00:06:05,330 --> 00:06:08,719
the work of coin at Tao who basically

147
00:06:07,430 --> 00:06:10,430
showed that using an

148
00:06:08,719 --> 00:06:12,680
indistinguishability obfuscator and

149
00:06:10,430 --> 00:06:15,830
one-way functions we can watermark a

150
00:06:12,680 --> 00:06:17,389
large class of PR apps and a very nice

151
00:06:15,830 --> 00:06:19,490
property of the construction was that

152
00:06:17,389 --> 00:06:21,650
the resulting watermarking scheme was

153
00:06:19,490 --> 00:06:22,909
actually publicly verifiable so this

154
00:06:21,650 --> 00:06:24,799
meant that all the users in the system

155
00:06:22,909 --> 00:06:26,960
can have access to a public verification

156
00:06:24,800 --> 00:06:29,689
key and run the verification algorithm

157
00:06:26,960 --> 00:06:31,400
themselves which is a really nice

158
00:06:29,689 --> 00:06:34,009
property to have for most applications

159
00:06:31,400 --> 00:06:35,659
of a watermarking scheme so a natural

160
00:06:34,009 --> 00:06:37,159
question they followed from their work

161
00:06:35,659 --> 00:06:39,438
was whether we can construct a

162
00:06:37,159 --> 00:06:43,580
watermarking scheme for PRF just relying

163
00:06:39,439 --> 00:06:46,039
on standard assumptions so in 2017 are

164
00:06:43,580 --> 00:06:46,609
Kim and woo showed that this can indeed

165
00:06:46,039 --> 00:06:48,560
be done

166
00:06:46,610 --> 00:06:50,870
they basically constructed water

167
00:06:48,560 --> 00:06:52,129
mockable family of PRF just relying on

168
00:06:50,870 --> 00:06:54,529
standard of learning with errors

169
00:06:52,129 --> 00:06:56,629
assumption and in contrast to the cornet

170
00:06:54,529 --> 00:06:58,909
tower construction the construction of

171
00:06:56,629 --> 00:07:01,250
Kim young-woo was a privately verifiable

172
00:06:58,909 --> 00:07:02,509
watermarking scheme so since this

173
00:07:01,250 --> 00:07:04,639
distinction will be relevant for

174
00:07:02,509 --> 00:07:07,399
explaining our result let me just

175
00:07:04,639 --> 00:07:10,129
quickly compare the two settings with

176
00:07:07,399 --> 00:07:13,009
pictures so in a publicly verifiable

177
00:07:10,129 --> 00:07:14,629
setting all the users in the system can

178
00:07:13,009 --> 00:07:16,819
have access to a public verification key

179
00:07:14,629 --> 00:07:18,050
so if they have some circuits C prime

180
00:07:16,819 --> 00:07:20,060
that he wants to check whether its

181
00:07:18,050 --> 00:07:21,830
marked or marked you can just look up a

182
00:07:20,060 --> 00:07:23,779
public verification key from some cloud

183
00:07:21,830 --> 00:07:26,419
and just run the verification algorithm

184
00:07:23,779 --> 00:07:29,149
themselves so in a private variable

185
00:07:26,419 --> 00:07:30,889
verifiability setting the verification

186
00:07:29,149 --> 00:07:32,629
key are for the watermarking team have

187
00:07:30,889 --> 00:07:35,389
to be kept private from all the users in

188
00:07:32,629 --> 00:07:37,430
the system so if a user has some circuit

189
00:07:35,389 --> 00:07:39,409
as that he wants to check whether it is

190
00:07:37,430 --> 00:07:41,029
marked or mark it has to go to some

191
00:07:39,409 --> 00:07:43,819
verifying Authority who would run the

192
00:07:41,029 --> 00:07:46,879
verification algorithm for the user so

193
00:07:43,819 --> 00:07:48,229
this a private a verifiability setting

194
00:07:46,879 --> 00:07:49,939
is a weaker than the public

195
00:07:48,229 --> 00:07:51,949
verifiability setting but it's still

196
00:07:49,939 --> 00:07:54,409
useful for a lot of the applications of

197
00:07:51,949 --> 00:07:56,959
watermarking scheme so this is basically

198
00:07:54,409 --> 00:07:58,969
how the landscape look like in 2017 so

199
00:07:56,959 --> 00:08:00,800
we had a privately verifiable

200
00:07:58,969 --> 00:08:01,219
watermarking scheme from their learning

201
00:08:00,800 --> 00:08:02,810
with air

202
00:08:01,220 --> 00:08:04,520
assumption and we had a publicly

203
00:08:02,810 --> 00:08:06,470
verifiable watermarking scheme from

204
00:08:04,520 --> 00:08:08,120
autistic asian and i guess the big

205
00:08:06,470 --> 00:08:09,830
driving question in this area was

206
00:08:08,120 --> 00:08:11,690
whether we could go from a privately

207
00:08:09,830 --> 00:08:13,580
verifiable our watermarking scheme to a

208
00:08:11,690 --> 00:08:17,060
publicly verifiable watermarking scheme

209
00:08:13,580 --> 00:08:19,190
just relying on standard assumptions so

210
00:08:17,060 --> 00:08:21,560
i'll just last year there was a very

211
00:08:19,190 --> 00:08:24,350
nice work due to our clash wigs and

212
00:08:21,560 --> 00:08:26,210
xored ellis who basically constructed a

213
00:08:24,350 --> 00:08:28,160
privately verifiable watermarking scheme

214
00:08:26,210 --> 00:08:31,359
just using CCA secure encryption scheme

215
00:08:28,160 --> 00:08:34,490
and also a privately puncture about PRF

216
00:08:31,360 --> 00:08:37,610
so they basically showed that just

217
00:08:34,490 --> 00:08:39,740
relying on CCA secure encryption scheme

218
00:08:37,610 --> 00:08:41,479
and a privately function PRF then you

219
00:08:39,740 --> 00:08:43,039
construct a watermarking scheme for PRF

220
00:08:41,479 --> 00:08:45,230
that achieves a much stronger security

221
00:08:43,039 --> 00:08:48,110
guarantee then the construction of Kim

222
00:08:45,230 --> 00:08:50,150
angle so recall that in the private

223
00:08:48,110 --> 00:08:52,100
verifiability setting all the users in

224
00:08:50,150 --> 00:08:54,050
the system have to go to a central go to

225
00:08:52,100 --> 00:08:56,720
a verifying authority to check whether a

226
00:08:54,050 --> 00:08:58,459
circuit is marked or marked so well in

227
00:08:56,720 --> 00:09:00,350
the key mu construction if there was

228
00:08:58,460 --> 00:09:01,940
some malicious user in the system with

229
00:09:00,350 --> 00:09:03,170
arbitrary access to a verifying

230
00:09:01,940 --> 00:09:05,270
authority who would act as a

231
00:09:03,170 --> 00:09:07,670
verification Oracle to the to other user

232
00:09:05,270 --> 00:09:11,660
then security was actually compromised

233
00:09:07,670 --> 00:09:13,430
so if so malicious user can cook up some

234
00:09:11,660 --> 00:09:15,709
circuit and send it over to the verifier

235
00:09:13,430 --> 00:09:18,130
and the verify response with other

236
00:09:15,710 --> 00:09:20,270
marked or unmarked and the users are

237
00:09:18,130 --> 00:09:22,100
constructs another circuit and another

238
00:09:20,270 --> 00:09:24,829
circuit is amiss another circuit and so

239
00:09:22,100 --> 00:09:26,480
on then after some point the malicious

240
00:09:24,830 --> 00:09:28,610
user in the system can get enough

241
00:09:26,480 --> 00:09:32,000
information to remove to remove any mark

242
00:09:28,610 --> 00:09:33,650
from any mark circuit so in the setting

243
00:09:32,000 --> 00:09:36,380
of proof systems this is sometimes

244
00:09:33,650 --> 00:09:37,819
called a verify rejection problem so for

245
00:09:36,380 --> 00:09:40,010
the setting of watermarking this is

246
00:09:37,820 --> 00:09:41,300
actually not so much of a problem for a

247
00:09:40,010 --> 00:09:43,339
lot of the applications where

248
00:09:41,300 --> 00:09:47,719
verification can be done less frequently

249
00:09:43,339 --> 00:09:49,160
like in in legal disputes and so on but

250
00:09:47,720 --> 00:09:51,110
this is still not a good property to

251
00:09:49,160 --> 00:09:54,620
have for you know many other for most

252
00:09:51,110 --> 00:09:56,690
other applications so the qwz

253
00:09:54,620 --> 00:09:58,370
construction basics basically completely

254
00:09:56,690 --> 00:10:00,290
remove this verify rejection problem

255
00:09:58,370 --> 00:10:01,550
from the original kimu construction

256
00:10:00,290 --> 00:10:03,079
which is really nice and the

257
00:10:01,550 --> 00:10:05,510
construction is also quite simple and

258
00:10:03,080 --> 00:10:09,170
quite clever so I think I courage

259
00:10:05,510 --> 00:10:11,959
everyone to read their paper I guess the

260
00:10:09,170 --> 00:10:13,180
the Kido busy construction had some of

261
00:10:11,959 --> 00:10:16,060
its own caviar

262
00:10:13,180 --> 00:10:18,420
however and this is related to the

263
00:10:16,060 --> 00:10:24,579
security against the verifying Authority

264
00:10:18,420 --> 00:10:27,370
so so so the PRF family that q WC that

265
00:10:24,580 --> 00:10:29,440
ik+ construct is a perfectly fine PRF it

266
00:10:27,370 --> 00:10:31,360
is a secure PRF against any users in the

267
00:10:29,440 --> 00:10:34,120
system who does not have access to a

268
00:10:31,360 --> 00:10:35,470
verification key but to the verifying

269
00:10:34,120 --> 00:10:37,600
Authority who has access to the

270
00:10:35,470 --> 00:10:40,750
verification key that a pure family was

271
00:10:37,600 --> 00:10:42,280
completely insecure so the verification

272
00:10:40,750 --> 00:10:43,960
key that the authority has basically

273
00:10:42,280 --> 00:10:45,850
acts as a trapdoor or some backdoor

274
00:10:43,960 --> 00:10:48,250
information to the PRF that currently

275
00:10:45,850 --> 00:10:51,250
compromises that security of the PRF

276
00:10:48,250 --> 00:10:53,800
family so it's actually important to

277
00:10:51,250 --> 00:10:57,520
kind of understand this sort of point so

278
00:10:53,800 --> 00:10:59,410
for Marc circus it's actually as remark

279
00:10:57,520 --> 00:11:00,939
circuits are satisfying this traditional

280
00:10:59,410 --> 00:11:02,350
notion of pseudo randomness against the

281
00:11:00,940 --> 00:11:06,250
verifying Authority is actually

282
00:11:02,350 --> 00:11:07,720
impossible well first the kadar

283
00:11:06,250 --> 00:11:09,520
watermarking authority needs access to

284
00:11:07,720 --> 00:11:11,530
the PRF key in order to our watermark

285
00:11:09,520 --> 00:11:13,569
the circuit and second the verification

286
00:11:11,530 --> 00:11:15,569
algorithm itself becomes a distinguisher

287
00:11:13,570 --> 00:11:18,340
for the underlying unmarked circuit

288
00:11:15,570 --> 00:11:20,020
however for unmarked circuits they use

289
00:11:18,340 --> 00:11:21,760
however one work circuit should still

290
00:11:20,020 --> 00:11:25,810
satisfy some level of pseudo randomness

291
00:11:21,760 --> 00:11:28,270
against the verifying Authority so if a

292
00:11:25,810 --> 00:11:29,739
user in the system just happens to if

293
00:11:28,270 --> 00:11:31,240
the user in the system generates its own

294
00:11:29,740 --> 00:11:31,870
PRF key and uses it for different

295
00:11:31,240 --> 00:11:34,120
purposes

296
00:11:31,870 --> 00:11:35,710
but there's not water mark this PRF then

297
00:11:34,120 --> 00:11:39,280
this PRF should still be pseudo-random

298
00:11:35,710 --> 00:11:42,490
to the authority who has who has access

299
00:11:39,280 --> 00:11:44,079
to the verification key and in fact even

300
00:11:42,490 --> 00:11:45,400
for unmarked even for mark circuits

301
00:11:44,080 --> 00:11:47,980
security against the authority is

302
00:11:45,400 --> 00:11:50,110
actually well-defined so we can consider

303
00:11:47,980 --> 00:11:51,790
a scenario where the marking procedure

304
00:11:50,110 --> 00:11:53,590
is done by a secure two-party

305
00:11:51,790 --> 00:11:56,349
complication between the authority and

306
00:11:53,590 --> 00:11:58,600
the user so the marking Authority can

307
00:11:56,350 --> 00:12:00,400
send in a marking key and the user in

308
00:11:58,600 --> 00:12:02,590
the system automates the circuit that it

309
00:12:00,400 --> 00:12:04,540
wants to get at Walmart in this scenario

310
00:12:02,590 --> 00:12:06,130
the verifying authority actually never

311
00:12:04,540 --> 00:12:08,949
learns the PRF key of the users in the

312
00:12:06,130 --> 00:12:10,510
system so so security against the

313
00:12:08,950 --> 00:12:12,310
authority is actually well-defined for

314
00:12:10,510 --> 00:12:14,080
Mark's circuits and due to the

315
00:12:12,310 --> 00:12:15,939
verification algorithm strong pseudo

316
00:12:14,080 --> 00:12:18,070
randomness against the authority is

317
00:12:15,940 --> 00:12:19,600
actually not well-defined but mark

318
00:12:18,070 --> 00:12:21,460
circuits can still be a secure a

319
00:12:19,600 --> 00:12:25,060
perfectly fine weak PRF against the

320
00:12:21,460 --> 00:12:28,240
authority okay so

321
00:12:25,060 --> 00:12:29,800
and I guess big prf still services for a

322
00:12:28,240 --> 00:12:31,510
lot of the applications it's a magical

323
00:12:29,800 --> 00:12:34,689
talk cryptography like symmetric

324
00:12:31,510 --> 00:12:39,250
encryption alright so this is basically

325
00:12:34,690 --> 00:12:41,200
our where our work comes in so in this

326
00:12:39,250 --> 00:12:43,510
work we construct a new privately

327
00:12:41,200 --> 00:12:45,130
verifiable watermarking scheme from PRF

328
00:12:43,510 --> 00:12:47,770
from the standard are learning with

329
00:12:45,130 --> 00:12:49,840
errors assumption so we basically remove

330
00:12:47,770 --> 00:12:51,819
this verify rejection problem that was

331
00:12:49,840 --> 00:12:55,090
evident in the Camus construction just

332
00:12:51,820 --> 00:12:56,890
like the qwc construction and are the

333
00:12:55,090 --> 00:12:59,050
pure family that we construct is

334
00:12:56,890 --> 00:13:00,699
actually the guarantee has some security

335
00:12:59,050 --> 00:13:03,310
against the verifying Authority in

336
00:13:00,700 --> 00:13:04,840
particular we can provide the PRF family

337
00:13:03,310 --> 00:13:08,469
can provide a weak pseudo randomness

338
00:13:04,840 --> 00:13:09,820
against the authority so actually we the

339
00:13:08,470 --> 00:13:12,250
PRI family that we construct actually

340
00:13:09,820 --> 00:13:13,690
satisfies a stronger stronger secure

341
00:13:12,250 --> 00:13:16,690
definition called he restrict this to

342
00:13:13,690 --> 00:13:19,330
the randomness but for this talk I will

343
00:13:16,690 --> 00:13:21,370
not define what this is so I refer to

344
00:13:19,330 --> 00:13:24,250
the paper for the specific definition

345
00:13:21,370 --> 00:13:26,320
and I guess a nice property of a

346
00:13:24,250 --> 00:13:28,660
construction is that the security relies

347
00:13:26,320 --> 00:13:31,500
on a much weaker a variant of the LTP

348
00:13:28,660 --> 00:13:34,180
assumption compared to previous works so

349
00:13:31,500 --> 00:13:36,070
so the security of a construction relies

350
00:13:34,180 --> 00:13:38,439
on approximately on the hardness of a

351
00:13:36,070 --> 00:13:40,240
pass mating short on worst-case notice

352
00:13:38,440 --> 00:13:42,220
problems to only nearly polynomial

353
00:13:40,240 --> 00:13:44,260
approximation factors while in previous

354
00:13:42,220 --> 00:13:48,220
works are we needed a sabich's financial

355
00:13:44,260 --> 00:13:50,140
approximation factors so along the way

356
00:13:48,220 --> 00:13:51,820
of achieving these results we define

357
00:13:50,140 --> 00:13:54,130
this new abstraction called extractable

358
00:13:51,820 --> 00:13:55,810
PRF which we think is also a very

359
00:13:54,130 --> 00:13:57,550
natural notion and when which we believe

360
00:13:55,810 --> 00:13:59,140
is of independent interest for future

361
00:13:57,550 --> 00:14:01,240
works all right

362
00:13:59,140 --> 00:14:02,890
so in the last few minutes that I have

363
00:14:01,240 --> 00:14:05,890
let me just give a quick overview of

364
00:14:02,890 --> 00:14:07,720
what we do at a technical level so I

365
00:14:05,890 --> 00:14:11,140
guess as in previous works I rely on

366
00:14:07,720 --> 00:14:12,880
this object called punctual PRF which is

367
00:14:11,140 --> 00:14:14,860
just like a standard PRF but they have

368
00:14:12,880 --> 00:14:17,350
but it has this a puncturing algorithm

369
00:14:14,860 --> 00:14:19,510
that basically takes in standard PRF key

370
00:14:17,350 --> 00:14:21,940
and punctures it at some specific point

371
00:14:19,510 --> 00:14:24,310
let's say X star to derive us new

372
00:14:21,940 --> 00:14:26,020
puncture key and this punker key can be

373
00:14:24,310 --> 00:14:27,790
used to evaluate the PRF on all points

374
00:14:26,020 --> 00:14:30,760
in the domain except for at this

375
00:14:27,790 --> 00:14:32,680
puncture point and in addition to the

376
00:14:30,760 --> 00:14:34,840
traditional definition in addition to

377
00:14:32,680 --> 00:14:37,089
the traditional requirements of punctual

378
00:14:34,840 --> 00:14:38,540
PRF we can define an additional set of

379
00:14:37,090 --> 00:14:40,850
properties that's useful for

380
00:14:38,540 --> 00:14:42,410
watermarking so we can first define this

381
00:14:40,850 --> 00:14:44,330
notion of private puncturing which

382
00:14:42,410 --> 00:14:46,490
basically says that the puncture key

383
00:14:44,330 --> 00:14:49,100
does not reveal any information about

384
00:14:46,490 --> 00:14:50,360
the point that it's punctured at and we

385
00:14:49,100 --> 00:14:51,320
can also define this notion of

386
00:14:50,360 --> 00:14:53,180
programmability

387
00:14:51,320 --> 00:14:55,280
which basically says that given some

388
00:14:53,180 --> 00:14:57,500
specific output as a y star a

389
00:14:55,280 --> 00:14:59,689
functioning algorithm can puncture a key

390
00:14:57,500 --> 00:15:01,700
such that the pure evaluation at the

391
00:14:59,690 --> 00:15:05,480
puncture point basically evaluates

392
00:15:01,700 --> 00:15:07,100
exactly to a Y star so if you had a

393
00:15:05,480 --> 00:15:09,260
puncture what PRF that basically

394
00:15:07,100 --> 00:15:10,280
satisfies all of these properties there

395
00:15:09,260 --> 00:15:13,280
is actually well to be straightforward

396
00:15:10,280 --> 00:15:14,870
to construct a watermarking scheme to

397
00:15:13,280 --> 00:15:18,319
actually well to straight forward to

398
00:15:14,870 --> 00:15:20,060
watermarks such a PRF so we can

399
00:15:18,320 --> 00:15:21,620
basically define this watermarking

400
00:15:20,060 --> 00:15:23,900
algorithm to basically just puncture the

401
00:15:21,620 --> 00:15:25,430
PRF in a specific way so what the

402
00:15:23,900 --> 00:15:27,740
marking algorithm will do is it will

403
00:15:25,430 --> 00:15:30,079
take in appeareth key to our watermark

404
00:15:27,740 --> 00:15:32,450
you derive this special as input and

405
00:15:30,080 --> 00:15:34,580
output pair X star and y star and it

406
00:15:32,450 --> 00:15:36,730
will just puncture the PRF key such that

407
00:15:34,580 --> 00:15:41,060
the pure evaluation at this point X star

408
00:15:36,730 --> 00:15:43,130
outputs our Y star and the verification

409
00:15:41,060 --> 00:15:44,780
algorithm is quite simple it would given

410
00:15:43,130 --> 00:15:46,730
some circuit it will just derive this

411
00:15:44,780 --> 00:15:48,439
input and output pair are the specific

412
00:15:46,730 --> 00:15:51,230
input and output pair and just test it

413
00:15:48,440 --> 00:15:54,170
the circuit evaluates to Y star on input

414
00:15:51,230 --> 00:15:56,270
X star so if you don't care about this

415
00:15:54,170 --> 00:16:00,050
verify rejection problems and this is

416
00:15:56,270 --> 00:16:03,110
actually perfectly fine oops this is a

417
00:16:00,050 --> 00:16:05,839
perfect this is a perfectly fine PRF

418
00:16:03,110 --> 00:16:07,640
perfectly fine or watermarking scheme

419
00:16:05,840 --> 00:16:10,010
for other PRF

420
00:16:07,640 --> 00:16:12,140
so basically the security relies on the

421
00:16:10,010 --> 00:16:13,819
fact that the point X star others the

422
00:16:12,140 --> 00:16:15,860
special point X star is remained hidden

423
00:16:13,820 --> 00:16:19,520
from the adversary which is guaranteed

424
00:16:15,860 --> 00:16:21,200
by privately puncture about PRF so but

425
00:16:19,520 --> 00:16:23,720
however if the adversary has access to

426
00:16:21,200 --> 00:16:25,670
the verification Oracle then even if you

427
00:16:23,720 --> 00:16:27,320
use a privately functionable PRF the

428
00:16:25,670 --> 00:16:29,930
special point X star is completely

429
00:16:27,320 --> 00:16:32,630
revealed by the adversary revealed to

430
00:16:29,930 --> 00:16:34,969
the adversary so what the adversary can

431
00:16:32,630 --> 00:16:37,640
do is do this binary search attack where

432
00:16:34,970 --> 00:16:40,130
it can just given some PRF circuit it

433
00:16:37,640 --> 00:16:41,870
can just change half of the inputs half

434
00:16:40,130 --> 00:16:43,700
of the app the outputs of half of its

435
00:16:41,870 --> 00:16:46,820
input and just submit it to the verifier

436
00:16:43,700 --> 00:16:49,250
and depending on the output of the

437
00:16:46,820 --> 00:16:51,680
verification Oracle the average the

438
00:16:49,250 --> 00:16:54,170
adversary can tell whether this

439
00:16:51,680 --> 00:16:57,680
extar lies in the modified set or the

440
00:16:54,170 --> 00:16:59,449
unmodified set okay and so by each by

441
00:16:57,680 --> 00:17:01,670
making a call to the verification or

442
00:16:59,449 --> 00:17:04,398
call the adversary is able to roll out a

443
00:17:01,670 --> 00:17:07,099
half of the inputs for which X star does

444
00:17:04,398 --> 00:17:08,809
not contain it and so the wave so the

445
00:17:07,099 --> 00:17:11,719
adversary can repeat this procedure over

446
00:17:08,809 --> 00:17:13,490
and over again and each time it can rule

447
00:17:11,720 --> 00:17:16,959
out half of the input and at the end

448
00:17:13,490 --> 00:17:21,020
eventually leak the special point X star

449
00:17:16,959 --> 00:17:22,610
and so the question so the question that

450
00:17:21,020 --> 00:17:25,579
that's the first question that we asked

451
00:17:22,609 --> 00:17:27,829
and in this work is you know can we

452
00:17:25,579 --> 00:17:29,809
actually force an adversary to rule that

453
00:17:27,829 --> 00:17:31,340
only a small fraction of the inputs so

454
00:17:29,809 --> 00:17:33,559
is there a statistical test that the

455
00:17:31,340 --> 00:17:35,120
verification algorithm can run to force

456
00:17:33,559 --> 00:17:36,980
the adversary to rule out only a very

457
00:17:35,120 --> 00:17:38,629
small fraction of the inputs such that

458
00:17:36,980 --> 00:17:42,799
an efficient adversary cannot rule out

459
00:17:38,630 --> 00:17:44,510
cannot efficiently rule out now

460
00:17:42,799 --> 00:17:47,480
officially rule out a large fraction of

461
00:17:44,510 --> 00:17:52,669
the inputs in in efficiently to recover

462
00:17:47,480 --> 00:17:55,039
X star all right so so this is where our

463
00:17:52,669 --> 00:17:57,799
new notion of extractable PRF comes in

464
00:17:55,039 --> 00:18:00,080
so technically this extractable PRF is

465
00:17:57,799 --> 00:18:01,429
an independent notion so independent

466
00:18:00,080 --> 00:18:03,590
ocean that is separate from the function

467
00:18:01,429 --> 00:18:05,840
what PRF but but for this talk let me

468
00:18:03,590 --> 00:18:07,340
just explain it as an additional

469
00:18:05,840 --> 00:18:10,730
property that we can add on to a

470
00:18:07,340 --> 00:18:12,470
puncture above PRF so we say that a

471
00:18:10,730 --> 00:18:16,100
function above your app is extractable

472
00:18:12,470 --> 00:18:17,779
if there exists a special point of Z for

473
00:18:16,100 --> 00:18:19,490
which if you evaluate the PRF on the

474
00:18:17,779 --> 00:18:22,279
special point then it gives you an

475
00:18:19,490 --> 00:18:26,000
encoding of the original PRF Quique okay

476
00:18:22,279 --> 00:18:27,740
so if you know this special point RZ and

477
00:18:26,000 --> 00:18:29,630
you're given a PRF circuit that you can

478
00:18:27,740 --> 00:18:31,970
evaluate the PRF on the special point C

479
00:18:29,630 --> 00:18:35,059
and I'll get some information about the

480
00:18:31,970 --> 00:18:37,490
original PRF G K so this encoding of the

481
00:18:35,059 --> 00:18:38,990
PRF GK is still pseudo-random to anyone

482
00:18:37,490 --> 00:18:40,850
in the system who does not have access

483
00:18:38,990 --> 00:18:45,470
to a trapdoor information for the PRF

484
00:18:40,850 --> 00:18:47,600
but - but but with access to a PRF at

485
00:18:45,470 --> 00:18:49,880
access to a trapdoor also say with the

486
00:18:47,600 --> 00:18:51,649
PRF you can completely recover the

487
00:18:49,880 --> 00:18:57,649
original PRF key that's associated with

488
00:18:51,649 --> 00:19:00,469
the extractable PRF exact about PRF okay

489
00:18:57,649 --> 00:19:03,649
and I guess our plan is to basically

490
00:19:00,470 --> 00:19:05,730
encode this basically moved this special

491
00:19:03,649 --> 00:19:07,469
point Z and this trapdoor

492
00:19:05,730 --> 00:19:09,450
information to a watermarking

493
00:19:07,470 --> 00:19:10,500
verification key such that the water so

494
00:19:09,450 --> 00:19:11,940
that such that the verification

495
00:19:10,500 --> 00:19:15,120
algorithm for the water marking scheme

496
00:19:11,940 --> 00:19:17,429
can extract this construct the original

497
00:19:15,120 --> 00:19:19,168
PRF key and run some verification run

498
00:19:17,429 --> 00:19:22,559
some statistical tests on the

499
00:19:19,169 --> 00:19:25,200
adversaries verification queries all

500
00:19:22,559 --> 00:19:27,210
right so so this is basically our it's a

501
00:19:25,200 --> 00:19:29,610
water marking scheme so if you had an

502
00:19:27,210 --> 00:19:31,799
extraction if you had extract or PRF

503
00:19:29,610 --> 00:19:33,629
then we can actually construct the water

504
00:19:31,799 --> 00:19:35,940
marking scheme as follows so the marking

505
00:19:33,630 --> 00:19:37,710
algorithm basically remains the same as

506
00:19:35,940 --> 00:19:39,690
before it will basically derived a

507
00:19:37,710 --> 00:19:41,909
special input and output pair X star and

508
00:19:39,690 --> 00:19:44,460
Y star and just program this input and

509
00:19:41,909 --> 00:19:46,470
output pair to a truth table of the PRF

510
00:19:44,460 --> 00:19:48,840
and the verification algorithm also

511
00:19:46,470 --> 00:19:50,760
stays the same so we basically our test

512
00:19:48,840 --> 00:19:52,559
it derives this special input and output

513
00:19:50,760 --> 00:19:55,919
pair and test whether the circuit

514
00:19:52,559 --> 00:19:58,019
evaluates to Y star on import X star but

515
00:19:55,919 --> 00:20:00,389
since we're using an extractable PRF

516
00:19:58,019 --> 00:20:02,340
this verification algorithm will run

517
00:20:00,389 --> 00:20:04,889
some step or some additional statistical

518
00:20:02,340 --> 00:20:08,070
tests on the adversaries queries to the

519
00:20:04,889 --> 00:20:11,519
verification Oracle alright so it will

520
00:20:08,070 --> 00:20:14,100
first on given a circuit to verify it

521
00:20:11,519 --> 00:20:15,960
will basically extract this extract the

522
00:20:14,100 --> 00:20:18,240
original PRF key that's associated with

523
00:20:15,960 --> 00:20:20,669
the circuit using this information of

524
00:20:18,240 --> 00:20:23,279
chat door ok and you basically run a

525
00:20:20,669 --> 00:20:24,480
statistical test to see if the circuit

526
00:20:23,279 --> 00:20:27,059
that is inputted to the verification

527
00:20:24,480 --> 00:20:29,880
algorithm and the PRF that's that's

528
00:20:27,059 --> 00:20:32,510
defined by the PRF key to be similar to

529
00:20:29,880 --> 00:20:35,250
have similar input and output behavior

530
00:20:32,510 --> 00:20:38,250
okay and other verification algorithm

531
00:20:35,250 --> 00:20:40,289
will basically accept the circuit as a

532
00:20:38,250 --> 00:20:43,919
mark circuit if only if both of these

533
00:20:40,289 --> 00:20:46,019
conditions are satisfied now the very

534
00:20:43,919 --> 00:20:48,750
now the adversary cannot actually run

535
00:20:46,019 --> 00:20:50,929
this binary search algorithm an airy

536
00:20:48,750 --> 00:20:53,429
search attack because if the adversary

537
00:20:50,929 --> 00:20:56,399
changed it modifies the output on half

538
00:20:53,429 --> 00:20:58,559
of the input then our first then either

539
00:20:56,399 --> 00:21:00,389
the variant of key works then either the

540
00:20:58,559 --> 00:21:02,720
key extraction will fail in which case

541
00:21:00,389 --> 00:21:05,519
the wave action algorithm will output 0

542
00:21:02,720 --> 00:21:07,230
or the extract the key extraction was

543
00:21:05,519 --> 00:21:10,139
the seed and will be able to detect

544
00:21:07,230 --> 00:21:12,419
whether the circuit a see the first from

545
00:21:10,139 --> 00:21:15,629
the PR from the original PRF on a

546
00:21:12,419 --> 00:21:18,830
sufficiently large amount of okay differ

547
00:21:15,629 --> 00:21:22,370
on sufficiently large amount of input

548
00:21:18,830 --> 00:21:24,169
so this is basically how we achieve our

549
00:21:22,370 --> 00:21:26,629
remove ability in the presence of other

550
00:21:24,170 --> 00:21:28,190
verification Oracle so for security

551
00:21:26,630 --> 00:21:30,080
against your authority is actually quite

552
00:21:28,190 --> 00:21:32,510
simple so if you actually look at the

553
00:21:30,080 --> 00:21:34,399
PRF domain of an extractable PRF there's

554
00:21:32,510 --> 00:21:38,240
actually only two set of special points

555
00:21:34,400 --> 00:21:40,370
X star and Z and so by the by the

556
00:21:38,240 --> 00:21:42,200
correctness of the PRF by the

557
00:21:40,370 --> 00:21:44,449
correctness of the original punctual PRF

558
00:21:42,200 --> 00:21:46,610
and pseudo randomness of the original

559
00:21:44,450 --> 00:21:48,590
punctual PRF as long as the PRF is

560
00:21:46,610 --> 00:21:50,629
actually not evaluated on these two

561
00:21:48,590 --> 00:21:55,939
special points then it's actually

562
00:21:50,630 --> 00:21:58,550
pseudo-random right so okay so

563
00:21:55,940 --> 00:21:59,870
unfortunately due to time and I'll not

564
00:21:58,550 --> 00:22:02,180
be able to cover a lot of the technical

565
00:21:59,870 --> 00:22:03,500
details that's in the paper so I guess

566
00:22:02,180 --> 00:22:06,140
how do we actually construct this

567
00:22:03,500 --> 00:22:07,970
extractable PRF so we do a lot of work

568
00:22:06,140 --> 00:22:11,330
in the paper to construct this extract

569
00:22:07,970 --> 00:22:13,790
this object of extractable PRF so in the

570
00:22:11,330 --> 00:22:15,530
paper so actually the statistical test

571
00:22:13,790 --> 00:22:17,180
that is actually run by the verification

572
00:22:15,530 --> 00:22:22,190
algorithm is a little bit more involved

573
00:22:17,180 --> 00:22:24,080
in that then I describe so so I will

574
00:22:22,190 --> 00:22:26,630
refer to everyone to the paper and also

575
00:22:24,080 --> 00:22:29,270
this defining defining the right notion

576
00:22:26,630 --> 00:22:33,170
of extract or PRF is actually much more

577
00:22:29,270 --> 00:22:34,850
difficult than it seems so I will also

578
00:22:33,170 --> 00:22:38,090
refer the details of this paper of this

579
00:22:34,850 --> 00:22:39,590
definition to the paper right so let me

580
00:22:38,090 --> 00:22:42,169
actually conclude with some open

581
00:22:39,590 --> 00:22:43,850
problems I guess there is no so in the

582
00:22:42,170 --> 00:22:45,680
paper we actually do a lot of work to

583
00:22:43,850 --> 00:22:48,830
construct this extract well PRF using

584
00:22:45,680 --> 00:22:50,540
algebraic techniques I think there may

585
00:22:48,830 --> 00:22:52,790
be some generic techniques that might

586
00:22:50,540 --> 00:22:54,560
give you this extractable PRF so for

587
00:22:52,790 --> 00:22:55,850
instance can we use a CCA secure

588
00:22:54,560 --> 00:22:57,770
encryption scheme to construct

589
00:22:55,850 --> 00:23:00,290
instructable PRF I think that's possible

590
00:22:57,770 --> 00:23:03,350
but right now it's actually not clear

591
00:23:00,290 --> 00:23:05,270
and also I guess the big question in

592
00:23:03,350 --> 00:23:07,459
this area is whether we can actually get

593
00:23:05,270 --> 00:23:08,870
to get from a private verifiable

594
00:23:07,460 --> 00:23:10,910
watermarking scheme to a publicly

595
00:23:08,870 --> 00:23:13,040
verifiable watermarking scheme just

596
00:23:10,910 --> 00:23:15,350
relying on standard assumptions all

597
00:23:13,040 --> 00:23:17,680
right so that's basically it thank you

598
00:23:15,350 --> 00:23:17,679
very much

599
00:23:21,690 --> 00:23:37,360
if you have a question please come to

600
00:23:25,059 --> 00:23:41,139
the microphone okay

601
00:23:37,360 --> 00:23:43,090
do you have any hope to achieve publicly

602
00:23:41,140 --> 00:23:48,700
very high water marking scheme for PRS

603
00:23:43,090 --> 00:23:50,530
from some of the assumptions well I

604
00:23:48,700 --> 00:23:52,179
guess that's very hard to tell but if

605
00:23:50,530 --> 00:23:53,889
you ask me then I think it's possible

606
00:23:52,179 --> 00:23:59,860
but at this point I guess it's not

607
00:23:53,890 --> 00:24:02,140
really clear but yeah hey yeah is there

608
00:23:59,860 --> 00:24:05,500
some relationship between extractable

609
00:24:02,140 --> 00:24:07,210
PRS and like the robustly and obfuscate

610
00:24:05,500 --> 00:24:09,669
of Epirus I forget exactly what they're

611
00:24:07,210 --> 00:24:13,860
called the ones that you can obfuscate

612
00:24:09,669 --> 00:24:13,860
as long as they approximate the original

613
00:24:20,340 --> 00:24:28,750
more questions okay let's

614
00:24:27,280 --> 00:24:32,789
speaker

615
00:24:28,750 --> 00:24:32,789
[Applause]

