1
00:00:04,900 --> 00:00:08,050
thank you thank you for then can you

2
00:00:07,150 --> 00:00:10,389
hear me well thank you for the

3
00:00:08,050 --> 00:00:11,920
introduction so yeah today I'm going to

4
00:00:10,389 --> 00:00:14,620
talk about some vector commitments with

5
00:00:11,920 --> 00:00:16,000
application to 16th argument and it's

6
00:00:14,620 --> 00:00:20,320
been mentioned this is a joint work with

7
00:00:16,000 --> 00:00:21,850
Russell so let me start by the Aveeno

8
00:00:20,320 --> 00:00:23,650
definition of a vector commitment this

9
00:00:21,850 --> 00:00:25,150
is from from the work of Catalan if you

10
00:00:23,650 --> 00:00:26,560
ever have been from Roy's first time but

11
00:00:25,150 --> 00:00:29,619
this is actually something everybody's

12
00:00:26,560 --> 00:00:32,980
familiar with so a vector commitment

13
00:00:29,619 --> 00:00:35,320
allows one to compress a large database

14
00:00:32,980 --> 00:00:36,790
into a small digest there is a commit

15
00:00:35,320 --> 00:00:39,220
argument that takes as input some

16
00:00:36,790 --> 00:00:41,710
randomness R and a vector V and produces

17
00:00:39,220 --> 00:00:43,629
a small commitment calm and there is an

18
00:00:41,710 --> 00:00:46,059
opening argument that takes as input a

19
00:00:43,630 --> 00:00:48,070
position a value of a certain position

20
00:00:46,059 --> 00:00:52,269
the random issues for the commitment and

21
00:00:48,070 --> 00:00:54,040
produces a short proof that that the the

22
00:00:52,270 --> 00:00:57,250
the value of position I was actually VI

23
00:00:54,040 --> 00:00:59,050
and then the proof can be used by

24
00:00:57,250 --> 00:01:01,180
everyone to verify that this is actually

25
00:00:59,050 --> 00:01:02,919
the case and the only property that we

26
00:01:01,180 --> 00:01:04,750
want from from a vector commitment is

27
00:01:02,920 --> 00:01:07,720
position binding which means essentially

28
00:01:04,750 --> 00:01:09,340
that you cannot prove that a certain

29
00:01:07,720 --> 00:01:12,310
position opens two to two different

30
00:01:09,340 --> 00:01:14,619
values and in this case ID is not really

31
00:01:12,310 --> 00:01:16,300
important because because the commitment

32
00:01:14,619 --> 00:01:17,619
is compressing so you just lose the

33
00:01:16,300 --> 00:01:18,729
information and anyway it can be

34
00:01:17,619 --> 00:01:20,979
achieved through a generic

35
00:01:18,729 --> 00:01:22,840
transformation and what we are

36
00:01:20,979 --> 00:01:25,060
interested in is the compression rate

37
00:01:22,840 --> 00:01:29,110
which is throughout this work is going

38
00:01:25,060 --> 00:01:31,390
to just be perfect services imagine the

39
00:01:29,110 --> 00:01:31,660
miracle tree so there is we can ignore

40
00:01:31,390 --> 00:01:33,550
that

41
00:01:31,660 --> 00:01:36,009
and the proof size this is which is

42
00:01:33,550 --> 00:01:39,039
going to be the focus of this talk so

43
00:01:36,009 --> 00:01:40,720
let me give you a few example and the

44
00:01:39,039 --> 00:01:42,459
firsts everybody's familiar with is the

45
00:01:40,720 --> 00:01:44,520
miracle tree and the miracle tree is

46
00:01:42,459 --> 00:01:48,610
very nice because there's perfect cone

47
00:01:44,520 --> 00:01:51,729
compression rate and you can give proofs

48
00:01:48,610 --> 00:01:53,289
of membership in with the size of lambda

49
00:01:51,729 --> 00:01:57,489
log n where n is the size of the

50
00:01:53,289 --> 00:02:00,489
database but recent work of Katherine

51
00:01:57,489 --> 00:02:02,770
and fewer appeared at PCC 2015 showed

52
00:02:00,489 --> 00:02:05,979
how to shave off this additional log and

53
00:02:02,770 --> 00:02:08,470
factor by leveraging algebraic structure

54
00:02:05,979 --> 00:02:11,319
and specifically they introduced to two

55
00:02:08,470 --> 00:02:13,109
schemes one from conciliation in

56
00:02:11,319 --> 00:02:17,369
bilinear groups and one from our say

57
00:02:13,110 --> 00:02:21,209
where they show a proof of size of

58
00:02:17,370 --> 00:02:23,040
Oh London roughly and this is the nice

59
00:02:21,209 --> 00:02:25,590
thing is that it has algebraic structure

60
00:02:23,040 --> 00:02:28,560
which is useful in general not only for

61
00:02:25,590 --> 00:02:30,000
to shave off this additional factor but

62
00:02:28,560 --> 00:02:31,560
unfortunately all both of the

63
00:02:30,000 --> 00:02:34,860
constructions that represented they they

64
00:02:31,560 --> 00:02:37,140
have a trusted set up so and think think

65
00:02:34,860 --> 00:02:38,700
about a trusted set up like ers a set up

66
00:02:37,140 --> 00:02:41,099
where you cannot reveal the primes but

67
00:02:38,700 --> 00:02:45,690
you still have to sample a random random

68
00:02:41,099 --> 00:02:47,670
or I say integer and another so is this

69
00:02:45,690 --> 00:02:48,870
the end of the story no this this is

70
00:02:47,670 --> 00:02:50,640
actually there there are system

71
00:02:48,870 --> 00:02:52,709
limitation of both of this construction

72
00:02:50,640 --> 00:02:55,500
in the fact that what happens if you

73
00:02:52,709 --> 00:02:57,660
open to cumin indices well the open is

74
00:02:55,500 --> 00:02:58,920
going to be linear in Q and this is

75
00:02:57,660 --> 00:03:01,500
really just a trivial approach you just

76
00:02:58,920 --> 00:03:02,670
do Q many probes so the question is can

77
00:03:01,500 --> 00:03:06,690
we can we do better

78
00:03:02,670 --> 00:03:11,099
and the objective of my work with Russel

79
00:03:06,690 --> 00:03:13,019
was to remove remove the size of of the

80
00:03:11,099 --> 00:03:17,040
remove the dependency on the size of Q

81
00:03:13,019 --> 00:03:18,540
and do that potentially without relying

82
00:03:17,040 --> 00:03:20,400
on trusted set up we were not always

83
00:03:18,540 --> 00:03:22,500
successful so just some constructions

84
00:03:20,400 --> 00:03:24,120
and then show where it makes a

85
00:03:22,500 --> 00:03:26,400
difference so give some application of

86
00:03:24,120 --> 00:03:30,540
this of this this is particularly

87
00:03:26,400 --> 00:03:32,160
important and so let me let me just then

88
00:03:30,540 --> 00:03:35,608
introduce the notion of a vector

89
00:03:32,160 --> 00:03:37,799
commitment so sub vector in throughout

90
00:03:35,609 --> 00:03:38,819
this talk is just a subset of vector I

91
00:03:37,799 --> 00:03:40,410
don't know if you have a better name we

92
00:03:38,819 --> 00:03:44,640
couldn't find any better and open to

93
00:03:40,410 --> 00:03:47,819
suggestions so the commitment algorithm

94
00:03:44,640 --> 00:03:49,559
is the same and the only thing that

95
00:03:47,819 --> 00:03:51,420
changes is essentially that the opening

96
00:03:49,560 --> 00:03:54,180
does not take a single position anymore

97
00:03:51,420 --> 00:03:56,399
but the set of positions and of course

98
00:03:54,180 --> 00:03:58,620
you would have also to to input a sub

99
00:03:56,400 --> 00:04:00,709
vector and everybody can just verify

100
00:03:58,620 --> 00:04:03,870
that that's the subject or is indeed

101
00:04:00,709 --> 00:04:08,280
those values at that position I want

102
00:04:03,870 --> 00:04:09,870
like you and the notion is essentially

103
00:04:08,280 --> 00:04:13,200
refinement of position binding which

104
00:04:09,870 --> 00:04:15,239
says that for for any sets of openings

105
00:04:13,200 --> 00:04:18,389
which refers to arbitrary sets of

106
00:04:15,239 --> 00:04:20,010
positions if there exists one position

107
00:04:18,389 --> 00:04:21,600
which is common among the two it has to

108
00:04:20,010 --> 00:04:23,520
have the same value so essentially we

109
00:04:21,600 --> 00:04:25,710
cannot give two different openings for a

110
00:04:23,520 --> 00:04:27,060
certain position except that we have to

111
00:04:25,710 --> 00:04:29,849
take into account the additional sub

112
00:04:27,060 --> 00:04:31,680
vector structure and compare

113
00:04:29,850 --> 00:04:33,840
is the crucial requirement of some

114
00:04:31,680 --> 00:04:36,360
vector commitment is the fact that the

115
00:04:33,840 --> 00:04:37,950
precise it should be independent of cube

116
00:04:36,360 --> 00:04:41,670
which is the size of the set of the

117
00:04:37,950 --> 00:04:43,950
indices that we give to the open but now

118
00:04:41,670 --> 00:04:46,230
that we have this the views primitive

119
00:04:43,950 --> 00:04:48,450
there is we actually learn that we can

120
00:04:46,230 --> 00:04:50,250
compute more things over the database so

121
00:04:48,450 --> 00:04:52,830
why don't compute over all the whole

122
00:04:50,250 --> 00:04:55,590
database right so in fact what we do is

123
00:04:52,830 --> 00:04:57,180
we define an even even generalized

124
00:04:55,590 --> 00:05:00,359
notion of sub vector commitment which we

125
00:04:57,180 --> 00:05:03,950
call linear map commitments which allows

126
00:05:00,360 --> 00:05:07,830
one to open to an arbitrary linear map

127
00:05:03,950 --> 00:05:10,770
computed over the commitment now if you

128
00:05:07,830 --> 00:05:12,810
think of the databases as a vector

129
00:05:10,770 --> 00:05:14,250
inside an for the state of physical sake

130
00:05:12,810 --> 00:05:18,920
of this talk you can think of F

131
00:05:14,250 --> 00:05:18,920
expressed as a matrix and it

132
00:05:19,340 --> 00:05:23,909
characterizes a linear map and then we

133
00:05:21,750 --> 00:05:26,490
can really show that a linear map has a

134
00:05:23,910 --> 00:05:28,050
certain output value which is w which in

135
00:05:26,490 --> 00:05:31,530
this case is going to be a set of

136
00:05:28,050 --> 00:05:33,770
element injury and the position binding

137
00:05:31,530 --> 00:05:36,659
are not going to define it formally here

138
00:05:33,770 --> 00:05:39,330
it gets a bit tricky because you have

139
00:05:36,660 --> 00:05:42,480
several relation intuitively what

140
00:05:39,330 --> 00:05:45,479
happened what we want is that if you

141
00:05:42,480 --> 00:05:49,530
think of the database as a set of

142
00:05:45,480 --> 00:05:51,210
unknowns then each opening together with

143
00:05:49,530 --> 00:05:53,909
the proof defines a set of linear

144
00:05:51,210 --> 00:05:55,710
equations right so we want that it's

145
00:05:53,910 --> 00:05:57,150
hard to find a set of linear equation

146
00:05:55,710 --> 00:06:03,479
which does not have a solution right

147
00:05:57,150 --> 00:06:05,969
even if you get many openings ok what's

148
00:06:03,480 --> 00:06:09,630
the application of this so our primarily

149
00:06:05,970 --> 00:06:12,510
focus was on as on 16th arguments and

150
00:06:09,630 --> 00:06:13,890
let me briefly recap the definition of

151
00:06:12,510 --> 00:06:15,690
16th argument and the folklore

152
00:06:13,890 --> 00:06:18,270
constructions and then we show how to

153
00:06:15,690 --> 00:06:22,620
use this these tools in order to improve

154
00:06:18,270 --> 00:06:25,950
the state of the earth so this this is

155
00:06:22,620 --> 00:06:27,300
one of the classical classical building

156
00:06:25,950 --> 00:06:30,590
blocks in cryptography as plenty of

157
00:06:27,300 --> 00:06:33,660
usages ok so if L is an empty language

158
00:06:30,590 --> 00:06:35,340
1/16 arguments is defined as an

159
00:06:33,660 --> 00:06:36,090
interactive protocol between a proven a

160
00:06:35,340 --> 00:06:38,250
verifier

161
00:06:36,090 --> 00:06:40,080
will prove as a statement and

162
00:06:38,250 --> 00:06:43,009
additionally a witness for such a

163
00:06:40,080 --> 00:06:44,628
statement and in the end the very fire

164
00:06:43,009 --> 00:06:46,969
convinced or not of the membership of

165
00:06:44,629 --> 00:06:50,360
such a statement and the proof of the

166
00:06:46,969 --> 00:06:53,149
soundness requirement is that if X is

167
00:06:50,360 --> 00:06:55,479
not in L then the verifier should reject

168
00:06:53,149 --> 00:06:58,639
with probability greater than half and

169
00:06:55,479 --> 00:07:00,789
usually usually soundness is not always

170
00:06:58,639 --> 00:07:02,960
but usually soundness is achieved by a

171
00:07:00,789 --> 00:07:06,139
row parallel repetition of the same

172
00:07:02,960 --> 00:07:08,960
protocol in power and we additionally

173
00:07:06,139 --> 00:07:10,159
want succinctness which states that the

174
00:07:08,960 --> 00:07:12,020
communication complexity of this

175
00:07:10,159 --> 00:07:15,860
protocol should be independent of the

176
00:07:12,020 --> 00:07:17,299
size of the witness okay so in order to

177
00:07:15,860 --> 00:07:19,539
introduce through the construction I

178
00:07:17,300 --> 00:07:21,289
need to give you like a one slide

179
00:07:19,539 --> 00:07:24,099
explanation of probabilistically

180
00:07:21,289 --> 00:07:26,539
checkable proof so this is a beautiful

181
00:07:24,099 --> 00:07:29,779
information theoretic object is not like

182
00:07:26,539 --> 00:07:31,430
monumental work in complexity theory and

183
00:07:29,779 --> 00:07:33,589
it has been proved useful in

184
00:07:31,430 --> 00:07:36,860
cryptography exactly primarily for these

185
00:07:33,589 --> 00:07:38,749
applications and I will be simplifying a

186
00:07:36,860 --> 00:07:42,279
lot so if you feel complexity theory

187
00:07:38,749 --> 00:07:45,770
don't please don't get so

188
00:07:42,279 --> 00:07:48,860
probabilistically checkable proof allows

189
00:07:45,770 --> 00:07:51,558
one to encode a certain witness in a

190
00:07:48,860 --> 00:07:53,689
statement in such a way that if the

191
00:07:51,559 --> 00:07:56,270
verifier as an oracle access to such an

192
00:07:53,689 --> 00:07:58,610
encoding it can verify the the

193
00:07:56,270 --> 00:08:01,039
membership of suchanek

194
00:07:58,610 --> 00:08:04,069
the witness of the statement is such in

195
00:08:01,039 --> 00:08:06,349
such a language by just queering by just

196
00:08:04,069 --> 00:08:10,279
clearing the the oracle a constant

197
00:08:06,349 --> 00:08:12,349
amount of time and for the sake of this

198
00:08:10,279 --> 00:08:14,240
talk again we require only probability

199
00:08:12,349 --> 00:08:16,519
of failure smaller than 1/2

200
00:08:14,240 --> 00:08:20,269
and again english' balsamic achieved by

201
00:08:16,519 --> 00:08:22,789
parallel repetitions and this has been a

202
00:08:20,269 --> 00:08:25,219
huge improvement in the last the last

203
00:08:22,789 --> 00:08:28,490
years and there has been many extensions

204
00:08:25,219 --> 00:08:30,558
also also too in order to improve the

205
00:08:28,490 --> 00:08:33,500
approver efficiency because usually the

206
00:08:30,559 --> 00:08:36,860
the cost of encoding of computing this

207
00:08:33,500 --> 00:08:38,750
encoding is very large so most of most

208
00:08:36,860 --> 00:08:44,540
of the literature's focused on improving

209
00:08:38,750 --> 00:08:47,480
the concrete numbers of this of this

210
00:08:44,540 --> 00:08:49,699
runtime and specifically they allow for

211
00:08:47,480 --> 00:08:53,360
some relaxation of the model for example

212
00:08:49,699 --> 00:08:55,459
linear PCP allows one to allows us to

213
00:08:53,360 --> 00:08:56,420
query the database as a linear function

214
00:08:55,459 --> 00:08:57,949
so you can

215
00:08:56,420 --> 00:08:59,990
to compute now the function of the old

216
00:08:57,950 --> 00:09:02,480
database but you can only do a constant

217
00:08:59,990 --> 00:09:04,010
amount of time and then I appear stands

218
00:09:02,480 --> 00:09:05,899
for interactive Oracle proof which is

219
00:09:04,010 --> 00:09:08,660
essentially the the interactive version

220
00:09:05,899 --> 00:09:10,850
of a PCP word that the database is

221
00:09:08,660 --> 00:09:13,550
allowed to decide encoding is allowed to

222
00:09:10,850 --> 00:09:15,800
change in between queries okay

223
00:09:13,550 --> 00:09:17,839
so how do you use this so this is the

224
00:09:15,800 --> 00:09:20,149
visited classical this this construction

225
00:09:17,839 --> 00:09:22,790
follow the classical blueprint of Hylian

226
00:09:20,149 --> 00:09:24,560
but instead uses a vector commitment or

227
00:09:22,790 --> 00:09:29,240
linear map commitment and you'll see why

228
00:09:24,560 --> 00:09:33,619
so the the first message of the prover

229
00:09:29,240 --> 00:09:35,269
is a is the encoding of of the computing

230
00:09:33,620 --> 00:09:36,949
coding of the witness and then commit

231
00:09:35,269 --> 00:09:40,190
commit with using a sub vector

232
00:09:36,949 --> 00:09:42,529
commitment and it's a sense is this sub

233
00:09:40,190 --> 00:09:45,740
actor commitment to the verifier then

234
00:09:42,529 --> 00:09:48,050
the verifier picks set of location more

235
00:09:45,740 --> 00:09:49,940
generally a set of queries sends them to

236
00:09:48,050 --> 00:09:52,670
the prover and then the prover can

237
00:09:49,940 --> 00:09:54,199
compute the opener relative to to that

238
00:09:52,670 --> 00:09:56,689
set of queries and then the verifier

239
00:09:54,199 --> 00:09:58,430
just runs the once he has the opening

240
00:09:56,690 --> 00:10:01,220
together with a proof verifies the proof

241
00:09:58,430 --> 00:10:05,870
and check whether the PCP relation is

242
00:10:01,220 --> 00:10:07,519
very fast correctly and this is most of

243
00:10:05,870 --> 00:10:10,910
the time made non interactive using the

244
00:10:07,519 --> 00:10:12,440
deviation every six so in the end if we

245
00:10:10,910 --> 00:10:14,000
consider that the communication

246
00:10:12,440 --> 00:10:16,399
complexity of this protocol is really

247
00:10:14,000 --> 00:10:18,079
the size of the commitment plus the size

248
00:10:16,399 --> 00:10:21,440
of the openings which is very very tiny

249
00:10:18,079 --> 00:10:25,089
and the size of the proof and because

250
00:10:21,440 --> 00:10:29,329
you can always recompute the query and

251
00:10:25,089 --> 00:10:30,800
so what do we gain if we if we instead

252
00:10:29,329 --> 00:10:32,420
of using a miracle tree we instantiate

253
00:10:30,800 --> 00:10:35,329
the commitment uses a sub vector

254
00:10:32,420 --> 00:10:36,740
commitment or linear map commitment so

255
00:10:35,329 --> 00:10:39,620
the first the first thing that we gain

256
00:10:36,740 --> 00:10:41,120
is generality in the sense that in the

257
00:10:39,620 --> 00:10:43,430
sense that the algebraic structure of a

258
00:10:41,120 --> 00:10:45,079
linear map commitment allows us really

259
00:10:43,430 --> 00:10:47,719
to compute even linear functions and

260
00:10:45,079 --> 00:10:50,870
give proof sixteen proofs for that so we

261
00:10:47,720 --> 00:10:53,360
can support a larger class of PCP namely

262
00:10:50,870 --> 00:10:55,790
linear PCP sand and an interactive

263
00:10:53,360 --> 00:10:57,040
Oracle proof and I think this is

264
00:10:55,790 --> 00:10:59,660
actually an important point because

265
00:10:57,040 --> 00:11:01,430
there is a lot of this is a very active

266
00:10:59,660 --> 00:11:03,649
area of research that it's a very rich

267
00:11:01,430 --> 00:11:06,349
of a new new scheme and new techniques

268
00:11:03,649 --> 00:11:08,029
and it's this is essentially what's what

269
00:11:06,350 --> 00:11:10,010
it tells is that the linear map

270
00:11:08,029 --> 00:11:13,100
commitment is sort of the only

271
00:11:10,010 --> 00:11:14,900
- graphic object that you need in order

272
00:11:13,100 --> 00:11:16,490
to instantiate or to construct a

273
00:11:14,900 --> 00:11:20,900
protocol like this and just have to come

274
00:11:16,490 --> 00:11:22,820
up you just need to construct your own

275
00:11:20,900 --> 00:11:25,610
linear PCP and then you're good to go

276
00:11:22,820 --> 00:11:27,020
and in terms of sixteenths we allow

277
00:11:25,610 --> 00:11:28,880
since we have this compactness

278
00:11:27,020 --> 00:11:32,180
requirement we are allowed to say the

279
00:11:28,880 --> 00:11:34,930
factor Q where Q in this case will be C

280
00:11:32,180 --> 00:11:38,089
times row and recall that row was the

281
00:11:34,930 --> 00:11:40,520
was the number of parallel repetition in

282
00:11:38,090 --> 00:11:44,180
the tubu sons and c is the constant

283
00:11:40,520 --> 00:11:48,020
which is the amount of query of the PCP

284
00:11:44,180 --> 00:11:51,439
encoding parent and as an eye light of

285
00:11:48,020 --> 00:11:53,600
if we if we really try to shoot for the

286
00:11:51,440 --> 00:11:57,110
best the breath proof size this allows

287
00:11:53,600 --> 00:11:58,730
us to get proofs without a trusted setup

288
00:11:57,110 --> 00:12:00,950
you still in the setup but is going to

289
00:11:58,730 --> 00:12:03,170
be public coin so it is also called

290
00:12:00,950 --> 00:12:05,930
transparent in the literature and the

291
00:12:03,170 --> 00:12:07,729
proofs are on your size 5000 bit for

292
00:12:05,930 --> 00:12:09,890
four hundred twenty eight bits of

293
00:12:07,730 --> 00:12:14,360
security should have three more minutes

294
00:12:09,890 --> 00:12:18,069
right and okay this is i should should

295
00:12:14,360 --> 00:12:23,150
mention that this this number are

296
00:12:18,070 --> 00:12:24,440
achieved by optimizing for proof size so

297
00:12:23,150 --> 00:12:26,959
there's not going to be a practical

298
00:12:24,440 --> 00:12:31,310
product just visibility result that we

299
00:12:26,960 --> 00:12:33,550
can do it with so much information and

300
00:12:31,310 --> 00:12:36,199
again what we lose unfortunately

301
00:12:33,550 --> 00:12:37,819
unfortunately sub vector commitment a

302
00:12:36,200 --> 00:12:39,140
linear map commitment uses public key

303
00:12:37,820 --> 00:12:41,000
operations

304
00:12:39,140 --> 00:12:43,250
it's an clear whether this isn't this is

305
00:12:41,000 --> 00:12:44,720
inherent but the prover efficiency is

306
00:12:43,250 --> 00:12:46,670
obviously affected because instead of

307
00:12:44,720 --> 00:12:52,750
computing symmetric symmetric operation

308
00:12:46,670 --> 00:12:55,819
you rely on public key crypto right so

309
00:12:52,750 --> 00:12:57,530
let's go to the construction so for the

310
00:12:55,820 --> 00:13:00,050
construction we give to construction of

311
00:12:57,530 --> 00:13:01,850
sub vector commitments one from groups

312
00:13:00,050 --> 00:13:05,359
of unknown order and I'll spend a few

313
00:13:01,850 --> 00:13:07,910
few words on that later one from CDH in

314
00:13:05,360 --> 00:13:09,650
Bell in your groups and we give a one

315
00:13:07,910 --> 00:13:13,600
construction of linear map commitments

316
00:13:09,650 --> 00:13:16,010
in the generic in your group model now

317
00:13:13,600 --> 00:13:18,050
what are groups of unknown order this

318
00:13:16,010 --> 00:13:20,240
pretty self-explanatory are groups where

319
00:13:18,050 --> 00:13:22,310
the order is unknown and you can think

320
00:13:20,240 --> 00:13:25,600
of the classical example is our RSA

321
00:13:22,310 --> 00:13:25,599
groups you don't know

322
00:13:25,899 --> 00:13:33,380
the order of rxa groups unless you can

323
00:13:28,820 --> 00:13:36,910
factor the big composite and there are

324
00:13:33,380 --> 00:13:39,410
other less known groups one known order

325
00:13:36,910 --> 00:13:41,390
among the most interesting in my opinion

326
00:13:39,410 --> 00:13:43,069
is the class groups of imaginary

327
00:13:41,390 --> 00:13:45,260
quadratic order and why is this

328
00:13:43,070 --> 00:13:48,230
interesting because it allows to

329
00:13:45,260 --> 00:13:49,189
represent element in in a 16th way so

330
00:13:48,230 --> 00:13:51,830
there are short there are relatively

331
00:13:49,190 --> 00:13:54,410
short group elements and it doesn't need

332
00:13:51,830 --> 00:13:57,860
a trusted setup you still need a set up

333
00:13:54,410 --> 00:13:59,660
but again you you can do this with

334
00:13:57,860 --> 00:14:01,580
public coin and this is especially

335
00:13:59,660 --> 00:14:04,069
relevant in practice because what you do

336
00:14:01,580 --> 00:14:08,060
you just catch it with a random or a

337
00:14:04,070 --> 00:14:10,310
column those are your parameters right

338
00:14:08,060 --> 00:14:12,170
so I just want to show here the

339
00:14:10,310 --> 00:14:14,199
construction from groups of an order I'm

340
00:14:12,170 --> 00:14:16,969
not going to go into the details of this

341
00:14:14,200 --> 00:14:19,760
mostly because benefit will show you an

342
00:14:16,970 --> 00:14:21,529
improved construction so but this is

343
00:14:19,760 --> 00:14:23,540
just to show that it is a simple scheme

344
00:14:21,529 --> 00:14:27,350
so this is nothing nothing to be afraid

345
00:14:23,540 --> 00:14:56,449
of yeah and on this note I would like to

346
00:14:27,350 --> 00:14:58,160
conclude my slide deck please okay thank

347
00:14:56,450 --> 00:15:00,260
you so I will talk about further

348
00:14:58,160 --> 00:15:02,839
batching techniques for vector

349
00:15:00,260 --> 00:15:05,329
commitments and accumulators and as a

350
00:15:02,839 --> 00:15:08,420
second motivating application next to

351
00:15:05,329 --> 00:15:10,550
these short proofs we are going to think

352
00:15:08,420 --> 00:15:12,199
about block chains so if you think about

353
00:15:10,550 --> 00:15:13,939
what block chains look like look like

354
00:15:12,200 --> 00:15:16,070
today you can kind of think of them as

355
00:15:13,940 --> 00:15:18,410
databases but there's different kinds of

356
00:15:16,070 --> 00:15:19,910
databases so on the Left we have Bitcoin

357
00:15:18,410 --> 00:15:22,490
here and on the right we have aetherium

358
00:15:19,910 --> 00:15:25,399
and in Bitcoin the state of the database

359
00:15:22,490 --> 00:15:28,130
is really a set an unordered set of

360
00:15:25,399 --> 00:15:30,529
coins and each coin is an IDE a public

361
00:15:28,130 --> 00:15:32,779
key and an amount and in aetherium it is

362
00:15:30,529 --> 00:15:34,790
a key value map between accounts and

363
00:15:32,779 --> 00:15:37,730
balances

364
00:15:34,790 --> 00:15:39,980
and the states are already quite large

365
00:15:37,730 --> 00:15:42,890
right they're already on the order of

366
00:15:39,980 --> 00:15:45,230
gigabytes and every single minor a full

367
00:15:42,890 --> 00:15:47,030
note needs to store this entire state

368
00:15:45,230 --> 00:15:48,530
and why do they need to store it well

369
00:15:47,030 --> 00:15:52,100
they need to store it in order to verify

370
00:15:48,530 --> 00:15:53,780
a new transaction that comes in so even

371
00:15:52,100 --> 00:15:56,540
with the limited usage these things are

372
00:15:53,780 --> 00:15:58,880
quite large so the motivation is can we

373
00:15:56,540 --> 00:16:01,219
get something like a low memory

374
00:15:58,880 --> 00:16:03,350
blockchain where instead of storing the

375
00:16:01,220 --> 00:16:05,840
state itself the miner just stores a

376
00:16:03,350 --> 00:16:08,570
short commitment so in the Bitcoin case

377
00:16:05,840 --> 00:16:10,760
this would be in a commitment called to

378
00:16:08,570 --> 00:16:14,030
an unordered set this is an accumulator

379
00:16:10,760 --> 00:16:15,920
and in the etherium case this is a

380
00:16:14,030 --> 00:16:17,449
vector commitment which we just heard

381
00:16:15,920 --> 00:16:19,610
about which is a commitment to an

382
00:16:17,450 --> 00:16:22,820
ordered list right notice the difference

383
00:16:19,610 --> 00:16:24,500
between the two so this is much better

384
00:16:22,820 --> 00:16:25,550
because these commitments are very short

385
00:16:24,500 --> 00:16:29,090
you know they can be less than a

386
00:16:25,550 --> 00:16:30,500
kilobyte and then how do transactions

387
00:16:29,090 --> 00:16:32,600
look like how do I then verify a

388
00:16:30,500 --> 00:16:34,280
transaction well the transaction now

389
00:16:32,600 --> 00:16:36,560
would not just contain the transaction

390
00:16:34,280 --> 00:16:39,170
information but also an additional proof

391
00:16:36,560 --> 00:16:41,329
and this proof will state that you know

392
00:16:39,170 --> 00:16:44,959
whatever coin Alice is trying to send

393
00:16:41,330 --> 00:16:47,510
Bob is in this accumulator of previously

394
00:16:44,960 --> 00:16:50,750
unspent coins so it is a valid coin

395
00:16:47,510 --> 00:16:52,819
basically and with this proof the the

396
00:16:50,750 --> 00:16:54,890
minor or the verify can just say wow

397
00:16:52,820 --> 00:16:57,680
this looks good I'm going to accept this

398
00:16:54,890 --> 00:16:59,330
transaction so what do these commitments

399
00:16:57,680 --> 00:17:02,750
look like let's look at them a little

400
00:16:59,330 --> 00:17:04,700
bit more detail so an accumulator is as

401
00:17:02,750 --> 00:17:07,760
I said a commitment to an unordered set

402
00:17:04,700 --> 00:17:09,410
and it has it supports short inclusion

403
00:17:07,760 --> 00:17:11,390
and exclusion proof so saying that

404
00:17:09,410 --> 00:17:13,520
something is in the set or not in the

405
00:17:11,390 --> 00:17:16,250
set and the security property is that

406
00:17:13,520 --> 00:17:18,500
for no element I can give you both an

407
00:17:16,250 --> 00:17:21,290
inclusion proof and an exclusion proof

408
00:17:18,500 --> 00:17:23,060
and we can instantiate accumulators from

409
00:17:21,290 --> 00:17:24,950
several constructions such as classic

410
00:17:23,060 --> 00:17:26,659
one like Merkel trees and the one that

411
00:17:24,950 --> 00:17:28,910
I'll be focusing on today is mostly

412
00:17:26,660 --> 00:17:30,230
accumulators are as a accumulators which

413
00:17:28,910 --> 00:17:32,300
have the nice property that the

414
00:17:30,230 --> 00:17:34,970
inclusion and exclusion proofs are

415
00:17:32,300 --> 00:17:36,860
constant size and vector commitments we

416
00:17:34,970 --> 00:17:38,480
already heard about their commitment to

417
00:17:36,860 --> 00:17:40,879
an ordered list so I can give you

418
00:17:38,480 --> 00:17:42,770
positional openings and again the

419
00:17:40,880 --> 00:17:45,250
security property is that I can't open

420
00:17:42,770 --> 00:17:47,660
to two elements at the same position and

421
00:17:45,250 --> 00:17:48,110
again we can instantiate these from

422
00:17:47,660 --> 00:17:51,169
urkesh

423
00:17:48,110 --> 00:17:54,500
and we just saw a construction from in

424
00:17:51,169 --> 00:17:59,029
groups of an order or a groups for these

425
00:17:54,500 --> 00:18:01,340
vector commitments so and again these

426
00:17:59,029 --> 00:18:03,649
proofs are constant size so the other

427
00:18:01,340 --> 00:18:05,779
thing that that we already had a little

428
00:18:03,649 --> 00:18:08,149
motivation for these bachelor behrouz

429
00:18:05,779 --> 00:18:10,820
are also going to be very important in

430
00:18:08,149 --> 00:18:12,469
this application why is this a case well

431
00:18:10,820 --> 00:18:14,870
think about it if I have it many

432
00:18:12,470 --> 00:18:16,549
transactions in a block and they are all

433
00:18:14,870 --> 00:18:19,518
have you know separate proofs with

434
00:18:16,549 --> 00:18:22,220
respect to the same accumulator what I

435
00:18:19,519 --> 00:18:24,110
would like to do is somehow aggregate

436
00:18:22,220 --> 00:18:26,149
these proofs maybe a miner could do this

437
00:18:24,110 --> 00:18:29,779
or some public operation some some

438
00:18:26,149 --> 00:18:33,500
helper and create one single short batch

439
00:18:29,779 --> 00:18:35,389
proof and just it's very easy to see

440
00:18:33,500 --> 00:18:36,590
that for a Merkle tree for example i

441
00:18:35,389 --> 00:18:38,840
couldn't really do this if i take

442
00:18:36,590 --> 00:18:40,279
multiple mirco paths together then

443
00:18:38,840 --> 00:18:42,740
they're not really going to be shorter

444
00:18:40,279 --> 00:18:45,440
than the individual merkel proofs so we

445
00:18:42,740 --> 00:18:48,470
need something more algebraic so the

446
00:18:45,440 --> 00:18:50,750
desert errata for accumulators are we

447
00:18:48,470 --> 00:18:52,279
already have a bunch of cool properties

448
00:18:50,750 --> 00:18:54,830
from prior work we have constant size

449
00:18:52,279 --> 00:18:56,870
openings they have a truss to set up a

450
00:18:54,830 --> 00:19:00,139
constant size a small small common

451
00:18:56,870 --> 00:19:01,719
reference string and what we add is the

452
00:19:00,139 --> 00:19:04,340
ability to give these batch

453
00:19:01,720 --> 00:19:07,970
inclusion/exclusion proofs so short

454
00:19:04,340 --> 00:19:09,918
proofs for large larger statements which

455
00:19:07,970 --> 00:19:11,840
are also very efficient to verify so i

456
00:19:09,919 --> 00:19:13,299
can verify them with a only constant

457
00:19:11,840 --> 00:19:15,408
number of group operations and

458
00:19:13,299 --> 00:19:17,629
four-vector commitments the desert

459
00:19:15,409 --> 00:19:19,580
rather looks similar but we just saw

460
00:19:17,630 --> 00:19:22,039
that we already have a beautiful

461
00:19:19,580 --> 00:19:24,080
construction for batch openings but the

462
00:19:22,039 --> 00:19:26,149
the problem with this construction for

463
00:19:24,080 --> 00:19:29,418
this particular application is that the

464
00:19:26,149 --> 00:19:31,908
common reference string is as long as

465
00:19:29,419 --> 00:19:34,399
the vector that I'm trying to commit to

466
00:19:31,909 --> 00:19:36,470
so I'm not really able to save space if

467
00:19:34,399 --> 00:19:39,110
I need to store this gigantic common

468
00:19:36,470 --> 00:19:40,610
reference string so our work was which

469
00:19:39,110 --> 00:19:43,219
is a very which is a different

470
00:19:40,610 --> 00:19:45,289
construction maintains the the same

471
00:19:43,220 --> 00:19:47,570
properties from the old construction but

472
00:19:45,289 --> 00:19:49,760
now adds also this property of having a

473
00:19:47,570 --> 00:19:52,039
constant size reference string I can

474
00:19:49,760 --> 00:19:54,200
efficiently verify it and it also allows

475
00:19:52,039 --> 00:19:56,090
the support for sparse vectors which is

476
00:19:54,200 --> 00:19:58,460
a vector that is potentially of

477
00:19:56,090 --> 00:20:00,668
exponential size but only has a

478
00:19:58,460 --> 00:20:02,889
polynomial number of

479
00:20:00,669 --> 00:20:05,200
zero elements so for the rest of the

480
00:20:02,889 --> 00:20:07,330
talk I will focus on how we achieve this

481
00:20:05,200 --> 00:20:11,019
one particular property the constant

482
00:20:07,330 --> 00:20:13,090
size CRS and as a rope Metford we're

483
00:20:11,019 --> 00:20:14,619
going to build a vector commitment with

484
00:20:13,090 --> 00:20:17,678
all of these nice properties so the

485
00:20:14,619 --> 00:20:19,809
constant size CRS from an accumulator

486
00:20:17,679 --> 00:20:23,590
which already has the the constant size

487
00:20:19,809 --> 00:20:26,859
CRS property and the if the accumulator

488
00:20:23,590 --> 00:20:28,600
also has batch openings then we can get

489
00:20:26,859 --> 00:20:30,369
batch openings for the vector commitment

490
00:20:28,600 --> 00:20:32,918
as well and in order to build these

491
00:20:30,369 --> 00:20:34,779
batch openings we need poky which are

492
00:20:32,919 --> 00:20:37,059
proofs of knowledge of exponent or

493
00:20:34,779 --> 00:20:39,820
succinct arguments of discrete

494
00:20:37,059 --> 00:20:41,230
logarithms in groups of unknown order so

495
00:20:39,820 --> 00:20:42,460
this is sort of the road map for the

496
00:20:41,230 --> 00:20:44,169
rest of the talk

497
00:20:42,460 --> 00:20:45,909
so what does a vector commitment built

498
00:20:44,169 --> 00:20:47,309
from an accumulator look like well it

499
00:20:45,909 --> 00:20:49,809
turns out to be a fairly simple

500
00:20:47,309 --> 00:20:51,700
construction and the idea is that we're

501
00:20:49,809 --> 00:20:54,428
going to commit to a bit vector so at

502
00:20:51,700 --> 00:20:58,090
every index the vector is either 0 or 1

503
00:20:54,429 --> 00:21:00,609
and we'll simply map each index in we

504
00:20:58,090 --> 00:21:04,570
hash it into the accumulator domain and

505
00:21:00,609 --> 00:21:07,960
if the bit of the vector is set to 1

506
00:21:04,570 --> 00:21:10,090
then we'll add the hash of the index to

507
00:21:07,960 --> 00:21:12,070
the accumulator so in order to open that

508
00:21:10,090 --> 00:21:14,918
I now can either give you an inclusion

509
00:21:12,070 --> 00:21:16,779
proof if the bit is set or an exclusion

510
00:21:14,919 --> 00:21:19,539
proof if the bit is not set so if it's 0

511
00:21:16,779 --> 00:21:21,669
at the position so this construction

512
00:21:19,539 --> 00:21:23,769
already has some nice properties because

513
00:21:21,669 --> 00:21:25,629
it inherits properties from the

514
00:21:23,769 --> 00:21:28,509
accumulator so if the accumulator has a

515
00:21:25,629 --> 00:21:30,428
constant size trust the crs then so will

516
00:21:28,509 --> 00:21:33,039
the vector commitment however it also

517
00:21:30,429 --> 00:21:34,869
has several downsides mainly that if I

518
00:21:33,039 --> 00:21:38,710
don't want to just open it to bits but

519
00:21:34,869 --> 00:21:40,209
to a large set of elements then I will

520
00:21:38,710 --> 00:21:41,769
need to give you many inclusion proofs

521
00:21:40,210 --> 00:21:44,409
and many exclusion proof in particular

522
00:21:41,769 --> 00:21:45,940
it's not a sub vector commitment yet so

523
00:21:44,409 --> 00:21:48,129
what do we need to get this property

524
00:21:45,940 --> 00:21:50,019
well what we would need is fetch

525
00:21:48,129 --> 00:21:51,279
inclusion and batch exclusion proof so

526
00:21:50,019 --> 00:21:53,559
what do I mean by that if we have one

527
00:21:51,279 --> 00:21:55,330
single inclusion proof which can tell

528
00:21:53,559 --> 00:21:57,609
you that many bits are equal to one and

529
00:21:55,330 --> 00:22:00,070
one single constant size exclusion proof

530
00:21:57,609 --> 00:22:02,289
that many bits are equal to 0 well then

531
00:22:00,070 --> 00:22:04,330
I have a constant size opening for you

532
00:22:02,289 --> 00:22:06,340
know an arbitrary number of indices and

533
00:22:04,330 --> 00:22:08,408
suddenly I have a subject a commitment

534
00:22:06,340 --> 00:22:10,509
with still the same great properties so

535
00:22:08,409 --> 00:22:12,489
this is exactly what we'll achieve so

536
00:22:10,509 --> 00:22:14,290
let's look at what our concrete

537
00:22:12,489 --> 00:22:15,490
accumulator construction or the

538
00:22:14,290 --> 00:22:17,740
the accumulated construction that we

539
00:22:15,490 --> 00:22:19,150
build on looks like well we are in a

540
00:22:17,740 --> 00:22:21,460
group of unknown order which we already

541
00:22:19,150 --> 00:22:23,710
heard about today so for example in this

542
00:22:21,460 --> 00:22:24,670
group we assume that taking routes of an

543
00:22:23,710 --> 00:22:29,200
lavance is hard

544
00:22:24,670 --> 00:22:31,030
the domain is primes and we initialize

545
00:22:29,200 --> 00:22:33,850
the accumulator with just a single

546
00:22:31,030 --> 00:22:36,760
random element so then to commit to a

547
00:22:33,850 --> 00:22:38,199
set of element we simply multiply all of

548
00:22:36,760 --> 00:22:42,160
these elements together remember they're

549
00:22:38,200 --> 00:22:46,270
primes and then raise the the base value

550
00:22:42,160 --> 00:22:47,860
G to that product so giving inclusion

551
00:22:46,270 --> 00:22:49,240
proves is fairly easy and we shown the

552
00:22:47,860 --> 00:22:51,189
preparer how to give betch includes

553
00:22:49,240 --> 00:22:53,860
improve as well so let's focus on

554
00:22:51,190 --> 00:22:57,490
exclusion proofs so I want to prove to

555
00:22:53,860 --> 00:22:59,379
you that Y is not in the set so another

556
00:22:57,490 --> 00:23:02,050
way to say this is that Y has to be

557
00:22:59,380 --> 00:23:04,630
co-prime to the product of all of the

558
00:23:02,050 --> 00:23:07,330
elements in the set so if this is the

559
00:23:04,630 --> 00:23:09,910
case then I can find integers a and B

560
00:23:07,330 --> 00:23:12,159
such that a times u the products of the

561
00:23:09,910 --> 00:23:15,940
element in the set plus B times y is

562
00:23:12,160 --> 00:23:18,430
equal to 1 and it turns out that a is

563
00:23:15,940 --> 00:23:21,250
actually bounded in size it's going to

564
00:23:18,430 --> 00:23:24,730
be less than Y B might be much larger

565
00:23:21,250 --> 00:23:27,730
so the exclusion proof is simply a and G

566
00:23:24,730 --> 00:23:31,060
to the B and the verification then

567
00:23:27,730 --> 00:23:33,280
checks this equation here in the

568
00:23:31,060 --> 00:23:35,290
exponent so it just checks that a times

569
00:23:33,280 --> 00:23:38,860
u plus B times y is equal to 1 and this

570
00:23:35,290 --> 00:23:41,050
is a proof that the element is not in

571
00:23:38,860 --> 00:23:44,320
the accumulator that Y is not in the

572
00:23:41,050 --> 00:23:47,139
accumulator in the accumulated set so

573
00:23:44,320 --> 00:23:48,760
now say I want to create batch exclusion

574
00:23:47,140 --> 00:23:50,590
proof I somehow wanna you know combine

575
00:23:48,760 --> 00:23:51,910
these exclusion pros so I have two of

576
00:23:50,590 --> 00:23:55,480
them and it turns out we shown in the

577
00:23:51,910 --> 00:23:57,730
paper you can combine them and then the

578
00:23:55,480 --> 00:24:00,700
problem is that a prime prime here the

579
00:23:57,730 --> 00:24:03,850
combined proof is actually a now of the

580
00:24:00,700 --> 00:24:05,530
size of x times y so it grows and if I

581
00:24:03,850 --> 00:24:07,810
do this repeatedly over and over again

582
00:24:05,530 --> 00:24:10,090
for multiple proofs I combine them in

583
00:24:07,810 --> 00:24:11,679
some way well then the size of this this

584
00:24:10,090 --> 00:24:13,389
combined proof will grow and grow and

585
00:24:11,680 --> 00:24:15,010
grow and it will actually be linear in

586
00:24:13,390 --> 00:24:16,680
the number of proofs that are combined

587
00:24:15,010 --> 00:24:19,150
so I don't really have a batch proof

588
00:24:16,680 --> 00:24:20,410
it's not really smaller than just taking

589
00:24:19,150 --> 00:24:23,710
the individual proofs at least not

590
00:24:20,410 --> 00:24:26,360
asymptotically so what we really would

591
00:24:23,710 --> 00:24:29,570
like is somehow to compress this proof

592
00:24:26,360 --> 00:24:32,360
and these proofs and our core idea is to

593
00:24:29,570 --> 00:24:35,240
not give you give a to the verifier in

594
00:24:32,360 --> 00:24:38,600
the clear but instead prove knowledge

595
00:24:35,240 --> 00:24:40,520
that such an a exists okay right I'm not

596
00:24:38,600 --> 00:24:43,010
gonna give you a I'm just gonna prove to

597
00:24:40,520 --> 00:24:45,790
you that such an a exists and maybe this

598
00:24:43,010 --> 00:24:48,200
proof can be a short so what we need is

599
00:24:45,790 --> 00:24:50,540
basically just a proof of knowledge of

600
00:24:48,200 --> 00:24:52,790
discrete logarithms in these groups of

601
00:24:50,540 --> 00:24:55,639
unknown order so alpha here is an

602
00:24:52,790 --> 00:24:57,830
integer may be very very large and the

603
00:24:55,640 --> 00:24:59,630
goal here is not zero knowledge I want

604
00:24:57,830 --> 00:25:02,929
to prove to you that V is equal to U to

605
00:24:59,630 --> 00:25:05,180
the to the alpha I guess it's not G or

606
00:25:02,930 --> 00:25:06,830
not it's it's really mainly efficiency

607
00:25:05,180 --> 00:25:09,920
so the verifiers work and the

608
00:25:06,830 --> 00:25:14,480
communication should ideally be constant

609
00:25:09,920 --> 00:25:16,100
size independent off of alpha so we're

610
00:25:14,480 --> 00:25:19,790
going to develop some some quick

611
00:25:16,100 --> 00:25:22,250
protocol some fast protocol that exceeds

612
00:25:19,790 --> 00:25:24,649
exactly this protocol this property so

613
00:25:22,250 --> 00:25:30,350
succinctly of knowledge of this

614
00:25:24,650 --> 00:25:32,810
statement so our the the protocol that

615
00:25:30,350 --> 00:25:34,879
we built that we were build on is this

616
00:25:32,810 --> 00:25:36,590
beautiful proof of exponentiation which

617
00:25:34,880 --> 00:25:40,790
was presented at yura crypt this way

618
00:25:36,590 --> 00:25:42,709
here and what the protocol does it lets

619
00:25:40,790 --> 00:25:46,040
the verify easily check that an

620
00:25:42,710 --> 00:25:48,580
exponentiation was done correctly using

621
00:25:46,040 --> 00:25:51,590
less work than doing the exponentiation

622
00:25:48,580 --> 00:25:53,419
himself right the important thing though

623
00:25:51,590 --> 00:25:56,720
is that the verify actually has input

624
00:25:53,420 --> 00:25:58,970
has UV and alpha itself so could have

625
00:25:56,720 --> 00:26:00,620
done the exponentiation himself it's

626
00:25:58,970 --> 00:26:02,090
just about saving work but we will build

627
00:26:00,620 --> 00:26:04,820
on it to get a proof of knowledge later

628
00:26:02,090 --> 00:26:07,340
so the protocol works by having the

629
00:26:04,820 --> 00:26:10,159
verifier sent a random lambda bit prime

630
00:26:07,340 --> 00:26:13,939
to the prover and the prover is going to

631
00:26:10,160 --> 00:26:14,570
divide alpha by L and get a quotient and

632
00:26:13,940 --> 00:26:17,000
a remainder

633
00:26:14,570 --> 00:26:18,649
note that the remainder is small but the

634
00:26:17,000 --> 00:26:22,460
quotient may be very large on the order

635
00:26:18,650 --> 00:26:26,180
of alpha the prover then sends over you

636
00:26:22,460 --> 00:26:28,420
to the Q and the verifier can compute

637
00:26:26,180 --> 00:26:30,680
the residue are equal to alpha mod L

638
00:26:28,420 --> 00:26:32,960
himself and then check that this

639
00:26:30,680 --> 00:26:35,380
equation holds again in the exponent and

640
00:26:32,960 --> 00:26:37,490
can it can do this very efficiently so

641
00:26:35,380 --> 00:26:39,560
the problem here as I already mentioned

642
00:26:37,490 --> 00:26:40,100
is that the verify needs to know alpha

643
00:26:39,560 --> 00:26:43,309
so how

644
00:26:40,100 --> 00:26:46,129
can we resolve this well the idea is our

645
00:26:43,309 --> 00:26:48,200
first approach is what if the prover

646
00:26:46,130 --> 00:26:50,720
sends the residue it computes the

647
00:26:48,200 --> 00:26:56,150
residue herself anyway what if she just

648
00:26:50,720 --> 00:26:58,400
sends the residue to the verify and well

649
00:26:56,150 --> 00:27:01,760
it turns out that this is in fact a

650
00:26:58,400 --> 00:27:03,620
proof of knowledge of exponent but it's

651
00:27:01,760 --> 00:27:05,750
not really a proof of knowledge of

652
00:27:03,620 --> 00:27:09,379
integer exponent alpha is not

653
00:27:05,750 --> 00:27:14,750
necessarily constrained to be an integer

654
00:27:09,380 --> 00:27:17,659
so the for example if it knows the that

655
00:27:14,750 --> 00:27:19,880
you is for example the V is the square

656
00:27:17,659 --> 00:27:21,710
root of U and it doesn't necessarily

657
00:27:19,880 --> 00:27:24,020
know an integer for which this is true

658
00:27:21,710 --> 00:27:26,630
then it can still succeed in the

659
00:27:24,020 --> 00:27:29,000
protocol by simply computing R equals 2

660
00:27:26,630 --> 00:27:32,240
inverse morale so this is slightly

661
00:27:29,000 --> 00:27:33,470
related to an impossibility result or

662
00:27:32,240 --> 00:27:35,240
this is actually very related to an

663
00:27:33,470 --> 00:27:37,340
impossibility results which says that

664
00:27:35,240 --> 00:27:38,960
notion or like protocol in this protocol

665
00:27:37,340 --> 00:27:41,418
falls in that category can achieve

666
00:27:38,960 --> 00:27:43,580
soundness error less than 1/2 in these

667
00:27:41,419 --> 00:27:45,289
groups of unknown order but if you look

668
00:27:43,580 --> 00:27:47,210
closely at this impossibility result it

669
00:27:45,289 --> 00:27:51,260
assumes that there's no common reference

670
00:27:47,210 --> 00:27:52,970
string and the we show that a very

671
00:27:51,260 --> 00:27:54,710
simple common reference string actually

672
00:27:52,970 --> 00:27:57,409
suffices to get exponential soundness

673
00:27:54,710 --> 00:28:00,010
and the way that we do that is by

674
00:27:57,409 --> 00:28:02,600
forcing the prover to commit to alpha

675
00:28:00,010 --> 00:28:05,539
using an element which is fixed in the

676
00:28:02,600 --> 00:28:09,678
CRS and then it if it's forced to use an

677
00:28:05,539 --> 00:28:12,140
integer alpha so I'll skip over the the

678
00:28:09,679 --> 00:28:16,520
proof idea which really uses the Chinese

679
00:28:12,140 --> 00:28:18,260
remainder theorem to extract but using

680
00:28:16,520 --> 00:28:21,918
this proof we can now get a batch

681
00:28:18,260 --> 00:28:24,140
exclusion proof by simply giving you G

682
00:28:21,919 --> 00:28:27,049
to the B and to prove that this alpha is

683
00:28:24,140 --> 00:28:28,549
known and this proof is constant size so

684
00:28:27,049 --> 00:28:29,809
from this batch inclusion proof we

685
00:28:28,549 --> 00:28:32,480
finally go back to what we originally

686
00:28:29,809 --> 00:28:34,730
wanted which is a vector commitment with

687
00:28:32,480 --> 00:28:37,100
constant size openings using both a

688
00:28:34,730 --> 00:28:39,020
batch inclusion proof for the elements

689
00:28:37,100 --> 00:28:40,549
where the vector is equal to 1 and the

690
00:28:39,020 --> 00:28:44,030
batch exclusion proof for the elements

691
00:28:40,549 --> 00:28:46,340
where the vector is equal to 0 so this

692
00:28:44,030 --> 00:28:47,840
this final vector commitment has very

693
00:28:46,340 --> 00:28:49,639
nice properties and is the first vector

694
00:28:47,840 --> 00:28:52,220
commitment which achieves all of these

695
00:28:49,640 --> 00:28:53,630
properties in parallel which is constant

696
00:28:52,220 --> 00:28:56,690
size openings

697
00:28:53,630 --> 00:28:59,210
such as the protocol that Julia

698
00:28:56,690 --> 00:29:01,610
presented but also fast verification and

699
00:28:59,210 --> 00:29:03,530
the constants ICRS and the support for

700
00:29:01,610 --> 00:29:07,280
these sparse vectors the approver time

701
00:29:03,530 --> 00:29:09,020
is even larger than the work that you

702
00:29:07,280 --> 00:29:11,690
presented and of course significantly

703
00:29:09,020 --> 00:29:14,510
larger than mercury so this is one

704
00:29:11,690 --> 00:29:17,360
downside the you can find the paper

705
00:29:14,510 --> 00:29:19,670
online and there's an implementation by

706
00:29:17,360 --> 00:29:28,760
the folks from Cambrian Labs so you can

707
00:29:19,670 --> 00:29:30,650
also find it online thank you both

708
00:29:28,760 --> 00:29:33,970
speakers are available for questions the

709
00:29:30,650 --> 00:29:33,970
microphones are at the end of the odds

710
00:29:36,550 --> 00:29:41,409
well it seems that we have been both

711
00:29:38,720 --> 00:29:44,600
efficient and have achieved consensus

712
00:29:41,410 --> 00:29:47,300
let's think the speakers again oh sorry

713
00:29:44,600 --> 00:29:50,360
I cannot see you behind this but go

714
00:29:47,300 --> 00:29:52,040
ahead a great presentation Benedict and

715
00:29:50,360 --> 00:29:53,780
I was wondering when you're going to

716
00:29:52,040 --> 00:29:55,790
commit to a vector of lots of elements

717
00:29:53,780 --> 00:29:58,100
you need lots of primes and I was

718
00:29:55,790 --> 00:30:00,260
wondering if it's possible to speed up

719
00:29:58,100 --> 00:30:04,310
prime sampling if you know that you have

720
00:30:00,260 --> 00:30:06,350
to sample a bunch of primes and there is

721
00:30:04,310 --> 00:30:09,440
a good question I think I mean you can

722
00:30:06,350 --> 00:30:12,500
you can do some small pre-computation to

723
00:30:09,440 --> 00:30:14,810
sieve out you know small primes or small

724
00:30:12,500 --> 00:30:18,020
things that are divisible by small

725
00:30:14,810 --> 00:30:20,360
primes but I don't think is something

726
00:30:18,020 --> 00:30:21,980
like a batch primality test which would

727
00:30:20,360 --> 00:30:23,330
be very useful where you can test many

728
00:30:21,980 --> 00:30:26,750
numbers for Prime's I think that's a

729
00:30:23,330 --> 00:30:27,980
major open it's an open problem and

730
00:30:26,750 --> 00:30:31,070
would be something really cool to have

731
00:30:27,980 --> 00:30:32,360
and yeah I think testing Prime's would

732
00:30:31,070 --> 00:30:38,780
be is actually important for both

733
00:30:32,360 --> 00:30:40,100
constructions other questions well in

734
00:30:38,780 --> 00:30:40,910
this case let's do things the speakers

735
00:30:40,100 --> 00:30:45,409
again

736
00:30:40,910 --> 00:30:45,410
[Applause]

