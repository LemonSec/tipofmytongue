1
00:00:04,860 --> 00:00:09,210
thank you so this is joint work with

2
00:00:07,439 --> 00:00:13,410
Casper claim last in the SP buisness and

3
00:00:09,210 --> 00:00:14,910
also from University and so welcome to

4
00:00:13,410 --> 00:00:18,930
the other half of the world of NPC

5
00:00:14,910 --> 00:00:20,279
information table secure NPC and in some

6
00:00:18,930 --> 00:00:22,080
sense that this talk is going to be

7
00:00:20,279 --> 00:00:23,460
about how different that half of the

8
00:00:22,080 --> 00:00:26,159
world is from what Abby just talked

9
00:00:23,460 --> 00:00:28,349
about and this point or I guess it is

10
00:00:26,160 --> 00:00:31,170
indeed very different in in in in some

11
00:00:28,349 --> 00:00:32,759
ways at least so as we all know

12
00:00:31,170 --> 00:00:34,199
information to medically secure NPC

13
00:00:32,759 --> 00:00:36,269
protocols there's a great low

14
00:00:34,199 --> 00:00:38,760
computational overhead no afraid see

15
00:00:36,269 --> 00:00:40,680
here best possible security guarantees

16
00:00:38,760 --> 00:00:43,379
what's not to like but as we also know

17
00:00:40,680 --> 00:00:45,239
they're not so great because you have to

18
00:00:43,379 --> 00:00:46,919
have many rounds and large communication

19
00:00:45,239 --> 00:00:48,449
complexity at least as far as we know

20
00:00:46,920 --> 00:00:51,479
from the protocols that we know about

21
00:00:48,449 --> 00:00:53,570
and a very important long-standing open

22
00:00:51,479 --> 00:00:57,659
problem is whether that is inherent

23
00:00:53,570 --> 00:01:00,570
those costs so so in this talk we we

24
00:00:57,659 --> 00:01:01,979
have some of the answers the spoiler

25
00:01:00,570 --> 00:01:03,960
here is that the communication it's

26
00:01:01,979 --> 00:01:06,299
indeed inherent at least for some

27
00:01:03,960 --> 00:01:10,170
functions but we don't have anything to

28
00:01:06,299 --> 00:01:12,030
say about the rounds um so just to be

29
00:01:10,170 --> 00:01:14,310
explicit about what is what do I mean by

30
00:01:12,030 --> 00:01:15,570
communication overhead so one trivial

31
00:01:14,310 --> 00:01:17,310
observation is that if you don't care

32
00:01:15,570 --> 00:01:18,750
about security of course you can compute

33
00:01:17,310 --> 00:01:20,340
any front any function with

34
00:01:18,750 --> 00:01:21,840
communication complexity with the size

35
00:01:20,340 --> 00:01:23,550
of the input you just send all the

36
00:01:21,840 --> 00:01:26,160
inputs to one guy he computes the

37
00:01:23,550 --> 00:01:27,660
function and then if everybody gets

38
00:01:26,160 --> 00:01:29,130
output of course you should add the

39
00:01:27,660 --> 00:01:30,300
total size of the output because he

40
00:01:29,130 --> 00:01:32,399
needs to send the outputs back to these

41
00:01:30,300 --> 00:01:34,830
guys but we'll only talk about functions

42
00:01:32,400 --> 00:01:37,530
with very short outputs here also to

43
00:01:34,830 --> 00:01:40,110
avoid cases where the communication

44
00:01:37,530 --> 00:01:41,550
complains D is is large for trivial

45
00:01:40,110 --> 00:01:42,870
reasons just because someone has to get

46
00:01:41,550 --> 00:01:47,190
a large output we don't really want to

47
00:01:42,870 --> 00:01:48,240
look at that so the question is if you

48
00:01:47,190 --> 00:01:50,370
take the information theoretically

49
00:01:48,240 --> 00:01:52,619
secure protocol must have communicated

50
00:01:50,370 --> 00:01:55,229
more than the inputs nice it's the most

51
00:01:52,620 --> 00:01:57,570
basic question there's also probably a

52
00:01:55,229 --> 00:01:59,100
much harder question that says what if

53
00:01:57,570 --> 00:02:01,408
the circuit size is much bigger than the

54
00:01:59,100 --> 00:02:03,059
input size must you then communicate

55
00:02:01,409 --> 00:02:04,500
more than the circuit size of the

56
00:02:03,060 --> 00:02:05,850
function that's that's not something we

57
00:02:04,500 --> 00:02:07,560
can say much about we can say some

58
00:02:05,850 --> 00:02:12,060
things though but but it really is a

59
00:02:07,560 --> 00:02:13,890
different question so our result so the

60
00:02:12,060 --> 00:02:14,490
model first we consistently secure

61
00:02:13,890 --> 00:02:16,649
protocols

62
00:02:14,490 --> 00:02:18,300
synchronous network and passive security

63
00:02:16,650 --> 00:02:20,250
Semyon security

64
00:02:18,300 --> 00:02:21,690
we assume secure point-to-point channels

65
00:02:20,250 --> 00:02:23,130
using the standard model here where the

66
00:02:21,690 --> 00:02:25,050
length of the message that you send

67
00:02:23,130 --> 00:02:26,820
always leads to the adversary this is

68
00:02:25,050 --> 00:02:28,590
very natural because if you ever gonna

69
00:02:26,820 --> 00:02:30,780
implement the secure channel you'll be

70
00:02:28,590 --> 00:02:32,280
using whatever using you shouldn't

71
00:02:30,780 --> 00:02:35,670
expect to be able to hide the length of

72
00:02:32,280 --> 00:02:36,870
the message from the adversary there are

73
00:02:35,670 --> 00:02:38,510
two months we can say that honest

74
00:02:36,870 --> 00:02:41,340
majority where the number of players n

75
00:02:38,510 --> 00:02:43,769
is 2 times corruption twice to all t

76
00:02:41,340 --> 00:02:45,360
plus 1 and also dishonest majority with

77
00:02:43,770 --> 00:02:48,000
pre-processing there can also get

78
00:02:45,360 --> 00:02:51,180
information theoretic security and here

79
00:02:48,000 --> 00:02:53,790
n can be T plus 1 while we show in both

80
00:02:51,180 --> 00:02:56,960
models is that for any number of players

81
00:02:53,790 --> 00:02:59,640
n and for infinitely many input sizes s

82
00:02:56,960 --> 00:03:01,890
there exists a function f with input

83
00:02:59,640 --> 00:03:03,839
size s bits so any protocol that

84
00:03:01,890 --> 00:03:06,959
computes F securely has to communicate

85
00:03:03,840 --> 00:03:08,640
at least some constant times n s bits so

86
00:03:06,960 --> 00:03:10,800
that says that there has to be this

87
00:03:08,640 --> 00:03:15,950
function did this factor n overhead

88
00:03:10,800 --> 00:03:18,480
compared to the input size okay and

89
00:03:15,950 --> 00:03:19,859
because it just to make sure this is not

90
00:03:18,480 --> 00:03:22,049
because every player has to compute long

91
00:03:19,860 --> 00:03:23,670
input because has to receive a long

92
00:03:22,050 --> 00:03:28,650
output because the outputs are in fact

93
00:03:23,670 --> 00:03:30,959
very small boys true it happens to be

94
00:03:28,650 --> 00:03:32,580
the case that our functions have very

95
00:03:30,960 --> 00:03:34,770
small circuits in fact linear size

96
00:03:32,580 --> 00:03:36,300
circuits in the input size so the

97
00:03:34,770 --> 00:03:37,680
results also therefore say obviously

98
00:03:36,300 --> 00:03:39,840
that some functions require

99
00:03:37,680 --> 00:03:43,400
communication n times the circuit size

100
00:03:39,840 --> 00:03:45,960
of the function so what this means

101
00:03:43,400 --> 00:03:47,790
intuitively at least is if you have a

102
00:03:45,960 --> 00:03:50,550
general protocol construction that can

103
00:03:47,790 --> 00:03:54,060
compute any circuit securely and if it

104
00:03:50,550 --> 00:03:56,430
does the same the same approach to every

105
00:03:54,060 --> 00:03:58,890
circuit whatever that means then it must

106
00:03:56,430 --> 00:04:00,990
actually always have that factor and

107
00:03:58,890 --> 00:04:02,609
overhead because it has to have it by

108
00:04:00,990 --> 00:04:05,880
these results when it computes that that

109
00:04:02,610 --> 00:04:07,620
function that we construct so in from

110
00:04:05,880 --> 00:04:09,390
that intuition at least it seems that we

111
00:04:07,620 --> 00:04:11,250
always talk with this with this overhead

112
00:04:09,390 --> 00:04:15,000
here at least for the for the public for

113
00:04:11,250 --> 00:04:16,649
cost that we know about for honest

114
00:04:15,000 --> 00:04:18,660
majority we have a matching upper bound

115
00:04:16,649 --> 00:04:20,070
n times the circuit size that's

116
00:04:18,660 --> 00:04:22,290
motivated by the fact that previous

117
00:04:20,070 --> 00:04:24,390
results were off by effects a log n for

118
00:04:22,290 --> 00:04:27,840
circuits that say for boolean circuit

119
00:04:24,390 --> 00:04:30,060
service over small fields for the

120
00:04:27,840 --> 00:04:32,669
pre-processing model there was always an

121
00:04:30,060 --> 00:04:35,700
upper bound shown in a paper from 2

122
00:04:32,670 --> 00:04:39,330
and 13 by UCI eval so the upper bound is

123
00:04:35,700 --> 00:04:41,159
n times s bits of communication

124
00:04:39,330 --> 00:04:43,409
this requires exponential size

125
00:04:41,160 --> 00:04:43,860
pre-processed data but if you can live

126
00:04:43,410 --> 00:04:45,180
with that

127
00:04:43,860 --> 00:04:46,980
then the pre-processing case this is

128
00:04:45,180 --> 00:04:49,710
actually settled the answer is n times

129
00:04:46,980 --> 00:04:53,160
input size good

130
00:04:49,710 --> 00:04:54,900
so we also extend this to self optimal

131
00:04:53,160 --> 00:04:57,630
try so okay so far majority

132
00:04:54,900 --> 00:04:59,729
what about N equals to T plus s where s

133
00:04:57,630 --> 00:05:02,340
can be greater than 1 so the question is

134
00:04:59,730 --> 00:05:04,230
what is smaller now and then the bound

135
00:05:02,340 --> 00:05:06,390
is what it was before but divided by s

136
00:05:04,230 --> 00:05:09,150
now and this is nice because this

137
00:05:06,390 --> 00:05:11,039
exactly matches what we can get from for

138
00:05:09,150 --> 00:05:12,989
other balance using packed secrets yeah

139
00:05:11,040 --> 00:05:15,090
so packed secrets and it's this

140
00:05:12,990 --> 00:05:16,740
technique where you can share a vector

141
00:05:15,090 --> 00:05:20,010
of sequence but this yes is still only

142
00:05:16,740 --> 00:05:22,380
one field element and in this way you

143
00:05:20,010 --> 00:05:24,300
can do a bunch of arithmetic operations

144
00:05:22,380 --> 00:05:26,690
in parallel for the communication cost

145
00:05:24,300 --> 00:05:29,370
of one essentially so this this this

146
00:05:26,690 --> 00:05:30,810
gives smaller communication but but the

147
00:05:29,370 --> 00:05:32,700
price is that the twice old must be

148
00:05:30,810 --> 00:05:34,770
smaller the quatrain one must be smaller

149
00:05:32,700 --> 00:05:38,280
and this exactly matches lists is this

150
00:05:34,770 --> 00:05:42,210
know about that we get here okay so

151
00:05:38,280 --> 00:05:43,559
before diving into how we do this we

152
00:05:42,210 --> 00:05:45,719
just mentioned some some some related

153
00:05:43,560 --> 00:05:48,450
worked as first of all this work by SIA

154
00:05:45,720 --> 00:05:49,980
dial from 13 they prove lower bounds for

155
00:05:48,450 --> 00:05:51,539
two parties in the pre-processing model

156
00:05:49,980 --> 00:05:54,290
and and this upper bound for the

157
00:05:51,540 --> 00:05:57,300
multi-party case that I mentioned then

158
00:05:54,290 --> 00:06:00,210
there's a work by I think data and and

159
00:05:57,300 --> 00:06:02,670
the prop cans they do a lower bound for

160
00:06:00,210 --> 00:06:03,989
three parties and perfect security I was

161
00:06:02,670 --> 00:06:06,120
actually the first results showing that

162
00:06:03,990 --> 00:06:08,070
communication sometimes has to be larger

163
00:06:06,120 --> 00:06:10,910
than the inputs but only that particular

164
00:06:08,070 --> 00:06:14,280
case would three parties and so on

165
00:06:10,910 --> 00:06:16,560
there's a work from yo crypt 16 myself

166
00:06:14,280 --> 00:06:17,669
Nilsson Ostrovsky and and Rosen where we

167
00:06:16,560 --> 00:06:20,070
saw a lower bound on the number of

168
00:06:17,670 --> 00:06:22,110
messages so some functions require you

169
00:06:20,070 --> 00:06:23,460
to send N squared messages everybody

170
00:06:22,110 --> 00:06:25,860
have to talk to everybody else so to

171
00:06:23,460 --> 00:06:27,210
speak this of course means you have to

172
00:06:25,860 --> 00:06:29,460
send and squared bits also in particular

173
00:06:27,210 --> 00:06:30,989
but that that's that's much smaller than

174
00:06:29,460 --> 00:06:33,810
than than our lower bound when the

175
00:06:30,990 --> 00:06:36,750
inputs are large and then finally there

176
00:06:33,810 --> 00:06:39,030
is another work from 16 and where we

177
00:06:36,750 --> 00:06:40,620
showed some lower bounds for gate by

178
00:06:39,030 --> 00:06:42,869
gate protocol so those are protocols

179
00:06:40,620 --> 00:06:45,390
that work the way we used to that you

180
00:06:42,870 --> 00:06:46,470
compute a circuit you do every gate by

181
00:06:45,390 --> 00:06:48,200
itself doesn't support

182
00:06:46,470 --> 00:06:50,640
already one fairy multiplication gate

183
00:06:48,200 --> 00:06:52,200
and for that class of protocol she would

184
00:06:50,640 --> 00:06:53,669
get very strong lower bounds but of

185
00:06:52,200 --> 00:06:54,960
course only for that class of protocols

186
00:06:53,670 --> 00:07:00,480
and we want to do something for

187
00:06:54,960 --> 00:07:02,099
arbitrary protocols okay so a starting

188
00:07:00,480 --> 00:07:05,090
point for the results is to look at two

189
00:07:02,100 --> 00:07:07,290
party private information retrieval so

190
00:07:05,090 --> 00:07:09,239
just to remind you what is what that is

191
00:07:07,290 --> 00:07:12,510
that's a server that's a client the

192
00:07:09,240 --> 00:07:15,540
server has the bit string X the client

193
00:07:12,510 --> 00:07:18,539
has an input in index I that points to

194
00:07:15,540 --> 00:07:20,460
some position in the string X and they

195
00:07:18,540 --> 00:07:22,110
talk that's a transcript T that's formed

196
00:07:20,460 --> 00:07:24,900
and at the end of the day the client can

197
00:07:22,110 --> 00:07:26,600
compute the ice bit of X while a service

198
00:07:24,900 --> 00:07:29,640
not supposed to learn anything here and

199
00:07:26,600 --> 00:07:31,020
and the only very well-known and

200
00:07:29,640 --> 00:07:34,020
straightforward fact that I need about

201
00:07:31,020 --> 00:07:36,210
this situation here is that if this

202
00:07:34,020 --> 00:07:37,590
protocol is perfectly secure then from

203
00:07:36,210 --> 00:07:39,299
the transcript the client can always

204
00:07:37,590 --> 00:07:41,070
compute all of X no matter what about

205
00:07:39,300 --> 00:07:43,230
the protocol does this is very intuitive

206
00:07:41,070 --> 00:07:44,760
if you think about it I mean because of

207
00:07:43,230 --> 00:07:46,980
the privacy requirement right if the

208
00:07:44,760 --> 00:07:49,650
transcript misses information about some

209
00:07:46,980 --> 00:07:51,120
part of X then the server could conclude

210
00:07:49,650 --> 00:07:53,789
that that's not the part that the client

211
00:07:51,120 --> 00:07:56,090
wants right so that this cannot be all

212
00:07:53,790 --> 00:07:58,350
the way it has to be there somehow okay

213
00:07:56,090 --> 00:08:00,390
so that that's the only thing I need you

214
00:07:58,350 --> 00:08:02,250
to remember from this slide that in in

215
00:08:00,390 --> 00:08:04,770
perfectly secure to body pier the client

216
00:08:02,250 --> 00:08:07,919
can always compute the service input

217
00:08:04,770 --> 00:08:09,330
from the transcript so now let's go to

218
00:08:07,919 --> 00:08:10,890
the honest majority oh by the way I

219
00:08:09,330 --> 00:08:13,169
forget this yes so in the following I

220
00:08:10,890 --> 00:08:15,150
only talked about perfect security all

221
00:08:13,169 --> 00:08:17,039
our songs hold for statistical security

222
00:08:15,150 --> 00:08:18,989
also they're essentially the same you

223
00:08:17,040 --> 00:08:21,030
take the perfect secure result and you

224
00:08:18,990 --> 00:08:22,200
take a few small Epsilon's and subtract

225
00:08:21,030 --> 00:08:24,599
here and there and then then you get the

226
00:08:22,200 --> 00:08:28,740
results I will distribute small Epsilon

227
00:08:24,600 --> 00:08:30,720
afterwards you can do it yourself anyway

228
00:08:28,740 --> 00:08:32,570
so honest majority three parties it's

229
00:08:30,720 --> 00:08:35,310
the first step

230
00:08:32,570 --> 00:08:36,659
so the function we consider here is is

231
00:08:35,309 --> 00:08:38,369
the following so there's going to be two

232
00:08:36,659 --> 00:08:41,338
parties on top there's nu P and Luci and

233
00:08:38,370 --> 00:08:45,630
they have each one bit string as input x

234
00:08:41,339 --> 00:08:47,280
and y and Charlie Brown has no inputs

235
00:08:45,630 --> 00:08:49,589
but gets the inner product of those two

236
00:08:47,280 --> 00:08:52,380
bit strings as the output okay

237
00:08:49,589 --> 00:08:54,660
and so we assume that there's a

238
00:08:52,380 --> 00:08:56,250
perfectly secure protocol for the

239
00:08:54,660 --> 00:08:59,020
product function which secure against

240
00:08:56,250 --> 00:09:02,110
one passive corruption

241
00:08:59,020 --> 00:09:04,110
good so you run the protocol and then

242
00:09:02,110 --> 00:09:06,700
there is some messages sent between

243
00:09:04,110 --> 00:09:09,220
party 1 and party - that's called t1 -

244
00:09:06,700 --> 00:09:11,529
that that transcript there which you can

245
00:09:09,220 --> 00:09:14,080
think about it as a random variable and

246
00:09:11,529 --> 00:09:16,649
similarly we have t1 3 and T 2 3

247
00:09:14,080 --> 00:09:19,240
that's inputs in the other two parties

248
00:09:16,649 --> 00:09:22,000
so the first pretty obvious observation

249
00:09:19,240 --> 00:09:23,920
is that since P 2 has no outputs should

250
00:09:22,000 --> 00:09:26,350
learn nothing new from the protocol then

251
00:09:23,920 --> 00:09:28,149
of course in particular t1 2 has to be

252
00:09:26,350 --> 00:09:29,830
independent of X the input of the other

253
00:09:28,149 --> 00:09:30,880
guy right because you're not supposed to

254
00:09:29,830 --> 00:09:34,839
learn anything whatsoever this is

255
00:09:30,880 --> 00:09:36,250
perfect security that's pretty clear so

256
00:09:34,839 --> 00:09:38,589
then with that information we now

257
00:09:36,250 --> 00:09:40,450
consider what's gonna happen if we run

258
00:09:38,589 --> 00:09:44,410
this protocol with a particular choice

259
00:09:40,450 --> 00:09:46,839
of the input Y so let's set Y to be the

260
00:09:44,410 --> 00:09:50,260
all 0 vector except that's 1 in the ice

261
00:09:46,839 --> 00:09:53,110
position ok so if you do this then of

262
00:09:50,260 --> 00:09:55,240
course the inner product of x and y is

263
00:09:53,110 --> 00:09:59,170
going to be the ice bit of X right

264
00:09:55,240 --> 00:10:00,850
obviously so that means that we can now

265
00:09:59,170 --> 00:10:02,170
construct ourselves a two party peer

266
00:10:00,850 --> 00:10:03,940
protocol because we're simply going to

267
00:10:02,170 --> 00:10:05,949
glue those two parties together there

268
00:10:03,940 --> 00:10:08,560
and consider them as being the client

269
00:10:05,950 --> 00:10:10,450
and then of course we have the snow base

270
00:10:08,560 --> 00:10:12,399
that server has input X and now these

271
00:10:10,450 --> 00:10:15,760
two guys together we'll learn the ice

272
00:10:12,399 --> 00:10:18,640
bit of X with that choice of y ou but

273
00:10:15,760 --> 00:10:21,880
what did we say about to party peer we

274
00:10:18,640 --> 00:10:25,270
said that that from the transcript of

275
00:10:21,880 --> 00:10:29,410
the protocol which in this case is t1 2

276
00:10:25,270 --> 00:10:32,470
and T 1 3 the client can compute the

277
00:10:29,410 --> 00:10:34,149
service at the service input X right so

278
00:10:32,470 --> 00:10:38,020
it means that you can compute X from T 1

279
00:10:34,149 --> 00:10:40,839
2 and T 1 3 however we just also said

280
00:10:38,020 --> 00:10:42,760
that C 1 2 itself is independent of X so

281
00:10:40,839 --> 00:10:44,560
from t1 - you have no idea what X is you

282
00:10:42,760 --> 00:10:46,870
bring in c1 3 now all of a sudden you

283
00:10:44,560 --> 00:10:47,890
know what X is so that means that T 1 3

284
00:10:46,870 --> 00:10:51,040
must have contained enough information

285
00:10:47,890 --> 00:10:52,899
to determine X right so therefore just

286
00:10:51,040 --> 00:10:55,569
well Huntress intuitive it has to be at

287
00:10:52,899 --> 00:10:56,829
least as large as X I should pass

288
00:10:55,570 --> 00:10:58,450
mention for those who know about the

289
00:10:56,829 --> 00:11:00,189
technicalities here what we actually

290
00:10:58,450 --> 00:11:03,010
show he has bounced on the entropy of

291
00:11:00,190 --> 00:11:04,209
say T t1 3 and this then implies that

292
00:11:03,010 --> 00:11:05,620
the average communication her place

293
00:11:04,209 --> 00:11:09,660
there must be at least the entropy but

294
00:11:05,620 --> 00:11:12,700
that's that's a detail ok so that's fine

295
00:11:09,660 --> 00:11:16,060
and then from this we can lift ourselves

296
00:11:12,700 --> 00:11:18,100
one step what and do the the yeah okay

297
00:11:16,060 --> 00:11:19,719
just this is two takeaway message from

298
00:11:18,100 --> 00:11:21,250
this slide the guy who gets the output

299
00:11:19,720 --> 00:11:25,360
must communicate a lot this is the only

300
00:11:21,250 --> 00:11:28,720
thing you need to remember okay so now

301
00:11:25,360 --> 00:11:31,330
the general case so here we have two T

302
00:11:28,720 --> 00:11:33,340
plus one parties first we have like TN

303
00:11:31,330 --> 00:11:34,810
connections of Snoopy they look an awful

304
00:11:33,340 --> 00:11:37,240
lot like each other but that's a good

305
00:11:34,810 --> 00:11:41,170
reason for this you'll see so they call

306
00:11:37,240 --> 00:11:44,530
P 1 1 up to P 1 T we have also T Lucis

307
00:11:41,170 --> 00:11:46,750
TPP 2 1 up to P 2 T and we have one

308
00:11:44,530 --> 00:11:51,819
Charlie Brown which is P 3 so 2 T plus 1

309
00:11:46,750 --> 00:11:54,760
parties all together okay and the inputs

310
00:11:51,820 --> 00:11:58,000
that we have here is each party has each

311
00:11:54,760 --> 00:12:00,700
of the top bro parties have a bit factor

312
00:11:58,000 --> 00:12:03,790
as input again X 1 up to X T and also y1

313
00:12:00,700 --> 00:12:06,250
up to Y T are also bit vectors and and

314
00:12:03,790 --> 00:12:09,459
then in addition every party has one bit

315
00:12:06,250 --> 00:12:13,480
as input okay then we b1 1 up to B 1 C

316
00:12:09,460 --> 00:12:17,530
and and so on and and B 3 for Charlie

317
00:12:13,480 --> 00:12:19,480
Brown okay and the way we define the

318
00:12:17,530 --> 00:12:22,839
function is as follows so we define a

319
00:12:19,480 --> 00:12:25,540
value Z which is you concatenate all the

320
00:12:22,840 --> 00:12:26,830
X Factor's concatenate all the Y vectors

321
00:12:25,540 --> 00:12:28,449
in you take the inner product that's

322
00:12:26,830 --> 00:12:30,370
called set and then the outputs are

323
00:12:28,450 --> 00:12:33,640
defined as follows each party gets as

324
00:12:30,370 --> 00:12:35,800
output that in a product times his input

325
00:12:33,640 --> 00:12:36,880
bit so the input bit selects whether you

326
00:12:35,800 --> 00:12:41,890
learn something or whether you learn

327
00:12:36,880 --> 00:12:43,780
nothing okay and now again the that's

328
00:12:41,890 --> 00:12:45,340
that's the function that will prove a

329
00:12:43,780 --> 00:12:46,959
lower bound for we assume the secure

330
00:12:45,340 --> 00:12:49,020
protocol for this function that secure

331
00:12:46,960 --> 00:12:53,290
against thicker options now okay

332
00:12:49,020 --> 00:12:54,790
so again we're gonna hard coat the

333
00:12:53,290 --> 00:12:56,829
inputs in a particular way so that

334
00:12:54,790 --> 00:12:58,689
things will behave nicely

335
00:12:56,830 --> 00:13:01,810
one thing we can do is we can set all

336
00:12:58,690 --> 00:13:04,480
the bij so all the input bits for these

337
00:13:01,810 --> 00:13:06,699
for these top row guys up there will be

338
00:13:04,480 --> 00:13:09,100
0 and only Charlie Brown's input there

339
00:13:06,700 --> 00:13:13,210
will be one it's the only one who

340
00:13:09,100 --> 00:13:15,160
learned something in that case um so

341
00:13:13,210 --> 00:13:16,660
then we can we can get to party protocol

342
00:13:15,160 --> 00:13:18,370
from this right because we're gonna glue

343
00:13:16,660 --> 00:13:20,199
all these Snoopy's together all the

344
00:13:18,370 --> 00:13:22,660
Lucy's together and then Emma get a

345
00:13:20,200 --> 00:13:23,980
three party protocol where because the

346
00:13:22,660 --> 00:13:25,839
original protocol allows for T

347
00:13:23,980 --> 00:13:26,590
corruptions then any one of these three

348
00:13:25,840 --> 00:13:29,080
parties now can

349
00:13:26,590 --> 00:13:31,030
corrupt so that exactly mirrors the

350
00:13:29,080 --> 00:13:32,400
situation from the previous slide it's

351
00:13:31,030 --> 00:13:35,890
exactly the same thing

352
00:13:32,400 --> 00:13:38,920
so remember the guy who gets the output

353
00:13:35,890 --> 00:13:40,600
has to talk a lot right so so in this

354
00:13:38,920 --> 00:13:43,469
case when we hot code the inputs in this

355
00:13:40,600 --> 00:13:46,540
way this guy must communicate at least

356
00:13:43,470 --> 00:13:47,950
order s bits whereas it's a total input

357
00:13:46,540 --> 00:13:52,150
size so the combined length of all these

358
00:13:47,950 --> 00:13:55,570
vectors okay but we can enforce glue

359
00:13:52,150 --> 00:13:57,310
parties together in all kinds of ways so

360
00:13:55,570 --> 00:14:02,350
we can also do something else like we

361
00:13:57,310 --> 00:14:03,729
can say let's set now B 1 1 2 B 1 so the

362
00:14:02,350 --> 00:14:06,820
first inclination of Snoopy gets the

363
00:14:03,730 --> 00:14:09,370
output and nobody else gets anything and

364
00:14:06,820 --> 00:14:12,130
then we also said why want to be one

365
00:14:09,370 --> 00:14:15,070
I'll tell you why that is in a moment so

366
00:14:12,130 --> 00:14:17,560
now we glue plants together like this so

367
00:14:15,070 --> 00:14:18,820
we glue all the t minus one lasting

368
00:14:17,560 --> 00:14:20,079
condition so if no get together with

369
00:14:18,820 --> 00:14:23,950
Charlie Brown and all the losers are

370
00:14:20,080 --> 00:14:25,450
glued together now what is going on the

371
00:14:23,950 --> 00:14:28,000
protocol of course computes the same

372
00:14:25,450 --> 00:14:29,860
function as before namely it

373
00:14:28,000 --> 00:14:31,210
concatenates all the X's all the Y's

374
00:14:29,860 --> 00:14:34,360
does the inner product but now because

375
00:14:31,210 --> 00:14:38,140
y1 is said to be 0 that wipes out in

376
00:14:34,360 --> 00:14:39,700
fact effectively the x1 right so so what

377
00:14:38,140 --> 00:14:42,699
it does is in fact it computes the inner

378
00:14:39,700 --> 00:14:45,370
product of X 2 up to X T concatenated

379
00:14:42,700 --> 00:14:46,600
and Y 2 up to Y T concatenated a little

380
00:14:45,370 --> 00:14:49,690
bit shorter but it's actually the same

381
00:14:46,600 --> 00:14:51,670
size as before so and and and that's the

382
00:14:49,690 --> 00:14:54,640
inner product that the first incarnation

383
00:14:51,670 --> 00:14:56,229
of Snoopy well get and now it's exactly

384
00:14:54,640 --> 00:15:01,150
the same situation again as the previous

385
00:14:56,230 --> 00:15:03,820
slide so so therefore ap11 numbers

386
00:15:01,150 --> 00:15:05,470
communicate orders bits and as you can

387
00:15:03,820 --> 00:15:07,680
easily imagine we can do exactly the

388
00:15:05,470 --> 00:15:10,300
same thing for all the players

389
00:15:07,680 --> 00:15:14,859
so therefore in conclusion what we get

390
00:15:10,300 --> 00:15:17,740
here is that so suggest to summarize

391
00:15:14,860 --> 00:15:19,120
what I just said for each party it holds

392
00:15:17,740 --> 00:15:22,000
that I can hard code the inputs in a

393
00:15:19,120 --> 00:15:24,220
particular way such that this guy gets

394
00:15:22,000 --> 00:15:27,400
the output and that part in that case

395
00:15:24,220 --> 00:15:30,670
must communicate some constant times s

396
00:15:27,400 --> 00:15:33,040
bits but the point now is that the

397
00:15:30,670 --> 00:15:35,410
communication pattern included length of

398
00:15:33,040 --> 00:15:37,990
the messages cannot depend on the inputs

399
00:15:35,410 --> 00:15:39,939
right because Peterson is model even an

400
00:15:37,990 --> 00:15:42,620
adversary who cops no one will see

401
00:15:39,940 --> 00:15:44,420
although the entire communication

402
00:15:42,620 --> 00:15:46,250
pattern can can do traffic analysis and

403
00:15:44,420 --> 00:15:48,800
that shouldn't reveal the inputs so that

404
00:15:46,250 --> 00:15:51,709
means if sometimes some guy has to talk

405
00:15:48,800 --> 00:15:53,390
a lot he has to do it all the time if

406
00:15:51,709 --> 00:15:55,579
the fact but it talks a lot depends on

407
00:15:53,390 --> 00:15:56,839
the inputs and it does here so so

408
00:15:55,579 --> 00:15:59,390
therefore the total communication in

409
00:15:56,839 --> 00:16:01,850
fact has to be I'm again in time such

410
00:15:59,390 --> 00:16:07,010
bits okay

411
00:16:01,850 --> 00:16:09,200
so note also that the function of course

412
00:16:07,010 --> 00:16:10,850
this is just inner product so so you can

413
00:16:09,200 --> 00:16:13,070
certainly compute that using order s

414
00:16:10,850 --> 00:16:14,510
Elementary bits so the bound is also n

415
00:16:13,070 --> 00:16:19,940
times the Circa size of the function s

416
00:16:14,510 --> 00:16:23,839
as I promised before okay good so that

417
00:16:19,940 --> 00:16:25,459
basically sums up what we do for the

418
00:16:23,839 --> 00:16:29,720
honest majority case whether twice world

419
00:16:25,459 --> 00:16:31,279
is full threshold for the for the case I

420
00:16:29,720 --> 00:16:33,230
don't have time to talk in details about

421
00:16:31,279 --> 00:16:36,140
the case of sovereign threshold and the

422
00:16:33,230 --> 00:16:38,209
case of dishonest majority with

423
00:16:36,140 --> 00:16:39,980
pre-processing it's basically very

424
00:16:38,209 --> 00:16:41,680
similar ideas but slightly could

425
00:16:39,980 --> 00:16:45,890
technically slightly different details

426
00:16:41,680 --> 00:16:50,000
if you have I guess I can say that if

427
00:16:45,890 --> 00:16:53,390
you have suboptimal threshold what

428
00:16:50,000 --> 00:16:56,019
happens is that you can start gluing

429
00:16:53,390 --> 00:16:59,209
parties together in small groups and

430
00:16:56,019 --> 00:17:01,190
then you so so we kind of do the the the

431
00:16:59,209 --> 00:17:02,420
transition from the multi-party case

432
00:17:01,190 --> 00:17:04,309
that there's three fatty case which is

433
00:17:02,420 --> 00:17:05,659
still what you would use to in in two

434
00:17:04,309 --> 00:17:07,490
steps first you glue some parties

435
00:17:05,660 --> 00:17:10,089
together then you get something which is

436
00:17:07,490 --> 00:17:11,929
essentially full threshold for this

437
00:17:10,089 --> 00:17:13,490
conglomerate of parties and then then

438
00:17:11,929 --> 00:17:14,839
you go to the last step that was

439
00:17:13,490 --> 00:17:17,809
probably not very clear but I think from

440
00:17:14,839 --> 00:17:21,438
the paper has hopefully clear okay let's

441
00:17:17,809 --> 00:17:23,030
talk about the upper bound so a Faunus

442
00:17:21,439 --> 00:17:25,939
majority there is in fact this this

443
00:17:23,030 --> 00:17:27,678
result from crypto oh seven well why I

444
00:17:25,939 --> 00:17:29,660
showed with with video spinel sin that

445
00:17:27,679 --> 00:17:32,120
any arithmetic circuit can be computed

446
00:17:29,660 --> 00:17:35,210
with passive security and honest

447
00:17:32,120 --> 00:17:38,750
majority in it for 2d was one big

448
00:17:35,210 --> 00:17:42,919
communication that's order n times

449
00:17:38,750 --> 00:17:44,510
circuit size field elements so you might

450
00:17:42,919 --> 00:17:46,160
say but that that's exactly the lower

451
00:17:44,510 --> 00:17:47,480
bound isn't it so there's already a

452
00:17:46,160 --> 00:17:49,760
matching upper bound but there's a catch

453
00:17:47,480 --> 00:17:53,020
namely that this only works if the field

454
00:17:49,760 --> 00:17:53,020
size is larger than n

455
00:17:53,060 --> 00:17:56,870
so if I want to compute the boolean

456
00:17:54,770 --> 00:17:58,580
circuit say I can still do that with

457
00:17:56,870 --> 00:18:01,429
that protocol I just need to run it with

458
00:17:58,580 --> 00:18:03,740
an extension field I need to make it big

459
00:18:01,430 --> 00:18:07,010
enough that that I can have n evaluation

460
00:18:03,740 --> 00:18:09,230
points in the field and so this means

461
00:18:07,010 --> 00:18:12,140
that I would have to put in a log n

462
00:18:09,230 --> 00:18:14,180
factor into the communication complexity

463
00:18:12,140 --> 00:18:17,530
of this thing for a boolean circuit so

464
00:18:14,180 --> 00:18:20,000
if we can get rid of this thing by using

465
00:18:17,530 --> 00:18:22,280
tool from last year there is something

466
00:18:20,000 --> 00:18:24,200
called reverse multiplication friendly

467
00:18:22,280 --> 00:18:26,060
embeddings that's something that that

468
00:18:24,200 --> 00:18:29,570
appears in the paper by crane medallion

469
00:18:26,060 --> 00:18:33,520
in crypto last year it's basically the

470
00:18:29,570 --> 00:18:36,679
idea is that it's a way to take to

471
00:18:33,520 --> 00:18:38,900
implement many parallel multiplications

472
00:18:36,680 --> 00:18:41,270
in a small field by doing just one

473
00:18:38,900 --> 00:18:42,650
multiplication in the bigger field so

474
00:18:41,270 --> 00:18:44,450
basically what would you do is you take

475
00:18:42,650 --> 00:18:47,090
your your two vectors that you want to

476
00:18:44,450 --> 00:18:49,070
point wise multiply and you encode them

477
00:18:47,090 --> 00:18:50,929
using a special encoding function into

478
00:18:49,070 --> 00:18:52,820
two field elements in the bigger fields

479
00:18:50,930 --> 00:18:54,410
then you multiply in the bigger field

480
00:18:52,820 --> 00:18:56,480
once and you get something which

481
00:18:54,410 --> 00:18:59,830
essentially encodes all these parallel

482
00:18:56,480 --> 00:19:03,290
multiplication results that they wanted

483
00:18:59,830 --> 00:19:04,790
so so then what we do is you combine

484
00:19:03,290 --> 00:19:06,950
these two things you basically run the

485
00:19:04,790 --> 00:19:08,870
old protocol from row 7 over the bigger

486
00:19:06,950 --> 00:19:10,550
field and this then does what you want

487
00:19:08,870 --> 00:19:12,169
essentially you have to do some

488
00:19:10,550 --> 00:19:14,090
unpacking at the end but that turns out

489
00:19:12,170 --> 00:19:15,740
to be only for one big field or method

490
00:19:14,090 --> 00:19:17,590
you have to do something non-trivial so

491
00:19:15,740 --> 00:19:23,780
so that basically gives you the the

492
00:19:17,590 --> 00:19:27,379
corresponding upper bound ok so let me

493
00:19:23,780 --> 00:19:30,490
go to open problems and field work

494
00:19:27,380 --> 00:19:33,200
so there's ongoing work where we try and

495
00:19:30,490 --> 00:19:35,420
be very happy to receive any inspiration

496
00:19:33,200 --> 00:19:37,250
for this that it would be nice to have

497
00:19:35,420 --> 00:19:40,070
lower bounds for also let's say

498
00:19:37,250 --> 00:19:41,660
naturally occurring functions that is

499
00:19:40,070 --> 00:19:43,070
functions that we haven't especially

500
00:19:41,660 --> 00:19:45,650
engineered to be able to prove the lower

501
00:19:43,070 --> 00:19:47,570
bound and and and them a my base in

502
00:19:45,650 --> 00:19:49,070
which functions naturally behave in sort

503
00:19:47,570 --> 00:19:53,050
of similar ways to what we engineered

504
00:19:49,070 --> 00:19:56,409
here so that that would be interesting a

505
00:19:53,050 --> 00:19:58,730
really tough question but also a

506
00:19:56,410 --> 00:19:59,990
immensely interesting question is what

507
00:19:58,730 --> 00:20:02,270
is the circuit size it's much bigger

508
00:19:59,990 --> 00:20:05,030
than the inputs is there a lower bound

509
00:20:02,270 --> 00:20:06,650
and the grows with the circuit size this

510
00:20:05,030 --> 00:20:08,420
is a question of a completely different

511
00:20:06,650 --> 00:20:09,860
nature than the one we had to resolve

512
00:20:08,420 --> 00:20:12,080
which has to do with the input size I

513
00:20:09,860 --> 00:20:13,699
mean for one thing if I give you a

514
00:20:12,080 --> 00:20:14,780
function a bit for most functions we

515
00:20:13,700 --> 00:20:17,740
don't even know where the circuit size

516
00:20:14,780 --> 00:20:19,820
is right so without some kind of

517
00:20:17,740 --> 00:20:21,860
assumption we will certainly get nowhere

518
00:20:19,820 --> 00:20:23,750
here and even then I think it's it's

519
00:20:21,860 --> 00:20:24,649
it's it's really totally different

520
00:20:23,750 --> 00:20:28,580
techniques that you would need to do

521
00:20:24,650 --> 00:20:30,860
this for the pre-processing model there

522
00:20:28,580 --> 00:20:33,260
was this open problem left so the

523
00:20:30,860 --> 00:20:33,709
existing upper bound says enzymes input

524
00:20:33,260 --> 00:20:35,660
size

525
00:20:33,710 --> 00:20:39,050
that's for optimal threshold and a c

526
00:20:35,660 --> 00:20:41,150
plus 1 m but what if we have suboptimal

527
00:20:39,050 --> 00:20:44,000
threshold then our bound degrades a

528
00:20:41,150 --> 00:20:48,710
little bit it divides NS by this little

529
00:20:44,000 --> 00:20:50,060
s that appears so this here gets divided

530
00:20:48,710 --> 00:20:53,420
by there's a lower bound gets smaller

531
00:20:50,060 --> 00:20:54,620
when this ratio get smaller and and we

532
00:20:53,420 --> 00:20:56,560
don't know whether we have an upper

533
00:20:54,620 --> 00:21:02,570
bound that can match that thing there

534
00:20:56,560 --> 00:21:04,220
okay and finally something which used to

535
00:21:02,570 --> 00:21:08,840
be an open problem but I think is now

536
00:21:04,220 --> 00:21:11,020
actually closed so what about a lower

537
00:21:08,840 --> 00:21:15,620
bound for perfect malicious security and

538
00:21:11,020 --> 00:21:17,870
any it was three three three plus one so

539
00:21:15,620 --> 00:21:19,250
you might think that okay Melissa's

540
00:21:17,870 --> 00:21:20,810
security should be easy because that

541
00:21:19,250 --> 00:21:22,700
implies passive security just apply our

542
00:21:20,810 --> 00:21:26,240
bound and this doesn't work here because

543
00:21:22,700 --> 00:21:29,720
the threshold here right there is is is

544
00:21:26,240 --> 00:21:31,790
inferred and we do something for n over

545
00:21:29,720 --> 00:21:33,050
two it's right so get smaller the

546
00:21:31,790 --> 00:21:35,270
boundary great so if you go all the way

547
00:21:33,050 --> 00:21:38,180
down to n over 3 our bond sells we have

548
00:21:35,270 --> 00:21:39,710
essentially nothing so it turns out that

549
00:21:38,180 --> 00:21:41,570
there is a different argument that

550
00:21:39,710 --> 00:21:43,490
explicitly exploits the fact that we

551
00:21:41,570 --> 00:21:44,750
have malicious security and it gives the

552
00:21:43,490 --> 00:21:46,580
same result there are some details we

553
00:21:44,750 --> 00:21:48,710
have to check but it seems to work out

554
00:21:46,580 --> 00:21:50,480
and then you get the same result in time

555
00:21:48,710 --> 00:21:52,670
circuit size as we have a passive

556
00:21:50,480 --> 00:21:54,710
security and by coincidence which is

557
00:21:52,670 --> 00:21:57,500
almost too good to be true the next talk

558
00:21:54,710 --> 00:22:00,010
in the session coil it out will tell you

559
00:21:57,500 --> 00:22:04,370
that that's exactly the upper bound so

560
00:22:00,010 --> 00:22:05,960
that's that's quite amazing but yeah so

561
00:22:04,370 --> 00:22:08,679
that's what I had but that I also think

562
00:22:05,960 --> 00:22:08,680
for your attention

563
00:22:13,250 --> 00:22:18,810
go ahead so you use the fact that the

564
00:22:16,680 --> 00:22:22,560
communication channel leaks the size of

565
00:22:18,810 --> 00:22:24,030
the messages do you think the bounce

566
00:22:22,560 --> 00:22:26,340
still holds if you have some sort of

567
00:22:24,030 --> 00:22:27,360
idealized channel that doesn't link I

568
00:22:26,340 --> 00:22:29,909
think so

569
00:22:27,360 --> 00:22:32,459
so do the bounce still hold if if the

570
00:22:29,910 --> 00:22:35,880
message links do not leak I think I

571
00:22:32,460 --> 00:22:37,110
think we were maybe a bit lazy I think

572
00:22:35,880 --> 00:22:38,700
we can still prove something even

573
00:22:37,110 --> 00:22:39,990
without that assumption then then we you

574
00:22:38,700 --> 00:22:41,520
have to have an adversary that that

575
00:22:39,990 --> 00:22:43,860
corrupts some of the players and and

576
00:22:41,520 --> 00:22:47,400
watches what is being sent and I'm

577
00:22:43,860 --> 00:22:48,990
pretty sure that could be worked out so

578
00:22:47,400 --> 00:22:51,660
my question is the theorem statements

579
00:22:48,990 --> 00:22:53,220
you said are about average communication

580
00:22:51,660 --> 00:22:55,230
the average complexity of a protocol

581
00:22:53,220 --> 00:22:58,440
right yeah so could it be that that

582
00:22:55,230 --> 00:23:00,000
average is basically due to you know low

583
00:22:58,440 --> 00:23:02,160
probability events having extreme

584
00:23:00,000 --> 00:23:03,720
communication ie can you make a

585
00:23:02,160 --> 00:23:05,700
statement about the variance and and

586
00:23:03,720 --> 00:23:07,710
argue that there can't be some protocols

587
00:23:05,700 --> 00:23:10,110
that are actually pretty good but their

588
00:23:07,710 --> 00:23:14,610
averages are large for obscure reasons

589
00:23:10,110 --> 00:23:16,649
that's a good question I don't have a

590
00:23:14,610 --> 00:23:19,860
good answer to that that that would have

591
00:23:16,650 --> 00:23:21,810
to be I think a different study I don't

592
00:23:19,860 --> 00:23:23,429
see anything that we have in the paper

593
00:23:21,810 --> 00:23:30,520
that will tell you directly what the

594
00:23:23,430 --> 00:23:35,480
answer to that one great thank you even

595
00:23:30,520 --> 00:23:35,480
[Applause]

