1
00:00:01,040 --> 00:00:03,360
hi this is joint work with ilan kumar

2
00:00:03,360 --> 00:00:04,560
gursky

3
00:00:04,560 --> 00:00:07,040
very broadly this work is about proving

4
00:00:07,040 --> 00:00:09,280
limitations on the best possible time

5
00:00:09,280 --> 00:00:11,519
space trade-off attacks for finding

6
00:00:11,519 --> 00:00:14,799
short collisions in mercury

7
00:00:14,799 --> 00:00:16,239
hash functions are one of the

8
00:00:16,239 --> 00:00:18,640
fundamental primitives of cryptography

9
00:00:18,640 --> 00:00:21,039
that have many different applications

10
00:00:21,039 --> 00:00:23,039
certain applications like password

11
00:00:23,039 --> 00:00:24,640
hashing etc

12
00:00:24,640 --> 00:00:26,800
require a hash function to handle

13
00:00:26,800 --> 00:00:28,560
different input layers

14
00:00:28,560 --> 00:00:31,760
however it is infeasible to design a

15
00:00:31,760 --> 00:00:35,200
different hash function for every length

16
00:00:35,200 --> 00:00:37,840
hence iterative hashing is used to

17
00:00:37,840 --> 00:00:40,079
construct variable input length hash

18
00:00:40,079 --> 00:00:41,040
function

19
00:00:41,040 --> 00:00:44,079
using fixed input length primitive

20
00:00:44,079 --> 00:00:46,000
some popular iterative hashing

21
00:00:46,000 --> 00:00:48,160
mechanisms are the merkle dam guard

22
00:00:48,160 --> 00:00:52,000
construction and the sponge construction

23
00:00:52,160 --> 00:00:54,399
our focus for this stock is the merkle

24
00:00:54,399 --> 00:00:57,280
dam guard construction uh it is based on

25
00:00:57,280 --> 00:00:59,280
a compression function h

26
00:00:59,280 --> 00:01:01,840
that takes as input two values lying in

27
00:01:01,840 --> 00:01:03,120
one through l

28
00:01:03,120 --> 00:01:06,240
and outputs a value in one through n

29
00:01:06,240 --> 00:01:09,280
the hash of a message m is defined with

30
00:01:09,280 --> 00:01:11,439
respect to a hash key a

31
00:01:11,439 --> 00:01:14,640
also known as the salt as follows

32
00:01:14,640 --> 00:01:17,200
m is padded up to an appropriate length

33
00:01:17,200 --> 00:01:20,000
and then broken up into blocks such that

34
00:01:20,000 --> 00:01:23,439
each block lies in once when

35
00:01:23,439 --> 00:01:25,600
the compression function is first

36
00:01:25,600 --> 00:01:26,400
evaluated

37
00:01:26,400 --> 00:01:28,240
using the salt and the first message

38
00:01:28,240 --> 00:01:29,360
block

39
00:01:29,360 --> 00:01:31,520
next it is evaluated

40
00:01:31,520 --> 00:01:34,159
again using the first output along with

41
00:01:34,159 --> 00:01:37,200
the second message block and so on

42
00:01:37,200 --> 00:01:39,439
the output produced by the final

43
00:01:39,439 --> 00:01:41,040
evaluation

44
00:01:41,040 --> 00:01:43,360
of the compression function is the hash

45
00:01:43,360 --> 00:01:47,840
of m with respect to the salt a

46
00:01:48,399 --> 00:01:51,759
this construction is used in md5 sha-1

47
00:01:51,759 --> 00:01:52,840
and

48
00:01:52,840 --> 00:01:56,079
sha-2 one very fundamental property that

49
00:01:56,079 --> 00:01:58,799
we want any hash function to satisfy is

50
00:01:58,799 --> 00:02:01,360
that of collision resistance

51
00:02:01,360 --> 00:02:02,320
that is

52
00:02:02,320 --> 00:02:05,600
given a random sort it must be hard to

53
00:02:05,600 --> 00:02:07,600
find two distinct messages

54
00:02:07,600 --> 00:02:11,119
that hatch to the same value

55
00:02:11,280 --> 00:02:13,599
we are interested in quantifying the

56
00:02:13,599 --> 00:02:15,760
collision resistance of the merkle dam

57
00:02:15,760 --> 00:02:17,520
guard construction

58
00:02:17,520 --> 00:02:20,000
the most common approach used in doing

59
00:02:20,000 --> 00:02:22,000
this is to model the compression

60
00:02:22,000 --> 00:02:24,879
function h as a random work

61
00:02:24,879 --> 00:02:27,840
uh when doing so uh one can find

62
00:02:27,840 --> 00:02:30,160
positions using roughly

63
00:02:30,160 --> 00:02:32,959
square root n queries to the random verb

64
00:02:32,959 --> 00:02:36,000
ah this is essentially the per data and

65
00:02:36,000 --> 00:02:39,040
this attack is optimal

66
00:02:39,040 --> 00:02:40,720
but typically

67
00:02:40,720 --> 00:02:42,720
age is a public function

68
00:02:42,720 --> 00:02:44,640
and the adversary might be able to do a

69
00:02:44,640 --> 00:02:46,879
lot of preprocessing on it

70
00:02:46,879 --> 00:02:49,120
and it turns out that this birthday

71
00:02:49,120 --> 00:02:51,840
style attack is no longer the best one

72
00:02:51,840 --> 00:02:53,280
when considering

73
00:02:53,280 --> 00:02:55,200
adversaries that can do pre-processing

74
00:02:55,200 --> 00:02:57,280
on the random work

75
00:02:57,280 --> 00:02:58,959
the scenario of pre-processing

76
00:02:58,959 --> 00:03:01,599
adversaries were studied in many earlier

77
00:03:01,599 --> 00:03:04,000
works for example in the context of

78
00:03:04,000 --> 00:03:05,920
function inversion collision resistance

79
00:03:05,920 --> 00:03:08,319
etcetera

80
00:03:09,360 --> 00:03:12,080
the auxiliary input random oracle model

81
00:03:12,080 --> 00:03:14,640
introduced by uru captures the power of

82
00:03:14,640 --> 00:03:16,400
pre-processing adversaries against

83
00:03:16,400 --> 00:03:19,360
random work the collision resistance

84
00:03:19,360 --> 00:03:21,519
game in this model is formalized as

85
00:03:21,519 --> 00:03:22,720
follows

86
00:03:22,720 --> 00:03:24,959
an adversary is modeled as a two phase

87
00:03:24,959 --> 00:03:26,000
one

88
00:03:26,000 --> 00:03:28,319
uh its pre-processing phase gets full

89
00:03:28,319 --> 00:03:30,480
access to the random oracle and it

90
00:03:30,480 --> 00:03:33,840
outputs s bits which is passed on

91
00:03:33,840 --> 00:03:36,159
to the online phase which additionally

92
00:03:36,159 --> 00:03:38,000
gets as input

93
00:03:38,000 --> 00:03:40,959
randomly sample salt a

94
00:03:40,959 --> 00:03:43,200
the online phase can make at most t

95
00:03:43,200 --> 00:03:45,280
queries to the random oracle

96
00:03:45,280 --> 00:03:47,440
the adversary wins if the online phase

97
00:03:47,440 --> 00:03:49,440
outputs two distinct messages which are

98
00:03:49,440 --> 00:03:51,120
the same hash with respect to the

99
00:03:51,120 --> 00:03:53,519
sorting

100
00:03:53,519 --> 00:03:56,239
we refer to such an adversary a as an

101
00:03:56,239 --> 00:03:58,239
sdn person

102
00:03:58,239 --> 00:04:00,239
we parameterize the advantage in terms

103
00:04:00,239 --> 00:04:01,680
of s and t

104
00:04:01,680 --> 00:04:03,280
and define it to be the maximum

105
00:04:03,280 --> 00:04:05,840
probability of any s d adversary winning

106
00:04:05,840 --> 00:04:07,680
this game

107
00:04:07,680 --> 00:04:09,439
ah we note that in allowing the

108
00:04:09,439 --> 00:04:12,400
adversary to compute any arbitrary s

109
00:04:12,400 --> 00:04:14,879
bits of preprocessing we make it very

110
00:04:14,879 --> 00:04:15,840
powerful

111
00:04:15,840 --> 00:04:18,399
hence any limitations proved in this

112
00:04:18,399 --> 00:04:22,560
model imply very strong guarantee

113
00:04:23,759 --> 00:04:25,880
currently at all gave a tight

114
00:04:25,880 --> 00:04:28,400
characterization of this advantage in

115
00:04:28,400 --> 00:04:30,000
terms of snt

116
00:04:30,000 --> 00:04:31,040
that is

117
00:04:31,040 --> 00:04:35,040
they proved an asymptotic upper bound of

118
00:04:35,040 --> 00:04:39,120
st squared by n on the advantage

119
00:04:39,120 --> 00:04:41,680
of any st adversary and also gave an

120
00:04:41,680 --> 00:04:44,639
attack that achieves this advantage

121
00:04:44,639 --> 00:04:45,759
however

122
00:04:45,759 --> 00:04:48,320
their attack finds collisions of length

123
00:04:48,320 --> 00:04:49,919
nearly t

124
00:04:49,919 --> 00:04:52,639
now say that an attack takes time to

125
00:04:52,639 --> 00:04:54,080
power 60.

126
00:04:54,080 --> 00:04:55,919
yeah it means that the collision that it

127
00:04:55,919 --> 00:04:57,440
finds is

128
00:04:57,440 --> 00:04:59,040
petabytes long

129
00:04:59,040 --> 00:05:01,600
uh collisions that long are not really

130
00:05:01,600 --> 00:05:03,280
useful for any

131
00:05:03,280 --> 00:05:05,440
practical purposes

132
00:05:05,440 --> 00:05:07,840
in addition short collisions are harder

133
00:05:07,840 --> 00:05:11,120
to find the longer ones this was proven

134
00:05:11,120 --> 00:05:13,840
by akshima at all here the two in the

135
00:05:13,840 --> 00:05:16,400
subscript denotes the

136
00:05:16,400 --> 00:05:18,479
advantage of an st adversary in finding

137
00:05:18,479 --> 00:05:20,400
two block positions that is collisions

138
00:05:20,400 --> 00:05:22,720
where both the messages are at most two

139
00:05:22,720 --> 00:05:25,840
blocks long ah akshma at all showed that

140
00:05:25,840 --> 00:05:27,520
the advantage for finding two block

141
00:05:27,520 --> 00:05:29,440
collisions is upper bounded

142
00:05:29,440 --> 00:05:31,039
asymptotically by

143
00:05:31,039 --> 00:05:34,000
s t by n plus t square by n

144
00:05:34,000 --> 00:05:36,080
and this result implies that the two

145
00:05:36,080 --> 00:05:38,160
block collisions are harder to find than

146
00:05:38,160 --> 00:05:41,120
arbitrary electrons

147
00:05:41,120 --> 00:05:43,840
further in the same work they gave an

148
00:05:43,840 --> 00:05:46,479
attack that has advantage

149
00:05:46,479 --> 00:05:47,520
roughly

150
00:05:47,520 --> 00:05:50,720
stb by n plus t square by n ignoring the

151
00:05:50,720 --> 00:05:52,560
polylog factor

152
00:05:52,560 --> 00:05:54,400
ah we refer to this attack as the

153
00:05:54,400 --> 00:05:56,160
estimator

154
00:05:56,160 --> 00:05:59,199
they also put forth the conjecture ah

155
00:05:59,199 --> 00:06:01,680
called the stb conjecture which says

156
00:06:01,680 --> 00:06:04,560
that the stb attack is asymptotically

157
00:06:04,560 --> 00:06:07,919
optimal for any value of p

158
00:06:07,919 --> 00:06:09,600
before our work

159
00:06:09,600 --> 00:06:12,319
this conjecture was unresolved for any

160
00:06:12,319 --> 00:06:14,960
value of p that is at least 3 but much

161
00:06:14,960 --> 00:06:17,520
less than t

162
00:06:18,000 --> 00:06:19,759
in this work we show that this

163
00:06:19,759 --> 00:06:21,919
conjecture is true for all constant

164
00:06:21,919 --> 00:06:23,360
values of b

165
00:06:23,360 --> 00:06:25,360
ah and for certain other range of

166
00:06:25,360 --> 00:06:26,560
parameters

167
00:06:26,560 --> 00:06:29,840
our two results are incomparable

168
00:06:29,840 --> 00:06:32,800
i will cover the proof of the conjecture

169
00:06:32,800 --> 00:06:35,039
for all constant values of p in the rest

170
00:06:35,039 --> 00:06:36,479
of the stock

171
00:06:36,479 --> 00:06:39,039
i refer you to our paper for the details

172
00:06:39,039 --> 00:06:41,440
of the other result

173
00:06:41,440 --> 00:06:44,160
also i should note that this second

174
00:06:44,160 --> 00:06:46,560
result was recently improved upon in a

175
00:06:46,560 --> 00:06:51,280
follow-up work by akshima guo and liu

176
00:06:51,759 --> 00:06:54,639
this is the main theorem that we prove

177
00:06:54,639 --> 00:06:57,840
we show that the maximum advantage of an

178
00:06:57,840 --> 00:07:00,240
sd adversary in finding a b block

179
00:07:00,240 --> 00:07:01,440
collision

180
00:07:01,440 --> 00:07:04,800
is asymptotically upper bounded by

181
00:07:04,800 --> 00:07:06,720
s t v squared

182
00:07:06,720 --> 00:07:10,080
times log s power b whole divided by n

183
00:07:10,080 --> 00:07:13,039
plus t square over n

184
00:07:13,039 --> 00:07:15,599
for constant values of b

185
00:07:15,599 --> 00:07:18,240
this is asymptotically st by n plus t

186
00:07:18,240 --> 00:07:20,080
square o by n

187
00:07:20,080 --> 00:07:23,280
ignoring ah the pull log factors

188
00:07:23,280 --> 00:07:25,199
ah this proves the sdb conjecture for

189
00:07:25,199 --> 00:07:27,680
all constant values

190
00:07:27,680 --> 00:07:30,319
the proof of this theorem is based on

191
00:07:30,319 --> 00:07:33,120
the multi-instance framework uh recently

192
00:07:33,120 --> 00:07:35,680
introduced in the works of chung atoll

193
00:07:35,680 --> 00:07:38,080
and akshima at all

194
00:07:38,080 --> 00:07:40,160
this framework was inspired by the

195
00:07:40,160 --> 00:07:42,880
beautiful techniques used to prove a

196
00:07:42,880 --> 00:07:44,960
constructive churn of bounds

197
00:07:44,960 --> 00:07:48,719
by impali also and components

198
00:07:48,879 --> 00:07:50,639
now here is a very brief description of

199
00:07:50,639 --> 00:07:52,080
the framework

200
00:07:52,080 --> 00:07:55,440
first u different source a1 through au

201
00:07:55,440 --> 00:07:58,720
are sampled uniformly at random the

202
00:07:58,720 --> 00:08:00,879
online phase of the adversary gets some

203
00:08:00,879 --> 00:08:03,039
fixed preprocessing independent of the

204
00:08:03,039 --> 00:08:07,199
uh random oracle say the all zero string

205
00:08:07,199 --> 00:08:08,560
and the

206
00:08:08,560 --> 00:08:10,560
random salt a1

207
00:08:10,560 --> 00:08:12,720
it can make at most t queries to the

208
00:08:12,720 --> 00:08:16,240
random oracle and it needs to output a b

209
00:08:16,240 --> 00:08:18,879
block collision

210
00:08:19,039 --> 00:08:19,840
ah

211
00:08:19,840 --> 00:08:22,000
next the online phase of the adversary

212
00:08:22,000 --> 00:08:25,039
is successively run on the other sample

213
00:08:25,039 --> 00:08:27,199
sorts

214
00:08:27,199 --> 00:08:29,680
the adversary wins the multi-instance

215
00:08:29,680 --> 00:08:32,159
game if it successfully finds a b block

216
00:08:32,159 --> 00:08:35,519
collision for every source

217
00:08:36,880 --> 00:08:39,200
the multi-instance lemma relays the

218
00:08:39,200 --> 00:08:41,919
maximum advantage of an st adversary in

219
00:08:41,919 --> 00:08:44,240
finding a b block collision to the

220
00:08:44,240 --> 00:08:46,160
maximum probability of an adversary

221
00:08:46,160 --> 00:08:48,160
winning the multi-instance game which we

222
00:08:48,160 --> 00:08:51,680
refer to using epsilon

223
00:08:51,680 --> 00:08:53,920
in more detail the lemma shows that when

224
00:08:53,920 --> 00:08:55,920
u is s plus log n

225
00:08:55,920 --> 00:08:58,160
uh the maximum advantage of any st

226
00:08:58,160 --> 00:09:00,160
adversary in finding a v block collision

227
00:09:00,160 --> 00:09:02,640
is upper bounded by at most

228
00:09:02,640 --> 00:09:05,600
epsilon power one by u

229
00:09:05,600 --> 00:09:08,640
ah we will prove that uh

230
00:09:08,640 --> 00:09:12,480
epsilon is in turn upper bounded by this

231
00:09:12,480 --> 00:09:14,320
quantity here

232
00:09:14,320 --> 00:09:17,680
uh which for constant values of b and u

233
00:09:17,680 --> 00:09:19,760
equals s plus log n

234
00:09:19,760 --> 00:09:22,720
is asymptotically in the order of st by

235
00:09:22,720 --> 00:09:25,440
n plus t square by n power u

236
00:09:25,440 --> 00:09:27,920
ignoring the polylog factors

237
00:09:27,920 --> 00:09:30,480
applying the multi instance lemma

238
00:09:30,480 --> 00:09:32,080
would give us the upper bound that we

239
00:09:32,080 --> 00:09:34,160
set out to prove on the maximum

240
00:09:34,160 --> 00:09:37,040
advantage of an sd adversary in finding

241
00:09:37,040 --> 00:09:39,839
v-block collisions

242
00:09:39,839 --> 00:09:40,880
so

243
00:09:40,880 --> 00:09:41,600
we

244
00:09:41,600 --> 00:09:43,920
need to upper bound the maximum

245
00:09:43,920 --> 00:09:46,640
advantage of the adversary against the

246
00:09:46,640 --> 00:09:49,200
multi-instance game

247
00:09:49,200 --> 00:09:50,800
we shall do this using a compression

248
00:09:50,800 --> 00:09:52,160
argument

249
00:09:52,160 --> 00:09:53,680
the main idea behind the combustion

250
00:09:53,680 --> 00:09:54,640
argument

251
00:09:54,640 --> 00:09:57,360
which is formalized in the lemma here

252
00:09:57,360 --> 00:09:59,680
is that it is impossible to compress a

253
00:09:59,680 --> 00:10:02,160
random element in the set x

254
00:10:02,160 --> 00:10:04,560
to a string shorter than

255
00:10:04,560 --> 00:10:07,360
log of size of x bits long

256
00:10:07,360 --> 00:10:11,279
even relative to a random string

257
00:10:12,240 --> 00:10:14,800
recall that our goal is to upper bound

258
00:10:14,800 --> 00:10:16,720
the advantage of an adversary in winning

259
00:10:16,720 --> 00:10:18,880
this multi-instance game

260
00:10:18,880 --> 00:10:22,000
our strategy uh will be to come up with

261
00:10:22,000 --> 00:10:24,720
an encoding and decoding procedure uh

262
00:10:24,720 --> 00:10:27,600
for the random oracle h and the random

263
00:10:27,600 --> 00:10:29,680
solves a one through a u

264
00:10:29,680 --> 00:10:32,959
uh that which uses this adversary

265
00:10:32,959 --> 00:10:35,120
such that the decoding procedure is

266
00:10:35,120 --> 00:10:38,800
correct whenever this adversary will

267
00:10:38,800 --> 00:10:40,560
using the the compression lemma would

268
00:10:40,560 --> 00:10:42,320
then lead us to an upper bound on the

269
00:10:42,320 --> 00:10:44,079
maximum probability of the adversary

270
00:10:44,079 --> 00:10:47,120
meaning the multi instance

271
00:10:47,120 --> 00:10:49,519
before starting uh with the encoding

272
00:10:49,519 --> 00:10:50,800
procedure

273
00:10:50,800 --> 00:10:53,120
let us make this following simplifying

274
00:10:53,120 --> 00:10:55,839
assumption that when the adversary

275
00:10:55,839 --> 00:10:57,839
multi-instance game adversary runs on a

276
00:10:57,839 --> 00:11:00,640
particular salt it only queries the

277
00:11:00,640 --> 00:11:02,720
random oracle on

278
00:11:02,720 --> 00:11:06,640
values prefixed by the particular salt

279
00:11:06,640 --> 00:11:08,880
of course this assumption is false but

280
00:11:08,880 --> 00:11:10,959
we will make it initially for the ease

281
00:11:10,959 --> 00:11:12,240
of exposition

282
00:11:12,240 --> 00:11:15,519
and remove it later on in the top

283
00:11:15,519 --> 00:11:17,680
note that this assumption in particular

284
00:11:17,680 --> 00:11:20,160
implies that the query made by

285
00:11:20,160 --> 00:11:21,760
the multi-instance adversary when

286
00:11:21,760 --> 00:11:23,040
running on different solves are

287
00:11:23,040 --> 00:11:25,839
completely different

288
00:11:26,720 --> 00:11:29,519
the encoding procedure works as follows

289
00:11:29,519 --> 00:11:32,880
ah the adversary is first run on salt a1

290
00:11:32,880 --> 00:11:35,120
and the salt is included as part of the

291
00:11:35,120 --> 00:11:36,880
encoding

292
00:11:36,880 --> 00:11:38,720
ah when the adversary makes a query to

293
00:11:38,720 --> 00:11:40,880
the random oracle the answer to that

294
00:11:40,880 --> 00:11:45,360
query is added to a list in the input

295
00:11:45,360 --> 00:11:47,680
if the adversary makes a query

296
00:11:47,680 --> 00:11:50,560
that had not been made before

297
00:11:50,560 --> 00:11:53,040
but which has the same answer

298
00:11:53,040 --> 00:11:55,120
as some previous query

299
00:11:55,120 --> 00:11:58,399
then the answer to this query is removed

300
00:11:58,399 --> 00:11:59,680
from the

301
00:11:59,680 --> 00:12:02,000
list of answers in the encoding and

302
00:12:02,000 --> 00:12:04,720
instead the indices of the two queries

303
00:12:04,720 --> 00:12:07,279
with the same answer is added to a

304
00:12:07,279 --> 00:12:10,560
separate list of tuples in the encoding

305
00:12:10,560 --> 00:12:12,240
this is done only for the first time

306
00:12:12,240 --> 00:12:13,680
this happens when the adversary is

307
00:12:13,680 --> 00:12:16,880
running on the salt a1

308
00:12:16,880 --> 00:12:19,440
similarly the adversary is run on the

309
00:12:19,440 --> 00:12:20,399
other

310
00:12:20,399 --> 00:12:22,800
solves one by one and the encoding built

311
00:12:22,800 --> 00:12:24,800
up likewise

312
00:12:24,800 --> 00:12:27,920
after running on all the solves uh the

313
00:12:27,920 --> 00:12:30,240
points of the random oracle on which the

314
00:12:30,240 --> 00:12:32,959
adversary did not query it are appended

315
00:12:32,959 --> 00:12:35,600
to the list of uh the answers to random

316
00:12:35,600 --> 00:12:37,600
oracle queries in the lexicographical

317
00:12:37,600 --> 00:12:40,079
order of inputs

318
00:12:40,079 --> 00:12:41,120
ah

319
00:12:41,120 --> 00:12:43,279
that's that completes the encoding

320
00:12:43,279 --> 00:12:45,040
procedure procedure

321
00:12:45,040 --> 00:12:50,000
now let me show you how decoding works

322
00:12:50,320 --> 00:12:51,279
the

323
00:12:51,279 --> 00:12:53,839
adversary is first run on salt a1 which

324
00:12:53,839 --> 00:12:55,680
is present in encoding

325
00:12:55,680 --> 00:12:59,279
and its query is answered from the list

326
00:12:59,279 --> 00:13:02,399
of answers in the input

327
00:13:02,399 --> 00:13:03,760
when a

328
00:13:03,760 --> 00:13:05,360
query

329
00:13:05,360 --> 00:13:07,200
is made whose answer was removed from

330
00:13:07,200 --> 00:13:08,480
the list

331
00:13:08,480 --> 00:13:11,440
the said query is detected by checking

332
00:13:11,440 --> 00:13:12,720
if the query

333
00:13:12,720 --> 00:13:16,160
index appears as the second element of

334
00:13:16,160 --> 00:13:17,680
a tuple

335
00:13:17,680 --> 00:13:18,480
in the

336
00:13:18,480 --> 00:13:21,839
list of tuples in the encoding

337
00:13:21,920 --> 00:13:25,360
if so it is answered with the query

338
00:13:25,360 --> 00:13:27,120
answer of the

339
00:13:27,120 --> 00:13:30,000
query whose index appears as the first

340
00:13:30,000 --> 00:13:32,959
element of the topic

341
00:13:33,600 --> 00:13:37,120
similarly the adversary is run on all

342
00:13:37,120 --> 00:13:38,959
the other salts

343
00:13:38,959 --> 00:13:42,079
and finally the unqueried values of h

344
00:13:42,079 --> 00:13:45,279
are deduced from the remaining entries

345
00:13:45,279 --> 00:13:47,440
of the list of answers

346
00:13:47,440 --> 00:13:49,120
which are in the lexicographical order

347
00:13:49,120 --> 00:13:51,839
of inputs

348
00:13:52,079 --> 00:13:53,920
whenever the adversary wins a

349
00:13:53,920 --> 00:13:55,839
multi-instance game

350
00:13:55,839 --> 00:13:57,519
we are guaranteed to have a collision

351
00:13:57,519 --> 00:13:59,440
for every salt

352
00:13:59,440 --> 00:14:01,440
and since by our assumption the

353
00:14:01,440 --> 00:14:03,680
adversary makes a

354
00:14:03,680 --> 00:14:05,279
completely different queries for

355
00:14:05,279 --> 00:14:08,160
different solves it follows that we say

356
00:14:08,160 --> 00:14:11,120
u times log n minus 2 log t bits in

357
00:14:11,120 --> 00:14:13,040
total

358
00:14:13,040 --> 00:14:14,880
since for every salt instead of

359
00:14:14,880 --> 00:14:17,839
remembering a query answer we included a

360
00:14:17,839 --> 00:14:20,639
couple of query indices to the encoding

361
00:14:20,639 --> 00:14:24,079
uh which take log t bits each

362
00:14:24,079 --> 00:14:25,600
using the compression lemma this would

363
00:14:25,600 --> 00:14:27,040
give us that the advantage of the

364
00:14:27,040 --> 00:14:28,720
adversary against the multi-instance

365
00:14:28,720 --> 00:14:30,639
game is at most

366
00:14:30,639 --> 00:14:32,800
t square by n whole power u

367
00:14:32,800 --> 00:14:34,959
which is what we want

368
00:14:34,959 --> 00:14:37,680
but remember ah we made a false

369
00:14:37,680 --> 00:14:38,720
assumption

370
00:14:38,720 --> 00:14:40,880
ah so we have to work much harder to get

371
00:14:40,880 --> 00:14:43,199
rid of it

372
00:14:43,199 --> 00:14:45,839
to this end as a first step we introduce

373
00:14:45,839 --> 00:14:48,000
the notion of a query graph

374
00:14:48,000 --> 00:14:49,600
ah this is a graph that is initially

375
00:14:49,600 --> 00:14:51,760
empty uh when we

376
00:14:51,760 --> 00:14:53,440
start running the adversary on the salt

377
00:14:53,440 --> 00:14:58,399
a1 if it makes a query on ah

378
00:14:58,399 --> 00:15:00,320
random workout query on x one y one and

379
00:15:00,320 --> 00:15:01,920
the answer is z one

380
00:15:01,920 --> 00:15:04,639
we add two nodes for x one and z one and

381
00:15:04,639 --> 00:15:06,880
add our directed edge from x one to z

382
00:15:06,880 --> 00:15:10,079
one with label y one

383
00:15:10,079 --> 00:15:12,800
next when it makes a random oracle query

384
00:15:12,800 --> 00:15:16,079
on z1 y2 and the answer is z2 we add a

385
00:15:16,079 --> 00:15:18,880
node z2 and add a directed edge from z1

386
00:15:18,880 --> 00:15:23,279
to z2 with label y2 and so on

387
00:15:23,680 --> 00:15:26,079
the graph grows as we run the adversary

388
00:15:26,079 --> 00:15:28,320
on all the users

389
00:15:28,320 --> 00:15:30,720
in particular note that

390
00:15:30,720 --> 00:15:33,680
the adversary when running on a sort may

391
00:15:33,680 --> 00:15:36,160
make queries that it made earlier while

392
00:15:36,160 --> 00:15:38,399
running on a different sort contrary to

393
00:15:38,399 --> 00:15:41,759
our earlier assumption

394
00:15:41,759 --> 00:15:43,199
we can assume

395
00:15:43,199 --> 00:15:45,440
without loss of generality that whenever

396
00:15:45,440 --> 00:15:47,920
the adversary find the position

397
00:15:47,920 --> 00:15:50,720
it must have queried the random oracle

398
00:15:50,720 --> 00:15:52,639
at all points required to compute the

399
00:15:52,639 --> 00:15:55,279
position

400
00:15:55,279 --> 00:15:58,000
so let us first see how a b block

401
00:15:58,000 --> 00:16:02,160
collision looks like in a query graph

402
00:16:02,160 --> 00:16:04,399
a general b block collision is a sub

403
00:16:04,399 --> 00:16:06,160
graph of the query graph

404
00:16:06,160 --> 00:16:08,800
that looks something like this

405
00:16:08,800 --> 00:16:11,279
this reminded us of the shape of a mouse

406
00:16:11,279 --> 00:16:14,560
hence we named it the mouse structure

407
00:16:14,560 --> 00:16:16,560
and referred to the different parts of

408
00:16:16,560 --> 00:16:20,320
the subgraph using different body parts

409
00:16:20,320 --> 00:16:22,240
now that there can be slight variations

410
00:16:22,240 --> 00:16:24,800
to the structure ah the entire body of

411
00:16:24,800 --> 00:16:26,880
the mouse might be a cycle or even a

412
00:16:26,880 --> 00:16:28,000
self loop

413
00:16:28,000 --> 00:16:31,759
the tail might be missing etcetera

414
00:16:31,759 --> 00:16:33,839
for every salt that the multi instance

415
00:16:33,839 --> 00:16:36,560
adversary is run on even if it finds

416
00:16:36,560 --> 00:16:38,880
multiple b block collisions

417
00:16:38,880 --> 00:16:40,720
we arbitrarily choose one of the

418
00:16:40,720 --> 00:16:43,759
collisions and refer to its sub graph as

419
00:16:43,759 --> 00:16:45,519
the mouse structure for the particular

420
00:16:45,519 --> 00:16:47,839
song

421
00:16:48,560 --> 00:16:51,440
next we categorize the types of queries

422
00:16:51,440 --> 00:16:53,120
made when the adversary is run on

423
00:16:53,120 --> 00:16:54,959
different songs

424
00:16:54,959 --> 00:16:57,360
we say that a query is new if it is

425
00:16:57,360 --> 00:17:00,000
being made for the first time

426
00:17:00,000 --> 00:17:02,000
ah we will assume without loss of

427
00:17:02,000 --> 00:17:04,799
generality that when running on a

428
00:17:04,799 --> 00:17:07,760
particular spot the adversary does not

429
00:17:07,760 --> 00:17:09,839
repeat query since it can just store the

430
00:17:09,839 --> 00:17:11,199
answers

431
00:17:11,199 --> 00:17:13,039
so if a particular

432
00:17:13,039 --> 00:17:14,959
query had not been made when the

433
00:17:14,959 --> 00:17:17,679
adversary was run on a prior serve

434
00:17:17,679 --> 00:17:21,119
uh the query is new

435
00:17:21,119 --> 00:17:24,000
we'll mark the new queries with red

436
00:17:24,000 --> 00:17:26,559
queries that are not new are repeated

437
00:17:26,559 --> 00:17:29,039
queries uh we will categorize them into

438
00:17:29,039 --> 00:17:30,320
two types

439
00:17:30,320 --> 00:17:32,880
ah repeated my queries are those that

440
00:17:32,880 --> 00:17:34,559
are present in the mouse structure of

441
00:17:34,559 --> 00:17:35,360
some

442
00:17:35,360 --> 00:17:39,120
earlier sort uh we mark these in blue

443
00:17:39,120 --> 00:17:41,440
any repeated way

444
00:17:41,440 --> 00:17:44,160
any other repeated query is called a

445
00:17:44,160 --> 00:17:47,039
repeated non-mouse query and we

446
00:17:47,039 --> 00:17:49,760
mark these in green

447
00:17:49,760 --> 00:17:52,559
uh further uh we'll make an assumption

448
00:17:52,559 --> 00:17:53,919
here

449
00:17:53,919 --> 00:17:56,400
we assume that before running that

450
00:17:56,400 --> 00:17:58,720
bursary on assault

451
00:17:58,720 --> 00:18:01,440
no query with the particular salt as

452
00:18:01,440 --> 00:18:03,440
prefix has been made

453
00:18:03,440 --> 00:18:07,039
uh we will soon show the why making this

454
00:18:07,039 --> 00:18:09,120
assumption is justified

455
00:18:09,120 --> 00:18:10,240
uh

456
00:18:10,240 --> 00:18:13,280
note that this implies that every mouse

457
00:18:13,280 --> 00:18:16,480
structure is a new query

458
00:18:16,480 --> 00:18:18,640
based on these definitions we classify

459
00:18:18,640 --> 00:18:20,400
the mouse structures in two different

460
00:18:20,400 --> 00:18:21,760
categories

461
00:18:21,760 --> 00:18:23,520
these categories are not mutually

462
00:18:23,520 --> 00:18:25,919
exclusive but they are exhaustive

463
00:18:25,919 --> 00:18:28,240
a mouse structure gets classified into

464
00:18:28,240 --> 00:18:31,039
the earliest category that it calls it

465
00:18:31,039 --> 00:18:33,600
the first category is when there are

466
00:18:33,600 --> 00:18:35,200
colliding new queries in the mouse

467
00:18:35,200 --> 00:18:36,240
structure

468
00:18:36,240 --> 00:18:38,640
ah the queries in black may be of any

469
00:18:38,640 --> 00:18:40,720
type new repeated mouse or repeated

470
00:18:40,720 --> 00:18:44,559
normals the second category is of mouse

471
00:18:44,559 --> 00:18:47,120
structures whose body is a self-loop

472
00:18:47,120 --> 00:18:49,360
and third is of more structures that

473
00:18:49,360 --> 00:18:52,720
have a new query whose answer is the

474
00:18:52,720 --> 00:18:56,880
input sort of a repeated mouse grid

475
00:18:56,880 --> 00:18:59,120
the two other mouse structure categories

476
00:18:59,120 --> 00:19:01,600
are the ones that have at least one

477
00:19:01,600 --> 00:19:04,080
repeated mouse query and one

478
00:19:04,080 --> 00:19:06,000
that have no repeated mouse queries at

479
00:19:06,000 --> 00:19:08,160
all

480
00:19:08,640 --> 00:19:11,520
our goal will be to save at least the

481
00:19:11,520 --> 00:19:12,480
following

482
00:19:12,480 --> 00:19:14,720
amount of bits for each of these mouse

483
00:19:14,720 --> 00:19:16,400
structure categories

484
00:19:16,400 --> 00:19:21,520
uh we refer to this quantity as delta

485
00:19:22,880 --> 00:19:26,320
this leads us to a saving of at least u

486
00:19:26,320 --> 00:19:28,320
delta bits in total

487
00:19:28,320 --> 00:19:30,640
and this suffices since

488
00:19:30,640 --> 00:19:33,360
uh applying the compression lemma would

489
00:19:33,360 --> 00:19:37,199
give us the bound that we want

490
00:19:37,440 --> 00:19:39,039
uh

491
00:19:39,039 --> 00:19:41,600
before we describe how we save

492
00:19:41,600 --> 00:19:44,160
let me address the assumption that we

493
00:19:44,160 --> 00:19:48,160
made that is when running on a sort the

494
00:19:48,160 --> 00:19:50,880
adversary had not made any query prefix

495
00:19:50,880 --> 00:19:52,960
with that sort when running on the

496
00:19:52,960 --> 00:19:55,280
earlier songs

497
00:19:55,280 --> 00:19:57,840
this is reasonable since otherwise we

498
00:19:57,840 --> 00:20:01,600
can save enough on the salt itself

499
00:20:01,600 --> 00:20:05,280
we save at least delta bits as follows

500
00:20:05,280 --> 00:20:07,200
uh we omit this

501
00:20:07,200 --> 00:20:09,520
the sort from the encoding the saving

502
00:20:09,520 --> 00:20:11,200
login bits

503
00:20:11,200 --> 00:20:12,400
instead

504
00:20:12,400 --> 00:20:14,720
write down the index of the query where

505
00:20:14,720 --> 00:20:16,320
the salt appears

506
00:20:16,320 --> 00:20:18,720
as a as the part of the encoding

507
00:20:18,720 --> 00:20:20,960
since there are at most u times t

508
00:20:20,960 --> 00:20:25,039
queries uh this costs us at most uh log

509
00:20:25,039 --> 00:20:26,799
of ut bits

510
00:20:26,799 --> 00:20:30,960
uh and that suffices for our needs

511
00:20:30,960 --> 00:20:32,880
thus we can make this assumption as we

512
00:20:32,880 --> 00:20:35,039
showed that otherwise we already save

513
00:20:35,039 --> 00:20:37,360
enough

514
00:20:38,640 --> 00:20:40,640
we first show how to deal with some of

515
00:20:40,640 --> 00:20:42,240
the easier cases

516
00:20:42,240 --> 00:20:44,320
consider the case when the mouse

517
00:20:44,320 --> 00:20:47,520
structure has colliding nucleus

518
00:20:47,520 --> 00:20:51,039
suppose the new queries are q1 and q2

519
00:20:51,039 --> 00:20:53,840
with q2 made after q1

520
00:20:53,840 --> 00:20:57,360
here we save log n bits by omitting the

521
00:20:57,360 --> 00:21:00,320
answer of q2 from the encoding

522
00:21:00,320 --> 00:21:03,440
and instead remembering the indices of

523
00:21:03,440 --> 00:21:07,039
q1 and q2 among the key queries

524
00:21:07,039 --> 00:21:09,760
another easy to handle case is when the

525
00:21:09,760 --> 00:21:12,480
answer of a new query is the input sort

526
00:21:12,480 --> 00:21:14,799
of a repeated mouse query

527
00:21:14,799 --> 00:21:17,600
here we save by omitting the answer of

528
00:21:17,600 --> 00:21:19,600
the new query

529
00:21:19,600 --> 00:21:21,520
and

530
00:21:21,520 --> 00:21:24,159
putting the indices of the new and the

531
00:21:24,159 --> 00:21:27,520
repeated mouse queries in the encoding

532
00:21:27,520 --> 00:21:29,600
the index of the new query can be

533
00:21:29,600 --> 00:21:32,960
encoded in log t bits uh while the

534
00:21:32,960 --> 00:21:35,120
index of the repeated mouse query needs

535
00:21:35,120 --> 00:21:36,400
roughly log

536
00:21:36,400 --> 00:21:38,559
of u times v bits because there are

537
00:21:38,559 --> 00:21:40,080
roughly at most

538
00:21:40,080 --> 00:21:41,120
u times

539
00:21:41,120 --> 00:21:42,840
b

540
00:21:42,840 --> 00:21:45,840
repeated mouse queries in total

541
00:21:45,840 --> 00:21:48,000
and this gives a sufficient amount of

542
00:21:48,000 --> 00:21:50,240
sales

543
00:21:50,240 --> 00:21:52,720
we'll now see an example of a case that

544
00:21:52,720 --> 00:21:55,440
is much harder to do

545
00:21:55,440 --> 00:21:57,280
consider the case when the mouse

546
00:21:57,280 --> 00:22:00,720
structure has some repeated mouse query

547
00:22:00,720 --> 00:22:03,120
but none of the input source of repeated

548
00:22:03,120 --> 00:22:05,120
mouse queries is the answer to a new

549
00:22:05,120 --> 00:22:06,880
print

550
00:22:06,880 --> 00:22:09,840
in this case our strategy would be to

551
00:22:09,840 --> 00:22:12,320
omit the answer of the new query and

552
00:22:12,320 --> 00:22:14,720
instead remember the indices of the new

553
00:22:14,720 --> 00:22:16,799
and the repeated mouse queries and the

554
00:22:16,799 --> 00:22:19,360
path back from the input salt of the

555
00:22:19,360 --> 00:22:21,280
repeated mouse query to the answer of

556
00:22:21,280 --> 00:22:23,039
the nucleus

557
00:22:23,039 --> 00:22:24,159
note that

558
00:22:24,159 --> 00:22:26,400
one can find a new query and repeated

559
00:22:26,400 --> 00:22:29,679
mouse query such that this path consists

560
00:22:29,679 --> 00:22:32,559
entirely of repeated non-mouse queries

561
00:22:32,559 --> 00:22:36,159
which had been already been made before

562
00:22:36,159 --> 00:22:38,640
running on the current sort

563
00:22:38,640 --> 00:22:41,200
but how do we encode this path

564
00:22:41,200 --> 00:22:43,440
let us zoom in

565
00:22:43,440 --> 00:22:47,200
uh we can remember the edges back for

566
00:22:47,200 --> 00:22:49,039
every node in the path

567
00:22:49,039 --> 00:22:51,520
but there might be a large number of

568
00:22:51,520 --> 00:22:52,960
incident edges

569
00:22:52,960 --> 00:22:56,080
for every node in the path

570
00:22:56,080 --> 00:22:57,600
we say that

571
00:22:57,600 --> 00:23:00,080
the query graph has no large

572
00:23:00,080 --> 00:23:02,480
multicollision if there is no node in

573
00:23:02,480 --> 00:23:05,039
the query graph that has in degree

574
00:23:05,039 --> 00:23:07,760
exceeding log u

575
00:23:07,760 --> 00:23:10,559
in case the query graph has no large

576
00:23:10,559 --> 00:23:13,600
multiplication ah we can encode the path

577
00:23:13,600 --> 00:23:17,918
back using the following number of bits

578
00:23:18,720 --> 00:23:21,200
we encode the path length using log b

579
00:23:21,200 --> 00:23:23,039
bits and

580
00:23:23,039 --> 00:23:27,600
each edge requires log of log units

581
00:23:29,200 --> 00:23:31,679
this strategy which turns out

582
00:23:31,679 --> 00:23:34,320
to give us enough savings

583
00:23:34,320 --> 00:23:36,720
in case there are no large multiples

584
00:23:36,720 --> 00:23:38,400
but what if there are large

585
00:23:38,400 --> 00:23:40,159
multiplication

586
00:23:40,159 --> 00:23:43,520
in this case our key idea is to save

587
00:23:43,520 --> 00:23:47,600
from the large multi collisions itself

588
00:23:47,679 --> 00:23:51,200
uh so if a node in the query graph has

589
00:23:51,200 --> 00:23:54,320
in degree m ah we say that it is a m uh

590
00:23:54,320 --> 00:23:55,840
multicollision

591
00:23:55,840 --> 00:23:58,000
our strategy to say from a multi

592
00:23:58,000 --> 00:24:01,039
collision is to remember only the answer

593
00:24:01,039 --> 00:24:04,320
of the first of the m queries and encode

594
00:24:04,320 --> 00:24:06,559
the indices of the rest of the queries

595
00:24:06,559 --> 00:24:08,400
as a set

596
00:24:08,400 --> 00:24:09,279
uh

597
00:24:09,279 --> 00:24:12,080
we save these bits for omitting the

598
00:24:12,080 --> 00:24:14,559
answer of m minus 1 queries but incurred

599
00:24:14,559 --> 00:24:16,840
this loss to encode the set of

600
00:24:16,840 --> 00:24:20,000
indices now it turns out that when m is

601
00:24:20,000 --> 00:24:23,360
at least log u we save more than delta

602
00:24:23,360 --> 00:24:26,000
which suffices for us

603
00:24:26,000 --> 00:24:28,159
of course the full formal proof needs to

604
00:24:28,159 --> 00:24:31,039
handle several subtleties and i refer

605
00:24:31,039 --> 00:24:35,200
you to our paper for all the details

606
00:24:35,679 --> 00:24:37,440
ah in conclusion

607
00:24:37,440 --> 00:24:40,320
we proved the stb conjecture for all

608
00:24:40,320 --> 00:24:42,799
constant values of b and for some other

609
00:24:42,799 --> 00:24:45,039
parameter ranges by characterizing the

610
00:24:45,039 --> 00:24:47,039
structure of collisions in the merkel

611
00:24:47,039 --> 00:24:49,279
damgar construction

612
00:24:49,279 --> 00:24:52,559
uh in a follow-up work by akshima at all

613
00:24:52,559 --> 00:24:53,679
thus

614
00:24:53,679 --> 00:24:55,520
one of our results were improved that

615
00:24:55,520 --> 00:24:57,440
resulted in the proof of the stb

616
00:24:57,440 --> 00:25:01,360
conjecture when st square is at most n

617
00:25:01,360 --> 00:25:04,000
also in a different follow-up work by us

618
00:25:04,000 --> 00:25:05,840
along with cody freitag

619
00:25:05,840 --> 00:25:08,000
uh the similar question of

620
00:25:08,000 --> 00:25:11,600
characterizing hardness of short sponge

621
00:25:11,600 --> 00:25:15,039
collisions was studied

622
00:25:15,039 --> 00:25:17,360
the main open problem that stems from

623
00:25:17,360 --> 00:25:20,159
this work is proving the stb conjecture

624
00:25:20,159 --> 00:25:22,720
or coming up with better attacks for the

625
00:25:22,720 --> 00:25:26,000
regime s t squared greater than

626
00:25:26,000 --> 00:25:28,000
the full version of our paper is on

627
00:25:28,000 --> 00:25:29,279
imprint

628
00:25:29,279 --> 00:25:31,760
thank you

