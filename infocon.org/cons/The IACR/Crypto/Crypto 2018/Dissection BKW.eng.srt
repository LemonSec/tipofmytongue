1
00:00:05,000 --> 00:00:10,620
<font color="#CCCCCC">hello I'm Andre</font><font color="#E5E5E5"> and I will give it</font><font color="#CCCCCC"> to</font>

2
00:00:07,740 --> 00:00:13,219
<font color="#CCCCCC">our talk on section BK w which is a</font>

3
00:00:10,620 --> 00:00:15,629
joint<font color="#E5E5E5"> work with Felix Hoyer who is also</font>

4
00:00:13,219 --> 00:00:18,660
<font color="#E5E5E5">attending the audience today as well as</font>

5
00:00:15,629 --> 00:00:21,270
Robert<font color="#E5E5E5"> Kubla and Alexander my all from</font>

6
00:00:18,660 --> 00:00:24,930
<font color="#CCCCCC">will University boham and Christian Zola</font>

7
00:00:21,270 --> 00:00:27,119
<font color="#E5E5E5">from Technical University Dortmund so</font>

8
00:00:24,930 --> 00:00:29,189
let's start<font color="#E5E5E5"> with the definition of the</font>

9
00:00:27,120 --> 00:00:31,230
problem<font color="#CCCCCC"> we</font><font color="#E5E5E5"> will focus on today</font><font color="#CCCCCC"> we've</font>

10
00:00:29,190 --> 00:00:32,460
<font color="#E5E5E5">seen this problem also in the talk of</font>

11
00:00:31,230 --> 00:00:35,070
<font color="#E5E5E5">Shafi</font><font color="#CCCCCC"> Goldwasser</font>

12
00:00:32,460 --> 00:00:38,370
the learning<font color="#E5E5E5"> parity with noise problem</font>

13
00:00:35,070 --> 00:00:40,500
<font color="#E5E5E5">or for</font><font color="#CCCCCC"> short ltn problem and for</font><font color="#E5E5E5"> this</font>

14
00:00:38,370 --> 00:00:43,140
problem<font color="#CCCCCC"> we are given an arbitrary</font><font color="#E5E5E5"> amount</font>

15
00:00:40,500 --> 00:00:45,780
<font color="#E5E5E5">of samples where sample consists of</font>

16
00:00:43,140 --> 00:00:48,270
randomly sampled vector from<font color="#CCCCCC"> I have to</font>

17
00:00:45,780 --> 00:00:51,420
choose<font color="#CCCCCC"> ok here AI and together with the</font>

18
00:00:48,270 --> 00:00:53,070
label and this<font color="#E5E5E5"> label is a scalar product</font>

19
00:00:51,420 --> 00:00:55,680
<font color="#E5E5E5">of</font><font color="#CCCCCC"> these random</font><font color="#E5E5E5"> vectors with a secret</font>

20
00:00:53,070 --> 00:00:57,510
<font color="#E5E5E5">vector plus an error term</font><font color="#CCCCCC"> and this error</font>

21
00:00:55,680 --> 00:00:59,610
term can be<font color="#E5E5E5"> 0 or</font><font color="#CCCCCC"> 1</font><font color="#E5E5E5"> and it's</font><font color="#CCCCCC"> 1 with</font>

22
00:00:57,510 --> 00:01:02,489
probability<font color="#CCCCCC"> tau which is</font><font color="#E5E5E5"> strictly less</font>

23
00:00:59,610 --> 00:01:04,289
than<font color="#CCCCCC"> 1/2</font><font color="#E5E5E5"> and the goal</font><font color="#CCCCCC"> is now given an</font>

24
00:01:02,489 --> 00:01:07,380
<font color="#CCCCCC">arbitrary amount</font><font color="#E5E5E5"> of these samples</font><font color="#CCCCCC"> to</font>

25
00:01:04,290 --> 00:01:09,179
recover<font color="#E5E5E5"> the secret vector</font><font color="#CCCCCC"> s so why is</font>

26
00:01:07,380 --> 00:01:10,530
this problem important for us<font color="#CCCCCC"> scores to</font>

27
00:01:09,179 --> 00:01:12,479
come<font color="#CCCCCC"> and use totnes assumption is that</font>

28
00:01:10,530 --> 00:01:14,850
<font color="#CCCCCC">this problem is not solvable in</font>

29
00:01:12,479 --> 00:01:17,340
polynomial time for<font color="#CCCCCC"> narrow rates that</font><font color="#E5E5E5"> is</font>

30
00:01:14,850 --> 00:01:18,568
high enough and so it forms the basis

31
00:01:17,340 --> 00:01:20,700
<font color="#E5E5E5">sort of a lot of cryptographic</font>

32
00:01:18,569 --> 00:01:22,740
applications<font color="#CCCCCC"> so for example there are</font>

33
00:01:20,700 --> 00:01:24,929
<font color="#CCCCCC">six authentication schemes as well as</font>

34
00:01:22,740 --> 00:01:27,029
<font color="#E5E5E5">encryption schemes based on the hardness</font>

35
00:01:24,929 --> 00:01:29,490
of<font color="#E5E5E5"> sale TN problem and as soon as this</font>

36
00:01:27,029 --> 00:01:31,200
is<font color="#E5E5E5"> the case we need</font><font color="#CCCCCC"> to understand how</font>

37
00:01:29,490 --> 00:01:34,079
hard this<font color="#E5E5E5"> problem is actually solvable</font>

38
00:01:31,200 --> 00:01:35,939
<font color="#E5E5E5">of course to determine proper parameters</font>

39
00:01:34,079 --> 00:01:39,568
<font color="#E5E5E5">for the mentioned schemes to ensure</font>

40
00:01:35,939 --> 00:01:42,359
certain<font color="#E5E5E5"> security levels so</font><font color="#CCCCCC"> it's a</font>

41
00:01:39,569 --> 00:01:44,249
state-of-the-art<font color="#E5E5E5"> algorithm to solve LP n</font>

42
00:01:42,359 --> 00:01:47,579
problem is the one by<font color="#CCCCCC"> Bloom</font><font color="#E5E5E5"> : but a</font>

43
00:01:44,249 --> 00:01:49,169
month<font color="#E5E5E5"> from 2000 and this algorithm</font><font color="#CCCCCC"> s the</font>

44
00:01:47,579 --> 00:01:50,219
advantage of<font color="#E5E5E5"> a slightly</font><font color="#CCCCCC"> sub-exponential</font>

45
00:01:49,169 --> 00:01:52,079
<font color="#CCCCCC">runtime</font>

46
00:01:50,219 --> 00:01:54,538
while it has the<font color="#CCCCCC"> drawback of a memory</font>

47
00:01:52,079 --> 00:01:56,579
and sample complexity that is as high as

48
00:01:54,539 --> 00:01:58,649
time complexity so slightly

49
00:01:56,579 --> 00:02:00,389
<font color="#CCCCCC">sub-exponential</font><font color="#E5E5E5"> and this makes the</font>

50
00:01:58,649 --> 00:02:02,609
algorithm quite impractical

51
00:02:00,389 --> 00:02:05,848
I mean there have been some experiments

52
00:02:02,609 --> 00:02:07,679
done in 2016 and 2017<font color="#E5E5E5"> but all we</font>

53
00:02:05,849 --> 00:02:09,420
restricted to a very small dimension<font color="#CCCCCC"> do</font>

54
00:02:07,679 --> 00:02:12,420
choose<font color="#CCCCCC"> a huge memory requirement of</font><font color="#E5E5E5"> this</font>

55
00:02:09,419 --> 00:02:14,280
algorithm<font color="#CCCCCC"> and if we now want to</font><font color="#E5E5E5"> estimate</font>

56
00:02:12,420 --> 00:02:16,320
the concrete hardness of suggested

57
00:02:14,280 --> 00:02:17,580
parameters for this<font color="#CCCCCC"> problem we need to</font>

58
00:02:16,320 --> 00:02:20,340
rely on experimental<font color="#E5E5E5"> data</font>

59
00:02:17,580 --> 00:02:23,040
and as long<font color="#CCCCCC"> as these experiments are</font>

60
00:02:20,340 --> 00:02:25,950
restricted to<font color="#E5E5E5"> such a small dimension we</font>

61
00:02:23,040 --> 00:02:28,739
yeah<font color="#E5E5E5"> get some estimates that are quite</font>

62
00:02:25,950 --> 00:02:31,290
in<font color="#E5E5E5"> inaccurate and so we want to present</font>

63
00:02:28,740 --> 00:02:33,690
a<font color="#CCCCCC"> vkw variant here that is applicable</font>

64
00:02:31,290 --> 00:02:35,100
for<font color="#E5E5E5"> any given amount</font><font color="#CCCCCC"> of memory</font><font color="#E5E5E5"> so we</font>

65
00:02:33,690 --> 00:02:36,570
will achieve this by giving time memory

66
00:02:35,100 --> 00:02:39,000
<font color="#E5E5E5">trade-off first time I marry</font><font color="#CCCCCC"> trade-off</font>

67
00:02:36,570 --> 00:02:41,310
<font color="#CCCCCC">slow wkw</font><font color="#E5E5E5"> algorithm which of course will</font>

68
00:02:39,000 --> 00:02:42,900
reduce<font color="#CCCCCC"> the memory</font><font color="#E5E5E5"> complexity why we have</font>

69
00:02:41,310 --> 00:02:45,960
to suffer<font color="#CCCCCC"> a slight increase</font><font color="#E5E5E5"> in time</font>

70
00:02:42,900 --> 00:02:49,170
complexity<font color="#E5E5E5"> so first I will illustrate</font>

71
00:02:45,960 --> 00:02:51,390
the<font color="#E5E5E5"> be kW algorithm and or a slight</font>

72
00:02:49,170 --> 00:02:53,190
<font color="#CCCCCC">variant thereof and before I do so I</font>

73
00:02:51,390 --> 00:02:56,339
would<font color="#CCCCCC"> like</font><font color="#E5E5E5"> to emphasize its core idea</font>

74
00:02:53,190 --> 00:02:57,959
<font color="#E5E5E5">and this is if we're given two samples I</font>

75
00:02:56,340 --> 00:03:00,900
<font color="#CCCCCC">want and a</font><font color="#E5E5E5"> two with corresponding labels</font>

76
00:02:57,959 --> 00:03:03,120
we can simply add<font color="#E5E5E5"> these samples</font>

77
00:03:00,900 --> 00:03:05,130
component-wise<font color="#E5E5E5"> to obtain a new sample</font>

78
00:03:03,120 --> 00:03:07,800
<font color="#CCCCCC">just cause of</font><font color="#E5E5E5"> the linearity of the</font>

79
00:03:05,130 --> 00:03:10,019
scalar product and it's worth<font color="#CCCCCC"> mentioning</font>

80
00:03:07,800 --> 00:03:11,760
that the new error term a prime which<font color="#CCCCCC"> is</font>

81
00:03:10,020 --> 00:03:15,090
now the sum<font color="#CCCCCC"> of</font><font color="#E5E5E5"> both previous error terms</font>

82
00:03:11,760 --> 00:03:17,640
<font color="#E5E5E5">is one with the higher probabilities and</font>

83
00:03:15,090 --> 00:03:19,650
before but we don't care for<font color="#E5E5E5"> the moment</font>

84
00:03:17,640 --> 00:03:22,500
<font color="#E5E5E5">we just keep in</font><font color="#CCCCCC"> mind we</font><font color="#E5E5E5"> can add samples</font>

85
00:03:19,650 --> 00:03:24,900
to create new ones so the<font color="#CCCCCC"> algorithm then</font>

86
00:03:22,500 --> 00:03:28,950
<font color="#E5E5E5">starts with a list containing</font><font color="#CCCCCC"> these AIS</font>

87
00:03:24,900 --> 00:03:31,500
<font color="#CCCCCC">rows and starts searching for pairs that</font>

88
00:03:28,950 --> 00:03:35,369
have<font color="#CCCCCC"> a special form</font><font color="#E5E5E5"> namely the shell and</font>

89
00:03:31,500 --> 00:03:36,570
all the same pattern of<font color="#E5E5E5"> bits and</font><font color="#CCCCCC"> OS</font><font color="#E5E5E5"> we</font>

90
00:03:35,370 --> 00:03:38,370
will call it<font color="#E5E5E5"> a shell be equal on</font><font color="#CCCCCC"> a</font>

91
00:03:36,570 --> 00:03:41,370
stripe and the algorithm then<font color="#E5E5E5"> proceeds</font>

92
00:03:38,370 --> 00:03:44,070
by adding these samples together<font color="#E5E5E5"> to form</font>

93
00:03:41,370 --> 00:03:45,900
a new sample<font color="#E5E5E5"> that ends on zeros and then</font>

94
00:03:44,070 --> 00:03:48,030
the algorithm continues searching<font color="#E5E5E5"> more</font>

95
00:03:45,900 --> 00:03:50,250
pairs behaving the same<font color="#E5E5E5"> until it</font>

96
00:03:48,030 --> 00:03:52,530
generated<font color="#E5E5E5"> a list that is as large as</font><font color="#CCCCCC"> the</font>

97
00:03:50,250 --> 00:03:55,110
initial one and then<font color="#CCCCCC"> it can simply start</font>

98
00:03:52,530 --> 00:03:56,700
all over again doing the<font color="#E5E5E5"> same procedure</font>

99
00:03:55,110 --> 00:03:58,620
for<font color="#E5E5E5"> the next stripe and the next stripe</font>

100
00:03:56,700 --> 00:04:00,899
<font color="#E5E5E5">until just</font><font color="#CCCCCC"> one random bit is left went</font>

101
00:03:58,620 --> 00:04:02,370
with a good probability<font color="#CCCCCC"> this bit is</font><font color="#E5E5E5"> 1</font>

102
00:04:00,900 --> 00:04:04,950
and we have<font color="#E5E5E5"> a lot of</font><font color="#CCCCCC"> unit vectors and</font>

103
00:04:02,370 --> 00:04:07,110
<font color="#CCCCCC">what can we do with unit vectors ok if</font>

104
00:04:04,950 --> 00:04:09,030
we<font color="#E5E5E5"> have a unit vector</font><font color="#CCCCCC"> and we look at the</font>

105
00:04:07,110 --> 00:04:10,800
label<font color="#CCCCCC"> which is the scalar product of the</font>

106
00:04:09,030 --> 00:04:12,420
secret with the unit<font color="#E5E5E5"> vector which</font><font color="#CCCCCC"> is</font>

107
00:04:10,800 --> 00:04:14,790
obviously just<font color="#CCCCCC"> one</font><font color="#E5E5E5"> bit</font><font color="#CCCCCC"> of the</font><font color="#E5E5E5"> secrecy of</font>

108
00:04:12,420 --> 00:04:16,289
<font color="#E5E5E5">the first plus the error term</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> since</font>

109
00:04:14,790 --> 00:04:18,390
this error term is strictly less than

110
00:04:16,290 --> 00:04:20,190
<font color="#CCCCCC">one half even if we add samples together</font>

111
00:04:18,390 --> 00:04:22,200
<font color="#E5E5E5">and stay is strictly less than one half</font>

112
00:04:20,190 --> 00:04:24,810
<font color="#E5E5E5">if we have enough of this unit vectors</font>

113
00:04:22,200 --> 00:04:26,880
<font color="#E5E5E5">we</font><font color="#CCCCCC"> can do a majority vote for one secret</font>

114
00:04:24,810 --> 00:04:29,039
bit and if<font color="#E5E5E5"> you analyze</font><font color="#CCCCCC"> this algorithm</font>

115
00:04:26,880 --> 00:04:31,169
<font color="#E5E5E5">you</font><font color="#CCCCCC"> will conclude</font><font color="#E5E5E5"> that it indeed has</font><font color="#CCCCCC"> a</font>

116
00:04:29,039 --> 00:04:34,710
slightly<font color="#E5E5E5"> sub-exponential runtime</font>

117
00:04:31,169 --> 00:04:37,799
of<font color="#CCCCCC"> to or</font><font color="#E5E5E5"> to the cable</font><font color="#CCCCCC"> okay</font><font color="#E5E5E5"> so also</font>

118
00:04:34,710 --> 00:04:39,659
memory and<font color="#CCCCCC"> central complexity so how do</font>

119
00:04:37,800 --> 00:04:42,360
we construct<font color="#E5E5E5"> time and we</font><font color="#CCCCCC"> trade-offs from</font>

120
00:04:39,659 --> 00:04:44,550
here<font color="#E5E5E5"> for this we</font><font color="#CCCCCC"> need one main</font>

121
00:04:42,360 --> 00:04:46,560
observation<font color="#E5E5E5"> and this is following we do</font>

122
00:04:44,550 --> 00:04:48,960
<font color="#E5E5E5">not need to restrict the algorithm to</font>

123
00:04:46,560 --> 00:04:50,909
just form pairs of vectors to eliminate

124
00:04:48,960 --> 00:04:53,310
stripe<font color="#E5E5E5"> we could also launch the</font>

125
00:04:50,909 --> 00:04:55,949
algorithm to sum up three or<font color="#CCCCCC"> even more</font>

126
00:04:53,310 --> 00:04:59,039
<font color="#E5E5E5">let's say C vectors to eliminate such a</font>

127
00:04:55,949 --> 00:05:01,680
stripe and advantage should be that this

128
00:04:59,039 --> 00:05:04,469
number<font color="#E5E5E5"> of combinations of C elements</font>

129
00:05:01,680 --> 00:05:06,539
<font color="#E5E5E5">increases exponentially in C and so does</font>

130
00:05:04,469 --> 00:05:08,939
the number<font color="#CCCCCC"> of combinations</font><font color="#E5E5E5"> that adds up</font>

131
00:05:06,539 --> 00:05:10,909
<font color="#E5E5E5">to zero on such a stripe and so we are</font>

132
00:05:08,939 --> 00:05:12,960
able<font color="#CCCCCC"> to start with a smaller</font><font color="#E5E5E5"> input list</font>

133
00:05:10,909 --> 00:05:15,779
<font color="#E5E5E5">so in the following</font><font color="#CCCCCC"> I will give the</font>

134
00:05:12,960 --> 00:05:17,998
framework that does not restrict the

135
00:05:15,779 --> 00:05:21,539
algorithm to just forming pairs of

136
00:05:17,999 --> 00:05:24,479
vectors but allows to sum up<font color="#CCCCCC"> 3/3 or</font>

137
00:05:21,539 --> 00:05:27,479
<font color="#E5E5E5">immoral it's AC vectors to eliminate</font>

138
00:05:24,479 --> 00:05:30,089
such a stripe and for this reason we

139
00:05:27,479 --> 00:05:33,628
<font color="#CCCCCC">need to define</font><font color="#E5E5E5"> the season problem which</font>

140
00:05:30,089 --> 00:05:35,849
is known variant of<font color="#CCCCCC"> our variant of a</font>

141
00:05:33,629 --> 00:05:38,250
known well<font color="#CCCCCC"> known problem</font><font color="#E5E5E5"> in</font><font color="#CCCCCC"> computer</font>

142
00:05:35,849 --> 00:05:42,779
science<font color="#E5E5E5"> so it's not new</font><font color="#CCCCCC"> but we define it</font>

143
00:05:38,250 --> 00:05:44,669
slightly differently<font color="#CCCCCC"> so and this</font><font color="#E5E5E5"> is just</font>

144
00:05:42,779 --> 00:05:46,770
given a list of size n containing

145
00:05:44,669 --> 00:05:49,560
uniformly distributed<font color="#E5E5E5"> elements from F 2</font>

146
00:05:46,770 --> 00:05:52,169
to the B where<font color="#E5E5E5"> B is now the width of</font>

147
00:05:49,560 --> 00:05:54,569
such a stripe find n combinations of C

148
00:05:52,169 --> 00:05:57,599
elements that<font color="#CCCCCC"> each</font><font color="#E5E5E5"> up to 0 so finding a</font>

149
00:05:54,569 --> 00:05:59,669
<font color="#CCCCCC">number</font><font color="#E5E5E5"> of these C sums that adds up to 0</font>

150
00:05:57,599 --> 00:06:02,998
<font color="#E5E5E5">that is as large as the initial list</font><font color="#CCCCCC"> so</font>

151
00:05:59,669 --> 00:06:04,979
as seen for the original<font color="#CCCCCC"> beaker W or</font><font color="#E5E5E5"> the</font>

152
00:06:02,999 --> 00:06:06,389
<font color="#E5E5E5">slight variant we've seen solved the to</font>

153
00:06:04,979 --> 00:06:08,370
some problem by finding<font color="#E5E5E5"> an amount of</font>

154
00:06:06,389 --> 00:06:12,029
Toussaint's adding up to 0<font color="#E5E5E5"> that were as</font>

155
00:06:08,370 --> 00:06:13,860
large<font color="#E5E5E5"> as an initial list and yeah to</font>

156
00:06:12,029 --> 00:06:16,110
<font color="#E5E5E5">ensure a solution to our problem we</font>

157
00:06:13,860 --> 00:06:17,939
<font color="#E5E5E5">obviously need n to</font><font color="#CCCCCC"> be sufficiently</font>

158
00:06:16,110 --> 00:06:20,759
large<font color="#E5E5E5"> since otherwise they</font><font color="#CCCCCC"> don't exist</font>

159
00:06:17,939 --> 00:06:23,699
enough combinations<font color="#CCCCCC"> and since expected</font>

160
00:06:20,759 --> 00:06:26,909
number<font color="#CCCCCC"> of combinations adding up to 0 on</font>

161
00:06:23,699 --> 00:06:28,860
a stripe is and should<font color="#CCCCCC"> C over 2 to</font><font color="#E5E5E5"> the B</font>

162
00:06:26,909 --> 00:06:31,680
since there are n<font color="#CCCCCC"> choose C combinations</font>

163
00:06:28,860 --> 00:06:33,599
of<font color="#E5E5E5"> C elements and probability that</font><font color="#CCCCCC"> 1 sum</font>

164
00:06:31,680 --> 00:06:36,389
<font color="#CCCCCC">is</font><font color="#E5E5E5"> 0 on a stripe should be 2 to the</font>

165
00:06:33,599 --> 00:06:38,849
minus B and so we<font color="#E5E5E5"> need this to be at</font>

166
00:06:36,389 --> 00:06:41,370
<font color="#E5E5E5">least the initial list size to be to</font>

167
00:06:38,849 --> 00:06:43,110
make the problem solvable and solving

168
00:06:41,370 --> 00:06:44,159
this<font color="#CCCCCC"> for n gives the lower bound on n</font><font color="#E5E5E5"> of</font>

169
00:06:43,110 --> 00:06:46,499
2 to the

170
00:06:44,159 --> 00:06:48,119
B over C minus<font color="#CCCCCC"> one and since</font><font color="#E5E5E5"> we</font><font color="#CCCCCC"> wanted</font>

171
00:06:46,499 --> 00:06:50,580
<font color="#E5E5E5">to start with the smallest this size as</font>

172
00:06:48,119 --> 00:06:52,889
possible<font color="#CCCCCC"> we</font><font color="#E5E5E5"> use exactly this</font><font color="#CCCCCC"> value for N</font>

173
00:06:50,580 --> 00:06:58,198
and<font color="#CCCCCC"> here we nicely see the dependence of</font>

174
00:06:52,889 --> 00:07:01,709
n to be<font color="#CCCCCC"> n star on B and</font><font color="#E5E5E5"> C so if we start</font>

175
00:06:58,199 --> 00:07:04,019
<font color="#CCCCCC">with a</font><font color="#E5E5E5"> if you increase C we can indeed</font>

176
00:07:01,709 --> 00:07:06,809
start with a smaller list size<font color="#E5E5E5"> but if we</font>

177
00:07:04,019 --> 00:07:09,330
increase<font color="#E5E5E5"> the width of a stripe we have</font>

178
00:07:06,809 --> 00:07:11,309
to<font color="#E5E5E5"> increase our list size again so</font><font color="#CCCCCC"> keep</font>

179
00:07:09,330 --> 00:07:13,409
<font color="#CCCCCC">this in mind</font><font color="#E5E5E5"> and the main idea is now to</font>

180
00:07:11,309 --> 00:07:15,839
<font color="#E5E5E5">solve to see some problem repeatedly on</font>

181
00:07:13,409 --> 00:07:20,490
each stripe<font color="#E5E5E5"> and just instead of just</font>

182
00:07:15,839 --> 00:07:25,139
forming pairs of vectors so<font color="#E5E5E5"> okay we need</font>

183
00:07:20,490 --> 00:07:26,580
one<font color="#CCCCCC"> more observation</font><font color="#E5E5E5"> to before stating</font>

184
00:07:25,139 --> 00:07:28,409
the framework and<font color="#E5E5E5"> this is we have to</font>

185
00:07:26,580 --> 00:07:30,508
understand<font color="#E5E5E5"> where actually the time</font>

186
00:07:28,409 --> 00:07:31,919
memory trade-off comes from since<font color="#CCCCCC"> till</font>

187
00:07:30,509 --> 00:07:33,899
now it looks<font color="#CCCCCC"> like a memory reduction</font>

188
00:07:31,919 --> 00:07:37,229
technique for the<font color="#E5E5E5"> algorithm but</font><font color="#CCCCCC"> it</font>

189
00:07:33,899 --> 00:07:38,550
unfortunately<font color="#CCCCCC"> has a</font><font color="#E5E5E5"> drawback and this is</font>

190
00:07:37,229 --> 00:07:40,679
<font color="#CCCCCC">the</font><font color="#E5E5E5"> following to understand this we have</font>

191
00:07:38,550 --> 00:07:43,019
<font color="#E5E5E5">to go back to the original</font><font color="#CCCCCC"> BK w</font>

192
00:07:40,679 --> 00:07:44,578
algorithm which forms pairs effectors<font color="#E5E5E5"> to</font>

193
00:07:43,019 --> 00:07:46,709
<font color="#E5E5E5">eliminate a stripe and it does so in</font>

194
00:07:44,579 --> 00:07:48,629
each<font color="#E5E5E5"> iteration so in the end we have</font>

195
00:07:46,709 --> 00:07:51,899
constructed<font color="#E5E5E5"> a unit vector or a lot of</font>

196
00:07:48,629 --> 00:07:53,519
<font color="#E5E5E5">unit vectors that are the sum of</font><font color="#CCCCCC"> two</font><font color="#E5E5E5"> -</font>

197
00:07:51,899 --> 00:07:55,110
<font color="#E5E5E5">the number of</font><font color="#CCCCCC"> iteration samples since</font><font color="#E5E5E5"> in</font>

198
00:07:53,519 --> 00:07:56,879
each iteration<font color="#E5E5E5"> we take two vectors</font><font color="#CCCCCC"> from</font>

199
00:07:55,110 --> 00:07:59,219
<font color="#E5E5E5">one list to form an element of the next</font>

200
00:07:56,879 --> 00:08:02,309
one<font color="#E5E5E5"> and as I told you in the beginning</font>

201
00:07:59,219 --> 00:08:04,498
if we add samples together<font color="#E5E5E5"> we increase</font>

202
00:08:02,309 --> 00:08:07,829
the error term so the error term of<font color="#E5E5E5"> the</font>

203
00:08:04,499 --> 00:08:10,169
final<font color="#E5E5E5"> unit vectors is much higher than</font>

204
00:08:07,829 --> 00:08:12,899
<font color="#E5E5E5">the one of the initial samples what I</font>

205
00:08:10,169 --> 00:08:15,269
did<font color="#E5E5E5"> not</font><font color="#CCCCCC"> mention is that BK w algorithm</font>

206
00:08:12,899 --> 00:08:17,309
somehow operates on the limit of<font color="#E5E5E5"> fading</font>

207
00:08:15,269 --> 00:08:18,559
samples<font color="#E5E5E5"> so we cannot afford to add more</font>

208
00:08:17,309 --> 00:08:20,729
<font color="#E5E5E5">than</font><font color="#CCCCCC"> these</font><font color="#E5E5E5"> eight</font><font color="#CCCCCC"> samples together</font>

209
00:08:18,559 --> 00:08:22,469
<font color="#E5E5E5">otherwise we would lose a slightly</font>

210
00:08:20,729 --> 00:08:24,959
<font color="#E5E5E5">sub-exponential runtime of the algorithm</font>

211
00:08:22,469 --> 00:08:26,579
so if we now start<font color="#E5E5E5"> adding three vectors</font>

212
00:08:24,959 --> 00:08:28,169
for example<font color="#E5E5E5"> together we can start with</font>

213
00:08:26,579 --> 00:08:30,419
smaller<font color="#E5E5E5"> lists smaller lists of all</font>

214
00:08:28,169 --> 00:08:32,880
iterations but we have<font color="#E5E5E5"> added too many</font>

215
00:08:30,419 --> 00:08:35,818
samples<font color="#E5E5E5"> so we have to compensate somehow</font>

216
00:08:32,880 --> 00:08:38,219
and this<font color="#E5E5E5"> is done by increasing the width</font>

217
00:08:35,818 --> 00:08:41,309
of a stripe which then leads to<font color="#E5E5E5"> overall</font>

218
00:08:38,219 --> 00:08:44,039
<font color="#E5E5E5">less iterations and for proper spreading</font>

219
00:08:41,309 --> 00:08:45,899
of the stripe we will end up with<font color="#E5E5E5"> some</font>

220
00:08:44,039 --> 00:08:48,360
<font color="#E5E5E5">of a samples again to construct the unit</font>

221
00:08:45,899 --> 00:08:51,329
vectors<font color="#CCCCCC"> as in the case when we'll when</font>

222
00:08:48,360 --> 00:08:52,860
just building<font color="#CCCCCC"> two sounds so but as we've</font>

223
00:08:51,329 --> 00:08:55,050
<font color="#E5E5E5">seen before if we increase the width of</font>

224
00:08:52,860 --> 00:08:57,550
<font color="#E5E5E5">stripe</font><font color="#CCCCCC"> we have to increase</font><font color="#E5E5E5"> our list size</font>

225
00:08:55,050 --> 00:09:01,990
<font color="#E5E5E5">again and this</font><font color="#CCCCCC"> is exactly what we will</font>

226
00:08:57,550 --> 00:09:03,609
in time complexity<font color="#E5E5E5"> so now we are ready</font>

227
00:09:01,990 --> 00:09:05,559
<font color="#E5E5E5">to state the framework</font><font color="#CCCCCC"> okay it should be</font>

228
00:09:03,610 --> 00:09:07,089
<font color="#E5E5E5">relatively clear how this works but we</font>

229
00:09:05,559 --> 00:09:08,769
have to make an<font color="#CCCCCC"> observation here</font><font color="#E5E5E5"> so we</font>

230
00:09:07,089 --> 00:09:10,420
start with<font color="#E5E5E5"> a list of size N and</font><font color="#CCCCCC"> then we</font>

231
00:09:08,769 --> 00:09:13,059
repeatedly<font color="#CCCCCC"> cells to see some problem</font>

232
00:09:10,420 --> 00:09:15,729
until<font color="#CCCCCC"> we generated unit vectors and then</font>

233
00:09:13,059 --> 00:09:18,100
we can do a<font color="#CCCCCC"> majority vote for one bit of</font>

234
00:09:15,730 --> 00:09:22,360
<font color="#E5E5E5">secret</font><font color="#CCCCCC"> since the observation here is</font>

235
00:09:18,100 --> 00:09:24,790
<font color="#E5E5E5">that time and memory complexity of our</font>

236
00:09:22,360 --> 00:09:27,579
first<font color="#E5E5E5"> memory complexity just</font><font color="#CCCCCC"> is</font>

237
00:09:24,790 --> 00:09:28,899
dependent<font color="#E5E5E5"> on the initial list size which</font>

238
00:09:27,579 --> 00:09:31,959
we've seen<font color="#E5E5E5"> is just depending on the</font>

239
00:09:28,899 --> 00:09:33,999
<font color="#E5E5E5">chosen C some instance and the time</font>

240
00:09:31,959 --> 00:09:35,979
complexity of this algorithm<font color="#CCCCCC"> of this ad</font>

241
00:09:33,999 --> 00:09:37,839
<font color="#CCCCCC">words</font><font color="#E5E5E5"> make framework is just dependent</font>

242
00:09:35,980 --> 00:09:39,550
on<font color="#CCCCCC"> the algorithm</font><font color="#E5E5E5"> used to solve</font><font color="#CCCCCC"> the</font>

243
00:09:37,839 --> 00:09:42,100
<font color="#CCCCCC">system</font><font color="#E5E5E5"> problem as long as we do not</font>

244
00:09:39,550 --> 00:09:44,618
<font color="#E5E5E5">iterate over too many stripes but we</font>

245
00:09:42,100 --> 00:09:46,749
won't so we can conclude<font color="#E5E5E5"> that's a time</font>

246
00:09:44,619 --> 00:09:49,269
and memory complexity<font color="#CCCCCC"> of our algorithmic</font>

247
00:09:46,749 --> 00:09:51,399
framework<font color="#E5E5E5"> are equal to the time at</font>

248
00:09:49,269 --> 00:09:56,139
memory complexity of the algorithm used

249
00:09:51,399 --> 00:09:58,869
to solve<font color="#E5E5E5"> see some problem so knowing is</font>

250
00:09:56,139 --> 00:10:00,999
this now we<font color="#CCCCCC"> can concentrate on</font><font color="#E5E5E5"> algorithm</font>

251
00:09:58,869 --> 00:10:04,149
solving<font color="#E5E5E5"> to see some problem we will do</font>

252
00:10:00,999 --> 00:10:06,639
so and then plugging them in into our

253
00:10:04,149 --> 00:10:10,389
framework<font color="#E5E5E5"> and forming time memory</font>

254
00:10:06,639 --> 00:10:13,149
trade-offs<font color="#E5E5E5"> so let's start with a very</font>

255
00:10:10,389 --> 00:10:14,499
simple<font color="#E5E5E5"> naive algorithm solving</font><font color="#CCCCCC"> you'll</font>

256
00:10:13,149 --> 00:10:18,579
see some problem leading<font color="#E5E5E5"> to our first</font>

257
00:10:14,499 --> 00:10:20,230
time memory trade-off<font color="#E5E5E5"> so it's a nearly</font>

258
00:10:18,579 --> 00:10:21,910
<font color="#E5E5E5">brute-force approach we call it see some</font>

259
00:10:20,230 --> 00:10:23,920
<font color="#E5E5E5">naive algorithm and it does the</font>

260
00:10:21,910 --> 00:10:27,189
following<font color="#E5E5E5"> it just computes all C minus 1</font>

261
00:10:23,920 --> 00:10:29,920
sums of the list<font color="#E5E5E5"> search the sum in the</font>

262
00:10:27,189 --> 00:10:33,069
list and if<font color="#E5E5E5"> it exists it can store the</font>

263
00:10:29,920 --> 00:10:35,199
corresponding see some and this

264
00:10:33,069 --> 00:10:37,929
algorithm<font color="#CCCCCC"> is</font><font color="#E5E5E5"> obviously</font><font color="#CCCCCC"> in time</font>

265
00:10:35,199 --> 00:10:39,969
complexity upper bounded by<font color="#CCCCCC"> N to</font><font color="#E5E5E5"> the C</font>

266
00:10:37,929 --> 00:10:42,699
minus 1<font color="#CCCCCC"> since</font><font color="#E5E5E5"> it has to compute all C</font>

267
00:10:39,970 --> 00:10:44,920
minus 1 sums and the memory complexity

268
00:10:42,699 --> 00:10:46,859
is n for a<font color="#E5E5E5"> properly choosing</font><font color="#CCCCCC"> this size</font>

269
00:10:44,920 --> 00:10:50,559
and<font color="#E5E5E5"> as we've seen before</font>

270
00:10:46,860 --> 00:10:52,299
so using<font color="#E5E5E5"> this algorithm now inside of</font>

271
00:10:50,559 --> 00:10:54,519
<font color="#CCCCCC">our algorithmic framework to</font><font color="#E5E5E5"> solve to</font>

272
00:10:52,299 --> 00:10:57,279
see some problem<font color="#E5E5E5"> we get an algorithm</font>

273
00:10:54,519 --> 00:10:59,439
solving the<font color="#CCCCCC"> LP n problem and these are</font>

274
00:10:57,279 --> 00:11:01,420
the time<font color="#CCCCCC"> in memory complexities of this</font>

275
00:10:59,439 --> 00:11:04,748
algorithm<font color="#CCCCCC"> so</font><font color="#E5E5E5"> the exponent of the time</font>

276
00:11:01,420 --> 00:11:08,248
and memory complexity<font color="#E5E5E5"> and we see that in</font>

277
00:11:04,749 --> 00:11:10,970
comparison<font color="#CCCCCC"> to</font><font color="#E5E5E5"> the original BK</font><font color="#CCCCCC"> w we</font>

278
00:11:08,249 --> 00:11:13,760
achieve this<font color="#E5E5E5"> lock</font><font color="#CCCCCC"> C factor in the expo</font>

279
00:11:10,970 --> 00:11:16,550
so it's increasing<font color="#E5E5E5"> logarithmic and</font><font color="#CCCCCC"> C and</font>

280
00:11:13,760 --> 00:11:18,620
the memory exponent is decreasing nearly

281
00:11:16,550 --> 00:11:21,859
linearly in C that's quite nice behavior

282
00:11:18,620 --> 00:11:24,290
<font color="#E5E5E5">and if we illustrate this in a graphic</font>

283
00:11:21,860 --> 00:11:26,390
where we plot time of a memory<font color="#E5E5E5"> we see</font>

284
00:11:24,290 --> 00:11:29,870
that the coordinate<font color="#E5E5E5"> 1</font><font color="#CCCCCC"> 1 corresponds to</font>

285
00:11:26,390 --> 00:11:34,520
the original<font color="#CCCCCC"> PKW run</font><font color="#E5E5E5"> times and memory</font>

286
00:11:29,870 --> 00:11:37,130
complexity of<font color="#E5E5E5"> cable</font><font color="#CCCCCC"> ok and if we now</font>

287
00:11:34,520 --> 00:11:38,840
plug<font color="#CCCCCC"> in or you can also achieve this</font>

288
00:11:37,130 --> 00:11:42,710
complexity<font color="#E5E5E5"> by I have plugging in C</font>

289
00:11:38,840 --> 00:11:45,950
equals 2<font color="#E5E5E5"> in our equations and if we now</font>

290
00:11:42,710 --> 00:11:47,330
plug in<font color="#E5E5E5"> high Aurelio's for C let's say C</font>

291
00:11:45,950 --> 00:11:49,400
equals 3<font color="#E5E5E5"> we get a point to the</font>

292
00:11:47,330 --> 00:11:51,860
<font color="#CCCCCC">upper-left</font><font color="#E5E5E5"> as expected from a time</font>

293
00:11:49,400 --> 00:11:53,990
memory trade-off reducing the memory

294
00:11:51,860 --> 00:11:56,660
complexity exponent what increasing the

295
00:11:53,990 --> 00:12:00,260
time complexity so for<font color="#CCCCCC"> even higher</font>

296
00:11:56,660 --> 00:12:03,800
instantiation of C we<font color="#E5E5E5"> will achieve</font><font color="#CCCCCC"> these</font>

297
00:12:00,260 --> 00:12:06,010
instantiations of<font color="#CCCCCC"> our framework</font><font color="#E5E5E5"> so in</font>

298
00:12:03,800 --> 00:12:09,170
the<font color="#E5E5E5"> following we want to concentrate on</font>

299
00:12:06,010 --> 00:12:11,689
<font color="#E5E5E5">more sophisticated</font><font color="#CCCCCC"> algorithm solving see</font>

300
00:12:09,170 --> 00:12:14,360
some problem and for this reason<font color="#E5E5E5"> I'm</font>

301
00:12:11,690 --> 00:12:17,120
going<font color="#E5E5E5"> to explain the idea</font><font color="#CCCCCC"> of shuttle</font>

302
00:12:14,360 --> 00:12:20,000
engineer<font color="#E5E5E5"> or to be more specific</font><font color="#CCCCCC"> what we</font>

303
00:12:17,120 --> 00:12:22,550
will see is a heuristic version of our

304
00:12:20,000 --> 00:12:25,160
graph crammed into this algorithm is

305
00:12:22,550 --> 00:12:27,199
<font color="#E5E5E5">especially designed to solve the</font><font color="#CCCCCC"> folsom</font>

306
00:12:25,160 --> 00:12:31,370
problem<font color="#E5E5E5"> and so it will just offer one</font>

307
00:12:27,200 --> 00:12:33,830
instantiation of our framework<font color="#E5E5E5"> but there</font>

308
00:12:31,370 --> 00:12:36,560
is a more general class<font color="#E5E5E5"> of algorithms</font>

309
00:12:33,830 --> 00:12:38,060
forming an abstraction of<font color="#E5E5E5"> the</font><font color="#CCCCCC"> sharp edge</font>

310
00:12:36,560 --> 00:12:40,339
<font color="#CCCCCC">a mere technique which is called</font>

311
00:12:38,060 --> 00:12:43,040
bisection and this will offer more

312
00:12:40,340 --> 00:12:45,080
instantiation for a framework<font color="#E5E5E5"> but for</font>

313
00:12:43,040 --> 00:12:46,459
brief understanding<font color="#CCCCCC"> I will just</font>

314
00:12:45,080 --> 00:12:50,390
<font color="#CCCCCC">concentrate on the</font><font color="#E5E5E5"> Scottish</font><font color="#CCCCCC"> a metric</font>

315
00:12:46,460 --> 00:12:52,310
technique so the first observation we

316
00:12:50,390 --> 00:12:54,589
need is<font color="#E5E5E5"> that if we are searching for for</font>

317
00:12:52,310 --> 00:12:56,839
sums in one big list<font color="#CCCCCC"> we can simply split</font>

318
00:12:54,589 --> 00:12:57,350
the<font color="#E5E5E5"> lists and as a list in four equal</font>

319
00:12:56,839 --> 00:12:59,270
parts

320
00:12:57,350 --> 00:13:01,310
<font color="#E5E5E5">treat it as four</font><font color="#CCCCCC"> different lists and</font>

321
00:12:59,270 --> 00:13:03,350
start<font color="#E5E5E5"> searching for for sums just</font>

322
00:13:01,310 --> 00:13:05,739
between these lists so one element from

323
00:13:03,350 --> 00:13:08,270
<font color="#E5E5E5">each list and what we will lose is a</font>

324
00:13:05,740 --> 00:13:10,400
<font color="#E5E5E5">polynomial factor of four sums not</font>

325
00:13:08,270 --> 00:13:12,560
affecting<font color="#CCCCCC"> the asymptotics so we can just</font>

326
00:13:10,400 --> 00:13:15,620
treat<font color="#E5E5E5"> the problem like this and what the</font>

327
00:13:12,560 --> 00:13:17,989
algorithms and acids<font color="#E5E5E5"> is it combines two</font>

328
00:13:15,620 --> 00:13:20,390
lists at a time<font color="#E5E5E5"> and it does so by</font>

329
00:13:17,990 --> 00:13:23,220
matching the lists on a specific<font color="#CCCCCC"> pattern</font>

330
00:13:20,390 --> 00:13:26,819
on the last bits your<font color="#CCCCCC"> zero zero</font>

331
00:13:23,220 --> 00:13:29,040
and also it searches<font color="#CCCCCC"> pairs</font><font color="#E5E5E5"> one from each</font>

332
00:13:26,820 --> 00:13:31,140
<font color="#E5E5E5">list it adds up to zero zero on the last</font>

333
00:13:29,040 --> 00:13:35,640
bits and the same is done<font color="#E5E5E5"> for the right</font>

334
00:13:31,140 --> 00:13:37,530
<font color="#E5E5E5">two lists and then the middle lists are</font>

335
00:13:35,640 --> 00:13:39,990
combined in the<font color="#CCCCCC"> same fashion so that</font>

336
00:13:37,530 --> 00:13:42,360
they add up<font color="#CCCCCC"> to</font><font color="#E5E5E5"> zero on all coordinates</font>

337
00:13:39,990 --> 00:13:45,660
<font color="#CCCCCC">so</font><font color="#E5E5E5"> we've generated our first four sums</font>

338
00:13:42,360 --> 00:13:48,510
here<font color="#CCCCCC"> and</font><font color="#E5E5E5"> obviously the last list is not</font>

339
00:13:45,660 --> 00:13:51,719
<font color="#E5E5E5">as large as</font><font color="#CCCCCC"> the initial one</font><font color="#E5E5E5"> so we have</font>

340
00:13:48,510 --> 00:13:53,730
to<font color="#E5E5E5"> compute more force on somehow and the</font>

341
00:13:51,720 --> 00:13:55,650
algorithm does so by starting<font color="#CCCCCC"> all over</font>

342
00:13:53,730 --> 00:13:57,750
again<font color="#E5E5E5"> and matching the base lists to a</font>

343
00:13:55,650 --> 00:14:00,319
different pattern<font color="#E5E5E5"> on the last bits so</font>

344
00:13:57,750 --> 00:14:05,280
same pattern is used for both lists and

345
00:14:00,320 --> 00:14:08,310
this<font color="#CCCCCC"> yes</font><font color="#E5E5E5"> and lists are again combined to</font>

346
00:14:05,280 --> 00:14:10,709
form solution on all bits<font color="#E5E5E5"> but note</font><font color="#CCCCCC"> that</font>

347
00:14:08,310 --> 00:14:12,180
by construction<font color="#CCCCCC"> if we take</font><font color="#E5E5E5"> a vector from</font>

348
00:14:10,710 --> 00:14:14,250
<font color="#E5E5E5">the left and from the right middle list</font>

349
00:14:12,180 --> 00:14:16,829
<font color="#CCCCCC">they add up</font><font color="#E5E5E5"> to</font><font color="#CCCCCC"> zero on the last bits</font><font color="#E5E5E5"> so</font>

350
00:14:14,250 --> 00:14:19,200
the constraint for the last level<font color="#CCCCCC"> just</font>

351
00:14:16,830 --> 00:14:22,170
holds on the first not matched yet bits

352
00:14:19,200 --> 00:14:24,980
and we generate and an expectation the

353
00:14:22,170 --> 00:14:27,360
same amount of solution vectors<font color="#E5E5E5"> so in</font>

354
00:14:24,980 --> 00:14:30,960
particular it does not matter on which

355
00:14:27,360 --> 00:14:32,700
pattern we match on<font color="#CCCCCC"> some middle</font><font color="#E5E5E5"> level we</font>

356
00:14:30,960 --> 00:14:35,910
can just repeat this for<font color="#CCCCCC"> all different</font>

357
00:14:32,700 --> 00:14:36,930
<font color="#CCCCCC">patterns to do an exhaustive search for</font>

358
00:14:35,910 --> 00:14:40,770
all four<font color="#E5E5E5"> sounds</font>

359
00:14:36,930 --> 00:14:43,140
<font color="#E5E5E5">I mean matching to</font><font color="#CCCCCC"> 0 and 4 properly</font>

360
00:14:40,770 --> 00:14:45,720
<font color="#CCCCCC">choosing this</font><font color="#E5E5E5"> size initial lists and the</font>

361
00:14:43,140 --> 00:14:48,390
output<font color="#E5E5E5"> list size will be equal after</font>

362
00:14:45,720 --> 00:14:50,700
doing the exhaustive search<font color="#E5E5E5"> so this</font>

363
00:14:48,390 --> 00:14:53,100
algorithm<font color="#E5E5E5"> has a time complexity</font><font color="#CCCCCC"> of N</font>

364
00:14:50,700 --> 00:14:54,990
squared<font color="#CCCCCC"> in comparison to the naive</font>

365
00:14:53,100 --> 00:14:59,160
<font color="#CCCCCC">approach which had a complexity of n</font>

366
00:14:54,990 --> 00:15:01,110
cube and there is more general<font color="#E5E5E5"> class of</font>

367
00:14:59,160 --> 00:15:03,180
algorithms I mentioned which<font color="#E5E5E5"> is called</font>

368
00:15:01,110 --> 00:15:06,570
<font color="#CCCCCC">dissection and the algorithms</font><font color="#E5E5E5"> of this</font>

369
00:15:03,180 --> 00:15:11,310
class have in general<font color="#CCCCCC"> runtime of n to</font>

370
00:15:06,570 --> 00:15:13,080
the C minus square root<font color="#E5E5E5"> of C and yeah in</font>

371
00:15:11,310 --> 00:15:16,260
comparison to the naive<font color="#CCCCCC"> approach which</font>

372
00:15:13,080 --> 00:15:18,000
had<font color="#CCCCCC"> runtime of</font><font color="#E5E5E5"> n to the C minus 1 so an</font>

373
00:15:16,260 --> 00:15:19,650
overall improvement and it should

374
00:15:18,000 --> 00:15:22,140
therefore<font color="#E5E5E5"> lead to a better time memory</font>

375
00:15:19,650 --> 00:15:24,780
trade-off and indeed<font color="#E5E5E5"> it does so if we</font>

376
00:15:22,140 --> 00:15:26,460
now use the dissection algorithms of the

377
00:15:24,780 --> 00:15:28,290
members of the dissection class to

378
00:15:26,460 --> 00:15:30,300
instantiate<font color="#E5E5E5"> our framework so the</font>

379
00:15:28,290 --> 00:15:32,099
<font color="#E5E5E5">subroutine for solving the season</font>

380
00:15:30,300 --> 00:15:34,979
problem is now dissection or the

381
00:15:32,100 --> 00:15:37,020
dissection<font color="#E5E5E5"> algorithms we achieve this</font>

382
00:15:34,980 --> 00:15:39,000
time and memory complexities

383
00:15:37,020 --> 00:15:41,370
where we have the benefit of this<font color="#E5E5E5"> one</font>

384
00:15:39,000 --> 00:15:43,920
minus<font color="#CCCCCC"> two over</font><font color="#E5E5E5"> square root of</font><font color="#CCCCCC"> C factor</font>

385
00:15:41,370 --> 00:15:46,740
<font color="#CCCCCC">in</font><font color="#E5E5E5"> the exponent which</font><font color="#CCCCCC"> is obviously less</font>

386
00:15:43,920 --> 00:15:47,250
<font color="#CCCCCC">than 1 and therefore improves the</font>

387
00:15:46,740 --> 00:15:50,790
<font color="#CCCCCC">trade-off</font>

388
00:15:47,250 --> 00:15:54,660
so again illustrating this in the

389
00:15:50,790 --> 00:15:58,250
graphic where we see time of a memory<font color="#CCCCCC"> if</font>

390
00:15:54,660 --> 00:16:00,900
we now use<font color="#E5E5E5"> shrubby shamea algorithm to</font>

391
00:15:58,250 --> 00:16:04,140
instantiate<font color="#E5E5E5"> our framework we achieve</font>

392
00:16:00,900 --> 00:16:08,850
this in sensation<font color="#CCCCCC"> market lying at</font><font color="#E5E5E5"> 2/3</font>

393
00:16:04,140 --> 00:16:12,000
<font color="#E5E5E5">4/3 instead of 2/3</font><font color="#CCCCCC"> - meaning we decrease</font>

394
00:16:08,850 --> 00:16:14,670
<font color="#CCCCCC">the time exponent</font><font color="#E5E5E5"> from 2 to 4/3 which is</font>

395
00:16:12,000 --> 00:16:16,740
quite nice improvement and using the

396
00:16:14,670 --> 00:16:18,329
other members of the dissection class we

397
00:16:16,740 --> 00:16:20,220
achieve this instantiation

398
00:16:18,330 --> 00:16:22,370
lying<font color="#CCCCCC"> Albanese the previous trade-off</font>

399
00:16:20,220 --> 00:16:27,300
<font color="#E5E5E5">and therefore forming a better trade-off</font>

400
00:16:22,370 --> 00:16:31,740
so here are<font color="#E5E5E5"> some lines illustrating the</font>

401
00:16:27,300 --> 00:16:34,319
behavior of the trade-offs<font color="#E5E5E5"> but I want to</font>

402
00:16:31,740 --> 00:16:38,100
mention<font color="#E5E5E5"> that if we are memory why is</font>

403
00:16:34,320 --> 00:16:39,900
somewhere in this<font color="#CCCCCC"> region so lying so we</font>

404
00:16:38,100 --> 00:16:41,970
have more memory available than we need

405
00:16:39,900 --> 00:16:45,150
for<font color="#CCCCCC"> building</font><font color="#E5E5E5"> for sums but less memory</font>

406
00:16:41,970 --> 00:16:47,790
than we need for<font color="#CCCCCC"> building</font><font color="#E5E5E5"> two sums we</font>

407
00:16:45,150 --> 00:16:50,640
have no instantiation besides<font color="#E5E5E5"> the</font><font color="#CCCCCC"> shop</font>

408
00:16:47,790 --> 00:16:52,829
<font color="#CCCCCC">shamea variant of the vkw</font><font color="#E5E5E5"> so the</font><font color="#CCCCCC"> Green</font>

409
00:16:50,640 --> 00:16:55,830
instantiation mark at the end<font color="#CCCCCC"> of the red</font>

410
00:16:52,830 --> 00:16:57,690
line so we would like to<font color="#E5E5E5"> have an</font>

411
00:16:55,830 --> 00:16:59,400
<font color="#CCCCCC">algorithm that</font><font color="#E5E5E5"> is able to leverage the</font>

412
00:16:57,690 --> 00:17:02,010
<font color="#E5E5E5">fact</font><font color="#CCCCCC"> of an increased</font><font color="#E5E5E5"> memory by</font>

413
00:16:59,400 --> 00:17:05,280
decreasing the<font color="#E5E5E5"> time exponent again</font><font color="#CCCCCC"> and</font>

414
00:17:02,010 --> 00:17:07,440
to overcome<font color="#E5E5E5"> this issue we give a slight</font>

415
00:17:05,280 --> 00:17:09,720
generalization of the dissection

416
00:17:07,440 --> 00:17:12,420
technique which we call<font color="#E5E5E5"> Taylor</font>

417
00:17:09,720 --> 00:17:17,819
dissection since it's tailored to any

418
00:17:12,420 --> 00:17:19,290
<font color="#E5E5E5">given amount of memory and yeah this</font>

419
00:17:17,819 --> 00:17:23,310
technique was independently discovered

420
00:17:19,290 --> 00:17:24,480
by each idea at the same time and yeah

421
00:17:23,310 --> 00:17:26,970
it works as follows

422
00:17:24,480 --> 00:17:28,680
<font color="#CCCCCC">so it's applicable to</font><font color="#E5E5E5"> any algorithm of</font>

423
00:17:26,970 --> 00:17:30,090
the<font color="#E5E5E5"> dissection class but again I</font>

424
00:17:28,680 --> 00:17:32,130
concentrate<font color="#CCCCCC"> on the</font><font color="#E5E5E5"> trouble</font><font color="#CCCCCC"> me a</font>

425
00:17:30,090 --> 00:17:33,540
technique<font color="#E5E5E5"> so what can we do if we have</font>

426
00:17:32,130 --> 00:17:35,490
more memory<font color="#CCCCCC"> available than we need for</font>

427
00:17:33,540 --> 00:17:37,620
<font color="#CCCCCC">building for</font><font color="#E5E5E5"> sums but less than we need</font>

428
00:17:35,490 --> 00:17:39,390
for<font color="#E5E5E5"> building two sons we can simply</font>

429
00:17:37,620 --> 00:17:42,780
increase the base list by<font color="#E5E5E5"> the amount of</font>

430
00:17:39,390 --> 00:17:45,630
memory<font color="#CCCCCC"> we get and which</font><font color="#E5E5E5"> forces are sent</font>

431
00:17:42,780 --> 00:17:48,090
<font color="#E5E5E5">to match the middle list</font><font color="#CCCCCC"> to a bigger</font>

432
00:17:45,630 --> 00:17:48,940
<font color="#E5E5E5">pattern just to control the size of the</font>

433
00:17:48,090 --> 00:17:51,250
<font color="#E5E5E5">list</font>

434
00:17:48,940 --> 00:17:53,380
and then we will generate<font color="#CCCCCC"> more solution</font>

435
00:17:51,250 --> 00:17:55,810
vectors in one iterations and so this is

436
00:17:53,380 --> 00:17:59,170
a larger now and they add up<font color="#CCCCCC"> to zero on</font>

437
00:17:55,810 --> 00:18:01,570
nearly all coordinates so my

438
00:17:59,170 --> 00:18:03,130
<font color="#E5E5E5">construction so if we repeat this for</font>

439
00:18:01,570 --> 00:18:04,990
<font color="#CCCCCC">different patterns we will generate more</font>

440
00:18:03,130 --> 00:18:07,060
solution vectors but<font color="#E5E5E5"> if we now repeat</font>

441
00:18:04,990 --> 00:18:09,610
for all patterns we will generate way

442
00:18:07,060 --> 00:18:11,440
too much solutions and so we have to

443
00:18:09,610 --> 00:18:14,530
stop stop at<font color="#E5E5E5"> some</font><font color="#CCCCCC"> point and this point</font>

444
00:18:11,440 --> 00:18:18,400
is exactly reached when the<font color="#CCCCCC"> input and</font>

445
00:18:14,530 --> 00:18:21,940
output list<font color="#CCCCCC"> sizes are equal so again</font>

446
00:18:18,400 --> 00:18:23,710
illustrating<font color="#E5E5E5"> this in our graphic</font><font color="#CCCCCC"> if we</font>

447
00:18:21,940 --> 00:18:27,340
apply<font color="#CCCCCC"> this tailoring technique to the</font>

448
00:18:23,710 --> 00:18:30,130
<font color="#CCCCCC">sharp edge jamia variant of our BK w we</font>

449
00:18:27,340 --> 00:18:32,050
<font color="#E5E5E5">achieve this solid line as trade off as</font>

450
00:18:30,130 --> 00:18:34,210
linear<font color="#E5E5E5"> interpolation between the</font>

451
00:18:32,050 --> 00:18:35,889
original BK w complexities and<font color="#CCCCCC"> the</font>

452
00:18:34,210 --> 00:18:38,350
<font color="#CCCCCC">sherpa Charmy a variant of the BK</font><font color="#E5E5E5"> w</font>

453
00:18:35,890 --> 00:18:40,900
which is<font color="#E5E5E5"> in fact able to leverage the</font>

454
00:18:38,350 --> 00:18:42,879
increase of memory between<font color="#E5E5E5"> these post</font>

455
00:18:40,900 --> 00:18:45,310
complexities<font color="#E5E5E5"> by decreasing the time</font>

456
00:18:42,880 --> 00:18:47,140
<font color="#E5E5E5">complexity and applying this technique</font>

457
00:18:45,310 --> 00:18:49,629
to the other members of the dissection

458
00:18:47,140 --> 00:18:51,820
class and<font color="#E5E5E5"> using them</font><font color="#CCCCCC"> into our inside of</font>

459
00:18:49,630 --> 00:18:54,070
our<font color="#CCCCCC"> framework</font><font color="#E5E5E5"> we achieve this solid</font>

460
00:18:51,820 --> 00:18:59,230
lines as piecewise continuous<font color="#E5E5E5"> trade off</font>

461
00:18:54,070 --> 00:19:01,570
so<font color="#CCCCCC"> which is in fact able</font><font color="#E5E5E5"> to leverage any</font>

462
00:18:59,230 --> 00:19:04,840
<font color="#E5E5E5">increase</font><font color="#CCCCCC"> of memory by decreasing the</font>

463
00:19:01,570 --> 00:19:08,530
<font color="#E5E5E5">time complexity so summarizing our</font>

464
00:19:04,840 --> 00:19:10,629
results we give a first<font color="#CCCCCC"> PK w variant</font>

465
00:19:08,530 --> 00:19:13,080
<font color="#CCCCCC">that</font><font color="#E5E5E5"> is applicable for any given amount</font>

466
00:19:10,630 --> 00:19:15,910
of<font color="#E5E5E5"> memory which we achieved by</font>

467
00:19:13,080 --> 00:19:19,000
abstracting solving<font color="#CCCCCC"> champion problem by</font>

468
00:19:15,910 --> 00:19:21,250
also b KW algorithm to solving<font color="#E5E5E5"> to see</font>

469
00:19:19,000 --> 00:19:24,880
some problem<font color="#CCCCCC"> and in</font><font color="#E5E5E5"> this context we give</font>

470
00:19:21,250 --> 00:19:27,610
a generalization<font color="#CCCCCC"> of</font><font color="#E5E5E5"> the dissection</font>

471
00:19:24,880 --> 00:19:29,770
technique which is in fact<font color="#E5E5E5"> a time memory</font>

472
00:19:27,610 --> 00:19:31,540
trade-off<font color="#E5E5E5"> for solving to see some</font>

473
00:19:29,770 --> 00:19:35,440
problem why<font color="#E5E5E5"> are the dissection</font>

474
00:19:31,540 --> 00:19:37,720
algorithms additionally not addressed in

475
00:19:35,440 --> 00:19:39,910
the<font color="#CCCCCC"> Stork</font><font color="#E5E5E5"> part addressed in our paper we</font>

476
00:19:37,720 --> 00:19:42,940
give a first quantum version of<font color="#E5E5E5"> the</font><font color="#CCCCCC"> ekw</font>

477
00:19:39,910 --> 00:19:44,860
<font color="#E5E5E5">algorithm which is a trade-off</font><font color="#CCCCCC"> so it of</font>

478
00:19:42,940 --> 00:19:46,870
course performs worse in terms of<font color="#E5E5E5"> times</font>

479
00:19:44,860 --> 00:19:49,719
in the original beacon<font color="#E5E5E5"> W but it forms</font>

480
00:19:46,870 --> 00:19:52,840
<font color="#E5E5E5">the best trade-off so far and our</font>

481
00:19:49,720 --> 00:19:56,040
results are easily<font color="#E5E5E5"> applicable to the lwe</font>

482
00:19:52,840 --> 00:20:01,559
setting thank you<font color="#CCCCCC"> very much</font>

483
00:19:56,040 --> 00:20:01,559
[Applause]

