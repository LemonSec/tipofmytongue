1
00:00:04,870 --> 00:00:09,090
all right thank you attack for<font color="#CCCCCC"> the</font>

2
00:00:07,120 --> 00:00:11,110
introduction so this work is<font color="#E5E5E5"> about</font>

3
00:00:09,090 --> 00:00:12,820
<font color="#E5E5E5">evaluating</font><font color="#CCCCCC"> ammo more freakily</font>

4
00:00:11,110 --> 00:00:16,720
neural network so<font color="#E5E5E5"> we want to evaluate</font>

5
00:00:12,820 --> 00:00:18,880
neural networks<font color="#E5E5E5"> over encrypted input so</font>

6
00:00:16,720 --> 00:00:20,229
as we<font color="#CCCCCC"> know machine</font><font color="#E5E5E5"> learning</font><font color="#CCCCCC"> as a service</font>

7
00:00:18,880 --> 00:00:22,560
is<font color="#E5E5E5"> gaining more and more importance</font>

8
00:00:20,230 --> 00:00:25,689
every day and new applications<font color="#CCCCCC"> come out</font>

9
00:00:22,560 --> 00:00:28,689
<font color="#E5E5E5">constantly in the usual scenario we</font><font color="#CCCCCC"> have</font>

10
00:00:25,689 --> 00:00:31,270
a remote party that has a model for

11
00:00:28,689 --> 00:00:33,790
<font color="#E5E5E5">example</font><font color="#CCCCCC"> a trained neural network</font><font color="#E5E5E5"> and a</font>

12
00:00:31,270 --> 00:00:35,980
user let's say Alice wants this model to

13
00:00:33,790 --> 00:00:39,850
be evaluated on some<font color="#E5E5E5"> input X that she</font>

14
00:00:35,980 --> 00:00:43,779
<font color="#E5E5E5">holds so the</font><font color="#CCCCCC"> usual the the easiest model</font>

15
00:00:39,850 --> 00:00:46,570
of interaction<font color="#CCCCCC"> is for Alice to send X to</font>

16
00:00:43,780 --> 00:00:49,780
the remote party and receive the model

17
00:00:46,570 --> 00:00:53,769
evaluated on X of course<font color="#E5E5E5"> this works but</font>

18
00:00:49,780 --> 00:00:57,640
there is a huge<font color="#CCCCCC"> problem here with sorry</font>

19
00:00:53,769 --> 00:01:00,248
<font color="#E5E5E5">with Alice's privacy because her data X</font>

20
00:00:57,640 --> 00:01:03,069
is leaked to the remote party and<font color="#E5E5E5"> this</font>

21
00:01:00,249 --> 00:01:06,310
might be<font color="#E5E5E5"> sensitive information that we</font>

22
00:01:03,069 --> 00:01:07,870
don't<font color="#E5E5E5"> want to believe so one possible</font>

23
00:01:06,310 --> 00:01:10,210
solution<font color="#CCCCCC"> to this problem is</font><font color="#E5E5E5"> of course</font>

24
00:01:07,870 --> 00:01:12,820
<font color="#CCCCCC">fully morphic encryption where instead</font>

25
00:01:10,210 --> 00:01:14,860
<font color="#CCCCCC">of sending just</font><font color="#E5E5E5"> X Alice sends an</font>

26
00:01:12,820 --> 00:01:18,220
encryption of<font color="#E5E5E5"> X and gets back an</font>

27
00:01:14,860 --> 00:01:20,620
encryption of the<font color="#E5E5E5"> of the output of the</font>

28
00:01:18,220 --> 00:01:22,570
result so of course this is<font color="#E5E5E5"> good for</font>

29
00:01:20,620 --> 00:01:24,520
<font color="#E5E5E5">privacy because data is encrypted both</font>

30
00:01:22,570 --> 00:01:26,289
ways meaning that the remote party

31
00:01:24,520 --> 00:01:29,770
doesn't<font color="#E5E5E5"> learn X and doesn't</font><font color="#CCCCCC"> even learn</font>

32
00:01:26,290 --> 00:01:31,510
<font color="#CCCCCC">the output M</font><font color="#E5E5E5"> of X the usual problem is</font>

33
00:01:29,770 --> 00:01:33,160
with<font color="#E5E5E5"> the efficiency because all the</font>

34
00:01:31,510 --> 00:01:34,810
solutions based on<font color="#CCCCCC"> fulham amorphic</font>

35
00:01:33,160 --> 00:01:37,179
encryptions are known to<font color="#CCCCCC"> be</font><font color="#E5E5E5"> somewhat</font>

36
00:01:34,810 --> 00:01:40,090
cumbersome or inefficient or anyway

37
00:01:37,180 --> 00:01:43,270
complicated so the<font color="#CCCCCC"> goal of this work</font>

38
00:01:40,090 --> 00:01:46,420
will be to<font color="#CCCCCC"> evaluate</font><font color="#E5E5E5"> neural networks</font>

39
00:01:43,270 --> 00:01:48,340
<font color="#CCCCCC">omma more filling</font><font color="#E5E5E5"> as efficiently as</font>

40
00:01:46,420 --> 00:01:50,350
possible<font color="#CCCCCC"> and note that</font><font color="#E5E5E5"> we</font><font color="#CCCCCC"> do not care</font>

41
00:01:48,340 --> 00:01:52,480
about<font color="#E5E5E5"> training from encrypted data we</font>

42
00:01:50,350 --> 00:01:55,119
assume that the model already<font color="#E5E5E5"> exists has</font>

43
00:01:52,480 --> 00:01:57,220
already<font color="#E5E5E5"> been trained somehow with some</font>

44
00:01:55,120 --> 00:01:59,920
data<font color="#E5E5E5"> we don't know how that happened and</font>

45
00:01:57,220 --> 00:02:02,470
<font color="#E5E5E5">we assume that the model is available in</font>

46
00:01:59,920 --> 00:02:06,400
the clear<font color="#CCCCCC"> so the weights of the neural</font>

47
00:02:02,470 --> 00:02:10,359
<font color="#CCCCCC">network will not be encrypted so very</font>

48
00:02:06,400 --> 00:02:13,030
quick refresher<font color="#CCCCCC"> on neural networks some</font>

49
00:02:10,360 --> 00:02:14,950
of these<font color="#E5E5E5"> things have already been said</font>

50
00:02:13,030 --> 00:02:17,439
by<font color="#CCCCCC"> chef in</font><font color="#E5E5E5"> your lecture</font><font color="#CCCCCC"> notes so we'll</font>

51
00:02:14,950 --> 00:02:18,709
just repeat a few key concepts so neural

52
00:02:17,439 --> 00:02:21,650
networks<font color="#E5E5E5"> are</font>

53
00:02:18,710 --> 00:02:23,780
collections of computational units

54
00:02:21,650 --> 00:02:25,850
called neurons which are arranged<font color="#E5E5E5"> in</font>

55
00:02:23,780 --> 00:02:27,920
several layers so<font color="#CCCCCC"> we have an input layer</font>

56
00:02:25,850 --> 00:02:30,739
that receives<font color="#E5E5E5"> input</font><font color="#CCCCCC"> from</font><font color="#E5E5E5"> the external</font>

57
00:02:27,920 --> 00:02:33,530
<font color="#CCCCCC">world</font><font color="#E5E5E5"> then we have several hidden layers</font>

58
00:02:30,740 --> 00:02:35,810
<font color="#E5E5E5">and we and the number of these hidden</font>

59
00:02:33,530 --> 00:02:37,730
layers<font color="#E5E5E5"> define the depth of the model and</font>

60
00:02:35,810 --> 00:02:39,650
then<font color="#CCCCCC"> we have an output layer that</font>

61
00:02:37,730 --> 00:02:42,290
communicates the result back to<font color="#E5E5E5"> the</font>

62
00:02:39,650 --> 00:02:44,600
<font color="#E5E5E5">external</font><font color="#CCCCCC"> world and if</font><font color="#E5E5E5"> we zoom in and if</font>

63
00:02:42,290 --> 00:02:47,060
we look at one<font color="#E5E5E5"> single neuron what</font>

64
00:02:44,600 --> 00:02:50,060
happens inside the neuron is basically

65
00:02:47,060 --> 00:02:52,670
this so there are inputs<font color="#CCCCCC"> excise</font><font color="#E5E5E5"> that</font>

66
00:02:50,060 --> 00:02:56,600
come into the neuron<font color="#E5E5E5"> on wires which are</font>

67
00:02:52,670 --> 00:02:59,269
associated<font color="#CCCCCC"> to several weights WI</font><font color="#E5E5E5"> and now</font>

68
00:02:56,600 --> 00:03:01,459
two things happen in the neuron<font color="#E5E5E5"> so we</font>

69
00:02:59,270 --> 00:03:04,790
have first of all this object<font color="#E5E5E5"> which we</font>

70
00:03:01,459 --> 00:03:08,240
call multisim because we scale the

71
00:03:04,790 --> 00:03:10,130
inputs<font color="#E5E5E5"> excise by the weights WI so we</font>

72
00:03:08,240 --> 00:03:14,570
multiply<font color="#CCCCCC"> them and then we sum</font><font color="#E5E5E5"> everything</font>

73
00:03:10,130 --> 00:03:16,459
together and then we apply<font color="#CCCCCC"> a nonlinear</font>

74
00:03:14,570 --> 00:03:19,519
function<font color="#E5E5E5"> which is called an activation</font>

75
00:03:16,459 --> 00:03:21,920
function<font color="#E5E5E5"> the result which we call</font><font color="#CCCCCC"> Y is</font>

76
00:03:19,520 --> 00:03:23,600
then the result of the<font color="#CCCCCC"> MIL of the neuron</font>

77
00:03:21,920 --> 00:03:25,549
which is propagated to<font color="#E5E5E5"> the</font><font color="#CCCCCC"> following</font>

78
00:03:23,600 --> 00:03:28,250
layer<font color="#E5E5E5"> and please here note that</font>

79
00:03:25,550 --> 00:03:31,640
<font color="#E5E5E5">everything is on the real so in general</font>

80
00:03:28,250 --> 00:03:37,340
<font color="#CCCCCC">there is</font><font color="#E5E5E5"> no restriction so x i's</font><font color="#CCCCCC"> wi s</font>

81
00:03:31,640 --> 00:03:40,220
and y are all real valued numbers in

82
00:03:37,340 --> 00:03:41,769
this work we consider as a specific use

83
00:03:40,220 --> 00:03:45,489
case the problem<font color="#E5E5E5"> of digit recognition</font>

84
00:03:41,769 --> 00:03:48,260
<font color="#E5E5E5">meaning that we will have a picture that</font>

85
00:03:45,489 --> 00:03:51,200
<font color="#CCCCCC">represents a handwritten</font><font color="#E5E5E5"> digit this will</font>

86
00:03:48,260 --> 00:03:53,390
be given to<font color="#CCCCCC"> our model and</font><font color="#E5E5E5"> the model will</font>

87
00:03:51,200 --> 00:03:57,920
have to predict<font color="#E5E5E5"> will have to understand</font>

88
00:03:53,390 --> 00:03:59,268
<font color="#E5E5E5">which digit is depicted in</font><font color="#CCCCCC"> the image the</font>

89
00:03:57,920 --> 00:04:01,429
thing here<font color="#CCCCCC"> is that</font><font color="#E5E5E5"> we will do</font><font color="#CCCCCC"> everything</font>

90
00:03:59,269 --> 00:04:03,140
<font color="#E5E5E5">emotionally meaning</font><font color="#CCCCCC"> that we will</font><font color="#E5E5E5"> start</font>

91
00:04:01,430 --> 00:04:05,060
<font color="#E5E5E5">with an encryption of an image and</font><font color="#CCCCCC"> we</font>

92
00:04:03,140 --> 00:04:08,540
<font color="#CCCCCC">will recover an encryption</font><font color="#E5E5E5"> of the</font>

93
00:04:05,060 --> 00:04:11,299
predicted label<font color="#E5E5E5"> and as a data set we</font><font color="#CCCCCC"> use</font>

94
00:04:08,540 --> 00:04:15,200
the common<font color="#CCCCCC"> NIST data set which contains</font>

95
00:04:11,299 --> 00:04:20,600
several thousands images of handwritten

96
00:04:15,200 --> 00:04:24,500
digits so currently the state<font color="#CCCCCC"> of the art</font>

97
00:04:20,600 --> 00:04:27,710
for this problem is Krypton s<font color="#CCCCCC"> Shaffi</font>

98
00:04:24,500 --> 00:04:30,020
also mentioned this work it was proposed

99
00:04:27,710 --> 00:04:31,349
in 2016 by people<font color="#CCCCCC"> that Microsoft</font>

100
00:04:30,020 --> 00:04:34,438
<font color="#E5E5E5">Research</font>

101
00:04:31,349 --> 00:04:36,659
and it achieves blind meaning<font color="#CCCCCC"> Alma</font>

102
00:04:34,439 --> 00:04:38,729
<font color="#CCCCCC">morphix so it operates unencrypted em</font>

103
00:04:36,659 --> 00:04:40,770
unencrypted data<font color="#CCCCCC"> non-interactive</font>

104
00:04:38,729 --> 00:04:42,240
classification and here<font color="#CCCCCC"> non-interactive</font>

105
00:04:40,770 --> 00:04:44,099
means that it does not rely on

106
00:04:42,240 --> 00:04:45,960
multi-party computation so there is no

107
00:04:44,099 --> 00:04:49,229
interaction<font color="#CCCCCC"> between the user and the</font>

108
00:04:45,960 --> 00:04:50,878
<font color="#E5E5E5">server it</font><font color="#CCCCCC"> also achieves</font><font color="#E5E5E5"> almost</font>

109
00:04:49,229 --> 00:04:53,248
state-of-the-art<font color="#E5E5E5"> accuracy there is a</font>

110
00:04:50,879 --> 00:04:58,409
small loss but it's<font color="#E5E5E5"> fairly limited so</font>

111
00:04:53,249 --> 00:05:01,139
almost<font color="#CCCCCC"> 99% accuracy the problems here</font>

112
00:04:58,409 --> 00:05:02,998
are<font color="#E5E5E5"> that usually the activation</font>

113
00:05:01,139 --> 00:05:04,800
functions are sigmoid<font color="#CCCCCC"> all functions</font>

114
00:05:02,999 --> 00:05:08,369
<font color="#E5E5E5">meaning that they have the shape of an</font><font color="#CCCCCC"> S</font>

115
00:05:04,800 --> 00:05:09,899
basically<font color="#E5E5E5"> and here</font><font color="#CCCCCC"> these functions are</font>

116
00:05:08,369 --> 00:05:12,089
replaced with low degree<font color="#CCCCCC"> polynomials</font>

117
00:05:09,899 --> 00:05:14,430
because<font color="#E5E5E5"> they are easier to</font><font color="#CCCCCC"> evaluate</font><font color="#E5E5E5"> or</font>

118
00:05:12,089 --> 00:05:18,509
<font color="#CCCCCC">mow more thickly</font><font color="#E5E5E5"> and this has been shown</font>

119
00:05:14,430 --> 00:05:20,339
<font color="#E5E5E5">to</font><font color="#CCCCCC"> work pretty</font><font color="#E5E5E5"> well but the biggest</font>

120
00:05:18,509 --> 00:05:21,869
problem<font color="#CCCCCC"> is that it</font><font color="#E5E5E5"> uses some</font><font color="#CCCCCC"> otome</font>

121
00:05:20,339 --> 00:05:24,240
<font color="#CCCCCC">amorphic encryptions meaning that</font>

122
00:05:21,869 --> 00:05:26,490
parameters have to<font color="#CCCCCC"> be</font><font color="#E5E5E5"> chosen at set up</font>

123
00:05:24,240 --> 00:05:28,080
time so<font color="#E5E5E5"> when we set up the system we</font>

124
00:05:26,490 --> 00:05:30,119
have to choose<font color="#E5E5E5"> the parameters</font><font color="#CCCCCC"> taking</font>

125
00:05:28,080 --> 00:05:32,969
into account the<font color="#E5E5E5"> entire structure</font><font color="#CCCCCC"> of the</font>

126
00:05:30,119 --> 00:05:34,469
system<font color="#E5E5E5"> so again</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> main limitation of</font>

127
00:05:32,969 --> 00:05:37,680
this approach<font color="#CCCCCC"> is that the computation</font>

128
00:05:34,469 --> 00:05:41,159
<font color="#E5E5E5">for each neuron</font><font color="#CCCCCC"> depends on how complex</font>

129
00:05:37,680 --> 00:05:43,259
the entire network<font color="#CCCCCC"> is so it depends on</font>

130
00:05:41,159 --> 00:05:45,149
<font color="#E5E5E5">the total multiplicative depth of the</font>

131
00:05:43,259 --> 00:05:47,849
entire network<font color="#CCCCCC"> and this</font><font color="#E5E5E5"> is particularly</font>

132
00:05:45,149 --> 00:05:50,309
bad especially for<font color="#E5E5E5"> deep learning because</font>

133
00:05:47,849 --> 00:05:53,209
we in deep learning we can<font color="#CCCCCC"> have models</font>

134
00:05:50,309 --> 00:05:56,009
<font color="#E5E5E5">where we</font><font color="#CCCCCC"> have tens or even hundreds of</font>

135
00:05:53,209 --> 00:05:57,719
layers one after the other<font color="#E5E5E5"> so the</font>

136
00:05:56,009 --> 00:05:59,669
<font color="#E5E5E5">complexity is</font><font color="#CCCCCC"> very high so the</font>

137
00:05:57,719 --> 00:06:03,319
parameters have to<font color="#CCCCCC"> be chosen very large</font>

138
00:05:59,669 --> 00:06:06,419
and this makes the approach quickly

139
00:06:03,319 --> 00:06:09,509
<font color="#E5E5E5">inefficient</font><font color="#CCCCCC"> so it's an approach that</font><font color="#E5E5E5"> in</font>

140
00:06:06,419 --> 00:06:11,008
<font color="#E5E5E5">general does</font><font color="#CCCCCC"> not scale well</font><font color="#E5E5E5"> instead in</font>

141
00:06:09,509 --> 00:06:13,110
this work we want to<font color="#E5E5E5"> make the</font>

142
00:06:11,009 --> 00:06:15,779
<font color="#E5E5E5">computation scale invariant meaning that</font>

143
00:06:13,110 --> 00:06:18,149
what happens at the neuron level<font color="#E5E5E5"> is not</font>

144
00:06:15,779 --> 00:06:21,869
does<font color="#E5E5E5"> not depend on</font><font color="#CCCCCC"> how big the total</font>

145
00:06:18,149 --> 00:06:24,180
network<font color="#E5E5E5"> is and in order to</font><font color="#CCCCCC"> achieve this</font>

146
00:06:21,869 --> 00:06:26,610
<font color="#CCCCCC">result we will rely on bootstrapping</font>

147
00:06:24,180 --> 00:06:29,309
which is a technique to kind<font color="#E5E5E5"> of refresh</font>

148
00:06:26,610 --> 00:06:34,559
the ciphertext<font color="#CCCCCC"> in order</font><font color="#E5E5E5"> for it to be</font>

149
00:06:29,309 --> 00:06:36,330
able<font color="#E5E5E5"> to support more computations so</font>

150
00:06:34,559 --> 00:06:39,269
first of<font color="#E5E5E5"> all a restriction on</font><font color="#CCCCCC"> the model</font>

151
00:06:36,330 --> 00:06:41,128
<font color="#E5E5E5">so we said that one</font><font color="#CCCCCC"> of the steps that we</font>

152
00:06:39,269 --> 00:06:43,560
have to<font color="#E5E5E5"> perform is</font><font color="#CCCCCC"> OMA more freakily</font>

153
00:06:41,129 --> 00:06:44,860
computed<font color="#CCCCCC"> computing this quantity here</font>

154
00:06:43,560 --> 00:06:48,730
<font color="#E5E5E5">that we call multisim</font>

155
00:06:44,860 --> 00:06:51,430
so we will be given<font color="#E5E5E5"> the weight of the</font>

156
00:06:48,730 --> 00:06:54,400
model<font color="#E5E5E5"> in the clear and encryptions</font><font color="#CCCCCC"> of</font>

157
00:06:51,430 --> 00:06:56,170
the inputs so<font color="#CCCCCC"> what we do is just</font><font color="#E5E5E5"> we take</font>

158
00:06:54,400 --> 00:06:57,789
the encryptions we scale them<font color="#E5E5E5"> by the</font>

159
00:06:56,170 --> 00:07:00,970
<font color="#E5E5E5">corresponding weight and then we sum</font>

160
00:06:57,790 --> 00:07:03,700
everything<font color="#E5E5E5"> together the thing that we</font>

161
00:07:00,970 --> 00:07:06,040
have<font color="#CCCCCC"> to take care of is</font><font color="#E5E5E5"> that in order</font><font color="#CCCCCC"> to</font>

162
00:07:03,700 --> 00:07:08,050
maintain correctness we can scale<font color="#CCCCCC"> only</font>

163
00:07:06,040 --> 00:07:10,030
by integer constants<font color="#E5E5E5"> if we scale by</font>

164
00:07:08,050 --> 00:07:11,530
floating points<font color="#E5E5E5"> we lose correctness so</font>

165
00:07:10,030 --> 00:07:14,619
we have to make sure<font color="#CCCCCC"> that the</font><font color="#E5E5E5"> weights</font>

166
00:07:11,530 --> 00:07:18,039
are integer<font color="#E5E5E5"> whereas before we had no</font>

167
00:07:14,620 --> 00:07:20,500
such limitation so of course<font color="#CCCCCC"> this</font>

168
00:07:18,040 --> 00:07:22,210
<font color="#E5E5E5">induces a trade-off between efficiency</font>

169
00:07:20,500 --> 00:07:24,490
<font color="#CCCCCC">and accuracy because</font><font color="#E5E5E5"> the way we</font>

170
00:07:22,210 --> 00:07:28,239
discretize the<font color="#E5E5E5"> weights will impact of</font>

171
00:07:24,490 --> 00:07:30,280
course efficiency and accuracy<font color="#E5E5E5"> it's a</font>

172
00:07:28,240 --> 00:07:34,780
matter of precision so how precisely we

173
00:07:30,280 --> 00:07:37,659
want to discretize<font color="#E5E5E5"> the weights so again</font>

174
00:07:34,780 --> 00:07:39,760
the<font color="#CCCCCC"> the goal</font><font color="#E5E5E5"> is to define an FHP</font>

175
00:07:37,660 --> 00:07:41,710
friendly model of neural networks so a

176
00:07:39,760 --> 00:07:44,110
<font color="#E5E5E5">model of neural network that</font><font color="#CCCCCC"> can</font><font color="#E5E5E5"> be</font>

177
00:07:41,710 --> 00:07:47,080
efficiently computed or<font color="#E5E5E5"> evaluated</font>

178
00:07:44,110 --> 00:07:48,580
homomorphic<font color="#CCCCCC"> ly</font><font color="#E5E5E5"> so we define this</font><font color="#CCCCCC"> object</font>

179
00:07:47,080 --> 00:07:50,950
which is called<font color="#E5E5E5"> discretized neural</font>

180
00:07:48,580 --> 00:07:53,320
network or<font color="#CCCCCC"> din</font><font color="#E5E5E5"> here I put the definition</font>

181
00:07:50,950 --> 00:07:55,870
<font color="#CCCCCC">but actually it's very</font><font color="#E5E5E5"> simple</font><font color="#CCCCCC"> we just</font>

182
00:07:53,320 --> 00:07:58,390
<font color="#E5E5E5">take integer</font><font color="#CCCCCC"> values for the inputs</font>

183
00:07:55,870 --> 00:08:00,400
integer values for the weights and then

184
00:07:58,390 --> 00:08:02,349
we<font color="#E5E5E5"> take an activation function function</font>

185
00:08:00,400 --> 00:08:05,620
that map's<font color="#E5E5E5"> whatever comes out of</font><font color="#CCCCCC"> the</font>

186
00:08:02,350 --> 00:08:08,080
<font color="#CCCCCC">multisim back to the</font><font color="#E5E5E5"> input space this</font>

187
00:08:05,620 --> 00:08:10,510
kind of psychical structure makes sure

188
00:08:08,080 --> 00:08:15,280
<font color="#CCCCCC">that we can go</font><font color="#E5E5E5"> on computing for an</font>

189
00:08:10,510 --> 00:08:17,680
unbounded number of operations so first

190
00:08:15,280 --> 00:08:20,559
of<font color="#E5E5E5"> all this model is not as restrictive</font>

191
00:08:17,680 --> 00:08:22,150
<font color="#CCCCCC">as it might seem for example it has</font>

192
00:08:20,560 --> 00:08:23,920
<font color="#E5E5E5">already been done even in a more</font>

193
00:08:22,150 --> 00:08:25,840
<font color="#E5E5E5">restrictive</font><font color="#CCCCCC"> fashion with binarized</font>

194
00:08:23,920 --> 00:08:28,930
neural networks<font color="#E5E5E5"> where everything is</font>

195
00:08:25,840 --> 00:08:32,140
<font color="#E5E5E5">binary so both the inputs the weights</font>

196
00:08:28,930 --> 00:08:34,450
and<font color="#E5E5E5"> the activations of course are binary</font>

197
00:08:32,140 --> 00:08:38,229
and it has been<font color="#E5E5E5"> shown</font><font color="#CCCCCC"> to work</font><font color="#E5E5E5"> well of</font>

198
00:08:34,450 --> 00:08:39,820
course<font color="#E5E5E5"> there is a trade-off between size</font>

199
00:08:38,229 --> 00:08:42,700
and<font color="#CCCCCC"> performance because if we</font><font color="#E5E5E5"> want</font><font color="#CCCCCC"> to</font>

200
00:08:39,820 --> 00:08:44,890
discretize the network<font color="#E5E5E5"> they will become</font>

201
00:08:42,700 --> 00:08:49,330
<font color="#E5E5E5">bigger in order to maintain the same</font>

202
00:08:44,890 --> 00:08:51,730
level<font color="#CCCCCC"> of accuracy</font><font color="#E5E5E5"> and finally we know</font>

203
00:08:49,330 --> 00:08:54,040
<font color="#E5E5E5">that a basic conversion from generic</font>

204
00:08:51,730 --> 00:08:56,140
neural network over the<font color="#E5E5E5"> reals and a</font>

205
00:08:54,040 --> 00:08:57,670
discretized neural network is extremely

206
00:08:56,140 --> 00:08:58,430
<font color="#CCCCCC">easy we can just chop off</font><font color="#E5E5E5"> the decimal</font>

207
00:08:57,670 --> 00:09:01,579
<font color="#CCCCCC">part</font>

208
00:08:58,430 --> 00:09:03,709
and that is<font color="#CCCCCC"> actually add in</font><font color="#E5E5E5"> of course</font>

209
00:09:01,580 --> 00:09:05,930
this<font color="#E5E5E5"> might not be</font><font color="#CCCCCC"> the best way to do it</font>

210
00:09:03,710 --> 00:09:07,790
<font color="#CCCCCC">so this</font><font color="#E5E5E5"> might not be</font><font color="#CCCCCC"> the best way to do</font>

211
00:09:05,930 --> 00:09:09,829
the conversion<font color="#CCCCCC"> but it already</font><font color="#E5E5E5"> works</font>

212
00:09:07,790 --> 00:09:15,410
<font color="#E5E5E5">meaning that it</font><font color="#CCCCCC"> achieves a model that</font>

213
00:09:09,830 --> 00:09:18,590
<font color="#E5E5E5">respects this definition</font><font color="#CCCCCC"> so again once</font>

214
00:09:15,410 --> 00:09:20,300
we have<font color="#CCCCCC"> add</font><font color="#E5E5E5"> in how do we</font><font color="#CCCCCC"> Oh mom Oracle</font>

215
00:09:18,590 --> 00:09:22,520
evaluate it so<font color="#CCCCCC"> first of all</font><font color="#E5E5E5"> we want to</font>

216
00:09:20,300 --> 00:09:24,490
evaluate the<font color="#E5E5E5"> multisim and this is easy</font>

217
00:09:22,520 --> 00:09:26,660
<font color="#CCCCCC">because we just need a normal</font><font color="#E5E5E5"> morphic</font>

218
00:09:24,490 --> 00:09:30,140
encryption scheme that supports linear

219
00:09:26,660 --> 00:09:32,180
operation then we want to<font color="#E5E5E5"> apply the</font>

220
00:09:30,140 --> 00:09:33,920
activation function<font color="#E5E5E5"> and this is a tricky</font>

221
00:09:32,180 --> 00:09:35,479
<font color="#CCCCCC">part because it depends</font><font color="#E5E5E5"> on which</font>

222
00:09:33,920 --> 00:09:39,079
function we choose and I will tell you

223
00:09:35,480 --> 00:09:40,880
<font color="#E5E5E5">more</font><font color="#CCCCCC"> about this in a moment then</font><font color="#E5E5E5"> we have</font>

224
00:09:39,080 --> 00:09:42,440
<font color="#CCCCCC">to bootstrap in order to refresh the</font>

225
00:09:40,880 --> 00:09:44,720
ciphertext<font color="#CCCCCC"> and be able</font><font color="#E5E5E5"> to go on</font>

226
00:09:42,440 --> 00:09:47,360
computing and then we have to repeat

227
00:09:44,720 --> 00:09:51,980
this process<font color="#CCCCCC"> for all the layers of</font><font color="#E5E5E5"> the</font>

228
00:09:47,360 --> 00:09:53,450
network<font color="#E5E5E5"> we also have some issues</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> face</font>

229
00:09:51,980 --> 00:09:56,500
so first of<font color="#E5E5E5"> all we have to choose the</font>

230
00:09:53,450 --> 00:09:59,450
message<font color="#CCCCCC"> space of the encryption</font><font color="#E5E5E5"> scheme</font>

231
00:09:56,500 --> 00:10:02,300
we have<font color="#E5E5E5"> several ways of</font><font color="#CCCCCC"> doing this</font><font color="#E5E5E5"> we</font>

232
00:09:59,450 --> 00:10:04,550
could guess a<font color="#CCCCCC"> number based</font><font color="#E5E5E5"> on some prior</font>

233
00:10:02,300 --> 00:10:06,949
<font color="#CCCCCC">information that we have we can take</font>

234
00:10:04,550 --> 00:10:09,620
<font color="#CCCCCC">statistics on the training set</font><font color="#E5E5E5"> and hope</font>

235
00:10:06,950 --> 00:10:12,620
that the test set<font color="#CCCCCC"> or the new instances</font>

236
00:10:09,620 --> 00:10:15,020
will behave<font color="#E5E5E5"> in the same way</font><font color="#CCCCCC"> or we can</font>

237
00:10:12,620 --> 00:10:16,850
take<font color="#E5E5E5"> a worst case the worst case over</font>

238
00:10:15,020 --> 00:10:19,970
the entire input<font color="#CCCCCC"> space meaning</font><font color="#E5E5E5"> that we</font>

239
00:10:16,850 --> 00:10:22,160
support<font color="#E5E5E5"> even the worst possible input</font>

240
00:10:19,970 --> 00:10:24,860
that we can receive this is<font color="#CCCCCC"> usually the</font>

241
00:10:22,160 --> 00:10:26,780
safest<font color="#CCCCCC"> approach but not</font><font color="#E5E5E5"> guaranteed to be</font>

242
00:10:24,860 --> 00:10:28,490
<font color="#CCCCCC">the best because if the input if the</font>

243
00:10:26,780 --> 00:10:32,270
worst case happens with very low

244
00:10:28,490 --> 00:10:34,520
probability then we it might be better

245
00:10:32,270 --> 00:10:38,030
to<font color="#E5E5E5"> just sacrifice perfect correctness in</font>

246
00:10:34,520 --> 00:10:40,610
order to<font color="#E5E5E5"> achieve more efficiency another</font>

247
00:10:38,030 --> 00:10:44,150
issue is that<font color="#E5E5E5"> the noise grows with</font><font color="#CCCCCC"> our</font>

248
00:10:40,610 --> 00:10:46,490
<font color="#CCCCCC">amorphic operations so</font><font color="#E5E5E5"> we have to start</font>

249
00:10:44,150 --> 00:10:49,220
from a very<font color="#CCCCCC"> small noise because even if</font>

250
00:10:46,490 --> 00:10:51,920
we<font color="#E5E5E5"> apply bootstrapping here just to</font>

251
00:10:49,220 --> 00:10:53,870
compute the<font color="#E5E5E5"> multisim we already have to</font>

252
00:10:51,920 --> 00:10:57,050
perform some<font color="#E5E5E5"> of morphic operations and</font>

253
00:10:53,870 --> 00:10:59,210
this makes the noise<font color="#E5E5E5"> grow so we have to</font>

254
00:10:57,050 --> 00:11:01,160
start with a very small<font color="#E5E5E5"> noise and in</font>

255
00:10:59,210 --> 00:11:02,960
order to<font color="#CCCCCC"> maintain security</font><font color="#E5E5E5"> even with a</font>

256
00:11:01,160 --> 00:11:06,469
small<font color="#E5E5E5"> noise we have to compensate by</font>

257
00:11:02,960 --> 00:11:09,860
using<font color="#E5E5E5"> bigger parameters larger</font>

258
00:11:06,470 --> 00:11:11,750
parameters for the encryption<font color="#E5E5E5"> scheme</font>

259
00:11:09,860 --> 00:11:13,820
and finally the main question is how do

260
00:11:11,750 --> 00:11:17,480
<font color="#E5E5E5">we apply the activation function or</font><font color="#CCCCCC"> Moe</font>

261
00:11:13,820 --> 00:11:19,880
<font color="#CCCCCC">more filling</font><font color="#E5E5E5"> so the basic idea</font><font color="#CCCCCC"> is to</font>

262
00:11:17,480 --> 00:11:22,339
activate<font color="#E5E5E5"> while we apply the</font>

263
00:11:19,880 --> 00:11:24,439
bootstrapping<font color="#CCCCCC"> procedure</font><font color="#E5E5E5"> so we combine</font>

264
00:11:22,339 --> 00:11:26,420
bootstrapping and<font color="#E5E5E5"> activation function</font>

265
00:11:24,440 --> 00:11:29,810
meaning that<font color="#E5E5E5"> we move from an encryption</font>

266
00:11:26,420 --> 00:11:32,630
of a value X to a refreshed<font color="#E5E5E5"> encryption</font>

267
00:11:29,810 --> 00:11:35,000
<font color="#E5E5E5">of a value f of X so we apply the</font>

268
00:11:32,630 --> 00:11:39,620
function<font color="#E5E5E5"> the activation function f and</font>

269
00:11:35,000 --> 00:11:43,130
<font color="#E5E5E5">we bootstrap at the same time so what</font>

270
00:11:39,620 --> 00:11:44,810
happens is<font color="#CCCCCC"> basically this this is the</font>

271
00:11:43,130 --> 00:11:47,360
same picture<font color="#CCCCCC"> as before</font><font color="#E5E5E5"> only that now</font>

272
00:11:44,810 --> 00:11:51,109
inputs and output and the output<font color="#CCCCCC"> are</font>

273
00:11:47,360 --> 00:11:53,899
encrypted<font color="#E5E5E5"> so we have encrypted input</font>

274
00:11:51,110 --> 00:11:56,630
inputs coming in they are weighted with

275
00:11:53,899 --> 00:11:59,300
this weight and they are activated<font color="#E5E5E5"> and</font>

276
00:11:56,630 --> 00:12:03,769
refreshed<font color="#E5E5E5"> the result is basically a</font>

277
00:11:59,300 --> 00:12:07,459
refreshed version of this<font color="#E5E5E5"> Y that</font><font color="#CCCCCC"> we saw</font>

278
00:12:03,769 --> 00:12:09,649
before<font color="#E5E5E5"> so again</font><font color="#CCCCCC"> two steps first we</font>

279
00:12:07,459 --> 00:12:12,829
<font color="#E5E5E5">compute the multisim and then we</font>

280
00:12:09,649 --> 00:12:15,769
bootstrap<font color="#CCCCCC"> to the activated value the</font>

281
00:12:12,829 --> 00:12:18,410
starting point is a word<font color="#E5E5E5"> called tfhe</font>

282
00:12:15,769 --> 00:12:20,209
<font color="#E5E5E5">this is not threshold for the moment rip</font>

283
00:12:18,410 --> 00:12:21,680
<font color="#CCCCCC">shin</font><font color="#E5E5E5"> it's</font><font color="#CCCCCC"> tourist fulham amorphic</font>

284
00:12:20,209 --> 00:12:26,510
encryption there is a collision<font color="#E5E5E5"> in the</font>

285
00:12:21,680 --> 00:12:28,670
actual names it's a work by kilo<font color="#CCCCCC"> title</font>

286
00:12:26,510 --> 00:12:31,279
which was<font color="#CCCCCC"> presented in 2016 and is</font>

287
00:12:28,670 --> 00:12:32,959
nowadays<font color="#E5E5E5"> to the best of</font><font color="#CCCCCC"> my knowledge</font><font color="#E5E5E5"> the</font>

288
00:12:31,279 --> 00:12:35,180
fastest implementation of the

289
00:12:32,959 --> 00:12:37,910
bootstrapping procedure<font color="#CCCCCC"> so the basic</font>

290
00:12:35,180 --> 00:12:43,069
assumption is<font color="#CCCCCC"> lwe over the torus where</font>

291
00:12:37,910 --> 00:12:45,199
the torus is the reals modulo<font color="#CCCCCC"> 1 so in</font>

292
00:12:43,070 --> 00:12:47,930
the in this word<font color="#CCCCCC"> the authors</font><font color="#E5E5E5"> define</font>

293
00:12:45,199 --> 00:12:51,439
<font color="#E5E5E5">several flavors of lwe based encryption</font>

294
00:12:47,930 --> 00:12:55,459
schemes the the<font color="#E5E5E5"> two that we will</font><font color="#CCCCCC"> use our</font>

295
00:12:51,440 --> 00:12:58,519
<font color="#E5E5E5">LW e</font><font color="#CCCCCC"> NT</font><font color="#E5E5E5"> LW e so with LW we encrypt a</font>

296
00:12:55,459 --> 00:13:01,250
scalar<font color="#E5E5E5"> into n plus</font><font color="#CCCCCC"> 1</font><font color="#E5E5E5"> scalars whereas</font>

297
00:12:58,519 --> 00:13:03,920
with t LW e which<font color="#CCCCCC"> is roughly ringed lwe</font>

298
00:13:01,250 --> 00:13:06,230
we include we encrypt a polynomial into

299
00:13:03,920 --> 00:13:09,949
k<font color="#CCCCCC"> plus 1 polynomials where N and K are</font>

300
00:13:06,230 --> 00:13:11,959
<font color="#E5E5E5">security parameters now I will not</font><font color="#CCCCCC"> go</font>

301
00:13:09,949 --> 00:13:13,819
<font color="#CCCCCC">into deep into the details of the</font>

302
00:13:11,959 --> 00:13:16,040
bootstrapping procedure but in order to

303
00:13:13,820 --> 00:13:18,199
<font color="#E5E5E5">just give a</font><font color="#CCCCCC"> quick intuition</font><font color="#E5E5E5"> the analogy</font>

304
00:13:16,040 --> 00:13:21,079
<font color="#CCCCCC">that the authors use is the wheel</font><font color="#E5E5E5"> of</font>

305
00:13:18,199 --> 00:13:22,680
fortune<font color="#CCCCCC"> so when we want to refresh a</font>

306
00:13:21,079 --> 00:13:25,709
<font color="#E5E5E5">ciphertext we prepare</font>

307
00:13:22,680 --> 00:13:27,959
wheel which is divided into slices<font color="#E5E5E5"> and</font>

308
00:13:25,709 --> 00:13:29,998
each slice contains the result a

309
00:13:27,959 --> 00:13:32,939
possible result of the bootstrapping

310
00:13:29,999 --> 00:13:36,180
procedure<font color="#E5E5E5"> then we automatically spin the</font>

311
00:13:32,939 --> 00:13:38,309
wheel and we take whatever<font color="#E5E5E5"> ciphertext is</font>

312
00:13:36,180 --> 00:13:41,189
pointed to<font color="#CCCCCC"> by</font><font color="#E5E5E5"> the arrow at the</font><font color="#CCCCCC"> end of</font>

313
00:13:38,309 --> 00:13:43,319
the<font color="#E5E5E5"> procedure and ohm</font><font color="#CCCCCC"> amorphic Li</font>

314
00:13:41,189 --> 00:13:45,569
spinning the wheel means that instead<font color="#E5E5E5"> of</font>

315
00:13:43,319 --> 00:13:47,368
having<font color="#CCCCCC"> access to the</font><font color="#E5E5E5"> secret key s we</font>

316
00:13:45,569 --> 00:13:49,349
have<font color="#E5E5E5"> access to</font><font color="#CCCCCC"> an encryption of the</font>

317
00:13:47,369 --> 00:13:51,749
secret key<font color="#E5E5E5"> s which is called the</font>

318
00:13:49,350 --> 00:13:53,279
bootstrapping key so basically we<font color="#CCCCCC"> start</font>

319
00:13:51,749 --> 00:13:55,619
with the<font color="#CCCCCC"> ciphertext that</font><font color="#E5E5E5"> contains a</font>

320
00:13:53,279 --> 00:13:57,300
certain<font color="#CCCCCC"> message</font><font color="#E5E5E5"> we automatically spin</font>

321
00:13:55,619 --> 00:13:59,970
<font color="#E5E5E5">the wheel by a quantity which is</font>

322
00:13:57,300 --> 00:14:02,329
equivalent<font color="#E5E5E5"> to this message</font><font color="#CCCCCC"> and then we</font>

323
00:13:59,970 --> 00:14:04,949
pick whatever ciphertext we end up on

324
00:14:02,329 --> 00:14:07,949
this is an intuition on the

325
00:14:04,949 --> 00:14:10,829
bootstrapping procedure<font color="#E5E5E5"> so in this work</font>

326
00:14:07,949 --> 00:14:12,748
we<font color="#CCCCCC"> focus on the sign as an activation</font>

327
00:14:10,829 --> 00:14:14,910
function so we want to<font color="#CCCCCC"> OMA</font><font color="#E5E5E5"> morphic Li</font>

328
00:14:12,749 --> 00:14:17,790
compute the sign of a message and the

329
00:14:14,910 --> 00:14:19,679
way we do it is this so we start<font color="#CCCCCC"> with</font>

330
00:14:17,790 --> 00:14:23,219
the wheel on<font color="#CCCCCC"> the left-hand side</font><font color="#E5E5E5"> that</font>

331
00:14:19,679 --> 00:14:26,459
<font color="#E5E5E5">contains</font><font color="#CCCCCC"> our inputs</font><font color="#E5E5E5"> so from 1 to I from</font>

332
00:14:23,220 --> 00:14:28,649
minus 1<font color="#CCCCCC"> to minus</font><font color="#E5E5E5"> I and the</font><font color="#CCCCCC"> 0 and we map</font>

333
00:14:26,459 --> 00:14:30,929
this wheel to the<font color="#E5E5E5"> wheel on the</font>

334
00:14:28,649 --> 00:14:33,209
<font color="#E5E5E5">right-hand side where the top points are</font>

335
00:14:30,929 --> 00:14:35,819
associated<font color="#CCCCCC"> to plus 1 and the bottom</font>

336
00:14:33,209 --> 00:14:37,829
points are associated<font color="#CCCCCC"> to minus 1 then we</font>

337
00:14:35,819 --> 00:14:39,689
<font color="#CCCCCC">alma morphic li spin this wheel and</font><font color="#E5E5E5"> we</font>

338
00:14:37,829 --> 00:14:41,609
pick the<font color="#CCCCCC"> ciphertext</font><font color="#E5E5E5"> that we end up on</font>

339
00:14:39,689 --> 00:14:46,649
and that<font color="#CCCCCC"> will be an encryption of</font><font color="#E5E5E5"> the</font>

340
00:14:41,610 --> 00:14:49,050
<font color="#E5E5E5">sign of the message along</font><font color="#CCCCCC"> the way we</font>

341
00:14:46,649 --> 00:14:51,600
<font color="#E5E5E5">also</font><font color="#CCCCCC"> introduce some</font><font color="#E5E5E5"> refinements so first</font>

342
00:14:49,050 --> 00:14:54,149
of all<font color="#E5E5E5"> we reduce the bandwidth usage</font>

343
00:14:51,600 --> 00:14:56,610
<font color="#E5E5E5">with the standard packing technique of</font>

344
00:14:54,149 --> 00:14:59,220
encrypting the polynomial<font color="#E5E5E5"> in</font><font color="#CCCCCC"> in instead</font>

345
00:14:56,610 --> 00:15:02,189
<font color="#CCCCCC">of</font><font color="#E5E5E5"> many scalars so instead of encrypting</font>

346
00:14:59,220 --> 00:15:04,860
the pixels one by one<font color="#E5E5E5"> we encrypt the</font>

347
00:15:02,189 --> 00:15:08,429
polynomial<font color="#E5E5E5"> that contains an entire image</font>

348
00:15:04,860 --> 00:15:10,829
<font color="#E5E5E5">so we start with a</font><font color="#CCCCCC"> t lwe encryption</font><font color="#E5E5E5"> of</font>

349
00:15:08,429 --> 00:15:14,629
this polynomial<font color="#E5E5E5"> where p is are the</font>

350
00:15:10,829 --> 00:15:17,459
<font color="#E5E5E5">pixels and we obtain this ciphertext C T</font>

351
00:15:14,629 --> 00:15:19,649
then in the first hidden layer we

352
00:15:17,459 --> 00:15:23,878
prepare this polynomial<font color="#E5E5E5"> W</font><font color="#CCCCCC"> pole which</font>

353
00:15:19,649 --> 00:15:26,429
contains the weights WI times X to the

354
00:15:23,879 --> 00:15:30,749
<font color="#E5E5E5">minus I and now it's easy to see that if</font>

355
00:15:26,429 --> 00:15:32,490
we<font color="#E5E5E5"> multiply C T and W pole</font><font color="#CCCCCC"> the constant</font>

356
00:15:30,749 --> 00:15:34,350
term of<font color="#E5E5E5"> the result will</font><font color="#CCCCCC"> be exactly</font><font color="#E5E5E5"> the</font>

357
00:15:32,490 --> 00:15:39,390
<font color="#E5E5E5">encryption of the</font><font color="#CCCCCC"> multisim</font><font color="#E5E5E5"> that we were</font>

358
00:15:34,350 --> 00:15:40,890
<font color="#CCCCCC">the computer</font><font color="#E5E5E5"> also we can dynamically</font>

359
00:15:39,390 --> 00:15:44,130
change<font color="#CCCCCC"> the message space of our</font>

360
00:15:40,890 --> 00:15:45,930
<font color="#E5E5E5">encryption scheme so we could keep the</font>

361
00:15:44,130 --> 00:15:48,060
message<font color="#CCCCCC"> space</font><font color="#E5E5E5"> constant throughout the</font>

362
00:15:45,930 --> 00:15:50,459
<font color="#E5E5E5">entire</font><font color="#CCCCCC"> evaluation of the neural network</font>

363
00:15:48,060 --> 00:15:52,050
<font color="#E5E5E5">we just take the banner bound on all the</font>

364
00:15:50,460 --> 00:15:54,420
values<font color="#E5E5E5"> that we want</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> support and we</font>

365
00:15:52,050 --> 00:15:57,660
say this<font color="#E5E5E5"> is our well our message space</font>

366
00:15:54,420 --> 00:15:59,550
and it<font color="#E5E5E5"> will not it</font><font color="#CCCCCC"> will not change but a</font>

367
00:15:57,660 --> 00:16:02,280
better<font color="#CCCCCC"> idea is to change the message</font>

368
00:15:59,550 --> 00:16:04,560
<font color="#CCCCCC">space as we go on</font><font color="#E5E5E5"> through the</font><font color="#CCCCCC"> evaluation</font>

369
00:16:02,280 --> 00:16:07,110
of the network<font color="#E5E5E5"> because the intuition</font><font color="#CCCCCC"> is</font>

370
00:16:04,560 --> 00:16:11,160
that<font color="#E5E5E5"> we can take larger slices when we</font>

371
00:16:07,110 --> 00:16:12,870
need less slices<font color="#E5E5E5"> so if we don't need a</font>

372
00:16:11,160 --> 00:16:14,790
<font color="#E5E5E5">very large message space we can take</font>

373
00:16:12,870 --> 00:16:17,220
larger<font color="#CCCCCC"> slices and accommodate for a</font>

374
00:16:14,790 --> 00:16:23,040
larger error and this allows us<font color="#E5E5E5"> to</font><font color="#CCCCCC"> take</font>

375
00:16:17,220 --> 00:16:25,020
<font color="#CCCCCC">a less aggressive</font><font color="#E5E5E5"> parameters</font><font color="#CCCCCC"> how do we</font>

376
00:16:23,040 --> 00:16:26,939
do<font color="#CCCCCC"> this well</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> details are in the</font>

377
00:16:25,020 --> 00:16:29,310
paper but<font color="#CCCCCC"> a quick intuition</font><font color="#E5E5E5"> that I can</font>

378
00:16:26,940 --> 00:16:31,080
give is basically we change what we<font color="#E5E5E5"> put</font>

379
00:16:29,310 --> 00:16:32,729
inside<font color="#E5E5E5"> the wheel</font><font color="#CCCCCC"> so every time</font><font color="#E5E5E5"> we have</font>

380
00:16:31,080 --> 00:16:35,220
<font color="#CCCCCC">to</font><font color="#E5E5E5"> compute a bootstrapping we have to</font>

381
00:16:32,730 --> 00:16:37,860
<font color="#E5E5E5">set</font><font color="#CCCCCC"> up this wheel that I showed you</font>

382
00:16:35,220 --> 00:16:39,690
<font color="#E5E5E5">before and by choosing what</font><font color="#CCCCCC"> we</font><font color="#E5E5E5"> put in</font>

383
00:16:37,860 --> 00:16:42,690
<font color="#E5E5E5">the wheel we</font><font color="#CCCCCC"> can dynamically change the</font>

384
00:16:39,690 --> 00:16:44,850
<font color="#E5E5E5">message</font><font color="#CCCCCC"> space</font><font color="#E5E5E5"> of the encryption scheme</font>

385
00:16:42,690 --> 00:16:46,770
so the bottom line<font color="#CCCCCC"> is that we can start</font>

386
00:16:44,850 --> 00:16:48,540
with<font color="#E5E5E5"> any message space that we want at</font>

387
00:16:46,770 --> 00:16:50,370
encryption time and then change it

388
00:16:48,540 --> 00:16:55,319
dynamically<font color="#E5E5E5"> during the bootstrapping</font>

389
00:16:50,370 --> 00:16:56,910
procedure so let<font color="#E5E5E5"> me show you an</font><font color="#CCCCCC"> overview</font>

390
00:16:55,320 --> 00:16:58,470
of the process<font color="#E5E5E5"> for</font><font color="#CCCCCC"> example let's say</font>

391
00:16:56,910 --> 00:17:00,839
<font color="#CCCCCC">that</font><font color="#E5E5E5"> we want</font><font color="#CCCCCC"> to evaluate the discretized</font>

392
00:16:58,470 --> 00:17:03,240
neural network<font color="#E5E5E5"> with 30 neurons in the</font>

393
00:17:00,840 --> 00:17:06,870
hidden<font color="#CCCCCC"> layers so</font><font color="#E5E5E5"> the user starts from an</font>

394
00:17:03,240 --> 00:17:09,540
encrypt from from an image it<font color="#E5E5E5"> encrypts</font>

395
00:17:06,869 --> 00:17:12,839
it<font color="#E5E5E5"> encrypts it as a polynomial and</font>

396
00:17:09,540 --> 00:17:14,819
obtains<font color="#E5E5E5"> one</font><font color="#CCCCCC"> tlw a ciphertext so here we</font>

397
00:17:12,839 --> 00:17:18,060
are in the<font color="#E5E5E5"> first in the input layer of</font>

398
00:17:14,819 --> 00:17:19,919
the neural<font color="#CCCCCC"> network then sends</font><font color="#E5E5E5"> this over</font>

399
00:17:18,060 --> 00:17:24,480
to the server<font color="#CCCCCC"> the server multiplies</font>

400
00:17:19,920 --> 00:17:26,520
whatever it<font color="#E5E5E5"> receives by this</font><font color="#CCCCCC"> W pole so</font>

401
00:17:24,480 --> 00:17:31,110
the polynomial with the weights<font color="#E5E5E5"> and</font>

402
00:17:26,520 --> 00:17:34,500
obtains<font color="#CCCCCC"> 30 T lwe ciphertext</font><font color="#E5E5E5"> one for</font>

403
00:17:31,110 --> 00:17:37,229
every neuron in<font color="#CCCCCC"> the</font><font color="#E5E5E5"> hidden layer then</font>

404
00:17:34,500 --> 00:17:40,320
extracts the constant term<font color="#E5E5E5"> and obtains</font>

405
00:17:37,230 --> 00:17:44,460
30<font color="#CCCCCC"> L W ciphertext corresponding to the</font>

406
00:17:40,320 --> 00:17:46,679
multi<font color="#E5E5E5"> sums then bootstraps</font><font color="#CCCCCC"> in to the</font>

407
00:17:44,460 --> 00:17:48,090
sign which<font color="#CCCCCC"> means computing homomorphic</font>

408
00:17:46,680 --> 00:17:51,450
<font color="#CCCCCC">LED activation</font><font color="#E5E5E5"> function</font>

409
00:17:48,090 --> 00:17:55,740
obtains<font color="#E5E5E5"> 30</font><font color="#CCCCCC"> lwe ciphertext once again so</font>

410
00:17:51,450 --> 00:17:58,380
one per neuron<font color="#E5E5E5"> compute this weighted sum</font>

411
00:17:55,740 --> 00:18:03,620
here moving towards the output layer

412
00:17:58,380 --> 00:18:06,299
obtains<font color="#CCCCCC"> 10 LW ciphertext 1 per neuron</font>

413
00:18:03,620 --> 00:18:09,330
sends everything<font color="#E5E5E5"> back to the user the</font>

414
00:18:06,299 --> 00:18:11,490
user<font color="#CCCCCC"> decrypt obtains</font><font color="#E5E5E5"> 10 scores which can</font>

415
00:18:09,330 --> 00:18:15,360
be seen as the<font color="#E5E5E5"> probabilities given by</font>

416
00:18:11,490 --> 00:18:18,029
the net from<font color="#CCCCCC"> the network to the</font><font color="#E5E5E5"> digit to</font>

417
00:18:15,360 --> 00:18:20,389
<font color="#CCCCCC">the image basically takes the Arg max</font>

418
00:18:18,029 --> 00:18:22,830
<font color="#E5E5E5">which means selecting the most likely</font>

419
00:18:20,390 --> 00:18:25,049
<font color="#E5E5E5">label according to the network</font><font color="#CCCCCC"> and if</font>

420
00:18:22,830 --> 00:18:28,080
everything<font color="#E5E5E5"> works correctly the user</font>

421
00:18:25,049 --> 00:18:30,299
<font color="#E5E5E5">should recover 7 here so the label</font>

422
00:18:28,080 --> 00:18:34,320
should be corresponding<font color="#CCCCCC"> to</font><font color="#E5E5E5"> the image</font>

423
00:18:30,299 --> 00:18:36,510
that<font color="#CCCCCC"> was</font><font color="#E5E5E5"> sent at</font><font color="#CCCCCC"> the beginning so here</font>

424
00:18:34,320 --> 00:18:40,049
we have some number some numbers so we

425
00:18:36,510 --> 00:18:42,390
<font color="#E5E5E5">implemented the solution</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> we and here</font>

426
00:18:40,049 --> 00:18:44,580
we have some experimental<font color="#CCCCCC"> results so we</font>

427
00:18:42,390 --> 00:18:48,120
can focus for example<font color="#CCCCCC"> on</font><font color="#E5E5E5"> these lines</font><font color="#CCCCCC"> so</font>

428
00:18:44,580 --> 00:18:51,629
on top we have the results on inputs in

429
00:18:48,120 --> 00:18:53,939
the clear so this<font color="#E5E5E5"> is the original neural</font>

430
00:18:51,630 --> 00:18:55,440
network<font color="#CCCCCC"> that we have</font><font color="#E5E5E5"> I would like to</font>

431
00:18:53,940 --> 00:18:57,179
stress<font color="#CCCCCC"> that</font><font color="#E5E5E5"> we did not put too much</font>

432
00:18:55,440 --> 00:18:59,190
effort<font color="#E5E5E5"> into optimizing the machine</font>

433
00:18:57,179 --> 00:19:00,450
<font color="#E5E5E5">learning model we</font><font color="#CCCCCC"> just wanted</font><font color="#E5E5E5"> something</font>

434
00:18:59,190 --> 00:19:02,720
that we<font color="#CCCCCC"> could evaluate or mow more</font>

435
00:19:00,450 --> 00:19:06,330
<font color="#CCCCCC">freakily</font><font color="#E5E5E5"> and see how this framework</font>

436
00:19:02,720 --> 00:19:08,070
<font color="#E5E5E5">performed so we start from a neural</font>

437
00:19:06,330 --> 00:19:10,740
network over the<font color="#CCCCCC"> reals which has this</font>

438
00:19:08,070 --> 00:19:12,510
accuracy<font color="#E5E5E5"> then we discretize</font><font color="#CCCCCC"> it and then</font>

439
00:19:10,740 --> 00:19:15,210
we use the sign as an activation

440
00:19:12,510 --> 00:19:18,929
function<font color="#E5E5E5"> this induces a certain loss</font>

441
00:19:15,210 --> 00:19:20,909
because we lose precision<font color="#E5E5E5"> during the</font>

442
00:19:18,929 --> 00:19:22,559
discretization<font color="#E5E5E5"> and also because we</font>

443
00:19:20,909 --> 00:19:26,070
<font color="#E5E5E5">change the activation function to the</font>

444
00:19:22,559 --> 00:19:27,870
sign so this<font color="#E5E5E5"> is the accuracy</font><font color="#CCCCCC"> that we</font>

445
00:19:26,070 --> 00:19:29,789
have in the clear and when we evaluate

446
00:19:27,870 --> 00:19:32,760
it<font color="#E5E5E5"> on mo morphic</font><font color="#CCCCCC"> Li we have for example</font>

447
00:19:29,789 --> 00:19:35,149
<font color="#CCCCCC">these values these two</font><font color="#E5E5E5"> values correspond</font>

448
00:19:32,760 --> 00:19:38,669
to different implementation

449
00:19:35,149 --> 00:19:40,320
implementations of<font color="#E5E5E5"> the procedures if you</font>

450
00:19:38,669 --> 00:19:43,169
want the<font color="#CCCCCC"> details they are</font><font color="#E5E5E5"> in the papers</font>

451
00:19:40,320 --> 00:19:46,139
<font color="#CCCCCC">basically two ways of implementing the</font>

452
00:19:43,169 --> 00:19:49,679
bootstrapping procedure as we can see

453
00:19:46,140 --> 00:19:51,600
<font color="#E5E5E5">that the accuracy</font><font color="#CCCCCC"> drops</font><font color="#E5E5E5"> a bit this is</font>

454
00:19:49,679 --> 00:19:54,029
<font color="#E5E5E5">because we set aggressive parameters in</font>

455
00:19:51,600 --> 00:19:56,969
order<font color="#CCCCCC"> to</font><font color="#E5E5E5"> gain as much efficiency as we</font>

456
00:19:54,029 --> 00:20:00,190
could<font color="#E5E5E5"> and the problem here is that</font>

457
00:19:56,970 --> 00:20:02,379
sometimes<font color="#CCCCCC"> the bootstrapping</font><font color="#E5E5E5"> might return</font>

458
00:20:00,190 --> 00:20:04,629
wrong result<font color="#CCCCCC"> because of too much noise</font>

459
00:20:02,379 --> 00:20:06,340
<font color="#CCCCCC">the thing here is that neural networks</font>

460
00:20:04,629 --> 00:20:08,668
are supposed to be resilient<font color="#E5E5E5"> to noise</font>

461
00:20:06,340 --> 00:20:11,110
<font color="#CCCCCC">and in fact we verified that</font><font color="#E5E5E5"> even if</font>

462
00:20:08,669 --> 00:20:15,000
<font color="#E5E5E5">sometimes we flip some bits here and</font>

463
00:20:11,110 --> 00:20:17,799
<font color="#E5E5E5">there</font><font color="#CCCCCC"> the results are mostly</font><font color="#E5E5E5"> correct</font>

464
00:20:15,000 --> 00:20:21,519
<font color="#CCCCCC">alright so here</font><font color="#E5E5E5"> we have some more</font>

465
00:20:17,799 --> 00:20:24,039
<font color="#E5E5E5">numbers for our framework so the first</font>

466
00:20:21,519 --> 00:20:26,559
line refers to<font color="#E5E5E5"> discretize neural network</font>

467
00:20:24,039 --> 00:20:29,710
network<font color="#E5E5E5"> with</font><font color="#CCCCCC"> 30 hidden neurons</font><font color="#E5E5E5"> and the</font>

468
00:20:26,559 --> 00:20:31,389
second with 100 in neurons so first of

469
00:20:29,710 --> 00:20:33,879
<font color="#E5E5E5">all the size of the cipher</font><font color="#CCCCCC"> text is very</font>

470
00:20:31,389 --> 00:20:36,668
<font color="#E5E5E5">limited on the</font><font color="#CCCCCC"> 8</font><font color="#E5E5E5"> kilobytes for</font><font color="#CCCCCC"> an entire</font>

471
00:20:33,879 --> 00:20:39,580
image<font color="#E5E5E5"> here we have the accuracies the</font>

472
00:20:36,669 --> 00:20:42,129
encryption time the evaluation<font color="#CCCCCC"> time and</font>

473
00:20:39,580 --> 00:20:44,049
the decryption time and<font color="#E5E5E5"> I would like to</font>

474
00:20:42,129 --> 00:20:47,320
<font color="#E5E5E5">stress</font><font color="#CCCCCC"> that encryption times and</font>

475
00:20:44,049 --> 00:20:48,700
decryption times do not<font color="#E5E5E5"> depend on the</font>

476
00:20:47,320 --> 00:20:50,830
shape<font color="#E5E5E5"> of the network so they are</font>

477
00:20:48,700 --> 00:20:53,080
<font color="#CCCCCC">completely independent of</font><font color="#E5E5E5"> the model that</font>

478
00:20:50,830 --> 00:20:55,689
<font color="#CCCCCC">will be</font><font color="#E5E5E5"> evaluated on the</font><font color="#CCCCCC"> cipher text and</font>

479
00:20:53,080 --> 00:20:59,139
<font color="#E5E5E5">also</font><font color="#CCCCCC"> an important feature of</font><font color="#E5E5E5"> this work</font>

480
00:20:55,690 --> 00:21:01,450
is that<font color="#E5E5E5"> the evaluation</font><font color="#CCCCCC"> time scales</font><font color="#E5E5E5"> only</font>

481
00:20:59,139 --> 00:21:03,219
<font color="#E5E5E5">linearly with the</font><font color="#CCCCCC"> number</font><font color="#E5E5E5"> of neurons so</font>

482
00:21:01,450 --> 00:21:07,509
we don't have to change any of the<font color="#CCCCCC"> other</font>

483
00:21:03,220 --> 00:21:09,340
<font color="#E5E5E5">parameters meaning</font><font color="#CCCCCC"> that it it</font><font color="#E5E5E5"> just</font>

484
00:21:07,509 --> 00:21:14,549
depends linearly on the number<font color="#E5E5E5"> of the</font>

485
00:21:09,340 --> 00:21:18,129
neurons or<font color="#E5E5E5"> the number of the layers yeah</font>

486
00:21:14,549 --> 00:21:19,360
<font color="#E5E5E5">so we have several open problems so</font>

487
00:21:18,129 --> 00:21:22,000
first of all<font color="#CCCCCC"> we</font><font color="#E5E5E5"> would</font><font color="#CCCCCC"> like to build</font>

488
00:21:19,360 --> 00:21:23,529
<font color="#E5E5E5">better discretized neural networks as I</font>

489
00:21:22,000 --> 00:21:26,440
told you we did not<font color="#E5E5E5"> pay too much</font>

490
00:21:23,529 --> 00:21:28,870
attention<font color="#E5E5E5"> into refining the the model we</font>

491
00:21:26,440 --> 00:21:30,370
just<font color="#E5E5E5"> wanted</font><font color="#CCCCCC"> to convert a normal</font><font color="#E5E5E5"> neural</font>

492
00:21:28,870 --> 00:21:33,908
network into a discretized neural

493
00:21:30,370 --> 00:21:35,678
network<font color="#E5E5E5"> and</font><font color="#CCCCCC"> so we basically multiply by</font>

494
00:21:33,909 --> 00:21:38,379
a constant<font color="#CCCCCC"> and remove the decimal</font><font color="#E5E5E5"> part</font>

495
00:21:35,679 --> 00:21:42,100
there might be better ways<font color="#E5E5E5"> of doing this</font>

496
00:21:38,379 --> 00:21:44,709
procedure<font color="#E5E5E5"> and also</font><font color="#CCCCCC"> once we have obtained</font>

497
00:21:42,100 --> 00:21:46,779
a discretized neural network<font color="#CCCCCC"> it might be</font>

498
00:21:44,710 --> 00:21:48,820
<font color="#E5E5E5">possible to retrain so to fine tune the</font>

499
00:21:46,779 --> 00:21:51,190
<font color="#E5E5E5">integer weights that we have found in</font>

500
00:21:48,820 --> 00:21:54,100
order to squeeze<font color="#E5E5E5"> all the accuracy out of</font>

501
00:21:51,190 --> 00:21:55,899
the<font color="#E5E5E5"> model also</font><font color="#CCCCCC"> we</font><font color="#E5E5E5"> would</font><font color="#CCCCCC"> like to</font>

502
00:21:54,100 --> 00:21:58,809
<font color="#E5E5E5">implement everything on GPU because</font>

503
00:21:55,899 --> 00:22:00,580
<font color="#E5E5E5">within a layer all the neurons can</font><font color="#CCCCCC"> be</font>

504
00:21:58,809 --> 00:22:02,769
processed<font color="#CCCCCC"> completely independently of</font>

505
00:22:00,580 --> 00:22:07,379
<font color="#E5E5E5">one another so this is the perfect</font>

506
00:22:02,769 --> 00:22:10,659
<font color="#CCCCCC">scenario for</font><font color="#E5E5E5"> parallel computing</font><font color="#CCCCCC"> and GPUs</font>

507
00:22:07,379 --> 00:22:13,659
and more importantly we<font color="#E5E5E5"> would like to</font>

508
00:22:10,659 --> 00:22:15,160
<font color="#E5E5E5">apply</font><font color="#CCCCCC"> this framework to</font><font color="#E5E5E5"> more model</font>

509
00:22:13,660 --> 00:22:17,140
for example convolutional neural

510
00:22:15,160 --> 00:22:19,780
networks<font color="#E5E5E5"> and two more machine</font><font color="#CCCCCC"> learning</font>

511
00:22:17,140 --> 00:22:23,200
problems<font color="#E5E5E5"> but in order</font><font color="#CCCCCC"> to do this we have</font>

512
00:22:19,780 --> 00:22:25,210
<font color="#CCCCCC">to</font><font color="#E5E5E5"> be able to support more activation</font>

513
00:22:23,200 --> 00:22:27,160
functions<font color="#CCCCCC"> so here we were very limited</font>

514
00:22:25,210 --> 00:22:31,660
<font color="#E5E5E5">by the fact that we can</font><font color="#CCCCCC"> only compute the</font>

515
00:22:27,160 --> 00:22:33,670
sine function<font color="#CCCCCC"> if we are able to compute</font>

516
00:22:31,660 --> 00:22:36,430
<font color="#E5E5E5">or</font><font color="#CCCCCC"> Moberly and</font><font color="#E5E5E5"> efficiently the max</font>

517
00:22:33,670 --> 00:22:38,380
function<font color="#CCCCCC"> or the so-called</font><font color="#E5E5E5"> rectified</font>

518
00:22:36,430 --> 00:22:40,870
linear unit which is a very popular

519
00:22:38,380 --> 00:22:43,390
activation function nowadays<font color="#E5E5E5"> this would</font>

520
00:22:40,870 --> 00:22:47,879
<font color="#CCCCCC">open the way to OMA morphic evaluation</font>

521
00:22:43,390 --> 00:22:50,470
of very complex<font color="#E5E5E5"> deep learning models</font>

522
00:22:47,880 --> 00:22:51,010
<font color="#E5E5E5">okay</font><font color="#CCCCCC"> so this is it thank you</font><font color="#E5E5E5"> for your</font>

523
00:22:50,470 --> 00:22:56,730
attention

524
00:22:51,010 --> 00:22:56,730
[Applause]

