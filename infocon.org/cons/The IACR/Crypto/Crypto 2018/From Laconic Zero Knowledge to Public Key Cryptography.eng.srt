1
00:00:05,060 --> 00:00:09,829
yes<font color="#CCCCCC"> thank</font><font color="#E5E5E5"> you all for</font><font color="#CCCCCC"> coming</font><font color="#E5E5E5"> and today I</font>

2
00:00:08,300 --> 00:00:11,380
<font color="#CCCCCC">will</font><font color="#E5E5E5"> be talking about laconic zero</font>

3
00:00:09,830 --> 00:00:14,389
knowledge<font color="#E5E5E5"> to public key cryptography</font>

4
00:00:11,380 --> 00:00:16,219
<font color="#CCCCCC">this is joint work with ETA</font><font color="#E5E5E5"> Berman Ron</font>

5
00:00:14,389 --> 00:00:19,400
Ratnam and Prashant Malini<font color="#CCCCCC"> what to do</font>

6
00:00:16,219 --> 00:00:21,860
<font color="#E5E5E5">okay so let's get started good</font>

7
00:00:19,400 --> 00:00:24,439
so public<font color="#CCCCCC"> encryption we all love</font><font color="#E5E5E5"> know</font>

8
00:00:21,860 --> 00:00:26,810
and love public encryption<font color="#E5E5E5"> so it allows</font>

9
00:00:24,440 --> 00:00:29,810
<font color="#E5E5E5">two people who have never met</font><font color="#CCCCCC"> each</font><font color="#E5E5E5"> other</font>

10
00:00:26,810 --> 00:00:31,970
to communicate<font color="#CCCCCC"> securely</font><font color="#E5E5E5"> in this case</font>

11
00:00:29,810 --> 00:00:34,610
<font color="#CCCCCC">Alice holds a secret key there's a</font>

12
00:00:31,970 --> 00:00:36,800
public key which is up in<font color="#E5E5E5"> the</font><font color="#CCCCCC"> sky it</font>

13
00:00:34,610 --> 00:00:40,190
allows Bob to send a message encrypted

14
00:00:36,800 --> 00:00:42,980
<font color="#E5E5E5">to Alice such that any eavesdropper Eve</font>

15
00:00:40,190 --> 00:00:45,559
<font color="#E5E5E5">who looks at this conversation</font><font color="#CCCCCC"> cannot</font>

16
00:00:42,980 --> 00:00:47,029
understand<font color="#E5E5E5"> what the messages right so</font>

17
00:00:45,559 --> 00:00:49,459
public key encryption has been<font color="#E5E5E5"> around</font>

18
00:00:47,030 --> 00:00:53,300
for a while<font color="#E5E5E5"> it's extremely useful</font><font color="#CCCCCC"> at the</font>

19
00:00:49,460 --> 00:00:55,249
same time it's quite rare so<font color="#CCCCCC"> we know</font>

20
00:00:53,300 --> 00:00:58,940
public key encryption constructions from

21
00:00:55,249 --> 00:01:02,539
<font color="#E5E5E5">a handful of candidates</font><font color="#CCCCCC"> largely</font><font color="#E5E5E5"> based on</font>

22
00:00:58,940 --> 00:01:05,750
number theory and<font color="#E5E5E5"> on lattices so it's a</font>

23
00:01:02,539 --> 00:01:07,340
very like it's a very important open

24
00:01:05,750 --> 00:01:09,979
question that we want<font color="#E5E5E5"> to consider public</font>

25
00:01:07,340 --> 00:01:13,250
<font color="#CCCCCC">encryption</font><font color="#E5E5E5"> from different kinds of</font>

26
00:01:09,979 --> 00:01:16,759
<font color="#E5E5E5">assumptions and different in the sense</font>

27
00:01:13,250 --> 00:01:18,619
<font color="#E5E5E5">that they look qualitatively different</font>

28
00:01:16,759 --> 00:01:19,880
from<font color="#E5E5E5"> the kind of assumptions we know</font>

29
00:01:18,619 --> 00:01:21,770
today<font color="#E5E5E5"> okay</font>

30
00:01:19,880 --> 00:01:24,259
so in this talk our goal is a bit

31
00:01:21,770 --> 00:01:26,719
different<font color="#CCCCCC"> so we want to understand what</font>

32
00:01:24,259 --> 00:01:28,759
<font color="#E5E5E5">kind of structure or what kind of</font>

33
00:01:26,719 --> 00:01:32,630
complexity theoretic structure implies

34
00:01:28,759 --> 00:01:34,130
public key encryption<font color="#E5E5E5"> so we the goal is</font>

35
00:01:32,630 --> 00:01:35,960
twofold<font color="#CCCCCC"> so first of</font><font color="#E5E5E5"> all we want to</font>

36
00:01:34,130 --> 00:01:37,820
understand why is it<font color="#CCCCCC"> that</font><font color="#E5E5E5"> public key</font>

37
00:01:35,960 --> 00:01:39,408
encryption is so<font color="#CCCCCC"> rare like that so few</font>

38
00:01:37,820 --> 00:01:42,048
<font color="#E5E5E5">assumptions actually give us public</font>

39
00:01:39,409 --> 00:01:44,119
<font color="#CCCCCC">encryption and the hope is that this</font>

40
00:01:42,049 --> 00:01:46,880
kind<font color="#E5E5E5"> of understanding will enable us</font><font color="#CCCCCC"> to</font>

41
00:01:44,119 --> 00:01:49,070
find other assumptions which give us<font color="#E5E5E5"> a</font>

42
00:01:46,880 --> 00:01:54,408
break encryption<font color="#CCCCCC"> okay so what kind</font><font color="#E5E5E5"> of</font>

43
00:01:49,070 --> 00:01:55,969
<font color="#CCCCCC">our</font><font color="#E5E5E5"> answer is</font><font color="#CCCCCC"> I'll be happy</font><font color="#E5E5E5"> with so the</font>

44
00:01:54,409 --> 00:01:58,159
best<font color="#E5E5E5"> possible answer would be to say</font>

45
00:01:55,969 --> 00:02:00,380
<font color="#CCCCCC">that</font><font color="#E5E5E5"> NP hardness implies public</font>

46
00:01:58,159 --> 00:02:02,929
<font color="#CCCCCC">encryption so if P is not equal</font><font color="#E5E5E5"> to NP</font>

47
00:02:00,380 --> 00:02:05,089
<font color="#E5E5E5">then we have public encryption so</font>

48
00:02:02,929 --> 00:02:06,049
unfortunately<font color="#E5E5E5"> if this seems a</font><font color="#CCCCCC"> bit too</font>

49
00:02:05,090 --> 00:02:08,780
much to hope for

50
00:02:06,049 --> 00:02:10,340
today we do we actually<font color="#CCCCCC"> don't know any</font>

51
00:02:08,780 --> 00:02:13,879
<font color="#CCCCCC">category based</font><font color="#E5E5E5"> on this worst-case</font>

52
00:02:10,340 --> 00:02:16,640
assumption also<font color="#CCCCCC"> there</font><font color="#E5E5E5"> are some barriers</font>

53
00:02:13,879 --> 00:02:18,370
known to achieving to constructing

54
00:02:16,640 --> 00:02:22,129
cryptography from these

55
00:02:18,370 --> 00:02:24,200
from np-hardness<font color="#E5E5E5"> alone the next best</font>

56
00:02:22,129 --> 00:02:26,209
<font color="#CCCCCC">thing we could hope for is to</font><font color="#E5E5E5"> say that</font>

57
00:02:24,200 --> 00:02:31,220
if<font color="#CCCCCC"> one-way functions</font><font color="#E5E5E5"> exist then public</font>

58
00:02:26,209 --> 00:02:33,470
encryption also exists and again<font color="#E5E5E5"> it</font>

59
00:02:31,220 --> 00:02:34,880
<font color="#E5E5E5">seems like a fairly difficult problem so</font>

60
00:02:33,470 --> 00:02:37,190
let's look at<font color="#E5E5E5"> something which seems more</font>

61
00:02:34,880 --> 00:02:39,380
reasonable<font color="#CCCCCC"> which is to</font><font color="#E5E5E5"> think of this</font>

62
00:02:37,190 --> 00:02:42,230
class of statistical zero knowledge

63
00:02:39,380 --> 00:02:45,890
problems so<font color="#CCCCCC"> I'll come to what it is in a</font>

64
00:02:42,230 --> 00:02:47,810
<font color="#E5E5E5">minute so there are a</font><font color="#CCCCCC"> few things</font><font color="#E5E5E5"> this</font>

65
00:02:45,890 --> 00:02:49,579
class has going for it<font color="#E5E5E5"> first of all we</font>

66
00:02:47,810 --> 00:02:51,500
don't know<font color="#E5E5E5"> any impossibility results for</font>

67
00:02:49,580 --> 00:02:53,569
<font color="#E5E5E5">this class secondly we know that it</font>

68
00:02:51,500 --> 00:02:56,090
actually<font color="#E5E5E5"> implies</font><font color="#CCCCCC"> one</font><font color="#E5E5E5"> a function so any</font>

69
00:02:53,569 --> 00:02:57,738
language which is in this<font color="#E5E5E5"> class and his</font>

70
00:02:56,090 --> 00:03:00,260
average gets hard<font color="#E5E5E5"> actually</font><font color="#CCCCCC"> in</font><font color="#E5E5E5"> phase</font><font color="#CCCCCC"> one</font>

71
00:02:57,739 --> 00:03:02,239
<font color="#CCCCCC">it functions</font><font color="#E5E5E5"> so that's good</font><font color="#CCCCCC"> and we also</font>

72
00:03:00,260 --> 00:03:03,200
know that the many problems<font color="#E5E5E5"> which imply</font>

73
00:03:02,239 --> 00:03:07,310
public encryption

74
00:03:03,200 --> 00:03:10,670
<font color="#E5E5E5">lie in this class so it looks like</font><font color="#CCCCCC"> a</font>

75
00:03:07,310 --> 00:03:14,690
<font color="#E5E5E5">promising place to look let me remind</font>

76
00:03:10,670 --> 00:03:17,920
you what<font color="#E5E5E5"> the</font><font color="#CCCCCC"> definition of</font><font color="#E5E5E5"> this class so</font>

77
00:03:14,690 --> 00:03:21,560
it was defined<font color="#E5E5E5"> by Sofia Silvio Angela</font>

78
00:03:17,920 --> 00:03:23,420
it's an interactive<font color="#CCCCCC"> piece so there is</font>

79
00:03:21,560 --> 00:03:27,440
approval who is<font color="#E5E5E5"> trying to prove</font><font color="#CCCCCC"> that a</font>

80
00:03:23,420 --> 00:03:29,298
certain instances in the language and it

81
00:03:27,440 --> 00:03:31,310
has the<font color="#CCCCCC"> standard properties which</font><font color="#E5E5E5"> is</font>

82
00:03:29,299 --> 00:03:33,980
that if the instance is actually in the

83
00:03:31,310 --> 00:03:36,560
language<font color="#E5E5E5"> then the prover succeeds in</font>

84
00:03:33,980 --> 00:03:39,220
convincing<font color="#E5E5E5"> the verifier that X is in the</font>

85
00:03:36,560 --> 00:03:44,540
language<font color="#E5E5E5"> if X is not</font><font color="#CCCCCC"> in the</font><font color="#E5E5E5"> language</font>

86
00:03:39,220 --> 00:03:47,660
then cheating<font color="#CCCCCC"> reverse</font><font color="#E5E5E5"> cannot convince a</font>

87
00:03:44,540 --> 00:03:49,429
verifier<font color="#E5E5E5"> that exists in the language so</font>

88
00:03:47,660 --> 00:03:53,350
other verifier<font color="#E5E5E5"> would with high</font>

89
00:03:49,430 --> 00:03:55,910
probability reject this transcript<font color="#E5E5E5"> and</font>

90
00:03:53,350 --> 00:03:58,340
here<font color="#E5E5E5"> this comes soundness comes in two</font>

91
00:03:55,910 --> 00:03:59,810
flavors<font color="#CCCCCC"> so we say that it's a proof if</font>

92
00:03:58,340 --> 00:04:02,150
the<font color="#CCCCCC"> proved arrays</font><font color="#E5E5E5"> are out to be</font>

93
00:03:59,810 --> 00:04:03,950
<font color="#CCCCCC">computationally unbounded</font><font color="#E5E5E5"> well we would</font>

94
00:04:02,150 --> 00:04:05,660
say<font color="#CCCCCC"> that it's an argument if the</font><font color="#E5E5E5"> prover</font>

95
00:04:03,950 --> 00:04:07,250
<font color="#CCCCCC">is only allowed to be</font><font color="#E5E5E5"> efficient so which</font>

96
00:04:05,660 --> 00:04:11,269
<font color="#E5E5E5">means that the prover can in particular</font>

97
00:04:07,250 --> 00:04:13,970
not<font color="#E5E5E5"> be a crypto and zero knowledge so</font>

98
00:04:11,269 --> 00:04:15,370
usually we consider<font color="#CCCCCC"> a notion of zero</font>

99
00:04:13,970 --> 00:04:18,289
knowledge<font color="#E5E5E5"> which is</font><font color="#CCCCCC"> secure against</font>

100
00:04:15,370 --> 00:04:19,940
malicious very fast but in this talk we

101
00:04:18,289 --> 00:04:22,639
<font color="#E5E5E5">would only need honest</font><font color="#CCCCCC"> very fair notion</font>

102
00:04:19,940 --> 00:04:24,229
so let me define<font color="#CCCCCC"> that</font><font color="#E5E5E5"> for you so this is</font>

103
00:04:22,639 --> 00:04:28,729
<font color="#E5E5E5">defined by the famous simulation</font>

104
00:04:24,229 --> 00:04:30,950
paradigm<font color="#CCCCCC"> we say that approval teach we</font>

105
00:04:28,729 --> 00:04:32,630
say that the<font color="#E5E5E5"> verify learns nothing</font><font color="#CCCCCC"> if</font>

106
00:04:30,950 --> 00:04:35,599
if I could have<font color="#E5E5E5"> simulated this</font>

107
00:04:32,630 --> 00:04:38,240
transcript completely by himself<font color="#CCCCCC"> or</font>

108
00:04:35,600 --> 00:04:39,920
herself<font color="#E5E5E5"> informally that there is a</font>

109
00:04:38,240 --> 00:04:41,960
simulator says that the simulator

110
00:04:39,920 --> 00:04:43,970
<font color="#E5E5E5">outputs transcripts which are</font>

111
00:04:41,960 --> 00:04:45,919
statistically<font color="#CCCCCC"> close to transcripts of</font>

112
00:04:43,970 --> 00:04:47,720
the real distribution<font color="#E5E5E5"> so here we</font>

113
00:04:45,920 --> 00:04:49,370
actually<font color="#E5E5E5"> want statistically</font><font color="#CCCCCC"> closed not</font>

114
00:04:47,720 --> 00:04:51,920
computationally<font color="#CCCCCC"> indistinguishable that</font>

115
00:04:49,370 --> 00:04:54,910
<font color="#CCCCCC">these transcripts have</font><font color="#E5E5E5"> a distribution</font>

116
00:04:51,920 --> 00:04:58,190
<font color="#CCCCCC">which is very similar</font><font color="#E5E5E5"> to the</font><font color="#CCCCCC"> actual one</font>

117
00:04:54,910 --> 00:04:59,960
so just<font color="#CCCCCC"> a reminder how big is this class</font>

118
00:04:58,190 --> 00:05:02,120
right<font color="#CCCCCC"> so</font><font color="#E5E5E5"> it's a relatively small class</font>

119
00:04:59,960 --> 00:05:04,190
when compared to<font color="#CCCCCC"> NP</font><font color="#E5E5E5"> it's bigger than P</font>

120
00:05:02,120 --> 00:05:07,040
but<font color="#E5E5E5"> relatively small class interestingly</font>

121
00:05:04,190 --> 00:05:10,190
it can has many<font color="#CCCCCC"> of the problems which</font>

122
00:05:07,040 --> 00:05:12,250
give public<font color="#E5E5E5"> encryption for example lwe</font>

123
00:05:10,190 --> 00:05:16,490
quadratic receive<font color="#CCCCCC"> diversity and so on</font>

124
00:05:12,250 --> 00:05:17,990
right so<font color="#E5E5E5"> can we construct public</font>

125
00:05:16,490 --> 00:05:23,480
<font color="#CCCCCC">encryption from statistical zero</font>

126
00:05:17,990 --> 00:05:27,170
<font color="#CCCCCC">knowledge and it seems challenging one</font>

127
00:05:23,480 --> 00:05:29,030
key reason behind this<font color="#CCCCCC"> is that ack the</font>

128
00:05:27,170 --> 00:05:31,220
class also<font color="#E5E5E5"> has</font><font color="#CCCCCC"> problems like discrete</font>

129
00:05:29,030 --> 00:05:34,130
log which have been<font color="#E5E5E5"> around for a really</font>

130
00:05:31,220 --> 00:05:37,490
long time<font color="#CCCCCC"> and we still don't know public</font>

131
00:05:34,130 --> 00:05:40,400
encryption based on these problems okay

132
00:05:37,490 --> 00:05:44,120
so<font color="#CCCCCC"> can we impose more structure to</font>

133
00:05:40,400 --> 00:05:46,969
<font color="#CCCCCC">actually</font><font color="#E5E5E5"> get something and to that end</font>

134
00:05:44,120 --> 00:05:48,440
let's look at an example<font color="#E5E5E5"> so let's</font>

135
00:05:46,970 --> 00:05:50,960
consider a<font color="#E5E5E5"> quadratic non-linearity our</font>

136
00:05:48,440 --> 00:05:53,570
scheme and let me remind you<font color="#E5E5E5"> at the</font>

137
00:05:50,960 --> 00:05:56,030
problems<font color="#E5E5E5"> so in this problem the instance</font>

138
00:05:53,570 --> 00:05:58,849
consists of number<font color="#E5E5E5"> n which is a product</font>

139
00:05:56,030 --> 00:06:00,500
<font color="#E5E5E5">of two primes</font><font color="#CCCCCC"> and the number</font><font color="#E5E5E5"> Y which we</font>

140
00:05:58,850 --> 00:06:04,220
have to<font color="#E5E5E5"> answer is it a square</font>

141
00:06:00,500 --> 00:06:07,640
I'm not modulating<font color="#CCCCCC"> okay</font><font color="#E5E5E5"> and this has a</font>

142
00:06:04,220 --> 00:06:09,410
very nice<font color="#E5E5E5"> zero knowledge proof what the</font>

143
00:06:07,640 --> 00:06:12,020
<font color="#E5E5E5">verify does is the</font><font color="#CCCCCC"> following that the</font>

144
00:06:09,410 --> 00:06:14,630
verified<font color="#E5E5E5"> pics a square multiplies it by</font>

145
00:06:12,020 --> 00:06:17,060
<font color="#E5E5E5">Y or not and</font><font color="#CCCCCC"> sends it across</font><font color="#E5E5E5"> as the</font>

146
00:06:14,630 --> 00:06:21,230
challenge and what the prover<font color="#CCCCCC"> has to</font>

147
00:06:17,060 --> 00:06:24,560
<font color="#E5E5E5">answer is that is C square or</font><font color="#CCCCCC"> not</font><font color="#E5E5E5"> so if</font>

148
00:06:21,230 --> 00:06:26,180
it was<font color="#E5E5E5"> multiple if the verify actually</font>

149
00:06:24,560 --> 00:06:28,190
<font color="#CCCCCC">multiplied Y to</font><font color="#E5E5E5"> the square then this</font>

150
00:06:26,180 --> 00:06:29,840
<font color="#E5E5E5">would not</font><font color="#CCCCCC"> be a square on the other hand</font>

151
00:06:28,190 --> 00:06:32,180
if the verify did not then<font color="#E5E5E5"> this should</font>

152
00:06:29,840 --> 00:06:34,310
<font color="#CCCCCC">be so the prover replies back an answer</font>

153
00:06:32,180 --> 00:06:38,510
<font color="#E5E5E5">which says is this square or</font><font color="#CCCCCC"> not and</font>

154
00:06:34,310 --> 00:06:40,280
this can be<font color="#E5E5E5"> done efficiently</font><font color="#CCCCCC"> ok so what</font>

155
00:06:38,510 --> 00:06:43,270
<font color="#CCCCCC">are the properties of</font><font color="#E5E5E5"> it so this proof</font>

156
00:06:40,280 --> 00:06:45,520
this proof<font color="#CCCCCC"> system by the way</font><font color="#E5E5E5"> is</font>

157
00:06:43,270 --> 00:06:47,710
very similar to<font color="#CCCCCC"> the goldwasser McCullagh</font>

158
00:06:45,520 --> 00:06:50,500
encryption scheme<font color="#E5E5E5"> so what are the</font>

159
00:06:47,710 --> 00:06:52,870
<font color="#CCCCCC">properties this</font><font color="#E5E5E5"> scheme has so first of</font>

160
00:06:50,500 --> 00:06:55,720
all it's a honest verify statistical

161
00:06:52,870 --> 00:06:58,240
knowledge<font color="#E5E5E5"> the very file actually learns</font>

162
00:06:55,720 --> 00:07:00,640
<font color="#CCCCCC">nothing here because</font><font color="#E5E5E5"> all the verify does</font>

163
00:06:58,240 --> 00:07:02,650
is the verify sends across a number

164
00:07:00,640 --> 00:07:04,479
knowing whether it's a square or not<font color="#E5E5E5"> and</font>

165
00:07:02,650 --> 00:07:07,150
gets<font color="#E5E5E5"> back an answer which is the same</font>

166
00:07:04,480 --> 00:07:09,130
thing<font color="#E5E5E5"> secondly we know that we can</font>

167
00:07:07,150 --> 00:07:11,799
sample<font color="#CCCCCC"> hide instances here so you take</font>

168
00:07:09,130 --> 00:07:15,159
<font color="#E5E5E5">two primes multiply them together and</font>

169
00:07:11,800 --> 00:07:16,780
you get<font color="#E5E5E5"> these instances we know that the</font>

170
00:07:15,160 --> 00:07:18,940
<font color="#CCCCCC">prover is</font><font color="#E5E5E5"> efficient so the prover</font>

171
00:07:16,780 --> 00:07:21,280
haven't given the factorization<font color="#E5E5E5"> of the</font>

172
00:07:18,940 --> 00:07:23,740
integer<font color="#E5E5E5"> n can actually answer this query</font>

173
00:07:21,280 --> 00:07:25,719
<font color="#E5E5E5">sufficiently and finally we know that</font>

174
00:07:23,740 --> 00:07:27,520
<font color="#CCCCCC">the prover talks really</font><font color="#E5E5E5"> little like the</font>

175
00:07:25,720 --> 00:07:31,810
prover is only communicating one bit

176
00:07:27,520 --> 00:07:33,969
<font color="#E5E5E5">which says is it a square or not okay so</font>

177
00:07:31,810 --> 00:07:35,920
in this paper what we show is<font color="#CCCCCC"> that these</font>

178
00:07:33,970 --> 00:07:38,410
four properties<font color="#E5E5E5"> are sufficient that is</font>

179
00:07:35,920 --> 00:07:42,640
if you have a<font color="#CCCCCC"> I seek a proof</font><font color="#E5E5E5"> system</font>

180
00:07:38,410 --> 00:07:46,450
which is an honest verify<font color="#CCCCCC"> ACK proof</font><font color="#E5E5E5"> or</font>

181
00:07:42,640 --> 00:07:48,789
argument<font color="#E5E5E5"> it's such that first of all the</font>

182
00:07:46,450 --> 00:07:49,920
prover<font color="#CCCCCC"> is efficient</font><font color="#E5E5E5"> and secondly the</font>

183
00:07:48,790 --> 00:07:57,280
prover talks

184
00:07:49,920 --> 00:08:00,610
little along with a high language where

185
00:07:57,280 --> 00:08:03,219
you can sample<font color="#CCCCCC"> ok ok so</font><font color="#E5E5E5"> along with</font><font color="#CCCCCC"> a</font>

186
00:08:00,610 --> 00:08:05,110
<font color="#E5E5E5">high language such that it has two</font>

187
00:08:03,220 --> 00:08:07,660
distributions<font color="#E5E5E5"> a yes distribution</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> no</font>

188
00:08:05,110 --> 00:08:09,790
distribution<font color="#E5E5E5"> with samples instances in</font>

189
00:08:07,660 --> 00:08:11,080
the language and not in the language<font color="#E5E5E5"> for</font>

190
00:08:09,790 --> 00:08:12,970
the instances which<font color="#E5E5E5"> are in the language</font>

191
00:08:11,080 --> 00:08:15,969
<font color="#CCCCCC">you sample them with corresponding</font>

192
00:08:12,970 --> 00:08:17,530
witness so we show that if you have<font color="#CCCCCC"> a</font>

193
00:08:15,970 --> 00:08:19,570
language<font color="#E5E5E5"> with both of these properties</font>

194
00:08:17,530 --> 00:08:22,599
<font color="#E5E5E5">then you can actually construct public</font>

195
00:08:19,570 --> 00:08:24,909
key encryption from this so a few points

196
00:08:22,600 --> 00:08:26,800
to<font color="#E5E5E5"> note so first of all honest verify is</font>

197
00:08:24,910 --> 00:08:28,300
actually a weakening of the<font color="#E5E5E5"> notion of</font>

198
00:08:26,800 --> 00:08:29,410
<font color="#CCCCCC">zero now let's so it actually</font><font color="#E5E5E5"> makes a</font>

199
00:08:28,300 --> 00:08:31,360
result stronger that you have to

200
00:08:29,410 --> 00:08:34,330
<font color="#E5E5E5">construct a weaker proof system than a</font>

201
00:08:31,360 --> 00:08:36,159
full-fledged<font color="#CCCCCC"> SEK</font><font color="#E5E5E5"> argument secondly</font>

202
00:08:34,330 --> 00:08:37,960
argument is<font color="#E5E5E5"> also weaker than a proof in</font>

203
00:08:36,159 --> 00:08:40,209
the sense that all you only have to

204
00:08:37,960 --> 00:08:44,980
achieve soundness against

205
00:08:40,210 --> 00:08:46,570
efficient<font color="#E5E5E5"> true words and one point to</font>

206
00:08:44,980 --> 00:08:48,610
notice that cryptographic<font color="#E5E5E5"> lehigh</font>

207
00:08:46,570 --> 00:08:50,200
language like this<font color="#E5E5E5"> motion of hardness is</font>

208
00:08:48,610 --> 00:08:52,600
different<font color="#E5E5E5"> from the usual notion</font><font color="#CCCCCC"> of</font>

209
00:08:50,200 --> 00:08:54,310
average<font color="#E5E5E5"> designers in the usual notion of</font>

210
00:08:52,600 --> 00:08:56,529
average case<font color="#CCCCCC"> highness what you want is</font>

211
00:08:54,310 --> 00:08:58,479
<font color="#CCCCCC">that there is</font><font color="#E5E5E5"> one distribution</font>

212
00:08:56,529 --> 00:09:00,279
<font color="#E5E5E5">samples hide instances you cannot tell</font>

213
00:08:58,480 --> 00:09:02,170
<font color="#E5E5E5">if they're in the language or not</font><font color="#CCCCCC"> so</font>

214
00:09:00,279 --> 00:09:05,110
here we are asking that<font color="#E5E5E5"> these to be</font>

215
00:09:02,170 --> 00:09:06,939
separated<font color="#E5E5E5"> like sample separately and in</font>

216
00:09:05,110 --> 00:09:09,069
particular this notion does imply<font color="#E5E5E5"> one a</font>

217
00:09:06,939 --> 00:09:10,839
function so it should be<font color="#E5E5E5"> hard to come up</font>

218
00:09:09,069 --> 00:09:14,649
<font color="#CCCCCC">with</font><font color="#E5E5E5"> the witness given the instance and</font>

219
00:09:10,839 --> 00:09:16,689
<font color="#E5E5E5">so this implies on</font><font color="#CCCCCC"> the function</font><font color="#E5E5E5"> okay</font><font color="#CCCCCC"> so</font>

220
00:09:14,649 --> 00:09:20,050
what we show is that<font color="#E5E5E5"> these properties</font>

221
00:09:16,689 --> 00:09:22,569
<font color="#CCCCCC">are sufficient</font><font color="#E5E5E5"> to actually construct</font>

222
00:09:20,050 --> 00:09:25,300
public encryption<font color="#E5E5E5"> now what you should</font>

223
00:09:22,569 --> 00:09:27,248
ask yourself is how<font color="#CCCCCC"> reasonable is this</font>

224
00:09:25,300 --> 00:09:29,920
<font color="#E5E5E5">so there are two</font><font color="#CCCCCC"> notions of what we</font>

225
00:09:27,249 --> 00:09:31,930
could mean by<font color="#E5E5E5"> these navels first of all</font>

226
00:09:29,920 --> 00:09:34,529
what<font color="#CCCCCC"> kind</font><font color="#E5E5E5"> of assumptions are actually</font>

227
00:09:31,930 --> 00:09:38,498
captured by this<font color="#E5E5E5"> characterization and</font>

228
00:09:34,529 --> 00:09:39,879
secondly<font color="#CCCCCC"> can you relax these conditions</font>

229
00:09:38,499 --> 00:09:43,079
<font color="#E5E5E5">primarily with the conditions of</font>

230
00:09:39,879 --> 00:09:47,980
efficient proven<font color="#E5E5E5"> and the lopunny</font><font color="#CCCCCC"> proofs</font>

231
00:09:43,079 --> 00:09:49,239
so<font color="#E5E5E5"> I'll come to both of these now</font><font color="#CCCCCC"> okay</font>

232
00:09:47,980 --> 00:09:51,850
so<font color="#E5E5E5"> first of all in terms of</font>

233
00:09:49,240 --> 00:09:53,769
instantiation<font color="#CCCCCC"> so here's an exhaustive</font>

234
00:09:51,850 --> 00:09:58,600
list of assumptions<font color="#E5E5E5"> which I don't imply</font>

235
00:09:53,769 --> 00:10:00,850
public encryption<font color="#CCCCCC"> and so this assumption</font>

236
00:09:58,600 --> 00:10:02,980
captures basically all the decision

237
00:10:00,850 --> 00:10:05,529
<font color="#E5E5E5">variance decision assumptions here it</font>

238
00:10:02,980 --> 00:10:08,860
does<font color="#E5E5E5"> not capture factoring and</font><font color="#CCCCCC"> CDH while</font>

239
00:10:05,529 --> 00:10:10,839
it does capture<font color="#CCCCCC"> Saqr and lwe</font><font color="#E5E5E5"> and the</font>

240
00:10:08,860 --> 00:10:16,000
assumptions which are given<font color="#CCCCCC"> by Appelbaum</font>

241
00:10:10,839 --> 00:10:18,279
<font color="#E5E5E5">Baraka professor</font><font color="#CCCCCC"> and yeah so captures</font>

242
00:10:16,000 --> 00:10:21,309
<font color="#E5E5E5">most of them we don't actually know</font>

243
00:10:18,279 --> 00:10:26,589
<font color="#CCCCCC">zeroes as it approves for a factoring</font>

244
00:10:21,309 --> 00:10:28,629
and<font color="#E5E5E5"> so okay so how about relaxing the</font>

245
00:10:26,589 --> 00:10:30,790
assumptions<font color="#E5E5E5"> right like so there are two</font>

246
00:10:28,629 --> 00:10:32,819
key limitations here the first one is

247
00:10:30,790 --> 00:10:35,110
<font color="#CCCCCC">that the prover has to be efficient and</font>

248
00:10:32,819 --> 00:10:36,969
the second one is that<font color="#CCCCCC"> the proved if</font>

249
00:10:35,110 --> 00:10:39,579
this proof system the prover has to<font color="#E5E5E5"> talk</font>

250
00:10:36,970 --> 00:10:42,100
little<font color="#E5E5E5"> so here we are saying that the</font>

251
00:10:39,579 --> 00:10:44,679
prover can only talk a sub logarithmic

252
00:10:42,100 --> 00:10:47,139
number of bits<font color="#E5E5E5"> so how reasonable are</font>

253
00:10:44,679 --> 00:10:49,509
these assumptions<font color="#E5E5E5"> right so first of all</font>

254
00:10:47,139 --> 00:10:52,269
if we<font color="#E5E5E5"> relax the efficient</font><font color="#CCCCCC"> prove our</font>

255
00:10:49,509 --> 00:10:54,129
assumption we know by<font color="#CCCCCC"> this beautiful</font>

256
00:10:52,269 --> 00:10:54,879
work of<font color="#CCCCCC"> Sahai onward</font><font color="#E5E5E5"> on that it would</font>

257
00:10:54,129 --> 00:10:57,100
imply that

258
00:10:54,879 --> 00:11:00,610
<font color="#CCCCCC">ACK hardness</font><font color="#E5E5E5"> implies public encryption</font>

259
00:10:57,100 --> 00:11:03,059
<font color="#E5E5E5">so this happens because we know</font><font color="#CCCCCC"> that all</font>

260
00:11:00,610 --> 00:11:06,250
of statistical<font color="#E5E5E5"> zero</font><font color="#CCCCCC"> knowledge has a</font>

261
00:11:03,059 --> 00:11:08,019
<font color="#CCCCCC">laconic</font><font color="#E5E5E5"> zero knowledge proof slick</font>

262
00:11:06,250 --> 00:11:09,370
proofs where the prover communicates

263
00:11:08,019 --> 00:11:14,890
only<font color="#E5E5E5"> one bit</font>

264
00:11:09,370 --> 00:11:17,170
and how about relaxing<font color="#E5E5E5"> the laconic</font>

265
00:11:14,890 --> 00:11:18,880
condition<font color="#E5E5E5"> right so first of all if we</font>

266
00:11:17,170 --> 00:11:20,770
<font color="#E5E5E5">can completely relax the</font><font color="#CCCCCC"> laconic</font>

267
00:11:18,880 --> 00:11:23,410
condition and have no restrictions

268
00:11:20,770 --> 00:11:25,360
<font color="#E5E5E5">placed was whatsoever then this actually</font>

269
00:11:23,410 --> 00:11:26,740
implies<font color="#E5E5E5"> one way function</font><font color="#CCCCCC"> public key</font>

270
00:11:25,360 --> 00:11:30,300
encryption from<font color="#CCCCCC"> one-way functions and</font>

271
00:11:26,740 --> 00:11:34,320
this is because all<font color="#CCCCCC"> of MP has these</font>

272
00:11:30,300 --> 00:11:38,920
statistical<font color="#CCCCCC"> zero-knowledge arguments</font><font color="#E5E5E5"> and</font>

273
00:11:34,320 --> 00:11:40,839
<font color="#E5E5E5">which are efficient proven even relaxing</font>

274
00:11:38,920 --> 00:11:45,430
it to<font color="#CCCCCC"> paly dog for a fixed poly dog</font>

275
00:11:40,839 --> 00:11:47,050
would be fantastic<font color="#CCCCCC"> so it would it would</font>

276
00:11:45,430 --> 00:11:49,209
imply that<font color="#E5E5E5"> exponentially hard</font><font color="#CCCCCC"> whenever</font>

277
00:11:47,050 --> 00:11:51,670
functions do imply public encryption<font color="#E5E5E5"> so</font>

278
00:11:49,210 --> 00:11:53,170
today what we know is that exponentially

279
00:11:51,670 --> 00:11:56,920
hard when a<font color="#CCCCCC"> function simply molecule</font>

280
00:11:53,170 --> 00:11:59,349
puzzle style<font color="#E5E5E5"> constructions which have a</font>

281
00:11:56,920 --> 00:12:00,790
security of about<font color="#E5E5E5"> N squared so this will</font>

282
00:11:59,350 --> 00:12:03,010
imply full-fledged public encryption

283
00:12:00,790 --> 00:12:08,469
which is<font color="#E5E5E5"> verified from what is known</font>

284
00:12:03,010 --> 00:12:11,589
<font color="#CCCCCC">today okay</font>

285
00:12:08,470 --> 00:12:13,270
so what we saw<font color="#E5E5E5"> is that these two</font>

286
00:12:11,589 --> 00:12:16,030
conditions<font color="#E5E5E5"> together imply public</font>

287
00:12:13,270 --> 00:12:17,890
<font color="#CCCCCC">encryption it turns out</font><font color="#E5E5E5"> that</font><font color="#CCCCCC"> public key</font>

288
00:12:16,030 --> 00:12:21,100
encryption itself implies a weaker form

289
00:12:17,890 --> 00:12:24,580
of these descriptor system so any public

290
00:12:21,100 --> 00:12:27,400
<font color="#E5E5E5">encryption scheme implies not</font><font color="#CCCCCC"> a</font><font color="#E5E5E5"> language</font>

291
00:12:24,580 --> 00:12:30,610
but<font color="#E5E5E5"> rather a pair of distributions such</font>

292
00:12:27,400 --> 00:12:32,740
that there<font color="#CCCCCC"> is a yes distribution and</font>

293
00:12:30,610 --> 00:12:37,870
<font color="#E5E5E5">known</font><font color="#CCCCCC"> distribution</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> yes distribution</font>

294
00:12:32,740 --> 00:12:39,820
has<font color="#CCCCCC"> Sat comes with</font><font color="#E5E5E5"> witness and also a</font>

295
00:12:37,870 --> 00:12:42,910
zero knowledge proof<font color="#E5E5E5"> system so this</font>

296
00:12:39,820 --> 00:12:45,130
proof system<font color="#E5E5E5"> is not so it's</font><font color="#CCCCCC"> B</font><font color="#E5E5E5"> because</font>

297
00:12:42,910 --> 00:12:46,990
both completeness and soundness here

298
00:12:45,130 --> 00:12:49,390
hold on average so they don't hold<font color="#E5E5E5"> for</font>

299
00:12:46,990 --> 00:12:51,640
<font color="#E5E5E5">every possible instance but they hold on</font>

300
00:12:49,390 --> 00:12:53,560
average for an<font color="#CCCCCC"> instance</font><font color="#E5E5E5"> sample according</font>

301
00:12:51,640 --> 00:12:58,300
to either the yes distribution or the

302
00:12:53,560 --> 00:13:00,160
new distribution<font color="#E5E5E5"> and you can go back so</font>

303
00:12:58,300 --> 00:13:02,260
once you have this assumption<font color="#E5E5E5"> you can</font>

304
00:13:00,160 --> 00:13:04,600
<font color="#E5E5E5">actually this assumption itself implies</font>

305
00:13:02,260 --> 00:13:06,100
<font color="#E5E5E5">public key encryption</font><font color="#CCCCCC"> so this gives you</font>

306
00:13:04,600 --> 00:13:09,040
a characterization<font color="#CCCCCC"> of public key</font>

307
00:13:06,100 --> 00:13:13,900
encryption<font color="#E5E5E5"> in terms of a zero knowledge</font>

308
00:13:09,040 --> 00:13:16,870
proof<font color="#E5E5E5"> system to</font><font color="#CCCCCC"> summarize</font><font color="#E5E5E5"> till now what</font>

309
00:13:13,900 --> 00:13:20,230
<font color="#E5E5E5">we</font><font color="#CCCCCC"> have</font><font color="#E5E5E5"> seen is</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> a laconic efficient</font>

310
00:13:16,870 --> 00:13:22,670
<font color="#CCCCCC">proved honest way</font><font color="#E5E5E5"> forensic arguments</font>

311
00:13:20,230 --> 00:13:24,770
give along with

312
00:13:22,670 --> 00:13:27,860
ability to<font color="#CCCCCC"> sample</font><font color="#E5E5E5"> hide instances gives</font>

313
00:13:24,770 --> 00:13:29,420
us public encryption<font color="#CCCCCC"> okay so in the</font>

314
00:13:27,860 --> 00:13:31,490
remaining time I have<font color="#E5E5E5"> let me talk about</font>

315
00:13:29,420 --> 00:13:38,089
the kind of<font color="#E5E5E5"> techniques which go into</font>

316
00:13:31,490 --> 00:13:40,970
<font color="#E5E5E5">this good so as a</font><font color="#CCCCCC"> warm-up</font><font color="#E5E5E5"> let's start</font>

317
00:13:38,090 --> 00:13:42,800
with<font color="#CCCCCC"> two message</font><font color="#E5E5E5"> deterministic a proof</font>

318
00:13:40,970 --> 00:13:44,810
system<font color="#CCCCCC"> so what this means</font><font color="#E5E5E5"> is</font><font color="#CCCCCC"> that</font>

319
00:13:42,800 --> 00:13:46,699
there's approval and<font color="#CCCCCC"> the verify the</font>

320
00:13:44,810 --> 00:13:49,520
<font color="#E5E5E5">prover the verified is first going to</font>

321
00:13:46,700 --> 00:13:51,110
<font color="#E5E5E5">send a challenge and then the prover</font><font color="#CCCCCC"> is</font>

322
00:13:49,520 --> 00:13:52,819
going to send back<font color="#E5E5E5"> a</font><font color="#CCCCCC"> response</font><font color="#E5E5E5"> at this</font>

323
00:13:51,110 --> 00:13:55,190
point the verify will decide<font color="#E5E5E5"> whether to</font>

324
00:13:52,820 --> 00:13:56,840
accept<font color="#E5E5E5"> or not this response doesn't have</font>

325
00:13:55,190 --> 00:14:01,340
to be a bit like<font color="#E5E5E5"> a B seems to be</font>

326
00:13:56,840 --> 00:14:03,980
confusing but it can be longer<font color="#E5E5E5"> okay so</font>

327
00:14:01,340 --> 00:14:05,810
and since it<font color="#CCCCCC"> has</font><font color="#E5E5E5"> you</font><font color="#CCCCCC"> know knowledge</font>

328
00:14:03,980 --> 00:14:08,720
<font color="#E5E5E5">proof we have a simulator the simulator</font>

329
00:14:05,810 --> 00:14:13,099
is going to output simulated transcripts

330
00:14:08,720 --> 00:14:15,020
which are<font color="#CCCCCC"> denoted by the dashed so as a</font>

331
00:14:13,100 --> 00:14:16,730
simplifying assumption let's assume<font color="#CCCCCC"> that</font>

332
00:14:15,020 --> 00:14:18,050
we have perfect completeness and perfect

333
00:14:16,730 --> 00:14:22,760
zero knowledge<font color="#CCCCCC"> both of these can</font><font color="#E5E5E5"> be</font>

334
00:14:18,050 --> 00:14:24,920
relaxed<font color="#E5E5E5"> okay so just to point out that</font>

335
00:14:22,760 --> 00:14:27,730
this<font color="#E5E5E5"> kind of a proof system is also</font>

336
00:14:24,920 --> 00:14:29,990
known<font color="#E5E5E5"> as a hash</font><font color="#CCCCCC"> boot system</font>

337
00:14:27,730 --> 00:14:33,410
so how do we can step public encryption

338
00:14:29,990 --> 00:14:35,510
<font color="#E5E5E5">from this so let's start by constructing</font>

339
00:14:33,410 --> 00:14:37,730
<font color="#E5E5E5">a weak key agreement protocol and this</font>

340
00:14:35,510 --> 00:14:41,600
can be amplified<font color="#CCCCCC"> to</font><font color="#E5E5E5"> full-fledged of the</font>

341
00:14:37,730 --> 00:14:44,240
key encryption key okay so what Alice

342
00:14:41,600 --> 00:14:46,480
does is that Alice first<font color="#E5E5E5"> samples a yes</font>

343
00:14:44,240 --> 00:14:51,200
instance along with<font color="#E5E5E5"> her</font><font color="#CCCCCC"> witness and she</font>

344
00:14:46,480 --> 00:14:53,320
<font color="#CCCCCC">sends across</font><font color="#E5E5E5"> the instance to Bob both of</font>

345
00:14:51,200 --> 00:14:57,380
both Alice and Bob<font color="#E5E5E5"> want to agree on</font>

346
00:14:53,320 --> 00:14:59,720
something<font color="#CCCCCC"> and at this point what can the</font>

347
00:14:57,380 --> 00:15:02,090
Bob do so Bob<font color="#E5E5E5"> only has the instance Bob</font>

348
00:14:59,720 --> 00:15:04,490
does not have a witness<font color="#E5E5E5"> so Bob can</font>

349
00:15:02,090 --> 00:15:06,260
essentially<font color="#CCCCCC"> run</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> simulator</font><font color="#E5E5E5"> and that's</font>

350
00:15:04,490 --> 00:15:09,380
what Bob<font color="#E5E5E5"> this so Bob runs the simulator</font>

351
00:15:06,260 --> 00:15:11,990
<font color="#CCCCCC">and Bob generates a</font><font color="#E5E5E5"> transcript and from</font>

352
00:15:09,380 --> 00:15:15,439
<font color="#E5E5E5">this transcript sends back the verifiers</font>

353
00:15:11,990 --> 00:15:19,310
<font color="#E5E5E5">challenge backwards and outputs the</font>

354
00:15:15,440 --> 00:15:23,480
<font color="#CCCCCC">provides response</font><font color="#E5E5E5"> as the key bob has</font>

355
00:15:19,310 --> 00:15:25,959
<font color="#E5E5E5">agrea now</font><font color="#CCCCCC"> alice has something which</font><font color="#E5E5E5"> Bob</font>

356
00:15:23,480 --> 00:15:28,880
did not which is<font color="#CCCCCC"> the witness</font><font color="#E5E5E5"> of this</font>

357
00:15:25,960 --> 00:15:31,190
instance<font color="#E5E5E5"> and so Alice uses that to run</font>

358
00:15:28,880 --> 00:15:33,050
the pool<font color="#E5E5E5"> and at this point</font>

359
00:15:31,190 --> 00:15:36,440
<font color="#CCCCCC">Alice outputs the response given</font><font color="#E5E5E5"> by the</font>

360
00:15:33,050 --> 00:15:39,229
<font color="#CCCCCC">pool so</font><font color="#E5E5E5"> base from these two</font>

361
00:15:36,440 --> 00:15:41,260
<font color="#E5E5E5">what you want to show is that first of</font>

362
00:15:39,230 --> 00:15:43,550
all Alice and<font color="#E5E5E5"> Bob actually agree and</font>

363
00:15:41,260 --> 00:15:48,290
second of all we would<font color="#CCCCCC"> like to show that</font>

364
00:15:43,550 --> 00:15:50,689
this<font color="#CCCCCC"> is actually secure good</font><font color="#E5E5E5"> so in terms</font>

365
00:15:48,290 --> 00:15:52,339
of correctness<font color="#CCCCCC"> the first thing to</font>

366
00:15:50,690 --> 00:15:56,630
<font color="#CCCCCC">observe is that because the prover is</font>

367
00:15:52,340 --> 00:15:58,610
deterministic<font color="#CCCCCC"> the verifies challenge</font>

368
00:15:56,630 --> 00:16:01,580
actually fixes the response the approval

369
00:15:58,610 --> 00:16:03,140
<font color="#E5E5E5">is going to give so every very first</font>

370
00:16:01,580 --> 00:16:07,910
challenge has a unique response which

371
00:16:03,140 --> 00:16:09,800
would be<font color="#E5E5E5"> given by</font><font color="#CCCCCC"> the pool</font><font color="#E5E5E5"> secondly we</font>

372
00:16:07,910 --> 00:16:10,490
know that because the zero knowledge<font color="#E5E5E5"> is</font>

373
00:16:09,800 --> 00:16:12,469
<font color="#CCCCCC">perfect</font>

374
00:16:10,490 --> 00:16:14,330
the simulator would also<font color="#CCCCCC"> out be</font>

375
00:16:12,470 --> 00:16:16,760
<font color="#CCCCCC">something from</font><font color="#E5E5E5"> the same distribution has</font>

376
00:16:14,330 --> 00:16:18,500
<font color="#CCCCCC">the original invalid distribution so</font>

377
00:16:16,760 --> 00:16:20,210
this tells us that<font color="#E5E5E5"> the simulator out</font>

378
00:16:18,500 --> 00:16:22,970
would be<font color="#E5E5E5"> prime would</font><font color="#CCCCCC"> be the same as the</font>

379
00:16:20,210 --> 00:16:27,490
<font color="#CCCCCC">original output P okay how about</font>

380
00:16:22,970 --> 00:16:30,400
security<font color="#E5E5E5"> right so we want to show that</font>

381
00:16:27,490 --> 00:16:33,830
the adversary cannot predict<font color="#E5E5E5"> this</font>

382
00:16:30,400 --> 00:16:39,199
message<font color="#E5E5E5"> B</font><font color="#CCCCCC"> prime with probability more</font>

383
00:16:33,830 --> 00:16:40,430
than say<font color="#CCCCCC"> the soundness error and so in</font>

384
00:16:39,200 --> 00:16:42,860
this<font color="#E5E5E5"> case we will show this by</font>

385
00:16:40,430 --> 00:16:45,770
contradiction<font color="#CCCCCC"> we would show that if this</font>

386
00:16:42,860 --> 00:16:47,720
adversary could break<font color="#CCCCCC"> a could actually</font>

387
00:16:45,770 --> 00:16:50,420
predict it with high probability we can

388
00:16:47,720 --> 00:16:51,980
<font color="#CCCCCC">use it</font><font color="#E5E5E5"> to break</font><font color="#CCCCCC"> average-case</font><font color="#E5E5E5"> harness we</font>

389
00:16:50,420 --> 00:16:55,010
would do this by roughly treating the

390
00:16:51,980 --> 00:16:56,720
adversity as a cheating<font color="#CCCCCC"> pool so here is</font>

391
00:16:55,010 --> 00:17:01,490
the distinguisher we would consider so

392
00:16:56,720 --> 00:17:03,290
we have the<font color="#E5E5E5"> verifier the verify and the</font>

393
00:17:01,490 --> 00:17:06,890
adversary taking the role of the pool

394
00:17:03,290 --> 00:17:09,139
<font color="#E5E5E5">and now the verify on input X runs the</font>

395
00:17:06,890 --> 00:17:12,439
<font color="#CCCCCC">event the</font><font color="#E5E5E5"> distinguisher runs the</font>

396
00:17:09,140 --> 00:17:14,360
verifier gets the first message<font color="#E5E5E5"> fitted</font>

397
00:17:12,439 --> 00:17:19,630
to the adversary sees the response<font color="#E5E5E5"> and</font>

398
00:17:14,359 --> 00:17:19,629
see if this<font color="#E5E5E5"> would</font><font color="#CCCCCC"> be accepted or not</font><font color="#E5E5E5"> and</font>

399
00:17:20,050 --> 00:17:25,430
so if X<font color="#E5E5E5"> is actually in the language then</font>

400
00:17:23,300 --> 00:17:27,919
by our<font color="#E5E5E5"> assumption that this adversity is</font>

401
00:17:25,430 --> 00:17:29,750
violating security<font color="#CCCCCC"> this should be</font>

402
00:17:27,920 --> 00:17:32,780
accepted<font color="#E5E5E5"> because the original</font><font color="#CCCCCC"> providers</font>

403
00:17:29,750 --> 00:17:35,540
response was going to be accepted and so

404
00:17:32,780 --> 00:17:37,790
then the distinguisher would<font color="#E5E5E5"> output yes</font>

405
00:17:35,540 --> 00:17:41,030
with probability more than the<font color="#E5E5E5"> service</font>

406
00:17:37,790 --> 00:17:43,790
area<font color="#CCCCCC"> on the other hand for an instance</font>

407
00:17:41,030 --> 00:17:46,520
which is<font color="#E5E5E5"> not in the language by the</font>

408
00:17:43,790 --> 00:17:48,830
property by soundness<font color="#CCCCCC"> you know that it's</font>

409
00:17:46,520 --> 00:17:50,029
going to<font color="#E5E5E5"> be accepted by a probability</font>

410
00:17:48,830 --> 00:17:54,000
<font color="#CCCCCC">which is less</font>

411
00:17:50,029 --> 00:17:56,610
and this gives<font color="#CCCCCC"> us a contradiction</font><font color="#E5E5E5"> so</font>

412
00:17:54,000 --> 00:17:58,789
this is a weak public<font color="#CCCCCC"> 8ve</font><font color="#E5E5E5"> agreement</font>

413
00:17:56,610 --> 00:18:02,100
<font color="#E5E5E5">protocol and this can be amplified</font><font color="#CCCCCC"> to</font>

414
00:17:58,789 --> 00:18:06,240
<font color="#E5E5E5">full-fledged</font><font color="#CCCCCC"> BKE</font><font color="#E5E5E5"> using this work of</font>

415
00:18:02,100 --> 00:18:08,490
Wallenstein<font color="#E5E5E5"> and then</font><font color="#CCCCCC"> i</font><font color="#E5E5E5"> okay so now we</font>

416
00:18:06,240 --> 00:18:10,019
have<font color="#CCCCCC"> made so this</font><font color="#E5E5E5"> was a warmer so we</font>

417
00:18:08,490 --> 00:18:11,549
have made a<font color="#E5E5E5"> couple of simplifying</font>

418
00:18:10,019 --> 00:18:15,390
<font color="#E5E5E5">assumptions here which we would</font><font color="#CCCCCC"> like to</font>

419
00:18:11,549 --> 00:18:17,610
remove and the assumptions<font color="#CCCCCC"> for the</font>

420
00:18:15,390 --> 00:18:19,200
following<font color="#E5E5E5"> dates first of all we assume</font>

421
00:18:17,610 --> 00:18:21,678
that the prover was deterministic<font color="#CCCCCC"> we</font>

422
00:18:19,200 --> 00:18:24,210
would like<font color="#CCCCCC"> to handle randomized spores</font>

423
00:18:21,679 --> 00:18:26,880
second of<font color="#E5E5E5"> all this was a two message</font>

424
00:18:24,210 --> 00:18:29,789
encryption<font color="#E5E5E5"> two message system we would</font>

425
00:18:26,880 --> 00:18:31,769
like<font color="#CCCCCC"> to handle many returns and this</font>

426
00:18:29,789 --> 00:18:33,899
<font color="#CCCCCC">introduces an additional challenge</font><font color="#E5E5E5"> that</font>

427
00:18:31,769 --> 00:18:36,059
in<font color="#E5E5E5"> this case the prover had no state all</font>

428
00:18:33,899 --> 00:18:38,309
I needed to<font color="#E5E5E5"> do and this proven was take</font>

429
00:18:36,059 --> 00:18:40,649
the next message<font color="#E5E5E5"> than the prover you get</font>

430
00:18:38,309 --> 00:18:43,260
something<font color="#E5E5E5"> on the other hand now</font><font color="#CCCCCC"> Tadano</font>

431
00:18:40,649 --> 00:18:45,600
approval which acts for many rounds<font color="#E5E5E5"> this</font>

432
00:18:43,260 --> 00:18:49,559
<font color="#CCCCCC">prove all can keep</font><font color="#E5E5E5"> state and somehow we</font>

433
00:18:45,600 --> 00:18:51,299
need<font color="#CCCCCC"> a way to handle this issue</font><font color="#E5E5E5"> there</font>

434
00:18:49,559 --> 00:18:53,340
are some other<font color="#CCCCCC"> challenges like relaxing</font>

435
00:18:51,299 --> 00:18:57,418
these conditions<font color="#E5E5E5"> that those really</font><font color="#CCCCCC"> good</font>

436
00:18:53,340 --> 00:19:02,879
for now<font color="#CCCCCC"> ok so now</font><font color="#E5E5E5"> let's see how do we</font>

437
00:18:57,419 --> 00:19:06,510
deal with randomized<font color="#E5E5E5"> to</font><font color="#CCCCCC"> voice so this is</font>

438
00:19:02,880 --> 00:19:09,110
<font color="#CCCCCC">the scheme we hire a bit like Alice sent</font>

439
00:19:06,510 --> 00:19:11,610
across the instance<font color="#E5E5E5"> got back</font><font color="#CCCCCC"> verified</font>

440
00:19:09,110 --> 00:19:14,250
<font color="#CCCCCC">verifies challenged as the next message</font>

441
00:19:11,610 --> 00:19:15,840
<font color="#CCCCCC">and both of them output the previous</font>

442
00:19:14,250 --> 00:19:16,500
response as generated in<font color="#E5E5E5"> two different</font>

443
00:19:15,840 --> 00:19:19,199
ways

444
00:19:16,500 --> 00:19:21,149
so what happens<font color="#E5E5E5"> to this so first of all</font>

445
00:19:19,200 --> 00:19:23,490
the<font color="#E5E5E5"> security still is finding nothing in</font>

446
00:19:21,149 --> 00:19:26,100
the proof was affected here but on the

447
00:19:23,490 --> 00:19:28,230
other hand correctness here doesn't

448
00:19:26,100 --> 00:19:30,269
actually go through the reason is the

449
00:19:28,230 --> 00:19:31,740
blue<font color="#CCCCCC"> bar is</font><font color="#E5E5E5"> now randomized so there are</font>

450
00:19:30,269 --> 00:19:33,510
multiple response as this<font color="#E5E5E5"> prove all</font>

451
00:19:31,740 --> 00:19:35,190
could have given and now the<font color="#CCCCCC"> probability</font>

452
00:19:33,510 --> 00:19:40,110
that<font color="#CCCCCC"> both of these responses will be the</font>

453
00:19:35,190 --> 00:19:42,389
same<font color="#CCCCCC"> it's actually no good so the way we</font>

454
00:19:40,110 --> 00:19:43,649
handle these issues<font color="#E5E5E5"> now I realize I</font>

455
00:19:42,389 --> 00:19:45,959
<font color="#E5E5E5">won't have a lot</font><font color="#CCCCCC"> of time to</font><font color="#E5E5E5"> talk about</font>

456
00:19:43,649 --> 00:19:47,789
<font color="#CCCCCC">it the way we handle these issues</font><font color="#E5E5E5"> is we</font>

457
00:19:45,960 --> 00:19:51,389
come up with an abstraction which is a

458
00:19:47,789 --> 00:19:54,720
weaker notion of so here we would relax

459
00:19:51,389 --> 00:19:56,729
<font color="#E5E5E5">the public key encryption notion in two</font>

460
00:19:54,720 --> 00:19:59,159
significant ways<font color="#E5E5E5"> first of all a</font>

461
00:19:56,730 --> 00:20:01,980
<font color="#CCCCCC">ciphertext in this motion is not bound</font>

462
00:19:59,159 --> 00:20:03,270
to a fixed bit<font color="#E5E5E5"> but rather bound to a</font>

463
00:20:01,980 --> 00:20:06,510
distribution of

464
00:20:03,270 --> 00:20:10,200
and secondly the<font color="#CCCCCC"> adversary here</font>

465
00:20:06,510 --> 00:20:12,360
the mess the underlying message<font color="#CCCCCC"> is</font><font color="#E5E5E5"> not</font>

466
00:20:10,200 --> 00:20:15,030
completely hidden<font color="#CCCCCC"> from the adversity but</font>

467
00:20:12,360 --> 00:20:19,290
<font color="#E5E5E5">rather only</font><font color="#CCCCCC"> weakly so</font><font color="#E5E5E5"> okay so I'll</font>

468
00:20:15,030 --> 00:20:22,920
<font color="#E5E5E5">actually keep</font><font color="#CCCCCC"> this yeah I'll actually</font>

469
00:20:19,290 --> 00:20:25,860
<font color="#CCCCCC">skip this</font><font color="#E5E5E5"> good so right so the two the</font>

470
00:20:22,920 --> 00:20:27,270
main differences here I bet the public

471
00:20:25,860 --> 00:20:29,669
<font color="#CCCCCC">cypher</font><font color="#E5E5E5"> text does not actually fix the</font>

472
00:20:27,270 --> 00:20:32,010
<font color="#E5E5E5">message and secondly</font><font color="#CCCCCC"> for an adversary</font>

473
00:20:29,670 --> 00:20:34,140
<font color="#E5E5E5">the adversary</font><font color="#CCCCCC"> has only</font><font color="#E5E5E5"> a weak motion of</font>

474
00:20:32,010 --> 00:20:37,860
unpredictability<font color="#CCCCCC"> that so we</font><font color="#E5E5E5"> formalize</font>

475
00:20:34,140 --> 00:20:39,960
this using pseudo entropy so now there

476
00:20:37,860 --> 00:20:41,280
are<font color="#E5E5E5"> two</font><font color="#CCCCCC"> steps which we have to talk</font>

477
00:20:39,960 --> 00:20:44,130
about<font color="#E5E5E5"> which</font><font color="#CCCCCC"> is how do you</font><font color="#E5E5E5"> go from this</font>

478
00:20:41,280 --> 00:20:45,809
assumption to<font color="#E5E5E5"> from</font><font color="#CCCCCC"> basic a harness to</font>

479
00:20:44,130 --> 00:20:47,400
trapdoor pseudo entropy generators and

480
00:20:45,809 --> 00:20:51,290
secondly from tableau so going<font color="#E5E5E5"> to a</font>

481
00:20:47,400 --> 00:20:51,290
general test of the key encryption<font color="#E5E5E5"> and</font>

482
00:20:52,010 --> 00:20:55,980
actually since I'm running<font color="#E5E5E5"> out of time</font>

483
00:20:54,059 --> 00:20:58,440
<font color="#CCCCCC">I'd</font><font color="#E5E5E5"> not talk a lot about it so</font><font color="#CCCCCC"> first</font><font color="#E5E5E5"> of</font>

484
00:20:55,980 --> 00:21:00,960
all here you<font color="#CCCCCC"> this part basically</font>

485
00:20:58,440 --> 00:21:03,960
abstract us out the<font color="#E5E5E5"> ACK proof system and</font>

486
00:21:00,960 --> 00:21:05,309
you I left with this notion so there are

487
00:21:03,960 --> 00:21:06,360
two challenges<font color="#CCCCCC"> you have to handle</font><font color="#E5E5E5"> the</font>

488
00:21:05,309 --> 00:21:08,700
first challenge<font color="#E5E5E5"> is that you have many</font>

489
00:21:06,360 --> 00:21:10,709
<font color="#CCCCCC">many notes and in this</font><font color="#E5E5E5"> case the way it's</font>

490
00:21:08,700 --> 00:21:12,450
handled is how<font color="#E5E5E5"> Ostrovsky constructs a</font>

491
00:21:10,710 --> 00:21:14,190
one-way function<font color="#CCCCCC"> which is you time in</font>

492
00:21:12,450 --> 00:21:17,700
than the similar time you terminate at a

493
00:21:14,190 --> 00:21:19,710
random round and the<font color="#CCCCCC"> stateful prove our</font>

494
00:21:17,700 --> 00:21:22,260
we cannot handle<font color="#E5E5E5"> completely generically</font>

495
00:21:19,710 --> 00:21:23,880
this does require<font color="#E5E5E5"> that the proof</font><font color="#CCCCCC"> system</font>

496
00:21:22,260 --> 00:21:26,940
is laconic in which case we do some

497
00:21:23,880 --> 00:21:29,880
notion of rejection sampling and the

498
00:21:26,940 --> 00:21:31,470
second half<font color="#E5E5E5"> is an amplification term so</font>

499
00:21:29,880 --> 00:21:34,170
you<font color="#E5E5E5"> have this weak notion of public</font>

500
00:21:31,470 --> 00:21:35,640
encryption<font color="#E5E5E5"> and from here we want to go</font>

501
00:21:34,170 --> 00:21:37,830
<font color="#E5E5E5">to the full Thresh public encryption</font>

502
00:21:35,640 --> 00:21:39,900
<font color="#CCCCCC">scheme this</font><font color="#E5E5E5"> is actually the technically</font>

503
00:21:37,830 --> 00:21:41,490
more difficult half now you what you

504
00:21:39,900 --> 00:21:43,110
have<font color="#E5E5E5"> to do is you have to exploit these</font>

505
00:21:41,490 --> 00:21:45,059
connections which are known between

506
00:21:43,110 --> 00:21:49,309
pseudo randomness and unpredictability

507
00:21:45,059 --> 00:21:51,510
<font color="#E5E5E5">and primarily the constructions of</font>

508
00:21:49,309 --> 00:21:55,950
pseudo-random<font color="#CCCCCC"> generators</font><font color="#E5E5E5"> from one wave</font>

509
00:21:51,510 --> 00:21:59,160
functions<font color="#E5E5E5"> and so</font><font color="#CCCCCC"> okay let</font><font color="#E5E5E5"> me</font><font color="#CCCCCC"> actually</font>

510
00:21:55,950 --> 00:22:00,990
conclude so here we have what we showed

511
00:21:59,160 --> 00:22:03,840
is that laconic efficient<font color="#CCCCCC"> through very</font>

512
00:22:00,990 --> 00:22:06,929
honest<font color="#CCCCCC"> very fair is a key argument imply</font>

513
00:22:03,840 --> 00:22:09,389
public encryption<font color="#CCCCCC"> and</font><font color="#E5E5E5"> a big open</font>

514
00:22:06,929 --> 00:22:12,240
<font color="#CCCCCC">question is can we use this</font><font color="#E5E5E5"> to design</font>

515
00:22:09,390 --> 00:22:14,700
new public encryption<font color="#E5E5E5"> okay with that</font>

516
00:22:12,240 --> 00:22:19,589
<font color="#E5E5E5">I'll take questions</font>

517
00:22:14,700 --> 00:22:19,589
[Applause]

