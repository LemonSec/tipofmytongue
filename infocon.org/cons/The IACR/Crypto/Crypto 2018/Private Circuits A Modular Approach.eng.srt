1
00:00:06,109 --> 00:00:11,930
thanks Daniel so<font color="#E5E5E5"> I'm going to talk about</font>

2
00:00:08,210 --> 00:00:14,269
private<font color="#E5E5E5"> circuits modular approach and</font>

3
00:00:11,930 --> 00:00:19,730
this isn't joint work with yadda<font color="#E5E5E5"> shayana</font>

4
00:00:14,269 --> 00:00:22,009
<font color="#E5E5E5">mensaje so ideally want to protect your</font>

5
00:00:19,730 --> 00:00:25,490
<font color="#E5E5E5">computation against external and</font>

6
00:00:22,010 --> 00:00:27,410
trustworthy entities however<font color="#E5E5E5"> this is not</font>

7
00:00:25,490 --> 00:00:29,630
always<font color="#E5E5E5"> the</font><font color="#CCCCCC"> case</font>

8
00:00:27,410 --> 00:00:31,880
many<font color="#E5E5E5"> studies have shown the</font><font color="#CCCCCC"> existence of</font>

9
00:00:29,630 --> 00:00:34,030
surveillance<font color="#CCCCCC"> attacks</font><font color="#E5E5E5"> where which</font>

10
00:00:31,880 --> 00:00:37,969
actually extract<font color="#E5E5E5"> sensitive information</font>

11
00:00:34,030 --> 00:00:39,980
<font color="#CCCCCC">from various devices this</font><font color="#E5E5E5"> sensitive</font>

12
00:00:37,969 --> 00:00:41,690
<font color="#E5E5E5">information could include things like</font>

13
00:00:39,980 --> 00:00:46,279
your<font color="#E5E5E5"> credit</font><font color="#CCCCCC"> card</font><font color="#E5E5E5"> details as a number and</font>

14
00:00:41,690 --> 00:00:48,620
so on<font color="#E5E5E5"> and this class of attacks in the</font>

15
00:00:46,280 --> 00:00:51,020
<font color="#E5E5E5">literature has</font><font color="#CCCCCC"> been coined as</font>

16
00:00:48,620 --> 00:00:52,579
<font color="#E5E5E5">side-channel attacks</font><font color="#CCCCCC"> there are various</font>

17
00:00:51,020 --> 00:00:55,190
<font color="#E5E5E5">types of side channel attacks to read in</font>

18
00:00:52,579 --> 00:00:56,989
the literature and in<font color="#E5E5E5"> this talk I am</font>

19
00:00:55,190 --> 00:00:58,789
going<font color="#CCCCCC"> to focus on</font><font color="#E5E5E5"> side channel attacks</font>

20
00:00:56,989 --> 00:01:03,500
where the adversary obtains<font color="#CCCCCC"> some partial</font>

21
00:00:58,789 --> 00:01:05,630
<font color="#CCCCCC">information about the computation</font><font color="#E5E5E5"> so</font><font color="#CCCCCC"> how</font>

22
00:01:03,500 --> 00:01:08,000
do we<font color="#E5E5E5"> actually protect our devices</font>

23
00:01:05,630 --> 00:01:09,949
<font color="#E5E5E5">against these side channel attacks this</font>

24
00:01:08,000 --> 00:01:11,840
question is not new there<font color="#E5E5E5"> is an entire</font>

25
00:01:09,950 --> 00:01:15,530
area<font color="#E5E5E5"> on cryptography that studies this</font>

26
00:01:11,840 --> 00:01:16,849
<font color="#E5E5E5">these sort</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> questions and this is this</font>

27
00:01:15,530 --> 00:01:20,090
<font color="#E5E5E5">is the</font><font color="#CCCCCC"> area of leakage resilient</font>

28
00:01:16,849 --> 00:01:21,560
cryptography<font color="#E5E5E5"> so the goal in this area is</font>

29
00:01:20,090 --> 00:01:24,459
<font color="#E5E5E5">to come up with cryptographic schemes</font>

30
00:01:21,560 --> 00:01:27,470
that<font color="#CCCCCC"> resist</font><font color="#E5E5E5"> side-channel attacks</font><font color="#CCCCCC"> and</font>

31
00:01:24,459 --> 00:01:29,840
there are several sort of primitive

32
00:01:27,470 --> 00:01:31,929
studied in this area and in<font color="#E5E5E5"> this talk</font>

33
00:01:29,840 --> 00:01:34,459
I'm going<font color="#E5E5E5"> to focus on one such</font><font color="#CCCCCC"> problem</font>

34
00:01:31,929 --> 00:01:37,220
which is to<font color="#E5E5E5"> design leakage resilient</font>

35
00:01:34,459 --> 00:01:40,340
circuit compilers which was<font color="#E5E5E5"> originally</font>

36
00:01:37,220 --> 00:01:42,830
<font color="#E5E5E5">introduced by Shia</font><font color="#CCCCCC"> high and</font><font color="#E5E5E5"> Wagner</font><font color="#CCCCCC"> so</font>

37
00:01:40,340 --> 00:01:45,369
let<font color="#CCCCCC"> me</font><font color="#E5E5E5"> explain what this</font><font color="#CCCCCC"> is so first let</font>

38
00:01:42,830 --> 00:01:48,319
me explain what<font color="#E5E5E5"> our circuit compilers</font>

39
00:01:45,369 --> 00:01:51,739
circuit compilers allow you to compile a

40
00:01:48,319 --> 00:01:54,440
circuit<font color="#CCCCCC"> C</font><font color="#E5E5E5"> into</font><font color="#CCCCCC"> a compiled circuit C hat</font>

41
00:01:51,739 --> 00:01:55,970
and this<font color="#E5E5E5"> is accompanied with the</font>

42
00:01:54,440 --> 00:01:58,520
<font color="#E5E5E5">corresponding encoding and decoding</font>

43
00:01:55,970 --> 00:02:00,830
algorithms<font color="#E5E5E5"> so the encoding algorithm</font>

44
00:01:58,520 --> 00:02:04,580
allows<font color="#E5E5E5"> you to encode an input X into</font>

45
00:02:00,830 --> 00:02:06,050
encoded input<font color="#E5E5E5"> X hat so the computation</font>

46
00:02:04,580 --> 00:02:08,359
of<font color="#E5E5E5"> C hat on excite essentially</font>

47
00:02:06,050 --> 00:02:12,170
ameliorates the computation of C on X

48
00:02:08,360 --> 00:02:13,520
and<font color="#E5E5E5"> to recover C of X from C hat of X</font>

49
00:02:12,170 --> 00:02:16,640
<font color="#E5E5E5">hat we are going to use the decode</font>

50
00:02:13,520 --> 00:02:18,200
algorithm and<font color="#E5E5E5"> here crucially we use the</font>

51
00:02:16,640 --> 00:02:23,450
fact that the encode algorithm is

52
00:02:18,200 --> 00:02:26,000
<font color="#E5E5E5">justic okay some remarks about this</font>

53
00:02:23,450 --> 00:02:27,890
<font color="#CCCCCC">definition</font><font color="#E5E5E5"> so we</font><font color="#CCCCCC"> are only</font><font color="#E5E5E5"> interested</font><font color="#CCCCCC"> in</font>

54
00:02:26,000 --> 00:02:31,190
the setting when<font color="#CCCCCC"> c and c had</font><font color="#E5E5E5"> contained</font>

55
00:02:27,890 --> 00:02:32,929
<font color="#E5E5E5">and gates and the case when C contains</font>

56
00:02:31,190 --> 00:02:35,540
nine gates is without loss of generality

57
00:02:32,930 --> 00:02:37,209
because<font color="#CCCCCC"> it can convert any boolean basis</font>

58
00:02:35,540 --> 00:02:42,140
into<font color="#E5E5E5"> NAND gates with constant overhead</font>

59
00:02:37,209 --> 00:02:45,080
and<font color="#E5E5E5"> for when C hat</font><font color="#CCCCCC"> when you want to work</font>

60
00:02:42,140 --> 00:02:47,690
with<font color="#E5E5E5"> C hat for other basis then you can</font>

61
00:02:45,080 --> 00:02:50,290
actually<font color="#E5E5E5"> extend our results to this</font>

62
00:02:47,690 --> 00:02:50,290
setting as<font color="#CCCCCC"> well</font>

63
00:02:50,620 --> 00:02:56,450
and we consider<font color="#E5E5E5"> we only consider the</font>

64
00:02:55,040 --> 00:02:58,640
setting when the circuit compilation

65
00:02:56,450 --> 00:03:00,859
algorithm is deterministic<font color="#CCCCCC"> and the</font>

66
00:02:58,640 --> 00:03:03,200
reason<font color="#E5E5E5"> to study this is because we can</font>

67
00:03:00,860 --> 00:03:06,230
<font color="#CCCCCC">use the circuit the compiled circuit in</font>

68
00:03:03,200 --> 00:03:08,690
multiple times and<font color="#CCCCCC"> there are no hidden</font>

69
00:03:06,230 --> 00:03:14,030
<font color="#CCCCCC">trapdoors so modeling adversaries is</font>

70
00:03:08,690 --> 00:03:16,849
also very clean and we allow<font color="#E5E5E5"> C had to</font>

71
00:03:14,030 --> 00:03:19,370
contain random<font color="#E5E5E5"> bit gates so by random</font>

72
00:03:16,849 --> 00:03:21,410
bit gates I mean is<font color="#E5E5E5"> that this is a gate</font>

73
00:03:19,370 --> 00:03:28,280
<font color="#E5E5E5">where if you invoke it you will get a</font>

74
00:03:21,410 --> 00:03:29,840
random<font color="#E5E5E5"> bit okay so now let me explain</font>

75
00:03:28,280 --> 00:03:32,329
<font color="#E5E5E5">what</font><font color="#CCCCCC"> is leakage resilient circuit</font>

76
00:03:29,840 --> 00:03:33,859
compilers<font color="#E5E5E5"> so the security experiment</font>

77
00:03:32,329 --> 00:03:36,590
associated<font color="#E5E5E5"> where this</font><font color="#CCCCCC"> notion is as</font>

78
00:03:33,859 --> 00:03:39,260
follows<font color="#E5E5E5"> so we have this computation C</font>

79
00:03:36,590 --> 00:03:43,370
hat on exact so we have the values

80
00:03:39,260 --> 00:03:45,440
assigned to<font color="#E5E5E5"> these wires so the</font><font color="#CCCCCC"> adversary</font>

81
00:03:43,370 --> 00:03:48,799
is allowed<font color="#CCCCCC"> to submit</font><font color="#E5E5E5"> a leak function and</font>

82
00:03:45,440 --> 00:03:51,500
this leak function operates on all the

83
00:03:48,799 --> 00:03:53,959
wire values in this computation and it

84
00:03:51,500 --> 00:03:58,700
outputs<font color="#E5E5E5"> something that some short</font>

85
00:03:53,959 --> 00:04:01,280
information<font color="#E5E5E5"> and intuitively we want that</font>

86
00:03:58,700 --> 00:04:04,310
<font color="#E5E5E5">the adversary doesn't get any</font>

87
00:04:01,280 --> 00:04:06,889
information<font color="#E5E5E5"> about the</font><font color="#CCCCCC"> input so we don't</font>

88
00:04:04,310 --> 00:04:08,329
care about hiding<font color="#E5E5E5"> the circuit we we</font>

89
00:04:06,889 --> 00:04:10,459
allow the adversary<font color="#E5E5E5"> to know the circuit</font>

90
00:04:08,329 --> 00:04:16,099
<font color="#E5E5E5">but we really want to hide the input</font>

91
00:04:10,459 --> 00:04:17,570
from the adversary okay so now the

92
00:04:16,099 --> 00:04:19,219
question<font color="#CCCCCC"> is what</font><font color="#E5E5E5"> sort of leakage</font>

93
00:04:17,570 --> 00:04:22,789
functions can the<font color="#E5E5E5"> adversary submit to</font>

94
00:04:19,220 --> 00:04:25,099
the submit to the Challenger so there

95
00:04:22,789 --> 00:04:27,260
are two categories you<font color="#E5E5E5"> can consider here</font>

96
00:04:25,099 --> 00:04:29,330
<font color="#E5E5E5">so one is global leakage another one is</font>

97
00:04:27,260 --> 00:04:31,289
local leakage<font color="#CCCCCC"> and the case</font><font color="#E5E5E5"> of global</font>

98
00:04:29,330 --> 00:04:33,568
leakage<font color="#E5E5E5"> the leak is a fun</font>

99
00:04:31,289 --> 00:04:35,369
<font color="#E5E5E5">of the entire</font><font color="#CCCCCC"> computation so for</font>

100
00:04:33,569 --> 00:04:36,839
instance<font color="#CCCCCC"> Lee could potentially compute</font>

101
00:04:35,369 --> 00:04:39,869
parity of all the bits in the

102
00:04:36,839 --> 00:04:41,460
computation<font color="#CCCCCC"> so in locally case the</font>

103
00:04:39,869 --> 00:04:43,649
adversary has<font color="#CCCCCC"> some partial view</font><font color="#E5E5E5"> of the</font>

104
00:04:41,460 --> 00:04:45,089
computation<font color="#E5E5E5"> so you can think of the</font>

105
00:04:43,649 --> 00:04:46,740
computation as divided into blocks<font color="#E5E5E5"> and</font>

106
00:04:45,089 --> 00:04:50,430
<font color="#E5E5E5">maybe he gets some subset of these</font>

107
00:04:46,740 --> 00:04:52,860
blocks<font color="#E5E5E5"> of computation so there are many</font>

108
00:04:50,430 --> 00:04:55,619
works<font color="#E5E5E5"> that study both these categories</font>

109
00:04:52,860 --> 00:04:59,069
<font color="#CCCCCC">so in the case</font><font color="#E5E5E5"> of globally case there</font>

110
00:04:55,619 --> 00:05:01,589
are there are<font color="#CCCCCC"> many works and some of</font>

111
00:04:59,069 --> 00:05:03,479
these works<font color="#E5E5E5"> resist attacks against</font>

112
00:05:01,589 --> 00:05:08,099
leakage functions that are in low

113
00:05:03,479 --> 00:05:10,619
complexity classes for instance<font color="#E5E5E5"> there</font>

114
00:05:08,099 --> 00:05:12,449
are works<font color="#E5E5E5"> that study leakage resilient</font>

115
00:05:10,619 --> 00:05:16,289
circuit<font color="#CCCCCC"> compiler</font><font color="#E5E5E5"> secure against AC</font><font color="#CCCCCC"> 0 and</font>

116
00:05:12,449 --> 00:05:18,629
so on<font color="#E5E5E5"> and the case</font><font color="#CCCCCC"> of local leakage</font>

117
00:05:16,289 --> 00:05:21,330
there are two popular<font color="#E5E5E5"> settings one is</font>

118
00:05:18,629 --> 00:05:23,430
wire probing attacks<font color="#CCCCCC"> and another one is</font>

119
00:05:21,330 --> 00:05:26,849
split<font color="#E5E5E5"> state leakage resilient circuit</font>

120
00:05:23,430 --> 00:05:32,580
compilers<font color="#E5E5E5"> and in this talk I'm going to</font>

121
00:05:26,849 --> 00:05:34,649
focus<font color="#E5E5E5"> on wire probing attacks so what</font>

122
00:05:32,580 --> 00:05:38,490
<font color="#CCCCCC">our wire probing attacks so in this case</font>

123
00:05:34,649 --> 00:05:41,039
<font color="#CCCCCC">leek is just a projection function so</font>

124
00:05:38,490 --> 00:05:45,509
the output of leek is a subset of wire

125
00:05:41,039 --> 00:05:48,389
values in this computation so how is

126
00:05:45,509 --> 00:05:50,399
<font color="#E5E5E5">this subset chosen is this chosen by the</font>

127
00:05:48,389 --> 00:05:52,139
adversary<font color="#E5E5E5"> or is this chosen from some</font>

128
00:05:50,399 --> 00:05:54,240
random process<font color="#E5E5E5"> the answers to these</font>

129
00:05:52,139 --> 00:05:56,879
<font color="#E5E5E5">questions lead to different settings so</font>

130
00:05:54,240 --> 00:06:00,330
<font color="#CCCCCC">let me first focus on</font><font color="#E5E5E5"> the worst-case</font>

131
00:05:56,879 --> 00:06:03,240
setting so in this in this setting<font color="#E5E5E5"> the</font>

132
00:06:00,330 --> 00:06:06,568
adversary specifies a<font color="#E5E5E5"> threshold T and he</font>

133
00:06:03,240 --> 00:06:11,309
is allowed to get<font color="#E5E5E5"> wire any T bar values</font>

134
00:06:06,569 --> 00:06:15,349
in the computation<font color="#E5E5E5"> and there are several</font>

135
00:06:11,309 --> 00:06:18,899
works<font color="#E5E5E5"> that study this this</font><font color="#CCCCCC"> setting</font>

136
00:06:15,349 --> 00:06:20,308
following<font color="#E5E5E5"> is</font><font color="#CCCCCC"> W</font><font color="#E5E5E5"> and in particular many of</font>

137
00:06:18,899 --> 00:06:24,180
<font color="#E5E5E5">these</font><font color="#CCCCCC"> works have been studied by the</font>

138
00:06:20,309 --> 00:06:25,559
<font color="#E5E5E5">just community and you can actually if</font>

139
00:06:24,180 --> 00:06:26,909
you look<font color="#E5E5E5"> at is every one of the</font>

140
00:06:25,559 --> 00:06:29,729
<font color="#E5E5E5">motivations they provide for this</font>

141
00:06:26,909 --> 00:06:33,300
<font color="#CCCCCC">problem is in some sense devising an pc</font>

142
00:06:29,729 --> 00:06:35,729
on silicon it is<font color="#E5E5E5"> you can think of it as</font>

143
00:06:33,300 --> 00:06:37,909
<font color="#E5E5E5">applying MPC techniques to design secure</font>

144
00:06:35,729 --> 00:06:37,909
hardware

145
00:06:40,330 --> 00:06:45,460
<font color="#E5E5E5">okay and in the recent years there is</font>

146
00:06:43,240 --> 00:06:48,129
growing<font color="#E5E5E5"> interest in designing leakage</font>

147
00:06:45,460 --> 00:06:52,090
resilient compilers<font color="#E5E5E5"> with good randomness</font>

148
00:06:48,129 --> 00:06:55,330
complexity so let me define<font color="#CCCCCC"> what</font>

149
00:06:52,090 --> 00:06:56,710
randomness complexity here<font color="#E5E5E5"> means</font><font color="#CCCCCC"> so the</font>

150
00:06:55,330 --> 00:06:58,240
randomness complexity<font color="#CCCCCC"> of a circuit</font>

151
00:06:56,710 --> 00:07:03,219
compiler is nothing but<font color="#E5E5E5"> the number of</font>

152
00:06:58,240 --> 00:07:05,800
<font color="#E5E5E5">random bit gates and a natural question</font>

153
00:07:03,220 --> 00:07:07,930
to<font color="#E5E5E5"> ask here is how many random bit gates</font>

154
00:07:05,800 --> 00:07:10,930
are needed for<font color="#E5E5E5"> a leakage resonant</font>

155
00:07:07,930 --> 00:07:13,840
circuit compiler and this is naturally

156
00:07:10,930 --> 00:07:14,710
<font color="#CCCCCC">motivated because you are in</font><font color="#E5E5E5"> de</font><font color="#CCCCCC"> Menezes</font>

157
00:07:13,840 --> 00:07:16,539
a scarce resource

158
00:07:14,710 --> 00:07:20,739
so you don't want your compiler to have

159
00:07:16,539 --> 00:07:21,159
too many random<font color="#CCCCCC"> bit gates so a few years</font>

160
00:07:20,740 --> 00:07:22,719
<font color="#CCCCCC">back</font>

161
00:07:21,159 --> 00:07:24,639
<font color="#CCCCCC">assha</font><font color="#E5E5E5"> at all studied this</font><font color="#CCCCCC"> problem and</font>

162
00:07:22,719 --> 00:07:28,120
they showed<font color="#CCCCCC"> how they showed a</font><font color="#E5E5E5"> positive</font>

163
00:07:24,639 --> 00:07:30,789
result<font color="#CCCCCC"> which</font><font color="#E5E5E5"> uses just slightly more</font>

164
00:07:28,120 --> 00:07:32,889
than<font color="#E5E5E5"> T cubed random bit gates recall</font>

165
00:07:30,789 --> 00:07:38,199
<font color="#CCCCCC">that T is the threshold</font><font color="#E5E5E5"> associated with</font>

166
00:07:32,889 --> 00:07:41,590
a compiler so natural question to<font color="#E5E5E5"> ask</font>

167
00:07:38,199 --> 00:07:47,409
<font color="#E5E5E5">here</font><font color="#CCCCCC"> is whether T power 3 plus</font><font color="#E5E5E5"> epsilon</font>

168
00:07:41,590 --> 00:07:51,279
<font color="#E5E5E5">is tight and in this work with answered</font>

169
00:07:47,409 --> 00:07:52,599
this question and the answer is no and

170
00:07:51,279 --> 00:07:55,719
in particular we show the following

171
00:07:52,599 --> 00:07:58,270
<font color="#E5E5E5">result</font><font color="#CCCCCC"> there exists leak resilient</font>

172
00:07:55,719 --> 00:08:02,080
circuit compilers for<font color="#CCCCCC"> Si circuits and</font>

173
00:07:58,270 --> 00:08:05,049
threshold<font color="#E5E5E5"> T that resists</font><font color="#CCCCCC"> T wire probing</font>

174
00:08:02,080 --> 00:08:06,789
attacks<font color="#E5E5E5"> the size of the compiled circuit</font>

175
00:08:05,050 --> 00:08:10,120
is s<font color="#E5E5E5"> times polynomial in the circuit a</font>

176
00:08:06,789 --> 00:08:11,590
polynomial in T and finally<font color="#CCCCCC"> the</font>

177
00:08:10,120 --> 00:08:15,870
randomness complexity used in<font color="#E5E5E5"> this</font>

178
00:08:11,590 --> 00:08:15,869
compiler is only<font color="#CCCCCC"> T power</font><font color="#E5E5E5"> 1 plus Epsilon</font>

179
00:08:18,389 --> 00:08:22,930
so this is for<font color="#CCCCCC"> were space probing</font>

180
00:08:21,250 --> 00:08:24,940
attacks<font color="#E5E5E5"> so let me move to a different</font>

181
00:08:22,930 --> 00:08:30,550
<font color="#E5E5E5">setting which</font><font color="#CCCCCC"> is random</font><font color="#E5E5E5"> wired probing</font>

182
00:08:24,940 --> 00:08:32,320
attacks so in this setting<font color="#CCCCCC"> recall that</font>

183
00:08:30,550 --> 00:08:34,630
in the<font color="#CCCCCC"> worst-case</font><font color="#E5E5E5"> setting the adversary</font>

184
00:08:32,320 --> 00:08:37,659
<font color="#E5E5E5">was could choose any T wires in the</font>

185
00:08:34,630 --> 00:08:39,578
circuit<font color="#E5E5E5"> but</font><font color="#CCCCCC"> in this case</font><font color="#E5E5E5"> the adversary</font>

186
00:08:37,659 --> 00:08:44,769
gets every wire value with some

187
00:08:39,578 --> 00:08:47,560
probability<font color="#CCCCCC"> P and in the ideas world we</font>

188
00:08:44,769 --> 00:08:50,680
want we<font color="#CCCCCC"> want to show a simulator</font><font color="#E5E5E5"> that</font>

189
00:08:47,560 --> 00:08:53,189
<font color="#E5E5E5">can simulate this leakage even only the</font>

190
00:08:50,680 --> 00:08:53,189
circuit<font color="#CCCCCC"> see</font>

191
00:08:53,430 --> 00:09:03,089
and we also allow for<font color="#E5E5E5"> a small simulation</font>

192
00:08:56,040 --> 00:09:05,520
<font color="#CCCCCC">error and this model</font><font color="#E5E5E5"> is related to the</font>

193
00:09:03,089 --> 00:09:12,120
noisy leakage model that was studied<font color="#E5E5E5"> in</font>

194
00:09:05,520 --> 00:09:14,610
<font color="#E5E5E5">many prior works okay so let</font><font color="#CCCCCC"> me review</font>

195
00:09:12,120 --> 00:09:18,720
the<font color="#CCCCCC"> the prior works</font><font color="#E5E5E5"> in this in this</font><font color="#CCCCCC"> area</font>

196
00:09:14,610 --> 00:09:21,450
and the regime I<font color="#E5E5E5"> am interested in is is</font>

197
00:09:18,720 --> 00:09:24,120
the case when<font color="#E5E5E5"> P</font><font color="#CCCCCC"> is constant</font><font color="#E5E5E5"> and E is</font>

198
00:09:21,450 --> 00:09:27,420
negligible<font color="#E5E5E5"> when I say negligible</font><font color="#CCCCCC"> its</font>

199
00:09:24,120 --> 00:09:28,980
<font color="#E5E5E5">negligible</font><font color="#CCCCCC"> in the circuit size and there</font>

200
00:09:27,420 --> 00:09:31,560
are two<font color="#E5E5E5"> prominent works in this</font><font color="#CCCCCC"> regime</font>

201
00:09:28,980 --> 00:09:34,230
<font color="#E5E5E5">so the first one is</font><font color="#CCCCCC"> biii</font>

202
00:09:31,560 --> 00:09:36,329
this I showed the first construction and

203
00:09:34,230 --> 00:09:38,370
this regime however<font color="#E5E5E5"> this the</font>

204
00:09:36,330 --> 00:09:40,790
construction<font color="#CCCCCC"> is highly complex</font><font color="#E5E5E5"> at least</font>

205
00:09:38,370 --> 00:09:44,760
I<font color="#E5E5E5"> don't understand the</font><font color="#CCCCCC"> construction well</font>

206
00:09:40,790 --> 00:09:47,339
<font color="#E5E5E5">and following</font><font color="#CCCCCC"> I</font><font color="#E5E5E5"> I there was a work of</font>

207
00:09:44,760 --> 00:09:49,890
<font color="#CCCCCC">ADF which actually among many other</font>

208
00:09:47,339 --> 00:09:53,430
result showed<font color="#E5E5E5"> showed a simplifications</font>

209
00:09:49,890 --> 00:09:55,980
<font color="#E5E5E5">of</font><font color="#CCCCCC"> I test</font><font color="#E5E5E5"> result but this result still</font>

210
00:09:53,430 --> 00:09:59,520
uses some heavy machinery<font color="#CCCCCC"> for</font><font color="#E5E5E5"> instance I</font>

211
00:09:55,980 --> 00:10:01,350
use<font color="#CCCCCC"> AG</font><font color="#E5E5E5"> quotes expanders</font><font color="#CCCCCC"> and so on</font><font color="#E5E5E5"> I have</font>

212
00:09:59,520 --> 00:10:03,240
to point out<font color="#E5E5E5"> that</font><font color="#CCCCCC"> even either cells</font><font color="#E5E5E5"> use</font>

213
00:10:01,350 --> 00:10:09,360
some expander based tools in the

214
00:10:03,240 --> 00:10:11,190
construction so in this work we show us

215
00:10:09,360 --> 00:10:12,930
somewhat simple<font color="#E5E5E5"> construction of leakage</font>

216
00:10:11,190 --> 00:10:17,300
<font color="#CCCCCC">resilient circuit compilers in the same</font>

217
00:10:12,930 --> 00:10:17,300
<font color="#E5E5E5">regime</font><font color="#CCCCCC"> as studied in the prior two works</font>

218
00:10:17,480 --> 00:10:22,500
and now and in fact we can actually show

219
00:10:20,520 --> 00:10:24,300
a concrete constant it<font color="#E5E5E5"> doesn't look that</font>

220
00:10:22,500 --> 00:10:25,830
<font color="#E5E5E5">exciting now but we hope that</font><font color="#CCCCCC"> our</font>

221
00:10:24,300 --> 00:10:31,949
<font color="#E5E5E5">approach can be</font><font color="#CCCCCC"> used to improve</font><font color="#E5E5E5"> this</font>

222
00:10:25,830 --> 00:10:33,839
constant<font color="#E5E5E5"> okay and underlying our result</font>

223
00:10:31,950 --> 00:10:36,029
<font color="#E5E5E5">is a simple</font><font color="#CCCCCC"> composition based approach</font>

224
00:10:33,839 --> 00:10:42,839
that only<font color="#CCCCCC"> uses</font><font color="#E5E5E5"> elementary tools as</font><font color="#CCCCCC"> you</font>

225
00:10:36,029 --> 00:10:43,950
will see soon<font color="#E5E5E5"> okay and as I had</font>

226
00:10:42,839 --> 00:10:45,300
<font color="#CCCCCC">mentioned</font><font color="#E5E5E5"> earlier we were only</font>

227
00:10:43,950 --> 00:10:47,029
interested<font color="#E5E5E5"> in the setting where</font><font color="#CCCCCC"> C</font><font color="#E5E5E5"> had</font>

228
00:10:45,300 --> 00:10:49,620
contains<font color="#CCCCCC"> nine gates but you can actually</font>

229
00:10:47,029 --> 00:10:51,209
replace<font color="#CCCCCC"> a</font><font color="#E5E5E5"> NAND gates with large gates</font>

230
00:10:49,620 --> 00:10:53,670
<font color="#E5E5E5">and in this case you can actually</font>

231
00:10:51,209 --> 00:11:00,989
<font color="#E5E5E5">tolerate probability arbitrary close to</font>

232
00:10:53,670 --> 00:11:03,510
<font color="#CCCCCC">1 okay</font><font color="#E5E5E5"> so we also study another model</font>

233
00:11:00,990 --> 00:11:05,700
<font color="#E5E5E5">called leakage tolerance so leakage in</font>

234
00:11:03,510 --> 00:11:07,020
the<font color="#E5E5E5"> model of leakage tolerance the input</font>

235
00:11:05,700 --> 00:11:11,460
<font color="#E5E5E5">and decoding algorithm</font>

236
00:11:07,020 --> 00:11:12,750
identity functions so the rest of the

237
00:11:11,460 --> 00:11:14,820
talk I will<font color="#E5E5E5"> be</font><font color="#CCCCCC"> mainly focusing on</font>

238
00:11:12,750 --> 00:11:16,380
leakage resilience but I will give the

239
00:11:14,820 --> 00:11:19,050
results we<font color="#CCCCCC"> obtained and the leakage</font>

240
00:11:16,380 --> 00:11:20,520
tolerance model as well<font color="#E5E5E5"> and the reason</font>

241
00:11:19,050 --> 00:11:22,589
<font color="#CCCCCC">why we</font><font color="#E5E5E5"> study leakage tolerance is</font>

242
00:11:20,520 --> 00:11:29,010
because<font color="#CCCCCC"> it says it implies leakage</font>

243
00:11:22,590 --> 00:11:31,050
resilience so the security<font color="#CCCCCC"> in</font><font color="#E5E5E5"> oceans is</font>

244
00:11:29,010 --> 00:11:32,850
slightly<font color="#E5E5E5"> tricky</font><font color="#CCCCCC"> to define compared to</font>

245
00:11:31,050 --> 00:11:34,439
<font color="#CCCCCC">allocated resilience and the reason is</font>

246
00:11:32,850 --> 00:11:36,770
<font color="#CCCCCC">that in this case</font><font color="#E5E5E5"> the adversary</font><font color="#CCCCCC"> gets</font>

247
00:11:34,440 --> 00:11:40,170
some fraction<font color="#CCCCCC"> of</font><font color="#E5E5E5"> the input</font><font color="#CCCCCC"> and</font><font color="#E5E5E5"> output</font>

248
00:11:36,770 --> 00:11:41,819
<font color="#CCCCCC">and so we need</font><font color="#E5E5E5"> to factor this when we</font>

249
00:11:40,170 --> 00:11:46,530
formula is the<font color="#CCCCCC"> definitions for</font><font color="#E5E5E5"> the</font><font color="#CCCCCC"> worst</font>

250
00:11:41,820 --> 00:11:47,580
<font color="#E5E5E5">case and the random probing case so as</font>

251
00:11:46,530 --> 00:11:50,100
<font color="#CCCCCC">before the worst</font><font color="#E5E5E5"> case will be</font>

252
00:11:47,580 --> 00:11:52,020
<font color="#CCCCCC">parameterize by T and we require that</font>

253
00:11:50,100 --> 00:11:57,180
the simulator<font color="#E5E5E5"> can simulate the leakage</font>

254
00:11:52,020 --> 00:11:58,740
even given T bits<font color="#E5E5E5"> of input</font><font color="#CCCCCC"> and output so</font>

255
00:11:57,180 --> 00:12:01,560
correspondingly we<font color="#CCCCCC"> can also define the</font>

256
00:11:58,740 --> 00:12:04,410
<font color="#E5E5E5">probabilistic setting the definition of</font>

257
00:12:01,560 --> 00:12:05,520
<font color="#CCCCCC">the probabilistic setting so here note</font>

258
00:12:04,410 --> 00:12:08,390
<font color="#CCCCCC">that we also</font><font color="#E5E5E5"> have this additional</font>

259
00:12:05,520 --> 00:12:11,130
parameter P Prime and this P Prime

260
00:12:08,390 --> 00:12:16,370
determines the probability<font color="#CCCCCC"> of leakage of</font>

261
00:12:11,130 --> 00:12:19,050
the<font color="#E5E5E5"> input and</font><font color="#CCCCCC"> the output and we</font>

262
00:12:16,370 --> 00:12:22,020
<font color="#CCCCCC">correspondingly obtain similar results</font>

263
00:12:19,050 --> 00:12:23,699
<font color="#E5E5E5">as leakage resilience so we can show a</font>

264
00:12:22,020 --> 00:12:25,980
construction<font color="#CCCCCC"> that has the same</font>

265
00:12:23,700 --> 00:12:27,990
<font color="#E5E5E5">randomness complexity as before</font><font color="#CCCCCC"> in fact</font>

266
00:12:25,980 --> 00:12:30,000
<font color="#E5E5E5">we even can show a lower bound</font><font color="#CCCCCC"> that says</font>

267
00:12:27,990 --> 00:12:32,660
that we require at least<font color="#E5E5E5"> T random</font><font color="#CCCCCC"> bit</font>

268
00:12:30,000 --> 00:12:35,640
<font color="#CCCCCC">gates so so in that sense this is tight</font>

269
00:12:32,660 --> 00:12:37,740
and for the publicity case you can

270
00:12:35,640 --> 00:12:41,370
actually<font color="#E5E5E5"> show upper bounds and lower</font>

271
00:12:37,740 --> 00:12:42,690
bounds<font color="#E5E5E5"> so this P which is the same as</font>

272
00:12:41,370 --> 00:12:45,000
what I had written<font color="#E5E5E5"> earlier so you can</font>

273
00:12:42,690 --> 00:12:47,610
show that<font color="#E5E5E5"> any leakage leakage torrent</font>

274
00:12:45,000 --> 00:12:48,990
compiler can tolerate<font color="#E5E5E5"> there exists like</font>

275
00:12:47,610 --> 00:12:50,880
<font color="#CCCCCC">it's</font><font color="#E5E5E5"> alternate compiler that can</font>

276
00:12:48,990 --> 00:12:53,190
tolerate<font color="#E5E5E5"> any probability that is less</font>

277
00:12:50,880 --> 00:12:55,790
than<font color="#CCCCCC"> this and correspondingly we can</font>

278
00:12:53,190 --> 00:12:58,110
<font color="#E5E5E5">also show that if you want to tolerate</font>

279
00:12:55,790 --> 00:12:59,670
<font color="#E5E5E5">probability</font><font color="#CCCCCC"> greater than point 8 then</font>

280
00:12:58,110 --> 00:13:05,490
there does not exist any leakage

281
00:12:59,670 --> 00:13:09,150
<font color="#CCCCCC">tolerant compiler okay so let me</font><font color="#E5E5E5"> explain</font>

282
00:13:05,490 --> 00:13:12,420
the techniques used in this in this<font color="#E5E5E5"> in</font>

283
00:13:09,150 --> 00:13:14,459
this work so the goal<font color="#CCCCCC"> for this talk</font>

284
00:13:12,420 --> 00:13:16,910
would<font color="#CCCCCC"> be</font><font color="#E5E5E5"> to just stick to leak is</font>

285
00:13:14,460 --> 00:13:19,890
resilient circuit compiler tolerating

286
00:13:16,910 --> 00:13:20,110
random probing attacks<font color="#CCCCCC"> okay so this is</font>

287
00:13:19,890 --> 00:13:22,060
what

288
00:13:20,110 --> 00:13:25,810
<font color="#E5E5E5">I'm going to deal with</font><font color="#CCCCCC"> for the</font><font color="#E5E5E5"> rest of</font>

289
00:13:22,060 --> 00:13:27,819
<font color="#E5E5E5">the talk</font><font color="#CCCCCC"> and the starting point</font><font color="#E5E5E5"> to</font>

290
00:13:25,810 --> 00:13:30,969
constructing this is<font color="#CCCCCC"> tea or turf and</font>

291
00:13:27,820 --> 00:13:33,279
secure<font color="#E5E5E5"> NPC protocol by this I mean this</font>

292
00:13:30,970 --> 00:13:36,640
NPC protocol tolerates<font color="#CCCCCC"> T adversaries and</font>

293
00:13:33,279 --> 00:13:38,500
<font color="#E5E5E5">n is</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> number of parties so I'm going</font>

294
00:13:36,640 --> 00:13:40,329
<font color="#E5E5E5">to view this NPC protocol slightly</font>

295
00:13:38,500 --> 00:13:41,860
differently<font color="#CCCCCC"> instead of viewing this as a</font>

296
00:13:40,329 --> 00:13:45,099
protocol<font color="#E5E5E5"> I'm going to view this as a</font>

297
00:13:41,860 --> 00:13:48,490
<font color="#E5E5E5">compiled circuit so</font><font color="#CCCCCC"> NPC protocol of a</font>

298
00:13:45,100 --> 00:13:51,940
circuit<font color="#E5E5E5"> C will be viewed as compiled</font>

299
00:13:48,490 --> 00:13:54,790
circuit C hat so the party<font color="#E5E5E5"> p2 will be</font>

300
00:13:51,940 --> 00:13:57,339
viewed as a block<font color="#E5E5E5"> of gates</font><font color="#CCCCCC"> in this</font>

301
00:13:54,790 --> 00:13:58,899
compiled circuit and similarly the

302
00:13:57,339 --> 00:14:00,940
communication channels between<font color="#E5E5E5"> the</font>

303
00:13:58,899 --> 00:14:05,050
parties will be<font color="#E5E5E5"> viewed as the wires</font>

304
00:14:00,940 --> 00:14:07,019
between these<font color="#CCCCCC"> different blocks</font><font color="#E5E5E5"> here</font><font color="#CCCCCC"> it's</font>

305
00:14:05,050 --> 00:14:10,329
<font color="#CCCCCC">just a</font><font color="#E5E5E5"> different way of viewing game pc</font>

306
00:14:07,019 --> 00:14:13,329
you can correspondingly also define an

307
00:14:10,329 --> 00:14:15,569
intuitive security notion so a party

308
00:14:13,329 --> 00:14:19,479
<font color="#E5E5E5">being corrupted here corresponds to</font>

309
00:14:15,570 --> 00:14:25,570
leaking<font color="#E5E5E5"> the entire block of p2 in this</font>

310
00:14:19,480 --> 00:14:27,160
case just this<font color="#E5E5E5"> viewpoint leads us to the</font>

311
00:14:25,570 --> 00:14:30,730
first candidate of leakage resident

312
00:14:27,160 --> 00:14:32,920
circuit compiler<font color="#E5E5E5"> so you can think</font><font color="#CCCCCC"> of the</font>

313
00:14:30,730 --> 00:14:35,310
compiled circuit C hat as just being an

314
00:14:32,920 --> 00:14:38,110
MPC protocol for C<font color="#E5E5E5"> Prime</font>

315
00:14:35,310 --> 00:14:42,399
so what is C<font color="#CCCCCC"> prime it takes as input</font>

316
00:14:38,110 --> 00:14:47,199
shares of<font color="#E5E5E5"> X reconstructs compute C of X</font>

317
00:14:42,399 --> 00:14:49,510
and then share C of X<font color="#E5E5E5"> that's it so this</font>

318
00:14:47,199 --> 00:14:54,880
<font color="#E5E5E5">is the this</font><font color="#CCCCCC"> is a candidate the cases</font><font color="#E5E5E5"> are</font>

319
00:14:49,510 --> 00:14:56,920
in circuit compiler<font color="#CCCCCC"> ok ok</font><font color="#E5E5E5"> so and what</font><font color="#CCCCCC"> is</font>

320
00:14:54,880 --> 00:14:58,990
the<font color="#E5E5E5"> encoding</font><font color="#CCCCCC"> or decoding is the</font><font color="#E5E5E5"> trivial</font>

321
00:14:56,920 --> 00:15:00,550
of algorithms the encoding those secret

322
00:14:58,990 --> 00:15:06,339
shares the input<font color="#E5E5E5"> and the</font><font color="#CCCCCC"> decoding</font>

323
00:15:00,550 --> 00:15:11,109
reconstructs<font color="#CCCCCC"> the output okay so why is</font>

324
00:15:06,339 --> 00:15:12,880
<font color="#E5E5E5">this secure so note that</font><font color="#CCCCCC"> if at most T</font>

325
00:15:11,110 --> 00:15:15,220
wires are leaked in<font color="#CCCCCC"> the circuit then</font><font color="#E5E5E5"> the</font>

326
00:15:12,880 --> 00:15:19,000
leakage can be<font color="#CCCCCC"> simulated and why is this</font>

327
00:15:15,220 --> 00:15:21,490
<font color="#E5E5E5">the case because any</font><font color="#CCCCCC"> T wires being</font>

328
00:15:19,000 --> 00:15:23,110
leaked<font color="#E5E5E5"> is the same as any tea party is</font>

329
00:15:21,490 --> 00:15:25,750
<font color="#E5E5E5">being corrupted in the corresponding MPC</font>

330
00:15:23,110 --> 00:15:27,760
protocol and the MPC protocol guarantees

331
00:15:25,750 --> 00:15:32,110
that<font color="#E5E5E5"> as long as at most</font><font color="#CCCCCC"> tea parties are</font>

332
00:15:27,760 --> 00:15:33,990
<font color="#E5E5E5">corrupted things are secure this is the</font>

333
00:15:32,110 --> 00:15:37,329
intuition

334
00:15:33,990 --> 00:15:38,980
so now we<font color="#E5E5E5"> need to calculate what</font><font color="#CCCCCC"> is the</font>

335
00:15:37,329 --> 00:15:42,010
<font color="#E5E5E5">probability that more than T words are</font>

336
00:15:38,980 --> 00:15:43,990
<font color="#E5E5E5">leaked right and once more than T</font><font color="#CCCCCC"> words</font>

337
00:15:42,010 --> 00:15:45,700
<font color="#CCCCCC">oblique then then we</font><font color="#E5E5E5"> can't do anything</font>

338
00:15:43,990 --> 00:15:48,370
<font color="#E5E5E5">this is this is why we need to</font>

339
00:15:45,700 --> 00:15:51,880
<font color="#E5E5E5">incorporate this as a simulation error E</font>

340
00:15:48,370 --> 00:15:53,649
and by a simple<font color="#E5E5E5"> turn</font><font color="#CCCCCC"> of calculation you</font>

341
00:15:51,880 --> 00:15:57,670
can<font color="#CCCCCC"> actually show that the simulation</font>

342
00:15:53,649 --> 00:16:00,040
error E is upper bounded by<font color="#CCCCCC"> this much</font><font color="#E5E5E5"> so</font>

343
00:15:57,670 --> 00:16:01,719
this<font color="#E5E5E5"> looks</font><font color="#CCCCCC"> complicated so we'll just</font>

344
00:16:00,040 --> 00:16:04,120
stick to the setting where these things

345
00:16:01,720 --> 00:16:05,470
<font color="#E5E5E5">are constant we C and T are constants in</font>

346
00:16:04,120 --> 00:16:11,350
this case the error will also be

347
00:16:05,470 --> 00:16:13,959
constant this<font color="#E5E5E5"> is great but we</font><font color="#CCCCCC"> really</font>

348
00:16:11,350 --> 00:16:16,779
<font color="#CCCCCC">don't want leakage resonant</font><font color="#E5E5E5"> circuit</font>

349
00:16:13,959 --> 00:16:19,599
compiler<font color="#CCCCCC"> that only tolerates constant</font>

350
00:16:16,779 --> 00:16:23,320
simulation error<font color="#E5E5E5"> right so how do we go</font>

351
00:16:19,600 --> 00:16:25,000
from constant to a<font color="#E5E5E5"> negligible so to do</font>

352
00:16:23,320 --> 00:16:27,910
this we are going<font color="#CCCCCC"> to</font><font color="#E5E5E5"> start with a base</font>

353
00:16:25,000 --> 00:16:29,680
gadget so what is the space gadget<font color="#E5E5E5"> it's</font>

354
00:16:27,910 --> 00:16:32,620
another name<font color="#E5E5E5"> for a leak is a NAND</font>

355
00:16:29,680 --> 00:16:34,719
circuit compiler<font color="#E5E5E5"> that has that's</font>

356
00:16:32,620 --> 00:16:38,410
<font color="#E5E5E5">associated with constant probability P</font>

357
00:16:34,720 --> 00:16:40,390
and<font color="#E5E5E5"> constant error easier note</font><font color="#CCCCCC"> that in</font>

358
00:16:38,410 --> 00:16:44,500
the previous<font color="#E5E5E5"> slide</font><font color="#CCCCCC"> we just</font><font color="#E5E5E5"> constructed</font>

359
00:16:40,390 --> 00:16:47,079
<font color="#E5E5E5">such a base catcher so we are going to</font>

360
00:16:44,500 --> 00:16:52,269
use this base catcher to achieve our

361
00:16:47,079 --> 00:16:54,519
result<font color="#CCCCCC"> okay so how do you reduce the</font>

362
00:16:52,269 --> 00:16:56,860
error so the idea is as follows<font color="#CCCCCC"> again</font>

363
00:16:54,519 --> 00:17:01,120
start with<font color="#CCCCCC"> the T out of n secure NPC</font>

364
00:16:56,860 --> 00:17:04,780
protocol and now<font color="#E5E5E5"> replace every gate in</font>

365
00:17:01,120 --> 00:17:06,490
this protocol<font color="#E5E5E5"> with a base gadget</font><font color="#CCCCCC"> okay so</font>

366
00:17:04,780 --> 00:17:11,020
we have a NAND gate here replace this

367
00:17:06,490 --> 00:17:13,150
with a base catcher and somehow<font color="#E5E5E5"> we</font>

368
00:17:11,020 --> 00:17:17,040
stitch<font color="#E5E5E5"> all the</font><font color="#CCCCCC"> gadgets that are</font>

369
00:17:13,150 --> 00:17:17,040
associated<font color="#E5E5E5"> with these different gates</font>

370
00:17:17,250 --> 00:17:24,910
and whatever you get here<font color="#E5E5E5"> will be the</font>

371
00:17:21,010 --> 00:17:31,750
next<font color="#E5E5E5"> gadget and I'm going</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> call this</font>

372
00:17:24,910 --> 00:17:35,049
gadget<font color="#CCCCCC"> resulting gadget as d1 so now why</font>

373
00:17:31,750 --> 00:17:37,690
is the resulting circuit compiler secure

374
00:17:35,049 --> 00:17:39,940
<font color="#E5E5E5">and the reason is that as</font><font color="#CCCCCC"> long as at</font>

375
00:17:37,690 --> 00:17:43,990
<font color="#E5E5E5">most</font><font color="#CCCCCC"> T based gadgets fail then</font><font color="#E5E5E5"> you can</font>

376
00:17:39,940 --> 00:17:46,090
simulate the leakage and the reason is

377
00:17:43,990 --> 00:17:46,840
the same as<font color="#CCCCCC"> before</font><font color="#E5E5E5"> as long as at most</font><font color="#CCCCCC"> T</font>

378
00:17:46,090 --> 00:17:49,299
<font color="#CCCCCC">bear sketch</font>

379
00:17:46,840 --> 00:17:51,639
that is that<font color="#E5E5E5"> corresponds to corrupting</font>

380
00:17:49,299 --> 00:17:53,529
<font color="#CCCCCC">at masti parties in the MPC protocol and</font>

381
00:17:51,639 --> 00:18:00,399
then<font color="#E5E5E5"> you can then it can successfully</font>

382
00:17:53,529 --> 00:18:01,720
simulate so now again we<font color="#CCCCCC"> need to</font>

383
00:18:00,399 --> 00:18:03,699
calculate what<font color="#CCCCCC"> is the simulation error</font>

384
00:18:01,720 --> 00:18:04,570
in<font color="#E5E5E5"> this setting so</font><font color="#CCCCCC"> in order</font><font color="#E5E5E5"> to do that</font>

385
00:18:03,700 --> 00:18:05,980
we need to<font color="#E5E5E5"> curve it what is the</font>

386
00:18:04,570 --> 00:18:08,678
probability<font color="#CCCCCC"> that more than</font><font color="#E5E5E5"> T</font><font color="#CCCCCC"> base</font>

387
00:18:05,980 --> 00:18:11,110
<font color="#CCCCCC">gadgets fail</font><font color="#E5E5E5"> and the expressions are the</font>

388
00:18:08,679 --> 00:18:13,360
<font color="#CCCCCC">same as before</font><font color="#E5E5E5"> except</font><font color="#CCCCCC"> that you replace p</font>

389
00:18:11,110 --> 00:18:18,399
with<font color="#E5E5E5"> easy row here and you see</font><font color="#CCCCCC"> row got</font>

390
00:18:13,360 --> 00:18:19,990
<font color="#E5E5E5">replaced with</font><font color="#CCCCCC"> t1 here and by suitably</font>

391
00:18:18,399 --> 00:18:22,570
setting the parameters you can<font color="#E5E5E5"> show</font><font color="#CCCCCC"> that</font>

392
00:18:19,990 --> 00:18:27,460
<font color="#CCCCCC">a1 is</font><font color="#E5E5E5"> actually smaller than e0 so you</font>

393
00:18:22,570 --> 00:18:29,740
have<font color="#CCCCCC"> achieved some progress</font><font color="#E5E5E5"> okay</font>

394
00:18:27,460 --> 00:18:31,690
so now we showed<font color="#CCCCCC"> that the error reduces</font>

395
00:18:29,740 --> 00:18:33,909
but we should also<font color="#E5E5E5"> be mindful of how the</font>

396
00:18:31,690 --> 00:18:36,460
size of the resulting<font color="#CCCCCC"> compiler increases</font>

397
00:18:33,909 --> 00:18:38,830
and in fact<font color="#CCCCCC"> again</font><font color="#E5E5E5"> this is easy to</font>

398
00:18:36,460 --> 00:18:40,809
observe the size of the final<font color="#E5E5E5"> compiler</font>

399
00:18:38,830 --> 00:18:47,470
<font color="#E5E5E5">here will be the size of the base gadget</font>

400
00:18:40,809 --> 00:18:50,379
<font color="#E5E5E5">times the size of the MPC protocol</font><font color="#CCCCCC"> okay</font>

401
00:18:47,470 --> 00:18:52,450
so now we reduce<font color="#E5E5E5"> there or a little bit</font>

402
00:18:50,379 --> 00:18:54,789
but it's still<font color="#CCCCCC"> a constant</font><font color="#E5E5E5"> so how do we</font>

403
00:18:52,450 --> 00:18:58,330
keep<font color="#CCCCCC"> going forward so we just repeat</font>

404
00:18:54,789 --> 00:18:59,649
this process so in the<font color="#CCCCCC"> KH step we are</font>

405
00:18:58,330 --> 00:19:01,928
going to take your tea out of<font color="#CCCCCC"> hansik</font>

406
00:18:59,649 --> 00:19:04,330
<font color="#CCCCCC">your MPC</font><font color="#E5E5E5"> protocol</font><font color="#CCCCCC"> and we are going to</font>

407
00:19:01,929 --> 00:19:08,309
<font color="#E5E5E5">replace the NAND gate with the gadget</font>

408
00:19:04,330 --> 00:19:08,309
<font color="#E5E5E5">obtained from K minus 1 step</font>

409
00:19:12,220 --> 00:19:18,450
so if you keep<font color="#E5E5E5"> doing</font><font color="#CCCCCC"> this you realize</font>

410
00:19:14,440 --> 00:19:21,790
<font color="#CCCCCC">that the size is no longer small because</font>

411
00:19:18,450 --> 00:19:25,150
in each step you are<font color="#E5E5E5"> increasing the size</font>

412
00:19:21,790 --> 00:19:28,060
of<font color="#E5E5E5"> the gadget and after K steps</font><font color="#CCCCCC"> this</font>

413
00:19:25,150 --> 00:19:31,830
<font color="#E5E5E5">will be exponential in K even</font><font color="#CCCCCC"> when you</font>

414
00:19:28,060 --> 00:19:31,830
<font color="#E5E5E5">only stick to constant size circuits</font>

415
00:19:32,610 --> 00:19:36,879
while this might<font color="#E5E5E5"> seem worrisome at this</font>

416
00:19:35,410 --> 00:19:40,630
point<font color="#E5E5E5"> let's look at how the error</font>

417
00:19:36,880 --> 00:19:43,660
<font color="#E5E5E5">reduces in fact you can</font><font color="#CCCCCC"> show that the</font>

418
00:19:40,630 --> 00:19:46,570
error actually reduces quite well it is

419
00:19:43,660 --> 00:19:50,110
1 over<font color="#CCCCCC"> 2 power</font><font color="#E5E5E5"> 2 working so it's</font>

420
00:19:46,570 --> 00:19:53,169
actually doubly exponential in K so<font color="#E5E5E5"> this</font>

421
00:19:50,110 --> 00:19:54,969
<font color="#E5E5E5">is this is good for us so just to</font>

422
00:19:53,170 --> 00:19:57,280
summarize what<font color="#CCCCCC"> we have here is that when</font>

423
00:19:54,970 --> 00:20:03,640
<font color="#E5E5E5">the circuit is circuits of constant size</font>

424
00:19:57,280 --> 00:20:06,760
then the error<font color="#CCCCCC"> also then the error</font><font color="#E5E5E5"> is</font>

425
00:20:03,640 --> 00:20:10,170
something<font color="#CCCCCC"> like utmost 1 by 2 power 2</font>

426
00:20:06,760 --> 00:20:12,850
power<font color="#E5E5E5"> K and the size</font><font color="#CCCCCC"> is exponential in K</font>

427
00:20:10,170 --> 00:20:14,320
the size is still<font color="#E5E5E5"> exponential so we need</font>

428
00:20:12,850 --> 00:20:16,990
to make sure<font color="#E5E5E5"> it's polynomial in the</font>

429
00:20:14,320 --> 00:20:19,090
circuit size<font color="#E5E5E5"> and to ensure</font><font color="#CCCCCC"> that we will</font>

430
00:20:16,990 --> 00:20:23,560
just set K to be logarithmic<font color="#E5E5E5"> in the</font>

431
00:20:19,090 --> 00:20:26,110
circuit size<font color="#E5E5E5"> so this stays the error</font>

432
00:20:23,560 --> 00:20:27,429
will be<font color="#E5E5E5"> negligible in this circuit size</font>

433
00:20:26,110 --> 00:20:34,750
and the size of the gadget will be

434
00:20:27,430 --> 00:20:36,520
<font color="#E5E5E5">poorer a good sign</font><font color="#CCCCCC"> ok</font><font color="#E5E5E5"> so note</font><font color="#CCCCCC"> that all</font>

435
00:20:34,750 --> 00:20:37,960
this while I have been saying<font color="#E5E5E5"> circuit of</font>

436
00:20:36,520 --> 00:20:40,930
constant size<font color="#E5E5E5"> circuit of constant size</font>

437
00:20:37,960 --> 00:20:42,280
so what kind of circuits are we

438
00:20:40,930 --> 00:20:45,280
<font color="#E5E5E5">considering so for now let's</font><font color="#CCCCCC"> just</font>

439
00:20:42,280 --> 00:20:47,500
<font color="#E5E5E5">consider a NAND gates so what we have so</font>

440
00:20:45,280 --> 00:20:50,560
<font color="#CCCCCC">far is leakage resilient circuit</font>

441
00:20:47,500 --> 00:20:53,290
compilers for<font color="#CCCCCC"> NAND gates with negligible</font>

442
00:20:50,560 --> 00:20:58,330
simulation error and constant

443
00:20:53,290 --> 00:21:00,220
probability this<font color="#CCCCCC"> is the result we want</font>

444
00:20:58,330 --> 00:21:02,429
except that it's only for NAND gates<font color="#E5E5E5"> so</font>

445
00:21:00,220 --> 00:21:06,040
how to go from<font color="#CCCCCC"> 9 to arbitrary circuits</font>

446
00:21:02,430 --> 00:21:08,500
<font color="#E5E5E5">so what we do here is we start with</font><font color="#CCCCCC"> this</font>

447
00:21:06,040 --> 00:21:11,200
arbitrary circuit which<font color="#CCCCCC"> is comprising</font><font color="#E5E5E5"> of</font>

448
00:21:08,500 --> 00:21:14,620
NAND gates<font color="#E5E5E5"> and we will replace every</font>

449
00:21:11,200 --> 00:21:16,780
NAND gate here with this gadget<font color="#CCCCCC"> so this</font>

450
00:21:14,620 --> 00:21:18,370
gadget<font color="#E5E5E5"> is associated with constant</font>

451
00:21:16,780 --> 00:21:21,280
<font color="#CCCCCC">probability and negligible simulation</font>

452
00:21:18,370 --> 00:21:24,879
error and then we figure out<font color="#E5E5E5"> how to</font>

453
00:21:21,280 --> 00:21:31,060
stitch these different<font color="#E5E5E5"> gadgets together</font>

454
00:21:24,880 --> 00:21:33,970
so this is the resulting compiler<font color="#E5E5E5"> okay</font>

455
00:21:31,060 --> 00:21:35,740
so one<font color="#CCCCCC"> thing I didn't explain is how to</font>

456
00:21:33,970 --> 00:21:39,250
actually<font color="#E5E5E5"> do this teaching how to argue</font>

457
00:21:35,740 --> 00:21:40,630
security when these different<font color="#E5E5E5"> gadgets</font>

458
00:21:39,250 --> 00:21:43,510
<font color="#CCCCCC">are</font><font color="#E5E5E5"> interacting with</font><font color="#CCCCCC"> each other</font><font color="#E5E5E5"> and so</font>

459
00:21:40,630 --> 00:21:45,880
on<font color="#CCCCCC"> so there</font><font color="#E5E5E5"> are some compositional</font>

460
00:21:43,510 --> 00:21:47,890
issues that come up<font color="#E5E5E5"> in this in this case</font>

461
00:21:45,880 --> 00:21:53,040
<font color="#E5E5E5">if you're interested to know more</font><font color="#CCCCCC"> I can</font>

462
00:21:47,890 --> 00:21:55,750
explain offline<font color="#CCCCCC"> okay so this was about</font>

463
00:21:53,040 --> 00:22:00,040
random probing attacks<font color="#CCCCCC"> so for worst-case</font>

464
00:21:55,750 --> 00:22:01,900
<font color="#E5E5E5">leakage we do something</font><font color="#CCCCCC"> similar</font><font color="#E5E5E5"> in fact</font>

465
00:22:00,040 --> 00:22:03,430
the same approach works even for<font color="#E5E5E5"> the</font>

466
00:22:01,900 --> 00:22:07,780
<font color="#CCCCCC">worst</font><font color="#E5E5E5"> case like a setting and the</font>

467
00:22:03,430 --> 00:22:09,610
analysis<font color="#CCCCCC"> is significantly simpler and to</font>

468
00:22:07,780 --> 00:22:12,160
show the randomness complexity result

469
00:22:09,610 --> 00:22:14,439
what we do is we have this base gadget

470
00:22:12,160 --> 00:22:16,210
<font color="#E5E5E5">we observe</font><font color="#CCCCCC"> that this base gadget has</font>

471
00:22:14,440 --> 00:22:18,730
what we call constant randomness

472
00:22:16,210 --> 00:22:22,480
locality<font color="#CCCCCC"> you don't</font><font color="#E5E5E5"> need to know what</font><font color="#CCCCCC"> are</font>

473
00:22:18,730 --> 00:22:24,130
<font color="#CCCCCC">n de-</font><font color="#E5E5E5"> locality for this talk and we</font>

474
00:22:22,480 --> 00:22:26,140
observe that<font color="#E5E5E5"> in every step this</font>

475
00:22:24,130 --> 00:22:28,930
<font color="#E5E5E5">randomness locality only increases</font>

476
00:22:26,140 --> 00:22:32,040
slightly so after K steps the randomness

477
00:22:28,930 --> 00:22:34,960
locality is some constant times K and

478
00:22:32,040 --> 00:22:37,840
then note that we set K to be

479
00:22:34,960 --> 00:22:40,120
logarithmic<font color="#CCCCCC"> in T and there is a previous</font>

480
00:22:37,840 --> 00:22:42,250
<font color="#E5E5E5">work</font><font color="#CCCCCC"> that shows</font><font color="#E5E5E5"> that any leakage</font>

481
00:22:40,120 --> 00:22:45,550
resilient circuit compiler<font color="#CCCCCC"> that has</font>

482
00:22:42,250 --> 00:22:47,890
small randomness locality<font color="#CCCCCC"> can be</font>

483
00:22:45,550 --> 00:22:49,659
converted<font color="#CCCCCC"> to another</font><font color="#E5E5E5"> leakages</font><font color="#CCCCCC"> and</font>

484
00:22:47,890 --> 00:22:52,180
circuit compiler with small randomness

485
00:22:49,660 --> 00:22:53,920
locality<font color="#CCCCCC"> just landed miss complexity</font><font color="#E5E5E5"> and</font>

486
00:22:52,180 --> 00:22:56,290
so we are<font color="#E5E5E5"> going to use this result to</font>

487
00:22:53,920 --> 00:23:00,610
<font color="#E5E5E5">get small randomness complexity so</font>

488
00:22:56,290 --> 00:23:04,810
<font color="#CCCCCC">that's that</font><font color="#E5E5E5"> is the main idea</font><font color="#CCCCCC"> so let</font><font color="#E5E5E5"> me</font>

489
00:23:00,610 --> 00:23:07,240
conclude<font color="#CCCCCC"> so we get results in the</font>

490
00:23:04,810 --> 00:23:11,020
<font color="#E5E5E5">leakage resilient and the leakage</font>

491
00:23:07,240 --> 00:23:12,580
tolerant settings so in both<font color="#E5E5E5"> of these</font>

492
00:23:11,020 --> 00:23:14,080
<font color="#E5E5E5">settings we consider two types of</font>

493
00:23:12,580 --> 00:23:15,429
attacks the worst case were probing

494
00:23:14,080 --> 00:23:17,679
attacks and random<font color="#CCCCCC"> were probing attacks</font>

495
00:23:15,430 --> 00:23:20,200
so worst case robbing<font color="#CCCCCC"> we're probing</font>

496
00:23:17,680 --> 00:23:23,470
<font color="#E5E5E5">attacks we get optimal randomness</font>

497
00:23:20,200 --> 00:23:25,600
complexity result<font color="#E5E5E5"> and for random</font><font color="#CCCCCC"> were</font>

498
00:23:23,470 --> 00:23:28,570
<font color="#E5E5E5">probing attacks we get a construction</font>

499
00:23:25,600 --> 00:23:31,139
that<font color="#E5E5E5"> is some significantly simpler than</font>

500
00:23:28,570 --> 00:23:31,139
prior<font color="#E5E5E5"> books</font>

501
00:23:32,360 --> 00:23:38,409
[Applause]

