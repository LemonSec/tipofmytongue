1
00:00:04,910 --> 00:00:09,770
thank you very<font color="#E5E5E5"> much</font><font color="#CCCCCC"> for the introduction</font>

2
00:00:07,149 --> 00:00:14,840
<font color="#CCCCCC">so this talk is on</font><font color="#E5E5E5"> verifiable delay</font>

3
00:00:09,770 --> 00:00:18,950
functions what is a verifiable delay

4
00:00:14,840 --> 00:00:21,829
function or<font color="#E5E5E5"> vdf for short</font><font color="#CCCCCC"> well first it</font>

5
00:00:18,950 --> 00:00:25,099
is a function<font color="#E5E5E5"> from some domain</font><font color="#CCCCCC"> X to some</font>

6
00:00:21,829 --> 00:00:29,079
range Y<font color="#E5E5E5"> meaning</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> for any input X and</font>

7
00:00:25,099 --> 00:00:31,910
X<font color="#CCCCCC"> there is a unique</font><font color="#E5E5E5"> output Y and Y and</font>

8
00:00:29,079 --> 00:00:34,309
furthermore<font color="#E5E5E5"> evaluating this function</font>

9
00:00:31,910 --> 00:00:37,190
incurs a delay<font color="#CCCCCC"> meaning that it</font><font color="#E5E5E5"> can be</font>

10
00:00:34,309 --> 00:00:40,430
evaluated<font color="#E5E5E5"> in time</font><font color="#CCCCCC"> T but cannot be</font>

11
00:00:37,190 --> 00:00:42,980
evaluated<font color="#CCCCCC"> in time 1</font><font color="#E5E5E5"> minus epsilon T for</font>

12
00:00:40,430 --> 00:00:44,660
some small<font color="#CCCCCC"> epsilon on even a parallel</font>

13
00:00:42,980 --> 00:00:47,089
machine<font color="#CCCCCC"> in other words it requires</font>

14
00:00:44,660 --> 00:00:48,980
sequential work to<font color="#CCCCCC"> evaluate or takes a</font>

15
00:00:47,090 --> 00:00:51,230
long<font color="#CCCCCC"> time in terms of wall clock time</font>

16
00:00:48,980 --> 00:00:54,620
<font color="#E5E5E5">not just</font><font color="#CCCCCC"> in</font><font color="#E5E5E5"> terms of</font><font color="#CCCCCC"> overall time</font>

17
00:00:51,230 --> 00:00:57,110
complexity and finally it is verifiable

18
00:00:54,620 --> 00:00:58,760
<font color="#E5E5E5">meaning that anyone who computes the</font>

19
00:00:57,110 --> 00:01:02,060
function<font color="#CCCCCC"> can also at the same</font><font color="#E5E5E5"> time</font>

20
00:00:58,760 --> 00:01:07,490
<font color="#CCCCCC">output a short proof of correctness that</font>

21
00:01:02,060 --> 00:01:09,700
anyone<font color="#E5E5E5"> else can verify efficiently</font><font color="#CCCCCC"> a bit</font>

22
00:01:07,490 --> 00:01:11,990
more formally<font color="#CCCCCC"> will say that a vdf</font>

23
00:01:09,700 --> 00:01:15,079
involves<font color="#E5E5E5"> three procedures</font><font color="#CCCCCC"> a set up</font>

24
00:01:11,990 --> 00:01:17,600
procedure<font color="#CCCCCC"> an eval procedure and a verify</font>

25
00:01:15,079 --> 00:01:19,219
procedure and the set up generates the

26
00:01:17,600 --> 00:01:21,499
public parameters from<font color="#E5E5E5"> a security</font>

27
00:01:19,219 --> 00:01:24,889
parameter and a delay parameter<font color="#CCCCCC"> T which</font>

28
00:01:21,499 --> 00:01:27,979
determines<font color="#E5E5E5"> the sequential work needed by</font>

29
00:01:24,889 --> 00:01:31,009
the evil algorithm eval evaluates the

30
00:01:27,979 --> 00:01:33,079
underlying function and outputs<font color="#CCCCCC"> the</font>

31
00:01:31,009 --> 00:01:34,520
result along with perhaps a proof

32
00:01:33,079 --> 00:01:38,089
<font color="#E5E5E5">although some constructions may not</font>

33
00:01:34,520 --> 00:01:40,189
require<font color="#CCCCCC"> a proof</font><font color="#E5E5E5"> and verify verifies that</font>

34
00:01:38,090 --> 00:01:43,369
<font color="#CCCCCC">a given input and output</font><font color="#E5E5E5"> and proof are</font>

35
00:01:40,189 --> 00:01:46,458
consistent importantly the eval

36
00:01:43,369 --> 00:01:50,240
procedure should run in<font color="#E5E5E5"> parallel time T</font>

37
00:01:46,459 --> 00:01:52,700
with poly log T processors and the

38
00:01:50,240 --> 00:01:54,770
verify procedure<font color="#E5E5E5"> in contrast should have</font>

39
00:01:52,700 --> 00:02:02,060
time complexity overall time complexity

40
00:01:54,770 --> 00:02:05,568
at most poly log<font color="#E5E5E5"> of T so in terms of the</font>

41
00:02:02,060 --> 00:02:08,209
<font color="#E5E5E5">security properties soundness captures</font>

42
00:02:05,569 --> 00:02:11,720
the<font color="#E5E5E5"> uniqueness or</font><font color="#CCCCCC"> the fact that eval</font>

43
00:02:08,209 --> 00:02:13,370
implements a function in other words for

44
00:02:11,720 --> 00:02:16,070
<font color="#E5E5E5">any given input X there is a unique</font>

45
00:02:13,370 --> 00:02:18,180
output<font color="#CCCCCC"> Y for</font><font color="#E5E5E5"> which an adversary can</font>

46
00:02:16,070 --> 00:02:19,590
<font color="#E5E5E5">produce a correct proof</font>

47
00:02:18,180 --> 00:02:23,129
that will be accepted by the verify

48
00:02:19,590 --> 00:02:26,909
algorithm<font color="#E5E5E5"> Sigma sequentiality then</font>

49
00:02:23,129 --> 00:02:28,560
captures<font color="#E5E5E5"> the delay property where Sigma</font>

50
00:02:26,909 --> 00:02:31,469
of T<font color="#E5E5E5"> is some</font><font color="#CCCCCC"> function of</font><font color="#E5E5E5"> T which is</font>

51
00:02:28,560 --> 00:02:33,780
strictly<font color="#E5E5E5"> less than T say 1 minus epsilon</font>

52
00:02:31,469 --> 00:02:37,769
T for some constant<font color="#E5E5E5"> small constant</font>

53
00:02:33,780 --> 00:02:40,319
<font color="#CCCCCC">epsilon and</font><font color="#E5E5E5"> we'll say that if a</font><font color="#CCCCCC"> is a is</font>

54
00:02:37,769 --> 00:02:43,709
a<font color="#E5E5E5"> P Ram algorithm that</font><font color="#CCCCCC"> runs in time less</font>

55
00:02:40,319 --> 00:02:46,018
than<font color="#CCCCCC"> Sigma</font><font color="#E5E5E5"> of T then it cannot pass it</font>

56
00:02:43,709 --> 00:02:48,510
cannot compute the correct<font color="#E5E5E5"> was the</font>

57
00:02:46,019 --> 00:02:51,329
correct output<font color="#E5E5E5"> of eval</font><font color="#CCCCCC"> Y on a given</font>

58
00:02:48,510 --> 00:02:53,459
input<font color="#CCCCCC"> X with probability</font><font color="#E5E5E5"> greater than</font>

59
00:02:51,329 --> 00:02:55,379
negligible<font color="#E5E5E5"> in lambda</font><font color="#CCCCCC"> so this is stated</font>

60
00:02:53,459 --> 00:02:57,209
informally now in a few<font color="#E5E5E5"> slides we'll</font>

61
00:02:55,379 --> 00:03:03,298
introduce<font color="#E5E5E5"> this a bit more formally</font>

62
00:02:57,209 --> 00:03:06,299
through<font color="#E5E5E5"> a game now</font><font color="#CCCCCC"> V BFS are very very</font>

63
00:03:03,299 --> 00:03:08,340
related<font color="#E5E5E5"> to</font><font color="#CCCCCC"> to crypto primitives that you</font>

64
00:03:06,299 --> 00:03:11,579
may be familiar<font color="#E5E5E5"> with the first is time</font>

65
00:03:08,340 --> 00:03:13,849
lock puzzles dating back to 1996 which

66
00:03:11,579 --> 00:03:18,000
also<font color="#E5E5E5"> involve a puzzle which requires</font>

67
00:03:13,849 --> 00:03:19,768
sequential time to compute the main

68
00:03:18,000 --> 00:03:22,229
difference<font color="#E5E5E5"> there are that time lock</font>

69
00:03:19,769 --> 00:03:24,329
puzzles involve a trapdoor<font color="#CCCCCC"> or secret key</font>

70
00:03:22,229 --> 00:03:26,760
<font color="#CCCCCC">setup per puzzle</font><font color="#E5E5E5"> and therefore they're</font>

71
00:03:24,329 --> 00:03:29,040
not<font color="#CCCCCC"> publicly verifiable in the same</font>

72
00:03:26,760 --> 00:03:31,888
sense but<font color="#E5E5E5"> more recently proofs of</font>

73
00:03:29,040 --> 00:03:33,959
sequential work solved the public

74
00:03:31,889 --> 00:03:37,199
verifiability problem<font color="#E5E5E5"> and there's</font>

75
00:03:33,959 --> 00:03:39,090
<font color="#E5E5E5">several recent constructions of proofs</font>

76
00:03:37,199 --> 00:03:40,939
<font color="#E5E5E5">of sequential work which are public very</font>

77
00:03:39,090 --> 00:03:44,010
publicly verifiable meaning they do not

78
00:03:40,939 --> 00:03:46,228
<font color="#E5E5E5">require any</font><font color="#CCCCCC"> trapdoor secret key</font><font color="#E5E5E5"> setup</font>

79
00:03:44,010 --> 00:03:48,478
<font color="#E5E5E5">per puzzle but on the other hand</font><font color="#CCCCCC"> these</font>

80
00:03:46,229 --> 00:03:55,709
constructions do not have unique outputs

81
00:03:48,479 --> 00:03:58,159
<font color="#E5E5E5">so they are not functions to summarize a</font>

82
00:03:55,709 --> 00:04:01,079
<font color="#E5E5E5">PDF - any one of these properties</font>

83
00:03:58,159 --> 00:04:03,409
<font color="#E5E5E5">follows from is either easy or</font><font color="#CCCCCC"> follows</font>

84
00:04:01,079 --> 00:04:06,090
from previously known constructions<font color="#E5E5E5"> if</font>

85
00:04:03,409 --> 00:04:07,649
it's not<font color="#E5E5E5"> verifiable then chaining any</font>

86
00:04:06,090 --> 00:04:10,889
one wave function would give you a

87
00:04:07,650 --> 00:04:13,109
sequential<font color="#CCCCCC"> function if there's no delay</font>

88
00:04:10,889 --> 00:04:15,720
required and it's just required to have

89
00:04:13,109 --> 00:04:17,459
some moderately<font color="#E5E5E5"> hard moderate hardness</font>

90
00:04:15,720 --> 00:04:18,988
to compute<font color="#E5E5E5"> with efficient verification</font>

91
00:04:17,459 --> 00:04:21,269
then there's many<font color="#E5E5E5"> many examples for</font>

92
00:04:18,988 --> 00:04:23,520
example discrete log on a small domain

93
00:04:21,269 --> 00:04:26,939
and if it's not<font color="#E5E5E5"> a function then proofs</font>

94
00:04:23,520 --> 00:04:29,560
of sequential work suffice

95
00:04:26,939 --> 00:04:31,960
but let<font color="#E5E5E5"> me mention one other classical</font>

96
00:04:29,560 --> 00:04:35,110
puzzle from the literature<font color="#CCCCCC"> that</font><font color="#E5E5E5"> comes</font>

97
00:04:31,960 --> 00:04:37,989
<font color="#CCCCCC">very close</font><font color="#E5E5E5"> to</font><font color="#CCCCCC"> a vdf and this is the</font>

98
00:04:35,110 --> 00:04:41,050
problem<font color="#E5E5E5"> of modular square roots</font><font color="#CCCCCC"> mata</font>

99
00:04:37,990 --> 00:04:43,360
<font color="#CCCCCC">Prime the puzzle is based on the</font>

100
00:04:41,050 --> 00:04:45,520
<font color="#E5E5E5">assumption that there's no log T</font>

101
00:04:43,360 --> 00:04:49,180
algorithm that can compute X to the

102
00:04:45,520 --> 00:04:52,780
power<font color="#E5E5E5"> T mod a prime faster than</font><font color="#CCCCCC"> doing</font>

103
00:04:49,180 --> 00:04:55,930
log<font color="#E5E5E5"> T sequential multiplications via the</font>

104
00:04:52,780 --> 00:04:58,628
repeated squaring algorithm the<font color="#E5E5E5"> way that</font>

105
00:04:55,930 --> 00:05:01,569
you would<font color="#CCCCCC"> use this to</font><font color="#E5E5E5"> create a vdf like</font>

106
00:04:58,629 --> 00:05:05,080
puzzle is well the setup procedure<font color="#E5E5E5"> would</font>

107
00:05:01,569 --> 00:05:07,810
pick the prime<font color="#E5E5E5"> P</font><font color="#CCCCCC"> and in</font><font color="#E5E5E5"> this case we</font>

108
00:05:05,080 --> 00:05:09,849
would set P equal to<font color="#CCCCCC"> 3 mod 4 so that the</font>

109
00:05:07,810 --> 00:05:12,699
eval procedure can compute the<font color="#E5E5E5"> square</font>

110
00:05:09,849 --> 00:05:14,889
root of a given point<font color="#E5E5E5"> X by raising X to</font>

111
00:05:12,699 --> 00:05:19,629
the P plus<font color="#E5E5E5"> 1 over 4</font><font color="#CCCCCC"> and that requires</font>

112
00:05:14,889 --> 00:05:21,729
<font color="#E5E5E5">log of P sequential squarings but the</font>

113
00:05:19,629 --> 00:05:26,080
verify procedure<font color="#E5E5E5"> just requires one</font>

114
00:05:21,729 --> 00:05:30,039
squaring<font color="#E5E5E5"> to verify the result so this</font>

115
00:05:26,080 --> 00:05:32,318
comes very<font color="#E5E5E5"> close to</font><font color="#CCCCCC"> a vdf the reason</font>

116
00:05:30,039 --> 00:05:34,900
that we would call it only<font color="#CCCCCC"> a proto vdf</font>

117
00:05:32,319 --> 00:05:38,529
is because it doesn't quite have<font color="#CCCCCC"> enough</font>

118
00:05:34,900 --> 00:05:39,789
<font color="#E5E5E5">asymmetry let's see why so let's say</font>

119
00:05:38,529 --> 00:05:43,000
that<font color="#E5E5E5"> the time complexity of</font>

120
00:05:39,789 --> 00:05:46,900
multiplication mod<font color="#CCCCCC"> P</font><font color="#E5E5E5"> is M of</font><font color="#CCCCCC"> P which</font><font color="#E5E5E5"> is</font>

121
00:05:43,000 --> 00:05:49,990
at least super linear<font color="#E5E5E5"> in log P the eval</font>

122
00:05:46,900 --> 00:05:54,818
time requires log of P times M of P work

123
00:05:49,990 --> 00:05:57,639
and the verify work is just M of<font color="#E5E5E5"> P so</font>

124
00:05:54,819 --> 00:05:59,680
there is a log<font color="#E5E5E5"> P gap between the verify</font>

125
00:05:57,639 --> 00:06:02,349
and evaluation procedure but the<font color="#E5E5E5"> verify</font>

126
00:05:59,680 --> 00:06:03,550
time is not<font color="#E5E5E5"> poly logarithmic in the eval</font>

127
00:06:02,349 --> 00:06:05,500
time and if you<font color="#E5E5E5"> want to increase the</font>

128
00:06:03,550 --> 00:06:07,029
<font color="#CCCCCC">delay by increasing</font><font color="#E5E5E5"> P it not only</font>

129
00:06:05,500 --> 00:06:09,550
introduces<font color="#E5E5E5"> more power that parallelism</font>

130
00:06:07,029 --> 00:06:14,110
<font color="#E5E5E5">in the multiplication</font><font color="#CCCCCC"> it also blows up</font>

131
00:06:09,550 --> 00:06:15,759
the size of the proof so let's now come

132
00:06:14,110 --> 00:06:17,770
<font color="#CCCCCC">back to the security</font><font color="#E5E5E5"> properties and</font>

133
00:06:15,759 --> 00:06:20,710
define more formally what<font color="#E5E5E5"> Sigma</font>

134
00:06:17,770 --> 00:06:23,969
sequentiality is in terms of a security

135
00:06:20,710 --> 00:06:27,159
game so the sequentiality game will

136
00:06:23,969 --> 00:06:29,229
generate a public public parameters<font color="#E5E5E5"> from</font>

137
00:06:27,159 --> 00:06:31,240
<font color="#CCCCCC">the set up algorithm these will be</font><font color="#E5E5E5"> given</font>

138
00:06:29,229 --> 00:06:33,580
to a pre-processing adversary who's

139
00:06:31,240 --> 00:06:37,149
allowed<font color="#E5E5E5"> to pre-process</font><font color="#CCCCCC"> on the parameters</font>

140
00:06:33,580 --> 00:06:39,780
<font color="#E5E5E5">and produce some advice</font><font color="#CCCCCC"> l this</font><font color="#E5E5E5"> has been</font>

141
00:06:37,149 --> 00:06:42,780
given<font color="#CCCCCC"> to an online adversary</font><font color="#E5E5E5"> whose</font>

142
00:06:39,780 --> 00:06:46,260
<font color="#E5E5E5">a challenge</font><font color="#CCCCCC"> a random challenge</font><font color="#E5E5E5"> X sampled</font>

143
00:06:42,780 --> 00:06:51,270
from<font color="#CCCCCC"> the domain and is</font><font color="#E5E5E5"> required to try</font>

144
00:06:46,260 --> 00:06:53,640
to output its guests for what the<font color="#E5E5E5"> with</font>

145
00:06:51,270 --> 00:06:56,039
the value<font color="#E5E5E5"> Y is and we say that the</font>

146
00:06:53,640 --> 00:06:58,680
adversary wins the game<font color="#E5E5E5"> if this online</font>

147
00:06:56,040 --> 00:07:01,080
adversary is able to output the correct

148
00:06:58,680 --> 00:07:03,960
<font color="#CCCCCC">y as defined by the eval procedure for</font>

149
00:07:01,080 --> 00:07:07,140
the given random challenge<font color="#E5E5E5"> ax and</font><font color="#CCCCCC"> will</font>

150
00:07:03,960 --> 00:07:10,530
say<font color="#E5E5E5"> that of EDF is P Sigma sequential</font><font color="#CCCCCC"> if</font>

151
00:07:07,140 --> 00:07:12,780
there's no adversary<font color="#E5E5E5"> consisting of a 0</font>

152
00:07:10,530 --> 00:07:15,780
and a 1 where a<font color="#CCCCCC"> zero</font><font color="#E5E5E5"> runs in polynomial</font>

153
00:07:12,780 --> 00:07:18,719
time in<font color="#CCCCCC"> lambda</font><font color="#E5E5E5"> and a 1 the online</font>

154
00:07:15,780 --> 00:07:21,239
<font color="#E5E5E5">adversary has pyram running time Sigma</font>

155
00:07:18,720 --> 00:07:22,980
of T on P of T processors and if no such

156
00:07:21,240 --> 00:07:24,810
adversary can win the game with

157
00:07:22,980 --> 00:07:27,060
probability<font color="#CCCCCC"> greater than negligible in</font>

158
00:07:24,810 --> 00:07:30,960
<font color="#CCCCCC">lambda</font><font color="#E5E5E5"> will say that the</font><font color="#CCCCCC"> VD F is P Sigma</font>

159
00:07:27,060 --> 00:07:34,280
sequential so before<font color="#E5E5E5"> going into</font>

160
00:07:30,960 --> 00:07:36,359
describing<font color="#E5E5E5"> some constructions of</font><font color="#CCCCCC"> V DFS I</font>

161
00:07:34,280 --> 00:07:40,440
first want to<font color="#CCCCCC"> highlight several</font>

162
00:07:36,360 --> 00:07:42,810
applications there<font color="#CCCCCC"> are many applications</font>

163
00:07:40,440 --> 00:07:44,760
<font color="#CCCCCC">ranging from randomness</font><font color="#E5E5E5"> beacons</font>

164
00:07:42,810 --> 00:07:48,030
<font color="#E5E5E5">multi-party randomness time stamping</font>

165
00:07:44,760 --> 00:07:50,490
proof of space and proof of replication

166
00:07:48,030 --> 00:07:52,409
or permissionless consensus protocols

167
00:07:50,490 --> 00:07:54,540
<font color="#E5E5E5">but in this talk I'm going to focus on</font>

168
00:07:52,410 --> 00:07:55,890
the<font color="#CCCCCC"> application to</font><font color="#E5E5E5"> randomness beacons</font>

169
00:07:54,540 --> 00:07:59,310
and<font color="#E5E5E5"> the related application of</font>

170
00:07:55,890 --> 00:08:01,260
<font color="#E5E5E5">multi-party randomness so</font><font color="#CCCCCC"> what is a</font>

171
00:07:59,310 --> 00:08:04,229
random<font color="#CCCCCC"> to</font><font color="#E5E5E5"> speakin it is a term that</font><font color="#CCCCCC"> was</font>

172
00:08:01,260 --> 00:08:06,289
coined in 1983 by<font color="#E5E5E5"> Michael Robin as an</font>

173
00:08:04,229 --> 00:08:09,990
ideal service that regularly publishes

174
00:08:06,290 --> 00:08:13,380
<font color="#E5E5E5">random values which no other party can</font>

175
00:08:09,990 --> 00:08:15,419
predict<font color="#E5E5E5"> or manipulate there are of</font>

176
00:08:13,380 --> 00:08:17,280
<font color="#CCCCCC">course many uses for random beacons most</font>

177
00:08:15,419 --> 00:08:19,590
notably running lotteries without a

178
00:08:17,280 --> 00:08:23,190
trusted operator or a Byzantine

179
00:08:19,590 --> 00:08:25,080
agreement protocols<font color="#E5E5E5"> and what is the</font>

180
00:08:23,190 --> 00:08:27,360
<font color="#E5E5E5">problem with randomness beacons the way</font>

181
00:08:25,080 --> 00:08:29,039
that<font color="#E5E5E5"> they're run usually in the real</font>

182
00:08:27,360 --> 00:08:30,930
world<font color="#CCCCCC"> today well they're done through</font>

183
00:08:29,040 --> 00:08:32,729
these<font color="#E5E5E5"> public displays of randomness</font><font color="#CCCCCC"> so</font>

184
00:08:30,930 --> 00:08:34,469
<font color="#CCCCCC">you'll</font><font color="#E5E5E5"> have some balls running around in</font>

185
00:08:32,729 --> 00:08:36,089
a machine<font color="#CCCCCC"> and</font><font color="#E5E5E5"> then the ball the</font><font color="#CCCCCC"> Machine</font>

186
00:08:34,469 --> 00:08:39,330
spits<font color="#E5E5E5"> out some balls which determines</font>

187
00:08:36,089 --> 00:08:40,710
the<font color="#CCCCCC"> winning tickets of the lottery</font><font color="#E5E5E5"> the</font>

188
00:08:39,330 --> 00:08:42,570
problem is<font color="#E5E5E5"> that this is</font><font color="#CCCCCC"> easily</font>

189
00:08:40,710 --> 00:08:45,210
corruptible in fact you can watch this

190
00:08:42,570 --> 00:08:46,680
<font color="#E5E5E5">YouTube video online where you see that</font>

191
00:08:45,210 --> 00:08:49,410
<font color="#CCCCCC">only three balls have come out of the</font>

192
00:08:46,680 --> 00:08:51,599
<font color="#E5E5E5">machine but magically the five winning</font>

193
00:08:49,410 --> 00:08:55,819
<font color="#E5E5E5">numbers have already been reported</font>

194
00:08:51,600 --> 00:08:59,040
so clearly something<font color="#E5E5E5"> fishy is going on</font>

195
00:08:55,820 --> 00:09:01,670
<font color="#E5E5E5">another idea perhaps better is to</font><font color="#CCCCCC"> use</font>

196
00:08:59,040 --> 00:09:04,050
some publicly occurring entropy source

197
00:09:01,670 --> 00:09:05,310
stock prices have<font color="#E5E5E5"> been suggested under</font>

198
00:09:04,050 --> 00:09:07,770
<font color="#CCCCCC">the assumption that they're</font>

199
00:09:05,310 --> 00:09:10,439
unpredictable<font color="#E5E5E5"> and an adversary cannot</font>

200
00:09:07,770 --> 00:09:12,870
fix<font color="#E5E5E5"> stock prices at least not over a</font>

201
00:09:10,440 --> 00:09:15,270
long period of time<font color="#E5E5E5"> but we do know that</font>

202
00:09:12,870 --> 00:09:17,460
stock<font color="#E5E5E5"> prices</font><font color="#CCCCCC"> are manipulatable to some</font>

203
00:09:15,270 --> 00:09:19,500
degree in<font color="#CCCCCC"> the</font><font color="#E5E5E5"> short term due</font><font color="#CCCCCC"> to high</font>

204
00:09:17,460 --> 00:09:21,510
frequency trading<font color="#CCCCCC"> so let's see how</font><font color="#E5E5E5"> this</font>

205
00:09:19,500 --> 00:09:23,760
is<font color="#CCCCCC"> problematic if you're</font><font color="#E5E5E5"> going to</font>

206
00:09:21,510 --> 00:09:27,420
<font color="#E5E5E5">construct a random and speakin naively</font>

207
00:09:23,760 --> 00:09:29,069
<font color="#E5E5E5">based on stock prices let's say that we</font>

208
00:09:27,420 --> 00:09:30,959
take the closing prices of<font color="#E5E5E5"> a</font><font color="#CCCCCC"> hundred</font>

209
00:09:29,070 --> 00:09:33,960
<font color="#E5E5E5">stocks on the new york</font><font color="#CCCCCC"> stock stock</font>

210
00:09:30,960 --> 00:09:36,960
exchange<font color="#E5E5E5"> and hash the prices and extract</font>

211
00:09:33,960 --> 00:09:38,760
<font color="#CCCCCC">from it at the</font><font color="#E5E5E5"> output of our beacon the</font>

212
00:09:36,960 --> 00:09:42,120
problem is<font color="#E5E5E5"> that an adversary a</font>

213
00:09:38,760 --> 00:09:43,860
<font color="#E5E5E5">high-frequency trader just after the</font>

214
00:09:42,120 --> 00:09:45,870
prices settle a few minutes<font color="#CCCCCC"> before</font>

215
00:09:43,860 --> 00:09:47,670
closing can execute say<font color="#CCCCCC"> twenty</font>

216
00:09:45,870 --> 00:09:50,520
<font color="#CCCCCC">last-minute</font><font color="#E5E5E5"> trades in order to influence</font>

217
00:09:47,670 --> 00:09:52,920
<font color="#E5E5E5">the seed the problem is that the</font>

218
00:09:50,520 --> 00:09:55,380
attacker can predict predict<font color="#E5E5E5"> the outcome</font>

219
00:09:52,920 --> 00:09:57,839
of<font color="#E5E5E5"> each of these trades and therefore</font>

220
00:09:55,380 --> 00:10:00,660
choose among its actions<font color="#CCCCCC"> are the most</font>

221
00:09:57,840 --> 00:10:04,650
<font color="#E5E5E5">favorable for for the outcome so</font><font color="#CCCCCC"> it can</font>

222
00:10:00,660 --> 00:10:07,319
therefore bias the result<font color="#E5E5E5"> and how</font><font color="#CCCCCC"> would</font>

223
00:10:04,650 --> 00:10:09,030
a verifiable<font color="#E5E5E5"> delay function help with</font>

224
00:10:07,320 --> 00:10:12,630
this<font color="#E5E5E5"> where the solution is simply to</font>

225
00:10:09,030 --> 00:10:14,610
<font color="#E5E5E5">slow things down</font><font color="#CCCCCC"> so after extracting the</font>

226
00:10:12,630 --> 00:10:16,439
value from<font color="#E5E5E5"> the half of the prices</font><font color="#CCCCCC"> we</font>

227
00:10:14,610 --> 00:10:19,560
would then run it through<font color="#E5E5E5"> say a</font><font color="#CCCCCC"> one-hour</font>

228
00:10:16,440 --> 00:10:21,900
long<font color="#E5E5E5"> video which after an hour spits out</font>

229
00:10:19,560 --> 00:10:24,150
<font color="#CCCCCC">the final value of</font><font color="#E5E5E5"> the beacon now the</font>

230
00:10:21,900 --> 00:10:26,220
attacker cannot tell which trades to

231
00:10:24,150 --> 00:10:29,100
execute just before the market<font color="#E5E5E5"> closes in</font>

232
00:10:26,220 --> 00:10:30,780
order to bias the result in a<font color="#CCCCCC"> particular</font>

233
00:10:29,100 --> 00:10:33,090
way<font color="#E5E5E5"> because it cannot predict what the</font>

234
00:10:30,780 --> 00:10:35,100
output of the vdf will be on this<font color="#E5E5E5"> value</font>

235
00:10:33,090 --> 00:10:39,140
presuming<font color="#CCCCCC"> that there is enough</font><font color="#E5E5E5"> entropy</font>

236
00:10:35,100 --> 00:10:39,140
that<font color="#CCCCCC"> it cannot manipulate</font><font color="#E5E5E5"> in the input</font>

237
00:10:39,950 --> 00:10:45,210
the same idea<font color="#CCCCCC"> can be used for</font>

238
00:10:42,600 --> 00:10:47,220
resurrecting<font color="#E5E5E5"> the most simple approach to</font>

239
00:10:45,210 --> 00:10:49,620
multi-party randomness generation and

240
00:10:47,220 --> 00:10:52,110
what does this approach we'll just have

241
00:10:49,620 --> 00:10:54,660
all the parties submit random values to

242
00:10:52,110 --> 00:10:57,000
a public bulletin<font color="#E5E5E5"> board and then</font>

243
00:10:54,660 --> 00:10:59,430
determine<font color="#CCCCCC"> the output of the condom</font>

244
00:10:57,000 --> 00:11:01,410
common randomness generation as the hash

245
00:10:59,430 --> 00:11:03,780
of all<font color="#E5E5E5"> these values now</font><font color="#CCCCCC"> clearly this</font>

246
00:11:01,410 --> 00:11:05,760
does not work because the last party to

247
00:11:03,780 --> 00:11:08,579
submit has complete<font color="#E5E5E5"> control</font>

248
00:11:05,760 --> 00:11:10,079
<font color="#CCCCCC">/ the</font><font color="#E5E5E5"> seed perhaps they cannot fix it to</font>

249
00:11:08,579 --> 00:11:11,790
a particular<font color="#CCCCCC"> value based on</font><font color="#E5E5E5"> the security</font>

250
00:11:10,079 --> 00:11:13,380
<font color="#CCCCCC">of</font><font color="#E5E5E5"> the hash function</font><font color="#CCCCCC"> but they can</font>

251
00:11:11,790 --> 00:11:17,849
<font color="#E5E5E5">certainly choose from polynomially many</font>

252
00:11:13,380 --> 00:11:21,180
options<font color="#E5E5E5"> and</font><font color="#CCCCCC"> bias</font><font color="#E5E5E5"> the result so with a</font>

253
00:11:17,850 --> 00:11:23,430
<font color="#E5E5E5">vdf we would just slow things</font><font color="#CCCCCC"> down so</font>

254
00:11:21,180 --> 00:11:26,880
that instead of<font color="#E5E5E5"> choosing the hash to be</font>

255
00:11:23,430 --> 00:11:29,760
the output the common random output<font color="#E5E5E5"> we</font>

256
00:11:26,880 --> 00:11:31,889
would then apply<font color="#E5E5E5"> a vdf to add a delay</font>

257
00:11:29,760 --> 00:11:34,470
and then hash again<font color="#E5E5E5"> to determine the</font>

258
00:11:31,889 --> 00:11:37,649
output<font color="#CCCCCC"> of the beacon</font><font color="#E5E5E5"> or in this case the</font>

259
00:11:34,470 --> 00:11:40,139
<font color="#CCCCCC">the multi-party randomness generation so</font>

260
00:11:37,649 --> 00:11:41,459
this way<font color="#CCCCCC"> Zoey who is the last submit can</font>

261
00:11:40,139 --> 00:11:42,990
choose<font color="#CCCCCC"> among many different values but</font>

262
00:11:41,459 --> 00:11:45,000
<font color="#CCCCCC">she can't figure out</font><font color="#E5E5E5"> how they will</font>

263
00:11:42,990 --> 00:11:48,990
<font color="#CCCCCC">actually affect</font><font color="#E5E5E5"> the outcome so she</font>

264
00:11:45,000 --> 00:11:51,630
cannot bias the result now let me talk

265
00:11:48,990 --> 00:11:53,040
<font color="#E5E5E5">about some constructions</font><font color="#CCCCCC"> I will spend</font>

266
00:11:51,630 --> 00:11:54,990
the<font color="#E5E5E5"> most time talking about the</font>

267
00:11:53,040 --> 00:11:57,060
<font color="#E5E5E5">construction we</font><font color="#CCCCCC"> have in our work with</font>

268
00:11:54,990 --> 00:12:00,209
which at a very high level<font color="#E5E5E5"> involves a</font>

269
00:11:57,060 --> 00:12:02,609
chained permutation which is fast<font color="#E5E5E5"> in</font>

270
00:12:00,209 --> 00:12:05,279
slow in one<font color="#CCCCCC"> direction but fast in the</font>

271
00:12:02,610 --> 00:12:07,680
<font color="#E5E5E5">other and then we'll use a snark or a</font>

272
00:12:05,279 --> 00:12:09,870
<font color="#E5E5E5">start to amplify</font><font color="#CCCCCC"> this into a verifiable</font>

273
00:12:07,680 --> 00:12:12,060
<font color="#E5E5E5">delay function and I will explain more</font>

274
00:12:09,870 --> 00:12:14,459
<font color="#CCCCCC">details on that but I will also</font><font color="#E5E5E5"> briefly</font>

275
00:12:12,060 --> 00:12:17,130
mention some<font color="#E5E5E5"> follow-up work that came</font>

276
00:12:14,459 --> 00:12:18,329
out<font color="#CCCCCC"> very</font><font color="#E5E5E5"> recently which takes a</font>

277
00:12:17,130 --> 00:12:20,130
different<font color="#E5E5E5"> approach</font><font color="#CCCCCC"> of essentially</font>

278
00:12:18,329 --> 00:12:22,500
constructing a specialized snark or

279
00:12:20,130 --> 00:12:24,600
compact<font color="#E5E5E5"> proof of correctness for</font>

280
00:12:22,500 --> 00:12:29,459
exponentiation in a group of unknown

281
00:12:24,600 --> 00:12:32,130
order so<font color="#E5E5E5"> let's recall the hash</font><font color="#CCCCCC"> chain</font>

282
00:12:29,459 --> 00:12:34,138
which gives you<font color="#E5E5E5"> a sequential function</font>

283
00:12:32,130 --> 00:12:35,910
<font color="#E5E5E5">but not one</font><font color="#CCCCCC"> that naturally admits a way</font>

284
00:12:34,139 --> 00:12:38,459
of proving correctness of<font color="#E5E5E5"> the</font>

285
00:12:35,910 --> 00:12:40,620
computation but we can just<font color="#CCCCCC"> combine</font><font color="#E5E5E5"> this</font>

286
00:12:38,459 --> 00:12:43,888
generically with verifiable computation

287
00:12:40,620 --> 00:12:45,839
which gives you a way of<font color="#E5E5E5"> producing a</font>

288
00:12:43,889 --> 00:12:48,839
proof<font color="#CCCCCC"> that a computation was done</font>

289
00:12:45,839 --> 00:12:50,970
correctly<font color="#E5E5E5"> what is the problem with just</font>

290
00:12:48,839 --> 00:12:53,940
<font color="#E5E5E5">say using a snark or a Stark for this</font>

291
00:12:50,970 --> 00:12:56,550
well the proof generation is much slower

292
00:12:53,940 --> 00:12:58,800
than<font color="#CCCCCC"> the hash chain itself</font><font color="#E5E5E5"> certainly</font>

293
00:12:56,550 --> 00:13:02,099
<font color="#CCCCCC">without massive</font><font color="#E5E5E5"> parallelism</font><font color="#CCCCCC"> to speed</font><font color="#E5E5E5"> up</font>

294
00:12:58,800 --> 00:13:04,680
the proof generation<font color="#E5E5E5"> and in terms of</font>

295
00:13:02,100 --> 00:13:06,240
security<font color="#CCCCCC"> this means</font><font color="#E5E5E5"> that the adversary</font>

296
00:13:04,680 --> 00:13:09,510
who is<font color="#E5E5E5"> not required to put out the proof</font>

297
00:13:06,240 --> 00:13:12,000
<font color="#E5E5E5">but only to compute the</font><font color="#CCCCCC"> output</font><font color="#E5E5E5"> Y will be</font>

298
00:13:09,510 --> 00:13:14,130
able to compute much faster than the

299
00:13:12,000 --> 00:13:17,189
honest<font color="#E5E5E5"> evil algorithm which also has to</font>

300
00:13:14,130 --> 00:13:19,439
put<font color="#E5E5E5"> out this proof so ideally we should</font>

301
00:13:17,189 --> 00:13:20,010
<font color="#E5E5E5">have a construction which can derive the</font>

302
00:13:19,439 --> 00:13:23,689
proof

303
00:13:20,010 --> 00:13:25,950
and the result<font color="#E5E5E5"> roughly at the</font><font color="#CCCCCC"> same</font><font color="#E5E5E5"> time</font>

304
00:13:23,690 --> 00:13:27,930
so the next<font color="#CCCCCC"> idea would be to use</font>

305
00:13:25,950 --> 00:13:30,210
<font color="#E5E5E5">incrementally verifiable computation</font>

306
00:13:27,930 --> 00:13:32,160
which is similar to<font color="#CCCCCC"> verifiable</font>

307
00:13:30,210 --> 00:13:33,810
computation<font color="#E5E5E5"> but allows you to produce</font>

308
00:13:32,160 --> 00:13:39,209
<font color="#E5E5E5">the proof as you're doing a computation</font>

309
00:13:33,810 --> 00:13:41,670
<font color="#E5E5E5">and update it along the way so it's</font>

310
00:13:39,210 --> 00:13:44,190
simply to compute several steps of the

311
00:13:41,670 --> 00:13:46,890
computation then output a proof of

312
00:13:44,190 --> 00:13:49,140
correctness of those then compute some

313
00:13:46,890 --> 00:13:52,140
more steps of the computation and<font color="#E5E5E5"> output</font>

314
00:13:49,140 --> 00:13:54,449
an updated proof which both verifies the

315
00:13:52,140 --> 00:13:57,090
previous proof and the next few<font color="#E5E5E5"> steps of</font>

316
00:13:54,450 --> 00:13:59,220
the computation<font color="#E5E5E5"> and so on and so forth</font>

317
00:13:57,090 --> 00:14:01,230
<font color="#CCCCCC">until you've derived the final</font><font color="#E5E5E5"> result</font>

318
00:13:59,220 --> 00:14:03,930
<font color="#E5E5E5">and the final proof which accumulates</font>

319
00:14:01,230 --> 00:14:05,880
<font color="#CCCCCC">all the intermediary proofs</font><font color="#E5E5E5"> so in theory</font>

320
00:14:03,930 --> 00:14:09,300
this<font color="#CCCCCC"> too would give you this would give</font>

321
00:14:05,880 --> 00:14:11,490
you a<font color="#CCCCCC"> sigma sequential vdf with a very</font>

322
00:14:09,300 --> 00:14:14,520
good Sigma of<font color="#E5E5E5"> T say 1 minus epsilon T</font>

323
00:14:11,490 --> 00:14:17,460
for small Epsilon<font color="#E5E5E5"> but we would really</font>

324
00:14:14,520 --> 00:14:19,800
<font color="#E5E5E5">like to make this</font><font color="#CCCCCC"> practical and relying</font>

325
00:14:17,460 --> 00:14:22,080
on generic<font color="#CCCCCC"> ibc would not necessarily</font>

326
00:14:19,800 --> 00:14:23,729
give you that so the first idea<font color="#E5E5E5"> is just</font>

327
00:14:22,080 --> 00:14:25,860
<font color="#CCCCCC">the natural</font><font color="#E5E5E5"> idea that's used in all</font>

328
00:14:23,730 --> 00:14:27,810
snark applications<font color="#CCCCCC"> well let's first</font>

329
00:14:25,860 --> 00:14:30,330
replace the hash function with something

330
00:14:27,810 --> 00:14:32,219
<font color="#CCCCCC">snart friendly so something which should</font>

331
00:14:30,330 --> 00:14:37,440
have low multiplicative complexity over

332
00:14:32,220 --> 00:14:39,810
<font color="#CCCCCC">a finite field but the second idea is</font><font color="#E5E5E5"> to</font>

333
00:14:37,440 --> 00:14:43,560
<font color="#E5E5E5">replace the hash function with a</font>

334
00:14:39,810 --> 00:14:45,359
permutation<font color="#E5E5E5"> row which is slow to compute</font>

335
00:14:43,560 --> 00:14:48,750
in the forward direction which is the

336
00:14:45,360 --> 00:14:50,940
<font color="#E5E5E5">incurring the delay but much faster</font><font color="#CCCCCC"> or</font>

337
00:14:48,750 --> 00:14:53,550
<font color="#E5E5E5">more specifically has low multiplicative</font>

338
00:14:50,940 --> 00:14:57,300
complexity over<font color="#CCCCCC"> a finite field</font><font color="#E5E5E5"> for the</font>

339
00:14:53,550 --> 00:14:59,400
reverse direction then the snark<font color="#CCCCCC"> or the</font>

340
00:14:57,300 --> 00:15:01,260
<font color="#E5E5E5">stark proof can be generated on</font><font color="#CCCCCC"> the</font>

341
00:14:59,400 --> 00:15:06,630
reverse direction<font color="#E5E5E5"> instead of the forward</font>

342
00:15:01,260 --> 00:15:10,110
direction<font color="#E5E5E5"> so what have we gained by</font>

343
00:15:06,630 --> 00:15:13,050
<font color="#CCCCCC">doing this</font><font color="#E5E5E5"> well the hash function or the</font>

344
00:15:10,110 --> 00:15:15,630
now<font color="#E5E5E5"> row the permutation we're using can</font>

345
00:15:13,050 --> 00:15:17,939
be weaker<font color="#CCCCCC"> than a vdf but still a proto</font>

346
00:15:15,630 --> 00:15:20,730
vdf or something that still has<font color="#E5E5E5"> some</font>

347
00:15:17,940 --> 00:15:22,020
asymmetry<font color="#CCCCCC"> such as the modular square</font>

348
00:15:20,730 --> 00:15:24,360
roots puzzle<font color="#E5E5E5"> that</font><font color="#CCCCCC"> I mentioned before</font>

349
00:15:22,020 --> 00:15:26,220
<font color="#E5E5E5">which</font><font color="#CCCCCC"> is not</font><font color="#E5E5E5"> quite a vdf if it were we</font>

350
00:15:24,360 --> 00:15:28,350
could<font color="#E5E5E5"> just use that on its own but it</font>

351
00:15:26,220 --> 00:15:31,320
does have a symmetry<font color="#E5E5E5"> and therefore can</font>

352
00:15:28,350 --> 00:15:34,630
<font color="#E5E5E5">optimize this generic IVC approach</font>

353
00:15:31,320 --> 00:15:39,580
to be concrete<font color="#E5E5E5"> how would this compare to</font>

354
00:15:34,630 --> 00:15:44,470
<font color="#E5E5E5">using sha-256 well if we had a</font><font color="#CCCCCC"> shot</font><font color="#E5E5E5"> 256</font>

355
00:15:39,580 --> 00:15:45,700
<font color="#E5E5E5">chain then well let me tell you how the</font>

356
00:15:44,470 --> 00:15:47,290
square<font color="#E5E5E5"> roots chain would work so the</font>

357
00:15:45,700 --> 00:15:49,810
square roots chain would<font color="#E5E5E5"> be over FP</font>

358
00:15:47,290 --> 00:15:51,849
squared and we do need to<font color="#E5E5E5"> add a</font>

359
00:15:49,810 --> 00:15:53,529
nonlinear permutation between each of

360
00:15:51,850 --> 00:15:54,910
<font color="#E5E5E5">the square roots for reasons that I</font>

361
00:15:53,529 --> 00:15:57,220
won't<font color="#E5E5E5"> go</font><font color="#CCCCCC"> into otherwise there is a</font>

362
00:15:54,910 --> 00:15:59,050
shortcut<font color="#E5E5E5"> so we'll do two square roots</font>

363
00:15:57,220 --> 00:16:01,450
over<font color="#E5E5E5"> F P squared so that we can add a</font>

364
00:15:59,050 --> 00:16:03,069
simple<font color="#CCCCCC"> nonlinear permutation such as a</font>

365
00:16:01,450 --> 00:16:05,470
coordinate swap that will not incur

366
00:16:03,070 --> 00:16:09,550
additional complexity in the<font color="#CCCCCC"> arithmetic</font>

367
00:16:05,470 --> 00:16:11,350
circuit so the<font color="#E5E5E5"> sha-256 chain would have</font>

368
00:16:09,550 --> 00:16:13,750
<font color="#CCCCCC">twenty-seven</font><font color="#E5E5E5"> thousand</font><font color="#CCCCCC"> nine</font><font color="#E5E5E5"> hundred and</font>

369
00:16:11,350 --> 00:16:15,850
<font color="#E5E5E5">four gates per hash function which would</font>

370
00:16:13,750 --> 00:16:17,740
<font color="#E5E5E5">need to go into</font><font color="#CCCCCC"> the snark</font><font color="#E5E5E5"> whereas</font>

371
00:16:15,850 --> 00:16:21,420
evaluating the reverse of<font color="#E5E5E5"> the square</font>

372
00:16:17,740 --> 00:16:21,420
root chain would just involve<font color="#E5E5E5"> four gates</font>

373
00:16:23,880 --> 00:16:27,100
perhaps really<font color="#E5E5E5"> this motivates the</font>

374
00:16:25,779 --> 00:16:29,189
question of whether we<font color="#CCCCCC"> can come up with</font>

375
00:16:27,100 --> 00:16:32,770
<font color="#E5E5E5">even better asymmetric permutations</font>

376
00:16:29,190 --> 00:16:36,880
which are beyond the classical square

377
00:16:32,770 --> 00:16:39,339
roots or equivalently cube roots<font color="#CCCCCC"> puzzles</font>

378
00:16:36,880 --> 00:16:41,620
<font color="#E5E5E5">so more</font><font color="#CCCCCC"> generally you can think of</font><font color="#E5E5E5"> this</font>

379
00:16:39,339 --> 00:16:44,350
as an<font color="#CCCCCC"> example of injective polynomial</font>

380
00:16:41,620 --> 00:16:47,500
<font color="#E5E5E5">inversion where the slow</font><font color="#CCCCCC"> direction is to</font>

381
00:16:44,350 --> 00:16:49,779
find the<font color="#CCCCCC"> inverse of a point</font><font color="#E5E5E5"> and the fast</font>

382
00:16:47,500 --> 00:16:52,240
is to<font color="#E5E5E5"> evaluate the polynomial in the</font>

383
00:16:49,779 --> 00:16:53,920
forward<font color="#E5E5E5"> direction even more generally we</font>

384
00:16:52,240 --> 00:16:57,399
could consider injective rational maps

385
00:16:53,920 --> 00:16:59,500
on algebraic sets<font color="#E5E5E5"> let's focus in on the</font>

386
00:16:57,399 --> 00:17:01,630
permutation polynomial which is one

387
00:16:59,500 --> 00:17:03,220
example<font color="#E5E5E5"> of this so it's</font><font color="#CCCCCC"> just a</font>

388
00:17:01,630 --> 00:17:07,059
<font color="#CCCCCC">polynomial on a</font><font color="#E5E5E5"> finite field which</font>

389
00:17:03,220 --> 00:17:09,880
permits the field<font color="#E5E5E5"> and because it's a</font>

390
00:17:07,059 --> 00:17:11,980
permutation inverting or<font color="#E5E5E5"> is equivalent</font>

391
00:17:09,880 --> 00:17:15,040
<font color="#CCCCCC">to finding a root say of f of X minus C</font>

392
00:17:11,980 --> 00:17:18,610
and<font color="#E5E5E5"> this can be done</font><font color="#CCCCCC"> using computing a</font>

393
00:17:15,040 --> 00:17:22,899
polynomial GCD which we know how to do

394
00:17:18,609 --> 00:17:25,329
using the Euclidean GCD algorithm which

395
00:17:22,900 --> 00:17:27,579
involves<font color="#E5E5E5"> D sequential steps where in</font>

396
00:17:25,329 --> 00:17:30,490
each<font color="#E5E5E5"> step</font><font color="#CCCCCC"> there</font><font color="#E5E5E5"> are D parallel</font>

397
00:17:27,579 --> 00:17:33,159
arithmetic<font color="#E5E5E5"> operations</font><font color="#CCCCCC"> I should</font><font color="#E5E5E5"> mention</font>

398
00:17:30,490 --> 00:17:34,870
that<font color="#E5E5E5"> there is also an NC algorithm or a</font>

399
00:17:33,160 --> 00:17:38,559
log squared depth algorithm for<font color="#E5E5E5"> doing</font>

400
00:17:34,870 --> 00:17:41,320
this but it requires a large<font color="#CCCCCC"> amount of</font>

401
00:17:38,559 --> 00:17:43,899
parallelism<font color="#CCCCCC"> so</font><font color="#E5E5E5"> order</font><font color="#CCCCCC"> of D to the 3.85</font>

402
00:17:41,320 --> 00:17:47,950
parallel processors

403
00:17:43,900 --> 00:17:51,130
so if we were to use<font color="#E5E5E5"> this for a proto</font>

404
00:17:47,950 --> 00:17:54,490
vdf<font color="#E5E5E5"> then the eval procedure would</font>

405
00:17:51,130 --> 00:17:56,920
require<font color="#CCCCCC"> deep parallelism</font><font color="#E5E5E5"> in order to</font>

406
00:17:54,490 --> 00:17:59,320
prevent the adversary from gaining<font color="#CCCCCC"> a</font>

407
00:17:56,920 --> 00:18:03,520
very large speed up over the honest eval

408
00:17:59,320 --> 00:18:05,409
procedure<font color="#E5E5E5"> and at the same time we would</font>

409
00:18:03,520 --> 00:18:07,510
<font color="#E5E5E5">need</font><font color="#CCCCCC"> to set D so that it's large enough</font>

410
00:18:05,410 --> 00:18:09,309
so<font color="#CCCCCC"> that D to the</font><font color="#E5E5E5"> 2.85 parallel</font>

411
00:18:07,510 --> 00:18:10,990
processors are infeasible<font color="#E5E5E5"> for an</font>

412
00:18:09,309 --> 00:18:13,300
adversary<font color="#E5E5E5"> so this</font><font color="#CCCCCC"> doesn't really give</font>

413
00:18:10,990 --> 00:18:15,010
you a theoretical vdf but it does give

414
00:18:13,300 --> 00:18:18,909
you some<font color="#CCCCCC"> kind of weaker form or proto</font>

415
00:18:15,010 --> 00:18:20,740
vdf<font color="#E5E5E5"> and what</font><font color="#CCCCCC"> I didn't say</font><font color="#E5E5E5"> that we</font>

416
00:18:18,910 --> 00:18:24,280
<font color="#CCCCCC">actually</font><font color="#E5E5E5"> have one of these that that</font>

417
00:18:20,740 --> 00:18:26,050
that works but the ideal holy grail of

418
00:18:24,280 --> 00:18:28,350
<font color="#E5E5E5">permutation polynomials would be one</font>

419
00:18:26,050 --> 00:18:30,428
which has some tuna<font color="#CCCCCC"> bleah large degree</font>

420
00:18:28,350 --> 00:18:32,439
<font color="#E5E5E5">independent of the field size remember</font>

421
00:18:30,429 --> 00:18:34,600
the field size needs<font color="#E5E5E5"> to be exponential</font>

422
00:18:32,440 --> 00:18:36,850
in size so the degree can't be the size

423
00:18:34,600 --> 00:18:39,879
of the field<font color="#E5E5E5"> otherwise</font><font color="#CCCCCC"> there's</font>

424
00:18:36,850 --> 00:18:41,740
brute-force attacks<font color="#E5E5E5"> it should be fast to</font>

425
00:18:39,880 --> 00:18:43,690
evaluate so<font color="#E5E5E5"> for example a sparse</font>

426
00:18:41,740 --> 00:18:46,390
polynomial which can be evaluated<font color="#E5E5E5"> in log</font>

427
00:18:43,690 --> 00:18:48,790
<font color="#E5E5E5">D complexity and there's no faster</font><font color="#CCCCCC"> way</font>

428
00:18:46,390 --> 00:18:50,590
to invert<font color="#E5E5E5"> it other than computing the</font>

429
00:18:48,790 --> 00:18:53,649
polynomial GCD which is inherently

430
00:18:50,590 --> 00:18:57,699
sequential<font color="#E5E5E5"> in the degree so if we were</font>

431
00:18:53,650 --> 00:19:00,640
to do this then this would give you a a

432
00:18:57,700 --> 00:19:06,040
puzzle which for which eval and verify

433
00:19:00,640 --> 00:19:07,750
have an exponential gap between them it

434
00:19:06,040 --> 00:19:10,000
turns out that permutation polynomials

435
00:19:07,750 --> 00:19:12,640
are an entire field of mathematics<font color="#E5E5E5"> and</font>

436
00:19:10,000 --> 00:19:14,710
there's many<font color="#CCCCCC"> examples of</font><font color="#E5E5E5"> different</font><font color="#CCCCCC"> kinds</font>

437
00:19:12,640 --> 00:19:17,050
<font color="#E5E5E5">of permutation polynomials</font><font color="#CCCCCC"> you know from</font>

438
00:19:14,710 --> 00:19:20,050
the<font color="#CCCCCC"> very</font><font color="#E5E5E5"> simple polynomial X cubed which</font>

439
00:19:17,050 --> 00:19:23,200
clearly<font color="#E5E5E5"> doesn't work for this to more</font>

440
00:19:20,050 --> 00:19:26,649
complex<font color="#E5E5E5"> polynomials sparse</font><font color="#CCCCCC"> polynomials</font><font color="#E5E5E5"> a</font>

441
00:19:23,200 --> 00:19:31,090
very large degree even<font color="#E5E5E5"> degree which</font><font color="#CCCCCC"> is</font>

442
00:19:26,650 --> 00:19:34,390
independent of the<font color="#E5E5E5"> field size but the</font>

443
00:19:31,090 --> 00:19:37,059
problem is that<font color="#E5E5E5"> well nearly</font><font color="#CCCCCC"> all of</font><font color="#E5E5E5"> these</font>

444
00:19:34,390 --> 00:19:39,840
we<font color="#E5E5E5"> can rule out is unsuitable</font><font color="#CCCCCC"> for</font><font color="#E5E5E5"> VDS</font>

445
00:19:37,059 --> 00:19:42,309
either because there is another way<font color="#CCCCCC"> to</font>

446
00:19:39,840 --> 00:19:44,350
invert them<font color="#CCCCCC"> which is not through GCD</font>

447
00:19:42,309 --> 00:19:47,620
which is efficient such<font color="#E5E5E5"> as if it's a</font>

448
00:19:44,350 --> 00:19:49,659
<font color="#E5E5E5">linear map or in this other example</font><font color="#CCCCCC"> here</font>

449
00:19:47,620 --> 00:19:51,820
<font color="#E5E5E5">the degree is the size of the field and</font>

450
00:19:49,660 --> 00:19:52,870
and<font color="#E5E5E5"> that is unsuitable because the field</font>

451
00:19:51,820 --> 00:19:55,750
size needs<font color="#E5E5E5"> to be</font><font color="#CCCCCC"> x been</font>

452
00:19:52,870 --> 00:19:59,709
large but there is this<font color="#E5E5E5"> last standing</font>

453
00:19:55,750 --> 00:20:02,200
<font color="#E5E5E5">class of permutation polynomials</font><font color="#CCCCCC"> that</font><font color="#E5E5E5"> we</font>

454
00:19:59,710 --> 00:20:03,790
haven't been able to attack<font color="#E5E5E5"> yet so it's</font>

455
00:20:02,200 --> 00:20:05,830
a very<font color="#E5E5E5"> interesting open question whether</font>

456
00:20:03,790 --> 00:20:08,139
<font color="#CCCCCC">this indeed could be a suitable</font>

457
00:20:05,830 --> 00:20:10,350
permutation polynomial for a vdf

458
00:20:08,140 --> 00:20:14,860
application

459
00:20:10,350 --> 00:20:16,809
so to<font color="#E5E5E5"> summarize when you take either an</font>

460
00:20:14,860 --> 00:20:18,070
underlying permutation polynomial or the

461
00:20:16,809 --> 00:20:21,670
square roots<font color="#E5E5E5"> and combine it</font><font color="#CCCCCC"> with the</font>

462
00:20:18,070 --> 00:20:24,610
<font color="#E5E5E5">snark or</font><font color="#CCCCCC"> Stark IVC approach you get a</font>

463
00:20:21,670 --> 00:20:26,830
<font color="#E5E5E5">vdf which has verification complexity</font>

464
00:20:24,610 --> 00:20:29,139
order of log<font color="#E5E5E5"> T snarks each snark has</font>

465
00:20:26,830 --> 00:20:31,960
constant complexity to verify so order

466
00:20:29,140 --> 00:20:35,620
<font color="#E5E5E5">of log T complexity overall it has proof</font>

467
00:20:31,960 --> 00:20:37,090
size also<font color="#E5E5E5"> order of log T it is</font><font color="#CCCCCC"> secure</font>

468
00:20:35,620 --> 00:20:39,250
under the assumption that the underlying

469
00:20:37,090 --> 00:20:41,350
chain is sequential<font color="#CCCCCC"> whether</font><font color="#E5E5E5"> this</font><font color="#CCCCCC"> is a</font>

470
00:20:39,250 --> 00:20:44,230
square root chain or an ideal

471
00:20:41,350 --> 00:20:46,000
permutation polynomial chain and also

472
00:20:44,230 --> 00:20:46,780
based on<font color="#E5E5E5"> the security of the snarks or</font>

473
00:20:46,000 --> 00:20:50,890
the<font color="#CCCCCC"> Starks</font>

474
00:20:46,780 --> 00:20:53,830
does it involve trusted<font color="#CCCCCC"> setup well none</font>

475
00:20:50,890 --> 00:20:56,800
if you use Starks<font color="#E5E5E5"> but even if we were to</font>

476
00:20:53,830 --> 00:20:59,110
<font color="#CCCCCC">use snarks and have a trusted</font><font color="#E5E5E5"> setup note</font>

477
00:20:56,800 --> 00:21:01,000
that the trusted<font color="#CCCCCC"> setup is is is</font><font color="#E5E5E5"> really</font>

478
00:20:59,110 --> 00:21:05,020
<font color="#E5E5E5">does not impact the sequentiality</font>

479
00:21:01,000 --> 00:21:07,000
security<font color="#E5E5E5"> the sequentiality is not broken</font>

480
00:21:05,020 --> 00:21:08,950
if the trusted<font color="#E5E5E5"> setup is broken</font><font color="#CCCCCC"> it's only</font>

481
00:21:07,000 --> 00:21:13,330
a way of<font color="#E5E5E5"> optimizing the efficiency</font><font color="#CCCCCC"> of</font>

482
00:21:08,950 --> 00:21:14,980
verification and moreover if<font color="#E5E5E5"> we were to</font>

483
00:21:13,330 --> 00:21:17,559
<font color="#E5E5E5">use Starks then possibly this would be</font>

484
00:21:14,980 --> 00:21:19,360
<font color="#E5E5E5">quantum resistant but it's it's not a</font>

485
00:21:17,559 --> 00:21:23,620
simple construction<font color="#E5E5E5"> and that's why I</font>

486
00:21:19,360 --> 00:21:26,050
will mention some<font color="#E5E5E5"> newer vdf from pH</font><font color="#CCCCCC"> sack</font>

487
00:21:23,620 --> 00:21:29,229
<font color="#E5E5E5">and was a loss key that came out</font><font color="#CCCCCC"> very</font>

488
00:21:26,050 --> 00:21:32,080
<font color="#E5E5E5">recently which essentially constructed a</font>

489
00:21:29,230 --> 00:21:34,120
specialized proof of correctness for

490
00:21:32,080 --> 00:21:38,260
exponentiation in a group of unknown

491
00:21:34,120 --> 00:21:39,939
size so the<font color="#E5E5E5"> the</font><font color="#CCCCCC"> VBF</font><font color="#E5E5E5"> eval algorithm is</font>

492
00:21:38,260 --> 00:21:41,740
<font color="#CCCCCC">two on a given challenge hash the</font>

493
00:21:39,940 --> 00:21:46,330
challenge and then raise it<font color="#CCCCCC"> to the two</font>

494
00:21:41,740 --> 00:21:47,950
to<font color="#E5E5E5"> the T which if the group the group's</font>

495
00:21:46,330 --> 00:21:50,770
order is unknown then it requires<font color="#CCCCCC"> T</font>

496
00:21:47,950 --> 00:21:52,360
sequential squarings<font color="#E5E5E5"> we believe and then</font>

497
00:21:50,770 --> 00:21:53,860
the cool thing is<font color="#CCCCCC"> that they</font><font color="#E5E5E5"> are able to</font>

498
00:21:52,360 --> 00:21:56,469
produce a proof of correct

499
00:21:53,860 --> 00:21:59,409
exponentiation<font color="#E5E5E5"> efficiently that can be</font>

500
00:21:56,470 --> 00:22:02,290
verified<font color="#E5E5E5"> efficiently as well so that's</font>

501
00:21:59,410 --> 00:22:05,080
the<font color="#CCCCCC"> end of my talk our paper is on</font>

502
00:22:02,290 --> 00:22:06,820
<font color="#CCCCCC">ePrint and we also have a survey</font><font color="#E5E5E5"> of the</font>

503
00:22:05,080 --> 00:22:10,389
various vdf<font color="#E5E5E5"> construction</font>

504
00:22:06,820 --> 00:22:11,360
from 2018<font color="#CCCCCC"> also</font><font color="#E5E5E5"> an ePrint</font><font color="#CCCCCC"> thank you very</font>

505
00:22:10,389 --> 00:22:15,949
<font color="#E5E5E5">much</font>

506
00:22:11,360 --> 00:22:15,949
[Applause]

