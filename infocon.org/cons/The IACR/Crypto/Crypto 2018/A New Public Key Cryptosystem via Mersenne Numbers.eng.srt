1
00:00:05,520 --> 00:00:11,260
<font color="#CCCCCC">thanks for the introduction</font><font color="#E5E5E5"> and I'll be</font>

2
00:00:09,879 --> 00:00:13,389
speaking about<font color="#E5E5E5"> a new public key</font>

3
00:00:11,260 --> 00:00:15,549
cryptosystem<font color="#E5E5E5"> via</font><font color="#CCCCCC"> merci numbers this</font><font color="#E5E5E5"> is</font>

4
00:00:13,389 --> 00:00:20,770
<font color="#E5E5E5">joint work with</font><font color="#CCCCCC"> Ando</font><font color="#E5E5E5"> and you and upon</font>

5
00:00:15,549 --> 00:00:23,080
<font color="#E5E5E5">Prakash and</font><font color="#CCCCCC"> me close Santa</font><font color="#E5E5E5"> okay so so we</font>

6
00:00:20,770 --> 00:00:24,939
started trading public key crypto back

7
00:00:23,080 --> 00:00:27,310
in 1976 starting with the breakthrough

8
00:00:24,939 --> 00:00:30,279
<font color="#E5E5E5">result of</font><font color="#CCCCCC"> defeating Hellman and there</font>

9
00:00:27,310 --> 00:00:33,430
were several candidates over over these

10
00:00:30,279 --> 00:00:35,860
four decades let's say about but more

11
00:00:33,430 --> 00:00:38,580
recently the focus<font color="#E5E5E5"> has shifted a little</font>

12
00:00:35,860 --> 00:00:41,379
bit<font color="#CCCCCC"> to more advanced primitives and</font>

13
00:00:38,580 --> 00:00:44,199
<font color="#E5E5E5">although maybe public key crypto was a</font>

14
00:00:41,379 --> 00:00:46,960
very important object of study<font color="#E5E5E5"> maybe</font>

15
00:00:44,199 --> 00:00:50,049
maybe in seventies or eighties<font color="#CCCCCC"> so I mean</font>

16
00:00:46,960 --> 00:00:53,170
this<font color="#E5E5E5"> is evident from the</font><font color="#CCCCCC"> fact that for a</font>

17
00:00:50,049 --> 00:00:57,610
lack of company this this<font color="#CCCCCC"> dog was put in</font>

18
00:00:53,170 --> 00:01:01,390
a section titled<font color="#E5E5E5"> various topics</font><font color="#CCCCCC"> in</font><font color="#E5E5E5"> this</font>

19
00:00:57,610 --> 00:01:03,820
work<font color="#E5E5E5"> we'll</font><font color="#CCCCCC"> be proposing a new public key</font>

20
00:01:01,390 --> 00:01:06,630
cryptosystem<font color="#E5E5E5"> that we believe is probably</font>

21
00:01:03,820 --> 00:01:08,799
<font color="#E5E5E5">simpler than what was already known and</font>

22
00:01:06,630 --> 00:01:14,229
we also believe<font color="#CCCCCC"> that</font><font color="#E5E5E5"> it is secure</font>

23
00:01:08,799 --> 00:01:17,920
against quantum quantum attacks and<font color="#CCCCCC"> ok</font>

24
00:01:14,230 --> 00:01:21,880
so so this crypto system can be

25
00:01:17,920 --> 00:01:25,540
classified<font color="#E5E5E5"> in this family what we called</font>

26
00:01:21,880 --> 00:01:27,820
the ring and noise family<font color="#E5E5E5"> so</font><font color="#CCCCCC"> there</font><font color="#E5E5E5"> you</font>

27
00:01:25,540 --> 00:01:29,740
have<font color="#E5E5E5"> a certain ring I mean the key</font>

28
00:01:27,820 --> 00:01:31,839
<font color="#E5E5E5">generation algorithm starts with a</font>

29
00:01:29,740 --> 00:01:35,919
certain ring does some operation then

30
00:01:31,840 --> 00:01:37,659
adds probably some small noise so a lot

31
00:01:35,920 --> 00:01:40,420
of crypto systems can be<font color="#E5E5E5"> classified in</font>

32
00:01:37,659 --> 00:01:42,970
in this class<font color="#E5E5E5"> for</font><font color="#CCCCCC"> example the NT reo</font>

33
00:01:40,420 --> 00:01:45,250
crypto system code base crypto systems

34
00:01:42,970 --> 00:01:48,460
of learning<font color="#E5E5E5"> where there are space</font>

35
00:01:45,250 --> 00:01:49,870
<font color="#CCCCCC">creeper systems so many of them but we</font>

36
00:01:48,460 --> 00:01:51,669
<font color="#E5E5E5">are talking about a different ring here</font>

37
00:01:49,870 --> 00:01:54,070
so the ring that<font color="#E5E5E5"> we'll be talking about</font>

38
00:01:51,670 --> 00:01:58,810
is<font color="#E5E5E5"> the ring of integers modulo a</font>

39
00:01:54,070 --> 00:02:01,020
Mersenne<font color="#CCCCCC"> prime and the noise is</font><font color="#E5E5E5"> also</font>

40
00:01:58,810 --> 00:02:06,400
different<font color="#E5E5E5"> so the noise function would be</font>

41
00:02:01,020 --> 00:02:08,079
Hamming weight<font color="#E5E5E5"> modulo this prime so what</font>

42
00:02:06,400 --> 00:02:10,149
I'm all seen<font color="#E5E5E5"> Prime's so these are</font>

43
00:02:08,080 --> 00:02:13,720
<font color="#E5E5E5">Prime's of the form 2 to</font><font color="#CCCCCC"> the</font><font color="#E5E5E5"> N minus</font><font color="#CCCCCC"> 1</font>

44
00:02:10,149 --> 00:02:16,750
where<font color="#CCCCCC"> n is also a prime so these prime</font>

45
00:02:13,720 --> 00:02:18,069
<font color="#CCCCCC">numbers were first studied by</font><font color="#E5E5E5"> marine</font>

46
00:02:16,750 --> 00:02:19,900
<font color="#CCCCCC">mersin</font>

47
00:02:18,069 --> 00:02:22,810
who was a French<font color="#CCCCCC"> mathematician and this</font>

48
00:02:19,900 --> 00:02:24,310
this<font color="#E5E5E5"> is where the name comes from</font><font color="#CCCCCC"> and he</font>

49
00:02:22,810 --> 00:02:27,940
<font color="#CCCCCC">studied them back in the 17th century</font>

50
00:02:24,310 --> 00:02:29,860
<font color="#CCCCCC">and as I mentioned the main advantage of</font>

51
00:02:27,940 --> 00:02:32,409
<font color="#E5E5E5">a</font><font color="#CCCCCC"> cryptosystem</font><font color="#E5E5E5"> is going to be its</font>

52
00:02:29,860 --> 00:02:34,480
simplicity<font color="#CCCCCC"> so I hope</font><font color="#E5E5E5"> I'll be able to</font>

53
00:02:32,409 --> 00:02:41,109
<font color="#E5E5E5">convince you during</font><font color="#CCCCCC"> this</font><font color="#E5E5E5"> stuff that it's</font>

54
00:02:34,480 --> 00:02:43,540
really simple<font color="#E5E5E5"> so again so the ring would</font>

55
00:02:41,110 --> 00:02:46,299
be<font color="#E5E5E5"> the ring of integers modulo the</font>

56
00:02:43,540 --> 00:02:51,040
<font color="#CCCCCC">mersin prime so the prime of</font><font color="#E5E5E5"> the form 2</font>

57
00:02:46,299 --> 00:02:53,099
<font color="#CCCCCC">to the N minus</font><font color="#E5E5E5"> 1 and I</font><font color="#CCCCCC"> buy R</font><font color="#E5E5E5"> P of X I'll</font>

58
00:02:51,040 --> 00:02:56,739
denote the representation of X in<font color="#E5E5E5"> this</font>

59
00:02:53,099 --> 00:02:59,738
in this ring so it's an integer between

60
00:02:56,739 --> 00:03:01,629
0 to P minus<font color="#CCCCCC"> 1 and the Hamming weight of</font>

61
00:02:59,739 --> 00:03:05,290
X is the<font color="#CCCCCC"> number of</font><font color="#E5E5E5"> ones in the binary</font>

62
00:03:01,629 --> 00:03:07,120
<font color="#CCCCCC">representation of</font><font color="#E5E5E5"> X modulo this prime so</font>

63
00:03:05,290 --> 00:03:11,709
modulo is<font color="#CCCCCC"> prime this the binary</font>

64
00:03:07,120 --> 00:03:13,120
representation has<font color="#E5E5E5"> n bits and Hamming</font>

65
00:03:11,709 --> 00:03:17,950
weight of X is the<font color="#E5E5E5"> number of ones in</font>

66
00:03:13,120 --> 00:03:19,959
<font color="#E5E5E5">this representation so some important</font>

67
00:03:17,950 --> 00:03:21,310
properties<font color="#E5E5E5"> before I get to the crypto</font>

68
00:03:19,959 --> 00:03:24,880
system<font color="#E5E5E5"> there here some important</font>

69
00:03:21,310 --> 00:03:27,609
properties<font color="#E5E5E5"> of arithmetic modulo Mersenne</font>

70
00:03:24,880 --> 00:03:31,840
<font color="#E5E5E5">Prime's</font><font color="#CCCCCC"> the so would kind of justify why</font>

71
00:03:27,609 --> 00:03:34,930
we<font color="#E5E5E5"> are using Mersin primes so first of</font>

72
00:03:31,840 --> 00:03:37,750
all the Hamming weight of the sum of<font color="#CCCCCC"> two</font>

73
00:03:34,930 --> 00:03:39,459
<font color="#E5E5E5">in two integers X X and</font><font color="#CCCCCC"> Y is upper</font>

74
00:03:37,750 --> 00:03:43,299
bounded<font color="#CCCCCC"> by the Hamming weight of X plus</font>

75
00:03:39,459 --> 00:03:45,160
<font color="#E5E5E5">the Hamming weight of Y notice</font><font color="#CCCCCC"> that I</font><font color="#E5E5E5"> am</font>

76
00:03:43,299 --> 00:03:47,829
talking about<font color="#E5E5E5"> integer addition and not</font>

77
00:03:45,160 --> 00:03:50,290
bitwise XOR so we cannot<font color="#CCCCCC"> really conclude</font>

78
00:03:47,829 --> 00:03:52,900
this from the<font color="#E5E5E5"> triangle inequality</font><font color="#CCCCCC"> but</font><font color="#E5E5E5"> it</font>

79
00:03:50,290 --> 00:03:56,010
is still fairly simple to to argue this

80
00:03:52,900 --> 00:03:58,260
we can<font color="#CCCCCC"> think</font><font color="#E5E5E5"> of it</font><font color="#CCCCCC"> like</font><font color="#E5E5E5"> basically adding</font>

81
00:03:56,010 --> 00:04:00,280
strings of Hamming weight<font color="#E5E5E5"> one</font>

82
00:03:58,260 --> 00:04:02,679
sequentially so inductors you can prove

83
00:04:00,280 --> 00:04:07,090
this<font color="#E5E5E5"> by induction and you can see as a</font>

84
00:04:02,680 --> 00:04:10,030
simple<font color="#E5E5E5"> example</font><font color="#CCCCCC"> when you add at this one</font>

85
00:04:07,090 --> 00:04:13,030
string of<font color="#E5E5E5"> Hamming weight one to this</font>

86
00:04:10,030 --> 00:04:16,180
string<font color="#CCCCCC"> do what you will be doing</font><font color="#E5E5E5"> is</font>

87
00:04:13,030 --> 00:04:18,399
<font color="#E5E5E5">basically looking at</font><font color="#CCCCCC"> the at the first</font>

88
00:04:16,180 --> 00:04:20,380
<font color="#CCCCCC">zero</font><font color="#E5E5E5"> and so first of</font><font color="#CCCCCC"> all you look</font><font color="#E5E5E5"> at the</font>

89
00:04:18,399 --> 00:04:22,060
<font color="#E5E5E5">corresponding one in this position and</font>

90
00:04:20,380 --> 00:04:25,120
then you look at the first zero<font color="#CCCCCC"> before</font>

91
00:04:22,060 --> 00:04:28,840
this and then you replace<font color="#E5E5E5"> the 0 1 1</font><font color="#CCCCCC"> 1 by</font>

92
00:04:25,120 --> 00:04:31,240
1 0 0 0<font color="#E5E5E5"> so the Hamming weight would</font>

93
00:04:28,840 --> 00:04:33,698
typically go down but<font color="#E5E5E5"> it can it can</font>

94
00:04:31,240 --> 00:04:36,490
go up by at<font color="#CCCCCC"> most one when you do this</font>

95
00:04:33,699 --> 00:04:39,819
<font color="#CCCCCC">operation because you are replacing some</font>

96
00:04:36,490 --> 00:04:42,520
t minus 1 0 t<font color="#CCCCCC"> minus</font><font color="#E5E5E5"> 1 months and 1 0 by</font>

97
00:04:39,819 --> 00:04:44,500
t minus 1 0<font color="#CCCCCC"> and 1</font><font color="#E5E5E5"> 1 so Hamming weight is</font>

98
00:04:42,520 --> 00:04:46,990
going<font color="#E5E5E5"> to not going to increase by more</font>

99
00:04:44,500 --> 00:04:48,610
<font color="#E5E5E5">than</font><font color="#CCCCCC"> 1</font><font color="#E5E5E5"> so by an induction we can see</font>

100
00:04:46,990 --> 00:04:50,139
that the Hamming weight of X plus y is

101
00:04:48,610 --> 00:04:53,949
Hamming is upper bounded by<font color="#E5E5E5"> Hamming</font>

102
00:04:50,139 --> 00:04:55,270
weight of X plus Hamming weight of<font color="#CCCCCC"> y</font><font color="#E5E5E5"> the</font>

103
00:04:53,949 --> 00:04:58,569
second property is<font color="#CCCCCC"> that when you</font>

104
00:04:55,270 --> 00:05:02,109
multiply X by a power<font color="#E5E5E5"> of 2 so x times 2</font>

105
00:04:58,569 --> 00:05:04,720
to the<font color="#E5E5E5"> I this is basically just a cyclic</font>

106
00:05:02,110 --> 00:05:09,310
shift of X because<font color="#CCCCCC"> we are doing it</font>

107
00:05:04,720 --> 00:05:12,669
modulo 2 to the<font color="#CCCCCC"> n minus 1 so so 2 to</font><font color="#E5E5E5"> the</font>

108
00:05:09,310 --> 00:05:14,380
<font color="#E5E5E5">N is is congruent to 1 mod 2 to the</font><font color="#CCCCCC"> n</font>

109
00:05:12,669 --> 00:05:17,198
<font color="#CCCCCC">minus</font><font color="#E5E5E5"> 1 and</font><font color="#CCCCCC"> so 2 to the n plus I is</font>

110
00:05:14,380 --> 00:05:18,969
congruent to 2 to<font color="#CCCCCC"> the I mod 2 to the N</font>

111
00:05:17,199 --> 00:05:20,380
minus<font color="#E5E5E5"> 1</font><font color="#CCCCCC"> so which means</font><font color="#E5E5E5"> when you do</font><font color="#CCCCCC"> X</font>

112
00:05:18,970 --> 00:05:22,330
times 2 to the<font color="#CCCCCC"> I it's just a cyclic</font>

113
00:05:20,380 --> 00:05:24,159
shift of X so Hamming weight of X times

114
00:05:22,330 --> 00:05:27,430
2 to the<font color="#CCCCCC"> ice is just the Hamming weight</font>

115
00:05:24,159 --> 00:05:29,889
of X and combining<font color="#E5E5E5"> these properties 1</font>

116
00:05:27,430 --> 00:05:31,240
<font color="#CCCCCC">and 2 we</font><font color="#E5E5E5"> get the third one which</font><font color="#CCCCCC"> is</font><font color="#E5E5E5"> that</font>

117
00:05:29,889 --> 00:05:34,930
the Hamming weight<font color="#CCCCCC"> of</font><font color="#E5E5E5"> the product of two</font>

118
00:05:31,240 --> 00:05:36,849
<font color="#CCCCCC">strings</font><font color="#E5E5E5"> X and</font><font color="#CCCCCC"> Y is upper bounded by the</font>

119
00:05:34,930 --> 00:05:40,570
product of<font color="#E5E5E5"> the Hamming weight of X and</font>

120
00:05:36,849 --> 00:05:42,610
the Hamming weight of Y and this<font color="#E5E5E5"> is</font>

121
00:05:40,570 --> 00:05:45,009
because just product can<font color="#CCCCCC"> be so</font><font color="#E5E5E5"> product</font>

122
00:05:42,610 --> 00:05:48,699
of Hamming weight of<font color="#CCCCCC"> x times y so x</font>

123
00:05:45,009 --> 00:05:52,000
times<font color="#E5E5E5"> y can be just seen as X</font><font color="#CCCCCC"> I mean</font>

124
00:05:48,699 --> 00:05:54,520
<font color="#CCCCCC">basically adding let's say the Hamming</font>

125
00:05:52,000 --> 00:05:59,169
weight of Y is some H so we are<font color="#E5E5E5"> adding H</font>

126
00:05:54,520 --> 00:06:02,650
cyclic shifts of Y so sorry<font color="#CCCCCC"> 8 cyclic</font>

127
00:05:59,169 --> 00:06:04,900
shifts of X and<font color="#E5E5E5"> so it is so using the</font>

128
00:06:02,650 --> 00:06:06,818
producing the first property we get that

129
00:06:04,900 --> 00:06:09,280
the Hamming weight of<font color="#E5E5E5"> x times y is upper</font>

130
00:06:06,819 --> 00:06:11,349
bounded<font color="#E5E5E5"> by Hamming weight of X times</font>

131
00:06:09,280 --> 00:06:14,109
Hamming weight of<font color="#CCCCCC"> Y and the fourth</font>

132
00:06:11,349 --> 00:06:16,870
property is that when you take the

133
00:06:14,110 --> 00:06:20,560
<font color="#CCCCCC">negative</font><font color="#E5E5E5"> of X the Hamming weight just</font>

134
00:06:16,870 --> 00:06:23,199
becomes n minus Hamming weight of X to

135
00:06:20,560 --> 00:06:25,900
see this notice<font color="#E5E5E5"> that when you look at</font>

136
00:06:23,199 --> 00:06:30,729
the binary<font color="#E5E5E5"> representation</font><font color="#CCCCCC"> of X and the</font>

137
00:06:25,900 --> 00:06:34,060
<font color="#E5E5E5">binary representation</font><font color="#CCCCCC"> of minus X if you</font>

138
00:06:30,729 --> 00:06:36,280
if you add them so you will get an all

139
00:06:34,060 --> 00:06:38,169
one string because all one string<font color="#CCCCCC"> is</font>

140
00:06:36,280 --> 00:06:42,400
just<font color="#CCCCCC"> two to the n minus</font><font color="#E5E5E5"> 1 in binary</font>

141
00:06:38,169 --> 00:06:44,909
representation so it is<font color="#E5E5E5"> just</font><font color="#CCCCCC"> 0 but 2 to</font>

142
00:06:42,400 --> 00:06:44,909
the N minus<font color="#E5E5E5"> 1</font>

143
00:06:45,190 --> 00:06:52,060
so so basically<font color="#CCCCCC"> minus X is just going to</font>

144
00:06:48,700 --> 00:06:55,860
be the complement of<font color="#E5E5E5"> X when you look at</font>

145
00:06:52,060 --> 00:06:58,840
it as in binary<font color="#E5E5E5"> representation okay so</font>

146
00:06:55,860 --> 00:07:00,670
to start<font color="#CCCCCC"> with I'll give a simple</font>

147
00:06:58,840 --> 00:07:05,369
<font color="#E5E5E5">encryption scheme which is just</font>

148
00:07:00,670 --> 00:07:07,780
encrypting the string bit by bit<font color="#E5E5E5"> in so</font>

149
00:07:05,370 --> 00:07:11,710
so we are<font color="#E5E5E5"> going to just encrypt one bit</font>

150
00:07:07,780 --> 00:07:16,539
<font color="#E5E5E5">so so P is the prime</font><font color="#CCCCCC"> two to the N minus</font>

151
00:07:11,710 --> 00:07:19,180
<font color="#E5E5E5">1 H is a parameter which is going to be</font>

152
00:07:16,540 --> 00:07:24,880
a bound on<font color="#E5E5E5"> the Hamming weight so</font><font color="#CCCCCC"> f and G</font>

153
00:07:19,180 --> 00:07:26,590
<font color="#CCCCCC">are two numbers mod P with few I mean</font>

154
00:07:24,880 --> 00:07:28,510
<font color="#E5E5E5">ones in the binary representation so</font>

155
00:07:26,590 --> 00:07:30,609
they have small Hamming weight<font color="#E5E5E5"> and then</font>

156
00:07:28,510 --> 00:07:35,710
we take the reciprocal<font color="#E5E5E5"> to take their</font>

157
00:07:30,610 --> 00:07:37,360
ratio<font color="#E5E5E5"> so H is</font><font color="#CCCCCC"> F divided by G</font><font color="#E5E5E5"> modulo P</font><font color="#CCCCCC"> so</font>

158
00:07:35,710 --> 00:07:39,280
the public key<font color="#E5E5E5"> is going to be H and the</font>

159
00:07:37,360 --> 00:07:41,320
private key<font color="#CCCCCC"> is going to</font><font color="#E5E5E5"> be F comma G and</font>

160
00:07:39,280 --> 00:07:44,200
the hard problem that<font color="#E5E5E5"> we are</font><font color="#CCCCCC"> going</font><font color="#E5E5E5"> to</font>

161
00:07:41,320 --> 00:07:47,980
basically<font color="#E5E5E5"> base our crypto system on is</font>

162
00:07:44,200 --> 00:07:50,469
that given<font color="#E5E5E5"> H it is hard to obtain</font><font color="#CCCCCC"> F and</font>

163
00:07:47,980 --> 00:07:52,120
G notice<font color="#CCCCCC"> that even though F and G have</font>

164
00:07:50,470 --> 00:07:54,790
small Hamming weight when you take the

165
00:07:52,120 --> 00:07:57,190
ratio<font color="#E5E5E5"> this number would typically look</font>

166
00:07:54,790 --> 00:08:00,580
<font color="#CCCCCC">very pseudo a</font><font color="#E5E5E5"> pseudo random and you will</font>

167
00:07:57,190 --> 00:08:03,100
not be able<font color="#E5E5E5"> to it would be difficult to</font>

168
00:08:00,580 --> 00:08:04,750
guess<font color="#E5E5E5"> every F and F and G from it and</font>

169
00:08:03,100 --> 00:08:07,750
<font color="#E5E5E5">this is the assumption that we are going</font>

170
00:08:04,750 --> 00:08:10,090
<font color="#CCCCCC">to</font><font color="#E5E5E5"> make that this is a hard problem okay</font>

171
00:08:07,750 --> 00:08:11,890
<font color="#CCCCCC">so here's the encryption scheme as I</font>

172
00:08:10,090 --> 00:08:16,750
said the public<font color="#CCCCCC"> key</font><font color="#E5E5E5"> is age the secret</font>

173
00:08:11,890 --> 00:08:20,409
key<font color="#E5E5E5"> is G and F and</font><font color="#CCCCCC"> G both they both</font>

174
00:08:16,750 --> 00:08:23,620
contain<font color="#CCCCCC"> h at most h once in the</font><font color="#E5E5E5"> binary</font>

175
00:08:20,410 --> 00:08:25,630
representation so<font color="#CCCCCC"> - we want</font><font color="#E5E5E5"> to encrypt a</font>

176
00:08:23,620 --> 00:08:29,050
single bit so you<font color="#E5E5E5"> encrypt the bit</font><font color="#CCCCCC"> zero</font>

177
00:08:25,630 --> 00:08:32,049
what we do is we take H we and we take

178
00:08:29,050 --> 00:08:35,560
two small Hamming weight strings<font color="#CCCCCC"> a and</font><font color="#E5E5E5"> B</font>

179
00:08:32,049 --> 00:08:38,650
and<font color="#E5E5E5"> we compute a times</font><font color="#CCCCCC"> H plus B to</font>

180
00:08:35,559 --> 00:08:43,359
compute<font color="#CCCCCC"> to encrypt one we do the</font>

181
00:08:38,650 --> 00:08:45,370
negation and then the<font color="#E5E5E5"> decryption is</font>

182
00:08:43,360 --> 00:08:47,110
simply basically what we<font color="#CCCCCC"> are</font><font color="#E5E5E5"> going to do</font>

183
00:08:45,370 --> 00:08:50,470
is we're going<font color="#CCCCCC"> to multiply G to the</font>

184
00:08:47,110 --> 00:08:53,710
<font color="#CCCCCC">ciphertext and then</font><font color="#E5E5E5"> it's either going to</font>

185
00:08:50,470 --> 00:08:55,510
<font color="#E5E5E5">be plus a times F plus B times G or it's</font>

186
00:08:53,710 --> 00:08:56,260
going<font color="#E5E5E5"> to be minus of a times F plus B</font>

187
00:08:55,510 --> 00:08:58,240
times<font color="#CCCCCC"> D</font>

188
00:08:56,260 --> 00:09:00,460
and then do you what we do is we just

189
00:08:58,240 --> 00:09:03,730
<font color="#CCCCCC">check</font><font color="#E5E5E5"> the Hamming weight of this G</font><font color="#CCCCCC"> times</font>

190
00:09:00,460 --> 00:09:06,340
<font color="#CCCCCC">C if it</font><font color="#E5E5E5"> is small</font><font color="#CCCCCC"> then we decrypt</font><font color="#E5E5E5"> to</font><font color="#CCCCCC"> 0 if</font>

191
00:09:03,730 --> 00:09:11,470
it<font color="#E5E5E5"> is large then we decrypt</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> 1 so</font>

192
00:09:06,340 --> 00:09:14,760
<font color="#CCCCCC">here's</font><font color="#E5E5E5"> an explanation for the sorry so -</font>

193
00:09:11,470 --> 00:09:18,400
yeah so<font color="#E5E5E5"> here's the here is a</font><font color="#CCCCCC"> tie example</font>

194
00:09:14,760 --> 00:09:20,160
<font color="#E5E5E5">so notice</font><font color="#CCCCCC"> that when we</font><font color="#E5E5E5"> have so if the</font>

195
00:09:18,400 --> 00:09:23,170
numbers are here written<font color="#E5E5E5"> in hexadecimal</font>

196
00:09:20,160 --> 00:09:25,150
<font color="#E5E5E5">form so</font><font color="#CCCCCC"> F</font><font color="#E5E5E5"> and D have small Hamming</font>

197
00:09:23,170 --> 00:09:31,750
weight and when we<font color="#E5E5E5"> take the ratio this</font>

198
00:09:25,150 --> 00:09:34,600
this number looks<font color="#E5E5E5"> fairly random and then</font>

199
00:09:31,750 --> 00:09:36,580
the encryption<font color="#E5E5E5"> again we are taking</font><font color="#CCCCCC"> a and</font>

200
00:09:34,600 --> 00:09:39,730
<font color="#E5E5E5">B to be small Hamming weight and then</font>

201
00:09:36,580 --> 00:09:42,400
the<font color="#CCCCCC"> ciphertext is this when</font><font color="#E5E5E5"> you multiply</font>

202
00:09:39,730 --> 00:09:44,770
G so this is quite<font color="#E5E5E5"> random I mean this</font>

203
00:09:42,400 --> 00:09:46,209
then you multiply G times C then you<font color="#E5E5E5"> get</font>

204
00:09:44,770 --> 00:09:49,030
a low Hamming weight string so<font color="#E5E5E5"> you get</font>

205
00:09:46,210 --> 00:09:51,430
<font color="#CCCCCC">that</font><font color="#E5E5E5"> Hamming weight is small it's less</font>

206
00:09:49,030 --> 00:09:53,680
than less than<font color="#E5E5E5"> half of the maximum</font>

207
00:09:51,430 --> 00:09:57,400
<font color="#CCCCCC">having</font><font color="#E5E5E5"> weight so we conclude that the</font>

208
00:09:53,680 --> 00:09:58,719
bit that<font color="#E5E5E5"> we encrypted was</font><font color="#CCCCCC"> zero</font><font color="#E5E5E5"> so what</font>

209
00:09:57,400 --> 00:10:02,230
<font color="#E5E5E5">is the rationale for this</font>

210
00:09:58,720 --> 00:10:04,960
what is the correctness argument<font color="#E5E5E5"> when</font>

211
00:10:02,230 --> 00:10:06,670
you do T times<font color="#E5E5E5"> a 8 a h plus B which is a</font>

212
00:10:04,960 --> 00:10:09,760
times F plus B times G the Hamming

213
00:10:06,670 --> 00:10:13,120
weight of<font color="#E5E5E5"> this by our properties that we</font>

214
00:10:09,760 --> 00:10:14,830
that we stated<font color="#CCCCCC"> earlier is h times h plus</font>

215
00:10:13,120 --> 00:10:18,730
<font color="#E5E5E5">h</font><font color="#CCCCCC"> time there it is upper bounded by two</font>

216
00:10:14,830 --> 00:10:21,040
times H square<font color="#E5E5E5"> so as long as two times H</font>

217
00:10:18,730 --> 00:10:23,170
square is smaller than<font color="#CCCCCC"> half of n which</font>

218
00:10:21,040 --> 00:10:25,449
<font color="#CCCCCC">means n is</font><font color="#E5E5E5"> bigger than four times H</font>

219
00:10:23,170 --> 00:10:28,630
<font color="#CCCCCC">square</font><font color="#E5E5E5"> we have that the Hamming weight</font>

220
00:10:25,450 --> 00:10:30,490
of<font color="#E5E5E5"> this is less than n</font><font color="#CCCCCC"> over 2 and the</font>

221
00:10:28,630 --> 00:10:34,420
Hamming weight of<font color="#E5E5E5"> the negation is larger</font>

222
00:10:30,490 --> 00:10:41,170
than n over<font color="#CCCCCC"> two</font><font color="#E5E5E5"> so so this implies that</font>

223
00:10:34,420 --> 00:10:43,750
<font color="#CCCCCC">we can decrypt correctly now</font><font color="#E5E5E5"> since since</font>

224
00:10:41,170 --> 00:10:45,939
this version<font color="#CCCCCC"> basically just encrypts one</font>

225
00:10:43,750 --> 00:10:48,420
bit at a time<font color="#E5E5E5"> and so it's quite low so</font>

226
00:10:45,940 --> 00:10:51,220
<font color="#E5E5E5">we want to do something</font><font color="#CCCCCC"> a bit faster</font><font color="#E5E5E5"> so</font>

227
00:10:48,420 --> 00:10:53,349
<font color="#CCCCCC">we now give another version which is</font>

228
00:10:51,220 --> 00:10:57,700
<font color="#E5E5E5">encrypting multiple bits at the same</font>

229
00:10:53,350 --> 00:10:59,520
time<font color="#CCCCCC"> ok so I'm going</font><font color="#E5E5E5"> to change the</font>

230
00:10:57,700 --> 00:11:04,000
public key and private<font color="#E5E5E5"> key slightly so</font>

231
00:10:59,520 --> 00:11:07,720
<font color="#E5E5E5">we had H was F divided by G with which</font>

232
00:11:04,000 --> 00:11:08,540
we<font color="#CCCCCC"> can rewrite as</font><font color="#E5E5E5"> F times minus 1 over h</font>

233
00:11:07,720 --> 00:11:11,600
plus<font color="#CCCCCC"> G</font>

234
00:11:08,540 --> 00:11:13,339
equal to 0 mod p<font color="#E5E5E5"> so this was a</font>

235
00:11:11,600 --> 00:11:15,590
<font color="#CCCCCC">pseudorandom string we can think</font><font color="#E5E5E5"> of it</font>

236
00:11:13,340 --> 00:11:18,980
like<font color="#CCCCCC"> f times R plus G is 0 where</font><font color="#E5E5E5"> R</font><font color="#CCCCCC"> is</font>

237
00:11:15,590 --> 00:11:20,720
<font color="#CCCCCC">some pseudo random string that was</font><font color="#E5E5E5"> the</font>

238
00:11:18,980 --> 00:11:23,090
public key<font color="#E5E5E5"> and now we are going to have</font>

239
00:11:20,720 --> 00:11:24,830
instead<font color="#E5E5E5"> of this big</font><font color="#CCCCCC"> 0 we'll have</font><font color="#E5E5E5"> two</font>

240
00:11:23,090 --> 00:11:26,720
<font color="#E5E5E5">random strings R and T</font><font color="#CCCCCC"> two pseudonyms</font>

241
00:11:24,830 --> 00:11:30,650
<font color="#CCCCCC">rings R and T</font><font color="#E5E5E5"> so which would satisfy</font>

242
00:11:26,720 --> 00:11:34,880
that<font color="#E5E5E5"> T is f times R plus G mod P and R</font>

243
00:11:30,650 --> 00:11:38,000
will in fact be uniformly random<font color="#E5E5E5"> all</font>

244
00:11:34,880 --> 00:11:43,040
<font color="#E5E5E5">right so so then the encryption</font>

245
00:11:38,000 --> 00:11:46,190
procedure is so we now have the public

246
00:11:43,040 --> 00:11:50,300
key<font color="#E5E5E5"> is R and T and the private key is F</font>

247
00:11:46,190 --> 00:11:53,750
and G<font color="#E5E5E5"> so the encryption</font><font color="#CCCCCC"> procedure we</font>

248
00:11:50,300 --> 00:11:56,689
just compute two numbers C 1 and C 2

249
00:11:53,750 --> 00:11:58,970
which<font color="#E5E5E5"> are a times R plus</font><font color="#CCCCCC"> B 1 and a times</font>

250
00:11:56,690 --> 00:12:02,830
T plus<font color="#E5E5E5"> B 2 where a B 1 and B 2 are again</font>

251
00:11:58,970 --> 00:12:07,400
small Hamming weight numbers<font color="#E5E5E5"> and then</font>

252
00:12:02,830 --> 00:12:11,300
for<font color="#E5E5E5"> encrypting a message</font><font color="#CCCCCC"> M we use an</font>

253
00:12:07,400 --> 00:12:14,420
error correction code<font color="#CCCCCC"> e so we encode the</font>

254
00:12:11,300 --> 00:12:18,560
<font color="#CCCCCC">message</font><font color="#E5E5E5"> as G of M and then we XOR it</font>

255
00:12:14,420 --> 00:12:21,770
with C 2 so<font color="#CCCCCC"> then</font><font color="#E5E5E5"> so finally the</font>

256
00:12:18,560 --> 00:12:25,250
encryption of M is<font color="#E5E5E5"> C 1 concatenated</font><font color="#CCCCCC"> with</font>

257
00:12:21,770 --> 00:12:27,500
Z and<font color="#E5E5E5"> then the decryption algorithm</font><font color="#CCCCCC"> what</font>

258
00:12:25,250 --> 00:12:30,740
it does is it computes<font color="#CCCCCC"> F times C 1 and</font>

259
00:12:27,500 --> 00:12:33,320
if we<font color="#CCCCCC"> ignore this ignore</font><font color="#E5E5E5"> this small</font>

260
00:12:30,740 --> 00:12:37,990
additional additional<font color="#E5E5E5"> string then F</font>

261
00:12:33,320 --> 00:12:43,870
times C 1 basically<font color="#E5E5E5"> looks like F times R</font>

262
00:12:37,990 --> 00:12:46,490
so sorry<font color="#E5E5E5"> a times F times R and which is</font>

263
00:12:43,870 --> 00:12:48,500
basically<font color="#E5E5E5"> a times T if we ignore the</font>

264
00:12:46,490 --> 00:12:51,980
small Hamming weight additional noise so

265
00:12:48,500 --> 00:12:53,720
so what<font color="#CCCCCC"> what we hope is that this error</font>

266
00:12:51,980 --> 00:12:57,050
correction code<font color="#E5E5E5"> the decoding procedure</font>

267
00:12:53,720 --> 00:12:58,880
and you<font color="#CCCCCC"> exhort</font><font color="#E5E5E5"> the C 2</font><font color="#CCCCCC"> Prime with</font><font color="#E5E5E5"> Z then</font>

268
00:12:57,050 --> 00:13:04,430
<font color="#E5E5E5">you should get back em I just justify</font>

269
00:12:58,880 --> 00:13:07,939
<font color="#CCCCCC">this</font><font color="#E5E5E5"> correctness in a moment</font><font color="#CCCCCC"> ok so here</font>

270
00:13:04,430 --> 00:13:11,660
<font color="#E5E5E5">is the analysis of decryption so C 2 was</font>

271
00:13:07,940 --> 00:13:15,380
a times<font color="#CCCCCC"> T plus</font><font color="#E5E5E5"> B 2 which is a times F</font>

272
00:13:11,660 --> 00:13:18,319
times R plus<font color="#E5E5E5"> AG plus B 2 if you do the</font>

273
00:13:15,380 --> 00:13:21,240
calculation<font color="#E5E5E5"> and C 2 prime is f times C 1</font>

274
00:13:18,320 --> 00:13:25,440
which is a times F times R<font color="#CCCCCC"> plus B</font>

275
00:13:21,240 --> 00:13:28,170
<font color="#E5E5E5">F so when you do the Hamming weight</font><font color="#CCCCCC"> of</font><font color="#E5E5E5"> C</font>

276
00:13:25,440 --> 00:13:29,790
to exert C 2 prime<font color="#E5E5E5"> which was basically</font>

277
00:13:28,170 --> 00:13:32,790
the<font color="#E5E5E5"> error</font><font color="#CCCCCC"> that we added</font><font color="#E5E5E5"> to the message</font>

278
00:13:29,790 --> 00:13:35,399
<font color="#CCCCCC">in the end this</font><font color="#E5E5E5"> is just Hamming weight</font>

279
00:13:32,790 --> 00:13:36,630
Hamming distance so this is<font color="#E5E5E5"> just using</font>

280
00:13:35,399 --> 00:13:40,170
triangle inequality it's the<font color="#E5E5E5"> Hamming</font>

281
00:13:36,630 --> 00:13:42,270
<font color="#E5E5E5">distance from C 2 to a times F R plus</font>

282
00:13:40,170 --> 00:13:47,729
the Hamming distance of C 2<font color="#CCCCCC"> prime with a</font>

283
00:13:42,270 --> 00:13:50,459
times<font color="#CCCCCC"> F</font><font color="#E5E5E5"> R and so just because these were</font>

284
00:13:47,730 --> 00:13:53,250
small<font color="#E5E5E5"> these were strings of small</font>

285
00:13:50,459 --> 00:13:56,579
Hamming weight<font color="#E5E5E5"> so we conclude</font><font color="#CCCCCC"> that this</font>

286
00:13:53,250 --> 00:13:58,110
Hamming weight<font color="#CCCCCC"> as so these two Hamming</font>

287
00:13:56,580 --> 00:14:00,000
distances are small<font color="#E5E5E5"> actually you need</font><font color="#CCCCCC"> to</font>

288
00:13:58,110 --> 00:14:03,620
do a little<font color="#E5E5E5"> bit of work</font><font color="#CCCCCC"> to show this but</font>

289
00:14:00,000 --> 00:14:06,480
<font color="#E5E5E5">it works out and then we can decode</font>

290
00:14:03,620 --> 00:14:08,190
<font color="#E5E5E5">using the decoding procedure since this</font>

291
00:14:06,480 --> 00:14:10,500
error is small so we can decode using

292
00:14:08,190 --> 00:14:12,029
the decoding procedure we flip we

293
00:14:10,500 --> 00:14:14,310
flipped a few<font color="#CCCCCC"> bits you</font><font color="#E5E5E5"> can decode to</font>

294
00:14:12,029 --> 00:14:16,320
recover back the message<font color="#E5E5E5"> we can use</font>

295
00:14:14,310 --> 00:14:20,069
different error correction codes for

296
00:14:16,320 --> 00:14:22,589
this but I mean we can since this since

297
00:14:20,070 --> 00:14:24,089
these strings were chosen<font color="#E5E5E5"> randomly</font><font color="#CCCCCC"> so we</font>

298
00:14:22,589 --> 00:14:26,250
can assume this if<font color="#CCCCCC"> we assume</font><font color="#E5E5E5"> this</font>

299
00:14:24,089 --> 00:14:29,100
heuristic<font color="#E5E5E5"> which we tested</font><font color="#CCCCCC"> actually that</font>

300
00:14:26,250 --> 00:14:31,290
the error is<font color="#E5E5E5"> well distributed</font><font color="#CCCCCC"> then this</font>

301
00:14:29,100 --> 00:14:33,180
allows us<font color="#CCCCCC"> to use a much</font><font color="#E5E5E5"> simpler</font>

302
00:14:31,290 --> 00:14:35,670
repetition code so we can<font color="#E5E5E5"> just repeat</font>

303
00:14:33,180 --> 00:14:38,910
every bit of the message<font color="#E5E5E5"> several times</font>

304
00:14:35,670 --> 00:14:40,410
and then I mean<font color="#E5E5E5"> you that that would be a</font>

305
00:14:38,910 --> 00:14:47,189
resurrection<font color="#CCCCCC"> code and</font><font color="#E5E5E5"> then just do the</font>

306
00:14:40,410 --> 00:14:49,380
<font color="#CCCCCC">majority</font><font color="#E5E5E5"> decoding</font><font color="#CCCCCC"> okay</font><font color="#E5E5E5"> so now how do you</font>

307
00:14:47,190 --> 00:14:51,510
how do we get chosen<font color="#CCCCCC"> side</font><font color="#E5E5E5"> ciphertext</font>

308
00:14:49,380 --> 00:14:55,610
attack<font color="#E5E5E5"> security so we want to get this</font>

309
00:14:51,510 --> 00:14:59,010
<font color="#E5E5E5">key encapsulation mechanism Bob so Bob</font>

310
00:14:55,610 --> 00:15:01,890
<font color="#CCCCCC">bond bob has Alice's public key he wants</font>

311
00:14:59,010 --> 00:15:04,709
to use this<font color="#CCCCCC"> encapsulation procedure to</font>

312
00:15:01,890 --> 00:15:08,550
get a shared secret<font color="#CCCCCC"> key and to send a</font>

313
00:15:04,709 --> 00:15:10,890
<font color="#E5E5E5">ciphertext</font><font color="#CCCCCC"> to</font><font color="#E5E5E5"> to Alice who using her</font>

314
00:15:08,550 --> 00:15:12,779
secret key<font color="#CCCCCC"> D capsulated</font><font color="#E5E5E5"> to get the</font>

315
00:15:10,890 --> 00:15:16,680
shared<font color="#CCCCCC"> secret key</font><font color="#E5E5E5"> so you want to you</font>

316
00:15:12,779 --> 00:15:19,020
<font color="#E5E5E5">want to modify this such that if there</font>

317
00:15:16,680 --> 00:15:22,109
is any active attack<font color="#E5E5E5"> then so if there is</font>

318
00:15:19,020 --> 00:15:25,020
<font color="#E5E5E5">an adversary who let's say put sends its</font>

319
00:15:22,110 --> 00:15:27,720
invalid<font color="#E5E5E5"> ciphertext then the</font><font color="#CCCCCC"> D cops</font>

320
00:15:25,020 --> 00:15:32,370
decapsulation algorithm<font color="#CCCCCC"> should output</font>

321
00:15:27,720 --> 00:15:34,680
<font color="#E5E5E5">bottom so this is what we want and what</font>

322
00:15:32,370 --> 00:15:36,899
we<font color="#E5E5E5"> do is we start with</font><font color="#CCCCCC"> the random</font><font color="#E5E5E5"> seed s</font>

323
00:15:34,680 --> 00:15:40,260
and we initialize<font color="#CCCCCC"> a</font><font color="#E5E5E5"> pseudo-random</font>

324
00:15:36,899 --> 00:15:41,880
generator using s so<font color="#E5E5E5"> this we can do</font>

325
00:15:40,260 --> 00:15:43,819
using a random Oracle so assuming the

326
00:15:41,880 --> 00:15:46,710
random Oracle model and then<font color="#CCCCCC"> we produce</font>

327
00:15:43,820 --> 00:15:49,260
<font color="#CCCCCC">pseudo-random shared secret from this</font>

328
00:15:46,710 --> 00:15:53,610
seed s and we run the basic encryption

329
00:15:49,260 --> 00:15:54,689
procedure of s where we vary the the

330
00:15:53,610 --> 00:15:57,000
randomness that<font color="#CCCCCC"> we need for the</font>

331
00:15:54,690 --> 00:15:59,040
encryption<font color="#CCCCCC"> which is a</font><font color="#E5E5E5"> b1 b2 is also</font>

332
00:15:57,000 --> 00:16:00,779
generated<font color="#E5E5E5"> from s so the procedure is</font>

333
00:15:59,040 --> 00:16:06,540
completely deterministic given the seed

334
00:16:00,779 --> 00:16:08,490
s and then we<font color="#CCCCCC"> output C 1 comma Z and the</font>

335
00:16:06,540 --> 00:16:10,560
decapsulation procedure<font color="#E5E5E5"> it basically</font>

336
00:16:08,490 --> 00:16:13,820
runs<font color="#E5E5E5"> the same decryption algorithm that</font>

337
00:16:10,560 --> 00:16:16,619
we earlier<font color="#CCCCCC"> had with</font><font color="#E5E5E5"> c1 z and then we</font>

338
00:16:13,820 --> 00:16:19,080
obtain<font color="#E5E5E5"> the seed s from the decapsulation</font>

339
00:16:16,620 --> 00:16:24,000
and then then we re encapsulate from the

340
00:16:19,080 --> 00:16:27,209
seed and we compare with<font color="#CCCCCC"> the within</font>

341
00:16:24,000 --> 00:16:29,520
<font color="#E5E5E5">capsule with c1 z if we if we</font><font color="#CCCCCC"> get the</font>

342
00:16:27,209 --> 00:16:30,930
same<font color="#CCCCCC"> answer then we output the</font><font color="#E5E5E5"> shared</font>

343
00:16:29,520 --> 00:16:34,890
secret that we<font color="#E5E5E5"> obtained from the seed</font>

344
00:16:30,930 --> 00:16:36,359
otherwise output bottom so it<font color="#E5E5E5"> I mean in</font>

345
00:16:34,890 --> 00:16:41,089
the random Oracle model we can show that

346
00:16:36,360 --> 00:16:44,940
<font color="#CCCCCC">this actually achieves</font><font color="#E5E5E5"> CCA security and</font>

347
00:16:41,089 --> 00:16:51,300
the parameters that<font color="#CCCCCC"> we recommend</font><font color="#E5E5E5"> for</font>

348
00:16:44,940 --> 00:16:53,670
this<font color="#E5E5E5"> crypto system we choose n as 7 5 6</font>

349
00:16:51,300 --> 00:16:55,680
<font color="#E5E5E5">89</font><font color="#CCCCCC"> so this is a merge</font><font color="#E5E5E5"> scene Prime and</font>

350
00:16:53,670 --> 00:17:00,300
the Hamming weight low Hamming weight

351
00:16:55,680 --> 00:17:02,670
parameter<font color="#E5E5E5"> 8 is 256</font><font color="#CCCCCC"> and we encode 256</font>

352
00:17:00,300 --> 00:17:06,059
bits<font color="#E5E5E5"> so this is something that we</font>

353
00:17:02,670 --> 00:17:08,040
implemented<font color="#CCCCCC"> actually so with 2048</font>

354
00:17:06,059 --> 00:17:12,480
<font color="#E5E5E5">repetition encoding which means that</font>

355
00:17:08,040 --> 00:17:16,020
each bit is repeated these<font color="#E5E5E5"> many</font><font color="#CCCCCC"> times ok</font>

356
00:17:12,480 --> 00:17:17,459
so to prove the security we need<font color="#E5E5E5"> we</font><font color="#CCCCCC"> need</font>

357
00:17:16,020 --> 00:17:19,429
a hardness assumption so the hardness

358
00:17:17,459 --> 00:17:22,170
assumption that we are making<font color="#E5E5E5"> is that</font>

359
00:17:19,429 --> 00:17:24,540
<font color="#E5E5E5">this</font><font color="#CCCCCC"> particular</font><font color="#E5E5E5"> problem if you look at</font>

360
00:17:22,170 --> 00:17:27,150
<font color="#CCCCCC">two uniformly random strings</font><font color="#E5E5E5"> r1 and r2</font>

361
00:17:24,540 --> 00:17:29,490
<font color="#E5E5E5">and then you look at</font><font color="#CCCCCC"> two low three low</font>

362
00:17:27,150 --> 00:17:31,679
Hamming weight strings a<font color="#CCCCCC"> b1 and b2</font><font color="#E5E5E5"> then</font>

363
00:17:29,490 --> 00:17:35,130
<font color="#E5E5E5">then you look at these four strings r1</font>

364
00:17:31,679 --> 00:17:38,160
<font color="#E5E5E5">r2 a r1 plus b1 and a r2 plus b2 so</font>

365
00:17:35,130 --> 00:17:40,380
<font color="#E5E5E5">these four strings look like a uniformly</font>

366
00:17:38,160 --> 00:17:44,700
random<font color="#CCCCCC"> couple so this is the assumption</font>

367
00:17:40,380 --> 00:17:46,290
that we are making<font color="#E5E5E5"> what are</font><font color="#CCCCCC"> the best</font>

368
00:17:44,700 --> 00:17:48,480
known attacks for this

369
00:17:46,290 --> 00:17:51,600
well the trivial

370
00:17:48,480 --> 00:17:55,460
one is we can<font color="#E5E5E5"> just try to guess one of</font>

371
00:17:51,600 --> 00:18:00,270
<font color="#CCCCCC">f/4g so that takes</font><font color="#E5E5E5"> time</font><font color="#CCCCCC"> n</font><font color="#E5E5E5"> choose age and</font>

372
00:17:55,460 --> 00:18:02,970
<font color="#E5E5E5">using some recent results</font><font color="#CCCCCC"> the so this</font>

373
00:18:00,270 --> 00:18:04,590
basically appeared after our first after

374
00:18:02,970 --> 00:18:08,850
the<font color="#CCCCCC"> first version of our paper came went</font>

375
00:18:04,590 --> 00:18:11,790
online so this the<font color="#E5E5E5"> best classical</font><font color="#CCCCCC"> attack</font>

376
00:18:08,850 --> 00:18:13,830
<font color="#E5E5E5">runs runs in time</font><font color="#CCCCCC"> I mean it takes time</font>

377
00:18:11,790 --> 00:18:15,570
to to the to H times something<font color="#E5E5E5"> so it's</font>

378
00:18:13,830 --> 00:18:18,299
at<font color="#CCCCCC"> least</font><font color="#E5E5E5"> it's larger than</font><font color="#CCCCCC"> 2 to</font><font color="#E5E5E5"> the 2 H</font>

379
00:18:15,570 --> 00:18:20,370
and then so<font color="#E5E5E5"> you can just use Grover's</font>

380
00:18:18,299 --> 00:18:24,210
algorithm to improve<font color="#E5E5E5"> a quantum algorithm</font>

381
00:18:20,370 --> 00:18:26,100
<font color="#E5E5E5">which runs in</font><font color="#CCCCCC"> time</font><font color="#E5E5E5"> to to the edge under</font>

382
00:18:24,210 --> 00:18:35,750
some assumption<font color="#E5E5E5"> so that's that's the</font>

383
00:18:26,100 --> 00:18:39,270
best<font color="#CCCCCC"> attacks that</font><font color="#E5E5E5"> we have so far and and</font>

384
00:18:35,750 --> 00:18:41,490
since<font color="#CCCCCC"> it's it's a pretty simple scheme I</font>

385
00:18:39,270 --> 00:18:44,990
mean it's easy to<font color="#E5E5E5"> understand so the hope</font>

386
00:18:41,490 --> 00:18:48,210
is<font color="#CCCCCC"> that it would</font><font color="#E5E5E5"> be easier to kind of</font>

387
00:18:44,990 --> 00:18:50,850
look<font color="#E5E5E5"> at cryptanalytic attacks for this</font>

388
00:18:48,210 --> 00:18:53,429
one and maybe since it since in

389
00:18:50,850 --> 00:18:55,889
<font color="#CCCCCC">particular this assumption has a little</font>

390
00:18:53,429 --> 00:18:57,600
bit<font color="#CCCCCC"> of a similar</font><font color="#E5E5E5"> flavor to</font><font color="#CCCCCC"> lwe so maybe</font>

391
00:18:55,890 --> 00:19:00,000
attacks<font color="#E5E5E5"> if you get a tax for this one</font>

392
00:18:57,600 --> 00:19:02,870
maybe that gives us some ideas for for

393
00:19:00,000 --> 00:19:05,700
<font color="#E5E5E5">learning with errors</font><font color="#CCCCCC"> and another</font>

394
00:19:02,870 --> 00:19:07,620
direction for future<font color="#E5E5E5"> work is of course</font>

395
00:19:05,700 --> 00:19:09,660
again<font color="#E5E5E5"> because it's it's simple maybe we</font>

396
00:19:07,620 --> 00:19:12,239
can come up<font color="#CCCCCC"> with</font><font color="#E5E5E5"> ideas to</font><font color="#CCCCCC"> improve the</font>

397
00:19:09,660 --> 00:19:19,350
efficiency without<font color="#E5E5E5"> really compromising</font>

398
00:19:12,240 --> 00:19:19,800
on<font color="#CCCCCC"> the security so that's all thank you</font>

399
00:19:19,350 --> 00:19:25,359
<font color="#CCCCCC">very</font><font color="#E5E5E5"> much</font>

400
00:19:19,800 --> 00:19:25,359
[Applause]

