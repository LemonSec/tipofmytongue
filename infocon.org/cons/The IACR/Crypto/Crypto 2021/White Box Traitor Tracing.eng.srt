1
00:00:02,879 --> 00:00:05,759
hello my name is mark zandry and today i

2
00:00:05,759 --> 00:00:07,440
will be talking about white box trader

3
00:00:07,440 --> 00:00:09,760
tracing

4
00:00:09,760 --> 00:00:11,440
let us first recall the goal of trader

5
00:00:11,440 --> 00:00:12,639
tracing

6
00:00:12,639 --> 00:00:14,719
here we have a content distributor who

7
00:00:14,719 --> 00:00:17,039
is broadcasting encrypted messages to a

8
00:00:17,039 --> 00:00:19,359
large set of recipients whom each have

9
00:00:19,359 --> 00:00:22,160
their own personalized secret key

10
00:00:22,160 --> 00:00:23,920
we are concerned that an unscrupulous

11
00:00:23,920 --> 00:00:26,480
user called a trader may leak their key

12
00:00:26,480 --> 00:00:28,480
to an unauthorized user

13
00:00:28,480 --> 00:00:30,400
thereby allowing the unauthorized user

14
00:00:30,400 --> 00:00:32,719
to read the encrypted messages

15
00:00:32,719 --> 00:00:35,280
there's no way to really prevent a user

16
00:00:35,280 --> 00:00:37,360
from becoming a trader

17
00:00:37,360 --> 00:00:39,440
however if the content distributor comes

18
00:00:39,440 --> 00:00:41,280
across the leaked key

19
00:00:41,280 --> 00:00:42,800
we want the content distributor to be

20
00:00:42,800 --> 00:00:45,440
able to identify the user it came from

21
00:00:45,440 --> 00:00:47,120
then the content distributor can take

22
00:00:47,120 --> 00:00:49,520
remedial actions such as prosecuting the

23
00:00:49,520 --> 00:00:51,520
trader or at least revoking the trader's

24
00:00:51,520 --> 00:00:52,719
credentials

25
00:00:52,719 --> 00:00:54,320
in this way trader tracing serves to

26
00:00:54,320 --> 00:00:57,719
deter piracy

27
00:00:59,280 --> 00:01:00,640
i will now discuss some of the main

28
00:01:00,640 --> 00:01:02,480
features one may want out of a trader

29
00:01:02,480 --> 00:01:04,080
tracing system

30
00:01:04,080 --> 00:01:05,760
first and foremost

31
00:01:05,760 --> 00:01:08,000
the trader may not simply output their

32
00:01:08,000 --> 00:01:10,159
key instead they may embed the key in a

33
00:01:10,159 --> 00:01:12,320
tamper-resistant hardware device or

34
00:01:12,320 --> 00:01:14,159
potentially an office-gated decoder

35
00:01:14,159 --> 00:01:16,640
program in an attempt to hide their

36
00:01:16,640 --> 00:01:19,600
identity from the tracer

37
00:01:19,600 --> 00:01:21,520
another important feature is collusion

38
00:01:21,520 --> 00:01:22,720
resistance

39
00:01:22,720 --> 00:01:24,320
which means that we can identify a

40
00:01:24,320 --> 00:01:26,560
trader even if multiple traders

41
00:01:26,560 --> 00:01:28,640
collude in producing the pirate key or

42
00:01:28,640 --> 00:01:30,880
decoder

43
00:01:30,880 --> 00:01:32,880
we would naturally want to use minimal

44
00:01:32,880 --> 00:01:34,960
computational assumptions in achieving

45
00:01:34,960 --> 00:01:37,680
our goal for example we would hope to

46
00:01:37,680 --> 00:01:40,320
rely just on public key encryption as

47
00:01:40,320 --> 00:01:43,040
opposed to hard

48
00:01:43,040 --> 00:01:46,079
algebraic tools

49
00:01:46,079 --> 00:01:47,920
next we would ideally be able to trace

50
00:01:47,920 --> 00:01:50,000
decoders that don't work all the time or

51
00:01:50,000 --> 00:01:51,360
which don't perfectly recover the

52
00:01:51,360 --> 00:01:53,680
message for example to evade tracing in

53
00:01:53,680 --> 00:01:55,680
a movie streaming scenario you could

54
00:01:55,680 --> 00:01:57,360
imagine a decoder outputting a low

55
00:01:57,360 --> 00:01:59,119
quality version of the movie instead of

56
00:01:59,119 --> 00:02:02,240
the original high quality version

57
00:02:02,240 --> 00:02:04,320
finally we would ideally have public

58
00:02:04,320 --> 00:02:05,360
tracing

59
00:02:05,360 --> 00:02:07,840
which allows anyone not just the content

60
00:02:07,840 --> 00:02:10,160
distributor to trace this provides for

61
00:02:10,160 --> 00:02:12,319
maximal deterrence since now anyone

62
00:02:12,319 --> 00:02:14,720
including the unauthorized user will

63
00:02:14,720 --> 00:02:16,560
immediately learn the trader's identity

64
00:02:16,560 --> 00:02:18,080
from any

65
00:02:18,080 --> 00:02:20,319
decoder program or device

66
00:02:20,319 --> 00:02:21,840
there are also advantages of public

67
00:02:21,840 --> 00:02:23,599
tracing for prosecuting traders but we

68
00:02:23,599 --> 00:02:25,520
will not discuss them

69
00:02:25,520 --> 00:02:27,599
uh when we refer to private tracing

70
00:02:27,599 --> 00:02:29,360
throughout this talk as opposed to

71
00:02:29,360 --> 00:02:31,599
public tracing will mean that only the

72
00:02:31,599 --> 00:02:33,680
content distributor can trace

73
00:02:33,680 --> 00:02:37,840
public tracing means anyone can trace

74
00:02:38,400 --> 00:02:39,920
one feature that has largely been taken

75
00:02:39,920 --> 00:02:41,920
for granted in the works is the tracing

76
00:02:41,920 --> 00:02:43,040
model

77
00:02:43,040 --> 00:02:45,440
you can imagine the decoder to be an

78
00:02:45,440 --> 00:02:47,360
actual hardware device

79
00:02:47,360 --> 00:02:49,040
which may be difficult to break open or

80
00:02:49,040 --> 00:02:52,400
inspect even with a software decoder

81
00:02:52,400 --> 00:02:54,800
it may be difficult to analyze the

82
00:02:54,800 --> 00:02:56,239
program because program code is

83
00:02:56,239 --> 00:02:59,200
notoriously difficult to analyze

84
00:02:59,200 --> 00:03:02,000
as such the vast majority of the trader

85
00:03:02,000 --> 00:03:03,920
tracing literature works in a black box

86
00:03:03,920 --> 00:03:05,280
tracing model

87
00:03:05,280 --> 00:03:06,879
where the tracer only makes queries to

88
00:03:06,879 --> 00:03:09,440
the coder and sees the responses without

89
00:03:09,440 --> 00:03:11,760
having to know how the tracer actually

90
00:03:11,760 --> 00:03:13,760
works

91
00:03:13,760 --> 00:03:15,440
this black box tracing model is so

92
00:03:15,440 --> 00:03:16,800
ingrained in the literature that it is

93
00:03:16,800 --> 00:03:18,480
written explicitly in the syntax

94
00:03:18,480 --> 00:03:20,159
essentially all prior trader tracing

95
00:03:20,159 --> 00:03:22,159
definitions

96
00:03:22,159 --> 00:03:24,640
there's one basically one exception to

97
00:03:24,640 --> 00:03:26,879
the black box model and that is that

98
00:03:26,879 --> 00:03:29,440
some early schemes did in fact look

99
00:03:29,440 --> 00:03:32,560
inside the decoder itself but all such

100
00:03:32,560 --> 00:03:34,480
schemes required that the trader

101
00:03:34,480 --> 00:03:36,400
actually output a valid key for the

102
00:03:36,400 --> 00:03:38,319
system as opposed to a general decoder

103
00:03:38,319 --> 00:03:40,720
program and importantly in all prior

104
00:03:40,720 --> 00:03:43,120
schemes that did not use black box

105
00:03:43,120 --> 00:03:46,159
tracing you could easily defeat tracing

106
00:03:46,159 --> 00:03:48,239
by outputting a general decoder program

107
00:03:48,239 --> 00:03:49,680
rather than a key

108
00:03:49,680 --> 00:03:52,560
so all of the prior tracing that works

109
00:03:52,560 --> 00:03:55,519
for general decoder programs all works

110
00:03:55,519 --> 00:03:58,640
in the black box model

111
00:03:59,040 --> 00:04:00,480
now there is a trip

112
00:04:00,480 --> 00:04:02,640
a trivial trader tracing solution which

113
00:04:02,640 --> 00:04:04,480
gives each user their own ciphertext

114
00:04:04,480 --> 00:04:07,120
component and decryption key

115
00:04:07,120 --> 00:04:08,959
uh this game does really well according

116
00:04:08,959 --> 00:04:10,480
to all the features we've discussed so

117
00:04:10,480 --> 00:04:12,400
far it's collusion resistant requires

118
00:04:12,400 --> 00:04:15,280
minimal assumptions allows for tracing

119
00:04:15,280 --> 00:04:18,079
arbitrary imperfect decoders gets public

120
00:04:18,079 --> 00:04:22,079
tracing as well as black box tracing

121
00:04:22,079 --> 00:04:25,600
the main problem is that the cipher text

122
00:04:25,600 --> 00:04:27,360
as well as the public keys

123
00:04:27,360 --> 00:04:29,199
are quite large and grow linearly with

124
00:04:29,199 --> 00:04:31,360
the number of users and this can become

125
00:04:31,360 --> 00:04:33,120
very impractical even for a modest

126
00:04:33,120 --> 00:04:35,919
number of users

127
00:04:35,919 --> 00:04:37,280
the bulk of the trader tracing

128
00:04:37,280 --> 00:04:39,520
literature therefore has focused on

129
00:04:39,520 --> 00:04:40,720
producing schemes with shorter

130
00:04:40,720 --> 00:04:42,240
parameters in particular shorter

131
00:04:42,240 --> 00:04:43,600
ciphertexts

132
00:04:43,600 --> 00:04:44,960
there have been a number of improvements

133
00:04:44,960 --> 00:04:47,120
over this trivial scheme often using

134
00:04:47,120 --> 00:04:49,600
algebraic tools to compress terms to the

135
00:04:49,600 --> 00:04:51,680
point where we now have asymptotically

136
00:04:51,680 --> 00:04:53,040
optimal schemes under certain

137
00:04:53,040 --> 00:04:57,280
assumptions such as learning with errors

138
00:04:57,280 --> 00:04:59,520
this talk will instead focus on a

139
00:04:59,520 --> 00:05:01,360
limitation of prior work which has

140
00:05:01,360 --> 00:05:04,800
nothing to do with parameter sizes

141
00:05:04,800 --> 00:05:07,600
to start i will crawl a previous work

142
00:05:07,600 --> 00:05:09,360
from 2016

143
00:05:09,360 --> 00:05:11,520
with my co-authors rio nishimaki and

144
00:05:11,520 --> 00:05:13,280
daniel wicks

145
00:05:13,280 --> 00:05:14,479
here we

146
00:05:14,479 --> 00:05:16,960
proposed using public tracing

147
00:05:16,960 --> 00:05:19,120
plus setting each user's identity to

148
00:05:19,120 --> 00:05:21,680
contain super sensitive information say

149
00:05:21,680 --> 00:05:23,280
a bank account number or something like

150
00:05:23,280 --> 00:05:24,479
that

151
00:05:24,479 --> 00:05:27,039
this way the moment a trader hands a

152
00:05:27,039 --> 00:05:29,280
decoder to an unauthorized user

153
00:05:29,280 --> 00:05:31,039
that user can trace using the public

154
00:05:31,039 --> 00:05:33,440
tracing algorithm and then learn the

155
00:05:33,440 --> 00:05:36,000
sensitive information of the tracer

156
00:05:36,000 --> 00:05:36,840
of the

157
00:05:36,840 --> 00:05:39,440
trader the result is that the only way a

158
00:05:39,440 --> 00:05:41,520
trader can distribute their key is to

159
00:05:41,520 --> 00:05:42,960
also distribute their sensitive

160
00:05:42,960 --> 00:05:44,320
information

161
00:05:44,320 --> 00:05:45,919
therefore such a mechanism would be a

162
00:05:45,919 --> 00:05:48,400
very good deterrence even in a situation

163
00:05:48,400 --> 00:05:50,080
where the content distributor may never

164
00:05:50,080 --> 00:05:53,520
come across the pirate decor

165
00:05:54,000 --> 00:05:56,240
the problem is that if the identity

166
00:05:56,240 --> 00:05:57,759
embedded in the secret key is very

167
00:05:57,759 --> 00:06:00,160
sensitive the honest user would clearly

168
00:06:00,160 --> 00:06:01,919
want to keep it secret if they are being

169
00:06:01,919 --> 00:06:03,199
honest

170
00:06:03,199 --> 00:06:05,840
in this prior work we proposed keeping

171
00:06:05,840 --> 00:06:07,520
the identity hidden from the content

172
00:06:07,520 --> 00:06:09,840
distributor by using a multi-party

173
00:06:09,840 --> 00:06:11,600
computation protocol to generate the

174
00:06:11,600 --> 00:06:13,360
user secret key

175
00:06:13,360 --> 00:06:16,720
this indeed based on the guarantees of

176
00:06:16,720 --> 00:06:19,120
multi-party computation will

177
00:06:19,120 --> 00:06:20,880
keep the identity hitting during the

178
00:06:20,880 --> 00:06:23,600
setup phase

179
00:06:24,000 --> 00:06:25,600
in this work we take things a step

180
00:06:25,600 --> 00:06:27,600
further and consider keeping the

181
00:06:27,600 --> 00:06:30,400
identity hidden even after setup and

182
00:06:30,400 --> 00:06:32,479
moreover keeping the identity hidden

183
00:06:32,479 --> 00:06:34,000
from potentially other users of the

184
00:06:34,000 --> 00:06:37,520
system besides the content distributor

185
00:06:37,520 --> 00:06:39,520
consider for example an encrypted group

186
00:06:39,520 --> 00:06:41,120
chat application

187
00:06:41,120 --> 00:06:42,479
where the users are encrypting their

188
00:06:42,479 --> 00:06:44,479
message using a trader tracing scheme

189
00:06:44,479 --> 00:06:47,039
with embedded sensitive identities

190
00:06:47,039 --> 00:06:48,960
now consider a malicious user who can

191
00:06:48,960 --> 00:06:50,960
send a message to the chat and see how

192
00:06:50,960 --> 00:06:53,120
an honest user responds

193
00:06:53,120 --> 00:06:55,520
in essence they can mount a chosen

194
00:06:55,520 --> 00:06:58,160
ciphertext or cca attack against the

195
00:06:58,160 --> 00:07:00,240
honest user and can potentially try to

196
00:07:00,240 --> 00:07:01,520
use such an attack to learn the

197
00:07:01,520 --> 00:07:03,919
sensitive information of that user

198
00:07:03,919 --> 00:07:06,080
ensuring privacy of the honest users in

199
00:07:06,080 --> 00:07:08,160
this attack scenario will therefore be

200
00:07:08,160 --> 00:07:11,520
the main focus of this talk

201
00:07:12,560 --> 00:07:15,120
our first result is an impossibility

202
00:07:15,120 --> 00:07:17,280
showing that with cca attacks and black

203
00:07:17,280 --> 00:07:18,720
box tracing

204
00:07:18,720 --> 00:07:20,639
anyone who is capable of tracing can

205
00:07:20,639 --> 00:07:23,599
break privacy of the honest users

206
00:07:23,599 --> 00:07:25,039
in the case of private tracing where

207
00:07:25,039 --> 00:07:27,280
only the content distributor can trace

208
00:07:27,280 --> 00:07:28,800
this means that the content distributor

209
00:07:28,800 --> 00:07:30,479
can use cca queries against an honest

210
00:07:30,479 --> 00:07:32,479
user to learn their identity

211
00:07:32,479 --> 00:07:34,080
in the case of public tracing which is

212
00:07:34,080 --> 00:07:35,360
really what you'd want for maximal

213
00:07:35,360 --> 00:07:38,639
deterrence this means that anyone can

214
00:07:38,639 --> 00:07:40,880
trace and therefore anyone can use cca

215
00:07:40,880 --> 00:07:42,400
queries to learn the identities of

216
00:07:42,400 --> 00:07:45,039
honest users the proof of this

217
00:07:45,039 --> 00:07:47,520
impossibility is simple

218
00:07:47,520 --> 00:07:49,039
anyone who can trace

219
00:07:49,039 --> 00:07:51,280
with a black box tracing algorithm can

220
00:07:51,280 --> 00:07:52,960
just mount the tracing algorithm over

221
00:07:52,960 --> 00:07:54,080
the network

222
00:07:54,080 --> 00:07:56,319
the tracing guarantee means that the

223
00:07:56,319 --> 00:07:58,560
adversary learns the user's identity

224
00:07:58,560 --> 00:08:00,319
from the users

225
00:08:00,319 --> 00:08:02,080
from the user's answers to the cca

226
00:08:02,080 --> 00:08:03,440
queries

227
00:08:03,440 --> 00:08:05,840
we note that tracing usually only needs

228
00:08:05,840 --> 00:08:08,080
to know whether or not a user decrypts

229
00:08:08,080 --> 00:08:09,759
so we don't even need the full power of

230
00:08:09,759 --> 00:08:12,560
cca attacks we just need to know whether

231
00:08:12,560 --> 00:08:14,639
a user decrypts this given ciphertext or

232
00:08:14,639 --> 00:08:16,560
not in order to mount the attack

233
00:08:16,560 --> 00:08:18,639
so in the public tracing setting what

234
00:08:18,639 --> 00:08:21,919
this means is even an outside user

235
00:08:21,919 --> 00:08:24,400
who doesn't have any secret keys at all

236
00:08:24,400 --> 00:08:26,560
can potentially mount the attack and all

237
00:08:26,560 --> 00:08:28,240
they have to do is see whether a user

238
00:08:28,240 --> 00:08:30,319
responds to their messages but they

239
00:08:30,319 --> 00:08:31,680
don't actually need to see the response

240
00:08:31,680 --> 00:08:33,519
itself and they can nevertheless not the

241
00:08:33,519 --> 00:08:35,919
attack

242
00:08:36,799 --> 00:08:38,958
for our first positive results we give a

243
00:08:38,958 --> 00:08:41,760
feasibility showing how to obtain public

244
00:08:41,760 --> 00:08:44,000
tracing and simultaneously preserve user

245
00:08:44,000 --> 00:08:45,760
privacy even under these chosen

246
00:08:45,760 --> 00:08:47,839
ciphertext attacks

247
00:08:47,839 --> 00:08:50,320
in light of our impossibility result

248
00:08:50,320 --> 00:08:53,279
this necessarily requires the use of

249
00:08:53,279 --> 00:08:55,440
white box tracing meaning that the

250
00:08:55,440 --> 00:08:57,040
tracing algorithm actually has to

251
00:08:57,040 --> 00:09:01,120
inspect the actual program code of a

252
00:09:01,120 --> 00:09:04,000
decoder program it can't it cannot just

253
00:09:04,000 --> 00:09:07,839
trace by making queries to the program

254
00:09:07,839 --> 00:09:09,920
terms of building blocks our scheme

255
00:09:09,920 --> 00:09:11,839
requires functional encryption and

256
00:09:11,839 --> 00:09:13,440
non-interactive zero-knowledge proofs

257
00:09:13,440 --> 00:09:15,519
from visits

258
00:09:15,519 --> 00:09:16,880
different assumptions can be used to

259
00:09:16,880 --> 00:09:18,320
instantiate the functional encryption

260
00:09:18,320 --> 00:09:20,000
scheme resulting in different parameter

261
00:09:20,000 --> 00:09:21,440
size trade-offs

262
00:09:21,440 --> 00:09:23,040
in particular if we don't care about

263
00:09:23,040 --> 00:09:25,519
parameter sizes we can use generic

264
00:09:25,519 --> 00:09:27,519
public key encryption together with

265
00:09:27,519 --> 00:09:28,480
music

266
00:09:28,480 --> 00:09:30,880
to achieve our scheme

267
00:09:30,880 --> 00:09:33,120
if we want optimal parameters we can use

268
00:09:33,120 --> 00:09:37,240
indistinguishability off execution

269
00:09:37,440 --> 00:09:39,760
i will now discuss the high level idea

270
00:09:39,760 --> 00:09:40,959
behind

271
00:09:40,959 --> 00:09:43,440
our proof of this theorem

272
00:09:43,440 --> 00:09:44,800
the proof idea is to use something

273
00:09:44,800 --> 00:09:47,440
called an obfuscatable program

274
00:09:47,440 --> 00:09:48,640
so these

275
00:09:48,640 --> 00:09:51,200
were defined by barack at all and they

276
00:09:51,200 --> 00:09:52,800
were originally used in the context of

277
00:09:52,800 --> 00:09:54,880
proving an impossibility for strong

278
00:09:54,880 --> 00:09:57,440
forms of obfuscation

279
00:09:57,440 --> 00:09:58,959
and they can be constructed from minimal

280
00:09:58,959 --> 00:10:01,200
computational assumptions

281
00:10:01,200 --> 00:10:03,680
so what is an obfuscatable program

282
00:10:03,680 --> 00:10:05,760
an unoffuscatable program are programs

283
00:10:05,760 --> 00:10:07,200
with two properties

284
00:10:07,200 --> 00:10:10,880
the first is that they are non-learnable

285
00:10:10,880 --> 00:10:12,480
this means that there is no efficient

286
00:10:12,480 --> 00:10:14,560
way to recover the program just given

287
00:10:14,560 --> 00:10:17,200
blackbox access to its functionality so

288
00:10:17,200 --> 00:10:18,320
if you have an adversary that can only

289
00:10:18,320 --> 00:10:20,560
make queries to the program it will not

290
00:10:20,560 --> 00:10:22,320
be able to produce any code for the

291
00:10:22,320 --> 00:10:24,480
program

292
00:10:24,480 --> 00:10:26,480
the second property is reverse

293
00:10:26,480 --> 00:10:28,240
engineerability

294
00:10:28,240 --> 00:10:31,360
which is says that given any code

295
00:10:31,360 --> 00:10:33,360
that has the same functionality as the

296
00:10:33,360 --> 00:10:35,680
original program even if it's been

297
00:10:35,680 --> 00:10:38,480
obfuscated or adversarially

298
00:10:38,480 --> 00:10:40,399
manipulated in some way

299
00:10:40,399 --> 00:10:43,200
given any code that computes the same

300
00:10:43,200 --> 00:10:45,200
function as the original program there

301
00:10:45,200 --> 00:10:47,040
is an automated process to actually

302
00:10:47,040 --> 00:10:49,360
recover the original program code in its

303
00:10:49,360 --> 00:10:51,839
entirety

304
00:10:52,320 --> 00:10:53,360
uh so

305
00:10:53,360 --> 00:10:55,920
superficially unofficiatable functions

306
00:10:55,920 --> 00:10:57,600
seem to be very analogous to what we

307
00:10:57,600 --> 00:10:59,839
need which is the ability to do

308
00:10:59,839 --> 00:11:02,480
something with code namely trace that

309
00:11:02,480 --> 00:11:05,680
you can't do given black box access

310
00:11:05,680 --> 00:11:07,279
but perhaps it's not immediately clear

311
00:11:07,279 --> 00:11:08,800
how to actually turn these programs into

312
00:11:08,800 --> 00:11:11,040
a trader tracing scheme with decryption

313
00:11:11,040 --> 00:11:15,839
functionality collusion resistance etc

314
00:11:16,560 --> 00:11:19,519
so here's a failed attempt to try to

315
00:11:19,519 --> 00:11:21,680
build a private trader tracing scheme

316
00:11:21,680 --> 00:11:24,640
from an unobfuscatable function

317
00:11:24,640 --> 00:11:26,480
so we'll assume any trader tracing

318
00:11:26,480 --> 00:11:30,000
scheme saved from prior literature

319
00:11:30,000 --> 00:11:33,360
which may have black box tracing

320
00:11:33,360 --> 00:11:36,160
the idea is to set the identity of a

321
00:11:36,160 --> 00:11:38,959
user to be the code of some unoffice

322
00:11:38,959 --> 00:11:40,560
skatable program

323
00:11:40,560 --> 00:11:42,560
this unobfuscatable program

324
00:11:42,560 --> 00:11:44,240
may have the desired sensitive

325
00:11:44,240 --> 00:11:46,640
information of that user embedded for

326
00:11:46,640 --> 00:11:49,120
example into the comments of the program

327
00:11:49,120 --> 00:11:50,800
code

328
00:11:50,800 --> 00:11:52,720
this way if you can recover

329
00:11:52,720 --> 00:11:55,360
the unofficiated program code including

330
00:11:55,360 --> 00:11:57,440
comments you would learn the sensitive

331
00:11:57,440 --> 00:12:00,000
information and so the hope is that by

332
00:12:00,000 --> 00:12:02,079
setting the identity to be this program

333
00:12:02,079 --> 00:12:02,959
code

334
00:12:02,959 --> 00:12:04,000
you can

335
00:12:04,000 --> 00:12:06,959
then trace and recover the

336
00:12:06,959 --> 00:12:09,600
uh the sensitive information

337
00:12:09,600 --> 00:12:11,279
the problem of course is that fireworks

338
00:12:11,279 --> 00:12:13,040
use black box tracing

339
00:12:13,040 --> 00:12:15,680
so what a adversary can do

340
00:12:15,680 --> 00:12:18,240
is a remote adversary can do is that

341
00:12:18,240 --> 00:12:20,320
they can simply trace over the network

342
00:12:20,320 --> 00:12:23,600
to recover the unofficiatable program

343
00:12:23,600 --> 00:12:25,120
but they actually recover the program

344
00:12:25,120 --> 00:12:27,600
code by the guarantees of the trader

345
00:12:27,600 --> 00:12:29,279
tracing scheme and once they have the

346
00:12:29,279 --> 00:12:33,360
program code they themselves can also

347
00:12:33,360 --> 00:12:34,959
see the comments even if you somehow

348
00:12:34,959 --> 00:12:36,560
obfuscated the code you could still

349
00:12:36,560 --> 00:12:38,480
reverse engineer it to learn the

350
00:12:38,480 --> 00:12:40,639
original program code with the comments

351
00:12:40,639 --> 00:12:43,600
embedded and therefore learn the

352
00:12:43,600 --> 00:12:46,560
sensitive information

353
00:12:48,000 --> 00:12:50,560
okay so what our solution is to do is to

354
00:12:50,560 --> 00:12:52,639
embed the program more carefully in a

355
00:12:52,639 --> 00:12:55,120
trader tracing system and we do this

356
00:12:55,120 --> 00:12:57,120
using a new object we call function

357
00:12:57,120 --> 00:12:59,200
embedded trader tracing

358
00:12:59,200 --> 00:13:01,440
here we embed a function into a program

359
00:13:01,440 --> 00:13:04,240
and as opposed to an identity

360
00:13:04,240 --> 00:13:07,360
and augment the tracing procedure to

361
00:13:07,360 --> 00:13:09,600
additionally take as it inputs an input

362
00:13:09,600 --> 00:13:11,680
to the function

363
00:13:11,680 --> 00:13:13,920
the tracing algorithm won't learn the

364
00:13:13,920 --> 00:13:16,000
function and instead will just allow for

365
00:13:16,000 --> 00:13:18,480
evaluating the function on the given

366
00:13:18,480 --> 00:13:19,600
input

367
00:13:19,600 --> 00:13:22,079
importantly the trader tracing

368
00:13:22,079 --> 00:13:24,560
algorithm never learns the any code for

369
00:13:24,560 --> 00:13:26,079
the function and this is actually a

370
00:13:26,079 --> 00:13:29,360
security requirement that the tracer

371
00:13:29,360 --> 00:13:31,279
cannot learn the code for the function

372
00:13:31,279 --> 00:13:33,440
just given black box access

373
00:13:33,440 --> 00:13:36,880
all they can do is evaluate it

374
00:13:37,040 --> 00:13:38,880
we show how to construct such an object

375
00:13:38,880 --> 00:13:42,000
from functional encryption in uh nzx

376
00:13:42,000 --> 00:13:44,160
basically the prior work already uses

377
00:13:44,160 --> 00:13:45,600
functional encryption to build trader

378
00:13:45,600 --> 00:13:48,240
tracing and we augment these works with

379
00:13:48,240 --> 00:13:50,720
an evaluation functionality

380
00:13:50,720 --> 00:13:52,800
nzx come in to guarantee that the tracer

381
00:13:52,800 --> 00:13:55,760
can't learn the function f itself and i

382
00:13:55,760 --> 00:13:58,240
will elaborate on this a little more

383
00:13:58,240 --> 00:14:01,800
in a couple slides

384
00:14:05,120 --> 00:14:06,959
all right so once we have a function

385
00:14:06,959 --> 00:14:09,680
embedded trader tracing scheme

386
00:14:09,680 --> 00:14:10,800
we then

387
00:14:10,800 --> 00:14:11,920
set the

388
00:14:11,920 --> 00:14:13,600
function to be an unoffice scalable

389
00:14:13,600 --> 00:14:16,720
program and the result is a white box

390
00:14:16,720 --> 00:14:18,560
traceable scheme with public tracing and

391
00:14:18,560 --> 00:14:20,560
user privacy

392
00:14:20,560 --> 00:14:23,600
the idea for tracing is that any code

393
00:14:23,600 --> 00:14:24,720
for

394
00:14:24,720 --> 00:14:25,920
decryption

395
00:14:25,920 --> 00:14:28,800
can be turned into code for evaluating

396
00:14:28,800 --> 00:14:30,399
the embedded function f using the

397
00:14:30,399 --> 00:14:32,320
tracing algorithm

398
00:14:32,320 --> 00:14:33,440
and then once you have code for

399
00:14:33,440 --> 00:14:35,360
evaluating the function f you can use

400
00:14:35,360 --> 00:14:37,760
the reverse engineer ability of the

401
00:14:37,760 --> 00:14:39,839
unoffice scadable program to recover the

402
00:14:39,839 --> 00:14:42,160
original code which then contains the

403
00:14:42,160 --> 00:14:46,240
sensitive information as a comment

404
00:14:46,800 --> 00:14:48,399
note that for our construction it is

405
00:14:48,399 --> 00:14:50,000
totally fine if the function embedded

406
00:14:50,000 --> 00:14:51,839
trader tracing system uses black box

407
00:14:51,839 --> 00:14:53,920
tracing and in fact our construction

408
00:14:53,920 --> 00:14:56,079
leverages the existing work which uses

409
00:14:56,079 --> 00:14:57,760
black box tracing

410
00:14:57,760 --> 00:14:59,279
and you can view our conversion as

411
00:14:59,279 --> 00:15:01,519
nevertheless upgrading a black box

412
00:15:01,519 --> 00:15:05,360
tracing scheme into a white box tracing

413
00:15:05,360 --> 00:15:09,800
scheme that ensures user privacy

414
00:15:12,639 --> 00:15:16,000
okay so let's now take a quick detour to

415
00:15:16,000 --> 00:15:17,839
discuss a limitation of

416
00:15:17,839 --> 00:15:20,079
functional encryption that arose when

417
00:15:20,079 --> 00:15:21,440
trying to use it to build our trader

418
00:15:21,440 --> 00:15:23,440
tracing system

419
00:15:23,440 --> 00:15:25,440
consider the canonical motivating

420
00:15:25,440 --> 00:15:27,600
example for functional encryption which

421
00:15:27,600 --> 00:15:29,839
is a spam filter on a remote email

422
00:15:29,839 --> 00:15:31,120
provider

423
00:15:31,120 --> 00:15:33,759
here a user wants to outsource email

424
00:15:33,759 --> 00:15:36,399
management to a remote provider

425
00:15:36,399 --> 00:15:37,920
but the remote provider needs to figure

426
00:15:37,920 --> 00:15:40,800
out how to route spam messages to trash

427
00:15:40,800 --> 00:15:42,320
the obvious solution is to have the

428
00:15:42,320 --> 00:15:45,440
provider just own the decryption key

429
00:15:45,440 --> 00:15:47,279
allowing it to decrypt the messages and

430
00:15:47,279 --> 00:15:50,480
apply the spam filter on the plain text

431
00:15:50,480 --> 00:15:51,920
but the user would like to keep the

432
00:15:51,920 --> 00:15:54,800
messages hidden even from the provider

433
00:15:54,800 --> 00:15:56,320
so what the user will do is employ a

434
00:15:56,320 --> 00:15:58,160
functional encryption scheme

435
00:15:58,160 --> 00:15:58,959
and

436
00:15:58,959 --> 00:16:01,600
give a special secret key corresponding

437
00:16:01,600 --> 00:16:03,839
to the fam spam filter

438
00:16:03,839 --> 00:16:06,160
to the email provider

439
00:16:06,160 --> 00:16:08,079
this key will allow the provider to

440
00:16:08,079 --> 00:16:10,240
learn the result of applying the spam

441
00:16:10,240 --> 00:16:12,720
filter to the content but it won't

442
00:16:12,720 --> 00:16:14,240
actually reveal anything else about the

443
00:16:14,240 --> 00:16:16,560
context of contents besides the single

444
00:16:16,560 --> 00:16:19,120
bit of whether the spam filter decided

445
00:16:19,120 --> 00:16:21,440
the contents were spam or not this will

446
00:16:21,440 --> 00:16:23,680
allow the provider to route the messages

447
00:16:23,680 --> 00:16:26,480
accordingly but will maintain

448
00:16:26,480 --> 00:16:29,040
the privacy of all other information in

449
00:16:29,040 --> 00:16:31,599
the message

450
00:16:32,079 --> 00:16:34,000
but now we ask what about security

451
00:16:34,000 --> 00:16:36,880
against the spammer concretely the

452
00:16:36,880 --> 00:16:39,360
spammer may try to learn how the spam

453
00:16:39,360 --> 00:16:42,399
filter works in order to design a cipher

454
00:16:42,399 --> 00:16:44,959
text that can circumvent the filter

455
00:16:44,959 --> 00:16:46,399
in particular you can imagine the

456
00:16:46,399 --> 00:16:49,199
spammer sending various cipher texts and

457
00:16:49,199 --> 00:16:51,040
then trying to learn whether or not the

458
00:16:51,040 --> 00:16:53,680
spam filter classified them as spam

459
00:16:53,680 --> 00:16:55,279
by observing for example whether the

460
00:16:55,279 --> 00:16:57,279
user clicked on a link in the email if

461
00:16:57,279 --> 00:16:58,880
the user clicked on a link

462
00:16:58,880 --> 00:17:00,079
then

463
00:17:00,079 --> 00:17:02,320
the spammer is reasonably confident that

464
00:17:02,320 --> 00:17:05,439
the email circumvented the spam filter

465
00:17:05,439 --> 00:17:06,799
and if the user doesn't click on the

466
00:17:06,799 --> 00:17:07,679
link

467
00:17:07,679 --> 00:17:10,079
then the spammer may hypothesize that

468
00:17:10,079 --> 00:17:13,599
the spam filter caught the message

469
00:17:14,240 --> 00:17:16,160
so basically the spammer in this setting

470
00:17:16,160 --> 00:17:18,640
is mounting a cca attack against the

471
00:17:18,640 --> 00:17:20,720
provider secret key in an attempt to

472
00:17:20,720 --> 00:17:23,039
learn about the spam filter

473
00:17:23,039 --> 00:17:24,400
and the natural question is what can the

474
00:17:24,400 --> 00:17:27,439
adversary learn through such an attack

475
00:17:27,439 --> 00:17:29,120
certainly it's unavoidable that the

476
00:17:29,120 --> 00:17:30,880
spammer can make black box queries to

477
00:17:30,880 --> 00:17:33,200
the spam filter given a message you can

478
00:17:33,200 --> 00:17:35,120
just encrypt it send it to the spam

479
00:17:35,120 --> 00:17:36,080
filter

480
00:17:36,080 --> 00:17:36,960
and

481
00:17:36,960 --> 00:17:39,440
see if it gets

482
00:17:39,440 --> 00:17:41,760
caught by the filter or not

483
00:17:41,760 --> 00:17:43,919
uh but the usual notions of security for

484
00:17:43,919 --> 00:17:46,000
functional encryption actually

485
00:17:46,000 --> 00:17:47,760
potentially allow the spammer to learn a

486
00:17:47,760 --> 00:17:50,799
lot more than just black box access they

487
00:17:50,799 --> 00:17:52,240
potentially allow

488
00:17:52,240 --> 00:17:54,559
the spammer to learn the actual code of

489
00:17:54,559 --> 00:17:56,320
the spam filter

490
00:17:56,320 --> 00:17:58,480
as the baroque at all unofficiatable

491
00:17:58,480 --> 00:17:59,760
functions show

492
00:17:59,760 --> 00:18:01,600
knowing the code may reveal more

493
00:18:01,600 --> 00:18:03,280
information about the spam filter than

494
00:18:03,280 --> 00:18:06,640
just having blackbox access

495
00:18:06,640 --> 00:18:09,280
we therefore propose a new notion of

496
00:18:09,280 --> 00:18:11,280
blackbox function privacy for functional

497
00:18:11,280 --> 00:18:13,280
encryption to

498
00:18:13,280 --> 00:18:15,520
uh capture this scenario

499
00:18:15,520 --> 00:18:17,760
essentially black box function privacy

500
00:18:17,760 --> 00:18:19,679
guarantees that the spammer

501
00:18:19,679 --> 00:18:22,160
is limited to just black box queries to

502
00:18:22,160 --> 00:18:23,919
the spam filter and can't learn anything

503
00:18:23,919 --> 00:18:26,080
beyond what can be learned by black box

504
00:18:26,080 --> 00:18:28,240
queries

505
00:18:28,240 --> 00:18:29,760
and we note that this notion is also

506
00:18:29,760 --> 00:18:31,600
needed for a trading trader tracing

507
00:18:31,600 --> 00:18:34,640
application to ensure that the cca

508
00:18:34,640 --> 00:18:36,000
attacks

509
00:18:36,000 --> 00:18:38,320
don't reveal the code of the embedded

510
00:18:38,320 --> 00:18:40,799
programs and only allow the programs to

511
00:18:40,799 --> 00:18:43,280
be queried on

512
00:18:43,280 --> 00:18:46,000
function inputs

513
00:18:46,000 --> 00:18:48,720
we show a simple transformation from any

514
00:18:48,720 --> 00:18:50,480
functional encryption scheme to one with

515
00:18:50,480 --> 00:18:53,039
black box privacy and this is where the

516
00:18:53,039 --> 00:18:56,760
musics come up

517
00:18:57,760 --> 00:19:00,240
all right so that that summarizes our

518
00:19:00,240 --> 00:19:02,160
our privacy

519
00:19:02,160 --> 00:19:04,559
result um and now we briefly discuss

520
00:19:04,559 --> 00:19:06,559
another potential limitation of the

521
00:19:06,559 --> 00:19:08,640
prior trader tracing literature that we

522
00:19:08,640 --> 00:19:10,640
explored in this work

523
00:19:10,640 --> 00:19:12,960
to motivate things consider a typical

524
00:19:12,960 --> 00:19:14,880
modeling assumption in the mpc

525
00:19:14,880 --> 00:19:17,120
literature which assumes a reliable

526
00:19:17,120 --> 00:19:18,720
broadcast channel

527
00:19:18,720 --> 00:19:20,320
this means any message sent to the

528
00:19:20,320 --> 00:19:22,080
broadcast channel is identically

529
00:19:22,080 --> 00:19:25,280
received by all parties why is such a

530
00:19:25,280 --> 00:19:26,799
model important

531
00:19:26,799 --> 00:19:28,880
well if you have an unreliable channel

532
00:19:28,880 --> 00:19:31,120
some users may know the adversary is

533
00:19:31,120 --> 00:19:33,600
malicious but others may think the

534
00:19:33,600 --> 00:19:36,000
adversary is honest and this would break

535
00:19:36,000 --> 00:19:38,960
the guarantees of many npc protocols

536
00:19:38,960 --> 00:19:40,400
we note that some works have developed

537
00:19:40,400 --> 00:19:42,080
protocols with point-to-point

538
00:19:42,080 --> 00:19:43,679
communication but typically at the cost

539
00:19:43,679 --> 00:19:46,559
of many more routes

540
00:19:46,559 --> 00:19:48,160
we now ask

541
00:19:48,160 --> 00:19:49,679
what if the broadcast channel is

542
00:19:49,679 --> 00:19:53,039
encrypted under a trader tracing scheme

543
00:19:53,039 --> 00:19:55,919
we will assume the cipher texts are sent

544
00:19:55,919 --> 00:19:57,600
the cybertechs themselves are sent over

545
00:19:57,600 --> 00:19:59,679
a reliable broadcast channel but the

546
00:19:59,679 --> 00:20:01,039
question then becomes will the virtual

547
00:20:01,039 --> 00:20:05,799
plaintext channel remain consistent

548
00:20:06,880 --> 00:20:08,640
and we show that for existing trader

549
00:20:08,640 --> 00:20:11,120
tracing schemes the answer is no and in

550
00:20:11,120 --> 00:20:12,320
particular

551
00:20:12,320 --> 00:20:14,480
uh we show an impossibility

552
00:20:14,480 --> 00:20:16,640
that if you have black box public

553
00:20:16,640 --> 00:20:18,880
tracing

554
00:20:18,880 --> 00:20:21,520
this allows anyone to compute ciphertext

555
00:20:21,520 --> 00:20:24,240
with inconsistent decryptions basically

556
00:20:24,240 --> 00:20:26,240
since the tracer learns the identity of

557
00:20:26,240 --> 00:20:29,360
a user just from queries in the blackbox

558
00:20:29,360 --> 00:20:30,720
setting

559
00:20:30,720 --> 00:20:32,320
different users must respond to these

560
00:20:32,320 --> 00:20:34,240
queries differently thereby having

561
00:20:34,240 --> 00:20:37,520
inconsistent decryptions

562
00:20:39,440 --> 00:20:41,039
on the other hand we give a partial

563
00:20:41,039 --> 00:20:43,919
positive result showing how to use

564
00:20:43,919 --> 00:20:46,480
functional fully homomorphic encryption

565
00:20:46,480 --> 00:20:49,360
and lockable obfuscation to achieve

566
00:20:49,360 --> 00:20:50,960
consistency

567
00:20:50,960 --> 00:20:53,600
the limitation of this work however is

568
00:20:53,600 --> 00:20:56,080
that we are only able to obtain

569
00:20:56,080 --> 00:20:58,480
tracing under a constant number of

570
00:20:58,480 --> 00:20:59,760
collusions

571
00:20:59,760 --> 00:21:01,600
and the efficiency of our scheme is

572
00:21:01,600 --> 00:21:05,280
exponential in this collusion bound

573
00:21:05,280 --> 00:21:06,720
note that even in the setting with the

574
00:21:06,720 --> 00:21:08,320
constant number of collusions however

575
00:21:08,320 --> 00:21:10,720
white box trees are tracing is still

576
00:21:10,720 --> 00:21:14,640
necessary per hour possibility

577
00:21:14,640 --> 00:21:17,120
our protocol and proof for for this are

578
00:21:17,120 --> 00:21:19,679
are pretty complicated but the basic

579
00:21:19,679 --> 00:21:21,440
idea is to start with a scheme where

580
00:21:21,440 --> 00:21:24,400
tracing requires a certain secret

581
00:21:24,400 --> 00:21:26,000
and this prevents users of the system

582
00:21:26,000 --> 00:21:27,360
from running the tracer tracing

583
00:21:27,360 --> 00:21:29,440
algorithm cells to learn the

584
00:21:29,440 --> 00:21:31,679
inconsistent decryptions because only

585
00:21:31,679 --> 00:21:34,159
who only the person who has

586
00:21:34,159 --> 00:21:37,280
the secret can run tracing

587
00:21:37,280 --> 00:21:39,200
but we want to allow public tracing so

588
00:21:39,200 --> 00:21:41,520
what do we do we encrypt the secrets

589
00:21:41,520 --> 00:21:43,360
under the fully homomorphic encryption

590
00:21:43,360 --> 00:21:44,480
scheme

591
00:21:44,480 --> 00:21:46,400
and have the tracer then perform the

592
00:21:46,400 --> 00:21:49,360
tracing algorithm homomorphically using

593
00:21:49,360 --> 00:21:51,280
the decoder program

594
00:21:51,280 --> 00:21:52,720
note that this homomorphic tracing

595
00:21:52,720 --> 00:21:54,320
cannot be accomplished with just black

596
00:21:54,320 --> 00:21:55,919
box access because you actually need the

597
00:21:55,919 --> 00:21:57,679
program code in order to do the

598
00:21:57,679 --> 00:22:00,400
homomorphic operations

599
00:22:00,400 --> 00:22:03,280
uh the problem though is that the

600
00:22:03,280 --> 00:22:05,919
results of tracing remain encrypted in

601
00:22:05,919 --> 00:22:08,000
the fhe scheme

602
00:22:08,000 --> 00:22:09,840
so to get the results of tracing in the

603
00:22:09,840 --> 00:22:11,760
clear we need to use lockable

604
00:22:11,760 --> 00:22:14,240
obfuscation and due to another number of

605
00:22:14,240 --> 00:22:16,320
subtle issues that come up in making

606
00:22:16,320 --> 00:22:18,480
everything work this outline appears

607
00:22:18,480 --> 00:22:19,840
that stuck at handling a constant

608
00:22:19,840 --> 00:22:22,320
collusion

609
00:22:22,480 --> 00:22:24,799
we therefore leave improving our results

610
00:22:24,799 --> 00:22:27,200
or showing an impossibility

611
00:22:27,200 --> 00:22:30,000
uh for fully collusion resistant

612
00:22:30,000 --> 00:22:31,200
consistent

613
00:22:31,200 --> 00:22:35,440
tracing as an interesting open question

614
00:22:35,440 --> 00:22:37,039
i'll now conclude with an interesting

615
00:22:37,039 --> 00:22:39,120
direction for future work

616
00:22:39,120 --> 00:22:41,039
note that trader tracing can be seen as

617
00:22:41,039 --> 00:22:43,679
a special case of a more general problem

618
00:22:43,679 --> 00:22:46,000
of water making software

619
00:22:46,000 --> 00:22:48,000
where trader tracing is a special case

620
00:22:48,000 --> 00:22:48,799
of

621
00:22:48,799 --> 00:22:52,320
watermarking decryption programs

622
00:22:52,320 --> 00:22:54,960
all prior water marking results

623
00:22:54,960 --> 00:22:57,760
analogous to trader tracing use black

624
00:22:57,760 --> 00:22:59,600
box tracing algorithms to extract the

625
00:22:59,600 --> 00:23:01,200
watermark

626
00:23:01,200 --> 00:23:03,360
as a consequence similar privacy and

627
00:23:03,360 --> 00:23:05,520
consistency issues may arrive in the

628
00:23:05,520 --> 00:23:07,760
more general water marking setting

629
00:23:07,760 --> 00:23:09,280
so an interesting direction is to

630
00:23:09,280 --> 00:23:11,840
explore white box techniques in this

631
00:23:11,840 --> 00:23:13,120
more general

632
00:23:13,120 --> 00:23:15,439
setting

633
00:23:16,640 --> 00:23:19,520
another interesting direction

634
00:23:19,520 --> 00:23:21,440
it is known that some programs cannot be

635
00:23:21,440 --> 00:23:23,679
watermarked for example unlearnable or

636
00:23:23,679 --> 00:23:26,000
even unofficiatable programs cannot be

637
00:23:26,000 --> 00:23:27,440
watermarked

638
00:23:27,440 --> 00:23:29,280
on the other hand we have a number of

639
00:23:29,280 --> 00:23:31,600
positive results for watermarking but

640
00:23:31,600 --> 00:23:33,280
there is a large gap between these

641
00:23:33,280 --> 00:23:35,679
positive and negative results

642
00:23:35,679 --> 00:23:37,039
so an interesting question is whether

643
00:23:37,039 --> 00:23:38,640
white box tracing

644
00:23:38,640 --> 00:23:40,640
can allow for watermarking more general

645
00:23:40,640 --> 00:23:42,720
programs than are possible using just

646
00:23:42,720 --> 00:23:45,679
black box tracing

647
00:23:46,080 --> 00:23:48,400
all right this concludes my talk thank

648
00:23:48,400 --> 00:23:51,720
you for listening

