1
00:00:00,480 --> 00:00:02,480
give me one second to get everything up

2
00:00:02,480 --> 00:00:04,960
and running

3
00:00:05,759 --> 00:00:07,359
there you go have a good session all

4
00:00:07,359 --> 00:00:09,120
right great thanks so thanks everyone

5
00:00:09,120 --> 00:00:11,360
for coming so this is the session on

6
00:00:11,360 --> 00:00:13,840
succinct arguments uh we'll have six

7
00:00:13,840 --> 00:00:16,320
talks uh this session and as in previous

8
00:00:16,320 --> 00:00:18,800
sessions what we'll do is we'll have all

9
00:00:18,800 --> 00:00:22,000
of the five-minute talks from uh

10
00:00:22,000 --> 00:00:23,840
each presenter and then we'll have a big

11
00:00:23,840 --> 00:00:26,480
block for questions at the end so if you

12
00:00:26,480 --> 00:00:28,400
have questions for the speakers please

13
00:00:28,400 --> 00:00:30,960
feel free to post them in the zoom chat

14
00:00:30,960 --> 00:00:32,800
you can post them on the zulu chat or

15
00:00:32,800 --> 00:00:35,040
you can also ask them directly

16
00:00:35,040 --> 00:00:35,920
after

17
00:00:35,920 --> 00:00:38,320
we conclude the talks in this session

18
00:00:38,320 --> 00:00:40,640
so without further ado let's uh start so

19
00:00:40,640 --> 00:00:42,879
the first talk in this session will be

20
00:00:42,879 --> 00:00:44,960
halo infinite proof carrying data from

21
00:00:44,960 --> 00:00:46,960
additive polynomial commitments by ben

22
00:00:46,960 --> 00:00:49,600
fish ambone ariel gabizon and justin

23
00:00:49,600 --> 00:00:52,079
drake and then we'll give the talk

24
00:00:52,079 --> 00:00:55,280
thanks david thanks for the intro

25
00:00:55,280 --> 00:00:57,600
so proof carrying data is an extension

26
00:00:57,600 --> 00:00:59,520
of verifiable computation so i'll

27
00:00:59,520 --> 00:01:01,359
briefly review this this is a

28
00:01:01,359 --> 00:01:02,960
non-interactive proof system which

29
00:01:02,960 --> 00:01:04,799
enables approver to demonstrate

30
00:01:04,799 --> 00:01:07,119
knowledge of a private input to a

31
00:01:07,119 --> 00:01:08,799
program called a witness

32
00:01:08,799 --> 00:01:11,040
that causes the program to output one

33
00:01:11,040 --> 00:01:12,720
and the proof should be small and fast

34
00:01:12,720 --> 00:01:15,280
to verify even as the program grows very

35
00:01:15,280 --> 00:01:17,759
complex or the witness grows very long

36
00:01:17,759 --> 00:01:19,680
it should be infeasible to produce this

37
00:01:19,680 --> 00:01:22,080
proof without knowledge of the witness

38
00:01:22,080 --> 00:01:24,799
and zero knowledge is an extra feature

39
00:01:24,799 --> 00:01:26,400
which says that the proof doesn't reveal

40
00:01:26,400 --> 00:01:28,240
anything about the witness

41
00:01:28,240 --> 00:01:31,119
so incrementally verifiable computation

42
00:01:31,119 --> 00:01:34,159
or ivc enables incrementally updating a

43
00:01:34,159 --> 00:01:36,400
proof of a computation's correctness as

44
00:01:36,400 --> 00:01:38,320
the computation evolves

45
00:01:38,320 --> 00:01:40,799
and for ivc to be non-trivial the cost

46
00:01:40,799 --> 00:01:42,799
to produce the next proof at the i-th

47
00:01:42,799 --> 00:01:44,960
iteration uh given the local state

48
00:01:44,960 --> 00:01:46,880
should be cheaper than proving the whole

49
00:01:46,880 --> 00:01:48,960
computation from scratch or sublinear in

50
00:01:48,960 --> 00:01:50,159
the depth

51
00:01:50,159 --> 00:01:51,759
and should not require the previous

52
00:01:51,759 --> 00:01:52,960
local inputs which may have been

53
00:01:52,960 --> 00:01:54,720
discarded

54
00:01:54,720 --> 00:01:59,040
proof carrying data generalizes ivc to a

55
00:01:59,040 --> 00:02:00,880
distributed computation

56
00:02:00,880 --> 00:02:02,719
any distributed computation that occurs

57
00:02:02,719 --> 00:02:05,680
along the nodes of a directed acyclic

58
00:02:05,680 --> 00:02:08,680
graph

59
00:02:09,280 --> 00:02:11,038
classical constructions of proof

60
00:02:11,038 --> 00:02:13,599
carrying data used a concept called

61
00:02:13,599 --> 00:02:15,680
proof recursion and the higher level

62
00:02:15,680 --> 00:02:18,400
idea is that the proof in this example

63
00:02:18,400 --> 00:02:20,400
pi i plus 1 is a proof for a witness

64
00:02:20,400 --> 00:02:22,080
that includes the previous proof the

65
00:02:22,080 --> 00:02:25,440
previous output the local input

66
00:02:25,440 --> 00:02:27,280
and this is a witness for a program that

67
00:02:27,280 --> 00:02:29,440
actually checks the snark verification

68
00:02:29,440 --> 00:02:31,280
of the previous proof and the local

69
00:02:31,280 --> 00:02:32,879
computation's correctness now i'm

70
00:02:32,879 --> 00:02:35,040
skipping some details of the program

71
00:02:35,040 --> 00:02:36,720
which actually enable it to reference

72
00:02:36,720 --> 00:02:38,720
its own verifier

73
00:02:38,720 --> 00:02:40,160
but for this to be possible it's

74
00:02:40,160 --> 00:02:42,000
necessary that the snark verifier is

75
00:02:42,000 --> 00:02:44,080
succinct or sublinear in the size of the

76
00:02:44,080 --> 00:02:47,040
program it verifies proofs for

77
00:02:47,040 --> 00:02:49,599
halo was the first pcd based on an

78
00:02:49,599 --> 00:02:51,200
underlying proof system that has a

79
00:02:51,200 --> 00:02:53,760
linear time verifier and it manages to

80
00:02:53,760 --> 00:02:55,200
do this by

81
00:02:55,200 --> 00:02:57,120
using proof recursion in a way that does

82
00:02:57,120 --> 00:02:59,280
not include the full verifier in the

83
00:02:59,280 --> 00:03:01,519
incremental progress program

84
00:03:01,519 --> 00:03:04,640
so our work generalizes halo for a very

85
00:03:04,640 --> 00:03:07,440
broad class of proof systems

86
00:03:07,440 --> 00:03:09,680
now there's two really important

87
00:03:09,680 --> 00:03:11,760
recent papers very related to ours that

88
00:03:11,760 --> 00:03:13,760
i'd like to mention here uh one of which

89
00:03:13,760 --> 00:03:16,000
benedict is presenting in the next talk

90
00:03:16,000 --> 00:03:19,599
um so bcms20 formalized and generalized

91
00:03:19,599 --> 00:03:21,680
the halo method identifying an

92
00:03:21,680 --> 00:03:23,200
underlying necessary property of the

93
00:03:23,200 --> 00:03:25,519
argument system called an accumulation

94
00:03:25,519 --> 00:03:26,720
scheme

95
00:03:26,720 --> 00:03:29,519
and bc lms 20 which is what benedict

96
00:03:29,519 --> 00:03:32,080
will present next further generalizes

97
00:03:32,080 --> 00:03:34,400
halo to work with even non-succinct

98
00:03:34,400 --> 00:03:36,400
argument systems that have something

99
00:03:36,400 --> 00:03:38,720
they call a split accumulation scheme

100
00:03:38,720 --> 00:03:40,239
and so while those works focus on

101
00:03:40,239 --> 00:03:42,239
defining the abstraction of accumulation

102
00:03:42,239 --> 00:03:44,480
schemes for proof systems and how to use

103
00:03:44,480 --> 00:03:47,360
them to build pcd ours focuses on

104
00:03:47,360 --> 00:03:49,519
properties of polynomial commitment

105
00:03:49,519 --> 00:03:52,400
schemes that lead to proof systems with

106
00:03:52,400 --> 00:03:54,400
accumulation and split accumulation and

107
00:03:54,400 --> 00:03:56,720
simple properties such as additivity and

108
00:03:56,720 --> 00:03:58,879
we give generic constructions

109
00:03:58,879 --> 00:04:02,159
from these underlying primitives

110
00:04:02,239 --> 00:04:04,239
so briefly polynomial commitment schemes

111
00:04:04,239 --> 00:04:06,080
combine a normal commitment scheme to

112
00:04:06,080 --> 00:04:08,640
polynomials over a finite field of a

113
00:04:08,640 --> 00:04:10,080
specified degree

114
00:04:10,080 --> 00:04:12,879
with a non-interactive proof that

115
00:04:12,879 --> 00:04:14,959
enables proving evaluations of the

116
00:04:14,959 --> 00:04:16,880
committed polynomials at points and it

117
00:04:16,880 --> 00:04:18,399
turns out that polynomial commitment

118
00:04:18,399 --> 00:04:20,320
schemes can be used to build proof

119
00:04:20,320 --> 00:04:22,479
systems where roughly the efficiency of

120
00:04:22,479 --> 00:04:24,800
the proof system in terms of prover time

121
00:04:24,800 --> 00:04:27,280
proof size and verification time are all

122
00:04:27,280 --> 00:04:29,040
dominated by the efficiency of the

123
00:04:29,040 --> 00:04:31,199
polynomial commitment scheme

124
00:04:31,199 --> 00:04:33,360
an additive polynomial commitment scheme

125
00:04:33,360 --> 00:04:35,199
also comes with a defined addition

126
00:04:35,199 --> 00:04:37,600
operation which enables taking linear

127
00:04:37,600 --> 00:04:39,520
combinations of commitments and the

128
00:04:39,520 --> 00:04:41,280
linear combination should itself be a

129
00:04:41,280 --> 00:04:42,960
valid commitment to the linear

130
00:04:42,960 --> 00:04:45,120
combination of the underlying committed

131
00:04:45,120 --> 00:04:47,360
polynomials so there should also be a

132
00:04:47,360 --> 00:04:49,440
way to derive an opening hint for the

133
00:04:49,440 --> 00:04:51,120
linear combination from the opening

134
00:04:51,120 --> 00:04:53,600
hints of the input commitments

135
00:04:53,600 --> 00:04:55,360
now it's actually always possible to

136
00:04:55,360 --> 00:04:57,600
define an addition operation trivially

137
00:04:57,600 --> 00:04:59,199
such as just defining it to be the

138
00:04:59,199 --> 00:05:01,280
formal addition of commitments so it's

139
00:05:01,280 --> 00:05:03,759
non-trivial when the addition operation

140
00:05:03,759 --> 00:05:05,520
is actually compressing

141
00:05:05,520 --> 00:05:08,000
or the set of commitments to polynomials

142
00:05:08,000 --> 00:05:09,759
without a degree closed under addition

143
00:05:09,759 --> 00:05:12,560
has polynomial bounded size

144
00:05:12,560 --> 00:05:14,639
now we define linear combination schemes

145
00:05:14,639 --> 00:05:17,520
to generalize additivity perhaps there's

146
00:05:17,520 --> 00:05:19,919
no compressing addition operation but

147
00:05:19,919 --> 00:05:22,000
there is a protocol between a verifier

148
00:05:22,000 --> 00:05:23,120
and approver

149
00:05:23,120 --> 00:05:25,280
which outputs a succinct commitment to

150
00:05:25,280 --> 00:05:26,880
the linear combination with a proof of

151
00:05:26,880 --> 00:05:29,759
correctness that the verifier can check

152
00:05:29,759 --> 00:05:31,360
and we call the linear combination

153
00:05:31,360 --> 00:05:34,080
efficient if the verifier is sublinear

154
00:05:34,080 --> 00:05:36,240
in the degree maximum degree of the of

155
00:05:36,240 --> 00:05:40,080
the input committed polynomials

156
00:05:40,080 --> 00:05:42,479
so our results can be stated informally

157
00:05:42,479 --> 00:05:44,720
as we can achieve pcd from any

158
00:05:44,720 --> 00:05:46,479
polynomial commitment scheme with an

159
00:05:46,479 --> 00:05:48,880
efficient linear combination scheme

160
00:05:48,880 --> 00:05:50,800
and the proving time inherits the same

161
00:05:50,800 --> 00:05:52,800
efficiency as the commitment scheme on

162
00:05:52,800 --> 00:05:54,639
polynomials of degree

163
00:05:54,639 --> 00:05:56,479
roughly the size of the local

164
00:05:56,479 --> 00:05:58,080
computation plus the size of the

165
00:05:58,080 --> 00:05:59,840
verifier for the linear combination

166
00:05:59,840 --> 00:06:01,039
scheme

167
00:06:01,039 --> 00:06:03,440
and if the pcs is additive then we can

168
00:06:03,440 --> 00:06:06,400
actually inherit the proof size as well

169
00:06:06,400 --> 00:06:08,560
this statement is informal because

170
00:06:08,560 --> 00:06:10,319
constructing pcd from polynomial

171
00:06:10,319 --> 00:06:13,120
commitments requires non-black bog use

172
00:06:13,120 --> 00:06:15,280
black blocks use of a random oracle and

173
00:06:15,280 --> 00:06:16,800
so there's a more formal way to state

174
00:06:16,800 --> 00:06:18,880
this but actually benedict's talk will

175
00:06:18,880 --> 00:06:21,280
talk more about that so without further

176
00:06:21,280 --> 00:06:22,240
ado

177
00:06:22,240 --> 00:06:25,440
that's the end of my five minutes

178
00:06:25,440 --> 00:06:28,479
great so thanks ben for the talk so

179
00:06:28,479 --> 00:06:30,240
let's move on to our next speaker so

180
00:06:30,240 --> 00:06:33,600
just a reminder in case you came in late

181
00:06:33,600 --> 00:06:35,280
we'll hold off all the questions until

182
00:06:35,280 --> 00:06:37,120
the end of the session

183
00:06:37,120 --> 00:06:39,039
so our next talk in this session will be

184
00:06:39,039 --> 00:06:40,960
on proof caring data without succinct

185
00:06:40,960 --> 00:06:43,199
arguments by benedict boone's alessandro

186
00:06:43,199 --> 00:06:46,080
ghieza william lin pratyush mishra and

187
00:06:46,080 --> 00:06:47,919
luke spooner and benedict will give the

188
00:06:47,919 --> 00:06:50,000
talk

189
00:06:50,000 --> 00:06:51,919
um thank you david

190
00:06:51,919 --> 00:06:53,599
so

191
00:06:53,599 --> 00:06:55,440
let's uh ben already gave an

192
00:06:55,440 --> 00:06:57,520
introduction to ibc but i'll give a

193
00:06:57,520 --> 00:06:59,680
quick recall that

194
00:06:59,680 --> 00:07:01,919
you know say imagine you're doing a long

195
00:07:01,919 --> 00:07:04,240
computation a t-step non-deterministic

196
00:07:04,240 --> 00:07:06,000
computation and say you want to

197
00:07:06,000 --> 00:07:07,680
outsource that to

198
00:07:07,680 --> 00:07:09,759
an untrusted server

199
00:07:09,759 --> 00:07:12,880
and there's multiple ways to to do this

200
00:07:12,880 --> 00:07:14,880
one of them is that the server simply

201
00:07:14,880 --> 00:07:16,400
does the computation

202
00:07:16,400 --> 00:07:20,000
and then afterwards it produces a proof

203
00:07:20,000 --> 00:07:23,360
that the computation was done correctly

204
00:07:23,360 --> 00:07:25,360
this unfortunately has multiple issues

205
00:07:25,360 --> 00:07:27,759
one of them is that typically this

206
00:07:27,759 --> 00:07:30,400
requires the prover to store all of the

207
00:07:30,400 --> 00:07:33,120
intermediate steps of the computation in

208
00:07:33,120 --> 00:07:34,800
its head

209
00:07:34,800 --> 00:07:36,880
and additionally even if there's a

210
00:07:36,880 --> 00:07:39,360
simple transition function describing

211
00:07:39,360 --> 00:07:41,280
how to advance the computation from one

212
00:07:41,280 --> 00:07:42,639
step to another

213
00:07:42,639 --> 00:07:44,960
if we do that and we then want to prove

214
00:07:44,960 --> 00:07:47,199
correctness of now this t plus one step

215
00:07:47,199 --> 00:07:49,120
computation well then we would need to

216
00:07:49,120 --> 00:07:51,759
recompute the entire to prove

217
00:07:51,759 --> 00:07:54,400
in order to circumvent these issues

218
00:07:54,400 --> 00:07:56,400
we have something called ibc or

219
00:07:56,400 --> 00:07:58,800
incrementally verifiable computation

220
00:07:58,800 --> 00:08:01,440
where the general idea is to interleave

221
00:08:01,440 --> 00:08:04,400
the proving and the evaluation so we

222
00:08:04,400 --> 00:08:07,280
have an ivc prover that can advance the

223
00:08:07,280 --> 00:08:09,680
computation and at the same time it

224
00:08:09,680 --> 00:08:11,440
takes a proof that

225
00:08:11,440 --> 00:08:12,639
all of the previous steps of the

226
00:08:12,639 --> 00:08:14,560
computation were done correctly and

227
00:08:14,560 --> 00:08:16,800
updates it and

228
00:08:16,800 --> 00:08:19,199
so incrementally updates it

229
00:08:19,199 --> 00:08:21,680
to become now a proof that say t plus

230
00:08:21,680 --> 00:08:23,039
one steps of the computation would

231
00:08:23,039 --> 00:08:24,319
encrypt

232
00:08:24,319 --> 00:08:25,360
and

233
00:08:25,360 --> 00:08:27,120
as ben said this can be generalized to

234
00:08:27,120 --> 00:08:30,720
pcb for from path grabs to any arbitrary

235
00:08:30,720 --> 00:08:31,520
deck

236
00:08:31,520 --> 00:08:34,640
and pcd and ivc have many applications

237
00:08:34,640 --> 00:08:36,880
some in the realm of for of like these

238
00:08:36,880 --> 00:08:39,839
long computations such as succinct block

239
00:08:39,839 --> 00:08:41,120
or

240
00:08:41,120 --> 00:08:43,360
verifiable lay functions but also some

241
00:08:43,360 --> 00:08:46,080
that are more about multiple

242
00:08:46,080 --> 00:08:47,839
provers that want to

243
00:08:47,839 --> 00:08:50,080
compute some proof together for example

244
00:08:50,080 --> 00:08:52,839
zk cluster computing or verifiable image

245
00:08:52,839 --> 00:08:54,959
editing so

246
00:08:54,959 --> 00:08:56,399
this leads us to the question how we

247
00:08:56,399 --> 00:08:59,360
actually construct ibc and historically

248
00:08:59,360 --> 00:09:01,519
and ivc we've seen is a very powerful

249
00:09:01,519 --> 00:09:03,360
primitive but historically we've also

250
00:09:03,360 --> 00:09:04,880
constructed from another very powerful

251
00:09:04,880 --> 00:09:06,839
primitives namely

252
00:09:06,839 --> 00:09:08,720
snarks

253
00:09:08,720 --> 00:09:09,440
so

254
00:09:09,440 --> 00:09:12,320
bct 13 showed that you can construct ivc

255
00:09:12,320 --> 00:09:15,040
from snarks with six very succinct uh

256
00:09:15,040 --> 00:09:17,279
verification and this has actually been

257
00:09:17,279 --> 00:09:19,600
instantiated using pre-processing snarks

258
00:09:19,600 --> 00:09:21,680
and cycles of uh carrying friendly

259
00:09:21,680 --> 00:09:23,279
elliptic curves

260
00:09:23,279 --> 00:09:25,600
and then more recently this uh

261
00:09:25,600 --> 00:09:27,040
requirement these requirements were

262
00:09:27,040 --> 00:09:29,360
relaxed so for example cost 20 showed

263
00:09:29,360 --> 00:09:31,120
that it actually suffices to have a

264
00:09:31,120 --> 00:09:32,720
snark with any sort of subliner

265
00:09:32,720 --> 00:09:35,440
verification and as ben mentioned in

266
00:09:35,440 --> 00:09:37,600
bcms 20 we showed that you can build

267
00:09:37,600 --> 00:09:39,680
this from a snark with

268
00:09:39,680 --> 00:09:41,600
sublinear accumulation and this builds

269
00:09:41,600 --> 00:09:44,800
on ideas proposed in halo

270
00:09:44,800 --> 00:09:46,399
but this leads to the natural question

271
00:09:46,399 --> 00:09:48,880
if we actually need a snark in order to

272
00:09:48,880 --> 00:09:52,000
build ivc do we really need that

273
00:09:52,000 --> 00:09:55,120
the proof size itself is succinct

274
00:09:55,120 --> 00:09:57,760
and to some degree you might assume this

275
00:09:57,760 --> 00:10:00,399
is the case because from ivc itself you

276
00:10:00,399 --> 00:10:02,640
can build snarks but we actually show

277
00:10:02,640 --> 00:10:04,959
that you can build ivc in pcd from

278
00:10:04,959 --> 00:10:07,360
something that is qualitatively simpler

279
00:10:07,360 --> 00:10:09,200
than a snark

280
00:10:09,200 --> 00:10:10,079
so

281
00:10:10,079 --> 00:10:12,800
our theory contributions are that we

282
00:10:12,800 --> 00:10:14,320
introduce something called split

283
00:10:14,320 --> 00:10:15,920
accumulation schemes

284
00:10:15,920 --> 00:10:19,920
and we show that if you have a narc so

285
00:10:19,920 --> 00:10:21,120
this is

286
00:10:21,120 --> 00:10:23,519
a snark that has no succinctless

287
00:10:23,519 --> 00:10:25,200
requirements it's just a non-interactive

288
00:10:25,200 --> 00:10:26,959
argument of knowledge

289
00:10:26,959 --> 00:10:29,600
that has such a split accumulation

290
00:10:29,600 --> 00:10:31,760
scheme associated with it well then

291
00:10:31,760 --> 00:10:34,000
there's no succinctness necessary the

292
00:10:34,000 --> 00:10:36,160
asterisk here is because there's you

293
00:10:36,160 --> 00:10:37,839
need to if the accumulation scheme

294
00:10:37,839 --> 00:10:40,000
itself involves sprues then these proofs

295
00:10:40,000 --> 00:10:42,640
need to be succinct but the narc itself

296
00:10:42,640 --> 00:10:44,240
has to be successful

297
00:10:44,240 --> 00:10:46,880
and this is not just a you know nice

298
00:10:46,880 --> 00:10:48,800
abstract result but

299
00:10:48,800 --> 00:10:51,760
we actually show that uh so in and ben's

300
00:10:51,760 --> 00:10:53,360
talk showed that there is you can

301
00:10:53,360 --> 00:10:55,200
construct this from any split

302
00:10:55,200 --> 00:10:56,959
accumulation scheme from any additive

303
00:10:56,959 --> 00:10:58,959
polynomial commitment but additionally

304
00:10:58,959 --> 00:11:01,760
we show that there is an arc a really

305
00:11:01,760 --> 00:11:03,760
really simple narc actually

306
00:11:03,760 --> 00:11:05,200
um

307
00:11:05,200 --> 00:11:07,360
and a very simple split accumulation

308
00:11:07,360 --> 00:11:10,399
scheme directly for r1cs

309
00:11:10,399 --> 00:11:12,720
and that is secure under the discrete

310
00:11:12,720 --> 00:11:15,200
log assumption in the random arc mode

311
00:11:15,200 --> 00:11:17,760
whose accumulation verifier is extremely

312
00:11:17,760 --> 00:11:20,079
efficient it does like three scalar

313
00:11:20,079 --> 00:11:23,120
multiplications and so it's constant but

314
00:11:23,120 --> 00:11:25,600
even the constants are very small

315
00:11:25,600 --> 00:11:28,079
there's this one gap here which is that

316
00:11:28,079 --> 00:11:29,360
theorem two

317
00:11:29,360 --> 00:11:31,040
holds in the and

318
00:11:31,040 --> 00:11:33,680
previously this was all log n so there's

319
00:11:33,680 --> 00:11:36,720
one gap here that in theorem two holds

320
00:11:36,720 --> 00:11:38,399
in the random oracle model so this

321
00:11:38,399 --> 00:11:40,000
construction is occur in the random

322
00:11:40,000 --> 00:11:42,399
oracle model and theorem two holds in

323
00:11:42,399 --> 00:11:44,560
the standard model or requires objects

324
00:11:44,560 --> 00:11:47,120
in the standard model so we have to do a

325
00:11:47,120 --> 00:11:49,200
heuristic jump here which is common for

326
00:11:49,200 --> 00:11:52,320
all of these pct constructions that um

327
00:11:52,320 --> 00:11:55,519
the objects in theorem 2 are still

328
00:11:55,519 --> 00:11:57,760
secure once we instantiate them with a

329
00:11:57,760 --> 00:11:59,519
secure hashtag

330
00:11:59,519 --> 00:12:00,959
we also

331
00:12:00,959 --> 00:12:03,760
implement uh the we implemented our

332
00:12:03,760 --> 00:12:04,639
scheme

333
00:12:04,639 --> 00:12:06,000
and we did that because it is really

334
00:12:06,000 --> 00:12:09,360
attractive asymptotic so for example the

335
00:12:09,360 --> 00:12:11,120
uh one of the key things is that the

336
00:12:11,120 --> 00:12:13,040
recursive circuit is really really small

337
00:12:13,040 --> 00:12:16,320
as this and the setup is transparent but

338
00:12:16,320 --> 00:12:18,399
also what is important for implement is

339
00:12:18,399 --> 00:12:20,800
that you need usually for to implement

340
00:12:20,800 --> 00:12:23,120
these recursive circuits you need cycles

341
00:12:23,120 --> 00:12:24,959
of elliptic curves and the requirement

342
00:12:24,959 --> 00:12:27,120
on the cycle of the elliptic curve is

343
00:12:27,120 --> 00:12:30,560
extremely limited so any to any

344
00:12:30,560 --> 00:12:32,800
cycle occurs where both curves are

345
00:12:32,800 --> 00:12:34,800
secure under the discrete logarithm

346
00:12:34,800 --> 00:12:37,680
assumption will suffice to build this

347
00:12:37,680 --> 00:12:39,839
and

348
00:12:39,839 --> 00:12:41,360
this is important because it makes it

349
00:12:41,360 --> 00:12:44,399
much more easy to find these cycles

350
00:12:44,399 --> 00:12:45,519
so

351
00:12:45,519 --> 00:12:47,040
we then implemented the scheme

352
00:12:47,040 --> 00:12:49,839
concretely in the artworks library and

353
00:12:49,839 --> 00:12:53,680
we evaluated the scheme showing that it

354
00:12:53,680 --> 00:12:56,079
significantly outperforms previous

355
00:12:56,079 --> 00:12:58,880
constructions so you can see that

356
00:12:58,880 --> 00:13:01,680
this is the gross 16

357
00:13:01,680 --> 00:13:04,399
recursive snark and dcms20 and we can

358
00:13:04,399 --> 00:13:06,800
see that there's about a factor of five

359
00:13:06,800 --> 00:13:10,639
gap uh even in the smallest case and

360
00:13:10,639 --> 00:13:12,399
the there's there might still be

361
00:13:12,399 --> 00:13:14,639
optimizations here but because we use

362
00:13:14,639 --> 00:13:16,160
all the same tools

363
00:13:16,160 --> 00:13:18,800
the comparison should be unaffected

364
00:13:18,800 --> 00:13:21,040
so yeah thank you very much this is my

365
00:13:21,040 --> 00:13:23,279
five minute talks and um please watch

366
00:13:23,279 --> 00:13:24,720
the full talk and

367
00:13:24,720 --> 00:13:27,120
read the paper

368
00:13:27,120 --> 00:13:30,480
great so thanks benedict uh for the talk

369
00:13:30,480 --> 00:13:32,480
so moving on to the next talk in this

370
00:13:32,480 --> 00:13:34,800
session we have sub-quadratic snarks in

371
00:13:34,800 --> 00:13:36,880
the random oracle model by alessandro

372
00:13:36,880 --> 00:13:39,360
queza and elon johan and elon will give

373
00:13:39,360 --> 00:13:41,760
the talk

374
00:13:43,360 --> 00:13:47,480
i think you're muted hello

375
00:13:51,920 --> 00:13:53,519
as

376
00:13:53,519 --> 00:13:54,560
okay

377
00:13:54,560 --> 00:13:56,639
yes that was not a minute i couldn't

378
00:13:56,639 --> 00:14:00,600
find button here

379
00:14:05,360 --> 00:14:07,680
okay

380
00:14:07,680 --> 00:14:10,000
uh okay so this is sub quadratic stars

381
00:14:10,000 --> 00:14:11,440
in the random oracle model as we

382
00:14:11,440 --> 00:14:13,120
mentioned this is john furrier with

383
00:14:13,120 --> 00:14:15,519
alexandra i'm melanie

384
00:14:15,519 --> 00:14:18,880
um okay so we i guess in this session we

385
00:14:18,880 --> 00:14:21,519
know what snarks are okay

386
00:14:21,519 --> 00:14:24,399
the focus here is snargs purely in the

387
00:14:24,399 --> 00:14:26,079
random oracle model

388
00:14:26,079 --> 00:14:29,519
okay so the prover and verifier share

389
00:14:29,519 --> 00:14:31,760
this truly random function that outputs

390
00:14:31,760 --> 00:14:33,440
lambda bits

391
00:14:33,440 --> 00:14:35,120
okay and it's non-interactive it's

392
00:14:35,120 --> 00:14:37,440
succinct and the computation the

393
00:14:37,440 --> 00:14:40,399
soundness is computational okay or in

394
00:14:40,399 --> 00:14:43,360
the oracle model what i more precisely

395
00:14:43,360 --> 00:14:46,560
mean that we have t epsilon security

396
00:14:46,560 --> 00:14:49,040
so any cheating proverb that does

397
00:14:49,040 --> 00:14:51,600
t queries to the random oracle and this

398
00:14:51,600 --> 00:14:53,920
cheating pool can be computationally

399
00:14:53,920 --> 00:14:55,760
unbounded okay but makes it mostly

400
00:14:55,760 --> 00:14:56,720
queries

401
00:14:56,720 --> 00:14:58,800
and then produces a proof the

402
00:14:58,800 --> 00:15:00,720
probability that the verifier accepts is

403
00:15:00,720 --> 00:15:03,120
at most epsilon okay

404
00:15:03,120 --> 00:15:05,199
so if you do at mostly queries your

405
00:15:05,199 --> 00:15:07,040
success probability is at most epsilon

406
00:15:07,040 --> 00:15:08,959
for any cheat improvement so these are

407
00:15:08,959 --> 00:15:12,639
slugs in the random oracle model

408
00:15:12,639 --> 00:15:15,360
there are several uh constructions okay

409
00:15:15,360 --> 00:15:18,399
fiat mirrors actually one mikali and

410
00:15:18,399 --> 00:15:21,199
recently bcs construction

411
00:15:21,199 --> 00:15:24,000
they all work in the same

412
00:15:24,000 --> 00:15:26,560
paradigm you take some information

413
00:15:26,560 --> 00:15:29,680
theoretic proof okay an ipo of a pcp or

414
00:15:29,680 --> 00:15:32,000
an iop you compile it with a

415
00:15:32,000 --> 00:15:33,600
cryptographic commitment this is a

416
00:15:33,600 --> 00:15:35,040
merkle tree

417
00:15:35,040 --> 00:15:37,759
usually and together you get a succinct

418
00:15:37,759 --> 00:15:39,279
argument

419
00:15:39,279 --> 00:15:41,839
and very briefly like what is michali's

420
00:15:41,839 --> 00:15:43,839
construction okay the

421
00:15:43,839 --> 00:15:44,720
uh

422
00:15:44,720 --> 00:15:47,600
probably the most famous one until bcs

423
00:15:47,600 --> 00:15:50,399
you just you take a pcp

424
00:15:50,399 --> 00:15:53,120
okay for the language that you want uh

425
00:15:53,120 --> 00:15:55,199
you make the approval commit to it okay

426
00:15:55,199 --> 00:15:57,680
using a merkle tree you apply the random

427
00:15:57,680 --> 00:15:59,440
oracle on the root of the commitment to

428
00:15:59,440 --> 00:16:02,399
derive the pcp randomness this tells you

429
00:16:02,399 --> 00:16:04,240
all the queries that the verifier wants

430
00:16:04,240 --> 00:16:06,720
to open and then the proof contains the

431
00:16:06,720 --> 00:16:09,600
root all the answers to the to the pcp

432
00:16:09,600 --> 00:16:12,720
and all the of the authentication paths

433
00:16:12,720 --> 00:16:15,199
and this three to uh verify the

434
00:16:15,199 --> 00:16:17,920
all the the pcp answers

435
00:16:17,920 --> 00:16:19,040
okay

436
00:16:19,040 --> 00:16:21,600
and the question is what is the size of

437
00:16:21,600 --> 00:16:24,480
the proof okay how large are it's not in

438
00:16:24,480 --> 00:16:26,959
the in the random local model

439
00:16:26,959 --> 00:16:27,839
okay

440
00:16:27,839 --> 00:16:29,279
so

441
00:16:29,279 --> 00:16:31,440
just uh uh

442
00:16:31,440 --> 00:16:34,320
a one slide for the whole talk mikali's

443
00:16:34,320 --> 00:16:37,279
construction has quadratic argument size

444
00:16:37,279 --> 00:16:39,279
and we give us sub quadratic argument

445
00:16:39,279 --> 00:16:41,360
size okay so we give a new construction

446
00:16:41,360 --> 00:16:43,680
that is quadratic and really the first

447
00:16:43,680 --> 00:16:46,560
improvement in terms of argument size

448
00:16:46,560 --> 00:16:49,040
for michael in the past 25 years

449
00:16:49,040 --> 00:16:51,759
so just briefly what do i mean by

450
00:16:51,759 --> 00:16:53,600
quadratic size

451
00:16:53,600 --> 00:16:55,519
so if you take if you use mikali with

452
00:16:55,519 --> 00:16:57,759
the pcp and it has length l and over

453
00:16:57,759 --> 00:17:00,240
some alphabet and query complexity

454
00:17:00,240 --> 00:17:02,639
then this is the size so this is the

455
00:17:02,639 --> 00:17:05,280
number of queries of the pcp and this is

456
00:17:05,280 --> 00:17:07,039
the symbols you need to write this is

457
00:17:07,039 --> 00:17:09,679
usually quite small the the large part

458
00:17:09,679 --> 00:17:11,280
is this which is the cryptographic

459
00:17:11,280 --> 00:17:14,959
commitment so for every query of the pcp

460
00:17:14,959 --> 00:17:17,599
you have to give a path of length log l

461
00:17:17,599 --> 00:17:19,520
okay this is the depth of the tree and

462
00:17:19,520 --> 00:17:21,520
every node in this three is lambda bits

463
00:17:21,520 --> 00:17:25,359
this is the output of the random marker

464
00:17:25,599 --> 00:17:27,280
and so

465
00:17:27,280 --> 00:17:28,960
i i want to claim that if you want to

466
00:17:28,960 --> 00:17:31,120
get t epsilon security

467
00:17:31,120 --> 00:17:32,799
uh the

468
00:17:32,799 --> 00:17:35,520
random oracle must be set to log t over

469
00:17:35,520 --> 00:17:36,799
epsilon

470
00:17:36,799 --> 00:17:39,440
and the pcb must have queries roughly

471
00:17:39,440 --> 00:17:40,480
log t

472
00:17:40,480 --> 00:17:42,080
over epsilon i'm not going to prove this

473
00:17:42,080 --> 00:17:44,559
claim but you can actually prove it

474
00:17:44,559 --> 00:17:47,440
and the corollary is that this size is

475
00:17:47,440 --> 00:17:50,559
going to be log t over epsilon squared

476
00:17:50,559 --> 00:17:52,240
okay because this is log t over option

477
00:17:52,240 --> 00:17:53,760
and this is log t of option and i'm

478
00:17:53,760 --> 00:17:57,840
ignoring like smaller volume terms

479
00:17:58,240 --> 00:18:01,520
and um so mikhail is a construction

480
00:18:01,520 --> 00:18:03,440
gives you this size you can show a

481
00:18:03,440 --> 00:18:06,000
trivial low bound of log t over epsilon

482
00:18:06,000 --> 00:18:08,400
okay like this is you have to have and

483
00:18:08,400 --> 00:18:10,160
in between currently we don't really

484
00:18:10,160 --> 00:18:11,679
know

485
00:18:11,679 --> 00:18:14,000
uh so what is our result a result that

486
00:18:14,000 --> 00:18:16,480
there exists now in the random oracle

487
00:18:16,480 --> 00:18:19,919
model that achieves size log t over

488
00:18:19,919 --> 00:18:22,080
epsilon times log t

489
00:18:22,080 --> 00:18:24,000
okay so this is really slightly sub

490
00:18:24,000 --> 00:18:25,760
quadratic

491
00:18:25,760 --> 00:18:29,280
and just one word about the approach

492
00:18:29,280 --> 00:18:31,679
we take some stronger information

493
00:18:31,679 --> 00:18:34,480
theoretic proof okay so we get some pcp

494
00:18:34,480 --> 00:18:37,840
but with the stronger soundness notion

495
00:18:37,840 --> 00:18:39,520
we combine this with a weak

496
00:18:39,520 --> 00:18:41,919
cryptographic commitment okay so a much

497
00:18:41,919 --> 00:18:44,400
relaxed notion of our commitment and

498
00:18:44,400 --> 00:18:46,240
this is how we get our subconscious

499
00:18:46,240 --> 00:18:47,679
knots

500
00:18:47,679 --> 00:18:50,640
uh so just going back to this picture

501
00:18:50,640 --> 00:18:51,919
uh

502
00:18:51,919 --> 00:18:53,280
a walk

503
00:18:53,280 --> 00:18:55,679
puts a snug here okay so

504
00:18:55,679 --> 00:18:58,400
you should view this as very close uh

505
00:18:58,400 --> 00:19:01,760
to mikali uh but still there's a big gap

506
00:19:01,760 --> 00:19:03,360
here that

507
00:19:03,360 --> 00:19:05,039
that we don't know

508
00:19:05,039 --> 00:19:06,240
um

509
00:19:06,240 --> 00:19:08,840
except of this a theoretical

510
00:19:08,840 --> 00:19:11,679
contribution if you implement and we

511
00:19:11,679 --> 00:19:13,360
implemented this construction you

512
00:19:13,360 --> 00:19:15,840
actually get good concrete efficiency as

513
00:19:15,840 --> 00:19:18,240
well so we just compared this with the

514
00:19:18,240 --> 00:19:21,760
same like pcp with mikalis and depending

515
00:19:21,760 --> 00:19:23,520
on t and epsilon you can look at the

516
00:19:23,520 --> 00:19:26,480
stabilator and the full talk for some

517
00:19:26,480 --> 00:19:28,480
values you get like improvement up to

518
00:19:28,480 --> 00:19:31,840
even a factor of two

519
00:19:32,320 --> 00:19:33,840
um

520
00:19:33,840 --> 00:19:35,840
okay i think i'm slightly out of the

521
00:19:35,840 --> 00:19:38,960
time so maybe escape my the construction

522
00:19:38,960 --> 00:19:40,640
and really the conclusion that we showed

523
00:19:40,640 --> 00:19:42,640
the snog of sides object over absolute

524
00:19:42,640 --> 00:19:44,000
times of t

525
00:19:44,000 --> 00:19:46,320
er there is a lower bound of lobster

526
00:19:46,320 --> 00:19:48,880
epsilon and a huge open problem

527
00:19:48,880 --> 00:19:52,000
is the question uh are there snugs in

528
00:19:52,000 --> 00:19:54,640
the random oracle model okay of size

529
00:19:54,640 --> 00:19:56,799
logs of epsilon

530
00:19:56,799 --> 00:19:58,160
thanks

531
00:19:58,160 --> 00:20:00,799
great thanks elon for the talk

532
00:20:00,799 --> 00:20:04,000
so moving on now to our next talk in the

533
00:20:04,000 --> 00:20:06,080
session we'll be on tight state

534
00:20:06,080 --> 00:20:08,240
restoration soundness in the algebraic

535
00:20:08,240 --> 00:20:11,280
group model by ashi rujit gosal and

536
00:20:11,280 --> 00:20:14,080
stefano tessaro and ashrujit will give

537
00:20:14,080 --> 00:20:16,480
the talk

538
00:20:17,360 --> 00:20:18,960
thanks for the introduction

539
00:20:18,960 --> 00:20:21,679
this is joint work with stefano tessaro

540
00:20:21,679 --> 00:20:23,760
very broadly this work develops a

541
00:20:23,760 --> 00:20:25,679
framework that provides security proofs

542
00:20:25,679 --> 00:20:28,159
for some proof systems used in practice

543
00:20:28,159 --> 00:20:30,000
which did not have meaningful security

544
00:20:30,000 --> 00:20:32,799
guarantee so far

545
00:20:32,799 --> 00:20:35,039
over the last few years we have seen

546
00:20:35,039 --> 00:20:36,960
zero knowledge proofs being implemented

547
00:20:36,960 --> 00:20:38,720
in real world systems

548
00:20:38,720 --> 00:20:41,760
however uh often the security guarantees

549
00:20:41,760 --> 00:20:44,159
about these proof systems are very weak

550
00:20:44,159 --> 00:20:46,159
or non-existent

551
00:20:46,159 --> 00:20:48,159
this might sound surprising to you given

552
00:20:48,159 --> 00:20:50,080
that most of these proof systems have

553
00:20:50,080 --> 00:20:52,320
existing security analysis

554
00:20:52,320 --> 00:20:54,960
uh the underlying reason for this issue

555
00:20:54,960 --> 00:20:57,280
is the use of the fiat semi transform

556
00:20:57,280 --> 00:20:59,200
before i explain you why that is the

557
00:20:59,200 --> 00:21:01,039
case let me briefly recall what prtrami

558
00:21:01,039 --> 00:21:02,880
tremendous

559
00:21:02,880 --> 00:21:04,960
it starts with the public coin

560
00:21:04,960 --> 00:21:07,039
interactive proof or argument

561
00:21:07,039 --> 00:21:09,679
and then uses a hash function to

562
00:21:09,679 --> 00:21:11,840
transform the interactive protocol into

563
00:21:11,840 --> 00:21:14,000
a non-interactive argument

564
00:21:14,000 --> 00:21:16,400
the idea is that the hash function plays

565
00:21:16,400 --> 00:21:18,240
the role of the verifier in computing

566
00:21:18,240 --> 00:21:20,080
the next challenge from the transcript

567
00:21:20,080 --> 00:21:21,919
so far

568
00:21:21,919 --> 00:21:23,760
many recently proposed non-interactive

569
00:21:23,760 --> 00:21:25,360
succinct argument systems have been

570
00:21:25,360 --> 00:21:27,600
designed using fear chemic and the

571
00:21:27,600 --> 00:21:30,559
soundness of these protocols is proved

572
00:21:30,559 --> 00:21:32,400
only in the interactive setting

573
00:21:32,400 --> 00:21:35,440
uh with the hope that if the interactive

574
00:21:35,440 --> 00:21:37,360
protocol is sound and the hash function

575
00:21:37,360 --> 00:21:39,120
is a random oracle then the

576
00:21:39,120 --> 00:21:40,799
non-interactive protocol is sound as

577
00:21:40,799 --> 00:21:42,159
well

578
00:21:42,159 --> 00:21:44,480
but unfortunately the situation is more

579
00:21:44,480 --> 00:21:46,799
complicated

580
00:21:46,799 --> 00:21:49,520
the problem is degradation of soundness

581
00:21:49,520 --> 00:21:52,400
resulting from the fear chemic transform

582
00:21:52,400 --> 00:21:54,320
let us assume that the interactive

583
00:21:54,320 --> 00:21:56,559
protocol has soundness error epsilon for

584
00:21:56,559 --> 00:21:58,720
a cheating prover running in

585
00:21:58,720 --> 00:22:00,960
time t meaning that any such cheating

586
00:22:00,960 --> 00:22:02,640
prover can full of verifier with

587
00:22:02,640 --> 00:22:04,720
probability at most epsilon

588
00:22:04,720 --> 00:22:06,720
then if the interactive protocol has r

589
00:22:06,720 --> 00:22:08,720
rounds and the hash function is a random

590
00:22:08,720 --> 00:22:09,760
oracle

591
00:22:09,760 --> 00:22:12,159
the best guarantee that we can prove

592
00:22:12,159 --> 00:22:14,559
generically for the non-interactive

593
00:22:14,559 --> 00:22:16,880
argument is that its soundness error is

594
00:22:16,880 --> 00:22:20,400
at most t power r plus 1 times epsilon

595
00:22:20,400 --> 00:22:23,039
this is a terrible degradation as the

596
00:22:23,039 --> 00:22:26,240
two examples next will illustrate

597
00:22:26,240 --> 00:22:28,880
our first example involves bullet proofs

598
00:22:28,880 --> 00:22:31,200
which has more than constant number of

599
00:22:31,200 --> 00:22:33,760
rounds meaning that t power r plus 1 is

600
00:22:33,760 --> 00:22:36,320
huge and we get no meaningful security

601
00:22:36,320 --> 00:22:37,679
guarantee

602
00:22:37,679 --> 00:22:39,840
even for constant round protocols with

603
00:22:39,840 --> 00:22:41,679
four rounds or more the security

604
00:22:41,679 --> 00:22:44,480
guarantees we get are weak

605
00:22:44,480 --> 00:22:46,720
are the proofs being overly pessimistic

606
00:22:46,720 --> 00:22:49,520
because from these systems we expect

607
00:22:49,520 --> 00:22:52,159
much better security

608
00:22:52,159 --> 00:22:54,720
so there's a significant gap between

609
00:22:54,720 --> 00:22:56,799
security expectations and what

610
00:22:56,799 --> 00:22:58,799
guarantees we can prove and this is a

611
00:22:58,799 --> 00:23:00,159
little alarming

612
00:23:00,159 --> 00:23:01,919
because some of these systems are being

613
00:23:01,919 --> 00:23:04,159
used in the real world

614
00:23:04,159 --> 00:23:06,400
the goal of our work is to exactly

615
00:23:06,400 --> 00:23:09,520
narrow this gap and we do this by giving

616
00:23:09,520 --> 00:23:12,159
a general framework to analyze security

617
00:23:12,159 --> 00:23:14,720
in the algebraic group model for group

618
00:23:14,720 --> 00:23:17,039
based protocols that use the fear chemic

619
00:23:17,039 --> 00:23:18,559
transform

620
00:23:18,559 --> 00:23:19,840
our framework

621
00:23:19,840 --> 00:23:21,679
captures protocols instantiated in

622
00:23:21,679 --> 00:23:24,960
groups with or without pairings

623
00:23:24,960 --> 00:23:27,520
we apply our framework to obtain tight

624
00:23:27,520 --> 00:23:29,679
security bounds for the non-interactive

625
00:23:29,679 --> 00:23:32,400
version of bullet proofs and sonic

626
00:23:32,400 --> 00:23:34,400
in fact for bullet proofs this is the

627
00:23:34,400 --> 00:23:36,480
first non-trivial soundness guarantee

628
00:23:36,480 --> 00:23:38,799
for the non interactive argument ever

629
00:23:38,799 --> 00:23:40,720
proved in any model

630
00:23:40,720 --> 00:23:42,640
uh in concurrent work boons at all

631
00:23:42,640 --> 00:23:44,880
analyze the non-interactive version of

632
00:23:44,880 --> 00:23:46,559
the main component of bullet proofs in

633
00:23:46,559 --> 00:23:49,200
the agm however uh the bounds that they

634
00:23:49,200 --> 00:23:51,200
obtain are not tight

635
00:23:51,200 --> 00:23:54,080
uh we also expect our framework to be

636
00:23:54,080 --> 00:23:56,240
more widely applicable to a number of

637
00:23:56,240 --> 00:23:58,320
other proof systems uh and leave that

638
00:23:58,320 --> 00:24:00,080
for future work

639
00:24:00,080 --> 00:24:01,120
also

640
00:24:01,120 --> 00:24:04,080
note that there are prior works that use

641
00:24:04,080 --> 00:24:06,159
the generic group model or the algebraic

642
00:24:06,159 --> 00:24:08,159
group model to analyze soundness of

643
00:24:08,159 --> 00:24:10,000
non-interactive protocols

644
00:24:10,000 --> 00:24:12,400
but these protocols did not involve the

645
00:24:12,400 --> 00:24:14,000
fear semi transform

646
00:24:14,000 --> 00:24:15,919
hence their analysis

647
00:24:15,919 --> 00:24:18,480
did not encounter the challenges that we

648
00:24:18,480 --> 00:24:20,080
do

649
00:24:20,080 --> 00:24:22,480
ah the key ingredient of our approach is

650
00:24:22,480 --> 00:24:24,720
analyzing a stronger notion of soundness

651
00:24:24,720 --> 00:24:26,400
for the interactive protocol called the

652
00:24:26,400 --> 00:24:28,480
state restoration soundness

653
00:24:28,480 --> 00:24:30,640
ah the state restriction soundness error

654
00:24:30,640 --> 00:24:32,880
of an interactive protocol is roughly an

655
00:24:32,880 --> 00:24:35,279
upper bound on the soundness error of

656
00:24:35,279 --> 00:24:37,440
the non-interactive protocol resulting

657
00:24:37,440 --> 00:24:40,320
from the fiat xiaomi transform

658
00:24:40,320 --> 00:24:41,919
let me define what state restriction

659
00:24:41,919 --> 00:24:43,919
soundness is very briefly

660
00:24:43,919 --> 00:24:45,600
this gives the cheating prover the

661
00:24:45,600 --> 00:24:47,679
additional power to restore the verifier

662
00:24:47,679 --> 00:24:49,679
to any of its previous states and resume

663
00:24:49,679 --> 00:24:51,840
execution from there here is an example

664
00:24:51,840 --> 00:24:53,520
to illustrate this

665
00:24:53,520 --> 00:24:55,039
the cheating prover interacts with the

666
00:24:55,039 --> 00:24:58,080
verifier and it restores it whenever it

667
00:24:58,080 --> 00:24:59,919
gets rejected or it gets a challenge

668
00:24:59,919 --> 00:25:01,760
that it does not like

669
00:25:01,760 --> 00:25:03,919
the cheating proverbs if there is an

670
00:25:03,919 --> 00:25:06,960
accepting path in the execution tree

671
00:25:06,960 --> 00:25:08,400
we define the state research and

672
00:25:08,400 --> 00:25:10,480
soundness error as the probability that

673
00:25:10,480 --> 00:25:12,799
the cheating proverbs

674
00:25:12,799 --> 00:25:14,960
for the particular case of arguments we

675
00:25:14,960 --> 00:25:17,120
do not know of any for which we can

676
00:25:17,120 --> 00:25:18,960
prove non-trivial bounds for state

677
00:25:18,960 --> 00:25:21,600
restriction sounds

678
00:25:21,600 --> 00:25:23,520
uh in this paper we analyze state

679
00:25:23,520 --> 00:25:25,360
resolution soundness of group based

680
00:25:25,360 --> 00:25:27,440
arguments in the algebraic group model

681
00:25:27,440 --> 00:25:29,679
that is we consider soundness only

682
00:25:29,679 --> 00:25:30,640
against

683
00:25:30,640 --> 00:25:33,200
algebraic adversaries that provide a

684
00:25:33,200 --> 00:25:35,440
representation of every group element

685
00:25:35,440 --> 00:25:37,360
they output in terms of the group

686
00:25:37,360 --> 00:25:40,960
element they received as input so far

687
00:25:40,960 --> 00:25:43,919
our main contribution is developing a

688
00:25:43,919 --> 00:25:46,080
general framework to analyze state

689
00:25:46,080 --> 00:25:48,159
resource and soundness for group based

690
00:25:48,159 --> 00:25:50,720
protocols in the algebraic group model i

691
00:25:50,720 --> 00:25:52,159
refer you to the full version of the

692
00:25:52,159 --> 00:25:55,520
talk for details about our framework

693
00:25:55,520 --> 00:25:58,320
uh we apply our framework to prove upper

694
00:25:58,320 --> 00:26:00,080
bounds on state restriction soundness

695
00:26:00,080 --> 00:26:01,440
for the two instantiations of

696
00:26:01,440 --> 00:26:03,679
bulletproofs and sonic

697
00:26:03,679 --> 00:26:05,919
we additionally give matching attacks to

698
00:26:05,919 --> 00:26:09,679
show that the bound we obtain or tight

699
00:26:09,679 --> 00:26:11,919
the main takeaway message from our work

700
00:26:11,919 --> 00:26:14,320
is that it is essential to analyze the

701
00:26:14,320 --> 00:26:16,320
state restriction soundness of

702
00:26:16,320 --> 00:26:18,640
interactive protocols when using the uh

703
00:26:18,640 --> 00:26:20,559
purchase transform

704
00:26:20,559 --> 00:26:24,159
uh a couple of related open problems are

705
00:26:24,159 --> 00:26:26,000
proving state pressure and soundness for

706
00:26:26,000 --> 00:26:28,480
more protocols specifically those which

707
00:26:28,480 --> 00:26:30,480
are not based on groups

708
00:26:30,480 --> 00:26:33,600
and uh proving uh a non-trivial bound

709
00:26:33,600 --> 00:26:35,679
for straight rational soundness for any

710
00:26:35,679 --> 00:26:38,480
argument in the standard model uh the

711
00:26:38,480 --> 00:26:39,919
full version of our paper is a neat

712
00:26:39,919 --> 00:26:42,960
print uh thank you

713
00:26:42,960 --> 00:26:45,840
great excellent thanks for the talk

714
00:26:45,840 --> 00:26:49,039
so our next talk in this session will be

715
00:26:49,039 --> 00:26:50,960
on some check arguments and their

716
00:26:50,960 --> 00:26:53,600
applications by jonathan pudo alessandro

717
00:26:53,600 --> 00:26:57,120
queza and katarina sotaraki and i think

718
00:26:57,120 --> 00:27:00,320
jonathan will give the talk

719
00:27:00,880 --> 00:27:02,880
yeah that's right thanks david

720
00:27:02,880 --> 00:27:04,960
um so our work is called some check

721
00:27:04,960 --> 00:27:08,000
arguments and their applications

722
00:27:08,000 --> 00:27:09,600
it's based on the subject protocol from

723
00:27:09,600 --> 00:27:12,640
1992 and in the subject protocol we have

724
00:27:12,640 --> 00:27:14,960
approver and a verifier and the approval

725
00:27:14,960 --> 00:27:16,799
wants to convince the verifier that

726
00:27:16,799 --> 00:27:19,039
evaluations of a polynomial over some

727
00:27:19,039 --> 00:27:20,960
finite field sum up to a particular

728
00:27:20,960 --> 00:27:22,000
value

729
00:27:22,000 --> 00:27:23,360
so what happens in this protocol is the

730
00:27:23,360 --> 00:27:25,120
prover sends a few smaller polynomials

731
00:27:25,120 --> 00:27:27,120
to the verifier who responds with random

732
00:27:27,120 --> 00:27:28,399
challenges

733
00:27:28,399 --> 00:27:31,039
and then after performing various checks

734
00:27:31,039 --> 00:27:33,039
the task of checking all these multiple

735
00:27:33,039 --> 00:27:35,600
polynomial evaluations is reduced to the

736
00:27:35,600 --> 00:27:37,600
task of checking one single polynomial

737
00:27:37,600 --> 00:27:41,439
evaluation at a random point

738
00:27:41,679 --> 00:27:43,039
so the reason why people like the

739
00:27:43,039 --> 00:27:44,799
subject protocol well one of the reasons

740
00:27:44,799 --> 00:27:47,600
is that it's used inside a lot of very

741
00:27:47,600 --> 00:27:49,919
efficient succinct arguments for mp

742
00:27:49,919 --> 00:27:52,000
statements um which come about when the

743
00:27:52,000 --> 00:27:53,679
subject protocol is combined with an

744
00:27:53,679 --> 00:27:55,600
appropriate cryptographic commitment

745
00:27:55,600 --> 00:27:57,360
scheme

746
00:27:57,360 --> 00:27:59,279
now the subject protocol is not the only

747
00:27:59,279 --> 00:28:01,919
way to construct succinct arguments

748
00:28:01,919 --> 00:28:03,840
there are also techniques based on let's

749
00:28:03,840 --> 00:28:05,279
say folding techniques like the

750
00:28:05,279 --> 00:28:07,279
bulletproofs protocol for example

751
00:28:07,279 --> 00:28:09,120
but until now

752
00:28:09,120 --> 00:28:10,559
it seemed like these two approaches were

753
00:28:10,559 --> 00:28:11,840
unrelated

754
00:28:11,840 --> 00:28:13,679
so one of the main contributions of our

755
00:28:13,679 --> 00:28:16,080
work is to come up with a generalization

756
00:28:16,080 --> 00:28:17,440
or a slight variance of the subject

757
00:28:17,440 --> 00:28:18,480
protocol

758
00:28:18,480 --> 00:28:20,799
which captures these folding techniques

759
00:28:20,799 --> 00:28:22,159
um based on lots of different

760
00:28:22,159 --> 00:28:24,320
cryptographic assumptions

761
00:28:24,320 --> 00:28:26,159
and actually shows the two lines of

762
00:28:26,159 --> 00:28:28,960
works are closely connected via the sum

763
00:28:28,960 --> 00:28:30,880
check protocol so we can get some check

764
00:28:30,880 --> 00:28:32,000
arguments based on the discrete

765
00:28:32,000 --> 00:28:33,600
logarithm assumption based on pairing

766
00:28:33,600 --> 00:28:35,440
based assumptions groups of unknown

767
00:28:35,440 --> 00:28:37,760
order and even lattice based assumptions

768
00:28:37,760 --> 00:28:40,559
like ringsis

769
00:28:41,279 --> 00:28:43,440
so the goal of a sum check argument is

770
00:28:43,440 --> 00:28:46,320
to prove that you know an opening for a

771
00:28:46,320 --> 00:28:48,080
cryptographic commitment

772
00:28:48,080 --> 00:28:49,679
and to capture what our subject

773
00:28:49,679 --> 00:28:51,679
arguments can do we introduce a new

774
00:28:51,679 --> 00:28:53,200
notion of some check friendly

775
00:28:53,200 --> 00:28:54,880
commitments

776
00:28:54,880 --> 00:28:56,720
a commitment scheme subject friendly if

777
00:28:56,720 --> 00:28:58,640
any commitment can be expressed as a sum

778
00:28:58,640 --> 00:29:01,440
of polynomial evaluations as follows

779
00:29:01,440 --> 00:29:02,960
so the evaluation points from the

780
00:29:02,960 --> 00:29:06,159
polynomial come from a ring r

781
00:29:06,159 --> 00:29:09,520
all commitments come from an r module

782
00:29:09,520 --> 00:29:11,520
messages are encoded using a message

783
00:29:11,520 --> 00:29:13,200
polynomial which is from another r

784
00:29:13,200 --> 00:29:14,399
module

785
00:29:14,399 --> 00:29:16,320
and the commitment key is encoded using

786
00:29:16,320 --> 00:29:19,600
a key polynomial from another r module

787
00:29:19,600 --> 00:29:21,360
now the simplest example of a

788
00:29:21,360 --> 00:29:23,039
subject-friendly commitment

789
00:29:23,039 --> 00:29:24,640
um maybe the simplest interesting

790
00:29:24,640 --> 00:29:25,600
example

791
00:29:25,600 --> 00:29:28,799
oh sorry before that we we also have a

792
00:29:28,799 --> 00:29:31,120
combiner function which maps

793
00:29:31,120 --> 00:29:32,000
um

794
00:29:32,000 --> 00:29:34,240
message evaluations and key evaluations

795
00:29:34,240 --> 00:29:36,799
to the commitment space

796
00:29:36,799 --> 00:29:38,880
now the simplest example of a

797
00:29:38,880 --> 00:29:40,399
subject-friendly commitment is a

798
00:29:40,399 --> 00:29:42,880
pedestal commitment and so to get a

799
00:29:42,880 --> 00:29:44,000
pesticide commitment as a

800
00:29:44,000 --> 00:29:45,760
subject-friendly commitment

801
00:29:45,760 --> 00:29:47,679
we set the ring to be a finite field of

802
00:29:47,679 --> 00:29:48,960
prime order

803
00:29:48,960 --> 00:29:51,279
the message module is the same field and

804
00:29:51,279 --> 00:29:53,520
the message polynomial is multi-linear

805
00:29:53,520 --> 00:29:55,279
with each message element appearing as

806
00:29:55,279 --> 00:29:57,520
one of the coefficients

807
00:29:57,520 --> 00:30:00,399
the key space is the group which the

808
00:30:00,399 --> 00:30:02,559
commitment key elements come from and we

809
00:30:02,559 --> 00:30:04,320
have another multi-linear polynomial

810
00:30:04,320 --> 00:30:05,600
with each element of the pedestal

811
00:30:05,600 --> 00:30:06,840
commitment key coming up as a

812
00:30:06,840 --> 00:30:09,039
coefficient and lastly the combiner

813
00:30:09,039 --> 00:30:10,080
function is just skill and

814
00:30:10,080 --> 00:30:12,080
multiplication between the finite field

815
00:30:12,080 --> 00:30:14,080
and the group

816
00:30:14,080 --> 00:30:15,840
so the next question is how do you give

817
00:30:15,840 --> 00:30:17,440
a succinct argument of knowledge that

818
00:30:17,440 --> 00:30:18,480
you know an opening to a

819
00:30:18,480 --> 00:30:22,000
subject-friendly commitment

820
00:30:22,000 --> 00:30:23,440
the common input here for the prover and

821
00:30:23,440 --> 00:30:25,520
the verifier is cryptographic commitment

822
00:30:25,520 --> 00:30:27,360
and a commitment key and the prover

823
00:30:27,360 --> 00:30:28,720
claims that there are a message which

824
00:30:28,720 --> 00:30:31,760
satisfies this subject-friendly relation

825
00:30:31,760 --> 00:30:33,200
the protocol is just the sum check

826
00:30:33,200 --> 00:30:35,200
protocol run on the polynomial from the

827
00:30:35,200 --> 00:30:36,960
previous slide

828
00:30:36,960 --> 00:30:39,279
um the only differences are the

829
00:30:39,279 --> 00:30:41,120
protocols run over rings and modules

830
00:30:41,120 --> 00:30:42,720
instead of finite fields

831
00:30:42,720 --> 00:30:44,559
and at the end of the protocol to

832
00:30:44,559 --> 00:30:46,880
perform the random evaluation

833
00:30:46,880 --> 00:30:48,880
well since half of the polynomial

834
00:30:48,880 --> 00:30:50,559
depends on the message which is secret

835
00:30:50,559 --> 00:30:52,080
from the verifier and not only to the

836
00:30:52,080 --> 00:30:54,320
approver the prover sends an evaluation

837
00:30:54,320 --> 00:30:56,240
of the message part of the polynomial to

838
00:30:56,240 --> 00:30:58,399
the verifier to let the verify perform

839
00:30:58,399 --> 00:31:00,559
the final check

840
00:31:00,559 --> 00:31:02,240
now surprisingly with the instantiation

841
00:31:02,240 --> 00:31:04,000
on the previous slide this is more or

842
00:31:04,000 --> 00:31:06,080
less equivalent to the first examples of

843
00:31:06,080 --> 00:31:07,600
folding techniques which gave rise to

844
00:31:07,600 --> 00:31:08,960
bulletproofs and you can see the paper

845
00:31:08,960 --> 00:31:10,880
for more details

846
00:31:10,880 --> 00:31:13,039
and finally to capture lattice-based

847
00:31:13,039 --> 00:31:14,799
assumptions or other assumptions where

848
00:31:14,799 --> 00:31:16,320
the norms of messages matter and you're

849
00:31:16,320 --> 00:31:17,600
only allowed small messages and

850
00:31:17,600 --> 00:31:19,360
commitments we have to add some extra

851
00:31:19,360 --> 00:31:23,039
norm checks to this basic protocol

852
00:31:23,039 --> 00:31:24,480
here's a summary of the results that we

853
00:31:24,480 --> 00:31:25,519
prove

854
00:31:25,519 --> 00:31:26,960
our main result is to show that the

855
00:31:26,960 --> 00:31:28,559
subject protocol applied to any

856
00:31:28,559 --> 00:31:31,039
subject-friendly commitment gives you a

857
00:31:31,039 --> 00:31:32,640
succinct argument of knowledge for

858
00:31:32,640 --> 00:31:35,519
opening the commitment

859
00:31:35,519 --> 00:31:38,159
so using this as a subroutine we're

860
00:31:38,159 --> 00:31:40,880
actually able to give very general

861
00:31:40,880 --> 00:31:43,120
succinct arguments for mp statements

862
00:31:43,120 --> 00:31:44,640
over a variety of different rings and

863
00:31:44,640 --> 00:31:45,919
modules to capture those different

864
00:31:45,919 --> 00:31:47,919
cryptographic assumptions

865
00:31:47,919 --> 00:31:50,559
and when we specialize to the case of

866
00:31:50,559 --> 00:31:53,519
lattice assumptions we give succinct

867
00:31:53,519 --> 00:31:54,880
zero knowledge arguments of knowledge

868
00:31:54,880 --> 00:31:56,480
for mp statements with logarithmic

869
00:31:56,480 --> 00:31:57,880
communication based on the cis

870
00:31:57,880 --> 00:32:00,960
assumption um and these are the first

871
00:32:00,960 --> 00:32:02,640
ones which are known

872
00:32:02,640 --> 00:32:03,519
um

873
00:32:03,519 --> 00:32:04,799
there are actually a number of similar

874
00:32:04,799 --> 00:32:06,799
works uh crypto this year if you're

875
00:32:06,799 --> 00:32:08,480
interested specifically in later space

876
00:32:08,480 --> 00:32:10,159
assumptions

877
00:32:10,159 --> 00:32:13,440
thanks very much for your attention

878
00:32:13,519 --> 00:32:15,360
wonderful

879
00:32:15,360 --> 00:32:17,840
all right so now i'm moving on to our

880
00:32:17,840 --> 00:32:20,159
final talk of this session we have an

881
00:32:20,159 --> 00:32:22,480
algebraic framework for universal and

882
00:32:22,480 --> 00:32:25,360
updatable snarks by aransa zapiko and

883
00:32:25,360 --> 00:32:28,480
karla raffles and aransa will keep the

884
00:32:28,480 --> 00:32:29,760
talk

885
00:32:29,760 --> 00:32:31,440
thank you

886
00:32:31,440 --> 00:32:32,720
so

887
00:32:32,720 --> 00:32:34,640
when we talk about universal and updated

888
00:32:34,640 --> 00:32:36,799
snacks we are actually talking about the

889
00:32:36,799 --> 00:32:39,279
way the structure reference string or

890
00:32:39,279 --> 00:32:42,159
srs that is a piece of information both

891
00:32:42,159 --> 00:32:44,720
pro and refresher is built

892
00:32:44,720 --> 00:32:47,200
so updatability means that

893
00:32:47,200 --> 00:32:49,200
many parties collaborate in a

894
00:32:49,200 --> 00:32:50,640
non-interactive way

895
00:32:50,640 --> 00:32:53,519
and with different parts of the secret

896
00:32:53,519 --> 00:32:55,600
and in such a way that if one of these

897
00:32:55,600 --> 00:32:58,640
parties is honest the secret is safe

898
00:32:58,640 --> 00:33:00,559
then the secret is used to create a

899
00:33:00,559 --> 00:33:03,279
universalist arrest but this is a reason

900
00:33:03,279 --> 00:33:06,159
works for any relation up to some size

901
00:33:06,159 --> 00:33:08,080
and then in an untrusted step we can

902
00:33:08,080 --> 00:33:11,760
derive like srs specific for for every

903
00:33:11,760 --> 00:33:13,600
reaction

904
00:33:13,600 --> 00:33:15,440
since the work that introduced this

905
00:33:15,440 --> 00:33:18,320
model in 2018 i want to talk there has

906
00:33:18,320 --> 00:33:20,480
been a huge line of research upon on

907
00:33:20,480 --> 00:33:22,640
this kind of snarks and the nice thing

908
00:33:22,640 --> 00:33:25,200
is that all these constructions follow a

909
00:33:25,200 --> 00:33:27,919
common design principle that consists on

910
00:33:27,919 --> 00:33:30,399
breaking the construction of the snark

911
00:33:30,399 --> 00:33:32,960
into step first creating an information

912
00:33:32,960 --> 00:33:35,440
theoretical secure object that is an

913
00:33:35,440 --> 00:33:37,120
holographic proof and i'm going to talk

914
00:33:37,120 --> 00:33:38,480
about that in a second

915
00:33:38,480 --> 00:33:40,480
and then using a polynomial complement

916
00:33:40,480 --> 00:33:42,960
sorry and rancher it's hard to hear what

917
00:33:42,960 --> 00:33:45,440
you're saying can you turn

918
00:33:45,440 --> 00:33:47,519
change anything in it's hard to see hear

919
00:33:47,519 --> 00:33:49,360
what you're saying can you get closer to

920
00:33:49,360 --> 00:33:51,440
the microphone

921
00:33:51,440 --> 00:33:53,760
wow

922
00:33:54,240 --> 00:33:58,559
i have no idea what will be happening

923
00:33:59,600 --> 00:34:03,360
wait a second because i don't have any

924
00:34:03,360 --> 00:34:05,039
micro options

925
00:34:05,039 --> 00:34:07,919
do you hear me better now

926
00:34:07,919 --> 00:34:11,839
the volume still seems a little bit low

927
00:34:13,760 --> 00:34:15,599
if if you're using headphones you may

928
00:34:15,599 --> 00:34:17,440
want to try with your

929
00:34:17,440 --> 00:34:19,839
laptop speakers instead and not use the

930
00:34:19,839 --> 00:34:21,760
headphone speaker no that one doesn't

931
00:34:21,760 --> 00:34:23,119
work

932
00:34:23,119 --> 00:34:25,359
okay

933
00:34:25,359 --> 00:34:27,440
do you hear me better now

934
00:34:27,440 --> 00:34:30,560
yes much better much better

935
00:34:30,560 --> 00:34:32,800
i'm super sorry shall i start from the

936
00:34:32,800 --> 00:34:34,960
beginning

937
00:34:34,960 --> 00:34:37,119
all right today i think we have time so

938
00:34:37,119 --> 00:34:39,359
sure

939
00:34:40,000 --> 00:34:42,239
okay

940
00:34:42,639 --> 00:34:44,560
so when we talk about you know some

941
00:34:44,560 --> 00:34:46,480
updated snacks we are talking about the

942
00:34:46,480 --> 00:34:48,639
way the structural reference string or

943
00:34:48,639 --> 00:34:50,320
srs is filled

944
00:34:50,320 --> 00:34:51,520
this reference string is some

945
00:34:51,520 --> 00:34:53,599
information both pro and verifier are

946
00:34:53,599 --> 00:34:54,800
going to share

947
00:34:54,800 --> 00:34:56,879
and applicability means that many

948
00:34:56,879 --> 00:34:58,480
parties are going to collaborate in a

949
00:34:58,480 --> 00:35:00,720
non-iterative way in order to generate

950
00:35:00,720 --> 00:35:02,640
this secret

951
00:35:02,640 --> 00:35:03,920
and then

952
00:35:03,920 --> 00:35:05,680
as soon as one of these parties is

953
00:35:05,680 --> 00:35:07,760
honest the secret is sex the chicken

954
00:35:07,760 --> 00:35:10,480
will be used to generate a universalist

955
00:35:10,480 --> 00:35:13,200
that is a universe an srs that works for

956
00:35:13,200 --> 00:35:15,200
any relation up to some size

957
00:35:15,200 --> 00:35:17,359
and then in an unstructured step we can

958
00:35:17,359 --> 00:35:20,079
derive from this universal surface uh

959
00:35:20,079 --> 00:35:22,400
some string that is specific for for

960
00:35:22,400 --> 00:35:24,000
different relations

961
00:35:24,000 --> 00:35:26,400
so this model was introduced in 2018 by

962
00:35:26,400 --> 00:35:28,560
water tool and since then has there has

963
00:35:28,560 --> 00:35:30,640
been a huge line of research on this

964
00:35:30,640 --> 00:35:32,000
kind of snacks

965
00:35:32,000 --> 00:35:33,839
and the next thing is that all this work

966
00:35:33,839 --> 00:35:36,000
follows some common design principle

967
00:35:36,000 --> 00:35:37,520
that consists on breaking the

968
00:35:37,520 --> 00:35:39,839
construction of the snack into steps

969
00:35:39,839 --> 00:35:41,119
first create an information

970
00:35:41,119 --> 00:35:43,200
theoretically secure object that is a

971
00:35:43,200 --> 00:35:44,800
holographic proof and i'm going to talk

972
00:35:44,800 --> 00:35:46,880
about that in a second and then use

973
00:35:46,880 --> 00:35:48,720
apple in american movement to compile it

974
00:35:48,720 --> 00:35:49,920
into snap

975
00:35:49,920 --> 00:35:51,920
this is the case for

976
00:35:51,920 --> 00:35:53,920
most of the constructions at least we

977
00:35:53,920 --> 00:35:55,359
are aware of

978
00:35:55,359 --> 00:35:57,760
so another proof for polynomial

979
00:35:57,760 --> 00:35:59,760
holography proof is a proof system we

980
00:35:59,760 --> 00:36:01,839
have a prover and a verifier but we also

981
00:36:01,839 --> 00:36:03,760
have another algorithm that is in that

982
00:36:03,760 --> 00:36:05,920
cell we measure output polynomials that

983
00:36:05,920 --> 00:36:07,440
describe the relation

984
00:36:07,440 --> 00:36:09,280
and when plural verifier interrupt the

985
00:36:09,280 --> 00:36:12,000
prover send some polynomials as well the

986
00:36:12,000 --> 00:36:13,760
key is that the verifier has oracle

987
00:36:13,760 --> 00:36:15,440
access to these polynomials it doesn't

988
00:36:15,440 --> 00:36:16,480
need to read

989
00:36:16,480 --> 00:36:19,119
them and these give us the samsung

990
00:36:19,119 --> 00:36:23,599
brain-based snark i have us used to

991
00:36:23,599 --> 00:36:24,960
so our goal is to construct

992
00:36:24,960 --> 00:36:27,040
polynomialographic proofs for general

993
00:36:27,040 --> 00:36:29,839
computations uh so

994
00:36:29,839 --> 00:36:31,359
for today we are going to talk about

995
00:36:31,359 --> 00:36:33,119
sequence of displayabilities a nice way

996
00:36:33,119 --> 00:36:34,720
to represent them

997
00:36:34,720 --> 00:36:35,440
and

998
00:36:35,440 --> 00:36:37,839
specifically about a generic circuit so

999
00:36:37,839 --> 00:36:38,800
we will

1000
00:36:38,800 --> 00:36:41,200
um way a map to move from the algebraic

1001
00:36:41,200 --> 00:36:42,800
to the polynomial

1002
00:36:42,800 --> 00:36:45,280
uh it could be other maps i'm using the

1003
00:36:45,280 --> 00:36:47,520
lavender interpolation as an example and

1004
00:36:47,520 --> 00:36:49,200
it's like

1005
00:36:49,200 --> 00:36:51,040
circuits have

1006
00:36:51,040 --> 00:36:52,800
three kind of guides

1007
00:36:52,800 --> 00:36:55,119
we have the multiplicative gates and

1008
00:36:55,119 --> 00:36:56,960
that can be expressed as quadratic

1009
00:36:56,960 --> 00:36:59,280
constraints so if we call a to the left

1010
00:36:59,280 --> 00:37:01,440
inputs b to the right inputs and c to

1011
00:37:01,440 --> 00:37:03,280
the output what we want to see is that

1012
00:37:03,280 --> 00:37:05,280
they have a product between the vectors

1013
00:37:05,280 --> 00:37:07,520
that have the input values is equal to

1014
00:37:07,520 --> 00:37:08,640
the output

1015
00:37:08,640 --> 00:37:11,200
and this is quite standard so it's not

1016
00:37:11,200 --> 00:37:13,359
what we are going to focus on today but

1017
00:37:13,359 --> 00:37:16,880
then we have linear uh constraints that

1018
00:37:16,880 --> 00:37:19,599
represent both additive

1019
00:37:19,599 --> 00:37:22,000
and multiplicative by constant guides

1020
00:37:22,000 --> 00:37:24,160
what they what they express basically is

1021
00:37:24,160 --> 00:37:25,920
that every input depends on previous

1022
00:37:25,920 --> 00:37:28,480
outputs and some constants that depend

1023
00:37:28,480 --> 00:37:29,680
on zero

1024
00:37:29,680 --> 00:37:31,599
in the sequence itself

1025
00:37:31,599 --> 00:37:35,680
if we take both left and right um

1026
00:37:35,680 --> 00:37:38,480
constraints we can actually reduce

1027
00:37:38,480 --> 00:37:41,680
the linear constraints to this um

1028
00:37:41,680 --> 00:37:44,960
volume of belonging to some states

1029
00:37:44,960 --> 00:37:46,400
so we want to prove that the vector of

1030
00:37:46,400 --> 00:37:49,280
the witness is in the orthogonal space

1031
00:37:49,280 --> 00:37:51,200
to the other one generated by the rows

1032
00:37:51,200 --> 00:37:53,520
of w and a natural way of doing this

1033
00:37:53,520 --> 00:37:56,480
would be okay let's sample some vector

1034
00:37:56,480 --> 00:37:58,720
random vector in the row space of this

1035
00:37:58,720 --> 00:37:59,920
matrix

1036
00:37:59,920 --> 00:38:02,400
and then of course compute the mapping

1037
00:38:02,400 --> 00:38:04,720
of that vector as a polynomial and the

1038
00:38:04,720 --> 00:38:06,880
same with the winners and prove that

1039
00:38:06,880 --> 00:38:09,200
just one interval so instead of checking

1040
00:38:09,200 --> 00:38:11,680
on the rows against the witness we

1041
00:38:11,680 --> 00:38:14,240
batch all the all the

1042
00:38:14,240 --> 00:38:16,640
constraints abroad only one in a row

1043
00:38:16,640 --> 00:38:18,720
inner products are also quite standard

1044
00:38:18,720 --> 00:38:20,640
and what i want to focus is in these two

1045
00:38:20,640 --> 00:38:22,800
steps so because the program is the one

1046
00:38:22,800 --> 00:38:24,480
that is trying to convince the verifier

1047
00:38:24,480 --> 00:38:26,880
it cannot choose the the

1048
00:38:26,880 --> 00:38:29,599
vector itself the verifier has to give

1049
00:38:29,599 --> 00:38:31,760
the randomness of

1050
00:38:31,760 --> 00:38:33,200
of this fact

1051
00:38:33,200 --> 00:38:35,280
this is what we call a checkabout

1052
00:38:35,280 --> 00:38:36,880
substrate sampling

1053
00:38:36,880 --> 00:38:38,560
horizontal spray sampling has the same

1054
00:38:38,560 --> 00:38:40,960
structure as an alloy proof we have an

1055
00:38:40,960 --> 00:38:42,800
indexer that outputs polynomial and

1056
00:38:42,800 --> 00:38:44,880
squaring matrix the video

1057
00:38:44,880 --> 00:38:46,880
and then in an online phase pro and

1058
00:38:46,880 --> 00:38:49,359
verify intellect the verifier sends the

1059
00:38:49,359 --> 00:38:52,800
coins it wants a vector g to be sampled

1060
00:38:52,800 --> 00:38:55,680
according to and then improver will send

1061
00:38:55,680 --> 00:38:57,599
the map of course then the brewer has

1062
00:38:57,599 --> 00:38:59,520
convinced the verifier that this map has

1063
00:38:59,520 --> 00:39:00,800
been

1064
00:39:00,800 --> 00:39:02,880
computed correctly

1065
00:39:02,880 --> 00:39:05,599
and the verifier assets are regions

1066
00:39:05,599 --> 00:39:07,520
you can find actually check out space

1067
00:39:07,520 --> 00:39:10,160
sampling in in the literature

1068
00:39:10,160 --> 00:39:12,079
in sonic you have two construction it's

1069
00:39:12,079 --> 00:39:13,599
implicit

1070
00:39:13,599 --> 00:39:15,280
you have also a construction of marlin

1071
00:39:15,280 --> 00:39:18,079
and kleimer and all of them have to make

1072
00:39:18,079 --> 00:39:19,599
some assumption on the structure of this

1073
00:39:19,599 --> 00:39:21,440
magic w

1074
00:39:21,440 --> 00:39:22,720
we also have

1075
00:39:22,720 --> 00:39:25,200
a bunch of new schemes and they are not

1076
00:39:25,200 --> 00:39:27,359
the same the exception we also need to

1077
00:39:27,359 --> 00:39:29,760
make some assumptions in the structure

1078
00:39:29,760 --> 00:39:31,359
of the secret

1079
00:39:31,359 --> 00:39:34,400
and we have one roots for limited fanout

1080
00:39:34,400 --> 00:39:36,400
secrets one for series that are

1081
00:39:36,400 --> 00:39:38,720
expressed through sparse matrices and

1082
00:39:38,720 --> 00:39:41,359
then one that works for dense rocks okay

1083
00:39:41,359 --> 00:39:43,280
this could be interesting because then

1084
00:39:43,280 --> 00:39:45,520
we also prove that we can combine check

1085
00:39:45,520 --> 00:39:47,599
velocity space sampling different

1086
00:39:47,599 --> 00:39:48,640
schemes

1087
00:39:48,640 --> 00:39:51,920
to to sample vectors in in the low space

1088
00:39:51,920 --> 00:39:54,079
of only one matrix

1089
00:39:54,079 --> 00:39:55,920
finally way to use this framework that

1090
00:39:55,920 --> 00:39:58,079
consists on channel suspense sampling

1091
00:39:58,079 --> 00:40:00,480
blessing approach for linear constraints

1092
00:40:00,480 --> 00:40:02,160
glass hammer probe for quality

1093
00:40:02,160 --> 00:40:03,359
constraints

1094
00:40:03,359 --> 00:40:06,079
because as young said before modularity

1095
00:40:06,079 --> 00:40:07,920
brings clarity

1096
00:40:07,920 --> 00:40:09,839
also we capture previous construction so

1097
00:40:09,839 --> 00:40:12,000
we can move forward from here

1098
00:40:12,000 --> 00:40:14,079
and indeed second suspect sampling is

1099
00:40:14,079 --> 00:40:16,319
the bottleneck of of all the existing

1100
00:40:16,319 --> 00:40:18,960
construction so we know where to to

1101
00:40:18,960 --> 00:40:21,280
focus in order to improve

1102
00:40:21,280 --> 00:40:23,520
and also because the framework brings

1103
00:40:23,520 --> 00:40:25,760
this flexibility of being able to mix

1104
00:40:25,760 --> 00:40:28,400
and unmatch according to a structure of

1105
00:40:28,400 --> 00:40:30,480
matrix w

1106
00:40:30,480 --> 00:40:33,280
that's all thank you

1107
00:40:33,440 --> 00:40:36,160
wonderful so thanks a lot for the talk

1108
00:40:36,160 --> 00:40:38,560
so that concludes the talks for the

1109
00:40:38,560 --> 00:40:40,480
session so now we have about 20 or so

1110
00:40:40,480 --> 00:40:43,280
minutes uh for q a so if you have a

1111
00:40:43,280 --> 00:40:45,599
question uh you can either type it in a

1112
00:40:45,599 --> 00:40:47,119
chat you can feel free to ask it

1113
00:40:47,119 --> 00:40:49,520
directly over zoom via say the raised

1114
00:40:49,520 --> 00:40:50,640
hand feature

1115
00:40:50,640 --> 00:40:53,440
or you can also type it into uh zulip as

1116
00:40:53,440 --> 00:40:54,640
well

1117
00:40:54,640 --> 00:40:56,720
so we already have a couple questions in

1118
00:40:56,720 --> 00:40:58,960
zulip so let me start by reading those

1119
00:40:58,960 --> 00:41:00,560
and while i'm reading these if you have

1120
00:41:00,560 --> 00:41:03,040
further questions please feel free

1121
00:41:03,040 --> 00:41:04,319
to ask

1122
00:41:04,319 --> 00:41:05,040
so

1123
00:41:05,040 --> 00:41:08,960
uh pratyush asks a question to elon so

1124
00:41:08,960 --> 00:41:11,200
do your techniques extend to knowledge

1125
00:41:11,200 --> 00:41:13,680
soundness as well or does that not work

1126
00:41:13,680 --> 00:41:16,319
because the bces extractor requires

1127
00:41:16,319 --> 00:41:18,319
recording random oracle queries during

1128
00:41:18,319 --> 00:41:21,839
numerical tree construction

1129
00:41:23,040 --> 00:41:24,960
yeah that's a good question so in the

1130
00:41:24,960 --> 00:41:27,359
paper we proved only

1131
00:41:27,359 --> 00:41:31,040
a soundness and we also did all of

1132
00:41:31,040 --> 00:41:33,040
so our construction is taking mikali and

1133
00:41:33,040 --> 00:41:35,040
doing like four tweaks

1134
00:41:35,040 --> 00:41:38,480
and you could do the same for bcs

1135
00:41:38,480 --> 00:41:40,480
in the same matrix the the proof is

1136
00:41:40,480 --> 00:41:42,400
slightly more complicated

1137
00:41:42,400 --> 00:41:44,000
um

1138
00:41:44,000 --> 00:41:46,480
i'm i'm quite sure it would work for

1139
00:41:46,480 --> 00:41:49,839
proof of knowledge but that

1140
00:41:50,319 --> 00:41:52,640
we didn't do that so

1141
00:41:52,640 --> 00:41:55,200
so i'm not gonna commit

1142
00:41:55,200 --> 00:41:59,598
not even with a weak commitment scheme

1143
00:42:00,839 --> 00:42:03,680
great so it's just as a brief follow-up

1144
00:42:03,680 --> 00:42:05,599
connect so does do your techniques also

1145
00:42:05,599 --> 00:42:08,400
extend to iops also following the bcs

1146
00:42:08,400 --> 00:42:09,839
line of work

1147
00:42:09,839 --> 00:42:11,920
yeah yeah so again we did it for mikali

1148
00:42:11,920 --> 00:42:13,280
because it's

1149
00:42:13,280 --> 00:42:15,839
the analysis even for mikali is like

1150
00:42:15,839 --> 00:42:18,400
it's very technical and complicated and

1151
00:42:18,400 --> 00:42:21,200
so doing it for like iops would mean

1152
00:42:21,200 --> 00:42:22,960
like having everything

1153
00:42:22,960 --> 00:42:24,640
to be interactive and

1154
00:42:24,640 --> 00:42:27,520
it is more complicated but

1155
00:42:27,520 --> 00:42:30,800
i i like i don't see any technical

1156
00:42:30,800 --> 00:42:32,800
problems except that it's just

1157
00:42:32,800 --> 00:42:34,720
more involved than and have many rounds

1158
00:42:34,720 --> 00:42:38,240
i think it should work the same

1159
00:42:38,400 --> 00:42:40,720
great

1160
00:42:40,960 --> 00:42:42,880
we have another question

1161
00:42:42,880 --> 00:42:45,040
from

1162
00:42:45,839 --> 00:42:47,760
so how does your work relate to

1163
00:42:47,760 --> 00:42:50,079
signature schemes built using the fiat

1164
00:42:50,079 --> 00:42:52,400
mirror transform for example for shore

1165
00:42:52,400 --> 00:42:54,960
signatures we already know that you get

1166
00:42:54,960 --> 00:42:56,720
tighter proofs in the algebraic root

1167
00:42:56,720 --> 00:42:58,880
model is there a direct relation to your

1168
00:42:58,880 --> 00:43:00,640
work

1169
00:43:00,640 --> 00:43:01,520
uh

1170
00:43:01,520 --> 00:43:02,640
so so

1171
00:43:02,640 --> 00:43:05,280
for signature schemes uh like these are

1172
00:43:05,280 --> 00:43:07,040
obtained by applying the fiat semi

1173
00:43:07,040 --> 00:43:08,560
transform to like the signup sigma

1174
00:43:08,560 --> 00:43:12,000
protocols and for those we already like

1175
00:43:12,000 --> 00:43:14,880
know our tight relationship between

1176
00:43:14,880 --> 00:43:17,680
state restoration soundness and

1177
00:43:17,680 --> 00:43:18,480
like

1178
00:43:18,480 --> 00:43:20,880
soundness generically

1179
00:43:20,880 --> 00:43:23,119
so yeah we do don't need to like use our

1180
00:43:23,119 --> 00:43:26,760
framework for that case

1181
00:43:27,440 --> 00:43:30,800
great excellent

1182
00:43:31,040 --> 00:43:34,240
another question uh in the zulu from

1183
00:43:34,240 --> 00:43:36,560
markle this is for aransa

1184
00:43:36,560 --> 00:43:39,040
how does verifiable subspace sampling

1185
00:43:39,040 --> 00:43:43,040
relate to the techniques used in plaque

1186
00:43:43,520 --> 00:43:46,800
that's a good one um so just basically

1187
00:43:46,800 --> 00:43:48,240
suspect something is the old name for

1188
00:43:48,240 --> 00:43:51,359
the checklist by something

1189
00:43:51,359 --> 00:43:52,160
and

1190
00:43:52,160 --> 00:43:54,800
so look it's quite different and it has

1191
00:43:54,800 --> 00:43:56,880
been difficult to to put it in our

1192
00:43:56,880 --> 00:43:58,079
framework

1193
00:43:58,079 --> 00:44:00,480
and because

1194
00:44:00,480 --> 00:44:02,720
like the assumption made in long

1195
00:44:02,720 --> 00:44:05,359
basically is that the matrix is a sum of

1196
00:44:05,359 --> 00:44:07,839
permutation matrices is a well actually

1197
00:44:07,839 --> 00:44:10,000
it's one matrix that is a permutation

1198
00:44:10,000 --> 00:44:12,720
so you don't really need um

1199
00:44:12,720 --> 00:44:14,480
to sample the way we

1200
00:44:14,480 --> 00:44:15,680
we show it

1201
00:44:15,680 --> 00:44:16,880
but

1202
00:44:16,880 --> 00:44:19,119
we do have like a follow-up work and the

1203
00:44:19,119 --> 00:44:22,400
extended version in print where we try

1204
00:44:22,400 --> 00:44:26,079
our best to to include planck and well i

1205
00:44:26,079 --> 00:44:28,160
would suggest you to have a look and

1206
00:44:28,160 --> 00:44:31,839
then we can discuss me

1207
00:44:33,920 --> 00:44:37,440
wonderful thank you okay so do we have

1208
00:44:37,440 --> 00:44:39,760
additional questions uh at this time

1209
00:44:39,760 --> 00:44:41,599
does anyone want to ask one directly

1210
00:44:41,599 --> 00:44:44,079
over zoom

1211
00:44:44,800 --> 00:44:48,160
i would like to ask one please go for it

1212
00:44:48,160 --> 00:44:51,119
so my question is for ashrae

1213
00:44:51,119 --> 00:44:54,400
so i don't really under so i i apologize

1214
00:44:54,400 --> 00:44:56,400
because i couldn't read it yet but

1215
00:44:56,400 --> 00:44:58,800
um in if you are using the algebraic

1216
00:44:58,800 --> 00:45:01,040
good ma group model in which sense do

1217
00:45:01,040 --> 00:45:03,200
you get like concrete guarantees this is

1218
00:45:03,200 --> 00:45:06,720
like a model also

1219
00:45:06,720 --> 00:45:08,160
so um

1220
00:45:08,160 --> 00:45:10,160
so the guarantees we prove are for like

1221
00:45:10,160 --> 00:45:12,079
algebraic provers

1222
00:45:12,079 --> 00:45:13,440
like uh

1223
00:45:13,440 --> 00:45:14,880
yeah but like you're still making an

1224
00:45:14,880 --> 00:45:18,880
assumption right like you cannot really

1225
00:45:18,880 --> 00:45:21,119
quantify this like if this is not true

1226
00:45:21,119 --> 00:45:24,000
if your approver is not algebraic

1227
00:45:24,000 --> 00:45:27,200
so what it does is it rules out a class

1228
00:45:27,200 --> 00:45:28,960
of attack like algebraic attacks at

1229
00:45:28,960 --> 00:45:31,040
least you get guarantees against those

1230
00:45:31,040 --> 00:45:32,560
kind of attacks

1231
00:45:32,560 --> 00:45:34,960
but yes uh of course like there could be

1232
00:45:34,960 --> 00:45:37,359
like non-algebraic provers

1233
00:45:37,359 --> 00:45:39,520
against them we cannot say anything from

1234
00:45:39,520 --> 00:45:41,680
our result

1235
00:45:41,680 --> 00:45:43,680
okay and do you think you can ever prove

1236
00:45:43,680 --> 00:45:45,440
something without in the standard model

1237
00:45:45,440 --> 00:45:47,200
like i i know you left it as an open

1238
00:45:47,200 --> 00:45:49,359
question but how do you

1239
00:45:49,359 --> 00:45:51,119
um see this

1240
00:45:51,119 --> 00:45:53,599
so for the specific case of arguments uh

1241
00:45:53,599 --> 00:45:56,560
the uh the like you know

1242
00:45:56,560 --> 00:45:58,400
very briefly like the main issue is the

1243
00:45:58,400 --> 00:46:00,079
way we generally prove soundness of

1244
00:46:00,079 --> 00:46:02,800
arguments is we generally rewind the

1245
00:46:02,800 --> 00:46:04,960
prover to obtain like a

1246
00:46:04,960 --> 00:46:07,040
multiple accepting transcripts

1247
00:46:07,040 --> 00:46:08,720
and then when we are considering this

1248
00:46:08,720 --> 00:46:11,680
notion of state restoration soundness

1249
00:46:11,680 --> 00:46:13,280
uh

1250
00:46:13,280 --> 00:46:15,920
here like the prover can uh also like

1251
00:46:15,920 --> 00:46:17,680
restore the state of the verifier and

1252
00:46:17,680 --> 00:46:19,359
then we also need to rewind the prover

1253
00:46:19,359 --> 00:46:20,319
so this

1254
00:46:20,319 --> 00:46:21,200
the

1255
00:46:21,200 --> 00:46:22,960
there's this issue of like double

1256
00:46:22,960 --> 00:46:25,359
rewinding that comes in and that is like

1257
00:46:25,359 --> 00:46:29,520
we don't know of like how how to give a

1258
00:46:29,520 --> 00:46:31,359
good extractor strategy

1259
00:46:31,359 --> 00:46:33,760
and i think that is a very important

1260
00:46:33,760 --> 00:46:35,520
open problem if you can solve that in

1261
00:46:35,520 --> 00:46:37,760
the standard model so the reason that we

1262
00:46:37,760 --> 00:46:40,240
use the algebraic group model is that we

1263
00:46:40,240 --> 00:46:42,800
can bypass this issue of

1264
00:46:42,800 --> 00:46:44,640
trying to rewind the

1265
00:46:44,640 --> 00:46:47,440
prover we just can

1266
00:46:47,440 --> 00:46:49,599
extract a witness given like one

1267
00:46:49,599 --> 00:46:53,400
accepting transcript

1268
00:46:59,440 --> 00:47:04,480
great okay do we have further questions

1269
00:47:05,119 --> 00:47:08,880
i have a question for jonathan

1270
00:47:09,359 --> 00:47:10,400
um

1271
00:47:10,400 --> 00:47:12,319
so so i was uh

1272
00:47:12,319 --> 00:47:14,400
curious so you have these

1273
00:47:14,400 --> 00:47:15,280
you

1274
00:47:15,280 --> 00:47:17,520
you can explain these folding techniques

1275
00:47:17,520 --> 00:47:19,920
with the sum check protocol i was

1276
00:47:19,920 --> 00:47:22,160
wondering sort of how

1277
00:47:22,160 --> 00:47:24,400
how they compare in performance are you

1278
00:47:24,400 --> 00:47:26,880
sort of like recovering the same as you

1279
00:47:26,880 --> 00:47:28,640
do with folding techniques in the

1280
00:47:28,640 --> 00:47:30,960
discrete log setting

1281
00:47:30,960 --> 00:47:32,400
or

1282
00:47:32,400 --> 00:47:36,240
do you have a loss there or

1283
00:47:36,240 --> 00:47:37,920
does it boil down to the same type of

1284
00:47:37,920 --> 00:47:39,599
protocols essentially but just in a

1285
00:47:39,599 --> 00:47:40,640
different

1286
00:47:40,640 --> 00:47:44,480
sort of explanation for them

1287
00:47:44,480 --> 00:47:46,720
yep that's a good question um

1288
00:47:46,720 --> 00:47:47,440
so

1289
00:47:47,440 --> 00:47:49,359
in most cases like in the discrete log

1290
00:47:49,359 --> 00:47:51,280
setting for example we do recover

1291
00:47:51,280 --> 00:47:53,520
exactly the same efficiency as you know

1292
00:47:53,520 --> 00:47:55,599
bulletproofs and other protocols

1293
00:47:55,599 --> 00:47:56,480
and

1294
00:47:56,480 --> 00:47:57,359
um

1295
00:47:57,359 --> 00:47:58,960
there are some other cases for example

1296
00:47:58,960 --> 00:48:01,839
based on groups of anonymous for example

1297
00:48:01,839 --> 00:48:04,240
where we end up with a linear verified

1298
00:48:04,240 --> 00:48:06,079
complexity uh compared with

1299
00:48:06,079 --> 00:48:07,520
state-of-the-art protocols that actually

1300
00:48:07,520 --> 00:48:10,240
have a logarithmic verify complexity but

1301
00:48:10,240 --> 00:48:12,480
actually um in our framework that's

1302
00:48:12,480 --> 00:48:14,880
actually very nicely explained because

1303
00:48:14,880 --> 00:48:16,400
in this random evaluation at the end of

1304
00:48:16,400 --> 00:48:17,760
the protocol the verifier has to

1305
00:48:17,760 --> 00:48:19,599
evaluate a polynomial in the commitment

1306
00:48:19,599 --> 00:48:21,359
key and actually in these other works

1307
00:48:21,359 --> 00:48:23,040
that do better

1308
00:48:23,040 --> 00:48:24,319
it's because they've outsourced that

1309
00:48:24,319 --> 00:48:26,480
very particular operation um from the

1310
00:48:26,480 --> 00:48:29,040
verifier to the to the approver so i'd

1311
00:48:29,040 --> 00:48:29,920
say

1312
00:48:29,920 --> 00:48:31,599
either we match the efficiency of

1313
00:48:31,599 --> 00:48:32,960
existing works

1314
00:48:32,960 --> 00:48:34,880
or there's a very clear point in the

1315
00:48:34,880 --> 00:48:37,520
protocol at which you could outsource

1316
00:48:37,520 --> 00:48:39,359
the verifiers work to the approver and

1317
00:48:39,359 --> 00:48:43,279
then get the same efficiency as existing

1318
00:48:46,839 --> 00:48:49,119
works looks like we have another

1319
00:48:49,119 --> 00:48:51,599
question from the zulu so akshayaram

1320
00:48:51,599 --> 00:48:54,160
asks to ashrajit

1321
00:48:54,160 --> 00:48:55,920
is there a relation between state

1322
00:48:55,920 --> 00:48:58,000
restoration soundness and resettable

1323
00:48:58,000 --> 00:49:00,400
protocols like resettable zero knowledge

1324
00:49:00,400 --> 00:49:03,640
and soundness

1325
00:49:08,079 --> 00:49:11,839
uh uh i'm not like uh super familiar

1326
00:49:11,839 --> 00:49:14,400
with like resettable soundness but uh

1327
00:49:14,400 --> 00:49:15,440
like

1328
00:49:15,440 --> 00:49:16,800
like the the thing with state

1329
00:49:16,800 --> 00:49:18,480
restriction soundness is uh the prover

1330
00:49:18,480 --> 00:49:19,440
can

1331
00:49:19,440 --> 00:49:21,440
uh restore the state of the verifier to

1332
00:49:21,440 --> 00:49:23,680
any state not necessarily the start

1333
00:49:23,680 --> 00:49:24,960
state so

1334
00:49:24,960 --> 00:49:27,280
if if resettable uh soundness means that

1335
00:49:27,280 --> 00:49:28,800
the prover can just reset the verifier

1336
00:49:28,800 --> 00:49:30,480
so straight pressure and soundness has a

1337
00:49:30,480 --> 00:49:33,040
more like powerful proverb

1338
00:49:33,040 --> 00:49:34,559
but i'm not super familiar with the

1339
00:49:34,559 --> 00:49:37,119
definition

1340
00:49:38,800 --> 00:49:40,400
okay

1341
00:49:40,400 --> 00:49:43,960
other questions

1342
00:49:49,119 --> 00:49:50,880
so i have a question for ben and

1343
00:49:50,880 --> 00:49:53,200
benedict regarding the pcd so can you

1344
00:49:53,200 --> 00:49:55,839
comment on whether your constructions

1345
00:49:55,839 --> 00:49:57,599
preserve zero knowledge and whether that

1346
00:49:57,599 --> 00:49:59,200
requires additional assumptions on the

1347
00:49:59,200 --> 00:50:02,160
underlying primitives

1348
00:50:02,319 --> 00:50:05,280
um yes so far construction we proved

1349
00:50:05,280 --> 00:50:06,480
that

1350
00:50:06,480 --> 00:50:09,200
if the so so we build

1351
00:50:09,200 --> 00:50:10,480
pcd

1352
00:50:10,480 --> 00:50:14,640
from an accumulation scheme and uh narc

1353
00:50:14,640 --> 00:50:17,680
um and we show that if both of these

1354
00:50:17,680 --> 00:50:21,359
um have zero knowledge then the pcd

1355
00:50:21,359 --> 00:50:23,359
construction will also have zero

1356
00:50:23,359 --> 00:50:25,200
knowledge and in fact we also do the

1357
00:50:25,200 --> 00:50:27,040
same thing for if both of the

1358
00:50:27,040 --> 00:50:29,119
accumulation scheme and the

1359
00:50:29,119 --> 00:50:32,000
uh narc have are post quantum secure

1360
00:50:32,000 --> 00:50:34,640
then they will have um then the the

1361
00:50:34,640 --> 00:50:36,559
final pct construction will also be post

1362
00:50:36,559 --> 00:50:38,480
quantum secure so it seems like really

1363
00:50:38,480 --> 00:50:40,400
like what you put in is

1364
00:50:40,400 --> 00:50:43,680
what you end up getting out

1365
00:50:45,119 --> 00:50:47,440
great

1366
00:50:50,800 --> 00:50:52,880
sorry i was muted just from the flip

1367
00:50:52,880 --> 00:50:54,880
side if you're trying so for for our

1368
00:50:54,880 --> 00:50:56,240
results which are more about how to

1369
00:50:56,240 --> 00:50:57,920
build accumulation schemes from

1370
00:50:57,920 --> 00:51:00,480
polynomial commitments uh yes we also if

1371
00:51:00,480 --> 00:51:02,880
you start with a zero knowledge uh

1372
00:51:02,880 --> 00:51:05,839
polynomial equipment scheme then the uh

1373
00:51:05,839 --> 00:51:08,319
the zero knowledge is preserved as well

1374
00:51:08,319 --> 00:51:09,040
and

1375
00:51:09,040 --> 00:51:10,880
we also give generic zero knowledge

1376
00:51:10,880 --> 00:51:13,359
compilers for additive polynomial

1377
00:51:13,359 --> 00:51:14,720
schemes so any additive polynomial

1378
00:51:14,720 --> 00:51:18,319
equivalent scheme can be zero knowledge

1379
00:51:18,960 --> 00:51:20,000
cool

1380
00:51:20,000 --> 00:51:21,520
and can you comment a little bit on

1381
00:51:21,520 --> 00:51:23,520
instantiation so under what assumptions

1382
00:51:23,520 --> 00:51:25,520
do you need to instantiate uh your

1383
00:51:25,520 --> 00:51:28,400
general compilers

1384
00:51:28,720 --> 00:51:33,040
uh so that the compilers are

1385
00:51:33,040 --> 00:51:34,400
so

1386
00:51:34,400 --> 00:51:36,720
i mean similar to how benedict described

1387
00:51:36,720 --> 00:51:39,359
when you're the the the compilers that

1388
00:51:39,359 --> 00:51:40,800
actually build a non-interactive

1389
00:51:40,800 --> 00:51:43,200
protocol require you know fiat chamier

1390
00:51:43,200 --> 00:51:45,760
so it requires random oracle assumptions

1391
00:51:45,760 --> 00:51:46,800
but

1392
00:51:46,800 --> 00:51:49,599
um the bulk of our theorems are focused

1393
00:51:49,599 --> 00:51:51,839
on building just first like the

1394
00:51:51,839 --> 00:51:53,920
interactive um

1395
00:51:53,920 --> 00:51:56,400
what we call aggregation for polynomial

1396
00:51:56,400 --> 00:51:57,760
schemes and all that is information

1397
00:51:57,760 --> 00:52:00,240
theoretic

1398
00:52:00,960 --> 00:52:03,040
yeah and i guess there's this the the

1399
00:52:03,040 --> 00:52:05,040
computational assumptions are all go

1400
00:52:05,040 --> 00:52:06,559
into what's required to build a

1401
00:52:06,559 --> 00:52:08,960
commitment scheme so it's uh you know

1402
00:52:08,960 --> 00:52:11,040
it's binding or collision resistant

1403
00:52:11,040 --> 00:52:12,559
based on some assumption whether that's

1404
00:52:12,559 --> 00:52:14,559
screed log or something else

1405
00:52:14,559 --> 00:52:16,480
um but the transformations are

1406
00:52:16,480 --> 00:52:18,160
information theoretic except for the use

1407
00:52:18,160 --> 00:52:19,680
of yacht mirror

1408
00:52:19,680 --> 00:52:21,200
got it

1409
00:52:21,200 --> 00:52:23,599
right yeah um very similar i guess in

1410
00:52:23,599 --> 00:52:24,800
our construction

1411
00:52:24,800 --> 00:52:27,280
as i said it's secured in the random

1412
00:52:27,280 --> 00:52:28,960
oracle model under just the discrete log

1413
00:52:28,960 --> 00:52:30,720
assumption and one thing that is special

1414
00:52:30,720 --> 00:52:32,880
is that a lot of the

1415
00:52:32,880 --> 00:52:34,480
snarks that we know nowadays they

1416
00:52:34,480 --> 00:52:38,559
require um ffts in order to be efficient

1417
00:52:38,559 --> 00:52:40,640
and uh one thing that is really unique

1418
00:52:40,640 --> 00:52:42,319
here is that our construction does not

1419
00:52:42,319 --> 00:52:43,440
require

1420
00:52:43,440 --> 00:52:46,640
any uh the computation of any ffts so

1421
00:52:46,640 --> 00:52:48,800
this reduces the requirements on the

1422
00:52:48,800 --> 00:52:50,400
field for example that you can use you

1423
00:52:50,400 --> 00:52:54,880
don't need to have any fft friendliness

1424
00:52:55,440 --> 00:52:57,760
cool thanks

1425
00:52:57,760 --> 00:53:00,720
so let's see so we have another question

1426
00:53:00,720 --> 00:53:01,680
from

1427
00:53:01,680 --> 00:53:06,799
i don't know uh i guess that's a comment

1428
00:53:08,160 --> 00:53:09,440
okay

1429
00:53:09,440 --> 00:53:11,839
david where where are you reading the so

1430
00:53:11,839 --> 00:53:14,720
in zulip uh where are the i don't see

1431
00:53:14,720 --> 00:53:16,880
the stream of comments or questions it's

1432
00:53:16,880 --> 00:53:19,440
not so if you go to the conference

1433
00:53:19,440 --> 00:53:21,760
portal uh via the link on the website

1434
00:53:21,760 --> 00:53:24,160
there's uh and you enter the portal i

1435
00:53:24,160 --> 00:53:26,400
think there's a link to chat so there is

1436
00:53:26,400 --> 00:53:28,960
a link in this chat the first message of

1437
00:53:28,960 --> 00:53:31,839
this chat is the link to salute

1438
00:53:31,839 --> 00:53:36,558
yes okay just i sent it thanks kate yes

1439
00:53:36,880 --> 00:53:38,800
yep so i encourage you to also take a

1440
00:53:38,800 --> 00:53:41,440
look at discussions uh there in case you

1441
00:53:41,440 --> 00:53:43,839
want to elaborate or follow up on the

1442
00:53:43,839 --> 00:53:46,000
questions

1443
00:53:46,000 --> 00:53:46,880
so

1444
00:53:46,880 --> 00:53:49,119
any other questions before we wrap up

1445
00:53:49,119 --> 00:53:52,280
the session

1446
00:53:56,640 --> 00:53:58,559
okay so if not then let's uh thank all

1447
00:53:58,559 --> 00:54:02,400
of the speakers in the session again

1448
00:54:02,400 --> 00:54:05,839
and yeah

