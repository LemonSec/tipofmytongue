1
00:00:00,320 --> 00:00:01,040
hi

2
00:00:01,040 --> 00:00:02,960
i'm laurence roy i'd like to show you

3
00:00:02,960 --> 00:00:04,640
our new grubbling technique sliced and

4
00:00:04,640 --> 00:00:06,319
diced garbling where three halves come

5
00:00:06,319 --> 00:00:09,279
together to make a hole

6
00:00:11,120 --> 00:00:12,880
garbled circuits are one main technique

7
00:00:12,880 --> 00:00:15,040
used for secure function evaluation for

8
00:00:15,040 --> 00:00:16,560
example two parties may be trying to

9
00:00:16,560 --> 00:00:18,560
compute statistics on medical data from

10
00:00:18,560 --> 00:00:20,560
multiple sources covered by incompatible

11
00:00:20,560 --> 00:00:21,760
regulations

12
00:00:21,760 --> 00:00:23,199
they each have a private input and

13
00:00:23,199 --> 00:00:24,480
together they want to compute some

14
00:00:24,480 --> 00:00:27,519
function of both their inputs

15
00:00:27,519 --> 00:00:29,359
for garbled circuits one party hard

16
00:00:29,359 --> 00:00:31,439
codes its inputs into the function f

17
00:00:31,439 --> 00:00:34,480
while the other provides its inputs is x

18
00:00:34,480 --> 00:00:36,559
these two parties are called the garbler

19
00:00:36,559 --> 00:00:38,800
and the evaluator

20
00:00:38,800 --> 00:00:40,879
the garbler mixes up the function f to

21
00:00:40,879 --> 00:00:43,120
make food capital f or sorry i mean the

22
00:00:43,120 --> 00:00:44,800
garbled function and then gives it to

23
00:00:44,800 --> 00:00:46,559
the evaluator for taste testing or sorry

24
00:00:46,559 --> 00:00:48,480
i mean evaluation

25
00:00:48,480 --> 00:00:50,320
they also use oblivious transfer to give

26
00:00:50,320 --> 00:00:52,559
the evaluator its encoded inputs capital

27
00:00:52,559 --> 00:00:53,840
x

28
00:00:53,840 --> 00:00:55,520
the evaluator runs the grouped circuits

29
00:00:55,520 --> 00:00:58,399
to get goubled outputs y which are then

30
00:00:58,399 --> 00:00:59,680
decoded to get the output of the

31
00:00:59,680 --> 00:01:02,000
function

32
00:01:02,000 --> 00:01:03,600
researchers have been improving garbled

33
00:01:03,600 --> 00:01:05,600
circuits communication costs ever since

34
00:01:05,600 --> 00:01:07,439
yao first invented them

35
00:01:07,439 --> 00:01:09,119
this plot shows the cost of garbling a

36
00:01:09,119 --> 00:01:11,119
circuit consisting of an and gate and an

37
00:01:11,119 --> 00:01:13,600
xor gate

38
00:01:13,600 --> 00:01:15,680
beaver mccauley and rogoway introduced

39
00:01:15,680 --> 00:01:18,960
the point and permute optimization

40
00:01:18,960 --> 00:01:20,720
now our pincus and sumner save the

41
00:01:20,720 --> 00:01:22,479
ciphertext into each gate by using row

42
00:01:22,479 --> 00:01:24,479
reduction

43
00:01:24,479 --> 00:01:26,320
kohlsnikov and schneider introduced a

44
00:01:26,320 --> 00:01:28,240
very important optimization called free

45
00:01:28,240 --> 00:01:30,320
xor which eliminates all communication

46
00:01:30,320 --> 00:01:32,479
from xor gates

47
00:01:32,479 --> 00:01:33,680
there are a couple of other papers that

48
00:01:33,680 --> 00:01:35,280
introduced optimizations but

49
00:01:35,280 --> 00:01:36,560
unfortunately they are incompatible with

50
00:01:36,560 --> 00:01:39,200
free xor

51
00:01:39,360 --> 00:01:41,680
zahur roslich and evans found that

52
00:01:41,680 --> 00:01:43,600
xoring together two half gates makes a

53
00:01:43,600 --> 00:01:45,439
hole and gate and is compatible with

54
00:01:45,439 --> 00:01:47,680
free axor this allowed and gates to be

55
00:01:47,680 --> 00:01:49,520
garbled with only two ciphertexts worth

56
00:01:49,520 --> 00:01:51,360
of communication

57
00:01:51,360 --> 00:01:52,960
half gates was the state of the art for

58
00:01:52,960 --> 00:01:54,880
six years and was even proven optimal in

59
00:01:54,880 --> 00:01:56,719
a restricted model initially we also

60
00:01:56,719 --> 00:01:58,159
believed it was optimal and tried to

61
00:01:58,159 --> 00:02:01,119
prove this more generally

62
00:02:01,840 --> 00:02:03,520
however while investigating what made

63
00:02:03,520 --> 00:02:05,040
our attempted proof difficult we

64
00:02:05,040 --> 00:02:06,960
discovered something new with sliced and

65
00:02:06,960 --> 00:02:08,800
diced garlic an and gate can now be

66
00:02:08,800 --> 00:02:09,919
garbled with just three halves

67
00:02:09,919 --> 00:02:11,280
ciphertext while maintaining

68
00:02:11,280 --> 00:02:13,840
compatibility of free xor

69
00:02:13,840 --> 00:02:15,520
this is a more detailed comparison to

70
00:02:15,520 --> 00:02:17,280
previous work communication and

71
00:02:17,280 --> 00:02:19,280
computational costs are given along with

72
00:02:19,280 --> 00:02:21,120
the required security assumption

73
00:02:21,120 --> 00:02:23,200
our technique sliced and diced garbling

74
00:02:23,200 --> 00:02:25,040
is shown in bold in the bottom row it

75
00:02:25,040 --> 00:02:26,720
gives the best communication cost among

76
00:02:26,720 --> 00:02:27,920
all schemes

77
00:02:27,920 --> 00:02:30,080
although we do use more computation how

78
00:02:30,080 --> 00:02:31,680
much more depends on an optimization

79
00:02:31,680 --> 00:02:33,599
detailed in the paper

80
00:02:33,599 --> 00:02:35,680
like all free xor schemes we require the

81
00:02:35,680 --> 00:02:37,519
stronger circular correlation robust

82
00:02:37,519 --> 00:02:40,319
hash assumption

83
00:02:40,480 --> 00:02:42,160
now let's look at how grubbled circuits

84
00:02:42,160 --> 00:02:44,720
work in a garbled circuit the function f

85
00:02:44,720 --> 00:02:46,400
is broken down into gates connected with

86
00:02:46,400 --> 00:02:50,640
wires here's a wire carrying one bit

87
00:02:50,640 --> 00:02:52,640
gurgler will encrypt the circuit each

88
00:02:52,640 --> 00:02:54,480
wire is given two random unguessable

89
00:02:54,480 --> 00:02:56,640
strings called wire labels representing

90
00:02:56,640 --> 00:02:58,400
false and true

91
00:02:58,400 --> 00:03:00,239
the evaluator will only ever know one of

92
00:03:00,239 --> 00:03:02,239
the two wire labels for each wire it

93
00:03:02,239 --> 00:03:04,480
must not learn the other wire label

94
00:03:04,480 --> 00:03:06,239
each gate must provide some way for the

95
00:03:06,239 --> 00:03:08,000
evaluator to decrypt only the correct

96
00:03:08,000 --> 00:03:09,599
output wire label

97
00:03:09,599 --> 00:03:11,599
to hide which wire label represents true

98
00:03:11,599 --> 00:03:13,519
the coupler samples the point from u-bit

99
00:03:13,519 --> 00:03:14,560
pi a

100
00:03:14,560 --> 00:03:17,200
the labels a0 and a1 are swapped if pi a

101
00:03:17,200 --> 00:03:20,480
is 1. therefore if the evaluator has a i

102
00:03:20,480 --> 00:03:22,720
then i and pi a are secret shares of the

103
00:03:22,720 --> 00:03:26,080
plaintext value on that wire

104
00:03:26,720 --> 00:03:29,519
free xor requires the a0 x or a1 always

105
00:03:29,519 --> 00:03:32,400
be delta so the ai is always a 0 x or i

106
00:03:32,400 --> 00:03:33,680
times delta

107
00:03:33,680 --> 00:03:35,040
delta must be kept secret from the

108
00:03:35,040 --> 00:03:37,519
evaluator this key optimization allows

109
00:03:37,519 --> 00:03:39,360
xor gates to be evaluated by simply

110
00:03:39,360 --> 00:03:42,239
xoring the wire labels

111
00:03:42,239 --> 00:03:43,760
the validator will need to know whether

112
00:03:43,760 --> 00:03:46,879
it has a 0 or a1 so the first bit called

113
00:03:46,879 --> 00:03:49,680
the color bit of a0 is set to 0 and if

114
00:03:49,680 --> 00:03:51,360
a1 is set to 1

115
00:03:51,360 --> 00:03:52,720
this is safe because the evaluator

116
00:03:52,720 --> 00:03:54,400
doesn't know pi a

117
00:03:54,400 --> 00:03:55,840
to decode the final outputs in the

118
00:03:55,840 --> 00:03:57,840
circuit the evaluator sends the output

119
00:03:57,840 --> 00:03:59,519
wire labels to the garbler who knows

120
00:03:59,519 --> 00:04:02,080
which represents true

121
00:04:02,080 --> 00:04:03,840
recall that the color bit and the point

122
00:04:03,840 --> 00:04:05,519
in permute bit are secret shares of the

123
00:04:05,519 --> 00:04:07,280
plaintext value of a wire in the garbled

124
00:04:07,280 --> 00:04:08,159
circuit

125
00:04:08,159 --> 00:04:09,840
from this viewpoint the rest of the wire

126
00:04:09,840 --> 00:04:12,080
label authenticates the shares

127
00:04:12,080 --> 00:04:13,920
linear operations on secret shares can

128
00:04:13,920 --> 00:04:16,399
be applied for free the same is true for

129
00:04:16,399 --> 00:04:18,079
garbling because we use the same delta

130
00:04:18,079 --> 00:04:20,639
for all wires

131
00:04:20,639 --> 00:04:22,400
if we have an xor gate then we can set

132
00:04:22,400 --> 00:04:24,320
the output wire labels to be the xor of

133
00:04:24,320 --> 00:04:26,080
the two input wire labels

134
00:04:26,080 --> 00:04:27,919
the evaluator can now evaluate the gate

135
00:04:27,919 --> 00:04:29,840
by just xoring the two input wire labels

136
00:04:29,840 --> 00:04:31,759
together

137
00:04:31,759 --> 00:04:33,840
this requires no communication and very

138
00:04:33,840 --> 00:04:35,360
little computation

139
00:04:35,360 --> 00:04:37,120
for this reason garbled circuits are

140
00:04:37,120 --> 00:04:38,960
generally represented using and gates

141
00:04:38,960 --> 00:04:42,160
and xor gates

142
00:04:42,160 --> 00:04:44,160
in a classic garbled circuit the other

143
00:04:44,160 --> 00:04:45,600
gates in the circuit become encrypted

144
00:04:45,600 --> 00:04:47,759
lookup tables where given only a single

145
00:04:47,759 --> 00:04:50,160
wire label from each input wire only a

146
00:04:50,160 --> 00:04:52,080
single output may be decrypted

147
00:04:52,080 --> 00:04:53,440
the governor gives the evaluator

148
00:04:53,440 --> 00:04:55,280
encrypted gate containing the four gate

149
00:04:55,280 --> 00:04:59,199
ciphertext g 0 0 and so on

150
00:04:59,199 --> 00:05:00,960
and gates have 3 ways to evaluate to

151
00:05:00,960 --> 00:05:03,520
false and one way to evaluate to true

152
00:05:03,520 --> 00:05:05,440
let c be the wire label representing

153
00:05:05,440 --> 00:05:06,560
false

154
00:05:06,560 --> 00:05:08,560
three of the four gate outputs must be c

155
00:05:08,560 --> 00:05:10,240
while the remaining output must be c x

156
00:05:10,240 --> 00:05:12,880
or delta to represent true

157
00:05:12,880 --> 00:05:14,880
if for example a's point and permute bit

158
00:05:14,880 --> 00:05:17,360
is zero and b's is one then both inputs

159
00:05:17,360 --> 00:05:19,039
represent true when the evaluator is

160
00:05:19,039 --> 00:05:21,919
given a1 and b0 while in the other three

161
00:05:21,919 --> 00:05:25,840
cases the and gate will output false

162
00:05:26,160 --> 00:05:29,039
when the evaluator gets inputs ai and bj

163
00:05:29,039 --> 00:05:31,280
you can only decrypt cij

164
00:05:31,280 --> 00:05:35,120
this is the correct output wire label

165
00:05:35,120 --> 00:05:36,639
our new garbling scheme depends on

166
00:05:36,639 --> 00:05:38,400
taking a linear algebraic perspective on

167
00:05:38,400 --> 00:05:40,240
garbled gates we have not found any

168
00:05:40,240 --> 00:05:41,759
simpler description

169
00:05:41,759 --> 00:05:43,520
i'll start out by deriving it for these

170
00:05:43,520 --> 00:05:46,960
classic garbled and gates

171
00:05:47,360 --> 00:05:48,880
the gerbled gate consists of four

172
00:05:48,880 --> 00:05:50,639
ciphertexts

173
00:05:50,639 --> 00:05:52,400
a secure way of encrypting them is to

174
00:05:52,400 --> 00:05:54,400
hash the input wire labels and extra

175
00:05:54,400 --> 00:05:56,960
that with the output wire label

176
00:05:56,960 --> 00:06:00,240
each output wire label cij is either c

177
00:06:00,240 --> 00:06:02,479
the output wire label representing false

178
00:06:02,479 --> 00:06:04,800
or cx or delta the label representing

179
00:06:04,800 --> 00:06:06,800
true depending on the truth table of the

180
00:06:06,800 --> 00:06:07,759
gate

181
00:06:07,759 --> 00:06:09,600
we are still using the example of an and

182
00:06:09,600 --> 00:06:11,680
gate with point and permute bits pi a

183
00:06:11,680 --> 00:06:14,479
equals zero and pi b equals one so the

184
00:06:14,479 --> 00:06:18,479
true output case is a one b

185
00:06:18,840 --> 00:06:21,440
zero rearrange the equation so that the

186
00:06:21,440 --> 00:06:22,800
variables that the garbler solves for

187
00:06:22,800 --> 00:06:24,240
are on the left and the values that are

188
00:06:24,240 --> 00:06:26,240
already constrained around the right

189
00:06:26,240 --> 00:06:27,680
when the garbler reaches this gate

190
00:06:27,680 --> 00:06:28,960
you'll already know the input wire

191
00:06:28,960 --> 00:06:32,160
labels a01 and b01 and already have

192
00:06:32,160 --> 00:06:33,360
chosen delta

193
00:06:33,360 --> 00:06:35,680
it's also the gate ciphertext gij and

194
00:06:35,680 --> 00:06:37,919
the output wire label representing false

195
00:06:37,919 --> 00:06:39,520
c

196
00:06:39,520 --> 00:06:41,039
these linear equations specifying the

197
00:06:41,039 --> 00:06:42,960
guerbled gate can be written with linear

198
00:06:42,960 --> 00:06:44,479
algebra instead

199
00:06:44,479 --> 00:06:46,080
here's the equation for the zero zero

200
00:06:46,080 --> 00:06:47,199
case

201
00:06:47,199 --> 00:06:48,880
for this technique the hash gets

202
00:06:48,880 --> 00:06:50,800
multiplied by an indenting matrix but

203
00:06:50,800 --> 00:06:52,080
this matrix will get more interesting

204
00:06:52,080 --> 00:06:55,599
when we try to optimize garbling

205
00:06:55,759 --> 00:06:57,520
we can stack multiple equations together

206
00:06:57,520 --> 00:07:00,319
using this notation

207
00:07:00,319 --> 00:07:02,479
the one zero case is the true case and

208
00:07:02,479 --> 00:07:04,080
so it involves delta

209
00:07:04,080 --> 00:07:06,000
to represent this add a vector that is

210
00:07:06,000 --> 00:07:08,880
multiplied by delta

211
00:07:09,199 --> 00:07:11,280
we now get the full gate equation the

212
00:07:11,280 --> 00:07:12,880
garbler can use this to find the gate

213
00:07:12,880 --> 00:07:15,520
ciphertext gij and the output wire label

214
00:07:15,520 --> 00:07:18,000
representing false c

215
00:07:18,000 --> 00:07:20,400
there's a gate matrix v that says how c

216
00:07:20,400 --> 00:07:21,680
and the gate ciphertext enter the

217
00:07:21,680 --> 00:07:24,160
equation a hash matrix m is specifying

218
00:07:24,160 --> 00:07:26,639
how the hashes are used a hash vector h

219
00:07:26,639 --> 00:07:28,960
containing all four hash evaluations and

220
00:07:28,960 --> 00:07:30,800
a true table t giving the cases where

221
00:07:30,800 --> 00:07:32,479
delta is used

222
00:07:32,479 --> 00:07:33,919
t is just the gate's truth table

223
00:07:33,919 --> 00:07:35,280
permuted to match the point and permute

224
00:07:35,280 --> 00:07:38,000
bits of the inputs

225
00:07:38,000 --> 00:07:39,360
although this equation shows how to

226
00:07:39,360 --> 00:07:41,280
garble the gate in fact we discovered it

227
00:07:41,280 --> 00:07:42,639
by writing out the four ways that the

228
00:07:42,639 --> 00:07:44,960
gate could be evaluated

229
00:07:44,960 --> 00:07:46,240
notice that this equation is

230
00:07:46,240 --> 00:07:48,960
underdetermined

231
00:07:48,960 --> 00:07:51,199
that is g zero zero is redundant and can

232
00:07:51,199 --> 00:07:53,039
be set to zero as long as we solve for

233
00:07:53,039 --> 00:07:55,199
the false output wire label c

234
00:07:55,199 --> 00:07:56,560
this optimization is called row

235
00:07:56,560 --> 00:07:59,560
reduction

236
00:08:00,080 --> 00:08:01,919
well that's one optimization can we do

237
00:08:01,919 --> 00:08:03,599
any others can we compress the gate

238
00:08:03,599 --> 00:08:05,039
ciphertext

239
00:08:05,039 --> 00:08:06,879
well this may seem absurd as the gate

240
00:08:06,879 --> 00:08:08,639
circuits have been hidden using h and

241
00:08:08,639 --> 00:08:10,160
you can cannot compress the uniform

242
00:08:10,160 --> 00:08:12,319
randomness

243
00:08:12,319 --> 00:08:14,000
however we can use h in a way that

244
00:08:14,000 --> 00:08:15,840
reduces the entropy allowing the gate to

245
00:08:15,840 --> 00:08:17,120
be compressed

246
00:08:17,120 --> 00:08:18,720
instead of hashing the input wire labels

247
00:08:18,720 --> 00:08:20,879
together hash them separately and export

248
00:08:20,879 --> 00:08:22,639
the hashes together

249
00:08:22,639 --> 00:08:24,160
this still has the security properties

250
00:08:24,160 --> 00:08:25,680
that the evaluator cannot evaluate any

251
00:08:25,680 --> 00:08:28,000
other case than the one is given because

252
00:08:28,000 --> 00:08:29,840
any two possible ways of evaluating the

253
00:08:29,840 --> 00:08:31,599
gate are separated by at least one input

254
00:08:31,599 --> 00:08:33,440
change which then attaches to something

255
00:08:33,440 --> 00:08:36,159
that the evaluator does not know

256
00:08:36,159 --> 00:08:38,000
if we multiply the all one's row vector

257
00:08:38,000 --> 00:08:39,679
by the vector of the combined hashes

258
00:08:39,679 --> 00:08:41,599
which represents taking the xor of all

259
00:08:41,599 --> 00:08:44,000
four elements we get zero because each

260
00:08:44,000 --> 00:08:46,800
hashed wire label is used exactly twice

261
00:08:46,800 --> 00:08:48,480
this means that there is now one linear

262
00:08:48,480 --> 00:08:50,240
constraint on the combined hashes so

263
00:08:50,240 --> 00:08:54,080
they have less entropy than before

264
00:08:54,080 --> 00:08:55,600
the new hashes can be written in matrix

265
00:08:55,600 --> 00:08:57,920
notation hash matrix now has rank three

266
00:08:57,920 --> 00:09:00,800
because each column xors to zero

267
00:09:00,800 --> 00:09:02,640
the all ones vector representing the

268
00:09:02,640 --> 00:09:04,640
constraint that the hash's xor to zero

269
00:09:04,640 --> 00:09:06,880
is the co kernel of this hash matrix

270
00:09:06,880 --> 00:09:08,399
in other words it's a kind of witness to

271
00:09:08,399 --> 00:09:10,320
the hash matrix not being full rank

272
00:09:10,320 --> 00:09:11,600
which is good because it means that

273
00:09:11,600 --> 00:09:12,720
there is a redundancy that we can

274
00:09:12,720 --> 00:09:15,360
compress away

275
00:09:15,680 --> 00:09:17,519
this is the gate equation now using the

276
00:09:17,519 --> 00:09:18,880
half gates hash

277
00:09:18,880 --> 00:09:20,480
you now have one fewer ciphertext

278
00:09:20,480 --> 00:09:21,839
because the hash matrix now has only

279
00:09:21,839 --> 00:09:23,120
rank 3.

280
00:09:23,120 --> 00:09:24,480
notice that the equation is now over

281
00:09:24,480 --> 00:09:26,240
determined so for a solution to exist we

282
00:09:26,240 --> 00:09:27,360
need the right-hand side to be in the

283
00:09:27,360 --> 00:09:30,959
column space of the gate matrix v

284
00:09:30,959 --> 00:09:32,959
this is fine for the hashes specifically

285
00:09:32,959 --> 00:09:34,640
chose v as the basis for m's column

286
00:09:34,640 --> 00:09:37,040
space but the truth table xors to one

287
00:09:37,040 --> 00:09:38,399
and every column of the gate matrix

288
00:09:38,399 --> 00:09:40,399
exports to zero so the truth table is

289
00:09:40,399 --> 00:09:42,480
not in the gate matrix's column space

290
00:09:42,480 --> 00:09:46,160
therefore no solution can exist

291
00:09:48,399 --> 00:09:50,000
to find a way of fixing this let's

292
00:09:50,000 --> 00:09:51,120
switch back to the evaluator's

293
00:09:51,120 --> 00:09:52,160
perspective

294
00:09:52,160 --> 00:09:53,760
evaluator computes the xor of the two

295
00:09:53,760 --> 00:09:55,760
hashes and uses it to decrypt the gate

296
00:09:55,760 --> 00:09:57,040
ciphertext

297
00:09:57,040 --> 00:09:58,640
using the correct row of the calf gate's

298
00:09:58,640 --> 00:10:00,480
gate matrix is equivalent to computing i

299
00:10:00,480 --> 00:10:03,519
times g0 xor j times g1

300
00:10:03,519 --> 00:10:05,440
this equation uses the gate ciphertext

301
00:10:05,440 --> 00:10:06,880
and the hashes but there's one thing

302
00:10:06,880 --> 00:10:08,800
that's missing it never uses the input

303
00:10:08,800 --> 00:10:11,360
wire labels directly

304
00:10:11,360 --> 00:10:13,839
let's try xoring a i into the output

305
00:10:13,839 --> 00:10:16,399
when the b input has color bit 1.

306
00:10:16,399 --> 00:10:21,200
in other words get x or with j times a i

307
00:10:21,760 --> 00:10:22,959
switching back to the garbler's

308
00:10:22,959 --> 00:10:24,959
perspective this becomes four equations

309
00:10:24,959 --> 00:10:28,640
for the four evaluation cases

310
00:10:29,680 --> 00:10:31,040
like when we were deriving the linear

311
00:10:31,040 --> 00:10:32,800
algebraic perspective before we can

312
00:10:32,800 --> 00:10:34,959
substitute in the relationship that cij

313
00:10:34,959 --> 00:10:37,360
and ai have with delta

314
00:10:37,360 --> 00:10:40,000
notice that a1 becomes a0 x or delta

315
00:10:40,000 --> 00:10:42,000
this additional delta term will let us

316
00:10:42,000 --> 00:10:44,720
fix the problem

317
00:10:44,720 --> 00:10:46,399
also like before we can rearrange the

318
00:10:46,399 --> 00:10:47,600
terms so that the variables that the

319
00:10:47,600 --> 00:10:49,440
gobbler must solve for on the left and

320
00:10:49,440 --> 00:10:50,720
the already known values are on the

321
00:10:50,720 --> 00:10:52,959
right

322
00:10:53,839 --> 00:10:55,440
again we can stack these equations

323
00:10:55,440 --> 00:10:57,040
together into matrices

324
00:10:57,040 --> 00:10:59,200
the first case only uses c it only

325
00:10:59,200 --> 00:11:04,079
computes hashes h of a 0 and h of b 0.

326
00:11:05,279 --> 00:11:06,640
something interesting happens in the

327
00:11:06,640 --> 00:11:08,560
second case we need to add another

328
00:11:08,560 --> 00:11:10,320
matrix called the control matrix to

329
00:11:10,320 --> 00:11:12,160
represent the fact that a0 was xored

330
00:11:12,160 --> 00:11:15,760
into this output wire

331
00:11:15,760 --> 00:11:17,920
the third case is the true output case

332
00:11:17,920 --> 00:11:21,279
so it gets a 1 in the truth table

333
00:11:21,279 --> 00:11:23,440
in the final case the control matrix not

334
00:11:23,440 --> 00:11:25,279
the truth table is responsible for delta

335
00:11:25,279 --> 00:11:27,200
being xor into the output because the

336
00:11:27,200 --> 00:11:29,279
delta came from the evaluator xoring the

337
00:11:29,279 --> 00:11:31,680
output wire label of a1

338
00:11:31,680 --> 00:11:33,440
in general the control matrix r tells

339
00:11:33,440 --> 00:11:35,360
which inputs are xored into the output

340
00:11:35,360 --> 00:11:37,120
in which cases

341
00:11:37,120 --> 00:11:38,640
now that the truth table has been xored

342
00:11:38,640 --> 00:11:40,160
with the control matrix the result has

343
00:11:40,160 --> 00:11:42,000
an even number of ones in each column no

344
00:11:42,000 --> 00:11:43,440
matter where the one goes in the truth

345
00:11:43,440 --> 00:11:45,519
table the equation will now always be

346
00:11:45,519 --> 00:11:47,920
solvable

347
00:11:47,920 --> 00:11:49,279
half gates was the state of the art and

348
00:11:49,279 --> 00:11:53,040
garbling and gates until our work

349
00:11:53,040 --> 00:11:54,480
more compression will require more

350
00:11:54,480 --> 00:11:57,040
redundancy in the hash matrix that is to

351
00:11:57,040 --> 00:11:58,639
reduce the number of gate sample texts

352
00:11:58,639 --> 00:12:00,000
you must reduce the rank of the hash

353
00:12:00,000 --> 00:12:01,519
matrix

354
00:12:01,519 --> 00:12:03,360
the redundancy and the half gates hash

355
00:12:03,360 --> 00:12:04,959
matrix comes from using hashes that can

356
00:12:04,959 --> 00:12:07,839
be computed in two out of four cases

357
00:12:07,839 --> 00:12:09,920
this diagram shows which hashed calls

358
00:12:09,920 --> 00:12:11,440
can be computed by the evaluator for

359
00:12:11,440 --> 00:12:13,279
which inputs there are four points

360
00:12:13,279 --> 00:12:14,880
representing the four cases the gate can

361
00:12:14,880 --> 00:12:17,279
be evaluated in each hash is represented

362
00:12:17,279 --> 00:12:18,639
as a line through the points that it can

363
00:12:18,639 --> 00:12:20,399
be evaluated at

364
00:12:20,399 --> 00:12:22,000
for example the lower left point is the

365
00:12:22,000 --> 00:12:24,240
a1 b0 case where the evaluator can

366
00:12:24,240 --> 00:12:28,399
compute h of a1 and h of b0

367
00:12:29,920 --> 00:12:31,839
taking the xor of the two inputs using

368
00:12:31,839 --> 00:12:33,839
free xor gives another pair of true and

369
00:12:33,839 --> 00:12:35,920
false wire labels what happens if we

370
00:12:35,920 --> 00:12:36,839
hash

371
00:12:36,839 --> 00:12:40,000
them we get two new hash evaluations

372
00:12:40,000 --> 00:12:41,600
which can each be computed in two out of

373
00:12:41,600 --> 00:12:42,959
the four cases

374
00:12:42,959 --> 00:12:44,560
one can be evaluated when the inputs are

375
00:12:44,560 --> 00:12:45,839
the same while the other can be

376
00:12:45,839 --> 00:12:48,079
evaluated when the inputs differ

377
00:12:48,079 --> 00:12:50,959
eg in the a1 b0 case not only can the

378
00:12:50,959 --> 00:12:53,760
evaluator find h of a1 and h of b0 you

379
00:12:53,760 --> 00:12:56,480
can also compute h of a1 x or b0 which

380
00:12:56,480 --> 00:13:00,480
is the same as h of a0 x or b1

381
00:13:00,959 --> 00:13:02,480
we'd like to get more redundancy from

382
00:13:02,480 --> 00:13:04,800
using these extra hashes unfortunately

383
00:13:04,800 --> 00:13:06,720
going down to rank two would be too low

384
00:13:06,720 --> 00:13:08,320
the hash matrix would either have two

385
00:13:08,320 --> 00:13:12,480
identical rows or an all zero row

386
00:13:14,240 --> 00:13:16,240
if we can't save a whole ciphertext

387
00:13:16,240 --> 00:13:17,760
let's save a half

388
00:13:17,760 --> 00:13:19,360
let's put the wire labels up into two

389
00:13:19,360 --> 00:13:21,519
pieces this allows much more flexibility

390
00:13:21,519 --> 00:13:22,959
when choosing linear combinations of

391
00:13:22,959 --> 00:13:25,359
hashes

392
00:13:25,920 --> 00:13:27,760
in each of the four cases for the inputs

393
00:13:27,760 --> 00:13:29,839
a and b there are three hashes that the

394
00:13:29,839 --> 00:13:31,680
evaluator can compute

395
00:13:31,680 --> 00:13:33,120
each hash function produces only

396
00:13:33,120 --> 00:13:34,959
half-sized output but still takes

397
00:13:34,959 --> 00:13:36,639
full-sized input as otherwise we'd be

398
00:13:36,639 --> 00:13:39,120
having the security parameter

399
00:13:39,120 --> 00:13:41,440
the three half-sized hashes are combined

400
00:13:41,440 --> 00:13:43,279
to make a whole wire label worth of

401
00:13:43,279 --> 00:13:44,959
randomness which is used to mask the

402
00:13:44,959 --> 00:13:47,120
output wire label the violator will

403
00:13:47,120 --> 00:13:48,880
compute the left half of the output with

404
00:13:48,880 --> 00:13:51,680
h of a x or h of ax or b and the right

405
00:13:51,680 --> 00:13:55,600
half with h of b x or h of a x or b

406
00:13:55,600 --> 00:13:57,760
some of the terms are needed of course

407
00:13:57,760 --> 00:13:59,279
we need to use the gate cipher text in

408
00:13:59,279 --> 00:14:02,600
the control matrix

409
00:14:02,800 --> 00:14:04,399
the hash term and the gate equation will

410
00:14:04,399 --> 00:14:06,079
now look like this

411
00:14:06,079 --> 00:14:07,839
notice that after splitting we now have

412
00:14:07,839 --> 00:14:10,160
eight rows instead of four because each

413
00:14:10,160 --> 00:14:12,079
case of evaluation must now produce a

414
00:14:12,079 --> 00:14:13,519
two dimensional vector as the output

415
00:14:13,519 --> 00:14:15,040
wire level

416
00:14:15,040 --> 00:14:16,800
the hashes the evaluator uses can be

417
00:14:16,800 --> 00:14:19,040
read off the hash matrix e.g let's say

418
00:14:19,040 --> 00:14:21,920
that the evaluator has the a0 b1 case

419
00:14:21,920 --> 00:14:23,199
corresponding to the third and fourth

420
00:14:23,199 --> 00:14:24,720
rows of the matrix

421
00:14:24,720 --> 00:14:26,240
evaluator computes the left half of the

422
00:14:26,240 --> 00:14:28,959
output wire label using h of a0 and h of

423
00:14:28,959 --> 00:14:31,680
a 0 x or b 1 and the right half using h

424
00:14:31,680 --> 00:14:36,160
of b 1 and h of a 0 x or b 1.

425
00:14:37,680 --> 00:14:40,480
notice that every row of m x raised to 0

426
00:14:40,480 --> 00:14:43,279
so m has rank 5.

427
00:14:43,279 --> 00:14:44,880
for the equation to be solvable the

428
00:14:44,880 --> 00:14:46,320
right hand side must be in the column

429
00:14:46,320 --> 00:14:48,079
space of the gate matrix

430
00:14:48,079 --> 00:14:49,760
therefore we should pick a gate matrix

431
00:14:49,760 --> 00:14:51,120
five columns to span the five

432
00:14:51,120 --> 00:14:53,760
dimensional column space of m

433
00:14:53,760 --> 00:14:55,360
two of the columns can be the two halves

434
00:14:55,360 --> 00:14:57,120
of the false output wire label because

435
00:14:57,120 --> 00:14:58,480
of row reduction

436
00:14:58,480 --> 00:15:00,000
the other three columns must come from

437
00:15:00,000 --> 00:15:01,680
the gate server texts since they are

438
00:15:01,680 --> 00:15:03,440
half sized if we can get this to work

439
00:15:03,440 --> 00:15:05,199
then we have a three halves ciphertext

440
00:15:05,199 --> 00:15:07,839
garbled and gate as promised

441
00:15:07,839 --> 00:15:08,959
so we need to fill out the question

442
00:15:08,959 --> 00:15:13,440
marks in v so the column spaces match

443
00:15:13,440 --> 00:15:14,880
it turns out that grabbing three columns

444
00:15:14,880 --> 00:15:16,560
from m will make v have the correct

445
00:15:16,560 --> 00:15:19,119
column space

446
00:15:20,959 --> 00:15:22,800
might we have reduced the security level

447
00:15:22,800 --> 00:15:24,320
by using a hash function with a half

448
00:15:24,320 --> 00:15:26,959
sized output to argue otherwise assume

449
00:15:26,959 --> 00:15:28,399
that there's an evaluator that gets the

450
00:15:28,399 --> 00:15:31,680
input wire labels in the a0 b0 case

451
00:15:31,680 --> 00:15:33,360
the evaluator has been corrupted and is

452
00:15:33,360 --> 00:15:36,480
trying to evaluate the a0 b1 case

453
00:15:36,480 --> 00:15:38,320
for security it must not be able to

454
00:15:38,320 --> 00:15:39,759
learn anything about the output wire

455
00:15:39,759 --> 00:15:41,600
labels other than the one that is

456
00:15:41,600 --> 00:15:44,320
supposed to evaluate

457
00:15:44,320 --> 00:15:46,079
the red wire labels are the values it

458
00:15:46,079 --> 00:15:48,399
knows

459
00:15:48,720 --> 00:15:50,399
it can only compute hashes on known

460
00:15:50,399 --> 00:15:52,320
inputs these hashes have also been

461
00:15:52,320 --> 00:15:53,519
highlighted

462
00:15:53,519 --> 00:15:55,360
the evaluator isn't able to learn

463
00:15:55,360 --> 00:15:57,360
anything about c01

464
00:15:57,360 --> 00:16:00,639
the two hashes h of b1 and h of a0 xor

465
00:16:00,639 --> 00:16:02,880
b1 which you cannot compute are enough

466
00:16:02,880 --> 00:16:04,639
to completely hide both halves of the

467
00:16:04,639 --> 00:16:06,320
output wire label

468
00:16:06,320 --> 00:16:08,000
this is true in general any two

469
00:16:08,000 --> 00:16:09,920
evaluation cases only share a single

470
00:16:09,920 --> 00:16:11,759
hash the other two hashes will look

471
00:16:11,759 --> 00:16:13,680
completely random to a corrupt evaluator

472
00:16:13,680 --> 00:16:15,519
and will completely hide the output wire

473
00:16:15,519 --> 00:16:18,519
label

474
00:16:22,320 --> 00:16:24,320
we need to derive the full gate equation

475
00:16:24,320 --> 00:16:26,639
in order to find the control matrices

476
00:16:26,639 --> 00:16:28,480
to start off this is how the evaluator

477
00:16:28,480 --> 00:16:30,560
will compute the output wire label using

478
00:16:30,560 --> 00:16:32,079
parts of the gate matrix and control

479
00:16:32,079 --> 00:16:33,600
matrix

480
00:16:33,600 --> 00:16:36,399
the partial control matrices rij a and

481
00:16:36,399 --> 00:16:38,959
rijb are two by two matrices telling the

482
00:16:38,959 --> 00:16:43,279
evaluator how to use the a and b inputs

483
00:16:44,320 --> 00:16:46,000
for concreteness let's assume that the

484
00:16:46,000 --> 00:16:50,759
evaluator has inputs a1 and b0

485
00:16:51,600 --> 00:16:53,440
introduce deltas into the equation by

486
00:16:53,440 --> 00:16:55,040
substituting in the equations for the

487
00:16:55,040 --> 00:16:56,880
input and output wire labels in terms of

488
00:16:56,880 --> 00:16:59,920
delta in this example the a1 b0 case

489
00:16:59,920 --> 00:17:02,000
output is true so the left side becomes

490
00:17:02,000 --> 00:17:05,839
the true wire label c x or delta

491
00:17:07,119 --> 00:17:09,599
here's the complete gate equation

492
00:17:09,599 --> 00:17:11,280
the left two columns of the gate matrix

493
00:17:11,280 --> 00:17:13,679
are always stacked identity matrices as

494
00:17:13,679 --> 00:17:15,760
they correspond to cl and cr which are

495
00:17:15,760 --> 00:17:17,359
always part of the left and right halves

496
00:17:17,359 --> 00:17:20,400
of the output wire label respectively

497
00:17:20,400 --> 00:17:23,280
rows 5 and 6 correspond to the a1 b0

498
00:17:23,280 --> 00:17:25,359
case shown above the delta is on the

499
00:17:25,359 --> 00:17:26,959
left side of the evaluation equation

500
00:17:26,959 --> 00:17:28,400
which came from this being the true

501
00:17:28,400 --> 00:17:30,480
output case it turned into a 2x2

502
00:17:30,480 --> 00:17:33,360
identity matrix in the truth table

503
00:17:33,360 --> 00:17:34,640
the deltas on the right of the

504
00:17:34,640 --> 00:17:37,039
evaluation equation come from a1 being a

505
00:17:37,039 --> 00:17:39,120
zero x or delta

506
00:17:39,120 --> 00:17:41,760
r one zero a is multiplied by both a0

507
00:17:41,760 --> 00:17:44,000
and delta in this equation

508
00:17:44,000 --> 00:17:45,440
in the gate equation this makes the

509
00:17:45,440 --> 00:17:48,240
control matrix contain r10a in both its

510
00:17:48,240 --> 00:17:51,679
a0 and its delta columns

511
00:17:52,000 --> 00:17:53,039
we can write this equation more

512
00:17:53,039 --> 00:17:55,120
succinctly using matrices and vectors we

513
00:17:55,120 --> 00:17:56,480
defined

514
00:17:56,480 --> 00:17:57,760
again we need the right side of the

515
00:17:57,760 --> 00:17:59,280
equation to always be in the column

516
00:17:59,280 --> 00:18:00,559
space of v

517
00:18:00,559 --> 00:18:02,400
like half gates the truth table causes

518
00:18:02,400 --> 00:18:04,000
the most trouble because we have to pick

519
00:18:04,000 --> 00:18:06,400
the control matrix so that r x or t fits

520
00:18:06,400 --> 00:18:09,200
in the column space

521
00:18:10,000 --> 00:18:11,679
however this is a bigger issue than it

522
00:18:11,679 --> 00:18:13,120
was for half gates

523
00:18:13,120 --> 00:18:15,039
slicing requires creating an asymmetry

524
00:18:15,039 --> 00:18:16,720
where h of a is used in the left half of

525
00:18:16,720 --> 00:18:18,640
the output while h of b is used in the

526
00:18:18,640 --> 00:18:19,520
right

527
00:18:19,520 --> 00:18:20,960
the corresponding asymmetry in the

528
00:18:20,960 --> 00:18:22,799
column space forces the control matrix

529
00:18:22,799 --> 00:18:25,760
to depend on which case output's true

530
00:18:25,760 --> 00:18:27,200
the evaluator would have to be told the

531
00:18:27,200 --> 00:18:28,880
control matrix but then it could find

532
00:18:28,880 --> 00:18:29,919
out which point in permute bits

533
00:18:29,919 --> 00:18:31,840
correspond to that control matrix

534
00:18:31,840 --> 00:18:33,200
leaking the point in permute bits is a

535
00:18:33,200 --> 00:18:34,640
big problem as then the evaluator would

536
00:18:34,640 --> 00:18:38,080
know the plaintext values in the circuit

537
00:18:38,960 --> 00:18:40,840
our solution to this problem is called

538
00:18:40,840 --> 00:18:43,039
dicing the idea is that the evaluator

539
00:18:43,039 --> 00:18:44,400
doesn't need to know the whole control

540
00:18:44,400 --> 00:18:46,960
matrix it only needs to know rij which

541
00:18:46,960 --> 00:18:48,559
it tells it what to do with input wire

542
00:18:48,559 --> 00:18:50,880
labels ai and bj the one case it is

543
00:18:50,880 --> 00:18:53,120
evaluating

544
00:18:53,120 --> 00:18:54,799
the gobbler rolls dice to randomize the

545
00:18:54,799 --> 00:18:57,679
choice of r so that rij leaks nothing

546
00:18:57,679 --> 00:18:59,440
it then garbles the control matrix by

547
00:18:59,440 --> 00:19:01,440
encrypting each rij with the input wire

548
00:19:01,440 --> 00:19:04,400
labels ai and bj so that the evaluator

549
00:19:04,400 --> 00:19:07,840
cannot learn more than rij

550
00:19:08,960 --> 00:19:10,240
for this to work we need the

551
00:19:10,240 --> 00:19:12,080
distribution on control matrices that

552
00:19:12,080 --> 00:19:14,799
always puts r x or t in the column space

553
00:19:14,799 --> 00:19:16,559
it does not leak the truth table t to

554
00:19:16,559 --> 00:19:18,799
the evaluator

555
00:19:18,799 --> 00:19:20,320
use compression so that we don't have to

556
00:19:20,320 --> 00:19:21,760
send the whole control matrix which

557
00:19:21,760 --> 00:19:24,799
takes 32 bits for every gate we require

558
00:19:24,799 --> 00:19:28,640
that each rij is in a linear subspace s

559
00:19:28,640 --> 00:19:30,400
of two by four matrices

560
00:19:30,400 --> 00:19:31,760
it turns out that a two dimensional

561
00:19:31,760 --> 00:19:34,799
subspace is optimal

562
00:19:36,720 --> 00:19:39,039
with compression each rij can be written

563
00:19:39,039 --> 00:19:41,200
as eight individual bits called control

564
00:19:41,200 --> 00:19:43,120
bits using a basis of this linear

565
00:19:43,120 --> 00:19:44,240
subspace

566
00:19:44,240 --> 00:19:45,840
we put these eight bits together into a

567
00:19:45,840 --> 00:19:47,520
four by two matrix

568
00:19:47,520 --> 00:19:49,760
each row represents an evaluation case

569
00:19:49,760 --> 00:19:51,600
while the columns correspond to the

570
00:19:51,600 --> 00:19:55,678
basis elements s1 and s2

571
00:19:58,799 --> 00:20:01,520
evaluating the gate requires three steps

572
00:20:01,520 --> 00:20:03,440
first the evaluator decrypts the garbled

573
00:20:03,440 --> 00:20:04,799
control bits

574
00:20:04,799 --> 00:20:06,960
z contains the encrypted control bits

575
00:20:06,960 --> 00:20:09,200
and zij gives the encrypted bits for the

576
00:20:09,200 --> 00:20:11,120
aibj case

577
00:20:11,120 --> 00:20:12,880
h prime is a hash function with 2-bit

578
00:20:12,880 --> 00:20:14,320
output

579
00:20:14,320 --> 00:20:16,320
next the evaluator finds its part of the

580
00:20:16,320 --> 00:20:18,159
control matrix using the control bits

581
00:20:18,159 --> 00:20:19,760
and the basis

582
00:20:19,760 --> 00:20:22,000
finally it uses the control matrix to

583
00:20:22,000 --> 00:20:23,840
evaluate the gate and get the output

584
00:20:23,840 --> 00:20:27,039
wire label cij

585
00:20:27,840 --> 00:20:29,440
we use the co kernel to help find the

586
00:20:29,440 --> 00:20:31,440
control matrix distribution

587
00:20:31,440 --> 00:20:34,000
the ko kernel of v is a matrix k such

588
00:20:34,000 --> 00:20:36,480
that k v equals 0 and k has as high rank

589
00:20:36,480 --> 00:20:38,080
as possible

590
00:20:38,080 --> 00:20:39,760
this means that a vector x is in the

591
00:20:39,760 --> 00:20:41,919
column space if and only if k x equals

592
00:20:41,919 --> 00:20:43,039
zero

593
00:20:43,039 --> 00:20:44,799
k has three rows which represents three

594
00:20:44,799 --> 00:20:46,840
constraints on

595
00:20:46,840 --> 00:20:49,280
x for half gates the co kernel was the

596
00:20:49,280 --> 00:20:52,240
all one's row vector

597
00:20:53,520 --> 00:20:55,600
we need r x or t to be in the column

598
00:20:55,600 --> 00:20:57,520
space

599
00:20:57,520 --> 00:20:59,120
and the co kernel gives a convenient way

600
00:20:59,120 --> 00:21:00,799
of expressing this constraint

601
00:21:00,799 --> 00:21:04,320
call it the co-kernel constraint

602
00:21:05,840 --> 00:21:07,120
let's see what the right-hand side of

603
00:21:07,120 --> 00:21:08,720
this constraint is

604
00:21:08,720 --> 00:21:10,720
the first four columns must be zeros

605
00:21:10,720 --> 00:21:12,400
because the zeros stuck onto the left of

606
00:21:12,400 --> 00:21:13,280
t

607
00:21:13,280 --> 00:21:15,200
the two by two identity matrix in t

608
00:21:15,200 --> 00:21:17,520
selects columns 5 and 6 from k to be the

609
00:21:17,520 --> 00:21:20,000
right two columns of the result

610
00:21:20,000 --> 00:21:21,600
in general the product can be written in

611
00:21:21,600 --> 00:21:23,120
this form

612
00:21:23,120 --> 00:21:24,880
p is the parity of the gate which is one

613
00:21:24,880 --> 00:21:26,480
for an and gate or for any gate for

614
00:21:26,480 --> 00:21:28,080
which there is an odd number of inputs

615
00:21:28,080 --> 00:21:30,400
that make the output be true

616
00:21:30,400 --> 00:21:32,000
notice that the last row of k is

617
00:21:32,000 --> 00:21:34,320
asymmetrical this means that a and b

618
00:21:34,320 --> 00:21:35,760
depend on which output is supposed to

619
00:21:35,760 --> 00:21:37,919
return true ie on the point in permute

620
00:21:37,919 --> 00:21:39,760
bits which is what forces us to use

621
00:21:39,760 --> 00:21:42,760
dicing

622
00:21:45,200 --> 00:21:47,039
to sample the control matrix we first

623
00:21:47,039 --> 00:21:48,400
find a matrix that satisfies the

624
00:21:48,400 --> 00:21:50,880
co-kernel constraint by taking a linear

625
00:21:50,880 --> 00:21:52,799
combination of basis solutions

626
00:21:52,799 --> 00:21:54,480
this is then masked by picking a random

627
00:21:54,480 --> 00:21:56,480
control matrix our dollar sign that does

628
00:21:56,480 --> 00:21:58,240
not affect the co-kernel constraint it

629
00:21:58,240 --> 00:22:01,440
must be in the subspace s

630
00:22:01,679 --> 00:22:03,039
to see why this will satisfy the

631
00:22:03,039 --> 00:22:04,799
cochrane constraint multiply the

632
00:22:04,799 --> 00:22:06,080
resulting control matrix by the

633
00:22:06,080 --> 00:22:08,320
co-kernel on the left

634
00:22:08,320 --> 00:22:10,080
our dollar sign disappears and the

635
00:22:10,080 --> 00:22:11,440
others were chosen to give particular

636
00:22:11,440 --> 00:22:14,880
matrices so that after simplification

637
00:22:14,880 --> 00:22:17,600
kr will take the required value

638
00:22:17,600 --> 00:22:19,600
for privacy we also need our dollar sign

639
00:22:19,600 --> 00:22:21,440
to be random enough to hide both ra and

640
00:22:21,440 --> 00:22:24,440
rb

641
00:22:26,720 --> 00:22:28,640
we performed a computer search over all

642
00:22:28,640 --> 00:22:30,480
possible two-dimensional subspaces of

643
00:22:30,480 --> 00:22:32,799
2x4 matrices solving for the control

644
00:22:32,799 --> 00:22:35,679
matrices r dollar sign ra and rb to see

645
00:22:35,679 --> 00:22:36,880
if they work

646
00:22:36,880 --> 00:22:39,600
this is the solution we found

647
00:22:39,600 --> 00:22:41,440
in the middle row the control matrices

648
00:22:41,440 --> 00:22:43,520
are written using the basis each column

649
00:22:43,520 --> 00:22:45,200
of a four by two matrix corresponds to

650
00:22:45,200 --> 00:22:46,799
one of the basis elements

651
00:22:46,799 --> 00:22:48,480
while each row corresponds to an

652
00:22:48,480 --> 00:22:50,400
evaluation case

653
00:22:50,400 --> 00:22:52,240
the evaluator's marginal view comes from

654
00:22:52,240 --> 00:22:53,840
just a single row of a linear

655
00:22:53,840 --> 00:22:55,039
combination of these four by two

656
00:22:55,039 --> 00:22:56,159
matrices

657
00:22:56,159 --> 00:22:57,760
there is clearly enough randomization to

658
00:22:57,760 --> 00:23:00,159
make this uniform a row of r dollar sign

659
00:23:00,159 --> 00:23:03,039
is just two random bits

660
00:23:03,039 --> 00:23:04,640
the bottom row shows the corresponding

661
00:23:04,640 --> 00:23:06,880
full control matrices they satisfy the

662
00:23:06,880 --> 00:23:09,679
co-kernel constraints

663
00:23:09,679 --> 00:23:12,080
note the rp does not fit in the subspace

664
00:23:12,080 --> 00:23:13,760
this is allowed because the gate parity

665
00:23:13,760 --> 00:23:16,000
is public so for and gates the evaluator

666
00:23:16,000 --> 00:23:18,240
can just take the decoded control matrix

667
00:23:18,240 --> 00:23:23,039
and xor it with rp before using it

668
00:23:23,039 --> 00:23:25,600
to summarize there are a few key ideas

669
00:23:25,600 --> 00:23:28,480
we use to beat half gates

670
00:23:28,480 --> 00:23:30,480
the linear algebraic perspective is

671
00:23:30,480 --> 00:23:32,000
powerful because it lets us put the

672
00:23:32,000 --> 00:23:34,159
whole garbled gate into one linear

673
00:23:34,159 --> 00:23:36,640
equation

674
00:23:36,640 --> 00:23:38,720
more hashes allow for more redundancy in

675
00:23:38,720 --> 00:23:40,400
the hash matrix and so for better

676
00:23:40,400 --> 00:23:42,640
compression of the gate ciphertexts half

677
00:23:42,640 --> 00:23:44,720
gates were missing the third hash

678
00:23:44,720 --> 00:23:47,360
evaluation h of ax or b

679
00:23:47,360 --> 00:23:49,360
to take advantage of this redundancy we

680
00:23:49,360 --> 00:23:51,039
had to use slicing and split all the

681
00:23:51,039 --> 00:23:53,039
wire labels in half

682
00:23:53,039 --> 00:23:54,480
and we needed dicing to fix the

683
00:23:54,480 --> 00:23:56,400
technical issue of the control matrices

684
00:23:56,400 --> 00:23:57,520
which would otherwise have leaked the

685
00:23:57,520 --> 00:24:01,039
plaintext values to the evaluator

686
00:24:02,159 --> 00:24:03,440
there are several more results in our

687
00:24:03,440 --> 00:24:05,200
paper which unfortunately didn't fit

688
00:24:05,200 --> 00:24:06,720
into the talk

689
00:24:06,720 --> 00:24:08,080
if we expand the size of the control

690
00:24:08,080 --> 00:24:09,919
subspace to four dimensions we can hide

691
00:24:09,919 --> 00:24:12,080
the gate parity p as well keeping the

692
00:24:12,080 --> 00:24:13,440
entire truth table secret from the

693
00:24:13,440 --> 00:24:14,960
evaluator instead of just the point and

694
00:24:14,960 --> 00:24:16,880
permute bits

695
00:24:16,880 --> 00:24:18,480
we describe a weakening of tweakable

696
00:24:18,480 --> 00:24:20,000
circular correlation robust hash

697
00:24:20,000 --> 00:24:22,240
functions that we call randomized tccr

698
00:24:22,240 --> 00:24:24,640
hashes the new hash can be made almost

699
00:24:24,640 --> 00:24:26,960
as efficient as a ccr hash but it is

700
00:24:26,960 --> 00:24:29,360
still tweakable enough for garbling

701
00:24:29,360 --> 00:24:31,039
it is possible to save computation on

702
00:24:31,039 --> 00:24:33,039
some circuits by combining together hash

703
00:24:33,039 --> 00:24:35,200
evaluations for multiple gates

704
00:24:35,200 --> 00:24:36,240
normally the hash function is

705
00:24:36,240 --> 00:24:38,559
instantiated with aes which has twice as

706
00:24:38,559 --> 00:24:40,240
much output as we need so if there are

707
00:24:40,240 --> 00:24:42,159
two gates that share an input wire then

708
00:24:42,159 --> 00:24:45,440
one hash is enough for both

709
00:24:45,600 --> 00:24:46,960
we can reduce the size of the garbled

710
00:24:46,960 --> 00:24:48,720
control bits from eight bits down to

711
00:24:48,720 --> 00:24:50,640
three bits by using sliced garbling

712
00:24:50,640 --> 00:24:51,520
again

713
00:24:51,520 --> 00:24:53,039
the control bits have a structure that

714
00:24:53,039 --> 00:24:54,960
lets us gobble them without dicing so

715
00:24:54,960 --> 00:24:59,159
this does not lead to infinite recursion

