1
00:00:04,080 --> 00:00:05,920
then you're ready to go

2
00:00:05,920 --> 00:00:09,919
i'm good all right i see it here

3
00:00:14,000 --> 00:00:15,759
all right so i can i can start the

4
00:00:15,759 --> 00:00:16,720
session

5
00:00:16,720 --> 00:00:19,119
yes and you're ready

6
00:00:19,119 --> 00:00:20,400
good awesome

7
00:00:20,400 --> 00:00:23,439
uh welcome everyone uh back to crypto

8
00:00:23,439 --> 00:00:26,960
2021 this is the the last session before

9
00:00:26,960 --> 00:00:30,240
uh the membership meeting

10
00:00:30,240 --> 00:00:31,679
on thursday

11
00:00:31,679 --> 00:00:34,239
this session is on uh is on is on zero

12
00:00:34,239 --> 00:00:37,040
knowledge we have five talks

13
00:00:37,040 --> 00:00:38,719
i'm sure most of you know what the

14
00:00:38,719 --> 00:00:41,120
procedure is but just very quickly

15
00:00:41,120 --> 00:00:45,120
uh each paper gets five minutes like the

16
00:00:45,120 --> 00:00:47,039
the presenter gets uh five minutes to

17
00:00:47,039 --> 00:00:49,200
present we're going to wait for all the

18
00:00:49,200 --> 00:00:51,680
five talks to be over and then i'm going

19
00:00:51,680 --> 00:00:53,680
to open the floor for

20
00:00:53,680 --> 00:00:56,320
uh for q a

21
00:00:56,320 --> 00:00:59,199
all right so let's not delay any further

22
00:00:59,199 --> 00:01:00,960
i'm going to start with the first talk

23
00:01:00,960 --> 00:01:02,640
which is witness authentic

24
00:01:02,640 --> 00:01:05,438
authenticating nic case and applications

25
00:01:05,438 --> 00:01:08,080
uh this is by hanuman feng and shang

26
00:01:08,080 --> 00:01:09,040
tang

27
00:01:09,040 --> 00:01:10,320
han wen will

28
00:01:10,320 --> 00:01:13,320
present

29
00:01:17,040 --> 00:01:20,000
sex introduction

30
00:01:22,479 --> 00:01:25,280
hi everyone i'm going to introduce with

31
00:01:25,280 --> 00:01:27,280
his authenticating needs and its

32
00:01:27,280 --> 00:01:29,439
applications and however this is going

33
00:01:29,439 --> 00:01:31,840
to work with chiang khan

34
00:01:31,840 --> 00:01:34,479
in stanley approver can use his witness

35
00:01:34,479 --> 00:01:36,560
to create a proof and by reading this

36
00:01:36,560 --> 00:01:38,560
proof the referendum is nothing beyond

37
00:01:38,560 --> 00:01:40,479
the validity of the statement

38
00:01:40,479 --> 00:01:42,880
in this work our target is to introduce

39
00:01:42,880 --> 00:01:45,280
an identification functionality such

40
00:01:45,280 --> 00:01:48,560
that one can identify whether proof was

41
00:01:48,560 --> 00:01:52,479
generated using a specific weakness

42
00:01:52,479 --> 00:01:54,560
this identification already involves

43
00:01:54,560 --> 00:01:56,560
many interesting functionalities in

44
00:01:56,560 --> 00:01:59,119
privacy-preserving primitives a concrete

45
00:01:59,119 --> 00:02:00,560
example could be autonomous

46
00:02:00,560 --> 00:02:02,479
authentication with verifier local

47
00:02:02,479 --> 00:02:05,040
revocation in which one can check and

48
00:02:05,040 --> 00:02:08,000
reject all signatures identified by a

49
00:02:08,000 --> 00:02:10,800
revoked secret key this primitive is

50
00:02:10,800 --> 00:02:13,840
useful for remote attestation in trusted

51
00:02:13,840 --> 00:02:14,879
computing

52
00:02:14,879 --> 00:02:16,080
beyond that

53
00:02:16,080 --> 00:02:18,400
this identification is also useful for

54
00:02:18,400 --> 00:02:20,800
encryption and commitments to enable

55
00:02:20,800 --> 00:02:22,400
advanced features

56
00:02:22,400 --> 00:02:23,680
however

57
00:02:23,680 --> 00:02:25,840
they were they were independently

58
00:02:25,840 --> 00:02:28,400
studied without a unified view and for

59
00:02:28,400 --> 00:02:30,239
money we still don't know how to

60
00:02:30,239 --> 00:02:33,519
construct or improve them

61
00:02:33,519 --> 00:02:36,720
we notice nick is already and actually a

62
00:02:36,720 --> 00:02:38,319
source of privacy

63
00:02:38,319 --> 00:02:40,640
the elegant formulation enables easy

64
00:02:40,640 --> 00:02:43,920
design and analysis of its applications

65
00:02:43,920 --> 00:02:46,160
so we want to start innis with

66
00:02:46,160 --> 00:02:48,720
identification to find the source of

67
00:02:48,720 --> 00:02:52,160
privacy and identification such that we

68
00:02:52,160 --> 00:02:54,160
can design other primitives with

69
00:02:54,160 --> 00:02:56,480
identification in a modular and much

70
00:02:56,480 --> 00:03:00,080
simpler manner and possibly be able to

71
00:03:00,080 --> 00:03:02,879
lift them to better security and more

72
00:03:02,879 --> 00:03:05,680
efficient constructions easily

73
00:03:05,680 --> 00:03:08,000
formally we present a new primitive

74
00:03:08,000 --> 00:03:10,319
whitney's authenticating risk and

75
00:03:10,319 --> 00:03:13,040
studies model constructions and

76
00:03:13,040 --> 00:03:15,040
applications

77
00:03:15,040 --> 00:03:17,200
in modern there are many strategies to

78
00:03:17,200 --> 00:03:19,440
be addressed and we have to take special

79
00:03:19,440 --> 00:03:20,480
care of

80
00:03:20,480 --> 00:03:22,640
we first have to relax the

81
00:03:22,640 --> 00:03:25,360
identification to allow identifying a

82
00:03:25,360 --> 00:03:28,080
proof using a specific part of weakness

83
00:03:28,080 --> 00:03:30,400
which we call an identifier this is

84
00:03:30,400 --> 00:03:32,799
necessary for applications

85
00:03:32,799 --> 00:03:34,799
the most challenging part is to find the

86
00:03:34,799 --> 00:03:37,040
best possible privacy the standard

87
00:03:37,040 --> 00:03:38,480
terminology is

88
00:03:38,480 --> 00:03:39,760
the simulation

89
00:03:39,760 --> 00:03:42,159
simulation-based definition in which the

90
00:03:42,159 --> 00:03:45,040
adversary can adaptively specify the

91
00:03:45,040 --> 00:03:47,920
weakness and the statement and weakness

92
00:03:47,920 --> 00:03:49,680
after cncrs

93
00:03:49,680 --> 00:03:52,400
and the suspicion knows any extra

94
00:03:52,400 --> 00:03:54,799
information about the statement

95
00:03:54,799 --> 00:03:56,560
these are strong points making this

96
00:03:56,560 --> 00:03:59,439
really useful and powerful but however

97
00:03:59,439 --> 00:04:01,680
since the adversary of already knows the

98
00:04:01,680 --> 00:04:03,519
identity she can never reach his

99
00:04:03,519 --> 00:04:07,760
identification to break their knowledge

100
00:04:07,760 --> 00:04:10,000
to get around this tribune possibility

101
00:04:10,000 --> 00:04:12,400
we present a new definition introducing

102
00:04:12,400 --> 00:04:14,879
tropical knowledge in which the virtue

103
00:04:14,879 --> 00:04:17,519
can only specify a sample instead of

104
00:04:17,519 --> 00:04:20,560
concrete statement and witness for proof

105
00:04:20,560 --> 00:04:23,600
this sample is a randomized algorithm

106
00:04:23,600 --> 00:04:26,560
and outputs statement and witness such

107
00:04:26,560 --> 00:04:28,240
that the identifier is always

108
00:04:28,240 --> 00:04:30,080
unpredictable given all public

109
00:04:30,080 --> 00:04:31,360
information

110
00:04:31,360 --> 00:04:32,720
such that

111
00:04:32,720 --> 00:04:34,800
this definition will be compatible with

112
00:04:34,800 --> 00:04:38,080
identity with identification and is and

113
00:04:38,080 --> 00:04:40,639
it's easy to see all strong points are

114
00:04:40,639 --> 00:04:43,840
preserved as much as possible

115
00:04:43,840 --> 00:04:46,560
besides privacy we also need several

116
00:04:46,560 --> 00:04:48,800
augmented assemblies definitions to

117
00:04:48,800 --> 00:04:51,360
describe identification functionality in

118
00:04:51,360 --> 00:04:55,199
principles of malicious users

119
00:04:55,199 --> 00:04:58,000
regarding construction the basic idea is

120
00:04:58,000 --> 00:05:01,440
to and either identifiable and and uh

121
00:05:01,440 --> 00:05:04,080
identifiable tag to unleash the proof

122
00:05:04,080 --> 00:05:06,320
it's easy to see this tag should

123
00:05:06,320 --> 00:05:07,360
provide

124
00:05:07,360 --> 00:05:09,919
almost all properties of this

125
00:05:09,919 --> 00:05:12,400
identification functionality so we

126
00:05:12,400 --> 00:05:15,120
require identifiability unforgivability

127
00:05:15,120 --> 00:05:16,479
and uninfinites

128
00:05:16,479 --> 00:05:19,039
this tag should also be compatible with

129
00:05:19,039 --> 00:05:21,440
entropic zero knowledges so we require

130
00:05:21,440 --> 00:05:22,960
simulatability

131
00:05:22,960 --> 00:05:25,280
we notice all these properties are hard

132
00:05:25,280 --> 00:05:27,840
to be satisfied simultaneously

133
00:05:27,840 --> 00:05:30,400
particularly when we consider general

134
00:05:30,400 --> 00:05:32,000
cases

135
00:05:32,000 --> 00:05:33,440
we indeed give

136
00:05:33,440 --> 00:05:35,680
multiple constructions depending on the

137
00:05:35,680 --> 00:05:38,560
generality that is wizard's identifier

138
00:05:38,560 --> 00:05:41,199
can be long uniform or can be dependent

139
00:05:41,199 --> 00:05:42,880
of the crs

140
00:05:42,880 --> 00:05:45,840
for the most general cases we overcome

141
00:05:45,840 --> 00:05:48,240
these challenges by carefully designing

142
00:05:48,240 --> 00:05:51,039
a tag construction using a form of a

143
00:05:51,039 --> 00:05:53,360
deterministic publicly encryption with

144
00:05:53,360 --> 00:05:54,800
the help of needs

145
00:05:54,800 --> 00:05:56,880
given current techniques we can have a

146
00:05:56,880 --> 00:05:59,199
secure construction from standard

147
00:05:59,199 --> 00:06:00,560
assumptions

148
00:06:00,560 --> 00:06:03,600
now we have nisk with identification so

149
00:06:03,600 --> 00:06:05,680
we can have many other primitives with

150
00:06:05,680 --> 00:06:08,639
identification easily particularly we

151
00:06:08,639 --> 00:06:11,440
give we give a group signature with

152
00:06:11,440 --> 00:06:13,680
verifier local revocation this is the

153
00:06:13,680 --> 00:06:16,560
first to have auxiliary input security

154
00:06:16,560 --> 00:06:18,880
we also obtain plain task

155
00:06:18,880 --> 00:06:20,800
checkbook encryption is the first

156
00:06:20,800 --> 00:06:22,800
standard model construction for long

157
00:06:22,800 --> 00:06:24,639
uniform messages

158
00:06:24,639 --> 00:06:27,280
most interestingly we obtain naman

159
00:06:27,280 --> 00:06:29,840
bahash this is a primitive for instance

160
00:06:29,840 --> 00:06:32,080
in random oracles we obtain the first

161
00:06:32,080 --> 00:06:33,840
construction tolerating general

162
00:06:33,840 --> 00:06:35,600
organization general auxiliary

163
00:06:35,600 --> 00:06:38,880
information from standard assumptions

164
00:06:38,880 --> 00:06:42,560
that's my presentation thank you

165
00:06:44,800 --> 00:06:47,440
thanks henry

166
00:06:47,440 --> 00:06:49,919
we're going to go to the second talk

167
00:06:49,919 --> 00:06:52,400
this is towards a unified approach to

168
00:06:52,400 --> 00:06:54,560
black box constructions of zero

169
00:06:54,560 --> 00:06:56,000
knowledge proofs

170
00:06:56,000 --> 00:06:59,039
uh it's by xiao lang and omkan pandey

171
00:06:59,039 --> 00:07:02,400
and xiao will give the talk

172
00:07:02,400 --> 00:07:04,880
yeah uh thank mutu for the introduction

173
00:07:04,880 --> 00:07:06,560
so let me start

174
00:07:06,560 --> 00:07:08,960
so let's consider a one function f for

175
00:07:08,960 --> 00:07:11,280
this one function we can define a

176
00:07:11,280 --> 00:07:12,800
language that captures the rich

177
00:07:12,800 --> 00:07:15,120
membership of this one function now i'm

178
00:07:15,120 --> 00:07:17,120
going to ask a bunch of questions first

179
00:07:17,120 --> 00:07:19,199
can we have another proof for this

180
00:07:19,199 --> 00:07:20,400
language

181
00:07:20,400 --> 00:07:21,919
of course yes because we have general

182
00:07:21,919 --> 00:07:24,319
purpose decay for np and this language

183
00:07:24,319 --> 00:07:26,880
is in p so this problem is easy

184
00:07:26,880 --> 00:07:28,479
now we want to ask can we have black

185
00:07:28,479 --> 00:07:31,520
boxes are not approved for this language

186
00:07:31,520 --> 00:07:33,759
by blackbox we mean the construction

187
00:07:33,759 --> 00:07:35,840
makes only blackbox access to its

188
00:07:35,840 --> 00:07:37,120
building blocks

189
00:07:37,120 --> 00:07:38,479
don't be confused with blackbox

190
00:07:38,479 --> 00:07:40,240
simulation so

191
00:07:40,240 --> 00:07:42,880
so why do we want dropbox instructions

192
00:07:42,880 --> 00:07:45,199
because first it means it needs a

193
00:07:45,199 --> 00:07:47,599
modular design of the protocol and also

194
00:07:47,599 --> 00:07:49,919
it usually give us better give us better

195
00:07:49,919 --> 00:07:51,039
efficiency

196
00:07:51,039 --> 00:07:53,520
and uh actually starting from the work

197
00:07:53,520 --> 00:07:55,680
of goldberg we have a bunch of

198
00:07:55,680 --> 00:07:57,360
constructions that makes only black box

199
00:07:57,360 --> 00:07:59,039
access to the bin block

200
00:07:59,039 --> 00:08:01,520
so this problem is also easy

201
00:08:01,520 --> 00:08:04,160
now let us let us ask some questions

202
00:08:04,160 --> 00:08:06,560
more ambitious uh ambitious like can we

203
00:08:06,560 --> 00:08:09,199
have a construction that makes black box

204
00:08:09,199 --> 00:08:13,840
access also on this one function f

205
00:08:13,919 --> 00:08:15,360
we know that the

206
00:08:15,360 --> 00:08:18,319
general purpose zk can be based on black

207
00:08:18,319 --> 00:08:20,879
box access to one way function now this

208
00:08:20,879 --> 00:08:23,680
language is also a language based only

209
00:08:23,680 --> 00:08:25,759
function in a black box way that means

210
00:08:25,759 --> 00:08:28,960
if you give me the witness to test the

211
00:08:28,960 --> 00:08:31,199
range membership i only need black box

212
00:08:31,199 --> 00:08:33,120
access to the online function f as

213
00:08:33,120 --> 00:08:34,159
oracle

214
00:08:34,159 --> 00:08:37,279
so it will be awesome like if we can

215
00:08:37,279 --> 00:08:39,039
construct blackbox access to this

216
00:08:39,039 --> 00:08:41,200
language also based on black box access

217
00:08:41,200 --> 00:08:42,640
to the loan function

218
00:08:42,640 --> 00:08:44,240
but unfortunately

219
00:08:44,240 --> 00:08:47,120
this for this question the answer is no

220
00:08:47,120 --> 00:08:48,880
intuition is uh

221
00:08:48,880 --> 00:08:49,600
to

222
00:08:49,600 --> 00:08:51,279
the the general way to build as you're

223
00:08:51,279 --> 00:08:53,519
not proof is that we build it for some

224
00:08:53,519 --> 00:08:56,000
anti-complete language that is uh

225
00:08:56,000 --> 00:08:58,080
like zk friendly for example graphs

226
00:08:58,080 --> 00:09:02,399
recovering or homogeneity now to prove a

227
00:09:02,399 --> 00:09:04,480
problem at hand we need to do the curve

228
00:09:04,480 --> 00:09:06,399
reduction this cup reduction need the

229
00:09:06,399 --> 00:09:09,839
code of the of the line function f here

230
00:09:09,839 --> 00:09:12,959
and uh this was formally proved in uh

231
00:09:12,959 --> 00:09:15,360
rosy next work as under some noun

232
00:09:15,360 --> 00:09:17,680
assumption f is injective

233
00:09:17,680 --> 00:09:18,640
so

234
00:09:18,640 --> 00:09:20,240
this is actually very

235
00:09:20,240 --> 00:09:22,959
discouraging because uh it's so common

236
00:09:22,959 --> 00:09:26,000
that that we usually run zk proofs on

237
00:09:26,000 --> 00:09:28,720
some cryptographic language so

238
00:09:28,720 --> 00:09:31,279
if we make a number about access to the

239
00:09:31,279 --> 00:09:33,600
language is usually not that efficient

240
00:09:33,600 --> 00:09:34,720
for example

241
00:09:34,720 --> 00:09:36,480
think of the norin paradigm you will run

242
00:09:36,480 --> 00:09:39,920
gk on a pk scheme or a gmw competitor

243
00:09:39,920 --> 00:09:42,000
where we need to run the dk at least on

244
00:09:42,000 --> 00:09:43,760
criminal scheme

245
00:09:43,760 --> 00:09:46,240
yeah so this gives us to a question can

246
00:09:46,240 --> 00:09:47,680
we somehow by passwords like same

247
00:09:47,680 --> 00:09:50,080
possibility result

248
00:09:50,080 --> 00:09:52,080
let's take a closer look at joseph

249
00:09:52,080 --> 00:09:54,399
blank's impossibility result

250
00:09:54,399 --> 00:09:55,920
so

251
00:09:55,920 --> 00:09:57,760
we basically we want such a protocol

252
00:09:57,760 --> 00:10:00,080
where the prover have witnessed

253
00:10:00,080 --> 00:10:02,640
x which is a pre image and the common

254
00:10:02,640 --> 00:10:04,959
statement would be y which is the image

255
00:10:04,959 --> 00:10:06,320
and uh

256
00:10:06,320 --> 00:10:09,120
such a protocol such as zk protocol

257
00:10:09,120 --> 00:10:11,120
cannot exist because

258
00:10:11,120 --> 00:10:12,880
first since both parties only have a

259
00:10:12,880 --> 00:10:16,000
black box access to this f to test like

260
00:10:16,000 --> 00:10:18,800
to ver validate this x you have you have

261
00:10:18,800 --> 00:10:20,880
to like somehow ask the plural to send

262
00:10:20,880 --> 00:10:22,399
the x to the verifier there's no other

263
00:10:22,399 --> 00:10:25,120
way to verify it however

264
00:10:25,120 --> 00:10:28,000
if you assume the x it varies decay so

265
00:10:28,000 --> 00:10:30,560
this is the essence of this lower bound

266
00:10:30,560 --> 00:10:31,680
proof

267
00:10:31,680 --> 00:10:34,240
or putting i'll put it in another way

268
00:10:34,240 --> 00:10:36,240
there's no redundancy in the evaluation

269
00:10:36,240 --> 00:10:38,640
procedure y equals f x you're gonna

270
00:10:38,640 --> 00:10:41,920
review x totally or you cannot prove

271
00:10:41,920 --> 00:10:43,839
you cannot prove it this is a true

272
00:10:43,839 --> 00:10:45,120
statement

273
00:10:45,120 --> 00:10:47,040
so our idea is try to introduce some

274
00:10:47,040 --> 00:10:49,120
redundancy so

275
00:10:49,120 --> 00:10:51,920
in particular or more concretely we are

276
00:10:51,920 --> 00:10:53,279
considering this

277
00:10:53,279 --> 00:10:55,040
uh if you give me this one function f i

278
00:10:55,040 --> 00:10:58,160
build a new one function and uh now

279
00:10:58,160 --> 00:11:00,399
instead of focusing on the original

280
00:11:00,399 --> 00:11:02,560
original membership language we focus on

281
00:11:02,560 --> 00:11:04,640
the real membership of the capital f to

282
00:11:04,640 --> 00:11:05,519
the f

283
00:11:05,519 --> 00:11:07,760
if i try it will look like this

284
00:11:07,760 --> 00:11:11,360
you have this f has oracle access to the

285
00:11:11,360 --> 00:11:14,399
small f given to you and here you can

286
00:11:14,399 --> 00:11:16,480
perform some pre-processing on input and

287
00:11:16,480 --> 00:11:17,600
you can also perform some

288
00:11:17,600 --> 00:11:20,480
post-processing and here you can query

289
00:11:20,480 --> 00:11:22,640
archive several times so this gives us

290
00:11:22,640 --> 00:11:24,240
some this should give us some advantage

291
00:11:24,240 --> 00:11:25,120
right

292
00:11:25,120 --> 00:11:27,839
so some part of x now can provide you

293
00:11:27,839 --> 00:11:30,000
one is and the other part will probably

294
00:11:30,000 --> 00:11:31,519
verification

295
00:11:31,519 --> 00:11:33,920
and the event drive and the protocol now

296
00:11:33,920 --> 00:11:36,000
it looked like this but not yet because

297
00:11:36,000 --> 00:11:38,000
if i draw it in this way you also have

298
00:11:38,000 --> 00:11:40,480
blackbox access to the after left

299
00:11:40,480 --> 00:11:42,959
the the just like lower bound extent but

300
00:11:42,959 --> 00:11:44,880
we have one more advantage

301
00:11:44,880 --> 00:11:47,200
we only require black box access to the

302
00:11:47,200 --> 00:11:49,760
small f our protocol can depend on the

303
00:11:49,760 --> 00:11:51,600
capital at heart

304
00:11:51,600 --> 00:11:53,680
so in summary

305
00:11:53,680 --> 00:11:55,519
our current goal is a

306
00:11:55,519 --> 00:11:57,440
built from a small f a newer function

307
00:11:57,440 --> 00:11:59,279
capital f and

308
00:11:59,279 --> 00:12:01,760
have an oracle have a protocol that can

309
00:12:01,760 --> 00:12:04,399
depend on the capital f and we want zero

310
00:12:04,399 --> 00:12:06,800
knowledge proof for this new language

311
00:12:06,800 --> 00:12:08,720
actually we can ask something more not

312
00:12:08,720 --> 00:12:10,720
only the real membership but also the

313
00:12:10,720 --> 00:12:12,480
existing pre-image satisfies some

314
00:12:12,480 --> 00:12:15,120
non-crypto graphic package

315
00:12:15,120 --> 00:12:16,240
and

316
00:12:16,240 --> 00:12:18,240
we call this new primitive black box

317
00:12:18,240 --> 00:12:19,920
proof based on function similarly you

318
00:12:19,920 --> 00:12:22,959
can also define prg and hash function

319
00:12:22,959 --> 00:12:25,279
and our hope is uh whenever you want to

320
00:12:25,279 --> 00:12:28,160
use a one function together with a zero

321
00:12:28,160 --> 00:12:29,839
knot proof that makes black box access

322
00:12:29,839 --> 00:12:31,360
to one function

323
00:12:31,360 --> 00:12:33,600
now just like tell you

324
00:12:33,600 --> 00:12:35,600
just like tells you that you cannot do

325
00:12:35,600 --> 00:12:38,079
that and now just replace this one

326
00:12:38,079 --> 00:12:40,560
function f with our line function and

327
00:12:40,560 --> 00:12:43,040
then together with this joint zk

328
00:12:43,040 --> 00:12:45,040
it will do the job

329
00:12:45,040 --> 00:12:46,079
so

330
00:12:46,079 --> 00:12:48,720
our results are twofold first there is a

331
00:12:48,720 --> 00:12:50,959
disappointing without like a

332
00:12:50,959 --> 00:12:52,639
discouraging result like even for this

333
00:12:52,639 --> 00:12:54,160
relaxed version the

334
00:12:54,160 --> 00:12:55,680
pb version

335
00:12:55,680 --> 00:12:56,639
pb

336
00:12:56,639 --> 00:12:59,680
pb version is also impossible but uh we

337
00:12:59,680 --> 00:13:01,519
if we introduce some

338
00:13:01,519 --> 00:13:04,240
some more relaxation like uh

339
00:13:04,240 --> 00:13:06,480
we give the verifier some control over

340
00:13:06,480 --> 00:13:09,040
the input then we can get a rid of the

341
00:13:09,040 --> 00:13:10,639
lower bound suddenly it is one function

342
00:13:10,639 --> 00:13:12,320
priority clearance hash function as

343
00:13:12,320 --> 00:13:14,720
possible and uh i don't have time to

344
00:13:14,720 --> 00:13:16,240
talk about what that is give control

345
00:13:16,240 --> 00:13:18,160
over the input mean but if you're

346
00:13:18,160 --> 00:13:20,399
interested please check our 25 minutes

347
00:13:20,399 --> 00:13:22,160
talk and the full version table thank

348
00:13:22,160 --> 00:13:24,240
you

349
00:13:32,880 --> 00:13:35,600
thank you thanks xiao and uh we'll wait

350
00:13:35,600 --> 00:13:37,279
till the end of the

351
00:13:37,279 --> 00:13:39,519
session to you know thank all the uh the

352
00:13:39,519 --> 00:13:42,000
speakers so

353
00:13:42,000 --> 00:13:43,920
let's go to the uh

354
00:13:43,920 --> 00:13:46,000
to the next talk

355
00:13:46,000 --> 00:13:48,959
this is compressing proofs of k out of n

356
00:13:48,959 --> 00:13:51,440
partial knowledge this is by thomas

357
00:13:51,440 --> 00:13:55,120
athema ronald kramer and surge fair and

358
00:13:55,120 --> 00:13:59,000
thomas will give the talk

359
00:14:04,079 --> 00:14:06,560
thomas sorry yeah i'm just trying to

360
00:14:06,560 --> 00:14:08,590
share my screen

361
00:14:08,590 --> 00:14:11,840
[Music]

362
00:14:12,240 --> 00:14:16,120
can you see my screen now

363
00:14:17,920 --> 00:14:20,160
yes that looks great okay perfect thank

364
00:14:20,160 --> 00:14:22,160
you and i'll start uh okay thank you for

365
00:14:22,160 --> 00:14:23,839
the introduction this is indeed a joint

366
00:14:23,839 --> 00:14:26,000
work with ronald kramer and star sphere

367
00:14:26,000 --> 00:14:27,600
on compressing proofs of partial

368
00:14:27,600 --> 00:14:29,680
knowledge

369
00:14:29,680 --> 00:14:32,320
so the setting we are considering is a

370
00:14:32,320 --> 00:14:34,800
proofer that claims to know k secret

371
00:14:34,800 --> 00:14:36,959
solutions out of and public problem

372
00:14:36,959 --> 00:14:40,079
instances and it wishes to prove uh the

373
00:14:40,079 --> 00:14:42,240
veracity of this claim without the

374
00:14:42,240 --> 00:14:44,720
verifier learning which k out of n

375
00:14:44,720 --> 00:14:46,800
secrets the prover knows

376
00:14:46,800 --> 00:14:48,639
this uh problem the proof of partial

377
00:14:48,639 --> 00:14:50,000
knowledge problem was introduced at

378
00:14:50,000 --> 00:14:52,240
crypto94

379
00:14:52,240 --> 00:14:54,399
so some examples are for example that we

380
00:14:54,399 --> 00:14:55,120
have

381
00:14:55,120 --> 00:14:59,040
n public group elements h1 up to hm

382
00:14:59,040 --> 00:15:01,839
and the prover claims no k discrete

383
00:15:01,839 --> 00:15:05,360
logarithms with respect to 2g out of

384
00:15:05,360 --> 00:15:07,920
these n group elements so it does not

385
00:15:07,920 --> 00:15:10,079
know all of the discrete logarithms just

386
00:15:10,079 --> 00:15:13,519
k out of n of them similar examples are

387
00:15:13,519 --> 00:15:16,079
for a prover claiming to know k out of n

388
00:15:16,079 --> 00:15:19,680
commitment openings or kfn pre-images

389
00:15:19,680 --> 00:15:22,560
with respect to some hash function

390
00:15:22,560 --> 00:15:24,320
so proofs of parts knowledge have found

391
00:15:24,320 --> 00:15:26,720
numerous applications for example in

392
00:15:26,720 --> 00:15:28,800
threshold and ring signature schemes

393
00:15:28,800 --> 00:15:30,560
e-voting protocols and also in

394
00:15:30,560 --> 00:15:34,239
confidential transaction systems

395
00:15:34,560 --> 00:15:36,160
so

396
00:15:36,160 --> 00:15:38,560
there is an immediate

397
00:15:38,560 --> 00:15:40,000
well given recent advances in

398
00:15:40,000 --> 00:15:42,480
circumstance knowledge uh protocols for

399
00:15:42,480 --> 00:15:44,560
communication efficient circuit serial

400
00:15:44,560 --> 00:15:47,279
knowledge uh protocols uh there's an

401
00:15:47,279 --> 00:15:49,680
immediate solution for this problem and

402
00:15:49,680 --> 00:15:52,160
it is namely by capturing the relations

403
00:15:52,160 --> 00:15:53,839
that approval partial knowledge relation

404
00:15:53,839 --> 00:15:55,600
by an arithmetic circuit

405
00:15:55,600 --> 00:15:57,680
so for example if we wish to prove

406
00:15:57,680 --> 00:15:59,519
knowledge of one out of n discrete

407
00:15:59,519 --> 00:16:00,959
logarithm

408
00:16:00,959 --> 00:16:03,040
we can construct a circuit that

409
00:16:03,040 --> 00:16:05,360
evaluates to zero if and only if the

410
00:16:05,360 --> 00:16:07,920
input x is the discrete logarithm of one

411
00:16:07,920 --> 00:16:09,360
of the n

412
00:16:09,360 --> 00:16:11,519
group elements

413
00:16:11,519 --> 00:16:12,560
so

414
00:16:12,560 --> 00:16:14,399
if we do it like this so we capture the

415
00:16:14,399 --> 00:16:16,079
relation by an arithmetic circuit then

416
00:16:16,079 --> 00:16:17,759
we can apply a circuit share knowledge

417
00:16:17,759 --> 00:16:20,720
protocol for example snark start bullet

418
00:16:20,720 --> 00:16:22,399
proofs and then

419
00:16:22,399 --> 00:16:24,079
we immediately get a proof of parched

420
00:16:24,079 --> 00:16:26,320
knowledge

421
00:16:26,320 --> 00:16:28,320
this approach works for arbitrary k and

422
00:16:28,320 --> 00:16:31,120
m and also because of these sufficient

423
00:16:31,120 --> 00:16:32,800
circuits or knowledge particles we

424
00:16:32,800 --> 00:16:34,560
immediately get logarithmic or even

425
00:16:34,560 --> 00:16:38,319
constant communication complexity

426
00:16:38,399 --> 00:16:40,399
however there are some disadvantages to

427
00:16:40,399 --> 00:16:42,880
this indirect approach in which the

428
00:16:42,880 --> 00:16:45,120
relation is first captured by an

429
00:16:45,120 --> 00:16:47,199
arithmetic circuit

430
00:16:47,199 --> 00:16:49,519
this aromatic circuit can namely be very

431
00:16:49,519 --> 00:16:52,160
complicated and large

432
00:16:52,160 --> 00:16:54,560
so so even though we get this asymptotic

433
00:16:54,560 --> 00:16:56,800
efficiency there's a significant or

434
00:16:56,800 --> 00:16:58,399
there can be a significant practical

435
00:16:58,399 --> 00:17:00,720
overhead so for example if you want to

436
00:17:00,720 --> 00:17:03,839
capture a single group exponentiation

437
00:17:03,839 --> 00:17:06,000
for some groups

438
00:17:06,000 --> 00:17:08,640
highly optimized groups you already get

439
00:17:08,640 --> 00:17:11,039
an arithmetic circuit containing about

440
00:17:11,039 --> 00:17:13,679
2000 multiplication gates

441
00:17:13,679 --> 00:17:15,439
so this this approach has some

442
00:17:15,439 --> 00:17:18,319
disadvantages so our goal is to devise a

443
00:17:18,319 --> 00:17:20,319
direct approach avoiding this overhead

444
00:17:20,319 --> 00:17:22,720
of the large arithmetic circuits

445
00:17:22,720 --> 00:17:24,640
our protocols should work for arbitrary

446
00:17:24,640 --> 00:17:26,880
k and n and we aim for a logarithmic

447
00:17:26,880 --> 00:17:28,140
communication complexity

448
00:17:28,140 --> 00:17:30,000
[Music]

449
00:17:30,000 --> 00:17:32,320
so there have been prior works on this

450
00:17:32,320 --> 00:17:35,120
uh so in particular uh the the crucial

451
00:17:35,120 --> 00:17:37,840
partial knowledge from crypto94 uh they

452
00:17:37,840 --> 00:17:40,000
introduced a sigma protocol that works

453
00:17:40,000 --> 00:17:41,760
for arbitrary k and n

454
00:17:41,760 --> 00:17:43,440
however it has linear communication

455
00:17:43,440 --> 00:17:45,039
complexity

456
00:17:45,039 --> 00:17:47,520
so we want to improve uh on that

457
00:17:47,520 --> 00:17:50,320
uh in 2015 gold and gold wise introduced

458
00:17:50,320 --> 00:17:52,640
one out of many uh proofs they do have a

459
00:17:52,640 --> 00:17:55,200
logarithmic communication complexity but

460
00:17:55,200 --> 00:17:56,960
this approach is tailored to the

461
00:17:56,960 --> 00:17:59,760
specific case k equals one

462
00:17:59,760 --> 00:18:01,440
so this this approach does not

463
00:18:01,440 --> 00:18:05,120
generalize well to arbitrary gate

464
00:18:05,280 --> 00:18:07,360
so in addition so what we will be doing

465
00:18:07,360 --> 00:18:08,640
is building our proofs of partial

466
00:18:08,640 --> 00:18:10,480
knowledge on the sigma protocol of this

467
00:18:10,480 --> 00:18:12,880
crypto 94 uh proof of parse knowledge

468
00:18:12,880 --> 00:18:14,640
approach but we will also build on

469
00:18:14,640 --> 00:18:16,400
compressed sigma protocol theory

470
00:18:16,400 --> 00:18:18,480
introduced at crypto

471
00:18:18,480 --> 00:18:20,160
2020.

472
00:18:20,160 --> 00:18:22,320
um compressed sigma protocol theory

473
00:18:22,320 --> 00:18:23,919
basically they introduced a compression

474
00:18:23,919 --> 00:18:26,160
mechanism for basic sigma protocols and

475
00:18:26,160 --> 00:18:28,320
this compression mechanism allows the

476
00:18:28,320 --> 00:18:30,559
communication complexity to be reduced

477
00:18:30,559 --> 00:18:33,760
from linear down to logarithmic

478
00:18:33,760 --> 00:18:35,440
so a natural question given this

479
00:18:35,440 --> 00:18:37,520
compressed sigma protocol theory is can

480
00:18:37,520 --> 00:18:39,280
we compress the proof of partial the

481
00:18:39,280 --> 00:18:43,360
sigma protocol of cds cds94

482
00:18:43,360 --> 00:18:45,760
and in this work we answer this question

483
00:18:45,760 --> 00:18:48,080
in the affirmative by giving a

484
00:18:48,080 --> 00:18:51,280
compressed proof of partial knowledge

485
00:18:51,280 --> 00:18:54,240
we do have to make some adaptations so

486
00:18:54,240 --> 00:18:56,080
for one we need an awful twist on the

487
00:18:56,080 --> 00:18:57,840
compression mechanism of this compressed

488
00:18:57,840 --> 00:19:01,039
sigma protocol theory

489
00:19:01,039 --> 00:19:03,360
and also we need an awful approach to

490
00:19:03,360 --> 00:19:05,120
the proof of partial knowledge from cds

491
00:19:05,120 --> 00:19:09,120
94. so the cd s94 protocol

492
00:19:09,120 --> 00:19:10,640
was a sigma protocol with linear

493
00:19:10,640 --> 00:19:12,960
communication complexity but the sigma

494
00:19:12,960 --> 00:19:14,640
protocol introduced

495
00:19:14,640 --> 00:19:17,520
there was not compressible so it was not

496
00:19:17,520 --> 00:19:19,760
aminable to the compression mechanism of

497
00:19:19,760 --> 00:19:21,520
compressed sigma protocol theory so we

498
00:19:21,520 --> 00:19:24,799
had to make some changes over there

499
00:19:24,799 --> 00:19:26,640
and all together this is the main result

500
00:19:26,640 --> 00:19:28,720
that we get as a lyrics is the protocol

501
00:19:28,720 --> 00:19:30,080
for proving

502
00:19:30,080 --> 00:19:31,679
partial knowledge care of n partial

503
00:19:31,679 --> 00:19:33,520
knowledge and the communication

504
00:19:33,520 --> 00:19:35,840
complexity is

505
00:19:35,840 --> 00:19:38,640
logarithmic both in n and k and this

506
00:19:38,640 --> 00:19:41,200
approach works for arbitrary k and that

507
00:19:41,200 --> 00:19:42,559
and in the

508
00:19:42,559 --> 00:19:44,559
longer version of this presentation we

509
00:19:44,559 --> 00:19:46,640
also have a number of extensions

510
00:19:46,640 --> 00:19:48,640
to this main result

511
00:19:48,640 --> 00:19:52,480
and that was a presentation thank you

512
00:19:52,480 --> 00:19:55,120
thanks thomas

513
00:19:55,840 --> 00:19:57,039
um

514
00:19:57,039 --> 00:19:59,200
let's move to the uh

515
00:19:59,200 --> 00:20:00,960
next talk

516
00:20:00,960 --> 00:20:02,080
this is

517
00:20:02,080 --> 00:20:05,120
mac and cheese zero knowledge proofs for

518
00:20:05,120 --> 00:20:08,240
boolean and

519
00:20:08,240 --> 00:20:10,960
arithmetic circuits just one second this

520
00:20:10,960 --> 00:20:14,799
zoom kind of stole my window

521
00:20:17,440 --> 00:20:18,880
zero knowledge boost for arithmetic

522
00:20:18,880 --> 00:20:22,159
circuits with nested disjunctions work

523
00:20:22,159 --> 00:20:25,520
by uh alex malozyma carsten baum mark

524
00:20:25,520 --> 00:20:27,520
rosen and peter show

525
00:20:27,520 --> 00:20:28,400
and

526
00:20:28,400 --> 00:20:30,640
uh

527
00:20:30,799 --> 00:20:32,799
wait let me see who's giving the talk i

528
00:20:32,799 --> 00:20:35,799
apologize

529
00:20:36,480 --> 00:20:37,760
it's me peter

530
00:20:37,760 --> 00:20:40,000
peter i'm good peter is giving the duck

531
00:20:40,000 --> 00:20:42,000
i feel it do you see my slides

532
00:20:42,000 --> 00:20:43,120
yes i do

533
00:20:43,120 --> 00:20:45,200
yeah great okay thanks for the

534
00:20:45,200 --> 00:20:46,880
introduction uh yeah i'm going to talk

535
00:20:46,880 --> 00:20:48,799
about mac and cheese join with carson

536
00:20:48,799 --> 00:20:50,880
alex and mark

537
00:20:50,880 --> 00:20:52,960
so mac and cheese is a zero launch proof

538
00:20:52,960 --> 00:20:54,799
system for evaluating arithmetic

539
00:20:54,799 --> 00:20:56,640
circuits over finite fields

540
00:20:56,640 --> 00:20:58,159
uh based on the commit and proof

541
00:20:58,159 --> 00:20:59,280
paradigm

542
00:20:59,280 --> 00:21:01,120
and our main goal with designing this

543
00:21:01,120 --> 00:21:03,520
protocol is to obtain proofs with very

544
00:21:03,520 --> 00:21:05,280
low computational overhead for the

545
00:21:05,280 --> 00:21:06,480
prover

546
00:21:06,480 --> 00:21:09,039
so concretely we achieve something which

547
00:21:09,039 --> 00:21:11,120
for evaluating binary circuits gets you

548
00:21:11,120 --> 00:21:14,960
around 140 nanoseconds for each and gate

549
00:21:14,960 --> 00:21:16,880
this goes up to around one and a half

550
00:21:16,880 --> 00:21:18,880
microseconds for each multiplication

551
00:21:18,880 --> 00:21:20,960
over a larger field

552
00:21:20,960 --> 00:21:22,880
one drawback of that is that now the

553
00:21:22,880 --> 00:21:24,400
communication becomes linear in the

554
00:21:24,400 --> 00:21:25,679
circuit size

555
00:21:25,679 --> 00:21:27,600
but still looking at the gate cost we

556
00:21:27,600 --> 00:21:29,919
obtain a relatively small amount of one

557
00:21:29,919 --> 00:21:31,520
to three field elements for each

558
00:21:31,520 --> 00:21:33,200
multiplication

559
00:21:33,200 --> 00:21:34,720
on top of this one of the main features

560
00:21:34,720 --> 00:21:37,200
we get is an optimization for reducing

561
00:21:37,200 --> 00:21:39,360
communication for disjunction

562
00:21:39,360 --> 00:21:42,000
disjunctive statements in circuits

563
00:21:42,000 --> 00:21:43,440
and as well as that we can also support

564
00:21:43,440 --> 00:21:45,520
streaming and non-interactivity in the

565
00:21:45,520 --> 00:21:47,600
online phase

566
00:21:47,600 --> 00:21:49,120
okay so digging into the details a

567
00:21:49,120 --> 00:21:51,600
little bit uh the rough blueprint for

568
00:21:51,600 --> 00:21:54,159
our protocols uh follows roughly the

569
00:21:54,159 --> 00:21:55,919
kramer and dangard protocols with zero

570
00:21:55,919 --> 00:21:58,960
knowledge based on discrete log

571
00:21:58,960 --> 00:22:00,799
which uses homomorphic commitments from

572
00:22:00,799 --> 00:22:02,960
discrete log where the key difference

573
00:22:02,960 --> 00:22:05,520
here is that instead of discrete log we

574
00:22:05,520 --> 00:22:07,120
instantiate homomorphic commitments

575
00:22:07,120 --> 00:22:09,039
based on a tool from secure two-body

576
00:22:09,039 --> 00:22:11,039
computation called vector oblivious

577
00:22:11,039 --> 00:22:13,200
linear function evaluation

578
00:22:13,200 --> 00:22:15,039
this can be built recently very

579
00:22:15,039 --> 00:22:16,480
efficiently from the learning parity

580
00:22:16,480 --> 00:22:18,080
with noise assumption

581
00:22:18,080 --> 00:22:19,919
which leads to much faster computational

582
00:22:19,919 --> 00:22:21,760
types

583
00:22:21,760 --> 00:22:24,400
and given this the rough approach for

584
00:22:24,400 --> 00:22:26,240
proving satisfiability of an arithmetic

585
00:22:26,240 --> 00:22:28,559
circuit over fields is for the approver

586
00:22:28,559 --> 00:22:30,480
to commit to the witness using this

587
00:22:30,480 --> 00:22:32,480
homomorphic commitment scheme then

588
00:22:32,480 --> 00:22:34,000
additionally commit to all intermediate

589
00:22:34,000 --> 00:22:36,880
y values prove that these y values are

590
00:22:36,880 --> 00:22:38,880
consistent with each other and finally

591
00:22:38,880 --> 00:22:40,400
prove that the output wire is a

592
00:22:40,400 --> 00:22:42,159
commitment to zero

593
00:22:42,159 --> 00:22:43,760
so of course the main challenge here is

594
00:22:43,760 --> 00:22:46,480
proven consistency of the internal wires

595
00:22:46,480 --> 00:22:48,240
uh where the hardest part is to verify

596
00:22:48,240 --> 00:22:50,400
multiplication case

597
00:22:50,400 --> 00:22:52,640
so we consider two different methods of

598
00:22:52,640 --> 00:22:54,159
verifying multiplications in mac and

599
00:22:54,159 --> 00:22:55,440
cheese

600
00:22:55,440 --> 00:22:57,520
first one is a simple approach based on

601
00:22:57,520 --> 00:22:59,280
beaver multiplication

602
00:22:59,280 --> 00:23:01,760
with a slight tweak to multiplication

603
00:23:01,760 --> 00:23:03,039
triples

604
00:23:03,039 --> 00:23:05,360
this has a constant round complexity

605
00:23:05,360 --> 00:23:07,440
and communication of around three field

606
00:23:07,440 --> 00:23:09,520
elements for each multiplication as long

607
00:23:09,520 --> 00:23:11,440
as your field is large enough

608
00:23:11,440 --> 00:23:13,360
and we also show that this approach we

609
00:23:13,360 --> 00:23:15,200
can support streaming

610
00:23:15,200 --> 00:23:17,120
so the say the memory usage for the

611
00:23:17,120 --> 00:23:18,159
prover

612
00:23:18,159 --> 00:23:20,320
when evaluating this proof is just a

613
00:23:20,320 --> 00:23:21,919
constant factor larger than the memory

614
00:23:21,919 --> 00:23:23,760
usage for evaluating the circuit in the

615
00:23:23,760 --> 00:23:26,080
clear

616
00:23:26,159 --> 00:23:27,600
so our amortized multiplication

617
00:23:27,600 --> 00:23:29,120
verification method

618
00:23:29,120 --> 00:23:30,720
uses a different approach based upon

619
00:23:30,720 --> 00:23:33,440
this uh recursive verification protocol

620
00:23:33,440 --> 00:23:36,559
from crypto 2019 by bonnie ital

621
00:23:36,559 --> 00:23:38,159
this has a larger round complexity

622
00:23:38,159 --> 00:23:39,440
there's logarithmic in the number of

623
00:23:39,440 --> 00:23:42,080
multiplications being verified

624
00:23:42,080 --> 00:23:44,080
but reduces communication down to just

625
00:23:44,080 --> 00:23:45,520
one field element for each

626
00:23:45,520 --> 00:23:47,520
multiplication over any finite fields

627
00:23:47,520 --> 00:23:49,279
including f2

628
00:23:49,279 --> 00:23:50,480
and unfortunately because this is an

629
00:23:50,480 --> 00:23:52,880
amortized check it's inherently not so

630
00:23:52,880 --> 00:23:55,279
well suited to stream

631
00:23:55,279 --> 00:23:57,440
however with both of these approaches

632
00:23:57,440 --> 00:23:58,720
we can actually reduce the round

633
00:23:58,720 --> 00:24:00,880
complexity down to just one round by

634
00:24:00,880 --> 00:24:03,120
applying the fiat schmitt transformation

635
00:24:03,120 --> 00:24:05,200
and on top of that we show that

636
00:24:05,200 --> 00:24:06,559
even if the original number of rounds

637
00:24:06,559 --> 00:24:08,559
was quite large either logarithmic or

638
00:24:08,559 --> 00:24:10,559
for the streaming approach potentially

639
00:24:10,559 --> 00:24:12,480
linear in the depth of the circuit

640
00:24:12,480 --> 00:24:14,480
uh we could still soundly apply for

641
00:24:14,480 --> 00:24:16,480
chimera without any degradation in the

642
00:24:16,480 --> 00:24:19,480
soundness

643
00:24:19,600 --> 00:24:21,919
okay so next i want to talk about how we

644
00:24:21,919 --> 00:24:24,799
optimize disjunctions in mac and cheese

645
00:24:24,799 --> 00:24:28,000
but first what do i mean by disjunctions

646
00:24:28,000 --> 00:24:29,919
so it's just simply

647
00:24:29,919 --> 00:24:32,720
a sequence of sub-circuits here y1 up to

648
00:24:32,720 --> 00:24:36,159
ym where we want to prove satisfiability

649
00:24:36,159 --> 00:24:38,480
of this disjunction of these circuits uh

650
00:24:38,480 --> 00:24:41,120
so a big or gate basically

651
00:24:41,120 --> 00:24:42,880
now the classic approach here is to use

652
00:24:42,880 --> 00:24:44,240
an or proof

653
00:24:44,240 --> 00:24:46,159
so following the cds paradigm from

654
00:24:46,159 --> 00:24:49,039
crypto94 but if we apply this naively to

655
00:24:49,039 --> 00:24:51,679
mac and cheese uh then we get something

656
00:24:51,679 --> 00:24:53,440
where the communication cost will be

657
00:24:53,440 --> 00:24:54,799
proportional to the total number of

658
00:24:54,799 --> 00:24:57,679
gates in all of these sub-circuits

659
00:24:57,679 --> 00:25:00,640
and we want to see if we can do that so

660
00:25:00,640 --> 00:25:02,960
the goal is perhaps to communicate only

661
00:25:02,960 --> 00:25:04,880
information proportional to the longest

662
00:25:04,880 --> 00:25:07,120
branch out of all of these m different

663
00:25:07,120 --> 00:25:08,559
branches

664
00:25:08,559 --> 00:25:09,840
and this is something which was actually

665
00:25:09,840 --> 00:25:12,240
achieved uh using zero lodge from

666
00:25:12,240 --> 00:25:14,159
garbled circuits and paper by heath and

667
00:25:14,159 --> 00:25:16,720
kalashnikov from eurocrypt last year

668
00:25:16,720 --> 00:25:19,840
but we applied a similar technique to

669
00:25:19,840 --> 00:25:21,919
mac and cheese to commit and proof style

670
00:25:21,919 --> 00:25:24,159
protocols

671
00:25:24,159 --> 00:25:26,559
so main observation is that when looking

672
00:25:26,559 --> 00:25:28,480
at these protocols um so the two

673
00:25:28,480 --> 00:25:29,919
different methods of multiplication we

674
00:25:29,919 --> 00:25:30,720
have

675
00:25:30,720 --> 00:25:32,960
then the messages sent from the prover

676
00:25:32,960 --> 00:25:34,559
are always just going to be random field

677
00:25:34,559 --> 00:25:35,679
elements

678
00:25:35,679 --> 00:25:37,440
so given these random elements the

679
00:25:37,440 --> 00:25:39,120
verifier can actually tell whether these

680
00:25:39,120 --> 00:25:41,679
correspond to a proof for circuit c1 or

681
00:25:41,679 --> 00:25:43,279
for c2

682
00:25:43,279 --> 00:25:44,320
so

683
00:25:44,320 --> 00:25:46,080
we just simply have the prover only send

684
00:25:46,080 --> 00:25:47,760
the messages corresponding to the true

685
00:25:47,760 --> 00:25:48,720
branch

686
00:25:48,720 --> 00:25:50,880
then the verifier can reuse these same

687
00:25:50,880 --> 00:25:53,039
messages to actually evaluate both of

688
00:25:53,039 --> 00:25:55,760
the branches in the circuit

689
00:25:55,760 --> 00:25:57,360
now there becomes a slight problem here

690
00:25:57,360 --> 00:25:58,880
when you actually get to the end of the

691
00:25:58,880 --> 00:26:00,640
branches because then at some point you

692
00:26:00,640 --> 00:26:02,480
do have to verify something

693
00:26:02,480 --> 00:26:03,840
so the question is how do you verify

694
00:26:03,840 --> 00:26:06,080
this obliviously without revealing which

695
00:26:06,080 --> 00:26:08,799
branches is has been chosen and here we

696
00:26:08,799 --> 00:26:11,679
tag on a small cds style or proof but

697
00:26:11,679 --> 00:26:13,440
you check one out of the m branches in

698
00:26:13,440 --> 00:26:16,159
the oblivious one

699
00:26:16,400 --> 00:26:18,799
so quickly summarizing what we get here

700
00:26:18,799 --> 00:26:20,640
is that we can optimize disjunctions for

701
00:26:20,640 --> 00:26:22,400
a large class of commit and proof type

702
00:26:22,400 --> 00:26:24,480
protocols which can be formalized using

703
00:26:24,480 --> 00:26:26,799
linear interactive oracle proofs

704
00:26:26,799 --> 00:26:28,960
we can also extend this to threshold

705
00:26:28,960 --> 00:26:30,640
disjunction so

706
00:26:30,640 --> 00:26:32,559
k out of m clauses similar to the

707
00:26:32,559 --> 00:26:34,240
previous talk

708
00:26:34,240 --> 00:26:35,520
and

709
00:26:35,520 --> 00:26:36,960
we can also support nesting of

710
00:26:36,960 --> 00:26:39,520
disjunctions within disjunctions and do

711
00:26:39,520 --> 00:26:41,039
this recursively

712
00:26:41,039 --> 00:26:43,279
which actually reduces the linear in the

713
00:26:43,279 --> 00:26:45,279
number of branches overhead to just be

714
00:26:45,279 --> 00:26:47,919
logarithmic

715
00:26:48,159 --> 00:26:50,640
okay and before concluding uh i'll do a

716
00:26:50,640 --> 00:26:53,120
brief comparison with some related work

717
00:26:53,120 --> 00:26:55,120
so these are all protocols on the slide

718
00:26:55,120 --> 00:26:57,919
here um in a somewhat similar setting to

719
00:26:57,919 --> 00:26:59,600
mac and cheese focusing on improver

720
00:26:59,600 --> 00:27:02,880
efficiency sacrificing succeedness

721
00:27:02,880 --> 00:27:04,320
so the first one is this stack double

722
00:27:04,320 --> 00:27:06,960
circuits approach from last year

723
00:27:06,960 --> 00:27:09,760
which is the only protocol in the family

724
00:27:09,760 --> 00:27:11,360
which was previously shown to support

725
00:27:11,360 --> 00:27:13,840
disjunctions

726
00:27:13,840 --> 00:27:15,279
but the communication here is much

727
00:27:15,279 --> 00:27:17,120
higher and it only supports binary

728
00:27:17,120 --> 00:27:18,480
circuits

729
00:27:18,480 --> 00:27:20,960
the second row wolverine is a similar

730
00:27:20,960 --> 00:27:23,200
vector only based protocol like mac and

731
00:27:23,200 --> 00:27:24,480
cheese with slightly higher

732
00:27:24,480 --> 00:27:26,799
communication and using our techniques

733
00:27:26,799 --> 00:27:29,120
you can also apply disjunctions

734
00:27:29,120 --> 00:27:31,360
optimized distractions to this

735
00:27:31,360 --> 00:27:33,760
and the next two protocols at line point

736
00:27:33,760 --> 00:27:36,080
zk and quicksilver

737
00:27:36,080 --> 00:27:37,840
have better efficiency in terms of

738
00:27:37,840 --> 00:27:39,279
communication

739
00:27:39,279 --> 00:27:40,960
but as far as we know

740
00:27:40,960 --> 00:27:42,320
we don't see how to apply our

741
00:27:42,320 --> 00:27:44,080
disjunctive technique to these protocols

742
00:27:44,080 --> 00:27:47,600
without increasing the communication

743
00:27:47,679 --> 00:27:49,840
okay so to conclude uh mac and cheese

744
00:27:49,840 --> 00:27:51,919
has a practical zero noise proof system

745
00:27:51,919 --> 00:27:53,360
based on vector oblivious linear

746
00:27:53,360 --> 00:27:55,360
evaluation in the designated verify

747
00:27:55,360 --> 00:27:56,240
setting

748
00:27:56,240 --> 00:27:58,399
and it gets a scalable proof of runtimes

749
00:27:58,399 --> 00:28:00,720
with low memory costs and

750
00:28:00,720 --> 00:28:02,640
relatively small communication of as

751
00:28:02,640 --> 00:28:04,240
small as one field element for

752
00:28:04,240 --> 00:28:05,760
multiplication

753
00:28:05,760 --> 00:28:07,760
as well as this stacked disjunction

754
00:28:07,760 --> 00:28:10,559
optimization for reducing communication

755
00:28:10,559 --> 00:28:12,640
interestingly it's an open problem to

756
00:28:12,640 --> 00:28:15,039
apply uh the same kind of optimization

757
00:28:15,039 --> 00:28:16,799
to also reduce computation for the

758
00:28:16,799 --> 00:28:18,559
approver

759
00:28:18,559 --> 00:28:19,919
and that's all i wanted to say thanks

760
00:28:19,919 --> 00:28:22,399
for listening

761
00:28:23,360 --> 00:28:26,000
thanks peter

762
00:28:27,600 --> 00:28:29,120
let's go

763
00:28:29,120 --> 00:28:31,200
to the uh

764
00:28:31,200 --> 00:28:33,279
last talk of the session

765
00:28:33,279 --> 00:28:34,320
uh

766
00:28:34,320 --> 00:28:36,159
time and space efficient arguments from

767
00:28:36,159 --> 00:28:38,240
groups of unknown order this joint work

768
00:28:38,240 --> 00:28:40,480
by alexander block justin holmgren elon

769
00:28:40,480 --> 00:28:43,840
rosen ron rothblum and pratik sony and

770
00:28:43,840 --> 00:28:45,760
i'm assuming alexander is going to get

771
00:28:45,760 --> 00:28:49,600
the talk yes i am uh can you all hear me

772
00:28:49,600 --> 00:28:52,719
uh-oh can you hear me

773
00:28:52,799 --> 00:28:55,039
yes we can yes okay thank you sorry

774
00:28:55,039 --> 00:28:56,880
sorry sorry okay thank you very much for

775
00:28:56,880 --> 00:28:58,320
the introduction move through uh hi

776
00:28:58,320 --> 00:29:00,399
everybody i'm alex and i'm very happy to

777
00:29:00,399 --> 00:29:02,240
talk about this work uh time to space

778
00:29:02,240 --> 00:29:03,679
efficient arguments from groups of on

779
00:29:03,679 --> 00:29:05,919
order um again joint work with my

780
00:29:05,919 --> 00:29:08,320
amazing set of co-authors uh justin

781
00:29:08,320 --> 00:29:10,640
allen ron and pratik

782
00:29:10,640 --> 00:29:12,399
so the topic of today is zero knowledge

783
00:29:12,399 --> 00:29:14,720
arguments and you know zero knowledge

784
00:29:14,720 --> 00:29:16,240
arguments everyone here knows are

785
00:29:16,240 --> 00:29:18,240
cornerstone of modern cryptography they

786
00:29:18,240 --> 00:29:19,840
enable verification of mathematical

787
00:29:19,840 --> 00:29:21,520
statements without revealing any other

788
00:29:21,520 --> 00:29:23,200
information

789
00:29:23,200 --> 00:29:24,960
and they enable several exciting

790
00:29:24,960 --> 00:29:26,960
applications including delegation of

791
00:29:26,960 --> 00:29:28,480
computation to the cloud

792
00:29:28,480 --> 00:29:29,760
cryptocurrencies with interesting

793
00:29:29,760 --> 00:29:31,600
properties existingness and privacy and

794
00:29:31,600 --> 00:29:34,320
various other interesting objects

795
00:29:34,320 --> 00:29:36,559
but a key challenge in general in uh

796
00:29:36,559 --> 00:29:38,240
scaling general purpose zero knowledge

797
00:29:38,240 --> 00:29:40,000
is the high computational complexity of

798
00:29:40,000 --> 00:29:42,159
generating proof strings and this has

799
00:29:42,159 --> 00:29:42,960
been

800
00:29:42,960 --> 00:29:45,440
the focus of recent lines of research

801
00:29:45,440 --> 00:29:47,200
now for our work we're going to focus on

802
00:29:47,200 --> 00:29:48,960
zero knowledge arguments for time t

803
00:29:48,960 --> 00:29:50,960
space s ramp programs rather than

804
00:29:50,960 --> 00:29:52,399
arithmetic circuits

805
00:29:52,399 --> 00:29:54,240
and in terms of time complexity for

806
00:29:54,240 --> 00:29:55,600
these uh

807
00:29:55,600 --> 00:29:58,399
kinds of zero-knowledge proofs uh we're

808
00:29:58,399 --> 00:29:59,520
in great shape

809
00:29:59,520 --> 00:30:02,559
in theory we know how to construct uh

810
00:30:02,559 --> 00:30:03,840
such systems where the prover is

811
00:30:03,840 --> 00:30:05,600
asymptotically almost optimal in terms

812
00:30:05,600 --> 00:30:07,760
of time and in some settings one can

813
00:30:07,760 --> 00:30:10,159
also achieve linear time proofers

814
00:30:10,159 --> 00:30:11,919
and the situation is surprisingly quite

815
00:30:11,919 --> 00:30:13,120
similar in practice and there are a

816
00:30:13,120 --> 00:30:15,440
number of systems with concrete uh if

817
00:30:15,440 --> 00:30:17,200
concretely efficient provers that are

818
00:30:17,200 --> 00:30:19,120
being deployed

819
00:30:19,120 --> 00:30:21,279
and so the question here is are we done

820
00:30:21,279 --> 00:30:22,720
well actually no

821
00:30:22,720 --> 00:30:23,520
so

822
00:30:23,520 --> 00:30:25,600
although time wise were good memory

823
00:30:25,600 --> 00:30:28,159
overheads remain a major bottleneck

824
00:30:28,159 --> 00:30:30,320
in current systems as observed in

825
00:30:30,320 --> 00:30:32,320
some prior work

826
00:30:32,320 --> 00:30:34,559
so in particular in currently

827
00:30:34,559 --> 00:30:36,559
implemented solutions the prover ends up

828
00:30:36,559 --> 00:30:38,080
requiring space proportional to the

829
00:30:38,080 --> 00:30:39,919
running time of the underlying ram

830
00:30:39,919 --> 00:30:43,919
program rather than the underlying space

831
00:30:43,919 --> 00:30:45,760
so as a step towards addressing this key

832
00:30:45,760 --> 00:30:47,840
challenge in this work we focus on

833
00:30:47,840 --> 00:30:49,600
constructing zero knowledge arguments

834
00:30:49,600 --> 00:30:51,440
where the prover running time in space

835
00:30:51,440 --> 00:30:53,200
is as close as possible to the time and

836
00:30:53,200 --> 00:30:54,960
space of the underlying ram program

837
00:30:54,960 --> 00:30:56,480
where we allow for some polylike t

838
00:30:56,480 --> 00:30:58,399
overheads

839
00:30:58,399 --> 00:31:00,880
so can we construct such zero knowledge

840
00:31:00,880 --> 00:31:01,919
arguments

841
00:31:01,919 --> 00:31:04,559
well there are some prior work known but

842
00:31:04,559 --> 00:31:06,000
they have some rather undesirable

843
00:31:06,000 --> 00:31:07,360
caveats

844
00:31:07,360 --> 00:31:09,120
so some constructions use recursive

845
00:31:09,120 --> 00:31:10,880
composition which require knowledge

846
00:31:10,880 --> 00:31:13,519
assumptions which are poorly understood

847
00:31:13,519 --> 00:31:15,120
other constructions are designated

848
00:31:15,120 --> 00:31:17,039
verifier which means the verifier needs

849
00:31:17,039 --> 00:31:18,799
to keep some secret state which is

850
00:31:18,799 --> 00:31:20,960
undesirable again for applications

851
00:31:20,960 --> 00:31:22,559
now in a prior work with the same set of

852
00:31:22,559 --> 00:31:24,880
co-authors we overcome these limitations

853
00:31:24,880 --> 00:31:27,120
but the verifier here is linear time

854
00:31:27,120 --> 00:31:29,279
which is again undesirable

855
00:31:29,279 --> 00:31:30,880
well in this work we remove all these

856
00:31:30,880 --> 00:31:33,279
caveats at once to do so we need the

857
00:31:33,279 --> 00:31:35,120
hidden order assumption which is

858
00:31:35,120 --> 00:31:36,720
comparatively much simpler and better

859
00:31:36,720 --> 00:31:37,679
study

860
00:31:37,679 --> 00:31:40,159
our verifier is public coin

861
00:31:40,159 --> 00:31:43,200
and it is a poly logarithmic verifier

862
00:31:43,200 --> 00:31:44,640
and in fact such a result was not even

863
00:31:44,640 --> 00:31:45,600
known without the zero knowledge

864
00:31:45,600 --> 00:31:47,200
requirement

865
00:31:47,200 --> 00:31:49,120
so what is our main result

866
00:31:49,120 --> 00:31:51,679
well given hidden order groups we

867
00:31:51,679 --> 00:31:53,679
construct public coin zero knowledge

868
00:31:53,679 --> 00:31:56,240
arguments for languages accepted by time

869
00:31:56,240 --> 00:31:58,480
t space s ram programs

870
00:31:58,480 --> 00:32:00,399
where the prover time and space

871
00:32:00,399 --> 00:32:02,480
and the verifier time are optimal up to

872
00:32:02,480 --> 00:32:04,320
polylike t factors

873
00:32:04,320 --> 00:32:06,559
our protocol is also interactive has

874
00:32:06,559 --> 00:32:08,720
polylog t communication and logarithmic

875
00:32:08,720 --> 00:32:10,480
number of rounds

876
00:32:10,480 --> 00:32:12,480
now we can instantiate hidden or groups

877
00:32:12,480 --> 00:32:15,039
from many different assumptions one such

878
00:32:15,039 --> 00:32:17,440
assumption is factoring via rsa groups

879
00:32:17,440 --> 00:32:19,519
but this requires a trusted setup

880
00:32:19,519 --> 00:32:21,360
if you want transparent setup then we

881
00:32:21,360 --> 00:32:22,880
can instantiate the hidden order groups

882
00:32:22,880 --> 00:32:24,720
via class groups

883
00:32:24,720 --> 00:32:26,480
and of course we can make our public

884
00:32:26,480 --> 00:32:27,840
coin protocol not interactive by

885
00:32:27,840 --> 00:32:29,279
applying the fiat sheet from your

886
00:32:29,279 --> 00:32:30,880
heuristic

887
00:32:30,880 --> 00:32:32,880
okay so very briefly i'll talk about

888
00:32:32,880 --> 00:32:34,720
what our approach is well our approach

889
00:32:34,720 --> 00:32:36,159
builds off of a known and natural

890
00:32:36,159 --> 00:32:38,399
approach where we compose polynomial

891
00:32:38,399 --> 00:32:40,559
interactive oracle proofs or iops with

892
00:32:40,559 --> 00:32:42,720
polynomial commitments however we need

893
00:32:42,720 --> 00:32:44,080
to adapt this natural approach to be

894
00:32:44,080 --> 00:32:46,559
space efficient this is done via what we

895
00:32:46,559 --> 00:32:49,279
call the streaming model so a streamable

896
00:32:49,279 --> 00:32:51,360
iop allows approver to stream the

897
00:32:51,360 --> 00:32:53,039
description of its polynomials in small

898
00:32:53,039 --> 00:32:53,919
space

899
00:32:53,919 --> 00:32:55,919
and a streamable polynomial commitment

900
00:32:55,919 --> 00:32:57,760
requires a committer to run in small

901
00:32:57,760 --> 00:32:59,519
space when given streaming access to the

902
00:32:59,519 --> 00:33:01,120
guts of the polynomial so the end of the

903
00:33:01,120 --> 00:33:02,159
description

904
00:33:02,159 --> 00:33:03,600
and in this work we construct such a

905
00:33:03,600 --> 00:33:05,760
polynomial commitment scheme

906
00:33:05,760 --> 00:33:07,679
more specifically we build off a recent

907
00:33:07,679 --> 00:33:11,120
polynomial convincing due to boons

908
00:33:11,679 --> 00:33:13,360
in fact we find a significant bug in

909
00:33:13,360 --> 00:33:14,960
their security proof

910
00:33:14,960 --> 00:33:16,559
and i want to just mention that the

911
00:33:16,559 --> 00:33:18,399
authors also informed us independently

912
00:33:18,399 --> 00:33:20,559
that they found this bug

913
00:33:20,559 --> 00:33:22,159
now although we don't know how to fix

914
00:33:22,159 --> 00:33:24,320
this bug we give a non-trivial variant

915
00:33:24,320 --> 00:33:26,480
of the protocol where to prove security

916
00:33:26,480 --> 00:33:28,080
we actually leverage ideas from the

917
00:33:28,080 --> 00:33:29,919
theory of integer lattices

918
00:33:29,919 --> 00:33:32,559
and as an added benefit of our protocol

919
00:33:32,559 --> 00:33:34,159
it is based on significantly weaker

920
00:33:34,159 --> 00:33:36,799
assumptions than wounds at all scheme

921
00:33:36,799 --> 00:33:38,480
we additionally show how to implement

922
00:33:38,480 --> 00:33:40,080
this committer of ours in small space

923
00:33:40,080 --> 00:33:41,279
given streaming access to the

924
00:33:41,279 --> 00:33:43,120
description of the polynomial

925
00:33:43,120 --> 00:33:44,720
and finally we develop a new proof of

926
00:33:44,720 --> 00:33:46,640
exponentiation protocol that is

927
00:33:46,640 --> 00:33:47,840
essential to getting our poly

928
00:33:47,840 --> 00:33:50,000
logarithmic verifier for our for our

929
00:33:50,000 --> 00:33:51,519
argument scheme

930
00:33:51,519 --> 00:33:53,679
now i want to emphasize that

931
00:33:53,679 --> 00:33:54,720
our

932
00:33:54,720 --> 00:33:56,000
that our proof of exponentiation

933
00:33:56,000 --> 00:33:58,399
protocol is statistically sound and

934
00:33:58,399 --> 00:34:00,480
works for arbitrary groups whereas

935
00:34:00,480 --> 00:34:01,760
previous work achieved only

936
00:34:01,760 --> 00:34:03,519
computational standards under novel

937
00:34:03,519 --> 00:34:05,360
graphic assumptions

938
00:34:05,360 --> 00:34:07,120
now finally we use off-the-shelf

939
00:34:07,120 --> 00:34:09,359
streamable iops and compose it with our

940
00:34:09,359 --> 00:34:11,040
shrinkable polynomial commitment scheme

941
00:34:11,040 --> 00:34:12,800
to obtain our time and space efficient

942
00:34:12,800 --> 00:34:14,719
zero-knowledge arguments

943
00:34:14,719 --> 00:34:16,000
and that's all i have to say thank you

944
00:34:16,000 --> 00:34:18,399
very much

945
00:34:19,359 --> 00:34:22,560
thanks alexander and that concludes the

946
00:34:22,560 --> 00:34:24,639
presentation phase of this of this

947
00:34:24,639 --> 00:34:25,679
session

948
00:34:25,679 --> 00:34:28,399
let's all uh clap

949
00:34:28,399 --> 00:34:31,040
virtually as we've been gotten used to

950
00:34:31,040 --> 00:34:33,040
doing this past year

951
00:34:33,040 --> 00:34:36,159
um i'm happy to

952
00:34:36,159 --> 00:34:38,399
switch my video on and and clap and

953
00:34:38,399 --> 00:34:40,480
thank all the authors of this

954
00:34:40,480 --> 00:34:42,480
and presenters of this

955
00:34:42,480 --> 00:34:45,679
of the session and open the floor for uh

956
00:34:45,679 --> 00:34:46,960
for questions

957
00:34:46,960 --> 00:34:49,918
i am on the zoolip chat and i don't see

958
00:34:49,918 --> 00:34:52,719
any questions so

959
00:34:53,520 --> 00:34:55,918
if anyone has a question i mean i think

960
00:34:55,918 --> 00:34:57,040
you can just

961
00:34:57,040 --> 00:34:59,680
unmute and

962
00:35:00,480 --> 00:35:02,320
and talk if there is contention i can

963
00:35:02,320 --> 00:35:04,800
resolve

964
00:35:06,800 --> 00:35:07,920
um

965
00:35:07,920 --> 00:35:11,440
i guess while uh people are

966
00:35:11,440 --> 00:35:14,079
formulating their questions yes go ahead

967
00:35:14,079 --> 00:35:16,079
this is for peter uh i was wondering if

968
00:35:16,079 --> 00:35:18,240
your disjunction trick uh affected

969
00:35:18,240 --> 00:35:20,000
soundness in any way

970
00:35:20,000 --> 00:35:22,160
just

971
00:35:22,320 --> 00:35:24,800
uh there's not a big loss in soundness

972
00:35:24,800 --> 00:35:25,760
maybe

973
00:35:25,760 --> 00:35:27,200
affected proportional to the number of

974
00:35:27,200 --> 00:35:28,960
dysjunctions

975
00:35:28,960 --> 00:35:31,839
i see thank you

976
00:35:34,720 --> 00:35:37,839
any other question

977
00:35:40,240 --> 00:35:42,320
maybe i have one for ah there's a

978
00:35:42,320 --> 00:35:44,000
question here question for thomas by

979
00:35:44,000 --> 00:35:46,160
ivan viscanti can your theorem be

980
00:35:46,160 --> 00:35:49,119
generalized beyond discrete blocker

981
00:35:49,119 --> 00:35:51,119
ah that's a good question so

982
00:35:51,119 --> 00:35:51,780
um

983
00:35:51,780 --> 00:35:52,880
[Music]

984
00:35:52,880 --> 00:35:55,359
so for example uh compressed sigma

985
00:35:55,359 --> 00:35:57,440
protocol theory we also presented the

986
00:35:57,440 --> 00:36:00,160
lattice-based version at this conference

987
00:36:00,160 --> 00:36:03,200
uh so in principle it should for example

988
00:36:03,200 --> 00:36:05,119
also be able you should also be able to

989
00:36:05,119 --> 00:36:06,640
instantiate it from others assumptions

990
00:36:06,640 --> 00:36:09,680
but you do encounter a number of

991
00:36:09,680 --> 00:36:12,000
difficulties that you have to overcome

992
00:36:12,000 --> 00:36:14,000
we haven't worked out the details but i

993
00:36:14,000 --> 00:36:15,599
believe

994
00:36:15,599 --> 00:36:17,839
i don't see any objections for for that

995
00:36:17,839 --> 00:36:20,240
approach

996
00:36:21,760 --> 00:36:23,920
good uh there's a question for peter

997
00:36:23,920 --> 00:36:25,280
again from

998
00:36:25,280 --> 00:36:27,280
zulip by

999
00:36:27,280 --> 00:36:29,599
ashrajit ghoshu

1000
00:36:29,599 --> 00:36:31,280
let me repeat the question here

1001
00:36:31,280 --> 00:36:32,880
you mentioned there's no degradation of

1002
00:36:32,880 --> 00:36:34,160
soundness

1003
00:36:34,160 --> 00:36:35,920
with respect to number of rounds for the

1004
00:36:35,920 --> 00:36:38,800
fiat shamir transformed version

1005
00:36:38,800 --> 00:36:40,880
did you analyze the concrete round by

1006
00:36:40,880 --> 00:36:43,280
round soundness of this uh of this

1007
00:36:43,280 --> 00:36:44,880
protocol

1008
00:36:44,880 --> 00:36:47,280
uh yes that's right so we

1009
00:36:47,280 --> 00:36:49,040
yeah we looked at the the round by ryan

1010
00:36:49,040 --> 00:36:50,880
samus of the underlying protocols and

1011
00:36:50,880 --> 00:36:52,960
then combined that with the fiasco mere

1012
00:36:52,960 --> 00:36:54,800
transform similar to how that was done

1013
00:36:54,800 --> 00:36:56,400
in previous works

1014
00:36:56,400 --> 00:36:57,920
okay and that's why you don't lose the

1015
00:36:57,920 --> 00:37:01,040
exponential loss for rounds yeah exactly

1016
00:37:01,040 --> 00:37:03,279
okay

1017
00:37:05,680 --> 00:37:06,880
all right i have a question for

1018
00:37:06,880 --> 00:37:10,880
alexander um in your complexity um you

1019
00:37:10,880 --> 00:37:13,520
know t polylog t and s polylog t

1020
00:37:13,520 --> 00:37:15,520
can i if i gave you a statistical or

1021
00:37:15,520 --> 00:37:17,839
like like a security parameter like

1022
00:37:17,839 --> 00:37:18,800
kappa

1023
00:37:18,800 --> 00:37:20,079
could i assume that there'd be something

1024
00:37:20,079 --> 00:37:22,000
polynomial in kappa in all of these

1025
00:37:22,000 --> 00:37:22,960
terms

1026
00:37:22,960 --> 00:37:25,119
so yeah actually underlying our protocol

1027
00:37:25,119 --> 00:37:27,440
is a statistical security parameter so

1028
00:37:27,440 --> 00:37:28,800
in the polynomial commitment scheme the

1029
00:37:28,800 --> 00:37:30,720
basic idea is to

1030
00:37:30,720 --> 00:37:32,800
take bunzodal scheme and instead of

1031
00:37:32,800 --> 00:37:34,800
giving like random exponent challenges

1032
00:37:34,800 --> 00:37:36,960
you do like a subset

1033
00:37:36,960 --> 00:37:38,800
product challenge so you do binary

1034
00:37:38,800 --> 00:37:40,079
challenges where it's a statistical

1035
00:37:40,079 --> 00:37:43,760
security parameter so there's um

1036
00:37:43,760 --> 00:37:45,359
there's a statistic there's a

1037
00:37:45,359 --> 00:37:47,119
statistical security parameter like a

1038
00:37:47,119 --> 00:37:49,359
poly like kappa floating around

1039
00:37:49,359 --> 00:37:51,119
everywhere yeah

1040
00:37:51,119 --> 00:37:52,320
um

1041
00:37:52,320 --> 00:37:55,119
maybe another question to alexander

1042
00:37:55,119 --> 00:37:57,280
prior work in your

1043
00:37:57,280 --> 00:37:58,960
in your line of work with respect to

1044
00:37:58,960 --> 00:38:01,280
space what do we know from minimal

1045
00:38:01,280 --> 00:38:03,040
assumptions like collision risk and hash

1046
00:38:03,040 --> 00:38:04,880
functions uh my understanding is that by

1047
00:38:04,880 --> 00:38:06,560
using recursive composition this is

1048
00:38:06,560 --> 00:38:08,480
achievable right

1049
00:38:08,480 --> 00:38:09,280
yeah

1050
00:38:09,280 --> 00:38:11,119
so i think the

1051
00:38:11,119 --> 00:38:14,320
because that's valiant i think um is i

1052
00:38:14,320 --> 00:38:15,680
think it's a

1053
00:38:15,680 --> 00:38:19,200
cr crhf with like merkle tree something

1054
00:38:19,200 --> 00:38:20,240
um

1055
00:38:20,240 --> 00:38:23,200
so the issue with that is like in our

1056
00:38:23,200 --> 00:38:24,320
model

1057
00:38:24,320 --> 00:38:25,760
um

1058
00:38:25,760 --> 00:38:27,520
you kind of need to be able to so the

1059
00:38:27,520 --> 00:38:30,160
way i think about it right is um

1060
00:38:30,160 --> 00:38:31,760
so if in a merkle tree right you need

1061
00:38:31,760 --> 00:38:33,280
the whole pcp

1062
00:38:33,280 --> 00:38:34,720
string you need to be able to write down

1063
00:38:34,720 --> 00:38:36,480
the whole pcp string

1064
00:38:36,480 --> 00:38:37,440
um

1065
00:38:37,440 --> 00:38:38,880
which we don't know how to do is like a

1066
00:38:38,880 --> 00:38:41,200
streaming way and in our model you just

1067
00:38:41,200 --> 00:38:43,280
need to be able to like compute any

1068
00:38:43,280 --> 00:38:45,599
point of the pcp string in like small

1069
00:38:45,599 --> 00:38:48,320
space right so with like a polynomial

1070
00:38:48,320 --> 00:38:50,640
right if you if i give you a description

1071
00:38:50,640 --> 00:38:52,160
so if it's a multilinear function if i

1072
00:38:52,160 --> 00:38:53,359
give you the

1073
00:38:53,359 --> 00:38:55,839
the evaluations on the boolean hypercube

1074
00:38:55,839 --> 00:38:58,079
i can compute the function everywhere

1075
00:38:58,079 --> 00:39:00,480
right and so it's enough to just have

1076
00:39:00,480 --> 00:39:01,760
that to be able to compute the function

1077
00:39:01,760 --> 00:39:03,680
everywhere but i i believe that like

1078
00:39:03,680 --> 00:39:05,839
valence method you need the whole pcp

1079
00:39:05,839 --> 00:39:08,240
string and generate the whole thing like

1080
00:39:08,240 --> 00:39:10,000
in small space as a stream which like we

1081
00:39:10,000 --> 00:39:12,880
really don't know how to do

1082
00:39:13,119 --> 00:39:14,800
if that makes sense sorry i don't know

1083
00:39:14,800 --> 00:39:16,720
if i answer your question yeah so i mean

1084
00:39:16,720 --> 00:39:18,400
just want to know like sort of yes or no

1085
00:39:18,400 --> 00:39:20,480
like can we apply like recursive

1086
00:39:20,480 --> 00:39:22,320
composition with like known techniques

1087
00:39:22,320 --> 00:39:24,480
based on like you know symmetric key

1088
00:39:24,480 --> 00:39:26,640
primitives and get something that has

1089
00:39:26,640 --> 00:39:28,960
similar complexity with respect to space

1090
00:39:28,960 --> 00:39:31,040
is that a is there a yes or no here um

1091
00:39:31,040 --> 00:39:32,640
oh yeah so like the prior work i think

1092
00:39:32,640 --> 00:39:33,920
it's uh

1093
00:39:33,920 --> 00:39:35,599
bedonsky

1094
00:39:35,599 --> 00:39:37,359
i think does this they they use uh they

1095
00:39:37,359 --> 00:39:40,000
use fhe and they get they they get

1096
00:39:40,000 --> 00:39:42,000
similar space complexity the only like i

1097
00:39:42,000 --> 00:39:43,920
think all these prior works get polylog

1098
00:39:43,920 --> 00:39:45,839
overhead the only work that doesn't is

1099
00:39:45,839 --> 00:39:48,400
uh holmgren and rothburn's work where

1100
00:39:48,400 --> 00:39:50,079
they get like an additive space overhead

1101
00:39:50,079 --> 00:39:51,119
but they're doing something very

1102
00:39:51,119 --> 00:39:52,240
different

1103
00:39:52,240 --> 00:39:53,119
okay

1104
00:39:53,119 --> 00:39:54,720
all right thanks

1105
00:39:54,720 --> 00:39:57,520
um question by vinod to peter what's the

1106
00:39:57,520 --> 00:39:59,440
communication complexity of mac and

1107
00:39:59,440 --> 00:40:01,839
cheese if you want like 2 to the minus

1108
00:40:01,839 --> 00:40:04,720
lambda soundness

1109
00:40:06,079 --> 00:40:09,200
i don't know what i i uc stands for

1110
00:40:09,200 --> 00:40:10,720
so

1111
00:40:10,720 --> 00:40:11,920
uh

1112
00:40:11,920 --> 00:40:13,839
is there a specific protocol he's

1113
00:40:13,839 --> 00:40:16,640
interested okay so that uh

1114
00:40:16,640 --> 00:40:19,839
like i think uh you know the first one

1115
00:40:19,839 --> 00:40:22,800
uh yeah it's lambda times c times log f

1116
00:40:22,800 --> 00:40:24,720
right like this that's what we know it's

1117
00:40:24,720 --> 00:40:26,160
asking

1118
00:40:26,160 --> 00:40:28,000
lambda times

1119
00:40:28,000 --> 00:40:29,359
yeah so

1120
00:40:29,359 --> 00:40:31,680
any of the protocols right i mean uh you

1121
00:40:31,680 --> 00:40:33,520
know if instant right you're going to

1122
00:40:33,520 --> 00:40:35,119
have a base protocol and you're going to

1123
00:40:35,119 --> 00:40:38,000
repeat it uh to get two to the minus to

1124
00:40:38,000 --> 00:40:40,720
reduce soundness error rate uh uh no

1125
00:40:40,720 --> 00:40:42,960
there's no repetition actually

1126
00:40:42,960 --> 00:40:43,760
um

1127
00:40:43,760 --> 00:40:46,240
so if the if the field is small then

1128
00:40:46,240 --> 00:40:47,839
sometimes we may have to lift to an

1129
00:40:47,839 --> 00:40:49,440
extension field

1130
00:40:49,440 --> 00:40:53,200
right okay so parts of the verification

1131
00:40:53,200 --> 00:40:55,520
assuming that the field is uh

1132
00:40:55,520 --> 00:40:57,359
huge like two to the lambda size you

1133
00:40:57,359 --> 00:40:59,280
don't have to repeat that's the point

1134
00:40:59,280 --> 00:41:01,680
yes yeah but even for small field we

1135
00:41:01,680 --> 00:41:03,680
don't have to repeat um

1136
00:41:03,680 --> 00:41:05,440
we just have to do some kind of

1137
00:41:05,440 --> 00:41:07,200
repetition or lifting for small

1138
00:41:07,200 --> 00:41:09,440
components of the verification

1139
00:41:09,440 --> 00:41:10,960
we should imagine that there is always

1140
00:41:10,960 --> 00:41:13,280
like a log f term which is of the size

1141
00:41:13,280 --> 00:41:17,280
lambda great sounds good thank you

1142
00:41:17,359 --> 00:41:19,680
okay

1143
00:41:19,839 --> 00:41:21,760
um any more

1144
00:41:21,760 --> 00:41:24,319
questions

1145
00:41:24,800 --> 00:41:27,440
maybe uh let me ask uh

1146
00:41:27,440 --> 00:41:29,280
thomas and maybe this question i'm not

1147
00:41:29,280 --> 00:41:30,800
quite sure if this is even a good

1148
00:41:30,800 --> 00:41:32,560
question but maybe it's also a comment

1149
00:41:32,560 --> 00:41:35,760
like it works so this compressed uh

1150
00:41:35,760 --> 00:41:38,160
chaotic improves does it work for any

1151
00:41:38,160 --> 00:41:40,640
sigma protocol for example can i combine

1152
00:41:40,640 --> 00:41:43,520
it with like an mpc in the head based on

1153
00:41:43,520 --> 00:41:45,040
like i cause

1154
00:41:45,040 --> 00:41:47,200
can i use

1155
00:41:47,200 --> 00:41:49,200
this technique to compress those kind of

1156
00:41:49,200 --> 00:41:50,319
proofs

1157
00:41:50,319 --> 00:41:54,000
okay so cds 94 uh was was very very

1158
00:41:54,000 --> 00:41:55,440
general result and that worked for a

1159
00:41:55,440 --> 00:41:57,200
very broad class of signal particles

1160
00:41:57,200 --> 00:41:58,640
indeed

1161
00:41:58,640 --> 00:42:01,920
so our results or our protocols do have

1162
00:42:01,920 --> 00:42:03,200
some

1163
00:42:03,200 --> 00:42:05,359
some some additional requirements so for

1164
00:42:05,359 --> 00:42:07,680
example uh that's also why we need to

1165
00:42:07,680 --> 00:42:10,319
modify the signal protocols of the cds

1166
00:42:10,319 --> 00:42:13,920
94 to to get a new sigma protocol that

1167
00:42:13,920 --> 00:42:14,839
is

1168
00:42:14,839 --> 00:42:17,599
compressible um so there are some some

1169
00:42:17,599 --> 00:42:19,280
some additional requirements that we

1170
00:42:19,280 --> 00:42:21,520
need we need for example we need to have

1171
00:42:21,520 --> 00:42:23,359
a factor commitment scheme for which we

1172
00:42:23,359 --> 00:42:25,599
can uh

1173
00:42:25,599 --> 00:42:27,839
prove knowledge of the of the the

1174
00:42:27,839 --> 00:42:30,640
commitment factor commitment opening

1175
00:42:30,640 --> 00:42:32,400
any algebraic properties that you need

1176
00:42:32,400 --> 00:42:34,240
like homomorphic properties or it's just

1177
00:42:34,240 --> 00:42:35,760
like some vector commitment

1178
00:42:35,760 --> 00:42:37,599
yeah it indeed

1179
00:42:37,599 --> 00:42:39,040
the factor commitment scheme has to be

1180
00:42:39,040 --> 00:42:40,319
homomorphic

1181
00:42:40,319 --> 00:42:44,040
okay all right

1182
00:42:44,720 --> 00:42:46,800
thanks

1183
00:42:46,800 --> 00:42:50,480
let me check any more questions on solid

1184
00:42:50,480 --> 00:42:51,359
no

1185
00:42:51,359 --> 00:42:53,680
uh maybe just one comment like i sort of

1186
00:42:53,680 --> 00:42:55,760
have a feeling that there is some common

1187
00:42:55,760 --> 00:42:58,160
thread between disjunctions the the kind

1188
00:42:58,160 --> 00:42:59,920
that peter presented and the kind of

1189
00:42:59,920 --> 00:43:01,680
compressed k out of n i don't know if

1190
00:43:01,680 --> 00:43:03,920
there is some way to unify like stack

1191
00:43:03,920 --> 00:43:07,200
garbling and these disjunctions into one

1192
00:43:07,200 --> 00:43:08,960
into one framework maybe this is a

1193
00:43:08,960 --> 00:43:10,640
totally out there question but just a

1194
00:43:10,640 --> 00:43:11,760
comment

1195
00:43:11,760 --> 00:43:15,359
watching the two talks today

1196
00:43:18,720 --> 00:43:20,880
yeah that's an interesting observation

1197
00:43:20,880 --> 00:43:24,800
i think maybe worth looking into

1198
00:43:25,040 --> 00:43:26,960
um

1199
00:43:26,960 --> 00:43:28,800
any other question actually i had a

1200
00:43:28,800 --> 00:43:30,480
question for given that we do have maybe

1201
00:43:30,480 --> 00:43:32,720
a couple more minutes for show on the

1202
00:43:32,720 --> 00:43:35,920
black box uh zero knowledge um

1203
00:43:35,920 --> 00:43:37,040
you had only five minutes for the

1204
00:43:37,040 --> 00:43:38,720
presentation so obviously you couldn't

1205
00:43:38,720 --> 00:43:40,560
get into details can i ask you like for

1206
00:43:40,560 --> 00:43:42,880
example you take a one-way function was

1207
00:43:42,880 --> 00:43:43,920
there in them

1208
00:43:43,920 --> 00:43:45,359
yes

1209
00:43:45,359 --> 00:43:47,599
you take a one-way function you modify

1210
00:43:47,599 --> 00:43:49,359
it into another one that makes black box

1211
00:43:49,359 --> 00:43:52,000
access to this to this function now how

1212
00:43:52,000 --> 00:43:53,520
do you prevent when you formulated that

1213
00:43:53,520 --> 00:43:55,599
this function f itself isn't one way

1214
00:43:55,599 --> 00:43:57,280
which means i won't even make any access

1215
00:43:57,280 --> 00:43:59,760
because your protocol is non-black box

1216
00:43:59,760 --> 00:44:02,240
and capital f black box is in small f

1217
00:44:02,240 --> 00:44:04,560
but not like how do you formulate it so

1218
00:44:04,560 --> 00:44:06,880
that the capital f itself isn't a

1219
00:44:06,880 --> 00:44:08,400
one-way function

1220
00:44:08,400 --> 00:44:09,200
uh

1221
00:44:09,200 --> 00:44:11,040
it's a good question actually

1222
00:44:11,040 --> 00:44:13,520
uh to define is if it is one function

1223
00:44:13,520 --> 00:44:16,079
you you will describe the f the capital

1224
00:44:16,079 --> 00:44:17,920
f part explicitly

1225
00:44:17,920 --> 00:44:21,119
and if you have this part described

1226
00:44:21,119 --> 00:44:23,440
then f to the f is a function it's one

1227
00:44:23,440 --> 00:44:25,520
different function you just

1228
00:44:25,520 --> 00:44:27,359
put the one-way definition directly on

1229
00:44:27,359 --> 00:44:29,760
top of it

1230
00:44:29,760 --> 00:44:31,839
right but my point is that i have an

1231
00:44:31,839 --> 00:44:34,480
easy way of satisfying your f to the f

1232
00:44:34,480 --> 00:44:36,160
definition and construct something

1233
00:44:36,160 --> 00:44:39,040
that's black box because my capital f

1234
00:44:39,040 --> 00:44:41,119
itself would be a description of another

1235
00:44:41,119 --> 00:44:42,960
one-way function it'll never make black

1236
00:44:42,960 --> 00:44:45,520
box call to the small f

1237
00:44:45,520 --> 00:44:47,599
now i can and your protocol can be

1238
00:44:47,599 --> 00:44:49,680
non-black box and capital f so then i

1239
00:44:49,680 --> 00:44:51,119
have a protocol it's black box and

1240
00:44:51,119 --> 00:44:53,440
smaller it just makes no call to

1241
00:44:53,440 --> 00:44:55,280
small f so maybe i'm missing something

1242
00:44:55,280 --> 00:44:56,800
in the formulation

1243
00:44:56,800 --> 00:44:59,760
uh no i guess i didn't say it explicitly

1244
00:44:59,760 --> 00:45:01,280
we're gonna require that that's capital

1245
00:45:01,280 --> 00:45:03,359
f part shouldn't rely on any like

1246
00:45:03,359 --> 00:45:04,640
cryptographic

1247
00:45:04,640 --> 00:45:06,720
extra cryptographic gadgets

1248
00:45:06,720 --> 00:45:08,880
but how like uh how do you formulate

1249
00:45:08,880 --> 00:45:10,319
this like do you say that it should be

1250
00:45:10,319 --> 00:45:12,000
secured with the p space oracle like

1251
00:45:12,000 --> 00:45:13,680
maybe

1252
00:45:13,680 --> 00:45:16,000
uh like how do you formulate it you know

1253
00:45:16,000 --> 00:45:18,400
like relativizing way we assume that the

1254
00:45:18,400 --> 00:45:21,599
only harness is this f molecule yeah in

1255
00:45:21,599 --> 00:45:23,599
this world is relativising

1256
00:45:23,599 --> 00:45:25,599
um one thing i'd be curious to know is

1257
00:45:25,599 --> 00:45:27,760
that i mean like the icos again you know

1258
00:45:27,760 --> 00:45:29,520
i go everything to mpc in the head but

1259
00:45:29,520 --> 00:45:31,599
the the icos construction is kind of

1260
00:45:31,599 --> 00:45:33,839
black box yes like in the commitment

1261
00:45:33,839 --> 00:45:34,720
scheme

1262
00:45:34,720 --> 00:45:36,480
so is it possible to make that an

1263
00:45:36,480 --> 00:45:38,640
instance of your framework eventually or

1264
00:45:38,640 --> 00:45:39,359
no

1265
00:45:39,359 --> 00:45:41,040
oh we actually follow the same paradigm

1266
00:45:41,040 --> 00:45:43,119
but we're addressing some extra problem

1267
00:45:43,119 --> 00:45:45,680
if you think about this uh emptying head

1268
00:45:45,680 --> 00:45:47,440
actually it gives you a black box coming

1269
00:45:47,440 --> 00:45:49,280
and proof blah blah blah proof is

1270
00:45:49,280 --> 00:45:51,040
already like a black box for commitment

1271
00:45:51,040 --> 00:45:53,119
and commitment is a long function so

1272
00:45:53,119 --> 00:45:54,480
yeah it seems it's already a cheaper

1273
00:45:54,480 --> 00:45:57,119
definition but here we require that once

1274
00:45:57,119 --> 00:46:00,160
you can prove something to me my son is

1275
00:46:00,160 --> 00:46:02,319
required that there must exist a

1276
00:46:02,319 --> 00:46:03,760
pre-image

1277
00:46:03,760 --> 00:46:05,520
the existence of the pre-image is with

1278
00:46:05,520 --> 00:46:08,079
respect to the f to the power f this

1279
00:46:08,079 --> 00:46:09,760
function this is the

1280
00:46:09,760 --> 00:46:11,760
fixed function the function itself

1281
00:46:11,760 --> 00:46:13,440
doesn't have extra randomness it's

1282
00:46:13,440 --> 00:46:14,960
different from a community scheme so

1283
00:46:14,960 --> 00:46:16,880
communist game you actually prove okay

1284
00:46:16,880 --> 00:46:18,480
it comes to some value but it's a

1285
00:46:18,480 --> 00:46:20,160
randomized primitive the for that one

1286
00:46:20,160 --> 00:46:21,920
it's easy this task because you have

1287
00:46:21,920 --> 00:46:24,720
actual randomness to consume to yeah

1288
00:46:24,720 --> 00:46:26,079
yeah okay

1289
00:46:26,079 --> 00:46:29,599
all right nice uh also i want to make a

1290
00:46:29,599 --> 00:46:31,440
quick comment if you think about this

1291
00:46:31,440 --> 00:46:33,200
notion for hash function then you don't

1292
00:46:33,200 --> 00:46:35,040
have randomness at all and then this

1293
00:46:35,040 --> 00:46:36,960
kind of proof-based test functions are

1294
00:46:36,960 --> 00:46:38,560
also very useful for example you can

1295
00:46:38,560 --> 00:46:40,800
hash a database and prove the data in

1296
00:46:40,800 --> 00:46:42,480
the database satisfying some

1297
00:46:42,480 --> 00:46:44,400
non-cryptographic predicate

1298
00:46:44,400 --> 00:46:48,960
non-techniques for example pcp based or

1299
00:46:49,280 --> 00:46:50,960
you can only prove closeness but you

1300
00:46:50,960 --> 00:46:53,119
cannot prove there exists

1301
00:46:53,119 --> 00:46:55,280
the existence of the data it's only you

1302
00:46:55,280 --> 00:46:56,640
can only prove this within a dialogue

1303
00:46:56,640 --> 00:46:57,760
box we just

1304
00:46:57,760 --> 00:46:59,359
our main difficulties addressing this

1305
00:46:59,359 --> 00:47:00,960
issue actually

1306
00:47:00,960 --> 00:47:03,119
okay nice

1307
00:47:03,119 --> 00:47:05,119
thanks joe

1308
00:47:05,119 --> 00:47:06,240
we can take

1309
00:47:06,240 --> 00:47:11,078
one last question if there is one

1310
00:47:11,920 --> 00:47:13,599
um

1311
00:47:13,599 --> 00:47:16,079
okay otherwise let's uh let's thank all

1312
00:47:16,079 --> 00:47:18,720
the all the speakers again of this of

1313
00:47:18,720 --> 00:47:20,240
this session

1314
00:47:20,240 --> 00:47:24,598
thanks everyone for attending

