1
00:00:00,320 --> 00:00:02,080
hello everyone i'll talk about

2
00:00:02,080 --> 00:00:03,840
non-malleable codes for bounded

3
00:00:03,840 --> 00:00:06,240
polynomial depth tempering this is based

4
00:00:06,240 --> 00:00:08,400
on joint work with dana dachman soled

5
00:00:08,400 --> 00:00:10,320
and rafael pass

6
00:00:10,320 --> 00:00:11,679
so the problem that we'll be talking

7
00:00:11,679 --> 00:00:13,519
about is really simple it's just two

8
00:00:13,519 --> 00:00:15,519
parties the sender and the receiver the

9
00:00:15,519 --> 00:00:17,119
sender wants to transmit the message to

10
00:00:17,119 --> 00:00:18,240
the receiver

11
00:00:18,240 --> 00:00:20,080
what makes the problem challenging is

12
00:00:20,080 --> 00:00:21,760
that we consider a main dimensional

13
00:00:21,760 --> 00:00:24,480
attacker or a tempering function you can

14
00:00:24,480 --> 00:00:25,599
think of it

15
00:00:25,599 --> 00:00:28,080
that sits on the channel intercepts all

16
00:00:28,080 --> 00:00:30,640
the messages that come from the sender

17
00:00:30,640 --> 00:00:33,040
inspect them in any way it wants

18
00:00:33,040 --> 00:00:34,320
and then

19
00:00:34,320 --> 00:00:36,800
speeds out a possibly different message

20
00:00:36,800 --> 00:00:38,079
to the receiver

21
00:00:38,079 --> 00:00:40,320
what we want to guarantee is that the

22
00:00:40,320 --> 00:00:42,559
adversary this adversary that sits on

23
00:00:42,559 --> 00:00:43,840
the channel

24
00:00:43,840 --> 00:00:46,000
cannot meaningfully modify the message

25
00:00:46,000 --> 00:00:47,440
and what we mean by meaningful

26
00:00:47,440 --> 00:00:48,800
modification

27
00:00:48,800 --> 00:00:50,960
is that we want to make sure that the

28
00:00:50,960 --> 00:00:53,520
decoded message that the receiver sees

29
00:00:53,520 --> 00:00:55,600
in the end of this game is with very

30
00:00:55,600 --> 00:00:58,000
high probability either the original

31
00:00:58,000 --> 00:01:00,480
message that was intended to say to be

32
00:01:00,480 --> 00:01:02,640
sent by the sender or something

33
00:01:02,640 --> 00:01:05,600
completely unrelated and notice that

34
00:01:05,600 --> 00:01:07,520
the adversary could always just

35
00:01:07,520 --> 00:01:09,520
intercept the message that the sender

36
00:01:09,520 --> 00:01:10,880
sent

37
00:01:10,880 --> 00:01:13,040
throw it away and just send something

38
00:01:13,040 --> 00:01:14,960
completely random to the receiver in

39
00:01:14,960 --> 00:01:16,960
this case we want the message received

40
00:01:16,960 --> 00:01:18,320
by the receiver to be completely

41
00:01:18,320 --> 00:01:20,159
unrelated because it's independent of

42
00:01:20,159 --> 00:01:22,159
the message underlying the real code

43
00:01:22,159 --> 00:01:23,040
word

44
00:01:23,040 --> 00:01:25,200
or we want to make sure that the

45
00:01:25,200 --> 00:01:27,520
adversary no matter what it did he tried

46
00:01:27,520 --> 00:01:29,520
to modify the underlying message it

47
00:01:29,520 --> 00:01:31,680
could it didn't succeed

48
00:01:31,680 --> 00:01:33,360
so this this primitive is called the

49
00:01:33,360 --> 00:01:35,840
non-valuable code it was introduced

50
00:01:35,840 --> 00:01:37,119
about

51
00:01:37,119 --> 00:01:38,960
10 years or a little bit more

52
00:01:38,960 --> 00:01:42,560
10 years ago by zimbabwe checking weeks

53
00:01:42,560 --> 00:01:44,079
and it has received significant

54
00:01:44,079 --> 00:01:46,479
attention from various communities in

55
00:01:46,479 --> 00:01:48,640
the past decade or so

56
00:01:48,640 --> 00:01:51,600
it was a for instance it was used as a

57
00:01:51,600 --> 00:01:52,880
building block

58
00:01:52,880 --> 00:01:55,520
in modern constructions of multi-source

59
00:01:55,520 --> 00:01:58,320
extractors uh interesting connections

60
00:01:58,320 --> 00:01:59,920
with active combinatories have been

61
00:01:59,920 --> 00:02:02,399
rediscovered and it was

62
00:02:02,399 --> 00:02:03,920
more naturally

63
00:02:03,920 --> 00:02:06,719
used as a as the building block in

64
00:02:06,719 --> 00:02:08,399
various non-malleable cryptographic

65
00:02:08,399 --> 00:02:10,239
constructions

66
00:02:10,239 --> 00:02:12,720
so this is a very useful and important

67
00:02:12,720 --> 00:02:14,000
notion

68
00:02:14,000 --> 00:02:16,239
but before i tell you what we know about

69
00:02:16,239 --> 00:02:18,400
it i wanted to draw some connections

70
00:02:18,400 --> 00:02:19,280
with

71
00:02:19,280 --> 00:02:21,840
existing primitives that you may have

72
00:02:21,840 --> 00:02:24,720
heard about and explain the differences

73
00:02:24,720 --> 00:02:26,879
so two primitives that i'll be talking

74
00:02:26,879 --> 00:02:28,640
about or comparing normal about those

75
00:02:28,640 --> 00:02:31,519
two are error correcting codes and

76
00:02:31,519 --> 00:02:33,519
non-valuable commitments

77
00:02:33,519 --> 00:02:35,599
so the first distinction between these

78
00:02:35,599 --> 00:02:38,000
three primitives comes in the

79
00:02:38,000 --> 00:02:40,239
in the class of adversaries that we're

80
00:02:40,239 --> 00:02:41,920
willing to tolerate

81
00:02:41,920 --> 00:02:43,680
in an error correcting code the

82
00:02:43,680 --> 00:02:46,239
adversary sees the code word but is

83
00:02:46,239 --> 00:02:48,720
limited in the way it can

84
00:02:48,720 --> 00:02:50,879
modify it or tamper with it and

85
00:02:50,879 --> 00:02:52,959
specifically usually what we allow the

86
00:02:52,959 --> 00:02:56,080
adversary to do is to choose a subset of

87
00:02:56,080 --> 00:02:57,760
coordinates let's say one half of them

88
00:02:57,760 --> 00:03:00,319
or one third of them or some fraction of

89
00:03:00,319 --> 00:03:02,159
the cold war of the symbols in the

90
00:03:02,159 --> 00:03:06,000
message and modify them arbitrarily and

91
00:03:06,000 --> 00:03:08,159
we want to guarantee that the receiver

92
00:03:08,159 --> 00:03:11,200
can recover the original message

93
00:03:11,200 --> 00:03:12,879
non-variable commitments the address

94
00:03:12,879 --> 00:03:15,120
receives the message that is sent from a

95
00:03:15,120 --> 00:03:16,640
sender to receiver

96
00:03:16,640 --> 00:03:19,440
but it can apply an arbitrary polynomial

97
00:03:19,440 --> 00:03:22,000
time function on it so it's not limited

98
00:03:22,000 --> 00:03:23,680
in the way that it accesses the code

99
00:03:23,680 --> 00:03:24,480
word

100
00:03:24,480 --> 00:03:27,280
it can do arbitrary computation and

101
00:03:27,280 --> 00:03:29,280
do anything on it as long as it's

102
00:03:29,280 --> 00:03:31,519
polynomial size and in a non variable

103
00:03:31,519 --> 00:03:33,280
codes as you we're going to see the

104
00:03:33,280 --> 00:03:36,239
adversary somewhere in between

105
00:03:36,239 --> 00:03:38,640
it's it's not an arbitrary polynomial

106
00:03:38,640 --> 00:03:39,760
side machine

107
00:03:39,760 --> 00:03:41,920
and but we hope that it's going to be a

108
00:03:41,920 --> 00:03:43,599
little bit more than just changing the

109
00:03:43,599 --> 00:03:44,840
subset of

110
00:03:44,840 --> 00:03:46,879
coordinates and the

111
00:03:46,879 --> 00:03:48,000
the second

112
00:03:48,000 --> 00:03:49,599
difference between these three primitive

113
00:03:49,599 --> 00:03:51,440
is that we want to be able to

114
00:03:51,440 --> 00:03:53,920
decode and this is why for instance this

115
00:03:53,920 --> 00:03:55,439
is why none other commitments you can

116
00:03:55,439 --> 00:03:57,599
allow arbitrary polynomial sized

117
00:03:57,599 --> 00:03:59,680
adversary it's because we don't really

118
00:03:59,680 --> 00:04:02,480
expect the the receiver to decode it's

119
00:04:02,480 --> 00:04:04,480
just a commitment

120
00:04:04,480 --> 00:04:06,480
in non-valuable code and in the error

121
00:04:06,480 --> 00:04:08,400
correcting code we do expect the

122
00:04:08,400 --> 00:04:10,400
receiver to decode

123
00:04:10,400 --> 00:04:12,159
and this is why we cannot support any

124
00:04:12,159 --> 00:04:14,480
polynomial size of factor okay so this

125
00:04:14,480 --> 00:04:16,238
is uh just to put things a little bit in

126
00:04:16,238 --> 00:04:17,440
context

127
00:04:17,440 --> 00:04:19,918
so here's uh some very basic facts about

128
00:04:19,918 --> 00:04:22,160
non-valuable codes

129
00:04:22,160 --> 00:04:23,919
so first of all like i

130
00:04:23,919 --> 00:04:26,840
as i alluded to in the previous slide if

131
00:04:26,840 --> 00:04:30,720
decoding can be done efficiently

132
00:04:30,720 --> 00:04:32,880
then there's no way to support all

133
00:04:32,880 --> 00:04:36,639
polynomial size tempering functions

134
00:04:36,639 --> 00:04:40,000
right because the adversary could decode

135
00:04:40,000 --> 00:04:41,520
if it's possible in doing doing

136
00:04:41,520 --> 00:04:43,360
polynomial time

137
00:04:43,360 --> 00:04:44,960
and if the message is equal to some

138
00:04:44,960 --> 00:04:46,479
predefined message let's say it's all

139
00:04:46,479 --> 00:04:48,880
zeros then we just output the all zero

140
00:04:48,880 --> 00:04:50,160
string

141
00:04:50,160 --> 00:04:52,479
and otherwise we output the code word by

142
00:04:52,479 --> 00:04:55,199
any meaningful notion of uh nominability

143
00:04:55,199 --> 00:04:56,479
this is a

144
00:04:56,479 --> 00:04:58,320
valid tempering

145
00:04:58,320 --> 00:04:59,680
tempering attack

146
00:04:59,680 --> 00:05:02,160
and that's why we have to limit

147
00:05:02,160 --> 00:05:04,080
the adversary in some way if we're

148
00:05:04,080 --> 00:05:05,360
willing to

149
00:05:05,360 --> 00:05:06,400
if we're

150
00:05:06,400 --> 00:05:09,680
requiring that decoding is polynomial

151
00:05:09,680 --> 00:05:11,440
so there has been

152
00:05:11,440 --> 00:05:13,520
many suggestions as to how to limit the

153
00:05:13,520 --> 00:05:15,039
adversary so

154
00:05:15,039 --> 00:05:16,960
for instance we can limit its running

155
00:05:16,960 --> 00:05:19,120
time it can run

156
00:05:19,120 --> 00:05:21,039
slower than the decoding

157
00:05:21,039 --> 00:05:23,600
it might have a small space namely it

158
00:05:23,600 --> 00:05:25,520
might

159
00:05:25,520 --> 00:05:27,600
use less space than is required by the

160
00:05:27,600 --> 00:05:31,360
decoding or we can limit in some way the

161
00:05:31,360 --> 00:05:33,680
access to the code word for instance

162
00:05:33,680 --> 00:05:36,000
we can allow an enter temperable common

163
00:05:36,000 --> 00:05:37,360
reference string

164
00:05:37,360 --> 00:05:38,479
or we

165
00:05:38,479 --> 00:05:39,840
limit the

166
00:05:39,840 --> 00:05:41,840
way the adversary

167
00:05:41,840 --> 00:05:43,919
accesses the code word not in the amount

168
00:05:43,919 --> 00:05:46,960
of things he can modify but in the way

169
00:05:46,960 --> 00:05:49,280
it can modify them and this is where

170
00:05:49,280 --> 00:05:51,919
for instance one useful note in it

171
00:05:51,919 --> 00:05:55,680
is split state adversaries

172
00:05:55,680 --> 00:05:59,039
so here are some results that are known

173
00:05:59,039 --> 00:06:00,960
so first of all in the very original

174
00:06:00,960 --> 00:06:03,280
work of zimbabwe education weeks it was

175
00:06:03,280 --> 00:06:05,919
already shown that this primitive exists

176
00:06:05,919 --> 00:06:08,479
it lives non-explicitly namely if you

177
00:06:08,479 --> 00:06:11,039
choose a random encoding scheme it will

178
00:06:11,039 --> 00:06:12,720
be secure for any

179
00:06:12,720 --> 00:06:16,639
circuit of size 2 to then over 2.

180
00:06:16,639 --> 00:06:19,199
and what about explicit construction so

181
00:06:19,199 --> 00:06:21,280
there has been lots of work and here are

182
00:06:21,280 --> 00:06:23,199
a couple of examples

183
00:06:23,199 --> 00:06:24,800
if we limit the adversary to be a

184
00:06:24,800 --> 00:06:26,560
polynomial size circuit an arbitrary

185
00:06:26,560 --> 00:06:28,319
polynomial size circuit

186
00:06:28,319 --> 00:06:32,160
and then we can support the we can

187
00:06:32,160 --> 00:06:33,840
indeed guarantee

188
00:06:33,840 --> 00:06:36,880
if we assume an untemperable crs so we

189
00:06:36,880 --> 00:06:38,479
assume there is some

190
00:06:38,479 --> 00:06:41,039
crs that's written in the sky

191
00:06:41,039 --> 00:06:42,880
it had to be bigger than the size of the

192
00:06:42,880 --> 00:06:44,800
adversary so

193
00:06:44,800 --> 00:06:46,479
bigger than this s

194
00:06:46,479 --> 00:06:48,160
and the adversary is not allowed to

195
00:06:48,160 --> 00:06:50,639
tamper with it and it's not allowed it

196
00:06:50,639 --> 00:06:52,800
won't be even allowed to read it because

197
00:06:52,800 --> 00:06:54,800
it's so long

198
00:06:54,800 --> 00:06:55,520
but

199
00:06:55,520 --> 00:06:58,160
there is an explicit construction

200
00:06:58,160 --> 00:07:00,240
and there is there's also explicit

201
00:07:00,240 --> 00:07:03,759
constructions in in models with some

202
00:07:03,759 --> 00:07:05,120
something like

203
00:07:05,120 --> 00:07:07,680
like a random oracle model if we assume

204
00:07:07,680 --> 00:07:09,360
the adversary has bounded space so we

205
00:07:09,360 --> 00:07:10,639
cannot just store the whole random

206
00:07:10,639 --> 00:07:13,599
workflow in memory

207
00:07:13,599 --> 00:07:16,400
and then more recent work uh focused on

208
00:07:16,400 --> 00:07:18,720
constructing online level codes

209
00:07:18,720 --> 00:07:21,680
uh against classes complexity classes

210
00:07:21,680 --> 00:07:23,440
adversaries that come from some

211
00:07:23,440 --> 00:07:26,160
well-known complexity classes like ac 0

212
00:07:26,160 --> 00:07:29,840
and c0 and the most up-to-date results

213
00:07:29,840 --> 00:07:30,560
is

214
00:07:30,560 --> 00:07:32,960
are even construction secure almost

215
00:07:32,960 --> 00:07:35,360
again and against nc one so it's log

216
00:07:35,360 --> 00:07:36,800
depth circuits

217
00:07:36,800 --> 00:07:39,199
specifically they obtain log over log

218
00:07:39,199 --> 00:07:42,240
log depth circuits

219
00:07:42,240 --> 00:07:44,560
so we have many constructions under many

220
00:07:44,560 --> 00:07:46,560
assumptions some of them are a

221
00:07:46,560 --> 00:07:50,160
trustworthy assumption some of them are

222
00:07:50,160 --> 00:07:51,280
are

223
00:07:51,280 --> 00:07:52,720
assumptions about

224
00:07:52,720 --> 00:07:56,319
the explicitness of the construction

225
00:07:56,319 --> 00:07:57,280
and

226
00:07:57,280 --> 00:07:59,919
arguably the holy grail or this whole

227
00:07:59,919 --> 00:08:02,000
line of work where it leads to

228
00:08:02,000 --> 00:08:04,479
is a construction of an explicit

229
00:08:04,479 --> 00:08:06,400
non-valuable code right so we first want

230
00:08:06,400 --> 00:08:08,720
an explicit construction

231
00:08:08,720 --> 00:08:11,280
of a non-variable code and we wanted to

232
00:08:11,280 --> 00:08:13,840
be secure against the best we can hope

233
00:08:13,840 --> 00:08:15,199
for which is

234
00:08:15,199 --> 00:08:17,440
just a bounded polynomial size circuit

235
00:08:17,440 --> 00:08:19,759
so i give you a bound let's say end to

236
00:08:19,759 --> 00:08:21,520
the 100

237
00:08:21,520 --> 00:08:23,680
and i want to construct an explicit

238
00:08:23,680 --> 00:08:25,520
nonvariable code

239
00:08:25,520 --> 00:08:28,720
that is secure or non-variable for all

240
00:08:28,720 --> 00:08:33,039
attackers of size up to n to the 100.

241
00:08:33,039 --> 00:08:35,120
so this is the the holy grail you want

242
00:08:35,120 --> 00:08:36,880
to be able to do this for any polynomial

243
00:08:36,880 --> 00:08:39,200
not just 10 to the 100

244
00:08:39,200 --> 00:08:40,719
and ideally

245
00:08:40,719 --> 00:08:42,880
we would like the encoding

246
00:08:42,880 --> 00:08:45,519
to run in fixed polynomial time so

247
00:08:45,519 --> 00:08:47,760
independent of this 100 so maybe n to

248
00:08:47,760 --> 00:08:50,880
the fifth for any fixed polynomial

249
00:08:50,880 --> 00:08:52,320
which bounds the running time of the

250
00:08:52,320 --> 00:08:54,000
adversary

251
00:08:54,000 --> 00:08:56,480
but as i mentioned decoding has to take

252
00:08:56,480 --> 00:08:57,839
longer so

253
00:08:57,839 --> 00:08:59,760
we want encoding in fixed point on time

254
00:08:59,760 --> 00:09:02,560
and decoding to depend on the

255
00:09:02,560 --> 00:09:05,279
class of the adversary

256
00:09:05,279 --> 00:09:07,519
so this is the holy grail

257
00:09:07,519 --> 00:09:09,279
so what has been done towards this holy

258
00:09:09,279 --> 00:09:11,920
grail and

259
00:09:11,920 --> 00:09:14,480
so the first attempt to really achieve

260
00:09:14,480 --> 00:09:17,200
something that looks like the

261
00:09:17,200 --> 00:09:19,920
comes close to the holy grail was done

262
00:09:19,920 --> 00:09:22,880
by boletal about three years ago

263
00:09:22,880 --> 00:09:24,880
they suggested well let's use crypto to

264
00:09:24,880 --> 00:09:27,279
see if this task is even possible

265
00:09:27,279 --> 00:09:29,760
and they indeed obtained the result

266
00:09:29,760 --> 00:09:31,519
they showed that

267
00:09:31,519 --> 00:09:32,880
if you assume

268
00:09:32,880 --> 00:09:34,480
public encryption

269
00:09:34,480 --> 00:09:37,440
and non-interactive zero knowledge

270
00:09:37,440 --> 00:09:40,080
plus some average case hardness for the

271
00:09:40,080 --> 00:09:41,920
class of attackers that you're willing

272
00:09:41,920 --> 00:09:42,880
to

273
00:09:42,880 --> 00:09:43,760
uh

274
00:09:43,760 --> 00:09:44,959
to capture

275
00:09:44,959 --> 00:09:46,720
then there exists a non-valuable code

276
00:09:46,720 --> 00:09:50,000
for this class of attackers

277
00:09:50,000 --> 00:09:52,160
this is a great result

278
00:09:52,160 --> 00:09:54,640
in terms of feasibility the downside

279
00:09:54,640 --> 00:09:56,320
is that the

280
00:09:56,320 --> 00:09:58,080
is that they're using a public

281
00:09:58,080 --> 00:10:00,399
encryption scheme and their music

282
00:10:00,399 --> 00:10:03,360
which both of which rely on

283
00:10:03,360 --> 00:10:05,920
crs in the case of a public encryption

284
00:10:05,920 --> 00:10:08,160
scheme it's just a public health scheme

285
00:10:08,160 --> 00:10:10,000
and both of them have to be

286
00:10:10,000 --> 00:10:11,680
written in the sky in some sense and

287
00:10:11,680 --> 00:10:13,680
they're untemporable

288
00:10:13,680 --> 00:10:15,680
by the attacker

289
00:10:15,680 --> 00:10:17,200
the advantage of this construction over

290
00:10:17,200 --> 00:10:19,440
previous ones is that here the crs is

291
00:10:19,440 --> 00:10:23,680
short it's independent of the class f

292
00:10:23,680 --> 00:10:25,680
so this was the first result and then

293
00:10:25,680 --> 00:10:28,000
the follow-up by bullet al

294
00:10:28,000 --> 00:10:29,680
was the construction in the plane model

295
00:10:29,680 --> 00:10:32,480
so right they got rid of the crs

296
00:10:32,480 --> 00:10:34,000
and they got construction in the plane

297
00:10:34,000 --> 00:10:37,519
model albeit they had several cats still

298
00:10:37,519 --> 00:10:39,440
had several caveats

299
00:10:39,440 --> 00:10:41,440
the first is that they relied on p

300
00:10:41,440 --> 00:10:43,680
certificates this certificate is a

301
00:10:43,680 --> 00:10:46,320
rather strong assumption it's a succinct

302
00:10:46,320 --> 00:10:49,440
one message argument for a p for all

303
00:10:49,440 --> 00:10:51,680
polynomial time computations and it's

304
00:10:51,680 --> 00:10:53,680
succinct in the strongest sense that you

305
00:10:53,680 --> 00:10:55,200
can imagine

306
00:10:55,200 --> 00:10:57,839
the proof size is independent of the

307
00:10:57,839 --> 00:10:59,680
computation the

308
00:10:59,680 --> 00:11:04,319
and or the instance right it's just

309
00:11:04,399 --> 00:11:06,720
it's the best notion of success you can

310
00:11:06,720 --> 00:11:09,200
imagine and one candidate for this

311
00:11:09,200 --> 00:11:11,200
construction is michael's cs proof

312
00:11:11,200 --> 00:11:13,680
system when you instantiate

313
00:11:13,680 --> 00:11:15,279
the random market with the complete hash

314
00:11:15,279 --> 00:11:16,320
function

315
00:11:16,320 --> 00:11:18,480
and this is the best of our knowledge

316
00:11:18,480 --> 00:11:20,560
this is the only candidate up to the up

317
00:11:20,560 --> 00:11:22,399
to now to date

318
00:11:22,399 --> 00:11:25,279
so this is a rather strong assumption

319
00:11:25,279 --> 00:11:26,240
and

320
00:11:26,240 --> 00:11:29,279
but they had even ignoring this uh

321
00:11:29,279 --> 00:11:30,959
this strong assumption which perhaps

322
00:11:30,959 --> 00:11:33,279
we're willing to settle for they had a

323
00:11:33,279 --> 00:11:36,320
couple of more uh downsides like one one

324
00:11:36,320 --> 00:11:38,640
was that they obtained normal ability

325
00:11:38,640 --> 00:11:41,279
only for uniform adversaries as opposed

326
00:11:41,279 --> 00:11:43,040
to the standard notion of non-uniform

327
00:11:43,040 --> 00:11:45,760
security against non-uniform attackers

328
00:11:45,760 --> 00:11:46,640
they

329
00:11:46,640 --> 00:11:48,800
only obtain non-variability with inverse

330
00:11:48,800 --> 00:11:50,959
polynomial distinguishing advantage

331
00:11:50,959 --> 00:11:54,880
namely an adversary could perform a

332
00:11:54,880 --> 00:11:57,040
successful tempering attack with with

333
00:11:57,040 --> 00:12:00,000
some inverse polynomial probability

334
00:12:00,000 --> 00:12:01,200
and

335
00:12:01,200 --> 00:12:04,079
lastly both their decoding and encoding

336
00:12:04,079 --> 00:12:06,800
run longer than the adversary

337
00:12:06,800 --> 00:12:07,600
and

338
00:12:07,600 --> 00:12:09,680
optimally we would like to achieve in

339
00:12:09,680 --> 00:12:13,040
coding in fixed polynomial time

340
00:12:13,040 --> 00:12:14,560
so this is what's known about this

341
00:12:14,560 --> 00:12:16,079
problem

342
00:12:16,079 --> 00:12:18,639
what we do we we have like a meta

343
00:12:18,639 --> 00:12:19,760
theorem

344
00:12:19,760 --> 00:12:21,839
that implies a new construction of a

345
00:12:21,839 --> 00:12:24,560
non-malabar code so here are the three

346
00:12:24,560 --> 00:12:26,000
building blocks that we need for our

347
00:12:26,000 --> 00:12:27,440
metatheorem

348
00:12:27,440 --> 00:12:29,040
let me just say that this is not a

349
00:12:29,040 --> 00:12:31,360
generic construction in any of these in

350
00:12:31,360 --> 00:12:33,600
any instantiation of these primitives

351
00:12:33,600 --> 00:12:35,120
wield specific constructions and

352
00:12:35,120 --> 00:12:36,880
specific properties

353
00:12:36,880 --> 00:12:40,000
that i will explain a little bit later

354
00:12:40,000 --> 00:12:42,480
but the general recipes

355
00:12:42,480 --> 00:12:46,639
is very easy to explain in a generic way

356
00:12:46,639 --> 00:12:48,880
so we use three primitives it's a time

357
00:12:48,880 --> 00:12:51,279
of puzzle a one message non-valuable

358
00:12:51,279 --> 00:12:54,000
commitment and the one message zero

359
00:12:54,000 --> 00:12:56,079
knowledge scheme

360
00:12:56,079 --> 00:12:58,240
by one message i mean just single shot

361
00:12:58,240 --> 00:13:00,720
one message and no crs or anything like

362
00:13:00,720 --> 00:13:02,800
that

363
00:13:02,800 --> 00:13:04,480
to be clear a time lock pass is this

364
00:13:04,480 --> 00:13:07,680
method to create puzzles that are

365
00:13:07,680 --> 00:13:09,120
easy to create

366
00:13:09,120 --> 00:13:10,800
but require

367
00:13:10,800 --> 00:13:13,920
some moderate polynomial uh sequential

368
00:13:13,920 --> 00:13:16,160
effort so even if you have

369
00:13:16,160 --> 00:13:18,639
many processors in

370
00:13:18,639 --> 00:13:20,560
even if the addresser has many

371
00:13:20,560 --> 00:13:22,480
processors that he can run in parallel

372
00:13:22,480 --> 00:13:24,399
it's a way to generate

373
00:13:24,399 --> 00:13:28,079
problems that are still hard to solve

374
00:13:28,079 --> 00:13:30,480
as long as the sequential running time

375
00:13:30,480 --> 00:13:33,040
is less than some predefined down

376
00:13:33,040 --> 00:13:35,920
so we have these three primitives

377
00:13:35,920 --> 00:13:37,360
with sub-exponential security and we

378
00:13:37,360 --> 00:13:39,519
obtain the following non-variable code

379
00:13:39,519 --> 00:13:42,880
so for any polynomial t

380
00:13:42,880 --> 00:13:45,040
there exists a null variable code where

381
00:13:45,040 --> 00:13:47,600
the encoding takes time polynomial in

382
00:13:47,600 --> 00:13:49,519
lambda so that is the security parameter

383
00:13:49,519 --> 00:13:51,680
so it's the fixed polynomial

384
00:13:51,680 --> 00:13:54,160
decoding takes time polynomial in t and

385
00:13:54,160 --> 00:13:55,120
lambda

386
00:13:55,120 --> 00:13:57,279
and notice that the dependence on t is

387
00:13:57,279 --> 00:13:58,880
necessary

388
00:13:58,880 --> 00:14:01,199
and we guarantee nonverbality for all

389
00:14:01,199 --> 00:14:04,959
adversaries of size at mostly

390
00:14:05,760 --> 00:14:07,199
so this is really

391
00:14:07,199 --> 00:14:08,959
achieving the holy grail

392
00:14:08,959 --> 00:14:10,480
i mentioned before

393
00:14:10,480 --> 00:14:12,959
and we check all the boxes that you can

394
00:14:12,959 --> 00:14:14,320
imagine we

395
00:14:14,320 --> 00:14:17,040
we achieve non-uniform security

396
00:14:17,040 --> 00:14:20,000
we achieve negligible advantage with

397
00:14:20,000 --> 00:14:22,880
negligible non-valuability like

398
00:14:22,880 --> 00:14:24,800
like what you would expect

399
00:14:24,800 --> 00:14:28,320
we have past encoding uh as i mentioned

400
00:14:28,320 --> 00:14:30,639
and we even get normal ability for

401
00:14:30,639 --> 00:14:32,720
for a larger class of adversaries

402
00:14:32,720 --> 00:14:34,880
because we're using time lock puzzles

403
00:14:34,880 --> 00:14:37,279
we actually get nominability for all

404
00:14:37,279 --> 00:14:39,920
polynomial size adversaries as long as

405
00:14:39,920 --> 00:14:42,639
their depth is operator rebounded so you

406
00:14:42,639 --> 00:14:44,399
only need to bound the depth of the

407
00:14:44,399 --> 00:14:46,000
attacker

408
00:14:46,000 --> 00:14:48,000
namely the further runtime of the

409
00:14:48,000 --> 00:14:50,480
attacker and then you can we can support

410
00:14:50,480 --> 00:14:53,440
arbitrary polynomial size attackers so

411
00:14:53,440 --> 00:14:55,040
this is the main theorem let me tell you

412
00:14:55,040 --> 00:14:56,800
about the specific instantiation that we

413
00:14:56,800 --> 00:14:57,600
have

414
00:14:57,600 --> 00:14:59,760
so these are the three primitives which

415
00:14:59,760 --> 00:15:01,680
imply non-variable code

416
00:15:01,680 --> 00:15:03,040
a non-variable code for boundary

417
00:15:03,040 --> 00:15:05,199
polynomial tempering

418
00:15:05,199 --> 00:15:06,639
we inferentiate the time of puzzles

419
00:15:06,639 --> 00:15:08,320
using repeated squaring assumption the

420
00:15:08,320 --> 00:15:10,240
most well-known construction

421
00:15:10,240 --> 00:15:11,839
and we use two other assumptions the

422
00:15:11,839 --> 00:15:14,320
keyless multi-collisions in hash and the

423
00:15:14,320 --> 00:15:16,880
new way to instantiate the other two

424
00:15:16,880 --> 00:15:18,399
primitives

425
00:15:18,399 --> 00:15:20,720
so all in all we get the construction of

426
00:15:20,720 --> 00:15:22,480
our non-variable code from three

427
00:15:22,480 --> 00:15:24,320
assumptions it's the repeated squaring

428
00:15:24,320 --> 00:15:25,519
assumption

429
00:15:25,519 --> 00:15:27,760
kill its multi-collision resistant hash

430
00:15:27,760 --> 00:15:31,199
and new wave for np

431
00:15:31,360 --> 00:15:35,360
so this is the main result of our paper

432
00:15:35,360 --> 00:15:36,959
let me tell you a little bit about how

433
00:15:36,959 --> 00:15:39,040
the construction works

434
00:15:39,040 --> 00:15:41,680
the construction is very easy to explain

435
00:15:41,680 --> 00:15:43,680
in steps let's first do the time of past

436
00:15:43,680 --> 00:15:45,440
them and see what we get

437
00:15:45,440 --> 00:15:47,600
we encode the message using a time lock

438
00:15:47,600 --> 00:15:49,759
puzzle and we can decode using the

439
00:15:49,759 --> 00:15:51,040
solving procedure of the timeline

440
00:15:51,040 --> 00:15:52,959
function this achieves in terms of

441
00:15:52,959 --> 00:15:54,480
functionality the chips what we want

442
00:15:54,480 --> 00:15:56,959
right we encode really fast and we can

443
00:15:56,959 --> 00:15:58,720
decode within

444
00:15:58,720 --> 00:15:59,759
some

445
00:15:59,759 --> 00:16:02,320
predefined time again to the 100

446
00:16:02,320 --> 00:16:04,000
the problem is that time of puzzles are

447
00:16:04,000 --> 00:16:06,000
not not malleable

448
00:16:06,000 --> 00:16:08,880
so we cannot just uh so we cannot claim

449
00:16:08,880 --> 00:16:10,399
non-valuability they're in fact not

450
00:16:10,399 --> 00:16:12,160
non-valuable

451
00:16:12,160 --> 00:16:14,399
so let's add the component on my level

452
00:16:14,399 --> 00:16:16,800
component to the scheme and

453
00:16:16,800 --> 00:16:18,320
together with the time of puzzling the

454
00:16:18,320 --> 00:16:19,839
encoding let's also commit with a

455
00:16:19,839 --> 00:16:23,360
non-verbal commitment to the message

456
00:16:23,360 --> 00:16:25,120
so this adds some non-valuable

457
00:16:25,120 --> 00:16:27,120
non-malleable component but the problem

458
00:16:27,120 --> 00:16:29,360
is that the coding is independent of it

459
00:16:29,360 --> 00:16:31,040
and the adversary could just ignore it

460
00:16:31,040 --> 00:16:32,720
right it could

461
00:16:32,720 --> 00:16:35,120
tamper with time or puzzle and modify

462
00:16:35,120 --> 00:16:37,600
the output of the experiment so we add a

463
00:16:37,600 --> 00:16:40,320
zero knowledge proof that shows that

464
00:16:40,320 --> 00:16:41,360
um

465
00:16:41,360 --> 00:16:43,199
that the two components

466
00:16:43,199 --> 00:16:45,519
are encoding the same message so the

467
00:16:45,519 --> 00:16:47,120
timer puzzle and the nonliable

468
00:16:47,120 --> 00:16:49,279
commitment are consistent with respect

469
00:16:49,279 --> 00:16:51,040
to the underlying message

470
00:16:51,040 --> 00:16:52,240
but this construction is really in the

471
00:16:52,240 --> 00:16:53,839
spirit of norian level encryption

472
00:16:53,839 --> 00:16:55,360
methods

473
00:16:55,360 --> 00:16:57,040
and and i'll talk a little bit more

474
00:16:57,040 --> 00:16:59,440
about that soon so this is our final

475
00:16:59,440 --> 00:17:01,920
construction

476
00:17:01,920 --> 00:17:03,839
the security definition that we achieve

477
00:17:03,839 --> 00:17:06,559
uh that this the construction achieves

478
00:17:06,559 --> 00:17:08,079
uh is the standard one in the

479
00:17:08,079 --> 00:17:10,799
non-violable community coding literature

480
00:17:10,799 --> 00:17:12,480
there are two experiments that need to

481
00:17:12,480 --> 00:17:13,520
be

482
00:17:13,520 --> 00:17:15,520
distinct indistinguishable the real

483
00:17:15,520 --> 00:17:16,959
world experiment

484
00:17:16,959 --> 00:17:20,079
allows an attacker to obtain a code word

485
00:17:20,079 --> 00:17:22,240
modify it in an arbitrary way and then

486
00:17:22,240 --> 00:17:24,079
the code and the output of the decoding

487
00:17:24,079 --> 00:17:25,839
is the output of the experiment

488
00:17:25,839 --> 00:17:27,359
in the real world experiment there is a

489
00:17:27,359 --> 00:17:29,360
simulator that doesn't know

490
00:17:29,360 --> 00:17:31,520
the underlying message it either outputs

491
00:17:31,520 --> 00:17:33,520
some message and field

492
00:17:33,520 --> 00:17:36,000
which is independent of m or it outputs

493
00:17:36,000 --> 00:17:38,799
the word same same meaning that the user

494
00:17:38,799 --> 00:17:41,120
didn't change anything

495
00:17:41,120 --> 00:17:42,799
and the output of the experiment is

496
00:17:42,799 --> 00:17:45,600
either the original message if

497
00:17:45,600 --> 00:17:47,520
the adversary if the simulator outputs

498
00:17:47,520 --> 00:17:49,919
the same or it's the unrelated message

499
00:17:49,919 --> 00:17:52,320
and field so this is the natural thing

500
00:17:52,320 --> 00:17:54,400
you would expect and this is what you

501
00:17:54,400 --> 00:17:55,919
achieved

502
00:17:55,919 --> 00:17:58,320
here's a couple of words about the main

503
00:17:58,320 --> 00:17:59,520
proof of idea

504
00:17:59,520 --> 00:18:01,360
so i mentioned that the construction is

505
00:18:01,360 --> 00:18:03,200
in the spirit of no nor young double

506
00:18:03,200 --> 00:18:05,360
encryption except that instead of using

507
00:18:05,360 --> 00:18:06,960
two public encryption schemes like they

508
00:18:06,960 --> 00:18:08,720
do we use a non-member commitment then

509
00:18:08,720 --> 00:18:10,240
in time of concept

510
00:18:10,240 --> 00:18:11,360
but

511
00:18:11,360 --> 00:18:13,120
one natural approach for the proof would

512
00:18:13,120 --> 00:18:15,919
be to say okay let's replace the real

513
00:18:15,919 --> 00:18:17,919
decryption with a simulated one and

514
00:18:17,919 --> 00:18:19,600
decryption in our case is decoding so

515
00:18:19,600 --> 00:18:20,960
let's replace the

516
00:18:20,960 --> 00:18:24,240
decoding procedure with a simulated one

517
00:18:24,240 --> 00:18:26,160
but the challenge is that

518
00:18:26,160 --> 00:18:28,480
for us the the simulated decoding

519
00:18:28,480 --> 00:18:30,960
procedure um

520
00:18:30,960 --> 00:18:32,559
is to essentially extract from the

521
00:18:32,559 --> 00:18:33,840
commitment

522
00:18:33,840 --> 00:18:35,679
so the real decoding procedure is to

523
00:18:35,679 --> 00:18:36,880
solve the term of puzzle but the

524
00:18:36,880 --> 00:18:38,160
alternate one would be to break the

525
00:18:38,160 --> 00:18:40,080
commitment and breaking the commitment

526
00:18:40,080 --> 00:18:42,320
is a super polynomial time task while

527
00:18:42,320 --> 00:18:43,760
breaking the time log puzzle is a

528
00:18:43,760 --> 00:18:44,960
polynomial

529
00:18:44,960 --> 00:18:48,320
time task so it's really in

530
00:18:48,320 --> 00:18:50,240
it's really not clear a priori how you

531
00:18:50,240 --> 00:18:52,480
would be able to move to the simulated

532
00:18:52,480 --> 00:18:55,120
decoding procedure without breaking

533
00:18:55,120 --> 00:18:58,240
the scheme security of this game

534
00:18:58,240 --> 00:18:59,840
so here's the problem in detail and

535
00:18:59,840 --> 00:19:01,280
where it comes up

536
00:19:01,280 --> 00:19:03,679
so once we in the proof once we simulate

537
00:19:03,679 --> 00:19:06,000
the zero knowledge proof

538
00:19:06,000 --> 00:19:09,280
we are and we're trying to move to the

539
00:19:09,280 --> 00:19:11,200
to the alternate decoding where we

540
00:19:11,200 --> 00:19:12,720
extract from the

541
00:19:12,720 --> 00:19:14,000
where we extract from the non-member

542
00:19:14,000 --> 00:19:16,720
commitment uh two conditions must be

543
00:19:16,720 --> 00:19:18,480
satisfied

544
00:19:18,480 --> 00:19:20,160
the first is that the extractor of the

545
00:19:20,160 --> 00:19:21,760
non-malleable commitment should not be

546
00:19:21,760 --> 00:19:24,240
able to break their knowledge the second

547
00:19:24,240 --> 00:19:26,000
one is that the simulator should not be

548
00:19:26,000 --> 00:19:28,000
able to break down malleability but we

549
00:19:28,000 --> 00:19:30,240
get two inequalities

550
00:19:30,240 --> 00:19:31,679
also

551
00:19:31,679 --> 00:19:34,080
for all known one messenger zero

552
00:19:34,080 --> 00:19:35,039
knowledge

553
00:19:35,039 --> 00:19:36,320
schemes

554
00:19:36,320 --> 00:19:38,000
for all of them the simulator simulator

555
00:19:38,000 --> 00:19:40,160
running time is larger than the time of

556
00:19:40,160 --> 00:19:42,480
uh then larger than the guarantee of

557
00:19:42,480 --> 00:19:44,320
zero knowledge like the distinct

558
00:19:44,320 --> 00:19:45,679
running time of the

559
00:19:45,679 --> 00:19:47,280
of the distinguisher in the zero

560
00:19:47,280 --> 00:19:49,039
knowledge experiment

561
00:19:49,039 --> 00:19:50,720
and it's a major open problem to

562
00:19:50,720 --> 00:19:52,400
construct one where the inequality is

563
00:19:52,400 --> 00:19:55,679
reversed and the simulator is after

564
00:19:55,679 --> 00:19:58,400
it's really fast

565
00:19:58,880 --> 00:20:00,960
so we cannot use that so if you take the

566
00:20:00,960 --> 00:20:03,039
three inequalities that are written now

567
00:20:03,039 --> 00:20:04,960
you see that the time to extract has to

568
00:20:04,960 --> 00:20:07,840
be much smaller than non-valuability

569
00:20:07,840 --> 00:20:09,280
and which is a contradiction right

570
00:20:09,280 --> 00:20:11,600
because the structure of the commitment

571
00:20:11,600 --> 00:20:13,440
can extract the underlying value and

572
00:20:13,440 --> 00:20:15,600
should and can trivially break normal

573
00:20:15,600 --> 00:20:16,880
ability

574
00:20:16,880 --> 00:20:19,120
so we get a contradiction at least

575
00:20:19,120 --> 00:20:20,640
in the usual

576
00:20:20,640 --> 00:20:22,559
proof strategy

577
00:20:22,559 --> 00:20:24,880
the main idea in the proof is to take

578
00:20:24,880 --> 00:20:26,720
advantage of the specific primitives

579
00:20:26,720 --> 00:20:28,960
that we're using and specifically we're

580
00:20:28,960 --> 00:20:31,440
going to introduce in the crew another

581
00:20:31,440 --> 00:20:33,480
axis of harness specifically in

582
00:20:33,480 --> 00:20:35,360
non-uniformity we're going to

583
00:20:35,360 --> 00:20:37,280
instantiate the primitives in a very

584
00:20:37,280 --> 00:20:39,840
careful way so that

585
00:20:39,840 --> 00:20:42,559
the inequalities that we need work out

586
00:20:42,559 --> 00:20:44,400
what we're going to do is to instantiate

587
00:20:44,400 --> 00:20:46,799
the zero-knowledge system to be zero

588
00:20:46,799 --> 00:20:48,720
knowledge against sub exponential size

589
00:20:48,720 --> 00:20:50,000
attackers

590
00:20:50,000 --> 00:20:51,440
while uh

591
00:20:51,440 --> 00:20:53,600
while showing that simulation can be

592
00:20:53,600 --> 00:20:56,480
done in polynomial size but

593
00:20:56,480 --> 00:20:59,760
using a non-uniform simulator that has

594
00:20:59,760 --> 00:21:01,840
some advice art

595
00:21:01,840 --> 00:21:04,159
non-variability is going to be for a

596
00:21:04,159 --> 00:21:07,280
polynomial size attackers and extraction

597
00:21:07,280 --> 00:21:11,039
will be possible in sub-exponential size

598
00:21:11,039 --> 00:21:12,880
if you stir this for two minutes you'll

599
00:21:12,880 --> 00:21:15,360
see that setting the parameters of the

600
00:21:15,360 --> 00:21:17,440
schemes of the primitives

601
00:21:17,440 --> 00:21:19,760
in this way you indeed satisfy the three

602
00:21:19,760 --> 00:21:21,600
inequalities that we need

603
00:21:21,600 --> 00:21:24,400
extractor cannot break your knowledge

604
00:21:24,400 --> 00:21:25,919
the simulator cannot break

605
00:21:25,919 --> 00:21:28,720
non-variability and the extractor can

606
00:21:28,720 --> 00:21:30,400
break normally

607
00:21:30,400 --> 00:21:32,159
before concluding let me mention a

608
00:21:32,159 --> 00:21:34,960
couple of more technical challenges that

609
00:21:34,960 --> 00:21:37,280
we encounter during the proof the first

610
00:21:37,280 --> 00:21:39,360
challenge is that

611
00:21:39,360 --> 00:21:41,600
the time of puzzles are a polynomial

612
00:21:41,600 --> 00:21:43,919
time primitive an adversary that runs in

613
00:21:43,919 --> 00:21:45,280
polynomial time

614
00:21:45,280 --> 00:21:47,600
can solve the time of puzzle

615
00:21:47,600 --> 00:21:49,600
so in particular the

616
00:21:49,600 --> 00:21:52,480
step in the proof or the the step in the

617
00:21:52,480 --> 00:21:54,880
reduction where we use the hardest of

618
00:21:54,880 --> 00:21:56,559
the time of puzzle

619
00:21:56,559 --> 00:22:00,000
must be implemented in polynomial time

620
00:22:00,000 --> 00:22:01,840
and this seems a priori a little bit

621
00:22:01,840 --> 00:22:03,679
challenging but the point is that the

622
00:22:03,679 --> 00:22:06,480
thumbnail puzzles are polynomial time in

623
00:22:06,480 --> 00:22:09,520
terms of depth or parallel time but they

624
00:22:09,520 --> 00:22:12,159
don't have to be polynomial time in size

625
00:22:12,159 --> 00:22:14,320
namely we instantiate the time of puzzle

626
00:22:14,320 --> 00:22:15,440
in a way

627
00:22:15,440 --> 00:22:16,640
that

628
00:22:16,640 --> 00:22:18,960
it's secure for attackers that have that

629
00:22:18,960 --> 00:22:21,600
might have super polynomial size but

630
00:22:21,600 --> 00:22:22,480
some

631
00:22:22,480 --> 00:22:25,120
polynomial fixed polynomial depth

632
00:22:25,120 --> 00:22:27,039
and this is how we implement this step

633
00:22:27,039 --> 00:22:28,480
in the reduction

634
00:22:28,480 --> 00:22:30,080
the second challenge is that

635
00:22:30,080 --> 00:22:32,000
non-uniformity needs to be dealt with

636
00:22:32,000 --> 00:22:33,280
carefully

637
00:22:33,280 --> 00:22:35,679
and the reason is that the instantiation

638
00:22:35,679 --> 00:22:37,200
of the zero knowledge system that we're

639
00:22:37,200 --> 00:22:38,240
using

640
00:22:38,240 --> 00:22:40,320
because we're in the uniform setting and

641
00:22:40,320 --> 00:22:42,159
the zero knowledge system is a one

642
00:22:42,159 --> 00:22:44,640
message system there's no crs there's no

643
00:22:44,640 --> 00:22:46,400
there's only one message

644
00:22:46,400 --> 00:22:48,799
then the system only satisfies a weak

645
00:22:48,799 --> 00:22:51,520
notion of soundness and this weak notion

646
00:22:51,520 --> 00:22:53,919
of soundness roughly very roughly means

647
00:22:53,919 --> 00:22:56,000
that the adversary might know some

648
00:22:56,000 --> 00:22:58,720
amount of cheating proofs or proofs for

649
00:22:58,720 --> 00:23:00,880
uh valid proofs for false statements but

650
00:23:00,880 --> 00:23:03,039
not too many of them and the proof needs

651
00:23:03,039 --> 00:23:05,679
to take this into account and we need to

652
00:23:05,679 --> 00:23:07,840
deal with it i'll refer to the paper for

653
00:23:07,840 --> 00:23:09,600
more details

654
00:23:09,600 --> 00:23:12,960
so let me summarize our results uh

655
00:23:12,960 --> 00:23:14,880
so the result is a non-valuable code for

656
00:23:14,880 --> 00:23:17,679
all bounded polynomial depth attackers

657
00:23:17,679 --> 00:23:19,840
uh the construction is in the plane

658
00:23:19,840 --> 00:23:21,360
model without any trusted setup

659
00:23:21,360 --> 00:23:22,720
assumptions

660
00:23:22,720 --> 00:23:24,320
the construction can be viewed because

661
00:23:24,320 --> 00:23:27,760
we get hardness for parallel time

662
00:23:27,760 --> 00:23:30,159
for a priori bounded polynomially

663
00:23:30,159 --> 00:23:32,720
bounded parallel time the construction

664
00:23:32,720 --> 00:23:34,400
can be actually viewed as a non-valuable

665
00:23:34,400 --> 00:23:36,400
time lock puzzle so we're taking a

666
00:23:36,400 --> 00:23:38,960
timelock puzzle and we're

667
00:23:38,960 --> 00:23:41,760
making it non-malleable

668
00:23:41,760 --> 00:23:44,559
and in the follow-up work we

669
00:23:44,559 --> 00:23:46,159
it was together with a

670
00:23:46,159 --> 00:23:49,520
frying flight again pass we perform a

671
00:23:49,520 --> 00:23:51,440
thorough study of non-valuable timelock

672
00:23:51,440 --> 00:23:53,120
puzzles we have more efficient

673
00:23:53,120 --> 00:23:55,120
constructions and what is presented here

674
00:23:55,120 --> 00:23:57,840
which is primarily the theoretical and

675
00:23:57,840 --> 00:23:59,440
feasibility results

676
00:23:59,440 --> 00:24:01,039
there we have a really practical and

677
00:24:01,039 --> 00:24:02,720
efficient construction

678
00:24:02,720 --> 00:24:05,360
with very weak set of assumptions

679
00:24:05,360 --> 00:24:07,840
and we also showed that this primitive

680
00:24:07,840 --> 00:24:10,159
is really useful for applications and

681
00:24:10,159 --> 00:24:11,760
for instance we get multi-party fair

682
00:24:11,760 --> 00:24:13,520
quality protocols

683
00:24:13,520 --> 00:24:17,600
and multi-party fare auctions and so on

684
00:24:17,600 --> 00:24:18,400
and

685
00:24:18,400 --> 00:24:21,039
i think that this work uh

686
00:24:21,039 --> 00:24:22,960
introduces a couple of very interesting

687
00:24:22,960 --> 00:24:24,640
open problems the first is to improve

688
00:24:24,640 --> 00:24:26,400
the assumptions prove the underlying

689
00:24:26,400 --> 00:24:27,760
assumptions of course

690
00:24:27,760 --> 00:24:30,880
and mostly the thing to to focus on in

691
00:24:30,880 --> 00:24:32,960
my opinion is the keyless hash function

692
00:24:32,960 --> 00:24:34,080
that

693
00:24:34,080 --> 00:24:35,760
we rely on

694
00:24:35,760 --> 00:24:36,559
and

695
00:24:36,559 --> 00:24:38,159
of course the concrete efficiency of our

696
00:24:38,159 --> 00:24:39,840
scheme is not that great if you use

697
00:24:39,840 --> 00:24:41,600
existing construction existing

698
00:24:41,600 --> 00:24:43,600
instantiation of all the schemes and it

699
00:24:43,600 --> 00:24:46,159
would be interesting to come up with a

700
00:24:46,159 --> 00:24:48,240
with an efficient construction a

701
00:24:48,240 --> 00:24:50,320
practically efficient construction

702
00:24:50,320 --> 00:24:52,720
without setup assumptions

703
00:24:52,720 --> 00:24:54,559
so thank you very much

704
00:24:54,559 --> 00:24:59,080
for listening and have a good day

