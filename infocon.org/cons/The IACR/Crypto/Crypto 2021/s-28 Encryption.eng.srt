1
00:00:01,280 --> 00:00:03,919
you are

2
00:00:03,919 --> 00:00:05,440
ready to start the session have a good

3
00:00:05,440 --> 00:00:06,640
one

4
00:00:06,640 --> 00:00:08,240
thank you

5
00:00:08,240 --> 00:00:11,360
all right welcome everyone uh for

6
00:00:11,360 --> 00:00:13,599
the session encryption plus plus for

7
00:00:13,599 --> 00:00:16,400
crypto 2021

8
00:00:16,400 --> 00:00:19,039
as you probably know we will have uh

9
00:00:19,039 --> 00:00:21,920
five short talks around five minutes

10
00:00:21,920 --> 00:00:25,199
each and then uh 25 minutes of q a

11
00:00:25,199 --> 00:00:28,320
session or you can ask questions

12
00:00:28,320 --> 00:00:30,880
via the zulip chat

13
00:00:30,880 --> 00:00:32,479
whose link is going to show up or

14
00:00:32,479 --> 00:00:33,760
directly

15
00:00:33,760 --> 00:00:36,559
on zoom by raising your hand

16
00:00:36,559 --> 00:00:39,200
okay so the first talk we will hear in

17
00:00:39,200 --> 00:00:40,399
this session

18
00:00:40,399 --> 00:00:42,960
is by waitakui and he will be talking

19
00:00:42,960 --> 00:00:46,000
about broadcast encryption with size 10

20
00:00:46,000 --> 00:00:50,239
to the one-third and more from kailin

21
00:00:51,120 --> 00:00:53,920
all right uh can everyone hear me

22
00:00:53,920 --> 00:00:56,160
okay so i'll be talking about uh

23
00:00:56,160 --> 00:00:58,239
broadcast encryption so let me start by

24
00:00:58,239 --> 00:01:00,399
defining a constitution in process

25
00:01:00,399 --> 00:01:02,480
encryption of the sender and end users

26
00:01:02,480 --> 00:01:04,720
and the sender wants to send a encrypted

27
00:01:04,720 --> 00:01:07,760
message to some of these users so that

28
00:01:07,760 --> 00:01:09,439
any user in the set will be able to

29
00:01:09,439 --> 00:01:11,439
decrypt the message with that individual

30
00:01:11,439 --> 00:01:14,240
secret key and in addition and user

31
00:01:14,240 --> 00:01:16,159
outside the step should learn nothing

32
00:01:16,159 --> 00:01:18,240
whatsoever about the message even if

33
00:01:18,240 --> 00:01:19,600
they could do it

34
00:01:19,600 --> 00:01:21,920
so our goal in broadcast encryption is

35
00:01:21,920 --> 00:01:24,000
to obtain a broadcast encryption skills

36
00:01:24,000 --> 00:01:26,400
with short parameters which i mean

37
00:01:26,400 --> 00:01:28,720
public key size short circuit exercise

38
00:01:28,720 --> 00:01:30,479
and short secret keys

39
00:01:30,479 --> 00:01:32,880
so what's wonderful broadcast encryption

40
00:01:32,880 --> 00:01:34,240
so there's actually a very simple

41
00:01:34,240 --> 00:01:36,079
construction overcast encryption skills

42
00:01:36,079 --> 00:01:37,840
from any public key encryption schemes

43
00:01:37,840 --> 00:01:39,920
that will choose linear size parameters

44
00:01:39,920 --> 00:01:42,159
where linear here means uh the natural

45
00:01:42,159 --> 00:01:44,240
number of uses

46
00:01:44,240 --> 00:01:47,439
and uh in 2005 for the general motors

47
00:01:47,439 --> 00:01:48,880
give the first broadcast encryption

48
00:01:48,880 --> 00:01:51,360
scheme with sub linear size square root

49
00:01:51,360 --> 00:01:53,360
and size parameters the construction

50
00:01:53,360 --> 00:01:56,320
relies on pairings and since this 2005

51
00:01:56,320 --> 00:01:58,079
work the big open problem in both

52
00:01:58,079 --> 00:01:59,840
paragraphs crypto and broadcast

53
00:01:59,840 --> 00:02:02,560
encryption is to go below this scroll

54
00:02:02,560 --> 00:02:04,399
area

55
00:02:04,399 --> 00:02:07,439
and in 2015 we showed that it's unlikely

56
00:02:07,439 --> 00:02:09,440
that we can pick this code and bounce

57
00:02:09,440 --> 00:02:11,038
using pairings and this will show that

58
00:02:11,038 --> 00:02:13,200
this square of n is optimal for a large

59
00:02:13,200 --> 00:02:15,440
class of our current base cubes

60
00:02:15,440 --> 00:02:17,440
so it's only last year that we have the

61
00:02:17,440 --> 00:02:18,959
first improvement to the square root of

62
00:02:18,959 --> 00:02:21,360
n construction from standard assumptions

63
00:02:21,360 --> 00:02:23,120
namely the work of

64
00:02:23,120 --> 00:02:25,440
your mother giving a polylog and scheme

65
00:02:25,440 --> 00:02:27,360
assuming pairings and additionally the

66
00:02:27,360 --> 00:02:29,760
lw assumption

67
00:02:29,760 --> 00:02:31,519
so our main result in this work is a

68
00:02:31,519 --> 00:02:33,440
different way to go with those groupings

69
00:02:33,440 --> 00:02:34,840
namely we give the first cell

70
00:02:34,840 --> 00:02:37,519
broadcaster plus the current basic block

71
00:02:37,519 --> 00:02:39,440
transformation scheme where the total

72
00:02:39,440 --> 00:02:41,599
parameter size is entered one

73
00:02:41,599 --> 00:02:43,360
in particular this end of the one that

74
00:02:43,360 --> 00:02:47,360
beats our previous lower bound of square

75
00:02:47,360 --> 00:02:48,720
our construction achieves adaptive

76
00:02:48,720 --> 00:02:51,280
security under the bilateral assumption

77
00:02:51,280 --> 00:02:53,120
i want to emphasize here that prior to

78
00:02:53,120 --> 00:02:55,200
this book even achieving selective

79
00:02:55,200 --> 00:02:57,680
security in the general model and to the

80
00:02:57,680 --> 00:03:00,720
wi-fi science parameters

81
00:03:01,519 --> 00:03:03,840
so the main cultural conceptual insight

82
00:03:03,840 --> 00:03:05,360
in this work that allows us to beat the

83
00:03:05,360 --> 00:03:07,760
previous uh squirrel and the mobile is

84
00:03:07,760 --> 00:03:10,080
the use of quadratic reconstruction this

85
00:03:10,080 --> 00:03:12,400
is an idea of first uh introducing joint

86
00:03:12,400 --> 00:03:14,959
work with value and dynamic in the

87
00:03:14,959 --> 00:03:17,120
context of information directed

88
00:03:17,120 --> 00:03:19,280
sharing and to implement this framework

89
00:03:19,280 --> 00:03:21,440
we will also be able to rely on

90
00:03:21,440 --> 00:03:24,319
additional ideas from other literature

91
00:03:24,319 --> 00:03:25,760
on our functional encryption

92
00:03:25,760 --> 00:03:28,000
particularly to polynomials

93
00:03:28,000 --> 00:03:30,080
uh without proper case encryption is

94
00:03:30,080 --> 00:03:31,440
actually a special case of a more

95
00:03:31,440 --> 00:03:34,080
general result than the c p abe for

96
00:03:34,080 --> 00:03:36,080
degree 3 polynomials that achieves

97
00:03:36,080 --> 00:03:38,560
optimal parameter size namely the total

98
00:03:38,560 --> 00:03:40,560
parameter size depends only on the

99
00:03:40,560 --> 00:03:42,480
number of variables in the polynomial

100
00:03:42,480 --> 00:03:44,400
which we call it action

101
00:03:44,400 --> 00:03:45,840
so for the rest of this talk i'm going

102
00:03:45,840 --> 00:03:47,840
to focus on the cpav skill preparation

103
00:03:47,840 --> 00:03:49,920
for dominance let me give a quick recap

104
00:03:49,920 --> 00:03:51,920
of what cpav is

105
00:03:51,920 --> 00:03:54,080
in cp abe our ciphertext are associated

106
00:03:54,080 --> 00:03:57,200
with function f and secret key super

107
00:03:57,200 --> 00:04:00,239
input x to the function f and uh

108
00:04:00,239 --> 00:04:02,000
decryption should be possible when f of

109
00:04:02,000 --> 00:04:04,239
x is not equal to zero and security

110
00:04:04,239 --> 00:04:06,400
should hold when f of x is zero it will

111
00:04:06,400 --> 00:04:08,239
have conclusions

112
00:04:08,239 --> 00:04:09,840
all right so in this one we are going to

113
00:04:09,840 --> 00:04:10,799
be looking at the right three

114
00:04:10,799 --> 00:04:13,200
polynomials which we're going to specify

115
00:04:13,200 --> 00:04:15,360
by thinking of the input as three

116
00:04:15,360 --> 00:04:17,759
vectors of like m or with that p

117
00:04:17,759 --> 00:04:20,000
and the uh function that we have now

118
00:04:20,000 --> 00:04:21,839
we're specified by coefficient vector

119
00:04:21,839 --> 00:04:23,759
which is less than q

120
00:04:23,759 --> 00:04:25,520
and uh as a warm up towards this

121
00:04:25,520 --> 00:04:27,199
construction of construction for degree

122
00:04:27,199 --> 00:04:29,199
three points we'll also be looking at

123
00:04:29,199 --> 00:04:30,960
two functions where the coefficient

124
00:04:30,960 --> 00:04:32,800
vector has left scope

125
00:04:32,800 --> 00:04:35,199
so our starting point is the cpav scheme

126
00:04:35,199 --> 00:04:36,880
particularly two polynomials that

127
00:04:36,880 --> 00:04:38,800
achieve optimal parameter size so total

128
00:04:38,800 --> 00:04:40,960
parameter size

129
00:04:40,960 --> 00:04:43,840
and degree number is variables uh that

130
00:04:43,840 --> 00:04:46,320
are input distributed

131
00:04:46,320 --> 00:04:49,040
uh in this construction in the cpa b for

132
00:04:49,040 --> 00:04:51,440
degree two polynomials the muscle public

133
00:04:51,440 --> 00:04:54,000
key contains two vectors of length uh

134
00:04:54,000 --> 00:04:58,240
w1w2 is encoded in the first g1 and

135
00:04:58,240 --> 00:05:00,080
alpha which is scanner and you can think

136
00:05:00,080 --> 00:05:01,680
of this as the master sequence key which

137
00:05:01,680 --> 00:05:04,160
is encoded

138
00:05:04,160 --> 00:05:06,240
for this uh overview it's sufficient to

139
00:05:06,240 --> 00:05:07,919
just look at the first part the first

140
00:05:07,919 --> 00:05:10,080
component of 7x and the first component

141
00:05:10,080 --> 00:05:11,840
of the second key

142
00:05:11,840 --> 00:05:13,199
which looks basically what you want is

143
00:05:13,199 --> 00:05:14,080
like

144
00:05:14,080 --> 00:05:15,759
and now what we want to do is to start

145
00:05:15,759 --> 00:05:18,320
from the cp avee for typical polynomials

146
00:05:18,320 --> 00:05:21,360
and get to our cp abe for division

147
00:05:21,360 --> 00:05:23,440
so very natural thing to do is to take

148
00:05:23,440 --> 00:05:27,759
this scheme and replace x2 by x2

149
00:05:27,759 --> 00:05:30,800
x3 and once you make this change a very

150
00:05:30,800 --> 00:05:32,800
natural thing to do next is to replace

151
00:05:32,800 --> 00:05:34,479
the vector w2

152
00:05:34,479 --> 00:05:37,520
with the tensor of the v2 and w3 whereas

153
00:05:37,520 --> 00:05:40,000
w3 is a random vector of length n that's

154
00:05:40,000 --> 00:05:42,400
also controlled by the set of numbers

155
00:05:42,400 --> 00:05:44,160
now once you make this change you get

156
00:05:44,160 --> 00:05:45,840
the following cp-abe scheme for the

157
00:05:45,840 --> 00:05:47,840
retrieve polynomials where your sample

158
00:05:47,840 --> 00:05:50,160
text still has linear sizes before but

159
00:05:50,160 --> 00:05:52,800
your secret key now has quadratic size

160
00:05:52,800 --> 00:05:55,039
because of the actual tensor x3 or the

161
00:05:55,039 --> 00:05:56,319
w2

162
00:05:56,319 --> 00:05:58,319
uh w2

163
00:05:58,319 --> 00:06:00,080
the first thing i'm going to do is to

164
00:06:00,080 --> 00:06:03,199
get the secret key size down to um all

165
00:06:03,199 --> 00:06:05,840
the angle elements by basically showing

166
00:06:05,840 --> 00:06:08,000
how to compute this vector of an x

167
00:06:08,000 --> 00:06:11,280
squared using just uh angle elements

168
00:06:11,280 --> 00:06:13,759
so starting point would be to publish in

169
00:06:13,759 --> 00:06:16,160
the secret key and algebra encryption of

170
00:06:16,160 --> 00:06:18,240
x3 comes into l1 and this is the idea

171
00:06:18,240 --> 00:06:19,840
that comes from for the ritual

172
00:06:19,840 --> 00:06:21,759
polynomials and once you have disturbed

173
00:06:21,759 --> 00:06:23,280
the very natural way to try to compute

174
00:06:23,280 --> 00:06:25,039
that degree uh and split sense

175
00:06:25,039 --> 00:06:28,240
expression is tensor this term with x2

176
00:06:28,240 --> 00:06:30,080
you get a bunch of extra prosthetics

177
00:06:30,080 --> 00:06:31,919
which says that you can cancel by

178
00:06:31,919 --> 00:06:33,840
publishing just a linear number of

179
00:06:33,840 --> 00:06:35,520
elements maybe the ones that you see on

180
00:06:35,520 --> 00:06:36,560
the slide

181
00:06:36,560 --> 00:06:39,520
so once you do this you get a cpap skill

182
00:06:39,520 --> 00:06:41,520
but the retrieve polynomials with linear

183
00:06:41,520 --> 00:06:44,240
cyber text size and linear key size but

184
00:06:44,240 --> 00:06:47,039
the problem however is that now we have

185
00:06:47,039 --> 00:06:48,720
we still have a quadratic size muscle

186
00:06:48,720 --> 00:06:50,160
property

187
00:06:50,160 --> 00:06:52,000
and our next idea is basically to reduce

188
00:06:52,000 --> 00:06:54,479
this uh probability key size to n by

189
00:06:54,479 --> 00:06:56,800
essentially having the encryption

190
00:06:56,800 --> 00:06:59,520
algorithm big to better w3 so that we no

191
00:06:59,520 --> 00:07:01,840
longer look at only so that suffices to

192
00:07:01,840 --> 00:07:03,599
just publish other two in the master

193
00:07:03,599 --> 00:07:05,440
public key and this creates some

194
00:07:05,440 --> 00:07:06,960
additional problems because the key

195
00:07:06,960 --> 00:07:08,880
generation algorithm will no longer be

196
00:07:08,880 --> 00:07:10,400
able to copy the cluster which depends

197
00:07:10,400 --> 00:07:12,400
on w3 and we need a couple more

198
00:07:12,400 --> 00:07:14,960
modifications

199
00:07:14,960 --> 00:07:16,880
and then basically complete uh conflict

200
00:07:16,880 --> 00:07:19,280
overview so the conclusion we represent

201
00:07:19,280 --> 00:07:20,880
if there's a broadcast encryption and

202
00:07:20,880 --> 00:07:23,599
cpu dvd comparing that breaks this uh

203
00:07:23,599 --> 00:07:25,280
price code and barrier you take this

204
00:07:25,280 --> 00:07:27,360
idea of project reconstruction i just

205
00:07:27,360 --> 00:07:28,960
want to say that there's still a bunch

206
00:07:28,960 --> 00:07:31,599
of very exciting open problems in

207
00:07:31,599 --> 00:07:33,919
broadcast conclusions both from paris

208
00:07:33,919 --> 00:07:35,599
and phoenix

209
00:07:35,599 --> 00:07:38,759
thank you

210
00:07:44,639 --> 00:07:47,120
all right thank you

211
00:07:47,120 --> 00:07:49,039
i don't see any questions so let's move

212
00:07:49,039 --> 00:07:51,680
on to the next talk

213
00:07:51,680 --> 00:07:54,000
uh

214
00:07:55,759 --> 00:07:56,639
which

215
00:07:56,639 --> 00:07:59,360
is going to be about fine-grained secure

216
00:07:59,360 --> 00:08:01,520
attribute-based encryption

217
00:08:01,520 --> 00:08:03,280
by you you won't

218
00:08:03,280 --> 00:08:05,759
yashin pan and new chen

219
00:08:05,759 --> 00:08:09,280
and you you won is gonna give the talk

220
00:08:09,280 --> 00:08:12,840
whenever you're ready

221
00:08:13,599 --> 00:08:17,280
okay thank you for the introduction

222
00:08:18,160 --> 00:08:20,800
so hello everyone i'm yuan i'm from

223
00:08:20,800 --> 00:08:23,840
uestc our title is vanguard and secure

224
00:08:23,840 --> 00:08:25,599
attribute-based encryption let's join

225
00:08:25,599 --> 00:08:29,120
the work with justinpander

226
00:08:30,160 --> 00:08:31,840
so as you know

227
00:08:31,840 --> 00:08:34,240
for standard cryptographic scheme we

228
00:08:34,240 --> 00:08:36,320
usually require that this party can run

229
00:08:36,320 --> 00:08:38,000
the scheme important moment time and the

230
00:08:38,000 --> 00:08:40,080
scheme can be secured against polynomial

231
00:08:40,080 --> 00:08:42,159
time anniversaries by now there have

232
00:08:42,159 --> 00:08:44,320
been a great deal of primitives that are

233
00:08:44,320 --> 00:08:45,839
secure against

234
00:08:45,839 --> 00:08:47,440
that are secure on the various

235
00:08:47,440 --> 00:08:49,680
assumptions proposed such as the one-way

236
00:08:49,680 --> 00:08:51,600
functioning factor industry logarithm

237
00:08:51,600 --> 00:08:52,720
ddh

238
00:08:52,720 --> 00:08:54,080
but we don't know whether these

239
00:08:54,080 --> 00:08:55,760
assumptions hold so

240
00:08:55,760 --> 00:08:58,160
uh it's desirable to

241
00:08:58,160 --> 00:09:00,480
for example design some primitive uh

242
00:09:00,480 --> 00:09:02,880
under no assumption or just some mild

243
00:09:02,880 --> 00:09:05,360
complexity worst case or something

244
00:09:05,360 --> 00:09:06,480
but

245
00:09:06,480 --> 00:09:08,880
uh it has turned out that this is quite

246
00:09:08,880 --> 00:09:11,519
difficult so the fingering cryptography

247
00:09:11,519 --> 00:09:13,360
gives us approach

248
00:09:13,360 --> 00:09:15,760
uh gives us a direct team approaching

249
00:09:15,760 --> 00:09:18,800
this problem in the penguin cryptography

250
00:09:18,800 --> 00:09:21,440
we only require that the onus party uses

251
00:09:21,440 --> 00:09:23,760
less resources than the adversary and

252
00:09:23,760 --> 00:09:26,560
the adversary other the resources of the

253
00:09:26,560 --> 00:09:29,120
adversary can be a prior bonding

254
00:09:29,120 --> 00:09:31,120
so in this setting it's possible to make

255
00:09:31,120 --> 00:09:34,640
the online assumption extremely weak

256
00:09:34,640 --> 00:09:36,560
by now there have been

257
00:09:36,560 --> 00:09:38,720
many franklin primitives proposed such

258
00:09:38,720 --> 00:09:41,040
as key exchange one-way function pke

259
00:09:41,040 --> 00:09:43,120
verifiable computation and hash proof

260
00:09:43,120 --> 00:09:44,160
system

261
00:09:44,160 --> 00:09:46,160
but there are still many important

262
00:09:46,160 --> 00:09:47,920
primitives that are missed such as

263
00:09:47,920 --> 00:09:50,320
signature

264
00:09:50,320 --> 00:09:52,560
so in this work we proposed the first

265
00:09:52,560 --> 00:09:55,600
fine green secure av scheme

266
00:09:55,600 --> 00:09:58,160
our scheme borrows the bkp framework by

267
00:09:58,160 --> 00:10:00,640
blister and others which constructed ib

268
00:10:00,640 --> 00:10:04,079
from 5 mac and also the chw framework by

269
00:10:04,079 --> 00:10:06,480
chiang and others which constructed abu

270
00:10:06,480 --> 00:10:07,600
from

271
00:10:07,600 --> 00:10:10,079
predicating buildings

272
00:10:10,079 --> 00:10:13,600
so we first generalized the a5 mic in

273
00:10:13,600 --> 00:10:16,640
the bkp framework by making use of part

274
00:10:16,640 --> 00:10:18,959
of the very predicate encoding in the

275
00:10:18,959 --> 00:10:22,000
chw framework and then combine the

276
00:10:22,000 --> 00:10:24,399
generalized version of the pharmacy with

277
00:10:24,399 --> 00:10:26,240
other parts of the predicate including

278
00:10:26,240 --> 00:10:29,760
to to achieve the ap scheme

279
00:10:29,760 --> 00:10:31,519
by instantiating the underlying

280
00:10:31,519 --> 00:10:32,959
predicate including

281
00:10:32,959 --> 00:10:35,360
in our general reconstruction we can

282
00:10:35,360 --> 00:10:36,560
obtain

283
00:10:36,560 --> 00:10:39,279
an ib scheme which in turn implies the

284
00:10:39,279 --> 00:10:41,519
signature scheme and also many types of

285
00:10:41,519 --> 00:10:43,920
abe schemes and also the

286
00:10:43,920 --> 00:10:46,480
broadcast encryption and fuzzy ib in the

287
00:10:46,480 --> 00:10:48,720
fan green setting

288
00:10:48,720 --> 00:10:51,040
all of the instantiations are computable

289
00:10:51,040 --> 00:10:54,320
in ac02 and secure against

290
00:10:54,320 --> 00:10:58,079
adversaries in nc1 notice that ac02 is

291
00:10:58,079 --> 00:11:00,959
included in nc1 so the owner's party

292
00:11:00,959 --> 00:11:03,920
uses less resources than the adversaries

293
00:11:03,920 --> 00:11:06,640
and the assumption is that ncy is not

294
00:11:06,640 --> 00:11:09,440
equal to parity l-40

295
00:11:09,440 --> 00:11:12,560
and all the computations are over

296
00:11:12,560 --> 00:11:15,760
gf2 notice that uh this assumption is

297
00:11:15,760 --> 00:11:18,480
widely believed to hold and this setting

298
00:11:18,480 --> 00:11:20,480
is exactly the same as the boundary

299
00:11:20,480 --> 00:11:23,839
circuit city previous works on penguin

300
00:11:23,839 --> 00:11:26,079
cryptography

301
00:11:26,079 --> 00:11:28,720
so our starting point is the bkp

302
00:11:28,720 --> 00:11:31,760
framework which constructed ib from a

303
00:11:31,760 --> 00:11:34,720
pharmac the pharmac was uh secure under

304
00:11:34,720 --> 00:11:35,920
the nvidia

305
00:11:35,920 --> 00:11:38,079
mddh assumption

306
00:11:38,079 --> 00:11:40,480
and the converging from the pharmac to

307
00:11:40,480 --> 00:11:42,720
the ib scheme heavily relies on the

308
00:11:42,720 --> 00:11:45,200
symmetric pairing and it's necessary to

309
00:11:45,200 --> 00:11:47,600
compute the inverse of a matrix in the

310
00:11:47,600 --> 00:11:50,000
security proof

311
00:11:50,000 --> 00:11:53,040
but unfortunately we don't have adding

312
00:11:53,040 --> 00:11:56,079
any pairing or nvidia assumption in the

313
00:11:56,079 --> 00:11:57,839
nc1 world

314
00:11:57,839 --> 00:12:00,480
and also we cannot compute the inverse

315
00:12:00,480 --> 00:12:04,000
of matrix in c1

316
00:12:04,000 --> 00:12:07,040
so instead of making use of the nvidia

317
00:12:07,040 --> 00:12:10,079
mddh assumption we make use of a new

318
00:12:10,079 --> 00:12:12,399
hard subset membership problem proposed

319
00:12:12,399 --> 00:12:14,560
by agusta and others

320
00:12:14,560 --> 00:12:17,839
this how this hard problem holds if the

321
00:12:17,839 --> 00:12:19,760
complexity problem

322
00:12:19,760 --> 00:12:22,880
i mentioned before holds

323
00:12:22,880 --> 00:12:25,600
and for the ib scheme the crucial step

324
00:12:25,600 --> 00:12:27,279
in the security proof

325
00:12:27,279 --> 00:12:30,480
is that uh it is to design a reduction

326
00:12:30,480 --> 00:12:32,639
algorithm which breaks the security of

327
00:12:32,639 --> 00:12:34,480
the fire mic

328
00:12:34,480 --> 00:12:37,440
and to achieve this we developed a new

329
00:12:37,440 --> 00:12:40,000
technique to extract the forgery of the

330
00:12:40,000 --> 00:12:42,399
fan mag from the adversary without

331
00:12:42,399 --> 00:12:44,560
computing the inverse of matrix so

332
00:12:44,560 --> 00:12:48,639
that's the reduction can be run in nc1

333
00:12:48,639 --> 00:12:49,680
and

334
00:12:49,680 --> 00:12:50,959
we

335
00:12:50,959 --> 00:12:53,519
used the uh we developed this technique

336
00:12:53,519 --> 00:12:56,079
by making use of several limiter in

337
00:12:56,079 --> 00:12:58,330
uh by

338
00:12:58,330 --> 00:12:59,440
[Music]

339
00:12:59,440 --> 00:13:00,320
the

340
00:13:00,320 --> 00:13:02,720
greek and others and also a custom

341
00:13:02,720 --> 00:13:05,120
analysis

342
00:13:05,120 --> 00:13:07,760
and our construction uh essentially

343
00:13:07,760 --> 00:13:09,920
implemented a dual system without

344
00:13:09,920 --> 00:13:13,519
pairing in the fine grained world

345
00:13:13,519 --> 00:13:16,720
also we note that the uh the

346
00:13:16,720 --> 00:13:18,880
construction essentially used encoding

347
00:13:18,880 --> 00:13:22,560
for equality and by generalizing the

348
00:13:22,560 --> 00:13:25,040
encoding for equality as predicted

349
00:13:25,040 --> 00:13:27,600
including the chw framework we can

350
00:13:27,600 --> 00:13:30,399
achieve the fine-grained av scheme

351
00:13:30,399 --> 00:13:33,040
please see the paper for more details

352
00:13:33,040 --> 00:13:35,920
and this is the conclusion of our work

353
00:13:35,920 --> 00:13:37,519
and

354
00:13:37,519 --> 00:13:39,839
we want to mention that by making use of

355
00:13:39,839 --> 00:13:42,079
our technique we can also achieve an

356
00:13:42,079 --> 00:13:44,880
efficient fingering q in this scheme

357
00:13:44,880 --> 00:13:48,839
so that's all thank you

358
00:13:51,279 --> 00:13:54,000
all right thank you

359
00:13:57,839 --> 00:14:00,560
let's move on to the next talk

360
00:14:00,560 --> 00:14:03,440
which is going to be about multi-input

361
00:14:03,440 --> 00:14:05,920
quantatic functional encryption

362
00:14:05,920 --> 00:14:08,880
from pairings by shwita agarwal

363
00:14:08,880 --> 00:14:12,720
rishab goyal yunichi tomida and rishab

364
00:14:12,720 --> 00:14:14,639
is going to give the talk

365
00:14:14,639 --> 00:14:18,480
you guys can hear me and see my slides

366
00:14:18,480 --> 00:14:19,360
yes

367
00:14:19,360 --> 00:14:21,680
okay great thanks so much okay so

368
00:14:21,680 --> 00:14:23,199
welcome everyone today i'm going to tell

369
00:14:23,199 --> 00:14:25,360
you more about how to build multi-input

370
00:14:25,360 --> 00:14:26,800
quadratic function encryption from

371
00:14:26,800 --> 00:14:28,720
parents

372
00:14:28,720 --> 00:14:31,600
so uh yeah so the starting point of this

373
00:14:31,600 --> 00:14:32,639
talk is the notion of function

374
00:14:32,639 --> 00:14:34,639
encryption function encryption as most

375
00:14:34,639 --> 00:14:36,480
of you might know is a very powerful

376
00:14:36,480 --> 00:14:37,760
notion of encryption which allows

377
00:14:37,760 --> 00:14:40,079
fine-grained access over encrypted data

378
00:14:40,079 --> 00:14:41,600
suppose we have two parties alice

379
00:14:41,600 --> 00:14:43,920
involved and alice has some private

380
00:14:43,920 --> 00:14:46,000
sensitive data m over here and alice

381
00:14:46,000 --> 00:14:48,000
wants to share this data such that a

382
00:14:48,000 --> 00:14:50,480
different party charlie only can learn f

383
00:14:50,480 --> 00:14:52,480
of m the evaluation of function f on the

384
00:14:52,480 --> 00:14:54,240
messaging but nothing else about the

385
00:14:54,240 --> 00:14:55,279
message

386
00:14:55,279 --> 00:14:56,800
so what alice can do is that alice can

387
00:14:56,800 --> 00:14:58,160
typically use the encryption algorithm

388
00:14:58,160 --> 00:14:59,199
to encrypt

389
00:14:59,199 --> 00:15:01,040
its sensitive data and what function

390
00:15:01,040 --> 00:15:02,800
encryption allows us is that it says

391
00:15:02,800 --> 00:15:04,560
that bob which has the master key

392
00:15:04,560 --> 00:15:06,480
material can generate a partial

393
00:15:06,480 --> 00:15:08,480
decryption key such that this partial

394
00:15:08,480 --> 00:15:10,800
decryption key for this function f can

395
00:15:10,800 --> 00:15:12,079
be used to sort of decrypt the

396
00:15:12,079 --> 00:15:14,240
ciphertext and learn only the evaluation

397
00:15:14,240 --> 00:15:16,240
of the function f on the message m

398
00:15:16,240 --> 00:15:18,079
and it basically hides every all the

399
00:15:18,079 --> 00:15:20,240
other information about the message m

400
00:15:20,240 --> 00:15:21,839
and the intuition behind security of

401
00:15:21,839 --> 00:15:23,199
function encryption says that suppose i

402
00:15:23,199 --> 00:15:24,560
give you a ciphertext that you give some

403
00:15:24,560 --> 00:15:25,440
message

404
00:15:25,440 --> 00:15:27,360
and polynomial secret keys for different

405
00:15:27,360 --> 00:15:30,079
functions f1 f2 up to fq then you as an

406
00:15:30,079 --> 00:15:32,160
attacker can only learn the evaluation

407
00:15:32,160 --> 00:15:34,079
of the function f on the current message

408
00:15:34,079 --> 00:15:35,519
but nothing else

409
00:15:35,519 --> 00:15:37,680
so basically you can only learn what you

410
00:15:37,680 --> 00:15:38,800
can learn by running the decryption

411
00:15:38,800 --> 00:15:40,800
algorithm honestly

412
00:15:40,800 --> 00:15:42,160
now functional encryption as in the last

413
00:15:42,160 --> 00:15:43,680
decade we've seen it's tremendously

414
00:15:43,680 --> 00:15:45,360
powerful and has tremendous amount of

415
00:15:45,360 --> 00:15:47,360
applications but there's an interesting

416
00:15:47,360 --> 00:15:49,199
generalization of function encryption to

417
00:15:49,199 --> 00:15:50,800
the notion of multi-input function

418
00:15:50,800 --> 00:15:52,560
encryption in multi-input function

419
00:15:52,560 --> 00:15:54,399
encryption instead of having a single

420
00:15:54,399 --> 00:15:56,240
message source we have multiple input

421
00:15:56,240 --> 00:15:57,279
sources

422
00:15:57,279 --> 00:15:59,279
and now with all these multiple input

423
00:15:59,279 --> 00:16:01,360
sources again charlie wants to learn the

424
00:16:01,360 --> 00:16:03,839
evaluation of function f that it chooses

425
00:16:03,839 --> 00:16:05,920
on all these messages together at the

426
00:16:05,920 --> 00:16:07,440
same time and all these messages are

427
00:16:07,440 --> 00:16:09,360
independently encrypted under their

428
00:16:09,360 --> 00:16:11,040
corresponding encryption keys

429
00:16:11,040 --> 00:16:13,120
a multi-function caption scheme says

430
00:16:13,120 --> 00:16:15,279
that bob again using its master secret

431
00:16:15,279 --> 00:16:17,040
key can generate a partial decryption

432
00:16:17,040 --> 00:16:18,720
key such that this partial decryption

433
00:16:18,720 --> 00:16:21,120
key can be used to learn exactly this

434
00:16:21,120 --> 00:16:23,519
value f of m1 m2 up to

435
00:16:23,519 --> 00:16:24,560
mn

436
00:16:24,560 --> 00:16:26,000
and nothing else about the underlying

437
00:16:26,000 --> 00:16:27,120
messages

438
00:16:27,120 --> 00:16:28,800
and this can be formalized uh this

439
00:16:28,800 --> 00:16:30,079
intuition can be formalized into a

440
00:16:30,079 --> 00:16:31,759
security argument where you basically

441
00:16:31,759 --> 00:16:33,839
say suppose as an university i give you

442
00:16:33,839 --> 00:16:36,320
a polynomially many uh scythe text

443
00:16:36,320 --> 00:16:37,920
encrypting different messages and also

444
00:16:37,920 --> 00:16:39,759
give you follow me many secret keys when

445
00:16:39,759 --> 00:16:41,759
you as an attacker can only learn the

446
00:16:41,759 --> 00:16:43,279
information about the messages that you

447
00:16:43,279 --> 00:16:44,560
can learn by sort of picking and

448
00:16:44,560 --> 00:16:45,920
choosing different septics and running

449
00:16:45,920 --> 00:16:47,120
the decryption algorithm given your

450
00:16:47,120 --> 00:16:49,519
secret key but nothing else

451
00:16:49,519 --> 00:16:50,880
here i'm sort of giving the intuition

452
00:16:50,880 --> 00:16:52,320
the secret key setting where i assume

453
00:16:52,320 --> 00:16:54,240
that the adversary cannot encrypt

454
00:16:54,240 --> 00:16:56,480
messages on its own and it has to always

455
00:16:56,480 --> 00:16:58,320
query the challenger to sort of get

456
00:16:58,320 --> 00:16:59,360
these uh

457
00:16:59,360 --> 00:17:00,560
scifix

458
00:17:00,560 --> 00:17:02,320
you can also sort of uh define it in the

459
00:17:02,320 --> 00:17:03,920
public key setting where the university

460
00:17:03,920 --> 00:17:05,839
can entry messages on its own but there

461
00:17:05,839 --> 00:17:07,119
will be more leakage in that setting

462
00:17:07,119 --> 00:17:08,799
because if the diversity can sort of

463
00:17:08,799 --> 00:17:10,000
just pick messages then it can learn

464
00:17:10,000 --> 00:17:11,119
even more information about the

465
00:17:11,119 --> 00:17:13,439
increment messages

466
00:17:13,439 --> 00:17:15,679
now let's just look at the landscape of

467
00:17:15,679 --> 00:17:17,520
multi-input functionality schemes that

468
00:17:17,520 --> 00:17:20,000
is around so generally we already know

469
00:17:20,000 --> 00:17:21,199
how to get multi-input function

470
00:17:21,199 --> 00:17:22,640
encryption schemes for general functions

471
00:17:22,640 --> 00:17:24,000
like for all circuits for healing

472
00:17:24,000 --> 00:17:26,640
machines etc from but it relies on very

473
00:17:26,640 --> 00:17:27,679
complicated assumptions like

474
00:17:27,679 --> 00:17:28,880
indistinguishability obfuscation

475
00:17:28,880 --> 00:17:31,039
multimedia maps and so on

476
00:17:31,039 --> 00:17:32,799
however we also know that we can build

477
00:17:32,799 --> 00:17:34,320
multi input function different schemes

478
00:17:34,320 --> 00:17:35,840
for specific functions such as linear

479
00:17:35,840 --> 00:17:37,679
functions starting with very standard

480
00:17:37,679 --> 00:17:39,919
and uh assumptions like uh assumptions

481
00:17:39,919 --> 00:17:42,880
over uh matrix edge learning with errors

482
00:17:42,880 --> 00:17:45,360
quadratic simplicity and more

483
00:17:45,360 --> 00:17:47,600
now if we look closely at the class of

484
00:17:47,600 --> 00:17:49,919
the specific functions then we know that

485
00:17:49,919 --> 00:17:51,440
for these specific functions such as

486
00:17:51,440 --> 00:17:53,440
linear functions we know we can build

487
00:17:53,440 --> 00:17:55,280
function encryption schemes in the one

488
00:17:55,280 --> 00:17:57,280
input case for linear functions from

489
00:17:57,280 --> 00:17:59,440
simple assumptions such as ddh ld and

490
00:17:59,440 --> 00:18:00,559
dcr

491
00:18:00,559 --> 00:18:02,960
and we can also extend those ideas to

492
00:18:02,960 --> 00:18:04,320
sort of give us

493
00:18:04,320 --> 00:18:06,240
mife for that same function plus for the

494
00:18:06,240 --> 00:18:07,840
class of linear functions from same

495
00:18:07,840 --> 00:18:09,440
assumptions

496
00:18:09,440 --> 00:18:11,039
and we also know that we can build

497
00:18:11,039 --> 00:18:12,400
functional encryption for quadratic

498
00:18:12,400 --> 00:18:13,520
functions

499
00:18:13,520 --> 00:18:16,160
but in the case of one input one user

500
00:18:16,160 --> 00:18:18,720
and we rely on pairings for that

501
00:18:18,720 --> 00:18:20,320
and interesting question is that since

502
00:18:20,320 --> 00:18:21,760
in the linear function case we can

503
00:18:21,760 --> 00:18:23,760
actually sort of extend this one input

504
00:18:23,760 --> 00:18:25,679
fe scheme to multi-input if you scheme

505
00:18:25,679 --> 00:18:28,559
can we do this game for these uh

506
00:18:28,559 --> 00:18:30,559
quadratic functions as well and this is

507
00:18:30,559 --> 00:18:32,000
precisely what we show in this work we

508
00:18:32,000 --> 00:18:34,080
show that we can build a multi-input

509
00:18:34,080 --> 00:18:35,600
function encryption scheme for quadratic

510
00:18:35,600 --> 00:18:38,080
functions when we start with pairings

511
00:18:38,080 --> 00:18:39,760
so let me just quickly explain what's

512
00:18:39,760 --> 00:18:41,760
the difference between single and multi

513
00:18:41,760 --> 00:18:43,760
input in the setting so in a single

514
00:18:43,760 --> 00:18:45,360
input linear function case suppose you

515
00:18:45,360 --> 00:18:47,360
have an input x a vector and a function

516
00:18:47,360 --> 00:18:49,520
c and the output uh the output of the

517
00:18:49,520 --> 00:18:51,600
evaluation is basically the uh sort of

518
00:18:51,600 --> 00:18:53,760
evaluation just inner product of this

519
00:18:53,760 --> 00:18:55,760
of the function and the input

520
00:18:55,760 --> 00:18:57,679
now in the case of quadratic functions

521
00:18:57,679 --> 00:19:00,000
you basically sort of have uh the input

522
00:19:00,000 --> 00:19:02,080
x and a function c and the evaluation is

523
00:19:02,080 --> 00:19:04,000
going to be you tensor you basically

524
00:19:04,000 --> 00:19:06,000
create all the inner products between x

525
00:19:06,000 --> 00:19:08,000
um between the input x and you sort of

526
00:19:08,000 --> 00:19:10,400
do an inner product with the function c

527
00:19:10,400 --> 00:19:12,640
now what happens in the single input

528
00:19:12,640 --> 00:19:14,960
case is that uh the quadratic functions

529
00:19:14,960 --> 00:19:16,640
this class of quadratic functions can

530
00:19:16,640 --> 00:19:18,720
actually be generically computed from

531
00:19:18,720 --> 00:19:21,200
single linear functions the idea is that

532
00:19:21,200 --> 00:19:22,880
instead of just encrypting them at the

533
00:19:22,880 --> 00:19:24,960
input x directly you basically encrypt

534
00:19:24,960 --> 00:19:26,799
all possible pairs of the input pair

535
00:19:26,799 --> 00:19:29,440
just all degree two functions of uh all

536
00:19:29,440 --> 00:19:31,520
degree two computations over the input x

537
00:19:31,520 --> 00:19:33,440
and under the linear function and

538
00:19:33,440 --> 00:19:35,039
basically you can sort of instantiate a

539
00:19:35,039 --> 00:19:36,720
quadratic function professional scheme

540
00:19:36,720 --> 00:19:38,240
from sort of linear functions by sort of

541
00:19:38,240 --> 00:19:40,240
using this idea but the problem is that

542
00:19:40,240 --> 00:19:42,320
in this generic transformation you sort

543
00:19:42,320 --> 00:19:44,240
of rely on the fact that you have to

544
00:19:44,240 --> 00:19:46,320
expand out these cyclic space so cytotex

545
00:19:46,320 --> 00:19:48,400
grows uh sort of quadratically with the

546
00:19:48,400 --> 00:19:50,400
size and it becomes only interesting

547
00:19:50,400 --> 00:19:52,080
when the scientific size has to be small

548
00:19:52,080 --> 00:19:53,520
has to only grow linearly with input

549
00:19:53,520 --> 00:19:54,960
length

550
00:19:54,960 --> 00:19:56,880
now in the multi-input case we again

551
00:19:56,880 --> 00:19:58,640
sort of can define for linear functions

552
00:19:58,640 --> 00:20:00,320
the same way we have all these inputs

553
00:20:00,320 --> 00:20:02,240
different vectors and a function c which

554
00:20:02,240 --> 00:20:04,080
sort of evaluates an inner product

555
00:20:04,080 --> 00:20:06,240
between uh appending all these inputs

556
00:20:06,240 --> 00:20:08,159
together and taking the input with this

557
00:20:08,159 --> 00:20:09,280
vector c

558
00:20:09,280 --> 00:20:10,640
now in the case of quadratic functions

559
00:20:10,640 --> 00:20:12,240
we have sort of uh we perform a

560
00:20:12,240 --> 00:20:13,760
tensioning operation take the inner

561
00:20:13,760 --> 00:20:15,679
product or just a tensioning operation

562
00:20:15,679 --> 00:20:17,520
all these inputs create these degree

563
00:20:17,520 --> 00:20:18,799
terms and sort of just take the inner

564
00:20:18,799 --> 00:20:20,960
product with the function c

565
00:20:20,960 --> 00:20:23,280
now as it turns out in the multi-input

566
00:20:23,280 --> 00:20:24,080
case

567
00:20:24,080 --> 00:20:25,600
a multi-put quadratic function in

568
00:20:25,600 --> 00:20:26,960
encryption scheme is not genetically

569
00:20:26,960 --> 00:20:28,400
constructable from multi-input linear

570
00:20:28,400 --> 00:20:29,760
function impression scheme and this is

571
00:20:29,760 --> 00:20:31,600
precisely because of the cross terms

572
00:20:31,600 --> 00:20:33,360
there are some cross terms of the form x

573
00:20:33,360 --> 00:20:35,760
i denser xj which were not present in

574
00:20:35,760 --> 00:20:37,200
the single input case

575
00:20:37,200 --> 00:20:39,120
and because of that quadratic mitov

576
00:20:39,120 --> 00:20:40,720
cannot be generally obtained from linear

577
00:20:40,720 --> 00:20:42,720
mife even if you don't care about the

578
00:20:42,720 --> 00:20:44,159
ciphertext size

579
00:20:44,159 --> 00:20:45,760
and the question then becomes that even

580
00:20:45,760 --> 00:20:47,280
if you forget about the cypher 6 size

581
00:20:47,280 --> 00:20:48,400
can we sort of compute this

582
00:20:48,400 --> 00:20:50,640
functionality in the multi-input setting

583
00:20:50,640 --> 00:20:52,080
and this is precisely what we show so

584
00:20:52,080 --> 00:20:53,840
sort of there could be three scenarios

585
00:20:53,840 --> 00:20:55,600
where sort of uh we have this multiple

586
00:20:55,600 --> 00:20:57,600
encryption scheme in which there is an

587
00:20:57,600 --> 00:20:59,200
encryption key for each user or there's

588
00:20:59,200 --> 00:21:01,120
a single public key for all the users or

589
00:21:01,120 --> 00:21:02,400
there's a master security that you need

590
00:21:02,400 --> 00:21:04,159
to perform the encryption algorithm

591
00:21:04,159 --> 00:21:06,080
in this what we show if you sort of work

592
00:21:06,080 --> 00:21:07,440
in this public key setting where the

593
00:21:07,440 --> 00:21:08,640
encryption algorithm takes from the

594
00:21:08,640 --> 00:21:10,159
public key then this can be easily

595
00:21:10,159 --> 00:21:11,760
constructed from any linear function

596
00:21:11,760 --> 00:21:13,200
encryption scheme still

597
00:21:13,200 --> 00:21:15,360
and we show that in the secret setting

598
00:21:15,360 --> 00:21:17,039
we can actually build this multiple

599
00:21:17,039 --> 00:21:17,919
function encryption scheme for the

600
00:21:17,919 --> 00:21:19,840
direct functions and it's still open

601
00:21:19,840 --> 00:21:23,120
that we can build mife for uh this uh

602
00:21:23,120 --> 00:21:25,120
this mixed corruption setting generally

603
00:21:25,120 --> 00:21:27,120
for quadratic functions

604
00:21:27,120 --> 00:21:28,480
now in the lack of time i won't have

605
00:21:28,480 --> 00:21:30,000
enough time to tell you about how to how

606
00:21:30,000 --> 00:21:31,679
we actually design this but let me just

607
00:21:31,679 --> 00:21:33,520
quick quickly share some sort of key

608
00:21:33,520 --> 00:21:35,760
ideas so basically the idea is that we

609
00:21:35,760 --> 00:21:36,799
sort of start with the functional

610
00:21:36,799 --> 00:21:38,720
encryption scheme for linear functions

611
00:21:38,720 --> 00:21:40,400
but that has to be a function hiding

612
00:21:40,400 --> 00:21:42,640
scheme and the point is that our mifv

613
00:21:42,640 --> 00:21:44,880
self text a quadratic mif ciphertext is

614
00:21:44,880 --> 00:21:47,120
going to contain a linear fe secret key

615
00:21:47,120 --> 00:21:49,440
and a ciphertext both of these things

616
00:21:49,440 --> 00:21:51,039
and basically you encode the input

617
00:21:51,039 --> 00:21:53,120
vector inside the secret key and the

618
00:21:53,120 --> 00:21:54,400
ciphertext for this linear referee

619
00:21:54,400 --> 00:21:56,480
schemes and you also embed some masking

620
00:21:56,480 --> 00:21:58,720
parameters masking terms and the idea is

621
00:21:58,720 --> 00:22:00,480
going to be the mifp secret key for the

622
00:22:00,480 --> 00:22:02,159
quadratic function it's going to give

623
00:22:02,159 --> 00:22:04,080
you a linear fe secret key that can

624
00:22:04,080 --> 00:22:06,000
basically be combined with these masking

625
00:22:06,000 --> 00:22:08,240
terms and compute some unmasking terms

626
00:22:08,240 --> 00:22:09,760
and you can sort of combine different

627
00:22:09,760 --> 00:22:11,600
components in different size

628
00:22:11,600 --> 00:22:12,880
and sort of just pair them together and

629
00:22:12,880 --> 00:22:14,799
just sort of decrypt them across these

630
00:22:14,799 --> 00:22:16,000
different slots to learn the

631
00:22:16,000 --> 00:22:18,159
corresponding function value

632
00:22:18,159 --> 00:22:19,919
and just to summarize we sort of in this

633
00:22:19,919 --> 00:22:21,919
work we propose uh the first quadratic

634
00:22:21,919 --> 00:22:23,360
and multiple function correction scheme

635
00:22:23,360 --> 00:22:26,080
from pairings sort of closing uh sort of

636
00:22:26,080 --> 00:22:27,520
just yeah following on this intuition

637
00:22:27,520 --> 00:22:29,360
that we can actually use ideas in the

638
00:22:29,360 --> 00:22:31,280
single input setting to get quadratic

639
00:22:31,280 --> 00:22:32,159
setting

640
00:22:32,159 --> 00:22:34,640
or just a multiple setting and there are

641
00:22:34,640 --> 00:22:36,400
a lot of interesting questions in syria

642
00:22:36,400 --> 00:22:37,919
we could only prove selective security

643
00:22:37,919 --> 00:22:39,919
or constructors but can we actually

644
00:22:39,919 --> 00:22:42,320
adapt to security for in the standing

645
00:22:42,320 --> 00:22:44,720
model for quadratic and ife or can we

646
00:22:44,720 --> 00:22:46,559
actually improve the saftix size of the

647
00:22:46,559 --> 00:22:47,760
of our scheme

648
00:22:47,760 --> 00:22:49,440
and finally can we actually go beyond

649
00:22:49,440 --> 00:22:50,559
quadratic functions from standard

650
00:22:50,559 --> 00:22:52,480
assumptions and actually try to evaluate

651
00:22:52,480 --> 00:22:54,960
a much larger class of functions from

652
00:22:54,960 --> 00:22:56,400
some assumptions

653
00:22:56,400 --> 00:22:57,840
and with that i'll just invite you to

654
00:22:57,840 --> 00:22:59,120
look at the longer version of the talk

655
00:22:59,120 --> 00:23:00,720
that junichi gave and it's like

656
00:23:00,720 --> 00:23:02,559
beautifully explains all the technical

657
00:23:02,559 --> 00:23:04,159
ideas and how we were able to sort of

658
00:23:04,159 --> 00:23:06,000
handle these masking and unmasking terms

659
00:23:06,000 --> 00:23:07,679
and still sort of prove security with

660
00:23:07,679 --> 00:23:09,200
that i'll sort of just

661
00:23:09,200 --> 00:23:11,919
thanks for your time

662
00:23:13,120 --> 00:23:15,600
thank you

663
00:23:19,039 --> 00:23:21,600
all right so let's move on to the

664
00:23:21,600 --> 00:23:22,799
next talk

665
00:23:22,799 --> 00:23:24,960
which is going to be about

666
00:23:24,960 --> 00:23:26,480
functional encryption

667
00:23:26,480 --> 00:23:28,640
for turing machines with dynamic bounded

668
00:23:28,640 --> 00:23:30,880
collisions from lwe

669
00:23:30,880 --> 00:23:36,679
by shweta agarwal shota yamada monozyma

670
00:23:38,960 --> 00:23:42,559
is going to give the torque

671
00:23:46,000 --> 00:23:47,679
can you hear me roman

672
00:23:47,679 --> 00:23:48,559
yes

673
00:23:48,559 --> 00:23:50,960
yeah thanks thanks uh

674
00:23:50,960 --> 00:23:53,279
now i shared my slides

675
00:23:53,279 --> 00:23:54,400
i think

676
00:23:54,400 --> 00:23:55,679
uh is it

677
00:23:55,679 --> 00:23:57,039
yeah

678
00:23:57,039 --> 00:24:00,320
yes yeah great great so hi everyone

679
00:24:00,320 --> 00:24:01,279
thanks

680
00:24:01,279 --> 00:24:04,400
uh so yeah my name is monoshimitra and

681
00:24:04,400 --> 00:24:05,440
i'll be

682
00:24:05,440 --> 00:24:07,200
i'm here to talk about functional

683
00:24:07,200 --> 00:24:08,559
encryption for tuning machines with

684
00:24:08,559 --> 00:24:10,960
dynamic bounded collusion from lwe this

685
00:24:10,960 --> 00:24:12,640
is joint work with sweta agrawal and

686
00:24:12,640 --> 00:24:14,720
narasimha sai empathy from iit madras

687
00:24:14,720 --> 00:24:17,520
and shota yamada from aisd japan

688
00:24:17,520 --> 00:24:20,480
so as we just saw in the last talk uh

689
00:24:20,480 --> 00:24:22,640
key policy functional encryption or more

690
00:24:22,640 --> 00:24:24,080
traditionally known as functional

691
00:24:24,080 --> 00:24:26,480
encryption is a generalization of public

692
00:24:26,480 --> 00:24:28,559
key encryption in the sense that it

693
00:24:28,559 --> 00:24:31,279
gives secret keys tied to function safe

694
00:24:31,279 --> 00:24:33,679
that can be used to

695
00:24:33,679 --> 00:24:35,360
decrypt ciphertext to reveal the

696
00:24:35,360 --> 00:24:37,520
functions of plain text on the other

697
00:24:37,520 --> 00:24:40,400
hand security says that any ppt

698
00:24:40,400 --> 00:24:42,159
adversary no ppt adversary should be

699
00:24:42,159 --> 00:24:44,400
able to learn information any more than

700
00:24:44,400 --> 00:24:45,919
what the functions of the plaintext

701
00:24:45,919 --> 00:24:46,960
tributes

702
00:24:46,960 --> 00:24:48,720
so this is uh

703
00:24:48,720 --> 00:24:50,880
more formally captured by uh by the

704
00:24:50,880 --> 00:24:53,360
existence of a simulator in a

705
00:24:53,360 --> 00:24:55,039
in an ideal world which should be able

706
00:24:55,039 --> 00:24:57,120
to simulate a cipher text

707
00:24:57,120 --> 00:24:58,720
that is indistinguishable from the real

708
00:24:58,720 --> 00:25:01,039
world one given access only to the

709
00:25:01,039 --> 00:25:03,360
length of the plain text and secret keys

710
00:25:03,360 --> 00:25:06,400
for say a bunch of q functions capital q

711
00:25:06,400 --> 00:25:08,159
functions and their outputs on the line

712
00:25:08,159 --> 00:25:09,760
text

713
00:25:09,760 --> 00:25:11,840
now this capital q when it is unbounded

714
00:25:11,840 --> 00:25:14,000
we call this colluding resistant and or

715
00:25:14,000 --> 00:25:16,480
fully simulation secure unfortunately

716
00:25:16,480 --> 00:25:18,880
this was shown to be impossible to

717
00:25:18,880 --> 00:25:20,640
attain for all circuits

718
00:25:20,640 --> 00:25:21,679
uh

719
00:25:21,679 --> 00:25:23,919
therefore we can weaken this security

720
00:25:23,919 --> 00:25:26,320
setting to say that q is a bounded

721
00:25:26,320 --> 00:25:28,720
polynomial where we declare it a priori

722
00:25:28,720 --> 00:25:31,520
before the setup and we call this model

723
00:25:31,520 --> 00:25:33,760
traditional bounded collusion model

724
00:25:33,760 --> 00:25:35,520
where we can still hope to achieve

725
00:25:35,520 --> 00:25:37,840
simulation based security

726
00:25:37,840 --> 00:25:39,760
now our work in this paper begins at

727
00:25:39,760 --> 00:25:41,840
this junction where we try to address

728
00:25:41,840 --> 00:25:44,799
some limitations of prior work and

729
00:25:44,799 --> 00:25:46,559
try to overcome them as follows so the

730
00:25:46,559 --> 00:25:48,720
first limitation comes from the bounded

731
00:25:48,720 --> 00:25:50,559
collusion model itself

732
00:25:50,559 --> 00:25:52,080
this was first

733
00:25:52,080 --> 00:25:55,279
formalized and studied by gordon of ital

734
00:25:55,279 --> 00:25:57,600
in 2012 and there were subsequent works

735
00:25:57,600 --> 00:26:00,240
being done till as recent as in 2019 by

736
00:26:00,240 --> 00:26:02,159
ananth and by kuntanatan

737
00:26:02,159 --> 00:26:03,919
in this model because q is fixed at

738
00:26:03,919 --> 00:26:06,480
setup this leads to an inefficiency that

739
00:26:06,480 --> 00:26:08,080
the keys and the ciphertext in the

740
00:26:08,080 --> 00:26:10,960
system grow with collusion bound q and

741
00:26:10,960 --> 00:26:12,400
further more

742
00:26:12,400 --> 00:26:14,320
however less or more sensitive the

743
00:26:14,320 --> 00:26:15,919
underlying plaintexts are all the

744
00:26:15,919 --> 00:26:17,919
ciphertexts in the scheme

745
00:26:17,919 --> 00:26:21,200
suffer or maybe i mean satisfy the same

746
00:26:21,200 --> 00:26:23,520
collusion tolerance

747
00:26:23,520 --> 00:26:26,320
so in this context we introduced this

748
00:26:26,320 --> 00:26:28,240
new stronger notion of dynamic bounded

749
00:26:28,240 --> 00:26:30,320
collision where essentially the

750
00:26:30,320 --> 00:26:32,400
encrypter gets to fix the

751
00:26:32,400 --> 00:26:34,880
uh collusion bound per cipher text as

752
00:26:34,880 --> 00:26:36,480
demanded by the sensitivity of the

753
00:26:36,480 --> 00:26:38,559
underlying plain plaintext

754
00:26:38,559 --> 00:26:42,159
and as a consequence the runtime

755
00:26:42,159 --> 00:26:44,000
of the setup and key generation gets

756
00:26:44,000 --> 00:26:46,240
independent of the factor queue and in

757
00:26:46,240 --> 00:26:48,080
our constructions also the ciphertext

758
00:26:48,080 --> 00:26:50,080
size grows linearly with the choice of

759
00:26:50,080 --> 00:26:52,559
that particular gene we show that

760
00:26:52,559 --> 00:26:54,960
functional encryption can be built in

761
00:26:54,960 --> 00:26:57,440
this stronger model from genetically

762
00:26:57,440 --> 00:27:00,000
from identity based encryption

763
00:27:00,000 --> 00:27:02,480
uh the next uh limitation is that we

764
00:27:02,480 --> 00:27:04,400
want to point out is that all prior work

765
00:27:04,400 --> 00:27:06,799
mostly built key policy focus mostly on

766
00:27:06,799 --> 00:27:09,279
building key policy fee

767
00:27:09,279 --> 00:27:11,200
on the other hand to build the dual

768
00:27:11,200 --> 00:27:13,120
notion of ciphertext policy if you where

769
00:27:13,120 --> 00:27:15,279
you want to hide let's say a function

770
00:27:15,279 --> 00:27:17,120
inside a ciphertext and generate secret

771
00:27:17,120 --> 00:27:19,520
keys for public inputs can be done by a

772
00:27:19,520 --> 00:27:22,320
universal service but this again i mean

773
00:27:22,320 --> 00:27:24,399
it becomes inefficient of course because

774
00:27:24,399 --> 00:27:27,279
due to the use of universal circuits and

775
00:27:27,279 --> 00:27:29,120
also they

776
00:27:29,120 --> 00:27:30,880
end up supporting bounded size circuits

777
00:27:30,880 --> 00:27:32,799
because the because of the fixed input

778
00:27:32,799 --> 00:27:35,760
length to the universal circuit uh

779
00:27:35,760 --> 00:27:36,720
i mean

780
00:27:36,720 --> 00:27:38,480
the only exception in this line of work

781
00:27:38,480 --> 00:27:40,720
is the scheme by ss10 uh

782
00:27:40,720 --> 00:27:43,279
which is a single key secure cpf scheme

783
00:27:43,279 --> 00:27:44,880
from public key encryption and garbage

784
00:27:44,880 --> 00:27:46,000
circuits

785
00:27:46,000 --> 00:27:48,080
now in this context we build a

786
00:27:48,080 --> 00:27:50,000
ciphertext policy fee which is dynamic

787
00:27:50,000 --> 00:27:52,000
bounded permission secure with various

788
00:27:52,000 --> 00:27:53,919
tradeoffs we show that assuming

789
00:27:53,919 --> 00:27:55,840
indistinguishability based cpa secure

790
00:27:55,840 --> 00:27:58,960
ibe we can get non-adaptive simulation

791
00:27:58,960 --> 00:28:02,399
secure cpfe for unbounded size circuits

792
00:28:02,399 --> 00:28:04,399
however to get adaptive simulation based

793
00:28:04,399 --> 00:28:05,600
cpfe

794
00:28:05,600 --> 00:28:07,840
we need to rely on simulation based

795
00:28:07,840 --> 00:28:10,720
receiver selective opening secure ibd

796
00:28:10,720 --> 00:28:12,480
but at the cost of getting support for

797
00:28:12,480 --> 00:28:14,799
only bounded size circuits

798
00:28:14,799 --> 00:28:16,880
here we note that it is worthwhile to

799
00:28:16,880 --> 00:28:18,960
note that cmrs is not a stronger

800
00:28:18,960 --> 00:28:20,720
assumption than in cpa

801
00:28:20,720 --> 00:28:22,880
uh therefore in this regime all our

802
00:28:22,880 --> 00:28:24,480
constructions can be based on the

803
00:28:24,480 --> 00:28:27,520
traditional ncpa security only

804
00:28:27,520 --> 00:28:30,080
we also show that ibe is a necessary

805
00:28:30,080 --> 00:28:31,279
assumption

806
00:28:31,279 --> 00:28:32,960
to build functional encryption in the

807
00:28:32,960 --> 00:28:35,279
stronger with the stronger model uh

808
00:28:35,279 --> 00:28:37,200
dynamic bounded collision

809
00:28:37,200 --> 00:28:39,279
further we show that uh

810
00:28:39,279 --> 00:28:41,760
we show how to build succinct functional

811
00:28:41,760 --> 00:28:43,679
encryption schemes from lwp both in the

812
00:28:43,679 --> 00:28:46,240
ciphertext and key policy settings

813
00:28:46,240 --> 00:28:48,799
this also strengthens the prior work

814
00:28:48,799 --> 00:28:50,159
uh

815
00:28:50,159 --> 00:28:52,320
by the way starting here means circuits

816
00:28:52,320 --> 00:28:54,080
that are supported are of unbounded size

817
00:28:54,080 --> 00:28:56,799
but of bounded and depth and output

818
00:28:56,799 --> 00:28:59,520
but uh this also strengthens a prior

819
00:28:59,520 --> 00:29:02,240
work by gold washer at all uh who built

820
00:29:02,240 --> 00:29:05,279
succinct key policy fe from lwe but in

821
00:29:05,279 --> 00:29:06,880
only in the bounded collusion model

822
00:29:06,880 --> 00:29:09,679
satisfying nsm security

823
00:29:09,679 --> 00:29:11,440
the third aspect of our work is to

824
00:29:11,440 --> 00:29:12,880
support more general models of

825
00:29:12,880 --> 00:29:16,240
computation namely uniform because

826
00:29:16,240 --> 00:29:17,039
i mean

827
00:29:17,039 --> 00:29:18,960
owing to the inherent drawbacks that

828
00:29:18,960 --> 00:29:21,520
non-uniform models like circuits have

829
00:29:21,520 --> 00:29:23,600
so in this regime we have

830
00:29:23,600 --> 00:29:25,919
a public key fe scheme by gold washer at

831
00:29:25,919 --> 00:29:27,919
all for tuning machine

832
00:29:27,919 --> 00:29:29,600
built from a non-standard assumption

833
00:29:29,600 --> 00:29:32,000
there is another public key fee fe for

834
00:29:32,000 --> 00:29:33,840
dfa as well as

835
00:29:33,840 --> 00:29:35,840
for finite dfa as well as turing

836
00:29:35,840 --> 00:29:37,039
machines

837
00:29:37,039 --> 00:29:38,799
from learning with errors by aggraval

838
00:29:38,799 --> 00:29:41,200
and c but that is only single key secure

839
00:29:41,200 --> 00:29:43,840
and more recently there is a fire fe for

840
00:29:43,840 --> 00:29:46,559
finite automata built from lw

841
00:29:46,559 --> 00:29:50,720
by my 19 but it's uh a secret kfc

842
00:29:50,720 --> 00:29:53,279
uh and last but not least all these are

843
00:29:53,279 --> 00:29:55,600
secure in the bounded collision model

844
00:29:55,600 --> 00:29:57,919
so here we built uh for the first time a

845
00:29:57,919 --> 00:30:00,240
public efe scheme for the general class

846
00:30:00,240 --> 00:30:02,240
of tubing machines as well as the class

847
00:30:02,240 --> 00:30:04,000
of non-deterministic lock specific

848
00:30:04,000 --> 00:30:05,440
machines from the learning with errors

849
00:30:05,440 --> 00:30:06,960
assumption

850
00:30:06,960 --> 00:30:09,440
in more detail uh we built both the key

851
00:30:09,440 --> 00:30:11,520
policy and ciphertext policy variants

852
00:30:11,520 --> 00:30:14,080
for fifa tutoring machine satisfying the

853
00:30:14,080 --> 00:30:16,080
stronger notion of dbc

854
00:30:16,080 --> 00:30:17,919
uh in particular the fe for turing

855
00:30:17,919 --> 00:30:20,159
machine satisfies nsm security while

856
00:30:20,159 --> 00:30:22,159
that for nl satisfies adaptive

857
00:30:22,159 --> 00:30:24,399
simulation and because nl the class nl

858
00:30:24,399 --> 00:30:26,559
already captures finite automata this

859
00:30:26,559 --> 00:30:30,240
subsumes prior work by my 19 and a 17.

860
00:30:30,240 --> 00:30:32,399
we note that the cipher texts in our

861
00:30:32,399 --> 00:30:34,960
schemes grow with the runtime t

862
00:30:34,960 --> 00:30:37,039
however this t is not really a global

863
00:30:37,039 --> 00:30:39,200
bound and can vary per input chosen by

864
00:30:39,200 --> 00:30:41,279
the encryptor

865
00:30:41,279 --> 00:30:44,720
so uh overall we introduced this new

866
00:30:44,720 --> 00:30:47,039
model of dynamic boundary collision fe

867
00:30:47,039 --> 00:30:48,799
which is a stronger which is stronger

868
00:30:48,799 --> 00:30:50,399
than the traditional bounded collision

869
00:30:50,399 --> 00:30:52,640
model we build various functional

870
00:30:52,640 --> 00:30:54,799
encryption schemes in the ciphertext

871
00:30:54,799 --> 00:30:57,519
policy as well as policy setting

872
00:30:57,519 --> 00:30:59,679
with various properties and with various

873
00:30:59,679 --> 00:31:01,360
security guarantees

874
00:31:01,360 --> 00:31:02,720
we also

875
00:31:02,720 --> 00:31:06,559
for circuits as well as turing machines

876
00:31:06,559 --> 00:31:08,480
and further we show that ib is a

877
00:31:08,480 --> 00:31:10,080
necessary assumption

878
00:31:10,080 --> 00:31:12,240
uh to build functional encryption

879
00:31:12,240 --> 00:31:13,519
schemes

880
00:31:13,519 --> 00:31:16,080
in this dynamic bounded collision model

881
00:31:16,080 --> 00:31:17,919
we note however here that there is a

882
00:31:17,919 --> 00:31:20,720
concurrent work by garg it all who also

883
00:31:20,720 --> 00:31:23,360
introduced this notion of bbc

884
00:31:23,360 --> 00:31:24,720
security

885
00:31:24,720 --> 00:31:26,399
and they built functional encryption

886
00:31:26,399 --> 00:31:28,559
schemes in the key policy setting

887
00:31:28,559 --> 00:31:31,120
uh satisfying the security notion

888
00:31:31,120 --> 00:31:32,799
the techniques are also very similar to

889
00:31:32,799 --> 00:31:35,360
us they use ib and existing kpi schemes

890
00:31:35,360 --> 00:31:37,760
to compile their

891
00:31:37,760 --> 00:31:40,880
dbc secure kpi generally

892
00:31:40,880 --> 00:31:42,000
and

893
00:31:42,000 --> 00:31:43,919
finally i would like to end with some

894
00:31:43,919 --> 00:31:46,559
open problems here we

895
00:31:46,559 --> 00:31:48,559
the fe for turing machine satisfies

896
00:31:48,559 --> 00:31:51,760
non-adaptive simulation security uh so

897
00:31:51,760 --> 00:31:54,159
adsense security is a nice open question

898
00:31:54,159 --> 00:31:56,000
how to get it we don't know

899
00:31:56,000 --> 00:31:58,799
uh also there is a runtime dependence of

900
00:31:58,799 --> 00:32:00,480
the ciphertext which we would like to

901
00:32:00,480 --> 00:32:02,880
get rid of all together

902
00:32:02,880 --> 00:32:05,039
also we

903
00:32:05,039 --> 00:32:07,279
saw that we observed that our compiler

904
00:32:07,279 --> 00:32:09,440
can actually yield pollutant resistant

905
00:32:09,440 --> 00:32:11,919
av for turing machine if only we know

906
00:32:11,919 --> 00:32:14,399
how to build cpav for unbounded depth

907
00:32:14,399 --> 00:32:15,519
service

908
00:32:15,519 --> 00:32:17,519
so this is only the kind of the missing

909
00:32:17,519 --> 00:32:20,159
piece in our uh compiler

910
00:32:20,159 --> 00:32:22,080
but we don't know how to support cpap

911
00:32:22,080 --> 00:32:24,799
for unbounded depth circuits from nwe

912
00:32:24,799 --> 00:32:27,600
or yeah from lwb

913
00:32:27,600 --> 00:32:29,519
and yeah last but not the least there

914
00:32:29,519 --> 00:32:30,960
may be other applications for our

915
00:32:30,960 --> 00:32:33,760
techniques and thanks for listening

916
00:32:33,760 --> 00:32:36,880
uh to this talk the final uh

917
00:32:36,880 --> 00:32:38,880
i would invite you to like to see the

918
00:32:38,880 --> 00:32:41,120
full talk as well as

919
00:32:41,120 --> 00:32:42,399
see default paper

920
00:32:42,399 --> 00:32:46,000
thanks for listening again thanks

921
00:32:46,960 --> 00:32:48,720
all right thank you

922
00:32:48,720 --> 00:32:50,640
let's move on to the last

923
00:32:50,640 --> 00:32:52,159
talk

924
00:32:52,159 --> 00:32:54,000
of the session which is going to be

925
00:32:54,000 --> 00:32:57,360
about receiver anonymity in randomizable

926
00:32:57,360 --> 00:33:00,880
rcca secure cryptosystems resolved

927
00:33:00,880 --> 00:33:05,279
by yi wong mao chan yo min yang yin yi

928
00:33:05,279 --> 00:33:08,720
wang bao sheng wang and moti young

929
00:33:08,720 --> 00:33:13,760
and yiwang is going to present the paper

930
00:33:14,799 --> 00:33:17,120
okay can you hear me

931
00:33:17,120 --> 00:33:18,159
yes

932
00:33:18,159 --> 00:33:19,600
okay

933
00:33:19,600 --> 00:33:21,360
thank you for introduction

934
00:33:21,360 --> 00:33:23,760
um welcome to this talk about receiving

935
00:33:23,760 --> 00:33:25,919
anonymity in randomizable assisted

936
00:33:25,919 --> 00:33:28,000
secure crypto system

937
00:33:28,000 --> 00:33:30,720
i'm yuan and this is a joint work with

938
00:33:30,720 --> 00:33:33,360
roma cheng kuang yang xin yi huang fung

939
00:33:33,360 --> 00:33:36,959
shung one and mo tm

940
00:33:37,360 --> 00:33:40,720
a replayable cc security was proposed by

941
00:33:40,720 --> 00:33:44,000
canadian courses at crypto 2003.

942
00:33:44,000 --> 00:33:46,399
it is the same as cc security except

943
00:33:46,399 --> 00:33:49,519
that the adversary is allowed to modify

944
00:33:49,519 --> 00:33:52,559
or separate into a new one of sam

945
00:33:52,559 --> 00:33:53,760
plaintext

946
00:33:53,760 --> 00:33:58,240
so it is a relaxation of cca security

947
00:33:58,240 --> 00:34:01,200
centralization endows the pke with

948
00:34:01,200 --> 00:34:04,159
desirable features randomizable rcc

949
00:34:04,159 --> 00:34:07,440
security is one of them we say pke is

950
00:34:07,440 --> 00:34:10,320
randomizable if there exists a efficient

951
00:34:10,320 --> 00:34:12,879
algorithm we ran that takes as input

952
00:34:12,879 --> 00:34:16,399
public key pk and sabotage c and output

953
00:34:16,399 --> 00:34:19,199
a news advertised c prime of same public

954
00:34:19,199 --> 00:34:22,319
key and plain text

955
00:34:22,399 --> 00:34:24,159
if the

956
00:34:24,159 --> 00:34:27,359
algorithm rerun does not need public tpk

957
00:34:27,359 --> 00:34:29,599
we say this pke is universally

958
00:34:29,599 --> 00:34:31,359
randomizable

959
00:34:31,359 --> 00:34:33,679
when rcc security turns out to have many

960
00:34:33,679 --> 00:34:36,000
applications such as mixed act

961
00:34:36,000 --> 00:34:38,079
controlled malleable sdk and

962
00:34:38,079 --> 00:34:40,480
cryptographic reverse firewalls

963
00:34:40,480 --> 00:34:43,119
however for some privacy oriented

964
00:34:43,119 --> 00:34:44,639
applications

965
00:34:44,639 --> 00:34:49,440
rcc receiver anonymity is also required

966
00:34:49,440 --> 00:34:51,599
the formal definition of

967
00:34:51,599 --> 00:34:54,320
rcc receiver anonymity was proposed by

968
00:34:54,320 --> 00:34:56,399
prop hurricane ross league at crypto

969
00:34:56,399 --> 00:34:58,480
2007.

970
00:34:58,480 --> 00:35:00,800
roughly the rcc

971
00:35:00,800 --> 00:35:03,599
receiver anonymity means that

972
00:35:03,599 --> 00:35:05,839
the adversary who can access a

973
00:35:05,839 --> 00:35:08,000
decryption oracle cannot obtain any

974
00:35:08,000 --> 00:35:10,079
information about the underlying public

975
00:35:10,079 --> 00:35:13,760
key from the separate tests

976
00:35:14,839 --> 00:35:16,800
um prabhupada and the ross league also

977
00:35:16,800 --> 00:35:17,920
said that

978
00:35:17,920 --> 00:35:20,160
ideonomity brings out the power of

979
00:35:20,160 --> 00:35:22,240
reunitability and yields a potent

980
00:35:22,240 --> 00:35:25,200
cryptographic primitive however their

981
00:35:25,200 --> 00:35:27,680
scheme the pr scheme does not achieve

982
00:35:27,680 --> 00:35:30,960
this definition of normative

983
00:35:30,960 --> 00:35:31,680
and

984
00:35:31,680 --> 00:35:34,560
how to construct a receiver anonymous

985
00:35:34,560 --> 00:35:36,720
random rcc pke was left as an

986
00:35:36,720 --> 00:35:39,919
interesting open problem

987
00:35:40,400 --> 00:35:42,960
so in this work we provide the first

988
00:35:42,960 --> 00:35:46,079
receive anonymous run rcc pke based on

989
00:35:46,079 --> 00:35:49,040
the pr scheme and resolve this open

990
00:35:49,040 --> 00:35:50,720
problem

991
00:35:50,720 --> 00:35:53,440
then we provide a generic construction

992
00:35:53,440 --> 00:35:56,560
of receive anonymous vendors is apke

993
00:35:56,560 --> 00:35:58,800
based on the iesphf

994
00:35:58,800 --> 00:36:02,000
it is a new variant of sphf

995
00:36:02,000 --> 00:36:05,280
also we incented it with the framework

996
00:36:05,280 --> 00:36:09,760
with kenyan assumption and grid ring

997
00:36:10,960 --> 00:36:14,880
next we show how to modify the pr scheme

998
00:36:14,880 --> 00:36:17,680
into a anonymous

999
00:36:17,680 --> 00:36:21,040
anonymous random rca so grpke

1000
00:36:21,040 --> 00:36:22,560
and this is the

1001
00:36:22,560 --> 00:36:25,200
the zeta is the advertised of the pr

1002
00:36:25,200 --> 00:36:27,359
scheme it comes it consists of

1003
00:36:27,359 --> 00:36:30,078
four strands

1004
00:36:30,160 --> 00:36:32,640
one can note that the first two strands

1005
00:36:32,640 --> 00:36:34,640
c one and the c two

1006
00:36:34,640 --> 00:36:37,599
their restriction is restricted by the

1007
00:36:37,599 --> 00:36:41,119
mask u and the vector z so the blue

1008
00:36:41,119 --> 00:36:43,599
errors illustrates the only way to

1009
00:36:43,599 --> 00:36:46,800
randomize the strand c 1 the c 2

1010
00:36:46,800 --> 00:36:49,040
however there is no such restriction in

1011
00:36:49,040 --> 00:36:51,680
c 3 and c 4.

1012
00:36:51,680 --> 00:36:52,480
so

1013
00:36:52,480 --> 00:36:55,920
the adversary is able to re-encrypt c3

1014
00:36:55,920 --> 00:36:58,880
and c4 with public with guest public key

1015
00:36:58,880 --> 00:37:01,200
and verify its guests we are queuing a

1016
00:37:01,200 --> 00:37:03,520
decryption oracle

1017
00:37:03,520 --> 00:37:06,240
so this is why the pr scheme does not

1018
00:37:06,240 --> 00:37:08,400
achieve receivable anonymity

1019
00:37:08,400 --> 00:37:12,160
so if we want to realize the anonymity

1020
00:37:12,160 --> 00:37:14,480
we have to disable

1021
00:37:14,480 --> 00:37:16,079
all the

1022
00:37:16,079 --> 00:37:17,760
randomization of

1023
00:37:17,760 --> 00:37:21,760
c3 and c4 involving public key

1024
00:37:21,760 --> 00:37:24,960
so this is our treatment we decided to

1025
00:37:24,960 --> 00:37:27,760
move all the mask and vector to the

1026
00:37:27,760 --> 00:37:30,720
validity checking part

1027
00:37:30,720 --> 00:37:31,839
and

1028
00:37:31,839 --> 00:37:33,920
now the blue arrows illustrate the only

1029
00:37:33,920 --> 00:37:34,720
way

1030
00:37:34,720 --> 00:37:37,839
to randomize the zipper test

1031
00:37:37,839 --> 00:37:40,640
next we show how to generalize our

1032
00:37:40,640 --> 00:37:44,400
treatment using the sbhf

1033
00:37:45,440 --> 00:37:47,040
sphf means

1034
00:37:47,040 --> 00:37:49,359
a smooth projective hash function it was

1035
00:37:49,359 --> 00:37:52,560
proposed by crema and soup at eurocrypto

1036
00:37:52,560 --> 00:37:54,320
2002.

1037
00:37:54,320 --> 00:37:56,079
roughly it is a

1038
00:37:56,079 --> 00:37:58,400
it is a family of hash function

1039
00:37:58,400 --> 00:37:59,760
that maps

1040
00:37:59,760 --> 00:38:03,839
element set x onto the hash value set

1041
00:38:03,839 --> 00:38:05,680
has related pi

1042
00:38:05,680 --> 00:38:08,800
each sphere is associated with a subset

1043
00:38:08,800 --> 00:38:11,680
membership problem

1044
00:38:11,680 --> 00:38:12,640
and

1045
00:38:12,640 --> 00:38:15,760
smhf also can be generalized into the

1046
00:38:15,760 --> 00:38:18,640
tag-based and tag sphf

1047
00:38:18,640 --> 00:38:19,440
where

1048
00:38:19,440 --> 00:38:20,240
the

1049
00:38:20,240 --> 00:38:21,440
tag tau

1050
00:38:21,440 --> 00:38:24,240
is introduced as the auxiliary input of

1051
00:38:24,240 --> 00:38:28,160
the hash function hsk

1052
00:38:28,960 --> 00:38:30,800
so in this work we

1053
00:38:30,800 --> 00:38:34,079
extended the sphere with randomizability

1054
00:38:34,079 --> 00:38:37,440
and proposed the notion of randomizable

1055
00:38:37,440 --> 00:38:40,480
sphere iesbhf

1056
00:38:40,480 --> 00:38:43,200
in this initial speedup we introduced

1057
00:38:43,200 --> 00:38:45,920
three extra algorithms to capture the

1058
00:38:45,920 --> 00:38:48,640
randomization of elements tag and hash

1059
00:38:48,640 --> 00:38:49,599
values

1060
00:38:49,599 --> 00:38:52,000
also we introduced we defined the four

1061
00:38:52,000 --> 00:38:54,960
new smoothnesses

1062
00:38:56,079 --> 00:38:58,800
and now our construction can be

1063
00:38:58,800 --> 00:39:01,280
generalized using six different iesp

1064
00:39:01,280 --> 00:39:04,880
jobs and with the hardness of subset

1065
00:39:04,880 --> 00:39:07,040
membership problem and the new

1066
00:39:07,040 --> 00:39:08,560
smoothnesses

1067
00:39:08,560 --> 00:39:12,240
we can give a modular analysis of our

1068
00:39:12,240 --> 00:39:15,920
of the rcc security of our construction

1069
00:39:15,920 --> 00:39:20,880
as well as the rcc receiver anonymity

1070
00:39:20,880 --> 00:39:23,920
okay that's all thank you

1071
00:39:25,760 --> 00:39:27,440
all right thank you

1072
00:39:27,440 --> 00:39:29,119
before taking questions let's give a

1073
00:39:29,119 --> 00:39:31,280
round of applause virtually to all the

1074
00:39:31,280 --> 00:39:34,560
speakers thank you

1075
00:39:37,040 --> 00:39:39,520
so now we have time for questions

1076
00:39:39,520 --> 00:39:41,839
that you can post on the zulip chat or

1077
00:39:41,839 --> 00:39:43,839
just by raising your hand

1078
00:39:43,839 --> 00:39:46,400
if you want

1079
00:39:54,800 --> 00:39:56,240
okay so i don't see anything on the

1080
00:39:56,240 --> 00:39:58,400
tulip

1081
00:39:58,400 --> 00:39:59,920
perhaps i'm not

1082
00:39:59,920 --> 00:40:03,359
using it correctly but okay

1083
00:40:03,359 --> 00:40:08,160
and i have some questions so um

1084
00:40:08,160 --> 00:40:09,280
for the first

1085
00:40:09,280 --> 00:40:13,599
speaker for wetek um you mentioned uh

1086
00:40:13,599 --> 00:40:15,599
you described uh

1087
00:40:15,599 --> 00:40:17,920
an encoding to build your broadcast

1088
00:40:17,920 --> 00:40:19,520
encryption

1089
00:40:19,520 --> 00:40:21,119
and

1090
00:40:21,119 --> 00:40:22,839
i understood that it's

1091
00:40:22,839 --> 00:40:25,520
computationally secure

1092
00:40:25,520 --> 00:40:27,599
because that has an elgamal encryption

1093
00:40:27,599 --> 00:40:30,400
if i remember uh is this necessary to

1094
00:40:30,400 --> 00:40:33,520
have a computational encoding does it

1095
00:40:33,520 --> 00:40:36,240
could you do it statistically would that

1096
00:40:36,240 --> 00:40:38,160
make overall broadcast encryption

1097
00:40:38,160 --> 00:40:39,839
simpler

1098
00:40:39,839 --> 00:40:42,000
right right uh that's a good question so

1099
00:40:42,000 --> 00:40:44,240
it's actually a combination recording

1100
00:40:44,240 --> 00:40:46,720
and uh in fact um

1101
00:40:46,720 --> 00:40:49,920
so basically our our

1102
00:40:49,920 --> 00:40:53,359
gkw lower bound applies only in

1103
00:40:53,359 --> 00:40:55,359
information theoretic setting and

1104
00:40:55,359 --> 00:40:58,319
assuming uh linear reconstruction

1105
00:40:58,319 --> 00:40:59,680
so

1106
00:40:59,680 --> 00:41:00,960
you know one could actually avoid the

1107
00:41:00,960 --> 00:41:02,800
lower bound either by

1108
00:41:02,800 --> 00:41:05,119
moving to computational security or by

1109
00:41:05,119 --> 00:41:06,720
moving to um

1110
00:41:06,720 --> 00:41:09,440
quadratic reconstruction

1111
00:41:09,440 --> 00:41:10,319
and

1112
00:41:10,319 --> 00:41:12,319
uh either will be sufficient about the

1113
00:41:12,319 --> 00:41:14,000
low bound and in this world actually

1114
00:41:14,000 --> 00:41:16,160
people um so

1115
00:41:16,160 --> 00:41:18,319
it's not clear that you really need the

1116
00:41:18,319 --> 00:41:20,079
computational version of the encoding

1117
00:41:20,079 --> 00:41:22,079
that's correct but

1118
00:41:22,079 --> 00:41:24,960
uh in the in the work with uh

1119
00:41:24,960 --> 00:41:27,040
you know i came ready we actually have a

1120
00:41:27,040 --> 00:41:28,640
information theoretically encoding with

1121
00:41:28,640 --> 00:41:30,800
degree to reconstruction

1122
00:41:30,800 --> 00:41:32,240
but the construction only works

1123
00:41:32,240 --> 00:41:34,640
overfused characteristics too

1124
00:41:34,640 --> 00:41:35,599
so

1125
00:41:35,599 --> 00:41:37,440
it crucially uses the fact that you know

1126
00:41:37,440 --> 00:41:38,880
when you multiply sometimes i'll

1127
00:41:38,880 --> 00:41:40,880
sometimes appear twice if your fierce

1128
00:41:40,880 --> 00:41:43,200
characteristic do this uh this cross

1129
00:41:43,200 --> 00:41:46,240
terms are difficult to handle cancer and

1130
00:41:46,240 --> 00:41:48,160
i wish you don't know how to extend that

1131
00:41:48,160 --> 00:41:49,440
uh

1132
00:41:49,440 --> 00:41:54,079
that encoding to uh general view small p

1133
00:41:54,079 --> 00:41:55,760
so and it's very considerable whether

1134
00:41:55,760 --> 00:41:57,760
that's doable um so then that would

1135
00:41:57,760 --> 00:41:58,720
potentially give you different

1136
00:41:58,720 --> 00:42:00,240
construction

1137
00:42:00,240 --> 00:42:02,480
but i guess that is for broadcast

1138
00:42:02,480 --> 00:42:05,040
encryption sufficient to do the uh

1139
00:42:05,040 --> 00:42:06,480
commercial version so that's what we

1140
00:42:06,480 --> 00:42:07,760
ended up doing

1141
00:42:07,760 --> 00:42:11,280
yeah yeah okay thank you

1142
00:42:12,400 --> 00:42:15,359
uh okay i will be able to mute uh a few

1143
00:42:15,359 --> 00:42:18,799
people that are raising their hands

1144
00:42:20,640 --> 00:42:23,200
i'm trying

1145
00:42:23,920 --> 00:42:25,680
they can actually unmute themselves you

1146
00:42:25,680 --> 00:42:28,800
won't need to do it manually

1147
00:42:28,800 --> 00:42:30,720
i think it worked so i think uh prabhan

1148
00:42:30,720 --> 00:42:33,040
channel had a question for razi sand

1149
00:42:33,040 --> 00:42:34,880
yeah i have a couple of questions one

1150
00:42:34,880 --> 00:42:38,079
for monastics and one for bishop

1151
00:42:38,079 --> 00:42:39,040
um

1152
00:42:39,040 --> 00:42:41,119
my first question is uh so regarding

1153
00:42:41,119 --> 00:42:42,560
this your

1154
00:42:42,560 --> 00:42:44,319
point on the last slide about removing

1155
00:42:44,319 --> 00:42:46,079
runtime dependence on the ciphertext

1156
00:42:46,079 --> 00:42:47,040
size

1157
00:42:47,040 --> 00:42:48,720
um is there some

1158
00:42:48,720 --> 00:42:50,000
barrier for

1159
00:42:50,000 --> 00:42:52,160
using like sustain gobbling schemes to

1160
00:42:52,160 --> 00:42:54,480
generically

1161
00:42:54,480 --> 00:42:56,480
remove the runtime dependence on the

1162
00:42:56,480 --> 00:42:58,640
time bond

1163
00:42:58,640 --> 00:43:02,079
uh i'm not really sure about that but in

1164
00:43:02,079 --> 00:43:04,160
our compiler it actually

1165
00:43:04,160 --> 00:43:05,680
i mean the runtime

1166
00:43:05,680 --> 00:43:08,160
became a factor because we used at the

1167
00:43:08,160 --> 00:43:10,079
end we used universal circuits where we

1168
00:43:10,079 --> 00:43:12,240
had to run the turing machine on the

1169
00:43:12,240 --> 00:43:14,400
input x inside the circuit for some t

1170
00:43:14,400 --> 00:43:16,560
number of steps

1171
00:43:16,560 --> 00:43:18,640
and because turing machine i mean if you

1172
00:43:18,640 --> 00:43:20,560
don't know a runtime bound you cannot

1173
00:43:20,560 --> 00:43:22,800
have the circuit size

1174
00:43:22,800 --> 00:43:24,400
you cannot know the circuit size before

1175
00:43:24,400 --> 00:43:25,760
android

1176
00:43:25,760 --> 00:43:27,680
so essentially that became a bottleneck

1177
00:43:27,680 --> 00:43:30,160
in our compiler actually why that is

1178
00:43:30,160 --> 00:43:31,520
because uh

1179
00:43:31,520 --> 00:43:33,200
that is because of which we need to

1180
00:43:33,200 --> 00:43:35,839
bound the runtime of the ciphertext

1181
00:43:35,839 --> 00:43:38,400
but i am not sure if succinct garbling

1182
00:43:38,400 --> 00:43:40,160
schemes

1183
00:43:40,160 --> 00:43:41,359
because because you can gobble the

1184
00:43:41,359 --> 00:43:44,560
encryption algorithm right and the

1185
00:43:44,560 --> 00:43:46,960
the cobbled uh turing machine will not

1186
00:43:46,960 --> 00:43:48,800
depend on the

1187
00:43:48,800 --> 00:43:50,640
encryption complexity right you're sort

1188
00:43:50,640 --> 00:43:51,440
of

1189
00:43:51,440 --> 00:43:54,640
uh delegating or rather differing the

1190
00:43:54,640 --> 00:43:56,079
execution of encryption to the

1191
00:43:56,079 --> 00:43:58,000
decryption phase

1192
00:43:58,000 --> 00:44:00,319
yeah

1193
00:44:00,480 --> 00:44:03,119
uh yeah i mean i need to look think

1194
00:44:03,119 --> 00:44:05,280
about it in a bit more detail and can

1195
00:44:05,280 --> 00:44:07,680
take your question offline uh but yeah i

1196
00:44:07,680 --> 00:44:09,359
need to think about it in more detail

1197
00:44:09,359 --> 00:44:10,400
yeah there's a reason i mentioned that

1198
00:44:10,400 --> 00:44:12,480
that can be telling schemes is also

1199
00:44:12,480 --> 00:44:14,000
because maybe

1200
00:44:14,000 --> 00:44:15,920
the implication might go the other way

1201
00:44:15,920 --> 00:44:17,599
around as well like if you consider like

1202
00:44:17,599 --> 00:44:19,200
a fe for turing machine

1203
00:44:19,200 --> 00:44:22,160
where the ciphertext size grows with uh

1204
00:44:22,160 --> 00:44:23,520
does not grow with the runtime bond

1205
00:44:23,520 --> 00:44:24,880
maybe this already implies it's in

1206
00:44:24,880 --> 00:44:27,040
governing schemes

1207
00:44:27,040 --> 00:44:30,560
yeah that would be as well yes yeah

1208
00:44:30,560 --> 00:44:32,000
um

1209
00:44:32,000 --> 00:44:34,240
can i ask one more question to reshap or

1210
00:44:34,240 --> 00:44:37,839
should i circle back

1211
00:44:39,040 --> 00:44:40,240
uh

1212
00:44:40,240 --> 00:44:42,240
yeah sure if it's yeah is it a quick

1213
00:44:42,240 --> 00:44:43,760
question yeah

1214
00:44:43,760 --> 00:44:47,920
so um it's a uh yeah so you consider

1215
00:44:47,920 --> 00:44:50,319
construct mi fee for quadratic functions

1216
00:44:50,319 --> 00:44:52,720
right and i would imagine constructing

1217
00:44:52,720 --> 00:44:55,680
mit for like cubic functions

1218
00:44:55,680 --> 00:44:58,480
would imply i o so um you would need

1219
00:44:58,480 --> 00:45:00,400
probably more assumptions

1220
00:45:00,400 --> 00:45:02,560
but you can you can construct something

1221
00:45:02,560 --> 00:45:04,960
in between uh like rama and others

1222
00:45:04,960 --> 00:45:07,920
consider this notion of uh

1223
00:45:07,920 --> 00:45:10,480
just like public nc1 evaluation and

1224
00:45:10,480 --> 00:45:12,400
private like quadratic evaluation right

1225
00:45:12,400 --> 00:45:15,200
like can you get the same uh result for

1226
00:45:15,200 --> 00:45:17,680
mif as well

1227
00:45:17,680 --> 00:45:19,920
i guess yeah possibly it's a good

1228
00:45:19,920 --> 00:45:21,520
question so it's like that's possible

1229
00:45:21,520 --> 00:45:23,040
and uh

1230
00:45:23,040 --> 00:45:24,720
i mean i think a good starting point

1231
00:45:24,720 --> 00:45:25,680
would be trying to optimize the

1232
00:45:25,680 --> 00:45:27,119
ciphertext size it's like the

1233
00:45:27,119 --> 00:45:29,119
construction that we have it's not uh i

1234
00:45:29,119 --> 00:45:31,119
mean you don't need to sort of uh

1235
00:45:31,119 --> 00:45:32,560
the ciphertext size need not depend upon

1236
00:45:32,560 --> 00:45:34,880
the number of users or quadratically on

1237
00:45:34,880 --> 00:45:37,359
the underlying sort of uh message length

1238
00:45:37,359 --> 00:45:39,599
and we still have that dependence

1239
00:45:39,599 --> 00:45:40,400
so

1240
00:45:40,400 --> 00:45:42,480
it's though it's not genetically implied

1241
00:45:42,480 --> 00:45:44,160
uh in sort of multi-input cases for

1242
00:45:44,160 --> 00:45:45,440
quadratic functions but it's like still

1243
00:45:45,440 --> 00:45:46,720
interesting trying to improve that part

1244
00:45:46,720 --> 00:45:48,400
first but yeah if you can improve that

1245
00:45:48,400 --> 00:45:49,680
then maybe it's like they might be hope

1246
00:45:49,680 --> 00:45:51,359
that okay maybe you can sort of because

1247
00:45:51,359 --> 00:45:52,400
right now if you sort of have this

1248
00:45:52,400 --> 00:45:54,400
public component of the f evaluation

1249
00:45:54,400 --> 00:45:56,560
then we are sort of just uh blowing

1250
00:45:56,560 --> 00:45:58,400
things up a little more and that blow up

1251
00:45:58,400 --> 00:45:59,760
might be a little more and you might be

1252
00:45:59,760 --> 00:46:01,200
able to do what you're trying to suggest

1253
00:46:01,200 --> 00:46:02,400
trying to have this public component of

1254
00:46:02,400 --> 00:46:04,079
the computation that might be possible

1255
00:46:04,079 --> 00:46:05,839
but it's like it really depends whether

1256
00:46:05,839 --> 00:46:06,640
that technique applies in the

1257
00:46:06,640 --> 00:46:08,560
multi-input setting or not possibly but

1258
00:46:08,560 --> 00:46:09,760
not sure

1259
00:46:09,760 --> 00:46:13,160
okay thanks

1260
00:46:14,880 --> 00:46:16,480
all right thank you

1261
00:46:16,480 --> 00:46:17,599
um

1262
00:46:17,599 --> 00:46:20,480
i think uh rohit chatterjee wanted to

1263
00:46:20,480 --> 00:46:22,400
ask a question

1264
00:46:22,400 --> 00:46:24,720
can you please uh mute yourself yeah

1265
00:46:24,720 --> 00:46:26,640
sorry i think i've been mostly preempted

1266
00:46:26,640 --> 00:46:29,119
by prabhanjan but also

1267
00:46:29,119 --> 00:46:31,040
as a follow-up to rishabh

1268
00:46:31,040 --> 00:46:32,720
can you blow up your key size and do

1269
00:46:32,720 --> 00:46:34,480
more than quadratic

1270
00:46:34,480 --> 00:46:35,359
uh

1271
00:46:35,359 --> 00:46:37,040
or are you logged into quadratic in many

1272
00:46:37,040 --> 00:46:39,599
different ways

1273
00:46:39,920 --> 00:46:41,520
um

1274
00:46:41,520 --> 00:46:43,680
i can't say for sure but i would say we

1275
00:46:43,680 --> 00:46:45,440
might be locked into quadratic reason

1276
00:46:45,440 --> 00:46:46,240
being

1277
00:46:46,240 --> 00:46:48,560
uh we do not have enough i mean we only

1278
00:46:48,560 --> 00:46:50,400
have one pairing available and we are

1279
00:46:50,400 --> 00:46:52,000
sort of using the pairings available to

1280
00:46:52,000 --> 00:46:54,160
us in a in a nice enough way even if you

1281
00:46:54,160 --> 00:46:55,200
sort of

1282
00:46:55,200 --> 00:46:56,880
blow up the key size it's not the key

1283
00:46:56,880 --> 00:46:57,680
size

1284
00:46:57,680 --> 00:46:59,040
the ciphertext size is being blown up

1285
00:46:59,040 --> 00:47:00,400
and the key size globe is not the

1286
00:47:00,400 --> 00:47:01,920
problem because anyways the key is

1287
00:47:01,920 --> 00:47:03,599
always going to depend upon the length

1288
00:47:03,599 --> 00:47:05,599
of the vector this is the c vector you

1289
00:47:05,599 --> 00:47:07,440
have to have that information available

1290
00:47:07,440 --> 00:47:09,359
so the question you're saying okay maybe

1291
00:47:09,359 --> 00:47:11,599
if you blow it up by even more

1292
00:47:11,599 --> 00:47:12,960
it might happen that you might be able

1293
00:47:12,960 --> 00:47:16,000
to reduce the potentially the circuits

1294
00:47:16,000 --> 00:47:18,160
or the ciphertext size maybe

1295
00:47:18,160 --> 00:47:19,520
but if you're trying to ask whether you

1296
00:47:19,520 --> 00:47:21,760
can sort of extend the function plus i'm

1297
00:47:21,760 --> 00:47:23,280
not too sure

1298
00:47:23,280 --> 00:47:24,960
intimately i don't see exactly why that

1299
00:47:24,960 --> 00:47:27,359
will help might but i can't say for sure

1300
00:47:27,359 --> 00:47:30,558
sure i don't thought thank you

1301
00:47:31,280 --> 00:47:33,359
thank you

1302
00:47:33,359 --> 00:47:35,359
um mike was like

1303
00:47:35,359 --> 00:47:37,599
and you want to ask a question

1304
00:47:37,599 --> 00:47:39,280
uh sure i had a question for the last

1305
00:47:39,280 --> 00:47:43,760
speaker yi wong if he's still here um

1306
00:47:43,760 --> 00:47:46,240
so in our 2007

1307
00:47:46,240 --> 00:47:48,800
rcca encryption scheme we had this weird

1308
00:47:48,800 --> 00:47:51,680
assumption about ddh in related groups

1309
00:47:51,680 --> 00:47:53,920
and i'm wondering if your ddh uh

1310
00:47:53,920 --> 00:47:56,480
instantiation still has that uh strange

1311
00:47:56,480 --> 00:47:58,319
feature or if you're able to somehow get

1312
00:47:58,319 --> 00:48:00,559
rid of that

1313
00:48:00,559 --> 00:48:04,079
okay yes yes the group will have to use

1314
00:48:04,079 --> 00:48:06,960
where also has to us

1315
00:48:06,960 --> 00:48:08,079
to be the

1316
00:48:08,079 --> 00:48:09,680
the coming chain

1317
00:48:09,680 --> 00:48:12,960
and yeah yes we still have to obey that

1318
00:48:12,960 --> 00:48:15,599
requirement

1319
00:48:17,040 --> 00:48:20,359
okay thanks

1320
00:48:23,280 --> 00:48:26,640
okay um stanislaw jareki wanted to also

1321
00:48:26,640 --> 00:48:27,520
ask

1322
00:48:27,520 --> 00:48:29,920
questions

1323
00:48:29,920 --> 00:48:31,920
um

1324
00:48:31,920 --> 00:48:33,200
hi

1325
00:48:33,200 --> 00:48:35,200
it's also a question to

1326
00:48:35,200 --> 00:48:37,599
the last speaker yi wang

1327
00:48:37,599 --> 00:48:39,760
maybe it's naive but i'm not sure i

1328
00:48:39,760 --> 00:48:42,480
understood the attack on the pr scheme

1329
00:48:42,480 --> 00:48:43,359
and

1330
00:48:43,359 --> 00:48:46,400
and the model so you said that

1331
00:48:46,400 --> 00:48:48,480
the problem with this previous

1332
00:48:48,480 --> 00:48:52,079
re-randomizable encryption was that

1333
00:48:52,079 --> 00:48:55,200
attacker can pick a public key

1334
00:48:55,200 --> 00:48:58,160
uh randomize the cipher text in a very

1335
00:48:58,160 --> 00:48:59,839
special way

1336
00:48:59,839 --> 00:49:00,559
uh

1337
00:49:00,559 --> 00:49:03,119
using that target public key and then

1338
00:49:03,119 --> 00:49:04,800
sends the result to the decryption

1339
00:49:04,800 --> 00:49:08,960
article and see if it's decrypted or not

1340
00:49:08,960 --> 00:49:09,920
but

1341
00:49:09,920 --> 00:49:10,720
if

1342
00:49:10,720 --> 00:49:12,960
if your decryption oracle

1343
00:49:12,960 --> 00:49:15,359
decrypts per

1344
00:49:15,359 --> 00:49:17,280
public key then

1345
00:49:17,280 --> 00:49:19,359
uh if you have subscription articles and

1346
00:49:19,359 --> 00:49:22,240
everything is the anonymized just by

1347
00:49:22,240 --> 00:49:24,000
querying the decryption oracle right

1348
00:49:24,000 --> 00:49:26,400
because i can just ask you know is this

1349
00:49:26,400 --> 00:49:28,480
a valid cipher text for a certain public

1350
00:49:28,480 --> 00:49:30,800
key and a decryption oracle will tell me

1351
00:49:30,800 --> 00:49:32,160
yes no

1352
00:49:32,160 --> 00:49:33,040
so

1353
00:49:33,040 --> 00:49:35,359
i think i'm missing something from the

1354
00:49:35,359 --> 00:49:38,400
from the security model

1355
00:49:38,400 --> 00:49:42,319
uh yes and and a key a key point to

1356
00:49:42,319 --> 00:49:44,559
achieve associated reserve anonymity is

1357
00:49:44,559 --> 00:49:47,359
that the adversary cannot

1358
00:49:47,359 --> 00:49:49,920
re-encrypt the separatist with public

1359
00:49:49,920 --> 00:49:50,800
key

1360
00:49:50,800 --> 00:49:54,400
so you can see the security game if the

1361
00:49:54,400 --> 00:49:56,319
if the adversary can be encrypted

1362
00:49:56,319 --> 00:49:58,960
several times with public key it can

1363
00:49:58,960 --> 00:50:01,280
guess the public key it can guess the

1364
00:50:01,280 --> 00:50:03,280
public key and re-encrypt part of the

1365
00:50:03,280 --> 00:50:04,880
separatist

1366
00:50:04,880 --> 00:50:06,000
and

1367
00:50:06,000 --> 00:50:08,480
then he can send the

1368
00:50:08,480 --> 00:50:11,119
new server test to the digital oracle to

1369
00:50:11,119 --> 00:50:14,480
verify its guess because because the

1370
00:50:14,480 --> 00:50:16,400
diffusion oracle would reply would

1371
00:50:16,400 --> 00:50:18,960
return replay if it is valid or

1372
00:50:18,960 --> 00:50:22,079
symmetrized and it would return about if

1373
00:50:22,079 --> 00:50:23,200
there

1374
00:50:23,200 --> 00:50:25,040
is a is a valid

1375
00:50:25,040 --> 00:50:27,200
test so it can

1376
00:50:27,200 --> 00:50:30,079
distinguish it can verify its guess via

1377
00:50:30,079 --> 00:50:31,599
the

1378
00:50:31,599 --> 00:50:34,160
output of the digital oracle

1379
00:50:34,160 --> 00:50:36,400
so if we have to achieve reserve

1380
00:50:36,400 --> 00:50:39,280
anonymity we have to make sure that

1381
00:50:39,280 --> 00:50:42,319
the only valid way to randomize the

1382
00:50:42,319 --> 00:50:45,119
separatist is not involving

1383
00:50:45,119 --> 00:50:47,200
does not does not involve in the public

1384
00:50:47,200 --> 00:50:48,079
key

1385
00:50:48,079 --> 00:50:50,880
so we have so that is why

1386
00:50:50,880 --> 00:50:53,440
in this slide in our treatment we have

1387
00:50:53,440 --> 00:50:55,040
to disable

1388
00:50:55,040 --> 00:50:57,040
all the randomization

1389
00:50:57,040 --> 00:50:59,200
using the public key and they don't do

1390
00:50:59,200 --> 00:51:02,079
anything so i i think that the the issue

1391
00:51:02,079 --> 00:51:04,400
is like what is this decryption article

1392
00:51:04,400 --> 00:51:06,720
exactly so you you're assuming the

1393
00:51:06,720 --> 00:51:08,880
decryption article that

1394
00:51:08,880 --> 00:51:10,640
it doesn't decrypt

1395
00:51:10,640 --> 00:51:14,720
anything it just tells you a bit

1396
00:51:14,720 --> 00:51:17,119
what would i do

1397
00:51:17,119 --> 00:51:18,880
the degradation will

1398
00:51:18,880 --> 00:51:22,160
deplete the separatist using two

1399
00:51:22,160 --> 00:51:23,520
different

1400
00:51:23,520 --> 00:51:26,160
secret secret key

1401
00:51:26,160 --> 00:51:29,280
you have only two public keys right

1402
00:51:29,280 --> 00:51:31,760
uh the challenger will provide

1403
00:51:31,760 --> 00:51:33,359
two different public key to the

1404
00:51:33,359 --> 00:51:34,720
adversary

1405
00:51:34,720 --> 00:51:36,400
yeah okay okay

1406
00:51:36,400 --> 00:51:39,359
yeah and and and the yeah and and so the

1407
00:51:39,359 --> 00:51:41,520
decryption article decrypts under the

1408
00:51:41,520 --> 00:51:44,480
two keys and

1409
00:51:44,480 --> 00:51:45,680
yes the

1410
00:51:45,680 --> 00:51:47,680
the demolition would decrypt the

1411
00:51:47,680 --> 00:51:48,839
separatist

1412
00:51:48,839 --> 00:51:51,520
using to using two

1413
00:51:51,520 --> 00:51:54,720
separate key respectively so if one of

1414
00:51:54,720 --> 00:51:57,599
the decision results equals to the

1415
00:51:57,599 --> 00:52:00,480
challenge plaintext m star so the oracle

1416
00:52:00,480 --> 00:52:02,640
would return replay

1417
00:52:02,640 --> 00:52:05,520
otherwise it would return the equation

1418
00:52:05,520 --> 00:52:08,800
results honestly

1419
00:52:14,240 --> 00:52:15,760
okay

1420
00:52:15,760 --> 00:52:16,559
okay

1421
00:52:16,559 --> 00:52:17,839
okay

1422
00:52:17,839 --> 00:52:18,240
um

1423
00:52:18,240 --> 00:52:19,599
[Music]

1424
00:52:19,599 --> 00:52:22,240
this is a subtle uh subtle thing so

1425
00:52:22,240 --> 00:52:23,920
thank you so much

1426
00:52:23,920 --> 00:52:25,599
for explaining that

1427
00:52:25,599 --> 00:52:27,200
i thank you very much thank you for your

1428
00:52:27,200 --> 00:52:30,200
question

1429
00:52:41,119 --> 00:52:42,160
all right

1430
00:52:42,160 --> 00:52:44,000
uh i just have one last question i guess

1431
00:52:44,000 --> 00:52:46,880
there's nobody else asking questions er

1432
00:52:46,880 --> 00:52:49,119
before we stop uh

1433
00:52:49,119 --> 00:52:51,280
question to you you won

1434
00:52:51,280 --> 00:52:52,160
a

1435
00:52:52,160 --> 00:52:53,440
just uh

1436
00:52:53,440 --> 00:52:57,040
mention if he's still here yes okay uh

1437
00:52:57,040 --> 00:52:59,280
yeah you mentioned basically it's a very

1438
00:52:59,280 --> 00:53:00,960
high level question do you know if these

1439
00:53:00,960 --> 00:53:02,400
techniques that you

1440
00:53:02,400 --> 00:53:04,480
came up with uh

1441
00:53:04,480 --> 00:53:06,079
basically you are reproducing dual

1442
00:53:06,079 --> 00:53:08,880
system methodology without pairing

1443
00:53:08,880 --> 00:53:09,839
so

1444
00:53:09,839 --> 00:53:12,480
you mentioned ibe music is there any

1445
00:53:12,480 --> 00:53:15,200
other primitive uh

1446
00:53:15,200 --> 00:53:16,880
for example functional encryption for

1447
00:53:16,880 --> 00:53:18,640
inner products or quadratic functions

1448
00:53:18,640 --> 00:53:20,160
that you could hope to do with your

1449
00:53:20,160 --> 00:53:21,760
techniques

1450
00:53:21,760 --> 00:53:22,960
um

1451
00:53:22,960 --> 00:53:25,040
okay um

1452
00:53:25,040 --> 00:53:26,240
actually i

1453
00:53:26,240 --> 00:53:28,559
haven't considered i mean general

1454
00:53:28,559 --> 00:53:30,319
functional encryption yet

1455
00:53:30,319 --> 00:53:31,520
but

1456
00:53:31,520 --> 00:53:32,800
actually we

1457
00:53:32,800 --> 00:53:35,200
have been um in this paper we talked

1458
00:53:35,200 --> 00:53:37,359
about the queueing risk but

1459
00:53:37,359 --> 00:53:38,319
uh

1460
00:53:38,319 --> 00:53:40,000
in a following paper

1461
00:53:40,000 --> 00:53:42,880
which we haven't published yet but uh in

1462
00:53:42,880 --> 00:53:46,079
that paper we we have constructed nisk

1463
00:53:46,079 --> 00:53:48,400
in the urs model and also now

1464
00:53:48,400 --> 00:53:51,280
interactive zap

1465
00:53:51,520 --> 00:53:53,680
yeah and

1466
00:53:53,680 --> 00:53:57,520
maybe i'm not sure whether more

1467
00:53:57,520 --> 00:53:58,960
non-tribute

1468
00:53:58,960 --> 00:54:00,800
primitives can be constructed in this

1469
00:54:00,800 --> 00:54:05,040
world i mean that might be interesting

1470
00:54:05,040 --> 00:54:07,040
okay thank you

1471
00:54:07,040 --> 00:54:10,200
thank you

1472
00:54:11,280 --> 00:54:13,200
alright so i guess we can close the

1473
00:54:13,200 --> 00:54:16,720
session if there's no more questions

1474
00:54:16,960 --> 00:54:19,760
in the

