1
00:00:00,320 --> 00:00:02,800
this talk is on halo infinity or proof

2
00:00:02,800 --> 00:00:04,880
carrying data from additive polynomial

3
00:00:04,880 --> 00:00:06,080
commitments

4
00:00:06,080 --> 00:00:08,400
i am ben fish from stanford university

5
00:00:08,400 --> 00:00:09,920
and my co-authors on this work are dan

6
00:00:09,920 --> 00:00:12,559
bonnett justin drake and ariel gabizon

7
00:00:12,559 --> 00:00:14,559
proof carrying data is an extension of

8
00:00:14,559 --> 00:00:16,480
non-interactive proof systems so let's

9
00:00:16,480 --> 00:00:17,920
begin by briefly reviewing

10
00:00:17,920 --> 00:00:20,400
non-interactive proof systems at a very

11
00:00:20,400 --> 00:00:22,080
high level a prover sends a proof to a

12
00:00:22,080 --> 00:00:24,000
verifier that helps the verifier check

13
00:00:24,000 --> 00:00:26,160
some claim the reason why this is useful

14
00:00:26,160 --> 00:00:28,000
is there is typically some asymmetry

15
00:00:28,000 --> 00:00:30,080
between the prover and verifier either

16
00:00:30,080 --> 00:00:31,920
in terms of computational resources or

17
00:00:31,920 --> 00:00:34,160
knowledge of secret information

18
00:00:34,160 --> 00:00:36,399
one flavor of a non-interactive proof is

19
00:00:36,399 --> 00:00:39,360
a non-interactive zero-knowledge proof

20
00:00:39,360 --> 00:00:40,960
here the prover wants to convince a

21
00:00:40,960 --> 00:00:42,640
verifier that a statement is true

22
00:00:42,640 --> 00:00:44,320
without revealing some secret evidence

23
00:00:44,320 --> 00:00:46,559
behind the statement's truth

24
00:00:46,559 --> 00:00:48,320
in other words the prover knows a

25
00:00:48,320 --> 00:00:50,480
private input w to some program such

26
00:00:50,480 --> 00:00:52,480
that the program evaluates to one on

27
00:00:52,480 --> 00:00:54,399
this private input

28
00:00:54,399 --> 00:00:56,079
and the prover sends a proof to the

29
00:00:56,079 --> 00:00:57,440
verifier the verifier runs a

30
00:00:57,440 --> 00:00:59,120
verification algorithm to accept or

31
00:00:59,120 --> 00:01:00,160
reject

32
00:01:00,160 --> 00:01:02,239
soundness says that it's infeasible to

33
00:01:02,239 --> 00:01:03,680
produce a valid proof if the prover

34
00:01:03,680 --> 00:01:05,600
doesn't know such a w

35
00:01:05,600 --> 00:01:07,119
and zero knowledge says that the proof

36
00:01:07,119 --> 00:01:09,920
doesn't reveal anything about w

37
00:01:09,920 --> 00:01:11,760
when the proof verification is

38
00:01:11,760 --> 00:01:13,600
asymptotically faster than program

39
00:01:13,600 --> 00:01:16,080
evaluation then we call this verifiable

40
00:01:16,080 --> 00:01:17,439
computation

41
00:01:17,439 --> 00:01:19,200
or snarks which stands for succinct

42
00:01:19,200 --> 00:01:21,520
non-interactive arguments of knowledge

43
00:01:21,520 --> 00:01:23,200
here the proof should be small and fast

44
00:01:23,200 --> 00:01:25,439
to verify even as the program grows very

45
00:01:25,439 --> 00:01:28,080
complex or the witness grows very long

46
00:01:28,080 --> 00:01:29,840
zero knowledge in this case is an

47
00:01:29,840 --> 00:01:32,720
optional extra feature

48
00:01:32,720 --> 00:01:33,920
ibc

49
00:01:33,920 --> 00:01:36,479
incrementally verifiable computation

50
00:01:36,479 --> 00:01:38,400
enables incrementally updating a proof

51
00:01:38,400 --> 00:01:40,479
of computation's correctness as the

52
00:01:40,479 --> 00:01:42,640
computation evolves

53
00:01:42,640 --> 00:01:45,040
each proof attests to the correctness of

54
00:01:45,040 --> 00:01:48,560
the computation up until this point

55
00:01:48,560 --> 00:01:50,799
importantly for ivc to be non-trivial

56
00:01:50,799 --> 00:01:52,560
the cost to produce the next proof at

57
00:01:52,560 --> 00:01:54,479
the i-th iteration given the local state

58
00:01:54,479 --> 00:01:56,479
should be cheaper than producing

59
00:01:56,479 --> 00:01:58,320
the proof from scratch

60
00:01:58,320 --> 00:02:00,079
in other words sublinear in the depth

61
00:02:00,079 --> 00:02:01,520
and should not require the previous

62
00:02:01,520 --> 00:02:03,040
local inputs which may have been

63
00:02:03,040 --> 00:02:04,479
discarded

64
00:02:04,479 --> 00:02:06,159
ivc has been important for recent

65
00:02:06,159 --> 00:02:07,840
real-world applications including to

66
00:02:07,840 --> 00:02:09,758
blockchains and certificate transparency

67
00:02:09,758 --> 00:02:11,680
logs

68
00:02:11,680 --> 00:02:13,120
although not quite the standard way of

69
00:02:13,120 --> 00:02:15,920
presenting ivc i like to describe ibc as

70
00:02:15,920 --> 00:02:18,239
also optionally passing along a separate

71
00:02:18,239 --> 00:02:20,160
prover state in addition to the proof

72
00:02:20,160 --> 00:02:22,560
and the local computation output

73
00:02:22,560 --> 00:02:24,400
this is not needed to verify the proof

74
00:02:24,400 --> 00:02:26,400
but helps the prover to produce the next

75
00:02:26,400 --> 00:02:27,920
proof which is why it makes sense to

76
00:02:27,920 --> 00:02:30,000
separate these components classical

77
00:02:30,000 --> 00:02:31,680
constructions of ipc

78
00:02:31,680 --> 00:02:33,760
via proof recursion did not utilize any

79
00:02:33,760 --> 00:02:35,200
extra prover state but newer

80
00:02:35,200 --> 00:02:39,040
constructions such as in this work do

81
00:02:39,599 --> 00:02:42,560
proof carrying data or pcd generalizes

82
00:02:42,560 --> 00:02:45,920
ivc to any distributed computation

83
00:02:45,920 --> 00:02:47,760
where the nodes of the computation are

84
00:02:47,760 --> 00:02:50,560
just are organized as a directed acyclic

85
00:02:50,560 --> 00:02:51,599
graph

86
00:02:51,599 --> 00:02:53,920
so ivc is a special case of

87
00:02:53,920 --> 00:02:55,680
of proof carrying data corresponding to

88
00:02:55,680 --> 00:02:58,159
a path distributed computation

89
00:02:58,159 --> 00:03:00,239
similarly to ivc we can separate the

90
00:03:00,239 --> 00:03:02,959
proof components pass along the edges of

91
00:03:02,959 --> 00:03:05,599
this computation into a proof and

92
00:03:05,599 --> 00:03:07,040
approver state

93
00:03:07,040 --> 00:03:08,800
the first is the actual proof that can

94
00:03:08,800 --> 00:03:10,640
be verified and the second component

95
00:03:10,640 --> 00:03:12,239
helps the next node in the computation

96
00:03:12,239 --> 00:03:14,159
produce a proof

97
00:03:14,159 --> 00:03:15,519
we can also have separate efficiency

98
00:03:15,519 --> 00:03:16,959
requirements for the two distinct proof

99
00:03:16,959 --> 00:03:18,640
components as they're used for different

100
00:03:18,640 --> 00:03:20,879
purposes and as their requirements for

101
00:03:20,879 --> 00:03:22,480
each of them may change based on the

102
00:03:22,480 --> 00:03:24,000
application

103
00:03:24,000 --> 00:03:26,640
classical constructions of pcd or ivc

104
00:03:26,640 --> 00:03:27,920
from snarks

105
00:03:27,920 --> 00:03:30,560
used an idea called proof recursion the

106
00:03:30,560 --> 00:03:31,920
high level concept is that the

107
00:03:31,920 --> 00:03:34,319
incremental proof pi i plus 1 is

108
00:03:34,319 --> 00:03:36,080
approved for a witness consisting of the

109
00:03:36,080 --> 00:03:38,640
previous proof pi i the previous

110
00:03:38,640 --> 00:03:42,239
output zi and the local input y i plus

111
00:03:42,239 --> 00:03:43,040
1.

112
00:03:43,040 --> 00:03:44,959
the program checking the witness is

113
00:03:44,959 --> 00:03:48,319
checking the snark verification of this

114
00:03:48,319 --> 00:03:50,720
previous proof pi i and also checking

115
00:03:50,720 --> 00:03:52,959
the local computation so the proving

116
00:03:52,959 --> 00:03:54,720
time is proportional to the size of the

117
00:03:54,720 --> 00:03:57,120
local computation and the snares of the

118
00:03:57,120 --> 00:03:59,519
snark verifier

119
00:03:59,519 --> 00:04:01,439
now i'm skipping some technical details

120
00:04:01,439 --> 00:04:03,920
of how the program uh works which

121
00:04:03,920 --> 00:04:06,720
enables it to reference its own verifier

122
00:04:06,720 --> 00:04:08,480
in a bit more detail here is how it

123
00:04:08,480 --> 00:04:10,560
would work for a pre-processing snark

124
00:04:10,560 --> 00:04:12,480
which is a snark that

125
00:04:12,480 --> 00:04:14,080
has a pre-processing algorithm that can

126
00:04:14,080 --> 00:04:16,079
produce compact proving and verification

127
00:04:16,079 --> 00:04:17,839
keys for a given program programs

128
00:04:17,839 --> 00:04:20,238
represented as having a variable public

129
00:04:20,238 --> 00:04:22,400
input x which will be an input to both

130
00:04:22,400 --> 00:04:24,639
prover and verifier and a variable

131
00:04:24,639 --> 00:04:27,120
private input w capturing the witness

132
00:04:27,120 --> 00:04:30,400
so the recursive program on xw parses

133
00:04:30,400 --> 00:04:32,000
its public input as a variable

134
00:04:32,000 --> 00:04:34,720
verification key the index i plus one

135
00:04:34,720 --> 00:04:36,639
and the local output z i plus one it

136
00:04:36,639 --> 00:04:40,160
parses w as local input y plus one the

137
00:04:40,160 --> 00:04:42,800
previous output zi the previous proof pi

138
00:04:42,800 --> 00:04:43,680
i

139
00:04:43,680 --> 00:04:45,600
and it runs the snark verification

140
00:04:45,600 --> 00:04:48,240
algorithm on the verification key the

141
00:04:48,240 --> 00:04:50,720
previous index previous output previous

142
00:04:50,720 --> 00:04:51,840
proof

143
00:04:51,840 --> 00:04:55,120
and also checks the local predicate f

144
00:04:55,120 --> 00:04:56,639
the actual verification key that we

145
00:04:56,639 --> 00:04:58,320
passed to this program will be the

146
00:04:58,320 --> 00:05:00,639
actual pre-processed verification key of

147
00:05:00,639 --> 00:05:01,919
the program but is referenced as a

148
00:05:01,919 --> 00:05:03,520
variable inside the program since we

149
00:05:03,520 --> 00:05:05,199
don't have it yet

150
00:05:05,199 --> 00:05:06,880
halo was the first

151
00:05:06,880 --> 00:05:09,120
pcb based on an underlying proof system

152
00:05:09,120 --> 00:05:11,440
that has a linear time verifier

153
00:05:11,440 --> 00:05:13,520
the classical method of constructing pcd

154
00:05:13,520 --> 00:05:15,360
solely from precision would not work

155
00:05:15,360 --> 00:05:17,440
with a linear time verifier but halo

156
00:05:17,440 --> 00:05:19,919
manages to use proof recursion in a way

157
00:05:19,919 --> 00:05:22,800
that does not include the full verifier

158
00:05:22,800 --> 00:05:26,160
in the incremental approvers program

159
00:05:26,160 --> 00:05:28,479
this work generalizes halo for a broad

160
00:05:28,479 --> 00:05:30,160
class of proof systems beyond the

161
00:05:30,160 --> 00:05:32,960
specific one used in halo paper

162
00:05:32,960 --> 00:05:35,199
there are two important recent papers

163
00:05:35,199 --> 00:05:37,039
related to ours that i'd like to mention

164
00:05:37,039 --> 00:05:40,720
here the first is bcms 20 which

165
00:05:40,720 --> 00:05:42,160
formalized and

166
00:05:42,160 --> 00:05:44,800
generalized the halo method

167
00:05:44,800 --> 00:05:47,039
identifying an underlying necessary

168
00:05:47,039 --> 00:05:48,080
property

169
00:05:48,080 --> 00:05:50,400
of argument or proof systems called an

170
00:05:50,400 --> 00:05:53,120
accumulation scheme

171
00:05:53,120 --> 00:05:55,680
and b c l m s 20 which further

172
00:05:55,680 --> 00:05:57,919
generalized the halo method to work with

173
00:05:57,919 --> 00:06:00,720
even non-succinct argument systems that

174
00:06:00,720 --> 00:06:03,280
have something that they call a split

175
00:06:03,280 --> 00:06:05,280
accumulation scheme

176
00:06:05,280 --> 00:06:07,600
now while these works focus on defining

177
00:06:07,600 --> 00:06:09,840
the abstraction of accumulation schemes

178
00:06:09,840 --> 00:06:11,600
for proof systems and how to use them to

179
00:06:11,600 --> 00:06:13,520
build pcd

180
00:06:13,520 --> 00:06:16,639
our work focuses more on

181
00:06:16,639 --> 00:06:18,240
properties of polynomial commitment

182
00:06:18,240 --> 00:06:20,000
schemes that lead to proof systems with

183
00:06:20,000 --> 00:06:22,880
accumulation and split accumulation

184
00:06:22,880 --> 00:06:25,520
and also gives generic constructions

185
00:06:25,520 --> 00:06:28,400
of accumulation

186
00:06:28,639 --> 00:06:30,560
let me briefly review

187
00:06:30,560 --> 00:06:33,039
what polynomial commitment schemes are

188
00:06:33,039 --> 00:06:35,600
a polynomial commitment scheme provides

189
00:06:35,600 --> 00:06:37,600
algorithms that enable producing a small

190
00:06:37,600 --> 00:06:39,759
value committing to a polynomial of

191
00:06:39,759 --> 00:06:42,400
bounded degree over a finite field

192
00:06:42,400 --> 00:06:44,240
and then later to provide proofs of

193
00:06:44,240 --> 00:06:46,639
evaluations of this committed polynomial

194
00:06:46,639 --> 00:06:49,199
at chosen points

195
00:06:49,199 --> 00:06:51,280
although not a strict requirement

196
00:06:51,280 --> 00:06:53,120
ideally these proofs should be

197
00:06:53,120 --> 00:06:56,000
succinct or sublinear indeed and

198
00:06:56,000 --> 00:06:58,240
efficient to verify also sublinear

199
00:06:58,240 --> 00:07:00,080
indeed

200
00:07:00,080 --> 00:07:01,599
more formally it combines a normal

201
00:07:01,599 --> 00:07:03,440
commitment scheme with a non-interactive

202
00:07:03,440 --> 00:07:04,560
proof

203
00:07:04,560 --> 00:07:05,759
the normal commitment scheme should

204
00:07:05,759 --> 00:07:07,120
satisfy the usual definition of

205
00:07:07,120 --> 00:07:08,720
committed binding

206
00:07:08,720 --> 00:07:09,599
to

207
00:07:09,599 --> 00:07:11,840
its input domain which are polynomials

208
00:07:11,840 --> 00:07:13,840
over fp of degree at most d and the

209
00:07:13,840 --> 00:07:15,280
non-interactive proof should be an

210
00:07:15,280 --> 00:07:17,440
argument of knowledge

211
00:07:17,440 --> 00:07:19,919
of an opening of a commitment

212
00:07:19,919 --> 00:07:22,000
to a polynomial such that the polynomial

213
00:07:22,000 --> 00:07:25,919
evaluates at z to a point y

214
00:07:25,919 --> 00:07:28,560
a polynomial interactive oracle proof is

215
00:07:28,560 --> 00:07:30,720
a public coin interactive proof between

216
00:07:30,720 --> 00:07:32,880
the prover and verifier where the prover

217
00:07:32,880 --> 00:07:34,720
sends polynomials to the verifier that

218
00:07:34,720 --> 00:07:37,759
the verifier accesses through oracles

219
00:07:37,759 --> 00:07:39,919
and uses those oracles for polynomial

220
00:07:39,919 --> 00:07:42,000
evaluation it checks some equation of

221
00:07:42,000 --> 00:07:43,360
the responses that depends on the

222
00:07:43,360 --> 00:07:45,440
program and the polynomials of the proof

223
00:07:45,440 --> 00:07:47,039
of sense are dependent on the progress

224
00:07:47,039 --> 00:07:49,199
witness the pro protocol overall is a

225
00:07:49,199 --> 00:07:52,319
proof of knowledge of this witness

226
00:07:52,319 --> 00:07:54,000
to compile this to a concrete

227
00:07:54,000 --> 00:07:55,520
interactive proof between approver and

228
00:07:55,520 --> 00:07:56,720
verifier

229
00:07:56,720 --> 00:07:58,240
and also to compress the size of the

230
00:07:58,240 --> 00:08:00,479
communication the prover instead sends

231
00:08:00,479 --> 00:08:02,479
commitments to the polynomials and

232
00:08:02,479 --> 00:08:04,319
replaces the oracle polynomial

233
00:08:04,319 --> 00:08:07,120
evaluations with evaluation proofs using

234
00:08:07,120 --> 00:08:10,160
the polynomial commitment scheme

235
00:08:10,160 --> 00:08:11,919
finally this can be transformed to a

236
00:08:11,919 --> 00:08:14,240
non-interactive proof using the standard

237
00:08:14,240 --> 00:08:16,400
fiat shamer transform

238
00:08:16,400 --> 00:08:18,720
an additive polynomial commitment scheme

239
00:08:18,720 --> 00:08:20,879
comes with a defined addition operation

240
00:08:20,879 --> 00:08:22,960
that enables taking linear combinations

241
00:08:22,960 --> 00:08:24,240
of commitments

242
00:08:24,240 --> 00:08:26,160
the linear combination should itself be

243
00:08:26,160 --> 00:08:27,520
a valid commitment to the linear

244
00:08:27,520 --> 00:08:29,520
combination of the underlying committed

245
00:08:29,520 --> 00:08:31,840
polynomials so there should additionally

246
00:08:31,840 --> 00:08:33,519
be an algorithm that derives an opening

247
00:08:33,519 --> 00:08:35,679
hint for this linear combination from

248
00:08:35,679 --> 00:08:37,120
the opening hints of the input

249
00:08:37,120 --> 00:08:39,679
commitments which enables producing eval

250
00:08:39,679 --> 00:08:42,320
proofs for the linear combination

251
00:08:42,320 --> 00:08:44,480
now it is always possible to trivially

252
00:08:44,480 --> 00:08:46,399
define this addition operation for

253
00:08:46,399 --> 00:08:48,240
example it could simply be the formal

254
00:08:48,240 --> 00:08:50,240
addition of the commitments

255
00:08:50,240 --> 00:08:51,839
it is non-trivial when the addition

256
00:08:51,839 --> 00:08:54,320
operation is actually compressing or

257
00:08:54,320 --> 00:08:55,839
there is a set of commitments to

258
00:08:55,839 --> 00:08:57,680
polynomials of bound to degree that is

259
00:08:57,680 --> 00:08:59,680
closed under addition that has

260
00:08:59,680 --> 00:09:02,080
polynomial bounded size it is in this

261
00:09:02,080 --> 00:09:04,160
case that we call the polynomial

262
00:09:04,160 --> 00:09:06,800
commitment scheme additive

263
00:09:06,800 --> 00:09:08,959
linear combination schemes

264
00:09:08,959 --> 00:09:10,880
for polynomial equipments generalize

265
00:09:10,880 --> 00:09:12,399
additivity

266
00:09:12,399 --> 00:09:14,480
perhaps there is no compressing addition

267
00:09:14,480 --> 00:09:17,440
operation as previously defined but

268
00:09:17,440 --> 00:09:19,839
there is a protocol between approver and

269
00:09:19,839 --> 00:09:22,080
a verifier which outputs a succinct

270
00:09:22,080 --> 00:09:23,920
commitment to the linear combination

271
00:09:23,920 --> 00:09:26,080
with a proof of correctness the verifier

272
00:09:26,080 --> 00:09:27,360
checks

273
00:09:27,360 --> 00:09:28,640
the security

274
00:09:28,640 --> 00:09:30,959
property of this linear combination

275
00:09:30,959 --> 00:09:32,560
protocol

276
00:09:32,560 --> 00:09:35,760
is that running an evaluation proof on

277
00:09:35,760 --> 00:09:38,320
the output c star is an argument of

278
00:09:38,320 --> 00:09:41,120
knowledge for openings of both c star

279
00:09:41,120 --> 00:09:43,040
and the formal linear combination of the

280
00:09:43,040 --> 00:09:45,200
input commitments to the same polynomial

281
00:09:45,200 --> 00:09:47,040
f

282
00:09:47,040 --> 00:09:48,959
we call a linear combination scheme

283
00:09:48,959 --> 00:09:51,519
efficient if the lin combined protocol

284
00:09:51,519 --> 00:09:54,240
has a verifier that is sublinear in the

285
00:09:54,240 --> 00:09:56,720
maximum degree of the

286
00:09:56,720 --> 00:09:59,440
input polynomials note also that in our

287
00:09:59,440 --> 00:10:01,200
example the lin combined protocol takes

288
00:10:01,200 --> 00:10:03,040
just two commitments but it could also

289
00:10:03,040 --> 00:10:04,800
take a linear combination of multiple

290
00:10:04,800 --> 00:10:07,120
commitments at once

291
00:10:07,120 --> 00:10:09,680
so to summarize a non-additive

292
00:10:09,680 --> 00:10:11,920
polynomial equipment scheme construction

293
00:10:11,920 --> 00:10:13,680
which may have no

294
00:10:13,680 --> 00:10:16,560
compressing ad operation

295
00:10:16,560 --> 00:10:18,560
could still have an efficient linear

296
00:10:18,560 --> 00:10:20,399
combination protocol with a succinct

297
00:10:20,399 --> 00:10:22,560
output

298
00:10:22,560 --> 00:10:25,920
the result of our work stated informally

299
00:10:25,920 --> 00:10:28,000
is that we can achieve proof carrying

300
00:10:28,000 --> 00:10:30,800
data from any polynomial movement scheme

301
00:10:30,800 --> 00:10:32,720
with an efficient linear combination

302
00:10:32,720 --> 00:10:34,000
scheme

303
00:10:34,000 --> 00:10:36,399
where the proving time

304
00:10:36,399 --> 00:10:38,079
inherits the same efficiency as the

305
00:10:38,079 --> 00:10:39,839
polynomial scheme

306
00:10:39,839 --> 00:10:42,240
roughly on polynomials of degree

307
00:10:42,240 --> 00:10:44,640
the size of the local predicate

308
00:10:44,640 --> 00:10:47,200
plus the size of the linear combination

309
00:10:47,200 --> 00:10:49,120
scheme verifier

310
00:10:49,120 --> 00:10:50,880
if additionally the polynomial

311
00:10:50,880 --> 00:10:52,240
equivalent scheme is

312
00:10:52,240 --> 00:10:54,160
is additive doesn't just have an

313
00:10:54,160 --> 00:10:56,560
efficient linear combination scheme

314
00:10:56,560 --> 00:10:59,760
then the pcs proof size is also

315
00:10:59,760 --> 00:11:01,279
inherited

316
00:11:01,279 --> 00:11:04,320
and there is no need to transfer

317
00:11:04,320 --> 00:11:06,720
prover states in the

318
00:11:06,720 --> 00:11:09,680
proof carrying data

319
00:11:10,320 --> 00:11:12,079
towards showing this result we

320
00:11:12,079 --> 00:11:13,760
introduced two types of aggregation

321
00:11:13,760 --> 00:11:16,240
schemes for polynomial commitments one

322
00:11:16,240 --> 00:11:18,399
that we call public aggregation which is

323
00:11:18,399 --> 00:11:22,079
related to the bcms idea of accumulation

324
00:11:22,079 --> 00:11:23,760
and the other which we call private

325
00:11:23,760 --> 00:11:26,240
aggregation which is related to the bc

326
00:11:26,240 --> 00:11:27,360
lms

327
00:11:27,360 --> 00:11:30,720
notion of split accumulation

328
00:11:30,720 --> 00:11:32,880
private aggregation is a public coin

329
00:11:32,880 --> 00:11:34,720
interactive protocol between approver

330
00:11:34,720 --> 00:11:36,480
and a verifier which aggregates

331
00:11:36,480 --> 00:11:38,640
commitment evaluation tuples

332
00:11:38,640 --> 00:11:40,480
an evaluation tuple is a commitment and

333
00:11:40,480 --> 00:11:42,079
a claimed point on the committed

334
00:11:42,079 --> 00:11:43,440
polynomial

335
00:11:43,440 --> 00:11:45,360
for simplicity let's define the protocol

336
00:11:45,360 --> 00:11:47,040
for aggregating just two commitment

337
00:11:47,040 --> 00:11:49,040
tuples but this generalizes to

338
00:11:49,040 --> 00:11:50,880
aggregating more than two

339
00:11:50,880 --> 00:11:53,200
the verifiers inputs in this case are

340
00:11:53,200 --> 00:11:54,639
two commitments

341
00:11:54,639 --> 00:11:56,720
and two claimed

342
00:11:56,720 --> 00:11:59,279
points on the committed polynomials

343
00:11:59,279 --> 00:12:01,519
while the prover additionally has

344
00:12:01,519 --> 00:12:02,800
the opening hints of the input

345
00:12:02,800 --> 00:12:04,480
commitments as private inputs to the

346
00:12:04,480 --> 00:12:06,639
aggregation protocol

347
00:12:06,639 --> 00:12:08,320
the output of the aggregation protocol

348
00:12:08,320 --> 00:12:10,240
has a public component received by both

349
00:12:10,240 --> 00:12:11,200
parties

350
00:12:11,200 --> 00:12:12,800
which is a new

351
00:12:12,800 --> 00:12:14,720
evaluation tuple

352
00:12:14,720 --> 00:12:18,000
and a private output just to the prover

353
00:12:18,000 --> 00:12:21,279
which consists of an opening hint for

354
00:12:21,279 --> 00:12:24,880
the commitment to see star and the

355
00:12:24,880 --> 00:12:28,560
polynomial f star that c star commits to

356
00:12:28,560 --> 00:12:30,240
the security property of this

357
00:12:30,240 --> 00:12:31,920
aggregation protocol

358
00:12:31,920 --> 00:12:33,600
is that the composition of running the

359
00:12:33,600 --> 00:12:36,320
aggregation and subsequently running the

360
00:12:36,320 --> 00:12:40,480
eval protocol on the output tuple zstar

361
00:12:40,480 --> 00:12:42,399
xrystar

362
00:12:42,399 --> 00:12:44,720
is equivalent to running eval on both

363
00:12:44,720 --> 00:12:46,480
input tuples in other words it is a

364
00:12:46,480 --> 00:12:50,000
proof of knowledge for both input tuples

365
00:12:50,000 --> 00:12:53,040
public aggregation is very similar

366
00:12:53,040 --> 00:12:54,720
except the key difference is that the

367
00:12:54,720 --> 00:12:57,200
aggregation prover does not need to know

368
00:12:57,200 --> 00:12:58,639
the opening hints for the input

369
00:12:58,639 --> 00:13:01,200
commitments instead it has eval proofs

370
00:13:01,200 --> 00:13:03,600
for each input evaluation tuple here the

371
00:13:03,600 --> 00:13:05,839
proven verifier therefore have the same

372
00:13:05,839 --> 00:13:07,200
inputs

373
00:13:07,200 --> 00:13:09,040
only the verifier does less work than

374
00:13:09,040 --> 00:13:10,720
the prover

375
00:13:10,720 --> 00:13:12,639
the output of the aggregation protocol

376
00:13:12,639 --> 00:13:14,720
is a new evaluation tuple as before and

377
00:13:14,720 --> 00:13:16,880
an opening hint for this tuple for

378
00:13:16,880 --> 00:13:18,800
efficiency the verifier does not need to

379
00:13:18,800 --> 00:13:21,040
read the full output in particular

380
00:13:21,040 --> 00:13:22,720
it does not need to read the opening

381
00:13:22,720 --> 00:13:24,880
hint but it should be possible to derive

382
00:13:24,880 --> 00:13:27,279
this from the protocol transcript

383
00:13:27,279 --> 00:13:30,160
the security property is the same

384
00:13:30,160 --> 00:13:31,760
i will sketch how we can improve the

385
00:13:31,760 --> 00:13:33,839
efficiency of pcd with proof systems

386
00:13:33,839 --> 00:13:35,519
built from polynomial equipment schemes

387
00:13:35,519 --> 00:13:37,920
that admit aggregation so given a proof

388
00:13:37,920 --> 00:13:40,959
system for a program on xw with the

389
00:13:40,959 --> 00:13:43,279
structure that proofs

390
00:13:43,279 --> 00:13:46,320
are a tuple t row a where t is an

391
00:13:46,320 --> 00:13:48,800
evaluation tuple c alpha beta rho is a

392
00:13:48,800 --> 00:13:51,680
pcs evaluation proof for t and a is an

393
00:13:51,680 --> 00:13:53,920
additional component of the proof

394
00:13:53,920 --> 00:13:56,320
and the verifier is split into two parts

395
00:13:56,320 --> 00:13:58,560
one is a succinct part which is

396
00:13:58,560 --> 00:14:00,480
efficient or sublinear in the size of

397
00:14:00,480 --> 00:14:04,320
the program and the other is a the

398
00:14:04,320 --> 00:14:06,880
evaluation proof verifier which checks

399
00:14:06,880 --> 00:14:07,839
row

400
00:14:07,839 --> 00:14:10,000
for t

401
00:14:10,000 --> 00:14:11,839
now the first step is to show how we can

402
00:14:11,839 --> 00:14:13,440
build an aggregation scheme for these

403
00:14:13,440 --> 00:14:15,440
proofs using the aggregation scheme of

404
00:14:15,440 --> 00:14:17,839
the pcs the aggregation approver will

405
00:14:17,839 --> 00:14:20,959
aggregate proofs by aggregating the

406
00:14:20,959 --> 00:14:23,680
evaluation tuple components into t star

407
00:14:23,680 --> 00:14:26,560
with a proof pi aggregation

408
00:14:26,560 --> 00:14:28,399
and the verifier will

409
00:14:28,399 --> 00:14:30,800
check the snark verification component

410
00:14:30,800 --> 00:14:33,199
of each proof and then run the pcs

411
00:14:33,199 --> 00:14:34,959
aggregation scheme verifier to check

412
00:14:34,959 --> 00:14:37,760
tstar's correctness

413
00:14:37,760 --> 00:14:39,920
so the high level idea of how we'll

414
00:14:39,920 --> 00:14:41,920
improve pcd

415
00:14:41,920 --> 00:14:43,199
is that the prover will produce

416
00:14:43,199 --> 00:14:45,040
separately

417
00:14:45,040 --> 00:14:48,399
a proof pi f for the local predicate

418
00:14:48,399 --> 00:14:51,600
and aggregate this together with the

419
00:14:51,600 --> 00:14:53,839
previous proof

420
00:14:53,839 --> 00:14:55,600
into the new proof

421
00:14:55,600 --> 00:14:58,480
so this new proof pi2 is approved for a

422
00:14:58,480 --> 00:15:00,399
program that calls the aggregation

423
00:15:00,399 --> 00:15:02,720
verifier with the previous proof pi 1

424
00:15:02,720 --> 00:15:04,800
and the local proof pi f and an

425
00:15:04,800 --> 00:15:06,880
aggregation proof

426
00:15:06,880 --> 00:15:09,360
as a witness

427
00:15:09,360 --> 00:15:11,040
in more detail the proofs that are

428
00:15:11,040 --> 00:15:13,440
passed along edges of the pcd

429
00:15:13,440 --> 00:15:15,279
have two components one being a primary

430
00:15:15,279 --> 00:15:18,160
proof component the other an aggregation

431
00:15:18,160 --> 00:15:19,519
output

432
00:15:19,519 --> 00:15:22,399
we pre-process the local program f so

433
00:15:22,399 --> 00:15:23,600
that the prover can independently

434
00:15:23,600 --> 00:15:24,639
produce proofs of the local

435
00:15:24,639 --> 00:15:27,199
computation's correctness the primary

436
00:15:27,199 --> 00:15:29,279
proof passed along the edges is a proof

437
00:15:29,279 --> 00:15:31,440
for the program recursively defined as

438
00:15:31,440 --> 00:15:33,440
follows it parses its

439
00:15:33,440 --> 00:15:35,440
input x as a variable verification key

440
00:15:35,440 --> 00:15:37,839
an index a local output

441
00:15:37,839 --> 00:15:41,920
and an aggregation output

442
00:15:41,920 --> 00:15:43,920
it parses its witness as a previous

443
00:15:43,920 --> 00:15:45,279
output

444
00:15:45,279 --> 00:15:46,639
a proof of the local computation

445
00:15:46,639 --> 00:15:48,079
correctness

446
00:15:48,079 --> 00:15:50,000
the previous

447
00:15:50,000 --> 00:15:52,399
primary proof pi i and previous

448
00:15:52,399 --> 00:15:54,399
aggregation value t star i and then an

449
00:15:54,399 --> 00:15:56,720
aggregation proof and it runs the

450
00:15:56,720 --> 00:16:00,240
verifier of the aggregation protocol

451
00:16:00,240 --> 00:16:03,040
on the aggregation proof and of these

452
00:16:03,040 --> 00:16:05,680
proofs pi i pi f

453
00:16:05,680 --> 00:16:07,360
and the previous

454
00:16:07,360 --> 00:16:09,519
aggregation value t star i in order to

455
00:16:09,519 --> 00:16:11,199
check that the new aggregation value of

456
00:16:11,199 --> 00:16:14,000
t star i plus 1 is correct

457
00:16:14,000 --> 00:16:17,120
so we can think of each t star value as

458
00:16:17,120 --> 00:16:19,040
as a value that accumulates the

459
00:16:19,040 --> 00:16:20,720
unchecked polynomial convincing eval

460
00:16:20,720 --> 00:16:22,720
components of all prior proofs in the

461
00:16:22,720 --> 00:16:24,000
chain which is why this technique has

462
00:16:24,000 --> 00:16:26,240
also been called proof accumulation and

463
00:16:26,240 --> 00:16:27,519
the complexity of the incremental

464
00:16:27,519 --> 00:16:29,920
proofer's work is proportional to the

465
00:16:29,920 --> 00:16:31,759
size of the

466
00:16:31,759 --> 00:16:33,040
efficient part of the proof system

467
00:16:33,040 --> 00:16:34,720
verifier v snark

468
00:16:34,720 --> 00:16:37,680
and the size of the verifier for the

469
00:16:37,680 --> 00:16:40,320
polynomial scheme aggregation if we are

470
00:16:40,320 --> 00:16:42,079
going to use private aggregation instead

471
00:16:42,079 --> 00:16:44,079
of public then the next incremental

472
00:16:44,079 --> 00:16:46,160
prover needs to also receive the opening

473
00:16:46,160 --> 00:16:48,639
for the evaluation tuple t star i and

474
00:16:48,639 --> 00:16:51,279
the evaluation top component of pi i

475
00:16:51,279 --> 00:16:53,199
passed along as the provers private

476
00:16:53,199 --> 00:16:54,079
state

477
00:16:54,079 --> 00:16:56,240
importantly this additional witness does

478
00:16:56,240 --> 00:16:58,720
not grow in size it's the same at each

479
00:16:58,720 --> 00:17:00,959
depth of the pcd

480
00:17:00,959 --> 00:17:02,639
so the main theorems in this work

481
00:17:02,639 --> 00:17:04,400
concern the efficiency of aggregation

482
00:17:04,400 --> 00:17:07,280
schemes for pellenium equipments

483
00:17:07,280 --> 00:17:10,079
a public or private aggregation scheme

484
00:17:10,079 --> 00:17:12,799
is said to be efficient if the aggregate

485
00:17:12,799 --> 00:17:14,959
protocol verifier is sublinear in the

486
00:17:14,959 --> 00:17:16,240
maximum degree of the committed

487
00:17:16,240 --> 00:17:18,160
polynomials so our first theorem shows

488
00:17:18,160 --> 00:17:19,679
that every polynomial equivalent scheme

489
00:17:19,679 --> 00:17:21,280
that has an efficient linear combination

490
00:17:21,280 --> 00:17:23,679
scheme also has an efficient aggregation

491
00:17:23,679 --> 00:17:24,559
scheme

492
00:17:24,559 --> 00:17:26,160
and our second theorem is that every

493
00:17:26,160 --> 00:17:28,000
additive polynomial equivalent scheme

494
00:17:28,000 --> 00:17:29,760
has an efficient public aggregation

495
00:17:29,760 --> 00:17:32,480
scheme both theorems are constructive we

496
00:17:32,480 --> 00:17:34,640
show how to build an aggregation scheme

497
00:17:34,640 --> 00:17:36,559
from a linear combination scheme which

498
00:17:36,559 --> 00:17:38,720
inherits the efficiency of the linear

499
00:17:38,720 --> 00:17:40,960
combination scheme and we also show how

500
00:17:40,960 --> 00:17:42,880
to construct public aggregation for any

501
00:17:42,880 --> 00:17:46,240
additive pcs

502
00:17:46,240 --> 00:17:47,840
i'll first show how to get private

503
00:17:47,840 --> 00:17:50,160
aggregation from a linear combination

504
00:17:50,160 --> 00:17:51,039
scheme

505
00:17:51,039 --> 00:17:52,799
to simplify the presentation let's

506
00:17:52,799 --> 00:17:54,640
assume the input evaluation tuples for

507
00:17:54,640 --> 00:17:56,880
claims about roots it's easy to reduce

508
00:17:56,880 --> 00:17:58,960
the general case to proven claims about

509
00:17:58,960 --> 00:18:01,280
roots and it's also easy to generalize

510
00:18:01,280 --> 00:18:03,120
the protocol that i'll give to

511
00:18:03,120 --> 00:18:05,919
aggregation of more than two commitment

512
00:18:05,919 --> 00:18:08,160
eval tuples

513
00:18:08,160 --> 00:18:10,000
so the prover begins by defining the

514
00:18:10,000 --> 00:18:12,480
zero polynomials z i of x is equal to x

515
00:18:12,480 --> 00:18:14,400
minus x i and z of x to be the product

516
00:18:14,400 --> 00:18:17,120
of z1 of x and z2 of x the verifier can

517
00:18:17,120 --> 00:18:18,480
do the same

518
00:18:18,480 --> 00:18:20,160
the verifier sends a random challenge

519
00:18:20,160 --> 00:18:21,120
rho

520
00:18:21,120 --> 00:18:22,880
the prover constructs this quotient

521
00:18:22,880 --> 00:18:26,000
polynomial z2 f1 plus rho z1 f2 divided

522
00:18:26,000 --> 00:18:29,679
by z of x note that both z2 f1 and z1 f2

523
00:18:29,679 --> 00:18:32,960
have roots at at both x1 and x2

524
00:18:32,960 --> 00:18:34,559
it commits to this and sends it to the

525
00:18:34,559 --> 00:18:36,400
verifier the verifier responds with

526
00:18:36,400 --> 00:18:38,160
another random challenge

527
00:18:38,160 --> 00:18:39,520
and the prover constructs this

528
00:18:39,520 --> 00:18:42,160
polynomial g of x is equal to z2 of r

529
00:18:42,160 --> 00:18:44,960
times f1 plus rho z1 of r times f2 minus

530
00:18:44,960 --> 00:18:47,520
z of r times q this is defined such that

531
00:18:47,520 --> 00:18:50,720
if done correctly g will have a root at

532
00:18:50,720 --> 00:18:52,720
r if the claim is true

533
00:18:52,720 --> 00:18:54,400
if the scheme is added the verifier can

534
00:18:54,400 --> 00:18:56,160
homomorphically derive a succinct

535
00:18:56,160 --> 00:18:58,960
commitment cg to this polynomial g but

536
00:18:58,960 --> 00:19:00,640
more generally we can use the linear

537
00:19:00,640 --> 00:19:02,960
combination scheme in order to produce

538
00:19:02,960 --> 00:19:05,919
succinct commitments to g

539
00:19:05,919 --> 00:19:08,480
the output of the prover is the

540
00:19:08,480 --> 00:19:11,200
commitment c star g r n zero and the

541
00:19:11,200 --> 00:19:13,120
opening of g

542
00:19:13,120 --> 00:19:14,960
and the verifiers output is just the

543
00:19:14,960 --> 00:19:17,520
commitment

544
00:19:17,679 --> 00:19:18,880
if

545
00:19:18,880 --> 00:19:20,720
the approver and verifier subsequently

546
00:19:20,720 --> 00:19:23,280
run the evaluation protocol

547
00:19:23,280 --> 00:19:25,760
on the output tuple c star

548
00:19:25,760 --> 00:19:26,880
zero

549
00:19:26,880 --> 00:19:28,720
then this turns into a batch evaluation

550
00:19:28,720 --> 00:19:30,320
protocol for

551
00:19:30,320 --> 00:19:33,678
the original claim

552
00:19:34,000 --> 00:19:36,000
so this protocol builds on the classical

553
00:19:36,000 --> 00:19:37,919
one round protocol to batch proving that

554
00:19:37,919 --> 00:19:39,919
multiple committed polynomials have a

555
00:19:39,919 --> 00:19:41,200
common root

556
00:19:41,200 --> 00:19:42,880
by opening a random linear combination

557
00:19:42,880 --> 00:19:44,880
of the commitments at this root

558
00:19:44,880 --> 00:19:46,720
and the knowledge extractor in that case

559
00:19:46,720 --> 00:19:48,320
is based on the invertibility of a

560
00:19:48,320 --> 00:19:50,400
vandermonde matrix

561
00:19:50,400 --> 00:19:52,480
but to batch proof multiple committed

562
00:19:52,480 --> 00:19:54,000
polynomials at different points the

563
00:19:54,000 --> 00:19:55,919
protocol here involves

564
00:19:55,919 --> 00:19:58,480
one more round as shown

565
00:19:58,480 --> 00:20:00,320
and the knowledge extractor ends up

566
00:20:00,320 --> 00:20:02,159
being based on the invertibility of the

567
00:20:02,159 --> 00:20:04,080
hadamard product of a random van dermont

568
00:20:04,080 --> 00:20:06,880
matrix with a square matrix of nonzero

569
00:20:06,880 --> 00:20:09,600
field elements

570
00:20:09,919 --> 00:20:12,080
next we'll show how to build public

571
00:20:12,080 --> 00:20:14,159
aggregation for additive polynomial

572
00:20:14,159 --> 00:20:16,080
commitment schemes

573
00:20:16,080 --> 00:20:18,000
an important building block for this is

574
00:20:18,000 --> 00:20:19,520
a succinct proof proof-of-knowledge

575
00:20:19,520 --> 00:20:21,039
protocol for pre-images of a

576
00:20:21,039 --> 00:20:23,600
homomorphism from integer vectors to an

577
00:20:23,600 --> 00:20:26,640
arbitrary a billion group

578
00:20:26,640 --> 00:20:28,960
the protocol we described for this is a

579
00:20:28,960 --> 00:20:30,559
generalization of the bulletproofs

580
00:20:30,559 --> 00:20:31,679
protocol

581
00:20:31,679 --> 00:20:32,840
depicted

582
00:20:32,840 --> 00:20:34,480
here

583
00:20:34,480 --> 00:20:36,320
now i won't walk through

584
00:20:36,320 --> 00:20:38,559
the details of the protocol but the

585
00:20:38,559 --> 00:20:40,720
verifier's final check

586
00:20:40,720 --> 00:20:43,120
is checking that the integer x prime

587
00:20:43,120 --> 00:20:45,039
times the homomorphism applied to an

588
00:20:45,039 --> 00:20:47,440
integer vector u is equal to the group

589
00:20:47,440 --> 00:20:49,520
element y prime

590
00:20:49,520 --> 00:20:51,039
where the

591
00:20:51,039 --> 00:20:52,960
integer vector u is the coefficient

592
00:20:52,960 --> 00:20:54,320
vector

593
00:20:54,320 --> 00:20:56,880
of this polynomial which is defined from

594
00:20:56,880 --> 00:20:59,200
the transcript challenges in the

595
00:20:59,200 --> 00:21:00,559
protocol

596
00:21:00,559 --> 00:21:02,159
so it's something the verifier can check

597
00:21:02,159 --> 00:21:04,640
on its own because u is publicly

598
00:21:04,640 --> 00:21:07,760
derivable from the protocol transcript

599
00:21:07,760 --> 00:21:09,679
a critical observation that comes out of

600
00:21:09,679 --> 00:21:11,280
our analysis of the security of this

601
00:21:11,280 --> 00:21:14,000
protocol is that the verifier doesn't

602
00:21:14,000 --> 00:21:16,640
need to explicitly derive the vector u

603
00:21:16,640 --> 00:21:17,360
and

604
00:21:17,360 --> 00:21:19,200
check the evaluation of the homomorphism

605
00:21:19,200 --> 00:21:20,559
on u

606
00:21:20,559 --> 00:21:22,000
which is the linear time part of the

607
00:21:22,000 --> 00:21:23,360
verification

608
00:21:23,360 --> 00:21:26,159
if instead the prover provides any proof

609
00:21:26,159 --> 00:21:28,559
of knowledge of some pre-image of y

610
00:21:28,559 --> 00:21:30,720
prime

611
00:21:30,720 --> 00:21:32,320
now you might wonder why this is helpful

612
00:21:32,320 --> 00:21:34,159
because the goal is to construct a proof

613
00:21:34,159 --> 00:21:36,000
of knowledge of homomorphism preimage in

614
00:21:36,000 --> 00:21:37,760
the first place

615
00:21:37,760 --> 00:21:39,840
repeating the protocol on you instead of

616
00:21:39,840 --> 00:21:41,679
having the verifier check you directly

617
00:21:41,679 --> 00:21:43,520
obviously wouldn't reduce the verifier

618
00:21:43,520 --> 00:21:45,600
complexity of the protocol

619
00:21:45,600 --> 00:21:48,559
here but this gives us a tool for public

620
00:21:48,559 --> 00:21:50,080
aggregation

621
00:21:50,080 --> 00:21:52,000
the key idea being that we can think of

622
00:21:52,000 --> 00:21:54,320
this protocol as reduction from proving

623
00:21:54,320 --> 00:21:55,760
a claim about

624
00:21:55,760 --> 00:21:59,200
a hidden pre-image x into a claim about

625
00:21:59,200 --> 00:22:02,159
a publicly known or derivable pre-image

626
00:22:02,159 --> 00:22:03,280
u

627
00:22:03,280 --> 00:22:05,919
which can be extracted later by another

628
00:22:05,919 --> 00:22:08,080
prover just from reading the proof

629
00:22:08,080 --> 00:22:09,280
transcript

630
00:22:09,280 --> 00:22:11,440
so we'll apply this sub protocol as

631
00:22:11,440 --> 00:22:12,480
follows

632
00:22:12,480 --> 00:22:13,760
first we'll need to do a slight

633
00:22:13,760 --> 00:22:16,480
compilation of an additive polynomial

634
00:22:16,480 --> 00:22:17,919
scheme into one that can be publicly

635
00:22:17,919 --> 00:22:19,200
aggregated

636
00:22:19,200 --> 00:22:21,520
the new commit star must implement a

637
00:22:21,520 --> 00:22:25,039
homomorphism from integer vectors to g

638
00:22:25,039 --> 00:22:26,880
this is often already the case but if

639
00:22:26,880 --> 00:22:27,840
not

640
00:22:27,840 --> 00:22:30,400
we can define a new commitment algorithm

641
00:22:30,400 --> 00:22:32,320
that takes linear combinations of

642
00:22:32,320 --> 00:22:35,200
commitments to the monomials

643
00:22:35,200 --> 00:22:37,120
and the new

644
00:22:37,120 --> 00:22:39,200
eval

645
00:22:39,200 --> 00:22:42,000
protocol on an evaluation tuple c x y

646
00:22:42,000 --> 00:22:43,760
will work as follows so first we define

647
00:22:43,760 --> 00:22:45,360
a new homomorphism

648
00:22:45,360 --> 00:22:47,840
h x of f bold f here denotes the

649
00:22:47,840 --> 00:22:50,640
coefficient vector of the polynomial

650
00:22:50,640 --> 00:22:52,400
which outputs two components first the

651
00:22:52,400 --> 00:22:53,600
commitment

652
00:22:53,600 --> 00:22:56,159
and then the evaluation of f x

653
00:22:56,159 --> 00:22:58,320
y

654
00:22:59,120 --> 00:23:01,600
it then runs the homomorphism pre-image

655
00:23:01,600 --> 00:23:03,760
proof for the statement that hx of bold

656
00:23:03,760 --> 00:23:05,679
f is equal to cy

657
00:23:05,679 --> 00:23:09,039
to get this integer vector u defined by

658
00:23:09,039 --> 00:23:11,840
on the previous slide

659
00:23:11,840 --> 00:23:13,600
and

660
00:23:13,600 --> 00:23:15,679
two values c prime and y prime such that

661
00:23:15,679 --> 00:23:19,120
h x of u is equal to c prime y prime

662
00:23:19,120 --> 00:23:20,559
and then it runs

663
00:23:20,559 --> 00:23:24,320
eval on the evaluation tuple c prime x y

664
00:23:24,320 --> 00:23:26,320
prime

665
00:23:26,320 --> 00:23:28,799
so notice u is public it can be derived

666
00:23:28,799 --> 00:23:30,159
from the hpi

667
00:23:30,159 --> 00:23:32,080
proof transcript

668
00:23:32,080 --> 00:23:34,159
and so this reduces

669
00:23:34,159 --> 00:23:35,679
an eval instance with a private witness

670
00:23:35,679 --> 00:23:39,200
to an instance with a public witness

671
00:23:40,000 --> 00:23:41,840
so finally

672
00:23:41,840 --> 00:23:44,159
if we're given evil star proofs for

673
00:23:44,159 --> 00:23:47,760
input tuples c-i-x-i-y-i

674
00:23:47,760 --> 00:23:50,080
each of these contains an eval proof for

675
00:23:50,080 --> 00:23:52,720
a new tuple ci prime xiy prime with a

676
00:23:52,720 --> 00:23:54,559
public witness ui

677
00:23:54,559 --> 00:23:57,200
derived from the proof transcript

678
00:23:57,200 --> 00:23:59,279
which enables the aggregation prover to

679
00:23:59,279 --> 00:24:01,760
run private aggregation

680
00:24:01,760 --> 00:24:03,200
deriving these witnesses from the proof

681
00:24:03,200 --> 00:24:04,480
transcripts

682
00:24:04,480 --> 00:24:06,720
to reduce to a double c star x star y

683
00:24:06,720 --> 00:24:08,960
star with a public witness u-star

684
00:24:08,960 --> 00:24:10,720
and opening in open source derivable

685
00:24:10,720 --> 00:24:13,200
from the transcript

686
00:24:13,200 --> 00:24:14,640
so a major difference from the original

687
00:24:14,640 --> 00:24:16,320
halo is of course that the original halo

688
00:24:16,320 --> 00:24:18,880
was for a specific polynomial equipment

689
00:24:18,880 --> 00:24:20,320
bulletproofs and this is much more

690
00:24:20,320 --> 00:24:21,760
general however there are also

691
00:24:21,760 --> 00:24:23,840
mechanical differences beyond direct

692
00:24:23,840 --> 00:24:25,919
generalization

693
00:24:25,919 --> 00:24:27,600
a minor technical difference is that it

694
00:24:27,600 --> 00:24:29,760
does not involve the verifier testing u

695
00:24:29,760 --> 00:24:32,480
of x at a random point but a more

696
00:24:32,480 --> 00:24:34,480
important difference is that

697
00:24:34,480 --> 00:24:37,600
the commitment function h does not need

698
00:24:37,600 --> 00:24:40,159
to be a collision resistant homomorphism

699
00:24:40,159 --> 00:24:42,320
whereas the original halo relied on the

700
00:24:42,320 --> 00:24:43,760
collision resistance of the patterson

701
00:24:43,760 --> 00:24:45,039
hash

702
00:24:45,039 --> 00:24:46,640
so in general the commitment function of

703
00:24:46,640 --> 00:24:48,159
course needs to be a binding commitment

704
00:24:48,159 --> 00:24:49,840
to polynomials but that is a weaker

705
00:24:49,840 --> 00:24:51,520
requirement than being a collision

706
00:24:51,520 --> 00:24:53,679
resistant homomorphism

707
00:24:53,679 --> 00:24:57,080
over the integers

708
00:25:01,919 --> 00:25:04,000
you

