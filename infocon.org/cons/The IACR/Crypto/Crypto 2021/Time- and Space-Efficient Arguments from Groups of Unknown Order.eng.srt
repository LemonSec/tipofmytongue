1
00:00:05,279 --> 00:00:06,080
hey

2
00:00:06,080 --> 00:00:08,080
i am pratik sumi and i will be

3
00:00:08,080 --> 00:00:10,639
presenting our paper which builds time

4
00:00:10,639 --> 00:00:12,480
and space efficient zero knowledge

5
00:00:12,480 --> 00:00:15,440
arguments from groups of unknown order

6
00:00:15,440 --> 00:00:17,600
this is joint work with justin holgrim

7
00:00:17,600 --> 00:00:20,960
ron rothbloom alan rosen and alex block

8
00:00:20,960 --> 00:00:22,720
who will take over for the second part

9
00:00:22,720 --> 00:00:24,160
of the talk

10
00:00:24,160 --> 00:00:26,720
let's begin

11
00:00:27,439 --> 00:00:28,960
zero knowledge protocols are a

12
00:00:28,960 --> 00:00:31,199
cornerstone of modern cryptography

13
00:00:31,199 --> 00:00:34,000
and they enable a verifier to check the

14
00:00:34,000 --> 00:00:35,920
truth of an arbitrary mathematical

15
00:00:35,920 --> 00:00:38,000
statement without revealing any

16
00:00:38,000 --> 00:00:39,840
information

17
00:00:39,840 --> 00:00:41,600
zero knowledge enables a number of

18
00:00:41,600 --> 00:00:44,399
exciting applications including

19
00:00:44,399 --> 00:00:46,840
delegating computations to the cloud and

20
00:00:46,840 --> 00:00:48,640
cryptocurrencies with interesting

21
00:00:48,640 --> 00:00:52,960
properties like succinctness and privacy

22
00:00:52,960 --> 00:00:55,280
a bit more formally zero knowledge

23
00:00:55,280 --> 00:00:57,680
argument for a language l is an

24
00:00:57,680 --> 00:01:00,160
interactive protocol between approver

25
00:01:00,160 --> 00:01:01,680
and a verifier

26
00:01:01,680 --> 00:01:04,479
where the prover is given an input as

27
00:01:04,479 --> 00:01:06,560
input and instance from the language

28
00:01:06,560 --> 00:01:08,240
along with some witness

29
00:01:08,240 --> 00:01:10,240
and wants to convince the verifier that

30
00:01:10,240 --> 00:01:12,960
the instance is in the language

31
00:01:12,960 --> 00:01:15,119
our focus going forward will be on

32
00:01:15,119 --> 00:01:17,600
languages accepted by random access

33
00:01:17,600 --> 00:01:21,439
machines or ram for short

34
00:01:21,439 --> 00:01:23,680
such arguments are required to satisfy

35
00:01:23,680 --> 00:01:25,759
standard properties like completeness

36
00:01:25,759 --> 00:01:27,360
and soundness

37
00:01:27,360 --> 00:01:30,000
additionally we need zero knowledge

38
00:01:30,000 --> 00:01:32,960
which informally captures that for true

39
00:01:32,960 --> 00:01:35,840
statements curious verifiers learn

40
00:01:35,840 --> 00:01:37,439
nothing more than the fact that the

41
00:01:37,439 --> 00:01:40,240
statement is true

42
00:01:40,240 --> 00:01:41,680
another important property is

43
00:01:41,680 --> 00:01:44,399
succinctness which requires the proof

44
00:01:44,399 --> 00:01:46,479
size which is the transcript of this

45
00:01:46,479 --> 00:01:49,600
interaction to be significantly smaller

46
00:01:49,600 --> 00:01:51,200
than the running time of the underlying

47
00:01:51,200 --> 00:01:54,240
ram program

48
00:01:54,240 --> 00:01:56,320
a key challenge in scaling general

49
00:01:56,320 --> 00:01:58,079
purpose zero knowledge is the high

50
00:01:58,079 --> 00:02:00,399
computational complexity of constructing

51
00:02:00,399 --> 00:02:01,759
such proofs

52
00:02:01,759 --> 00:02:03,920
or generating such proofs

53
00:02:03,920 --> 00:02:05,759
and this has been the focus of recent

54
00:02:05,759 --> 00:02:07,759
line of research

55
00:02:07,759 --> 00:02:09,758
and in terms of time complexity of the

56
00:02:09,758 --> 00:02:13,040
prover we are in great shape

57
00:02:13,040 --> 00:02:15,599
in theory we now know of constructions

58
00:02:15,599 --> 00:02:17,440
where the prover is asymptotically

59
00:02:17,440 --> 00:02:19,120
almost optimal

60
00:02:19,120 --> 00:02:21,200
and in some settings one can even

61
00:02:21,200 --> 00:02:24,560
achieve linear time provers

62
00:02:24,560 --> 00:02:27,040
the situation is surprisingly quite

63
00:02:27,040 --> 00:02:28,879
similar in practice

64
00:02:28,879 --> 00:02:31,599
and a number of systems with concretely

65
00:02:31,599 --> 00:02:34,959
efficiency brewers are being deployed

66
00:02:34,959 --> 00:02:37,599
as evidenced by this graph where the

67
00:02:37,599 --> 00:02:39,840
y-axis is the running time of the prover

68
00:02:39,840 --> 00:02:42,560
in deployed systems and x-axis is the

69
00:02:42,560 --> 00:02:44,319
logarithm of the size of statements

70
00:02:44,319 --> 00:02:46,319
being proved

71
00:02:46,319 --> 00:02:48,160
the light blue line here

72
00:02:48,160 --> 00:02:50,400
is the native execution which is the

73
00:02:50,400 --> 00:02:51,519
baseline

74
00:02:51,519 --> 00:02:54,160
and quite clearly recent deployed

75
00:02:54,160 --> 00:02:57,360
systems are approaching this line

76
00:02:57,360 --> 00:02:59,599
so are we done

77
00:02:59,599 --> 00:03:01,840
actually no

78
00:03:01,840 --> 00:03:04,720
although time wise we are good

79
00:03:04,720 --> 00:03:07,200
memory overheads of the brewer remain a

80
00:03:07,200 --> 00:03:10,319
major bottleneck in current systems

81
00:03:10,319 --> 00:03:13,040
in fact seti in his recent paper

82
00:03:13,040 --> 00:03:15,599
observes that the prover of the fractal

83
00:03:15,599 --> 00:03:16,560
system

84
00:03:16,560 --> 00:03:19,920
the orange line runs out of memory at

85
00:03:19,920 --> 00:03:22,720
statements of size 2 to the 18

86
00:03:22,720 --> 00:03:24,080
explaining

87
00:03:24,080 --> 00:03:26,879
why the orange line abruptly stops

88
00:03:26,879 --> 00:03:29,280
midway in the graph

89
00:03:29,280 --> 00:03:31,360
in fact the state of affairs for rest of

90
00:03:31,360 --> 00:03:34,159
the system is not significantly better

91
00:03:34,159 --> 00:03:36,239
as the prover is already at the limits

92
00:03:36,239 --> 00:03:38,640
of memory usage for statements of size 2

93
00:03:38,640 --> 00:03:40,480
to the 20

94
00:03:40,480 --> 00:03:43,120
and unlikely to scale to moderate sizes

95
00:03:43,120 --> 00:03:46,560
of 2 to the 30 necessary to handle any

96
00:03:46,560 --> 00:03:50,400
interesting real world application

97
00:03:50,799 --> 00:03:52,560
said another way

98
00:03:52,560 --> 00:03:54,959
in currently implemented solutions the

99
00:03:54,959 --> 00:03:57,920
prover ends up requiring space

100
00:03:57,920 --> 00:04:00,080
proportional to the running time of the

101
00:04:00,080 --> 00:04:02,640
underlying ram program rather than its

102
00:04:02,640 --> 00:04:04,560
space

103
00:04:04,560 --> 00:04:07,040
as a step towards addressing this key

104
00:04:07,040 --> 00:04:08,400
challenge

105
00:04:08,400 --> 00:04:10,640
in this work we focus on constructing

106
00:04:10,640 --> 00:04:13,360
zero knowledge arguments where we want

107
00:04:13,360 --> 00:04:15,760
the plural running time and space

108
00:04:15,760 --> 00:04:18,079
to be as close to the running time and

109
00:04:18,079 --> 00:04:21,358
space of the underlying ram program

110
00:04:21,358 --> 00:04:23,759
where we allow poly logarithmic in t

111
00:04:23,759 --> 00:04:26,320
overheads

112
00:04:27,120 --> 00:04:28,960
i want to emphasize that time and space

113
00:04:28,960 --> 00:04:31,280
of the brewer are both very important

114
00:04:31,280 --> 00:04:33,440
and would be unfair to trade one or the

115
00:04:33,440 --> 00:04:34,639
other

116
00:04:34,639 --> 00:04:36,800
but time overheads are easier to manage

117
00:04:36,800 --> 00:04:38,560
you can just let the prover run for as

118
00:04:38,560 --> 00:04:40,479
much time as possible

119
00:04:40,479 --> 00:04:42,800
but comparatively memory overheads are

120
00:04:42,800 --> 00:04:44,000
challenging

121
00:04:44,000 --> 00:04:46,160
expanding memory is non-trivial due to

122
00:04:46,160 --> 00:04:47,919
the hierarchical nature of modern

123
00:04:47,919 --> 00:04:50,720
computer systems

124
00:04:50,720 --> 00:04:52,720
and often the overall running time

125
00:04:52,720 --> 00:04:54,160
depends on parameters like cache

126
00:04:54,160 --> 00:04:58,000
efficiency which are very hard to tame

127
00:04:58,000 --> 00:04:59,759
hopefully by this point you're convinced

128
00:04:59,759 --> 00:05:02,080
that proof the space of the brewer is an

129
00:05:02,080 --> 00:05:04,160
important resource to consider

130
00:05:04,160 --> 00:05:06,000
and with that let's talk about prior

131
00:05:06,000 --> 00:05:09,759
work on getting time and space efficient

132
00:05:09,759 --> 00:05:12,240
brewers

133
00:05:13,120 --> 00:05:15,280
so there are some constructions known

134
00:05:15,280 --> 00:05:19,199
but all of them have undesirable caveats

135
00:05:19,199 --> 00:05:21,840
for example valiant and batansky atar

136
00:05:21,840 --> 00:05:24,400
give constructions from recursive

137
00:05:24,400 --> 00:05:25,759
composition

138
00:05:25,759 --> 00:05:27,919
which requires knowledge assumptions

139
00:05:27,919 --> 00:05:30,639
that are poorly understood

140
00:05:30,639 --> 00:05:33,280
betansky kiesa and holgrim and rothlum

141
00:05:33,280 --> 00:05:35,360
give constructions with a designated

142
00:05:35,360 --> 00:05:37,520
verifier which means that the verifier

143
00:05:37,520 --> 00:05:40,320
needs to keep some secret state

144
00:05:40,320 --> 00:05:44,000
this is undesirable for applications

145
00:05:44,000 --> 00:05:45,919
in a prior work with the same set of

146
00:05:45,919 --> 00:05:48,000
co-authors we overcome these two

147
00:05:48,000 --> 00:05:50,400
limitations but the verifier

148
00:05:50,400 --> 00:05:51,600
is linear

149
00:05:51,600 --> 00:05:55,600
again undesirable for applications

150
00:05:55,600 --> 00:05:58,639
in this work we remove all these caveats

151
00:05:58,639 --> 00:06:00,080
at once

152
00:06:00,080 --> 00:06:02,560
we need the hidden order assumption

153
00:06:02,560 --> 00:06:05,039
which is comparatively much simpler and

154
00:06:05,039 --> 00:06:06,800
better studied

155
00:06:06,800 --> 00:06:09,280
our verifier is public coin

156
00:06:09,280 --> 00:06:12,479
and runs in sublinear time

157
00:06:12,479 --> 00:06:15,600
in fact such a result was not known even

158
00:06:15,600 --> 00:06:19,520
without the zero knowledge requirement

159
00:06:19,680 --> 00:06:21,360
before i can state our main result more

160
00:06:21,360 --> 00:06:23,759
formally let me describe the hidden

161
00:06:23,759 --> 00:06:26,479
order assumption

162
00:06:26,479 --> 00:06:28,800
the hidden order assumption holds in a

163
00:06:28,800 --> 00:06:31,600
group if it's hard to find

164
00:06:31,600 --> 00:06:34,240
any multiple of the order of a random

165
00:06:34,240 --> 00:06:35,919
group element

166
00:06:35,919 --> 00:06:38,000
and classical candidate for such groups

167
00:06:38,000 --> 00:06:40,639
are rsa groups

168
00:06:40,639 --> 00:06:43,280
class groups of imaginary quadratic

169
00:06:43,280 --> 00:06:46,479
order are another candidate and in fact

170
00:06:46,479 --> 00:06:48,319
have received a lot of interest lately

171
00:06:48,319 --> 00:06:50,960
from the blockchain space

172
00:06:50,960 --> 00:06:53,520
the key feature of class groups is that

173
00:06:53,520 --> 00:06:55,440
the description of the group which is

174
00:06:55,440 --> 00:06:58,240
the discriminant delta can be generated

175
00:06:58,240 --> 00:07:00,319
using public randomness

176
00:07:00,319 --> 00:07:02,160
and hence it's plausible to assume that

177
00:07:02,160 --> 00:07:03,520
the hidden order assumption would

178
00:07:03,520 --> 00:07:05,440
continue to hold even when the

179
00:07:05,440 --> 00:07:07,759
randomness used to sample the group is

180
00:07:07,759 --> 00:07:09,840
made public

181
00:07:09,840 --> 00:07:11,919
in the context of applications this

182
00:07:11,919 --> 00:07:14,000
provides an alternative to removing

183
00:07:14,000 --> 00:07:15,759
trust from the parameter generation

184
00:07:15,759 --> 00:07:16,800
phase

185
00:07:16,800 --> 00:07:19,280
resulting in a transparent setup of

186
00:07:19,280 --> 00:07:21,840
parameters

187
00:07:21,840 --> 00:07:23,440
on the contrary we cannot expect

188
00:07:23,440 --> 00:07:25,520
something like this from rsa groups

189
00:07:25,520 --> 00:07:27,440
where the description of the group is a

190
00:07:27,440 --> 00:07:29,120
product of two primes

191
00:07:29,120 --> 00:07:31,919
and there is seemingly no obvious way to

192
00:07:31,919 --> 00:07:34,000
sample the product without knowing the

193
00:07:34,000 --> 00:07:36,319
factors

194
00:07:36,319 --> 00:07:38,720
so with rsa groups we would need trusted

195
00:07:38,720 --> 00:07:40,639
setup but here the hidden order

196
00:07:40,639 --> 00:07:44,720
assumptions can be based on factoring

197
00:07:44,720 --> 00:07:47,039
in summary the hidden order assumption

198
00:07:47,039 --> 00:07:50,000
is well studied simpler weaker in

199
00:07:50,000 --> 00:07:52,240
comparison with the assumptions used in

200
00:07:52,240 --> 00:07:56,000
prior work that we built on

201
00:07:57,759 --> 00:07:59,840
now to state our main result

202
00:07:59,840 --> 00:08:01,680
given such hidden order groups we

203
00:08:01,680 --> 00:08:04,400
construct public coin zero knowledge

204
00:08:04,400 --> 00:08:07,360
arguments for language l accepted by

205
00:08:07,360 --> 00:08:11,599
time t and space s rammus program

206
00:08:11,599 --> 00:08:12,479
where

207
00:08:12,479 --> 00:08:14,479
the prover time and space and the

208
00:08:14,479 --> 00:08:17,280
verified time are optimal up to polylock

209
00:08:17,280 --> 00:08:19,120
t factors

210
00:08:19,120 --> 00:08:21,599
our protocol is interactive and has log

211
00:08:21,599 --> 00:08:25,520
t runs and polylock t communication

212
00:08:25,520 --> 00:08:26,960
instantiating the hidden order group

213
00:08:26,960 --> 00:08:29,199
with rsa group will result in an

214
00:08:29,199 --> 00:08:31,120
argument from factoring but this would

215
00:08:31,120 --> 00:08:33,039
require trusted setup

216
00:08:33,039 --> 00:08:35,039
instantiating with hidden order class

217
00:08:35,039 --> 00:08:37,279
groups results in an argument with

218
00:08:37,279 --> 00:08:38,958
transparent setup

219
00:08:38,958 --> 00:08:41,120
and finally we can make our public con

220
00:08:41,120 --> 00:08:43,519
protocol non-interactive by applying the

221
00:08:43,519 --> 00:08:46,000
featurement heuristic which results in

222
00:08:46,000 --> 00:08:48,480
time and space efficient zero knowledge

223
00:08:48,480 --> 00:08:51,120
snarks

224
00:08:52,720 --> 00:08:54,640
at a very high level our approach is to

225
00:08:54,640 --> 00:08:56,720
combine polynomial iops along with

226
00:08:56,720 --> 00:08:58,560
polynomial commitments

227
00:08:58,560 --> 00:09:00,640
polynomial iops are information

228
00:09:00,640 --> 00:09:03,040
theoretic proof systems where the prover

229
00:09:03,040 --> 00:09:06,000
sends an oracle in the first round which

230
00:09:06,000 --> 00:09:08,560
embeds a polynomial

231
00:09:08,560 --> 00:09:11,120
and then interaction and interacts with

232
00:09:11,120 --> 00:09:12,800
the verifier at the end of which the

233
00:09:12,800 --> 00:09:14,800
verifier asks for evaluations of this

234
00:09:14,800 --> 00:09:17,440
polynomial and accordingly accepts or

235
00:09:17,440 --> 00:09:20,880
reject this reject this proof

236
00:09:20,880 --> 00:09:22,720
polynomial commitments on the other hand

237
00:09:22,720 --> 00:09:24,880
are cryptographic rules that allow a

238
00:09:24,880 --> 00:09:27,760
committer to commit to a polynomial and

239
00:09:27,760 --> 00:09:29,600
later reveal evaluations of this

240
00:09:29,600 --> 00:09:32,399
polynomial on verifier chosen points

241
00:09:32,399 --> 00:09:34,560
along with a proof that it has correctly

242
00:09:34,560 --> 00:09:37,839
evaluated the polynomial

243
00:09:38,000 --> 00:09:39,519
and we combine these two tools in the

244
00:09:39,519 --> 00:09:42,560
most natural way we ask the iop prover

245
00:09:42,560 --> 00:09:44,800
to send a commitment rather than the

246
00:09:44,800 --> 00:09:47,680
oracle highlighted in orange

247
00:09:47,680 --> 00:09:50,800
and we replace the iop verifier queries

248
00:09:50,800 --> 00:09:53,200
to the oracle with the evaluation

249
00:09:53,200 --> 00:09:54,720
protocol of the polynomial commitment

250
00:09:54,720 --> 00:09:58,480
scheme highlighted by blue

251
00:09:58,480 --> 00:10:00,240
in fact this approach is not new to us

252
00:10:00,240 --> 00:10:02,160
and is a common denominator of a number

253
00:10:02,160 --> 00:10:05,760
of prior schemes in fact a time optimal

254
00:10:05,760 --> 00:10:07,440
prover combined with tom optimal

255
00:10:07,440 --> 00:10:08,560
committer

256
00:10:08,560 --> 00:10:10,640
indeed gives a time optimal argument

257
00:10:10,640 --> 00:10:12,800
prover

258
00:10:12,800 --> 00:10:14,880
since we are also interested in space

259
00:10:14,880 --> 00:10:16,800
efficiency it is natural to ask whether

260
00:10:16,800 --> 00:10:20,720
the same transformation preserves space

261
00:10:20,720 --> 00:10:22,240
in fact turns out that this question is

262
00:10:22,240 --> 00:10:24,399
a bit more nuanced

263
00:10:24,399 --> 00:10:26,480
to get a space optimal prover for the

264
00:10:26,480 --> 00:10:27,600
argument

265
00:10:27,600 --> 00:10:30,399
we would need a committer to run in

266
00:10:30,399 --> 00:10:32,320
space which is sublinear in the size of

267
00:10:32,320 --> 00:10:36,880
the polynomial which is its input

268
00:10:37,040 --> 00:10:38,880
this is clearly impossible for arbitrary

269
00:10:38,880 --> 00:10:40,800
polynomials

270
00:10:40,800 --> 00:10:42,880
but in a prior work along with the same

271
00:10:42,880 --> 00:10:45,200
set of co-authors we observe that the

272
00:10:45,200 --> 00:10:47,920
polynomial in context has a rather space

273
00:10:47,920 --> 00:10:49,760
friendly structure

274
00:10:49,760 --> 00:10:52,160
specifically this polynomial encodes the

275
00:10:52,160 --> 00:10:54,880
transcript of the underlying ram program

276
00:10:54,880 --> 00:10:57,120
and hence that its description can be

277
00:10:57,120 --> 00:11:01,839
generated as a stream in small space

278
00:11:02,160 --> 00:11:04,160
we refer to polynomial commitments where

279
00:11:04,160 --> 00:11:06,880
the committee requires small space when

280
00:11:06,880 --> 00:11:08,560
given streaming access to this

281
00:11:08,560 --> 00:11:11,360
polynomial as a streamable polynomial

282
00:11:11,360 --> 00:11:12,640
commitment

283
00:11:12,640 --> 00:11:15,760
which is what we construct in this work

284
00:11:15,760 --> 00:11:18,079
more specifically we build on a recent

285
00:11:18,079 --> 00:11:19,839
polynomial commitment scheme due to

286
00:11:19,839 --> 00:11:22,160
burns fish and sapnic

287
00:11:22,160 --> 00:11:24,640
in fact we find a significant bug in

288
00:11:24,640 --> 00:11:26,720
their scheme

289
00:11:26,720 --> 00:11:28,800
the authors informed us that they also

290
00:11:28,800 --> 00:11:32,000
found this bug independently

291
00:11:32,000 --> 00:11:33,760
although we don't know how to fix this

292
00:11:33,760 --> 00:11:34,800
bug

293
00:11:34,800 --> 00:11:36,800
we give a non-trivial variant of their

294
00:11:36,800 --> 00:11:39,360
protocol where to prove security we

295
00:11:39,360 --> 00:11:41,120
leverage ideas from the theory of

296
00:11:41,120 --> 00:11:43,279
individual lattices

297
00:11:43,279 --> 00:11:45,519
an added benefit of our protocol is that

298
00:11:45,519 --> 00:11:47,519
it's based on significantly weaker

299
00:11:47,519 --> 00:11:51,600
assumptions than the works of bunsetal

300
00:11:51,600 --> 00:11:53,920
additionally we also show how to

301
00:11:53,920 --> 00:11:56,240
implement the committer of our scheme in

302
00:11:56,240 --> 00:11:57,519
small space

303
00:11:57,519 --> 00:12:01,440
given streaming access to the polynomial

304
00:12:01,440 --> 00:12:04,079
and finally we develop a new proof of

305
00:12:04,079 --> 00:12:05,920
exponentiation protocol that is

306
00:12:05,920 --> 00:12:08,000
essential in getting the poly

307
00:12:08,000 --> 00:12:10,079
logarithmic verifier for our argument

308
00:12:10,079 --> 00:12:11,360
scheme

309
00:12:11,360 --> 00:12:13,839
i want to emphasize that our proof of

310
00:12:13,839 --> 00:12:16,240
exponentiation protocol is statistically

311
00:12:16,240 --> 00:12:19,440
sound and works for arbitrary groups

312
00:12:19,440 --> 00:12:21,440
whereas previous work only achieved

313
00:12:21,440 --> 00:12:23,360
computational soundness under normal

314
00:12:23,360 --> 00:12:25,519
cryptographic assumptions for arbitrary

315
00:12:25,519 --> 00:12:27,920
groups

316
00:12:29,040 --> 00:12:31,040
going back to the transformation we take

317
00:12:31,040 --> 00:12:32,959
our streamable polynomial commitment

318
00:12:32,959 --> 00:12:34,639
combine them in a natural way with

319
00:12:34,639 --> 00:12:36,480
streamable polynomial iops from the

320
00:12:36,480 --> 00:12:39,200
literature and get time and space

321
00:12:39,200 --> 00:12:41,040
efficient public coin zero knowledge

322
00:12:41,040 --> 00:12:43,599
arguments

323
00:12:43,920 --> 00:12:45,519
now there are going to be there are many

324
00:12:45,519 --> 00:12:47,839
moving parts here and although space

325
00:12:47,839 --> 00:12:49,839
optimality is the killer consequence of

326
00:12:49,839 --> 00:12:52,399
our work and most relevant to practice

327
00:12:52,399 --> 00:12:54,720
it is somehow unfortunately not the most

328
00:12:54,720 --> 00:12:57,040
technically interesting bit

329
00:12:57,040 --> 00:12:58,880
so we won't be talking about polynomial

330
00:12:58,880 --> 00:13:00,639
commitments time and space efficient

331
00:13:00,639 --> 00:13:02,399
implementation and zero knowledge in the

332
00:13:02,399 --> 00:13:04,079
rest of the talk

333
00:13:04,079 --> 00:13:06,000
rather we want to focus on the main

334
00:13:06,000 --> 00:13:09,519
ideas and for this alex will discuss two

335
00:13:09,519 --> 00:13:11,040
sub protocols

336
00:13:11,040 --> 00:13:12,720
first is a proof of knowledge of

337
00:13:12,720 --> 00:13:14,880
exponent with small digits which will

338
00:13:14,880 --> 00:13:17,120
highlight the bug in the buncital paper

339
00:13:17,120 --> 00:13:18,800
and how we fix it

340
00:13:18,800 --> 00:13:20,880
and second is a proof of exponentiation

341
00:13:20,880 --> 00:13:23,120
protocol that leverages ideas from the

342
00:13:23,120 --> 00:13:25,600
proof of knowledge protocol

343
00:13:25,600 --> 00:13:28,560
alex over to you

344
00:13:28,560 --> 00:13:29,839
thank you very much fatigue hello

345
00:13:29,839 --> 00:13:31,279
everybody i'm alex block and i will

346
00:13:31,279 --> 00:13:32,800
begin by describing your protocol which

347
00:13:32,800 --> 00:13:34,560
is a succinct proof of knowledge of

348
00:13:34,560 --> 00:13:36,560
exponent with small digits and as i said

349
00:13:36,560 --> 00:13:37,760
before this protocol is the core of a

350
00:13:37,760 --> 00:13:39,440
polynomial congruence scheme

351
00:13:39,440 --> 00:13:41,279
so to begin let's fix the cyclic group g

352
00:13:41,279 --> 00:13:43,519
and two integers b and q now our proof

353
00:13:43,519 --> 00:13:44,639
of knowledge of exponent with small

354
00:13:44,639 --> 00:13:46,720
digits the public statement is some

355
00:13:46,720 --> 00:13:48,959
group element y and the prover is given

356
00:13:48,959 --> 00:13:51,199
an integer witness x so the protocol

357
00:13:51,199 --> 00:13:52,959
certifies that x is a witness to y so

358
00:13:52,959 --> 00:13:54,959
that g to the x equals y and that the

359
00:13:54,959 --> 00:13:57,440
base q representation of x has small

360
00:13:57,440 --> 00:13:59,440
digits bounded by b

361
00:13:59,440 --> 00:14:01,199
let's consider examples in our familiar

362
00:14:01,199 --> 00:14:05,040
base 10 and the bound be equal 5.

363
00:14:05,040 --> 00:14:06,880
so if x is 12 the verify should accept

364
00:14:06,880 --> 00:14:08,959
because 1 and 2 are less than 5 or less

365
00:14:08,959 --> 00:14:10,880
than or equal to 5. the verify should

366
00:14:10,880 --> 00:14:12,800
project x equals 18 because 8 is bigger

367
00:14:12,800 --> 00:14:13,839
than 5

368
00:14:13,839 --> 00:14:16,880
and the verifier should accept 252.

369
00:14:16,880 --> 00:14:18,959
okay so for the sake of this discussion

370
00:14:18,959 --> 00:14:20,480
we're going to define succinctness as

371
00:14:20,480 --> 00:14:22,320
being requiring the proof to be of size

372
00:14:22,320 --> 00:14:24,079
roughly n by 2. this just means we

373
00:14:24,079 --> 00:14:25,839
cannot send back

374
00:14:25,839 --> 00:14:27,760
so as an additional simplification we're

375
00:14:27,760 --> 00:14:29,040
going to assume unit costs to send a

376
00:14:29,040 --> 00:14:30,880
single base q digit

377
00:14:30,880 --> 00:14:32,880
and now as a warning we're going to give

378
00:14:32,880 --> 00:14:33,600
a

379
00:14:33,600 --> 00:14:35,199
divide and conquer protocol to solve

380
00:14:35,199 --> 00:14:37,279
this problem but this prob but the

381
00:14:37,279 --> 00:14:39,760
divine conqueror protocol is buggy and

382
00:14:39,760 --> 00:14:41,760
is identical to what the polynomial

383
00:14:41,760 --> 00:14:43,680
command scheme of bonds at all do

384
00:14:43,680 --> 00:14:45,040
so we're going to examine the buggy

385
00:14:45,040 --> 00:14:46,800
protocol first see where the security

386
00:14:46,800 --> 00:14:48,639
breaks and then describe our fix okay

387
00:14:48,639 --> 00:14:50,079
let's get to it

388
00:14:50,079 --> 00:14:51,440
so like i said before there's a very

389
00:14:51,440 --> 00:14:53,120
natural but buggy divide and conquer

390
00:14:53,120 --> 00:14:55,839
approach to obtain n by t communication

391
00:14:55,839 --> 00:14:57,760
simply put we split the statement y into

392
00:14:57,760 --> 00:15:00,320
two statements y and y m where x and xm

393
00:15:00,320 --> 00:15:02,160
are the witnesses for these statements

394
00:15:02,160 --> 00:15:04,079
we perform this split such that if x has

395
00:15:04,079 --> 00:15:06,240
n digits and base q then the witnesses x

396
00:15:06,240 --> 00:15:07,920
and x m have n by two d to the space

397
00:15:07,920 --> 00:15:08,959
cube

398
00:15:08,959 --> 00:15:10,160
then we somehow recombine these

399
00:15:10,160 --> 00:15:12,000
statements y l and y m a two statement y

400
00:15:12,000 --> 00:15:14,800
prime and combine xl and xm into x prime

401
00:15:14,800 --> 00:15:16,320
and the hop is that x prime is a witness

402
00:15:16,320 --> 00:15:18,480
for y prime and that x prime has n by

403
00:15:18,480 --> 00:15:21,440
two digits base q that are small

404
00:15:21,440 --> 00:15:22,800
if this is the case then the prover can

405
00:15:22,800 --> 00:15:24,560
simply send x and we're done

406
00:15:24,560 --> 00:15:27,040
so what does this protocol look like

407
00:15:27,040 --> 00:15:29,120
so we're going to define xl as the

408
00:15:29,120 --> 00:15:30,880
encode as the base q encoding of the n

409
00:15:30,880 --> 00:15:33,199
by two least and least significant

410
00:15:33,199 --> 00:15:36,320
digits of x we're going to define x m as

411
00:15:36,320 --> 00:15:38,320
the encoding of the n by two most

412
00:15:38,320 --> 00:15:40,639
significant digits of x and we will

413
00:15:40,639 --> 00:15:43,680
define y l and y m appropriately

414
00:15:43,680 --> 00:15:44,880
note that

415
00:15:44,880 --> 00:15:48,720
x l plus q to the n by two x m equals x

416
00:15:48,720 --> 00:15:50,320
and this is the check the verifier

417
00:15:50,320 --> 00:15:52,560
performs under the hood as well

418
00:15:52,560 --> 00:15:54,240
now the verifier samples are random

419
00:15:54,240 --> 00:15:56,399
lambda integer and then the proven

420
00:15:56,399 --> 00:15:57,600
verifier

421
00:15:57,600 --> 00:15:59,440
compute this random linear combination y

422
00:15:59,440 --> 00:16:01,600
prime as the recombination step

423
00:16:01,600 --> 00:16:03,759
and similarly the prover computes x

424
00:16:03,759 --> 00:16:06,160
prime equal a xl plus xn

425
00:16:06,160 --> 00:16:08,320
now the big question here is first off

426
00:16:08,320 --> 00:16:11,360
does x prime have n by two digit space q

427
00:16:11,360 --> 00:16:12,160
and

428
00:16:12,160 --> 00:16:14,560
are these digits small and is x prime a

429
00:16:14,560 --> 00:16:16,240
witness to y prime

430
00:16:16,240 --> 00:16:18,720
well i hope you'll trust me that

431
00:16:18,720 --> 00:16:21,440
i at least x prime is indeed a witness

432
00:16:21,440 --> 00:16:22,720
to y prime

433
00:16:22,720 --> 00:16:24,720
but what about the other two properties

434
00:16:24,720 --> 00:16:26,560
so as long as there's no overflow in the

435
00:16:26,560 --> 00:16:29,440
digits of a xl plus xm we can ensure

436
00:16:29,440 --> 00:16:31,440
that x prime has n by two digits and

437
00:16:31,440 --> 00:16:33,759
that x prime has bounded digits

438
00:16:33,759 --> 00:16:36,320
when can we ensure no overflow happens

439
00:16:36,320 --> 00:16:38,240
as long as q is sufficiently large as

440
00:16:38,240 --> 00:16:39,440
shown here

441
00:16:39,440 --> 00:16:42,160
so given a sufficiently large q then x

442
00:16:42,160 --> 00:16:44,399
prime has n by two digits and each of

443
00:16:44,399 --> 00:16:46,720
them are bounded sufficiently as shown

444
00:16:46,720 --> 00:16:47,920
here

445
00:16:47,920 --> 00:16:49,279
okay and at this point we're done we

446
00:16:49,279 --> 00:16:51,360
just send x prime and the refer computes

447
00:16:51,360 --> 00:16:54,000
its final checks and accepts our rejects

448
00:16:54,000 --> 00:16:56,320
so this protocol has n by two digits

449
00:16:56,320 --> 00:16:58,000
plus two group elements of communication

450
00:16:58,000 --> 00:17:00,480
which i will call succinct great

451
00:17:00,480 --> 00:17:02,240
so this protocol is both succinct and

452
00:17:02,240 --> 00:17:04,480
complete but what about sinus extraction

453
00:17:04,480 --> 00:17:05,679
and this is where i mentioned before the

454
00:17:05,679 --> 00:17:07,280
bug shows up

455
00:17:07,280 --> 00:17:08,720
so for extraction we are given a

456
00:17:08,720 --> 00:17:10,079
cheating proofer that convinces a

457
00:17:10,079 --> 00:17:12,160
verifier that a statement y is true with

458
00:17:12,160 --> 00:17:14,319
nonlinear probability and we want to

459
00:17:14,319 --> 00:17:16,640
extract out a small digit witness x for

460
00:17:16,640 --> 00:17:19,280
y from this program

461
00:17:19,280 --> 00:17:20,559
so we get we're given an initial

462
00:17:20,559 --> 00:17:22,640
interaction where we send a challenge a

463
00:17:22,640 --> 00:17:24,640
and give are given a message x prime

464
00:17:24,640 --> 00:17:26,559
such that x prime has small digits and

465
00:17:26,559 --> 00:17:29,120
is a witness to this relation here

466
00:17:29,120 --> 00:17:31,440
y l to the a times y m

467
00:17:31,440 --> 00:17:33,120
so we're going to rerun the prover send

468
00:17:33,120 --> 00:17:35,679
a distinct challenge a1 and receive x1

469
00:17:35,679 --> 00:17:37,600
prime and then we're going to

470
00:17:37,600 --> 00:17:39,440
note that x1 prime has small digits and

471
00:17:39,440 --> 00:17:41,919
satisfies the relationship here

472
00:17:41,919 --> 00:17:43,840
now my claim is sufficient

473
00:17:43,840 --> 00:17:45,520
now i claim it is sufficient to extract

474
00:17:45,520 --> 00:17:47,679
integers x on the xm such that xl is a

475
00:17:47,679 --> 00:17:49,919
witness to yl and xm is a witness to ym

476
00:17:49,919 --> 00:17:51,760
and they have small digits base q

477
00:17:51,760 --> 00:17:52,559
y

478
00:17:52,559 --> 00:17:54,160
well given these values we can

479
00:17:54,160 --> 00:17:56,720
explicitly compute x via this

480
00:17:56,720 --> 00:17:58,799
linear combination here

481
00:17:58,799 --> 00:18:01,760
okay great so we have a system of linear

482
00:18:01,760 --> 00:18:03,919
equations which i'm going to rewrite as

483
00:18:03,919 --> 00:18:06,799
this matrix vector equation

484
00:18:06,799 --> 00:18:08,720
now x prime has small digits and x1

485
00:18:08,720 --> 00:18:10,880
prime has small digits as i said before

486
00:18:10,880 --> 00:18:13,200
fix this matrix to be a let's just take

487
00:18:13,200 --> 00:18:16,160
the inverse okay very natural approach

488
00:18:16,160 --> 00:18:18,320
but very clearly there's an issue here a

489
00:18:18,320 --> 00:18:20,320
and versus rational entries and so it's

490
00:18:20,320 --> 00:18:22,320
not clear if xl and xm are integers

491
00:18:22,320 --> 00:18:23,520
anymore

492
00:18:23,520 --> 00:18:25,200
so buns at all encountered the same

493
00:18:25,200 --> 00:18:27,520
problem and here's how they handle it so

494
00:18:27,520 --> 00:18:29,440
first off they argue okay xl and xm have

495
00:18:29,440 --> 00:18:31,840
to be integers otherwise the assumption

496
00:18:31,840 --> 00:18:33,280
the computational assumption they assume

497
00:18:33,280 --> 00:18:34,880
on their group is broken so this

498
00:18:34,880 --> 00:18:36,240
computational assumption is called the

499
00:18:36,240 --> 00:18:38,400
fractional root assumption and it says

500
00:18:38,400 --> 00:18:40,480
that it's hard to compute g to the x by

501
00:18:40,480 --> 00:18:43,280
a for random a okay this is a slightly

502
00:18:43,280 --> 00:18:45,360
funky assumption but let's go with it so

503
00:18:45,360 --> 00:18:47,679
we have xl and x on our integers now do

504
00:18:47,679 --> 00:18:48,960
they have small digits that's the big

505
00:18:48,960 --> 00:18:50,160
question

506
00:18:50,160 --> 00:18:51,679
and the argument in bones at all is that

507
00:18:51,679 --> 00:18:53,360
okay x prime and x1 prime has small

508
00:18:53,360 --> 00:18:56,320
digits and a minus a1 is small therefore

509
00:18:56,320 --> 00:18:58,640
xl and xn must be small and this turns

510
00:18:58,640 --> 00:19:00,640
out to be false

511
00:19:00,640 --> 00:19:02,880
so as a counter example

512
00:19:02,880 --> 00:19:04,480
we consider this implicit claim made by

513
00:19:04,480 --> 00:19:07,039
moons at all so if x has small digits

514
00:19:07,039 --> 00:19:08,000
base q

515
00:19:08,000 --> 00:19:10,559
and a is a small integer

516
00:19:10,559 --> 00:19:11,840
dividing x

517
00:19:11,840 --> 00:19:13,520
then x divided by a has small digit

518
00:19:13,520 --> 00:19:15,520
space cubed and small just think of as

519
00:19:15,520 --> 00:19:17,280
being much less than q

520
00:19:17,280 --> 00:19:18,799
so there's a very easy counter example

521
00:19:18,799 --> 00:19:21,440
take an odd q take x equal one plus q

522
00:19:21,440 --> 00:19:23,679
and a equal to two then very clearly x

523
00:19:23,679 --> 00:19:25,200
and base q have small digits they're 1

524
00:19:25,200 --> 00:19:26,240
and 1

525
00:19:26,240 --> 00:19:28,559
but x divided by a is equal to 1 plus q

526
00:19:28,559 --> 00:19:30,720
by 2 and x divided by a base q is the

527
00:19:30,720 --> 00:19:33,600
same thing which is a single large digit

528
00:19:33,600 --> 00:19:36,320
okay so can we fix the soundless proof

529
00:19:36,320 --> 00:19:38,480
recall that we wanted xl and xm to be

530
00:19:38,480 --> 00:19:40,799
integers with small digit space q

531
00:19:40,799 --> 00:19:42,720
and that we're given x prime and x1

532
00:19:42,720 --> 00:19:44,320
prime with small digits and this matrix

533
00:19:44,320 --> 00:19:46,480
a with small integer entries and then

534
00:19:46,480 --> 00:19:47,679
the issue was that a inverse had

535
00:19:47,679 --> 00:19:49,679
rational entries

536
00:19:49,679 --> 00:19:51,679
so the question is can we sample a from

537
00:19:51,679 --> 00:19:53,360
a different distribution such that a

538
00:19:53,360 --> 00:19:56,160
inverse only has small integer entries

539
00:19:56,160 --> 00:19:57,760
if we have this then we are able to

540
00:19:57,760 --> 00:20:00,160
abstract out integers xl and xm and

541
00:20:00,160 --> 00:20:01,840
furthermore they will have small digits

542
00:20:01,840 --> 00:20:03,360
and we'll be done

543
00:20:03,360 --> 00:20:05,120
okay so then we focus on answering this

544
00:20:05,120 --> 00:20:06,960
question how do we do this

545
00:20:06,960 --> 00:20:08,480
so our approach is a divide and conquer

546
00:20:08,480 --> 00:20:10,480
approach with random subset products

547
00:20:10,480 --> 00:20:13,039
so the key idea is to fix a statistical

548
00:20:13,039 --> 00:20:15,120
security parameter lambda

549
00:20:15,120 --> 00:20:16,480
so our protocol will now be a

550
00:20:16,480 --> 00:20:18,400
statistically secure protocol and we'll

551
00:20:18,400 --> 00:20:20,159
divide and conquer lambda different

552
00:20:20,159 --> 00:20:22,000
statements into two different statements

553
00:20:22,000 --> 00:20:23,280
and then recombine into lambda

554
00:20:23,280 --> 00:20:24,480
difference statements with binary

555
00:20:24,480 --> 00:20:26,640
challenges what does this look like so

556
00:20:26,640 --> 00:20:28,559
fix lambda statements y

557
00:20:28,559 --> 00:20:30,559
1 through y lambda and lambda different

558
00:20:30,559 --> 00:20:33,280
witnesses x1 to x lambda split them

559
00:20:33,280 --> 00:20:36,080
exactly as before in the base protocol

560
00:20:36,080 --> 00:20:37,760
and now for the recombination step we're

561
00:20:37,760 --> 00:20:39,280
going to sample bits and perform a

562
00:20:39,280 --> 00:20:41,440
random subset product

563
00:20:41,440 --> 00:20:42,799
okay and i said before these are

564
00:20:42,799 --> 00:20:45,200
uniformly random bits and each bit is

565
00:20:45,200 --> 00:20:47,919
resampled for each y i prime leading to

566
00:20:47,919 --> 00:20:50,880
two lambda squared bits of randomness

567
00:20:50,880 --> 00:20:52,720
so at the end the prover just sends x

568
00:20:52,720 --> 00:20:55,200
one prime to x lambda prime

569
00:20:55,200 --> 00:20:56,080
okay

570
00:20:56,080 --> 00:20:56,799
so

571
00:20:56,799 --> 00:20:58,080
let's look at the modifications to our

572
00:20:58,080 --> 00:20:59,679
protocol first off we have again a

573
00:20:59,679 --> 00:21:01,520
statistical security parameter lambda so

574
00:21:01,520 --> 00:21:04,640
our protocol is statistically secure

575
00:21:04,640 --> 00:21:06,080
we have one of the different witnesses

576
00:21:06,080 --> 00:21:07,760
lem different statements each satisfying

577
00:21:07,760 --> 00:21:09,440
land of different constraints the same

578
00:21:09,440 --> 00:21:11,200
constraint really

579
00:21:11,200 --> 00:21:12,400
then the proof is just going to do

580
00:21:12,400 --> 00:21:13,840
exactly as we just described in the

581
00:21:13,840 --> 00:21:15,120
previous step we're going to split into

582
00:21:15,120 --> 00:21:16,720
two lambda different statements as shown

583
00:21:16,720 --> 00:21:17,520
here

584
00:21:17,520 --> 00:21:19,280
and the verifier is going to compute

585
00:21:19,280 --> 00:21:22,158
lambda different checks

586
00:21:23,200 --> 00:21:25,200
shown here

587
00:21:25,200 --> 00:21:27,440
okay looking ahead this check is

588
00:21:27,440 --> 00:21:29,360
offloaded to the prover as it is too

589
00:21:29,360 --> 00:21:31,039
expensive for the verifier we offload it

590
00:21:31,039 --> 00:21:32,720
via our new proof of exponent protocol

591
00:21:32,720 --> 00:21:35,520
which i'll talk about in a bit

592
00:21:35,520 --> 00:21:36,559
so then the

593
00:21:36,559 --> 00:21:39,360
verifier samples landed uh two lambda

594
00:21:39,360 --> 00:21:40,480
squared bits of randomness we have this

595
00:21:40,480 --> 00:21:41,760
matrix a

596
00:21:41,760 --> 00:21:43,600
and then recombination is done exactly

597
00:21:43,600 --> 00:21:46,080
as before via random subset products and

598
00:21:46,080 --> 00:21:47,600
at the end the prover just sends x one

599
00:21:47,600 --> 00:21:49,679
prime to x lambda prime

600
00:21:49,679 --> 00:21:51,360
so what about standards of our protocol

601
00:21:51,360 --> 00:21:53,600
so again is sufficient to extract these

602
00:21:53,600 --> 00:21:56,320
two lambda integers x i l x i m which

603
00:21:56,320 --> 00:21:58,880
are witnesses to y i l and y i m and all

604
00:21:58,880 --> 00:22:01,039
have small digits base q

605
00:22:01,039 --> 00:22:02,240
so we're going to take our malicious

606
00:22:02,240 --> 00:22:03,840
prover we're going to rewind it some

607
00:22:03,840 --> 00:22:06,320
constant number c times and obtain a new

608
00:22:06,320 --> 00:22:07,840
system of linear equations that looks

609
00:22:07,840 --> 00:22:08,960
like this

610
00:22:08,960 --> 00:22:11,600
so each of these x i primes these

611
00:22:11,600 --> 00:22:13,919
capital x i primes has lambda different

612
00:22:13,919 --> 00:22:15,760
has lambda entries and each of these

613
00:22:15,760 --> 00:22:18,159
entries have small digits

614
00:22:18,159 --> 00:22:20,640
now fix this big block matrix to be a we

615
00:22:20,640 --> 00:22:23,200
want this matrix to have an integer left

616
00:22:23,200 --> 00:22:25,760
inverse specifically with small entries

617
00:22:25,760 --> 00:22:28,000
once this happens we are done

618
00:22:28,000 --> 00:22:30,720
so this gives our key lemma

619
00:22:30,720 --> 00:22:33,200
so fix their distribution d to be

620
00:22:33,200 --> 00:22:35,360
exactly as what the extractor does

621
00:22:35,360 --> 00:22:37,039
mainly it samples some constant number

622
00:22:37,039 --> 00:22:40,559
of lambda by two lambda binary matrices

623
00:22:40,559 --> 00:22:42,480
it stacks them on top of each other and

624
00:22:42,480 --> 00:22:46,080
outputs this a so c is a constant here

625
00:22:46,080 --> 00:22:48,080
so if we sample a in this manner then x

626
00:22:48,080 --> 00:22:49,200
up with two to the minus lambda

627
00:22:49,200 --> 00:22:50,400
probability

628
00:22:50,400 --> 00:22:52,480
a has an integer left inverse and the

629
00:22:52,480 --> 00:22:53,760
entries of a are bounded by 2 to the

630
00:22:53,760 --> 00:22:55,039
poly lambda

631
00:22:55,039 --> 00:22:57,360
this to the poly lambda is okay by us

632
00:22:57,360 --> 00:22:59,280
because it is independent of the value q

633
00:22:59,280 --> 00:23:00,720
in the protocol

634
00:23:00,720 --> 00:23:02,400
and furthermore as necessary for the

635
00:23:02,400 --> 00:23:04,000
extraction a inverse can be computed in

636
00:23:04,000 --> 00:23:06,080
poly lambda time

637
00:23:06,080 --> 00:23:07,440
so i'm not going to get into the proof

638
00:23:07,440 --> 00:23:09,039
in this talk but the proof uses ideas

639
00:23:09,039 --> 00:23:11,039
from the theory of integer lattices and

640
00:23:11,039 --> 00:23:12,720
we foresee being a very useful tool and

641
00:23:12,720 --> 00:23:14,960
crypto based on integers such as our

642
00:23:14,960 --> 00:23:16,480
work here

643
00:23:16,480 --> 00:23:18,400
so just to recap we give a proof of

644
00:23:18,400 --> 00:23:20,159
knowledge of exponent with

645
00:23:20,159 --> 00:23:22,400
small digits base q

646
00:23:22,400 --> 00:23:24,960
uh we highlighted a buggy protocol and

647
00:23:24,960 --> 00:23:27,840
we describe our fix from which uses

648
00:23:27,840 --> 00:23:29,120
ideas from the theory of integer

649
00:23:29,120 --> 00:23:30,159
lattices

650
00:23:30,159 --> 00:23:32,720
and the subset product thingy

651
00:23:32,720 --> 00:23:34,240
and as a result we obtain a particle

652
00:23:34,240 --> 00:23:36,640
which is statistically sound and i want

653
00:23:36,640 --> 00:23:38,400
to emphasize that this proof of

654
00:23:38,400 --> 00:23:40,240
knowledge protocol captures the main

655
00:23:40,240 --> 00:23:41,919
technical ideas of our panama commitment

656
00:23:41,919 --> 00:23:43,600
scheme and can be modified to the full

657
00:23:43,600 --> 00:23:44,880
version of our streamable polymer

658
00:23:44,880 --> 00:23:47,520
commitments gaming with some tweaks

659
00:23:47,520 --> 00:23:48,640
furthermore if we want logarithmic

660
00:23:48,640 --> 00:23:50,640
communication we can just recurse log n

661
00:23:50,640 --> 00:23:52,559
times on this lambda 2 lambda lambda

662
00:23:52,559 --> 00:23:54,000
protocol

663
00:23:54,000 --> 00:23:55,120
and then finally i want to mention

664
00:23:55,120 --> 00:23:56,400
there's a gap in the completeness and

665
00:23:56,400 --> 00:23:57,760
soundness

666
00:23:57,760 --> 00:23:59,440
if we want to extract out b bounded

667
00:23:59,440 --> 00:24:01,840
digits in the extraction then we need an

668
00:24:01,840 --> 00:24:03,760
honest proof to start with some b prime

669
00:24:03,760 --> 00:24:05,760
bounded bounded digits which is much

670
00:24:05,760 --> 00:24:07,919
smaller than b

671
00:24:07,919 --> 00:24:08,799
okay

672
00:24:08,799 --> 00:24:10,000
so with the proven knowledge of

673
00:24:10,000 --> 00:24:11,760
exponential quantity it's complete we're

674
00:24:11,760 --> 00:24:13,360
going to move on to our next

675
00:24:13,360 --> 00:24:15,200
awesome thing the proof of

676
00:24:15,200 --> 00:24:18,480
exponentiation for arbitrary groups

677
00:24:18,480 --> 00:24:20,880
so the poe problem specifies a group g

678
00:24:20,880 --> 00:24:23,200
two elements x and y in the group and an

679
00:24:23,200 --> 00:24:25,760
integer t all this information is public

680
00:24:25,760 --> 00:24:27,520
and we want an interactive protocol or

681
00:24:27,520 --> 00:24:30,240
non-interactive protocol that produces a

682
00:24:30,240 --> 00:24:32,480
proof pie which it tests that y to the 2

683
00:24:32,480 --> 00:24:34,799
to the t equals x

684
00:24:34,799 --> 00:24:36,640
sorry excuse me x to the 2 to the t

685
00:24:36,640 --> 00:24:38,400
equals y

686
00:24:38,400 --> 00:24:40,960
of course there's a naive so poe is

687
00:24:40,960 --> 00:24:42,640
actually a very important component of

688
00:24:42,640 --> 00:24:45,679
vdfs and systemic polymer commitments

689
00:24:45,679 --> 00:24:48,240
and of course the naive solution has the

690
00:24:48,240 --> 00:24:50,080
verifier just compute this x to the 2 to

691
00:24:50,080 --> 00:24:51,279
the t

692
00:24:51,279 --> 00:24:52,880
this works for any group this requires

693
00:24:52,880 --> 00:24:54,320
no communication

694
00:24:54,320 --> 00:24:55,600
but the v

695
00:24:55,600 --> 00:24:57,679
but the verifier runs in time t

696
00:24:57,679 --> 00:24:59,679
so can we submit the verifier

697
00:24:59,679 --> 00:25:01,840
so there are a couple of works with

698
00:25:01,840 --> 00:25:04,000
subliner verification so poe sublime

699
00:25:04,000 --> 00:25:05,200
verification

700
00:25:05,200 --> 00:25:07,200
so petrasart gives a statistically sound

701
00:25:07,200 --> 00:25:09,279
protocol in rsa groups so this is only

702
00:25:09,279 --> 00:25:11,360
statistically sound in rsa groups where

703
00:25:11,360 --> 00:25:14,080
the verifier runs in logarithmic time

704
00:25:14,080 --> 00:25:15,760
while zolowski gives a computational

705
00:25:15,760 --> 00:25:17,360
sound protocol assuming class groups

706
00:25:17,360 --> 00:25:18,320
with the adapt something called the

707
00:25:18,320 --> 00:25:19,919
adaptive route assumption and the

708
00:25:19,919 --> 00:25:22,159
verified time is constant

709
00:25:22,159 --> 00:25:23,919
then bonnet at all observed that

710
00:25:23,919 --> 00:25:25,760
petroleum's protocol

711
00:25:25,760 --> 00:25:28,480
is also computationally secure assuming

712
00:25:28,480 --> 00:25:30,400
other group assumptions class mainly

713
00:25:30,400 --> 00:25:32,799
class groups with low earth assumption

714
00:25:32,799 --> 00:25:34,640
okay so our main question here is can we

715
00:25:34,640 --> 00:25:36,880
get a statistically sound

716
00:25:36,880 --> 00:25:39,520
poe over class groups or arbitrary

717
00:25:39,520 --> 00:25:41,919
groups for that matter and in fact yes

718
00:25:41,919 --> 00:25:43,760
so in this work we give a statistically

719
00:25:43,760 --> 00:25:45,919
sound poe that works over any group with

720
00:25:45,919 --> 00:25:46,960
some with

721
00:25:46,960 --> 00:25:49,760
logarithmic verification

722
00:25:49,760 --> 00:25:51,840
so what does this look like so

723
00:25:51,840 --> 00:25:53,440
just the main theorem it is a public

724
00:25:53,440 --> 00:25:56,159
coin statistically sound p-o-e over any

725
00:25:56,159 --> 00:25:56,960
group

726
00:25:56,960 --> 00:25:59,440
where the verifier time is logarithmic

727
00:25:59,440 --> 00:26:00,799
the proof size and number of rounds is

728
00:26:00,799 --> 00:26:02,320
logarithmic

729
00:26:02,320 --> 00:26:04,480
and the proof of time is linear

730
00:26:04,480 --> 00:26:06,080
so what do we do we generalize petri

731
00:26:06,080 --> 00:26:08,559
direct protocol to work over

732
00:26:08,559 --> 00:26:10,720
any group and this can be made

733
00:26:10,720 --> 00:26:12,640
non-interactive or via the fiat

734
00:26:12,640 --> 00:26:14,480
heuristic

735
00:26:14,480 --> 00:26:16,240
so very briefly we're going to go over

736
00:26:16,240 --> 00:26:18,960
petrozark's halfing protocol

737
00:26:18,960 --> 00:26:20,960
this is the core of petrozark's

738
00:26:20,960 --> 00:26:22,559
poe and then we're going to give our

739
00:26:22,559 --> 00:26:24,880
modification

740
00:26:24,880 --> 00:26:26,320
so the halfing protocol splits

741
00:26:26,320 --> 00:26:29,279
computation of x to the 2 to the t

742
00:26:29,279 --> 00:26:31,840
in half via first computing this mu and

743
00:26:31,840 --> 00:26:33,520
having the proof resend it so x to the 2

744
00:26:33,520 --> 00:26:35,039
to the t by 2.

745
00:26:35,039 --> 00:26:36,880
now if mu is computed correctly as shown

746
00:26:36,880 --> 00:26:40,320
here then y is in fact equal to mu to

747
00:26:40,320 --> 00:26:42,159
the two to the t by two so the power is

748
00:26:42,159 --> 00:26:44,000
split in half

749
00:26:44,000 --> 00:26:45,440
then a random linear combination is

750
00:26:45,440 --> 00:26:49,200
sampled by the verifier which is then

751
00:26:49,200 --> 00:26:51,520
computed via then experiment y prime are

752
00:26:51,520 --> 00:26:52,799
computed via this random linear

753
00:26:52,799 --> 00:26:55,919
combination and indeed if mu is if mu is

754
00:26:55,919 --> 00:26:57,919
computed correctly and the x prime and y

755
00:26:57,919 --> 00:26:59,679
prime computed correctly

756
00:26:59,679 --> 00:27:02,000
then y prime is in fact x prime to the

757
00:27:02,000 --> 00:27:04,159
two to the t by two so we go from an

758
00:27:04,159 --> 00:27:05,919
exponent size t to an exponential t by

759
00:27:05,919 --> 00:27:06,880
two

760
00:27:06,880 --> 00:27:08,799
so for the full protocol you you recurse

761
00:27:08,799 --> 00:27:11,120
log t times and the verifier checks the

762
00:27:11,120 --> 00:27:12,880
final claim itself

763
00:27:12,880 --> 00:27:14,559
okay so what about

764
00:27:14,559 --> 00:27:18,480
our poe so rpoe is actually again using

765
00:27:18,480 --> 00:27:20,240
the ideas of dividing conquer via random

766
00:27:20,240 --> 00:27:22,399
subset products that we saw in the proof

767
00:27:22,399 --> 00:27:24,880
of knowledge of exponent

768
00:27:24,880 --> 00:27:26,399
so we now again have a lambda

769
00:27:26,399 --> 00:27:28,000
statistical security parameter we have

770
00:27:28,000 --> 00:27:30,640
lambda different poe instances

771
00:27:30,640 --> 00:27:32,159
and we're going to do the same halfing

772
00:27:32,159 --> 00:27:34,320
for each but now our recombination is

773
00:27:34,320 --> 00:27:36,720
again via random subset product so again

774
00:27:36,720 --> 00:27:39,600
these ais are randomly selected bits

775
00:27:39,600 --> 00:27:41,200
okay so

776
00:27:41,200 --> 00:27:42,720
i'm not going to go into full details

777
00:27:42,720 --> 00:27:44,559
but i hope you'll believe me when i say

778
00:27:44,559 --> 00:27:47,360
that this modification is complete it is

779
00:27:47,360 --> 00:27:49,039
statistically sound and it works over

780
00:27:49,039 --> 00:27:50,960
any group g

781
00:27:50,960 --> 00:27:52,960
okay so that completes the section on

782
00:27:52,960 --> 00:27:54,320
the proof of exponentiation for

783
00:27:54,320 --> 00:27:56,000
arbitrary groups and in fact we come to

784
00:27:56,000 --> 00:27:58,240
the end of the talk so i want to end by

785
00:27:58,240 --> 00:28:00,720
first just flashing our main theorem and

786
00:28:00,720 --> 00:28:02,880
restating it again so assuming hidden

787
00:28:02,880 --> 00:28:05,279
order groups we obtain public coin zero

788
00:28:05,279 --> 00:28:06,640
knowledge arguments for languages

789
00:28:06,640 --> 00:28:08,720
accepted by a

790
00:28:08,720 --> 00:28:09,679
time t

791
00:28:09,679 --> 00:28:12,000
space as non-deterministic ram where the

792
00:28:12,000 --> 00:28:13,679
prover time is nearly optimal the proof

793
00:28:13,679 --> 00:28:15,200
of space has poly logarithmic overhead

794
00:28:15,200 --> 00:28:17,440
with respect to the ram the verified

795
00:28:17,440 --> 00:28:20,559
time is poly logarithmic overhead

796
00:28:20,559 --> 00:28:22,399
um the communication is poly algorithmic

797
00:28:22,399 --> 00:28:24,399
and the number of rounds is logarithmic

798
00:28:24,399 --> 00:28:26,000
for the more assuming hidden order

799
00:28:26,000 --> 00:28:28,159
groups we obtain a transparent setup and

800
00:28:28,159 --> 00:28:29,760
we can make this non-interactive via

801
00:28:29,760 --> 00:28:31,760
fiat premiere and obtain time and space

802
00:28:31,760 --> 00:28:34,080
sufficient zero knowledge arguments

803
00:28:34,080 --> 00:28:35,679
uh succinct non-interactive and

804
00:28:35,679 --> 00:28:37,919
knowledge arguments and with that thank

805
00:28:37,919 --> 00:28:41,200
you very much

