1
00:00:00,719 --> 00:00:01,839
hi

2
00:00:01,839 --> 00:00:03,280
my name is joe

3
00:00:03,280 --> 00:00:04,960
and this talk is on our paper that's

4
00:00:04,960 --> 00:00:07,919
been accepted to crypto 2021 latin

5
00:00:07,919 --> 00:00:10,000
production with approximate enumeration

6
00:00:10,000 --> 00:00:12,000
oracles practical algorithms and

7
00:00:12,000 --> 00:00:13,519
concrete performance

8
00:00:13,519 --> 00:00:15,759
this is joint work with martin albrecht

9
00:00:15,759 --> 00:00:18,640
shubai and chanwelli

10
00:00:18,640 --> 00:00:20,400
so before we start i'd like to give you

11
00:00:20,400 --> 00:00:22,640
a high-level summary of what this talk

12
00:00:22,640 --> 00:00:25,279
and what this work are ultimately about

13
00:00:25,279 --> 00:00:27,519
this is a talk about block-wise lattice

14
00:00:27,519 --> 00:00:30,240
reduction and in particular we focus on

15
00:00:30,240 --> 00:00:31,760
the role of an algorithm called

16
00:00:31,760 --> 00:00:33,280
enumeration

17
00:00:33,280 --> 00:00:35,040
inside these block-wise reduction

18
00:00:35,040 --> 00:00:36,640
algorithms

19
00:00:36,640 --> 00:00:38,079
and crucially what we're really going to

20
00:00:38,079 --> 00:00:40,719
focus on is how changing how

21
00:00:40,719 --> 00:00:42,800
these oracles behave inside a block-wise

22
00:00:42,800 --> 00:00:44,960
reduction algorithm couldn't change the

23
00:00:44,960 --> 00:00:48,800
running time by an exponential factor

24
00:00:49,120 --> 00:00:51,600
there's obviously some clear motivation

25
00:00:51,600 --> 00:00:53,360
that's needed for this work

26
00:00:53,360 --> 00:00:55,520
and in particular you can view this

27
00:00:55,520 --> 00:00:57,199
via the fact that lattices are the basis

28
00:00:57,199 --> 00:00:59,600
of five of the remaining seven

29
00:00:59,600 --> 00:01:02,800
schemes in the nist pqc process

30
00:01:02,800 --> 00:01:05,199
understanding the difficulty of solving

31
00:01:05,199 --> 00:01:06,799
the problems upon which these schemes

32
00:01:06,799 --> 00:01:09,840
are based such as the lwe variants and

33
00:01:09,840 --> 00:01:11,840
entro is crucial for setting

34
00:01:11,840 --> 00:01:14,080
cryptographic parameters

35
00:01:14,080 --> 00:01:16,479
if we don't truly understand how hard

36
00:01:16,479 --> 00:01:18,560
these problems are to solve

37
00:01:18,560 --> 00:01:20,320
then we may set either parameters too

38
00:01:20,320 --> 00:01:22,880
large and compromise on efficiency or

39
00:01:22,880 --> 00:01:25,680
too small and compromising security

40
00:01:25,680 --> 00:01:27,200
and although there are many approaches

41
00:01:27,200 --> 00:01:29,360
to solving these problems the best

42
00:01:29,360 --> 00:01:31,520
practical attacks against these schemes

43
00:01:31,520 --> 00:01:34,640
require block-wise lattice reduction

44
00:01:34,640 --> 00:01:36,560
so before we begin we'll go over some

45
00:01:36,560 --> 00:01:37,920
preliminaries

46
00:01:37,920 --> 00:01:40,880
so if we have some set b comprised of

47
00:01:40,880 --> 00:01:44,079
vectors b zero through to b n minus one

48
00:01:44,079 --> 00:01:47,119
of some linearly independent vectors

49
00:01:47,119 --> 00:01:49,200
then we refer to the set of all

50
00:01:49,200 --> 00:01:51,840
interlinear combinations of the vectors

51
00:01:51,840 --> 00:01:52,799
in b

52
00:01:52,799 --> 00:01:55,360
as the lattice l of b

53
00:01:55,360 --> 00:01:58,000
or simply l

54
00:01:58,000 --> 00:01:59,200
you may also

55
00:01:59,200 --> 00:02:00,960
have heard of b by a different word

56
00:02:00,960 --> 00:02:03,119
which is referred to as a basis but for

57
00:02:03,119 --> 00:02:04,479
the sake of this talk we should just

58
00:02:04,479 --> 00:02:06,880
refer to it as b

59
00:02:06,880 --> 00:02:09,199
lattices have an associated invariant

60
00:02:09,199 --> 00:02:10,639
known as the volume

61
00:02:10,639 --> 00:02:12,239
and you can see that this is efficiently

62
00:02:12,239 --> 00:02:14,400
computable for some

63
00:02:14,400 --> 00:02:15,440
set b

64
00:02:15,440 --> 00:02:16,720
when the vectors are linearly

65
00:02:16,720 --> 00:02:18,640
independent

66
00:02:18,640 --> 00:02:20,959
this volume also has a nice geometric

67
00:02:20,959 --> 00:02:23,280
property as well it corresponds to the

68
00:02:23,280 --> 00:02:25,200
density of the lattice

69
00:02:25,200 --> 00:02:27,440
if your volume is small then it implies

70
00:02:27,440 --> 00:02:29,760
your lattice is very dense whereas if

71
00:02:29,760 --> 00:02:31,840
you have a large volume it implies the

72
00:02:31,840 --> 00:02:35,120
lattice is rather sparse

73
00:02:35,599 --> 00:02:37,280
when thinking about solving

74
00:02:37,280 --> 00:02:39,360
cryptographic problems typically

75
00:02:39,360 --> 00:02:41,760
speaking we focus on the shortest vector

76
00:02:41,760 --> 00:02:43,040
problem

77
00:02:43,040 --> 00:02:44,879
in this work we focus on a variant of

78
00:02:44,879 --> 00:02:46,720
the short effect problem known as

79
00:02:46,720 --> 00:02:48,640
hermite svp

80
00:02:48,640 --> 00:02:50,560
and in particular the definition of this

81
00:02:50,560 --> 00:02:53,040
is if we want to solve delta approximate

82
00:02:53,040 --> 00:02:56,720
my svp on an n-dimensional lattice l

83
00:02:56,720 --> 00:02:59,120
we require to find a vector v

84
00:02:59,120 --> 00:03:01,519
that has norm less than delta times the

85
00:03:01,519 --> 00:03:03,760
volume of the lattice normalized by the

86
00:03:03,760 --> 00:03:06,000
dimension

87
00:03:06,000 --> 00:03:08,000
typically speaking one might consider

88
00:03:08,000 --> 00:03:10,640
delta as this square root of n over two

89
00:03:10,640 --> 00:03:11,920
pi eta

90
00:03:11,920 --> 00:03:13,599
and the reason for this is because this

91
00:03:13,599 --> 00:03:16,000
is exactly the leading factor

92
00:03:16,000 --> 00:03:18,959
as predicted by the gaussian heuristic

93
00:03:18,959 --> 00:03:21,440
because this value depends solely on the

94
00:03:21,440 --> 00:03:23,599
dimension of the lattice for the rest of

95
00:03:23,599 --> 00:03:26,000
this talk we'll simply refer to this as

96
00:03:26,000 --> 00:03:28,560
gh of n

97
00:03:28,560 --> 00:03:30,239
so just to give you a pictorial

98
00:03:30,239 --> 00:03:32,239
representation of what a lattice looks

99
00:03:32,239 --> 00:03:32,959
like

100
00:03:32,959 --> 00:03:34,720
you can see on the left hand side here

101
00:03:34,720 --> 00:03:36,879
that we have a regularly repeating set

102
00:03:36,879 --> 00:03:38,159
of points

103
00:03:38,159 --> 00:03:39,760
and you can also see on the right hand

104
00:03:39,760 --> 00:03:42,480
side we have a picture that shows

105
00:03:42,480 --> 00:03:45,599
the shortest vector in this lattice

106
00:03:45,599 --> 00:03:47,920
geometrically speaking you can view the

107
00:03:47,920 --> 00:03:49,840
volume as the area

108
00:03:49,840 --> 00:03:52,400
of one of these squares that appear on

109
00:03:52,400 --> 00:03:53,760
the slide

110
00:03:53,760 --> 00:03:55,519
so for example if you took a point of

111
00:03:55,519 --> 00:03:56,560
the origin

112
00:03:56,560 --> 00:03:58,080
and went out to the point that it's

113
00:03:58,080 --> 00:04:00,000
closest to it on the right hand side

114
00:04:00,000 --> 00:04:02,959
then this also forms part of a square

115
00:04:02,959 --> 00:04:05,519
and the volume of this square is the

116
00:04:05,519 --> 00:04:08,480
volume of the lattice

117
00:04:08,879 --> 00:04:10,319
when approaching

118
00:04:10,319 --> 00:04:13,200
when attempting to solve hsvp

119
00:04:13,200 --> 00:04:17,519
typically what one does is replace the

120
00:04:17,519 --> 00:04:18,959
exact problem

121
00:04:18,959 --> 00:04:20,798
with an approximation

122
00:04:20,798 --> 00:04:22,639
and the typical way to do this is to

123
00:04:22,639 --> 00:04:26,240
embed an exact hsvp solver inside some

124
00:04:26,240 --> 00:04:28,639
block-wise reduction algorithm

125
00:04:28,639 --> 00:04:30,560
the intuition behind why one might do

126
00:04:30,560 --> 00:04:31,360
this

127
00:04:31,360 --> 00:04:33,840
is because you're replacing the basis by

128
00:04:33,840 --> 00:04:36,560
a set of short nearly orthogonal

129
00:04:36,560 --> 00:04:39,199
linearly independent vectors

130
00:04:39,199 --> 00:04:41,120
the reason for this is you're trying to

131
00:04:41,120 --> 00:04:43,120
balance out the contribution of the

132
00:04:43,120 --> 00:04:45,520
lengths across all of the vectors in

133
00:04:45,520 --> 00:04:47,919
your basis

134
00:04:47,919 --> 00:04:49,199
in particular

135
00:04:49,199 --> 00:04:51,680
we take the basis for some lattice of

136
00:04:51,680 --> 00:04:52,720
rank n

137
00:04:52,720 --> 00:04:54,639
and decompose it into projected

138
00:04:54,639 --> 00:04:57,520
sub-lattices of rank k

139
00:04:57,520 --> 00:04:59,040
and the way that we form these projected

140
00:04:59,040 --> 00:05:02,080
sub-lattices is if we have some

141
00:05:02,080 --> 00:05:05,440
projected sub-letters l of i-j

142
00:05:05,440 --> 00:05:07,919
we project the vectors in the basis from

143
00:05:07,919 --> 00:05:12,000
b i up to bj orthogonally to the span of

144
00:05:12,000 --> 00:05:14,720
the previous vectors in the bases

145
00:05:14,720 --> 00:05:17,280
and this provides a very powerful time

146
00:05:17,280 --> 00:05:19,199
quality trade-off

147
00:05:19,199 --> 00:05:20,560
if the rank of our projected

148
00:05:20,560 --> 00:05:23,520
sub-lattices is close to the rank of the

149
00:05:23,520 --> 00:05:25,280
lattice at large

150
00:05:25,280 --> 00:05:26,880
then the

151
00:05:26,880 --> 00:05:29,759
output basis is more likely to be short

152
00:05:29,759 --> 00:05:31,680
and near orthogonal

153
00:05:31,680 --> 00:05:33,199
by contrast

154
00:05:33,199 --> 00:05:35,680
if we make k rather small

155
00:05:35,680 --> 00:05:38,880
then the problem will be faster to solve

156
00:05:38,880 --> 00:05:41,440
because it's less challenging

157
00:05:41,440 --> 00:05:43,919
but the quality of the output basis is

158
00:05:43,919 --> 00:05:46,880
unlikely to be as good

159
00:05:46,880 --> 00:05:48,479
as we would want

160
00:05:48,479 --> 00:05:50,479
so there's a real trade-off here between

161
00:05:50,479 --> 00:05:52,560
how large we choose these blocks to

162
00:05:52,560 --> 00:05:54,880
ensure that our output basis looks a

163
00:05:54,880 --> 00:05:56,880
certain way

164
00:05:56,880 --> 00:05:58,720
but we also need to balance this against

165
00:05:58,720 --> 00:06:01,440
the running time

166
00:06:01,759 --> 00:06:04,400
one way to gauge the quality

167
00:06:04,400 --> 00:06:07,600
of these algorithms is using a measure

168
00:06:07,600 --> 00:06:09,520
called the root hermite factor or the

169
00:06:09,520 --> 00:06:10,960
rhf

170
00:06:10,960 --> 00:06:13,280
and put briefly the root hermite factor

171
00:06:13,280 --> 00:06:15,280
of some lattice l

172
00:06:15,280 --> 00:06:17,199
is the length of the first vector in the

173
00:06:17,199 --> 00:06:21,120
lattice divided by the normalized length

174
00:06:21,120 --> 00:06:23,840
that we might expect so this term in the

175
00:06:23,840 --> 00:06:26,160
denominator here is the length you might

176
00:06:26,160 --> 00:06:28,560
expect if the norms of all of the

177
00:06:28,560 --> 00:06:30,080
vectors in the lattice were evenly

178
00:06:30,080 --> 00:06:31,919
distributed

179
00:06:31,919 --> 00:06:34,160
because this quality is independent of

180
00:06:34,160 --> 00:06:36,479
the rank of the lattice we normalize by

181
00:06:36,479 --> 00:06:39,199
this term one over n minus one but this

182
00:06:39,199 --> 00:06:42,000
is just to normalize the quality

183
00:06:42,000 --> 00:06:43,120
for

184
00:06:43,120 --> 00:06:44,960
so we can compare across many different

185
00:06:44,960 --> 00:06:47,440
lattices

186
00:06:47,440 --> 00:06:49,759
one blockwise reduction algorithm that

187
00:06:49,759 --> 00:06:51,120
features quite a lot in the literature

188
00:06:51,120 --> 00:06:53,120
is called bkz

189
00:06:53,120 --> 00:06:56,000
and what bkz does is you divide the

190
00:06:56,000 --> 00:06:58,720
lattice up into blocks of size k

191
00:06:58,720 --> 00:07:01,680
and you first find the shortest vector

192
00:07:01,680 --> 00:07:04,080
over the first k elements and then you

193
00:07:04,080 --> 00:07:06,639
shift one along by projections and find

194
00:07:06,639 --> 00:07:08,800
the shortest vector in that sub lattice

195
00:07:08,800 --> 00:07:11,599
and you continue this process many times

196
00:07:11,599 --> 00:07:13,840
until you end up with a basis that looks

197
00:07:13,840 --> 00:07:14,840
a certain

198
00:07:14,840 --> 00:07:17,120
way there are some theoretical

199
00:07:17,120 --> 00:07:20,319
guarantees on how bkz operates

200
00:07:20,319 --> 00:07:22,479
but you can essentially think about the

201
00:07:22,479 --> 00:07:25,440
each block having the shortest vector in

202
00:07:25,440 --> 00:07:29,199
that block in the first position

203
00:07:29,199 --> 00:07:32,479
it can also be useful to run bkz on

204
00:07:32,479 --> 00:07:34,240
these projected sublattices in a

205
00:07:34,240 --> 00:07:36,639
recursive sense so that you have some

206
00:07:36,639 --> 00:07:38,800
guarantees about the shape of the basis

207
00:07:38,800 --> 00:07:41,039
or how the norms are distributed before

208
00:07:41,039 --> 00:07:42,479
you start

209
00:07:42,479 --> 00:07:44,639
doing the rest of the work but again

210
00:07:44,639 --> 00:07:46,080
this is another trade-off that needs to

211
00:07:46,080 --> 00:07:47,360
be considered

212
00:07:47,360 --> 00:07:49,440
because pre-processing also comes with

213
00:07:49,440 --> 00:07:51,759
cost

214
00:07:52,639 --> 00:07:54,319
once you have a block-wise reduction

215
00:07:54,319 --> 00:07:56,160
algorithm such as bkz

216
00:07:56,160 --> 00:07:58,479
you do need an exact solver

217
00:07:58,479 --> 00:08:00,720
to reduce the blocks

218
00:08:00,720 --> 00:08:02,240
and in this work we consider an

219
00:08:02,240 --> 00:08:04,879
algorithm known as enumeration

220
00:08:04,879 --> 00:08:07,520
enumeration works by walking across all

221
00:08:07,520 --> 00:08:09,680
of the points inside a ball

222
00:08:09,680 --> 00:08:11,599
of some radius r

223
00:08:11,599 --> 00:08:13,840
that intersects with the lattice so

224
00:08:13,840 --> 00:08:15,280
we're looking for all of the lattice

225
00:08:15,280 --> 00:08:17,680
points that are inside some ball with a

226
00:08:17,680 --> 00:08:19,919
particular radius

227
00:08:19,919 --> 00:08:22,000
if you center this ball at the origin

228
00:08:22,000 --> 00:08:24,000
then this has the same effect of making

229
00:08:24,000 --> 00:08:26,479
sure that all of the vectors in this

230
00:08:26,479 --> 00:08:28,080
inside the sphere

231
00:08:28,080 --> 00:08:29,520
are less than

232
00:08:29,520 --> 00:08:31,919
length are

233
00:08:31,919 --> 00:08:33,519
without going into too much detail about

234
00:08:33,519 --> 00:08:35,039
how this works

235
00:08:35,039 --> 00:08:37,120
what one first does is you start with

236
00:08:37,120 --> 00:08:39,599
the final

237
00:08:39,599 --> 00:08:41,360
vector in the basis

238
00:08:41,360 --> 00:08:44,000
and you produce all combinations of that

239
00:08:44,000 --> 00:08:47,120
vector for r inside this ball and then

240
00:08:47,120 --> 00:08:49,120
you gradually walk your way across the

241
00:08:49,120 --> 00:08:50,480
rest of the basis

242
00:08:50,480 --> 00:08:52,399
until you're finished with all of the

243
00:08:52,399 --> 00:08:55,440
points inside that ball

244
00:08:55,440 --> 00:08:56,959
this algorithm has been very well

245
00:08:56,959 --> 00:08:57,920
studied

246
00:08:57,920 --> 00:09:00,480
and to date the best known variants of

247
00:09:00,480 --> 00:09:03,279
this algorithm run inside bkz

248
00:09:03,279 --> 00:09:05,440
in time 2 to the power of k log k

249
00:09:05,440 --> 00:09:06,880
divided by 8

250
00:09:06,880 --> 00:09:09,040
times some exponential term

251
00:09:09,040 --> 00:09:10,959
but crucially they also run in space

252
00:09:10,959 --> 00:09:14,160
polynomial in the rank of the lattice

253
00:09:14,160 --> 00:09:16,959
in this work we're focusing on improving

254
00:09:16,959 --> 00:09:19,279
this exponential term without

255
00:09:19,279 --> 00:09:21,760
compromising on the hermite factor we

256
00:09:21,760 --> 00:09:23,279
want to make sure that no matter what we

257
00:09:23,279 --> 00:09:26,160
do here we maintain the quality

258
00:09:26,160 --> 00:09:30,240
of the basis that's output by bkz

259
00:09:30,399 --> 00:09:32,160
one classic approach to doing this is

260
00:09:32,160 --> 00:09:34,000
known as pruning

261
00:09:34,000 --> 00:09:34,800
and

262
00:09:34,800 --> 00:09:36,560
intuitively the way you can think about

263
00:09:36,560 --> 00:09:37,360
this

264
00:09:37,360 --> 00:09:39,360
is that the previous explanation

265
00:09:39,360 --> 00:09:41,440
considered finding all of the vectors

266
00:09:41,440 --> 00:09:43,200
inside this set

267
00:09:43,200 --> 00:09:45,440
s intersect l

268
00:09:45,440 --> 00:09:46,880
but not all of the piles in the

269
00:09:46,880 --> 00:09:49,120
enumeration tree are likely to lead to

270
00:09:49,120 --> 00:09:52,000
solutions the enumeration tree is very

271
00:09:52,000 --> 00:09:53,600
large in size

272
00:09:53,600 --> 00:09:55,040
and we don't expect there to be that

273
00:09:55,040 --> 00:09:56,880
many short vectors

274
00:09:56,880 --> 00:09:59,680
as a result and a typical approach is to

275
00:09:59,680 --> 00:10:01,519
cut off some of these parts that we

276
00:10:01,519 --> 00:10:02,800
don't need

277
00:10:02,800 --> 00:10:04,880
and this is referred to as pruning we

278
00:10:04,880 --> 00:10:06,480
simply cut off branches in the

279
00:10:06,480 --> 00:10:08,880
enumeration tree that are unlikely to

280
00:10:08,880 --> 00:10:11,279
lead to short vectors

281
00:10:11,279 --> 00:10:12,720
there are many different approaches to

282
00:10:12,720 --> 00:10:14,640
pruning but the most popular one is

283
00:10:14,640 --> 00:10:16,720
referred to as extreme pruning and this

284
00:10:16,720 --> 00:10:18,560
can provide a speed up that is

285
00:10:18,560 --> 00:10:20,320
exponential in the dimension of the

286
00:10:20,320 --> 00:10:21,680
lattice

287
00:10:21,680 --> 00:10:23,279
we'll come back to how extreme pruning

288
00:10:23,279 --> 00:10:26,000
works later but the idea is that one

289
00:10:26,000 --> 00:10:28,480
sets a parameter that is rather

290
00:10:28,480 --> 00:10:29,440
aggressive

291
00:10:29,440 --> 00:10:32,880
so you expect to cut many many parts

292
00:10:32,880 --> 00:10:34,880
and whilst this drops your success

293
00:10:34,880 --> 00:10:36,959
probability exponentially

294
00:10:36,959 --> 00:10:39,279
the cost of re-randomizing your basis

295
00:10:39,279 --> 00:10:41,440
and then running pruning over that basis

296
00:10:41,440 --> 00:10:42,560
again

297
00:10:42,560 --> 00:10:44,800
is cheaper than

298
00:10:44,800 --> 00:10:47,200
the speed up the one oh sorry it's less

299
00:10:47,200 --> 00:10:48,640
expensive than the speed up that one

300
00:10:48,640 --> 00:10:50,880
gets and thus you still end up with a

301
00:10:50,880 --> 00:10:52,480
speed up even though you're going

302
00:10:52,480 --> 00:10:55,040
through this process of

303
00:10:55,040 --> 00:10:57,760
randomizing the basis re-reducing it and

304
00:10:57,760 --> 00:11:00,000
then running an extreme enumeration over

305
00:11:00,000 --> 00:11:02,079
it

306
00:11:02,399 --> 00:11:04,560
now there are other approaches to this

307
00:11:04,560 --> 00:11:07,680
problem and a rather natural one is to

308
00:11:07,680 --> 00:11:10,160
merely loosen the requirements on the

309
00:11:10,160 --> 00:11:11,279
solution

310
00:11:11,279 --> 00:11:13,279
so in particular

311
00:11:13,279 --> 00:11:16,160
it may be wise to accept a longer vector

312
00:11:16,160 --> 00:11:19,120
from our enumeration oracle

313
00:11:19,120 --> 00:11:22,079
we refer to this process as relaxation

314
00:11:22,079 --> 00:11:24,240
and so to give you an example

315
00:11:24,240 --> 00:11:26,720
we might accept a vector that is at most

316
00:11:26,720 --> 00:11:29,200
a factor alpha which where alpha is some

317
00:11:29,200 --> 00:11:31,040
constant greater than one

318
00:11:31,040 --> 00:11:32,959
longer than is predicted by the gaussian

319
00:11:32,959 --> 00:11:34,800
heuristic

320
00:11:34,800 --> 00:11:36,560
this was recently studied by lion and

321
00:11:36,560 --> 00:11:37,360
nguyen

322
00:11:37,360 --> 00:11:39,200
and they showed that if one of relaxes

323
00:11:39,200 --> 00:11:41,680
enumeration inside bkz

324
00:11:41,680 --> 00:11:43,600
then you can get a speed up of around

325
00:11:43,600 --> 00:11:47,040
four alpha squared times one minus rho

326
00:11:47,040 --> 00:11:49,680
all to the power of k divided by four

327
00:11:49,680 --> 00:11:51,440
where rho here denotes a pruning

328
00:11:51,440 --> 00:11:54,240
parameter in the range zero to one

329
00:11:54,240 --> 00:11:56,720
as rho approaches zero the pruning

330
00:11:56,720 --> 00:11:58,399
becomes more aggressive

331
00:11:58,399 --> 00:12:01,279
but the speed up also increases

332
00:12:01,279 --> 00:12:03,120
one disadvantage here though is that

333
00:12:03,120 --> 00:12:05,680
we're accepting a vector that is further

334
00:12:05,680 --> 00:12:07,680
away from being ideal

335
00:12:07,680 --> 00:12:09,519
and this can lead to our final basis

336
00:12:09,519 --> 00:12:12,160
being less strongly reduced

337
00:12:12,160 --> 00:12:13,920
and so the approach we take in this work

338
00:12:13,920 --> 00:12:15,279
is we ask

339
00:12:15,279 --> 00:12:17,440
what happens if we increase the size of

340
00:12:17,440 --> 00:12:18,639
the blocks

341
00:12:18,639 --> 00:12:20,880
to accommodate the loss in quality that

342
00:12:20,880 --> 00:12:22,800
we get by using these approximate

343
00:12:22,800 --> 00:12:25,040
oracles

344
00:12:25,040 --> 00:12:27,200
so as before we'll let alpha denote the

345
00:12:27,200 --> 00:12:29,279
approximation factor that we're willing

346
00:12:29,279 --> 00:12:31,600
to accept

347
00:12:31,600 --> 00:12:33,760
our approach is to replace enumeration

348
00:12:33,760 --> 00:12:35,680
in block size k

349
00:12:35,680 --> 00:12:37,360
by enumeration

350
00:12:37,360 --> 00:12:39,600
across a block of this of sides the

351
00:12:39,600 --> 00:12:41,680
smallest integer greater than k which we

352
00:12:41,680 --> 00:12:43,920
do know is k alpha

353
00:12:43,920 --> 00:12:45,519
in particular this k alpha should be

354
00:12:45,519 --> 00:12:48,000
chosen such that the root hermite factor

355
00:12:48,000 --> 00:12:50,240
does not increase

356
00:12:50,240 --> 00:12:52,480
in other words we numerically solve

357
00:12:52,480 --> 00:12:54,000
equation two at the bottom of the page

358
00:12:54,000 --> 00:12:56,720
here where we're looking for a value k

359
00:12:56,720 --> 00:12:57,760
alpha

360
00:12:57,760 --> 00:13:00,160
such that when we find a vector of

361
00:13:00,160 --> 00:13:03,519
length alpha times g h of k alpha

362
00:13:03,519 --> 00:13:04,959
normalized

363
00:13:04,959 --> 00:13:06,480
we do not increase the root highlight

364
00:13:06,480 --> 00:13:07,839
factor

365
00:13:07,839 --> 00:13:09,760
and this k can be or this k alpha can be

366
00:13:09,760 --> 00:13:11,600
uniquely determined

367
00:13:11,600 --> 00:13:14,320
the way to solve this is to set

368
00:13:14,320 --> 00:13:16,720
this equation here up as an equality and

369
00:13:16,720 --> 00:13:21,399
then round the value of k alpha

370
00:13:21,920 --> 00:13:24,079
so however our main result for this work

371
00:13:24,079 --> 00:13:25,760
is we show that the speed up from

372
00:13:25,760 --> 00:13:28,079
relaxed enumeration is enough to

373
00:13:28,079 --> 00:13:30,560
overcome the extra cost from increasing

374
00:13:30,560 --> 00:13:33,120
the block size

375
00:13:33,120 --> 00:13:35,200
this speed up holds for both fixed

376
00:13:35,200 --> 00:13:37,760
pruning parameters i.e when we choose

377
00:13:37,760 --> 00:13:38,880
row

378
00:13:38,880 --> 00:13:40,800
and the numerically optimized pruning

379
00:13:40,800 --> 00:13:42,880
parameters that are chosen by the fpi

380
00:13:42,880 --> 00:13:44,560
lll library

381
00:13:44,560 --> 00:13:47,199
for those of you who are unaware fpll is

382
00:13:47,199 --> 00:13:49,199
a lattice reduction library that's been

383
00:13:49,199 --> 00:13:50,959
used in many different cryptographic

384
00:13:50,959 --> 00:13:51,839
works

385
00:13:51,839 --> 00:13:53,760
and one of its crucial features is that

386
00:13:53,760 --> 00:13:55,519
it sports a

387
00:13:55,519 --> 00:13:57,760
numerically optimized pruner

388
00:13:57,760 --> 00:14:00,639
the given sum basis will compute optimal

389
00:14:00,639 --> 00:14:03,920
pruning parameters for speed and quality

390
00:14:03,920 --> 00:14:07,040
and success probability

391
00:14:07,519 --> 00:14:09,680
just to go into more detail quickly

392
00:14:09,680 --> 00:14:12,800
if we assume the enumeration in rank k

393
00:14:12,800 --> 00:14:15,760
costs 2 to the power of c 0 k

394
00:14:15,760 --> 00:14:17,040
times log k

395
00:14:17,040 --> 00:14:20,560
plus c 1 k plus c 2 many polynomial time

396
00:14:20,560 --> 00:14:23,519
operations where c 0 c 1 and c 2 are

397
00:14:23,519 --> 00:14:25,440
just some constants

398
00:14:25,440 --> 00:14:28,639
then if we have some fixed parameter rho

399
00:14:28,639 --> 00:14:32,720
we can solve alpha gh k alpha hsvp in

400
00:14:32,720 --> 00:14:34,800
rank k alpha

401
00:14:34,800 --> 00:14:38,880
faster than solving ghk alpha hs6p

402
00:14:38,880 --> 00:14:42,000
in rank a by a factor of at least

403
00:14:42,000 --> 00:14:44,560
equation three

404
00:14:44,560 --> 00:14:45,920
just to guide you through this a little

405
00:14:45,920 --> 00:14:48,079
bit it's the term on the left-hand side

406
00:14:48,079 --> 00:14:49,760
that really matters here

407
00:14:49,760 --> 00:14:52,320
so it says alpha to the power of a half

408
00:14:52,320 --> 00:14:56,079
minus z zero eta k

409
00:14:56,079 --> 00:14:58,399
here eta is some parameter

410
00:14:58,399 --> 00:15:00,720
that is inside this range here but you

411
00:15:00,720 --> 00:15:02,399
can see that this really isn't as

412
00:15:02,399 --> 00:15:04,320
important as

413
00:15:04,320 --> 00:15:06,240
the alpha to the power of k term

414
00:15:06,240 --> 00:15:07,120
essentially that we have at the

415
00:15:07,120 --> 00:15:09,040
beginning

416
00:15:09,040 --> 00:15:11,440
our proof technique works

417
00:15:11,440 --> 00:15:13,920
by showing that we have a band on how

418
00:15:13,920 --> 00:15:17,199
large k alpha can be compared to k

419
00:15:17,199 --> 00:15:19,600
so in particular we don't expect k alpha

420
00:15:19,600 --> 00:15:22,480
to be much larger than k

421
00:15:22,480 --> 00:15:26,079
and as a result we can make some

422
00:15:26,079 --> 00:15:27,839
we can prove some term or some

423
00:15:27,839 --> 00:15:29,360
inequalities

424
00:15:29,360 --> 00:15:30,800
based on

425
00:15:30,800 --> 00:15:33,920
how large the enumeration tree will be

426
00:15:33,920 --> 00:15:36,880
for k alpha relative to enumeration in

427
00:15:36,880 --> 00:15:39,360
rank k

428
00:15:39,360 --> 00:15:41,040
so just to show you some results quickly

429
00:15:41,040 --> 00:15:42,720
about how this works

430
00:15:42,720 --> 00:15:45,839
so in this table we have this term here

431
00:15:45,839 --> 00:15:47,360
t alpha

432
00:15:47,360 --> 00:15:52,000
which denotes the time for solving

433
00:15:52,839 --> 00:15:54,480
alpha

434
00:15:54,480 --> 00:15:58,480
hsvp in rank k alpha and t1 is the time

435
00:15:58,480 --> 00:16:01,680
that it takes us to solve gh svp in rank

436
00:16:01,680 --> 00:16:02,880
k

437
00:16:02,880 --> 00:16:04,560
and we've just chosen some fixed pruning

438
00:16:04,560 --> 00:16:08,800
parameter here rho which equals 0.01

439
00:16:08,800 --> 00:16:10,639
in this table you can see that we have

440
00:16:10,639 --> 00:16:12,880
an alpha term on the left hand side that

441
00:16:12,880 --> 00:16:14,399
just shows

442
00:16:14,399 --> 00:16:16,000
the results for differing values of

443
00:16:16,000 --> 00:16:16,959
alpha

444
00:16:16,959 --> 00:16:18,399
and then in the middle of this table

445
00:16:18,399 --> 00:16:19,360
here

446
00:16:19,360 --> 00:16:22,720
you can see both the time complexities

447
00:16:22,720 --> 00:16:27,199
for running enumeration in

448
00:16:27,199 --> 00:16:31,120
rank k alpha with alpha ghhsp

449
00:16:31,120 --> 00:16:33,360
and how this compares to the baseline in

450
00:16:33,360 --> 00:16:35,519
the third column

451
00:16:35,519 --> 00:16:37,360
you can see here that we get a

452
00:16:37,360 --> 00:16:39,839
exponential speed up as alpha increases

453
00:16:39,839 --> 00:16:41,519
which is exactly what our previous

454
00:16:41,519 --> 00:16:43,040
theorem showed

455
00:16:43,040 --> 00:16:45,519
but crucially this yet this does not yet

456
00:16:45,519 --> 00:16:47,600
approach the state of the art

457
00:16:47,600 --> 00:16:50,160
so as i previously mentioned the leading

458
00:16:50,160 --> 00:16:53,519
term in the state of the art is

459
00:16:53,519 --> 00:16:56,000
k log k divided by 8 whereas here we

460
00:16:56,000 --> 00:16:58,880
have k log k divided by 2 e

461
00:16:58,880 --> 00:17:00,560
and this second term as well is

462
00:17:00,560 --> 00:17:02,000
undesirable

463
00:17:02,000 --> 00:17:03,680
simply because the approach of extreme

464
00:17:03,680 --> 00:17:04,799
pruning

465
00:17:04,799 --> 00:17:07,520
in practice provides a larger second

466
00:17:07,520 --> 00:17:09,280
term

467
00:17:09,280 --> 00:17:11,199
so the natural question now is whether

468
00:17:11,199 --> 00:17:12,959
we can do better

469
00:17:12,959 --> 00:17:15,760
and the answer is yes you can

470
00:17:15,760 --> 00:17:17,359
so firstly

471
00:17:17,359 --> 00:17:19,520
a reasonable approach is to try and use

472
00:17:19,520 --> 00:17:22,799
fpll to compute the pruning parameters

473
00:17:22,799 --> 00:17:24,559
because it may well be that for some

474
00:17:24,559 --> 00:17:26,160
fixed value row

475
00:17:26,160 --> 00:17:27,919
the pruning parameters that are chosen

476
00:17:27,919 --> 00:17:30,160
are not optimal

477
00:17:30,160 --> 00:17:32,240
and secondly we can also try to

478
00:17:32,240 --> 00:17:33,760
integrate the super exponential

479
00:17:33,760 --> 00:17:34,960
improvements

480
00:17:34,960 --> 00:17:36,720
from this work that's cited here at the

481
00:17:36,720 --> 00:17:37,679
bottom

482
00:17:37,679 --> 00:17:40,400
which i'll refer to as abf plus 20 for

483
00:17:40,400 --> 00:17:42,400
the rest of this presentation

484
00:17:42,400 --> 00:17:44,880
the crucial part of that abf plus 20 is

485
00:17:44,880 --> 00:17:47,200
that they provide an algorithm that does

486
00:17:47,200 --> 00:17:49,200
achieve the state of the art with a

487
00:17:49,200 --> 00:17:51,520
leading one over eight term

488
00:17:51,520 --> 00:17:53,520
and thankfully these ideas appear to be

489
00:17:53,520 --> 00:17:56,080
somewhat orthogonal and we found that we

490
00:17:56,080 --> 00:17:58,480
can achieve a speed up over the state of

491
00:17:58,480 --> 00:18:00,880
the r when using numerically optimal

492
00:18:00,880 --> 00:18:03,120
pruning practice and the improvements

493
00:18:03,120 --> 00:18:05,919
from abf plus 20 whilst achieving the

494
00:18:05,919 --> 00:18:08,799
same root permanent factor

495
00:18:08,799 --> 00:18:11,280
so here we have some simulated costs for

496
00:18:11,280 --> 00:18:13,919
achieving the same root hermite factor

497
00:18:13,919 --> 00:18:16,720
which in particular is k to the power of

498
00:18:16,720 --> 00:18:19,120
1 over 2k

499
00:18:19,120 --> 00:18:21,520
and so you can see here the simulated

500
00:18:21,520 --> 00:18:23,360
costs with our line fit

501
00:18:23,360 --> 00:18:26,720
that if we have out 3 equals 1.05 we end

502
00:18:26,720 --> 00:18:30,000
up with a cost of k log k divided by 8

503
00:18:30,000 --> 00:18:31,000
minus

504
00:18:31,000 --> 00:18:32,880
0.596 k

505
00:18:32,880 --> 00:18:35,120
plus 12.09

506
00:18:35,120 --> 00:18:37,600
and we have a similar cost for alpha

507
00:18:37,600 --> 00:18:38,720
equals

508
00:18:38,720 --> 00:18:42,880
1.2 but you'll notice that the

509
00:18:42,880 --> 00:18:45,360
the coefficient in front of the lower

510
00:18:45,360 --> 00:18:47,120
order k term here

511
00:18:47,120 --> 00:18:49,520
has decreased and so we have achieved an

512
00:18:49,520 --> 00:18:52,559
exponential speed up

513
00:18:53,120 --> 00:18:55,600
but of course we also need to be careful

514
00:18:55,600 --> 00:18:58,000
because as i've previously mentioned

515
00:18:58,000 --> 00:18:59,760
when we

516
00:18:59,760 --> 00:19:02,320
relax enumeration we can end up with a

517
00:19:02,320 --> 00:19:03,919
lower cost oh sorry a lower quality

518
00:19:03,919 --> 00:19:05,200
solution

519
00:19:05,200 --> 00:19:07,039
and the way we do this is we increase

520
00:19:07,039 --> 00:19:09,200
the rank of our enumeration oracles

521
00:19:09,200 --> 00:19:11,520
inside bkz

522
00:19:11,520 --> 00:19:13,600
in particular we define a new bkz

523
00:19:13,600 --> 00:19:16,400
variant that extends the bkz variant

524
00:19:16,400 --> 00:19:20,160
from abf20 or abf plus 20 sorry

525
00:19:20,160 --> 00:19:22,400
simply by adding alpha as an additional

526
00:19:22,400 --> 00:19:24,080
parameter

527
00:19:24,080 --> 00:19:26,559
as a further speed up we also used our

528
00:19:26,559 --> 00:19:27,840
relaxed oracles during the

529
00:19:27,840 --> 00:19:29,760
pre-processing stage when it's

530
00:19:29,760 --> 00:19:31,919
advantageous to do so

531
00:19:31,919 --> 00:19:34,320
the subtlety here is that when one

532
00:19:34,320 --> 00:19:36,160
preprocesses a block

533
00:19:36,160 --> 00:19:39,440
it is typical to shrink the block size

534
00:19:39,440 --> 00:19:43,280
quite a bit so as a if you're solving uh

535
00:19:43,280 --> 00:19:44,640
if you're pre-processing a block by

536
00:19:44,640 --> 00:19:46,160
using bkz

537
00:19:46,160 --> 00:19:48,640
if you shrink the block size too much

538
00:19:48,640 --> 00:19:51,600
relaxation may no longer benefit you

539
00:19:51,600 --> 00:19:54,160
and as a result when it is no longer

540
00:19:54,160 --> 00:19:56,400
advantageous to do so we simply use the

541
00:19:56,400 --> 00:19:58,160
default setting

542
00:19:58,160 --> 00:20:00,400
but when it is advantageous to do so we

543
00:20:00,400 --> 00:20:02,960
use these relaxed oracles

544
00:20:02,960 --> 00:20:06,480
there are lots of parameters that can be

545
00:20:06,480 --> 00:20:09,919
customized in this bkz variant and so to

546
00:20:09,919 --> 00:20:12,400
avoid going into detail here we provide

547
00:20:12,400 --> 00:20:14,240
a full table of configurations in the

548
00:20:14,240 --> 00:20:16,240
paper

549
00:20:16,240 --> 00:20:18,559
so this is just to show how

550
00:20:18,559 --> 00:20:21,919
this work and abf plus 20 have moved the

551
00:20:21,919 --> 00:20:25,280
state-of-the-art in the last few years

552
00:20:25,280 --> 00:20:28,000
so as reported in abf plus 20

553
00:20:28,000 --> 00:20:31,280
the running time provided by the fplo

554
00:20:31,280 --> 00:20:32,320
library

555
00:20:32,320 --> 00:20:35,520
achieves time k log k divided by 2 e

556
00:20:35,520 --> 00:20:40,400
minus 0.995 k plus 16.25

557
00:20:40,400 --> 00:20:43,280
abf plus 20 from last year achieves a

558
00:20:43,280 --> 00:20:46,320
running time of k log k divided by 8

559
00:20:46,320 --> 00:20:48,960
minus 0.54 k

560
00:20:48,960 --> 00:20:50,880
plus 10.4

561
00:20:50,880 --> 00:20:52,720
and in this work we do not move the

562
00:20:52,720 --> 00:20:54,720
leading term at all but we do

563
00:20:54,720 --> 00:20:56,880
exponentially accelerate the enumeration

564
00:20:56,880 --> 00:20:57,919
oracle

565
00:20:57,919 --> 00:20:58,880
by

566
00:20:58,880 --> 00:21:00,720
increasing this second term here also

567
00:21:00,720 --> 00:21:02,480
decreasing the second term here

568
00:21:02,480 --> 00:21:03,320
from

569
00:21:03,320 --> 00:21:08,080
0.547 k to 0.654 k

570
00:21:08,080 --> 00:21:10,480
this is all for achieving a root hermite

571
00:21:10,480 --> 00:21:12,000
factor of

572
00:21:12,000 --> 00:21:15,520
k to the power of 1 over 2k so this is

573
00:21:15,520 --> 00:21:17,520
exactly what we would expect for bkz

574
00:21:17,520 --> 00:21:19,840
asymptotically

575
00:21:19,840 --> 00:21:22,320
you can see here in this graph

576
00:21:22,320 --> 00:21:25,520
that we have managed to lower the cost

577
00:21:25,520 --> 00:21:27,360
of

578
00:21:27,360 --> 00:21:29,280
achieving lattice reduction in certain

579
00:21:29,280 --> 00:21:30,720
positions

580
00:21:30,720 --> 00:21:33,280
so for example if you consider two to

581
00:21:33,280 --> 00:21:36,400
the 256 operations you'll notice that

582
00:21:36,400 --> 00:21:38,320
our work moves the crossover point to

583
00:21:38,320 --> 00:21:39,520
around

584
00:21:39,520 --> 00:21:41,200
rank 500

585
00:21:41,200 --> 00:21:43,440
whereas just two years ago it was around

586
00:21:43,440 --> 00:21:45,280
about rank 400

587
00:21:45,280 --> 00:21:48,400
and indeed we make a larger improvement

588
00:21:48,400 --> 00:21:50,640
compared to abf plus 20

589
00:21:50,640 --> 00:21:53,919
versus abf plus 20 against the baseline

590
00:21:53,919 --> 00:21:57,440
provided by fpll

591
00:21:57,600 --> 00:22:00,640
there is a following uh takeaway from

592
00:22:00,640 --> 00:22:01,760
this

593
00:22:01,760 --> 00:22:03,679
and that is is that this work does not

594
00:22:03,679 --> 00:22:06,080
utilize the regular re-randomization

595
00:22:06,080 --> 00:22:08,559
provided by extreme pruning

596
00:22:08,559 --> 00:22:10,720
so as i mentioned earlier on extreme

597
00:22:10,720 --> 00:22:13,120
pruning has this

598
00:22:13,120 --> 00:22:14,320
property

599
00:22:14,320 --> 00:22:16,000
where one aggressively sets pruning

600
00:22:16,000 --> 00:22:18,640
parameters and if a solution is not

601
00:22:18,640 --> 00:22:19,520
found

602
00:22:19,520 --> 00:22:22,159
one re-randomizes the basis and then

603
00:22:22,159 --> 00:22:24,240
repeats the process

604
00:22:24,240 --> 00:22:26,400
our work doesn't do this

605
00:22:26,400 --> 00:22:28,320
and in particular we believe that this

606
00:22:28,320 --> 00:22:30,720
is due to the expensive pre-processing

607
00:22:30,720 --> 00:22:32,799
that we need to ensure that our

608
00:22:32,799 --> 00:22:35,200
algorithm works

609
00:22:35,200 --> 00:22:38,400
so we may yet find further speed ups

610
00:22:38,400 --> 00:22:40,080
if it is possible to find a way to

611
00:22:40,080 --> 00:22:42,240
reconcile these strategies

612
00:22:42,240 --> 00:22:44,400
if pre-processing can somehow be

613
00:22:44,400 --> 00:22:46,559
preserved whilst doing this regularly

614
00:22:46,559 --> 00:22:48,000
randomization

615
00:22:48,000 --> 00:22:49,840
then it may be that a further speed up

616
00:22:49,840 --> 00:22:53,280
is possible compared to our approach

617
00:22:53,280 --> 00:22:56,080
and so just to demonstrate this

618
00:22:56,080 --> 00:22:57,440
viral graph

619
00:22:57,440 --> 00:22:59,280
you can see here that the expected

620
00:22:59,280 --> 00:23:01,840
number of solutions and thus the success

621
00:23:01,840 --> 00:23:05,520
probability is roughly constant as the

622
00:23:05,520 --> 00:23:08,159
dimension of the lattice increases so

623
00:23:08,159 --> 00:23:09,919
you can see that it roughly holds around

624
00:23:09,919 --> 00:23:11,760
one with some noise

625
00:23:11,760 --> 00:23:12,720
and this

626
00:23:12,720 --> 00:23:16,000
is the same for all values of alpha

627
00:23:16,000 --> 00:23:17,360
this is

628
00:23:17,360 --> 00:23:19,120
essentially a proxy measurement for the

629
00:23:19,120 --> 00:23:20,720
success probability

630
00:23:20,720 --> 00:23:22,480
because we would expect the expected

631
00:23:22,480 --> 00:23:25,120
number of solutions to decrease

632
00:23:25,120 --> 00:23:26,880
as the rank increases

633
00:23:26,880 --> 00:23:29,039
because the success probability goes

634
00:23:29,039 --> 00:23:30,080
down

635
00:23:30,080 --> 00:23:32,320
that is not what we observe here

636
00:23:32,320 --> 00:23:35,520
and so there still may be some speed ups

637
00:23:35,520 --> 00:23:37,600
by forcing this number of solutions to

638
00:23:37,600 --> 00:23:38,640
decrease

639
00:23:38,640 --> 00:23:40,960
as we increase the rank but despite all

640
00:23:40,960 --> 00:23:42,080
of this

641
00:23:42,080 --> 00:23:44,640
this work does not invalidate any

642
00:23:44,640 --> 00:23:47,919
existing nist security claims

643
00:23:47,919 --> 00:23:50,159
although we may have moved the crossover

644
00:23:50,159 --> 00:23:51,840
for enumeration

645
00:23:51,840 --> 00:23:54,799
for two to the 256 operations

646
00:23:54,799 --> 00:23:58,320
from rank 400 to rank 500-ish

647
00:23:58,320 --> 00:24:00,640
the singly exponential sieving is still

648
00:24:00,640 --> 00:24:03,200
far faster than enumeration

649
00:24:03,200 --> 00:24:05,360
and none of the speed ups in this work

650
00:24:05,360 --> 00:24:08,320
are enough to lower any security claims

651
00:24:08,320 --> 00:24:11,840
for any of the nist based crypto systems

652
00:24:11,840 --> 00:24:13,360
with that i would like to say thank you

653
00:24:13,360 --> 00:24:15,039
for your attention and i look forward to

654
00:24:15,039 --> 00:24:16,400
answering any questions you might have

655
00:24:16,400 --> 00:24:19,039
on zealand

