1
00:00:02,960 --> 00:00:04,720
hello and welcome

2
00:00:04,720 --> 00:00:07,680
i'm gayathri garimella from oregon state

3
00:00:07,680 --> 00:00:10,240
university and i'm really happy to be

4
00:00:10,240 --> 00:00:11,920
presenting our work

5
00:00:11,920 --> 00:00:14,400
oblivious key value stores and

6
00:00:14,400 --> 00:00:16,400
amplification for private set

7
00:00:16,400 --> 00:00:18,000
intersection

8
00:00:18,000 --> 00:00:19,920
this is joint work with my wonderful

9
00:00:19,920 --> 00:00:21,199
co-authors

10
00:00:21,199 --> 00:00:24,720
benny pinkas my advisor mike roslich

11
00:00:24,720 --> 00:00:27,599
neets you and avishai yanai

12
00:00:27,599 --> 00:00:31,039
let's get started

13
00:00:31,039 --> 00:00:33,200
in private set intersection

14
00:00:33,200 --> 00:00:36,079
alice and bob each have a private set of

15
00:00:36,079 --> 00:00:38,000
items as input

16
00:00:38,000 --> 00:00:40,960
they can use a psi protocol to learn

17
00:00:40,960 --> 00:00:42,960
items they have in common

18
00:00:42,960 --> 00:00:45,920
here bob who learns the output learns

19
00:00:45,920 --> 00:00:49,760
the intersection items namely letters t

20
00:00:49,760 --> 00:00:52,559
a and l and learns nothing else about

21
00:00:52,559 --> 00:00:55,360
alice's set

22
00:00:56,719 --> 00:00:59,359
in a large number of psi protocols you

23
00:00:59,359 --> 00:01:02,160
encounter the following scenario

24
00:01:02,160 --> 00:01:04,799
alice has a function f

25
00:01:04,799 --> 00:01:07,119
for most keys she doesn't care what this

26
00:01:07,119 --> 00:01:09,360
function evaluates to

27
00:01:09,360 --> 00:01:12,080
for a small number of keys she wishes to

28
00:01:12,080 --> 00:01:14,560
convey a specially crafted random value

29
00:01:14,560 --> 00:01:16,240
to bob

30
00:01:16,240 --> 00:01:18,799
this small set of keys depend on her

31
00:01:18,799 --> 00:01:21,680
input and she wants to keep this private

32
00:01:21,680 --> 00:01:24,400
so the goal is for alice to compactly

33
00:01:24,400 --> 00:01:26,720
convey this function to bob while

34
00:01:26,720 --> 00:01:29,280
ensuring that bob can't distinguish if

35
00:01:29,280 --> 00:01:31,600
he is evaluating f on one of these

36
00:01:31,600 --> 00:01:35,839
special keys or a key outside of it

37
00:01:36,720 --> 00:01:39,119
in psi and related applications that we

38
00:01:39,119 --> 00:01:42,000
consider the values associated with the

39
00:01:42,000 --> 00:01:44,799
keys are uniformly random

40
00:01:44,799 --> 00:01:46,880
so they end up using polynomials for

41
00:01:46,880 --> 00:01:49,520
their task of conveying key value pairs

42
00:01:49,520 --> 00:01:51,680
while hiding keys

43
00:01:51,680 --> 00:01:53,920
polynomials have the property that when

44
00:01:53,920 --> 00:01:55,600
you interpolate through values that are

45
00:01:55,600 --> 00:01:58,640
random the resulting polynomial f is

46
00:01:58,640 --> 00:02:01,200
uniformly random and ends up hiding the

47
00:02:01,200 --> 00:02:04,159
special keys for someone evaluating it

48
00:02:04,159 --> 00:02:06,640
we see polynomials used to obliviously

49
00:02:06,640 --> 00:02:09,280
store key value pairs in a host of psi

50
00:02:09,280 --> 00:02:11,679
papers

51
00:02:12,239 --> 00:02:15,040
in this paper we formalize and study the

52
00:02:15,040 --> 00:02:17,680
general notion of oblivious key value

53
00:02:17,680 --> 00:02:20,400
stores as a data structure to convey key

54
00:02:20,400 --> 00:02:22,640
value pairs obliviously

55
00:02:22,640 --> 00:02:24,239
we catalog various existing

56
00:02:24,239 --> 00:02:27,280
constructions including polynomials that

57
00:02:27,280 --> 00:02:30,560
could classify as an okvs

58
00:02:30,560 --> 00:02:33,440
in particular in the psi context we

59
00:02:33,440 --> 00:02:36,640
looked at the paxos data structure

60
00:02:36,640 --> 00:02:38,239
which was used to build the most

61
00:02:38,239 --> 00:02:41,040
efficient malicious secure psi in prty

62
00:02:41,040 --> 00:02:42,400
20.

63
00:02:42,400 --> 00:02:45,440
pack source is a binary okvs that uses

64
00:02:45,440 --> 00:02:47,519
the analysis of coco hashing with two

65
00:02:47,519 --> 00:02:49,680
hash functions

66
00:02:49,680 --> 00:02:52,560
psi protocols need cuckoo hashing to

67
00:02:52,560 --> 00:02:54,480
work with except with negligible failure

68
00:02:54,480 --> 00:02:55,840
probability

69
00:02:55,840 --> 00:02:57,680
something of the order of 2 to the minus

70
00:02:57,680 --> 00:02:59,280
40.

71
00:02:59,280 --> 00:03:01,599
the paxos paper describes an asymptotic

72
00:03:01,599 --> 00:03:03,519
analysis of the cuckoo hashing

73
00:03:03,519 --> 00:03:04,800
parameters

74
00:03:04,800 --> 00:03:07,360
but it remains non-trivial to translate

75
00:03:07,360 --> 00:03:09,920
them into concrete parameters needed to

76
00:03:09,920 --> 00:03:12,400
instantiate psi in practice

77
00:03:12,400 --> 00:03:14,480
they rely on heuristics to instantiate

78
00:03:14,480 --> 00:03:17,599
the psi protocol

79
00:03:17,760 --> 00:03:20,560
our goal is to build a more efficient ok

80
00:03:20,560 --> 00:03:23,040
vs with cuckoo hashing using three hash

81
00:03:23,040 --> 00:03:24,239
functions

82
00:03:24,239 --> 00:03:27,040
which is known to be much more efficient

83
00:03:27,040 --> 00:03:27,920
again

84
00:03:27,920 --> 00:03:29,280
we are not equipped to determine the

85
00:03:29,280 --> 00:03:31,120
tight concrete bounds for negligible

86
00:03:31,120 --> 00:03:33,200
failure probability

87
00:03:33,200 --> 00:03:35,760
our first construction is to extrapolate

88
00:03:35,760 --> 00:03:38,080
the parameters of back source and design

89
00:03:38,080 --> 00:03:40,000
a binary ok vs using three hash

90
00:03:40,000 --> 00:03:42,000
functions

91
00:03:42,000 --> 00:03:44,319
however we would still like empirical

92
00:03:44,319 --> 00:03:47,120
confidence for our chosen parameters

93
00:03:47,120 --> 00:03:49,280
but empirically verifying negligible

94
00:03:49,280 --> 00:03:51,360
failure probabilities like 2 to the

95
00:03:51,360 --> 00:03:54,480
minus 40 is infeasible

96
00:03:54,480 --> 00:03:56,640
our next contribution is to show some

97
00:03:56,640 --> 00:03:59,040
amplification techniques

98
00:03:59,040 --> 00:04:00,879
note that we can easily measure failure

99
00:04:00,879 --> 00:04:02,640
probabilities of the order 2 to the

100
00:04:02,640 --> 00:04:05,680
minus 15 even on our personal laptops

101
00:04:05,680 --> 00:04:08,720
we design methods to use an okvs with a

102
00:04:08,720 --> 00:04:11,439
fairly large probability and convert it

103
00:04:11,439 --> 00:04:14,400
into an occavious with negligible error

104
00:04:14,400 --> 00:04:17,440
so for so for some constant c we show

105
00:04:17,440 --> 00:04:20,798
how to compose ok vs with error p into

106
00:04:20,798 --> 00:04:23,440
an ok vs with error p to the c with

107
00:04:23,440 --> 00:04:25,040
minimal overhead

108
00:04:25,040 --> 00:04:27,280
thus we're probably amplifying the

109
00:04:27,280 --> 00:04:28,960
failure probability

110
00:04:28,960 --> 00:04:33,280
of an empirically verified okvs

111
00:04:33,680 --> 00:04:35,840
this allows us to choose our concrete

112
00:04:35,840 --> 00:04:38,639
parameters for our okvs with cuckoo

113
00:04:38,639 --> 00:04:41,280
hashing with three hash functions

114
00:04:41,280 --> 00:04:44,000
finally we show that our improved ok vs

115
00:04:44,000 --> 00:04:46,080
gives us the fastest malicious two-party

116
00:04:46,080 --> 00:04:49,440
psi protocol on slow and medium networks

117
00:04:49,440 --> 00:04:51,680
by plugging in a better ok vs into the

118
00:04:51,680 --> 00:04:54,400
construction of prty 20.

119
00:04:54,400 --> 00:04:56,960
and we also show many applications where

120
00:04:56,960 --> 00:04:59,199
ok vs can be a plug-in replacement for

121
00:04:59,199 --> 00:05:03,680
polynomials to improve their efficiency

122
00:05:03,840 --> 00:05:07,280
given a set of n key value pairs we can

123
00:05:07,280 --> 00:05:11,120
encode them into an object s later we

124
00:05:11,120 --> 00:05:13,280
can use this data structure s to

125
00:05:13,280 --> 00:05:15,759
retrieve our key value pairs

126
00:05:15,759 --> 00:05:18,080
if we probe or call the decode function

127
00:05:18,080 --> 00:05:20,160
on any of the special keys

128
00:05:20,160 --> 00:05:23,120
it returns the correct associated value

129
00:05:23,120 --> 00:05:26,160
if we probe s on keys outside the set

130
00:05:26,160 --> 00:05:28,160
we learn some value that we don't care

131
00:05:28,160 --> 00:05:29,600
about

132
00:05:29,600 --> 00:05:32,960
when the associated values are random

133
00:05:32,960 --> 00:05:35,120
you cannot distinguish if you probe the

134
00:05:35,120 --> 00:05:38,000
object s on an encoded key or some other

135
00:05:38,000 --> 00:05:39,600
key outside the set

136
00:05:39,600 --> 00:05:43,919
this makes the key value store oblivious

137
00:05:43,919 --> 00:05:45,840
let's look at some properties of an ok

138
00:05:45,840 --> 00:05:47,360
vs

139
00:05:47,360 --> 00:05:49,360
given an ok vss

140
00:05:49,360 --> 00:05:50,800
the first thing that we are interested

141
00:05:50,800 --> 00:05:51,440
in

142
00:05:51,440 --> 00:05:53,919
is that we want to compactly encode the

143
00:05:53,919 --> 00:05:55,840
n key values

144
00:05:55,840 --> 00:05:58,800
so if the ok vs has a size m then we

145
00:05:58,800 --> 00:06:03,440
want m to be as close to n as possible

146
00:06:03,440 --> 00:06:05,120
we can represent the encoding and

147
00:06:05,120 --> 00:06:08,240
decoding of an a okvs in terms of this

148
00:06:08,240 --> 00:06:11,199
matrix multiplication

149
00:06:11,199 --> 00:06:13,440
during encoding we need to determine

150
00:06:13,440 --> 00:06:16,240
what each of the rows of the matrix k

151
00:06:16,240 --> 00:06:16,960
are

152
00:06:16,960 --> 00:06:20,560
each row is associated with one key

153
00:06:20,560 --> 00:06:23,520
then we need to solve for vector s

154
00:06:23,520 --> 00:06:26,400
and a multiplication of k times s will

155
00:06:26,400 --> 00:06:28,319
be the decoding that gives us the set of

156
00:06:28,319 --> 00:06:30,960
values that we're looking for

157
00:06:30,960 --> 00:06:33,360
so it's useful to have some if the

158
00:06:33,360 --> 00:06:37,440
values of the ok vs belong to some field

159
00:06:37,440 --> 00:06:39,840
and the matrix k consists of this

160
00:06:39,840 --> 00:06:42,240
elements of the same field

161
00:06:42,240 --> 00:06:44,960
we end up with a vector s

162
00:06:44,960 --> 00:06:47,360
which is our ok vs which consists of m

163
00:06:47,360 --> 00:06:49,039
field elements

164
00:06:49,039 --> 00:06:52,240
a special case of the linear ok vs is a

165
00:06:52,240 --> 00:06:54,400
binary ok vs

166
00:06:54,400 --> 00:06:57,199
here we restrict that the elements of

167
00:06:57,199 --> 00:07:00,560
matrix k consists of binary values of 0

168
00:07:00,560 --> 00:07:02,400
and 1.

169
00:07:02,400 --> 00:07:04,960
now let's look at some existing examples

170
00:07:04,960 --> 00:07:07,039
of an ok vs

171
00:07:07,039 --> 00:07:10,720
our first example is a polynomial

172
00:07:10,720 --> 00:07:13,599
so we can encode a set of n key value

173
00:07:13,599 --> 00:07:14,639
pairs

174
00:07:14,639 --> 00:07:17,759
into a polynomial say s

175
00:07:17,759 --> 00:07:19,680
that satisfies the constraints of these

176
00:07:19,680 --> 00:07:21,280
key value pairs

177
00:07:21,280 --> 00:07:24,000
that is if you evaluate this polynomial

178
00:07:24,000 --> 00:07:26,400
on key k1 then the result of the

179
00:07:26,400 --> 00:07:30,000
polynomial evaluation is value 1.

180
00:07:30,000 --> 00:07:32,400
to be explicit the coefficients of this

181
00:07:32,400 --> 00:07:33,759
polynomial

182
00:07:33,759 --> 00:07:36,319
form the ok vs

183
00:07:36,319 --> 00:07:38,800
and we can represent the ocvs encoding

184
00:07:38,800 --> 00:07:41,280
and decoding in terms of this matrix

185
00:07:41,280 --> 00:07:42,880
multiplication

186
00:07:42,880 --> 00:07:45,520
to decode a specific key we look at the

187
00:07:45,520 --> 00:07:49,599
row in matrix k associated with that key

188
00:07:49,599 --> 00:07:51,840
we can obtain the right value for that

189
00:07:51,840 --> 00:07:54,639
key by computing the dot product of the

190
00:07:54,639 --> 00:07:56,160
associated row

191
00:07:56,160 --> 00:07:59,520
and the ok vs s

192
00:07:59,520 --> 00:08:01,759
what are the efficiency measures of a

193
00:08:01,759 --> 00:08:05,280
polynomial polynomials are optimal size

194
00:08:05,280 --> 00:08:08,080
so if we encode n key value pairs then

195
00:08:08,080 --> 00:08:09,680
we obtain n coefficients of the

196
00:08:09,680 --> 00:08:11,520
polynomial

197
00:08:11,520 --> 00:08:12,400
however

198
00:08:12,400 --> 00:08:14,319
polynomials have the drawback that the

199
00:08:14,319 --> 00:08:17,120
encoding and decoding time

200
00:08:17,120 --> 00:08:18,960
for n values

201
00:08:18,960 --> 00:08:21,360
requires order n log square n field

202
00:08:21,360 --> 00:08:24,000
operations

203
00:08:24,000 --> 00:08:26,879
the next example is the binary okvs back

204
00:08:26,879 --> 00:08:29,199
source which is also a starting point to

205
00:08:29,199 --> 00:08:33,039
build a more efficient okvs

206
00:08:33,200 --> 00:08:36,399
paxos has hash functions h1 and h2 as

207
00:08:36,399 --> 00:08:37,839
its parameters

208
00:08:37,839 --> 00:08:40,399
i will present a simplified version and

209
00:08:40,399 --> 00:08:42,559
start by showing how to decode or probe

210
00:08:42,559 --> 00:08:44,800
a value from s

211
00:08:44,800 --> 00:08:46,240
for a key a

212
00:08:46,240 --> 00:08:48,640
we look at position given by both the

213
00:08:48,640 --> 00:08:52,320
hash functions namely h1 of a which is 5

214
00:08:52,320 --> 00:08:55,600
in this case and h2 of a which is 1.

215
00:08:55,600 --> 00:08:58,240
we can decode by computing the xor of

216
00:08:58,240 --> 00:08:59,920
the values that are stored in these

217
00:08:59,920 --> 00:09:01,200
positions

218
00:09:01,200 --> 00:09:03,680
so we decode a

219
00:09:03,680 --> 00:09:08,399
so d code of a would be s1 xor s5

220
00:09:08,399 --> 00:09:10,880
we know that paxos needs to encode a set

221
00:09:10,880 --> 00:09:12,240
of keys

222
00:09:12,240 --> 00:09:15,200
so how do we encode many such keys while

223
00:09:15,200 --> 00:09:17,200
ensuring that each of them decodes

224
00:09:17,200 --> 00:09:18,480
correctly

225
00:09:18,480 --> 00:09:20,880
i will show a simple example

226
00:09:20,880 --> 00:09:24,399
suppose you have to encode four keys a b

227
00:09:24,399 --> 00:09:25,440
c d

228
00:09:25,440 --> 00:09:29,519
we use a method called peel then fill

229
00:09:29,519 --> 00:09:33,600
first we compute the hashes h1 and h2 of

230
00:09:33,600 --> 00:09:35,680
all the keys

231
00:09:35,680 --> 00:09:36,880
a b

232
00:09:36,880 --> 00:09:38,560
c and d

233
00:09:38,560 --> 00:09:41,760
next we recursively identify slots that

234
00:09:41,760 --> 00:09:44,399
are constrained by just one key

235
00:09:44,399 --> 00:09:47,040
so here we can see that position 2 is

236
00:09:47,040 --> 00:09:50,000
constrained by key c and position three

237
00:09:50,000 --> 00:09:52,080
is also constrained by just one key

238
00:09:52,080 --> 00:09:54,880
which is key b so when we have multiple

239
00:09:54,880 --> 00:09:58,920
options we can arbitrarily um

240
00:09:58,920 --> 00:10:02,020
[Applause]

241
00:10:04,959 --> 00:10:06,880
when we have more than one option we can

242
00:10:06,880 --> 00:10:09,920
arbitrarily break dice so i will pick

243
00:10:09,920 --> 00:10:13,519
position 2 which is constrained by key c

244
00:10:13,519 --> 00:10:14,560
then

245
00:10:14,560 --> 00:10:16,720
we can delete the constraints associated

246
00:10:16,720 --> 00:10:19,360
with key c

247
00:10:19,360 --> 00:10:23,519
next we identify that position

248
00:10:23,519 --> 00:10:26,079
4 is also constrained by a single key

249
00:10:26,079 --> 00:10:27,440
which is key d

250
00:10:27,440 --> 00:10:28,800
and then delete the constraints

251
00:10:28,800 --> 00:10:30,720
associated with d

252
00:10:30,720 --> 00:10:32,640
now we see that position three is

253
00:10:32,640 --> 00:10:34,959
identified by key b and we have only one

254
00:10:34,959 --> 00:10:37,440
option so we delete the constraints

255
00:10:37,440 --> 00:10:39,200
associated with key b

256
00:10:39,200 --> 00:10:42,480
finally for uh position for key a we

257
00:10:42,480 --> 00:10:44,800
have two positions so we can just delete

258
00:10:44,800 --> 00:10:46,720
this key

259
00:10:46,720 --> 00:10:48,240
once we have successfully peeled the

260
00:10:48,240 --> 00:10:50,320
keys we fill the pack source in a

261
00:10:50,320 --> 00:10:52,160
reverse order

262
00:10:52,160 --> 00:10:55,440
so for key a we have two positions given

263
00:10:55,440 --> 00:10:57,120
by um

264
00:10:57,120 --> 00:11:00,079
slot one and five so we can pick any

265
00:11:00,079 --> 00:11:04,720
values for them as long as s1 xor s5

266
00:11:04,720 --> 00:11:08,480
matches the value of the value of a

267
00:11:08,480 --> 00:11:10,880
next we look at key b

268
00:11:10,880 --> 00:11:13,440
here s5 has already been occupied by a

269
00:11:13,440 --> 00:11:17,200
value so we need to assign s3 as s5 xor

270
00:11:17,200 --> 00:11:19,120
the value of b

271
00:11:19,120 --> 00:11:21,279
we follow a similar process

272
00:11:21,279 --> 00:11:24,959
for key d we notice that s4 is unfilled

273
00:11:24,959 --> 00:11:27,040
and s1 is already been filled so we have

274
00:11:27,040 --> 00:11:31,120
to assign s4 as s1 xor the value of d

275
00:11:31,120 --> 00:11:34,959
finally we plug in the value for slot 2

276
00:11:34,959 --> 00:11:37,519
which is given by s4 xor the value of

277
00:11:37,519 --> 00:11:38,880
value c

278
00:11:38,880 --> 00:11:41,279
so this worked out rather nicely but a

279
00:11:41,279 --> 00:11:44,240
natural question is does encoding always

280
00:11:44,240 --> 00:11:46,480
work

281
00:11:46,480 --> 00:11:48,320
are there any bad events that prevent

282
00:11:48,320 --> 00:11:52,079
the successful encoding of keys

283
00:11:52,560 --> 00:11:54,959
consider a situation like this where no

284
00:11:54,959 --> 00:11:57,600
slot is constrained by a single key

285
00:11:57,600 --> 00:11:59,760
how do we resolve this cycle

286
00:11:59,760 --> 00:12:02,639
in paxos they call the set of all keys

287
00:12:02,639 --> 00:12:05,200
that are not solvable as the two core

288
00:12:05,200 --> 00:12:07,760
here the two core consists of keys a b

289
00:12:07,760 --> 00:12:09,360
and c

290
00:12:09,360 --> 00:12:12,320
in prty 20 they show that if there's a

291
00:12:12,320 --> 00:12:14,560
known a priori bound on the size of the

292
00:12:14,560 --> 00:12:16,720
two core then they describe a method to

293
00:12:16,720 --> 00:12:19,040
resolve it that is they will be success

294
00:12:19,040 --> 00:12:20,880
they'll be able to successfully encode

295
00:12:20,880 --> 00:12:23,200
the n keys but i will not delve into

296
00:12:23,200 --> 00:12:24,720
those details

297
00:12:24,720 --> 00:12:26,880
but the theorem is as follows

298
00:12:26,880 --> 00:12:28,800
if the size of the two core is greater

299
00:12:28,800 --> 00:12:30,880
than log n with less than epsilon

300
00:12:30,880 --> 00:12:32,240
probability

301
00:12:32,240 --> 00:12:34,320
then the increase the size of the pack

302
00:12:34,320 --> 00:12:37,839
source from n to n plus log n plus

303
00:12:37,839 --> 00:12:38,959
lambda

304
00:12:38,959 --> 00:12:41,120
and this allows them to encode n key

305
00:12:41,120 --> 00:12:43,519
successfully except with negligible

306
00:12:43,519 --> 00:12:45,760
error

307
00:12:45,760 --> 00:12:48,480
to reiterate the only bad event that

308
00:12:48,480 --> 00:12:51,279
happens while encoding is when the back

309
00:12:51,279 --> 00:12:53,920
source 2 core overflows that is the size

310
00:12:53,920 --> 00:12:56,240
of 2 core is a greater than the expected

311
00:12:56,240 --> 00:12:57,839
size of log n

312
00:12:57,839 --> 00:12:59,360
and this happens with negligible

313
00:12:59,360 --> 00:13:02,079
probability

314
00:13:02,720 --> 00:13:04,480
one of our main motivations for this

315
00:13:04,480 --> 00:13:06,800
paper is that it's non-trivial to

316
00:13:06,800 --> 00:13:09,440
translate this asymptotic analysis into

317
00:13:09,440 --> 00:13:11,519
concrete parameters while instantiating

318
00:13:11,519 --> 00:13:13,279
psi

319
00:13:13,279 --> 00:13:15,519
in paxos to encode n items with

320
00:13:15,519 --> 00:13:18,480
negligible error they pick a binary okvs

321
00:13:18,480 --> 00:13:21,120
with size 2.4 n

322
00:13:21,120 --> 00:13:23,519
using the analysis of cocoa hashing with

323
00:13:23,519 --> 00:13:25,279
three hash functions we can

324
00:13:25,279 --> 00:13:27,519
heuristically determine that to encode n

325
00:13:27,519 --> 00:13:32,240
items we need around 1.23 n bins

326
00:13:32,240 --> 00:13:35,440
however to have empirical confidence we

327
00:13:35,440 --> 00:13:38,480
would need to verify statements like

328
00:13:38,480 --> 00:13:40,800
except with probability 2 to the minus

329
00:13:40,800 --> 00:13:43,680
40 can we encode using cuckoo hashing

330
00:13:43,680 --> 00:13:45,839
with 3 hash functions

331
00:13:45,839 --> 00:13:49,279
1 million keys into say 1.3 million bins

332
00:13:49,279 --> 00:13:51,519
or slots with less than 10 keys

333
00:13:51,519 --> 00:13:53,839
appearing in the 2 core with confidence

334
00:13:53,839 --> 00:13:56,839
0.9999

335
00:13:56,959 --> 00:13:58,800
running experiments to verify something

336
00:13:58,800 --> 00:14:01,600
like this is very resource intensive

337
00:14:01,600 --> 00:14:03,199
and even after investing millions of

338
00:14:03,199 --> 00:14:04,880
cores of hours it's not feasible to

339
00:14:04,880 --> 00:14:06,240
verify

340
00:14:06,240 --> 00:14:07,279
further

341
00:14:07,279 --> 00:14:09,360
what if you want to use your ok vs in an

342
00:14:09,360 --> 00:14:10,720
application that needs failure

343
00:14:10,720 --> 00:14:13,199
probability say 2 to the minus 80.

344
00:14:13,199 --> 00:14:14,959
certainly you can't experimentally

345
00:14:14,959 --> 00:14:17,199
verify this

346
00:14:17,199 --> 00:14:19,440
so this is our approach

347
00:14:19,440 --> 00:14:22,320
we can verify statements like

348
00:14:22,320 --> 00:14:24,240
except with probability 2 to the minus

349
00:14:24,240 --> 00:14:28,600
15 can we encode using kuku hashing

350
00:14:28,600 --> 00:14:32,800
1000 keys into 1.3 k bins or slots with

351
00:14:32,800 --> 00:14:34,560
less than 10 keys appearing in the two

352
00:14:34,560 --> 00:14:36,800
core with high statistical confidence

353
00:14:36,800 --> 00:14:38,880
say 0.9999

354
00:14:38,880 --> 00:14:41,120
and the answer is yes we can easily

355
00:14:41,120 --> 00:14:43,279
run experiments to verify something like

356
00:14:43,279 --> 00:14:45,760
this even on our personal laptops

357
00:14:45,760 --> 00:14:47,839
so our main idea is

358
00:14:47,839 --> 00:14:49,839
that we want to compose

359
00:14:49,839 --> 00:14:53,040
empirically verified smaller ok vs

360
00:14:53,040 --> 00:14:55,600
into a larger ok vs by probably

361
00:14:55,600 --> 00:14:57,839
amplifying the correctness guarantee

362
00:14:57,839 --> 00:15:00,079
from 2 to the minus 15 to say something

363
00:15:00,079 --> 00:15:02,639
like 2 to the minus 40.

364
00:15:02,639 --> 00:15:04,800
i will now show our first amplification

365
00:15:04,800 --> 00:15:08,240
method called replicated3 hash function

366
00:15:08,240 --> 00:15:10,800
gable cuckoo table

367
00:15:10,800 --> 00:15:13,839
to encode n keys we start with two

368
00:15:13,839 --> 00:15:17,519
instances of ok vs s and s prime

369
00:15:17,519 --> 00:15:20,160
each of these can encode n key value

370
00:15:20,160 --> 00:15:22,800
pairs and s is parameterized by three

371
00:15:22,800 --> 00:15:27,120
hash functions h1 h2 and h3 and s prime

372
00:15:27,120 --> 00:15:28,959
is parameterized by three different hash

373
00:15:28,959 --> 00:15:33,839
functions h1 prime h2 prime and h3 prime

374
00:15:33,839 --> 00:15:35,680
let's see how we would decode such an

375
00:15:35,680 --> 00:15:37,839
architecture

376
00:15:37,839 --> 00:15:40,880
to decode a single key a we start by

377
00:15:40,880 --> 00:15:44,880
computing the hash values h1a h2a h3a

378
00:15:44,880 --> 00:15:46,399
and look at the positions that they

379
00:15:46,399 --> 00:15:48,000
indicate

380
00:15:48,000 --> 00:15:50,959
namely 2 3 and 5 in this case so we

381
00:15:50,959 --> 00:15:53,040
compute the value as

382
00:15:53,040 --> 00:15:57,360
s2 xor s3 xor s5 when we decode a in the

383
00:15:57,360 --> 00:15:59,600
first ok vs

384
00:15:59,600 --> 00:16:01,839
in the second ok vs again we apply the

385
00:16:01,839 --> 00:16:03,920
three different hash functions which

386
00:16:03,920 --> 00:16:06,639
point to locations one three and five

387
00:16:06,639 --> 00:16:09,279
and compute their compute their xor s1

388
00:16:09,279 --> 00:16:13,360
xor s3 xor s4 to obtain the decoding of

389
00:16:13,360 --> 00:16:15,839
a with an s prime

390
00:16:15,839 --> 00:16:18,160
we define the enco decoding of our

391
00:16:18,160 --> 00:16:20,880
replicated kabul cocoa table as

392
00:16:20,880 --> 00:16:22,800
the xor of the d code within the first

393
00:16:22,800 --> 00:16:27,199
ok vs and the second oqps

394
00:16:27,199 --> 00:16:29,360
now let's see how we encode the values

395
00:16:29,360 --> 00:16:32,560
successfully into this ok vs

396
00:16:32,560 --> 00:16:34,880
remember that for each of the individual

397
00:16:34,880 --> 00:16:38,320
ok vs successful encoding depends only

398
00:16:38,320 --> 00:16:40,959
on the keys and the hash functions

399
00:16:40,959 --> 00:16:42,720
in no way is it related to the

400
00:16:42,720 --> 00:16:46,000
associated values of each of the keys

401
00:16:46,000 --> 00:16:48,079
now suppose you want to

402
00:16:48,079 --> 00:16:50,399
encode n key value pairs

403
00:16:50,399 --> 00:16:52,160
and let's focus on one of those key

404
00:16:52,160 --> 00:16:56,880
value pairs namely a and the value of a

405
00:16:57,040 --> 00:16:59,519
we start by testing if s can

406
00:16:59,519 --> 00:17:02,160
successfully encode all the keys or if a

407
00:17:02,160 --> 00:17:04,959
bad event happens without loss of

408
00:17:04,959 --> 00:17:07,839
generality suppose s is unable to encode

409
00:17:07,839 --> 00:17:10,640
all the n keys and it fails

410
00:17:10,640 --> 00:17:14,160
in this case we sample a random okvs of

411
00:17:14,160 --> 00:17:16,000
the size of the okvs

412
00:17:16,000 --> 00:17:18,640
with random field elements like this

413
00:17:18,640 --> 00:17:22,799
with values r1 r2 and so on

414
00:17:23,119 --> 00:17:25,520
and suppose that s prime is successfully

415
00:17:25,520 --> 00:17:28,000
able to encode the same set of n keys

416
00:17:28,000 --> 00:17:29,919
within its ok vs

417
00:17:29,919 --> 00:17:30,720
then

418
00:17:30,720 --> 00:17:33,440
to encode a specific key and its value

419
00:17:33,440 --> 00:17:37,600
we start by probing that key in ok vs s

420
00:17:37,600 --> 00:17:39,520
and we get a setup and we obtain the

421
00:17:39,520 --> 00:17:43,679
value r2 xor r3 xor r5

422
00:17:43,679 --> 00:17:45,280
and this is the correction that we need

423
00:17:45,280 --> 00:17:47,919
to apply within the second ok vs

424
00:17:47,919 --> 00:17:48,799
so

425
00:17:48,799 --> 00:17:52,080
in the second ok vs we encode the key a

426
00:17:52,080 --> 00:17:55,919
with its value xored with r2 xor r3 xor

427
00:17:55,919 --> 00:17:58,240
r5 like this

428
00:17:58,240 --> 00:17:59,360
now

429
00:17:59,360 --> 00:18:02,160
when we decode um the key a in this

430
00:18:02,160 --> 00:18:05,200
replicated uh kabul cocoa table we xor

431
00:18:05,200 --> 00:18:06,960
both these values so that we get the

432
00:18:06,960 --> 00:18:10,160
expected value a now each of these ok

433
00:18:10,160 --> 00:18:13,520
vs's s and s prime assume that they fail

434
00:18:13,520 --> 00:18:15,440
with probability p

435
00:18:15,440 --> 00:18:16,960
the only time this replicated

436
00:18:16,960 --> 00:18:18,960
architecture will be unable to encode

437
00:18:18,960 --> 00:18:22,080
the set of n keys is when both s and s

438
00:18:22,080 --> 00:18:24,720
prime are unable to encode the set of n

439
00:18:24,720 --> 00:18:26,960
keys that is both of them fail

440
00:18:26,960 --> 00:18:29,360
and these are independent events so the

441
00:18:29,360 --> 00:18:31,919
probability that the encoding fails

442
00:18:31,919 --> 00:18:33,919
is p squared

443
00:18:33,919 --> 00:18:36,559
the drawback of this construction is

444
00:18:36,559 --> 00:18:40,160
that we double the size of the ok vs

445
00:18:40,160 --> 00:18:41,600
and we are looking to be more efficient

446
00:18:41,600 --> 00:18:42,960
than that

447
00:18:42,960 --> 00:18:44,799
so our goal is to amplify the failure

448
00:18:44,799 --> 00:18:47,200
probability with minimal increase in the

449
00:18:47,200 --> 00:18:49,679
size of the occavious

450
00:18:49,679 --> 00:18:52,080
i will show a simplified version of our

451
00:18:52,080 --> 00:18:55,039
construction and then generalize it

452
00:18:55,039 --> 00:18:56,320
when i'm presenting the concrete

453
00:18:56,320 --> 00:18:58,559
parameters later

454
00:18:58,559 --> 00:19:01,200
so suppose you want to encode n key

455
00:19:01,200 --> 00:19:02,480
value pairs

456
00:19:02,480 --> 00:19:05,120
you choose a hash function h1 and say

457
00:19:05,120 --> 00:19:08,160
you hash it into three bins

458
00:19:08,160 --> 00:19:09,120
now

459
00:19:09,120 --> 00:19:12,160
you associate a single ok vs with each

460
00:19:12,160 --> 00:19:15,120
of the bins and one ok vs as a central

461
00:19:15,120 --> 00:19:17,120
okvs

462
00:19:17,120 --> 00:19:19,840
and each of these okbs has parameters to

463
00:19:19,840 --> 00:19:25,080
encode n over 3 items and not n items

464
00:19:25,360 --> 00:19:28,160
let's see how we would decode a key a in

465
00:19:28,160 --> 00:19:30,080
this construction

466
00:19:30,080 --> 00:19:32,480
suppose you want to decode a you first

467
00:19:32,480 --> 00:19:35,280
apply the hash function h1 to see which

468
00:19:35,280 --> 00:19:37,520
of the bins it falls into suppose it

469
00:19:37,520 --> 00:19:39,360
falls into bin 1

470
00:19:39,360 --> 00:19:42,720
then you can decode key a by

471
00:19:42,720 --> 00:19:46,559
decoding a within the central okvis n0

472
00:19:46,559 --> 00:19:49,360
and the ok vs n1 and xor both these

473
00:19:49,360 --> 00:19:50,559
values

474
00:19:50,559 --> 00:19:53,360
suppose a fell into bin 3 instead

475
00:19:53,360 --> 00:19:56,160
then you would decode the key a within

476
00:19:56,160 --> 00:19:58,960
the central okvs and within the third ok

477
00:19:58,960 --> 00:20:02,559
vs and xor both these values

478
00:20:02,559 --> 00:20:05,679
so let's see how we would encode values

479
00:20:05,679 --> 00:20:07,919
into such an ok vs such that the

480
00:20:07,919 --> 00:20:09,840
encoding works correct such that all the

481
00:20:09,840 --> 00:20:13,039
decoding works correctly

482
00:20:13,039 --> 00:20:15,760
we start by testing each of the leaf and

483
00:20:15,760 --> 00:20:17,919
central ok vss

484
00:20:17,919 --> 00:20:20,000
we start by testing each of the leaf ok

485
00:20:20,000 --> 00:20:21,120
vss

486
00:20:21,120 --> 00:20:24,320
and see if say n1 can encode all the

487
00:20:24,320 --> 00:20:26,480
keys that have been assigned to its bin

488
00:20:26,480 --> 00:20:28,559
n2 can encode all the keys assigned to

489
00:20:28,559 --> 00:20:31,200
its bin and so on

490
00:20:31,200 --> 00:20:33,679
suppose one of the leaves is unable to

491
00:20:33,679 --> 00:20:36,880
encode the keys say n1 can't encode all

492
00:20:36,880 --> 00:20:39,039
the keys that it has

493
00:20:39,039 --> 00:20:41,760
in this case we need to fix the central

494
00:20:41,760 --> 00:20:45,039
node such that it allows to successfully

495
00:20:45,039 --> 00:20:48,000
encode all the keys that lie in bin 1.

496
00:20:48,000 --> 00:20:52,240
so we update the values of n0 so that n1

497
00:20:52,240 --> 00:20:55,200
xor n 0 allows us to get the correct

498
00:20:55,200 --> 00:20:58,000
decode values for all the bins in bin 1.

499
00:20:58,000 --> 00:21:00,640
since n2 and n3 can successfully encode

500
00:21:00,640 --> 00:21:03,280
their keys they just adjust their values

501
00:21:03,280 --> 00:21:06,799
according to this ok vs n0

502
00:21:06,799 --> 00:21:10,480
similarly if only n3 failed then you can

503
00:21:10,480 --> 00:21:14,159
deco you first fix the central node n0

504
00:21:14,159 --> 00:21:16,080
to decode correctly all the keys that

505
00:21:16,080 --> 00:21:17,600
lie in bin 3

506
00:21:17,600 --> 00:21:20,640
and then once the central okvs is fixed

507
00:21:20,640 --> 00:21:22,960
n1 and n2 can successfully encode all

508
00:21:22,960 --> 00:21:25,679
the keys in their bin

509
00:21:25,679 --> 00:21:28,799
if n1 n2 and n3 can successfully encode

510
00:21:28,799 --> 00:21:32,000
you just pick a random ok vs for n0 and

511
00:21:32,000 --> 00:21:34,960
adjust the values of n1 n2 and n3 so

512
00:21:34,960 --> 00:21:36,480
that when you decode you get the

513
00:21:36,480 --> 00:21:39,200
expected value for each key

514
00:21:39,200 --> 00:21:41,840
if only one leaf fails say n1 then you

515
00:21:41,840 --> 00:21:44,480
adjust n0 to match n1

516
00:21:44,480 --> 00:21:46,799
and then you are just n2 and n3 to match

517
00:21:46,799 --> 00:21:48,159
n0

518
00:21:48,159 --> 00:21:50,480
so the bad event is when two or more

519
00:21:50,480 --> 00:21:53,120
nodes fail

520
00:21:53,120 --> 00:21:55,679
assume let's calculate the probability

521
00:21:55,679 --> 00:21:57,679
of this bad event occurring

522
00:21:57,679 --> 00:21:59,919
if each of these individual nodes fails

523
00:21:59,919 --> 00:22:01,919
with probability p

524
00:22:01,919 --> 00:22:04,320
then we compute the probability as a

525
00:22:04,320 --> 00:22:06,640
summation of the

526
00:22:06,640 --> 00:22:09,440
of more than two nodes failing

527
00:22:09,440 --> 00:22:10,799
and

528
00:22:10,799 --> 00:22:12,400
this almost squares the failure

529
00:22:12,400 --> 00:22:14,320
probability

530
00:22:14,320 --> 00:22:16,720
now i will show the concrete parameters

531
00:22:16,720 --> 00:22:19,520
that we obtained for our kvs that can

532
00:22:19,520 --> 00:22:22,559
encode a million key value pairs

533
00:22:22,559 --> 00:22:27,120
we had cubins where q is 160

534
00:22:27,120 --> 00:22:29,919
and by standard balls and bins analysis

535
00:22:29,919 --> 00:22:32,400
we obtain that each of the bins has

536
00:22:32,400 --> 00:22:34,760
maximum load

537
00:22:34,760 --> 00:22:37,520
7163 keys except a negligible

538
00:22:37,520 --> 00:22:38,960
probability

539
00:22:38,960 --> 00:22:41,200
so each of the occavious leaves and the

540
00:22:41,200 --> 00:22:44,520
central ok vs needs to encode

541
00:22:44,520 --> 00:22:47,760
7163 keys each

542
00:22:47,760 --> 00:22:50,640
we plug this into our

543
00:22:50,640 --> 00:22:55,120
formula to compute the ok vs

544
00:22:55,520 --> 00:22:57,679
and we found that we need an okbs of

545
00:22:57,679 --> 00:23:01,400
size 8622

546
00:23:02,480 --> 00:23:05,120
we ran empirical experiments and saw

547
00:23:05,120 --> 00:23:08,559
that only one bad event occurred in 2 to

548
00:23:08,559 --> 00:23:11,440
the 23 runs of the small okvs

549
00:23:11,440 --> 00:23:13,080
each which holds

550
00:23:13,080 --> 00:23:16,240
7163 keys each and each of them was

551
00:23:16,240 --> 00:23:18,320
parameterized by different random hash

552
00:23:18,320 --> 00:23:19,919
functions

553
00:23:19,919 --> 00:23:22,720
and we saw that the probability that an

554
00:23:22,720 --> 00:23:24,559
encode fails

555
00:23:24,559 --> 00:23:27,679
was 2 to the minus 29.35

556
00:23:27,679 --> 00:23:31,440
with confidence level 0.999

557
00:23:31,440 --> 00:23:33,840
we obtain that the probability that

558
00:23:33,840 --> 00:23:36,559
encoding a million items fails is 2 to

559
00:23:36,559 --> 00:23:40,159
the minus 45.05 which is negligible

560
00:23:40,159 --> 00:23:43,200
and our encoding time was around 2.915

561
00:23:43,200 --> 00:23:44,400
seconds

562
00:23:44,400 --> 00:23:46,080
and the decoding time for all the

563
00:23:46,080 --> 00:23:48,200
million items was

564
00:23:48,200 --> 00:23:51,600
1.625 seconds

565
00:23:51,600 --> 00:23:54,960
and the size of the ok vs was q plus 1

566
00:23:54,960 --> 00:23:57,039
times the size of each of the smaller ok

567
00:23:57,039 --> 00:24:03,559
vs's which was around 1.38 times million

568
00:24:04,080 --> 00:24:06,080
in our paper we describe many

569
00:24:06,080 --> 00:24:08,880
applications or use cases for our ok vs

570
00:24:08,880 --> 00:24:10,400
construction

571
00:24:10,400 --> 00:24:12,480
our three hash garble coco table

572
00:24:12,480 --> 00:24:14,720
construction with a star architecture

573
00:24:14,720 --> 00:24:18,080
can replace any random encoding task we

574
00:24:18,080 --> 00:24:20,400
can replace the use of polynomials in

575
00:24:20,400 --> 00:24:22,480
the following use cases

576
00:24:22,480 --> 00:24:25,679
the first one is the sparse ot extension

577
00:24:25,679 --> 00:24:27,600
which was used to design

578
00:24:27,600 --> 00:24:29,840
a communication efficient semi-honest

579
00:24:29,840 --> 00:24:33,360
psi protocol in prty 19.

580
00:24:33,360 --> 00:24:35,279
one of their construction relies on the

581
00:24:35,279 --> 00:24:37,679
interpolation of a large polynomial and

582
00:24:37,679 --> 00:24:41,360
our ok vs can replace this

583
00:24:41,600 --> 00:24:44,159
oblivious programmable prfs are an

584
00:24:44,159 --> 00:24:46,080
important building block in many psi

585
00:24:46,080 --> 00:24:48,640
constructions

586
00:24:48,640 --> 00:24:51,200
many oprs rely again on the use of a

587
00:24:51,200 --> 00:24:54,080
polynomial to encode key value pairs and

588
00:24:54,080 --> 00:24:56,480
we can replace their use of polynomials

589
00:24:56,480 --> 00:24:58,840
by our okvs

590
00:24:58,840 --> 00:25:02,000
opprfs are used to build circuit psi

591
00:25:02,000 --> 00:25:04,000
protocols

592
00:25:04,000 --> 00:25:06,000
they are also used they were also used

593
00:25:06,000 --> 00:25:08,640
to design the private set union protocol

594
00:25:08,640 --> 00:25:11,440
in krtw19

595
00:25:11,440 --> 00:25:13,200
and they also form a major building

596
00:25:13,200 --> 00:25:15,200
block for multi-party private set

597
00:25:15,200 --> 00:25:17,760
intersection protocols

598
00:25:17,760 --> 00:25:22,320
described in the paper kmprt 17

599
00:25:22,320 --> 00:25:24,880
while exploring the multi-party psi

600
00:25:24,880 --> 00:25:28,080
protocols in kmprt 17

601
00:25:28,080 --> 00:25:29,440
we realized that one of their

602
00:25:29,440 --> 00:25:30,799
constructions

603
00:25:30,799 --> 00:25:33,360
which is augmented semion is secure

604
00:25:33,360 --> 00:25:35,679
is actually efficient against malicious

605
00:25:35,679 --> 00:25:38,720
adversaries with a small modification

606
00:25:38,720 --> 00:25:40,640
so we obtain the most efficient

607
00:25:40,640 --> 00:25:42,559
malicious secure multi-party psi

608
00:25:42,559 --> 00:25:45,600
protocol and describe this in our paper

609
00:25:45,600 --> 00:25:47,679
we show a qualitative analysis of why

610
00:25:47,679 --> 00:25:49,440
this is the most efficient protocol to

611
00:25:49,440 --> 00:25:51,760
date

612
00:25:51,760 --> 00:25:54,400
our ok vs can also replace the role of

613
00:25:54,400 --> 00:25:57,520
pax source in the following papers

614
00:25:57,520 --> 00:25:59,760
as a flagship example

615
00:25:59,760 --> 00:26:02,320
we consider the ot-based paxos psi

616
00:26:02,320 --> 00:26:06,559
protocol that was presented in prty 20.

617
00:26:06,559 --> 00:26:09,279
by replacing the paxos with our okvs we

618
00:26:09,279 --> 00:26:11,760
obtain the fastest malicious two-party

619
00:26:11,760 --> 00:26:14,159
psi protocol to date

620
00:26:14,159 --> 00:26:15,840
with the added advantage that this is

621
00:26:15,840 --> 00:26:17,840
empirically verified

622
00:26:17,840 --> 00:26:22,080
we also present a new psi paper protocol

623
00:26:22,080 --> 00:26:25,039
by generalizing the ot base paxos psi

624
00:26:25,039 --> 00:26:29,600
protocol to admit a linear okvs

625
00:26:29,600 --> 00:26:31,279
we show that we

626
00:26:31,279 --> 00:26:34,240
we obtain a new vector ole based okvs

627
00:26:34,240 --> 00:26:37,720
psi protocol

628
00:26:38,159 --> 00:26:41,200
concurrently in rs 21 they showed a

629
00:26:41,200 --> 00:26:44,080
vector royally paxos psi protocol

630
00:26:44,080 --> 00:26:46,080
and we suggest that you can replace the

631
00:26:46,080 --> 00:26:47,760
ok vs in there

632
00:26:47,760 --> 00:26:48,880
we can

633
00:26:48,880 --> 00:26:50,720
we suggest that you can replace the pack

634
00:26:50,720 --> 00:26:52,880
source by ocavious in their paper as

635
00:26:52,880 --> 00:26:54,400
well

636
00:26:54,400 --> 00:26:56,159
finally i'd like to provide some

637
00:26:56,159 --> 00:26:58,880
takeaways from our experimental results

638
00:26:58,880 --> 00:27:00,720
while computing the intersection on a

639
00:27:00,720 --> 00:27:02,799
million items

640
00:27:02,799 --> 00:27:05,440
we saw that our constructions the three

641
00:27:05,440 --> 00:27:07,679
hash gobble coco table based on

642
00:27:07,679 --> 00:27:10,159
heuristic parameters and the three hash

643
00:27:10,159 --> 00:27:12,559
kabul cocoa table based on the star

644
00:27:12,559 --> 00:27:14,720
amplification

645
00:27:14,720 --> 00:27:18,840
had about 1.61 times and 1.43 times less

646
00:27:18,840 --> 00:27:22,640
communication than paxos psi

647
00:27:22,640 --> 00:27:24,399
this means that on slow and medial

648
00:27:24,399 --> 00:27:25,600
networks

649
00:27:25,600 --> 00:27:28,480
we have the fastest malicious secure psi

650
00:27:28,480 --> 00:27:30,559
protocol

651
00:27:30,559 --> 00:27:32,320
and on slower networks we have the

652
00:27:32,320 --> 00:27:36,320
fastest semi honest psi protocol

653
00:27:36,320 --> 00:27:38,000
with that i would like to thank you for

654
00:27:38,000 --> 00:27:41,159
your attention

