1
00:00:00,719 --> 00:00:03,280
this is joint work with stefano tessaro

2
00:00:03,280 --> 00:00:05,200
very broadly this work develops a

3
00:00:05,200 --> 00:00:07,279
framework that provides security proofs

4
00:00:07,279 --> 00:00:10,000
for some proof systems used in practice

5
00:00:10,000 --> 00:00:11,920
which did not have meaningful security

6
00:00:11,920 --> 00:00:14,799
guarantee so far

7
00:00:15,679 --> 00:00:17,840
over the last few years we have seen

8
00:00:17,840 --> 00:00:19,680
zero knowledge proofs being implemented

9
00:00:19,680 --> 00:00:21,840
in real-world system

10
00:00:21,840 --> 00:00:22,800
however

11
00:00:22,800 --> 00:00:24,720
often the security guarantees about

12
00:00:24,720 --> 00:00:26,960
these proof systems are very weak or

13
00:00:26,960 --> 00:00:28,960
non-existent

14
00:00:28,960 --> 00:00:30,960
this might sound surprising to you given

15
00:00:30,960 --> 00:00:33,040
that most of these proof systems have

16
00:00:33,040 --> 00:00:35,600
existing security analysis

17
00:00:35,600 --> 00:00:37,840
the underlying reason for this issue is

18
00:00:37,840 --> 00:00:41,120
the use of the feared trauma transform

19
00:00:41,120 --> 00:00:42,800
before i explain you why that is the

20
00:00:42,800 --> 00:00:44,559
case let me briefly recall what the

21
00:00:44,559 --> 00:00:47,120
reaction transform does

22
00:00:47,120 --> 00:00:49,920
it starts with an interactive proof or

23
00:00:49,920 --> 00:00:52,079
argument which is public point that is

24
00:00:52,079 --> 00:00:54,160
the verifiers messages are random

25
00:00:54,160 --> 00:00:55,600
challenges

26
00:00:55,600 --> 00:00:58,320
it uses a hash function to transform the

27
00:00:58,320 --> 00:00:59,760
interactive protocol into a

28
00:00:59,760 --> 00:01:02,239
non-interactive argument

29
00:01:02,239 --> 00:01:04,640
the idea is that the hash function plays

30
00:01:04,640 --> 00:01:06,960
the role of the verifier in computing

31
00:01:06,960 --> 00:01:08,960
the next challenge from the transcript

32
00:01:08,960 --> 00:01:11,360
so far

33
00:01:11,360 --> 00:01:13,280
if the interactive protocol is zero

34
00:01:13,280 --> 00:01:14,720
knowledge to begin with then the

35
00:01:14,720 --> 00:01:16,240
non-interactive protocol is zero

36
00:01:16,240 --> 00:01:18,880
knowledge as well

37
00:01:19,200 --> 00:01:21,280
many recently proposed non-interactive

38
00:01:21,280 --> 00:01:23,520
succinct argument systems have been

39
00:01:23,520 --> 00:01:24,960
designed using the feared shaming

40
00:01:24,960 --> 00:01:26,479
transform

41
00:01:26,479 --> 00:01:27,200
the

42
00:01:27,200 --> 00:01:29,520
key point is that the soundness of these

43
00:01:29,520 --> 00:01:31,600
protocols is only proved in the

44
00:01:31,600 --> 00:01:33,600
interactive setting

45
00:01:33,600 --> 00:01:35,200
and you think

46
00:01:35,200 --> 00:01:36,720
that if the interactive protocol is

47
00:01:36,720 --> 00:01:38,560
sound and the hash function is a random

48
00:01:38,560 --> 00:01:39,520
oracle

49
00:01:39,520 --> 00:01:41,280
then the non-interactive protocol is

50
00:01:41,280 --> 00:01:43,759
sound as well

51
00:01:43,759 --> 00:01:46,000
unfortunately the situation here is

52
00:01:46,000 --> 00:01:47,360
complicated

53
00:01:47,360 --> 00:01:49,439
it is a fact that most experts in the

54
00:01:49,439 --> 00:01:50,640
area know

55
00:01:50,640 --> 00:01:52,240
but it is not very

56
00:01:52,240 --> 00:01:55,839
well documented in general

57
00:01:55,920 --> 00:01:57,680
the problem is the degradation of

58
00:01:57,680 --> 00:01:59,360
soundness resulting from the feared

59
00:01:59,360 --> 00:02:01,200
trauma transform

60
00:02:01,200 --> 00:02:03,119
let us assume that the interactive

61
00:02:03,119 --> 00:02:05,040
protocol has soundness error epsilon for

62
00:02:05,040 --> 00:02:07,920
a cheating prover running in time t

63
00:02:07,920 --> 00:02:10,080
meaning that any such cheat improver can

64
00:02:10,080 --> 00:02:11,680
full or verifier with probability at

65
00:02:11,680 --> 00:02:13,920
most epsilon

66
00:02:13,920 --> 00:02:15,920
then if the interactive protocol has

67
00:02:15,920 --> 00:02:18,720
around and the hash function is random

68
00:02:18,720 --> 00:02:20,959
oracle the best guarantee that we can

69
00:02:20,959 --> 00:02:22,640
prove generically for the

70
00:02:22,640 --> 00:02:24,640
non-interactive counterpart

71
00:02:24,640 --> 00:02:27,200
is that its soundness error is at most t

72
00:02:27,200 --> 00:02:30,080
power r plus 1 times epsilon

73
00:02:30,080 --> 00:02:31,280
this is a

74
00:02:31,280 --> 00:02:33,840
terrible soundness degradation as the

75
00:02:33,840 --> 00:02:37,840
two examples next we'll illustrate

76
00:02:38,800 --> 00:02:41,760
our first example involves bullet proofs

77
00:02:41,760 --> 00:02:44,239
which is a popular argument system that

78
00:02:44,239 --> 00:02:46,959
has been deployed in practice in monero

79
00:02:46,959 --> 00:02:49,360
and signals mobile time

80
00:02:49,360 --> 00:02:51,440
the interactive protocols has more than

81
00:02:51,440 --> 00:02:54,800
constant number of rounds meaning that

82
00:02:54,800 --> 00:02:58,319
t power r plus 1 is huge and we get no

83
00:02:58,319 --> 00:03:01,599
meaningful security guarantees

84
00:03:01,599 --> 00:03:03,599
it might appear that this is fine for

85
00:03:03,599 --> 00:03:06,319
constant round protocols but even then

86
00:03:06,319 --> 00:03:08,959
the situation is not as nice as you

87
00:03:08,959 --> 00:03:10,480
think

88
00:03:10,480 --> 00:03:12,879
it is not uncommon for these protocols

89
00:03:12,879 --> 00:03:16,080
to have at least four rounds

90
00:03:16,080 --> 00:03:17,440
because of the loss in the

91
00:03:17,440 --> 00:03:18,480
transformation

92
00:03:18,480 --> 00:03:22,000
for 256 bit curves we cannot get a

93
00:03:22,000 --> 00:03:24,640
security guarantees for adversaries in

94
00:03:24,640 --> 00:03:27,519
time running in time beyond to power 60

95
00:03:27,519 --> 00:03:30,720
which is not very meaningful

96
00:03:30,720 --> 00:03:33,360
are the proofs being overly pessimistic

97
00:03:33,360 --> 00:03:35,840
because from these systems we expect

98
00:03:35,840 --> 00:03:38,879
much better security

99
00:03:39,200 --> 00:03:42,000
so there's a significant gap between

100
00:03:42,000 --> 00:03:43,920
security expectations and what

101
00:03:43,920 --> 00:03:46,799
guarantees we can prove this is a little

102
00:03:46,799 --> 00:03:49,040
alarming because some of these systems

103
00:03:49,040 --> 00:03:51,280
are being used in the real world without

104
00:03:51,280 --> 00:03:54,319
proofs backing security expectations

105
00:03:54,319 --> 00:03:56,959
the goal of our work is exactly to

106
00:03:56,959 --> 00:03:59,599
narrow this gap

107
00:03:59,599 --> 00:04:02,080
we do this by giving a general framework

108
00:04:02,080 --> 00:04:04,560
to analyze security in the algebraic

109
00:04:04,560 --> 00:04:07,120
group model for group based protocols

110
00:04:07,120 --> 00:04:10,159
that use the fear shami transform

111
00:04:10,159 --> 00:04:12,560
our framework captures protocols

112
00:04:12,560 --> 00:04:14,799
instantiated in groups with or without

113
00:04:14,799 --> 00:04:17,200
parents

114
00:04:17,759 --> 00:04:18,720
we

115
00:04:18,720 --> 00:04:20,639
apply our framework to

116
00:04:20,639 --> 00:04:22,800
obtain tight security bounds for the

117
00:04:22,800 --> 00:04:24,639
non-interactive version of bulletproofs

118
00:04:24,639 --> 00:04:27,199
and sonic

119
00:04:27,360 --> 00:04:28,400
in fact

120
00:04:28,400 --> 00:04:30,400
for bullet proofs this is the first

121
00:04:30,400 --> 00:04:32,479
non-trivial soundness guarantee for the

122
00:04:32,479 --> 00:04:34,240
non-interactive argument

123
00:04:34,240 --> 00:04:37,840
ever proved in any model

124
00:04:37,919 --> 00:04:40,400
note that in concurrent work bonds at

125
00:04:40,400 --> 00:04:43,120
all analyze the non-interactive version

126
00:04:43,120 --> 00:04:45,120
of the main component of bullet proofs

127
00:04:45,120 --> 00:04:46,560
in the agm

128
00:04:46,560 --> 00:04:49,280
however the bounds they obtain are not

129
00:04:49,280 --> 00:04:51,599
typed

130
00:04:52,160 --> 00:04:54,160
we also expect our framework to be more

131
00:04:54,160 --> 00:04:56,479
widely applicable to a number of other

132
00:04:56,479 --> 00:04:57,840
group systems

133
00:04:57,840 --> 00:05:00,960
but leave that for future work

134
00:05:00,960 --> 00:05:04,000
also note that there are prior works

135
00:05:04,000 --> 00:05:05,680
that use the

136
00:05:05,680 --> 00:05:07,360
generate group model or the algebraic

137
00:05:07,360 --> 00:05:09,120
group model to analyze soundness of

138
00:05:09,120 --> 00:05:11,120
non-interactive protocols

139
00:05:11,120 --> 00:05:13,280
but these protocols do not involve the

140
00:05:13,280 --> 00:05:15,440
future transform hence

141
00:05:15,440 --> 00:05:17,680
their analysis does not encounter the

142
00:05:17,680 --> 00:05:21,039
challenges that we have here

143
00:05:21,680 --> 00:05:24,320
the key ingredient of our approach is to

144
00:05:24,320 --> 00:05:26,960
analyze the notion of state restoration

145
00:05:26,960 --> 00:05:29,039
sounds

146
00:05:29,039 --> 00:05:31,440
the state restoration soundness error of

147
00:05:31,440 --> 00:05:34,160
an interactive protocol is roughly

148
00:05:34,160 --> 00:05:36,240
an upper bound on the soundness error of

149
00:05:36,240 --> 00:05:38,720
the non-interactive protocol resulting

150
00:05:38,720 --> 00:05:42,000
from the fiat summit transform

151
00:05:42,160 --> 00:05:43,759
let me define what state restriction

152
00:05:43,759 --> 00:05:45,120
soundness is

153
00:05:45,120 --> 00:05:46,800
simply stated

154
00:05:46,800 --> 00:05:48,160
this notion of state restriction

155
00:05:48,160 --> 00:05:50,000
soundness gives

156
00:05:50,000 --> 00:05:52,400
the cheating prover the additional power

157
00:05:52,400 --> 00:05:54,639
to restore the verifier to any of its

158
00:05:54,639 --> 00:05:56,880
previous states and resume its execution

159
00:05:56,880 --> 00:05:58,080
from there

160
00:05:58,080 --> 00:06:00,319
ah let me illustrate what i mean by this

161
00:06:00,319 --> 00:06:02,639
through an example of a protocol with

162
00:06:02,639 --> 00:06:04,319
two rounds

163
00:06:04,319 --> 00:06:05,840
the very fire

164
00:06:05,840 --> 00:06:07,919
in its initial state

165
00:06:07,919 --> 00:06:09,520
uh the cheating prover interacts with

166
00:06:09,520 --> 00:06:11,280
the verifier sending a message receiving

167
00:06:11,280 --> 00:06:14,080
a challenge and it continues execution

168
00:06:14,080 --> 00:06:17,280
which eventually leads to rejection

169
00:06:17,280 --> 00:06:20,400
the cheating proverb then restores the

170
00:06:20,400 --> 00:06:22,319
initial state of the verifier

171
00:06:22,319 --> 00:06:24,400
and starts with the new first message

172
00:06:24,400 --> 00:06:26,800
receives a new first challenge

173
00:06:26,800 --> 00:06:28,800
which it does not like and restores the

174
00:06:28,800 --> 00:06:31,039
verifier to an earlier state the

175
00:06:31,039 --> 00:06:32,639
cheating prover

176
00:06:32,639 --> 00:06:34,639
continues the execution

177
00:06:34,639 --> 00:06:36,560
restoring the state of the verifier uh

178
00:06:36,560 --> 00:06:39,120
whenever it does not like a challenge

179
00:06:39,120 --> 00:06:40,240
and

180
00:06:40,240 --> 00:06:43,840
that finally leads to an accept

181
00:06:43,919 --> 00:06:45,919
uh the cheating proverbs

182
00:06:45,919 --> 00:06:47,280
if there is an accepting path in the

183
00:06:47,280 --> 00:06:50,080
execution tree

184
00:06:50,160 --> 00:06:51,599
we define the state restoration

185
00:06:51,599 --> 00:06:53,280
soundness error as the probability that

186
00:06:53,280 --> 00:06:56,318
the cheating tool gets

187
00:06:57,120 --> 00:06:59,280
so the question we can ask here is that

188
00:06:59,280 --> 00:07:00,960
can we bound the state restoration

189
00:07:00,960 --> 00:07:02,479
soundness error for a protocol

190
00:07:02,479 --> 00:07:04,400
generically if we know the regular

191
00:07:04,400 --> 00:07:05,840
soundness error

192
00:07:05,840 --> 00:07:08,080
well if we have a round protocol with

193
00:07:08,080 --> 00:07:10,160
soundness error epsilon

194
00:07:10,160 --> 00:07:11,759
we can show generically that for

195
00:07:11,759 --> 00:07:13,919
cheating towards running in time t the

196
00:07:13,919 --> 00:07:16,080
state restoration soundness error is

197
00:07:16,080 --> 00:07:18,560
upper bounded by t power r plus 1 times

198
00:07:18,560 --> 00:07:20,400
epsilon

199
00:07:20,400 --> 00:07:22,319
this can be translated into an upper

200
00:07:22,319 --> 00:07:24,479
bound on the soundness of the

201
00:07:24,479 --> 00:07:26,639
non-interactive protocol resulting from

202
00:07:26,639 --> 00:07:28,960
the fluid semi transform

203
00:07:28,960 --> 00:07:29,680
but

204
00:07:29,680 --> 00:07:31,919
if you remember we could have already

205
00:07:31,919 --> 00:07:35,039
proved the same bound generically

206
00:07:35,039 --> 00:07:37,120
and in fact technically the proofs

207
00:07:37,120 --> 00:07:40,639
behind these two statements are the same

208
00:07:40,639 --> 00:07:42,240
and it looks like we're back to square

209
00:07:42,240 --> 00:07:45,240
one

210
00:07:45,280 --> 00:07:47,840
since we cannot do something generically

211
00:07:47,840 --> 00:07:50,160
the question is whether for some

212
00:07:50,160 --> 00:07:53,199
protocols uh can we prove better

213
00:07:53,199 --> 00:07:55,039
bounds directly for the state

214
00:07:55,039 --> 00:07:57,599
restriction sounds

215
00:07:57,599 --> 00:08:00,000
the answer here again is it's

216
00:08:00,000 --> 00:08:02,400
complicated

217
00:08:02,400 --> 00:08:05,520
it turns out that for interactive proofs

218
00:08:05,520 --> 00:08:06,800
indeed

219
00:08:06,800 --> 00:08:08,800
it is sometimes possible to give better

220
00:08:08,800 --> 00:08:10,000
bonds

221
00:08:10,000 --> 00:08:13,039
in particular these works show that some

222
00:08:13,039 --> 00:08:14,560
proofs satisfy

223
00:08:14,560 --> 00:08:16,479
a different notion called round by round

224
00:08:16,479 --> 00:08:18,879
soundness which was shown to be

225
00:08:18,879 --> 00:08:20,400
equivalent to state restriction

226
00:08:20,400 --> 00:08:23,680
soundness by hongdae

227
00:08:23,680 --> 00:08:24,800
however

228
00:08:24,800 --> 00:08:26,879
we are interested in success protocols

229
00:08:26,879 --> 00:08:29,759
which are arguments and for these we

230
00:08:29,759 --> 00:08:32,399
don't actually know of any non-trivial

231
00:08:32,399 --> 00:08:36,159
bounds for state restriction source

232
00:08:37,120 --> 00:08:39,120
i want to give you an idea of what the

233
00:08:39,120 --> 00:08:42,479
challenge is and highlight our approach

234
00:08:42,479 --> 00:08:43,919
to do that i

235
00:08:43,919 --> 00:08:47,519
want to first tell you normally how

236
00:08:47,519 --> 00:08:50,880
plane soundness of arguments is proved

237
00:08:50,880 --> 00:08:54,240
here specifically i'll talk about a

238
00:08:54,240 --> 00:08:55,760
security notion which has been

239
00:08:55,760 --> 00:08:58,399
frequently used in recent work which is

240
00:08:58,399 --> 00:09:01,920
that of witness extended emulation

241
00:09:01,920 --> 00:09:04,160
uh this is a proof of knowledge property

242
00:09:04,160 --> 00:09:08,080
and therefore implies soundness

243
00:09:08,080 --> 00:09:10,480
this notion is defined as follows for an

244
00:09:10,480 --> 00:09:12,640
interactive protocol

245
00:09:12,640 --> 00:09:15,120
uh we consider a real world experiment

246
00:09:15,120 --> 00:09:16,720
where the cheating proverb interacts

247
00:09:16,720 --> 00:09:18,160
with the verifier

248
00:09:18,160 --> 00:09:19,920
and their interaction generates a

249
00:09:19,920 --> 00:09:21,120
transcript

250
00:09:21,120 --> 00:09:22,480
we compare it

251
00:09:22,480 --> 00:09:24,640
with an ideal world experiment where the

252
00:09:24,640 --> 00:09:27,120
cheating improver is interacting with an

253
00:09:27,120 --> 00:09:29,360
extractor that only knows the instance

254
00:09:29,360 --> 00:09:33,040
and can rewind the cheating tool

255
00:09:33,040 --> 00:09:34,720
the extractor outputs a simulated

256
00:09:34,720 --> 00:09:39,120
transcript and a candidate witness

257
00:09:39,120 --> 00:09:40,480
the

258
00:09:40,480 --> 00:09:42,240
requirement that we

259
00:09:42,240 --> 00:09:44,240
want to have is that the simulated

260
00:09:44,240 --> 00:09:46,560
transcript is identically distributed to

261
00:09:46,560 --> 00:09:48,399
the original transcript

262
00:09:48,399 --> 00:09:50,399
and whenever the simulated transcript is

263
00:09:50,399 --> 00:09:52,000
an accepting transcript that is a

264
00:09:52,000 --> 00:09:54,640
verifier would accept the interaction uh

265
00:09:54,640 --> 00:09:57,120
then the candidate witness should be a

266
00:09:57,120 --> 00:09:59,040
valid witness for the

267
00:09:59,040 --> 00:10:01,439
instance

268
00:10:02,240 --> 00:10:04,800
for arguments the latter guarantee is

269
00:10:04,800 --> 00:10:07,120
only computational that is it needs to

270
00:10:07,120 --> 00:10:09,360
hold against all efficient cheating

271
00:10:09,360 --> 00:10:11,440
proverbs except with some negligible

272
00:10:11,440 --> 00:10:13,760
probability

273
00:10:13,760 --> 00:10:16,640
typically the way this is proved is by

274
00:10:16,640 --> 00:10:19,360
using very uh complicated forking lemmas

275
00:10:19,360 --> 00:10:21,440
for multi-round protocols uh starting

276
00:10:21,440 --> 00:10:23,920
from the work of brutal at all and

277
00:10:23,920 --> 00:10:27,040
refined subsequently

278
00:10:28,320 --> 00:10:29,600
what is the challenge for state

279
00:10:29,600 --> 00:10:31,200
restoration tools

280
00:10:31,200 --> 00:10:32,959
the role of the extractor is much more

281
00:10:32,959 --> 00:10:35,279
complicated and the reason for that is

282
00:10:35,279 --> 00:10:38,000
that the cheating prover now can rewind

283
00:10:38,000 --> 00:10:39,920
the verifier and the transcript that is

284
00:10:39,920 --> 00:10:41,519
being generated is going to be an

285
00:10:41,519 --> 00:10:43,760
execution tree

286
00:10:43,760 --> 00:10:46,399
and now when we

287
00:10:46,399 --> 00:10:48,480
move to the experiment where the cheat

288
00:10:48,480 --> 00:10:50,880
improver interacts with the extractor

289
00:10:50,880 --> 00:10:52,880
not only does the

290
00:10:52,880 --> 00:10:55,920
extractor need to rewind the prover

291
00:10:55,920 --> 00:10:58,800
the extractor itself needs to deal with

292
00:10:58,800 --> 00:11:01,279
the fact that the approver will try to

293
00:11:01,279 --> 00:11:04,800
rewind the simulated verifier

294
00:11:05,040 --> 00:11:07,040
we don't even know what are good

295
00:11:07,040 --> 00:11:09,680
extracting extraction strategies and how

296
00:11:09,680 --> 00:11:12,399
to analyze them

297
00:11:13,040 --> 00:11:15,519
in our work we bypass the problem

298
00:11:15,519 --> 00:11:20,160
entirely by relying on online extraction

299
00:11:20,160 --> 00:11:23,120
the idea is that we want to extract a

300
00:11:23,120 --> 00:11:25,120
witness from an accepting transcript

301
00:11:25,120 --> 00:11:26,959
without actually needing to rewind the

302
00:11:26,959 --> 00:11:29,120
cheating proverb

303
00:11:29,120 --> 00:11:31,440
so now we have removed one of the two

304
00:11:31,440 --> 00:11:33,760
sources of evidence

305
00:11:33,760 --> 00:11:35,200
of course this sounds too good to be

306
00:11:35,200 --> 00:11:36,240
true

307
00:11:36,240 --> 00:11:39,120
online extraction does not come for free

308
00:11:39,120 --> 00:11:41,279
because otherwise the verifier could

309
00:11:41,279 --> 00:11:43,760
also extract the witness

310
00:11:43,760 --> 00:11:45,760
so the way we can achieve online

311
00:11:45,760 --> 00:11:47,920
extraction is by using

312
00:11:47,920 --> 00:11:50,240
either knowledge assumption or doing the

313
00:11:50,240 --> 00:11:52,959
analysis in some ideal models

314
00:11:52,959 --> 00:11:54,560
these approaches are

315
00:11:54,560 --> 00:11:57,120
common in existing analysis of succinct

316
00:11:57,120 --> 00:11:59,760
truth systems

317
00:12:00,320 --> 00:12:03,360
in this paper we focus on the algebraic

318
00:12:03,360 --> 00:12:05,920
group model

319
00:12:06,160 --> 00:12:08,160
the algebraic group model is an ideal

320
00:12:08,160 --> 00:12:10,720
model that considers security against

321
00:12:10,720 --> 00:12:13,600
algebraic adversaries only

322
00:12:13,600 --> 00:12:16,160
and algebraic adversary is one that

323
00:12:16,160 --> 00:12:18,880
provides a representation of every group

324
00:12:18,880 --> 00:12:21,279
elements its outputs with respect to all

325
00:12:21,279 --> 00:12:24,480
the group elements that have been input

326
00:12:24,480 --> 00:12:27,279
for example if we imagine an adversary

327
00:12:27,279 --> 00:12:29,440
that initially

328
00:12:29,440 --> 00:12:34,240
gets as input generators g1 and g2

329
00:12:34,240 --> 00:12:37,120
for some understood group g

330
00:12:37,120 --> 00:12:39,600
it later produces a group element y as

331
00:12:39,600 --> 00:12:41,920
output and a representation of y in

332
00:12:41,920 --> 00:12:44,560
terms of g one and g two

333
00:12:44,560 --> 00:12:46,880
ah we denote the group element and its

334
00:12:46,880 --> 00:12:50,720
representation as a square bracket one

335
00:12:50,720 --> 00:12:53,040
next it gets a group element h

336
00:12:53,040 --> 00:12:54,240
and

337
00:12:54,240 --> 00:12:55,760
it produces

338
00:12:55,760 --> 00:12:58,000
another group element z as output

339
00:12:58,000 --> 00:13:00,800
and a representation of z in terms of g

340
00:13:00,800 --> 00:13:03,760
1 g 2 and h

341
00:13:05,120 --> 00:13:07,279
our target is to

342
00:13:07,279 --> 00:13:10,000
analyze the witness extended emulation

343
00:13:10,000 --> 00:13:12,720
for state restoration proverbs in the

344
00:13:12,720 --> 00:13:14,959
agm

345
00:13:14,959 --> 00:13:16,880
we first consider an adaptive version

346
00:13:16,880 --> 00:13:18,320
where the cheating proverb gets to

347
00:13:18,320 --> 00:13:20,399
choose the input

348
00:13:20,399 --> 00:13:22,800
we again consider a real-world

349
00:13:22,800 --> 00:13:25,200
experiment where the algebraic state

350
00:13:25,200 --> 00:13:27,360
restoration cheating proverb interacts

351
00:13:27,360 --> 00:13:28,639
with the verifier

352
00:13:28,639 --> 00:13:31,120
here it can rewind the verifier and the

353
00:13:31,120 --> 00:13:35,120
interaction generates an execution tree

354
00:13:35,120 --> 00:13:35,920
we

355
00:13:35,920 --> 00:13:37,519
compare it with an ideal world

356
00:13:37,519 --> 00:13:40,079
experiment where the approver is

357
00:13:40,079 --> 00:13:42,480
interacting with an extractor

358
00:13:42,480 --> 00:13:44,160
since the prover is algebraic it

359
00:13:44,160 --> 00:13:47,199
provides the representation of the input

360
00:13:47,199 --> 00:13:49,440
and all of its messages that are group

361
00:13:49,440 --> 00:13:51,680
elements

362
00:13:51,680 --> 00:13:53,440
here the extractor

363
00:13:53,440 --> 00:13:55,920
again returns an execution tree and a

364
00:13:55,920 --> 00:13:58,240
candidate witness

365
00:13:58,240 --> 00:14:00,880
for a good extractor we need that for

366
00:14:00,880 --> 00:14:04,160
any distinguisher t the probability that

367
00:14:04,160 --> 00:14:05,839
d returns 1

368
00:14:05,839 --> 00:14:08,800
on getting the original execution 3 is

369
00:14:08,800 --> 00:14:10,399
approximately the same as the

370
00:14:10,399 --> 00:14:12,560
probability that d returns 1 on getting

371
00:14:12,560 --> 00:14:15,600
the simulated execution tree

372
00:14:15,600 --> 00:14:18,720
and whenever the simulator execution

373
00:14:18,720 --> 00:14:21,120
tree has an accepting path the candidate

374
00:14:21,120 --> 00:14:25,440
witness is a valid witness for the input

375
00:14:25,920 --> 00:14:27,920
we accordingly

376
00:14:27,920 --> 00:14:29,680
define the

377
00:14:29,680 --> 00:14:31,519
state restoration witness extended

378
00:14:31,519 --> 00:14:33,839
emulation advantage for an algebraic

379
00:14:33,839 --> 00:14:36,480
cheating proverb with respect to an uh

380
00:14:36,480 --> 00:14:39,760
with respect to an extractor to be the

381
00:14:39,760 --> 00:14:41,519
maximum of

382
00:14:41,519 --> 00:14:42,800
the difference of these two

383
00:14:42,800 --> 00:14:44,480
probabilities for any

384
00:14:44,480 --> 00:14:47,199
distinguisher d

385
00:14:47,760 --> 00:14:50,560
we also consider a non-adaptive version

386
00:14:50,560 --> 00:14:52,880
of the notion where the input is chosen

387
00:14:52,880 --> 00:14:55,040
by an external instance generator

388
00:14:55,040 --> 00:14:57,199
instead of the cheating prover

389
00:14:57,199 --> 00:15:00,639
the main difference here is if the input

390
00:15:00,639 --> 00:15:02,720
contains group elements the extractor

391
00:15:02,720 --> 00:15:06,720
does not learn the representations

392
00:15:06,959 --> 00:15:09,199
this notion might be useful for some

393
00:15:09,199 --> 00:15:11,040
other applications

394
00:15:11,040 --> 00:15:13,839
uh in our paper we have results for this

395
00:15:13,839 --> 00:15:16,800
notion but i shall focus on only on the

396
00:15:16,800 --> 00:15:20,079
adaptive version for this talk

397
00:15:20,079 --> 00:15:22,480
our goal here is given an interactive

398
00:15:22,480 --> 00:15:23,519
protocol

399
00:15:23,519 --> 00:15:26,079
uh we need to first define an extractor

400
00:15:26,079 --> 00:15:27,920
then we need to prove an upper bound on

401
00:15:27,920 --> 00:15:30,560
the state restoration witness extended

402
00:15:30,560 --> 00:15:32,160
emulation advantage

403
00:15:32,160 --> 00:15:34,240
of any algebraic cheating prover running

404
00:15:34,240 --> 00:15:35,360
in time t

405
00:15:35,360 --> 00:15:39,880
with respect to our defined extractor

406
00:15:41,279 --> 00:15:42,320
so we

407
00:15:42,320 --> 00:15:44,480
propose a proof framework for this and

408
00:15:44,480 --> 00:15:48,320
our framework is composed of

409
00:15:48,320 --> 00:15:50,880
two main ingredients

410
00:15:50,880 --> 00:15:51,920
first

411
00:15:51,920 --> 00:15:53,120
for

412
00:15:53,120 --> 00:15:57,040
all partial paths in the execution tree

413
00:15:57,040 --> 00:16:00,160
we define a set of bad challenges

414
00:16:00,160 --> 00:16:02,800
we show that there is some epsilon such

415
00:16:02,800 --> 00:16:05,600
that for any partial path

416
00:16:05,600 --> 00:16:07,759
at most an epsilon fraction of the

417
00:16:07,759 --> 00:16:10,320
challenges are back

418
00:16:10,320 --> 00:16:11,360
secondly

419
00:16:11,360 --> 00:16:14,959
we define an efficient function little e

420
00:16:14,959 --> 00:16:16,079
which is

421
00:16:16,079 --> 00:16:18,720
meant to take an accepting path and the

422
00:16:18,720 --> 00:16:20,480
instance as input

423
00:16:20,480 --> 00:16:23,440
and return either bottom or a witness

424
00:16:23,440 --> 00:16:26,160
for the instance

425
00:16:26,639 --> 00:16:28,639
ah we define a path in the execution

426
00:16:28,639 --> 00:16:31,680
tree to be bad if there are any bad

427
00:16:31,680 --> 00:16:35,120
challenges in the path and any part that

428
00:16:35,120 --> 00:16:36,720
does not have any bad challenges is a

429
00:16:36,720 --> 00:16:38,720
good path

430
00:16:38,720 --> 00:16:41,920
ah our hope is that

431
00:16:41,920 --> 00:16:46,320
if the accepting path input to e is good

432
00:16:46,320 --> 00:16:49,440
then it returns a valid witness

433
00:16:49,440 --> 00:16:52,240
additionally we want to minimize epsilon

434
00:16:52,240 --> 00:16:55,040
to ensure that there are not too many

435
00:16:55,040 --> 00:16:57,759
bad challenges

436
00:16:58,560 --> 00:17:01,360
now suppose for an interactive protocol

437
00:17:01,360 --> 00:17:02,959
the set of bad challenges and the

438
00:17:02,959 --> 00:17:05,039
function a little e are

439
00:17:05,039 --> 00:17:07,359
defined

440
00:17:07,359 --> 00:17:08,240
then

441
00:17:08,240 --> 00:17:10,880
we can construct an extractor that runs

442
00:17:10,880 --> 00:17:13,439
the cheating prover and applies

443
00:17:13,439 --> 00:17:15,599
this function little e to an accepting

444
00:17:15,599 --> 00:17:16,880
path

445
00:17:16,880 --> 00:17:19,599
and we can prove that for

446
00:17:19,599 --> 00:17:22,400
cheating proverbs running in time t

447
00:17:22,400 --> 00:17:25,039
the state restoration weakness extended

448
00:17:25,039 --> 00:17:28,559
emulation advantage is upper bounded by

449
00:17:28,559 --> 00:17:32,480
ah t epsilon uh plus the probability

450
00:17:32,480 --> 00:17:33,520
that

451
00:17:33,520 --> 00:17:34,640
little e

452
00:17:34,640 --> 00:17:36,960
fails to extract a witness on a good

453
00:17:36,960 --> 00:17:39,679
accepting path

454
00:17:39,760 --> 00:17:41,919
generally for arguments uh the

455
00:17:41,919 --> 00:17:44,400
probability of little e failing is going

456
00:17:44,400 --> 00:17:46,160
to be related to the probability of

457
00:17:46,160 --> 00:17:49,280
violating some assumption

458
00:17:50,320 --> 00:17:52,320
we apply this framework to some

459
00:17:52,320 --> 00:17:54,559
protocols

460
00:17:54,559 --> 00:17:56,880
we first apply it to bullet proof's

461
00:17:56,880 --> 00:17:59,280
range proof which is an argument of

462
00:17:59,280 --> 00:18:02,080
knowledge of opening of a

463
00:18:02,080 --> 00:18:04,400
person commitment to a value in the

464
00:18:04,400 --> 00:18:08,320
range 0 to 2 power n minus 1.

465
00:18:08,320 --> 00:18:10,400
for this argument we show that there

466
00:18:10,400 --> 00:18:12,799
exists an extractor such therefore any

467
00:18:12,799 --> 00:18:15,360
cheat improver running in time t its

468
00:18:15,360 --> 00:18:17,280
state restoration witness extended

469
00:18:17,280 --> 00:18:19,039
emulation advantage

470
00:18:19,039 --> 00:18:21,440
uh with respect to the extractor

471
00:18:21,440 --> 00:18:24,960
is upper bounded by the

472
00:18:25,039 --> 00:18:26,720
discrete logarithm advantage of an

473
00:18:26,720 --> 00:18:31,440
adversary in the group running in time t

474
00:18:31,440 --> 00:18:33,280
plus a small term that grows only

475
00:18:33,280 --> 00:18:35,520
linearly

476
00:18:35,520 --> 00:18:37,840
for bullet proofs our argument for

477
00:18:37,840 --> 00:18:39,440
arithmetic circuit satisfiability we

478
00:18:39,440 --> 00:18:41,520
prove a similar result

479
00:18:41,520 --> 00:18:43,679
and likewise

480
00:18:43,679 --> 00:18:44,799
for

481
00:18:44,799 --> 00:18:45,840
sonic

482
00:18:45,840 --> 00:18:49,760
argument for ethnic survey satisfaction

483
00:18:50,080 --> 00:18:53,039
we show that our bounds are tight by

484
00:18:53,039 --> 00:18:56,840
giving matching attacks

485
00:18:57,120 --> 00:18:58,720
prior work by

486
00:18:58,720 --> 00:19:00,880
jaeger and tessaro analyze the concrete

487
00:19:00,880 --> 00:19:03,120
security of bulletproof's argument for

488
00:19:03,120 --> 00:19:05,280
arithmetic circuit satisfiability

489
00:19:05,280 --> 00:19:08,880
uh only in the interactive study

490
00:19:08,880 --> 00:19:11,039
our bounds for the interactive protocol

491
00:19:11,039 --> 00:19:12,320
are better

492
00:19:12,320 --> 00:19:14,000
even though we prove a stronger

493
00:19:14,000 --> 00:19:15,600
soundness motion

494
00:19:15,600 --> 00:19:18,080
in order to compare we translate our

495
00:19:18,080 --> 00:19:19,360
bounds to

496
00:19:19,360 --> 00:19:22,000
the generic group model and see that

497
00:19:22,000 --> 00:19:24,000
we get security guarantees against

498
00:19:24,000 --> 00:19:25,760
adversaries running in

499
00:19:25,760 --> 00:19:28,879
much longer time

500
00:19:30,080 --> 00:19:31,919
finally i would like to give a high

501
00:19:31,919 --> 00:19:34,480
level idea of how we instantiate our

502
00:19:34,480 --> 00:19:36,880
framework for specific protocols through

503
00:19:36,880 --> 00:19:39,919
the example of bulletproofs

504
00:19:39,919 --> 00:19:42,000
this is a complicated protocol

505
00:19:42,000 --> 00:19:44,640
it turns out however that to understand

506
00:19:44,640 --> 00:19:46,799
some of our basic ideas you do not need

507
00:19:46,799 --> 00:19:49,039
to understand all the details of how

508
00:19:49,039 --> 00:19:52,080
bulletins work

509
00:19:52,080 --> 00:19:54,799
ah the main ingredient in bulk bruce is

510
00:19:54,799 --> 00:19:57,840
an elegant inner product argument

511
00:19:57,840 --> 00:20:00,240
for this argument the input is a group

512
00:20:00,240 --> 00:20:03,039
element q and a scalar t hat

513
00:20:03,039 --> 00:20:04,720
the approver proves knowledge of two

514
00:20:04,720 --> 00:20:06,559
vectors l and r

515
00:20:06,559 --> 00:20:09,760
such that ah q is a commitment to lnr

516
00:20:09,760 --> 00:20:10,880
and

517
00:20:10,880 --> 00:20:15,840
the inner product of l and r is t hat

518
00:20:17,919 --> 00:20:20,400
in all instantiation of instantiations

519
00:20:20,400 --> 00:20:23,600
of blitz rules to prove

520
00:20:23,600 --> 00:20:25,679
knowledge of a witness for an np

521
00:20:25,679 --> 00:20:26,960
relation

522
00:20:26,960 --> 00:20:29,440
we reduce this to an instance of the

523
00:20:29,440 --> 00:20:31,679
inner product argument and then run the

524
00:20:31,679 --> 00:20:33,360
inner product argument on the particular

525
00:20:33,360 --> 00:20:35,840
instance

526
00:20:37,039 --> 00:20:38,720
there are a couple of important points

527
00:20:38,720 --> 00:20:41,039
worth noting uh about analyzing

528
00:20:41,039 --> 00:20:43,760
bulletproofs in our framework

529
00:20:43,760 --> 00:20:46,080
the first one is that there is no easy

530
00:20:46,080 --> 00:20:48,960
composition in the agm

531
00:20:48,960 --> 00:20:50,799
you would think that it would be enough

532
00:20:50,799 --> 00:20:52,640
to analyze the inner product argument in

533
00:20:52,640 --> 00:20:53,919
isolation

534
00:20:53,919 --> 00:20:56,000
first and then compose it with the

535
00:20:56,000 --> 00:20:58,320
analysis with the uh

536
00:20:58,320 --> 00:21:00,720
of the other sub product

537
00:21:00,720 --> 00:21:03,280
but this model approach is not possible

538
00:21:03,280 --> 00:21:04,960
ah because the representation of the

539
00:21:04,960 --> 00:21:06,720
group elements in the inner product

540
00:21:06,720 --> 00:21:09,120
argument run in isolation

541
00:21:09,120 --> 00:21:10,960
is different from the representation of

542
00:21:10,960 --> 00:21:12,480
group elements when run as a sub

543
00:21:12,480 --> 00:21:17,240
protocol for bullet proof instantiations

544
00:21:17,440 --> 00:21:18,799
the second

545
00:21:18,799 --> 00:21:21,840
point is that extraction strategies for

546
00:21:21,840 --> 00:21:23,600
different instantiations of grid crews

547
00:21:23,600 --> 00:21:24,960
is different

548
00:21:24,960 --> 00:21:27,039
for example in the range proof the

549
00:21:27,039 --> 00:21:29,039
instance is a group element provided by

550
00:21:29,039 --> 00:21:31,440
the approval and the extractor can

551
00:21:31,440 --> 00:21:32,799
directly

552
00:21:32,799 --> 00:21:35,840
extract from the representation

553
00:21:35,840 --> 00:21:37,760
but for the argument of knowledge for

554
00:21:37,760 --> 00:21:39,520
arithmetic circuit satisfiability the

555
00:21:39,520 --> 00:21:42,080
input has no group elements and we need

556
00:21:42,080 --> 00:21:45,200
to use a different strategy

557
00:21:45,200 --> 00:21:47,360
here you just heard something that might

558
00:21:47,360 --> 00:21:49,120
appear to make the problem trivial

559
00:21:49,120 --> 00:21:51,200
namely for protocols where the instance

560
00:21:51,200 --> 00:21:52,720
is a group element

561
00:21:52,720 --> 00:21:54,799
the agm basically

562
00:21:54,799 --> 00:21:57,039
includes in the input a representation

563
00:21:57,039 --> 00:21:58,480
which might directly give out the

564
00:21:58,480 --> 00:22:00,480
witness

565
00:22:00,480 --> 00:22:02,080
for example the bullet cruise range

566
00:22:02,080 --> 00:22:04,400
proof is an argument of knowledge of

567
00:22:04,400 --> 00:22:07,679
opening of paris and commitment

568
00:22:07,679 --> 00:22:10,240
c to a value x in the range 0 to power n

569
00:22:10,240 --> 00:22:12,080
minus 1.

570
00:22:12,080 --> 00:22:14,000
the instance of the protocol is the

571
00:22:14,000 --> 00:22:16,559
group element c and the generators here

572
00:22:16,559 --> 00:22:19,520
are g and h

573
00:22:19,760 --> 00:22:22,960
so the adaptive algebraic prover will

574
00:22:22,960 --> 00:22:25,280
provide a representation of c in terms

575
00:22:25,280 --> 00:22:27,679
of g and h

576
00:22:27,679 --> 00:22:30,159
now the function little e will just

577
00:22:30,159 --> 00:22:32,000
return

578
00:22:32,000 --> 00:22:33,919
the representation of c

579
00:22:33,919 --> 00:22:37,200
this seems very simple are we done

580
00:22:37,200 --> 00:22:38,880
ah the cat

581
00:22:38,880 --> 00:22:42,000
here is that we are not guaranteed that

582
00:22:42,000 --> 00:22:44,960
x is in the range

583
00:22:44,960 --> 00:22:45,919
in fact

584
00:22:45,919 --> 00:22:48,000
the technical core of the proof boils

585
00:22:48,000 --> 00:22:50,159
down to showing that if the algebraic

586
00:22:50,159 --> 00:22:52,080
cheating prover produces a good

587
00:22:52,080 --> 00:22:53,760
accepting

588
00:22:53,760 --> 00:22:56,559
and if x is not in the range

589
00:22:56,559 --> 00:22:59,919
we can break discrete log

590
00:22:59,919 --> 00:23:02,480
we also have an analysis for the same

591
00:23:02,480 --> 00:23:04,480
protocol in the context of non-inductive

592
00:23:04,480 --> 00:23:06,159
provers

593
00:23:06,159 --> 00:23:08,000
in that case we have to extract from

594
00:23:08,000 --> 00:23:10,400
somewhere else since the instance is not

595
00:23:10,400 --> 00:23:13,200
supplied by the algebraic approval

596
00:23:13,200 --> 00:23:15,120
and hence we need to give a more

597
00:23:15,120 --> 00:23:16,880
complicated proof which involves

598
00:23:16,880 --> 00:23:19,440
rewinding

599
00:23:20,720 --> 00:23:22,400
even if i have overwhelmed you in this

600
00:23:22,400 --> 00:23:25,360
talk and you want to walk away with one

601
00:23:25,360 --> 00:23:28,240
line uh it would be that it is essential

602
00:23:28,240 --> 00:23:29,760
to analyze the state restriction

603
00:23:29,760 --> 00:23:31,840
soundness of interactive protocols when

604
00:23:31,840 --> 00:23:35,280
using the feared trauma transform

605
00:23:35,280 --> 00:23:38,080
finally let me conclude by stating some

606
00:23:38,080 --> 00:23:40,799
of the related open problems ah an

607
00:23:40,799 --> 00:23:44,559
interesting direction of future work is

608
00:23:44,559 --> 00:23:46,320
proving state restriction soundness for

609
00:23:46,320 --> 00:23:48,799
more protocols specifically those which

610
00:23:48,799 --> 00:23:51,840
are not based on groups

611
00:23:52,000 --> 00:23:54,320
uh proving a non-trivial bound for state

612
00:23:54,320 --> 00:23:56,240
restriction soundness of any argument in

613
00:23:56,240 --> 00:23:58,159
the standard model is a very important

614
00:23:58,159 --> 00:23:59,840
problem

615
00:23:59,840 --> 00:24:02,240
ah another interesting open problem uh

616
00:24:02,240 --> 00:24:04,240
is extending our framework to allow

617
00:24:04,240 --> 00:24:07,919
modular analysis in the agm

618
00:24:07,919 --> 00:24:09,440
the full version of our paper is a new

619
00:24:09,440 --> 00:24:10,799
print

620
00:24:10,799 --> 00:24:14,039
thank you

