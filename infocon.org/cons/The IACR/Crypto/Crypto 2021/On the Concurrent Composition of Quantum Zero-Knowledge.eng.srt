1
00:00:01,920 --> 00:00:04,080
hi i am prahanjan

2
00:00:04,080 --> 00:00:05,759
and i am going to talk about

3
00:00:05,759 --> 00:00:07,759
quantum zero knowledge in the concurrent

4
00:00:07,759 --> 00:00:10,240
composition setting

5
00:00:10,240 --> 00:00:12,799
this is in joint work with kaimen chung

6
00:00:12,799 --> 00:00:16,599
and rolando laplaca

7
00:00:16,720 --> 00:00:18,720
zero knowledge is a notion that we are

8
00:00:18,720 --> 00:00:20,160
all familiar with

9
00:00:20,160 --> 00:00:21,439
the traditional notion of generalized

10
00:00:21,439 --> 00:00:23,680
stipulates that the conversation between

11
00:00:23,680 --> 00:00:26,800
approver and a verifier can be simulated

12
00:00:26,800 --> 00:00:28,640
in other words

13
00:00:28,640 --> 00:00:30,160
the verifier doesn't learn any

14
00:00:30,160 --> 00:00:32,159
additional information

15
00:00:32,159 --> 00:00:35,199
after talking to the prover

16
00:00:35,520 --> 00:00:37,120
you know in most protocols we have seen

17
00:00:37,120 --> 00:00:38,719
so far the assumption is that the

18
00:00:38,719 --> 00:00:42,960
verifier is a classical ppt algorithm

19
00:00:43,200 --> 00:00:45,520
however this assumption has been

20
00:00:45,520 --> 00:00:47,600
challenged

21
00:00:47,600 --> 00:00:50,320
by the prospect of quantum computers

22
00:00:50,320 --> 00:00:53,039
in the last few years

23
00:00:53,039 --> 00:00:55,280
some companies and many governments have

24
00:00:55,280 --> 00:00:57,440
intensified efforts towards building

25
00:00:57,440 --> 00:00:59,520
quantum computers

26
00:00:59,520 --> 00:01:00,480
in the

27
00:01:00,480 --> 00:01:02,399
next few decades we need to brace

28
00:01:02,399 --> 00:01:03,840
ourselves towards the possibility that

29
00:01:03,840 --> 00:01:07,920
quantum computers could become a reality

30
00:01:07,920 --> 00:01:09,840
and towards this we need to start

31
00:01:09,840 --> 00:01:11,439
thinking about designing protocols that

32
00:01:11,439 --> 00:01:13,920
are secure even after quantum computers

33
00:01:13,920 --> 00:01:16,320
come into existence

34
00:01:16,320 --> 00:01:18,479
so we're going to look at one such

35
00:01:18,479 --> 00:01:20,880
protocol which is you know

36
00:01:20,880 --> 00:01:22,159
we're going to look at one such notion

37
00:01:22,159 --> 00:01:23,520
which is the notion of quantum zero

38
00:01:23,520 --> 00:01:25,600
knowledge

39
00:01:25,600 --> 00:01:27,119
so this notion is a

40
00:01:27,119 --> 00:01:29,040
is an analog of zero knowledge in the

41
00:01:29,040 --> 00:01:30,479
quantum setting

42
00:01:30,479 --> 00:01:32,159
and it roughly says that the

43
00:01:32,159 --> 00:01:34,880
conversation between approver and a

44
00:01:34,880 --> 00:01:36,880
quantum verifier

45
00:01:36,880 --> 00:01:41,560
can be simulated by a quantum simulator

46
00:01:43,280 --> 00:01:45,280
this notion is not new i mean people

47
00:01:45,280 --> 00:01:47,680
have actually looked at

48
00:01:47,680 --> 00:01:50,399
quantum zero knowledge protocols

49
00:01:50,399 --> 00:01:52,799
but they're mostly focused on standalone

50
00:01:52,799 --> 00:01:55,119
quantum zero noise protocols

51
00:01:55,119 --> 00:01:56,880
in the setting we assume that there is a

52
00:01:56,880 --> 00:01:59,439
prover and a verifier

53
00:01:59,439 --> 00:02:02,479
um and uh you know the execution between

54
00:02:02,479 --> 00:02:04,000
the prover and this verifier is run in

55
00:02:04,000 --> 00:02:06,079
isolation so in other words you know the

56
00:02:06,079 --> 00:02:07,439
prover is talking to this verifier then

57
00:02:07,439 --> 00:02:10,560
it cannot talk to any other verifier

58
00:02:10,560 --> 00:02:13,280
during this time

59
00:02:13,440 --> 00:02:15,200
so the good news is that there are some

60
00:02:15,200 --> 00:02:17,520
feasibility results now so we do know

61
00:02:17,520 --> 00:02:21,120
how to achieve the standalone qck

62
00:02:21,120 --> 00:02:23,520
however this is not a very realistic

63
00:02:23,520 --> 00:02:24,480
setting

64
00:02:24,480 --> 00:02:25,599
um

65
00:02:25,599 --> 00:02:26,800
so if you think about it it's not

66
00:02:26,800 --> 00:02:28,480
reasonable to assume that you know

67
00:02:28,480 --> 00:02:30,319
approver only talks to one verifier at a

68
00:02:30,319 --> 00:02:31,519
time

69
00:02:31,519 --> 00:02:32,480
uh

70
00:02:32,480 --> 00:02:33,680
in the real world setting you know you

71
00:02:33,680 --> 00:02:34,800
have

72
00:02:34,800 --> 00:02:37,040
you could have a you know maybe like a

73
00:02:37,040 --> 00:02:38,879
server who's running um

74
00:02:38,879 --> 00:02:40,480
who's taking the role of the brewer you

75
00:02:40,480 --> 00:02:42,720
know talking to many clients who are

76
00:02:42,720 --> 00:02:45,280
taking the role of verifiers

77
00:02:45,280 --> 00:02:47,920
at the same time

78
00:02:49,599 --> 00:02:51,200
so more realistic setting that we can

79
00:02:51,200 --> 00:02:54,879
consider is uh concurrency

80
00:02:54,879 --> 00:02:57,200
so in this setting we have

81
00:02:57,200 --> 00:02:58,239
a prover

82
00:02:58,239 --> 00:03:00,400
talking to multiple verifiers at the

83
00:03:00,400 --> 00:03:02,159
same time

84
00:03:02,159 --> 00:03:04,400
and these verifiers can interleave their

85
00:03:04,400 --> 00:03:05,760
messages with the prover in any

86
00:03:05,760 --> 00:03:08,640
arbitrary fashion

87
00:03:08,879 --> 00:03:10,480
um you know maybe you know there's one

88
00:03:10,480 --> 00:03:12,080
verifier who starts the execution with

89
00:03:12,080 --> 00:03:13,120
approver

90
00:03:13,120 --> 00:03:15,360
uh and before this verifier sends its

91
00:03:15,360 --> 00:03:17,200
second message maybe

92
00:03:17,200 --> 00:03:18,800
another verifier starts talking to this

93
00:03:18,800 --> 00:03:21,120
proverb

94
00:03:21,280 --> 00:03:22,879
and we want the notion of

95
00:03:22,879 --> 00:03:26,959
zero knowledge to even hold in this city

96
00:03:29,200 --> 00:03:30,959
you know and the

97
00:03:30,959 --> 00:03:33,440
the notion of

98
00:03:33,440 --> 00:03:36,239
q z k in the concurrent setting

99
00:03:36,239 --> 00:03:39,920
will be called as uh concurrent qck

100
00:03:39,920 --> 00:03:41,840
and unfortunately we don't know much

101
00:03:41,840 --> 00:03:42,799
about

102
00:03:42,799 --> 00:03:43,760
uh

103
00:03:43,760 --> 00:03:46,799
the possibility or impossibility of

104
00:03:46,799 --> 00:03:48,400
qck in the concurrent composition

105
00:03:48,400 --> 00:03:50,720
setting

106
00:03:51,680 --> 00:03:53,519
but if you look at the classical

107
00:03:53,519 --> 00:03:56,000
cryptography literature there are

108
00:03:56,000 --> 00:03:59,120
many many works on uh you know

109
00:03:59,120 --> 00:04:03,920
on on the feasibility of concurrent ck

110
00:04:04,159 --> 00:04:07,200
so before we try to understand the uh

111
00:04:07,200 --> 00:04:08,799
feasibility of cusick in the concurrent

112
00:04:08,799 --> 00:04:11,840
composition setting let's first try to

113
00:04:11,840 --> 00:04:16,959
formally define what concurrent qc is

114
00:04:18,560 --> 00:04:22,479
so in order to do that we need to define

115
00:04:22,479 --> 00:04:24,080
what is a malicious

116
00:04:24,080 --> 00:04:26,880
how does a malicious verifier behave

117
00:04:26,880 --> 00:04:28,800
so in this case the malicious verifier

118
00:04:28,800 --> 00:04:30,800
is a qpt algorithm

119
00:04:30,800 --> 00:04:33,440
let me denote this by v star

120
00:04:33,440 --> 00:04:34,800
and we're going to work in the setting

121
00:04:34,800 --> 00:04:37,680
where the verifier can be non-uniform

122
00:04:37,680 --> 00:04:39,120
so in other words it can take as input

123
00:04:39,120 --> 00:04:40,960
in auxiliary state

124
00:04:40,960 --> 00:04:44,560
this auxiliary state denoted here by rho

125
00:04:44,560 --> 00:04:46,080
can be thought of as

126
00:04:46,080 --> 00:04:47,199
you know

127
00:04:47,199 --> 00:04:48,960
a quantum state

128
00:04:48,960 --> 00:04:52,160
that has a polynomial number of qubits

129
00:04:52,160 --> 00:04:55,040
and this verified restar can invoke

130
00:04:55,040 --> 00:04:57,600
queue sessions or queue verifiers with

131
00:04:57,600 --> 00:04:59,919
the prover p so with the honest proverb

132
00:04:59,919 --> 00:05:02,080
p

133
00:05:02,720 --> 00:05:04,720
and the sessions are denoted by v1

134
00:05:04,720 --> 00:05:07,280
through vq

135
00:05:09,199 --> 00:05:11,199
okay so

136
00:05:11,199 --> 00:05:12,320
to

137
00:05:12,320 --> 00:05:14,240
be a little more precise about how the

138
00:05:14,240 --> 00:05:16,240
interaction between the prover and the

139
00:05:16,240 --> 00:05:18,320
verified restart goes

140
00:05:18,320 --> 00:05:20,400
so we can think of

141
00:05:20,400 --> 00:05:23,120
every message computed by vstar to be

142
00:05:23,120 --> 00:05:24,880
let's say unitary

143
00:05:24,880 --> 00:05:26,880
uh followed by a measurement where this

144
00:05:26,880 --> 00:05:29,039
measurement determines the message to be

145
00:05:29,039 --> 00:05:31,039
sent to the proverb

146
00:05:31,039 --> 00:05:32,639
right and then we can think of every

147
00:05:32,639 --> 00:05:34,639
message we start sends to be of the

148
00:05:34,639 --> 00:05:36,160
following format

149
00:05:36,160 --> 00:05:37,199
so it's

150
00:05:37,199 --> 00:05:38,720
message one corresponding to the first

151
00:05:38,720 --> 00:05:40,160
session message two corresponding to the

152
00:05:40,160 --> 00:05:41,840
second section and so on

153
00:05:41,840 --> 00:05:43,759
uh and then we have q comma message q

154
00:05:43,759 --> 00:05:46,320
where q is the number of sessions

155
00:05:46,320 --> 00:05:48,000
and then you can do this for

156
00:05:48,000 --> 00:05:51,320
all the messages

157
00:05:52,639 --> 00:05:53,440
and

158
00:05:53,440 --> 00:05:54,400
you know

159
00:05:54,400 --> 00:05:56,720
not all sessions need to

160
00:05:56,720 --> 00:05:58,400
you know uh

161
00:05:58,400 --> 00:06:00,400
be active in any round

162
00:06:00,400 --> 00:06:03,680
um so for example the ayat session can

163
00:06:03,680 --> 00:06:05,680
choose not to you know send any message

164
00:06:05,680 --> 00:06:08,319
to the prover uh in some round

165
00:06:08,319 --> 00:06:10,880
in this case it will set the message

166
00:06:10,880 --> 00:06:13,199
message i to be empty

167
00:06:13,199 --> 00:06:14,160
which

168
00:06:14,160 --> 00:06:15,600
which we are going to interpret as

169
00:06:15,600 --> 00:06:16,960
saying that the i verifier is not

170
00:06:16,960 --> 00:06:21,159
sending any message in this round

171
00:06:21,840 --> 00:06:23,360
and

172
00:06:23,360 --> 00:06:25,280
we say that a protocol satisfies

173
00:06:25,280 --> 00:06:27,120
concurrent qck if there exists a

174
00:06:27,120 --> 00:06:28,720
simulator such that the following two

175
00:06:28,720 --> 00:06:30,639
distributions are indistinguishable now

176
00:06:30,639 --> 00:06:32,319
the output of the verifier you know

177
00:06:32,319 --> 00:06:33,840
after it interacts with the honest

178
00:06:33,840 --> 00:06:34,800
brewer

179
00:06:34,800 --> 00:06:36,639
uh you know the output of the verifier v

180
00:06:36,639 --> 00:06:38,479
star is going to be some state

181
00:06:38,479 --> 00:06:40,160
we want this state to be

182
00:06:40,160 --> 00:06:42,960
uh computationally indistinguishable

183
00:06:42,960 --> 00:06:44,400
or rather like a distribution of states

184
00:06:44,400 --> 00:06:46,479
to be computationally indistinguishable

185
00:06:46,479 --> 00:06:48,880
from the uh

186
00:06:48,880 --> 00:06:50,240
the the

187
00:06:50,240 --> 00:06:52,160
the distribution specified by the

188
00:06:52,160 --> 00:06:54,160
simulator right

189
00:06:54,160 --> 00:06:57,039
um so the output of the simulator uh

190
00:06:57,039 --> 00:06:58,880
describes a distribution and we want uh

191
00:06:58,880 --> 00:06:59,840
this distribution to be

192
00:06:59,840 --> 00:07:01,840
indistinguishable from the output of the

193
00:07:01,840 --> 00:07:04,239
verifier

194
00:07:04,479 --> 00:07:07,199
so it's the same uh as as uh

195
00:07:07,199 --> 00:07:09,440
classical zk except that you know the

196
00:07:09,440 --> 00:07:11,039
algorithms here

197
00:07:11,039 --> 00:07:12,319
are quantum

198
00:07:12,319 --> 00:07:17,160
and and also the advice is quantum

199
00:07:18,160 --> 00:07:20,479
there are two notions of concurrent qck

200
00:07:20,479 --> 00:07:22,160
that we can consider one is bounded

201
00:07:22,160 --> 00:07:24,240
concurrency and another one is unbounded

202
00:07:24,240 --> 00:07:26,479
concurrency right so in in bounded

203
00:07:26,479 --> 00:07:28,960
concurrency the number of sessions q

204
00:07:28,960 --> 00:07:30,960
needs to be fixed a priori like even

205
00:07:30,960 --> 00:07:32,800
before the protocol begins

206
00:07:32,800 --> 00:07:34,800
uh in the case of unburdened concurrency

207
00:07:34,800 --> 00:07:35,840
you know the

208
00:07:35,840 --> 00:07:37,599
verifier the malicious verifier can

209
00:07:37,599 --> 00:07:39,759
choose how many sessions to run

210
00:07:39,759 --> 00:07:40,800
um

211
00:07:40,800 --> 00:07:41,680
you know at the beginning of the

212
00:07:41,680 --> 00:07:43,360
security experiment so it need not be

213
00:07:43,360 --> 00:07:44,720
specified as part of the protocol

214
00:07:44,720 --> 00:07:47,199
description

215
00:07:48,479 --> 00:07:50,639
so we can also consider another weaker

216
00:07:50,639 --> 00:07:53,520
notion which is parallel qck

217
00:07:53,520 --> 00:07:55,919
um so in in the parallel setting we want

218
00:07:55,919 --> 00:07:57,599
all the verifiers to send the messages

219
00:07:57,599 --> 00:08:00,240
at the same time

220
00:08:00,720 --> 00:08:02,560
while this is not the

221
00:08:02,560 --> 00:08:04,400
most

222
00:08:04,400 --> 00:08:06,319
useful notion in practice

223
00:08:06,319 --> 00:08:08,879
uh parallel zika is still useful for

224
00:08:08,879 --> 00:08:13,400
constructing let's say mpc protocols

225
00:08:15,440 --> 00:08:17,759
okay so let's let me

226
00:08:17,759 --> 00:08:18,720
give a

227
00:08:18,720 --> 00:08:20,960
an overview of our results so we

228
00:08:20,960 --> 00:08:22,720
initiate a formal study of concurrent

229
00:08:22,720 --> 00:08:24,400
qck

230
00:08:24,400 --> 00:08:27,039
we give a feasibility result of bounded

231
00:08:27,039 --> 00:08:29,840
concurrent qck for uh all languages in

232
00:08:29,840 --> 00:08:31,520
np

233
00:08:31,520 --> 00:08:32,399
and

234
00:08:32,399 --> 00:08:35,599
we actually show how to get

235
00:08:35,599 --> 00:08:38,320
quantum proof proof of knowledge for np

236
00:08:38,320 --> 00:08:39,519
um

237
00:08:39,519 --> 00:08:41,839
and finally we also show feasibility of

238
00:08:41,839 --> 00:08:44,159
bounded concurrent qck for

239
00:08:44,159 --> 00:08:49,440
uh qma so qma is a quantum analog of m a

240
00:08:49,440 --> 00:08:50,399
so

241
00:08:50,399 --> 00:08:52,320
we say that a relation is qmi relation

242
00:08:52,320 --> 00:08:53,519
if

243
00:08:53,519 --> 00:08:54,959
you know for

244
00:08:54,959 --> 00:08:55,920
every

245
00:08:55,920 --> 00:08:58,880
instance boolean uh string let's say x

246
00:08:58,880 --> 00:09:01,279
we say x comma some state belongs to

247
00:09:01,279 --> 00:09:02,480
this relation

248
00:09:02,480 --> 00:09:04,320
uh if there is a quantum algorithm

249
00:09:04,320 --> 00:09:06,080
quantum polynomial time algorithm that

250
00:09:06,080 --> 00:09:07,839
on input this instance and the state

251
00:09:07,839 --> 00:09:12,080
outputs are one with high probability

252
00:09:13,200 --> 00:09:15,600
so it's in ma the witness is

253
00:09:15,600 --> 00:09:17,680
classical in qma the witness can be

254
00:09:17,680 --> 00:09:21,959
quantum so that's that's the difference

255
00:09:23,040 --> 00:09:25,440
um so i'm not going to elaborate on the

256
00:09:25,440 --> 00:09:26,640
quantum proof of knowledge and the

257
00:09:26,640 --> 00:09:29,360
bounded concurrent qck for qma results

258
00:09:29,360 --> 00:09:32,320
uh i encourage you to look at the paper

259
00:09:32,320 --> 00:09:33,519
so for the rest of the talk i'm going to

260
00:09:33,519 --> 00:09:34,880
focus on the feasibility of bounded

261
00:09:34,880 --> 00:09:38,160
concurrent qsyk for np

262
00:09:38,399 --> 00:09:39,440
okay so

263
00:09:39,440 --> 00:09:41,360
let me zoom in on this and expand on

264
00:09:41,360 --> 00:09:43,120
this result statement so we show that

265
00:09:43,120 --> 00:09:44,880
there exists bounded concurrent qck for

266
00:09:44,880 --> 00:09:46,000
np

267
00:09:46,000 --> 00:09:47,760
assuming

268
00:09:47,760 --> 00:09:49,360
the existence of post quantum only

269
00:09:49,360 --> 00:09:51,839
functions

270
00:09:52,320 --> 00:09:55,040
and two nice features about our protocol

271
00:09:55,040 --> 00:09:57,760
is that first of all it's a public coin

272
00:09:57,760 --> 00:09:59,200
protocol and moreover it's a proof

273
00:09:59,200 --> 00:10:01,279
system that is the soundness holds

274
00:10:01,279 --> 00:10:05,399
against unbounded provers

275
00:10:05,680 --> 00:10:07,760
so we know that

276
00:10:07,760 --> 00:10:10,720
there you know there was a prior work on

277
00:10:10,720 --> 00:10:13,279
bounded parallel qck argument system for

278
00:10:13,279 --> 00:10:15,360
np from fhe for quantum computation

279
00:10:15,360 --> 00:10:16,720
which is going to appear in eurocrypt

280
00:10:16,720 --> 00:10:19,760
this year so our work improves upon

281
00:10:19,760 --> 00:10:22,240
their result in terms of assumption also

282
00:10:22,240 --> 00:10:23,440
we get the

283
00:10:23,440 --> 00:10:24,800
stronger stronger notion of bonded

284
00:10:24,800 --> 00:10:27,680
concurrent qck

285
00:10:28,240 --> 00:10:32,240
let's dive right into the techniques

286
00:10:32,240 --> 00:10:34,000
a natural approach that we can consider

287
00:10:34,000 --> 00:10:35,519
is the following

288
00:10:35,519 --> 00:10:37,040
so we can start with

289
00:10:37,040 --> 00:10:39,519
a classical bounded concurrent zk for np

290
00:10:39,519 --> 00:10:41,600
so we do know how to achieve this so

291
00:10:41,600 --> 00:10:43,360
let's start with the construction that

292
00:10:43,360 --> 00:10:44,880
we know

293
00:10:44,880 --> 00:10:47,920
and then what we can do is you know try

294
00:10:47,920 --> 00:10:50,399
to come up with a

295
00:10:50,399 --> 00:10:52,079
a different proof for the same

296
00:10:52,079 --> 00:10:53,680
construction that proves that this

297
00:10:53,680 --> 00:10:55,440
construction is actually

298
00:10:55,440 --> 00:10:57,200
secure against quantum verifiers and not

299
00:10:57,200 --> 00:10:59,040
just classical verifiers

300
00:10:59,040 --> 00:11:00,240
so in order to do that you know we need

301
00:11:00,240 --> 00:11:01,680
to figure out a

302
00:11:01,680 --> 00:11:03,600
way to port the classical simulation

303
00:11:03,600 --> 00:11:06,160
strategy to quantum um to quantum

304
00:11:06,160 --> 00:11:07,760
stimulation

305
00:11:07,760 --> 00:11:09,040
right and we're going to focus on

306
00:11:09,040 --> 00:11:13,560
rewinding based simulation strategies

307
00:11:14,160 --> 00:11:16,160
so and towards this you know we can ask

308
00:11:16,160 --> 00:11:18,240
a more general question uh what are the

309
00:11:18,240 --> 00:11:20,240
classical rewinding techniques that can

310
00:11:20,240 --> 00:11:23,600
be ported to the quantum setting

311
00:11:24,240 --> 00:11:25,360
so we can

312
00:11:25,360 --> 00:11:28,320
identify a quote and quote

313
00:11:28,320 --> 00:11:30,320
quantum friendly classical rewinding

314
00:11:30,320 --> 00:11:33,200
techniques these are the techniques that

315
00:11:33,200 --> 00:11:34,720
can actually be ported to the quantum

316
00:11:34,720 --> 00:11:36,480
setting these are classical techniques

317
00:11:36,480 --> 00:11:37,680
but that can be

318
00:11:37,680 --> 00:11:40,079
adapted to the quantum setting

319
00:11:40,079 --> 00:11:42,880
and a rule of thumb that we can

320
00:11:42,880 --> 00:11:43,839
adopt

321
00:11:43,839 --> 00:11:46,560
um for identifying this class of quantum

322
00:11:46,560 --> 00:11:48,480
friendly classical rewinding techniques

323
00:11:48,480 --> 00:11:50,720
is the following

324
00:11:50,720 --> 00:11:52,160
so we can first

325
00:11:52,160 --> 00:11:54,399
ask if the classical rewinding technique

326
00:11:54,399 --> 00:11:57,680
is oblivious what do i mean

327
00:11:57,680 --> 00:12:00,480
you know in any round the simulator can

328
00:12:00,480 --> 00:12:02,240
you know decide whether it wants to

329
00:12:02,240 --> 00:12:03,680
rewind or not

330
00:12:03,680 --> 00:12:05,839
and we want the property that

331
00:12:05,839 --> 00:12:08,160
you know at any point in time the

332
00:12:08,160 --> 00:12:09,440
simulators

333
00:12:09,440 --> 00:12:11,839
the distribution on simulator's

334
00:12:11,839 --> 00:12:13,680
decisions should be independent of the

335
00:12:13,680 --> 00:12:15,680
verified state so it should be the same

336
00:12:15,680 --> 00:12:17,760
no matter what auxiliary state the

337
00:12:17,760 --> 00:12:19,519
verifier has so this is the first

338
00:12:19,519 --> 00:12:21,279
condition

339
00:12:21,279 --> 00:12:24,800
see the other condition is that we want

340
00:12:24,800 --> 00:12:26,959
the simulator to be no recording what

341
00:12:26,959 --> 00:12:29,519
does it mean it means that

342
00:12:29,519 --> 00:12:31,440
the simulator you know should not learn

343
00:12:31,440 --> 00:12:33,440
some information

344
00:12:33,440 --> 00:12:35,200
and then rewind

345
00:12:35,200 --> 00:12:36,959
and then you know continue to use the

346
00:12:36,959 --> 00:12:39,200
information that it had gathered from a

347
00:12:39,200 --> 00:12:40,800
previous rewinding for for future

348
00:12:40,800 --> 00:12:42,880
rewindings

349
00:12:42,880 --> 00:12:45,040
so this is the other sort of uh

350
00:12:45,040 --> 00:12:47,360
guarantee we need

351
00:12:47,360 --> 00:12:48,399
so you might think that these two

352
00:12:48,399 --> 00:12:50,480
properties are sort of artificial and

353
00:12:50,480 --> 00:12:52,560
you can ask whether do we know any

354
00:12:52,560 --> 00:12:54,240
classical rewinding that satisfies these

355
00:12:54,240 --> 00:12:55,440
two properties

356
00:12:55,440 --> 00:12:58,079
and the answer is yes there are actually

357
00:12:58,079 --> 00:13:00,560
protocols that satisfy both these there

358
00:13:00,560 --> 00:13:01,920
are actually techniques that satisfy

359
00:13:01,920 --> 00:13:03,360
both these properties

360
00:13:03,360 --> 00:13:04,959
so if you look at the

361
00:13:04,959 --> 00:13:08,000
um the simulator of

362
00:13:08,000 --> 00:13:10,800
the popular graph isomorphism protocol

363
00:13:10,800 --> 00:13:12,160
you can show that that particular

364
00:13:12,160 --> 00:13:13,519
simulator satisfies both these

365
00:13:13,519 --> 00:13:15,279
properties

366
00:13:15,279 --> 00:13:16,639
you know there are other examples as

367
00:13:16,639 --> 00:13:18,399
well so this is the

368
00:13:18,399 --> 00:13:20,639
um this is sort of like the prototypical

369
00:13:20,639 --> 00:13:23,680
example that you can consider

370
00:13:24,560 --> 00:13:28,079
okay so once we have identified this

371
00:13:28,079 --> 00:13:29,760
quantum friendly classical rewinding the

372
00:13:29,760 --> 00:13:32,639
next step would be to combine this with

373
00:13:32,639 --> 00:13:36,000
a lemma that was proposed by waters

374
00:13:36,000 --> 00:13:38,320
and we can combine both of them to get

375
00:13:38,320 --> 00:13:40,880
quantum simulation right so um somehow

376
00:13:40,880 --> 00:13:41,920
we can

377
00:13:41,920 --> 00:13:42,720
uh

378
00:13:42,720 --> 00:13:43,839
you know

379
00:13:43,839 --> 00:13:45,920
merge these two different

380
00:13:45,920 --> 00:13:47,519
techniques together to get a quantum

381
00:13:47,519 --> 00:13:48,480
simulator

382
00:13:48,480 --> 00:13:51,120
so this is sort of roughly the

383
00:13:51,120 --> 00:13:54,240
strategy we are going to adopt to uh

384
00:13:54,240 --> 00:13:55,920
come up with a feasibility result for

385
00:13:55,920 --> 00:13:59,279
bounded concurrent qck

386
00:13:59,279 --> 00:14:01,519
okay so towards this we can ask if there

387
00:14:01,519 --> 00:14:02,880
are quantum friendly classical

388
00:14:02,880 --> 00:14:05,199
concurrent rewinding techniques right

389
00:14:05,199 --> 00:14:07,199
and then we can try to combine them with

390
00:14:07,199 --> 00:14:09,600
waters

391
00:14:09,600 --> 00:14:11,760
and the

392
00:14:11,760 --> 00:14:13,680
answer is unfortunately no i mean most

393
00:14:13,680 --> 00:14:14,880
of the techniques we know in the

394
00:14:14,880 --> 00:14:18,079
classical concurrent literature

395
00:14:18,079 --> 00:14:20,480
either violate the obliviousness

396
00:14:20,480 --> 00:14:24,639
condition or the no recording condition

397
00:14:24,639 --> 00:14:27,440
um so which means that we need to

398
00:14:27,440 --> 00:14:31,440
really you know sort of devise a new um

399
00:14:31,440 --> 00:14:33,040
quantum friendly classical demanding

400
00:14:33,040 --> 00:14:34,639
technique and that's what we do in this

401
00:14:34,639 --> 00:14:36,959
work so we propose a technique called

402
00:14:36,959 --> 00:14:38,800
block rewinding technique

403
00:14:38,800 --> 00:14:40,000
and then we're going to use this

404
00:14:40,000 --> 00:14:42,800
technique to prove that the classical

405
00:14:42,800 --> 00:14:45,440
protocol of pass

406
00:14:45,440 --> 00:14:47,600
singh and big strong

407
00:14:47,600 --> 00:14:49,920
is bounded concurrent qck

408
00:14:49,920 --> 00:14:52,639
they showed the existence of classical

409
00:14:52,639 --> 00:14:56,000
concurrent zk uh bounded concurrency k

410
00:14:56,000 --> 00:14:57,279
and we're going to show that the same

411
00:14:57,279 --> 00:14:58,720
construction

412
00:14:58,720 --> 00:15:00,639
modulo some modifications in the

413
00:15:00,639 --> 00:15:01,839
parameters

414
00:15:01,839 --> 00:15:03,120
um

415
00:15:03,120 --> 00:15:06,880
is also secure in the quantum setting

416
00:15:06,880 --> 00:15:08,639
okay

417
00:15:08,639 --> 00:15:10,160
so what is this block rewinding

418
00:15:10,160 --> 00:15:11,199
technique

419
00:15:11,199 --> 00:15:13,360
at a high level what we do is we sort of

420
00:15:13,360 --> 00:15:14,720
divide the

421
00:15:14,720 --> 00:15:16,720
the entire transcript which is the

422
00:15:16,720 --> 00:15:18,160
execution of the prover with all the

423
00:15:18,160 --> 00:15:19,279
verifiers

424
00:15:19,279 --> 00:15:21,680
into blocks

425
00:15:21,680 --> 00:15:22,800
and

426
00:15:22,800 --> 00:15:24,959
this simulator what it's going to do is

427
00:15:24,959 --> 00:15:27,120
at the end of every block it's going to

428
00:15:27,120 --> 00:15:28,720
decide whether to rewind to the

429
00:15:28,720 --> 00:15:31,519
beginning of the block or not with with

430
00:15:31,519 --> 00:15:33,360
probability half

431
00:15:33,360 --> 00:15:36,880
and since the decision to rewind

432
00:15:36,880 --> 00:15:38,959
is oblivious of the very fast state so

433
00:15:38,959 --> 00:15:40,560
the simulator will do this no matter

434
00:15:40,560 --> 00:15:42,880
what the auxiliary state was

435
00:15:42,880 --> 00:15:45,759
so this particular

436
00:15:45,759 --> 00:15:47,759
step would satisfy the obliviousness

437
00:15:47,759 --> 00:15:50,240
condition

438
00:15:50,720 --> 00:15:52,639
and when the simulator records it's

439
00:15:52,639 --> 00:15:54,399
going to forget all the transcript it

440
00:15:54,399 --> 00:15:56,720
has remembered so far so when it goes

441
00:15:56,720 --> 00:15:58,959
from step i to step j

442
00:15:58,959 --> 00:16:01,199
uh so sorry when it when it rewinds from

443
00:16:01,199 --> 00:16:03,279
step j to step i then it's going to

444
00:16:03,279 --> 00:16:07,360
forget all the messages from i to j

445
00:16:07,759 --> 00:16:09,920
and that's the the this also satisfies

446
00:16:09,920 --> 00:16:12,800
the no recording condition

447
00:16:12,800 --> 00:16:14,240
so this was a

448
00:16:14,240 --> 00:16:17,360
so really vague and high level uh

449
00:16:17,360 --> 00:16:18,800
idea of how the simulator would work i

450
00:16:18,800 --> 00:16:20,320
mean here there are many questions how

451
00:16:20,320 --> 00:16:23,440
big are the blocks you know will the

452
00:16:23,440 --> 00:16:25,279
simulation work for all schedulings you

453
00:16:25,279 --> 00:16:27,199
know can the verifier somehow interleave

454
00:16:27,199 --> 00:16:29,519
the messages cleverly in such a way that

455
00:16:29,519 --> 00:16:31,199
the simulator fails

456
00:16:31,199 --> 00:16:32,480
and uh

457
00:16:32,480 --> 00:16:34,160
finally what if the all the verifiers

458
00:16:34,160 --> 00:16:36,880
are bought in a single block

459
00:16:36,880 --> 00:16:38,959
will the simulator even remind them

460
00:16:38,959 --> 00:16:40,560
right so

461
00:16:40,560 --> 00:16:42,160
if the simulator doesn't choose to

462
00:16:42,160 --> 00:16:43,279
rewind

463
00:16:43,279 --> 00:16:44,560
then

464
00:16:44,560 --> 00:16:45,920
it would end up depending on the

465
00:16:45,920 --> 00:16:47,680
verified state and thus violating the

466
00:16:47,680 --> 00:16:49,759
obliviousness condition so we need to

467
00:16:49,759 --> 00:16:51,199
also handle the case when all the

468
00:16:51,199 --> 00:16:52,959
verifiers are bought in a block single

469
00:16:52,959 --> 00:16:55,199
block

470
00:16:55,360 --> 00:16:56,800
okay so before

471
00:16:56,800 --> 00:16:57,600
uh

472
00:16:57,600 --> 00:16:59,519
answering these questions let's uh look

473
00:16:59,519 --> 00:17:02,079
at the protocol description of bus thing

474
00:17:02,079 --> 00:17:03,519
and big storm

475
00:17:03,519 --> 00:17:05,839
so their protocol is composed into two

476
00:17:05,839 --> 00:17:08,000
stages in the first stage uh the prover

477
00:17:08,000 --> 00:17:10,799
p sends a commitment uh of a bit to the

478
00:17:10,799 --> 00:17:11,919
verifier

479
00:17:11,919 --> 00:17:15,359
and the verifier sends some other bit

480
00:17:15,359 --> 00:17:19,119
to back to p so in terms of what

481
00:17:19,119 --> 00:17:21,280
commitment we use we are going to use a

482
00:17:21,280 --> 00:17:23,520
statistically binding

483
00:17:23,520 --> 00:17:24,959
a quantum concealing commitment scheme

484
00:17:24,959 --> 00:17:26,240
which can be based on post quantum

485
00:17:26,240 --> 00:17:28,880
memory functions

486
00:17:29,120 --> 00:17:30,720
and in the second stage

487
00:17:30,720 --> 00:17:33,039
prover proves to the verifier that

488
00:17:33,039 --> 00:17:35,120
either it knows

489
00:17:35,120 --> 00:17:36,559
the witness

490
00:17:36,559 --> 00:17:38,160
for this instance

491
00:17:38,160 --> 00:17:40,160
or

492
00:17:40,160 --> 00:17:42,160
there are enough number of

493
00:17:42,160 --> 00:17:43,520
executions

494
00:17:43,520 --> 00:17:45,039
in stage one

495
00:17:45,039 --> 00:17:48,240
where the very first bit agreed with the

496
00:17:48,240 --> 00:17:51,440
provers committed bit

497
00:17:51,760 --> 00:17:53,600
so we're going to use the term matchings

498
00:17:53,600 --> 00:17:55,440
so we say that

499
00:17:55,440 --> 00:17:57,280
you know a particular execution of stage

500
00:17:57,280 --> 00:17:58,840
1 has been matched

501
00:17:58,840 --> 00:18:01,760
if the very first bit is the same as the

502
00:18:01,760 --> 00:18:03,520
proverbs committed bit like in other

503
00:18:03,520 --> 00:18:07,280
words if bi prime is the same as bi

504
00:18:07,520 --> 00:18:09,600
and if we can we can rephrase

505
00:18:09,600 --> 00:18:10,640
this

506
00:18:10,640 --> 00:18:12,400
condition as saying that the number of

507
00:18:12,400 --> 00:18:14,480
matchings has to be at least l over two

508
00:18:14,480 --> 00:18:18,480
plus uh q to the four uh lambda

509
00:18:18,480 --> 00:18:21,600
so roughly you know uh in expectation l

510
00:18:21,600 --> 00:18:24,559
over two executions will have uh the

511
00:18:24,559 --> 00:18:25,760
very fast bit to be the same as the

512
00:18:25,760 --> 00:18:27,039
prover split

513
00:18:27,039 --> 00:18:28,400
what we are asking

514
00:18:28,400 --> 00:18:30,640
is something that is slightly more than

515
00:18:30,640 --> 00:18:32,640
uh roughly half of the executions of

516
00:18:32,640 --> 00:18:35,360
stage one

517
00:18:35,360 --> 00:18:36,960
okay

518
00:18:36,960 --> 00:18:38,480
so we're going to use the

519
00:18:38,480 --> 00:18:39,679
you know we're going to call a single

520
00:18:39,679 --> 00:18:43,799
execution of stage one to be a slot

521
00:18:45,200 --> 00:18:47,440
so let's first consider the setting when

522
00:18:47,440 --> 00:18:50,400
the simulator is uh

523
00:18:50,400 --> 00:18:53,280
when the verifier is classical and then

524
00:18:53,280 --> 00:18:54,960
you know we're going to see how to put

525
00:18:54,960 --> 00:18:56,640
the ideas developed here to the case

526
00:18:56,640 --> 00:18:59,679
when this verifier is quantum

527
00:18:59,679 --> 00:19:01,440
okay

528
00:19:01,440 --> 00:19:03,760
okay so we're going to divide the

529
00:19:03,760 --> 00:19:05,600
the transcript into b size blocks we're

530
00:19:05,600 --> 00:19:08,400
going to fix uh b soon

531
00:19:08,400 --> 00:19:10,480
so what we're going to do is for the ith

532
00:19:10,480 --> 00:19:13,120
message of v star

533
00:19:13,120 --> 00:19:14,400
in in a block

534
00:19:14,400 --> 00:19:16,640
what we are going to check is if

535
00:19:16,640 --> 00:19:18,080
this message

536
00:19:18,080 --> 00:19:21,678
is a is a last message in a block

537
00:19:22,640 --> 00:19:24,160
so if this message is the last message

538
00:19:24,160 --> 00:19:25,360
in the block

539
00:19:25,360 --> 00:19:26,160
then

540
00:19:26,160 --> 00:19:29,600
you see how many of the sessions

541
00:19:29,600 --> 00:19:32,240
contain a slot in this block b

542
00:19:32,240 --> 00:19:34,880
okay so you're going to consider all the

543
00:19:34,880 --> 00:19:36,720
slots that are completely contained in

544
00:19:36,720 --> 00:19:37,760
this block

545
00:19:37,760 --> 00:19:39,120
and then you're going to pick

546
00:19:39,120 --> 00:19:41,440
one of these slots uniformly at random

547
00:19:41,440 --> 00:19:43,200
right

548
00:19:43,200 --> 00:19:45,200
right so there are let's say there are l

549
00:19:45,200 --> 00:19:46,480
verifiers

550
00:19:46,480 --> 00:19:47,600
whose uh

551
00:19:47,600 --> 00:19:48,960
slots are contained in b then you're

552
00:19:48,960 --> 00:19:50,080
going to pick one of the verifiers

553
00:19:50,080 --> 00:19:53,440
uniformly at random um you know

554
00:19:53,440 --> 00:19:55,039
of course a single verifier could have

555
00:19:55,039 --> 00:19:56,880
multiple slots just pick one of them at

556
00:19:56,880 --> 00:19:58,799
random and then you're going to check if

557
00:19:58,799 --> 00:20:00,400
this slot has been matched in other

558
00:20:00,400 --> 00:20:02,960
words if bi prime is the same as bi

559
00:20:02,960 --> 00:20:04,480
so if that is the case then you move to

560
00:20:04,480 --> 00:20:06,799
the next block otherwise what you're

561
00:20:06,799 --> 00:20:09,760
going to do is you're going to rewind

562
00:20:09,760 --> 00:20:13,039
rewind to the beginning of the block

563
00:20:13,360 --> 00:20:14,559
okay

564
00:20:14,559 --> 00:20:17,440
so let's first assume that

565
00:20:17,440 --> 00:20:19,200
somehow the verifiers interleaving

566
00:20:19,200 --> 00:20:21,280
strategy says that

567
00:20:21,280 --> 00:20:22,559
one slot

568
00:20:22,559 --> 00:20:24,159
in every block contains at least one

569
00:20:24,159 --> 00:20:25,360
slot

570
00:20:25,360 --> 00:20:26,960
if this is the case then you can see

571
00:20:26,960 --> 00:20:28,559
that the probability that the simulator

572
00:20:28,559 --> 00:20:30,400
rewinds

573
00:20:30,400 --> 00:20:34,679
is going to be roughly half

574
00:20:35,440 --> 00:20:37,840
right um so now we can ask what if a

575
00:20:37,840 --> 00:20:40,640
block doesn't contain any slot

576
00:20:40,640 --> 00:20:43,440
if a block doesn't contain any slot then

577
00:20:43,440 --> 00:20:44,799
you know what you are going to do is the

578
00:20:44,799 --> 00:20:46,880
simulator is going to just

579
00:20:46,880 --> 00:20:48,960
you know pick a bit uniformly at random

580
00:20:48,960 --> 00:20:50,960
this is a dummy bit and this bit comes

581
00:20:50,960 --> 00:20:52,880
up as zero then it goes to the next

582
00:20:52,880 --> 00:20:54,159
block otherwise it's going to rewind to

583
00:20:54,159 --> 00:20:56,480
the beginning of the block

584
00:20:56,480 --> 00:20:58,080
and why do we have this

585
00:20:58,080 --> 00:21:00,559
remember we need to satisfy a condition

586
00:21:00,559 --> 00:21:02,080
called obliviousness that says that the

587
00:21:02,080 --> 00:21:03,840
simulator's rewinding

588
00:21:03,840 --> 00:21:04,799
uh

589
00:21:04,799 --> 00:21:06,640
the the the decision to rewind should be

590
00:21:06,640 --> 00:21:09,039
independent of the verifier state right

591
00:21:09,039 --> 00:21:10,720
so this you know it could very well be

592
00:21:10,720 --> 00:21:12,480
the very will be the case that the

593
00:21:12,480 --> 00:21:15,200
verifier has uh interluded its messages

594
00:21:15,200 --> 00:21:16,400
in such a way that

595
00:21:16,400 --> 00:21:19,039
it there does not exist any slot in a

596
00:21:19,039 --> 00:21:20,080
block

597
00:21:20,080 --> 00:21:21,919
uh and if the simulator does not choose

598
00:21:21,919 --> 00:21:23,360
to rewind then

599
00:21:23,360 --> 00:21:24,320
um

600
00:21:24,320 --> 00:21:26,400
then its decision is depending

601
00:21:26,400 --> 00:21:28,720
on the verified state right and that

602
00:21:28,720 --> 00:21:31,520
violates obliviousness

603
00:21:31,520 --> 00:21:33,039
so we're going to add this condition as

604
00:21:33,039 --> 00:21:36,960
well in the description of the simulator

605
00:21:39,120 --> 00:21:42,640
okay so now what if uh you know the

606
00:21:42,640 --> 00:21:44,080
the message that you're considering is

607
00:21:44,080 --> 00:21:46,000
the intermediate message in the block in

608
00:21:46,000 --> 00:21:47,360
this case you know if it is a stage one

609
00:21:47,360 --> 00:21:48,559
message then you are going to behave

610
00:21:48,559 --> 00:21:49,919
like the onus prover you are going to

611
00:21:49,919 --> 00:21:51,840
just stand a commitment of a random bit

612
00:21:51,840 --> 00:21:53,360
if it is a states two message then you

613
00:21:53,360 --> 00:21:56,000
check if the number of matchings

614
00:21:56,000 --> 00:21:58,960
uh is at least l over two plus this

615
00:21:58,960 --> 00:22:00,640
additional q to the four lambda or

616
00:22:00,640 --> 00:22:02,240
naught if it is less than that then

617
00:22:02,240 --> 00:22:04,080
you're going to abort

618
00:22:04,080 --> 00:22:05,840
otherwise you have sufficient number of

619
00:22:05,840 --> 00:22:07,520
matchings now you can

620
00:22:07,520 --> 00:22:10,159
use these matchings to complete the wi

621
00:22:10,159 --> 00:22:13,159
phase

622
00:22:15,280 --> 00:22:17,280
so what is left is to show that the

623
00:22:17,280 --> 00:22:19,679
probability that the number of matchings

624
00:22:19,679 --> 00:22:21,520
is at most l over 2 plus q to the 4

625
00:22:21,520 --> 00:22:24,000
lambda is negligible right because if

626
00:22:24,000 --> 00:22:25,440
this happens then the simulator is

627
00:22:25,440 --> 00:22:26,880
failing right and we want to show that

628
00:22:26,880 --> 00:22:29,919
the probability of this event is low

629
00:22:29,919 --> 00:22:31,520
so the intuition is that for every

630
00:22:31,520 --> 00:22:33,520
verified vi the number of blocks that

631
00:22:33,520 --> 00:22:35,440
contain at least one slot of vi is at

632
00:22:35,440 --> 00:22:38,000
least 6

633
00:22:38,000 --> 00:22:39,679
times q to the 5 lambda so you can you

634
00:22:39,679 --> 00:22:41,840
can show this using a counting argument

635
00:22:41,840 --> 00:22:43,039
similarly you can also show that the

636
00:22:43,039 --> 00:22:44,799
number of uh blocks in which a

637
00:22:44,799 --> 00:22:46,799
particular verifier slot is picked is

638
00:22:46,799 --> 00:22:49,200
also sufficiently high

639
00:22:49,200 --> 00:22:50,880
then you can use both combine both these

640
00:22:50,880 --> 00:22:52,320
facts to argue that with high

641
00:22:52,320 --> 00:22:55,760
probability using channel bond

642
00:22:55,760 --> 00:22:57,600
at least three times q to the four

643
00:22:57,600 --> 00:22:59,600
lambda of the slots are matched

644
00:22:59,600 --> 00:23:03,760
um you know this is by the simulator

645
00:23:03,760 --> 00:23:06,159
employing the rewinding strategy

646
00:23:06,159 --> 00:23:07,840
on the other hand you know there are

647
00:23:07,840 --> 00:23:10,400
still l minus three q to the four lambda

648
00:23:10,400 --> 00:23:12,000
slots remaining

649
00:23:12,000 --> 00:23:12,799
and

650
00:23:12,799 --> 00:23:13,679
you know

651
00:23:13,679 --> 00:23:14,799
even

652
00:23:14,799 --> 00:23:16,159
you know even if the simulator doesn't

653
00:23:16,159 --> 00:23:19,120
try to match them just by sheer luck

654
00:23:19,120 --> 00:23:20,559
uh half of them are going to be

655
00:23:20,559 --> 00:23:22,960
satisfied in expectation and again using

656
00:23:22,960 --> 00:23:24,159
churn off you can show that the number

657
00:23:24,159 --> 00:23:26,480
of slots that are satisfied with high

658
00:23:26,480 --> 00:23:28,799
probability is at least low to minus 2q

659
00:23:28,799 --> 00:23:31,440
to 4 lambda so if you add both of them

660
00:23:31,440 --> 00:23:32,240
up

661
00:23:32,240 --> 00:23:33,760
these two quantities up you're going to

662
00:23:33,760 --> 00:23:34,720
get

663
00:23:34,720 --> 00:23:36,799
the desired bound right so you can argue

664
00:23:36,799 --> 00:23:37,679
that

665
00:23:37,679 --> 00:23:41,200
this is in fact negligible

666
00:23:42,880 --> 00:23:44,559
right so that's how you complete the

667
00:23:44,559 --> 00:23:46,240
simulation strategy

668
00:23:46,240 --> 00:23:47,039
so

669
00:23:47,039 --> 00:23:49,360
what is remaining is to show that

670
00:23:49,360 --> 00:23:52,159
the verifier is

671
00:23:52,159 --> 00:23:53,600
in we need to show the case when the

672
00:23:53,600 --> 00:23:55,679
verifier is qpt

673
00:23:55,679 --> 00:23:56,960
and

674
00:23:56,960 --> 00:23:58,720
the quantum

675
00:23:58,720 --> 00:24:01,200
simulation strategy is very simple you

676
00:24:01,200 --> 00:24:02,400
know the quantum simulator is just going

677
00:24:02,400 --> 00:24:03,919
to run the classical simulator and the

678
00:24:03,919 --> 00:24:05,840
verifier in superposition so it's not

679
00:24:05,840 --> 00:24:08,000
going to measure anything

680
00:24:08,000 --> 00:24:09,520
um

681
00:24:09,520 --> 00:24:10,799
except at the end of the block at the

682
00:24:10,799 --> 00:24:12,320
end of the block it's going to measure

683
00:24:12,320 --> 00:24:14,000
something and based on that it decides

684
00:24:14,000 --> 00:24:15,760
to rewind

685
00:24:15,760 --> 00:24:18,320
and how does it rewind it employs the

686
00:24:18,320 --> 00:24:20,559
rewinding strategy proposed by waters so

687
00:24:20,559 --> 00:24:23,120
this is the rewinding that's going to be

688
00:24:23,120 --> 00:24:26,639
given to us by the water slam

689
00:24:28,720 --> 00:24:30,880
and we can show that a careful repeated

690
00:24:30,880 --> 00:24:33,360
application of water's lemma implies a

691
00:24:33,360 --> 00:24:35,840
successful simulation against a quantum

692
00:24:35,840 --> 00:24:38,320
verifier

693
00:24:40,159 --> 00:24:41,600
okay so with this

694
00:24:41,600 --> 00:24:43,200
let me conclude this talk

695
00:24:43,200 --> 00:24:44,960
we initiate a formal study of concurrent

696
00:24:44,960 --> 00:24:47,679
qck we showed a feasibility of bounded

697
00:24:47,679 --> 00:24:49,600
concurrent qck for np

698
00:24:49,600 --> 00:24:51,279
couple of results i didn't talk about is

699
00:24:51,279 --> 00:24:53,120
quantum proof of knowledge for np and we

700
00:24:53,120 --> 00:24:54,480
also show the feasibility of boundary

701
00:24:54,480 --> 00:24:57,760
concurrent qck for qma

702
00:24:57,760 --> 00:25:00,640
so what is open is to show the

703
00:25:00,640 --> 00:25:02,400
possibility or impossibility of

704
00:25:02,400 --> 00:25:05,600
unbounded concurrent qck

705
00:25:05,600 --> 00:25:07,919
and also post quantum concurrent secure

706
00:25:07,919 --> 00:25:10,080
computation

707
00:25:10,080 --> 00:25:11,919
with this i conclude

708
00:25:11,919 --> 00:25:14,400
thanks

