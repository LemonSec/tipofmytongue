1
00:00:01,680 --> 00:00:03,439
hi i'm sarah wrote and i'll be

2
00:00:03,439 --> 00:00:05,359
presenting moss the modular security

3
00:00:05,359 --> 00:00:07,279
specifications framework

4
00:00:07,279 --> 00:00:09,280
this is joint work with professor amir

5
00:00:09,280 --> 00:00:10,719
harrisburg from the university of

6
00:00:10,719 --> 00:00:12,000
connecticut

7
00:00:12,000 --> 00:00:14,480
hemi leibovite from barline university

8
00:00:14,480 --> 00:00:16,239
and professor evacetta from trinity

9
00:00:16,239 --> 00:00:18,639
college

10
00:00:18,800 --> 00:00:20,160
we know that proofs are critical to

11
00:00:20,160 --> 00:00:21,680
ensure security and improving the

12
00:00:21,680 --> 00:00:23,600
security of well-defined cryptographic

13
00:00:23,600 --> 00:00:25,359
primitives like set random functions and

14
00:00:25,359 --> 00:00:28,160
encryption schemes for a long time for

15
00:00:28,160 --> 00:00:30,240
example probabilistic encryption by

16
00:00:30,240 --> 00:00:32,159
goldwester and ricali was published

17
00:00:32,159 --> 00:00:34,399
already in 1984.

18
00:00:34,399 --> 00:00:36,640
so probable security is well established

19
00:00:36,640 --> 00:00:38,239
and we also know that bringing the

20
00:00:38,239 --> 00:00:40,160
security of a primitive is not enough to

21
00:00:40,160 --> 00:00:42,000
guarantee the security of a whole system

22
00:00:42,000 --> 00:00:44,079
or protocol using the primitive and

23
00:00:44,079 --> 00:00:45,920
there have been many failures of systems

24
00:00:45,920 --> 00:00:47,920
which were not proven secure

25
00:00:47,920 --> 00:00:49,840
so ideally we would like provably secure

26
00:00:49,840 --> 00:00:51,600
protocols as well

27
00:00:51,600 --> 00:00:53,440
but unfortunately many applied protocols

28
00:00:53,440 --> 00:00:55,840
are not proven secure

29
00:00:55,840 --> 00:00:57,520
and admittedly proving the security of

30
00:00:57,520 --> 00:00:59,280
applied protocols is not easy we can

31
00:00:59,280 --> 00:01:01,600
make subtle mistakes and the protocols

32
00:01:01,600 --> 00:01:03,600
themselves and the specifications which

33
00:01:03,600 --> 00:01:05,519
include assumptions and goals

34
00:01:05,519 --> 00:01:08,240
can be quite complex and in addition

35
00:01:08,240 --> 00:01:10,320
defining specifications which accurately

36
00:01:10,320 --> 00:01:12,560
reflect real world environment

37
00:01:12,560 --> 00:01:14,400
assumptions for example about

38
00:01:14,400 --> 00:01:16,960
communication and synchronization

39
00:01:16,960 --> 00:01:19,360
is not trivial so altogether this can

40
00:01:19,360 --> 00:01:21,119
discourage people from

41
00:01:21,119 --> 00:01:22,560
trying to prove the security of

42
00:01:22,560 --> 00:01:25,119
protocols

43
00:01:25,600 --> 00:01:26,880
in order to prove the security of

44
00:01:26,880 --> 00:01:29,360
protocols though we need to define

45
00:01:29,360 --> 00:01:30,799
um what we're proving so we need to

46
00:01:30,799 --> 00:01:33,600
define the protocol specifications

47
00:01:33,600 --> 00:01:36,159
and there are a few existing approaches

48
00:01:36,159 --> 00:01:38,479
um to protocol specifications

49
00:01:38,479 --> 00:01:40,880
the first one is the informal approach

50
00:01:40,880 --> 00:01:42,640
in which we list the

51
00:01:42,640 --> 00:01:44,880
specifications as descriptions

52
00:01:44,880 --> 00:01:46,159
and words

53
00:01:46,159 --> 00:01:48,079
and your specifications include the

54
00:01:48,079 --> 00:01:51,040
assumptions and goals

55
00:01:51,040 --> 00:01:52,399
and we use models to refer to the

56
00:01:52,399 --> 00:01:54,720
assumptions so we have adversary models

57
00:01:54,720 --> 00:01:56,240
like men in the middle communication

58
00:01:56,240 --> 00:01:58,479
models like reliable communication

59
00:01:58,479 --> 00:02:00,000
synchronization models like boundary

60
00:02:00,000 --> 00:02:01,119
drive clocks

61
00:02:01,119 --> 00:02:03,360
initialization models like shared keys

62
00:02:03,360 --> 00:02:06,079
and so on and we use requirements to

63
00:02:06,079 --> 00:02:08,239
refer to the goals so you can have

64
00:02:08,239 --> 00:02:10,479
generic requirements which can apply to

65
00:02:10,479 --> 00:02:12,400
multiple protocols

66
00:02:12,400 --> 00:02:14,319
like indistinguishability

67
00:02:14,319 --> 00:02:15,760
um and you can have more specific

68
00:02:15,760 --> 00:02:17,520
requirements like authenticated

69
00:02:17,520 --> 00:02:20,800
broadcast for a broadcasting protocol

70
00:02:20,800 --> 00:02:22,319
so going back to how we can define

71
00:02:22,319 --> 00:02:24,640
specifications the first way is to write

72
00:02:24,640 --> 00:02:26,400
a list of descriptions of the

73
00:02:26,400 --> 00:02:28,400
assumptions in words and then a list of

74
00:02:28,400 --> 00:02:29,520
the goals

75
00:02:29,520 --> 00:02:31,040
and this separates the assumptions from

76
00:02:31,040 --> 00:02:32,080
the goals

77
00:02:32,080 --> 00:02:34,000
but it doesn't facilitate probable

78
00:02:34,000 --> 00:02:36,160
security but this is the approach that

79
00:02:36,160 --> 00:02:38,080
we're used to and which is used in

80
00:02:38,080 --> 00:02:40,239
systems papers where the models and

81
00:02:40,239 --> 00:02:42,400
requirements are informally defined

82
00:02:42,400 --> 00:02:44,879
properties in english

83
00:02:44,879 --> 00:02:46,560
which is natural and easy to understand

84
00:02:46,560 --> 00:02:47,760
for people

85
00:02:47,760 --> 00:02:49,840
but informal arguments can be misleading

86
00:02:49,840 --> 00:02:51,680
can overlook things and it can be

87
00:02:51,680 --> 00:02:53,840
difficult to tell if they're correct and

88
00:02:53,840 --> 00:02:55,360
if each paper defines their own

89
00:02:55,360 --> 00:02:57,440
specifications it can be hard to tell if

90
00:02:57,440 --> 00:03:00,239
they're comparable

91
00:03:00,239 --> 00:03:02,319
second is the game based approach in

92
00:03:02,319 --> 00:03:05,200
which we define a game for each goal are

93
00:03:05,200 --> 00:03:07,519
for multiple goals and the game includes

94
00:03:07,519 --> 00:03:09,200
the assumptions as well

95
00:03:09,200 --> 00:03:10,720
so the assumptions and goals are

96
00:03:10,720 --> 00:03:12,720
combined and the game is kind of

97
00:03:12,720 --> 00:03:14,400
monolithic in the sense that all the

98
00:03:14,400 --> 00:03:16,400
assumptions and the goal are defined

99
00:03:16,400 --> 00:03:17,440
together

100
00:03:17,440 --> 00:03:19,040
and or even all the assumptions all the

101
00:03:19,040 --> 00:03:21,840
goals are defined together in one game

102
00:03:21,840 --> 00:03:24,080
but it does approval security although

103
00:03:24,080 --> 00:03:27,680
we don't have general compositions

104
00:03:27,680 --> 00:03:29,440
the third approach is a simulation based

105
00:03:29,440 --> 00:03:30,400
approach

106
00:03:30,400 --> 00:03:32,159
where we show the pro that the protocol

107
00:03:32,159 --> 00:03:34,560
is indistinguishable from an ideal

108
00:03:34,560 --> 00:03:37,599
system or an id functionality and you

109
00:03:37,599 --> 00:03:38,560
see

110
00:03:38,560 --> 00:03:40,959
an ideal functionality is a description

111
00:03:40,959 --> 00:03:43,120
of what the protocol should do

112
00:03:43,120 --> 00:03:45,599
as a an ideal machine

113
00:03:45,599 --> 00:03:48,000
so it specifies what what outputs it

114
00:03:48,000 --> 00:03:50,000
should ideally have

115
00:03:50,000 --> 00:03:51,920
and this is also monolithic because all

116
00:03:51,920 --> 00:03:53,280
the assumptions

117
00:03:53,280 --> 00:03:55,439
and even all the goals too is are

118
00:03:55,439 --> 00:03:56,879
defined together in one ideal

119
00:03:56,879 --> 00:03:58,640
functionality

120
00:03:58,640 --> 00:04:00,560
but it does have approval security and

121
00:04:00,560 --> 00:04:01,599
you can also

122
00:04:01,599 --> 00:04:04,080
have secure compositions which is an

123
00:04:04,080 --> 00:04:06,319
important feature of uc

124
00:04:06,319 --> 00:04:07,920
both for applied and theoretical

125
00:04:07,920 --> 00:04:09,120
protocols

126
00:04:09,120 --> 00:04:11,040
um because we often build protocols out

127
00:04:11,040 --> 00:04:13,120
of smaller pieces or we design a

128
00:04:13,120 --> 00:04:15,040
cryptographic primitive using another

129
00:04:15,040 --> 00:04:17,199
cryptographic primitive so we want to be

130
00:04:17,199 --> 00:04:18,399
able to prove

131
00:04:18,399 --> 00:04:19,918
based on the security of the smaller

132
00:04:19,918 --> 00:04:22,160
pieces that the bigger system or

133
00:04:22,160 --> 00:04:24,080
protocol is secure

134
00:04:24,080 --> 00:04:27,280
and uc has secure compositions

135
00:04:27,280 --> 00:04:29,600
and finally uh in this work we present

136
00:04:29,600 --> 00:04:30,720
moss

137
00:04:30,720 --> 00:04:32,400
which is game based and it uses

138
00:04:32,400 --> 00:04:34,080
predicate so we have model predicates

139
00:04:34,080 --> 00:04:36,400
and requirement predicates

140
00:04:36,400 --> 00:04:38,160
and in contrast to the typical game

141
00:04:38,160 --> 00:04:39,759
based approach moss

142
00:04:39,759 --> 00:04:40,560
has

143
00:04:40,560 --> 00:04:42,320
separate models and requirements so it

144
00:04:42,320 --> 00:04:44,720
separates the models and requirements

145
00:04:44,720 --> 00:04:46,960
and notice that this is similar to the

146
00:04:46,960 --> 00:04:48,880
informal approach where we can list the

147
00:04:48,880 --> 00:04:50,800
models and requirements

148
00:04:50,800 --> 00:04:53,520
but now these are formal models and

149
00:04:53,520 --> 00:04:55,360
requirements which are well defined

150
00:04:55,360 --> 00:04:56,800
using predicates

151
00:04:56,800 --> 00:04:59,199
are not descriptions in english

152
00:04:59,199 --> 00:05:01,759
and we can prove security

153
00:05:01,759 --> 00:05:02,960
and currently we do not have

154
00:05:02,960 --> 00:05:05,600
composability but we have some intuition

155
00:05:05,600 --> 00:05:08,960
and are optimistic that it can be done

156
00:05:08,960 --> 00:05:11,680
so what is moss moss stands for modular

157
00:05:11,680 --> 00:05:13,919
security specifications framework and

158
00:05:13,919 --> 00:05:15,840
it's a game-based framework with

159
00:05:15,840 --> 00:05:17,680
well-defined formal modular

160
00:05:17,680 --> 00:05:20,080
specifications

161
00:05:20,080 --> 00:05:21,840
um and it's in game based because we

162
00:05:21,840 --> 00:05:23,120
found it more convenient to use

163
00:05:23,120 --> 00:05:24,800
game-based definitions

164
00:05:24,800 --> 00:05:26,479
but there is an interesting question for

165
00:05:26,479 --> 00:05:28,320
the future of whether we can have

166
00:05:28,320 --> 00:05:30,479
modular simulation-based specifications

167
00:05:30,479 --> 00:05:31,840
as well

168
00:05:31,840 --> 00:05:34,479
but moss is game-based modular and

169
00:05:34,479 --> 00:05:36,639
separates the execution process models

170
00:05:36,639 --> 00:05:38,000
and requirements so these three

171
00:05:38,000 --> 00:05:40,320
components are independent

172
00:05:40,320 --> 00:05:42,320
and models and requirements themselves

173
00:05:42,320 --> 00:05:45,360
are modular also so we can for example

174
00:05:45,360 --> 00:05:47,600
combine models together easily

175
00:05:47,600 --> 00:05:49,520
and it'll be more clear what i mean by

176
00:05:49,520 --> 00:05:50,639
combine

177
00:05:50,639 --> 00:05:51,680
after

178
00:05:51,680 --> 00:05:53,440
i believe after i

179
00:05:53,440 --> 00:05:56,880
define models and requirements in moss

180
00:05:56,880 --> 00:05:58,880
but notice that this modularity has

181
00:05:58,880 --> 00:06:00,400
several benefits

182
00:06:00,400 --> 00:06:01,759
we can have gradual development of

183
00:06:01,759 --> 00:06:03,600
specifications

184
00:06:03,600 --> 00:06:05,680
which can be useful because oftentimes

185
00:06:05,680 --> 00:06:08,479
we first simplify a complex problem and

186
00:06:08,479 --> 00:06:11,039
then gradually make it more realistic so

187
00:06:11,039 --> 00:06:13,039
we can for example start with a stronger

188
00:06:13,039 --> 00:06:13,919
model

189
00:06:13,919 --> 00:06:15,840
and prove a weaker requirement and then

190
00:06:15,840 --> 00:06:17,440
work towards a

191
00:06:17,440 --> 00:06:19,520
weaker model and prove a stronger

192
00:06:19,520 --> 00:06:21,600
requirement

193
00:06:21,600 --> 00:06:22,639
and

194
00:06:22,639 --> 00:06:25,440
maybe it was intentionally simplified or

195
00:06:25,440 --> 00:06:27,039
or the assumptions and goals changed

196
00:06:27,039 --> 00:06:29,199
over time so it can be convenient to

197
00:06:29,199 --> 00:06:31,520
reuse previous definitions and only

198
00:06:31,520 --> 00:06:33,520
change what's needed

199
00:06:33,520 --> 00:06:35,759
and we can reuse models and requirements

200
00:06:35,759 --> 00:06:38,560
across works to save time and space

201
00:06:38,560 --> 00:06:40,560
and make the results easier to compare

202
00:06:40,560 --> 00:06:42,800
which might not be so easy with

203
00:06:42,800 --> 00:06:44,479
even monolithic games idm

204
00:06:44,479 --> 00:06:46,960
functionalities in uc and even more with

205
00:06:46,960 --> 00:06:49,280
the informal approach

206
00:06:49,280 --> 00:06:51,680
so now you know what moss is let me tell

207
00:06:51,680 --> 00:06:53,680
you a bit more about how moss works

208
00:06:53,680 --> 00:06:55,840
starting with the execution process

209
00:06:55,840 --> 00:06:57,120
and then

210
00:06:57,120 --> 00:06:59,840
models and requirements

211
00:06:59,840 --> 00:07:01,440
so this is a high level diagram of the

212
00:07:01,440 --> 00:07:03,599
most execution process

213
00:07:03,599 --> 00:07:05,360
and the great the succession process in

214
00:07:05,360 --> 00:07:06,720
the gray box interacts with the

215
00:07:06,720 --> 00:07:08,080
adversary

216
00:07:08,080 --> 00:07:09,759
at the bottom and the protocol at the

217
00:07:09,759 --> 00:07:10,639
top

218
00:07:10,639 --> 00:07:12,319
which are both represented as stateless

219
00:07:12,319 --> 00:07:13,919
functions

220
00:07:13,919 --> 00:07:15,759
and the execution process maintains

221
00:07:15,759 --> 00:07:17,199
their state and then gives them their

222
00:07:17,199 --> 00:07:19,360
state when they're invoked

223
00:07:19,360 --> 00:07:21,759
and we give the parameters params on on

224
00:07:21,759 --> 00:07:24,240
the left to the execution process

225
00:07:24,240 --> 00:07:26,080
which can include security parameters

226
00:07:26,080 --> 00:07:28,800
the key length and other parameters

227
00:07:28,800 --> 00:07:30,960
and then the execution um is run and

228
00:07:30,960 --> 00:07:32,560
it's controlled almost entirely by the

229
00:07:32,560 --> 00:07:35,039
adversary so the adversary can choose

230
00:07:35,039 --> 00:07:37,199
the number of entities inputs operation

231
00:07:37,199 --> 00:07:39,360
clock values

232
00:07:39,360 --> 00:07:40,720
in each round

233
00:07:40,720 --> 00:07:41,599
and

234
00:07:41,599 --> 00:07:44,240
then can see the outputs

235
00:07:44,240 --> 00:07:45,919
the execution is

236
00:07:45,919 --> 00:07:47,360
basically

237
00:07:47,360 --> 00:07:49,280
a sequence of events and in each event

238
00:07:49,280 --> 00:07:50,639
the adversary interacts with the

239
00:07:50,639 --> 00:07:51,840
protocol

240
00:07:51,840 --> 00:07:54,080
and chooses the input operation clock

241
00:07:54,080 --> 00:07:56,240
values and then the protocol is run with

242
00:07:56,240 --> 00:07:58,160
these inputs in the entity state and

243
00:07:58,160 --> 00:08:00,639
returns an output and a new state and

244
00:08:00,639 --> 00:08:02,960
the output is given to the adversary

245
00:08:02,960 --> 00:08:04,560
and this can repeat for as many events

246
00:08:04,560 --> 00:08:06,240
as the adversary wants and then at the

247
00:08:06,240 --> 00:08:07,120
end

248
00:08:07,120 --> 00:08:08,639
the execution process outputs a

249
00:08:08,639 --> 00:08:10,960
transcript t which contains values from

250
00:08:10,960 --> 00:08:13,840
the execution

251
00:08:13,840 --> 00:08:16,080
so the adversary can do a lot and this

252
00:08:16,080 --> 00:08:18,080
is intentional because we don't enforce

253
00:08:18,080 --> 00:08:20,960
models as part of the execution process

254
00:08:20,960 --> 00:08:22,479
instead we define models using

255
00:08:22,479 --> 00:08:24,080
predicates over

256
00:08:24,080 --> 00:08:26,319
the transcript so we can limit what is

257
00:08:26,319 --> 00:08:28,479
allowed in the transcript

258
00:08:28,479 --> 00:08:30,879
and we can this way we use the execution

259
00:08:30,879 --> 00:08:32,958
process in different works which makes

260
00:08:32,958 --> 00:08:35,279
writing and understanding works easier

261
00:08:35,279 --> 00:08:37,279
in contrast to for example

262
00:08:37,279 --> 00:08:39,440
the typical game-based approach where

263
00:08:39,440 --> 00:08:41,519
the execution process is also defined as

264
00:08:41,519 --> 00:08:43,839
part of the game

265
00:08:43,839 --> 00:08:46,000
so and also the execution process is

266
00:08:46,000 --> 00:08:48,240
simpler which is one of our goals that

267
00:08:48,240 --> 00:08:51,360
we want it to be understandable

268
00:08:51,360 --> 00:08:53,680
and we also have a formal description of

269
00:08:53,680 --> 00:08:56,160
the execution process with pseudocode

270
00:08:56,160 --> 00:08:58,720
and it's not that complex but you can

271
00:08:58,720 --> 00:09:00,800
see it in the paper i just want to draw

272
00:09:00,800 --> 00:09:03,680
your attention to lines 12 and 13

273
00:09:03,680 --> 00:09:05,600
where you can see that values are saved

274
00:09:05,600 --> 00:09:07,200
to the transcript t and then the

275
00:09:07,200 --> 00:09:09,600
transcript is returned which includes

276
00:09:09,600 --> 00:09:11,680
the entities operations inputs clock

277
00:09:11,680 --> 00:09:12,880
values

278
00:09:12,880 --> 00:09:14,080
entities

279
00:09:14,080 --> 00:09:16,080
states and other values

280
00:09:16,080 --> 00:09:18,000
and then you can look at these and place

281
00:09:18,000 --> 00:09:20,160
well-defined restrictions on them and

282
00:09:20,160 --> 00:09:23,440
models and requirements

283
00:09:23,440 --> 00:09:25,760
so we talked a lot about models but they

284
00:09:25,760 --> 00:09:28,320
may be abstract so let's look more

285
00:09:28,320 --> 00:09:30,000
closely at what we mean by models in

286
00:09:30,000 --> 00:09:30,959
moss

287
00:09:30,959 --> 00:09:32,240
so first

288
00:09:32,240 --> 00:09:33,839
on the left we have examples of models

289
00:09:33,839 --> 00:09:35,760
which we can define and it's kind of

290
00:09:35,760 --> 00:09:37,760
like a menu where you can pick and

291
00:09:37,760 --> 00:09:40,240
choose the ones that you need

292
00:09:40,240 --> 00:09:42,320
and each model is a clearly

293
00:09:42,320 --> 00:09:44,480
independently defined piece or item on

294
00:09:44,480 --> 00:09:46,000
the menu

295
00:09:46,000 --> 00:09:47,279
and then they're defined using

296
00:09:47,279 --> 00:09:49,360
predicates so you can have adversary

297
00:09:49,360 --> 00:09:50,560
models

298
00:09:50,560 --> 00:09:53,360
um like man in the middle byzantine

299
00:09:53,360 --> 00:09:55,440
threshold you can have communication

300
00:09:55,440 --> 00:09:57,920
models like authenticated communication

301
00:09:57,920 --> 00:10:00,560
reliable communication and others you

302
00:10:00,560 --> 00:10:02,640
can have clock models like boundary

303
00:10:02,640 --> 00:10:04,560
drift or synchronize clocks

304
00:10:04,560 --> 00:10:06,880
you can have secure key initialization

305
00:10:06,880 --> 00:10:08,320
models

306
00:10:08,320 --> 00:10:10,160
and then we enforce a model by looking

307
00:10:10,160 --> 00:10:11,600
at the transcript

308
00:10:11,600 --> 00:10:13,120
of the execution and checking if the

309
00:10:13,120 --> 00:10:15,440
adversary satisfies the model based on

310
00:10:15,440 --> 00:10:18,519
the transcript

311
00:10:18,880 --> 00:10:21,120
and so i'll go over definitions more in

312
00:10:21,120 --> 00:10:22,959
a moment but basically when we assume a

313
00:10:22,959 --> 00:10:23,920
model

314
00:10:23,920 --> 00:10:26,240
we consider only adversaries that

315
00:10:26,240 --> 00:10:28,000
satisfy the model so

316
00:10:28,000 --> 00:10:30,720
only adverse series for which

317
00:10:30,720 --> 00:10:32,640
the transcript satisfies the model with

318
00:10:32,640 --> 00:10:34,720
a sufficient probability

319
00:10:34,720 --> 00:10:36,560
models are independent of the execution

320
00:10:36,560 --> 00:10:38,480
process and requirements

321
00:10:38,480 --> 00:10:39,839
and they're also independent of other

322
00:10:39,839 --> 00:10:42,079
models so like a fault model and a

323
00:10:42,079 --> 00:10:44,000
synchronization model can be completely

324
00:10:44,000 --> 00:10:45,440
separate

325
00:10:45,440 --> 00:10:47,440
and we can also include multiple sub

326
00:10:47,440 --> 00:10:48,959
models in a model

327
00:10:48,959 --> 00:10:51,040
so they're easy to combine and we can

328
00:10:51,040 --> 00:10:53,519
reuse the definitions of models across

329
00:10:53,519 --> 00:10:55,600
systems and works

330
00:10:55,600 --> 00:10:57,680
more specifically a model is a set of

331
00:10:57,680 --> 00:10:59,040
pairs pi beta which we call

332
00:10:59,040 --> 00:11:00,640
specifications

333
00:11:00,640 --> 00:11:02,880
um our pi is a predicate and that has

334
00:11:02,880 --> 00:11:04,640
the base function which specifies the

335
00:11:04,640 --> 00:11:06,640
probability which is allowed for the

336
00:11:06,640 --> 00:11:09,680
adversary to win against the predicate

337
00:11:09,680 --> 00:11:11,440
and since models are set so we can

338
00:11:11,440 --> 00:11:14,560
combine them by taking their union

339
00:11:14,560 --> 00:11:16,480
and the reason for the base function is

340
00:11:16,480 --> 00:11:18,480
that we might want different predicates

341
00:11:18,480 --> 00:11:20,640
to hold with different probabilities for

342
00:11:20,640 --> 00:11:22,720
example confidentiality we might want to

343
00:11:22,720 --> 00:11:24,800
allow the adversary to win with

344
00:11:24,800 --> 00:11:26,480
probability one-half

345
00:11:26,480 --> 00:11:28,560
and for authenticity and we might want

346
00:11:28,560 --> 00:11:30,959
to allow two to the minus l probability

347
00:11:30,959 --> 00:11:33,440
if we're using l-bit tags

348
00:11:33,440 --> 00:11:35,600
um in the protocol and for others you

349
00:11:35,600 --> 00:11:37,839
might just want negligible or zero

350
00:11:37,839 --> 00:11:39,760
probability of winning so then you can

351
00:11:39,760 --> 00:11:41,760
just use the constant zero

352
00:11:41,760 --> 00:11:43,920
and we can define these probabilities

353
00:11:43,920 --> 00:11:46,399
easily in the base functions

354
00:11:46,399 --> 00:11:48,959
so how do we define an adversary

355
00:11:48,959 --> 00:11:51,839
satisfying a model

356
00:11:51,839 --> 00:11:53,920
for the case where the model includes

357
00:11:53,920 --> 00:11:55,920
just one specification we would say that

358
00:11:55,920 --> 00:11:58,639
adversary a satisfies model m

359
00:11:58,639 --> 00:12:00,720
which includes this one specification pi

360
00:12:00,720 --> 00:12:02,000
beta

361
00:12:02,000 --> 00:12:03,839
if for every protocol the probability

362
00:12:03,839 --> 00:12:05,839
that the predicate over the transcript

363
00:12:05,839 --> 00:12:08,399
is false is the most negligibly greater

364
00:12:08,399 --> 00:12:10,399
than the base function

365
00:12:10,399 --> 00:12:12,560
and t here is the transcript output by

366
00:12:12,560 --> 00:12:14,480
running the execution process with the

367
00:12:14,480 --> 00:12:18,160
adversary a and protocol p

368
00:12:18,399 --> 00:12:20,959
and i mean by negligibly i mean

369
00:12:20,959 --> 00:12:22,240
negligibly in the length of the

370
00:12:22,240 --> 00:12:24,240
parameters per params

371
00:12:24,240 --> 00:12:25,279
and then if there are multiple

372
00:12:25,279 --> 00:12:26,959
specifications we can just check this

373
00:12:26,959 --> 00:12:29,839
for each one of them

374
00:12:30,079 --> 00:12:32,399
as an example here is a model which

375
00:12:32,399 --> 00:12:34,560
assumes bounded drip clocks

376
00:12:34,560 --> 00:12:36,399
and the probability function is the

377
00:12:36,399 --> 00:12:38,959
constant 0 here so the adversary should

378
00:12:38,959 --> 00:12:40,320
not break this

379
00:12:40,320 --> 00:12:43,760
ever or only with negligible probability

380
00:12:43,760 --> 00:12:46,320
um and the predicate and algorithm one

381
00:12:46,320 --> 00:12:48,560
checks that the local clock

382
00:12:48,560 --> 00:12:50,399
values which are set by the adversary

383
00:12:50,399 --> 00:12:52,560
and execution are always within delta

384
00:12:52,560 --> 00:12:54,720
clock of the real time which is also set

385
00:12:54,720 --> 00:12:57,040
by the adversary

386
00:12:57,040 --> 00:12:58,639
and also checks that real time is

387
00:12:58,639 --> 00:13:00,320
monotonically increasing over the

388
00:13:00,320 --> 00:13:01,760
execution

389
00:13:01,760 --> 00:13:04,000
and so this is simple and small and

390
00:13:04,000 --> 00:13:05,440
reusable

391
00:13:05,440 --> 00:13:07,440
and there are many situations where you

392
00:13:07,440 --> 00:13:09,200
might want to use this model to assume

393
00:13:09,200 --> 00:13:12,160
boundary drift clocks

394
00:13:13,600 --> 00:13:15,360
okay so now let's look more closely at

395
00:13:15,360 --> 00:13:17,040
requirements

396
00:13:17,040 --> 00:13:18,800
on the left we have examples and

397
00:13:18,800 --> 00:13:20,720
requirements we can define

398
00:13:20,720 --> 00:13:22,560
again it's a nice menu

399
00:13:22,560 --> 00:13:24,560
and we can have generic requirements it

400
00:13:24,560 --> 00:13:26,639
can be used for different protocols

401
00:13:26,639 --> 00:13:28,480
like indistinguishability

402
00:13:28,480 --> 00:13:31,040
a false positive verifiable attribution

403
00:13:31,040 --> 00:13:33,839
can have pki requirements

404
00:13:33,839 --> 00:13:35,760
and this work actually began after

405
00:13:35,760 --> 00:13:38,079
trying to use the game basin simulation

406
00:13:38,079 --> 00:13:39,440
based approaches

407
00:13:39,440 --> 00:13:41,920
for pki specifications which turned out

408
00:13:41,920 --> 00:13:45,360
to be impractical so we designed moss

409
00:13:45,360 --> 00:13:47,040
so you can have accountability

410
00:13:47,040 --> 00:13:49,600
transparency privacy requirements

411
00:13:49,600 --> 00:13:51,199
and we can also have other specific

412
00:13:51,199 --> 00:13:53,760
requirements for specific protocols like

413
00:13:53,760 --> 00:13:55,839
for example authenticated broadcast for

414
00:13:55,839 --> 00:13:59,120
a broadcasting protocol

415
00:13:59,360 --> 00:14:00,720
requirements are defined just like

416
00:14:00,720 --> 00:14:02,560
models and then we check that a protocol

417
00:14:02,560 --> 00:14:04,320
satisfies a requirement

418
00:14:04,320 --> 00:14:06,639
under some specific model

419
00:14:06,639 --> 00:14:08,720
and we basically consider adversaries

420
00:14:08,720 --> 00:14:11,120
which satisfy the model and again we

421
00:14:11,120 --> 00:14:13,600
look at the transcript to see if it

422
00:14:13,600 --> 00:14:15,120
if the requirement is satisfied with

423
00:14:15,120 --> 00:14:17,440
sufficient probability

424
00:14:17,440 --> 00:14:19,279
and since the adversary controls the

425
00:14:19,279 --> 00:14:21,920
execution then by checking

426
00:14:21,920 --> 00:14:24,160
that the adversary satisfies

427
00:14:24,160 --> 00:14:26,880
a model we are effectively checking that

428
00:14:26,880 --> 00:14:28,399
certain assumptions are held during the

429
00:14:28,399 --> 00:14:29,519
execution

430
00:14:29,519 --> 00:14:31,920
so this is how we specify requirements

431
00:14:31,920 --> 00:14:35,040
for a protocol under a model

432
00:14:35,040 --> 00:14:36,480
and requirements are well defined using

433
00:14:36,480 --> 00:14:39,040
predicates like models

434
00:14:39,040 --> 00:14:41,680
and they can be compared and can include

435
00:14:41,680 --> 00:14:43,760
sub-requirements also and the generic

436
00:14:43,760 --> 00:14:46,880
requirements can be reused

437
00:14:46,880 --> 00:14:49,120
so just like for models a requirement is

438
00:14:49,120 --> 00:14:51,600
a set of pairs pi beta which we call

439
00:14:51,600 --> 00:14:53,839
specifications

440
00:14:53,839 --> 00:14:55,519
so these are these pairs of predicates

441
00:14:55,519 --> 00:14:56,839
and probability

442
00:14:56,839 --> 00:14:58,959
functions and for the case where the

443
00:14:58,959 --> 00:15:01,199
requirement includes one specification

444
00:15:01,199 --> 00:15:03,040
we say that a protocol p

445
00:15:03,040 --> 00:15:05,040
satisfies requirement r which includes

446
00:15:05,040 --> 00:15:06,959
this one specification

447
00:15:06,959 --> 00:15:08,800
under model m

448
00:15:08,800 --> 00:15:10,480
and for every adversary a which

449
00:15:10,480 --> 00:15:13,199
satisfies m the probability that the

450
00:15:13,199 --> 00:15:14,880
predicate over the transcript is false

451
00:15:14,880 --> 00:15:17,120
is at most negligibly greater than the

452
00:15:17,120 --> 00:15:18,880
base function

453
00:15:18,880 --> 00:15:21,120
and t is again the transcript output by

454
00:15:21,120 --> 00:15:25,639
the execution with a and p

455
00:15:27,360 --> 00:15:29,360
so as an example here is a delta

456
00:15:29,360 --> 00:15:31,600
transparency requirement which is a bki

457
00:15:31,600 --> 00:15:33,199
requirement

458
00:15:33,199 --> 00:15:35,759
intuitively we say that a certificate

459
00:15:35,759 --> 00:15:37,440
adjusted as though the transparent must

460
00:15:37,440 --> 00:15:39,680
be available to all interested parties

461
00:15:39,680 --> 00:15:41,759
within delta time of its transparency

462
00:15:41,759 --> 00:15:43,680
activation being issued by a proper

463
00:15:43,680 --> 00:15:45,680
authority

464
00:15:45,680 --> 00:15:47,680
below is the delta transparency

465
00:15:47,680 --> 00:15:49,519
predicate

466
00:15:49,519 --> 00:15:50,959
notice that this predicate is more

467
00:15:50,959 --> 00:15:53,120
complicated than the clock drift one but

468
00:15:53,120 --> 00:15:55,600
we can use sub predicates

469
00:15:55,600 --> 00:15:57,519
in this project kit so we have one to

470
00:15:57,519 --> 00:15:59,199
check that an entity is honest when to

471
00:15:59,199 --> 00:16:01,680
confirm public key we want to verify a

472
00:16:01,680 --> 00:16:03,519
certificate of station

473
00:16:03,519 --> 00:16:04,959
so you can also have modularity and

474
00:16:04,959 --> 00:16:07,360
predicates and you can use and reuse the

475
00:16:07,360 --> 00:16:09,839
smaller predicates for example we can

476
00:16:09,839 --> 00:16:12,160
reuse the honest entity predicate and

477
00:16:12,160 --> 00:16:16,319
other pre-ki requirement predicates

478
00:16:17,519 --> 00:16:19,680
so as i've been saying in mostly support

479
00:16:19,680 --> 00:16:22,079
modularity of models and requirements

480
00:16:22,079 --> 00:16:24,079
and we have some lemons which basically

481
00:16:24,079 --> 00:16:26,079
formalize the intuitive modularity

482
00:16:26,079 --> 00:16:28,480
properties you thought you might expect

483
00:16:28,480 --> 00:16:30,240
so you can know some properties about

484
00:16:30,240 --> 00:16:32,639
combined or stronger or weaker models

485
00:16:32,639 --> 00:16:34,480
and requirements and i'll just talk

486
00:16:34,480 --> 00:16:36,959
about two of them here the first one is

487
00:16:36,959 --> 00:16:40,800
the requirement model monotonicity llama

488
00:16:40,800 --> 00:16:44,560
which says that for any two models where

489
00:16:44,560 --> 00:16:47,680
m is a subset of m hat so

490
00:16:47,680 --> 00:16:49,600
m hat is a stronger model and m is the

491
00:16:49,600 --> 00:16:53,120
weaker model and any requirement are

492
00:16:53,120 --> 00:16:55,199
if the protocol satisfies the

493
00:16:55,199 --> 00:16:57,519
requirement under the weaker model then

494
00:16:57,519 --> 00:16:59,199
it must satisfy it under the stronger

495
00:16:59,199 --> 00:17:00,639
model

496
00:17:00,639 --> 00:17:02,959
and the second lemma is the requirement

497
00:17:02,959 --> 00:17:04,720
it's union level

498
00:17:04,720 --> 00:17:06,959
which is that for any two models mrn

499
00:17:06,959 --> 00:17:09,359
prime and any requirements are in our

500
00:17:09,359 --> 00:17:10,880
prime

501
00:17:10,880 --> 00:17:13,280
if we take the combined uh the union of

502
00:17:13,280 --> 00:17:14,720
the two models in the union of the two

503
00:17:14,720 --> 00:17:16,240
requirements

504
00:17:16,240 --> 00:17:18,640
and if the protocol satisfies the first

505
00:17:18,640 --> 00:17:20,640
requirement under the first model

506
00:17:20,640 --> 00:17:22,000
and also satisfies the second

507
00:17:22,000 --> 00:17:24,480
requirement under the second model

508
00:17:24,480 --> 00:17:26,079
then it satisfies the combined

509
00:17:26,079 --> 00:17:29,600
requirement under the combined model

510
00:17:29,600 --> 00:17:31,600
and you can see the paper for more

511
00:17:31,600 --> 00:17:34,959
llamas and proofs

512
00:17:36,240 --> 00:17:40,240
so let me describe an analysis example

513
00:17:40,240 --> 00:17:41,760
using moss

514
00:17:41,760 --> 00:17:43,120
so we have these

515
00:17:43,120 --> 00:17:46,000
separate focus models and requirements

516
00:17:46,000 --> 00:17:47,039
and

517
00:17:47,039 --> 00:17:48,640
this facilitates gradual protocol

518
00:17:48,640 --> 00:17:50,160
development and analysis and as an

519
00:17:50,160 --> 00:17:51,360
example

520
00:17:51,360 --> 00:17:53,520
we analyzed a simple authenticated

521
00:17:53,520 --> 00:17:56,720
broadcast protocol which i call p here

522
00:17:56,720 --> 00:17:59,039
and we did it in three steps under three

523
00:17:59,039 --> 00:18:01,840
models so in the first step

524
00:18:01,840 --> 00:18:04,320
we use the model that assumes secure key

525
00:18:04,320 --> 00:18:05,280
sharing

526
00:18:05,280 --> 00:18:07,600
and initialization assumptions

527
00:18:07,600 --> 00:18:09,280
and then we showed that the protocol

528
00:18:09,280 --> 00:18:13,039
ensures authenticity under this model

529
00:18:13,039 --> 00:18:15,840
and then the second step we assumed also

530
00:18:15,840 --> 00:18:17,919
a bounded clock drift

531
00:18:17,919 --> 00:18:20,240
so we didn't define a whole new model we

532
00:18:20,240 --> 00:18:22,000
used the union of the

533
00:18:22,000 --> 00:18:24,000
model from the first step and the

534
00:18:24,000 --> 00:18:27,039
boundary clock drift model

535
00:18:27,039 --> 00:18:29,520
and this and then we showed that the

536
00:18:29,520 --> 00:18:31,760
protocol achieves freshness also so

537
00:18:31,760 --> 00:18:34,240
authenticity and freshness under this

538
00:18:34,240 --> 00:18:37,360
stronger model and then the third step

539
00:18:37,360 --> 00:18:39,840
um we also added assumptions about

540
00:18:39,840 --> 00:18:42,160
bounded delay communication and the

541
00:18:42,160 --> 00:18:44,240
first interval and showed that the

542
00:18:44,240 --> 00:18:46,559
protocol ensures

543
00:18:46,559 --> 00:18:48,880
correct boundary delay delivery of the

544
00:18:48,880 --> 00:18:51,039
broadcast messages

545
00:18:51,039 --> 00:18:54,160
under the stronger model

546
00:18:55,280 --> 00:18:57,200
so let me mention three additional

547
00:18:57,200 --> 00:18:59,679
features of moss which i didn't discuss

548
00:18:59,679 --> 00:19:01,200
so far

549
00:19:01,200 --> 00:19:03,760
the first one is um that the execution

550
00:19:03,760 --> 00:19:05,440
process can be extended

551
00:19:05,440 --> 00:19:07,919
so we define a set of execution process

552
00:19:07,919 --> 00:19:09,679
operations

553
00:19:09,679 --> 00:19:11,840
which we call x and then we can add

554
00:19:11,840 --> 00:19:13,919
operations which the adversary can use

555
00:19:13,919 --> 00:19:15,919
to this set which adds additional

556
00:19:15,919 --> 00:19:17,919
functionality which the basic execution

557
00:19:17,919 --> 00:19:19,760
process doesn't provide

558
00:19:19,760 --> 00:19:22,080
um our support for example entity

559
00:19:22,080 --> 00:19:23,840
corruptions confidentiality and shared

560
00:19:23,840 --> 00:19:25,039
keys

561
00:19:25,039 --> 00:19:27,200
and one reason for this design is that

562
00:19:27,200 --> 00:19:29,280
it keeps the basic execution process

563
00:19:29,280 --> 00:19:30,320
simple

564
00:19:30,320 --> 00:19:32,240
so that it can be understood by people

565
00:19:32,240 --> 00:19:34,799
not used to formal model models and

566
00:19:34,799 --> 00:19:36,720
definitions

567
00:19:36,720 --> 00:19:40,160
and uh sometimes we don't need the

568
00:19:40,160 --> 00:19:41,200
extra

569
00:19:41,200 --> 00:19:43,840
uh functionality like for example you

570
00:19:43,840 --> 00:19:45,679
could have added confidentiality to the

571
00:19:45,679 --> 00:19:47,919
basic execution process but it's not

572
00:19:47,919 --> 00:19:49,440
always needed for

573
00:19:49,440 --> 00:19:50,880
different protocols which only care

574
00:19:50,880 --> 00:19:52,320
about authentication and not

575
00:19:52,320 --> 00:19:53,919
confidentiality

576
00:19:53,919 --> 00:19:55,440
so

577
00:19:55,440 --> 00:19:58,240
we only left this for the full execution

578
00:19:58,240 --> 00:20:01,360
process using these x operations

579
00:20:01,360 --> 00:20:03,200
and the full execution process includes

580
00:20:03,200 --> 00:20:05,520
everything that the basic execution

581
00:20:05,520 --> 00:20:08,158
process has

582
00:20:08,400 --> 00:20:10,559
on second mos also supports secure

583
00:20:10,559 --> 00:20:12,240
concrete security facing a small

584
00:20:12,240 --> 00:20:14,960
extension to the execution

585
00:20:14,960 --> 00:20:17,600
and concrete security definitions for

586
00:20:17,600 --> 00:20:19,840
model satisfying requirements satisfying

587
00:20:19,840 --> 00:20:21,679
are quite similar to the asymptotic ones

588
00:20:21,679 --> 00:20:24,799
but they include concrete bounds

589
00:20:24,799 --> 00:20:26,480
and this is important to provide support

590
00:20:26,480 --> 00:20:28,559
for applied protocols so that we can

591
00:20:28,559 --> 00:20:30,400
have concrete bounds and concrete values

592
00:20:30,400 --> 00:20:32,240
of parameters

593
00:20:32,240 --> 00:20:34,880
and third um we can also ensure

594
00:20:34,880 --> 00:20:37,120
polynomial time execution

595
00:20:37,120 --> 00:20:38,159
so

596
00:20:38,159 --> 00:20:40,320
because we have this problem

597
00:20:40,320 --> 00:20:42,240
that even if the adversarian protocol a

598
00:20:42,240 --> 00:20:44,720
polynomial the total runtime

599
00:20:44,720 --> 00:20:46,559
might not be polynomial because over the

600
00:20:46,559 --> 00:20:48,799
execution there's this interaction and

601
00:20:48,799 --> 00:20:50,720
the outputs become inputs

602
00:20:50,720 --> 00:20:52,320
and so the inputs can keep growing and

603
00:20:52,320 --> 00:20:56,159
eventually allow exponential time

604
00:20:56,159 --> 00:20:56,880
for

605
00:20:56,880 --> 00:20:58,000
for the

606
00:20:58,000 --> 00:21:00,720
for a for the adversarial protocol

607
00:21:00,720 --> 00:21:04,320
in the size of the original parameters

608
00:21:04,320 --> 00:21:06,320
or for both of them and this should be

609
00:21:06,320 --> 00:21:09,120
prevented for a synthetic analysis

610
00:21:09,120 --> 00:21:12,719
and we have considered this in moss

611
00:21:12,880 --> 00:21:14,640
mouse does have some limitations and we

612
00:21:14,640 --> 00:21:16,880
have some errors for future work so the

613
00:21:16,880 --> 00:21:18,320
first one is that currently we don't

614
00:21:18,320 --> 00:21:21,520
have composability like uc does

615
00:21:21,520 --> 00:21:22,960
and this is a useful feature for

616
00:21:22,960 --> 00:21:24,960
protocol design and analysis

617
00:21:24,960 --> 00:21:26,960
and actually uncomposibility also

618
00:21:26,960 --> 00:21:28,880
provides modularity but its modularity

619
00:21:28,880 --> 00:21:31,200
for protocol design rather than

620
00:21:31,200 --> 00:21:34,480
for um the specifications so it'll be

621
00:21:34,480 --> 00:21:36,480
great to have this and also so and as i

622
00:21:36,480 --> 00:21:38,000
said we have some intuition and our

623
00:21:38,000 --> 00:21:40,320
optimistic that it can be done

624
00:21:40,320 --> 00:21:42,720
and the second area is that moss is game

625
00:21:42,720 --> 00:21:44,559
based but some definitions seem to

626
00:21:44,559 --> 00:21:47,200
require stimulation like zero knowledge

627
00:21:47,200 --> 00:21:48,799
and as i said there is the open question

628
00:21:48,799 --> 00:21:50,559
of whether we can have all modular

629
00:21:50,559 --> 00:21:54,480
simulation-based specifications also

630
00:21:54,480 --> 00:21:55,600
and these could be modular

631
00:21:55,600 --> 00:21:57,440
specifications and simulation based

632
00:21:57,440 --> 00:21:58,400
frameworks

633
00:21:58,400 --> 00:22:00,559
and or extending moss to support

634
00:22:00,559 --> 00:22:03,200
simulation-based specifications

635
00:22:03,200 --> 00:22:05,280
and third we don't have automated tools

636
00:22:05,280 --> 00:22:07,360
for computer-aided analysis so these

637
00:22:07,360 --> 00:22:08,720
could be developed either for

638
00:22:08,720 --> 00:22:11,120
translating mass specifications to other

639
00:22:11,120 --> 00:22:13,440
forms supported by such tools and or

640
00:22:13,440 --> 00:22:16,480
tools for moss directly

641
00:22:16,480 --> 00:22:19,280
in conclusion omos facilitates modular

642
00:22:19,280 --> 00:22:22,400
security specifications for protocols

643
00:22:22,400 --> 00:22:24,480
it allows verbal security for practical

644
00:22:24,480 --> 00:22:25,679
protocols

645
00:22:25,679 --> 00:22:27,760
which may assume complex models which

646
00:22:27,760 --> 00:22:29,120
might include communication

647
00:22:29,120 --> 00:22:30,559
synchronization

648
00:22:30,559 --> 00:22:32,720
faults and other assumptions

649
00:22:32,720 --> 00:22:34,799
and it allows the reuse of models and

650
00:22:34,799 --> 00:22:37,280
requirement definitions across protocols

651
00:22:37,280 --> 00:22:38,640
and across works

652
00:22:38,640 --> 00:22:41,039
which can also make it easier to compare

653
00:22:41,039 --> 00:22:42,240
words

654
00:22:42,240 --> 00:22:44,240
of course please see the paper

655
00:22:44,240 --> 00:22:46,240
for details and proofs

656
00:22:46,240 --> 00:22:49,520
and thank you

