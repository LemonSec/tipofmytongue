1
00:00:03,199 --> 00:00:04,960
you're ready to go have a good session

2
00:00:04,960 --> 00:00:06,720
great thank you

3
00:00:06,720 --> 00:00:09,599
okay uh so i'm john skank and this is

4
00:00:09,599 --> 00:00:11,280
the last script analysis session of

5
00:00:11,280 --> 00:00:13,120
crypto 2021

6
00:00:13,120 --> 00:00:14,639
uh we have a nice program here we're

7
00:00:14,639 --> 00:00:16,640
going to do five five minute talks and

8
00:00:16,640 --> 00:00:19,039
then move over to a q a uh at any point

9
00:00:19,039 --> 00:00:20,480
you can start dropping questions into

10
00:00:20,480 --> 00:00:22,240
the zulu chat

11
00:00:22,240 --> 00:00:24,080
kay just dropped a uh

12
00:00:24,080 --> 00:00:26,720
link in the zoom chat

13
00:00:26,720 --> 00:00:27,760
um

14
00:00:27,760 --> 00:00:29,439
so yeah we'll move over to q a at about

15
00:00:29,439 --> 00:00:32,238
quarter past maybe 20 past the hour

16
00:00:32,238 --> 00:00:34,640
and uh let's get started so first we

17
00:00:34,640 --> 00:00:36,960
have sam hopkins presenting uh

18
00:00:36,960 --> 00:00:38,800
counterexamples to new circular security

19
00:00:38,800 --> 00:00:41,200
assumptions underlying i o take it away

20
00:00:41,200 --> 00:00:42,320
sam

21
00:00:42,320 --> 00:00:44,320
thanks so much so this is joint work

22
00:00:44,320 --> 00:00:48,000
with um i use jane and rachel lynn

23
00:00:48,000 --> 00:00:50,480
um our work falls in a line of recent

24
00:00:50,480 --> 00:00:51,840
works which are studying the following

25
00:00:51,840 --> 00:00:54,320
basic question can indistinguishability

26
00:00:54,320 --> 00:00:57,360
obfuscation which is a intensely studied

27
00:00:57,360 --> 00:00:59,520
very useful cryptographic primitive from

28
00:00:59,520 --> 00:01:01,359
the last decade or so

29
00:01:01,359 --> 00:01:03,920
can it be based on lattices alone

30
00:01:03,920 --> 00:01:07,119
so only very recently we have a

31
00:01:07,119 --> 00:01:08,799
construction of indistinguishability

32
00:01:08,799 --> 00:01:10,320
obfuscation which is based on

33
00:01:10,320 --> 00:01:12,640
well-founded assumptions by jane lynn

34
00:01:12,640 --> 00:01:13,760
and sahai

35
00:01:13,760 --> 00:01:15,040
but

36
00:01:15,040 --> 00:01:17,200
there are many potential advantages to

37
00:01:17,200 --> 00:01:19,119
give indistinguishability obfuscation

38
00:01:19,119 --> 00:01:21,600
based only on lattices

39
00:01:21,600 --> 00:01:23,119
one is that such a construction would be

40
00:01:23,119 --> 00:01:25,439
plausibly post-quantum secure

41
00:01:25,439 --> 00:01:27,040
existing the existing construction uses

42
00:01:27,040 --> 00:01:28,479
assumptions which are not post quantum

43
00:01:28,479 --> 00:01:30,640
secure and the other is that if we can

44
00:01:30,640 --> 00:01:32,079
reduce the number of assumptions needed

45
00:01:32,079 --> 00:01:33,680
we can hope for simpler and more post

46
00:01:33,680 --> 00:01:35,920
parsimonious constructions

47
00:01:35,920 --> 00:01:37,600
so these are just two of many potential

48
00:01:37,600 --> 00:01:39,840
advantages

49
00:01:39,840 --> 00:01:41,439
in particular there are three recent

50
00:01:41,439 --> 00:01:43,840
works that give new and simple candidate

51
00:01:43,840 --> 00:01:45,920
i o constructions in this direction due

52
00:01:45,920 --> 00:01:48,159
to brokerski dot lingard molovolta gay

53
00:01:48,159 --> 00:01:50,560
and pass and we and wix

54
00:01:50,560 --> 00:01:52,880
and the latter two works in particular

55
00:01:52,880 --> 00:01:55,119
give clean and simple to state

56
00:01:55,119 --> 00:01:57,520
falsifiable assumptions under which they

57
00:01:57,520 --> 00:01:59,840
can prove security of their candidate i

58
00:01:59,840 --> 00:02:02,320
o construction so this is very exciting

59
00:02:02,320 --> 00:02:04,479
these assumptions are not yet just

60
00:02:04,479 --> 00:02:06,159
learning with errors that would really

61
00:02:06,159 --> 00:02:07,840
solve the problem

62
00:02:07,840 --> 00:02:09,199
but they're what i'm going to call an

63
00:02:09,199 --> 00:02:12,239
lwe plus plus type of assumption they

64
00:02:12,239 --> 00:02:14,080
assume learning with errors and then

65
00:02:14,080 --> 00:02:15,840
they assume that some

66
00:02:15,840 --> 00:02:17,520
fully homomorphic encryption scheme

67
00:02:17,520 --> 00:02:19,599
whose security is based on learning with

68
00:02:19,599 --> 00:02:22,080
errors remains secure in the presence of

69
00:02:22,080 --> 00:02:23,840
a couple of additional types of

70
00:02:23,840 --> 00:02:25,360
information leakage

71
00:02:25,360 --> 00:02:28,720
which i'm going to describe very shortly

72
00:02:28,720 --> 00:02:29,440
so

73
00:02:29,440 --> 00:02:31,519
given these exciting constructions it's

74
00:02:31,519 --> 00:02:34,480
now imperative to do crypto analysis on

75
00:02:34,480 --> 00:02:36,959
this kind of lwe plus plus assumption to

76
00:02:36,959 --> 00:02:39,280
understand the lay of the land what kind

77
00:02:39,280 --> 00:02:40,959
of assumptions like this could be true

78
00:02:40,959 --> 00:02:43,280
which are not and how can we give

79
00:02:43,280 --> 00:02:44,720
plausible assumptions on which we can

80
00:02:44,720 --> 00:02:47,920
base security of i o

81
00:02:48,160 --> 00:02:50,879
so our results in a nutshell are that

82
00:02:50,879 --> 00:02:54,000
the particular forms of the lwe plus

83
00:02:54,000 --> 00:02:56,000
plus assumptions that are given in gay

84
00:02:56,000 --> 00:02:57,680
and past and we in wicks are

85
00:02:57,680 --> 00:03:00,000
unfortunately not true so we give a tax

86
00:03:00,000 --> 00:03:01,519
on these assumptions

87
00:03:01,519 --> 00:03:05,519
however to be clear the overall strategy

88
00:03:05,519 --> 00:03:08,000
of the i o constructions of of all three

89
00:03:08,000 --> 00:03:10,159
papers and the constructions themselves

90
00:03:10,159 --> 00:03:12,000
are not broken by our work and in fact

91
00:03:12,000 --> 00:03:14,879
remain promising so it's our hope that

92
00:03:14,879 --> 00:03:17,200
our attacks can be used to give more

93
00:03:17,200 --> 00:03:19,040
refined assumptions

94
00:03:19,040 --> 00:03:20,480
under which we could still prove

95
00:03:20,480 --> 00:03:22,239
security of io and hopefully eventually

96
00:03:22,239 --> 00:03:24,480
give assumptions that are that are that

97
00:03:24,480 --> 00:03:26,000
are believable and

98
00:03:26,000 --> 00:03:28,640
thoroughly tested

99
00:03:28,640 --> 00:03:29,599
so

100
00:03:29,599 --> 00:03:31,040
for the rest of the talk i'm going to

101
00:03:31,040 --> 00:03:32,720
give you a little more detail on the

102
00:03:32,720 --> 00:03:34,959
particular lw plus plus assumption used

103
00:03:34,959 --> 00:03:39,040
by gay and pass and our attack on it

104
00:03:39,040 --> 00:03:41,120
so let's fix some kind of nice fully

105
00:03:41,120 --> 00:03:42,720
homomorphic encryption scheme whose

106
00:03:42,720 --> 00:03:44,319
security is based on learning with

107
00:03:44,319 --> 00:03:46,319
errors for instance gentry's the high

108
00:03:46,319 --> 00:03:48,640
waters

109
00:03:48,640 --> 00:03:50,640
now i said that lwe plus plus

110
00:03:50,640 --> 00:03:53,200
assumptions assume security of uh of

111
00:03:53,200 --> 00:03:56,239
like gsw our fhe scheme plus a couple of

112
00:03:56,239 --> 00:03:57,760
additional kinds of leakages let me

113
00:03:57,760 --> 00:04:00,159
describe those leakages to you so the

114
00:04:00,159 --> 00:04:02,400
first is the leakage that happens in a

115
00:04:02,400 --> 00:04:04,799
circular security scheme just to refresh

116
00:04:04,799 --> 00:04:07,519
ourselves circular security means that

117
00:04:07,519 --> 00:04:08,400
some

118
00:04:08,400 --> 00:04:10,239
key cycle in this case a let's say a

119
00:04:10,239 --> 00:04:12,000
length two key cycle is released to the

120
00:04:12,000 --> 00:04:14,480
attacker that means that we set up two

121
00:04:14,480 --> 00:04:17,040
copies of our fhe scheme with a secret

122
00:04:17,040 --> 00:04:18,880
key and a public key and a secret key

123
00:04:18,880 --> 00:04:21,519
and a public key and we publish the

124
00:04:21,519 --> 00:04:23,280
secret key of

125
00:04:23,280 --> 00:04:25,360
one scheme encrypted under the public

126
00:04:25,360 --> 00:04:28,560
key of the other and and vice versa

127
00:04:28,560 --> 00:04:31,040
so this kind of circular security while

128
00:04:31,040 --> 00:04:32,400
it you know security of a scheme like

129
00:04:32,400 --> 00:04:34,000
this doesn't seem to follow directly

130
00:04:34,000 --> 00:04:36,880
from lwe it's believed to be secure i

131
00:04:36,880 --> 00:04:38,880
think it's fair to say for natural

132
00:04:38,880 --> 00:04:41,120
looking fhe schemes and in particular

133
00:04:41,120 --> 00:04:43,360
this kind of circular security underlies

134
00:04:43,360 --> 00:04:45,199
uh unleveled fully homomorphic

135
00:04:45,199 --> 00:04:47,520
encryption so it's not a crazy kind of

136
00:04:47,520 --> 00:04:50,880
assumption to say that that gsw uh fully

137
00:04:50,880 --> 00:04:52,560
homomorphic encryption remains secure in

138
00:04:52,560 --> 00:04:54,840
the presence of a key cycle like

139
00:04:54,840 --> 00:04:57,199
this the other kind of leakage is a

140
00:04:57,199 --> 00:04:59,040
little bit more complicated it's called

141
00:04:59,040 --> 00:05:00,720
in gay and past they call this shielded

142
00:05:00,720 --> 00:05:03,520
randomness leakage the basic idea is

143
00:05:03,520 --> 00:05:06,800
that in the middle of a cpa attack

144
00:05:06,800 --> 00:05:08,160
security game

145
00:05:08,160 --> 00:05:10,720
the attacker gets to call some oracle

146
00:05:10,720 --> 00:05:12,960
which i'm going to describe in a minute

147
00:05:12,960 --> 00:05:15,520
um what the attacker does is specify a

148
00:05:15,520 --> 00:05:17,759
circuit the oracle evaluates this

149
00:05:17,759 --> 00:05:20,080
circuit with inputs given by the uh the

150
00:05:20,080 --> 00:05:21,600
message that the attacker is trying to

151
00:05:21,600 --> 00:05:23,039
learn something about

152
00:05:23,039 --> 00:05:24,720
and then the oracle tells the attacker

153
00:05:24,720 --> 00:05:26,400
some information about the randomness of

154
00:05:26,400 --> 00:05:27,919
encryption that results after that

155
00:05:27,919 --> 00:05:29,199
circuit is evaluated fully

156
00:05:29,199 --> 00:05:30,720
homomorphically

157
00:05:30,720 --> 00:05:31,440
so

158
00:05:31,440 --> 00:05:32,960
just a tiny bit more detail and then

159
00:05:32,960 --> 00:05:36,639
i'll wrap up in 30 seconds or so

160
00:05:36,639 --> 00:05:38,400
basically what happens is the attacker

161
00:05:38,400 --> 00:05:41,280
chooses a circuit the oracle does an fhe

162
00:05:41,280 --> 00:05:42,720
valve on that circuit and then releases

163
00:05:42,720 --> 00:05:44,720
the resulting randomness of encryption

164
00:05:44,720 --> 00:05:46,400
if we're released in the clear this

165
00:05:46,400 --> 00:05:48,400
would be broken so instead the oracle

166
00:05:48,400 --> 00:05:50,720
releases it in a shielded fashion by

167
00:05:50,720 --> 00:05:53,199
adding some fresh randomness r star

168
00:05:53,199 --> 00:05:55,199
the catch is that the attacker has also

169
00:05:55,199 --> 00:05:57,360
previously gotten to see something about

170
00:05:57,360 --> 00:05:59,520
our star they've gotten to see a fresh

171
00:05:59,520 --> 00:06:01,280
encryption of zero using randomness of

172
00:06:01,280 --> 00:06:03,919
encryption r star

173
00:06:03,919 --> 00:06:04,720
so

174
00:06:04,720 --> 00:06:06,720
let me um

175
00:06:06,720 --> 00:06:08,800
this this is also a reasonable thing to

176
00:06:08,800 --> 00:06:10,319
believe would be secure in fact it's

177
00:06:10,319 --> 00:06:13,039
secure under lwe

178
00:06:13,039 --> 00:06:14,240
however

179
00:06:14,240 --> 00:06:16,560
moving past this slide it turns out that

180
00:06:16,560 --> 00:06:18,560
in the presence of both types of leakage

181
00:06:18,560 --> 00:06:20,560
this this is broken the scheme is broken

182
00:06:20,560 --> 00:06:22,160
and i'll tell you our attack from 10 000

183
00:06:22,160 --> 00:06:23,120
feet

184
00:06:23,120 --> 00:06:24,560
remember that what the attacker gets to

185
00:06:24,560 --> 00:06:26,479
do to call this uh randomness leakage

186
00:06:26,479 --> 00:06:28,479
oracle is choose a circuit and that

187
00:06:28,479 --> 00:06:30,400
circuit gets to depend on both the

188
00:06:30,400 --> 00:06:32,400
encrypted key cycle and the information

189
00:06:32,400 --> 00:06:33,520
that the attacker has about the

190
00:06:33,520 --> 00:06:34,800
shielding randomness that will

191
00:06:34,800 --> 00:06:36,319
eventually be used to release the

192
00:06:36,319 --> 00:06:38,479
remnant encryption from the circuit

193
00:06:38,479 --> 00:06:40,240
and the key idea is that the attacker

194
00:06:40,240 --> 00:06:43,280
will decrypt ct star to get access to

195
00:06:43,280 --> 00:06:45,199
our star inside the circuit that's going

196
00:06:45,199 --> 00:06:47,280
to be evaluated homomorphically they can

197
00:06:47,280 --> 00:06:48,560
do that because they have access to the

198
00:06:48,560 --> 00:06:51,039
encrypted key cycle

199
00:06:51,039 --> 00:06:52,240
for more details on the attack i

200
00:06:52,240 --> 00:06:53,520
encourage you to watch our longer talk

201
00:06:53,520 --> 00:06:55,120
or have a look at our paper i'll wrap up

202
00:06:55,120 --> 00:06:57,599
here thanks very much

203
00:06:57,599 --> 00:07:00,400
thanks sam um okay nice so let's move on

204
00:07:00,400 --> 00:07:01,840
to the next talk

205
00:07:01,840 --> 00:07:04,000
alex mai will present how to meet

206
00:07:04,000 --> 00:07:07,960
turnery lwe keys

207
00:07:22,319 --> 00:07:25,759
ah alex you're muted

208
00:07:26,080 --> 00:07:27,759
shows full screen right everything fine

209
00:07:27,759 --> 00:07:29,840
so far it is full screen yes and you're

210
00:07:29,840 --> 00:07:30,560
okay

211
00:07:30,560 --> 00:07:31,440
now

212
00:07:31,440 --> 00:07:34,319
okay fine so what do i mean by a ternary

213
00:07:34,319 --> 00:07:37,199
lwe keys

214
00:07:37,199 --> 00:07:38,720
so here's the definition of the problem

215
00:07:38,720 --> 00:07:42,240
you are given a and b as usual in uh lwe

216
00:07:42,240 --> 00:07:45,520
and you have the equation as b plus e

217
00:07:45,520 --> 00:07:48,240
but now your secret s and your arrow e

218
00:07:48,240 --> 00:07:50,319
are terminal reactors so they are from c

219
00:07:50,319 --> 00:07:52,080
o plus minus one to the n

220
00:07:52,080 --> 00:07:54,240
so many cryptosystems use these keys of

221
00:07:54,240 --> 00:07:56,800
bounded range and our results also apply

222
00:07:56,800 --> 00:07:59,280
if you have a larger fixed range like

223
00:07:59,280 --> 00:08:01,280
you add in plus minus twos and i will

224
00:08:01,280 --> 00:08:03,840
show you an example on the last slide

225
00:08:03,840 --> 00:08:05,759
and for the applications in this talk i

226
00:08:05,759 --> 00:08:07,360
will focus on then true but there are

227
00:08:07,360 --> 00:08:09,120
more applications in the paper like the

228
00:08:09,120 --> 00:08:12,400
signature schemes bliss and glp

229
00:08:12,400 --> 00:08:15,280
okay so in andrew you do not only have

230
00:08:15,280 --> 00:08:17,680
ternary keys but you also

231
00:08:17,680 --> 00:08:20,400
fix a number of plus minus ones that you

232
00:08:20,400 --> 00:08:21,840
have and this is called the weight and

233
00:08:21,840 --> 00:08:24,160
this is defined here so secret has

234
00:08:24,160 --> 00:08:28,000
weight w if s has w plus minus one

235
00:08:28,000 --> 00:08:30,319
coefficient so non-zero coefficients so

236
00:08:30,319 --> 00:08:31,840
as an example here is an end for

237
00:08:31,840 --> 00:08:35,120
instance with weight 254 and you usually

238
00:08:35,120 --> 00:08:38,000
evenly split in once and plus minus ones

239
00:08:38,000 --> 00:08:39,760
so now we are ready to define a search

240
00:08:39,760 --> 00:08:42,479
space so the search space is now the

241
00:08:42,479 --> 00:08:44,800
number of ternary keys which which is

242
00:08:44,800 --> 00:08:48,320
certain weight w and as an example here

243
00:08:48,320 --> 00:08:50,240
we have this multinomial coefficient as

244
00:08:50,240 --> 00:08:52,480
a search space for the keys

245
00:08:52,480 --> 00:08:54,959
and in this talk i will ask a very

246
00:08:54,959 --> 00:08:56,399
elementary questions what is the

247
00:08:56,399 --> 00:08:58,720
combinatorial complexity of finding s

248
00:08:58,720 --> 00:09:00,640
there's no lattices so far but i will

249
00:09:00,640 --> 00:09:01,839
come to letters

250
00:09:01,839 --> 00:09:03,040
later

251
00:09:03,040 --> 00:09:05,120
so the easiest thing is you search for

252
00:09:05,120 --> 00:09:07,760
all ternary s in your search space you

253
00:09:07,760 --> 00:09:09,839
need to check whether is

254
00:09:09,839 --> 00:09:11,839
b is ternary and this gives you

255
00:09:11,839 --> 00:09:14,560
complexity equal to the search space

256
00:09:14,560 --> 00:09:16,480
with constant memory

257
00:09:16,480 --> 00:09:18,080
but you could also do a meet in the

258
00:09:18,080 --> 00:09:20,720
middle so you split your secret s in two

259
00:09:20,720 --> 00:09:24,240
parts of the same dimension and half

260
00:09:24,240 --> 00:09:26,160
and then as you would expect in the meat

261
00:09:26,160 --> 00:09:28,959
in the middle you obtain the square root

262
00:09:28,959 --> 00:09:31,600
of the time but also memory square root

263
00:09:31,600 --> 00:09:33,440
of the search space

264
00:09:33,440 --> 00:09:36,560
yeah and this is due to atletico from 97

265
00:09:36,560 --> 00:09:38,080
and it's kind of the state of the art

266
00:09:38,080 --> 00:09:39,920
for the combinatorial complexity of

267
00:09:39,920 --> 00:09:41,040
finding s

268
00:09:41,040 --> 00:09:43,440
so what do we do in this talk so i will

269
00:09:43,440 --> 00:09:46,800
use a different splitting of s

270
00:09:46,800 --> 00:09:48,839
well let's

271
00:09:48,839 --> 00:09:52,959
see something seems to be broken oop

272
00:09:52,959 --> 00:09:55,360
hope you can find ah no it's fine

273
00:09:55,360 --> 00:09:59,120
so i split s as a sum s1 and s2 both of

274
00:09:59,120 --> 00:10:00,480
full dimension

275
00:10:00,480 --> 00:10:02,240
but with smaller weight and this is

276
00:10:02,240 --> 00:10:03,839
called the representation technique it

277
00:10:03,839 --> 00:10:06,000
was introduced by hawker claim and jewel

278
00:10:06,000 --> 00:10:07,120
yet

279
00:10:07,120 --> 00:10:10,079
eurocrypt 2010

280
00:10:10,079 --> 00:10:11,760
in the context of some sense some and

281
00:10:11,760 --> 00:10:13,440
here you see some improvements for

282
00:10:13,440 --> 00:10:15,440
subset some within the last decade and

283
00:10:15,440 --> 00:10:17,760
it was also used for the best syndrome

284
00:10:17,760 --> 00:10:21,040
decoding algorithms called mmt and bgmm

285
00:10:21,040 --> 00:10:23,760
also like 10 years ago

286
00:10:23,760 --> 00:10:25,920
now you might wonder why nobody applied

287
00:10:25,920 --> 00:10:28,640
this cool technique to lwe and the

288
00:10:28,640 --> 00:10:31,360
reason might be that the error in lwe

289
00:10:31,360 --> 00:10:33,600
makes your problem an approximate subset

290
00:10:33,600 --> 00:10:35,600
sum problem and it seems that the

291
00:10:35,600 --> 00:10:38,399
representation techniques exacts up to

292
00:10:38,399 --> 00:10:40,320
some problems

293
00:10:40,320 --> 00:10:42,560
so our solution our workaround to make

294
00:10:42,560 --> 00:10:44,720
the representation technique work also

295
00:10:44,720 --> 00:10:48,160
for lw is we should we guess a very

296
00:10:48,160 --> 00:10:51,040
small portion of our error e namely we

297
00:10:51,040 --> 00:10:53,680
guess r which is o of n over log n

298
00:10:53,680 --> 00:10:56,000
coordinates and that surfaces already to

299
00:10:56,000 --> 00:10:58,480
achieve our main result so

300
00:10:58,480 --> 00:11:00,720
our main result is our algorithm solves

301
00:11:00,720 --> 00:11:04,240
ternary lwe in time and memory which is

302
00:11:04,240 --> 00:11:06,880
3 to the r which is for guessing

303
00:11:06,880 --> 00:11:09,120
times roughly the fourth root of the

304
00:11:09,120 --> 00:11:10,560
search space

305
00:11:10,560 --> 00:11:12,800
and since 3 to the r is slightly sub

306
00:11:12,800 --> 00:11:16,240
sub-exponential by our choice of r and

307
00:11:16,240 --> 00:11:18,959
the search space is exponential in n we

308
00:11:18,959 --> 00:11:21,519
can put this guessing into a small o of

309
00:11:21,519 --> 00:11:22,320
one

310
00:11:22,320 --> 00:11:23,760
term here

311
00:11:23,760 --> 00:11:25,680
so you see asymptotically it doesn't

312
00:11:25,680 --> 00:11:27,760
matter but in practice of course it does

313
00:11:27,760 --> 00:11:29,600
and here you see some practical results

314
00:11:29,600 --> 00:11:31,120
on the next slide

315
00:11:31,120 --> 00:11:33,760
so i have some entry results so there's

316
00:11:33,760 --> 00:11:36,640
the ieee standard from 2008 and there's

317
00:11:36,640 --> 00:11:39,200
the current this proposal from from this

318
00:11:39,200 --> 00:11:40,880
year

319
00:11:40,880 --> 00:11:43,279
and they differ by actually the relative

320
00:11:43,279 --> 00:11:45,120
weight that is chosen to use so you see

321
00:11:45,120 --> 00:11:47,600
i triple e is a kind of smallish weight

322
00:11:47,600 --> 00:11:50,160
whereas the control block is kind of a

323
00:11:50,160 --> 00:11:52,320
large weight and then here you see the

324
00:11:52,320 --> 00:11:54,160
search space in this column and here's

325
00:11:54,160 --> 00:11:56,720
our result you so you see in practice we

326
00:11:56,720 --> 00:11:58,880
do not really get the fourth route but

327
00:11:58,880 --> 00:12:00,800
more the third route maybe and this is

328
00:12:00,800 --> 00:12:03,440
due to guessing but you should also see

329
00:12:03,440 --> 00:12:05,600
that in the small weight setting we are

330
00:12:05,600 --> 00:12:07,279
actually improving on the current

331
00:12:07,279 --> 00:12:09,920
letters estimates whereas in the large

332
00:12:09,920 --> 00:12:12,000
weight setting we are a tad bit away

333
00:12:12,000 --> 00:12:14,399
from the current last letters estimates

334
00:12:14,399 --> 00:12:16,720
so it seems that the end true team and

335
00:12:16,720 --> 00:12:18,639
among them

336
00:12:18,639 --> 00:12:20,399
the chair of the session made a smart

337
00:12:20,399 --> 00:12:22,720
decision in choosing large weights and

338
00:12:22,720 --> 00:12:24,480
therefore also large search spaces yeah

339
00:12:24,480 --> 00:12:26,800
to guard against this attack or

340
00:12:26,800 --> 00:12:28,720
also it was not there when

341
00:12:28,720 --> 00:12:31,040
uh the proposal was made

342
00:12:31,040 --> 00:12:33,200
okay so in order to wrap up as a

343
00:12:33,200 --> 00:12:34,639
conclusion we improved the best

344
00:12:34,639 --> 00:12:36,639
combinatorial attack from the square

345
00:12:36,639 --> 00:12:38,480
root of the search space to almost the

346
00:12:38,480 --> 00:12:39,760
first route

347
00:12:39,760 --> 00:12:41,760
and this improves upon lattice estimates

348
00:12:41,760 --> 00:12:43,600
in the small mate regime

349
00:12:43,600 --> 00:12:44,959
and there are more generalizations in

350
00:12:44,959 --> 00:12:47,120
the paper so for instance there are time

351
00:12:47,120 --> 00:12:49,200
memory trade-offs and there's a bliss

352
00:12:49,200 --> 00:12:52,399
example with also non-ternary keys which

353
00:12:52,399 --> 00:12:54,880
achieves like the fifth suit so this is

354
00:12:54,880 --> 00:12:57,760
kind of promising we generalized

355
00:12:57,760 --> 00:12:58,720
but

356
00:12:58,720 --> 00:13:00,880
in general it's not so clear how to

357
00:13:00,880 --> 00:13:02,800
generalize the analysis it gets very

358
00:13:02,800 --> 00:13:04,720
complicated for arbitrary maximum so

359
00:13:04,720 --> 00:13:06,959
this is no problem

360
00:13:06,959 --> 00:13:09,360
and then as another problem

361
00:13:09,360 --> 00:13:11,200
uh can we close this gap between

362
00:13:11,200 --> 00:13:13,440
asymptotics and practical parameters so

363
00:13:13,440 --> 00:13:15,760
that is can we get rid of the small r1

364
00:13:15,760 --> 00:13:17,120
for guessing

365
00:13:17,120 --> 00:13:19,360
and now that we have two algorithms is

366
00:13:19,360 --> 00:13:21,360
there a good hybrid between our new

367
00:13:21,360 --> 00:13:23,040
combinatorial

368
00:13:23,040 --> 00:13:25,680
algorithm and lettuce reduction

369
00:13:25,680 --> 00:13:27,839
and as that's it thank you for your

370
00:13:27,839 --> 00:13:30,079
attention

371
00:13:30,079 --> 00:13:32,639
okay cool stuff thank you alex

372
00:13:32,639 --> 00:13:34,720
next up we have joe roll telling us

373
00:13:34,720 --> 00:13:36,399
about lattice reduction with an

374
00:13:36,399 --> 00:13:39,839
approximate enumeration article

375
00:13:45,920 --> 00:13:48,639
hang on give me just one second

376
00:13:48,639 --> 00:13:50,000
uh

377
00:13:50,000 --> 00:13:52,800
can you see this

378
00:13:54,079 --> 00:13:57,279
can you see it okay

379
00:13:57,600 --> 00:13:59,440
zoom window

380
00:13:59,440 --> 00:14:03,720
ah that's not good give me a second

381
00:14:05,680 --> 00:14:07,920
okay how about now it looks good yeah

382
00:14:07,920 --> 00:14:09,839
just full screen there okay

383
00:14:09,839 --> 00:14:12,800
okay excellent okay thank you so hi

384
00:14:12,800 --> 00:14:14,639
everyone and welcome this is lattice

385
00:14:14,639 --> 00:14:16,639
reduction with approximate enumeration

386
00:14:16,639 --> 00:14:18,480
oracles and this is joint work with

387
00:14:18,480 --> 00:14:21,680
martin albrecht shubai and jamili

388
00:14:21,680 --> 00:14:23,839
so i'd just like to begin with sort of a

389
00:14:23,839 --> 00:14:25,920
high level why you should care and so

390
00:14:25,920 --> 00:14:28,160
we're a crypto conference and so we care

391
00:14:28,160 --> 00:14:30,639
about the difficulty of

392
00:14:30,639 --> 00:14:32,560
breaking cryptosystems and when you're

393
00:14:32,560 --> 00:14:34,880
thinking about n-true or lwe-based

394
00:14:34,880 --> 00:14:37,440
cryptosystems what you really care about

395
00:14:37,440 --> 00:14:39,600
is the difficulty of solving the

396
00:14:39,600 --> 00:14:41,680
shortest vector problem and how this

397
00:14:41,680 --> 00:14:43,600
varies depending on the computational

398
00:14:43,600 --> 00:14:46,000
model that you're considering

399
00:14:46,000 --> 00:14:48,639
if we consider the polynomial regime

400
00:14:48,639 --> 00:14:50,000
then the algorithm that you will care

401
00:14:50,000 --> 00:14:52,480
about is enumeration and enumeration is

402
00:14:52,480 --> 00:14:54,480
an algorithm that walks through

403
00:14:54,480 --> 00:14:56,639
a super exponentially large tree

404
00:14:56,639 --> 00:14:59,519
and produces the shortest vector for you

405
00:14:59,519 --> 00:15:00,959
now because this tree is super

406
00:15:00,959 --> 00:15:02,720
exponentially large

407
00:15:02,720 --> 00:15:04,959
typically you will either embed it

408
00:15:04,959 --> 00:15:07,680
inside bkz so that you can reduce the

409
00:15:07,680 --> 00:15:09,519
size of the lattice you're operating on

410
00:15:09,519 --> 00:15:12,399
any given time or you will cut the tree

411
00:15:12,399 --> 00:15:14,480
so that paths that are unlikely to lead

412
00:15:14,480 --> 00:15:17,279
to short vectors are sort of discarded

413
00:15:17,279 --> 00:15:19,360
and this is referred to as pruning

414
00:15:19,360 --> 00:15:21,519
so i'm sure you've all seen this diagram

415
00:15:21,519 --> 00:15:23,360
a million times before but just as a

416
00:15:23,360 --> 00:15:25,680
recap on the left hand side here you

417
00:15:25,680 --> 00:15:28,959
have a 2d lattice and on the right hand

418
00:15:28,959 --> 00:15:31,680
side you have exactly the same lattice

419
00:15:31,680 --> 00:15:34,079
but the shortest vector is

420
00:15:34,079 --> 00:15:35,839
sort of marked

421
00:15:35,839 --> 00:15:37,920
now in two dimensions this problem is

422
00:15:37,920 --> 00:15:40,079
known to be quite easy but if you could

423
00:15:40,079 --> 00:15:41,920
imagine turning this into say a

424
00:15:41,920 --> 00:15:44,720
dimension 1000 problem it becomes

425
00:15:44,720 --> 00:15:46,880
significantly harder and so it's quite

426
00:15:46,880 --> 00:15:49,040
natural to think about how you might try

427
00:15:49,040 --> 00:15:52,480
and make this problem easier to solve

428
00:15:52,480 --> 00:15:55,040
quite naturally it's you can ask what

429
00:15:55,040 --> 00:15:56,240
would happen

430
00:15:56,240 --> 00:15:58,399
if we would accept a vector that is

431
00:15:58,399 --> 00:16:00,959
longer than optimal by say a factor at

432
00:16:00,959 --> 00:16:03,279
most alpha where alpha is some constant

433
00:16:03,279 --> 00:16:05,440
factor greater than one

434
00:16:05,440 --> 00:16:07,600
so intuitively you might think that this

435
00:16:07,600 --> 00:16:10,399
is easier but it's not necessarily clear

436
00:16:10,399 --> 00:16:12,639
for this by how much easier it is in

437
00:16:12,639 --> 00:16:14,079
practice

438
00:16:14,079 --> 00:16:16,000
and so thankfully this has already been

439
00:16:16,000 --> 00:16:17,279
studied before

440
00:16:17,279 --> 00:16:19,360
so liam and nguyen in this paper from

441
00:16:19,360 --> 00:16:20,480
last year

442
00:16:20,480 --> 00:16:22,160
showed that if you choose some pruning

443
00:16:22,160 --> 00:16:24,000
parameter rho

444
00:16:24,000 --> 00:16:25,759
and use extreme pruning which is an

445
00:16:25,759 --> 00:16:27,600
aggressive form of pruning

446
00:16:27,600 --> 00:16:29,920
then this relaxation technique

447
00:16:29,920 --> 00:16:33,199
accelerates bk z by a speed up of around

448
00:16:33,199 --> 00:16:36,079
four alpha squared times one minus rho

449
00:16:36,079 --> 00:16:38,160
all to the power of k over 4 where k is

450
00:16:38,160 --> 00:16:40,160
your block size

451
00:16:40,160 --> 00:16:41,839
but the problem with this is that it

452
00:16:41,839 --> 00:16:43,920
makes the quality of your output basis

453
00:16:43,920 --> 00:16:46,000
worse because at each step you're

454
00:16:46,000 --> 00:16:48,240
accepting a vector that is longer than

455
00:16:48,240 --> 00:16:51,040
what you would get in an ideal situation

456
00:16:51,040 --> 00:16:53,120
and so what we do in this work is we say

457
00:16:53,120 --> 00:16:56,240
well as opposed to doing this relaxation

458
00:16:56,240 --> 00:16:58,399
over a block size of width k

459
00:16:58,399 --> 00:17:00,880
what happens if we increase it to say k

460
00:17:00,880 --> 00:17:03,440
alpha which is the smallest block size

461
00:17:03,440 --> 00:17:05,119
such that our

462
00:17:05,119 --> 00:17:07,520
quality metric called the hermit factor

463
00:17:07,520 --> 00:17:08,959
does not increase

464
00:17:08,959 --> 00:17:11,679
and we show that even when increasing

465
00:17:11,679 --> 00:17:13,280
this block size

466
00:17:13,280 --> 00:17:15,599
the speed up from relaxation is

467
00:17:15,599 --> 00:17:17,599
exponentially faster

468
00:17:17,599 --> 00:17:20,319
than doing enumeration over the original

469
00:17:20,319 --> 00:17:22,959
block size so even though we have to

470
00:17:22,959 --> 00:17:25,359
increase the size of the block we still

471
00:17:25,359 --> 00:17:27,599
get a speed up from this relaxation

472
00:17:27,599 --> 00:17:29,679
while still achieving the same repair

473
00:17:29,679 --> 00:17:30,640
factor

474
00:17:30,640 --> 00:17:33,200
and so just before i wrap up i want to

475
00:17:33,200 --> 00:17:35,200
show you this graph that compares sort

476
00:17:35,200 --> 00:17:37,120
of the different approaches for doing

477
00:17:37,120 --> 00:17:37,840
this

478
00:17:37,840 --> 00:17:41,360
so this black line here is the

479
00:17:41,360 --> 00:17:44,400
running time given by fpll which is the

480
00:17:44,400 --> 00:17:45,919
sort of state of the art at the moment

481
00:17:45,919 --> 00:17:47,600
for an implementation

482
00:17:47,600 --> 00:17:49,840
beneath this in the blue

483
00:17:49,840 --> 00:17:52,080
dotted line is the work from crypto last

484
00:17:52,080 --> 00:17:54,640
year and then the green line there shows

485
00:17:54,640 --> 00:17:57,039
the result for this work so you can see

486
00:17:57,039 --> 00:17:59,440
that although we only improve why i say

487
00:17:59,440 --> 00:18:02,080
only improve the lower order term in

488
00:18:02,080 --> 00:18:05,200
this we are able to move across over for

489
00:18:05,200 --> 00:18:08,240
two to the 256 operations to around

490
00:18:08,240 --> 00:18:10,000
about rank 500

491
00:18:10,000 --> 00:18:12,480
which is you can see higher than for the

492
00:18:12,480 --> 00:18:15,360
blue line which is around about 450

493
00:18:15,360 --> 00:18:17,600
and higher than the black line which is

494
00:18:17,600 --> 00:18:19,360
a roundabout with 400.

495
00:18:19,360 --> 00:18:21,760
so in other words this work presents the

496
00:18:21,760 --> 00:18:24,640
fastest way to do enumeration inside bk

497
00:18:24,640 --> 00:18:25,840
set

498
00:18:25,840 --> 00:18:29,559
and that's it thank you

499
00:18:30,160 --> 00:18:32,400
okay thank you joe

500
00:18:32,400 --> 00:18:35,200
next up we have thomas espoto presenting

501
00:18:35,200 --> 00:18:37,360
towards faster polynomial time lattice

502
00:18:37,360 --> 00:18:40,360
reduction

503
00:18:48,720 --> 00:18:50,559
can you see this

504
00:18:50,559 --> 00:18:51,760
yeah it looks good

505
00:18:51,760 --> 00:18:53,280
okay thanks

506
00:18:53,280 --> 00:18:55,200
okay thanks for the introduction uh this

507
00:18:55,200 --> 00:18:57,120
is john robles uh politikashner and

508
00:18:57,120 --> 00:19:00,959
karana from university

509
00:19:01,679 --> 00:19:02,640
okay

510
00:19:02,640 --> 00:19:05,200
so in general finding a short vector in

511
00:19:05,200 --> 00:19:06,559
the lattice

512
00:19:06,559 --> 00:19:08,160
is a hard problem

513
00:19:08,160 --> 00:19:10,880
however in 82 uh lens transfer and lovat

514
00:19:10,880 --> 00:19:12,640
uh show that there exists some point

515
00:19:12,640 --> 00:19:14,799
number term algorithm which allows you

516
00:19:14,799 --> 00:19:16,960
to find some uh

517
00:19:16,960 --> 00:19:18,640
mildly short vector that is to say which

518
00:19:18,640 --> 00:19:20,480
is two n times longer than the shortest

519
00:19:20,480 --> 00:19:21,919
vector of the lattice

520
00:19:21,919 --> 00:19:23,679
you might say okay it's pretty big but

521
00:19:23,679 --> 00:19:25,760
actually it's still useful because uh

522
00:19:25,760 --> 00:19:27,760
with this algorithm you can solve uh

523
00:19:27,760 --> 00:19:29,440
platforms number of problems such as

524
00:19:29,440 --> 00:19:31,440
differential approximation finding

525
00:19:31,440 --> 00:19:33,919
minimal polynomials logic members uh

526
00:19:33,919 --> 00:19:35,679
doing factorization of a rational and of

527
00:19:35,679 --> 00:19:37,679
course doing cryptanalysis and this is

528
00:19:37,679 --> 00:19:39,120
maybe uh

529
00:19:39,120 --> 00:19:41,520
why we are here today

530
00:19:41,520 --> 00:19:44,480
um quantitatively speaking uh the naive

531
00:19:44,480 --> 00:19:47,200
analysis of the algorithm reveals that

532
00:19:47,200 --> 00:19:49,520
the dependency is 60 in the dimension of

533
00:19:49,520 --> 00:19:52,400
the lattice and is cubic in the bit size

534
00:19:52,400 --> 00:19:53,840
you're using

535
00:19:53,840 --> 00:19:57,679
however in 2009 angry and instead showed

536
00:19:57,679 --> 00:19:58,640
that

537
00:19:58,640 --> 00:20:00,000
by using carefully floating point

538
00:20:00,000 --> 00:20:03,200
arithmetic you can get some dependency

539
00:20:03,200 --> 00:20:06,159
in the bit size which is quadratic and

540
00:20:06,159 --> 00:20:09,039
uh remains a 60k in the uh dimension and

541
00:20:09,039 --> 00:20:11,200
more recently in 2016 nominal studies

542
00:20:11,200 --> 00:20:13,200
showed that with a recursive strategy on

543
00:20:13,200 --> 00:20:15,200
the rank you can achieve

544
00:20:15,200 --> 00:20:17,360
a quasi-out-time complexity in the bit

545
00:20:17,360 --> 00:20:18,840
size and

546
00:20:18,840 --> 00:20:20,000
quasi uh

547
00:20:20,000 --> 00:20:22,240
and uh governance win fought some small

548
00:20:22,240 --> 00:20:25,039
epsilon in the uh dimension

549
00:20:25,039 --> 00:20:26,559
however the constants which are hidden

550
00:20:26,559 --> 00:20:28,559
in this biggo are pretty big and this

551
00:20:28,559 --> 00:20:30,000
algorithm have never been properly

552
00:20:30,000 --> 00:20:31,440
implemented

553
00:20:31,440 --> 00:20:34,080
so a question is now how we can improve

554
00:20:34,080 --> 00:20:36,799
the dependency in the dimension

555
00:20:36,799 --> 00:20:39,520
and uh if we can also get some practical

556
00:20:39,520 --> 00:20:42,559
results from this

557
00:20:42,559 --> 00:20:43,840
so um

558
00:20:43,840 --> 00:20:46,159
just to recall the algorithm epitomize a

559
00:20:46,159 --> 00:20:47,039
very

560
00:20:47,039 --> 00:20:49,039
neat idea which is that reducing an

561
00:20:49,039 --> 00:20:51,120
arbitrary rank lattice can be done by

562
00:20:51,120 --> 00:20:54,080
using sub calls to run to reduction for

563
00:20:54,080 --> 00:20:56,480
instance using the gauss algorithm and

564
00:20:56,480 --> 00:20:58,320
do some progress all along the lattice

565
00:20:58,320 --> 00:21:03,399
until no improvement can be done

566
00:21:07,600 --> 00:21:09,120
it replaces this iterative sequence of

567
00:21:09,120 --> 00:21:11,520
reduction

568
00:21:12,559 --> 00:21:14,240
so just to

569
00:21:14,240 --> 00:21:16,799
draw things up if i have my bases here

570
00:21:16,799 --> 00:21:20,080
what i'm going to do uh is to do a

571
00:21:20,080 --> 00:21:21,039
regular

572
00:21:21,039 --> 00:21:23,200
reduction in rank 2 on non-overlapping

573
00:21:23,200 --> 00:21:25,120
blocks for instance up here up here here

574
00:21:25,120 --> 00:21:26,720
and i can do them all in parallel

575
00:21:26,720 --> 00:21:28,400
because they're not overlapping

576
00:21:28,400 --> 00:21:30,559
but then if i want to mix uh what

577
00:21:30,559 --> 00:21:33,120
happened in my vectors i need to

578
00:21:33,120 --> 00:21:35,200
shift slightly a bit the blocks and do

579
00:21:35,200 --> 00:21:36,559
reduction

580
00:21:36,559 --> 00:21:38,799
over uh all the shifted blocks by one

581
00:21:38,799 --> 00:21:41,039
half okay and then you do that over and

582
00:21:41,039 --> 00:21:43,039
over and over until nothing happens and

583
00:21:43,039 --> 00:21:46,240
your bases will be reduced at the end

584
00:21:46,240 --> 00:21:48,400
so uh you can remark that all of these

585
00:21:48,400 --> 00:21:50,240
operations are actually quite local so

586
00:21:50,240 --> 00:21:52,320
it's possibly it's possible to do some

587
00:21:52,320 --> 00:21:54,480
recursion on blocks and by that i mean

588
00:21:54,480 --> 00:21:56,240
that now you're not doing small blocks

589
00:21:56,240 --> 00:21:58,559
of size two but using big blocks like

590
00:21:58,559 --> 00:22:01,039
non-overlapping over over here and then

591
00:22:01,039 --> 00:22:02,880
you do require sizes block to reduce

592
00:22:02,880 --> 00:22:05,280
them and once you're fully done what you

593
00:22:05,280 --> 00:22:07,120
will do is do this shifting again by

594
00:22:07,120 --> 00:22:10,240
half a block to mix everything up and

595
00:22:10,240 --> 00:22:13,760
you do that by a breakthrough regular

596
00:22:13,760 --> 00:22:16,320
question again so once again you iterate

597
00:22:16,320 --> 00:22:18,240
until nothing can happen

598
00:22:18,240 --> 00:22:20,640
and this design which exploits locality

599
00:22:20,640 --> 00:22:22,640
can be pushed to its limits by designing

600
00:22:22,640 --> 00:22:24,320
the full reduction algorithm using only

601
00:22:24,320 --> 00:22:26,000
block matrix operations and in

602
00:22:26,000 --> 00:22:27,679
particular we will replace the so-called

603
00:22:27,679 --> 00:22:30,559
branch meter organization by uh the uh

604
00:22:30,559 --> 00:22:32,080
block version which is blockchain

605
00:22:32,080 --> 00:22:34,000
algorithm and the so-called size

606
00:22:34,000 --> 00:22:36,320
reduction algorithm by as the block says

607
00:22:36,320 --> 00:22:38,880
reduction to be a bit more precise our

608
00:22:38,880 --> 00:22:40,960
reduction procedure works as follows so

609
00:22:40,960 --> 00:22:43,039
our base case would be dimension two as

610
00:22:43,039 --> 00:22:44,480
previously and we use the house

611
00:22:44,480 --> 00:22:46,080
algorithm or schneger algorithm if you

612
00:22:46,080 --> 00:22:48,320
want to be fast and then for a certain

613
00:22:48,320 --> 00:22:51,840
number of iterations you will start by

614
00:22:51,840 --> 00:22:54,080
computing the qr decomposition so it

615
00:22:54,080 --> 00:22:55,280
means that you're working modular

616
00:22:55,280 --> 00:22:57,440
rotation of the lattice so once one

617
00:22:57,440 --> 00:23:00,000
rotation is fixed you say send reduce it

618
00:23:00,000 --> 00:23:01,919
which means that you will control the

619
00:23:01,919 --> 00:23:03,520
condition number of the matrix and avoid

620
00:23:03,520 --> 00:23:05,120
an explosion of the size of the

621
00:23:05,120 --> 00:23:08,640
coefficient and then you do uh this uh

622
00:23:08,640 --> 00:23:11,039
iteration uh on the blocks

623
00:23:11,039 --> 00:23:13,200
so for every blocks you will recursively

624
00:23:13,200 --> 00:23:15,120
reduce it if it's not already

625
00:23:15,120 --> 00:23:17,679
pre-reduced and by that you can check by

626
00:23:17,679 --> 00:23:20,159
some volumic arguments that first half

627
00:23:20,159 --> 00:23:21,520
of the block is not too large compared

628
00:23:21,520 --> 00:23:23,280
to the second one and then you iterate

629
00:23:23,280 --> 00:23:26,240
that until the basis is reduced

630
00:23:26,240 --> 00:23:28,320
so by doing so

631
00:23:28,320 --> 00:23:31,840
you can achieve to

632
00:23:31,840 --> 00:23:34,400
reduce your basis into ll manner so you

633
00:23:34,400 --> 00:23:36,159
can do even the slightly more reduced

634
00:23:36,159 --> 00:23:38,799
and elevated spaces in times which is

635
00:23:38,799 --> 00:23:40,960
essentially in the time of matrix

636
00:23:40,960 --> 00:23:43,039
multiplication so the omega times the

637
00:23:43,039 --> 00:23:44,640
condition number where omega is a

638
00:23:44,640 --> 00:23:46,880
constant of matrix multiplication

639
00:23:46,880 --> 00:23:48,640
so i point out here that these results

640
00:23:48,640 --> 00:23:49,840
are fully heuristic because you need

641
00:23:49,840 --> 00:23:51,520
some very uh stronger sticky counter

642
00:23:51,520 --> 00:23:52,720
precision needed to handle the

643
00:23:52,720 --> 00:23:54,720
computation and we did not manage to

644
00:23:54,720 --> 00:23:56,640
make that disappear

645
00:23:56,640 --> 00:23:58,480
so practically speaking if we compare

646
00:23:58,480 --> 00:24:00,000
with the state-of-the-art implementation

647
00:24:00,000 --> 00:24:01,919
fpll

648
00:24:01,919 --> 00:24:02,640
for

649
00:24:02,640 --> 00:24:05,600
lattices in a dimension for instance

650
00:24:05,600 --> 00:24:06,679
three

651
00:24:06,679 --> 00:24:11,039
34 344 for knapsack types we achieve

652
00:24:11,039 --> 00:24:13,600
results which are around 35 times faster

653
00:24:13,600 --> 00:24:15,360
than the state-of-the-art and for entry

654
00:24:15,360 --> 00:24:18,159
type lattices in dimension up to 512 we

655
00:24:18,159 --> 00:24:19,200
achieve

656
00:24:19,200 --> 00:24:22,640
some reduction which is up to 40 times

657
00:24:22,640 --> 00:24:24,640
45 times faster than the state of the

658
00:24:24,640 --> 00:24:26,960
art

659
00:24:29,279 --> 00:24:33,159
fingering chain we were able

660
00:24:35,600 --> 00:24:37,279
you're cutting out a bit

661
00:24:37,279 --> 00:24:39,679
up to uh

662
00:24:39,679 --> 00:24:41,120
you're cutting out that you may want to

663
00:24:41,120 --> 00:24:44,080
turn off your camera i can do that sure

664
00:24:44,080 --> 00:24:47,080
uh

665
00:24:48,799 --> 00:24:50,240
is it better

666
00:24:50,240 --> 00:24:52,159
i don't know if it's better uh we're

667
00:24:52,159 --> 00:24:54,720
able to reduce a lattice in dimension up

668
00:24:54,720 --> 00:24:59,679
to 5000 in a bit more than one day

669
00:24:59,679 --> 00:25:02,080
so to conclude with uh we presented some

670
00:25:02,080 --> 00:25:04,240
a fast ll variant which is designed

671
00:25:04,240 --> 00:25:05,679
using recursion and block matrix

672
00:25:05,679 --> 00:25:08,240
operation

673
00:25:12,880 --> 00:25:15,039
release innovation our implementation

674
00:25:15,039 --> 00:25:17,039
which is uh currently as the fastest

675
00:25:17,039 --> 00:25:19,760
available and last but not least proving

676
00:25:19,760 --> 00:25:21,440
this uh contractual results on the

677
00:25:21,440 --> 00:25:22,960
complex it will be a very interesting

678
00:25:22,960 --> 00:25:25,679
challenge but it seems very hard and we

679
00:25:25,679 --> 00:25:27,520
are not able to manage to do so

680
00:25:27,520 --> 00:25:28,480
currently

681
00:25:28,480 --> 00:25:30,880
thank you for your attention

682
00:25:30,880 --> 00:25:32,880
okay thank you thomas

683
00:25:32,880 --> 00:25:34,960
uh next up we have tys larhoven

684
00:25:34,960 --> 00:25:36,559
presenting lower bounds on lattice

685
00:25:36,559 --> 00:25:40,480
sieving and information set decoding

686
00:25:40,480 --> 00:25:41,520
um

687
00:25:41,520 --> 00:25:42,880
i can see yeah

688
00:25:42,880 --> 00:25:45,520
yeah okay looks good so this is yeah so

689
00:25:45,520 --> 00:25:47,919
this is joint work with elena

690
00:25:47,919 --> 00:25:49,760
um yeah so i don't really need to

691
00:25:49,760 --> 00:25:51,760
motivate why we need to squeeze to push

692
00:25:51,760 --> 00:25:54,000
quantum crypto but like letters based on

693
00:25:54,000 --> 00:25:55,679
code based cryptography i mean they are

694
00:25:55,679 --> 00:25:57,520
kind of the main candidates for

695
00:25:57,520 --> 00:25:59,919
replacing classical cryptography

696
00:25:59,919 --> 00:26:01,279
like most of the

697
00:26:01,279 --> 00:26:02,880
the finalists in the nist competition

698
00:26:02,880 --> 00:26:04,960
they are based on lessons and codes so

699
00:26:04,960 --> 00:26:07,200
we really need to study these

700
00:26:07,200 --> 00:26:08,720
the highness of these these underlying

701
00:26:08,720 --> 00:26:10,559
problems like response and coding

702
00:26:10,559 --> 00:26:12,080
problems

703
00:26:12,080 --> 00:26:14,080
interesting algorithms of course

704
00:26:14,080 --> 00:26:15,760
and ideally we also want to choose

705
00:26:15,760 --> 00:26:17,120
schemes which have like long-term

706
00:26:17,120 --> 00:26:18,880
security like even in

707
00:26:18,880 --> 00:26:20,400
50 years they are still secure so we

708
00:26:20,400 --> 00:26:22,480
want to have conservative bounce on what

709
00:26:22,480 --> 00:26:24,640
attackers can do and what are the best

710
00:26:24,640 --> 00:26:26,640
algorithms and so we need to

711
00:26:26,640 --> 00:26:29,039
uh like we need to prepare for better

712
00:26:29,039 --> 00:26:30,640
hardware but also for

713
00:26:30,640 --> 00:26:32,480
improvements in caps analysis like

714
00:26:32,480 --> 00:26:33,840
people might come up with faster

715
00:26:33,840 --> 00:26:35,600
algorithms which really

716
00:26:35,600 --> 00:26:37,440
threatens the security so

717
00:26:37,440 --> 00:26:39,039
ideally we would like to have like

718
00:26:39,039 --> 00:26:40,559
conservative bounce on what an attacker

719
00:26:40,559 --> 00:26:43,520
can do so maybe like some kind of like

720
00:26:43,520 --> 00:26:45,520
kind of lower bound on what

721
00:26:45,520 --> 00:26:47,360
because of any algorithm to break a

722
00:26:47,360 --> 00:26:48,559
scheme would

723
00:26:48,559 --> 00:26:50,480
have to cost

724
00:26:50,480 --> 00:26:52,960
so okay so we would like to study the

725
00:26:52,960 --> 00:26:54,400
the concrete the hardness of this

726
00:26:54,400 --> 00:26:56,000
problem so we studied the alkalines for

727
00:26:56,000 --> 00:26:58,159
this so like in lettuces we have lettuce

728
00:26:58,159 --> 00:27:00,000
sieving which is kind of the

729
00:27:00,000 --> 00:27:01,520
state of the art right now in

730
00:27:01,520 --> 00:27:03,200
combination with base reduction i mean

731
00:27:03,200 --> 00:27:04,640
there's also enumeration in one of the

732
00:27:04,640 --> 00:27:06,559
previous talks here but like there's a

733
00:27:06,559 --> 00:27:08,240
savings asymptotically the best and also

734
00:27:08,240 --> 00:27:10,720
in practice is one of the best right now

735
00:27:10,720 --> 00:27:13,200
um information decoding algorithms are

736
00:27:13,200 --> 00:27:14,720
on the code base side are one of the

737
00:27:14,720 --> 00:27:16,720
most important ones

738
00:27:16,720 --> 00:27:18,480
and both of these approaches i mean

739
00:27:18,480 --> 00:27:19,760
they're kind of different so in

740
00:27:19,760 --> 00:27:21,120
different problems but they kind of

741
00:27:21,120 --> 00:27:22,399
follow the same approach you're first

742
00:27:22,399 --> 00:27:24,480
sampling a large database of kind of

743
00:27:24,480 --> 00:27:26,720
long vectors under some metric when you

744
00:27:26,720 --> 00:27:29,039
combine these vectors to find shorter

745
00:27:29,039 --> 00:27:31,600
vectors and some way of combining them

746
00:27:31,600 --> 00:27:33,679
then you hope that if you repeat this a

747
00:27:33,679 --> 00:27:35,679
number of times then hopefully you find

748
00:27:35,679 --> 00:27:38,399
some short factors which then solve your

749
00:27:38,399 --> 00:27:41,440
letters problem or your decoding problem

750
00:27:41,440 --> 00:27:43,279
and so one of the key problems in both

751
00:27:43,279 --> 00:27:44,799
of these applications is that you need

752
00:27:44,799 --> 00:27:46,320
to solve

753
00:27:46,320 --> 00:27:48,080
some closest pairs problem in a sense

754
00:27:48,080 --> 00:27:50,559
like you want to find nearby pairs of

755
00:27:50,559 --> 00:27:52,399
factors which you can combine to form

756
00:27:52,399 --> 00:27:54,000
shorter vectors so

757
00:27:54,000 --> 00:27:55,520
and let's say you just want to add them

758
00:27:55,520 --> 00:27:56,880
and then you want to find pairs of

759
00:27:56,880 --> 00:27:58,399
vectors which are

760
00:27:58,399 --> 00:28:00,640
like uh close to one another and that

761
00:28:00,640 --> 00:28:02,240
you can combine them to make shorter

762
00:28:02,240 --> 00:28:03,840
vectors

763
00:28:03,840 --> 00:28:06,159
so naively if you have a large database

764
00:28:06,159 --> 00:28:07,600
and you want to find all pairs which

765
00:28:07,600 --> 00:28:09,679
combine or if there's one of them just

766
00:28:09,679 --> 00:28:11,600
find this one and it takes like

767
00:28:11,600 --> 00:28:13,200
quadratic time in the size of the

768
00:28:13,200 --> 00:28:14,240
database

769
00:28:14,240 --> 00:28:16,240
but there are these smarter approaches

770
00:28:16,240 --> 00:28:17,600
in even that even work in high

771
00:28:17,600 --> 00:28:18,720
dimensions that you encounter in

772
00:28:18,720 --> 00:28:20,960
cryptography like this is hash based

773
00:28:20,960 --> 00:28:22,640
approaches like lookout sensor hashing

774
00:28:22,640 --> 00:28:23,919
you may have heard of it

775
00:28:23,919 --> 00:28:25,440
but there's like a circulating

776
00:28:25,440 --> 00:28:27,440
complexity like circulating in the

777
00:28:27,440 --> 00:28:28,799
side of the database and they're

778
00:28:28,799 --> 00:28:30,559
actually also practical people are using

779
00:28:30,559 --> 00:28:32,399
them

780
00:28:32,399 --> 00:28:34,559
um and also there are currently no

781
00:28:34,559 --> 00:28:37,440
uh matching uh no matching lower bounds

782
00:28:37,440 --> 00:28:38,159
so

783
00:28:38,159 --> 00:28:39,919
like there are these approaches that we

784
00:28:39,919 --> 00:28:41,200
are using but we don't know if they are

785
00:28:41,200 --> 00:28:43,520
optimal there might be better ways to

786
00:28:43,520 --> 00:28:45,440
to do this cross space column and to

787
00:28:45,440 --> 00:28:47,039
actually speed up like letter saving and

788
00:28:47,039 --> 00:28:49,360
information decoding just by improving

789
00:28:49,360 --> 00:28:51,039
like the algorithm that they're using

790
00:28:51,039 --> 00:28:52,720
for this code spare problem and that is

791
00:28:52,720 --> 00:28:53,760
kind of

792
00:28:53,760 --> 00:28:55,600
like yeah unsatisfactory like we want to

793
00:28:55,600 --> 00:28:57,520
know that at least this part you cannot

794
00:28:57,520 --> 00:28:58,880
improve so that we have some kind of

795
00:28:58,880 --> 00:29:00,240
guarantee that

796
00:29:00,240 --> 00:29:01,679
you know organs are not going to be

797
00:29:01,679 --> 00:29:03,360
improved in the future and the security

798
00:29:03,360 --> 00:29:05,440
will be lower

799
00:29:05,440 --> 00:29:07,600
that's why this work comes in so we

800
00:29:07,600 --> 00:29:09,520
in this work we studied like this ghost

801
00:29:09,520 --> 00:29:12,000
spares problem that we that we encounter

802
00:29:12,000 --> 00:29:13,760
in this this setting for both lattices

803
00:29:13,760 --> 00:29:15,600
and for codes because these lower bounds

804
00:29:15,600 --> 00:29:17,440
did not really exist and we

805
00:29:17,440 --> 00:29:18,799
try to find these lower bounds and we

806
00:29:18,799 --> 00:29:20,480
actually got some

807
00:29:20,480 --> 00:29:22,080
and they are conditional like they are

808
00:29:22,080 --> 00:29:24,399
only for this hash based model which

809
00:29:24,399 --> 00:29:26,000
okay that's quite a broad model because

810
00:29:26,000 --> 00:29:28,000
it captures most of the algorithms that

811
00:29:28,000 --> 00:29:29,120
have been

812
00:29:29,120 --> 00:29:31,440
used to date in kept analysis

813
00:29:31,440 --> 00:29:33,120
and for the latter saving setting this

814
00:29:33,120 --> 00:29:35,120
lower bound is actually tight so it

815
00:29:35,120 --> 00:29:36,799
shows that actually the

816
00:29:36,799 --> 00:29:38,559
the best technique that we have right

817
00:29:38,559 --> 00:29:40,399
now like the best upper bound

818
00:29:40,399 --> 00:29:41,919
for this cosplayer problem for letter

819
00:29:41,919 --> 00:29:44,000
saving is actually uh

820
00:29:44,000 --> 00:29:46,320
matches the lower bound so this is that

821
00:29:46,320 --> 00:29:48,559
shows that this work from 2016

822
00:29:48,559 --> 00:29:51,120
with like the 0.292 exponent for the

823
00:29:51,120 --> 00:29:53,360
shortest vector problem is optimal

824
00:29:53,360 --> 00:29:55,120
within this model of course

825
00:29:55,120 --> 00:29:56,640
and some quantum results are also

826
00:29:56,640 --> 00:29:58,000
conditionally optimal assuming that

827
00:29:58,000 --> 00:29:59,440
you're not improving the quantum result

828
00:29:59,440 --> 00:30:02,399
which was actually done also recently

829
00:30:02,399 --> 00:30:04,320
and for the information decoding setting

830
00:30:04,320 --> 00:30:06,159
we get a lower bound which is not tight

831
00:30:06,159 --> 00:30:07,919
but there's like the gap at least

832
00:30:07,919 --> 00:30:09,200
between the lower bound and the upper

833
00:30:09,200 --> 00:30:11,200
bound is not that big so

834
00:30:11,200 --> 00:30:12,559
it does give you some indication that

835
00:30:12,559 --> 00:30:14,159
okay you're not going to improve the

836
00:30:14,159 --> 00:30:16,399
overall kill analysis just by improving

837
00:30:16,399 --> 00:30:17,360
the

838
00:30:17,360 --> 00:30:19,200
closest pair algorithm like you might

839
00:30:19,200 --> 00:30:21,679
increase the security a bit specifically

840
00:30:21,679 --> 00:30:24,320
but not so much so yeah also some kind

841
00:30:24,320 --> 00:30:26,720
of useful result there

842
00:30:26,720 --> 00:30:28,399
but there is still a gap so it might be

843
00:30:28,399 --> 00:30:30,240
that like the current best algorithm

844
00:30:30,240 --> 00:30:33,279
from from alex also from 2015 like the

845
00:30:33,279 --> 00:30:35,520
closest pairs organ that we are using

846
00:30:35,520 --> 00:30:37,760
there might not actually be optimal you

847
00:30:37,760 --> 00:30:39,600
might be able to do better but we don't

848
00:30:39,600 --> 00:30:40,640
know

849
00:30:40,640 --> 00:30:42,960
and so the application is like

850
00:30:42,960 --> 00:30:44,080
like what are you going to take away

851
00:30:44,080 --> 00:30:45,520
from this so

852
00:30:45,520 --> 00:30:47,120
okay you'll get a slightly better

853
00:30:47,120 --> 00:30:49,600
understanding of the hardness of the

854
00:30:49,600 --> 00:30:51,919
of these underlying heart problems

855
00:30:51,919 --> 00:30:53,279
so for kills analysis if you work on

856
00:30:53,279 --> 00:30:55,360
cryptognosis so yeah the main takeaway i

857
00:30:55,360 --> 00:30:56,559
guess is that you should speak for

858
00:30:56,559 --> 00:30:58,480
improvements elsewhere because on this

859
00:30:58,480 --> 00:31:00,000
cross-spares problem you're not really

860
00:31:00,000 --> 00:31:01,360
going to do much better than what we

861
00:31:01,360 --> 00:31:03,360
have now like this especially for letter

862
00:31:03,360 --> 00:31:05,519
saving like we already have the optimal

863
00:31:05,519 --> 00:31:06,880
approach for this

864
00:31:06,880 --> 00:31:08,399
and for the code based system you might

865
00:31:08,399 --> 00:31:10,480
be able to do slightly better but

866
00:31:10,480 --> 00:31:11,919
yeah you're not going to improve too

867
00:31:11,919 --> 00:31:14,000
much there have been some works recently

868
00:31:14,000 --> 00:31:15,600
improving other parts of like data

869
00:31:15,600 --> 00:31:18,399
saving combined with basic seduction or

870
00:31:18,399 --> 00:31:20,799
something like low order terms improving

871
00:31:20,799 --> 00:31:22,640
those

872
00:31:22,640 --> 00:31:24,720
um yeah this also motivates focus on the

873
00:31:24,720 --> 00:31:26,159
best leadership that has already been

874
00:31:26,159 --> 00:31:27,600
done recently like

875
00:31:27,600 --> 00:31:29,600
uh working on like this this algorithm

876
00:31:29,600 --> 00:31:31,360
that uses this this fastest algorithm

877
00:31:31,360 --> 00:31:33,600
for the course program for the data

878
00:31:33,600 --> 00:31:35,600
civic setting and just implementing it

879
00:31:35,600 --> 00:31:36,720
well and

880
00:31:36,720 --> 00:31:39,360
yeah improving the the lower order terms

881
00:31:39,360 --> 00:31:41,120
that make sense now that we know that

882
00:31:41,120 --> 00:31:42,640
this algorithm is actually the best and

883
00:31:42,640 --> 00:31:44,480
you're not going to improve it unless

884
00:31:44,480 --> 00:31:46,960
you find some really new ideas we

885
00:31:46,960 --> 00:31:48,559
currently don't have

886
00:31:48,559 --> 00:31:50,000
and also the parents are selection this

887
00:31:50,000 --> 00:31:51,600
gives you some kind of

888
00:31:51,600 --> 00:31:54,000
i mean it does not prove security that

889
00:31:54,000 --> 00:31:55,360
no one is ever going to break it but it

890
00:31:55,360 --> 00:31:56,720
gives you at least some conditional

891
00:31:56,720 --> 00:31:58,000
security guarantees that if your

892
00:31:58,000 --> 00:31:59,919
attacker is going to attack your scheme

893
00:31:59,919 --> 00:32:01,360
with leather saving and it's going to

894
00:32:01,360 --> 00:32:04,320
use better steering with some

895
00:32:04,320 --> 00:32:06,000
say algorithm for the closed spare spawn

896
00:32:06,000 --> 00:32:09,279
then it's not going to do better

897
00:32:09,519 --> 00:32:10,799
but okay

898
00:32:10,799 --> 00:32:14,720
at least some conditional security

899
00:32:15,370 --> 00:32:18,240
[Music]

900
00:32:18,240 --> 00:32:21,840
so thank you for your attention

901
00:32:22,080 --> 00:32:23,519
great thank you thais

902
00:32:23,519 --> 00:32:25,760
uh okay so questions are now coming in

903
00:32:25,760 --> 00:32:27,919
in the zulu please uh post them there

904
00:32:27,919 --> 00:32:29,840
and preface your question with the

905
00:32:29,840 --> 00:32:31,519
speaker that you want to address

906
00:32:31,519 --> 00:32:32,880
um i

907
00:32:32,880 --> 00:32:34,320
am going to take

908
00:32:34,320 --> 00:32:36,480
the opportunity to ask my own question

909
00:32:36,480 --> 00:32:38,799
first before we dive into this so uh for

910
00:32:38,799 --> 00:32:39,760
sam

911
00:32:39,760 --> 00:32:42,399
uh i am really curious about the uh

912
00:32:42,399 --> 00:32:45,679
process of discovery here for you so uh

913
00:32:45,679 --> 00:32:47,039
you didn't quite get to it in this five

914
00:32:47,039 --> 00:32:48,480
minute talk i understand i encourage

915
00:32:48,480 --> 00:32:50,720
everyone to go and watch the longer talk

916
00:32:50,720 --> 00:32:52,399
uh but it's uh it's quite an elegant

917
00:32:52,399 --> 00:32:55,120
attack and i'm wondering uh did it just

918
00:32:55,120 --> 00:32:57,279
uh kind of pop out to you do you spend a

919
00:32:57,279 --> 00:32:59,120
lot of time manually looking for things

920
00:32:59,120 --> 00:33:01,039
or i mean based on the form of the

921
00:33:01,039 --> 00:33:02,640
attack it almost feels like we could be

922
00:33:02,640 --> 00:33:04,720
doing some kind of computer search to

923
00:33:04,720 --> 00:33:06,559
find things like this so i'm really

924
00:33:06,559 --> 00:33:09,039
curious uh how you found it and maybe if

925
00:33:09,039 --> 00:33:11,360
you have any recommendations for

926
00:33:11,360 --> 00:33:14,240
system designers how they might um

927
00:33:14,240 --> 00:33:18,240
find these kind of in the review process

928
00:33:18,320 --> 00:33:19,919
wow that's that's an excellent question

929
00:33:19,919 --> 00:33:21,279
i'm not sure i have such a great answer

930
00:33:21,279 --> 00:33:24,559
for it so um i i guess i think the part

931
00:33:24,559 --> 00:33:26,480
of the attack that that you maybe think

932
00:33:26,480 --> 00:33:27,279
um

933
00:33:27,279 --> 00:33:28,399
like one thing i didn't get to talk

934
00:33:28,399 --> 00:33:31,679
about was gadgets that we use to uh that

935
00:33:31,679 --> 00:33:33,600
when we stick inside uh circuits that

936
00:33:33,600 --> 00:33:35,600
get evaluated fully homomorphically to

937
00:33:35,600 --> 00:33:38,000
move um information which is sitting in

938
00:33:38,000 --> 00:33:40,159
the message part of the uh of the

939
00:33:40,159 --> 00:33:42,080
ciphertext over into the randomness part

940
00:33:42,080 --> 00:33:44,240
and so we use details of the ski of like

941
00:33:44,240 --> 00:33:46,080
the way the fh scheme is implemented you

942
00:33:46,080 --> 00:33:47,360
know multiplication clever use of

943
00:33:47,360 --> 00:33:49,440
multiplication gates to move information

944
00:33:49,440 --> 00:33:51,279
around and that kind of thing you maybe

945
00:33:51,279 --> 00:33:54,240
could imagine um searching for gadgets

946
00:33:54,240 --> 00:33:57,600
this idea to use um

947
00:33:57,600 --> 00:34:00,240
to use the encrypted key cycle to do a

948
00:34:00,240 --> 00:34:02,399
decryption inside the circuit uh it's

949
00:34:02,399 --> 00:34:03,840
hard for me to say what the process of

950
00:34:03,840 --> 00:34:05,120
discovery was because frankly my

951
00:34:05,120 --> 00:34:07,120
co-author ayush you know it came the

952
00:34:07,120 --> 00:34:08,960
idea seemed to come fully formed so you

953
00:34:08,960 --> 00:34:10,960
have to ask ayush a little bit i guess

954
00:34:10,960 --> 00:34:13,760
um he was super brilliant in inventing

955
00:34:13,760 --> 00:34:15,679
this um

956
00:34:15,679 --> 00:34:18,079
yeah i think i think played a lot though

957
00:34:18,079 --> 00:34:19,679
he played around a lot before before

958
00:34:19,679 --> 00:34:21,199
coming to us with us with this so i

959
00:34:21,199 --> 00:34:22,719
don't i don't i can't speak to exactly

960
00:34:22,719 --> 00:34:24,159
how he came up with it

961
00:34:24,159 --> 00:34:25,280
um

962
00:34:25,280 --> 00:34:26,719
yeah okay

963
00:34:26,719 --> 00:34:28,079
i will say the last thing i'll say is

964
00:34:28,079 --> 00:34:30,399
that uh i i think there is i don't have

965
00:34:30,399 --> 00:34:31,359
an answer to the last part of your

966
00:34:31,359 --> 00:34:34,159
question for what's a systematic thing i

967
00:34:34,159 --> 00:34:35,679
agree we absolutely need one that's one

968
00:34:35,679 --> 00:34:36,800
thing we're thinking about is how to

969
00:34:36,800 --> 00:34:38,399
systematize this kind of attack so that

970
00:34:38,399 --> 00:34:41,440
we can um present you with some

971
00:34:41,440 --> 00:34:42,960
calculation you can do or something you

972
00:34:42,960 --> 00:34:44,320
can check to say okay you're secure

973
00:34:44,320 --> 00:34:47,119
against this kind of attack

974
00:34:47,119 --> 00:34:48,399
cool well i'm looking forward to

975
00:34:48,399 --> 00:34:49,679
whatever you come up with there that's

976
00:34:49,679 --> 00:34:50,879
great

977
00:34:50,879 --> 00:34:51,839
um

978
00:34:51,839 --> 00:34:53,679
let's see moving on we're getting a lot

979
00:34:53,679 --> 00:34:56,239
of questions for thomas um

980
00:34:56,239 --> 00:34:58,160
but i'm still going to use my privilege

981
00:34:58,160 --> 00:35:01,040
here and ask a question for

982
00:35:01,040 --> 00:35:03,200
uh alex actually dan bernstein has just

983
00:35:03,200 --> 00:35:05,200
asked a question for alex um so let me

984
00:35:05,200 --> 00:35:07,920
read that uh dan asks for the three to

985
00:35:07,920 --> 00:35:11,280
the r search on uh ternary uh vectors of

986
00:35:11,280 --> 00:35:13,440
length r or the five with the r search

987
00:35:13,440 --> 00:35:15,760
on ones with plus and minus twos did you

988
00:35:15,760 --> 00:35:17,839
try searching the most common vectors

989
00:35:17,839 --> 00:35:19,359
obviously re-randomizing the positions

990
00:35:19,359 --> 00:35:21,920
if that doesn't work for example kyber

991
00:35:21,920 --> 00:35:22,960
uses the

992
00:35:22,960 --> 00:35:25,599
range minus two to two uh but mostly

993
00:35:25,599 --> 00:35:27,760
minus one to one

994
00:35:27,760 --> 00:35:30,480
uh thoughts on that alex

995
00:35:30,480 --> 00:35:32,640
no this is not used currently and

996
00:35:32,640 --> 00:35:35,040
actually i was oversimplifying in this

997
00:35:35,040 --> 00:35:37,119
five minute talk so you can actually

998
00:35:37,119 --> 00:35:39,440
meet in the middle of the search so what

999
00:35:39,440 --> 00:35:42,480
you do is it's more a three to the r

1000
00:35:42,480 --> 00:35:45,680
over two or 5 to the r over 2.

1001
00:35:45,680 --> 00:35:48,160
but you're right so if you have more

1002
00:35:48,160 --> 00:35:50,240
information on on the error then you can

1003
00:35:50,240 --> 00:35:52,480
use that but it's not done in this work

1004
00:35:52,480 --> 00:35:54,400
so far

1005
00:35:54,400 --> 00:35:56,400
okay and then while we have you unmuted

1006
00:35:56,400 --> 00:35:58,640
i'm really curious about

1007
00:35:58,640 --> 00:36:01,200
extending this to the hybrid attack and

1008
00:36:01,200 --> 00:36:02,880
uh what the barriers are there if you

1009
00:36:02,880 --> 00:36:05,280
have any you know just thoughts on what

1010
00:36:05,280 --> 00:36:06,560
makes it difficult because it doesn't

1011
00:36:06,560 --> 00:36:07,839
seem easy

1012
00:36:07,839 --> 00:36:10,560
yeah that was my initial motivation to

1013
00:36:10,560 --> 00:36:12,320
actually do it and i have to admit that

1014
00:36:12,320 --> 00:36:13,520
i failed

1015
00:36:13,520 --> 00:36:16,880
in in a certain sense it the

1016
00:36:16,880 --> 00:36:19,119
the key equation is used twice yeah it's

1017
00:36:19,119 --> 00:36:21,200
used for the hybrid and it's also used

1018
00:36:21,200 --> 00:36:23,599
for for this so in a certain sense in

1019
00:36:23,599 --> 00:36:26,000
this new attack you really need the full

1020
00:36:26,000 --> 00:36:27,839
equations and you cannot split them

1021
00:36:27,839 --> 00:36:29,760
because you don't know the the target

1022
00:36:29,760 --> 00:36:31,200
vector in between

1023
00:36:31,200 --> 00:36:33,680
yeah so you you kind of splitted them to

1024
00:36:33,680 --> 00:36:35,760
two sides but then you know you have to

1025
00:36:35,760 --> 00:36:38,480
have a target for one items of them so

1026
00:36:38,480 --> 00:36:39,359
i'm

1027
00:36:39,359 --> 00:36:41,599
at the moment i'm kind of skeptical

1028
00:36:41,599 --> 00:36:44,079
whether you can do it for hybrids

1029
00:36:44,079 --> 00:36:46,800
that would maybe really threaten

1030
00:36:46,800 --> 00:36:49,359
and through security but honestly i

1031
00:36:49,359 --> 00:36:51,920
think andrew stay safe because because

1032
00:36:51,920 --> 00:36:53,440
you cannot

1033
00:36:53,440 --> 00:36:55,520
but is it that's one of the open

1034
00:36:55,520 --> 00:36:58,320
questions uh of this paper so i

1035
00:36:58,320 --> 00:37:00,480
mentioned the hybrid between lettuce

1036
00:37:00,480 --> 00:37:02,800
reduction and this one there's maybe a

1037
00:37:02,800 --> 00:37:04,960
hybrid but you are talking about the

1038
00:37:04,960 --> 00:37:07,359
real hybrids this uh how graphic graham

1039
00:37:07,359 --> 00:37:09,040
hybrid

1040
00:37:09,040 --> 00:37:11,839
and for this there are also current

1041
00:37:11,839 --> 00:37:14,400
results that tell you that maybe the

1042
00:37:14,400 --> 00:37:16,320
success probability is heavily

1043
00:37:16,320 --> 00:37:19,280
underestimated so far right and that

1044
00:37:19,280 --> 00:37:21,119
also comes into play because you need

1045
00:37:21,119 --> 00:37:23,040
this homomorphic properties of this

1046
00:37:23,040 --> 00:37:25,920
hybrid so i'm not super positive that

1047
00:37:25,920 --> 00:37:28,320
you can get a lattice hybrid here where

1048
00:37:28,320 --> 00:37:31,040
you enumerate so in a certain sense the

1049
00:37:31,040 --> 00:37:33,040
old lettuce hybrid works because you're

1050
00:37:33,040 --> 00:37:36,320
kind of enumerating all the keys but

1051
00:37:36,320 --> 00:37:38,560
this is not what i do i

1052
00:37:38,560 --> 00:37:41,760
only enroll enumerate those keys which

1053
00:37:41,760 --> 00:37:43,280
uh certif

1054
00:37:43,280 --> 00:37:46,000
satisfy a certain equation and this is

1055
00:37:46,000 --> 00:37:48,240
actually only a very small portion

1056
00:37:48,240 --> 00:37:51,839
and that's where the speed up comes from

1057
00:37:52,240 --> 00:37:54,560
okay

1058
00:37:55,680 --> 00:37:59,200
uh yeah so let's see um question for

1059
00:37:59,200 --> 00:38:01,280
joe in chat there was already some

1060
00:38:01,280 --> 00:38:03,119
discussion about the crossover point

1061
00:38:03,119 --> 00:38:05,440
between sieving and enumeration

1062
00:38:05,440 --> 00:38:06,320
um

1063
00:38:06,320 --> 00:38:09,280
but i'm and people can go read that

1064
00:38:09,280 --> 00:38:11,440
joe's already answered there um i'm

1065
00:38:11,440 --> 00:38:13,599
curious about when uh

1066
00:38:13,599 --> 00:38:16,079
you throw quantum enumeration into the

1067
00:38:16,079 --> 00:38:17,760
mix

1068
00:38:17,760 --> 00:38:19,520
it seems like

1069
00:38:19,520 --> 00:38:21,680
you should get pretty close

1070
00:38:21,680 --> 00:38:23,280
to uh

1071
00:38:23,280 --> 00:38:25,520
to something that works and i just i

1072
00:38:25,520 --> 00:38:27,040
just like to hear from joe what what you

1073
00:38:27,040 --> 00:38:29,119
guys have tried and uh what the barriers

1074
00:38:29,119 --> 00:38:30,560
are

1075
00:38:30,560 --> 00:38:32,800
so naively we looked at

1076
00:38:32,800 --> 00:38:35,119
computing the crossover between sort of

1077
00:38:35,119 --> 00:38:37,280
the quadratic speed up for enumeration

1078
00:38:37,280 --> 00:38:39,359
and for quantum sieving

1079
00:38:39,359 --> 00:38:41,520
but there are some problems so

1080
00:38:41,520 --> 00:38:43,119
quantum sieving is much better

1081
00:38:43,119 --> 00:38:45,359
understood from a circuit complexity

1082
00:38:45,359 --> 00:38:47,680
perspective than enumeration is that's

1083
00:38:47,680 --> 00:38:49,040
one big thing

1084
00:38:49,040 --> 00:38:51,680
the second thing is the

1085
00:38:51,680 --> 00:38:53,839
the quantum enumeration algorithms are

1086
00:38:53,839 --> 00:38:55,599
sort of dependent on the number of bases

1087
00:38:55,599 --> 00:38:58,000
you need to store and pre-process

1088
00:38:58,000 --> 00:39:00,720
it appears that we only need to do one

1089
00:39:00,720 --> 00:39:02,880
enumeration as opposed to a constant

1090
00:39:02,880 --> 00:39:04,400
re-randomization

1091
00:39:04,400 --> 00:39:06,320
but we don't know why that's the case we

1092
00:39:06,320 --> 00:39:08,079
sort of assume it's due to the expensive

1093
00:39:08,079 --> 00:39:09,440
pre-processing

1094
00:39:09,440 --> 00:39:12,400
but we haven't investigated this further

1095
00:39:12,400 --> 00:39:14,560
and even with all of that even assuming

1096
00:39:14,560 --> 00:39:16,480
that everything is good sitting is still

1097
00:39:16,480 --> 00:39:17,359
better

1098
00:39:17,359 --> 00:39:18,079
so

1099
00:39:18,079 --> 00:39:19,920
there is some further work there to be

1100
00:39:19,920 --> 00:39:23,040
done but sieving is still the primary

1101
00:39:23,040 --> 00:39:24,640
the thing to be concerned about when

1102
00:39:24,640 --> 00:39:26,560
setting parameters

1103
00:39:26,560 --> 00:39:28,960
okay interesting because uh

1104
00:39:28,960 --> 00:39:30,480
you know in some of the previous work on

1105
00:39:30,480 --> 00:39:32,560
quantum enumeration something that stood

1106
00:39:32,560 --> 00:39:34,240
out to me is that you do have all of

1107
00:39:34,240 --> 00:39:36,960
these uh you know many bases around and

1108
00:39:36,960 --> 00:39:38,560
you need to have them probably in

1109
00:39:38,560 --> 00:39:40,839
quantum ram which would make them quite

1110
00:39:40,839 --> 00:39:42,320
expensive so it seemed

1111
00:39:42,320 --> 00:39:43,920
like maybe the fact that you're getting

1112
00:39:43,920 --> 00:39:46,000
such a nice speed up classically and not

1113
00:39:46,000 --> 00:39:47,920
needing all those bases around but that

1114
00:39:47,920 --> 00:39:50,480
actually might tip the scales but yeah

1115
00:39:50,480 --> 00:39:51,440
possibly

1116
00:39:51,440 --> 00:39:53,680
yeah okay

1117
00:39:53,680 --> 00:39:55,359
cool um

1118
00:39:55,359 --> 00:39:58,000
let's see we have lots of questions for

1119
00:39:58,000 --> 00:40:00,960
thomas um

1120
00:40:00,960 --> 00:40:04,000
uh and i guess some of them on on the uh

1121
00:40:04,000 --> 00:40:06,000
the implementation so you know can we

1122
00:40:06,000 --> 00:40:08,480
expect uh to be able to use this this

1123
00:40:08,480 --> 00:40:11,520
new ll algorithm in uh you know some of

1124
00:40:11,520 --> 00:40:12,800
the easy

1125
00:40:12,800 --> 00:40:16,319
uh to use packages like pi lll or by fll

1126
00:40:16,319 --> 00:40:17,119
or

1127
00:40:17,119 --> 00:40:20,400
um you know would we want to like uh is

1128
00:40:20,400 --> 00:40:21,760
this something that you really need

1129
00:40:21,760 --> 00:40:23,520
specialized hardware and like lots of

1130
00:40:23,520 --> 00:40:25,599
parallel machines or maybe it's is it

1131
00:40:25,599 --> 00:40:27,760
useful for me just uh i run into a

1132
00:40:27,760 --> 00:40:28,960
lattice and i want to reduce it should i

1133
00:40:28,960 --> 00:40:31,359
use your algorithm yeah yeah so uh

1134
00:40:31,359 --> 00:40:33,359
actually actually it was uh

1135
00:40:33,359 --> 00:40:34,640
we designed it to be fully powered

1136
00:40:34,640 --> 00:40:36,560
elisabeth and it is

1137
00:40:36,560 --> 00:40:39,599
but our let's say main target is uh very

1138
00:40:39,599 --> 00:40:42,319
accessible uh machines like uh

1139
00:40:42,319 --> 00:40:44,640
regular servers or even like desktop

1140
00:40:44,640 --> 00:40:46,720
computers which are just you know

1141
00:40:46,720 --> 00:40:49,119
multi-architecture with uh eight cores

1142
00:40:49,119 --> 00:40:51,200
or something like that we it's not we

1143
00:40:51,200 --> 00:40:53,520
didn't develop it as uh

1144
00:40:53,520 --> 00:40:56,160
being uh

1145
00:40:57,040 --> 00:40:58,400
we didn't want it to run it on the grid

1146
00:40:58,400 --> 00:41:00,640
architectures or whatever it's just for

1147
00:41:00,640 --> 00:41:03,040
very uh simple very simple uh simple

1148
00:41:03,040 --> 00:41:04,480
machines so yeah definitely it's

1149
00:41:04,480 --> 00:41:06,160
supposed to improve practical lattice

1150
00:41:06,160 --> 00:41:07,680
reductions that you can run on your own

1151
00:41:07,680 --> 00:41:10,000
computer

1152
00:41:10,000 --> 00:41:12,240
cool and how about integration into some

1153
00:41:12,240 --> 00:41:14,480
packages is is that um you know can i

1154
00:41:14,480 --> 00:41:16,319
expect to use it anytime soon

1155
00:41:16,319 --> 00:41:18,720
as i was entering so basically right now

1156
00:41:18,720 --> 00:41:21,119
we were writing some some of the code to

1157
00:41:21,119 --> 00:41:22,640
have a

1158
00:41:22,640 --> 00:41:25,200
cleaner code base because like let's

1159
00:41:25,200 --> 00:41:26,800
let's be honest it's very proof of

1160
00:41:26,800 --> 00:41:28,640
concept uh right now

1161
00:41:28,640 --> 00:41:29,440
uh

1162
00:41:29,440 --> 00:41:30,800
and definitely we would be very

1163
00:41:30,800 --> 00:41:33,520
interested in uh merging that with some

1164
00:41:33,520 --> 00:41:37,119
of the big easy uh

1165
00:41:38,560 --> 00:41:40,240
uh because we didn't have any

1166
00:41:40,240 --> 00:41:41,520
improvement on the enumeration or saving

1167
00:41:41,520 --> 00:41:44,240
parties purely on the uh ll base and

1168
00:41:44,240 --> 00:41:47,560
nothing else

1169
00:41:48,400 --> 00:41:49,440
okay

1170
00:41:49,440 --> 00:41:50,880
um

1171
00:41:50,880 --> 00:41:52,079
thomas did any of the other questions

1172
00:41:52,079 --> 00:41:53,440
jump out at you or something you might

1173
00:41:53,440 --> 00:41:56,240
want to uh answer

1174
00:41:56,240 --> 00:41:58,000
audio right now um

1175
00:41:58,000 --> 00:41:59,359
i'm having trouble keeping up with the

1176
00:41:59,359 --> 00:42:00,839
chat

1177
00:42:00,839 --> 00:42:04,400
uh let's see

1178
00:42:06,330 --> 00:42:09,119
[Music]

1179
00:42:09,119 --> 00:42:11,520
i have a question for alex if there's uh

1180
00:42:11,520 --> 00:42:13,040
sure

1181
00:42:13,040 --> 00:42:15,599
alex it occurred to me um

1182
00:42:15,599 --> 00:42:18,720
you are your attack is primarily framed

1183
00:42:18,720 --> 00:42:21,119
in terms of lwe with uh ternary errors

1184
00:42:21,119 --> 00:42:22,960
or small errors

1185
00:42:22,960 --> 00:42:24,960
um is there anything you can do in the

1186
00:42:24,960 --> 00:42:27,440
context of um learning with rounding so

1187
00:42:27,440 --> 00:42:30,160
where some of these ternary values are

1188
00:42:30,160 --> 00:42:31,839
you know deterministic

1189
00:42:31,839 --> 00:42:34,079
round off um

1190
00:42:34,079 --> 00:42:35,520
uh you know let's say ternary for

1191
00:42:35,520 --> 00:42:36,800
example

1192
00:42:36,800 --> 00:42:38,800
does that help uh the attack in any way

1193
00:42:38,800 --> 00:42:41,040
that you can imagine

1194
00:42:41,040 --> 00:42:44,160
so honestly i don't know so it's not i

1195
00:42:44,160 --> 00:42:47,119
think it's not really limited to only

1196
00:42:47,119 --> 00:42:50,000
ternary errors you could maybe work with

1197
00:42:50,000 --> 00:42:52,880
other errors as well so so far

1198
00:42:52,880 --> 00:42:54,880
the way i present it you have to search

1199
00:42:54,880 --> 00:42:56,880
for them and that's why they are limited

1200
00:42:56,880 --> 00:42:59,040
right but you might use locality

1201
00:42:59,040 --> 00:43:01,200
sensitive hashing or things like this to

1202
00:43:01,200 --> 00:43:03,839
do it for learning with rounding

1203
00:43:03,839 --> 00:43:05,839
actually i i have to look up whether

1204
00:43:05,839 --> 00:43:07,760
this makes sense or not or whether it

1205
00:43:07,760 --> 00:43:10,319
helps or not i don't i cannot answer it

1206
00:43:10,319 --> 00:43:11,599
i'm sorry

1207
00:43:11,599 --> 00:43:14,400
okay yeah thanks

1208
00:43:18,000 --> 00:43:20,160
okay maybe a uh

1209
00:43:20,160 --> 00:43:22,800
kind of a soft question for tice i uh so

1210
00:43:22,800 --> 00:43:24,960
it's a really nice result one thing that

1211
00:43:24,960 --> 00:43:26,640
concerns me a little bit and i mean you

1212
00:43:26,640 --> 00:43:28,880
you address this in your talk um there's

1213
00:43:28,880 --> 00:43:31,280
this gap between the you know when

1214
00:43:31,280 --> 00:43:32,319
you're when you're actually breaking a

1215
00:43:32,319 --> 00:43:33,760
crypto system you have you know the

1216
00:43:33,760 --> 00:43:34,960
dimension that you're going to perform

1217
00:43:34,960 --> 00:43:36,160
sitting in

1218
00:43:36,160 --> 00:43:37,839
and that's kind of a big open question

1219
00:43:37,839 --> 00:43:39,520
so we've seen some improvements on that

1220
00:43:39,520 --> 00:43:40,960
with the dimensions for free trick or

1221
00:43:40,960 --> 00:43:42,319
some of your own work

1222
00:43:42,319 --> 00:43:43,200
um

1223
00:43:43,200 --> 00:43:45,280
what uh what's your what's your feeling

1224
00:43:45,280 --> 00:43:47,760
on how those will progress do we really

1225
00:43:47,760 --> 00:43:49,200
get um

1226
00:43:49,200 --> 00:43:50,640
you know some

1227
00:43:50,640 --> 00:43:52,160
this conditional assurance that we're

1228
00:43:52,160 --> 00:43:54,480
getting from your lower bound on

1229
00:43:54,480 --> 00:43:56,079
on the on the sipping techniques or the

1230
00:43:56,079 --> 00:43:58,800
the nearest neighbor search techniques

1231
00:43:58,800 --> 00:44:00,560
you know how confident should we be or

1232
00:44:00,560 --> 00:44:01,760
is there

1233
00:44:01,760 --> 00:44:04,000
i mean the yeah so so in the in the

1234
00:44:04,000 --> 00:44:05,839
entire thought only says that if you are

1235
00:44:05,839 --> 00:44:07,920
trying to improve like this this part of

1236
00:44:07,920 --> 00:44:10,319
your approach then you're not going to

1237
00:44:10,319 --> 00:44:12,079
do much better i mean even there it's

1238
00:44:12,079 --> 00:44:13,119
like

1239
00:44:13,119 --> 00:44:14,640
part of this is asymptotic and part of

1240
00:44:14,640 --> 00:44:16,400
it is quite complex but

1241
00:44:16,400 --> 00:44:18,000
like if you want to improve the nearest

1242
00:44:18,000 --> 00:44:19,200
neighbor part you're not going to do

1243
00:44:19,200 --> 00:44:21,520
better so that's that's some assurance

1244
00:44:21,520 --> 00:44:23,520
that you get but indeed there's like

1245
00:44:23,520 --> 00:44:25,920
the the the closed path column inside

1246
00:44:25,920 --> 00:44:28,400
the letter saving for instance which

1247
00:44:28,400 --> 00:44:29,839
like maybe you can do something else

1248
00:44:29,839 --> 00:44:31,359
there and then also letter saving like

1249
00:44:31,359 --> 00:44:33,040
in in a complete attack you probably do

1250
00:44:33,040 --> 00:44:34,880
some basis detection you can do

1251
00:44:34,880 --> 00:44:36,480
maybe something else there like with

1252
00:44:36,480 --> 00:44:38,160
jessica you can do better than just

1253
00:44:38,160 --> 00:44:40,000
doing it as a black box and

1254
00:44:40,000 --> 00:44:42,079
there are several other things also like

1255
00:44:42,079 --> 00:44:43,520
the

1256
00:44:43,520 --> 00:44:45,920
dimensions for free and uh

1257
00:44:45,920 --> 00:44:47,599
yeah and maybe even you can do something

1258
00:44:47,599 --> 00:44:49,440
smarter than that assuming i mean

1259
00:44:49,440 --> 00:44:51,040
of course but this is like just for this

1260
00:44:51,040 --> 00:44:53,119
part and of course like right now the

1261
00:44:53,119 --> 00:44:54,640
state of the art for attacking a scheme

1262
00:44:54,640 --> 00:44:57,119
would be usually like some form of basis

1263
00:44:57,119 --> 00:44:58,800
reduction with sieving

1264
00:44:58,800 --> 00:45:00,480
inside of it and the saving would be

1265
00:45:00,480 --> 00:45:02,079
with uh hash based nearest neighbor

1266
00:45:02,079 --> 00:45:03,440
surging so

1267
00:45:03,440 --> 00:45:05,119
yeah i mean it's yeah it's a conditional

1268
00:45:05,119 --> 00:45:06,880
part for part of your argument of course

1269
00:45:06,880 --> 00:45:08,000
i mean it's not

1270
00:45:08,000 --> 00:45:09,440
we're not there yet but it's the first

1271
00:45:09,440 --> 00:45:11,440
step i guess towards

1272
00:45:11,440 --> 00:45:14,640
some lower bounds at least

1273
00:45:15,599 --> 00:45:17,760
okay thanks uh alex has a question for

1274
00:45:17,760 --> 00:45:21,760
you twice um is the sub-optimality of my

1275
00:45:21,760 --> 00:45:23,839
other 15 an artifact of the full

1276
00:45:23,839 --> 00:45:25,760
exponential scenario is it optimal in

1277
00:45:25,760 --> 00:45:28,960
the sub-exponential scenario or in any

1278
00:45:28,960 --> 00:45:29,920
um

1279
00:45:29,920 --> 00:45:31,119
yeah so the

1280
00:45:31,119 --> 00:45:33,680
so there were already uh passwords also

1281
00:45:33,680 --> 00:45:35,280
like on neo's neighbor techniques but

1282
00:45:35,280 --> 00:45:37,280
also on lower bounds for the

1283
00:45:37,280 --> 00:45:40,160
subexination size of the database in

1284
00:45:40,160 --> 00:45:42,079
terms of the dimension and for those

1285
00:45:42,079 --> 00:45:43,520
like several techniques were optimal

1286
00:45:43,520 --> 00:45:45,119
also techniques which turn out to be

1287
00:45:45,119 --> 00:45:46,480
suboptimal for instance in the better

1288
00:45:46,480 --> 00:45:48,400
shaping setting they turned out to be

1289
00:45:48,400 --> 00:45:50,560
optimal in the excellent show at this

1290
00:45:50,560 --> 00:45:52,640
space so it's really a different color

1291
00:45:52,640 --> 00:45:54,880
you have to look at it separately

1292
00:45:54,880 --> 00:45:57,280
so yeah i think the the technique that

1293
00:45:57,280 --> 00:45:59,200
you're using in this 2015 result is

1294
00:45:59,200 --> 00:46:01,280
actually also optimal if you look at the

1295
00:46:01,280 --> 00:46:03,520
sub-exponential less sizes but yeah i

1296
00:46:03,520 --> 00:46:04,880
mean it could also be optimal in the

1297
00:46:04,880 --> 00:46:06,720
exponential list size we

1298
00:46:06,720 --> 00:46:08,240
just have a lower bound which does not

1299
00:46:08,240 --> 00:46:10,400
match the upper bounds so

1300
00:46:10,400 --> 00:46:13,119
um yeah i mean there's still some some

1301
00:46:13,119 --> 00:46:14,480
work to do there to see if the lower

1302
00:46:14,480 --> 00:46:16,720
bounds should go up a bit too much level

1303
00:46:16,720 --> 00:46:18,079
boundary if the upper bounds actually

1304
00:46:18,079 --> 00:46:19,200
not

1305
00:46:19,200 --> 00:46:21,200
yeah if it should go down towards lower

1306
00:46:21,200 --> 00:46:23,440
bounds using different chords then what

1307
00:46:23,440 --> 00:46:25,440
you like spherical caps don't match some

1308
00:46:25,440 --> 00:46:26,720
bound in the

1309
00:46:26,720 --> 00:46:28,880
in the pool somehow like in the lower

1310
00:46:28,880 --> 00:46:30,319
bounds

1311
00:46:30,319 --> 00:46:32,480
no

1312
00:46:34,319 --> 00:46:36,880
okay elena is saying um mmo meets our

1313
00:46:36,880 --> 00:46:38,480
lower bound in the sub-exponential

1314
00:46:38,480 --> 00:46:41,040
non-dense regime

1315
00:46:41,040 --> 00:46:44,000
just a little clarification there

1316
00:46:44,000 --> 00:46:46,400
um

1317
00:46:46,560 --> 00:46:49,760
okay are there any more questions uh

1318
00:46:49,760 --> 00:46:51,040
now would be a good time to drop them

1319
00:46:51,040 --> 00:46:52,960
into the chat um

1320
00:46:52,960 --> 00:46:54,079
if there's anything i've missed and

1321
00:46:54,079 --> 00:46:56,240
somebody wants to just

1322
00:46:56,240 --> 00:47:00,200
just flag me on it

1323
00:47:12,480 --> 00:47:13,760
okay if not it looks like we're a little

1324
00:47:13,760 --> 00:47:16,079
ahead of sky

