1
00:00:00,399 --> 00:00:02,639
hi my name is carson baum and i will now

2
00:00:02,639 --> 00:00:04,319
present you the mac and cheese zero

3
00:00:04,319 --> 00:00:06,240
knowledge proof system for boolean and

4
00:00:06,240 --> 00:00:08,160
arithmetic circuits with nested

5
00:00:08,160 --> 00:00:09,440
disjunctions

6
00:00:09,440 --> 00:00:12,320
this is joint work with alex malozimov

7
00:00:12,320 --> 00:00:14,960
and mark rosen from galoa and peter shaw

8
00:00:14,960 --> 00:00:18,240
from always university

9
00:00:18,240 --> 00:00:19,520
as a

10
00:00:19,520 --> 00:00:21,279
quick overview in a nutshell mac and

11
00:00:21,279 --> 00:00:24,240
cheese is a commit and proof style zero

12
00:00:24,240 --> 00:00:25,599
knowledge proof

13
00:00:25,599 --> 00:00:26,400
for

14
00:00:26,400 --> 00:00:29,439
arbitrary circuits over any field

15
00:00:29,439 --> 00:00:32,558
it has specific optimizations that allow

16
00:00:32,558 --> 00:00:34,640
it to support nested disjunctions more

17
00:00:34,640 --> 00:00:35,920
efficiently

18
00:00:35,920 --> 00:00:37,440
and it's practically efficient our

19
00:00:37,440 --> 00:00:38,800
implementation

20
00:00:38,800 --> 00:00:40,879
that includes both the pre-processing

21
00:00:40,879 --> 00:00:42,640
and the online phase of the

22
00:00:42,640 --> 00:00:45,120
xero launch proof system achieves

23
00:00:45,120 --> 00:00:48,480
140 nanoseconds per proven and gate or

24
00:00:48,480 --> 00:00:50,559
1.5 milliseconds

25
00:00:50,559 --> 00:00:54,160
per multiplication over a 61 bills bit

26
00:00:54,160 --> 00:00:55,920
field

27
00:00:55,920 --> 00:00:56,719
and

28
00:00:56,719 --> 00:00:59,600
our proof system asymptotically sends

29
00:00:59,600 --> 00:01:02,320
approximately one field element for any

30
00:01:02,320 --> 00:01:04,000
kind of multiplication

31
00:01:04,000 --> 00:01:06,080
or three field elements

32
00:01:06,080 --> 00:01:10,159
if no amortizations are being used

33
00:01:10,159 --> 00:01:12,640
before i will go into the details of the

34
00:01:12,640 --> 00:01:15,119
mac and cheese proof system let me recap

35
00:01:15,119 --> 00:01:17,600
some definitions which are necessary for

36
00:01:17,600 --> 00:01:19,680
understanding how mac and cheese

37
00:01:19,680 --> 00:01:21,119
actually works

38
00:01:21,119 --> 00:01:21,920
so

39
00:01:21,920 --> 00:01:23,280
let us assume

40
00:01:23,280 --> 00:01:25,280
that we want to show that a statement x

41
00:01:25,280 --> 00:01:28,320
is in the language l then you know

42
00:01:28,320 --> 00:01:30,720
we could just consider

43
00:01:30,720 --> 00:01:33,280
that there is a turing machine

44
00:01:33,280 --> 00:01:34,240
which

45
00:01:34,240 --> 00:01:35,600
accepts

46
00:01:35,600 --> 00:01:38,479
x together with a witness w

47
00:01:38,479 --> 00:01:40,799
in polynomial time

48
00:01:40,799 --> 00:01:43,119
um an alternative

49
00:01:43,119 --> 00:01:45,360
view which we use in this paper which is

50
00:01:45,360 --> 00:01:47,439
much more useful and is generally being

51
00:01:47,439 --> 00:01:48,399
used

52
00:01:48,399 --> 00:01:51,200
in uh in many zeros proof systems is

53
00:01:51,200 --> 00:01:52,640
that there

54
00:01:52,640 --> 00:01:53,759
exists

55
00:01:53,759 --> 00:01:56,399
circuit c which can be obtained from the

56
00:01:56,399 --> 00:01:58,320
statement x and

57
00:01:58,320 --> 00:01:59,920
we say that

58
00:01:59,920 --> 00:02:02,320
x is in the language l

59
00:02:02,320 --> 00:02:04,799
if there existed witness w such that the

60
00:02:04,799 --> 00:02:07,360
circuit when evaluated on the witness w

61
00:02:07,360 --> 00:02:09,360
evaluates to zero

62
00:02:09,360 --> 00:02:10,160
so

63
00:02:10,160 --> 00:02:12,319
only if and only if the circuit

64
00:02:12,319 --> 00:02:14,319
evaluates to zero

65
00:02:14,319 --> 00:02:15,680
we say that

66
00:02:15,680 --> 00:02:17,280
x is in the language

67
00:02:17,280 --> 00:02:21,360
and here w is considered as a witness

68
00:02:21,360 --> 00:02:23,840
and if we just

69
00:02:23,840 --> 00:02:25,840
just write out that circuit and

70
00:02:25,840 --> 00:02:29,280
alternatively we could view that as

71
00:02:29,280 --> 00:02:31,599
many gates with inputs and outputs as

72
00:02:31,599 --> 00:02:32,800
shown here

73
00:02:32,800 --> 00:02:33,599
and

74
00:02:33,599 --> 00:02:35,120
the inputs

75
00:02:35,120 --> 00:02:37,840
of the top level of gates

76
00:02:37,840 --> 00:02:39,680
will be fed with

77
00:02:39,680 --> 00:02:41,840
the witness w

78
00:02:41,840 --> 00:02:43,360
with the individual field elements from

79
00:02:43,360 --> 00:02:46,879
the witness and then one evaluates

80
00:02:46,879 --> 00:02:48,400
each of the gates

81
00:02:48,400 --> 00:02:51,040
throughout the whole circuits until

82
00:02:51,040 --> 00:02:53,920
the output of the last gate has been

83
00:02:53,920 --> 00:02:57,120
obtained and then we just consider if

84
00:02:57,120 --> 00:02:59,440
the output of that last gate is being

85
00:02:59,440 --> 00:03:01,519
zero or not

86
00:03:01,519 --> 00:03:02,319
and

87
00:03:02,319 --> 00:03:04,800
we can use this kind of formulation

88
00:03:04,800 --> 00:03:06,800
in uh when constructing a zero knowledge

89
00:03:06,800 --> 00:03:07,760
proof

90
00:03:07,760 --> 00:03:11,040
where the view is now that the prover uh

91
00:03:11,040 --> 00:03:13,360
knows the circuit c

92
00:03:13,360 --> 00:03:15,760
and so does the verifier and the proof

93
00:03:15,760 --> 00:03:19,440
additionally has the witness w

94
00:03:19,440 --> 00:03:20,959
now the approver wants to convince the

95
00:03:20,959 --> 00:03:24,000
verifier that uh the statement is true

96
00:03:24,000 --> 00:03:27,760
so that c on w evaluates to zero

97
00:03:27,760 --> 00:03:30,720
so the two run an interactive protocol

98
00:03:30,720 --> 00:03:33,360
which has uh at the end the verifier

99
00:03:33,360 --> 00:03:36,560
saying that he either accepts or rejects

100
00:03:36,560 --> 00:03:39,599
and this usually comes with three

101
00:03:39,599 --> 00:03:40,799
properties that we want for zero

102
00:03:40,799 --> 00:03:43,120
knowledge proofs namely the protocol is

103
00:03:43,120 --> 00:03:46,080
complete if w is indeed a witness for c

104
00:03:46,080 --> 00:03:48,080
uh then the anonymous verifier will

105
00:03:48,080 --> 00:03:50,239
always accept

106
00:03:50,239 --> 00:03:52,400
additionally we have soundness meaning

107
00:03:52,400 --> 00:03:55,519
that uh if the prover uh if the

108
00:03:55,519 --> 00:03:56,799
statement is not true then the approver

109
00:03:56,799 --> 00:03:58,879
cannot convince the verifier in this

110
00:03:58,879 --> 00:04:00,959
word we will use uh knowledge soundness

111
00:04:00,959 --> 00:04:03,360
meaning that if a prover can convince a

112
00:04:03,360 --> 00:04:05,599
verifier with decent probability then

113
00:04:05,599 --> 00:04:07,519
one would be able to extract

114
00:04:07,519 --> 00:04:10,560
a uh a true witness w uh for the

115
00:04:10,560 --> 00:04:11,840
statement

116
00:04:11,840 --> 00:04:13,599
and a protocol is zero knowledge meaning

117
00:04:13,599 --> 00:04:14,400
that

118
00:04:14,400 --> 00:04:16,880
all the verifier learns is if the

119
00:04:16,880 --> 00:04:18,720
statement is true or not but it in

120
00:04:18,720 --> 00:04:20,160
particular does not learn any

121
00:04:20,160 --> 00:04:23,840
information about the witness w

122
00:04:23,919 --> 00:04:25,919
a well-known technique for constructing

123
00:04:25,919 --> 00:04:27,360
zero large proofs is the so-called

124
00:04:27,360 --> 00:04:29,199
commit improved paradigm

125
00:04:29,199 --> 00:04:30,960
here one uses homomorphic commitments in

126
00:04:30,960 --> 00:04:32,320
order to construct a zero-knowledge

127
00:04:32,320 --> 00:04:33,199
proof

128
00:04:33,199 --> 00:04:35,199
and the starting point is the

129
00:04:35,199 --> 00:04:36,800
protocol due to common dumb go which

130
00:04:36,800 --> 00:04:39,199
uses commitments based on discrete block

131
00:04:39,199 --> 00:04:41,199
assumptions

132
00:04:41,199 --> 00:04:42,479
so let's assume

133
00:04:42,479 --> 00:04:45,600
that we have a circuit c and we want to

134
00:04:45,600 --> 00:04:48,800
convince the verifier that c

135
00:04:48,800 --> 00:04:52,479
applied to some witness w is zero

136
00:04:52,479 --> 00:04:54,720
so what the prover does is it commits to

137
00:04:54,720 --> 00:04:57,520
the individual elements of the witness w

138
00:04:57,520 --> 00:05:00,080
all of them in individual commitments

139
00:05:00,080 --> 00:05:03,199
then it computes the outputs of all the

140
00:05:03,199 --> 00:05:04,880
intermediate gates

141
00:05:04,880 --> 00:05:07,039
and it proves in zero knowledge that

142
00:05:07,039 --> 00:05:08,880
the commitments to the outputs of each

143
00:05:08,880 --> 00:05:10,960
gate are consistent with the inputs of

144
00:05:10,960 --> 00:05:12,479
each of the gates

145
00:05:12,479 --> 00:05:14,960
so that means by recursively recursively

146
00:05:14,960 --> 00:05:16,160
applying

147
00:05:16,160 --> 00:05:17,520
this

148
00:05:17,520 --> 00:05:19,440
this proof for each of the gates we in

149
00:05:19,440 --> 00:05:22,320
the end get that the output

150
00:05:22,320 --> 00:05:24,880
can be opened to zero if and only if the

151
00:05:24,880 --> 00:05:27,280
witness was actually valid for a certain

152
00:05:27,280 --> 00:05:29,199
circuit c

153
00:05:29,199 --> 00:05:30,960
this approach for commit improve

154
00:05:30,960 --> 00:05:33,120
actually only needs linearly homomorphic

155
00:05:33,120 --> 00:05:35,360
commitments and this is well known

156
00:05:35,360 --> 00:05:37,440
here um what this means is that the

157
00:05:37,440 --> 00:05:39,120
verifier can

158
00:05:39,120 --> 00:05:40,720
compute a

159
00:05:40,720 --> 00:05:42,639
commitment to

160
00:05:42,639 --> 00:05:45,360
alpha x plus beta y

161
00:05:45,360 --> 00:05:48,720
plus gamma from commitments to x and y

162
00:05:48,720 --> 00:05:49,759
and

163
00:05:49,759 --> 00:05:51,680
publicly known values alpha beta and

164
00:05:51,680 --> 00:05:53,360
gamma without any interaction with the

165
00:05:53,360 --> 00:05:54,400
prover

166
00:05:54,400 --> 00:05:55,600
so the parties do not have to

167
00:05:55,600 --> 00:05:57,440
communicate in order to transform

168
00:05:57,440 --> 00:05:58,800
commitments

169
00:05:58,800 --> 00:05:59,759
into

170
00:05:59,759 --> 00:06:02,800
linearly related commitments

171
00:06:02,800 --> 00:06:05,199
so if we want to evaluate linear gates

172
00:06:05,199 --> 00:06:06,880
or prove anything about the output of a

173
00:06:06,880 --> 00:06:10,880
linear gate then we only have to

174
00:06:10,880 --> 00:06:13,280
apply this homomorphism and do not need

175
00:06:13,280 --> 00:06:15,440
any interaction in order to prove this

176
00:06:15,440 --> 00:06:18,319
relation whereas for multiplication

177
00:06:18,319 --> 00:06:19,840
gates

178
00:06:19,840 --> 00:06:23,280
what one usually does is one uh

179
00:06:23,280 --> 00:06:24,880
the approver commits to a random

180
00:06:24,880 --> 00:06:28,160
multiplication triple as well as to the

181
00:06:28,160 --> 00:06:31,199
product z that should come out of this

182
00:06:31,199 --> 00:06:33,919
multiplication gate then one uses the

183
00:06:33,919 --> 00:06:35,919
so-called viva circuit randomization

184
00:06:35,919 --> 00:06:38,880
technique in order to prove that

185
00:06:38,880 --> 00:06:41,440
the commitment in that opens to a

186
00:06:41,440 --> 00:06:44,000
commitment of x multiplied with y and

187
00:06:44,000 --> 00:06:46,160
for this one uses the multiplication

188
00:06:46,160 --> 00:06:47,360
triple that

189
00:06:47,360 --> 00:06:48,960
the approver additionally had to commit

190
00:06:48,960 --> 00:06:51,039
to

191
00:06:51,039 --> 00:06:53,440
these are the general ideas which you

192
00:06:53,440 --> 00:06:55,039
can also find in the mac and cheese

193
00:06:55,039 --> 00:06:58,080
protocol although we alter them in order

194
00:06:58,080 --> 00:07:00,000
to obtain a highly efficiency or

195
00:07:00,000 --> 00:07:03,680
knowledge proof system

196
00:07:03,680 --> 00:07:04,960
the foundation

197
00:07:04,960 --> 00:07:07,360
of our proof system are so-called

198
00:07:07,360 --> 00:07:09,919
vector-previous linear evaluations

199
00:07:09,919 --> 00:07:11,120
where

200
00:07:11,120 --> 00:07:13,440
oblivious linear evaluation or ole for

201
00:07:13,440 --> 00:07:16,319
short can be seen as a generalization of

202
00:07:16,319 --> 00:07:18,080
oblivious transfers to an arbitrary

203
00:07:18,080 --> 00:07:19,919
field f

204
00:07:19,919 --> 00:07:22,319
here the sender inputs alpha and beta

205
00:07:22,319 --> 00:07:25,840
into our ole box while

206
00:07:25,840 --> 00:07:28,720
the receiver inputs are and obtains the

207
00:07:28,720 --> 00:07:32,240
correlation alpha times r plus beta

208
00:07:32,240 --> 00:07:33,440
here

209
00:07:33,440 --> 00:07:34,960
the sender doesn't learn anything about

210
00:07:34,960 --> 00:07:37,599
r while the verifier doesn't learn

211
00:07:37,599 --> 00:07:39,360
the receiver doesn't learn anything

212
00:07:39,360 --> 00:07:42,960
beyond this linear relation

213
00:07:43,199 --> 00:07:48,240
and vector only is uh a version of ole

214
00:07:48,240 --> 00:07:50,400
where if we have multiple oblivious

215
00:07:50,400 --> 00:07:51,919
evaluations

216
00:07:51,919 --> 00:07:53,919
um then they will all have the same

217
00:07:53,919 --> 00:07:54,960
alpha

218
00:07:54,960 --> 00:07:55,840
across

219
00:07:55,840 --> 00:07:57,039
all the different

220
00:07:57,039 --> 00:07:58,800
instances

221
00:07:58,800 --> 00:08:01,599
and there exist very fast instantiations

222
00:08:01,599 --> 00:08:03,599
that allow you to

223
00:08:03,599 --> 00:08:07,039
obtain lots of vo elite correlations

224
00:08:07,039 --> 00:08:10,000
based on the work of boyle at all

225
00:08:10,000 --> 00:08:11,280
and these

226
00:08:11,280 --> 00:08:13,120
in particular need a very small

227
00:08:13,120 --> 00:08:14,400
communication

228
00:08:14,400 --> 00:08:17,120
of let's say approximately 0.4 bits per

229
00:08:17,120 --> 00:08:19,280
uh correlation and a small amount of

230
00:08:19,280 --> 00:08:21,199
computation so

231
00:08:21,199 --> 00:08:24,160
approximately 80 to 85 nanoseconds for

232
00:08:24,160 --> 00:08:27,520
one vector only instance

233
00:08:27,520 --> 00:08:29,599
in our work we instantiate the

234
00:08:29,599 --> 00:08:31,840
commitments using

235
00:08:31,840 --> 00:08:34,080
linearly homomorphic max which are

236
00:08:34,080 --> 00:08:36,000
instantiated from this

237
00:08:36,000 --> 00:08:37,440
vector over e

238
00:08:37,440 --> 00:08:39,760
so let's say we have a random vector

239
00:08:39,760 --> 00:08:42,880
overle instance where we assume that the

240
00:08:42,880 --> 00:08:44,800
prover actually inputs r into a

241
00:08:44,800 --> 00:08:47,600
vectorial e whereas the verifier inputs

242
00:08:47,600 --> 00:08:49,519
alpha and beta

243
00:08:49,519 --> 00:08:51,360
the prover additionally has the value m

244
00:08:51,360 --> 00:08:52,959
which we now consider as an information

245
00:08:52,959 --> 00:08:54,560
theoretic mac

246
00:08:54,560 --> 00:08:57,040
on the message r

247
00:08:57,040 --> 00:08:59,839
under the key alpha and beta this

248
00:08:59,839 --> 00:09:01,440
on its own is already linearly

249
00:09:01,440 --> 00:09:03,360
homomorphic over f which one can easily

250
00:09:03,360 --> 00:09:05,120
verify

251
00:09:05,120 --> 00:09:06,160
now

252
00:09:06,160 --> 00:09:07,600
how can this be used as a commitment

253
00:09:07,600 --> 00:09:09,839
scheme well uh assuming we can make lots

254
00:09:09,839 --> 00:09:12,320
of these correlations for random r then

255
00:09:12,320 --> 00:09:14,240
in order to commit to a fixed value x

256
00:09:14,240 --> 00:09:15,839
the prover can simply send the

257
00:09:15,839 --> 00:09:17,839
difference between x and the random

258
00:09:17,839 --> 00:09:19,279
value r

259
00:09:19,279 --> 00:09:21,920
um to verify the verifier locally

260
00:09:21,920 --> 00:09:24,480
updates his value beta

261
00:09:24,480 --> 00:09:26,480
and now one can easily see that by

262
00:09:26,480 --> 00:09:28,320
adjusting

263
00:09:28,320 --> 00:09:29,600
beta

264
00:09:29,600 --> 00:09:31,279
now both parties together hold the

265
00:09:31,279 --> 00:09:33,760
correlation

266
00:09:33,760 --> 00:09:36,399
which max the value x using alpha and

267
00:09:36,399 --> 00:09:38,080
beta prime

268
00:09:38,080 --> 00:09:39,920
as as keys

269
00:09:39,920 --> 00:09:41,920
and in order to open a commitment the

270
00:09:41,920 --> 00:09:43,680
prover simply sends x as well as the

271
00:09:43,680 --> 00:09:46,080
macm to the verifier who checks the

272
00:09:46,080 --> 00:09:50,480
relation with alpha and beta prime

273
00:09:50,480 --> 00:09:53,200
this is um only

274
00:09:53,200 --> 00:09:54,000
as

275
00:09:54,000 --> 00:09:56,000
binding as the

276
00:09:56,000 --> 00:09:57,839
size of the field so if we want to use

277
00:09:57,839 --> 00:09:59,120
this with

278
00:09:59,120 --> 00:10:00,880
for example bits then

279
00:10:00,880 --> 00:10:02,480
one would either have to repeat this

280
00:10:02,480 --> 00:10:04,240
multiple times or use subfield

281
00:10:04,240 --> 00:10:07,680
vectorially where r comes from a

282
00:10:07,680 --> 00:10:10,399
subfield of where alpha and beta

283
00:10:10,399 --> 00:10:12,000
actually come from

284
00:10:12,000 --> 00:10:14,079
and also one can easily see that this is

285
00:10:14,079 --> 00:10:16,320
a designated verifier scheme namely the

286
00:10:16,320 --> 00:10:18,320
verifier has some secret randomness

287
00:10:18,320 --> 00:10:20,480
which is alpha and beta

288
00:10:20,480 --> 00:10:22,880
if the prover would ever get hold of

289
00:10:22,880 --> 00:10:24,320
alpha and beta then it could forge

290
00:10:24,320 --> 00:10:27,279
proofs so the verifier must keep this as

291
00:10:27,279 --> 00:10:29,839
a secret

292
00:10:30,079 --> 00:10:32,000
using these information theoretic max we

293
00:10:32,000 --> 00:10:34,399
can now outline a simple version of the

294
00:10:34,399 --> 00:10:36,640
mac and cheese protocol here the prover

295
00:10:36,640 --> 00:10:38,160
initially commits to all the elements of

296
00:10:38,160 --> 00:10:39,920
the witness and then evaluates the

297
00:10:39,920 --> 00:10:42,480
circuit gate by gate and proves that

298
00:10:42,480 --> 00:10:44,800
all the gate outputs are committed

299
00:10:44,800 --> 00:10:46,480
correctly now for the linear gates

300
00:10:46,480 --> 00:10:48,160
proving this is easy because we can use

301
00:10:48,160 --> 00:10:49,120
the

302
00:10:49,120 --> 00:10:51,680
linear homomorphism of the information

303
00:10:51,680 --> 00:10:53,440
theoretic max

304
00:10:53,440 --> 00:10:55,120
in order to prove that multiplications

305
00:10:55,120 --> 00:10:56,560
are done correctly

306
00:10:56,560 --> 00:10:58,640
what the prover does is an optimization

307
00:10:58,640 --> 00:11:00,800
of beaver's approach where it's in

308
00:11:00,800 --> 00:11:02,240
addition to the output of the

309
00:11:02,240 --> 00:11:04,560
multiplication commits to an auxiliary

310
00:11:04,560 --> 00:11:07,760
value c which is derived from

311
00:11:07,760 --> 00:11:09,920
a random value a and remember that

312
00:11:09,920 --> 00:11:11,680
random commitments can be done cheaply

313
00:11:11,680 --> 00:11:13,680
in vectorially

314
00:11:13,680 --> 00:11:16,160
and a is multiplied with uh one of the

315
00:11:16,160 --> 00:11:18,160
terms of the multiplication that we want

316
00:11:18,160 --> 00:11:19,680
to verify

317
00:11:19,680 --> 00:11:22,640
not a very fire sensor random challenge

318
00:11:22,640 --> 00:11:25,440
which is used in order to create a and

319
00:11:25,440 --> 00:11:27,920
open a linear relation and then the

320
00:11:27,920 --> 00:11:30,000
prover additionally shows that

321
00:11:30,000 --> 00:11:31,200
this linear

322
00:11:31,200 --> 00:11:32,959
linear relation

323
00:11:32,959 --> 00:11:35,200
evaluates to zero

324
00:11:35,200 --> 00:11:36,720
now the good thing about

325
00:11:36,720 --> 00:11:39,360
zero checks is that one only has to send

326
00:11:39,360 --> 00:11:41,440
the mac because the verifier already

327
00:11:41,440 --> 00:11:43,920
knows what to expect namely that the

328
00:11:43,920 --> 00:11:46,320
committed value there must be zero

329
00:11:46,320 --> 00:11:48,560
and in particular the verifier then only

330
00:11:48,560 --> 00:11:50,480
has to check if the value being sent is

331
00:11:50,480 --> 00:11:52,160
the same as the value that already has

332
00:11:52,160 --> 00:11:54,959
namely the value beta

333
00:11:54,959 --> 00:11:57,920
now um this simple multiplication check

334
00:11:57,920 --> 00:11:59,680
sends three field elements per

335
00:11:59,680 --> 00:12:01,279
multiplication which one can easily

336
00:12:01,279 --> 00:12:02,320
verify

337
00:12:02,320 --> 00:12:04,399
um but this only holds even true for

338
00:12:04,399 --> 00:12:05,680
large fields for small fields the

339
00:12:05,680 --> 00:12:07,680
overhead might be even bigger

340
00:12:07,680 --> 00:12:10,480
so the question is if we can actually do

341
00:12:10,480 --> 00:12:12,160
multiplication verification with less

342
00:12:12,160 --> 00:12:13,839
overhead and we show that this is

343
00:12:13,839 --> 00:12:15,760
actually possible by using the recursive

344
00:12:15,760 --> 00:12:17,600
dot product check of

345
00:12:17,600 --> 00:12:20,079
bonnie at all

346
00:12:20,079 --> 00:12:21,680
this increases the round complexity for

347
00:12:21,680 --> 00:12:24,079
checking multiplications from a constant

348
00:12:24,079 --> 00:12:25,440
number of rounds to something that is

349
00:12:25,440 --> 00:12:27,279
logarithmic in the number of

350
00:12:27,279 --> 00:12:29,839
multiplications that we want to check

351
00:12:29,839 --> 00:12:31,920
this again can we get down to a constant

352
00:12:31,920 --> 00:12:34,079
by using the fiat chamber transform and

353
00:12:34,079 --> 00:12:36,000
the communication improves to one plus

354
00:12:36,000 --> 00:12:38,240
epsilon field elements per

355
00:12:38,240 --> 00:12:41,279
multiplication or also per verified and

356
00:12:41,279 --> 00:12:42,560
relation

357
00:12:42,560 --> 00:12:44,320
where the constant

358
00:12:44,320 --> 00:12:45,959
is

359
00:12:45,959 --> 00:12:48,000
0.008 for

360
00:12:48,000 --> 00:12:50,959
1 million multiplications or 1 million

361
00:12:50,959 --> 00:12:52,639
ants that we

362
00:12:52,639 --> 00:12:55,200
verify at once

363
00:12:55,200 --> 00:12:57,279
and if you want to learn in more detail

364
00:12:57,279 --> 00:12:59,200
how this actually works i'd like to

365
00:12:59,200 --> 00:13:02,720
refer you to the paper for more details

366
00:13:02,720 --> 00:13:05,040
as already mentioned in the beginning a

367
00:13:05,040 --> 00:13:06,480
special feature of mac and cheese is

368
00:13:06,480 --> 00:13:08,320
that it can more efficiently deal with

369
00:13:08,320 --> 00:13:10,320
nested disjunctions so we'll now explain

370
00:13:10,320 --> 00:13:11,920
what these are and how we actually

371
00:13:11,920 --> 00:13:15,440
handle them in our proof system

372
00:13:15,440 --> 00:13:17,120
for this junction

373
00:13:17,120 --> 00:13:18,000
we

374
00:13:18,000 --> 00:13:19,440
consider that there are multiple

375
00:13:19,440 --> 00:13:22,959
sub-circuits in this example c1 and c2

376
00:13:22,959 --> 00:13:24,000
and

377
00:13:24,000 --> 00:13:27,120
our circuit will evaluate to uh to zero

378
00:13:27,120 --> 00:13:30,000
meaning the witness is valid

379
00:13:30,000 --> 00:13:31,040
if

380
00:13:31,040 --> 00:13:33,519
the first circuit evaluates to zero or

381
00:13:33,519 --> 00:13:35,920
the second circuit divides to 0 or maybe

382
00:13:35,920 --> 00:13:39,040
both of them at the same time

383
00:13:39,040 --> 00:13:40,880
and usually if we just feed such a

384
00:13:40,880 --> 00:13:42,720
circuit into

385
00:13:42,720 --> 00:13:45,279
a proof system then we would have to

386
00:13:45,279 --> 00:13:47,519
transfer communication for

387
00:13:47,519 --> 00:13:51,519
both of these sub-circuits

388
00:13:51,920 --> 00:13:54,880
now what we want to achieve is that we

389
00:13:54,880 --> 00:13:56,639
only communicate information that is

390
00:13:56,639 --> 00:13:59,120
proportional to the longest branch

391
00:13:59,120 --> 00:14:01,680
that means that if for example we have

392
00:14:01,680 --> 00:14:04,320
100 parallel branches and only one of

393
00:14:04,320 --> 00:14:06,320
them evaluates to zero

394
00:14:06,320 --> 00:14:07,680
then our proof

395
00:14:07,680 --> 00:14:10,320
would only need to communicate one

396
00:14:10,320 --> 00:14:12,639
of the 100 branches

397
00:14:12,639 --> 00:14:16,000
and we would save a factor of 100 in

398
00:14:16,000 --> 00:14:18,079
communication

399
00:14:18,079 --> 00:14:19,760
now the key observation that we make is

400
00:14:19,760 --> 00:14:22,000
that the provers messages

401
00:14:22,000 --> 00:14:24,639
that have to be sent in order to prove

402
00:14:24,639 --> 00:14:25,920
that one

403
00:14:25,920 --> 00:14:28,800
of the branches evaluates to zero well

404
00:14:28,800 --> 00:14:30,720
all of these are

405
00:14:30,720 --> 00:14:32,639
appearing to the verifier as random

406
00:14:32,639 --> 00:14:34,800
field elements right if you prove that

407
00:14:34,800 --> 00:14:37,600
the multiplication is uh is correct or

408
00:14:37,600 --> 00:14:40,079
if you commit to an additional value

409
00:14:40,079 --> 00:14:42,560
then all the verifier ever sees

410
00:14:42,560 --> 00:14:43,440
are

411
00:14:43,440 --> 00:14:44,399
random

412
00:14:44,399 --> 00:14:45,839
field elements

413
00:14:45,839 --> 00:14:47,040
so

414
00:14:47,040 --> 00:14:50,800
what we just do is that uh the verifier

415
00:14:50,800 --> 00:14:52,160
since uh

416
00:14:52,160 --> 00:14:53,920
it can't distinguish between the

417
00:14:53,920 --> 00:14:56,000
individual branches uh when messages

418
00:14:56,000 --> 00:14:56,959
come in

419
00:14:56,959 --> 00:14:59,680
well we only sent him messages

420
00:14:59,680 --> 00:15:01,440
that can be used

421
00:15:01,440 --> 00:15:02,639
to

422
00:15:02,639 --> 00:15:04,959
evaluate the true branch but since he

423
00:15:04,959 --> 00:15:06,240
doesn't know what these messages are

424
00:15:06,240 --> 00:15:08,959
there for it will just use the same

425
00:15:08,959 --> 00:15:10,959
messages for all the branches

426
00:15:10,959 --> 00:15:12,720
at the same time

427
00:15:12,720 --> 00:15:15,199
right so in our example if for example

428
00:15:15,199 --> 00:15:16,399
the first

429
00:15:16,399 --> 00:15:17,839
circuit was true

430
00:15:17,839 --> 00:15:19,680
uh we only send the messages for the

431
00:15:19,680 --> 00:15:22,079
first circuits but the verifier will

432
00:15:22,079 --> 00:15:24,480
also try to verify the second

433
00:15:24,480 --> 00:15:26,639
sub-circuit using this but it will never

434
00:15:26,639 --> 00:15:28,800
notice that it's just getting garbage

435
00:15:28,800 --> 00:15:30,639
there

436
00:15:30,639 --> 00:15:33,600
now in more detail uh how do we do

437
00:15:33,600 --> 00:15:35,519
disjunctive proofs in mac and cheese

438
00:15:35,519 --> 00:15:37,519
well let's assume we have m

439
00:15:37,519 --> 00:15:38,560
different

440
00:15:38,560 --> 00:15:40,560
clauses c1 to cm

441
00:15:40,560 --> 00:15:42,720
where there's a witness that makes at

442
00:15:42,720 --> 00:15:45,360
least one of them evaluate zero as

443
00:15:45,360 --> 00:15:47,440
mentioned the proof of sense messages uh

444
00:15:47,440 --> 00:15:49,759
for evaluating uh this one that divides

445
00:15:49,759 --> 00:15:51,920
to zero in this case that's called ci

446
00:15:51,920 --> 00:15:53,839
the verifier sends random challenges for

447
00:15:53,839 --> 00:15:56,959
all the branches as he did before

448
00:15:56,959 --> 00:15:57,759
um

449
00:15:57,759 --> 00:16:01,199
now both parties evaluate each branch uh

450
00:16:01,199 --> 00:16:02,399
locally

451
00:16:02,399 --> 00:16:04,800
um based on the random challenges uh

452
00:16:04,800 --> 00:16:07,680
from the verifier so this implicitly um

453
00:16:07,680 --> 00:16:10,480
defines uh the uh commitments to the

454
00:16:10,480 --> 00:16:13,040
outputs of all of the branches

455
00:16:13,040 --> 00:16:15,040
what one can prove is that uh all of

456
00:16:15,040 --> 00:16:17,440
these commitments uh

457
00:16:17,440 --> 00:16:20,560
if if the witness didn't make uh this

458
00:16:20,560 --> 00:16:24,320
branch to zero um then

459
00:16:24,320 --> 00:16:25,600
uh one would

460
00:16:25,600 --> 00:16:27,759
definitely get something else than zero

461
00:16:27,759 --> 00:16:30,399
even if one uh evaluates uh on garbage

462
00:16:30,399 --> 00:16:32,240
messages so the approver can't use this

463
00:16:32,240 --> 00:16:34,000
uh in order to

464
00:16:34,000 --> 00:16:37,199
cheat um in the process

465
00:16:37,199 --> 00:16:39,839
and then um so one of the

466
00:16:39,839 --> 00:16:41,279
one of these commitments must be zero

467
00:16:41,279 --> 00:16:43,600
the others are random but

468
00:16:43,600 --> 00:16:45,040
you know the approver can determine what

469
00:16:45,040 --> 00:16:46,880
they actually are and then the parties

470
00:16:46,880 --> 00:16:48,959
just use an or proof

471
00:16:48,959 --> 00:16:51,759
which shows that there exists

472
00:16:51,759 --> 00:16:53,040
one

473
00:16:53,040 --> 00:16:54,639
of these commitments that is actually

474
00:16:54,639 --> 00:16:55,519
zero

475
00:16:55,519 --> 00:16:57,839
and this is a standard technique uh used

476
00:16:57,839 --> 00:17:00,560
uh already by karma damn god and schwann

477
00:17:00,560 --> 00:17:03,360
marcus in 94 for sigma protocols which

478
00:17:03,360 --> 00:17:05,439
we adapt to commit and proof style

479
00:17:05,439 --> 00:17:07,199
systems

480
00:17:07,199 --> 00:17:08,160
now

481
00:17:08,160 --> 00:17:11,439
the overall communication of this is uh

482
00:17:11,439 --> 00:17:13,679
scaling in the length of the longest

483
00:17:13,679 --> 00:17:17,039
branch plus an additional

484
00:17:17,039 --> 00:17:18,160
o ofm

485
00:17:18,160 --> 00:17:20,319
field elementaries are necessary in

486
00:17:20,319 --> 00:17:22,640
order to perform the or proof

487
00:17:22,640 --> 00:17:26,000
and this improves uh by a factor of m

488
00:17:26,000 --> 00:17:27,599
actually over the naive approach

489
00:17:27,599 --> 00:17:28,720
ignoring the

490
00:17:28,720 --> 00:17:31,039
o of m for a second

491
00:17:31,039 --> 00:17:32,400
where for the naive approach we would

492
00:17:32,400 --> 00:17:34,640
have to prove all branches towards the

493
00:17:34,640 --> 00:17:37,200
verifier

494
00:17:37,200 --> 00:17:39,440
one can then also modify

495
00:17:39,440 --> 00:17:42,400
this approach to support

496
00:17:42,400 --> 00:17:44,400
statements where the approver tries to

497
00:17:44,400 --> 00:17:46,640
show that k out of the sub circuits

498
00:17:46,640 --> 00:17:49,280
evaluate to zero here one

499
00:17:49,280 --> 00:17:50,960
replaces the

500
00:17:50,960 --> 00:17:52,480
one out of m

501
00:17:52,480 --> 00:17:54,720
or proof with the threshold or proof of

502
00:17:54,720 --> 00:17:57,280
cds 94.

503
00:17:57,280 --> 00:17:58,880
again this improves the oval

504
00:17:58,880 --> 00:18:01,760
communication to a factor

505
00:18:01,760 --> 00:18:04,480
2k times the longest

506
00:18:04,480 --> 00:18:05,919
sub-circuit

507
00:18:05,919 --> 00:18:08,480
where the naive approach only com needs

508
00:18:08,480 --> 00:18:11,919
to communicate all of the sub-circuits

509
00:18:11,919 --> 00:18:14,160
and then we can also uh prove

510
00:18:14,160 --> 00:18:16,080
disjunctions inside this junction so we

511
00:18:16,080 --> 00:18:17,200
can nest

512
00:18:17,200 --> 00:18:19,280
um our uh

513
00:18:19,280 --> 00:18:21,200
this junction proofs into each other

514
00:18:21,200 --> 00:18:23,200
there can be multiple layers

515
00:18:23,200 --> 00:18:26,240
of these at the same time

516
00:18:26,240 --> 00:18:28,160
as mentioned in order to prove such a

517
00:18:28,160 --> 00:18:30,720
disjunction um we have to communicate

518
00:18:30,720 --> 00:18:33,679
something scales in the longest

519
00:18:33,679 --> 00:18:36,160
branch of this junction this seems to be

520
00:18:36,160 --> 00:18:38,480
unavoidable but additionally we have to

521
00:18:38,480 --> 00:18:39,919
communicate

522
00:18:39,919 --> 00:18:41,919
m field elements in order to do the or

523
00:18:41,919 --> 00:18:44,400
proof where m is the number of branches

524
00:18:44,400 --> 00:18:45,600
now let's see

525
00:18:45,600 --> 00:18:48,960
how one can reduce this overhead

526
00:18:48,960 --> 00:18:50,320
and in

527
00:18:50,320 --> 00:18:51,840
in order to understand what is going on

528
00:18:51,840 --> 00:18:53,919
there um let's say

529
00:18:53,919 --> 00:18:56,000
instead of doing an or proof we do an

530
00:18:56,000 --> 00:18:58,240
alternative proof where we show that the

531
00:18:58,240 --> 00:19:00,640
product of all the

532
00:19:00,640 --> 00:19:03,360
output commitments of the individual

533
00:19:03,360 --> 00:19:05,919
branches is actually zero

534
00:19:05,919 --> 00:19:10,400
now this is equivalent at least for um a

535
00:19:10,400 --> 00:19:12,510
simple disjunction to

536
00:19:12,510 --> 00:19:13,679
[Music]

537
00:19:13,679 --> 00:19:16,400
computing an or proof because only if at

538
00:19:16,400 --> 00:19:18,400
least one of these

539
00:19:18,400 --> 00:19:21,200
values y i is actually zero one will get

540
00:19:21,200 --> 00:19:24,480
to a value that is actually zero

541
00:19:24,480 --> 00:19:25,360
now

542
00:19:25,360 --> 00:19:27,039
why can this be

543
00:19:27,039 --> 00:19:29,440
done with less overhead well let's

544
00:19:29,440 --> 00:19:32,240
assume we have two branches

545
00:19:32,240 --> 00:19:33,600
where the first one is actually zero

546
00:19:33,600 --> 00:19:36,400
whereas the second one is some that's

547
00:19:36,400 --> 00:19:39,039
let's say random value um

548
00:19:39,039 --> 00:19:41,039
then uh now using just one

549
00:19:41,039 --> 00:19:42,799
multiplication we can do the or proof

550
00:19:42,799 --> 00:19:46,720
right we just multiply y1 with y2 and

551
00:19:46,720 --> 00:19:49,280
prove that this is actually zero now if

552
00:19:49,280 --> 00:19:50,640
we have uh

553
00:19:50,640 --> 00:19:53,360
more branches let's say y3 and y4

554
00:19:53,360 --> 00:19:54,640
and then

555
00:19:54,640 --> 00:19:58,080
we would now do the same thing

556
00:19:58,559 --> 00:19:59,440
but

557
00:19:59,440 --> 00:20:01,600
what one would observe is that

558
00:20:01,600 --> 00:20:03,200
combining y1 and y2 with a

559
00:20:03,200 --> 00:20:05,600
multiplication gate

560
00:20:05,600 --> 00:20:10,240
leads to a sub-circuit um and y3 and y4

561
00:20:10,240 --> 00:20:12,640
together with the multiplication gate is

562
00:20:12,640 --> 00:20:14,559
again a sub-circuit and we can

563
00:20:14,559 --> 00:20:16,240
recursively apply the technique from

564
00:20:16,240 --> 00:20:19,440
before meaning that we now

565
00:20:19,440 --> 00:20:21,360
take the output of the left

566
00:20:21,360 --> 00:20:23,440
multiplication gate

567
00:20:23,440 --> 00:20:24,799
use this

568
00:20:24,799 --> 00:20:26,640
you know in the simulation of the right

569
00:20:26,640 --> 00:20:28,000
branch

570
00:20:28,000 --> 00:20:28,880
and

571
00:20:28,880 --> 00:20:31,600
now do a multiplication proof on both of

572
00:20:31,600 --> 00:20:33,120
these branches

573
00:20:33,120 --> 00:20:36,000
and and again this will evaluate to zero

574
00:20:36,000 --> 00:20:38,159
if uh one of the two is actually zero

575
00:20:38,159 --> 00:20:39,679
and the cool thing is well we only had

576
00:20:39,679 --> 00:20:41,679
to communicate um

577
00:20:41,679 --> 00:20:42,640
um

578
00:20:42,640 --> 00:20:44,960
something for the true branches uh of

579
00:20:44,960 --> 00:20:47,200
this

580
00:20:47,200 --> 00:20:49,919
of the circuit whereas for the right uh

581
00:20:49,919 --> 00:20:52,080
top right uh multiplication gate we

582
00:20:52,080 --> 00:20:53,919
didn't actually have to send uh

583
00:20:53,919 --> 00:20:56,240
information and if one uh does the math

584
00:20:56,240 --> 00:20:57,039
then

585
00:20:57,039 --> 00:21:00,080
this means that one actually has to send

586
00:21:00,080 --> 00:21:02,080
something that scales logarithmically in

587
00:21:02,080 --> 00:21:04,640
the number of branches

588
00:21:04,640 --> 00:21:07,039
and instead of something that is linear

589
00:21:07,039 --> 00:21:10,000
in the number of branches

590
00:21:10,000 --> 00:21:11,919
as was mentioned in the introduction we

591
00:21:11,919 --> 00:21:13,919
implemented mac and cheese and now also

592
00:21:13,919 --> 00:21:16,960
want to report on the efficiency of our

593
00:21:16,960 --> 00:21:18,559
proof system

594
00:21:18,559 --> 00:21:20,080
mac and cheese

595
00:21:20,080 --> 00:21:22,080
has been implemented in

596
00:21:22,080 --> 00:21:23,360
rust by us

597
00:21:23,360 --> 00:21:25,360
both the offline meaning the vector or

598
00:21:25,360 --> 00:21:27,280
lead generation as well as the online

599
00:21:27,280 --> 00:21:28,960
phase in non-interactive fashion using

600
00:21:28,960 --> 00:21:31,200
the vhmr transform

601
00:21:31,200 --> 00:21:32,880
it's implemented based on the swanky

602
00:21:32,880 --> 00:21:36,240
secure computation framework by galwa

603
00:21:36,240 --> 00:21:37,280
and

604
00:21:37,280 --> 00:21:39,039
we plan to open source it as soon as

605
00:21:39,039 --> 00:21:41,360
possible although some things are

606
00:21:41,360 --> 00:21:45,520
currently being re-implemented

607
00:21:45,520 --> 00:21:47,440
our mac and cheese implementation

608
00:21:47,440 --> 00:21:50,080
supports input from the zk interface

609
00:21:50,080 --> 00:21:51,760
project

610
00:21:51,760 --> 00:21:56,240
we can support various fields such as f

611
00:21:56,240 --> 00:21:58,400
2 to the minus 1

612
00:21:58,400 --> 00:22:01,360
or also proofs that are just over f2

613
00:22:01,360 --> 00:22:02,159
and

614
00:22:02,159 --> 00:22:03,840
our optimizations mean as the

615
00:22:03,840 --> 00:22:06,159
disjunctions are

616
00:22:06,159 --> 00:22:08,240
used in our mac and cheese

617
00:22:08,240 --> 00:22:10,640
implementation and we also have these

618
00:22:10,640 --> 00:22:12,320
optimized multiplications which only

619
00:22:12,320 --> 00:22:14,240
communicate approximately one field

620
00:22:14,240 --> 00:22:16,880
element per multiplication

621
00:22:16,880 --> 00:22:19,120
we benchmarked the performance of our

622
00:22:19,120 --> 00:22:21,360
implementation in a setting where proven

623
00:22:21,360 --> 00:22:23,200
verifier connected

624
00:22:23,200 --> 00:22:24,559
over a

625
00:22:24,559 --> 00:22:26,880
network with 95 millisecond ping and

626
00:22:26,880 --> 00:22:29,679
2.25 megabytes per second of bandwidth

627
00:22:29,679 --> 00:22:31,679
our benchmarks include the runtimes

628
00:22:31,679 --> 00:22:33,280
necessary to pre-compute the vector

629
00:22:33,280 --> 00:22:34,720
onlys

630
00:22:34,720 --> 00:22:37,120
and in this setting uh mac and cheese

631
00:22:37,120 --> 00:22:40,559
requires 1.5 microseconds to prove

632
00:22:40,559 --> 00:22:42,960
one multiplication gate in f2 to the

633
00:22:42,960 --> 00:22:45,039
61-1

634
00:22:45,039 --> 00:22:48,320
or 140 nanoseconds in order to prove one

635
00:22:48,320 --> 00:22:49,919
multiplication in the

636
00:22:49,919 --> 00:22:51,120
circuit

637
00:22:51,120 --> 00:22:53,679
in a circuit over f2

638
00:22:53,679 --> 00:22:55,520
and both of these are

639
00:22:55,520 --> 00:22:57,120
in the setting where we use our

640
00:22:57,120 --> 00:22:58,880
amortization technique

641
00:22:58,880 --> 00:23:01,039
and that only communicates approximately

642
00:23:01,039 --> 00:23:01,760
one

643
00:23:01,760 --> 00:23:04,159
field element per multiplication

644
00:23:04,159 --> 00:23:05,520
to show that our

645
00:23:05,520 --> 00:23:07,679
improvement for this junction

646
00:23:07,679 --> 00:23:10,080
is actually visible in terms of

647
00:23:10,080 --> 00:23:11,919
communication

648
00:23:11,919 --> 00:23:14,080
if we have multiple branches each of

649
00:23:14,080 --> 00:23:15,360
which are

650
00:23:15,360 --> 00:23:17,520
of one billion and gates then we can see

651
00:23:17,520 --> 00:23:19,760
that in order to prove eight of these

652
00:23:19,760 --> 00:23:22,480
branches we only have to send 75 bytes

653
00:23:22,480 --> 00:23:24,640
more than when we want to proof only one

654
00:23:24,640 --> 00:23:26,559
of these branches

655
00:23:26,559 --> 00:23:28,080
at the same time

656
00:23:28,080 --> 00:23:29,679
the proof

657
00:23:29,679 --> 00:23:32,240
run time still increases

658
00:23:32,240 --> 00:23:33,840
because the proof and the verifier have

659
00:23:33,840 --> 00:23:34,840
to

660
00:23:34,840 --> 00:23:37,919
evaluate i still have to evaluate all of

661
00:23:37,919 --> 00:23:39,919
the branches locally but we get this

662
00:23:39,919 --> 00:23:42,799
improvement in terms of communication

663
00:23:42,799 --> 00:23:44,880
now with all of this let's put mac and

664
00:23:44,880 --> 00:23:46,559
cheese into perspective with respect to

665
00:23:46,559 --> 00:23:48,960
other works that do

666
00:23:48,960 --> 00:23:52,080
large-scale scale zero knowledge proofs

667
00:23:52,080 --> 00:23:53,840
stack gobbling has been introduced by

668
00:23:53,840 --> 00:23:56,159
heath and kalashnikov and uses

669
00:23:56,159 --> 00:23:59,520
goblet circuits in order to prove

670
00:23:59,520 --> 00:24:00,960
statements about

671
00:24:00,960 --> 00:24:02,559
circuits over f2

672
00:24:02,559 --> 00:24:04,080
here we can see that mac and cheese

673
00:24:04,080 --> 00:24:09,039
actually uh communicates a lot less per

674
00:24:09,039 --> 00:24:10,880
per and gate

675
00:24:10,880 --> 00:24:12,480
while um

676
00:24:12,480 --> 00:24:14,799
we also uh well they also have this

677
00:24:14,799 --> 00:24:16,960
junction such as we have

678
00:24:16,960 --> 00:24:18,799
wolverine can

679
00:24:18,799 --> 00:24:20,559
possibly also be extended to support

680
00:24:20,559 --> 00:24:22,480
disjunctions and the

681
00:24:22,480 --> 00:24:24,080
performance of wolverine is actually

682
00:24:24,080 --> 00:24:25,679
comparable

683
00:24:25,679 --> 00:24:27,120
in terms of communication and round

684
00:24:27,120 --> 00:24:29,600
complexity to our simple mac and cheese

685
00:24:29,600 --> 00:24:32,159
protocol means without the amortized

686
00:24:32,159 --> 00:24:33,600
proofs

687
00:24:33,600 --> 00:24:36,000
line point ck introduced by ditmer at

688
00:24:36,000 --> 00:24:36,720
all

689
00:24:36,720 --> 00:24:41,760
um has a comparable uh efficiency to our

690
00:24:41,760 --> 00:24:42,720
batched

691
00:24:42,720 --> 00:24:45,679
mac and cheese approach in terms of

692
00:24:45,679 --> 00:24:48,080
in terms of communication

693
00:24:48,080 --> 00:24:49,919
over over large fields

694
00:24:49,919 --> 00:24:52,159
and line points your knowledge has been

695
00:24:52,159 --> 00:24:54,320
further developed in the quicksilver

696
00:24:54,320 --> 00:24:56,320
protocol

697
00:24:56,320 --> 00:24:57,120
which

698
00:24:57,120 --> 00:24:59,120
has a similar which has a comparable

699
00:24:59,120 --> 00:25:01,919
performance to ours um so they get rid

700
00:25:01,919 --> 00:25:05,360
of the epsilon vector that we have

701
00:25:05,360 --> 00:25:08,559
and have uh twice as much uh throughput

702
00:25:08,559 --> 00:25:10,080
in terms of multiplication million

703
00:25:10,080 --> 00:25:12,000
multiplications per second and what we

704
00:25:12,000 --> 00:25:13,840
do but to the best of our knowledge

705
00:25:13,840 --> 00:25:15,600
quicksilver

706
00:25:15,600 --> 00:25:16,400
can

707
00:25:16,400 --> 00:25:18,400
at least not simply be extended to also

708
00:25:18,400 --> 00:25:19,760
support

709
00:25:19,760 --> 00:25:21,600
these nested disjunctions that mac and

710
00:25:21,600 --> 00:25:24,399
cheese actually has

711
00:25:24,720 --> 00:25:27,520
in summary uh mac and cheese is a

712
00:25:27,520 --> 00:25:29,200
designated verifier zine large proof

713
00:25:29,200 --> 00:25:31,679
system that is particularly suitable for

714
00:25:31,679 --> 00:25:33,120
large scale

715
00:25:33,120 --> 00:25:34,880
zero knowledge so geologically large

716
00:25:34,880 --> 00:25:35,919
circuits

717
00:25:35,919 --> 00:25:38,000
we use uh vector overleas in order to

718
00:25:38,000 --> 00:25:40,480
instantiate information theoretic max

719
00:25:40,480 --> 00:25:42,159
and get a commit and proof style

720
00:25:42,159 --> 00:25:44,480
protocol

721
00:25:44,480 --> 00:25:46,159
essentially most of the communication

722
00:25:46,159 --> 00:25:47,360
only flows from the approver to the

723
00:25:47,360 --> 00:25:49,840
verifier so we

724
00:25:49,840 --> 00:25:52,159
get two constant rounds using the fiat

725
00:25:52,159 --> 00:25:53,679
smear transform

726
00:25:53,679 --> 00:25:56,080
and we can optimize

727
00:25:56,080 --> 00:25:58,159
disjunctions in order to reduce

728
00:25:58,159 --> 00:25:59,679
communication unfortunately not

729
00:25:59,679 --> 00:26:01,440
computation

730
00:26:01,440 --> 00:26:03,520
our communication is approximately one

731
00:26:03,520 --> 00:26:06,480
field element per multiplication gate

732
00:26:06,480 --> 00:26:08,240
for any field

733
00:26:08,240 --> 00:26:10,720
and as mentioned we have a highly

734
00:26:10,720 --> 00:26:12,559
efficient implementation

735
00:26:12,559 --> 00:26:15,200
uh that is as efficient as the state of

736
00:26:15,200 --> 00:26:16,320
the art

737
00:26:16,320 --> 00:26:17,200
um

738
00:26:17,200 --> 00:26:19,200
if you want to learn more

739
00:26:19,200 --> 00:26:22,080
i'd like to refer you to the paper or if

740
00:26:22,080 --> 00:26:23,520
you have questions

741
00:26:23,520 --> 00:26:26,320
feel free to either contact us during

742
00:26:26,320 --> 00:26:27,360
the

743
00:26:27,360 --> 00:26:29,840
online talk at crypto or

744
00:26:29,840 --> 00:26:31,919
by email and with this i'd like to thank

745
00:26:31,919 --> 00:26:35,400
you for your attention

