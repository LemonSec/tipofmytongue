1
00:00:00,719 --> 00:00:03,120
hi i'm q lee of seoul national

2
00:00:03,120 --> 00:00:05,920
university in korea in this video i will

3
00:00:05,920 --> 00:00:08,639
present megahertz 2k a new multi-party

4
00:00:08,639 --> 00:00:10,960
computation protocol from homomorph

5
00:00:10,960 --> 00:00:13,679
encryption over rings at 2k

6
00:00:13,679 --> 00:00:15,679
this is a joint work with my advisor

7
00:00:15,679 --> 00:00:18,000
johnny chan and dr don kim of western

8
00:00:18,000 --> 00:00:20,480
digital

9
00:00:20,560 --> 00:00:23,119
our mpc protocol belongs to so called

10
00:00:23,119 --> 00:00:25,439
speeds family which follows the approach

11
00:00:25,439 --> 00:00:27,599
of speeds protocol presented at crypto

12
00:00:27,599 --> 00:00:29,279
2012.

13
00:00:29,279 --> 00:00:32,000
all these protocols aim a general mpc

14
00:00:32,000 --> 00:00:34,160
protocol which is secure against

15
00:00:34,160 --> 00:00:36,559
actively corrupted majority

16
00:00:36,559 --> 00:00:38,960
by active security we mean that

17
00:00:38,960 --> 00:00:41,200
adversaries may freely deviate from the

18
00:00:41,200 --> 00:00:43,840
described protocol opposed to honest but

19
00:00:43,840 --> 00:00:45,520
curious model

20
00:00:45,520 --> 00:00:47,520
by dishonest majority we mean that all

21
00:00:47,520 --> 00:00:50,960
parties except one may be corrupted

22
00:00:50,960 --> 00:00:53,360
among various settings of npc it is one

23
00:00:53,360 --> 00:00:55,520
of the most important setting

24
00:00:55,520 --> 00:00:57,520
modeling the security thread as honest

25
00:00:57,520 --> 00:00:59,680
but curious adversaries is often

26
00:00:59,680 --> 00:01:02,960
unsatisfactory in real life applications

27
00:01:02,960 --> 00:01:04,640
and in the case of secret two-party

28
00:01:04,640 --> 00:01:07,200
computation corrupted majority is the

29
00:01:07,200 --> 00:01:09,200
only meaningful goal

30
00:01:09,200 --> 00:01:11,920
however it was notoriously difficult to

31
00:01:11,920 --> 00:01:14,240
handle actively corrupted majority

32
00:01:14,240 --> 00:01:16,960
efficiently

33
00:01:17,360 --> 00:01:20,080
before speeds bedoza first observed that

34
00:01:20,080 --> 00:01:22,320
one can push the use of heavy public key

35
00:01:22,320 --> 00:01:24,720
machinery into a pre-processing phase

36
00:01:24,720 --> 00:01:26,320
without knowing input values and

37
00:01:26,320 --> 00:01:28,080
functions to compute

38
00:01:28,080 --> 00:01:30,799
meanwhile in an online phase one can

39
00:01:30,799 --> 00:01:33,119
securely compute a function using only

40
00:01:33,119 --> 00:01:34,799
lightweight primitives

41
00:01:34,799 --> 00:01:37,200
this paradigm so-called pre-processing

42
00:01:37,200 --> 00:01:39,920
model spotlighted the possibility of

43
00:01:39,920 --> 00:01:42,560
designing an efficient mpc protocol even

44
00:01:42,560 --> 00:01:45,200
in the actively security sinus maturity

45
00:01:45,200 --> 00:01:47,520
setting

46
00:01:47,520 --> 00:01:49,360
in more details the goal of

47
00:01:49,360 --> 00:01:51,360
pre-processing phase is the generation

48
00:01:51,360 --> 00:01:54,000
of so-called beavers triple or simply

49
00:01:54,000 --> 00:01:56,399
triple generation

50
00:01:56,399 --> 00:01:58,560
that is parties jointly and secretly

51
00:01:58,560 --> 00:02:00,000
generate

52
00:02:00,000 --> 00:02:02,560
random additive secret shares of a b and

53
00:02:02,560 --> 00:02:06,960
c satisfying a times b equals c

54
00:02:06,960 --> 00:02:10,080
then in online phase parties can perform

55
00:02:10,080 --> 00:02:12,000
secret computation using the famous

56
00:02:12,000 --> 00:02:14,480
bieber's trick where beaver's triple is

57
00:02:14,480 --> 00:02:17,680
consumed at each multiplication gate

58
00:02:17,680 --> 00:02:19,680
however this is not sufficient for our

59
00:02:19,680 --> 00:02:21,599
malicious setting since adversaries

60
00:02:21,599 --> 00:02:23,840
might deviate from described protocols

61
00:02:23,840 --> 00:02:25,840
in online phase

62
00:02:25,840 --> 00:02:28,319
so in speeds like protocols mac is used

63
00:02:28,319 --> 00:02:30,640
to authenticate the computations

64
00:02:30,640 --> 00:02:32,720
in particular we use an information

65
00:02:32,720 --> 00:02:35,120
theoretically secure mac simply

66
00:02:35,120 --> 00:02:37,360
multiplying a global mackie alpha to

67
00:02:37,360 --> 00:02:41,680
input which satisfies linearity

68
00:02:42,239 --> 00:02:44,239
accordingly the goal of pre-processing

69
00:02:44,239 --> 00:02:46,480
phase is changed to authenticated triple

70
00:02:46,480 --> 00:02:47,920
generation

71
00:02:47,920 --> 00:02:50,080
namely parties additionally generate

72
00:02:50,080 --> 00:02:52,959
random additive shares of alpha a alpha

73
00:02:52,959 --> 00:02:56,640
b and alpha c using obfuscated mac key

74
00:02:56,640 --> 00:02:58,720
we remark that no one knows the value of

75
00:02:58,720 --> 00:03:00,720
alpha since it is generated in a

76
00:03:00,720 --> 00:03:02,480
distributed way

77
00:03:02,480 --> 00:03:04,400
the online phase essentially stays the

78
00:03:04,400 --> 00:03:07,840
same by the linearity of our mac

79
00:03:07,840 --> 00:03:10,159
after speeds there were active and

80
00:03:10,159 --> 00:03:12,959
steady developments in this area

81
00:03:12,959 --> 00:03:15,120
except betosa all these works share the

82
00:03:15,120 --> 00:03:16,879
same online phase

83
00:03:16,879 --> 00:03:18,640
the distinctive features are in the

84
00:03:18,640 --> 00:03:22,080
designs of pre-processing phase

85
00:03:22,080 --> 00:03:24,239
these works can be classified by main

86
00:03:24,239 --> 00:03:26,720
technical tools they are using namely

87
00:03:26,720 --> 00:03:29,440
somatomorphy encryption linear morph

88
00:03:29,440 --> 00:03:32,640
encryption and oblivious transfer

89
00:03:32,640 --> 00:03:35,599
there were some back and forth but

90
00:03:35,599 --> 00:03:38,159
overdrive with top key optimization on

91
00:03:38,159 --> 00:03:40,319
it is now considered to be the state of

92
00:03:40,319 --> 00:03:42,799
the art which leverage high parallelism

93
00:03:42,799 --> 00:03:46,720
of lattice-based morphe encryption

94
00:03:46,720 --> 00:03:48,879
meanwhile all the works i have mentioned

95
00:03:48,879 --> 00:03:51,920
are mpc protocols over finite fields

96
00:03:51,920 --> 00:03:53,439
the main reason that they were not

97
00:03:53,439 --> 00:03:55,680
extended to more general rings such as

98
00:03:55,680 --> 00:03:58,560
z2k is that the security of mac we are

99
00:03:58,560 --> 00:04:00,480
using is somehow related to

100
00:04:00,480 --> 00:04:02,159
invertibility

101
00:04:02,159 --> 00:04:04,239
that is it is hard to translate the

102
00:04:04,239 --> 00:04:06,640
online phase of speeds to the rings at

103
00:04:06,640 --> 00:04:09,360
2k where non-invertible elements are

104
00:04:09,360 --> 00:04:11,120
majority

105
00:04:11,120 --> 00:04:14,000
surprisingly speeds to k presented in

106
00:04:14,000 --> 00:04:17,759
crypto 2018 extended the mac to also

107
00:04:17,759 --> 00:04:21,040
work over 72k case and initiated the

108
00:04:21,040 --> 00:04:23,040
research on speed light protocol over

109
00:04:23,040 --> 00:04:24,639
z2k

110
00:04:24,639 --> 00:04:26,639
according to the authors this is not

111
00:04:26,639 --> 00:04:29,280
only theoretically interesting but also

112
00:04:29,280 --> 00:04:32,800
have implications in practice

113
00:04:32,800 --> 00:04:34,960
note that integer arithmetic in modern

114
00:04:34,960 --> 00:04:37,840
cpus are down modulo 2 to the k say 2 to

115
00:04:37,840 --> 00:04:39,199
the 64.

116
00:04:39,199 --> 00:04:42,400
if we use mpc over it set p we first

117
00:04:42,400 --> 00:04:44,479
need to compile our code into that p

118
00:04:44,479 --> 00:04:45,759
arithmetic

119
00:04:45,759 --> 00:04:48,240
and that p arithmetic in npc online

120
00:04:48,240 --> 00:04:51,520
phase needs to be again emulated by z2k

121
00:04:51,520 --> 00:04:53,759
arithmetic for executions

122
00:04:53,759 --> 00:04:55,199
these cause

123
00:04:55,199 --> 00:04:57,840
double overheads for emulations

124
00:04:57,840 --> 00:05:00,000
on the other hand if we use mpc over

125
00:05:00,000 --> 00:05:02,320
that 2k we can naturally compile without

126
00:05:02,320 --> 00:05:04,400
overheads

127
00:05:04,400 --> 00:05:06,560
meanwhile there are also limitations

128
00:05:06,560 --> 00:05:08,479
that this approach requires a less

129
00:05:08,479 --> 00:05:11,440
efficient mag namely speeds to kmac

130
00:05:11,440 --> 00:05:14,240
however a follow-up work reported that

131
00:05:14,240 --> 00:05:16,560
in serious applications such as decision

132
00:05:16,560 --> 00:05:18,800
tree and support vector machine

133
00:05:18,800 --> 00:05:21,680
mpc over the 2k shows up to 5 times

134
00:05:21,680 --> 00:05:24,080
improvement in online phase compared to

135
00:05:24,080 --> 00:05:26,240
npc or finite fields

136
00:05:26,240 --> 00:05:28,880
however a disclaimer here is that this

137
00:05:28,880 --> 00:05:31,199
does not mean an absolute advantage

138
00:05:31,199 --> 00:05:33,199
since for the pre-processing phase there

139
00:05:33,199 --> 00:05:35,280
are still a substantial gap between set

140
00:05:35,280 --> 00:05:37,520
p and z2ks

141
00:05:37,520 --> 00:05:39,520
actually the goal of our work is to

142
00:05:39,520 --> 00:05:41,919
reduce such gap

143
00:05:41,919 --> 00:05:44,880
however as you can see speeds to k is an

144
00:05:44,880 --> 00:05:47,600
ot-based protocol the authors left an

145
00:05:47,600 --> 00:05:50,080
open problem to construct an he-based

146
00:05:50,080 --> 00:05:52,960
mpc protocol versus 2k since the

147
00:05:52,960 --> 00:05:54,800
he-based approach showed the best

148
00:05:54,800 --> 00:05:58,000
performance in set pks

149
00:05:58,000 --> 00:05:59,919
the complication here is that achieving

150
00:05:59,919 --> 00:06:02,800
high parallelism in lattice-based he is

151
00:06:02,800 --> 00:06:05,680
very nontrivial in set 2k case opposed

152
00:06:05,680 --> 00:06:08,319
to zpks

153
00:06:08,319 --> 00:06:10,479
there are two follow-up works aiming to

154
00:06:10,479 --> 00:06:12,319
improve the pre-processing phase of

155
00:06:12,319 --> 00:06:16,880
speeds 2k namely overdrive 2k and manza

156
00:06:16,880 --> 00:06:19,759
especially overdrive 2k partially solved

157
00:06:19,759 --> 00:06:22,240
the open problem of speeds to k by

158
00:06:22,240 --> 00:06:24,720
proposing a new packing method for z2k

159
00:06:24,720 --> 00:06:26,400
messages

160
00:06:26,400 --> 00:06:28,800
interestingly the authors of overdrive

161
00:06:28,800 --> 00:06:31,280
2k left another open problem to bring

162
00:06:31,280 --> 00:06:33,919
the top gear optimization into 2k

163
00:06:33,919 --> 00:06:36,319
framework as they could not employ top

164
00:06:36,319 --> 00:06:38,319
gear the state-of-the-art technique of

165
00:06:38,319 --> 00:06:40,800
zp

166
00:06:40,880 --> 00:06:43,199
and this is where our work belongs we

167
00:06:43,199 --> 00:06:45,440
follow the sag based approach to

168
00:06:45,440 --> 00:06:48,479
construct an npc protocol over z2k

169
00:06:48,479 --> 00:06:50,080
secure against

170
00:06:50,080 --> 00:06:52,800
actively corrupted majority

171
00:06:52,800 --> 00:06:55,360
we solved the open problem of speeds 2k

172
00:06:55,360 --> 00:06:57,440
by designing an efficient packing method

173
00:06:57,440 --> 00:07:00,400
for z2k messages and also the open

174
00:07:00,400 --> 00:07:02,880
problem of overdrive 2k by proving

175
00:07:02,880 --> 00:07:04,720
mathematical lemmas to allow top gear

176
00:07:04,720 --> 00:07:07,919
optimization also in depth 2k case

177
00:07:07,919 --> 00:07:10,400
as overdrive 2k is the most comparative

178
00:07:10,400 --> 00:07:12,800
work we will continuously compare our

179
00:07:12,800 --> 00:07:15,759
work with overdrive to

180
00:07:15,759 --> 00:07:18,080
in this slide i will briefly review the

181
00:07:18,080 --> 00:07:20,080
she-based authenticated triple

182
00:07:20,080 --> 00:07:21,199
generation

183
00:07:21,199 --> 00:07:23,280
recall that the goal is to securely

184
00:07:23,280 --> 00:07:25,680
generate fears of a

185
00:07:25,680 --> 00:07:26,800
b

186
00:07:26,800 --> 00:07:30,560
and c satisfying a times b equals c

187
00:07:30,560 --> 00:07:32,400
in addition to that we have to generate

188
00:07:32,400 --> 00:07:36,319
shares of alpha a alpha b and alpha c

189
00:07:36,319 --> 00:07:38,080
where alpha

190
00:07:38,080 --> 00:07:41,599
is a global mac key

191
00:07:41,680 --> 00:07:43,599
the protocol starts by each party

192
00:07:43,599 --> 00:07:46,319
choosing random values a i and bi

193
00:07:46,319 --> 00:07:49,440
reversely the shared values a and b are

194
00:07:49,440 --> 00:07:52,000
defined by these additive shares

195
00:07:52,000 --> 00:07:54,560
then each party encrypts these shares

196
00:07:54,560 --> 00:07:57,360
and broadcast them with so called zkp of

197
00:07:57,360 --> 00:07:59,280
plain text knowledge

198
00:07:59,280 --> 00:08:01,440
which guarantees that they have honestly

199
00:08:01,440 --> 00:08:04,639
generated the ciphertext

200
00:08:04,639 --> 00:08:06,240
then they add the ciphertext to

201
00:08:06,240 --> 00:08:09,360
reconstruct a and b in encrypted form

202
00:08:09,360 --> 00:08:11,599
to generate shares of alpha a they

203
00:08:11,599 --> 00:08:14,400
multiply encryption of a with previously

204
00:08:14,400 --> 00:08:17,280
generated encryption of mecha alpha

205
00:08:17,280 --> 00:08:20,080
then they perform so-called distributed

206
00:08:20,080 --> 00:08:22,720
decryption to share alpha a

207
00:08:22,720 --> 00:08:26,400
you can do similarly for alpha b

208
00:08:26,400 --> 00:08:28,639
to generate shares of c

209
00:08:28,639 --> 00:08:31,120
and alpha c we first homomorphically

210
00:08:31,120 --> 00:08:33,599
multiply the ciphertext

211
00:08:33,599 --> 00:08:36,000
indeed to generate shares of alpha c we

212
00:08:36,000 --> 00:08:37,760
can again homomorphically multiply

213
00:08:37,760 --> 00:08:39,919
encryption of alpha and perform

214
00:08:39,919 --> 00:08:42,399
distributed decryption

215
00:08:42,399 --> 00:08:44,959
however this method is not favorable

216
00:08:44,959 --> 00:08:47,200
since this requires sag scheme of

217
00:08:47,200 --> 00:08:49,760
multiplicative depth too as we are

218
00:08:49,760 --> 00:08:51,680
homomorphically multiplying two times

219
00:08:51,680 --> 00:08:53,519
consecutively

220
00:08:53,519 --> 00:08:56,560
this increases parameters of she and

221
00:08:56,560 --> 00:09:00,000
affects the efficiency

222
00:09:00,480 --> 00:09:02,640
so the standard method here is so-called

223
00:09:02,640 --> 00:09:05,200
reshare protocol roughly speaking the

224
00:09:05,200 --> 00:09:08,000
reshare protocol securely re-encrypts a

225
00:09:08,000 --> 00:09:10,560
level zero he ciphertext which does not

226
00:09:10,560 --> 00:09:12,800
allow any more multiplications into a

227
00:09:12,800 --> 00:09:14,560
fresh ciphertext

228
00:09:14,560 --> 00:09:17,120
the reshare protocol allows sag scheme

229
00:09:17,120 --> 00:09:19,200
with multiplicative depth 1 to be

230
00:09:19,200 --> 00:09:21,360
sufficient for our case

231
00:09:21,360 --> 00:09:24,000
then we can just proceed just like alpha

232
00:09:24,000 --> 00:09:26,800
a and alpha b

233
00:09:26,800 --> 00:09:28,480
we remarked that the messages are

234
00:09:28,480 --> 00:09:30,959
actually vectors by parallelism offered

235
00:09:30,959 --> 00:09:32,959
by packing methods of

236
00:09:32,959 --> 00:09:35,279
lattice-based hg schemes

237
00:09:35,279 --> 00:09:37,279
so to sum up

238
00:09:37,279 --> 00:09:38,640
the main building blocks of

239
00:09:38,640 --> 00:09:40,480
authenticated triple generation and

240
00:09:40,480 --> 00:09:42,640
their rules are first

241
00:09:42,640 --> 00:09:45,519
a packing method enhances amortized

242
00:09:45,519 --> 00:09:46,880
performance

243
00:09:46,880 --> 00:09:47,920
second

244
00:09:47,920 --> 00:09:50,000
reshare protocol allows us to keep down

245
00:09:50,000 --> 00:09:51,920
the sag parameters

246
00:09:51,920 --> 00:09:54,480
and third that kpopk which is the

247
00:09:54,480 --> 00:09:56,320
heaviest part guarantees that the

248
00:09:56,320 --> 00:09:58,320
parties honestly generated the

249
00:09:58,320 --> 00:10:00,240
ciphertext

250
00:10:00,240 --> 00:10:02,800
as the title of our paper suggests our

251
00:10:02,800 --> 00:10:05,680
protocol megahertz 2k is a combination

252
00:10:05,680 --> 00:10:07,600
of improvements in all these three

253
00:10:07,600 --> 00:10:09,600
building blocks

254
00:10:09,600 --> 00:10:11,519
finally we are ready to get into our

255
00:10:11,519 --> 00:10:15,079
technical contributions

256
00:10:18,959 --> 00:10:21,360
in this section we are interested in he

257
00:10:21,360 --> 00:10:22,880
packing methods

258
00:10:22,880 --> 00:10:25,200
by packing we mean methods for embedding

259
00:10:25,200 --> 00:10:27,360
several copies of messages into a single

260
00:10:27,360 --> 00:10:29,519
plain text while providing a certain

261
00:10:29,519 --> 00:10:31,600
degree of homomorphism

262
00:10:31,600 --> 00:10:33,600
in our work we consider packing for

263
00:10:33,600 --> 00:10:35,760
copies of reading of integers modulus on

264
00:10:35,760 --> 00:10:37,360
t

265
00:10:37,360 --> 00:10:39,440
packing enhances amortized performance

266
00:10:39,440 --> 00:10:42,160
by allowing cmd-like optimizations and

267
00:10:42,160 --> 00:10:44,880
it is essential for practical use of he

268
00:10:44,880 --> 00:10:47,120
as this complicated plain text space

269
00:10:47,120 --> 00:10:49,600
defined by lattice-based hg schemes is

270
00:10:49,600 --> 00:10:51,680
usually not the space we want to compute

271
00:10:51,680 --> 00:10:53,200
in

272
00:10:53,200 --> 00:10:55,120
packing plays an important role in

273
00:10:55,120 --> 00:10:58,320
speeds like he-based npc protocols since

274
00:10:58,320 --> 00:11:00,399
the efficiency of packing methods which

275
00:11:00,399 --> 00:11:03,040
is measured by how densely the messages

276
00:11:03,040 --> 00:11:06,079
are packed into a plain text directly

277
00:11:06,079 --> 00:11:08,000
affects the throughput of triple

278
00:11:08,000 --> 00:11:10,640
generations

279
00:11:10,640 --> 00:11:12,720
first i will review the conventional

280
00:11:12,720 --> 00:11:15,839
packing method for prime field messages

281
00:11:15,839 --> 00:11:18,560
the idea is to choose parameters so that

282
00:11:18,560 --> 00:11:21,279
the cyclotomy polynomial fully splits

283
00:11:21,279 --> 00:11:22,640
modulo p

284
00:11:22,640 --> 00:11:25,279
then we can apply crt ring isomorphisms

285
00:11:25,279 --> 00:11:28,399
to pack several zp messages into a plain

286
00:11:28,399 --> 00:11:29,279
text

287
00:11:29,279 --> 00:11:33,279
in that px quotiented by a cycloatomic

288
00:11:33,279 --> 00:11:35,519
polynomial

289
00:11:35,519 --> 00:11:37,519
note that since this packing method is

290
00:11:37,519 --> 00:11:40,079
defined by an isomorphism it offers

291
00:11:40,079 --> 00:11:42,079
fully homomorphic correspondence between

292
00:11:42,079 --> 00:11:43,920
messages and plain text

293
00:11:43,920 --> 00:11:45,920
and packing structure is maintained

294
00:11:45,920 --> 00:11:48,320
after the homomorphic operations

295
00:11:48,320 --> 00:11:50,320
also it offers the perfect packing

296
00:11:50,320 --> 00:11:52,320
density

297
00:11:52,320 --> 00:11:54,480
however we cannot use the conventional

298
00:11:54,480 --> 00:11:57,360
packing method for z2k messages since

299
00:11:57,360 --> 00:11:59,600
zyklotonic polynomial never fully splits

300
00:11:59,600 --> 00:12:01,760
module 2 to the k

301
00:12:01,760 --> 00:12:04,240
meanwhile it is known that it vectorizes

302
00:12:04,240 --> 00:12:07,120
into polynomials of same degree d

303
00:12:07,120 --> 00:12:09,600
in this case one way to pack z2k

304
00:12:09,600 --> 00:12:12,160
messages is to again leverage crt

305
00:12:12,160 --> 00:12:14,480
isomorphism but use only constant

306
00:12:14,480 --> 00:12:16,720
coefficients and put zero in the other

307
00:12:16,720 --> 00:12:18,959
equations

308
00:12:18,959 --> 00:12:20,959
in this way we can still enjoy fully

309
00:12:20,959 --> 00:12:22,959
homomorphic correspondence and level

310
00:12:22,959 --> 00:12:24,480
consistency

311
00:12:24,480 --> 00:12:26,800
this method was often used by helip and

312
00:12:26,800 --> 00:12:29,600
heli-based applications

313
00:12:29,600 --> 00:12:32,399
however using this method the packing

314
00:12:32,399 --> 00:12:36,000
density goes too low namely 1 over d

315
00:12:36,000 --> 00:12:39,279
as we can use only d over 10 due to

316
00:12:39,279 --> 00:12:41,680
security reasons using this method in

317
00:12:41,680 --> 00:12:44,240
our case causes over 10 times overhead

318
00:12:44,240 --> 00:12:47,440
for npc over debt to k messages compared

319
00:12:47,440 --> 00:12:48,560
to

320
00:12:48,560 --> 00:12:50,560
prime field case

321
00:12:50,560 --> 00:12:52,959
overdrive 2k aims to improve the packing

322
00:12:52,959 --> 00:12:55,440
density of helipacking by an observation

323
00:12:55,440 --> 00:12:57,440
that a somatomorphic correspondence up

324
00:12:57,440 --> 00:13:00,240
to one multiplication is enough for npc

325
00:13:00,240 --> 00:13:02,320
preprocessing

326
00:13:02,320 --> 00:13:04,560
the idea is to use coefficients as much

327
00:13:04,560 --> 00:13:07,680
as possible but avoiding interference

328
00:13:07,680 --> 00:13:10,079
for example if we pack messages into

329
00:13:10,079 --> 00:13:14,560
questions of degree 0 1 3 4 and 9

330
00:13:14,560 --> 00:13:16,079
and multiply

331
00:13:16,079 --> 00:13:18,320
as it is carefully designed coefficients

332
00:13:18,320 --> 00:13:23,040
of 0 2 6 8 and 18 encode the product of

333
00:13:23,040 --> 00:13:24,800
messages

334
00:13:24,800 --> 00:13:27,440
by this mean overdrive 2k achieve some

335
00:13:27,440 --> 00:13:29,200
automotive correspondence up to one

336
00:13:29,200 --> 00:13:31,200
multiplication

337
00:13:31,200 --> 00:13:33,200
also note that this packing method is

338
00:13:33,200 --> 00:13:35,600
level dependent meaning that the packing

339
00:13:35,600 --> 00:13:39,040
structure changes after multiplication

340
00:13:39,040 --> 00:13:40,639
the authors claim that the packing

341
00:13:40,639 --> 00:13:42,240
density of their method has

342
00:13:42,240 --> 00:13:46,639
asymptotically 1 over d to 0.4

343
00:13:46,639 --> 00:13:49,040
and is roughly 1 over 5 for practical

344
00:13:49,040 --> 00:13:51,680
parameters

345
00:13:51,839 --> 00:13:54,000
the starting point of our packing method

346
00:13:54,000 --> 00:13:56,880
is the idea of what if we use evaluation

347
00:13:56,880 --> 00:13:58,880
points rather than coefficients as

348
00:13:58,880 --> 00:14:00,399
previous packings

349
00:14:00,399 --> 00:14:02,800
that is what if we use interpolation to

350
00:14:02,800 --> 00:14:04,399
pack messages

351
00:14:04,399 --> 00:14:06,240
if we interpolate the messages into a

352
00:14:06,240 --> 00:14:09,600
polynomial of degree roughly half of d

353
00:14:09,600 --> 00:14:11,680
then we can easily avoid

354
00:14:11,680 --> 00:14:14,160
degree overflow when multiplied and

355
00:14:14,160 --> 00:14:16,480
prevent information loss by reduction by

356
00:14:16,480 --> 00:14:19,680
the quotient polynomials

357
00:14:20,160 --> 00:14:22,160
the best part is that this packing

358
00:14:22,160 --> 00:14:24,160
method offers packing density of more

359
00:14:24,160 --> 00:14:25,519
than a half

360
00:14:25,519 --> 00:14:27,199
this sounds perfect

361
00:14:27,199 --> 00:14:29,440
reducing the gap of packing density

362
00:14:29,440 --> 00:14:31,120
between the field and

363
00:14:31,120 --> 00:14:34,800
that 2k case only to the vector of 2.

364
00:14:34,800 --> 00:14:36,959
however the cavity here is that

365
00:14:36,959 --> 00:14:38,720
interpolation over that's 2k is

366
00:14:38,720 --> 00:14:40,560
impossible in general

367
00:14:40,560 --> 00:14:43,199
to see this consider evaluation at 0 and

368
00:14:43,199 --> 00:14:45,600
2. these two values must have the same

369
00:14:45,600 --> 00:14:46,880
parity

370
00:14:46,880 --> 00:14:49,120
thus we do not have full freedom to

371
00:14:49,120 --> 00:14:51,760
choose target points

372
00:14:51,760 --> 00:14:54,720
however our story does not end here we

373
00:14:54,720 --> 00:14:57,199
devised a method to perform something

374
00:14:57,199 --> 00:15:00,560
very similar to interpolation over z2k

375
00:15:00,560 --> 00:15:02,240
we call this method a tweaked

376
00:15:02,240 --> 00:15:04,160
interpolation

377
00:15:04,160 --> 00:15:06,160
the main idea is to lift the target

378
00:15:06,160 --> 00:15:08,320
points to a larger ring to cancel out

379
00:15:08,320 --> 00:15:11,040
effects of zero divisors

380
00:15:11,040 --> 00:15:14,560
precisely when nz2k messages are given

381
00:15:14,560 --> 00:15:17,360
we can find a not so large delta so that

382
00:15:17,360 --> 00:15:19,760
there exists a polynomial over this

383
00:15:19,760 --> 00:15:21,199
lifted mean

384
00:15:21,199 --> 00:15:23,279
whose degree is less than n

385
00:15:23,279 --> 00:15:27,199
and its evaluation at i equals i message

386
00:15:27,199 --> 00:15:31,839
multiplied by 2 to the delta for all i

387
00:15:32,399 --> 00:15:34,639
coming back to packing methods we can

388
00:15:34,639 --> 00:15:36,720
now realize our packing design with the

389
00:15:36,720 --> 00:15:39,199
help of tweak interpolation

390
00:15:39,199 --> 00:15:41,199
just one thing to be careful is that

391
00:15:41,199 --> 00:15:43,279
since we lifted the target points by a

392
00:15:43,279 --> 00:15:45,680
vector of 2 to the delta

393
00:15:45,680 --> 00:15:48,399
we multiply the lifting vector grows to

394
00:15:48,399 --> 00:15:50,800
2 to the 2 delta

395
00:15:50,800 --> 00:15:53,279
in this regard we must use plain text

396
00:15:53,279 --> 00:15:56,240
modulus with an extra delta to avoid

397
00:15:56,240 --> 00:15:58,560
modulus overflow and prevent information

398
00:15:58,560 --> 00:16:00,240
loss

399
00:16:00,240 --> 00:16:02,560
then our tweaked interpolation packing

400
00:16:02,560 --> 00:16:05,040
offers somatomorphic correspondence up

401
00:16:05,040 --> 00:16:07,360
to one multiplication

402
00:16:07,360 --> 00:16:09,519
note that our packing method is also

403
00:16:09,519 --> 00:16:12,079
level dependent

404
00:16:12,079 --> 00:16:14,399
in fact we can choose the delta to be

405
00:16:14,399 --> 00:16:16,800
roughly the half of d

406
00:16:16,800 --> 00:16:18,720
thus packing density of our tweaked

407
00:16:18,720 --> 00:16:21,759
interpolation packing is roughly a half

408
00:16:21,759 --> 00:16:24,959
when d is sufficiently smaller than k

409
00:16:24,959 --> 00:16:26,639
and this is the case for typical

410
00:16:26,639 --> 00:16:29,680
parameters of actively secure npc over

411
00:16:29,680 --> 00:16:31,440
z2k

412
00:16:31,440 --> 00:16:34,000
moreover in a recent paper by me and

413
00:16:34,000 --> 00:16:36,880
professor chan we proved that this is

414
00:16:36,880 --> 00:16:39,839
somehow near optimal

415
00:16:39,839 --> 00:16:42,240
the graphs show the plots of packing

416
00:16:42,240 --> 00:16:44,399
densities along the change of the degree

417
00:16:44,399 --> 00:16:45,360
d

418
00:16:45,360 --> 00:16:48,000
the red is for overdrive 2k packing and

419
00:16:48,000 --> 00:16:49,839
blue is for our tweaked interpolation

420
00:16:49,839 --> 00:16:51,040
packing

421
00:16:51,040 --> 00:16:53,199
three blue lines each denote densities

422
00:16:53,199 --> 00:16:55,839
for three typical size of k used in

423
00:16:55,839 --> 00:16:58,959
actively secure npc over set 2k as our

424
00:16:58,959 --> 00:17:00,959
density is affected by the size of the

425
00:17:00,959 --> 00:17:03,519
ring set 2k

426
00:17:03,519 --> 00:17:05,599
the left graph shows an asymptotic

427
00:17:05,599 --> 00:17:07,839
behavior of density and the right graph

428
00:17:07,839 --> 00:17:10,319
shows an exact densities in practical

429
00:17:10,319 --> 00:17:12,079
set of d

430
00:17:12,079 --> 00:17:14,160
notice that the gap is visible even in

431
00:17:14,160 --> 00:17:17,280
the closest case

432
00:17:17,280 --> 00:17:19,359
our tweaked interpolation packing shows

433
00:17:19,359 --> 00:17:22,480
up to 2.5 times improvements in packing

434
00:17:22,480 --> 00:17:26,000
density versus overdrive 2k packing

435
00:17:26,000 --> 00:17:28,160
that is using tweaked interpolation

436
00:17:28,160 --> 00:17:30,960
packing in npc pre-processing we could

437
00:17:30,960 --> 00:17:34,000
improve the amortized performance by a

438
00:17:34,000 --> 00:17:38,000
factor of 2.5

439
00:17:41,600 --> 00:17:44,480
a limitation of packings for z2k is that

440
00:17:44,480 --> 00:17:46,799
they are level dependent by level

441
00:17:46,799 --> 00:17:48,720
dependent we mean that we get different

442
00:17:48,720 --> 00:17:51,600
packing structure after multiplications

443
00:17:51,600 --> 00:17:53,039
so that we have different packing

444
00:17:53,039 --> 00:17:55,919
structure for each multiplicative level

445
00:17:55,919 --> 00:17:58,880
a recent paper by me and professor chan

446
00:17:58,880 --> 00:18:01,440
proves that this situation is inevitable

447
00:18:01,440 --> 00:18:03,919
the circumstance is in contrast with

448
00:18:03,919 --> 00:18:06,320
conventional packings for prime fields

449
00:18:06,320 --> 00:18:08,880
which are naturally level consistent by

450
00:18:08,880 --> 00:18:11,200
crt isomorphisms

451
00:18:11,200 --> 00:18:13,120
the issue here is that if a packing

452
00:18:13,120 --> 00:18:16,000
method is level dependent then we cannot

453
00:18:16,000 --> 00:18:17,840
perform homomorphic computation between

454
00:18:17,840 --> 00:18:20,240
different packing levels

455
00:18:20,240 --> 00:18:22,880
but why does this even matter to see

456
00:18:22,880 --> 00:18:24,880
this i will briefly review the process

457
00:18:24,880 --> 00:18:26,799
of the reshare protocol

458
00:18:26,799 --> 00:18:28,480
roughly speaking it is used to

459
00:18:28,480 --> 00:18:31,919
re-encrypt a level 0 he ciphertext which

460
00:18:31,919 --> 00:18:34,240
does not allow any more multiplications

461
00:18:34,240 --> 00:18:37,200
into a fresh ciphertext over simplifying

462
00:18:37,200 --> 00:18:40,480
a bit it proceeds like the diagram

463
00:18:40,480 --> 00:18:43,440
first we add a random ciphertext r to

464
00:18:43,440 --> 00:18:45,760
mask the input ciphertext c

465
00:18:45,760 --> 00:18:48,559
then we perform collaborative decryption

466
00:18:48,559 --> 00:18:50,400
followed by encryption

467
00:18:50,400 --> 00:18:52,880
finally we subtract the masking cipher

468
00:18:52,880 --> 00:18:55,280
text r to reconstruct the original plain

469
00:18:55,280 --> 00:18:57,840
text c

470
00:18:57,840 --> 00:19:00,640
notice that the masking cipher text r is

471
00:19:00,640 --> 00:19:03,360
used twice at different levels

472
00:19:03,360 --> 00:19:05,679
once to mask the input cipher text c at

473
00:19:05,679 --> 00:19:08,960
level 0 and wants to reconstruct the

474
00:19:08,960 --> 00:19:11,200
plain text at level 1.

475
00:19:11,200 --> 00:19:13,120
whereas the ciphertext levels can be

476
00:19:13,120 --> 00:19:15,360
easily adjusted by modulus switching

477
00:19:15,360 --> 00:19:17,200
technique in he

478
00:19:17,200 --> 00:19:18,080
but

479
00:19:18,080 --> 00:19:20,080
difference of packing levels seems

480
00:19:20,080 --> 00:19:21,520
problematic

481
00:19:21,520 --> 00:19:24,240
in this context overdrive to k provides

482
00:19:24,240 --> 00:19:26,480
two masking cipher text with same

483
00:19:26,480 --> 00:19:29,039
message but in different packing levels

484
00:19:29,039 --> 00:19:31,840
this solution however almost doubles the

485
00:19:31,840 --> 00:19:34,880
cost of reshare protocol

486
00:19:34,880 --> 00:19:37,280
on the other hand we resolve this issue

487
00:19:37,280 --> 00:19:39,280
by a technical trick the main

488
00:19:39,280 --> 00:19:41,360
observation is that we use the reshare

489
00:19:41,360 --> 00:19:43,840
protocol only to support an additional

490
00:19:43,840 --> 00:19:46,400
multiplication with mac key alpha which

491
00:19:46,400 --> 00:19:49,840
is indeed a constant in that 2k

492
00:19:49,840 --> 00:19:52,160
thus in fact we do not even need to care

493
00:19:52,160 --> 00:19:54,160
about packing levels if we use a

494
00:19:54,160 --> 00:19:56,400
different packing structure for mackey

495
00:19:56,400 --> 00:19:59,679
namely if we use constant packing method

496
00:19:59,679 --> 00:20:01,840
our tree closes gap between the prime

497
00:20:01,840 --> 00:20:04,960
field and z2k cases caused by level

498
00:20:04,960 --> 00:20:07,120
consistency of the packings

499
00:20:07,120 --> 00:20:10,000
and offers 1.4 times reduction in

500
00:20:10,000 --> 00:20:11,679
communication cost compared to the

501
00:20:11,679 --> 00:20:15,520
solution of overdrive 2k

502
00:20:18,799 --> 00:20:21,600
in this section we are interested in zkp

503
00:20:21,600 --> 00:20:23,679
of plain text knowledge which is

504
00:20:23,679 --> 00:20:26,640
abbreviated as that kpopk

505
00:20:26,640 --> 00:20:28,640
it guarantees that a ciphertext is

506
00:20:28,640 --> 00:20:30,799
honestly generated from a plain text

507
00:20:30,799 --> 00:20:32,640
without revealing any information on the

508
00:20:32,640 --> 00:20:36,320
plain text that kpopk plays an important

509
00:20:36,320 --> 00:20:38,640
role in speech-like protocols since it

510
00:20:38,640 --> 00:20:40,880
restricts adversaries from submitting

511
00:20:40,880 --> 00:20:43,360
maliciously generated cipher text to

512
00:20:43,360 --> 00:20:47,280
learn information of other parties

513
00:20:47,600 --> 00:20:51,280
that kpopk is a standard type protocol

514
00:20:51,280 --> 00:20:53,679
suppose the prover alice wants to prove

515
00:20:53,679 --> 00:20:56,080
that she has honestly generated a cipher

516
00:20:56,080 --> 00:20:58,320
text which encrypts

517
00:20:58,320 --> 00:21:01,840
a plain text x with randomness r

518
00:21:01,840 --> 00:21:04,000
first she commits a random masking

519
00:21:04,000 --> 00:21:05,679
cipher text

520
00:21:05,679 --> 00:21:09,039
then the verifier bob chooses a random

521
00:21:09,039 --> 00:21:12,320
challenge c which is either 0 or 1.

522
00:21:12,320 --> 00:21:14,720
after receiving the challenge ellis

523
00:21:14,720 --> 00:21:16,799
responds with corresponding linear

524
00:21:16,799 --> 00:21:19,919
combination of plain text and randomness

525
00:21:19,919 --> 00:21:22,720
finally bob checks certain criteria to

526
00:21:22,720 --> 00:21:25,039
judge whether really ellie says

527
00:21:25,039 --> 00:21:27,600
honestly generate the cipher text

528
00:21:27,600 --> 00:21:29,840
however using such a small challenge

529
00:21:29,840 --> 00:21:32,880
space consisting of only 0 and 1 we must

530
00:21:32,880 --> 00:21:35,679
iterate this process numerous times to

531
00:21:35,679 --> 00:21:39,360
achieve satisfactory level of security

532
00:21:39,360 --> 00:21:41,760
the top gear protocol aims to enhance

533
00:21:41,760 --> 00:21:44,320
the efficiency of jet kpop k by

534
00:21:44,320 --> 00:21:47,039
enlarging the challenge space

535
00:21:47,039 --> 00:21:49,360
main idea is to leverage the structure

536
00:21:49,360 --> 00:21:52,640
of h e plaintext base namely zx

537
00:21:52,640 --> 00:21:55,600
quotiented by a power of two cycloatomic

538
00:21:55,600 --> 00:21:57,280
polynomial

539
00:21:57,280 --> 00:21:59,360
in this way they extended the challenge

540
00:21:59,360 --> 00:22:02,240
space to 0 and powers of x

541
00:22:02,240 --> 00:22:04,720
this approach is favorable in

542
00:22:04,720 --> 00:22:07,600
communication cost and latency and top

543
00:22:07,600 --> 00:22:09,919
gear optimization also affects memory

544
00:22:09,919 --> 00:22:12,080
consumption in batched version of jet

545
00:22:12,080 --> 00:22:14,960
kpopk which is a standard in speed slide

546
00:22:14,960 --> 00:22:17,679
protocols

547
00:22:17,840 --> 00:22:19,760
behind the scene of top gear there are

548
00:22:19,760 --> 00:22:21,760
two mathematical lemmas which enable

549
00:22:21,760 --> 00:22:24,159
such large challenge space

550
00:22:24,159 --> 00:22:26,559
first fact is that multiplying a power

551
00:22:26,559 --> 00:22:28,640
of x does not increase the size of

552
00:22:28,640 --> 00:22:30,720
questions too much

553
00:22:30,720 --> 00:22:33,039
second is that a difference of powers of

554
00:22:33,039 --> 00:22:35,840
x always has a small pseudo inverse in

555
00:22:35,840 --> 00:22:38,080
plain text space

556
00:22:38,080 --> 00:22:40,320
the second fact was first observed by

557
00:22:40,320 --> 00:22:43,039
benham udayad al and is being widely

558
00:22:43,039 --> 00:22:44,400
employed

559
00:22:44,400 --> 00:22:46,480
these two facts are the essence of

560
00:22:46,480 --> 00:22:49,520
security proofs of that kpop k including

561
00:22:49,520 --> 00:22:51,360
soundness

562
00:22:51,360 --> 00:22:53,919
however these lemmas were only known for

563
00:22:53,919 --> 00:22:56,000
the power of 2ks

564
00:22:56,000 --> 00:22:58,159
meanwhile power of two six atomic

565
00:22:58,159 --> 00:23:00,400
polynomials are irreducible modulus to

566
00:23:00,400 --> 00:23:01,600
the k

567
00:23:01,600 --> 00:23:04,320
this means that we cannot leverage crt

568
00:23:04,320 --> 00:23:07,200
parallelism or set to k messages in this

569
00:23:07,200 --> 00:23:09,520
case in this context

570
00:23:09,520 --> 00:23:11,840
overdrive 2k could not employ the top

571
00:23:11,840 --> 00:23:14,320
gear optimization

572
00:23:14,320 --> 00:23:16,720
in this work we extended the lambus to

573
00:23:16,720 --> 00:23:19,120
the prime case and in the follow-up work

574
00:23:19,120 --> 00:23:21,200
we extended even further to the case

575
00:23:21,200 --> 00:23:25,360
where m has two or less prime factors

576
00:23:25,360 --> 00:23:27,440
with these new generalizations we

577
00:23:27,440 --> 00:23:30,080
propose top gear 2k which allows us to

578
00:23:30,080 --> 00:23:32,640
use larger challenge space for z2k

579
00:23:32,640 --> 00:23:33,760
messages

580
00:23:33,760 --> 00:23:38,240
as in top gear for prime field messages

581
00:23:38,240 --> 00:23:41,679
indeed our jet kpopk enjoys same

582
00:23:41,679 --> 00:23:44,080
advantages as the original top gear

583
00:23:44,080 --> 00:23:47,080
protocol

584
00:23:50,720 --> 00:23:53,440
another limitation of packings for z2k

585
00:23:53,440 --> 00:23:55,679
is that they are non-subjective

586
00:23:55,679 --> 00:23:57,760
buying and subjective we mean that there

587
00:23:57,760 --> 00:24:00,080
exist invalid packings in plain text

588
00:24:00,080 --> 00:24:01,200
base

589
00:24:01,200 --> 00:24:02,799
the recent work proves that this

590
00:24:02,799 --> 00:24:05,039
situation is also inevitable

591
00:24:05,039 --> 00:24:07,600
the circumstance is in contrast with the

592
00:24:07,600 --> 00:24:10,480
conventional packings for prime fields

593
00:24:10,480 --> 00:24:12,480
which are naturally subjective by crt

594
00:24:12,480 --> 00:24:14,320
isomorphisms

595
00:24:14,320 --> 00:24:16,159
the issue here is that malicious

596
00:24:16,159 --> 00:24:18,400
adversaries may use these invalid

597
00:24:18,400 --> 00:24:20,799
packings to illegitimately learn

598
00:24:20,799 --> 00:24:23,279
information of other parties so it is

599
00:24:23,279 --> 00:24:26,080
necessary to somehow handle this

600
00:24:26,080 --> 00:24:28,640
invalid packings

601
00:24:28,640 --> 00:24:30,799
in this work we conceptualize zero

602
00:24:30,799 --> 00:24:32,640
knowledge proof of message knowledge

603
00:24:32,640 --> 00:24:35,600
abbreviated as that kpo mk which

604
00:24:35,600 --> 00:24:38,320
guarantees that a cipher text encrypts a

605
00:24:38,320 --> 00:24:40,400
valid packing without revealing any

606
00:24:40,400 --> 00:24:42,720
other information on message

607
00:24:42,720 --> 00:24:45,039
this concept was somehow neglected in

608
00:24:45,039 --> 00:24:47,840
overdrive 2k since that kpo mk can be

609
00:24:47,840 --> 00:24:51,760
easily integrated into the kpo pk if one

610
00:24:51,760 --> 00:24:53,600
only used the small challenge space

611
00:24:53,600 --> 00:24:56,480
consisting of zero and one

612
00:24:56,480 --> 00:24:58,400
in this work we designed an efficient

613
00:24:58,400 --> 00:25:00,480
jet kpo kpomk for our tweaked

614
00:25:00,480 --> 00:25:02,720
interpolation packing which goes well

615
00:25:02,720 --> 00:25:06,640
with our extended challenge space

616
00:25:10,640 --> 00:25:13,279
combining all the previous improvements

617
00:25:13,279 --> 00:25:15,200
we can combine them into a better

618
00:25:15,200 --> 00:25:17,679
authenticated triple generation

619
00:25:17,679 --> 00:25:19,679
our new tweaked interpolation packing

620
00:25:19,679 --> 00:25:22,559
offers a better amortized performance

621
00:25:22,559 --> 00:25:24,640
our simpler reshare protocol offers

622
00:25:24,640 --> 00:25:26,400
reduction in communication cost and

623
00:25:26,400 --> 00:25:29,520
latency and our better that kpopk with

624
00:25:29,520 --> 00:25:33,200
our new depth kpumk offers reduction in

625
00:25:33,200 --> 00:25:35,679
communication cost latency and memory

626
00:25:35,679 --> 00:25:37,919
consumption

627
00:25:37,919 --> 00:25:41,200
as a whole megahertz 2k an npc protocol

628
00:25:41,200 --> 00:25:43,600
over that 2k secure against actively

629
00:25:43,600 --> 00:25:47,279
corrupted majority offers from 2.2 to

630
00:25:47,279 --> 00:25:50,000
4.8 times improvements in amortized

631
00:25:50,000 --> 00:25:52,320
communication cost versus previous best

632
00:25:52,320 --> 00:25:53,679
schemes

633
00:25:53,679 --> 00:25:57,679
and offers 3.7 to 6.4 times improvements

634
00:25:57,679 --> 00:25:59,919
in memory consumption versus overdrive

635
00:25:59,919 --> 00:26:01,520
2k

636
00:26:01,520 --> 00:26:03,279
but what we really want to share here is

637
00:26:03,279 --> 00:26:05,360
our new techniques and concepts which

638
00:26:05,360 --> 00:26:07,520
enabled these improvements

639
00:26:07,520 --> 00:26:10,000
namely tweaked interpolation and tweaked

640
00:26:10,000 --> 00:26:12,000
interpolation packing

641
00:26:12,000 --> 00:26:14,320
level dependency and search activity for

642
00:26:14,320 --> 00:26:15,520
packings

643
00:26:15,520 --> 00:26:18,080
constant packing trick for simpler

644
00:26:18,080 --> 00:26:19,279
reshare

645
00:26:19,279 --> 00:26:22,960
generalization of dilemma by behamud al

646
00:26:22,960 --> 00:26:27,840
and our new notion of jet kpo mk

647
00:26:27,840 --> 00:26:30,080
thank you for watching any questions or

648
00:26:30,080 --> 00:26:34,760
comments are welcomed by any means

649
00:26:40,720 --> 00:26:42,799
you

