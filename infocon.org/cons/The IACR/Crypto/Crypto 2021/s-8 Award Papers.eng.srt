1
00:00:01,680 --> 00:00:04,240
okay so uh

2
00:00:04,240 --> 00:00:06,720
sorry you're good to go yeah thank you

3
00:00:06,720 --> 00:00:09,679
okay so welcome again everybody uh uh

4
00:00:09,679 --> 00:00:12,799
for the uh award papers uh session

5
00:00:12,799 --> 00:00:16,000
uh and the uh the first paper is on the

6
00:00:16,000 --> 00:00:19,039
possibility of basic cryptography on x

7
00:00:19,039 --> 00:00:21,359
uh not equal to bpp

8
00:00:21,359 --> 00:00:22,320
uh

9
00:00:22,320 --> 00:00:24,880
by ajani liu and rafael pass

10
00:00:24,880 --> 00:00:28,080
uh the paper did uh get the best paper

11
00:00:28,080 --> 00:00:33,280
award for uh to 2021 and uh uh yandi uh

12
00:00:33,280 --> 00:00:35,120
please give it up can you say that for

13
00:00:35,120 --> 00:00:37,600
this talk and for all the other uh

14
00:00:37,600 --> 00:00:40,480
papers in in this session uh um we're

15
00:00:40,480 --> 00:00:42,960
gonna uh ask the authors to to spend

16
00:00:42,960 --> 00:00:45,440
about nine to ten minutes maybe oh for

17
00:00:45,440 --> 00:00:48,320
nine minutes for uh uh presentation then

18
00:00:48,320 --> 00:00:50,480
we have like ample six minutes for

19
00:00:50,480 --> 00:00:52,640
discussion so please you know prepare

20
00:00:52,640 --> 00:00:54,160
questions and we have some time to

21
00:00:54,160 --> 00:00:56,239
discuss each paper so you have an hour

22
00:00:56,239 --> 00:00:59,440
overall for the four papers uh anyway so

23
00:00:59,440 --> 00:01:02,000
can you please go ahead

24
00:01:02,000 --> 00:01:05,000
yep

25
00:01:18,240 --> 00:01:20,880
okay hi everyone it's really my owner

26
00:01:20,880 --> 00:01:23,119
here to present my work on the

27
00:01:23,119 --> 00:01:26,159
possibility of basing cryptography on x

28
00:01:26,159 --> 00:01:28,720
is not equal to bpp and this is a joint

29
00:01:28,720 --> 00:01:30,799
work with professor of our past ethical

30
00:01:30,799 --> 00:01:32,400
attack

31
00:01:32,400 --> 00:01:33,280
so

32
00:01:33,280 --> 00:01:35,119
today we're going to talk about the

33
00:01:35,119 --> 00:01:37,200
notion of male functions which was

34
00:01:37,200 --> 00:01:40,400
proposed by divine helmet in fact 76

35
00:01:40,400 --> 00:01:42,880
one-way function is unequivocally the

36
00:01:42,880 --> 00:01:45,520
most central notion in cryptography

37
00:01:45,520 --> 00:01:48,159
on one hand we know that one function is

38
00:01:48,159 --> 00:01:50,000
both necessary and sufficient for a

39
00:01:50,000 --> 00:01:52,960
branch of private key crypto primitives

40
00:01:52,960 --> 00:01:54,960
and on the other hand

41
00:01:54,960 --> 00:01:57,280
probability encryption of lewis transfer

42
00:01:57,280 --> 00:01:59,840
would imply the existing functions

43
00:01:59,840 --> 00:02:02,799
therefore without one function there's

44
00:02:02,799 --> 00:02:04,799
really no non-trivial computational

45
00:02:04,799 --> 00:02:06,320
crypto

46
00:02:06,320 --> 00:02:08,720
however proving the existence of a

47
00:02:08,720 --> 00:02:10,878
function is a very hard problem and

48
00:02:10,878 --> 00:02:13,599
would imply mp is not equal to p

49
00:02:13,599 --> 00:02:15,360
therefore in the absence of a formal

50
00:02:15,360 --> 00:02:17,760
proof people have just you know come up

51
00:02:17,760 --> 00:02:19,440
with this

52
00:02:19,440 --> 00:02:21,120
difference complete uh

53
00:02:21,120 --> 00:02:23,040
one function candidates based on

54
00:02:23,040 --> 00:02:25,120
different competition assumptions

55
00:02:25,120 --> 00:02:27,840
however we know that if we can build

56
00:02:27,840 --> 00:02:30,720
quantum computers then some of these

57
00:02:30,720 --> 00:02:33,360
assumptions are just broken and we

58
00:02:33,360 --> 00:02:36,480
really need a formal proof so in this

59
00:02:36,480 --> 00:02:37,920
work we ask

60
00:02:37,920 --> 00:02:40,640
can we prove the exist of wave function

61
00:02:40,640 --> 00:02:43,920
based on weak assumptions about feasible

62
00:02:43,920 --> 00:02:45,360
computations

63
00:02:45,360 --> 00:02:49,200
and perhaps the most believable and open

64
00:02:49,200 --> 00:02:51,920
conjecture would be x is not equal to

65
00:02:51,920 --> 00:02:53,840
bbp

66
00:02:53,840 --> 00:02:56,480
recall that x denotes the class of x

67
00:02:56,480 --> 00:02:58,879
financial time decidable languages and

68
00:02:58,879 --> 00:03:01,920
bpp stands for the class of randomized

69
00:03:01,920 --> 00:03:04,239
polynomial time decidable language

70
00:03:04,239 --> 00:03:07,280
so our unproven minimal conjecture would

71
00:03:07,280 --> 00:03:11,040
be x is not equal to bpp informally

72
00:03:11,040 --> 00:03:13,840
randomness does not exponentially speed

73
00:03:13,840 --> 00:03:16,000
up computation

74
00:03:16,000 --> 00:03:18,800
to see that this is really a believable

75
00:03:18,800 --> 00:03:21,760
and very weak conductor let's consider

76
00:03:21,760 --> 00:03:24,319
the factoring problem so to factor a

77
00:03:24,319 --> 00:03:26,000
large number n

78
00:03:26,000 --> 00:03:28,959
uh randomness seems not to be very much

79
00:03:28,959 --> 00:03:31,760
helpful since even if we can toss a coin

80
00:03:31,760 --> 00:03:33,519
we don't know how to factor a large

81
00:03:33,519 --> 00:03:35,840
number in polynomial time

82
00:03:35,840 --> 00:03:38,159
however if we have an exponential time

83
00:03:38,159 --> 00:03:40,560
algorithm we can simply factor a larger

84
00:03:40,560 --> 00:03:43,280
number and buy a boot for search

85
00:03:43,280 --> 00:03:46,000
so therefore x and the bpp are really

86
00:03:46,000 --> 00:03:48,000
two different things and it would be

87
00:03:48,000 --> 00:03:50,319
crazy that's a randomized polynomial

88
00:03:50,319 --> 00:03:52,959
time algorithm can emulate exponential

89
00:03:52,959 --> 00:03:55,599
time algorithm

90
00:03:55,599 --> 00:03:56,319
so

91
00:03:56,319 --> 00:03:58,080
today

92
00:03:58,080 --> 00:04:00,799
we ask can we base the existence of a

93
00:04:00,799 --> 00:04:03,680
function and the very weak assumption x

94
00:04:03,680 --> 00:04:06,400
is not equal to vvp

95
00:04:06,400 --> 00:04:09,599
so we show that there exists a standard

96
00:04:09,599 --> 00:04:12,400
nature problem called mktp

97
00:04:12,400 --> 00:04:15,120
and this problem being harder average

98
00:04:15,120 --> 00:04:16,798
with respect to two-stated error

99
00:04:16,798 --> 00:04:19,358
heuristics is equivalent to

100
00:04:19,358 --> 00:04:21,519
the existence of one functions

101
00:04:21,519 --> 00:04:24,320
and also this this problem the same

102
00:04:24,320 --> 00:04:26,560
problem being hot on average with

103
00:04:26,560 --> 00:04:28,880
respect to errorless heuristics is

104
00:04:28,880 --> 00:04:32,800
equivalent to x is not equal to bpp

105
00:04:32,800 --> 00:04:35,840
as we shall see later mktp is really a

106
00:04:35,840 --> 00:04:38,000
standard problem related to combo

107
00:04:38,000 --> 00:04:40,840
capacity and has been studied since the

108
00:04:40,840 --> 00:04:45,360
70s and the two notions of errorless

109
00:04:45,360 --> 00:04:47,360
average case harness and two-sided area

110
00:04:47,360 --> 00:04:50,240
average harness are two standard notions

111
00:04:50,240 --> 00:04:52,880
used in complexity theory literature

112
00:04:52,880 --> 00:04:56,080
so today we show that the only gap

113
00:04:56,080 --> 00:04:58,320
between the existence of one function

114
00:04:58,320 --> 00:05:01,680
and x is not equal to bbp is a seemingly

115
00:05:01,680 --> 00:05:04,720
minor technical distinction between two

116
00:05:04,720 --> 00:05:06,960
the two standard notions of equity's

117
00:05:06,960 --> 00:05:10,720
hardness for a specific problem

118
00:05:10,720 --> 00:05:12,479
so to present our main theory more

119
00:05:12,479 --> 00:05:16,320
formally let us look at some notions

120
00:05:16,320 --> 00:05:18,320
first let us introduce the notion of one

121
00:05:18,320 --> 00:05:19,280
function

122
00:05:19,280 --> 00:05:22,240
so a function f is one way if it's easy

123
00:05:22,240 --> 00:05:25,680
to compute and hard to invert

124
00:05:25,680 --> 00:05:28,479
and in this work we also consider a

125
00:05:28,479 --> 00:05:30,800
notion of infinity of a line function

126
00:05:30,800 --> 00:05:32,880
where the inversion requirement is

127
00:05:32,880 --> 00:05:35,919
relaxed and we only recall that all

128
00:05:35,919 --> 00:05:38,479
attackers fell on infinitely many input

129
00:05:38,479 --> 00:05:41,199
lengths and as opposite to for all input

130
00:05:41,199 --> 00:05:43,039
lengths and in standard runway function

131
00:05:43,039 --> 00:05:45,680
experiments

132
00:05:45,840 --> 00:05:47,600
then let us introduce the notion of

133
00:05:47,600 --> 00:05:50,160
commodore capacity and the question here

134
00:05:50,160 --> 00:05:51,919
is which of the following strings is

135
00:05:51,919 --> 00:05:54,639
more random the first string is a one

136
00:05:54,639 --> 00:05:57,039
two three one two three and so on and

137
00:05:57,039 --> 00:05:59,280
the second string is like something

138
00:05:59,280 --> 00:06:00,880
looks really random

139
00:06:00,880 --> 00:06:03,520
and the notion of komodo capacity is

140
00:06:03,520 --> 00:06:06,560
used to measure amount of randomness in

141
00:06:06,560 --> 00:06:08,560
a fixed string

142
00:06:08,560 --> 00:06:10,880
so for any string x we let k of x

143
00:06:10,880 --> 00:06:12,639
denotes the length of the shortest

144
00:06:12,639 --> 00:06:15,440
program that outputs the string x

145
00:06:15,440 --> 00:06:17,440
more formally we fix the universal tree

146
00:06:17,440 --> 00:06:19,520
machine u and we are looking for the

147
00:06:19,520 --> 00:06:21,600
length of the shortest program pi which

148
00:06:21,600 --> 00:06:24,240
consists of m comma w such that the

149
00:06:24,240 --> 00:06:26,240
universal tree machine u when simulated

150
00:06:26,240 --> 00:06:30,479
on m comma w will output the string x

151
00:06:30,479 --> 00:06:32,880
and the notion of commodore capacity has

152
00:06:32,880 --> 00:06:36,160
a great number of applications however

153
00:06:36,160 --> 00:06:38,880
this is uncomputable

154
00:06:38,880 --> 00:06:41,440
so we instead look at lemon's commodore

155
00:06:41,440 --> 00:06:42,720
capacity

156
00:06:42,720 --> 00:06:44,960
and in levin's commodore capacity we are

157
00:06:44,960 --> 00:06:47,680
looking for the most efficient program

158
00:06:47,680 --> 00:06:50,639
that outputs the string x and here the

159
00:06:50,639 --> 00:06:53,759
efficiency is defined to be the sum of

160
00:06:53,759 --> 00:06:55,680
the length of the program and the

161
00:06:55,680 --> 00:06:58,560
logarithm of the running time

162
00:06:58,560 --> 00:07:00,319
for example if

163
00:07:00,319 --> 00:07:02,479
there is a program pi that outputs the

164
00:07:02,479 --> 00:07:05,199
string x within time 2 to the power of n

165
00:07:05,199 --> 00:07:08,400
over 10 and length of machine is at most

166
00:07:08,400 --> 00:07:09,680
n over 10

167
00:07:09,680 --> 00:07:12,639
then we conclude kt of the string x is

168
00:07:12,639 --> 00:07:15,599
at most n over 10 plus n over 10 that is

169
00:07:15,599 --> 00:07:17,520
n over 5.

170
00:07:17,520 --> 00:07:19,919
and the intuition behind this is that we

171
00:07:19,919 --> 00:07:22,080
charge for the size of the program and

172
00:07:22,080 --> 00:07:23,360
the runtime of the program

173
00:07:23,360 --> 00:07:25,840
simultaneously but we only charge

174
00:07:25,840 --> 00:07:28,240
logarithmically for time to capture the

175
00:07:28,240 --> 00:07:29,680
intuition that polynomial time

176
00:07:29,680 --> 00:07:33,120
competitions are relatively cheap

177
00:07:33,120 --> 00:07:36,240
and here mktp denotes the language of

178
00:07:36,240 --> 00:07:39,919
pairs of x comma k such that mktp such

179
00:07:39,919 --> 00:07:43,120
that kt of x is at most k

180
00:07:43,120 --> 00:07:46,000
we remark that mktp no longer seems to

181
00:07:46,000 --> 00:07:48,560
be in mp since we don't know how to

182
00:07:48,560 --> 00:07:50,080
verify this

183
00:07:50,080 --> 00:07:52,720
in polynomial time

184
00:07:52,720 --> 00:07:54,720
and let us introduce the notions of

185
00:07:54,720 --> 00:07:57,599
advocacy hardness that we rely on

186
00:07:57,599 --> 00:07:59,199
we first introduce the notion of

187
00:07:59,199 --> 00:08:02,240
two-sided advocacy heuristic so we say

188
00:08:02,240 --> 00:08:05,360
that a language l is in curiosity p if

189
00:08:05,360 --> 00:08:08,080
there exists an algorithm h such as h of

190
00:08:08,080 --> 00:08:10,319
x the output the correct answer with

191
00:08:10,319 --> 00:08:12,400
very high probability over random

192
00:08:12,400 --> 00:08:14,240
instances

193
00:08:14,240 --> 00:08:15,520
and

194
00:08:15,520 --> 00:08:17,520
next let us introduce the notion of

195
00:08:17,520 --> 00:08:19,360
errorless advocates hardness which is

196
00:08:19,360 --> 00:08:21,039
also a standard notion used in

197
00:08:21,039 --> 00:08:23,280
complexity theory literature

198
00:08:23,280 --> 00:08:26,080
we say that a language l is in average p

199
00:08:26,080 --> 00:08:28,960
if there exists an algorithm h such that

200
00:08:28,960 --> 00:08:30,960
h of x will output the current constant

201
00:08:30,960 --> 00:08:32,640
with a high probability over random

202
00:08:32,640 --> 00:08:33,599
instance

203
00:08:33,599 --> 00:08:34,479
and

204
00:08:34,479 --> 00:08:37,039
if h of x doesn't output the correct

205
00:08:37,039 --> 00:08:40,000
answer it is guaranteed that h of x

206
00:08:40,000 --> 00:08:42,479
outputs spots

207
00:08:42,479 --> 00:08:44,080
so the difference between these two

208
00:08:44,080 --> 00:08:45,680
notions is that

209
00:08:45,680 --> 00:08:48,399
a two-sided error average case jurassic

210
00:08:48,399 --> 00:08:50,880
is unaware of any mistakes

211
00:08:50,880 --> 00:08:53,519
so if the periodic output zero it's

212
00:08:53,519 --> 00:08:55,920
unclear whether l affirmative is also

213
00:08:55,920 --> 00:08:57,200
zero

214
00:08:57,200 --> 00:08:59,920
however an errorless average case

215
00:08:59,920 --> 00:09:03,519
heuristic knows it when making a mistake

216
00:09:03,519 --> 00:09:07,200
so if h of x doesn't output spots then

217
00:09:07,200 --> 00:09:09,839
it is guaranteed that the h of x outputs

218
00:09:09,839 --> 00:09:11,839
the correct answer

219
00:09:11,839 --> 00:09:14,160
and in this work we actually consider

220
00:09:14,160 --> 00:09:16,959
the bpp analog of these two classes and

221
00:09:16,959 --> 00:09:18,880
the difference of these two classes

222
00:09:18,880 --> 00:09:22,080
remains the same

223
00:09:22,080 --> 00:09:24,000
we are ready to present our main theorem

224
00:09:24,000 --> 00:09:26,000
formally we show that

225
00:09:26,000 --> 00:09:27,920
the existence of infinite overlapping

226
00:09:27,920 --> 00:09:31,279
functions is equivalent to mktp it's not

227
00:09:31,279 --> 00:09:33,200
inside here at bpp

228
00:09:33,200 --> 00:09:34,080
and

229
00:09:34,080 --> 00:09:37,200
x is not equal to ppp is equivalent to

230
00:09:37,200 --> 00:09:41,360
mktp it's not inside average vpp

231
00:09:41,360 --> 00:09:44,160
so basing when functions on xp is not

232
00:09:44,160 --> 00:09:47,279
equal to pvp boils down to a seemingly

233
00:09:47,279 --> 00:09:49,600
minor technical problem

234
00:09:49,600 --> 00:09:51,920
and we showed that proving the

235
00:09:51,920 --> 00:09:55,200
implication that mktp is not in fgbp

236
00:09:55,200 --> 00:09:58,320
implies mkgp is not in here acid bpp is

237
00:09:58,320 --> 00:10:00,880
exactly what we need to base infantry

238
00:10:00,880 --> 00:10:03,120
overwhelm function and x is not equal to

239
00:10:03,120 --> 00:10:05,200
bpp

240
00:10:05,200 --> 00:10:07,120
and we remark here that we can also

241
00:10:07,120 --> 00:10:09,120
characterize standard runway functions

242
00:10:09,120 --> 00:10:10,959
by considering an almost everywhere

243
00:10:10,959 --> 00:10:13,680
notion of every case terms

244
00:10:13,680 --> 00:10:15,920
so it seems that this implication is

245
00:10:15,920 --> 00:10:18,000
really important to us and we really

246
00:10:18,000 --> 00:10:19,680
want to prove this

247
00:10:19,680 --> 00:10:22,399
but the next theorem says that okay if

248
00:10:22,399 --> 00:10:24,480
we want to prove this implication we

249
00:10:24,480 --> 00:10:27,920
have to prove mp is not equal to p

250
00:10:27,920 --> 00:10:30,240
so there are two ways to interpret this

251
00:10:30,240 --> 00:10:32,240
theorem and the pessimistic

252
00:10:32,240 --> 00:10:34,399
interpretation would be that closing

253
00:10:34,399 --> 00:10:37,600
this minor gap will be very hard

254
00:10:37,600 --> 00:10:39,600
and the optimistic interpretation would

255
00:10:39,600 --> 00:10:41,920
be that this is a new algorithmic

256
00:10:41,920 --> 00:10:44,079
approach towards proving mp is not equal

257
00:10:44,079 --> 00:10:45,360
to p

258
00:10:45,360 --> 00:10:48,160
just solve the mktp problem

259
00:10:48,160 --> 00:10:49,120
every

260
00:10:49,120 --> 00:10:51,120
errorlessly on average

261
00:10:51,120 --> 00:10:53,440
having access to a two-sided error

262
00:10:53,440 --> 00:10:57,279
heuristic for the same problem

263
00:10:57,279 --> 00:11:00,160
and let us mention some related work a

264
00:11:00,160 --> 00:11:02,399
first element at all shows the x

265
00:11:02,399 --> 00:11:04,880
completeness of mktp with respect to

266
00:11:04,880 --> 00:11:06,959
pss-following reductions

267
00:11:06,959 --> 00:11:09,519
they show that if x is not inside pixel

268
00:11:09,519 --> 00:11:11,839
trolley then mktp is not inside precise

269
00:11:11,839 --> 00:11:13,040
volume

270
00:11:13,040 --> 00:11:16,399
and the aspect 20 shows when functions

271
00:11:16,399 --> 00:11:19,040
exist if and only if

272
00:11:19,040 --> 00:11:21,200
this t times a time bounded homogeneous

273
00:11:21,200 --> 00:11:23,440
capacity is hard on average

274
00:11:23,440 --> 00:11:25,200
so this time boundary common competitive

275
00:11:25,200 --> 00:11:28,240
problem is another common competitor

276
00:11:28,240 --> 00:11:29,200
problem

277
00:11:29,200 --> 00:11:31,680
however it is unknown that this problem

278
00:11:31,680 --> 00:11:34,640
is x complete however the problem we

279
00:11:34,640 --> 00:11:38,560
look at today is x and complete

280
00:11:38,560 --> 00:11:40,880
and concurrently and independently then

281
00:11:40,880 --> 00:11:43,040
and thunder also shows an equivalence

282
00:11:43,040 --> 00:11:44,959
between wire functions and mild output

283
00:11:44,959 --> 00:11:48,079
hardness of mktp

284
00:11:48,079 --> 00:11:51,279
so in conclusion today we have seen that

285
00:11:51,279 --> 00:11:53,920
the only gap of basing infinity

286
00:11:53,920 --> 00:11:56,160
overwhelm functions and x is not equal

287
00:11:56,160 --> 00:11:59,040
to bpp is the seemingly minor technical

288
00:11:59,040 --> 00:12:00,480
problem

289
00:12:00,480 --> 00:12:03,200
however proving this implication also

290
00:12:03,200 --> 00:12:05,600
shows that mp is not equal to p which

291
00:12:05,600 --> 00:12:08,320
gives us a new algorithmic approach

292
00:12:08,320 --> 00:12:10,399
towards solving the empty versus p

293
00:12:10,399 --> 00:12:12,399
problem

294
00:12:12,399 --> 00:12:14,720
and thank you for listening and

295
00:12:14,720 --> 00:12:18,000
questions are welcome

296
00:12:18,560 --> 00:12:21,040
thank you

297
00:12:22,839 --> 00:12:24,880
questions uh

298
00:12:24,880 --> 00:12:26,079
please

299
00:12:26,079 --> 00:12:29,440
feel free to meet yourself and ask

300
00:12:29,440 --> 00:12:32,480
or ask in the chat

301
00:12:33,200 --> 00:12:35,920
uh oh question here yeah

302
00:12:35,920 --> 00:12:38,000
yes can you say can you say more about

303
00:12:38,000 --> 00:12:41,279
what it means to prove that uh this

304
00:12:41,279 --> 00:12:43,519
implication

305
00:12:43,519 --> 00:12:46,079
also proves p not equal to np

306
00:12:46,079 --> 00:12:48,000
but that somehow parses a bit strangely

307
00:12:48,000 --> 00:12:49,440
to me can you

308
00:12:49,440 --> 00:12:51,040
expand on

309
00:12:51,040 --> 00:12:52,880
yeah so

310
00:12:52,880 --> 00:12:54,880
yeah so basically

311
00:12:54,880 --> 00:12:57,200
uh this theorem says okay if this

312
00:12:57,200 --> 00:12:59,200
implication holds then

313
00:12:59,200 --> 00:13:00,000
uh

314
00:13:00,000 --> 00:13:02,240
the consequence of this is that the mp

315
00:13:02,240 --> 00:13:04,079
is not equal to p

316
00:13:04,079 --> 00:13:07,040
and so basically the way we prove this

317
00:13:07,040 --> 00:13:09,279
is basically through our men's theorem

318
00:13:09,279 --> 00:13:10,399
so

319
00:13:10,399 --> 00:13:11,440
uh

320
00:13:11,440 --> 00:13:13,200
like you you can

321
00:13:13,200 --> 00:13:15,519
so if this implication holds then there

322
00:13:15,519 --> 00:13:17,120
are two cases

323
00:13:17,120 --> 00:13:20,560
a one case is mktp is not in average pvp

324
00:13:20,560 --> 00:13:22,480
then we have one function therefore mp

325
00:13:22,480 --> 00:13:24,399
is not equal to p

326
00:13:24,399 --> 00:13:27,680
and sec uh second if mktp is in average

327
00:13:27,680 --> 00:13:31,760
vpp then we can reach a contradiction so

328
00:13:31,760 --> 00:13:33,360
so basically

329
00:13:33,360 --> 00:13:35,600
we are saying that if this implication

330
00:13:35,600 --> 00:13:37,040
is true then

331
00:13:37,040 --> 00:13:40,079
mp is not equal to p so like anyone

332
00:13:40,079 --> 00:13:43,199
proves this implication would also

333
00:13:43,199 --> 00:13:47,279
prove mp is not equal to p

334
00:13:48,639 --> 00:13:50,800
yes thank you

335
00:13:50,800 --> 00:13:54,160
yeah thank you for your question

336
00:13:54,160 --> 00:13:56,639
um okay so so uh any other questions

337
00:13:56,639 --> 00:13:58,880
there are a bunch of questions on uh on

338
00:13:58,880 --> 00:14:00,639
the chat that somebody

339
00:14:00,639 --> 00:14:03,920
want to unmute and ask or should i read

340
00:14:03,920 --> 00:14:07,000
[Music]

341
00:14:08,959 --> 00:14:10,720
so my question was same as chris's

342
00:14:10,720 --> 00:14:12,800
question so i think it was answered yeah

343
00:14:12,800 --> 00:14:14,959
thanks

344
00:14:14,959 --> 00:14:17,440
okay um

345
00:14:17,440 --> 00:14:18,560
so

346
00:14:18,560 --> 00:14:20,000
um

347
00:14:20,000 --> 00:14:21,680
you know pick one of them so is there

348
00:14:21,680 --> 00:14:22,959
the question is is there something

349
00:14:22,959 --> 00:14:24,320
interesting to say about the hardness

350
00:14:24,320 --> 00:14:26,480
against algorithms that make one-sided

351
00:14:26,480 --> 00:14:28,399
error

352
00:14:28,399 --> 00:14:29,760
uh

353
00:14:29,760 --> 00:14:33,199
i think uh make one side error uh

354
00:14:33,199 --> 00:14:34,880
it depends on

355
00:14:34,880 --> 00:14:38,160
which one sets which one sides like you

356
00:14:38,160 --> 00:14:39,519
are

357
00:14:39,519 --> 00:14:41,279
so if you

358
00:14:41,279 --> 00:14:43,920
uh if you making no mistakes on yes

359
00:14:43,920 --> 00:14:45,600
instance but only

360
00:14:45,600 --> 00:14:47,839
heirs oh no

361
00:14:47,839 --> 00:14:49,440
i think like

362
00:14:49,440 --> 00:14:52,480
that case is like similar in similar

363
00:14:52,480 --> 00:14:54,320
with this errorless

364
00:14:54,320 --> 00:14:56,720
case errorless case

365
00:14:56,720 --> 00:15:00,160
i however if you can make mistakes on

366
00:15:00,160 --> 00:15:02,480
guest instances but you make no mistake

367
00:15:02,480 --> 00:15:05,440
on no instances uh the case is more

368
00:15:05,440 --> 00:15:07,519
similar with this two-sided error

369
00:15:07,519 --> 00:15:10,079
application harness so it really depends

370
00:15:10,079 --> 00:15:11,440
on which

371
00:15:11,440 --> 00:15:16,399
uh your like the mistake uh happens

372
00:15:16,399 --> 00:15:19,440
yeah is that clear

373
00:15:21,199 --> 00:15:22,800
so

374
00:15:22,800 --> 00:15:24,480
this is another yeah thank you so it's

375
00:15:24,480 --> 00:15:26,399
another question here so so what if we

376
00:15:26,399 --> 00:15:29,360
assume p is not equal to np then can we

377
00:15:29,360 --> 00:15:31,120
uh still hope to prove the

378
00:15:31,120 --> 00:15:32,959
implication

379
00:15:32,959 --> 00:15:35,519
uh yes of course uh

380
00:15:35,519 --> 00:15:39,360
if we assume p is not equal to mp then

381
00:15:39,360 --> 00:15:42,240
there's no contradiction

382
00:15:42,240 --> 00:15:43,120
okay

383
00:15:43,120 --> 00:15:46,000
so this implication is like only

384
00:15:46,000 --> 00:15:48,240
uh

385
00:15:49,519 --> 00:15:52,880
it's like only weaker

386
00:15:53,279 --> 00:15:55,199
yeah thank you for

387
00:15:55,199 --> 00:15:58,800
uh your question yeah

388
00:15:59,199 --> 00:16:00,400
so so uh um

389
00:16:00,400 --> 00:16:02,480
[Music]

390
00:16:02,480 --> 00:16:04,079
so now another question kind of like

391
00:16:04,079 --> 00:16:05,600
maybe uh

392
00:16:05,600 --> 00:16:07,920
open-ended so you're talking about

393
00:16:07,920 --> 00:16:11,120
building uh one way functions from uh

394
00:16:11,120 --> 00:16:12,880
complexity the hardest of from goal

395
00:16:12,880 --> 00:16:14,160
complexity

396
00:16:14,160 --> 00:16:16,880
uh um what about uh building other

397
00:16:16,880 --> 00:16:19,360
primitives directly from harness

398
00:16:19,360 --> 00:16:21,600
karma golf complexity not just many

399
00:16:21,600 --> 00:16:22,959
functions

400
00:16:22,959 --> 00:16:25,120
do we have chances to do something nice

401
00:16:25,120 --> 00:16:26,480
there to break

402
00:16:26,480 --> 00:16:29,040
some you know black box impossibility

403
00:16:29,040 --> 00:16:32,880
results etc or not break but go around

404
00:16:32,880 --> 00:16:33,600
yeah

405
00:16:33,600 --> 00:16:36,000
this is a great question and i think we

406
00:16:36,000 --> 00:16:38,959
are still working on that and

407
00:16:38,959 --> 00:16:42,160
right now it seems there's not much hope

408
00:16:42,160 --> 00:16:43,600
and uh

409
00:16:43,600 --> 00:16:45,279
we don't know we don't even know like

410
00:16:45,279 --> 00:16:47,920
how to base regular runway function on

411
00:16:47,920 --> 00:16:51,759
commodore capacity so yeah but uh you

412
00:16:51,759 --> 00:16:54,079
know we're keep working on this

413
00:16:54,079 --> 00:16:55,360
okay

414
00:16:55,360 --> 00:16:56,800
thanks

415
00:16:56,800 --> 00:16:59,920
yeah thanks for the

416
00:17:00,560 --> 00:17:01,600
thank you

417
00:17:01,600 --> 00:17:03,759
so thank you again and here's a great

418
00:17:03,759 --> 00:17:07,280
result congratulations again

419
00:17:07,599 --> 00:17:08,880
and um

420
00:17:08,880 --> 00:17:11,520
okay so let's move on to uh uh to the

421
00:17:11,520 --> 00:17:15,359
second uh figure uh uh in the session

422
00:17:15,359 --> 00:17:18,959
uh that's the second uh

423
00:17:18,959 --> 00:17:21,679
uh yeah so uh the second paper is in

424
00:17:21,679 --> 00:17:24,559
linear crypto analysis of failure 3-1

425
00:17:24,559 --> 00:17:25,839
and fea

426
00:17:25,839 --> 00:17:28,880
uh uh and this is uh uh swiss earlier is

427
00:17:28,880 --> 00:17:31,600
the best uh young researcher of the

428
00:17:31,600 --> 00:17:32,400
award

429
00:17:32,400 --> 00:17:36,080
uh winner and also uh honorable mention

430
00:17:36,080 --> 00:17:38,240
for the best paper award and the author

431
00:17:38,240 --> 00:17:43,120
is tim bain and uh team please go ahead

432
00:17:43,120 --> 00:17:46,120
thanks

433
00:17:54,799 --> 00:17:55,600
so

434
00:17:55,600 --> 00:17:57,760
in this work i'll uh present new attacks

435
00:17:57,760 --> 00:17:59,760
based on linear cryptanalysis or for

436
00:17:59,760 --> 00:18:02,000
preserving encryption standards

437
00:18:02,000 --> 00:18:03,120
so

438
00:18:03,120 --> 00:18:05,840
format preserving encryption um allows

439
00:18:05,840 --> 00:18:06,640
you

440
00:18:06,640 --> 00:18:08,640
to encrypt a plain text that has a

441
00:18:08,640 --> 00:18:10,080
certain format

442
00:18:10,080 --> 00:18:11,200
like

443
00:18:11,200 --> 00:18:13,440
for instance a six digit integer

444
00:18:13,440 --> 00:18:15,200
so that the cipher text has the same

445
00:18:15,200 --> 00:18:16,480
format

446
00:18:16,480 --> 00:18:18,160
so for example if you're encrypting the

447
00:18:18,160 --> 00:18:19,840
six middle digits of a credit card

448
00:18:19,840 --> 00:18:21,760
number and you have a legacy system that

449
00:18:21,760 --> 00:18:23,760
only allows you to store six digit

450
00:18:23,760 --> 00:18:25,840
integers you need this

451
00:18:25,840 --> 00:18:27,120
of course

452
00:18:27,120 --> 00:18:29,039
because there aren't many six digit

453
00:18:29,039 --> 00:18:30,960
integers this would give codebook

454
00:18:30,960 --> 00:18:32,080
attacks

455
00:18:32,080 --> 00:18:34,559
so that's why we need a tweak which is

456
00:18:34,559 --> 00:18:37,840
um like an additional public parameter

457
00:18:37,840 --> 00:18:40,720
and so if you change a tweak ideally you

458
00:18:40,720 --> 00:18:42,640
should get a different looking block

459
00:18:42,640 --> 00:18:43,919
cipher

460
00:18:43,919 --> 00:18:45,360
so there are standards for this in the

461
00:18:45,360 --> 00:18:46,960
u.s there's the

462
00:18:46,960 --> 00:18:50,240
list standards ff1 and ff3 in south

463
00:18:50,240 --> 00:18:52,799
korea the sophia family of block ciphers

464
00:18:52,799 --> 00:18:55,360
and the attacks i'll present apply to

465
00:18:55,360 --> 00:18:56,480
one

466
00:18:56,480 --> 00:19:00,640
and then this fear family but not to ff1

467
00:19:00,640 --> 00:19:01,520
so

468
00:19:01,520 --> 00:19:03,520
these ciphers

469
00:19:03,520 --> 00:19:05,280
are physical cyphers

470
00:19:05,280 --> 00:19:08,480
and um in the case of vr1 it's a really

471
00:19:08,480 --> 00:19:10,240
classical physical cypher you're

472
00:19:10,240 --> 00:19:13,280
basically exuring the branches

473
00:19:13,280 --> 00:19:16,400
and in the case of ff3 the branches are

474
00:19:16,400 --> 00:19:20,000
added using a modular edition

475
00:19:20,000 --> 00:19:21,440
now there's there's a bunch of other

476
00:19:21,440 --> 00:19:23,039
differences that we can

477
00:19:23,039 --> 00:19:24,720
mostly ignore but what

478
00:19:24,720 --> 00:19:26,480
what they have in common and this is

479
00:19:26,480 --> 00:19:28,960
really important is that the tweak is

480
00:19:28,960 --> 00:19:30,799
split into two parts there's a left

481
00:19:30,799 --> 00:19:34,160
tweak and a right tweak so tl and tr

482
00:19:34,160 --> 00:19:35,360
and

483
00:19:35,360 --> 00:19:37,520
these are used in an alternating way

484
00:19:37,520 --> 00:19:39,520
so for example in the even rounds we

485
00:19:39,520 --> 00:19:40,960
always use the right tweak and in the

486
00:19:40,960 --> 00:19:42,960
old rounds we always use the left tweak

487
00:19:42,960 --> 00:19:44,880
and that will be the basis for the

488
00:19:44,880 --> 00:19:46,240
ethics

489
00:19:46,240 --> 00:19:48,000
so there have been

490
00:19:48,000 --> 00:19:50,080
of course there has been a lot of work

491
00:19:50,080 --> 00:19:52,720
on the security of fisa ciphers generic

492
00:19:52,720 --> 00:19:53,760
security

493
00:19:53,760 --> 00:19:56,559
so even at the time of the design of

494
00:19:56,559 --> 00:19:58,799
ff3 it was known that you can

495
00:19:58,799 --> 00:20:00,720
distinguish such reconstruction with

496
00:20:00,720 --> 00:20:03,039
some amount of data and later on it was

497
00:20:03,039 --> 00:20:04,840
also shown that you can do message

498
00:20:04,840 --> 00:20:07,039
recovery so

499
00:20:07,039 --> 00:20:11,039
then at crypto 2017 there were a number

500
00:20:11,039 --> 00:20:13,039
of dedicated detects on this nist

501
00:20:13,039 --> 00:20:14,960
standard ff3

502
00:20:14,960 --> 00:20:16,559
where it was shown that there's a flaw

503
00:20:16,559 --> 00:20:18,720
in this streak schedule

504
00:20:18,720 --> 00:20:21,120
and that leads to slide ethics of course

505
00:20:21,120 --> 00:20:23,360
this did respond to those attacks so

506
00:20:23,360 --> 00:20:25,760
they modified the tweak schedule um

507
00:20:25,760 --> 00:20:28,960
that's why i'm talking about ff31

508
00:20:28,960 --> 00:20:31,120
and this this modification destroys this

509
00:20:31,120 --> 00:20:33,440
um this dedicated that

510
00:20:33,440 --> 00:20:36,880
they also required that the domain size

511
00:20:36,880 --> 00:20:38,960
is at least one million

512
00:20:38,960 --> 00:20:40,480
and that doesn't completely prevent the

513
00:20:40,480 --> 00:20:42,080
generic attacks but it does make them

514
00:20:42,080 --> 00:20:44,880
essentially uh much harder because the

515
00:20:44,880 --> 00:20:46,559
amount of data you need

516
00:20:46,559 --> 00:20:49,760
grows with this uh with this n

517
00:20:49,760 --> 00:20:52,240
so the newer text will be

518
00:20:52,240 --> 00:20:54,559
essentially generic but we use this

519
00:20:54,559 --> 00:20:57,919
property that the tweaks alternate that

520
00:20:57,919 --> 00:21:00,240
will be really important

521
00:21:00,240 --> 00:21:01,919
and the data complexity of the attacks

522
00:21:01,919 --> 00:21:03,919
is about the square roots of the data

523
00:21:03,919 --> 00:21:05,360
complexity

524
00:21:05,360 --> 00:21:07,840
of previous attacks so that shows for

525
00:21:07,840 --> 00:21:10,480
example that this nist requirement of a

526
00:21:10,480 --> 00:21:12,960
minimum domain size of 1 million

527
00:21:12,960 --> 00:21:15,120
really isn't enough

528
00:21:15,120 --> 00:21:17,760
so i'll try to give a high level uh idea

529
00:21:17,760 --> 00:21:20,400
of how this detect works so suppose you

530
00:21:20,400 --> 00:21:22,799
take a random four bit function so you

531
00:21:22,799 --> 00:21:24,640
just from the set of all possible four

532
00:21:24,640 --> 00:21:26,799
bit functions select one uniformly at

533
00:21:26,799 --> 00:21:29,600
random and then you look at this output

534
00:21:29,600 --> 00:21:31,360
distribution of this function so you

535
00:21:31,360 --> 00:21:32,880
count how many

536
00:21:32,880 --> 00:21:35,600
inputs are mapped to a given output

537
00:21:35,600 --> 00:21:37,440
and then actually typically this

538
00:21:37,440 --> 00:21:40,960
distribution will not be very uniform

539
00:21:40,960 --> 00:21:42,960
if it was a large random function it

540
00:21:42,960 --> 00:21:45,120
would be pretty close to uniform but for

541
00:21:45,120 --> 00:21:47,039
small functions there's actually a lot

542
00:21:47,039 --> 00:21:48,880
of variability so there's a good chance

543
00:21:48,880 --> 00:21:50,000
that you don't get a uniform

544
00:21:50,000 --> 00:21:51,360
distribution

545
00:21:51,360 --> 00:21:52,880
and another way of thinking about it

546
00:21:52,880 --> 00:21:55,520
which i'm i'm not gonna go into

547
00:21:55,520 --> 00:21:57,360
too much here is that you can take the

548
00:21:57,360 --> 00:21:59,440
fourier transform of that distribution

549
00:21:59,440 --> 00:22:02,400
and that means we're going to look at

550
00:22:02,400 --> 00:22:04,720
which linear combinations of outputs of

551
00:22:04,720 --> 00:22:06,559
this function are highly biased that

552
00:22:06,559 --> 00:22:07,520
will be

553
00:22:07,520 --> 00:22:09,280
very closely related of course to linear

554
00:22:09,280 --> 00:22:10,799
tips analysis

555
00:22:10,799 --> 00:22:12,720
so what can we do with this observation

556
00:22:12,720 --> 00:22:14,960
about non-uniform output distributions

557
00:22:14,960 --> 00:22:15,919
well

558
00:22:15,919 --> 00:22:17,440
so remember we have this alternating

559
00:22:17,440 --> 00:22:20,000
tweak property so what happens if we fix

560
00:22:20,000 --> 00:22:22,080
for example the left tweak

561
00:22:22,080 --> 00:22:24,720
so now actually this f1 so before it was

562
00:22:24,720 --> 00:22:26,640
actually a big function had many inputs

563
00:22:26,640 --> 00:22:28,000
but now it has

564
00:22:28,000 --> 00:22:29,919
not too many inputs because the domain

565
00:22:29,919 --> 00:22:31,600
is typically small

566
00:22:31,600 --> 00:22:33,280
so that means that the output

567
00:22:33,280 --> 00:22:35,840
distribution of f1

568
00:22:35,840 --> 00:22:37,840
so that's the distribution when the

569
00:22:37,840 --> 00:22:39,200
right half of the

570
00:22:39,200 --> 00:22:41,200
left half of ciphertext

571
00:22:41,200 --> 00:22:43,280
of plaintext sorry and the right of the

572
00:22:43,280 --> 00:22:45,039
tweak are all uniform random so that

573
00:22:45,039 --> 00:22:47,760
distribution will be not uniform in some

574
00:22:47,760 --> 00:22:50,000
way and actually this output is just the

575
00:22:50,000 --> 00:22:51,280
same as the

576
00:22:51,280 --> 00:22:53,600
sum or xor of the left half of the

577
00:22:53,600 --> 00:22:55,039
plaintext and the left half of the

578
00:22:55,039 --> 00:22:57,520
ciphertext so that would be a two-round

579
00:22:57,520 --> 00:22:58,799
distinguisher

580
00:22:58,799 --> 00:23:00,720
of course we need to somehow quantify

581
00:23:00,720 --> 00:23:02,880
what it means for this to be non-uniform

582
00:23:02,880 --> 00:23:04,559
and we also need to iterate this over

583
00:23:04,559 --> 00:23:06,080
many more rounds

584
00:23:06,080 --> 00:23:07,840
and that's what we're using uh linear

585
00:23:07,840 --> 00:23:09,679
cryptanalysis for

586
00:23:09,679 --> 00:23:12,080
so if you do the analysis you find that

587
00:23:12,080 --> 00:23:14,400
there's an iterative linear trail

588
00:23:14,400 --> 00:23:16,159
so that's the one actually shown here on

589
00:23:16,159 --> 00:23:17,919
the right

590
00:23:17,919 --> 00:23:20,480
which has a a pretty good correlation of

591
00:23:20,480 --> 00:23:22,799
one over these domains or square root of

592
00:23:22,799 --> 00:23:26,000
domains has to the power of r over two

593
00:23:26,000 --> 00:23:27,280
so

594
00:23:27,280 --> 00:23:29,280
um for ff3 it's a little bit different

595
00:23:29,280 --> 00:23:30,960
because we have these modular additions

596
00:23:30,960 --> 00:23:32,799
but it's not a real problem because we

597
00:23:32,799 --> 00:23:35,520
can just use a generalization of linear

598
00:23:35,520 --> 00:23:36,799
key analysis

599
00:23:36,799 --> 00:23:39,840
to the group of integers uh mod n with

600
00:23:39,840 --> 00:23:41,520
with addition

601
00:23:41,520 --> 00:23:43,120
and

602
00:23:43,120 --> 00:23:44,640
if you do a little bit of additional

603
00:23:44,640 --> 00:23:46,320
tricks you can get

604
00:23:46,320 --> 00:23:47,919
the data complexity of this

605
00:23:47,919 --> 00:23:50,159
distinguisher down to something n to the

606
00:23:50,159 --> 00:23:52,960
power of r over two minus one

607
00:23:52,960 --> 00:23:55,120
um but this isn't optimal yet because

608
00:23:55,120 --> 00:23:56,799
we're just using one approximation

609
00:23:56,799 --> 00:23:58,240
there's only one

610
00:23:58,240 --> 00:24:00,640
mask u one linear combination of the

611
00:24:00,640 --> 00:24:02,159
outputs that we're using but we could

612
00:24:02,159 --> 00:24:03,600
use any so

613
00:24:03,600 --> 00:24:05,440
this is a good step to in the analysis

614
00:24:05,440 --> 00:24:08,080
but we really need to use all of them

615
00:24:08,080 --> 00:24:09,039
and

616
00:24:09,039 --> 00:24:11,679
since actually the set of all these

617
00:24:11,679 --> 00:24:13,600
values u that we can use is a vector

618
00:24:13,600 --> 00:24:14,960
space we can use what's called

619
00:24:14,960 --> 00:24:16,480
multi-dimensional

620
00:24:16,480 --> 00:24:19,200
linear distinguishes so

621
00:24:19,200 --> 00:24:20,880
an easy way to

622
00:24:20,880 --> 00:24:23,279
sort of describe that is by what's

623
00:24:23,279 --> 00:24:25,600
called a chi-squared distinguisher

624
00:24:25,600 --> 00:24:28,000
so what we do here is we

625
00:24:28,000 --> 00:24:30,000
estimate an output distribution so in

626
00:24:30,000 --> 00:24:32,000
this case it will be the distribution of

627
00:24:32,000 --> 00:24:34,320
the left half of the plaintext

628
00:24:34,320 --> 00:24:37,600
plus the left half of the ciphertext

629
00:24:37,600 --> 00:24:39,679
we make an empirical estimate of that

630
00:24:39,679 --> 00:24:41,919
and then we basically compute

631
00:24:41,919 --> 00:24:43,679
the euclidean distance from that

632
00:24:43,679 --> 00:24:47,360
estimate to the uniform distribution

633
00:24:47,360 --> 00:24:49,760
and because of the linear analysis we

634
00:24:49,760 --> 00:24:50,480
did

635
00:24:50,480 --> 00:24:52,480
we know more or less what this chi

636
00:24:52,480 --> 00:24:54,240
squared statistic should be and we also

637
00:24:54,240 --> 00:24:58,240
know it's it's going to be quite large

638
00:24:58,240 --> 00:24:59,200
and

639
00:24:59,200 --> 00:25:01,120
so this is uh

640
00:25:01,120 --> 00:25:03,039
then a distinguisher and it's a

641
00:25:03,039 --> 00:25:05,200
distinction with a data complexity which

642
00:25:05,200 --> 00:25:06,799
is about a square root of and better

643
00:25:06,799 --> 00:25:09,120
than the than just using a simple linear

644
00:25:09,120 --> 00:25:11,279
distribution

645
00:25:11,279 --> 00:25:13,520
so of course in practice it's always

646
00:25:13,520 --> 00:25:15,919
very interesting not to just have

647
00:25:15,919 --> 00:25:19,200
distinguishes but also message recovery

648
00:25:19,200 --> 00:25:20,400
and

649
00:25:20,400 --> 00:25:22,880
what this means is that so and this is

650
00:25:22,880 --> 00:25:24,720
the same as for previous message

651
00:25:24,720 --> 00:25:26,159
recovery attacks

652
00:25:26,159 --> 00:25:28,400
given the cipher text or secret message

653
00:25:28,400 --> 00:25:30,559
encrypted under many different tweaks we

654
00:25:30,559 --> 00:25:32,799
want to recover that secret message

655
00:25:32,799 --> 00:25:35,840
so how it will work is uh for example

656
00:25:35,840 --> 00:25:38,080
we estimate the distribution of the left

657
00:25:38,080 --> 00:25:42,080
ciphertext for a known message uh blpr

658
00:25:42,080 --> 00:25:44,159
and then we do the same thing for an

659
00:25:44,159 --> 00:25:46,559
unknown message which is just the same

660
00:25:46,559 --> 00:25:48,559
except that for instance the left part

661
00:25:48,559 --> 00:25:50,720
there's an unknown difference added

662
00:25:50,720 --> 00:25:52,480
and then actually these distributions

663
00:25:52,480 --> 00:25:54,400
they will be related to each other in

664
00:25:54,400 --> 00:25:56,080
fact there will be just

665
00:25:56,080 --> 00:25:58,720
shifted roughly by this difference delta

666
00:25:58,720 --> 00:26:01,120
so in this case actually shifted by

667
00:26:01,120 --> 00:26:03,520
one right because zero and one

668
00:26:03,520 --> 00:26:07,600
are kind of flipped in this histogram

669
00:26:07,600 --> 00:26:09,279
and um

670
00:26:09,279 --> 00:26:11,520
so you can that attack essentially

671
00:26:11,520 --> 00:26:13,679
requires about the same amount of data

672
00:26:13,679 --> 00:26:15,760
as the distinction and for write-off

673
00:26:15,760 --> 00:26:16,880
recovery

674
00:26:16,880 --> 00:26:20,000
um you need a little bit more data

675
00:26:20,000 --> 00:26:22,799
um so to conclude um

676
00:26:22,799 --> 00:26:24,159
so i've

677
00:26:24,159 --> 00:26:26,720
tried to explain the basics at least of

678
00:26:26,720 --> 00:26:29,279
of two attacks um

679
00:26:29,279 --> 00:26:30,559
uh

680
00:26:30,559 --> 00:26:31,600
three if you count the linear

681
00:26:31,600 --> 00:26:32,799
distinction

682
00:26:32,799 --> 00:26:36,080
um on ff31 and fear one

683
00:26:36,080 --> 00:26:38,559
which require about square root of data

684
00:26:38,559 --> 00:26:40,799
as previous attacks

685
00:26:40,799 --> 00:26:41,760
um

686
00:26:41,760 --> 00:26:44,080
and uh in the paper i also described

687
00:26:44,080 --> 00:26:46,080
some attacks on fia2 which

688
00:26:46,080 --> 00:26:47,919
required a cube root of the amount of

689
00:26:47,919 --> 00:26:50,080
data of previous it takes

690
00:26:50,080 --> 00:26:53,120
but then again field two has more rounds

691
00:26:53,120 --> 00:26:54,320
um

692
00:26:54,320 --> 00:26:55,919
and also how to turn the message

693
00:26:55,919 --> 00:26:57,840
recovery attack for fear one into a

694
00:26:57,840 --> 00:26:59,120
kiriko

695
00:26:59,120 --> 00:27:01,279
so what's the impact of this so of

696
00:27:01,279 --> 00:27:02,159
course

697
00:27:02,159 --> 00:27:03,760
uh so the ethics

698
00:27:03,760 --> 00:27:06,000
i should say can be completely practical

699
00:27:06,000 --> 00:27:08,480
but some applications don't allow you to

700
00:27:08,480 --> 00:27:10,960
use a lot of data sometimes the domain

701
00:27:10,960 --> 00:27:13,279
size is large so smaller domain size

702
00:27:13,279 --> 00:27:15,600
means you're more vulnerable the big

703
00:27:15,600 --> 00:27:17,200
problem here is essentially that every

704
00:27:17,200 --> 00:27:18,960
application of these standards needs to

705
00:27:18,960 --> 00:27:21,120
be carefully checked

706
00:27:21,120 --> 00:27:22,720
so

707
00:27:22,720 --> 00:27:24,399
that's that's something you definitely

708
00:27:24,399 --> 00:27:27,840
don't want normally from a block cipher

709
00:27:27,840 --> 00:27:30,240
for example if you want for the standard

710
00:27:30,240 --> 00:27:32,720
fft one the same security as before you

711
00:27:32,720 --> 00:27:34,960
would have to use a minimum

712
00:27:34,960 --> 00:27:36,720
n of one million as opposed to one

713
00:27:36,720 --> 00:27:37,919
thousand

714
00:27:37,919 --> 00:27:39,840
but that's just i mean you cannot do

715
00:27:39,840 --> 00:27:41,600
that because that would ruin a lot of

716
00:27:41,600 --> 00:27:43,919
applications so the real thing to do is

717
00:27:43,919 --> 00:27:46,080
of course to to fix the tweak schedule

718
00:27:46,080 --> 00:27:48,399
so for now i would say just avoid uh

719
00:27:48,399 --> 00:27:49,919
these standards

720
00:27:49,919 --> 00:27:52,159
i don't use them if you don't if you're

721
00:27:52,159 --> 00:27:54,159
not already using them if you're already

722
00:27:54,159 --> 00:27:55,760
using them definitely check that you

723
00:27:55,760 --> 00:27:57,919
don't rely just on indistinguishability

724
00:27:57,919 --> 00:27:59,679
because that's yeah that's typically

725
00:27:59,679 --> 00:28:01,120
even easier

726
00:28:01,120 --> 00:28:03,200
not in terms of data but in terms of the

727
00:28:03,200 --> 00:28:05,440
practical conditions

728
00:28:05,440 --> 00:28:06,320
and

729
00:28:06,320 --> 00:28:08,960
definitely don't use small domains

730
00:28:08,960 --> 00:28:12,399
so that's that's everything so

731
00:28:12,399 --> 00:28:14,000
this link here you can

732
00:28:14,000 --> 00:28:15,840
follow that for the source code of the

733
00:28:15,840 --> 00:28:18,080
attacks and if you want to compute

734
00:28:18,080 --> 00:28:20,320
exactly uh how much data you would need

735
00:28:20,320 --> 00:28:21,679
for for

736
00:28:21,679 --> 00:28:22,799
you know the parameters that you're

737
00:28:22,799 --> 00:28:24,080
using

738
00:28:24,080 --> 00:28:26,320
thanks

739
00:28:28,240 --> 00:28:30,399
thank you uh tim

740
00:28:30,399 --> 00:28:31,600
um

741
00:28:31,600 --> 00:28:34,799
thank you very much uh any questions can

742
00:28:34,799 --> 00:28:38,559
please feel free to unmute yourself

743
00:28:43,679 --> 00:28:46,000
so there's uh there's a question in the

744
00:28:46,000 --> 00:28:48,559
chat uh uh why did this standard use

745
00:28:48,559 --> 00:28:51,200
left right tweaks

746
00:28:51,200 --> 00:28:52,640
um

747
00:28:52,640 --> 00:28:54,559
good question why i don't know why it

748
00:28:54,559 --> 00:28:56,720
because for instance ff1 doesn't and

749
00:28:56,720 --> 00:28:58,799
that doesn't have the problem

750
00:28:58,799 --> 00:29:00,480
so um

751
00:29:00,480 --> 00:29:02,880
i guess that for in the case of fia it's

752
00:29:02,880 --> 00:29:05,760
more or less because ff3 used it because

753
00:29:05,760 --> 00:29:08,480
it's a later design i guess they

754
00:29:08,480 --> 00:29:10,640
it makes it i mean one one way could be

755
00:29:10,640 --> 00:29:13,039
like if you want a longer tweak

756
00:29:13,039 --> 00:29:14,080
i mean

757
00:29:14,080 --> 00:29:15,840
you can only put so many bits of tweak

758
00:29:15,840 --> 00:29:18,320
every round so

759
00:29:18,320 --> 00:29:20,720
then you can have a twice as long tweak

760
00:29:20,720 --> 00:29:22,559
maybe that's a reason

761
00:29:22,559 --> 00:29:24,399
although there are also

762
00:29:24,399 --> 00:29:27,840
different ways of achieving that

763
00:29:31,840 --> 00:29:34,399
in fact were there any uh security

764
00:29:34,399 --> 00:29:36,880
claims or either formal and formal

765
00:29:36,880 --> 00:29:38,720
coming of the design or

766
00:29:38,720 --> 00:29:41,200
they just design come

767
00:29:41,200 --> 00:29:42,080
from

768
00:29:42,080 --> 00:29:43,039
so

769
00:29:43,039 --> 00:29:44,000
yeah

770
00:29:44,000 --> 00:29:45,440
i mean of course the

771
00:29:45,440 --> 00:29:47,760
the security of generic faisal cyphers

772
00:29:47,760 --> 00:29:49,679
is quite well understood but the problem

773
00:29:49,679 --> 00:29:52,559
is it's not so well understood for well

774
00:29:52,559 --> 00:29:55,520
if the domain size is small

775
00:29:55,520 --> 00:29:57,840
uh that's hard to get a

776
00:29:57,840 --> 00:29:59,520
good results let's say

777
00:29:59,520 --> 00:30:01,200
so that the main focus on physical

778
00:30:01,200 --> 00:30:03,039
surface has been when the domain size is

779
00:30:03,039 --> 00:30:04,559
large

780
00:30:04,559 --> 00:30:06,080
um

781
00:30:06,080 --> 00:30:08,159
but yeah there has been a lot of

782
00:30:08,159 --> 00:30:09,120
previous

783
00:30:09,120 --> 00:30:13,360
analysis on this scheme so uh

784
00:30:13,360 --> 00:30:15,360
yeah

785
00:30:15,360 --> 00:30:18,799
but well still it was broken

786
00:30:21,120 --> 00:30:24,640
so another question in the chat uh um

787
00:30:24,640 --> 00:30:27,440
uh were you able to identify this flaw

788
00:30:27,440 --> 00:30:29,360
by modeling the primitive in something

789
00:30:29,360 --> 00:30:31,679
like easykeep or you found it by

790
00:30:31,679 --> 00:30:33,919
inspecting the spec

791
00:30:33,919 --> 00:30:36,399
i i just found it uh

792
00:30:36,399 --> 00:30:37,200
by

793
00:30:37,200 --> 00:30:39,679
by looking at it yeah

794
00:30:39,679 --> 00:30:41,840
so uh

795
00:30:41,840 --> 00:30:43,520
yeah i just went through linear quick

796
00:30:43,520 --> 00:30:46,879
analysis directly yeah

797
00:30:47,840 --> 00:30:50,840
okay

798
00:30:52,000 --> 00:30:53,440
uh

799
00:30:53,440 --> 00:30:55,440
so or has a comment that due to this

800
00:30:55,440 --> 00:30:59,120
attack and the improved versions of uh

801
00:30:59,120 --> 00:31:00,720
uh 10 which

802
00:31:00,720 --> 00:31:02,159
this is

803
00:31:02,159 --> 00:31:05,120
which is a similar capacity iso decided

804
00:31:05,120 --> 00:31:07,840
not to standardize the fde at the moment

805
00:31:07,840 --> 00:31:10,399
so at least

806
00:31:14,000 --> 00:31:15,519
um

807
00:31:15,519 --> 00:31:16,640
okay

808
00:31:16,640 --> 00:31:18,960
so there's no more questions

809
00:31:18,960 --> 00:31:21,919
then uh uh team thanks again uh

810
00:31:21,919 --> 00:31:24,880
congratulations for uh the result uh

811
00:31:24,880 --> 00:31:26,880
thanks thank you

812
00:31:26,880 --> 00:31:31,600
very nice and uh let's move on to the uh

813
00:31:31,600 --> 00:31:35,600
to the next paper uh in this session

814
00:31:35,600 --> 00:31:36,559
uh

815
00:31:36,559 --> 00:31:39,279
which is uh official key recovery for

816
00:31:39,279 --> 00:31:42,640
all hiv signature violence by uh

817
00:31:42,640 --> 00:31:44,840
chengdu uh tau

818
00:31:44,840 --> 00:31:47,760
uh petzl and gene

819
00:31:47,760 --> 00:31:50,720
t ding uh and this is an honorable

820
00:31:50,720 --> 00:31:52,480
honorable mention for the best paper of

821
00:31:52,480 --> 00:31:53,200
all

822
00:31:53,200 --> 00:31:57,120
uh um so uh please so uh

823
00:31:57,120 --> 00:32:00,310
who is going to give the uh the talk um

824
00:32:00,310 --> 00:32:02,559
[Music]

825
00:32:02,559 --> 00:32:04,159
i'll practically give the talk so please

826
00:32:04,159 --> 00:32:05,200
go ahead and

827
00:32:05,200 --> 00:32:06,480
help her

828
00:32:06,480 --> 00:32:08,559
thanks can you see my slides

829
00:32:08,559 --> 00:32:11,519
yes thank you yeah okay so

830
00:32:11,519 --> 00:32:13,200
thank you for the introduction and

831
00:32:13,200 --> 00:32:15,360
welcome to my talk on the efficient key

832
00:32:15,360 --> 00:32:19,360
recovery for all hfe signature variants

833
00:32:19,360 --> 00:32:20,159
so

834
00:32:20,159 --> 00:32:22,880
my name is i played petrol and this is a

835
00:32:22,880 --> 00:32:25,360
joint work together with chendong tao

836
00:32:25,360 --> 00:32:28,880
and qin tai ding

837
00:32:28,880 --> 00:32:31,279
so first where are we in this talk so we

838
00:32:31,279 --> 00:32:33,120
are talking about post quantum

839
00:32:33,120 --> 00:32:34,880
cryptography

840
00:32:34,880 --> 00:32:36,559
and in particular multivariate

841
00:32:36,559 --> 00:32:38,960
cryptography and here we

842
00:32:38,960 --> 00:32:40,240
uh

843
00:32:40,240 --> 00:32:43,279
we are in the field of picnic big field

844
00:32:43,279 --> 00:32:46,000
signature schemes

845
00:32:46,000 --> 00:32:48,480
this means that we have a central map f

846
00:32:48,480 --> 00:32:50,480
which is a univariate map over an

847
00:32:50,480 --> 00:32:53,120
extension field f q to the n

848
00:32:53,120 --> 00:32:55,519
and we have an isomorphism phi between

849
00:32:55,519 --> 00:32:57,840
vector space f q to the n

850
00:32:57,840 --> 00:33:00,159
and the extension field

851
00:33:00,159 --> 00:33:02,399
and due to the special structure of the

852
00:33:02,399 --> 00:33:05,919
map f the map f bar phytus minus one so

853
00:33:05,919 --> 00:33:08,880
f stock phi is a quadratic map over the

854
00:33:08,880 --> 00:33:11,919
vector space fq to the n

855
00:33:11,919 --> 00:33:14,000
an important example

856
00:33:14,000 --> 00:33:16,480
of such a big field signature scheme is

857
00:33:16,480 --> 00:33:19,440
a hfe reminisce signature scheme which

858
00:33:19,440 --> 00:33:22,080
combines the idea of big field together

859
00:33:22,080 --> 00:33:24,159
with a minus modification and the

860
00:33:24,159 --> 00:33:25,919
miniature variation

861
00:33:25,919 --> 00:33:28,080
the central left of the scheme is a map

862
00:33:28,080 --> 00:33:30,559
from fq to the v times the extension

863
00:33:30,559 --> 00:33:32,799
field to the extension field

864
00:33:32,799 --> 00:33:35,760
and it has this form shown in the slide

865
00:33:35,760 --> 00:33:37,760
so the important things here are that

866
00:33:37,760 --> 00:33:40,559
the degree of the polynomial is bounded

867
00:33:40,559 --> 00:33:42,240
by big d

868
00:33:42,240 --> 00:33:45,039
and we have here this these linear maps

869
00:33:45,039 --> 00:33:48,640
better i and the map quadratic map gamma

870
00:33:48,640 --> 00:33:53,000
in the so-called miniature variables

871
00:33:53,200 --> 00:33:55,600
then we have choose randomly to linear

872
00:33:55,600 --> 00:33:58,960
maps t and s of maximal rank

873
00:33:58,960 --> 00:34:01,840
and the public key is given as p is t

874
00:34:01,840 --> 00:34:04,320
circ f bar circ

875
00:34:04,320 --> 00:34:06,640
which is a quadratic map from the

876
00:34:06,640 --> 00:34:09,040
vector space f q to the n plus 3 to the

877
00:34:09,040 --> 00:34:12,000
vector space f q to the n minus a

878
00:34:12,000 --> 00:34:14,079
and the private key consists of the

879
00:34:14,079 --> 00:34:16,719
three maps f f and t and therefore

880
00:34:16,719 --> 00:34:21,239
allows to invert the public key

881
00:34:21,440 --> 00:34:23,520
there exists basically two attack

882
00:34:23,520 --> 00:34:25,918
strategies against the hfev miners

883
00:34:25,918 --> 00:34:28,239
signature scheme the first one is a

884
00:34:28,239 --> 00:34:30,239
direct attack which is a signature

885
00:34:30,239 --> 00:34:31,839
fortunery attack

886
00:34:31,839 --> 00:34:33,760
and here we find that the degree of

887
00:34:33,760 --> 00:34:36,800
regularity is bounded from above by this

888
00:34:36,800 --> 00:34:39,280
formula here

889
00:34:39,280 --> 00:34:41,599
which depends on the degree bound the

890
00:34:41,599 --> 00:34:44,320
number of minus equations a and the

891
00:34:44,320 --> 00:34:47,440
number of literature variables

892
00:34:47,440 --> 00:34:49,839
the second attack strategy is a min rank

893
00:34:49,839 --> 00:34:52,879
attack which is a key recovery attack

894
00:34:52,879 --> 00:34:55,359
and when solving the mentoring problem

895
00:34:55,359 --> 00:34:58,160
using the miners approach the complexity

896
00:34:58,160 --> 00:35:00,480
of this attack can be estimated by the

897
00:35:00,480 --> 00:35:03,680
formula here

898
00:35:03,680 --> 00:35:07,920
in our paper here we propose a new

899
00:35:07,920 --> 00:35:11,119
mineral attack against hfe signature

900
00:35:11,119 --> 00:35:12,320
variants

901
00:35:12,320 --> 00:35:14,160
and the complexity of our attack is

902
00:35:14,160 --> 00:35:17,680
given by this formula here

903
00:35:17,680 --> 00:35:20,400
so the main differences are that our

904
00:35:20,400 --> 00:35:22,640
attack is completely independent of the

905
00:35:22,640 --> 00:35:25,200
number of minus equations

906
00:35:25,200 --> 00:35:28,000
and they complete and b only appears in

907
00:35:28,000 --> 00:35:30,480
the first row which means that the

908
00:35:30,480 --> 00:35:32,640
complexity of the attack is polynomial

909
00:35:32,640 --> 00:35:36,560
in the number of miniature variables

910
00:35:37,839 --> 00:35:39,920
so to describe our attack we need a

911
00:35:39,920 --> 00:35:42,240
number of preliminaries so first we use

912
00:35:42,240 --> 00:35:44,640
a so-called matrix representation of the

913
00:35:44,640 --> 00:35:46,720
hfd central map

914
00:35:46,720 --> 00:35:49,440
namely we write the hfe central map as a

915
00:35:49,440 --> 00:35:54,320
quadratic form with a matrix f star zero

916
00:35:54,320 --> 00:35:57,400
and we can easily compute the progenious

917
00:35:57,400 --> 00:36:00,400
isomorphisms as q to the k from this

918
00:36:00,400 --> 00:36:02,240
formula

919
00:36:02,240 --> 00:36:06,560
and here we get the matrices f star k

920
00:36:06,640 --> 00:36:08,320
furthermore we use a matrix

921
00:36:08,320 --> 00:36:10,000
representation of

922
00:36:10,000 --> 00:36:12,720
our isomorphism between the vector space

923
00:36:12,720 --> 00:36:13,920
and the

924
00:36:13,920 --> 00:36:15,920
extension field

925
00:36:15,920 --> 00:36:20,000
and to cover the vintage variables we

926
00:36:20,000 --> 00:36:22,320
define a matrix m tilde which is a block

927
00:36:22,320 --> 00:36:24,400
matrix containing m

928
00:36:24,400 --> 00:36:26,240
and the identity metric for the

929
00:36:26,240 --> 00:36:29,200
miniature variables

930
00:36:29,200 --> 00:36:31,119
and by doing so we get the following

931
00:36:31,119 --> 00:36:33,359
relation between elements of the vector

932
00:36:33,359 --> 00:36:35,359
space and elements of the extension

933
00:36:35,359 --> 00:36:37,759
field

934
00:36:38,640 --> 00:36:41,119
so now let f and p be matrices

935
00:36:41,119 --> 00:36:44,160
representing the linear parts of s and t

936
00:36:44,160 --> 00:36:46,400
and from our

937
00:36:46,400 --> 00:36:48,720
quadratic form of the central map we

938
00:36:48,720 --> 00:36:51,680
find the following

939
00:36:51,680 --> 00:36:54,000
and if we denote here and tilde to the

940
00:36:54,000 --> 00:36:56,800
minus 1 times s tilde to the s to the

941
00:36:56,800 --> 00:36:58,560
minus 1 by u

942
00:36:58,560 --> 00:36:59,440
and

943
00:36:59,440 --> 00:37:03,200
m to the minus 1 times t by w

944
00:37:03,200 --> 00:37:05,839
we get the flowing which i call the

945
00:37:05,839 --> 00:37:09,040
fundamental equation and which will play

946
00:37:09,040 --> 00:37:12,640
a major role in our attack

947
00:37:13,119 --> 00:37:14,320
so here

948
00:37:14,320 --> 00:37:17,680
we have again our fundamental equation

949
00:37:17,680 --> 00:37:18,960
and the

950
00:37:18,960 --> 00:37:21,040
main step of our attack is to recover

951
00:37:21,040 --> 00:37:23,440
the first affine map f

952
00:37:23,440 --> 00:37:26,880
and we observe here that if we denote by

953
00:37:26,880 --> 00:37:29,440
u the first row of the matrix u

954
00:37:29,440 --> 00:37:32,000
and by bi

955
00:37:32,000 --> 00:37:35,760
the first map first row of u

956
00:37:35,760 --> 00:37:38,480
multiplied by the matrix representing

957
00:37:38,480 --> 00:37:40,160
the public key

958
00:37:40,160 --> 00:37:42,480
then we define a metric set

959
00:37:42,480 --> 00:37:45,119
as a row as a matrix whose row vectors

960
00:37:45,119 --> 00:37:47,119
are given by the bi

961
00:37:47,119 --> 00:37:49,520
and then the rank of the metric set is

962
00:37:49,520 --> 00:37:52,480
at most d

963
00:37:52,720 --> 00:37:54,960
and the second important observation is

964
00:37:54,960 --> 00:37:57,920
that the first n rows of the matrix view

965
00:37:57,920 --> 00:38:00,240
are completely different determined by

966
00:38:00,240 --> 00:38:03,879
its first row

967
00:38:05,440 --> 00:38:06,560
so

968
00:38:06,560 --> 00:38:09,599
how does our attack work in a nutshell

969
00:38:09,599 --> 00:38:11,839
so since we have u is n tilde to the

970
00:38:11,839 --> 00:38:14,720
minus one times s to the minus one

971
00:38:14,720 --> 00:38:18,720
we can find s by finding u

972
00:38:18,720 --> 00:38:20,800
and due to our lemma we only have to

973
00:38:20,800 --> 00:38:24,240
first find the first row of u

974
00:38:24,240 --> 00:38:26,240
and if we denote the first row of the

975
00:38:26,240 --> 00:38:28,000
matrix u by

976
00:38:28,000 --> 00:38:30,800
the vector u

977
00:38:31,040 --> 00:38:33,920
we find that we only have to

978
00:38:33,920 --> 00:38:36,560
or that we can assume that u 0 is equal

979
00:38:36,560 --> 00:38:38,480
to 1

980
00:38:38,480 --> 00:38:40,480
and since the rank of the metric set is

981
00:38:40,480 --> 00:38:42,640
smaller or equal to d we can find the

982
00:38:42,640 --> 00:38:45,760
unknown element u1 2 u enter 3 minus 1

983
00:38:45,760 --> 00:38:48,000
by solving a min rank problem over the

984
00:38:48,000 --> 00:38:50,640
base field

985
00:38:50,720 --> 00:38:52,880
the remaining rows of the matrix u can

986
00:38:52,880 --> 00:38:55,040
be chosen at random such that u is

987
00:38:55,040 --> 00:38:56,560
invertible

988
00:38:56,560 --> 00:38:58,960
which means that we have found f

989
00:38:58,960 --> 00:39:02,240
and having found this matrix f it is

990
00:39:02,240 --> 00:39:05,599
easy to recover f and t it is basically

991
00:39:05,599 --> 00:39:10,640
only solving some systems of equations

992
00:39:10,880 --> 00:39:13,119
for the complexity the most costly step

993
00:39:13,119 --> 00:39:15,119
of our attack is the solution of the

994
00:39:15,119 --> 00:39:17,119
mentoring problem

995
00:39:17,119 --> 00:39:19,760
that we need to recover u and f

996
00:39:19,760 --> 00:39:22,960
and when doing this using the milling

997
00:39:22,960 --> 00:39:26,000
the complexity of this step is given by

998
00:39:26,000 --> 00:39:29,520
this formula here

999
00:39:29,520 --> 00:39:32,000
so this table shows the application of

1000
00:39:32,000 --> 00:39:36,240
our attack on the ge mf signature scheme

1001
00:39:36,240 --> 00:39:37,839
which is one of the third round

1002
00:39:37,839 --> 00:39:40,000
candidates in the nist standardization

1003
00:39:40,000 --> 00:39:42,400
process

1004
00:39:42,400 --> 00:39:44,640
and we see that especially for the high

1005
00:39:44,640 --> 00:39:47,280
security levels the proposed parameters

1006
00:39:47,280 --> 00:39:49,680
for the scheme don't reach the required

1007
00:39:49,680 --> 00:39:52,880
security security levels

1008
00:39:52,880 --> 00:39:54,880
we find that speeding up the signature

1009
00:39:54,880 --> 00:39:57,200
generation process of the scheme by

1010
00:39:57,200 --> 00:39:59,920
decreasing the degree bound while

1011
00:39:59,920 --> 00:40:02,720
increasing a and b is not possible which

1012
00:40:02,720 --> 00:40:05,200
makes the modifications as in blue games

1013
00:40:05,200 --> 00:40:06,720
and red games

1014
00:40:06,720 --> 00:40:08,319
impossible

1015
00:40:08,319 --> 00:40:10,880
and thirdly note that for high levels of

1016
00:40:10,880 --> 00:40:14,000
security we need very high values of the

1017
00:40:14,000 --> 00:40:16,800
degree bound t

1018
00:40:16,800 --> 00:40:19,520
for example for the highest security

1019
00:40:19,520 --> 00:40:21,839
level we need small d is greater or

1020
00:40:21,839 --> 00:40:25,440
equal to 20 or big d is greater than 500

1021
00:40:25,440 --> 00:40:27,440
000 which will

1022
00:40:27,440 --> 00:40:29,440
mean a drastical slowdown of the

1023
00:40:29,440 --> 00:40:32,480
signature generation process of hfe

1024
00:40:32,480 --> 00:40:34,720
minus in games

1025
00:40:34,720 --> 00:40:36,720
therefore we comes with a conclusion

1026
00:40:36,720 --> 00:40:39,599
that that techniques used in games don't

1027
00:40:39,599 --> 00:40:42,800
suffice to create an hfe based signature

1028
00:40:42,800 --> 00:40:45,040
scheme which is both efficient and

1029
00:40:45,040 --> 00:40:48,640
reaches high levels of security

1030
00:40:48,640 --> 00:40:50,560
and

1031
00:40:50,560 --> 00:40:53,760
to conclude so in this paper we proposed

1032
00:40:53,760 --> 00:40:56,480
a new mean range attack against hfe

1033
00:40:56,480 --> 00:40:58,160
signature variants

1034
00:40:58,160 --> 00:41:00,079
the complexity of our attack is

1035
00:41:00,079 --> 00:41:02,560
exponential in the degree bound d

1036
00:41:02,560 --> 00:41:04,400
but it is polynomial in the number of

1037
00:41:04,400 --> 00:41:06,800
miniature variables and it is

1038
00:41:06,800 --> 00:41:08,720
independent of the number of minus

1039
00:41:08,720 --> 00:41:11,359
equations

1040
00:41:11,760 --> 00:41:13,680
some consequences

1041
00:41:13,680 --> 00:41:16,079
so first we can't speed up the scheme by

1042
00:41:16,079 --> 00:41:19,760
decreasing d while increasing a and b

1043
00:41:19,760 --> 00:41:21,440
and we find that for high levels of

1044
00:41:21,440 --> 00:41:24,160
security we need a very large value of

1045
00:41:24,160 --> 00:41:26,960
the degree bound d

1046
00:41:26,960 --> 00:41:29,760
and this arises questions if we can

1047
00:41:29,760 --> 00:41:32,640
build an hfe-based signature scheme

1048
00:41:32,640 --> 00:41:34,880
which is both efficient and offers a

1049
00:41:34,880 --> 00:41:38,240
high level of security

1050
00:41:38,240 --> 00:41:40,319
so thank you for your attention and for

1051
00:41:40,319 --> 00:41:42,800
more information on our attack please

1052
00:41:42,800 --> 00:41:45,839
watch the 20 minute video talk or read

1053
00:41:45,839 --> 00:41:49,720
our paper thanks

1054
00:41:50,319 --> 00:41:53,759
thank you very much albert

1055
00:41:54,800 --> 00:41:57,680
any uh questions please feel free to ask

1056
00:41:57,680 --> 00:42:00,680
yourselves

1057
00:42:14,940 --> 00:42:18,039
[Music]

1058
00:42:23,040 --> 00:42:25,359
okay

1059
00:42:27,280 --> 00:42:29,440
[Music]

1060
00:42:29,440 --> 00:42:31,920
okay so if there are uh oh here's a

1061
00:42:31,920 --> 00:42:35,680
question uh um by uh daniel beckman um

1062
00:42:35,680 --> 00:42:38,560
he really is on the chat uh um

1063
00:42:38,560 --> 00:42:41,359
uh mean rank attacks have hit uh uh

1064
00:42:41,359 --> 00:42:43,200
multiply signatures really hard in the

1065
00:42:43,200 --> 00:42:46,160
past do you have any idea how close

1066
00:42:46,160 --> 00:42:49,359
we are to a theory that the mean rank

1067
00:42:49,359 --> 00:42:54,078
attacks are exhausted as an approach

1068
00:42:55,520 --> 00:42:58,520
um

1069
00:43:00,960 --> 00:43:03,839
i think that the authors of

1070
00:43:03,839 --> 00:43:07,680
the human ring papers

1071
00:43:07,920 --> 00:43:09,359
recently

1072
00:43:09,359 --> 00:43:11,599
tried to

1073
00:43:11,599 --> 00:43:12,960
use every

1074
00:43:12,960 --> 00:43:15,440
or really every information that they

1075
00:43:15,440 --> 00:43:17,440
are possible to get

1076
00:43:17,440 --> 00:43:19,359
and therefore i don't think that there

1077
00:43:19,359 --> 00:43:21,599
are

1078
00:43:21,599 --> 00:43:23,280
a

1079
00:43:23,280 --> 00:43:25,440
main possibilities to improve their mind

1080
00:43:25,440 --> 00:43:28,000
rank attack anymore

1081
00:43:28,000 --> 00:43:30,240
but it's only by

1082
00:43:30,240 --> 00:43:33,439
my opinion

1083
00:43:33,839 --> 00:43:35,040
okay

1084
00:43:35,040 --> 00:43:37,520
thank you

1085
00:43:39,359 --> 00:43:40,640
more questions

1086
00:43:40,640 --> 00:43:42,879
uh

1087
00:43:43,760 --> 00:43:45,599
so uh

1088
00:43:45,599 --> 00:43:48,160
okay so

1089
00:43:48,160 --> 00:43:49,680
okay so i think there's some problem

1090
00:43:49,680 --> 00:43:51,040
discussion here anyway so thank you

1091
00:43:51,040 --> 00:43:54,400
again uh uh very much uh albrecht uh um

1092
00:43:54,400 --> 00:43:57,440
again for the uh the uh the great result

1093
00:43:57,440 --> 00:44:00,880
and uh uh let's move on to uh the uh

1094
00:44:00,880 --> 00:44:03,119
last uh session past paper of the

1095
00:44:03,119 --> 00:44:06,480
session last but definitely not least uh

1096
00:44:06,480 --> 00:44:08,960
three hubs makes a whole beating uh uh

1097
00:44:08,960 --> 00:44:10,800
the half gate solar bound for government

1098
00:44:10,800 --> 00:44:13,359
circuits again uh honorable mention for

1099
00:44:13,359 --> 00:44:16,240
bestiary award uh mike russell lawrence

1100
00:44:16,240 --> 00:44:18,079
throwing and lawrence i assume we're

1101
00:44:18,079 --> 00:44:19,280
good to talk

1102
00:44:19,280 --> 00:44:20,480
uh

1103
00:44:20,480 --> 00:44:23,839
please go ahead

1104
00:44:24,000 --> 00:44:25,200
thanks

1105
00:44:25,200 --> 00:44:26,800
hi i'm laurence roy

1106
00:44:26,800 --> 00:44:28,160
i'd like to show you our new garbling

1107
00:44:28,160 --> 00:44:30,480
technique sliced and diced garlic where

1108
00:44:30,480 --> 00:44:31,760
three halves come together to make a

1109
00:44:31,760 --> 00:44:33,920
hole

1110
00:44:33,920 --> 00:44:35,440
crumpled circuits are one main technique

1111
00:44:35,440 --> 00:44:38,319
used for secure function valuation

1112
00:44:38,319 --> 00:44:40,319
one party becomes the garbler and the

1113
00:44:40,319 --> 00:44:42,400
other the evaluator the garbler sends a

1114
00:44:42,400 --> 00:44:43,599
kind of encrypted circuit to the

1115
00:44:43,599 --> 00:44:45,440
evaluator who runs it

1116
00:44:45,440 --> 00:44:46,800
this keeps the values in the circuit

1117
00:44:46,800 --> 00:44:49,520
secure secret from both of them

1118
00:44:49,520 --> 00:44:51,359
sending garbo garbled circuit is a

1119
00:44:51,359 --> 00:44:54,160
bottleneck of the protocol

1120
00:44:54,160 --> 00:44:56,319
ever since yao invented garbled circuits

1121
00:44:56,319 --> 00:44:58,640
researchers have been improving them

1122
00:44:58,640 --> 00:45:00,160
this plot shows the cost of garbling a

1123
00:45:00,160 --> 00:45:01,680
circuit consisting of an and gate and

1124
00:45:01,680 --> 00:45:05,160
the next door gate

1125
00:45:09,359 --> 00:45:11,359
zero e15 found that xoring together two

1126
00:45:11,359 --> 00:45:13,680
half gates makes a whole and gate with

1127
00:45:13,680 --> 00:45:14,800
only two ciphertex worth of

1128
00:45:14,800 --> 00:45:16,079
communication

1129
00:45:16,079 --> 00:45:17,520
this was the state of the art for six

1130
00:45:17,520 --> 00:45:19,200
years and it was even proven optimal in

1131
00:45:19,200 --> 00:45:21,119
a restricted model

1132
00:45:21,119 --> 00:45:23,440
however our new garbling scheme

1133
00:45:23,440 --> 00:45:25,040
uh in our new garbling scheme and the

1134
00:45:25,040 --> 00:45:26,240
and gate can now be garbled with just

1135
00:45:26,240 --> 00:45:27,680
three halves of ciphertex while

1136
00:45:27,680 --> 00:45:31,359
maintaining compatibility with free xor

1137
00:45:31,599 --> 00:45:33,280
in a garbled circuit the function f is

1138
00:45:33,280 --> 00:45:34,640
broken down into gates connected with

1139
00:45:34,640 --> 00:45:38,079
wires here's a wire carrying one bit

1140
00:45:38,079 --> 00:45:39,599
the gobbler will encrypt the circuit

1141
00:45:39,599 --> 00:45:41,040
each wire is given two random

1142
00:45:41,040 --> 00:45:42,960
unguessable strings called wire labels

1143
00:45:42,960 --> 00:45:44,800
representing false and true

1144
00:45:44,800 --> 00:45:46,480
the validator will only ever know one of

1145
00:45:46,480 --> 00:45:48,319
the two wire labels for each wire and

1146
00:45:48,319 --> 00:45:50,319
must not learn the other label

1147
00:45:50,319 --> 00:45:52,079
to hide which wire label represents true

1148
00:45:52,079 --> 00:45:53,599
the garbler samples the point in permute

1149
00:45:53,599 --> 00:45:55,040
bit pi a

1150
00:45:55,040 --> 00:45:57,359
labels a0 and a1 are swapped if pi a is

1151
00:45:57,359 --> 00:45:59,598
one

1152
00:45:59,680 --> 00:46:02,240
free xor requires the ax a0 x or a1

1153
00:46:02,240 --> 00:46:04,800
always be delta the same for all wires

1154
00:46:04,800 --> 00:46:06,800
this key optimization allows xor gates

1155
00:46:06,800 --> 00:46:08,800
to be valid by simply xoring the wire

1156
00:46:08,800 --> 00:46:10,960
labels together

1157
00:46:10,960 --> 00:46:12,560
the router will need to know whether it

1158
00:46:12,560 --> 00:46:15,040
has a0 or a1 so the first bit called the

1159
00:46:15,040 --> 00:46:18,720
color bit of ai is set to i

1160
00:46:19,280 --> 00:46:21,280
in a classic garbled circuit the non-xor

1161
00:46:21,280 --> 00:46:22,640
gates in the circuit become encrypted

1162
00:46:22,640 --> 00:46:24,560
lookup tables we're given only a single

1163
00:46:24,560 --> 00:46:26,640
wire label from each input wire only a

1164
00:46:26,640 --> 00:46:29,839
single output wire may be decrypted

1165
00:46:29,839 --> 00:46:31,040
the gobbler gives the evaluator

1166
00:46:31,040 --> 00:46:33,359
encrypted gate consisting of the four

1167
00:46:33,359 --> 00:46:36,720
gate ciphertext g00 and so on

1168
00:46:36,720 --> 00:46:38,079
let's see the output wire label

1169
00:46:38,079 --> 00:46:41,119
representing false and gate has three

1170
00:46:41,119 --> 00:46:43,440
ways to evaluate a false c and one way

1171
00:46:43,440 --> 00:46:46,960
to evaluate the true c x or delta

1172
00:46:46,960 --> 00:46:48,800
when the validator gets inputs a i and b

1173
00:46:48,800 --> 00:46:51,200
j it can only decrypt c i j the correct

1174
00:46:51,200 --> 00:46:54,000
output wire label

1175
00:46:54,160 --> 00:46:55,440
our new garbling scheme depends on

1176
00:46:55,440 --> 00:46:57,200
taking a linear algebraic perspective on

1177
00:46:57,200 --> 00:46:58,400
garbled gates

1178
00:46:58,400 --> 00:47:00,000
i'll start out by deriving it for these

1179
00:47:00,000 --> 00:47:02,079
classic garbled and gates

1180
00:47:02,079 --> 00:47:03,440
the garble gate consists of four

1181
00:47:03,440 --> 00:47:04,800
ciphertexts

1182
00:47:04,800 --> 00:47:06,319
a secure way of encrypting them is to

1183
00:47:06,319 --> 00:47:08,000
hash the input wire labels and extra

1184
00:47:08,000 --> 00:47:10,880
that with the output wire label

1185
00:47:10,880 --> 00:47:12,800
each output by our level of cij is

1186
00:47:12,800 --> 00:47:14,720
either c or cx or delta based on the

1187
00:47:14,720 --> 00:47:17,119
truth table

1188
00:47:17,119 --> 00:47:18,640
rearrange the equation so the variables

1189
00:47:18,640 --> 00:47:20,319
that the evaluator solves for are on the

1190
00:47:20,319 --> 00:47:22,000
left

1191
00:47:22,000 --> 00:47:23,359
these linear equations specify the

1192
00:47:23,359 --> 00:47:24,559
global gate can now be written with

1193
00:47:24,559 --> 00:47:26,880
linear algebra instead by stacking them

1194
00:47:26,880 --> 00:47:28,640
together

1195
00:47:28,640 --> 00:47:30,800
the one zero case is the true case and

1196
00:47:30,800 --> 00:47:32,880
so it involves a delta to represent this

1197
00:47:32,880 --> 00:47:34,400
we add a vector that is multiplied by

1198
00:47:34,400 --> 00:47:36,480
delta

1199
00:47:36,480 --> 00:47:37,920
and then this is this gives us the full

1200
00:47:37,920 --> 00:47:39,920
gate equation the garbler can use this

1201
00:47:39,920 --> 00:47:42,160
to find the gate ciphertext gij and the

1202
00:47:42,160 --> 00:47:45,359
false output wire label c

1203
00:47:45,440 --> 00:47:48,960
notice this equation is under determined

1204
00:47:48,960 --> 00:47:51,200
that is g00 is redundant and can be set

1205
00:47:51,200 --> 00:47:52,960
to 0 as long as we solve for the false

1206
00:47:52,960 --> 00:47:54,480
output wire label c

1207
00:47:54,480 --> 00:47:55,839
this optimization is called row

1208
00:47:55,839 --> 00:47:58,319
reduction

1209
00:47:58,400 --> 00:48:00,720
the next optimization half gates works

1210
00:48:00,720 --> 00:48:02,240
by combining hashes together in a way

1211
00:48:02,240 --> 00:48:04,880
that creates redundancies it uses h of a

1212
00:48:04,880 --> 00:48:08,480
x or b instead of h of a b

1213
00:48:08,480 --> 00:48:10,480
this is the gate equation for half gates

1214
00:48:10,480 --> 00:48:12,400
for the equation to be solvable we need

1215
00:48:12,400 --> 00:48:13,760
the right hand side to be in the column

1216
00:48:13,760 --> 00:48:14,960
space of v

1217
00:48:14,960 --> 00:48:17,280
the hash matrix has rank three as every

1218
00:48:17,280 --> 00:48:19,359
column has an even number of ones so the

1219
00:48:19,359 --> 00:48:21,680
gate matrix v only has only needs three

1220
00:48:21,680 --> 00:48:24,640
columns to make this happen

1221
00:48:24,960 --> 00:48:26,319
the garbler must then solve for three

1222
00:48:26,319 --> 00:48:28,480
things one output wire label and two

1223
00:48:28,480 --> 00:48:30,640
gate cipher texts

1224
00:48:30,640 --> 00:48:32,319
however the truth table does not have an

1225
00:48:32,319 --> 00:48:34,800
even number of ones so it is not in the

1226
00:48:34,800 --> 00:48:36,079
column space

1227
00:48:36,079 --> 00:48:37,920
to make this equation solvable a control

1228
00:48:37,920 --> 00:48:39,839
matrix r is added which tells the

1229
00:48:39,839 --> 00:48:42,319
evaluator to add to xor the a input into

1230
00:48:42,319 --> 00:48:44,720
the result when b's color bit is one in

1231
00:48:44,720 --> 00:48:47,200
the second and fourth rows a zero is xor

1232
00:48:47,200 --> 00:48:48,079
n

1233
00:48:48,079 --> 00:48:49,760
and then the a fourth row delta is x

1234
00:48:49,760 --> 00:48:52,000
origin as well uh because in that case

1235
00:48:52,000 --> 00:48:55,119
the value has a1 not a0

1236
00:48:55,119 --> 00:48:56,559
solving for four equations and three

1237
00:48:56,559 --> 00:48:57,440
unknowns

1238
00:48:57,440 --> 00:48:58,880
unknowns is possible because the

1239
00:48:58,880 --> 00:49:01,280
equations are linear linearly dependent

1240
00:49:01,280 --> 00:49:03,040
which comes from using hashes like h of

1241
00:49:03,040 --> 00:49:06,800
a0 that can be found in two cases

1242
00:49:07,920 --> 00:49:09,440
more compression requires creating more

1243
00:49:09,440 --> 00:49:11,280
redundancy in the hash calls

1244
00:49:11,280 --> 00:49:12,960
in this diagram the four points are the

1245
00:49:12,960 --> 00:49:15,839
four evaluation cases ai

1246
00:49:15,839 --> 00:49:17,839
each hash is a line through the points

1247
00:49:17,839 --> 00:49:19,920
it can be evaluated at for example the

1248
00:49:19,920 --> 00:49:22,319
lower left point is the a1 b0 case where

1249
00:49:22,319 --> 00:49:24,480
the evaluator can compute h of a1 and a

1250
00:49:24,480 --> 00:49:27,119
to b0

1251
00:49:27,200 --> 00:49:28,960
taking the xor of the two inputs gives

1252
00:49:28,960 --> 00:49:30,640
another pair of true and false wire

1253
00:49:30,640 --> 00:49:33,200
labels this is unused potential for hash

1254
00:49:33,200 --> 00:49:36,079
calls what happens if we hash them

1255
00:49:36,079 --> 00:49:38,000
you get two new hash calls which can be

1256
00:49:38,000 --> 00:49:39,520
each should be computed in two out of

1257
00:49:39,520 --> 00:49:41,280
the four cases

1258
00:49:41,280 --> 00:49:43,599
eg and the a1 b0 case

1259
00:49:43,599 --> 00:49:46,640
we can compute h of a1 x or b0

1260
00:49:46,640 --> 00:49:49,119
although we'd like to get more competit

1261
00:49:49,119 --> 00:49:50,960
more compression from these extra hashes

1262
00:49:50,960 --> 00:49:52,559
saving a whole ciphertext seems to be

1263
00:49:52,559 --> 00:49:54,800
impossible

1264
00:49:54,800 --> 00:49:57,839
let's save half a ciphertext instead

1265
00:49:57,839 --> 00:50:00,079
the wire labels up into two pieces this

1266
00:50:00,079 --> 00:50:01,760
doubles the linear algebraic dimension

1267
00:50:01,760 --> 00:50:03,440
making room for to fully use the six

1268
00:50:03,440 --> 00:50:05,920
hash calls

1269
00:50:05,920 --> 00:50:07,440
in each of the four cases for the inputs

1270
00:50:07,440 --> 00:50:09,440
a and b there are three hashes that the

1271
00:50:09,440 --> 00:50:11,119
evaluator can compute

1272
00:50:11,119 --> 00:50:12,960
the hash produces only a half a wire

1273
00:50:12,960 --> 00:50:14,880
label of randomness it still has full

1274
00:50:14,880 --> 00:50:16,720
sized input though as otherwise it'd be

1275
00:50:16,720 --> 00:50:18,160
insecure

1276
00:50:18,160 --> 00:50:20,079
the three half-sized hashes combined

1277
00:50:20,079 --> 00:50:21,599
together to make a whole wire label

1278
00:50:21,599 --> 00:50:23,599
worth a randomness which is used to mask

1279
00:50:23,599 --> 00:50:27,480
the whole output wire label

1280
00:50:28,000 --> 00:50:29,359
the hash term and the gate equation will

1281
00:50:29,359 --> 00:50:30,880
then look like this

1282
00:50:30,880 --> 00:50:32,720
notice that after slicing we now have

1283
00:50:32,720 --> 00:50:34,720
eight rows instead of four because each

1284
00:50:34,720 --> 00:50:36,400
case evaluation must now produce a two

1285
00:50:36,400 --> 00:50:37,839
dimensional vector as the output wire

1286
00:50:37,839 --> 00:50:40,800
label

1287
00:50:40,800 --> 00:50:43,440
every row of m x goes to zero

1288
00:50:43,440 --> 00:50:45,280
so m has rank five

1289
00:50:45,280 --> 00:50:47,359
for this equation to be solvable v must

1290
00:50:47,359 --> 00:50:49,119
be a basis for m's five dimensional

1291
00:50:49,119 --> 00:50:51,520
column space

1292
00:50:51,520 --> 00:50:53,520
the gobbler must then solve for five

1293
00:50:53,520 --> 00:50:55,200
half size variables

1294
00:50:55,200 --> 00:50:57,040
two of these are the two false output

1295
00:50:57,040 --> 00:50:58,240
wire labels

1296
00:50:58,240 --> 00:50:59,760
because the row reduction

1297
00:50:59,760 --> 00:51:02,319
or the two halves of it i mean

1298
00:51:02,319 --> 00:51:03,440
the other three must be the gate

1299
00:51:03,440 --> 00:51:06,000
ciphertext since they're half sized if

1300
00:51:06,000 --> 00:51:07,280
we can get this to work then we have a

1301
00:51:07,280 --> 00:51:09,280
three halves ciphertext scrabbled and

1302
00:51:09,280 --> 00:51:12,240
gate as promised

1303
00:51:12,640 --> 00:51:14,400
is our gate still secure

1304
00:51:14,400 --> 00:51:15,680
assuming that the evaluator gets the

1305
00:51:15,680 --> 00:51:17,760
input wire labels assume assume that the

1306
00:51:17,760 --> 00:51:19,839
validator gets the input wire labels a0

1307
00:51:19,839 --> 00:51:22,000
b0

1308
00:51:22,000 --> 00:51:23,200
the things that it can compute are

1309
00:51:23,200 --> 00:51:24,880
highlighted in red

1310
00:51:24,880 --> 00:51:26,559
any other evaluation case depends on

1311
00:51:26,559 --> 00:51:28,720
three hashes only one of which is known

1312
00:51:28,720 --> 00:51:32,000
to the evaluator the two unknown hashes

1313
00:51:32,000 --> 00:51:33,520
are enough to completely hide the gate

1314
00:51:33,520 --> 00:51:36,240
output

1315
00:51:36,240 --> 00:51:38,319
here's the complete gate equation

1316
00:51:38,319 --> 00:51:40,240
the control matrix r must consist of two

1317
00:51:40,240 --> 00:51:42,160
by two blocks in this form based on the

1318
00:51:42,160 --> 00:51:43,839
wire labels the evaluator knows in each

1319
00:51:43,839 --> 00:51:45,760
case

1320
00:51:45,760 --> 00:51:47,119
again we need the right hand side of the

1321
00:51:47,119 --> 00:51:48,559
equation to always be in the column

1322
00:51:48,559 --> 00:51:51,280
space of the v

1323
00:51:51,280 --> 00:51:53,359
like with half gates the truth table

1324
00:51:53,359 --> 00:51:55,280
causes the most trouble because we need

1325
00:51:55,280 --> 00:51:57,040
to pick the control matrix so that r x

1326
00:51:57,040 --> 00:52:00,720
or t fits in the column space

1327
00:52:00,720 --> 00:52:02,240
however this is a bigger issue than it

1328
00:52:02,240 --> 00:52:04,319
was for half gates slicing requires

1329
00:52:04,319 --> 00:52:05,599
creating an asymmetry in the column

1330
00:52:05,599 --> 00:52:07,680
space of v which forces the control

1331
00:52:07,680 --> 00:52:09,839
matrix r to depend on which case

1332
00:52:09,839 --> 00:52:11,280
output's true

1333
00:52:11,280 --> 00:52:12,960
from r the validator could compute the

1334
00:52:12,960 --> 00:52:14,319
point preview bits and learn the

1335
00:52:14,319 --> 00:52:16,720
plaintext values

1336
00:52:16,720 --> 00:52:18,400
our solution to this problem is called

1337
00:52:18,400 --> 00:52:20,240
dicing the idea is that the evaluator

1338
00:52:20,240 --> 00:52:21,599
doesn't need to know the whole control

1339
00:52:21,599 --> 00:52:23,839
matrix it only needs to know rij which

1340
00:52:23,839 --> 00:52:25,359
tells it what to do in the one case it

1341
00:52:25,359 --> 00:52:27,440
is evaluating

1342
00:52:27,440 --> 00:52:29,200
the garber rolls dice to randomize the

1343
00:52:29,200 --> 00:52:31,839
choice of r so that rij leaks nothing it

1344
00:52:31,839 --> 00:52:33,280
then garbles the control matrix by

1345
00:52:33,280 --> 00:52:35,119
encrypting each rij with the input wire

1346
00:52:35,119 --> 00:52:36,880
labels so that the evaluator cannot

1347
00:52:36,880 --> 00:52:39,520
learn more than rij

1348
00:52:39,520 --> 00:52:41,119
for this to work we need a distribution

1349
00:52:41,119 --> 00:52:43,119
on control matrices that always puts rx

1350
00:52:43,119 --> 00:52:45,280
or t in the column space and does not

1351
00:52:45,280 --> 00:52:48,480
leak the truth table t to the evaluator

1352
00:52:48,480 --> 00:52:50,000
the way to do this is to first find a

1353
00:52:50,000 --> 00:52:52,480
solution rt which always exists then

1354
00:52:52,480 --> 00:52:54,000
hide it by picking a random valid

1355
00:52:54,000 --> 00:52:55,760
control matrix or a dollar sign that's

1356
00:52:55,760 --> 00:52:57,280
in the column space

1357
00:52:57,280 --> 00:52:59,520
picking r dollar sign from as wide as

1358
00:52:59,520 --> 00:53:02,319
possible space as possible masks it

1359
00:53:02,319 --> 00:53:05,520
or makes it completely hide rit rt

1360
00:53:05,520 --> 00:53:09,040
completely masking the truth table

1361
00:53:09,280 --> 00:53:11,040
i'll now summarize the evaluation

1362
00:53:11,040 --> 00:53:12,240
process

1363
00:53:12,240 --> 00:53:14,640
first the evaluator uses h prime a hash

1364
00:53:14,640 --> 00:53:16,640
function outputting 8 bits to decrypt

1365
00:53:16,640 --> 00:53:17,760
the garbled

1366
00:53:17,760 --> 00:53:19,119
control matrix

1367
00:53:19,119 --> 00:53:21,200
zij is the corresponding control matrix

1368
00:53:21,200 --> 00:53:22,559
ciphertext

1369
00:53:22,559 --> 00:53:25,520
it then uses half-sized hashes

1370
00:53:25,520 --> 00:53:26,960
in the control matrix

1371
00:53:26,960 --> 00:53:28,319
to evaluate the gate and get the output

1372
00:53:28,319 --> 00:53:30,800
wire label cij

1373
00:53:30,800 --> 00:53:32,559
our garbling scheme bay passes the half

1374
00:53:32,559 --> 00:53:34,400
gate's lower bound by using two ideas

1375
00:53:34,400 --> 00:53:36,400
not present in their model

1376
00:53:36,400 --> 00:53:38,319
they assume a monolithic wire label

1377
00:53:38,319 --> 00:53:39,839
while we slice them into halves and

1378
00:53:39,839 --> 00:53:42,319
operate on them independently

1379
00:53:42,319 --> 00:53:43,920
dicing hides some of the coefficients of

1380
00:53:43,920 --> 00:53:45,599
our evaluation equation while they

1381
00:53:45,599 --> 00:53:46,960
assume that the coefficients are all

1382
00:53:46,960 --> 00:53:49,839
fixed in advance

1383
00:53:49,920 --> 00:53:51,440
we have several more results which

1384
00:53:51,440 --> 00:53:53,040
didn't fit into this talk including

1385
00:53:53,040 --> 00:53:54,319
hiding the truth table of arbitrary

1386
00:53:54,319 --> 00:53:56,319
gates compressing control the control

1387
00:53:56,319 --> 00:53:58,480
matrices down to just three bits

1388
00:53:58,480 --> 00:54:00,079
please check out the paper or the video

1389
00:54:00,079 --> 00:54:02,240
for more

1390
00:54:02,240 --> 00:54:04,558
thank you

1391
00:54:06,640 --> 00:54:08,839
thank you very

1392
00:54:08,839 --> 00:54:11,040
much great talk

1393
00:54:11,040 --> 00:54:12,720
uh

1394
00:54:12,720 --> 00:54:14,880
some questions

1395
00:54:14,880 --> 00:54:17,040
so nigel is asking can you get further

1396
00:54:17,040 --> 00:54:19,440
servings if you slice the uh

1397
00:54:19,440 --> 00:54:21,040
wire levels into more than two

1398
00:54:21,040 --> 00:54:22,880
components

1399
00:54:22,880 --> 00:54:24,880
i was hoping somebody would ask that

1400
00:54:24,880 --> 00:54:26,559
uh sorry a second

1401
00:54:26,559 --> 00:54:27,440
so i

1402
00:54:27,440 --> 00:54:31,440
uh it's a subject of uh ongoing research

1403
00:54:31,440 --> 00:54:33,520
but uh here's sort of a sneak preview of

1404
00:54:33,520 --> 00:54:36,319
like why that might not be the case or

1405
00:54:36,319 --> 00:54:39,040
why we might not be able to do better

1406
00:54:39,040 --> 00:54:41,040
so if we split into s parts

1407
00:54:41,040 --> 00:54:43,920
and then uh there's m cop they make the

1408
00:54:43,920 --> 00:54:45,359
hash function output m dimensional

1409
00:54:45,359 --> 00:54:47,599
vector we get a hash matrix that's 4s by

1410
00:54:47,599 --> 00:54:50,000
6m

1411
00:54:50,000 --> 00:54:51,040
um

1412
00:54:51,040 --> 00:54:52,720
you want to lower bound the rank of m in

1413
00:54:52,720 --> 00:54:53,760
order to lower down the number of

1414
00:54:53,760 --> 00:54:56,000
ciphertexts

1415
00:54:56,000 --> 00:54:58,240
so then uh if we look at just one case

1416
00:54:58,240 --> 00:54:59,599
evaluation

1417
00:54:59,599 --> 00:55:02,799
uh the thing is it must

1418
00:55:02,799 --> 00:55:05,520
fully hide the output from the evaluator

1419
00:55:05,520 --> 00:55:07,440
even the valider knows another case so

1420
00:55:07,440 --> 00:55:09,280
just from two hashes it must be fully

1421
00:55:09,280 --> 00:55:11,599
random so that means that

1422
00:55:11,599 --> 00:55:13,359
of the three non-zero columns like the

1423
00:55:13,359 --> 00:55:15,280
values that the 3m hashes it can

1424
00:55:15,280 --> 00:55:16,240
evaluate

1425
00:55:16,240 --> 00:55:18,960
after deleting m of them there must be

1426
00:55:18,960 --> 00:55:21,520
it only uses 2m hash uh remaining

1427
00:55:21,520 --> 00:55:22,720
columns so

1428
00:55:22,720 --> 00:55:24,319
that's like an upper bound on the rank

1429
00:55:24,319 --> 00:55:26,960
so s must be less than 2m

1430
00:55:26,960 --> 00:55:28,799
and then second there's like a kernel of

1431
00:55:28,799 --> 00:55:31,359
this matrix uh n

1432
00:55:31,359 --> 00:55:35,200
and uh so the rank of m is the

1433
00:55:35,200 --> 00:55:36,960
uh columns minus the current size of the

1434
00:55:36,960 --> 00:55:38,720
kernel

1435
00:55:38,720 --> 00:55:40,160
and anything on the kernel also

1436
00:55:40,160 --> 00:55:42,960
constrains this uh matrix here puts

1437
00:55:42,960 --> 00:55:46,400
another bound on s upper bound on s

1438
00:55:46,400 --> 00:55:47,760
then if you combine these two upper

1439
00:55:47,760 --> 00:55:48,960
bounds together

1440
00:55:48,960 --> 00:55:50,720
we get uh that

1441
00:55:50,720 --> 00:55:51,760
um

1442
00:55:51,760 --> 00:55:53,359
the number of ciphertexts has to be at

1443
00:55:53,359 --> 00:55:55,119
least three halves

1444
00:55:55,119 --> 00:55:57,520
so according to this rough analysis it

1445
00:55:57,520 --> 00:55:59,760
seems that we can't do better using this

1446
00:55:59,760 --> 00:56:02,920
our technique

1447
00:56:08,960 --> 00:56:10,559
thank you

1448
00:56:10,559 --> 00:56:13,040
can you say a word on the assumption of

1449
00:56:13,040 --> 00:56:14,720
the hash function that you flashed i

1450
00:56:14,720 --> 00:56:17,200
think in the last flight

1451
00:56:17,200 --> 00:56:19,759
uh sure

1452
00:56:22,079 --> 00:56:23,839
yes so um

1453
00:56:23,839 --> 00:56:25,680
there's like two

1454
00:56:25,680 --> 00:56:27,280
uh there's like a

1455
00:56:27,280 --> 00:56:29,280
correlation uh circular correlation

1456
00:56:29,280 --> 00:56:31,200
robust hash function assumption

1457
00:56:31,200 --> 00:56:33,280
which is like uh says that if you have

1458
00:56:33,280 --> 00:56:36,079
some secret delta then

1459
00:56:36,079 --> 00:56:39,040
uh and the hash function h h of delta x

1460
00:56:39,040 --> 00:56:39,920
or

1461
00:56:39,920 --> 00:56:40,720
x

1462
00:56:40,720 --> 00:56:45,440
is like a p or f as a function of x um

1463
00:56:45,440 --> 00:56:46,640
that's the whole assumption right it's

1464
00:56:46,640 --> 00:56:48,559
not the assumption that for this paper

1465
00:56:48,559 --> 00:56:49,760
right that's something was just before

1466
00:56:49,760 --> 00:56:50,960
yeah

1467
00:56:50,960 --> 00:56:52,720
so then there's a stronger assumption

1468
00:56:52,720 --> 00:56:54,799
that's called the tweakable ccr

1469
00:56:54,799 --> 00:56:56,319
which normally garbling needs because

1470
00:56:56,319 --> 00:56:57,760
you need to tweak the hash function for

1471
00:56:57,760 --> 00:56:59,119
every gate

1472
00:56:59,119 --> 00:57:01,280
and it introduces a tweak

1473
00:57:01,280 --> 00:57:02,960
the thing is it's more expensive to

1474
00:57:02,960 --> 00:57:05,280
realize it requires two aes calls rather

1475
00:57:05,280 --> 00:57:06,480
than one

1476
00:57:06,480 --> 00:57:07,280
um

1477
00:57:07,280 --> 00:57:10,160
whereas we realize that we can instead

1478
00:57:10,160 --> 00:57:11,520
make a weaker version of the tweakable

1479
00:57:11,520 --> 00:57:13,839
circular secure robust hash function

1480
00:57:13,839 --> 00:57:15,040
that's um

1481
00:57:15,040 --> 00:57:16,559
doesn't isn't quite as strong but is

1482
00:57:16,559 --> 00:57:18,079
still good enough for garbling and it

1483
00:57:18,079 --> 00:57:19,760
can be instantiated from

1484
00:57:19,760 --> 00:57:22,640
a ccr and a universal hash so that's

1485
00:57:22,640 --> 00:57:24,839
like one call to aes rather than

1486
00:57:24,839 --> 00:57:28,319
two okay thank you

1487
00:57:31,359 --> 00:57:35,119
any more questions

1488
00:57:36,559 --> 00:57:37,760
oh and just to add to that there's a

1489
00:57:37,760 --> 00:57:39,040
there's a sort of a trick that lets

1490
00:57:39,040 --> 00:57:40,720
goblin get away f1 normally but it

1491
00:57:40,720 --> 00:57:42,079
didn't work for this and that's why we

1492
00:57:42,079 --> 00:57:43,359
needed to use our

1493
00:57:43,359 --> 00:57:47,640
this new technique for the hash

1494
00:57:53,610 --> 00:57:55,280
[Music]

1495
00:57:55,280 --> 00:57:57,440
so while people are thinking and typing

1496
00:57:57,440 --> 00:57:59,760
out the questions uh just a small uh uh

1497
00:57:59,760 --> 00:58:02,559
uh uh knit you know for old foggies so i

1498
00:58:02,559 --> 00:58:04,240
think the uh for your first slice i

1499
00:58:04,240 --> 00:58:06,319
think the first kind of whiff that you

1500
00:58:06,319 --> 00:58:07,920
got from garbage it was like thinking

1501
00:58:07,920 --> 00:58:10,079
the yao 85 not 32

1502
00:58:10,079 --> 00:58:10,960
uh

1503
00:58:10,960 --> 00:58:12,799
and even then what's implicit but never

1504
00:58:12,799 --> 00:58:13,760
mind

1505
00:58:13,760 --> 00:58:14,559
uh

1506
00:58:14,559 --> 00:58:16,799
sorry yeah

1507
00:58:16,799 --> 00:58:19,680
i think yeah people also you know i know

1508
00:58:19,680 --> 00:58:21,359
it's since previous millennium you know

1509
00:58:21,359 --> 00:58:24,720
who knows who cares but yeah

1510
00:58:26,319 --> 00:58:28,480
any anyone has something more meaningful

1511
00:58:28,480 --> 00:58:32,359
to say a common task

1512
00:58:43,280 --> 00:58:45,839
yeah okay

1513
00:58:47,040 --> 00:58:48,000
okay

1514
00:58:48,000 --> 00:58:49,280
um

1515
00:58:49,280 --> 00:58:51,440
okay um

1516
00:58:51,440 --> 00:58:52,090
so

1517
00:58:52,090 --> 00:58:54,160
[Music]

1518
00:58:54,160 --> 00:58:56,880
okay so so again thank you very much uh

1519
00:58:56,880 --> 00:58:58,079
uh uh

1520
00:58:58,079 --> 00:58:59,760
um

1521
00:58:59,760 --> 00:59:01,760
the uh speaker thank you very much and

1522
00:59:01,760 --> 00:59:04,240
thank you uh uh lawrence thank you all

1523
00:59:04,240 --> 00:59:06,400
the speakers of the session so again

1524
00:59:06,400 --> 00:59:07,359
thank you

1525
00:59:07,359 --> 00:59:10,680
and i think

