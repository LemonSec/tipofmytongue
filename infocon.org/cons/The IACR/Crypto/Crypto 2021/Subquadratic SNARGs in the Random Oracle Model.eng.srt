1
00:00:00,080 --> 00:00:02,480
hi everyone this talk is going to be

2
00:00:02,480 --> 00:00:05,279
about subquadratic snarks in the random

3
00:00:05,279 --> 00:00:08,080
oracle model my name is elon yugev and

4
00:00:08,080 --> 00:00:10,240
this is joint work with alessandro

5
00:00:10,240 --> 00:00:11,920
chiesa

6
00:00:11,920 --> 00:00:13,120
okay

7
00:00:13,120 --> 00:00:14,719
so let me start

8
00:00:14,719 --> 00:00:15,759
by

9
00:00:15,759 --> 00:00:18,240
brief introduction

10
00:00:18,240 --> 00:00:21,359
a very high level introduction to snarks

11
00:00:21,359 --> 00:00:23,600
so these are succinct non-interactive

12
00:00:23,600 --> 00:00:26,640
arguments so this is a proof system for

13
00:00:26,640 --> 00:00:29,359
some language l and we have a verifier

14
00:00:29,359 --> 00:00:31,359
that wants to be convinced that x is in

15
00:00:31,359 --> 00:00:32,640
the language

16
00:00:32,640 --> 00:00:35,440
and it's a non-interactive protocol so

17
00:00:35,440 --> 00:00:39,200
the pool sends a single message pi

18
00:00:39,200 --> 00:00:41,760
the communication complexity okay

19
00:00:41,760 --> 00:00:43,680
meaning the size of this proof is going

20
00:00:43,680 --> 00:00:44,399
to be

21
00:00:44,399 --> 00:00:46,879
16 so it's going to be very small

22
00:00:46,879 --> 00:00:49,039
in particular for an np language this is

23
00:00:49,039 --> 00:00:51,600
like much smaller than the the witness

24
00:00:51,600 --> 00:00:53,039
itself

25
00:00:53,039 --> 00:00:55,680
and the soundness is computational what

26
00:00:55,680 --> 00:00:58,079
do you mean by computational okay so

27
00:00:58,079 --> 00:01:00,399
this is in the random oracle model so

28
00:01:00,399 --> 00:01:02,960
the approval and verifier both have

29
00:01:02,960 --> 00:01:05,680
a this shared resource this truly random

30
00:01:05,680 --> 00:01:09,360
function that outputs lambda lambda bits

31
00:01:09,360 --> 00:01:11,840
and the security requirement is called

32
00:01:11,840 --> 00:01:14,560
this t epsilon security

33
00:01:14,560 --> 00:01:17,600
so for any t query

34
00:01:17,600 --> 00:01:19,920
unbounded so computationally unbounded

35
00:01:19,920 --> 00:01:21,840
cheating over p

36
00:01:21,840 --> 00:01:24,000
the probability that this

37
00:01:24,000 --> 00:01:25,200
prover

38
00:01:25,200 --> 00:01:26,960
performed that mostly queries and

39
00:01:26,960 --> 00:01:28,960
outputs are proof pi that makes the

40
00:01:28,960 --> 00:01:32,400
verifier accept is at most epsilon

41
00:01:32,400 --> 00:01:34,479
okay so t is the bound of the number of

42
00:01:34,479 --> 00:01:36,560
queries the cheating prover is allowed

43
00:01:36,560 --> 00:01:39,520
to do and epsilon is a bound on its

44
00:01:39,520 --> 00:01:42,720
success probability

45
00:01:43,040 --> 00:01:45,759
so why do we study security of snags in

46
00:01:45,759 --> 00:01:48,479
the random oracle model well it's a very

47
00:01:48,479 --> 00:01:51,520
elegant information theoretic model okay

48
00:01:51,520 --> 00:01:53,680
the questions are more about information

49
00:01:53,680 --> 00:01:54,880
and not

50
00:01:54,880 --> 00:01:58,240
computational or complexity assumptions

51
00:01:58,240 --> 00:02:00,719
um it's not only just a nice node we

52
00:02:00,719 --> 00:02:01,759
actually

53
00:02:01,759 --> 00:02:04,320
a nice model we actually have a very

54
00:02:04,320 --> 00:02:06,479
elegant nice constructions in the in

55
00:02:06,479 --> 00:02:08,800
this model uh

56
00:02:08,800 --> 00:02:10,878
after you take these constructions in

57
00:02:10,878 --> 00:02:12,640
the unwalker model you can actually

58
00:02:12,640 --> 00:02:15,680
heuristically instantiate them uh using

59
00:02:15,680 --> 00:02:16,800
usually

60
00:02:16,800 --> 00:02:19,200
relatively lightweight crypto symmetric

61
00:02:19,200 --> 00:02:20,879
crypto

62
00:02:20,879 --> 00:02:22,560
okay and then these

63
00:02:22,560 --> 00:02:24,800
constructions are also post quantums in

64
00:02:24,800 --> 00:02:28,959
cure and also do not require any setup

65
00:02:29,599 --> 00:02:31,760
okay

66
00:02:31,760 --> 00:02:33,760
so what constructions of snugs do we

67
00:02:33,760 --> 00:02:36,480
have we have several constructions

68
00:02:36,480 --> 00:02:38,160
i'm just going to mention the main two

69
00:02:38,160 --> 00:02:41,360
this is mikali and bcs they both work in

70
00:02:41,360 --> 00:02:42,400
the

71
00:02:42,400 --> 00:02:45,040
same format or paradigm

72
00:02:45,040 --> 00:02:46,879
so they both take a information

73
00:02:46,879 --> 00:02:49,599
theoretic proof it's either a pcp for

74
00:02:49,599 --> 00:02:52,400
micalli or an iop for bcs

75
00:02:52,400 --> 00:02:55,760
uh then you combine this combine this

76
00:02:55,760 --> 00:02:59,280
with a cryptographic commitment

77
00:02:59,280 --> 00:03:01,040
so this is just going to be a merkle

78
00:03:01,040 --> 00:03:04,480
tree okay using the random worker

79
00:03:04,480 --> 00:03:07,920
and you get a snug okay you get a very

80
00:03:07,920 --> 00:03:11,200
short non-interactive synth

81
00:03:11,200 --> 00:03:14,319
a slightly more detail just for mikali's

82
00:03:14,319 --> 00:03:16,959
constructions we're gonna we're gonna

83
00:03:16,959 --> 00:03:19,440
use this later

84
00:03:19,440 --> 00:03:20,319
so

85
00:03:20,319 --> 00:03:23,519
the prover writes a pcp okay for the

86
00:03:23,519 --> 00:03:25,840
statement that x is in the language he

87
00:03:25,840 --> 00:03:29,280
takes this pcp computes a miracle tree

88
00:03:29,280 --> 00:03:31,519
okay he gets the root

89
00:03:31,519 --> 00:03:33,040
he applies the random oracle on the

90
00:03:33,040 --> 00:03:34,159
route to

91
00:03:34,159 --> 00:03:37,360
derive pcp randomness okay randomness

92
00:03:37,360 --> 00:03:40,720
for the very file okay this defines the

93
00:03:40,720 --> 00:03:43,440
queries the verifier wants to read

94
00:03:43,440 --> 00:03:45,440
and then the proof is gonna contain this

95
00:03:45,440 --> 00:03:49,200
route okay all the pcp answers okay all

96
00:03:49,200 --> 00:03:51,920
the locations the verify i wanted to see

97
00:03:51,920 --> 00:03:54,799
and all the authentication passes okay

98
00:03:54,799 --> 00:03:56,400
so all the authentication paths and

99
00:03:56,400 --> 00:03:58,319
making sure that these answers are

100
00:03:58,319 --> 00:04:01,200
actually what he committed to under this

101
00:04:01,200 --> 00:04:02,799
route

102
00:04:02,799 --> 00:04:04,480
okay so this is going to be the pover

103
00:04:04,480 --> 00:04:06,959
and the verifiers of course gonna check

104
00:04:06,959 --> 00:04:10,400
the answers to the pcp okay and then for

105
00:04:10,400 --> 00:04:13,439
each answer it checks that

106
00:04:13,439 --> 00:04:14,799
there the authentication path that

107
00:04:14,799 --> 00:04:17,279
corresponds to the sensor

108
00:04:17,279 --> 00:04:19,120
okay

109
00:04:19,120 --> 00:04:21,440
and what question one question is

110
00:04:21,440 --> 00:04:25,040
what is the size of the snog okay in

111
00:04:25,040 --> 00:04:27,040
this construction okay so what is the

112
00:04:27,040 --> 00:04:29,840
size of pi

113
00:04:30,240 --> 00:04:32,720
and uh let me

114
00:04:32,720 --> 00:04:35,840
give like a one slide the answer of what

115
00:04:35,840 --> 00:04:37,600
the size is and what our contributions

116
00:04:37,600 --> 00:04:38,560
are

117
00:04:38,560 --> 00:04:39,520
so

118
00:04:39,520 --> 00:04:41,759
mikali's construction has a quadratic

119
00:04:41,759 --> 00:04:43,759
argument size and i'm going to explain

120
00:04:43,759 --> 00:04:46,960
exactly what this means and we give a

121
00:04:46,960 --> 00:04:49,840
slightly sub-quadratic argument size and

122
00:04:49,840 --> 00:04:52,560
this is really the first time um the

123
00:04:52,560 --> 00:04:53,840
first improvement to me carries

124
00:04:53,840 --> 00:04:57,040
constructions in a long time okay so now

125
00:04:57,040 --> 00:04:59,199
let me explain these two issues with

126
00:04:59,199 --> 00:05:02,080
slightly more detail

127
00:05:02,400 --> 00:05:04,800
so mikali's argument size

128
00:05:04,800 --> 00:05:05,680
um

129
00:05:05,680 --> 00:05:06,720
so

130
00:05:06,720 --> 00:05:08,880
the argument size depends on the pcp

131
00:05:08,880 --> 00:05:11,759
that you use okay so suppose the pcp has

132
00:05:11,759 --> 00:05:14,160
length l okay so this is like the poof

133
00:05:14,160 --> 00:05:17,360
length over an alphabet sigma and it has

134
00:05:17,360 --> 00:05:20,240
q queries okay then the size is going to

135
00:05:20,240 --> 00:05:21,440
be

136
00:05:21,440 --> 00:05:23,919
so this is exactly the the ansels to the

137
00:05:23,919 --> 00:05:26,639
pcp so you have q queries and and and

138
00:05:26,639 --> 00:05:28,880
and this is one symbol okay

139
00:05:28,880 --> 00:05:30,479
and then you need all the authentication

140
00:05:30,479 --> 00:05:32,639
passes so for every

141
00:05:32,639 --> 00:05:33,680
uh

142
00:05:33,680 --> 00:05:37,039
for every query you have a path of

143
00:05:37,039 --> 00:05:39,600
length log n and every node in the three

144
00:05:39,600 --> 00:05:42,320
is of size lambda okay this is the size

145
00:05:42,320 --> 00:05:44,880
of the of the random worker

146
00:05:44,880 --> 00:05:46,560
okay so there's the information

147
00:05:46,560 --> 00:05:48,320
theoretical cost and this is the

148
00:05:48,320 --> 00:05:52,000
cryptographic commitment cost

149
00:05:52,000 --> 00:05:53,039
uh

150
00:05:53,039 --> 00:05:54,479
so

151
00:05:54,479 --> 00:05:56,720
i claim that if you want to get t

152
00:05:56,720 --> 00:05:58,479
epsilon security

153
00:05:58,479 --> 00:06:01,120
okay you must set the random oracle to

154
00:06:01,120 --> 00:06:01,919
be

155
00:06:01,919 --> 00:06:05,280
a o of log t over epsilon and the number

156
00:06:05,280 --> 00:06:07,600
of queries of the pcp also needs to be

157
00:06:07,600 --> 00:06:11,520
log t over epsilon okay roughly

158
00:06:11,520 --> 00:06:13,759
this means that the argument size is

159
00:06:13,759 --> 00:06:16,160
quadratic what do i mean by quadratic if

160
00:06:16,160 --> 00:06:18,639
you plug in these two parameters here

161
00:06:18,639 --> 00:06:21,280
okay you get ignoring like

162
00:06:21,280 --> 00:06:24,479
small log terms okay you get log t over

163
00:06:24,479 --> 00:06:26,720
epsilon squared okay because this is log

164
00:06:26,720 --> 00:06:29,120
t over epsilon and this lambda is log t

165
00:06:29,120 --> 00:06:31,759
over epsilon

166
00:06:32,240 --> 00:06:35,600
okay i want to briefly tell you why

167
00:06:35,600 --> 00:06:38,880
uh why these two must hold okay

168
00:06:38,880 --> 00:06:41,680
so first about the the random oracle

169
00:06:41,680 --> 00:06:43,039
output size

170
00:06:43,039 --> 00:06:45,280
okay

171
00:06:46,319 --> 00:06:47,600
so

172
00:06:47,600 --> 00:06:48,400
um

173
00:06:48,400 --> 00:06:51,599
here's one attack okay an adversary can

174
00:06:51,599 --> 00:06:54,880
just guess the route and invests okay

175
00:06:54,880 --> 00:06:57,840
and then he can derive

176
00:06:57,840 --> 00:06:59,840
a fooling pcp

177
00:06:59,840 --> 00:07:01,759
for this particular wound okay if he

178
00:07:01,759 --> 00:07:04,000
knows the root then he knows the queries

179
00:07:04,000 --> 00:07:05,680
of the pcp and then if he knows the

180
00:07:05,680 --> 00:07:07,599
queries of the pecp in advance of course

181
00:07:07,599 --> 00:07:10,240
he can he can fool you okay

182
00:07:10,240 --> 00:07:11,039
but

183
00:07:11,039 --> 00:07:13,039
guessing in advance the the road that

184
00:07:13,039 --> 00:07:14,960
has like a very small probability it's 2

185
00:07:14,960 --> 00:07:16,720
to the minus lambda okay this is just

186
00:07:16,720 --> 00:07:19,120
the size of the root

187
00:07:19,120 --> 00:07:21,039
and then you can try this t times

188
00:07:21,039 --> 00:07:23,440
actually so a success probability is

189
00:07:23,440 --> 00:07:26,240
roughly t times 2 to the minus lambda

190
00:07:26,240 --> 00:07:27,680
okay

191
00:07:27,680 --> 00:07:30,240
and if we want this to be smaller than

192
00:07:30,240 --> 00:07:33,280
epsilon okay it just means that

193
00:07:33,280 --> 00:07:34,639
the output of the

194
00:07:34,639 --> 00:07:39,039
oracle must be log t over epsilon

195
00:07:39,440 --> 00:07:40,479
okay

196
00:07:40,479 --> 00:07:41,680
what about

197
00:07:41,680 --> 00:07:43,520
q the number of queries

198
00:07:43,520 --> 00:07:46,160
okay so again i claim that to get t

199
00:07:46,160 --> 00:07:48,720
epsilon security the number of queries

200
00:07:48,720 --> 00:07:52,000
must be roughly log t over epsilon

201
00:07:52,000 --> 00:07:53,199
okay

202
00:07:53,199 --> 00:07:54,000
and

203
00:07:54,000 --> 00:07:56,240
why is this so first the soundness of

204
00:07:56,240 --> 00:08:00,720
the pcp must be epsilon over t okay

205
00:08:00,720 --> 00:08:04,160
because he can try t times to win this

206
00:08:04,160 --> 00:08:06,080
probability and each time he has

207
00:08:06,080 --> 00:08:07,280
uh

208
00:08:07,280 --> 00:08:09,039
a probability of winning so you have to

209
00:08:09,039 --> 00:08:10,639
put the soundness of the pcp to be

210
00:08:10,639 --> 00:08:13,120
epsilon ovt

211
00:08:13,120 --> 00:08:14,160
now

212
00:08:14,160 --> 00:08:16,000
how do we achieve

213
00:08:16,000 --> 00:08:18,720
a pcp with such a small such small

214
00:08:18,720 --> 00:08:21,599
soundness well you take the best pcp you

215
00:08:21,599 --> 00:08:23,840
can you know and

216
00:08:23,840 --> 00:08:27,599
use it as a base pcp and you repeat okay

217
00:08:27,599 --> 00:08:29,199
and you repeat and decrease the l you

218
00:08:29,199 --> 00:08:31,520
amplify the the sounds

219
00:08:31,520 --> 00:08:32,479
and

220
00:08:32,479 --> 00:08:34,080
uh

221
00:08:34,080 --> 00:08:36,719
if you look at the standard pcp that has

222
00:08:36,719 --> 00:08:39,279
like constant sounds constant queries or

223
00:08:39,279 --> 00:08:41,440
even very sophisticated constructions

224
00:08:41,440 --> 00:08:44,159
like the hk which has have very good

225
00:08:44,159 --> 00:08:46,399
soundness with relatively small double

226
00:08:46,399 --> 00:08:48,959
quotes or even if you go to the

227
00:08:48,959 --> 00:08:51,760
conjecture the best possible pcp that we

228
00:08:51,760 --> 00:08:53,760
assume exists this is like the sliding

229
00:08:53,760 --> 00:08:56,080
scale conjecture which has soundness 1

230
00:08:56,080 --> 00:08:59,279
over poly and 01 queries

231
00:08:59,279 --> 00:09:01,760
okay still the number of repetitions you

232
00:09:01,760 --> 00:09:05,040
need to do is log t over epsilon over

233
00:09:05,040 --> 00:09:06,839
some small factor that i'm currently

234
00:09:06,839 --> 00:09:08,640
ignoring uh

235
00:09:08,640 --> 00:09:10,480
and so the final number of queries is

236
00:09:10,480 --> 00:09:13,519
still log till the epsilon

237
00:09:13,519 --> 00:09:15,600
okay and this like we have lower bounds

238
00:09:15,600 --> 00:09:17,760
like you really cannot do do anything

239
00:09:17,760 --> 00:09:20,080
better

240
00:09:20,800 --> 00:09:23,519
okay so let's just put things on a scale

241
00:09:23,519 --> 00:09:25,360
uh so we said that we call its

242
00:09:25,360 --> 00:09:27,279
construction is roughly log t over

243
00:09:27,279 --> 00:09:30,560
epsilon squared okay you can easily show

244
00:09:30,560 --> 00:09:33,360
a lower bound of log t over epsilon okay

245
00:09:33,360 --> 00:09:35,279
like this is a trivial orbit you cannot

246
00:09:35,279 --> 00:09:36,640
do better than that

247
00:09:36,640 --> 00:09:39,040
and of course the question is the focus

248
00:09:39,040 --> 00:09:41,440
of this talk is what happens here in the

249
00:09:41,440 --> 00:09:43,600
middle

250
00:09:43,600 --> 00:09:46,160
okay and now using all this formulation

251
00:09:46,160 --> 00:09:48,320
i can formally state a result

252
00:09:48,320 --> 00:09:50,640
so we prove okay we give a new

253
00:09:50,640 --> 00:09:51,920
construction

254
00:09:51,920 --> 00:09:54,160
uh so we prove that there exists a snogs

255
00:09:54,160 --> 00:09:56,800
in the random oracle model that achieve

256
00:09:56,800 --> 00:09:59,680
argument size log t over epsilon times

257
00:09:59,680 --> 00:10:01,200
log t

258
00:10:01,200 --> 00:10:03,279
okay so we don't have the logit of

259
00:10:03,279 --> 00:10:05,839
epsilon squared okay but just one times

260
00:10:05,839 --> 00:10:07,680
this and then log t

261
00:10:07,680 --> 00:10:10,959
okay for t epsilon security

262
00:10:10,959 --> 00:10:12,560
and just

263
00:10:12,560 --> 00:10:15,440
one line about our approach okay before

264
00:10:15,440 --> 00:10:18,399
i describe the construction

265
00:10:18,399 --> 00:10:19,600
we use a

266
00:10:19,600 --> 00:10:22,399
a stronger information theoretic

267
00:10:22,399 --> 00:10:23,519
proof

268
00:10:23,519 --> 00:10:24,640
okay

269
00:10:24,640 --> 00:10:27,519
so we still use a pcp but a stronger

270
00:10:27,519 --> 00:10:30,000
soundness notion this allows us to

271
00:10:30,000 --> 00:10:33,200
combine this with a weak cryptographic

272
00:10:33,200 --> 00:10:35,040
commitment okay so it's not actually

273
00:10:35,040 --> 00:10:37,440
going to be a commitment but some weak

274
00:10:37,440 --> 00:10:39,040
binding

275
00:10:39,040 --> 00:10:41,200
and together we get our psychologic

276
00:10:41,200 --> 00:10:43,440
stocks

277
00:10:43,440 --> 00:10:45,680
okay

278
00:10:45,680 --> 00:10:48,399
so just putting this back on the scale

279
00:10:48,399 --> 00:10:50,880
okay in this work we show

280
00:10:50,880 --> 00:10:52,880
we get this argument size

281
00:10:52,880 --> 00:10:56,079
uh well it's so it's much closer

282
00:10:56,079 --> 00:10:58,160
to to mikalis and still we have like a

283
00:10:58,160 --> 00:11:00,800
large gap here where um

284
00:11:00,800 --> 00:11:02,240
we don't know

285
00:11:02,240 --> 00:11:05,120
um of course we hope that maybe after

286
00:11:05,120 --> 00:11:07,040
you know our first step and maybe we

287
00:11:07,040 --> 00:11:08,800
could actually make this smaller and

288
00:11:08,800 --> 00:11:14,040
smaller and get to to this low bound

289
00:11:16,000 --> 00:11:17,279
okay

290
00:11:17,279 --> 00:11:18,800
um

291
00:11:18,800 --> 00:11:20,720
one last comment about the construction

292
00:11:20,720 --> 00:11:23,279
before i describe it so we actually work

293
00:11:23,279 --> 00:11:26,160
how to get not only this uh theoretical

294
00:11:26,160 --> 00:11:27,360
like a

295
00:11:27,360 --> 00:11:29,200
tilde notation

296
00:11:29,200 --> 00:11:31,200
expressions but actually we get good

297
00:11:31,200 --> 00:11:33,360
concrete parameters

298
00:11:33,360 --> 00:11:36,079
and we compare this with like mikali

299
00:11:36,079 --> 00:11:39,519
with like a standard base pcp

300
00:11:39,519 --> 00:11:41,600
and you can see that in this table

301
00:11:41,600 --> 00:11:44,000
depending of course on the values of t

302
00:11:44,000 --> 00:11:46,000
and epsilon like we get different

303
00:11:46,000 --> 00:11:47,279
improvements

304
00:11:47,279 --> 00:11:49,600
and just like the best improvements is

305
00:11:49,600 --> 00:11:51,360
here in the table where we actually get

306
00:11:51,360 --> 00:11:56,360
like a factor of two better than mikali

307
00:11:56,480 --> 00:11:58,720
okay our construction

308
00:11:58,720 --> 00:12:01,120
um so only have time to describe the

309
00:12:01,120 --> 00:12:02,800
construction i won't have time to give

310
00:12:02,800 --> 00:12:04,560
you a proof

311
00:12:04,560 --> 00:12:06,880
um but

312
00:12:06,880 --> 00:12:09,440
i'll give the intuition of why this is

313
00:12:09,440 --> 00:12:12,320
secure on the way

314
00:12:12,480 --> 00:12:15,120
okay so our starting point is mikali's

315
00:12:15,120 --> 00:12:18,000
construction okay like think of mikali

316
00:12:18,000 --> 00:12:19,760
like you take a pcp you do this merkel

317
00:12:19,760 --> 00:12:20,880
route

318
00:12:20,880 --> 00:12:22,320
and then you give all the authentication

319
00:12:22,320 --> 00:12:24,639
passes this is our starting point

320
00:12:24,639 --> 00:12:26,240
what we are going to do

321
00:12:26,240 --> 00:12:27,920
is we are going to set

322
00:12:27,920 --> 00:12:28,800
the

323
00:12:28,800 --> 00:12:30,720
oracle output sides

324
00:12:30,720 --> 00:12:32,240
to be log t

325
00:12:32,240 --> 00:12:33,440
okay

326
00:12:33,440 --> 00:12:34,880
so um

327
00:12:34,880 --> 00:12:37,360
first once we set it to b log t actually

328
00:12:37,360 --> 00:12:39,200
we exactly get the

329
00:12:39,200 --> 00:12:41,680
uh the argument size that we want

330
00:12:41,680 --> 00:12:43,680
okay because it's going to be q which is

331
00:12:43,680 --> 00:12:46,399
oct of epsilon times log t okay so the

332
00:12:46,399 --> 00:12:48,800
argument size is right but i just

333
00:12:48,800 --> 00:12:50,560
convinced you that you shouldn't use

334
00:12:50,560 --> 00:12:54,320
this this output size of the molecule

335
00:12:54,320 --> 00:12:55,760
um

336
00:12:55,760 --> 00:12:58,800
okay but now okay so just using this the

337
00:12:58,800 --> 00:13:00,880
construction is not secure of course and

338
00:13:00,880 --> 00:13:02,480
what we're going to do we're going to

339
00:13:02,480 --> 00:13:04,800
introduce a few changes that together

340
00:13:04,800 --> 00:13:05,760
are going to make sure that the

341
00:13:05,760 --> 00:13:08,000
construction is secure

342
00:13:08,000 --> 00:13:10,959
so make four main changes okay we chop

343
00:13:10,959 --> 00:13:12,480
the three we introduce the main

344
00:13:12,480 --> 00:13:14,959
separation we permute the proof and we

345
00:13:14,959 --> 00:13:17,279
use robust pcps okay i'm gonna shortly

346
00:13:17,279 --> 00:13:18,800
describe this

347
00:13:18,800 --> 00:13:20,240
and i just want to say that these

348
00:13:20,240 --> 00:13:23,279
changes they do not increase the the

349
00:13:23,279 --> 00:13:25,440
argument size okay so we're left with

350
00:13:25,440 --> 00:13:28,240
the argument size that we want

351
00:13:28,240 --> 00:13:30,160
each and every one separate doesn't do a

352
00:13:30,160 --> 00:13:32,079
lot but combined they actually do

353
00:13:32,079 --> 00:13:35,279
increase security okay and this is what

354
00:13:35,279 --> 00:13:36,959
lets us reduce the output size of the

355
00:13:36,959 --> 00:13:39,360
random orbital to just look t

356
00:13:39,360 --> 00:13:40,240
okay

357
00:13:40,240 --> 00:13:42,800
and just a comment this also works when

358
00:13:42,800 --> 00:13:45,600
you add salts which is very good for

359
00:13:45,600 --> 00:13:47,760
for zero knowledge okay but i'm not

360
00:13:47,760 --> 00:13:49,839
gonna talk about their own knowledge

361
00:13:49,839 --> 00:13:52,079
here

362
00:13:52,079 --> 00:13:52,959
okay

363
00:13:52,959 --> 00:13:54,160
so

364
00:13:54,160 --> 00:13:56,560
this is michali right you take the pcp

365
00:13:56,560 --> 00:13:58,720
you do american tree you derive

366
00:13:58,720 --> 00:14:00,079
randomness and then you give all the

367
00:14:00,079 --> 00:14:02,320
authentication paths

368
00:14:02,320 --> 00:14:04,800
so we're going to change this

369
00:14:04,800 --> 00:14:07,040
this commitment okay so instead of

370
00:14:07,040 --> 00:14:08,639
sending the root

371
00:14:08,639 --> 00:14:10,480
we're going to chop the tree at some

372
00:14:10,480 --> 00:14:12,320
layer i star

373
00:14:12,320 --> 00:14:14,320
okay so what i mean let's say you choose

374
00:14:14,320 --> 00:14:16,560
some layer i star okay which i'm gonna

375
00:14:16,560 --> 00:14:18,639
choose okay soon

376
00:14:18,639 --> 00:14:19,440
and

377
00:14:19,440 --> 00:14:21,360
you stop computing the mercury at this

378
00:14:21,360 --> 00:14:23,760
layer okay and then you take all the

379
00:14:23,760 --> 00:14:25,600
node in this layer we might have many

380
00:14:25,600 --> 00:14:28,160
nodes in this layer you treat them as

381
00:14:28,160 --> 00:14:29,680
one like

382
00:14:29,680 --> 00:14:32,320
long concatenated string okay and this

383
00:14:32,320 --> 00:14:34,639
is like your new root so you apply the

384
00:14:34,639 --> 00:14:36,560
random oracle to all of this to to

385
00:14:36,560 --> 00:14:40,079
derive pcp randomness

386
00:14:41,040 --> 00:14:44,639
okay so this is just a chopped tree

387
00:14:44,639 --> 00:14:47,839
um okay so when i start equal zero this

388
00:14:47,839 --> 00:14:50,560
is mikali okay i didn't do anything

389
00:14:50,560 --> 00:14:53,680
when i start equals log n log l

390
00:14:53,680 --> 00:14:55,920
okay so this means that you just you

391
00:14:55,920 --> 00:14:57,519
chop here meaning you just send the

392
00:14:57,519 --> 00:14:58,959
entire pcp

393
00:14:58,959 --> 00:15:01,040
okay so this means that you have

394
00:15:01,040 --> 00:15:04,079
excellent security okay but your puff

395
00:15:04,079 --> 00:15:06,639
length is like very very large

396
00:15:06,639 --> 00:15:09,199
okay and in general

397
00:15:09,199 --> 00:15:11,920
as i start is larger the security is

398
00:15:11,920 --> 00:15:14,000
better it's higher okay

399
00:15:14,000 --> 00:15:16,880
but the argument size is also larger

400
00:15:16,880 --> 00:15:19,040
okay and the question is what is the

401
00:15:19,040 --> 00:15:21,199
best point and in general this trade-off

402
00:15:21,199 --> 00:15:24,800
is not in your favor okay except for one

403
00:15:24,800 --> 00:15:27,600
specifically value of i style

404
00:15:27,600 --> 00:15:30,000
and this is going to be log q

405
00:15:30,000 --> 00:15:31,839
okay well again q is the number of

406
00:15:31,839 --> 00:15:34,720
queries in the pcp

407
00:15:34,720 --> 00:15:35,839
and

408
00:15:35,839 --> 00:15:38,800
for this specific setting we actually

409
00:15:38,800 --> 00:15:41,120
can show that we get better security and

410
00:15:41,120 --> 00:15:43,759
we get the same argument size

411
00:15:43,759 --> 00:15:44,560
okay

412
00:15:44,560 --> 00:15:46,720
and why do we get the same argument size

413
00:15:46,720 --> 00:15:48,000
this is because

414
00:15:48,000 --> 00:15:51,839
anyway you're going to open queue paths

415
00:15:51,839 --> 00:15:54,399
okay so if you look at level log q that

416
00:15:54,399 --> 00:15:56,639
has q nodes in it

417
00:15:56,639 --> 00:15:58,399
anyway the proof is going to contain

418
00:15:58,399 --> 00:16:00,639
with high probability almost all of

419
00:16:00,639 --> 00:16:02,639
these nodes

420
00:16:02,639 --> 00:16:05,360
okay so sending all of the nodes really

421
00:16:05,360 --> 00:16:07,440
doesn't increase the the actual proof

422
00:16:07,440 --> 00:16:09,759
sites

423
00:16:10,959 --> 00:16:12,079
and

424
00:16:12,079 --> 00:16:14,320
just some comment on why

425
00:16:14,320 --> 00:16:17,440
this helps so if you remember the attack

426
00:16:17,440 --> 00:16:19,120
that i described before where you

427
00:16:19,120 --> 00:16:20,480
guessed the rules in advance and then

428
00:16:20,480 --> 00:16:22,959
you know the entire randomness

429
00:16:22,959 --> 00:16:25,519
okay and and this lets you win this this

430
00:16:25,519 --> 00:16:28,720
is this was one little bound that

431
00:16:28,720 --> 00:16:30,160
made us set the

432
00:16:30,160 --> 00:16:32,639
random oracle to look to your episode

433
00:16:32,639 --> 00:16:36,399
here you cannot guess all of this cap at

434
00:16:36,399 --> 00:16:39,120
once okay you can guess maybe a single

435
00:16:39,120 --> 00:16:41,759
node okay and then if you do that you

436
00:16:41,759 --> 00:16:45,680
can only control a small part of the pcp

437
00:16:45,680 --> 00:16:48,000
okay which hopefully doesn't increase

438
00:16:48,000 --> 00:16:51,839
your probability by too much

439
00:16:52,880 --> 00:16:55,759
okay the second change is a very simple

440
00:16:55,759 --> 00:16:58,959
change okay we call it domain separation

441
00:16:58,959 --> 00:17:00,959
uh so we're going to use a different

442
00:17:00,959 --> 00:17:03,680
overkill for every location in the three

443
00:17:03,680 --> 00:17:05,520
okay and because this is a random

444
00:17:05,520 --> 00:17:08,000
overkill this is easily achieved just by

445
00:17:08,000 --> 00:17:09,919
you know putting a prefix

446
00:17:09,919 --> 00:17:12,240
for every query location i j

447
00:17:12,240 --> 00:17:15,359
so if i have some node in level i of the

448
00:17:15,359 --> 00:17:18,319
three you know it's the jth node in that

449
00:17:18,319 --> 00:17:22,160
level i just put this prefix there

450
00:17:22,160 --> 00:17:25,679
okay and this prevents reusing uh

451
00:17:25,679 --> 00:17:27,679
inversion all collisions in different

452
00:17:27,679 --> 00:17:30,400
parts of the trees so if i the versary

453
00:17:30,400 --> 00:17:33,360
found some collision okay on one node in

454
00:17:33,360 --> 00:17:35,679
the tree he cannot use this collision in

455
00:17:35,679 --> 00:17:38,080
a in a different node because

456
00:17:38,080 --> 00:17:39,840
he's going to need to use different

457
00:17:39,840 --> 00:17:42,559
prefixes this of course does not

458
00:17:42,559 --> 00:17:44,240
increase the

459
00:17:44,240 --> 00:17:45,679
the size of the

460
00:17:45,679 --> 00:17:47,360
of the proof because these i and j's you

461
00:17:47,360 --> 00:17:49,760
don't need to write them explicitly

462
00:17:49,760 --> 00:17:50,880
okay

463
00:17:50,880 --> 00:17:52,080
um

464
00:17:52,080 --> 00:17:54,160
so just an example the prefix of this

465
00:17:54,160 --> 00:17:56,480
node is one one one two one three up to

466
00:17:56,480 --> 00:17:59,360
116 in this example two one two two okay

467
00:17:59,360 --> 00:18:01,679
so you just add the prefixes everywhere

468
00:18:01,679 --> 00:18:03,200
and this really

469
00:18:03,200 --> 00:18:05,280
splits the oracle to be different for

470
00:18:05,280 --> 00:18:06,320
every

471
00:18:06,320 --> 00:18:09,120
position in the tree

472
00:18:09,120 --> 00:18:11,520
okay change number three

473
00:18:11,520 --> 00:18:14,960
um permuting the proof

474
00:18:14,960 --> 00:18:17,520
so we're gonna permute the pcp proof

475
00:18:17,520 --> 00:18:20,080
before applying the chopped

476
00:18:20,080 --> 00:18:21,520
merkel tree

477
00:18:21,520 --> 00:18:23,440
okay what i mean permit the pcp we're

478
00:18:23,440 --> 00:18:26,480
gonna permute the locations of the proof

479
00:18:26,480 --> 00:18:27,600
okay

480
00:18:27,600 --> 00:18:28,640
so

481
00:18:28,640 --> 00:18:30,799
for simplicity we're just gonna assume

482
00:18:30,799 --> 00:18:34,480
access to a random permutation okay over

483
00:18:34,480 --> 00:18:37,120
l over the positions one to l okay l is

484
00:18:37,120 --> 00:18:38,720
the size of the pcp

485
00:18:38,720 --> 00:18:39,840
this is just

486
00:18:39,840 --> 00:18:42,320
simplifying assumption for now okay of

487
00:18:42,320 --> 00:18:43,360
course you can implement this

488
00:18:43,360 --> 00:18:46,720
permutation like using uh lubirakov okay

489
00:18:46,720 --> 00:18:48,799
for miranda markle i'm not going to go

490
00:18:48,799 --> 00:18:51,120
into those details

491
00:18:51,120 --> 00:18:52,480
um

492
00:18:52,480 --> 00:18:53,520
and

493
00:18:53,520 --> 00:18:56,240
the reason this creates the effect as as

494
00:18:56,240 --> 00:18:58,480
if you had a pcp with uniform random

495
00:18:58,480 --> 00:19:00,559
query so if you have a pcp with uniform

496
00:19:00,559 --> 00:19:02,720
random queries to begin with and then

497
00:19:02,720 --> 00:19:03,919
that's grating you don't need this

498
00:19:03,919 --> 00:19:05,840
permutation okay

499
00:19:05,840 --> 00:19:06,799
but

500
00:19:06,799 --> 00:19:09,120
in general you might have a pcp that has

501
00:19:09,120 --> 00:19:10,799
like you know

502
00:19:10,799 --> 00:19:12,559
the distribution of queries is not

503
00:19:12,559 --> 00:19:15,840
uniform and i want every single query to

504
00:19:15,840 --> 00:19:18,720
be like to a uniform position so i just

505
00:19:18,720 --> 00:19:21,600
permit the positions of the of the proof

506
00:19:21,600 --> 00:19:23,520
okay so the position is important

507
00:19:23,520 --> 00:19:25,120
because of the way the milkity is

508
00:19:25,120 --> 00:19:27,679
constructed is constructed okay it's

509
00:19:27,679 --> 00:19:29,840
just the pcp like the positions really

510
00:19:29,840 --> 00:19:32,480
mean nothing

511
00:19:32,640 --> 00:19:34,799
um okay so it's the same construction we

512
00:19:34,799 --> 00:19:37,200
have the cap we have the prefixes and

513
00:19:37,200 --> 00:19:39,760
now instead of writing the pct epcp

514
00:19:39,760 --> 00:19:42,640
itself i'm permuting the pcp randomly

515
00:19:42,640 --> 00:19:44,880
okay and then and then writing this so

516
00:19:44,880 --> 00:19:47,120
this might be position number 10 this

517
00:19:47,120 --> 00:19:49,280
might be position number two position

518
00:19:49,280 --> 00:19:51,440
number 25 and so on

519
00:19:51,440 --> 00:19:53,520
okay

520
00:19:53,520 --> 00:19:55,280
but in every subtree we're going to have

521
00:19:55,280 --> 00:20:00,000
like a random subset of the of the pcb

522
00:20:01,679 --> 00:20:02,720
um

523
00:20:02,720 --> 00:20:04,799
okay change number four

524
00:20:04,799 --> 00:20:07,840
a robust pcp so as we said we're going

525
00:20:07,840 --> 00:20:09,840
to use something stronger than the

526
00:20:09,840 --> 00:20:13,280
standard a soundness notion of pcps

527
00:20:13,280 --> 00:20:15,280
okay so this is a strong notion of pcp

528
00:20:15,280 --> 00:20:18,000
we call permuted robust pcps this has to

529
00:20:18,000 --> 00:20:20,640
do with how we promote the proof

530
00:20:20,640 --> 00:20:22,000
and

531
00:20:22,000 --> 00:20:24,320
the intuition of robust pcps in general

532
00:20:24,320 --> 00:20:26,799
i like about recipes not a new notion

533
00:20:26,799 --> 00:20:28,240
is that

534
00:20:28,240 --> 00:20:30,720
if the proverb changes just a small

535
00:20:30,720 --> 00:20:32,240
number of symbols

536
00:20:32,240 --> 00:20:34,720
after the fact okay after the verifier

537
00:20:34,720 --> 00:20:38,400
already decided on what symbols to read

538
00:20:38,400 --> 00:20:39,919
okay so the approval commits to some

539
00:20:39,919 --> 00:20:41,919
proof the verifier randomly chooses

540
00:20:41,919 --> 00:20:43,840
which symbols to read and then after

541
00:20:43,840 --> 00:20:45,840
that you allow the power to change a few

542
00:20:45,840 --> 00:20:47,919
symbols still he cannot make the

543
00:20:47,919 --> 00:20:49,520
verifier accept

544
00:20:49,520 --> 00:20:51,679
okay so the local view of the verifier

545
00:20:51,679 --> 00:20:55,520
is actually far from being accepting

546
00:20:56,960 --> 00:20:58,400
uh and

547
00:20:58,400 --> 00:20:59,280
will

548
00:20:59,280 --> 00:21:02,240
we want such a such a notion uh i'll

549
00:21:02,240 --> 00:21:03,360
nothing

550
00:21:03,360 --> 00:21:04,320
is gonna

551
00:21:04,320 --> 00:21:06,000
introduce something called the blocks so

552
00:21:06,000 --> 00:21:07,679
we're gonna have a parameter b which is

553
00:21:07,679 --> 00:21:09,760
the number of blocks and we're gonna

554
00:21:09,760 --> 00:21:11,760
assume we have a random permutation over

555
00:21:11,760 --> 00:21:12,720
l

556
00:21:12,720 --> 00:21:13,520
okay

557
00:21:13,520 --> 00:21:16,000
and then we're gonna define distance

558
00:21:16,000 --> 00:21:18,080
okay so this is not going to be distance

559
00:21:18,080 --> 00:21:20,720
by a single symbol locations but

560
00:21:20,720 --> 00:21:23,440
actually a block-wise distance so it's

561
00:21:23,440 --> 00:21:25,360
the block-wise distance

562
00:21:25,360 --> 00:21:26,480
um

563
00:21:26,480 --> 00:21:28,559
after you permute the strings according

564
00:21:28,559 --> 00:21:31,280
to to this spell okay so

565
00:21:31,280 --> 00:21:33,440
i take the two strings i permute them

566
00:21:33,440 --> 00:21:35,360
and then i look at the block

567
00:21:35,360 --> 00:21:37,600
block difference

568
00:21:37,600 --> 00:21:40,960
okay so for example

569
00:21:40,960 --> 00:21:42,960
the difference between these two strings

570
00:21:42,960 --> 00:21:45,600
is one why so these two blocks all these

571
00:21:45,600 --> 00:21:47,600
blocks are exactly the same

572
00:21:47,600 --> 00:21:50,080
and then you have these two blocks where

573
00:21:50,080 --> 00:21:51,600
even though they have two different

574
00:21:51,600 --> 00:21:53,360
locations it's just one block that is

575
00:21:53,360 --> 00:21:56,880
different okay so the the distance is is

576
00:21:56,880 --> 00:21:59,840
one in this case

577
00:22:00,799 --> 00:22:02,159
so what

578
00:22:02,159 --> 00:22:04,559
given this definition of distance

579
00:22:04,559 --> 00:22:07,840
uh what is our notion of pcp

580
00:22:07,840 --> 00:22:10,240
um

581
00:22:10,880 --> 00:22:11,840
so

582
00:22:11,840 --> 00:22:13,760
it's the following

583
00:22:13,760 --> 00:22:15,919
okay so um

584
00:22:15,919 --> 00:22:20,080
we have a parameter b and a distance d

585
00:22:20,080 --> 00:22:22,400
and then we first publish a random

586
00:22:22,400 --> 00:22:24,320
permutation okay so there's a two linear

587
00:22:24,320 --> 00:22:26,640
permutation but it's known to everybody

588
00:22:26,640 --> 00:22:28,960
known to the poor beforehand

589
00:22:28,960 --> 00:22:29,840
okay

590
00:22:29,840 --> 00:22:30,960
the

591
00:22:30,960 --> 00:22:32,799
cheating approval p

592
00:22:32,799 --> 00:22:35,919
outputs a pcp string okay so he commits

593
00:22:35,919 --> 00:22:38,559
to some pcp string pi

594
00:22:38,559 --> 00:22:40,880
okay the verifier sample is pcp

595
00:22:40,880 --> 00:22:42,400
randomness law

596
00:22:42,400 --> 00:22:43,919
he gives this

597
00:22:43,919 --> 00:22:45,280
to the approval

598
00:22:45,280 --> 00:22:46,880
okay so he gives another respect to the

599
00:22:46,880 --> 00:22:48,320
approval

600
00:22:48,320 --> 00:22:50,000
and now the puller is actually allowed

601
00:22:50,000 --> 00:22:53,760
to output a different pcp string okay as

602
00:22:53,760 --> 00:22:56,080
a function of the randomness rule okay

603
00:22:56,080 --> 00:22:58,880
so different pcp string pi

604
00:22:58,880 --> 00:22:59,919
but

605
00:22:59,919 --> 00:23:01,919
okay the game is going to output one

606
00:23:01,919 --> 00:23:04,559
okay so it's going to win if and only if

607
00:23:04,559 --> 00:23:06,640
not only of course the verifier accepted

608
00:23:06,640 --> 00:23:09,200
the new news the new proof this is like

609
00:23:09,200 --> 00:23:12,000
easy okay but the new string should be

610
00:23:12,000 --> 00:23:14,640
close to the original proof

611
00:23:14,640 --> 00:23:17,840
okay so the the the distance between the

612
00:23:17,840 --> 00:23:19,760
two is at most d

613
00:23:19,760 --> 00:23:22,400
okay and this distance relative to this

614
00:23:22,400 --> 00:23:24,400
block parameter b and and this random

615
00:23:24,400 --> 00:23:26,559
permutation

616
00:23:26,559 --> 00:23:27,840
so this is the

617
00:23:27,840 --> 00:23:28,799
the

618
00:23:28,799 --> 00:23:31,840
our like permuted robust pcp

619
00:23:31,840 --> 00:23:34,240
okay well just a standard robust pcp

620
00:23:34,240 --> 00:23:37,120
would be without this permutation at all

621
00:23:37,120 --> 00:23:41,199
okay and then the b would be one

622
00:23:43,919 --> 00:23:44,960
okay

623
00:23:44,960 --> 00:23:46,080
and

624
00:23:46,080 --> 00:23:47,520
we're going to say that the pcp has

625
00:23:47,520 --> 00:23:49,679
robustness ratio better

626
00:23:49,679 --> 00:23:51,279
if for any d

627
00:23:51,279 --> 00:23:53,600
the ratio of it is between these two

628
00:23:53,600 --> 00:23:55,440
things is

629
00:23:55,440 --> 00:23:58,400
bounded by beta

630
00:24:00,080 --> 00:24:02,240
okay so um

631
00:24:02,240 --> 00:24:04,880
if you increase the distance by one and

632
00:24:04,880 --> 00:24:07,440
you look at the distance with d okay so

633
00:24:07,440 --> 00:24:09,679
this ratio is bounded by by beta of

634
00:24:09,679 --> 00:24:11,760
course you increase the probability of

635
00:24:11,760 --> 00:24:13,919
the verifier but you can bound the ratio

636
00:24:13,919 --> 00:24:16,480
okay so then we say it has a

637
00:24:16,480 --> 00:24:18,960
robustness

638
00:24:18,960 --> 00:24:22,000
and um

639
00:24:22,320 --> 00:24:23,760
so we're going to

640
00:24:23,760 --> 00:24:26,880
use such a pcp we also construct this

641
00:24:26,880 --> 00:24:29,279
pcp okay and this is like the fourth

642
00:24:29,279 --> 00:24:32,320
change in the proof okay uh compared to

643
00:24:32,320 --> 00:24:35,600
mikali that can just use any pcp and so

644
00:24:35,600 --> 00:24:37,679
this is the final construction we have

645
00:24:37,679 --> 00:24:39,520
the chopped tree

646
00:24:39,520 --> 00:24:42,400
okay we have the domain separation

647
00:24:42,400 --> 00:24:44,159
and we permute the proof

648
00:24:44,159 --> 00:24:46,799
okay and we use a

649
00:24:46,799 --> 00:24:49,200
we use this robust pcp

650
00:24:49,200 --> 00:24:52,000
okay so this is a permuted proof of a

651
00:24:52,000 --> 00:24:54,880
robust pcp

652
00:24:56,000 --> 00:24:57,919
okay

653
00:24:57,919 --> 00:24:59,200
and

654
00:24:59,200 --> 00:25:01,279
i don't have time to show the the pope

655
00:25:01,279 --> 00:25:03,039
i'm just gonna say the security is shown

656
00:25:03,039 --> 00:25:04,640
in two steps

657
00:25:04,640 --> 00:25:06,559
um

658
00:25:06,559 --> 00:25:08,799
so first we show that permitted robust

659
00:25:08,799 --> 00:25:12,960
pcps plus this weak commitment okay so

660
00:25:12,960 --> 00:25:15,360
it's a chop three plus domain separation

661
00:25:15,360 --> 00:25:17,840
puts the permutation okay you actually

662
00:25:17,840 --> 00:25:19,840
get some quadratic snogs

663
00:25:19,840 --> 00:25:22,000
and then the second step is of course

664
00:25:22,000 --> 00:25:25,360
constructing permitted robust pcps okay

665
00:25:25,360 --> 00:25:27,600
so we show that these pcps exist with

666
00:25:27,600 --> 00:25:29,279
good parameters

667
00:25:29,279 --> 00:25:32,960
um just by showing that a a repeated pcp

668
00:25:32,960 --> 00:25:35,600
actually can

669
00:25:35,600 --> 00:25:37,840
so you can take any like base pcp repeat

670
00:25:37,840 --> 00:25:39,760
it and this construction actually has

671
00:25:39,760 --> 00:25:42,080
has the the soundness notion that we

672
00:25:42,080 --> 00:25:44,320
want

673
00:25:44,720 --> 00:25:45,840
okay

674
00:25:45,840 --> 00:25:48,799
so just a summary we have shown as now

675
00:25:48,799 --> 00:25:51,520
of size log t over epsilon times log t

676
00:25:51,520 --> 00:25:53,760
in the random oracle model

677
00:25:53,760 --> 00:25:56,400
the lower bound is this and

678
00:25:56,400 --> 00:26:00,000
just the major open question here

679
00:26:00,000 --> 00:26:00,799
and

680
00:26:00,799 --> 00:26:02,880
like you know like wishful thinking you

681
00:26:02,880 --> 00:26:05,360
know i hope the answer is yes are there

682
00:26:05,360 --> 00:26:08,480
snogs in the random oracle model of size

683
00:26:08,480 --> 00:26:11,840
or log t over epsilon

684
00:26:11,840 --> 00:26:13,840
okay that of course would be like an

685
00:26:13,840 --> 00:26:16,159
amazing improvement and i guess also

686
00:26:16,159 --> 00:26:20,240
like have many practical considerations

687
00:26:20,240 --> 00:26:22,400
okay thank you guys

688
00:26:22,400 --> 00:26:24,480
very much

689
00:26:24,480 --> 00:26:27,480
bye

