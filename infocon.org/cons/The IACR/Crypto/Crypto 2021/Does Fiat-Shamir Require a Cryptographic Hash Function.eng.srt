1
00:00:00,719 --> 00:00:02,879
all right hi everyone um this talk is

2
00:00:02,879 --> 00:00:04,400
called does fiat shamir require a

3
00:00:04,400 --> 00:00:06,160
cryptographic hash function my name is

4
00:00:06,160 --> 00:00:08,320
fermi ma and i'll be giving this talk uh

5
00:00:08,320 --> 00:00:10,000
this is based on joint work with eli

6
00:00:10,000 --> 00:00:14,080
chen alex lombardi and willie plush

7
00:00:15,040 --> 00:00:16,400
all right so i'll be talking today about

8
00:00:16,400 --> 00:00:18,720
public coin interactive protocols so we

9
00:00:18,720 --> 00:00:20,080
have a prover on the left and a verifier

10
00:00:20,080 --> 00:00:21,680
on the right and the prover wants to

11
00:00:21,680 --> 00:00:23,039
convince the verifier that some kind of

12
00:00:23,039 --> 00:00:25,199
statement is true so for instance x is

13
00:00:25,199 --> 00:00:28,560
in 3sat or that it knows a witness for x

14
00:00:28,560 --> 00:00:29,679
and the way the proofer is going to do

15
00:00:29,679 --> 00:00:31,039
this is they're going to have a back and

16
00:00:31,039 --> 00:00:32,880
forth interaction with the verifier so

17
00:00:32,880 --> 00:00:35,040
it sends over messages these ais and the

18
00:00:35,040 --> 00:00:36,880
verifier responds by sampling uniformly

19
00:00:36,880 --> 00:00:39,280
random coins and sending them back

20
00:00:39,280 --> 00:00:40,719
at the end of this interaction the

21
00:00:40,719 --> 00:00:42,480
verifier determines whether or not to

22
00:00:42,480 --> 00:00:44,320
accept just based on the transfer below

23
00:00:44,320 --> 00:00:46,960
there's no private randomness here

24
00:00:46,960 --> 00:00:48,399
so there's two properties that we always

25
00:00:48,399 --> 00:00:49,680
want to satisfy

26
00:00:49,680 --> 00:00:50,879
one is completeness and there's

27
00:00:50,879 --> 00:00:52,879
soundness completeness says that if the

28
00:00:52,879 --> 00:00:54,559
statement is true then the verifier

29
00:00:54,559 --> 00:00:56,719
should accept with probability one

30
00:00:56,719 --> 00:00:58,399
and soundness says that if statement is

31
00:00:58,399 --> 00:00:59,920
false then the verifier should reject

32
00:00:59,920 --> 00:01:01,520
the high probability no matter what the

33
00:01:01,520 --> 00:01:02,960
proofer does even if it deviates from

34
00:01:02,960 --> 00:01:05,280
the protocol

35
00:01:05,280 --> 00:01:06,720
so we know that interaction is really

36
00:01:06,720 --> 00:01:08,320
powerful there's a lot you can do with

37
00:01:08,320 --> 00:01:09,920
interaction you can prove anything in p

38
00:01:09,920 --> 00:01:11,280
space you can prove things in zero

39
00:01:11,280 --> 00:01:12,240
knowledge you can prove things

40
00:01:12,240 --> 00:01:14,320
distinctly

41
00:01:14,320 --> 00:01:15,759
but we know that interaction is also

42
00:01:15,759 --> 00:01:17,759
quite impractical it's a very unwieldy

43
00:01:17,759 --> 00:01:19,280
assumption to have to make that your two

44
00:01:19,280 --> 00:01:20,320
parties are going to wait for each

45
00:01:20,320 --> 00:01:22,000
other's messages to be received so

46
00:01:22,000 --> 00:01:23,600
whenever possible we want to do things

47
00:01:23,600 --> 00:01:25,200
non-interactively

48
00:01:25,200 --> 00:01:26,479
and that brings me to the theater near

49
00:01:26,479 --> 00:01:28,560
heuristic which in a nutshell is a

50
00:01:28,560 --> 00:01:30,560
magical compiler that somehow removes

51
00:01:30,560 --> 00:01:32,240
interaction from public coin interactive

52
00:01:32,240 --> 00:01:33,520
protocols

53
00:01:33,520 --> 00:01:35,600
so here's how it works

54
00:01:35,600 --> 00:01:37,520
the prover and verifier are going to

55
00:01:37,520 --> 00:01:41,280
agree on some fiat mere hash function h

56
00:01:41,280 --> 00:01:42,880
and now the prover instead of having a

57
00:01:42,880 --> 00:01:44,079
back and forth conversation with the

58
00:01:44,079 --> 00:01:45,840
verifier is essentially going to

59
00:01:45,840 --> 00:01:47,680
simulate this conversation

60
00:01:47,680 --> 00:01:49,520
and every time the verifier is supposed

61
00:01:49,520 --> 00:01:51,439
to send a random message the proofer is

62
00:01:51,439 --> 00:01:53,360
instead going to compute that message by

63
00:01:53,360 --> 00:01:55,200
applying the hash function h to the

64
00:01:55,200 --> 00:01:57,280
transcript of the interaction so far

65
00:01:57,280 --> 00:01:58,960
so let's watch it happen the proofer

66
00:01:58,960 --> 00:02:01,119
computes the first message a1 then when

67
00:02:01,119 --> 00:02:02,719
it needs the next challenge it computes

68
00:02:02,719 --> 00:02:04,960
h applied to a1

69
00:02:04,960 --> 00:02:06,799
responds with a2 then for the next

70
00:02:06,799 --> 00:02:09,038
challenge it computes that is h of a1 a2

71
00:02:09,038 --> 00:02:11,280
and so on and so forth

72
00:02:11,280 --> 00:02:12,800
and the prover can send all these ai's

73
00:02:12,800 --> 00:02:14,720
to the verifier the verifier can just

74
00:02:14,720 --> 00:02:17,280
recompute all these uh challenges ri by

75
00:02:17,280 --> 00:02:19,120
applying the hash the to the transform

76
00:02:19,120 --> 00:02:20,080
so far

77
00:02:20,080 --> 00:02:21,840
and at the end the verifier just decides

78
00:02:21,840 --> 00:02:23,520
whether or not to accept or reject based

79
00:02:23,520 --> 00:02:24,720
on whether or not the interactive

80
00:02:24,720 --> 00:02:28,480
verifier would have accepted or rejected

81
00:02:28,480 --> 00:02:29,760
this has been an extraordinarily

82
00:02:29,760 --> 00:02:32,080
fruitful approach to constructing crypto

83
00:02:32,080 --> 00:02:33,440
so the idea is you build some

84
00:02:33,440 --> 00:02:34,959
interactive protocol for desired

85
00:02:34,959 --> 00:02:37,120
functionality such as identify yourself

86
00:02:37,120 --> 00:02:38,800
over the internet to someone and then

87
00:02:38,800 --> 00:02:40,640
you apply fiat chemir you create a

88
00:02:40,640 --> 00:02:42,480
non-interactive protocol for the same

89
00:02:42,480 --> 00:02:44,560
functionality

90
00:02:44,560 --> 00:02:46,720
the important question of course is when

91
00:02:46,720 --> 00:02:48,160
exactly does this does this

92
00:02:48,160 --> 00:02:50,480
transformation preserve soundness

93
00:02:50,480 --> 00:02:52,239
so here's the intuition we have right we

94
00:02:52,239 --> 00:02:54,239
have some interactive protocol that's

95
00:02:54,239 --> 00:02:56,160
sound when the rise are chosen randomly

96
00:02:56,160 --> 00:02:58,400
and out of the prover's hands

97
00:02:58,400 --> 00:02:59,840
and now the fiat mirror hash function

98
00:02:59,840 --> 00:03:01,599
should essentially play that role right

99
00:03:01,599 --> 00:03:02,800
we don't have any guarantee of the

100
00:03:02,800 --> 00:03:04,640
protocol of sound when the prover can

101
00:03:04,640 --> 00:03:06,640
pick the rise for itself but the

102
00:03:06,640 --> 00:03:07,760
theatrimer hash function should

103
00:03:07,760 --> 00:03:09,680
essentially bound the prover to not be

104
00:03:09,680 --> 00:03:11,840
able to come up with arbitrary good ris

105
00:03:11,840 --> 00:03:15,840
that will allow it to fool the verifier

106
00:03:15,840 --> 00:03:17,440
there's basically two known approaches

107
00:03:17,440 --> 00:03:18,959
for giving positive results with the

108
00:03:18,959 --> 00:03:21,760
etch mirror one is to treat the hash

109
00:03:21,760 --> 00:03:24,080
function h essentially a random oracle

110
00:03:24,080 --> 00:03:25,840
and you can show that in most cases if

111
00:03:25,840 --> 00:03:27,519
the hash function is a random oracle the

112
00:03:27,519 --> 00:03:28,959
theatrical mirror transformation is in

113
00:03:28,959 --> 00:03:30,239
fact sound

114
00:03:30,239 --> 00:03:31,680
and more recently there's an exciting

115
00:03:31,680 --> 00:03:33,760
line of work showing uh fiat smear

116
00:03:33,760 --> 00:03:35,360
compilation in the standard model in

117
00:03:35,360 --> 00:03:37,200
particular showing that when the hash

118
00:03:37,200 --> 00:03:38,720
function satisfies a property known as

119
00:03:38,720 --> 00:03:40,400
correlation and tractability there's a

120
00:03:40,400 --> 00:03:41,599
lot of interesting theosmere

121
00:03:41,599 --> 00:03:44,239
compilations that you can do

122
00:03:44,239 --> 00:03:45,760
but in all these cases this feature

123
00:03:45,760 --> 00:03:47,200
mirror hash function h is a

124
00:03:47,200 --> 00:03:49,360
cryptographic hash function and there is

125
00:03:49,360 --> 00:03:50,879
some sort of computational hardness

126
00:03:50,879 --> 00:03:53,760
coming from the hash function itself

127
00:03:53,760 --> 00:03:55,680
in this work we asked the question is

128
00:03:55,680 --> 00:03:57,599
this really necessary is it necessary

129
00:03:57,599 --> 00:04:01,519
for sound fiat smear compilation

130
00:04:01,519 --> 00:04:03,280
so our first set of results perhaps

131
00:04:03,280 --> 00:04:04,480
surprisingly are actually positive

132
00:04:04,480 --> 00:04:06,000
results where we show that some

133
00:04:06,000 --> 00:04:07,760
protocols don't seem to need

134
00:04:07,760 --> 00:04:10,799
cryptographic fiat smear hash functions

135
00:04:10,799 --> 00:04:13,280
so in particular what i mean by a simple

136
00:04:13,280 --> 00:04:14,959
non-cryptographic the entrepreneur hash

137
00:04:14,959 --> 00:04:17,199
function are things like say compute the

138
00:04:17,199 --> 00:04:19,040
bit decomposition of a vector you have

139
00:04:19,040 --> 00:04:21,519
some vector over zq and the bit decom

140
00:04:21,519 --> 00:04:23,280
bit decomposed vector is just expanding

141
00:04:23,280 --> 00:04:24,479
out every single one of these zq

142
00:04:24,479 --> 00:04:25,680
elements into a bit string

143
00:04:25,680 --> 00:04:27,440
representation of them

144
00:04:27,440 --> 00:04:29,199
or for instance a hash function that

145
00:04:29,199 --> 00:04:31,199
computes a linear function of its inputs

146
00:04:31,199 --> 00:04:32,960
so these hash functions are clearly not

147
00:04:32,960 --> 00:04:35,120
satisfying any any obvious cryptographic

148
00:04:35,120 --> 00:04:36,960
properties they're totally invertible

149
00:04:36,960 --> 00:04:38,160
and yet we show that these hash

150
00:04:38,160 --> 00:04:39,680
functions compile protocols such as

151
00:04:39,680 --> 00:04:41,680
lubashevsky's id protocol schnorr's

152
00:04:41,680 --> 00:04:43,440
protocol john peterson protocol so

153
00:04:43,440 --> 00:04:45,120
various protocols of interest that we'd

154
00:04:45,120 --> 00:04:46,800
actually want to implement

155
00:04:46,800 --> 00:04:49,680
non-interactively

156
00:04:50,639 --> 00:04:52,000
so i should mention that the first

157
00:04:52,000 --> 00:04:53,600
result of uh lubashevsky is in the plain

158
00:04:53,600 --> 00:04:55,040
model whereas all of our group-based

159
00:04:55,040 --> 00:04:56,479
results are shown in the generic group

160
00:04:56,479 --> 00:04:58,800
model

161
00:04:58,960 --> 00:05:00,320
so our second set of results are

162
00:05:00,320 --> 00:05:02,400
negative results basically showing that

163
00:05:02,400 --> 00:05:04,320
cryptographic gets mere hash functions

164
00:05:04,320 --> 00:05:05,919
are necessary for a whole bunch of other

165
00:05:05,919 --> 00:05:07,759
protocols some particular protocols that

166
00:05:07,759 --> 00:05:09,199
do not include the ones that we gave

167
00:05:09,199 --> 00:05:11,280
positive results for so we showed that

168
00:05:11,280 --> 00:05:12,960
for a large class of three message

169
00:05:12,960 --> 00:05:14,160
honest verifiers your knowledge

170
00:05:14,160 --> 00:05:16,240
arguments you actually do need some kind

171
00:05:16,240 --> 00:05:18,240
of cryptography in your hash function in

172
00:05:18,240 --> 00:05:20,080
order to get a sound from the hmir

173
00:05:20,080 --> 00:05:22,240
compilation

174
00:05:22,240 --> 00:05:23,759
so in a little bit more detail we show

175
00:05:23,759 --> 00:05:25,199
that any the engineer hash function that

176
00:05:25,199 --> 00:05:26,960
compiles these protocols must be

177
00:05:26,960 --> 00:05:28,880
something called mix and match resistant

178
00:05:28,880 --> 00:05:30,639
which i'll get into in the second half

179
00:05:30,639 --> 00:05:32,960
of this talk

180
00:05:32,960 --> 00:05:34,880
so example protocols it applies to are

181
00:05:34,880 --> 00:05:37,120
say blum's hamiltonicity protocol

182
00:05:37,120 --> 00:05:39,280
the gmw three coloring protocol and in

183
00:05:39,280 --> 00:05:41,440
fact a one bit challenge uh version of

184
00:05:41,440 --> 00:05:42,960
the schnorr protocol and all these

185
00:05:42,960 --> 00:05:45,440
protocols uh crucially

186
00:05:45,440 --> 00:05:47,840
are sound via parallel repetition

187
00:05:47,840 --> 00:05:49,440
and so this is actually the sort of the

188
00:05:49,440 --> 00:05:51,680
dividing line between the protocols that

189
00:05:51,680 --> 00:05:53,199
we have positive results for and the

190
00:05:53,199 --> 00:05:55,120
ones that we show negative results for

191
00:05:55,120 --> 00:05:56,960
essentially all of our positive results

192
00:05:56,960 --> 00:05:58,639
are for protocols that already sound

193
00:05:58,639 --> 00:06:00,400
already have negligible soundness error

194
00:06:00,400 --> 00:06:02,400
without any parallel repetition

195
00:06:02,400 --> 00:06:03,680
and our negative results apply to

196
00:06:03,680 --> 00:06:05,600
protocols that achieve their soundness

197
00:06:05,600 --> 00:06:06,400
achieve

198
00:06:06,400 --> 00:06:08,160
negligible soundness by a parallel

199
00:06:08,160 --> 00:06:10,560
repetition of a protocol with a small

200
00:06:10,560 --> 00:06:13,199
challenge space

201
00:06:14,400 --> 00:06:15,840
all right so in this talk i'm going to

202
00:06:15,840 --> 00:06:18,800
first give a simple almost toy example

203
00:06:18,800 --> 00:06:20,479
showing that a simple theater mirror

204
00:06:20,479 --> 00:06:22,800
compiler works for turning lewishafc's

205
00:06:22,800 --> 00:06:24,560
three message id protocol into a

206
00:06:24,560 --> 00:06:26,639
one-shot non-interactive

207
00:06:26,639 --> 00:06:29,360
id protocol

208
00:06:29,360 --> 00:06:30,800
and then i'm going to show the a little

209
00:06:30,800 --> 00:06:32,560
more details on the negative results and

210
00:06:32,560 --> 00:06:34,400
explain why some protocols do require a

211
00:06:34,400 --> 00:06:36,400
cryptographic the engineer hash function

212
00:06:36,400 --> 00:06:37,600
and i encourage you all to look at the

213
00:06:37,600 --> 00:06:39,120
paper for more details on how our

214
00:06:39,120 --> 00:06:40,960
group-based results work because i'm not

215
00:06:40,960 --> 00:06:44,000
going to cover those in this talk

216
00:06:44,479 --> 00:06:46,720
so let me start by recapping uh lewisha

217
00:06:46,720 --> 00:06:48,560
id protocol and for those of you

218
00:06:48,560 --> 00:06:50,400
familiar with the the group based short

219
00:06:50,400 --> 00:06:52,319
protocol this is essentially a lattice

220
00:06:52,319 --> 00:06:55,520
analog of that of the schnorr protocol

221
00:06:55,520 --> 00:06:58,240
so here we have uh three parameters a r

222
00:06:58,240 --> 00:07:00,160
and y so a and y are going to be these

223
00:07:00,160 --> 00:07:02,479
two public matrices a is going to be a

224
00:07:02,479 --> 00:07:06,000
random wide matrix over z q

225
00:07:06,000 --> 00:07:07,520
y is going to be statistically close to

226
00:07:07,520 --> 00:07:09,360
random and y is going to be computed

227
00:07:09,360 --> 00:07:10,639
based on

228
00:07:10,639 --> 00:07:12,319
sampling a short

229
00:07:12,319 --> 00:07:14,080
square matrix r so short meaning the

230
00:07:14,080 --> 00:07:16,240
entries are small right multiplying that

231
00:07:16,240 --> 00:07:17,599
to a

232
00:07:17,599 --> 00:07:19,840
and computing y so by left over hash

233
00:07:19,840 --> 00:07:21,199
flammable y is going to be statistically

234
00:07:21,199 --> 00:07:23,199
random

235
00:07:23,199 --> 00:07:25,520
so the prover is going to post these uh

236
00:07:25,520 --> 00:07:27,199
these public a and y these public

237
00:07:27,199 --> 00:07:28,319
parameters

238
00:07:28,319 --> 00:07:30,160
and to identify itself to someone else

239
00:07:30,160 --> 00:07:31,199
it's going to prove that it actually

240
00:07:31,199 --> 00:07:33,120
knows r alright so the proverb should be

241
00:07:33,120 --> 00:07:34,560
the only person who's able to convince

242
00:07:34,560 --> 00:07:36,160
somebody because they're the only person

243
00:07:36,160 --> 00:07:39,039
who generated y and you are

244
00:07:39,039 --> 00:07:41,199
so how does approver do this first it's

245
00:07:41,199 --> 00:07:43,680
going to sample a short vector t

246
00:07:43,680 --> 00:07:46,400
and left multiply this by a

247
00:07:46,400 --> 00:07:47,680
and it's going to compute this vector

248
00:07:47,680 --> 00:07:49,360
alpha and send this over essentially

249
00:07:49,360 --> 00:07:50,639
alpha is going to function as type of

250
00:07:50,639 --> 00:07:53,360
commitment to t

251
00:07:54,000 --> 00:07:56,000
next the verifier is going to sample a

252
00:07:56,000 --> 00:07:58,000
challenge vector so we want the entries

253
00:07:58,000 --> 00:07:59,599
of the challenge vector to also be short

254
00:07:59,599 --> 00:08:00,879
for simplicity i'm going to pick them to

255
00:08:00,879 --> 00:08:03,440
be random and 0 1.

256
00:08:03,440 --> 00:08:05,759
and finally the proofer's task is to

257
00:08:05,759 --> 00:08:08,479
compute t plus r times c right so it

258
00:08:08,479 --> 00:08:10,800
knows r it can multiply r by c and i can

259
00:08:10,800 --> 00:08:13,199
add t to this and essentially mask it

260
00:08:13,199 --> 00:08:16,000
and so it's going to send over the z

261
00:08:16,000 --> 00:08:17,680
and the verifier can check the z is

262
00:08:17,680 --> 00:08:19,520
computed correctly by left multiplying

263
00:08:19,520 --> 00:08:21,520
by a so in particular checks that a

264
00:08:21,520 --> 00:08:24,400
times z is equal to alpha plus y times c

265
00:08:24,400 --> 00:08:26,639
and moreover the z is short

266
00:08:26,639 --> 00:08:28,800
so you can verify that if the proofer

267
00:08:28,800 --> 00:08:30,479
indeed follows a protocol correctly then

268
00:08:30,479 --> 00:08:32,080
this check will pass that z will be

269
00:08:32,080 --> 00:08:34,640
short because t is short r is short and

270
00:08:34,640 --> 00:08:36,799
c is short and that a z equals alpha

271
00:08:36,799 --> 00:08:39,039
plus y c holds as long as the prover

272
00:08:39,039 --> 00:08:41,360
does everything correctly

273
00:08:41,360 --> 00:08:42,719
so in the fiat shamir version of this

274
00:08:42,719 --> 00:08:44,560
protocol of course

275
00:08:44,560 --> 00:08:46,240
the the prover is just going to apply

276
00:08:46,240 --> 00:08:48,080
the hash function h to alpha and it's

277
00:08:48,080 --> 00:08:50,240
going to use that in place of c

278
00:08:50,240 --> 00:08:51,920
so let me just put that up

279
00:08:51,920 --> 00:08:53,760
uh so in the non-interactive lubichevsky

280
00:08:53,760 --> 00:08:55,760
protocol it's exactly the same thing but

281
00:08:55,760 --> 00:08:57,920
now h of alpha is playing the role of c

282
00:08:57,920 --> 00:08:59,839
so it just sends over alpha and z

283
00:08:59,839 --> 00:09:01,440
because the the verifier can compute the

284
00:09:01,440 --> 00:09:04,720
middle message h of alpha for itself

285
00:09:04,720 --> 00:09:07,040
and so finally the verifier accepts same

286
00:09:07,040 --> 00:09:08,880
condition as in the interactive protocol

287
00:09:08,880 --> 00:09:10,560
if z is short and this condition is

288
00:09:10,560 --> 00:09:12,080
satisfied

289
00:09:12,080 --> 00:09:14,080
so let's think about what you want out

290
00:09:14,080 --> 00:09:16,240
of h to ensure that that this is

291
00:09:16,240 --> 00:09:18,240
actually hard right so that if somebody

292
00:09:18,240 --> 00:09:20,240
comes along and just sees a and y has no

293
00:09:20,240 --> 00:09:22,000
knowledge of what r is they shouldn't be

294
00:09:22,000 --> 00:09:24,560
able to produce this non-interactive

295
00:09:24,560 --> 00:09:27,600
proof that they know are

296
00:09:27,600 --> 00:09:30,399
so here's what we want right we want h

297
00:09:30,399 --> 00:09:32,800
such that if you see a random a and y

298
00:09:32,800 --> 00:09:34,560
it's going to be hard to find alpha and

299
00:09:34,560 --> 00:09:36,720
a short z satisfying this equation this

300
00:09:36,720 --> 00:09:38,800
this condition that uh if satisfied the

301
00:09:38,800 --> 00:09:41,600
verifier will accept

302
00:09:41,600 --> 00:09:44,000
so here is the the key idea

303
00:09:44,000 --> 00:09:45,680
everything is in this box

304
00:09:45,680 --> 00:09:48,720
so what you want to do is pick an h such

305
00:09:48,720 --> 00:09:50,800
that alpha is equal to g times h of

306
00:09:50,800 --> 00:09:52,959
alpha for some matrix g

307
00:09:52,959 --> 00:09:55,519
so in particular you want that the input

308
00:09:55,519 --> 00:09:58,160
alpha is some linear function of the

309
00:09:58,160 --> 00:10:00,240
output h of alpha so alpha is equal to

310
00:10:00,240 --> 00:10:02,839
some matrix g times the output h of

311
00:10:02,839 --> 00:10:05,120
alpha okay so

312
00:10:05,120 --> 00:10:08,000
one example of a choice of h that works

313
00:10:08,000 --> 00:10:09,360
is think about h being the big

314
00:10:09,360 --> 00:10:11,519
decomposition of the vector alpha right

315
00:10:11,519 --> 00:10:13,360
taking the vector alpha and taking every

316
00:10:13,360 --> 00:10:14,640
component and expanding out the bit

317
00:10:14,640 --> 00:10:16,320
decomposition

318
00:10:16,320 --> 00:10:18,079
now now you can pick g to be the

319
00:10:18,079 --> 00:10:19,839
so-called gadget matrix or this powers

320
00:10:19,839 --> 00:10:21,200
of two matrix

321
00:10:21,200 --> 00:10:23,120
right and now multiplying g by h of

322
00:10:23,120 --> 00:10:26,000
alpha recovers the original input alpha

323
00:10:26,000 --> 00:10:27,680
so this is the the g matrix to keep in

324
00:10:27,680 --> 00:10:29,760
mind here

325
00:10:29,760 --> 00:10:32,000
so so imagine we we've set our theater

326
00:10:32,000 --> 00:10:33,600
hash function this way h satisfies this

327
00:10:33,600 --> 00:10:35,200
property it is the big decomposition

328
00:10:35,200 --> 00:10:37,680
function and satisfies this property

329
00:10:37,680 --> 00:10:39,519
then we can plug in alpha

330
00:10:39,519 --> 00:10:41,440
and uh replace that that alpha vector

331
00:10:41,440 --> 00:10:44,000
with a g times h of alpha and now all we

332
00:10:44,000 --> 00:10:46,320
have to do is just rearrange so now

333
00:10:46,320 --> 00:10:48,079
we're going to get minus a concatenate

334
00:10:48,079 --> 00:10:49,360
with g plus y

335
00:10:49,360 --> 00:10:51,519
and this times the vector z concatenated

336
00:10:51,519 --> 00:10:53,040
with h of alpha is actually equal to the

337
00:10:53,040 --> 00:10:54,399
zero vector

338
00:10:54,399 --> 00:10:56,000
but i claim now that we're actually done

339
00:10:56,000 --> 00:10:57,600
this is all we wanted to show that

340
00:10:57,600 --> 00:11:00,079
producing this alpha in short z is now

341
00:11:00,079 --> 00:11:02,079
hard and the reason

342
00:11:02,079 --> 00:11:04,399
is that a and y are random right so for

343
00:11:04,399 --> 00:11:06,399
some fixed g uh we're going to have that

344
00:11:06,399 --> 00:11:08,560
a concatenate with g plus y is a random

345
00:11:08,560 --> 00:11:10,240
wide matrix

346
00:11:10,240 --> 00:11:12,000
and if the adversary is able to convince

347
00:11:12,000 --> 00:11:13,920
the verifier to accept then it also

348
00:11:13,920 --> 00:11:15,440
finds a short

349
00:11:15,440 --> 00:11:17,920
z concatenate with h of alpha vector

350
00:11:17,920 --> 00:11:19,360
such that this

351
00:11:19,360 --> 00:11:21,760
vector times a concatenate g plus y is a

352
00:11:21,760 --> 00:11:23,600
zero vector and if you look at it this

353
00:11:23,600 --> 00:11:25,200
is actually just a cis problem right i

354
00:11:25,200 --> 00:11:26,800
gave you a random wide matrix and you

355
00:11:26,800 --> 00:11:28,079
found me a short solution a short

356
00:11:28,079 --> 00:11:29,760
pre-image of zero

357
00:11:29,760 --> 00:11:31,839
so that's it we're done this shows that

358
00:11:31,839 --> 00:11:33,040
the non-interactive version of

359
00:11:33,040 --> 00:11:36,000
lubizhevsky is sound as long as you use

360
00:11:36,000 --> 00:11:38,160
the the bitdecomposition function as

361
00:11:38,160 --> 00:11:41,439
your theatemir hash function

362
00:11:41,680 --> 00:11:44,240
so a brief aside on lattices uh note

363
00:11:44,240 --> 00:11:46,320
here that the honest prover

364
00:11:46,320 --> 00:11:48,000
right is actually able to compute this

365
00:11:48,000 --> 00:11:50,480
this short um the short solution this is

366
00:11:50,480 --> 00:11:52,560
solution right so in particular it knows

367
00:11:52,560 --> 00:11:54,560
a short r satisfying ar equals y and it

368
00:11:54,560 --> 00:11:56,639
computes a short solution

369
00:11:56,639 --> 00:11:58,000
and this sounds familiar it's because it

370
00:11:58,000 --> 00:11:59,120
really is

371
00:11:59,120 --> 00:12:01,279
uh so one fun fact that this is we've

372
00:12:01,279 --> 00:12:03,279
just rederived lattice trapdoors right

373
00:12:03,279 --> 00:12:04,959
so the lattice trapdoors of mp's solvent

374
00:12:04,959 --> 00:12:07,920
and lw15 actually arise from applying

375
00:12:07,920 --> 00:12:09,600
fiat chamier with the bit decomposition

376
00:12:09,600 --> 00:12:11,920
function to lubichevsky so this is not

377
00:12:11,920 --> 00:12:13,839
at all how lattice trapdoors were

378
00:12:13,839 --> 00:12:15,920
derived in literature but you actually

379
00:12:15,920 --> 00:12:17,200
could have arrived at them you could

380
00:12:17,200 --> 00:12:19,040
have rediscovered them

381
00:12:19,040 --> 00:12:20,800
by trying to do fiat chamier with a

382
00:12:20,800 --> 00:12:22,399
simple information theoretic hash

383
00:12:22,399 --> 00:12:24,000
function

384
00:12:24,000 --> 00:12:25,680
and going a little bit further

385
00:12:25,680 --> 00:12:27,680
if we want to talk all the way to talk

386
00:12:27,680 --> 00:12:29,120
about signatures

387
00:12:29,120 --> 00:12:30,160
um

388
00:12:30,160 --> 00:12:31,600
there's essentially two seemingly

389
00:12:31,600 --> 00:12:32,959
unrelated approaches to lattice

390
00:12:32,959 --> 00:12:35,360
signatures and one is this gpv based

391
00:12:35,360 --> 00:12:36,880
approach where

392
00:12:36,880 --> 00:12:39,360
this pre-image samplable

393
00:12:39,360 --> 00:12:40,480
functions approach to computing

394
00:12:40,480 --> 00:12:42,399
signatures and the other is the fiat

395
00:12:42,399 --> 00:12:44,240
chamier based approach by applying fiat

396
00:12:44,240 --> 00:12:46,160
mirror to lubricate

397
00:12:46,160 --> 00:12:48,079
and we show that essentially these two

398
00:12:48,079 --> 00:12:51,200
uh previously unrelated protocols are

399
00:12:51,200 --> 00:12:52,560
unrelated ways to getting last base

400
00:12:52,560 --> 00:12:54,880
signatures are actually equivalent if

401
00:12:54,880 --> 00:12:56,880
you instantiate the fiat chimera with a

402
00:12:56,880 --> 00:12:58,720
particular bit decomposition based hash

403
00:12:58,720 --> 00:13:00,560
function and then apply hash and sign

404
00:13:00,560 --> 00:13:02,560
with the random oracle

405
00:13:02,560 --> 00:13:04,480
so thinking about fiat mirror's simple

406
00:13:04,480 --> 00:13:06,320
hash functions allowed us to find the

407
00:13:06,320 --> 00:13:08,320
simple connection between two

408
00:13:08,320 --> 00:13:09,600
between the two ways we know for

409
00:13:09,600 --> 00:13:11,040
constructing lattice signatures which i

410
00:13:11,040 --> 00:13:14,000
think is a fun fact

411
00:13:14,639 --> 00:13:16,240
all right so that was a taste of the

412
00:13:16,240 --> 00:13:18,399
positive results i encourage you to look

413
00:13:18,399 --> 00:13:20,160
at the paper for a lot more on positive

414
00:13:20,160 --> 00:13:21,839
results in particular all of our

415
00:13:21,839 --> 00:13:23,440
group-based results are

416
00:13:23,440 --> 00:13:25,360
deferred to the paper

417
00:13:25,360 --> 00:13:26,320
um

418
00:13:26,320 --> 00:13:27,519
i want to move on to the negative

419
00:13:27,519 --> 00:13:29,200
results and in particular so i want to

420
00:13:29,200 --> 00:13:30,720
talk about why some protocols are going

421
00:13:30,720 --> 00:13:33,040
to require a cryptographic the engineer

422
00:13:33,040 --> 00:13:36,160
hash function exactly what that means

423
00:13:36,160 --> 00:13:37,120
so

424
00:13:37,120 --> 00:13:38,480
i'm going to put up a generic sigma

425
00:13:38,480 --> 00:13:41,199
protocol pi so in a generic protocol

426
00:13:41,199 --> 00:13:43,040
generic segment protocol the prover

427
00:13:43,040 --> 00:13:45,040
first sends a commitment alpha gets a

428
00:13:45,040 --> 00:13:46,560
response beta

429
00:13:46,560 --> 00:13:47,839
gets a challenge beta and sends a

430
00:13:47,839 --> 00:13:49,199
response gamma

431
00:13:49,199 --> 00:13:50,720
and in all of our positive results that

432
00:13:50,720 --> 00:13:51,920
i mentioned before

433
00:13:51,920 --> 00:13:54,399
um this challenge beta is sampled from

434
00:13:54,399 --> 00:13:56,639
some challenge space r that's really

435
00:13:56,639 --> 00:13:58,880
large right in the lubricate example for

436
00:13:58,880 --> 00:14:01,120
instance beta is a random bit vector so

437
00:14:01,120 --> 00:14:02,800
there's exponentially many choices for

438
00:14:02,800 --> 00:14:05,440
for the challenge

439
00:14:05,440 --> 00:14:07,040
but many important protocols for

440
00:14:07,040 --> 00:14:09,839
instance gmr blom gmw

441
00:14:09,839 --> 00:14:11,440
this the challenge space size is

442
00:14:11,440 --> 00:14:13,360
actually small it could be two could be

443
00:14:13,360 --> 00:14:14,399
poly

444
00:14:14,399 --> 00:14:15,680
and sound this actually requires

445
00:14:15,680 --> 00:14:18,079
parallel repetition right you send many

446
00:14:18,079 --> 00:14:20,800
commitments alpha one alpha t uh you get

447
00:14:20,800 --> 00:14:22,160
a lot of challenges you send a lot of

448
00:14:22,160 --> 00:14:24,000
responses over and so that's actually

449
00:14:24,000 --> 00:14:25,279
the protocol that you want to apply the

450
00:14:25,279 --> 00:14:26,959
engineer to right you want negligible

451
00:14:26,959 --> 00:14:28,800
soundness so you first parallel repeat

452
00:14:28,800 --> 00:14:30,320
the interactive protocol and then you

453
00:14:30,320 --> 00:14:33,199
apply fiat mirror to that

454
00:14:33,199 --> 00:14:34,800
so the bad news here is that our

455
00:14:34,800 --> 00:14:36,800
positive theoretical results do do not

456
00:14:36,800 --> 00:14:38,480
apply to these protocols so in

457
00:14:38,480 --> 00:14:40,160
particular you can't really hope to have

458
00:14:40,160 --> 00:14:41,440
such a simple

459
00:14:41,440 --> 00:14:42,959
fiat chamber compiler like we did in the

460
00:14:42,959 --> 00:14:44,959
previous part of this talk for protocols

461
00:14:44,959 --> 00:14:46,000
such as

462
00:14:46,000 --> 00:14:48,959
gmr and blum

463
00:14:49,040 --> 00:14:50,800
so here's our theorem we show that for

464
00:14:50,800 --> 00:14:53,199
many common segment protocols pi

465
00:14:53,199 --> 00:14:55,040
in particular ones that satisfy these

466
00:14:55,040 --> 00:14:57,519
three properties first off that beta is

467
00:14:57,519 --> 00:14:59,040
sampled from some polynomial size

468
00:14:59,040 --> 00:15:00,240
challenge space

469
00:15:00,240 --> 00:15:02,240
the first message alpha is going to be

470
00:15:02,240 --> 00:15:03,519
pseudorandom

471
00:15:03,519 --> 00:15:04,880
and wherever we have honest verifier

472
00:15:04,880 --> 00:15:06,240
zero knowledge which is a standard

473
00:15:06,240 --> 00:15:08,320
property of sigma protocols

474
00:15:08,320 --> 00:15:10,000
so if you have your protocol satisfying

475
00:15:10,000 --> 00:15:11,519
all these three properties which are

476
00:15:11,519 --> 00:15:12,880
satisfied by most of the classic

477
00:15:12,880 --> 00:15:14,639
protocols in the literature

478
00:15:14,639 --> 00:15:16,399
then the theomere hash function h that

479
00:15:16,399 --> 00:15:18,320
compiles the t wise parallel repetition

480
00:15:18,320 --> 00:15:21,440
of the protocol must be cryptographic

481
00:15:21,440 --> 00:15:22,720
so this deserves a little bit more

482
00:15:22,720 --> 00:15:24,800
explanation but what does it mean for h

483
00:15:24,800 --> 00:15:26,560
to be cryptographic

484
00:15:26,560 --> 00:15:28,000
well informally

485
00:15:28,000 --> 00:15:29,759
what i mean is that you can use the hash

486
00:15:29,759 --> 00:15:31,680
function h to define a challenge or

487
00:15:31,680 --> 00:15:33,519
adversary game with a computational

488
00:15:33,519 --> 00:15:36,000
statistical gap

489
00:15:36,000 --> 00:15:37,040
alright

490
00:15:37,040 --> 00:15:39,120
so here's the proof idea

491
00:15:39,120 --> 00:15:41,120
for any hash function h we're going to

492
00:15:41,120 --> 00:15:42,480
define something called the mix and

493
00:15:42,480 --> 00:15:43,759
match game

494
00:15:43,759 --> 00:15:45,279
and to ensure that there's actually a

495
00:15:45,279 --> 00:15:46,639
computational statistical gap we're

496
00:15:46,639 --> 00:15:48,480
going to show that any

497
00:15:48,480 --> 00:15:50,240
that an inefficient adversary can almost

498
00:15:50,240 --> 00:15:53,199
always win this game

499
00:15:53,360 --> 00:15:55,360
then we show that if an efficient

500
00:15:55,360 --> 00:15:57,920
adversary can win the mix and match game

501
00:15:57,920 --> 00:15:59,600
then it can break the the fiat and

502
00:15:59,600 --> 00:16:00,800
mirrored compiled version of this

503
00:16:00,800 --> 00:16:03,279
protocol

504
00:16:03,680 --> 00:16:05,519
so what exactly is this mix and match

505
00:16:05,519 --> 00:16:08,320
game for the hash function h so what

506
00:16:08,320 --> 00:16:10,320
we're going to do is have a challenger

507
00:16:10,320 --> 00:16:11,759
it's going to sample a whole bunch of

508
00:16:11,759 --> 00:16:14,480
alpha i j beta ijs

509
00:16:14,480 --> 00:16:16,320
basically in a grid so we're going to

510
00:16:16,320 --> 00:16:18,720
have you know t columns where t this t

511
00:16:18,720 --> 00:16:20,639
here corresponds to the t the number of

512
00:16:20,639 --> 00:16:22,800
parallel repetitions we have and k is

513
00:16:22,800 --> 00:16:23,920
going to be some number of rows that

514
00:16:23,920 --> 00:16:25,920
we'll set in the bit

515
00:16:25,920 --> 00:16:28,320
so we sample an alpha i j beta ij pair

516
00:16:28,320 --> 00:16:30,959
and put it in each cell

517
00:16:30,959 --> 00:16:33,040
and now your the adversary is given this

518
00:16:33,040 --> 00:16:35,360
table of these randomly chosen alpha ij

519
00:16:35,360 --> 00:16:38,160
beta ajs and the adversary is challenged

520
00:16:38,160 --> 00:16:41,600
to find one cell in each column

521
00:16:41,600 --> 00:16:43,440
such that if you apply the theatemir

522
00:16:43,440 --> 00:16:46,320
hash function h to all the alpha ijs in

523
00:16:46,320 --> 00:16:48,399
those cells then it spits out all the

524
00:16:48,399 --> 00:16:50,639
beta ijs in those cells

525
00:16:50,639 --> 00:16:52,560
right so in particular like if the the

526
00:16:52,560 --> 00:16:54,480
adversary could win if it finds say

527
00:16:54,480 --> 00:16:57,519
these green cells here if uh h applied

528
00:16:57,519 --> 00:16:59,440
to all these alphas concatenate together

529
00:16:59,440 --> 00:17:01,040
gives all those betas concatenated

530
00:17:01,040 --> 00:17:04,040
together

531
00:17:04,480 --> 00:17:06,319
and so we show that as long as the

532
00:17:06,319 --> 00:17:08,400
number of rows is asymptotically larger

533
00:17:08,400 --> 00:17:09,839
than the number of columns then there

534
00:17:09,839 --> 00:17:12,559
exists a solution to this game uh with

535
00:17:12,559 --> 00:17:14,319
overwhelming probability and this this

536
00:17:14,319 --> 00:17:16,319
could be this this is true for any hash

537
00:17:16,319 --> 00:17:17,439
function h that's what's interesting

538
00:17:17,439 --> 00:17:20,079
about this lemma

539
00:17:21,359 --> 00:17:23,039
all right so what remains to show is

540
00:17:23,039 --> 00:17:24,480
that if you have an efficient attacker

541
00:17:24,480 --> 00:17:25,919
for this mix and match game for a hash

542
00:17:25,919 --> 00:17:28,400
function h then you can break soundness

543
00:17:28,400 --> 00:17:31,760
of the fiatumir protocol

544
00:17:31,760 --> 00:17:33,280
so here's how the attack works it's very

545
00:17:33,280 --> 00:17:34,160
simple

546
00:17:34,160 --> 00:17:35,679
so first what we're going to do is run

547
00:17:35,679 --> 00:17:37,200
the honest verifier zero knowledge

548
00:17:37,200 --> 00:17:39,760
simulator uh for the sigma protocol

549
00:17:39,760 --> 00:17:41,039
we're gonna do this every single for

550
00:17:41,039 --> 00:17:43,200
every single cell of the mix and match

551
00:17:43,200 --> 00:17:44,320
game

552
00:17:44,320 --> 00:17:46,640
so we're gonna build up this whole grid

553
00:17:46,640 --> 00:17:48,400
and we're only going to place the alpha

554
00:17:48,400 --> 00:17:50,080
ij beta ij part of the accepting

555
00:17:50,080 --> 00:17:51,600
transcript in each cell right we're

556
00:17:51,600 --> 00:17:52,880
going to hide the gamma ids we're not

557
00:17:52,880 --> 00:17:54,080
going to give that to our mix and match

558
00:17:54,080 --> 00:17:55,520
attacker

559
00:17:55,520 --> 00:17:57,520
so we come up with this whole grid and

560
00:17:57,520 --> 00:17:58,640
we're going to run the mix and match

561
00:17:58,640 --> 00:18:00,480
attacker on this grid of inputs see all

562
00:18:00,480 --> 00:18:02,480
these alpha ij beta ijs and that

563
00:18:02,480 --> 00:18:04,880
attacker is going to tell us which uh

564
00:18:04,880 --> 00:18:07,760
which cell each column to use

565
00:18:07,760 --> 00:18:09,039
and just by the design of the mix and

566
00:18:09,039 --> 00:18:11,280
match game if the mix and match attacker

567
00:18:11,280 --> 00:18:12,960
is correct then we're actually fine

568
00:18:12,960 --> 00:18:14,799
we're we're happy and we can break the

569
00:18:14,799 --> 00:18:16,240
we we can break the fiat mirrored

570
00:18:16,240 --> 00:18:17,280
protocol

571
00:18:17,280 --> 00:18:19,600
right in particular uh by the guarantee

572
00:18:19,600 --> 00:18:22,400
of the of the mix and match attacker

573
00:18:22,400 --> 00:18:25,200
if it wins then h applied to all these

574
00:18:25,200 --> 00:18:26,480
alphas will give us all the

575
00:18:26,480 --> 00:18:28,559
corresponding betas and therefore for

576
00:18:28,559 --> 00:18:30,320
those betas we actually have the correct

577
00:18:30,320 --> 00:18:32,400
final message gamma ij

578
00:18:32,400 --> 00:18:34,400
that would make the make the verifier

579
00:18:34,400 --> 00:18:36,000
accept

580
00:18:36,000 --> 00:18:37,440
and so why does this work why does this

581
00:18:37,440 --> 00:18:38,960
attack actually succeed

582
00:18:38,960 --> 00:18:40,640
well the mix and match attacker is

583
00:18:40,640 --> 00:18:42,240
actually expecting to see a randomly

584
00:18:42,240 --> 00:18:44,240
generated um

585
00:18:44,240 --> 00:18:46,080
randomly generated grid of alpha j and

586
00:18:46,080 --> 00:18:48,080
beta ijs that's not quite what we have

587
00:18:48,080 --> 00:18:50,000
here but we are relying on the fact that

588
00:18:50,000 --> 00:18:51,520
the first message of the sigma protocol

589
00:18:51,520 --> 00:18:53,600
looks pseudorandom and moreover that we

590
00:18:53,600 --> 00:18:55,039
have an honest verifier's ear knowledge

591
00:18:55,039 --> 00:18:57,039
simulator so that the distribution of

592
00:18:57,039 --> 00:18:59,600
this of the um simulated transcripts

593
00:18:59,600 --> 00:19:03,120
looks just like uh the real distribution

594
00:19:03,120 --> 00:19:05,840
so from the from the perspective of the

595
00:19:05,840 --> 00:19:07,600
mix and match attacker it sees

596
00:19:07,600 --> 00:19:10,400
essentially or computationally random a

597
00:19:10,400 --> 00:19:12,160
random grid and so if it exceeds in the

598
00:19:12,160 --> 00:19:13,840
mid to match game it will succeed on

599
00:19:13,840 --> 00:19:15,679
this pseudo-random grid

600
00:19:15,679 --> 00:19:17,440
and then if the attacker succeeds as it

601
00:19:17,440 --> 00:19:20,240
is explained then uh then we're able to

602
00:19:20,240 --> 00:19:22,000
uh break the edge mirror we're able to

603
00:19:22,000 --> 00:19:25,840
break the the estimated protocol

604
00:19:25,919 --> 00:19:27,679
all right so in summary the answer to

605
00:19:27,679 --> 00:19:29,280
our title question is basically

606
00:19:29,280 --> 00:19:31,039
sometimes right does vs may require a

607
00:19:31,039 --> 00:19:32,880
cryptographic hash function but for some

608
00:19:32,880 --> 00:19:34,160
protocols

609
00:19:34,160 --> 00:19:36,000
it doesn't and for some protocols it

610
00:19:36,000 --> 00:19:37,200
does

611
00:19:37,200 --> 00:19:39,200
so i encourage you to look at the paper

612
00:19:39,200 --> 00:19:41,360
for a larger collection of results this

613
00:19:41,360 --> 00:19:43,360
is only a small taste of what we do in

614
00:19:43,360 --> 00:19:44,880
the whole paper

615
00:19:44,880 --> 00:19:47,120
thanks so much for your attention

616
00:19:47,120 --> 00:19:49,520
take care

