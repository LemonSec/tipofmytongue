1
00:00:01,199 --> 00:00:02,560
hello

2
00:00:02,560 --> 00:00:05,200
this will be a talk about secret sharing

3
00:00:05,200 --> 00:00:07,279
we're going to cover some basic concepts

4
00:00:07,279 --> 00:00:09,519
in the field and we're going to see the

5
00:00:09,519 --> 00:00:11,599
best secret change scheme to date with

6
00:00:11,599 --> 00:00:14,480
complexity of three halves to the end

7
00:00:14,480 --> 00:00:15,839
and this is a joint work with danny

8
00:00:15,839 --> 00:00:19,279
applebaum from the tel aviv university

9
00:00:19,279 --> 00:00:21,760
so to begin with let's introduce the

10
00:00:21,760 --> 00:00:24,640
concept what is a secret sharing scheme

11
00:00:24,640 --> 00:00:26,880
so we have a randomized dealer which

12
00:00:26,880 --> 00:00:29,199
holds some secret s

13
00:00:29,199 --> 00:00:31,840
and it wants to share it with n parties

14
00:00:31,840 --> 00:00:33,840
and it does so in the following way it

15
00:00:33,840 --> 00:00:36,640
sends one message to each party here in

16
00:00:36,640 --> 00:00:39,280
the example we have six parties

17
00:00:39,280 --> 00:00:41,200
and we want that every authorized

18
00:00:41,200 --> 00:00:43,440
coalition will be able to recover the

19
00:00:43,440 --> 00:00:45,520
secrets the dealer had

20
00:00:45,520 --> 00:00:48,320
from the messages it received

21
00:00:48,320 --> 00:00:51,039
and we want that any unauthorized

22
00:00:51,039 --> 00:00:53,360
coalition will learn nothing about the

23
00:00:53,360 --> 00:00:57,039
secret from the messages it received

24
00:00:57,120 --> 00:00:59,440
so we will call the list of all

25
00:00:59,440 --> 00:01:01,440
authorized coalition

26
00:01:01,440 --> 00:01:04,479
the access structure we deal with

27
00:01:04,479 --> 00:01:06,240
and throughout the talk we will think of

28
00:01:06,240 --> 00:01:09,680
access structures as boolean functions

29
00:01:09,680 --> 00:01:11,840
where every authorized set is assigned

30
00:01:11,840 --> 00:01:14,560
one by the function and every authorized

31
00:01:14,560 --> 00:01:17,520
set is assigned zero by the function

32
00:01:17,520 --> 00:01:19,920
and we notice that these functions will

33
00:01:19,920 --> 00:01:22,000
always be monotone

34
00:01:22,000 --> 00:01:23,920
and that is because if

35
00:01:23,920 --> 00:01:26,720
some set here it's the set of parties

36
00:01:26,720 --> 00:01:29,600
one two and three is authorized

37
00:01:29,600 --> 00:01:32,240
then if we add parties to it it will

38
00:01:32,240 --> 00:01:34,320
only it will remain authorized because

39
00:01:34,320 --> 00:01:37,360
it only has more information

40
00:01:37,360 --> 00:01:40,320
and in this sense we will think of every

41
00:01:40,320 --> 00:01:42,240
access structure or function as the list

42
00:01:42,240 --> 00:01:46,320
of all of its minimal authorized sets

43
00:01:46,320 --> 00:01:49,280
and another side to monotonicity

44
00:01:49,280 --> 00:01:52,079
is that of unauthorized sets where if a

45
00:01:52,079 --> 00:01:54,000
set is unauthorized and all of its

46
00:01:54,000 --> 00:01:56,960
subsets are obviously also unauthorized

47
00:01:56,960 --> 00:01:59,920
since they have less information

48
00:01:59,920 --> 00:02:03,520
and in this perspective

49
00:02:03,520 --> 00:02:05,680
we will think of an access structure as

50
00:02:05,680 --> 00:02:07,920
the list of all of the maximal

51
00:02:07,920 --> 00:02:11,200
unauthorized sets

52
00:02:13,440 --> 00:02:14,480
so

53
00:02:14,480 --> 00:02:17,760
moving on after these preliminaries

54
00:02:17,760 --> 00:02:20,160
the most known and studied access

55
00:02:20,160 --> 00:02:23,280
structure is the threshold one

56
00:02:23,280 --> 00:02:26,080
so with tl of n threshold function or

57
00:02:26,080 --> 00:02:27,680
access structure

58
00:02:27,680 --> 00:02:29,120
is that where

59
00:02:29,120 --> 00:02:32,560
every subset of the parties of size t is

60
00:02:32,560 --> 00:02:33,760
authorized

61
00:02:33,760 --> 00:02:36,400
and all sets of size t minus one are

62
00:02:36,400 --> 00:02:39,200
unauthorized

63
00:02:39,599 --> 00:02:40,720
so

64
00:02:40,720 --> 00:02:42,800
these uh threshold access structures

65
00:02:42,800 --> 00:02:44,400
were introduced by shamir and blakely in

66
00:02:44,400 --> 00:02:46,080
1979

67
00:02:46,080 --> 00:02:48,840
and since then they had this interesting

68
00:02:48,840 --> 00:02:52,000
property where the sizes of the shares

69
00:02:52,000 --> 00:02:53,680
was relatively small it was only

70
00:02:53,680 --> 00:02:57,599
logarithmic in the number of parties

71
00:02:57,599 --> 00:03:00,640
and it is a big open problem and this is

72
00:03:00,640 --> 00:03:03,840
the problem we are trying to solve here

73
00:03:03,840 --> 00:03:06,959
to know what is the worst case share

74
00:03:06,959 --> 00:03:08,319
size for

75
00:03:08,319 --> 00:03:10,959
any access structure how much storage is

76
00:03:10,959 --> 00:03:13,360
required by the parties

77
00:03:13,360 --> 00:03:15,920
in any such protocol for

78
00:03:15,920 --> 00:03:19,559
any access structure

79
00:03:20,000 --> 00:03:22,000
so this problem was first considered by

80
00:03:22,000 --> 00:03:24,720
ito ital in 1987

81
00:03:24,720 --> 00:03:26,239
where they shown how to build a sql

82
00:03:26,239 --> 00:03:28,319
chain scheme for every access structure

83
00:03:28,319 --> 00:03:31,040
with share sizes 2 to the n

84
00:03:31,040 --> 00:03:32,640
and it took over 30 years to improve

85
00:03:32,640 --> 00:03:34,000
this result

86
00:03:34,000 --> 00:03:36,000
it was a great barrier it was only

87
00:03:36,000 --> 00:03:38,799
broken by liu and vaikuntanatan

88
00:03:38,799 --> 00:03:40,319
three years ago

89
00:03:40,319 --> 00:03:42,000
when they showed how to reduce this

90
00:03:42,000 --> 00:03:44,159
exponent by just a little bit

91
00:03:44,159 --> 00:03:45,920
but this showed that probably much more

92
00:03:45,920 --> 00:03:47,200
is possible

93
00:03:47,200 --> 00:03:49,200
and it inspired the following line of

94
00:03:49,200 --> 00:03:50,239
work

95
00:03:50,239 --> 00:03:53,280
by applebaum by mel faras myself and

96
00:03:53,280 --> 00:03:55,680
peter this work included

97
00:03:55,680 --> 00:03:58,840
where we reduce the exponent down to

98
00:03:58,840 --> 00:04:02,239
0.585 and as in many information

99
00:04:02,239 --> 00:04:04,959
theoretic protocols there is a huge gap

100
00:04:04,959 --> 00:04:06,480
between the upper bound and the lower

101
00:04:06,480 --> 00:04:07,760
bound

102
00:04:07,760 --> 00:04:09,599
and we don't know where the truth lies

103
00:04:09,599 --> 00:04:10,799
it could be that

104
00:04:10,799 --> 00:04:12,799
some access structures require

105
00:04:12,799 --> 00:04:15,439
exponential share size and it also could

106
00:04:15,439 --> 00:04:17,600
be that secret sharing is a polynomial

107
00:04:17,600 --> 00:04:20,000
protocol

108
00:04:20,000 --> 00:04:22,960
but in fact there is a family of secret

109
00:04:22,960 --> 00:04:25,520
sharing schemes where this gap is much

110
00:04:25,520 --> 00:04:26,720
smaller

111
00:04:26,720 --> 00:04:28,800
and it is a very important family of

112
00:04:28,800 --> 00:04:31,120
linear secret sharing schemes

113
00:04:31,120 --> 00:04:32,240
where

114
00:04:32,240 --> 00:04:34,080
every share has to be a linear

115
00:04:34,080 --> 00:04:36,639
combination of the secret and the random

116
00:04:36,639 --> 00:04:38,320
elements

117
00:04:38,320 --> 00:04:39,600
and for

118
00:04:39,600 --> 00:04:41,840
linear

119
00:04:41,840 --> 00:04:44,320
there is a much higher lower bound also

120
00:04:44,320 --> 00:04:46,880
exponential so the gap is

121
00:04:46,880 --> 00:04:48,800
only between the the constants in the

122
00:04:48,800 --> 00:04:50,400
exponents

123
00:04:50,400 --> 00:04:53,360
and we also improve the

124
00:04:53,360 --> 00:04:56,160
state-of-the-art exponent by but only by

125
00:04:56,160 --> 00:04:57,360
a little bit

126
00:04:57,360 --> 00:04:59,120
and the techniques that we use are

127
00:04:59,120 --> 00:05:01,360
perhaps more interesting here than the

128
00:05:01,360 --> 00:05:03,840
improvement itself

129
00:05:03,840 --> 00:05:06,320
so this is the universe of a

130
00:05:06,320 --> 00:05:07,840
secret chunk for general access

131
00:05:07,840 --> 00:05:09,039
structures

132
00:05:09,039 --> 00:05:10,800
and in the rest of the talk we'll

133
00:05:10,800 --> 00:05:13,759
present how we get to the upper bounds

134
00:05:13,759 --> 00:05:16,800
we'll focus more on the first one

135
00:05:16,800 --> 00:05:19,520
a brief on other interesting results but

136
00:05:19,520 --> 00:05:20,880
first we'll have to do a bit of

137
00:05:20,880 --> 00:05:22,400
preliminaries

138
00:05:22,400 --> 00:05:24,080
and how to do secret sharing via

139
00:05:24,080 --> 00:05:25,520
formulas

140
00:05:25,520 --> 00:05:27,680
how lou and vai contanata did their

141
00:05:27,680 --> 00:05:29,280
secret sharing scheme

142
00:05:29,280 --> 00:05:30,800
and we'll also talk about slice

143
00:05:30,800 --> 00:05:33,520
functions which are in the title of

144
00:05:33,520 --> 00:05:36,639
the paper and the talk

145
00:05:37,039 --> 00:05:38,639
so we start this secret sharing via

146
00:05:38,639 --> 00:05:40,240
formulas

147
00:05:40,240 --> 00:05:42,800
and secretary has very useful closure

148
00:05:42,800 --> 00:05:45,759
properties the first is for or gates and

149
00:05:45,759 --> 00:05:47,600
it means that if we know how to deal a

150
00:05:47,600 --> 00:05:49,919
secret according to two functions f1 and

151
00:05:49,919 --> 00:05:50,960
f2

152
00:05:50,960 --> 00:05:52,720
then it will be easy for us to deal with

153
00:05:52,720 --> 00:05:54,720
circuit according to f which is the or

154
00:05:54,720 --> 00:05:56,639
of both functions

155
00:05:56,639 --> 00:05:59,199
and we do that as follows say we want to

156
00:05:59,199 --> 00:06:01,199
deal with the secret s

157
00:06:01,199 --> 00:06:04,400
then we did it twice independently once

158
00:06:04,400 --> 00:06:08,000
according to f1 and once according to f2

159
00:06:08,000 --> 00:06:10,080
and then if a set of parties is

160
00:06:10,080 --> 00:06:13,120
authorized by f1 or by f2

161
00:06:13,120 --> 00:06:15,120
it will be able to recover the secret

162
00:06:15,120 --> 00:06:16,960
which is exactly the behavior that we

163
00:06:16,960 --> 00:06:18,800
want

164
00:06:18,800 --> 00:06:20,639
and the second closure property is over

165
00:06:20,639 --> 00:06:22,960
n gates which is quite similar and in

166
00:06:22,960 --> 00:06:26,240
this case if we say the secret is of

167
00:06:26,240 --> 00:06:27,759
one bit

168
00:06:27,759 --> 00:06:29,360
then we will deal

169
00:06:29,360 --> 00:06:32,479
the a random element a random bit as the

170
00:06:32,479 --> 00:06:34,960
secret according to f1

171
00:06:34,960 --> 00:06:36,319
and the same

172
00:06:36,319 --> 00:06:38,800
random bit rx or s

173
00:06:38,800 --> 00:06:41,199
as the secret for f2

174
00:06:41,199 --> 00:06:44,639
then if a set is authorized by f1 and

175
00:06:44,639 --> 00:06:46,400
also by f2

176
00:06:46,400 --> 00:06:48,639
only then it will be able to recover the

177
00:06:48,639 --> 00:06:50,720
secret s

178
00:06:50,720 --> 00:06:51,680
so

179
00:06:51,680 --> 00:06:54,319
in both cases we can see that the share

180
00:06:54,319 --> 00:06:56,720
size of f equals the sum of

181
00:06:56,720 --> 00:06:58,240
share sizes for

182
00:06:58,240 --> 00:07:00,639
f1 and f2

183
00:07:00,639 --> 00:07:03,360
because we build a secret twice

184
00:07:03,360 --> 00:07:06,000
and we can do more complex decomposition

185
00:07:06,000 --> 00:07:08,319
decompositions like that for any

186
00:07:08,319 --> 00:07:11,039
function f to many functions

187
00:07:11,039 --> 00:07:13,120
and this is an idea that goes through

188
00:07:13,120 --> 00:07:15,199
many of the known secret sharing schemes

189
00:07:15,199 --> 00:07:18,160
today and also in the scheme of lv which

190
00:07:18,160 --> 00:07:20,800
we will now talk about

191
00:07:20,800 --> 00:07:21,759
and

192
00:07:21,759 --> 00:07:25,440
their scheme was based on two main ideas

193
00:07:25,440 --> 00:07:27,360
the first one was a very efficient

194
00:07:27,360 --> 00:07:28,880
secret chinese scheme for slice

195
00:07:28,880 --> 00:07:30,880
functions which we'll define in the next

196
00:07:30,880 --> 00:07:31,840
slide

197
00:07:31,840 --> 00:07:34,400
we had sub-exponential share size for

198
00:07:34,400 --> 00:07:36,560
any such size function

199
00:07:36,560 --> 00:07:37,440
and then

200
00:07:37,440 --> 00:07:39,599
they built a formula

201
00:07:39,599 --> 00:07:41,840
they built a formula of size less than 2

202
00:07:41,840 --> 00:07:43,520
to the n

203
00:07:43,520 --> 00:07:46,000
where the leaves were represented by

204
00:07:46,000 --> 00:07:48,720
these slice functions we had which had

205
00:07:48,720 --> 00:07:51,039
efficient implementation

206
00:07:51,039 --> 00:07:53,919
of secret sharing

207
00:07:54,400 --> 00:07:56,479
so we're presenting this because we'll

208
00:07:56,479 --> 00:07:57,759
soon

209
00:07:57,759 --> 00:08:00,560
do similar tricks with other kinds of

210
00:08:00,560 --> 00:08:01,919
functions

211
00:08:01,919 --> 00:08:03,840
but first we'll define these slice

212
00:08:03,840 --> 00:08:06,400
functions

213
00:08:06,400 --> 00:08:08,479
probably many of you have heard of them

214
00:08:08,479 --> 00:08:10,800
before but the k slice function is one

215
00:08:10,800 --> 00:08:14,639
which outputs one for every input of

216
00:08:14,639 --> 00:08:16,720
size larger than k

217
00:08:16,720 --> 00:08:18,400
zero for every input of size smaller

218
00:08:18,400 --> 00:08:20,879
than k and it is unrestricted

219
00:08:20,879 --> 00:08:23,840
for inputs of size k

220
00:08:23,840 --> 00:08:26,400
and we represent slice functions by

221
00:08:26,400 --> 00:08:28,479
these this rhombus on the right and

222
00:08:28,479 --> 00:08:30,319
generally represent

223
00:08:30,319 --> 00:08:32,559
graphically like this functions from now

224
00:08:32,559 --> 00:08:33,519
on

225
00:08:33,519 --> 00:08:34,240
and

226
00:08:34,240 --> 00:08:37,360
every vertical layer here represents

227
00:08:37,360 --> 00:08:39,440
sets of certain size

228
00:08:39,440 --> 00:08:42,159
and if that layer is green it means that

229
00:08:42,159 --> 00:08:44,480
they received one and

230
00:08:44,480 --> 00:08:46,800
if it is reddit they receive the

231
00:08:46,800 --> 00:08:51,040
zero from the relevant function

232
00:08:51,279 --> 00:08:53,360
so now we're finally getting to some new

233
00:08:53,360 --> 00:08:54,480
ideas

234
00:08:54,480 --> 00:08:56,880
and we saw that the formula by lv even

235
00:08:56,880 --> 00:08:59,920
though the constant in the exponents

236
00:08:59,920 --> 00:09:02,320
representing the size of the formula

237
00:09:02,320 --> 00:09:05,200
it's amazing that it's below 1

238
00:09:05,200 --> 00:09:07,120
but it's still quite high

239
00:09:07,120 --> 00:09:09,839
so we offer a different approach

240
00:09:09,839 --> 00:09:11,760
where we define functions that are

241
00:09:11,760 --> 00:09:14,160
similar to slices with some important

242
00:09:14,160 --> 00:09:15,839
variations

243
00:09:15,839 --> 00:09:18,080
and these functions will be much harder

244
00:09:18,080 --> 00:09:20,160
to implement in secret sharing their

245
00:09:20,160 --> 00:09:22,720
share size will not be sub-exponential

246
00:09:22,720 --> 00:09:25,600
and it will be the highest exponent for

247
00:09:25,600 --> 00:09:27,600
any such slice would be three halves to

248
00:09:27,600 --> 00:09:28,800
the n

249
00:09:28,800 --> 00:09:31,200
but it will be very very easy to compose

250
00:09:31,200 --> 00:09:33,279
these special slices actually the cells

251
00:09:33,279 --> 00:09:34,959
of the formula will be

252
00:09:34,959 --> 00:09:37,040
linear in n

253
00:09:37,040 --> 00:09:40,080
and then what are these special slices

254
00:09:40,080 --> 00:09:41,600
actually it's a

255
00:09:41,600 --> 00:09:43,279
maybe a simple

256
00:09:43,279 --> 00:09:45,120
definition than expected they're

257
00:09:45,120 --> 00:09:48,839
actually for up slices they are monotone

258
00:09:48,839 --> 00:09:51,120
kbnfs which means that they are

259
00:09:51,120 --> 00:09:53,279
functions where all of the min terms of

260
00:09:53,279 --> 00:09:57,680
rs are of specific size k

261
00:09:57,760 --> 00:10:00,640
and this is the formal definition if we

262
00:10:00,640 --> 00:10:03,040
take a function f

263
00:10:03,040 --> 00:10:05,760
then it's k up slice

264
00:10:05,760 --> 00:10:09,200
is simply a function which has the min

265
00:10:09,200 --> 00:10:12,880
terms of f of size exactly k

266
00:10:12,880 --> 00:10:14,160
so

267
00:10:14,160 --> 00:10:16,640
if the inputs are sized below k

268
00:10:16,640 --> 00:10:20,000
there the output output will be zero

269
00:10:20,000 --> 00:10:21,760
for inputs of size k

270
00:10:21,760 --> 00:10:25,200
the kf slice of f equals f

271
00:10:25,200 --> 00:10:27,440
but everything above that is only

272
00:10:27,440 --> 00:10:31,440
defined by what happens in the kf layer

273
00:10:31,440 --> 00:10:35,360
so we will represent up slices with

274
00:10:35,360 --> 00:10:37,680
this shape where the two bottom parts

275
00:10:37,680 --> 00:10:39,839
are exactly like slices and the upper

276
00:10:39,839 --> 00:10:42,480
part is different

277
00:10:42,480 --> 00:10:43,360
and

278
00:10:43,360 --> 00:10:46,399
this definition is useful since

279
00:10:46,399 --> 00:10:50,240
a function f can be decomposed to its n

280
00:10:50,240 --> 00:10:51,680
up slices

281
00:10:51,680 --> 00:10:55,920
with one or gate with fan in n

282
00:10:56,480 --> 00:10:59,120
and anonymously we can define down

283
00:10:59,120 --> 00:11:03,040
slices which are monotone k c and f's or

284
00:11:03,040 --> 00:11:05,600
functions where all the max terms are of

285
00:11:05,600 --> 00:11:08,560
size exactly k

286
00:11:08,560 --> 00:11:11,440
and then again the kth downslice of a

287
00:11:11,440 --> 00:11:13,839
function f is a function which has the

288
00:11:13,839 --> 00:11:16,720
exact same max term as f

289
00:11:16,720 --> 00:11:19,760
of size k

290
00:11:20,640 --> 00:11:21,170
and then

291
00:11:21,170 --> 00:11:22,480
[Music]

292
00:11:22,480 --> 00:11:25,680
analogously to before the last two items

293
00:11:25,680 --> 00:11:28,480
will be identical to slice function

294
00:11:28,480 --> 00:11:29,360
where

295
00:11:29,360 --> 00:11:31,200
small sets

296
00:11:31,200 --> 00:11:32,959
the behavior of the function on them

297
00:11:32,959 --> 00:11:35,200
will be defined by what happens on the

298
00:11:35,200 --> 00:11:37,920
kf layer

299
00:11:38,000 --> 00:11:41,200
and here f can be decomposed to its and

300
00:11:41,200 --> 00:11:44,320
down slices with one end gate

301
00:11:44,320 --> 00:11:47,760
which has found in n

302
00:11:47,760 --> 00:11:50,399
so how do we actually do anything with

303
00:11:50,399 --> 00:11:54,079
these up slices or down slices

304
00:11:54,079 --> 00:11:56,720
so luckily for us basic schemes for up

305
00:11:56,720 --> 00:11:59,040
slices and down slices can be derived

306
00:11:59,040 --> 00:12:01,600
from the work of apple baumetal from

307
00:12:01,600 --> 00:12:03,120
last year

308
00:12:03,120 --> 00:12:03,920
and

309
00:12:03,920 --> 00:12:04,959
we get

310
00:12:04,959 --> 00:12:07,519
the following share sizes which

311
00:12:07,519 --> 00:12:10,000
can be understood maybe better by this

312
00:12:10,000 --> 00:12:12,240
graph representation

313
00:12:12,240 --> 00:12:15,279
so we'll focus on down slices

314
00:12:15,279 --> 00:12:16,320
where

315
00:12:16,320 --> 00:12:18,880
the constant in the exponent increases

316
00:12:18,880 --> 00:12:21,600
as the parameter of the slice increases

317
00:12:21,600 --> 00:12:23,839
and if we would have wanted to generate

318
00:12:23,839 --> 00:12:26,000
from this secret sharing scheme for

319
00:12:26,000 --> 00:12:27,920
every access structure

320
00:12:27,920 --> 00:12:29,600
the exponent we'll get in the end will

321
00:12:29,600 --> 00:12:30,639
be

322
00:12:30,639 --> 00:12:34,880
n exactly because these high down slices

323
00:12:34,880 --> 00:12:36,880
cost too much

324
00:12:36,880 --> 00:12:39,839
so what we do in our paper is we try to

325
00:12:39,839 --> 00:12:42,480
reduce the cost of these high down

326
00:12:42,480 --> 00:12:45,040
slices and then do a decomposition of

327
00:12:45,040 --> 00:12:49,200
all down slices for a specific function

328
00:12:49,200 --> 00:12:51,600
we use down slices because we see that

329
00:12:51,600 --> 00:12:54,079
for apps license the situation is even

330
00:12:54,079 --> 00:12:55,120
worse

331
00:12:55,120 --> 00:12:57,839
all up slices from

332
00:12:57,839 --> 00:12:59,680
half downwards

333
00:12:59,680 --> 00:13:02,880
already have an expensive n

334
00:13:02,880 --> 00:13:04,000
so

335
00:13:04,000 --> 00:13:06,720
what we'll do is reduce the

336
00:13:06,720 --> 00:13:10,240
exponent of these high down slices

337
00:13:10,240 --> 00:13:11,360
and then

338
00:13:11,360 --> 00:13:13,600
we'll realize all down slices of a

339
00:13:13,600 --> 00:13:15,200
function

340
00:13:15,200 --> 00:13:18,480
below half with the abilities we had

341
00:13:18,480 --> 00:13:20,959
from the previous paper

342
00:13:20,959 --> 00:13:23,440
and we'll do a reduction from higher

343
00:13:23,440 --> 00:13:27,760
downsizes to the half down slice

344
00:13:27,760 --> 00:13:30,639
that is the general idea of this new

345
00:13:30,639 --> 00:13:32,079
scheme

346
00:13:32,079 --> 00:13:34,399
so we will now show this

347
00:13:34,399 --> 00:13:36,959
reduction

348
00:13:38,399 --> 00:13:39,279
so

349
00:13:39,279 --> 00:13:41,920
the idea is as follows

350
00:13:41,920 --> 00:13:44,399
say we want to realize

351
00:13:44,399 --> 00:13:47,120
some high down slice

352
00:13:47,120 --> 00:13:50,000
uh we pick many functions which are half

353
00:13:50,000 --> 00:13:52,560
down slices and we pick these functions

354
00:13:52,560 --> 00:13:54,800
in a way that satisfies the following

355
00:13:54,800 --> 00:13:56,800
two conditions

356
00:13:56,800 --> 00:13:59,199
the first is that every

357
00:13:59,199 --> 00:14:02,959
half down slice that we choose is always

358
00:14:02,959 --> 00:14:05,839
larger than the original function on

359
00:14:05,839 --> 00:14:07,199
every input

360
00:14:07,199 --> 00:14:09,680
where the original function f i remind

361
00:14:09,680 --> 00:14:13,360
you is a high down size

362
00:14:13,360 --> 00:14:16,000
this means that if f of x equals one

363
00:14:16,000 --> 00:14:16,880
then

364
00:14:16,880 --> 00:14:21,120
for every t f t of x also must equal one

365
00:14:21,120 --> 00:14:23,680
but we also require that

366
00:14:23,680 --> 00:14:25,839
for every max term

367
00:14:25,839 --> 00:14:27,040
of f

368
00:14:27,040 --> 00:14:29,120
there will be some function that we

369
00:14:29,120 --> 00:14:32,160
chose that is equal to f on this max

370
00:14:32,160 --> 00:14:33,839
term

371
00:14:33,839 --> 00:14:36,720
and why do we want these two conditions

372
00:14:36,720 --> 00:14:38,240
because then the following equality

373
00:14:38,240 --> 00:14:41,440
holds f will be the end of all of these

374
00:14:41,440 --> 00:14:43,519
functions

375
00:14:43,519 --> 00:14:46,399
and then we'll be able to decompose f

376
00:14:46,399 --> 00:14:48,720
with end gates as we've seen before for

377
00:14:48,720 --> 00:14:52,399
secret sharing and we will be done

378
00:14:52,399 --> 00:14:55,120
so why are these two conditions enough

379
00:14:55,120 --> 00:14:56,839
for this equality to

380
00:14:56,839 --> 00:14:58,880
hold say

381
00:14:58,880 --> 00:15:02,560
f of x is one then by condition one f t

382
00:15:02,560 --> 00:15:05,440
of x is also one for every t and the

383
00:15:05,440 --> 00:15:07,199
equality holds

384
00:15:07,199 --> 00:15:10,560
and if f of x is zero

385
00:15:10,560 --> 00:15:13,760
then at least one function will also

386
00:15:13,760 --> 00:15:16,000
output 0 on this x

387
00:15:16,000 --> 00:15:17,600
and since this is an end gate the

388
00:15:17,600 --> 00:15:21,040
equality will again hold

389
00:15:21,040 --> 00:15:25,519
so it is only left to see how we

390
00:15:25,680 --> 00:15:27,440
find these

391
00:15:27,440 --> 00:15:29,600
ft's how we define them

392
00:15:29,600 --> 00:15:33,680
so they will hold these two properties

393
00:15:34,399 --> 00:15:36,959
we'll show an example for this reduction

394
00:15:36,959 --> 00:15:39,759
from high down slices to the half down

395
00:15:39,759 --> 00:15:40,800
slice

396
00:15:40,800 --> 00:15:43,600
for a specific high down size

397
00:15:43,600 --> 00:15:45,519
for the parameters to make sense so

398
00:15:45,519 --> 00:15:46,399
we'll

399
00:15:46,399 --> 00:15:49,519
observe a specific point 8 and down

400
00:15:49,519 --> 00:15:51,040
slice

401
00:15:51,040 --> 00:15:53,440
and then the functions ft we will choose

402
00:15:53,440 --> 00:15:55,440
will be defined as follows

403
00:15:55,440 --> 00:15:58,480
every function ft will be defined by a

404
00:15:58,480 --> 00:16:02,880
set t of 0.6 and parties

405
00:16:03,519 --> 00:16:06,320
and we will say that ft

406
00:16:06,320 --> 00:16:08,560
when it receives the input x

407
00:16:08,560 --> 00:16:12,160
some of it belongs t and some doesn't

408
00:16:12,160 --> 00:16:15,360
then the function will output whatever f

409
00:16:15,360 --> 00:16:16,880
outputs

410
00:16:16,880 --> 00:16:17,759
on

411
00:16:17,759 --> 00:16:19,040
x

412
00:16:19,040 --> 00:16:21,120
which is the same for the complement of

413
00:16:21,120 --> 00:16:26,000
t but only ones for the t part

414
00:16:26,000 --> 00:16:27,120
so

415
00:16:27,120 --> 00:16:29,440
for example if there was a complex uh

416
00:16:29,440 --> 00:16:31,680
input here with many ones and zeros then

417
00:16:31,680 --> 00:16:34,959
ft simply puts ones in all of the part

418
00:16:34,959 --> 00:16:38,079
that belongs to t and outputs whatever f

419
00:16:38,079 --> 00:16:40,800
would have outputted on this full

420
00:16:40,800 --> 00:16:43,199
input

421
00:16:43,920 --> 00:16:44,880
and

422
00:16:44,880 --> 00:16:47,680
we can first easily see that every such

423
00:16:47,680 --> 00:16:48,720
ft

424
00:16:48,720 --> 00:16:51,920
is larger than the original function

425
00:16:51,920 --> 00:16:54,880
since for every input it only increases

426
00:16:54,880 --> 00:16:57,839
the input it puts in more ones

427
00:16:57,839 --> 00:16:59,920
and then and then responds when the

428
00:16:59,920 --> 00:17:02,560
original function would have responded

429
00:17:02,560 --> 00:17:04,400
and since these functions are monotone

430
00:17:04,400 --> 00:17:07,119
this means that the output will also be

431
00:17:07,119 --> 00:17:08,959
larger

432
00:17:08,959 --> 00:17:11,599
and we notice that if we have an input

433
00:17:11,599 --> 00:17:13,359
that contains

434
00:17:13,359 --> 00:17:15,919
all of the bits of t it means that it

435
00:17:15,919 --> 00:17:20,480
already has one's where the set t lies

436
00:17:20,480 --> 00:17:23,599
then the function f t answers exactly

437
00:17:23,599 --> 00:17:25,919
the same as the function f on that input

438
00:17:25,919 --> 00:17:28,000
it changes nothing and simply responds

439
00:17:28,000 --> 00:17:30,400
whatever f response

440
00:17:30,400 --> 00:17:32,960
so this gives us a hint about how we

441
00:17:32,960 --> 00:17:33,919
will

442
00:17:33,919 --> 00:17:36,880
be able to satisfy the second condition

443
00:17:36,880 --> 00:17:38,960
where for every input at least one

444
00:17:38,960 --> 00:17:40,640
function must be

445
00:17:40,640 --> 00:17:43,919
equal to the original function

446
00:17:43,919 --> 00:17:44,799
and

447
00:17:44,799 --> 00:17:47,600
the way we do it is via combinatorial

448
00:17:47,600 --> 00:17:48,880
covers

449
00:17:48,880 --> 00:17:50,960
which is an idea which was already used

450
00:17:50,960 --> 00:17:52,640
for secret sharing schemes in the

451
00:17:52,640 --> 00:17:56,400
european paper of obama

452
00:17:56,720 --> 00:17:58,000
and

453
00:17:58,000 --> 00:18:01,039
the way to do it is to pick many such

454
00:18:01,039 --> 00:18:03,520
functions and many such t's

455
00:18:03,520 --> 00:18:04,720
such that

456
00:18:04,720 --> 00:18:09,360
every x of size 0.8 n that means that if

457
00:18:09,360 --> 00:18:12,240
this includes all of the max terms

458
00:18:12,240 --> 00:18:14,640
it will contain at least one of these

459
00:18:14,640 --> 00:18:16,960
t's

460
00:18:17,120 --> 00:18:20,000
and if this is the case

461
00:18:20,000 --> 00:18:23,919
then for every max term

462
00:18:24,400 --> 00:18:26,960
ft such that t is contained is that in

463
00:18:26,960 --> 00:18:30,640
that max term will equal f

464
00:18:30,640 --> 00:18:32,400
and then the two conditions we talked

465
00:18:32,400 --> 00:18:35,760
about in the previous slide

466
00:18:36,559 --> 00:18:37,679
will hold

467
00:18:37,679 --> 00:18:40,080
and we will be able to do this

468
00:18:40,080 --> 00:18:44,080
composition of f from the fts

469
00:18:44,160 --> 00:18:46,240
which is copied here

470
00:18:46,240 --> 00:18:49,280
and it will be a legitimate sql chain

471
00:18:49,280 --> 00:18:52,200
scheme for the high down slice

472
00:18:52,200 --> 00:18:54,840
0.8 of

473
00:18:54,840 --> 00:18:56,880
f so

474
00:18:56,880 --> 00:19:00,400
only one thing is remaining hidden here

475
00:19:00,400 --> 00:19:03,679
and that is why are these fts

476
00:19:03,679 --> 00:19:06,720
half down slices

477
00:19:06,720 --> 00:19:08,880
why are these ft's

478
00:19:08,880 --> 00:19:11,520
easier to implement

479
00:19:11,520 --> 00:19:15,280
more than any general function

480
00:19:16,960 --> 00:19:18,799
so we'll claim that

481
00:19:18,799 --> 00:19:21,520
these fts are actually half down slices

482
00:19:21,520 --> 00:19:25,919
but on a smaller input that means that

483
00:19:25,919 --> 00:19:31,440
there are 0.2 and 0.4 and down slices

484
00:19:32,080 --> 00:19:32,880
and

485
00:19:32,880 --> 00:19:35,760
the 0.4 end part is the easier one to

486
00:19:35,760 --> 00:19:38,000
understand since

487
00:19:38,000 --> 00:19:40,160
actually ft is defined only on the

488
00:19:40,160 --> 00:19:42,400
smaller part of the inputs as it always

489
00:19:42,400 --> 00:19:46,799
puts one in all other parts of the input

490
00:19:47,600 --> 00:19:50,000
and we will be able to observe that all

491
00:19:50,000 --> 00:19:51,360
max terms

492
00:19:51,360 --> 00:19:55,679
of any such ft are of size 0.2 n

493
00:19:55,679 --> 00:19:57,840
and why is that

494
00:19:57,840 --> 00:19:59,520
say that we have

495
00:19:59,520 --> 00:20:01,440
a set here in

496
00:20:01,440 --> 00:20:03,520
x t bar

497
00:20:03,520 --> 00:20:08,240
of size larger than 0.2 n of ones

498
00:20:08,240 --> 00:20:09,600
then ft

499
00:20:09,600 --> 00:20:12,559
will answer on it the same as f would

500
00:20:12,559 --> 00:20:17,280
for these ones plus these 0.6 and ones

501
00:20:17,280 --> 00:20:19,120
in x t

502
00:20:19,120 --> 00:20:21,039
and the sum of these ones here and here

503
00:20:21,039 --> 00:20:21,919
will be

504
00:20:21,919 --> 00:20:24,159
bigger than 0.8

505
00:20:24,159 --> 00:20:25,039
n

506
00:20:25,039 --> 00:20:26,320
which is the

507
00:20:26,320 --> 00:20:28,000
downslice parameter of the original

508
00:20:28,000 --> 00:20:30,480
function and therefore the slice

509
00:20:30,480 --> 00:20:33,679
will always output one on such inputs as

510
00:20:33,679 --> 00:20:36,000
we see here on the right uh with our

511
00:20:36,000 --> 00:20:38,080
graphical representation

512
00:20:38,080 --> 00:20:40,320
if sets are

513
00:20:40,320 --> 00:20:42,400
if the one sets are too large the

514
00:20:42,400 --> 00:20:45,440
function outputs one

515
00:20:45,440 --> 00:20:50,640
and if sets are of says exactly 0.2 and

516
00:20:50,640 --> 00:20:52,480
in the input of ft

517
00:20:52,480 --> 00:20:55,520
then there will be of size 0.8 n

518
00:20:55,520 --> 00:20:57,360
of the original function they could be

519
00:20:57,360 --> 00:21:00,559
unrestricted ones or zeros

520
00:21:00,559 --> 00:21:04,480
and below sets can only be zeroed out if

521
00:21:04,480 --> 00:21:07,360
they are contained in a max term of size

522
00:21:07,360 --> 00:21:10,720
0.2 n which corresponds to 0.8 n in the

523
00:21:10,720 --> 00:21:13,600
original function

524
00:21:14,159 --> 00:21:19,200
so this actually sums up the entire idea

525
00:21:19,200 --> 00:21:19,919
and

526
00:21:19,919 --> 00:21:22,320
the share size of such a scheme for this

527
00:21:22,320 --> 00:21:25,919
point eight and down slices will be

528
00:21:25,919 --> 00:21:30,240
the number of 0.6 and sets that is

529
00:21:30,240 --> 00:21:32,000
required to cover

530
00:21:32,000 --> 00:21:35,679
of the sets of size 0.8 n

531
00:21:35,679 --> 00:21:38,080
times the cost of the secret sharing

532
00:21:38,080 --> 00:21:40,960
schemes for such fts

533
00:21:40,960 --> 00:21:43,039
which is the share size of

534
00:21:43,039 --> 00:21:44,640
down slices

535
00:21:44,640 --> 00:21:47,520
of over 0.4 n parties where the

536
00:21:47,520 --> 00:21:51,120
downsized parameter is 0.2 n

537
00:21:51,120 --> 00:21:53,520
and this gets us to the graph we've seen

538
00:21:53,520 --> 00:21:54,880
before

539
00:21:54,880 --> 00:21:57,200
so we see here that the most expensive

540
00:21:57,200 --> 00:21:58,559
downslice

541
00:21:58,559 --> 00:22:01,679
will be that of the two-thirds downsize

542
00:22:01,679 --> 00:22:04,080
and it has the exponent we already

543
00:22:04,080 --> 00:22:06,159
mentioned many times the three halves to

544
00:22:06,159 --> 00:22:08,200
the end or two to the

545
00:22:08,200 --> 00:22:09,760
0.585

546
00:22:09,760 --> 00:22:12,760
n

547
00:22:13,679 --> 00:22:16,080
so now we will go in a faster pace

548
00:22:16,080 --> 00:22:17,520
through other results presented in the

549
00:22:17,520 --> 00:22:20,000
paper the first one being the linear

550
00:22:20,000 --> 00:22:22,159
scheme we mentioned

551
00:22:22,159 --> 00:22:24,240
so in this case we had to beat the

552
00:22:24,240 --> 00:22:27,280
exponent of point seven seven n by upper

553
00:22:27,280 --> 00:22:28,799
bound

554
00:22:28,799 --> 00:22:31,200
and if we try to do the exact same

555
00:22:31,200 --> 00:22:33,280
tricks as before with the reduction from

556
00:22:33,280 --> 00:22:36,080
high down slices to low down slices

557
00:22:36,080 --> 00:22:38,720
the numbers just don't add up and we get

558
00:22:38,720 --> 00:22:41,919
to a higher exponent than before

559
00:22:41,919 --> 00:22:43,360
and to

560
00:22:43,360 --> 00:22:44,600
get to the

561
00:22:44,600 --> 00:22:46,480
0.76n we

562
00:22:46,480 --> 00:22:48,720
had to use other tricks which rely on

563
00:22:48,720 --> 00:22:51,600
the properties of dual axis structures

564
00:22:51,600 --> 00:22:54,880
so we'll briefly define those

565
00:22:54,880 --> 00:22:57,679
a dual of a function f

566
00:22:57,679 --> 00:23:00,880
is a function which on an input x

567
00:23:00,880 --> 00:23:03,440
looks at what f outputs on the

568
00:23:03,440 --> 00:23:05,039
complement of x

569
00:23:05,039 --> 00:23:07,760
and outputs the opposite

570
00:23:07,760 --> 00:23:09,840
so in a verbal explanation it might

571
00:23:09,840 --> 00:23:12,960
sound complicated but a few examples

572
00:23:12,960 --> 00:23:13,840
will

573
00:23:13,840 --> 00:23:16,880
show us that it's actually pretty simple

574
00:23:16,880 --> 00:23:18,559
for example the dual of a threshold

575
00:23:18,559 --> 00:23:20,880
function is also a threshold function

576
00:23:20,880 --> 00:23:23,520
but with a different parameter so you

577
00:23:23,520 --> 00:23:25,840
can see that if all sets above

578
00:23:25,840 --> 00:23:28,720
size t are authorized by f

579
00:23:28,720 --> 00:23:31,360
then their complements which are sets of

580
00:23:31,360 --> 00:23:35,200
size below n minus t plus one

581
00:23:35,200 --> 00:23:38,000
will be unauthorized by the dual

582
00:23:38,000 --> 00:23:39,919
and the same happens

583
00:23:39,919 --> 00:23:42,559
with the zeros which turns to ones and

584
00:23:42,559 --> 00:23:45,120
basically when we look at these shapes

585
00:23:45,120 --> 00:23:47,039
to move to the dual function we just

586
00:23:47,039 --> 00:23:48,400
have to flip

587
00:23:48,400 --> 00:23:51,039
the shape over on its head then the

588
00:23:51,039 --> 00:23:52,799
then replace every one with a zero and

589
00:23:52,799 --> 00:23:55,279
every zero with a one

590
00:23:55,279 --> 00:23:56,320
so

591
00:23:56,320 --> 00:23:57,840
we can also

592
00:23:57,840 --> 00:24:00,159
see that the dual of a slice function

593
00:24:00,159 --> 00:24:02,320
will also be a slice function with a

594
00:24:02,320 --> 00:24:04,880
different parameter

595
00:24:04,880 --> 00:24:07,520
and the dual of up slices

596
00:24:07,520 --> 00:24:10,480
will be down slices

597
00:24:10,480 --> 00:24:12,880
here the zero stirs to one the

598
00:24:12,880 --> 00:24:16,080
unrestricted layer remains unrestricted

599
00:24:16,080 --> 00:24:18,400
in the dual and everything that was

600
00:24:18,400 --> 00:24:20,480
induced upwards

601
00:24:20,480 --> 00:24:22,720
in f in the up slice is now induced

602
00:24:22,720 --> 00:24:26,640
downwards in the dual of f

603
00:24:27,200 --> 00:24:28,320
so

604
00:24:28,320 --> 00:24:29,520
it is a

605
00:24:29,520 --> 00:24:31,360
old open problem

606
00:24:31,360 --> 00:24:33,840
in sql sharing whether the optimal share

607
00:24:33,840 --> 00:24:35,919
size for an access structure and its

608
00:24:35,919 --> 00:24:38,799
dual are the same

609
00:24:38,799 --> 00:24:41,360
but this problem is resolved for linear

610
00:24:41,360 --> 00:24:43,440
secret sharing schemes

611
00:24:43,440 --> 00:24:45,520
and we can use

612
00:24:45,520 --> 00:24:46,400
this

613
00:24:46,400 --> 00:24:49,200
theorem this idea to improve

614
00:24:49,200 --> 00:24:52,400
our linear schemes

615
00:24:52,400 --> 00:24:54,799
and the things we do is we

616
00:24:54,799 --> 00:24:57,279
realize up slices more efficiently via

617
00:24:57,279 --> 00:25:00,880
duality because we know that down slices

618
00:25:00,880 --> 00:25:03,120
can be realized more efficiently and

619
00:25:03,120 --> 00:25:05,679
then we move to the dual which is up

620
00:25:05,679 --> 00:25:08,480
slices and realize them

621
00:25:08,480 --> 00:25:10,720
and then we define a recursively a

622
00:25:10,720 --> 00:25:11,840
formula

623
00:25:11,840 --> 00:25:15,120
for every function f over down slices up

624
00:25:15,120 --> 00:25:16,480
slices and

625
00:25:16,480 --> 00:25:19,600
even slices and other types of functions

626
00:25:19,600 --> 00:25:20,400
and

627
00:25:20,400 --> 00:25:22,640
the size of this formula

628
00:25:22,640 --> 00:25:25,120
will be 2 to the

629
00:25:25,120 --> 00:25:28,840
7 6 n

630
00:25:29,360 --> 00:25:32,000
another insight that we had is that the

631
00:25:32,000 --> 00:25:33,919
average case is easier than the worst

632
00:25:33,919 --> 00:25:36,240
case for signaturing for down slices and

633
00:25:36,240 --> 00:25:37,919
up slices

634
00:25:37,919 --> 00:25:39,279
so here on the left you can see the

635
00:25:39,279 --> 00:25:41,760
expressions for the worst case and

636
00:25:41,760 --> 00:25:44,799
average case for up slices

637
00:25:44,799 --> 00:25:46,320
but it will be again easier to

638
00:25:46,320 --> 00:25:47,840
understand things by looking at the

639
00:25:47,840 --> 00:25:49,679
graph and we see that the average case

640
00:25:49,679 --> 00:25:50,640
is

641
00:25:50,640 --> 00:25:52,799
much easier

642
00:25:52,799 --> 00:25:54,799
for example for the middle slice the

643
00:25:54,799 --> 00:25:57,200
exponent in the worst case is n and the

644
00:25:57,200 --> 00:25:59,120
average case it will be

645
00:25:59,120 --> 00:26:00,720
half n

646
00:26:00,720 --> 00:26:02,880
and the similar phenomenon exists for

647
00:26:02,880 --> 00:26:05,600
down slices and even for linear schemes

648
00:26:05,600 --> 00:26:07,760
we can show the same thing the graphs of

649
00:26:07,760 --> 00:26:09,760
course will look a little different for

650
00:26:09,760 --> 00:26:12,000
uh every case

651
00:26:12,000 --> 00:26:12,720
and

652
00:26:12,720 --> 00:26:14,400
it also needs to be said that similar

653
00:26:14,400 --> 00:26:16,640
results were obtained by bimeland for us

654
00:26:16,640 --> 00:26:17,840
for

655
00:26:17,840 --> 00:26:21,360
up slices with a constant k

656
00:26:21,360 --> 00:26:24,799
and here we give the full picture for

657
00:26:24,799 --> 00:26:28,880
every possible upsize and downslides

658
00:26:28,880 --> 00:26:29,679
so

659
00:26:29,679 --> 00:26:31,679
the last thing we're going to talk about

660
00:26:31,679 --> 00:26:34,240
is this gap theorem which is really nice

661
00:26:34,240 --> 00:26:36,080
because it connects all the things we've

662
00:26:36,080 --> 00:26:37,600
talked about throughout

663
00:26:37,600 --> 00:26:39,440
this presentation

664
00:26:39,440 --> 00:26:42,080
and it basically says that one of the

665
00:26:42,080 --> 00:26:45,120
following three gaps must hold

666
00:26:45,120 --> 00:26:47,760
and the gaps are the first one the

667
00:26:47,760 --> 00:26:50,400
average case to worst case gap which we

668
00:26:50,400 --> 00:26:52,400
just talked about

669
00:26:52,400 --> 00:26:55,120
and the second one is the duality gap

670
00:26:55,120 --> 00:26:56,960
which means that

671
00:26:56,960 --> 00:26:58,880
there exists a function

672
00:26:58,880 --> 00:27:00,880
which has a better sequel sharing scheme

673
00:27:00,880 --> 00:27:01,919
than

674
00:27:01,919 --> 00:27:04,559
the optimal scheme for its duel

675
00:27:04,559 --> 00:27:06,480
and the non-linearity gap which means

676
00:27:06,480 --> 00:27:08,799
that the general secret sharing

677
00:27:08,799 --> 00:27:11,200
has exponentially smaller share sizes

678
00:27:11,200 --> 00:27:14,080
than linear secret sharing

679
00:27:14,080 --> 00:27:16,559
so we're going to show that one of these

680
00:27:16,559 --> 00:27:17,600
three

681
00:27:17,600 --> 00:27:20,320
gaps must hold by showing that if the

682
00:27:20,320 --> 00:27:22,480
first two are cancelled out then the

683
00:27:22,480 --> 00:27:24,480
third one holds

684
00:27:24,480 --> 00:27:26,480
so why is that

685
00:27:26,480 --> 00:27:27,679
first

686
00:27:27,679 --> 00:27:29,120
we just saw that

687
00:27:29,120 --> 00:27:31,840
if there will be no gap between

688
00:27:31,840 --> 00:27:33,520
the average case and the worst case for

689
00:27:33,520 --> 00:27:34,799
up slices

690
00:27:34,799 --> 00:27:36,399
then the up slice with the worst

691
00:27:36,399 --> 00:27:39,039
exponent will have an exponent of half

692
00:27:39,039 --> 00:27:41,039
and then for every function we'll be

693
00:27:41,039 --> 00:27:44,080
able to compose all of its up slices

694
00:27:44,080 --> 00:27:45,679
to a scheme

695
00:27:45,679 --> 00:27:48,480
with an exponent of half

696
00:27:48,480 --> 00:27:51,679
then if the duality gap is cancelled out

697
00:27:51,679 --> 00:27:53,679
we can use more tricks which we are not

698
00:27:53,679 --> 00:27:56,000
going to talk about to bring down the

699
00:27:56,000 --> 00:27:57,760
exponent

700
00:27:57,760 --> 00:27:59,440
a little further

701
00:27:59,440 --> 00:28:02,480
and this already implies a gap between

702
00:28:02,480 --> 00:28:04,399
general siquijor and linear secret

703
00:28:04,399 --> 00:28:07,520
sharing as linear secret sharing has a

704
00:28:07,520 --> 00:28:12,320
lower bound of 2 to the 0.5 n

705
00:28:12,480 --> 00:28:14,799
so this is basically it

706
00:28:14,799 --> 00:28:17,120
and we've talked about

707
00:28:17,120 --> 00:28:19,600
the upper bounds and the different types

708
00:28:19,600 --> 00:28:20,640
of scheme

709
00:28:20,640 --> 00:28:22,399
we show in the paper

710
00:28:22,399 --> 00:28:26,799
but the main open questions remain open

711
00:28:26,799 --> 00:28:29,440
can we achieve sub-exponential general

712
00:28:29,440 --> 00:28:31,760
secret sharing

713
00:28:31,760 --> 00:28:34,640
or can we improve the lower bound and

714
00:28:34,640 --> 00:28:34,800
the

715
00:28:34,800 --> 00:28:36,159
[Music]

716
00:28:36,159 --> 00:28:38,159
making progress in both of these

717
00:28:38,159 --> 00:28:40,320
questions should be a great achievement

718
00:28:40,320 --> 00:28:41,919
and we'll

719
00:28:41,919 --> 00:28:45,120
i think try to do it so hope to see you

720
00:28:45,120 --> 00:28:46,640
next time

721
00:28:46,640 --> 00:28:50,480
and thanks for listening

