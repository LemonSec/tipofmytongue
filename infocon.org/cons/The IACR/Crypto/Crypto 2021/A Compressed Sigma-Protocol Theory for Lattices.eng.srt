1
00:00:00,719 --> 00:00:02,560
hello my name is thomas atma and i will

2
00:00:02,560 --> 00:00:04,799
be presenting our paper a compressed

3
00:00:04,799 --> 00:00:07,600
sigma protocol theory for lattices this

4
00:00:07,600 --> 00:00:10,080
is joint work with my co-authors ronald

5
00:00:10,080 --> 00:00:13,440
kramer and lisa cole

6
00:00:13,599 --> 00:00:15,200
in this work we consider the following

7
00:00:15,200 --> 00:00:17,039
zero-knowledge scenario

8
00:00:17,039 --> 00:00:19,119
a proofer is committed to a secret input

9
00:00:19,119 --> 00:00:20,320
value x

10
00:00:20,320 --> 00:00:22,320
and it wishes to convince a verifier

11
00:00:22,320 --> 00:00:24,000
that it knows an opening to this

12
00:00:24,000 --> 00:00:26,480
commitment and that this opening

13
00:00:26,480 --> 00:00:28,840
satisfies an arbitrary public

14
00:00:28,840 --> 00:00:30,400
constraint

15
00:00:30,400 --> 00:00:32,238
moreover it wished to do this without

16
00:00:32,238 --> 00:00:34,079
releasing any additional information

17
00:00:34,079 --> 00:00:37,120
besides the veracity of the claim

18
00:00:37,120 --> 00:00:38,800
in other words we want to prove it to be

19
00:00:38,800 --> 00:00:40,399
able to do this in a zero-knowledge

20
00:00:40,399 --> 00:00:42,800
manner

21
00:00:43,280 --> 00:00:45,120
and our goal is to construct protocols

22
00:00:45,120 --> 00:00:47,120
for precisely this task

23
00:00:47,120 --> 00:00:48,559
and our protocols should have low

24
00:00:48,559 --> 00:00:51,039
communication complexity in particular

25
00:00:51,039 --> 00:00:52,719
we aim for a fully logarithmic

26
00:00:52,719 --> 00:00:55,120
communication complexity

27
00:00:55,120 --> 00:00:57,199
moreover we want the underlying hardness

28
00:00:57,199 --> 00:01:00,960
assumptions to be lattice based

29
00:01:00,960 --> 00:01:03,120
finally we aim for a commit improve

30
00:01:03,120 --> 00:01:05,040
functionality where the proofer first

31
00:01:05,040 --> 00:01:07,600
commits to the secret input value

32
00:01:07,600 --> 00:01:09,680
and at some later point in time decides

33
00:01:09,680 --> 00:01:11,439
to prove statements about the committed

34
00:01:11,439 --> 00:01:14,080
input value

35
00:01:14,320 --> 00:01:16,000
the starting point of our work is

36
00:01:16,000 --> 00:01:17,920
compressed sigma protocol theory as

37
00:01:17,920 --> 00:01:20,880
introduced at crypto 2020. the high

38
00:01:20,880 --> 00:01:23,520
level paradigm of this work is to solve

39
00:01:23,520 --> 00:01:25,439
linear instances first and then

40
00:01:25,439 --> 00:01:28,159
linearize non-linearities

41
00:01:28,159 --> 00:01:29,600
so basically

42
00:01:29,600 --> 00:01:32,079
first construct a protocol for proving

43
00:01:32,079 --> 00:01:33,840
linear relations so for proving that

44
00:01:33,840 --> 00:01:34,960
secret

45
00:01:34,960 --> 00:01:38,000
input factors satisfy a linear relation

46
00:01:38,000 --> 00:01:40,320
and then construct technique to

47
00:01:40,320 --> 00:01:43,960
linearize non-linearities

48
00:01:44,159 --> 00:01:45,759
the starting point of this theory is a

49
00:01:45,759 --> 00:01:47,520
natural sigma protocol for linear

50
00:01:47,520 --> 00:01:49,759
constraints so on the right hand side we

51
00:01:49,759 --> 00:01:52,240
see such a sigma protocol

52
00:01:52,240 --> 00:01:54,479
the sigma protocol allows approver to

53
00:01:54,479 --> 00:01:56,320
prove that it knows an opening to a

54
00:01:56,320 --> 00:01:58,399
commitment here the commitment is

55
00:01:58,399 --> 00:02:00,560
denoted by square brackets

56
00:02:00,560 --> 00:02:02,719
such that the opening of this commitment

57
00:02:02,719 --> 00:02:05,280
satisfies a linear constraint

58
00:02:05,280 --> 00:02:06,240
here

59
00:02:06,240 --> 00:02:09,598
captured by this linear form l

60
00:02:09,598 --> 00:02:11,038
so sigma protocol theory is a

61
00:02:11,038 --> 00:02:12,800
well-established widely used basis for

62
00:02:12,800 --> 00:02:14,640
general knowledge proofs

63
00:02:14,640 --> 00:02:17,120
in particular we know how to construct

64
00:02:17,120 --> 00:02:19,280
general constrained zero knowledge

65
00:02:19,280 --> 00:02:22,239
protocols based on sigma particles

66
00:02:22,239 --> 00:02:24,080
however these protocols have a linear

67
00:02:24,080 --> 00:02:26,000
communication complexity

68
00:02:26,000 --> 00:02:28,160
and this sigma protocol we can already

69
00:02:28,160 --> 00:02:29,599
see where this linear communication

70
00:02:29,599 --> 00:02:31,680
complexity comes from

71
00:02:31,680 --> 00:02:34,160
the final response set of this sigma

72
00:02:34,160 --> 00:02:36,959
protocol is namely of exactly the same

73
00:02:36,959 --> 00:02:39,920
size as the input x

74
00:02:39,920 --> 00:02:41,760
the secret input x

75
00:02:41,760 --> 00:02:44,160
so this sigma protocol is has a

76
00:02:44,160 --> 00:02:46,400
communication complexity that is linear

77
00:02:46,400 --> 00:02:48,840
in the size of the input

78
00:02:48,840 --> 00:02:50,480
x

79
00:02:50,480 --> 00:02:52,879
in compressed sigma protocol theory the

80
00:02:52,879 --> 00:02:55,280
communication complexity of this natural

81
00:02:55,280 --> 00:02:58,560
sigma protocol is compressed from linear

82
00:02:58,560 --> 00:03:01,120
down to logarithmic by applying an

83
00:03:01,120 --> 00:03:03,120
adaptation of a bulletproof proof of

84
00:03:03,120 --> 00:03:04,560
knowledge

85
00:03:04,560 --> 00:03:06,879
so bulletproof proof of knowledge

86
00:03:06,879 --> 00:03:08,879
is a recursive proof of knowledge for a

87
00:03:08,879 --> 00:03:11,200
certain quadratic relation

88
00:03:11,200 --> 00:03:13,440
so this proof of knowledge is adapted in

89
00:03:13,440 --> 00:03:15,519
compressed sigma protocol theory and

90
00:03:15,519 --> 00:03:17,840
repurposed as a black box compression

91
00:03:17,840 --> 00:03:21,120
mechanism for the sigma protocol

92
00:03:21,120 --> 00:03:24,640
for proving linear relations

93
00:03:25,200 --> 00:03:27,040
the resulting compressed sigma protocol

94
00:03:27,040 --> 00:03:29,200
still only allows a prover to prove that

95
00:03:29,200 --> 00:03:31,200
the committed factor satisfies a linear

96
00:03:31,200 --> 00:03:32,640
constraint

97
00:03:32,640 --> 00:03:35,440
to be able to handle non-linearities so

98
00:03:35,440 --> 00:03:36,959
to prove that a committed vector

99
00:03:36,959 --> 00:03:39,519
satisfies some non-linear constraint an

100
00:03:39,519 --> 00:03:41,760
arithmetic secret sharing scheme is used

101
00:03:41,760 --> 00:03:44,879
to linearize these non-linearities

102
00:03:44,879 --> 00:03:46,879
after the linearization the compressed

103
00:03:46,879 --> 00:03:48,720
sigma protocol for linear constraints

104
00:03:48,720 --> 00:03:52,400
can be used in a black box manner

105
00:03:54,400 --> 00:03:55,920
the compressed sigma protocol has been

106
00:03:55,920 --> 00:03:57,840
instantiated from a variety of hardness

107
00:03:57,840 --> 00:03:58,879
assumptions

108
00:03:58,879 --> 00:04:01,200
so we can achieve logarithmic

109
00:04:01,200 --> 00:04:02,879
communication by instantiating this

110
00:04:02,879 --> 00:04:04,879
theory from discrete logarithms strong

111
00:04:04,879 --> 00:04:07,680
rsa assumption

112
00:04:07,680 --> 00:04:09,280
but we can also achieve a constant

113
00:04:09,280 --> 00:04:10,720
communication complexity by

114
00:04:10,720 --> 00:04:12,799
instantiating this theory from the

115
00:04:12,799 --> 00:04:15,920
knowledge of experiment exemption

116
00:04:15,920 --> 00:04:19,600
also in a follow-up work this theory has

117
00:04:19,600 --> 00:04:20,399
been

118
00:04:20,399 --> 00:04:22,800
instantiated for pairing-based languages

119
00:04:22,800 --> 00:04:26,160
in a bi-linear circuit model

120
00:04:26,160 --> 00:04:28,479
so very natural question that arises is

121
00:04:28,479 --> 00:04:31,840
whether this theory also works for

122
00:04:31,840 --> 00:04:32,880
lattice

123
00:04:32,880 --> 00:04:36,000
based hardness assumptions

124
00:04:36,000 --> 00:04:37,919
we answer this natural question in the

125
00:04:37,919 --> 00:04:39,280
affirmative by constructing a

126
00:04:39,280 --> 00:04:40,720
lattice-based instantiation of

127
00:04:40,720 --> 00:04:43,280
compressed sigma protocol theory

128
00:04:43,280 --> 00:04:45,600
on a very high level we do this by

129
00:04:45,600 --> 00:04:47,440
replacing for example the peterson

130
00:04:47,440 --> 00:04:49,280
factor commitment scheme by a

131
00:04:49,280 --> 00:04:51,199
homomorphic factor commitment scheme

132
00:04:51,199 --> 00:04:53,680
that is based on a lattice assumption

133
00:04:53,680 --> 00:04:55,360
and in principle this should lead us to

134
00:04:55,360 --> 00:04:57,600
a circuit share knowledge protocol based

135
00:04:57,600 --> 00:04:59,120
on lattice assumptions with poly

136
00:04:59,120 --> 00:05:02,880
logarithmic communication complexity

137
00:05:02,880 --> 00:05:05,120
however when going through the motions

138
00:05:05,120 --> 00:05:07,600
we encounter a number of challenges

139
00:05:07,600 --> 00:05:09,199
so for example we have to deal with

140
00:05:09,199 --> 00:05:11,199
sound and slack approximation factors

141
00:05:11,199 --> 00:05:13,039
rejection sampling

142
00:05:13,039 --> 00:05:14,720
and on the board special ones verify

143
00:05:14,720 --> 00:05:16,160
zero knowledge

144
00:05:16,160 --> 00:05:18,160
well these challenges are not unique to

145
00:05:18,160 --> 00:05:19,919
compressed signal protocol theory and

146
00:05:19,919 --> 00:05:22,240
are also encountered when instantiating

147
00:05:22,240 --> 00:05:24,160
standard sigma protocols from lattice

148
00:05:24,160 --> 00:05:25,600
assumptions

149
00:05:25,600 --> 00:05:28,479
the difference however is that

150
00:05:28,479 --> 00:05:30,960
in contrast to standard sigma protocols

151
00:05:30,960 --> 00:05:32,880
compressed sigma protocols have

152
00:05:32,880 --> 00:05:35,919
logarithmically many rounds

153
00:05:35,919 --> 00:05:38,160
in these aspects they propagate through

154
00:05:38,160 --> 00:05:40,639
these rounds so for example the sound is

155
00:05:40,639 --> 00:05:41,600
slack

156
00:05:41,600 --> 00:05:43,520
accumulates through the logarithmically

157
00:05:43,520 --> 00:05:44,960
many rounds of a compressed sigma

158
00:05:44,960 --> 00:05:46,080
protocol

159
00:05:46,080 --> 00:05:48,479
this requires us to be very careful in

160
00:05:48,479 --> 00:05:50,880
the analysis and instantiation of the of

161
00:05:50,880 --> 00:05:52,800
the protocols

162
00:05:52,800 --> 00:05:54,560
and our contribution in this regards is

163
00:05:54,560 --> 00:05:56,880
that we develop an abstract framework

164
00:05:56,880 --> 00:05:58,880
and this abstract framework captures

165
00:05:58,880 --> 00:06:01,039
various design choices that allows us to

166
00:06:01,039 --> 00:06:03,360
instantiate or this abstract framework

167
00:06:03,360 --> 00:06:05,360
can be instantiated from a variety of

168
00:06:05,360 --> 00:06:06,720
lettuce

169
00:06:06,720 --> 00:06:09,039
assumptions and lettuce in sensations in

170
00:06:09,039 --> 00:06:11,680
contrast many other works are tailored

171
00:06:11,680 --> 00:06:15,759
to very specific lattice and sensations

172
00:06:15,759 --> 00:06:17,520
the second challenge that we encounter

173
00:06:17,520 --> 00:06:19,759
is the extractor analysis

174
00:06:19,759 --> 00:06:21,600
so lattice instantiations of sigma

175
00:06:21,600 --> 00:06:23,840
protocols and compressed sigma protocols

176
00:06:23,840 --> 00:06:25,680
typically have much smaller challenge

177
00:06:25,680 --> 00:06:28,000
sets and this leads to larger knowledge

178
00:06:28,000 --> 00:06:29,600
errors

179
00:06:29,600 --> 00:06:32,000
and our contribution in this regards is

180
00:06:32,000 --> 00:06:35,039
the first tight extractor analysis for

181
00:06:35,039 --> 00:06:38,240
protocols of this specific form

182
00:06:38,240 --> 00:06:39,840
for multi-round protocols of this

183
00:06:39,840 --> 00:06:41,759
specific form

184
00:06:41,759 --> 00:06:44,240
and not only is this extractor analysis

185
00:06:44,240 --> 00:06:46,560
applicable to lattice instantiations but

186
00:06:46,560 --> 00:06:48,479
it also leads to better parameters for

187
00:06:48,479 --> 00:06:51,840
non-lattice instantiations

188
00:06:52,639 --> 00:06:54,880
so for a similar reason so because we

189
00:06:54,880 --> 00:06:56,800
have these larger knowledge errors even

190
00:06:56,800 --> 00:06:59,440
with our tight extractor analysis

191
00:06:59,440 --> 00:07:01,759
we need to repeat the protocol in order

192
00:07:01,759 --> 00:07:04,160
to reduce the knowledge error

193
00:07:04,160 --> 00:07:06,800
and we have to do this by

194
00:07:06,800 --> 00:07:09,759
using a parallel repetition

195
00:07:09,759 --> 00:07:11,919
so our contribution is that we have a

196
00:07:11,919 --> 00:07:13,919
parallel novel parallel repetition

197
00:07:13,919 --> 00:07:16,400
theorem for arbitrary proofs of

198
00:07:16,400 --> 00:07:18,400
knowledge that shows that parallel

199
00:07:18,400 --> 00:07:20,000
repetition indeed

200
00:07:20,000 --> 00:07:23,360
reduces the knowledge error

201
00:07:24,880 --> 00:07:26,240
and finally

202
00:07:26,240 --> 00:07:28,000
we have to adapt the linearization

203
00:07:28,000 --> 00:07:29,520
strategy

204
00:07:29,520 --> 00:07:31,759
so a compressed sigma protocol shows how

205
00:07:31,759 --> 00:07:34,080
to linearize non-linear instances using

206
00:07:34,080 --> 00:07:36,400
an arithmetic secret sharing scheme

207
00:07:36,400 --> 00:07:38,880
so when we instantiate this theory from

208
00:07:38,880 --> 00:07:41,039
a lettuce assumption we have to define

209
00:07:41,039 --> 00:07:42,880
the secret channel scheme over a ring

210
00:07:42,880 --> 00:07:44,800
instead of a field

211
00:07:44,800 --> 00:07:47,919
this requires some adaptation and again

212
00:07:47,919 --> 00:07:51,039
a careful analysis

213
00:07:51,440 --> 00:07:53,360
a number of prior works on sub-linear

214
00:07:53,360 --> 00:07:54,800
lattice-based circuits and knowledge

215
00:07:54,800 --> 00:07:57,039
particles have appeared in literature

216
00:07:57,039 --> 00:07:58,319
the first circuit serial knowledge

217
00:07:58,319 --> 00:08:01,199
protocol with lattice assumptions and a

218
00:08:01,199 --> 00:08:02,879
sublinear communication complexity

219
00:08:02,879 --> 00:08:05,199
appeared in 2018

220
00:08:05,199 --> 00:08:06,319
however

221
00:08:06,319 --> 00:08:07,840
their communication complexity is not

222
00:08:07,840 --> 00:08:10,080
poly logarithmic and therefore does not

223
00:08:10,080 --> 00:08:14,240
achieve our goal last year in 2020 a

224
00:08:14,240 --> 00:08:15,599
lattice-based instantiation of

225
00:08:15,599 --> 00:08:17,680
bulletproofs was presented

226
00:08:17,680 --> 00:08:19,840
however this protocol is restricted to

227
00:08:19,840 --> 00:08:22,720
proving knowledge of an sis pre-image

228
00:08:22,720 --> 00:08:24,639
this protocol is not zero knowledge and

229
00:08:24,639 --> 00:08:26,400
it is tailored to a specific lattice

230
00:08:26,400 --> 00:08:27,680
instantiation

231
00:08:27,680 --> 00:08:29,759
particular to power of two cycle atomic

232
00:08:29,759 --> 00:08:32,080
number fields

233
00:08:32,080 --> 00:08:33,839
we also see a number of related works

234
00:08:33,839 --> 00:08:37,519
presented at this conference crypto 2021

235
00:08:37,519 --> 00:08:39,919
the bootle nl presents an alternative

236
00:08:39,919 --> 00:08:41,440
abstract framework for efficient

237
00:08:41,440 --> 00:08:43,599
circuits your knowledge protocols based

238
00:08:43,599 --> 00:08:46,000
on some check arguments

239
00:08:46,000 --> 00:08:47,839
given our extractor analysis their

240
00:08:47,839 --> 00:08:49,600
protocols achieve similar communication

241
00:08:49,600 --> 00:08:52,560
complexity as ours

242
00:08:52,560 --> 00:08:55,200
moreover albert and lie present an awful

243
00:08:55,200 --> 00:08:57,839
analysis of so-called subtractive

244
00:08:57,839 --> 00:08:58,959
subsets

245
00:08:58,959 --> 00:09:00,800
resulting in upper and lower bounds for

246
00:09:00,800 --> 00:09:02,640
certain lattice-based

247
00:09:02,640 --> 00:09:06,000
circuits here knowledge protocols

248
00:09:06,000 --> 00:09:08,480
they also present an extractor analysis

249
00:09:08,480 --> 00:09:10,480
however unlike ours their extractor

250
00:09:10,480 --> 00:09:13,760
analysis is non-tight

251
00:09:14,480 --> 00:09:16,000
for the remainder of this presentation

252
00:09:16,000 --> 00:09:17,519
we will focus on the technical details

253
00:09:17,519 --> 00:09:19,760
of our extractor analysis for the other

254
00:09:19,760 --> 00:09:22,640
topics we refer to our paper

255
00:09:22,640 --> 00:09:24,480
so rx factor analysis is not only

256
00:09:24,480 --> 00:09:26,480
applicable to compressed sigma protocols

257
00:09:26,480 --> 00:09:29,120
but to certain multi-round protocols

258
00:09:29,120 --> 00:09:31,040
in in general

259
00:09:31,040 --> 00:09:33,440
so these protocols take

260
00:09:33,440 --> 00:09:35,839
in principle take this form so as input

261
00:09:35,839 --> 00:09:37,440
to the political we have a public

262
00:09:37,440 --> 00:09:38,959
statement x

263
00:09:38,959 --> 00:09:41,600
so prover and verifier both know this

264
00:09:41,600 --> 00:09:44,399
public statement x and the prover claims

265
00:09:44,399 --> 00:09:47,440
to know a secret witness w associated to

266
00:09:47,440 --> 00:09:48,880
this witness

267
00:09:48,880 --> 00:09:51,200
x and

268
00:09:51,200 --> 00:09:53,200
the the proof and the verifier in this

269
00:09:53,200 --> 00:09:55,040
protocol they interact

270
00:09:55,040 --> 00:09:57,120
and the prover sends different messages

271
00:09:57,120 --> 00:09:59,440
the verifier sends challenges to the

272
00:09:59,440 --> 00:10:02,320
prover and in the end of the protocol so

273
00:10:02,320 --> 00:10:04,880
after these two mu plus one rounds the

274
00:10:04,880 --> 00:10:07,760
verifier decides whether to accept or

275
00:10:07,760 --> 00:10:10,399
reject the proofer's claim of known

276
00:10:10,399 --> 00:10:13,279
witness w

277
00:10:14,560 --> 00:10:16,240
so in our extractor analysis we

278
00:10:16,240 --> 00:10:18,079
basically aim to construct a knowledge

279
00:10:18,079 --> 00:10:20,480
extractor a knowledge extractor is an

280
00:10:20,480 --> 00:10:23,279
algorithm and this algorithm is given an

281
00:10:23,279 --> 00:10:25,120
input statement

282
00:10:25,120 --> 00:10:26,079
x

283
00:10:26,079 --> 00:10:29,839
and rewindable access to some proverb b

284
00:10:29,839 --> 00:10:31,519
and the goal of this knowledge extractor

285
00:10:31,519 --> 00:10:33,600
is to compute the witness w for

286
00:10:33,600 --> 00:10:36,399
statement x

287
00:10:36,480 --> 00:10:38,560
and we basically say that a protocol is

288
00:10:38,560 --> 00:10:41,120
knowledge sound if there exists an

289
00:10:41,120 --> 00:10:43,360
extractor with certain properties

290
00:10:43,360 --> 00:10:45,120
so for example this extractor should be

291
00:10:45,120 --> 00:10:47,200
efficient

292
00:10:47,200 --> 00:10:49,279
so informally this basically

293
00:10:49,279 --> 00:10:50,320
means

294
00:10:50,320 --> 00:10:51,120
that

295
00:10:51,120 --> 00:10:53,519
if there exists such an extractor

296
00:10:53,519 --> 00:10:55,600
then a prover can only convince the

297
00:10:55,600 --> 00:10:58,240
verifier if it knows a witness

298
00:10:58,240 --> 00:10:59,920
because if a proofer can convince a

299
00:10:59,920 --> 00:11:02,320
verifier that it knows a witness it can

300
00:11:02,320 --> 00:11:04,079
also run the extractor and compute the

301
00:11:04,079 --> 00:11:06,479
witness

302
00:11:07,200 --> 00:11:08,640
so the knowledge extractor should have

303
00:11:08,640 --> 00:11:10,480
certain properties so let us now

304
00:11:10,480 --> 00:11:12,399
formalize these properties

305
00:11:12,399 --> 00:11:13,680
and before we do that we need to

306
00:11:13,680 --> 00:11:15,839
introduce some notation

307
00:11:15,839 --> 00:11:17,600
epsilon x will denote the success

308
00:11:17,600 --> 00:11:19,600
probability of the prover on public

309
00:11:19,600 --> 00:11:21,440
input x

310
00:11:21,440 --> 00:11:22,560
so this

311
00:11:22,560 --> 00:11:24,560
is the success probability of the prover

312
00:11:24,560 --> 00:11:26,800
to which the extractor is given a

313
00:11:26,800 --> 00:11:29,839
rewindable black box axis

314
00:11:29,839 --> 00:11:32,560
moreover we let kappa x be the knowledge

315
00:11:32,560 --> 00:11:34,480
error of the protocol

316
00:11:34,480 --> 00:11:36,800
intuitively a protocol has knowledge

317
00:11:36,800 --> 00:11:39,360
error kappa x if a dishonest proofer

318
00:11:39,360 --> 00:11:41,920
succeeds in convincing verifier with

319
00:11:41,920 --> 00:11:46,240
probability at most kappa x

320
00:11:46,800 --> 00:11:49,120
so given this notation we have the

321
00:11:49,120 --> 00:11:50,720
following standard definition of

322
00:11:50,720 --> 00:11:52,880
knowledge sounds which requires

323
00:11:52,880 --> 00:11:55,040
knowledge extractor to have expected

324
00:11:55,040 --> 00:11:56,399
time

325
00:11:56,399 --> 00:11:59,200
pulling x divided by epsilon x minus

326
00:11:59,200 --> 00:12:01,839
kappa x

327
00:12:02,720 --> 00:12:04,560
however we also have the following

328
00:12:04,560 --> 00:12:06,880
alternative definition for knowledge

329
00:12:06,880 --> 00:12:07,920
soundness

330
00:12:07,920 --> 00:12:09,680
and this alternative definition turns

331
00:12:09,680 --> 00:12:11,920
out to be equivalent to the previous one

332
00:12:11,920 --> 00:12:13,839
however in some scenarios this

333
00:12:13,839 --> 00:12:15,760
alternative definition is more

334
00:12:15,760 --> 00:12:17,839
convenient to work with for this reason

335
00:12:17,839 --> 00:12:20,560
we introduced and we will actually be

336
00:12:20,560 --> 00:12:22,959
using second definition to prove that

337
00:12:22,959 --> 00:12:25,839
our protocols are knowledge sound

338
00:12:25,839 --> 00:12:28,399
and the second definition requires an

339
00:12:28,399 --> 00:12:30,880
extractor to have expected polynomial

340
00:12:30,880 --> 00:12:32,320
runtime

341
00:12:32,320 --> 00:12:34,320
so note that the extractor of the first

342
00:12:34,320 --> 00:12:36,399
definition does not necessarily have an

343
00:12:36,399 --> 00:12:38,480
expected polynomial runtime

344
00:12:38,480 --> 00:12:40,639
because epsilon minus kappa x might be

345
00:12:40,639 --> 00:12:43,200
negligible

346
00:12:43,200 --> 00:12:45,680
however in the second definition

347
00:12:45,680 --> 00:12:47,200
the

348
00:12:47,200 --> 00:12:49,680
extractor has a success probability

349
00:12:49,680 --> 00:12:52,160
epsilon x minus kappa x divided by some

350
00:12:52,160 --> 00:12:55,120
polynomial in x

351
00:12:55,120 --> 00:12:57,600
so basically there's a trade-off in

352
00:12:57,600 --> 00:13:00,079
these two definitions between

353
00:13:00,079 --> 00:13:02,639
expected run time and success

354
00:13:02,639 --> 00:13:05,279
probability so the first one can have a

355
00:13:05,279 --> 00:13:07,200
lot larger in the first definition the

356
00:13:07,200 --> 00:13:09,360
knowledge extractor can have a larger

357
00:13:09,360 --> 00:13:11,600
expected room time but it always has

358
00:13:11,600 --> 00:13:13,519
successful ability one

359
00:13:13,519 --> 00:13:16,720
and in the second definition

360
00:13:16,720 --> 00:13:18,639
the success probability can be a bit

361
00:13:18,639 --> 00:13:22,720
smaller but the runtime is polynomial on

362
00:13:22,720 --> 00:13:25,440
expectation

363
00:13:25,760 --> 00:13:27,279
so to prove that the protocol is

364
00:13:27,279 --> 00:13:29,839
knowledge sound we have to show that

365
00:13:29,839 --> 00:13:31,680
there exists a knowledge extractor with

366
00:13:31,680 --> 00:13:34,880
the above mentioned properties

367
00:13:34,880 --> 00:13:37,360
this can be a challenging task

368
00:13:37,360 --> 00:13:39,600
to this end we also have another notion

369
00:13:39,600 --> 00:13:41,839
of soundness that is much easier to

370
00:13:41,839 --> 00:13:42,880
handle

371
00:13:42,880 --> 00:13:44,800
namely special soundness

372
00:13:44,800 --> 00:13:46,560
it is typically much easier to prove

373
00:13:46,560 --> 00:13:48,560
that a protocol is special sound then

374
00:13:48,560 --> 00:13:52,160
proving that it is knowledge sound

375
00:13:52,320 --> 00:13:54,320
so what is special soundness so let us

376
00:13:54,320 --> 00:13:57,760
consider a tree move protocol

377
00:13:57,760 --> 00:14:00,560
where the the verifier sends only one

378
00:14:00,560 --> 00:14:02,079
challenge in the second move of the

379
00:14:02,079 --> 00:14:04,480
protocol a such a protocol is called

380
00:14:04,480 --> 00:14:06,320
special sound if there exists an

381
00:14:06,320 --> 00:14:07,440
algorithm

382
00:14:07,440 --> 00:14:10,160
that on input two accepting transcripts

383
00:14:10,160 --> 00:14:13,360
a comma c comma z and a c prime comma z

384
00:14:13,360 --> 00:14:14,480
prime

385
00:14:14,480 --> 00:14:19,279
outputs so witness w for a statement x

386
00:14:19,279 --> 00:14:21,680
so uh in these transcripts a is the

387
00:14:21,680 --> 00:14:23,120
first message from the proofer to the

388
00:14:23,120 --> 00:14:25,279
verifier c is the challenge sent from

389
00:14:25,279 --> 00:14:27,199
the verifier to the proofer and that is

390
00:14:27,199 --> 00:14:30,480
the final response from the approver to

391
00:14:30,480 --> 00:14:31,760
the verifier

392
00:14:31,760 --> 00:14:32,720
and

393
00:14:32,720 --> 00:14:34,880
the special soundness definition

394
00:14:34,880 --> 00:14:36,639
requires these two

395
00:14:36,639 --> 00:14:40,240
transcripts to have coinciding first

396
00:14:40,240 --> 00:14:42,000
message so both transcripts should have

397
00:14:42,000 --> 00:14:44,560
the same first message and the challenge

398
00:14:44,560 --> 00:14:46,720
sent by the verifier

399
00:14:46,720 --> 00:14:48,880
should be different for the second

400
00:14:48,880 --> 00:14:51,600
transcript

401
00:14:51,839 --> 00:14:54,240
so it's typically much easier to prove

402
00:14:54,240 --> 00:14:56,240
that a search inefficient algorithm

403
00:14:56,240 --> 00:14:58,720
exists than proving the existence of a

404
00:14:58,720 --> 00:15:00,320
knowledge extractor with the desired

405
00:15:00,320 --> 00:15:02,480
properties

406
00:15:02,480 --> 00:15:04,800
however we also have this very generic

407
00:15:04,800 --> 00:15:06,880
result that shows that special soundness

408
00:15:06,880 --> 00:15:08,959
implies knowledge soundness with

409
00:15:08,959 --> 00:15:11,120
knowledge error one over n where n is

410
00:15:11,120 --> 00:15:14,160
the size of the challenge set

411
00:15:14,160 --> 00:15:16,720
so this basically means that using this

412
00:15:16,720 --> 00:15:18,560
generic result we only have to prove

413
00:15:18,560 --> 00:15:20,480
that the protocol is special sound

414
00:15:20,480 --> 00:15:22,639
because by this generic result knowledge

415
00:15:22,639 --> 00:15:25,440
sounders will automatically follow

416
00:15:25,440 --> 00:15:27,199
so this is a very

417
00:15:27,199 --> 00:15:31,040
convenient result that allows us to to

418
00:15:31,040 --> 00:15:32,800
deal with special sounders rather than

419
00:15:32,800 --> 00:15:36,000
knowledge channels directly

420
00:15:36,000 --> 00:15:37,519
this

421
00:15:37,519 --> 00:15:39,279
this definition of special soundness

422
00:15:39,279 --> 00:15:41,680
where we require only two accepting

423
00:15:41,680 --> 00:15:43,279
transcripts as

424
00:15:43,279 --> 00:15:46,320
a natural generalization to case special

425
00:15:46,320 --> 00:15:48,720
soundness where the efficient algorithm

426
00:15:48,720 --> 00:15:52,160
requires k different transcripts

427
00:15:52,160 --> 00:15:52,880
and

428
00:15:52,880 --> 00:15:54,560
also the

429
00:15:54,560 --> 00:15:56,720
this result that special soundness

430
00:15:56,720 --> 00:15:58,079
implies knowledge sounders can be

431
00:15:58,079 --> 00:16:01,120
generalized to k special soundness

432
00:16:01,120 --> 00:16:03,120
more precisely it is known that k

433
00:16:03,120 --> 00:16:05,199
special soundness implies knowledge

434
00:16:05,199 --> 00:16:07,279
soundness with knowledge error k minus 1

435
00:16:07,279 --> 00:16:09,839
over n

436
00:16:11,759 --> 00:16:13,519
we've only treated the special sinus

437
00:16:13,519 --> 00:16:15,600
protocols for the case of three round

438
00:16:15,600 --> 00:16:17,839
protocols however this property has a

439
00:16:17,839 --> 00:16:19,839
natural generalization to multi-round

440
00:16:19,839 --> 00:16:21,199
protocols

441
00:16:21,199 --> 00:16:22,639
the precise definition of this

442
00:16:22,639 --> 00:16:24,480
generalization is not important for the

443
00:16:24,480 --> 00:16:26,800
stock but informally we say that a

444
00:16:26,800 --> 00:16:29,759
protocol is k1 up to k mu special sound

445
00:16:29,759 --> 00:16:32,560
if the protocol is ki special sound with

446
00:16:32,560 --> 00:16:35,360
respect to the height challenge

447
00:16:35,360 --> 00:16:37,440
a bit more precisely a protocol

448
00:16:37,440 --> 00:16:39,360
satisfies this generalized notion of

449
00:16:39,360 --> 00:16:41,519
special soundness if there exists an

450
00:16:41,519 --> 00:16:43,440
algorithm that given a certain

451
00:16:43,440 --> 00:16:45,600
structured set of transcripts

452
00:16:45,600 --> 00:16:48,720
extracts a witness

453
00:16:48,959 --> 00:16:52,000
our result now shows that k1 up to k new

454
00:16:52,000 --> 00:16:54,079
special soundness tightly implies

455
00:16:54,079 --> 00:16:56,959
knowledge sadness

456
00:16:57,360 --> 00:16:58,880
prior works have studied special

457
00:16:58,880 --> 00:17:01,360
soundness of multiround protocols

458
00:17:01,360 --> 00:17:04,480
for example an asymptotic analysis

459
00:17:04,480 --> 00:17:06,559
has been done and this asymptotic

460
00:17:06,559 --> 00:17:08,160
analysis shows that

461
00:17:08,160 --> 00:17:10,480
an exponentially large challenge set

462
00:17:10,480 --> 00:17:13,359
implies a negligible knowledge error

463
00:17:13,359 --> 00:17:15,199
however this result does not give a

464
00:17:15,199 --> 00:17:17,520
concrete knowledge error moreover it is

465
00:17:17,520 --> 00:17:19,919
not applicable to the lattice setting

466
00:17:19,919 --> 00:17:21,760
because in the lattice setting

467
00:17:21,760 --> 00:17:24,640
challenge sets are typically not

468
00:17:24,640 --> 00:17:27,760
exponentially large

469
00:17:28,000 --> 00:17:30,640
also there exists a concrete analysis of

470
00:17:30,640 --> 00:17:32,559
this asymptotic approach

471
00:17:32,559 --> 00:17:35,039
however the resulting error is knowledge

472
00:17:35,039 --> 00:17:38,000
error is not tied

473
00:17:38,480 --> 00:17:40,799
on a high level we achieve our result by

474
00:17:40,799 --> 00:17:43,760
applying the following techniques

475
00:17:43,760 --> 00:17:45,760
first we use the alternative but

476
00:17:45,760 --> 00:17:47,440
equivalent definition of knowledge

477
00:17:47,440 --> 00:17:49,679
soundness

478
00:17:49,679 --> 00:17:51,840
second we simplify the extractor for

479
00:17:51,840 --> 00:17:54,559
three round protocols

480
00:17:54,559 --> 00:17:56,799
we use sampling with replacement instead

481
00:17:56,799 --> 00:18:00,080
of sampling without replacement

482
00:18:00,080 --> 00:18:02,799
because of these two ids our three-round

483
00:18:02,799 --> 00:18:05,360
extractor can be applied recursively to

484
00:18:05,360 --> 00:18:07,280
the multi-round case

485
00:18:07,280 --> 00:18:10,880
this is in contrast to prior works

486
00:18:10,880 --> 00:18:13,120
so let us now describe our knowledge

487
00:18:13,120 --> 00:18:15,520
extractor we consider

488
00:18:15,520 --> 00:18:18,559
special sound three round protocols

489
00:18:18,559 --> 00:18:20,240
so the only thing the extractor has to

490
00:18:20,240 --> 00:18:23,520
do is it is to extract two different

491
00:18:23,520 --> 00:18:25,360
accepting transcripts because the

492
00:18:25,360 --> 00:18:27,679
protocol is special sound

493
00:18:27,679 --> 00:18:31,360
and to do this it proceeds as follows

494
00:18:31,360 --> 00:18:33,679
in the first step the extractor queries

495
00:18:33,679 --> 00:18:36,720
the prover on a random channel c

496
00:18:36,720 --> 00:18:38,720
so the the extractor sends a random

497
00:18:38,720 --> 00:18:40,400
challenge to the proofer

498
00:18:40,400 --> 00:18:41,520
and

499
00:18:41,520 --> 00:18:43,520
it sees whether the proofer returns an

500
00:18:43,520 --> 00:18:46,080
accepting transcript or not

501
00:18:46,080 --> 00:18:48,720
if the proofer fails to return an

502
00:18:48,720 --> 00:18:50,400
accepting transcript the extractor

503
00:18:50,400 --> 00:18:52,080
aborts

504
00:18:52,080 --> 00:18:54,400
if the proofer succeeds

505
00:18:54,400 --> 00:18:56,799
then the extractor keeps rewinding so it

506
00:18:56,799 --> 00:18:58,160
keeps

507
00:18:58,160 --> 00:19:01,120
sending new challenges c

508
00:19:01,120 --> 00:19:03,039
until it has found a second accepting

509
00:19:03,039 --> 00:19:04,640
transcript

510
00:19:04,640 --> 00:19:06,960
and every time it rewinds the extractor

511
00:19:06,960 --> 00:19:08,880
fixes the proofers randomness so the

512
00:19:08,880 --> 00:19:11,440
first message of the transcripts stay

513
00:19:11,440 --> 00:19:12,720
the same

514
00:19:12,720 --> 00:19:15,120
and also the proofer or the extractor

515
00:19:15,120 --> 00:19:16,960
samples challenges

516
00:19:16,960 --> 00:19:18,799
with replacement

517
00:19:18,799 --> 00:19:19,600
so

518
00:19:19,600 --> 00:19:21,440
once it has tried the challenge it will

519
00:19:21,440 --> 00:19:24,480
never try the same challenge again

520
00:19:24,480 --> 00:19:26,320
and it continues in this manner until it

521
00:19:26,320 --> 00:19:27,520
has found the second accepting

522
00:19:27,520 --> 00:19:30,000
transcript or until it has exhausted all

523
00:19:30,000 --> 00:19:32,640
different challenges

524
00:19:32,640 --> 00:19:35,039
so this is already how our extractor

525
00:19:35,039 --> 00:19:36,960
works it is a very simple

526
00:19:36,960 --> 00:19:38,400
algorithm

527
00:19:38,400 --> 00:19:39,520
and

528
00:19:39,520 --> 00:19:41,679
we can prove the following two levels so

529
00:19:41,679 --> 00:19:43,760
the first one shows that the expected

530
00:19:43,760 --> 00:19:46,160
number of queries

531
00:19:46,160 --> 00:19:49,520
of this extractor is at most two

532
00:19:49,520 --> 00:19:51,520
so this basically shows that this

533
00:19:51,520 --> 00:19:53,120
extractor

534
00:19:53,120 --> 00:19:54,080
has

535
00:19:54,080 --> 00:19:54,960
runs

536
00:19:54,960 --> 00:19:57,600
efficiently

537
00:19:57,600 --> 00:19:59,200
moreover the second dilemma shows that

538
00:19:59,200 --> 00:20:00,799
the success probability of this

539
00:20:00,799 --> 00:20:04,480
extractor is at least epsilon minus one

540
00:20:04,480 --> 00:20:07,120
over n where n is the size of the

541
00:20:07,120 --> 00:20:09,200
challenge set and epsilon is the success

542
00:20:09,200 --> 00:20:11,520
probability of disprover

543
00:20:11,520 --> 00:20:13,440
so these two lemmas together they

544
00:20:13,440 --> 00:20:14,960
basically prove

545
00:20:14,960 --> 00:20:15,919
that

546
00:20:15,919 --> 00:20:18,320
this extractor satisfies the desired

547
00:20:18,320 --> 00:20:19,919
properties and that our protocol is

548
00:20:19,919 --> 00:20:22,080
knowledge sound so basically that

549
00:20:22,080 --> 00:20:24,000
special soundness implies knowledge

550
00:20:24,000 --> 00:20:27,679
soundness with knowledge error 1 over n

551
00:20:27,679 --> 00:20:29,440
let us now prove the two lemmas

552
00:20:29,440 --> 00:20:30,960
describing the properties of our

553
00:20:30,960 --> 00:20:32,559
extractor

554
00:20:32,559 --> 00:20:34,640
to do this we define the random variable

555
00:20:34,640 --> 00:20:38,240
a that indicates the prover's randomness

556
00:20:38,240 --> 00:20:39,919
first we start by proving that our

557
00:20:39,919 --> 00:20:42,880
extractor is efficient

558
00:20:42,880 --> 00:20:45,360
intuitively we can see that the

559
00:20:45,360 --> 00:20:47,280
extractor is efficient

560
00:20:47,280 --> 00:20:49,679
by considering the following two cases

561
00:20:49,679 --> 00:20:51,840
so first if the success probability of

562
00:20:51,840 --> 00:20:54,640
the proofer is large then the extractor

563
00:20:54,640 --> 00:20:56,559
will quickly quickly find two

564
00:20:56,559 --> 00:20:57,919
transcripts

565
00:20:57,919 --> 00:20:59,600
but if the success probability of the

566
00:20:59,600 --> 00:21:01,679
proofer is small then with a high

567
00:21:01,679 --> 00:21:03,919
probability the extractor will abort

568
00:21:03,919 --> 00:21:05,919
after only one query

569
00:21:05,919 --> 00:21:08,640
so in both cases the extractor runs

570
00:21:08,640 --> 00:21:11,039
efficiently

571
00:21:11,039 --> 00:21:12,720
for the formal proof of disclaimer we

572
00:21:12,720 --> 00:21:14,320
first condition on the proof is

573
00:21:14,320 --> 00:21:16,640
randomness being equal to a

574
00:21:16,640 --> 00:21:18,400
if this is the case the first step of

575
00:21:18,400 --> 00:21:20,480
the extractor succeeds with probability

576
00:21:20,480 --> 00:21:22,640
epsilon a where epsilon is this

577
00:21:22,640 --> 00:21:25,919
conditional success probability

578
00:21:25,919 --> 00:21:27,840
if it does the extractor starts a

579
00:21:27,840 --> 00:21:30,320
negative hypergeometric experiment in

580
00:21:30,320 --> 00:21:32,400
which it samples challenges

581
00:21:32,400 --> 00:21:34,640
with replacement until it has found a

582
00:21:34,640 --> 00:21:37,440
second accepting transcript or until it

583
00:21:37,440 --> 00:21:40,080
has exhausted all challenges

584
00:21:40,080 --> 00:21:42,640
so the expected number of trials of this

585
00:21:42,640 --> 00:21:45,120
negative hypergeometric experiment is at

586
00:21:45,120 --> 00:21:49,039
most one over epsilon a

587
00:21:49,760 --> 00:21:51,679
together these two observations show

588
00:21:51,679 --> 00:21:53,760
that the expected number of proofer

589
00:21:53,760 --> 00:21:55,919
queries is at most two

590
00:21:55,919 --> 00:21:58,880
which finishes the proof of this lamp

591
00:21:58,880 --> 00:22:00,640
let us now show that our extractor

592
00:22:00,640 --> 00:22:02,320
succeeds with probability at least

593
00:22:02,320 --> 00:22:04,799
epsilon minus 1 over n where n is the

594
00:22:04,799 --> 00:22:07,120
size of the challenge set

595
00:22:07,120 --> 00:22:09,200
the intuition behind this

596
00:22:09,200 --> 00:22:10,960
result is that in the first step the

597
00:22:10,960 --> 00:22:12,880
proofer succeeds with probability

598
00:22:12,880 --> 00:22:14,640
exactly epsilon

599
00:22:14,640 --> 00:22:16,559
and in the second step so this negative

600
00:22:16,559 --> 00:22:19,360
hypergeometric experiment the proverbs

601
00:22:19,360 --> 00:22:21,919
or the extractor succeeds if and only if

602
00:22:21,919 --> 00:22:23,760
there exists a second accepting

603
00:22:23,760 --> 00:22:25,760
challenge

604
00:22:25,760 --> 00:22:27,919
because it keeps trying until it has

605
00:22:27,919 --> 00:22:30,000
either found an accept accepting

606
00:22:30,000 --> 00:22:31,200
challenge

607
00:22:31,200 --> 00:22:33,120
accepting transcript or until it has

608
00:22:33,120 --> 00:22:35,679
exhausted all challenges

609
00:22:35,679 --> 00:22:37,440
for the formal proof of dislema we again

610
00:22:37,440 --> 00:22:38,960
condition on the provers randomness

611
00:22:38,960 --> 00:22:40,640
being equal to a

612
00:22:40,640 --> 00:22:42,799
if this is the case we can easily see

613
00:22:42,799 --> 00:22:44,960
that the extractor succeeds if the first

614
00:22:44,960 --> 00:22:47,440
step is successful and if epsilon a is

615
00:22:47,440 --> 00:22:49,520
larger than one over n

616
00:22:49,520 --> 00:22:51,760
namely if epsilon a is larger than one

617
00:22:51,760 --> 00:22:53,840
over n it means that there exists a

618
00:22:53,840 --> 00:22:55,760
second challenge for which the proofer

619
00:22:55,760 --> 00:23:00,000
can produce an accepting transcript

620
00:23:00,159 --> 00:23:01,840
hence the success probability of the

621
00:23:01,840 --> 00:23:04,320
extractor equals this this

622
00:23:04,320 --> 00:23:06,240
precise expression

623
00:23:06,240 --> 00:23:10,720
and this sum can be split into two parts

624
00:23:10,720 --> 00:23:13,200
and the first part is easily seen to be

625
00:23:13,200 --> 00:23:14,640
equal to epsilon

626
00:23:14,640 --> 00:23:17,120
and the second part is easily seen to be

627
00:23:17,120 --> 00:23:19,840
at most one over n

628
00:23:19,840 --> 00:23:22,240
hence the success probability of this

629
00:23:22,240 --> 00:23:25,440
extractor is at least epsilon minus one

630
00:23:25,440 --> 00:23:28,000
over n which completes the proof of this

631
00:23:28,000 --> 00:23:30,320
lemon

632
00:23:30,640 --> 00:23:32,799
thus far we've described the extractor

633
00:23:32,799 --> 00:23:35,200
and its analysis for a three round

634
00:23:35,200 --> 00:23:37,440
special sound protocols

635
00:23:37,440 --> 00:23:39,440
this extractor or this approach

636
00:23:39,440 --> 00:23:41,840
immediately generalizes to k special

637
00:23:41,840 --> 00:23:44,159
sound protocols so still three round

638
00:23:44,159 --> 00:23:45,760
protocols but

639
00:23:45,760 --> 00:23:47,679
now k special sound instead of two

640
00:23:47,679 --> 00:23:49,760
special sounds

641
00:23:49,760 --> 00:23:52,480
moreover we can apply this specific

642
00:23:52,480 --> 00:23:54,880
extractor recursively to the multi-round

643
00:23:54,880 --> 00:23:57,039
scenario

644
00:23:57,039 --> 00:23:58,960
we do have to be a bit careful with the

645
00:23:58,960 --> 00:24:00,799
analysis but it turns out that

646
00:24:00,799 --> 00:24:02,720
everything works out and we can obtain

647
00:24:02,720 --> 00:24:06,400
the following theorem showing that k1

648
00:24:06,400 --> 00:24:08,960
up to k mu special soundness implies

649
00:24:08,960 --> 00:24:11,440
knowledge soundness with this precise

650
00:24:11,440 --> 00:24:14,159
knowledge error

651
00:24:15,120 --> 00:24:17,279
moreover this expression or of this

652
00:24:17,279 --> 00:24:19,919
knowledge error is tight so typically

653
00:24:19,919 --> 00:24:22,640
there exists a cheating strategy for k1

654
00:24:22,640 --> 00:24:25,120
of 2k new special sound protocols that

655
00:24:25,120 --> 00:24:27,840
succeeds with probability kappa so we

656
00:24:27,840 --> 00:24:29,360
cannot hope to

657
00:24:29,360 --> 00:24:31,120
obtain a knowledge error smaller than

658
00:24:31,120 --> 00:24:33,520
kappa for this generic class of

659
00:24:33,520 --> 00:24:35,440
protocols

660
00:24:35,440 --> 00:24:37,120
this brings me to the conclusion of this

661
00:24:37,120 --> 00:24:39,279
presentation and a short summary of our

662
00:24:39,279 --> 00:24:40,960
contributions

663
00:24:40,960 --> 00:24:42,960
so we developed the first lattice-based

664
00:24:42,960 --> 00:24:44,559
circuit zero knowledge protocol with

665
00:24:44,559 --> 00:24:47,120
poly logarithmic communication

666
00:24:47,120 --> 00:24:49,120
moreover it supports commit and proof

667
00:24:49,120 --> 00:24:50,400
functionality

668
00:24:50,400 --> 00:24:53,760
and it does not have a trusted setup

669
00:24:53,760 --> 00:24:55,919
also we develop a general and tight

670
00:24:55,919 --> 00:24:58,880
extractor analysis for special sound

671
00:24:58,880 --> 00:25:00,400
protocols

672
00:25:00,400 --> 00:25:01,200
this

673
00:25:01,200 --> 00:25:03,520
extractor analysis also has applications

674
00:25:03,520 --> 00:25:05,679
and practical benefits for non-lattice

675
00:25:05,679 --> 00:25:07,440
instantiations of compressed sigma

676
00:25:07,440 --> 00:25:08,799
protocols

677
00:25:08,799 --> 00:25:12,240
and other protocols such as bulletproof

678
00:25:12,240 --> 00:25:15,360
moreover we develop a novel parallel

679
00:25:15,360 --> 00:25:17,440
repetition theorem for proofs of

680
00:25:17,440 --> 00:25:19,679
knowledge

681
00:25:19,679 --> 00:25:21,440
thanks for your attention and we'd be

682
00:25:21,440 --> 00:25:22,880
happy to answer all your questions

683
00:25:22,880 --> 00:25:24,880
during the live presentation on august

684
00:25:24,880 --> 00:25:27,880
17th

