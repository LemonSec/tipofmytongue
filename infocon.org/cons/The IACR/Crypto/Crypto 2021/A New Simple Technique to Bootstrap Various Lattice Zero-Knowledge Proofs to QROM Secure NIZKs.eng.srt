1
00:00:01,599 --> 00:00:03,760
this is a paper on a new simple

2
00:00:03,760 --> 00:00:05,440
technique to boost strabara's lattice

3
00:00:05,440 --> 00:00:07,120
zero knowledge proofs to cure obscure

4
00:00:07,120 --> 00:00:08,639
and iz case

5
00:00:08,639 --> 00:00:12,559
my name is shu and i'm from ice

6
00:00:13,920 --> 00:00:15,679
so this is our result

7
00:00:15,679 --> 00:00:18,000
we provide a simple semi-generic method

8
00:00:18,000 --> 00:00:20,240
to construct qram security space zero

9
00:00:20,240 --> 00:00:22,320
knowledge proofs

10
00:00:22,320 --> 00:00:24,720
the new technical tool that we develop

11
00:00:24,720 --> 00:00:26,560
is an extractable linear homomorphic

12
00:00:26,560 --> 00:00:29,039
commitment which i might just call

13
00:00:29,039 --> 00:00:32,240
extractable lin hc

14
00:00:32,558 --> 00:00:34,640
what i mean by this semi-generic is that

15
00:00:34,640 --> 00:00:37,040
doesn't work for any sigma protocol or

16
00:00:37,040 --> 00:00:39,200
public contracted protocol but only

17
00:00:39,200 --> 00:00:41,440
works for this limited class that has a

18
00:00:41,440 --> 00:00:43,200
linear response

19
00:00:43,200 --> 00:00:45,120
but this is very natural and it's

20
00:00:45,120 --> 00:00:47,920
satisfied by a lot of ladder space uh

21
00:00:47,920 --> 00:00:50,000
public coin interrupt protocols so

22
00:00:50,000 --> 00:00:52,000
starting from this we can apply our

23
00:00:52,000 --> 00:00:54,640
linear extractable linear ac

24
00:00:54,640 --> 00:00:55,760
and then

25
00:00:55,760 --> 00:00:58,559
obtain a qram secure nizk which is also

26
00:00:58,559 --> 00:01:03,440
an online extractable proof of knowledge

27
00:01:04,319 --> 00:01:06,320
let me first provide the background and

28
00:01:06,320 --> 00:01:08,960
motivation

29
00:01:09,439 --> 00:01:11,119
so in this talk we'll be considering

30
00:01:11,119 --> 00:01:14,960
non-network zero knowledge uh niz case

31
00:01:14,960 --> 00:01:16,799
in an nick

32
00:01:16,799 --> 00:01:18,479
there's going to be a statement x that's

33
00:01:18,479 --> 00:01:20,720
in this language l and

34
00:01:20,720 --> 00:01:23,200
any prover that holds a valid witness w

35
00:01:23,200 --> 00:01:25,360
for the statement x shall be able to

36
00:01:25,360 --> 00:01:27,680
construct a proof pi

37
00:01:27,680 --> 00:01:30,079
and this proof pi will convince to the

38
00:01:30,079 --> 00:01:32,400
verifier that this prover knew this

39
00:01:32,400 --> 00:01:35,040
witness w

40
00:01:35,200 --> 00:01:36,400
there's going to be two security

41
00:01:36,400 --> 00:01:40,079
properties that we require

42
00:01:40,079 --> 00:01:42,640
so one property is zero knowledge

43
00:01:42,640 --> 00:01:44,479
and this states that for a cheating

44
00:01:44,479 --> 00:01:48,720
jitting verifier given this proof pie

45
00:01:48,720 --> 00:01:50,799
this proof pie leaks no information

46
00:01:50,799 --> 00:01:52,560
about this witness w

47
00:01:52,560 --> 00:01:53,840
and the only thing that the cheating

48
00:01:53,840 --> 00:01:55,520
verifier gets to know is that the

49
00:01:55,520 --> 00:01:57,600
statement x was actually in the language

50
00:01:57,600 --> 00:02:00,000
or not

51
00:02:00,799 --> 00:02:03,200
we also want to consider a secure notion

52
00:02:03,200 --> 00:02:05,680
for cheat improvers and we'll be talking

53
00:02:05,680 --> 00:02:07,600
about proof of knowledge in this work

54
00:02:07,600 --> 00:02:09,679
which is uh strictly stronger than

55
00:02:09,679 --> 00:02:10,878
soundness

56
00:02:10,878 --> 00:02:12,800
so what this tells us is that there's

57
00:02:12,800 --> 00:02:15,360
going to be an extractor

58
00:02:15,360 --> 00:02:16,959
such that

59
00:02:16,959 --> 00:02:18,480
for any cheating perimeter that outputs

60
00:02:18,480 --> 00:02:21,440
a valid proof of pi it's able to extract

61
00:02:21,440 --> 00:02:24,480
a valid witness w that satisfies this

62
00:02:24,480 --> 00:02:27,200
type of relation

63
00:02:27,200 --> 00:02:30,239
and this implicitly implies soundness

64
00:02:30,239 --> 00:02:33,599
because uh if this proof pi

65
00:02:33,599 --> 00:02:37,519
can be used to extracted witness w

66
00:02:37,519 --> 00:02:39,920
then it means that the statement x was

67
00:02:39,920 --> 00:02:42,958
actually in this language

68
00:02:44,239 --> 00:02:46,160
in this work we'll be considering nick

69
00:02:46,160 --> 00:02:48,239
k's in the random oracle model

70
00:02:48,239 --> 00:02:50,879
and in the rom uh all the users in the

71
00:02:50,879 --> 00:02:52,800
system the approver or the verifier

72
00:02:52,800 --> 00:02:54,160
they're going to have access to the

73
00:02:54,160 --> 00:02:56,800
random oracle

74
00:02:56,800 --> 00:02:57,760
and

75
00:02:57,760 --> 00:03:00,080
nsd case in the random oracle model is

76
00:03:00,080 --> 00:03:02,080
heuristic to some extent because it can

77
00:03:02,080 --> 00:03:04,080
only be secure it can be only proven

78
00:03:04,080 --> 00:03:05,920
secure in the random oracle model but

79
00:03:05,920 --> 00:03:07,680
this is typically fine in practice

80
00:03:07,680 --> 00:03:09,200
because this results in the most

81
00:03:09,200 --> 00:03:12,720
efficient and practical schemes

82
00:03:13,120 --> 00:03:15,120
so there's two types of rom that we can

83
00:03:15,120 --> 00:03:16,480
think of

84
00:03:16,480 --> 00:03:19,040
so if we have a quantum adversary

85
00:03:19,040 --> 00:03:21,200
then this quantum energy can evaluate

86
00:03:21,200 --> 00:03:23,120
real world hash functions over qubits in

87
00:03:23,120 --> 00:03:25,680
the real world in the real world

88
00:03:25,680 --> 00:03:26,799
so

89
00:03:26,799 --> 00:03:28,799
we want this qram to model this

90
00:03:28,799 --> 00:03:30,640
capability as well

91
00:03:30,640 --> 00:03:32,319
so while in the classical rom it only

92
00:03:32,319 --> 00:03:34,159
made classical inputs and receive

93
00:03:34,159 --> 00:03:36,959
classical outputs and the quantum rom

94
00:03:36,959 --> 00:03:39,519
will allow this adversary to query

95
00:03:39,519 --> 00:03:41,519
inputs and superpositions

96
00:03:41,519 --> 00:03:44,560
and receive outputs in superposition as

97
00:03:44,560 --> 00:03:46,879
well

98
00:03:46,879 --> 00:03:48,879
and this creates a lot of difficulties

99
00:03:48,879 --> 00:03:50,799
in the proof of q roms

100
00:03:50,799 --> 00:03:52,720
so there are a lot of

101
00:03:52,720 --> 00:03:54,480
proof techniques in the classical rom

102
00:03:54,480 --> 00:03:56,319
that we take for granted which seems

103
00:03:56,319 --> 00:03:58,959
hard to import to the qram setting

104
00:03:58,959 --> 00:04:00,959
the first two are observing the

105
00:04:00,959 --> 00:04:03,760
adversary's input query and also knowing

106
00:04:03,760 --> 00:04:05,920
what this corresponding output was with

107
00:04:05,920 --> 00:04:08,640
respect to this input query

108
00:04:08,640 --> 00:04:10,480
and why is this difficult

109
00:04:10,480 --> 00:04:12,400
so the reason is is that since these are

110
00:04:12,400 --> 00:04:15,200
in superposition if we measure it it

111
00:04:15,200 --> 00:04:18,238
will collapse to a single state

112
00:04:18,238 --> 00:04:20,478
and if these input and output queries

113
00:04:20,478 --> 00:04:22,560
were entangled with the quantum

114
00:04:22,560 --> 00:04:25,120
state of this adversary then measurement

115
00:04:25,120 --> 00:04:27,600
might disturb the adversary's states so

116
00:04:27,600 --> 00:04:30,080
the adversary might actually notice that

117
00:04:30,080 --> 00:04:33,040
it was being measured in the qrom

118
00:04:33,040 --> 00:04:34,160
and this doesn't show up in the

119
00:04:34,160 --> 00:04:35,280
classical setting because in the

120
00:04:35,280 --> 00:04:37,199
classical setting we just write proof

121
00:04:37,199 --> 00:04:40,639
saying that the adversary outputs and

122
00:04:40,639 --> 00:04:43,120
outputs x to the random article

123
00:04:43,120 --> 00:04:46,160
we sample random y so we know these x

124
00:04:46,160 --> 00:04:48,880
values and y values definitely

125
00:04:48,880 --> 00:04:51,199
but in the quantum setting this is a bit

126
00:04:51,199 --> 00:04:53,680
difficult

127
00:04:54,000 --> 00:04:56,400
also another issue is adaptively

128
00:04:56,400 --> 00:04:58,720
programming the random article

129
00:04:58,720 --> 00:05:00,960
and this is because the quantum

130
00:05:00,960 --> 00:05:02,080
adversary

131
00:05:02,080 --> 00:05:04,080
may query all the inputs in

132
00:05:04,080 --> 00:05:07,280
superposition to the random oracle so

133
00:05:07,280 --> 00:05:09,919
at that point it seems as though the

134
00:05:09,919 --> 00:05:11,919
random article is going to be defined on

135
00:05:11,919 --> 00:05:13,360
all outputs

136
00:05:13,360 --> 00:05:15,600
meaning that there's not going to be any

137
00:05:15,600 --> 00:05:17,919
notion of adaptively programmed the

138
00:05:17,919 --> 00:05:20,880
random oracle while the game trends

139
00:05:20,880 --> 00:05:23,880
transcends

140
00:05:26,639 --> 00:05:28,720
and uh these three uh seemingly very

141
00:05:28,720 --> 00:05:31,440
difficult problem uh nowadays well the

142
00:05:31,440 --> 00:05:33,440
past two or three years there's been a

143
00:05:33,440 --> 00:05:35,600
lot of work regarding this so we now

144
00:05:35,600 --> 00:05:37,600
know uh many ways to overcome these

145
00:05:37,600 --> 00:05:40,479
seemingly difficult uh problems

146
00:05:40,479 --> 00:05:41,520
however

147
00:05:41,520 --> 00:05:43,440
uh they do not come for free as in the

148
00:05:43,440 --> 00:05:45,199
classical realm setting and it requires

149
00:05:45,199 --> 00:05:48,320
a lot of complications and sometimes

150
00:05:48,320 --> 00:05:49,120
it's

151
00:05:49,120 --> 00:05:51,120
there are still um

152
00:05:51,120 --> 00:05:52,800
really difficult things that we have to

153
00:05:52,800 --> 00:05:55,280
overcome

154
00:05:56,319 --> 00:05:58,240
so that was the issue about whether

155
00:05:58,240 --> 00:06:00,240
we're talking about classical or quantum

156
00:06:00,240 --> 00:06:02,800
realm but there's actually difficulty

157
00:06:02,800 --> 00:06:05,919
just in using quantum adversaries

158
00:06:05,919 --> 00:06:07,840
regardless of this rom being classical

159
00:06:07,840 --> 00:06:09,600
or quantum

160
00:06:09,600 --> 00:06:12,479
and one representative example is

161
00:06:12,479 --> 00:06:15,520
rewinding type of arguments

162
00:06:15,520 --> 00:06:18,319
this is a type of proof where we

163
00:06:18,319 --> 00:06:20,639
fix a randomness r for this adversary

164
00:06:20,639 --> 00:06:22,400
and we run the reduction while the

165
00:06:22,400 --> 00:06:24,479
reduction algorithm um

166
00:06:24,479 --> 00:06:26,720
programs the random oracle up to this

167
00:06:26,720 --> 00:06:27,759
point

168
00:06:27,759 --> 00:06:29,919
well it proves the random oracle

169
00:06:29,919 --> 00:06:33,039
and what we do is that we will

170
00:06:33,039 --> 00:06:35,680
rewind adversary to some point let's say

171
00:06:35,680 --> 00:06:39,280
to this queer x prime

172
00:06:39,440 --> 00:06:42,400
and we will reprogram the random article

173
00:06:42,400 --> 00:06:44,720
on this

174
00:06:44,720 --> 00:06:46,960
x prime and from that point on we run

175
00:06:46,960 --> 00:06:48,400
the adversary again on the same

176
00:06:48,400 --> 00:06:51,120
randomness r so rewind the adversary and

177
00:06:51,120 --> 00:06:53,919
we rerun it

178
00:06:54,639 --> 00:06:56,960
and the issue the the issue of this in

179
00:06:56,960 --> 00:06:58,240
the quantum setting is that there's no

180
00:06:58,240 --> 00:07:00,560
notion of fixed randomness so

181
00:07:00,560 --> 00:07:02,960
this general technique

182
00:07:02,960 --> 00:07:04,639
might not really work in the quantum

183
00:07:04,639 --> 00:07:06,960
setting

184
00:07:08,880 --> 00:07:10,960
and now let me explain a bit more about

185
00:07:10,960 --> 00:07:13,280
lattice-based qram and izks and how we

186
00:07:13,280 --> 00:07:16,319
construct them

187
00:07:16,319 --> 00:07:18,319
all the niz case that will be mentioning

188
00:07:18,319 --> 00:07:20,080
this work will start from a sigma

189
00:07:20,080 --> 00:07:22,479
protocol or in more general a public

190
00:07:22,479 --> 00:07:26,080
coin interactive proof system

191
00:07:26,319 --> 00:07:29,039
if we focus on sigma protocols it's very

192
00:07:29,039 --> 00:07:30,960
standard to define two notions honest

193
00:07:30,960 --> 00:07:32,560
verifiers are knowledge and special

194
00:07:32,560 --> 00:07:33,599
sounds

195
00:07:33,599 --> 00:07:35,039
where special soundness is very

196
00:07:35,039 --> 00:07:36,479
interesting because

197
00:07:36,479 --> 00:07:39,840
um it states that given two two valid

198
00:07:39,840 --> 00:07:43,120
transcripts with the same a

199
00:07:43,120 --> 00:07:44,800
first flow

200
00:07:44,800 --> 00:07:46,639
there is an efficient way to extract the

201
00:07:46,639 --> 00:07:49,280
witness w

202
00:07:50,639 --> 00:07:52,639
let me explain two famous ways to

203
00:07:52,639 --> 00:07:57,039
convert a sigma protocol into an izk

204
00:07:57,039 --> 00:07:58,479
the first one is the fiaschemia

205
00:07:58,479 --> 00:08:01,120
transform and in the classical setting

206
00:08:01,120 --> 00:08:02,639
this is excellent because it works for

207
00:08:02,639 --> 00:08:04,879
any type of sigma protocol and the proof

208
00:08:04,879 --> 00:08:06,960
overhead is minimal

209
00:08:06,960 --> 00:08:07,759
uh

210
00:08:07,759 --> 00:08:08,639
one

211
00:08:08,639 --> 00:08:10,240
relatively small downside is that the

212
00:08:10,240 --> 00:08:12,160
proof of knowledge it requires rewinding

213
00:08:12,160 --> 00:08:14,080
so it does incur

214
00:08:14,080 --> 00:08:17,280
a reduction loss

215
00:08:17,520 --> 00:08:19,599
there's also the owner transform which

216
00:08:19,599 --> 00:08:21,280
was originally created for this quantum

217
00:08:21,280 --> 00:08:23,520
setting which i'll explain later but uh

218
00:08:23,520 --> 00:08:25,360
i it works for the classical setting as

219
00:08:25,360 --> 00:08:27,759
well and it works again for any sigma

220
00:08:27,759 --> 00:08:29,680
protocol but we have to restrict the

221
00:08:29,680 --> 00:08:32,000
challenge set to be small

222
00:08:32,000 --> 00:08:34,080
and due to this we require a lot of

223
00:08:34,080 --> 00:08:36,240
power repetitions and we also have to

224
00:08:36,240 --> 00:08:38,080
include a lot of garbage terms to make

225
00:08:38,080 --> 00:08:41,120
their own transform work where this c is

226
00:08:41,120 --> 00:08:42,958
the size of this challenge space so the

227
00:08:42,958 --> 00:08:45,040
there's going to be a lot blow to blow

228
00:08:45,040 --> 00:08:47,279
up here

229
00:08:47,279 --> 00:08:48,399
the good thing is that the proof of

230
00:08:48,399 --> 00:08:52,000
knowledge is straight line extractable

231
00:08:52,000 --> 00:08:54,080
so it results in a tighter proof it

232
00:08:54,080 --> 00:08:57,519
doesn't require rewinding

233
00:08:59,200 --> 00:09:01,040
but uh still the general rule of thumb i

234
00:09:01,040 --> 00:09:02,480
guess in the classical setting is that

235
00:09:02,480 --> 00:09:03,680
we want to work with a fisherman

236
00:09:03,680 --> 00:09:05,440
transform because it's

237
00:09:05,440 --> 00:09:07,279
uh it's just really good

238
00:09:07,279 --> 00:09:09,120
and earnest transform

239
00:09:09,120 --> 00:09:10,959
the overhead is quite big when the

240
00:09:10,959 --> 00:09:12,320
challenge said

241
00:09:12,320 --> 00:09:15,040
the original sigma protocol can have

242
00:09:15,040 --> 00:09:16,880
challenge set that's as large as

243
00:09:16,880 --> 00:09:18,480
exponential

244
00:09:18,480 --> 00:09:20,399
however if it's

245
00:09:20,399 --> 00:09:22,320
if it only is capable of using small

246
00:09:22,320 --> 00:09:24,160
challenge set to begin with then

247
00:09:24,160 --> 00:09:25,920
sometimes earned transform is

248
00:09:25,920 --> 00:09:28,800
competitive too

249
00:09:28,800 --> 00:09:30,720
the situation the quantum setting is a

250
00:09:30,720 --> 00:09:31,920
bit different

251
00:09:31,920 --> 00:09:33,519
so the fischer mirror transform no

252
00:09:33,519 --> 00:09:35,839
longer works for any sigma protocol but

253
00:09:35,839 --> 00:09:37,839
only works for a class called collapsing

254
00:09:37,839 --> 00:09:40,399
sigma protocols

255
00:09:40,399 --> 00:09:43,040
also the proof of knowledge it works but

256
00:09:43,040 --> 00:09:45,279
uh through rewinding but there's going

257
00:09:45,279 --> 00:09:46,959
to be a lot of

258
00:09:46,959 --> 00:09:48,800
small subtleties that we have to take

259
00:09:48,800 --> 00:09:50,640
care of and uh technical issues that we

260
00:09:50,640 --> 00:09:52,080
have to take care of

261
00:09:52,080 --> 00:09:53,519
and they will lose a bit more in the

262
00:09:53,519 --> 00:09:55,680
reduction law reduction compared to

263
00:09:55,680 --> 00:09:58,000
classical setting

264
00:09:58,000 --> 00:09:59,760
compared to this the under transform

265
00:09:59,760 --> 00:10:01,760
it's much better because

266
00:10:01,760 --> 00:10:03,760
it's basically the same argument that we

267
00:10:03,760 --> 00:10:05,839
would make in the classical settings

268
00:10:05,839 --> 00:10:06,690
so it just

269
00:10:06,690 --> 00:10:09,040
[Music]

270
00:10:09,040 --> 00:10:12,800
it's very similar and easy

271
00:10:14,240 --> 00:10:16,880
so the obvious downside now is that not

272
00:10:16,880 --> 00:10:18,640
all existing sim protocol are known to

273
00:10:18,640 --> 00:10:20,480
be collapsing so we have to show that

274
00:10:20,480 --> 00:10:22,480
it's collapsing and this is not

275
00:10:22,480 --> 00:10:26,079
this is sometimes very tricky i guess

276
00:10:26,079 --> 00:10:28,320
so the good thing about unruh is that

277
00:10:28,320 --> 00:10:30,000
if we can show in the classical setting

278
00:10:30,000 --> 00:10:32,959
then it also will work

279
00:10:32,959 --> 00:10:34,560
fine in the quantum setting too so it's

280
00:10:34,560 --> 00:10:37,920
very easy to analyze

281
00:10:40,000 --> 00:10:42,160
um for general two n plus one random

282
00:10:42,160 --> 00:10:44,640
pcips uh the situation for the phase

283
00:10:44,640 --> 00:10:46,800
human transform the same but the under

284
00:10:46,800 --> 00:10:48,480
transform it's a bit different it

285
00:10:48,480 --> 00:10:50,640
doesn't work for any two n plus one but

286
00:10:50,640 --> 00:10:52,880
it only works for five round protocols

287
00:10:52,880 --> 00:10:55,839
with a specific type of challenge sets

288
00:10:55,839 --> 00:10:56,800
and here

289
00:10:56,800 --> 00:10:58,959
this might be able to be expanded to

290
00:10:58,959 --> 00:11:01,040
multi-rounds but uh we don't know of

291
00:11:01,040 --> 00:11:03,440
this yet

292
00:11:03,440 --> 00:11:06,079
let me talk a bit more about

293
00:11:06,079 --> 00:11:08,880
this qram security assignment transform

294
00:11:08,880 --> 00:11:11,040
so this was shown by these two groups in

295
00:11:11,040 --> 00:11:13,600
2019

296
00:11:13,600 --> 00:11:15,360
and they start with a collapsing sigma

297
00:11:15,360 --> 00:11:17,279
protocol

298
00:11:17,279 --> 00:11:20,240
and they first argue using a rewinding

299
00:11:20,240 --> 00:11:23,200
argument that this can be transformed

300
00:11:23,200 --> 00:11:24,800
into a sigma protocol with a quantum

301
00:11:24,800 --> 00:11:26,800
proof of knowledge where basically this

302
00:11:26,800 --> 00:11:28,560
is a sigma protocol with a proof of

303
00:11:28,560 --> 00:11:29,519
knowledge

304
00:11:29,519 --> 00:11:32,560
where the adversary is also a quantum

305
00:11:32,560 --> 00:11:34,880
adversary

306
00:11:34,880 --> 00:11:37,600
and in the second step they argued using

307
00:11:37,600 --> 00:11:40,079
a new reprogram technique to show that

308
00:11:40,079 --> 00:11:42,480
the theochemic transform applies and it

309
00:11:42,480 --> 00:11:44,800
constructs the cure on securing izkai

310
00:11:44,800 --> 00:11:48,319
so this is the two step that they took

311
00:11:49,920 --> 00:11:51,839
and the thing is uh

312
00:11:51,839 --> 00:11:53,440
it's really not clear if all these

313
00:11:53,440 --> 00:11:56,160
existing schemes are collapsing so this

314
00:11:56,160 --> 00:11:59,839
part is the difficult part now

315
00:11:59,839 --> 00:12:02,399
and also this reprogramming step most of

316
00:12:02,399 --> 00:12:04,240
the times it will incurred

317
00:12:04,240 --> 00:12:06,320
reduction loss

318
00:12:06,320 --> 00:12:10,519
a bit more than a classical setting

319
00:12:14,240 --> 00:12:16,240
so let me explain a bit about the recent

320
00:12:16,240 --> 00:12:18,639
uh ladder space pcips in the classical

321
00:12:18,639 --> 00:12:20,079
rom setting

322
00:12:20,079 --> 00:12:21,920
so i only talk about the fischer mirror

323
00:12:21,920 --> 00:12:23,920
with abort types of signal protocol so i

324
00:12:23,920 --> 00:12:25,279
won't be talking about the stern type

325
00:12:25,279 --> 00:12:28,320
protocol in this line

326
00:12:29,040 --> 00:12:31,200
so the most basic one is the original

327
00:12:31,200 --> 00:12:34,240
liboshevsky 09012 paper which provided

328
00:12:34,240 --> 00:12:36,839
relaxed proof for sis and lw

329
00:12:36,839 --> 00:12:39,839
relations and interestingly the two

330
00:12:39,839 --> 00:12:40,880
papers

331
00:12:40,880 --> 00:12:43,360
show that this is a collapsing sigma

332
00:12:43,360 --> 00:12:45,360
protocol as well with a slight increase

333
00:12:45,360 --> 00:12:47,279
in the parameters

334
00:12:47,279 --> 00:12:49,760
so we know how to apply the fiesta

335
00:12:49,760 --> 00:12:51,760
mirror transform securely in the qram

336
00:12:51,760 --> 00:12:52,720
setting

337
00:12:52,720 --> 00:12:57,120
for these very basic sigma protocols

338
00:12:57,120 --> 00:12:59,120
for the more recent ones like opening to

339
00:12:59,120 --> 00:13:01,040
commitments range proofs one of many

340
00:13:01,040 --> 00:13:03,200
proofs we don't know if these are

341
00:13:03,200 --> 00:13:05,279
collapsing sigma protocols

342
00:13:05,279 --> 00:13:06,959
so we don't know how to apply the schmer

343
00:13:06,959 --> 00:13:08,320
transform

344
00:13:08,320 --> 00:13:09,839
but we do know how to apply the under

345
00:13:09,839 --> 00:13:11,760
transform because it's still a sigma

346
00:13:11,760 --> 00:13:12,800
protocol

347
00:13:12,800 --> 00:13:16,079
the caveat is that these schemes

348
00:13:16,079 --> 00:13:17,920
can use exponentially large challenge

349
00:13:17,920 --> 00:13:18,720
set

350
00:13:18,720 --> 00:13:20,240
but we have to restrict them to be

351
00:13:20,240 --> 00:13:22,160
polynomial size or even smaller than

352
00:13:22,160 --> 00:13:22,880
that

353
00:13:22,880 --> 00:13:26,320
to make lunar transform work

354
00:13:26,959 --> 00:13:28,480
so there's going to be a large blow up

355
00:13:28,480 --> 00:13:29,680
here

356
00:13:29,680 --> 00:13:31,760
compared to the classical ones

357
00:13:31,760 --> 00:13:34,079
and finally there are these new five

358
00:13:34,079 --> 00:13:36,079
round schemes or even larger than five

359
00:13:36,079 --> 00:13:38,000
round schemes where we don't know how to

360
00:13:38,000 --> 00:13:40,000
apply the fiat scheme or under transform

361
00:13:40,000 --> 00:13:41,120
at all

362
00:13:41,120 --> 00:13:43,040
i would know that this modified earner

363
00:13:43,040 --> 00:13:45,040
transform for the five round protocol

364
00:13:45,040 --> 00:13:46,639
might work but

365
00:13:46,639 --> 00:13:48,079
there are a lot of details that we have

366
00:13:48,079 --> 00:13:50,399
to check to really know for sure if it

367
00:13:50,399 --> 00:13:52,480
works or not

368
00:13:52,480 --> 00:13:55,920
so this is the current situation

369
00:13:55,920 --> 00:13:57,760
and this brings us to our main question

370
00:13:57,760 --> 00:13:59,839
of this talk which is can we get the

371
00:13:59,839 --> 00:14:01,760
best of the fishermen and urine

372
00:14:01,760 --> 00:14:04,320
transform and even a bit more

373
00:14:04,320 --> 00:14:06,399
so the fish might transform it requires

374
00:14:06,399 --> 00:14:08,160
no overhead and it works for

375
00:14:08,160 --> 00:14:11,279
exponentially large challenge set size

376
00:14:11,279 --> 00:14:14,480
under it works for any sigma protocol

377
00:14:14,480 --> 00:14:15,760
and it has a

378
00:14:15,760 --> 00:14:17,920
tight reduction which is a straight line

379
00:14:17,920 --> 00:14:21,519
extractable uh proof of knowledge

380
00:14:21,519 --> 00:14:23,519
however uh there are these schemes that

381
00:14:23,519 --> 00:14:26,079
are not covered by fiesta mayor or under

382
00:14:26,079 --> 00:14:28,079
so it will be interesting to see if

383
00:14:28,079 --> 00:14:29,279
there are

384
00:14:29,279 --> 00:14:32,030
other transforms that covers

385
00:14:32,030 --> 00:14:33,360
[Music]

386
00:14:33,360 --> 00:14:35,360
protocols that lie outside of these two

387
00:14:35,360 --> 00:14:37,760
schemes

388
00:14:38,560 --> 00:14:42,560
and this brings us to our result

389
00:14:43,440 --> 00:14:46,320
so our result is a new transform

390
00:14:46,320 --> 00:14:48,079
uh that provides a partial answer to the

391
00:14:48,079 --> 00:14:50,320
previous question it's a semi-generic

392
00:14:50,320 --> 00:14:51,680
approach that says somewhere between

393
00:14:51,680 --> 00:14:53,839
fishermen and unrule

394
00:14:53,839 --> 00:14:55,519
so these are the properties and the

395
00:14:55,519 --> 00:14:56,880
first one is that it works for many

396
00:14:56,880 --> 00:14:59,440
lattice-based pcips or in general any

397
00:14:59,440 --> 00:15:01,760
pcip with a linear response where this

398
00:15:01,760 --> 00:15:03,120
notion will become clear in the later

399
00:15:03,120 --> 00:15:04,959
slides

400
00:15:04,959 --> 00:15:07,440
the overhead of our transform is larger

401
00:15:07,440 --> 00:15:10,240
than the fishermen transform while it's

402
00:15:10,240 --> 00:15:12,320
much smaller than the owner transform

403
00:15:12,320 --> 00:15:14,000
when the challenge set size is

404
00:15:14,000 --> 00:15:16,079
exponentially large which is the case

405
00:15:16,079 --> 00:15:17,920
for many of these ladder space pcie

406
00:15:17,920 --> 00:15:20,480
protocols

407
00:15:20,480 --> 00:15:21,920
the reduction loss is smaller than

408
00:15:21,920 --> 00:15:23,920
fiaschemir since it's a straight line

409
00:15:23,920 --> 00:15:27,680
extractable proof like in room

410
00:15:27,680 --> 00:15:30,079
and our security proof is very simple

411
00:15:30,079 --> 00:15:32,480
and it's almost very classical so

412
00:15:32,480 --> 00:15:34,399
it requires minimal knowledge and

413
00:15:34,399 --> 00:15:36,720
quantum computation

414
00:15:36,720 --> 00:15:39,360
and finally it works for peace ips where

415
00:15:39,360 --> 00:15:43,360
and undue are not yet known to work

416
00:15:44,480 --> 00:15:46,399
the new technical tool that we develop

417
00:15:46,399 --> 00:15:47,839
in this work is called extractable

418
00:15:47,839 --> 00:15:50,160
linear homomorphic commitment

419
00:15:50,160 --> 00:15:53,360
and with using this extract boolean hc

420
00:15:53,360 --> 00:15:55,600
we can start from any sigma protocol

421
00:15:55,600 --> 00:15:57,279
with a linear response

422
00:15:57,279 --> 00:15:59,120
and this is a very natural

423
00:15:59,120 --> 00:16:01,199
sigma protocol and is satisfied by many

424
00:16:01,199 --> 00:16:04,079
sigma protocols

425
00:16:04,240 --> 00:16:05,120
here

426
00:16:05,120 --> 00:16:07,519
if we start from this primitive we can

427
00:16:07,519 --> 00:16:10,320
combine with an extractable linear ac

428
00:16:10,320 --> 00:16:12,480
and bypass this rewinding argument to

429
00:16:12,480 --> 00:16:14,079
directly get a

430
00:16:14,079 --> 00:16:15,759
sigma protocol with quantum proof of

431
00:16:15,759 --> 00:16:18,000
knowledge and then we can use prior

432
00:16:18,000 --> 00:16:19,680
reprogramming techniques to get a qram

433
00:16:19,680 --> 00:16:22,480
secure nizk

434
00:16:22,480 --> 00:16:23,920
or

435
00:16:23,920 --> 00:16:26,079
this is a simplified extractable linear

436
00:16:26,079 --> 00:16:29,360
hc but if we start with a more

437
00:16:29,360 --> 00:16:31,600
structured extractable linear hc which

438
00:16:31,600 --> 00:16:34,240
is not that different

439
00:16:34,240 --> 00:16:36,320
we can directly get to this qram

440
00:16:36,320 --> 00:16:38,399
security and idk without even having

441
00:16:38,399 --> 00:16:40,240
this reprogramming technique so this

442
00:16:40,240 --> 00:16:42,240
will provide us the most tightest and

443
00:16:42,240 --> 00:16:44,320
its simplest um

444
00:16:44,320 --> 00:16:46,959
transformer if we want an ic king

445
00:16:46,959 --> 00:16:48,320
if we only want a quantum proof of

446
00:16:48,320 --> 00:16:49,680
knowledge then we can just use this

447
00:16:49,680 --> 00:16:52,160
transform

448
00:16:53,199 --> 00:16:55,440
we will explain our idea in a bottom-up

449
00:16:55,440 --> 00:16:57,920
approach so we'll start from this very

450
00:16:57,920 --> 00:17:00,320
base example which is a signal protocol

451
00:17:00,320 --> 00:17:02,399
for the sis or lw relation by

452
00:17:02,399 --> 00:17:04,720
lukaszewski so this will be a scheme

453
00:17:04,720 --> 00:17:07,199
that's scary in the classical rom

454
00:17:07,199 --> 00:17:09,439
here we have two mate one matrix a and a

455
00:17:09,439 --> 00:17:11,439
vector u and the witness is going to be

456
00:17:11,439 --> 00:17:13,359
a short vector e satisfying this

457
00:17:13,359 --> 00:17:15,839
relation

458
00:17:17,039 --> 00:17:19,839
the proverb will sample a short vector r

459
00:17:19,839 --> 00:17:21,359
from some distribution let's say a

460
00:17:21,359 --> 00:17:23,359
gaussian distribution and create this

461
00:17:23,359 --> 00:17:24,799
vector w

462
00:17:24,799 --> 00:17:27,919
and sends it to the verifier

463
00:17:27,919 --> 00:17:31,200
the verifier sample is a short

464
00:17:31,200 --> 00:17:33,120
element from this rq

465
00:17:33,120 --> 00:17:35,760
and sends it to the prover the prover

466
00:17:35,760 --> 00:17:39,760
sets z as c times e plus r and uh

467
00:17:39,760 --> 00:17:41,679
it will do this rejection sampling step

468
00:17:41,679 --> 00:17:42,880
which is not really important for this

469
00:17:42,880 --> 00:17:44,960
talk to maintain the shortness of z

470
00:17:44,960 --> 00:17:48,880
without revealing the witness e

471
00:17:49,600 --> 00:17:51,520
it will then send this z

472
00:17:51,520 --> 00:17:53,760
and the verifier will just check that z

473
00:17:53,760 --> 00:17:56,640
is short and this equation holds so

474
00:17:56,640 --> 00:17:59,120
basically this is schnorr's protocol but

475
00:17:59,120 --> 00:18:02,239
using lattice language

476
00:18:02,640 --> 00:18:04,559
the main question here is that to

477
00:18:04,559 --> 00:18:06,080
eventually show proof of knowledge of

478
00:18:06,080 --> 00:18:08,880
the fiat schemer nizk we want to extract

479
00:18:08,880 --> 00:18:12,720
a witness from a single transcript

480
00:18:12,799 --> 00:18:15,200
but in order to invoke this special

481
00:18:15,200 --> 00:18:17,200
soundness of this sigma protocol we need

482
00:18:17,200 --> 00:18:19,440
two transcripts

483
00:18:19,440 --> 00:18:22,559
and the question is how to obtain these

484
00:18:22,559 --> 00:18:27,879
two valid transcripts without rewinding

485
00:18:29,919 --> 00:18:32,080
so this is the first step we add a

486
00:18:32,080 --> 00:18:34,799
linear homomorphic commitment

487
00:18:34,799 --> 00:18:36,880
so when the prover

488
00:18:36,880 --> 00:18:39,039
computes this w

489
00:18:39,039 --> 00:18:40,720
first flow w

490
00:18:40,720 --> 00:18:42,400
we'll also commit

491
00:18:42,400 --> 00:18:44,080
to the witness e

492
00:18:44,080 --> 00:18:46,480
and to the randomness r

493
00:18:46,480 --> 00:18:48,640
and we'll send this commitment come a

494
00:18:48,640 --> 00:18:51,120
income r to the verifier

495
00:18:51,120 --> 00:18:53,280
the verifiable sample challenge c and

496
00:18:53,280 --> 00:18:55,520
sends it to the progress before and now

497
00:18:55,520 --> 00:18:58,640
the prover will set the z which is

498
00:18:58,640 --> 00:19:00,240
when you look at it here it's a linearly

499
00:19:00,240 --> 00:19:02,400
homophobic operation over this e and r

500
00:19:02,400 --> 00:19:04,160
the committed messages

501
00:19:04,160 --> 00:19:06,080
and it will also do the same for this

502
00:19:06,080 --> 00:19:08,320
committed randomness now so it will

503
00:19:08,320 --> 00:19:10,880
create a delta z randomness from the

504
00:19:10,880 --> 00:19:14,240
delta e and delta r

505
00:19:14,880 --> 00:19:16,960
and the prover will send this delta z to

506
00:19:16,960 --> 00:19:18,880
the verifier what does the verifier do

507
00:19:18,880 --> 00:19:21,600
so it does the normal checks and it also

508
00:19:21,600 --> 00:19:23,600
checks that this

509
00:19:23,600 --> 00:19:25,840
commitment

510
00:19:25,840 --> 00:19:27,120
uh

511
00:19:27,120 --> 00:19:30,480
com e income r was constructed correctly

512
00:19:30,480 --> 00:19:33,120
using this z

513
00:19:33,120 --> 00:19:36,959
the z and the opening delta z

514
00:19:37,200 --> 00:19:39,120
so if this equation holds then the

515
00:19:39,120 --> 00:19:40,960
verifier will accept and this is

516
00:19:40,960 --> 00:19:42,799
implicitly checking that this commitment

517
00:19:42,799 --> 00:19:46,960
two commitments were created honestly

518
00:19:48,000 --> 00:19:49,840
and this is still standard sigma

519
00:19:49,840 --> 00:19:50,880
protocol

520
00:19:50,880 --> 00:19:53,200
because uh if this commitment is let's

521
00:19:53,200 --> 00:19:54,960
say hiding then

522
00:19:54,960 --> 00:19:56,720
we have honest verifier zero knowledge

523
00:19:56,720 --> 00:19:59,280
and special soundness we just can ignore

524
00:19:59,280 --> 00:20:01,840
these purple elements and we just invoke

525
00:20:01,840 --> 00:20:03,760
it using

526
00:20:03,760 --> 00:20:07,480
the base sigma protocol

527
00:20:09,600 --> 00:20:11,360
so right now it doesn't provide us

528
00:20:11,360 --> 00:20:12,559
anything new

529
00:20:12,559 --> 00:20:13,360
so

530
00:20:13,360 --> 00:20:15,440
we want to as a second step add

531
00:20:15,440 --> 00:20:17,120
extractability

532
00:20:17,120 --> 00:20:19,280
so assume this commitment scheme was

533
00:20:19,280 --> 00:20:21,840
public keyed

534
00:20:21,840 --> 00:20:22,640
and

535
00:20:22,640 --> 00:20:24,080
in the original public key it's just

536
00:20:24,080 --> 00:20:26,559
going to be a random bit string but in

537
00:20:26,559 --> 00:20:30,000
the proof we'll swap this into a new

538
00:20:30,000 --> 00:20:32,840
public key star with a trapdoor

539
00:20:32,840 --> 00:20:36,559
town and this trapdoor towel will allow

540
00:20:36,559 --> 00:20:38,960
us to extract from any honestly

541
00:20:38,960 --> 00:20:40,960
generated commitment so given a

542
00:20:40,960 --> 00:20:44,000
commitment of this form

543
00:20:44,000 --> 00:20:47,760
then extract com will extract this uh

544
00:20:47,760 --> 00:20:50,480
element x

545
00:20:51,600 --> 00:20:53,520
so now what we want to show using this

546
00:20:53,520 --> 00:20:56,240
added extractability is that only given

547
00:20:56,240 --> 00:20:59,200
this first valid transcript we want to

548
00:20:59,200 --> 00:21:03,159
extract a witness e

549
00:21:05,440 --> 00:21:07,919
an incorrect naive argument will just be

550
00:21:07,919 --> 00:21:10,240
to say well run this

551
00:21:10,240 --> 00:21:12,720
extractor on this commitment e which is

552
00:21:12,720 --> 00:21:14,840
given to the verifier in the first round

553
00:21:14,840 --> 00:21:18,000
here but this is obviously wrong because

554
00:21:18,000 --> 00:21:19,520
there is no guarantee that this

555
00:21:19,520 --> 00:21:22,960
commitment e come e is valid

556
00:21:22,960 --> 00:21:25,200
the verifier or the simulator or the

557
00:21:25,200 --> 00:21:27,520
reduction algorithm only knows that this

558
00:21:27,520 --> 00:21:29,440
commitment

559
00:21:29,440 --> 00:21:31,200
this part is correct

560
00:21:31,200 --> 00:21:33,039
but since the commitment

561
00:21:33,039 --> 00:21:34,960
we already know that this opens to z and

562
00:21:34,960 --> 00:21:36,240
delta z

563
00:21:36,240 --> 00:21:38,240
it seems like there's no place to use

564
00:21:38,240 --> 00:21:41,360
this trap door right now

565
00:21:43,120 --> 00:21:44,640
so this third step

566
00:21:44,640 --> 00:21:46,559
we will now show how to argue extraction

567
00:21:46,559 --> 00:21:47,919
correctly

568
00:21:47,919 --> 00:21:50,080
so the simple observation is that this

569
00:21:50,080 --> 00:21:52,320
commitment ian commitment r is prepared

570
00:21:52,320 --> 00:21:55,520
before the challenge c

571
00:21:56,320 --> 00:21:58,880
so for simplicity we'll assume that this

572
00:21:58,880 --> 00:22:00,880
challenge set is small right now even

573
00:22:00,880 --> 00:22:03,039
though eventually we want this to be

574
00:22:03,039 --> 00:22:05,039
exponentially large for now we'll just

575
00:22:05,039 --> 00:22:07,919
think that this is small

576
00:22:07,919 --> 00:22:10,799
and we'll further assume that there's

577
00:22:10,799 --> 00:22:13,200
we are guaranteed that there is another

578
00:22:13,200 --> 00:22:15,120
valid transcript that v will accept

579
00:22:15,120 --> 00:22:18,000
eventually the verify will accept

580
00:22:18,000 --> 00:22:18,880
then

581
00:22:18,880 --> 00:22:20,960
with these two assumptions what this

582
00:22:20,960 --> 00:22:23,200
extractor will do the sigma protocol

583
00:22:23,200 --> 00:22:25,520
extractor what it will do is that it

584
00:22:25,520 --> 00:22:27,520
will just run through all the challenge

585
00:22:27,520 --> 00:22:30,159
and create commitment for all this

586
00:22:30,159 --> 00:22:32,640
challenge i

587
00:22:32,640 --> 00:22:34,799
and try to extract the extract from this

588
00:22:34,799 --> 00:22:37,280
commitment

589
00:22:37,919 --> 00:22:41,120
so by assumption since this

590
00:22:41,120 --> 00:22:43,600
since this verifier will accept on this

591
00:22:43,600 --> 00:22:46,080
channel c prime it means that

592
00:22:46,080 --> 00:22:48,480
for c prime this commitment z created

593
00:22:48,480 --> 00:22:51,200
for the c prime it will be valid

594
00:22:51,200 --> 00:22:53,120
therefore

595
00:22:53,120 --> 00:22:54,960
this is guaranteed to be a valid

596
00:22:54,960 --> 00:22:56,240
commitment so

597
00:22:56,240 --> 00:22:58,960
the strap door will extract this doe z

598
00:22:58,960 --> 00:23:00,480
prime

599
00:23:00,480 --> 00:23:03,280
as promised

600
00:23:03,919 --> 00:23:06,640
so if we're given this first flow

601
00:23:06,640 --> 00:23:09,520
i mean first transcript then we can run

602
00:23:09,520 --> 00:23:12,080
this uh extractor which will run through

603
00:23:12,080 --> 00:23:14,640
all the challenge set

604
00:23:14,640 --> 00:23:17,440
then it will find z prime at some point

605
00:23:17,440 --> 00:23:19,760
in polynomial steps and we'll be able to

606
00:23:19,760 --> 00:23:22,640
extract uh these two

607
00:23:22,640 --> 00:23:25,600
valid transcripts

608
00:23:27,600 --> 00:23:29,200
the remaining question is how to make

609
00:23:29,200 --> 00:23:31,600
this argument work for exponentially

610
00:23:31,600 --> 00:23:33,280
large challenges

611
00:23:33,280 --> 00:23:36,000
and here

612
00:23:36,000 --> 00:23:38,240
point was that uh we needed this to be

613
00:23:38,240 --> 00:23:40,240
polynomial large to run through all this

614
00:23:40,240 --> 00:23:41,200
uh

615
00:23:41,200 --> 00:23:42,720
space

616
00:23:42,720 --> 00:23:45,360
and an easy modification is that we're

617
00:23:45,360 --> 00:23:47,600
just gonna make this probabilistic

618
00:23:47,600 --> 00:23:49,600
so we're gonna have an upper bound large

619
00:23:49,600 --> 00:23:50,720
n

620
00:23:50,720 --> 00:23:52,400
and we're just going to keep on running

621
00:23:52,400 --> 00:23:55,200
this until it succeeds so we'll sample a

622
00:23:55,200 --> 00:23:56,720
random challenge and just keep on

623
00:23:56,720 --> 00:23:59,200
running this extraction

624
00:23:59,200 --> 00:24:01,440
and the question is does this work and

625
00:24:01,440 --> 00:24:05,120
how do we set this large n

626
00:24:06,400 --> 00:24:08,400
so this is a simple our statistical

627
00:24:08,400 --> 00:24:10,960
argument so let's assume an adversary

628
00:24:10,960 --> 00:24:13,279
has non-negligible advantage epsilon

629
00:24:13,279 --> 00:24:15,200
right now in completing the sigma

630
00:24:15,200 --> 00:24:17,679
protocol

631
00:24:17,840 --> 00:24:19,919
then using a very standard counting

632
00:24:19,919 --> 00:24:22,320
argument there has to be at least 2d

633
00:24:22,320 --> 00:24:25,520
times epsilon challenges for which a

634
00:24:25,520 --> 00:24:28,799
would have been able to answer

635
00:24:29,760 --> 00:24:31,760
therefore we can set this large end to

636
00:24:31,760 --> 00:24:34,559
be roughly lambda both lambda secure

637
00:24:34,559 --> 00:24:37,760
parameter over epsilon

638
00:24:37,760 --> 00:24:39,840
and after sampling this many random

639
00:24:39,840 --> 00:24:42,320
challenges then with overwhelming

640
00:24:42,320 --> 00:24:44,640
probability it will hit another valid

641
00:24:44,640 --> 00:24:47,640
commitment

642
00:24:48,960 --> 00:24:50,080
and

643
00:24:50,080 --> 00:24:51,520
this analysis

644
00:24:51,520 --> 00:24:54,240
works regardless of the adversary being

645
00:24:54,240 --> 00:24:57,279
quantum or not because it works

646
00:24:57,279 --> 00:24:59,120
the moment the adversary is able to

647
00:24:59,120 --> 00:25:00,960
produce a valid transcript then we can

648
00:25:00,960 --> 00:25:03,520
just invoke this reduction regardless of

649
00:25:03,520 --> 00:25:06,480
a being quantum or classical

650
00:25:06,480 --> 00:25:09,840
so this is how we make it work

651
00:25:09,840 --> 00:25:12,640
so summary so far is that uh using this

652
00:25:12,640 --> 00:25:15,120
simple extractable lin ac then we can

653
00:25:15,120 --> 00:25:16,960
get a sigma protocol with a quantum

654
00:25:16,960 --> 00:25:19,760
proof of knowledge

655
00:25:20,720 --> 00:25:22,480
extending this to the qram security and

656
00:25:22,480 --> 00:25:24,559
idk setting is very easy which is

657
00:25:24,559 --> 00:25:26,880
covered by this blue line

658
00:25:26,880 --> 00:25:28,960
we don't have time to explain in detail

659
00:25:28,960 --> 00:25:30,880
in this talk but it does follow very

660
00:25:30,880 --> 00:25:34,559
naturally from previous results

661
00:25:35,919 --> 00:25:38,880
some details worth mentioning is that uh

662
00:25:38,880 --> 00:25:40,960
in our future transform require a

663
00:25:40,960 --> 00:25:42,799
slightly stronger flavor extractable

664
00:25:42,799 --> 00:25:44,080
than ac

665
00:25:44,080 --> 00:25:45,840
because the sigma protocol is only

666
00:25:45,840 --> 00:25:47,520
competition on its verifier zero

667
00:25:47,520 --> 00:25:49,918
knowledge

668
00:25:50,640 --> 00:25:52,559
also the analysis extends easily to

669
00:25:52,559 --> 00:25:53,840
multi-round

670
00:25:53,840 --> 00:25:56,240
and since the commitment key was a

671
00:25:56,240 --> 00:25:58,960
random binary string we can just use the

672
00:25:58,960 --> 00:26:01,679
random oracle to output this public key

673
00:26:01,679 --> 00:26:04,000
in the real protocol rather than relying

674
00:26:04,000 --> 00:26:07,039
on a crs a common reference stream

675
00:26:07,039 --> 00:26:10,080
also when we look carefully our nizk is

676
00:26:10,080 --> 00:26:12,159
actually dual mode because depending on

677
00:26:12,159 --> 00:26:14,080
the public key we use it will be

678
00:26:14,080 --> 00:26:16,159
statistically sound or statistically

679
00:26:16,159 --> 00:26:18,880
zero knowledge

680
00:26:20,799 --> 00:26:22,880
finally let me just give a brief

681
00:26:22,880 --> 00:26:25,360
overview on how to construct such an

682
00:26:25,360 --> 00:26:28,400
extractable lineage c

683
00:26:28,400 --> 00:26:30,799
so in fact the dual rank of pk is

684
00:26:30,799 --> 00:26:31,919
already

685
00:26:31,919 --> 00:26:34,640
what we want an extra bollin hc

686
00:26:34,640 --> 00:26:37,520
so the commitment key in the real world

687
00:26:37,520 --> 00:26:39,919
will be a random binary string so this

688
00:26:39,919 --> 00:26:42,320
will be structured into a matrix a and b

689
00:26:42,320 --> 00:26:44,720
so this will correspond to a drill rig

690
00:26:44,720 --> 00:26:47,200
of pke public key

691
00:26:47,200 --> 00:26:50,320
that has no secret keys

692
00:26:50,320 --> 00:26:52,080
and to commit we're just going to

693
00:26:52,080 --> 00:26:56,000
encrypt using this uh random public key

694
00:26:56,000 --> 00:26:57,600
and here the

695
00:26:57,600 --> 00:27:00,240
randomness here for this acceptable nhc

696
00:27:00,240 --> 00:27:01,760
will just be the randomness for this

697
00:27:01,760 --> 00:27:06,039
encryption scheme here yes

698
00:27:06,240 --> 00:27:08,799
and linearly uh linear homomorphism

699
00:27:08,799 --> 00:27:11,200
follows naturally because george of pke

700
00:27:11,200 --> 00:27:13,679
is really homomorphic

701
00:27:13,679 --> 00:27:16,400
so you can just uh get the c times e

702
00:27:16,400 --> 00:27:19,120
plus r term here

703
00:27:19,120 --> 00:27:21,520
and in the extraction mode we'll just

704
00:27:21,520 --> 00:27:24,799
set this public key into an actual dual

705
00:27:24,799 --> 00:27:26,480
regular public key

706
00:27:26,480 --> 00:27:28,320
with a secret key

707
00:27:28,320 --> 00:27:30,320
and using that secret key we can always

708
00:27:30,320 --> 00:27:33,600
decrypt this and obtain this c times e

709
00:27:33,600 --> 00:27:36,320
plus r term back

710
00:27:36,320 --> 00:27:38,080
so this is a very basic way of

711
00:27:38,080 --> 00:27:41,039
constructing an extractor or linhc and

712
00:27:41,039 --> 00:27:43,520
in the paper we also

713
00:27:43,520 --> 00:27:46,000
provide a second method that uses entry

714
00:27:46,000 --> 00:27:47,760
like public encryption scheme to get

715
00:27:47,760 --> 00:27:50,640
better efficiency

716
00:27:51,279 --> 00:27:53,840
as a concrete application we benchmark

717
00:27:53,840 --> 00:27:56,880
using this bls19 protocol which provides

718
00:27:56,880 --> 00:28:01,279
an exact sound five round pcip protocol

719
00:28:01,600 --> 00:28:03,360
uh first of all the physical transformer

720
00:28:03,360 --> 00:28:05,120
it's not obvious whether it applies or

721
00:28:05,120 --> 00:28:06,880
not because we don't know if this is a

722
00:28:06,880 --> 00:28:09,120
collapsing sigma protocol or a five

723
00:28:09,120 --> 00:28:10,720
round protocol

724
00:28:10,720 --> 00:28:12,320
and also the under transform doesn't

725
00:28:12,320 --> 00:28:14,880
work because it's not a sigma protocol

726
00:28:14,880 --> 00:28:16,880
but this modified image transform might

727
00:28:16,880 --> 00:28:17,840
apply

728
00:28:17,840 --> 00:28:20,399
so we will benchmark using this modified

729
00:28:20,399 --> 00:28:24,959
under transform assuming that it works

730
00:28:25,279 --> 00:28:28,480
so uh the normal classical rom nizk is

731
00:28:28,480 --> 00:28:32,159
going to be 812 kilobytes the proof size

732
00:28:32,159 --> 00:28:33,760
if we apply the modified earner

733
00:28:33,760 --> 00:28:36,240
transform it's going to result in a 45

734
00:28:36,240 --> 00:28:38,640
megabyte proof which is roughly more

735
00:28:38,640 --> 00:28:40,960
than 100 times larger than the classical

736
00:28:40,960 --> 00:28:43,200
one

737
00:28:43,520 --> 00:28:45,760
and if we apply our extractable lin hc

738
00:28:45,760 --> 00:28:48,320
protocol it's only going to be at most

739
00:28:48,320 --> 00:28:52,320
2.6 larger which is 2071 kilobytes so

740
00:28:52,320 --> 00:28:54,640
compared to undrew it does provide a

741
00:28:54,640 --> 00:28:58,840
smaller proof size

742
00:29:00,080 --> 00:29:02,320
so this was our talk and this is a

743
00:29:02,320 --> 00:29:04,000
summary and open problems thanks for

744
00:29:04,000 --> 00:29:07,000
listening

