1
00:00:02,080 --> 00:00:04,240
okay so i'll be talking about uh the

2
00:00:04,240 --> 00:00:05,759
round complexity of secure quantum

3
00:00:05,759 --> 00:00:07,759
computation this is joint work with

4
00:00:07,759 --> 00:00:11,040
andrea dakshita and fermi

5
00:00:11,040 --> 00:00:13,519
so it turns out that um quantum

6
00:00:13,519 --> 00:00:15,120
information is pretty useful for

7
00:00:15,120 --> 00:00:17,279
cryptography and

8
00:00:17,279 --> 00:00:19,039
probably the most famous example of this

9
00:00:19,039 --> 00:00:21,520
is information theoretic key exchange

10
00:00:21,520 --> 00:00:23,039
but there are

11
00:00:23,039 --> 00:00:25,519
many other examples including quantum

12
00:00:25,519 --> 00:00:26,560
money so

13
00:00:26,560 --> 00:00:28,880
unclonable currency

14
00:00:28,880 --> 00:00:31,439
other types of unclonable cryptography

15
00:00:31,439 --> 00:00:33,680
so like encryption or signature schemes

16
00:00:33,680 --> 00:00:36,480
with unclonable keys for example

17
00:00:36,480 --> 00:00:37,440
um

18
00:00:37,440 --> 00:00:40,079
provable deletion of information

19
00:00:40,079 --> 00:00:42,239
um copy protection of programs and the

20
00:00:42,239 --> 00:00:43,120
list

21
00:00:43,120 --> 00:00:44,719
goes on and i'm probably missing many

22
00:00:44,719 --> 00:00:47,440
citations but the point is that

23
00:00:47,440 --> 00:00:49,760
quantum information can be used to

24
00:00:49,760 --> 00:00:53,039
perform like various tasks that are

25
00:00:53,039 --> 00:00:56,480
completely impossible

26
00:00:56,480 --> 00:00:59,680
with only classical information okay so

27
00:00:59,680 --> 00:01:00,640
you know

28
00:01:00,640 --> 00:01:02,399
one could imagine a world in which uh

29
00:01:02,399 --> 00:01:03,920
quantum information is being leveraged

30
00:01:03,920 --> 00:01:05,920
to perform all of these uh um

31
00:01:05,920 --> 00:01:07,600
interesting tasks

32
00:01:07,600 --> 00:01:09,520
um

33
00:01:09,520 --> 00:01:12,880
uh now the you know one prominent goal

34
00:01:12,880 --> 00:01:16,159
of of classical crypto uh has been you

35
00:01:16,159 --> 00:01:17,840
know one goal has been to

36
00:01:17,840 --> 00:01:19,759
distribute trust among multiple parties

37
00:01:19,759 --> 00:01:21,759
right in order to avoid like single

38
00:01:21,759 --> 00:01:23,520
points of failure or corruption things

39
00:01:23,520 --> 00:01:25,280
like this so a pretty

40
00:01:25,280 --> 00:01:28,320
natural question to ask is whether

41
00:01:28,320 --> 00:01:30,000
these cryptographic tasks that make

42
00:01:30,000 --> 00:01:32,960
inherent use of quantum information

43
00:01:32,960 --> 00:01:34,799
can be securely distributed among

44
00:01:34,799 --> 00:01:37,200
multiple parties okay

45
00:01:37,200 --> 00:01:39,200
as a concrete example maybe you have a

46
00:01:39,200 --> 00:01:40,720
quantum money scheme

47
00:01:40,720 --> 00:01:43,680
um and where of course the the

48
00:01:43,680 --> 00:01:45,600
the banknote generation procedure is of

49
00:01:45,600 --> 00:01:47,360
course quantum but now you might want to

50
00:01:47,360 --> 00:01:49,200
distribute this generation procedure so

51
00:01:49,200 --> 00:01:51,119
there isn't a single entity that is just

52
00:01:51,119 --> 00:01:52,560
able to

53
00:01:52,560 --> 00:01:54,799
generate banknotes right

54
00:01:54,799 --> 00:01:55,680
but

55
00:01:55,680 --> 00:01:58,640
okay so this is just uh one one way uh

56
00:01:58,640 --> 00:02:01,759
to motivate a more general um

57
00:02:01,759 --> 00:02:04,079
task that is uh

58
00:02:04,079 --> 00:02:06,560
the focus of this work which is secure

59
00:02:06,560 --> 00:02:10,318
multi-party quantum computation okay

60
00:02:10,318 --> 00:02:11,520
so

61
00:02:11,520 --> 00:02:13,360
what is this it's uh

62
00:02:13,360 --> 00:02:15,680
um you know same as the classical you

63
00:02:15,680 --> 00:02:17,920
know well-studied classical npc except

64
00:02:17,920 --> 00:02:19,599
that we're going to allow

65
00:02:19,599 --> 00:02:22,720
um parties to have quantum computers and

66
00:02:22,720 --> 00:02:25,840
uh quantum inputs and their goal is now

67
00:02:25,840 --> 00:02:27,680
to compute some quantum functionality

68
00:02:27,680 --> 00:02:29,599
over their quantum inputs um to produce

69
00:02:29,599 --> 00:02:33,120
some some quantum output in you know in

70
00:02:33,120 --> 00:02:33,920
um

71
00:02:33,920 --> 00:02:36,239
in its most general form right and and

72
00:02:36,239 --> 00:02:37,680
here actually we could consider like

73
00:02:37,680 --> 00:02:39,280
these inputs and outputs also being

74
00:02:39,280 --> 00:02:41,920
being entangled okay

75
00:02:41,920 --> 00:02:43,920
um so you know to do this of course

76
00:02:43,920 --> 00:02:46,080
they'll communicate with each other um

77
00:02:46,080 --> 00:02:48,480
now over quantum channels right

78
00:02:48,480 --> 00:02:50,480
and security is is the same as as

79
00:02:50,480 --> 00:02:52,800
classically we're going to say that um

80
00:02:52,800 --> 00:02:55,120
if an adversary is corrupting some set

81
00:02:55,120 --> 00:02:57,920
of parties say say two and three um they

82
00:02:57,920 --> 00:02:59,599
shouldn't learn anything about the

83
00:02:59,599 --> 00:03:02,080
honest party inputs

84
00:03:02,080 --> 00:03:03,840
except for what is already implied by

85
00:03:03,840 --> 00:03:06,480
their output okay

86
00:03:06,480 --> 00:03:08,400
and so of course like classical npc is

87
00:03:08,400 --> 00:03:10,239
extremely well studied and as uh you

88
00:03:10,239 --> 00:03:12,000
know dates all the way back almost to

89
00:03:12,000 --> 00:03:14,239
the beginning of modern crypto

90
00:03:14,239 --> 00:03:15,920
um

91
00:03:15,920 --> 00:03:17,519
multi-party quantum computation has also

92
00:03:17,519 --> 00:03:20,080
been studied but of course not as much

93
00:03:20,080 --> 00:03:21,760
so what is known is that you know there

94
00:03:21,760 --> 00:03:24,000
are these two works in the early 2000s

95
00:03:24,000 --> 00:03:25,680
that constructed

96
00:03:25,680 --> 00:03:27,840
information theoretically secure

97
00:03:27,840 --> 00:03:30,400
protocols in the honest majority setting

98
00:03:30,400 --> 00:03:32,159
okay

99
00:03:32,159 --> 00:03:33,840
later on the dishonest majority setting

100
00:03:33,840 --> 00:03:35,680
was considered

101
00:03:35,680 --> 00:03:39,440
and these works dns djjms

102
00:03:39,440 --> 00:03:42,400
they present basically compilers showing

103
00:03:42,400 --> 00:03:44,400
that if you have secure classical

104
00:03:44,400 --> 00:03:45,680
computation

105
00:03:45,680 --> 00:03:47,519
uh you can construct secure quantum

106
00:03:47,519 --> 00:03:50,560
computation um even you know

107
00:03:50,560 --> 00:03:52,480
against uh malicious adversaries

108
00:03:52,480 --> 00:03:55,519
corrupting an arbitrary um

109
00:03:55,519 --> 00:03:57,280
subset of the parties okay and so this

110
00:03:57,280 --> 00:03:58,959
is you know these

111
00:03:58,959 --> 00:04:00,799
these works really are works

112
00:04:00,799 --> 00:04:03,439
establishing the feasibility of secure

113
00:04:03,439 --> 00:04:06,080
multi-party quantum competition right

114
00:04:06,080 --> 00:04:07,680
and so this is kind of the state of

115
00:04:07,680 --> 00:04:09,280
affairs um

116
00:04:09,280 --> 00:04:10,799
prior to our work

117
00:04:10,799 --> 00:04:12,400
so uh

118
00:04:12,400 --> 00:04:13,599
you know

119
00:04:13,599 --> 00:04:15,599
one you know potential issue or drawback

120
00:04:15,599 --> 00:04:17,759
with these protocols uh

121
00:04:17,759 --> 00:04:20,320
really is uh they're extremely

122
00:04:20,320 --> 00:04:22,240
interactive highly interactive protocols

123
00:04:22,240 --> 00:04:23,360
right so

124
00:04:23,360 --> 00:04:25,520
um in particular like the number of

125
00:04:25,520 --> 00:04:26,800
rounds

126
00:04:26,800 --> 00:04:28,639
of communication required and keep in

127
00:04:28,639 --> 00:04:30,479
mind this communication is in general

128
00:04:30,479 --> 00:04:32,160
going to be quantum communication so

129
00:04:32,160 --> 00:04:33,840
these parties you know sending quantum

130
00:04:33,840 --> 00:04:35,600
states to each other right

131
00:04:35,600 --> 00:04:37,680
in general uh in these protocols it

132
00:04:37,680 --> 00:04:39,040
grows with the depth of the quantum

133
00:04:39,040 --> 00:04:41,280
circuit okay

134
00:04:41,280 --> 00:04:42,800
and so

135
00:04:42,800 --> 00:04:45,600
you know uh round complexity is a a

136
00:04:45,600 --> 00:04:47,520
notion that's been heavily studied in

137
00:04:47,520 --> 00:04:50,400
the classical setting

138
00:04:50,800 --> 00:04:52,400
and our work the starting point of our

139
00:04:52,400 --> 00:04:54,639
work our focus is on um

140
00:04:54,639 --> 00:04:56,160
round efficient secure quantum

141
00:04:56,160 --> 00:04:57,759
computation okay

142
00:04:57,759 --> 00:04:59,120
so we know

143
00:04:59,120 --> 00:05:01,120
these these feasibility results exist

144
00:05:01,120 --> 00:05:03,520
okay so now we want to study um

145
00:05:03,520 --> 00:05:05,440
uh you know whether whether we can

146
00:05:05,440 --> 00:05:07,120
really obtain round efficiency in the

147
00:05:07,120 --> 00:05:09,039
quantum setting right

148
00:05:09,039 --> 00:05:10,960
and to be clear about the

149
00:05:10,960 --> 00:05:12,240
particular setting that we are

150
00:05:12,240 --> 00:05:15,280
interested in is this dishonest majority

151
00:05:15,280 --> 00:05:16,479
um

152
00:05:16,479 --> 00:05:18,880
setting uh where adversary can corrupt

153
00:05:18,880 --> 00:05:20,639
an arbitrary subset of parties and can

154
00:05:20,639 --> 00:05:22,479
act arbitrarily and maliciously during

155
00:05:22,479 --> 00:05:24,880
the protocol okay and we're also going

156
00:05:24,880 --> 00:05:27,120
to assume some minimal trusted setup so

157
00:05:27,120 --> 00:05:29,120
so a pretty common model of assuming

158
00:05:29,120 --> 00:05:30,880
like a common random string

159
00:05:30,880 --> 00:05:32,720
that that the parties have access to

160
00:05:32,720 --> 00:05:34,960
okay

161
00:05:35,360 --> 00:05:36,720
right so this is

162
00:05:36,720 --> 00:05:39,039
the focus of this work um

163
00:05:39,039 --> 00:05:41,039
we have various results both in the

164
00:05:41,039 --> 00:05:42,320
two-party

165
00:05:42,320 --> 00:05:44,320
and more than two-party or multi-party

166
00:05:44,320 --> 00:05:46,720
setting um and all kind of

167
00:05:46,720 --> 00:05:48,880
uh let's put this talking into those two

168
00:05:48,880 --> 00:05:50,560
parts

169
00:05:50,560 --> 00:05:52,160
i'll be able to give all our result

170
00:05:52,160 --> 00:05:54,720
statements along with some uh a little

171
00:05:54,720 --> 00:05:56,639
bit about like the techniques we use to

172
00:05:56,639 --> 00:05:58,560
get them um but we'll we'll leave a lot

173
00:05:58,560 --> 00:06:01,280
of the details to the paper okay

174
00:06:01,280 --> 00:06:02,880
um

175
00:06:02,880 --> 00:06:04,720
so to begin with the two-party case

176
00:06:04,720 --> 00:06:07,520
we'll first look at

177
00:06:07,520 --> 00:06:09,039
what's known about classical two-party

178
00:06:09,039 --> 00:06:11,759
computation okay so

179
00:06:11,759 --> 00:06:14,080
these results you know daybet date back

180
00:06:14,080 --> 00:06:15,919
to yao in the 80s

181
00:06:15,919 --> 00:06:17,680
who show that if you

182
00:06:17,680 --> 00:06:20,479
assume a two message oblivious transfer

183
00:06:20,479 --> 00:06:22,880
protocol and oblivious transfer is a

184
00:06:22,880 --> 00:06:24,880
extremely simple two-party functionality

185
00:06:24,880 --> 00:06:26,720
right where we have a receiver with a

186
00:06:26,720 --> 00:06:29,199
bit b sender with two strings

187
00:06:29,199 --> 00:06:30,560
and the receiver at the end of the

188
00:06:30,560 --> 00:06:33,360
protocol learns one of the two center

189
00:06:33,360 --> 00:06:36,319
strings right so this very simple

190
00:06:36,319 --> 00:06:38,240
oblivious transfer functionality that if

191
00:06:38,240 --> 00:06:40,639
you can do this in just two messages

192
00:06:40,639 --> 00:06:42,160
then

193
00:06:42,160 --> 00:06:45,280
kind of amazingly you can compute any

194
00:06:45,280 --> 00:06:48,240
arbitrary classical functionality over

195
00:06:48,240 --> 00:06:49,120
um

196
00:06:49,120 --> 00:06:51,280
over two you know two private inputs x

197
00:06:51,280 --> 00:06:52,479
and x b

198
00:06:52,479 --> 00:06:55,680
um delivering output to a right so

199
00:06:55,680 --> 00:06:56,720
um

200
00:06:56,720 --> 00:06:58,639
basically ot the simple functionality

201
00:06:58,639 --> 00:07:00,160
implies the ability to do secure

202
00:07:00,160 --> 00:07:02,240
computation of arbitrary functionalities

203
00:07:02,240 --> 00:07:04,560
and even in a round preserving way okay

204
00:07:04,560 --> 00:07:07,120
and so sometimes this is called

205
00:07:07,120 --> 00:07:08,400
um

206
00:07:08,400 --> 00:07:10,800
nisk uh this protocol a non-interactive

207
00:07:10,800 --> 00:07:12,720
secure computation protocol

208
00:07:12,720 --> 00:07:15,039
and kind of the malicious version like

209
00:07:15,039 --> 00:07:17,120
uh nisco with malicious security was uh

210
00:07:17,120 --> 00:07:19,120
formalized by this work in

211
00:07:19,120 --> 00:07:22,160
ips okay

212
00:07:22,400 --> 00:07:24,560
so um

213
00:07:24,560 --> 00:07:26,479
our first result is just going to be a

214
00:07:26,479 --> 00:07:28,400
quantum analog of this right we're going

215
00:07:28,400 --> 00:07:29,840
to show that

216
00:07:29,840 --> 00:07:32,800
how to construct a quantum disk protocol

217
00:07:32,800 --> 00:07:34,240
in other words

218
00:07:34,240 --> 00:07:36,240
assuming just the same assumption so

219
00:07:36,240 --> 00:07:37,759
well of course not post quantum so

220
00:07:37,759 --> 00:07:39,199
assuming post quantum two message

221
00:07:39,199 --> 00:07:41,520
oblivious transfer

222
00:07:41,520 --> 00:07:43,120
you know we can construct

223
00:07:43,120 --> 00:07:45,440
a two message protocol for computing any

224
00:07:45,440 --> 00:07:47,199
functionality any quantum functionality

225
00:07:47,199 --> 00:07:49,280
that delivers output uh to one party

226
00:07:49,280 --> 00:07:50,319
okay so

227
00:07:50,319 --> 00:07:53,280
uh quantum risk

228
00:07:53,520 --> 00:07:55,039
and i can say

229
00:07:55,039 --> 00:07:57,120
a few words about how we construct this

230
00:07:57,120 --> 00:07:58,720
protocol

231
00:07:58,720 --> 00:08:00,400
and to do that we'll need a little bit

232
00:08:00,400 --> 00:08:02,319
of background on

233
00:08:02,319 --> 00:08:04,400
classical garbled circuits

234
00:08:04,400 --> 00:08:05,599
right so

235
00:08:05,599 --> 00:08:08,240
a classical garbled circuit is basically

236
00:08:08,240 --> 00:08:09,440
consists of

237
00:08:09,440 --> 00:08:12,560
two procedures garble and a eval

238
00:08:12,560 --> 00:08:15,280
and garble takes us and put a

239
00:08:15,280 --> 00:08:17,520
circuit or a functionality f and an

240
00:08:17,520 --> 00:08:21,360
input x and produces a garbled circuit f

241
00:08:21,360 --> 00:08:24,479
tilde and a garbled input x tilde

242
00:08:24,479 --> 00:08:26,960
um okay and the evaluation uh

243
00:08:26,960 --> 00:08:28,639
functionality takes this garbled

244
00:08:28,639 --> 00:08:30,639
information and produces from it uh the

245
00:08:30,639 --> 00:08:33,919
output f of x okay and security

246
00:08:33,919 --> 00:08:35,919
intuitively states that like

247
00:08:35,919 --> 00:08:37,440
this garbled information kind of only

248
00:08:37,440 --> 00:08:39,440
contains information about f x and this

249
00:08:39,440 --> 00:08:40,719
is formalized by saying there's a

250
00:08:40,719 --> 00:08:43,519
simulator that just just given f x but

251
00:08:43,519 --> 00:08:46,399
not x right can can produce something

252
00:08:46,399 --> 00:08:47,760
that is indistinguishable from this

253
00:08:47,760 --> 00:08:50,640
garbled information okay

254
00:08:50,640 --> 00:08:52,560
and this is you know

255
00:08:52,560 --> 00:08:54,560
it's it's only non-trivial and garble

256
00:08:54,560 --> 00:08:56,959
has some is simpler or lower complexity

257
00:08:56,959 --> 00:08:58,640
in some sense than f otherwise garble

258
00:08:58,640 --> 00:09:01,200
could just evaluate f already right but

259
00:09:01,200 --> 00:09:04,080
when when garble is um sufficiently

260
00:09:04,080 --> 00:09:06,480
simple or efficient then this uh this

261
00:09:06,480 --> 00:09:09,600
object has many applications

262
00:09:09,600 --> 00:09:11,040
right so this is a classical garbled

263
00:09:11,040 --> 00:09:12,080
circuit

264
00:09:12,080 --> 00:09:13,920
uh you could ask for the same thing in

265
00:09:13,920 --> 00:09:15,519
the quantum setting right and there's

266
00:09:15,519 --> 00:09:17,680
there's many there's probably many ways

267
00:09:17,680 --> 00:09:20,880
to uh formalize or like

268
00:09:20,880 --> 00:09:22,880
uh kind of specify what sort of

269
00:09:22,880 --> 00:09:24,560
properties you'd want out of a quantum

270
00:09:24,560 --> 00:09:26,640
grapple circuit and i'll discuss one

271
00:09:26,640 --> 00:09:29,279
particular

272
00:09:29,279 --> 00:09:31,200
set of properties so

273
00:09:31,200 --> 00:09:33,040
you know here

274
00:09:33,040 --> 00:09:35,279
like let's say you have say a classical

275
00:09:35,279 --> 00:09:38,000
description of a unitary u but in

276
00:09:38,000 --> 00:09:39,760
general maybe a more general quantum

277
00:09:39,760 --> 00:09:41,279
operation as well

278
00:09:41,279 --> 00:09:44,160
and you have a

279
00:09:45,440 --> 00:09:48,000
quantum input x right

280
00:09:48,000 --> 00:09:50,240
so what we want out of our garble

281
00:09:50,240 --> 00:09:53,279
procedure is going to be um

282
00:09:53,279 --> 00:09:54,399
well

283
00:09:54,399 --> 00:09:57,600
uh the procedure that garbles you and

284
00:09:57,600 --> 00:09:59,760
produces utilda we're going to require

285
00:09:59,760 --> 00:10:02,000
is going to be completely classical okay

286
00:10:02,000 --> 00:10:03,279
so

287
00:10:03,279 --> 00:10:04,720
you know takes a classical description

288
00:10:04,720 --> 00:10:06,000
of you and outputs a classical

289
00:10:06,000 --> 00:10:08,640
description of utildo

290
00:10:08,640 --> 00:10:10,959
uh and moreover the the procedure that

291
00:10:10,959 --> 00:10:13,680
takes the input x um and produces a

292
00:10:13,680 --> 00:10:15,440
global input x should be simple in some

293
00:10:15,440 --> 00:10:16,800
sense which i'll be

294
00:10:16,800 --> 00:10:19,040
more specific about later

295
00:10:19,040 --> 00:10:21,600
but this particular set of properties

296
00:10:21,600 --> 00:10:23,440
out of a grappled circuit like

297
00:10:23,440 --> 00:10:25,120
um was considered

298
00:10:25,120 --> 00:10:27,839
uh in this recent work over kirsky un

299
00:10:27,839 --> 00:10:29,600
uh and they they sketched how you might

300
00:10:29,600 --> 00:10:31,760
construct this and then we go and

301
00:10:31,760 --> 00:10:33,279
formalize and prove security of it in

302
00:10:33,279 --> 00:10:34,320
our work

303
00:10:34,320 --> 00:10:35,360
um

304
00:10:35,360 --> 00:10:37,920
and to be uh clear about what i meant by

305
00:10:37,920 --> 00:10:40,240
simple basically the garbling the input

306
00:10:40,240 --> 00:10:42,000
garbling procedure just basically takes

307
00:10:42,000 --> 00:10:44,880
your input x appends some zero states

308
00:10:44,880 --> 00:10:48,000
and some so-called like magic t states

309
00:10:48,000 --> 00:10:50,079
um and then re-randomizes everything

310
00:10:50,079 --> 00:10:51,839
with a random clifford and this is

311
00:10:51,839 --> 00:10:53,760
simple because like basically this

312
00:10:53,760 --> 00:10:57,360
clifford computation is uh in general um

313
00:10:57,360 --> 00:10:59,279
simpler than arbitrary an arbitrary

314
00:10:59,279 --> 00:11:00,399
quantum operation

315
00:11:00,399 --> 00:11:02,160
okay

316
00:11:02,160 --> 00:11:04,399
right so

317
00:11:04,399 --> 00:11:06,240
so we're going to

318
00:11:06,240 --> 00:11:08,560
take this object as our starting point a

319
00:11:08,560 --> 00:11:11,279
quantum garbling procedure down here

320
00:11:11,279 --> 00:11:12,320
with

321
00:11:12,320 --> 00:11:15,120
with a classical unitary or classical

322
00:11:15,120 --> 00:11:18,079
circuit garbling uh subroutine right and

323
00:11:18,079 --> 00:11:20,160
we're going to use it to

324
00:11:20,160 --> 00:11:21,040
um

325
00:11:21,040 --> 00:11:23,600
to build the nisk okay so recall we have

326
00:11:23,600 --> 00:11:24,640
a

327
00:11:24,640 --> 00:11:25,600
um

328
00:11:25,600 --> 00:11:27,120
you know two quantum parties each with

329
00:11:27,120 --> 00:11:29,120
their quantum input

330
00:11:29,120 --> 00:11:31,440
and we want uh to uh

331
00:11:31,440 --> 00:11:34,160
we want a to recover its output ya at

332
00:11:34,160 --> 00:11:36,560
the end of interaction okay so

333
00:11:36,560 --> 00:11:38,720
so first we're gonna have a send over an

334
00:11:38,720 --> 00:11:40,720
encrypted version of its quantum input

335
00:11:40,720 --> 00:11:42,399
for this we'll use something called an

336
00:11:42,399 --> 00:11:44,480
clifford encoding

337
00:11:44,480 --> 00:11:46,160
and then we'll just basically have b

338
00:11:46,160 --> 00:11:50,160
send back a a garbled input okay so

339
00:11:50,160 --> 00:11:52,399
it's going to append like its input xb

340
00:11:52,399 --> 00:11:54,639
to a as input xa and it's going to

341
00:11:54,639 --> 00:11:56,399
garble that input by appending zero and

342
00:11:56,399 --> 00:11:57,839
two states re-randomizing with the

343
00:11:57,839 --> 00:11:59,839
clifford right

344
00:11:59,839 --> 00:12:01,680
so this gives a the global input we also

345
00:12:01,680 --> 00:12:03,120
have to give a

346
00:12:03,120 --> 00:12:05,920
the garbled unitary right

347
00:12:05,920 --> 00:12:07,760
and so

348
00:12:07,760 --> 00:12:09,680
we're going to enable this with a

349
00:12:09,680 --> 00:12:12,079
classical gpc or a classical nisk

350
00:12:12,079 --> 00:12:15,279
protocol okay

351
00:12:15,839 --> 00:12:17,440
and this is possible because this

352
00:12:17,440 --> 00:12:19,839
procedure that garbles you into utility

353
00:12:19,839 --> 00:12:21,360
is completely classical

354
00:12:21,360 --> 00:12:23,680
okay so we can kind of run this under a

355
00:12:23,680 --> 00:12:26,480
classical gpc and this is

356
00:12:26,480 --> 00:12:28,240
uh very helpful because we're going to

357
00:12:28,240 --> 00:12:30,720
get some you know malicious security out

358
00:12:30,720 --> 00:12:32,560
of our you know malicious secure

359
00:12:32,560 --> 00:12:33,920
classical npc so we're going to

360
00:12:33,920 --> 00:12:36,399
basically be able to ensure that utilda

361
00:12:36,399 --> 00:12:39,440
is is competed properly okay

362
00:12:39,440 --> 00:12:40,160
so

363
00:12:40,160 --> 00:12:42,240
right so a gets the scarable input gets

364
00:12:42,240 --> 00:12:44,560
this properly computed utility and from

365
00:12:44,560 --> 00:12:47,600
that is able to obtain its output

366
00:12:47,600 --> 00:12:49,200
so this is the basic idea there's still

367
00:12:49,200 --> 00:12:51,279
kind of one

368
00:12:51,279 --> 00:12:53,120
big issue that needs to be taken care of

369
00:12:53,120 --> 00:12:55,680
like this classical tpc is ensuring that

370
00:12:55,680 --> 00:12:57,680
that utility is correctly computed but

371
00:12:57,680 --> 00:13:00,720
what about this garbled input okay

372
00:13:00,720 --> 00:13:03,839
so you know in particular a uh

373
00:13:03,839 --> 00:13:04,959
malicious

374
00:13:04,959 --> 00:13:07,680
party b might send a malformed um

375
00:13:07,680 --> 00:13:10,000
grabble input right

376
00:13:10,000 --> 00:13:12,160
in particular they might not be lying

377
00:13:12,160 --> 00:13:14,079
about or they might not send like proper

378
00:13:14,079 --> 00:13:16,160
zero empty states so without going into

379
00:13:16,160 --> 00:13:18,079
details we're going to need to include

380
00:13:18,079 --> 00:13:20,480
some extra two message protocols that

381
00:13:20,480 --> 00:13:23,120
basically allow a to check for these uh

382
00:13:23,120 --> 00:13:26,639
properly formed zero and two states okay

383
00:13:26,639 --> 00:13:29,600
um and these these checks are

384
00:13:29,600 --> 00:13:31,600
inspired um

385
00:13:31,600 --> 00:13:34,399
by similar checks that were used in dg

386
00:13:34,399 --> 00:13:36,720
jms in a more interactive setting um and

387
00:13:36,720 --> 00:13:38,240
we basically show like two message

388
00:13:38,240 --> 00:13:40,160
versions of these these these checks

389
00:13:40,160 --> 00:13:41,680
okay

390
00:13:41,680 --> 00:13:42,800
um

391
00:13:42,800 --> 00:13:44,880
so yeah this is this gives a picture of

392
00:13:44,880 --> 00:13:47,279
basically how our quantum disk protocol

393
00:13:47,279 --> 00:13:49,440
is constructed

394
00:13:49,440 --> 00:13:50,800
and before

395
00:13:50,800 --> 00:13:52,959
moving on i will mention a

396
00:13:52,959 --> 00:13:55,199
we have a corollary of this

397
00:13:55,199 --> 00:13:57,760
is that we can use this to build a

398
00:13:57,760 --> 00:14:00,320
particular type of a designated verifier

399
00:14:00,320 --> 00:14:01,760
a non-interactive zero knowledge

400
00:14:01,760 --> 00:14:04,000
protocol for qma

401
00:14:04,000 --> 00:14:05,680
and it has interesting properties like

402
00:14:05,680 --> 00:14:06,959
reusable

403
00:14:06,959 --> 00:14:09,120
uh malicious security

404
00:14:09,120 --> 00:14:10,560
um

405
00:14:10,560 --> 00:14:12,160
and like the you know the actual

406
00:14:12,160 --> 00:14:13,680
statement we get is that like if we

407
00:14:13,680 --> 00:14:15,360
combine two message abilities transfer

408
00:14:15,360 --> 00:14:16,639
with

409
00:14:16,639 --> 00:14:18,959
mdb and isik for np then we get this

410
00:14:18,959 --> 00:14:21,600
protocol for qma okay and this is the

411
00:14:21,600 --> 00:14:24,079
same this mdv music for qma is the same

412
00:14:24,079 --> 00:14:25,600
object it was also constructed by

413
00:14:25,600 --> 00:14:26,880
shimeli

414
00:14:26,880 --> 00:14:29,199
also appearing at this crypto conference

415
00:14:29,199 --> 00:14:32,079
um you know one difference kind of the

416
00:14:32,079 --> 00:14:35,519
advantage of our protocol is that

417
00:14:35,519 --> 00:14:37,680
the prover in our protocol only requires

418
00:14:37,680 --> 00:14:39,760
one copy of the quantum witness state

419
00:14:39,760 --> 00:14:40,639
okay

420
00:14:40,639 --> 00:14:43,199
whereas in this other protocol from

421
00:14:43,199 --> 00:14:45,120
schmeli there's uh the preview needed

422
00:14:45,120 --> 00:14:47,839
multiple copies okay so that but this is

423
00:14:47,839 --> 00:14:50,320
yeah so this is just one um application

424
00:14:50,320 --> 00:14:54,480
we have of our of our quantum disk okay

425
00:14:55,279 --> 00:14:56,079
so

426
00:14:56,079 --> 00:14:59,360
good now um i'd like to move on and and

427
00:14:59,360 --> 00:15:01,279
say well we've so far we've just

428
00:15:01,279 --> 00:15:02,959
considered protocols where one party

429
00:15:02,959 --> 00:15:04,959
obtains an output right

430
00:15:04,959 --> 00:15:06,959
so what if we want you know

431
00:15:06,959 --> 00:15:08,399
the more general setting where both

432
00:15:08,399 --> 00:15:10,720
parties are obtaining some output and

433
00:15:10,720 --> 00:15:12,800
what if we you know furthermore we want

434
00:15:12,800 --> 00:15:14,240
to maintain the the

435
00:15:14,240 --> 00:15:16,560
optimal round complexity of two

436
00:15:16,560 --> 00:15:17,680
right

437
00:15:17,680 --> 00:15:19,839
so there's a pretty natural classical

438
00:15:19,839 --> 00:15:22,720
approach to doing this so

439
00:15:22,720 --> 00:15:24,839
if you have some you know classical

440
00:15:24,839 --> 00:15:27,680
functionality now that has two outputs

441
00:15:27,680 --> 00:15:30,320
you can basically consider writing it as

442
00:15:30,320 --> 00:15:32,320
two separate functionalities one that

443
00:15:32,320 --> 00:15:33,920
just outputs like a is part of the

444
00:15:33,920 --> 00:15:35,839
output and the other that just outputs b

445
00:15:35,839 --> 00:15:37,600
is part of the output

446
00:15:37,600 --> 00:15:39,759
and then you could consider running two

447
00:15:39,759 --> 00:15:42,480
nisk protocols in parallel okay so you

448
00:15:42,480 --> 00:15:44,560
could have you know the blue nisk that's

449
00:15:44,560 --> 00:15:46,240
delivering a's output and the orange

450
00:15:46,240 --> 00:15:49,839
nisk that is delivering b's output

451
00:15:49,839 --> 00:15:51,279
this is a natural approach and it can be

452
00:15:51,279 --> 00:15:53,279
made to work on the classical setting

453
00:15:53,279 --> 00:15:54,560
however there are some significant

454
00:15:54,560 --> 00:15:56,320
barriers to making this work in the

455
00:15:56,320 --> 00:15:58,160
quantum setting okay

456
00:15:58,160 --> 00:15:59,680
and

457
00:15:59,680 --> 00:16:01,920
the reason uh well one reason is that

458
00:16:01,920 --> 00:16:04,160
this seems to require cloning inputs

459
00:16:04,160 --> 00:16:05,519
right you need to run these two parallel

460
00:16:05,519 --> 00:16:08,959
protocols on the same set of inputs but

461
00:16:08,959 --> 00:16:10,480
if your inputs are quantum you can't in

462
00:16:10,480 --> 00:16:13,120
general clone them right

463
00:16:13,120 --> 00:16:14,000
and

464
00:16:14,000 --> 00:16:15,040
kind of

465
00:16:15,040 --> 00:16:17,680
even worse

466
00:16:18,480 --> 00:16:20,720
this like say that this functionality is

467
00:16:20,720 --> 00:16:22,639
is randomized well what what you're

468
00:16:22,639 --> 00:16:24,160
actually doing when you write it as two

469
00:16:24,160 --> 00:16:26,399
functionalities is is kind of fixing a

470
00:16:26,399 --> 00:16:28,399
particular random string

471
00:16:28,399 --> 00:16:30,480
r and then using that same random string

472
00:16:30,480 --> 00:16:32,639
in both of these like f a and fb right

473
00:16:32,639 --> 00:16:34,079
because if you didn't do this then these

474
00:16:34,079 --> 00:16:36,320
outputs y a y b wouldn't be properly

475
00:16:36,320 --> 00:16:38,560
jointly distributed okay

476
00:16:38,560 --> 00:16:40,079
so this relies on the fact that you can

477
00:16:40,079 --> 00:16:41,600
really take a a

478
00:16:41,600 --> 00:16:42,880
a randomized protocol and make it

479
00:16:42,880 --> 00:16:44,639
deterministic by fixing the random

480
00:16:44,639 --> 00:16:45,600
string

481
00:16:45,600 --> 00:16:47,040
and this is something also that you just

482
00:16:47,040 --> 00:16:48,480
cannot do in the quantum setting right

483
00:16:48,480 --> 00:16:50,800
because maybe randomness um

484
00:16:50,800 --> 00:16:53,199
is coming from measurement okay

485
00:16:53,199 --> 00:16:55,440
and so this this issue the fact that you

486
00:16:55,440 --> 00:16:57,279
can't kind of like fix the randomness

487
00:16:57,279 --> 00:17:00,160
and split up the protocol like this um

488
00:17:00,160 --> 00:17:02,160
is you know it even comes up even if

489
00:17:02,160 --> 00:17:05,280
these even if these uh inputs x a and x

490
00:17:05,280 --> 00:17:07,359
b are classical but maybe the parties

491
00:17:07,359 --> 00:17:08,720
want to compute a quantum functionality

492
00:17:08,720 --> 00:17:11,520
over them okay so these are kind of

493
00:17:11,520 --> 00:17:12,959
you know no cloning and not being able

494
00:17:12,959 --> 00:17:14,880
to fix the randomness or two to issues

495
00:17:14,880 --> 00:17:16,319
that kind of prevent this natural

496
00:17:16,319 --> 00:17:20,640
approach from from working okay

497
00:17:20,640 --> 00:17:23,039
so this is just to highlight

498
00:17:23,039 --> 00:17:24,480
maybe some difficulties in getting a

499
00:17:24,480 --> 00:17:26,559
two-round protocol

500
00:17:26,559 --> 00:17:27,919
um

501
00:17:27,919 --> 00:17:30,160
and now i'll basically i won't be able

502
00:17:30,160 --> 00:17:32,720
to go into details about like

503
00:17:32,720 --> 00:17:35,039
our technical contributions

504
00:17:35,039 --> 00:17:36,640
here but i'll be able to give result

505
00:17:36,640 --> 00:17:38,559
statements so basically the first thing

506
00:17:38,559 --> 00:17:40,320
we do is we relax the problem a little

507
00:17:40,320 --> 00:17:41,600
bit and we

508
00:17:41,600 --> 00:17:44,080
we construct a two-round protocol where

509
00:17:44,080 --> 00:17:45,919
pre-processing is allowed meaning that

510
00:17:45,919 --> 00:17:48,559
the parties can exchange some

511
00:17:48,559 --> 00:17:50,799
you know messages beforehand before they

512
00:17:50,799 --> 00:17:52,559
before they obtain their inputs okay and

513
00:17:52,559 --> 00:17:53,760
then once they obtain their inputs it's

514
00:17:53,760 --> 00:17:55,360
just a two-round protocol and so we can

515
00:17:55,360 --> 00:17:57,520
construct this object

516
00:17:57,520 --> 00:17:58,320
from

517
00:17:58,320 --> 00:18:01,200
exponentially secure lwe okay

518
00:18:01,200 --> 00:18:03,840
so two-round uh two-party uh quantum

519
00:18:03,840 --> 00:18:06,960
computation with free processing

520
00:18:06,960 --> 00:18:09,360
of course we are also interested in you

521
00:18:09,360 --> 00:18:11,520
know what's actually happening

522
00:18:11,520 --> 00:18:12,720
um in

523
00:18:12,720 --> 00:18:15,440
in uh the setting without pre-processing

524
00:18:15,440 --> 00:18:16,320
like a

525
00:18:16,320 --> 00:18:18,320
like can we actually obtain a truly

526
00:18:18,320 --> 00:18:20,559
two-round protocol right

527
00:18:20,559 --> 00:18:22,320
and we and here it's still like pretty

528
00:18:22,320 --> 00:18:25,919
open okay um we only have like a partial

529
00:18:25,919 --> 00:18:27,600
negative result and a partial positive

530
00:18:27,600 --> 00:18:29,760
result okay so

531
00:18:29,760 --> 00:18:32,640
um our partial negative result is really

532
00:18:32,640 --> 00:18:35,120
uh in an attempt to formalize this

533
00:18:35,120 --> 00:18:37,360
intuition i was i was mentioning before

534
00:18:37,360 --> 00:18:39,760
about what makes this problem difficult

535
00:18:39,760 --> 00:18:42,960
and this formalization is takes the form

536
00:18:42,960 --> 00:18:44,400
of saying well

537
00:18:44,400 --> 00:18:47,679
there is a particular like class of uh

538
00:18:47,679 --> 00:18:50,160
simulators right

539
00:18:50,160 --> 00:18:51,600
that is impossible in the sense that you

540
00:18:51,600 --> 00:18:53,760
can't construct a two-round protocol

541
00:18:53,760 --> 00:18:55,679
with what we call an oblivious simulator

542
00:18:55,679 --> 00:18:57,600
an oblivious simulator is basically one

543
00:18:57,600 --> 00:18:58,640
that

544
00:18:58,640 --> 00:19:00,799
kind of programs the crs independently

545
00:19:00,799 --> 00:19:03,440
of of which the two parties is corrupted

546
00:19:03,440 --> 00:19:04,480
and

547
00:19:04,480 --> 00:19:05,440
this is

548
00:19:05,440 --> 00:19:07,520
uh kind of interesting and or i should

549
00:19:07,520 --> 00:19:09,919
say while we only obtain this uh results

550
00:19:09,919 --> 00:19:11,919
under a a

551
00:19:11,919 --> 00:19:13,440
an information theoretical conjecture

552
00:19:13,440 --> 00:19:14,559
okay

553
00:19:14,559 --> 00:19:16,320
um

554
00:19:16,320 --> 00:19:18,320
but this is interesting because this

555
00:19:18,320 --> 00:19:21,360
type of oblivious simulation is uh

556
00:19:21,360 --> 00:19:23,039
um

557
00:19:23,039 --> 00:19:25,600
uh does suffice for a classical to round

558
00:19:25,600 --> 00:19:27,919
tpc okay so it kind of shows under this

559
00:19:27,919 --> 00:19:29,600
conjecture a separation between the

560
00:19:29,600 --> 00:19:32,799
classical and quantum cases

561
00:19:33,440 --> 00:19:35,760
but we have a partial positive result as

562
00:19:35,760 --> 00:19:37,679
well that says that well

563
00:19:37,679 --> 00:19:39,440
if you um

564
00:19:39,440 --> 00:19:41,520
you know assume access to a quantum

565
00:19:41,520 --> 00:19:43,360
oracle in other words like basically

566
00:19:43,360 --> 00:19:45,840
assuming like ideal obfuscation of a

567
00:19:45,840 --> 00:19:48,160
particular quantum functionality

568
00:19:48,160 --> 00:19:49,600
then you can construct a two-round

569
00:19:49,600 --> 00:19:51,440
two-party computation protocol and this

570
00:19:51,440 --> 00:19:53,520
necessarily uses not oblivious

571
00:19:53,520 --> 00:19:55,360
simulation

572
00:19:55,360 --> 00:19:57,280
um

573
00:19:57,280 --> 00:19:59,200
but i i call it

574
00:19:59,200 --> 00:20:00,000
uh

575
00:20:00,000 --> 00:20:01,840
i'd say this is a proof of concept

576
00:20:01,840 --> 00:20:03,760
because we don't even know any

577
00:20:03,760 --> 00:20:06,480
heuristic approaches to constructing um

578
00:20:06,480 --> 00:20:08,799
you know uh obfuscation of quantum

579
00:20:08,799 --> 00:20:10,880
circuits right so

580
00:20:10,880 --> 00:20:12,720
um this is kind of at this point it's

581
00:20:12,720 --> 00:20:14,400
not even a heuristic construction it's

582
00:20:14,400 --> 00:20:16,320
just a proof of concept saying how you

583
00:20:16,320 --> 00:20:18,640
know maybe suggesting how one might

584
00:20:18,640 --> 00:20:21,679
construct such a protocol okay so again

585
00:20:21,679 --> 00:20:23,360
yeah we have these partial positive and

586
00:20:23,360 --> 00:20:24,880
negative results but

587
00:20:24,880 --> 00:20:28,559
this question is is remaining open

588
00:20:29,120 --> 00:20:30,559
so i think that's all i wanted to say

589
00:20:30,559 --> 00:20:32,640
about the tea party case i can quickly

590
00:20:32,640 --> 00:20:34,880
say

591
00:20:35,039 --> 00:20:36,400
something about

592
00:20:36,400 --> 00:20:38,240
what we do in the multi-party case and

593
00:20:38,240 --> 00:20:40,400
really i'm just going to be

594
00:20:40,400 --> 00:20:42,640
focusing on one particular issue that

595
00:20:42,640 --> 00:20:45,120
comes up in the multi-party case okay

596
00:20:45,120 --> 00:20:46,880
which is that now we have to be worried

597
00:20:46,880 --> 00:20:49,120
about the number of rounds like

598
00:20:49,120 --> 00:20:50,320
in the end we want a constant round

599
00:20:50,320 --> 00:20:52,400
protocol right so we we do not want this

600
00:20:52,400 --> 00:20:53,919
number of rounds to depend on the number

601
00:20:53,919 --> 00:20:55,840
of parties partaking in the protocol

602
00:20:55,840 --> 00:20:57,120
right

603
00:20:57,120 --> 00:20:59,200
and to see why this might be difficult

604
00:20:59,200 --> 00:21:00,240
um

605
00:21:00,240 --> 00:21:02,640
generally in a pc you know you have to

606
00:21:02,640 --> 00:21:05,120
have each party is going to first

607
00:21:05,120 --> 00:21:06,960
commit to some input that's going to be

608
00:21:06,960 --> 00:21:09,520
used in the computation okay

609
00:21:09,520 --> 00:21:11,360
and the classical setting you know

610
00:21:11,360 --> 00:21:12,720
every party can like you know

611
00:21:12,720 --> 00:21:14,240
classically commit to their classical

612
00:21:14,240 --> 00:21:15,760
input and then broadcast their

613
00:21:15,760 --> 00:21:17,520
commitment to other parties right in a

614
00:21:17,520 --> 00:21:19,919
single round

615
00:21:19,919 --> 00:21:21,520
but broadcasting quantum information is

616
00:21:21,520 --> 00:21:23,600
not possible again due to due to no

617
00:21:23,600 --> 00:21:26,080
cloning okay so

618
00:21:26,080 --> 00:21:28,240
let's look at basically how prior works

619
00:21:28,240 --> 00:21:30,400
so dg jms uh

620
00:21:30,400 --> 00:21:33,760
how this this work approaches this input

621
00:21:33,760 --> 00:21:35,360
commitment phase

622
00:21:35,360 --> 00:21:37,039
so here you have you know you have your

623
00:21:37,039 --> 00:21:39,280
quantum parties and say you want your

624
00:21:39,280 --> 00:21:42,320
first party to commit to their input x1

625
00:21:42,320 --> 00:21:43,440
what's going to happen is each of the

626
00:21:43,440 --> 00:21:45,360
parties chooses their own uniform

627
00:21:45,360 --> 00:21:48,320
randomness in the form of a clifford

628
00:21:48,320 --> 00:21:49,280
and

629
00:21:49,280 --> 00:21:50,880
party one is going to send a clifford

630
00:21:50,880 --> 00:21:52,960
encoding to party 2 of their input and

631
00:21:52,960 --> 00:21:54,720
then party 2 is going to kind of

632
00:21:54,720 --> 00:21:56,000
re-randomize this with their own

633
00:21:56,000 --> 00:21:57,760
clifford and this is going to continue

634
00:21:57,760 --> 00:22:00,080
all the way around the circle of parties

635
00:22:00,080 --> 00:22:02,000
and at the end what we end up with is

636
00:22:02,000 --> 00:22:04,000
like party one holds this encoded

637
00:22:04,000 --> 00:22:07,200
quantum state but the parties all share

638
00:22:07,200 --> 00:22:08,640
the encoding key

639
00:22:08,640 --> 00:22:10,559
okay so granny key is kind of secret

640
00:22:10,559 --> 00:22:12,640
shared among all the parties and this is

641
00:22:12,640 --> 00:22:15,039
uh a good enough commitment to allow uh

642
00:22:15,039 --> 00:22:17,120
npc

643
00:22:17,120 --> 00:22:17,840
so

644
00:22:17,840 --> 00:22:19,679
the issue with this is that like the

645
00:22:19,679 --> 00:22:21,039
number of rounds like really grows with

646
00:22:21,039 --> 00:22:22,480
a number of parties right you're sending

647
00:22:22,480 --> 00:22:24,559
this quantum state around and around in

648
00:22:24,559 --> 00:22:27,760
a circle so our approach to round

649
00:22:27,760 --> 00:22:30,880
collapse uh this um step

650
00:22:30,880 --> 00:22:33,440
is to use teleportation okay so

651
00:22:33,440 --> 00:22:34,880
in the first round we'll have parties

652
00:22:34,880 --> 00:22:35,919
like set up

653
00:22:35,919 --> 00:22:37,760
api pairs with each other

654
00:22:37,760 --> 00:22:38,640
okay

655
00:22:38,640 --> 00:22:40,799
and then what we're going to do is have

656
00:22:40,799 --> 00:22:42,000
the parties

657
00:22:42,000 --> 00:22:43,919
you know teleport and apply their random

658
00:22:43,919 --> 00:22:46,720
cliffords like simultaneously like in a

659
00:22:46,720 --> 00:22:48,559
single round right

660
00:22:48,559 --> 00:22:49,280
and

661
00:22:49,280 --> 00:22:51,520
this basically leads to the same result

662
00:22:51,520 --> 00:22:52,960
as before except that there are

663
00:22:52,960 --> 00:22:54,960
teleportation errors now inserted

664
00:22:54,960 --> 00:22:57,840
between all of these cliffords

665
00:22:57,840 --> 00:22:59,679
but this is okay because we can then use

666
00:22:59,679 --> 00:23:02,480
classical mpc again in like a around

667
00:23:02,480 --> 00:23:03,919
efficient way to correct these

668
00:23:03,919 --> 00:23:06,080
teleportation errors so this whole input

669
00:23:06,080 --> 00:23:07,840
commitment phase can be done in a

670
00:23:07,840 --> 00:23:10,320
constant number of rounds

671
00:23:10,320 --> 00:23:11,919
okay and so this is kind of the one

672
00:23:11,919 --> 00:23:14,000
issue i wanted to highlight and i you

673
00:23:14,000 --> 00:23:14,720
know

674
00:23:14,720 --> 00:23:16,559
in the paper we you know leverage this

675
00:23:16,559 --> 00:23:18,159
and combined with other techniques to

676
00:23:18,159 --> 00:23:19,600
eventually arrive at a full-fledged

677
00:23:19,600 --> 00:23:21,600
constant round multi-party quantum

678
00:23:21,600 --> 00:23:23,520
computation protocol in particular

679
00:23:23,520 --> 00:23:25,840
assuming to message ot we get a five

680
00:23:25,840 --> 00:23:28,640
round and pqc protocol and then we also

681
00:23:28,640 --> 00:23:30,559
have the same you know same sort of

682
00:23:30,559 --> 00:23:32,480
result as in the two-party case we can

683
00:23:32,480 --> 00:23:33,919
do um

684
00:23:33,919 --> 00:23:35,840
even just two rounds

685
00:23:35,840 --> 00:23:37,120
as long as we allow some input

686
00:23:37,120 --> 00:23:38,559
independent pre-processing and this

687
00:23:38,559 --> 00:23:40,159
result again

688
00:23:40,159 --> 00:23:42,000
follows from sub-exponentially secure

689
00:23:42,000 --> 00:23:43,840
lwe so this is

690
00:23:43,840 --> 00:23:45,279
uh our result statements in the

691
00:23:45,279 --> 00:23:48,159
multi-party setting

692
00:23:48,480 --> 00:23:50,320
um so now yeah i just wanted to quickly

693
00:23:50,320 --> 00:23:52,480
recap so basically you know what this

694
00:23:52,480 --> 00:23:54,559
work is is an initiation of the study of

695
00:23:54,559 --> 00:23:56,640
round efficiency in multi-party quantum

696
00:23:56,640 --> 00:23:57,840
computation

697
00:23:57,840 --> 00:24:00,240
and um there's another you know there's

698
00:24:00,240 --> 00:24:03,120
a concurrent work also um um appearing

699
00:24:03,120 --> 00:24:05,200
at uh this crypto conference that also

700
00:24:05,200 --> 00:24:06,159
um

701
00:24:06,159 --> 00:24:09,120
studies around efficiency okay

702
00:24:09,120 --> 00:24:10,799
um

703
00:24:10,799 --> 00:24:14,159
and i want to also remind uh you of like

704
00:24:14,159 --> 00:24:16,240
uh there's basically a few interesting

705
00:24:16,240 --> 00:24:17,360
challenges

706
00:24:17,360 --> 00:24:18,960
that are that arise that are specific to

707
00:24:18,960 --> 00:24:21,279
the quantum setting uh when you want to

708
00:24:21,279 --> 00:24:22,880
you know attempt to

709
00:24:22,880 --> 00:24:24,559
kind of come up with round efficient

710
00:24:24,559 --> 00:24:25,760
protocols

711
00:24:25,760 --> 00:24:28,080
um you know things like functionalities

712
00:24:28,080 --> 00:24:29,600
cannot be made deterministic which is

713
00:24:29,600 --> 00:24:31,039
quite useful in the classical setting

714
00:24:31,039 --> 00:24:33,279
inputs can't be cloned

715
00:24:33,279 --> 00:24:34,720
in quantum information can't be

716
00:24:34,720 --> 00:24:36,320
broadcast and so like these are useful

717
00:24:36,320 --> 00:24:37,840
things in the classical setting and we

718
00:24:37,840 --> 00:24:40,320
need different uh techniques

719
00:24:40,320 --> 00:24:41,120
um

720
00:24:41,120 --> 00:24:43,360
in the quantum setting uh to obtain kind

721
00:24:43,360 --> 00:24:47,279
of similar results right

722
00:24:47,279 --> 00:24:49,440
and then finally uh this open question

723
00:24:49,440 --> 00:24:50,880
that i think is pretty interesting is

724
00:24:50,880 --> 00:24:52,960
like does does two round or like round

725
00:24:52,960 --> 00:24:55,039
optimal secure computation exist right

726
00:24:55,039 --> 00:24:57,279
we have these these two kind of partial

727
00:24:57,279 --> 00:24:58,559
results

728
00:24:58,559 --> 00:24:59,679
um

729
00:24:59,679 --> 00:25:01,600
and like kind of this

730
00:25:01,600 --> 00:25:03,600
uh partial negative result that i hope

731
00:25:03,600 --> 00:25:06,240
is kind of just uh eventually going to

732
00:25:06,240 --> 00:25:07,919
point to um

733
00:25:07,919 --> 00:25:10,400
uh basically uh new methods for

734
00:25:10,400 --> 00:25:12,080
obtaining eventually a positive result

735
00:25:12,080 --> 00:25:14,559
but this question is is remaining open

736
00:25:14,559 --> 00:25:15,679
so

737
00:25:15,679 --> 00:25:16,559
um

738
00:25:16,559 --> 00:25:18,320
yeah that's all i wanted to say so so

739
00:25:18,320 --> 00:25:21,799
thank you for listening

