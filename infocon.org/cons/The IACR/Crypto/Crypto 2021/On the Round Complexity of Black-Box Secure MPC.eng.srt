1
00:00:00,080 --> 00:00:02,320
hi everyone i am akshay aram and i am

2
00:00:02,320 --> 00:00:04,400
going to talk about the round complexity

3
00:00:04,400 --> 00:00:06,319
of black box npc

4
00:00:06,319 --> 00:00:08,639
this is based on joint work with yuwal

5
00:00:08,639 --> 00:00:13,679
ishai dakshita kurana and amit sahai

6
00:00:13,679 --> 00:00:15,519
let me start this talk by briefly

7
00:00:15,519 --> 00:00:17,119
recalling the notion of secure

8
00:00:17,119 --> 00:00:19,359
multi-party computation

9
00:00:19,359 --> 00:00:22,160
here there are several parties and each

10
00:00:22,160 --> 00:00:24,720
party has its own private input

11
00:00:24,720 --> 00:00:26,720
so we denote the private input of the

12
00:00:26,720 --> 00:00:29,279
ayat parking by xx

13
00:00:29,279 --> 00:00:32,320
the parties also have a common input

14
00:00:32,320 --> 00:00:33,840
which is the description of some

15
00:00:33,840 --> 00:00:35,200
function f

16
00:00:35,200 --> 00:00:37,520
and the parties want to learn the output

17
00:00:37,520 --> 00:00:39,840
of this function applied on the private

18
00:00:39,840 --> 00:00:41,360
inputs

19
00:00:41,360 --> 00:00:43,440
a secure multi-party computation

20
00:00:43,440 --> 00:00:44,800
protocol

21
00:00:44,800 --> 00:00:48,079
enables the parties to learn this output

22
00:00:48,079 --> 00:00:50,800
while hiding everything else about their

23
00:00:50,800 --> 00:00:53,199
private inputs

24
00:00:53,199 --> 00:00:55,280
in this talk we are interested in

25
00:00:55,280 --> 00:00:57,760
answering the following question

26
00:00:57,760 --> 00:01:00,320
what is the round complexity of black

27
00:01:00,320 --> 00:01:03,520
box malicious secure mpc in the plane

28
00:01:03,520 --> 00:01:04,959
mode

29
00:01:04,959 --> 00:01:07,840
by round complexity we mean the number

30
00:01:07,840 --> 00:01:10,479
of sequential messages that need to be

31
00:01:10,479 --> 00:01:12,880
exchanged between the parties during the

32
00:01:12,880 --> 00:01:14,799
protocol execution

33
00:01:14,799 --> 00:01:17,040
and this is a very very important

34
00:01:17,040 --> 00:01:19,520
efficiency determining factor if the

35
00:01:19,520 --> 00:01:22,240
protocol is to be run over networks with

36
00:01:22,240 --> 00:01:23,759
high latency

37
00:01:23,759 --> 00:01:25,759
hence it's important to minimize the

38
00:01:25,759 --> 00:01:28,479
round complexity of an mpc protocol as

39
00:01:28,479 --> 00:01:31,119
much as possible

40
00:01:31,119 --> 00:01:34,320
by black box protocols we mean those

41
00:01:34,320 --> 00:01:37,119
protocols that only make input output

42
00:01:37,119 --> 00:01:39,280
calls to the underlying cryptographic

43
00:01:39,280 --> 00:01:40,640
building blocks

44
00:01:40,640 --> 00:01:43,280
and these protocols are independent of

45
00:01:43,280 --> 00:01:44,799
how these building blocks are

46
00:01:44,799 --> 00:01:46,320
implemented

47
00:01:46,320 --> 00:01:49,119
generally black box protocols tend to be

48
00:01:49,119 --> 00:01:51,840
much more computationally efficient than

49
00:01:51,840 --> 00:01:54,399
their non-black box counterparts and

50
00:01:54,399 --> 00:01:57,439
hence obtaining such black box protocol

51
00:01:57,439 --> 00:02:00,000
is viewed as a first step towards

52
00:02:00,000 --> 00:02:03,360
achieving computational efficiency

53
00:02:03,360 --> 00:02:06,479
and by plane model we mean a model that

54
00:02:06,479 --> 00:02:08,720
does not assume any form of trusted

55
00:02:08,720 --> 00:02:09,679
setup

56
00:02:09,679 --> 00:02:11,680
this specifically means that we do not

57
00:02:11,680 --> 00:02:14,319
assume any common random or reference

58
00:02:14,319 --> 00:02:16,640
strings that is available to the parties

59
00:02:16,640 --> 00:02:19,040
nor we assume any sort of correlated

60
00:02:19,040 --> 00:02:20,879
randomness that could be shared between

61
00:02:20,879 --> 00:02:24,160
the parties so this is the basic setting

62
00:02:24,160 --> 00:02:26,959
in which mpc could be constructed and

63
00:02:26,959 --> 00:02:29,360
it's very important to construct npc

64
00:02:29,360 --> 00:02:31,519
protocols that does not assume any form

65
00:02:31,519 --> 00:02:34,319
of trusted setup

66
00:02:34,319 --> 00:02:36,879
so before moving on let me briefly

67
00:02:36,879 --> 00:02:39,440
summarize the prior work in constructing

68
00:02:39,440 --> 00:02:41,920
round efficient multi-party computation

69
00:02:41,920 --> 00:02:44,800
protocols in the plane mode

70
00:02:44,800 --> 00:02:47,920
the work of ger get all from europe 2016

71
00:02:47,920 --> 00:02:50,720
showed that four rounds are necessary in

72
00:02:50,720 --> 00:02:53,280
order to construct secure multi-party

73
00:02:53,280 --> 00:02:55,519
computation protocols in the plain model

74
00:02:55,519 --> 00:02:57,840
against malicious adversities

75
00:02:57,840 --> 00:03:00,080
and this lower bond holds even when

76
00:03:00,080 --> 00:03:02,000
considering black box as well as

77
00:03:02,000 --> 00:03:04,480
non-black box protocols

78
00:03:04,480 --> 00:03:07,440
a sequence of recent exciting works have

79
00:03:07,440 --> 00:03:09,360
in fact shown that four rounds are

80
00:03:09,360 --> 00:03:11,440
sufficient for constructing multi-party

81
00:03:11,440 --> 00:03:13,440
computation against malicious

82
00:03:13,440 --> 00:03:16,000
adversaries in the plane model

83
00:03:16,000 --> 00:03:19,120
unfortunately all these protocols make

84
00:03:19,120 --> 00:03:21,280
non-black box use of cryptographic

85
00:03:21,280 --> 00:03:23,519
primitive and hence they have a

86
00:03:23,519 --> 00:03:27,200
prohibitively high computational cost

87
00:03:27,200 --> 00:03:29,519
on the other hand the state-of-the-art

88
00:03:29,519 --> 00:03:31,920
black box protocols in the plane model

89
00:03:31,920 --> 00:03:34,080
have a large number of rounds

90
00:03:34,080 --> 00:03:38,720
for instance the work of goyal from 2011

91
00:03:38,720 --> 00:03:41,040
gave a black box protocol whose round

92
00:03:41,040 --> 00:03:44,480
complexity was more than 50.

93
00:03:44,480 --> 00:03:46,319
so the main question we are interested

94
00:03:46,319 --> 00:03:48,640
in answering here is that is such a

95
00:03:48,640 --> 00:03:51,280
large round complexity necessary in

96
00:03:51,280 --> 00:03:53,360
order to construct black box protocols

97
00:03:53,360 --> 00:03:55,840
in the play model

98
00:03:55,840 --> 00:03:59,040
be sure that this is not the case

99
00:03:59,040 --> 00:04:01,200
in our work we show that for an

100
00:04:01,200 --> 00:04:03,920
interesting subclass of functions we can

101
00:04:03,920 --> 00:04:06,000
in fact construct a round optimal that

102
00:04:06,000 --> 00:04:09,280
is a four round black box mpc protocol

103
00:04:09,280 --> 00:04:12,799
and this mpc protocol makes black box

104
00:04:12,799 --> 00:04:14,799
use of a public key encryption scheme

105
00:04:14,799 --> 00:04:17,199
with pseudo-random public keys and such

106
00:04:17,199 --> 00:04:19,120
an encryption scheme can be constructed

107
00:04:19,120 --> 00:04:21,519
based on many standard cryptographic

108
00:04:21,519 --> 00:04:24,560
hardness assumptions

109
00:04:25,680 --> 00:04:28,320
for general functions we give a 5 round

110
00:04:28,320 --> 00:04:31,600
black box mpc protocol and this protocol

111
00:04:31,600 --> 00:04:33,520
makes black box use of a public key

112
00:04:33,520 --> 00:04:35,759
encryption with sudo random public keys

113
00:04:35,759 --> 00:04:37,919
as well as a two round semi-malicious

114
00:04:37,919 --> 00:04:40,639
oblivious transfer protocol

115
00:04:40,639 --> 00:04:42,400
semi-malicious security is a

116
00:04:42,400 --> 00:04:44,080
strengthening of the standard

117
00:04:44,080 --> 00:04:47,199
semi-honest security wherein we allow

118
00:04:47,199 --> 00:04:49,680
the adversarial parties to choose their

119
00:04:49,680 --> 00:04:51,440
own random things

120
00:04:51,440 --> 00:04:53,199
again a two-round semi-malicious

121
00:04:53,199 --> 00:04:55,680
oblivious transfer can be constructed

122
00:04:55,680 --> 00:04:57,680
based on a variety of standard

123
00:04:57,680 --> 00:05:00,960
cryptographic hardness assumptions

124
00:05:00,960 --> 00:05:03,520
somewhat surprisingly we use the

125
00:05:03,520 --> 00:05:06,080
techniques for constructing these mpc

126
00:05:06,080 --> 00:05:08,639
protocols in the plane model to give

127
00:05:08,639 --> 00:05:10,560
better protocols in the correlated

128
00:05:10,560 --> 00:05:12,160
randomness setting

129
00:05:12,160 --> 00:05:14,720
specifically assuming a special form of

130
00:05:14,720 --> 00:05:17,440
multi-party correlation we construct a

131
00:05:17,440 --> 00:05:20,240
two-round malicious secure protocol that

132
00:05:20,240 --> 00:05:22,800
makes black box use of a two-round

133
00:05:22,800 --> 00:05:25,440
augmented semi-malicious npc

134
00:05:25,440 --> 00:05:28,160
by augmented semi-malicious npc we mean

135
00:05:28,160 --> 00:05:30,880
a semi-malicious mpc protocol that

136
00:05:30,880 --> 00:05:33,199
satisfies some weak form of adaptive

137
00:05:33,199 --> 00:05:35,520
security with aerations

138
00:05:35,520 --> 00:05:38,240
so prior protocols in the multi-party

139
00:05:38,240 --> 00:05:39,919
correlation model

140
00:05:39,919 --> 00:05:42,160
made extensive use of the protocol

141
00:05:42,160 --> 00:05:44,560
garbling technique and hence had a very

142
00:05:44,560 --> 00:05:46,639
high computational cost on the other

143
00:05:46,639 --> 00:05:49,840
hand our protocols are extremely simple

144
00:05:49,840 --> 00:05:51,440
so as a

145
00:05:51,440 --> 00:05:53,280
two interesting corollaries of this

146
00:05:53,280 --> 00:05:55,600
result are as follows

147
00:05:55,600 --> 00:05:58,400
firstly uh we give a two round protocol

148
00:05:58,400 --> 00:06:01,199
for computing branching programs that

149
00:06:01,199 --> 00:06:02,080
are

150
00:06:02,080 --> 00:06:04,319
that have statistical security against

151
00:06:04,319 --> 00:06:06,400
malicious adversaries

152
00:06:06,400 --> 00:06:08,800
second we also give a two round protocol

153
00:06:08,800 --> 00:06:11,600
for log depth arithmetic circuits that

154
00:06:11,600 --> 00:06:13,759
makes black box use of the underlying

155
00:06:13,759 --> 00:06:15,600
field

156
00:06:15,600 --> 00:06:17,759
so in the rest of the talk i'll mainly

157
00:06:17,759 --> 00:06:19,759
focus on our construction of a

158
00:06:19,759 --> 00:06:21,759
forerunned protocol for an interesting

159
00:06:21,759 --> 00:06:24,960
subclass of functions

160
00:06:26,080 --> 00:06:27,840
so the the functionality that we

161
00:06:27,840 --> 00:06:30,240
consider is what we call as the pairwise

162
00:06:30,240 --> 00:06:31,919
ot functionality

163
00:06:31,919 --> 00:06:34,720
to understand this better consider

164
00:06:34,720 --> 00:06:37,600
multiple parties and in the spareways ot

165
00:06:37,600 --> 00:06:41,759
functionality for every ordered pair inj

166
00:06:41,759 --> 00:06:45,360
we compute a ot instance between i and j

167
00:06:45,360 --> 00:06:48,479
where j acts as the sender and i access

168
00:06:48,479 --> 00:06:50,160
the receiver

169
00:06:50,160 --> 00:06:52,080
so for instance between the first and

170
00:06:52,080 --> 00:06:55,039
the second party we run an ot instance

171
00:06:55,039 --> 00:06:57,680
called as ot12 where the first party

172
00:06:57,680 --> 00:06:59,440
access the receiver and second party

173
00:06:59,440 --> 00:07:01,360
access the sender

174
00:07:01,360 --> 00:07:04,319
simultaneously we also compute a ot

175
00:07:04,319 --> 00:07:05,680
instance between the first and the

176
00:07:05,680 --> 00:07:08,560
second part t called ot21 where the

177
00:07:08,560 --> 00:07:10,800
second party access the receiver and the

178
00:07:10,800 --> 00:07:12,960
first party access the sender

179
00:07:12,960 --> 00:07:14,639
similarly between the first and the

180
00:07:14,639 --> 00:07:17,680
fourth party we run an instance ot41

181
00:07:17,680 --> 00:07:19,280
where the fourth party acts as the

182
00:07:19,280 --> 00:07:21,440
receiver and the first party acts as the

183
00:07:21,440 --> 00:07:23,199
sender and so on

184
00:07:23,199 --> 00:07:25,520
so why is this pairwise ot functionality

185
00:07:25,520 --> 00:07:26,880
interesting

186
00:07:26,880 --> 00:07:28,880
it's interesting because it readily

187
00:07:28,880 --> 00:07:30,960
implies a protocol for pair-based

188
00:07:30,960 --> 00:07:33,360
two-party computation we where you

189
00:07:33,360 --> 00:07:35,680
compute some uh two-party functionality

190
00:07:35,680 --> 00:07:37,919
between each ordered pair of parties

191
00:07:37,919 --> 00:07:39,919
where one party acts as the receiver and

192
00:07:39,919 --> 00:07:42,080
the other party access the sender and

193
00:07:42,080 --> 00:07:44,720
this result follows directly from the

194
00:07:44,720 --> 00:07:47,039
work of ishay at all in

195
00:07:47,039 --> 00:07:49,120
2011

196
00:07:49,120 --> 00:07:50,879
and the main question we are interested

197
00:07:50,879 --> 00:07:53,360
in uh solving is can we construct a

198
00:07:53,360 --> 00:07:55,840
foreground protocol for computing this

199
00:07:55,840 --> 00:07:58,960
pairwise ot functionality

200
00:07:58,960 --> 00:08:01,120
before moving on to our construction let

201
00:08:01,120 --> 00:08:03,199
me explain the main challenge involved

202
00:08:03,199 --> 00:08:04,960
in constructing such a

203
00:08:04,960 --> 00:08:07,680
ot protocol

204
00:08:07,680 --> 00:08:10,080
a natural attempt that one could think

205
00:08:10,080 --> 00:08:12,479
of is to take a

206
00:08:12,479 --> 00:08:15,120
protocol that securely implements the ot

207
00:08:15,120 --> 00:08:16,879
functionality between a sender and

208
00:08:16,879 --> 00:08:18,000
receiver

209
00:08:18,000 --> 00:08:20,800
and use this protocol and run it in

210
00:08:20,800 --> 00:08:23,840
parallel for computing each of these ot

211
00:08:23,840 --> 00:08:25,360
instance in the pairwise ot

212
00:08:25,360 --> 00:08:27,360
functionality

213
00:08:27,360 --> 00:08:29,599
so this satisfies correctness

214
00:08:29,599 --> 00:08:32,000
but unfortunately this might always not

215
00:08:32,000 --> 00:08:33,200
be secure

216
00:08:33,200 --> 00:08:36,320
so to see why this is the case consider

217
00:08:36,320 --> 00:08:38,559
the setting where the adversary corrupts

218
00:08:38,559 --> 00:08:40,640
the second party

219
00:08:40,640 --> 00:08:43,360
so this corrupted party which is the

220
00:08:43,360 --> 00:08:45,120
second party

221
00:08:45,120 --> 00:08:48,320
acts as a receiver in one of the ot

222
00:08:48,320 --> 00:08:51,040
instance with the first party

223
00:08:51,040 --> 00:08:54,560
so the first party acts as a sender and

224
00:08:54,560 --> 00:08:56,720
this corrupted party acts as a receiver

225
00:08:56,720 --> 00:08:58,680
in one of the ot instances

226
00:08:58,680 --> 00:09:02,240
simultaneously this corrupted party acts

227
00:09:02,240 --> 00:09:04,000
as a sender

228
00:09:04,000 --> 00:09:05,760
with the third party acting as a

229
00:09:05,760 --> 00:09:09,360
receiver in another ot instance

230
00:09:09,360 --> 00:09:11,600
so what this corrupted party could do is

231
00:09:11,600 --> 00:09:14,720
that it could take the messages that it

232
00:09:14,720 --> 00:09:17,040
received from the first party acting as

233
00:09:17,040 --> 00:09:18,320
the sender

234
00:09:18,320 --> 00:09:21,360
it could maul these messages to generate

235
00:09:21,360 --> 00:09:22,560
new messages

236
00:09:22,560 --> 00:09:25,120
to be sent to the third party

237
00:09:25,120 --> 00:09:27,680
a result of this morning attack the

238
00:09:27,680 --> 00:09:30,000
inputs that the adversarial party could

239
00:09:30,000 --> 00:09:30,880
use

240
00:09:30,880 --> 00:09:33,760
may depend on the inputs of the honest

241
00:09:33,760 --> 00:09:34,800
sender

242
00:09:34,800 --> 00:09:36,560
and this violates the security

243
00:09:36,560 --> 00:09:38,320
requirement

244
00:09:38,320 --> 00:09:40,800
so in order to prevent such an attack

245
00:09:40,800 --> 00:09:43,440
one needs to make use of what is called

246
00:09:43,440 --> 00:09:47,440
as a non-malleable ot protocol

247
00:09:47,440 --> 00:09:50,160
and our approach of constructing such a

248
00:09:50,160 --> 00:09:53,040
non-malleable ot protocol involves the

249
00:09:53,040 --> 00:09:55,519
following steps

250
00:09:55,519 --> 00:09:57,839
first take a foreign oblivious transfer

251
00:09:57,839 --> 00:10:00,800
protocol with some special properties

252
00:10:00,800 --> 00:10:03,680
and transform this protocol into a four

253
00:10:03,680 --> 00:10:06,880
round send a non-malleable ot protocol

254
00:10:06,880 --> 00:10:09,279
by sender non-malleability we mean a

255
00:10:09,279 --> 00:10:11,760
protocol where the adversary of sender

256
00:10:11,760 --> 00:10:14,000
inputs cannot depend on the honest

257
00:10:14,000 --> 00:10:16,320
party's inputs

258
00:10:16,320 --> 00:10:18,480
so we take such a foreign send a

259
00:10:18,480 --> 00:10:21,680
nonvaluable ot protocol and transform it

260
00:10:21,680 --> 00:10:23,839
into a forerunned protocol that computes

261
00:10:23,839 --> 00:10:27,600
the pairwise ot functionality

262
00:10:28,000 --> 00:10:30,079
so the second transformation from four

263
00:10:30,079 --> 00:10:31,920
round sender non-malleable ot to

264
00:10:31,920 --> 00:10:34,800
forerunned pairwise ot involves standard

265
00:10:34,800 --> 00:10:36,640
tools and techniques

266
00:10:36,640 --> 00:10:38,800
whereas the first transformation that is

267
00:10:38,800 --> 00:10:40,959
from a four round ot protocol with some

268
00:10:40,959 --> 00:10:43,120
special properties to a four round send

269
00:10:43,120 --> 00:10:45,839
a non-malleable ot involves the use of

270
00:10:45,839 --> 00:10:48,160
split state non-malleable goods

271
00:10:48,160 --> 00:10:50,240
and finally we construct this four round

272
00:10:50,240 --> 00:10:52,480
special oblivious transfer protocol

273
00:10:52,480 --> 00:10:54,880
based on any public key encryption with

274
00:10:54,880 --> 00:10:57,279
pseudo-random publicly

275
00:10:57,279 --> 00:10:59,519
so in the rest of the talk i i'll mainly

276
00:10:59,519 --> 00:11:02,240
focus on constructing a four round send

277
00:11:02,240 --> 00:11:04,720
a non-malleable ot protocol from a four

278
00:11:04,720 --> 00:11:06,640
on ot protocol with some special

279
00:11:06,640 --> 00:11:09,839
properties and before going on to that

280
00:11:09,839 --> 00:11:11,200
ah we'll

281
00:11:11,200 --> 00:11:13,120
first define what is meant by a split

282
00:11:13,120 --> 00:11:16,320
state non-malleable code

283
00:11:16,320 --> 00:11:18,720
a split state non-malable code involves

284
00:11:18,720 --> 00:11:21,279
an encoding and a decoding scheme

285
00:11:21,279 --> 00:11:24,320
the encoder takes a message m and

286
00:11:24,320 --> 00:11:26,880
encodes this message into two states the

287
00:11:26,880 --> 00:11:29,760
left state and the right state

288
00:11:29,760 --> 00:11:31,920
the decoder takes these left state and

289
00:11:31,920 --> 00:11:35,040
the right state and outputs the message

290
00:11:35,040 --> 00:11:37,279
the non malleability property requires

291
00:11:37,279 --> 00:11:38,640
that

292
00:11:38,640 --> 00:11:41,120
if the left and the right states are

293
00:11:41,120 --> 00:11:43,600
tampered with two independent functions

294
00:11:43,600 --> 00:11:47,920
f and g into states l tilde and r tilde

295
00:11:47,920 --> 00:11:49,839
and if we run the decoder on these

296
00:11:49,839 --> 00:11:52,000
tampered states l tilde and r delta to

297
00:11:52,000 --> 00:11:54,720
obtain the tampered message m tilde

298
00:11:54,720 --> 00:11:56,880
then we are guaranteed that m tilde is

299
00:11:56,880 --> 00:11:59,760
independent of the original presentation

300
00:11:59,760 --> 00:12:01,680
and for our purpose we need a

301
00:12:01,680 --> 00:12:04,639
non-malleable code with a

302
00:12:04,639 --> 00:12:06,399
special property called a symmetric

303
00:12:06,399 --> 00:12:09,200
decoder specifically we require the

304
00:12:09,200 --> 00:12:11,760
output of the decoding when given l and

305
00:12:11,760 --> 00:12:13,920
r to be same as the output of the

306
00:12:13,920 --> 00:12:16,399
decoding when given rna that is even if

307
00:12:16,399 --> 00:12:18,720
you swap these two states the output of

308
00:12:18,720 --> 00:12:21,440
the decoding remains the same and it's

309
00:12:21,440 --> 00:12:23,920
easy to add the symmetric decodability

310
00:12:23,920 --> 00:12:26,160
property on top of any non-malleable

311
00:12:26,160 --> 00:12:28,399
code

312
00:12:29,279 --> 00:12:31,839
so let's see how does non-valuable codes

313
00:12:31,839 --> 00:12:33,360
help in constructing a sender

314
00:12:33,360 --> 00:12:37,399
non-malleable ot protocol

315
00:12:38,079 --> 00:12:39,760
so in order to construct the sender

316
00:12:39,760 --> 00:12:41,279
non-malleability

317
00:12:41,279 --> 00:12:43,440
we use the same template that we

318
00:12:43,440 --> 00:12:45,920
discussed before but instead of running

319
00:12:45,920 --> 00:12:49,600
a ot protocol in parallel we run a two

320
00:12:49,600 --> 00:12:52,399
party computation protocol for computing

321
00:12:52,399 --> 00:12:56,399
a special function f in parallel

322
00:12:56,399 --> 00:12:58,959
so we design this function in a very

323
00:12:58,959 --> 00:13:01,519
special way that allows us to argue the

324
00:13:01,519 --> 00:13:04,839
sender non malleability property of this

325
00:13:04,839 --> 00:13:08,399
proton okay so let's see how this

326
00:13:08,399 --> 00:13:10,639
function is constructed

327
00:13:10,639 --> 00:13:11,600
so this

328
00:13:11,600 --> 00:13:13,519
function f is a two party function

329
00:13:13,519 --> 00:13:16,399
between a sender which is on the left

330
00:13:16,399 --> 00:13:18,399
and a receiver which is on the

331
00:13:18,399 --> 00:13:19,360
right

332
00:13:19,360 --> 00:13:21,839
so the sender inputs to this function

333
00:13:21,839 --> 00:13:25,680
consists of strings m0 m1

334
00:13:25,680 --> 00:13:28,720
and encoding l0 r0 and another encoding

335
00:13:28,720 --> 00:13:31,920
l1 r1 using the non malleable code

336
00:13:31,920 --> 00:13:33,920
the receiver inputs to this function

337
00:13:33,920 --> 00:13:35,920
consists of a bit b

338
00:13:35,920 --> 00:13:37,760
and another bit c

339
00:13:37,760 --> 00:13:40,399
so b is the choice bit that is to be

340
00:13:40,399 --> 00:13:43,440
used in ot and c is another

341
00:13:43,440 --> 00:13:45,600
so what this function does is the

342
00:13:45,600 --> 00:13:47,199
following

343
00:13:47,199 --> 00:13:49,440
so it first checks if

344
00:13:49,440 --> 00:13:54,240
decoding of l0 from r0 is equal to m0

345
00:13:54,240 --> 00:13:56,800
it then checks if decoding of l1 comma

346
00:13:56,800 --> 00:13:59,199
r1 is equal to n1

347
00:13:59,199 --> 00:14:01,440
if both these checks pass

348
00:14:01,440 --> 00:14:02,959
then it sets

349
00:14:02,959 --> 00:14:06,000
x comma y to be l0 comma l1 that is the

350
00:14:06,000 --> 00:14:08,000
set of two left states

351
00:14:08,000 --> 00:14:10,560
from the sender inputs if c is equal to

352
00:14:10,560 --> 00:14:11,600
0

353
00:14:11,600 --> 00:14:15,199
otherwise it sets x comma y to be the

354
00:14:15,199 --> 00:14:18,079
two right states r0 and r1 and it

355
00:14:18,079 --> 00:14:20,720
outputs mb along with x comma y to the

356
00:14:20,720 --> 00:14:22,480
receiver

357
00:14:22,480 --> 00:14:25,279
so the receiver can retrieve mb

358
00:14:25,279 --> 00:14:28,000
and it follows from the property of non

359
00:14:28,000 --> 00:14:30,399
valuable codes which states that any non

360
00:14:30,399 --> 00:14:32,880
malleable code acts as a two out of two

361
00:14:32,880 --> 00:14:34,480
secret sharing that

362
00:14:34,480 --> 00:14:37,279
given this x comma y the other string is

363
00:14:37,279 --> 00:14:40,000
hidden namely m one minus v is hidden

364
00:14:40,000 --> 00:14:42,240
and hence this function f computes the

365
00:14:42,240 --> 00:14:44,720
ot functionality

366
00:14:44,720 --> 00:14:48,639
and we can construct a protocol for

367
00:14:48,639 --> 00:14:51,519
securely computing this function f based

368
00:14:51,519 --> 00:14:54,240
on any malicious secure ot protocol and

369
00:14:54,240 --> 00:14:56,000
again this follows from the work of

370
00:14:56,000 --> 00:14:59,760
ishay at all in 2011.

371
00:14:59,760 --> 00:15:03,600
so let's see uh how a protocol for f uh

372
00:15:03,600 --> 00:15:05,360
helps in arguing the send a

373
00:15:05,360 --> 00:15:07,680
non-malleability property

374
00:15:07,680 --> 00:15:09,600
and before that let's try to see what

375
00:15:09,600 --> 00:15:12,480
the sender non malleability property so

376
00:15:12,480 --> 00:15:14,720
let's consider an adversary who corrupts

377
00:15:14,720 --> 00:15:16,320
one of these parties

378
00:15:16,320 --> 00:15:18,880
and this party acts as a

379
00:15:18,880 --> 00:15:21,600
receiver when it is interacting with the

380
00:15:21,600 --> 00:15:24,959
party uh which is acting as a sender

381
00:15:24,959 --> 00:15:26,880
and in other instance it acts as a

382
00:15:26,880 --> 00:15:29,279
sender when interacting with an honest

383
00:15:29,279 --> 00:15:31,600
party acting as the receiver

384
00:15:31,600 --> 00:15:33,680
and let's call the first interaction

385
00:15:33,680 --> 00:15:34,800
where

386
00:15:34,800 --> 00:15:37,360
the adversarial party acts as a receiver

387
00:15:37,360 --> 00:15:39,680
has the left interaction and the second

388
00:15:39,680 --> 00:15:41,519
interaction where the adversary acts as

389
00:15:41,519 --> 00:15:44,240
the sender has the right interaction

390
00:15:44,240 --> 00:15:47,040
so the sender non malleability property

391
00:15:47,040 --> 00:15:49,120
requires the following

392
00:15:49,120 --> 00:15:51,279
namely there exists a simulator

393
00:15:51,279 --> 00:15:54,000
extractor that can simulate the left

394
00:15:54,000 --> 00:15:56,800
interaction while extracting the

395
00:15:56,800 --> 00:15:58,959
implicit sender inputs used by the

396
00:15:58,959 --> 00:16:00,560
adversarial party in the right

397
00:16:00,560 --> 00:16:02,560
interaction

398
00:16:02,560 --> 00:16:04,320
in order to argue sender

399
00:16:04,320 --> 00:16:06,720
non-malleability

400
00:16:06,720 --> 00:16:10,320
it's sufficient to show the following

401
00:16:10,320 --> 00:16:12,720
let's say that the implicit receiver

402
00:16:12,720 --> 00:16:15,279
input used by the adversarial party on

403
00:16:15,279 --> 00:16:19,839
the left interaction is a choice bit b

404
00:16:19,839 --> 00:16:22,320
now the sender non-malleability property

405
00:16:22,320 --> 00:16:25,040
boils down to proving the following

406
00:16:25,040 --> 00:16:26,880
for any two

407
00:16:26,880 --> 00:16:29,360
honest parties inputs on the left namely

408
00:16:29,360 --> 00:16:34,079
m one minus b and m prime one minus b

409
00:16:34,079 --> 00:16:36,959
the implicit sender inputs used by the

410
00:16:36,959 --> 00:16:39,360
adversarial party on the right namely m

411
00:16:39,360 --> 00:16:41,519
tilde 0 and m tilde 1 are

412
00:16:41,519 --> 00:16:43,519
computationally indistinguishable in

413
00:16:43,519 --> 00:16:45,680
these two settings

414
00:16:45,680 --> 00:16:48,959
namely when the honest party uses the

415
00:16:48,959 --> 00:16:50,880
input m 1 minus b

416
00:16:50,880 --> 00:16:53,360
you consider the distribution of m delta

417
00:16:53,360 --> 00:16:55,680
0 and m delta 1 on the right

418
00:16:55,680 --> 00:16:57,360
similarly when you

419
00:16:57,360 --> 00:17:00,480
when honest party uses the input m prime

420
00:17:00,480 --> 00:17:02,639
1 minus p on the left consider the

421
00:17:02,639 --> 00:17:05,439
distribution of m delta 0 and m tilde 1

422
00:17:05,439 --> 00:17:07,679
on the right and these two distributions

423
00:17:07,679 --> 00:17:08,799
have to be computationally

424
00:17:08,799 --> 00:17:10,319
indistinguishable

425
00:17:10,319 --> 00:17:13,439
and in order to show this we make use of

426
00:17:13,439 --> 00:17:16,319
a split state non-malleable code

427
00:17:16,319 --> 00:17:20,079
so let's see how this is shown

428
00:17:20,079 --> 00:17:22,799
so consider a thought experiment

429
00:17:22,799 --> 00:17:23,760
where

430
00:17:23,760 --> 00:17:27,199
the the honest receiver on the right in

431
00:17:27,199 --> 00:17:30,160
the first experiment uses the input c

432
00:17:30,160 --> 00:17:32,960
tilde 0 and in the second experiment

433
00:17:32,960 --> 00:17:35,520
uses c tilde 1

434
00:17:35,520 --> 00:17:37,360
as a result of the correctness of the

435
00:17:37,360 --> 00:17:39,600
two party computation protocol

436
00:17:39,600 --> 00:17:42,720
this harnessed receiver will obtain l

437
00:17:42,720 --> 00:17:45,200
tilde 0 and l delta 1 in the first

438
00:17:45,200 --> 00:17:48,160
experiment and it will obtain r tilde 0

439
00:17:48,160 --> 00:17:50,640
and r tilde 1 in the second experiment

440
00:17:50,640 --> 00:17:53,520
and using l tilde 0 and r tilde 0 you

441
00:17:53,520 --> 00:17:56,480
can obtain m tilde 0 and again using l

442
00:17:56,480 --> 00:17:58,720
tilde 1 and r tilde 1 you should be able

443
00:17:58,720 --> 00:18:00,799
to obtain m delta

444
00:18:00,799 --> 00:18:03,679
now we should prove that m tilde 0 and m

445
00:18:03,679 --> 00:18:06,640
tilde 1 is independent of the the send

446
00:18:06,640 --> 00:18:08,880
or the other string which is used by the

447
00:18:08,880 --> 00:18:10,720
honest part

448
00:18:10,720 --> 00:18:13,120
in order to show this

449
00:18:13,120 --> 00:18:16,080
let's consider the case where

450
00:18:16,080 --> 00:18:18,400
in the first experiment the adversary

451
00:18:18,400 --> 00:18:20,720
uses the input with c equal to zero on

452
00:18:20,720 --> 00:18:22,880
the left interaction and in the second

453
00:18:22,880 --> 00:18:25,120
experiment the adversary uses the input

454
00:18:25,120 --> 00:18:28,160
c equal to one that is the the c tilde

455
00:18:28,160 --> 00:18:29,280
and c

456
00:18:29,280 --> 00:18:31,120
are the same

457
00:18:31,120 --> 00:18:34,240
so in this case we can use the security

458
00:18:34,240 --> 00:18:37,120
of the two-party computation protocol to

459
00:18:37,120 --> 00:18:39,600
argue that the only information that the

460
00:18:39,600 --> 00:18:42,240
adversary learns in the first experiment

461
00:18:42,240 --> 00:18:44,160
is l0 l1

462
00:18:44,160 --> 00:18:45,679
similarly

463
00:18:45,679 --> 00:18:47,280
we can again use the security of

464
00:18:47,280 --> 00:18:50,240
two-party computation to argue that the

465
00:18:50,240 --> 00:18:51,919
only information that the adversary

466
00:18:51,919 --> 00:18:54,240
learns about the honest party's other

467
00:18:54,240 --> 00:18:56,960
input is r0 comma r1

468
00:18:56,960 --> 00:18:58,480
so

469
00:18:58,480 --> 00:19:03,200
we notice that l tilde 0 l tilde 1 is

470
00:19:03,200 --> 00:19:06,640
a function of l 0 l 1 in the first case

471
00:19:06,640 --> 00:19:09,840
and r tilde 0 r tilde 1 is a function of

472
00:19:09,840 --> 00:19:12,240
r0 comma r1

473
00:19:12,240 --> 00:19:15,280
hence this constitutes a valid split

474
00:19:15,280 --> 00:19:17,840
state tampering of the non malleable

475
00:19:17,840 --> 00:19:20,640
code and hence we should be able to use

476
00:19:20,640 --> 00:19:22,960
the security of the non malleable code

477
00:19:22,960 --> 00:19:25,280
in order to argue that m delta 0 and

478
00:19:25,280 --> 00:19:27,919
tilde 1 is independent of the sender's

479
00:19:27,919 --> 00:19:31,200
string m 1 minus v

480
00:19:31,200 --> 00:19:33,919
however in the first case we considered

481
00:19:33,919 --> 00:19:36,880
the setting where c is same as c delta

482
00:19:36,880 --> 00:19:39,200
but this need not always be the case so

483
00:19:39,200 --> 00:19:41,360
let us consider the case where c equal

484
00:19:41,360 --> 00:19:43,679
to 1 in the first experiment and c equal

485
00:19:43,679 --> 00:19:45,919
to 0 in the second experiment

486
00:19:45,919 --> 00:19:48,080
again via the security of the 2 party

487
00:19:48,080 --> 00:19:49,760
computation protocol

488
00:19:49,760 --> 00:19:51,760
we can argue that the only information

489
00:19:51,760 --> 00:19:54,720
that the adversary learns is r0 comma r1

490
00:19:54,720 --> 00:19:56,400
and the only information adversary

491
00:19:56,400 --> 00:19:58,320
learns in the second experiment is l 0

492
00:19:58,320 --> 00:20:00,400
comma l 1

493
00:20:00,400 --> 00:20:03,280
so what we infer is that l tilde 0 n

494
00:20:03,280 --> 00:20:06,240
tilde 1 is a function of only r 0 r 1

495
00:20:06,240 --> 00:20:09,039
and similarly r delta 0 r tilde 1 is

496
00:20:09,039 --> 00:20:11,919
only a function of l 0 and l 1

497
00:20:11,919 --> 00:20:14,640
so now we should be able we can use the

498
00:20:14,640 --> 00:20:16,559
symmetric decoding property of the non

499
00:20:16,559 --> 00:20:19,840
malleable code to again

500
00:20:19,840 --> 00:20:22,240
show that this constitutes a valid split

501
00:20:22,240 --> 00:20:24,880
state tampering attack and now we can

502
00:20:24,880 --> 00:20:26,720
use the security of the non malleable

503
00:20:26,720 --> 00:20:29,679
code to show that n tilde 0 m tilde 1 is

504
00:20:29,679 --> 00:20:32,080
independent of sender's input m 1 minus

505
00:20:32,080 --> 00:20:33,039
p

506
00:20:33,039 --> 00:20:35,039
and of course i have swept a lot of

507
00:20:35,039 --> 00:20:37,200
details under this rug and in order for

508
00:20:37,200 --> 00:20:40,240
this protocol to work we need this uh

509
00:20:40,240 --> 00:20:42,880
the underlying two party computation for

510
00:20:42,880 --> 00:20:45,520
computing this function f to have

511
00:20:45,520 --> 00:20:47,679
something called as one rewinding sender

512
00:20:47,679 --> 00:20:50,000
security and we construct a one

513
00:20:50,000 --> 00:20:51,840
rewinding sender secure two-party

514
00:20:51,840 --> 00:20:54,480
computation protocol making black box

515
00:20:54,480 --> 00:20:56,480
use of any public key encryption with

516
00:20:56,480 --> 00:20:59,760
pseudo-random public keys

517
00:20:59,760 --> 00:21:02,799
so this is the the main ideas underlying

518
00:21:02,799 --> 00:21:04,720
the construction of a sender

519
00:21:04,720 --> 00:21:07,039
non-malleable ot and

520
00:21:07,039 --> 00:21:09,360
as i mentioned before we can transform a

521
00:21:09,360 --> 00:21:12,159
sender non-malleable ot to a pairwise ot

522
00:21:12,159 --> 00:21:14,000
protocol using standard tools and

523
00:21:14,000 --> 00:21:16,720
techniques

524
00:21:16,720 --> 00:21:19,760
so finally i would like to give a brief

525
00:21:19,760 --> 00:21:21,919
idea about our fire on protocol for

526
00:21:21,919 --> 00:21:24,159
computing general functions

527
00:21:24,159 --> 00:21:26,000
so in order to construct a firearm

528
00:21:26,000 --> 00:21:29,280
protocol we make use of the ips compiler

529
00:21:29,280 --> 00:21:31,440
that was introduced by ishai prabhakaran

530
00:21:31,440 --> 00:21:34,000
and sahai in crypto 2008.

531
00:21:34,000 --> 00:21:36,080
in order to instantiate this ips

532
00:21:36,080 --> 00:21:39,440
compiler one needs a outer protocol an

533
00:21:39,440 --> 00:21:42,880
inner protocol and a watchlist protocol

534
00:21:42,880 --> 00:21:46,159
we instantiate the outer npc protocol

535
00:21:46,159 --> 00:21:47,840
using the two-round

536
00:21:47,840 --> 00:21:50,080
client server protocol from the work of

537
00:21:50,080 --> 00:21:53,440
ishay kushilovits and pascal in 2010.

538
00:21:53,440 --> 00:21:55,039
in order to instantiate the inner

539
00:21:55,039 --> 00:21:57,520
protocol in this compiler we give a new

540
00:21:57,520 --> 00:21:59,440
construction based on the protocol

541
00:21:59,440 --> 00:22:01,039
garbling technique

542
00:22:01,039 --> 00:22:02,799
and to instantiate the watchlist

543
00:22:02,799 --> 00:22:05,600
protocol we make use of the pairwise ot

544
00:22:05,600 --> 00:22:08,240
protocol that we just discussed

545
00:22:08,240 --> 00:22:11,520
a careful combination of these protocols

546
00:22:11,520 --> 00:22:14,000
will give rise to a firearm protocol for

547
00:22:14,000 --> 00:22:16,720
computing general functions

548
00:22:16,720 --> 00:22:18,159
to conclude

549
00:22:18,159 --> 00:22:20,240
we gave a round optimal black box

550
00:22:20,240 --> 00:22:22,880
protocol for computing the pairwise ot

551
00:22:22,880 --> 00:22:26,559
functionality and this implies a black

552
00:22:26,559 --> 00:22:29,120
box protocol for computing the pairwise

553
00:22:29,120 --> 00:22:32,559
two party functionality

554
00:22:32,799 --> 00:22:36,159
using the ips compiler we also gave a

555
00:22:36,159 --> 00:22:38,400
five round black box protocol for

556
00:22:38,400 --> 00:22:40,960
computing general functions

557
00:22:40,960 --> 00:22:42,960
as mentioned before

558
00:22:42,960 --> 00:22:45,440
using these techniques we give a two

559
00:22:45,440 --> 00:22:47,360
round black box protocol in the

560
00:22:47,360 --> 00:22:50,000
correlated randomness setting and i

561
00:22:50,000 --> 00:22:52,000
encourage you to look into our paper for

562
00:22:52,000 --> 00:22:54,480
the details

563
00:22:54,480 --> 00:22:56,480
so there are plenty of interesting open

564
00:22:56,480 --> 00:22:58,640
problems from our work

565
00:22:58,640 --> 00:22:59,840
so the first

566
00:22:59,840 --> 00:23:01,840
is are there other applications of our

567
00:23:01,840 --> 00:23:02,880
techniques

568
00:23:02,880 --> 00:23:04,400
specifically

569
00:23:04,400 --> 00:23:06,080
can we combine

570
00:23:06,080 --> 00:23:08,240
the use of non malleable codes with

571
00:23:08,240 --> 00:23:10,799
other secure computation protocols to

572
00:23:10,799 --> 00:23:13,760
obtain non-malleable versions of other

573
00:23:13,760 --> 00:23:17,440
interesting cryptographic primitives

574
00:23:17,600 --> 00:23:19,840
the second question is to find other

575
00:23:19,840 --> 00:23:22,880
applications of pairwise ot protocol so

576
00:23:22,880 --> 00:23:24,720
one of the applications that we used in

577
00:23:24,720 --> 00:23:27,200
this work is to use this pairwise ot in

578
00:23:27,200 --> 00:23:28,799
order to implement the watchlist

579
00:23:28,799 --> 00:23:31,440
functionality in the ips compiler

580
00:23:31,440 --> 00:23:33,679
but are there other applications

581
00:23:33,679 --> 00:23:35,200
and finally

582
00:23:35,200 --> 00:23:37,919
can we construct a foreground protocol

583
00:23:37,919 --> 00:23:39,520
using our techniques

584
00:23:39,520 --> 00:23:42,159
we discuss some barriers in the paper of

585
00:23:42,159 --> 00:23:45,120
obtaining such a forerunned protocol

586
00:23:45,120 --> 00:23:46,159
and

587
00:23:46,159 --> 00:23:50,679
that's it thank you for your attention

588
00:23:53,520 --> 00:23:55,600
you

