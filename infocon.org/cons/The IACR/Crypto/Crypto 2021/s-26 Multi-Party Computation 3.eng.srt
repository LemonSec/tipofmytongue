1
00:00:04,160 --> 00:00:05,920
okay you're ready to go have a good

2
00:00:05,920 --> 00:00:08,240
session

3
00:00:08,880 --> 00:00:12,160
thank you for introduction

4
00:00:13,360 --> 00:00:15,120
you can start uh

5
00:00:15,120 --> 00:00:17,760
yeah i just want to introduce the people

6
00:00:17,760 --> 00:00:20,880
yeah so hi everyone and welcome to the

7
00:00:20,880 --> 00:00:23,039
uh the multi-party

8
00:00:23,039 --> 00:00:25,279
computation number

9
00:00:25,279 --> 00:00:27,599
and uh we start with uh for this session

10
00:00:27,599 --> 00:00:29,679
we start with the presentation of

11
00:00:29,679 --> 00:00:31,199
hunting you

12
00:00:31,199 --> 00:00:33,200
on the paper pushing the limits of

13
00:00:33,200 --> 00:00:34,719
valiant

14
00:00:34,719 --> 00:00:36,079
circuits

15
00:00:36,079 --> 00:00:38,879
simpler tighter and more compassion so

16
00:00:38,879 --> 00:00:42,000
highly you can start

17
00:00:42,000 --> 00:00:43,840
thanks for introduction hello everyone

18
00:00:43,840 --> 00:00:46,320
i'm haning yo from san john university

19
00:00:46,320 --> 00:00:48,079
today i'm presenting a high level

20
00:00:48,079 --> 00:00:50,800
overview of our paper about universal

21
00:00:50,800 --> 00:00:53,279
circuits

22
00:00:54,239 --> 00:00:56,079
for any circle c

23
00:00:56,079 --> 00:00:58,079
of size up to n we can efficiently

24
00:00:58,079 --> 00:01:01,039
encode c with configuration stream pc

25
00:01:01,039 --> 00:01:03,440
such as that the universal circle

26
00:01:03,440 --> 00:01:05,519
configured under pc is a functional

27
00:01:05,519 --> 00:01:08,880
equivalence to the original circle c

28
00:01:08,880 --> 00:01:11,040
and the universal circles can be seen as

29
00:01:11,040 --> 00:01:13,680
a graph object called edge universal

30
00:01:13,680 --> 00:01:17,280
graphs eog issued

31
00:01:18,799 --> 00:01:21,840
before our work the pastor says official

32
00:01:21,840 --> 00:01:26,320
eog has a size 4.5 logan and it is known

33
00:01:26,320 --> 00:01:28,400
to be lower bound

34
00:01:28,400 --> 00:01:29,799
by

35
00:01:29,799 --> 00:01:34,400
3.64 and logan ingredient framework

36
00:01:34,400 --> 00:01:37,280
in this work we give a eog construction

37
00:01:37,280 --> 00:01:40,240
of size 3 and logan and we also lower

38
00:01:40,240 --> 00:01:44,560
bound the size of our ug by 2.951 logan

39
00:01:44,560 --> 00:01:46,320
under our framework

40
00:01:46,320 --> 00:01:49,759
notice the side the size of our ut is

41
00:01:49,759 --> 00:01:52,960
even smaller than the lower boundary

42
00:01:52,960 --> 00:01:54,720
ingredients framework

43
00:01:54,720 --> 00:01:57,439
which is not a contradiction because our

44
00:01:57,439 --> 00:01:59,439
construction is not under witness

45
00:01:59,439 --> 00:02:01,439
framework

46
00:02:01,439 --> 00:02:04,560
mpc can preserve input privacy in some

47
00:02:04,560 --> 00:02:06,799
situation we may want to preserve

48
00:02:06,799 --> 00:02:09,280
functional privacy universal circuits

49
00:02:09,280 --> 00:02:10,720
can transform

50
00:02:10,720 --> 00:02:12,959
acquisition c into the configuration

51
00:02:12,959 --> 00:02:14,400
stream pc

52
00:02:14,400 --> 00:02:17,200
then we invoke mpc for secure

53
00:02:17,200 --> 00:02:19,040
computation

54
00:02:19,040 --> 00:02:21,840
well the privacy of equation c is

55
00:02:21,840 --> 00:02:22,959
preserved

56
00:02:22,959 --> 00:02:25,120
we reveal some other application in our

57
00:02:25,120 --> 00:02:27,280
paper

58
00:02:27,280 --> 00:02:32,480
a circuit is a eag on the left hand

59
00:02:32,480 --> 00:02:36,160
and a usa is an ug on the right hand

60
00:02:36,160 --> 00:02:37,360
then

61
00:02:37,360 --> 00:02:40,000
a universal circle simulates a circle

62
00:02:40,000 --> 00:02:41,840
reduces to

63
00:02:41,840 --> 00:02:43,760
eog

64
00:02:43,760 --> 00:02:47,360
reduce reduces to eog edge in binding so

65
00:02:47,360 --> 00:02:51,200
to create funding eight

66
00:02:51,200 --> 00:02:52,640
venues give

67
00:02:52,640 --> 00:02:56,640
a recursive eog construction

68
00:02:56,640 --> 00:02:59,840
reduces the problem of constructing eog

69
00:02:59,840 --> 00:03:02,959
to itself but with much smaller size

70
00:03:02,959 --> 00:03:04,640
this is achieved

71
00:03:04,640 --> 00:03:07,280
with another graph object called kiwi

72
00:03:07,280 --> 00:03:10,879
super low snk ensured

73
00:03:10,879 --> 00:03:12,480
as a fourth step

74
00:03:12,480 --> 00:03:14,879
we give our intermediate construction

75
00:03:14,879 --> 00:03:17,040
that is a functional equivalence to

76
00:03:17,040 --> 00:03:19,920
venus construction

77
00:03:19,920 --> 00:03:22,560
it has roughly same size as venus

78
00:03:22,560 --> 00:03:25,760
construction without any improvement

79
00:03:25,760 --> 00:03:28,159
further there are some issues such as

80
00:03:28,159 --> 00:03:31,680
our intermediate construction has cycles

81
00:03:31,680 --> 00:03:33,760
in other words

82
00:03:33,760 --> 00:03:36,640
the graph of wave object reconstruct

83
00:03:36,640 --> 00:03:41,599
is not even a dng not to mention an eog

84
00:03:41,599 --> 00:03:43,519
in our end construction

85
00:03:43,519 --> 00:03:46,560
we remove these cycles

86
00:03:46,560 --> 00:03:49,120
which brings additional benefits power

87
00:03:49,120 --> 00:03:52,239
and construction of much smaller size

88
00:03:52,239 --> 00:03:54,879
we give an example to show how to remove

89
00:03:54,879 --> 00:03:57,040
the

90
00:03:58,840 --> 00:04:03,040
cycle node a matrix

91
00:04:03,040 --> 00:04:05,360
node a matters is the previous node of

92
00:04:05,360 --> 00:04:07,920
load a in the smaller eog

93
00:04:07,920 --> 00:04:09,760
then we need

94
00:04:09,760 --> 00:04:12,480
age number one and age number two

95
00:04:12,480 --> 00:04:15,360
and add a little edge from the

96
00:04:15,360 --> 00:04:19,600
node a minus to the corresponding ug

97
00:04:19,600 --> 00:04:23,120
and the node a plus is the next node of

98
00:04:23,120 --> 00:04:24,240
the

99
00:04:24,240 --> 00:04:26,720
node a in the smaller ug then we need

100
00:04:26,720 --> 00:04:27,840
delete

101
00:04:27,840 --> 00:04:29,840
edge number three and the edge number

102
00:04:29,840 --> 00:04:31,040
four

103
00:04:31,040 --> 00:04:33,199
and add a little h from the

104
00:04:33,199 --> 00:04:35,840
corresponding eog

105
00:04:35,840 --> 00:04:39,919
to the to the node a mass

106
00:04:39,919 --> 00:04:43,600
so the load a can be removed since the

107
00:04:43,600 --> 00:04:46,880
degree of load a is zero

108
00:04:46,880 --> 00:04:50,080
therefore we can get a more compact

109
00:04:50,080 --> 00:04:52,880
eog construction without affecting the

110
00:04:52,880 --> 00:04:54,320
functional

111
00:04:54,320 --> 00:04:56,479
of universal h in bindings

112
00:04:56,479 --> 00:04:59,440
this summarizes the size of our ug and

113
00:04:59,440 --> 00:05:00,400
uc

114
00:05:00,400 --> 00:05:03,600
the advantage of our construction always

115
00:05:03,600 --> 00:05:06,320
minus one is minus k

116
00:05:06,320 --> 00:05:08,800
highlighted in z

117
00:05:08,800 --> 00:05:11,440
moreover we prove the lower bound of

118
00:05:11,440 --> 00:05:13,039
2.95

119
00:05:13,039 --> 00:05:14,160
logan

120
00:05:14,160 --> 00:05:17,280
for our construction

121
00:05:17,520 --> 00:05:20,720
and we get a eog construction of size

122
00:05:20,720 --> 00:05:23,520
three androgen which is very close to

123
00:05:23,520 --> 00:05:25,000
the lower bound

124
00:05:25,000 --> 00:05:28,560
2.95 and northern

125
00:05:28,960 --> 00:05:31,680
finally we visualize the comparison with

126
00:05:31,680 --> 00:05:33,440
the previous works

127
00:05:33,440 --> 00:05:35,919
our construction improves over the past

128
00:05:35,919 --> 00:05:39,840
previous works by about 33

129
00:05:41,120 --> 00:05:43,199
so the native works about the universal

130
00:05:43,199 --> 00:05:45,680
circuits

131
00:05:45,919 --> 00:05:48,719
that's all thank

132
00:05:50,840 --> 00:05:55,360
you thank you lahani new also

133
00:05:55,360 --> 00:05:57,680
do you have do anyone have questions for

134
00:05:57,680 --> 00:06:02,120
him for the for the presenter

135
00:06:11,680 --> 00:06:12,639
so

136
00:06:12,639 --> 00:06:14,560
so i have a

137
00:06:14,560 --> 00:06:16,479
small questions

138
00:06:16,479 --> 00:06:18,840
so in in the experiments in the

139
00:06:18,840 --> 00:06:21,840
performance you show the graph

140
00:06:21,840 --> 00:06:22,639
and

141
00:06:22,639 --> 00:06:24,400
which kind of

142
00:06:24,400 --> 00:06:27,680
what kind of circuits do you use in your

143
00:06:27,680 --> 00:06:30,960
performance evaluations

144
00:06:32,840 --> 00:06:36,560
so i don't know

145
00:06:36,720 --> 00:06:38,720
so you have the input size of the

146
00:06:38,720 --> 00:06:41,600
circuit right and this is how how how

147
00:06:41,600 --> 00:06:42,960
you might

148
00:06:42,960 --> 00:06:46,198
not know

149
00:06:48,800 --> 00:06:51,440
i cannot help

150
00:06:51,440 --> 00:06:53,599
so the next slide

151
00:06:53,599 --> 00:06:55,280
this one

152
00:06:55,280 --> 00:06:57,759
yeah so which kind of circuit

153
00:06:57,759 --> 00:07:00,560
circuit do you use in the performance

154
00:07:00,560 --> 00:07:03,840
evaluations because

155
00:07:06,160 --> 00:07:08,479
this is the i can i can have to answer

156
00:07:08,479 --> 00:07:10,160
also this work

157
00:07:10,160 --> 00:07:11,039
so

158
00:07:11,039 --> 00:07:13,520
so a universal circuit uh simulates an

159
00:07:13,520 --> 00:07:16,639
arbitrary circuit of size up to n

160
00:07:16,639 --> 00:07:19,360
so then you know n is measured as well

161
00:07:19,360 --> 00:07:20,400
as the

162
00:07:20,400 --> 00:07:22,000
no

163
00:07:22,000 --> 00:07:23,759
so if you

164
00:07:23,759 --> 00:07:24,960
want to

165
00:07:24,960 --> 00:07:27,440
simulate the arbitrary circuit of size n

166
00:07:27,440 --> 00:07:30,560
then the size of eog is like oh

167
00:07:30,560 --> 00:07:32,639
or universal circuit is measured in

168
00:07:32,639 --> 00:07:35,759
terms of the function of this uh n

169
00:07:35,759 --> 00:07:39,120
so we use this uh circuit size of the uc

170
00:07:39,120 --> 00:07:41,199
as a function of n as you can see the

171
00:07:41,199 --> 00:07:44,960
previous works so we need like an uh for

172
00:07:44,960 --> 00:07:47,440
four point uh spamming five

173
00:07:47,440 --> 00:07:51,360
and log in or recently improved to 4.5

174
00:07:51,360 --> 00:07:53,759
and logan and in this work we reduced by

175
00:07:53,759 --> 00:07:54,879
uh

176
00:07:54,879 --> 00:07:57,759
by like uh

177
00:07:57,759 --> 00:08:00,879
percent and reduces to three n logging

178
00:08:00,879 --> 00:08:04,479
and we also prove a lower bond

179
00:08:04,720 --> 00:08:05,599
thank you

180
00:08:05,599 --> 00:08:07,280
yeah so thank you for your question your

181
00:08:07,280 --> 00:08:09,840
answers uh yeah i think

182
00:08:09,840 --> 00:08:12,240
uh the reason like because i see that

183
00:08:12,240 --> 00:08:15,360
you say the input size n and n from

184
00:08:15,360 --> 00:08:18,160
thousand from uh hundred to to two to

185
00:08:18,160 --> 00:08:20,560
the pen eight so you generate the

186
00:08:20,560 --> 00:08:23,280
circuit like the similar you just

187
00:08:23,280 --> 00:08:25,360
generate the circuit right

188
00:08:25,360 --> 00:08:26,879
right the circuit is random it's not

189
00:08:26,879 --> 00:08:28,879
like aes or xiaomi

190
00:08:28,879 --> 00:08:31,199
and it's just a random circuit

191
00:08:31,199 --> 00:08:33,519
thank you yeah thank you

192
00:08:33,519 --> 00:08:34,799
a nice work

193
00:08:34,799 --> 00:08:39,399
uh let me any other questions

194
00:08:41,279 --> 00:08:44,240
oh yeah so thank you

195
00:08:44,240 --> 00:08:47,279
thank you let me move to uh the next

196
00:08:47,279 --> 00:08:48,880
presentation

197
00:08:48,880 --> 00:08:52,080
uh so the next the next talk here is for

198
00:08:52,080 --> 00:08:53,200
uh

199
00:08:53,200 --> 00:08:56,800
three kilometers will present uh the

200
00:08:56,800 --> 00:09:00,880
work on oblivious key value stores and

201
00:09:00,880 --> 00:09:02,560
implications for pride set in the

202
00:09:02,560 --> 00:09:04,720
sessions

203
00:09:04,720 --> 00:09:06,959
uh thank you nee for the introduction so

204
00:09:06,959 --> 00:09:09,440
this is joint work with benny pinkass

205
00:09:09,440 --> 00:09:12,480
microslick nitrio and avisha yanai so

206
00:09:12,480 --> 00:09:15,920
thank you and let's get started

207
00:09:16,000 --> 00:09:18,640
in private set intersection alice and

208
00:09:18,640 --> 00:09:21,360
bob each have input a private set of

209
00:09:21,360 --> 00:09:22,560
items

210
00:09:22,560 --> 00:09:24,240
and they want to run a two-party

211
00:09:24,240 --> 00:09:26,560
protocol so that bob who learns the

212
00:09:26,560 --> 00:09:28,959
output learns the intersection of both

213
00:09:28,959 --> 00:09:30,480
the sets

214
00:09:30,480 --> 00:09:32,720
here he learns the items they have in

215
00:09:32,720 --> 00:09:35,040
common and nothing else about alice's

216
00:09:35,040 --> 00:09:37,040
set

217
00:09:37,040 --> 00:09:39,519
a common scenario that we see in a host

218
00:09:39,519 --> 00:09:41,440
of psi protocols

219
00:09:41,440 --> 00:09:44,880
is alice has a function f that she wants

220
00:09:44,880 --> 00:09:47,040
to convey to bob

221
00:09:47,040 --> 00:09:49,360
for most key values alice doesn't care

222
00:09:49,360 --> 00:09:52,000
what this function evaluates to

223
00:09:52,000 --> 00:09:55,120
for a few special keys k star she wants

224
00:09:55,120 --> 00:09:57,200
to convey specially crafted random

225
00:09:57,200 --> 00:09:59,600
values to bob

226
00:09:59,600 --> 00:10:01,920
this small set of keys k star depend on

227
00:10:01,920 --> 00:10:04,959
alice's input so she wishes to hide it

228
00:10:04,959 --> 00:10:07,200
so the goal is for alice to compactly

229
00:10:07,200 --> 00:10:09,600
convey these key value pairs to bob

230
00:10:09,600 --> 00:10:12,880
while hiding key star

231
00:10:12,959 --> 00:10:15,360
in psi and all the related protocols

232
00:10:15,360 --> 00:10:16,880
that we consider

233
00:10:16,880 --> 00:10:19,279
the values associated with the keys or

234
00:10:19,279 --> 00:10:21,440
the special keys are usually uniformly

235
00:10:21,440 --> 00:10:22,560
random

236
00:10:22,560 --> 00:10:23,920
so

237
00:10:23,920 --> 00:10:25,519
they end up using the technique of

238
00:10:25,519 --> 00:10:27,279
polynomials

239
00:10:27,279 --> 00:10:29,519
to convey the key value pairs

240
00:10:29,519 --> 00:10:31,440
that is they interpolate a polynomial so

241
00:10:31,440 --> 00:10:33,360
that when you evaluate it on any of the

242
00:10:33,360 --> 00:10:34,959
keys that you require you learn the

243
00:10:34,959 --> 00:10:37,279
correct associated value

244
00:10:37,279 --> 00:10:39,279
since the values are uniformly random

245
00:10:39,279 --> 00:10:41,600
the interpolated polynomial also looks

246
00:10:41,600 --> 00:10:44,560
uniformly random so it effectively hides

247
00:10:44,560 --> 00:10:46,959
the input of the special keys

248
00:10:46,959 --> 00:10:49,120
and we see polynomials used like this in

249
00:10:49,120 --> 00:10:51,680
the papers that have listed

250
00:10:51,680 --> 00:10:54,240
so in our work we abstract the specific

251
00:10:54,240 --> 00:10:55,600
properties that we require from

252
00:10:55,600 --> 00:10:57,839
polynomials in our application

253
00:10:57,839 --> 00:11:00,480
and define the notion of oblivious key

254
00:11:00,480 --> 00:11:02,240
value stores

255
00:11:02,240 --> 00:11:04,240
as data structures

256
00:11:04,240 --> 00:11:06,640
where you can encode n key value pairs

257
00:11:06,640 --> 00:11:08,240
into an object s

258
00:11:08,240 --> 00:11:10,240
and later you can decode

259
00:11:10,240 --> 00:11:12,480
using a decode algorithm and any key of

260
00:11:12,480 --> 00:11:13,920
your choice to learn the right

261
00:11:13,920 --> 00:11:16,800
associated value you can also decode in

262
00:11:16,800 --> 00:11:19,040
any key that lies outside the set and

263
00:11:19,040 --> 00:11:21,440
you learn and you end up learning some

264
00:11:21,440 --> 00:11:23,760
value that you don't care about

265
00:11:23,760 --> 00:11:25,920
so this is a key value store and it

266
00:11:25,920 --> 00:11:28,320
becomes oblivious when the object s

267
00:11:28,320 --> 00:11:31,200
effectively hides all the encoded keys

268
00:11:31,200 --> 00:11:33,680
for ok vs we measure the efficiency of

269
00:11:33,680 --> 00:11:35,519
it in terms of

270
00:11:35,519 --> 00:11:38,640
one is the size of the occavious so

271
00:11:38,640 --> 00:11:40,240
let's assume that there are m field

272
00:11:40,240 --> 00:11:42,800
elements in the vs we want this m to be

273
00:11:42,800 --> 00:11:45,279
as close to n as possible

274
00:11:45,279 --> 00:11:47,120
also we are interested in having very

275
00:11:47,120 --> 00:11:49,760
efficient encoding time

276
00:11:49,760 --> 00:11:52,639
ideally linear in this number of keys

277
00:11:52,639 --> 00:11:54,160
key value pairs that we're encoding and

278
00:11:54,160 --> 00:11:56,399
we want efficient decoding time

279
00:11:56,399 --> 00:11:58,399
and if our ok vs is a randomized

280
00:11:58,399 --> 00:11:59,839
construction then there's also an

281
00:11:59,839 --> 00:12:02,560
associated failure probability that we

282
00:12:02,560 --> 00:12:04,959
need to consider

283
00:12:04,959 --> 00:12:07,040
so in our work we study the general

284
00:12:07,040 --> 00:12:10,000
notion of oblivious key value stores and

285
00:12:10,000 --> 00:12:12,240
catalog all existing constructions and

286
00:12:12,240 --> 00:12:14,000
compare them in terms of their various

287
00:12:14,000 --> 00:12:17,440
efficiencies including polynomials

288
00:12:17,440 --> 00:12:20,959
then in the psi context we look at the

289
00:12:20,959 --> 00:12:23,519
prty 20 paper which uses a data

290
00:12:23,519 --> 00:12:25,440
structure called paxos

291
00:12:25,440 --> 00:12:28,320
to obtain an a very efficient malicious

292
00:12:28,320 --> 00:12:31,600
secure two-party psi protocol

293
00:12:31,600 --> 00:12:33,920
we observe that paxos can be categorized

294
00:12:33,920 --> 00:12:36,959
as an ok vs that relies on the analysis

295
00:12:36,959 --> 00:12:38,399
of cuckoo hashing with two hash

296
00:12:38,399 --> 00:12:40,000
functions

297
00:12:40,000 --> 00:12:42,399
again this construction is randomized

298
00:12:42,399 --> 00:12:44,480
and we need to ensure that

299
00:12:44,480 --> 00:12:46,720
it encodes correctly the end key value

300
00:12:46,720 --> 00:12:49,040
pairs except with negligible failure

301
00:12:49,040 --> 00:12:50,639
probability

302
00:12:50,639 --> 00:12:52,800
in pack source they show an asymptotic

303
00:12:52,800 --> 00:12:54,000
analysis

304
00:12:54,000 --> 00:12:56,399
of whether the failure of the failure

305
00:12:56,399 --> 00:12:58,000
probability

306
00:12:58,000 --> 00:13:00,399
but it remains highly non-trivial to

307
00:13:00,399 --> 00:13:03,519
translate this asymptotic analysis into

308
00:13:03,519 --> 00:13:05,440
actual concrete parameters used to

309
00:13:05,440 --> 00:13:08,160
instantiate an instance of psi

310
00:13:08,160 --> 00:13:10,000
therefore when they implement they rely

311
00:13:10,000 --> 00:13:11,680
on some heuristics to determine the

312
00:13:11,680 --> 00:13:14,720
various concrete parameters needed

313
00:13:14,720 --> 00:13:18,000
our goal is to obtain a better okvs

314
00:13:18,000 --> 00:13:20,320
we know that we can use cuckoo hashing

315
00:13:20,320 --> 00:13:22,480
with an analysis with three hash

316
00:13:22,480 --> 00:13:25,279
functions to obtain better efficiency in

317
00:13:25,279 --> 00:13:27,680
terms of the size of the occivious

318
00:13:27,680 --> 00:13:29,200
better size would

319
00:13:29,200 --> 00:13:31,200
immediately imply better communication

320
00:13:31,200 --> 00:13:34,240
performance in the psi

321
00:13:34,240 --> 00:13:36,880
so our first task is that i mean our

322
00:13:36,880 --> 00:13:38,639
first construction is that we

323
00:13:38,639 --> 00:13:41,440
extrapolate the concrete parameters from

324
00:13:41,440 --> 00:13:43,680
the paxos data structure

325
00:13:43,680 --> 00:13:46,480
and we show how to obtain an ok vs using

326
00:13:46,480 --> 00:13:48,800
cuckoo hashing with three hash functions

327
00:13:48,800 --> 00:13:51,120
but again we're not satisfied with how

328
00:13:51,120 --> 00:13:53,519
we obtain the concrete parameters we

329
00:13:53,519 --> 00:13:56,240
want some more empirical confidence

330
00:13:56,240 --> 00:13:58,560
and to run experiments to verify a

331
00:13:58,560 --> 00:14:00,480
failure probability of the order of 2 to

332
00:14:00,480 --> 00:14:02,639
the minus 40 is extremely resource

333
00:14:02,639 --> 00:14:04,720
intensive you have to invest millions of

334
00:14:04,720 --> 00:14:06,800
core hours and still it wouldn't be

335
00:14:06,800 --> 00:14:07,839
enough

336
00:14:07,839 --> 00:14:09,839
and suppose you need an ok vs for an

337
00:14:09,839 --> 00:14:11,600
application that needs say 2 to the

338
00:14:11,600 --> 00:14:13,839
minus 80 failure probability then it's

339
00:14:13,839 --> 00:14:16,000
certainly not feasible to empirically

340
00:14:16,000 --> 00:14:18,000
verify it

341
00:14:18,000 --> 00:14:19,279
so

342
00:14:19,279 --> 00:14:21,120
we observe that if the failure

343
00:14:21,120 --> 00:14:23,839
probability was more reasonable like say

344
00:14:23,839 --> 00:14:26,959
2 to the minus 15 then we can verify

345
00:14:26,959 --> 00:14:29,519
something like this even easily even on

346
00:14:29,519 --> 00:14:32,000
our personal laptops and achieve very

347
00:14:32,000 --> 00:14:34,480
high statistical confidence

348
00:14:34,480 --> 00:14:37,600
so we present techniques where for any

349
00:14:37,600 --> 00:14:39,680
for some constant c

350
00:14:39,680 --> 00:14:41,040
we can

351
00:14:41,040 --> 00:14:43,600
compose a set of beaker ok vs with

352
00:14:43,600 --> 00:14:45,360
failure probability p

353
00:14:45,360 --> 00:14:47,839
to obtain a stronger ok vs with failure

354
00:14:47,839 --> 00:14:50,320
probability p to the c

355
00:14:50,320 --> 00:14:52,000
while ensuring

356
00:14:52,000 --> 00:14:53,920
that there is minimal overhead in terms

357
00:14:53,920 --> 00:14:56,480
of the size of the okay vs

358
00:14:56,480 --> 00:14:58,639
thus we can um

359
00:14:58,639 --> 00:15:01,360
we can instantiate our okay vs with

360
00:15:01,360 --> 00:15:03,600
cuckoo hashing with three hash functions

361
00:15:03,600 --> 00:15:05,600
and set the concrete parameters with

362
00:15:05,600 --> 00:15:07,600
empirical confidence

363
00:15:07,600 --> 00:15:09,920
our better ok vs gives us the fastest

364
00:15:09,920 --> 00:15:12,480
malicious two-party psi protocol and

365
00:15:12,480 --> 00:15:14,480
many applications

366
00:15:14,480 --> 00:15:16,000
i'll very quickly summarize our

367
00:15:16,000 --> 00:15:17,839
applications

368
00:15:17,839 --> 00:15:20,800
our ok vs can replace any random

369
00:15:20,800 --> 00:15:23,120
encoding task including the use of

370
00:15:23,120 --> 00:15:24,560
polynomials in the following

371
00:15:24,560 --> 00:15:26,240
applications

372
00:15:26,240 --> 00:15:29,120
in the use especially uh the first one

373
00:15:29,120 --> 00:15:31,440
is in sparse ot extension which was used

374
00:15:31,440 --> 00:15:34,320
to get a communication efficient psi in

375
00:15:34,320 --> 00:15:36,079
the semi honest setting

376
00:15:36,079 --> 00:15:38,079
it can also be used to replace the use

377
00:15:38,079 --> 00:15:39,680
of polynomials in an oblivious

378
00:15:39,680 --> 00:15:41,519
programmable prf

379
00:15:41,519 --> 00:15:44,240
which is used to build circuit psi

380
00:15:44,240 --> 00:15:45,839
a version of it is used to obtain

381
00:15:45,839 --> 00:15:48,000
private set union

382
00:15:48,000 --> 00:15:48,880
and

383
00:15:48,880 --> 00:15:50,399
it's also a major building block in

384
00:15:50,399 --> 00:15:52,480
multi-party psi

385
00:15:52,480 --> 00:15:54,720
apart from using ok vs as a plug-in

386
00:15:54,720 --> 00:15:56,639
replacement we also see

387
00:15:56,639 --> 00:15:58,639
that one of the multi-party psi

388
00:15:58,639 --> 00:16:02,000
protocols presented in kmprt 17

389
00:16:02,000 --> 00:16:04,000
actually turns out to be a malicious

390
00:16:04,000 --> 00:16:06,079
secured and we show a qualitative

391
00:16:06,079 --> 00:16:07,600
analysis of how this is the most

392
00:16:07,600 --> 00:16:09,680
efficient malicious secure multi-party

393
00:16:09,680 --> 00:16:11,440
psi to date

394
00:16:11,440 --> 00:16:14,320
and as a flagship example we consider

395
00:16:14,320 --> 00:16:17,440
the ot paxos based psi protocol in prty

396
00:16:17,440 --> 00:16:18,399
20

397
00:16:18,399 --> 00:16:20,800
and replaced it with our more efficient

398
00:16:20,800 --> 00:16:22,959
ok vs to obtain the fastest malicious

399
00:16:22,959 --> 00:16:25,680
two-party psi which is now empirically

400
00:16:25,680 --> 00:16:30,880
verified we also show a generalization

401
00:16:30,959 --> 00:16:33,440
and convert this psi protocol into a

402
00:16:33,440 --> 00:16:36,880
vector ole and ok vs psi protocol

403
00:16:36,880 --> 00:16:38,880
and you have to look at the paper to um

404
00:16:38,880 --> 00:16:40,880
i invite you to look at the paper to

405
00:16:40,880 --> 00:16:43,199
know what a linear okay vs is

406
00:16:43,199 --> 00:16:46,480
and as a concurrent work uh there's a

407
00:16:46,480 --> 00:16:49,360
vector ole and pax source based psi

408
00:16:49,360 --> 00:16:52,720
that is presented by rs21 and we suggest

409
00:16:52,720 --> 00:16:54,560
that you can replace their paxos also

410
00:16:54,560 --> 00:16:56,160
with our better ok vs for better

411
00:16:56,160 --> 00:16:57,440
performance

412
00:16:57,440 --> 00:16:59,120
so i'll end with that thank you so much

413
00:16:59,120 --> 00:17:01,680
for listening

414
00:17:02,880 --> 00:17:05,520
thank you yeah three for the nice talk

415
00:17:05,520 --> 00:17:10,679
uh do we have a question from audience

416
00:17:23,520 --> 00:17:26,079
is it actually also my book so

417
00:17:26,079 --> 00:17:29,200
yeah i know what okay so maybe we can if

418
00:17:29,200 --> 00:17:31,600
we don't have uh any question from the

419
00:17:31,600 --> 00:17:32,640
chat

420
00:17:32,640 --> 00:17:34,480
or audience so i

421
00:17:34,480 --> 00:17:37,440
we can move to the network

422
00:17:37,440 --> 00:17:40,080
okay thank you

423
00:17:43,520 --> 00:17:46,880
so the next talk will be pc from

424
00:17:46,880 --> 00:17:48,960
actually oh yeah sorry the network will

425
00:17:48,960 --> 00:17:51,520
be h2k

426
00:17:51,520 --> 00:17:55,360
and pc from ha our z 2 to the k

427
00:17:55,360 --> 00:17:57,280
with the

428
00:17:57,280 --> 00:18:01,520
simpler results and bet the ckp

429
00:18:01,520 --> 00:18:03,840
and he

430
00:18:06,559 --> 00:18:08,960
okay thank you for the introduction and

431
00:18:08,960 --> 00:18:13,039
i will present our work name megahertz2k

432
00:18:13,039 --> 00:18:14,640
and pc from

433
00:18:14,640 --> 00:18:16,160
hd over

434
00:18:16,160 --> 00:18:18,480
set 2k

435
00:18:18,480 --> 00:18:19,679
messages

436
00:18:19,679 --> 00:18:21,840
this is a joint work with my advisor

437
00:18:21,840 --> 00:18:23,840
johnny chan and dr donald team of

438
00:18:23,840 --> 00:18:26,639
western digital

439
00:18:27,360 --> 00:18:29,280
so our work

440
00:18:29,280 --> 00:18:32,400
mega s2k belongs to so-called

441
00:18:32,400 --> 00:18:35,600
speeds family which follows the approach

442
00:18:35,600 --> 00:18:37,600
of speeds

443
00:18:37,600 --> 00:18:40,240
to construct an mpc protocol secure

444
00:18:40,240 --> 00:18:43,360
against actively corrupted majority

445
00:18:43,360 --> 00:18:46,240
all these protocols leverage a high

446
00:18:46,240 --> 00:18:48,640
parallelism of lattice-based morphe

447
00:18:48,640 --> 00:18:52,480
encryption in pre-processing phase to

448
00:18:52,480 --> 00:18:55,039
securely and efficiently generate

449
00:18:55,039 --> 00:18:57,760
authenticated reverse triples

450
00:18:57,760 --> 00:19:00,640
meanwhile all these works

451
00:19:00,640 --> 00:19:03,200
are protocols for arithmetic circuits

452
00:19:03,200 --> 00:19:05,039
over

453
00:19:05,039 --> 00:19:07,679
large prime field jet p

454
00:19:07,679 --> 00:19:10,240
more recent work named speeds2k

455
00:19:10,240 --> 00:19:11,760
highlights that

456
00:19:11,760 --> 00:19:14,480
the importance of

457
00:19:14,480 --> 00:19:18,000
mpc over set 2k

458
00:19:18,000 --> 00:19:20,480
as they are more suitable for

459
00:19:20,480 --> 00:19:23,520
modern cpus

460
00:19:23,520 --> 00:19:25,440
uh speech decay mainly follows the

461
00:19:25,440 --> 00:19:26,559
approach of

462
00:19:26,559 --> 00:19:29,039
speeds but they are based on oblivious

463
00:19:29,039 --> 00:19:30,880
transfer rather than homophobia

464
00:19:30,880 --> 00:19:33,520
encryption and the authors of speech

465
00:19:33,520 --> 00:19:36,240
decay raised the question of can we

466
00:19:36,240 --> 00:19:40,880
construct an efficient he-based npc over

467
00:19:40,880 --> 00:19:43,520
z2k because

468
00:19:43,520 --> 00:19:44,960
known

469
00:19:44,960 --> 00:19:47,840
techniques for

470
00:19:48,080 --> 00:19:49,760
sp case

471
00:19:49,760 --> 00:19:52,320
do not seem to generalize generalize

472
00:19:52,320 --> 00:19:56,160
well to the case of z2k

473
00:19:56,160 --> 00:19:58,880
so the our question was how can we make

474
00:19:58,880 --> 00:20:00,480
the best use of

475
00:20:00,480 --> 00:20:03,760
homework encryption or mpc over z2k in

476
00:20:03,760 --> 00:20:04,840
speeds

477
00:20:04,840 --> 00:20:07,919
framework in more details

478
00:20:07,919 --> 00:20:10,960
we have two major complications here

479
00:20:10,960 --> 00:20:12,960
first

480
00:20:12,960 --> 00:20:15,760
conventional he packing method for zp

481
00:20:15,760 --> 00:20:17,200
messages

482
00:20:17,200 --> 00:20:19,840
which provides high parallelism through

483
00:20:19,840 --> 00:20:22,480
this green isomorphism

484
00:20:22,480 --> 00:20:26,320
does not work with 2k messages so this

485
00:20:26,320 --> 00:20:28,240
means that we need new packing methods

486
00:20:28,240 --> 00:20:32,720
for z2k with nice packing density

487
00:20:33,039 --> 00:20:36,559
second um when we leverage the

488
00:20:36,559 --> 00:20:39,600
lattice-based morphing encryption we

489
00:20:39,600 --> 00:20:42,080
usually choose power of two simple

490
00:20:42,080 --> 00:20:44,320
atomic polynomials because they have

491
00:20:44,320 --> 00:20:46,840
nice structures

492
00:20:46,840 --> 00:20:50,880
and nice properties however power of two

493
00:20:50,880 --> 00:20:52,720
simple atomic polynomials are

494
00:20:52,720 --> 00:20:55,120
irreducible modulus to the k

495
00:20:55,120 --> 00:20:57,360
and this means that we cannot leverage

496
00:20:57,360 --> 00:20:59,840
uh crt parallelism for

497
00:20:59,840 --> 00:21:01,360
uh that's two

498
00:21:01,360 --> 00:21:04,320
packings and this will beat us from

499
00:21:04,320 --> 00:21:06,559
using power of two cycloatomic

500
00:21:06,559 --> 00:21:09,679
polynomials for z2k messages

501
00:21:09,679 --> 00:21:11,760
accordingly we cannot use known

502
00:21:11,760 --> 00:21:14,240
techniques which leverage power of

503
00:21:14,240 --> 00:21:16,799
leverage the structure of power of two

504
00:21:16,799 --> 00:21:19,760
simple atomic polynomials this includes

505
00:21:19,760 --> 00:21:20,880
the

506
00:21:20,880 --> 00:21:22,080
word by

507
00:21:22,080 --> 00:21:25,039
hamuda al on batteries at kp for latest

508
00:21:25,039 --> 00:21:27,520
encryption

509
00:21:27,520 --> 00:21:31,840
so in short our work

510
00:21:31,840 --> 00:21:34,240
our contribution is a new mtc protocol

511
00:21:34,240 --> 00:21:37,120
over 62k secure against actively

512
00:21:37,120 --> 00:21:40,240
corrupted majority which offers a

513
00:21:40,240 --> 00:21:42,720
substantial improvement in amortized

514
00:21:42,720 --> 00:21:45,039
community amortized communication cost

515
00:21:45,039 --> 00:21:47,760
and memory consumption versus previous

516
00:21:47,760 --> 00:21:49,440
best results

517
00:21:49,440 --> 00:21:52,400
and as our title suggests these

518
00:21:52,400 --> 00:21:54,960
improvements are based on

519
00:21:54,960 --> 00:21:57,360
three independent technical

520
00:21:57,360 --> 00:21:58,960
contributions

521
00:21:58,960 --> 00:22:01,120
first

522
00:22:01,120 --> 00:22:02,080
is

523
00:22:02,080 --> 00:22:04,559
that we we propose a new packing method

524
00:22:04,559 --> 00:22:05,360
for

525
00:22:05,360 --> 00:22:07,440
set 2k messages

526
00:22:07,440 --> 00:22:10,080
which offers a nice packing density of

527
00:22:10,080 --> 00:22:13,360
roughly a half the interesting part is

528
00:22:13,360 --> 00:22:17,039
that our packing method is based on

529
00:22:17,039 --> 00:22:19,039
what we call tweaked interpolation over

530
00:22:19,039 --> 00:22:21,600
http

531
00:22:21,600 --> 00:22:24,080
note that conventional interpolation

532
00:22:24,080 --> 00:22:27,679
cannot be cannot be applied here because

533
00:22:27,679 --> 00:22:30,000
um

534
00:22:30,880 --> 00:22:33,760
in general over rings we cannot the

535
00:22:33,760 --> 00:22:35,760
interpolation is impossible due to the

536
00:22:35,760 --> 00:22:38,799
existence of zero divisors

537
00:22:38,799 --> 00:22:41,520
and second simpler reshare reshare

538
00:22:41,520 --> 00:22:43,440
protocol is a

539
00:22:43,440 --> 00:22:45,919
one of the main component of speedsport

540
00:22:45,919 --> 00:22:47,120
code

541
00:22:47,120 --> 00:22:49,039
and somehow it is

542
00:22:49,039 --> 00:22:51,520
affected by the structure of our new

543
00:22:51,520 --> 00:22:53,679
packing method

544
00:22:53,679 --> 00:22:56,320
namely by the level dependency of the

545
00:22:56,320 --> 00:22:58,080
packings

546
00:22:58,080 --> 00:23:01,120
uh we share protocol for so we

547
00:23:01,120 --> 00:23:04,080
proposed a new visual protocol for level

548
00:23:04,080 --> 00:23:06,320
dependent packings which is inevitable

549
00:23:06,320 --> 00:23:07,760
feature for

550
00:23:07,760 --> 00:23:10,960
packing methods for z2k messages

551
00:23:10,960 --> 00:23:14,000
and this close the gap between

552
00:23:14,000 --> 00:23:17,679
zpd case and z2k case caused by this

553
00:23:17,679 --> 00:23:19,760
level dependency

554
00:23:19,760 --> 00:23:21,280
and for last

555
00:23:21,280 --> 00:23:24,159
we designed a batteries at kp

556
00:23:24,159 --> 00:23:25,360
which

557
00:23:25,360 --> 00:23:26,640
uh

558
00:23:26,640 --> 00:23:29,280
by enlarging the challenge space in

559
00:23:29,280 --> 00:23:30,480
general like

560
00:23:30,480 --> 00:23:33,919
that kp over that's x quotient by sigma

561
00:23:33,919 --> 00:23:36,799
atomic polynomial of prime p

562
00:23:36,799 --> 00:23:40,000
this offers a

563
00:23:40,799 --> 00:23:43,279
this benefits in amortized both in

564
00:23:43,279 --> 00:23:45,279
amortized communication cost and memory

565
00:23:45,279 --> 00:23:46,480
consumption

566
00:23:46,480 --> 00:23:49,360
and this improvement is based on a

567
00:23:49,360 --> 00:23:51,440
non-trivial extension of mathematical

568
00:23:51,440 --> 00:23:53,840
landmark

569
00:23:54,559 --> 00:23:56,320
al's work

570
00:23:56,320 --> 00:23:58,799
which is about coefficient size of

571
00:23:58,799 --> 00:24:02,480
inverses in that x quotient by this

572
00:24:02,480 --> 00:24:06,240
power of two cycloatomic polynomials

573
00:24:06,240 --> 00:24:08,640
and yes this is it and thank you for

574
00:24:08,640 --> 00:24:11,120
listening

575
00:24:13,120 --> 00:24:14,880
thank you for the

576
00:24:14,880 --> 00:24:16,240
night talk

577
00:24:16,240 --> 00:24:20,320
do we have any question from audience

578
00:24:30,640 --> 00:24:33,840
and in the chat

579
00:24:40,080 --> 00:24:42,480
yeah i think let's wait to

580
00:24:42,480 --> 00:24:45,520
okay yeah i think yeah thank you again

581
00:24:45,520 --> 00:24:48,159
for the presentations so let me move to

582
00:24:48,159 --> 00:24:51,440
the next talk

583
00:24:52,559 --> 00:24:53,440
okay

584
00:24:53,440 --> 00:24:55,840
yeah so the next talk will be

585
00:24:55,840 --> 00:24:57,200
uh can you

586
00:24:57,200 --> 00:25:00,400
okay yeah okay

587
00:25:00,400 --> 00:25:02,240
the next talk will be subpoenaed gm the

588
00:25:02,240 --> 00:25:04,960
q style compiler for npc with

589
00:25:04,960 --> 00:25:09,039
pre-processing and ariel will give talk

590
00:25:09,039 --> 00:25:11,360
yes thank you so this is a joint work

591
00:25:11,360 --> 00:25:13,440
with ellet boyle niv gilbert and you've

592
00:25:13,440 --> 00:25:15,120
already shy

593
00:25:15,120 --> 00:25:17,200
right so um

594
00:25:17,200 --> 00:25:19,679
right

595
00:25:20,159 --> 00:25:22,159
okay so in this talk we consider

596
00:25:22,159 --> 00:25:23,679
multi-party computation in the

597
00:25:23,679 --> 00:25:25,600
pre-processing model

598
00:25:25,600 --> 00:25:27,679
in this model the execution is divided

599
00:25:27,679 --> 00:25:30,080
into two phases an online phase or the

600
00:25:30,080 --> 00:25:32,320
pre-processing phase and an online phase

601
00:25:32,320 --> 00:25:35,200
an offline phase in an online phase

602
00:25:35,200 --> 00:25:37,360
uh the goal of the offline phase is to

603
00:25:37,360 --> 00:25:39,600
produce correlated randomness which is

604
00:25:39,600 --> 00:25:42,080
later used by the parties in the online

605
00:25:42,080 --> 00:25:43,360
execution

606
00:25:43,360 --> 00:25:45,440
uh to compute the desired functionality

607
00:25:45,440 --> 00:25:48,159
over their private inputs

608
00:25:48,159 --> 00:25:50,159
now another way to look at this model is

609
00:25:50,159 --> 00:25:52,240
to view this execution as an execution

610
00:25:52,240 --> 00:25:53,840
with a trusted dealer

611
00:25:53,840 --> 00:25:55,520
who gives the parties correlated

612
00:25:55,520 --> 00:25:57,760
randomness and then later designed a

613
00:25:57,760 --> 00:25:59,200
fuel protocol

614
00:25:59,200 --> 00:26:01,679
to distribute the delay

615
00:26:01,679 --> 00:26:03,120
now this model

616
00:26:03,120 --> 00:26:05,520
is in particular useful in the dishonest

617
00:26:05,520 --> 00:26:07,279
majority setting which we consider in

618
00:26:07,279 --> 00:26:08,880
this work

619
00:26:08,880 --> 00:26:11,200
in this challenging setting when where

620
00:26:11,200 --> 00:26:12,799
no one trusts no one

621
00:26:12,799 --> 00:26:14,559
we know that achieving secure multiple

622
00:26:14,559 --> 00:26:16,799
decomposition requires using expensive

623
00:26:16,799 --> 00:26:18,720
tools tools with uh

624
00:26:18,720 --> 00:26:20,640
high communication or tools that are

625
00:26:20,640 --> 00:26:23,039
computationally expensive rather in this

626
00:26:23,039 --> 00:26:24,880
model we can move all the expensive

627
00:26:24,880 --> 00:26:27,360
machinery into the offline phase and

628
00:26:27,360 --> 00:26:29,440
obtain an online execution which is fast

629
00:26:29,440 --> 00:26:30,960
cheap and

630
00:26:30,960 --> 00:26:33,200
information theoretic

631
00:26:33,200 --> 00:26:35,279
and now in this work we mainly focus on

632
00:26:35,279 --> 00:26:37,440
the online execution and its efficiency

633
00:26:37,440 --> 00:26:40,000
and we look at two main metrics

634
00:26:40,000 --> 00:26:42,480
the online communication cost and the

635
00:26:42,480 --> 00:26:44,640
amount of correlated ratings

636
00:26:44,640 --> 00:26:48,320
given by the by the trusted dealer

637
00:26:48,320 --> 00:26:50,640
now the standard approach for computing

638
00:26:50,640 --> 00:26:53,039
mpc in the previous model is to use

639
00:26:53,039 --> 00:26:55,440
bibliotriple and here the dealer gives

640
00:26:55,440 --> 00:26:58,159
the parties a random multiple shells of

641
00:26:58,159 --> 00:27:00,080
random multiplication papers and these

642
00:27:00,080 --> 00:27:02,159
are used to multiply shared values in

643
00:27:02,159 --> 00:27:04,559
the online execution and this table you

644
00:27:04,559 --> 00:27:06,960
can see the exact communication of

645
00:27:06,960 --> 00:27:08,320
course the exact amount of

646
00:27:08,320 --> 00:27:10,159
collateralness per

647
00:27:10,159 --> 00:27:12,400
pair multiplication and as you can see

648
00:27:12,400 --> 00:27:14,799
there are two variants for this approach

649
00:27:14,799 --> 00:27:16,720
with circuit independent preprocessing

650
00:27:16,720 --> 00:27:18,159
and with circuit dependent

651
00:27:18,159 --> 00:27:20,240
pre-processing when we allow circuit

652
00:27:20,240 --> 00:27:21,760
dependent people are saying this means

653
00:27:21,760 --> 00:27:23,919
that the dealer knows the structure of

654
00:27:23,919 --> 00:27:26,240
the circuit and this can be used to

655
00:27:26,240 --> 00:27:28,720
reduce the cost slightly

656
00:27:28,720 --> 00:27:30,399
and also we can use plg based

657
00:27:30,399 --> 00:27:32,640
compression and then we we can give each

658
00:27:32,640 --> 00:27:35,360
party one seed from which he derives all

659
00:27:35,360 --> 00:27:37,600
all these shells but even with this

660
00:27:37,600 --> 00:27:40,080
optimization we still need to give

661
00:27:40,080 --> 00:27:41,840
one element per gate to a single party

662
00:27:41,840 --> 00:27:44,000
because one share of a times b

663
00:27:44,000 --> 00:27:46,000
is fixed and not random

664
00:27:46,000 --> 00:27:48,159
now these are the costs to achieve

665
00:27:48,159 --> 00:27:50,080
semi-honor security

666
00:27:50,080 --> 00:27:52,799
to achieve malicious security so the

667
00:27:52,799 --> 00:27:54,320
most popular approach currently is the

668
00:27:54,320 --> 00:27:56,320
speed approach where the dealer gives

669
00:27:56,320 --> 00:27:58,480
also for each multiplication gate it

670
00:27:58,480 --> 00:28:00,480
gives also an authenticated version of

671
00:28:00,480 --> 00:28:03,440
each random by multiplying each

672
00:28:03,440 --> 00:28:06,399
value in in each triple with a random

673
00:28:06,399 --> 00:28:09,120
global mask

674
00:28:09,120 --> 00:28:11,039
now the main advantage of this approach

675
00:28:11,039 --> 00:28:13,039
is that the online communication cost

676
00:28:13,039 --> 00:28:15,440
with malicious security remains the same

677
00:28:15,440 --> 00:28:17,600
as the as the communication cost with

678
00:28:17,600 --> 00:28:19,120
semi owner security

679
00:28:19,120 --> 00:28:20,640
but of course the amount of quality of

680
00:28:20,640 --> 00:28:22,159
the randomness grows

681
00:28:22,159 --> 00:28:24,000
for large fields it grows by a factor of

682
00:28:24,000 --> 00:28:25,840
two and for small fields it goes by a

683
00:28:25,840 --> 00:28:27,760
factor of a capable copper is the

684
00:28:27,760 --> 00:28:30,159
statistical security parameter because

685
00:28:30,159 --> 00:28:31,840
the authenticated triple needs to be

686
00:28:31,840 --> 00:28:34,880
generated over an extension field with

687
00:28:34,880 --> 00:28:37,760
size that depends on the statistical

688
00:28:37,760 --> 00:28:40,240
parameter

689
00:28:40,399 --> 00:28:42,399
now another approach which was first

690
00:28:42,399 --> 00:28:44,640
introduced in the minimak protocol for

691
00:28:44,640 --> 00:28:47,279
small fields allows achieving constant

692
00:28:47,279 --> 00:28:48,799
correlating randomness overhead which

693
00:28:48,799 --> 00:28:51,600
does not depend does not depend on the

694
00:28:51,600 --> 00:28:53,440
security on the statistical security

695
00:28:53,440 --> 00:28:55,440
parameter although this comes at the

696
00:28:55,440 --> 00:28:56,960
expense of

697
00:28:56,960 --> 00:28:58,960
increasing the online communication cost

698
00:28:58,960 --> 00:29:00,960
so now the communication cost with

699
00:29:00,960 --> 00:29:02,640
malicious security is higher than the

700
00:29:02,640 --> 00:29:04,960
cost with semi on the secure

701
00:29:04,960 --> 00:29:07,039
so as can be seen from this

702
00:29:07,039 --> 00:29:09,200
slide there is currently a trade-off

703
00:29:09,200 --> 00:29:11,520
between the communication overhead and

704
00:29:11,520 --> 00:29:13,760
the correlating randomness overhead

705
00:29:13,760 --> 00:29:16,080
and this raises the following question

706
00:29:16,080 --> 00:29:17,679
can we achieve malaysian security where

707
00:29:17,679 --> 00:29:19,679
both the amortized online communication

708
00:29:19,679 --> 00:29:21,279
costs and the amortized correlative

709
00:29:21,279 --> 00:29:23,600
analysis are the same as for seminar

710
00:29:23,600 --> 00:29:25,520
security and of course without

711
00:29:25,520 --> 00:29:27,919
introducing any new assumption

712
00:29:27,919 --> 00:29:30,000
and in this work we give a positive

713
00:29:30,000 --> 00:29:32,880
answer to this question

714
00:29:32,880 --> 00:29:34,799
and in particular our main result is the

715
00:29:34,799 --> 00:29:37,600
following so given an arithmetic circuit

716
00:29:37,600 --> 00:29:38,399
c

717
00:29:38,399 --> 00:29:40,480
which is defined over uh some phenolic

718
00:29:40,480 --> 00:29:42,399
field although the linguistics module to

719
00:29:42,399 --> 00:29:44,960
the k then we can take every natural

720
00:29:44,960 --> 00:29:47,440
semi honest mpc protocol which computes

721
00:29:47,440 --> 00:29:49,440
c and i will explain what natural means

722
00:29:49,440 --> 00:29:50,799
in the next slide

723
00:29:50,799 --> 00:29:52,640
and compile it into malicious security

724
00:29:52,640 --> 00:29:54,000
where both the additional coordinated

725
00:29:54,000 --> 00:29:55,200
roundness and the additional

726
00:29:55,200 --> 00:29:56,640
communication are

727
00:29:56,640 --> 00:29:59,440
logarithmic in the size of the circuit

728
00:29:59,440 --> 00:30:00,399
times

729
00:30:00,399 --> 00:30:02,080
some statistical parameter which means

730
00:30:02,080 --> 00:30:05,760
that amortized over the circuit the cost

731
00:30:05,760 --> 00:30:07,600
per multiplication gain per single

732
00:30:07,600 --> 00:30:10,000
multiplication gate remains the same as

733
00:30:10,000 --> 00:30:13,679
the cost with semi on the security

734
00:30:13,679 --> 00:30:15,760
right so the high level framework of our

735
00:30:15,760 --> 00:30:17,440
solution is the following so first the

736
00:30:17,440 --> 00:30:19,279
parties additively share their inputs

737
00:30:19,279 --> 00:30:20,960
then they run a semi-honest protocol to

738
00:30:20,960 --> 00:30:22,799
compute the circuit and here addition

739
00:30:22,799 --> 00:30:24,640
gates can be locally computed but the

740
00:30:24,640 --> 00:30:26,480
parties need to interact

741
00:30:26,480 --> 00:30:28,880
to compute multiplication gates

742
00:30:28,880 --> 00:30:30,720
and therefore they need to verify that

743
00:30:30,720 --> 00:30:32,559
all multiplication gates were computed

744
00:30:32,559 --> 00:30:35,200
correctly and our main contribution is a

745
00:30:35,200 --> 00:30:37,360
new verification protocol to verify the

746
00:30:37,360 --> 00:30:39,600
correctness of all multiplications with

747
00:30:39,600 --> 00:30:41,120
logarithmic amount of communication and

748
00:30:41,120 --> 00:30:44,159
logarithmic amount of correlated animals

749
00:30:44,159 --> 00:30:46,320
if this step ends successfully then the

750
00:30:46,320 --> 00:30:49,360
parties proceed to reveal the outputs so

751
00:30:49,360 --> 00:30:50,799
the main requirements from our

752
00:30:50,799 --> 00:30:53,120
semi-honest protocol are we have two

753
00:30:53,120 --> 00:30:54,880
requirements first that the protocol is

754
00:30:54,880 --> 00:30:56,240
additively secure meaning that the

755
00:30:56,240 --> 00:30:58,320
adversary can only add arrows to the

756
00:30:58,320 --> 00:30:59,279
wires

757
00:30:59,279 --> 00:31:00,640
and the second

758
00:31:00,640 --> 00:31:02,480
property is what we call

759
00:31:02,480 --> 00:31:04,799
sharing compliance which basically means

760
00:31:04,799 --> 00:31:06,960
that its secret can be reconstructed by

761
00:31:06,960 --> 00:31:08,399
each party and

762
00:31:08,399 --> 00:31:10,320
the dealer

763
00:31:10,320 --> 00:31:12,320
and fortunately many secret sharing

764
00:31:12,320 --> 00:31:14,240
based seminars protocols including

765
00:31:14,240 --> 00:31:16,240
beaver style protocols

766
00:31:16,240 --> 00:31:18,080
satisfy these properties and therefore

767
00:31:18,080 --> 00:31:20,399
can be used as the underlying seminars

768
00:31:20,399 --> 00:31:22,880
protocol in our framework

769
00:31:22,880 --> 00:31:25,200
so let me say just a few words

770
00:31:25,200 --> 00:31:27,519
about our verification protocols so at a

771
00:31:27,519 --> 00:31:29,919
very high level the goal is to verify

772
00:31:29,919 --> 00:31:31,679
that if we take a random linear

773
00:31:31,679 --> 00:31:33,120
combination of all

774
00:31:33,120 --> 00:31:35,519
the outputs of all multiplication gates

775
00:31:35,519 --> 00:31:38,399
minus the multiplication of the inputs

776
00:31:38,399 --> 00:31:40,080
and these values are shared across the

777
00:31:40,080 --> 00:31:41,120
parties

778
00:31:41,120 --> 00:31:44,000
then the result will be zero so if we

779
00:31:44,000 --> 00:31:46,320
denote this one value that we want to

780
00:31:46,320 --> 00:31:48,960
check to take equality to zero by v

781
00:31:48,960 --> 00:31:51,039
then the main idea of our

782
00:31:51,039 --> 00:31:53,360
protocol is that first the parties can

783
00:31:53,360 --> 00:31:56,960
locally compute an additive sharing of v

784
00:31:56,960 --> 00:31:58,880
but of course they cannot simply open it

785
00:31:58,880 --> 00:32:01,760
because the militia parties can open to

786
00:32:01,760 --> 00:32:04,320
any value they want so we first convert

787
00:32:04,320 --> 00:32:06,240
the additive sharing into a robustical

788
00:32:06,240 --> 00:32:08,080
sharing by letting each party secret

789
00:32:08,080 --> 00:32:10,720
share its additive sharing additive

790
00:32:10,720 --> 00:32:14,880
shell in a robust way by showing it such

791
00:32:14,880 --> 00:32:17,200
that they generate a two out of two

792
00:32:17,200 --> 00:32:19,039
additive sharing between each party and

793
00:32:19,039 --> 00:32:20,640
the dealer which means that an honest

794
00:32:20,640 --> 00:32:22,880
party and the dealer can reconstruct

795
00:32:22,880 --> 00:32:24,799
the secret

796
00:32:24,799 --> 00:32:26,559
now of course so

797
00:32:26,559 --> 00:32:28,960
then then we have a robust sharing of v

798
00:32:28,960 --> 00:32:30,159
and then we can open it and check

799
00:32:30,159 --> 00:32:31,919
equality to zero but of course this is

800
00:32:31,919 --> 00:32:33,919
not enough because a malicious party can

801
00:32:33,919 --> 00:32:34,799
also

802
00:32:34,799 --> 00:32:37,360
uh seek a share an incorrect value

803
00:32:37,360 --> 00:32:39,519
so we have another step where everybody

804
00:32:39,519 --> 00:32:42,159
proves that it shared the correct vi and

805
00:32:42,159 --> 00:32:44,080
here we use a tool which is called

806
00:32:44,080 --> 00:32:45,919
disability zero knowledge proof due to

807
00:32:45,919 --> 00:32:48,399
boonetail from crypto19 to

808
00:32:48,399 --> 00:32:49,679
to prove that

809
00:32:49,679 --> 00:32:52,399
each party share the correct value

810
00:32:52,399 --> 00:32:55,120
and with this tool the approval can

811
00:32:55,120 --> 00:32:57,200
prove some the correctness of some

812
00:32:57,200 --> 00:32:59,200
statement over an input that is shared

813
00:32:59,200 --> 00:33:00,240
across

814
00:33:00,240 --> 00:33:03,120
several very files and bonnet i'll show

815
00:33:03,120 --> 00:33:05,279
that if the statement to be proven is a

816
00:33:05,279 --> 00:33:07,679
degree to polynomial and the input is

817
00:33:07,679 --> 00:33:09,919
robustly shared across the belfast which

818
00:33:09,919 --> 00:33:12,240
means that the shares held by the honest

819
00:33:12,240 --> 00:33:14,159
parties alone are enough to reconcile

820
00:33:14,159 --> 00:33:16,799
the secret then we can have a proof with

821
00:33:16,799 --> 00:33:19,360
the logarithmic amount of communication

822
00:33:19,360 --> 00:33:23,120
and with soundness that all even if

823
00:33:23,120 --> 00:33:26,320
the malicious approval colludes with a

824
00:33:26,320 --> 00:33:29,760
subset of the of the verifiers

825
00:33:29,760 --> 00:33:31,840
this goal is is very useful to achieve

826
00:33:31,840 --> 00:33:34,480
malicious security in the mpc

827
00:33:34,480 --> 00:33:36,960
because many computations many pc are

828
00:33:36,960 --> 00:33:39,360
indeed degree two computations

829
00:33:39,360 --> 00:33:42,480
and this tool was used before to achieve

830
00:33:42,480 --> 00:33:43,919
uh malicious security and even full

831
00:33:43,919 --> 00:33:46,399
security in the honest majority setting

832
00:33:46,399 --> 00:33:48,000
relying on the fact that the secret

833
00:33:48,000 --> 00:33:49,279
sharing in the honest majority

834
00:33:49,279 --> 00:33:52,640
self-taking is inherently robust

835
00:33:52,640 --> 00:33:54,080
but when we move to the dishonest

836
00:33:54,080 --> 00:33:57,360
modality setting uh in our work so

837
00:33:57,360 --> 00:34:00,000
so first the indeed the computations are

838
00:34:00,000 --> 00:34:02,320
still the greater polynomials

839
00:34:02,320 --> 00:34:04,559
so we can so this is good but the the

840
00:34:04,559 --> 00:34:07,039
main challenge is how to achieve robust

841
00:34:07,039 --> 00:34:09,280
how to maintain robustness throughout

842
00:34:09,280 --> 00:34:10,159
the

843
00:34:10,159 --> 00:34:12,879
uh visible knowledge proof execution and

844
00:34:12,879 --> 00:34:14,159
of course without increasing the amount

845
00:34:14,159 --> 00:34:16,000
of collateral anonymous so the main

846
00:34:16,000 --> 00:34:17,918
technical idea that we have is to use

847
00:34:17,918 --> 00:34:19,679
the dealer to achieve robustness and

848
00:34:19,679 --> 00:34:21,040
through when we show how

849
00:34:21,040 --> 00:34:23,199
throughout the verification protocol we

850
00:34:23,199 --> 00:34:25,280
maintain the invariant where each piece

851
00:34:25,280 --> 00:34:27,119
of information is two out of two

852
00:34:27,119 --> 00:34:29,440
additives shared between each party and

853
00:34:29,440 --> 00:34:31,440
the dealer so again we have the property

854
00:34:31,440 --> 00:34:33,040
that the an honest party and the dealer

855
00:34:33,040 --> 00:34:34,719
can reconstruct all

856
00:34:34,719 --> 00:34:35,440
uh

857
00:34:35,440 --> 00:34:37,918
all can work like basically everything

858
00:34:37,918 --> 00:34:40,480
and we do it by using the dealer as one

859
00:34:40,480 --> 00:34:42,480
of the verifiers in the zero knowledge

860
00:34:42,480 --> 00:34:44,320
proof

861
00:34:44,320 --> 00:34:45,679
and now since the amount of

862
00:34:45,679 --> 00:34:47,040
communication in the zero knowledge

863
00:34:47,040 --> 00:34:48,960
proof is logarithmic this means that

864
00:34:48,960 --> 00:34:50,560
also the amount of communication from

865
00:34:50,560 --> 00:34:52,159
the side of the dealer is also

866
00:34:52,159 --> 00:34:54,960
logarithmic in the original circuit's

867
00:34:54,960 --> 00:34:55,918
size

868
00:34:55,918 --> 00:34:57,760
and then we show how you how the dealer

869
00:34:57,760 --> 00:35:00,160
can compute all these messages in the

870
00:35:00,160 --> 00:35:01,839
zero knowledge proof which and give it

871
00:35:01,839 --> 00:35:04,240
as a as correlated randomness and this

872
00:35:04,240 --> 00:35:06,640
is how we achieve our result that

873
00:35:06,640 --> 00:35:08,079
eventually the amount of correct and

874
00:35:08,079 --> 00:35:10,320
randomness given by the dealer in the

875
00:35:10,320 --> 00:35:12,800
verification step is logarithmic in the

876
00:35:12,800 --> 00:35:14,480
size of the circuit

877
00:35:14,480 --> 00:35:16,079
and with this i will end my talk thank

878
00:35:16,079 --> 00:35:18,640
you very much

879
00:35:20,160 --> 00:35:23,118
thank you are you okay

880
00:35:24,000 --> 00:35:27,560
question from audience

881
00:35:38,560 --> 00:35:41,560
shhh

882
00:35:48,400 --> 00:35:51,680
yeah so if so like thank you ariel for

883
00:35:51,680 --> 00:35:53,599
the presentation

884
00:35:53,599 --> 00:35:57,960
and we can move to the neck

885
00:35:58,160 --> 00:36:00,320
so the next talk will be

886
00:36:00,320 --> 00:36:03,040
limits on adaptive skills security of

887
00:36:03,040 --> 00:36:04,560
giant grappling

888
00:36:04,560 --> 00:36:07,520
and current will give a talk

889
00:36:07,520 --> 00:36:09,680
yes

890
00:36:09,680 --> 00:36:12,720
let me share the screens

891
00:36:12,720 --> 00:36:15,680
can you see it no yes yeah i see it

892
00:36:15,680 --> 00:36:18,160
okay so my name is calvin klein and this

893
00:36:18,160 --> 00:36:19,599
talk will be on limits on the adaptive

894
00:36:19,599 --> 00:36:21,280
security of your house garbling it is

895
00:36:21,280 --> 00:36:22,800
joint work with chattan kamat

896
00:36:22,800 --> 00:36:24,839
christopher and daniel

897
00:36:24,839 --> 00:36:26,720
lyrics

898
00:36:26,720 --> 00:36:28,320
consider the following scenario aldis

899
00:36:28,320 --> 00:36:29,839
hold some circuit c

900
00:36:29,839 --> 00:36:31,599
bob some input x

901
00:36:31,599 --> 00:36:33,200
and they want to jointly evaluate the

902
00:36:33,200 --> 00:36:35,359
circuit on the input without revealing

903
00:36:35,359 --> 00:36:38,320
their respective secret information

904
00:36:38,320 --> 00:36:40,720
and to this aim

905
00:36:40,720 --> 00:36:43,599
gao suggested the following solution

906
00:36:43,599 --> 00:36:45,920
so first alice can gobble the circuit

907
00:36:45,920 --> 00:36:47,839
send over the garbage circuit c tilde to

908
00:36:47,839 --> 00:36:49,119
bob

909
00:36:49,119 --> 00:36:50,960
and then alice and bob run an oblivious

910
00:36:50,960 --> 00:36:53,359
transfer protocol so that bob learns

911
00:36:53,359 --> 00:36:57,119
exactly the garbling of his input

912
00:36:57,119 --> 00:36:58,800
bob can then evaluate the garbage

913
00:36:58,800 --> 00:37:01,280
circuit on the garbage input to learn

914
00:37:01,280 --> 00:37:04,400
the output c of x

915
00:37:04,400 --> 00:37:06,240
and while yao suggested the solution

916
00:37:06,240 --> 00:37:08,560
already in the 80s it was only much

917
00:37:08,560 --> 00:37:10,640
later that the security of yale's goblin

918
00:37:10,640 --> 00:37:14,240
scheme was formally analyzed

919
00:37:15,040 --> 00:37:17,280
the first formal security proof was due

920
00:37:17,280 --> 00:37:20,560
to lindell and pinkas in 2009

921
00:37:20,560 --> 00:37:23,119
however they only proved security in a

922
00:37:23,119 --> 00:37:24,800
in a selective model

923
00:37:24,800 --> 00:37:27,599
where the input is known ahead of time

924
00:37:27,599 --> 00:37:30,160
but in practice we would like to compute

925
00:37:30,160 --> 00:37:32,079
the guarding of the circuit in an

926
00:37:32,079 --> 00:37:35,040
offline pre-crossing processing

927
00:37:35,040 --> 00:37:37,440
phase so we would require adaptive

928
00:37:37,440 --> 00:37:40,000
security

929
00:37:40,640 --> 00:37:43,119
there exists a trivial reduction that

930
00:37:43,119 --> 00:37:44,960
proves adaptive security based on the

931
00:37:44,960 --> 00:37:46,800
selective security on the scheme by

932
00:37:46,800 --> 00:37:49,040
simply randomly guessing the input

933
00:37:49,040 --> 00:37:51,359
however unfortunately this leads to a

934
00:37:51,359 --> 00:37:53,119
loss in security that is exponential in

935
00:37:53,119 --> 00:37:55,920
the input length

936
00:37:56,880 --> 00:37:59,040
the first non-trivial adaptive security

937
00:37:59,040 --> 00:38:02,560
proof was due to chaffergoli and riggs

938
00:38:02,560 --> 00:38:04,720
who managed to improve

939
00:38:04,720 --> 00:38:07,359
this this loss vector to be exponential

940
00:38:07,359 --> 00:38:09,680
only in the depth of the circuit

941
00:38:09,680 --> 00:38:11,680
so for nc1 circuits they obtain

942
00:38:11,680 --> 00:38:15,200
polynomial loss in security

943
00:38:15,599 --> 00:38:17,920
in our paper we are now interested in

944
00:38:17,920 --> 00:38:20,240
lower bounds on this loss in security

945
00:38:20,240 --> 00:38:21,920
namely we prove

946
00:38:21,920 --> 00:38:24,720
that for any black box proof of adaptive

947
00:38:24,720 --> 00:38:26,400
indistinguishability

948
00:38:26,400 --> 00:38:28,480
for yao's guarding scheme for circuits

949
00:38:28,480 --> 00:38:32,720
with n bit input one bit output the ft

950
00:38:32,720 --> 00:38:34,880
from an ncba cto secret key encryption

951
00:38:34,880 --> 00:38:37,200
scheme

952
00:38:37,520 --> 00:38:39,440
the security loss involved will be

953
00:38:39,440 --> 00:38:42,800
exponential in square root of d

954
00:38:44,880 --> 00:38:47,200
and i want to make two remarks on this

955
00:38:47,200 --> 00:38:48,320
result

956
00:38:48,320 --> 00:38:50,640
the first one is that our lower bound

957
00:38:50,640 --> 00:38:52,000
only applies to our specific

958
00:38:52,000 --> 00:38:53,280
construction

959
00:38:53,280 --> 00:38:54,800
so note that we do not prove a

960
00:38:54,800 --> 00:38:56,480
separation of garbage circuits from one

961
00:38:56,480 --> 00:38:57,760
way functions

962
00:38:57,760 --> 00:39:00,400
and in fact there exists a scheme due to

963
00:39:00,400 --> 00:39:02,000
him and weight all

964
00:39:02,000 --> 00:39:04,240
that is adaptively secure

965
00:39:04,240 --> 00:39:07,040
based only on one-way functions

966
00:39:07,040 --> 00:39:07,680
and

967
00:39:07,680 --> 00:39:09,119
what they are using

968
00:39:09,119 --> 00:39:10,880
to achieve this is somewhere equivocal

969
00:39:10,880 --> 00:39:12,560
encryption

970
00:39:12,560 --> 00:39:14,000
however this scheme is less efficient

971
00:39:14,000 --> 00:39:16,320
than yao's original construction

972
00:39:16,320 --> 00:39:18,000
since the online complexity increases

973
00:39:18,000 --> 00:39:19,520
with the pebble complexity of the

974
00:39:19,520 --> 00:39:21,920
circuit

975
00:39:22,480 --> 00:39:24,400
as a second remark

976
00:39:24,400 --> 00:39:26,640
i want to highlight that our lower

977
00:39:26,640 --> 00:39:27,560
bounds hold even for

978
00:39:27,560 --> 00:39:29,359
indistinguishability which is a weaker

979
00:39:29,359 --> 00:39:31,359
notion than the usually considered

980
00:39:31,359 --> 00:39:33,359
simulatability notion for garbage

981
00:39:33,359 --> 00:39:35,920
circuits however since we're considered

982
00:39:35,920 --> 00:39:38,000
we're considering lower bounds this only

983
00:39:38,000 --> 00:39:41,040
strengthens our results

984
00:39:41,040 --> 00:39:42,560
furthermore i was cheating a bit on the

985
00:39:42,560 --> 00:39:44,320
previous slide namely jeffergoli and

986
00:39:44,320 --> 00:39:46,240
twix do not prove adaptive security of

987
00:39:46,240 --> 00:39:48,240
the original scheme by yao

988
00:39:48,240 --> 00:39:50,320
but a slight modification where the

989
00:39:50,320 --> 00:39:51,920
output mapping is sent in the online

990
00:39:51,920 --> 00:39:54,960
phase instead of the offline phase

991
00:39:54,960 --> 00:39:56,720
so for our lower bound we also consider

992
00:39:56,720 --> 00:39:58,960
this variant of yao and again this only

993
00:39:58,960 --> 00:40:02,400
makes our results stronger

994
00:40:02,560 --> 00:40:04,880
the only previously known limitation to

995
00:40:04,880 --> 00:40:07,280
your scheme was due to applebaum at all

996
00:40:07,280 --> 00:40:09,680
who proved that yao's original scheme so

997
00:40:09,680 --> 00:40:11,040
where the output mapping is sending the

998
00:40:11,040 --> 00:40:12,560
offline phase

999
00:40:12,560 --> 00:40:15,200
is not adaptively simulatable

1000
00:40:15,200 --> 00:40:17,040
and for this result they used circuits

1001
00:40:17,040 --> 00:40:19,280
with large output

1002
00:40:19,280 --> 00:40:22,480
so our is our lower bound differs in

1003
00:40:22,480 --> 00:40:24,560
three aspects first we consider a weaker

1004
00:40:24,560 --> 00:40:26,480
security notion

1005
00:40:26,480 --> 00:40:28,960
second we consider a scheme

1006
00:40:28,960 --> 00:40:30,160
to which

1007
00:40:30,160 --> 00:40:32,160
the the lower bound by apple bomb at all

1008
00:40:32,160 --> 00:40:34,720
does not apply

1009
00:40:34,720 --> 00:40:37,200
and finally we consider circuits

1010
00:40:37,200 --> 00:40:39,680
with constant output

1011
00:40:39,680 --> 00:40:43,200
on the other hand we require large depth

1012
00:40:43,200 --> 00:40:45,760
whereas the result by upper bound all

1013
00:40:45,760 --> 00:40:49,440
falls for small depth

1014
00:40:50,960 --> 00:40:53,359
to achieve our results we define two

1015
00:40:53,359 --> 00:40:56,000
oracles f and a where f is an ideal

1016
00:40:56,000 --> 00:40:57,520
secret key encryption schemes in

1017
00:40:57,520 --> 00:40:59,440
particular it is

1018
00:40:59,440 --> 00:41:03,119
information theoretically in cca secure

1019
00:41:03,119 --> 00:41:05,359
and a is an inefficient adversary that

1020
00:41:05,359 --> 00:41:07,760
breaks your scheme by simply brute force

1021
00:41:07,760 --> 00:41:08,640
breaking

1022
00:41:08,640 --> 00:41:10,800
the underlying encryption scheme

1023
00:41:10,800 --> 00:41:12,720
but still it is not too helpful for any

1024
00:41:12,720 --> 00:41:14,400
reduction that aims to break this

1025
00:41:14,400 --> 00:41:17,200
encryption scheme

1026
00:41:18,800 --> 00:41:20,880
and the main idea here is inspired by

1027
00:41:20,880 --> 00:41:23,359
jeffrey goliadwigs who named their upper

1028
00:41:23,359 --> 00:41:26,720
bound while some pebbling gammon graphs

1029
00:41:26,720 --> 00:41:29,280
we encounters use lower bounds for some

1030
00:41:29,280 --> 00:41:31,440
appropriate pebbling game

1031
00:41:31,440 --> 00:41:33,200
to establish our lower bounds for

1032
00:41:33,200 --> 00:41:35,839
security

1033
00:41:36,319 --> 00:41:38,400
while this idea is rather simple it

1034
00:41:38,400 --> 00:41:40,800
turned out quite tricky to realize it

1035
00:41:40,800 --> 00:41:42,960
namely the main issues where

1036
00:41:42,960 --> 00:41:44,960
to design a suitable circuit c with

1037
00:41:44,960 --> 00:41:47,280
constant output

1038
00:41:47,280 --> 00:41:49,280
and to relate a guarded circuit input

1039
00:41:49,280 --> 00:41:52,800
pair to peddling configuration

1040
00:41:53,440 --> 00:41:55,040
but with this i want to conclude this

1041
00:41:55,040 --> 00:41:57,599
brief overview of our work and want to

1042
00:41:57,599 --> 00:42:00,000
refer to the longer version of my talk

1043
00:42:00,000 --> 00:42:02,000
for more details and especially to the

1044
00:42:02,000 --> 00:42:03,920
full version of our paper for precise

1045
00:42:03,920 --> 00:42:05,599
proofs

1046
00:42:05,599 --> 00:42:07,280
thank you for your attention i'm happy

1047
00:42:07,280 --> 00:42:11,040
to answer any questions if there are

1048
00:42:13,440 --> 00:42:14,839
for the nice

1049
00:42:14,839 --> 00:42:17,920
presentations let me check if they have

1050
00:42:17,920 --> 00:42:22,440
any questions in the from audience

1051
00:42:30,079 --> 00:42:33,200
we we still have a minute left

1052
00:42:33,200 --> 00:42:35,920
for the for the sessions if uh any

1053
00:42:35,920 --> 00:42:37,599
questions related to previous

1054
00:42:37,599 --> 00:42:40,640
presentation in this

1055
00:42:40,640 --> 00:42:42,319
you can actually

1056
00:42:42,319 --> 00:42:44,400
stop i stopped sharing right

1057
00:42:44,400 --> 00:42:46,640
yeah

1058
00:42:46,640 --> 00:42:49,200
yeah cool

1059
00:42:57,280 --> 00:42:59,920
so thank you so i think they have might

1060
00:42:59,920 --> 00:43:02,480
be too early mornings so

1061
00:43:02,480 --> 00:43:03,839
yeah so maybe

1062
00:43:03,839 --> 00:43:05,119
uh

1063
00:43:05,119 --> 00:43:10,000
i think we can have uh like um

1064
00:43:10,319 --> 00:43:13,760
the next sessions

1065
00:43:13,760 --> 00:43:16,720
right can you

1066
00:43:19,760 --> 00:43:23,440
stop the video recording

