1
00:00:01,520 --> 00:00:02,560
then

2
00:00:02,560 --> 00:00:03,280
you

3
00:00:03,280 --> 00:00:04,799
are

4
00:00:04,799 --> 00:00:06,879
ready to go

5
00:00:06,879 --> 00:00:08,400
enjoy thank you

6
00:00:08,400 --> 00:00:10,960
so thank you everyone for joining this

7
00:00:10,960 --> 00:00:12,400
session of models

8
00:00:12,400 --> 00:00:15,280
uh we have three talks uh um

9
00:00:15,280 --> 00:00:17,199
the first one is on a rational protocol

10
00:00:17,199 --> 00:00:19,680
treatment of 51 attacks

11
00:00:19,680 --> 00:00:20,720
and uh

12
00:00:20,720 --> 00:00:21,840
jan is

13
00:00:21,840 --> 00:00:24,320
giving the talk and k just gently just

14
00:00:24,320 --> 00:00:25,359
put the

15
00:00:25,359 --> 00:00:26,400
um

16
00:00:26,400 --> 00:00:28,640
link to the zulip uh

17
00:00:28,640 --> 00:00:30,480
thread where you can ask questions or

18
00:00:30,480 --> 00:00:32,479
you can also do it here in the zoom

19
00:00:32,479 --> 00:00:36,239
chat if you want and i'll try to uh uh

20
00:00:36,239 --> 00:00:37,600
keep track of all the questions we're

21
00:00:37,600 --> 00:00:39,280
gonna have the three talks one after

22
00:00:39,280 --> 00:00:40,640
each other and then we're gonna have all

23
00:00:40,640 --> 00:00:42,399
the questions at the end

24
00:00:42,399 --> 00:00:43,600
so

25
00:00:43,600 --> 00:00:45,520
take it away john

26
00:00:45,520 --> 00:00:48,480
hi uh thanks

27
00:00:53,760 --> 00:00:54,640
so

28
00:00:54,640 --> 00:00:57,520
hi everyone uh this is the

29
00:00:57,520 --> 00:01:01,280
short version of the talk for our paper

30
00:01:01,280 --> 00:01:04,720
a rational protocol treatment of 51

31
00:01:04,720 --> 00:01:07,760
attacks and this is joint work with our

32
00:01:07,760 --> 00:01:09,119
co-authors

33
00:01:09,119 --> 00:01:12,159
christian and professor zika and you can

34
00:01:12,159 --> 00:01:15,920
find also the full version of our paper

35
00:01:15,920 --> 00:01:17,759
on eprint

36
00:01:17,759 --> 00:01:19,680
as well as the uh

37
00:01:19,680 --> 00:01:24,240
the full version of the talk on youtube

38
00:01:24,240 --> 00:01:26,479
so in this short talk i'm just going to

39
00:01:26,479 --> 00:01:28,479
briefly go through

40
00:01:28,479 --> 00:01:30,159
some of our

41
00:01:30,159 --> 00:01:32,960
motivation as well as a bit of our

42
00:01:32,960 --> 00:01:35,439
results

43
00:01:38,320 --> 00:01:41,360
so this project really started

44
00:01:41,360 --> 00:01:43,680
as a response to the

45
00:01:43,680 --> 00:01:47,840
uh recent and rather frequent um attacks

46
00:01:47,840 --> 00:01:51,119
on uh proof-of-work blockchains like

47
00:01:51,119 --> 00:01:52,640
ethereum classic

48
00:01:52,640 --> 00:01:56,000
and bitcoin cash and so on and these

49
00:01:56,000 --> 00:01:59,520
attacks which are coined uh 51

50
00:01:59,520 --> 00:02:00,640
attacks

51
00:02:00,640 --> 00:02:01,759
um

52
00:02:01,759 --> 00:02:03,600
and in these attacks what happens

53
00:02:03,600 --> 00:02:06,799
usually is that the adversary somehow

54
00:02:06,799 --> 00:02:08,399
obtains a

55
00:02:08,399 --> 00:02:11,680
majority of power in the system and they

56
00:02:11,680 --> 00:02:14,080
use this power to

57
00:02:14,080 --> 00:02:17,360
revert certain transactions which allows

58
00:02:17,360 --> 00:02:21,120
them to steal essentially a lot of money

59
00:02:21,120 --> 00:02:25,520
from crypto exchanges

60
00:02:26,080 --> 00:02:30,000
so the property that's been broken by

61
00:02:30,000 --> 00:02:33,840
these 51 attacks is what's called

62
00:02:33,840 --> 00:02:35,280
consistency

63
00:02:35,280 --> 00:02:39,120
and very informally consistency is a

64
00:02:39,120 --> 00:02:42,879
property that ensures that transactions

65
00:02:42,879 --> 00:02:44,160
that are

66
00:02:44,160 --> 00:02:46,239
somehow confirmed

67
00:02:46,239 --> 00:02:48,160
will not be able to be

68
00:02:48,160 --> 00:02:51,840
reverted or double spent later and a bit

69
00:02:51,840 --> 00:02:55,360
more formally it says that um

70
00:02:55,360 --> 00:02:58,959
if you uh cut off if you remove the

71
00:02:58,959 --> 00:03:01,680
most recent blocks in your chain

72
00:03:01,680 --> 00:03:04,000
then the rest of the blocks and

73
00:03:04,000 --> 00:03:06,640
therefore the transactions inside them

74
00:03:06,640 --> 00:03:08,080
are going to be

75
00:03:08,080 --> 00:03:10,800
immutable

76
00:03:11,280 --> 00:03:14,560
oh and typically what's important is

77
00:03:14,560 --> 00:03:15,519
that

78
00:03:15,519 --> 00:03:19,280
they require this property requires a

79
00:03:19,280 --> 00:03:22,480
assumption called honest majority and

80
00:03:22,480 --> 00:03:26,000
this is exactly what's broken by a 51

81
00:03:26,000 --> 00:03:30,480
percent attacker so that's not great

82
00:03:30,480 --> 00:03:34,239
and um just as an example of how a 51

83
00:03:34,239 --> 00:03:37,680
attacker might um break consistency uh

84
00:03:37,680 --> 00:03:39,519
let's say you have this chain on top

85
00:03:39,519 --> 00:03:40,319
here

86
00:03:40,319 --> 00:03:44,239
then um a 51 attacker essentially uses

87
00:03:44,239 --> 00:03:46,560
his uh major

88
00:03:46,560 --> 00:03:48,720
the majority of power

89
00:03:48,720 --> 00:03:51,840
to uh create a private chain

90
00:03:51,840 --> 00:03:53,760
and this private chain since he has

91
00:03:53,760 --> 00:03:55,840
majority is going to be

92
00:03:55,840 --> 00:03:58,799
longer than the honest party's chain

93
00:03:58,799 --> 00:04:02,799
and um this means that once he releases

94
00:04:02,799 --> 00:04:06,080
um this privately created chain uh it

95
00:04:06,080 --> 00:04:08,640
will cause the honest parties to

96
00:04:08,640 --> 00:04:11,720
um abandon their own chain and

97
00:04:11,720 --> 00:04:13,519
adopt the

98
00:04:13,519 --> 00:04:16,798
attacker's chain instead which makes uh

99
00:04:16,798 --> 00:04:19,600
certain blocks to be reverted and the

100
00:04:19,600 --> 00:04:21,680
transactions inside them to be double

101
00:04:21,680 --> 00:04:24,000
spent

102
00:04:24,800 --> 00:04:25,600
so

103
00:04:25,600 --> 00:04:27,600
um so it seems that it's kind of sad

104
00:04:27,600 --> 00:04:30,720
that there isn't on this majority but

105
00:04:30,720 --> 00:04:33,199
what's nice is that the um rational

106
00:04:33,199 --> 00:04:36,000
setting allows us to sort of circumvent

107
00:04:36,000 --> 00:04:38,720
this by saying it's okay if there's no

108
00:04:38,720 --> 00:04:41,280
honest majority hard-coded

109
00:04:41,280 --> 00:04:44,320
but we can instead assume that the

110
00:04:44,320 --> 00:04:45,919
attacker has

111
00:04:45,919 --> 00:04:48,400
some kind of incentive

112
00:04:48,400 --> 00:04:51,280
and this is really

113
00:04:51,280 --> 00:04:53,440
compatible with blockchains because

114
00:04:53,440 --> 00:04:56,639
blockchains inherently have incentives

115
00:04:56,639 --> 00:04:59,520
for example like block rewards mining

116
00:04:59,520 --> 00:05:02,000
cars and etc

117
00:05:02,000 --> 00:05:06,160
and just as a comparison of our work

118
00:05:06,160 --> 00:05:08,880
with previous works

119
00:05:08,880 --> 00:05:12,160
we in our protocol we use this framework

120
00:05:12,160 --> 00:05:14,960
called rational protocol design which

121
00:05:14,960 --> 00:05:17,280
among other things has the

122
00:05:17,280 --> 00:05:20,720
advantage of being composable in the

123
00:05:20,720 --> 00:05:23,919
uc sense as well as not having

124
00:05:23,919 --> 00:05:27,039
hard-coded restrictions on the action

125
00:05:27,039 --> 00:05:30,560
space unlike much of previous work

126
00:05:30,560 --> 00:05:33,680
and um under this framework we've

127
00:05:33,680 --> 00:05:35,919
modeled this 51

128
00:05:35,919 --> 00:05:37,840
attacks and

129
00:05:37,840 --> 00:05:41,440
just as a technical contribution we

130
00:05:41,440 --> 00:05:45,039
point out and solve a overlooked issue

131
00:05:45,039 --> 00:05:47,440
in previous work which we call unbounded

132
00:05:47,440 --> 00:05:49,840
incentives and informally this just says

133
00:05:49,840 --> 00:05:51,600
that

134
00:05:51,600 --> 00:05:52,720
you must

135
00:05:52,720 --> 00:05:55,759
make sure that your utility function

136
00:05:55,759 --> 00:05:57,919
can is not um

137
00:05:57,919 --> 00:05:59,360
does not grant

138
00:05:59,360 --> 00:06:02,400
passive strategies uh unlimited utility

139
00:06:02,400 --> 00:06:05,039
or else this allows you to prove really

140
00:06:05,039 --> 00:06:06,400
odd things

141
00:06:06,400 --> 00:06:07,680
so that's bad

142
00:06:07,680 --> 00:06:11,120
um so now that we've solved this issue

143
00:06:11,120 --> 00:06:12,560
we finally

144
00:06:12,560 --> 00:06:14,479
turned to analyzing

145
00:06:14,479 --> 00:06:17,199
these 51 attacks

146
00:06:17,199 --> 00:06:19,600
and when they're profitable as well as

147
00:06:19,600 --> 00:06:22,800
how we can prevent them by tweaking

148
00:06:22,800 --> 00:06:26,080
protocol parameters

149
00:06:26,160 --> 00:06:29,199
and um finally just time is almost up so

150
00:06:29,199 --> 00:06:31,600
oh yeah that's the last slide

151
00:06:31,600 --> 00:06:32,720
um so

152
00:06:32,720 --> 00:06:35,520
uh so just a glimpse of our results um

153
00:06:35,520 --> 00:06:38,960
this is a graph that visualizes um i

154
00:06:38,960 --> 00:06:41,759
plots the cost of renting hashing power

155
00:06:41,759 --> 00:06:42,960
with and

156
00:06:42,960 --> 00:06:44,560
the estimated

157
00:06:44,560 --> 00:06:46,639
length of an attack and what's more

158
00:06:46,639 --> 00:06:49,599
interesting is that um

159
00:06:49,599 --> 00:06:51,599
during the the time of writing um

160
00:06:51,599 --> 00:06:54,000
ethereum classic has a renting cost of

161
00:06:54,000 --> 00:06:56,400
about 0.00045

162
00:06:56,400 --> 00:06:59,360
which gives attack length about

163
00:06:59,360 --> 00:07:01,599
two to three days uh two to three days

164
00:07:01,599 --> 00:07:04,880
and this is on par with an actual attack

165
00:07:04,880 --> 00:07:06,479
on ethereum classic

166
00:07:06,479 --> 00:07:10,319
um in august of 2020 and this is uh

167
00:07:10,319 --> 00:07:11,520
really nice because this is good

168
00:07:11,520 --> 00:07:12,880
evidence that

169
00:07:12,880 --> 00:07:15,680
our results do in fact correspond to

170
00:07:15,680 --> 00:07:16,800
reality

171
00:07:16,800 --> 00:07:18,960
and um yeah that's it for the short

172
00:07:18,960 --> 00:07:21,520
version of the talk and

173
00:07:21,520 --> 00:07:24,560
any questions uh please feel free and

174
00:07:24,560 --> 00:07:26,319
thank you for watching

175
00:07:26,319 --> 00:07:27,919
thank you very much so let's switch to

176
00:07:27,919 --> 00:07:29,840
the next speaker which is supposed to be

177
00:07:29,840 --> 00:07:32,880
sarak correct

178
00:07:32,880 --> 00:07:35,199
yes

179
00:07:40,400 --> 00:07:43,840
can you hear me and see the slides

180
00:07:43,840 --> 00:07:45,120
so

181
00:07:45,120 --> 00:07:46,479
i guess i will not steal any of your

182
00:07:46,479 --> 00:07:47,919
time by reading your title you can do

183
00:07:47,919 --> 00:07:50,479
that to yourself

184
00:07:51,039 --> 00:07:54,479
um so hi i'm sarah wicknack and i'll be

185
00:07:54,479 --> 00:07:56,240
presenting moss the modular security

186
00:07:56,240 --> 00:07:58,479
specifications framework and this is

187
00:07:58,479 --> 00:07:59,919
joint work with professor amir

188
00:07:59,919 --> 00:08:02,000
harrisburg dr jamie leibovich and

189
00:08:02,000 --> 00:08:05,120
professor of assetto

190
00:08:07,840 --> 00:08:10,639
um so unfortunately many particles are

191
00:08:10,639 --> 00:08:12,639
not proven secure and admittedly

192
00:08:12,639 --> 00:08:14,319
bringing security of protocols is not

193
00:08:14,319 --> 00:08:16,800
easy due to the complexity of protocols

194
00:08:16,800 --> 00:08:18,720
and specifications which can include the

195
00:08:18,720 --> 00:08:19,900
assumptions and the goals

196
00:08:19,900 --> 00:08:21,039
[Music]

197
00:08:21,039 --> 00:08:22,879
there are a few existing approaches to

198
00:08:22,879 --> 00:08:24,800
critical specifications

199
00:08:24,800 --> 00:08:26,240
um the first one is the informal

200
00:08:26,240 --> 00:08:27,840
approach where we list the

201
00:08:27,840 --> 00:08:30,639
specifications as descriptions and words

202
00:08:30,639 --> 00:08:32,320
any other specifications include

203
00:08:32,320 --> 00:08:34,399
assumptions which we call models and

204
00:08:34,399 --> 00:08:36,640
goals which we call requirements

205
00:08:36,640 --> 00:08:38,559
so the informal approach separates the

206
00:08:38,559 --> 00:08:40,399
models from the requirements

207
00:08:40,399 --> 00:08:42,080
um but doesn't facility approval

208
00:08:42,080 --> 00:08:44,800
security and while it's commonly used in

209
00:08:44,800 --> 00:08:47,440
systems papers um and it's natural for

210
00:08:47,440 --> 00:08:49,120
people to understand how you can make

211
00:08:49,120 --> 00:08:51,200
mistakes and specifications from

212
00:08:51,200 --> 00:08:52,839
different works can be difficult to

213
00:08:52,839 --> 00:08:55,839
compare so in the game-based approach we

214
00:08:55,839 --> 00:08:57,920
define a game for each goal or for

215
00:08:57,920 --> 00:08:59,360
multiple goals

216
00:08:59,360 --> 00:09:01,600
um and the games are monolithic because

217
00:09:01,600 --> 00:09:04,000
they also include the assumptions

218
00:09:04,000 --> 00:09:05,680
the game-based approach has provable

219
00:09:05,680 --> 00:09:07,200
security but in general we don't have

220
00:09:07,200 --> 00:09:09,760
secure compositions

221
00:09:09,760 --> 00:09:11,920
in the simulation-based approach

222
00:09:11,920 --> 00:09:13,120
we show that a protocol is

223
00:09:13,120 --> 00:09:16,080
indistinguishable from an ideal system

224
00:09:16,080 --> 00:09:18,399
for example in uc i'll use an ideal

225
00:09:18,399 --> 00:09:20,000
functionality to describe what a

226
00:09:20,000 --> 00:09:22,240
vertical should do

227
00:09:22,240 --> 00:09:23,920
and this is also monolithic because the

228
00:09:23,920 --> 00:09:25,200
assumptions and the goals are all

229
00:09:25,200 --> 00:09:27,120
defined together in one ideal

230
00:09:27,120 --> 00:09:29,760
functionality

231
00:09:29,760 --> 00:09:31,519
simulation-based approach has verbal

232
00:09:31,519 --> 00:09:33,519
security and uc also allows secure

233
00:09:33,519 --> 00:09:35,519
compositions which is an important

234
00:09:35,519 --> 00:09:37,440
feature for verticals which are built

235
00:09:37,440 --> 00:09:40,399
from smaller pieces

236
00:09:40,480 --> 00:09:42,640
in this work represent moss

237
00:09:42,640 --> 00:09:44,480
which is a game-based approach which

238
00:09:44,480 --> 00:09:46,160
uses predicates so you have model

239
00:09:46,160 --> 00:09:49,200
predicates and requirement predicates

240
00:09:49,200 --> 00:09:50,720
and in contrast to the typical

241
00:09:50,720 --> 00:09:52,240
game-based approach

242
00:09:52,240 --> 00:09:53,920
mass models and requirements are

243
00:09:53,920 --> 00:09:55,920
separate and independent so it's like

244
00:09:55,920 --> 00:09:57,760
the informal approach um but they're

245
00:09:57,760 --> 00:09:59,920
well defined using predicates so

246
00:09:59,920 --> 00:10:04,160
um which allows proofs of security

247
00:10:04,160 --> 00:10:06,160
the loss is a game-based framework with

248
00:10:06,160 --> 00:10:08,079
well-defined formal modular

249
00:10:08,079 --> 00:10:09,920
specifications which separates the

250
00:10:09,920 --> 00:10:11,600
execution process

251
00:10:11,600 --> 00:10:13,839
models and requirements

252
00:10:13,839 --> 00:10:16,079
and the gradual separation um the

253
00:10:16,079 --> 00:10:18,240
modular separation allows just gradual

254
00:10:18,240 --> 00:10:20,240
development of specifications

255
00:10:20,240 --> 00:10:22,959
and it allows us to conveniently reuse

256
00:10:22,959 --> 00:10:24,959
model and requirement definitions across

257
00:10:24,959 --> 00:10:26,399
works

258
00:10:26,399 --> 00:10:28,640
so let me tell you more about moss

259
00:10:28,640 --> 00:10:31,600
models and requirements

260
00:10:31,600 --> 00:10:33,440
so on the left we have examples of

261
00:10:33,440 --> 00:10:35,360
models we can define and this includes

262
00:10:35,360 --> 00:10:37,760
adversary models in the middle

263
00:10:37,760 --> 00:10:40,800
communication models like bounded um for

264
00:10:40,800 --> 00:10:43,279
reliable or authenticated and then clock

265
00:10:43,279 --> 00:10:45,200
models and other models

266
00:10:45,200 --> 00:10:46,800
so take a menu or you can choose

267
00:10:46,800 --> 00:10:48,959
whichever models or assumptions apply to

268
00:10:48,959 --> 00:10:50,480
your case

269
00:10:50,480 --> 00:10:52,640
and most models are clearly and

270
00:10:52,640 --> 00:10:55,200
independently defined using predicates

271
00:10:55,200 --> 00:10:57,279
and then we enforce the model by looking

272
00:10:57,279 --> 00:10:59,440
at the transcript which is output by the

273
00:10:59,440 --> 00:11:00,480
execution

274
00:11:00,480 --> 00:11:03,360
and checking if the adversary satisfies

275
00:11:03,360 --> 00:11:05,440
the model based on the transcript

276
00:11:05,440 --> 00:11:07,600
so when we are assuming a model or only

277
00:11:07,600 --> 00:11:09,600
considering adverse series

278
00:11:09,600 --> 00:11:11,440
for which the transcripts size the model

279
00:11:11,440 --> 00:11:15,000
was division probability

280
00:11:15,120 --> 00:11:17,360
as an example here is a simple and

281
00:11:17,360 --> 00:11:19,920
reusable model the bounded collector

282
00:11:19,920 --> 00:11:21,519
model

283
00:11:21,519 --> 00:11:23,279
and the predicate which is shown in the

284
00:11:23,279 --> 00:11:25,920
algorithm just checks that the local

285
00:11:25,920 --> 00:11:28,399
clock values which the adversary chooses

286
00:11:28,399 --> 00:11:29,920
are always within delta clock of the

287
00:11:29,920 --> 00:11:31,200
real time

288
00:11:31,200 --> 00:11:33,279
and that the real time is monotonically

289
00:11:33,279 --> 00:11:37,120
increasing during the execution

290
00:11:37,839 --> 00:11:39,920
and similarly for requirements we can

291
00:11:39,920 --> 00:11:41,839
again pick which ones we need you can

292
00:11:41,839 --> 00:11:44,240
have generic requirements which can be

293
00:11:44,240 --> 00:11:46,640
applied to different protocols pki

294
00:11:46,640 --> 00:11:49,120
requirements and other protocol specific

295
00:11:49,120 --> 00:11:50,880
requirements

296
00:11:50,880 --> 00:11:52,560
and then requirements are defined just

297
00:11:52,560 --> 00:11:53,920
like models

298
00:11:53,920 --> 00:11:55,839
and we check that a protocol satisfies a

299
00:11:55,839 --> 00:11:58,320
requirement under some model

300
00:11:58,320 --> 00:12:00,000
again by looking at the transcript but

301
00:12:00,000 --> 00:12:02,079
only considering adverse series which

302
00:12:02,079 --> 00:12:05,040
satisfy the model

303
00:12:06,160 --> 00:12:08,720
as an example um here's the generational

304
00:12:08,720 --> 00:12:11,040
force securities requirement

305
00:12:11,040 --> 00:12:12,959
which ensures that an honest entity

306
00:12:12,959 --> 00:12:15,680
doesn't accuse another honest entity

307
00:12:15,680 --> 00:12:17,519
and the predicate just checks that an

308
00:12:17,519 --> 00:12:19,519
honest entity doesn't output

309
00:12:19,519 --> 00:12:21,440
on what we call an indicator of

310
00:12:21,440 --> 00:12:24,010
accusation for an honest entity

311
00:12:24,010 --> 00:12:25,680
[Music]

312
00:12:25,680 --> 00:12:27,760
so briefly let me mention two additional

313
00:12:27,760 --> 00:12:29,279
features of moss

314
00:12:29,279 --> 00:12:32,160
first we uh defined several modularity

315
00:12:32,160 --> 00:12:34,800
elements which formalized on intuitive

316
00:12:34,800 --> 00:12:36,639
modularity properties

317
00:12:36,639 --> 00:12:38,720
all you might expect such as combining

318
00:12:38,720 --> 00:12:41,440
multiple models or multiple requirements

319
00:12:41,440 --> 00:12:43,200
um and second also also supports

320
00:12:43,200 --> 00:12:44,880
concrete security using a small

321
00:12:44,880 --> 00:12:47,839
extension to the execution

322
00:12:47,839 --> 00:12:50,079
um and also i mentioned two areas for

323
00:12:50,079 --> 00:12:52,240
future work so the first one is

324
00:12:52,240 --> 00:12:54,000
composability

325
00:12:54,000 --> 00:12:56,720
um and we like to

326
00:12:56,720 --> 00:12:59,040
support also secure compositions in moss

327
00:12:59,040 --> 00:13:00,959
so we can support modular protocol

328
00:13:00,959 --> 00:13:03,200
design as well and we're optimistic that

329
00:13:03,200 --> 00:13:04,639
it can be done

330
00:13:04,639 --> 00:13:06,480
and second automated tools could be

331
00:13:06,480 --> 00:13:08,880
developed to um enable computer-aided

332
00:13:08,880 --> 00:13:12,000
analysis using moss

333
00:13:12,000 --> 00:13:14,240
so in conclusion moss facilitates

334
00:13:14,240 --> 00:13:16,240
modular security specifications for

335
00:13:16,240 --> 00:13:17,760
protocols

336
00:13:17,760 --> 00:13:20,240
allows variable security for protocols

337
00:13:20,240 --> 00:13:22,480
which may assume complex communication

338
00:13:22,480 --> 00:13:23,760
synchronization

339
00:13:23,760 --> 00:13:25,440
defaults in other models

340
00:13:25,440 --> 00:13:27,279
and allows us to reuse model and

341
00:13:27,279 --> 00:13:29,200
requirement definitions

342
00:13:29,200 --> 00:13:30,800
across works which can make it easier to

343
00:13:30,800 --> 00:13:32,639
compare works as well

344
00:13:32,639 --> 00:13:34,160
we see the video in february for more

345
00:13:34,160 --> 00:13:37,440
details and thank you

346
00:13:37,440 --> 00:13:39,920
thank you for your talk sarah um

347
00:13:39,920 --> 00:13:40,720
so

348
00:13:40,720 --> 00:13:41,519
uh

349
00:13:41,519 --> 00:13:42,959
let's switch to the last speaker and

350
00:13:42,959 --> 00:13:45,920
sarah there is a question on on the

351
00:13:45,920 --> 00:13:50,079
chat for you so i guess you might

352
00:13:50,079 --> 00:13:51,440
you might start looking at that if you

353
00:13:51,440 --> 00:13:53,519
want

354
00:13:53,519 --> 00:13:56,399
and uri

355
00:13:57,279 --> 00:14:00,839
please show yourself

356
00:14:08,959 --> 00:14:10,560
okay

357
00:14:10,560 --> 00:14:11,839
yes

358
00:14:11,839 --> 00:14:13,279
it's my screen

359
00:14:13,279 --> 00:14:14,560
yes

360
00:14:14,560 --> 00:14:16,720
it's perfect

361
00:14:16,720 --> 00:14:18,000
uh so

362
00:14:18,000 --> 00:14:20,800
hi i'm uwe and this is a joint talk with

363
00:14:20,800 --> 00:14:22,160
jaime kaplan the shai mansour and

364
00:14:22,160 --> 00:14:24,000
kobinissim

365
00:14:24,000 --> 00:14:26,480
and before i'll uh

366
00:14:26,480 --> 00:14:29,199
show you the specific model i just wanna

367
00:14:29,199 --> 00:14:31,440
quickly mention the highlights here

368
00:14:31,440 --> 00:14:34,399
so we show a separation between the

369
00:14:34,399 --> 00:14:36,800
classical streaming model sometimes

370
00:14:36,800 --> 00:14:39,519
called the oblivious streaming model and

371
00:14:39,519 --> 00:14:42,399
a relatively new modeling the streaming

372
00:14:42,399 --> 00:14:44,639
literature called the adaptive streaming

373
00:14:44,639 --> 00:14:47,920
model or the adversarial streaming model

374
00:14:47,920 --> 00:14:49,920
and i'll tell you what this model means

375
00:14:49,920 --> 00:14:52,320
in a minute uh just i want to mention

376
00:14:52,320 --> 00:14:54,560
that to get this uh separation we

377
00:14:54,560 --> 00:14:57,199
combine techniques from learning theory

378
00:14:57,199 --> 00:14:59,199
with cryptographic tools from the

379
00:14:59,199 --> 00:15:01,760
bounded storage model uh specifically a

380
00:15:01,760 --> 00:15:04,240
prg from the bounded storage model so i

381
00:15:04,240 --> 00:15:06,560
think it's another nice example for when

382
00:15:06,560 --> 00:15:09,360
cryptographic tools are used to prove

383
00:15:09,360 --> 00:15:13,680
similarly unrelated results in tcs

384
00:15:13,680 --> 00:15:15,760
okay so before i tell you what that

385
00:15:15,760 --> 00:15:17,839
versailles or adaptive streaming model

386
00:15:17,839 --> 00:15:18,560
is

387
00:15:18,560 --> 00:15:20,560
let's remind ourselves what happens in

388
00:15:20,560 --> 00:15:22,079
the classical or oblivious streaming

389
00:15:22,079 --> 00:15:23,279
model

390
00:15:23,279 --> 00:15:25,360
so we think about and a streaming

391
00:15:25,360 --> 00:15:27,440
algorithm that continuously reports

392
00:15:27,440 --> 00:15:28,880
estimations

393
00:15:28,880 --> 00:15:30,959
for uh the function that it is

394
00:15:30,959 --> 00:15:32,480
estimating the function that we care

395
00:15:32,480 --> 00:15:33,440
about

396
00:15:33,440 --> 00:15:36,000
so here is our streaming algorithm and

397
00:15:36,000 --> 00:15:38,320
in the classical oblivious setting

398
00:15:38,320 --> 00:15:40,959
we assume that the entire input stream

399
00:15:40,959 --> 00:15:42,959
is fixed in advance

400
00:15:42,959 --> 00:15:44,720
we don't know this entire input stream

401
00:15:44,720 --> 00:15:46,240
of course but we assume that it is fixed

402
00:15:46,240 --> 00:15:47,920
in advance

403
00:15:47,920 --> 00:15:49,839
now in every time step

404
00:15:49,839 --> 00:15:52,399
the algorithm gets the next input from

405
00:15:52,399 --> 00:15:53,519
the stream

406
00:15:53,519 --> 00:15:55,440
and needs to respond with its current

407
00:15:55,440 --> 00:15:58,240
estimation for uh the function that it

408
00:15:58,240 --> 00:16:00,320
is computing or estimating

409
00:16:00,320 --> 00:16:03,040
so it outputs this uh estimation gets

410
00:16:03,040 --> 00:16:05,680
the next input from the stream

411
00:16:05,680 --> 00:16:07,680
outputs its next estimation or modified

412
00:16:07,680 --> 00:16:10,720
estimation and so on

413
00:16:10,720 --> 00:16:12,399
okay so that's fine

414
00:16:12,399 --> 00:16:14,480
that's the classical picture what

415
00:16:14,480 --> 00:16:17,279
happens on the other side of the screen

416
00:16:17,279 --> 00:16:20,240
so we still have our streaming algorithm

417
00:16:20,240 --> 00:16:23,600
but now the input stream is not fixed in

418
00:16:23,600 --> 00:16:25,120
advance

419
00:16:25,120 --> 00:16:27,040
what happens is that there is this

420
00:16:27,040 --> 00:16:29,279
adversary in the background that chooses

421
00:16:29,279 --> 00:16:31,680
the inputs in the stream adaptively as

422
00:16:31,680 --> 00:16:33,199
time goes by

423
00:16:33,199 --> 00:16:34,800
so in the beginning the adversary

424
00:16:34,800 --> 00:16:37,600
chooses the first input in the stream

425
00:16:37,600 --> 00:16:40,480
our algorithm processes this input and

426
00:16:40,480 --> 00:16:42,800
responds with its first estimation for

427
00:16:42,800 --> 00:16:45,040
the value of the function the adversary

428
00:16:45,040 --> 00:16:46,480
gets to see

429
00:16:46,480 --> 00:16:48,399
this estimation and based on that

430
00:16:48,399 --> 00:16:50,959
estimation the adversary chooses the

431
00:16:50,959 --> 00:16:52,480
next

432
00:16:52,480 --> 00:16:54,160
input in the stream

433
00:16:54,160 --> 00:16:55,519
and then the picture continues the

434
00:16:55,519 --> 00:16:58,079
algorithm gets this new input processes

435
00:16:58,079 --> 00:17:00,800
it output outputs its next response the

436
00:17:00,800 --> 00:17:02,839
adversary gets it and

437
00:17:02,839 --> 00:17:04,720
so

438
00:17:04,720 --> 00:17:07,199
and as you can guess the challenge now

439
00:17:07,199 --> 00:17:08,319
is that

440
00:17:08,319 --> 00:17:11,520
the inputs in the stream depend on

441
00:17:11,520 --> 00:17:13,359
the outputs given by

442
00:17:13,359 --> 00:17:16,079
the algorithm and as a result

443
00:17:16,079 --> 00:17:18,799
the inputs in the stream

444
00:17:18,799 --> 00:17:21,839
can depend on the internal randomness of

445
00:17:21,839 --> 00:17:23,839
the streaming algorithm and that's a

446
00:17:23,839 --> 00:17:27,039
problem that kind of breaks the analysis

447
00:17:27,039 --> 00:17:29,039
and also the correctness of many of the

448
00:17:29,039 --> 00:17:33,039
existing classical streaming algorithms

449
00:17:33,039 --> 00:17:35,440
so that's the model adaptive adversarial

450
00:17:35,440 --> 00:17:37,520
streaming model so here is a summary of

451
00:17:37,520 --> 00:17:40,000
uh the state-of-the-art results uh

452
00:17:40,000 --> 00:17:41,840
within this model

453
00:17:41,840 --> 00:17:44,080
so first there were several papers that

454
00:17:44,080 --> 00:17:46,320
presented positive results what they

455
00:17:46,320 --> 00:17:49,280
showed are generic transformations that

456
00:17:49,280 --> 00:17:51,520
allow us to take a classical algorithm

457
00:17:51,520 --> 00:17:53,520
and transform it into an adversarially

458
00:17:53,520 --> 00:17:56,400
robust streaming algorithm while in

459
00:17:56,400 --> 00:18:00,480
calling only a small space blow up and

460
00:18:00,480 --> 00:18:03,039
to understand what it means small space

461
00:18:03,039 --> 00:18:04,160
blow up

462
00:18:04,160 --> 00:18:06,960
so it's based on the following notion uh

463
00:18:06,960 --> 00:18:09,200
by benedict al that is called the flip

464
00:18:09,200 --> 00:18:11,600
number of the stream so informally

465
00:18:11,600 --> 00:18:13,360
the flip number of the stream is denoted

466
00:18:13,360 --> 00:18:16,559
as lambda it's a bound on the maximum

467
00:18:16,559 --> 00:18:19,200
number of time steps

468
00:18:19,200 --> 00:18:21,440
on which the value of the target

469
00:18:21,440 --> 00:18:23,440
function which we are trying to estimate

470
00:18:23,440 --> 00:18:25,679
can jump significantly throughout the

471
00:18:25,679 --> 00:18:28,679
stream

472
00:18:28,799 --> 00:18:30,720
so there are many cases where this the

473
00:18:30,720 --> 00:18:33,919
number of possible large jumps is small

474
00:18:33,919 --> 00:18:35,679
and when that happens then we are in a

475
00:18:35,679 --> 00:18:37,840
good situation because all of these

476
00:18:37,840 --> 00:18:40,960
existing transformations in call space

477
00:18:40,960 --> 00:18:44,080
blow up either linear in this

478
00:18:44,080 --> 00:18:46,799
lambda bound or square root in this

479
00:18:46,799 --> 00:18:48,799
lambda bound

480
00:18:48,799 --> 00:18:50,720
okay so these are the existing positive

481
00:18:50,720 --> 00:18:52,799
results of positive uh or

482
00:18:52,799 --> 00:18:54,880
transformations what about negative

483
00:18:54,880 --> 00:18:58,000
results so first there is this uh result

484
00:18:58,000 --> 00:19:01,039
by hart and woodward from uh 13

485
00:19:01,039 --> 00:19:03,600
where they showed negative results for

486
00:19:03,600 --> 00:19:05,600
adversarial streaming

487
00:19:05,600 --> 00:19:06,880
that holds

488
00:19:06,880 --> 00:19:09,120
for linear streaming algorithms

489
00:19:09,120 --> 00:19:11,679
so that's as a negative result that's

490
00:19:11,679 --> 00:19:13,840
that's great but

491
00:19:13,840 --> 00:19:16,640
uh like after the result it was kind of

492
00:19:16,640 --> 00:19:19,039
left open that maybe you know everything

493
00:19:19,039 --> 00:19:20,640
that you can do in the classical setting

494
00:19:20,640 --> 00:19:23,200
you can also do in the adversarial

495
00:19:23,200 --> 00:19:25,919
setting just maybe not using uh linear

496
00:19:25,919 --> 00:19:27,679
algorithms

497
00:19:27,679 --> 00:19:30,559
so we show a general separation so

498
00:19:30,559 --> 00:19:32,799
showing that this is not the case we

499
00:19:32,799 --> 00:19:34,640
give a specific example of a streaming

500
00:19:34,640 --> 00:19:37,200
problem that you can solve very cheaply

501
00:19:37,200 --> 00:19:39,200
using only poly logarithmic space in the

502
00:19:39,200 --> 00:19:41,039
classical setting but if you want to

503
00:19:41,039 --> 00:19:43,039
solve it in the adversarial setting then

504
00:19:43,039 --> 00:19:44,559
you are stuck and no matter what you do

505
00:19:44,559 --> 00:19:47,679
you must use large polynomial space

506
00:19:47,679 --> 00:19:50,400
and as it happens like the blow-up we

507
00:19:50,400 --> 00:19:53,280
get in our negative result uh is like

508
00:19:53,280 --> 00:19:56,080
till this tilde matches uh what happens

509
00:19:56,080 --> 00:19:58,320
here in the positive results so i don't

510
00:19:58,320 --> 00:20:00,799
know if lambda is the correct

511
00:20:00,799 --> 00:20:02,400
measure to look at but like if you

512
00:20:02,400 --> 00:20:04,320
decided to use lambda as the parameter

513
00:20:04,320 --> 00:20:06,559
that controls your space blow-up

514
00:20:06,559 --> 00:20:08,480
then lambda then root lambda is the best

515
00:20:08,480 --> 00:20:10,480
you can hope for

516
00:20:10,480 --> 00:20:14,159
so just to summarize in this work uh we

517
00:20:14,159 --> 00:20:14,960
give

518
00:20:14,960 --> 00:20:17,280
the first general separation between uh

519
00:20:17,280 --> 00:20:19,120
the capabilities of these two models the

520
00:20:19,120 --> 00:20:21,360
adaptive or adversarial streaming model

521
00:20:21,360 --> 00:20:22,960
and the classical oblivious streaming

522
00:20:22,960 --> 00:20:26,159
model and our result relies on

523
00:20:26,159 --> 00:20:28,320
techniques techniques from

524
00:20:28,320 --> 00:20:30,480
the bounded storage model and techniques

525
00:20:30,480 --> 00:20:33,120
from learning theory

526
00:20:33,120 --> 00:20:36,240
and that's that's it thank you

527
00:20:36,240 --> 00:20:37,679
thank you very much

528
00:20:37,679 --> 00:20:42,000
so now we have time for questions um

529
00:20:42,000 --> 00:20:44,640
so i guess we'll start by taking the uh

530
00:20:44,640 --> 00:20:47,120
question in the uh zulip there was a

531
00:20:47,120 --> 00:20:49,760
question for the second talk for sarah

532
00:20:49,760 --> 00:20:51,520
the question is i'm going to read it for

533
00:20:51,520 --> 00:20:53,600
uh the one that don't have access to the

534
00:20:53,600 --> 00:20:54,799
chart

535
00:20:54,799 --> 00:20:56,159
question for most i thought that the

536
00:20:56,159 --> 00:20:58,400
simulation approach does assumptions

537
00:20:58,400 --> 00:21:00,559
apparently that is with uc usually have

538
00:21:00,559 --> 00:21:01,760
an ideal functionality you want to

539
00:21:01,760 --> 00:21:03,600
construct and also you have one more

540
00:21:03,600 --> 00:21:05,360
ideal functionality that you assume you

541
00:21:05,360 --> 00:21:07,200
have access to in order to build that

542
00:21:07,200 --> 00:21:08,480
for instance authenticated channel

543
00:21:08,480 --> 00:21:10,240
obvious transfer at the latter not

544
00:21:10,240 --> 00:21:11,520
considered to be assumptions in your

545
00:21:11,520 --> 00:21:13,120
framework

546
00:21:13,120 --> 00:21:16,640
sarah do you want to react to that

547
00:21:16,640 --> 00:21:18,960
um right so i see professor herzberg

548
00:21:18,960 --> 00:21:21,280
also or something but i think

549
00:21:21,280 --> 00:21:22,320
like

550
00:21:22,320 --> 00:21:24,320
that's a good point that some um some

551
00:21:24,320 --> 00:21:26,480
assumptions can be modeled and you see

552
00:21:26,480 --> 00:21:28,159
separately

553
00:21:28,159 --> 00:21:29,760
but it's not like clear that all

554
00:21:29,760 --> 00:21:32,799
assumptions can easily be separated into

555
00:21:32,799 --> 00:21:35,360
distinct ideal functionalities and and

556
00:21:35,360 --> 00:21:37,120
additionally in moss um we tried to do

557
00:21:37,120 --> 00:21:39,679
it in a way that's um like more simple

558
00:21:39,679 --> 00:21:40,960
and intuitive

559
00:21:40,960 --> 00:21:42,400
um compared to

560
00:21:42,400 --> 00:21:44,799
something more complex like you see so

561
00:21:44,799 --> 00:21:45,600
um

562
00:21:45,600 --> 00:21:47,840
maybe it's like a different approach um

563
00:21:47,840 --> 00:21:51,360
which allows uh like easy separation of

564
00:21:51,360 --> 00:21:55,479
assumptions from the goals

565
00:21:58,799 --> 00:21:59,760
thank you

566
00:21:59,760 --> 00:22:01,280
since you are already

567
00:22:01,280 --> 00:22:03,360
on mike i also wanted to ask you so if

568
00:22:03,360 --> 00:22:05,120
you could say something about uh the

569
00:22:05,120 --> 00:22:06,559
lack of composibility in your framework

570
00:22:06,559 --> 00:22:07,600
can you say that this is something

571
00:22:07,600 --> 00:22:09,520
they're working on so

572
00:22:09,520 --> 00:22:11,200
what's i mean what's the punchline why

573
00:22:11,200 --> 00:22:12,640
is it uh

574
00:22:12,640 --> 00:22:14,799
i mean

575
00:22:14,799 --> 00:22:16,880
what was harding getting composition uh

576
00:22:16,880 --> 00:22:18,480
with your framework

577
00:22:18,480 --> 00:22:19,919
compared to other

578
00:22:19,919 --> 00:22:23,039
previous existing frameworks

579
00:22:23,039 --> 00:22:24,960
um well it's it's composition is

580
00:22:24,960 --> 00:22:26,400
something that we're definitely

581
00:22:26,400 --> 00:22:28,080
um want to

582
00:22:28,080 --> 00:22:30,480
have in our framework um we haven't it's

583
00:22:30,480 --> 00:22:32,320
something that we want to work on and we

584
00:22:32,320 --> 00:22:34,480
believe it's going to it can be done

585
00:22:34,480 --> 00:22:37,360
because um well for example our models

586
00:22:37,360 --> 00:22:38,880
and requirements are defined in the same

587
00:22:38,880 --> 00:22:41,760
way so it seems to be like useful to use

588
00:22:41,760 --> 00:22:44,159
like a model as a requirement for a

589
00:22:44,159 --> 00:22:46,640
higher level protocol and so on um but

590
00:22:46,640 --> 00:22:48,240
it's just something that

591
00:22:48,240 --> 00:22:50,960
we need to continue to work on

592
00:22:50,960 --> 00:22:53,039
it's not like i don't believe there's

593
00:22:53,039 --> 00:22:55,039
anything inherently more difficult in

594
00:22:55,039 --> 00:22:57,039
moss compared to other like

595
00:22:57,039 --> 00:22:59,440
game-based frameworks um as far as i

596
00:22:59,440 --> 00:23:01,679
know

597
00:23:02,159 --> 00:23:03,440
can i hear

598
00:23:03,440 --> 00:23:04,799
the world

599
00:23:04,799 --> 00:23:06,159
sure

600
00:23:06,159 --> 00:23:07,520
yeah so we

601
00:23:07,520 --> 00:23:10,480
like said we actually when we did

602
00:23:10,480 --> 00:23:13,200
design these models and requirements

603
00:23:13,200 --> 00:23:15,440
that the plan of supporting

604
00:23:15,440 --> 00:23:18,080
composability was there that is

605
00:23:18,080 --> 00:23:21,039
led us to that design and we do think

606
00:23:21,039 --> 00:23:23,600
that this is possible but you know

607
00:23:23,600 --> 00:23:26,159
game-based composibility is not really

608
00:23:26,159 --> 00:23:27,520
available so

609
00:23:27,520 --> 00:23:30,080
we we don't want to over promise right

610
00:23:30,080 --> 00:23:32,559
so we are optimistic but we need to do

611
00:23:32,559 --> 00:23:34,880
the work carefully you know how it is

612
00:23:34,880 --> 00:23:36,640
right

613
00:23:36,640 --> 00:23:38,880
okay

614
00:23:39,360 --> 00:23:41,678
thanks

615
00:23:41,840 --> 00:23:44,240
so the other questions from

616
00:23:44,240 --> 00:23:47,200
any of the in the audience uh

617
00:23:47,200 --> 00:23:50,880
feel free to make yourself to

618
00:23:53,919 --> 00:23:56,000
otherwise uh i have a question for the

619
00:23:56,000 --> 00:23:58,240
last speaker uh uh

620
00:23:58,240 --> 00:24:00,640
so uh uri you were talking about your

621
00:24:00,640 --> 00:24:05,400
result and and uh so uh

622
00:24:05,919 --> 00:24:08,640
where was the cryptography used again so

623
00:24:08,640 --> 00:24:10,159
so you mentioned prg in the first slide

624
00:24:10,159 --> 00:24:13,279
but then i missed out those where uh uh

625
00:24:13,279 --> 00:24:16,080
uh using your result could you

626
00:24:16,080 --> 00:24:19,600
maybe say a few words about yeah uh so

627
00:24:19,600 --> 00:24:21,600
uh the

628
00:24:21,600 --> 00:24:24,880
the way we prove it is by uh showing uh

629
00:24:24,880 --> 00:24:27,200
we are using we are uh based basing our

630
00:24:27,200 --> 00:24:29,360
uh negative results on negative result

631
00:24:29,360 --> 00:24:32,240
we were connecting this situation to uh

632
00:24:32,240 --> 00:24:34,240
setting in the in the learning theory

633
00:24:34,240 --> 00:24:36,400
called adaptive data analysis

634
00:24:36,400 --> 00:24:37,919
and uh

635
00:24:37,919 --> 00:24:41,360
we show a reduction uh from uh

636
00:24:41,360 --> 00:24:43,600
the problem uh

637
00:24:43,600 --> 00:24:46,559
between these two problems and but the

638
00:24:46,559 --> 00:24:48,640
negative results that people get

639
00:24:48,640 --> 00:24:50,480
for adaptive data analysis they are only

640
00:24:50,480 --> 00:24:53,679
computational uh negative results uh and

641
00:24:53,679 --> 00:24:54,480
uh

642
00:24:54,480 --> 00:24:55,200
like

643
00:24:55,200 --> 00:24:59,120
to get information theoretic results we

644
00:24:59,120 --> 00:25:00,720
need to replace the replace the

645
00:25:00,720 --> 00:25:03,600
assumptions which were one-way functions

646
00:25:03,600 --> 00:25:05,440
with uh information theoretic

647
00:25:05,440 --> 00:25:07,360
assumptions and we did that

648
00:25:07,360 --> 00:25:10,559
based on assumptions of bounded storage

649
00:25:10,559 --> 00:25:13,559
space

650
00:25:14,720 --> 00:25:17,039
thanks

651
00:25:18,320 --> 00:25:19,600
i guess i'll have to read the paper to

652
00:25:19,600 --> 00:25:22,480
get more details

653
00:25:22,559 --> 00:25:24,799
um

654
00:25:24,960 --> 00:25:27,120
any further questions from the audience

655
00:25:27,120 --> 00:25:30,959
for uri maybe um

656
00:25:32,720 --> 00:25:34,240
okay so otherwise i would like to ask

657
00:25:34,240 --> 00:25:36,880
some questions the first picayan um

658
00:25:36,880 --> 00:25:38,159
so

659
00:25:38,159 --> 00:25:39,360
in your last slide you were talking

660
00:25:39,360 --> 00:25:41,760
about uh how your uh

661
00:25:41,760 --> 00:25:43,600
analysis could explain the attack

662
00:25:43,600 --> 00:25:46,000
against ethereum but you know it was the

663
00:25:46,000 --> 00:25:47,600
last slide so i didn't have enough time

664
00:25:47,600 --> 00:25:48,880
maybe you can say a few more words about

665
00:25:48,880 --> 00:25:50,640
that i i

666
00:25:50,640 --> 00:25:52,640
um

667
00:25:52,640 --> 00:25:54,799
oh yeah sure um

668
00:25:54,799 --> 00:25:58,000
so uh we essentially uh

669
00:25:58,000 --> 00:26:01,440
used our our model and our results um

670
00:26:01,440 --> 00:26:04,320
and we uh fitted it and outfitted it but

671
00:26:04,320 --> 00:26:06,720
we plugged in uh

672
00:26:06,720 --> 00:26:10,159
numbers from for ethereum classic uh at

673
00:26:10,159 --> 00:26:12,960
the time of writing which is um february

674
00:26:12,960 --> 00:26:16,480
of this year and um so we checked to see

675
00:26:16,480 --> 00:26:18,799
like suppose you're given these uh

676
00:26:18,799 --> 00:26:22,159
parameters such as like the price of

677
00:26:22,159 --> 00:26:25,200
renting hashing power um the

678
00:26:25,200 --> 00:26:29,600
um price of ethereum for example uh etc

679
00:26:29,600 --> 00:26:32,159
and so given these parameters what kind

680
00:26:32,159 --> 00:26:34,320
of um uh

681
00:26:34,320 --> 00:26:36,880
attack which which would you uh predict

682
00:26:36,880 --> 00:26:39,919
to see and we see that the length of

683
00:26:39,919 --> 00:26:42,559
attack is actually what's

684
00:26:42,559 --> 00:26:44,880
being seen in reality

685
00:26:44,880 --> 00:26:47,919
in a real attack so that's quite nice

686
00:26:47,919 --> 00:26:51,279
yeah thanks for the question

687
00:26:51,279 --> 00:26:52,559
thank you

688
00:26:52,559 --> 00:26:54,799
um

689
00:26:56,320 --> 00:26:57,919
i cannot see any other question in

690
00:26:57,919 --> 00:27:01,039
either chat so um if you want to say

691
00:27:01,039 --> 00:27:03,120
something speak up or

692
00:27:03,120 --> 00:27:05,760
shut up forever

693
00:27:05,760 --> 00:27:07,360
and otherwise let's thank all the

694
00:27:07,360 --> 00:27:09,520
speaker of the session again and see you

695
00:27:09,520 --> 00:27:11,279
in the

696
00:27:11,279 --> 00:27:14,520
lounge rooms

