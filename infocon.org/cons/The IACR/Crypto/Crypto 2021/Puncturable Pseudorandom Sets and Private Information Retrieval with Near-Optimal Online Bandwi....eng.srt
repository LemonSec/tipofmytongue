1
00:00:02,960 --> 00:00:04,640
i'd like to talk about some latest

2
00:00:04,640 --> 00:00:06,879
progress that i'm excited about on a

3
00:00:06,879 --> 00:00:08,960
classical problem called private

4
00:00:08,960 --> 00:00:10,480
information retrieval

5
00:00:10,480 --> 00:00:13,759
or pir for short

6
00:00:14,480 --> 00:00:16,480
as a motivating example let's consider

7
00:00:16,480 --> 00:00:19,199
private dns private dns recently

8
00:00:19,199 --> 00:00:21,119
received quite a lot of attention from

9
00:00:21,119 --> 00:00:23,519
companies like cloudflare apple and

10
00:00:23,519 --> 00:00:26,240
mozilla for example the new firefox

11
00:00:26,240 --> 00:00:29,359
browser supports private dns and what

12
00:00:29,359 --> 00:00:31,519
they're doing is essentially dns over

13
00:00:31,519 --> 00:00:34,800
https so in their solution you still

14
00:00:34,800 --> 00:00:36,800
have to trust the server it would be

15
00:00:36,800 --> 00:00:38,480
very nice if we can accomplish this

16
00:00:38,480 --> 00:00:40,239
without having to trust any central

17
00:00:40,239 --> 00:00:42,959
server at all

18
00:00:43,440 --> 00:00:45,360
more concretely imagine we have a

19
00:00:45,360 --> 00:00:47,920
paranoid cryptographer hypothetically

20
00:00:47,920 --> 00:00:50,640
imagine he likes to play minecraft but

21
00:00:50,640 --> 00:00:52,000
he doesn't want the

22
00:00:52,000 --> 00:00:55,600
dns server to know about this

23
00:00:55,600 --> 00:00:57,840
okay so in this setting the database is

24
00:00:57,840 --> 00:01:00,640
the dns repository the database itself

25
00:01:00,640 --> 00:01:02,399
is public it is the query that we want

26
00:01:02,399 --> 00:01:05,199
to protect and this is exactly the pir

27
00:01:05,199 --> 00:01:08,479
problem and pir was first proposed by

28
00:01:08,479 --> 00:01:10,799
carl goldbrick kushlavit said sudan back

29
00:01:10,799 --> 00:01:12,640
in 1995

30
00:01:12,640 --> 00:01:15,520
so it's like an almost three decade old

31
00:01:15,520 --> 00:01:17,920
problem

32
00:01:18,640 --> 00:01:21,439
more abstractly let's imagine

33
00:01:21,439 --> 00:01:24,240
the database contains end bits the user

34
00:01:24,240 --> 00:01:26,240
wants to retrieve the bit at some

35
00:01:26,240 --> 00:01:29,680
position x x is also called the index

36
00:01:29,680 --> 00:01:32,240
and the user doesn't want to reveal x to

37
00:01:32,240 --> 00:01:34,798
the server

38
00:01:35,840 --> 00:01:37,840
in this talk we will focus on the two

39
00:01:37,840 --> 00:01:40,159
server scenario basically assume there

40
00:01:40,159 --> 00:01:42,479
are two servers that are non-colluding

41
00:01:42,479 --> 00:01:44,000
we want to make sure that from each

42
00:01:44,000 --> 00:01:46,079
individual servers view nothing is

43
00:01:46,079 --> 00:01:48,240
leaked about the user's query

44
00:01:48,240 --> 00:01:49,759
in comparison with a single server

45
00:01:49,759 --> 00:01:51,520
setting the two server setting can often

46
00:01:51,520 --> 00:01:55,840
result in more efficient schemes

47
00:01:55,920 --> 00:01:57,759
let me quickly tell you the landscape of

48
00:01:57,759 --> 00:01:59,840
this area in the very beginning

49
00:01:59,840 --> 00:02:01,520
researchers mostly

50
00:02:01,520 --> 00:02:03,600
considered a class of scenes which i

51
00:02:03,600 --> 00:02:06,640
call classical pir and these are schemes

52
00:02:06,640 --> 00:02:08,479
without pre-processing

53
00:02:08,479 --> 00:02:09,919
in this setting there's good news and

54
00:02:09,919 --> 00:02:12,480
there's bad news the good news is that

55
00:02:12,480 --> 00:02:14,080
you know we know how to construct themes

56
00:02:14,080 --> 00:02:15,920
with polylog bandwidth

57
00:02:15,920 --> 00:02:18,160
here when i write oh tilde

58
00:02:18,160 --> 00:02:21,200
it hides polylog factors so auto1 means

59
00:02:21,200 --> 00:02:22,800
polylog

60
00:02:22,800 --> 00:02:25,440
and that's great however the bad news is

61
00:02:25,440 --> 00:02:27,200
that each query would incur linear

62
00:02:27,200 --> 00:02:29,440
amount of server computation basically

63
00:02:29,440 --> 00:02:31,760
the server needs to look at every single

64
00:02:31,760 --> 00:02:34,160
position in the database and in fact

65
00:02:34,160 --> 00:02:36,000
bamo and others prove the lower bound

66
00:02:36,000 --> 00:02:38,080
showing that indeed the linear server

67
00:02:38,080 --> 00:02:40,879
computation is necessary intuitively the

68
00:02:40,879 --> 00:02:42,480
reason is that if there are some bits

69
00:02:42,480 --> 00:02:44,560
that the server doesn't look at then it

70
00:02:44,560 --> 00:02:47,120
leaks the fact that the client is not

71
00:02:47,120 --> 00:02:50,480
interested in that position

72
00:02:50,480 --> 00:02:52,480
okay unfortunately the

73
00:02:52,480 --> 00:02:54,720
linear server computation per query is

74
00:02:54,720 --> 00:02:57,200
quite bad like in practice when when the

75
00:02:57,200 --> 00:02:58,959
database is large

76
00:02:58,959 --> 00:03:01,760
uh this is not particularly scalable

77
00:03:01,760 --> 00:03:04,239
like in private dns the database can

78
00:03:04,239 --> 00:03:08,319
easily be several hundred gigabytes

79
00:03:10,080 --> 00:03:11,920
so this motivated a promising new

80
00:03:11,920 --> 00:03:14,159
direction that is pir in the

81
00:03:14,159 --> 00:03:15,840
pre-processing model

82
00:03:15,840 --> 00:03:17,680
the pre-processing model was first

83
00:03:17,680 --> 00:03:20,879
suggested by bamo ishai and malking and

84
00:03:20,879 --> 00:03:22,720
they showed that by using pre-processing

85
00:03:22,720 --> 00:03:24,879
we can overcome the linear server

86
00:03:24,879 --> 00:03:28,000
computation lower bound

87
00:03:28,720 --> 00:03:30,799
okay in this talk we'll focus on a

88
00:03:30,799 --> 00:03:32,799
particular type of preprocessing which i

89
00:03:32,799 --> 00:03:34,720
call the subscription model

90
00:03:34,720 --> 00:03:36,879
imagine that each client who wants

91
00:03:36,879 --> 00:03:39,840
private dns service subscribes with the

92
00:03:39,840 --> 00:03:41,760
subscribes with the server during the

93
00:03:41,760 --> 00:03:44,640
subscription the client and

94
00:03:44,640 --> 00:03:48,000
downloads and starts some hints locally

95
00:03:48,000 --> 00:03:50,239
and afterwards with the help of the the

96
00:03:50,239 --> 00:03:51,280
hint

97
00:03:51,280 --> 00:03:53,519
hopefully we can answer each online

98
00:03:53,519 --> 00:03:57,360
query with sub-linear computation

99
00:03:57,360 --> 00:03:59,120
in most conceivable applications we

100
00:03:59,120 --> 00:04:01,120
always want the ability to support an

101
00:04:01,120 --> 00:04:03,680
unbounded number of queries after the

102
00:04:03,680 --> 00:04:05,680
one-time pre-processing

103
00:04:05,680 --> 00:04:07,360
so in this talk we care about the

104
00:04:07,360 --> 00:04:10,959
unbounded query setting

105
00:04:13,040 --> 00:04:15,360
for pre-processing pir

106
00:04:15,360 --> 00:04:17,199
the state of the art is an elegant work

107
00:04:17,199 --> 00:04:19,279
by cargo gibson colgan which had won the

108
00:04:19,279 --> 00:04:22,720
europe 90 best student paper award

109
00:04:22,720 --> 00:04:24,639
they showed how to support each online

110
00:04:24,639 --> 00:04:27,440
query with only square root n online

111
00:04:27,440 --> 00:04:29,840
time assuming the existence of one-way

112
00:04:29,840 --> 00:04:32,000
functions to get this result they need

113
00:04:32,000 --> 00:04:33,840
to assume roughly square root and

114
00:04:33,840 --> 00:04:36,080
client-side storage and in this talk we

115
00:04:36,080 --> 00:04:38,000
are going to just assume you know the

116
00:04:38,000 --> 00:04:42,080
same square root and client-side storage

117
00:04:42,080 --> 00:04:44,400
to get the sublinear online computation

118
00:04:44,400 --> 00:04:47,600
they have to make a pretty significant

119
00:04:47,600 --> 00:04:49,840
sacrifice basically their online

120
00:04:49,840 --> 00:04:53,840
bandwidth per query is blown up to

121
00:04:53,840 --> 00:04:56,080
square root n and this is much worse

122
00:04:56,080 --> 00:04:59,680
than the classical pir schemes

123
00:04:59,680 --> 00:05:01,440
also to avoid confusion i want to

124
00:05:01,440 --> 00:05:02,880
quickly point out that part of the

125
00:05:02,880 --> 00:05:04,960
curriculum tips coding paper

126
00:05:04,960 --> 00:05:07,520
also considered single shot schemes in

127
00:05:07,520 --> 00:05:10,240
other words schemes that support only a

128
00:05:10,240 --> 00:05:12,720
single query after the pre-processing

129
00:05:12,720 --> 00:05:13,919
and they're able to get better

130
00:05:13,919 --> 00:05:16,560
asymptotics in the single shot setting

131
00:05:16,560 --> 00:05:18,000
but in almost all conceivable

132
00:05:18,000 --> 00:05:19,919
applications we always want

133
00:05:19,919 --> 00:05:22,080
unbounded queries

134
00:05:22,080 --> 00:05:23,759
and that's the setting we care about in

135
00:05:23,759 --> 00:05:26,160
this talk

136
00:05:28,160 --> 00:05:30,080
so given this landscape

137
00:05:30,080 --> 00:05:32,080
what's the most natural and obvious

138
00:05:32,080 --> 00:05:35,039
question and so we are asking can we get

139
00:05:35,039 --> 00:05:36,720
the best of both worlds

140
00:05:36,720 --> 00:05:38,720
that is can we get sublinear online

141
00:05:38,720 --> 00:05:40,800
competition with pre-processing but

142
00:05:40,800 --> 00:05:42,880
still preserve the polylog bandwidth

143
00:05:42,880 --> 00:05:46,320
just like the classical pir

144
00:05:48,880 --> 00:05:50,960
in our work we show that indeed we can

145
00:05:50,960 --> 00:05:52,960
achieve this to get this result we need

146
00:05:52,960 --> 00:05:55,440
to assume that rw is hard which is the

147
00:05:55,440 --> 00:05:56,639
standard

148
00:05:56,639 --> 00:06:00,479
ladder space hardness assumption

149
00:06:00,479 --> 00:06:02,319
also due to an elegant lower bound

150
00:06:02,319 --> 00:06:05,199
proven by carrigan gibson kogan our

151
00:06:05,199 --> 00:06:10,160
scheme is optimal up to poly log factors

152
00:06:10,160 --> 00:06:12,639
in the online computation assuming you

153
00:06:12,639 --> 00:06:14,800
know the client has square root and

154
00:06:14,800 --> 00:06:17,840
uh storage and assuming that the server

155
00:06:17,840 --> 00:06:19,039
star

156
00:06:19,039 --> 00:06:22,080
the database in the original formats and

157
00:06:22,080 --> 00:06:23,759
do not perform any encoding on the

158
00:06:23,759 --> 00:06:26,319
database

159
00:06:26,880 --> 00:06:28,479
okay so essentially square root and

160
00:06:28,479 --> 00:06:31,039
online time is the best you can hope for

161
00:06:31,039 --> 00:06:35,318
for this type this type of schemes

162
00:06:39,280 --> 00:06:41,680
okay so i've told you about our results

163
00:06:41,680 --> 00:06:44,240
before i tell you our scheme

164
00:06:44,240 --> 00:06:45,919
let me mention that having a truly

165
00:06:45,919 --> 00:06:48,000
practical pir is something we've always

166
00:06:48,000 --> 00:06:50,080
dreamed of having for the past three

167
00:06:50,080 --> 00:06:53,440
decades uh so are we there yet

168
00:06:53,440 --> 00:06:55,520
uh i i guess in the past 10 years i've

169
00:06:55,520 --> 00:06:57,120
spent a lot of time working on a

170
00:06:57,120 --> 00:06:58,639
seemingly related but different

171
00:06:58,639 --> 00:07:01,360
primitive called oblivious ram or o-ram

172
00:07:01,360 --> 00:07:02,880
for short

173
00:07:02,880 --> 00:07:04,639
so there with oram

174
00:07:04,639 --> 00:07:06,080
you know we

175
00:07:06,080 --> 00:07:08,400
really made it quite practical you can

176
00:07:08,400 --> 00:07:11,280
implement an oram steam on a small

177
00:07:11,280 --> 00:07:13,280
secure processor chip

178
00:07:13,280 --> 00:07:14,080
but

179
00:07:14,080 --> 00:07:16,800
in comparison pir schemes are not

180
00:07:16,800 --> 00:07:18,880
quite so practical yet

181
00:07:18,880 --> 00:07:20,639
uh you know first

182
00:07:20,639 --> 00:07:22,400
these classical schemes with linear

183
00:07:22,400 --> 00:07:24,160
server computation

184
00:07:24,160 --> 00:07:26,080
are what i call asymptotically

185
00:07:26,080 --> 00:07:28,160
impractical because because of the poor

186
00:07:28,160 --> 00:07:30,880
asymptotics they're unlikely to scale to

187
00:07:30,880 --> 00:07:33,599
large databases

188
00:07:33,599 --> 00:07:35,680
and

189
00:07:35,680 --> 00:07:37,120
for this reason

190
00:07:37,120 --> 00:07:38,960
the pre-processing model seems more

191
00:07:38,960 --> 00:07:40,880
promising if we want to eventually have

192
00:07:40,880 --> 00:07:43,039
like a practical pir scheme

193
00:07:43,039 --> 00:07:45,120
so our skin is actually conceptually

194
00:07:45,120 --> 00:07:48,400
rather simple as you'll see later um but

195
00:07:48,400 --> 00:07:50,479
it's still not practical because we need

196
00:07:50,479 --> 00:07:52,720
a cryptographic object called a

197
00:07:52,720 --> 00:07:55,120
privately punctual prf this is the only

198
00:07:55,120 --> 00:07:57,120
crypto we need and essentially the rest

199
00:07:57,120 --> 00:07:59,039
of the scheme gives statistical

200
00:07:59,039 --> 00:08:00,639
guarantees

201
00:08:00,639 --> 00:08:02,800
and it turns out to construct a

202
00:08:02,800 --> 00:08:05,280
privately punctual prf the only known

203
00:08:05,280 --> 00:08:07,199
construction is from lattices and the

204
00:08:07,199 --> 00:08:08,800
only known construction is also of a

205
00:08:08,800 --> 00:08:10,840
theoretical nature and i wouldn't

206
00:08:10,840 --> 00:08:13,680
recommend implementing the current

207
00:08:13,680 --> 00:08:14,879
scheme

208
00:08:14,879 --> 00:08:17,520
in its original format

209
00:08:17,520 --> 00:08:19,919
uh okay

210
00:08:19,919 --> 00:08:22,639
so but our work you know hopefully does

211
00:08:22,639 --> 00:08:24,479
open up um

212
00:08:24,479 --> 00:08:26,960
a new avenue towards eventually getting

213
00:08:26,960 --> 00:08:29,199
a practical pir

214
00:08:29,199 --> 00:08:31,440
uh so if there's a way to somehow make

215
00:08:31,440 --> 00:08:34,399
the constants in the big o small

216
00:08:34,399 --> 00:08:36,240
maybe we can hope for something like

217
00:08:36,240 --> 00:08:38,799
that like a truly practical pir

218
00:08:38,799 --> 00:08:40,880
somewhere down the road and maybe one

219
00:08:40,880 --> 00:08:42,640
way to you know

220
00:08:42,640 --> 00:08:45,279
uh get closer to this goal is to think

221
00:08:45,279 --> 00:08:47,839
about how to construct a concretely

222
00:08:47,839 --> 00:08:51,519
efficient privately punctual prf

223
00:08:51,519 --> 00:08:54,080
and so this i think is an exciting you

224
00:08:54,080 --> 00:08:57,440
know future research direction

225
00:08:59,680 --> 00:09:00,880
okay so

226
00:09:00,880 --> 00:09:02,800
without further ado let me tell you how

227
00:09:02,800 --> 00:09:05,120
to get our results i'll start with an

228
00:09:05,120 --> 00:09:07,200
inefficient straw man which is a variant

229
00:09:07,200 --> 00:09:08,959
of the strongman scheme described by

230
00:09:08,959 --> 00:09:10,720
carrigan gibson kogan

231
00:09:10,720 --> 00:09:12,800
and then i'll tell you how to make the

232
00:09:12,800 --> 00:09:15,360
straw man efficient

233
00:09:15,360 --> 00:09:18,240
by using a new cryptographic primitive

234
00:09:18,240 --> 00:09:19,839
called a privately punctual

235
00:09:19,839 --> 00:09:23,399
pseudo-random set

236
00:09:25,279 --> 00:09:27,680
so here's the straw man

237
00:09:27,680 --> 00:09:29,360
recall we have two servers i'll call

238
00:09:29,360 --> 00:09:30,800
them the top server and the bottom

239
00:09:30,800 --> 00:09:32,959
server respectively

240
00:09:32,959 --> 00:09:34,560
let me start with the pre-processing

241
00:09:34,560 --> 00:09:36,480
place in the pre-processing phase the

242
00:09:36,480 --> 00:09:40,800
client talks only to the top server

243
00:09:42,399 --> 00:09:44,160
okay here's what the client does during

244
00:09:44,160 --> 00:09:46,000
pre-processing it samples a random set

245
00:09:46,000 --> 00:09:47,360
of indices

246
00:09:47,360 --> 00:09:50,399
for every index from 1 to n where n is

247
00:09:50,399 --> 00:09:52,560
the size of database the client will

248
00:09:52,560 --> 00:09:55,519
flip a random kind and include the index

249
00:09:55,519 --> 00:09:57,920
in the set with probability 1 over

250
00:09:57,920 --> 00:10:00,640
square root n

251
00:10:01,440 --> 00:10:03,600
for example imagine that s1 is the set

252
00:10:03,600 --> 00:10:06,240
of indices sampled in this manner it's

253
00:10:06,240 --> 00:10:08,160
easy to see that in expectation the set

254
00:10:08,160 --> 00:10:11,680
is of a square root ending size

255
00:10:12,000 --> 00:10:14,399
the client now writes down the sets it

256
00:10:14,399 --> 00:10:16,640
also sends the set as one to the top

257
00:10:16,640 --> 00:10:18,480
server

258
00:10:18,480 --> 00:10:20,959
top server now looks at the database at

259
00:10:20,959 --> 00:10:23,519
these specified positions it computes

260
00:10:23,519 --> 00:10:26,000
the parity of all these bits

261
00:10:26,000 --> 00:10:29,040
and the resulting parity is denoted

262
00:10:29,040 --> 00:10:30,959
parity of s1 here

263
00:10:30,959 --> 00:10:33,120
and it turns out to be one in this case

264
00:10:33,120 --> 00:10:34,959
so the server now sends the parity bit

265
00:10:34,959 --> 00:10:36,959
back to the client the client writes it

266
00:10:36,959 --> 00:10:40,560
down and remembers it

267
00:10:41,120 --> 00:10:43,040
the client needs to repeat this process

268
00:10:43,040 --> 00:10:45,360
roughly speaking square root and

269
00:10:45,360 --> 00:10:48,240
poly log n times

270
00:10:48,240 --> 00:10:50,079
as a result it will write down square

271
00:10:50,079 --> 00:10:54,000
root n times poly log n sets locally

272
00:10:54,000 --> 00:10:56,079
and it'll write down a parity bit for

273
00:10:56,079 --> 00:10:57,200
each set

274
00:10:57,200 --> 00:10:59,120
throughout the stock for simplicity i

275
00:10:59,120 --> 00:11:00,880
won't care too much about polylog

276
00:11:00,880 --> 00:11:02,959
factors so sometimes when i say square

277
00:11:02,959 --> 00:11:05,519
root n and i may actually mean square

278
00:11:05,519 --> 00:11:08,959
root and poly log n

279
00:11:09,040 --> 00:11:10,959
so not all of these sets must be of the

280
00:11:10,959 --> 00:11:12,959
same size right because every index is

281
00:11:12,959 --> 00:11:15,600
some put independently at random the set

282
00:11:15,600 --> 00:11:17,600
size itself is a random variable but

283
00:11:17,600 --> 00:11:19,920
it's very much concentrated

284
00:11:19,920 --> 00:11:23,120
around square root n

285
00:11:24,480 --> 00:11:26,160
at the end of the preprocessing this

286
00:11:26,160 --> 00:11:28,079
whole state that the client is storing

287
00:11:28,079 --> 00:11:30,880
is called the hint

288
00:11:30,959 --> 00:11:32,880
and at this moment the hint is like

289
00:11:32,880 --> 00:11:35,440
still pretty large in fact it's

290
00:11:35,440 --> 00:11:37,600
more than ending size and you may think

291
00:11:37,600 --> 00:11:39,279
this is pretty useless right because if

292
00:11:39,279 --> 00:11:41,600
the client has such large space it can

293
00:11:41,600 --> 00:11:44,399
simply start the whole database itself

294
00:11:44,399 --> 00:11:46,560
but don't worry later on we'll see how

295
00:11:46,560 --> 00:11:48,720
to compress things and in fact that's

296
00:11:48,720 --> 00:11:50,480
the technically interesting aspect of

297
00:11:50,480 --> 00:11:55,240
our work how to compress these things

298
00:11:56,639 --> 00:11:58,480
now we are done with preprocessing let's

299
00:11:58,480 --> 00:12:02,639
see how to support uh online queries

300
00:12:03,760 --> 00:12:05,760
in this example

301
00:12:05,760 --> 00:12:07,360
imagine that the client wants to fetch

302
00:12:07,360 --> 00:12:09,200
the index

303
00:12:09,200 --> 00:12:11,279
note that the client did not know the

304
00:12:11,279 --> 00:12:13,760
index 6 earlier during pre-processing

305
00:12:13,760 --> 00:12:15,519
right so this query is generated in an

306
00:12:15,519 --> 00:12:17,279
online fashion

307
00:12:17,279 --> 00:12:19,360
during the online phase the client will

308
00:12:19,360 --> 00:12:20,560
interact

309
00:12:20,560 --> 00:12:24,079
with the bottom server

310
00:12:24,079 --> 00:12:26,000
to be able to fetch the database at the

311
00:12:26,000 --> 00:12:28,800
desired index 6 the client first needs

312
00:12:28,800 --> 00:12:30,480
to find the sets

313
00:12:30,480 --> 00:12:32,639
it has start locally

314
00:12:32,639 --> 00:12:34,079
that contains

315
00:12:34,079 --> 00:12:35,760
the index 6.

316
00:12:35,760 --> 00:12:36,880
in this case

317
00:12:36,880 --> 00:12:39,120
s2 would serve the purpose

318
00:12:39,120 --> 00:12:42,240
because it contains six

319
00:12:43,760 --> 00:12:45,519
okay so the client also starts the

320
00:12:45,519 --> 00:12:47,920
parity of the sets as two

321
00:12:47,920 --> 00:12:50,560
and to obtain the bittex index six the

322
00:12:50,560 --> 00:12:51,680
client

323
00:12:51,680 --> 00:12:53,760
only needs to find out the parity of all

324
00:12:53,760 --> 00:12:56,000
the remaining bits in s2 right basically

325
00:12:56,000 --> 00:12:58,480
all the bits except

326
00:12:58,480 --> 00:13:01,519
the positioning six

327
00:13:02,000 --> 00:13:04,160
so therefore the most naive approach is

328
00:13:04,160 --> 00:13:05,839
for the client to just remove six from

329
00:13:05,839 --> 00:13:08,560
the set s2 and

330
00:13:08,560 --> 00:13:11,040
and the remaining set is called s2 prime

331
00:13:11,040 --> 00:13:13,279
the client sends s2 prime to the bottom

332
00:13:13,279 --> 00:13:14,639
server

333
00:13:14,639 --> 00:13:15,839
and then

334
00:13:15,839 --> 00:13:17,760
the bottom server will compute the

335
00:13:17,760 --> 00:13:20,880
parity of s2 prime

336
00:13:20,880 --> 00:13:22,959
and then it will return the parity to

337
00:13:22,959 --> 00:13:24,560
the client

338
00:13:24,560 --> 00:13:26,800
and the client can simply xor the parity

339
00:13:26,800 --> 00:13:28,240
of s2

340
00:13:28,240 --> 00:13:30,959
and the parity of s2 prime

341
00:13:30,959 --> 00:13:32,720
and then it will obtain

342
00:13:32,720 --> 00:13:36,160
the bit at position 6.

343
00:13:38,079 --> 00:13:40,160
the bottom server doesn't know what sets

344
00:13:40,160 --> 00:13:41,920
the client has downloaded from the top

345
00:13:41,920 --> 00:13:44,079
server during pre-processing right so it

346
00:13:44,079 --> 00:13:45,600
seems like the bottom server is just

347
00:13:45,600 --> 00:13:47,920
like seeing some random stats so

348
00:13:47,920 --> 00:13:50,079
intuitively this approach shouldn't leak

349
00:13:50,079 --> 00:13:52,399
too much information

350
00:13:52,399 --> 00:13:54,240
but i want you to think more carefully

351
00:13:54,240 --> 00:13:58,480
like is the scene really secure

352
00:13:59,839 --> 00:14:01,120
it turns out

353
00:14:01,120 --> 00:14:02,959
there's actually a problem

354
00:14:02,959 --> 00:14:06,240
like this random looking set as to prime

355
00:14:06,240 --> 00:14:08,240
that the bottom server sees

356
00:14:08,240 --> 00:14:10,560
definitely doesn't contain the desired

357
00:14:10,560 --> 00:14:12,639
indexes and this leaks information right

358
00:14:12,639 --> 00:14:16,320
because the server can learn um you know

359
00:14:16,320 --> 00:14:18,720
anything contained in the set

360
00:14:18,720 --> 00:14:22,639
must not be what the client wants

361
00:14:22,639 --> 00:14:25,440
okay so this isn't too great but

362
00:14:25,440 --> 00:14:26,880
it turns out

363
00:14:26,880 --> 00:14:31,320
there's an easy way to fix the problem

364
00:14:31,360 --> 00:14:33,519
so here's the fix instead of removing

365
00:14:33,519 --> 00:14:36,320
the desired index from s2 the client

366
00:14:36,320 --> 00:14:38,320
will instead we sample the decision

367
00:14:38,320 --> 00:14:40,240
whether six belongs to the set and here

368
00:14:40,240 --> 00:14:42,000
i'm using this particular notation to

369
00:14:42,000 --> 00:14:45,199
denote this resampling operation

370
00:14:45,199 --> 00:14:47,519
so in other words the client will flip a

371
00:14:47,519 --> 00:14:49,360
fresh new coin

372
00:14:49,360 --> 00:14:51,440
and decide whether to include the index

373
00:14:51,440 --> 00:14:54,639
six and it's included with probability

374
00:14:54,639 --> 00:14:56,639
you know one over square root n the same

375
00:14:56,639 --> 00:14:58,800
as before

376
00:14:58,800 --> 00:15:00,720
okay so as a result with high

377
00:15:00,720 --> 00:15:03,519
probability the index six will indeed be

378
00:15:03,519 --> 00:15:05,120
removed but with some small

379
00:15:05,120 --> 00:15:07,279
non-negligible probability six will

380
00:15:07,279 --> 00:15:10,320
still be included

381
00:15:10,800 --> 00:15:11,519
and

382
00:15:11,519 --> 00:15:13,680
same as before the client now

383
00:15:13,680 --> 00:15:16,240
sends the re-sampled sets as 2

384
00:15:16,240 --> 00:15:19,279
s2 prime to the bottom server

385
00:15:19,279 --> 00:15:22,000
where the desired index 6 has been

386
00:15:22,000 --> 00:15:23,760
resampled

387
00:15:23,760 --> 00:15:25,760
the bottom server returns the parity of

388
00:15:25,760 --> 00:15:29,920
the bits at the specified locations

389
00:15:30,880 --> 00:15:33,040
and now the client computes the xr of

390
00:15:33,040 --> 00:15:35,040
these two parities

391
00:15:35,040 --> 00:15:37,040
and it hopes to get back

392
00:15:37,040 --> 00:15:41,000
the bitter position suits

393
00:15:42,399 --> 00:15:43,920
well this will

394
00:15:43,920 --> 00:15:45,759
only give a correct result if the

395
00:15:45,759 --> 00:15:48,000
resampling indeed removed index six

396
00:15:48,000 --> 00:15:50,160
right if the resampling fails to remove

397
00:15:50,160 --> 00:15:52,240
the index six the client may obtain

398
00:15:52,240 --> 00:15:54,320
incorrect answer

399
00:15:54,320 --> 00:15:56,639
um so in other words in order to fix the

400
00:15:56,639 --> 00:15:58,399
privacy problem we've introduced the

401
00:15:58,399 --> 00:16:00,320
small error probability

402
00:16:00,320 --> 00:16:02,720
um but it turns out the small error

403
00:16:02,720 --> 00:16:04,560
probability is easy to fix and we can

404
00:16:04,560 --> 00:16:06,880
just basically use k-fold parallel

405
00:16:06,880 --> 00:16:10,240
repetition and take majority among these

406
00:16:10,240 --> 00:16:12,560
k answers so this is like a standard

407
00:16:12,560 --> 00:16:14,560
technique and we can amplify the

408
00:16:14,560 --> 00:16:16,480
correctness to essentially one minus

409
00:16:16,480 --> 00:16:18,639
negligible

410
00:16:18,639 --> 00:16:21,040
um because this k-k-fold parallel

411
00:16:21,040 --> 00:16:22,800
repetition is simple

412
00:16:22,800 --> 00:16:25,120
for the rest of the talk i will mostly

413
00:16:25,120 --> 00:16:27,120
just focus on a single instance and i'll

414
00:16:27,120 --> 00:16:29,120
assume that you know for a single

415
00:16:29,120 --> 00:16:32,560
instance it's okay to incur a small but

416
00:16:32,560 --> 00:16:36,758
non-negligible error probability

417
00:16:38,880 --> 00:16:40,720
okay before i talk about how to make the

418
00:16:40,720 --> 00:16:43,040
strongman scheme efficient let me

419
00:16:43,040 --> 00:16:46,399
quickly mention that so far i focused on

420
00:16:46,399 --> 00:16:49,040
making only one online query it turns

421
00:16:49,040 --> 00:16:50,720
out to make the scheme sustainable and

422
00:16:50,720 --> 00:16:52,800
support an unbounded number of queries

423
00:16:52,800 --> 00:16:55,120
this is not enough we need that another

424
00:16:55,120 --> 00:16:57,600
operation called refresh right after you

425
00:16:57,600 --> 00:16:59,839
make a query you have to perform a

426
00:16:59,839 --> 00:17:02,399
refresh operation because you know when

427
00:17:02,399 --> 00:17:04,559
you make the query you consume one entry

428
00:17:04,559 --> 00:17:07,039
in the hint and you have to replenish

429
00:17:07,039 --> 00:17:08,400
that entry

430
00:17:08,400 --> 00:17:10,160
so i won't actually have time to talk

431
00:17:10,160 --> 00:17:13,679
about the details of the refresh and

432
00:17:13,679 --> 00:17:16,160
and so you know please read the paper

433
00:17:16,160 --> 00:17:19,400
for details

434
00:17:20,240 --> 00:17:22,400
okay so so far we've seen an inefficient

435
00:17:22,400 --> 00:17:25,039
straw man the good news

436
00:17:25,039 --> 00:17:27,359
is that we we've managed to achieve

437
00:17:27,359 --> 00:17:30,960
square root and online time

438
00:17:30,960 --> 00:17:33,760
uh because the server only needs to

439
00:17:33,760 --> 00:17:35,360
compute the parity of a set that's

440
00:17:35,360 --> 00:17:37,520
roughly square root n in size and it

441
00:17:37,520 --> 00:17:39,039
only has to look at the database at

442
00:17:39,039 --> 00:17:40,960
square root and positions

443
00:17:40,960 --> 00:17:43,200
the problem is that the client space is

444
00:17:43,200 --> 00:17:45,520
larger than the database itself and also

445
00:17:45,520 --> 00:17:48,559
the online bandwidth is square root n

446
00:17:48,559 --> 00:17:50,240
because the client is sending the whole

447
00:17:50,240 --> 00:17:51,360
set

448
00:17:51,360 --> 00:17:53,679
to the bottom server during an online

449
00:17:53,679 --> 00:17:56,000
query

450
00:17:56,000 --> 00:17:58,240
what we want to achieve is to reduce the

451
00:17:58,240 --> 00:18:00,160
client space roughly square root n

452
00:18:00,160 --> 00:18:02,160
rather than linear and we also want to

453
00:18:02,160 --> 00:18:03,840
reduce online bandwidth to roughly

454
00:18:03,840 --> 00:18:05,840
polylog

455
00:18:05,840 --> 00:18:07,679
and we want to keep the square root and

456
00:18:07,679 --> 00:18:10,400
online time

457
00:18:11,200 --> 00:18:12,960
okay so one thing i want to mention is

458
00:18:12,960 --> 00:18:14,720
that we want both the client and the

459
00:18:14,720 --> 00:18:16,880
server's online computation to be

460
00:18:16,880 --> 00:18:19,039
small and basically upper bounded by

461
00:18:19,039 --> 00:18:21,440
square root and

462
00:18:21,440 --> 00:18:23,280
so how can we achieve this kind of

463
00:18:23,280 --> 00:18:25,840
compression

464
00:18:27,280 --> 00:18:28,960
and this brings us to

465
00:18:28,960 --> 00:18:32,240
um a cryptographic primitive called

466
00:18:32,240 --> 00:18:35,760
punctuable pseudorandom set

467
00:18:37,919 --> 00:18:39,679
at a high level what we want is the

468
00:18:39,679 --> 00:18:41,840
following and let's start with the

469
00:18:41,840 --> 00:18:44,240
pre-processing phase right so instead of

470
00:18:44,240 --> 00:18:47,200
storing the entire set as one imagine we

471
00:18:47,200 --> 00:18:49,840
compress it down to a small zero key

472
00:18:49,840 --> 00:18:52,400
denoted k1

473
00:18:52,400 --> 00:18:54,240
and if we do this for each of the you

474
00:18:54,240 --> 00:18:56,160
know roughly square root and sets in the

475
00:18:56,160 --> 00:18:58,960
hint we can compress the storage to

476
00:18:58,960 --> 00:19:01,600
um roughly square root n

477
00:19:01,600 --> 00:19:03,440
similarly instead of sending the entire

478
00:19:03,440 --> 00:19:05,840
sets as one to the server the client can

479
00:19:05,840 --> 00:19:08,960
simply send the compressed key k1

480
00:19:08,960 --> 00:19:11,280
and then the server can take this key

481
00:19:11,280 --> 00:19:14,000
and expand it to

482
00:19:14,000 --> 00:19:16,880
the sets the entire set and then it can

483
00:19:16,880 --> 00:19:18,320
compute the parity of these bits and

484
00:19:18,320 --> 00:19:21,439
send it back to the client

485
00:19:22,400 --> 00:19:25,400
okay

486
00:19:27,120 --> 00:19:28,480
so basically at the end of the

487
00:19:28,480 --> 00:19:30,400
preprocessing phase but remember now the

488
00:19:30,400 --> 00:19:32,320
client would be storing roughly square

489
00:19:32,320 --> 00:19:34,400
root and keys rather than square root n

490
00:19:34,400 --> 00:19:36,160
sets

491
00:19:36,160 --> 00:19:40,320
and its space is again square root n

492
00:19:42,320 --> 00:19:44,160
okay so that was the pre-processing

493
00:19:44,160 --> 00:19:45,200
phase and

494
00:19:45,200 --> 00:19:47,360
and that's easy

495
00:19:47,360 --> 00:19:49,760
so now let's look at the online phase

496
00:19:49,760 --> 00:19:51,120
and here something more interesting

497
00:19:51,120 --> 00:19:53,600
happens

498
00:19:53,600 --> 00:19:55,360
in the online phase imagine the client

499
00:19:55,360 --> 00:19:57,360
wants to look up the index

500
00:19:57,360 --> 00:19:59,678
six

501
00:20:01,280 --> 00:20:03,280
as before the you know the client needs

502
00:20:03,280 --> 00:20:06,080
to identify a set in its local hint that

503
00:20:06,080 --> 00:20:08,240
contains the indexes

504
00:20:08,240 --> 00:20:10,640
in other words it wants to find the

505
00:20:10,640 --> 00:20:12,080
key ki

506
00:20:12,080 --> 00:20:14,320
such that six is included in the sets

507
00:20:14,320 --> 00:20:17,280
generated by ki

508
00:20:19,440 --> 00:20:22,320
um remember that in the strongman scheme

509
00:20:22,320 --> 00:20:24,159
the client would we sample the decision

510
00:20:24,159 --> 00:20:26,640
whether six is included in the set and

511
00:20:26,640 --> 00:20:28,640
then send this re-sampled set to the

512
00:20:28,640 --> 00:20:29,919
bottom server

513
00:20:29,919 --> 00:20:32,320
so now here correspondingly we replace

514
00:20:32,320 --> 00:20:35,200
the resampling operation with

515
00:20:35,200 --> 00:20:37,600
a so-called puncture operation

516
00:20:37,600 --> 00:20:40,080
the client punctures the key ki at the

517
00:20:40,080 --> 00:20:41,440
0.6

518
00:20:41,440 --> 00:20:43,679
and this gives a puncture key denoted ki

519
00:20:43,679 --> 00:20:45,919
prime

520
00:20:46,559 --> 00:20:48,240
i want you to think of the puncture key

521
00:20:48,240 --> 00:20:50,159
as the following the set generated by

522
00:20:50,159 --> 00:20:52,400
the puncture tki prime is basically the

523
00:20:52,400 --> 00:20:54,960
set generated by the original ki but

524
00:20:54,960 --> 00:20:59,120
with the 0.6 resampled

525
00:21:01,039 --> 00:21:02,960
okay so i'm going to tell you how to

526
00:21:02,960 --> 00:21:04,559
construct something like this but for

527
00:21:04,559 --> 00:21:06,960
the time being imagine that indeed we

528
00:21:06,960 --> 00:21:08,000
have like

529
00:21:08,000 --> 00:21:10,640
a punctuable cereal and random set

530
00:21:10,640 --> 00:21:11,840
uh

531
00:21:11,840 --> 00:21:13,360
like this right

532
00:21:13,360 --> 00:21:15,280
um

533
00:21:15,280 --> 00:21:17,120
and basically now the client tends to

534
00:21:17,120 --> 00:21:19,600
send the key ki prime to the bottom

535
00:21:19,600 --> 00:21:21,440
server

536
00:21:21,440 --> 00:21:22,720
and the bottom server you know

537
00:21:22,720 --> 00:21:24,480
enumerates the cell generated by this

538
00:21:24,480 --> 00:21:27,600
puncture key ki prime it looks up those

539
00:21:27,600 --> 00:21:29,520
bits in the database and computes

540
00:21:29,520 --> 00:21:31,679
apparently returns it to the client

541
00:21:31,679 --> 00:21:33,440
and basically everything is just like

542
00:21:33,440 --> 00:21:35,120
the straw man scheme except that we are

543
00:21:35,120 --> 00:21:38,640
compressing the sets using 16 keys

544
00:21:38,640 --> 00:21:39,440
and

545
00:21:39,440 --> 00:21:41,360
importantly we need the ability to

546
00:21:41,360 --> 00:21:43,039
puncture a point

547
00:21:43,039 --> 00:21:45,440
from some key that's representing uh

548
00:21:45,440 --> 00:21:48,240
pseudonym set

549
00:21:49,600 --> 00:21:51,600
so a cryptographic object like this is

550
00:21:51,600 --> 00:21:53,760
called the punctual random set

551
00:21:53,760 --> 00:21:56,240
and what it allows you to do is the

552
00:21:56,240 --> 00:21:58,480
following so first we

553
00:21:58,480 --> 00:22:00,320
want to be able to sample a key that

554
00:22:00,320 --> 00:22:01,919
represents a set

555
00:22:01,919 --> 00:22:03,520
with this key we can have a set

556
00:22:03,520 --> 00:22:05,840
enumeration algorithm that expands the

557
00:22:05,840 --> 00:22:08,080
key into a zero random set

558
00:22:08,080 --> 00:22:10,159
and then we can puncture a key at a

559
00:22:10,159 --> 00:22:12,559
certain point which is effectively

560
00:22:12,559 --> 00:22:14,480
resampling whether this puncture point

561
00:22:14,480 --> 00:22:17,760
belongs to the set or not

562
00:22:21,760 --> 00:22:24,880
okay so to use such a punctual ceramic

563
00:22:24,880 --> 00:22:28,240
set scheme in our pir

564
00:22:28,240 --> 00:22:30,080
we want it to satisfy some nice

565
00:22:30,080 --> 00:22:31,520
properties

566
00:22:31,520 --> 00:22:32,799
first

567
00:22:32,799 --> 00:22:34,960
we want to make sure the puncture key

568
00:22:34,960 --> 00:22:37,919
hides the points being punctured and

569
00:22:37,919 --> 00:22:39,520
this is because you know the client

570
00:22:39,520 --> 00:22:41,280
would be sending the puncture key to the

571
00:22:41,280 --> 00:22:43,840
bottom server during the online query

572
00:22:43,840 --> 00:22:44,799
and

573
00:22:44,799 --> 00:22:46,960
due to the privacy requirement of pir

574
00:22:46,960 --> 00:22:48,480
you know it must be that the puncture

575
00:22:48,480 --> 00:22:50,960
key doesn't reveal which index the

576
00:22:50,960 --> 00:22:53,200
client wants

577
00:22:53,200 --> 00:22:56,400
so if a punctuable surround set scheme

578
00:22:56,400 --> 00:22:57,919
satisfies

579
00:22:57,919 --> 00:23:00,559
this private puncturing property we also

580
00:23:00,559 --> 00:23:03,919
call it a privately punctual surround

581
00:23:03,919 --> 00:23:06,159
set

582
00:23:07,520 --> 00:23:09,760
second we want a fast membership test

583
00:23:09,760 --> 00:23:10,880
algorithm

584
00:23:10,880 --> 00:23:12,880
specifically given a key our puncture

585
00:23:12,880 --> 00:23:14,480
key we should be able to determine

586
00:23:14,480 --> 00:23:16,480
whether a given index x belongs to the

587
00:23:16,480 --> 00:23:17,280
set

588
00:23:17,280 --> 00:23:20,320
uh in as small as polylog time

589
00:23:20,320 --> 00:23:22,400
and why do we need this requirement

590
00:23:22,400 --> 00:23:24,320
recall that whenever

591
00:23:24,320 --> 00:23:27,120
a new query comes the client must find a

592
00:23:27,120 --> 00:23:29,760
key ki in its local hint

593
00:23:29,760 --> 00:23:32,080
such that the desired index in this case

594
00:23:32,080 --> 00:23:35,600
6 is included in the set generated by ki

595
00:23:35,600 --> 00:23:37,200
and the way you would do this is

596
00:23:37,200 --> 00:23:38,640
essentially

597
00:23:38,640 --> 00:23:40,640
scan through every key start in the

598
00:23:40,640 --> 00:23:41,840
local hint

599
00:23:41,840 --> 00:23:42,799
and

600
00:23:42,799 --> 00:23:44,720
and test if the desired index belongs to

601
00:23:44,720 --> 00:23:46,320
the sets

602
00:23:46,320 --> 00:23:47,840
because there are as many as square

603
00:23:47,840 --> 00:23:49,520
return keys to check we want to make

604
00:23:49,520 --> 00:23:51,520
sure there's a fast membership test

605
00:23:51,520 --> 00:23:53,600
algorithm

606
00:23:53,600 --> 00:23:55,120
and this will you know make sure the

607
00:23:55,120 --> 00:23:56,880
client's competition is upper bounded by

608
00:23:56,880 --> 00:24:00,080
roughly square root n

609
00:24:01,279 --> 00:24:03,679
finally we want a fast set enumeration

610
00:24:03,679 --> 00:24:06,240
algorithm and that is given a key or

611
00:24:06,240 --> 00:24:08,320
puncture key one should be able to

612
00:24:08,320 --> 00:24:10,559
enumerate the entire set in time roughly

613
00:24:10,559 --> 00:24:11,840
proportional to the size of the

614
00:24:11,840 --> 00:24:13,600
enumerated sets

615
00:24:13,600 --> 00:24:16,559
basically square root n

616
00:24:16,559 --> 00:24:18,159
okay so this is because whenever the

617
00:24:18,159 --> 00:24:20,559
server receives a key or puncture key it

618
00:24:20,559 --> 00:24:23,279
needs to enumerate the entire sets in

619
00:24:23,279 --> 00:24:25,200
time roughly square root n

620
00:24:25,200 --> 00:24:26,880
and then it can look up the database at

621
00:24:26,880 --> 00:24:28,720
those positions and return the parity to

622
00:24:28,720 --> 00:24:31,799
the client

623
00:24:33,440 --> 00:24:35,520
okay just to quickly recap one of these

624
00:24:35,520 --> 00:24:37,919
three nice properties uh from this

625
00:24:37,919 --> 00:24:40,080
punctual and set scheme right the first

626
00:24:40,080 --> 00:24:42,000
is a security property and

627
00:24:42,000 --> 00:24:43,520
the other two

628
00:24:43,520 --> 00:24:47,440
are efficiency properties

629
00:24:47,440 --> 00:24:49,360
and how can we construct such a

630
00:24:49,360 --> 00:24:52,640
punctuation set

631
00:24:52,640 --> 00:24:54,640
uh in some sense you know

632
00:24:54,640 --> 00:24:56,559
curriculum gibbs and kogan in their

633
00:24:56,559 --> 00:24:58,880
paper they encounter the same technical

634
00:24:58,880 --> 00:25:01,039
challenge and they were kind of stuck

635
00:25:01,039 --> 00:25:02,480
here and that's why they didn't have

636
00:25:02,480 --> 00:25:05,520
like an optimal scheme

637
00:25:09,679 --> 00:25:11,039
okay so let's think about how to

638
00:25:11,039 --> 00:25:13,279
construct a privately punctual pseudonym

639
00:25:13,279 --> 00:25:15,520
set

640
00:25:15,520 --> 00:25:16,880
um

641
00:25:16,880 --> 00:25:18,880
you know from fireworks we know how to

642
00:25:18,880 --> 00:25:20,000
construct

643
00:25:20,000 --> 00:25:22,480
a privately punctual prf and this like

644
00:25:22,480 --> 00:25:24,320
seems pretty close to what we want right

645
00:25:24,320 --> 00:25:26,159
so what is a privately punctured

646
00:25:26,159 --> 00:25:30,080
punctual prf um

647
00:25:30,080 --> 00:25:32,480
it is essentially a prf scheme but with

648
00:25:32,480 --> 00:25:35,039
an additional puncture operation the

649
00:25:35,039 --> 00:25:37,039
puncture operation allows you to produce

650
00:25:37,039 --> 00:25:38,720
a puncture key

651
00:25:38,720 --> 00:25:41,120
and and this puncture key

652
00:25:41,120 --> 00:25:44,080
would let you evaluate the pif at any

653
00:25:44,080 --> 00:25:45,919
point except the point that's being

654
00:25:45,919 --> 00:25:48,480
punctured and moreover the puncture key

655
00:25:48,480 --> 00:25:50,320
must hide the points

656
00:25:50,320 --> 00:25:53,039
that is punctured

657
00:25:53,039 --> 00:25:56,039
okay

658
00:25:56,720 --> 00:25:58,960
and here's the most naive approach

659
00:25:58,960 --> 00:26:00,799
let's say we want to know if an element

660
00:26:00,799 --> 00:26:03,440
six is in the set or not we can evaluate

661
00:26:03,440 --> 00:26:06,000
the prf at the point six and check if

662
00:26:06,000 --> 00:26:08,880
the outcome has a half log n trailing

663
00:26:08,880 --> 00:26:10,720
zeros at the end

664
00:26:10,720 --> 00:26:12,720
in this way with roughly one over square

665
00:26:12,720 --> 00:26:14,799
root n probability

666
00:26:14,799 --> 00:26:18,240
it'll get included in the set

667
00:26:19,279 --> 00:26:21,600
puncturing a point is also simple if we

668
00:26:21,600 --> 00:26:23,279
want to puncture a point from the set we

669
00:26:23,279 --> 00:26:25,120
can simply call

670
00:26:25,120 --> 00:26:26,640
the puncture function of the underlying

671
00:26:26,640 --> 00:26:27,840
prf

672
00:26:27,840 --> 00:26:29,840
uh

673
00:26:29,840 --> 00:26:31,760
i recall that if we puncture some point

674
00:26:31,760 --> 00:26:34,080
and use the puncture key to evaluate

675
00:26:34,080 --> 00:26:36,400
at exactly the puncture points it will

676
00:26:36,400 --> 00:26:39,120
just give a still random outcome

677
00:26:39,120 --> 00:26:41,200
so this is as if you know you freshly

678
00:26:41,200 --> 00:26:43,360
resampled whether this particular

679
00:26:43,360 --> 00:26:46,959
element belongs to the set or not

680
00:26:50,080 --> 00:26:52,159
okay so now i want you to take a moment

681
00:26:52,159 --> 00:26:53,600
and think whether something like this

682
00:26:53,600 --> 00:26:56,158
would work

683
00:26:58,240 --> 00:26:59,840
the problem with this approach is that

684
00:26:59,840 --> 00:27:01,760
the set enumeration algorithm takes too

685
00:27:01,760 --> 00:27:04,880
long if i want to enumerate all elements

686
00:27:04,880 --> 00:27:07,360
in the sets generated by some key i

687
00:27:07,360 --> 00:27:09,679
essentially have to perform n individual

688
00:27:09,679 --> 00:27:12,320
membership tests taking linear time and

689
00:27:12,320 --> 00:27:14,240
remember we want square root n rather

690
00:27:14,240 --> 00:27:16,880
than linear

691
00:27:19,120 --> 00:27:21,039
okay so we've seen the strongman scheme

692
00:27:21,039 --> 00:27:22,320
and we learned that if we want to

693
00:27:22,320 --> 00:27:24,640
guarantee fast membership tests and fast

694
00:27:24,640 --> 00:27:27,039
set enumeration at the same time that

695
00:27:27,039 --> 00:27:28,960
seems pretty hard

696
00:27:28,960 --> 00:27:31,600
and this brings us finally to our

697
00:27:31,600 --> 00:27:34,600
approach

698
00:27:34,960 --> 00:27:37,039
at a very high level our key insight is

699
00:27:37,039 --> 00:27:38,559
the following

700
00:27:38,559 --> 00:27:40,799
we will sample the set according to a

701
00:27:40,799 --> 00:27:43,679
carefully crafted distribution and each

702
00:27:43,679 --> 00:27:45,840
element is included in the set

703
00:27:45,840 --> 00:27:48,240
not completely independently there's a

704
00:27:48,240 --> 00:27:50,399
tiny bit of correlation between certain

705
00:27:50,399 --> 00:27:52,960
elements and with this carefully crafted

706
00:27:52,960 --> 00:27:56,159
distribution we can simultaneously have

707
00:27:56,159 --> 00:27:58,320
fast membership tests and fast set

708
00:27:58,320 --> 00:28:00,399
enumeration

709
00:28:00,399 --> 00:28:02,240
but there's just a small caveat that

710
00:28:02,240 --> 00:28:04,480
comes with it and this correlation

711
00:28:04,480 --> 00:28:06,159
between elements

712
00:28:06,159 --> 00:28:08,640
is going to break the puncturing just a

713
00:28:08,640 --> 00:28:10,240
little bit

714
00:28:10,240 --> 00:28:12,320
and it turns out this will introduce a

715
00:28:12,320 --> 00:28:14,080
small error probability

716
00:28:14,080 --> 00:28:14,880
uh

717
00:28:14,880 --> 00:28:17,120
for the puncturing but we can cope with

718
00:28:17,120 --> 00:28:18,880
small error probability using parallel

719
00:28:18,880 --> 00:28:21,039
repetition so it doesn't turn out to be

720
00:28:21,039 --> 00:28:23,679
a big problem

721
00:28:24,480 --> 00:28:28,720
okay so let's see how to actually

722
00:28:28,720 --> 00:28:30,799
instantiate a scheme uh given these

723
00:28:30,799 --> 00:28:33,279
insights

724
00:28:33,679 --> 00:28:36,399
imagine the client has in mind a query

725
00:28:36,399 --> 00:28:38,880
for the index 38

726
00:28:38,880 --> 00:28:40,960
and the client wants to find the key

727
00:28:40,960 --> 00:28:43,360
among other keys it has starts such that

728
00:28:43,360 --> 00:28:45,600
the set generated by the key contains

729
00:28:45,600 --> 00:28:47,760
you know 38

730
00:28:47,760 --> 00:28:49,600
okay so to do this

731
00:28:49,600 --> 00:28:51,600
we want to test and

732
00:28:51,600 --> 00:28:54,960
if the 38 elements belongs to the set or

733
00:28:54,960 --> 00:28:57,960
not

734
00:28:58,080 --> 00:29:00,000
first let's express this number in the

735
00:29:00,000 --> 00:29:01,919
binary format essentially this is the

736
00:29:01,919 --> 00:29:05,039
base representation

737
00:29:05,760 --> 00:29:08,080
next we will pack the string with two

738
00:29:08,080 --> 00:29:10,559
log log n zeros at the front

739
00:29:10,559 --> 00:29:13,279
i'll explain why this padding is needed

740
00:29:13,279 --> 00:29:15,600
later

741
00:29:16,799 --> 00:29:19,679
and we'll take the last half log n bits

742
00:29:19,679 --> 00:29:22,080
and compute the prf of these bits so

743
00:29:22,080 --> 00:29:24,159
when i write h here it doesn't mean a

744
00:29:24,159 --> 00:29:26,640
hash it actually means the punctuable pr

745
00:29:26,640 --> 00:29:28,960
scheme

746
00:29:29,360 --> 00:29:30,960
okay

747
00:29:30,960 --> 00:29:32,960
and not only so

748
00:29:32,960 --> 00:29:35,120
i will repeat the same for every suffix

749
00:29:35,120 --> 00:29:37,760
of the string that's at least half log n

750
00:29:37,760 --> 00:29:39,600
bits long

751
00:29:39,600 --> 00:29:41,279
and now the element belongs to the set

752
00:29:41,279 --> 00:29:44,080
if and only if all of these tests return

753
00:29:44,080 --> 00:29:46,399
true

754
00:29:49,760 --> 00:29:51,360
and here i've just copied the scheme to

755
00:29:51,360 --> 00:29:53,279
the upper left corner so we can keep

756
00:29:53,279 --> 00:29:55,840
looking at it

757
00:29:56,480 --> 00:29:58,799
one question i haven't answered is how

758
00:29:58,799 --> 00:30:01,440
to puncture a point from the set

759
00:30:01,440 --> 00:30:03,360
and that's pretty easy

760
00:30:03,360 --> 00:30:05,440
basically we can puncture all relevant

761
00:30:05,440 --> 00:30:08,880
suffixes from the prf scheme and this

762
00:30:08,880 --> 00:30:10,799
does require a prf that supports

763
00:30:10,799 --> 00:30:14,000
puncturing at login positions and that's

764
00:30:14,000 --> 00:30:15,679
but that's not a problem because we know

765
00:30:15,679 --> 00:30:16,640
how to

766
00:30:16,640 --> 00:30:17,600
um

767
00:30:17,600 --> 00:30:20,880
get it from a standard punctuable prf

768
00:30:20,880 --> 00:30:22,720
that supports puncturing at a single

769
00:30:22,720 --> 00:30:25,039
point

770
00:30:26,480 --> 00:30:28,080
okay

771
00:30:28,080 --> 00:30:30,399
furthermore if the underlying prf is

772
00:30:30,399 --> 00:30:32,799
privately punctual and then the

773
00:30:32,799 --> 00:30:35,679
resulting punctual random set scheme

774
00:30:35,679 --> 00:30:39,679
would also be privately punctual

775
00:30:42,720 --> 00:30:45,039
so what about efficiency it's not hard

776
00:30:45,039 --> 00:30:46,960
to see that the set size is roughly

777
00:30:46,960 --> 00:30:48,960
square root and still

778
00:30:48,960 --> 00:30:51,200
membership test is fast basically the

779
00:30:51,200 --> 00:30:52,640
description of the scheme itself

780
00:30:52,640 --> 00:30:54,159
provides a fast membership test

781
00:30:54,159 --> 00:30:55,600
algorithm

782
00:30:55,600 --> 00:30:58,080
and and you know specifically a

783
00:30:58,080 --> 00:31:00,000
membership test requires computing the

784
00:31:00,000 --> 00:31:01,039
prf

785
00:31:01,039 --> 00:31:03,279
on roughly login points

786
00:31:03,279 --> 00:31:06,000
so it takes time at most polylog

787
00:31:06,000 --> 00:31:08,000
finally i also claim that with this kind

788
00:31:08,000 --> 00:31:09,760
of structure

789
00:31:09,760 --> 00:31:12,240
set enumeration is also efficient and

790
00:31:12,240 --> 00:31:15,840
takes time roughly square root n

791
00:31:16,159 --> 00:31:17,919
so i won't have time to give the details

792
00:31:17,919 --> 00:31:20,000
of the set enumeration algorithm at a

793
00:31:20,000 --> 00:31:22,399
very high level you start with suffixes

794
00:31:22,399 --> 00:31:24,799
of length a half log n and then you keep

795
00:31:24,799 --> 00:31:27,279
expanding them at any point of time you

796
00:31:27,279 --> 00:31:30,159
keep only the suffixes that hash to one

797
00:31:30,159 --> 00:31:32,159
and you throw away the rest and there

798
00:31:32,159 --> 00:31:34,159
should only be roughly the square root

799
00:31:34,159 --> 00:31:36,480
of a square root end of them that you

800
00:31:36,480 --> 00:31:38,159
have to keep

801
00:31:38,159 --> 00:31:41,840
and please read the paper for details

802
00:31:43,760 --> 00:31:45,360
so there's only one last question i

803
00:31:45,360 --> 00:31:47,360
haven't answered yet why do we need

804
00:31:47,360 --> 00:31:48,320
these

805
00:31:48,320 --> 00:31:50,799
zeros at the front

806
00:31:50,799 --> 00:31:52,320
to answer this question recall that

807
00:31:52,320 --> 00:31:54,159
whether two elements belong to the set

808
00:31:54,159 --> 00:31:55,919
or not

809
00:31:55,919 --> 00:31:58,559
are not completely independent there's a

810
00:31:58,559 --> 00:32:00,559
bit of correlation

811
00:32:00,559 --> 00:32:02,640
in this example x and y share a

812
00:32:02,640 --> 00:32:05,120
sufficiently long suffix

813
00:32:05,120 --> 00:32:06,000
uh

814
00:32:06,000 --> 00:32:08,399
recall to test whether x or y is in the

815
00:32:08,399 --> 00:32:09,840
set we need to

816
00:32:09,840 --> 00:32:12,640
compute the prf on every suffix that's

817
00:32:12,640 --> 00:32:15,760
sufficiently long and and therefore if x

818
00:32:15,760 --> 00:32:17,840
is included in the set then y is more

819
00:32:17,840 --> 00:32:20,480
likely going to be included as well

820
00:32:20,480 --> 00:32:22,640
in other words you know x and y

821
00:32:22,640 --> 00:32:26,559
they have a little bit of correlation

822
00:32:26,799 --> 00:32:29,120
this correlation result results in a

823
00:32:29,120 --> 00:32:31,120
small problem if we try to puncture the

824
00:32:31,120 --> 00:32:32,960
point x from the set

825
00:32:32,960 --> 00:32:35,440
uh with the intention of removing x

826
00:32:35,440 --> 00:32:37,840
we might accidentally end up removing y

827
00:32:37,840 --> 00:32:39,919
as well

828
00:32:39,919 --> 00:32:41,679
this isn't the you know intended

829
00:32:41,679 --> 00:32:43,279
behavior we want

830
00:32:43,279 --> 00:32:45,760
if puncturing x causes any other element

831
00:32:45,760 --> 00:32:48,320
to be removed too it'll incur an error

832
00:32:48,320 --> 00:32:50,799
in the prr scheme

833
00:32:50,799 --> 00:32:52,640
but remember what i said about error

834
00:32:52,640 --> 00:32:54,080
right we can deal with small error

835
00:32:54,080 --> 00:32:55,360
probabilities through parallel

836
00:32:55,360 --> 00:32:56,399
repetition

837
00:32:56,399 --> 00:32:58,559
so it turns out you know as long as we

838
00:32:58,559 --> 00:33:00,880
can keep our probability small we are

839
00:33:00,880 --> 00:33:03,519
fine and this is the reason for these

840
00:33:03,519 --> 00:33:05,679
beginning zeros like we are patting

841
00:33:05,679 --> 00:33:08,240
these two log log n zeros in the front

842
00:33:08,240 --> 00:33:11,279
and because it makes the probability

843
00:33:11,279 --> 00:33:13,679
that any element is included uh

844
00:33:13,679 --> 00:33:14,880
in the set

845
00:33:14,880 --> 00:33:17,360
uh poly logarithmically smaller

846
00:33:17,360 --> 00:33:19,440
such that with more than 99

847
00:33:19,440 --> 00:33:20,399
uh

848
00:33:20,399 --> 00:33:23,919
probability puncturing x is not going to

849
00:33:23,919 --> 00:33:26,080
cause any other element to be removed

850
00:33:26,080 --> 00:33:28,000
along the way

851
00:33:28,000 --> 00:33:32,080
our paper contains a detailed analysis

852
00:33:33,120 --> 00:33:35,760
to summarize to get our pir scheme we

853
00:33:35,760 --> 00:33:37,519
just need an efficient privately

854
00:33:37,519 --> 00:33:40,000
punctual surrounding sex

855
00:33:40,000 --> 00:33:42,880
and and constructing such a punctuation

856
00:33:42,880 --> 00:33:44,000
set scheme

857
00:33:44,000 --> 00:33:45,919
with the desired efficiency requirements

858
00:33:45,919 --> 00:33:48,399
is non-trivial as mentioned our key

859
00:33:48,399 --> 00:33:50,159
insight is to sample the set according

860
00:33:50,159 --> 00:33:52,559
to a carefully crafted distribution that

861
00:33:52,559 --> 00:33:54,480
resolves the conflict between fast set

862
00:33:54,480 --> 00:33:57,679
enumeration and fast membership tests

863
00:33:57,679 --> 00:33:59,760
this slide correlation is going to break

864
00:33:59,760 --> 00:34:01,760
the puncturing just a little bit

865
00:34:01,760 --> 00:34:03,600
introducing a small error probability

866
00:34:03,600 --> 00:34:05,279
but we can deal with that through

867
00:34:05,279 --> 00:34:07,039
parallel repetition

868
00:34:07,039 --> 00:34:09,520
our construction is conceptually very

869
00:34:09,520 --> 00:34:10,719
simple

870
00:34:10,719 --> 00:34:12,320
but the proofs are non-trivial

871
00:34:12,320 --> 00:34:14,399
especially the correctness proof

872
00:34:14,399 --> 00:34:16,560
and also although the construction is

873
00:34:16,560 --> 00:34:18,079
conceptually simple if we want to

874
00:34:18,079 --> 00:34:19,280
implement it

875
00:34:19,280 --> 00:34:20,879
we do need

876
00:34:20,879 --> 00:34:22,879
a concretely efficient privately

877
00:34:22,879 --> 00:34:26,000
punctual pr scheme

878
00:34:26,879 --> 00:34:28,239
there's quite a lot of things that i

879
00:34:28,239 --> 00:34:30,079
didn't have time to cover

880
00:34:30,079 --> 00:34:31,520
please see our paper if you are

881
00:34:31,520 --> 00:34:34,520
interested

882
00:34:34,879 --> 00:34:36,719
on a concluding note i want to call your

883
00:34:36,719 --> 00:34:39,119
attention again to this long-time dream

884
00:34:39,119 --> 00:34:41,918
question that's not dear to my heart can

885
00:34:41,918 --> 00:34:44,639
we get a truly practical pir this

886
00:34:44,639 --> 00:34:46,560
question is still open

887
00:34:46,560 --> 00:34:48,239
i'm very happy to discuss with you if

888
00:34:48,239 --> 00:34:50,480
you are also excited about it thank you

889
00:34:50,480 --> 00:34:53,800
very much

