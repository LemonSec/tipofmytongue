1
00:00:00,560 --> 00:00:02,879
hello everyone i'm very happy to talk

2
00:00:02,879 --> 00:00:04,640
about oblivious run with worst case

3
00:00:04,640 --> 00:00:07,200
logarithmic coverage i'm gilad ashram

4
00:00:07,200 --> 00:00:09,200
from bailland university and this is the

5
00:00:09,200 --> 00:00:11,759
german walk with ilan kamalgatsky wake

6
00:00:11,759 --> 00:00:15,719
aileen and elaine she

7
00:00:16,320 --> 00:00:18,080
so what is the problem that oren comes

8
00:00:18,080 --> 00:00:19,199
to address

9
00:00:19,199 --> 00:00:21,439
suppose that we have a secure processor

10
00:00:21,439 --> 00:00:24,160
and an untrusted memory

11
00:00:24,160 --> 00:00:25,039
uh

12
00:00:25,039 --> 00:00:26,800
suppose that we have some client that

13
00:00:26,800 --> 00:00:28,840
uploads this information to our trust

14
00:00:28,840 --> 00:00:31,679
itself even if the uploaded information

15
00:00:31,679 --> 00:00:34,480
is encrypted the access pattern

16
00:00:34,480 --> 00:00:36,800
the memory locations that the client

17
00:00:36,800 --> 00:00:38,719
accesses reveal some sensitive

18
00:00:38,719 --> 00:00:40,000
information

19
00:00:40,000 --> 00:00:42,239
for instance let's say that a medical

20
00:00:42,239 --> 00:00:43,920
doctor uploads all the genomic

21
00:00:43,920 --> 00:00:46,640
information of its client to the cloud

22
00:00:46,640 --> 00:00:48,879
suppose also that the doctor always

23
00:00:48,879 --> 00:00:51,199
accesses regions that relates to the

24
00:00:51,199 --> 00:00:52,399
kidney

25
00:00:52,399 --> 00:00:54,480
even though the data is encrypted and

26
00:00:54,480 --> 00:00:56,559
therefore the server cannot see this

27
00:00:56,559 --> 00:00:59,680
information the server can still infer

28
00:00:59,680 --> 00:01:01,680
that the patient has some kidney problem

29
00:01:01,680 --> 00:01:03,840
and not say a heart problem

30
00:01:03,840 --> 00:01:05,840
and this is a leakage that we want to

31
00:01:05,840 --> 00:01:08,000
prevent

32
00:01:08,000 --> 00:01:10,400
oblivious rom addresses this exact

33
00:01:10,400 --> 00:01:12,880
problem it can be viewed as a compiler

34
00:01:12,880 --> 00:01:15,119
that takes the program that the client

35
00:01:15,119 --> 00:01:16,799
wishes to execute

36
00:01:16,799 --> 00:01:20,159
and convert it to an oblivious

37
00:01:20,159 --> 00:01:21,680
program where the

38
00:01:21,680 --> 00:01:24,960
untrusted server cannot understand which

39
00:01:24,960 --> 00:01:28,000
element the client is actually accessing

40
00:01:28,000 --> 00:01:30,079
this is achieved by shuffling parts of

41
00:01:30,079 --> 00:01:32,479
the memory every now and then and moving

42
00:01:32,479 --> 00:01:36,560
blocks around to hide the access button

43
00:01:36,560 --> 00:01:38,720
the security requirement is that the

44
00:01:38,720 --> 00:01:41,360
access pattern which addresses are being

45
00:01:41,360 --> 00:01:43,920
accessed in the physical memory can be

46
00:01:43,920 --> 00:01:46,159
simulated and therefore they do not

47
00:01:46,159 --> 00:01:48,799
reveal information on which addresses

48
00:01:48,799 --> 00:01:51,600
are being accessed by the program

49
00:01:51,600 --> 00:01:53,520
naturally oblivious realms also

50
00:01:53,520 --> 00:01:56,000
introduced some over it this shuffling

51
00:01:56,000 --> 00:01:58,240
of the memory and moving blocks around

52
00:01:58,240 --> 00:02:01,040
every now and then are expensive and

53
00:02:01,040 --> 00:02:03,119
every access to the logical in the

54
00:02:03,119 --> 00:02:06,320
logical memory is translated to many

55
00:02:06,320 --> 00:02:08,878
accesses by the oblivious round compiler

56
00:02:08,878 --> 00:02:11,520
to the physical memory

57
00:02:11,520 --> 00:02:13,200
how many accesses

58
00:02:13,200 --> 00:02:14,720
so we are looking at the standard

59
00:02:14,720 --> 00:02:16,879
setting where n is the size of the

60
00:02:16,879 --> 00:02:18,000
memory

61
00:02:18,000 --> 00:02:20,239
the world size is login

62
00:02:20,239 --> 00:02:23,599
and the client's memory sizes is of all

63
00:02:23,599 --> 00:02:25,840
the one volts

64
00:02:25,840 --> 00:02:28,080
in this uh setting there is a lower

65
00:02:28,080 --> 00:02:30,959
bound uh that every error must introduce

66
00:02:30,959 --> 00:02:33,280
omega log n

67
00:02:33,280 --> 00:02:35,599
uh over it this means that if the

68
00:02:35,599 --> 00:02:38,640
program has to perform m accesses

69
00:02:38,640 --> 00:02:41,920
to a memory of size n then the oblivious

70
00:02:41,920 --> 00:02:44,160
program or the compiled program must

71
00:02:44,160 --> 00:02:47,360
have m log n access to the physical

72
00:02:47,360 --> 00:02:49,280
memory

73
00:02:49,280 --> 00:02:51,280
in this setting there is a long line of

74
00:02:51,280 --> 00:02:54,000
forks that try to match this low bar and

75
00:02:54,000 --> 00:02:55,519
this lower bound

76
00:02:55,519 --> 00:02:58,319
just uh was just matched matched last

77
00:02:58,319 --> 00:02:59,200
year

78
00:02:59,200 --> 00:03:01,360
uh by a construction that is called

79
00:03:01,360 --> 00:03:03,360
optorama

80
00:03:03,360 --> 00:03:06,959
although a cluster look shows that um

81
00:03:06,959 --> 00:03:09,120
in all those works

82
00:03:09,120 --> 00:03:11,440
uh they achieve those complexities in

83
00:03:11,440 --> 00:03:14,720
the amortized sense this means that on m

84
00:03:14,720 --> 00:03:18,400
axis the total work would be m log n

85
00:03:18,400 --> 00:03:21,360
but for some axises they might

86
00:03:21,360 --> 00:03:24,000
take much longer in particular

87
00:03:24,000 --> 00:03:25,920
in those constructions the worst case

88
00:03:25,920 --> 00:03:30,559
complexity is sometimes even linear

89
00:03:31,680 --> 00:03:33,360
some techniques were previously

90
00:03:33,360 --> 00:03:36,159
introduced for uh de-amortizing aura

91
00:03:36,159 --> 00:03:37,840
however those techniques are not

92
00:03:37,840 --> 00:03:41,920
compatible with the recent uh

93
00:03:41,920 --> 00:03:43,760
recent constructions of

94
00:03:43,760 --> 00:03:46,400
panorama and optorum

95
00:03:46,400 --> 00:03:48,400
this means that when we look at worst

96
00:03:48,400 --> 00:03:51,280
case complexity we have a relatively

97
00:03:51,280 --> 00:03:55,040
large gap between the best known orange

98
00:03:55,040 --> 00:03:58,080
and the long one

99
00:03:58,080 --> 00:04:01,040
to elaborate further both panorama and

100
00:04:01,040 --> 00:04:03,920
optorama use it uh what is so called the

101
00:04:03,920 --> 00:04:06,080
randomness reuse technique

102
00:04:06,080 --> 00:04:08,000
i will talk about this technique later

103
00:04:08,000 --> 00:04:09,280
in the top

104
00:04:09,280 --> 00:04:12,000
the de-amortization method of

105
00:04:12,000 --> 00:04:15,040
of straw skin soup is not compatible

106
00:04:15,040 --> 00:04:16,639
with this technique

107
00:04:16,639 --> 00:04:19,440
this leads us to our question is it even

108
00:04:19,440 --> 00:04:22,079
possible to de-amortize constructions

109
00:04:22,079 --> 00:04:23,759
that are based on randomness to use

110
00:04:23,759 --> 00:04:27,840
technique such as panorama and octorama

111
00:04:27,840 --> 00:04:28,960
results

112
00:04:28,960 --> 00:04:31,919
we show that there is an orum with order

113
00:04:31,919 --> 00:04:34,400
log and worst case over it

114
00:04:34,400 --> 00:04:36,800
we show a new demotization method that

115
00:04:36,800 --> 00:04:38,800
is compatible with the randomness to use

116
00:04:38,800 --> 00:04:40,160
technique

117
00:04:40,160 --> 00:04:43,280
this means in particular uh that we show

118
00:04:43,280 --> 00:04:45,440
out to de-amortize the optorama

119
00:04:45,440 --> 00:04:46,960
construction

120
00:04:46,960 --> 00:04:49,759
along the way we also show a new

121
00:04:49,759 --> 00:04:52,160
algorithm for removing duplications in

122
00:04:52,160 --> 00:04:53,440
array

123
00:04:53,440 --> 00:04:57,520
which might be an independent interest

124
00:04:57,520 --> 00:04:59,680
the algorithm works in linear time

125
00:04:59,680 --> 00:05:02,320
assuming some assumption on the inputs

126
00:05:02,320 --> 00:05:05,520
well the best known algorithm uh

127
00:05:05,520 --> 00:05:06,880
beforehand

128
00:05:06,880 --> 00:05:09,520
and without this input assumption

129
00:05:09,520 --> 00:05:10,560
requires

130
00:05:10,560 --> 00:05:12,880
or takes and login

131
00:05:12,880 --> 00:05:14,560
i'm going to describe this primitive

132
00:05:14,560 --> 00:05:16,800
later

133
00:05:16,800 --> 00:05:19,120
in the rest of this presentation i will

134
00:05:19,120 --> 00:05:21,280
start by briefly explaining hierarchical

135
00:05:21,280 --> 00:05:22,240
aura

136
00:05:22,240 --> 00:05:24,479
this is a common framework for building

137
00:05:24,479 --> 00:05:28,400
an auram introduced by ostrovsky 1990.

138
00:05:28,400 --> 00:05:30,880
both panorama and optorama followed this

139
00:05:30,880 --> 00:05:32,080
framework

140
00:05:32,080 --> 00:05:34,000
i will then explain the de-amortization

141
00:05:34,000 --> 00:05:36,160
method of ostravskinship

142
00:05:36,160 --> 00:05:38,080
i will cover the randomness reuse

143
00:05:38,080 --> 00:05:40,560
technique of panorama and optorama and i

144
00:05:40,560 --> 00:05:43,120
will explain why this technique is not

145
00:05:43,120 --> 00:05:45,039
compatible with the de-amortization

146
00:05:45,039 --> 00:05:47,680
method of a strobe skinship

147
00:05:47,680 --> 00:05:49,919
i will then say some words about our

148
00:05:49,919 --> 00:05:52,479
de-amortization method while referring

149
00:05:52,479 --> 00:05:55,919
to the paper for the actual details

150
00:05:55,919 --> 00:05:57,840
i will start with briefly explaining

151
00:05:57,840 --> 00:06:00,479
analytical aura we have login levels of

152
00:06:00,479 --> 00:06:02,160
doubling sizes

153
00:06:02,160 --> 00:06:04,560
each level is a hash table where the

154
00:06:04,560 --> 00:06:07,840
life level is of size 2 to the i

155
00:06:07,840 --> 00:06:10,639
some of the levels are going to be empty

156
00:06:10,639 --> 00:06:12,479
and some of the levels are going to be

157
00:06:12,479 --> 00:06:14,080
full

158
00:06:14,080 --> 00:06:16,720
each level of size n can support up to n

159
00:06:16,720 --> 00:06:17,840
lookups

160
00:06:17,840 --> 00:06:20,479
this means that every n accesses to the

161
00:06:20,479 --> 00:06:24,000
level every n lookups we are we must

162
00:06:24,000 --> 00:06:26,319
rebuild that level

163
00:06:26,319 --> 00:06:28,560
the lookups are cheap for this stock we

164
00:06:28,560 --> 00:06:30,240
can assume that the lookup takes a

165
00:06:30,240 --> 00:06:32,240
constant amount of work

166
00:06:32,240 --> 00:06:34,639
but rebuilding the level is an expensive

167
00:06:34,639 --> 00:06:37,600
operation that takes over the n log n

168
00:06:37,600 --> 00:06:38,639
work

169
00:06:38,639 --> 00:06:40,960
i will now explain how an access looks

170
00:06:40,960 --> 00:06:41,840
like

171
00:06:41,840 --> 00:06:44,160
for demonstration purposes i am going to

172
00:06:44,160 --> 00:06:47,120
add some pairs of addresses and data

173
00:06:47,120 --> 00:06:51,280
for example the content of address 5

174
00:06:51,280 --> 00:06:53,440
in the memory will be found in this

175
00:06:53,440 --> 00:06:56,000
table in the fourth table

176
00:06:56,000 --> 00:06:56,880
and

177
00:06:56,880 --> 00:07:01,199
its associated data is tlt

178
00:07:01,440 --> 00:07:03,120
now let's assume that the client wants

179
00:07:03,120 --> 00:07:05,840
to read the content of address 9.

180
00:07:05,840 --> 00:07:08,319
this is translated to lookups in each

181
00:07:08,319 --> 00:07:12,080
one of the non-empty levels

182
00:07:13,599 --> 00:07:16,160
and the element is going to be found in

183
00:07:16,160 --> 00:07:19,680
the last level over here we can now read

184
00:07:19,680 --> 00:07:23,360
the data associated to 9 which is bcd in

185
00:07:23,360 --> 00:07:26,160
this example

186
00:07:26,319 --> 00:07:28,080
after we read the element we are going

187
00:07:28,080 --> 00:07:30,880
to write it into the first lab

188
00:07:30,880 --> 00:07:33,759
now let's assume that the client wishes

189
00:07:33,759 --> 00:07:36,970
to write address 25

190
00:07:36,970 --> 00:07:38,880
[Music]

191
00:07:38,880 --> 00:07:42,400
to address 25 the value gly

192
00:07:42,400 --> 00:07:45,199
again it's going to look up of of two

193
00:07:45,199 --> 00:07:49,520
four of 25 in each one of the um

194
00:07:49,520 --> 00:07:51,120
in each level

195
00:07:51,120 --> 00:07:54,319
after it's going to find 25 over here

196
00:07:54,319 --> 00:07:56,960
it's going to pretend to look up in the

197
00:07:56,960 --> 00:07:58,639
rest of the levels to have the same

198
00:07:58,639 --> 00:08:00,720
access pattern

199
00:08:00,720 --> 00:08:03,440
after finding 25

200
00:08:03,440 --> 00:08:05,599
we now know its value we are going to

201
00:08:05,599 --> 00:08:07,919
override on this value

202
00:08:07,919 --> 00:08:09,759
and we are going to write into the first

203
00:08:09,759 --> 00:08:12,560
level the value gry the new value that

204
00:08:12,560 --> 00:08:16,160
the client wishes to write

205
00:08:16,160 --> 00:08:16,960
now

206
00:08:16,960 --> 00:08:19,120
however we cannot really write into the

207
00:08:19,120 --> 00:08:21,360
first level because it's full

208
00:08:21,360 --> 00:08:24,160
and we have to rebuild the next level

209
00:08:24,160 --> 00:08:25,599
level two

210
00:08:25,599 --> 00:08:27,280
and we're going to rebuild the level

211
00:08:27,280 --> 00:08:28,960
from the content of the two previous

212
00:08:28,960 --> 00:08:30,879
levels of of the

213
00:08:30,879 --> 00:08:32,240
level one

214
00:08:32,240 --> 00:08:36,320
and the new element uh 25

215
00:08:36,320 --> 00:08:38,320
after some more accesses we're going to

216
00:08:38,320 --> 00:08:39,679
have the same things we are going to

217
00:08:39,679 --> 00:08:41,519
look up in each one of the levels right

218
00:08:41,519 --> 00:08:43,120
in the first level

219
00:08:43,120 --> 00:08:44,800
and then the first level is going to be

220
00:08:44,800 --> 00:08:48,000
full and after some more accesses

221
00:08:48,000 --> 00:08:50,560
uh we have to rebuild

222
00:08:50,560 --> 00:08:51,680
uh

223
00:08:51,680 --> 00:08:54,000
the next level the next empty level from

224
00:08:54,000 --> 00:08:57,040
the content of all previous

225
00:08:57,040 --> 00:08:59,440
levels okay so we're going to

226
00:08:59,440 --> 00:09:00,399
write

227
00:09:00,399 --> 00:09:02,240
level three from the content of level

228
00:09:02,240 --> 00:09:03,680
one and two

229
00:09:03,680 --> 00:09:05,920
in general what happens here is that

230
00:09:05,920 --> 00:09:09,360
every two to the i accesses level i is

231
00:09:09,360 --> 00:09:11,760
being rebuilt from the content of all

232
00:09:11,760 --> 00:09:13,680
levels that are above it

233
00:09:13,680 --> 00:09:16,399
after another to the eye accesses its

234
00:09:16,399 --> 00:09:18,720
elements will be pushed down and will

235
00:09:18,720 --> 00:09:20,399
become empty again

236
00:09:20,399 --> 00:09:22,320
after another two to three i accesses it

237
00:09:22,320 --> 00:09:24,080
will again be rebuilt from the content

238
00:09:24,080 --> 00:09:26,320
of all levels above it

239
00:09:26,320 --> 00:09:29,440
each rebuild is an expensive operation

240
00:09:29,440 --> 00:09:33,200
which costs something like m logan

241
00:09:33,760 --> 00:09:35,760
i'm now going to describe a slightly

242
00:09:35,760 --> 00:09:38,480
different approach for rebuilding

243
00:09:38,480 --> 00:09:40,399
this new approach will be easier to do

244
00:09:40,399 --> 00:09:42,720
the amortized so in the previous

245
00:09:42,720 --> 00:09:46,240
approach every 2di accesses we pushed

246
00:09:46,240 --> 00:09:48,720
all the all the top levels into the

247
00:09:48,720 --> 00:09:51,360
height level

248
00:09:51,360 --> 00:09:53,839
this is quite expensive instead i want

249
00:09:53,839 --> 00:09:57,279
to break it down into smaller operations

250
00:09:57,279 --> 00:09:58,959
and what we do is that we push the

251
00:09:58,959 --> 00:10:01,519
content of each uh

252
00:10:01,519 --> 00:10:02,560
table

253
00:10:02,560 --> 00:10:04,720
to the level below it

254
00:10:04,720 --> 00:10:06,880
previously each level could have been

255
00:10:06,880 --> 00:10:09,920
either full or empty

256
00:10:09,920 --> 00:10:11,839
now what we're going to have is that

257
00:10:11,839 --> 00:10:15,200
each level is either full or half full

258
00:10:15,200 --> 00:10:17,040
and only the first level can be

259
00:10:17,040 --> 00:10:19,040
completely empty

260
00:10:19,040 --> 00:10:21,600
okay so what's going to happen now is

261
00:10:21,600 --> 00:10:24,480
that i'm going to push each level to the

262
00:10:24,480 --> 00:10:25,920
level below it

263
00:10:25,920 --> 00:10:27,920
so the content of all those elements is

264
00:10:27,920 --> 00:10:28,959
going to be

265
00:10:28,959 --> 00:10:31,279
to to be pushed over here

266
00:10:31,279 --> 00:10:33,360
and therefore this one is going to be

267
00:10:33,360 --> 00:10:34,800
half empty

268
00:10:34,800 --> 00:10:36,160
half full

269
00:10:36,160 --> 00:10:39,279
uh after the rebuild process

270
00:10:39,279 --> 00:10:41,279
this level is going to be pushed over

271
00:10:41,279 --> 00:10:43,680
here and this level

272
00:10:43,680 --> 00:10:45,440
is going to be pushed

273
00:10:45,440 --> 00:10:47,839
into this level and it's going to be

274
00:10:47,839 --> 00:10:50,800
merged actually so at the end of this

275
00:10:50,800 --> 00:10:53,040
process the first level is going to be

276
00:10:53,040 --> 00:10:55,200
empty those two levels are going to be

277
00:10:55,200 --> 00:10:58,000
half full and this level is going to be

278
00:10:58,000 --> 00:10:58,800
full

279
00:10:58,800 --> 00:11:01,200
so if previously we looked for the first

280
00:11:01,200 --> 00:11:02,640
empty level

281
00:11:02,640 --> 00:11:05,040
now we are going to look for the first

282
00:11:05,040 --> 00:11:07,839
half full level we are going to push

283
00:11:07,839 --> 00:11:11,440
down all elements into it

284
00:11:11,440 --> 00:11:14,079
how does it help us and why does it help

285
00:11:14,079 --> 00:11:15,120
us

286
00:11:15,120 --> 00:11:17,279
now when we rebuild we just need to look

287
00:11:17,279 --> 00:11:19,600
on two levels two consecutive levels we

288
00:11:19,600 --> 00:11:20,800
don't need to look on the entire

289
00:11:20,800 --> 00:11:22,959
structures above it

290
00:11:22,959 --> 00:11:24,880
there are two possible procedures either

291
00:11:24,880 --> 00:11:27,040
we just push down

292
00:11:27,040 --> 00:11:30,640
or we are going to merge the two levels

293
00:11:30,640 --> 00:11:33,360
either i rebuild i know exactly what i'm

294
00:11:33,360 --> 00:11:34,880
going to rebuild is exactly all the

295
00:11:34,880 --> 00:11:37,519
elements above me and my elements are

296
00:11:37,519 --> 00:11:40,000
going to be pushing down also

297
00:11:40,000 --> 00:11:41,760
or that i am the last level to be

298
00:11:41,760 --> 00:11:43,839
rebuilt so i'm just getting more

299
00:11:43,839 --> 00:11:46,160
elements from the level above me that's

300
00:11:46,160 --> 00:11:47,519
like a merge

301
00:11:47,519 --> 00:11:49,839
between the two um

302
00:11:49,839 --> 00:11:52,079
to uh two levels

303
00:11:52,079 --> 00:11:54,560
okay so this is easier to be amortized

304
00:11:54,560 --> 00:11:56,399
because i need now only to look at two

305
00:11:56,399 --> 00:11:59,440
consecutive levels

306
00:11:59,440 --> 00:12:01,680
now let's take a look at the life cycle

307
00:12:01,680 --> 00:12:04,880
of level i and i minus one

308
00:12:04,880 --> 00:12:08,399
this line is represents a timeline

309
00:12:08,399 --> 00:12:09,839
remember that on

310
00:12:09,839 --> 00:12:12,399
each table of size n we can accommodate

311
00:12:12,399 --> 00:12:15,680
only n lookups and after n lookups it

312
00:12:15,680 --> 00:12:17,519
has to be rebuilt

313
00:12:17,519 --> 00:12:19,600
those after two to the i minus one

314
00:12:19,600 --> 00:12:20,880
accesses

315
00:12:20,880 --> 00:12:23,200
level i minus one

316
00:12:23,200 --> 00:12:25,519
cannot be accessed anymore

317
00:12:25,519 --> 00:12:27,519
and we must rebuild it

318
00:12:27,519 --> 00:12:30,399
now the rebuild is expensive we have to

319
00:12:30,399 --> 00:12:34,000
wait we have some delay and so on

320
00:12:34,000 --> 00:12:35,839
okay at this point we have to rebuild

321
00:12:35,839 --> 00:12:38,800
level i minus one

322
00:12:38,800 --> 00:12:41,279
at this point level i minus 1 was

323
00:12:41,279 --> 00:12:44,399
rebuilt we can accommodate another 2 to

324
00:12:44,399 --> 00:12:46,800
the i minus 1 axises

325
00:12:46,800 --> 00:12:49,279
and here we are must rebuild both level

326
00:12:49,279 --> 00:12:52,720
i minus 1 and level i again this is

327
00:12:52,720 --> 00:12:55,040
expensive we'll have to wait it will

328
00:12:55,040 --> 00:12:56,800
take time

329
00:12:56,800 --> 00:12:59,440
after those two levels were rebuilt

330
00:12:59,440 --> 00:13:01,920
i again can accommodate to the i minus 1

331
00:13:01,920 --> 00:13:04,639
axises i reach this point i need to

332
00:13:04,639 --> 00:13:06,399
rebuild again

333
00:13:06,399 --> 00:13:09,360
another two to the i minus one axises

334
00:13:09,360 --> 00:13:11,440
and then i have to repeat both level i

335
00:13:11,440 --> 00:13:15,279
minus one and level i

336
00:13:15,760 --> 00:13:16,560
now

337
00:13:16,560 --> 00:13:21,120
let's de-amortize this process um we are

338
00:13:21,120 --> 00:13:23,600
now focusing i'm now going to focus only

339
00:13:23,600 --> 00:13:26,720
on level i and not level i minus one

340
00:13:26,720 --> 00:13:28,880
and let's take a look at this point of

341
00:13:28,880 --> 00:13:29,680
time

342
00:13:29,680 --> 00:13:31,440
at this point

343
00:13:31,440 --> 00:13:34,800
this level i minus one is already re it

344
00:13:34,800 --> 00:13:37,040
was already rebuilt

345
00:13:37,040 --> 00:13:39,519
and i know that in the future at this

346
00:13:39,519 --> 00:13:43,360
point i will need to rebuild level i

347
00:13:43,360 --> 00:13:46,000
and i know exactly which elements are

348
00:13:46,000 --> 00:13:49,120
going to be rebuilt like which elements

349
00:13:49,120 --> 00:13:51,920
will be pushed down into level i

350
00:13:51,920 --> 00:13:54,240
so i can start the rebuild process of

351
00:13:54,240 --> 00:13:55,519
level i

352
00:13:55,519 --> 00:13:57,920
already at this point

353
00:13:57,920 --> 00:14:00,160
and i can start rebuilding level i from

354
00:14:00,160 --> 00:14:02,560
the content of all elements in level i

355
00:14:02,560 --> 00:14:04,880
minus one

356
00:14:04,880 --> 00:14:06,880
and

357
00:14:06,880 --> 00:14:08,399
and because

358
00:14:08,399 --> 00:14:10,720
i know it in advance i can spread the

359
00:14:10,720 --> 00:14:12,240
reveal process

360
00:14:12,240 --> 00:14:15,519
over many axises such that in each

361
00:14:15,519 --> 00:14:18,639
access i'm gonna do a little bit of work

362
00:14:18,639 --> 00:14:22,320
towards uh rebuilding level i

363
00:14:22,320 --> 00:14:26,320
so the cost per access is is low

364
00:14:26,320 --> 00:14:28,480
when we reach this point

365
00:14:28,480 --> 00:14:31,760
level i is already rebuilt

366
00:14:31,760 --> 00:14:33,920
we finished the rebuilding of level i

367
00:14:33,920 --> 00:14:36,720
and we can immediately start to use the

368
00:14:36,720 --> 00:14:39,680
new table that we just built

369
00:14:39,680 --> 00:14:40,880
and we can

370
00:14:40,880 --> 00:14:44,399
proceed without any delays

371
00:14:44,399 --> 00:14:46,959
again uh

372
00:14:46,959 --> 00:14:50,480
after i two did the i minus one axises

373
00:14:50,480 --> 00:14:53,680
at this point of time level i minus one

374
00:14:53,680 --> 00:14:55,360
is revealed

375
00:14:55,360 --> 00:14:58,240
and now i know exactly which elements

376
00:14:58,240 --> 00:14:59,600
i'm going to

377
00:14:59,600 --> 00:15:00,959
rebuild

378
00:15:00,959 --> 00:15:02,800
in level i

379
00:15:02,800 --> 00:15:04,880
when i need to rebuild it

380
00:15:04,880 --> 00:15:07,519
so i can start the rebuild process in

381
00:15:07,519 --> 00:15:10,000
advance

382
00:15:10,399 --> 00:15:13,279
when we cannot uh

383
00:15:13,279 --> 00:15:15,519
okay and then i start to rebuild again

384
00:15:15,519 --> 00:15:17,600
i'm spreading it throughout many

385
00:15:17,600 --> 00:15:20,320
accesses and when i cannot use the ice

386
00:15:20,320 --> 00:15:22,000
table anymore

387
00:15:22,000 --> 00:15:24,639
uh we finish the reveal process exactly

388
00:15:24,639 --> 00:15:27,279
at the same time and we can just proceed

389
00:15:27,279 --> 00:15:30,240
with the new table with the table just

390
00:15:30,240 --> 00:15:32,320
remember

391
00:15:32,320 --> 00:15:34,639
to conclude the idea is that we know in

392
00:15:34,639 --> 00:15:37,759
advance what exactly we want to rebuild

393
00:15:37,759 --> 00:15:40,320
and we can just start the repeat process

394
00:15:40,320 --> 00:15:44,800
earlier in parallel to our accesses

395
00:15:44,800 --> 00:15:47,839
far before the deadline so that when we

396
00:15:47,839 --> 00:15:50,240
reach the deadline with the new table

397
00:15:50,240 --> 00:15:52,320
it's already ready

398
00:15:52,320 --> 00:15:54,720
we with each access to the structure we

399
00:15:54,720 --> 00:15:58,639
perform a little bit of the rebuild

400
00:15:59,199 --> 00:16:01,759
so what goes wrong with uh panorama and

401
00:16:01,759 --> 00:16:04,000
optorama

402
00:16:04,000 --> 00:16:07,199
the key idea of panorama of the rama is

403
00:16:07,199 --> 00:16:09,360
what is so called the randomness reuse

404
00:16:09,360 --> 00:16:10,800
technique

405
00:16:10,800 --> 00:16:13,519
the idea is that if we take a table

406
00:16:13,519 --> 00:16:16,079
and we shuffle all the elements

407
00:16:16,079 --> 00:16:17,759
and

408
00:16:17,759 --> 00:16:20,000
and then

409
00:16:20,000 --> 00:16:22,560
whatever we don't touch

410
00:16:22,560 --> 00:16:24,959
whatever elements we didn't look for

411
00:16:24,959 --> 00:16:26,959
those elements are still randomly

412
00:16:26,959 --> 00:16:28,000
shuffled

413
00:16:28,000 --> 00:16:31,120
from the eye of the adversary didn't see

414
00:16:31,120 --> 00:16:33,120
where those ornaments are

415
00:16:33,120 --> 00:16:35,040
so the idea is that don't we don't

416
00:16:35,040 --> 00:16:37,440
really need to rebuild everything from

417
00:16:37,440 --> 00:16:38,720
scratch

418
00:16:38,720 --> 00:16:40,959
in each reveal process

419
00:16:40,959 --> 00:16:43,199
we can just rebuild

420
00:16:43,199 --> 00:16:44,079
uh

421
00:16:44,079 --> 00:16:45,120
whatever

422
00:16:45,120 --> 00:16:47,680
the adversary didn't see is still a

423
00:16:47,680 --> 00:16:51,120
secret and we don't have to rebuild it

424
00:16:51,120 --> 00:16:53,759
so this reduces this idea

425
00:16:53,759 --> 00:16:55,040
um

426
00:16:55,040 --> 00:16:56,639
it shows

427
00:16:56,639 --> 00:16:59,440
the paper shows are the how to reduce

428
00:16:59,440 --> 00:17:01,120
the rebuild process

429
00:17:01,120 --> 00:17:05,839
from n log n to to just order and walk

430
00:17:05,839 --> 00:17:08,559
okay the idea is that whatever we didn't

431
00:17:08,559 --> 00:17:10,000
look for

432
00:17:10,000 --> 00:17:12,880
we don't really have to uh rebuild it we

433
00:17:12,880 --> 00:17:14,640
don't really have to

434
00:17:14,640 --> 00:17:16,400
reshuffle it

435
00:17:16,400 --> 00:17:20,319
we can reuse the randomness that we have

436
00:17:20,319 --> 00:17:21,919
what is the main challenge when you come

437
00:17:21,919 --> 00:17:24,240
to the amortize this process

438
00:17:24,240 --> 00:17:25,599
so

439
00:17:25,599 --> 00:17:28,240
this randomly used brings the following

440
00:17:28,240 --> 00:17:30,880
problem if we want to start rebuilding

441
00:17:30,880 --> 00:17:32,400
the table

442
00:17:32,400 --> 00:17:35,039
but then let's assume that we are making

443
00:17:35,039 --> 00:17:36,960
we are going to access

444
00:17:36,960 --> 00:17:39,120
element 25

445
00:17:39,120 --> 00:17:41,520
this means that we cannot

446
00:17:41,520 --> 00:17:44,400
now we reveal the randomness of 25 we

447
00:17:44,400 --> 00:17:46,720
consume that randomness

448
00:17:46,720 --> 00:17:50,559
and therefore this rebuild process uh is

449
00:17:50,559 --> 00:17:51,440
just

450
00:17:51,440 --> 00:17:53,280
it's not going to work

451
00:17:53,280 --> 00:17:54,799
we um

452
00:17:54,799 --> 00:17:57,600
we perform the lookup

453
00:17:57,600 --> 00:18:01,440
and we cannot reuse the randomness of 25

454
00:18:01,440 --> 00:18:03,760
we just consumed it over here

455
00:18:03,760 --> 00:18:06,240
so this is problematic we cannot start

456
00:18:06,240 --> 00:18:08,000
to build in advance

457
00:18:08,000 --> 00:18:09,840
as we don't know which elements we are

458
00:18:09,840 --> 00:18:11,760
going to look up

459
00:18:11,760 --> 00:18:13,919
on the other end we also cannot allow

460
00:18:13,919 --> 00:18:16,720
ourselves to start rebuild after we know

461
00:18:16,720 --> 00:18:19,039
what lookups will be looked for

462
00:18:19,039 --> 00:18:23,200
because this is going to be too late

463
00:18:24,000 --> 00:18:26,240
this brings us to the main idea of our

464
00:18:26,240 --> 00:18:27,840
new technique

465
00:18:27,840 --> 00:18:30,480
so the main idea behind our solution is

466
00:18:30,480 --> 00:18:33,600
the following we maintain two copies of

467
00:18:33,600 --> 00:18:36,559
each level copy a and copy b

468
00:18:36,559 --> 00:18:38,559
and each has its own independent

469
00:18:38,559 --> 00:18:41,200
randomness

470
00:18:41,280 --> 00:18:42,480
whenever we

471
00:18:42,480 --> 00:18:46,160
rebuild let's say uh we're rebuilding a

472
00:18:46,160 --> 00:18:49,120
copy b we'll build this table this level

473
00:18:49,120 --> 00:18:50,640
of copy b

474
00:18:50,640 --> 00:18:52,400
all the lookups are going to be

475
00:18:52,400 --> 00:18:56,400
performed on level a on the copy a sorry

476
00:18:56,400 --> 00:18:58,799
on copy a we're not going to perform the

477
00:18:58,799 --> 00:19:00,960
lookups on copy b

478
00:19:00,960 --> 00:19:04,400
and vice versa when a is being rebuilt

479
00:19:04,400 --> 00:19:06,400
we are going to perform all the lookups

480
00:19:06,400 --> 00:19:08,840
on copy b

481
00:19:08,840 --> 00:19:12,160
um this means that we never really

482
00:19:12,160 --> 00:19:14,320
reconsume randomness

483
00:19:14,320 --> 00:19:16,880
as the lookups are going to be in a

484
00:19:16,880 --> 00:19:18,960
different structure completely

485
00:19:18,960 --> 00:19:20,400
independent to whatever we are

486
00:19:20,400 --> 00:19:22,640
rebuilding

487
00:19:22,640 --> 00:19:25,360
uh whenever an element is found in one

488
00:19:25,360 --> 00:19:27,120
of the in the

489
00:19:27,120 --> 00:19:29,280
in one of the structures we are going to

490
00:19:29,280 --> 00:19:32,320
write it to both

491
00:19:32,320 --> 00:19:33,760
both copies

492
00:19:33,760 --> 00:19:35,679
okay this means that we are going to

493
00:19:35,679 --> 00:19:39,840
make new copies of the same elements

494
00:19:39,840 --> 00:19:42,240
this is very very high level description

495
00:19:42,240 --> 00:19:44,080
and the actual scheduling is a bit

496
00:19:44,080 --> 00:19:45,679
subtle because

497
00:19:45,679 --> 00:19:48,480
elements move from one to another and

498
00:19:48,480 --> 00:19:50,320
i'm just referring to the paper for the

499
00:19:50,320 --> 00:19:53,280
actual details

500
00:19:53,280 --> 00:19:55,600
this solution brings us to some more

501
00:19:55,600 --> 00:19:58,000
challenges one of them

502
00:19:58,000 --> 00:19:58,960
uh

503
00:19:58,960 --> 00:20:01,600
is the problem of

504
00:20:01,600 --> 00:20:04,480
duplication removing due duplications so

505
00:20:04,480 --> 00:20:06,720
remember that when an element is found

506
00:20:06,720 --> 00:20:09,520
we're going to put it in both structures

507
00:20:09,520 --> 00:20:10,880
this means that we're going to have the

508
00:20:10,880 --> 00:20:13,120
same keys more than once in the same

509
00:20:13,120 --> 00:20:16,000
match in the same uh

510
00:20:16,000 --> 00:20:17,679
in the same uh

511
00:20:17,679 --> 00:20:20,400
oven

512
00:20:20,400 --> 00:20:24,000
so we need to remove duplications now in

513
00:20:24,000 --> 00:20:26,000
optorama and panorama we didn't have

514
00:20:26,000 --> 00:20:27,840
this problem we never needed to delete

515
00:20:27,840 --> 00:20:30,000
an element whenever we looked for an

516
00:20:30,000 --> 00:20:32,400
element we deleted it right away so we

517
00:20:32,400 --> 00:20:35,120
didn't have two copies of the same

518
00:20:35,120 --> 00:20:36,159
element

519
00:20:36,159 --> 00:20:38,159
somewhere in the structure

520
00:20:38,159 --> 00:20:40,480
now what's wrong with duplications we

521
00:20:40,480 --> 00:20:42,320
know how to remove the duplication it's

522
00:20:42,320 --> 00:20:45,360
a non-primitive in the arm literature

523
00:20:45,360 --> 00:20:48,000
however in the olm literature we can

524
00:20:48,000 --> 00:20:51,360
afford to remove duplications in time

525
00:20:51,360 --> 00:20:54,480
and log in with the recent constructions

526
00:20:54,480 --> 00:20:56,480
we want to push down the rebuild process

527
00:20:56,480 --> 00:20:57,840
for men logan

528
00:20:57,840 --> 00:20:59,280
into all the van

529
00:20:59,280 --> 00:21:01,679
so this means that we must have a

530
00:21:01,679 --> 00:21:04,320
duplication removing the duplication

531
00:21:04,320 --> 00:21:05,360
process

532
00:21:05,360 --> 00:21:07,760
that takes linear time

533
00:21:07,760 --> 00:21:09,120
so we show

534
00:21:09,120 --> 00:21:12,559
how to perform a linear and we show a

535
00:21:12,559 --> 00:21:15,840
linear time algorithm that gets as input

536
00:21:15,840 --> 00:21:18,880
two sets a and b and outputs the union

537
00:21:18,880 --> 00:21:22,320
and we move duplications along the way

538
00:21:22,320 --> 00:21:25,200
and the algorithm is oblivious if a and

539
00:21:25,200 --> 00:21:27,280
b are randomly shuffled

540
00:21:27,280 --> 00:21:29,200
assuming one way function

541
00:21:29,200 --> 00:21:31,679
so we show something that is linear time

542
00:21:31,679 --> 00:21:33,679
assuming that it's

543
00:21:33,679 --> 00:21:36,240
assuming some input assumption

544
00:21:36,240 --> 00:21:38,320
um

545
00:21:38,320 --> 00:21:40,000
and without the input assumption we

546
00:21:40,000 --> 00:21:42,640
still cannot do better than m again

547
00:21:42,640 --> 00:21:44,480
another challenge that we have is

548
00:21:44,480 --> 00:21:46,240
something that i put under the rack so

549
00:21:46,240 --> 00:21:49,520
far i presented here as each hash table

550
00:21:49,520 --> 00:21:51,440
is completely independent

551
00:21:51,440 --> 00:21:53,679
in fact all hash tables

552
00:21:53,679 --> 00:21:56,240
have also a stash and looking for an

553
00:21:56,240 --> 00:21:58,080
element inside the stash is quite

554
00:21:58,080 --> 00:21:59,600
pricely

555
00:21:59,600 --> 00:22:01,600
all recent constructions

556
00:22:01,600 --> 00:22:04,000
also follow what is so called the

557
00:22:04,000 --> 00:22:06,880
combined stash technique

558
00:22:06,880 --> 00:22:09,760
where they take the stashes of all hash

559
00:22:09,760 --> 00:22:11,440
tables and combined

560
00:22:11,440 --> 00:22:13,679
combined it into one

561
00:22:13,679 --> 00:22:16,880
big stash which allows them looking into

562
00:22:16,880 --> 00:22:20,159
the stashes much much faster

563
00:22:20,159 --> 00:22:22,799
however this means that all levels have

564
00:22:22,799 --> 00:22:25,280
something some shared memory they are

565
00:22:25,280 --> 00:22:27,280
not completely independent

566
00:22:27,280 --> 00:22:30,880
and in particular they are not uh

567
00:22:30,880 --> 00:22:33,600
when we come to rebuild and and move

568
00:22:33,600 --> 00:22:35,280
things uh

569
00:22:35,280 --> 00:22:37,039
to rebuild the level

570
00:22:37,039 --> 00:22:39,760
we cannot just lock the shared memory

571
00:22:39,760 --> 00:22:41,919
because other tables have to look into

572
00:22:41,919 --> 00:22:44,400
it at the same time and so on

573
00:22:44,400 --> 00:22:47,840
to solve this issue we use a version of

574
00:22:47,840 --> 00:22:50,240
an oblivious dictionary that supports

575
00:22:50,240 --> 00:22:52,559
lookup of elements with respect to

576
00:22:52,559 --> 00:22:54,480
various auxiliary keys

577
00:22:54,480 --> 00:22:56,559
such as the level they came from and so

578
00:22:56,559 --> 00:23:00,879
on we shout out to bill starch addiction

579
00:23:02,720 --> 00:23:05,120
so to conclude the talk i want to

580
00:23:05,120 --> 00:23:08,559
mention our results and techniques so we

581
00:23:08,559 --> 00:23:10,880
knew we showed a new deal motivation

582
00:23:10,880 --> 00:23:12,720
method for constructions that are based

583
00:23:12,720 --> 00:23:15,520
on the randomness free use technique

584
00:23:15,520 --> 00:23:17,919
uh we move we showed the method for

585
00:23:17,919 --> 00:23:20,320
removing duplications in linear time in

586
00:23:20,320 --> 00:23:22,159
two arrays

587
00:23:22,159 --> 00:23:24,799
we show a new method for handling child

588
00:23:24,799 --> 00:23:26,640
memory

589
00:23:26,640 --> 00:23:28,799
and our main theorem we show that there

590
00:23:28,799 --> 00:23:31,200
exists a computational loan with the

591
00:23:31,200 --> 00:23:32,880
worst case

592
00:23:32,880 --> 00:23:35,120
or the login overhead

593
00:23:35,120 --> 00:23:37,440
thank you very much and i hope that next

594
00:23:37,440 --> 00:23:38,400
day

595
00:23:38,400 --> 00:23:42,039
we'll see you in person

