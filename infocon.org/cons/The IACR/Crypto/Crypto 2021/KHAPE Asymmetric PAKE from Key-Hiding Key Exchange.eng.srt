1
00:00:01,920 --> 00:00:03,040
hello

2
00:00:03,040 --> 00:00:04,960
welcome to a talk about cape an

3
00:00:04,960 --> 00:00:07,359
asymmetric peg protocol from key hiding

4
00:00:07,359 --> 00:00:10,639
authenticated key exchange it's a joint

5
00:00:10,639 --> 00:00:15,559
work with yankee ghoul and hugocraft

6
00:00:17,279 --> 00:00:19,760
i'll start by recording what pack is

7
00:00:19,760 --> 00:00:21,520
bake is the protocol where two parties

8
00:00:21,520 --> 00:00:24,160
contribute passwords and if those

9
00:00:24,160 --> 00:00:26,000
passwords are the same

10
00:00:26,000 --> 00:00:28,960
uh then the two parties compute the same

11
00:00:28,960 --> 00:00:31,359
random session key

12
00:00:31,359 --> 00:00:34,160
otherwise they get independent keys and

13
00:00:34,160 --> 00:00:35,600
this implies

14
00:00:35,600 --> 00:00:38,079
authentication because if the two

15
00:00:38,079 --> 00:00:40,640
passwords differ the key

16
00:00:40,640 --> 00:00:42,559
leaks one party computes leaks nothing

17
00:00:42,559 --> 00:00:46,399
about the the key of the other party

18
00:00:46,399 --> 00:00:49,200
what are the most efficient uh existing

19
00:00:49,200 --> 00:00:50,800
pay constructions

20
00:00:50,800 --> 00:00:52,399
uh

21
00:00:52,399 --> 00:00:54,559
very briefly assuming standard groups

22
00:00:54,559 --> 00:00:56,640
and random oracle model the most

23
00:00:56,640 --> 00:00:58,719
efficient schemes use the password to

24
00:00:58,719 --> 00:01:01,760
blind in a way uh messages of the divi

25
00:01:01,760 --> 00:01:04,720
key exchange protocol and uh

26
00:01:04,720 --> 00:01:08,640
each of these protocol proposal could be

27
00:01:08,640 --> 00:01:10,960
viewed in this way starting from the

28
00:01:10,960 --> 00:01:14,240
encrypted key exchange of eke of beloved

29
00:01:14,240 --> 00:01:15,280
merit

30
00:01:15,280 --> 00:01:16,080
and

31
00:01:16,080 --> 00:01:18,560
uh the overhead these some of these

32
00:01:18,560 --> 00:01:20,240
protocols

33
00:01:20,240 --> 00:01:22,960
create in particular this one

34
00:01:22,960 --> 00:01:24,640
are are very low compared to the

35
00:01:24,640 --> 00:01:28,320
underlying difficulty extent

36
00:01:29,040 --> 00:01:30,720
in a client server setting it's useful

37
00:01:30,720 --> 00:01:33,119
to have an asymmetric version of pike

38
00:01:33,119 --> 00:01:35,280
called apek

39
00:01:35,280 --> 00:01:37,600
where the server stores a hashed

40
00:01:37,600 --> 00:01:39,280
password

41
00:01:39,280 --> 00:01:41,119
not the password itself

42
00:01:41,119 --> 00:01:43,439
and the protocol checks that the

43
00:01:43,439 --> 00:01:45,759
client's password hashes into the server

44
00:01:45,759 --> 00:01:47,600
held value

45
00:01:47,600 --> 00:01:50,240
the advantage of this is that on server

46
00:01:50,240 --> 00:01:51,439
compromise

47
00:01:51,439 --> 00:01:53,439
adversary doesn't leak it doesn't get

48
00:01:53,439 --> 00:01:55,840
the password itself but it's harsh

49
00:01:55,840 --> 00:01:58,880
so if it wants to compute the password

50
00:01:58,880 --> 00:02:00,719
there's a one-way function but it's a

51
00:02:00,719 --> 00:02:02,479
deterministic one so it can compute

52
00:02:02,479 --> 00:02:05,200
forward on any password guest

53
00:02:05,200 --> 00:02:06,719
however

54
00:02:06,719 --> 00:02:08,720
it's called brute force search but if

55
00:02:08,720 --> 00:02:10,959
the entropy of this part was is high

56
00:02:10,959 --> 00:02:14,319
enough then uh this search will uh

57
00:02:14,319 --> 00:02:16,640
then the password will escape uh the

58
00:02:16,640 --> 00:02:18,480
search right the search will

59
00:02:18,480 --> 00:02:21,520
fail to find the password

60
00:02:21,520 --> 00:02:25,040
existing uh apec constructions

61
00:02:25,040 --> 00:02:27,200
um are formed by

62
00:02:27,200 --> 00:02:29,920
uh essentially a pig

63
00:02:29,920 --> 00:02:32,000
uh with

64
00:02:32,000 --> 00:02:34,319
something added and this is either a

65
00:02:34,319 --> 00:02:37,840
password-based encryption or a signature

66
00:02:37,840 --> 00:02:40,000
and the signature is the lower cost

67
00:02:40,000 --> 00:02:41,040
option

68
00:02:41,040 --> 00:02:43,360
uh using general signatures costs half

69
00:02:43,360 --> 00:02:45,840
the key exchange so the overall cost of

70
00:02:45,840 --> 00:02:49,200
such solution is about one and a half of

71
00:02:49,200 --> 00:02:52,000
dp hellmann

72
00:02:52,000 --> 00:02:53,920
it can be strengthened to strong

73
00:02:53,920 --> 00:02:55,680
asymmetric peg

74
00:02:55,680 --> 00:02:59,200
where the hash is randomized

75
00:02:59,200 --> 00:03:00,400
the

76
00:03:00,400 --> 00:03:02,159
point is that

77
00:03:02,159 --> 00:03:04,720
because it's a randomized hash now it

78
00:03:04,720 --> 00:03:07,599
cannot be pre-computed right because

79
00:03:07,599 --> 00:03:09,519
before server compromise adversary

80
00:03:09,519 --> 00:03:12,560
doesn't know this randomization

81
00:03:12,560 --> 00:03:16,959
and the most efficient uh strong apex

82
00:03:16,959 --> 00:03:19,280
is the opaque construction

83
00:03:19,280 --> 00:03:22,159
uh which is a compiler from oblivious

84
00:03:22,159 --> 00:03:24,560
random function and

85
00:03:24,560 --> 00:03:26,720
authenticated key exchange

86
00:03:26,720 --> 00:03:30,000
uh for this i will invite you to to this

87
00:03:30,000 --> 00:03:32,879
talks called papers

88
00:03:32,879 --> 00:03:35,440
uh but for uh authenticated key exchange

89
00:03:35,440 --> 00:03:37,040
we'll talk in a second

90
00:03:37,040 --> 00:03:38,640
the bottom line is that both of these

91
00:03:38,640 --> 00:03:40,879
can be instantiated in this setting at

92
00:03:40,879 --> 00:03:43,599
the cost of key exchange each so this

93
00:03:43,599 --> 00:03:45,760
gives you two key exchange

94
00:03:45,760 --> 00:03:47,680
cost for this strong

95
00:03:47,680 --> 00:03:49,280
as metric peg

96
00:03:49,280 --> 00:03:51,360
now what about this building block

97
00:03:51,360 --> 00:03:55,200
we will need it in this in this work

98
00:03:55,200 --> 00:03:57,519
uh authenticated key exchange refers to

99
00:03:57,519 --> 00:03:59,680
authentication key exchange in a public

100
00:03:59,680 --> 00:04:02,640
key setting so each party has secret and

101
00:04:02,640 --> 00:04:04,640
public keeper

102
00:04:04,640 --> 00:04:07,519
the public keys are assumed universally

103
00:04:07,519 --> 00:04:10,480
known and tied to identities of these of

104
00:04:10,480 --> 00:04:11,920
these parties

105
00:04:11,920 --> 00:04:14,560
and the functionality is that if

106
00:04:14,560 --> 00:04:17,279
you you get the same key even on the if

107
00:04:17,279 --> 00:04:18,720
you supply

108
00:04:18,720 --> 00:04:20,639
the assumed public secret key

109
00:04:20,639 --> 00:04:22,479
corresponding to just one public key and

110
00:04:22,479 --> 00:04:25,440
so does your counterparty

111
00:04:25,440 --> 00:04:28,160
and there are many protocol proposals

112
00:04:28,160 --> 00:04:29,680
you know tls

113
00:04:29,680 --> 00:04:33,280
realizes this this type of

114
00:04:33,280 --> 00:04:35,280
mechanism

115
00:04:35,280 --> 00:04:36,080
and

116
00:04:36,080 --> 00:04:38,639
the most efficient is hmqv

117
00:04:38,639 --> 00:04:39,919
and

118
00:04:39,919 --> 00:04:41,440
somewhat surprisingly it actually gets

119
00:04:41,440 --> 00:04:44,320
the same cost as the dp monkey exchange

120
00:04:44,320 --> 00:04:46,160
uh we'll look at this protocol in a few

121
00:04:46,160 --> 00:04:48,000
slides

122
00:04:48,000 --> 00:04:50,479
because we will use it here

123
00:04:50,479 --> 00:04:51,840
um so

124
00:04:51,840 --> 00:04:54,080
summing up the efficiency landscape is

125
00:04:54,080 --> 00:04:56,960
that authenticated key exchange

126
00:04:56,960 --> 00:04:58,960
as well as symmetric

127
00:04:58,960 --> 00:05:01,440
uh password key exchange can both be

128
00:05:01,440 --> 00:05:03,840
implemented at the cost which is which

129
00:05:03,840 --> 00:05:07,280
matches plain unauthenticated gpr monkey

130
00:05:07,280 --> 00:05:09,280
exchange

131
00:05:09,280 --> 00:05:11,039
excuse me

132
00:05:11,039 --> 00:05:13,840
now this is not so for asymmetric peg

133
00:05:13,840 --> 00:05:16,800
and even less for strong asymmetric peak

134
00:05:16,800 --> 00:05:18,960
so what do we do here

135
00:05:18,960 --> 00:05:21,440
our main contribution is a protocol we

136
00:05:21,440 --> 00:05:22,960
call k

137
00:05:22,960 --> 00:05:25,680
it stands for key hiding authenticated

138
00:05:25,680 --> 00:05:28,240
password key exchange and it's a

139
00:05:28,240 --> 00:05:31,360
asymmetric page

140
00:05:31,440 --> 00:05:34,000
created using a key hiding

141
00:05:34,000 --> 00:05:36,080
authenticator key exchange

142
00:05:36,080 --> 00:05:37,520
and

143
00:05:37,520 --> 00:05:38,560
because

144
00:05:38,560 --> 00:05:39,600
the over

145
00:05:39,600 --> 00:05:41,919
overhead of this construction over the

146
00:05:41,919 --> 00:05:43,280
underlying

147
00:05:43,280 --> 00:05:44,160
uh

148
00:05:44,160 --> 00:05:46,720
key hiding egg is very low

149
00:05:46,720 --> 00:05:48,240
and

150
00:05:48,240 --> 00:05:51,120
hmqv turns out to be a key hiding egg

151
00:05:51,120 --> 00:05:55,120
so basically the apec has the same

152
00:05:55,120 --> 00:05:57,520
efficiency as agent qv

153
00:05:57,520 --> 00:06:01,120
and that in particular places apec in

154
00:06:01,120 --> 00:06:04,720
the same uh now apec cost as asymmetric

155
00:06:04,720 --> 00:06:07,680
pack costs essentially the same as the

156
00:06:07,680 --> 00:06:10,240
symmetric one

157
00:06:10,240 --> 00:06:13,919
in more detail our apec construction

158
00:06:13,919 --> 00:06:16,479
is a black box compiler from key hiding

159
00:06:16,479 --> 00:06:18,560
egg and ideal cipher

160
00:06:18,560 --> 00:06:20,400
now this idea cyber has to work on

161
00:06:20,400 --> 00:06:22,160
groups so if the group is an elliptic

162
00:06:22,160 --> 00:06:23,360
curve

163
00:06:23,360 --> 00:06:24,400
um

164
00:06:24,400 --> 00:06:25,680
you have to work a little bit to

165
00:06:25,680 --> 00:06:27,280
implement it

166
00:06:27,280 --> 00:06:30,240
uh one impossible way to implement it

167
00:06:30,240 --> 00:06:33,199
would be using uh uniform encodings of

168
00:06:33,199 --> 00:06:35,919
electric curve points like alligator 2

169
00:06:35,919 --> 00:06:38,560
or alligator square

170
00:06:38,560 --> 00:06:39,759
another

171
00:06:39,759 --> 00:06:40,880
is

172
00:06:40,880 --> 00:06:42,560
comes from the recent

173
00:06:42,560 --> 00:06:45,039
work by mccoy

174
00:06:45,039 --> 00:06:47,360
roswell conroy

175
00:06:47,360 --> 00:06:50,479
which show uh something we can call weak

176
00:06:50,479 --> 00:06:52,880
idea cipher that can be implemented with

177
00:06:52,880 --> 00:06:55,280
a single for a group

178
00:06:55,280 --> 00:06:57,360
implementable using a single random

179
00:06:57,360 --> 00:06:59,360
oracle hash onto the group

180
00:06:59,360 --> 00:07:02,960
per each cipher operation and um they

181
00:07:02,960 --> 00:07:04,960
showed that this is sufficient for

182
00:07:04,960 --> 00:07:06,880
encrypted key exchange

183
00:07:06,880 --> 00:07:09,840
which originally used ideal cipher

184
00:07:09,840 --> 00:07:11,680
right uh

185
00:07:11,680 --> 00:07:13,440
we believe that it can be also plugged

186
00:07:13,440 --> 00:07:14,960
in here but still have to formally

187
00:07:14,960 --> 00:07:17,840
compare that

188
00:07:18,080 --> 00:07:19,919
so because we

189
00:07:19,919 --> 00:07:22,479
based our construction on this new key

190
00:07:22,479 --> 00:07:24,479
hiding

191
00:07:24,479 --> 00:07:27,199
authenticated key exchange

192
00:07:27,199 --> 00:07:28,560
sub protocol

193
00:07:28,560 --> 00:07:29,680
we

194
00:07:29,680 --> 00:07:30,720
give

195
00:07:30,720 --> 00:07:33,120
defines this notion in a composable way

196
00:07:33,120 --> 00:07:35,120
so in particular we can plug it in our

197
00:07:35,120 --> 00:07:37,199
own construction

198
00:07:37,199 --> 00:07:38,800
and we showed that in random morocco

199
00:07:38,800 --> 00:07:41,199
model it's implement it's realized by

200
00:07:41,199 --> 00:07:43,680
several implicitly authenticated key

201
00:07:43,680 --> 00:07:45,840
exchange protocols out there including

202
00:07:45,840 --> 00:07:50,080
hmqb triple th and scheme

203
00:07:50,080 --> 00:07:52,080
the last one is interesting uh because

204
00:07:52,080 --> 00:07:54,479
it's a black box construction from cam

205
00:07:54,479 --> 00:07:57,520
so it can lead to postponed to my fake

206
00:07:57,520 --> 00:07:59,919
design alternative to those

207
00:07:59,919 --> 00:08:00,800
um

208
00:08:00,800 --> 00:08:01,759
now

209
00:08:01,759 --> 00:08:04,639
taking the two together gives us uh

210
00:08:04,639 --> 00:08:08,240
the most efficient apek uh to date and

211
00:08:08,240 --> 00:08:10,479
it's optimal in terms of computational

212
00:08:10,479 --> 00:08:13,759
cost because uh it has

213
00:08:13,759 --> 00:08:15,440
roughly the same cost as the underlying

214
00:08:15,440 --> 00:08:18,639
of the german key exchange

215
00:08:18,720 --> 00:08:20,720
it comes at the price though it has four

216
00:08:20,720 --> 00:08:21,759
flows

217
00:08:21,759 --> 00:08:24,400
uh three if the server starts

218
00:08:24,400 --> 00:08:26,639
versus three flows in the standard

219
00:08:26,639 --> 00:08:29,599
setting where the client is in initiator

220
00:08:29,599 --> 00:08:30,639
uh

221
00:08:30,639 --> 00:08:34,958
which was the case for prior uh apex

222
00:08:34,958 --> 00:08:37,440
uh now an interesting implication

223
00:08:37,440 --> 00:08:40,000
another interesting implication is that

224
00:08:40,000 --> 00:08:41,919
if you

225
00:08:41,919 --> 00:08:44,240
instantiate use this

226
00:08:44,240 --> 00:08:46,399
now low-cost apex

227
00:08:46,399 --> 00:08:48,080
you can use it to instantiate an

228
00:08:48,080 --> 00:08:49,279
alternative

229
00:08:49,279 --> 00:08:52,000
strong epic construction called opec

230
00:08:52,000 --> 00:08:54,399
prime which was given in the same paper

231
00:08:54,399 --> 00:08:57,360
that introduced opaque

232
00:08:57,360 --> 00:08:58,320
and

233
00:08:58,320 --> 00:09:02,399
because now apec and egg cost the same

234
00:09:02,399 --> 00:09:04,959
so these two constructions are

235
00:09:04,959 --> 00:09:06,640
excuse me have the same

236
00:09:06,640 --> 00:09:09,839
computational efficiency

237
00:09:10,240 --> 00:09:11,279
but

238
00:09:11,279 --> 00:09:14,800
new construction has a funny advantage

239
00:09:14,800 --> 00:09:17,120
namely it offers a graceful security

240
00:09:17,120 --> 00:09:18,560
degradation

241
00:09:18,560 --> 00:09:21,839
from strong apec to just

242
00:09:21,839 --> 00:09:24,880
if this is a protocol breaks now

243
00:09:24,880 --> 00:09:26,800
innocence is going to break

244
00:09:26,800 --> 00:09:28,160
it's a key leak

245
00:09:28,160 --> 00:09:29,920
it's information theoretic for the

246
00:09:29,920 --> 00:09:32,560
client so um

247
00:09:32,560 --> 00:09:33,760
this

248
00:09:33,760 --> 00:09:34,959
means that

249
00:09:34,959 --> 00:09:36,959
this implies this um

250
00:09:36,959 --> 00:09:39,120
graceful security degradation why is it

251
00:09:39,120 --> 00:09:40,399
useful

252
00:09:40,399 --> 00:09:42,399
for example if you outsource

253
00:09:42,399 --> 00:09:44,640
to oblivious prf block

254
00:09:44,640 --> 00:09:45,600
uh

255
00:09:45,600 --> 00:09:47,920
but this outsourcing fails you

256
00:09:47,920 --> 00:09:50,000
uh the worst that that happens is that

257
00:09:50,000 --> 00:09:52,640
you downgrade from this to here

258
00:09:52,640 --> 00:09:53,519
uh

259
00:09:53,519 --> 00:09:56,000
another is that uh perhaps everything is

260
00:09:56,000 --> 00:10:00,000
quantum secure but the opr not so

261
00:10:00,000 --> 00:10:02,839
um and and indeed the

262
00:10:02,839 --> 00:10:05,600
quantum secure opr

263
00:10:05,600 --> 00:10:07,200
is

264
00:10:07,200 --> 00:10:08,959
still not uh

265
00:10:08,959 --> 00:10:12,160
not very efficient

266
00:10:12,560 --> 00:10:13,680
so

267
00:10:13,680 --> 00:10:16,079
it comes at the price first of all uh

268
00:10:16,079 --> 00:10:18,399
also we have one more protocol flow so

269
00:10:18,399 --> 00:10:21,120
this is a four message protocol whereas

270
00:10:21,120 --> 00:10:23,120
opaque is three

271
00:10:23,120 --> 00:10:25,839
and it needs a specific egg

272
00:10:25,839 --> 00:10:28,240
namely key hiding eggs and in particular

273
00:10:28,240 --> 00:10:30,000
you cannot use the sigma

274
00:10:30,000 --> 00:10:32,959
egg from tls which will probably make

275
00:10:32,959 --> 00:10:35,839
integration with tls uh easier for

276
00:10:35,839 --> 00:10:38,480
opaque compared to opaque prime

277
00:10:38,480 --> 00:10:39,920
okay

278
00:10:39,920 --> 00:10:42,399
so that's the that's the contributions

279
00:10:42,399 --> 00:10:44,000
uh in the rest of the talk i'll talk

280
00:10:44,000 --> 00:10:44,800
about

281
00:10:44,800 --> 00:10:48,320
what's this key hiding acres and then uh

282
00:10:48,320 --> 00:10:50,880
once we get that clear uh

283
00:10:50,880 --> 00:10:54,720
how that this compiler works

284
00:10:55,120 --> 00:10:56,000
okay

285
00:10:56,000 --> 00:10:58,560
so here is the key hiding egg

286
00:10:58,560 --> 00:10:59,519
so

287
00:10:59,519 --> 00:11:01,920
it's in the public key setting where uh

288
00:11:01,920 --> 00:11:04,320
but uh everybody has a secret public

289
00:11:04,320 --> 00:11:06,000
keeper

290
00:11:06,000 --> 00:11:08,640
but unlike the standard take notion

291
00:11:08,640 --> 00:11:11,760
uh we modeled inputs in the prime public

292
00:11:11,760 --> 00:11:14,240
key of the presumed counterparty as the

293
00:11:14,240 --> 00:11:17,440
explicit private input of each

294
00:11:17,440 --> 00:11:19,120
of its party participating in the

295
00:11:19,120 --> 00:11:20,399
protocol

296
00:11:20,399 --> 00:11:22,079
so these are not

297
00:11:22,079 --> 00:11:24,399
defined by names

298
00:11:24,399 --> 00:11:25,440
these are

299
00:11:25,440 --> 00:11:28,480
explicit inputs

300
00:11:28,480 --> 00:11:29,520
and um

301
00:11:29,520 --> 00:11:30,800
[Music]

302
00:11:30,800 --> 00:11:32,800
the rest looks the same

303
00:11:32,800 --> 00:11:34,720
and now where is the key hiding property

304
00:11:34,720 --> 00:11:37,839
so notice that the key uh the only

305
00:11:37,839 --> 00:11:40,640
output that this party gets assumed

306
00:11:40,640 --> 00:11:43,519
client this attacker is just a random

307
00:11:43,519 --> 00:11:45,600
key right which is whether it's

308
00:11:45,600 --> 00:11:47,839
independent of k prime or the same

309
00:11:47,839 --> 00:11:50,240
uh this person doesn't even know so

310
00:11:50,240 --> 00:11:52,320
in particular basically everything about

311
00:11:52,320 --> 00:11:54,880
these inputs is hidden by the must be

312
00:11:54,880 --> 00:11:56,800
hidden by the protocol messages which

313
00:11:56,800 --> 00:11:59,440
will realize this notion

314
00:11:59,440 --> 00:12:01,519
um however

315
00:12:01,519 --> 00:12:03,600
uh of course the server computes the key

316
00:12:03,600 --> 00:12:05,040
here and it can

317
00:12:05,040 --> 00:12:06,959
use it so without loss of generality

318
00:12:06,959 --> 00:12:08,720
gives it to the environment which gives

319
00:12:08,720 --> 00:12:10,240
it to the client right so the client

320
00:12:10,240 --> 00:12:11,519
basically can

321
00:12:11,519 --> 00:12:13,680
reveal what the session key server

322
00:12:13,680 --> 00:12:15,920
computes is

323
00:12:15,920 --> 00:12:18,720
and now using it it can test whether

324
00:12:18,720 --> 00:12:22,720
it's a secret key publicly input match

325
00:12:22,720 --> 00:12:26,240
uh the one server uses so in that sense

326
00:12:26,240 --> 00:12:27,839
if

327
00:12:27,839 --> 00:12:29,920
that's the that's the way in which it's

328
00:12:29,920 --> 00:12:31,839
not key hiding so if you have the

329
00:12:31,839 --> 00:12:34,480
corresponding matching

330
00:12:34,480 --> 00:12:37,360
you will test and figure out

331
00:12:37,360 --> 00:12:40,560
that i use the ones that match yours

332
00:12:40,560 --> 00:12:42,240
but if you don't have them

333
00:12:42,240 --> 00:12:44,240
then in particular you don't have the

334
00:12:44,240 --> 00:12:47,040
secret key corresponding to this one you

335
00:12:47,040 --> 00:12:48,880
learn nothing about either of these two

336
00:12:48,880 --> 00:12:50,560
inputs

337
00:12:50,560 --> 00:12:53,600
okay uh however we have no perfect

338
00:12:53,600 --> 00:12:55,760
forward secrecy

339
00:12:55,760 --> 00:12:58,560
okay so in particular

340
00:12:58,560 --> 00:13:00,000
when uh

341
00:13:00,000 --> 00:13:01,440
the server

342
00:13:01,440 --> 00:13:03,040
let's say the client

343
00:13:03,040 --> 00:13:06,240
uh at the time when it when the client

344
00:13:06,240 --> 00:13:08,399
runs this protocol

345
00:13:08,399 --> 00:13:10,000
it really doesn't have to have these

346
00:13:10,000 --> 00:13:11,440
inputs

347
00:13:11,440 --> 00:13:14,320
so it is possible that after the

348
00:13:14,320 --> 00:13:16,399
protocol stops

349
00:13:16,399 --> 00:13:17,920
it

350
00:13:17,920 --> 00:13:20,560
really then uses the inputs and computes

351
00:13:20,560 --> 00:13:21,839
this key

352
00:13:21,839 --> 00:13:23,920
and then compares to the key that the

353
00:13:23,920 --> 00:13:25,279
server gets

354
00:13:25,279 --> 00:13:27,200
and which diversity learned from the

355
00:13:27,200 --> 00:13:28,560
environment

356
00:13:28,560 --> 00:13:29,839
which allows

357
00:13:29,839 --> 00:13:33,200
basically offline testing of any

358
00:13:33,200 --> 00:13:36,480
skc pks pair that aggressive learns in

359
00:13:36,480 --> 00:13:38,000
the future

360
00:13:38,000 --> 00:13:40,320
now for better for a secrecy it is easy

361
00:13:40,320 --> 00:13:42,000
to stop you just introduce key

362
00:13:42,000 --> 00:13:44,800
confirmation message so the client has

363
00:13:44,800 --> 00:13:48,000
to confirm that it learned the key that

364
00:13:48,000 --> 00:13:50,000
matches the server one or otherwise the

365
00:13:50,000 --> 00:13:52,320
server is not going to output this one

366
00:13:52,320 --> 00:13:55,040
with proof that the client knows these

367
00:13:55,040 --> 00:13:56,480
inputs

368
00:13:56,480 --> 00:13:58,639
before this guy

369
00:13:58,639 --> 00:14:01,279
decides to use the key right so it just

370
00:14:01,279 --> 00:14:04,480
stops this whole thing however for

371
00:14:04,480 --> 00:14:06,639
privacy is not so easy

372
00:14:06,639 --> 00:14:07,519
because

373
00:14:07,519 --> 00:14:09,120
the first party let's say it's the

374
00:14:09,120 --> 00:14:10,959
client who leaks

375
00:14:10,959 --> 00:14:12,800
basically sends the key confirmation

376
00:14:12,800 --> 00:14:13,839
message

377
00:14:13,839 --> 00:14:16,800
allows the server side attacker to then

378
00:14:16,800 --> 00:14:19,360
well he cannot if he doesn't have these

379
00:14:19,360 --> 00:14:20,959
matching inputs then he cannot compute

380
00:14:20,959 --> 00:14:23,519
the key and he cannot send his uh

381
00:14:23,519 --> 00:14:25,600
confirmation so the client will abort

382
00:14:25,600 --> 00:14:27,040
however

383
00:14:27,040 --> 00:14:29,839
after if he learns this input he can

384
00:14:29,839 --> 00:14:31,600
still compute the key and test whether

385
00:14:31,600 --> 00:14:33,680
it was equal because it has the key

386
00:14:33,680 --> 00:14:36,800
confirmation message from the client now

387
00:14:36,800 --> 00:14:39,920
one can implement more secure more

388
00:14:39,920 --> 00:14:42,079
secure notion i mean basically a notion

389
00:14:42,079 --> 00:14:44,800
which has perfect for privacy using the

390
00:14:44,800 --> 00:14:46,800
standard secure computation approaches

391
00:14:46,800 --> 00:14:48,320
commit to input

392
00:14:48,320 --> 00:14:50,320
uh uh in particular commit to this

393
00:14:50,320 --> 00:14:52,800
inputs of the protocol execution

394
00:14:52,800 --> 00:14:54,480
um

395
00:14:54,480 --> 00:14:56,880
we don't because we're not interested in

396
00:14:56,880 --> 00:14:58,639
the strongest properties to you can get

397
00:14:58,639 --> 00:15:00,399
for this what we're interested in is to

398
00:15:00,399 --> 00:15:01,360
model

399
00:15:01,360 --> 00:15:04,079
minimal properties necessarily

400
00:15:04,079 --> 00:15:07,600
uh that this compiler goes through

401
00:15:07,600 --> 00:15:08,880
and also

402
00:15:08,880 --> 00:15:10,320
that the properties will actually be

403
00:15:10,320 --> 00:15:14,560
realized by this all least expensive

404
00:15:14,560 --> 00:15:16,639
key agreement protocols

405
00:15:16,639 --> 00:15:18,000
because it's the efficiency of the

406
00:15:18,000 --> 00:15:19,519
resulting

407
00:15:19,519 --> 00:15:22,959
asymmetric peak that we're after

408
00:15:22,959 --> 00:15:24,399
okay

409
00:15:24,399 --> 00:15:26,320
so here's one example of how to realize

410
00:15:26,320 --> 00:15:28,240
this is the triple dp helmond used in

411
00:15:28,240 --> 00:15:31,440
the signal uh application

412
00:15:31,440 --> 00:15:32,560
uh

413
00:15:32,560 --> 00:15:34,480
the setting is like the keys are like in

414
00:15:34,480 --> 00:15:35,600
elgamal

415
00:15:35,600 --> 00:15:37,920
encryption or the german key exchange

416
00:15:37,920 --> 00:15:40,480
and the message is that people send are

417
00:15:40,480 --> 00:15:41,440
just

418
00:15:41,440 --> 00:15:43,759
divi monkey exchange again

419
00:15:43,759 --> 00:15:46,639
note that the messages are independent

420
00:15:46,639 --> 00:15:48,800
of the input so the messages themselves

421
00:15:48,800 --> 00:15:52,000
reveal nothing about these inputs

422
00:15:52,000 --> 00:15:53,839
now how is the key computed it's

423
00:15:53,839 --> 00:15:56,959
computed using a true as an arrow hash

424
00:15:56,959 --> 00:15:58,800
of three separate diffie-hellman

425
00:15:58,800 --> 00:16:01,440
instances where the client always makes

426
00:16:01,440 --> 00:16:02,800
one

427
00:16:02,800 --> 00:16:04,959
contribution and the server makes

428
00:16:04,959 --> 00:16:07,279
another either the ephemeral key for the

429
00:16:07,279 --> 00:16:10,720
client or the long term key and likewise

430
00:16:10,720 --> 00:16:13,199
either a thermal key for the server or a

431
00:16:13,199 --> 00:16:15,199
long term key

432
00:16:15,199 --> 00:16:17,439
and

433
00:16:19,199 --> 00:16:21,199
okay so the protocol messages but note

434
00:16:21,199 --> 00:16:22,880
that the protocol messages don't do not

435
00:16:22,880 --> 00:16:24,160
reveal anything about the long-term

436
00:16:24,160 --> 00:16:26,480
input but they do not commit to

437
00:16:26,480 --> 00:16:28,800
long-term input right so this party

438
00:16:28,800 --> 00:16:30,959
might not know these inputs when they

439
00:16:30,959 --> 00:16:33,839
send a message and when the counterparty

440
00:16:33,839 --> 00:16:35,360
outputs this key

441
00:16:35,360 --> 00:16:37,120
but if they learn the symbols afterwards

442
00:16:37,120 --> 00:16:39,120
they can complete this equation and

443
00:16:39,120 --> 00:16:42,000
learn the key as well

444
00:16:42,000 --> 00:16:44,720
hmqv can be seen as an optimization of

445
00:16:44,720 --> 00:16:48,240
tripoli g helmand everything is the same

446
00:16:48,240 --> 00:16:51,519
except for the key division equation

447
00:16:51,519 --> 00:16:55,519
which uh in a very nice way uh combines

448
00:16:55,519 --> 00:16:58,079
this through three-way or really

449
00:16:58,079 --> 00:17:01,279
four-way matching of ephemeral keys and

450
00:17:01,279 --> 00:17:04,400
permanent keys for for each side

451
00:17:04,400 --> 00:17:06,079
because the difficult contribution on

452
00:17:06,079 --> 00:17:08,240
the client side is a linear combination

453
00:17:08,240 --> 00:17:10,959
of the ephemeral difficult contribution

454
00:17:10,959 --> 00:17:12,799
in the long term

455
00:17:12,799 --> 00:17:15,199
and so it is for the circle where the

456
00:17:15,199 --> 00:17:18,720
linear equation here is a random one uh

457
00:17:18,720 --> 00:17:19,760
with the

458
00:17:19,760 --> 00:17:22,160
random coefficient output by the random

459
00:17:22,160 --> 00:17:23,919
oracle hash

460
00:17:23,919 --> 00:17:25,679
so we showed that this protocol has the

461
00:17:25,679 --> 00:17:27,520
same properties as strictly hermann in

462
00:17:27,520 --> 00:17:29,840
particular risky hiding

463
00:17:29,840 --> 00:17:32,480
but it is advantageous in that its cost

464
00:17:32,480 --> 00:17:35,840
is uh very it's all roughly the same as

465
00:17:35,840 --> 00:17:39,679
the dividend key exchange itself

466
00:17:39,679 --> 00:17:42,640
okay so now how do we get this compiler

467
00:17:42,640 --> 00:17:45,679
using the key hiding uh egg and an ideal

468
00:17:45,679 --> 00:17:48,240
cipher to get asymmetric pack because

469
00:17:48,240 --> 00:17:49,919
it's an asymmetric peg we have to

470
00:17:49,919 --> 00:17:52,480
specify what is this quote unquote hash

471
00:17:52,480 --> 00:17:55,440
password that the server stores for a

472
00:17:55,440 --> 00:17:58,000
given client okay so here is how we

473
00:17:58,000 --> 00:18:01,120
compute we pick two uh public key pairs

474
00:18:01,120 --> 00:18:03,520
one for the client one for the server

475
00:18:03,520 --> 00:18:05,760
and then we encrypt

476
00:18:05,760 --> 00:18:09,360
the ake inputs of the client namely the

477
00:18:09,360 --> 00:18:11,520
secret key of the client and the public

478
00:18:11,520 --> 00:18:13,919
key of the server we together encrypt

479
00:18:13,919 --> 00:18:16,400
that under the client's password and we

480
00:18:16,400 --> 00:18:18,400
call this an envelope

481
00:18:18,400 --> 00:18:22,400
the service file is that envelope

482
00:18:22,400 --> 00:18:25,600
and the credentials it use it needs for

483
00:18:25,600 --> 00:18:27,760
authenticated key exchange so its own

484
00:18:27,760 --> 00:18:30,559
secret key the secret key here

485
00:18:30,559 --> 00:18:33,200
and the public key for the client

486
00:18:33,200 --> 00:18:34,400
now uh

487
00:18:34,400 --> 00:18:37,039
note public key in

488
00:18:37,039 --> 00:18:40,080
this crypto systems is a group element

489
00:18:40,080 --> 00:18:43,600
hence we need ideal cypher on on groups

490
00:18:43,600 --> 00:18:46,320
now how the protocol goes very simple

491
00:18:46,320 --> 00:18:48,799
uh the server sends this envelope to the

492
00:18:48,799 --> 00:18:51,360
clients the client uses her password to

493
00:18:51,360 --> 00:18:53,520
decrypt the envelope and interpret the

494
00:18:53,520 --> 00:18:56,559
outputs as the secret key for herself

495
00:18:56,559 --> 00:18:58,960
and the public key for the

496
00:18:58,960 --> 00:19:00,240
server

497
00:19:00,240 --> 00:19:03,520
and then the two run key hiding egg on

498
00:19:03,520 --> 00:19:06,160
this corresponding imports

499
00:19:06,160 --> 00:19:08,240
now crucially you need a round of key

500
00:19:08,240 --> 00:19:10,320
confirmations

501
00:19:10,320 --> 00:19:12,559
excuse me

502
00:19:12,559 --> 00:19:15,039
and importantly the client has to go

503
00:19:15,039 --> 00:19:16,080
first

504
00:19:16,080 --> 00:19:18,559
and uh these are important for security

505
00:19:18,559 --> 00:19:22,160
as we'll shortly explain but also they

506
00:19:22,160 --> 00:19:24,480
account for this extra protocol round

507
00:19:24,480 --> 00:19:25,919
compared to

508
00:19:25,919 --> 00:19:28,400
alternative apec designs

509
00:19:28,400 --> 00:19:29,919
it's interesting to compare these

510
00:19:29,919 --> 00:19:31,760
compilers with classic encrypted key

511
00:19:31,760 --> 00:19:34,720
exchange of beloved merit both protocols

512
00:19:34,720 --> 00:19:36,559
use ideal cipher

513
00:19:36,559 --> 00:19:40,160
to encrypt uh group elements and compile

514
00:19:40,160 --> 00:19:43,440
some form of key extension to peg but

515
00:19:43,440 --> 00:19:46,720
eke compiles plain key exchange into a

516
00:19:46,720 --> 00:19:49,600
symmetric peg and we compile

517
00:19:49,600 --> 00:19:51,440
authenticated key exchange into

518
00:19:51,440 --> 00:19:53,919
asymmetric bike

519
00:19:53,919 --> 00:19:56,320
and how we do well

520
00:19:56,320 --> 00:19:58,080
encrypted key exchange uses the ideal

521
00:19:58,080 --> 00:20:00,400
cipher to password encrypt every message

522
00:20:00,400 --> 00:20:02,480
of the key exchange

523
00:20:02,480 --> 00:20:05,600
what we do is to ideal cipher encrypt

524
00:20:05,600 --> 00:20:08,880
under the password only the inputs

525
00:20:08,880 --> 00:20:10,480
of the client

526
00:20:10,480 --> 00:20:13,360
in the authenticative key exchange

527
00:20:13,360 --> 00:20:16,159
okay so some similar entirety's and and

528
00:20:16,159 --> 00:20:18,640
some differences but this is funny that

529
00:20:18,640 --> 00:20:21,600
this very classic protocol kind of gets

530
00:20:21,600 --> 00:20:25,200
resurfaced in um in a different

531
00:20:25,200 --> 00:20:26,720
version here

532
00:20:26,720 --> 00:20:28,799
um

533
00:20:28,799 --> 00:20:30,240
so

534
00:20:30,240 --> 00:20:31,039
now

535
00:20:31,039 --> 00:20:33,120
why is it secure so

536
00:20:33,120 --> 00:20:35,520
uh let's

537
00:20:35,520 --> 00:20:37,679
notice that uh basically by the

538
00:20:37,679 --> 00:20:39,200
properties of this the only thing that

539
00:20:39,200 --> 00:20:41,039
the party engaging here learns is the

540
00:20:41,039 --> 00:20:43,200
key and it's a random key regardless of

541
00:20:43,200 --> 00:20:45,760
the input so the real information is in

542
00:20:45,760 --> 00:20:47,919
the envelope and in these key

543
00:20:47,919 --> 00:20:49,760
confirmation messages

544
00:20:49,760 --> 00:20:52,480
so let's look at the envelope first

545
00:20:52,480 --> 00:20:54,880
for a passive attacker

546
00:20:54,880 --> 00:20:58,320
they can decrypt an envelope

547
00:20:58,320 --> 00:21:00,640
under arbitrary passwords and every time

548
00:21:00,640 --> 00:21:02,960
they do so it gives them some random

549
00:21:02,960 --> 00:21:04,480
secret key for the client and random

550
00:21:04,480 --> 00:21:07,039
past publicly for the server

551
00:21:07,039 --> 00:21:09,520
however by the key hiding properties of

552
00:21:09,520 --> 00:21:12,080
egg this pair cannot be correlated with

553
00:21:12,080 --> 00:21:14,559
the inputs of the honest parties

554
00:21:14,559 --> 00:21:17,120
unless through an active attack

555
00:21:17,120 --> 00:21:19,919
so let's look at an active attack

556
00:21:19,919 --> 00:21:21,919
first if the attacker plays the server

557
00:21:21,919 --> 00:21:23,919
wrong so imagine an attacker on this

558
00:21:23,919 --> 00:21:26,000
side what do they do first they have a

559
00:21:26,000 --> 00:21:27,840
choice of the envelope

560
00:21:27,840 --> 00:21:30,960
uh however because it's an ideal cipher

561
00:21:30,960 --> 00:21:33,200
every choice of a cipher text commits to

562
00:21:33,200 --> 00:21:35,520
a single key which is a password in this

563
00:21:35,520 --> 00:21:36,559
case

564
00:21:36,559 --> 00:21:39,200
uh for which the decryption is

565
00:21:39,200 --> 00:21:40,960
non-random so it can be controlled by

566
00:21:40,960 --> 00:21:42,320
the attacker

567
00:21:42,320 --> 00:21:44,320
so in other words a title can encrypt

568
00:21:44,320 --> 00:21:46,240
any secret key for the client in public

569
00:21:46,240 --> 00:21:47,919
key for the server that they want on a

570
00:21:47,919 --> 00:21:49,919
single password but on any other

571
00:21:49,919 --> 00:21:51,760
password it would decrypt into random

572
00:21:51,760 --> 00:21:54,480
keys in particular if it does

573
00:21:54,480 --> 00:21:55,679
uh

574
00:21:55,679 --> 00:21:57,840
the because this key will be random so

575
00:21:57,840 --> 00:21:59,280
the adversary cannot know the

576
00:21:59,280 --> 00:22:01,280
corresponding secret key and therefore

577
00:22:01,280 --> 00:22:03,039
cannot go through this protocol and

578
00:22:03,039 --> 00:22:05,039
authenticate

579
00:22:05,039 --> 00:22:06,640
and basically cannot make anything from

580
00:22:06,640 --> 00:22:10,480
this message and cannot send that one

581
00:22:11,120 --> 00:22:13,360
uh um the on

582
00:22:13,360 --> 00:22:15,039
right um

583
00:22:15,039 --> 00:22:17,679
on the other hand for the password uh

584
00:22:17,679 --> 00:22:19,919
before the single password adversary

585
00:22:19,919 --> 00:22:21,760
does control what these inputs are and

586
00:22:21,760 --> 00:22:23,520
therefore can pick them in such a way

587
00:22:23,520 --> 00:22:26,480
that it knows the corresponding uh

588
00:22:26,480 --> 00:22:28,320
values on the other side

589
00:22:28,320 --> 00:22:30,159
and go through the protocol right but

590
00:22:30,159 --> 00:22:32,559
that's a single password it's an online

591
00:22:32,559 --> 00:22:33,520
choice

592
00:22:33,520 --> 00:22:37,280
so this is the same as ssl page

593
00:22:37,280 --> 00:22:39,440
that does allow you every session you

594
00:22:39,440 --> 00:22:41,520
interact with you can test one password

595
00:22:41,520 --> 00:22:42,880
on it

596
00:22:42,880 --> 00:22:44,960
now what about clients confirmation

597
00:22:44,960 --> 00:22:46,000
message

598
00:22:46,000 --> 00:22:47,840
it is necessary

599
00:22:47,840 --> 00:22:49,679
uh because

600
00:22:49,679 --> 00:22:51,600
um

601
00:22:51,600 --> 00:22:53,600
the adversary training the client

602
00:22:53,600 --> 00:22:55,280
without this message

603
00:22:55,280 --> 00:22:56,720
could later

604
00:22:56,720 --> 00:22:59,200
given the clients is the server's key

605
00:22:59,200 --> 00:23:00,080
test

606
00:23:00,080 --> 00:23:03,520
uh perform this this test offline it can

607
00:23:03,520 --> 00:23:04,640
decrypt

608
00:23:04,640 --> 00:23:06,320
the envelope under different passwords

609
00:23:06,320 --> 00:23:09,120
and get this candidate and for each of

610
00:23:09,120 --> 00:23:11,600
them completes this and test the history

611
00:23:11,600 --> 00:23:14,320
as a server's output right but if it has

612
00:23:14,320 --> 00:23:16,159
the confirmation message if it has to

613
00:23:16,159 --> 00:23:17,760
send it then that has to commit to a

614
00:23:17,760 --> 00:23:19,919
single value here which means a single

615
00:23:19,919 --> 00:23:22,799
value here which means a single password

616
00:23:22,799 --> 00:23:25,840
and again that is a online choice of a

617
00:23:25,840 --> 00:23:27,760
unique password on which that was

618
00:23:27,760 --> 00:23:29,200
replaced here

619
00:23:29,200 --> 00:23:32,159
uh the service key confirmation

620
00:23:32,159 --> 00:23:34,720
uh is is a little more subtle

621
00:23:34,720 --> 00:23:37,440
uh it basically protects uh

622
00:23:37,440 --> 00:23:40,240
against uh without it the protocol would

623
00:23:40,240 --> 00:23:41,840
be insecure

624
00:23:41,840 --> 00:23:45,279
uh against future the past client

625
00:23:45,279 --> 00:23:48,320
sessions which use the key here without

626
00:23:48,320 --> 00:23:50,400
waiting for the key confirmation would

627
00:23:50,400 --> 00:23:52,720
be insecure against future compromises

628
00:23:52,720 --> 00:23:55,279
of the server where the adversary learns

629
00:23:55,279 --> 00:23:58,000
these values and completes this

630
00:23:58,000 --> 00:24:01,120
confirms here and now knows the key for

631
00:24:01,120 --> 00:24:03,440
all prior sessions

632
00:24:03,440 --> 00:24:05,440
okay so but with the key confirmations

633
00:24:05,440 --> 00:24:07,919
this is stopped

634
00:24:07,919 --> 00:24:10,320
and with that i conclude

635
00:24:10,320 --> 00:24:14,080
uh we showed a new apec construction

636
00:24:14,080 --> 00:24:16,080
with optimal efficiency

637
00:24:16,080 --> 00:24:18,960
uh in the process we defined key hiding

638
00:24:18,960 --> 00:24:19,840
aches

639
00:24:19,840 --> 00:24:21,760
and shorts that some protocols realize

640
00:24:21,760 --> 00:24:23,120
it efficiently

641
00:24:23,120 --> 00:24:25,360
and it has these interesting uh

642
00:24:25,360 --> 00:24:28,159
implications for a super strong

643
00:24:28,159 --> 00:24:30,240
asymmetric opaque some follow-up

644
00:24:30,240 --> 00:24:31,679
questions

645
00:24:31,679 --> 00:24:35,279
what about optimal cost and optimal

646
00:24:35,279 --> 00:24:37,120
ground complexity

647
00:24:37,120 --> 00:24:38,000
and

648
00:24:38,000 --> 00:24:39,919
about lattice-based implement

649
00:24:39,919 --> 00:24:41,840
implications of this

650
00:24:41,840 --> 00:24:43,600
and with that

651
00:24:43,600 --> 00:24:44,480
i

652
00:24:44,480 --> 00:24:46,880
conclude and thank everyone listening

653
00:24:46,880 --> 00:24:50,720
and invite you to the

