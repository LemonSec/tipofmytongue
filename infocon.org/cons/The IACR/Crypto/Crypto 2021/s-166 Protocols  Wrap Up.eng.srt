1
00:00:02,639 --> 00:00:05,279
ready to go have a good session

2
00:00:05,279 --> 00:00:08,318
great thank you okay

3
00:00:08,720 --> 00:00:11,040
hello everyone and welcome to the last

4
00:00:11,040 --> 00:00:13,759
session of crypto 2021

5
00:00:13,759 --> 00:00:16,000
today we'll be having five great talks

6
00:00:16,000 --> 00:00:18,160
about protocols

7
00:00:18,160 --> 00:00:21,439
as we're somewhat used to at this point

8
00:00:21,439 --> 00:00:23,359
we'll start the session by giving each

9
00:00:23,359 --> 00:00:25,680
speaker five minutes a piece for their

10
00:00:25,680 --> 00:00:28,080
talks and then afterwards we'll be doing

11
00:00:28,080 --> 00:00:30,160
the q a

12
00:00:30,160 --> 00:00:31,920
and please if you think of questions

13
00:00:31,920 --> 00:00:33,440
during people's thoughts put them in the

14
00:00:33,440 --> 00:00:36,719
zoolop so we can ask them later

15
00:00:36,719 --> 00:00:38,640
and without further ado

16
00:00:38,640 --> 00:00:40,719
the first talk we're going to hear is a

17
00:00:40,719 --> 00:00:42,800
logarithmic lower bound for oblivious

18
00:00:42,800 --> 00:00:45,120
ram for all parameters

19
00:00:45,120 --> 00:00:49,280
which is joined by elaine komoko

20
00:00:49,280 --> 00:00:51,680
komogowski and wake island

21
00:00:51,680 --> 00:00:56,079
without further ado take it away waikai

22
00:00:56,559 --> 00:00:59,440
ah kai you're muted actually

23
00:00:59,440 --> 00:01:02,399
okay thank you for the introduction and

24
00:01:02,399 --> 00:01:04,319
uh further reminder

25
00:01:04,319 --> 00:01:05,840
uh so

26
00:01:05,840 --> 00:01:08,560
this is a joint work with elaine kumar

27
00:01:08,560 --> 00:01:11,200
gossipy from the hebrew university and

28
00:01:11,200 --> 00:01:12,720
the entity

29
00:01:12,720 --> 00:01:14,080
so

30
00:01:14,080 --> 00:01:16,799
the problem of oblivious ram or oram

31
00:01:16,799 --> 00:01:19,200
considers a scenario of outsourcing

32
00:01:19,200 --> 00:01:23,119
storage so we have a client that has

33
00:01:23,119 --> 00:01:26,080
only a small storage so we outsource a

34
00:01:26,080 --> 00:01:29,600
huge data array to the cloud server

35
00:01:29,600 --> 00:01:31,520
because in case the server is

36
00:01:31,520 --> 00:01:34,400
compromised or corrupted we encrypt all

37
00:01:34,400 --> 00:01:37,200
the data contents but the encryption is

38
00:01:37,200 --> 00:01:39,439
not enough because the

39
00:01:39,439 --> 00:01:41,840
can still see the locations of

40
00:01:41,840 --> 00:01:44,560
access the data contents and if these

41
00:01:44,560 --> 00:01:46,640
locations depend on

42
00:01:46,640 --> 00:01:49,759
data contents then the adversary can

43
00:01:49,759 --> 00:01:52,880
learn very sensitive information

44
00:01:52,880 --> 00:01:56,640
to defend against such adversaries we

45
00:01:56,640 --> 00:01:59,360
model this problem using the standard

46
00:01:59,360 --> 00:02:02,479
random access machine the correctness of

47
00:02:02,479 --> 00:02:05,360
the correctness of our is just the

48
00:02:05,360 --> 00:02:06,560
standard

49
00:02:06,560 --> 00:02:10,000
abstract data structure array we can

50
00:02:10,000 --> 00:02:12,879
update or query an array entry by the

51
00:02:12,879 --> 00:02:15,840
index of this entry and we require every

52
00:02:15,840 --> 00:02:18,239
entry must be answered before the next

53
00:02:18,239 --> 00:02:20,879
operation either that's a update or next

54
00:02:20,879 --> 00:02:23,080
query comes in for

55
00:02:23,080 --> 00:02:25,760
implementation there is no way to

56
00:02:25,760 --> 00:02:28,800
there's no space to store this huge data

57
00:02:28,800 --> 00:02:30,959
array on the processor or the client

58
00:02:30,959 --> 00:02:35,040
side so the data structure must store or

59
00:02:35,040 --> 00:02:36,400
implement this

60
00:02:36,400 --> 00:02:39,840
array using physical memory that's the

61
00:02:39,840 --> 00:02:43,840
server or that can be seen as a physical

62
00:02:43,840 --> 00:02:46,480
array of memory sales for security we

63
00:02:46,480 --> 00:02:47,760
consider

64
00:02:47,760 --> 00:02:49,840
an adversary that can see all the

65
00:02:49,840 --> 00:02:52,959
locations of access memory sales but we

66
00:02:52,959 --> 00:02:54,959
don't want the adversary to learn

67
00:02:54,959 --> 00:02:57,680
anything about our top secret that's the

68
00:02:57,680 --> 00:03:00,879
operations performed on our abstract

69
00:03:00,879 --> 00:03:05,280
array so we stay or we require the orem

70
00:03:05,280 --> 00:03:07,920
is secure if

71
00:03:07,920 --> 00:03:10,959
for any operation performed on the top

72
00:03:10,959 --> 00:03:12,560
the obstructed array

73
00:03:12,560 --> 00:03:15,440
the accessor locations

74
00:03:15,440 --> 00:03:19,280
are computationally indistinguishable

75
00:03:19,280 --> 00:03:21,760
back to the data outsourcing scenario

76
00:03:21,760 --> 00:03:24,640
the client and the server may have quite

77
00:03:24,640 --> 00:03:27,920
different units for example we may want

78
00:03:27,920 --> 00:03:30,799
to want we may want to run a 64-bit

79
00:03:30,799 --> 00:03:32,959
program on the client so we want an

80
00:03:32,959 --> 00:03:36,560
array where the entry size is 64-bit for

81
00:03:36,560 --> 00:03:40,000
our 64-bit program but the server speaks

82
00:03:40,000 --> 00:03:43,360
in network packets the page size is

83
00:03:43,360 --> 00:03:46,480
probably 1 megabits so that means the

84
00:03:46,480 --> 00:03:48,400
sale size on the

85
00:03:48,400 --> 00:03:51,280
server is one megabits and

86
00:03:51,280 --> 00:03:55,439
this introduces two extra parameters the

87
00:03:55,439 --> 00:03:57,760
entry size and the sale size

88
00:03:57,760 --> 00:04:00,879
co can be much greater than an entry in

89
00:04:00,879 --> 00:04:04,159
size and this also makes the efficiency

90
00:04:04,159 --> 00:04:05,519
magic

91
00:04:05,519 --> 00:04:07,599
slightly different in terms of

92
00:04:07,599 --> 00:04:09,760
terminology because the cells can be

93
00:04:09,760 --> 00:04:12,879
much greater than an entry so

94
00:04:12,879 --> 00:04:15,840
we

95
00:04:18,478 --> 00:04:21,120
the definition is totally the same as

96
00:04:21,120 --> 00:04:23,040
measured in the number of memory cells

97
00:04:23,040 --> 00:04:25,600
accessed it's just using a different

98
00:04:25,600 --> 00:04:26,720
number

99
00:04:26,720 --> 00:04:28,479
in case of confusion

100
00:04:28,479 --> 00:04:31,440
under this model there are many upper

101
00:04:31,440 --> 00:04:34,000
bound constructions

102
00:04:34,000 --> 00:04:37,040
on one extreme when cells are small we

103
00:04:37,040 --> 00:04:40,720
achieve log n efficiency location io and

104
00:04:40,720 --> 00:04:42,800
on the other extreme when sales are

105
00:04:42,800 --> 00:04:47,120
large we achieve constant io so

106
00:04:47,120 --> 00:04:49,840
the efficiency increases when the sale

107
00:04:49,840 --> 00:04:52,080
size increases

108
00:04:52,080 --> 00:04:54,720
and the main question we want to know in

109
00:04:54,720 --> 00:04:57,040
this world is whether we can

110
00:04:57,040 --> 00:04:59,440
significantly improve the efficiency

111
00:04:59,440 --> 00:05:02,000
when we have larger sales

112
00:05:02,000 --> 00:05:03,440
there are

113
00:05:03,440 --> 00:05:06,400
new techniques and the better results in

114
00:05:06,400 --> 00:05:09,360
our bonds recently and on the lower bank

115
00:05:09,360 --> 00:05:12,639
side there was no impossibility in

116
00:05:12,639 --> 00:05:14,639
particular the lower bound of larsen and

117
00:05:14,639 --> 00:05:16,800
nielsen says that

118
00:05:16,800 --> 00:05:20,240
the efficiency can be improved

119
00:05:20,240 --> 00:05:22,400
linearly in terms of increasing sales

120
00:05:22,400 --> 00:05:24,639
size that means if we have sales size a

121
00:05:24,639 --> 00:05:26,720
million times greater than entry size we

122
00:05:26,720 --> 00:05:28,880
could have a speed up of one million

123
00:05:28,880 --> 00:05:29,759
times

124
00:05:29,759 --> 00:05:32,479
or speaking asymptotically if we

125
00:05:32,479 --> 00:05:34,720
increase sales size by a local vector

126
00:05:34,720 --> 00:05:37,520
then we could improve the efficiency

127
00:05:37,520 --> 00:05:39,840
from lock-end to constant that's also a

128
00:05:39,840 --> 00:05:41,520
huge improvement

129
00:05:41,520 --> 00:05:44,479
however as our title suggested we

130
00:05:44,479 --> 00:05:46,800
improved the lower bank side our

131
00:05:46,800 --> 00:05:48,639
stronger lower bank says that the

132
00:05:48,639 --> 00:05:51,800
efficiency can only be improved

133
00:05:51,800 --> 00:05:55,199
logarithmically in cell size that means

134
00:05:55,199 --> 00:05:57,360
if we increase cell size by a log vector

135
00:05:57,360 --> 00:06:01,199
or any polylog factor then the speed up

136
00:06:01,199 --> 00:06:05,520
can be at most locate log log n

137
00:06:05,520 --> 00:06:08,240
moreover our lower bound matches the

138
00:06:08,240 --> 00:06:11,680
upper bound with sales are large that is

139
00:06:11,680 --> 00:06:14,080
sales is greater than any unto the

140
00:06:14,080 --> 00:06:16,880
epsilon so our lower bound leaves a very

141
00:06:16,880 --> 00:06:19,039
narrow range of parameters that are

142
00:06:19,039 --> 00:06:21,120
still open

143
00:06:21,120 --> 00:06:23,039
technically

144
00:06:23,039 --> 00:06:25,919
our result is based on the previous

145
00:06:25,919 --> 00:06:28,160
result of larson and nielsen they

146
00:06:28,160 --> 00:06:31,600
propose a hard sequence of operations

147
00:06:31,600 --> 00:06:34,560
and our key idea is to make this hard

148
00:06:34,560 --> 00:06:37,199
sequence of operation even harder by

149
00:06:37,199 --> 00:06:40,160
querying random entries in the

150
00:06:40,160 --> 00:06:42,639
obstructed array

151
00:06:42,639 --> 00:06:45,680
this allows us to prove a stronger

152
00:06:45,680 --> 00:06:48,479
technical lemma it says that with high

153
00:06:48,479 --> 00:06:51,759
probability any organ construction must

154
00:06:51,759 --> 00:06:52,800
access

155
00:06:52,800 --> 00:06:56,000
at least one memory cell in order to

156
00:06:56,000 --> 00:06:58,479
answer one query correctly this dilemma

157
00:06:58,479 --> 00:07:01,120
is extremely simple and intuitive but

158
00:07:01,120 --> 00:07:03,599
it's also very useful and

159
00:07:03,599 --> 00:07:06,160
it is actually the most challenging part

160
00:07:06,160 --> 00:07:07,840
in our proof

161
00:07:07,840 --> 00:07:10,880
and that is because we don't want to put

162
00:07:10,880 --> 00:07:14,319
any restriction on the oral construction

163
00:07:14,319 --> 00:07:17,599
to wrap up we improved the lower bank of

164
00:07:17,599 --> 00:07:21,440
orem our lower bank is very robust it is

165
00:07:21,440 --> 00:07:24,000
unconditional and it holds for any

166
00:07:24,000 --> 00:07:25,680
ordering conduction that may use any

167
00:07:25,680 --> 00:07:27,919
cryptographic assumption and our

168
00:07:27,919 --> 00:07:30,639
technique extends to other settings like

169
00:07:30,639 --> 00:07:33,759
multi-server orange there are still open

170
00:07:33,759 --> 00:07:36,800
problems like the bonds first physical

171
00:07:36,800 --> 00:07:40,160
security and i also want to advertise

172
00:07:40,160 --> 00:07:43,440
for our new related results like

173
00:07:43,440 --> 00:07:46,720
oblivious parallel ring thank you for

174
00:07:46,720 --> 00:07:49,680
your attention

175
00:07:51,599 --> 00:07:54,800
okay thanks for that

176
00:07:54,800 --> 00:07:56,319
just as a reminder for anyone if you

177
00:07:56,319 --> 00:07:58,560
have any questions about this talk feel

178
00:07:58,560 --> 00:08:00,560
free to put in the zoo look and i can

179
00:08:00,560 --> 00:08:02,080
read that later when we get to the

180
00:08:02,080 --> 00:08:03,759
questions

181
00:08:03,759 --> 00:08:06,160
and uh

182
00:08:06,160 --> 00:08:08,960
yeah so

183
00:08:10,479 --> 00:08:12,560
without further ado

184
00:08:12,560 --> 00:08:15,440
the next talk again by way guy lin

185
00:08:15,440 --> 00:08:17,840
on oblivious ram with worst-case

186
00:08:17,840 --> 00:08:19,919
logarithmic overhead

187
00:08:19,919 --> 00:08:23,360
with gilad asharov ilan kumar

188
00:08:23,360 --> 00:08:28,080
godski and delaney take it away

189
00:08:28,080 --> 00:08:30,800
thank you for the introduction

190
00:08:30,800 --> 00:08:32,479
joseph so

191
00:08:32,479 --> 00:08:35,440
i'm still talking about our previous ram

192
00:08:35,440 --> 00:08:38,240
but now on the upper bound side

193
00:08:38,240 --> 00:08:39,519
this is a

194
00:08:39,519 --> 00:08:42,080
more efficient construction in terms of

195
00:08:42,080 --> 00:08:45,120
worst case running time so our

196
00:08:45,120 --> 00:08:48,640
long video was prepared by gilad but he

197
00:08:48,640 --> 00:08:51,600
is now observing shabbat so i'm using

198
00:08:51,600 --> 00:08:53,519
his slide here

199
00:08:53,519 --> 00:08:56,880
so the problem of oblivious ram is the

200
00:08:56,880 --> 00:08:59,360
same as in my previous talk

201
00:08:59,360 --> 00:09:02,640
a client uploads his data to a

202
00:09:02,640 --> 00:09:05,200
untrusted server even the data is

203
00:09:05,200 --> 00:09:07,680
encrypted the access pattern or the

204
00:09:07,680 --> 00:09:10,000
locations of this

205
00:09:10,000 --> 00:09:12,800
access the memory can leak sensitive

206
00:09:12,800 --> 00:09:15,920
information here's another example a

207
00:09:15,920 --> 00:09:18,800
medical doctor uploads the genomic data

208
00:09:18,800 --> 00:09:22,399
of his patients to a cloud server even

209
00:09:22,399 --> 00:09:24,959
the data is encrypted the server cannot

210
00:09:24,959 --> 00:09:28,320
see anything about the data the server

211
00:09:28,320 --> 00:09:30,959
can still infer that

212
00:09:30,959 --> 00:09:32,000
when the

213
00:09:32,000 --> 00:09:34,800
doctor always access the

214
00:09:34,800 --> 00:09:37,519
locations related to kidney the server

215
00:09:37,519 --> 00:09:40,640
can still infer the patient has some

216
00:09:40,640 --> 00:09:43,760
kidney related problems instead of a say

217
00:09:43,760 --> 00:09:46,080
heart problem and that is the leakage

218
00:09:46,080 --> 00:09:48,080
you want to prevent

219
00:09:48,080 --> 00:09:50,959
so oblivious runs

220
00:09:50,959 --> 00:09:54,720
can be viewed as a compiler that takes a

221
00:09:54,720 --> 00:09:57,600
program on the client side and uh

222
00:09:57,600 --> 00:10:00,480
converts it into an oblivious program so

223
00:10:00,480 --> 00:10:03,120
the server cannot understand what's

224
00:10:03,120 --> 00:10:05,920
what's the operation performed on the

225
00:10:05,920 --> 00:10:08,719
client side

226
00:10:13,680 --> 00:10:15,920
the security requirement is can be

227
00:10:15,920 --> 00:10:19,440
simulated so that this excess pattern

228
00:10:19,440 --> 00:10:22,560
cannot leak information

229
00:10:22,560 --> 00:10:25,680
i believe these runs do so by

230
00:10:25,680 --> 00:10:28,560
shuffling parts of the memory every now

231
00:10:28,560 --> 00:10:31,279
and then and the moving blocks in the

232
00:10:31,279 --> 00:10:32,880
memory around

233
00:10:32,880 --> 00:10:36,160
so naturally oblivious ramps introduce

234
00:10:36,160 --> 00:10:39,920
some overhead it is shuffling the memory

235
00:10:39,920 --> 00:10:43,120
every now and then is expensive and

236
00:10:43,120 --> 00:10:45,360
every operation on the client side

237
00:10:45,360 --> 00:10:48,000
translates to many accesses

238
00:10:48,000 --> 00:10:50,240
by the oblivious ram

239
00:10:50,240 --> 00:10:53,279
so the problem is how many accesses

240
00:10:53,279 --> 00:10:54,800
we consider

241
00:10:54,800 --> 00:10:57,600
the standard setting where n is the

242
00:10:57,600 --> 00:11:00,959
memory size and the logical and the

243
00:11:00,959 --> 00:11:02,959
physical

244
00:11:02,959 --> 00:11:06,000
memory water size is log n in bits so

245
00:11:06,000 --> 00:11:09,200
that is the setting when cell size

246
00:11:09,200 --> 00:11:13,200
equals to entry size in my previous talk

247
00:11:13,200 --> 00:11:16,399
and the lower bound says that neorm must

248
00:11:16,399 --> 00:11:17,680
introduce

249
00:11:17,680 --> 00:11:20,880
log n overhead and there's a long list

250
00:11:20,880 --> 00:11:23,040
of upper bound constructions

251
00:11:23,040 --> 00:11:24,240
try to

252
00:11:24,240 --> 00:11:28,399
match this lower bound and it is it was

253
00:11:28,399 --> 00:11:30,880
finally matched the last year in world

254
00:11:30,880 --> 00:11:32,959
crypt by the construction

255
00:11:32,959 --> 00:11:34,560
of programmer

256
00:11:34,560 --> 00:11:37,600
but a closer look on these constructions

257
00:11:37,600 --> 00:11:40,240
shows that all these constructions

258
00:11:40,240 --> 00:11:42,399
achieve the complexities in the

259
00:11:42,399 --> 00:11:45,279
amortized sense that means for p

260
00:11:45,279 --> 00:11:48,640
operations this construction run in

261
00:11:48,640 --> 00:11:53,360
time t times log n but some operations

262
00:11:53,360 --> 00:11:55,839
might take much longer in particular all

263
00:11:55,839 --> 00:11:58,560
these constructions has a worst case

264
00:11:58,560 --> 00:11:59,519
time

265
00:11:59,519 --> 00:12:02,639
older end and that's pretty bad

266
00:12:02,639 --> 00:12:05,440
previously there are amortization

267
00:12:05,440 --> 00:12:08,160
methods to improve the worst case

268
00:12:08,160 --> 00:12:10,399
complexity

269
00:12:10,399 --> 00:12:11,519
however

270
00:12:11,519 --> 00:12:12,480
these

271
00:12:12,480 --> 00:12:15,839
demotization methods are not compatible

272
00:12:15,839 --> 00:12:17,040
with

273
00:12:17,040 --> 00:12:19,600
recent constructions panorama or a

274
00:12:19,600 --> 00:12:21,839
programmer this

275
00:12:21,839 --> 00:12:22,800
means

276
00:12:22,800 --> 00:12:25,920
in terms of worst case there is a rather

277
00:12:25,920 --> 00:12:28,480
large gap between the best known orange

278
00:12:28,480 --> 00:12:32,160
construction and the lower bound

279
00:12:32,160 --> 00:12:34,240
to elaborate further

280
00:12:34,240 --> 00:12:38,240
both optorama and the panorama applies a

281
00:12:38,240 --> 00:12:40,800
technique called reusing randomness i

282
00:12:40,800 --> 00:12:43,279
will briefly talk about this technique

283
00:12:43,279 --> 00:12:46,760
in my next slide but the point is the

284
00:12:46,760 --> 00:12:50,320
diameterization method was applied on a

285
00:12:50,320 --> 00:12:53,120
heavy procedure called rebuild and does

286
00:12:53,120 --> 00:12:56,160
the automatization needs to start this

287
00:12:56,160 --> 00:12:59,440
rebuild procedure earlier in advance and

288
00:12:59,440 --> 00:13:02,800
this makes it incompatible incompatible

289
00:13:02,800 --> 00:13:06,800
with randomness reusing and the the main

290
00:13:06,800 --> 00:13:09,680
technical question in our work is

291
00:13:09,680 --> 00:13:12,079
whether we can de-amortize organ

292
00:13:12,079 --> 00:13:15,120
constructions that rely on randomness

293
00:13:15,120 --> 00:13:18,639
reusing like panorama or aquarama

294
00:13:18,639 --> 00:13:20,639
so what goes wrong in

295
00:13:20,639 --> 00:13:23,279
panorama or programma

296
00:13:23,279 --> 00:13:27,600
the idea of randomness reusing is that

297
00:13:27,600 --> 00:13:29,920
when we want to shuffle

298
00:13:29,920 --> 00:13:33,200
elements into a new hash table

299
00:13:33,200 --> 00:13:35,440
for those elements that

300
00:13:35,440 --> 00:13:38,720
are not touched or not accessed they are

301
00:13:38,720 --> 00:13:41,120
still randomly shuffled so we don't need

302
00:13:41,120 --> 00:13:44,000
to reshuffle them in particular in the

303
00:13:44,000 --> 00:13:48,519
construction of all rams

304
00:13:49,040 --> 00:13:52,219
[Music]

305
00:14:01,760 --> 00:14:04,760
hello

306
00:14:17,120 --> 00:14:20,320
but this also moved those elements that

307
00:14:20,320 --> 00:14:23,680
were not touched so we could start the

308
00:14:23,680 --> 00:14:26,639
rebuild earlier in advance that's the

309
00:14:26,639 --> 00:14:28,000
amortization

310
00:14:28,000 --> 00:14:30,639
but for panorama and our programmer the

311
00:14:30,639 --> 00:14:34,320
rebuild process really depends on which

312
00:14:34,320 --> 00:14:37,120
elements that are not touched

313
00:14:37,120 --> 00:14:40,079
so we cannot start to rebuild earlier in

314
00:14:40,079 --> 00:14:41,839
advance

315
00:14:41,839 --> 00:14:45,360
in this work we solved this problem

316
00:14:45,360 --> 00:14:49,440
and constructed an o ram achieving log n

317
00:14:49,440 --> 00:14:51,760
overhead in the worst case

318
00:14:51,760 --> 00:14:54,160
in particular we designed a new

319
00:14:54,160 --> 00:14:56,240
diameterization method that is

320
00:14:56,240 --> 00:14:59,440
compatible with randomness reusing and

321
00:14:59,440 --> 00:15:02,079
we demonitize the the construction of

322
00:15:02,079 --> 00:15:03,760
the rama

323
00:15:03,760 --> 00:15:07,120
so for technical details please watch

324
00:15:07,120 --> 00:15:10,320
our long video and read our paper thank

325
00:15:10,320 --> 00:15:13,839
you for your attention

326
00:15:14,880 --> 00:15:17,360
thank you

327
00:15:25,360 --> 00:15:27,040
okay

328
00:15:27,040 --> 00:15:29,279
thanks for both of those talks

329
00:15:29,279 --> 00:15:32,399
next up we have elaine sheep so if you

330
00:15:32,399 --> 00:15:33,759
could start sharing your screens that

331
00:15:33,759 --> 00:15:35,120
would be great

332
00:15:35,120 --> 00:15:37,279
and elaine will be talking to us about

333
00:15:37,279 --> 00:15:39,519
punctual pseudo-random sets and private

334
00:15:39,519 --> 00:15:42,800
information retrieval with near optimal

335
00:15:42,800 --> 00:15:47,040
online bandwidth and time

336
00:15:47,440 --> 00:15:50,240
and we can see your slide delay so start

337
00:15:50,240 --> 00:15:51,440
when you're ready

338
00:15:51,440 --> 00:15:53,199
okay yeah thanks a lot i'm going to talk

339
00:15:53,199 --> 00:15:54,639
about

340
00:15:54,639 --> 00:15:56,639
some new results on private information

341
00:15:56,639 --> 00:15:58,480
retrieval this is joint work with waka

342
00:15:58,480 --> 00:15:59,759
akio

343
00:15:59,759 --> 00:16:00,880
bala

344
00:16:00,880 --> 00:16:05,040
chandra sankara and bruce max

345
00:16:05,040 --> 00:16:06,880
okay so

346
00:16:06,880 --> 00:16:11,120
the motivation example is private dns

347
00:16:11,120 --> 00:16:14,240
and recently private dns received a lot

348
00:16:14,240 --> 00:16:15,920
of attention from companies like

349
00:16:15,920 --> 00:16:17,440
cloudflare

350
00:16:17,440 --> 00:16:20,160
apple and mozilla like for instance

351
00:16:20,160 --> 00:16:22,639
in the new firefox browser

352
00:16:22,639 --> 00:16:24,639
there's a private dns feature but

353
00:16:24,639 --> 00:16:25,839
they're um

354
00:16:25,839 --> 00:16:29,040
they're basically doing dns over https

355
00:16:29,040 --> 00:16:30,800
so the server can still

356
00:16:30,800 --> 00:16:33,440
see all of your dns queries so it would

357
00:16:33,440 --> 00:16:36,079
be nice if we can you know do this dns

358
00:16:36,079 --> 00:16:38,880
lookup without having to

359
00:16:38,880 --> 00:16:41,519
reveal your private privacy

360
00:16:41,519 --> 00:16:43,199
to anyone

361
00:16:43,199 --> 00:16:45,040
including the server

362
00:16:45,040 --> 00:16:47,519
and more specifically imagine we have a

363
00:16:47,519 --> 00:16:49,759
paranoid cryptographer

364
00:16:49,759 --> 00:16:52,320
hypothetically suppose he likes to play

365
00:16:52,320 --> 00:16:55,040
minecraft but he doesn't want the dns

366
00:16:55,040 --> 00:16:56,720
server to find out

367
00:16:56,720 --> 00:16:58,639
and so you know we want to run some

368
00:16:58,639 --> 00:17:00,399
privacy preserving protocol that

369
00:17:00,399 --> 00:17:02,560
protects the user's privacy

370
00:17:02,560 --> 00:17:05,439
so the database is actually public and

371
00:17:05,439 --> 00:17:08,880
it is the query that we want to protect

372
00:17:08,880 --> 00:17:10,959
more abstractly we can think of the

373
00:17:10,959 --> 00:17:12,480
database as the

374
00:17:12,480 --> 00:17:14,880
you know consisting of n bits

375
00:17:14,880 --> 00:17:18,959
and the user wants and one of these bits

376
00:17:18,959 --> 00:17:20,079
okay

377
00:17:20,079 --> 00:17:22,160
and we want to hide the index x that the

378
00:17:22,160 --> 00:17:25,120
user is looking for

379
00:17:25,199 --> 00:17:27,199
and and in our people we specifically

380
00:17:27,199 --> 00:17:29,440
focused on the two server settings and

381
00:17:29,440 --> 00:17:31,360
there are two non-concluding servers and

382
00:17:31,360 --> 00:17:33,440
essentially we want to we want to say

383
00:17:33,440 --> 00:17:36,160
you know for privacy any individual

384
00:17:36,160 --> 00:17:37,600
service view

385
00:17:37,600 --> 00:17:39,520
is completely let's say independent of

386
00:17:39,520 --> 00:17:42,480
the user's query

387
00:17:43,280 --> 00:17:45,520
and let me quickly give you landscape of

388
00:17:45,520 --> 00:17:47,280
this area and then i'll tell you our

389
00:17:47,280 --> 00:17:49,360
results and i won't have time to go into

390
00:17:49,360 --> 00:17:51,360
the construction

391
00:17:51,360 --> 00:17:53,360
so there's a class of schemes which i

392
00:17:53,360 --> 00:17:56,160
call classical pir and these are schemes

393
00:17:56,160 --> 00:17:58,960
without pre-processing

394
00:17:58,960 --> 00:18:01,840
and there's good news and bad news

395
00:18:01,840 --> 00:18:04,400
the good news is that we know how to

396
00:18:04,400 --> 00:18:07,120
achieve um poly log bandwidth so here

397
00:18:07,120 --> 00:18:09,679
autodem is hiding polylog factors so

398
00:18:09,679 --> 00:18:12,480
auto one is just polylog

399
00:18:12,480 --> 00:18:15,440
okay so that's very nice um on the other

400
00:18:15,440 --> 00:18:16,400
hand

401
00:18:16,400 --> 00:18:18,400
the server competition is very expensive

402
00:18:18,400 --> 00:18:20,480
essentially the server has to look at

403
00:18:20,480 --> 00:18:22,960
the entire database and in fact there's

404
00:18:22,960 --> 00:18:25,440
a lower bound proof by bamo at all

405
00:18:25,440 --> 00:18:27,280
showing that you know this linear server

406
00:18:27,280 --> 00:18:29,760
computation is necessary because

407
00:18:29,760 --> 00:18:31,600
if there's some location the server

408
00:18:31,600 --> 00:18:33,520
doesn't look at then you know you leak

409
00:18:33,520 --> 00:18:35,280
the information that the client is not

410
00:18:35,280 --> 00:18:39,600
interested in that specific position

411
00:18:39,679 --> 00:18:41,440
and because this linear server

412
00:18:41,440 --> 00:18:44,559
computation is too expensive and

413
00:18:44,559 --> 00:18:46,720
there's a new class of schemes which is

414
00:18:46,720 --> 00:18:48,880
very nice called pre-processing pir and

415
00:18:48,880 --> 00:18:50,960
this was first proposed in

416
00:18:50,960 --> 00:18:53,679
an elegant work by bamo at all

417
00:18:53,679 --> 00:18:54,640
and

418
00:18:54,640 --> 00:18:57,120
specifically in our work and

419
00:18:57,120 --> 00:18:59,600
we assume um you know pre-processing in

420
00:18:59,600 --> 00:19:01,679
what i call the subscription model

421
00:19:01,679 --> 00:19:03,679
basically every client can perform a

422
00:19:03,679 --> 00:19:04,880
one-time

423
00:19:04,880 --> 00:19:07,039
pre-processing with the server and

424
00:19:07,039 --> 00:19:09,039
during this one-time pre-processing the

425
00:19:09,039 --> 00:19:12,000
client will download some hints and and

426
00:19:12,000 --> 00:19:13,679
in our case the hint will be square with

427
00:19:13,679 --> 00:19:15,280
ending size

428
00:19:15,280 --> 00:19:16,720
and then after this one time

429
00:19:16,720 --> 00:19:19,200
pre-processing then you know you can

430
00:19:19,200 --> 00:19:21,600
engage in unbounded number of queries

431
00:19:21,600 --> 00:19:24,080
with the server

432
00:19:24,080 --> 00:19:26,559
okay um

433
00:19:26,559 --> 00:19:29,840
so in terms of pre-processing pir prior

434
00:19:29,840 --> 00:19:32,400
to our work the state of the art is a

435
00:19:32,400 --> 00:19:35,120
elegant paper by corgan gibson kogan and

436
00:19:35,120 --> 00:19:37,200
it won the eurocrypt best student paper

437
00:19:37,200 --> 00:19:39,919
award and they basically achieve

438
00:19:39,919 --> 00:19:42,880
square root and server time per query

439
00:19:42,880 --> 00:19:44,640
and square root and bandwidth right so

440
00:19:44,640 --> 00:19:45,360
the

441
00:19:45,360 --> 00:19:48,720
server runtime has been greatly improved

442
00:19:48,720 --> 00:19:50,799
on the other hand they suffer from much

443
00:19:50,799 --> 00:19:52,480
worse bandwidth like you know if you

444
00:19:52,480 --> 00:19:54,080
compare with the classical themes this

445
00:19:54,080 --> 00:19:55,760
is much worse

446
00:19:55,760 --> 00:19:57,440
and they need to assume

447
00:19:57,440 --> 00:19:59,440
one-way function

448
00:19:59,440 --> 00:20:01,120
to get this result and they also need to

449
00:20:01,120 --> 00:20:02,640
assume square root and client-side

450
00:20:02,640 --> 00:20:05,039
storage and you know we also assume the

451
00:20:05,039 --> 00:20:07,200
same amount of client-side

452
00:20:07,200 --> 00:20:08,559
storage

453
00:20:08,559 --> 00:20:12,080
so okay now the question we ask is given

454
00:20:12,080 --> 00:20:13,919
this landscape can we

455
00:20:13,919 --> 00:20:16,159
achieve the best of both worlds

456
00:20:16,159 --> 00:20:17,840
so by the way i want to mention that in

457
00:20:17,840 --> 00:20:19,520
the current gifts and cooking paper then

458
00:20:19,520 --> 00:20:21,840
they also devote part of the paper to a

459
00:20:21,840 --> 00:20:23,600
different setting which is like one shot

460
00:20:23,600 --> 00:20:25,280
scheme that means after the

461
00:20:25,280 --> 00:20:26,880
pre-processing you only have to support

462
00:20:26,880 --> 00:20:28,240
one query

463
00:20:28,240 --> 00:20:30,400
and they can have better asymptotics for

464
00:20:30,400 --> 00:20:32,320
that setting but you know in

465
00:20:32,320 --> 00:20:34,000
almost all conceivable practical

466
00:20:34,000 --> 00:20:35,679
applications we always want the ability

467
00:20:35,679 --> 00:20:40,159
to support unbounded number of queries

468
00:20:40,159 --> 00:20:42,000
so we ask can we achieve the best of

469
00:20:42,000 --> 00:20:43,440
both worlds

470
00:20:43,440 --> 00:20:44,559
and

471
00:20:44,559 --> 00:20:48,000
we give a positive answer essentially

472
00:20:48,000 --> 00:20:49,679
and

473
00:20:49,679 --> 00:20:51,360
to get this result we need to assume the

474
00:20:51,360 --> 00:20:53,440
hardness of lwe

475
00:20:53,440 --> 00:20:55,919
and in particular our construction

476
00:20:55,919 --> 00:20:57,360
relies on

477
00:20:57,360 --> 00:20:59,520
a cryptographic primitive called a

478
00:20:59,520 --> 00:21:01,600
privately punctuable pseudo-random

479
00:21:01,600 --> 00:21:02,640
function

480
00:21:02,640 --> 00:21:04,799
and the only known instantiation of this

481
00:21:04,799 --> 00:21:08,320
primitive is from lattices

482
00:21:08,559 --> 00:21:11,120
okay so before i end i just i don't have

483
00:21:11,120 --> 00:21:12,720
time to talk about the scheme but i just

484
00:21:12,720 --> 00:21:14,720
want to

485
00:21:14,720 --> 00:21:16,559
tell you about this exciting question

486
00:21:16,559 --> 00:21:19,520
right so essentially for more than 30

487
00:21:19,520 --> 00:21:21,120
years we've always

488
00:21:21,120 --> 00:21:24,000
looked for like a practical pir scheme

489
00:21:24,000 --> 00:21:26,320
but we are still not there yet

490
00:21:26,320 --> 00:21:28,480
so these classical pir schemes they're

491
00:21:28,480 --> 00:21:31,360
just prohibitive in practice because you

492
00:21:31,360 --> 00:21:33,039
know asymptotically linear server

493
00:21:33,039 --> 00:21:34,559
competition

494
00:21:34,559 --> 00:21:36,240
won't scale very well when you have

495
00:21:36,240 --> 00:21:38,400
large databases like in private dns the

496
00:21:38,400 --> 00:21:40,640
database is easily several hundred

497
00:21:40,640 --> 00:21:42,840
gigabytes

498
00:21:42,840 --> 00:21:45,120
and you know in this sense these

499
00:21:45,120 --> 00:21:47,120
pre-processing schemes are more

500
00:21:47,120 --> 00:21:48,640
promising

501
00:21:48,640 --> 00:21:50,960
and our scheme is actually conceptually

502
00:21:50,960 --> 00:21:53,600
rather simple and if you think about you

503
00:21:53,600 --> 00:21:55,120
know if you want to implement something

504
00:21:55,120 --> 00:21:57,280
like our steam right now the main

505
00:21:57,280 --> 00:21:59,280
performance bottleneck is this crypto

506
00:21:59,280 --> 00:22:01,840
primitive which is this privately

507
00:22:01,840 --> 00:22:03,600
punctuable prf and this is the only

508
00:22:03,600 --> 00:22:05,200
crypto we need we don't need any other

509
00:22:05,200 --> 00:22:07,280
crypto everything else is like basically

510
00:22:07,280 --> 00:22:08,640
statistical

511
00:22:08,640 --> 00:22:10,080
um

512
00:22:10,080 --> 00:22:11,840
so in some sense if you you know for

513
00:22:11,840 --> 00:22:14,000
instance if you could get

514
00:22:14,000 --> 00:22:16,640
a practical privately punctual pif scene

515
00:22:16,640 --> 00:22:18,799
then perhaps that's one

516
00:22:18,799 --> 00:22:21,200
possible path you know towards

517
00:22:21,200 --> 00:22:23,280
tackling this open question

518
00:22:23,280 --> 00:22:25,280
and i'm personally very excited about

519
00:22:25,280 --> 00:22:28,159
this and you know if you want to discuss

520
00:22:28,159 --> 00:22:31,200
this i'm very happy to

521
00:22:31,200 --> 00:22:32,640
please look at our paper for more

522
00:22:32,640 --> 00:22:36,240
details thank you very much

523
00:22:39,679 --> 00:22:42,960
great thank you elaine

524
00:22:44,320 --> 00:22:46,480
and once again if people have questions

525
00:22:46,480 --> 00:22:47,760
you can

526
00:22:47,760 --> 00:22:49,600
feel free to put them on zoolip and

527
00:22:49,600 --> 00:22:51,280
we'll get to them later but for now

528
00:22:51,280 --> 00:22:53,919
we'll be moving on to our next talk

529
00:22:53,919 --> 00:22:57,520
which will be given by georgine triple

530
00:22:57,520 --> 00:23:00,080
about authenticated key extremes and

531
00:23:00,080 --> 00:23:02,320
signatures with tight security in the

532
00:23:02,320 --> 00:23:05,039
standard model

533
00:23:05,039 --> 00:23:06,960
okay

534
00:23:06,960 --> 00:23:08,400
yes we can hear you

535
00:23:08,400 --> 00:23:10,640
okay perfect um thanks for the

536
00:23:10,640 --> 00:23:13,440
introduction and hi to everyone so let

537
00:23:13,440 --> 00:23:15,760
me directly start with a general

538
00:23:15,760 --> 00:23:18,960
overview of authenticated key exchange

539
00:23:18,960 --> 00:23:21,919
we consider two users alice and bob they

540
00:23:21,919 --> 00:23:23,919
exchange some messages and in the end

541
00:23:23,919 --> 00:23:25,760
they will both compute a shared session

542
00:23:25,760 --> 00:23:28,159
key which can then be used to encrypt

543
00:23:28,159 --> 00:23:30,080
further traffic

544
00:23:30,080 --> 00:23:32,320
when looking at the security of an

545
00:23:32,320 --> 00:23:34,480
ake protocol we also consider an

546
00:23:34,480 --> 00:23:36,880
adversary eve and we put eve in between

547
00:23:36,880 --> 00:23:38,240
the interaction

548
00:23:38,240 --> 00:23:40,720
that means eve controls the message flow

549
00:23:40,720 --> 00:23:44,080
she can drop modify or inject messages

550
00:23:44,080 --> 00:23:46,240
we also give eve access to some secret

551
00:23:46,240 --> 00:23:48,720
information she can for example corrupt

552
00:23:48,720 --> 00:23:50,960
the long term keys of users reveal

553
00:23:50,960 --> 00:23:54,159
secret state information or session keys

554
00:23:54,159 --> 00:23:56,559
and for this we define two security

555
00:23:56,559 --> 00:23:59,840
goals the first one is authenticity and

556
00:23:59,840 --> 00:24:02,240
the second is key and distinguishability

557
00:24:02,240 --> 00:24:04,159
which essentially says that the real

558
00:24:04,159 --> 00:24:07,039
session key is indistinguishable from a

559
00:24:07,039 --> 00:24:09,840
uniformly random key

560
00:24:09,840 --> 00:24:11,919
which brings me to some background on

561
00:24:11,919 --> 00:24:13,760
provable security

562
00:24:13,760 --> 00:24:15,760
we define security as a game between a

563
00:24:15,760 --> 00:24:17,760
challenger and an adversary

564
00:24:17,760 --> 00:24:18,640
and

565
00:24:18,640 --> 00:24:20,960
we prove security by contradiction using

566
00:24:20,960 --> 00:24:22,960
a security reduction

567
00:24:22,960 --> 00:24:24,480
that is we assume there exists an

568
00:24:24,480 --> 00:24:26,960
adversary a against our scheme

569
00:24:26,960 --> 00:24:29,840
in this case the ake protocol and we use

570
00:24:29,840 --> 00:24:32,159
a to build an adversary b against a

571
00:24:32,159 --> 00:24:34,320
computationally hard problem

572
00:24:34,320 --> 00:24:36,880
and we focused on tightness so

573
00:24:36,880 --> 00:24:38,480
let me define this

574
00:24:38,480 --> 00:24:41,279
we call a security reduction tight if a

575
00:24:41,279 --> 00:24:42,640
and b have

576
00:24:42,640 --> 00:24:44,400
about the same advantage and running

577
00:24:44,400 --> 00:24:46,720
time and what i mean with about the same

578
00:24:46,720 --> 00:24:48,559
is that they only differ in a constant

579
00:24:48,559 --> 00:24:49,679
factor

580
00:24:49,679 --> 00:24:52,000
and for many ake proofs this is not the

581
00:24:52,000 --> 00:24:54,320
case as we are not looking at two users

582
00:24:54,320 --> 00:24:55,279
and

583
00:24:55,279 --> 00:24:57,360
one session key but in the game we have

584
00:24:57,360 --> 00:25:00,640
many users and each of them may have

585
00:25:00,640 --> 00:25:03,600
many sessions and all of these can be

586
00:25:03,600 --> 00:25:05,600
test sessions

587
00:25:05,600 --> 00:25:07,520
and why this is interesting is because

588
00:25:07,520 --> 00:25:09,440
it tells us how to choose system

589
00:25:09,440 --> 00:25:12,480
parameters in fact only a tight proof

590
00:25:12,480 --> 00:25:14,240
allows us to implement the protocol

591
00:25:14,240 --> 00:25:16,159
theoretically sound

592
00:25:16,159 --> 00:25:18,320
without the need to increase system

593
00:25:18,320 --> 00:25:20,640
parameters

594
00:25:20,640 --> 00:25:23,120
okay and in order to put our work into

595
00:25:23,120 --> 00:25:24,559
context i want to give a short

596
00:25:24,559 --> 00:25:26,880
comparison to previous work

597
00:25:26,880 --> 00:25:28,480
the details of this table are not too

598
00:25:28,480 --> 00:25:30,080
important i just want to highlight some

599
00:25:30,080 --> 00:25:31,919
properties here

600
00:25:31,919 --> 00:25:33,760
the first tightly secure ake was

601
00:25:33,760 --> 00:25:37,840
proposed by badad al at tcc 2015 they

602
00:25:37,840 --> 00:25:39,919
also focused on the standard model and

603
00:25:39,919 --> 00:25:42,000
they proposed a very efficient signature

604
00:25:42,000 --> 00:25:43,039
scheme

605
00:25:43,039 --> 00:25:45,279
but unfortunately we found a flaw in

606
00:25:45,279 --> 00:25:46,400
their proof

607
00:25:46,400 --> 00:25:48,080
so the protocol

608
00:25:48,080 --> 00:25:49,760
actually needs to rely on another

609
00:25:49,760 --> 00:25:52,000
inefficient scheme and one of our

610
00:25:52,000 --> 00:25:55,039
contributions here is that we modify and

611
00:25:55,039 --> 00:25:56,880
fix the signature scheme to make the

612
00:25:56,880 --> 00:25:58,320
proof work

613
00:25:58,320 --> 00:26:02,159
um going uh further at crypto 2018 and

614
00:26:02,159 --> 00:26:04,720
19 there were two works on ake in the

615
00:26:04,720 --> 00:26:07,520
random oracle model um justine and jaga

616
00:26:07,520 --> 00:26:09,520
first proposed a quite efficient variant

617
00:26:09,520 --> 00:26:11,840
of the scientific helmet protocol

618
00:26:11,840 --> 00:26:13,840
and one year later congordond i'll

619
00:26:13,840 --> 00:26:15,520
provide very practical and efficient

620
00:26:15,520 --> 00:26:17,279
diffie-hellman protocols without

621
00:26:17,279 --> 00:26:18,480
signatures

622
00:26:18,480 --> 00:26:20,240
but their proof is also not completely

623
00:26:20,240 --> 00:26:22,640
tight

624
00:26:22,799 --> 00:26:25,360
and following this the work of you at i

625
00:26:25,360 --> 00:26:27,840
presented at asiacrypt um last year

626
00:26:27,840 --> 00:26:29,600
focused on tight ake in the standard

627
00:26:29,600 --> 00:26:32,559
model again um they use a slightly

628
00:26:32,559 --> 00:26:34,159
different security model for test

629
00:26:34,159 --> 00:26:37,120
queries and our work now revisits their

630
00:26:37,120 --> 00:26:39,679
construction in a more realistic model

631
00:26:39,679 --> 00:26:43,440
and also with our new signature scheme

632
00:26:43,440 --> 00:26:45,840
the work by yaga at islet eurogroup this

633
00:26:45,840 --> 00:26:46,720
year

634
00:26:46,720 --> 00:26:49,520
was the first to then consider tight ake

635
00:26:49,520 --> 00:26:52,080
with ephemeral stage reviews but their

636
00:26:52,080 --> 00:26:54,080
techniques inherently relied on the

637
00:26:54,080 --> 00:26:56,240
random oracle model

638
00:26:56,240 --> 00:26:58,240
which brings us to our work

639
00:26:58,240 --> 00:27:00,320
which combines everything together so we

640
00:27:00,320 --> 00:27:02,640
have a proof in the standard model the

641
00:27:02,640 --> 00:27:04,880
protocol is still quite efficient and we

642
00:27:04,880 --> 00:27:07,360
also allow state reveals

643
00:27:07,360 --> 00:27:09,600
so let me give a short overview of our

644
00:27:09,600 --> 00:27:12,000
results we follow the quite standard

645
00:27:12,000 --> 00:27:14,640
approach of a generic construction from

646
00:27:14,640 --> 00:27:17,360
an ephemeral camp to derive the session

647
00:27:17,360 --> 00:27:19,279
key and a signature scheme for

648
00:27:19,279 --> 00:27:21,039
authentication

649
00:27:21,039 --> 00:27:24,000
we extend this protocol by an additional

650
00:27:24,000 --> 00:27:25,600
round with the nonce

651
00:27:25,600 --> 00:27:27,919
and this nonce helps us to relax the

652
00:27:27,919 --> 00:27:30,159
security notion for the cam to

653
00:27:30,159 --> 00:27:33,520
multi-user single challenge cca security

654
00:27:33,520 --> 00:27:35,039
and previous work

655
00:27:35,039 --> 00:27:38,080
needed multi-challenge security here

656
00:27:38,080 --> 00:27:40,640
which is harder to achieve

657
00:27:40,640 --> 00:27:42,640
for the signature scheme we also need

658
00:27:42,640 --> 00:27:44,799
multi-user security but this time with

659
00:27:44,799 --> 00:27:46,159
corruptions

660
00:27:46,159 --> 00:27:48,000
and those components together already

661
00:27:48,000 --> 00:27:50,799
use an ake scheme with authenticity and

662
00:27:50,799 --> 00:27:53,039
key and distinguishability

663
00:27:53,039 --> 00:27:56,000
um but now we strengthen the security of

664
00:27:56,000 --> 00:27:57,039
the

665
00:27:57,039 --> 00:27:59,440
security of the cam again and we also

666
00:27:59,440 --> 00:28:01,760
require corruptions and some special

667
00:28:01,760 --> 00:28:02,960
property

668
00:28:02,960 --> 00:28:05,279
and also we add a symmetric encryption

669
00:28:05,279 --> 00:28:06,320
scheme

670
00:28:06,320 --> 00:28:09,200
with some standard cpa security

671
00:28:09,200 --> 00:28:12,159
and then we can also prove security

672
00:28:12,159 --> 00:28:14,799
against state reveals

673
00:28:14,799 --> 00:28:17,440
to summarize um the chem is one of the

674
00:28:17,440 --> 00:28:19,440
main building blocks to construct our

675
00:28:19,440 --> 00:28:21,840
new efficient and tight ike protocol in

676
00:28:21,840 --> 00:28:23,440
the standard model

677
00:28:23,440 --> 00:28:25,520
we can build it from hash proof systems

678
00:28:25,520 --> 00:28:27,520
for example under the matrix dep hermann

679
00:28:27,520 --> 00:28:28,960
assumption

680
00:28:28,960 --> 00:28:31,200
our new signature scheme is the first

681
00:28:31,200 --> 00:28:33,360
that supports corruptions while still

682
00:28:33,360 --> 00:28:35,440
being efficient and we can also

683
00:28:35,440 --> 00:28:37,039
instantiate it under the matrix

684
00:28:37,039 --> 00:28:39,279
diffie-hellman assumption in pairing

685
00:28:39,279 --> 00:28:40,399
groups

686
00:28:40,399 --> 00:28:41,840
and finally

687
00:28:41,840 --> 00:28:44,159
we achieve security in a stronger model

688
00:28:44,159 --> 00:28:47,360
additionally considering state reveals

689
00:28:47,360 --> 00:28:49,840
for me for more details please have a

690
00:28:49,840 --> 00:28:52,000
look at the longer video or our paypal

691
00:28:52,000 --> 00:28:54,559
eprint thank you for listening

692
00:28:54,559 --> 00:28:57,799
that's it

693
00:28:59,520 --> 00:29:02,799
thank you doreen great talk

694
00:29:02,799 --> 00:29:05,279
and with that we've come to the final

695
00:29:05,279 --> 00:29:07,600
talk of this year's crypto

696
00:29:07,600 --> 00:29:10,720
which will be given by stanislaus rocky

697
00:29:10,720 --> 00:29:12,960
who will be talking about their paper

698
00:29:12,960 --> 00:29:15,440
tape asymmetric

699
00:29:15,440 --> 00:29:19,760
pig from key hiding key exchange

700
00:29:22,880 --> 00:29:24,320
oh hello hello

701
00:29:24,320 --> 00:29:25,600
can you hear me

702
00:29:25,600 --> 00:29:27,039
yes

703
00:29:27,039 --> 00:29:28,240
uh thank you

704
00:29:28,240 --> 00:29:31,039
uh welcome everyone um i guess i have an

705
00:29:31,039 --> 00:29:33,840
honor to have a last uh talk of the of

706
00:29:33,840 --> 00:29:35,120
of crypto

707
00:29:35,120 --> 00:29:35,440
um

708
00:29:35,440 --> 00:29:37,520
[Music]

709
00:29:37,520 --> 00:29:39,760
this is a joint work with yankee go and

710
00:29:39,760 --> 00:29:42,320
hugo kravchek and i'll talk about an

711
00:29:42,320 --> 00:29:45,360
asymmetric opaque protocol

712
00:29:45,360 --> 00:29:48,158
that we designed

713
00:29:48,320 --> 00:29:49,919
so

714
00:29:49,919 --> 00:29:51,520
here is a

715
00:29:51,520 --> 00:29:55,840
quick reminder what a peak is it's

716
00:29:55,919 --> 00:29:57,600
stands for password authentication

717
00:29:57,600 --> 00:30:00,480
authenticated key exchange and it's uh

718
00:30:00,480 --> 00:30:02,000
authentication and the symmetric

719
00:30:02,000 --> 00:30:04,159
password settings so people contribute

720
00:30:04,159 --> 00:30:06,480
the two parties contribute passwords

721
00:30:06,480 --> 00:30:08,960
functionality checks if they are equal

722
00:30:08,960 --> 00:30:10,720
if they're equally gives them the same

723
00:30:10,720 --> 00:30:11,520
key

724
00:30:11,520 --> 00:30:13,360
random key

725
00:30:13,360 --> 00:30:15,360
and otherwise it gives them independent

726
00:30:15,360 --> 00:30:17,039
keys

727
00:30:17,039 --> 00:30:19,279
so this authentication because

728
00:30:19,279 --> 00:30:21,919
if you put a wrong password you don't

729
00:30:21,919 --> 00:30:24,000
get any information about

730
00:30:24,000 --> 00:30:25,520
your counterparty

731
00:30:25,520 --> 00:30:26,799
and now

732
00:30:26,799 --> 00:30:28,480
what are the

733
00:30:28,480 --> 00:30:32,799
the best uh protocols uh

734
00:30:32,799 --> 00:30:36,640
okay sorry uh

735
00:30:36,640 --> 00:30:38,000
here are the

736
00:30:38,000 --> 00:30:39,919
most efficient protocols in the prime

737
00:30:39,919 --> 00:30:43,840
order group and random oracle setting

738
00:30:44,080 --> 00:30:45,440
um

739
00:30:45,440 --> 00:30:47,919
they all work uh by blinding the

740
00:30:47,919 --> 00:30:50,480
password but blinding the difficulty key

741
00:30:50,480 --> 00:30:52,960
exchange messages in some way

742
00:30:52,960 --> 00:30:54,320
uh

743
00:30:54,320 --> 00:30:55,919
using the password

744
00:30:55,919 --> 00:30:57,679
and that starts with the encrypted key

745
00:30:57,679 --> 00:31:02,559
exchange of uh beloved and merit and

746
00:31:02,559 --> 00:31:05,279
especially this last analysis by mccoy

747
00:31:05,279 --> 00:31:08,159
uh rasulullah conroy shows that this is

748
00:31:08,159 --> 00:31:11,200
a really uh practical uh so the overhead

749
00:31:11,200 --> 00:31:12,159
of the

750
00:31:12,159 --> 00:31:13,440
eke

751
00:31:13,440 --> 00:31:15,279
uh even if you

752
00:31:15,279 --> 00:31:17,840
implement it over elliptic curve groups

753
00:31:17,840 --> 00:31:20,000
is very close to the underlying

754
00:31:20,000 --> 00:31:23,279
determinity exchange

755
00:31:23,519 --> 00:31:24,720
now

756
00:31:24,720 --> 00:31:28,080
our setting is that of asymmetric peg so

757
00:31:28,080 --> 00:31:30,000
it's a client server setting which

758
00:31:30,000 --> 00:31:31,679
differs in that

759
00:31:31,679 --> 00:31:33,600
the server party

760
00:31:33,600 --> 00:31:34,880
god bless you

761
00:31:34,880 --> 00:31:36,960
has uh

762
00:31:36,960 --> 00:31:39,600
has a hash of the password rather than a

763
00:31:39,600 --> 00:31:41,760
pass password itself

764
00:31:41,760 --> 00:31:42,880
and

765
00:31:42,880 --> 00:31:45,440
the functionality checks if the client's

766
00:31:45,440 --> 00:31:47,039
password hashes

767
00:31:47,039 --> 00:31:49,600
to the value that the server has

768
00:31:49,600 --> 00:31:51,840
and uh what's the point the point is

769
00:31:51,840 --> 00:31:54,799
that if somebody corrupts the server

770
00:31:54,799 --> 00:31:57,279
compromises the server and learns server

771
00:31:57,279 --> 00:31:59,600
state long-term information right which

772
00:31:59,600 --> 00:32:02,399
is this hash they can not invert the

773
00:32:02,399 --> 00:32:04,159
one-way function but it's a

774
00:32:04,159 --> 00:32:06,080
deterministic function so they can

775
00:32:06,080 --> 00:32:07,919
compute forward on different password

776
00:32:07,919 --> 00:32:10,720
candidates and watch for collisions

777
00:32:10,720 --> 00:32:12,399
however if there is enough entropy in

778
00:32:12,399 --> 00:32:14,399
this password just brute force search

779
00:32:14,399 --> 00:32:18,640
work fail so so that's the advantage and

780
00:32:18,640 --> 00:32:21,360
uh the best designs in this

781
00:32:21,360 --> 00:32:22,320
setting

782
00:32:22,320 --> 00:32:24,960
uh basically run pake and then add to it

783
00:32:24,960 --> 00:32:27,600
either password-based encryption or

784
00:32:27,600 --> 00:32:30,159
signature in more or less explicit way

785
00:32:30,159 --> 00:32:33,440
and effectively the best designs which

786
00:32:33,440 --> 00:32:36,159
are here and so this stuff

787
00:32:36,159 --> 00:32:39,120
is like a cost of key exchange

788
00:32:39,120 --> 00:32:40,799
but

789
00:32:40,799 --> 00:32:44,480
half more uh because like basically uh

790
00:32:44,480 --> 00:32:46,960
there is one fixed uh base and one fla

791
00:32:46,960 --> 00:32:50,559
variable based exponentiation on top

792
00:32:50,559 --> 00:32:51,519
um

793
00:32:51,519 --> 00:32:53,760
you can strengthen this and

794
00:32:53,760 --> 00:32:56,799
here is the strong

795
00:32:56,799 --> 00:32:58,399
asymmetric fake

796
00:32:58,399 --> 00:33:01,279
the hash function is randomized

797
00:33:01,279 --> 00:33:03,120
through a salt value that is held on the

798
00:33:03,120 --> 00:33:04,640
server

799
00:33:04,640 --> 00:33:06,480
and the point is that now you cannot

800
00:33:06,480 --> 00:33:08,880
pre-compute the brute force attack

801
00:33:08,880 --> 00:33:11,840
so the most efficient design seems uh

802
00:33:11,840 --> 00:33:14,320
currently the opaque protocol

803
00:33:14,320 --> 00:33:16,720
uh which is compiled from these building

804
00:33:16,720 --> 00:33:21,519
blocks and it costs two key exchange

805
00:33:21,519 --> 00:33:22,399
okay

806
00:33:22,399 --> 00:33:23,760
so

807
00:33:23,760 --> 00:33:27,120
this is the efficiency landscape uh

808
00:33:27,120 --> 00:33:29,440
symmetric peak can be done in the cost

809
00:33:29,440 --> 00:33:31,200
of the key exchange

810
00:33:31,200 --> 00:33:34,799
uh asymmetric no and strong asymmetric

811
00:33:34,799 --> 00:33:36,080
even less

812
00:33:36,080 --> 00:33:38,559
and interestingly authenticated key

813
00:33:38,559 --> 00:33:40,320
exchange the kind that was discussed in

814
00:33:40,320 --> 00:33:42,480
the last talk where the authentication

815
00:33:42,480 --> 00:33:44,480
is based on public keys

816
00:33:44,480 --> 00:33:46,880
can also be done in the uh like like at

817
00:33:46,880 --> 00:33:49,600
the cost of the exchange essentially

818
00:33:49,600 --> 00:33:51,039
so what we do

819
00:33:51,039 --> 00:33:53,600
is that we give a new construction for

820
00:33:53,600 --> 00:33:55,360
asymmetric pack

821
00:33:55,360 --> 00:33:56,559
that is

822
00:33:56,559 --> 00:33:58,799
a small overhead or something we call

823
00:33:58,799 --> 00:34:02,159
key hiding or key private authenticated

824
00:34:02,159 --> 00:34:03,360
key exchange

825
00:34:03,360 --> 00:34:07,200
and because hmqv the same as the this

826
00:34:07,200 --> 00:34:10,480
most efficient ake protocol

827
00:34:10,480 --> 00:34:12,000
is key hiding

828
00:34:12,000 --> 00:34:12,879
uh

829
00:34:12,879 --> 00:34:14,000
you know

830
00:34:14,000 --> 00:34:16,480
he is in what's called implicitly

831
00:34:16,480 --> 00:34:18,639
authenticated key exchange and key

832
00:34:18,639 --> 00:34:21,520
hiding is a stronger property

833
00:34:21,520 --> 00:34:23,520
then this design

834
00:34:23,520 --> 00:34:26,399
gives us an asymmetric peg that is now

835
00:34:26,399 --> 00:34:28,800
at a very comparable cost to the best

836
00:34:28,800 --> 00:34:31,280
symmetric pace so it turns out that we

837
00:34:31,280 --> 00:34:35,199
don't pay a price for asymmetric take

838
00:34:35,199 --> 00:34:37,520
now

839
00:34:37,839 --> 00:34:41,119
here is the protocol

840
00:34:41,119 --> 00:34:43,119
so

841
00:34:43,119 --> 00:34:44,000
the

842
00:34:44,000 --> 00:34:46,239
client and server create

843
00:34:46,239 --> 00:34:48,239
public private pairs

844
00:34:48,239 --> 00:34:50,399
and the hash of the password quote

845
00:34:50,399 --> 00:34:53,918
unquote so this is the server state is

846
00:34:53,918 --> 00:34:56,560
the public key for the client

847
00:34:56,560 --> 00:34:58,560
secret key for the server and an

848
00:34:58,560 --> 00:35:00,560
envelope which is an ideal cyber

849
00:35:00,560 --> 00:35:04,240
encryption of the client's

850
00:35:04,240 --> 00:35:06,000
uh credentials under the client's

851
00:35:06,000 --> 00:35:08,640
password uh password so the cl

852
00:35:08,640 --> 00:35:10,240
the server sends this envelope the

853
00:35:10,240 --> 00:35:11,760
client's decrypts

854
00:35:11,760 --> 00:35:14,320
and gets the keys which then they run

855
00:35:14,320 --> 00:35:17,359
the key hiding ache on it

856
00:35:17,359 --> 00:35:18,640
and then there is a round of key

857
00:35:18,640 --> 00:35:20,320
confirmation

858
00:35:20,320 --> 00:35:22,960
so it's a very simple design and it's

859
00:35:22,960 --> 00:35:26,000
secure if this thing here is

860
00:35:26,000 --> 00:35:27,599
is a uc

861
00:35:27,599 --> 00:35:30,480
key exchange and its key hiding

862
00:35:30,480 --> 00:35:34,400
which we formalize in in this paper

863
00:35:34,400 --> 00:35:36,640
but just compare to the very classic

864
00:35:36,640 --> 00:35:39,440
result of encrypted key exchange of

865
00:35:39,440 --> 00:35:41,280
beloved merit i mean this is the paper

866
00:35:41,280 --> 00:35:43,440
that started

867
00:35:43,440 --> 00:35:45,440
work on password authenticated key

868
00:35:45,440 --> 00:35:46,960
exchange

869
00:35:46,960 --> 00:35:49,599
and it was a very neat beautiful

870
00:35:49,599 --> 00:35:52,079
compiler from key exchange

871
00:35:52,079 --> 00:35:53,920
to symmetric

872
00:35:53,920 --> 00:35:56,960
password exchange by how did it work

873
00:35:56,960 --> 00:35:58,880
every key exchange message was password

874
00:35:58,880 --> 00:36:02,720
encrypted under ideal cyber encryption

875
00:36:02,720 --> 00:36:06,000
uh that was analyzed later by uh belarus

876
00:36:06,000 --> 00:36:08,880
but uh that was the thing and what we do

877
00:36:08,880 --> 00:36:10,800
is that we compile from authenticated

878
00:36:10,800 --> 00:36:13,599
key exchange to an asymmetric page using

879
00:36:13,599 --> 00:36:15,440
a sort of a similar trick but on a

880
00:36:15,440 --> 00:36:18,720
different level we encrypt inputs

881
00:36:18,720 --> 00:36:21,040
to authenticate the key strength inputs

882
00:36:21,040 --> 00:36:24,079
of the client and leave the key exchange

883
00:36:24,079 --> 00:36:25,839
itself alone

884
00:36:25,839 --> 00:36:28,640
okay and now you know i'm out of time

885
00:36:28,640 --> 00:36:31,040
so very briefly if you instantiate with

886
00:36:31,040 --> 00:36:32,480
hmqd

887
00:36:32,480 --> 00:36:36,079
um the protocol looks like this so it's

888
00:36:36,079 --> 00:36:38,880
very very simple and uh the cost of it

889
00:36:38,880 --> 00:36:41,119
is uh uh the helm and key exchange

890
00:36:41,119 --> 00:36:42,640
essentially

891
00:36:42,640 --> 00:36:45,680
and um and that said um

892
00:36:45,680 --> 00:36:48,800
it's uh we just works

893
00:36:48,800 --> 00:36:50,800
because we use ideal cycle on groups we

894
00:36:50,800 --> 00:36:53,680
need uh we we need ideal site on groups

895
00:36:53,680 --> 00:36:54,960
so

896
00:36:54,960 --> 00:36:58,079
this is an exciting work uh that gives

897
00:36:58,079 --> 00:37:00,240
like probably the best implementation of

898
00:37:00,240 --> 00:37:03,359
uh of an ideal cypher of those not full

899
00:37:03,359 --> 00:37:07,040
ideal cypher uh but it's good enough

900
00:37:07,040 --> 00:37:10,079
for this kind of stuff and um

901
00:37:10,079 --> 00:37:11,040
and it

902
00:37:11,040 --> 00:37:13,280
also gives rise to an interesting twist

903
00:37:13,280 --> 00:37:16,079
a variant of uh opaque

904
00:37:16,079 --> 00:37:18,720
uh so you will have to see the full talk

905
00:37:18,720 --> 00:37:20,240
and of course the paper

906
00:37:20,240 --> 00:37:23,680
for this i also put slides uh online if

907
00:37:23,680 --> 00:37:26,160
you if anyone wants to compare the

908
00:37:26,160 --> 00:37:30,000
opaque design to this new strong apex

909
00:37:30,000 --> 00:37:31,440
that comes out of

910
00:37:31,440 --> 00:37:33,599
this paper because we put the two side

911
00:37:33,599 --> 00:37:36,240
by side and and compare them for anyone

912
00:37:36,240 --> 00:37:38,880
who is interested uh and open questions

913
00:37:38,880 --> 00:37:41,920
i would think oh we have one extra flow

914
00:37:41,920 --> 00:37:44,240
compared to other protocols so optimal

915
00:37:44,240 --> 00:37:46,079
cost and optimal flow would be nice to

916
00:37:46,079 --> 00:37:47,280
get

917
00:37:47,280 --> 00:37:48,240
and

918
00:37:48,240 --> 00:37:50,560
uh and implications for lattice-based

919
00:37:50,560 --> 00:37:53,119
cryptosystems uh you know how would you

920
00:37:53,119 --> 00:37:55,040
get instantiated from lattices some of

921
00:37:55,040 --> 00:37:59,200
this is easy and some a little uh not so

922
00:37:59,200 --> 00:38:02,359
thank you

923
00:38:04,079 --> 00:38:05,040
okay

924
00:38:05,040 --> 00:38:07,280
thank you for that talk says thought

925
00:38:07,280 --> 00:38:09,440
and uh i guess we can give a nice

926
00:38:09,440 --> 00:38:11,760
virtual applause to everyone who gave a

927
00:38:11,760 --> 00:38:16,119
talk in that session to thank them

928
00:38:20,160 --> 00:38:22,400
just as a reminder if you have questions

929
00:38:22,400 --> 00:38:24,320
for our speakers

930
00:38:24,320 --> 00:38:25,280
here

931
00:38:25,280 --> 00:38:27,839
please share them so we can ask them and

932
00:38:27,839 --> 00:38:30,240
i'll start off with the question that we

933
00:38:30,240 --> 00:38:31,760
had for elaine

934
00:38:31,760 --> 00:38:33,680
on the zooloop

935
00:38:33,680 --> 00:38:35,520
adjacent thing

936
00:38:35,520 --> 00:38:37,599
as can we hope to improve the square

937
00:38:37,599 --> 00:38:40,560
root and online server time complexity

938
00:38:40,560 --> 00:38:41,839
any further

939
00:38:41,839 --> 00:38:44,000
or is there any known lower bound for

940
00:38:44,000 --> 00:38:45,599
server-side complexity in the

941
00:38:45,599 --> 00:38:47,760
pre-processing model

942
00:38:47,760 --> 00:38:49,440
that's a great question actually i

943
00:38:49,440 --> 00:38:51,440
should have mentioned it in the talk

944
00:38:51,440 --> 00:38:52,240
and

945
00:38:52,240 --> 00:38:54,400
basically there's an elegant lower bound

946
00:38:54,400 --> 00:38:57,200
proven by corrigan gibson kogan and

947
00:38:57,200 --> 00:38:59,599
under client square root and client-side

948
00:38:59,599 --> 00:39:00,640
storage

949
00:39:00,640 --> 00:39:03,440
the server computation is almost optimal

950
00:39:03,440 --> 00:39:06,880
up to poly log factors

951
00:39:06,880 --> 00:39:09,119
and in fact we can like in the paper we

952
00:39:09,119 --> 00:39:11,040
also describe a way to

953
00:39:11,040 --> 00:39:13,520
there's a knob you can tune between the

954
00:39:13,520 --> 00:39:15,119
client side storage and the server

955
00:39:15,119 --> 00:39:17,359
compute computation time and we are

956
00:39:17,359 --> 00:39:19,359
basically nearly optimal for every

957
00:39:19,359 --> 00:39:21,119
parameter like

958
00:39:21,119 --> 00:39:23,839
yeah you can basically

959
00:39:23,839 --> 00:39:25,520
tune the parameters

960
00:39:25,520 --> 00:39:29,480
and to get different trade-offs

961
00:39:30,640 --> 00:39:33,200
okay thank you

962
00:39:33,200 --> 00:39:35,760
i guess i'll next go to a question for

963
00:39:35,760 --> 00:39:37,920
stanislav from watson

964
00:39:37,920 --> 00:39:39,040
lad

965
00:39:39,040 --> 00:39:40,720
they ask are there

966
00:39:40,720 --> 00:39:43,119
ideal cyphers for the lattice setting

967
00:39:43,119 --> 00:39:45,359
seems like for something like ntru one

968
00:39:45,359 --> 00:39:47,599
could enumerate sign permutations and

969
00:39:47,599 --> 00:39:50,960
use that transformation

970
00:39:51,200 --> 00:39:52,160
um

971
00:39:52,160 --> 00:39:52,960
so

972
00:39:52,960 --> 00:39:54,880
i don't know anything specifically

973
00:39:54,880 --> 00:39:58,640
designed for for for for lattices but um

974
00:39:58,640 --> 00:40:02,079
the the one approach to ideal cyphers is

975
00:40:02,079 --> 00:40:03,119
that

976
00:40:03,119 --> 00:40:06,000
as long as the domain like for example

977
00:40:06,000 --> 00:40:08,000
uh take a

978
00:40:08,000 --> 00:40:09,599
particular lattice cam and it's

979
00:40:09,599 --> 00:40:10,960
ciphertext

980
00:40:10,960 --> 00:40:13,440
as long as the ciphertext can be encoded

981
00:40:13,440 --> 00:40:17,119
as random bit strings of certain length

982
00:40:17,119 --> 00:40:19,760
then you are in essence done

983
00:40:19,760 --> 00:40:22,800
except that these bit strings are long

984
00:40:22,800 --> 00:40:25,119
and

985
00:40:25,359 --> 00:40:27,599
you know a standard cipher doesn't take

986
00:40:27,599 --> 00:40:29,359
uh you know

987
00:40:29,359 --> 00:40:30,720
2 000 bits

988
00:40:30,720 --> 00:40:33,119
of plaintext or 10 000 bits of plaintext

989
00:40:33,119 --> 00:40:36,079
right so you still need to go from

990
00:40:36,079 --> 00:40:38,720
standard ciphers that we you know let's

991
00:40:38,720 --> 00:40:41,440
say that you believe aes is an ideal

992
00:40:41,440 --> 00:40:44,880
cipher how do you go from 128 bits to

993
00:40:44,880 --> 00:40:46,720
much larger domain but there are

994
00:40:46,720 --> 00:40:48,720
existing constructions

995
00:40:48,720 --> 00:40:50,400
for this

996
00:40:50,400 --> 00:40:53,520
that you might want to improve but they

997
00:40:53,520 --> 00:40:55,359
there are out there

998
00:40:55,359 --> 00:40:56,240
uh

999
00:40:56,240 --> 00:40:58,800
but you know the problems appear like if

1000
00:40:58,800 --> 00:41:01,680
your domain space is not random or it's

1001
00:41:01,680 --> 00:41:05,200
difficult to encode it as random

1002
00:41:05,200 --> 00:41:06,800
so that's the whole thing about elliptic

1003
00:41:06,800 --> 00:41:09,359
curves elliptic curve you know in a

1004
00:41:09,359 --> 00:41:11,119
standard way a point on an electric

1005
00:41:11,119 --> 00:41:12,960
curve can be distinguished from a random

1006
00:41:12,960 --> 00:41:14,640
string because it satisfies an elliptic

1007
00:41:14,640 --> 00:41:16,480
curve equation

1008
00:41:16,480 --> 00:41:18,240
so it's a non-trivial question how do

1009
00:41:18,240 --> 00:41:20,319
you encode a random this elliptic curve

1010
00:41:20,319 --> 00:41:22,720
point as a random bit string that cannot

1011
00:41:22,720 --> 00:41:24,240
be distinguished

1012
00:41:24,240 --> 00:41:26,560
you know from a uniform random bit

1013
00:41:26,560 --> 00:41:28,880
string right and for lattices i think

1014
00:41:28,880 --> 00:41:30,560
it's actually easier

1015
00:41:30,560 --> 00:41:33,520
uh or at least for many lattice

1016
00:41:33,520 --> 00:41:35,280
cams

1017
00:41:35,280 --> 00:41:38,800
and the only thing is that they're long

1018
00:41:43,200 --> 00:41:46,160
okay thank you for that

1019
00:41:46,160 --> 00:41:49,200
and i guess next we have a question from

1020
00:41:49,200 --> 00:41:51,599
waikai for germany

1021
00:41:51,599 --> 00:41:52,720
repo

1022
00:41:52,720 --> 00:41:54,240
asking if you could elaborate a little

1023
00:41:54,240 --> 00:41:56,560
bit on the new tight signature scheme

1024
00:41:56,560 --> 00:41:59,359
you introduced in your paper

1025
00:41:59,359 --> 00:42:00,800
uh yes sure

1026
00:42:00,800 --> 00:42:01,520
so

1027
00:42:01,520 --> 00:42:04,240
our construction basically follows um a

1028
00:42:04,240 --> 00:42:06,160
generic transformation from a tightly

1029
00:42:06,160 --> 00:42:08,880
secure mac to a signature scheme um this

1030
00:42:08,880 --> 00:42:10,800
was first shown

1031
00:42:10,800 --> 00:42:13,040
for the single user setting i think by

1032
00:42:13,040 --> 00:42:15,599
blazikiltz and pan

1033
00:42:15,599 --> 00:42:17,760
and the scheme by bada then they

1034
00:42:17,760 --> 00:42:20,000
extended it to the multi-user setting so

1035
00:42:20,000 --> 00:42:24,000
they have a multi-user secure mac and

1036
00:42:24,000 --> 00:42:26,160
construct a multi-user signal secure

1037
00:42:26,160 --> 00:42:28,319
signature scheme

1038
00:42:28,319 --> 00:42:29,200
but

1039
00:42:29,200 --> 00:42:31,599
actually we can show that um they cannot

1040
00:42:31,599 --> 00:42:33,839
support corrupt corruptions

1041
00:42:33,839 --> 00:42:36,079
um the main problem here is that we want

1042
00:42:36,079 --> 00:42:38,400
to replace the mag tag which is part of

1043
00:42:38,400 --> 00:42:42,079
the signature um by random but if we

1044
00:42:42,079 --> 00:42:43,920
uh output the secret key to the

1045
00:42:43,920 --> 00:42:47,119
adversary then this mac tag

1046
00:42:47,119 --> 00:42:49,119
is uniquely defined

1047
00:42:49,119 --> 00:42:50,079
and

1048
00:42:50,079 --> 00:42:51,680
we fixed this

1049
00:42:51,680 --> 00:42:54,240
by extending techniques that were quite

1050
00:42:54,240 --> 00:42:56,400
recently used to

1051
00:42:56,400 --> 00:42:57,680
construct

1052
00:42:57,680 --> 00:43:00,000
tightly secure hiv

1053
00:43:00,000 --> 00:43:03,040
um what we essentially do is we increase

1054
00:43:03,040 --> 00:43:05,040
the size of the matrix which is in the

1055
00:43:05,040 --> 00:43:06,720
public parameter

1056
00:43:06,720 --> 00:43:07,680
um

1057
00:43:07,680 --> 00:43:09,680
and before that the the

1058
00:43:09,680 --> 00:43:11,839
the kernel was zero and now we we have a

1059
00:43:11,839 --> 00:43:14,400
non-zero kernel and thus we can

1060
00:43:14,400 --> 00:43:16,800
somehow hide the the information

1061
00:43:16,800 --> 00:43:19,040
in there and replace the mag tag by

1062
00:43:19,040 --> 00:43:21,520
random

1063
00:43:21,520 --> 00:43:25,040
uh does it answer your question

1064
00:43:25,040 --> 00:43:27,839
okay perfect

1065
00:43:28,319 --> 00:43:30,400
thank you connectorine

1066
00:43:30,400 --> 00:43:32,640
um i guess i have a question i want to

1067
00:43:32,640 --> 00:43:34,560
point at way thai

1068
00:43:34,560 --> 00:43:36,960
um the i believe is the first paper you

1069
00:43:36,960 --> 00:43:38,880
presented

1070
00:43:38,880 --> 00:43:40,800
was giving this level bound for kind of

1071
00:43:40,800 --> 00:43:43,119
different parameters for the

1072
00:43:43,119 --> 00:43:45,440
cell size of the

1073
00:43:45,440 --> 00:43:47,760
storage versus the o-ram

1074
00:43:47,760 --> 00:43:50,160
could you say something about

1075
00:43:50,160 --> 00:43:52,400
kind of the

1076
00:43:52,400 --> 00:43:54,720
the application of this to practice of

1077
00:43:54,720 --> 00:43:56,720
what sort of cell size

1078
00:43:56,720 --> 00:44:00,640
ratio we expect in practice maybe

1079
00:44:01,760 --> 00:44:03,440
uh yes

1080
00:44:03,440 --> 00:44:05,599
so that's a good question

1081
00:44:05,599 --> 00:44:08,400
um in the beginning of this project

1082
00:44:08,400 --> 00:44:09,119
we

1083
00:44:09,119 --> 00:44:10,960
hoped to

1084
00:44:10,960 --> 00:44:13,760
improve the efficiency by increasing

1085
00:44:13,760 --> 00:44:16,760
sales size say in a server client

1086
00:44:16,760 --> 00:44:18,800
scenario the

1087
00:44:18,800 --> 00:44:21,839
sales size can indeed be parameterized

1088
00:44:21,839 --> 00:44:24,960
from cell client from server client

1089
00:44:24,960 --> 00:44:27,839
protocols right we can prompt salaries

1090
00:44:27,839 --> 00:44:31,440
the sale size or the packet sized

1091
00:44:31,440 --> 00:44:35,040
network transmitted but

1092
00:44:35,040 --> 00:44:39,599
we ended up with lower bond and uh

1093
00:44:39,599 --> 00:44:41,920
in terms of application

1094
00:44:41,920 --> 00:44:43,280
there is

1095
00:44:43,280 --> 00:44:47,119
not much probe to improve because

1096
00:44:47,119 --> 00:44:50,160
uh the lower bank says if we increase

1097
00:44:50,160 --> 00:44:51,280
your size

1098
00:44:51,280 --> 00:44:53,280
the efficiency only increase

1099
00:44:53,280 --> 00:44:56,160
logarithmically that means you transmit

1100
00:44:56,160 --> 00:44:58,319
a lot of bits

1101
00:44:58,319 --> 00:45:02,079
in exchange of reducing slight number of

1102
00:45:02,079 --> 00:45:03,839
excesses and

1103
00:45:03,839 --> 00:45:06,400
that is probably

1104
00:45:06,400 --> 00:45:09,520
not very efficient to trade off

1105
00:45:09,520 --> 00:45:12,960
the set answer the question

1106
00:45:12,960 --> 00:45:16,240
yeah sure thank you for that

1107
00:45:16,240 --> 00:45:18,800
um i guess going back to a question i

1108
00:45:18,800 --> 00:45:21,839
had missed on zulu earlier

1109
00:45:21,839 --> 00:45:23,200
um

1110
00:45:23,200 --> 00:45:24,240
jasper

1111
00:45:24,240 --> 00:45:26,000
singh had asked a question for elaine

1112
00:45:26,000 --> 00:45:27,920
about for

1113
00:45:27,920 --> 00:45:30,240
an encoded database setting

1114
00:45:30,240 --> 00:45:32,079
where the server can store pre-processed

1115
00:45:32,079 --> 00:45:34,240
data as well can we get a more optimal

1116
00:45:34,240 --> 00:45:34,990
construction

1117
00:45:34,990 --> 00:45:37,839
[Music]

1118
00:45:37,839 --> 00:45:38,960
and so

1119
00:45:38,960 --> 00:45:41,520
there's a paper by female ishai and

1120
00:45:41,520 --> 00:45:42,560
malki

1121
00:45:42,560 --> 00:45:43,680
and there

1122
00:45:43,680 --> 00:45:45,599
you know they consider schemes with a

1123
00:45:45,599 --> 00:45:47,599
global preprocessing this is not per

1124
00:45:47,599 --> 00:45:49,920
client so basically the server

1125
00:45:49,920 --> 00:45:52,640
will encode the database into poly and

1126
00:45:52,640 --> 00:45:54,160
number of bits

1127
00:45:54,160 --> 00:45:56,319
and then with this they show you can get

1128
00:45:56,319 --> 00:45:59,200
sub-linear server computation

1129
00:45:59,200 --> 00:46:01,680
and i i guess like at this moment i

1130
00:46:01,680 --> 00:46:03,440
don't have any idea how to make their

1131
00:46:03,440 --> 00:46:05,280
scheme practical

1132
00:46:05,280 --> 00:46:07,839
um but that's certainly you know

1133
00:46:07,839 --> 00:46:10,079
something interesting to think about and

1134
00:46:10,079 --> 00:46:11,920
also like another open question is like

1135
00:46:11,920 --> 00:46:13,520
whether there's any way

1136
00:46:13,520 --> 00:46:16,240
to comply combine these two types of

1137
00:46:16,240 --> 00:46:18,720
techniques

1138
00:46:22,240 --> 00:46:24,400
okay thank you

1139
00:46:24,400 --> 00:46:25,920
and

1140
00:46:25,920 --> 00:46:27,520
i guess i'll ask this question we had

1141
00:46:27,520 --> 00:46:29,359
for stanislaus oh

1142
00:46:29,359 --> 00:46:30,960
let's see

1143
00:46:30,960 --> 00:46:31,920
uh

1144
00:46:31,920 --> 00:46:34,319
honestly this one first um

1145
00:46:34,319 --> 00:46:36,319
a question that mihir bulari asked for

1146
00:46:36,319 --> 00:46:39,119
stannis love does the use of public key

1147
00:46:39,119 --> 00:46:41,040
crypto mean you need a public key

1148
00:46:41,040 --> 00:46:43,520
infrastructure

1149
00:46:43,520 --> 00:46:45,680
oh

1150
00:46:45,680 --> 00:46:47,119
do we

1151
00:46:47,119 --> 00:46:50,560
no i don't think so no because

1152
00:46:50,560 --> 00:46:53,440
the the secret keys did the public key

1153
00:46:53,440 --> 00:46:55,760
pairs are picked

1154
00:46:55,760 --> 00:46:57,680
per user

1155
00:46:57,680 --> 00:46:58,480
so

1156
00:46:58,480 --> 00:47:00,800
like if a client wants to register their

1157
00:47:00,800 --> 00:47:02,880
password with the server the the server

1158
00:47:02,880 --> 00:47:04,160
or the user

1159
00:47:04,160 --> 00:47:07,520
picks two keys two public key pairs

1160
00:47:07,520 --> 00:47:10,160
and forms this

1161
00:47:10,160 --> 00:47:12,400
household

1162
00:47:12,400 --> 00:47:13,839
password hash

1163
00:47:13,839 --> 00:47:15,440
from them

1164
00:47:15,440 --> 00:47:17,440
and that's the files that the server

1165
00:47:17,440 --> 00:47:19,119
stores for the user so it has nothing to

1166
00:47:19,119 --> 00:47:21,359
do with others i mean

1167
00:47:21,359 --> 00:47:25,760
you have to agree on an elliptic curve

1168
00:47:25,760 --> 00:47:28,319
but you don't have to agree to

1169
00:47:28,319 --> 00:47:29,760
on anything else

1170
00:47:29,760 --> 00:47:31,920
the results work only in a random oracle

1171
00:47:31,920 --> 00:47:34,079
model

1172
00:47:34,079 --> 00:47:38,280
but that's that's it

1173
00:47:39,040 --> 00:47:40,720
okay thank you

1174
00:47:40,720 --> 00:47:42,000
and um

1175
00:47:42,000 --> 00:47:43,920
i mean i guess following up on that

1176
00:47:43,920 --> 00:47:45,280
quickly

1177
00:47:45,280 --> 00:47:47,440
now at least for some applications for

1178
00:47:47,440 --> 00:47:49,599
pigs we think of them as running over

1179
00:47:49,599 --> 00:47:51,839
tls

1180
00:47:51,839 --> 00:47:53,359
so where we do have this public key

1181
00:47:53,359 --> 00:47:54,960
infrastructure

1182
00:47:54,960 --> 00:47:56,640
would that

1183
00:47:56,640 --> 00:47:58,000
do you think that would somehow be able

1184
00:47:58,000 --> 00:47:59,920
to make us do things more efficiently or

1185
00:47:59,920 --> 00:48:01,520
is that really just completely

1186
00:48:01,520 --> 00:48:04,079
orthogonal

1187
00:48:04,079 --> 00:48:05,520
um

1188
00:48:05,520 --> 00:48:08,240
well so since uh we've been working as

1189
00:48:08,240 --> 00:48:08,960
uh

1190
00:48:08,960 --> 00:48:10,960
as authors of opaque

1191
00:48:10,960 --> 00:48:12,240
uh

1192
00:48:12,240 --> 00:48:16,000
myself and uh who crafted uh

1193
00:48:16,000 --> 00:48:18,839
julia hesse and

1194
00:48:18,839 --> 00:48:21,200
uh um

1195
00:48:21,200 --> 00:48:24,319
chris woods we were working on uh how to

1196
00:48:24,319 --> 00:48:26,720
um

1197
00:48:27,200 --> 00:48:28,720
how to integrate

1198
00:48:28,720 --> 00:48:30,319
uh

1199
00:48:30,319 --> 00:48:32,400
opaque with tls

1200
00:48:32,400 --> 00:48:35,040
and that's an example of and it's an

1201
00:48:35,040 --> 00:48:39,440
ongoing work it's an example of um

1202
00:48:39,440 --> 00:48:42,319
how integrating takes with uh

1203
00:48:42,319 --> 00:48:45,440
with the public infrastructure like tls

1204
00:48:45,440 --> 00:48:48,640
it's you you actually can take advantage

1205
00:48:48,640 --> 00:48:51,440
uh it's an efficiency advantage though

1206
00:48:51,440 --> 00:48:52,890
so

1207
00:48:52,890 --> 00:48:54,480
[Music]

1208
00:48:54,480 --> 00:48:55,599
um

1209
00:48:55,599 --> 00:48:58,319
and um

1210
00:48:58,720 --> 00:49:01,040
so so it's not essential like you could

1211
00:49:01,040 --> 00:49:02,720
run a break without

1212
00:49:02,720 --> 00:49:06,558
without tls and um

1213
00:49:06,720 --> 00:49:07,599
there's

1214
00:49:07,599 --> 00:49:08,559
some

1215
00:49:08,559 --> 00:49:09,680
you know

1216
00:49:09,680 --> 00:49:11,599
for example

1217
00:49:11,599 --> 00:49:14,000
when i run a peg over

1218
00:49:14,000 --> 00:49:16,400
an insecure channel

1219
00:49:16,400 --> 00:49:17,359
uh

1220
00:49:17,359 --> 00:49:19,920
i have to tell you what my username is

1221
00:49:19,920 --> 00:49:23,040
right and that i review publicly well if

1222
00:49:23,040 --> 00:49:24,880
i run it over to ls

1223
00:49:24,880 --> 00:49:26,319
this that part

1224
00:49:26,319 --> 00:49:28,960
becomes but

1225
00:49:29,040 --> 00:49:32,880
apart from that and the efficiency

1226
00:49:32,880 --> 00:49:35,280
of the combining and the fact that you

1227
00:49:35,280 --> 00:49:38,000
can actually reuse element from the

1228
00:49:38,000 --> 00:49:39,760
authenticated key exchange that dls

1229
00:49:39,760 --> 00:49:44,400
implements handshake implements and uh

1230
00:49:44,400 --> 00:49:47,440
um no truth that you know that there is

1231
00:49:47,440 --> 00:49:49,359
um

1232
00:49:49,359 --> 00:49:51,680
there is like a fundamental uh security

1233
00:49:51,680 --> 00:49:54,720
advantage that you get

1234
00:49:55,839 --> 00:49:58,559
sure thank you

1235
00:49:58,559 --> 00:50:01,520
and uh if i'm reading things correctly

1236
00:50:01,520 --> 00:50:03,280
it looks like we've come to the end of

1237
00:50:03,280 --> 00:50:04,720
our session time

1238
00:50:04,720 --> 00:50:06,880
so i'm going to applaud again to once

1239
00:50:06,880 --> 00:50:08,720
again thank all of our speakers both in

1240
00:50:08,720 --> 00:50:13,160
this session and throughout crypto

1241
00:50:17,680 --> 00:50:19,280
and um

1242
00:50:19,280 --> 00:50:21,680
i guess i'm not sure who's in charge of

1243
00:50:21,680 --> 00:50:24,079
the backup but uh

1244
00:50:24,079 --> 00:50:26,640
feel free to take over whoever that

1245
00:50:26,640 --> 00:50:28,960
would be

1246
00:50:31,520 --> 00:50:34,319
um well um

1247
00:50:34,319 --> 00:50:36,960
i i think it is 5 20 i think

1248
00:50:36,960 --> 00:50:39,440
so the previous session ended

1249
00:50:39,440 --> 00:50:41,760
i'm here i'm not

1250
00:50:41,760 --> 00:50:43,920
i think i think towel is logged in but

1251
00:50:43,920 --> 00:50:46,319
also maybe

1252
00:50:46,319 --> 00:50:48,319
chris is around

1253
00:50:48,319 --> 00:50:50,400
so the

1254
00:50:50,400 --> 00:50:52,079
let me start

1255
00:50:52,079 --> 00:50:54,640
the closing remarks which is not uh too

1256
00:50:54,640 --> 00:50:55,920
much to say

1257
00:50:55,920 --> 00:50:59,040
um i think that the conference

1258
00:50:59,040 --> 00:51:01,200
went uh very well

1259
00:51:01,200 --> 00:51:04,000
there were no hiccups and um it was very

1260
00:51:04,000 --> 00:51:05,440
smooth and

1261
00:51:05,440 --> 00:51:07,760
a great organization

1262
00:51:07,760 --> 00:51:09,359
a lot of people

1263
00:51:09,359 --> 00:51:11,200
showed up and i think everybody is

1264
00:51:11,200 --> 00:51:14,160
enjoying the conference

1265
00:51:14,160 --> 00:51:17,200
so i wanted to thank everybody

1266
00:51:17,200 --> 00:51:20,000
i wanted to encourage everybody to

1267
00:51:20,000 --> 00:51:23,440
download and print the logo on their

1268
00:51:23,440 --> 00:51:25,200
t-shirts to

1269
00:51:25,200 --> 00:51:27,599
uh and to show it in person next time we

1270
00:51:27,599 --> 00:51:28,400
meet

1271
00:51:28,400 --> 00:51:30,240
uh hopefully

1272
00:51:30,240 --> 00:51:32,559
maybe some people will be able to go to

1273
00:51:32,559 --> 00:51:35,760
uh to eurocrypt this year but hopefully

1274
00:51:35,760 --> 00:51:38,160
very soon we will all meet in some

1275
00:51:38,160 --> 00:51:40,240
conference uh

1276
00:51:40,240 --> 00:51:43,680
eurocrypt next year perhaps or even rwc

1277
00:51:43,680 --> 00:51:46,319
and there is a

1278
00:51:46,319 --> 00:51:49,440
would be nice to uh to wear the shirts

1279
00:51:49,440 --> 00:51:51,599
from from this year's crypto

1280
00:51:51,599 --> 00:51:53,760
um so again um

1281
00:51:53,760 --> 00:51:55,760
thank you everybody for uh for a great

1282
00:51:55,760 --> 00:51:57,440
conference um

1283
00:51:57,440 --> 00:51:59,440
it was a pleasure sitting

1284
00:51:59,440 --> 00:52:00,800
sitting seeing

1285
00:52:00,800 --> 00:52:03,760
so many people and chatting and

1286
00:52:03,760 --> 00:52:05,839
a video and chat

1287
00:52:05,839 --> 00:52:06,960
with

1288
00:52:06,960 --> 00:52:10,880
with many friends and i hope to see you

1289
00:52:10,880 --> 00:52:12,800
hope to see you very soon

1290
00:52:12,800 --> 00:52:15,680
i already thanked kevin and kay

1291
00:52:15,680 --> 00:52:17,440
300 times

1292
00:52:17,440 --> 00:52:19,359
but let me you know

1293
00:52:19,359 --> 00:52:21,920
let me thank them again for making uh

1294
00:52:21,920 --> 00:52:23,680
this happen so easily

1295
00:52:23,680 --> 00:52:26,078
thank you

1296
00:52:29,119 --> 00:52:32,079
i'll just add thank you also to everyone

1297
00:52:32,079 --> 00:52:35,119
the organizers kevin and kay and vlad

1298
00:52:35,119 --> 00:52:36,880
and everyone else as well as the

1299
00:52:36,880 --> 00:52:38,800
audience and the authors

1300
00:52:38,800 --> 00:52:40,480
and i also hope to see everyone in

1301
00:52:40,480 --> 00:52:44,200
person very soon

1302
00:52:46,720 --> 00:52:48,880
and i suppose with that i should stop

1303
00:52:48,880 --> 00:52:53,119
live streaming this uh i defer

