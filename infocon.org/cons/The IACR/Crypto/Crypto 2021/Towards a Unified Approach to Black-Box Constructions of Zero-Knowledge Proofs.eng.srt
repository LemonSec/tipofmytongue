1
00:00:00,000 --> 00:00:02,000
hi everyone i'm here to talk about our

2
00:00:02,000 --> 00:00:04,080
work on blackbox your knowledge this is

3
00:00:04,080 --> 00:00:06,000
a joint work with my advisor amkhan

4
00:00:06,000 --> 00:00:08,320
pandi

5
00:00:08,320 --> 00:00:10,320
your knowledge is a so important

6
00:00:10,320 --> 00:00:13,120
primitive that requires no infection in

7
00:00:13,120 --> 00:00:15,200
this work we focus on black boxer

8
00:00:15,200 --> 00:00:17,440
knowledge by black box we mean the

9
00:00:17,440 --> 00:00:18,880
construction of the zero knowledge

10
00:00:18,880 --> 00:00:20,480
protocol only makes use of the

11
00:00:20,480 --> 00:00:22,720
underlying primitive in a black box way

12
00:00:22,720 --> 00:00:24,560
so why we are interested in black box

13
00:00:24,560 --> 00:00:26,000
zero knowledge

14
00:00:26,000 --> 00:00:28,000
because the efficiency of the zero

15
00:00:28,000 --> 00:00:30,000
knowledge protocol is not affected no

16
00:00:30,000 --> 00:00:32,079
matter how you implement the underlying

17
00:00:32,079 --> 00:00:34,320
building blocks

18
00:00:34,320 --> 00:00:36,000
over the years our community has

19
00:00:36,000 --> 00:00:38,239
developed so many bad box journalist

20
00:00:38,239 --> 00:00:39,360
protocols

21
00:00:39,360 --> 00:00:41,360
however once you want to use your

22
00:00:41,360 --> 00:00:43,680
knowledge protocol to prove a statement

23
00:00:43,680 --> 00:00:46,000
involving some cryptographic gadgets

24
00:00:46,000 --> 00:00:48,480
things change that means even though the

25
00:00:48,480 --> 00:00:50,079
zero knowledge protocol itself is black

26
00:00:50,079 --> 00:00:52,879
box once you write on such a statement

27
00:00:52,879 --> 00:00:54,800
you are bound to make non-black box use

28
00:00:54,800 --> 00:00:56,320
of the underlying primitive that is

29
00:00:56,320 --> 00:00:58,079
involved in the statement this is

30
00:00:58,079 --> 00:01:00,079
actually a quite common situation for

31
00:01:00,079 --> 00:01:02,879
example think of the norm paradigm or

32
00:01:02,879 --> 00:01:06,240
the gmw compiler in these situations you

33
00:01:06,240 --> 00:01:08,000
need to write your knowledge proof on an

34
00:01:08,000 --> 00:01:10,560
encryption or a commitment then you have

35
00:01:10,560 --> 00:01:12,320
to know the code of the encryption or

36
00:01:12,320 --> 00:01:14,640
the commitment scheme in this work we

37
00:01:14,640 --> 00:01:17,200
are particularly interested in this

38
00:01:17,200 --> 00:01:19,920
simple language this language captures

39
00:01:19,920 --> 00:01:21,920
the range membership of a only function

40
00:01:21,920 --> 00:01:24,240
f this language itself is black box

41
00:01:24,240 --> 00:01:26,240
because to test the membership of the

42
00:01:26,240 --> 00:01:28,400
language if someone gives you the

43
00:01:28,400 --> 00:01:30,479
witness which is a pre-image you only

44
00:01:30,479 --> 00:01:32,000
need black box access to the one

45
00:01:32,000 --> 00:01:33,040
function f

46
00:01:33,040 --> 00:01:34,880
as we know zero knowledge can be

47
00:01:34,880 --> 00:01:36,479
constructed from one function in a

48
00:01:36,479 --> 00:01:39,119
mailbox way now we have this language

49
00:01:39,119 --> 00:01:41,280
that also makes only black box access to

50
00:01:41,280 --> 00:01:42,880
the one function f

51
00:01:42,880 --> 00:01:44,880
then a natural question would be

52
00:01:44,880 --> 00:01:46,320
can we have a zero knowledge protocol

53
00:01:46,320 --> 00:01:48,479
for this language making only black box

54
00:01:48,479 --> 00:01:51,040
access to the only function f

55
00:01:51,040 --> 00:01:54,159
to capture this task formally mac result

56
00:01:54,159 --> 00:01:55,840
defines the notion of functionality

57
00:01:55,840 --> 00:01:57,759
black box zero knowledge

58
00:01:57,759 --> 00:01:59,600
let's look at the range membership

59
00:01:59,600 --> 00:02:02,320
language we defined before f b b z k

60
00:02:02,320 --> 00:02:04,479
requires the existence of a protocol

61
00:02:04,479 --> 00:02:06,320
where both parties has only black box

62
00:02:06,320 --> 00:02:09,280
access to this f the statement is the

63
00:02:09,280 --> 00:02:11,520
image y and the prover holds

64
00:02:11,520 --> 00:02:13,599
additionally the pre-image x as a

65
00:02:13,599 --> 00:02:15,840
witness the approver wants to prove that

66
00:02:15,840 --> 00:02:18,640
y is indeed in the range of f

67
00:02:18,640 --> 00:02:20,800
the companies and soundness are defined

68
00:02:20,800 --> 00:02:22,640
in a natural way for the zero knowledge

69
00:02:22,640 --> 00:02:23,840
property

70
00:02:23,840 --> 00:02:26,400
as you can see it's also the same as the

71
00:02:26,400 --> 00:02:28,879
traditional one the only difference is

72
00:02:28,879 --> 00:02:31,760
now both party has black box access to f

73
00:02:31,760 --> 00:02:34,000
in the real execution i want to point

74
00:02:34,000 --> 00:02:36,480
out that it is not necessary to require

75
00:02:36,480 --> 00:02:39,519
that the simulator

76
00:02:39,519 --> 00:02:41,519
makes only black box access to this only

77
00:02:41,519 --> 00:02:43,360
function f or not you can choose to give

78
00:02:43,360 --> 00:02:44,879
the code to the simulator but the

79
00:02:44,879 --> 00:02:47,200
parties in the real execution they must

80
00:02:47,200 --> 00:02:48,959
have black box access to this one

81
00:02:48,959 --> 00:02:50,400
function

82
00:02:50,400 --> 00:02:52,640
unfortunately dress like shows that

83
00:02:52,640 --> 00:02:54,080
functionally black box journalist

84
00:02:54,080 --> 00:02:56,080
doesn't exist even for this simple range

85
00:02:56,080 --> 00:02:58,080
membership language this is actually

86
00:02:58,080 --> 00:02:59,920
quite discouraging because as we

87
00:02:59,920 --> 00:03:02,159
mentioned before we usually need to run

88
00:03:02,159 --> 00:03:04,959
zk for a capital statement and now even

89
00:03:04,959 --> 00:03:07,120
for this simple membership language we

90
00:03:07,120 --> 00:03:09,920
cannot do that therefore in this work we

91
00:03:09,920 --> 00:03:12,319
ask the question can we somehow bypass

92
00:03:12,319 --> 00:03:13,680
this lower bound

93
00:03:13,680 --> 00:03:15,840
so the first question is why can we even

94
00:03:15,840 --> 00:03:18,000
hope for bypassing this lower bound if

95
00:03:18,000 --> 00:03:19,440
you look at the vertical like lower

96
00:03:19,440 --> 00:03:21,599
bound carefully it says for given moment

97
00:03:21,599 --> 00:03:24,159
function f you cannot have a black box

98
00:03:24,159 --> 00:03:26,080
protocol for the range membership of

99
00:03:26,080 --> 00:03:28,959
this one function our idea here is to

100
00:03:28,959 --> 00:03:30,640
construct a new one function from the

101
00:03:30,640 --> 00:03:32,480
given moment function and then try to

102
00:03:32,480 --> 00:03:34,159
construct a zero noise protocol for the

103
00:03:34,159 --> 00:03:36,319
new one function in a bad box way i will

104
00:03:36,319 --> 00:03:38,799
elaborate on this in next slide

105
00:03:38,799 --> 00:03:40,879
more formally we are looking for an

106
00:03:40,879 --> 00:03:42,799
oracle algorithm f and an oracle

107
00:03:42,799 --> 00:03:45,440
protocol pi if we instantiate them with

108
00:03:45,440 --> 00:03:48,319
a one function f to the f will be a y

109
00:03:48,319 --> 00:03:50,799
function and pi to the f will be a zero

110
00:03:50,799 --> 00:03:52,000
knowledge protocol for the linear

111
00:03:52,000 --> 00:03:53,840
membership of the new one function after

112
00:03:53,840 --> 00:03:55,760
the f that is uh

113
00:03:55,760 --> 00:03:57,680
this new black box language it is

114
00:03:57,680 --> 00:04:00,239
important to notice that both f to the f

115
00:04:00,239 --> 00:04:02,080
and path to the f make only black box

116
00:04:02,080 --> 00:04:03,680
access to the given runway function

117
00:04:03,680 --> 00:04:04,799
small f

118
00:04:04,799 --> 00:04:06,879
we call this primitive proof based one

119
00:04:06,879 --> 00:04:09,280
function we can also define proof based

120
00:04:09,280 --> 00:04:11,519
prg and the clearing resistance hash

121
00:04:11,519 --> 00:04:13,439
function in a similar way

122
00:04:13,439 --> 00:04:16,000
then why this approach has a potential

123
00:04:16,000 --> 00:04:18,399
to bypass resolute lower bound there are

124
00:04:18,399 --> 00:04:20,959
two reasons first given an input this

125
00:04:20,959 --> 00:04:22,960
capital f can make many oracle queries

126
00:04:22,960 --> 00:04:25,440
to the small f also it can perform

127
00:04:25,440 --> 00:04:27,840
post-processing or pre-processing on the

128
00:04:27,840 --> 00:04:30,479
intermediate oracle answers also the

129
00:04:30,479 --> 00:04:32,639
protocol pi even though it cannot use

130
00:04:32,639 --> 00:04:34,800
the code of the small f it can use the

131
00:04:34,800 --> 00:04:37,280
code of the capital f if this idea can

132
00:04:37,280 --> 00:04:39,360
really help us bypass roswell's lower

133
00:04:39,360 --> 00:04:41,919
bound then our hope is in applications

134
00:04:41,919 --> 00:04:43,280
where you need to run the xenomorph

135
00:04:43,280 --> 00:04:45,600
proof on one function prg or hash

136
00:04:45,600 --> 00:04:47,680
function we'll just use the proof based

137
00:04:47,680 --> 00:04:49,280
version instead

138
00:04:49,280 --> 00:04:51,280
now the question is is this proof based

139
00:04:51,280 --> 00:04:53,280
notion really possible to achieve

140
00:04:53,280 --> 00:04:55,520
in this work we provide results on both

141
00:04:55,520 --> 00:04:58,080
sides on the negative side we show that

142
00:04:58,080 --> 00:05:00,400
proof based line function is impossible

143
00:05:00,400 --> 00:05:02,240
actually due to some technical reasons

144
00:05:02,240 --> 00:05:03,520
we are only able to show that

145
00:05:03,520 --> 00:05:06,000
proof-based prt is impossible but this

146
00:05:06,000 --> 00:05:08,240
is already a strong evidence showing the

147
00:05:08,240 --> 00:05:10,880
limitation of the proof-based notion

148
00:05:10,880 --> 00:05:13,039
next we show that if we give the

149
00:05:13,039 --> 00:05:15,520
verifier some control over the input

150
00:05:15,520 --> 00:05:17,759
then proof-based notion actually becomes

151
00:05:17,759 --> 00:05:19,840
flexible i'll explain later what do we

152
00:05:19,840 --> 00:05:22,000
mean by sub-control over the input let

153
00:05:22,000 --> 00:05:24,000
me first give a very brief overview of

154
00:05:24,000 --> 00:05:26,720
our netfield result here the strategy is

155
00:05:26,720 --> 00:05:28,720
we assume the existence of a proof-based

156
00:05:28,720 --> 00:05:30,560
prg and then we try to derive a

157
00:05:30,560 --> 00:05:31,680
contradiction

158
00:05:31,680 --> 00:05:33,759
given any one-way function f a

159
00:05:33,759 --> 00:05:36,240
proof-based prg consists of two parts

160
00:05:36,240 --> 00:05:38,800
first we have this oracle algorithm g to

161
00:05:38,800 --> 00:05:41,280
the power f which is the prg we also

162
00:05:41,280 --> 00:05:43,600
have this oracle path to the f which is

163
00:05:43,600 --> 00:05:45,759
a gq protocol for the range membership

164
00:05:45,759 --> 00:05:47,840
relation of the prg to derive the

165
00:05:47,840 --> 00:05:50,080
contradiction we first consider the

166
00:05:50,080 --> 00:05:52,320
honest execution of the protocol where

167
00:05:52,320 --> 00:05:54,880
both the prover and verifier has oracle

168
00:05:54,880 --> 00:05:57,600
access to the only function f and we

169
00:05:57,600 --> 00:05:59,919
have all this generated pre-image image

170
00:05:59,919 --> 00:06:02,880
pair x and y in this habit by the

171
00:06:02,880 --> 00:06:05,440
companies of the dk protocol we have

172
00:06:05,440 --> 00:06:07,520
that the verifier will accept with

173
00:06:07,520 --> 00:06:10,000
probability close to 1. now we consider

174
00:06:10,000 --> 00:06:11,840
another hybrid where we resample the

175
00:06:11,840 --> 00:06:13,840
oracle but we keep the most likely

176
00:06:13,840 --> 00:06:15,680
queries of the verifier

177
00:06:15,680 --> 00:06:18,240
let's look at the view execution here

178
00:06:18,240 --> 00:06:20,639
during the execution the verifier can

179
00:06:20,639 --> 00:06:23,199
make multiple queries to the oracle f

180
00:06:23,199 --> 00:06:25,680
now we collect all the query answer

181
00:06:25,680 --> 00:06:27,759
pairs that obtained by v with high

182
00:06:27,759 --> 00:06:29,039
probability

183
00:06:29,039 --> 00:06:31,520
and we call this set

184
00:06:31,520 --> 00:06:34,800
q easy we keep this q easy set fixed but

185
00:06:34,800 --> 00:06:36,880
we resample every other points of the

186
00:06:36,880 --> 00:06:40,160
oracle f we call this new oracle f prime

187
00:06:40,160 --> 00:06:42,560
now intuitively because we keep all the

188
00:06:42,560 --> 00:06:45,360
queries asked by v with high probability

189
00:06:45,360 --> 00:06:47,680
these two executions from this point of

190
00:06:47,680 --> 00:06:50,400
view shouldn't differ too much therefore

191
00:06:50,400 --> 00:06:53,039
in hebrew 1 p should also accept with

192
00:06:53,039 --> 00:06:55,120
probability close to 1. actually there

193
00:06:55,120 --> 00:06:57,280
will be an additional 1 over poly laws

194
00:06:57,280 --> 00:06:58,960
but in this talk we don't need to pay

195
00:06:58,960 --> 00:07:00,560
much attention to this

196
00:07:00,560 --> 00:07:02,479
then in the paper we proved a technical

197
00:07:02,479 --> 00:07:05,199
letter which says if we start with an y

198
00:07:05,199 --> 00:07:08,000
that is in the range of g to the power f

199
00:07:08,000 --> 00:07:09,919
then we replace this f by the

200
00:07:09,919 --> 00:07:13,199
composition of f prime

201
00:07:13,199 --> 00:07:16,240
and q e z set

202
00:07:16,240 --> 00:07:18,400
the probability that y is still in the

203
00:07:18,400 --> 00:07:20,880
range of this g instantiated with this

204
00:07:20,880 --> 00:07:23,680
new oracle is no larger than half this

205
00:07:23,680 --> 00:07:26,479
actually gave us a contradiction

206
00:07:26,479 --> 00:07:28,720
because in hebrew 1 the verifier still

207
00:07:28,720 --> 00:07:30,319
accepts with probability very close to

208
00:07:30,319 --> 00:07:32,319
1. this technical learner is our major

209
00:07:32,319 --> 00:07:34,160
contribution in this part but due to

210
00:07:34,160 --> 00:07:35,840
time constraints i won't talk about it

211
00:07:35,840 --> 00:07:37,919
here more details can be found in our

212
00:07:37,919 --> 00:07:40,160
paper if you are interested

213
00:07:40,160 --> 00:07:42,319
now we just showed that proof-based prg

214
00:07:42,319 --> 00:07:45,120
is impossible and this is also an

215
00:07:45,120 --> 00:07:47,039
evidence for the impossibility of proof

216
00:07:47,039 --> 00:07:49,360
is to line function then we want to ask

217
00:07:49,360 --> 00:07:51,360
the question can we somehow relax the

218
00:07:51,360 --> 00:07:53,360
proof-based notion such that it's still

219
00:07:53,360 --> 00:07:55,360
meaningful and achievable

220
00:07:55,360 --> 00:07:57,599
this is our original definition for

221
00:07:57,599 --> 00:08:00,240
perfect y function here we draw some

222
00:08:00,240 --> 00:08:02,639
inspirations from the famous gojek 11

223
00:08:02,639 --> 00:08:05,039
theorem that is instead of viewing the

224
00:08:05,039 --> 00:08:07,360
input at the single string x we want to

225
00:08:07,360 --> 00:08:10,160
split it into two parts x and r we

226
00:08:10,160 --> 00:08:12,479
require that f is the only function on

227
00:08:12,479 --> 00:08:15,280
its first input for arbitrary r

228
00:08:15,280 --> 00:08:17,680
then in a protocol we allow the verifier

229
00:08:17,680 --> 00:08:20,160
to pick the r part intuitively this

230
00:08:20,160 --> 00:08:22,000
allows the verifier to hold some part of

231
00:08:22,000 --> 00:08:24,319
the input which he can use to verify the

232
00:08:24,319 --> 00:08:26,479
range membership and as we will show

233
00:08:26,479 --> 00:08:28,960
later this relaxation indeed allows us

234
00:08:28,960 --> 00:08:30,800
to have a construction but here i want

235
00:08:30,800 --> 00:08:32,958
to make two remarks first since the

236
00:08:32,958 --> 00:08:35,360
verifier choose the r part to have a

237
00:08:35,360 --> 00:08:37,200
meaningful notion of what we need we

238
00:08:37,200 --> 00:08:39,760
want to see that no matter what the r is

239
00:08:39,760 --> 00:08:41,599
the function should be one way this is

240
00:08:41,599 --> 00:08:43,919
the exact reason why we stipulate that

241
00:08:43,919 --> 00:08:45,920
one minute should hold for arbitrary r

242
00:08:45,920 --> 00:08:48,080
second this r part is picked by the

243
00:08:48,080 --> 00:08:50,560
verifier it's not a part of the public

244
00:08:50,560 --> 00:08:52,480
statement so it becomes a little bit

245
00:08:52,480 --> 00:08:54,560
trickier to define your knowledge here

246
00:08:54,560 --> 00:08:56,320
we have to switch to a 2pc flavor

247
00:08:56,320 --> 00:08:57,760
definition

248
00:08:57,760 --> 00:09:00,080
more formally our new definition for

249
00:09:00,080 --> 00:09:01,440
proof based online function works as

250
00:09:01,440 --> 00:09:02,560
false

251
00:09:02,560 --> 00:09:04,800
as we said before we want one minutes to

252
00:09:04,800 --> 00:09:06,560
hold for r

253
00:09:06,560 --> 00:09:08,800
now for companies and for z key we're

254
00:09:08,800 --> 00:09:11,200
gonna use a two pc flavor definition we

255
00:09:11,200 --> 00:09:13,200
compare a real execution and the audio

256
00:09:13,200 --> 00:09:15,760
execution in the real execution the

257
00:09:15,760 --> 00:09:18,560
sender has x as input and the receiver

258
00:09:18,560 --> 00:09:20,720
has r as input these are the two parts

259
00:09:20,720 --> 00:09:23,360
of the input with split as x and r

260
00:09:23,360 --> 00:09:26,320
these two parties run the protocol pi f

261
00:09:26,320 --> 00:09:28,240
defined by the proof based only function

262
00:09:28,240 --> 00:09:30,959
at the end of the execution the sender

263
00:09:30,959 --> 00:09:33,519
learns x and r which are supposed to be

264
00:09:33,519 --> 00:09:35,680
the which are supposed to be the input

265
00:09:35,680 --> 00:09:37,279
of the y function

266
00:09:37,279 --> 00:09:40,720
f x r the receiver learns the output y

267
00:09:40,720 --> 00:09:43,200
which is supposed to be the image of f

268
00:09:43,200 --> 00:09:46,399
under x r in the edu world there is a

269
00:09:46,399 --> 00:09:48,959
trusted third party computing f to the f

270
00:09:48,959 --> 00:09:51,200
the sender will provide the x part of

271
00:09:51,200 --> 00:09:53,519
the input the receiver will provide the

272
00:09:53,519 --> 00:09:56,320
r part the trusted third party just

273
00:09:56,320 --> 00:09:59,440
return r back to s honestly and computes

274
00:09:59,440 --> 00:10:02,399
the output y and give it to the receiver

275
00:10:02,399 --> 00:10:04,560
once we are in this simulation paradigm

276
00:10:04,560 --> 00:10:06,800
gk can be defined by requiring the

277
00:10:06,800 --> 00:10:09,040
security for malicious receiver to

278
00:10:09,040 --> 00:10:11,040
define soundness we require that

279
00:10:11,040 --> 00:10:13,600
whenever the receiver output a value y

280
00:10:13,600 --> 00:10:16,160
that is non-abort there must exist a

281
00:10:16,160 --> 00:10:18,480
pre-image such that this equation holds

282
00:10:18,480 --> 00:10:20,160
if you are interested you can pause the

283
00:10:20,160 --> 00:10:21,920
video and look at this more formal

284
00:10:21,920 --> 00:10:24,000
version of sony's

285
00:10:24,000 --> 00:10:25,680
now we are ready to talk about our

286
00:10:25,680 --> 00:10:27,680
construction i'll present a first

287
00:10:27,680 --> 00:10:29,760
attempt that doesn't quite work but it

288
00:10:29,760 --> 00:10:32,079
gave us inspirations remember that the

289
00:10:32,079 --> 00:10:34,240
proof-based one function consists of two

290
00:10:34,240 --> 00:10:36,640
parts the function and the protocol that

291
00:10:36,640 --> 00:10:38,560
proves its range membership

292
00:10:38,560 --> 00:10:40,720
here i will describe the protocol first

293
00:10:40,720 --> 00:10:42,399
because from the description of the

294
00:10:42,399 --> 00:10:44,959
protocol it's easy to derive what the

295
00:10:44,959 --> 00:10:46,800
function should look like

296
00:10:46,800 --> 00:10:48,880
let's recall our setting first we have

297
00:10:48,880 --> 00:10:50,880
the sender and receiver having black box

298
00:10:50,880 --> 00:10:53,440
access to a one function f the sender

299
00:10:53,440 --> 00:10:55,360
holds the s part of the input and the

300
00:10:55,360 --> 00:10:58,160
receiver picks the r part of input our

301
00:10:58,160 --> 00:11:00,079
first idea is inspired by the cut and

302
00:11:00,079 --> 00:11:02,959
choose technique concretely we ask the

303
00:11:02,959 --> 00:11:05,440
sender to pick np images query the

304
00:11:05,440 --> 00:11:07,920
article and learn the corresponding well

305
00:11:07,920 --> 00:11:09,120
and through button

306
00:11:09,120 --> 00:11:11,040
the sender will send the image to the

307
00:11:11,040 --> 00:11:13,600
receiver now the receiver has no idea of

308
00:11:13,600 --> 00:11:16,160
the corresponding pre-image

309
00:11:16,160 --> 00:11:18,000
but here we'll pick a random size t

310
00:11:18,000 --> 00:11:20,079
subset where t is a constant fraction of

311
00:11:20,079 --> 00:11:23,200
n receiver sends this r the sender will

312
00:11:23,200 --> 00:11:25,360
review the pre-image in the positions

313
00:11:25,360 --> 00:11:27,760
specified by the sexy random subset the

314
00:11:27,760 --> 00:11:29,279
receiver of course checks if the

315
00:11:29,279 --> 00:11:31,920
positions in r are open honestly

316
00:11:31,920 --> 00:11:34,320
if the check passes he will output all

317
00:11:34,320 --> 00:11:36,560
the images under the pre image for

318
00:11:36,560 --> 00:11:40,000
position r and also this subset r as a

319
00:11:40,000 --> 00:11:41,440
final output

320
00:11:41,440 --> 00:11:43,360
from this protocol it's not hard to see

321
00:11:43,360 --> 00:11:45,040
that the corresponding y function should

322
00:11:45,040 --> 00:11:46,160
look like this

323
00:11:46,160 --> 00:11:48,320
on input x and r

324
00:11:48,320 --> 00:11:50,320
it just outputs the same output as the

325
00:11:50,320 --> 00:11:53,440
receiver let's look at what we achieved

326
00:11:53,440 --> 00:11:55,839
here are n positions the receiver checks

327
00:11:55,839 --> 00:11:58,079
the successive random subset

328
00:11:58,079 --> 00:12:00,639
this ensures that a malicious sender can

329
00:12:00,639 --> 00:12:03,040
cheat on at most k positions out of n

330
00:12:03,040 --> 00:12:05,680
where k is a constant fraction of n

331
00:12:05,680 --> 00:12:07,279
this is not good enough

332
00:12:07,279 --> 00:12:09,200
recall that the thirdness of the proof

333
00:12:09,200 --> 00:12:11,120
based one function requires that if the

334
00:12:11,120 --> 00:12:13,360
receiver accepts there must exist a

335
00:12:13,360 --> 00:12:14,480
pre-image

336
00:12:14,480 --> 00:12:16,720
however this protocol only ensures that

337
00:12:16,720 --> 00:12:19,040
there exists some string that is a

338
00:12:19,040 --> 00:12:22,399
one-man delta close to a real per image

339
00:12:22,399 --> 00:12:24,959
as we said before that's because s star

340
00:12:24,959 --> 00:12:27,680
can still cheat on the delta fraction

341
00:12:27,680 --> 00:12:29,360
this inspires us to think of the

342
00:12:29,360 --> 00:12:30,560
following idea

343
00:12:30,560 --> 00:12:33,680
can we somehow extend f to f such that

344
00:12:33,680 --> 00:12:35,839
for all the strings within a delta bar

345
00:12:35,839 --> 00:12:37,760
of a real per image these strings are

346
00:12:37,760 --> 00:12:40,079
also valid for image

347
00:12:40,079 --> 00:12:41,839
now i'm going to talk about how to

348
00:12:41,839 --> 00:12:44,000
incorporate this delta bar into the

349
00:12:44,000 --> 00:12:46,079
domain of the one function

350
00:12:46,079 --> 00:12:48,240
here we need a new idea called pre-image

351
00:12:48,240 --> 00:12:50,720
editing concretely we modify the

352
00:12:50,720 --> 00:12:52,240
previous only function in the following

353
00:12:52,240 --> 00:12:53,200
way

354
00:12:53,200 --> 00:12:56,800
on input x and r the function parses x

355
00:12:56,800 --> 00:12:59,920
as x 1 through x n and an additional

356
00:12:59,920 --> 00:13:02,800
beta part as we will see later this beta

357
00:13:02,800 --> 00:13:05,519
part is the key component that allow us

358
00:13:05,519 --> 00:13:08,399
to incorporate the delta ball

359
00:13:08,399 --> 00:13:09,920
then as before

360
00:13:09,920 --> 00:13:12,240
the function query the oracle to compute

361
00:13:12,240 --> 00:13:14,399
y1 through yn

362
00:13:14,399 --> 00:13:17,120
and as before it parses r as a set t

363
00:13:17,120 --> 00:13:19,760
subset of n

364
00:13:19,760 --> 00:13:22,639
now to compute the output y we consider

365
00:13:22,639 --> 00:13:25,120
two separate cases the first case is a

366
00:13:25,120 --> 00:13:27,760
non-editing case it is identified by

367
00:13:27,760 --> 00:13:28,959
this condition

368
00:13:28,959 --> 00:13:30,639
this condition says

369
00:13:30,639 --> 00:13:33,760
if you collect the pi part from beta it

370
00:13:33,760 --> 00:13:36,000
forms a subset of positions

371
00:13:36,000 --> 00:13:37,920
if this subset of positions is

372
00:13:37,920 --> 00:13:39,760
overlapping with the predictions

373
00:13:39,760 --> 00:13:42,399
specified by r the function just

374
00:13:42,399 --> 00:13:45,440
operates as before that is it put all

375
00:13:45,440 --> 00:13:48,560
the y one through a y and in the s part

376
00:13:48,560 --> 00:13:51,120
the more interesting case is the editing

377
00:13:51,120 --> 00:13:53,760
case this case is identified by the

378
00:13:53,760 --> 00:13:56,079
complement of the previous one in this

379
00:13:56,079 --> 00:13:58,560
situation for all the positions

380
00:13:58,560 --> 00:14:01,279
specified by the p set we're going to

381
00:14:01,279 --> 00:14:03,920
set xi to the value specified by the

382
00:14:03,920 --> 00:14:06,000
corresponding ypi prime

383
00:14:06,000 --> 00:14:08,320
for all the other positions we will just

384
00:14:08,320 --> 00:14:10,720
use the y returned by oracle

385
00:14:10,720 --> 00:14:12,800
this must be confusing if you look at it

386
00:14:12,800 --> 00:14:14,240
for the first time

387
00:14:14,240 --> 00:14:16,079
but the magical takeaway is if the

388
00:14:16,079 --> 00:14:18,160
editing case is triggered for the

389
00:14:18,160 --> 00:14:21,360
positions specified by this p set the

390
00:14:21,360 --> 00:14:24,399
corresponding s i values are already

391
00:14:24,399 --> 00:14:27,279
appearing in the input anyone who's this

392
00:14:27,279 --> 00:14:30,160
input can tell these values directly

393
00:14:30,160 --> 00:14:32,079
let's see how this resolves the previous

394
00:14:32,079 --> 00:14:33,680
problem

395
00:14:33,680 --> 00:14:36,079
recall that the previous problem is we

396
00:14:36,079 --> 00:14:38,000
may have k bad positions in the pre

397
00:14:38,000 --> 00:14:38,880
image

398
00:14:38,880 --> 00:14:41,519
now by making use of this editing case

399
00:14:41,519 --> 00:14:43,360
we want to correct all these k bad

400
00:14:43,360 --> 00:14:45,680
positions using the values specified by

401
00:14:45,680 --> 00:14:48,079
its ypi prime values contained in this

402
00:14:48,079 --> 00:14:50,560
beta part i think it will help if we run

403
00:14:50,560 --> 00:14:52,320
through this mini example

404
00:14:52,320 --> 00:14:53,360
let's say

405
00:14:53,360 --> 00:14:55,839
after the execution of the protocol the

406
00:14:55,839 --> 00:14:58,480
receiver learn the y of this form

407
00:14:58,480 --> 00:15:01,600
where this s4 is a bad position also

408
00:15:01,600 --> 00:15:04,399
this y tells us that the set r consists

409
00:15:04,399 --> 00:15:06,639
of this one and three

410
00:15:06,639 --> 00:15:08,959
now i claim that this x is a very

411
00:15:08,959 --> 00:15:10,079
pre-image

412
00:15:10,079 --> 00:15:12,720
let's take a closer look at this x here

413
00:15:12,720 --> 00:15:16,079
we have x1 2 3 and x5 these are the

414
00:15:16,079 --> 00:15:20,079
valid per image of s123 and s5

415
00:15:20,079 --> 00:15:21,120
note that

416
00:15:21,120 --> 00:15:23,680
these pre images exist because the only

417
00:15:23,680 --> 00:15:27,199
bad position is s4 for s123 and s5 there

418
00:15:27,199 --> 00:15:29,680
must exist corresponding image so the

419
00:15:29,680 --> 00:15:32,480
only problematic position is s4

420
00:15:32,480 --> 00:15:34,800
now in the pre image we constructed we

421
00:15:34,800 --> 00:15:37,279
just put a zero string as a pre-image of

422
00:15:37,279 --> 00:15:38,320
s4

423
00:15:38,320 --> 00:15:41,600
we make the beta part look at 4 and s4

424
00:15:41,600 --> 00:15:44,639
this s4 comes from the y to see why this

425
00:15:44,639 --> 00:15:47,680
x is a very free image of y let's try to

426
00:15:47,680 --> 00:15:50,560
evaluate the function f on x and r

427
00:15:50,560 --> 00:15:53,600
following the definition on this set by

428
00:15:53,600 --> 00:15:57,120
definition we know that the r set is one

429
00:15:57,120 --> 00:16:00,320
three and the corresponding p set is

430
00:16:00,320 --> 00:16:02,880
simply four therefore these two sets

431
00:16:02,880 --> 00:16:05,279
does not overlap so we triggered this

432
00:16:05,279 --> 00:16:07,839
editing condition

433
00:16:07,839 --> 00:16:10,240
it doesn't matter what value we put here

434
00:16:10,240 --> 00:16:12,399
because this position is a position

435
00:16:12,399 --> 00:16:15,759
specified by p in the output we will

436
00:16:15,759 --> 00:16:18,639
always put s4 as the corresponding

437
00:16:18,639 --> 00:16:19,920
output

438
00:16:19,920 --> 00:16:22,399
therefore if you follow the steps listed

439
00:16:22,399 --> 00:16:24,639
on the left you can verify that

440
00:16:24,639 --> 00:16:27,440
x and r is a very pre-image for this y

441
00:16:27,440 --> 00:16:30,000
here i want to make one more remark this

442
00:16:30,000 --> 00:16:33,360
x 1 2 3 and x 5 there are three images

443
00:16:33,360 --> 00:16:35,600
of the corresponding

444
00:16:35,600 --> 00:16:37,759
s values or y values

445
00:16:37,759 --> 00:16:39,920
they may not be efficiently computable

446
00:16:39,920 --> 00:16:41,759
but in the proof of security we do not

447
00:16:41,759 --> 00:16:43,600
really want to compute them the only

448
00:16:43,600 --> 00:16:46,720
thing we need is their existence

449
00:16:46,720 --> 00:16:48,639
previously i just showed you the only

450
00:16:48,639 --> 00:16:50,240
function construction to have a

451
00:16:50,240 --> 00:16:52,240
proof-based line function we also need a

452
00:16:52,240 --> 00:16:54,079
zero-knowledge protocol computing this

453
00:16:54,079 --> 00:16:56,240
function we just defined

454
00:16:56,240 --> 00:16:58,720
in this slide i will first give you an

455
00:16:58,720 --> 00:17:01,600
interactive proof protocol and later i

456
00:17:01,600 --> 00:17:03,040
will show you how to add zero knowledge

457
00:17:03,040 --> 00:17:05,280
property if you stare at this

458
00:17:05,280 --> 00:17:07,760
construction for a second it is not hard

459
00:17:07,760 --> 00:17:09,359
to see how can we have an interactive

460
00:17:09,359 --> 00:17:11,119
protocol computing it

461
00:17:11,119 --> 00:17:12,720
so first

462
00:17:12,720 --> 00:17:14,640
the sender pass the x into the

463
00:17:14,640 --> 00:17:16,959
corresponding x and the beta part then

464
00:17:16,959 --> 00:17:18,959
it makes oracle queries to learn one

465
00:17:18,959 --> 00:17:21,599
through and case send one through one to

466
00:17:21,599 --> 00:17:23,599
the receiver here since we also have

467
00:17:23,599 --> 00:17:25,199
additional beta part the sender will

468
00:17:25,199 --> 00:17:27,679
also send the data the third step is to

469
00:17:27,679 --> 00:17:29,600
compute this random subset in the

470
00:17:29,600 --> 00:17:31,760
protocol we simply ask the receiver to

471
00:17:31,760 --> 00:17:34,000
send the set r as challenge

472
00:17:34,000 --> 00:17:37,200
at this moment the sender knows both x

473
00:17:37,200 --> 00:17:40,559
and r so he can perform the step 4 as in

474
00:17:40,559 --> 00:17:42,880
the description of the function

475
00:17:42,880 --> 00:17:45,840
now the sender simply sends these values

476
00:17:45,840 --> 00:17:47,600
to the receiver

477
00:17:47,600 --> 00:17:49,280
at the end of the protocol you can

478
00:17:49,280 --> 00:17:51,919
verify that the receiver can output this

479
00:17:51,919 --> 00:17:54,640
value value and the sender simply output

480
00:17:54,640 --> 00:17:56,960
his input x and the r part it learns

481
00:17:56,960 --> 00:17:58,400
from the receiver

482
00:17:58,400 --> 00:18:00,400
now the only thing left is that we want

483
00:18:00,400 --> 00:18:02,799
to make this protocol zero knowledge

484
00:18:02,799 --> 00:18:05,039
up to now this protocol is only a simple

485
00:18:05,039 --> 00:18:07,200
cut and choose phone call together with

486
00:18:07,200 --> 00:18:09,840
our pre-image editing as you can see

487
00:18:09,840 --> 00:18:12,240
this custom truth step does not review

488
00:18:12,240 --> 00:18:14,320
any extra information regarding the

489
00:18:14,320 --> 00:18:16,720
pre-image of the one function so the

490
00:18:16,720 --> 00:18:18,720
only information we need to head to

491
00:18:18,720 --> 00:18:21,360
achieve zk is actually the fact whether

492
00:18:21,360 --> 00:18:23,600
we are in the item case or a non-editing

493
00:18:23,600 --> 00:18:25,760
case to do that we will use the black

494
00:18:25,760 --> 00:18:27,600
box commit and proof

495
00:18:27,600 --> 00:18:30,000
recall that to see if we are in the

496
00:18:30,000 --> 00:18:32,480
editing case and non-ideal case

497
00:18:32,480 --> 00:18:34,720
we need to use both the beta part and

498
00:18:34,720 --> 00:18:36,080
the y value

499
00:18:36,080 --> 00:18:38,160
and this information is embedded in the

500
00:18:38,160 --> 00:18:40,080
first round message to head this

501
00:18:40,080 --> 00:18:42,240
information instead of sending the first

502
00:18:42,240 --> 00:18:44,400
round message in plain

503
00:18:44,400 --> 00:18:47,200
we use the commit stage of the blackbox

504
00:18:47,200 --> 00:18:48,559
camera proof

505
00:18:48,559 --> 00:18:50,880
in the third step the receiver can still

506
00:18:50,880 --> 00:18:53,120
check the consistency between the

507
00:18:53,120 --> 00:18:55,360
pre-image and image on the partitions

508
00:18:55,360 --> 00:18:57,360
specified by the set r

509
00:18:57,360 --> 00:19:00,320
however there is no guarantee that the y

510
00:19:00,320 --> 00:19:03,280
values are indeed the y values committed

511
00:19:03,280 --> 00:19:05,200
at the beginning so we will ask the

512
00:19:05,200 --> 00:19:07,440
sender to give a zero large proof using

513
00:19:07,440 --> 00:19:09,760
the proof stage of the blubox camison

514
00:19:09,760 --> 00:19:11,120
proof protocol

515
00:19:11,120 --> 00:19:13,679
importantly this bb proof stage only

516
00:19:13,679 --> 00:19:17,120
proves statements about about y and s it

517
00:19:17,120 --> 00:19:18,960
has nothing to do with the relation

518
00:19:18,960 --> 00:19:21,679
between pre-immediate x and y

519
00:19:21,679 --> 00:19:24,799
actually the consistency between x and y

520
00:19:24,799 --> 00:19:27,200
pairs is checked by the receiver offset

521
00:19:27,200 --> 00:19:29,039
of this bb proof

522
00:19:29,039 --> 00:19:31,280
therefore this bb improved stage has

523
00:19:31,280 --> 00:19:33,760
nothing to do with the oracle y function

524
00:19:33,760 --> 00:19:35,840
small f

525
00:19:35,840 --> 00:19:37,919
now let me briefly summarize our

526
00:19:37,919 --> 00:19:39,440
construction of the proof based one

527
00:19:39,440 --> 00:19:40,480
function

528
00:19:40,480 --> 00:19:42,559
we start with a simple cut and choose

529
00:19:42,559 --> 00:19:44,640
protocol this protocol is not good

530
00:19:44,640 --> 00:19:47,039
enough because we wanted to guarantee

531
00:19:47,039 --> 00:19:49,520
the existence of a pre-image however if

532
00:19:49,520 --> 00:19:51,200
we are using this protocol there could

533
00:19:51,200 --> 00:19:53,360
still be a delta bet fraction in the

534
00:19:53,360 --> 00:19:56,559
pre-image so our idea is to try to embed

535
00:19:56,559 --> 00:19:58,799
the delta bar into the domain of the run

536
00:19:58,799 --> 00:20:01,440
function to do that we introduce a new

537
00:20:01,440 --> 00:20:03,679
idea called pre-image editing

538
00:20:03,679 --> 00:20:06,320
the editing case will not happen in the

539
00:20:06,320 --> 00:20:08,320
real execution of the protocol that's

540
00:20:08,320 --> 00:20:10,480
because there is a r part controlled by

541
00:20:10,480 --> 00:20:12,240
the verifier if the verifier picked the

542
00:20:12,240 --> 00:20:14,640
r part randomly the editing case won't

543
00:20:14,640 --> 00:20:16,000
happen except for the negative

544
00:20:16,000 --> 00:20:18,480
probability but now the security

545
00:20:18,480 --> 00:20:20,480
reduction can make use of this editing

546
00:20:20,480 --> 00:20:21,360
case

547
00:20:21,360 --> 00:20:24,559
intuitively it plants the k values from

548
00:20:24,559 --> 00:20:28,080
the output y into the pre-image x since

549
00:20:28,080 --> 00:20:30,720
there are at most k bad positions we can

550
00:20:30,720 --> 00:20:33,440
effectively correct all of them

551
00:20:33,440 --> 00:20:36,799
to add zq property we rely on blackbox

552
00:20:36,799 --> 00:20:39,200
commit and proof it is important to

553
00:20:39,200 --> 00:20:41,360
notice that this proof stage does not

554
00:20:41,360 --> 00:20:44,880
make use of the code of oracle small f

555
00:20:44,880 --> 00:20:46,720
now we've shown how to construct proof

556
00:20:46,720 --> 00:20:48,640
based on function

557
00:20:48,640 --> 00:20:50,720
a proof-based prg can be built in a

558
00:20:50,720 --> 00:20:53,280
similar way we will not talk about it as

559
00:20:53,280 --> 00:20:55,039
mentioned at the beginning of this talk

560
00:20:55,039 --> 00:20:56,960
we also want to construct proof-based

561
00:20:56,960 --> 00:20:59,760
hash functions however it turns out that

562
00:20:59,760 --> 00:21:02,400
this construction requires new idea let

563
00:21:02,400 --> 00:21:04,400
me explain the reason why our technique

564
00:21:04,400 --> 00:21:06,000
for proof based one function doesn't

565
00:21:06,000 --> 00:21:07,440
work directly

566
00:21:07,440 --> 00:21:09,200
recall that in the proof phase one

567
00:21:09,200 --> 00:21:11,120
function construction we introduced this

568
00:21:11,120 --> 00:21:12,960
pre-image editing idea

569
00:21:12,960 --> 00:21:14,960
it essentially introduced multiple

570
00:21:14,960 --> 00:21:16,880
images for a single y

571
00:21:16,880 --> 00:21:18,640
this actually values the collision

572
00:21:18,640 --> 00:21:20,640
resistance requirement if you want a

573
00:21:20,640 --> 00:21:23,919
crhf to see why first notice that the

574
00:21:23,919 --> 00:21:25,760
protocol is fine because in the

575
00:21:25,760 --> 00:21:27,919
execution of the protocol there is a r

576
00:21:27,919 --> 00:21:29,600
part controlled by the receiver if the

577
00:21:29,600 --> 00:21:31,440
receiver picks this r part uniformly

578
00:21:31,440 --> 00:21:33,760
random the editing case will not be

579
00:21:33,760 --> 00:21:34,960
triggered except for negative

580
00:21:34,960 --> 00:21:37,520
probability so a malicious sender cannot

581
00:21:37,520 --> 00:21:40,640
make use of this however remember that

582
00:21:40,640 --> 00:21:42,799
our proof-based notion also have a

583
00:21:42,799 --> 00:21:44,559
construction of the function the

584
00:21:44,559 --> 00:21:46,559
function is where the problem headed

585
00:21:46,559 --> 00:21:49,360
more specifically a ppv algorithm can

586
00:21:49,360 --> 00:21:52,159
easily construct two inputs both of them

587
00:21:52,159 --> 00:21:54,480
trigger the editing condition and hash

588
00:21:54,480 --> 00:21:56,880
to the same value and address can't do

589
00:21:56,880 --> 00:21:58,960
this because when evaluating the

590
00:21:58,960 --> 00:22:01,360
function there's no receiver the single

591
00:22:01,360 --> 00:22:03,280
adversary can't control the whole part

592
00:22:03,280 --> 00:22:05,600
of the function to solve this problem we

593
00:22:05,600 --> 00:22:07,760
will embed a random string z in a

594
00:22:07,760 --> 00:22:09,840
published hashing key and we change the

595
00:22:09,840 --> 00:22:12,080
condition for either case we add one

596
00:22:12,080 --> 00:22:13,919
more condition this condition says you

597
00:22:13,919 --> 00:22:16,000
can trigger the editing case only if you

598
00:22:16,000 --> 00:22:18,320
know a pre-image of d under the oracle

599
00:22:18,320 --> 00:22:21,600
hash function as we know a ppt cannot

600
00:22:21,600 --> 00:22:24,000
figure out the pre-image of z therefore

601
00:22:24,000 --> 00:22:26,159
he cannot make use of the editing case

602
00:22:26,159 --> 00:22:28,799
however our security proof of songs can

603
00:22:28,799 --> 00:22:30,960
always make use of this editing case

604
00:22:30,960 --> 00:22:32,960
this is how we create the asymmetry

605
00:22:32,960 --> 00:22:35,280
between the address 3 and our security

606
00:22:35,280 --> 00:22:36,159
lecture

607
00:22:36,159 --> 00:22:38,320
unfortunately i cannot talk more about

608
00:22:38,320 --> 00:22:40,960
our construction for hash function if

609
00:22:40,960 --> 00:22:42,799
you are interested please refer to our

610
00:22:42,799 --> 00:22:44,159
paper

611
00:22:44,159 --> 00:22:46,159
let me give a summary of this talk in

612
00:22:46,159 --> 00:22:48,720
this work we generalize the notion of

613
00:22:48,720 --> 00:22:50,320
functional black box your knowledge

614
00:22:50,320 --> 00:22:52,400
proposed by razorlak we show that

615
00:22:52,400 --> 00:22:54,320
drought's impossibility result still

616
00:22:54,320 --> 00:22:56,240
holds for our generalized notion

617
00:22:56,240 --> 00:22:58,080
specifically we show that black box

618
00:22:58,080 --> 00:23:00,480
proof based prd is impossible

619
00:23:00,480 --> 00:23:03,200
next we relax the prefix notion by

620
00:23:03,200 --> 00:23:05,360
splitting the input and let the receiver

621
00:23:05,360 --> 00:23:07,440
control the r part of it then we show

622
00:23:07,440 --> 00:23:09,280
that for this split input proof based

623
00:23:09,280 --> 00:23:12,480
notion one function prg and the creation

624
00:23:12,480 --> 00:23:15,440
recession hash functions become possible

625
00:23:15,440 --> 00:23:17,280
our work actually raises more

626
00:23:17,280 --> 00:23:19,200
interesting questions as we mentioned

627
00:23:19,200 --> 00:23:20,960
before we are only able to show the

628
00:23:20,960 --> 00:23:23,840
impossibility of proof-based prg i mean

629
00:23:23,840 --> 00:23:26,000
without splitting the input we take this

630
00:23:26,000 --> 00:23:27,280
as a strong absence for the

631
00:23:27,280 --> 00:23:29,200
impossibility for proof based online

632
00:23:29,200 --> 00:23:31,360
function but it is interesting to see an

633
00:23:31,360 --> 00:23:33,679
actual proof for this impossibility

634
00:23:33,679 --> 00:23:35,760
also this work inspires us to ask a more

635
00:23:35,760 --> 00:23:38,000
general question that is can we give

636
00:23:38,000 --> 00:23:40,320
black box zero proof for any polynomial

637
00:23:40,320 --> 00:23:41,600
cell circuits

638
00:23:41,600 --> 00:23:44,400
more concretely consider this example

639
00:23:44,400 --> 00:23:47,120
let's say we have a circuit c it can be

640
00:23:47,120 --> 00:23:50,000
decomposed into three parts the input x

641
00:23:50,000 --> 00:23:52,880
will first go through a subcircuit c one

642
00:23:52,880 --> 00:23:55,679
that is crypto free and then a one-way

643
00:23:55,679 --> 00:23:58,080
function gate is evaluated on the output

644
00:23:58,080 --> 00:24:00,720
of c1 the output of the line function

645
00:24:00,720 --> 00:24:02,799
will go through another crypto free

646
00:24:02,799 --> 00:24:04,960
sub-circuit c2 to give us the final

647
00:24:04,960 --> 00:24:06,159
output y

648
00:24:06,159 --> 00:24:08,080
it will be interesting if we can have a

649
00:24:08,080 --> 00:24:09,200
zero knowledge protocol for the

650
00:24:09,200 --> 00:24:11,200
certifiability of this circuit while

651
00:24:11,200 --> 00:24:13,200
making only black box access to one

652
00:24:13,200 --> 00:24:15,279
function just like impossibility result

653
00:24:15,279 --> 00:24:17,279
says this is impossible that's because

654
00:24:17,279 --> 00:24:19,200
we cannot even have a black box zero

655
00:24:19,200 --> 00:24:21,360
knowledge for this one function gate let

656
00:24:21,360 --> 00:24:23,279
alone the whole circuit but our

657
00:24:23,279 --> 00:24:25,440
proof-based notion gave us some hope the

658
00:24:25,440 --> 00:24:28,000
idea here is to replace the one-way

659
00:24:28,000 --> 00:24:30,240
function by its proof-based alternative

660
00:24:30,240 --> 00:24:32,559
the result in our work gives a black box

661
00:24:32,559 --> 00:24:35,039
zero noise proof for this crypto gate it

662
00:24:35,039 --> 00:24:36,960
will be very interesting to extend our

663
00:24:36,960 --> 00:24:39,279
idea to eventually give a blah blah zero

664
00:24:39,279 --> 00:24:42,640
knowledge proof for the whole circuit

665
00:24:42,640 --> 00:24:44,559
now we are at the end of this talk

666
00:24:44,559 --> 00:24:45,919
thanks for your attention and more

667
00:24:45,919 --> 00:24:47,600
details can be found in the full version

668
00:24:47,600 --> 00:24:51,240
of this paper here

