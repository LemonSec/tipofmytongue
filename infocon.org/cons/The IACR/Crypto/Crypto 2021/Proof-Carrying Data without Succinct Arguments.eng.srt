1
00:00:00,080 --> 00:00:01,839
hello today i'll tell you about proof

2
00:00:01,839 --> 00:00:03,919
carrying data without succinct arguments

3
00:00:03,919 --> 00:00:05,839
my name is binig pins and this is joint

4
00:00:05,839 --> 00:00:07,600
work with alessandro casa cartouche

5
00:00:07,600 --> 00:00:11,360
micia william lin and nick spooner

6
00:00:11,360 --> 00:00:14,920
so consider doing a long t-step

7
00:00:14,920 --> 00:00:17,760
computation so we the computation

8
00:00:17,760 --> 00:00:20,720
evolves in the following way we go from

9
00:00:20,720 --> 00:00:23,720
step zi to step zi plus one

10
00:00:23,720 --> 00:00:26,000
non-deterministically by applying a

11
00:00:26,000 --> 00:00:28,720
transition function f to z i and an

12
00:00:28,720 --> 00:00:31,039
optional witness wi

13
00:00:31,039 --> 00:00:32,719
and say we want to outsource this

14
00:00:32,719 --> 00:00:34,960
computation to an untrusted server and

15
00:00:34,960 --> 00:00:37,520
we want that the server provides a proof

16
00:00:37,520 --> 00:00:39,600
to us that it did the computation

17
00:00:39,600 --> 00:00:41,760
correct well there's multiple ways to do

18
00:00:41,760 --> 00:00:44,320
this one is we ask the server to just do

19
00:00:44,320 --> 00:00:46,800
the computation and afterwards provide

20
00:00:46,800 --> 00:00:49,039
one monolithic proof that it did the

21
00:00:49,039 --> 00:00:51,199
entire computation correctly

22
00:00:51,199 --> 00:00:53,440
this works but it has a few issues

23
00:00:53,440 --> 00:00:55,520
namely that it would require the prover

24
00:00:55,520 --> 00:00:58,239
to store all of the intermediate states

25
00:00:58,239 --> 00:01:01,359
that it has when doing the computation

26
00:01:01,359 --> 00:01:04,400
in its memory in order to perform the

27
00:01:04,400 --> 00:01:05,519
proof

28
00:01:05,519 --> 00:01:07,200
and the second issue is that if we did

29
00:01:07,200 --> 00:01:09,520
this for t steps and then say we evolved

30
00:01:09,520 --> 00:01:11,840
the computation for one more step well

31
00:01:11,840 --> 00:01:13,760
then this would require recomputing the

32
00:01:13,760 --> 00:01:15,600
entire proof

33
00:01:15,600 --> 00:01:18,159
the second option resolves all of these

34
00:01:18,159 --> 00:01:20,240
issues and it's called incrementally

35
00:01:20,240 --> 00:01:23,439
verifiable computation or ivc for short

36
00:01:23,439 --> 00:01:25,680
and the idea here is to interleave the

37
00:01:25,680 --> 00:01:28,479
evaluation with the computation of the

38
00:01:28,479 --> 00:01:31,280
proof so what we'll do is at every step

39
00:01:31,280 --> 00:01:33,920
that we still have zi and wi but we'll

40
00:01:33,920 --> 00:01:37,040
also have a proof pi which asserts that

41
00:01:37,040 --> 00:01:39,600
all of the previous computations so the

42
00:01:39,600 --> 00:01:41,200
first i steps of the computation we're

43
00:01:41,200 --> 00:01:44,399
done correctly and then the eivc prover

44
00:01:44,399 --> 00:01:47,520
pef here can advance the computation so

45
00:01:47,520 --> 00:01:50,079
compute z i plus 1 and additionally

46
00:01:50,079 --> 00:01:52,640
compute the next proof pi i plus 1 which

47
00:01:52,640 --> 00:01:54,240
now says that the computation was

48
00:01:54,240 --> 00:01:57,119
correct for the first i plus 1 steps and

49
00:01:57,119 --> 00:02:00,240
ivc is really for computations over path

50
00:02:00,240 --> 00:02:04,159
graphs but this has been generalized to

51
00:02:04,159 --> 00:02:06,399
more generic tags and we call this proof

52
00:02:06,399 --> 00:02:09,199
carrying data and ivc and pcd they have

53
00:02:09,199 --> 00:02:11,520
tons of applications some of them are

54
00:02:11,520 --> 00:02:14,560
around long everlasting computations

55
00:02:14,560 --> 00:02:17,280
such as succinct blockchains or verify

56
00:02:17,280 --> 00:02:19,599
delay functions there's also others that

57
00:02:19,599 --> 00:02:22,160
are more about multiple groupers working

58
00:02:22,160 --> 00:02:23,840
together to combine

59
00:02:23,840 --> 00:02:26,000
to create one proof together so zk

60
00:02:26,000 --> 00:02:28,400
cluster computing or verifiable image

61
00:02:28,400 --> 00:02:30,720
editing

62
00:02:30,720 --> 00:02:32,560
so the interesting question though is

63
00:02:32,560 --> 00:02:34,400
how do we actually construct ivc it's

64
00:02:34,400 --> 00:02:36,800
clearly a very powerful primitive and

65
00:02:36,800 --> 00:02:39,040
has a lot of applications well it turns

66
00:02:39,040 --> 00:02:40,959
out historically the way to construct it

67
00:02:40,959 --> 00:02:42,879
was from another very powerful primitive

68
00:02:42,879 --> 00:02:45,760
namely snarks succinct non-interactive

69
00:02:45,760 --> 00:02:47,599
arguments of knowledge

70
00:02:47,599 --> 00:02:50,160
and historically it was shown that you

71
00:02:50,160 --> 00:02:51,120
can

72
00:02:51,120 --> 00:02:52,959
construct ibc from snarks that have

73
00:02:52,959 --> 00:02:54,400
really efficient

74
00:02:54,400 --> 00:02:56,000
succinct or poly logarithmic

75
00:02:56,000 --> 00:02:58,159
verification time and this can be

76
00:02:58,159 --> 00:02:59,519
efficiently realized using

77
00:02:59,519 --> 00:03:01,760
pre-processing snarks and cycles of

78
00:03:01,760 --> 00:03:02,840
elliptic

79
00:03:02,840 --> 00:03:05,519
curves then recently there have been

80
00:03:05,519 --> 00:03:06,400
more

81
00:03:06,400 --> 00:03:07,920
efforts in order to relax the

82
00:03:07,920 --> 00:03:10,239
requirement on the snark so for example

83
00:03:10,239 --> 00:03:12,720
cost 20 showed that it actually suffices

84
00:03:12,720 --> 00:03:14,959
to have a snark that has just sublinear

85
00:03:14,959 --> 00:03:16,879
verification time so for example square

86
00:03:16,879 --> 00:03:18,800
root verification

87
00:03:18,800 --> 00:03:22,640
and then uh most recently bcms 20 showed

88
00:03:22,640 --> 00:03:24,959
that it is actually okay to have a snark

89
00:03:24,959 --> 00:03:26,959
that does not have linear

90
00:03:26,959 --> 00:03:29,440
sub linear verification time but instead

91
00:03:29,440 --> 00:03:32,000
it has something called an accumulation

92
00:03:32,000 --> 00:03:34,159
scheme a sublinear accumulation scheme

93
00:03:34,159 --> 00:03:36,799
associated with it and this builds on

94
00:03:36,799 --> 00:03:39,519
ideas originally proposed in halo

95
00:03:39,519 --> 00:03:42,400
and but all of this leads to really a

96
00:03:42,400 --> 00:03:44,959
natural and important question which is

97
00:03:44,959 --> 00:03:47,360
do we even require snarks in order to

98
00:03:47,360 --> 00:03:50,000
create ivc do we require the

99
00:03:50,000 --> 00:03:51,840
succinctness of the proofs the proofs

100
00:03:51,840 --> 00:03:55,439
are being short in order to

101
00:03:55,439 --> 00:03:56,799
create ivc

102
00:03:56,799 --> 00:03:58,640
and in this work we'll show that the

103
00:03:58,640 --> 00:04:01,120
answer is actually no we can construct

104
00:04:01,120 --> 00:04:04,239
ivc from something that is qualitatively

105
00:04:04,239 --> 00:04:06,879
simpler than a snark

106
00:04:06,879 --> 00:04:09,760
so more formally we say we show we

107
00:04:09,760 --> 00:04:11,760
introduce something called a split

108
00:04:11,760 --> 00:04:14,959
accumulation scheme and we'll show that

109
00:04:14,959 --> 00:04:17,358
given an arc so this is a

110
00:04:17,358 --> 00:04:19,918
non-interactive argument of knowledge

111
00:04:19,918 --> 00:04:22,720
with such a split accumulation scheme

112
00:04:22,720 --> 00:04:26,000
we can build ivc and pcd from it and

113
00:04:26,000 --> 00:04:27,919
it's an arc it's not a snark because

114
00:04:27,919 --> 00:04:30,880
there's no succinct requirement on the

115
00:04:30,880 --> 00:04:33,360
dark itself there's a small asterisk

116
00:04:33,360 --> 00:04:35,600
with it that we do require that the

117
00:04:35,600 --> 00:04:37,840
proofs of the accumulations keep

118
00:04:37,840 --> 00:04:39,360
if the accumulation scheme involves some

119
00:04:39,360 --> 00:04:41,280
proofs then we require that those are

120
00:04:41,280 --> 00:04:44,560
succinct but not the narc itself

121
00:04:44,560 --> 00:04:47,600
and this isn't just you know sort of

122
00:04:47,600 --> 00:04:49,600
using the old tricks and this is

123
00:04:49,600 --> 00:04:51,680
actually something new and we show this

124
00:04:51,680 --> 00:04:54,880
by uh in theorem 2 where we say there

125
00:04:54,880 --> 00:04:56,880
exists an arc that has really exciting

126
00:04:56,880 --> 00:04:59,520
properties something properties that we

127
00:04:59,520 --> 00:05:01,840
hadn't been able to achieve from a snark

128
00:05:01,840 --> 00:05:04,240
so this narc is secure in the random

129
00:05:04,240 --> 00:05:06,000
oracle model under just the discrete

130
00:05:06,000 --> 00:05:07,600
logarithm assumption

131
00:05:07,600 --> 00:05:10,960
and it has a split accumulation scheme

132
00:05:10,960 --> 00:05:13,680
and and the accumulation verifier is

133
00:05:13,680 --> 00:05:15,520
really efficient it only does a constant

134
00:05:15,520 --> 00:05:16,560
number

135
00:05:16,560 --> 00:05:19,199
of operations and if we compare this to

136
00:05:19,199 --> 00:05:22,320
prior work then the best we could do

137
00:05:22,320 --> 00:05:24,560
here for the accumulation verifier is a

138
00:05:24,560 --> 00:05:29,199
logarithmic number of operations

139
00:05:29,360 --> 00:05:31,759
and there is a small gap between these

140
00:05:31,759 --> 00:05:34,479
two theorems so theorem one requires a

141
00:05:34,479 --> 00:05:35,600
narc

142
00:05:35,600 --> 00:05:36,960
and an accumulation scheme that is

143
00:05:36,960 --> 00:05:39,039
secure in the standard mode whereas this

144
00:05:39,039 --> 00:05:40,720
theorem 2 is

145
00:05:40,720 --> 00:05:42,560
in the random oracle model and we can

146
00:05:42,560 --> 00:05:44,479
prove it to be secure in the random arca

147
00:05:44,479 --> 00:05:45,520
mall

148
00:05:45,520 --> 00:05:48,560
so we need to do a small heuristic jump

149
00:05:48,560 --> 00:05:50,880
here between theorem 2 and theorem 1

150
00:05:50,880 --> 00:05:52,720
saying that our

151
00:05:52,720 --> 00:05:54,639
constructions are still secure if we

152
00:05:54,639 --> 00:05:57,600
replace the random oracle with a secure

153
00:05:57,600 --> 00:06:00,479
cryptographic hash function

154
00:06:00,479 --> 00:06:01,919
i also want to point out that split

155
00:06:01,919 --> 00:06:03,360
accumulation schemes are about

156
00:06:03,360 --> 00:06:05,360
accumulating verification and they have

157
00:06:05,360 --> 00:06:08,880
nothing to do with static generators

158
00:06:08,880 --> 00:06:10,479
our scheme has really interesting

159
00:06:10,479 --> 00:06:12,800
asymptotics it has a very very small

160
00:06:12,800 --> 00:06:15,120
recursive circuit and it

161
00:06:15,120 --> 00:06:16,639
doesn't require a trusted setup the

162
00:06:16,639 --> 00:06:19,680
setup is transparent and additionally um

163
00:06:19,680 --> 00:06:21,919
all of these recursive circuits kind of

164
00:06:21,919 --> 00:06:24,400
constructions they require cycles of

165
00:06:24,400 --> 00:06:26,880
curves so we need two elliptic curves

166
00:06:26,880 --> 00:06:29,039
that are kind of cycles of each other in

167
00:06:29,039 --> 00:06:31,680
order to implement this efficiently and

168
00:06:31,680 --> 00:06:34,000
historically um in the older

169
00:06:34,000 --> 00:06:36,240
construction you needed cycles that are

170
00:06:36,240 --> 00:06:38,160
pairing both where both curves have a

171
00:06:38,160 --> 00:06:41,280
pairing or where there's um some fft

172
00:06:41,280 --> 00:06:43,280
friendliness and this makes it actually

173
00:06:43,280 --> 00:06:45,600
very hard to find proper cycles with

174
00:06:45,600 --> 00:06:48,160
good properties and for us it actually

175
00:06:48,160 --> 00:06:51,199
suffices to find any sort of cycle that

176
00:06:51,199 --> 00:06:53,680
has um where we just believe that the

177
00:06:53,680 --> 00:06:55,599
discrete logarithm is secure in both of

178
00:06:55,599 --> 00:06:57,280
the groups or in all of the groups on

179
00:06:57,280 --> 00:07:00,639
the cycle and this turns out is much

180
00:07:00,639 --> 00:07:04,000
easier to find than the other two

181
00:07:04,000 --> 00:07:05,199
but the

182
00:07:05,199 --> 00:07:06,880
attractive asymptotics led us to the

183
00:07:06,880 --> 00:07:09,360
question of uh whether this is also

184
00:07:09,360 --> 00:07:11,440
concretely efficient and in order to

185
00:07:11,440 --> 00:07:15,680
test this we implement it and uh the um

186
00:07:15,680 --> 00:07:18,160
accumulation scheme and the pcd

187
00:07:18,160 --> 00:07:20,800
construction in the artworks ecosystem

188
00:07:20,800 --> 00:07:22,400
so we added two libraries arc

189
00:07:22,400 --> 00:07:24,479
accumulation and rtcd

190
00:07:24,479 --> 00:07:27,199
and also implementing generic frameworks

191
00:07:27,199 --> 00:07:29,520
and some of the older schemes

192
00:07:29,520 --> 00:07:31,680
and they are of course available open

193
00:07:31,680 --> 00:07:34,319
source and freely available and play

194
00:07:34,319 --> 00:07:36,000
interplay nicely with all of the other

195
00:07:36,000 --> 00:07:37,440
great libraries in the artworks

196
00:07:37,440 --> 00:07:39,759
ecosystem

197
00:07:39,759 --> 00:07:41,440
we then measured the performance of our

198
00:07:41,440 --> 00:07:43,520
scheme and you can see here at a very

199
00:07:43,520 --> 00:07:45,039
high level that

200
00:07:45,039 --> 00:07:47,919
our scheme does about five times better

201
00:07:47,919 --> 00:07:49,360
compared to the previous scheme we

202
00:07:49,360 --> 00:07:51,360
measured this in terms of number of

203
00:07:51,360 --> 00:07:54,080
constraints in the recursive circuit and

204
00:07:54,080 --> 00:07:55,919
this turns out to be the key performance

205
00:07:55,919 --> 00:07:58,319
metric and the absolute numbers are

206
00:07:58,319 --> 00:08:00,879
already really good we're about a 50 000

207
00:08:00,879 --> 00:08:03,039
uh cycle gates

208
00:08:03,039 --> 00:08:04,639
and but you know there might be

209
00:08:04,639 --> 00:08:06,479
optimizations that you can apply but

210
00:08:06,479 --> 00:08:07,840
they wouldn't

211
00:08:07,840 --> 00:08:09,520
we we assume that they wouldn't change

212
00:08:09,520 --> 00:08:11,440
the comparison because

213
00:08:11,440 --> 00:08:13,199
everything is implemented using the same

214
00:08:13,199 --> 00:08:14,639
library so the

215
00:08:14,639 --> 00:08:16,240
the optimizations which is move

216
00:08:16,240 --> 00:08:18,080
everything down there's one small

217
00:08:18,080 --> 00:08:20,560
optimization that for the specific case

218
00:08:20,560 --> 00:08:22,960
of ivc this is we implemented it

219
00:08:22,960 --> 00:08:25,280
generically for pcd but for the specific

220
00:08:25,280 --> 00:08:28,479
case of ibc um our scheme can do even

221
00:08:28,479 --> 00:08:30,000
better or we have a

222
00:08:30,000 --> 00:08:31,520
specialized construction that can do

223
00:08:31,520 --> 00:08:33,200
even better but we did not implement

224
00:08:33,200 --> 00:08:34,799
this

225
00:08:34,799 --> 00:08:35,599
so

226
00:08:35,599 --> 00:08:37,360
let's dive in or let's let's look at

227
00:08:37,360 --> 00:08:39,279
what the spit accumulation actually is

228
00:08:39,279 --> 00:08:41,919
and how we get pcd from it and but first

229
00:08:41,919 --> 00:08:44,640
a small background on on ivc

230
00:08:44,640 --> 00:08:48,160
so in ivc we have an ivc prover which

231
00:08:48,160 --> 00:08:50,560
performs a computation and

232
00:08:50,560 --> 00:08:53,519
so advances the computation from z and w

233
00:08:53,519 --> 00:08:56,240
to z prime and it also takes as input

234
00:08:56,240 --> 00:08:59,279
the proof and advances it to a new proof

235
00:08:59,279 --> 00:09:00,480
pi prime

236
00:09:00,480 --> 00:09:02,240
and it can do this over and over again

237
00:09:02,240 --> 00:09:03,839
so you can feed the new state of the

238
00:09:03,839 --> 00:09:06,080
computation and the the new proof into

239
00:09:06,080 --> 00:09:10,080
the ivc prover again and the snark the

240
00:09:10,080 --> 00:09:12,320
ivc verifier simply takes us input the

241
00:09:12,320 --> 00:09:14,240
current state of the computation and the

242
00:09:14,240 --> 00:09:17,839
proof at any point and either accepts or

243
00:09:17,839 --> 00:09:19,920
rejects and we have adversarial

244
00:09:19,920 --> 00:09:23,600
completeness saying that if the verifier

245
00:09:23,600 --> 00:09:24,480
if

246
00:09:24,480 --> 00:09:26,240
for any proof even if it was

247
00:09:26,240 --> 00:09:28,160
adversarially uh

248
00:09:28,160 --> 00:09:30,640
created an honest proofer can advance

249
00:09:30,640 --> 00:09:33,120
the computation on it and proof of

250
00:09:33,120 --> 00:09:36,080
knowledge says that um

251
00:09:36,080 --> 00:09:39,040
if we have a convincing prover so if you

252
00:09:39,040 --> 00:09:40,720
can convince the verifier then it is

253
00:09:40,720 --> 00:09:42,000
possible to

254
00:09:42,000 --> 00:09:43,760
extract the entire transcript of the

255
00:09:43,760 --> 00:09:47,279
computation um from these these valid

256
00:09:47,279 --> 00:09:49,440
proofs

257
00:09:49,440 --> 00:09:51,519
a key efficiency requirement is that the

258
00:09:51,519 --> 00:09:54,720
size of the proof does not grow with

259
00:09:54,720 --> 00:09:56,800
any computation step and this is

260
00:09:56,800 --> 00:09:59,519
important because it implies that the

261
00:09:59,519 --> 00:10:01,040
size of the proof is actually

262
00:10:01,040 --> 00:10:02,800
independent of the length of the

263
00:10:02,800 --> 00:10:05,120
computation

264
00:10:05,120 --> 00:10:08,480
i also want to very quickly um define

265
00:10:08,480 --> 00:10:10,800
narcs so we have nargs and z knocks and

266
00:10:10,800 --> 00:10:11,920
we define them for circuit

267
00:10:11,920 --> 00:10:13,839
satisfiability so we have a circuit that

268
00:10:13,839 --> 00:10:16,160
takes in a public input x and some

269
00:10:16,160 --> 00:10:19,279
private inputs w and we say it accepts

270
00:10:19,279 --> 00:10:20,320
if

271
00:10:20,320 --> 00:10:22,320
the circuit evaluates to one on x comma

272
00:10:22,320 --> 00:10:23,360
w

273
00:10:23,360 --> 00:10:24,399
and an

274
00:10:24,399 --> 00:10:26,959
arc is simply a protocol where the

275
00:10:26,959 --> 00:10:28,720
prover sends a proof

276
00:10:28,720 --> 00:10:31,680
that um convinces the verifier that

277
00:10:31,680 --> 00:10:33,839
these private inputs exist so the

278
00:10:33,839 --> 00:10:36,640
verifier does not have in access to them

279
00:10:36,640 --> 00:10:38,640
and it's a non-interactive protocol so

280
00:10:38,640 --> 00:10:40,399
there's only a single message being sent

281
00:10:40,399 --> 00:10:43,040
from the proven the verifier and we you

282
00:10:43,040 --> 00:10:46,320
can define completeness and and proof of

283
00:10:46,320 --> 00:10:48,000
knowledge property so from the proof you

284
00:10:48,000 --> 00:10:49,200
should be able to extract the

285
00:10:49,200 --> 00:10:50,880
willingness

286
00:10:50,880 --> 00:10:53,600
additionally um if these proofs are

287
00:10:53,600 --> 00:10:55,519
sublinear so they're really small then

288
00:10:55,519 --> 00:10:58,160
we call this a snark um

289
00:10:58,160 --> 00:11:00,320
but they don't necessarily have to be

290
00:11:00,320 --> 00:11:02,640
and if it's your knowledge then we can

291
00:11:02,640 --> 00:11:04,880
call this a ck narc or

292
00:11:04,880 --> 00:11:07,839
an is a k okay

293
00:11:08,399 --> 00:11:09,279
so

294
00:11:09,279 --> 00:11:12,079
let's look at what atomic accumulation

295
00:11:12,079 --> 00:11:14,880
is so this was a something that was

296
00:11:14,880 --> 00:11:17,519
introduced in bcms 20

297
00:11:17,519 --> 00:11:19,600
and the idea here is that i can

298
00:11:19,600 --> 00:11:21,920
accumulate a bunch of predicate checks

299
00:11:21,920 --> 00:11:23,920
so i have a set of ft inputs to a

300
00:11:23,920 --> 00:11:26,880
predicate and i want to see whether the

301
00:11:26,880 --> 00:11:29,200
predicate evaluated on all of these

302
00:11:29,200 --> 00:11:32,640
predicate checks evaluates to one

303
00:11:32,640 --> 00:11:34,480
and

304
00:11:34,480 --> 00:11:37,200
i do this by accumulating these checks

305
00:11:37,200 --> 00:11:40,079
so we have some accumulation and we have

306
00:11:40,079 --> 00:11:42,800
we start with an empty accumulator say

307
00:11:42,800 --> 00:11:45,680
and then we have approver that keeps on

308
00:11:45,680 --> 00:11:49,440
adding things to the um the accumulator

309
00:11:49,440 --> 00:11:51,279
so it keeps on adding these predicates

310
00:11:51,279 --> 00:11:54,079
to the accumulator and

311
00:11:54,079 --> 00:11:56,240
uh the verifier there's an accumulation

312
00:11:56,240 --> 00:11:57,920
verifier that can simply check whether

313
00:11:57,920 --> 00:12:01,760
the accumulation was done correctly and

314
00:12:01,760 --> 00:12:03,360
then at the end we have our final

315
00:12:03,360 --> 00:12:05,839
accumulator and there exists a so-called

316
00:12:05,839 --> 00:12:07,120
decider

317
00:12:07,120 --> 00:12:09,040
that can

318
00:12:09,040 --> 00:12:10,880
check whether this final accumulator is

319
00:12:10,880 --> 00:12:13,040
valid and what we would want as a

320
00:12:13,040 --> 00:12:14,959
property for this accumulation scheme is

321
00:12:14,959 --> 00:12:17,600
that if all of the verifiers accept so

322
00:12:17,600 --> 00:12:18,880
the verify accepts all of the

323
00:12:18,880 --> 00:12:21,680
accumulation step and the decider except

324
00:12:21,680 --> 00:12:23,040
well then we would want that this

325
00:12:23,040 --> 00:12:24,800
implies that

326
00:12:24,800 --> 00:12:27,279
this is equivalent to checking all of

327
00:12:27,279 --> 00:12:28,639
the predicates

328
00:12:28,639 --> 00:12:30,240
and

329
00:12:30,240 --> 00:12:33,200
the this this makes sense

330
00:12:33,200 --> 00:12:36,720
really if the accumulation verifier is

331
00:12:36,720 --> 00:12:38,880
much more efficient than checking the

332
00:12:38,880 --> 00:12:40,320
predicate itself

333
00:12:40,320 --> 00:12:42,560
well why is this the case well it is the

334
00:12:42,560 --> 00:12:44,240
case because really then you have to

335
00:12:44,240 --> 00:12:45,920
check you have to do t checks of the

336
00:12:45,920 --> 00:12:48,160
predicates here in the row below and in

337
00:12:48,160 --> 00:12:50,639
the ruby above you only have to do t

338
00:12:50,639 --> 00:12:53,040
checks of the accumulation verifier so

339
00:12:53,040 --> 00:12:55,200
if there's a gap here well then we're

340
00:12:55,200 --> 00:12:57,920
about t times faster than checking the

341
00:12:57,920 --> 00:13:00,720
predicate itself

342
00:13:00,720 --> 00:13:02,800
additionally in order to

343
00:13:02,800 --> 00:13:04,399
prevent a trivial construction we

344
00:13:04,399 --> 00:13:06,880
require that the accumulator does not

345
00:13:06,880 --> 00:13:09,279
grow with t so you can't just simply

346
00:13:09,279 --> 00:13:12,320
append the the predicate inputs to the

347
00:13:12,320 --> 00:13:13,920
accumulator but this should be

348
00:13:13,920 --> 00:13:16,560
compressing

349
00:13:17,040 --> 00:13:19,040
and bcms 20 showed that you can

350
00:13:19,040 --> 00:13:21,440
construct ivc from

351
00:13:21,440 --> 00:13:24,079
the accumulation and there's two things

352
00:13:24,079 --> 00:13:25,519
that i want to quickly point out here i

353
00:13:25,519 --> 00:13:27,440
don't want to dive into the details but

354
00:13:27,440 --> 00:13:29,279
what is the predicate well the predicate

355
00:13:29,279 --> 00:13:31,519
is simply snark verification

356
00:13:31,519 --> 00:13:33,519
and what we care about really here in

357
00:13:33,519 --> 00:13:34,880
this construction what is going to be

358
00:13:34,880 --> 00:13:36,800
the p key performance

359
00:13:36,800 --> 00:13:39,839
um bottle neck is going to be the size

360
00:13:39,839 --> 00:13:42,800
of r this is this recursive circuit over

361
00:13:42,800 --> 00:13:45,440
which you create a proof over and it

362
00:13:45,440 --> 00:13:47,839
mainly consists of the accumulation

363
00:13:47,839 --> 00:13:50,240
verifier so this is good because it

364
00:13:50,240 --> 00:13:51,920
doesn't actually consist of the snark

365
00:13:51,920 --> 00:13:54,320
verify because we know note that the

366
00:13:54,320 --> 00:13:56,399
accumulation verifier the whole idea is

367
00:13:56,399 --> 00:13:58,160
that it's more efficient than the snark

368
00:13:58,160 --> 00:14:00,079
verifier

369
00:14:00,079 --> 00:14:00,880
but

370
00:14:00,880 --> 00:14:01,920
um

371
00:14:01,920 --> 00:14:04,480
the accumulation verifier has to read

372
00:14:04,480 --> 00:14:08,079
the entire proof the ivc proof and the

373
00:14:08,079 --> 00:14:10,240
the old accumulator so both of these

374
00:14:10,240 --> 00:14:13,760
feed into this um accumulation verifier

375
00:14:13,760 --> 00:14:16,720
so clearly this implies that if the

376
00:14:16,720 --> 00:14:18,880
accumulation verifies sublinear well

377
00:14:18,880 --> 00:14:20,800
then the proof must be sublinear so we

378
00:14:20,800 --> 00:14:24,160
actually do require snarks here

379
00:14:24,160 --> 00:14:26,480
so to get around this we introduce a new

380
00:14:26,480 --> 00:14:29,920
tool which is called split accumulation

381
00:14:29,920 --> 00:14:33,839
and in split accumulation the idea is

382
00:14:33,839 --> 00:14:36,240
that we do it we we perform split

383
00:14:36,240 --> 00:14:38,880
accumulation not for predicates and we

384
00:14:38,880 --> 00:14:40,880
don't have predicate inputs but we split

385
00:14:40,880 --> 00:14:43,440
them into two parts in a an input

386
00:14:43,440 --> 00:14:45,920
instance and an input witness and then

387
00:14:45,920 --> 00:14:49,199
we have a relation over this um and we

388
00:14:49,199 --> 00:14:50,320
say that

389
00:14:50,320 --> 00:14:52,320
there exists basically you want to show

390
00:14:52,320 --> 00:14:53,760
that there exists

391
00:14:53,760 --> 00:14:58,560
um qwi such that all of the phi q x i

392
00:14:58,560 --> 00:15:02,240
comma q wi evaluate to 1.

393
00:15:02,240 --> 00:15:04,880
so now let's try to accumulate this so

394
00:15:04,880 --> 00:15:06,880
again we start with an accumulator and

395
00:15:06,880 --> 00:15:08,639
we have an accumulation prover that

396
00:15:08,639 --> 00:15:11,360
keeps on adding things to the human

397
00:15:11,360 --> 00:15:13,040
to the accumulator

398
00:15:13,040 --> 00:15:15,440
and but now the accumulation verifier is

399
00:15:15,440 --> 00:15:17,440
a little bit different

400
00:15:17,440 --> 00:15:19,600
in that it doesn't read the entire

401
00:15:19,600 --> 00:15:22,160
predicate input or the relation input it

402
00:15:22,160 --> 00:15:24,959
just gets to see this instance here so

403
00:15:24,959 --> 00:15:27,519
this input instance qxi

404
00:15:27,519 --> 00:15:29,600
and also we can split the accumulator in

405
00:15:29,600 --> 00:15:32,000
a very similar way into

406
00:15:32,000 --> 00:15:34,880
an accu accumulator instance and an

407
00:15:34,880 --> 00:15:36,480
accumulator with this and the

408
00:15:36,480 --> 00:15:39,040
accumulation verified only needs to say

409
00:15:39,040 --> 00:15:41,600
the input and the instance

410
00:15:41,600 --> 00:15:44,160
additionally the prover

411
00:15:44,160 --> 00:15:45,440
will

412
00:15:45,440 --> 00:15:48,320
can provide a short proof so this proof

413
00:15:48,320 --> 00:15:50,560
needs to be succinct to the accumulation

414
00:15:50,560 --> 00:15:51,680
verifier

415
00:15:51,680 --> 00:15:54,560
so what we've saved here and then at the

416
00:15:54,560 --> 00:15:57,600
end we'll have a decider that still

417
00:15:57,600 --> 00:15:59,600
reads the entire accumulator and we have

418
00:15:59,600 --> 00:16:02,560
a similar property which is that we want

419
00:16:02,560 --> 00:16:04,399
if all of the accumulation verifies

420
00:16:04,399 --> 00:16:05,920
except and the decider except this

421
00:16:05,920 --> 00:16:08,399
should imply that all of the relations

422
00:16:08,399 --> 00:16:09,519
exist

423
00:16:09,519 --> 00:16:12,399
so the key difference here is that the

424
00:16:12,399 --> 00:16:14,639
approver can provide that we can split

425
00:16:14,639 --> 00:16:17,759
the accumulator and the

426
00:16:17,759 --> 00:16:19,839
queries but now the prover can provide

427
00:16:19,839 --> 00:16:22,880
an additional proof to aid the verifier

428
00:16:22,880 --> 00:16:24,720
but now the accumulation verify could

429
00:16:24,720 --> 00:16:27,279
actually be subliner in both the size of

430
00:16:27,279 --> 00:16:29,440
the accumulator and the size of the

431
00:16:29,440 --> 00:16:30,480
queries

432
00:16:30,480 --> 00:16:31,440
and

433
00:16:31,440 --> 00:16:33,839
we still kind of get the same efficiency

434
00:16:33,839 --> 00:16:36,480
gain if this accumulation verifier now

435
00:16:36,480 --> 00:16:38,160
is sublinear in the size of the

436
00:16:38,160 --> 00:16:40,560
predicate

437
00:16:40,560 --> 00:16:41,440
so

438
00:16:41,440 --> 00:16:44,639
um how does this interact with with ivc

439
00:16:44,639 --> 00:16:47,440
can we still construct ivc from it yes

440
00:16:47,440 --> 00:16:49,759
the answer is yes so

441
00:16:49,759 --> 00:16:52,160
now what we have here is basically our

442
00:16:52,160 --> 00:16:54,000
recursive circuit again i won't dive

443
00:16:54,000 --> 00:16:55,440
into all of the details but our

444
00:16:55,440 --> 00:16:57,839
recursive circuit now consists of the

445
00:16:57,839 --> 00:17:01,440
accumulation verifier and again we

446
00:17:01,440 --> 00:17:03,759
now set as our predicate to be not

447
00:17:03,759 --> 00:17:06,240
there's no snark anymore but the anarch

448
00:17:06,240 --> 00:17:09,199
verification where we split the proof

449
00:17:09,199 --> 00:17:12,400
into two parts the short part and a long

450
00:17:12,400 --> 00:17:14,959
part and basically the accumulation

451
00:17:14,959 --> 00:17:18,079
verifier only needs to read the short

452
00:17:18,079 --> 00:17:19,599
part of the proof

453
00:17:19,599 --> 00:17:21,599
and also the short part of the

454
00:17:21,599 --> 00:17:24,079
accumulator so again the accumulator

455
00:17:24,079 --> 00:17:26,400
also split into two halves a short and a

456
00:17:26,400 --> 00:17:28,400
long part and the proof should split

457
00:17:28,400 --> 00:17:30,400
into a short and long part and the

458
00:17:30,400 --> 00:17:32,400
accumulation verifier the prover gets to

459
00:17:32,400 --> 00:17:33,600
see everything but the accumulation

460
00:17:33,600 --> 00:17:36,240
verify only has access to the short part

461
00:17:36,240 --> 00:17:39,760
so it can be much more efficient

462
00:17:40,000 --> 00:17:40,799
and

463
00:17:40,799 --> 00:17:43,600
the soundness requirement really relies

464
00:17:43,600 --> 00:17:45,039
on

465
00:17:45,039 --> 00:17:48,559
the nike and the accumulation scheme

466
00:17:48,559 --> 00:17:50,640
having strong knowledge properties so we

467
00:17:50,640 --> 00:17:52,640
need to be able to extract the entire

468
00:17:52,640 --> 00:17:55,039
transcript in abc and in order to do

469
00:17:55,039 --> 00:17:57,200
that we we call the extractors of the

470
00:17:57,200 --> 00:17:58,960
narc and we call the extractor of the

471
00:17:58,960 --> 00:18:00,799
accumulation skill

472
00:18:00,799 --> 00:18:03,760
and the efficiency

473
00:18:03,760 --> 00:18:04,799
of

474
00:18:04,799 --> 00:18:07,440
really is is the size of r

475
00:18:07,440 --> 00:18:10,880
and this is independent on now pi w and

476
00:18:10,880 --> 00:18:11,840
pi

477
00:18:11,840 --> 00:18:12,840
on

478
00:18:12,840 --> 00:18:16,880
aw so theorem moon says to to formalize

479
00:18:16,880 --> 00:18:18,720
this that this construction is actually

480
00:18:18,720 --> 00:18:20,880
secure so given an arc and a split

481
00:18:20,880 --> 00:18:23,760
accumulation scheme we get ivc and pcd

482
00:18:23,760 --> 00:18:25,679
for it and also some really nice

483
00:18:25,679 --> 00:18:29,919
properties persist so if the

484
00:18:29,919 --> 00:18:31,280
narc and the accumulation scheme has

485
00:18:31,280 --> 00:18:33,440
zero knowledge and so is the pct and if

486
00:18:33,440 --> 00:18:37,039
they're post quantum secure then so is

487
00:18:37,039 --> 00:18:39,600
the pcd scheme as well

488
00:18:39,600 --> 00:18:41,760
and this is the first construction of

489
00:18:41,760 --> 00:18:45,760
ivc that does not rely on snarks it only

490
00:18:45,760 --> 00:18:49,600
relies on non-sink narcs so um you know

491
00:18:49,600 --> 00:18:52,559
that's really exciting

492
00:18:52,640 --> 00:18:54,400
and now now

493
00:18:54,400 --> 00:18:56,160
since we had this theorem we went to

494
00:18:56,160 --> 00:18:58,880
look for a narc for r1cs that has a

495
00:18:58,880 --> 00:19:00,799
split accumulation scheme and has some

496
00:19:00,799 --> 00:19:03,120
exciting properties so

497
00:19:03,120 --> 00:19:06,720
um we what is r1cs well r1cs is an

498
00:19:06,720 --> 00:19:08,720
encoding of np

499
00:19:08,720 --> 00:19:12,000
that um is fairly simple but also widely

500
00:19:12,000 --> 00:19:15,360
used and it exists of three matrices a b

501
00:19:15,360 --> 00:19:16,480
and c

502
00:19:16,480 --> 00:19:20,880
and a public vector x and the the

503
00:19:20,880 --> 00:19:22,720
the rank one constraint system is

504
00:19:22,720 --> 00:19:24,799
satisfied if they exist the secret

505
00:19:24,799 --> 00:19:26,160
vector w

506
00:19:26,160 --> 00:19:28,480
such that r a

507
00:19:28,480 --> 00:19:30,559
times z where z is concatenate x

508
00:19:30,559 --> 00:19:33,919
concatenated with w times v z

509
00:19:33,919 --> 00:19:35,840
equals easy and times here is the

510
00:19:35,840 --> 00:19:38,720
element-wise product so

511
00:19:38,720 --> 00:19:41,520
and you can very easily transform an

512
00:19:41,520 --> 00:19:44,240
arithmetic circuit into such an

513
00:19:44,240 --> 00:19:45,679
r1cs

514
00:19:45,679 --> 00:19:48,559
constraint system and because of this

515
00:19:48,559 --> 00:19:50,480
this nice balance between structure and

516
00:19:50,480 --> 00:19:52,559
expressivity this is actually extremely

517
00:19:52,559 --> 00:19:55,280
widely used

518
00:19:55,520 --> 00:19:57,440
also for the rest of the talk we'll kind

519
00:19:57,440 --> 00:19:58,960
of ignore x

520
00:19:58,960 --> 00:20:01,840
which of course in reality you can't do

521
00:20:01,840 --> 00:20:03,679
but it makes the presentation slightly

522
00:20:03,679 --> 00:20:05,280
simpler

523
00:20:05,280 --> 00:20:08,320
so now we've constructed an arc for r1cs

524
00:20:08,320 --> 00:20:11,280
and what is the simplest possible narc

525
00:20:11,280 --> 00:20:12,720
for r1cs

526
00:20:12,720 --> 00:20:14,960
well in general for any np problem the

527
00:20:14,960 --> 00:20:17,600
simplest uh possible nerc is just simply

528
00:20:17,600 --> 00:20:19,760
sending the witness and this is almost

529
00:20:19,760 --> 00:20:22,480
rna we just simply sent z

530
00:20:22,480 --> 00:20:23,919
uh the witness

531
00:20:23,919 --> 00:20:26,960
and um but we sent a few things more

532
00:20:26,960 --> 00:20:30,799
actually what we do send is that the

533
00:20:30,799 --> 00:20:33,120
commitments to

534
00:20:33,120 --> 00:20:35,200
b azbz and c z

535
00:20:35,200 --> 00:20:38,320
and the verifier simply checks that a z

536
00:20:38,320 --> 00:20:40,320
times b z is equal to c z and that these

537
00:20:40,320 --> 00:20:43,840
commitments are correct

538
00:20:43,840 --> 00:20:45,280
additionally

539
00:20:45,280 --> 00:20:49,158
we have a

540
00:20:49,760 --> 00:20:52,480
linearly so the commitment itself

541
00:20:52,480 --> 00:20:55,360
is a linearly homomorphic commitment and

542
00:20:55,360 --> 00:20:58,080
so we this is what we'll use later on

543
00:20:58,080 --> 00:20:59,440
we'll use that the commitment scheme

544
00:20:59,440 --> 00:21:02,080
itself is homomorphic and so we can just

545
00:21:02,080 --> 00:21:04,320
you instantiate it with a patterson

546
00:21:04,320 --> 00:21:06,240
commitment scheme which is secure under

547
00:21:06,240 --> 00:21:08,159
the dispute locker assumption so this is

548
00:21:08,159 --> 00:21:09,919
where the only place really where the

549
00:21:09,919 --> 00:21:12,640
security assumption comes into play

550
00:21:12,640 --> 00:21:15,120
and the reason for doing this is yeah

551
00:21:15,120 --> 00:21:16,640
well the commitments allow us to

552
00:21:16,640 --> 00:21:19,039
accumulate the proof so

553
00:21:19,039 --> 00:21:20,799
we'll see that the commitments are the

554
00:21:20,799 --> 00:21:22,960
short part of the proof and

555
00:21:22,960 --> 00:21:24,880
see here this will be the long part of

556
00:21:24,880 --> 00:21:26,320
the proof

557
00:21:26,320 --> 00:21:27,840
so

558
00:21:27,840 --> 00:21:30,240
let's look at our split accumulation

559
00:21:30,240 --> 00:21:31,200
scheme

560
00:21:31,200 --> 00:21:32,400
and

561
00:21:32,400 --> 00:21:33,679
and

562
00:21:33,679 --> 00:21:35,600
it works in the following way where we

563
00:21:35,600 --> 00:21:38,080
start with exactly as i said the proof

564
00:21:38,080 --> 00:21:38,960
having

565
00:21:38,960 --> 00:21:39,919
been

566
00:21:39,919 --> 00:21:43,039
split into short parts c a c b c c and a

567
00:21:43,039 --> 00:21:45,120
long part which is just z

568
00:21:45,120 --> 00:21:46,720
and then we have our accumulator which

569
00:21:46,720 --> 00:21:49,039
looks very similar to our proofs um it

570
00:21:49,039 --> 00:21:52,240
just has one additional element c c zero

571
00:21:52,240 --> 00:21:56,000
here or a c circ and um basically it

572
00:21:56,000 --> 00:21:58,400
turns out that this is not quite

573
00:21:58,400 --> 00:22:00,720
the accumulator is not quite an r1cs

574
00:22:00,720 --> 00:22:04,080
instant so cacb

575
00:22:04,080 --> 00:22:07,760
is not quite equal to cc but instead

576
00:22:07,760 --> 00:22:09,840
it is equal to whatever is committed to

577
00:22:09,840 --> 00:22:11,600
in c0

578
00:22:11,600 --> 00:22:12,720
so

579
00:22:12,720 --> 00:22:15,760
this is the the accumulator and then in

580
00:22:15,760 --> 00:22:17,919
order to combine these well we'll simply

581
00:22:17,919 --> 00:22:19,679
take basically a random linear

582
00:22:19,679 --> 00:22:22,080
combination so if we take

583
00:22:22,080 --> 00:22:25,679
a random scalar field element that will

584
00:22:25,679 --> 00:22:28,000
be then generated by a random oracle in

585
00:22:28,000 --> 00:22:29,679
the actual construction

586
00:22:29,679 --> 00:22:30,640
then

587
00:22:30,640 --> 00:22:33,360
this gives us our new accumulator

588
00:22:33,360 --> 00:22:36,159
well plus some cross terms that will

589
00:22:36,159 --> 00:22:38,080
need to be able to it will need to be

590
00:22:38,080 --> 00:22:40,640
correct for uh we need to conrect for

591
00:22:40,640 --> 00:22:43,280
but this is possible by just having the

592
00:22:43,280 --> 00:22:46,559
approver send this proof element here

593
00:22:46,559 --> 00:22:48,240
and and then we can correct for these

594
00:22:48,240 --> 00:22:50,240
cross jumps so we'll see that the

595
00:22:50,240 --> 00:22:52,080
accumulation proof is also extremely

596
00:22:52,080 --> 00:22:52,960
short

597
00:22:52,960 --> 00:22:55,520
and in the end this gives us a really

598
00:22:55,520 --> 00:22:57,360
nice construction that has some really

599
00:22:57,360 --> 00:22:58,720
interesting

600
00:22:58,720 --> 00:23:00,799
property namely the accumulation

601
00:23:00,799 --> 00:23:03,039
verifier will only perform three scalar

602
00:23:03,039 --> 00:23:05,840
multiplications and also what is really

603
00:23:05,840 --> 00:23:07,919
interesting is that this doesn't require

604
00:23:07,919 --> 00:23:12,080
any ffts or pcps or or any other fancy

605
00:23:12,080 --> 00:23:14,240
machinery it really just relies on the

606
00:23:14,240 --> 00:23:16,320
discrete log assumption and and the very

607
00:23:16,320 --> 00:23:18,799
similar homomorphism of our commitment

608
00:23:18,799 --> 00:23:21,280
scheme and yet it allows us to

609
00:23:21,280 --> 00:23:22,480
accumulate

610
00:23:22,480 --> 00:23:24,480
a proof with the previous accumulator

611
00:23:24,480 --> 00:23:26,799
and this is given our very powerful

612
00:23:26,799 --> 00:23:28,159
theorem one

613
00:23:28,159 --> 00:23:30,480
this is all we need in order to

614
00:23:30,480 --> 00:23:33,120
construct ivc from this and and this is

615
00:23:33,120 --> 00:23:35,200
really where the power comes in you know

616
00:23:35,200 --> 00:23:37,760
now from something really simple we can

617
00:23:37,760 --> 00:23:39,280
construct something really really

618
00:23:39,280 --> 00:23:41,600
powerful

619
00:23:41,600 --> 00:23:44,159
so now let me close with some takeaways

620
00:23:44,159 --> 00:23:47,279
and open problems and so as i already

621
00:23:47,279 --> 00:23:49,440
said is ibc is a very useful primitive

622
00:23:49,440 --> 00:23:51,440
and which we've constructed from this

623
00:23:51,440 --> 00:23:52,880
can now be constructed from a very

624
00:23:52,880 --> 00:23:54,960
simple ingredient narcs with

625
00:23:54,960 --> 00:23:56,400
accumulation

626
00:23:56,400 --> 00:23:58,640
and we've constructed a very efficient

627
00:23:58,640 --> 00:24:00,640
arc with accumulation

628
00:24:00,640 --> 00:24:01,840
and this is

629
00:24:01,840 --> 00:24:03,760
also very exciting because it's already

630
00:24:03,760 --> 00:24:06,720
being deployed in practice so

631
00:24:06,720 --> 00:24:08,159
there's a number of projects using

632
00:24:08,159 --> 00:24:10,799
accumulation-based ivc so there's a lot

633
00:24:10,799 --> 00:24:12,799
of you know interesting open problems

634
00:24:12,799 --> 00:24:15,120
and details to work out and it really

635
00:24:15,120 --> 00:24:17,039
seems like a great time to work on this

636
00:24:17,039 --> 00:24:19,440
area and there's also a couple really

637
00:24:19,440 --> 00:24:20,799
interesting both theoretical and

638
00:24:20,799 --> 00:24:23,200
practical problems one of them is that

639
00:24:23,200 --> 00:24:26,320
we still use we have this heuristic gap

640
00:24:26,320 --> 00:24:28,720
where we use the random oracle

641
00:24:28,720 --> 00:24:30,080
or proof things in the random oracle

642
00:24:30,080 --> 00:24:31,679
model but really need them in the

643
00:24:31,679 --> 00:24:35,440
standard model so um this uses the

644
00:24:35,440 --> 00:24:37,760
question is could we maybe remove the

645
00:24:37,760 --> 00:24:40,080
the use of the random oracle maybe with

646
00:24:40,080 --> 00:24:42,720
collision intractable hashes or some

647
00:24:42,720 --> 00:24:44,159
other techniques

648
00:24:44,159 --> 00:24:46,240
and additionally uh the other question

649
00:24:46,240 --> 00:24:48,799
is if we can construct uh post-quantum

650
00:24:48,799 --> 00:24:51,840
secure accumulation schemes maybe using

651
00:24:51,840 --> 00:24:53,520
lattices but then there's of course

652
00:24:53,520 --> 00:24:55,039
interesting questions of how we deal

653
00:24:55,039 --> 00:24:57,200
with errors uh how do these errors

654
00:24:57,200 --> 00:25:01,039
accumulate and so on and so forth

655
00:25:01,039 --> 00:25:02,000
so

656
00:25:02,000 --> 00:25:04,159
this is the talk and and i hope you come

657
00:25:04,159 --> 00:25:06,159
to the live session but you can also

658
00:25:06,159 --> 00:25:09,200
find the paper online and and yeah thank

659
00:25:09,200 --> 00:25:12,520
you very much

