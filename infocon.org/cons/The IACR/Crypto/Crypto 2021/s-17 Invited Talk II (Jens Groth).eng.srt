1
00:00:04,080 --> 00:00:05,440
you're welcome to start have a good

2
00:00:05,440 --> 00:00:06,319
session

3
00:00:06,319 --> 00:00:07,120
thanks

4
00:00:07,120 --> 00:00:10,160
all right uh welcome everybody

5
00:00:10,160 --> 00:00:12,400
turn my video on

6
00:00:12,400 --> 00:00:15,120
welcome everybody to the second invited

7
00:00:15,120 --> 00:00:17,600
talk of crypto21

8
00:00:17,600 --> 00:00:19,680
uh we're very pleased to have jen's

9
00:00:19,680 --> 00:00:22,480
growth here uh to get the talk

10
00:00:22,480 --> 00:00:25,920
jens is the uh is director of research

11
00:00:25,920 --> 00:00:27,359
at dfinity

12
00:00:27,359 --> 00:00:29,840
and he received his phd from our host

13
00:00:29,840 --> 00:00:32,880
university and then did a postdoc at

14
00:00:32,880 --> 00:00:36,399
ucla where he was awarded the 2007

15
00:00:36,399 --> 00:00:37,760
ucla's

16
00:00:37,760 --> 00:00:39,600
chancellor award for postdoctoral

17
00:00:39,600 --> 00:00:40,800
research

18
00:00:40,800 --> 00:00:42,719
he was then a full professor at

19
00:00:42,719 --> 00:00:44,559
university of college

20
00:00:44,559 --> 00:00:45,840
in london

21
00:00:45,840 --> 00:00:48,079
his uh research interests are quite

22
00:00:48,079 --> 00:00:50,480
varied they include electronic voting

23
00:00:50,480 --> 00:00:52,160
and mixnets

24
00:00:52,160 --> 00:00:54,800
digital signatures public key encryption

25
00:00:54,800 --> 00:00:56,800
zero knowledge proofs and

26
00:00:56,800 --> 00:00:59,840
most recently blockchain security

27
00:00:59,840 --> 00:01:01,760
he was awarded this year's asia crypt

28
00:01:01,760 --> 00:01:04,400
2021 test of time award

29
00:01:04,400 --> 00:01:07,119
for his work on asymptotically optimal

30
00:01:07,119 --> 00:01:10,159
nizk proofs and group signatures without

31
00:01:10,159 --> 00:01:11,600
random oracles

32
00:01:11,600 --> 00:01:14,000
and he has also co-invented pairing

33
00:01:14,000 --> 00:01:15,520
based snarks

34
00:01:15,520 --> 00:01:18,240
logarithmic sized proof systems that

35
00:01:18,240 --> 00:01:19,920
underpin the bulletproof

36
00:01:19,920 --> 00:01:20,880
system

37
00:01:20,880 --> 00:01:23,360
and zero knowledge proofs with constant

38
00:01:23,360 --> 00:01:24,880
prover overhead

39
00:01:24,880 --> 00:01:25,680
so

40
00:01:25,680 --> 00:01:28,080
we're very excited to have jens and to

41
00:01:28,080 --> 00:01:29,680
hear his talk on

42
00:01:29,680 --> 00:01:33,439
a world of snarks so please welcome jens

43
00:01:33,439 --> 00:01:36,560
and take it away

44
00:01:36,560 --> 00:01:39,920
thank you chris um and thank you to the

45
00:01:39,920 --> 00:01:43,520
program committee for the invitation um

46
00:01:43,520 --> 00:01:45,759
uh i've been with dfinity for two and a

47
00:01:45,759 --> 00:01:47,520
half years now we just launched the

48
00:01:47,520 --> 00:01:50,399
internet computer and my the focus of my

49
00:01:50,399 --> 00:01:52,560
work is on the security of the internet

50
00:01:52,560 --> 00:01:55,360
computer so it's great to have the

51
00:01:55,360 --> 00:01:57,200
chance to to

52
00:01:57,200 --> 00:02:01,439
think more about snarks again um

53
00:02:01,439 --> 00:02:02,880
and

54
00:02:02,880 --> 00:02:04,799
which is an area i've been working in

55
00:02:04,799 --> 00:02:08,318
for for two decades

56
00:02:08,318 --> 00:02:11,280
i want to talk today about snarks and

57
00:02:11,280 --> 00:02:13,599
sort of like the information theoretic

58
00:02:13,599 --> 00:02:15,920
underpinning of snarks um

59
00:02:15,920 --> 00:02:17,360
this is something that i think people

60
00:02:17,360 --> 00:02:18,800
have been come

61
00:02:18,800 --> 00:02:21,440
more keenly aware of and and more

62
00:02:21,440 --> 00:02:23,280
clearly distinguish what is the

63
00:02:23,280 --> 00:02:25,440
information theoretic core

64
00:02:25,440 --> 00:02:28,480
and what is the crypto compilation

65
00:02:28,480 --> 00:02:30,800
uh that goes together to create uh

66
00:02:30,800 --> 00:02:32,480
snarks and i think it's a very useful

67
00:02:32,480 --> 00:02:33,840
distinction so i

68
00:02:33,840 --> 00:02:36,400
want to take a tour of different stocks

69
00:02:36,400 --> 00:02:39,120
i've worked on and some other snarks and

70
00:02:39,120 --> 00:02:40,800
look at what is the information

71
00:02:40,800 --> 00:02:44,879
theoretical underpinning of those snarks

72
00:02:46,319 --> 00:02:48,319
um

73
00:02:48,319 --> 00:02:51,599
okay so let me start just with what is a

74
00:02:51,599 --> 00:02:54,720
snark uh so everybody is up to speed on

75
00:02:54,720 --> 00:02:57,440
that it's a succinct non-interactive

76
00:02:57,440 --> 00:02:58,560
argument

77
00:02:58,560 --> 00:03:01,599
of knowledge uh so we have a statement

78
00:03:01,599 --> 00:03:03,360
known to both the approval and the

79
00:03:03,360 --> 00:03:05,120
verifier

80
00:03:05,120 --> 00:03:06,879
the proofer has a witness and wants to

81
00:03:06,879 --> 00:03:09,040
convince the verify that the statement

82
00:03:09,040 --> 00:03:10,720
is true

83
00:03:10,720 --> 00:03:12,319
so the prover sends a proof to the

84
00:03:12,319 --> 00:03:14,239
verifier the verify checks the proofs

85
00:03:14,239 --> 00:03:18,239
and and hopefully everything works out

86
00:03:18,239 --> 00:03:20,720
now the key properties of a snark is

87
00:03:20,720 --> 00:03:22,720
that it should be non-interactive so

88
00:03:22,720 --> 00:03:25,040
there's no interaction between the proof

89
00:03:25,040 --> 00:03:26,959
and the verify the verify just receives

90
00:03:26,959 --> 00:03:27,920
the proof

91
00:03:27,920 --> 00:03:30,159
and decides whether to accept or reject

92
00:03:30,159 --> 00:03:32,400
that proof

93
00:03:32,400 --> 00:03:33,920
then we also want the proof to be

94
00:03:33,920 --> 00:03:35,920
succinct right so it has to be much

95
00:03:35,920 --> 00:03:39,040
smaller than the statement to be proved

96
00:03:39,040 --> 00:03:41,599
uh and particular snarks are used in the

97
00:03:41,599 --> 00:03:43,200
blockchain space and there it's very

98
00:03:43,200 --> 00:03:45,120
important that we reduce memory

99
00:03:45,120 --> 00:03:47,440
consumption as much as possible because

100
00:03:47,440 --> 00:03:49,599
these proofs may be replicated in many

101
00:03:49,599 --> 00:03:52,079
places

102
00:03:53,040 --> 00:03:54,319
and then

103
00:03:54,319 --> 00:03:55,439
finally

104
00:03:55,439 --> 00:03:58,319
it's often in in context we use them

105
00:03:58,319 --> 00:04:00,879
very important that the esr proofs of

106
00:04:00,879 --> 00:04:02,959
knowledge that not only is the statement

107
00:04:02,959 --> 00:04:04,799
true but actually the proven knows a

108
00:04:04,799 --> 00:04:08,560
witness to the statement

109
00:04:08,799 --> 00:04:11,360
snarks may have other properties

110
00:04:11,360 --> 00:04:13,680
a snark may be zero knowledge so it

111
00:04:13,680 --> 00:04:15,040
doesn't reveal anything about the

112
00:04:15,040 --> 00:04:17,519
witness now in its nature because it's

113
00:04:17,519 --> 00:04:19,440
succinct there's a limit to how much

114
00:04:19,440 --> 00:04:21,199
information it can leak

115
00:04:21,199 --> 00:04:22,479
um but

116
00:04:22,479 --> 00:04:24,720
snacks may or may not be fully zero

117
00:04:24,720 --> 00:04:26,840
knowledge

118
00:04:26,840 --> 00:04:29,440
um i'm also

119
00:04:29,440 --> 00:04:31,280
not going to go so much into

120
00:04:31,280 --> 00:04:34,080
succinctness so so the questions does

121
00:04:34,080 --> 00:04:36,000
the definition really require the

122
00:04:36,000 --> 00:04:38,080
success to be all the way down to

123
00:04:38,080 --> 00:04:40,320
polyurethane size or do you allow a

124
00:04:40,320 --> 00:04:42,479
little more than that i'm going to be

125
00:04:42,479 --> 00:04:44,000
pretty relaxed about that as long as

126
00:04:44,000 --> 00:04:46,000
it's clearly sub-linear communication

127
00:04:46,000 --> 00:04:48,800
i'm happy to call it succinct

128
00:04:48,800 --> 00:04:50,639
um there are also some definitions that

129
00:04:50,639 --> 00:04:52,400
really emphasize that the verifier

130
00:04:52,400 --> 00:04:55,280
should be very efficient as well and

131
00:04:55,280 --> 00:04:56,639
depends a little on the statement

132
00:04:56,639 --> 00:04:59,360
whether that's possible or not right so

133
00:04:59,360 --> 00:05:01,280
in order to verify proof for statement

134
00:05:01,280 --> 00:05:03,759
general the uh verifier has to read the

135
00:05:03,759 --> 00:05:06,240
full statement and so so only when the

136
00:05:06,240 --> 00:05:07,280
statement is

137
00:05:07,280 --> 00:05:08,880
small compared to the witness size

138
00:05:08,880 --> 00:05:11,759
doesn't make sense to talk about

139
00:05:11,759 --> 00:05:14,160
a sub-linear something in terms of

140
00:05:14,160 --> 00:05:17,680
verifier computation

141
00:05:20,240 --> 00:05:22,800
okay so there's a wealth of different

142
00:05:22,800 --> 00:05:24,800
proof systems um

143
00:05:24,800 --> 00:05:26,080
and

144
00:05:26,080 --> 00:05:29,199
um as snarks are just one type of proof

145
00:05:29,199 --> 00:05:31,120
system and i'm always a little

146
00:05:31,120 --> 00:05:33,039
ambivalent about the

147
00:05:33,039 --> 00:05:35,919
term snark i think it's

148
00:05:35,919 --> 00:05:38,479
extremely useful to have a precise term

149
00:05:38,479 --> 00:05:40,320
for the kind of things that we do need

150
00:05:40,320 --> 00:05:41,919
in the blockchain space and i do think

151
00:05:41,919 --> 00:05:44,000
that

152
00:05:44,000 --> 00:05:46,400
the core of it that it's succinct and

153
00:05:46,400 --> 00:05:48,960
therefore it very easy to copy and send

154
00:05:48,960 --> 00:05:51,759
too many people is very important

155
00:05:51,759 --> 00:05:53,600
and certainly non-interactivity is

156
00:05:53,600 --> 00:05:55,120
important in that

157
00:05:55,120 --> 00:05:57,120
context as well

158
00:05:57,120 --> 00:05:58,720
on the other hand

159
00:05:58,720 --> 00:06:00,400
i see

160
00:06:00,400 --> 00:06:02,639
snark as a bit of a fancy and catchy

161
00:06:02,639 --> 00:06:05,120
name that many other starks come to

162
00:06:05,120 --> 00:06:07,280
spring to minus as well right and and

163
00:06:07,280 --> 00:06:10,240
they're all to me just examples of proof

164
00:06:10,240 --> 00:06:12,720
systems i was working this area before

165
00:06:12,720 --> 00:06:15,680
these terms were invented and in general

166
00:06:15,680 --> 00:06:17,280
we can think of proof systems that can

167
00:06:17,280 --> 00:06:19,039
have all sorts of properties the kind of

168
00:06:19,039 --> 00:06:21,199
security properties efficiency

169
00:06:21,199 --> 00:06:23,360
properties be based on different types

170
00:06:23,360 --> 00:06:25,600
of cryptography and there can also be

171
00:06:25,600 --> 00:06:28,160
operational questions such as what is a

172
00:06:28,160 --> 00:06:30,960
setup and what is the interaction and is

173
00:06:30,960 --> 00:06:35,759
it public coin or not so there's a um

174
00:06:35,759 --> 00:06:38,240
many dimensions on which you can

175
00:06:38,240 --> 00:06:40,479
do different tweaks and on proof systems

176
00:06:40,479 --> 00:06:41,600
and to me

177
00:06:41,600 --> 00:06:44,000
um when i think about this space i often

178
00:06:44,000 --> 00:06:45,759
just think about proof systems and then

179
00:06:45,759 --> 00:06:47,039
they may have

180
00:06:47,039 --> 00:06:49,120
some properties and not have other

181
00:06:49,120 --> 00:06:51,680
properties

182
00:06:54,479 --> 00:06:56,080
okay so i want to

183
00:06:56,080 --> 00:06:58,800
go back to to time i was thinking about

184
00:06:58,800 --> 00:07:01,199
when was the first time i

185
00:07:01,199 --> 00:07:04,000
learned about zero knowledge um

186
00:07:04,000 --> 00:07:05,520
and i think it was actually when back

187
00:07:05,520 --> 00:07:08,479
when it was a a child um

188
00:07:08,479 --> 00:07:11,199
so 10 years or so

189
00:07:11,199 --> 00:07:12,639
and

190
00:07:12,639 --> 00:07:14,800
this is a fake slide this is not how i

191
00:07:14,800 --> 00:07:17,280
learned about syrian knowledge first uh

192
00:07:17,280 --> 00:07:19,440
i did an artist 10 year old

193
00:07:19,440 --> 00:07:20,720
read

194
00:07:20,720 --> 00:07:21,680
fox

195
00:07:21,680 --> 00:07:23,120
papers

196
00:07:23,120 --> 00:07:24,800
um

197
00:07:24,800 --> 00:07:27,039
so so but it was about the same time

198
00:07:27,039 --> 00:07:29,280
actually as as it was invented by

199
00:07:29,280 --> 00:07:32,319
goldwater michalian and rakoff

200
00:07:32,319 --> 00:07:33,280
um

201
00:07:33,280 --> 00:07:36,400
the way i encountered it was in i think

202
00:07:36,400 --> 00:07:39,120
in a story that i uh

203
00:07:39,120 --> 00:07:41,520
that i heard which was about an emperor

204
00:07:41,520 --> 00:07:44,000
and a hero right and

205
00:07:44,000 --> 00:07:44,800
as

206
00:07:44,800 --> 00:07:47,440
many good stories the hero goes through

207
00:07:47,440 --> 00:07:48,879
an enormous

208
00:07:48,879 --> 00:07:51,280
amount of obstacles and the emperor

209
00:07:51,280 --> 00:07:53,199
really doesn't like the hero and and

210
00:07:53,199 --> 00:07:56,400
sets all these obstacles

211
00:07:56,400 --> 00:07:59,599
and at some point the emperor uh

212
00:07:59,599 --> 00:08:02,080
sets um

213
00:08:02,080 --> 00:08:03,440
sets uh

214
00:08:03,440 --> 00:08:06,639
two balls covered with lids in in front

215
00:08:06,639 --> 00:08:09,120
of the hero and then promises that you

216
00:08:09,120 --> 00:08:11,280
know either he will become incredibly

217
00:08:11,280 --> 00:08:12,560
wealthy

218
00:08:12,560 --> 00:08:15,120
or he will be executed

219
00:08:15,120 --> 00:08:18,240
and he has to pick one of these uh

220
00:08:18,240 --> 00:08:21,280
balls and if there's a

221
00:08:21,280 --> 00:08:23,840
gold inside then he gets the gold uh but

222
00:08:23,840 --> 00:08:27,840
if it's empty he will be executed

223
00:08:27,919 --> 00:08:28,720
and

224
00:08:28,720 --> 00:08:31,280
the hero

225
00:08:31,599 --> 00:08:34,240
fortunately for this story is suspicious

226
00:08:34,240 --> 00:08:35,679
of the emperor

227
00:08:35,679 --> 00:08:37,760
and realizes that the emperor may have

228
00:08:37,760 --> 00:08:40,880
just put two empty balls in front of him

229
00:08:40,880 --> 00:08:43,279
right and there's no chance of winning

230
00:08:43,279 --> 00:08:45,440
and indeed that is what the emperor has

231
00:08:45,440 --> 00:08:46,959
done

232
00:08:46,959 --> 00:08:48,240
but uh

233
00:08:48,240 --> 00:08:50,160
as in good stories the

234
00:08:50,160 --> 00:08:53,279
hero is very clever and he changes the

235
00:08:53,279 --> 00:08:54,399
algorithm

236
00:08:54,399 --> 00:08:56,399
what he does is he picks one of the

237
00:08:56,399 --> 00:08:59,360
balls and say says i choose this one and

238
00:08:59,360 --> 00:09:02,560
then he lifts the lid on the other ball

239
00:09:02,560 --> 00:09:04,560
right and now everybody can see

240
00:09:04,560 --> 00:09:07,200
the other one is empty and therefore the

241
00:09:07,200 --> 00:09:09,600
one he has chosen must be

242
00:09:09,600 --> 00:09:11,519
the one with the gold

243
00:09:11,519 --> 00:09:14,080
and the emperor does not want to

244
00:09:14,080 --> 00:09:16,080
reveal that he's been cheating and

245
00:09:16,080 --> 00:09:20,560
therefore the hero is rewarded

246
00:09:21,360 --> 00:09:22,880
now

247
00:09:22,880 --> 00:09:25,440
the reason this story is sprung to my

248
00:09:25,440 --> 00:09:27,440
mind is because this is exactly what

249
00:09:27,440 --> 00:09:29,360
we're doing when we do non-interactive

250
00:09:29,360 --> 00:09:31,200
knowledge proofs

251
00:09:31,200 --> 00:09:32,800
right so so

252
00:09:32,800 --> 00:09:33,760
um

253
00:09:33,760 --> 00:09:35,760
so non-interactive very knowledge tools

254
00:09:35,760 --> 00:09:38,320
or like uh invented by bloom feldman

255
00:09:38,320 --> 00:09:39,600
mcauley

256
00:09:39,600 --> 00:09:41,760
in in in the 80s

257
00:09:41,760 --> 00:09:43,279
um

258
00:09:43,279 --> 00:09:45,200
it can be set in in what is called the

259
00:09:45,200 --> 00:09:48,080
hidden random bits model this is a

260
00:09:48,080 --> 00:09:51,120
information theoretic abstraction of so

261
00:09:51,120 --> 00:09:53,680
like the core ideas in a non-interactive

262
00:09:53,680 --> 00:09:55,600
knowledge proof

263
00:09:55,600 --> 00:09:57,839
so in this model there's a dealer that

264
00:09:57,839 --> 00:10:02,000
produces a uniformly random string

265
00:10:02,000 --> 00:10:04,800
and the prover can see the bits in this

266
00:10:04,800 --> 00:10:06,480
string right so think of the dealers

267
00:10:06,480 --> 00:10:08,800
giving some cards the approver can peek

268
00:10:08,800 --> 00:10:10,399
and see whether it's a zero or one

269
00:10:10,399 --> 00:10:12,160
that's written on the card

270
00:10:12,160 --> 00:10:14,720
and the verify does not know

271
00:10:14,720 --> 00:10:17,440
but the prover can decide to disclose

272
00:10:17,440 --> 00:10:19,120
some of these cards

273
00:10:19,120 --> 00:10:22,079
to the verifier

274
00:10:23,360 --> 00:10:26,000
now it's surprising that

275
00:10:26,000 --> 00:10:28,000
in this model you can prove anything

276
00:10:28,000 --> 00:10:30,480
right it's just uniformly random string

277
00:10:30,480 --> 00:10:32,079
what does it give you what kind of power

278
00:10:32,079 --> 00:10:34,320
does it give to the proof

279
00:10:34,320 --> 00:10:35,839
and and the very

280
00:10:35,839 --> 00:10:37,519
cool idea is that you can do some

281
00:10:37,519 --> 00:10:39,519
statistical sampling right so if the

282
00:10:39,519 --> 00:10:42,320
prover for instance decides to

283
00:10:42,320 --> 00:10:44,320
sort this

284
00:10:44,320 --> 00:10:46,480
all these cards and pairs

285
00:10:46,480 --> 00:10:49,440
um and reveals the ones which have odd

286
00:10:49,440 --> 00:10:51,440
parity then statistically speaking the

287
00:10:51,440 --> 00:10:55,440
remaining cards should have even parity

288
00:10:55,440 --> 00:10:58,800
and you can build more clever uh

289
00:10:58,800 --> 00:11:01,519
structures by this statistical sampling

290
00:11:01,519 --> 00:11:03,680
and and actually create them such that

291
00:11:03,680 --> 00:11:05,839
they can also be sort of put together

292
00:11:05,839 --> 00:11:07,200
and boost

293
00:11:07,200 --> 00:11:09,680
help each other to actually prove a

294
00:11:09,680 --> 00:11:12,239
statement

295
00:11:13,519 --> 00:11:14,480
um

296
00:11:14,480 --> 00:11:16,320
and the reason that i was thinking about

297
00:11:16,320 --> 00:11:18,959
that is because the simulation you do in

298
00:11:18,959 --> 00:11:21,440
in those proofs is exactly the same as

299
00:11:21,440 --> 00:11:23,760
the hero did towards the emperor

300
00:11:23,760 --> 00:11:25,440
right when you want to simulate

301
00:11:25,440 --> 00:11:26,399
something

302
00:11:26,399 --> 00:11:29,440
then you choose the pairs in a different

303
00:11:29,440 --> 00:11:31,839
way you prepare the pairs such that you

304
00:11:31,839 --> 00:11:34,000
can actually reveal them

305
00:11:34,000 --> 00:11:35,279
you have more

306
00:11:35,279 --> 00:11:37,120
a different statistical distribution and

307
00:11:37,120 --> 00:11:39,440
you can actually reveal them as either

308
00:11:39,440 --> 00:11:42,440
thing

309
00:11:44,399 --> 00:11:46,720
okay so so that's all like illustrates

310
00:11:46,720 --> 00:11:48,800
an information theoretical model that

311
00:11:48,800 --> 00:11:51,440
can underpin uh a non-interactive zero

312
00:11:51,440 --> 00:11:53,760
knowledge truth and then you can also do

313
00:11:53,760 --> 00:11:56,320
a cryptographic compilation of this and

314
00:11:56,320 --> 00:11:59,200
get a real world proof out of it in this

315
00:11:59,200 --> 00:12:02,399
case the setup is a uniformly random

316
00:12:02,399 --> 00:12:06,240
string and the approver may choose

317
00:12:07,120 --> 00:12:09,760
interpret those as blocks that are

318
00:12:09,760 --> 00:12:12,160
ciphertext and then the prover

319
00:12:12,160 --> 00:12:15,519
picks keys for bit encryption scheme

320
00:12:15,519 --> 00:12:16,959
um

321
00:12:16,959 --> 00:12:19,040
and sends the public key to the verify

322
00:12:19,040 --> 00:12:21,839
as part of the proof and also then

323
00:12:21,839 --> 00:12:24,720
opens some of these uh

324
00:12:24,720 --> 00:12:27,360
cipher text to the underlying plain text

325
00:12:27,360 --> 00:12:30,160
and if it's a verifiable encryption

326
00:12:30,160 --> 00:12:32,240
openings that we have in this encryption

327
00:12:32,240 --> 00:12:34,800
scheme then that makes it possible to

328
00:12:34,800 --> 00:12:37,839
selectively disclose some of the uh the

329
00:12:37,839 --> 00:12:41,120
plain text bits to the verify and hide

330
00:12:41,120 --> 00:12:43,680
some of the other the remaining plain

331
00:12:43,680 --> 00:12:46,239
text bits

332
00:12:46,320 --> 00:12:50,480
so that's like the core idea in

333
00:12:50,839 --> 00:12:52,959
traditional uh non-interactive zero

334
00:12:52,959 --> 00:12:54,959
knowledge proofs based on contractor

335
00:12:54,959 --> 00:12:57,760
permutations

336
00:12:59,120 --> 00:13:02,480
okay so i want to to look then at more

337
00:13:02,480 --> 00:13:04,800
modern proofs um

338
00:13:04,800 --> 00:13:06,639
and i'm going to think a lot about

339
00:13:06,639 --> 00:13:08,399
interactive proofs that we make

340
00:13:08,399 --> 00:13:10,880
non-interactive using the future mere

341
00:13:10,880 --> 00:13:13,439
heuristic

342
00:13:13,760 --> 00:13:16,000
um

343
00:13:16,240 --> 00:13:18,160
and and i'll i want to

344
00:13:18,160 --> 00:13:20,399
walk through some of these proofs sort

345
00:13:20,399 --> 00:13:22,000
of thinking about what is the

346
00:13:22,000 --> 00:13:24,160
information theoretical model

347
00:13:24,160 --> 00:13:27,680
what is the cryptographic way we realize

348
00:13:27,680 --> 00:13:30,399
them and sort of see how those two play

349
00:13:30,399 --> 00:13:33,399
together

350
00:13:35,360 --> 00:13:38,160
okay so let's uh start with the shores

351
00:13:38,160 --> 00:13:40,480
classical proof of knowledge of a

352
00:13:40,480 --> 00:13:42,560
discrete logarithm

353
00:13:42,560 --> 00:13:44,800
so here the instance is a group element

354
00:13:44,800 --> 00:13:47,040
a

355
00:13:47,199 --> 00:13:48,880
and the witness is the discrete

356
00:13:48,880 --> 00:13:52,560
logarithm of this group element

357
00:13:52,560 --> 00:13:55,360
and the way the proof system works is

358
00:13:55,360 --> 00:13:58,000
that the proverb picks up at random

359
00:13:58,000 --> 00:13:59,279
blinding

360
00:13:59,279 --> 00:14:00,839
field element a

361
00:14:00,839 --> 00:14:03,519
node and computes

362
00:14:03,519 --> 00:14:05,360
the exponentiation of that field element

363
00:14:05,360 --> 00:14:08,560
and sends that to the verifier

364
00:14:08,560 --> 00:14:11,279
now the verify picks a random

365
00:14:11,279 --> 00:14:12,399
challenge

366
00:14:12,399 --> 00:14:14,160
send that to the prover

367
00:14:14,160 --> 00:14:16,160
and the prover opens this linear

368
00:14:16,160 --> 00:14:17,760
combination here

369
00:14:17,760 --> 00:14:20,639
uh a notepad plus the challenge times

370
00:14:20,639 --> 00:14:25,279
the the secret discrete logarithm a

371
00:14:25,279 --> 00:14:27,519
and it's pretty easy to see that if you

372
00:14:27,519 --> 00:14:29,519
plug in these numbers that indeed the

373
00:14:29,519 --> 00:14:31,839
verify will accept with this

374
00:14:31,839 --> 00:14:35,920
verification equation over here

375
00:14:38,480 --> 00:14:40,079
now if we look at this

376
00:14:40,079 --> 00:14:42,320
information theoretically what's really

377
00:14:42,320 --> 00:14:45,120
going on here well it is that the proof

378
00:14:45,120 --> 00:14:46,959
is bound to some

379
00:14:46,959 --> 00:14:48,720
field element a

380
00:14:48,720 --> 00:14:52,320
right picks a random blinding and

381
00:14:52,320 --> 00:14:53,199
sort of

382
00:14:53,199 --> 00:14:55,120
commits to that as well

383
00:14:55,120 --> 00:14:57,040
in a way that the verified does not know

384
00:14:57,040 --> 00:14:59,279
what these elements are

385
00:14:59,279 --> 00:15:01,839
then the verifier sends a challenge x

386
00:15:01,839 --> 00:15:04,079
and gets some linear combination of

387
00:15:04,079 --> 00:15:08,079
those secret field elements

388
00:15:08,720 --> 00:15:11,040
and as long as the verify is guaranteed

389
00:15:11,040 --> 00:15:14,639
that is the answer really is this linear

390
00:15:14,639 --> 00:15:17,519
uh combination of the field elements

391
00:15:17,519 --> 00:15:20,480
then we get a proof of knowledge

392
00:15:20,480 --> 00:15:23,760
right and the core idea here is that

393
00:15:23,760 --> 00:15:25,680
um if the approval would be able to

394
00:15:25,680 --> 00:15:26,399
answer

395
00:15:26,399 --> 00:15:28,399
two distinct challenges right then you

396
00:15:28,399 --> 00:15:30,240
would actually have

397
00:15:30,240 --> 00:15:32,399
two different evaluations of this linear

398
00:15:32,399 --> 00:15:34,480
combination and that would be enough to

399
00:15:34,480 --> 00:15:36,800
determine the line

400
00:15:36,800 --> 00:15:39,519
defined by the discrete logarithm and

401
00:15:39,519 --> 00:15:41,519
the blinding factor and then you can

402
00:15:41,519 --> 00:15:44,240
determine the slope which is indeed the

403
00:15:44,240 --> 00:15:46,240
discrete logarithm that the prover

404
00:15:46,240 --> 00:15:49,120
claimed to know

405
00:15:51,279 --> 00:15:52,560
now

406
00:15:52,560 --> 00:15:54,320
i think this picture illustrates very

407
00:15:54,320 --> 00:15:57,120
well what is uh what is the core idea of

408
00:15:57,120 --> 00:16:00,160
schnoor's uh proof of knowledge

409
00:16:00,160 --> 00:16:02,160
right but it also

410
00:16:02,160 --> 00:16:04,480
is helpful because it points to ways you

411
00:16:04,480 --> 00:16:05,920
can extend

412
00:16:05,920 --> 00:16:08,000
this right so one natural question is

413
00:16:08,000 --> 00:16:09,600
for instance what instead of a line we

414
00:16:09,600 --> 00:16:12,240
have a polynomial

415
00:16:12,240 --> 00:16:13,120
um

416
00:16:13,120 --> 00:16:15,759
and indeed you can do that right if the

417
00:16:15,759 --> 00:16:18,240
proof has multiple field elements and

418
00:16:18,240 --> 00:16:20,000
field elements

419
00:16:20,000 --> 00:16:20,959
then

420
00:16:20,959 --> 00:16:22,320
the challenge could define this

421
00:16:22,320 --> 00:16:24,000
polynomial

422
00:16:24,000 --> 00:16:25,440
and if you get

423
00:16:25,440 --> 00:16:28,079
enough distinct challenges answers then

424
00:16:28,079 --> 00:16:29,920
you can determine the full polynomial

425
00:16:29,920 --> 00:16:31,199
and therefore all the discrete

426
00:16:31,199 --> 00:16:33,839
logarithms

427
00:16:35,440 --> 00:16:38,000
right and you can translate that back to

428
00:16:38,000 --> 00:16:40,480
to uh

429
00:16:40,959 --> 00:16:43,120
to a group with a discrete logarithm

430
00:16:43,120 --> 00:16:45,040
where you can compile this information

431
00:16:45,040 --> 00:16:47,440
serrated malta so it generalizes

432
00:16:47,440 --> 00:16:49,920
schnoor's proof of discrete logarithms

433
00:16:49,920 --> 00:16:51,680
where we can now prove

434
00:16:51,680 --> 00:16:53,839
that knowledge of the discrete logarithm

435
00:16:53,839 --> 00:16:58,000
of multiple elements in one go

436
00:16:58,800 --> 00:17:00,959
and if we use the future mere heuristic

437
00:17:00,959 --> 00:17:05,119
we may compute x as the hash uh

438
00:17:05,119 --> 00:17:06,400
so so

439
00:17:06,400 --> 00:17:10,640
it's sort of uh looks random right um

440
00:17:10,640 --> 00:17:13,520
and that then gives us non-interactive

441
00:17:13,520 --> 00:17:15,520
proof where you just send this initial

442
00:17:15,520 --> 00:17:16,480
element

443
00:17:16,480 --> 00:17:19,439
hash things you send the answer

444
00:17:19,439 --> 00:17:21,119
the verifier can

445
00:17:21,119 --> 00:17:23,520
himself recompute the challenge and

446
00:17:23,520 --> 00:17:27,119
decide whether to accept the proof

447
00:17:27,439 --> 00:17:29,840
and that's the first example of a snark

448
00:17:29,840 --> 00:17:31,840
right it's a very simple snack but it is

449
00:17:31,840 --> 00:17:32,880
a

450
00:17:32,880 --> 00:17:35,360
it's a saint because the only

451
00:17:35,360 --> 00:17:37,440
uh one group element and two field

452
00:17:37,440 --> 00:17:39,440
elements that we send right

453
00:17:39,440 --> 00:17:41,760
and that's much less than the instance

454
00:17:41,760 --> 00:17:43,919
size

455
00:17:43,919 --> 00:17:45,520
and it's not interactive right because

456
00:17:45,520 --> 00:17:48,880
we're using the future heuristic

457
00:17:48,880 --> 00:17:52,960
so so there we have our first snark

458
00:17:55,679 --> 00:17:57,120
um

459
00:17:57,120 --> 00:17:59,200
the different ways you can generalize

460
00:17:59,200 --> 00:18:01,200
that

461
00:18:01,200 --> 00:18:05,200
so so one way to do that is

462
00:18:05,200 --> 00:18:07,760
to prove knowledge of vectors instead of

463
00:18:07,760 --> 00:18:09,360
field elements

464
00:18:09,360 --> 00:18:11,280
and we're just using

465
00:18:11,280 --> 00:18:13,120
linear properties

466
00:18:13,120 --> 00:18:15,679
here so that works out perfectly well as

467
00:18:15,679 --> 00:18:18,799
well so now you can commit to many

468
00:18:18,799 --> 00:18:21,039
vectors of field elements

469
00:18:21,039 --> 00:18:23,440
you pick a vector to blind everything

470
00:18:23,440 --> 00:18:25,520
you get a challenge and you compute

471
00:18:25,520 --> 00:18:28,080
vectors of polynomials and exactly the

472
00:18:28,080 --> 00:18:31,280
same reasoning goes through

473
00:18:34,160 --> 00:18:35,600
right

474
00:18:35,600 --> 00:18:38,000
and what we have now if we balance

475
00:18:38,000 --> 00:18:40,640
things correctly let's say m and then a

476
00:18:40,640 --> 00:18:42,480
roughly little square root of

477
00:18:42,480 --> 00:18:45,360
n which is the the total number of

478
00:18:45,360 --> 00:18:47,360
field elements here

479
00:18:47,360 --> 00:18:49,039
um

480
00:18:49,039 --> 00:18:51,840
then then we actually get a root n

481
00:18:51,840 --> 00:18:55,120
sized uh snark and if you would if you

482
00:18:55,120 --> 00:18:57,039
had to show me your heuristic

483
00:18:57,039 --> 00:18:58,400
but where we are

484
00:18:58,400 --> 00:19:02,320
proving knowledge of n uh field elements

485
00:19:02,320 --> 00:19:04,240
and at this stage

486
00:19:04,240 --> 00:19:06,400
the proof is smaller than both

487
00:19:06,400 --> 00:19:08,840
the instance size right

488
00:19:08,840 --> 00:19:11,679
um and also at the same time the

489
00:19:11,679 --> 00:19:13,360
instance is actually

490
00:19:13,360 --> 00:19:15,200
smaller than the witness size right it's

491
00:19:15,200 --> 00:19:17,200
actually committing to many field

492
00:19:17,200 --> 00:19:21,760
elements uh with just one short instance

493
00:19:21,760 --> 00:19:25,200
so so that points to to how we can get

494
00:19:25,200 --> 00:19:27,400
really powerful

495
00:19:27,400 --> 00:19:32,000
sublinearity in improved systems

496
00:19:36,960 --> 00:19:39,919
okay so information theoretically what's

497
00:19:39,919 --> 00:19:41,919
going on here

498
00:19:41,919 --> 00:19:42,960
um

499
00:19:42,960 --> 00:19:45,760
and the way we can abstract it is to say

500
00:19:45,760 --> 00:19:47,120
that we have this

501
00:19:47,120 --> 00:19:49,439
um

502
00:19:50,840 --> 00:19:54,240
interactive a deal commit commitment

503
00:19:54,240 --> 00:19:56,240
model right so

504
00:19:56,240 --> 00:19:58,320
if we imagine this protocol and it could

505
00:19:58,320 --> 00:20:00,320
have more rounds of interaction right

506
00:20:00,320 --> 00:20:02,720
you can still if you have multiple

507
00:20:02,720 --> 00:20:05,039
rounds of poplar coin uh challenge you

508
00:20:05,039 --> 00:20:07,440
can still use the future mere heuristic

509
00:20:07,440 --> 00:20:09,600
to to

510
00:20:09,600 --> 00:20:11,520
compress it down to a non-interactive

511
00:20:11,520 --> 00:20:13,918
snark

512
00:20:14,480 --> 00:20:15,360
so

513
00:20:15,360 --> 00:20:17,360
so in this model you could imagine that

514
00:20:17,360 --> 00:20:19,440
the prover commits to

515
00:20:19,440 --> 00:20:21,440
vectors of field elements

516
00:20:21,440 --> 00:20:22,960
get some message

517
00:20:22,960 --> 00:20:24,880
from the verifier

518
00:20:24,880 --> 00:20:27,039
commit to another set of

519
00:20:27,039 --> 00:20:28,080
field

520
00:20:28,080 --> 00:20:30,400
vectors or field elements it's another

521
00:20:30,400 --> 00:20:32,840
challenge and so forth

522
00:20:32,840 --> 00:20:37,039
right and in the end um

523
00:20:37,039 --> 00:20:39,440
we have these uh homomorphic properties

524
00:20:39,440 --> 00:20:41,919
the verifier can query for linear

525
00:20:41,919 --> 00:20:43,760
combinations of those

526
00:20:43,760 --> 00:20:46,720
committed vectors

527
00:20:47,200 --> 00:20:48,799
and

528
00:20:48,799 --> 00:20:51,280
when we compiled this and did this in in

529
00:20:51,280 --> 00:20:52,880
the

530
00:20:52,880 --> 00:20:54,720
group with discrete logarithm we saw

531
00:20:54,720 --> 00:20:57,280
like the prover could

532
00:20:57,280 --> 00:20:59,360
send these answers to the verify that

533
00:20:59,360 --> 00:21:01,120
verify could check it right but in this

534
00:21:01,120 --> 00:21:03,600
ideal model we can simply

535
00:21:03,600 --> 00:21:05,280
model that as something that's where the

536
00:21:05,280 --> 00:21:07,440
proof is not involved at all it's just

537
00:21:07,440 --> 00:21:09,679
the model that guarantees that indeed

538
00:21:09,679 --> 00:21:11,520
the verify gets correct linear

539
00:21:11,520 --> 00:21:15,960
combinations of the committed vectors

540
00:21:16,080 --> 00:21:20,400
that abstracts this model here abstracts

541
00:21:20,400 --> 00:21:22,880
a lot of

542
00:21:22,880 --> 00:21:25,760
proof systems you could build over

543
00:21:25,760 --> 00:21:29,640
groups with discrete logarithms

544
00:21:34,000 --> 00:21:35,520
okay um

545
00:21:35,520 --> 00:21:38,240
proofs of knowledge are of course um

546
00:21:38,240 --> 00:21:40,880
nice but not super useful by themselves

547
00:21:40,880 --> 00:21:43,280
but um but we actually can do more in

548
00:21:43,280 --> 00:21:45,600
this model here

549
00:21:45,600 --> 00:21:47,360
because of these

550
00:21:47,360 --> 00:21:49,679
ability to do

551
00:21:49,679 --> 00:21:51,840
get linear combinations of committed

552
00:21:51,840 --> 00:21:55,520
vectors open we get additive relations

553
00:21:55,520 --> 00:21:57,200
almost for free

554
00:21:57,200 --> 00:21:59,200
um with some extra work it's also

555
00:21:59,200 --> 00:22:01,039
possible to show that you can actually

556
00:22:01,039 --> 00:22:02,880
in this model prove that you have

557
00:22:02,880 --> 00:22:05,200
multiplicative relationships where you

558
00:22:05,200 --> 00:22:07,760
take for instance two vectors and show a

559
00:22:07,760 --> 00:22:09,679
third vector is the entry-wise product

560
00:22:09,679 --> 00:22:12,480
of each of those

561
00:22:12,480 --> 00:22:14,880
pairs of interest in the first vectors

562
00:22:14,880 --> 00:22:16,400
you could also have some committed

563
00:22:16,400 --> 00:22:18,159
values and prove that you have a

564
00:22:18,159 --> 00:22:20,240
permutation of those committed

565
00:22:20,240 --> 00:22:21,360
values

566
00:22:21,360 --> 00:22:24,559
and and all those tools taken together

567
00:22:24,559 --> 00:22:27,919
can actually give us succinct proofs for

568
00:22:27,919 --> 00:22:30,559
arithmetic circuit satisfiability so if

569
00:22:30,559 --> 00:22:32,880
you have an arithmetic circuit or a

570
00:22:32,880 --> 00:22:34,159
field of size

571
00:22:34,159 --> 00:22:34,880
n

572
00:22:34,880 --> 00:22:36,880
then you can get succinct proofs that

573
00:22:36,880 --> 00:22:41,720
have a size root n

574
00:22:44,240 --> 00:22:46,080
and it's sort of

575
00:22:46,080 --> 00:22:48,559
similar ideas that

576
00:22:48,559 --> 00:22:50,640
underpin discrete log based proofs that

577
00:22:50,640 --> 00:22:52,840
have logarithmic size

578
00:22:52,840 --> 00:22:56,640
um so bulletproofs is one example of

579
00:22:56,640 --> 00:22:59,120
that and sort of based on an earlier

580
00:22:59,120 --> 00:23:00,480
paper from

581
00:23:00,480 --> 00:23:03,480
2016

582
00:23:04,799 --> 00:23:06,159
but

583
00:23:06,159 --> 00:23:09,360
i guess this work also shows that

584
00:23:09,360 --> 00:23:10,640
models are

585
00:23:10,640 --> 00:23:12,559
only good as as far as they actually

586
00:23:12,559 --> 00:23:15,120
describe reality there you need a little

587
00:23:15,120 --> 00:23:17,679
extra ingredient ingredient namely that

588
00:23:17,679 --> 00:23:19,520
also the group elements you use in

589
00:23:19,520 --> 00:23:21,840
peterson commitment to to commit to

590
00:23:21,840 --> 00:23:24,400
things are are key homomorphic

591
00:23:24,400 --> 00:23:25,600
um

592
00:23:25,600 --> 00:23:27,600
so so the idealized model would be a

593
00:23:27,600 --> 00:23:29,440
little different and i guess it just

594
00:23:29,440 --> 00:23:31,360
goes to show that it's not always easy

595
00:23:31,360 --> 00:23:34,720
to be a theoretician right

596
00:23:34,720 --> 00:23:37,440
there it's very nice to come up with

597
00:23:37,440 --> 00:23:40,799
abstract ideal models of what going on

598
00:23:40,799 --> 00:23:42,720
um i think it's great for building

599
00:23:42,720 --> 00:23:43,919
understanding

600
00:23:43,919 --> 00:23:44,799
um

601
00:23:44,799 --> 00:23:45,919
but but

602
00:23:45,919 --> 00:23:47,840
it's also clear that you know when we

603
00:23:47,840 --> 00:23:50,080
have new cryptography might be new

604
00:23:50,080 --> 00:23:51,919
things that we can

605
00:23:51,919 --> 00:23:54,080
use and that would again would have to

606
00:23:54,080 --> 00:23:56,000
go back and change the model to

607
00:23:56,000 --> 00:23:59,760
incorporate those new features

608
00:24:02,840 --> 00:24:04,720
um

609
00:24:04,720 --> 00:24:07,120
let me

610
00:24:07,200 --> 00:24:09,840
jump to an earlier model because this is

611
00:24:09,840 --> 00:24:12,080
certainly not the first construction of

612
00:24:12,080 --> 00:24:13,440
uh

613
00:24:13,440 --> 00:24:15,120
succinct

614
00:24:15,120 --> 00:24:18,320
proofs um

615
00:24:18,320 --> 00:24:19,760
and

616
00:24:19,760 --> 00:24:22,400
the first such constructions was by by

617
00:24:22,400 --> 00:24:25,120
killian in 92 um

618
00:24:25,120 --> 00:24:27,760
and and he used a different information

619
00:24:27,760 --> 00:24:30,559
theoretical model uh probabilistically

620
00:24:30,559 --> 00:24:32,559
checkable proofs

621
00:24:32,559 --> 00:24:35,039
um and these are really cool proofs it's

622
00:24:35,039 --> 00:24:38,000
uh so like you can prove it

623
00:24:38,000 --> 00:24:40,720
a theorem

624
00:24:41,360 --> 00:24:43,520
in a way such that the verify only needs

625
00:24:43,520 --> 00:24:46,400
to spot check that proof

626
00:24:46,400 --> 00:24:48,400
so typically the proof will be bigger

627
00:24:48,400 --> 00:24:49,919
than the instances that you want to

628
00:24:49,919 --> 00:24:51,600
prove but the advantage is that the

629
00:24:51,600 --> 00:24:53,360
verify can be really

630
00:24:53,360 --> 00:24:55,360
efficient because the verify only needs

631
00:24:55,360 --> 00:24:56,880
to check

632
00:24:56,880 --> 00:25:00,960
a few parts of that proof not everything

633
00:25:00,960 --> 00:25:03,679
so think of the model as the prover can

634
00:25:03,679 --> 00:25:05,840
commit to say

635
00:25:05,840 --> 00:25:06,720
n

636
00:25:06,720 --> 00:25:08,720
field elements and that's

637
00:25:08,720 --> 00:25:10,559
the proof

638
00:25:10,559 --> 00:25:12,880
and then the verify can come along and

639
00:25:12,880 --> 00:25:16,320
ask to see some of those field elements

640
00:25:16,320 --> 00:25:19,200
but only a few of them

641
00:25:19,200 --> 00:25:23,440
and the amazing thing in the pcp theorem

642
00:25:23,919 --> 00:25:24,960
is that

643
00:25:24,960 --> 00:25:27,039
you only need a small number of queries

644
00:25:27,039 --> 00:25:31,600
too to get overwhelming soundness

645
00:25:34,159 --> 00:25:35,520
okay so

646
00:25:35,520 --> 00:25:38,400
so what killian did was to compile this

647
00:25:38,400 --> 00:25:39,679
into a

648
00:25:39,679 --> 00:25:43,159
non um

649
00:25:43,200 --> 00:25:46,400
a succinct proof system um

650
00:25:46,400 --> 00:25:48,640
and and the tool to do that can be a

651
00:25:48,640 --> 00:25:50,240
collision resistant

652
00:25:50,240 --> 00:25:52,000
hash function so basically what you do

653
00:25:52,000 --> 00:25:54,400
is you just take the pcp

654
00:25:54,400 --> 00:25:56,480
uh you commit to all these elements in

655
00:25:56,480 --> 00:25:58,960
the pcp using a merkle tree

656
00:25:58,960 --> 00:26:00,640
and you send the root of that merkle

657
00:26:00,640 --> 00:26:02,080
tree to the

658
00:26:02,080 --> 00:26:03,919
verifier

659
00:26:03,919 --> 00:26:05,760
and then the verifier says okay i want

660
00:26:05,760 --> 00:26:08,158
to check

661
00:26:08,559 --> 00:26:11,679
these parts of the

662
00:26:11,679 --> 00:26:13,279
pcp

663
00:26:13,279 --> 00:26:14,720
and then you

664
00:26:14,720 --> 00:26:16,880
the proverb reveals those parts and the

665
00:26:16,880 --> 00:26:17,760
paths

666
00:26:17,760 --> 00:26:19,520
to the merkle root right and then the

667
00:26:19,520 --> 00:26:21,919
verify can verify that indeed those are

668
00:26:21,919 --> 00:26:23,840
the correct elements that

669
00:26:23,840 --> 00:26:26,240
he received

670
00:26:26,240 --> 00:26:28,720
so once you have a pcp you have this

671
00:26:28,720 --> 00:26:30,480
information there ready core it's

672
00:26:30,480 --> 00:26:32,960
actually a pretty simple construction

673
00:26:32,960 --> 00:26:35,520
you can use to build a succinct

674
00:26:35,520 --> 00:26:38,400
interactive argument

675
00:26:38,400 --> 00:26:40,400
and then you can make it non-interactive

676
00:26:40,400 --> 00:26:44,480
using the future heuristic

677
00:26:50,159 --> 00:26:52,960
okay another um

678
00:26:52,960 --> 00:26:55,440
information terrain model that has come

679
00:26:55,440 --> 00:26:56,960
into work is

680
00:26:56,960 --> 00:26:59,600
interactive oracle proofs

681
00:26:59,600 --> 00:27:00,760
and those are

682
00:27:00,760 --> 00:27:03,440
generalizations of probabilistically

683
00:27:03,440 --> 00:27:05,600
checkable proofs

684
00:27:05,600 --> 00:27:07,039
and the reason we need this

685
00:27:07,039 --> 00:27:08,400
generalization is because

686
00:27:08,400 --> 00:27:11,120
probabilistically checkable proofs are

687
00:27:11,120 --> 00:27:12,720
um

688
00:27:12,720 --> 00:27:15,440
are expensive to to compute so so

689
00:27:15,440 --> 00:27:18,840
typically the pcp will be larger than

690
00:27:18,840 --> 00:27:22,000
um the statement you want to prove is

691
00:27:22,000 --> 00:27:24,240
true

692
00:27:24,559 --> 00:27:26,559
and there may also be significant

693
00:27:26,559 --> 00:27:28,640
computation involved for the proverb to

694
00:27:28,640 --> 00:27:31,600
create the pcp

695
00:27:32,559 --> 00:27:34,720
interactive oracle proofs can be more

696
00:27:34,720 --> 00:27:37,279
efficient um

697
00:27:37,279 --> 00:27:40,720
so what the generalization says is

698
00:27:40,720 --> 00:27:42,799
it's essentially the same as a pcp but

699
00:27:42,799 --> 00:27:45,360
now there are multiple rounds where the

700
00:27:45,360 --> 00:27:48,720
prover can commit to elements

701
00:27:48,720 --> 00:27:51,520
so the prover commits to some elements

702
00:27:51,520 --> 00:27:53,679
okay there may be other interaction

703
00:27:53,679 --> 00:27:55,600
between the proof and verify then the

704
00:27:55,600 --> 00:27:56,799
prover can

705
00:27:56,799 --> 00:27:59,279
commit to the next batch of elements and

706
00:27:59,279 --> 00:28:01,360
so forth

707
00:28:01,360 --> 00:28:02,960
and during that

708
00:28:02,960 --> 00:28:05,200
time the verify

709
00:28:05,200 --> 00:28:07,840
query for indices again and see

710
00:28:07,840 --> 00:28:10,959
get those revealed

711
00:28:12,159 --> 00:28:15,120
okay and uh interactive oracle proves if

712
00:28:15,120 --> 00:28:17,120
they're public coin then you can use

713
00:28:17,120 --> 00:28:19,440
merkel trees and the future heuristics

714
00:28:19,440 --> 00:28:20,559
to make it

715
00:28:20,559 --> 00:28:23,279
into a snark

716
00:28:24,720 --> 00:28:26,320
so so this

717
00:28:26,320 --> 00:28:30,000
interactive model allows us some better

718
00:28:30,000 --> 00:28:31,679
efficiency but we still get

719
00:28:31,679 --> 00:28:35,760
non-interactive and very succinct proofs

720
00:28:35,760 --> 00:28:39,720
with the future heuristic

721
00:28:44,080 --> 00:28:46,080
okay so what is a

722
00:28:46,080 --> 00:28:48,640
broader landscape here right so i think

723
00:28:48,640 --> 00:28:51,120
what we're seeing is that there are now

724
00:28:51,120 --> 00:28:53,919
many different information theoretical

725
00:28:53,919 --> 00:28:56,799
models in play are not just touching

726
00:28:56,799 --> 00:28:58,799
some of those the hidden written random

727
00:28:58,799 --> 00:29:01,440
bits model the ideal vector

728
00:29:01,440 --> 00:29:03,679
linear commitments

729
00:29:03,679 --> 00:29:06,799
and pcps and interactive oracle proofs

730
00:29:06,799 --> 00:29:08,000
they're also

731
00:29:08,000 --> 00:29:10,559
models you can use for designated verify

732
00:29:10,559 --> 00:29:12,960
proofs linear interactive throughs and

733
00:29:12,960 --> 00:29:14,000
and for

734
00:29:14,000 --> 00:29:16,799
uh pairing-based snarks um

735
00:29:16,799 --> 00:29:19,760
getting non-interactive linear proofs um

736
00:29:19,760 --> 00:29:22,080
uh i will not have time to get into

737
00:29:22,080 --> 00:29:23,760
unfortunate tools so pairing-based

738
00:29:23,760 --> 00:29:25,760
snarks in in this

739
00:29:25,760 --> 00:29:27,360
presentation but

740
00:29:27,360 --> 00:29:30,080
the ideas are again some of the same

741
00:29:30,080 --> 00:29:31,600
that you can have

742
00:29:31,600 --> 00:29:33,600
some some group elements you can take

743
00:29:33,600 --> 00:29:35,600
linear combination of those that's just

744
00:29:35,600 --> 00:29:38,399
generic group operations and then in the

745
00:29:38,399 --> 00:29:41,520
end the verifier may multiply those and

746
00:29:41,520 --> 00:29:43,840
and check basically that quadratic

747
00:29:43,840 --> 00:29:46,880
equation holds over those uh committed

748
00:29:46,880 --> 00:29:49,679
field elements

749
00:29:49,760 --> 00:29:52,000
there are also many ways you can compile

750
00:29:52,000 --> 00:29:53,760
things right you can use trapdoor

751
00:29:53,760 --> 00:29:56,080
permutations as in the original

752
00:29:56,080 --> 00:29:58,480
uh non-interactive zero knowledge proofs

753
00:29:58,480 --> 00:30:00,960
you can use discrete log groups pairings

754
00:30:00,960 --> 00:30:03,279
collision resistant hash functions

755
00:30:03,279 --> 00:30:06,080
uh and so forth

756
00:30:06,080 --> 00:30:08,080
and it's not all of those combinations

757
00:30:08,080 --> 00:30:10,080
that that fit together right but you can

758
00:30:10,080 --> 00:30:12,159
see it's so like

759
00:30:12,159 --> 00:30:15,840
an enormous space of different possible

760
00:30:15,840 --> 00:30:18,399
combinations and i think for that reason

761
00:30:18,399 --> 00:30:19,520
also it's

762
00:30:19,520 --> 00:30:21,440
nice that people are

763
00:30:21,440 --> 00:30:23,760
increasingly trying to separate out the

764
00:30:23,760 --> 00:30:26,080
information theoretic core from the

765
00:30:26,080 --> 00:30:28,640
cryptographic compilation so you can

766
00:30:28,640 --> 00:30:30,399
analyze those

767
00:30:30,399 --> 00:30:33,399
independently

768
00:30:38,159 --> 00:30:39,600
okay so

769
00:30:39,600 --> 00:30:42,480
um one question you may ask then is how

770
00:30:42,480 --> 00:30:44,399
do these different information

771
00:30:44,399 --> 00:30:48,559
theoretical models relate to each other

772
00:30:48,559 --> 00:30:51,559
um

773
00:30:52,080 --> 00:30:54,880
and and in some cases uh

774
00:30:54,880 --> 00:30:56,080
you have

775
00:30:56,080 --> 00:30:57,919
information theoretic models where you

776
00:30:57,919 --> 00:31:00,240
can do more than in other information

777
00:31:00,240 --> 00:31:04,000
theoretically in some sense stronger

778
00:31:04,000 --> 00:31:06,880
and that makes it possible to make

779
00:31:06,880 --> 00:31:08,960
more compact and more efficient

780
00:31:08,960 --> 00:31:10,799
information theoretical proofs so the

781
00:31:10,799 --> 00:31:11,919
information

782
00:31:11,919 --> 00:31:15,120
theoretic core becomes

783
00:31:15,360 --> 00:31:17,279
better more efficient

784
00:31:17,279 --> 00:31:19,120
but then the price you pay is typically

785
00:31:19,120 --> 00:31:20,880
in the cryptography because then you

786
00:31:20,880 --> 00:31:23,840
need more sophisticated cryptography to

787
00:31:23,840 --> 00:31:26,159
instantiate this stronger information

788
00:31:26,159 --> 00:31:29,440
theoretical model

789
00:31:30,799 --> 00:31:33,360
um so i wanted to compare

790
00:31:33,360 --> 00:31:35,600
interactive linear commitments with the

791
00:31:35,600 --> 00:31:37,919
iops right

792
00:31:37,919 --> 00:31:39,519
so remember in

793
00:31:39,519 --> 00:31:42,399
interactive linear interactive

794
00:31:42,399 --> 00:31:44,960
commitments you could commit to batches

795
00:31:44,960 --> 00:31:46,960
of vectors

796
00:31:46,960 --> 00:31:49,120
and in the end the verify was allowed to

797
00:31:49,120 --> 00:31:50,399
ask for

798
00:31:50,399 --> 00:31:52,480
linear combinations of those committed

799
00:31:52,480 --> 00:31:54,960
vectors

800
00:31:55,039 --> 00:31:57,679
in iops you can just commit to field

801
00:31:57,679 --> 00:31:59,600
elements and then the verified can query

802
00:31:59,600 --> 00:32:01,120
some of those

803
00:32:01,120 --> 00:32:03,918
field elements

804
00:32:04,480 --> 00:32:07,760
um but you can see that the real

805
00:32:07,760 --> 00:32:09,919
models can relate to each other right

806
00:32:09,919 --> 00:32:11,279
you could actually

807
00:32:11,279 --> 00:32:12,960
instantiate the

808
00:32:12,960 --> 00:32:15,840
interactive oracle proofs in the

809
00:32:15,840 --> 00:32:17,840
interactive linear commitment model by

810
00:32:17,840 --> 00:32:18,960
encoding

811
00:32:18,960 --> 00:32:20,960
each fill field element in a vector and

812
00:32:20,960 --> 00:32:23,120
then query specifically for that

813
00:32:23,120 --> 00:32:25,200
vector right so if you issue a query

814
00:32:25,200 --> 00:32:27,200
which is zero for all the vectors and

815
00:32:27,200 --> 00:32:28,799
just one for one of the vectors they

816
00:32:28,799 --> 00:32:31,680
will give you that vector

817
00:32:31,680 --> 00:32:33,120
[Music]

818
00:32:33,120 --> 00:32:34,799
and then that way you would get

819
00:32:34,799 --> 00:32:36,159
basically what is

820
00:32:36,159 --> 00:32:38,880
that particular field element you can

821
00:32:38,880 --> 00:32:41,519
make some more efficient conversions but

822
00:32:41,519 --> 00:32:44,240
what it shows is that it is possible to

823
00:32:44,240 --> 00:32:45,200
uh

824
00:32:45,200 --> 00:32:46,480
um

825
00:32:46,480 --> 00:32:47,440
to

826
00:32:47,440 --> 00:32:49,840
make a conversion of an

827
00:32:49,840 --> 00:32:51,600
interactive oracle truth to something

828
00:32:51,600 --> 00:32:53,440
that's an interactive

829
00:32:53,440 --> 00:32:55,360
proofs in the interactive linear

830
00:32:55,360 --> 00:32:58,240
commitment model

831
00:32:58,799 --> 00:33:00,240
um

832
00:33:00,240 --> 00:33:01,840
it turns out that it also works the

833
00:33:01,840 --> 00:33:03,360
other way around you can actually

834
00:33:03,360 --> 00:33:05,440
compile

835
00:33:05,440 --> 00:33:07,760
the interactive linear commitment model

836
00:33:07,760 --> 00:33:11,840
into interactive oracle proofs

837
00:33:12,320 --> 00:33:15,440
and in order to do that you use a linear

838
00:33:15,440 --> 00:33:18,480
error correcting codes

839
00:33:18,480 --> 00:33:22,320
um so so just a reminder that a linear

840
00:33:22,320 --> 00:33:25,039
error correcting code takes

841
00:33:25,039 --> 00:33:28,960
k field elements uh and and maps it into

842
00:33:28,960 --> 00:33:31,760
um n field elements where n is a bit

843
00:33:31,760 --> 00:33:34,159
larger than k right so it sort of

844
00:33:34,159 --> 00:33:36,080
extends

845
00:33:36,080 --> 00:33:40,240
the word that you want to encode

846
00:33:40,240 --> 00:33:43,760
and we want um first of all that

847
00:33:43,760 --> 00:33:45,440
we want to have a linear hamming

848
00:33:45,440 --> 00:33:48,000
distance so if we had two distinct code

849
00:33:48,000 --> 00:33:49,039
works

850
00:33:49,039 --> 00:33:51,519
then they differ in many places so there

851
00:33:51,519 --> 00:33:53,200
are no codewords that are very close to

852
00:33:53,200 --> 00:33:55,679
each other they differ in many places

853
00:33:55,679 --> 00:33:58,480
when they're different

854
00:33:58,559 --> 00:34:00,880
second we want it to be linear so if you

855
00:34:00,880 --> 00:34:04,159
take a linear combination of

856
00:34:04,159 --> 00:34:08,719
two uh code words then you actually get

857
00:34:08,719 --> 00:34:11,359
the same as the encoding of that linear

858
00:34:11,359 --> 00:34:15,679
combination of the original message

859
00:34:16,000 --> 00:34:18,800
uh and then for efficiency uh it's

860
00:34:18,800 --> 00:34:21,199
actually interesting that some of these

861
00:34:21,199 --> 00:34:23,520
linear correcting codes that are very

862
00:34:23,520 --> 00:34:26,639
efficient can be computed with a linear

863
00:34:26,639 --> 00:34:30,399
number of field operations

864
00:34:32,719 --> 00:34:36,159
okay so um

865
00:34:36,159 --> 00:34:37,679
so the the

866
00:34:37,679 --> 00:34:40,560
compilation into ip and um here so like

867
00:34:40,560 --> 00:34:42,000
taking the

868
00:34:42,000 --> 00:34:44,960
core idea rather than the actual uh

869
00:34:44,960 --> 00:34:47,119
instantiation in the papers was

870
00:34:47,119 --> 00:34:49,040
discovered in

871
00:34:49,040 --> 00:34:51,679
two parallel works uh

872
00:34:51,679 --> 00:34:53,679
one known as a slighter and another

873
00:34:53,679 --> 00:34:55,359
would with

874
00:34:55,359 --> 00:34:58,639
people from from my group

875
00:34:58,880 --> 00:35:00,960
and the idea is to use

876
00:35:00,960 --> 00:35:02,880
error correcting codes

877
00:35:02,880 --> 00:35:05,200
so when in the

878
00:35:05,200 --> 00:35:06,880
interactive linear commitment model you

879
00:35:06,880 --> 00:35:09,359
want to commit to a vector of field

880
00:35:09,359 --> 00:35:12,640
elements what you do is you encode that

881
00:35:12,640 --> 00:35:14,960
with the linear error correcting code

882
00:35:14,960 --> 00:35:17,280
and you send those

883
00:35:17,280 --> 00:35:20,400
there's error corrected

884
00:35:20,480 --> 00:35:22,640
this code word and

885
00:35:22,640 --> 00:35:24,640
the field demonstration that could work

886
00:35:24,640 --> 00:35:25,440
to

887
00:35:25,440 --> 00:35:29,680
the interactive vocal proof model

888
00:35:29,680 --> 00:35:31,680
the verifier sends messages to to the

889
00:35:31,680 --> 00:35:33,839
prover then that just passes through the

890
00:35:33,839 --> 00:35:36,240
same with the prover sends messages to

891
00:35:36,240 --> 00:35:39,359
directly to the verify

892
00:35:39,359 --> 00:35:43,599
now this can go on for several rounds

893
00:35:43,599 --> 00:35:45,680
and in the end

894
00:35:45,680 --> 00:35:46,560
when

895
00:35:46,560 --> 00:35:47,359
uh

896
00:35:47,359 --> 00:35:50,000
the verifier wants to get so like

897
00:35:50,000 --> 00:35:50,720
uh

898
00:35:50,720 --> 00:35:51,440
in

899
00:35:51,440 --> 00:35:52,960
interactive linear commitment model

900
00:35:52,960 --> 00:35:56,240
would want to query for a set of linear

901
00:35:56,240 --> 00:35:58,640
combinations

902
00:35:58,640 --> 00:36:00,880
what happens in the interactive oracle

903
00:36:00,880 --> 00:36:03,200
proof model is that you just

904
00:36:03,200 --> 00:36:06,000
send the prover sends those

905
00:36:06,000 --> 00:36:08,000
linear combination just makes a claim

906
00:36:08,000 --> 00:36:11,280
that hey this is the the vectors that

907
00:36:11,280 --> 00:36:14,240
you were asking for

908
00:36:14,240 --> 00:36:16,400
and then there's a final step

909
00:36:16,400 --> 00:36:18,480
where the verifier

910
00:36:18,480 --> 00:36:20,000
and and

911
00:36:20,000 --> 00:36:21,920
sort of uses interactive oral proof

912
00:36:21,920 --> 00:36:24,800
model to to check that that answer from

913
00:36:24,800 --> 00:36:28,160
the proof is actually correct

914
00:36:30,400 --> 00:36:33,440
okay and i'll show on the next slide how

915
00:36:33,440 --> 00:36:34,400
how that

916
00:36:34,400 --> 00:36:37,119
works what what the real idea is here

917
00:36:37,119 --> 00:36:38,320
right so

918
00:36:38,320 --> 00:36:40,720
so here we have vector

919
00:36:40,720 --> 00:36:43,359
vectors a that the approver wants to to

920
00:36:43,359 --> 00:36:45,359
commit to

921
00:36:45,359 --> 00:36:47,680
and the proof would uh use the error

922
00:36:47,680 --> 00:36:49,520
correcting codes and and

923
00:36:49,520 --> 00:36:50,560
in the

924
00:36:50,560 --> 00:36:52,320
interactive oracle proof

925
00:36:52,320 --> 00:36:54,800
submit the field elements from those

926
00:36:54,800 --> 00:36:57,440
code words

927
00:36:57,839 --> 00:36:58,800
um

928
00:36:58,800 --> 00:37:00,720
in the interactive oracle proof the

929
00:37:00,720 --> 00:37:02,640
verifier has no clue what those field

930
00:37:02,640 --> 00:37:03,680
elements

931
00:37:03,680 --> 00:37:05,839
are but now they are committed right

932
00:37:05,839 --> 00:37:07,359
it's not something that the proofer can

933
00:37:07,359 --> 00:37:09,839
change

934
00:37:10,400 --> 00:37:12,160
now in order to check that those are

935
00:37:12,160 --> 00:37:13,440
actually

936
00:37:13,440 --> 00:37:15,839
real codewords and not just bogus field

937
00:37:15,839 --> 00:37:16,800
elements

938
00:37:16,800 --> 00:37:20,000
the verify can actually do a

939
00:37:20,000 --> 00:37:22,240
linear test so verifier

940
00:37:22,240 --> 00:37:24,400
proximity tests so the verify sends a

941
00:37:24,400 --> 00:37:26,240
random vector t

942
00:37:26,240 --> 00:37:28,000
and the prover reveals a linear

943
00:37:28,000 --> 00:37:32,720
combination corresponding this to this t

944
00:37:33,119 --> 00:37:35,119
and after the proof has done that the

945
00:37:35,119 --> 00:37:37,200
verifier can actually do some spot

946
00:37:37,200 --> 00:37:39,200
checking is that answered by the prover

947
00:37:39,200 --> 00:37:41,040
correct right and the way that the

948
00:37:41,040 --> 00:37:43,280
verify does that is basically to ask in

949
00:37:43,280 --> 00:37:44,400
vip

950
00:37:44,400 --> 00:37:46,480
i would like to see the field elements

951
00:37:46,480 --> 00:37:50,160
that correspond to some of the columns

952
00:37:50,160 --> 00:37:51,119
of this

953
00:37:51,119 --> 00:37:53,119
this matrix that the code would

954
00:37:53,119 --> 00:37:55,839
constitute

955
00:37:55,839 --> 00:37:58,640
and once the verifier sees those columns

956
00:37:58,640 --> 00:38:00,560
then the verify can

957
00:38:00,560 --> 00:38:03,200
himself

958
00:38:03,359 --> 00:38:05,680
use the error correcting code to compute

959
00:38:05,680 --> 00:38:06,800
the

960
00:38:06,800 --> 00:38:09,520
the code word that's supposed to

961
00:38:09,520 --> 00:38:12,640
resolve from the provers respondents

962
00:38:12,640 --> 00:38:15,280
but i also then use the columns to check

963
00:38:15,280 --> 00:38:16,960
and take the same linear combination of

964
00:38:16,960 --> 00:38:19,280
those columns and check that those

965
00:38:19,280 --> 00:38:21,440
parts of the code word are actually

966
00:38:21,440 --> 00:38:23,839
correct

967
00:38:24,079 --> 00:38:26,640
and it turns out if there's any of these

968
00:38:26,640 --> 00:38:28,800
code words that the group has committed

969
00:38:28,800 --> 00:38:30,560
to which is not really a code word but

970
00:38:30,560 --> 00:38:32,640
just a focus thing that's far from the

971
00:38:32,640 --> 00:38:33,680
code

972
00:38:33,680 --> 00:38:36,240
then that's very likely to be uncovered

973
00:38:36,240 --> 00:38:38,240
by the proximity test

974
00:38:38,240 --> 00:38:39,839
and furthermore if there are any of

975
00:38:39,839 --> 00:38:42,880
those columns that are have false then

976
00:38:42,880 --> 00:38:45,280
that's also likely to be

977
00:38:45,280 --> 00:38:47,839
discovered

978
00:38:48,640 --> 00:38:51,359
and in terms of the so like the response

979
00:38:51,359 --> 00:38:54,240
to a query a linear combination of those

980
00:38:54,240 --> 00:38:55,839
limits that the

981
00:38:55,839 --> 00:38:57,920
verify wants then it's exactly the same

982
00:38:57,920 --> 00:39:00,560
model you take the corresponding

983
00:39:00,560 --> 00:39:02,800
linear combination the prover sends that

984
00:39:02,800 --> 00:39:05,359
to the verifier and then the verify uses

985
00:39:05,359 --> 00:39:07,280
the opened columns to check whether that

986
00:39:07,280 --> 00:39:10,240
response is correct

987
00:39:10,320 --> 00:39:12,880
so in this way we can can actually use

988
00:39:12,880 --> 00:39:13,599
the

989
00:39:13,599 --> 00:39:16,480
interactive oracle proofs to compile a

990
00:39:16,480 --> 00:39:18,480
proof in the

991
00:39:18,480 --> 00:39:22,240
interactive linear commitment model

992
00:39:27,520 --> 00:39:30,320
okay um

993
00:39:30,720 --> 00:39:33,760
so the interesting thing here is that

994
00:39:33,760 --> 00:39:36,240
in the interactive oracle

995
00:39:36,240 --> 00:39:37,200
proofs

996
00:39:37,200 --> 00:39:38,320
um

997
00:39:38,320 --> 00:39:42,560
we usually don't use um

998
00:39:42,560 --> 00:39:44,800
group elements and and rely on the

999
00:39:44,800 --> 00:39:47,359
discrete logarithm problem right this is

1000
00:39:47,359 --> 00:39:50,320
a model that's been designed to actually

1001
00:39:50,320 --> 00:39:52,640
work with with hash functions

1002
00:39:52,640 --> 00:39:54,880
um so you do

1003
00:39:54,880 --> 00:39:58,160
merkle trees you hash some things

1004
00:39:58,160 --> 00:40:01,520
and then later on you repeal some paths

1005
00:40:01,520 --> 00:40:05,280
from from those merkle roots

1006
00:40:05,680 --> 00:40:07,440
and we can do that

1007
00:40:07,440 --> 00:40:08,880
as well here

1008
00:40:08,880 --> 00:40:11,520
there's a slide optimization so

1009
00:40:11,520 --> 00:40:13,760
so basically the way it works is that

1010
00:40:13,760 --> 00:40:15,040
the prover

1011
00:40:15,040 --> 00:40:17,280
whenever it has a batch of vectors that

1012
00:40:17,280 --> 00:40:19,280
she wants to commit to

1013
00:40:19,280 --> 00:40:22,640
she applies the error correcting

1014
00:40:22,640 --> 00:40:24,800
code function to them

1015
00:40:24,800 --> 00:40:26,160
gets a

1016
00:40:26,160 --> 00:40:30,079
a bunch of row vectors hashes those

1017
00:40:30,079 --> 00:40:32,319
columns that result from that

1018
00:40:32,319 --> 00:40:34,319
right and that commits to her to those

1019
00:40:34,319 --> 00:40:36,720
columns and then when she has the next

1020
00:40:36,720 --> 00:40:38,480
batch of row vectors you also applies

1021
00:40:38,480 --> 00:40:39,839
the error correcting code to it and

1022
00:40:39,839 --> 00:40:42,160
hashes and columns and so forth so that

1023
00:40:42,160 --> 00:40:44,640
way you should commit to all of those

1024
00:40:44,640 --> 00:40:47,200
code words

1025
00:40:47,200 --> 00:40:49,200
and whenever the verifier comes along

1026
00:40:49,200 --> 00:40:51,119
and wants to spot

1027
00:40:51,119 --> 00:40:53,200
check some of those columns right then

1028
00:40:53,200 --> 00:40:56,240
she just opens those hashes and

1029
00:40:56,240 --> 00:40:58,000
reveals the the

1030
00:40:58,000 --> 00:40:59,280
field elements

1031
00:40:59,280 --> 00:41:01,680
in them

1032
00:41:03,520 --> 00:41:05,839
so from the verifiers perspective it's

1033
00:41:05,839 --> 00:41:08,880
just a question of checking those

1034
00:41:08,880 --> 00:41:11,280
spot checked columns

1035
00:41:11,280 --> 00:41:13,760
and check that the response is correct

1036
00:41:13,760 --> 00:41:16,720
right and then check the

1037
00:41:16,720 --> 00:41:18,720
original interactive linear commitment

1038
00:41:18,720 --> 00:41:20,480
proof with respect to that

1039
00:41:20,480 --> 00:41:21,839
which is now

1040
00:41:21,839 --> 00:41:23,680
known to be a correct response from the

1041
00:41:23,680 --> 00:41:25,280
prover that it really is this linear

1042
00:41:25,280 --> 00:41:28,400
combination of vectors

1043
00:41:31,520 --> 00:41:33,440
okay so let's think a little about what

1044
00:41:33,440 --> 00:41:36,480
what this buys us

1045
00:41:36,480 --> 00:41:39,280
and in terms of efficiency what we get

1046
00:41:39,280 --> 00:41:40,560
is actually

1047
00:41:40,560 --> 00:41:44,160
a linear number of field operations um

1048
00:41:44,160 --> 00:41:46,960
and why is that um

1049
00:41:46,960 --> 00:41:48,720
so think of it about this from the

1050
00:41:48,720 --> 00:41:49,920
prover

1051
00:41:49,920 --> 00:41:52,079
perspective right

1052
00:41:52,079 --> 00:41:54,800
so um the error correcting code is

1053
00:41:54,800 --> 00:41:56,640
linear so it just takes

1054
00:41:56,640 --> 00:41:58,880
linear time so that doesn't really give

1055
00:41:58,880 --> 00:42:00,960
you anything except for a constant

1056
00:42:00,960 --> 00:42:03,359
overhead

1057
00:42:03,359 --> 00:42:06,079
there are hash functions

1058
00:42:06,079 --> 00:42:09,359
which are linear time computable

1059
00:42:09,359 --> 00:42:11,040
so so again

1060
00:42:11,040 --> 00:42:12,960
committing to columns doesn't give you

1061
00:42:12,960 --> 00:42:14,640
any overhead

1062
00:42:14,640 --> 00:42:17,119
and what you end up with is actually a

1063
00:42:17,119 --> 00:42:20,319
linear time proof

1064
00:42:20,720 --> 00:42:23,200
um i've put in this table here a

1065
00:42:23,200 --> 00:42:26,480
comparison um

1066
00:42:26,480 --> 00:42:28,400
what you had

1067
00:42:28,400 --> 00:42:31,920
in the past was um based on the discrete

1068
00:42:31,920 --> 00:42:35,040
log problem you could do um

1069
00:42:35,040 --> 00:42:37,440
linear time approvals but where it was a

1070
00:42:37,440 --> 00:42:39,680
linear number of exponentiations right

1071
00:42:39,680 --> 00:42:43,200
and then you get root n elements

1072
00:42:43,200 --> 00:42:45,040
if you do bulletproof

1073
00:42:45,040 --> 00:42:46,400
then you get

1074
00:42:46,400 --> 00:42:47,920
better communication than just a

1075
00:42:47,920 --> 00:42:50,240
logarithmic number of elements

1076
00:42:50,240 --> 00:42:51,920
um

1077
00:42:51,920 --> 00:42:54,319
and what you get here now this

1078
00:42:54,319 --> 00:42:56,720
compiler technique is is

1079
00:42:56,720 --> 00:42:58,480
elements in the communication right so

1080
00:42:58,480 --> 00:43:00,960
it's succinct but the prover is truly

1081
00:43:00,960 --> 00:43:03,359
linear right there's no exponentiation

1082
00:43:03,359 --> 00:43:04,880
then exponentiations are actually

1083
00:43:04,880 --> 00:43:06,319
expensive right

1084
00:43:06,319 --> 00:43:08,000
but here it's sort of like apples to

1085
00:43:08,000 --> 00:43:10,160
apples

1086
00:43:10,160 --> 00:43:11,839
you're proving something about field

1087
00:43:11,839 --> 00:43:14,240
operations and the cost is measured in

1088
00:43:14,240 --> 00:43:16,480
field operations so it really is true

1089
00:43:16,480 --> 00:43:18,720
linear time

1090
00:43:18,720 --> 00:43:21,760
uh and in a later work with um

1091
00:43:21,760 --> 00:43:23,280
with alessandro

1092
00:43:23,280 --> 00:43:26,880
casa jonathan boodle we've sort of like

1093
00:43:26,880 --> 00:43:29,680
reduced the communication even more to

1094
00:43:29,680 --> 00:43:32,640
to basically being an arbitrary root a

1095
00:43:32,640 --> 00:43:34,000
constant root

1096
00:43:34,000 --> 00:43:35,280
of uh

1097
00:43:35,280 --> 00:43:36,720
of the size of the circuit that you

1098
00:43:36,720 --> 00:43:40,359
would want to prove

1099
00:43:41,119 --> 00:43:42,480
um

1100
00:43:42,480 --> 00:43:44,319
okay so there's a

1101
00:43:44,319 --> 00:43:46,880
couple of uh i'll sort of go into a

1102
00:43:46,880 --> 00:43:49,760
little bit of a rant here um

1103
00:43:49,760 --> 00:43:51,599
because i think we are now really

1104
00:43:51,599 --> 00:43:55,200
pushing efficiency of these

1105
00:43:55,200 --> 00:43:58,720
snarks and other proof systems um

1106
00:43:58,720 --> 00:43:59,680
and

1107
00:43:59,680 --> 00:44:02,960
in olden days it was very common to see

1108
00:44:02,960 --> 00:44:05,520
this is linear without specifying what

1109
00:44:05,520 --> 00:44:08,560
is the unit of computation um i think

1110
00:44:08,560 --> 00:44:10,160
we're now living in a world where we're

1111
00:44:10,160 --> 00:44:12,480
really trying to eke out all the factors

1112
00:44:12,480 --> 00:44:14,319
that that we can get all the savings we

1113
00:44:14,319 --> 00:44:15,520
can get

1114
00:44:15,520 --> 00:44:17,599
and this is important and it really

1115
00:44:17,599 --> 00:44:20,800
makes a difference

1116
00:44:21,280 --> 00:44:22,800
um

1117
00:44:22,800 --> 00:44:25,839
so so so clearly uh

1118
00:44:25,839 --> 00:44:26,800
as a

1119
00:44:26,800 --> 00:44:28,400
as opposed to doing a linear number of

1120
00:44:28,400 --> 00:44:30,560
exponentiation if you do a linear number

1121
00:44:30,560 --> 00:44:32,720
of field operation that's going to be a

1122
00:44:32,720 --> 00:44:35,440
a significant saving

1123
00:44:35,440 --> 00:44:37,440
now i don't want to claim this is a

1124
00:44:37,440 --> 00:44:40,400
practical work because the big o is

1125
00:44:40,400 --> 00:44:42,640
actually pretty big and and if you want

1126
00:44:42,640 --> 00:44:44,480
the practical invitation then you should

1127
00:44:44,480 --> 00:44:48,280
go to the here

1128
00:44:51,599 --> 00:44:53,280
um

1129
00:44:53,280 --> 00:44:56,160
speaking of practice um

1130
00:44:56,160 --> 00:44:59,119
so one thing we were looking at then was

1131
00:44:59,119 --> 00:45:00,000
uh

1132
00:45:00,000 --> 00:45:02,720
can we apply this this type of proof

1133
00:45:02,720 --> 00:45:04,400
technique to

1134
00:45:04,400 --> 00:45:07,520
more practical questions and we settled

1135
00:45:07,520 --> 00:45:10,480
on uh verifiable computation right so

1136
00:45:10,480 --> 00:45:12,160
here the

1137
00:45:12,160 --> 00:45:15,119
statement is essentially think of

1138
00:45:15,119 --> 00:45:17,200
outsourcing to the cloud here's a

1139
00:45:17,200 --> 00:45:19,520
program here's some input and the cloud

1140
00:45:19,520 --> 00:45:21,599
says okay here is the output from that

1141
00:45:21,599 --> 00:45:23,359
program right now you want to verify

1142
00:45:23,359 --> 00:45:25,040
whether that's correct

1143
00:45:25,040 --> 00:45:27,040
and there may or may not be also some

1144
00:45:27,040 --> 00:45:29,680
secret input that the cloud puts into

1145
00:45:29,680 --> 00:45:33,399
this execution

1146
00:45:34,160 --> 00:45:36,960
what we have right now is we have very

1147
00:45:36,960 --> 00:45:39,359
succinct and easy to verify snarks right

1148
00:45:39,359 --> 00:45:41,200
so if you use pairing-based snarks you

1149
00:45:41,200 --> 00:45:43,839
can get down and so like the order for

1150
00:45:43,839 --> 00:45:47,200
a few kilobits um

1151
00:45:47,200 --> 00:45:48,480
and have

1152
00:45:48,480 --> 00:45:50,880
really fast verification of the snacks

1153
00:45:50,880 --> 00:45:53,599
right so the main bottleneck nowadays is

1154
00:45:53,599 --> 00:45:55,520
the proven the time that it takes for

1155
00:45:55,520 --> 00:45:57,119
the prover to prove

1156
00:45:57,119 --> 00:45:57,920
uh

1157
00:45:57,920 --> 00:46:00,920
statement

1158
00:46:01,359 --> 00:46:03,359
so what we did was so like look at this

1159
00:46:03,359 --> 00:46:05,119
from a theoretical perspective right so

1160
00:46:05,119 --> 00:46:06,079
we picked

1161
00:46:06,079 --> 00:46:08,800
a model for program execution and we

1162
00:46:08,800 --> 00:46:11,119
settled on a model that's been used

1163
00:46:11,119 --> 00:46:13,359
before the tiny model which is

1164
00:46:13,359 --> 00:46:15,920
essentially an assembly language

1165
00:46:15,920 --> 00:46:18,720
that allows some small set of operations

1166
00:46:18,720 --> 00:46:19,680
over

1167
00:46:19,680 --> 00:46:20,640
uh

1168
00:46:20,640 --> 00:46:23,598
over some words

1169
00:46:23,920 --> 00:46:26,560
and and then we rewrite the verification

1170
00:46:26,560 --> 00:46:29,359
of that tiny ramp program as constraints

1171
00:46:29,359 --> 00:46:30,640
in the field and prove that those

1172
00:46:30,640 --> 00:46:32,720
constraints are satisfied so there's

1173
00:46:32,720 --> 00:46:35,760
sort of an embedding of those words into

1174
00:46:35,760 --> 00:46:37,920
a field and then proving that that

1175
00:46:37,920 --> 00:46:42,000
embedding satisfy some constraints

1176
00:46:42,000 --> 00:46:44,400
and what it gives us is actually a snark

1177
00:46:44,400 --> 00:46:48,000
with almost linear time right so um

1178
00:46:48,000 --> 00:46:50,240
so so if you have uh

1179
00:46:50,240 --> 00:46:52,480
time t computation

1180
00:46:52,480 --> 00:46:56,800
so t tiny ram operations then the prover

1181
00:46:56,800 --> 00:46:57,760
uses

1182
00:46:57,760 --> 00:46:59,760
a super linear but an arbitrary small

1183
00:46:59,760 --> 00:47:01,839
super linear number of tiny ram

1184
00:47:01,839 --> 00:47:03,359
operations

1185
00:47:03,359 --> 00:47:05,920
and it's also succinct to inherit from

1186
00:47:05,920 --> 00:47:08,240
from before that it's basically a root t

1187
00:47:08,240 --> 00:47:10,560
field elements that it

1188
00:47:10,560 --> 00:47:13,040
that you have to send

1189
00:47:13,040 --> 00:47:15,200
and you get negligible

1190
00:47:15,200 --> 00:47:18,000
soundness error

1191
00:47:18,000 --> 00:47:18,720
now

1192
00:47:18,720 --> 00:47:21,280
it's interesting when you

1193
00:47:21,280 --> 00:47:24,720
so like as theoreticians try to look at

1194
00:47:24,720 --> 00:47:26,319
practical problem right one of the

1195
00:47:26,319 --> 00:47:28,319
things we were thinking a lot about is

1196
00:47:28,319 --> 00:47:30,640
what is the right word size right is it

1197
00:47:30,640 --> 00:47:33,200
so two bits if the 64 bits or is it

1198
00:47:33,200 --> 00:47:35,119
something else

1199
00:47:35,119 --> 00:47:36,960
and and we found that the right

1200
00:47:36,960 --> 00:47:39,440
theoretical model would be to say it's

1201
00:47:39,440 --> 00:47:41,280
basically the logarithm of the memory

1202
00:47:41,280 --> 00:47:42,960
right you want the words to be able to

1203
00:47:42,960 --> 00:47:46,960
address any point in memory

1204
00:47:50,880 --> 00:47:53,280
in terms of time this is about as good

1205
00:47:53,280 --> 00:47:54,960
as it gets right we could hope for

1206
00:47:54,960 --> 00:47:58,319
something that's true linear time uh so

1207
00:47:58,319 --> 00:47:59,680
so you basically have linear number of

1208
00:47:59,680 --> 00:48:02,160
tiny ram operations for linear number of

1209
00:48:02,160 --> 00:48:04,399
uh

1210
00:48:05,359 --> 00:48:08,160
a computation which is t tiny ram

1211
00:48:08,160 --> 00:48:10,960
operations uh but again importantly here

1212
00:48:10,960 --> 00:48:13,280
right we're really comparing apples to

1213
00:48:13,280 --> 00:48:16,480
apples right if we are measuring

1214
00:48:16,480 --> 00:48:17,839
computation

1215
00:48:17,839 --> 00:48:20,640
so like of the program in in tiny ram

1216
00:48:20,640 --> 00:48:23,680
operations then we should also measure

1217
00:48:23,680 --> 00:48:26,319
uh the comp the computation of the proof

1218
00:48:26,319 --> 00:48:28,160
with the same measure so you can sort

1219
00:48:28,160 --> 00:48:30,319
like see clearly how they compare to

1220
00:48:30,319 --> 00:48:32,480
each other

1221
00:48:32,480 --> 00:48:34,319
now i'm not sure i'm so happy about the

1222
00:48:34,319 --> 00:48:36,640
sound he's here right again as a

1223
00:48:36,640 --> 00:48:38,720
theoretician you're saying hey the sun

1224
00:48:38,720 --> 00:48:41,280
has era is negligible that's great right

1225
00:48:41,280 --> 00:48:45,599
but in reality what it is it's uh

1226
00:48:45,599 --> 00:48:47,760
determined by by born over the field

1227
00:48:47,760 --> 00:48:49,520
size

1228
00:48:49,520 --> 00:48:50,640
and

1229
00:48:50,640 --> 00:48:52,319
and the reason we get this

1230
00:48:52,319 --> 00:48:54,880
super constant overhead because the

1231
00:48:54,880 --> 00:48:57,599
field size should be super super

1232
00:48:57,599 --> 00:48:59,040
logarithmic

1233
00:48:59,040 --> 00:49:01,599
in the security parameter

1234
00:49:01,599 --> 00:49:03,359
right and then you get negligible

1235
00:49:03,359 --> 00:49:06,160
soundness error but that

1236
00:49:06,160 --> 00:49:07,119
that

1237
00:49:07,119 --> 00:49:09,680
is uh so like if you're a practitioner

1238
00:49:09,680 --> 00:49:11,119
right you would so like more look at

1239
00:49:11,119 --> 00:49:12,800
water what are those concrete numbers

1240
00:49:12,800 --> 00:49:14,559
right and if you get one to have like i

1241
00:49:14,559 --> 00:49:17,599
know two to the minus security parameter

1242
00:49:17,599 --> 00:49:19,119
uh soundness error and then you would

1243
00:49:19,119 --> 00:49:21,040
actually have to do some repetition of

1244
00:49:21,040 --> 00:49:25,279
this proven and the cost would go up

1245
00:49:27,200 --> 00:49:29,200
okay so this is like

1246
00:49:29,200 --> 00:49:31,599
sort of a very

1247
00:49:31,599 --> 00:49:33,680
practice oriented uh

1248
00:49:33,680 --> 00:49:35,280
result and i think it says some

1249
00:49:35,280 --> 00:49:36,960
interesting theoretical things about

1250
00:49:36,960 --> 00:49:38,000
practice

1251
00:49:38,000 --> 00:49:39,359
um

1252
00:49:39,359 --> 00:49:41,440
if you look at so like the constants

1253
00:49:41,440 --> 00:49:43,280
involved and

1254
00:49:43,280 --> 00:49:45,359
they do blow up right and it's not

1255
00:49:45,359 --> 00:49:47,119
something you would want to

1256
00:49:47,119 --> 00:49:51,280
implement just as as written here

1257
00:49:52,800 --> 00:49:54,400
okay so let me

1258
00:49:54,400 --> 00:49:55,520
jump to

1259
00:49:55,520 --> 00:49:58,720
to the conclusion here i sort of

1260
00:49:58,720 --> 00:50:00,880
considered myself a theoretician but

1261
00:50:00,880 --> 00:50:03,599
practice oriented one of those

1262
00:50:03,599 --> 00:50:05,119
um

1263
00:50:05,119 --> 00:50:07,520
so so i think we are now

1264
00:50:07,520 --> 00:50:08,559
seeing

1265
00:50:08,559 --> 00:50:10,640
an enormous amount of work

1266
00:50:10,640 --> 00:50:13,359
when it comes to snarks

1267
00:50:13,359 --> 00:50:15,200
and one of those directions we see

1268
00:50:15,200 --> 00:50:17,200
really pushing is so like towards

1269
00:50:17,200 --> 00:50:19,359
optimal efficiency right can you get

1270
00:50:19,359 --> 00:50:21,119
true linear time

1271
00:50:21,119 --> 00:50:23,760
provers

1272
00:50:24,319 --> 00:50:25,359
and how

1273
00:50:25,359 --> 00:50:27,040
how far can you push down also the

1274
00:50:27,040 --> 00:50:29,280
constants here right

1275
00:50:29,280 --> 00:50:31,200
um and there's some interesting things

1276
00:50:31,200 --> 00:50:33,520
that have come up when we've been

1277
00:50:33,520 --> 00:50:36,000
working this direction which don't come

1278
00:50:36,000 --> 00:50:37,920
up when you have other overheads that

1279
00:50:37,920 --> 00:50:38,880
sort like

1280
00:50:38,880 --> 00:50:40,559
um

1281
00:50:40,559 --> 00:50:43,359
overshadow

1282
00:50:43,440 --> 00:50:46,480
the efficient these uh considerations so

1283
00:50:46,480 --> 00:50:48,800
one thing that came up in in the latest

1284
00:50:48,800 --> 00:50:50,400
paper with the

1285
00:50:50,400 --> 00:50:52,559
jonathan butland and sander kiersen

1286
00:50:52,559 --> 00:50:55,119
where we got done to to constant root

1287
00:50:55,119 --> 00:50:57,440
communication was that

1288
00:50:57,440 --> 00:50:59,520
a true linear time proofer cannot run a

1289
00:50:59,520 --> 00:51:01,760
sorting algorithm so we wanted to sort

1290
00:51:01,760 --> 00:51:03,920
some elements we could not do that

1291
00:51:03,920 --> 00:51:06,480
because that would take more than linear

1292
00:51:06,480 --> 00:51:08,880
time to to sort them right and we had to

1293
00:51:08,880 --> 00:51:11,359
do that in a different way

1294
00:51:11,359 --> 00:51:13,359
so there's a lot of things that you have

1295
00:51:13,359 --> 00:51:15,119
to be really careful about when you're

1296
00:51:15,119 --> 00:51:17,760
getting pushing so much in efficiency

1297
00:51:17,760 --> 00:51:19,200
and i think we're getting to the point

1298
00:51:19,200 --> 00:51:20,400
where

1299
00:51:20,400 --> 00:51:22,079
we probably need to think about what is

1300
00:51:22,079 --> 00:51:25,599
the communication computation

1301
00:51:25,599 --> 00:51:27,760
model that we are building on and so

1302
00:51:27,760 --> 00:51:29,280
like does that match

1303
00:51:29,280 --> 00:51:31,440
practice right and and are there sort of

1304
00:51:31,440 --> 00:51:32,559
like

1305
00:51:32,559 --> 00:51:37,839
on unseen uh overheads in in those

1306
00:51:38,319 --> 00:51:40,319
the other thing i think we need to be is

1307
00:51:40,319 --> 00:51:42,800
very careful when we account for cost

1308
00:51:42,800 --> 00:51:45,119
right a big annotation is uh is great

1309
00:51:45,119 --> 00:51:47,119
because it simplifies

1310
00:51:47,119 --> 00:51:49,119
reading things but it's also very vague

1311
00:51:49,119 --> 00:51:50,640
right and if you have like a truly

1312
00:51:50,640 --> 00:51:52,319
practical scheme i don't think you

1313
00:51:52,319 --> 00:51:54,800
should be using bigger notation so like

1314
00:51:54,800 --> 00:51:56,240
use some concrete

1315
00:51:56,240 --> 00:51:57,920
numbers

1316
00:51:57,920 --> 00:52:00,000
and i think for for

1317
00:52:00,000 --> 00:52:02,240
schemes that you you want to push for

1318
00:52:02,240 --> 00:52:04,400
for the efficiency i think it's also

1319
00:52:04,400 --> 00:52:06,640
really important to have the the units

1320
00:52:06,640 --> 00:52:09,119
there is we're talking about

1321
00:52:09,119 --> 00:52:11,839
group exponentiation bits kilobytes

1322
00:52:11,839 --> 00:52:13,839
hashes field operations or whatever

1323
00:52:13,839 --> 00:52:15,920
right because that really does

1324
00:52:15,920 --> 00:52:18,960
matter right and and i have to say i get

1325
00:52:18,960 --> 00:52:20,480
so like again

1326
00:52:20,480 --> 00:52:22,319
ranting a bit here right but i get very

1327
00:52:22,319 --> 00:52:24,319
annoyed when i see a paper that says

1328
00:52:24,319 --> 00:52:27,040
this is linear time or this is linear

1329
00:52:27,040 --> 00:52:29,839
communication without specifying

1330
00:52:29,839 --> 00:52:33,200
with which unit it is linear right

1331
00:52:33,200 --> 00:52:35,119
and and i would like to also see that

1332
00:52:35,119 --> 00:52:36,720
that really compares i mean if we're

1333
00:52:36,720 --> 00:52:38,640
talking linear time is it linear time

1334
00:52:38,640 --> 00:52:41,280
compared to the time it would just

1335
00:52:41,280 --> 00:52:43,599
take to verify the witness directly or

1336
00:52:43,599 --> 00:52:47,839
is it linear compared to something else

1337
00:52:49,680 --> 00:52:52,079
and then i think it's it's uh

1338
00:52:52,079 --> 00:52:54,319
exciting that it's a field where we're

1339
00:52:54,319 --> 00:52:56,720
seeing so much adoption now especially

1340
00:52:56,720 --> 00:52:59,680
in blockchain space right

1341
00:52:59,680 --> 00:53:02,079
and i think as we push towards practice

1342
00:53:02,079 --> 00:53:04,240
i think theory is still

1343
00:53:04,240 --> 00:53:05,680
really important for understanding

1344
00:53:05,680 --> 00:53:08,319
what's going on uh and also for getting

1345
00:53:08,319 --> 00:53:11,520
ideas for building proof systems um

1346
00:53:11,520 --> 00:53:14,000
so so i like this direction that people

1347
00:53:14,000 --> 00:53:15,920
have suggested that we should really try

1348
00:53:15,920 --> 00:53:16,880
to

1349
00:53:16,880 --> 00:53:18,880
extract the information serrated models

1350
00:53:18,880 --> 00:53:20,480
and understand what's going on there

1351
00:53:20,480 --> 00:53:23,280
right and and as we saw we actually had

1352
00:53:23,280 --> 00:53:24,960
sort of like an information theoretic

1353
00:53:24,960 --> 00:53:27,040
model derived from the discrete log

1354
00:53:27,040 --> 00:53:28,800
world but it turned out you could

1355
00:53:28,800 --> 00:53:31,599
compile that in in with hash functions

1356
00:53:31,599 --> 00:53:33,119
right and actually get something really

1357
00:53:33,119 --> 00:53:35,920
efficient out of it

1358
00:53:35,920 --> 00:53:39,119
um but as we push towards practice again

1359
00:53:39,119 --> 00:53:41,599
i think it's it's not always that clear

1360
00:53:41,599 --> 00:53:44,240
easy to to model right i mean

1361
00:53:44,240 --> 00:53:46,640
from a theoretical perspective

1362
00:53:46,640 --> 00:53:48,880
what is the computer's word size is it a

1363
00:53:48,880 --> 00:53:51,200
constant or is it logarithmic in in the

1364
00:53:51,200 --> 00:53:53,520
memory for instance

1365
00:53:53,520 --> 00:53:54,559
um

1366
00:53:54,559 --> 00:53:58,800
and i guess here really the proof is in

1367
00:53:58,800 --> 00:54:01,280
in the pudding right i mean i think now

1368
00:54:01,280 --> 00:54:03,280
we're seeing a lot more papers that also

1369
00:54:03,280 --> 00:54:05,520
come with implementations right and

1370
00:54:05,520 --> 00:54:07,520
those implementation you could see on a

1371
00:54:07,520 --> 00:54:10,160
real world computer what is the time it

1372
00:54:10,160 --> 00:54:12,480
takes to

1373
00:54:12,480 --> 00:54:14,079
to prove something that you you won't

1374
00:54:14,079 --> 00:54:17,680
really care about in practice

1375
00:54:17,680 --> 00:54:18,880
um

1376
00:54:18,880 --> 00:54:23,400
okay thank you for for your attention

1377
00:54:25,920 --> 00:54:28,240
thank you jens uh really interesting and

1378
00:54:28,240 --> 00:54:30,640
great talk um we have

1379
00:54:30,640 --> 00:54:34,640
yes let's uh give a virtual applause

1380
00:54:34,640 --> 00:54:35,440
um

1381
00:54:35,440 --> 00:54:37,760
we have several minutes for for any

1382
00:54:37,760 --> 00:54:39,920
questions from the audience um let me

1383
00:54:39,920 --> 00:54:41,740
check the

1384
00:54:41,740 --> 00:54:44,400
[Music]

1385
00:54:44,400 --> 00:54:45,390
check the

1386
00:54:45,390 --> 00:54:46,640
[Music]

1387
00:54:46,640 --> 00:54:49,839
zoop as well as anything uh if you could

1388
00:54:49,839 --> 00:54:51,119
raise your hand

1389
00:54:51,119 --> 00:54:54,000
or just pipe up

1390
00:54:54,000 --> 00:54:58,440
unmute yourself and ask questions

1391
00:55:14,640 --> 00:55:16,799
so i'll start with one question which is

1392
00:55:16,799 --> 00:55:18,079
um

1393
00:55:18,079 --> 00:55:21,440
you spoke about the compilation from uh

1394
00:55:21,440 --> 00:55:23,599
tiny ram to then these constraint

1395
00:55:23,599 --> 00:55:24,640
systems

1396
00:55:24,640 --> 00:55:26,480
and then um

1397
00:55:26,480 --> 00:55:27,200
the

1398
00:55:27,200 --> 00:55:29,359
the various proof systems are designed

1399
00:55:29,359 --> 00:55:30,400
to prove

1400
00:55:30,400 --> 00:55:31,680
uh that all the constraints are

1401
00:55:31,680 --> 00:55:34,480
satisfied right um

1402
00:55:34,480 --> 00:55:36,000
and i imagine there's a good deal of

1403
00:55:36,000 --> 00:55:39,440
work also in a compilation from

1404
00:55:39,440 --> 00:55:40,400
um

1405
00:55:40,400 --> 00:55:42,880
you know human readable languages or or

1406
00:55:42,880 --> 00:55:45,359
friendly languages to these constraint

1407
00:55:45,359 --> 00:55:46,480
systems

1408
00:55:46,480 --> 00:55:47,359
um

1409
00:55:47,359 --> 00:55:49,440
how much in your experience

1410
00:55:49,440 --> 00:55:52,000
uh overhead is there in that stage

1411
00:55:52,000 --> 00:55:53,599
versus the overhead

1412
00:55:53,599 --> 00:55:55,119
in the

1413
00:55:55,119 --> 00:55:58,319
improved system cryptographic uh system

1414
00:55:58,319 --> 00:56:00,000
and uh do you have any thoughts about

1415
00:56:00,000 --> 00:56:03,599
improving uh overheads on that side

1416
00:56:03,599 --> 00:56:06,079
so i don't think i have a good

1417
00:56:06,079 --> 00:56:08,000
general answer to that right because

1418
00:56:08,000 --> 00:56:10,000
there's a lot of people that really do

1419
00:56:10,000 --> 00:56:12,559
this in in in practice right and and

1420
00:56:12,559 --> 00:56:13,760
take

1421
00:56:13,760 --> 00:56:15,920
different examples of of computation

1422
00:56:15,920 --> 00:56:17,520
that they compile and typically you'll

1423
00:56:17,520 --> 00:56:20,240
have several steps in in that compiler

1424
00:56:20,240 --> 00:56:21,359
so you may

1425
00:56:21,359 --> 00:56:23,920
start with sort of the program execution

1426
00:56:23,920 --> 00:56:26,160
you saw like map that into constraints

1427
00:56:26,160 --> 00:56:28,319
in a field system

1428
00:56:28,319 --> 00:56:29,599
you would then

1429
00:56:29,599 --> 00:56:32,079
map that to so like

1430
00:56:32,079 --> 00:56:34,000
or you may write that as a what is

1431
00:56:34,000 --> 00:56:35,599
called a rank one constraint

1432
00:56:35,599 --> 00:56:37,119
satisfaction

1433
00:56:37,119 --> 00:56:39,520
system you would then compile that maybe

1434
00:56:39,520 --> 00:56:42,079
into a quadratic arithmetic program

1435
00:56:42,079 --> 00:56:43,920
right and then you would put a snark in

1436
00:56:43,920 --> 00:56:46,799
on top of that um

1437
00:56:46,799 --> 00:56:48,160
and i think at least for the latter

1438
00:56:48,160 --> 00:56:49,440
version uh

1439
00:56:49,440 --> 00:56:51,200
putting the cryptographic stark at the

1440
00:56:51,200 --> 00:56:52,160
end is

1441
00:56:52,160 --> 00:56:54,240
cheap compared to

1442
00:56:54,240 --> 00:56:57,119
uh the other things that you have to to

1443
00:56:57,119 --> 00:56:58,799
do um

1444
00:56:58,799 --> 00:57:01,200
and uh certainly our experience when we

1445
00:57:01,200 --> 00:57:03,440
wrote this which was a theoretical paper

1446
00:57:03,440 --> 00:57:05,440
right so we did not really try to super

1447
00:57:05,440 --> 00:57:06,799
optimize

1448
00:57:06,799 --> 00:57:09,680
the overhead right but you know it was

1449
00:57:09,680 --> 00:57:12,400
tedious work to take all these tiny iran

1450
00:57:12,400 --> 00:57:15,200
operations and find the constraints and

1451
00:57:15,200 --> 00:57:18,079
and there were a number of overheads in

1452
00:57:18,079 --> 00:57:21,040
in those constraints

1453
00:57:22,480 --> 00:57:24,960
and as a follow-up to that are there

1454
00:57:24,960 --> 00:57:26,880
do you think there are

1455
00:57:26,880 --> 00:57:28,880
interesting research directions or what

1456
00:57:28,880 --> 00:57:31,280
what are interesting research directions

1457
00:57:31,280 --> 00:57:35,440
in um perhaps richer

1458
00:57:35,440 --> 00:57:38,160
notions of computation that can be

1459
00:57:38,160 --> 00:57:39,520
expressed

1460
00:57:39,520 --> 00:57:42,160
or approved you know more directly and

1461
00:57:42,160 --> 00:57:44,240
starts

1462
00:57:44,240 --> 00:57:45,760
i think that's a

1463
00:57:45,760 --> 00:57:49,040
a really good question um

1464
00:57:49,040 --> 00:57:51,119
and again i'm

1465
00:57:51,119 --> 00:57:53,280
not too familiar with other models i've

1466
00:57:53,280 --> 00:57:55,280
sort of grown up myself

1467
00:57:55,280 --> 00:57:57,359
with so like he wanted to prove that a

1468
00:57:57,359 --> 00:57:59,440
circuit is satisfiable right it's np

1469
00:57:59,440 --> 00:58:01,520
complete it's simple to understand for

1470
00:58:01,520 --> 00:58:03,200
cryptographers it just involves some

1471
00:58:03,200 --> 00:58:05,520
field in which you do additions and

1472
00:58:05,520 --> 00:58:07,119
multiplications

1473
00:58:07,119 --> 00:58:08,960
and you know so it's a great model right

1474
00:58:08,960 --> 00:58:10,559
and it's also great then for

1475
00:58:10,559 --> 00:58:12,079
benchmarking whenever you have a new

1476
00:58:12,079 --> 00:58:14,559
proof system so like run that you have a

1477
00:58:14,559 --> 00:58:16,400
lot of things that you can compare with

1478
00:58:16,400 --> 00:58:17,760
write and see whether your techniques

1479
00:58:17,760 --> 00:58:20,079
really are advancing

1480
00:58:20,079 --> 00:58:22,480
the field um

1481
00:58:22,480 --> 00:58:25,040
but but it does raise uh

1482
00:58:25,040 --> 00:58:26,720
the question of you know what other

1483
00:58:26,720 --> 00:58:27,839
things can

1484
00:58:27,839 --> 00:58:29,520
can you prove which which are

1485
00:58:29,520 --> 00:58:32,160
interesting to to prove things about

1486
00:58:32,160 --> 00:58:33,920
right and people

1487
00:58:33,920 --> 00:58:36,960
have managed to do so like a

1488
00:58:36,960 --> 00:58:38,240
verifying

1489
00:58:38,240 --> 00:58:40,559
real competition say

1490
00:58:40,559 --> 00:58:42,960
competition is a program written in c or

1491
00:58:42,960 --> 00:58:45,119
something like that right but uh

1492
00:58:45,119 --> 00:58:47,119
i think there's been quite a lot of work

1493
00:58:47,119 --> 00:58:49,520
in going into to actually doing that

1494
00:58:49,520 --> 00:58:51,920
that compilation but but now the tools

1495
00:58:51,920 --> 00:58:53,839
are for that right and then you could

1496
00:58:53,839 --> 00:58:55,520
ask you know are there

1497
00:58:55,520 --> 00:58:56,960
other things that are so like not

1498
00:58:56,960 --> 00:58:59,440
captured by that very general model

1499
00:58:59,440 --> 00:59:00,960
right but which

1500
00:59:00,960 --> 00:59:03,200
still simpler and still be very

1501
00:59:03,200 --> 00:59:05,119
interesting to to prove and

1502
00:59:05,119 --> 00:59:07,040
i don't have a good example that springs

1503
00:59:07,040 --> 00:59:08,480
to mind but

1504
00:59:08,480 --> 00:59:12,240
it certainly seems plausible

1505
00:59:12,240 --> 00:59:14,240
great um we have a question in the chat

1506
00:59:14,240 --> 00:59:17,599
uh from chelsea comolo who asks one of

1507
00:59:17,599 --> 00:59:19,359
the largest barriers

1508
00:59:19,359 --> 00:59:21,760
to using snarks at a wider scale is

1509
00:59:21,760 --> 00:59:24,480
their complexity to implementers

1510
00:59:24,480 --> 00:59:26,720
what role do you think theoreticians can

1511
00:59:26,720 --> 00:59:29,040
have in ensuring that their schemes can

1512
00:59:29,040 --> 00:59:33,280
be widely understood and therefore used

1513
00:59:33,280 --> 00:59:36,319
right so i think this separation between

1514
00:59:36,319 --> 00:59:38,640
an information and theoretic core and so

1515
00:59:38,640 --> 00:59:41,040
like cryptographic

1516
00:59:41,040 --> 00:59:44,160
compilation is really strikes to to that

1517
00:59:44,160 --> 00:59:46,720
right because we want the the more

1518
00:59:46,720 --> 00:59:48,960
modular things are the the easier they

1519
00:59:48,960 --> 00:59:51,119
are to understand the easier they are to

1520
00:59:51,119 --> 00:59:53,200
implement as well right and it also

1521
00:59:53,200 --> 00:59:54,160
makes

1522
00:59:54,160 --> 00:59:55,839
ensures that people can sort like work

1523
00:59:55,839 --> 00:59:56,480
in

1524
00:59:56,480 --> 00:59:58,640
in parallel and optimizing different

1525
00:59:58,640 --> 01:00:00,799
things right so you don't have to

1526
01:00:00,799 --> 01:00:02,160
actually know

1527
01:00:02,160 --> 01:00:05,359
how you sort of compile things into to

1528
01:00:05,359 --> 01:00:07,200
quadratic arithmetic programs in order

1529
01:00:07,200 --> 01:00:08,880
to optimize say elliptic curve

1530
01:00:08,880 --> 01:00:10,799
operations to do pairing based snark

1531
01:00:10,799 --> 01:00:13,359
right and and vice versa you don't

1532
01:00:13,359 --> 01:00:15,119
need to know too much about

1533
01:00:15,119 --> 01:00:18,000
elliptic curves and pairings in order to

1534
01:00:18,000 --> 01:00:23,040
try to optimize uh towards uh say um

1535
01:00:23,119 --> 01:00:25,359
take a right one constraint satisfaction

1536
01:00:25,359 --> 01:00:28,720
system and compile that into a quadratic

1537
01:00:28,720 --> 01:00:31,598
arithmetic program

1538
01:00:33,440 --> 01:00:35,760
thanks uh let's see are there any other

1539
01:00:35,760 --> 01:00:38,079
questions out there we have time for

1540
01:00:38,079 --> 01:00:40,960
a couple more minutes

1541
01:00:40,960 --> 01:00:45,599
so last call for questions to yens

1542
01:00:53,359 --> 01:00:54,880
all right well we're

1543
01:00:54,880 --> 01:00:57,599
just a minute or two over so i think

1544
01:00:57,599 --> 01:01:00,559
that's a good time uh to end and

1545
01:01:00,559 --> 01:01:02,720
if i remember correctly yes uh thank you

1546
01:01:02,720 --> 01:01:05,520
again jens for a wonderful talk

1547
01:01:05,520 --> 01:01:09,200
um and much to think about and then uh

1548
01:01:09,200 --> 01:01:12,240
we have about a 30

