1
00:00:00,480 --> 00:00:02,639
hi i'll be presenting silver silent bowl

2
00:00:02,639 --> 00:00:04,080
and oblivious transfer from the hardness

3
00:00:04,080 --> 00:00:06,640
of decoding ldpc codes this is joint

4
00:00:06,640 --> 00:00:08,720
work with jeff wah and srini

5
00:00:08,720 --> 00:00:11,679
along with myself peter rindahl

6
00:00:11,679 --> 00:00:13,440
so as a way of introduction i'd like to

7
00:00:13,440 --> 00:00:14,799
introduce

8
00:00:14,799 --> 00:00:16,640
oblivious transfer

9
00:00:16,640 --> 00:00:18,240
here this there's two parties a sender

10
00:00:18,240 --> 00:00:19,520
and a receiver the sender has two

11
00:00:19,520 --> 00:00:22,320
messages m0 and m1 and the receiver has

12
00:00:22,320 --> 00:00:24,320
a choice bit c the receiver should learn

13
00:00:24,320 --> 00:00:26,320
the message mc and nothing about the

14
00:00:26,320 --> 00:00:28,240
other message

15
00:00:28,240 --> 00:00:30,320
oblivious transfer is used throughout

16
00:00:30,320 --> 00:00:32,238
multi-party computation and it's one of

17
00:00:32,238 --> 00:00:34,079
the most fundamental

18
00:00:34,079 --> 00:00:37,120
protocols in cryptography

19
00:00:37,120 --> 00:00:39,360
there's also a variant of

20
00:00:39,360 --> 00:00:41,200
oblivious cancer known as random alleles

21
00:00:41,200 --> 00:00:42,640
transfer here

22
00:00:42,640 --> 00:00:44,399
the parties don't exactly have input

23
00:00:44,399 --> 00:00:45,600
instead the functionality or the

24
00:00:45,600 --> 00:00:47,760
protocol chooses the everything at

25
00:00:47,760 --> 00:00:49,520
random so the m0 and m1 is random and

26
00:00:49,520 --> 00:00:52,160
the choice bit c is random and otherwise

27
00:00:52,160 --> 00:00:54,239
the protocol is roughly the same and the

28
00:00:54,239 --> 00:00:55,680
nice thing about random ots is that you

29
00:00:55,680 --> 00:00:57,120
can sort of derandomize them and get

30
00:00:57,120 --> 00:00:59,039
back to the original ot correlation and

31
00:00:59,039 --> 00:01:01,440
so in some sense random ot is all that

32
00:01:01,440 --> 00:01:03,359
you need

33
00:01:03,359 --> 00:01:05,119
uh further we can consider sort of a

34
00:01:05,119 --> 00:01:06,720
slight variant on this

35
00:01:06,720 --> 00:01:09,680
is that let the messages m0 and m1 be

36
00:01:09,680 --> 00:01:12,320
offset by some delta and then you can

37
00:01:12,320 --> 00:01:14,640
rewrite the receiver's message mc as m0

38
00:01:14,640 --> 00:01:18,320
plus c times this delta value

39
00:01:18,320 --> 00:01:20,080
and this is a sort of naturally

40
00:01:20,080 --> 00:01:21,520
generalizes to something known as

41
00:01:21,520 --> 00:01:23,920
oblivious linear evaluation here the key

42
00:01:23,920 --> 00:01:25,759
distinction from ot is that

43
00:01:25,759 --> 00:01:27,280
c the choice bit

44
00:01:27,280 --> 00:01:28,799
is allowed to be

45
00:01:28,799 --> 00:01:32,400
a field element instead of just binary

46
00:01:32,400 --> 00:01:34,159
and we can further generalize this to

47
00:01:34,159 --> 00:01:36,400
what is known as vector ole

48
00:01:36,400 --> 00:01:39,759
here the message m0 is a vector messages

49
00:01:39,759 --> 00:01:42,159
and similarly the choice

50
00:01:42,159 --> 00:01:44,479
value c is now a vector and so you get a

51
00:01:44,479 --> 00:01:46,640
vector correlation which m c equals

52
00:01:46,640 --> 00:01:50,000
vector m0 plus vector m vector c times

53
00:01:50,000 --> 00:01:52,880
the scalar delta

54
00:01:52,880 --> 00:01:55,280
and rewriting sort of the terms to be a

55
00:01:55,280 --> 00:01:58,240
b c and delta to clean it up a little uh

56
00:01:58,240 --> 00:01:59,840
you we can see this is the correlation

57
00:01:59,840 --> 00:02:01,040
and the nice thing about this vol

58
00:02:01,040 --> 00:02:03,200
correlation is that you can sort of

59
00:02:03,200 --> 00:02:05,280
as i mentioned before de-randomize it to

60
00:02:05,280 --> 00:02:06,840
get back to ot

61
00:02:06,840 --> 00:02:09,360
uh whichever variant of ot that you want

62
00:02:09,360 --> 00:02:10,878
or you can stay with this sort of vocal

63
00:02:10,878 --> 00:02:13,440
correlation where uh this

64
00:02:13,440 --> 00:02:16,879
choice vector a now is uh over the field

65
00:02:16,879 --> 00:02:18,480
and so throughout this talk i'll be

66
00:02:18,480 --> 00:02:20,239
referring to this formulation and not

67
00:02:20,239 --> 00:02:22,160
the oblivious transfer one but just

68
00:02:22,160 --> 00:02:23,599
understand that they're in some sense

69
00:02:23,599 --> 00:02:25,680
equivalent

70
00:02:25,680 --> 00:02:27,680
another property that we want is this

71
00:02:27,680 --> 00:02:28,720
silent

72
00:02:28,720 --> 00:02:30,160
feature where

73
00:02:30,160 --> 00:02:32,239
the protocol itself

74
00:02:32,239 --> 00:02:35,120
is only a setup protocol in that this it

75
00:02:35,120 --> 00:02:36,879
has low communication and it outputs

76
00:02:36,879 --> 00:02:38,319
some small keys to the sender and

77
00:02:38,319 --> 00:02:39,280
receiver

78
00:02:39,280 --> 00:02:41,440
and then by local communic uh local

79
00:02:41,440 --> 00:02:43,120
computation only they're able to expand

80
00:02:43,120 --> 00:02:44,959
these keys into the final vol

81
00:02:44,959 --> 00:02:46,800
correlation

82
00:02:46,800 --> 00:02:48,480
uh in particular the setup should be

83
00:02:48,480 --> 00:02:50,480
sublinear in the size of the vectors and

84
00:02:50,480 --> 00:02:52,720
the expansion should be non-interactive

85
00:02:52,720 --> 00:02:54,720
our our whole protocol that we use in

86
00:02:54,720 --> 00:02:55,680
this talk

87
00:02:55,680 --> 00:02:58,360
is in fact silent in this way

88
00:02:58,360 --> 00:02:59,680
[Music]

89
00:02:59,680 --> 00:03:01,360
and it's a nice property to have because

90
00:03:01,360 --> 00:03:03,040
it allows you to a get less

91
00:03:03,040 --> 00:03:04,480
communication and b

92
00:03:04,480 --> 00:03:05,760
uh you can pronounce

93
00:03:05,760 --> 00:03:07,440
communication during a setup phase and

94
00:03:07,440 --> 00:03:09,120
then sort of go offline or store the

95
00:03:09,120 --> 00:03:12,080
keys for later use

96
00:03:12,159 --> 00:03:14,080
the volt protocol or ot protocol

97
00:03:14,080 --> 00:03:15,840
whichever is the case

98
00:03:15,840 --> 00:03:18,560
that that were that we use uh

99
00:03:18,560 --> 00:03:21,120
its setup phase it internally uses this

100
00:03:21,120 --> 00:03:23,360
thing called a punctured prf

101
00:03:23,360 --> 00:03:24,720
i'm not going to get into exactly what a

102
00:03:24,720 --> 00:03:26,799
punctured prf is but suffice it to say

103
00:03:26,799 --> 00:03:28,560
that so the gen generation algorithm is

104
00:03:28,560 --> 00:03:30,400
run inside an npc protocol which outputs

105
00:03:30,400 --> 00:03:32,480
these keys k 0 and c1

106
00:03:32,480 --> 00:03:34,400
these can then be expanded using the

107
00:03:34,400 --> 00:03:36,159
puncture qrf function

108
00:03:36,159 --> 00:03:38,400
to get the following correlation

109
00:03:38,400 --> 00:03:39,280
it's

110
00:03:39,280 --> 00:03:40,720
basically identical to the volt

111
00:03:40,720 --> 00:03:42,879
correlation that we want in the end with

112
00:03:42,879 --> 00:03:46,000
the catch that this a vector is sparse

113
00:03:46,000 --> 00:03:47,760
meaning that only say 100 or 200 of the

114
00:03:47,760 --> 00:03:50,400
locations of this a prime vector

115
00:03:50,400 --> 00:03:51,680
is non-zero

116
00:03:51,680 --> 00:03:53,120
and overall this vector might be a

117
00:03:53,120 --> 00:03:56,319
length a million so it's highly sparse

118
00:03:56,319 --> 00:03:58,319
but it is close to the correlation that

119
00:03:58,319 --> 00:04:00,000
we want

120
00:04:00,000 --> 00:04:02,720
so the next step is that we'll run lpn

121
00:04:02,720 --> 00:04:04,879
to sort of bootstrap this sparse

122
00:04:04,879 --> 00:04:06,480
correlation into the standard vocal

123
00:04:06,480 --> 00:04:07,599
correlation

124
00:04:07,599 --> 00:04:09,599
and we'll talk more about lpn later but

125
00:04:09,599 --> 00:04:11,840
suffices say now

126
00:04:11,840 --> 00:04:13,840
what lpn consists of is multiplying a

127
00:04:13,840 --> 00:04:16,160
large random matrix g from the left by

128
00:04:16,160 --> 00:04:17,519
the vector

129
00:04:17,519 --> 00:04:20,000
and then this gets you the final output

130
00:04:20,000 --> 00:04:22,240
and critically lpn says that even though

131
00:04:22,240 --> 00:04:24,560
this a prime vector is sparse the final

132
00:04:24,560 --> 00:04:29,040
a vector is in fact uniformly random

133
00:04:29,040 --> 00:04:30,880
and this is sort of concludes what how

134
00:04:30,880 --> 00:04:32,560
our vol protocol or that the volt

135
00:04:32,560 --> 00:04:35,280
protocol that we use that works

136
00:04:35,280 --> 00:04:38,400
so drilling in to this lpn instance in

137
00:04:38,400 --> 00:04:41,199
particular we want to run generate say a

138
00:04:41,199 --> 00:04:43,440
million or many millions of ots or volts

139
00:04:43,440 --> 00:04:45,280
whichever you have and this means that

140
00:04:45,280 --> 00:04:47,280
the lpn instance will be very large so

141
00:04:47,280 --> 00:04:50,160
say if we want 4 million ots then our g

142
00:04:50,160 --> 00:04:52,080
matrix here will be 4 million by 8

143
00:04:52,080 --> 00:04:54,160
million for example and this

144
00:04:54,160 --> 00:04:56,639
for classic lpn this mean uh this

145
00:04:56,639 --> 00:04:58,560
corresponds to this g matrix being

146
00:04:58,560 --> 00:05:00,240
uniformly random

147
00:05:00,240 --> 00:05:02,320
and therefore the multiplication would

148
00:05:02,320 --> 00:05:04,960
be quadratic time uh taking you know

149
00:05:04,960 --> 00:05:07,520
roughly to the power 40 untime

150
00:05:07,520 --> 00:05:08,800
which is clearly impractical if we're

151
00:05:08,800 --> 00:05:11,840
going for extremely high performance

152
00:05:11,840 --> 00:05:13,440
this leads us to

153
00:05:13,440 --> 00:05:15,120
a modification known as like structured

154
00:05:15,120 --> 00:05:17,199
lpn here we place additional structure

155
00:05:17,199 --> 00:05:18,880
on this matrix g

156
00:05:18,880 --> 00:05:21,039
which allows us to do this matrix vector

157
00:05:21,039 --> 00:05:24,479
multiplication in uh in less time

158
00:05:24,479 --> 00:05:26,479
uh previous works had achieved this in

159
00:05:26,479 --> 00:05:28,240
sort of n log end time while in this

160
00:05:28,240 --> 00:05:31,840
work we will design a new matrix g uh

161
00:05:31,840 --> 00:05:33,440
that actually allows us to do linear

162
00:05:33,440 --> 00:05:36,880
time multiplication uh but importantly

163
00:05:36,880 --> 00:05:39,039
you have to be careful in that uh by

164
00:05:39,039 --> 00:05:40,960
modifying this matrix g you might weaken

165
00:05:40,960 --> 00:05:43,280
the lpn instance and so it's a careful

166
00:05:43,280 --> 00:05:45,039
balance between getting high performance

167
00:05:45,039 --> 00:05:47,120
or also maintaining the security of lpn

168
00:05:47,120 --> 00:05:49,280
and we'll discuss that next

169
00:05:49,280 --> 00:05:50,720
uh by way of doing this we're going to

170
00:05:50,720 --> 00:05:52,320
introduce what's known as primalopn this

171
00:05:52,320 --> 00:05:54,880
is how it's traditionally thought of and

172
00:05:54,880 --> 00:05:57,120
here you have a public matrix a it's a

173
00:05:57,120 --> 00:05:58,880
large random matrix

174
00:05:58,880 --> 00:05:59,759
and then

175
00:05:59,759 --> 00:06:01,919
someone takes their seed s and e these

176
00:06:01,919 --> 00:06:02,720
are

177
00:06:02,720 --> 00:06:04,319
vectors as shown here

178
00:06:04,319 --> 00:06:06,240
s will be sort of uniformly random but

179
00:06:06,240 --> 00:06:08,720
somewhat short while e is sparse uh but

180
00:06:08,720 --> 00:06:11,120
longer and so you'll do a times s plus e

181
00:06:11,120 --> 00:06:12,800
and this gives you r

182
00:06:12,800 --> 00:06:14,479
now lpn says that r should be

183
00:06:14,479 --> 00:06:17,520
indistinguishable from uniformly random

184
00:06:17,520 --> 00:06:19,440
sort of shown here given that the matrix

185
00:06:19,440 --> 00:06:21,199
a is public

186
00:06:21,199 --> 00:06:22,800
in our work we'll use what's known as

187
00:06:22,800 --> 00:06:24,400
the dual formulation

188
00:06:24,400 --> 00:06:26,080
here we have a matrix g

189
00:06:26,080 --> 00:06:28,240
and we'll just we just do g times this

190
00:06:28,240 --> 00:06:30,880
sparse vector e and this gives us a sort

191
00:06:30,880 --> 00:06:32,000
of a short

192
00:06:32,000 --> 00:06:35,199
ideally uniformly random vector r hat

193
00:06:35,199 --> 00:06:37,199
and again the the

194
00:06:37,199 --> 00:06:38,479
security statement somewhat similar is

195
00:06:38,479 --> 00:06:40,479
that g and r should be indistinguishable

196
00:06:40,479 --> 00:06:43,359
from uniform random

197
00:06:44,080 --> 00:06:45,360
these two formulations actually

198
00:06:45,360 --> 00:06:47,280
equivalent to see how this works i

199
00:06:47,280 --> 00:06:50,639
relabeled this a matrix as h transpose

200
00:06:50,639 --> 00:06:51,680
and then

201
00:06:51,680 --> 00:06:53,280
let g and h

202
00:06:53,280 --> 00:06:54,880
be the generator and parity check matrix

203
00:06:54,880 --> 00:06:56,560
for an air correcting code so if you're

204
00:06:56,560 --> 00:06:58,400
starting with primal then you are given

205
00:06:58,400 --> 00:07:01,199
h as the lpn matrix and you can derive

206
00:07:01,199 --> 00:07:02,560
the corresponding

207
00:07:02,560 --> 00:07:04,000
generator matrix

208
00:07:04,000 --> 00:07:05,840
for that error correcting code

209
00:07:05,840 --> 00:07:07,120
and then to see why these two are

210
00:07:07,120 --> 00:07:08,560
equivalent

211
00:07:08,560 --> 00:07:10,000
we use the properties of the generator

212
00:07:10,000 --> 00:07:11,440
times the transpose of the parity check

213
00:07:11,440 --> 00:07:12,800
matrix h

214
00:07:12,800 --> 00:07:15,039
equals 0. and so if you multiply the

215
00:07:15,039 --> 00:07:18,080
primal lpn instance from the left by g

216
00:07:18,080 --> 00:07:19,440
you get the following

217
00:07:19,440 --> 00:07:21,599
g times h transpose is zero

218
00:07:21,599 --> 00:07:23,680
and so zero times s is zero and so what

219
00:07:23,680 --> 00:07:25,280
you're left with is just g times the

220
00:07:25,280 --> 00:07:28,800
sparse vector e equals g times the

221
00:07:28,800 --> 00:07:31,680
sort of uniformly random vector r

222
00:07:31,680 --> 00:07:32,639
and

223
00:07:32,639 --> 00:07:34,560
uh by some properties of the generating

224
00:07:34,560 --> 00:07:36,400
matrix it's not hard to show that as

225
00:07:36,400 --> 00:07:38,000
long as r is uniformly random then g

226
00:07:38,000 --> 00:07:40,160
times r is uniformly random and that's

227
00:07:40,160 --> 00:07:42,560
how we arrive at our dual formulation

228
00:07:42,560 --> 00:07:44,639
and so next i'll be talking about uh the

229
00:07:44,639 --> 00:07:46,240
security of the primal version of lpn

230
00:07:46,240 --> 00:07:48,240
but our implementation will use dual lpn

231
00:07:48,240 --> 00:07:50,960
and these sort of are equivalent

232
00:07:50,960 --> 00:07:54,080
um so lpn has been studied extensively

233
00:07:54,080 --> 00:07:55,520
uh there's numerous attacks based on

234
00:07:55,520 --> 00:07:57,759
gaussian elimination set uh sec

235
00:07:57,759 --> 00:07:59,919
recovering set information set decoding

236
00:07:59,919 --> 00:08:02,560
and so forth and so on uh and since

237
00:08:02,560 --> 00:08:04,160
we're in the business of designing a new

238
00:08:04,160 --> 00:08:06,479
lpn matrix it'd be very tedious to have

239
00:08:06,479 --> 00:08:07,520
to like go through each one of these

240
00:08:07,520 --> 00:08:09,280
papers and sort of just

241
00:08:09,280 --> 00:08:11,039
decide whether their attack is relevant

242
00:08:11,039 --> 00:08:12,400
to our

243
00:08:12,400 --> 00:08:14,639
our particular lpn instance

244
00:08:14,639 --> 00:08:16,479
but fortunately we don't have to and

245
00:08:16,479 --> 00:08:17,440
that

246
00:08:17,440 --> 00:08:19,919
there's this framework which is

247
00:08:19,919 --> 00:08:21,680
introduced previous to us known as the

248
00:08:21,680 --> 00:08:23,840
linear test framework

249
00:08:23,840 --> 00:08:25,039
and here

250
00:08:25,039 --> 00:08:27,520
the adversary is first given the the

251
00:08:27,520 --> 00:08:29,199
matrix in question h and they're allowed

252
00:08:29,199 --> 00:08:31,520
to pre-process so arbitrarily uh

253
00:08:31,520 --> 00:08:33,120
whatever they want and then they output

254
00:08:33,120 --> 00:08:34,640
a vector v

255
00:08:34,640 --> 00:08:36,880
and this and then uh

256
00:08:36,880 --> 00:08:38,640
as a way of distinguishing whether the r

257
00:08:38,640 --> 00:08:40,240
is from an lpn instance or uniformly

258
00:08:40,240 --> 00:08:42,479
random uh the adversary will output a

259
00:08:42,479 --> 00:08:44,880
bit v inner product r

260
00:08:44,880 --> 00:08:47,200
uh and so if say if p is one then that's

261
00:08:47,200 --> 00:08:48,720
maybe saying that uh it's an lpn

262
00:08:48,720 --> 00:08:50,560
instance and otherwise it's random

263
00:08:50,560 --> 00:08:52,399
and fortunately all these attacks can be

264
00:08:52,399 --> 00:08:54,560
framed in this framework with adversary

265
00:08:54,560 --> 00:08:57,040
pre-processes the lpn matrix outputs a

266
00:08:57,040 --> 00:08:58,560
vector and then inner products the

267
00:08:58,560 --> 00:09:00,160
vector with r

268
00:09:00,160 --> 00:09:02,080
and now that now that we have this sort

269
00:09:02,080 --> 00:09:03,839
of linear test

270
00:09:03,839 --> 00:09:06,000
we can sort of reason about it

271
00:09:06,000 --> 00:09:08,399
so first let us consider the case where

272
00:09:08,399 --> 00:09:09,680
this matrix

273
00:09:09,680 --> 00:09:12,959
h transpose is uh it's rows are d y is

274
00:09:12,959 --> 00:09:15,360
independent meaning uh it takes at least

275
00:09:15,360 --> 00:09:17,279
d plus one rows to be added together to

276
00:09:17,279 --> 00:09:18,720
equal zero

277
00:09:18,720 --> 00:09:19,680
uh

278
00:09:19,680 --> 00:09:21,519
then we can consider quote-unquote a

279
00:09:21,519 --> 00:09:23,760
sparse v meaning that the hamming weight

280
00:09:23,760 --> 00:09:27,680
of this test vector v is less than d the

281
00:09:27,680 --> 00:09:29,680
row wise independence value

282
00:09:29,680 --> 00:09:32,080
and what this will look like is so v

283
00:09:32,080 --> 00:09:34,959
times h transpose times s which is sort

284
00:09:34,959 --> 00:09:37,440
of like the contribution s makes to r

285
00:09:37,440 --> 00:09:39,760
uh will equal sort of some other uh

286
00:09:39,760 --> 00:09:42,640
matrix h prime times s where h prime is

287
00:09:42,640 --> 00:09:44,800
row wise independent and it's not hard

288
00:09:44,800 --> 00:09:46,800
to see since s is uniformly random and

289
00:09:46,800 --> 00:09:48,000
you're multiplying it by row wise

290
00:09:48,000 --> 00:09:49,200
independent

291
00:09:49,200 --> 00:09:51,519
matrix h which is sort of short

292
00:09:51,519 --> 00:09:54,000
then the output will be uniformly random

293
00:09:54,000 --> 00:09:56,160
and so what it is saying is that when v

294
00:09:56,160 --> 00:09:58,720
is sparse that the s is what's saving

295
00:09:58,720 --> 00:10:00,800
our lpn instance or what's giving our

296
00:10:00,800 --> 00:10:03,279
lpm instance

297
00:10:03,279 --> 00:10:04,399
making it indistinguishable from

298
00:10:04,399 --> 00:10:06,160
uniformly random

299
00:10:06,160 --> 00:10:08,720
on the other case when v is dense uh the

300
00:10:08,720 --> 00:10:11,040
e vector comes into play in that to see

301
00:10:11,040 --> 00:10:13,920
this uh roughly speaking is that once v

302
00:10:13,920 --> 00:10:15,360
is sufficiently dense then the

303
00:10:15,360 --> 00:10:17,440
probability that it intersects this air

304
00:10:17,440 --> 00:10:20,000
vector becomes high overwhelming and in

305
00:10:20,000 --> 00:10:22,160
this case that further derandomizes the

306
00:10:22,160 --> 00:10:24,959
result and so then it becomes uh the e

307
00:10:24,959 --> 00:10:27,519
makes the r uniformly random and so it's

308
00:10:27,519 --> 00:10:28,720
sort of a balancing act between these

309
00:10:28,720 --> 00:10:31,440
two extremes sparse v and dense v

310
00:10:31,440 --> 00:10:34,000
uh this analysis strictly stems from the

311
00:10:34,000 --> 00:10:35,200
fact that

312
00:10:35,200 --> 00:10:36,800
we considered

313
00:10:36,800 --> 00:10:38,079
h to be

314
00:10:38,079 --> 00:10:39,680
h transposed to b

315
00:10:39,680 --> 00:10:41,920
d y's rho independent

316
00:10:41,920 --> 00:10:44,399
and uh this in turn sort of tells us how

317
00:10:44,399 --> 00:10:46,160
to set how noisy the e vector needs to

318
00:10:46,160 --> 00:10:47,519
be

319
00:10:47,519 --> 00:10:48,240
but

320
00:10:48,240 --> 00:10:49,680
this uh

321
00:10:49,680 --> 00:10:51,200
row wise independence property is

322
00:10:51,200 --> 00:10:53,120
equivalent to saying that the

323
00:10:53,120 --> 00:10:56,000
code generated by this other matrix g

324
00:10:56,000 --> 00:10:58,240
should have minimum distance d

325
00:10:58,240 --> 00:11:00,160
um and so this brings us to a way of

326
00:11:00,160 --> 00:11:02,959
searching for new uh highly efficient

327
00:11:02,959 --> 00:11:05,600
lpn instances we simply need to find a

328
00:11:05,600 --> 00:11:08,079
linear code g with parity check matrix h

329
00:11:08,079 --> 00:11:10,320
which has high minimum distance uh for

330
00:11:10,320 --> 00:11:12,560
the code it should have fast encode here

331
00:11:12,560 --> 00:11:13,920
we actually need the transpose of the

332
00:11:13,920 --> 00:11:15,200
encoding algorithm but this ends up not

333
00:11:15,200 --> 00:11:17,279
being an issue and finally this code

334
00:11:17,279 --> 00:11:18,720
should be efficient when the dimensions

335
00:11:18,720 --> 00:11:20,720
are very large so these properties are

336
00:11:20,720 --> 00:11:22,880
somewhat unique to us a lot of codes out

337
00:11:22,880 --> 00:11:24,079
there aim to achieve additional

338
00:11:24,079 --> 00:11:25,440
properties or some other set of

339
00:11:25,440 --> 00:11:26,800
properties and so we're looking to

340
00:11:26,800 --> 00:11:30,160
optimize just these properties

341
00:11:30,720 --> 00:11:32,480
to do this we turn to

342
00:11:32,480 --> 00:11:33,440
uh

343
00:11:33,440 --> 00:11:35,200
low density parity check

344
00:11:35,200 --> 00:11:36,079
codes

345
00:11:36,079 --> 00:11:39,360
these codes are sort of

346
00:11:39,360 --> 00:11:40,720
are

347
00:11:40,720 --> 00:11:42,240
characterized by having the parity check

348
00:11:42,240 --> 00:11:44,640
matrix h being sparse so this might mean

349
00:11:44,640 --> 00:11:46,240
the number of ones in any given column

350
00:11:46,240 --> 00:11:50,399
of h is some uh fixed constant

351
00:11:50,399 --> 00:11:53,360
and then to encode ldpc codes a common

352
00:11:53,360 --> 00:11:55,360
approach is to uh

353
00:11:55,360 --> 00:11:57,920
instead of mult having x multiplied by

354
00:11:57,920 --> 00:12:00,160
the generator which is maybe the

355
00:12:00,160 --> 00:12:01,680
traditional method you will solve the

356
00:12:01,680 --> 00:12:03,920
system of equations that h times the

357
00:12:03,920 --> 00:12:05,279
code word c

358
00:12:05,279 --> 00:12:07,600
equals zero

359
00:12:07,600 --> 00:12:09,440
and we're about to go over several

360
00:12:09,440 --> 00:12:12,800
examples of such ldpc codes uh

361
00:12:12,800 --> 00:12:14,560
which namely the uniform code which has

362
00:12:14,560 --> 00:12:16,399
good minimum distance but poor encoding

363
00:12:16,399 --> 00:12:18,959
time uh in the until it's the more code

364
00:12:18,959 --> 00:12:22,079
which is sort of has the inverse

365
00:12:22,079 --> 00:12:24,800
but first i want to talk about the g alt

366
00:12:24,800 --> 00:12:26,000
encoder this is the encoder that we're

367
00:12:26,000 --> 00:12:27,440
going to use

368
00:12:27,440 --> 00:12:29,040
and here uh

369
00:12:29,040 --> 00:12:30,320
the way you

370
00:12:30,320 --> 00:12:32,240
the way of explaining the glt encoder

371
00:12:32,240 --> 00:12:34,560
first we need to consider the

372
00:12:34,560 --> 00:12:37,680
systematic form of the code and here

373
00:12:37,680 --> 00:12:39,279
to given g and h you can get the

374
00:12:39,279 --> 00:12:41,279
systematic form g prime and h prime by

375
00:12:41,279 --> 00:12:43,519
doing row operations until

376
00:12:43,519 --> 00:12:45,519
h has the identity matrix on the right

377
00:12:45,519 --> 00:12:46,880
and g has the identity matrix on the

378
00:12:46,880 --> 00:12:48,959
left and in some sense this doesn't

379
00:12:48,959 --> 00:12:50,480
change the code

380
00:12:50,480 --> 00:12:51,760
it just uh you're just sort of

381
00:12:51,760 --> 00:12:53,440
re-labeling things

382
00:12:53,440 --> 00:12:54,240
but

383
00:12:54,240 --> 00:12:56,000
uh and then this gl encoder will

384
00:12:56,000 --> 00:12:58,399
actually encode under g prime the sort

385
00:12:58,399 --> 00:13:00,480
of systematic form

386
00:13:00,480 --> 00:13:02,399
uh but we don't actually want to

387
00:13:02,399 --> 00:13:04,160
explicitly write out h prime because

388
00:13:04,160 --> 00:13:06,079
even though h is sparse h prime might

389
00:13:06,079 --> 00:13:07,120
not be

390
00:13:07,120 --> 00:13:08,959
but that's okay because we can leverage

391
00:13:08,959 --> 00:13:11,519
the fact that uh the null space of these

392
00:13:11,519 --> 00:13:13,279
of h prime and h are the same meaning

393
00:13:13,279 --> 00:13:15,760
that uh if x times epsilon which is of

394
00:13:15,760 --> 00:13:17,440
some code word

395
00:13:17,440 --> 00:13:19,440
if h prime times that equals 0 then it

396
00:13:19,440 --> 00:13:22,720
would also hold true for h

397
00:13:23,360 --> 00:13:25,120
and then the next step

398
00:13:25,120 --> 00:13:26,880
is that

399
00:13:26,880 --> 00:13:28,240
and this allows us to run sort of

400
00:13:28,240 --> 00:13:29,519
solving the system of linear equations

401
00:13:29,519 --> 00:13:33,120
onto h and x and epsilon that's the idea

402
00:13:33,120 --> 00:13:34,880
uh but the next step in our encoder is

403
00:13:34,880 --> 00:13:37,600
that we first need to perform row and

404
00:13:37,600 --> 00:13:39,920
column operation swaps uh on h in order

405
00:13:39,920 --> 00:13:41,360
to put it in this form known as

406
00:13:41,360 --> 00:13:43,519
approximate g lower triangular

407
00:13:43,519 --> 00:13:46,480
here the idea is that uh h should

408
00:13:46,480 --> 00:13:48,320
basically be a lower triangular matrix

409
00:13:48,320 --> 00:13:50,800
except for we allow the last g rows not

410
00:13:50,800 --> 00:13:52,160
to be so

411
00:13:52,160 --> 00:13:54,000
any matrix can be put into this form for

412
00:13:54,000 --> 00:13:55,920
some value of g you know g might almost

413
00:13:55,920 --> 00:13:58,320
be the whole thing or you know uh and so

414
00:13:58,320 --> 00:13:59,519
forth

415
00:13:59,519 --> 00:14:00,720
uh and then we have an encoding

416
00:14:00,720 --> 00:14:02,720
algorithm that can be written like this

417
00:14:02,720 --> 00:14:04,880
basically it's a form of like a back

418
00:14:04,880 --> 00:14:07,920
propagation algorithm

419
00:14:07,920 --> 00:14:10,320
but the important takeaway even if all

420
00:14:10,320 --> 00:14:12,079
this didn't really make too much sense

421
00:14:12,079 --> 00:14:13,120
is that the running time of this

422
00:14:13,120 --> 00:14:15,680
encoding algorithm is m plus g squared

423
00:14:15,680 --> 00:14:16,399
so

424
00:14:16,399 --> 00:14:19,839
uh importantly we we uh

425
00:14:19,839 --> 00:14:21,680
this algorithm is only efficient i mean

426
00:14:21,680 --> 00:14:24,399
only linear time when g is a small or

427
00:14:24,399 --> 00:14:27,040
square root m

428
00:14:27,519 --> 00:14:29,760
so now let us consider the uniform ldpc

429
00:14:29,760 --> 00:14:30,399
code

430
00:14:30,399 --> 00:14:32,959
the uniform ldpc codes is described by

431
00:14:32,959 --> 00:14:34,959
having some fixed column weight w

432
00:14:34,959 --> 00:14:37,120
so each column will have weight w and

433
00:14:37,120 --> 00:14:38,240
this and then show an example on the

434
00:14:38,240 --> 00:14:40,320
right is say three but in practice it'd

435
00:14:40,320 --> 00:14:42,000
be like five or maybe eleven

436
00:14:42,000 --> 00:14:43,040
and then

437
00:14:43,040 --> 00:14:45,279
it's been shown uh sort of analytically

438
00:14:45,279 --> 00:14:47,199
that this code has linear minimum

439
00:14:47,199 --> 00:14:49,199
distance which is great which is what we

440
00:14:49,199 --> 00:14:50,160
want

441
00:14:50,160 --> 00:14:53,120
um but the problem is that how to encode

442
00:14:53,120 --> 00:14:55,440
uh you know there's various ways but if

443
00:14:55,440 --> 00:14:57,040
we're going to use our g alt encoder the

444
00:14:57,040 --> 00:14:59,199
first step right is to put it in this

445
00:14:59,199 --> 00:15:01,120
approximate lower triangular form

446
00:15:01,120 --> 00:15:02,560
and the way of doing this is you can do

447
00:15:02,560 --> 00:15:05,519
row and column swaps

448
00:15:05,519 --> 00:15:06,880
you don't want to do row addition

449
00:15:06,880 --> 00:15:08,160
operations because that will increase

450
00:15:08,160 --> 00:15:09,279
the weight

451
00:15:09,279 --> 00:15:11,120
which is undesirable but just doing row

452
00:15:11,120 --> 00:15:12,639
and column swaps is okay

453
00:15:12,639 --> 00:15:14,480
but the problem is that you can show at

454
00:15:14,480 --> 00:15:17,040
least for uh typical uh linear time

455
00:15:17,040 --> 00:15:18,720
algorithms uh

456
00:15:18,720 --> 00:15:20,560
is that the when you do those rows in

457
00:15:20,560 --> 00:15:22,800
column swaps uh the

458
00:15:22,800 --> 00:15:24,320
the gap inside the gap will remain

459
00:15:24,320 --> 00:15:26,160
linear in the overall size of the code

460
00:15:26,160 --> 00:15:27,120
and this

461
00:15:27,120 --> 00:15:28,560
basically means our overall running time

462
00:15:28,560 --> 00:15:30,560
will be quadratic and not efficient

463
00:15:30,560 --> 00:15:32,959
enough for our application

464
00:15:32,959 --> 00:15:34,800
uh this leads us to our second code

465
00:15:34,800 --> 00:15:38,000
which is the tillage zoom or code

466
00:15:38,000 --> 00:15:39,759
here the code is sort of broken up into

467
00:15:39,759 --> 00:15:41,360
a left half and right half

468
00:15:41,360 --> 00:15:42,639
the left half is uniformly random

469
00:15:42,639 --> 00:15:44,480
subject to some column weight w

470
00:15:44,480 --> 00:15:46,399
while the right half has two diagonals

471
00:15:46,399 --> 00:15:48,880
right next to each other of ones

472
00:15:48,880 --> 00:15:50,880
the reason for this structure is several

473
00:15:50,880 --> 00:15:52,560
fold but one of them is that it gives

474
00:15:52,560 --> 00:15:54,240
you a fast encoding in particular using

475
00:15:54,240 --> 00:15:56,399
the glt encoder we have g equals one and

476
00:15:56,399 --> 00:15:58,800
so trivially linear time

477
00:15:58,800 --> 00:16:00,720
uh as we'll get back to actually the

478
00:16:00,720 --> 00:16:02,079
left half although linear time is

479
00:16:02,079 --> 00:16:03,519
actually quite slow due to the

480
00:16:03,519 --> 00:16:06,839
randomized nature as we'll talk about

481
00:16:06,839 --> 00:16:09,120
um one of the primary issues with this

482
00:16:09,120 --> 00:16:10,320
code is that it actually achieves

483
00:16:10,320 --> 00:16:12,800
sub-linear minimum distance uh the

484
00:16:12,800 --> 00:16:14,880
authors of the code showed analytically

485
00:16:14,880 --> 00:16:17,920
that it's uh yeah it achieves the

486
00:16:17,920 --> 00:16:20,240
minimum distance shown here and

487
00:16:20,240 --> 00:16:22,240
this is primarily or exclusively due to

488
00:16:22,240 --> 00:16:25,040
these diagonals that they introduced

489
00:16:25,040 --> 00:16:26,639
and their code had several reasons to

490
00:16:26,639 --> 00:16:28,160
introduce them

491
00:16:28,160 --> 00:16:30,880
among them was fast encoding

492
00:16:30,880 --> 00:16:33,920
we in order to get a grips on the exact

493
00:16:33,920 --> 00:16:35,519
minimum distance that these codes have

494
00:16:35,519 --> 00:16:38,079
we actually implemented some extensive

495
00:16:38,079 --> 00:16:41,360
experimental uh techniques to

496
00:16:41,360 --> 00:16:42,880
evaluate an upper bound on the actual

497
00:16:42,880 --> 00:16:45,040
minimum distance and given this we do

498
00:16:45,040 --> 00:16:47,120
observe that the uniform code does

499
00:16:47,120 --> 00:16:49,360
achieve linear minimum distance while

500
00:16:49,360 --> 00:16:51,600
the tillets zimmer code gets sort of

501
00:16:51,600 --> 00:16:54,639
sublinear minimum distance

502
00:16:54,639 --> 00:16:56,000
as a way of explaining this you can

503
00:16:56,000 --> 00:16:58,000
consider what do these minimum distance

504
00:16:58,000 --> 00:16:58,959
uh

505
00:16:58,959 --> 00:17:00,000
what does the minimum distance really

506
00:17:00,000 --> 00:17:01,440
look like with respect to

507
00:17:01,440 --> 00:17:03,440
the parity check matrix and one way to

508
00:17:03,440 --> 00:17:05,359
formulate what this is is it's how many

509
00:17:05,359 --> 00:17:07,599
columns of this parity check matrix do

510
00:17:07,599 --> 00:17:09,280
you need to add together such that you

511
00:17:09,280 --> 00:17:10,959
get the zero vector

512
00:17:10,959 --> 00:17:11,919
and

513
00:17:11,919 --> 00:17:13,679
one way of going about doing this and in

514
00:17:13,679 --> 00:17:15,760
fact what typically are the low way

515
00:17:15,760 --> 00:17:18,319
code words in this uh what happens is

516
00:17:18,319 --> 00:17:19,599
you take several columns from the left

517
00:17:19,599 --> 00:17:22,319
hand side which almost cancel out but

518
00:17:22,319 --> 00:17:24,319
have maybe two ones which are nearby

519
00:17:24,319 --> 00:17:26,160
each other which don't cancel

520
00:17:26,160 --> 00:17:27,439
and then you include the corresponding

521
00:17:27,439 --> 00:17:28,720
column from the right which sort of

522
00:17:28,720 --> 00:17:31,120
bridges the gap between these two

523
00:17:31,120 --> 00:17:33,200
as shown here if the gap is more than

524
00:17:33,200 --> 00:17:34,799
one you can then include like the next

525
00:17:34,799 --> 00:17:36,400
two columns in the right

526
00:17:36,400 --> 00:17:39,039
half and so in some sense uh these

527
00:17:39,039 --> 00:17:41,200
diagonals allow you to sort of bridge

528
00:17:41,200 --> 00:17:42,480
the gap between

529
00:17:42,480 --> 00:17:43,679
code words from the left which are

530
00:17:43,679 --> 00:17:45,679
almost equal and that's the structure of

531
00:17:45,679 --> 00:17:48,160
minimum weight code words in this code

532
00:17:48,160 --> 00:17:49,919
and so given this you know you could try

533
00:17:49,919 --> 00:17:52,559
to formulate ways to improve the

534
00:17:52,559 --> 00:17:56,080
minimum weight performance of this code

535
00:17:56,080 --> 00:17:58,320
so this leads us to our first code

536
00:17:58,320 --> 00:17:59,919
silver code one and we start with the

537
00:17:59,919 --> 00:18:02,640
telescope code uh zoom our code excuse

538
00:18:02,640 --> 00:18:04,880
me and we remove the weight two columns

539
00:18:04,880 --> 00:18:06,559
and we replace them with uh higher

540
00:18:06,559 --> 00:18:09,440
weight sort of weight w columns uh we we

541
00:18:09,440 --> 00:18:11,360
keep the g alt

542
00:18:11,360 --> 00:18:12,640
form

543
00:18:12,640 --> 00:18:14,880
but uh allow g to increase from one is

544
00:18:14,880 --> 00:18:16,480
the basic idea and below this main

545
00:18:16,480 --> 00:18:19,039
diagonal we fill the

546
00:18:19,039 --> 00:18:19,840
uh

547
00:18:19,840 --> 00:18:22,240
fill sum region uh

548
00:18:22,240 --> 00:18:24,799
with uniformly random columns subject to

549
00:18:24,799 --> 00:18:27,039
having the desired column weight w

550
00:18:27,039 --> 00:18:29,600
so shown here right we have a gap of

551
00:18:29,600 --> 00:18:32,320
four with a column weight of three

552
00:18:32,320 --> 00:18:34,400
and we just fill in the values below the

553
00:18:34,400 --> 00:18:36,080
cap uniformly random

554
00:18:36,080 --> 00:18:37,679
and the idea here

555
00:18:37,679 --> 00:18:39,200
is that you know if we go back to our

556
00:18:39,200 --> 00:18:41,360
example before right you might want to

557
00:18:41,360 --> 00:18:43,760
uh you know you get code work columns

558
00:18:43,760 --> 00:18:45,440
from the left half which are almost

559
00:18:45,440 --> 00:18:46,799
equal and then you include the

560
00:18:46,799 --> 00:18:47,919
corresponding columns on the right you

561
00:18:47,919 --> 00:18:49,440
can see that this no longer works

562
00:18:49,440 --> 00:18:52,000
because the non-zero locations below the

563
00:18:52,000 --> 00:18:53,840
main diagonal uh

564
00:18:53,840 --> 00:18:55,919
won't cancel out nicely most likely and

565
00:18:55,919 --> 00:18:58,720
so this sort of allows

566
00:18:58,720 --> 00:19:00,559
this new code to

567
00:19:00,559 --> 00:19:02,559
sort of defend partially at least defend

568
00:19:02,559 --> 00:19:04,080
against these bridging

569
00:19:04,080 --> 00:19:06,080
attacks so to speak

570
00:19:06,080 --> 00:19:08,559
and we experimentally validate that this

571
00:19:08,559 --> 00:19:11,039
alteration does in fact improve the tz

572
00:19:11,039 --> 00:19:13,120
code significantly and we almost get the

573
00:19:13,120 --> 00:19:14,640
same performance as uniform with the

574
00:19:14,640 --> 00:19:17,360
same column weight

575
00:19:17,440 --> 00:19:19,600
through further iteration and looking at

576
00:19:19,600 --> 00:19:20,799
what

577
00:19:20,799 --> 00:19:22,320
what type of low weight code words exist

578
00:19:22,320 --> 00:19:25,039
in these codes we identified that often

579
00:19:25,039 --> 00:19:28,400
in the right hand side you'll get

580
00:19:28,400 --> 00:19:29,919
two columns which are very similar and

581
00:19:29,919 --> 00:19:31,200
mostly cancel with each other and this

582
00:19:31,200 --> 00:19:33,360
allows a similar type of bridging attack

583
00:19:33,360 --> 00:19:36,320
or bridging phenomenon per se

584
00:19:36,320 --> 00:19:38,400
and to prevent this we discovered

585
00:19:38,400 --> 00:19:40,080
through extensive experimentation that

586
00:19:40,080 --> 00:19:42,400
if you add an additional diagonals below

587
00:19:42,400 --> 00:19:44,400
this main diagonal it helps prevent this

588
00:19:44,400 --> 00:19:46,720
attack sort of intuitively it ensures

589
00:19:46,720 --> 00:19:50,320
that the spreading is is larger

590
00:19:50,320 --> 00:19:52,720
across the rows and you can't simply

591
00:19:52,720 --> 00:19:54,960
get unlucky and have a few columns on

592
00:19:54,960 --> 00:19:57,280
the right hand side uh canceled properly

593
00:19:57,280 --> 00:20:00,480
for more details to see the paper

594
00:20:00,480 --> 00:20:01,919
uh but the main takeaway is that this

595
00:20:01,919 --> 00:20:03,039
further significantly improves the

596
00:20:03,039 --> 00:20:05,440
performance of the code

597
00:20:05,440 --> 00:20:07,440
uh now we turn to the

598
00:20:07,440 --> 00:20:09,760
optimizing the left half where the main

599
00:20:09,760 --> 00:20:12,000
issue is that although our

600
00:20:12,000 --> 00:20:14,159
code is linear time and codable the

601
00:20:14,159 --> 00:20:16,320
memory efficiency of performing the left

602
00:20:16,320 --> 00:20:18,080
half of the parity check matrix is

603
00:20:18,080 --> 00:20:20,559
actually quite low roughly speaking uh

604
00:20:20,559 --> 00:20:22,640
what this corresponds to is taking this

605
00:20:22,640 --> 00:20:24,080
left half of the matrix and multiplying

606
00:20:24,080 --> 00:20:26,000
it with a vector and since it's more or

607
00:20:26,000 --> 00:20:28,240
less uniformly random this corresponds

608
00:20:28,240 --> 00:20:31,039
to performing uh roughly you know

609
00:20:31,039 --> 00:20:33,360
million random accesses into an array of

610
00:20:33,360 --> 00:20:35,760
length 1 million or you know whatever

611
00:20:35,760 --> 00:20:37,840
the array size is and this ends up being

612
00:20:37,840 --> 00:20:39,600
really inefficient for from a memory

613
00:20:39,600 --> 00:20:41,919
perspective because every memory access

614
00:20:41,919 --> 00:20:43,280
goes to main memory which is

615
00:20:43,280 --> 00:20:45,120
significantly slower than say icash or

616
00:20:45,120 --> 00:20:47,280
something like that

617
00:20:47,280 --> 00:20:49,760
uh we tried numerous techniques to try

618
00:20:49,760 --> 00:20:51,280
to improve the cash efficiency and we

619
00:20:51,280 --> 00:20:53,440
ended up landing on this one which is

620
00:20:53,440 --> 00:20:55,840
surprisingly simple in that you replace

621
00:20:55,840 --> 00:20:57,840
the laptop with just several diagonals

622
00:20:57,840 --> 00:20:58,799
or

623
00:20:58,799 --> 00:21:01,360
w diagonals going across

624
00:21:01,360 --> 00:21:02,880
and

625
00:21:02,880 --> 00:21:05,039
they need to be spaced irregularly with

626
00:21:05,039 --> 00:21:06,720
a certain structure in order to avoid

627
00:21:06,720 --> 00:21:08,559
some pathological cases

628
00:21:08,559 --> 00:21:11,200
uh but we experimentally validated this

629
00:21:11,200 --> 00:21:14,080
that our codes do in fact work well

630
00:21:14,080 --> 00:21:16,799
and in fact this uniform or this uh

631
00:21:16,799 --> 00:21:18,720
silver code actually outperforms the

632
00:21:18,720 --> 00:21:20,080
uniform code with the same weight which

633
00:21:20,080 --> 00:21:22,799
is somewhat surprising

634
00:21:22,799 --> 00:21:26,000
uh our final optimization is that uh we

635
00:21:26,000 --> 00:21:28,320
change that the current most uh

636
00:21:28,320 --> 00:21:30,320
inefficient part of this code is that uh

637
00:21:30,320 --> 00:21:32,080
sampling this main diagonal which

638
00:21:32,080 --> 00:21:33,440
consists of these sort of uniformly

639
00:21:33,440 --> 00:21:35,919
random columns subject to being in this

640
00:21:35,919 --> 00:21:37,039
band

641
00:21:37,039 --> 00:21:39,039
is actually quite inefficient especially

642
00:21:39,039 --> 00:21:41,039
when this matrix a size of one million

643
00:21:41,039 --> 00:21:43,440
you could say store in memory but this

644
00:21:43,440 --> 00:21:46,720
again is so undesirable due to its size

645
00:21:46,720 --> 00:21:47,840
and so

646
00:21:47,840 --> 00:21:50,000
we experimented with deranimizing the

647
00:21:50,000 --> 00:21:54,320
this uh main diagonal by repeating the

648
00:21:54,320 --> 00:21:57,120
rows after sort of every g steps

649
00:21:57,120 --> 00:21:58,640
and we experimentally validated that

650
00:21:58,640 --> 00:22:01,200
this uh doesn't hurt uh minimum distance

651
00:22:01,200 --> 00:22:02,480
performance

652
00:22:02,480 --> 00:22:04,400
we also make the rows regular meaning

653
00:22:04,400 --> 00:22:05,440
that they all have the same number of

654
00:22:05,440 --> 00:22:07,280
ones in each row and this further helps

655
00:22:07,280 --> 00:22:08,320
improve the efficiency of the

656
00:22:08,320 --> 00:22:10,159
implementation

657
00:22:10,159 --> 00:22:12,320
but the final takeaway is that our final

658
00:22:12,320 --> 00:22:15,760
code is sort of highly structured uh

659
00:22:15,760 --> 00:22:17,840
and but still achieves as good of

660
00:22:17,840 --> 00:22:19,120
minimum distance performance as the

661
00:22:19,120 --> 00:22:20,480
uniform code

662
00:22:20,480 --> 00:22:22,480
we designed two codes although others

663
00:22:22,480 --> 00:22:24,000
could be

664
00:22:24,000 --> 00:22:25,760
considered which have column weight 5

665
00:22:25,760 --> 00:22:27,360
and column weight 11 and i get the

666
00:22:27,360 --> 00:22:29,520
corresponding uh minimum distance from

667
00:22:29,520 --> 00:22:31,760
here

668
00:22:32,080 --> 00:22:33,440
uh the other

669
00:22:33,440 --> 00:22:35,440
point of optimization that we considered

670
00:22:35,440 --> 00:22:37,360
is the sort of the right the running

671
00:22:37,360 --> 00:22:39,360
time of our codes so shown here at the

672
00:22:39,360 --> 00:22:41,760
bottom is our final code silver five uh

673
00:22:41,760 --> 00:22:44,000
and the weight five variant of it has

674
00:22:44,000 --> 00:22:44,799
takes

675
00:22:44,799 --> 00:22:47,840
uh one point one three seconds to encode

676
00:22:47,840 --> 00:22:50,559
a vector of length sixteen million uh

677
00:22:50,559 --> 00:22:52,880
you can compare this to the work of boil

678
00:22:52,880 --> 00:22:56,320
at all which uses quasi-cichlid codes

679
00:22:56,320 --> 00:22:57,679
which takes four seconds for the same

680
00:22:57,679 --> 00:23:00,320
operation or the tz code which takes two

681
00:23:00,320 --> 00:23:02,000
seconds so you can see it's a very

682
00:23:02,000 --> 00:23:03,840
significant order magnitude

683
00:23:03,840 --> 00:23:07,439
improvement over the state of art

684
00:23:07,520 --> 00:23:08,799
while when applying this to our

685
00:23:08,799 --> 00:23:10,559
oblivious transfer protocol we can see

686
00:23:10,559 --> 00:23:11,760
that this significantly improves the

687
00:23:11,760 --> 00:23:14,000
performance so our protocol is basically

688
00:23:14,000 --> 00:23:15,600
the same protocol as the boiler tall one

689
00:23:15,600 --> 00:23:17,440
shown here but with our code replaced

690
00:23:17,440 --> 00:23:19,039
and you can see this reduces the running

691
00:23:19,039 --> 00:23:20,640
time from 10 seconds to half a second

692
00:23:20,640 --> 00:23:22,720
for 16 million ots

693
00:23:22,720 --> 00:23:24,480
and we achieve the same

694
00:23:24,480 --> 00:23:27,520
sublinear communication

695
00:23:27,760 --> 00:23:29,320
another work from

696
00:23:29,320 --> 00:23:32,159
2020 uses primal lpn and a sort of

697
00:23:32,159 --> 00:23:33,440
similar structure

698
00:23:33,440 --> 00:23:35,440
to ours and they

699
00:23:35,440 --> 00:23:38,159
can perform 10 000 ots in uh roughly

700
00:23:38,159 --> 00:23:39,840
like 1.2 seconds while ours takes a

701
00:23:39,840 --> 00:23:41,120
quarter second so very significant

702
00:23:41,120 --> 00:23:43,120
improvement uh what's more ours achieves

703
00:23:43,120 --> 00:23:45,360
the silent property was theirs does not

704
00:23:45,360 --> 00:23:47,279
maybe the most surprising takeaway is

705
00:23:47,279 --> 00:23:49,039
that our protocol is actually faster

706
00:23:49,039 --> 00:23:51,120
than the original ot extension work of

707
00:23:51,120 --> 00:23:53,200
iknp this work has stood the test time

708
00:23:53,200 --> 00:23:55,520
for almost 20 years and our and we

709
00:23:55,520 --> 00:23:57,279
finally are able to beat it in terms of

710
00:23:57,279 --> 00:23:58,799
running time and

711
00:23:58,799 --> 00:24:00,159
also significantly improve its

712
00:24:00,159 --> 00:24:02,480
communication

713
00:24:02,480 --> 00:24:04,720
uh a similar story is true for the volt

714
00:24:04,720 --> 00:24:06,480
performance is that uh we are roughly

715
00:24:06,480 --> 00:24:08,799
five times faster than uh

716
00:24:08,799 --> 00:24:12,480
another full work from 2020 uh and this

717
00:24:12,480 --> 00:24:15,919
and we also achieve this silent property

718
00:24:15,919 --> 00:24:18,320
and with that i conclude my talk silver

719
00:24:18,320 --> 00:24:20,000
silent vole and oblivious transfer thank

720
00:24:20,000 --> 00:24:22,960
you

