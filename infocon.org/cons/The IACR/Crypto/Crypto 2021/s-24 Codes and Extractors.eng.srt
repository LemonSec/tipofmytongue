1
00:00:00,080 --> 00:00:02,320
and

2
00:00:06,160 --> 00:00:07,370
sorry

3
00:00:07,370 --> 00:00:09,840
[Music]

4
00:00:09,840 --> 00:00:12,240
okay there you go have a good session

5
00:00:12,240 --> 00:00:14,080
thank you thank you very much so hi

6
00:00:14,080 --> 00:00:16,160
everyone welcome to the session today on

7
00:00:16,160 --> 00:00:19,119
codes and extractors so we will hear

8
00:00:19,119 --> 00:00:22,160
five talks each five minutes and then

9
00:00:22,160 --> 00:00:25,279
followed by 25 minutes of q a so for

10
00:00:25,279 --> 00:00:26,880
those speakers

11
00:00:26,880 --> 00:00:27,760
please

12
00:00:27,760 --> 00:00:29,359
stick to the five minutes and stick

13
00:00:29,359 --> 00:00:31,439
around until the end to answer questions

14
00:00:31,439 --> 00:00:33,040
and for the audience if you have

15
00:00:33,040 --> 00:00:35,360
questions either post it on the tulip so

16
00:00:35,360 --> 00:00:37,520
the uh solid link will appear in the

17
00:00:37,520 --> 00:00:39,120
chat or

18
00:00:39,120 --> 00:00:41,440
ask the question in the q a just by

19
00:00:41,440 --> 00:00:43,840
raising the hand whichever you prefer

20
00:00:43,840 --> 00:00:46,879
and yeah i think uh then with this we're

21
00:00:46,879 --> 00:00:49,920
ready to start uh you do you want to

22
00:00:49,920 --> 00:00:51,440
share your screen

23
00:00:51,440 --> 00:00:52,719
not sure

24
00:00:52,719 --> 00:00:54,879
okay

25
00:00:54,879 --> 00:00:57,760
yes perfect thank you so yeah the first

26
00:00:57,760 --> 00:00:59,199
talk of this session will be on

27
00:00:59,199 --> 00:01:01,280
smoothing out binary linear codes and

28
00:01:01,280 --> 00:01:03,280
worst case sub exponential hardness for

29
00:01:03,280 --> 00:01:07,360
lpn um by yu yu and zhang and you will

30
00:01:07,360 --> 00:01:10,000
give the talk sage is yours

31
00:01:10,000 --> 00:01:11,040
thank you

32
00:01:11,040 --> 00:01:12,960
i'm glad to introduce our paper on how

33
00:01:12,960 --> 00:01:15,200
to prove a worst case exponential

34
00:01:15,200 --> 00:01:17,360
hardness for appear

35
00:01:17,360 --> 00:01:18,400
and

36
00:01:18,400 --> 00:01:20,640
i'll start with the introduction

37
00:01:20,640 --> 00:01:22,720
so the search version oh sorry search

38
00:01:22,720 --> 00:01:24,479
version of the decoding problem asks to

39
00:01:24,479 --> 00:01:27,119
decode out the message x given a noisy

40
00:01:27,119 --> 00:01:30,079
codeword in presence of noise e and

41
00:01:30,079 --> 00:01:32,320
every case of uh this problem is called

42
00:01:32,320 --> 00:01:34,159
landing parity is noise where this

43
00:01:34,159 --> 00:01:36,159
matrix and secret is sampled uniformly

44
00:01:36,159 --> 00:01:38,079
from random and

45
00:01:38,079 --> 00:01:40,320
the noise follows from the brain legit

46
00:01:40,320 --> 00:01:42,720
distribution and we know that the worst

47
00:01:42,720 --> 00:01:43,600
case

48
00:01:43,600 --> 00:01:44,960
worst case version of the problem is

49
00:01:44,960 --> 00:01:47,759
called the ncp nearest codeword problem

50
00:01:47,759 --> 00:01:50,000
and in this case we consider the

51
00:01:50,000 --> 00:01:52,960
promised version where this noise vector

52
00:01:52,960 --> 00:01:54,799
is guaranteed to have the

53
00:01:54,799 --> 00:01:57,759
exact amount of hemingway

54
00:01:57,759 --> 00:01:59,079
at eurocrypt

55
00:01:59,079 --> 00:02:02,240
2019 uh black schedule gave the first

56
00:02:02,240 --> 00:02:04,560
westgate to advocates reduction from ncp

57
00:02:04,560 --> 00:02:05,840
to lpn

58
00:02:05,840 --> 00:02:08,239
suppose we have an ncp instance as

59
00:02:08,239 --> 00:02:10,318
visualized in this

60
00:02:10,318 --> 00:02:11,680
slide

61
00:02:11,680 --> 00:02:13,440
so then we uh

62
00:02:13,440 --> 00:02:15,040
the goal is to

63
00:02:15,040 --> 00:02:16,640
transform the ncp instance into the

64
00:02:16,640 --> 00:02:20,319
airplane sample by multiplying with a

65
00:02:20,319 --> 00:02:23,520
sparse vector r and xor this

66
00:02:23,520 --> 00:02:25,840
message s since it has no entropy at all

67
00:02:25,840 --> 00:02:28,800
with the uniform random mask y

68
00:02:28,800 --> 00:02:32,160
and we have by the smoothing level that

69
00:02:32,160 --> 00:02:34,480
this the resulting sample

70
00:02:34,480 --> 00:02:37,920
is exactly follows uh exactly follow is

71
00:02:37,920 --> 00:02:40,480
a sorry

72
00:02:41,680 --> 00:02:43,360
that this uh the process generates the

73
00:02:43,360 --> 00:02:45,599
airplane sample following the exact

74
00:02:45,599 --> 00:02:48,640
distribution we needed however

75
00:02:48,640 --> 00:02:51,760
the result is not good enough because uh

76
00:02:51,760 --> 00:02:54,400
you know as you can see uh on the very

77
00:02:54,400 --> 00:02:57,040
strong assumption we get the

78
00:02:57,040 --> 00:02:59,200
very conservative and

79
00:02:59,200 --> 00:03:01,040
actually quite weak result which is

80
00:03:01,040 --> 00:03:04,400
mostly a feasibility result and and we

81
00:03:04,400 --> 00:03:07,040
can see the tension between the

82
00:03:07,040 --> 00:03:09,200
the tension between the um

83
00:03:09,200 --> 00:03:10,239
you know the

84
00:03:10,239 --> 00:03:11,840
assumption and the conclusion is

85
00:03:11,840 --> 00:03:12,959
reflected

86
00:03:12,959 --> 00:03:14,800
on the range of the lambda

87
00:03:14,800 --> 00:03:17,280
so typically we set lambda to be

88
00:03:17,280 --> 00:03:18,640
log n

89
00:03:18,640 --> 00:03:20,239
and and this and in this work we are

90
00:03:20,239 --> 00:03:21,760
going to introduce

91
00:03:21,760 --> 00:03:24,159
to generalize this lemma and to to

92
00:03:24,159 --> 00:03:25,760
improve it

93
00:03:25,760 --> 00:03:26,640
so

94
00:03:26,640 --> 00:03:28,720
here comes our first contribution

95
00:03:28,720 --> 00:03:30,000
and we

96
00:03:30,000 --> 00:03:31,680
observe it's always easy to prove the

97
00:03:31,680 --> 00:03:33,680
unconditional case where the cis

98
00:03:33,680 --> 00:03:35,920
statistics statistically close to

99
00:03:35,920 --> 00:03:37,840
uniform but proving that

100
00:03:37,840 --> 00:03:39,440
uh proving the

101
00:03:39,440 --> 00:03:40,159
uh

102
00:03:40,159 --> 00:03:41,760
conditional case that see as close to

103
00:03:41,760 --> 00:03:43,440
uniform given the leakages less

104
00:03:43,440 --> 00:03:45,280
efficient things we have to make sure

105
00:03:45,280 --> 00:03:48,480
that this holds for all possible error x

106
00:03:48,480 --> 00:03:50,560
so what we proved following we

107
00:03:50,560 --> 00:03:53,200
we show that uh what if i is drawn from

108
00:03:53,200 --> 00:03:55,360
a proper distribution then the boundary

109
00:03:55,360 --> 00:03:57,360
in the conditional case is implied by

110
00:03:57,360 --> 00:04:00,159
that of the unconditional case paying a

111
00:04:00,159 --> 00:04:01,439
reasonable

112
00:04:01,439 --> 00:04:04,080
cost so it suffices to prove proof that

113
00:04:04,080 --> 00:04:06,400
the easier can unconditional case for a

114
00:04:06,400 --> 00:04:09,280
specific code such as balanced code and

115
00:04:09,280 --> 00:04:10,959
independent code

116
00:04:10,959 --> 00:04:13,360
we omitted the details so then we state

117
00:04:13,360 --> 00:04:15,760
our main main theorem first we get

118
00:04:15,760 --> 00:04:18,798
similars out as brvw then

119
00:04:18,798 --> 00:04:21,440
we show that

120
00:04:21,519 --> 00:04:23,360
on the like

121
00:04:23,360 --> 00:04:25,520
our main result which is not known

122
00:04:25,520 --> 00:04:28,080
before if the low noise ncp problem has

123
00:04:28,080 --> 00:04:30,160
almost hardness meaning that the best

124
00:04:30,160 --> 00:04:32,479
known attacks are almost optimal up to

125
00:04:32,479 --> 00:04:35,280
arbitrary polynomial speed up then it

126
00:04:35,280 --> 00:04:38,320
implies that the sub-exponential version

127
00:04:38,320 --> 00:04:40,400
sub exponential hardness for standard

128
00:04:40,400 --> 00:04:42,880
erp where noise is constant

129
00:04:42,880 --> 00:04:44,160
okay

130
00:04:44,160 --> 00:04:46,880
then we also have another acute result

131
00:04:46,880 --> 00:04:49,440
in the sense that

132
00:04:49,440 --> 00:04:51,919
we can reduce the awa to large field

133
00:04:51,919 --> 00:04:53,120
airplane

134
00:04:53,120 --> 00:04:54,720
and on the

135
00:04:54,720 --> 00:04:56,960
vendors when the noise is very strong

136
00:04:56,960 --> 00:04:57,680
and

137
00:04:57,680 --> 00:04:59,520
the proof is very simple can transform

138
00:04:59,520 --> 00:05:01,840
every lw sample into a airplane sample

139
00:05:01,840 --> 00:05:03,440
using random mask

140
00:05:03,440 --> 00:05:04,160
m

141
00:05:04,160 --> 00:05:06,479
we just multiply multiplying the sample

142
00:05:06,479 --> 00:05:10,320
with m so the noise e in the f a w e

143
00:05:10,320 --> 00:05:11,360
will become

144
00:05:11,360 --> 00:05:13,680
m e in the airplane where this m e

145
00:05:13,680 --> 00:05:15,199
exactly follows

146
00:05:15,199 --> 00:05:16,800
followed by the generalized binary

147
00:05:16,800 --> 00:05:19,440
distribution

148
00:05:19,680 --> 00:05:22,400
then i give a short summary of our work

149
00:05:22,400 --> 00:05:24,320
we present the two worst case-to-fg case

150
00:05:24,320 --> 00:05:27,199
reductions for different types of lwe uh

151
00:05:27,199 --> 00:05:29,039
sorry air pn and the large field

152
00:05:29,039 --> 00:05:31,919
airplane can be reduceable from lwe of

153
00:05:31,919 --> 00:05:33,919
the same modulus and that's reduced from

154
00:05:33,919 --> 00:05:35,840
west case assumptions lattice

155
00:05:35,840 --> 00:05:37,360
assumptions secondly we generalized

156
00:05:37,360 --> 00:05:39,360
reduction via vw to

157
00:05:39,360 --> 00:05:42,880
to from promised ncp to lv airplane

158
00:05:42,880 --> 00:05:45,360
eventually allowing to prove exponential

159
00:05:45,360 --> 00:05:47,360
hardness for standard rpm and there are

160
00:05:47,360 --> 00:05:50,160
remains a few urban questions such as

161
00:05:50,160 --> 00:05:51,759
how we can based on the hardness of

162
00:05:51,759 --> 00:05:55,039
european on promise ncp of any code with

163
00:05:55,039 --> 00:05:57,280
a non-trivial meaning

164
00:05:57,280 --> 00:05:59,280
having weight and how to construct the

165
00:05:59,280 --> 00:06:00,639
public encryption or collision

166
00:06:00,639 --> 00:06:01,759
resistance

167
00:06:01,759 --> 00:06:03,199
hash functions from the worst case

168
00:06:03,199 --> 00:06:04,800
decoding problems

169
00:06:04,800 --> 00:06:07,039
actually we had a uh

170
00:06:07,039 --> 00:06:09,120
we didn't we didn't get through because

171
00:06:09,120 --> 00:06:10,800
the the kindness that we proved it's not

172
00:06:10,800 --> 00:06:13,039
strong enough and finally how to find

173
00:06:13,039 --> 00:06:14,160
out more efficient and useful

174
00:06:14,160 --> 00:06:16,720
relationships between aw and airpn

175
00:06:16,720 --> 00:06:18,319
this is my talk thank you for your

176
00:06:18,319 --> 00:06:20,639
attention

177
00:06:20,639 --> 00:06:22,639
thank you so much for your talk

178
00:06:22,639 --> 00:06:23,520
um

179
00:06:23,520 --> 00:06:26,720
so um yeah if you have questions in the

180
00:06:26,720 --> 00:06:29,120
audience please uh stay around or post

181
00:06:29,120 --> 00:06:30,880
them already on sulip and

182
00:06:30,880 --> 00:06:32,560
peter do you want to

183
00:06:32,560 --> 00:06:35,840
say your slides

184
00:06:45,440 --> 00:06:49,319
and you're still muted

185
00:06:56,800 --> 00:06:59,199
if we just

186
00:06:59,199 --> 00:07:02,520
lose peter

187
00:07:02,639 --> 00:07:05,520
no perfect

188
00:07:07,360 --> 00:07:09,440
yeah sorry i you did lose me but i'm

189
00:07:09,440 --> 00:07:10,479
here now

190
00:07:10,479 --> 00:07:12,880
okay perfect

191
00:07:12,880 --> 00:07:14,400
great

192
00:07:14,400 --> 00:07:17,400
yes

193
00:07:19,360 --> 00:07:21,680
so the next talk will be a silvers

194
00:07:21,680 --> 00:07:23,520
silent vole and oblivious transfer from

195
00:07:23,520 --> 00:07:27,360
hardness of decoding ldbc codes um

196
00:07:27,360 --> 00:07:30,319
this is uh joint work by peter brindal

197
00:07:30,319 --> 00:07:31,599
srinivasan

198
00:07:31,599 --> 00:07:33,280
ramen and jeffrey

199
00:07:33,280 --> 00:07:34,880
and peter will give the talk so now

200
00:07:34,880 --> 00:07:37,280
stage is yours

201
00:07:37,280 --> 00:07:38,639
thank you

202
00:07:38,639 --> 00:07:41,199
uh yeah in this work we present

203
00:07:41,199 --> 00:07:43,520
improvements to protocol for performing

204
00:07:43,520 --> 00:07:46,160
oblivious transfer and vector ole

205
00:07:46,160 --> 00:07:47,840
here i won't talk too much about the ot

206
00:07:47,840 --> 00:07:50,080
case but it's basically identical

207
00:07:50,080 --> 00:07:52,879
to this vole here

208
00:07:52,879 --> 00:07:54,479
vol is a two-party protocol with a

209
00:07:54,479 --> 00:07:56,160
sender and receiver

210
00:07:56,160 --> 00:07:57,280
and in our

211
00:07:57,280 --> 00:07:59,520
formulation of it the sender should get

212
00:07:59,520 --> 00:08:01,199
a random vector b

213
00:08:01,199 --> 00:08:04,000
and a scalar delta over some field and

214
00:08:04,000 --> 00:08:05,919
the receiver should get two random

215
00:08:05,919 --> 00:08:07,680
vectors a and c

216
00:08:07,680 --> 00:08:09,120
which are sort of all these are

217
00:08:09,120 --> 00:08:10,479
uniformly random subject to the

218
00:08:10,479 --> 00:08:12,879
correlation that c minus b equals delta

219
00:08:12,879 --> 00:08:14,879
times a

220
00:08:14,879 --> 00:08:16,000
so you can kind of think of this as a

221
00:08:16,000 --> 00:08:18,400
secret sharing of delta times a

222
00:08:18,400 --> 00:08:20,240
b output to the parties

223
00:08:20,240 --> 00:08:23,120
and then you can use this to do ot or or

224
00:08:23,120 --> 00:08:26,400
various other protocols like psi

225
00:08:26,400 --> 00:08:28,479
uh i won't get into the details but uh

226
00:08:28,479 --> 00:08:30,400
the way the protocol that we use works

227
00:08:30,400 --> 00:08:32,159
it starts with this thing called a

228
00:08:32,159 --> 00:08:35,120
punctured prf which outputs uh some keys

229
00:08:35,120 --> 00:08:37,360
to two parties it's sort of not very

230
00:08:37,360 --> 00:08:38,479
interactive

231
00:08:38,479 --> 00:08:40,399
and these keys can be locally expanded

232
00:08:40,399 --> 00:08:41,519
into

233
00:08:41,519 --> 00:08:43,519
almost the correlation we want except

234
00:08:43,519 --> 00:08:44,399
for

235
00:08:44,399 --> 00:08:47,839
the issue that a is actually sparse

236
00:08:47,839 --> 00:08:49,839
so in the protocol these vectors might

237
00:08:49,839 --> 00:08:52,160
be a length like a million but a is a

238
00:08:52,160 --> 00:08:55,200
sparse vector say a length uh say weight

239
00:08:55,200 --> 00:08:58,320
like 20 or i mean say 200 or so

240
00:08:58,320 --> 00:08:59,279
uh

241
00:08:59,279 --> 00:09:01,279
and so what we want to do is bootstrap

242
00:09:01,279 --> 00:09:04,080
this correlation to get the our desired

243
00:09:04,080 --> 00:09:06,399
correlation and to do this we can apply

244
00:09:06,399 --> 00:09:08,640
the lpn assumption

245
00:09:08,640 --> 00:09:11,279
here what we'll do is multiply these

246
00:09:11,279 --> 00:09:13,360
vectors from the left with a

247
00:09:13,360 --> 00:09:14,800
sort of more or less uniformly random

248
00:09:14,800 --> 00:09:16,320
matrix g

249
00:09:16,320 --> 00:09:18,080
and this compresses

250
00:09:18,080 --> 00:09:20,080
these vectors and in particular it makes

251
00:09:20,080 --> 00:09:22,720
this sparse a prime vector into a

252
00:09:22,720 --> 00:09:24,560
uniformly random

253
00:09:24,560 --> 00:09:26,240
shorter vector a

254
00:09:26,240 --> 00:09:29,360
and since g is linear uh we maintain our

255
00:09:29,360 --> 00:09:32,200
linear correlation and we get our final

256
00:09:32,200 --> 00:09:33,920
[Music]

257
00:09:33,920 --> 00:09:35,200
output

258
00:09:35,200 --> 00:09:37,040
um so

259
00:09:37,040 --> 00:09:39,279
in our in our case we're doing

260
00:09:39,279 --> 00:09:40,800
uh we want to generate like say a

261
00:09:40,800 --> 00:09:43,360
million ots or volts and in this case

262
00:09:43,360 --> 00:09:45,279
this matrix g will be very large say

263
00:09:45,279 --> 00:09:48,080
order a trillion and uh that makes

264
00:09:48,080 --> 00:09:50,640
multiplication extremely slow

265
00:09:50,640 --> 00:09:53,200
in the classic lpn setting where this

266
00:09:53,200 --> 00:09:56,320
matrix g needs to be uniformly random

267
00:09:56,320 --> 00:09:58,560
uh in order to get around this issue and

268
00:09:58,560 --> 00:10:00,720
get good performance a lot of works have

269
00:10:00,720 --> 00:10:03,120
been looking at how to perform structur

270
00:10:03,120 --> 00:10:06,079
do structured lpn here where we allow g

271
00:10:06,079 --> 00:10:08,000
to have some extra structure

272
00:10:08,000 --> 00:10:09,440
uh which improves the running time of

273
00:10:09,440 --> 00:10:11,440
this multiplication

274
00:10:11,440 --> 00:10:12,959
and uh sort of prior works have to

275
00:10:12,959 --> 00:10:14,079
consider like

276
00:10:14,079 --> 00:10:16,800
uh g with like n log n

277
00:10:16,800 --> 00:10:19,200
uh overhead and in this work we design a

278
00:10:19,200 --> 00:10:22,560
new matrix which gets linear time uh

279
00:10:22,560 --> 00:10:23,760
multiplication

280
00:10:23,760 --> 00:10:26,000
uh while still maintaining the lpn

281
00:10:26,000 --> 00:10:28,200
hardness

282
00:10:28,200 --> 00:10:29,360
[Music]

283
00:10:29,360 --> 00:10:31,440
so we work over the dual version of lpn

284
00:10:31,440 --> 00:10:33,680
here as i sort of said is you multiply

285
00:10:33,680 --> 00:10:36,480
this you do g times this sparse vector e

286
00:10:36,480 --> 00:10:39,040
and you should get a random output r

287
00:10:39,040 --> 00:10:42,399
um there's been numerous attacks uh

288
00:10:42,399 --> 00:10:46,079
over the years to try to break lpn um

289
00:10:46,079 --> 00:10:47,600
and it would be tedious to go through

290
00:10:47,600 --> 00:10:50,000
all of them but fortunately we make this

291
00:10:50,000 --> 00:10:51,680
sort of and others who made this

292
00:10:51,680 --> 00:10:53,680
observation that you can sort of reduce

293
00:10:53,680 --> 00:10:55,920
this uh setting to uh where the

294
00:10:55,920 --> 00:10:57,440
adversary is allowed to pre-process the

295
00:10:57,440 --> 00:10:59,600
matrix and output this uh sort of s

296
00:10:59,600 --> 00:11:01,440
vector v and then

297
00:11:01,440 --> 00:11:03,120
their distinguishing power is basically

298
00:11:03,120 --> 00:11:04,720
just interproducting

299
00:11:04,720 --> 00:11:06,959
r with v

300
00:11:06,959 --> 00:11:08,640
and this leads us to

301
00:11:08,640 --> 00:11:11,040
the sort of conclusion that really what

302
00:11:11,040 --> 00:11:12,240
we need to do is find an error

303
00:11:12,240 --> 00:11:14,880
correcting code g h which has high

304
00:11:14,880 --> 00:11:16,880
minimum distance and then for efficiency

305
00:11:16,880 --> 00:11:19,200
we want a good encoding time for the

306
00:11:19,200 --> 00:11:20,959
aircraft

307
00:11:20,959 --> 00:11:21,920
and

308
00:11:21,920 --> 00:11:22,640
we

309
00:11:22,640 --> 00:11:24,480
search for various codes and we end up

310
00:11:24,480 --> 00:11:25,600
landing on

311
00:11:25,600 --> 00:11:27,519
low density parity check codes these

312
00:11:27,519 --> 00:11:28,880
codes are sort of characterized by

313
00:11:28,880 --> 00:11:31,360
having a parity check matrix h which is

314
00:11:31,360 --> 00:11:32,480
sparse

315
00:11:32,480 --> 00:11:34,399
and this leveraging the sparsity you can

316
00:11:34,399 --> 00:11:36,320
sort of solve the system of equations

317
00:11:36,320 --> 00:11:38,399
instead of doing the multiplication this

318
00:11:38,399 --> 00:11:40,800
sort of intuition at least

319
00:11:40,800 --> 00:11:43,600
and our our

320
00:11:43,600 --> 00:11:45,680
actual final parity check matrix is sort

321
00:11:45,680 --> 00:11:48,320
of depicted here it's highly structured

322
00:11:48,320 --> 00:11:51,040
and we through extensive experimental

323
00:11:51,040 --> 00:11:52,320
evaluation we

324
00:11:52,320 --> 00:11:54,399
conjecture it to linear minimum distance

325
00:11:54,399 --> 00:11:56,959
along with some analytical results

326
00:11:56,959 --> 00:11:57,920
but

327
00:11:57,920 --> 00:11:59,360
on the performance side this code is

328
00:11:59,360 --> 00:12:01,760
extremely fast maybe 20 to 40 times

329
00:12:01,760 --> 00:12:04,800
faster than prior prior

330
00:12:04,800 --> 00:12:06,800
approaches

331
00:12:06,800 --> 00:12:08,480
while still achieving the desired

332
00:12:08,480 --> 00:12:09,760
minimum distance

333
00:12:09,760 --> 00:12:12,000
and this translates to extremely fast

334
00:12:12,000 --> 00:12:13,760
performance for ot

335
00:12:13,760 --> 00:12:14,800
uh

336
00:12:14,800 --> 00:12:17,279
previous a work of boyle at all for

337
00:12:17,279 --> 00:12:19,279
doing sort of the same type of ot

338
00:12:19,279 --> 00:12:21,279
protocol just with a different matrix

339
00:12:21,279 --> 00:12:22,880
had a running time like 10 seconds for

340
00:12:22,880 --> 00:12:24,959
16 million ots while we get half a

341
00:12:24,959 --> 00:12:26,160
second

342
00:12:26,160 --> 00:12:27,920
and we also beat sort of the classic

343
00:12:27,920 --> 00:12:31,040
ikmp ot extension approach uh in running

344
00:12:31,040 --> 00:12:34,000
time and significantly in communication

345
00:12:34,000 --> 00:12:36,560
we get a similar result for vector ole

346
00:12:36,560 --> 00:12:39,279
uh

347
00:12:39,279 --> 00:12:40,560
last year

348
00:12:40,560 --> 00:12:43,440
and uh yeah for details see the paper or

349
00:12:43,440 --> 00:12:46,480
the full talk thanks

350
00:12:46,720 --> 00:12:50,000
uh thank you so much for your talk um

351
00:12:50,000 --> 00:12:52,399
yeah again any questions please post and

352
00:12:52,399 --> 00:12:55,120
uh iland um will be the next speaker do

353
00:12:55,120 --> 00:12:56,079
you want to

354
00:12:56,079 --> 00:12:58,959
share your screen

355
00:12:58,959 --> 00:13:00,959
so uh the next talk will be on

356
00:13:00,959 --> 00:13:02,560
non-malleable quotes for bounded

357
00:13:02,560 --> 00:13:04,639
polynomial depth tampering

358
00:13:04,639 --> 00:13:08,000
this is joint work by donna

359
00:13:08,000 --> 00:13:09,839
godski and rafael pass and ilan will

360
00:13:09,839 --> 00:13:11,839
give the talk

361
00:13:11,839 --> 00:13:14,000
hi everyone can you hear me

362
00:13:14,000 --> 00:13:14,880
yes

363
00:13:14,880 --> 00:13:16,079
perfect

364
00:13:16,079 --> 00:13:18,320
thanks so i'll talk about the problem of

365
00:13:18,320 --> 00:13:20,320
constructing non-variable codes so a

366
00:13:20,320 --> 00:13:22,880
non-variable code is this a primitive

367
00:13:22,880 --> 00:13:24,560
that allows you to

368
00:13:24,560 --> 00:13:27,120
to work in the following setting there

369
00:13:27,120 --> 00:13:28,880
is a sender that has a message and it

370
00:13:28,880 --> 00:13:31,200
wants to transmit and transmit it to a

371
00:13:31,200 --> 00:13:33,360
receiver so it sends it over a digital

372
00:13:33,360 --> 00:13:35,200
channel but there is a man in the middle

373
00:13:35,200 --> 00:13:37,120
attacker that intercepts the message

374
00:13:37,120 --> 00:13:39,120
changes it in an arbitrary way and then

375
00:13:39,120 --> 00:13:41,680
forwards it to the receiver

376
00:13:41,680 --> 00:13:44,320
so that's uh the setting that we want to

377
00:13:44,320 --> 00:13:46,480
handle and the nonmanabel code allows

378
00:13:46,480 --> 00:13:48,560
you to do exactly that

379
00:13:48,560 --> 00:13:50,480
informally what we want is to make sure

380
00:13:50,480 --> 00:13:51,279
that

381
00:13:51,279 --> 00:13:53,519
the adversary that sits on the channel

382
00:13:53,519 --> 00:13:55,680
and modifies the message arbitrarily

383
00:13:55,680 --> 00:13:57,279
will not be able to modify the

384
00:13:57,279 --> 00:13:59,440
underlying message inside the encoding

385
00:13:59,440 --> 00:14:02,000
in a meaningful way what do we mean by a

386
00:14:02,000 --> 00:14:04,720
meaningful modification it's that we

387
00:14:04,720 --> 00:14:06,800
want to make sure that the coded message

388
00:14:06,800 --> 00:14:08,720
is either the original message which is

389
00:14:08,720 --> 00:14:10,480
great the adversary didn't change

390
00:14:10,480 --> 00:14:11,440
anything

391
00:14:11,440 --> 00:14:14,000
or it's something completely unrelated

392
00:14:14,000 --> 00:14:16,480
and it's necessary to allow this under

393
00:14:16,480 --> 00:14:19,120
unrelated decoding because the adversary

394
00:14:19,120 --> 00:14:20,639
could just intercept the message and

395
00:14:20,639 --> 00:14:23,120
send something completely independent or

396
00:14:23,120 --> 00:14:24,240
a random

397
00:14:24,240 --> 00:14:26,000
sequence of bits

398
00:14:26,000 --> 00:14:27,600
so we want an encoding scheme that

399
00:14:27,600 --> 00:14:29,440
guarantees that this is the only

400
00:14:29,440 --> 00:14:31,279
possible attack and notice that we want

401
00:14:31,279 --> 00:14:33,199
efficient decoding

402
00:14:33,199 --> 00:14:34,880
okay so this is a non-male level code it

403
00:14:34,880 --> 00:14:36,720
was introduced about 10 years ago a

404
00:14:36,720 --> 00:14:39,040
little bit more and it has it had tons

405
00:14:39,040 --> 00:14:40,959
of applications without complexity

406
00:14:40,959 --> 00:14:43,120
theory coding theory cryptography of

407
00:14:43,120 --> 00:14:44,880
course and more

408
00:14:44,880 --> 00:14:47,360
see the paper or the full length talk

409
00:14:47,360 --> 00:14:48,800
for details

410
00:14:48,800 --> 00:14:50,959
but i'll just tell you a couple of very

411
00:14:50,959 --> 00:14:53,279
basic facts the first one is that if you

412
00:14:53,279 --> 00:14:55,920
want to be able to do efficient decoding

413
00:14:55,920 --> 00:14:57,120
there is no way to construct a

414
00:14:57,120 --> 00:14:59,519
non-valuable code that is secure for an

415
00:14:59,519 --> 00:15:02,000
arbitrary polynomial time attacker why

416
00:15:02,000 --> 00:15:04,800
the attacker could just perform decoding

417
00:15:04,800 --> 00:15:06,959
and if the decoding is let's say if the

418
00:15:06,959 --> 00:15:08,800
underlying message is say zero it can

419
00:15:08,800 --> 00:15:10,560
just send a bunch of zeros that's

420
00:15:10,560 --> 00:15:12,079
clearly a tempering attack a valid

421
00:15:12,079 --> 00:15:14,720
tempering attack and therefore we cannot

422
00:15:14,720 --> 00:15:16,160
hope for a

423
00:15:16,160 --> 00:15:18,240
primitive that is both efficiently

424
00:15:18,240 --> 00:15:20,880
decodable and secure for any polynomial

425
00:15:20,880 --> 00:15:22,240
time attacker

426
00:15:22,240 --> 00:15:24,000
so we must restrict the adversary in

427
00:15:24,000 --> 00:15:25,120
some way

428
00:15:25,120 --> 00:15:27,279
so either it's by its running time or by

429
00:15:27,279 --> 00:15:29,920
the space complexity of the adversary or

430
00:15:29,920 --> 00:15:31,920
by the exact way it accesses the code

431
00:15:31,920 --> 00:15:33,680
word then this is where this notion of

432
00:15:33,680 --> 00:15:36,079
split state adversaries comes up

433
00:15:36,079 --> 00:15:38,720
so there's a bunch of ways to restrict

434
00:15:38,720 --> 00:15:39,519
the

435
00:15:39,519 --> 00:15:41,120
adversary and

436
00:15:41,120 --> 00:15:43,440
probably the holy grail of this line of

437
00:15:43,440 --> 00:15:45,680
works is to say okay let's just imagine

438
00:15:45,680 --> 00:15:47,839
the strongest attacker we can it's

439
00:15:47,839 --> 00:15:49,759
probably an attacker that runs in some

440
00:15:49,759 --> 00:15:51,759
let's say fixed polynomial time let's

441
00:15:51,759 --> 00:15:53,360
say n to the hundred

442
00:15:53,360 --> 00:15:54,959
and we want to construct an encoding

443
00:15:54,959 --> 00:15:57,839
scheme which is not manageable and and

444
00:15:57,839 --> 00:16:00,160
is which is not valuable for this class

445
00:16:00,160 --> 00:16:02,639
of attackers so we first know the bound

446
00:16:02,639 --> 00:16:04,880
on the running time of the attacker and

447
00:16:04,880 --> 00:16:06,959
then we construct our code

448
00:16:06,959 --> 00:16:08,399
but this is

449
00:16:08,399 --> 00:16:10,720
probably the best we can do and ideally

450
00:16:10,720 --> 00:16:12,720
we want the encoding to run in fixed

451
00:16:12,720 --> 00:16:14,560
polynomial time and only the decoding to

452
00:16:14,560 --> 00:16:16,079
take longer than the adversary and this

453
00:16:16,079 --> 00:16:18,000
is necessary because of what i said in

454
00:16:18,000 --> 00:16:19,440
the previous slide

455
00:16:19,440 --> 00:16:21,199
so this is the holy grail

456
00:16:21,199 --> 00:16:23,040
there has been really tons of work

457
00:16:23,040 --> 00:16:25,279
towards this holy grail and it seems to

458
00:16:25,279 --> 00:16:27,839
be a really difficult problem at least

459
00:16:27,839 --> 00:16:30,160
in some regimes of parameters and i'll

460
00:16:30,160 --> 00:16:32,720
mention just the most relevant work it's

461
00:16:32,720 --> 00:16:35,040
a work from two years ago by volatile

462
00:16:35,040 --> 00:16:37,120
from eurocrypt they had a construction

463
00:16:37,120 --> 00:16:38,800
that essentially almost achieves the

464
00:16:38,800 --> 00:16:40,720
holy grail they had the construction in

465
00:16:40,720 --> 00:16:42,800
the plain module so there's no setup

466
00:16:42,800 --> 00:16:45,600
assumptions no random oracle no crs no

467
00:16:45,600 --> 00:16:47,120
nothing

468
00:16:47,120 --> 00:16:49,040
but it relied on a somewhat strong

469
00:16:49,040 --> 00:16:51,600
assumption called p certificate it's

470
00:16:51,600 --> 00:16:53,600
essentially one message argument system

471
00:16:53,600 --> 00:16:55,120
for p which is

472
00:16:55,120 --> 00:16:57,040
uh succinct in the

473
00:16:57,040 --> 00:16:59,040
strongest sense you can imagine

474
00:16:59,040 --> 00:17:01,040
and in this

475
00:17:01,040 --> 00:17:02,320
the size of the

476
00:17:02,320 --> 00:17:04,959
of the of the proof is independent of

477
00:17:04,959 --> 00:17:06,480
the statement of the witness of the

478
00:17:06,480 --> 00:17:08,640
computation time it's just the shortest

479
00:17:08,640 --> 00:17:10,880
you can imagine it's essentially

480
00:17:10,880 --> 00:17:13,119
instantiatable by michael's cs proof

481
00:17:13,119 --> 00:17:14,959
system in the random oracle model but

482
00:17:14,959 --> 00:17:17,119
it's an assumption that is

483
00:17:17,119 --> 00:17:19,599
tuned without the random oracle

484
00:17:19,599 --> 00:17:21,599
so it's a rather strong assumption

485
00:17:21,599 --> 00:17:23,520
they are obtained known availability

486
00:17:23,520 --> 00:17:25,359
only for uniform adversaries so the

487
00:17:25,359 --> 00:17:27,039
attacker that sits on the channel had to

488
00:17:27,039 --> 00:17:29,360
be a uniform machine which is not what

489
00:17:29,360 --> 00:17:31,679
we typically want to to guarantee in

490
00:17:31,679 --> 00:17:33,600
cryptographic constructions

491
00:17:33,600 --> 00:17:35,919
they also only achieved vulnerability

492
00:17:35,919 --> 00:17:38,160
for inverse polynomial distinguishing

493
00:17:38,160 --> 00:17:40,480
advantage so they didn't get negligible

494
00:17:40,480 --> 00:17:42,799
security but on the inverse polynomial

495
00:17:42,799 --> 00:17:44,799
and both of their encoding and the

496
00:17:44,799 --> 00:17:47,120
decoding run longer than the attacker

497
00:17:47,120 --> 00:17:49,520
this is the most relevant previous work

498
00:17:49,520 --> 00:17:52,400
and what we achieve is a construction

499
00:17:52,400 --> 00:17:54,240
that essentially relies on three

500
00:17:54,240 --> 00:17:56,559
assumptions a time lock puzzle and one

501
00:17:56,559 --> 00:17:58,320
message non-valuable commitment scheme

502
00:17:58,320 --> 00:17:59,840
and the one message super polynomial

503
00:17:59,840 --> 00:18:01,840
simulation zero knowledge proof

504
00:18:01,840 --> 00:18:03,919
and this is the definition of time of

505
00:18:03,919 --> 00:18:05,679
puzzle for whoever doesn't know it it's

506
00:18:05,679 --> 00:18:07,760
the way to generate puzzles

507
00:18:07,760 --> 00:18:11,200
uh quickly generate puzzles without a to

508
00:18:11,200 --> 00:18:12,880
quickly generate puzzles and make sure

509
00:18:12,880 --> 00:18:15,919
that nobody can solve them

510
00:18:15,919 --> 00:18:17,840
in some bounded amount of time even if

511
00:18:17,840 --> 00:18:20,720
they use a lot of processing power

512
00:18:20,720 --> 00:18:22,799
and we use these assumptions uh to

513
00:18:22,799 --> 00:18:23,919
construct

514
00:18:23,919 --> 00:18:25,840
a code a non-variable code where the

515
00:18:25,840 --> 00:18:27,919
encoding is really fast it's independent

516
00:18:27,919 --> 00:18:29,679
of the time bound to the attacker the

517
00:18:29,679 --> 00:18:31,600
coding is

518
00:18:31,600 --> 00:18:33,280
depending on the time

519
00:18:33,280 --> 00:18:34,720
like what

520
00:18:34,720 --> 00:18:36,720
which is necessary and it's not manabe

521
00:18:36,720 --> 00:18:39,600
for all attackers of some predefined

522
00:18:39,600 --> 00:18:43,520
size and we uh solve all of the i i

523
00:18:43,520 --> 00:18:44,960
guess the disadvantage of the previous

524
00:18:44,960 --> 00:18:47,600
work we get non-meaningful security

525
00:18:47,600 --> 00:18:50,000
we get negligible advantage the encoding

526
00:18:50,000 --> 00:18:52,080
is fast and we even get the stronger

527
00:18:52,080 --> 00:18:55,120
notion of normal ability

528
00:18:55,120 --> 00:18:57,520
in by that we capture attackers that

529
00:18:57,520 --> 00:19:00,640
have unbounded polynomial size

530
00:19:00,640 --> 00:19:02,640
so it doesn't have to be arbitrarily it

531
00:19:02,640 --> 00:19:04,799
doesn't have to be a prior rebounded as

532
00:19:04,799 --> 00:19:07,200
long as the depth of the attacker or the

533
00:19:07,200 --> 00:19:09,760
parallel runtime of the attacker is

534
00:19:09,760 --> 00:19:12,240
so we even capture a larger class

535
00:19:12,240 --> 00:19:13,919
this is the meta theorem

536
00:19:13,919 --> 00:19:14,799
and

537
00:19:14,799 --> 00:19:16,960
we cannot use any instantiation of these

538
00:19:16,960 --> 00:19:18,480
assumptions

539
00:19:18,480 --> 00:19:21,440
so we have a specific instantiation

540
00:19:21,440 --> 00:19:23,919
we instantiate the time log puzzles with

541
00:19:23,919 --> 00:19:26,240
the repeated scoring assumption

542
00:19:26,240 --> 00:19:28,240
and one message non-variable commitments

543
00:19:28,240 --> 00:19:30,880
with a couple of additional assumptions

544
00:19:30,880 --> 00:19:32,480
and the one message zero knowledge group

545
00:19:32,480 --> 00:19:34,240
system with the same subset of

546
00:19:34,240 --> 00:19:35,520
assumptions

547
00:19:35,520 --> 00:19:37,120
and so we get a construction based on

548
00:19:37,120 --> 00:19:39,440
three assumptions essentially

549
00:19:39,440 --> 00:19:40,960
and this is the instantiation and the

550
00:19:40,960 --> 00:19:42,320
construction is also very simple to

551
00:19:42,320 --> 00:19:44,639
state

552
00:19:45,200 --> 00:19:46,960
we only have three components in the

553
00:19:46,960 --> 00:19:49,200
construction so an encoding only

554
00:19:49,200 --> 00:19:51,840
consists of a time lock puzzle and

555
00:19:51,840 --> 00:19:53,600
non-multiple commitment

556
00:19:53,600 --> 00:19:55,440
and the proof that these two primitives

557
00:19:55,440 --> 00:19:56,880
are that these two objects are

558
00:19:56,880 --> 00:19:59,039
consistent in the sense that they have

559
00:19:59,039 --> 00:20:00,960
that same underlying message

560
00:20:00,960 --> 00:20:02,400
this is the encoding and the coding

561
00:20:02,400 --> 00:20:05,280
works by verifying the proof

562
00:20:05,280 --> 00:20:07,840
and then solving the puzzle

563
00:20:07,840 --> 00:20:10,159
so it's very simple to state

564
00:20:10,159 --> 00:20:11,280
and

565
00:20:11,280 --> 00:20:13,440
the the challenge is in the proof

566
00:20:13,440 --> 00:20:15,840
the proof is very non-trivial

567
00:20:15,840 --> 00:20:16,720
you could

568
00:20:16,720 --> 00:20:18,080
imagine that because of this this

569
00:20:18,080 --> 00:20:19,520
construction is similar to the newer

570
00:20:19,520 --> 00:20:21,760
young dub encryption paradigm

571
00:20:21,760 --> 00:20:23,760
and then the proof will be will follow a

572
00:20:23,760 --> 00:20:25,600
similar structure where we're going to

573
00:20:25,600 --> 00:20:27,760
replace the real decryption or decoding

574
00:20:27,760 --> 00:20:30,480
in our case with a simulated one

575
00:20:30,480 --> 00:20:32,240
but it doesn't really works in a

576
00:20:32,240 --> 00:20:34,320
straightforward way here because we have

577
00:20:34,320 --> 00:20:36,240
two primitives one which is a super

578
00:20:36,240 --> 00:20:38,159
polynomial probability the denominator

579
00:20:38,159 --> 00:20:39,679
commitment and one is the time log

580
00:20:39,679 --> 00:20:41,039
puzzle which is a polynomial time

581
00:20:41,039 --> 00:20:42,320
primitive

582
00:20:42,320 --> 00:20:44,640
so the construction sorry can you

583
00:20:44,640 --> 00:20:46,640
wrap up

584
00:20:46,640 --> 00:20:48,880
sorry so the idea is to use multiple

585
00:20:48,880 --> 00:20:50,799
access of hardness size and

586
00:20:50,799 --> 00:20:52,559
non-uniformity and to set up the

587
00:20:52,559 --> 00:20:55,120
primitives the hybrids in a careful way

588
00:20:55,120 --> 00:20:57,120
so the this is the conclusion i'm

589
00:20:57,120 --> 00:20:59,200
wrapping up we can construct a

590
00:20:59,200 --> 00:21:00,880
non-multiple code

591
00:21:00,880 --> 00:21:02,799
for bounded polynomial depth attackers

592
00:21:02,799 --> 00:21:04,080
the construction can be viewed as a

593
00:21:04,080 --> 00:21:06,000
non-malleable time lock puzzle and we

594
00:21:06,000 --> 00:21:08,000
have a follow-up work where we perform a

595
00:21:08,000 --> 00:21:09,600
third study of this primitive and

596
00:21:09,600 --> 00:21:11,280
there's a couple of interesting open

597
00:21:11,280 --> 00:21:13,360
problems to improve assumptions

598
00:21:13,360 --> 00:21:16,240
and the concrete efficiency thank you

599
00:21:16,240 --> 00:21:18,320
thank you so much for your talk sorry

600
00:21:18,320 --> 00:21:19,919
for interrupting

601
00:21:19,919 --> 00:21:24,080
and uh yeah so uh yeah again please wait

602
00:21:24,080 --> 00:21:25,919
around for the questions and the next

603
00:21:25,919 --> 00:21:28,080
talk will be by dakshita and can you

604
00:21:28,080 --> 00:21:31,399
share your screen

605
00:21:39,280 --> 00:21:42,400
so the next talk will be on improved

606
00:21:42,400 --> 00:21:44,240
we're switching to extractors the next

607
00:21:44,240 --> 00:21:46,080
talk will be on improved computational

608
00:21:46,080 --> 00:21:48,320
extractors and their applications and

609
00:21:48,320 --> 00:21:51,039
this is a joint work by like shitak vana

610
00:21:51,039 --> 00:21:51,919
and dr

611
00:21:51,919 --> 00:21:53,760
srinivasan and takeshita will give the

612
00:21:53,760 --> 00:21:55,120
talk

613
00:21:55,120 --> 00:21:58,240
so um hi everyone thanks lisa for

614
00:21:58,240 --> 00:22:00,960
introducing the title of the talk

615
00:22:00,960 --> 00:22:04,240
um this is a joint work with akshay

616
00:22:04,240 --> 00:22:06,240
who's also here in the audience

617
00:22:06,240 --> 00:22:07,200
um

618
00:22:07,200 --> 00:22:09,039
so this this is going this talk is going

619
00:22:09,039 --> 00:22:12,400
to focus on new construct new

620
00:22:12,400 --> 00:22:15,039
types of extractors

621
00:22:15,039 --> 00:22:17,200
the first thing the first primitive that

622
00:22:17,200 --> 00:22:19,600
we look at is a two-source extractor

623
00:22:19,600 --> 00:22:22,000
which converts two independent weak

624
00:22:22,000 --> 00:22:25,360
sources to a nearly uniform

625
00:22:25,360 --> 00:22:27,600
source of randomness

626
00:22:27,600 --> 00:22:32,480
um both sources uh so extractors uh in

627
00:22:32,480 --> 00:22:34,159
settings where both sources have at

628
00:22:34,159 --> 00:22:37,600
least poly logarithmic uh min entropy

629
00:22:37,600 --> 00:22:40,960
were open for a while and were very

630
00:22:40,960 --> 00:22:42,559
recently constructed in breakthrough

631
00:22:42,559 --> 00:22:43,679
works by

632
00:22:43,679 --> 00:22:45,679
chatopadhyay at all and then there's

633
00:22:45,679 --> 00:22:47,919
been a sequence of information theoretic

634
00:22:47,919 --> 00:22:51,760
constructions of these extractors

635
00:22:51,760 --> 00:22:52,799
however

636
00:22:52,799 --> 00:22:54,799
in all of these information theoretic

637
00:22:54,799 --> 00:22:57,360
constructions the error has not been

638
00:22:57,360 --> 00:22:59,760
negligible in

639
00:22:59,760 --> 00:23:02,960
in n which is the length of the source

640
00:23:02,960 --> 00:23:04,240
and

641
00:23:04,240 --> 00:23:05,679
in particular this is because the

642
00:23:05,679 --> 00:23:08,159
running time of the extractor grows

643
00:23:08,159 --> 00:23:10,000
inverse polynomially

644
00:23:10,000 --> 00:23:12,640
with the error and this in this in

645
00:23:12,640 --> 00:23:14,240
general appears to be

646
00:23:14,240 --> 00:23:15,919
hard to remove in the information

647
00:23:15,919 --> 00:23:19,120
theoretic setting and so um one question

648
00:23:19,120 --> 00:23:21,039
that has been looked at in a few recent

649
00:23:21,039 --> 00:23:23,039
works is can we rely on cryptographic

650
00:23:23,039 --> 00:23:25,679
hardness assumptions so as to achieve

651
00:23:25,679 --> 00:23:27,600
two source extractors with better

652
00:23:27,600 --> 00:23:29,760
parameters lower error than than our

653
00:23:29,760 --> 00:23:33,520
known information theoretically

654
00:23:33,520 --> 00:23:34,799
and so

655
00:23:34,799 --> 00:23:36,240
more specifically the question is

656
00:23:36,240 --> 00:23:37,679
whether one can achieve two source

657
00:23:37,679 --> 00:23:40,159
extractors for poly logarithmic main

658
00:23:40,159 --> 00:23:42,320
entropy and negligible error

659
00:23:42,320 --> 00:23:44,159
and under cryptographic hardness

660
00:23:44,159 --> 00:23:45,440
assumptions

661
00:23:45,440 --> 00:23:47,600
um these types of questions were first

662
00:23:47,600 --> 00:23:50,400
studied in a work of coli at all who

663
00:23:50,400 --> 00:23:53,279
obtained epsilon n entropy negligible

664
00:23:53,279 --> 00:23:55,520
and error assuming the existence of

665
00:23:55,520 --> 00:23:57,520
optimally exponentially hard one-way

666
00:23:57,520 --> 00:24:00,000
permutations

667
00:24:00,000 --> 00:24:01,039
and

668
00:24:01,039 --> 00:24:03,679
subsequently in a recent work with yael

669
00:24:03,679 --> 00:24:05,520
kalai and ankit garg

670
00:24:05,520 --> 00:24:08,159
we obtained the construction for

671
00:24:08,159 --> 00:24:10,480
polylog arithmetic entropy in one of the

672
00:24:10,480 --> 00:24:12,880
sources into the epsilon when entropy in

673
00:24:12,880 --> 00:24:14,960
the other one and where the sources were

674
00:24:14,960 --> 00:24:16,640
themselves unbalanced

675
00:24:16,640 --> 00:24:19,919
with error that was also negligible

676
00:24:19,919 --> 00:24:22,480
and here uh one one difference from all

677
00:24:22,480 --> 00:24:24,080
the settings that i've been talking

678
00:24:24,080 --> 00:24:26,880
about so far is that we considered the

679
00:24:26,880 --> 00:24:31,279
crs model um the crs model um

680
00:24:31,279 --> 00:24:33,440
allows for a common random string which

681
00:24:33,440 --> 00:24:35,520
is a common source of randomness to be

682
00:24:35,520 --> 00:24:37,760
fixed once and for all and allows for

683
00:24:37,760 --> 00:24:40,320
sources to depend on the crs

684
00:24:40,320 --> 00:24:43,200
now this is still interesting because

685
00:24:43,200 --> 00:24:44,960
unlike the case the simpler case of

686
00:24:44,960 --> 00:24:46,720
seeded extractors for those that are

687
00:24:46,720 --> 00:24:48,640
familiar um

688
00:24:48,640 --> 00:24:50,799
two source extractors in the crs model

689
00:24:50,799 --> 00:24:54,080
allow both sources to depend on the crs

690
00:24:54,080 --> 00:24:54,960
and

691
00:24:54,960 --> 00:24:56,960
in particular this reduces the need for

692
00:24:56,960 --> 00:24:58,880
true randomness to the single one-time

693
00:24:58,880 --> 00:25:00,400
requirement of the crs

694
00:25:00,400 --> 00:25:02,240
and then all sources can depend

695
00:25:02,240 --> 00:25:04,320
arbitrarily on on it

696
00:25:04,320 --> 00:25:05,760
i want to emphasize that in the

697
00:25:05,760 --> 00:25:07,600
computational setting the sources are

698
00:25:07,600 --> 00:25:11,039
restricted to being efficiently familiar

699
00:25:11,039 --> 00:25:12,480
unlike the information theoretic

700
00:25:12,480 --> 00:25:14,159
settings

701
00:25:14,159 --> 00:25:16,320
there was also a work of agarwal at all

702
00:25:16,320 --> 00:25:18,240
that obtained epsilon n entropy and

703
00:25:18,240 --> 00:25:21,279
negligible and error in the crs model

704
00:25:21,279 --> 00:25:22,960
assuming quasi-polynomial hardness of

705
00:25:22,960 --> 00:25:25,120
ddh

706
00:25:25,120 --> 00:25:27,440
they built on gkk20 and they also

707
00:25:27,440 --> 00:25:29,679
obtained poly log main entropy assuming

708
00:25:29,679 --> 00:25:31,919
optimally hard collision resistant hash

709
00:25:31,919 --> 00:25:33,760
functions

710
00:25:33,760 --> 00:25:35,679
uh that brings me to what we do in this

711
00:25:35,679 --> 00:25:36,480
work

712
00:25:36,480 --> 00:25:38,720
we also consider the crs model and

713
00:25:38,720 --> 00:25:40,640
perform an improved analysis of the

714
00:25:40,640 --> 00:25:43,520
extractor in the gk work and in

715
00:25:43,520 --> 00:25:45,200
particular we show that the same

716
00:25:45,200 --> 00:25:46,799
extractor actually can also handle

717
00:25:46,799 --> 00:25:48,400
balanced sources

718
00:25:48,400 --> 00:25:50,159
where each source only needs to have

719
00:25:50,159 --> 00:25:52,960
poly logarithmic entropy and allows for

720
00:25:52,960 --> 00:25:54,960
negligible error essentially under the

721
00:25:54,960 --> 00:25:56,880
same assumption which is subexponential

722
00:25:56,880 --> 00:25:59,360
delete

723
00:25:59,360 --> 00:26:01,600
the second part of this work

724
00:26:01,600 --> 00:26:03,600
uses this result to obtain improved

725
00:26:03,600 --> 00:26:06,080
realizations of a few other types of

726
00:26:06,080 --> 00:26:08,559
extractors and in particular we look at

727
00:26:08,559 --> 00:26:11,200
network extractors and extractors for

728
00:26:11,200 --> 00:26:12,880
adversarial sources

729
00:26:12,880 --> 00:26:14,080
these are two different types of

730
00:26:14,080 --> 00:26:16,480
extractors that consider settings where

731
00:26:16,480 --> 00:26:19,039
some of the sources may be adversarial

732
00:26:19,039 --> 00:26:21,520
in some way

733
00:26:23,360 --> 00:26:26,720
so let me say a few words about um about

734
00:26:26,720 --> 00:26:28,880
the template for constructing two source

735
00:26:28,880 --> 00:26:30,240
extractors

736
00:26:30,240 --> 00:26:33,440
um the first step follows a template of

737
00:26:33,440 --> 00:26:34,640
um

738
00:26:34,640 --> 00:26:36,640
bsk11 to obtain computational

739
00:26:36,640 --> 00:26:38,400
non-malleable extractors

740
00:26:38,400 --> 00:26:40,240
and then the second step compiles any

741
00:26:40,240 --> 00:26:43,039
such extractor to a two source extractor

742
00:26:43,039 --> 00:26:44,480
this is following a different

743
00:26:44,480 --> 00:26:46,000
information theoretic template of

744
00:26:46,000 --> 00:26:47,679
beneroya at all

745
00:26:47,679 --> 00:26:50,400
and combining these two steps together

746
00:26:50,400 --> 00:26:52,400
uh gives a two-source extractor with

747
00:26:52,400 --> 00:26:54,080
negligible error

748
00:26:54,080 --> 00:26:57,200
the main barrier in the in in in this

749
00:26:57,200 --> 00:26:58,559
construction was that the proof

750
00:26:58,559 --> 00:27:01,120
technique of benaroya at all crucially

751
00:27:01,120 --> 00:27:03,760
had an inefficient reduction

752
00:27:03,760 --> 00:27:06,000
and in the computational setting dealing

753
00:27:06,000 --> 00:27:07,679
with inefficient reductions is hard and

754
00:27:07,679 --> 00:27:10,320
so we had to do things to get around it

755
00:27:10,320 --> 00:27:13,440
and in particular in gkk

756
00:27:13,440 --> 00:27:15,440
we used the leakage lemma to efficiently

757
00:27:15,440 --> 00:27:17,200
simulate some of the inefficient steps

758
00:27:17,200 --> 00:27:18,880
of this reduction

759
00:27:18,880 --> 00:27:21,279
and in this work uh we perform a

760
00:27:21,279 --> 00:27:23,760
monolithic analysis of both steps one

761
00:27:23,760 --> 00:27:26,080
and two together first tripping off all

762
00:27:26,080 --> 00:27:28,240
the computational components to obtain

763
00:27:28,240 --> 00:27:30,640
an information theoretic experiment and

764
00:27:30,640 --> 00:27:33,600
then uh performing

765
00:27:33,600 --> 00:27:35,360
and then basically the inefficient part

766
00:27:35,360 --> 00:27:37,200
is only reduced to an information

767
00:27:37,200 --> 00:27:40,240
theoretic excitement

768
00:27:40,799 --> 00:27:42,480
now let me say just a little bit about

769
00:27:42,480 --> 00:27:44,559
our applications um

770
00:27:44,559 --> 00:27:46,399
the first one is to a network extractor

771
00:27:46,399 --> 00:27:48,720
protocol here there's a bunch of sources

772
00:27:48,720 --> 00:27:50,480
that want to communicate over a public

773
00:27:50,480 --> 00:27:52,480
channel to end up with uniform

774
00:27:52,480 --> 00:27:53,600
randomness

775
00:27:53,600 --> 00:27:55,120
and the challenge is that some of these

776
00:27:55,120 --> 00:27:57,679
sources may be adversarial and may send

777
00:27:57,679 --> 00:27:59,600
messages that depend on the messages

778
00:27:59,600 --> 00:28:01,840
sent by honest sources so a lot like the

779
00:28:01,840 --> 00:28:04,240
settings of npc

780
00:28:04,240 --> 00:28:06,799
where the adversary may be rushing

781
00:28:06,799 --> 00:28:08,960
and we want to guarantee that even given

782
00:28:08,960 --> 00:28:11,919
the transcript the honest sources end up

783
00:28:11,919 --> 00:28:14,320
with computationally uniform randomness

784
00:28:14,320 --> 00:28:17,039
and in general network extractors uh

785
00:28:17,039 --> 00:28:19,360
were first defined uh and considered

786
00:28:19,360 --> 00:28:21,039
implicitly in this work of dodis and

787
00:28:21,039 --> 00:28:23,039
oliveira and were made explicit in a

788
00:28:23,039 --> 00:28:25,120
bunch of other works and so far all

789
00:28:25,120 --> 00:28:26,320
these constructions have been

790
00:28:26,320 --> 00:28:28,240
information theoretic

791
00:28:28,240 --> 00:28:29,600
we study this question in the

792
00:28:29,600 --> 00:28:32,640
computational settings um

793
00:28:32,640 --> 00:28:34,559
and

794
00:28:34,559 --> 00:28:36,399
just just for your reference a bunch of

795
00:28:36,399 --> 00:28:37,919
prior work that i'm not going to spend

796
00:28:37,919 --> 00:28:39,200
too much time on

797
00:28:39,200 --> 00:28:41,120
so in our work we obtain a one-round

798
00:28:41,120 --> 00:28:43,279
network extractor with negligible error

799
00:28:43,279 --> 00:28:45,760
for up to polynomially many participants

800
00:28:45,760 --> 00:28:48,720
tolerating up to all but two corruptions

801
00:28:48,720 --> 00:28:50,480
where each source has poly logarithmic

802
00:28:50,480 --> 00:28:52,080
main entropy and based on sub

803
00:28:52,080 --> 00:28:53,679
exponential ddh

804
00:28:53,679 --> 00:28:56,000
and the i would say the first four

805
00:28:56,000 --> 00:28:58,080
bullets are somewhat optimal the last

806
00:28:58,080 --> 00:28:59,520
one the need for sub-exponential

807
00:28:59,520 --> 00:29:01,200
assumptions is not so there is there may

808
00:29:01,200 --> 00:29:04,000
be some scope for improvement there

809
00:29:04,000 --> 00:29:06,000
the second application that we look at

810
00:29:06,000 --> 00:29:07,440
is the setting of extractors for

811
00:29:07,440 --> 00:29:09,520
adversarial sources but there's again a

812
00:29:09,520 --> 00:29:12,399
bunch of sources some of which may be

813
00:29:12,399 --> 00:29:14,799
honest the others may be adversarial and

814
00:29:14,799 --> 00:29:16,559
are allowed to depend on few of the

815
00:29:16,559 --> 00:29:17,919
honest sources

816
00:29:17,919 --> 00:29:20,080
uh extractors for adversarial sources

817
00:29:20,080 --> 00:29:22,080
were first introduced

818
00:29:22,080 --> 00:29:23,760
were introduced almost simultaneously in

819
00:29:23,760 --> 00:29:27,039
works of chatopathy at

820
00:29:29,360 --> 00:29:32,159
and um sorry can you also wrap up soon

821
00:29:32,159 --> 00:29:34,640
i'm really sorry

822
00:29:34,640 --> 00:29:37,919
last slide i promise uh so

823
00:29:37,919 --> 00:29:38,720
um

824
00:29:38,720 --> 00:29:40,559
and so they were introduced in these

825
00:29:40,559 --> 00:29:41,919
three different works that consider

826
00:29:41,919 --> 00:29:43,919
different flavors of this definition we

827
00:29:43,919 --> 00:29:45,520
work with the flavor uh that was

828
00:29:45,520 --> 00:29:47,840
introduced in chatopathy at all and we

829
00:29:47,840 --> 00:29:49,600
obtain extractors for adversarial

830
00:29:49,600 --> 00:29:52,559
sources um handling two out of a total

831
00:29:52,559 --> 00:29:55,200
of polynomially many two honest sources

832
00:29:55,200 --> 00:29:56,720
out of a total of polynomially many

833
00:29:56,720 --> 00:29:59,279
sources with polylogman entropy and

834
00:29:59,279 --> 00:30:01,360
negligible error and where each

835
00:30:01,360 --> 00:30:03,279
adversarial force is allowed to depend

836
00:30:03,279 --> 00:30:06,320
on at most one of the two honest sources

837
00:30:06,320 --> 00:30:08,960
with that i want to wrap up um i'll just

838
00:30:08,960 --> 00:30:10,880
display these open problems here in case

839
00:30:10,880 --> 00:30:15,200
anyone wants to take a look um thank you

840
00:30:15,200 --> 00:30:17,120
thank you so much thank you so much for

841
00:30:17,120 --> 00:30:19,279
your talk and yeah please

842
00:30:19,279 --> 00:30:20,960
stay around for questions and we're

843
00:30:20,960 --> 00:30:22,880
going to move on to the next talk

844
00:30:22,880 --> 00:30:26,720
sai can you please share your screen

845
00:30:29,279 --> 00:30:30,559
so

846
00:30:30,559 --> 00:30:33,039
the last talk of the session is on

847
00:30:33,039 --> 00:30:34,880
adaptive extractors and their

848
00:30:34,880 --> 00:30:36,720
application to leakage brazilian secret

849
00:30:36,720 --> 00:30:39,679
sharing this is joined for it by nishan

850
00:30:39,679 --> 00:30:43,039
chandran vana

851
00:30:43,279 --> 00:30:46,399
vana ubatu and shruti zakar and sai will

852
00:30:46,399 --> 00:30:49,200
give the talk say

853
00:30:49,200 --> 00:30:51,679
thanks lisa jesus the introduction

854
00:30:51,679 --> 00:30:52,720
um

855
00:30:52,720 --> 00:30:55,120
yeah so in this talk we'll first begin

856
00:30:55,120 --> 00:30:57,120
with talking about adaptive extractors

857
00:30:57,120 --> 00:30:58,640
and then we'll move on to leakage

858
00:30:58,640 --> 00:31:00,640
frequency sharing

859
00:31:00,640 --> 00:31:04,320
so to begin with randomness extractors

860
00:31:04,320 --> 00:31:06,640
take in an entropic source and a uniform

861
00:31:06,640 --> 00:31:08,640
seed and ensure that the extractor

862
00:31:08,640 --> 00:31:10,880
output is indistinguishable from uniform

863
00:31:10,880 --> 00:31:12,880
even given the seed and

864
00:31:12,880 --> 00:31:14,799
any arbitrary short leakage that's

865
00:31:14,799 --> 00:31:17,360
purely dependent on the source

866
00:31:17,360 --> 00:31:19,279
the question that we consider is that

867
00:31:19,279 --> 00:31:21,039
whether the leakage can depend on the

868
00:31:21,039 --> 00:31:23,120
speed and the challenge as well whereby

869
00:31:23,120 --> 00:31:24,399
challenge we

870
00:31:24,399 --> 00:31:26,000
mean the sample that needs to be

871
00:31:26,000 --> 00:31:27,440
distinguished

872
00:31:27,440 --> 00:31:29,279
a general answer to this question would

873
00:31:29,279 --> 00:31:31,200
be no because there could be leakage

874
00:31:31,200 --> 00:31:32,640
functions that check whether the

875
00:31:32,640 --> 00:31:34,559
challenge equals the extractor output or

876
00:31:34,559 --> 00:31:36,159
not

877
00:31:36,159 --> 00:31:38,960
so is this the end of the story

878
00:31:38,960 --> 00:31:41,279
well through this work we actually show

879
00:31:41,279 --> 00:31:42,960
that this is really not the end of the

880
00:31:42,960 --> 00:31:46,720
story by introducing adaptive extractors

881
00:31:46,720 --> 00:31:48,480
we say an extractor is adaptive with

882
00:31:48,480 --> 00:31:50,640
respect to a leakage function family is

883
00:31:50,640 --> 00:31:52,720
for every function in the family the

884
00:31:52,720 --> 00:31:54,720
extractor output looks indistinguishable

885
00:31:54,720 --> 00:31:58,240
from uniform even given the seed and

886
00:31:58,240 --> 00:32:00,480
the adaptive leakage dependent on the

887
00:32:00,480 --> 00:32:03,840
source speed and the challenge

888
00:32:04,000 --> 00:32:06,640
so here we would like to just note that

889
00:32:06,640 --> 00:32:07,679
now

890
00:32:07,679 --> 00:32:09,440
we consider the notion of adaptive

891
00:32:09,440 --> 00:32:11,279
extractors in school generality in this

892
00:32:11,279 --> 00:32:12,880
paper uh

893
00:32:12,880 --> 00:32:15,440
while some implicit uh well some

894
00:32:15,440 --> 00:32:16,960
specialized variants were also

895
00:32:16,960 --> 00:32:18,480
implicitly studied in the works of

896
00:32:18,480 --> 00:32:21,360
siemens and agrawal at all as well

897
00:32:21,360 --> 00:32:23,919
so moving on

898
00:32:23,919 --> 00:32:26,080
in our paper we specifically consider

899
00:32:26,080 --> 00:32:27,919
the following leakage family where we

900
00:32:27,919 --> 00:32:30,799
allow the leakage to arbitrarily depend

901
00:32:30,799 --> 00:32:32,480
on the challenge and we refer to this

902
00:32:32,480 --> 00:32:34,799
family as the output adapter family we

903
00:32:34,799 --> 00:32:37,120
show that every extractor is indeed an

904
00:32:37,120 --> 00:32:38,960
output adaptive extractor with slight

905
00:32:38,960 --> 00:32:41,760
loss in parameters and so a non-trivial

906
00:32:41,760 --> 00:32:43,360
application of this output adaptive

907
00:32:43,360 --> 00:32:45,200
extractors in building leakage resistant

908
00:32:45,200 --> 00:32:47,840
secretion space finally concluding on

909
00:32:47,840 --> 00:32:50,000
adaptive extractors yeah the area is

910
00:32:50,000 --> 00:32:52,480
wide open and it will be really

911
00:32:52,480 --> 00:32:54,159
interesting to study other leakage

912
00:32:54,159 --> 00:32:55,200
families

913
00:32:55,200 --> 00:32:57,600
moving on to secret sharing schemes an n

914
00:32:57,600 --> 00:33:00,399
party t threshold secret sharing scheme

915
00:33:00,399 --> 00:33:03,039
let's uh to share a message m into n

916
00:33:03,039 --> 00:33:05,360
shares such that any t plus one of the

917
00:33:05,360 --> 00:33:07,440
shares can taken

918
00:33:07,440 --> 00:33:09,919
are useful in reconstructing the message

919
00:33:09,919 --> 00:33:12,240
and any two of them have no information

920
00:33:12,240 --> 00:33:14,720
about the secret

921
00:33:14,720 --> 00:33:16,799
further a secretion scheme is said to

922
00:33:16,799 --> 00:33:18,960
satisfy leakage resilience against a

923
00:33:18,960 --> 00:33:21,279
leakage family if for every leakage

924
00:33:21,279 --> 00:33:23,120
function in the family and any two

925
00:33:23,120 --> 00:33:25,039
secret sermon temple and the leakage on

926
00:33:25,039 --> 00:33:27,919
shares of message m is in this refuge is

927
00:33:27,919 --> 00:33:29,760
indistinguishable from leakage on shares

928
00:33:29,760 --> 00:33:31,120
of message

929
00:33:31,120 --> 00:33:33,440
m prime

930
00:33:33,440 --> 00:33:35,279
now moving ahead some parameters of

931
00:33:35,279 --> 00:33:38,799
interest for leakage lrs are fixed which

932
00:33:38,799 --> 00:33:40,640
is the ratio of secret size to the share

933
00:33:40,640 --> 00:33:43,440
size and the most important thing is the

934
00:33:43,440 --> 00:33:45,840
leakage model

935
00:33:45,840 --> 00:33:47,360
most of the leakage models that were

936
00:33:47,360 --> 00:33:48,960
studied in the literature can be

937
00:33:48,960 --> 00:33:51,039
categorized based on whether they

938
00:33:51,039 --> 00:33:53,519
support joint leakage on the share or

939
00:33:53,519 --> 00:33:55,440
whether whether they support adaptive

940
00:33:55,440 --> 00:33:59,039
leakage or on the leakage queries

941
00:33:59,039 --> 00:34:02,480
so with this we'll move we'll just move

942
00:34:02,480 --> 00:34:04,320
on to some high level overview of

943
00:34:04,320 --> 00:34:06,720
private

944
00:34:06,720 --> 00:34:07,440
so

945
00:34:07,440 --> 00:34:10,079
lrss has seen a very interesting light

946
00:34:10,079 --> 00:34:12,000
of works but for the purpose of this

947
00:34:12,000 --> 00:34:13,760
talk we will rush the classes to

948
00:34:13,760 --> 00:34:15,520
relevant privates in the information

949
00:34:15,520 --> 00:34:16,960
theoretic setting

950
00:34:16,960 --> 00:34:19,599
from the perspective of it the best work

951
00:34:19,599 --> 00:34:20,399
till now

952
00:34:20,399 --> 00:34:22,800
is due to srinivasan and washington

953
00:34:22,800 --> 00:34:24,239
achieving an impressive rate of

954
00:34:24,239 --> 00:34:26,960
one-third but the model that the support

955
00:34:26,960 --> 00:34:28,719
is very basic which is the independent

956
00:34:28,719 --> 00:34:31,040
and non-adaptive leakage model from the

957
00:34:31,040 --> 00:34:33,199
perspective of leakage models the words

958
00:34:33,199 --> 00:34:36,239
due to chatopathy at all and

959
00:34:36,239 --> 00:34:37,679
computer

960
00:34:37,679 --> 00:34:40,159
so here it's important to note that

961
00:34:40,159 --> 00:34:43,359
even for any restricted setting of n t

962
00:34:43,359 --> 00:34:45,440
there have been no adaptive or joint

963
00:34:45,440 --> 00:34:47,359
analysis which has

964
00:34:47,359 --> 00:34:48,320
it

965
00:34:48,320 --> 00:34:51,119
so in this work in our work we precisely

966
00:34:51,119 --> 00:34:53,440
bridge this gap by

967
00:34:53,440 --> 00:34:55,440
giving a compiler that compiles any

968
00:34:55,440 --> 00:34:56,879
secret sharing scheme into a

969
00:34:56,879 --> 00:34:59,040
corresponding lrs in the joint and

970
00:34:59,040 --> 00:35:02,400
adaptive leakage model that just uses an

971
00:35:02,400 --> 00:35:04,480
extractor as a building block

972
00:35:04,480 --> 00:35:07,040
further we show that when n and d or if

973
00:35:07,040 --> 00:35:08,880
they mustn't protect order and when each

974
00:35:08,880 --> 00:35:10,960
joint leakage query is only on constant

975
00:35:10,960 --> 00:35:13,359
number of shares because there exists a

976
00:35:13,359 --> 00:35:14,800
translation of the analysis with

977
00:35:14,800 --> 00:35:17,280
constructed so further details on the

978
00:35:17,280 --> 00:35:20,480
construction model and applications uh i

979
00:35:20,480 --> 00:35:22,160
asked the audience to refer to the

980
00:35:22,160 --> 00:35:24,560
people thank you

981
00:35:24,560 --> 00:35:26,640
thank you thank you so much for your

982
00:35:26,640 --> 00:35:29,760
talks i and thanks again uh all the

983
00:35:29,760 --> 00:35:31,520
speakers of the session for all the

984
00:35:31,520 --> 00:35:35,200
great talks and we're moving on to q and

985
00:35:35,200 --> 00:35:36,400
a now

986
00:35:36,400 --> 00:35:40,960
so i see we have some questions

987
00:35:41,200 --> 00:35:42,880
on

988
00:35:42,880 --> 00:35:44,960
we have some questions on

989
00:35:44,960 --> 00:35:48,480
sulip so we have a question for uh for

990
00:35:48,480 --> 00:35:51,200
peter and what bandwidth setting did you

991
00:35:51,200 --> 00:35:53,359
use for the benchmarks at the end of

992
00:35:53,359 --> 00:35:56,680
your talk

993
00:36:03,040 --> 00:36:04,000
uh

994
00:36:04,000 --> 00:36:07,280
i think we were in the land setting uh

995
00:36:07,280 --> 00:36:10,640
but it communicates so little it's like

996
00:36:10,640 --> 00:36:13,599
megabytes for millions of ots so it's

997
00:36:13,599 --> 00:36:14,480
like

998
00:36:14,480 --> 00:36:18,240
it it's already the least communication

999
00:36:18,240 --> 00:36:20,960
heavy protocol and uh so we didn't

1000
00:36:20,960 --> 00:36:23,440
bother with doing latency and stuff but

1001
00:36:23,440 --> 00:36:26,720
basically just round trip over

1002
00:36:29,119 --> 00:36:32,640
okay thanks uh peter so next question is

1003
00:36:32,640 --> 00:36:34,800
for ilan uh

1004
00:36:34,800 --> 00:36:36,480
i'm not sure if i missed this but what

1005
00:36:36,480 --> 00:36:38,400
is the security property that you need

1006
00:36:38,400 --> 00:36:40,480
from an unknowable commitment

1007
00:36:40,480 --> 00:36:42,720
like not knowing with respect to

1008
00:36:42,720 --> 00:36:45,839
commitment or opening

1009
00:36:46,160 --> 00:36:48,240
um so i answered in the bottom we're

1010
00:36:48,240 --> 00:36:49,920
using the previous works that

1011
00:36:49,920 --> 00:36:51,680
constructed non-valuable commitments and

1012
00:36:51,680 --> 00:36:53,599
both of them achieve vulnerability with

1013
00:36:53,599 --> 00:36:55,599
respect to commitment

1014
00:36:55,599 --> 00:36:57,280
that's what we use

1015
00:36:57,280 --> 00:36:58,960
okay thank you

1016
00:36:58,960 --> 00:37:01,040
um

1017
00:37:01,040 --> 00:37:03,599
ah yeah now i see it thanks

1018
00:37:03,599 --> 00:37:04,640
um

1019
00:37:04,640 --> 00:37:07,599
okay so we have a second question for

1020
00:37:07,599 --> 00:37:08,560
peter

1021
00:37:08,560 --> 00:37:10,160
what do can you say about the security

1022
00:37:10,160 --> 00:37:11,920
of silver against the text i don't think

1023
00:37:11,920 --> 00:37:15,200
it's the linear model um am i correct in

1024
00:37:15,200 --> 00:37:16,720
thinking that red solomon is insecure

1025
00:37:16,720 --> 00:37:18,640
for lpn because you can use an efficient

1026
00:37:18,640 --> 00:37:21,599
syndrome decoder to find the noise

1027
00:37:21,599 --> 00:37:23,440
rs has a pretty check with high minimum

1028
00:37:23,440 --> 00:37:24,640
distance so the attack doesn't fit the

1029
00:37:24,640 --> 00:37:26,079
linear model which makes me think that

1030
00:37:26,079 --> 00:37:27,599
codes with too much structure may have

1031
00:37:27,599 --> 00:37:29,359
attacks that don't fit in the linear

1032
00:37:29,359 --> 00:37:30,720
model

1033
00:37:30,720 --> 00:37:32,000
yeah uh

1034
00:37:32,000 --> 00:37:34,800
i mean we we did our best we could to

1035
00:37:34,800 --> 00:37:37,680
try to address such things but it is an

1036
00:37:37,680 --> 00:37:39,520
open question um

1037
00:37:39,520 --> 00:37:41,200
in the work in the paper itself we've

1038
00:37:41,200 --> 00:37:43,359
got to frame it as an open question uh

1039
00:37:43,359 --> 00:37:45,440
we invite people to come look at code

1040
00:37:45,440 --> 00:37:47,520
and try to do it uh

1041
00:37:47,520 --> 00:37:49,839
i guess the idea is like if you can

1042
00:37:49,839 --> 00:37:51,359
break it you're gonna have to somehow

1043
00:37:51,359 --> 00:37:53,280
definitely use the structure of the code

1044
00:37:53,280 --> 00:37:56,079
and in like a novel way and uh yeah we

1045
00:37:56,079 --> 00:37:58,320
weren't able to break it but uh

1046
00:37:58,320 --> 00:37:59,520
doesn't mean

1047
00:37:59,520 --> 00:38:02,480
no one could so it's open question and i

1048
00:38:02,480 --> 00:38:05,359
invite you to try

1049
00:38:05,359 --> 00:38:07,760
thanks peter uh do we have any more i

1050
00:38:07,760 --> 00:38:10,000
don't see any more questions on sulu and

1051
00:38:10,000 --> 00:38:11,440
i have any more questions in the

1052
00:38:11,440 --> 00:38:13,119
audience here anyone want to go ahead

1053
00:38:13,119 --> 00:38:15,520
and ask a question

1054
00:38:15,520 --> 00:38:18,800
uh yes patrick please go

1055
00:38:18,800 --> 00:38:20,480
thank you very much so i think this

1056
00:38:20,480 --> 00:38:23,680
question is for the before last talk i'm

1057
00:38:23,680 --> 00:38:25,440
not entirely sure sorry how to pronounce

1058
00:38:25,440 --> 00:38:27,119
the name it's on the

1059
00:38:27,119 --> 00:38:30,720
it's on the extractors the two x factors

1060
00:38:30,720 --> 00:38:33,040
so my question would be like how

1061
00:38:33,040 --> 00:38:35,119
realistic is this model in the trs

1062
00:38:35,119 --> 00:38:37,040
because essentially when you have

1063
00:38:37,040 --> 00:38:38,320
extractors you assume that you have a

1064
00:38:38,320 --> 00:38:40,560
very small seed and then you have some

1065
00:38:40,560 --> 00:38:42,400
public value that has randomness and

1066
00:38:42,400 --> 00:38:44,000
then eventually you want to have

1067
00:38:44,000 --> 00:38:46,560
something close to uniform but in this

1068
00:38:46,560 --> 00:38:48,320
year's model so while you need an

1069
00:38:48,320 --> 00:38:49,760
extremely long string i understand that

1070
00:38:49,760 --> 00:38:52,480
you need it only once but uh somehow how

1071
00:38:52,480 --> 00:38:54,640
realistic would that be and my second

1072
00:38:54,640 --> 00:38:56,560
question was are you aware of the work

1073
00:38:56,560 --> 00:38:59,440
by it candidates in 2019 and europe i

1074
00:38:59,440 --> 00:39:01,200
think where he was basically

1075
00:39:01,200 --> 00:39:03,440
investigating uh two random number

1076
00:39:03,440 --> 00:39:05,839
generators without seeds

1077
00:39:05,839 --> 00:39:08,320
so i was wondering if you thought about

1078
00:39:08,320 --> 00:39:11,280
something in that direction

1079
00:39:11,520 --> 00:39:13,359
um so

1080
00:39:13,359 --> 00:39:15,839
so to answer so let me answer your first

1081
00:39:15,839 --> 00:39:18,240
question first how realistic is this

1082
00:39:18,240 --> 00:39:21,040
setting um i think it's an interesting

1083
00:39:21,040 --> 00:39:23,839
setting because uh you like i was saying

1084
00:39:23,839 --> 00:39:25,680
in the talk you can generate this crf

1085
00:39:25,680 --> 00:39:26,960
once and for all so you need this

1086
00:39:26,960 --> 00:39:29,520
one-time good randomness and then you

1087
00:39:29,520 --> 00:39:31,520
can have sources that are allowed to

1088
00:39:31,520 --> 00:39:34,079
depend on the crs so in that sense it's

1089
00:39:34,079 --> 00:39:35,839
different from the seated extractor

1090
00:39:35,839 --> 00:39:38,880
setting um and there could be situations

1091
00:39:38,880 --> 00:39:41,359
where it is hard to get a seed that is

1092
00:39:41,359 --> 00:39:44,000
completely independent of your sources

1093
00:39:44,000 --> 00:39:46,720
but you can have a crf and and where the

1094
00:39:46,720 --> 00:39:49,839
sources actually do depend on it so um

1095
00:39:49,839 --> 00:39:53,240
so these are different settings i

1096
00:39:53,240 --> 00:39:56,240
realistic-ness i

1097
00:39:56,240 --> 00:39:58,400
i don't know i had to take to say that

1098
00:39:58,400 --> 00:40:01,359
any of these are very realistic so um

1099
00:40:01,359 --> 00:40:05,599
um and to your second question um

1100
00:40:05,599 --> 00:40:09,040
uh yes i'm aware of yavghani's work but

1101
00:40:09,040 --> 00:40:11,839
i

1102
00:40:11,920 --> 00:40:14,400
i am not uh i'll have to look at it in

1103
00:40:14,400 --> 00:40:16,000
more detail to actually draw some sort

1104
00:40:16,000 --> 00:40:18,880
of comparison with this um

1105
00:40:18,880 --> 00:40:20,720
i'm happy to look at it and get back to

1106
00:40:20,720 --> 00:40:22,160
you offline

1107
00:40:22,160 --> 00:40:25,839
okay thank you very much

1108
00:40:26,800 --> 00:40:30,079
um okay so any more questions from the

1109
00:40:30,079 --> 00:40:32,640
audience

1110
00:40:34,160 --> 00:40:37,040
so we have another question in the chat

1111
00:40:37,040 --> 00:40:40,000
uh to peter i suppose the computational

1112
00:40:40,000 --> 00:40:42,160
cost is also lesser than prior can you

1113
00:40:42,160 --> 00:40:43,920
say something more and how much less is

1114
00:40:43,920 --> 00:40:45,520
the computational cost compared with

1115
00:40:45,520 --> 00:40:48,160
fireworks things

1116
00:40:48,160 --> 00:40:49,760
yeah um

1117
00:40:49,760 --> 00:40:51,839
yeah basically in the prior works that

1118
00:40:51,839 --> 00:40:54,640
follow this up dual lpn structure almost

1119
00:40:54,640 --> 00:40:56,480
all the overhead was just evaluating the

1120
00:40:56,480 --> 00:40:59,920
code and so we sort of reduced that by a

1121
00:40:59,920 --> 00:41:01,760
large margin and now it's more balanced

1122
00:41:01,760 --> 00:41:04,560
between this like uh punctured prf setup

1123
00:41:04,560 --> 00:41:06,960
phase and the code actually i think the

1124
00:41:06,960 --> 00:41:08,880
code is even faster than function prf so

1125
00:41:08,880 --> 00:41:10,400
now we sort of shifted the main overhead

1126
00:41:10,400 --> 00:41:12,720
to like the other parts of the protocol

1127
00:41:12,720 --> 00:41:15,359
uh and so that's comparing to the prior

1128
00:41:15,359 --> 00:41:18,400
work based on dual lpn uh the other main

1129
00:41:18,400 --> 00:41:20,800
point of comparison is is um

1130
00:41:20,800 --> 00:41:23,040
ikmp which is the traditional ot

1131
00:41:23,040 --> 00:41:25,440
extension approach and here we get

1132
00:41:25,440 --> 00:41:27,280
basically better efficiency

1133
00:41:27,280 --> 00:41:28,880
do not need to do this like matrix

1134
00:41:28,880 --> 00:41:30,880
transpose operation and obviously not

1135
00:41:30,880 --> 00:41:33,040
sending the data which is maybe the main

1136
00:41:33,040 --> 00:41:36,160
benefit uh so those are the two points

1137
00:41:36,160 --> 00:41:37,520
two primary parts there's also this

1138
00:41:37,520 --> 00:41:40,880
primal lpn ot protocols out there and

1139
00:41:40,880 --> 00:41:43,200
there we get better computational

1140
00:41:43,200 --> 00:41:45,040
efficiency just because theirs is quite

1141
00:41:45,040 --> 00:41:46,640
heavily involved after this iterative

1142
00:41:46,640 --> 00:41:47,520
step

1143
00:41:47,520 --> 00:41:49,760
um which adds overhead versus weak

1144
00:41:49,760 --> 00:41:51,200
sorter to directly

1145
00:41:51,200 --> 00:41:52,880
go

1146
00:41:52,880 --> 00:41:55,599
overall it's asymptotically linear uh we

1147
00:41:55,599 --> 00:41:59,599
generate like it's like 2n aes calls for

1148
00:41:59,599 --> 00:42:01,280
n otps

1149
00:42:01,280 --> 00:42:02,400
something like that

1150
00:42:02,400 --> 00:42:03,920
so it's quite

1151
00:42:03,920 --> 00:42:06,319
efficient

1152
00:42:07,359 --> 00:42:11,200
thanks thanks peter um so unless there's

1153
00:42:11,200 --> 00:42:12,079
um

1154
00:42:12,079 --> 00:42:14,160
any more questions in the audience now

1155
00:42:14,160 --> 00:42:17,119
then i i will take i will ask a question

1156
00:42:17,119 --> 00:42:20,079
um so i have a question uh for you uh

1157
00:42:20,079 --> 00:42:22,960
you um on the last slide you mentioned

1158
00:42:22,960 --> 00:42:24,800
uh you mentioned the gap so that you

1159
00:42:24,800 --> 00:42:27,599
can't that we don't know uh how to base

1160
00:42:27,599 --> 00:42:29,440
collision resistant hashing or public

1161
00:42:29,440 --> 00:42:31,520
key encryption on the hardness

1162
00:42:31,520 --> 00:42:35,040
of uh of ncp um so what is your what

1163
00:42:35,040 --> 00:42:37,359
would be your guess or your feeling are

1164
00:42:37,359 --> 00:42:39,839
you optimistic that this is just like

1165
00:42:39,839 --> 00:42:41,839
something small missing and then and

1166
00:42:41,839 --> 00:42:43,920
it's possible to get there or do you see

1167
00:42:43,920 --> 00:42:46,079
any concrete point in the analysis that

1168
00:42:46,079 --> 00:42:48,240
could be improved to get there or

1169
00:42:48,240 --> 00:42:50,800
like you think this is maybe

1170
00:42:50,800 --> 00:42:52,640
yeah

1171
00:42:52,640 --> 00:42:54,880
far too

1172
00:42:54,880 --> 00:42:57,280
i don't know i'm not very optimistic

1173
00:42:57,280 --> 00:42:59,359
about that because i

1174
00:42:59,359 --> 00:43:01,440
i also cause of the work that they can

1175
00:43:01,440 --> 00:43:03,119
construct

1176
00:43:03,119 --> 00:43:06,960
pke and the collision cih from support

1177
00:43:06,960 --> 00:43:09,839
sub-exponential hard erpm

1178
00:43:09,839 --> 00:43:11,440
in that case we

1179
00:43:11,440 --> 00:43:12,720
push all the

1180
00:43:12,720 --> 00:43:15,359
other possibilities and it is work in

1181
00:43:15,359 --> 00:43:17,440
this work we do also try to like

1182
00:43:17,440 --> 00:43:20,319
optimize everything and finally we have

1183
00:43:20,319 --> 00:43:21,760
we

1184
00:43:21,760 --> 00:43:24,319
it's very close but we didn't make it i

1185
00:43:24,319 --> 00:43:26,160
think this may be some kind of a

1186
00:43:26,160 --> 00:43:27,440
separation

1187
00:43:27,440 --> 00:43:29,680
i don't know but that's uh it was a

1188
00:43:29,680 --> 00:43:31,119
urban question

1189
00:43:31,119 --> 00:43:32,560
but my guess is

1190
00:43:32,560 --> 00:43:36,560
just maybe it's something so easy

1191
00:43:37,119 --> 00:43:41,280
okay very interesting things um

1192
00:43:41,280 --> 00:43:43,280
lisa if there is time i can answer the

1193
00:43:43,280 --> 00:43:45,839
shooter's question this is evgeny um i

1194
00:43:45,839 --> 00:43:47,920
can answer the cheetahs question about

1195
00:43:47,920 --> 00:43:49,839
seedless extractors but

1196
00:43:49,839 --> 00:43:51,520
yeah i think i think it's a different

1197
00:43:51,520 --> 00:43:54,880
setting so now europe paper um it was a

1198
00:43:54,880 --> 00:43:57,440
seedless extractor but it was inherently

1199
00:43:57,440 --> 00:43:59,839
in some kind of idealized model like so

1200
00:43:59,839 --> 00:44:01,599
essentially we formalized the heuristic

1201
00:44:01,599 --> 00:44:03,359
how to extract deterministically

1202
00:44:03,359 --> 00:44:06,079
randomness from officially samplable

1203
00:44:06,079 --> 00:44:07,520
sources using cryptographic hash

1204
00:44:07,520 --> 00:44:10,960
functions so it was kind of incomparable

1205
00:44:10,960 --> 00:44:12,880
last eurocrib we did have

1206
00:44:12,880 --> 00:44:15,119
standard model extension

1207
00:44:15,119 --> 00:44:17,359
uh of this work but those extractors

1208
00:44:17,359 --> 00:44:19,119
were not seedless but they were seeded

1209
00:44:19,119 --> 00:44:20,800
but

1210
00:44:20,800 --> 00:44:22,720
in some sense the sampler who samples

1211
00:44:22,720 --> 00:44:24,720
the distribution only has oracle access

1212
00:44:24,720 --> 00:44:26,319
to the next structure

1213
00:44:26,319 --> 00:44:29,280
uh when when he samples um so it's a

1214
00:44:29,280 --> 00:44:30,480
very good question but i guess the

1215
00:44:30,480 --> 00:44:34,920
incomparable models overall

1216
00:44:37,119 --> 00:44:38,800
thanks

1217
00:44:38,800 --> 00:44:41,839
thanks so uh

1218
00:44:41,839 --> 00:44:43,760
i have a question if we still have time

1219
00:44:43,760 --> 00:44:46,240
for yes yes we have thanks

1220
00:44:46,240 --> 00:44:48,480
okay

1221
00:44:48,480 --> 00:44:50,560
hi hi again thanks for answering that

1222
00:44:50,560 --> 00:44:51,520
question

1223
00:44:51,520 --> 00:44:52,560
um

1224
00:44:52,560 --> 00:44:53,920
so uh

1225
00:44:53,920 --> 00:44:57,680
elan i i wanted to ask you use a um time

1226
00:44:57,680 --> 00:44:59,200
lock puzzle as

1227
00:44:59,200 --> 00:45:01,200
some sort of object that

1228
00:45:01,200 --> 00:45:03,440
hard along some axis of hardness from

1229
00:45:03,440 --> 00:45:05,440
from the non malleable commitment but

1230
00:45:05,440 --> 00:45:08,480
also efficiently decodable um

1231
00:45:08,480 --> 00:45:09,359
and

1232
00:45:09,359 --> 00:45:10,400
so

1233
00:45:10,400 --> 00:45:13,440
can this be generalized can this be

1234
00:45:13,440 --> 00:45:15,200
i see that time lock puzzles are really

1235
00:45:15,200 --> 00:45:17,599
useful in your setting but

1236
00:45:17,599 --> 00:45:19,839
um

1237
00:45:20,319 --> 00:45:22,800
yeah i think there's nothing

1238
00:45:22,800 --> 00:45:24,480
there's nothing uh

1239
00:45:24,480 --> 00:45:26,560
really inherent about android puzzles

1240
00:45:26,560 --> 00:45:28,240
they just fit really well with the other

1241
00:45:28,240 --> 00:45:30,160
primitives

1242
00:45:30,160 --> 00:45:31,280
right we know how to construct

1243
00:45:31,280 --> 00:45:33,280
non-valuable commitments

1244
00:45:33,280 --> 00:45:34,079
uh

1245
00:45:34,079 --> 00:45:36,240
basically from only one assumption which

1246
00:45:36,240 --> 00:45:40,319
is non-valuable which is dialog puzzles

1247
00:45:40,319 --> 00:45:41,599
yeah

1248
00:45:41,599 --> 00:45:44,800
yeah we so

1249
00:45:44,800 --> 00:45:47,119
i i guess oh no right we also have from

1250
00:45:47,119 --> 00:45:49,760
lwe

1251
00:45:50,160 --> 00:45:52,400
and so yeah so probably there is nothing

1252
00:45:52,400 --> 00:45:54,640
super inherent about it we just need to

1253
00:45:54,640 --> 00:45:57,839
fit all the pieces together

1254
00:45:57,839 --> 00:45:59,359
i don't think there's anything inherent

1255
00:45:59,359 --> 00:46:00,400
about

1256
00:46:00,400 --> 00:46:02,880
time of puzzles so the proof might go

1257
00:46:02,880 --> 00:46:04,079
through with

1258
00:46:04,079 --> 00:46:05,440
other assumptions or other

1259
00:46:05,440 --> 00:46:06,800
instantiations

1260
00:46:06,800 --> 00:46:09,760
okay thanks

1261
00:46:10,560 --> 00:46:12,240
thank you

1262
00:46:12,240 --> 00:46:15,599
so i have one more question for uh

1263
00:46:15,599 --> 00:46:20,000
psy so in in in the long talk um the the

1264
00:46:20,000 --> 00:46:20,800
the

1265
00:46:20,800 --> 00:46:24,720
um scheme you present uh the rate uh

1266
00:46:24,720 --> 00:46:27,200
degrades so you have this parameter h

1267
00:46:27,200 --> 00:46:29,599
and did the rate degrades with one over

1268
00:46:29,599 --> 00:46:32,160
h to support large larger leakage h

1269
00:46:32,160 --> 00:46:34,079
times t so you have like kind of a

1270
00:46:34,079 --> 00:46:36,560
linear trade-off between uh between the

1271
00:46:36,560 --> 00:46:38,560
right rate and the amount of leakage you

1272
00:46:38,560 --> 00:46:41,119
can support do you have any is this like

1273
00:46:41,119 --> 00:46:43,040
inherent in in the model or is this

1274
00:46:43,040 --> 00:46:45,200
something that just that your approach

1275
00:46:45,200 --> 00:46:47,119
gives to is there any known results or

1276
00:46:47,119 --> 00:46:50,640
can you say anything about this

1277
00:46:50,640 --> 00:46:52,880
yeah no this is not inherent to the

1278
00:46:52,880 --> 00:46:54,839
model this is inherent to the

1279
00:46:54,839 --> 00:46:57,119
construction yeah

1280
00:46:57,119 --> 00:46:58,240
yeah

1281
00:46:58,240 --> 00:47:01,359
okay okay cool thank you

1282
00:47:01,359 --> 00:47:04,560
um so do you think uh like this can be

1283
00:47:04,560 --> 00:47:06,800
improved upon or or i guess that that

1284
00:47:06,800 --> 00:47:08,640
would require very like maybe very

1285
00:47:08,640 --> 00:47:11,839
different techniques or

1286
00:47:12,800 --> 00:47:15,119
yeah might be possible yeah there is

1287
00:47:15,119 --> 00:47:17,119
still some

1288
00:47:17,119 --> 00:47:18,560
yeah

1289
00:47:18,560 --> 00:47:20,480
okay

1290
00:47:20,480 --> 00:47:22,839
with better analysis

1291
00:47:22,839 --> 00:47:25,760
uh so currently this is the best that we

1292
00:47:25,760 --> 00:47:27,119
have yeah

1293
00:47:27,119 --> 00:47:30,240
but yeah we still have some

1294
00:47:30,240 --> 00:47:32,480
okay okay thank you

1295
00:47:32,480 --> 00:47:36,160
um do we have any more questions from

1296
00:47:36,160 --> 00:47:39,558
the audience

1297
00:47:46,240 --> 00:47:47,920
i don't see any more questions maybe

1298
00:47:47,920 --> 00:47:50,400
then i have a

1299
00:47:50,400 --> 00:47:54,720
question to elan

1300
00:47:54,800 --> 00:47:57,760
uh so

1301
00:48:00,319 --> 00:48:04,240
um so so you you you pose it as an as an

1302
00:48:04,240 --> 00:48:07,359
open open question in in getting rid of

1303
00:48:07,359 --> 00:48:09,760
the mostly of the keyless hash function

1304
00:48:09,760 --> 00:48:12,319
and then can you give a bit of intuition

1305
00:48:12,319 --> 00:48:15,520
why this is hard or so so so i guess if

1306
00:48:15,520 --> 00:48:16,720
you would

1307
00:48:16,720 --> 00:48:20,079
this is uh this is is this is this or is

1308
00:48:20,079 --> 00:48:22,079
the main purpose to allow to get rid of

1309
00:48:22,079 --> 00:48:25,200
the the crs and to get also uh security

1310
00:48:25,200 --> 00:48:27,280
against uh non-uniform adversaries or

1311
00:48:27,280 --> 00:48:28,720
what is like what is the role and what

1312
00:48:28,720 --> 00:48:30,960
is the challenge there can you elaborate

1313
00:48:30,960 --> 00:48:32,720
a bit on that

1314
00:48:32,720 --> 00:48:34,000
so the keyless

1315
00:48:34,000 --> 00:48:36,000
hash functions are used to get security

1316
00:48:36,000 --> 00:48:39,760
against non-uniform attackers

1317
00:48:40,240 --> 00:48:41,839
so it's not a serious assumption it's

1318
00:48:41,839 --> 00:48:43,520
just an assumption

1319
00:48:43,520 --> 00:48:45,680
that such a function exists

1320
00:48:45,680 --> 00:48:47,839
i guess the challenge is that there's

1321
00:48:47,839 --> 00:48:49,599
only we're using non-valuable

1322
00:48:49,599 --> 00:48:51,520
commitments in our construction and

1323
00:48:51,520 --> 00:48:52,400
there's

1324
00:48:52,400 --> 00:48:54,559
basically two constructions or

1325
00:48:54,559 --> 00:48:56,559
very few constructions and

1326
00:48:56,559 --> 00:48:58,800
one of them uses keyless hash functions

1327
00:48:58,800 --> 00:49:01,119
and the other doesn't but it uses some

1328
00:49:01,119 --> 00:49:03,520
other form of uh

1329
00:49:03,520 --> 00:49:05,520
of hardness which is like quantum

1330
00:49:05,520 --> 00:49:06,960
hardness

1331
00:49:06,960 --> 00:49:08,000
uh

1332
00:49:08,000 --> 00:49:09,839
so it might be possible to get rid of

1333
00:49:09,839 --> 00:49:12,079
them by replacing it with a different

1334
00:49:12,079 --> 00:49:14,559
kind of assumption but it will you will

1335
00:49:14,559 --> 00:49:16,559
paint some other place so something else

1336
00:49:16,559 --> 00:49:17,520
will

1337
00:49:17,520 --> 00:49:18,480
will be

1338
00:49:18,480 --> 00:49:19,680
less good

1339
00:49:19,680 --> 00:49:21,280
and maybe decoding will need to be

1340
00:49:21,280 --> 00:49:24,079
quantum or something like that

1341
00:49:24,079 --> 00:49:27,760
okay i think it's possible it's possible

1342
00:49:27,760 --> 00:49:28,960
yeah yeah

1343
00:49:28,960 --> 00:49:32,240
yes yeah with the with the cis i just

1344
00:49:32,240 --> 00:49:34,319
meant like would it get much easier like

1345
00:49:34,319 --> 00:49:36,000
your construction yeah yeah

1346
00:49:36,000 --> 00:49:36,720
yeah

1347
00:49:36,720 --> 00:49:39,040
yeah yeah if there's a crs the the whole

1348
00:49:39,040 --> 00:49:41,599
problem becomes essentially trivial

1349
00:49:41,599 --> 00:49:44,720
ah okay okay thanks

1350
00:49:44,720 --> 00:49:46,400
thanks um

1351
00:49:46,400 --> 00:49:48,559
very interesting maybe not trivial but

1352
00:49:48,559 --> 00:49:50,240
known

1353
00:49:50,240 --> 00:49:52,400
okay

1354
00:49:52,400 --> 00:49:54,079
um okay

1355
00:49:54,079 --> 00:49:55,839
um

1356
00:49:55,839 --> 00:49:57,520
what's the time i guess

1357
00:49:57,520 --> 00:49:58,720
we're

1358
00:49:58,720 --> 00:50:01,760
out of time so i if there's no more

1359
00:50:01,760 --> 00:50:04,400
question from the audience and

1360
00:50:04,400 --> 00:50:07,920
yeah i don't see any new questions on

1361
00:50:07,920 --> 00:50:10,400
tulip right now so

1362
00:50:10,400 --> 00:50:12,880
yeah thank

