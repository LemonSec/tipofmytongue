1
00:00:00,719 --> 00:00:03,439
hi i'm arushi i'm going to talk about

2
00:00:03,439 --> 00:00:05,839
this joint work with arkhar chaudhary

3
00:00:05,839 --> 00:00:08,639
matthew green abhishek jain and gabriel

4
00:00:08,639 --> 00:00:10,719
captain on secure multi-party

5
00:00:10,719 --> 00:00:13,840
computation with dynamic participants

6
00:00:13,840 --> 00:00:15,519
to begin with

7
00:00:15,519 --> 00:00:18,000
mpc is an interactive protocol that

8
00:00:18,000 --> 00:00:20,160
allows a group of mutually distrusting

9
00:00:20,160 --> 00:00:22,640
parties to compute on their private

10
00:00:22,640 --> 00:00:23,920
inputs

11
00:00:23,920 --> 00:00:26,240
and the security guaranteed by an mpc

12
00:00:26,240 --> 00:00:29,039
protocol is that an adversary who

13
00:00:29,039 --> 00:00:31,519
corrupts a subset of the parties should

14
00:00:31,519 --> 00:00:34,000
not be able to learn anything beyond

15
00:00:34,000 --> 00:00:35,840
just the output of the function that the

16
00:00:35,840 --> 00:00:38,960
parties were computing

17
00:00:39,440 --> 00:00:42,320
npc was introduced in the 80s and since

18
00:00:42,320 --> 00:00:44,960
then there has been extensive research

19
00:00:44,960 --> 00:00:47,600
in trying to bring npc closer to

20
00:00:47,600 --> 00:00:48,640
practice

21
00:00:48,640 --> 00:00:51,920
and as the efficiency of mpc increases

22
00:00:51,920 --> 00:00:54,079
the hope is that it can be used to

23
00:00:54,079 --> 00:00:57,039
compute large complex functionalities

24
00:00:57,039 --> 00:00:58,719
such as training machine learning

25
00:00:58,719 --> 00:01:01,600
algorithms or simulating large ram

26
00:01:01,600 --> 00:01:04,879
programs on massive distributed data

27
00:01:04,879 --> 00:01:06,720
sets

28
00:01:06,720 --> 00:01:08,960
however since these are massive

29
00:01:08,960 --> 00:01:11,520
functionalities irrespective of how

30
00:01:11,520 --> 00:01:14,560
efficient the npc protocol is computing

31
00:01:14,560 --> 00:01:17,200
on them could take up to several hours

32
00:01:17,200 --> 00:01:20,080
or even days

33
00:01:20,320 --> 00:01:22,159
the problem with most existing

34
00:01:22,159 --> 00:01:24,080
literature on mpc

35
00:01:24,080 --> 00:01:27,280
is that it considers static participants

36
00:01:27,280 --> 00:01:28,960
and what that means is

37
00:01:28,960 --> 00:01:31,680
that the participating parties are fixed

38
00:01:31,680 --> 00:01:34,000
at the beginning of the protocol

39
00:01:34,000 --> 00:01:36,880
in such protocols if the computation is

40
00:01:36,880 --> 00:01:38,079
long drawn

41
00:01:38,079 --> 00:01:40,880
some of the parties might leave or drop

42
00:01:40,880 --> 00:01:43,360
out in the middle of the computation

43
00:01:43,360 --> 00:01:45,439
this could be because they have some

44
00:01:45,439 --> 00:01:48,560
other commitment or maybe because they

45
00:01:48,560 --> 00:01:50,720
ran out of resources

46
00:01:50,720 --> 00:01:53,119
in such cases the remaining parties

47
00:01:53,119 --> 00:01:55,360
usually have to simply abort the

48
00:01:55,360 --> 00:01:58,240
competition and all of the work done so

49
00:01:58,240 --> 00:02:01,360
far goes to waste

50
00:02:01,439 --> 00:02:04,079
indeed requiring all of the parties to

51
00:02:04,079 --> 00:02:05,840
stay online

52
00:02:05,840 --> 00:02:08,560
throughout the entire computation is an

53
00:02:08,560 --> 00:02:11,120
unrealistic expectation

54
00:02:11,120 --> 00:02:13,440
therefore the main question that we

55
00:02:13,440 --> 00:02:15,599
address in this work is whether the

56
00:02:15,599 --> 00:02:18,800
static nature of npc protocols is really

57
00:02:18,800 --> 00:02:22,080
inherent or if there is a way to design

58
00:02:22,080 --> 00:02:24,319
protocols that

59
00:02:24,319 --> 00:02:27,920
allow dynamic participants

60
00:02:28,080 --> 00:02:30,560
to elaborate on what i mean by dynamic

61
00:02:30,560 --> 00:02:32,800
participants let's consider a group of

62
00:02:32,800 --> 00:02:35,440
parties that begin executing an abc

63
00:02:35,440 --> 00:02:37,200
protocol

64
00:02:37,200 --> 00:02:39,120
now after some time let's say two

65
00:02:39,120 --> 00:02:41,120
parties need to leave

66
00:02:41,120 --> 00:02:43,120
but at the same time

67
00:02:43,120 --> 00:02:45,440
another party is willing to join the

68
00:02:45,440 --> 00:02:46,879
computation

69
00:02:46,879 --> 00:02:49,280
what we want is that this should not

70
00:02:49,280 --> 00:02:52,720
disrupt the computation and instead

71
00:02:52,720 --> 00:02:55,200
this previous group of parties should be

72
00:02:55,200 --> 00:02:57,760
able to securely share the computation

73
00:02:57,760 --> 00:03:00,879
done by them with the new group

74
00:03:00,879 --> 00:03:03,599
such that they can use this group to

75
00:03:03,599 --> 00:03:05,680
continue the rest of the computation

76
00:03:05,680 --> 00:03:08,560
without having to redo the work done by

77
00:03:08,560 --> 00:03:11,360
the previous group

78
00:03:11,840 --> 00:03:14,239
and the protocol can proceed in a

79
00:03:14,239 --> 00:03:16,959
similar way with parties leaving and

80
00:03:16,959 --> 00:03:19,519
joining is the wish without causing any

81
00:03:19,519 --> 00:03:22,000
disruptions

82
00:03:22,000 --> 00:03:24,319
this approach will clearly reduce the

83
00:03:24,319 --> 00:03:26,560
burden of competition on individual

84
00:03:26,560 --> 00:03:28,239
parties

85
00:03:28,239 --> 00:03:29,920
parties that have low computational

86
00:03:29,920 --> 00:03:32,000
resources for example the blue party

87
00:03:32,000 --> 00:03:34,480
here can participate for a small amount

88
00:03:34,480 --> 00:03:35,760
of time

89
00:03:35,760 --> 00:03:37,760
and parties that have enough dedicated

90
00:03:37,760 --> 00:03:40,319
resources can continue to participate

91
00:03:40,319 --> 00:03:42,720
for a longer time for example the yellow

92
00:03:42,720 --> 00:03:45,280
party here

93
00:03:45,360 --> 00:03:47,440
such a protocol would result in a

94
00:03:47,440 --> 00:03:50,319
weighted privacy preserving distributed

95
00:03:50,319 --> 00:03:52,080
computing system

96
00:03:52,080 --> 00:03:54,640
which can also be used as a paid mpc as

97
00:03:54,640 --> 00:03:56,879
a service framework where the clients

98
00:03:56,879 --> 00:03:57,680
can

99
00:03:57,680 --> 00:04:00,959
pay to delegate computational tasks

100
00:04:00,959 --> 00:04:03,439
and anyone irrespective of their time

101
00:04:03,439 --> 00:04:06,560
availability or computing resources can

102
00:04:06,560 --> 00:04:09,120
volunteer to participate and get paid

103
00:04:09,120 --> 00:04:11,760
accordingly

104
00:04:12,799 --> 00:04:15,439
notions related to dynamic participants

105
00:04:15,439 --> 00:04:18,238
have been considered in some prior works

106
00:04:18,238 --> 00:04:20,079
for instance this notion of player

107
00:04:20,079 --> 00:04:22,320
replaceability where

108
00:04:22,320 --> 00:04:24,560
the parties are replaced after every

109
00:04:24,560 --> 00:04:27,759
round has been studied by mikali and

110
00:04:27,759 --> 00:04:29,919
chen in the context of byzantine

111
00:04:29,919 --> 00:04:31,840
agreement

112
00:04:31,840 --> 00:04:34,080
this notion of player replaceability was

113
00:04:34,080 --> 00:04:37,120
also used in the design of algorand by

114
00:04:37,120 --> 00:04:40,000
gillard at all

115
00:04:40,720 --> 00:04:44,160
this idea in algorand was used to keep

116
00:04:44,160 --> 00:04:46,880
the identity of the parties hidden until

117
00:04:46,880 --> 00:04:48,160
they speak

118
00:04:48,160 --> 00:04:50,800
and this notion of player replaceability

119
00:04:50,800 --> 00:04:53,680
helps prevent targeted attacks on chosen

120
00:04:53,680 --> 00:04:54,960
participants

121
00:04:54,960 --> 00:04:58,719
after their identity is revealed

122
00:04:59,440 --> 00:05:01,680
while the idea of dynamic participants

123
00:05:01,680 --> 00:05:03,520
is relatively new

124
00:05:03,520 --> 00:05:07,120
the notion of dynamism itself dates back

125
00:05:07,120 --> 00:05:08,560
to the 90s

126
00:05:08,560 --> 00:05:10,560
where ostrowski at all

127
00:05:10,560 --> 00:05:12,720
introduced the notion of a mobile

128
00:05:12,720 --> 00:05:15,759
adversary that can keep changing its set

129
00:05:15,759 --> 00:05:18,000
of corrupted parties while the

130
00:05:18,000 --> 00:05:20,560
participants remain static

131
00:05:20,560 --> 00:05:22,479
the main idea behind their modeling

132
00:05:22,479 --> 00:05:25,120
choice was to capture a slow moving

133
00:05:25,120 --> 00:05:27,199
adversary such as the spread of a

134
00:05:27,199 --> 00:05:29,840
computer virus

135
00:05:29,840 --> 00:05:32,560
more recently goyal at all and benomoda

136
00:05:32,560 --> 00:05:35,440
at all have also studied secret sharing

137
00:05:35,440 --> 00:05:37,600
with dynamic participants

138
00:05:37,600 --> 00:05:40,080
their notion of dynamism is similar to

139
00:05:40,080 --> 00:05:42,720
ours but they only focus on secret

140
00:05:42,720 --> 00:05:44,400
sharing while we

141
00:05:44,400 --> 00:05:46,960
uh focus on a broader goal of designing

142
00:05:46,960 --> 00:05:48,479
npc

143
00:05:48,479 --> 00:05:51,880
in this setting

144
00:05:52,160 --> 00:05:54,080
on to our contributions our

145
00:05:54,080 --> 00:05:56,080
contributions are twofold

146
00:05:56,080 --> 00:05:58,720
our first and main contribution is in

147
00:05:58,720 --> 00:06:01,680
formalizing a model for npc with dynamic

148
00:06:01,680 --> 00:06:03,039
participants

149
00:06:03,039 --> 00:06:07,440
we refer to this model as fluid npc

150
00:06:07,440 --> 00:06:10,000
and this name comes from the fact

151
00:06:10,000 --> 00:06:11,919
that it allows a smooth flow of

152
00:06:11,919 --> 00:06:14,000
information between the different groups

153
00:06:14,000 --> 00:06:15,680
of parties

154
00:06:15,680 --> 00:06:18,240
we also design both semi-honest and

155
00:06:18,240 --> 00:06:21,039
maliciously secure protocols

156
00:06:21,039 --> 00:06:24,479
in this fluid mpc model

157
00:06:24,880 --> 00:06:27,280
i will now talk about the fluid mpc

158
00:06:27,280 --> 00:06:28,479
model

159
00:06:28,479 --> 00:06:30,240
in more detail

160
00:06:30,240 --> 00:06:33,280
so we model computation in the setting

161
00:06:33,280 --> 00:06:35,919
in the well studied client server model

162
00:06:35,919 --> 00:06:37,520
where the clients can delegate

163
00:06:37,520 --> 00:06:39,919
computational tasks to a set of

164
00:06:39,919 --> 00:06:41,759
volunteer servers

165
00:06:41,759 --> 00:06:44,080
and this computation proceeds in three

166
00:06:44,080 --> 00:06:45,759
main stages

167
00:06:45,759 --> 00:06:48,080
the first stage is the input stage where

168
00:06:48,080 --> 00:06:50,880
the clients can give or share their

169
00:06:50,880 --> 00:06:52,479
inputs with

170
00:06:52,479 --> 00:06:54,080
the servers

171
00:06:54,080 --> 00:06:56,800
now given these inputs a set of dynamic

172
00:06:56,800 --> 00:06:59,520
servers participate in the execution

173
00:06:59,520 --> 00:07:02,960
stage where the main computation is done

174
00:07:02,960 --> 00:07:05,680
and finally during the output state

175
00:07:05,680 --> 00:07:08,319
the servers share the output of the

176
00:07:08,319 --> 00:07:10,240
computation with the clients who can

177
00:07:10,240 --> 00:07:14,319
then reconstruct and learn the output

178
00:07:15,199 --> 00:07:16,880
since we assume that the clients are

179
00:07:16,880 --> 00:07:18,080
static

180
00:07:18,080 --> 00:07:18,880
uh

181
00:07:18,880 --> 00:07:21,280
dynamism only shows up in the execution

182
00:07:21,280 --> 00:07:23,759
stage therefore i'm only going to focus

183
00:07:23,759 --> 00:07:26,000
on the execution stage now

184
00:07:26,000 --> 00:07:28,880
so the execution stage can be viewed as

185
00:07:28,880 --> 00:07:32,319
proceeding in discrete steps

186
00:07:32,319 --> 00:07:34,880
called epochs where each epoch could

187
00:07:34,880 --> 00:07:38,000
potentially consist of many rounds

188
00:07:38,000 --> 00:07:40,639
each epoch is further divided into two

189
00:07:40,639 --> 00:07:42,720
main sub phases

190
00:07:42,720 --> 00:07:44,400
called the computation phase and the

191
00:07:44,400 --> 00:07:45,840
hand-off phase

192
00:07:45,840 --> 00:07:48,400
and each epoch has a designated set of

193
00:07:48,400 --> 00:07:50,800
parties which we refer to as the

194
00:07:50,800 --> 00:07:54,479
assigned committee for that epoch

195
00:07:54,479 --> 00:07:57,360
while in the hand of phase uh i'm sorry

196
00:07:57,360 --> 00:07:59,599
the parties within the assigned

197
00:07:59,599 --> 00:08:01,360
committee of an in

198
00:08:01,360 --> 00:08:04,160
of an epoch interact with each other in

199
00:08:04,160 --> 00:08:06,479
the computation phase and then in the

200
00:08:06,479 --> 00:08:08,639
hand of phase they interact with the

201
00:08:08,639 --> 00:08:11,759
parties in the next committee to share

202
00:08:11,759 --> 00:08:14,319
the information share information about

203
00:08:14,319 --> 00:08:16,319
the computation

204
00:08:16,319 --> 00:08:18,639
done by them so far

205
00:08:18,639 --> 00:08:20,400
and this is basically how the

206
00:08:20,400 --> 00:08:23,599
computation proceeds

207
00:08:23,919 --> 00:08:26,639
for our protocols we consider an honest

208
00:08:26,639 --> 00:08:29,199
majority of clients and an honest

209
00:08:29,199 --> 00:08:31,840
majority of servers in each committee

210
00:08:31,840 --> 00:08:34,559
but of course one could consider

211
00:08:34,559 --> 00:08:39,239
a dishonest majority setting as well

212
00:08:40,320 --> 00:08:42,479
based on the discussion so far it's

213
00:08:42,479 --> 00:08:44,480
clear that there are two main components

214
00:08:44,480 --> 00:08:46,800
in a fluid mpc protocol

215
00:08:46,800 --> 00:08:49,360
the first is deciding how the committees

216
00:08:49,360 --> 00:08:51,839
for each epoch will be selected

217
00:08:51,839 --> 00:08:54,240
and then given these committees how the

218
00:08:54,240 --> 00:08:56,800
protocol in particular the execution

219
00:08:56,800 --> 00:09:00,319
phase of the protocol will proceed

220
00:09:01,440 --> 00:09:03,279
i will now elaborate on the different

221
00:09:03,279 --> 00:09:05,519
properties required from both these

222
00:09:05,519 --> 00:09:06,880
components

223
00:09:06,880 --> 00:09:09,360
so the two main properties required from

224
00:09:09,360 --> 00:09:12,320
our protocol execution uh i'm sorry the

225
00:09:12,320 --> 00:09:14,480
execution phase of our protocol

226
00:09:14,480 --> 00:09:18,000
uh our division of work and fluidity

227
00:09:18,000 --> 00:09:19,600
let me explain each of them in more

228
00:09:19,600 --> 00:09:21,040
detail

229
00:09:21,040 --> 00:09:23,040
so the first main requirement that is

230
00:09:23,040 --> 00:09:25,920
division of work essentially means that

231
00:09:25,920 --> 00:09:29,120
each committee should only be required

232
00:09:29,120 --> 00:09:33,440
to compute a small part of the circuit

233
00:09:33,440 --> 00:09:36,000
and ideally this computation should be

234
00:09:36,000 --> 00:09:38,560
independent of the depth of the circuit

235
00:09:38,560 --> 00:09:40,959
otherwise if the committee is required

236
00:09:40,959 --> 00:09:43,360
to do a lot of work then that would

237
00:09:43,360 --> 00:09:45,360
defeat the whole purpose of dynamism in

238
00:09:45,360 --> 00:09:47,920
some sense

239
00:09:48,560 --> 00:09:50,399
a second requirement is that the

240
00:09:50,399 --> 00:09:53,279
protocol should have a high churn rate

241
00:09:53,279 --> 00:09:54,560
in other words

242
00:09:54,560 --> 00:09:56,880
the commitment that each party needs to

243
00:09:56,880 --> 00:10:00,720
make in order to participate should be

244
00:10:00,720 --> 00:10:02,640
should be relatively small

245
00:10:02,640 --> 00:10:04,560
and we measure this commitment in the

246
00:10:04,560 --> 00:10:08,880
number of rounds in an epoch

247
00:10:08,880 --> 00:10:11,600
in fact ideally what we want is that a

248
00:10:11,600 --> 00:10:14,560
protocol should have maximum fluidity

249
00:10:14,560 --> 00:10:17,040
meaning that each party should only be

250
00:10:17,040 --> 00:10:20,240
required to communicate in one round

251
00:10:20,240 --> 00:10:22,480
this can be achieved only if the

252
00:10:22,480 --> 00:10:24,399
computation phase

253
00:10:24,399 --> 00:10:27,279
uh is completely silent and no messages

254
00:10:27,279 --> 00:10:29,519
are exchanged during this phase

255
00:10:29,519 --> 00:10:33,120
while the handoff phase should consist

256
00:10:33,120 --> 00:10:35,440
of a single round of unidirectional

257
00:10:35,440 --> 00:10:36,480
messages

258
00:10:36,480 --> 00:10:39,519
from the old committee to the committee

259
00:10:39,519 --> 00:10:41,440
of the next epoch

260
00:10:41,440 --> 00:10:43,920
designing such protocols where each

261
00:10:43,920 --> 00:10:46,160
committee is only required to send a

262
00:10:46,160 --> 00:10:48,399
single message

263
00:10:48,399 --> 00:10:50,880
is in my opinion both theoretically and

264
00:10:50,880 --> 00:10:54,079
practically interesting

265
00:10:54,480 --> 00:10:56,959
looking ahead uh we design our protocols

266
00:10:56,959 --> 00:11:01,360
keeping these two properties in mind

267
00:11:01,360 --> 00:11:04,320
and so while we view committee selection

268
00:11:04,320 --> 00:11:06,720
as an external process and assume that

269
00:11:06,720 --> 00:11:08,720
its outcome is an input to our main

270
00:11:08,720 --> 00:11:10,000
protocol

271
00:11:10,000 --> 00:11:11,680
nevertheless

272
00:11:11,680 --> 00:11:13,839
the properties of the selection process

273
00:11:13,839 --> 00:11:15,600
actually dictates the design of the

274
00:11:15,600 --> 00:11:18,640
remaining protocol

275
00:11:18,880 --> 00:11:21,040
therefore the main properties of the

276
00:11:21,040 --> 00:11:23,200
committee selection process process that

277
00:11:23,200 --> 00:11:26,160
we want to consider here

278
00:11:26,160 --> 00:11:28,079
are how and when the committees are

279
00:11:28,079 --> 00:11:30,800
formed and when the adversary gets to

280
00:11:30,800 --> 00:11:34,640
corrupt parties in these committees

281
00:11:34,640 --> 00:11:36,480
i will discuss each of these in more

282
00:11:36,480 --> 00:11:39,680
detail now and on the way also mention

283
00:11:39,680 --> 00:11:41,680
how this committee selection process

284
00:11:41,680 --> 00:11:43,920
with the desired properties can be

285
00:11:43,920 --> 00:11:47,839
instantiated using prior works

286
00:11:47,839 --> 00:11:49,440
starting with when the committees are

287
00:11:49,440 --> 00:11:50,639
formed

288
00:11:50,639 --> 00:11:53,120
so one could consider a weaker variant

289
00:11:53,120 --> 00:11:55,519
where the committees are decided at the

290
00:11:55,519 --> 00:11:57,279
beginning of the protocol

291
00:11:57,279 --> 00:11:59,920
but that is clearly too restrictive

292
00:11:59,920 --> 00:12:02,880
therefore we consider an on the fly

293
00:12:02,880 --> 00:12:05,279
committee formation

294
00:12:05,279 --> 00:12:07,680
model where the committees for each

295
00:12:07,680 --> 00:12:09,920
epoch are known at the start of the

296
00:12:09,920 --> 00:12:13,120
handoff phase of the previous epoch

297
00:12:13,120 --> 00:12:15,760
so for instance in this example

298
00:12:15,760 --> 00:12:17,920
the committee for the first epoch is

299
00:12:17,920 --> 00:12:21,040
decided during the input stage

300
00:12:21,040 --> 00:12:23,279
and similarly the committee for the

301
00:12:23,279 --> 00:12:25,519
second epoch is determined at the

302
00:12:25,519 --> 00:12:27,120
beginning of the hand of phase of the

303
00:12:27,120 --> 00:12:28,959
first epoch

304
00:12:28,959 --> 00:12:31,120
and so on

305
00:12:31,120 --> 00:12:34,399
now the next question to consider is how

306
00:12:34,399 --> 00:12:36,800
are these committees decided

307
00:12:36,800 --> 00:12:39,760
so again one could consider a completely

308
00:12:39,760 --> 00:12:42,480
volunteer based system where anyone is

309
00:12:42,480 --> 00:12:45,120
allowed to sign up at any time and

310
00:12:45,120 --> 00:12:47,680
anyone who signs up is included in the

311
00:12:47,680 --> 00:12:49,839
computation

312
00:12:49,839 --> 00:12:52,160
but clearly this kind of system is prone

313
00:12:52,160 --> 00:12:55,040
to civil attacks in which a single party

314
00:12:55,040 --> 00:12:57,360
pretends to be many parties

315
00:12:57,360 --> 00:12:59,519
and enforcing a strict corruption

316
00:12:59,519 --> 00:13:01,839
threshold in each committee in the

317
00:13:01,839 --> 00:13:05,120
setting would be difficult

318
00:13:05,120 --> 00:13:08,160
the other more realistic option uh is

319
00:13:08,160 --> 00:13:09,839
one that's based on an election

320
00:13:09,839 --> 00:13:11,200
mechanism

321
00:13:11,200 --> 00:13:13,360
this is where every party who wants to

322
00:13:13,360 --> 00:13:16,959
participate can nominate itself

323
00:13:16,959 --> 00:13:19,519
and an election process decides which of

324
00:13:19,519 --> 00:13:21,760
these nominated parties actually get to

325
00:13:21,760 --> 00:13:23,040
participate

326
00:13:23,040 --> 00:13:26,000
this is clearly a more realistic model

327
00:13:26,000 --> 00:13:28,720
and in fact these recent works by bennu

328
00:13:28,720 --> 00:13:31,680
moditol and goyal at all

329
00:13:31,680 --> 00:13:33,680
implement such an election process that

330
00:13:33,680 --> 00:13:36,320
enforces a corruption threshold in each

331
00:13:36,320 --> 00:13:38,079
committee using proof of state

332
00:13:38,079 --> 00:13:39,760
blockchains

333
00:13:39,760 --> 00:13:42,399
as i mentioned earlier one could choose

334
00:13:42,399 --> 00:13:44,720
which of these they want to consider

335
00:13:44,720 --> 00:13:46,399
depending on the need

336
00:13:46,399 --> 00:13:48,320
from the perspective of our main

337
00:13:48,320 --> 00:13:51,199
protocol we keep these choices

338
00:13:51,199 --> 00:13:53,839
uh separate from the main protocol and

339
00:13:53,839 --> 00:13:55,920
as long as the next committee is

340
00:13:55,920 --> 00:13:57,519
determined at the beginning of the

341
00:13:57,519 --> 00:13:59,040
handoff phase

342
00:13:59,040 --> 00:14:03,839
uh that's that's that's all we require

343
00:14:04,959 --> 00:14:07,279
so the next question is about committee

344
00:14:07,279 --> 00:14:08,720
corruption

345
00:14:08,720 --> 00:14:10,720
here again one could consider static

346
00:14:10,720 --> 00:14:13,279
corruptions but we consider a stronger

347
00:14:13,279 --> 00:14:15,360
adaptive corruption model

348
00:14:15,360 --> 00:14:17,199
where the adversary is allowed to

349
00:14:17,199 --> 00:14:20,639
corrupt parties within a committee

350
00:14:20,639 --> 00:14:22,079
throughout its

351
00:14:22,079 --> 00:14:23,680
activity period

352
00:14:23,680 --> 00:14:26,800
so for instance here it could corrupt

353
00:14:26,800 --> 00:14:28,720
a party in a given committee during the

354
00:14:28,720 --> 00:14:31,360
hand-off phase or anytime during the

355
00:14:31,360 --> 00:14:33,839
computation phase or

356
00:14:33,839 --> 00:14:37,279
during the next hand of phase

357
00:14:37,440 --> 00:14:39,600
we also need to account for the effect

358
00:14:39,600 --> 00:14:41,839
that corrupting a server has

359
00:14:41,839 --> 00:14:43,519
on the prior epochs where it

360
00:14:43,519 --> 00:14:45,120
participated

361
00:14:45,120 --> 00:14:47,279
for instance here if the anniversary

362
00:14:47,279 --> 00:14:49,760
corrupts this yellow party at some later

363
00:14:49,760 --> 00:14:50,880
epoch

364
00:14:50,880 --> 00:14:53,440
then it inevitably learns the its

365
00:14:53,440 --> 00:14:56,399
private state in the previous epoch

366
00:14:56,399 --> 00:14:59,120
therefore if there is an overlap we

367
00:14:59,120 --> 00:15:01,120
assume that a server

368
00:15:01,120 --> 00:15:03,199
can only be corrupted if it doesn't

369
00:15:03,199 --> 00:15:05,600
violate the corruption threshold of the

370
00:15:05,600 --> 00:15:08,399
prior ebox

371
00:15:09,680 --> 00:15:11,760
now let me move on to the actual

372
00:15:11,760 --> 00:15:14,399
protocols that we design in the setting

373
00:15:14,399 --> 00:15:16,240
so assuming that we have a committee

374
00:15:16,240 --> 00:15:18,959
selection process that satisfies all of

375
00:15:18,959 --> 00:15:20,800
the properties that i mentioned on the

376
00:15:20,800 --> 00:15:22,399
previous slides

377
00:15:22,399 --> 00:15:25,920
we observe that an optimized version of

378
00:15:25,920 --> 00:15:29,600
the classical bgw protocol by genero it

379
00:15:29,600 --> 00:15:30,320
all

380
00:15:30,320 --> 00:15:33,440
can actually be naturally adapted to the

381
00:15:33,440 --> 00:15:36,480
fluid mpc setting and in fact this

382
00:15:36,480 --> 00:15:40,720
protocol achieves maximal fluidity

383
00:15:40,720 --> 00:15:43,600
i'm going to give a quick recap of this

384
00:15:43,600 --> 00:15:47,199
optimized semi-honest pdw protocol first

385
00:15:47,199 --> 00:15:49,279
so this protocol

386
00:15:49,279 --> 00:15:51,759
evaluates the circuit in a gate by gate

387
00:15:51,759 --> 00:15:55,839
manner on secret shared inputs

388
00:15:56,720 --> 00:15:59,040
in more detail the parties start by

389
00:15:59,040 --> 00:16:01,120
secret sharing their inputs using a

390
00:16:01,120 --> 00:16:04,399
threshold secret sharing scheme

391
00:16:04,399 --> 00:16:06,839
then for the edition gates the parties

392
00:16:06,839 --> 00:16:09,920
simply locally add their shares and for

393
00:16:09,920 --> 00:16:12,560
multiplication gates they first locally

394
00:16:12,560 --> 00:16:14,560
multiply their shares

395
00:16:14,560 --> 00:16:15,360
then

396
00:16:15,360 --> 00:16:18,160
reshare these locally evaluated shares

397
00:16:18,160 --> 00:16:20,560
using a lower degree polynomial

398
00:16:20,560 --> 00:16:22,720
exchange these shares of shares with all

399
00:16:22,720 --> 00:16:24,240
of the parties

400
00:16:24,240 --> 00:16:26,399
and finally reconstruct the relevant

401
00:16:26,399 --> 00:16:28,720
shares for the outgoing wire of this

402
00:16:28,720 --> 00:16:31,440
multiplication gate

403
00:16:31,440 --> 00:16:33,759
for the final output gate the parties

404
00:16:33,759 --> 00:16:36,720
review their local shares for the output

405
00:16:36,720 --> 00:16:41,759
wires and then reconstruct the output

406
00:16:42,320 --> 00:16:45,120
our main observation here is that this

407
00:16:45,120 --> 00:16:47,759
protocol is quite amenable to the fluid

408
00:16:47,759 --> 00:16:50,160
npc setting

409
00:16:50,160 --> 00:16:52,880
in particular consider an input phase

410
00:16:52,880 --> 00:16:54,880
where the clients secret share their

411
00:16:54,880 --> 00:16:58,399
inputs with the first committee

412
00:16:58,399 --> 00:17:01,839
now the execution stage proceeds

413
00:17:01,839 --> 00:17:03,600
in different layers

414
00:17:03,600 --> 00:17:06,799
in particular committee i is responsible

415
00:17:06,799 --> 00:17:09,599
for computing or evaluating layer i of

416
00:17:09,599 --> 00:17:11,919
the circuit

417
00:17:11,919 --> 00:17:13,760
more specifically

418
00:17:13,760 --> 00:17:16,480
after the input phase the parties in the

419
00:17:16,480 --> 00:17:19,359
first committee locally compute on their

420
00:17:19,359 --> 00:17:22,079
respective shares depending on the gate

421
00:17:22,079 --> 00:17:23,199
in the layer

422
00:17:23,199 --> 00:17:25,439
they then compute shares of these

423
00:17:25,439 --> 00:17:28,240
locally evaluated shares for both the

424
00:17:28,240 --> 00:17:30,400
addition gates and the multiplication

425
00:17:30,400 --> 00:17:32,320
gates

426
00:17:32,320 --> 00:17:34,480
they then exchange these shares of

427
00:17:34,480 --> 00:17:37,039
shares in the hand-off phase with the

428
00:17:37,039 --> 00:17:39,360
next committee

429
00:17:39,360 --> 00:17:41,760
and now the next committee starts by

430
00:17:41,760 --> 00:17:45,520
first extracting the relevant shares

431
00:17:45,520 --> 00:17:47,520
from these shares of shares received

432
00:17:47,520 --> 00:17:49,039
from the previous committee in the hand

433
00:17:49,039 --> 00:17:50,080
office

434
00:17:50,080 --> 00:17:52,480
and then compute on them to evaluate the

435
00:17:52,480 --> 00:17:54,240
next layer

436
00:17:54,240 --> 00:17:56,640
and so on

437
00:17:56,640 --> 00:17:59,360
finally for the output phase the last

438
00:17:59,360 --> 00:18:02,000
committee simply sends

439
00:18:02,000 --> 00:18:04,720
the shares of the output wires to the

440
00:18:04,720 --> 00:18:07,120
clients who can then reconstruct the

441
00:18:07,120 --> 00:18:08,960
output

442
00:18:08,960 --> 00:18:12,080
note that here in the computation phase

443
00:18:12,080 --> 00:18:14,320
we do not require the parties to

444
00:18:14,320 --> 00:18:16,320
communicate at all

445
00:18:16,320 --> 00:18:19,280
moreover the handoff phase is also

446
00:18:19,280 --> 00:18:20,080
uh

447
00:18:20,080 --> 00:18:22,559
only one round log

448
00:18:22,559 --> 00:18:25,200
also the committee is here each

449
00:18:25,200 --> 00:18:27,280
committee here is only doing work

450
00:18:27,280 --> 00:18:29,520
proportional to the width of the circuit

451
00:18:29,520 --> 00:18:32,080
and is independent of the depth

452
00:18:32,080 --> 00:18:34,640
therefore it's easy to see that this

453
00:18:34,640 --> 00:18:38,080
protocol satisfies both division of work

454
00:18:38,080 --> 00:18:41,799
and maximal fluidity

455
00:18:42,640 --> 00:18:45,600
next for our maliciously secure protocol

456
00:18:45,600 --> 00:18:48,640
we present a compiler that transforms

457
00:18:48,640 --> 00:18:51,919
certain semi-honest protocols including

458
00:18:51,919 --> 00:18:54,720
uh the fluid bgw protocol that i just

459
00:18:54,720 --> 00:18:57,200
mentioned into a maliciously secure

460
00:18:57,200 --> 00:18:58,320
protocol

461
00:18:58,320 --> 00:19:00,320
and this resulting maliciously secure

462
00:19:00,320 --> 00:19:03,440
protocol achieves security with the part

463
00:19:03,440 --> 00:19:05,919
and has the same level of fluidity as

464
00:19:05,919 --> 00:19:09,120
the underlying semi-honest protocol

465
00:19:09,120 --> 00:19:11,200
we also provide an implementation of our

466
00:19:11,200 --> 00:19:13,360
maliciously secure protocol based on

467
00:19:13,360 --> 00:19:14,640
semi honest

468
00:19:14,640 --> 00:19:18,240
uh fluid phw

469
00:19:18,640 --> 00:19:22,720
uh i will now discuss this compiler in

470
00:19:22,720 --> 00:19:25,520
we start by examining the approach used

471
00:19:25,520 --> 00:19:28,799
in modern efficient npc protocols

472
00:19:28,799 --> 00:19:30,880
and we notice that most of these

473
00:19:30,880 --> 00:19:33,760
protocols rely on an observation made by

474
00:19:33,760 --> 00:19:36,960
genkin at all who showed that most

475
00:19:36,960 --> 00:19:38,880
secret sharing based semi-honest

476
00:19:38,880 --> 00:19:40,080
protocols

477
00:19:40,080 --> 00:19:42,240
are actually secure against malicious

478
00:19:42,240 --> 00:19:45,679
adversaries up to additive attacks

479
00:19:45,679 --> 00:19:47,760
meaning that the attack strategy of a

480
00:19:47,760 --> 00:19:50,559
malicious adversary in these protocols

481
00:19:50,559 --> 00:19:53,039
is restricted to just injecting

482
00:19:53,039 --> 00:19:55,120
arbitrary additive errors on

483
00:19:55,120 --> 00:19:57,200
intermediate wire values

484
00:19:57,200 --> 00:19:59,760
and these additive errors

485
00:19:59,760 --> 00:20:02,159
are actually independent of the actual

486
00:20:02,159 --> 00:20:05,480
wire values

487
00:20:06,400 --> 00:20:09,039
most recent efficient mpc protocols

488
00:20:09,039 --> 00:20:11,840
exploit this idea by running two

489
00:20:11,840 --> 00:20:14,720
parallel executions of such semi-honest

490
00:20:14,720 --> 00:20:17,120
protocols

491
00:20:17,120 --> 00:20:19,280
one of the executions is on the actual

492
00:20:19,280 --> 00:20:20,799
inputs and the other one is on

493
00:20:20,799 --> 00:20:24,480
randomized inputs is shown on this line

494
00:20:24,480 --> 00:20:26,400
at the end of the protocol before the

495
00:20:26,400 --> 00:20:28,559
outputs are revealed to the parties a

496
00:20:28,559 --> 00:20:30,480
correctness check is performed by

497
00:20:30,480 --> 00:20:33,280
comparing a random linear combination

498
00:20:33,280 --> 00:20:35,840
of the intermediate values in the two

499
00:20:35,840 --> 00:20:38,639
executions

500
00:20:39,760 --> 00:20:42,000
what we now want to explore is whether

501
00:20:42,000 --> 00:20:44,799
we can use the similar strategy in the

502
00:20:44,799 --> 00:20:47,440
fluid npc setting as well to get a

503
00:20:47,440 --> 00:20:49,919
maliciously secure protocol by

504
00:20:49,919 --> 00:20:53,840
transforming fluid phw

505
00:20:54,400 --> 00:20:56,640
and we observe that this paradigm does

506
00:20:56,640 --> 00:20:59,360
indeed extend in a natural way to the

507
00:20:59,360 --> 00:21:01,600
fluid mpc setting

508
00:21:01,600 --> 00:21:04,640
and in fact most secret sharing based

509
00:21:04,640 --> 00:21:08,320
semi honest fluid fbc protocols

510
00:21:08,320 --> 00:21:10,320
are likely to be secured against

511
00:21:10,320 --> 00:21:12,240
malicious adversaries up to additive

512
00:21:12,240 --> 00:21:15,240
attacks

513
00:21:16,000 --> 00:21:18,240
now let us try to see if known

514
00:21:18,240 --> 00:21:20,720
techniques in this paradigm

515
00:21:20,720 --> 00:21:23,280
can work in the fluid mpc setting as it

516
00:21:23,280 --> 00:21:25,440
is

517
00:21:26,000 --> 00:21:27,919
so the first

518
00:21:27,919 --> 00:21:29,840
case that we consider is if the linear

519
00:21:29,840 --> 00:21:33,520
combination is computed at the very end

520
00:21:33,520 --> 00:21:35,760
but in this case uh all of the

521
00:21:35,760 --> 00:21:37,919
intermediate wire values will have to be

522
00:21:37,919 --> 00:21:39,679
passed along across all of the

523
00:21:39,679 --> 00:21:40,880
committees

524
00:21:40,880 --> 00:21:43,919
until the very end

525
00:21:44,159 --> 00:21:46,159
and therefore we won't be able to get

526
00:21:46,159 --> 00:21:48,799
division of work

527
00:21:48,799 --> 00:21:51,200
on the other hand if we try to compute

528
00:21:51,200 --> 00:21:53,600
the linear combination in an incremental

529
00:21:53,600 --> 00:21:54,480
way

530
00:21:54,480 --> 00:21:57,039
that is by combining

531
00:21:57,039 --> 00:21:59,679
all of the values of a given layer and

532
00:21:59,679 --> 00:22:01,679
only passing along this partially

533
00:22:01,679 --> 00:22:03,520
computed value

534
00:22:03,520 --> 00:22:05,360
then we would have to find a way to

535
00:22:05,360 --> 00:22:07,360
generate these alpha values that are

536
00:22:07,360 --> 00:22:09,600
used in the linear combination on the

537
00:22:09,600 --> 00:22:10,799
fly

538
00:22:10,799 --> 00:22:13,919
and generating these alpha values

539
00:22:13,919 --> 00:22:16,640
could take more than one rounds which

540
00:22:16,640 --> 00:22:20,640
could hamper maximum fluidity

541
00:22:20,720 --> 00:22:22,960
we resolve this problem using a simple

542
00:22:22,960 --> 00:22:24,240
idea

543
00:22:24,240 --> 00:22:25,760
let's say this is the circuit that we

544
00:22:25,760 --> 00:22:27,679
want to compute

545
00:22:27,679 --> 00:22:29,679
now at the time of secret sharing their

546
00:22:29,679 --> 00:22:32,080
inputs with the first committee we

547
00:22:32,080 --> 00:22:35,039
require the clients to also secret share

548
00:22:35,039 --> 00:22:36,799
random values

549
00:22:36,799 --> 00:22:40,960
beta and alpha 1 to alpha w where w is

550
00:22:40,960 --> 00:22:44,000
the width of the circuit

551
00:22:44,000 --> 00:22:46,240
now when the first committee computes

552
00:22:46,240 --> 00:22:50,159
the first layer in the dual executions

553
00:22:50,159 --> 00:22:52,799
they also additionally multiply beta

554
00:22:52,799 --> 00:22:55,200
with itself and with each of the alpha

555
00:22:55,200 --> 00:22:57,039
values

556
00:22:57,039 --> 00:22:59,039
similarly the next committee will

557
00:22:59,039 --> 00:23:01,600
additionally multiply beta with all of

558
00:23:01,600 --> 00:23:05,679
the previously computed random values

559
00:23:05,679 --> 00:23:07,520
these values will then be used to

560
00:23:07,520 --> 00:23:10,000
compute the linear combination in an

561
00:23:10,000 --> 00:23:12,559
incremental manner

562
00:23:12,559 --> 00:23:15,280
in particular the first committee simply

563
00:23:15,280 --> 00:23:17,679
sets the partial linear combination to

564
00:23:17,679 --> 00:23:18,559
zero

565
00:23:18,559 --> 00:23:20,480
since no values have been computed so

566
00:23:20,480 --> 00:23:22,400
far

567
00:23:22,400 --> 00:23:24,880
the next committee will compute this

568
00:23:24,880 --> 00:23:27,120
partial linear combination

569
00:23:27,120 --> 00:23:30,080
by multiplying alpha 1 beta with the

570
00:23:30,080 --> 00:23:32,080
first value

571
00:23:32,080 --> 00:23:34,320
alpha 2 beta with the second value and

572
00:23:34,320 --> 00:23:35,360
so on

573
00:23:35,360 --> 00:23:37,760
and add these to the previously computed

574
00:23:37,760 --> 00:23:39,919
partial linear combination

575
00:23:39,919 --> 00:23:42,000
and similarly the parties will compute

576
00:23:42,000 --> 00:23:44,720
another linear combination using the

577
00:23:44,720 --> 00:23:46,880
same alpha beta values

578
00:23:46,880 --> 00:23:48,480
and

579
00:23:48,480 --> 00:23:51,919
the values induced on the circuit from

580
00:23:51,919 --> 00:23:54,320
the other parallel execution that is run

581
00:23:54,320 --> 00:23:56,960
on randomized inputs

582
00:23:56,960 --> 00:23:59,360
finally the clients can compare the two

583
00:23:59,360 --> 00:24:01,279
linear combinations before

584
00:24:01,279 --> 00:24:05,320
reconstructing the actual

585
00:24:06,320 --> 00:24:08,159
note that each of these additional

586
00:24:08,159 --> 00:24:10,559
computations are done in parallel with

587
00:24:10,559 --> 00:24:12,400
the dual executions

588
00:24:12,400 --> 00:24:14,880
and hence if the underlying semi honest

589
00:24:14,880 --> 00:24:18,400
mpc has maximum fluidity so will the

590
00:24:18,400 --> 00:24:22,080
resulting maliciously secured.com

591
00:24:22,080 --> 00:24:24,480
moreover the parties in the solution

592
00:24:24,480 --> 00:24:27,039
still only do work that is proportional

593
00:24:27,039 --> 00:24:29,200
to the width of the circuit and doesn't

594
00:24:29,200 --> 00:24:31,279
depend on the depth and hence this

595
00:24:31,279 --> 00:24:36,159
protocol also supports division of work

596
00:24:37,360 --> 00:24:39,520
finally to summarize we present the

597
00:24:39,520 --> 00:24:42,080
first formal model for mpc with dynamic

598
00:24:42,080 --> 00:24:43,440
participants

599
00:24:43,440 --> 00:24:45,760
we also present constructions for

600
00:24:45,760 --> 00:24:47,600
semi-honest and maliciously secure

601
00:24:47,600 --> 00:24:49,760
protocols in this model

602
00:24:49,760 --> 00:24:52,159
and implement our maliciously secure

603
00:24:52,159 --> 00:24:53,200
protocol

604
00:24:53,200 --> 00:24:55,120
however these are only baseline

605
00:24:55,120 --> 00:24:57,360
solutions and there are many interesting

606
00:24:57,360 --> 00:25:02,959
open problems in this area thank you

