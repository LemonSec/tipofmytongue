1
00:00:03,840 --> 00:00:06,560
you're ready to go have a good session

2
00:00:06,560 --> 00:00:08,160
hi okay

3
00:00:08,160 --> 00:00:10,559
so hi everyone welcome

4
00:00:10,559 --> 00:00:12,799
to this uh secret sharing session on

5
00:00:12,799 --> 00:00:14,719
thursday

6
00:00:14,719 --> 00:00:16,800
and the first talk

7
00:00:16,800 --> 00:00:19,279
is by odenir and benny applebaum about

8
00:00:19,279 --> 00:00:21,359
up slices down slices and sticker

9
00:00:21,359 --> 00:00:26,240
sharing with complexity of 1.5 to the n

10
00:00:27,439 --> 00:00:28,800
thank you

11
00:00:28,800 --> 00:00:32,160
so do you see my screen

12
00:00:32,880 --> 00:00:33,680
yes

13
00:00:33,680 --> 00:00:35,680
yeah okay excellent

14
00:00:35,680 --> 00:00:36,800
so

15
00:00:36,800 --> 00:00:38,719
this is joint work with the dead neil

16
00:00:38,719 --> 00:00:41,120
and my talented student and i urge you

17
00:00:41,120 --> 00:00:42,960
all to watch the

18
00:00:42,960 --> 00:00:44,719
full version of this stock that today is

19
00:00:44,719 --> 00:00:47,039
recorded

20
00:00:47,039 --> 00:00:49,360
so

21
00:00:49,920 --> 00:00:52,079
what's my content okay

22
00:00:52,079 --> 00:00:53,520
so we're going to talk about the secret

23
00:00:53,520 --> 00:00:55,280
sharing schemes which are basically a

24
00:00:55,280 --> 00:00:58,559
distributed analog of encryption skins

25
00:00:58,559 --> 00:01:00,079
so in the general version of this

26
00:01:00,079 --> 00:01:02,559
problem we have a dealer who holds a

27
00:01:02,559 --> 00:01:04,959
secret s and n parties or in servers if

28
00:01:04,959 --> 00:01:06,159
you want

29
00:01:06,159 --> 00:01:08,159
and they were given a list a of the

30
00:01:08,159 --> 00:01:10,560
authorized and amateurised collisions

31
00:01:10,560 --> 00:01:12,479
and the goal is to take this secret and

32
00:01:12,479 --> 00:01:13,360
to

33
00:01:13,360 --> 00:01:16,159
distribute it into shells s1 up to sn

34
00:01:16,159 --> 00:01:18,080
such that authorized coalitions can

35
00:01:18,080 --> 00:01:19,680
recover the secret and unauthorized

36
00:01:19,680 --> 00:01:21,040
coalitions learn nothing about the

37
00:01:21,040 --> 00:01:22,799
secret in an information theoretical

38
00:01:22,799 --> 00:01:24,799
sense

39
00:01:24,799 --> 00:01:27,119
and the basic complexity measure is the

40
00:01:27,119 --> 00:01:28,799
total bit length of the shell so we

41
00:01:28,799 --> 00:01:30,320
think about the secret as being a single

42
00:01:30,320 --> 00:01:32,400
bit secret and the goal is to realize a

43
00:01:32,400 --> 00:01:35,520
with the minimum total share size

44
00:01:35,520 --> 00:01:37,280
and it's a very

45
00:01:37,280 --> 00:01:40,000
famous and well known open problem in

46
00:01:40,000 --> 00:01:41,520
information theory cryptography to

47
00:01:41,520 --> 00:01:43,119
understand what is the best achievable

48
00:01:43,119 --> 00:01:45,040
share size for general end party access

49
00:01:45,040 --> 00:01:46,079
structure

50
00:01:46,079 --> 00:01:47,600
so let me tell you what's known about

51
00:01:47,600 --> 00:01:50,159
this problem so since the late 80s we

52
00:01:50,159 --> 00:01:51,520
know that this problem can be solved

53
00:01:51,520 --> 00:01:53,280
with complexity roughly 2 to the n where

54
00:01:53,280 --> 00:01:55,200
n is the number of parties

55
00:01:55,200 --> 00:01:57,200
and we have a lower bound which says

56
00:01:57,200 --> 00:01:59,040
that essentially the complexity is n

57
00:01:59,040 --> 00:02:00,960
squared this is due to summers

58
00:02:00,960 --> 00:02:03,920
the upper bound was due to a intuitive

59
00:02:03,920 --> 00:02:05,920
and for a while this was the state of

60
00:02:05,920 --> 00:02:06,960
the arts

61
00:02:06,960 --> 00:02:08,639
until a few years ago

62
00:02:08,639 --> 00:02:10,639
chambray and vinod they showed us that

63
00:02:10,639 --> 00:02:13,040
this can actually be improved

64
00:02:13,040 --> 00:02:14,800
and the exponent can be brought down

65
00:02:14,800 --> 00:02:16,400
slightly below one so you can see the

66
00:02:16,400 --> 00:02:18,400
exponential is slightly is a constant

67
00:02:18,400 --> 00:02:20,319
which is slightly smaller than one

68
00:02:20,319 --> 00:02:21,599
and following this result there were

69
00:02:21,599 --> 00:02:23,599
several other improvements

70
00:02:23,599 --> 00:02:25,520
and in this paper we continued this line

71
00:02:25,520 --> 00:02:28,000
of uh research and then we proved the

72
00:02:28,000 --> 00:02:31,440
exponent down below 0.6 and in fact

73
00:02:31,440 --> 00:02:33,760
there's a nice bonus we have a this

74
00:02:33,760 --> 00:02:35,599
constant has actually a very nice form

75
00:02:35,599 --> 00:02:38,319
this is 1.5 to the power of n

76
00:02:38,319 --> 00:02:42,879
so this is an actual a complexity point

77
00:02:42,879 --> 00:02:44,800
we also study the case of the linear

78
00:02:44,800 --> 00:02:47,120
signal sharing skins so in this setting

79
00:02:47,120 --> 00:02:50,160
the um the sharing function of the data

80
00:02:50,160 --> 00:02:53,120
is a linear function say over gf2

81
00:02:53,120 --> 00:02:55,200
and then the picture is a somewhat

82
00:02:55,200 --> 00:02:56,959
similar so again the

83
00:02:56,959 --> 00:02:59,040
uh current v node were able to improve

84
00:02:59,040 --> 00:03:02,480
the a trivial two to the n low bound

85
00:03:02,480 --> 00:03:03,680
upper bound

86
00:03:03,680 --> 00:03:04,720
slightly

87
00:03:04,720 --> 00:03:07,200
to 0.999

88
00:03:07,200 --> 00:03:08,400
and following this result there were

89
00:03:08,400 --> 00:03:10,720
several improvements and in this work we

90
00:03:10,720 --> 00:03:13,120
get an additional minor improvement and

91
00:03:13,120 --> 00:03:14,800
we can get down there we can reduce the

92
00:03:14,800 --> 00:03:17,360
exponent almost to three quarters

93
00:03:17,360 --> 00:03:19,280
and here i should say that uh the gap

94
00:03:19,280 --> 00:03:20,959
between the upper bound the normal is

95
00:03:20,959 --> 00:03:22,560
not that large because we have a lower

96
00:03:22,560 --> 00:03:25,120
boundary of two today n over two so we

97
00:03:25,120 --> 00:03:26,720
know that the exponent cannot be uh

98
00:03:26,720 --> 00:03:29,200
below a half

99
00:03:29,200 --> 00:03:30,000
good

100
00:03:30,000 --> 00:03:31,280
so

101
00:03:31,280 --> 00:03:33,519
a few words about uh

102
00:03:33,519 --> 00:03:36,720
the nine ideas so

103
00:03:37,040 --> 00:03:39,200
in a very high level uh the difference

104
00:03:39,200 --> 00:03:41,200
between our work in previous ones is

105
00:03:41,200 --> 00:03:43,040
that we focus on

106
00:03:43,040 --> 00:03:44,959
what we call up slices and down slices

107
00:03:44,959 --> 00:03:46,400
access structure

108
00:03:46,400 --> 00:03:48,000
so let me explain what these success

109
00:03:48,000 --> 00:03:49,440
structures are

110
00:03:49,440 --> 00:03:52,080
so um first let's order the sets in a

111
00:03:52,080 --> 00:03:54,239
lattice where the empty set is in the

112
00:03:54,239 --> 00:03:55,680
bottom and

113
00:03:55,680 --> 00:03:57,920
the set of all parties on this on top

114
00:03:57,920 --> 00:04:00,080
okay and okay up slice a access

115
00:04:00,080 --> 00:04:01,840
structure is the following form

116
00:04:01,840 --> 00:04:03,439
so in level k

117
00:04:03,439 --> 00:04:04,560
i'm allowing

118
00:04:04,560 --> 00:04:06,319
sets to take arbitrary values so they

119
00:04:06,319 --> 00:04:07,840
can be authorized or unauthorized you're

120
00:04:07,840 --> 00:04:09,840
allowed to specify exactly the structure

121
00:04:09,840 --> 00:04:10,720
here

122
00:04:10,720 --> 00:04:12,640
okay no constraints

123
00:04:12,640 --> 00:04:15,040
below right smaller sets are

124
00:04:15,040 --> 00:04:17,279
unauthorized

125
00:04:17,279 --> 00:04:19,040
and larger sets

126
00:04:19,040 --> 00:04:20,320
well there are otherwise only if they

127
00:04:20,320 --> 00:04:22,639
have to what do i mean by this so if i'm

128
00:04:22,639 --> 00:04:24,320
looking at the set here

129
00:04:24,320 --> 00:04:25,600
i'm going to define that it is

130
00:04:25,600 --> 00:04:28,000
authorized only if it is a superset of

131
00:04:28,000 --> 00:04:30,720
an authorized set of size key

132
00:04:30,720 --> 00:04:32,080
okay otherwise i'm going to put here

133
00:04:32,080 --> 00:04:33,440
like i'm going to say that the set is

134
00:04:33,440 --> 00:04:34,880
unauthorized

135
00:04:34,880 --> 00:04:36,320
and if you think about it a little bit

136
00:04:36,320 --> 00:04:37,520
you'll see that this is equivalent to

137
00:04:37,520 --> 00:04:39,680
mono to kdnf where all the min terms are

138
00:04:39,680 --> 00:04:40,840
of size

139
00:04:40,840 --> 00:04:43,759
exactly so these are app slices and we

140
00:04:43,759 --> 00:04:46,000
also consider the dual version of this

141
00:04:46,000 --> 00:04:47,440
thing which are down slices and they

142
00:04:47,440 --> 00:04:50,320
correspond to cnfs

143
00:04:50,320 --> 00:04:52,080
and

144
00:04:52,080 --> 00:04:54,840
what we show in our work is that

145
00:04:54,840 --> 00:04:57,600
first we can realize up slices and down

146
00:04:57,600 --> 00:04:59,919
slices with the complexity that they

147
00:04:59,919 --> 00:05:01,759
showed you in the previous slides and

148
00:05:01,759 --> 00:05:04,080
second and this is actually an easy step

149
00:05:04,080 --> 00:05:05,840
general secret sharing can be reduced

150
00:05:05,840 --> 00:05:07,840
easily to up slices and down slices then

151
00:05:07,840 --> 00:05:09,759
you can glue together up slices you know

152
00:05:09,759 --> 00:05:11,919
to generally realize the general

153
00:05:11,919 --> 00:05:13,520
signature in scheme

154
00:05:13,520 --> 00:05:16,080
uh with relatively low cost

155
00:05:16,080 --> 00:05:17,600
so as i said the first step is the

156
00:05:17,600 --> 00:05:20,320
non-trivial part and here we this is

157
00:05:20,320 --> 00:05:21,919
expensive like this is where the

158
00:05:21,919 --> 00:05:24,080
exponential complexity goes to and for

159
00:05:24,080 --> 00:05:25,520
this we explored previous tools and

160
00:05:25,520 --> 00:05:27,199
introduced new ones

161
00:05:27,199 --> 00:05:28,960
and the second step is really trivial

162
00:05:28,960 --> 00:05:30,560
and very cheap

163
00:05:30,560 --> 00:05:32,880
and it's interesting to compare this

164
00:05:32,880 --> 00:05:34,880
outline to previous works that were

165
00:05:34,880 --> 00:05:36,880
based on basically slices okay this is

166
00:05:36,880 --> 00:05:38,800
how slices look like

167
00:05:38,800 --> 00:05:41,280
and in this

168
00:05:41,759 --> 00:05:43,680
in in the previous frameworks basically

169
00:05:43,680 --> 00:05:44,479
these

170
00:05:44,479 --> 00:05:46,639
slices were cheap to realize

171
00:05:46,639 --> 00:05:49,360
based on work of geranium vinod and the

172
00:05:49,360 --> 00:05:50,320
queen

173
00:05:50,320 --> 00:05:52,080
but actually are hard to glue together

174
00:05:52,080 --> 00:05:54,880
so this is exactly the opposite case

175
00:05:54,880 --> 00:05:58,560
compared to the current approach

176
00:05:59,919 --> 00:06:03,360
some other results in the paper so

177
00:06:03,360 --> 00:06:05,039
we look at the random app slices and the

178
00:06:05,039 --> 00:06:06,160
reason is that there was a very

179
00:06:06,160 --> 00:06:08,800
intriguing result from last year by a a

180
00:06:08,800 --> 00:06:10,880
by man and fuss who shows that

181
00:06:10,880 --> 00:06:12,240
a random access structure are actually

182
00:06:12,240 --> 00:06:14,080
very cheap they have a sub exponential

183
00:06:14,080 --> 00:06:15,600
cost and the reason is that if you

184
00:06:15,600 --> 00:06:16,960
choose a random

185
00:06:16,960 --> 00:06:18,800
access structure it looks very similar

186
00:06:18,800 --> 00:06:20,880
to a slice function and we said that

187
00:06:20,880 --> 00:06:23,039
this is easy

188
00:06:23,039 --> 00:06:25,120
so we ask is it also true for random

189
00:06:25,120 --> 00:06:27,039
abstices or random dnfs if you want so

190
00:06:27,039 --> 00:06:28,960
we study several natural distribution of

191
00:06:28,960 --> 00:06:30,639
okay up slashes i'm not going to define

192
00:06:30,639 --> 00:06:31,600
it here

193
00:06:31,600 --> 00:06:32,960
and we show the following results so

194
00:06:32,960 --> 00:06:34,400
first we showed that at least given

195
00:06:34,400 --> 00:06:36,160
current techniques we don't know how to

196
00:06:36,160 --> 00:06:37,440
uh

197
00:06:37,440 --> 00:06:38,639
realize this

198
00:06:38,639 --> 00:06:40,160
access structure with sub-exponential

199
00:06:40,160 --> 00:06:42,479
complexity so this gives us the first

200
00:06:42,479 --> 00:06:44,080
candidate distribution for exponentially

201
00:06:44,080 --> 00:06:47,120
how signaturing scheme

202
00:06:47,120 --> 00:06:48,800
nevertheless we can show some

203
00:06:48,800 --> 00:06:50,800
improvement compared to the worst case

204
00:06:50,800 --> 00:06:52,479
so still we have exponential gaps

205
00:06:52,479 --> 00:06:54,000
between the versus complexity and the

206
00:06:54,000 --> 00:06:56,319
evolution of complexity and for this we

207
00:06:56,319 --> 00:06:58,240
actually generalize an approach that was

208
00:06:58,240 --> 00:07:01,280
a a again used by bamilan first for

209
00:07:01,280 --> 00:07:02,400
constant

210
00:07:02,400 --> 00:07:05,120
case so for very low levels

211
00:07:05,120 --> 00:07:08,319
of up slices and then since they use

212
00:07:08,319 --> 00:07:10,639
constant case they only got a polynomial

213
00:07:10,639 --> 00:07:12,880
gaps but we use linear case and

214
00:07:12,880 --> 00:07:16,560
therefore we get exponential gaps

215
00:07:16,560 --> 00:07:18,960
so now you can ask is this regular

216
00:07:18,960 --> 00:07:21,280
gateway right i mean so this is the gap

217
00:07:21,280 --> 00:07:24,318
between the best known

218
00:07:25,599 --> 00:07:27,599
constructions but maybe you know the

219
00:07:27,599 --> 00:07:29,520
personal construction do not reflect the

220
00:07:29,520 --> 00:07:31,520
true picture so of course we cannot

221
00:07:31,520 --> 00:07:32,960
prove that this gap is real because we

222
00:07:32,960 --> 00:07:34,639
don't know how to prove a exponential

223
00:07:34,639 --> 00:07:36,639
low bounce for signaturing

224
00:07:36,639 --> 00:07:38,080
but what we can show is the following

225
00:07:38,080 --> 00:07:39,919
interesting result

226
00:07:39,919 --> 00:07:41,440
we can prove unconditionally a gap

227
00:07:41,440 --> 00:07:43,120
theorem that says that there exists an

228
00:07:43,120 --> 00:07:45,199
exponential gap in at least one of the

229
00:07:45,199 --> 00:07:47,599
following cases so either there's a gap

230
00:07:47,599 --> 00:07:48,960
between this world's case and the

231
00:07:48,960 --> 00:07:51,840
average case say up slices right towards

232
00:07:51,840 --> 00:07:55,120
case dnf vessels random dnfs or those

233
00:07:55,120 --> 00:07:56,720
those this an exponential gap between

234
00:07:56,720 --> 00:07:59,199
access structure and their duals

235
00:07:59,199 --> 00:08:00,800
okay and this is an

236
00:08:00,800 --> 00:08:02,560
interesting open problem whether they do

237
00:08:02,560 --> 00:08:04,160
our equivalent this is a well-known

238
00:08:04,160 --> 00:08:06,960
problem or the existing exponential gap

239
00:08:06,960 --> 00:08:08,240
between linear signature and the

240
00:08:08,240 --> 00:08:10,400
non-linear sql sharing and did i mean

241
00:08:10,400 --> 00:08:11,840
that when i say exponential gap i mean

242
00:08:11,840 --> 00:08:14,639
that only keeps signature and can go be

243
00:08:14,639 --> 00:08:17,199
below this exponent of half

244
00:08:17,199 --> 00:08:18,720
namely that every function can be

245
00:08:18,720 --> 00:08:20,639
realized with an exponent which is two

246
00:08:20,639 --> 00:08:22,400
to the alpha n for some alphas one of

247
00:08:22,400 --> 00:08:23,520
them

248
00:08:23,520 --> 00:08:25,199
so we don't know how to prove any of

249
00:08:25,199 --> 00:08:27,039
these separations individually but we

250
00:08:27,039 --> 00:08:30,318
know that at least one of the imports

251
00:08:31,120 --> 00:08:32,799
so to conclude

252
00:08:32,799 --> 00:08:33,839
so

253
00:08:33,839 --> 00:08:35,679
we look at upslices downslices this

254
00:08:35,679 --> 00:08:37,519
seems to be like a useful and very

255
00:08:37,519 --> 00:08:39,519
natural families of the access structure

256
00:08:39,519 --> 00:08:42,240
that deserve a further study

257
00:08:42,240 --> 00:08:44,800
this is the new state of the art

258
00:08:44,800 --> 00:08:46,640
one point half to the end versus the

259
00:08:46,640 --> 00:08:48,880
quadratic still a huge gap and the

260
00:08:48,880 --> 00:08:50,560
obviously open problem is to try and

261
00:08:50,560 --> 00:08:52,480
narrow this game

262
00:08:52,480 --> 00:08:56,080
thank you okay thank you very much benny

263
00:08:56,080 --> 00:08:58,720
uh let's uh

264
00:08:58,720 --> 00:09:00,800
let's oh i guess it does not work

265
00:09:00,800 --> 00:09:03,440
virtually okay let's make the and so

266
00:09:03,440 --> 00:09:06,320
let's go to the next talk because we i

267
00:09:06,320 --> 00:09:10,240
don't think we have time for question so

268
00:09:10,240 --> 00:09:13,040
let's immediately go to the next talk uh

269
00:09:13,040 --> 00:09:15,279
the next talk is by uh ronald cramer

270
00:09:15,279 --> 00:09:18,240
matteo rambo and chow ping sheng

271
00:09:18,240 --> 00:09:21,839
and the title is asymptotic

272
00:09:21,839 --> 00:09:24,720
good arithmetic secret sharing of zp

273
00:09:24,720 --> 00:09:25,760
l

274
00:09:25,760 --> 00:09:27,920
over zip with strong multiplication and

275
00:09:27,920 --> 00:09:31,680
its application to efficient mpc

276
00:09:33,760 --> 00:09:35,519
wait if

277
00:09:35,519 --> 00:09:39,360
wait is there anyone here ronald cameron

278
00:09:39,360 --> 00:09:41,760
ciao

279
00:09:43,519 --> 00:09:46,000
oh oh

280
00:09:46,560 --> 00:09:49,120
oh i see material okay if anyone has a

281
00:09:49,120 --> 00:09:51,600
question why martial rumble is preparing

282
00:09:51,600 --> 00:09:53,040
to talk

283
00:09:53,040 --> 00:09:57,120
please ask in a zulip or in the chat

284
00:09:57,120 --> 00:10:00,839
or raise your hand

285
00:10:39,680 --> 00:10:41,680
i think you're muted i don't know if you

286
00:10:41,680 --> 00:10:44,920
want to

287
00:10:46,240 --> 00:10:48,800
oh okay

288
00:10:50,800 --> 00:10:53,920
uh matthew your um sound is not actually

289
00:10:53,920 --> 00:10:55,600
coming through it says you're unmuted

290
00:10:55,600 --> 00:11:00,200
but it does not appear to be working

291
00:11:04,720 --> 00:11:08,800
you may need to log out and log back in

292
00:11:11,519 --> 00:11:14,320
and fabrice if you wanted to move on to

293
00:11:14,320 --> 00:11:16,800
the next talk and then matthieu can

294
00:11:16,800 --> 00:11:19,200
maybe figure out sound issues

295
00:11:19,200 --> 00:11:20,480
okay okay

296
00:11:20,480 --> 00:11:22,880
it's okay

297
00:11:24,560 --> 00:11:27,600
oh the song is not really good

298
00:11:27,600 --> 00:11:29,120
okay

299
00:11:29,120 --> 00:11:31,360
okay let's move to the next talk uh if

300
00:11:31,360 --> 00:11:33,440
you can try to find better headphones or

301
00:11:33,440 --> 00:11:36,399
better the sound is very very bad

302
00:11:36,399 --> 00:11:38,399
uh better either headphone or

303
00:11:38,399 --> 00:11:40,959
speakerphone or something like this

304
00:11:40,959 --> 00:11:43,200
okay so uh

305
00:11:43,200 --> 00:11:45,600
that's back so let's move to the next

306
00:11:45,600 --> 00:11:47,920
talk a large message homomorphic

307
00:11:47,920 --> 00:11:49,920
secretary from uh this you have an

308
00:11:49,920 --> 00:11:51,279
application

309
00:11:51,279 --> 00:11:53,920
and this is a paper by just by thing and

310
00:11:53,920 --> 00:11:56,560
lawrence roy and just by is giving the

311
00:11:56,560 --> 00:11:58,800
talk

312
00:11:59,760 --> 00:12:01,040
sorry to

313
00:12:01,040 --> 00:12:04,160
to switch the program like this

314
00:12:04,160 --> 00:12:05,920
is my screen share

315
00:12:05,920 --> 00:12:07,279
yes perfect

316
00:12:07,279 --> 00:12:08,639
all right

317
00:12:08,639 --> 00:12:10,720
so hi this is jaspal and today i'll be

318
00:12:10,720 --> 00:12:12,720
talking about our recent work on large

319
00:12:12,720 --> 00:12:14,800
message homomorphic secret sharing from

320
00:12:14,800 --> 00:12:17,279
dcr and applications this is a joint

321
00:12:17,279 --> 00:12:19,200
work with lansroy at oregon state

322
00:12:19,200 --> 00:12:21,760
university

323
00:12:22,639 --> 00:12:24,560
uh so let's begin by defining what is

324
00:12:24,560 --> 00:12:25,680
hss

325
00:12:25,680 --> 00:12:27,519
so the traditional definition of one

326
00:12:27,519 --> 00:12:30,800
minus phss consists of three algorithms

327
00:12:30,800 --> 00:12:32,480
the share function is used to secret

328
00:12:32,480 --> 00:12:35,120
share the input x with two parties

329
00:12:35,120 --> 00:12:37,360
each party runs the eval algorithm which

330
00:12:37,360 --> 00:12:39,519
takes as input to shadow of x and it out

331
00:12:39,519 --> 00:12:41,279
and it also takes as input a program

332
00:12:41,279 --> 00:12:43,040
description p

333
00:12:43,040 --> 00:12:44,800
the output of eval is fed into the

334
00:12:44,800 --> 00:12:48,480
decode function which outputs p of x

335
00:12:48,480 --> 00:12:50,800
hss is termed secure if it satisfies

336
00:12:50,800 --> 00:12:52,639
correctness and privacy

337
00:12:52,639 --> 00:12:54,320
correctness ensures that the decode

338
00:12:54,320 --> 00:12:56,320
outputs the correct value p of x with

339
00:12:56,320 --> 00:12:58,560
probability at least 1 minus p

340
00:12:58,560 --> 00:13:01,519
and privacy ensures that each share x i

341
00:13:01,519 --> 00:13:05,040
individually hides the input x

342
00:13:05,040 --> 00:13:06,480
in this work we will consider the

343
00:13:06,480 --> 00:13:08,959
restricted multiplication program or rms

344
00:13:08,959 --> 00:13:11,600
programs as the model of computation

345
00:13:11,600 --> 00:13:13,680
in this model each memory value is

346
00:13:13,680 --> 00:13:15,839
bounded by a parameter m

347
00:13:15,839 --> 00:13:17,120
and it allows for the following

348
00:13:17,120 --> 00:13:18,480
operations

349
00:13:18,480 --> 00:13:20,560
so you can initialize a memory value to

350
00:13:20,560 --> 00:13:23,120
one you can add two memory values you

351
00:13:23,120 --> 00:13:25,440
can multiply a memory value by constant

352
00:13:25,440 --> 00:13:26,959
or you can do a restricted

353
00:13:26,959 --> 00:13:29,200
multiplication that is you can multiply

354
00:13:29,200 --> 00:13:32,560
an input with a memory value

355
00:13:32,560 --> 00:13:35,519
coming to our contributions for hss

356
00:13:35,519 --> 00:13:37,519
so in this work we introduce a new hss

357
00:13:37,519 --> 00:13:39,680
construction with negligible correctness

358
00:13:39,680 --> 00:13:41,920
error p and for exponentially large

359
00:13:41,920 --> 00:13:45,040
message spaces m for rms programs based

360
00:13:45,040 --> 00:13:47,920
on dermacad's uric encryption scheme

361
00:13:47,920 --> 00:13:50,160
an hss that fails with negligible error

362
00:13:50,160 --> 00:13:52,320
was previously only known

363
00:13:52,320 --> 00:13:54,880
to be based on lwe assumptions whereas

364
00:13:54,880 --> 00:13:56,560
our construction is secure assuming the

365
00:13:56,560 --> 00:13:59,199
dcr assumption as well

366
00:13:59,199 --> 00:14:00,480
unlike all previous books our

367
00:14:00,480 --> 00:14:02,160
construction does not rely on any

368
00:14:02,160 --> 00:14:04,079
circular security assumption or on a

369
00:14:04,079 --> 00:14:06,320
circular secure encryption scheme

370
00:14:06,320 --> 00:14:08,079
i will also note that a concurrent work

371
00:14:08,079 --> 00:14:10,399
at eurocrypt 2021 achieved similar

372
00:14:10,399 --> 00:14:11,440
results

373
00:14:11,440 --> 00:14:13,360
but they based their construction on pi

374
00:14:13,360 --> 00:14:15,839
a instead of democrats uric you can find

375
00:14:15,839 --> 00:14:17,440
a more detailed comparisons of our

376
00:14:17,440 --> 00:14:21,120
construction to theirs in our paper

377
00:14:21,519 --> 00:14:23,199
next we'll present a general framework

378
00:14:23,199 --> 00:14:26,399
for the design of hss constructions

379
00:14:26,399 --> 00:14:28,480
so hss is based on the interplay between

380
00:14:28,480 --> 00:14:30,800
two encodings an additively homomorphic

381
00:14:30,800 --> 00:14:32,720
encryption scheme and an additive secret

382
00:14:32,720 --> 00:14:34,000
sharing scheme

383
00:14:34,000 --> 00:14:35,920
encryptions hold the input to the hss

384
00:14:35,920 --> 00:14:36,880
program

385
00:14:36,880 --> 00:14:38,880
hence the share function on input x

386
00:14:38,880 --> 00:14:40,959
outputs the encryption of x to both the

387
00:14:40,959 --> 00:14:42,160
parties

388
00:14:42,160 --> 00:14:44,079
the additive shares represent memory

389
00:14:44,079 --> 00:14:46,480
values of the rms program we say that a

390
00:14:46,480 --> 00:14:48,639
value y is stored in the program if the

391
00:14:48,639 --> 00:14:50,880
parties have additive shares of 5 times

392
00:14:50,880 --> 00:14:53,120
y where 5 is the private key of the

393
00:14:53,120 --> 00:14:54,959
encryption scheme

394
00:14:54,959 --> 00:14:56,959
both are additive homomorphic schemes

395
00:14:56,959 --> 00:14:59,440
hence given encodings of x and y

396
00:14:59,440 --> 00:15:01,760
we can generate encodings of x plus y

397
00:15:01,760 --> 00:15:04,560
and the constant time 6.

398
00:15:04,560 --> 00:15:06,240
we will now look at how

399
00:15:06,240 --> 00:15:08,959
an hss scheme evaluates each rms

400
00:15:08,959 --> 00:15:10,720
operation given the encodings that we

401
00:15:10,720 --> 00:15:11,760
defined

402
00:15:11,760 --> 00:15:13,920
to initialize a memory value with 1 the

403
00:15:13,920 --> 00:15:16,079
servers can use additive shares of 5

404
00:15:16,079 --> 00:15:17,920
which will be given to them as outputs

405
00:15:17,920 --> 00:15:19,760
of share

406
00:15:19,760 --> 00:15:22,079
to output a value x the decode function

407
00:15:22,079 --> 00:15:23,839
can subtract the additive shares of 5

408
00:15:23,839 --> 00:15:28,160
times 6 and divide it by the private e5

409
00:15:28,160 --> 00:15:29,600
addition of memory values and

410
00:15:29,600 --> 00:15:31,839
multiplication by a constant comes from

411
00:15:31,839 --> 00:15:34,480
comes for free as uh by the properties

412
00:15:34,480 --> 00:15:36,959
of the additive shares

413
00:15:36,959 --> 00:15:38,880
so the key challenge that remains is in

414
00:15:38,880 --> 00:15:40,320
how we perform the restricted

415
00:15:40,320 --> 00:15:42,480
multiplication that is multiplying an

416
00:15:42,480 --> 00:15:44,880
input x with the memory value y

417
00:15:44,880 --> 00:15:46,880
and this is essentially where all hss

418
00:15:46,880 --> 00:15:49,600
schemes differ

419
00:15:50,320 --> 00:15:52,959
so we next look at how we propose

420
00:15:52,959 --> 00:15:54,639
how we propose to compute this rms

421
00:15:54,639 --> 00:15:56,079
multiplication

422
00:15:56,079 --> 00:15:58,160
so in our hss construction we use the

423
00:15:58,160 --> 00:16:00,880
dermacad theory public key crypto system

424
00:16:00,880 --> 00:16:02,480
this public key crypto system is based

425
00:16:02,480 --> 00:16:04,320
on the homomorphism x

426
00:16:04,320 --> 00:16:06,560
and its inverse function log as shown as

427
00:16:06,560 --> 00:16:09,120
shown here note that these are finite

428
00:16:09,120 --> 00:16:11,759
sums in modulo n to the s plus one and

429
00:16:11,759 --> 00:16:13,360
both these functions are efficiently

430
00:16:13,360 --> 00:16:14,800
computable

431
00:16:14,800 --> 00:16:16,959
we can use this homomorphisms to define

432
00:16:16,959 --> 00:16:19,199
the encryption scheme

433
00:16:19,199 --> 00:16:21,040
particularly note that the encrypt

434
00:16:21,040 --> 00:16:23,680
function applies the homomorphism x on

435
00:16:23,680 --> 00:16:25,920
the input x and it multiplies it with a

436
00:16:25,920 --> 00:16:28,800
random perfect power of n to the s

437
00:16:28,800 --> 00:16:30,639
and the decrypt function has two key

438
00:16:30,639 --> 00:16:31,600
steps

439
00:16:31,600 --> 00:16:33,600
it first exponentiates the ciphertext

440
00:16:33,600 --> 00:16:35,600
with the private e5 and then the plain

441
00:16:35,600 --> 00:16:37,920
text is extracted using the log function

442
00:16:37,920 --> 00:16:41,040
which is the inverse of x

443
00:16:41,440 --> 00:16:43,040
coming back to the problem of rms

444
00:16:43,040 --> 00:16:45,920
multiplication we solve it as follows

445
00:16:45,920 --> 00:16:48,240
each party locally raises the encryption

446
00:16:48,240 --> 00:16:51,199
of x to their additive share of y

447
00:16:51,199 --> 00:16:52,880
the parties hence end up with

448
00:16:52,880 --> 00:16:55,360
multiplicative shares of encryption of x

449
00:16:55,360 --> 00:16:58,000
times y raised to the power phi

450
00:16:58,000 --> 00:16:59,920
here we define multiplicative shares of

451
00:16:59,920 --> 00:17:02,959
z to be elements z1 and z2 held by the

452
00:17:02,959 --> 00:17:05,839
two parties such that z is g one by z

453
00:17:05,839 --> 00:17:08,159
zero

454
00:17:08,240 --> 00:17:10,160
since the first step in the decryptions

455
00:17:10,160 --> 00:17:12,000
uh decryption algorithm involves

456
00:17:12,000 --> 00:17:14,160
exponentiating by the private key which

457
00:17:14,160 --> 00:17:16,000
we have already performed here the

458
00:17:16,000 --> 00:17:17,839
challenge is now to convert the

459
00:17:17,839 --> 00:17:20,720
multiplicative shares of x of

460
00:17:20,720 --> 00:17:23,039
phi times x y into additive shares of

461
00:17:23,039 --> 00:17:25,439
phi x y

462
00:17:25,439 --> 00:17:26,959
for this we use something called the

463
00:17:26,959 --> 00:17:28,640
distance function

464
00:17:28,640 --> 00:17:30,640
so if both parties evaluate this

465
00:17:30,640 --> 00:17:31,760
distance function on their

466
00:17:31,760 --> 00:17:34,720
multiplicative shares of x c then by

467
00:17:34,720 --> 00:17:36,400
definition of the distance function they

468
00:17:36,400 --> 00:17:38,559
would output additive shares of c with

469
00:17:38,559 --> 00:17:41,520
probability at least one minus epsilon

470
00:17:41,520 --> 00:17:43,840
so this completely describes how

471
00:17:43,840 --> 00:17:45,679
rms multiplication can be carried out

472
00:17:45,679 --> 00:17:47,760
using the distance function and the

473
00:17:47,760 --> 00:17:49,600
properties of the additively homomorphic

474
00:17:49,600 --> 00:17:51,520
scheme

475
00:17:51,520 --> 00:17:53,679
our key insight in this work is in that

476
00:17:53,679 --> 00:17:55,360
we designed the distance function for

477
00:17:55,360 --> 00:17:57,600
democrats uric ciphertex such that the

478
00:17:57,600 --> 00:18:00,480
epsilon error is negligible which was

479
00:18:00,480 --> 00:18:04,000
previously not known based on any tdh or

480
00:18:04,000 --> 00:18:07,600
dcr based hss construction

481
00:18:07,600 --> 00:18:09,280
specifically we propose the following

482
00:18:09,280 --> 00:18:11,600
distance function which is log of c

483
00:18:11,600 --> 00:18:14,480
divided by c modulo n using the

484
00:18:14,480 --> 00:18:17,200
properties of log and x homomorphisms we

485
00:18:17,200 --> 00:18:19,280
show that this function is well defined

486
00:18:19,280 --> 00:18:21,039
and that it's correct

487
00:18:21,039 --> 00:18:22,320
you can check out the paper for a

488
00:18:22,320 --> 00:18:24,480
detailed proof along with the discussion

489
00:18:24,480 --> 00:18:26,480
on when exactly the distance computation

490
00:18:26,480 --> 00:18:29,760
fails with negligible error

491
00:18:29,760 --> 00:18:31,679
for final remarks i shared that i

492
00:18:31,679 --> 00:18:33,120
couldn't discuss all the results we

493
00:18:33,120 --> 00:18:35,679
proposed related to hss in our paper

494
00:18:35,679 --> 00:18:37,679
particularly i didn't get to discuss our

495
00:18:37,679 --> 00:18:39,440
new hss definitions

496
00:18:39,440 --> 00:18:41,360
our two applications for hss

497
00:18:41,360 --> 00:18:43,760
particularly oblivious ramps and traffic

498
00:18:43,760 --> 00:18:45,120
to hash functions

499
00:18:45,120 --> 00:18:47,039
and also a modified hss construction

500
00:18:47,039 --> 00:18:49,440
that satisfies additive decoding

501
00:18:49,440 --> 00:18:52,080
you are welcome to check out a paper

502
00:18:52,080 --> 00:18:55,360
to see all the details thank you

503
00:18:55,360 --> 00:18:58,320
uh thank you very much uh jaspal

504
00:18:58,320 --> 00:19:01,280
uh any questions

505
00:19:01,280 --> 00:19:04,400
for somebody or somebody

506
00:19:04,400 --> 00:19:06,080
okay so so i have

507
00:19:06,080 --> 00:19:08,400
one question so so you say that your

508
00:19:08,400 --> 00:19:10,400
paper is based on damn guard drake do

509
00:19:10,400 --> 00:19:12,400
you since then get drunk is a

510
00:19:12,400 --> 00:19:14,960
generalization of pi yi do you

511
00:19:14,960 --> 00:19:17,039
does your paper also apply when uh

512
00:19:17,039 --> 00:19:18,799
intercepting using payee or you need a

513
00:19:18,799 --> 00:19:22,000
higher order in the damned graduate

514
00:19:22,000 --> 00:19:24,240
that's a good question uh so our scheme

515
00:19:24,240 --> 00:19:26,320
actually works for pi as well

516
00:19:26,320 --> 00:19:28,559
the only disadvantage is uh that to

517
00:19:28,559 --> 00:19:31,919
encode an input to the rms program uh if

518
00:19:31,919 --> 00:19:33,520
you're using a pi encryption scheme you

519
00:19:33,520 --> 00:19:35,039
would have to break it into multiple

520
00:19:35,039 --> 00:19:37,440
cipher text of pi to encode a single

521
00:19:37,440 --> 00:19:38,400
input of

522
00:19:38,400 --> 00:19:40,559
the rms program but whereas if you are

523
00:19:40,559 --> 00:19:42,480
using democrats uri you can expand the

524
00:19:42,480 --> 00:19:44,799
plaintext space to be large enough so

525
00:19:44,799 --> 00:19:47,360
that that is helpful to encode a single

526
00:19:47,360 --> 00:19:49,919
rms input using a single cipher text of

527
00:19:49,919 --> 00:19:52,559
a security but yes the

528
00:19:52,559 --> 00:19:54,640
the additions function that we propose

529
00:19:54,640 --> 00:19:56,559
sort of is negative it has negligible

530
00:19:56,559 --> 00:20:00,160
error probability for pi as well

531
00:20:01,440 --> 00:20:03,039
uh

532
00:20:03,039 --> 00:20:05,280
let's see okay so i guess we are back on

533
00:20:05,280 --> 00:20:07,919
time so thanks jaspal and matthew are

534
00:20:07,919 --> 00:20:10,720
you ready to

535
00:20:12,880 --> 00:20:16,200
to join

536
00:20:22,880 --> 00:20:26,480
matthew you'll need to unmute

537
00:20:26,880 --> 00:20:29,760
if if you can

538
00:20:32,000 --> 00:20:35,679
yes is it better now yes much yes

539
00:20:35,679 --> 00:20:37,840
okay fine

540
00:20:37,840 --> 00:20:40,000
okay

541
00:20:40,240 --> 00:20:41,760
okay perfect so let me introduce you

542
00:20:41,760 --> 00:20:43,520
sorry i didn't realize that i

543
00:20:43,520 --> 00:20:46,400
i didn't uh so it's a paper

544
00:20:46,400 --> 00:20:47,840
that we took before like the second

545
00:20:47,840 --> 00:20:50,240
paper of the session uh asymptotic

546
00:20:50,240 --> 00:20:52,159
asymptotically good arithmetic secret

547
00:20:52,159 --> 00:20:53,600
training over z

548
00:20:53,600 --> 00:20:55,760
p to z l with strong multiplication on

549
00:20:55,760 --> 00:20:56,880
its

550
00:20:56,880 --> 00:20:57,679
uh

551
00:20:57,679 --> 00:20:59,600
application to efficient mpc and this is

552
00:20:59,600 --> 00:21:03,039
the paper but not camera

553
00:21:05,039 --> 00:21:08,000
thank you very much so the the take home

554
00:21:08,000 --> 00:21:10,480
point of this paper the technical

555
00:21:10,480 --> 00:21:11,679
content

556
00:21:11,679 --> 00:21:14,799
is that we we consider gadgets for

557
00:21:14,799 --> 00:21:16,880
information theoretically secure

558
00:21:16,880 --> 00:21:18,400
computation

559
00:21:18,400 --> 00:21:21,520
which were previously known over finite

560
00:21:21,520 --> 00:21:22,960
fields

561
00:21:22,960 --> 00:21:26,720
and we carried them over rings z modulo

562
00:21:26,720 --> 00:21:28,320
p to the lz

563
00:21:28,320 --> 00:21:32,000
with exactly the same parameters

564
00:21:32,000 --> 00:21:34,960
the in the interesting case is where p

565
00:21:34,960 --> 00:21:37,200
equals 2 because then it is the ring of

566
00:21:37,200 --> 00:21:39,760
machine integers

567
00:21:39,760 --> 00:21:42,799
these multiplicative gadgets apart from

568
00:21:42,799 --> 00:21:44,880
the one in the title which is secret

569
00:21:44,880 --> 00:21:46,640
sharing

570
00:21:46,640 --> 00:21:49,200
are reverse multiplication friendly

571
00:21:49,200 --> 00:21:50,400
embeddings

572
00:21:50,400 --> 00:21:51,919
which i recall

573
00:21:51,919 --> 00:21:55,039
are useful to amortize the cost

574
00:21:55,039 --> 00:21:57,679
of many evaluations in parallel of the

575
00:21:57,679 --> 00:21:59,440
same circuit

576
00:21:59,440 --> 00:22:01,280
and the third gadget

577
00:22:01,280 --> 00:22:03,200
is the batch verification of

578
00:22:03,200 --> 00:22:05,600
multiplicative triples so you have a

579
00:22:05,600 --> 00:22:08,080
batch of short triple and you want to

580
00:22:08,080 --> 00:22:10,960
check if they are indeed multiplicative

581
00:22:10,960 --> 00:22:13,440
for this last one we of independent

582
00:22:13,440 --> 00:22:16,720
interest improve its complexity even

583
00:22:16,720 --> 00:22:19,600
over finite fields so we recover as a

584
00:22:19,600 --> 00:22:21,200
particular case

585
00:22:21,200 --> 00:22:23,520
a previous result on the complexity of

586
00:22:23,520 --> 00:22:25,520
npc over field

587
00:22:25,520 --> 00:22:26,480
so

588
00:22:26,480 --> 00:22:29,120
the the general motivation to study this

589
00:22:29,120 --> 00:22:31,280
gadget the big picture

590
00:22:31,280 --> 00:22:34,080
is the secure computation of

591
00:22:34,080 --> 00:22:36,080
arithmetic circuits

592
00:22:36,080 --> 00:22:39,760
which are naturally expressed in in the

593
00:22:39,760 --> 00:22:42,720
ring z modulo p to the lz

594
00:22:42,720 --> 00:22:44,640
so circuit with additions and

595
00:22:44,640 --> 00:22:48,480
multiplication guess modulo p to the l

596
00:22:48,480 --> 00:22:50,559
and we ask the question

597
00:22:50,559 --> 00:22:54,080
what is the the best

598
00:22:54,080 --> 00:22:56,159
is the complexity of protocols to

599
00:22:56,159 --> 00:22:58,960
directly compute in this ring

600
00:22:58,960 --> 00:23:01,840
and as a corollary of our results we

601
00:23:01,840 --> 00:23:04,320
close the gap between the complexity of

602
00:23:04,320 --> 00:23:06,080
secure protocols

603
00:23:06,080 --> 00:23:07,200
over

604
00:23:07,200 --> 00:23:08,559
rings and

605
00:23:08,559 --> 00:23:13,440
previously known complexity over fields

606
00:23:13,919 --> 00:23:16,559
now the the first gadget which i'm going

607
00:23:16,559 --> 00:23:19,200
to define again is secret sharing with

608
00:23:19,200 --> 00:23:21,039
strong multiplication

609
00:23:21,039 --> 00:23:22,559
it asks that

610
00:23:22,559 --> 00:23:25,600
if you have two vectors of shares of one

611
00:23:25,600 --> 00:23:29,360
secret s and one secret s prime

612
00:23:29,360 --> 00:23:31,600
and you know you don't know the vectors

613
00:23:31,600 --> 00:23:34,400
of sharps but you you you know c

614
00:23:34,400 --> 00:23:36,880
products component by component

615
00:23:36,880 --> 00:23:38,960
product share by sha you know me you

616
00:23:38,960 --> 00:23:42,640
know many products s i s prime i

617
00:23:42,640 --> 00:23:44,799
then the strong multiplication property

618
00:23:44,799 --> 00:23:46,080
states that

619
00:23:46,080 --> 00:23:47,279
even if

620
00:23:47,279 --> 00:23:48,880
you are missing

621
00:23:48,880 --> 00:23:51,600
some of these products you miss c

622
00:23:51,600 --> 00:23:53,039
products

623
00:23:53,039 --> 00:23:55,200
then anyway you can reconstruct the

624
00:23:55,200 --> 00:23:57,600
product of secrets from the

625
00:23:57,600 --> 00:24:00,640
n minus t remaining products

626
00:24:00,640 --> 00:24:03,760
so the technical hurdle to achieve

627
00:24:03,760 --> 00:24:06,080
this primitive over rings is the

628
00:24:06,080 --> 00:24:08,400
following

629
00:24:08,400 --> 00:24:10,960
the technical problem is to find codes

630
00:24:10,960 --> 00:24:13,279
with small square

631
00:24:13,279 --> 00:24:15,600
why small square because a square of a

632
00:24:15,600 --> 00:24:18,720
code is the code generated by all the

633
00:24:18,720 --> 00:24:20,960
products of code words component by

634
00:24:20,960 --> 00:24:22,400
components

635
00:24:22,400 --> 00:24:24,720
small square means big distance

636
00:24:24,720 --> 00:24:26,960
means you can reconstruct a product of

637
00:24:26,960 --> 00:24:30,320
two secrets from a few coordinates this

638
00:24:30,320 --> 00:24:32,880
is what we are looking for

639
00:24:32,880 --> 00:24:36,240
the problem is that in general

640
00:24:36,240 --> 00:24:37,200
the

641
00:24:37,200 --> 00:24:40,400
the square of codes over rings they have

642
00:24:40,400 --> 00:24:42,080
they are very big

643
00:24:42,080 --> 00:24:45,039
so even if you start from a code over a

644
00:24:45,039 --> 00:24:47,279
field which is known to have a small

645
00:24:47,279 --> 00:24:48,880
square

646
00:24:48,880 --> 00:24:51,679
it is not guaranteed at all that if you

647
00:24:51,679 --> 00:24:53,840
lift the coefficients of the code modulo

648
00:24:53,840 --> 00:24:55,120
p to the l

649
00:24:55,120 --> 00:24:57,520
then you take the square the square will

650
00:24:57,520 --> 00:24:59,520
be very big

651
00:24:59,520 --> 00:25:01,440
let me give the intuition of this

652
00:25:01,440 --> 00:25:04,159
problem this problem comes from the fact

653
00:25:04,159 --> 00:25:05,039
that

654
00:25:05,039 --> 00:25:07,679
when a code has a small square it means

655
00:25:07,679 --> 00:25:10,000
that you have many linear relations

656
00:25:10,000 --> 00:25:12,640
between the products of code words

657
00:25:12,640 --> 00:25:14,720
but this linear relations they hold

658
00:25:14,720 --> 00:25:16,240
modulo p

659
00:25:16,240 --> 00:25:18,799
it is not guaranteed at all that these

660
00:25:18,799 --> 00:25:22,080
relations also hold modulo p to the l

661
00:25:22,080 --> 00:25:25,279
this is the big technical problem

662
00:25:25,279 --> 00:25:27,679
so the main theorem of the paper

663
00:25:27,679 --> 00:25:30,799
guarantees the existence of codes with

664
00:25:30,799 --> 00:25:32,400
small square

665
00:25:32,400 --> 00:25:33,760
over rings

666
00:25:33,760 --> 00:25:36,080
unfortunately it is not needed to

667
00:25:36,080 --> 00:25:38,320
understand the proof to construct them

668
00:25:38,320 --> 00:25:39,919
explicitly

669
00:25:39,919 --> 00:25:42,080
the explicit construction

670
00:25:42,080 --> 00:25:43,919
starts from the intuition that i've just

671
00:25:43,919 --> 00:25:45,919
said the intuition is that

672
00:25:45,919 --> 00:25:48,640
you start from a code over fields

673
00:25:48,640 --> 00:25:50,960
such that the the products component by

674
00:25:50,960 --> 00:25:52,880
component the square

675
00:25:52,880 --> 00:25:55,279
they have many linear relations between

676
00:25:55,279 --> 00:25:57,840
them the square is very small

677
00:25:57,840 --> 00:26:00,080
and from this ingredient you would like

678
00:26:00,080 --> 00:26:02,480
to construct the same

679
00:26:02,480 --> 00:26:05,440
in a bigger ring audio p to the l

680
00:26:05,440 --> 00:26:07,760
so the explicit method that we develop

681
00:26:07,760 --> 00:26:09,840
in the paper which is called as the

682
00:26:09,840 --> 00:26:13,039
hansel lifted me handsome lifting method

683
00:26:13,039 --> 00:26:15,919
is that we write down the the

684
00:26:15,919 --> 00:26:18,080
linear relations between square of

685
00:26:18,080 --> 00:26:19,679
elements of the code

686
00:26:19,679 --> 00:26:22,880
and we lift them recursively modulo p l

687
00:26:22,880 --> 00:26:26,320
pl plus 1 so that in l steps

688
00:26:26,320 --> 00:26:29,600
applying every time a linear system over

689
00:26:29,600 --> 00:26:33,440
z modulo pz a finite field we achieve to

690
00:26:33,440 --> 00:26:36,480
find a code over a big ring with a small

691
00:26:36,480 --> 00:26:37,600
square

692
00:26:37,600 --> 00:26:40,879
this concludes my talk

693
00:26:45,039 --> 00:26:47,360
thank you very much matia and thanks to

694
00:26:47,360 --> 00:26:48,559
all the

695
00:26:48,559 --> 00:26:51,600
speakers before the break

696
00:26:51,600 --> 00:26:54,000
do anyone have questions

697
00:26:54,000 --> 00:26:58,240
about this talk or the previous talk

698
00:26:58,320 --> 00:27:00,320
please raise your hand or write in the

699
00:27:00,320 --> 00:27:04,639
chat or write on zulip

700
00:27:05,279 --> 00:27:09,039
oh uh so uh what's on that ask

701
00:27:09,039 --> 00:27:09,760
uh

702
00:27:09,760 --> 00:27:12,080
can we see your result as an analytic

703
00:27:12,080 --> 00:27:15,200
one for prd codes no sorry it's not so

704
00:27:15,200 --> 00:27:18,559
much it's for a previous talk

705
00:27:18,559 --> 00:27:22,559
ah sorry no okay sorry no not

706
00:27:22,559 --> 00:27:24,960
absolutely so it's it's a very

707
00:27:24,960 --> 00:27:27,200
interesting question it is true

708
00:27:27,200 --> 00:27:29,360
that all our results

709
00:27:29,360 --> 00:27:32,159
that i presented modulo p to the l

710
00:27:32,159 --> 00:27:34,799
they also hold modulo

711
00:27:34,799 --> 00:27:36,960
sorry they also hold

712
00:27:36,960 --> 00:27:40,080
in the piadig ring so the infinite ring

713
00:27:40,080 --> 00:27:42,399
is the the periodic numbers with

714
00:27:42,399 --> 00:27:44,799
infinite p development

715
00:27:44,799 --> 00:27:47,679
but to have these results you need

716
00:27:47,679 --> 00:27:49,520
more ingredients

717
00:27:49,520 --> 00:27:51,919
so in the paper we only presented it

718
00:27:51,919 --> 00:27:54,960
over finite rings the modulo a fixed

719
00:27:54,960 --> 00:27:57,760
peep to the l

720
00:27:58,159 --> 00:28:03,120
okay thanks thanks and anat baskin

721
00:28:04,159 --> 00:28:07,440
as asking to benny applebaum

722
00:28:07,440 --> 00:28:09,200
do you think looking for a different

723
00:28:09,200 --> 00:28:11,679
family of function that achieves a

724
00:28:11,679 --> 00:28:13,200
better trade-off between share

725
00:28:13,200 --> 00:28:15,279
complexity and glowing complexity is a

726
00:28:15,279 --> 00:28:17,520
viable way for improving the upper bound

727
00:28:17,520 --> 00:28:20,799
for general sequentially

728
00:28:23,360 --> 00:28:25,679
i wish i don't know

729
00:28:25,679 --> 00:28:27,360
i mean

730
00:28:27,360 --> 00:28:31,719
frankly in this field

731
00:28:31,840 --> 00:28:32,559
i

732
00:28:32,559 --> 00:28:34,080
currently don't don't really trust my

733
00:28:34,080 --> 00:28:36,559
own intuitions and we've seen we've seen

734
00:28:36,559 --> 00:28:38,640
all sorts of surprises in the last few

735
00:28:38,640 --> 00:28:40,080
years

736
00:28:40,080 --> 00:28:44,399
and maybe i think i think that uh

737
00:28:44,399 --> 00:28:46,159
it's it's it's possible i don't even

738
00:28:46,159 --> 00:28:48,080
know whether to guess that there is a

739
00:28:48,080 --> 00:28:50,000
sub-exponential

740
00:28:50,000 --> 00:28:53,679
solution or not so so i don't know

741
00:28:53,679 --> 00:28:55,520
it's certainly possible that such an

742
00:28:55,520 --> 00:28:58,520
approach

743
00:29:00,559 --> 00:29:04,000
okay any other questions

744
00:29:08,640 --> 00:29:10,640
okay so then we'll reconvene in 10

745
00:29:10,640 --> 00:29:14,240
minutes at 3 20

746
00:29:14,240 --> 00:29:17,600
for the second part of this session

747
00:29:17,600 --> 00:29:19,760
so you

