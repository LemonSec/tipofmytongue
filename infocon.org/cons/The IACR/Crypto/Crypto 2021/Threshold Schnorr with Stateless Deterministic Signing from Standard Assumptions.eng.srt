1
00:00:02,800 --> 00:00:04,560
hi i'm yashwan and i'll be speaking

2
00:00:04,560 --> 00:00:06,160
about threshold schnau with status

3
00:00:06,160 --> 00:00:07,919
deterministic signing from standard

4
00:00:07,919 --> 00:00:09,920
assumptions this is joint work with

5
00:00:09,920 --> 00:00:11,759
francois garrio bayman mohassel and

6
00:00:11,759 --> 00:00:14,240
valeriana kolenko

7
00:00:14,240 --> 00:00:15,679
so let's say bob would like to send some

8
00:00:15,679 --> 00:00:17,680
bitcoin to his friend alice

9
00:00:17,680 --> 00:00:19,359
he first creates a message to that

10
00:00:19,359 --> 00:00:21,279
effect he takes out his laptop in which

11
00:00:21,279 --> 00:00:22,880
he has a sending key and he presses a

12
00:00:22,880 --> 00:00:24,720
button to produce a signature to attach

13
00:00:24,720 --> 00:00:26,880
to the message

14
00:00:26,880 --> 00:00:28,480
however an attacker could enter the

15
00:00:28,480 --> 00:00:30,240
picture and hack into bob's laptop and

16
00:00:30,240 --> 00:00:33,280
steal his secret key

17
00:00:33,280 --> 00:00:35,280
and she can essentially divert funds to

18
00:00:35,280 --> 00:00:36,480
herself

19
00:00:36,480 --> 00:00:38,960
as she has understated access to bob's

20
00:00:38,960 --> 00:00:41,120
account

21
00:00:41,120 --> 00:00:43,600
in order to mitigate this bob could

22
00:00:43,600 --> 00:00:46,239
employ a technique by which he splits

23
00:00:46,239 --> 00:00:48,480
his signing key into multiple fragments

24
00:00:48,480 --> 00:00:50,000
so that even if one fragment is

25
00:00:50,000 --> 00:00:53,440
compromised the secret key stays safe

26
00:00:53,440 --> 00:00:55,440
so this notion is achieved by threshold

27
00:00:55,440 --> 00:00:57,120
signature where the secret key can be

28
00:00:57,120 --> 00:00:59,199
split into multiple fragments

29
00:00:59,199 --> 00:01:00,879
and stored on different devices and the

30
00:01:00,879 --> 00:01:02,160
devices must interact and

31
00:01:02,160 --> 00:01:05,360
collaboratively sign messages

32
00:01:05,360 --> 00:01:06,960
the important thing is that the

33
00:01:06,960 --> 00:01:08,960
signature that comes out of the system

34
00:01:08,960 --> 00:01:11,360
looks just as though it came from

35
00:01:11,360 --> 00:01:13,200
an execution of the regular single party

36
00:01:13,200 --> 00:01:15,520
sending algorithm

37
00:01:15,520 --> 00:01:17,200
so the setting that we are going to

38
00:01:17,200 --> 00:01:19,119
consider in this work is that if

39
00:01:19,119 --> 00:01:21,280
dishonest majority that's all devices

40
00:01:21,280 --> 00:01:22,960
but one are corrupt

41
00:01:22,960 --> 00:01:24,640
but we're mostly going to talk about the

42
00:01:24,640 --> 00:01:27,200
two-party case though this

43
00:01:27,200 --> 00:01:30,560
the techniques will generalize

44
00:01:30,640 --> 00:01:33,040
and as for adversarial behavior we

45
00:01:33,040 --> 00:01:35,840
consider malicious adversaries who

46
00:01:35,840 --> 00:01:37,520
can deviate arbitrarily from the

47
00:01:37,520 --> 00:01:40,400
protocol

48
00:01:40,400 --> 00:01:42,320
so we consider schnauz signature scheme

49
00:01:42,320 --> 00:01:44,320
in this work which is an elegant

50
00:01:44,320 --> 00:01:46,399
signature scheme with security based on

51
00:01:46,399 --> 00:01:47,840
the hardness of computing discrete

52
00:01:47,840 --> 00:01:49,040
logarithms

53
00:01:49,040 --> 00:01:51,280
the scheme was initially hampered in

54
00:01:51,280 --> 00:01:53,520
terms of adoption due to a patent but is

55
00:01:53,520 --> 00:01:54,799
now seeing

56
00:01:54,799 --> 00:01:56,880
more deployment across the internet in

57
00:01:56,880 --> 00:01:59,600
the form of fdsa

58
00:01:59,600 --> 00:02:01,360
the nice thing is that it's very easy to

59
00:02:01,360 --> 00:02:03,759
distribute with natural or threshold key

60
00:02:03,759 --> 00:02:05,680
generation assigning protocols these are

61
00:02:05,680 --> 00:02:08,639
classic works

62
00:02:08,639 --> 00:02:10,560
so let's take a look at how signatures

63
00:02:10,560 --> 00:02:12,400
are structured so given an elliptic

64
00:02:12,400 --> 00:02:13,760
curve group

65
00:02:13,760 --> 00:02:16,000
ball g of prime order q that's generated

66
00:02:16,000 --> 00:02:18,560
by capital g the secret key is sampled

67
00:02:18,560 --> 00:02:20,879
uniformly from z queue and the public

68
00:02:20,879 --> 00:02:22,879
key is simply the secret key times the

69
00:02:22,879 --> 00:02:25,120
generator

70
00:02:25,120 --> 00:02:27,680
so now let's step through signing

71
00:02:27,680 --> 00:02:30,560
you begin by sampling an instance key k

72
00:02:30,560 --> 00:02:31,920
and multiplying it with the group

73
00:02:31,920 --> 00:02:34,000
generator to get the nonce hash the

74
00:02:34,000 --> 00:02:35,680
nonce with the message and compute the

75
00:02:35,680 --> 00:02:37,680
signature as a linear combination of k

76
00:02:37,680 --> 00:02:39,519
and s k

77
00:02:39,519 --> 00:02:42,000
ah the linear combination is weighted by

78
00:02:42,000 --> 00:02:43,120
e

79
00:02:43,120 --> 00:02:45,120
so verifying a signature is simple it's

80
00:02:45,120 --> 00:02:46,800
just checking the sign descending

81
00:02:46,800 --> 00:02:49,360
equation and the exponent

82
00:02:49,360 --> 00:02:51,920
so that's quite easy so useful property

83
00:02:51,920 --> 00:02:54,239
about china is a threshold friendliness

84
00:02:54,239 --> 00:02:56,319
in particular the standing equation is a

85
00:02:56,319 --> 00:02:58,239
linear function of k and sk which is

86
00:02:58,239 --> 00:03:00,239
very easy to distribute with most

87
00:03:00,239 --> 00:03:02,640
natural secret sharing schemes

88
00:03:02,640 --> 00:03:04,720
so for instance in the two-party setting

89
00:03:04,720 --> 00:03:07,040
uh we can produce additive shares of the

90
00:03:07,040 --> 00:03:08,560
standing key as k

91
00:03:08,560 --> 00:03:10,319
sample additive shares of the instance

92
00:03:10,319 --> 00:03:11,840
key k

93
00:03:11,840 --> 00:03:14,720
um exchange the corresponding nonsense

94
00:03:14,720 --> 00:03:17,599
compute the hash the usual way and now

95
00:03:17,599 --> 00:03:19,680
shares of s can be computed simply

96
00:03:19,680 --> 00:03:21,680
locally as a linear combination of

97
00:03:21,680 --> 00:03:24,080
shares of k and sk

98
00:03:24,080 --> 00:03:27,120
exchanging these completes the signature

99
00:03:27,120 --> 00:03:28,879
so this can be made maliciously secure

100
00:03:28,879 --> 00:03:30,720
quite easily and it also generalizes to

101
00:03:30,720 --> 00:03:33,680
end parties

102
00:03:33,680 --> 00:03:36,239
however it turns out that um

103
00:03:36,239 --> 00:03:39,200
security of schnoz signatures is

104
00:03:39,200 --> 00:03:41,120
extremely sensitive to the distribution

105
00:03:41,120 --> 00:03:42,959
of k that is even a tiny amount of

106
00:03:42,959 --> 00:03:44,720
non-uniformity can be leveraged to

107
00:03:44,720 --> 00:03:46,959
completely retrieve the standing key and

108
00:03:46,959 --> 00:03:48,560
break security

109
00:03:48,560 --> 00:03:50,080
so this started with the hidden number

110
00:03:50,080 --> 00:03:51,920
problem is formulated by borneo and

111
00:03:51,920 --> 00:03:53,439
vacation all the way to modern

112
00:03:53,439 --> 00:03:54,879
techniques that can be used to mount

113
00:03:54,879 --> 00:03:57,120
attacks with practical running times

114
00:03:57,120 --> 00:03:59,439
this is a major concern in practice

115
00:03:59,439 --> 00:04:00,560
because

116
00:04:00,560 --> 00:04:02,080
there are a variety of engineering

117
00:04:02,080 --> 00:04:03,760
problems that make acquiring fresh

118
00:04:03,760 --> 00:04:06,879
entropy quite difficult

119
00:04:08,080 --> 00:04:10,400
so this is a systems level problem that

120
00:04:10,400 --> 00:04:12,000
we can largely avoid with a simple

121
00:04:12,000 --> 00:04:15,040
cryptographic click so during one time

122
00:04:15,040 --> 00:04:16,720
secret key generation we can sample the

123
00:04:16,720 --> 00:04:18,560
seed and then when sending a message

124
00:04:18,560 --> 00:04:20,959
instead of sampling a fresh k we can

125
00:04:20,959 --> 00:04:23,520
compute k as a deterministic function of

126
00:04:23,520 --> 00:04:26,080
the seed and the message being signed

127
00:04:26,080 --> 00:04:28,240
so assuming that this function is ac to

128
00:04:28,240 --> 00:04:30,000
nano function the

129
00:04:30,000 --> 00:04:32,000
uh security of the resulting scheme is

130
00:04:32,000 --> 00:04:34,800
as is as good as choosing k uniformly

131
00:04:34,800 --> 00:04:36,080
for each message

132
00:04:36,080 --> 00:04:38,160
this is the classic idea that is more

133
00:04:38,160 --> 00:04:40,160
recently employed by the modern ldsa

134
00:04:40,160 --> 00:04:43,040
variation

135
00:04:43,040 --> 00:04:44,320
so let's try a simple attempt at

136
00:04:44,320 --> 00:04:46,800
deterministic signing in the two-party

137
00:04:46,800 --> 00:04:48,880
signing scheme that we looked at earlier

138
00:04:48,880 --> 00:04:51,040
let's say we also sample

139
00:04:51,040 --> 00:04:53,520
some seeds on each of the devices

140
00:04:53,520 --> 00:04:55,280
so let's do the trivial thing and let's

141
00:04:55,280 --> 00:04:57,040
keep track of what information the

142
00:04:57,040 --> 00:04:59,759
adversary can learn when

143
00:04:59,759 --> 00:05:02,880
we execute this library protocol

144
00:05:02,880 --> 00:05:03,919
so

145
00:05:03,919 --> 00:05:06,479
in this scheme

146
00:05:06,479 --> 00:05:10,160
the adversary can collect

147
00:05:10,160 --> 00:05:12,960
first just the linear combination of

148
00:05:12,960 --> 00:05:15,120
the shares of k and sk of the honest

149
00:05:15,120 --> 00:05:17,440
party this is just by honest execution

150
00:05:17,440 --> 00:05:19,039
and now since the

151
00:05:19,039 --> 00:05:22,720
nonsense k are derived deterministically

152
00:05:22,720 --> 00:05:23,680
and

153
00:05:23,680 --> 00:05:25,440
honest party is always going to derive

154
00:05:25,440 --> 00:05:27,039
the same nonce but then adversely you

155
00:05:27,039 --> 00:05:28,800
could do it could deviate from honest

156
00:05:28,800 --> 00:05:30,639
noise derivation

157
00:05:30,639 --> 00:05:32,639
and to see what effect this has let's

158
00:05:32,639 --> 00:05:35,360
see what happens when an adversary uses

159
00:05:35,360 --> 00:05:38,880
a non-ska style instead of the honest ka

160
00:05:38,880 --> 00:05:40,479
and see how this error propagates

161
00:05:40,479 --> 00:05:42,400
through an honest signing

162
00:05:42,400 --> 00:05:43,759
um

163
00:05:43,759 --> 00:05:44,639
through

164
00:05:44,639 --> 00:05:47,600
an instance of designing protocol

165
00:05:47,600 --> 00:05:49,600
so essentially if we trace how this

166
00:05:49,600 --> 00:05:50,800
error

167
00:05:50,800 --> 00:05:52,400
propagates through

168
00:05:52,400 --> 00:05:55,600
the protocol we find that

169
00:05:55,600 --> 00:05:57,280
the adversary now learns a different

170
00:05:57,280 --> 00:05:59,520
linear combination of the same

171
00:05:59,520 --> 00:06:00,560
secrets

172
00:06:00,560 --> 00:06:03,840
that is because the honest party derives

173
00:06:03,840 --> 00:06:06,800
kb deterministically as a function of

174
00:06:06,800 --> 00:06:08,400
the message in the seed and this and the

175
00:06:08,400 --> 00:06:10,400
message in the seed have not changed

176
00:06:10,400 --> 00:06:12,160
so now

177
00:06:12,160 --> 00:06:14,080
this induces the honest party to reveal

178
00:06:14,080 --> 00:06:16,960
two linear equations and two unknowns

179
00:06:16,960 --> 00:06:19,280
and this is bad because the address that

180
00:06:19,280 --> 00:06:21,280
you can now simply solve for the honest

181
00:06:21,280 --> 00:06:22,720
party shared with the signing key and

182
00:06:22,720 --> 00:06:24,479
then reconstruct the signing key in its

183
00:06:24,479 --> 00:06:25,919
entirety

184
00:06:25,919 --> 00:06:28,479
this was first observed by maxwell

185
00:06:28,479 --> 00:06:30,800
poster sarah einberg

186
00:06:30,800 --> 00:06:33,199
and it constitutes

187
00:06:33,199 --> 00:06:35,360
uh

188
00:06:35,360 --> 00:06:38,000
another specific instance of

189
00:06:38,000 --> 00:06:40,240
a general flavor

190
00:06:40,240 --> 00:06:42,400
of a problem that has previously been

191
00:06:42,400 --> 00:06:45,520
encountered in the context of resettable

192
00:06:45,520 --> 00:06:47,680
zero knowledge of the resettable npc

193
00:06:47,680 --> 00:06:51,440
starting with the work of kenneth at all

194
00:06:52,479 --> 00:06:54,400
so instead of evaluating a prf on the

195
00:06:54,400 --> 00:06:56,639
message let's try a different approach

196
00:06:56,639 --> 00:06:58,240
let's

197
00:06:58,240 --> 00:07:00,400
for instance we could try maintaining a

198
00:07:00,400 --> 00:07:03,199
counter and the deriving the instance

199
00:07:03,199 --> 00:07:04,880
key by

200
00:07:04,880 --> 00:07:07,840
applying the prf on the seed sampled

201
00:07:07,840 --> 00:07:10,160
earlier and the counter so each time the

202
00:07:10,160 --> 00:07:12,560
counter is accessed it is also

203
00:07:12,560 --> 00:07:15,680
incremented and so this ensures that the

204
00:07:15,680 --> 00:07:17,039
instant scales that come out of this

205
00:07:17,039 --> 00:07:19,280
method are always fresh

206
00:07:19,280 --> 00:07:21,120
however this introduces a new attack

207
00:07:21,120 --> 00:07:23,039
surface that is the using a counter is

208
00:07:23,039 --> 00:07:25,360
now equivalent to reusing the nonce so

209
00:07:25,360 --> 00:07:27,120
it would be catastrophic to use the same

210
00:07:27,120 --> 00:07:29,440
counter twice

211
00:07:29,440 --> 00:07:30,400
unfortunately

212
00:07:30,400 --> 00:07:33,280
undetectable you reuse a stale state is

213
00:07:33,280 --> 00:07:35,919
a significant concern in practice

214
00:07:35,919 --> 00:07:38,319
among other things due to introductions

215
00:07:38,319 --> 00:07:40,319
and power supply and rolling back to

216
00:07:40,319 --> 00:07:43,199
previous states restoring from backups

217
00:07:43,199 --> 00:07:44,879
and also loading virtual machines with

218
00:07:44,879 --> 00:07:47,680
old snapshots

219
00:07:48,080 --> 00:07:49,440
these are all events that can be

220
00:07:49,440 --> 00:07:51,919
adversarially induced or even or can

221
00:07:51,919 --> 00:07:55,599
even record you together as mistakes

222
00:07:56,720 --> 00:07:58,479
so this sounds like a systems problem so

223
00:07:58,479 --> 00:08:00,479
we couldn't principally up to the

224
00:08:00,479 --> 00:08:02,800
systems people to worry about

225
00:08:02,800 --> 00:08:05,919
indeed pano at all um identified that

226
00:08:05,919 --> 00:08:07,599
state continuity

227
00:08:07,599 --> 00:08:09,039
which is the problem at hand is

228
00:08:09,039 --> 00:08:11,199
difficult even on dedicated and hardened

229
00:08:11,199 --> 00:08:13,599
isolated devices

230
00:08:13,599 --> 00:08:15,680
so broadly there are two flavors of

231
00:08:15,680 --> 00:08:18,000
general solutions and from the systems

232
00:08:18,000 --> 00:08:20,720
literature one is to use helper nodes

233
00:08:20,720 --> 00:08:22,879
which is inapplicable to our dishonest

234
00:08:22,879 --> 00:08:24,319
majority setting where there's only one

235
00:08:24,319 --> 00:08:27,360
honest party or we could also use

236
00:08:27,360 --> 00:08:30,000
special purpose hardware as also shown

237
00:08:30,000 --> 00:08:31,360
in recent work

238
00:08:31,360 --> 00:08:33,200
so this is unsatisfying for a couple of

239
00:08:33,200 --> 00:08:34,958
reasons one qualitatively this

240
00:08:34,958 --> 00:08:37,440
introduces extra physical assumptions we

241
00:08:37,440 --> 00:08:38,839
have to trust

242
00:08:38,839 --> 00:08:40,479
hardware

243
00:08:40,479 --> 00:08:42,240
and quantitatively it turns out that

244
00:08:42,240 --> 00:08:44,320
this is still quite slow

245
00:08:44,320 --> 00:08:46,880
uh that is magic and all and

246
00:08:46,880 --> 00:08:48,320
at all found

247
00:08:48,320 --> 00:08:50,000
a latency for about 60 to 100

248
00:08:50,000 --> 00:08:52,000
milliseconds in incrementing an sjx

249
00:08:52,000 --> 00:08:54,000
monotonic counter others want even

250
00:08:54,000 --> 00:08:55,920
larger latencies

251
00:08:55,920 --> 00:08:58,399
of course it's also expensive to

252
00:08:58,399 --> 00:09:00,080
purchase new hardware for each new

253
00:09:00,080 --> 00:09:01,760
deployment

254
00:09:01,760 --> 00:09:02,640
and

255
00:09:02,640 --> 00:09:05,360
additionally this also has

256
00:09:05,360 --> 00:09:07,600
a limited lifespan that is in their work

257
00:09:07,600 --> 00:09:09,839
they also found that

258
00:09:09,839 --> 00:09:12,160
non-volatile memory can wear out

259
00:09:12,160 --> 00:09:16,000
in just a few days of continuous use

260
00:09:16,320 --> 00:09:18,320
so in this work we study whether solving

261
00:09:18,320 --> 00:09:20,320
this at a cryptographic protocol design

262
00:09:20,320 --> 00:09:22,560
level could be useful

263
00:09:22,560 --> 00:09:23,440
so

264
00:09:23,440 --> 00:09:25,519
we asked the question how can we design

265
00:09:25,519 --> 00:09:27,440
a threshold protocol that enjoys

266
00:09:27,440 --> 00:09:29,360
stateless deterministic signing that is

267
00:09:29,360 --> 00:09:31,519
we want no party to have the sample

268
00:09:31,519 --> 00:09:33,360
flash randomness or rely on updating

269
00:09:33,360 --> 00:09:36,640
state of the key generation

270
00:09:36,640 --> 00:09:38,160
the idea is that we should be able to

271
00:09:38,160 --> 00:09:39,920
safely restore crash devices with

272
00:09:39,920 --> 00:09:41,600
long-term secrets which is significantly

273
00:09:41,600 --> 00:09:44,480
easier to maintain

274
00:09:45,440 --> 00:09:46,880
so we developed new techniques to

275
00:09:46,880 --> 00:09:48,959
construct threshold signing that's

276
00:09:48,959 --> 00:09:51,200
stateless and deterministic by design

277
00:09:51,200 --> 00:09:52,959
while using native cryptographic tools

278
00:09:52,959 --> 00:09:55,440
such as block ciphers and

279
00:09:55,440 --> 00:09:57,279
we estimate the efficiency to be

280
00:09:57,279 --> 00:09:58,800
significantly faster than trusted

281
00:09:58,800 --> 00:10:01,199
hardware

282
00:10:01,279 --> 00:10:02,959
so the high level idea is really quite

283
00:10:02,959 --> 00:10:05,600
simple let's say we have some magic

284
00:10:05,600 --> 00:10:08,160
boxes that have embedded in them the

285
00:10:08,160 --> 00:10:10,640
each party is seed so that when given

286
00:10:10,640 --> 00:10:13,120
the message m as public input

287
00:10:13,120 --> 00:10:15,920
they produce the corresponding nonsense

288
00:10:15,920 --> 00:10:18,240
r a and r b and they deliver them to the

289
00:10:18,240 --> 00:10:19,680
opposite party

290
00:10:19,680 --> 00:10:23,279
so this is secure by definition

291
00:10:23,440 --> 00:10:24,720
of course the canonical way to

292
00:10:24,720 --> 00:10:26,959
instantiate such a box is to have each

293
00:10:26,959 --> 00:10:28,720
party commit to their respective seats

294
00:10:28,720 --> 00:10:30,800
and subsequently prove in zero knowledge

295
00:10:30,800 --> 00:10:31,920
that they've derived their claim

296
00:10:31,920 --> 00:10:35,920
nonsense correctly when given a message

297
00:10:35,920 --> 00:10:37,519
so there's a myriad of ways to construct

298
00:10:37,519 --> 00:10:39,279
such a proof system and in order to make

299
00:10:39,279 --> 00:10:41,120
our choice of tools clearer we lay down

300
00:10:41,120 --> 00:10:43,440
our priorities for the setting

301
00:10:43,440 --> 00:10:46,079
so firstly we want to focus on

302
00:10:46,079 --> 00:10:48,720
conservative choice of the pseudo-random

303
00:10:48,720 --> 00:10:50,399
function because

304
00:10:50,399 --> 00:10:52,240
the signatures which are exposed to the

305
00:10:52,240 --> 00:10:53,920
outside world strongly depend on the

306
00:10:53,920 --> 00:10:56,480
security of the prf

307
00:10:56,480 --> 00:10:57,760
next we would like lightweight

308
00:10:57,760 --> 00:10:59,760
computation so we would like to retain

309
00:10:59,760 --> 00:11:02,320
friendliness to weaker devices such as

310
00:11:02,320 --> 00:11:04,320
mobile cryptocurrency wallets

311
00:11:04,320 --> 00:11:06,160
and also this could be useful in high

312
00:11:06,160 --> 00:11:08,480
throughput settings

313
00:11:08,480 --> 00:11:09,839
finally we want

314
00:11:09,839 --> 00:11:11,360
round efficiency to match that of

315
00:11:11,360 --> 00:11:12,560
regulator

316
00:11:12,560 --> 00:11:14,240
that's three times

317
00:11:14,240 --> 00:11:17,839
so we don't want to increase the latency

318
00:11:18,000 --> 00:11:19,519
so there's a variety of candidate

319
00:11:19,519 --> 00:11:21,839
cryptographic tools to instantiate such

320
00:11:21,839 --> 00:11:23,519
a box and

321
00:11:23,519 --> 00:11:25,839
we recall some common candidates

322
00:11:25,839 --> 00:11:28,720
we could use snarks genetic mpc mpc in

323
00:11:28,720 --> 00:11:31,360
the head global circuits

324
00:11:31,360 --> 00:11:33,600
um but with our constraints in mind we

325
00:11:33,600 --> 00:11:36,320
can start building some of these out

326
00:11:36,320 --> 00:11:38,079
in particular matching round efficiency

327
00:11:38,079 --> 00:11:40,240
of threshold means that we can't really

328
00:11:40,240 --> 00:11:43,440
use genetic mpc because mpc protocols

329
00:11:43,440 --> 00:11:45,200
that are concretely efficient are also

330
00:11:45,200 --> 00:11:46,880
quite interactive and difficult to

331
00:11:46,880 --> 00:11:48,480
instantiate statistics and

332
00:11:48,480 --> 00:11:51,200
deterministically

333
00:11:51,200 --> 00:11:52,959
and the combination of requirements of

334
00:11:52,959 --> 00:11:55,279
low computation and standard pls rules

335
00:11:55,279 --> 00:11:56,560
out snarks

336
00:11:56,560 --> 00:11:58,320
as they tend to be either heavy to

337
00:11:58,320 --> 00:12:00,880
compute or um require custom arithmetic

338
00:12:00,880 --> 00:12:04,000
pr as for efficiency

339
00:12:04,000 --> 00:12:06,560
so the recent work of necrophinc solar

340
00:12:06,560 --> 00:12:09,040
world from i mean constructed a custom

341
00:12:09,040 --> 00:12:11,440
prf for which bullet proofs are very bad

342
00:12:11,440 --> 00:12:12,880
bandwidth efficient

343
00:12:12,880 --> 00:12:15,200
um the order of just a kilobyte but they

344
00:12:15,200 --> 00:12:17,519
tend to be a bit heavier to execute one

345
00:12:17,519 --> 00:12:19,279
second so essentially their construction

346
00:12:19,279 --> 00:12:21,440
results in very compact proofs

347
00:12:21,440 --> 00:12:23,040
but they're a bit slow to generate and

348
00:12:23,040 --> 00:12:25,040
this is sort of the opposite end of the

349
00:12:25,040 --> 00:12:29,439
spectrum from what we aim to construct

350
00:12:30,240 --> 00:12:31,839
so we're left with mpc in the hair and

351
00:12:31,839 --> 00:12:33,440
garbage circuits for which there's an

352
00:12:33,440 --> 00:12:34,720
interesting detection and the work is

353
00:12:34,720 --> 00:12:38,320
zero knowledge for composite statements

354
00:12:38,320 --> 00:12:40,320
so both of these tools are known to be

355
00:12:40,320 --> 00:12:43,120
efficient for boolean circuits but not

356
00:12:43,120 --> 00:12:45,519
for algebraic operations um

357
00:12:45,519 --> 00:12:47,279
but the bridge to algebraic operations

358
00:12:47,279 --> 00:12:49,200
has been investigated in the works of

359
00:12:49,200 --> 00:12:51,680
chase ganesha rehearsal and back sounds

360
00:12:51,680 --> 00:12:54,800
like herzberg cutting and privilege

361
00:12:54,800 --> 00:12:57,200
this is a great detection since

362
00:12:57,200 --> 00:12:59,440
um aes and shah have compact boolean

363
00:12:59,440 --> 00:13:01,440
circuit representations and we require

364
00:13:01,440 --> 00:13:03,839
such a bridge to elliptical algebra fish

365
00:13:03,839 --> 00:13:06,240
oil

366
00:13:06,240 --> 00:13:08,399
our target is to achieve ideally cheap

367
00:13:08,399 --> 00:13:10,240
only cheap symmetrically operations per

368
00:13:10,240 --> 00:13:12,320
proof but existing techniques don't

369
00:13:12,320 --> 00:13:14,320
achieve this out of the box and this is

370
00:13:14,320 --> 00:13:15,760
why

371
00:13:15,760 --> 00:13:17,839
in existing works the fundamental secure

372
00:13:17,839 --> 00:13:19,519
computation object for instance the

373
00:13:19,519 --> 00:13:21,600
garbage circuit is not the actual

374
00:13:21,600 --> 00:13:23,680
dominant cost instead the dominant cost

375
00:13:23,680 --> 00:13:27,440
lies in logistics around it

376
00:13:27,440 --> 00:13:29,279
in particular the

377
00:13:29,279 --> 00:13:30,880
current techniques applied to our work

378
00:13:30,880 --> 00:13:32,240
would require

379
00:13:32,240 --> 00:13:35,040
an order of uh security parameter

380
00:13:35,040 --> 00:13:37,120
exponentiations due to homomorphic

381
00:13:37,120 --> 00:13:39,040
commitments and committed oblivious

382
00:13:39,040 --> 00:13:40,880
transfer instances that must be executed

383
00:13:40,880 --> 00:13:43,120
per bit of the witness completely this

384
00:13:43,120 --> 00:13:44,800
is in the hundreds the number of

385
00:13:44,800 --> 00:13:47,120
exponentiations

386
00:13:47,120 --> 00:13:50,000
so alternatively chase at all show how

387
00:13:50,000 --> 00:13:51,760
to replace one specific part that is the

388
00:13:51,760 --> 00:13:55,199
commitments by gobbling a gadget that

389
00:13:55,199 --> 00:13:57,760
um incurs a cost of about

390
00:13:57,760 --> 00:14:00,399
uh okay approximately quadratic in the

391
00:14:00,399 --> 00:14:01,920
normal security parameter number of

392
00:14:01,920 --> 00:14:04,720
gates which is completely more expensive

393
00:14:04,720 --> 00:14:05,839
than

394
00:14:05,839 --> 00:14:08,079
a standard prf for instance this gadget

395
00:14:08,079 --> 00:14:09,760
would concretely cost eight times as

396
00:14:09,760 --> 00:14:13,360
much as a single aes instance

397
00:14:13,360 --> 00:14:14,880
so we focus on the global circuit

398
00:14:14,880 --> 00:14:16,800
approach and develop new techniques so

399
00:14:16,800 --> 00:14:19,040
that the dominant cost of proof in this

400
00:14:19,040 --> 00:14:20,320
paradigm

401
00:14:20,320 --> 00:14:22,399
is

402
00:14:22,399 --> 00:14:24,160
just that of the secure computation

403
00:14:24,160 --> 00:14:26,560
object that is gobbling and evaluating

404
00:14:26,560 --> 00:14:30,518
the pseudonym function

405
00:14:30,800 --> 00:14:34,160
so we make use of the zkgc paradigm of

406
00:14:34,160 --> 00:14:36,320
javadecor formula landi i won't recall

407
00:14:36,320 --> 00:14:38,240
that protocol in the interest of time

408
00:14:38,240 --> 00:14:40,560
but our contributions can be understood

409
00:14:40,560 --> 00:14:42,639
independently of ckgc if you're

410
00:14:42,639 --> 00:14:43,760
interested in learning how these

411
00:14:43,760 --> 00:14:45,360
techniques were in context i encourage

412
00:14:45,360 --> 00:14:47,199
you to take a look at our paper

413
00:14:47,199 --> 00:14:49,120
we also use the conditional

414
00:14:49,120 --> 00:14:51,279
conditional disclosure down compression

415
00:14:51,279 --> 00:14:53,440
technique of ganesh myself path transfer

416
00:14:53,440 --> 00:14:55,680
god

417
00:14:55,760 --> 00:14:57,040
so we developed the following new

418
00:14:57,040 --> 00:14:58,399
techniques to tailor and improve this

419
00:14:58,399 --> 00:15:00,000
paradigm

420
00:15:00,000 --> 00:15:02,079
firstly a goblin gadget to output the

421
00:15:02,079 --> 00:15:04,160
exponentiation of an encoded input which

422
00:15:04,160 --> 00:15:07,839
improves an equivalent gadget in

423
00:15:07,839 --> 00:15:10,160
the work of chase and others

424
00:15:10,160 --> 00:15:11,440
and also applies to anonymous

425
00:15:11,440 --> 00:15:12,560
credentials

426
00:15:12,560 --> 00:15:14,240
additionally we construct a custom

427
00:15:14,240 --> 00:15:16,079
committed ot protocol that allows us to

428
00:15:16,079 --> 00:15:18,480
pre-process most of most of almost all

429
00:15:18,480 --> 00:15:20,560
of the other key operations

430
00:15:20,560 --> 00:15:22,399
so this makes input encoding now cheaper

431
00:15:22,399 --> 00:15:24,000
than coupling the

432
00:15:24,000 --> 00:15:25,600
random function and it also finds

433
00:15:25,600 --> 00:15:27,360
application in the distributed symmetric

434
00:15:27,360 --> 00:15:29,839
key encryption

435
00:15:29,839 --> 00:15:31,759
so we face the task at hand as doubling

436
00:15:31,759 --> 00:15:33,839
the circuit c that can be expressed as

437
00:15:33,839 --> 00:15:35,440
fee applied to f

438
00:15:35,440 --> 00:15:37,440
where f is a boolean circuit and phi

439
00:15:37,440 --> 00:15:39,279
takes in the bit representation of some

440
00:15:39,279 --> 00:15:41,360
data bit value y and outputs the

441
00:15:41,360 --> 00:15:44,399
elliptic curve point y times g

442
00:15:44,399 --> 00:15:46,160
so consider the standard sequence in

443
00:15:46,160 --> 00:15:48,639
goblin circuit that is producing the

444
00:15:48,639 --> 00:15:52,079
values that we have on screen

445
00:15:52,079 --> 00:15:53,680
and putting them into the correct

446
00:15:53,680 --> 00:15:57,440
algorithms so we start with the

447
00:15:57,440 --> 00:16:00,320
with the composition of the input x

448
00:16:00,320 --> 00:16:02,399
and then we encode it using these

449
00:16:02,399 --> 00:16:04,720
capital x values let's simply just

450
00:16:04,720 --> 00:16:06,480
choosing the appropriate capital x

451
00:16:06,480 --> 00:16:08,800
values we evaluate them with the global

452
00:16:08,800 --> 00:16:10,800
circuit c tilde to obtain and encode it

453
00:16:10,800 --> 00:16:12,880
out with z tilde which can then be

454
00:16:12,880 --> 00:16:15,120
decoded to get the clear outcome

455
00:16:15,120 --> 00:16:18,399
z of the computation

456
00:16:19,279 --> 00:16:21,519
so looking after the hood we split c

457
00:16:21,519 --> 00:16:23,839
tilde into two distinct components f

458
00:16:23,839 --> 00:16:25,839
tilde that's the goblin of the boolean

459
00:16:25,839 --> 00:16:27,519
circuit f and phi delta that's the

460
00:16:27,519 --> 00:16:30,240
goblin of the exponentiation gadget so f

461
00:16:30,240 --> 00:16:32,480
tilde receives as input x produces an

462
00:16:32,480 --> 00:16:34,880
intermediate set of y labels capital y

463
00:16:34,880 --> 00:16:36,399
that corresponds to the intermediate

464
00:16:36,399 --> 00:16:38,079
string y

465
00:16:38,079 --> 00:16:40,320
and v tilde translates this

466
00:16:40,320 --> 00:16:42,320
capital y into

467
00:16:42,320 --> 00:16:45,040
the encoded output z tilde

468
00:16:45,040 --> 00:16:47,600
so we can use any standard goblin scheme

469
00:16:47,600 --> 00:16:48,560
for

470
00:16:48,560 --> 00:16:50,800
boolean circles to produce f tilde think

471
00:16:50,800 --> 00:16:52,480
of half gates for instance

472
00:16:52,480 --> 00:16:54,720
and for feed tilde we construct a new

473
00:16:54,720 --> 00:16:56,560
gadget that's inspired by the oblivious

474
00:16:56,560 --> 00:17:00,560
linear evaluation technique of gilboa

475
00:17:01,120 --> 00:17:02,480
at a high level

476
00:17:02,480 --> 00:17:05,760
the idea is to begin by sampling

477
00:17:05,760 --> 00:17:07,760
a random beta and a bunch of alpha

478
00:17:07,760 --> 00:17:10,160
values and we define alpha to be the sum

479
00:17:10,160 --> 00:17:12,959
of all the alpha alpha values

480
00:17:12,959 --> 00:17:14,640
so the garbage circuit itself is going

481
00:17:14,640 --> 00:17:16,880
to be a collection of ciphertext pairs

482
00:17:16,880 --> 00:17:19,280
they're structured in such a way that um

483
00:17:19,280 --> 00:17:21,439
the nth pair allows the evaluator to

484
00:17:21,439 --> 00:17:25,280
decrypt alpha n times yn times 2 to the

485
00:17:25,280 --> 00:17:26,799
n times beta

486
00:17:26,799 --> 00:17:28,799
the idea here is that when you add all

487
00:17:28,799 --> 00:17:30,160
of these up

488
00:17:30,160 --> 00:17:33,200
we obtain alpha plus y times beta

489
00:17:33,200 --> 00:17:34,880
which to give the name let's call it z

490
00:17:34,880 --> 00:17:36,000
tilde

491
00:17:36,000 --> 00:17:37,200
lowercase

492
00:17:37,200 --> 00:17:39,280
now multiplying little z tilde by g

493
00:17:39,280 --> 00:17:41,120
gives us the full encoded output capital

494
00:17:41,120 --> 00:17:43,760
z delta which can easily be decoded by

495
00:17:43,760 --> 00:17:45,919
subtracting out alpha and dividing our

496
00:17:45,919 --> 00:17:48,320
beta

497
00:17:50,160 --> 00:17:52,160
so the intuition for security is that

498
00:17:52,160 --> 00:17:54,320
first authenticity of the goblet circuit

499
00:17:54,320 --> 00:17:56,320
which corresponds to soundness of the

500
00:17:56,320 --> 00:17:58,880
zkgtc group comes from the fact that the

501
00:17:58,880 --> 00:18:00,799
mechanism with alpha and beta serves as

502
00:18:00,799 --> 00:18:03,280
an information theoretic mac so forgery

503
00:18:03,280 --> 00:18:04,720
is as hard as either guessing these

504
00:18:04,720 --> 00:18:08,480
values or breaking the encryption scheme

505
00:18:08,480 --> 00:18:10,080
uniqueness for the coupled output which

506
00:18:10,080 --> 00:18:12,240
is what gives us zero knowledge the zkgc

507
00:18:12,240 --> 00:18:14,160
proof comes with the fact that once

508
00:18:14,160 --> 00:18:16,960
alpha beta and z are fixed we can

509
00:18:16,960 --> 00:18:19,440
simulate z tilde perfectly

510
00:18:19,440 --> 00:18:21,440
essentially this technique is very very

511
00:18:21,440 --> 00:18:23,679
similar to simulating a signature

512
00:18:23,679 --> 00:18:26,480
original proof of knowledge

513
00:18:26,480 --> 00:18:28,240
as for efficiency this gadget is

514
00:18:28,240 --> 00:18:30,720
equivalent to goblin 2 log q amp case

515
00:18:30,720 --> 00:18:32,640
which is a substantial improvement over

516
00:18:32,640 --> 00:18:35,280
similar over a similar gadget from prior

517
00:18:35,280 --> 00:18:36,559
work

518
00:18:36,559 --> 00:18:39,440
so the result of this is that the cost

519
00:18:39,440 --> 00:18:41,760
of this particular operation

520
00:18:41,760 --> 00:18:42,960
is

521
00:18:42,960 --> 00:18:45,200
now insignificant compared to

522
00:18:45,200 --> 00:18:47,039
the cost of gobbling the prf circuit

523
00:18:47,039 --> 00:18:48,880
itself so we've eliminated one of the

524
00:18:48,880 --> 00:18:51,840
logistical costs

525
00:18:52,160 --> 00:18:53,679
so now we turn to the other dominant

526
00:18:53,679 --> 00:18:55,840
logistical cost that is committed ot of

527
00:18:55,840 --> 00:18:57,600
which one instance is needed for each

528
00:18:57,600 --> 00:18:59,840
bit of the witness

529
00:18:59,840 --> 00:19:01,280
so the additional instruction that

530
00:19:01,280 --> 00:19:03,840
committed ot offers on top of regular ot

531
00:19:03,840 --> 00:19:06,480
is the ability to open both messages

532
00:19:06,480 --> 00:19:09,280
that the sender had sent earlier

533
00:19:09,280 --> 00:19:10,880
unfortunately it's unclear how to

534
00:19:10,880 --> 00:19:12,640
pre-process public key operations to

535
00:19:12,640 --> 00:19:14,720
committed ot in such a way that the

536
00:19:14,720 --> 00:19:16,640
online phase is efficient which in our

537
00:19:16,640 --> 00:19:17,840
setting is going to be essentially

538
00:19:17,840 --> 00:19:19,120
non-interactive

539
00:19:19,120 --> 00:19:21,360
and the correlations are still usable

540
00:19:21,360 --> 00:19:24,559
after executing the open phase

541
00:19:24,559 --> 00:19:26,000
so we relax the problem a bit by

542
00:19:26,000 --> 00:19:27,679
tailoring it to our setting that is we

543
00:19:27,679 --> 00:19:29,440
want the receiver to input its choice

544
00:19:29,440 --> 00:19:31,360
bit once and then we want an unbounded

545
00:19:31,360 --> 00:19:32,880
number of instances with this fixed

546
00:19:32,880 --> 00:19:34,480
choice bit thereafter

547
00:19:34,480 --> 00:19:36,240
this is fine in our setting because the

548
00:19:36,240 --> 00:19:37,280
witness

549
00:19:37,280 --> 00:19:39,919
is the prs feed and it's going to be the

550
00:19:39,919 --> 00:19:42,880
same for all groups

551
00:19:43,280 --> 00:19:44,960
let's try a naive attempt to solving

552
00:19:44,960 --> 00:19:46,880
this problem we can have the sender

553
00:19:46,880 --> 00:19:50,000
sample some seeds um zero and one which

554
00:19:50,000 --> 00:19:53,520
it provides to the ot and the receiver

555
00:19:53,520 --> 00:19:55,520
retrieves the seed corresponding to its

556
00:19:55,520 --> 00:19:57,039
choice that b

557
00:19:57,039 --> 00:20:00,160
so online given some instance x

558
00:20:00,160 --> 00:20:03,360
the sender will compute pads p0 and p1

559
00:20:03,360 --> 00:20:04,640
by applying

560
00:20:04,640 --> 00:20:08,159
the prf on its respective seats on x

561
00:20:08,159 --> 00:20:10,799
and then it's going to use p0 and p1 as

562
00:20:10,799 --> 00:20:14,480
pads to encrypt messages n0 m1

563
00:20:14,480 --> 00:20:16,320
so of the two of these the receiver is

564
00:20:16,320 --> 00:20:17,679
able to decrypt the message

565
00:20:17,679 --> 00:20:20,000
corresponding to its choice but b as it

566
00:20:20,000 --> 00:20:22,720
has the seed for that message

567
00:20:22,720 --> 00:20:25,200
during the open phase the

568
00:20:25,200 --> 00:20:27,120
center simply provides the pads that it

569
00:20:27,120 --> 00:20:29,840
had sampled that it computed earlier

570
00:20:29,840 --> 00:20:33,280
and the receiver is able to then decrypt

571
00:20:33,280 --> 00:20:35,360
the ciphertext that it wasn't able to

572
00:20:35,360 --> 00:20:36,880
decrypt earlier and retrieve the

573
00:20:36,880 --> 00:20:39,600
opposite message

574
00:20:39,600 --> 00:20:41,679
so to see what goes wrong let's see what

575
00:20:41,679 --> 00:20:44,720
happens when the sender is corrupted

576
00:20:44,720 --> 00:20:46,240
so let's fix a concrete bit for the

577
00:20:46,240 --> 00:20:48,640
receiver let's say zero

578
00:20:48,640 --> 00:20:51,760
now the sender can simply change its

579
00:20:51,760 --> 00:20:54,400
claimed pad p1 in the open phase to some

580
00:20:54,400 --> 00:20:55,600
p star

581
00:20:55,600 --> 00:20:57,679
which then tricks the receiver into

582
00:20:57,679 --> 00:20:59,919
thinking that the the message that

583
00:20:59,919 --> 00:21:01,760
it couldn't decrypt earlier was instead

584
00:21:01,760 --> 00:21:04,799
some m1 star

585
00:21:05,120 --> 00:21:07,840
so this error propagates upwards in the

586
00:21:07,840 --> 00:21:10,320
ckgc protocol so we can solve this

587
00:21:10,320 --> 00:21:12,159
problem using universally composable

588
00:21:12,159 --> 00:21:13,679
commitments

589
00:21:13,679 --> 00:21:15,679
specifically we use you see commitments

590
00:21:15,679 --> 00:21:18,080
that permit the following algorithms

591
00:21:18,080 --> 00:21:20,480
first a setup that produces a tactile a

592
00:21:20,480 --> 00:21:22,799
commitment key and a verification key a

593
00:21:22,799 --> 00:21:24,640
commitment algorithm that produces a

594
00:21:24,640 --> 00:21:25,919
commitment and some decommitment

595
00:21:25,919 --> 00:21:27,440
information and of course a method to

596
00:21:27,440 --> 00:21:29,280
verify this

597
00:21:29,280 --> 00:21:31,280
and finally a straight line algorithm

598
00:21:31,280 --> 00:21:33,120
that extracts the committed message

599
00:21:33,120 --> 00:21:36,158
given the chapter

600
00:21:36,480 --> 00:21:38,559
conventionally this extractor is simply

601
00:21:38,559 --> 00:21:41,360
a proof artifact but in our case we're

602
00:21:41,360 --> 00:21:43,120
actually going to execute this proof

603
00:21:43,120 --> 00:21:46,399
artifact in our construction

604
00:21:47,679 --> 00:21:49,120
so once we have this abstraction in

605
00:21:49,120 --> 00:21:50,880
place constructing the committed ot

606
00:21:50,880 --> 00:21:53,360
protocol is quite simple

607
00:21:53,360 --> 00:21:54,480
we

608
00:21:54,480 --> 00:21:57,440
have a setup functionality that provides

609
00:21:57,440 --> 00:22:00,400
two commitment keys to the sender

610
00:22:00,400 --> 00:22:02,159
and the corresponding verification keys

611
00:22:02,159 --> 00:22:04,000
to the receiver and additionally the

612
00:22:04,000 --> 00:22:06,480
receiver can choose the trapdoor for one

613
00:22:06,480 --> 00:22:10,080
of these two commitment keys

614
00:22:10,480 --> 00:22:12,640
so in order to send a message

615
00:22:12,640 --> 00:22:14,640
the sender commits

616
00:22:14,640 --> 00:22:15,600
um

617
00:22:15,600 --> 00:22:17,360
to a message is m0 m1 using the

618
00:22:17,360 --> 00:22:19,280
corresponding commitment keys and sends

619
00:22:19,280 --> 00:22:21,360
over these commitments to the receiver

620
00:22:21,360 --> 00:22:22,720
who then runs the straight line

621
00:22:22,720 --> 00:22:24,880
extractor in order to retrieve the

622
00:22:24,880 --> 00:22:28,240
message that it wanted to choose

623
00:22:29,360 --> 00:22:31,440
during the open phase the sender now

624
00:22:31,440 --> 00:22:32,799
sends

625
00:22:32,799 --> 00:22:34,640
on the commitment information for both

626
00:22:34,640 --> 00:22:37,280
of the messages

627
00:22:37,600 --> 00:22:40,000
the receiver is able to verify that

628
00:22:40,000 --> 00:22:41,840
these messages were indeed the ones that

629
00:22:41,840 --> 00:22:44,959
were committed to earlier

630
00:22:45,679 --> 00:22:46,799
so

631
00:22:46,799 --> 00:22:48,640
security for this construction follows

632
00:22:48,640 --> 00:22:50,559
directly from straight line extraction

633
00:22:50,559 --> 00:22:52,320
and equivocability of the commitment

634
00:22:52,320 --> 00:22:53,440
scheme

635
00:22:53,440 --> 00:22:55,200
and we instantiate this commitment

636
00:22:55,200 --> 00:22:57,200
scheme using ideas from the literature

637
00:22:57,200 --> 00:22:59,360
on uc commitments from error correcting

638
00:22:59,360 --> 00:23:01,760
codes of course we have to do some extra

639
00:23:01,760 --> 00:23:05,520
work to obtain stateless determinism

640
00:23:05,760 --> 00:23:08,240
so committing verifying and extraction

641
00:23:08,240 --> 00:23:10,799
requires only prf evaluations which is

642
00:23:10,799 --> 00:23:12,640
really nice and some hashing and this

643
00:23:12,640 --> 00:23:14,000
translates to

644
00:23:14,000 --> 00:23:15,600
really good efficiency and the online

645
00:23:15,600 --> 00:23:17,520
complexity of committed ot which is what

646
00:23:17,520 --> 00:23:19,840
we were looking for

647
00:23:19,840 --> 00:23:21,760
so concretely for the parameters that we

648
00:23:21,760 --> 00:23:22,960
care about you can think of the

649
00:23:22,960 --> 00:23:25,360
computation and bandwidth cost is about

650
00:23:25,360 --> 00:23:27,039
the same as gobbling a single aes

651
00:23:27,039 --> 00:23:29,520
circuit which is significantly cheaper

652
00:23:29,520 --> 00:23:31,760
than actually gobbling aes for the prf

653
00:23:31,760 --> 00:23:33,120
because we will need multiple aes

654
00:23:33,120 --> 00:23:37,799
invocations to dive in on bias mods

655
00:23:38,400 --> 00:23:39,760
so in summary

656
00:23:39,760 --> 00:23:42,080
we showed that the zkgc paradigm is well

657
00:23:42,080 --> 00:23:44,080
suited to enabling status determinism

658
00:23:44,080 --> 00:23:46,320
threshold small when we care about

659
00:23:46,320 --> 00:23:47,919
computational efficiency and standard

660
00:23:47,919 --> 00:23:49,679
assumptions

661
00:23:49,679 --> 00:23:51,679
the dominant cost of previous techniques

662
00:23:51,679 --> 00:23:53,679
applied to our setting was mostly in the

663
00:23:53,679 --> 00:23:56,640
logistics rather than the

664
00:23:56,640 --> 00:23:59,200
actual secure computation object

665
00:23:59,200 --> 00:24:00,080
which

666
00:24:00,080 --> 00:24:02,000
we developed new techniques to fix so

667
00:24:02,000 --> 00:24:03,440
that the dominant cost is now just a

668
00:24:03,440 --> 00:24:05,200
secure computation object that's

669
00:24:05,200 --> 00:24:08,720
gobbling and evaluating the prf

670
00:24:08,960 --> 00:24:10,320
so our

671
00:24:10,320 --> 00:24:12,880
cost analysis estimates that the

672
00:24:12,880 --> 00:24:14,880
computation of our construction should

673
00:24:14,880 --> 00:24:15,760
be

674
00:24:15,760 --> 00:24:17,520
considerably faster than using trusted

675
00:24:17,520 --> 00:24:19,840
hardware

676
00:24:20,000 --> 00:24:21,679
so i encourage you to look at the paper

677
00:24:21,679 --> 00:24:22,720
for

678
00:24:22,720 --> 00:24:24,559
a concrete cost analysis a number of

679
00:24:24,559 --> 00:24:26,159
optimizations and tricks and of course

680
00:24:26,159 --> 00:24:28,880
details on the high level ideas that i

681
00:24:28,880 --> 00:24:31,520
uh spoke about

682
00:24:31,520 --> 00:24:33,200
thanks for your attention i hope i

683
00:24:33,200 --> 00:24:34,880
motivated you to read our paper which

684
00:24:34,880 --> 00:24:36,880
can be found on my homepage and please

685
00:24:36,880 --> 00:24:39,279
feel free to email me with any questions

686
00:24:39,279 --> 00:24:42,279
thanks

