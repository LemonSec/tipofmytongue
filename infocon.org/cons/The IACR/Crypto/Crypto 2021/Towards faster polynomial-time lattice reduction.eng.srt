1
00:00:01,520 --> 00:00:03,840
hi everyone thomas here i'm glad to

2
00:00:03,840 --> 00:00:06,080
present you some new results uh on first

3
00:00:06,080 --> 00:00:07,839
european real time lattice reduction

4
00:00:07,839 --> 00:00:10,480
algorithms this is joint work with my

5
00:00:10,480 --> 00:00:12,719
colleagues paul keshner and karana from

6
00:00:12,719 --> 00:00:14,799
indriyan

7
00:00:14,799 --> 00:00:16,960
so first of all let me uh

8
00:00:16,960 --> 00:00:19,520
make some recalls on lattices and on the

9
00:00:19,520 --> 00:00:21,520
led algorithm

10
00:00:21,520 --> 00:00:22,480
so

11
00:00:22,480 --> 00:00:25,680
what are we working with here so to set

12
00:00:25,680 --> 00:00:27,760
up some uh setting

13
00:00:27,760 --> 00:00:29,599
suppose that we are taking the euclidean

14
00:00:29,599 --> 00:00:30,560
space

15
00:00:30,560 --> 00:00:33,280
here r2 and take a bunch of linearly

16
00:00:33,280 --> 00:00:36,320
independent vectors in this space

17
00:00:36,320 --> 00:00:38,160
then consider

18
00:00:38,160 --> 00:00:40,719
the set of all possible integral linear

19
00:00:40,719 --> 00:00:43,520
combination of these vectors you get a

20
00:00:43,520 --> 00:00:44,879
very regular structure which is

21
00:00:44,879 --> 00:00:48,079
reminiscent of a grid in high dimension

22
00:00:48,079 --> 00:00:49,280
and

23
00:00:49,280 --> 00:00:52,719
it has actually the structure of a group

24
00:00:52,719 --> 00:00:55,280
as such it's a subgroup of the euclidean

25
00:00:55,280 --> 00:00:58,960
space and by construction it's discrete

26
00:00:58,960 --> 00:00:59,760
this

27
00:00:59,760 --> 00:01:04,239
algebraic structure is called a lattice

28
00:01:04,400 --> 00:01:07,920
in lattice you might want to measure

29
00:01:07,920 --> 00:01:08,960
the

30
00:01:08,960 --> 00:01:10,960
density of points

31
00:01:10,960 --> 00:01:12,720
in your structure and for that you use a

32
00:01:12,720 --> 00:01:15,040
geometric invariant which is called the

33
00:01:15,040 --> 00:01:17,439
curve volume it can be computed from

34
00:01:17,439 --> 00:01:19,680
your basis vector as a

35
00:01:19,680 --> 00:01:22,320
root of the determinant of the crime

36
00:01:22,320 --> 00:01:24,720
matrix that says the matrix of inner

37
00:01:24,720 --> 00:01:27,119
products of your vectors

38
00:01:27,119 --> 00:01:29,200
it also corresponds to

39
00:01:29,200 --> 00:01:32,159
the volume of the polyp that is

40
00:01:32,159 --> 00:01:34,079
spanned by your vectors

41
00:01:34,079 --> 00:01:35,759
i say it's a geometric invariant because

42
00:01:35,759 --> 00:01:37,759
it's invariant

43
00:01:37,759 --> 00:01:42,000
under a change of basis it's independent

44
00:01:42,000 --> 00:01:42,880
um

45
00:01:42,880 --> 00:01:44,399
actually so i'm speaking of having

46
00:01:44,399 --> 00:01:46,880
multiple bases in your lattice uh so

47
00:01:46,880 --> 00:01:50,000
that the question is how can i get from

48
00:01:50,000 --> 00:01:52,799
a screw one a very bad one to a nice one

49
00:01:52,799 --> 00:01:54,880
like the first one i showed

50
00:01:54,880 --> 00:01:56,640
uh assumption to do that at least in

51
00:01:56,640 --> 00:01:59,759
dimension two is to use the shortest

52
00:01:59,759 --> 00:02:02,240
vector to you to reduce the length of

53
00:02:02,240 --> 00:02:03,920
the longest one

54
00:02:03,920 --> 00:02:06,479
more precisely uh you take the shortest

55
00:02:06,479 --> 00:02:09,520
element in the coset which is panned by

56
00:02:09,520 --> 00:02:11,200
the short vector and get through the

57
00:02:11,200 --> 00:02:12,480
long one

58
00:02:12,480 --> 00:02:14,480
and then you get a shorter vector and

59
00:02:14,480 --> 00:02:16,879
then you repeat as long as you can

60
00:02:16,879 --> 00:02:20,239
and at one point this process will stop

61
00:02:20,239 --> 00:02:22,879
this is in substance uh the so-called

62
00:02:22,879 --> 00:02:25,840
lagrange gauss reduction algorithm

63
00:02:25,840 --> 00:02:27,920
and this algorithm has very

64
00:02:27,920 --> 00:02:30,319
interesting properties in particular the

65
00:02:30,319 --> 00:02:33,440
output basis satisfy that the first

66
00:02:33,440 --> 00:02:36,959
vector is one of the shortest vector of

67
00:02:36,959 --> 00:02:38,800
the lattice

68
00:02:38,800 --> 00:02:41,440
moreover you can prove from that that

69
00:02:41,440 --> 00:02:45,280
the length of this shortest vector is

70
00:02:45,280 --> 00:02:48,000
smaller than four thirds of the

71
00:02:48,000 --> 00:02:50,560
co-volume of the lattice which is a

72
00:02:50,560 --> 00:02:52,640
constant which is independent of the

73
00:02:52,640 --> 00:02:54,480
lattice itself

74
00:02:54,480 --> 00:02:56,959
more generally speaking in any dimension

75
00:02:56,959 --> 00:02:58,640
in your rank

76
00:02:58,640 --> 00:03:01,120
we get the following theorem which is

77
00:03:01,120 --> 00:03:02,800
minkowski hermet theorem for first

78
00:03:02,800 --> 00:03:05,440
minima which asserts that for in the

79
00:03:05,440 --> 00:03:08,080
lattice lambda of rank d the length of

80
00:03:08,080 --> 00:03:11,120
the shortest vector will be smaller than

81
00:03:11,120 --> 00:03:12,959
some constant which only depends on the

82
00:03:12,959 --> 00:03:14,400
dimension multiplied by the

83
00:03:14,400 --> 00:03:18,480
normalization of the covalent

84
00:03:18,480 --> 00:03:19,840
so

85
00:03:19,840 --> 00:03:22,239
we know that such short vectors exist

86
00:03:22,239 --> 00:03:24,959
however finding them algorithmically is

87
00:03:24,959 --> 00:03:27,360
a hard problem has been proved to be np

88
00:03:27,360 --> 00:03:28,400
hard

89
00:03:28,400 --> 00:03:30,879
however in 82 let's try lens trend

90
00:03:30,879 --> 00:03:32,400
lovatch

91
00:03:32,400 --> 00:03:34,159
show that there exists some polynomial

92
00:03:34,159 --> 00:03:36,640
time algorithms with given any lattice

93
00:03:36,640 --> 00:03:40,159
lambda will give you some lattice vector

94
00:03:40,159 --> 00:03:42,879
of length at most 2 to the n times

95
00:03:42,879 --> 00:03:44,720
longer than the length of the shortest

96
00:03:44,720 --> 00:03:46,480
vector

97
00:03:46,480 --> 00:03:50,080
it might seem pretty big but actually

98
00:03:50,080 --> 00:03:53,519
this lll algorithm is quite useful for

99
00:03:53,519 --> 00:03:55,840
instance we can solve the cement

100
00:03:55,840 --> 00:03:57,920
simultaneous difference in approximation

101
00:03:57,920 --> 00:04:00,720
problems which is finding an

102
00:04:00,720 --> 00:04:03,120
approximation with rational of real

103
00:04:03,120 --> 00:04:05,200
numbers with common denominators

104
00:04:05,200 --> 00:04:06,879
from that you can

105
00:04:06,879 --> 00:04:08,879
use the same method to find the minimal

106
00:04:08,879 --> 00:04:12,159
polynomial of algebraic numbers

107
00:04:12,159 --> 00:04:13,920
you can factorize over rationals that

108
00:04:13,920 --> 00:04:15,120
was the original application of

109
00:04:15,120 --> 00:04:17,519
alexander's friend lavatch and of course

110
00:04:17,519 --> 00:04:19,759
you can do crypt analysis with that and

111
00:04:19,759 --> 00:04:21,759
that might what interests me the most uh

112
00:04:21,759 --> 00:04:23,840
in the context of this conference

113
00:04:23,840 --> 00:04:25,440
for instance you can solve knapsack

114
00:04:25,440 --> 00:04:27,759
problems in very specific settings you

115
00:04:27,759 --> 00:04:31,600
can break rsa with public exponent

116
00:04:31,600 --> 00:04:32,479
and

117
00:04:32,479 --> 00:04:34,160
you can also

118
00:04:34,160 --> 00:04:35,840
of course

119
00:04:35,840 --> 00:04:38,960
attack lattice-based cryptography

120
00:04:38,960 --> 00:04:40,840
moreover you can

121
00:04:40,840 --> 00:04:41,840
also uh

122
00:04:41,840 --> 00:04:43,759
help computation in algebraic number

123
00:04:43,759 --> 00:04:45,759
theory in particular it's very important

124
00:04:45,759 --> 00:04:46,880
in uh

125
00:04:46,880 --> 00:04:49,360
normal form computation uh working with

126
00:04:49,360 --> 00:04:52,560
ideals and also to control the size of

127
00:04:52,560 --> 00:04:54,320
elements appearing in your computation

128
00:04:54,320 --> 00:04:57,600
and ensures polynomial time

129
00:04:57,600 --> 00:05:01,440
so let's see how we can construct this

130
00:05:01,440 --> 00:05:04,240
uh reconstruct let's say this uh lll

131
00:05:04,240 --> 00:05:05,360
algorithm

132
00:05:05,360 --> 00:05:07,840
so first of all if you take any basis uh

133
00:05:07,840 --> 00:05:09,759
let's say v1 to vd of your lattice

134
00:05:09,759 --> 00:05:12,800
lambda then you get a filtration from

135
00:05:12,800 --> 00:05:15,840
that basis uh constructed as follows you

136
00:05:15,840 --> 00:05:17,759
start from the sublet is zero and then

137
00:05:17,759 --> 00:05:19,440
you go to your lambda one which is the

138
00:05:19,440 --> 00:05:22,639
lattice span by v1 then lambda2 span by

139
00:05:22,639 --> 00:05:24,880
v1 v2 and

140
00:05:24,880 --> 00:05:27,280
so on until you reach the full lattice

141
00:05:27,280 --> 00:05:30,400
so you get an increasing sequence of

142
00:05:30,400 --> 00:05:32,960
sub-lattices

143
00:05:32,960 --> 00:05:35,680
now you might want to quantify the

144
00:05:35,680 --> 00:05:38,400
quality of your filtration and to do so

145
00:05:38,400 --> 00:05:40,880
we do a bit of quantization how we do

146
00:05:40,880 --> 00:05:44,880
that we basically uh use this co volume

147
00:05:44,880 --> 00:05:46,560
actually we're using the degree here

148
00:05:46,560 --> 00:05:49,280
which is a logarithm of the covolume of

149
00:05:49,280 --> 00:05:51,440
each of the sub lattices appearing in

150
00:05:51,440 --> 00:05:55,039
the filtration so then you get

151
00:05:55,039 --> 00:05:57,680
some bunch of real numbers which

152
00:05:57,680 --> 00:06:00,160
corresponds to the degree of each

153
00:06:00,160 --> 00:06:04,000
element appearing in your filtration

154
00:06:04,000 --> 00:06:05,199
now

155
00:06:05,199 --> 00:06:08,479
we should we we we've seen that we the

156
00:06:08,479 --> 00:06:12,000
gauss reduction algorithm uh helps to

157
00:06:12,000 --> 00:06:14,319
reduce lattice in dimension too but

158
00:06:14,319 --> 00:06:16,880
given a filtration we get a bunch of

159
00:06:16,880 --> 00:06:19,600
rank two lattices actually all of the

160
00:06:19,600 --> 00:06:22,319
quotients lambda i plus 1 over lambda i

161
00:06:22,319 --> 00:06:25,600
minus 1 actually of rank 2 so that we

162
00:06:25,600 --> 00:06:27,919
can use gauss-reduction algorithm on

163
00:06:27,919 --> 00:06:29,280
these quotients

164
00:06:29,280 --> 00:06:31,120
more precisely what we're going to do is

165
00:06:31,120 --> 00:06:34,319
to use the gauss gaussian algorithm on

166
00:06:34,319 --> 00:06:36,639
the projected sublet is corresponding to

167
00:06:36,639 --> 00:06:38,800
this quotient then lifts a result and

168
00:06:38,800 --> 00:06:41,280
replace in our basis and marginally

169
00:06:41,280 --> 00:06:44,319
replacing the corresponding filtration

170
00:06:44,319 --> 00:06:46,000
if we look at the effect of this

171
00:06:46,000 --> 00:06:50,000
operation let's say i place i

172
00:06:50,000 --> 00:06:53,440
then we can easily see that the all the

173
00:06:53,440 --> 00:06:56,319
degrees are invariants except the degree

174
00:06:56,319 --> 00:06:58,720
of lambda i which is replaced by say

175
00:06:58,720 --> 00:07:00,960
lambda i prime and in particular we can

176
00:07:00,960 --> 00:07:03,680
show that this new degree lambda a prime

177
00:07:03,680 --> 00:07:06,479
is smaller than the previous one

178
00:07:06,479 --> 00:07:09,520
so at all in all the gauss reduction is

179
00:07:09,520 --> 00:07:11,440
a local tool because we're only applying

180
00:07:11,440 --> 00:07:13,360
it in a very specific position of the

181
00:07:13,360 --> 00:07:16,400
filtration to densify it that reducing

182
00:07:16,400 --> 00:07:18,080
the equivalent

183
00:07:18,080 --> 00:07:20,960
okay so now from that observation we can

184
00:07:20,960 --> 00:07:22,960
construct a simple iterative algorithm

185
00:07:22,960 --> 00:07:26,800
that will do gauss reduction steps as

186
00:07:26,800 --> 00:07:29,039
much as it's possible

187
00:07:29,039 --> 00:07:30,960
and from that we just start from the

188
00:07:30,960 --> 00:07:33,199
beginning of the basis so let's say the

189
00:07:33,199 --> 00:07:36,319
first two vectors and then we move on to

190
00:07:36,319 --> 00:07:37,199
the

191
00:07:37,199 --> 00:07:39,680
third second and third and so on but

192
00:07:39,680 --> 00:07:41,280
maybe doing so

193
00:07:41,280 --> 00:07:44,160
uh will help to reduce the already

194
00:07:44,160 --> 00:07:45,919
previously reduced first second and

195
00:07:45,919 --> 00:07:48,240
third breakers so that maybe we need to

196
00:07:48,240 --> 00:07:51,360
redo a step of reduction uh earlier on

197
00:07:51,360 --> 00:07:53,919
and so we then continue go on and might

198
00:07:53,919 --> 00:07:56,639
be go back and go on and so on but in

199
00:07:56,639 --> 00:07:59,360
the end we will finish by reaching the

200
00:07:59,360 --> 00:08:02,160
end of the basis and no more

201
00:08:02,160 --> 00:08:05,280
gauss step can be done anywhere else in

202
00:08:05,280 --> 00:08:06,960
that case we say that the basis is a

203
00:08:06,960 --> 00:08:08,400
little reduced

204
00:08:08,400 --> 00:08:10,160
if we analyze

205
00:08:10,160 --> 00:08:14,000
this algorithm we will find uh some

206
00:08:14,000 --> 00:08:17,440
dependency which is 60 in the rank and

207
00:08:17,440 --> 00:08:19,840
which is cubic in the size of the

208
00:08:19,840 --> 00:08:21,680
integers

209
00:08:21,680 --> 00:08:24,879
however if we are precocious enough we

210
00:08:24,879 --> 00:08:27,039
can use floating point arithmetic

211
00:08:27,039 --> 00:08:30,080
instead of exact arithmetic and that was

212
00:08:30,080 --> 00:08:32,958
a first step made by ingrian and stele

213
00:08:32,958 --> 00:08:33,719
in

214
00:08:33,719 --> 00:08:35,599
2009

215
00:08:35,599 --> 00:08:37,919
where they showed that we can do ll

216
00:08:37,919 --> 00:08:40,000
reduction which dependency which is

217
00:08:40,000 --> 00:08:42,958
quadratic in the logarithm of the size

218
00:08:42,958 --> 00:08:45,519
of the elements appearing in your basis

219
00:08:45,519 --> 00:08:47,120
more

220
00:08:47,120 --> 00:08:48,240
recently

221
00:08:48,240 --> 00:08:51,040
numero and stele showed that with some

222
00:08:51,040 --> 00:08:54,560
recursive strategy you can go down to

223
00:08:54,560 --> 00:08:57,360
some kartik or quasi-kartik dependency

224
00:08:57,360 --> 00:08:59,519
inter-dimension and quasi-linear

225
00:08:59,519 --> 00:09:01,760
dependency in the logarithm

226
00:09:01,760 --> 00:09:05,040
however uh this algorithm is purely

227
00:09:05,040 --> 00:09:07,120
theoretical and the constant bearings of

228
00:09:07,120 --> 00:09:09,120
bigo are too big to be

229
00:09:09,120 --> 00:09:12,399
concretely implemented

230
00:09:13,200 --> 00:09:15,360
the question is now

231
00:09:15,360 --> 00:09:17,560
how can we improve this

232
00:09:17,560 --> 00:09:19,920
quasi-quartic dependency

233
00:09:19,920 --> 00:09:21,680
in c-rank because quasi-linear

234
00:09:21,680 --> 00:09:23,760
dependency in this size seems already

235
00:09:23,760 --> 00:09:26,800
close to the optimal so let's try to

236
00:09:26,800 --> 00:09:28,640
focus on the

237
00:09:28,640 --> 00:09:31,279
rank dependency

238
00:09:31,279 --> 00:09:33,839
so how to get some faster type

239
00:09:33,839 --> 00:09:35,760
lattice reduction

240
00:09:35,760 --> 00:09:36,480
so

241
00:09:36,480 --> 00:09:38,080
we're going to completely change the

242
00:09:38,080 --> 00:09:41,279
structure which is uh used and instead

243
00:09:41,279 --> 00:09:43,120
of doing this iterative back and forth

244
00:09:43,120 --> 00:09:45,519
strategy as using ll we're going to use

245
00:09:45,519 --> 00:09:47,839
parallelization and recursion on the

246
00:09:47,839 --> 00:09:48,880
rank

247
00:09:48,880 --> 00:09:53,200
so uh let me explain that a bit more

248
00:09:53,200 --> 00:09:55,839
so i said that all the reduction boils

249
00:09:55,839 --> 00:09:59,120
down to doing some gauss steps uh on

250
00:09:59,120 --> 00:10:01,120
projected sub-lattices

251
00:10:01,120 --> 00:10:03,360
what we can do first and this was

252
00:10:03,360 --> 00:10:06,959
already uh hinted by uh villain 93 was

253
00:10:06,959 --> 00:10:08,640
to is to

254
00:10:08,640 --> 00:10:09,600
um

255
00:10:09,600 --> 00:10:12,399
do parallel gauss step uh everywhere

256
00:10:12,399 --> 00:10:14,240
it's possible when it's not overlapping

257
00:10:14,240 --> 00:10:15,680
so basically attacking the first two

258
00:10:15,680 --> 00:10:18,079
vectors and the projection of third and

259
00:10:18,079 --> 00:10:19,680
fourth and so on

260
00:10:19,680 --> 00:10:21,519
then you do all your uh parallel

261
00:10:21,519 --> 00:10:22,959
reduction like that

262
00:10:22,959 --> 00:10:25,760
but if you stop there then you don't

263
00:10:25,760 --> 00:10:28,720
have uh interleaving relations between

264
00:10:28,720 --> 00:10:30,640
let's say second vector and third vector

265
00:10:30,640 --> 00:10:33,040
and so on so what you do is shift all

266
00:10:33,040 --> 00:10:36,399
your windows and do the same parallel

267
00:10:36,399 --> 00:10:38,959
gauss reduction uh at the

268
00:10:38,959 --> 00:10:41,040
intersection of the produce blocks and

269
00:10:41,040 --> 00:10:43,279
then you continue again and again and

270
00:10:43,279 --> 00:10:46,240
again and you will in the end reach a

271
00:10:46,240 --> 00:10:48,880
reduced basis

272
00:10:48,880 --> 00:10:51,279
so if you take a full round of local

273
00:10:51,279 --> 00:10:53,839
reduction so all let's say the odd steps

274
00:10:53,839 --> 00:10:55,600
and all the even stuff you like two of

275
00:10:55,600 --> 00:10:59,040
them uh if you look at the effect of

276
00:10:59,040 --> 00:11:02,959
this operation on the um

277
00:11:02,959 --> 00:11:04,240
on the

278
00:11:04,240 --> 00:11:05,600
degree space

279
00:11:05,600 --> 00:11:07,760
then whatever is uh you're basically

280
00:11:07,760 --> 00:11:10,880
applying some discretized version of the

281
00:11:10,880 --> 00:11:13,120
laplacian operator and by that i mean

282
00:11:13,120 --> 00:11:14,399
that each

283
00:11:14,399 --> 00:11:20,000
degree is now replaced by the average of

284
00:11:20,000 --> 00:11:23,120
its neighbors ancient degrees

285
00:11:23,120 --> 00:11:25,760
it's very reminiscent and to the

286
00:11:25,760 --> 00:11:28,160
diffusion property of the solution of

287
00:11:28,160 --> 00:11:30,720
the heat equation because heat equation

288
00:11:30,720 --> 00:11:33,760
is basically that infinite infinitesimal

289
00:11:33,760 --> 00:11:35,440
increase increment of time you are

290
00:11:35,440 --> 00:11:36,880
applying the elaboration operator on

291
00:11:36,880 --> 00:11:40,160
your space and here at each time step we

292
00:11:40,160 --> 00:11:42,000
are applying a discrete labellation

293
00:11:42,000 --> 00:11:43,360
operator

294
00:11:43,360 --> 00:11:46,800
onto uh the profile space

295
00:11:46,800 --> 00:11:49,680
so since we know that the characteristic

296
00:11:49,680 --> 00:11:52,639
time of the diffusion of the solution of

297
00:11:52,639 --> 00:11:54,480
the heat equation is quadratic in the

298
00:11:54,480 --> 00:11:56,720
diameter of space will get exactly the

299
00:11:56,720 --> 00:11:58,800
same kind of property

300
00:11:58,800 --> 00:12:00,720
in substance it means that the number of

301
00:12:00,720 --> 00:12:02,720
steps you need to

302
00:12:02,720 --> 00:12:05,279
reach a stable

303
00:12:05,279 --> 00:12:07,519
stable step is

304
00:12:07,519 --> 00:12:10,560
roughly quadratic in the diameter of the

305
00:12:10,560 --> 00:12:12,959
space which is here actually the rank of

306
00:12:12,959 --> 00:12:15,680
the lattice okay

307
00:12:15,680 --> 00:12:17,279
so now we can

308
00:12:17,279 --> 00:12:19,120
remark in addition to that that all the

309
00:12:19,120 --> 00:12:21,519
operations are actually local so we can

310
00:12:21,519 --> 00:12:24,160
do the same but with big blocks instead

311
00:12:24,160 --> 00:12:26,240
of blocks two and recurs inside the

312
00:12:26,240 --> 00:12:27,680
blocks

313
00:12:27,680 --> 00:12:29,279
so for instance here we take like big

314
00:12:29,279 --> 00:12:32,160
blocks and four of them for instance and

315
00:12:32,160 --> 00:12:35,040
we will apply parallel reduction on each

316
00:12:35,040 --> 00:12:36,720
of these blocks and each of them

317
00:12:36,720 --> 00:12:39,200
consists in the same

318
00:12:39,200 --> 00:12:41,839
recursive calls so we're starting by

319
00:12:41,839 --> 00:12:44,639
even odd steps and even steps and so on

320
00:12:44,639 --> 00:12:47,279
when it's done we do we shift all our

321
00:12:47,279 --> 00:12:49,680
window by half a block and we do the

322
00:12:49,680 --> 00:12:52,800
same reducing and calling recursive

323
00:12:52,800 --> 00:12:55,040
recursively on the rank and we do it

324
00:12:55,040 --> 00:12:56,639
again on

325
00:12:56,639 --> 00:12:58,480
routine shifted windows and again and

326
00:12:58,480 --> 00:13:00,480
again and again

327
00:13:00,480 --> 00:13:02,720
so we want to make some

328
00:13:02,720 --> 00:13:05,360
big algorithmic design by exploiting

329
00:13:05,360 --> 00:13:08,079
this locality property and to do so it

330
00:13:08,079 --> 00:13:10,959
will amounts to uh makes an algorithmic

331
00:13:10,959 --> 00:13:13,360
design with the only block matrix

332
00:13:13,360 --> 00:13:15,200
operations

333
00:13:15,200 --> 00:13:18,480
so uh let's now see uh more in more

334
00:13:18,480 --> 00:13:20,399
details what are these precise block

335
00:13:20,399 --> 00:13:21,920
operation

336
00:13:21,920 --> 00:13:23,760
first of all we need to invert

337
00:13:23,760 --> 00:13:25,680
triangular matrices this will be used

338
00:13:25,680 --> 00:13:30,399
everywhere so uh as a warm up let's see

339
00:13:30,399 --> 00:13:32,560
so take a triangular matrix let's say

340
00:13:32,560 --> 00:13:34,160
block a c

341
00:13:34,160 --> 00:13:36,880
d and if you you can write directly the

342
00:13:36,880 --> 00:13:38,880
inverse of this matrix using shows

343
00:13:38,880 --> 00:13:39,920
complement

344
00:13:39,920 --> 00:13:41,519
and it's pretty easy it's a minus one d

345
00:13:41,519 --> 00:13:43,680
minus one and some

346
00:13:43,680 --> 00:13:46,560
uh block here minus a minus one c d

347
00:13:46,560 --> 00:13:48,320
minus 1.

348
00:13:48,320 --> 00:13:50,240
okay so formula is pretty explicit so we

349
00:13:50,240 --> 00:13:52,800
can construct a recursive algorithm for

350
00:13:52,800 --> 00:13:55,120
that and the

351
00:13:55,120 --> 00:13:57,920
complexity of this algorithm amounts to

352
00:13:57,920 --> 00:14:00,000
basically matrix multiplication so you

353
00:14:00,000 --> 00:14:02,320
can inverse for the cost of matrix

354
00:14:02,320 --> 00:14:04,000
multiplication

355
00:14:04,000 --> 00:14:05,680
okay so

356
00:14:05,680 --> 00:14:08,240
now let's see how we can compute the

357
00:14:08,240 --> 00:14:11,120
so-called qr decomposition by blocks

358
00:14:11,120 --> 00:14:12,720
so

359
00:14:12,720 --> 00:14:14,320
current decomposition is an algorithmic

360
00:14:14,320 --> 00:14:17,199
null to handle filtration because i said

361
00:14:17,199 --> 00:14:19,440
previously that we were directly using

362
00:14:19,440 --> 00:14:22,000
filtration but uh in practice what we

363
00:14:22,000 --> 00:14:24,560
are doing is to have an algorithmic grip

364
00:14:24,560 --> 00:14:27,040
on it so we want to work with mattresses

365
00:14:27,040 --> 00:14:29,120
and to do so uh

366
00:14:29,120 --> 00:14:31,440
we want to find some say a

367
00:14:31,440 --> 00:14:34,800
normal form of uh the basis and it

368
00:14:34,800 --> 00:14:36,399
amounts to finding some orthogonal

369
00:14:36,399 --> 00:14:38,480
transformation to put the basis in

370
00:14:38,480 --> 00:14:40,320
triangular form because triangular form

371
00:14:40,320 --> 00:14:42,240
is the uh

372
00:14:42,240 --> 00:14:45,360
a way to encode uh filtration uh as

373
00:14:45,360 --> 00:14:46,880
mattresses

374
00:14:46,880 --> 00:14:48,639
so basically it just means that we are

375
00:14:48,639 --> 00:14:51,279
looking at the lattice modulo any kind

376
00:14:51,279 --> 00:14:54,160
of rotation of the space and we take a

377
00:14:54,160 --> 00:14:56,160
good rotation so that your matrix is

378
00:14:56,160 --> 00:14:57,839
just triangular it's nothing much more

379
00:14:57,839 --> 00:14:58,880
than that

380
00:14:58,880 --> 00:15:02,240
so how we can uh do this uh computation

381
00:15:02,240 --> 00:15:06,000
by block so uh instead of uh working

382
00:15:06,000 --> 00:15:07,279
directly with basically we're working

383
00:15:07,279 --> 00:15:10,480
with the gram matrix which is symmetric

384
00:15:10,480 --> 00:15:13,760
and we work it we divided in uh three

385
00:15:13,760 --> 00:15:15,360
blocks abc

386
00:15:15,360 --> 00:15:18,560
then the first corner uh we can just

387
00:15:18,560 --> 00:15:21,440
suppose that we can directly uh find the

388
00:15:21,440 --> 00:15:23,360
decomposition so let's suppose that we

389
00:15:23,360 --> 00:15:26,160
find a triangular matrix uh l a such

390
00:15:26,160 --> 00:15:28,399
that l a transpose l a is equal to a

391
00:15:28,399 --> 00:15:30,959
okay then we constrict as before the

392
00:15:30,959 --> 00:15:32,480
shortest complement

393
00:15:32,480 --> 00:15:34,959
of a in the matrix g so it's c minus b

394
00:15:34,959 --> 00:15:37,040
transpose a b

395
00:15:37,040 --> 00:15:39,440
and we can decompose it

396
00:15:39,440 --> 00:15:42,320
directly using let's say recursion and

397
00:15:42,320 --> 00:15:46,079
we find l transpose s l s is equal to s

398
00:15:46,079 --> 00:15:48,480
and we now uh can show with a bit of

399
00:15:48,480 --> 00:15:51,759
computation that the

400
00:15:51,759 --> 00:15:53,759
shortest scale conversancy our part of

401
00:15:53,759 --> 00:15:57,920
the creative composition is l-a-l-s and

402
00:15:57,920 --> 00:16:02,880
l a minus l s transpose minus 1 b here

403
00:16:02,880 --> 00:16:04,560
from that we can

404
00:16:04,560 --> 00:16:05,680
directly

405
00:16:05,680 --> 00:16:08,079
work some

406
00:16:08,079 --> 00:16:10,720
algorithm which is the transposition of

407
00:16:10,720 --> 00:16:11,600
this

408
00:16:11,600 --> 00:16:14,320
construction here once again the costly

409
00:16:14,320 --> 00:16:16,880
step uh except the regulation step is

410
00:16:16,880 --> 00:16:18,639
matrix multiplication here and you can

411
00:16:18,639 --> 00:16:20,560
prove that it amounts to

412
00:16:20,560 --> 00:16:24,399
a matrix multiplication once again

413
00:16:24,399 --> 00:16:26,000
now the

414
00:16:26,000 --> 00:16:28,800
final tool we need to do our reduction

415
00:16:28,800 --> 00:16:30,880
is so-called size reduction so what size

416
00:16:30,880 --> 00:16:32,399
reduction

417
00:16:32,399 --> 00:16:35,680
size reduction is a process which will

418
00:16:35,680 --> 00:16:38,560
reduce over diagonal elements using some

419
00:16:38,560 --> 00:16:39,759
let's say lattice compatible

420
00:16:39,759 --> 00:16:41,199
transformations that says to say

421
00:16:41,199 --> 00:16:44,000
unimodular transformation it's a

422
00:16:44,000 --> 00:16:46,240
transformation matrix which has integral

423
00:16:46,240 --> 00:16:49,680
coefficient and determinant y

424
00:16:49,680 --> 00:16:51,279
so

425
00:16:51,279 --> 00:16:52,079
um

426
00:16:52,079 --> 00:16:54,560
how we can reduce over diagonal elements

427
00:16:54,560 --> 00:16:58,000
here uh i did normalize the matrix r we

428
00:16:58,000 --> 00:17:00,000
constrict with qr decompositions just

429
00:17:00,000 --> 00:17:02,079
dividing the rows by the length of the

430
00:17:02,079 --> 00:17:03,680
diagonal

431
00:17:03,680 --> 00:17:06,160
okay so how we can do that uh

432
00:17:06,160 --> 00:17:07,199
we can

433
00:17:07,199 --> 00:17:10,400
use a block uh structure idea by start

434
00:17:10,400 --> 00:17:11,760
reducing

435
00:17:11,760 --> 00:17:12,720
the

436
00:17:12,720 --> 00:17:15,599
upper part of the over diagonal limits

437
00:17:15,599 --> 00:17:17,679
okay let's suppose we can do that then

438
00:17:17,679 --> 00:17:20,559
we will reduce the lower part uh as

439
00:17:20,559 --> 00:17:23,039
before and like for the current concern

440
00:17:23,039 --> 00:17:25,599
for the inversion it remains to handle

441
00:17:25,599 --> 00:17:26,880
correctly

442
00:17:26,880 --> 00:17:27,599
the

443
00:17:27,599 --> 00:17:30,400
upper diagonal part here like the

444
00:17:30,400 --> 00:17:33,120
upper right elements

445
00:17:33,120 --> 00:17:36,320
so how we can do that so if we write the

446
00:17:36,320 --> 00:17:40,000
transformation let's say u is uh u1 u2

447
00:17:40,000 --> 00:17:42,799
and x x being some

448
00:17:42,799 --> 00:17:44,880
unknown for the moment

449
00:17:44,880 --> 00:17:48,799
integral matrix the effect of uh u on

450
00:17:48,799 --> 00:17:51,280
the triangular matrix uh

451
00:17:51,280 --> 00:17:53,919
we that we write by block a cd

452
00:17:53,919 --> 00:17:56,720
is applying some transformation u1 on a

453
00:17:56,720 --> 00:17:59,360
appliance transformation u2 on d and

454
00:17:59,360 --> 00:18:01,039
then doing

455
00:18:01,039 --> 00:18:03,440
ax plus cu 2

456
00:18:03,440 --> 00:18:05,200
on the upper block

457
00:18:05,200 --> 00:18:07,360
so if we suppose that u1 and u2 are

458
00:18:07,360 --> 00:18:10,000
correctly chosen so that a1 and du2 are

459
00:18:10,000 --> 00:18:12,080
small as we want

460
00:18:12,080 --> 00:18:14,799
then we just want ax plus cu 2 to be

461
00:18:14,799 --> 00:18:18,240
close to 0 with x being integral

462
00:18:18,240 --> 00:18:20,720
and basically we get a recursive

463
00:18:20,720 --> 00:18:23,120
algorithm from that which amounts on

464
00:18:23,120 --> 00:18:26,160
size reducing a size reducing d

465
00:18:26,160 --> 00:18:27,280
and

466
00:18:27,280 --> 00:18:30,720
finding like that if you take uh

467
00:18:30,720 --> 00:18:34,400
a minus one c u two for the matrix uh x

468
00:18:34,400 --> 00:18:37,039
and you're basically good

469
00:18:37,039 --> 00:18:39,440
uh this is in substance a block variant

470
00:18:39,440 --> 00:18:41,919
of a reduction which has been introduced

471
00:18:41,919 --> 00:18:42,720
by

472
00:18:42,720 --> 00:18:44,880
sasem so we call that let's say say say

473
00:18:44,880 --> 00:18:47,679
in size reduce

474
00:18:47,679 --> 00:18:50,480
so we can move on to the uh actual

475
00:18:50,480 --> 00:18:52,880
reduction procedure which uh will amount

476
00:18:52,880 --> 00:18:55,440
to use our big design

477
00:18:55,440 --> 00:18:56,720
by

478
00:18:56,720 --> 00:18:58,320
applying parallel reduction and

479
00:18:58,320 --> 00:19:00,320
recursion and all of our

480
00:19:00,320 --> 00:19:02,000
block tools

481
00:19:02,000 --> 00:19:05,039
so when the dimension is two then we use

482
00:19:05,039 --> 00:19:07,039
the gauss algorithm or uh if you want to

483
00:19:07,039 --> 00:19:08,559
be more efficient that subtypically you

484
00:19:08,559 --> 00:19:10,640
can use shenaniga algorithm which is a

485
00:19:10,640 --> 00:19:12,320
quasi-linear in

486
00:19:12,320 --> 00:19:13,919
size b

487
00:19:13,919 --> 00:19:16,080
then for a certain number of iterations

488
00:19:16,080 --> 00:19:17,840
which is basically quadratic in the bit

489
00:19:17,840 --> 00:19:19,919
diameter as i said

490
00:19:19,919 --> 00:19:23,039
we will do some reduction and we start

491
00:19:23,039 --> 00:19:26,000
we start start by um computing the

492
00:19:26,000 --> 00:19:27,520
curated composition with the blockchain

493
00:19:27,520 --> 00:19:29,840
list algorithm i showed

494
00:19:29,840 --> 00:19:32,240
and then we sales and reduce uh the

495
00:19:32,240 --> 00:19:34,080
basis to reduce the size of all

496
00:19:34,080 --> 00:19:36,480
coefficients appearing

497
00:19:36,480 --> 00:19:38,559
and then we

498
00:19:38,559 --> 00:19:41,200
do this uh window

499
00:19:41,200 --> 00:19:43,840
strategy and we

500
00:19:43,840 --> 00:19:46,960
will apply the reduction recursively to

501
00:19:46,960 --> 00:19:48,400
all the blocks

502
00:19:48,400 --> 00:19:49,360
so

503
00:19:49,360 --> 00:19:51,360
here we introduce

504
00:19:51,360 --> 00:19:53,679
some condition which is reminiscent to

505
00:19:53,679 --> 00:19:55,840
the lovage condition in the original

506
00:19:55,840 --> 00:19:58,480
algorithm which basically says if you

507
00:19:58,480 --> 00:20:02,640
need or not to reduce

508
00:20:02,640 --> 00:20:04,880
and so that if you're reduced enough you

509
00:20:04,880 --> 00:20:07,440
just move on to the next block and so on

510
00:20:07,440 --> 00:20:10,480
so that you will eventually start

511
00:20:10,480 --> 00:20:11,520
so

512
00:20:11,520 --> 00:20:13,600
if you look at the running time and

513
00:20:13,600 --> 00:20:15,440
where the

514
00:20:15,440 --> 00:20:16,960
most computation

515
00:20:16,960 --> 00:20:19,919
is done you can see that for free when

516
00:20:19,919 --> 00:20:22,320
the dimension is small enough

517
00:20:22,320 --> 00:20:24,960
it's uh with regards to the rank with

518
00:20:24,960 --> 00:20:26,159
regards to

519
00:20:26,159 --> 00:20:28,320
the size of the christians appearing

520
00:20:28,320 --> 00:20:31,840
then you can actually don't go

521
00:20:31,840 --> 00:20:33,840
all the way down to the leaves of the

522
00:20:33,840 --> 00:20:36,080
recursion tree but you can stop a bit

523
00:20:36,080 --> 00:20:38,320
before and use a more costly reduction

524
00:20:38,320 --> 00:20:40,880
such that the big easy reduction

525
00:20:40,880 --> 00:20:42,880
and the overall running time of the

526
00:20:42,880 --> 00:20:45,360
algorithm will remain unchanged

527
00:20:45,360 --> 00:20:47,679
so basically for free you can use

528
00:20:47,679 --> 00:20:49,039
something which is a slightly more

529
00:20:49,039 --> 00:20:51,760
powerful than a gauss algorithm and

530
00:20:51,760 --> 00:20:53,840
something which is slightly bigger

531
00:20:53,840 --> 00:20:57,200
dimension and so you will get in the end

532
00:20:57,200 --> 00:20:59,520
uh vectors which are slightly shorter

533
00:20:59,520 --> 00:21:00,840
than uh

534
00:21:00,840 --> 00:21:04,880
before so all in all uh with this little

535
00:21:04,880 --> 00:21:05,760
trick

536
00:21:05,760 --> 00:21:09,760
we can uh heuristically uh conjecture

537
00:21:09,760 --> 00:21:10,720
that

538
00:21:10,720 --> 00:21:13,280
in time which amounts to matrix

539
00:21:13,280 --> 00:21:16,480
multiplication so d omega multiplied by

540
00:21:16,480 --> 00:21:20,640
the condition number of uh euro bases

541
00:21:20,640 --> 00:21:24,240
we can find some vectors which is uh

542
00:21:24,240 --> 00:21:26,799
within

543
00:21:27,679 --> 00:21:28,880
2 to the

544
00:21:28,880 --> 00:21:29,600
d

545
00:21:29,600 --> 00:21:32,159
log log c over log c

546
00:21:32,159 --> 00:21:34,400
multiplied by the

547
00:21:34,400 --> 00:21:36,720
normalized co volume

548
00:21:36,720 --> 00:21:38,960
so this uh

549
00:21:38,960 --> 00:21:41,280
d log log c over log c is basically

550
00:21:41,280 --> 00:21:43,919
because we use this uh big easy uh

551
00:21:43,919 --> 00:21:45,200
instead of

552
00:21:45,200 --> 00:21:47,760
going up the way down to uh rank two

553
00:21:47,760 --> 00:21:49,840
with uh gauss algorithm otherwise we

554
00:21:49,840 --> 00:21:53,039
just get two to z d like llm so for the

555
00:21:53,039 --> 00:21:56,400
reading time uh this is a conjectural

556
00:21:56,400 --> 00:21:57,440
right now

557
00:21:57,440 --> 00:21:58,720
but we

558
00:21:58,720 --> 00:22:01,039
made a lot of experiments and in

559
00:22:01,039 --> 00:22:02,480
particular

560
00:22:02,480 --> 00:22:03,919
here you have

561
00:22:03,919 --> 00:22:05,200
on the left

562
00:22:05,200 --> 00:22:08,080
some traces of execution so

563
00:22:08,080 --> 00:22:10,880
the abscissa is the

564
00:22:10,880 --> 00:22:12,240
log of the dimension of the lattice

565
00:22:12,240 --> 00:22:13,840
we're considering from two to the seven

566
00:22:13,840 --> 00:22:17,039
to two to the eleven and in uh

567
00:22:17,039 --> 00:22:19,039
ordinates you get uh the log of the

568
00:22:19,039 --> 00:22:20,720
running time in second

569
00:22:20,720 --> 00:22:24,640
so uh we also we increased linearly uh

570
00:22:24,640 --> 00:22:26,559
the condition number of the matrix we're

571
00:22:26,559 --> 00:22:29,360
considering and we see that

572
00:22:29,360 --> 00:22:31,200
all the uh

573
00:22:31,200 --> 00:22:33,600
slopes of this

574
00:22:33,600 --> 00:22:36,000
of these graphs are

575
00:22:36,000 --> 00:22:39,200
almost all equals and are around

576
00:22:39,200 --> 00:22:41,600
2.7 which was the exponent we use for

577
00:22:41,600 --> 00:22:44,400
matrix multiplication

578
00:22:44,400 --> 00:22:46,320
um so

579
00:22:46,320 --> 00:22:49,200
just before moving on to uh other

580
00:22:49,200 --> 00:22:52,320
experiments uh and results uh i'd just

581
00:22:52,320 --> 00:22:54,799
like to point out that we can reduce

582
00:22:54,799 --> 00:22:55,919
this

583
00:22:55,919 --> 00:22:57,120
d omega

584
00:22:57,120 --> 00:23:00,480
dependency for knapsack-like lattices

585
00:23:00,480 --> 00:23:02,640
which

