1
00:00:02,960 --> 00:00:04,400
and you're ready to go have a good

2
00:00:04,400 --> 00:00:05,279
session

3
00:00:05,279 --> 00:00:06,480
yeah thanks

4
00:00:06,480 --> 00:00:09,040
um hello everyone welcome to today's

5
00:00:09,040 --> 00:00:12,320
session on foundations our first talk

6
00:00:12,320 --> 00:00:15,200
would be on white box trader tracing by

7
00:00:15,200 --> 00:00:16,560
mark zoundry

8
00:00:16,560 --> 00:00:20,000
and mark will give the talk

9
00:00:20,000 --> 00:00:22,400
all right thank you

10
00:00:22,400 --> 00:00:24,800
uh so today i'm going to be talking

11
00:00:24,800 --> 00:00:28,560
about white box trader tracing

12
00:00:28,560 --> 00:00:29,920
so let us first recall the goal of

13
00:00:29,920 --> 00:00:31,359
trader tracing

14
00:00:31,359 --> 00:00:33,440
we have a content distributor who is

15
00:00:33,440 --> 00:00:35,520
broadcasting encrypted messages to a

16
00:00:35,520 --> 00:00:37,520
large set of recipients whom each have

17
00:00:37,520 --> 00:00:39,840
their own personalized secret key

18
00:00:39,840 --> 00:00:41,520
we are concerned that an unscrupulous

19
00:00:41,520 --> 00:00:43,360
user called a trader

20
00:00:43,360 --> 00:00:45,120
may create a and distribute an

21
00:00:45,120 --> 00:00:47,039
unauthorized decoder program that can

22
00:00:47,039 --> 00:00:49,200
also decrypt the broadcast

23
00:00:49,200 --> 00:00:50,640
to deter such behavior we want the

24
00:00:50,640 --> 00:00:53,039
content distributor to be able to trace

25
00:00:53,039 --> 00:00:54,960
the decoder identifying the user that it

26
00:00:54,960 --> 00:00:57,360
came from

27
00:00:57,360 --> 00:00:59,039
the bulk of the tracing literature has

28
00:00:59,039 --> 00:01:00,559
focused on producing schemes with

29
00:01:00,559 --> 00:01:03,199
shorter parameters in particular cipher

30
00:01:03,199 --> 00:01:04,159
text

31
00:01:04,159 --> 00:01:06,240
using various combinatorial and

32
00:01:06,240 --> 00:01:09,360
algebraic techniques

33
00:01:09,520 --> 00:01:11,119
in this work however we will look at

34
00:01:11,119 --> 00:01:12,479
something different

35
00:01:12,479 --> 00:01:14,799
uh we'll revisit the trading the tracing

36
00:01:14,799 --> 00:01:16,479
model of essentially all prior tracing

37
00:01:16,479 --> 00:01:17,840
works

38
00:01:17,840 --> 00:01:20,320
uh specifically all modern tracing works

39
00:01:20,320 --> 00:01:22,560
work in a black box tracing model where

40
00:01:22,560 --> 00:01:24,560
the tracer simply queries the decoder on

41
00:01:24,560 --> 00:01:26,560
several ciphertexts and observes the

42
00:01:26,560 --> 00:01:28,240
plaintext that come out

43
00:01:28,240 --> 00:01:30,079
the motivation for this model is that it

44
00:01:30,079 --> 00:01:32,079
allows for tracing decoders based on

45
00:01:32,079 --> 00:01:34,079
hardware and also prevents us from

46
00:01:34,079 --> 00:01:36,000
having to decipher program code in the

47
00:01:36,000 --> 00:01:39,360
case of software decoders

48
00:01:39,520 --> 00:01:41,759
uh to motivate our study we will

49
00:01:41,759 --> 00:01:44,000
consider the following scenario

50
00:01:44,000 --> 00:01:46,560
suppose the identity of an honest user

51
00:01:46,560 --> 00:01:48,479
contains sensitive information for

52
00:01:48,479 --> 00:01:50,399
example a bank account number or

53
00:01:50,399 --> 00:01:52,240
something like that

54
00:01:52,240 --> 00:01:54,240
a malicious user or even the content

55
00:01:54,240 --> 00:01:56,000
distributor themselves

56
00:01:56,000 --> 00:01:57,600
may be interested in trying to obtain

57
00:01:57,600 --> 00:01:59,040
this information

58
00:01:59,040 --> 00:02:01,119
and they will try to extract it using a

59
00:02:01,119 --> 00:02:02,719
chosen ciphertext

60
00:02:02,719 --> 00:02:06,559
attack against the user's secret key

61
00:02:06,960 --> 00:02:09,758
uh we show an impossibility that if your

62
00:02:09,758 --> 00:02:12,319
tracing algorithm is black box

63
00:02:12,319 --> 00:02:14,560
that privacy against chosen ciphertext

64
00:02:14,560 --> 00:02:16,480
attack is fundamentally at odds with

65
00:02:16,480 --> 00:02:18,640
tracing

66
00:02:18,640 --> 00:02:20,959
so we show that any user who is able to

67
00:02:20,959 --> 00:02:23,440
trace if the tracing algo in this black

68
00:02:23,440 --> 00:02:25,120
box can mount the tracing algorithm

69
00:02:25,120 --> 00:02:28,400
using a chosen ciphertext attack

70
00:02:28,400 --> 00:02:30,080
we then complement this result by

71
00:02:30,080 --> 00:02:32,560
showing how to use functional encryption

72
00:02:32,560 --> 00:02:34,080
and non-interactive zero-knowledge

73
00:02:34,080 --> 00:02:36,239
proofs to build a scheme that maintains

74
00:02:36,239 --> 00:02:38,319
privacy even in the presence of chosen

75
00:02:38,319 --> 00:02:41,120
ciphertext attacks for honest users but

76
00:02:41,120 --> 00:02:43,840
allows tracing against traders

77
00:02:43,840 --> 00:02:45,599
because of our impossibility such a

78
00:02:45,599 --> 00:02:47,200
result means that we need to use white

79
00:02:47,200 --> 00:02:49,280
box tracing which means that we actually

80
00:02:49,280 --> 00:02:51,920
need to inspect the actual program code

81
00:02:51,920 --> 00:02:54,160
of the decoder rather than just viewing

82
00:02:54,160 --> 00:02:57,519
its input output behavior

83
00:02:58,480 --> 00:03:01,360
uh we next consider another scenario

84
00:03:01,360 --> 00:03:03,920
which uh will also require white box

85
00:03:03,920 --> 00:03:05,360
tracing

86
00:03:05,360 --> 00:03:07,760
here we consider a typical assumption in

87
00:03:07,760 --> 00:03:10,400
the multi-party computation literature

88
00:03:10,400 --> 00:03:12,640
which asks for a reliable broadcast

89
00:03:12,640 --> 00:03:13,519
channel

90
00:03:13,519 --> 00:03:15,360
this means if an adversary sends a

91
00:03:15,360 --> 00:03:17,519
message to another party all parties

92
00:03:17,519 --> 00:03:19,599
will see the same message there's no way

93
00:03:19,599 --> 00:03:22,400
for an adversary to send one message to

94
00:03:22,400 --> 00:03:24,159
one user and have that be interpreted as

95
00:03:24,159 --> 00:03:26,879
a different message for another user

96
00:03:26,879 --> 00:03:28,959
this is important in many malicious npc

97
00:03:28,959 --> 00:03:31,200
protocols since we don't want a scenario

98
00:03:31,200 --> 00:03:34,080
where some users observe the adversary

99
00:03:34,080 --> 00:03:36,239
behaving maliciously but others think

100
00:03:36,239 --> 00:03:38,239
the adversary's still honest

101
00:03:38,239 --> 00:03:40,640
so we ask what if the channel now is

102
00:03:40,640 --> 00:03:44,798
encrypted under a trader tracing scheme

103
00:03:45,599 --> 00:03:47,920
uh we show another impossibility uh in

104
00:03:47,920 --> 00:03:49,920
the black box tracing setting and

105
00:03:49,920 --> 00:03:52,159
demonstrate that any scheme with black

106
00:03:52,159 --> 00:03:53,519
box tracing

107
00:03:53,519 --> 00:03:55,040
in um

108
00:03:55,040 --> 00:03:56,640
what i'll call a public tracing setting

109
00:03:56,640 --> 00:03:58,720
where anyone can trace

110
00:03:58,720 --> 00:04:01,120
uh that in such a setting the

111
00:04:01,120 --> 00:04:02,879
reliability of the broadcast channel is

112
00:04:02,879 --> 00:04:04,640
actually broken by virtue of it being

113
00:04:04,640 --> 00:04:07,599
encrypted with the trader tracing scheme

114
00:04:07,599 --> 00:04:09,920
in particular you can an adversary can

115
00:04:09,920 --> 00:04:11,760
produce ciphertext which will decrypt

116
00:04:11,760 --> 00:04:15,280
differently to different users

117
00:04:15,280 --> 00:04:17,120
we then complement this impossibility

118
00:04:17,120 --> 00:04:19,358
with another result this one is a more

119
00:04:19,358 --> 00:04:21,358
limited result

120
00:04:21,358 --> 00:04:23,840
showing that we we can use fully

121
00:04:23,840 --> 00:04:26,000
homomorphic encryption and lockable

122
00:04:26,000 --> 00:04:27,280
obfuscation

123
00:04:27,280 --> 00:04:28,960
to get a trader tracing scheme that is

124
00:04:28,960 --> 00:04:30,639
consistent

125
00:04:30,639 --> 00:04:33,280
however we only guarantee tracing under

126
00:04:33,280 --> 00:04:35,680
a constant number of collusion occluding

127
00:04:35,680 --> 00:04:37,360
users this is in contrast to many

128
00:04:37,360 --> 00:04:40,840
schemes that actually allow unbounded

129
00:04:40,840 --> 00:04:43,280
collusions uh but nevertheless it's sort

130
00:04:43,280 --> 00:04:45,919
of an initial positive result um for

131
00:04:45,919 --> 00:04:48,320
consistent tracing

132
00:04:48,320 --> 00:04:49,759
all right and again because of our

133
00:04:49,759 --> 00:04:52,320
impossibility this results necessarily

134
00:04:52,320 --> 00:04:55,040
uses white box tracing

135
00:04:55,040 --> 00:04:56,880
all right this concludes the overview of

136
00:04:56,880 --> 00:04:59,840
my work thank you

137
00:05:01,919 --> 00:05:04,639
thanks mark for the presentation

138
00:05:04,639 --> 00:05:08,080
any questions from the audience

139
00:05:08,080 --> 00:05:11,039
feel free to ask questions on the chat

140
00:05:11,039 --> 00:05:12,080
or

141
00:05:12,080 --> 00:05:15,120
um on the zulip channel

142
00:05:15,120 --> 00:05:16,960
or just simply

143
00:05:16,960 --> 00:05:19,840
raise your hand or

144
00:05:22,080 --> 00:05:24,639
mark what's your model of uh white box

145
00:05:24,639 --> 00:05:26,960
tracing uh like orbiter or you assume

146
00:05:26,960 --> 00:05:28,720
some specific format

147
00:05:28,720 --> 00:05:30,800
of the decoder like some gtm or

148
00:05:30,800 --> 00:05:31,919
something

149
00:05:31,919 --> 00:05:35,680
no the the coder is an arbitrary program

150
00:05:35,680 --> 00:05:37,919
but you actually get the the tracing

151
00:05:37,919 --> 00:05:39,440
algorithm actually gets the code for the

152
00:05:39,440 --> 00:05:42,720
program as opposed to most of the work

153
00:05:42,720 --> 00:05:44,880
in the trader tracing setting where the

154
00:05:44,880 --> 00:05:46,560
tracing algorithm is only assumed to

155
00:05:46,560 --> 00:05:49,440
have query access

156
00:05:50,000 --> 00:05:51,280
so what kind of i'm just curious what

157
00:05:51,280 --> 00:05:53,440
kind of tricks do you use so like

158
00:05:53,440 --> 00:05:55,199
barack's kind of tricks

159
00:05:55,199 --> 00:05:57,840
yeah exactly so the

160
00:05:57,840 --> 00:05:59,360
the

161
00:05:59,360 --> 00:06:01,440
the starting point is to use these

162
00:06:01,440 --> 00:06:03,440
unoffice skatable programs of barack at

163
00:06:03,440 --> 00:06:06,000
all which are programs that

164
00:06:06,000 --> 00:06:09,280
you can learn given the program code but

165
00:06:09,280 --> 00:06:12,000
you can't learn just given query access

166
00:06:12,000 --> 00:06:13,919
um and then we have to

167
00:06:13,919 --> 00:06:15,520
you know play some tricks in order to

168
00:06:15,520 --> 00:06:17,440
actually adequately embed these programs

169
00:06:17,440 --> 00:06:19,520
into the trader tracing system in order

170
00:06:19,520 --> 00:06:22,400
to get the guarantees that we need

171
00:06:22,400 --> 00:06:23,759
so i would imagine this is like

172
00:06:23,759 --> 00:06:25,440
beautiful observation but i would

173
00:06:25,440 --> 00:06:27,360
imagine this is

174
00:06:27,360 --> 00:06:28,639
kind of

175
00:06:28,639 --> 00:06:31,120
purely theoretical it has no hope

176
00:06:31,120 --> 00:06:33,039
to get something

177
00:06:33,039 --> 00:06:34,800
uh well i'm just curious because

178
00:06:34,800 --> 00:06:36,479
certainly

179
00:06:36,479 --> 00:06:38,160
yeah certainly the constructions that we

180
00:06:38,160 --> 00:06:39,440
give are

181
00:06:39,440 --> 00:06:42,960
are hopelessly inefficient um

182
00:06:42,960 --> 00:06:43,840
but

183
00:06:43,840 --> 00:06:46,720
you know there might be hope for

184
00:06:46,720 --> 00:06:48,560
yeah either a different model or maybe

185
00:06:48,560 --> 00:06:50,960
using different techniques to

186
00:06:50,960 --> 00:06:53,199
to get a more efficient protocol

187
00:06:53,199 --> 00:06:55,039
well because for some kind of scheme the

188
00:06:55,039 --> 00:06:57,599
key is it is reasonable to assume for

189
00:06:57,599 --> 00:06:59,759
some discrete log scheme that all the

190
00:06:59,759 --> 00:07:01,759
decoder keys do like different discrete

191
00:07:01,759 --> 00:07:04,080
lock representations or something

192
00:07:04,080 --> 00:07:05,840
so i would imagine it's conceivable to

193
00:07:05,840 --> 00:07:08,160
go into some kind of ggm or something

194
00:07:08,160 --> 00:07:10,080
but i don't know if you thought about it

195
00:07:10,080 --> 00:07:13,440
if you assume specific kind of programs

196
00:07:13,440 --> 00:07:16,240
right right the the problem is i i mean

197
00:07:16,240 --> 00:07:17,759
i have thought about it the problem is

198
00:07:17,759 --> 00:07:19,440
that um

199
00:07:19,440 --> 00:07:21,840
at least so so there is a body of

200
00:07:21,840 --> 00:07:23,840
literature especially sort of in the

201
00:07:23,840 --> 00:07:25,680
early days of trader tracing

202
00:07:25,680 --> 00:07:27,919
that that did exactly this kind of thing

203
00:07:27,919 --> 00:07:31,280
where you assume some structure of the

204
00:07:31,280 --> 00:07:32,479
of the key

205
00:07:32,479 --> 00:07:34,240
for example you assume that the trader

206
00:07:34,240 --> 00:07:36,240
actually outputs a legitimate key for

207
00:07:36,240 --> 00:07:37,520
the system

208
00:07:37,520 --> 00:07:39,039
um

209
00:07:39,039 --> 00:07:40,960
however

210
00:07:40,960 --> 00:07:42,400
all those schemes

211
00:07:42,400 --> 00:07:44,560
as far as i'm aware are

212
00:07:44,560 --> 00:07:46,479
very easily breakable

213
00:07:46,479 --> 00:07:47,680
if you

214
00:07:47,680 --> 00:07:48,479
are

215
00:07:48,479 --> 00:07:50,879
not restricted to

216
00:07:50,879 --> 00:07:53,919
um to such a legitimate key

217
00:07:53,919 --> 00:07:55,039
uh so

218
00:07:55,039 --> 00:07:57,039
so there's a question of what like what

219
00:07:57,039 --> 00:07:58,879
what's the

220
00:07:58,879 --> 00:08:00,160
you know making these restrictions if

221
00:08:00,160 --> 00:08:01,680
it's really easy to just get around them

222
00:08:01,680 --> 00:08:04,240
by by producing a fake key by

223
00:08:04,240 --> 00:08:06,400
by producing a general decoder program

224
00:08:06,400 --> 00:08:08,639
they're sort of a question of um like

225
00:08:08,639 --> 00:08:10,479
what what's really the guarantee you get

226
00:08:10,479 --> 00:08:14,080
from that um

227
00:08:15,360 --> 00:08:18,160
yeah thanks

228
00:08:19,440 --> 00:08:21,599
okay great discussion

229
00:08:21,599 --> 00:08:24,879
um let's thank the speaker again

230
00:08:24,879 --> 00:08:27,919
and our uh next talk

231
00:08:27,919 --> 00:08:31,520
for me can you share the screen

232
00:08:31,919 --> 00:08:34,080
the next talk will be uh does fear

233
00:08:34,080 --> 00:08:36,159
shamir require a cryptographic hash

234
00:08:36,159 --> 00:08:39,760
function by eli chen alex lombardi from

235
00:08:39,760 --> 00:08:42,320
miymar and uh willie watch and for me

236
00:08:42,320 --> 00:08:44,240
it's giving the talk

237
00:08:44,240 --> 00:08:46,560
everyone

238
00:08:50,560 --> 00:08:51,519
am i

239
00:08:51,519 --> 00:08:54,920
no no

240
00:09:01,760 --> 00:09:05,240
all right hold on

241
00:09:13,600 --> 00:09:14,880
okay sorry is everything working with

242
00:09:14,880 --> 00:09:16,080
the slide

243
00:09:16,080 --> 00:09:17,839
yeah it looks good thanks

244
00:09:17,839 --> 00:09:20,000
all right so this talk is uh does fiat

245
00:09:20,000 --> 00:09:21,519
chamier acquire a cryptographic hash

246
00:09:21,519 --> 00:09:23,680
function this is joint work with eli

247
00:09:23,680 --> 00:09:26,480
chen alex lombardi and willie flush

248
00:09:26,480 --> 00:09:27,920
uh alex and will you're actually my

249
00:09:27,920 --> 00:09:29,120
roommates for the summer so they're

250
00:09:29,120 --> 00:09:30,560
right next to me on hand to also help

251
00:09:30,560 --> 00:09:32,399
answer questions

252
00:09:32,399 --> 00:09:33,360
um

253
00:09:33,360 --> 00:09:34,560
all right so

254
00:09:34,560 --> 00:09:35,920
this talk is about the fiat mirror

255
00:09:35,920 --> 00:09:37,600
heuristic which in a nutshell is a

256
00:09:37,600 --> 00:09:39,440
magical compiler that somehow removes

257
00:09:39,440 --> 00:09:41,519
interaction from public coin interactive

258
00:09:41,519 --> 00:09:42,720
protocols

259
00:09:42,720 --> 00:09:44,160
so let's recall that a public one

260
00:09:44,160 --> 00:09:45,839
interactive protocol is an interaction

261
00:09:45,839 --> 00:09:47,440
between approver and verifier the

262
00:09:47,440 --> 00:09:48,399
proverb is trying to convince the

263
00:09:48,399 --> 00:09:50,399
verifier that some claim is true they

264
00:09:50,399 --> 00:09:52,320
have a back and forth conversation where

265
00:09:52,320 --> 00:09:53,519
all the verifier messages to the

266
00:09:53,519 --> 00:09:55,680
approver are just random coins random

267
00:09:55,680 --> 00:09:56,560
rise

268
00:09:56,560 --> 00:09:57,920
and at the end of the interaction the

269
00:09:57,920 --> 00:10:00,080
verifier either accepts or rejects just

270
00:10:00,080 --> 00:10:02,399
based on the transcript alone

271
00:10:02,399 --> 00:10:04,240
and so fiat here takes such a public

272
00:10:04,240 --> 00:10:06,320
coin interactive protocol and turns it

273
00:10:06,320 --> 00:10:08,480
into a non-interactive protocol and the

274
00:10:08,480 --> 00:10:09,839
way this goes is that the prover and

275
00:10:09,839 --> 00:10:11,519
verifier agree on something called the

276
00:10:11,519 --> 00:10:13,680
fiat mirror hash function h

277
00:10:13,680 --> 00:10:14,800
and essentially what the approver is

278
00:10:14,800 --> 00:10:16,880
going to do is emulate a conversation

279
00:10:16,880 --> 00:10:18,720
with the verifier and then send over the

280
00:10:18,720 --> 00:10:20,880
resulting transfer to the verifier

281
00:10:20,880 --> 00:10:22,560
but the way we're going to do it is the

282
00:10:22,560 --> 00:10:23,680
approver is going to compute the

283
00:10:23,680 --> 00:10:25,600
messages the approver masters as it

284
00:10:25,600 --> 00:10:27,440
would in the interactive protocol and

285
00:10:27,440 --> 00:10:28,800
then when it's time for verifier to

286
00:10:28,800 --> 00:10:30,480
respond what it's going to do instead is

287
00:10:30,480 --> 00:10:32,399
how apply the fiat in your hash function

288
00:10:32,399 --> 00:10:34,320
to the transcript so far and use that to

289
00:10:34,320 --> 00:10:36,399
compute the next verifier message

290
00:10:36,399 --> 00:10:38,720
so it proceeds in this way uh generating

291
00:10:38,720 --> 00:10:40,160
the whole transfer of interaction sends

292
00:10:40,160 --> 00:10:42,000
it over to the verifier and the verifier

293
00:10:42,000 --> 00:10:43,839
can easily check by just recomputing the

294
00:10:43,839 --> 00:10:45,519
the challenges using the hash function

295
00:10:45,519 --> 00:10:46,959
and then accepting based on whether or

296
00:10:46,959 --> 00:10:49,040
not the verifier would accept the

297
00:10:49,040 --> 00:10:52,399
original interactive protocol

298
00:10:52,399 --> 00:10:53,839
and so this has been an incredibly

299
00:10:53,839 --> 00:10:55,440
fruitful approach to building crypto

300
00:10:55,440 --> 00:10:57,760
both in theory and practice the idea is

301
00:10:57,760 --> 00:10:59,440
roughly construct some kind of

302
00:10:59,440 --> 00:11:01,519
interactive protocol for a desired

303
00:11:01,519 --> 00:11:03,519
useful functionality say identify

304
00:11:03,519 --> 00:11:05,680
yourself over the internet to someone

305
00:11:05,680 --> 00:11:07,519
and then you apply fiat mirror to it to

306
00:11:07,519 --> 00:11:09,279
get a non-interactive implementation of

307
00:11:09,279 --> 00:11:11,200
the same functionality

308
00:11:11,200 --> 00:11:13,279
and so this is incredibly useful really

309
00:11:13,279 --> 00:11:15,360
broad idea

310
00:11:15,360 --> 00:11:17,279
but the problem with it is that our

311
00:11:17,279 --> 00:11:19,120
priority it's not clear that even if you

312
00:11:19,120 --> 00:11:21,360
start with a sound uh interactive

313
00:11:21,360 --> 00:11:23,440
protocol that fiat mirror is actually

314
00:11:23,440 --> 00:11:26,480
going to preserve soundness

315
00:11:26,480 --> 00:11:28,560
so here's the intuition to keep in mind

316
00:11:28,560 --> 00:11:30,320
um you have an interactive protocol that

317
00:11:30,320 --> 00:11:31,279
is sound

318
00:11:31,279 --> 00:11:32,720
uh when these rises these random

319
00:11:32,720 --> 00:11:35,360
challenges are in fact chosen randomly

320
00:11:35,360 --> 00:11:37,040
um so what the fiat mirror hash function

321
00:11:37,040 --> 00:11:39,279
a should guarantee is roughly that the

322
00:11:39,279 --> 00:11:40,640
uh this shouldn't allow the approver to

323
00:11:40,640 --> 00:11:42,560
obtain favorable rise right it shouldn't

324
00:11:42,560 --> 00:11:44,720
allow it to generate verifier challenges

325
00:11:44,720 --> 00:11:46,720
that will allow it to fool a verifier on

326
00:11:46,720 --> 00:11:49,200
a false instance

327
00:11:49,200 --> 00:11:50,880
so there's basically been two classes of

328
00:11:50,880 --> 00:11:52,240
approaches for

329
00:11:52,240 --> 00:11:54,160
formalizing this in literature

330
00:11:54,160 --> 00:11:56,320
you can show that roughly speaking uh

331
00:11:56,320 --> 00:11:57,360
whenever you would expect the

332
00:11:57,360 --> 00:11:59,200
achievement to work you can show that

333
00:11:59,200 --> 00:12:00,639
when the theatre hash function is

334
00:12:00,639 --> 00:12:02,320
modeled as a random oracle or a truly

335
00:12:02,320 --> 00:12:03,839
random function that you can usually

336
00:12:03,839 --> 00:12:04,880
prove this you can prove this in the

337
00:12:04,880 --> 00:12:06,079
random oracle model that it will

338
00:12:06,079 --> 00:12:07,600
preserve soundness

339
00:12:07,600 --> 00:12:09,279
and more recently there's been a really

340
00:12:09,279 --> 00:12:11,839
a really exciting line of work um giving

341
00:12:11,839 --> 00:12:13,440
sound the educare instantiations in the

342
00:12:13,440 --> 00:12:15,360
standard model in particular identifying

343
00:12:15,360 --> 00:12:16,560
this property called correlation

344
00:12:16,560 --> 00:12:17,920
interactability

345
00:12:17,920 --> 00:12:19,760
and showing that for a narrower but

346
00:12:19,760 --> 00:12:21,920
still interesting class of protocols

347
00:12:21,920 --> 00:12:23,760
this actually suffices to get sound via

348
00:12:23,760 --> 00:12:26,079
instantiations

349
00:12:26,079 --> 00:12:28,079
but in all these cases the theatre hash

350
00:12:28,079 --> 00:12:30,240
function h is at its core a

351
00:12:30,240 --> 00:12:31,600
cryptographic hash function there is

352
00:12:31,600 --> 00:12:33,279
some sort of cryptographic hardness

353
00:12:33,279 --> 00:12:35,120
associated with the hash function itself

354
00:12:35,120 --> 00:12:36,560
and it sounds like a really natural

355
00:12:36,560 --> 00:12:38,240
thing for exactly what we're trying to

356
00:12:38,240 --> 00:12:39,920
do here right you don't want the hashtag

357
00:12:39,920 --> 00:12:41,200
to allow the approver to get favorable

358
00:12:41,200 --> 00:12:42,800
ris so you want the hash function to

359
00:12:42,800 --> 00:12:44,079
have some sort of cryptographic

360
00:12:44,079 --> 00:12:46,800
properties that will capture this

361
00:12:46,800 --> 00:12:47,920
in this work

362
00:12:47,920 --> 00:12:50,000
uh we asked the maybe seemingly naive

363
00:12:50,000 --> 00:12:52,079
question is this necessary all right

364
00:12:52,079 --> 00:12:53,760
does fiat shmear really require a

365
00:12:53,760 --> 00:12:55,360
cryptographic hash function for for

366
00:12:55,360 --> 00:12:58,160
sound compilation

367
00:12:58,160 --> 00:13:00,079
and our first set of results are a set

368
00:13:00,079 --> 00:13:02,560
of perhaps surprising positive results

369
00:13:02,560 --> 00:13:04,079
where we show that in fact some

370
00:13:04,079 --> 00:13:06,399
protocols some fairly interesting

371
00:13:06,399 --> 00:13:08,399
protocols can be compiled with really

372
00:13:08,399 --> 00:13:11,040
simple uh non-cryptographic theatrical

373
00:13:11,040 --> 00:13:12,399
hash functions

374
00:13:12,399 --> 00:13:14,240
and so what i mean by that like what is

375
00:13:14,240 --> 00:13:16,560
a non-cryptographic hash function i mean

376
00:13:16,560 --> 00:13:19,680
something like taking a vector of uh

377
00:13:19,680 --> 00:13:21,360
entries over zp and spit out the bit

378
00:13:21,360 --> 00:13:23,040
decomposition specter right so no

379
00:13:23,040 --> 00:13:25,200
cryptography no one awayness whatsoever

380
00:13:25,200 --> 00:13:26,240
or another

381
00:13:26,240 --> 00:13:28,079
example would be literally a linear

382
00:13:28,079 --> 00:13:29,760
function on the input

383
00:13:29,760 --> 00:13:31,279
and we show that that really simple

384
00:13:31,279 --> 00:13:32,959
theatrical hash functions like this and

385
00:13:32,959 --> 00:13:35,200
in certain cases uh compile interesting

386
00:13:35,200 --> 00:13:36,800
protocols such as lube testing

387
00:13:36,800 --> 00:13:38,639
identification protocol schnorr's

388
00:13:38,639 --> 00:13:40,800
protocol sean peterson

389
00:13:40,800 --> 00:13:41,680
um

390
00:13:41,680 --> 00:13:42,880
and so these positive results are in a

391
00:13:42,880 --> 00:13:44,959
variety of settings uh the luba chassis

392
00:13:44,959 --> 00:13:46,320
positive result we show in the plane

393
00:13:46,320 --> 00:13:47,920
model whereas the group based positive

394
00:13:47,920 --> 00:13:49,120
results we

395
00:13:49,120 --> 00:13:50,560
prove security in the generic group

396
00:13:50,560 --> 00:13:52,880
model

397
00:13:53,120 --> 00:13:54,560
so we complement this with a set of

398
00:13:54,560 --> 00:13:56,000
negative results essentially

399
00:13:56,000 --> 00:13:58,480
establishing some limitations on

400
00:13:58,480 --> 00:14:00,240
how far you can take this idea how far

401
00:14:00,240 --> 00:14:02,240
you can go without putting cryptography

402
00:14:02,240 --> 00:14:04,320
into your theater hash functions and we

403
00:14:04,320 --> 00:14:06,079
show that cryptographic ph mere hash

404
00:14:06,079 --> 00:14:07,920
functions really are necessary to

405
00:14:07,920 --> 00:14:10,160
compile a large class of three message

406
00:14:10,160 --> 00:14:11,760
honest verifier zero knowledge arguments

407
00:14:11,760 --> 00:14:13,600
these are really interesting protocols

408
00:14:13,600 --> 00:14:14,800
that we'd love to be able to compile

409
00:14:14,800 --> 00:14:16,079
with the echometer

410
00:14:16,079 --> 00:14:17,680
and we show for

411
00:14:17,680 --> 00:14:19,519
this large class of protocols that

412
00:14:19,519 --> 00:14:21,040
cryptographic piezmere hash functions

413
00:14:21,040 --> 00:14:23,600
are necessary so what i mean what is

414
00:14:23,600 --> 00:14:24,959
this large class

415
00:14:24,959 --> 00:14:26,560
the important properties are that the

416
00:14:26,560 --> 00:14:28,000
first message of the protocol is

417
00:14:28,000 --> 00:14:29,360
pseudorandom

418
00:14:29,360 --> 00:14:31,440
and the soundness of the protocol this

419
00:14:31,440 --> 00:14:32,639
is crucial

420
00:14:32,639 --> 00:14:34,240
the sound the negligible soundness area

421
00:14:34,240 --> 00:14:35,839
of the protocol is achieved through pale

422
00:14:35,839 --> 00:14:37,040
repetition

423
00:14:37,040 --> 00:14:38,639
of some base protocol where the

424
00:14:38,639 --> 00:14:40,399
challenge space size is small this this

425
00:14:40,399 --> 00:14:43,440
is really crucial to the result

426
00:14:43,440 --> 00:14:45,120
so examples of protocols that satisfy

427
00:14:45,120 --> 00:14:46,880
these properties for instance classic

428
00:14:46,880 --> 00:14:48,560
protocols such as blum's hamilton

429
00:14:48,560 --> 00:14:50,560
protocol once you parallel repeat it uh

430
00:14:50,560 --> 00:14:52,480
the gmw3 coloring protocol parallel

431
00:14:52,480 --> 00:14:54,480
petition and even a one bit challenge

432
00:14:54,480 --> 00:14:55,519
version of schnorr with parallel

433
00:14:55,519 --> 00:14:57,279
repetition and this last example was

434
00:14:57,279 --> 00:14:58,639
really included to highlight the fact

435
00:14:58,639 --> 00:15:00,720
that it's not like some group magic that

436
00:15:00,720 --> 00:15:02,639
is making um

437
00:15:02,639 --> 00:15:03,920
that's that's taking the the

438
00:15:03,920 --> 00:15:05,279
cryptography out of the extra hash

439
00:15:05,279 --> 00:15:07,519
function um it was really the structure

440
00:15:07,519 --> 00:15:10,000
of the original schnorr protocol um but

441
00:15:10,000 --> 00:15:11,920
here uh when you get sounded through

442
00:15:11,920 --> 00:15:13,040
parallel repetition even though you're

443
00:15:13,040 --> 00:15:16,480
using groups you still need um

444
00:15:16,480 --> 00:15:17,680
you still need cryptography in your

445
00:15:17,680 --> 00:15:19,600
theater hash function

446
00:15:19,600 --> 00:15:20,560
all right so

447
00:15:20,560 --> 00:15:22,160
um in a little bit more detail what we

448
00:15:22,160 --> 00:15:24,160
show is that if h is a sound the

449
00:15:24,160 --> 00:15:25,440
engineer hash function for such a

450
00:15:25,440 --> 00:15:26,639
protocol

451
00:15:26,639 --> 00:15:28,720
then h must satisfy a cryptographic

452
00:15:28,720 --> 00:15:31,040
security property we call mix and match

453
00:15:31,040 --> 00:15:33,839
resistance essentially this is a

454
00:15:33,839 --> 00:15:35,519
challenger adversary game you can write

455
00:15:35,519 --> 00:15:37,279
down about h has nothing to do with the

456
00:15:37,279 --> 00:15:40,000
protocol is just a property of h and

457
00:15:40,000 --> 00:15:41,600
this game must have a statistical

458
00:15:41,600 --> 00:15:43,680
computational gap if you want h to be a

459
00:15:43,680 --> 00:15:46,240
sound the smear hash function compiler

460
00:15:46,240 --> 00:15:47,440
and in particular we show that this

461
00:15:47,440 --> 00:15:50,480
property implies only functions

462
00:15:50,480 --> 00:15:52,959
okay so to sum up the answer to our

463
00:15:52,959 --> 00:15:54,720
title question of does the actual mirror

464
00:15:54,720 --> 00:15:56,880
require a cryptographic hash function is

465
00:15:56,880 --> 00:15:58,240
uh sometimes

466
00:15:58,240 --> 00:16:00,560
okay so for certain protocols simple ph

467
00:16:00,560 --> 00:16:02,320
or hash functions can be enough

468
00:16:02,320 --> 00:16:03,839
but for many many other protocols of

469
00:16:03,839 --> 00:16:05,680
interest we show that cryptography is

470
00:16:05,680 --> 00:16:07,759
needed in your in your hash function

471
00:16:07,759 --> 00:16:09,519
so our paper is up on eprint and i

472
00:16:09,519 --> 00:16:11,199
highly encourage you all to take a look

473
00:16:11,199 --> 00:16:13,439
thanks

474
00:16:14,800 --> 00:16:17,440
thank the speaker for the talk

475
00:16:17,440 --> 00:16:18,240
and

476
00:16:18,240 --> 00:16:22,360
any questions from the audience

477
00:16:28,720 --> 00:16:30,959
feel free to unmute yourself if you have

478
00:16:30,959 --> 00:16:33,279
any

479
00:16:34,720 --> 00:16:37,360
um maybe i can ask so

480
00:16:37,360 --> 00:16:39,600
so if for for those things where it is

481
00:16:39,600 --> 00:16:41,759
not necessary it seems a very exciting

482
00:16:41,759 --> 00:16:44,240
result maybe i'm missing something like

483
00:16:44,240 --> 00:16:45,199
is it

484
00:16:45,199 --> 00:16:46,480
is it does it mean that you don't need

485
00:16:46,480 --> 00:16:50,000
random oracles for signatures or

486
00:16:50,000 --> 00:16:52,079
yeah so okay the the the answer to this

487
00:16:52,079 --> 00:16:55,040
is a little bit complicated um

488
00:16:55,040 --> 00:16:57,279
so there are certainly limitations first

489
00:16:57,279 --> 00:16:58,880
off um

490
00:16:58,880 --> 00:17:01,199
it is a a uh

491
00:17:01,199 --> 00:17:03,440
it is a generic group result and so we

492
00:17:03,440 --> 00:17:04,959
are saying that you really require

493
00:17:04,959 --> 00:17:06,880
optimal hardness from your group and so

494
00:17:06,880 --> 00:17:08,000
if you really believe that your group

495
00:17:08,000 --> 00:17:09,760
has some sort of optimal hardness then

496
00:17:09,760 --> 00:17:12,240
we are saying that yes it is conceivable

497
00:17:12,240 --> 00:17:15,599
that you could have a a sound or um

498
00:17:15,599 --> 00:17:17,119
a sound fiat mirror compilation that

499
00:17:17,119 --> 00:17:18,640
just uses an information to write a hash

500
00:17:18,640 --> 00:17:20,799
function

501
00:17:20,799 --> 00:17:24,079
there are uh

502
00:17:24,240 --> 00:17:26,160
there are some caveats here where

503
00:17:26,160 --> 00:17:29,199
basically show that

504
00:17:29,840 --> 00:17:31,200
when we say theatre mute here i guess

505
00:17:31,200 --> 00:17:33,919
i'm referring to compiling into a an

506
00:17:33,919 --> 00:17:35,520
interactive identification protocol into

507
00:17:35,520 --> 00:17:37,679
a non-interactive id protocol

508
00:17:37,679 --> 00:17:39,039
um but if i'm thinking about getting

509
00:17:39,039 --> 00:17:40,720
full signatures which is the the

510
00:17:40,720 --> 00:17:43,360
motivating practical application here um

511
00:17:43,360 --> 00:17:45,520
to actually get standard notions of

512
00:17:45,520 --> 00:17:47,919
signature security you need a small

513
00:17:47,919 --> 00:17:49,200
message space

514
00:17:49,200 --> 00:17:51,360
uh and and actually

515
00:17:51,360 --> 00:17:53,280
uh showing that this can be made general

516
00:17:53,280 --> 00:17:55,520
requires the use of more complicated

517
00:17:55,520 --> 00:17:56,640
hash functions like random oracle

518
00:17:56,640 --> 00:17:59,120
potentially um so

519
00:17:59,120 --> 00:18:01,360
uh in terms of like

520
00:18:01,360 --> 00:18:02,720
having meaningful practical applications

521
00:18:02,720 --> 00:18:04,799
right away this this result doesn't

522
00:18:04,799 --> 00:18:07,280
doesn't say that um it's saying you know

523
00:18:07,280 --> 00:18:08,799
where does the security come from in the

524
00:18:08,799 --> 00:18:10,080
fiat mirror hash function and we're

525
00:18:10,080 --> 00:18:12,000
saying that uh you can get some of the

526
00:18:12,000 --> 00:18:13,679
soundness or you can get the soundness

527
00:18:13,679 --> 00:18:14,960
without needing

528
00:18:14,960 --> 00:18:16,799
crypto in your fiat mirror hash function

529
00:18:16,799 --> 00:18:18,080
but you may need crypto somewhere else

530
00:18:18,080 --> 00:18:19,679
in the protocol

531
00:18:19,679 --> 00:18:20,559
um

532
00:18:20,559 --> 00:18:21,840
if either of you have anything to add

533
00:18:21,840 --> 00:18:24,399
feel free to

534
00:18:26,240 --> 00:18:29,039
um so this limitation about the message

535
00:18:29,039 --> 00:18:31,520
space uh is that is that inherent like

536
00:18:31,520 --> 00:18:33,280
is there an attack or is it just a

537
00:18:33,280 --> 00:18:36,720
limitation of the current analysis

538
00:18:36,720 --> 00:18:38,320
i'm pretty sure it's inherent you can't

539
00:18:38,320 --> 00:18:40,799
uh like if your hash like if your

540
00:18:40,799 --> 00:18:42,880
message space is larger than the size of

541
00:18:42,880 --> 00:18:44,480
the signatures there's going to be some

542
00:18:44,480 --> 00:18:45,840
sort of collision attack on an

543
00:18:45,840 --> 00:18:47,679
information theoretic hash function but

544
00:18:47,679 --> 00:18:49,760
we show essentially that if like without

545
00:18:49,760 --> 00:18:52,320
the like as long as the message space is

546
00:18:52,320 --> 00:18:55,200
not larger than the signature size then

547
00:18:55,200 --> 00:18:57,760
then then information theoretic hash

548
00:18:57,760 --> 00:19:00,000
functions are okay

549
00:19:00,000 --> 00:19:02,240
thanks

550
00:19:04,080 --> 00:19:05,840
also a quick question about the generic

551
00:19:05,840 --> 00:19:07,840
group model there is that mars group or

552
00:19:07,840 --> 00:19:09,919
is it ships because shoops

553
00:19:09,919 --> 00:19:11,760
comes with like a random function itself

554
00:19:11,760 --> 00:19:14,240
i guess it's mars when you say you model

555
00:19:14,240 --> 00:19:16,080
group with generic group model

556
00:19:16,080 --> 00:19:18,000
you know it it is a distribution our

557
00:19:18,000 --> 00:19:19,679
group model and i think that maybe the

558
00:19:19,679 --> 00:19:21,840
distinction here is that um when you're

559
00:19:21,840 --> 00:19:23,679
talking about constructions

560
00:19:23,679 --> 00:19:24,960
uh it makes a lot more sense to talk

561
00:19:24,960 --> 00:19:26,880
about troops protocol

562
00:19:26,880 --> 00:19:29,039
formulation of the ggm versus mars

563
00:19:29,039 --> 00:19:30,720
because in mars um

564
00:19:30,720 --> 00:19:32,080
like so so

565
00:19:32,080 --> 00:19:33,919
in this case you actually need to apply

566
00:19:33,919 --> 00:19:35,360
the hash function

567
00:19:35,360 --> 00:19:37,200
the theotomir hash function to a group

568
00:19:37,200 --> 00:19:40,240
element and mora's model does not allow

569
00:19:40,240 --> 00:19:42,240
you to even specify what that means

570
00:19:42,240 --> 00:19:43,440
so you need to have some kind of

571
00:19:43,440 --> 00:19:44,880
representation of the group element to

572
00:19:44,880 --> 00:19:46,080
even make sense of what it means to

573
00:19:46,080 --> 00:19:48,000
apply a hash function to it and troops

574
00:19:48,000 --> 00:19:48,799
is the

575
00:19:48,799 --> 00:19:50,400
of the two gtms the one that actually

576
00:19:50,400 --> 00:19:51,440
gives you representation to buy your

577
00:19:51,440 --> 00:19:52,880
hash function two

578
00:19:52,880 --> 00:19:55,200
um so yes we are saying that the result

579
00:19:55,200 --> 00:19:56,640
the proof does rely on the fact that you

580
00:19:56,640 --> 00:19:58,000
are getting a randomness from the group

581
00:19:58,000 --> 00:19:59,200
representation

582
00:19:59,200 --> 00:20:01,280
uh but the hash function itself is still

583
00:20:01,280 --> 00:20:02,799
some really simple function like a

584
00:20:02,799 --> 00:20:04,400
literally like a linear function on that

585
00:20:04,400 --> 00:20:07,120
group element

586
00:20:07,120 --> 00:20:08,320
thank you

587
00:20:08,320 --> 00:20:10,240
we have more questions from the audience

588
00:20:10,240 --> 00:20:11,840
but let's push these questions to the

589
00:20:11,840 --> 00:20:14,640
end of the session um after the third

590
00:20:14,640 --> 00:20:15,679
talk

591
00:20:15,679 --> 00:20:18,640
because i just wanted to keep on time

592
00:20:18,640 --> 00:20:20,400
and let's thank for me again and we will

593
00:20:20,400 --> 00:20:22,080
take more questions at the end of the

594
00:20:22,080 --> 00:20:23,280
session

595
00:20:23,280 --> 00:20:26,158
the next speaker

596
00:20:26,480 --> 00:20:29,120
the next talk will be on composition

597
00:20:29,120 --> 00:20:31,360
with knowledgeable sorry knowledge

598
00:20:31,360 --> 00:20:34,320
assumptions uh by thomas gerber uh

599
00:20:34,320 --> 00:20:38,799
aguilas kiayas and marco cole weiss and

600
00:20:38,799 --> 00:20:41,600
thomas will give the talk

601
00:20:41,600 --> 00:20:44,080
thank you very much for the introduction

602
00:20:44,080 --> 00:20:46,000
um so yeah this is on composition of

603
00:20:46,000 --> 00:20:47,440
knowledge assumptions

604
00:20:47,440 --> 00:20:50,320
and i'm going to start with a brief

605
00:20:50,320 --> 00:20:52,159
recap of uh

606
00:20:52,159 --> 00:20:54,240
simulation based composition

607
00:20:54,240 --> 00:20:56,240
um because that's the kind of

608
00:20:56,240 --> 00:20:57,840
composition we're really talking about

609
00:20:57,840 --> 00:20:59,200
and in general

610
00:20:59,200 --> 00:21:01,039
your security statements are something

611
00:21:01,039 --> 00:21:03,280
of the type that you want to show some

612
00:21:03,280 --> 00:21:05,679
uh real world protocol here on the left

613
00:21:05,679 --> 00:21:07,440
is equivalent to some ideal

614
00:21:07,440 --> 00:21:09,840
specification so you see for example

615
00:21:09,840 --> 00:21:11,039
that that would be your ideal

616
00:21:11,039 --> 00:21:13,360
functionality

617
00:21:13,360 --> 00:21:14,960
um and

618
00:21:14,960 --> 00:21:17,120
part of the simulation part of the

619
00:21:17,120 --> 00:21:19,280
simulation security comes from there

620
00:21:19,280 --> 00:21:21,760
being a smaller attack interface in the

621
00:21:21,760 --> 00:21:25,280
ideal specification uh which a simulator

622
00:21:25,280 --> 00:21:27,120
translates into a larger attack

623
00:21:27,120 --> 00:21:29,360
interface to match what is available in

624
00:21:29,360 --> 00:21:30,880
the real world

625
00:21:30,880 --> 00:21:32,400
um and

626
00:21:32,400 --> 00:21:34,640
your security statement then usually

627
00:21:34,640 --> 00:21:36,600
comes um in terms of this

628
00:21:36,600 --> 00:21:38,880
indistinguishability by saying

629
00:21:38,880 --> 00:21:40,240
uh well

630
00:21:40,240 --> 00:21:42,840
if we plug this in with some

631
00:21:42,840 --> 00:21:46,720
arbitrary environment or distinguisher

632
00:21:46,720 --> 00:21:49,360
belonging to some set of potential

633
00:21:49,360 --> 00:21:51,120
distinguishes and i'll get into that in

634
00:21:51,120 --> 00:21:52,240
a little bit

635
00:21:52,240 --> 00:21:53,919
um then

636
00:21:53,919 --> 00:21:55,360
if you use the same distinguisher on

637
00:21:55,360 --> 00:21:58,320
both sides the the two are identical and

638
00:21:58,320 --> 00:22:00,159
they will behave identically when

639
00:22:00,159 --> 00:22:02,480
they're uh actually executed

640
00:22:02,480 --> 00:22:04,960
and composition is then actually just a

641
00:22:04,960 --> 00:22:07,039
property of this set of distinguishes

642
00:22:07,039 --> 00:22:09,120
because what you really want is you want

643
00:22:09,120 --> 00:22:10,799
to be able to

644
00:22:10,799 --> 00:22:12,720
move things in and out of this set of

645
00:22:12,720 --> 00:22:14,480
distinguishes and

646
00:22:14,480 --> 00:22:16,240
if it's closed under

647
00:22:16,240 --> 00:22:19,039
the addition and removal of parts of the

648
00:22:19,039 --> 00:22:20,400
network

649
00:22:20,400 --> 00:22:23,919
then you have composition essentially

650
00:22:23,919 --> 00:22:26,320
now with knowledge assumptions i'm going

651
00:22:26,320 --> 00:22:28,559
to go with the example of the algebraic

652
00:22:28,559 --> 00:22:29,679
group model

653
00:22:29,679 --> 00:22:31,120
which is quite powerful knowledge

654
00:22:31,120 --> 00:22:33,840
assumption but it illustrates quite well

655
00:22:33,840 --> 00:22:36,720
what you actually want to do and usually

656
00:22:36,720 --> 00:22:38,559
there the statement is whenever you're

657
00:22:38,559 --> 00:22:41,520
outputting some group element here why

658
00:22:41,520 --> 00:22:43,600
you need to know how to compute this

659
00:22:43,600 --> 00:22:44,480
from

660
00:22:44,480 --> 00:22:47,120
group elements you go as inputs

661
00:22:47,120 --> 00:22:49,360
and the way this is usually formalized

662
00:22:49,360 --> 00:22:51,200
is to say that there needs to exist some

663
00:22:51,200 --> 00:22:53,760
extractor algorithm that given all the

664
00:22:53,760 --> 00:22:55,520
same inputs given the code to the

665
00:22:55,520 --> 00:22:57,200
algorithm you're running and given its

666
00:22:57,200 --> 00:22:58,480
randomness

667
00:22:58,480 --> 00:23:00,159
will be able to output the

668
00:23:00,159 --> 00:23:02,559
representation of y so it'll be able to

669
00:23:02,559 --> 00:23:04,159
output something that

670
00:23:04,159 --> 00:23:06,559
explains further as to what's actually

671
00:23:06,559 --> 00:23:09,840
going on in the output of y

672
00:23:09,840 --> 00:23:12,559
now if we look again at the

673
00:23:12,559 --> 00:23:14,640
compositional setting where we want to

674
00:23:14,640 --> 00:23:17,200
use this usually is in the simulator

675
00:23:17,200 --> 00:23:19,120
this is where

676
00:23:19,120 --> 00:23:21,760
we get some real world cryptographic

677
00:23:21,760 --> 00:23:24,159
objects and we want to extract some more

678
00:23:24,159 --> 00:23:26,000
information from that to be able to

679
00:23:26,000 --> 00:23:28,559
replicate it in the ideal world

680
00:23:28,559 --> 00:23:29,919
now

681
00:23:29,919 --> 00:23:32,480
this is a problem because what that

682
00:23:32,480 --> 00:23:34,320
means if we want to give the simulator

683
00:23:34,320 --> 00:23:35,679
access to this

684
00:23:35,679 --> 00:23:38,000
is we have to give it the code and the

685
00:23:38,000 --> 00:23:39,520
randomness to the distinguishing

686
00:23:39,520 --> 00:23:41,200
environment

687
00:23:41,200 --> 00:23:43,679
and that means we've removed

688
00:23:43,679 --> 00:23:45,679
all notion of privacy from our ideal

689
00:23:45,679 --> 00:23:47,200
world because we've given the ideal

690
00:23:47,200 --> 00:23:49,600
world adversary full access to

691
00:23:49,600 --> 00:23:51,600
everything that's going on so we don't

692
00:23:51,600 --> 00:23:54,320
want that and the the solution that we

693
00:23:54,320 --> 00:23:56,159
have to this is to

694
00:23:56,159 --> 00:23:57,600
uh

695
00:23:57,600 --> 00:24:00,960
essentially allow the the simulator to

696
00:24:00,960 --> 00:24:02,240
query

697
00:24:02,240 --> 00:24:05,679
uh to do oracle queries uh about the

698
00:24:05,679 --> 00:24:07,279
knowledge assumption and to essentially

699
00:24:07,279 --> 00:24:10,080
just do oracle extraction queries

700
00:24:10,080 --> 00:24:12,240
uh so in particular we attach a type

701
00:24:12,240 --> 00:24:13,760
system to messages

702
00:24:13,760 --> 00:24:16,240
uh and we lift the

703
00:24:16,240 --> 00:24:18,320
uh distinguishing environments on both

704
00:24:18,320 --> 00:24:20,559
sides and we say first off that it has

705
00:24:20,559 --> 00:24:21,840
to be something that supports the

706
00:24:21,840 --> 00:24:23,200
knowledge assumption so we have to be

707
00:24:23,200 --> 00:24:24,559
able to extract

708
00:24:24,559 --> 00:24:27,360
um and then whenever it sends a

709
00:24:27,360 --> 00:24:29,200
uh what we call a knowledge implying

710
00:24:29,200 --> 00:24:31,520
object so in the case of the agm just a

711
00:24:31,520 --> 00:24:32,960
group element

712
00:24:32,960 --> 00:24:35,679
we transform that into a message which

713
00:24:35,679 --> 00:24:37,679
also sends the corresponding witness

714
00:24:37,679 --> 00:24:40,720
explaining how this was constructed

715
00:24:40,720 --> 00:24:43,039
um now that isn't what the

716
00:24:43,039 --> 00:24:45,760
other end of the the

717
00:24:45,760 --> 00:24:48,799
expects so this message is then again

718
00:24:48,799 --> 00:24:50,000
intercepted

719
00:24:50,000 --> 00:24:50,880
and

720
00:24:50,880 --> 00:24:53,360
just these pairs of knowledge implying

721
00:24:53,360 --> 00:24:55,760
objects and witnesses are recorded in a

722
00:24:55,760 --> 00:24:57,279
repository

723
00:24:57,279 --> 00:24:59,440
which the simulator has access to in the

724
00:24:59,440 --> 00:25:01,840
ideal world but no one can access in the

725
00:25:01,840 --> 00:25:03,440
real world

726
00:25:03,440 --> 00:25:06,799
and this is sort of the core of the idea

727
00:25:06,799 --> 00:25:08,640
now one crucial

728
00:25:08,640 --> 00:25:11,600
thing that this distinction makes is it

729
00:25:11,600 --> 00:25:13,279
limits the set of distinguishing

730
00:25:13,279 --> 00:25:15,360
environments we can consider to a set of

731
00:25:15,360 --> 00:25:17,600
possible distinguishes

732
00:25:17,600 --> 00:25:20,480
and interestingly this cannot

733
00:25:20,480 --> 00:25:22,559
trivially absorb the simulate so we have

734
00:25:22,559 --> 00:25:23,440
to

735
00:25:23,440 --> 00:25:25,919
change the

736
00:25:25,919 --> 00:25:27,760
the algebra of composition to account

737
00:25:27,760 --> 00:25:29,200
for this and we do this by making the

738
00:25:29,200 --> 00:25:32,559
sets of distinguishers uh explicit and

739
00:25:32,559 --> 00:25:34,240
in particular for transitivity that

740
00:25:34,240 --> 00:25:36,320
means you need to support absorbing the

741
00:25:36,320 --> 00:25:38,720
simulator for the first step

742
00:25:38,720 --> 00:25:40,960
and for parallel composition you need to

743
00:25:40,960 --> 00:25:42,640
be able to support absorbing what you're

744
00:25:42,640 --> 00:25:44,559
parallelly composing with

745
00:25:44,559 --> 00:25:46,240
now for knowledge assumptions what that

746
00:25:46,240 --> 00:25:48,320
means in practice is if you have

747
00:25:48,320 --> 00:25:51,360
disjoint knowledge assumptions k1 and k2

748
00:25:51,360 --> 00:25:53,200
then you can get transitivity provided

749
00:25:53,200 --> 00:25:54,799
you can lift one of the simulators so

750
00:25:54,799 --> 00:25:56,720
you can extract from it

751
00:25:56,720 --> 00:25:58,880
and if you are parallely composing if

752
00:25:58,880 --> 00:26:00,080
you can extract from what you're

753
00:26:00,080 --> 00:26:01,840
parallely composing then that's also

754
00:26:01,840 --> 00:26:03,440
fine

755
00:26:03,440 --> 00:26:06,400
um we have impossibility results if you

756
00:26:06,400 --> 00:26:08,799
you don't do this generalization so

757
00:26:08,799 --> 00:26:10,720
there are some special cases where it

758
00:26:10,720 --> 00:26:12,480
does go through but in general there are

759
00:26:12,480 --> 00:26:15,120
counter examples and we give those

760
00:26:15,120 --> 00:26:17,200
um and we also

761
00:26:17,200 --> 00:26:19,440
have as our main motivation that we want

762
00:26:19,440 --> 00:26:21,440
to be able to show the composability of

763
00:26:21,440 --> 00:26:23,520
snarks and we do that for the graph 16

764
00:26:23,520 --> 00:26:25,360
ck snark which

765
00:26:25,360 --> 00:26:27,039
recently was shown to be simulation

766
00:26:27,039 --> 00:26:29,039
extractable and we show that with

767
00:26:29,039 --> 00:26:30,320
special

768
00:26:30,320 --> 00:26:33,120
case analysis you can also do

769
00:26:33,120 --> 00:26:35,200
secure setups for these

770
00:26:35,200 --> 00:26:36,640
now there are still a number of open

771
00:26:36,640 --> 00:26:38,480
questions in particular

772
00:26:38,480 --> 00:26:39,440
a lot of

773
00:26:39,440 --> 00:26:40,720
algorithms which use knowledge

774
00:26:40,720 --> 00:26:42,960
assumptions don't aren't designed with

775
00:26:42,960 --> 00:26:44,799
simulation extractability in mind and

776
00:26:44,799 --> 00:26:46,559
this is something

777
00:26:46,559 --> 00:26:48,559
which we find very interesting and which

778
00:26:48,559 --> 00:26:49,440
should be

779
00:26:49,440 --> 00:26:51,279
explored more

780
00:26:51,279 --> 00:26:54,799
and also our results show an explicit or

781
00:26:54,799 --> 00:26:57,520
explicitly show a negative result for

782
00:26:57,520 --> 00:26:59,120
reusing knowledge assumptions

783
00:26:59,120 --> 00:27:01,520
generically in practice that we see this

784
00:27:01,520 --> 00:27:03,200
is done quite often especially with

785
00:27:03,200 --> 00:27:04,880
groups we see that they are reused quite

786
00:27:04,880 --> 00:27:06,960
frequently and then the algebraic group

787
00:27:06,960 --> 00:27:08,400
model is applied to them and this is

788
00:27:08,400 --> 00:27:09,600
something which

789
00:27:09,600 --> 00:27:11,919
uh our result does not immediately show

790
00:27:11,919 --> 00:27:13,919
it's safe and we believe there needs to

791
00:27:13,919 --> 00:27:16,000
be further analysis to see

792
00:27:16,000 --> 00:27:18,000
when is it actually safe and

793
00:27:18,000 --> 00:27:21,039
yeah yeah is current practice uh good in

794
00:27:21,039 --> 00:27:23,600
that regard

795
00:27:24,320 --> 00:27:27,919
that's it i'll take questions now

796
00:27:27,919 --> 00:27:30,720
let's thank the speaker for the talk

797
00:27:30,720 --> 00:27:33,360
uh any questions from the audience

798
00:27:33,360 --> 00:27:35,840
for thomas

799
00:27:41,679 --> 00:27:43,840
okay let's thank the speaker again

800
00:27:43,840 --> 00:27:46,559
and uh we will take more questions for

801
00:27:46,559 --> 00:27:49,520
uh fermi's stock

802
00:27:49,919 --> 00:27:52,080
there is one question on the chat

803
00:27:52,080 --> 00:27:53,039
from

804
00:27:53,039 --> 00:27:54,640
archery

805
00:27:54,640 --> 00:27:56,240
garcia

806
00:27:56,240 --> 00:27:57,760
can you characterize the set of

807
00:27:57,760 --> 00:28:00,480
protocols to which the part one result

808
00:28:00,480 --> 00:28:04,960
applies beyond these specific examples

809
00:28:04,960 --> 00:28:07,360
uh the short answer is no it was sort of

810
00:28:07,360 --> 00:28:09,760
a case-by-case space we can characterize

811
00:28:09,760 --> 00:28:11,520
the protocols that it doesn't apply to

812
00:28:11,520 --> 00:28:12,399
uh but

813
00:28:12,399 --> 00:28:14,399
no getting the boundaries of what

814
00:28:14,399 --> 00:28:15,919
protocols we can actually have positive

815
00:28:15,919 --> 00:28:19,760
results for is not something that we do

816
00:28:20,000 --> 00:28:21,679
and there are more questions on the

817
00:28:21,679 --> 00:28:24,240
zulip channel

818
00:28:24,240 --> 00:28:26,640
i saw that lawrence's question is

819
00:28:26,640 --> 00:28:28,480
already handled do you have more

820
00:28:28,480 --> 00:28:30,880
questions

821
00:28:30,880 --> 00:28:33,440
or is

822
00:28:35,679 --> 00:28:37,279
uh no

823
00:28:37,279 --> 00:28:38,880
uh he answered my question good well

824
00:28:38,880 --> 00:28:40,159
thanks okay

825
00:28:40,159 --> 00:28:42,399
uh okay uh and there's a question from

826
00:28:42,399 --> 00:28:45,360
tal malkin how does mix and match

827
00:28:45,360 --> 00:28:48,320
resistant resistance relate to standard

828
00:28:48,320 --> 00:28:49,600
collision resistance

829
00:28:49,600 --> 00:28:52,000
answer this one uh yeah so yeah so mix

830
00:28:52,000 --> 00:28:53,760
and match resistance

831
00:28:53,760 --> 00:28:56,640
form like uh is is black box separated

832
00:28:56,640 --> 00:28:58,799
from collision resistance so that in

833
00:28:58,799 --> 00:29:00,559
this like mix of mattresses and hash

834
00:29:00,559 --> 00:29:02,399
functions do not imply collision

835
00:29:02,399 --> 00:29:03,520
resistance

836
00:29:03,520 --> 00:29:04,960
the reason is that mix and match

837
00:29:04,960 --> 00:29:07,120
resistance like one way to instantiate

838
00:29:07,120 --> 00:29:08,799
it is by using a form of what's called

839
00:29:08,799 --> 00:29:10,159
single input correlation and

840
00:29:10,159 --> 00:29:12,320
tractability while collision resistance

841
00:29:12,320 --> 00:29:14,240
is a form of two input correlation and

842
00:29:14,240 --> 00:29:17,120
tractability and this is a like uh these

843
00:29:17,120 --> 00:29:20,158
are black box operated

844
00:29:21,360 --> 00:29:22,240
okay

845
00:29:22,240 --> 00:29:25,679
the next question is by what's on that

846
00:29:25,679 --> 00:29:28,240
do these results apply to all the

847
00:29:28,240 --> 00:29:30,159
discrete log statements

848
00:29:30,159 --> 00:29:31,520
i think schmor

849
00:29:31,520 --> 00:29:34,240
considers somewhere

850
00:29:34,240 --> 00:29:37,200
and ends and or is it sexual or just a

851
00:29:37,200 --> 00:29:39,760
proof of proof of knowledge of a single

852
00:29:39,760 --> 00:29:41,600
discrete log not not that we know of

853
00:29:41,600 --> 00:29:43,679
we've handled schnorr we had all tron

854
00:29:43,679 --> 00:29:45,200
peterson which is about equality of two

855
00:29:45,200 --> 00:29:47,679
different discrete logs um but we do not

856
00:29:47,679 --> 00:29:49,279
there's no such a general result for

857
00:29:49,279 --> 00:29:51,919
ants and ores

858
00:29:53,039 --> 00:29:55,279
watson do you have more questions or

859
00:29:55,279 --> 00:29:57,279
does that answer your question

860
00:29:57,279 --> 00:29:59,919
uh can you do some you you did equality

861
00:29:59,919 --> 00:30:03,600
but can i also do linear relations

862
00:30:03,600 --> 00:30:05,039
or

863
00:30:05,039 --> 00:30:05,919
uh

864
00:30:05,919 --> 00:30:07,760
that's a good question uh it's not

865
00:30:07,760 --> 00:30:09,919
something that we that we uh tried to

866
00:30:09,919 --> 00:30:12,559
answer at all

867
00:30:13,840 --> 00:30:16,799
okay uh the next question is by uh

868
00:30:16,799 --> 00:30:20,559
stanislav jeraki you discussed soundness

869
00:30:20,559 --> 00:30:22,480
of the resulting

870
00:30:22,480 --> 00:30:26,080
ni product of ni proofs but what about

871
00:30:26,080 --> 00:30:28,720
their zk properties given your

872
00:30:28,720 --> 00:30:32,399
instantiations of the hash functions

873
00:30:32,399 --> 00:30:34,320
um yeah the zk properties in most cases

874
00:30:34,320 --> 00:30:36,559
are just easy to achieve um by standard

875
00:30:36,559 --> 00:30:37,679
techniques you randomize the hash

876
00:30:37,679 --> 00:30:40,159
function in some way um

877
00:30:40,159 --> 00:30:41,840
yeah zero knowledge for fiat mirror

878
00:30:41,840 --> 00:30:44,480
protocols is usually easily generically

879
00:30:44,480 --> 00:30:46,159
obtainable which is why we weren't

880
00:30:46,159 --> 00:30:49,279
focusing on it in the talk or

881
00:30:49,279 --> 00:30:50,880
for like the introduction of the paper

882
00:30:50,880 --> 00:30:53,279
but you can you can do it

883
00:30:53,279 --> 00:30:55,520
but you you don't mean that

884
00:30:55,520 --> 00:30:57,600
using these hash functions is zero

885
00:30:57,600 --> 00:30:59,919
knowledge you mean that some complete

886
00:30:59,919 --> 00:31:02,399
compilation applied to it you have a if

887
00:31:02,399 --> 00:31:04,399
you have a if you if you xor with the

888
00:31:04,399 --> 00:31:06,159
random mask you should get zero

889
00:31:06,159 --> 00:31:07,679
knowledge or something like that yeah so

890
00:31:07,679 --> 00:31:09,760
take one of the simple ones and then

891
00:31:09,760 --> 00:31:11,679
put in a key and the key is just xor the

892
00:31:11,679 --> 00:31:13,279
output with the with that that the

893
00:31:13,279 --> 00:31:14,880
random string is just the key of course

894
00:31:14,880 --> 00:31:16,559
you need some sort of program like some

895
00:31:16,559 --> 00:31:18,320
place to program for a zero knowledge

896
00:31:18,320 --> 00:31:20,240
simulator and these hash functions won't

897
00:31:20,240 --> 00:31:21,840
in our positive results won't have any

898
00:31:21,840 --> 00:31:24,000
place for that so you need to

899
00:31:24,000 --> 00:31:26,720
yeah add this mask for programmability

900
00:31:26,720 --> 00:31:28,480
okay do you have that in the in the

901
00:31:28,480 --> 00:31:30,480
paper examples yes

902
00:31:30,480 --> 00:31:32,799
yes okay great

903
00:31:32,799 --> 00:31:35,200
thank you

904
00:31:35,600 --> 00:31:38,480
okay cool any other questions yeah go

905
00:31:38,480 --> 00:31:39,279
ahead

906
00:31:39,279 --> 00:31:42,399
so so on an intuitive level um so you

907
00:31:42,399 --> 00:31:44,240
said you can prove security of let's

908
00:31:44,240 --> 00:31:46,159
snore signature or something like that

909
00:31:46,159 --> 00:31:48,399
in generic group model right if you i

910
00:31:48,399 --> 00:31:49,919
mean if you instantiate the hash

911
00:31:49,919 --> 00:31:51,600
functions as some kind of

912
00:31:51,600 --> 00:31:53,360
linear function in the generic group

913
00:31:53,360 --> 00:31:54,399
model

914
00:31:54,399 --> 00:31:55,919
assuming i understood it correctly

915
00:31:55,919 --> 00:31:57,919
what's your interpretation is this you

916
00:31:57,919 --> 00:31:59,039
know

917
00:31:59,039 --> 00:32:00,799
some things that uh

918
00:32:00,799 --> 00:32:04,559
for some groups you recommend to do uh

919
00:32:04,559 --> 00:32:05,519
yeah

920
00:32:05,519 --> 00:32:07,679
this is a really good question okay um

921
00:32:07,679 --> 00:32:08,480
so

922
00:32:08,480 --> 00:32:09,600
actually the

923
00:32:09,600 --> 00:32:11,679
we first proved a generic group results

924
00:32:11,679 --> 00:32:13,440
and i guess you can make it what you

925
00:32:13,440 --> 00:32:15,679
will uh and then we found that actually

926
00:32:15,679 --> 00:32:17,039
there are like fairly reasonable

927
00:32:17,039 --> 00:32:19,519
non-uniform attacks uh

928
00:32:19,519 --> 00:32:21,760
on on the resulting signatures

929
00:32:21,760 --> 00:32:22,640
um

930
00:32:22,640 --> 00:32:24,480
and then we found that not only are

931
00:32:24,480 --> 00:32:25,679
there non-uniform attacks these

932
00:32:25,679 --> 00:32:28,480
non-uniform attacks uh are efficient for

933
00:32:28,480 --> 00:32:31,440
like uh widely used groups like a zb

934
00:32:31,440 --> 00:32:34,159
star elliptic curve groups um so we

935
00:32:34,159 --> 00:32:36,799
actually found was that uh the way to to

936
00:32:36,799 --> 00:32:38,720
handle these sort of attacks was then to

937
00:32:38,720 --> 00:32:40,960
prove security in in the auxiliary input

938
00:32:40,960 --> 00:32:42,960
generic group model um and this we can

939
00:32:42,960 --> 00:32:44,960
have a little bit more confidence in uh

940
00:32:44,960 --> 00:32:46,799
and we actually do give a copy proposal

941
00:32:46,799 --> 00:32:49,360
of um like the simplest short signature

942
00:32:49,360 --> 00:32:51,919
that we do not know how to break uh i

943
00:32:51,919 --> 00:32:53,279
wouldn't say that we have like enormous

944
00:32:53,279 --> 00:32:54,880
confidence in it but it's just uh we

945
00:32:54,880 --> 00:32:57,440
wrote down a candidate in the paper a zp

946
00:32:57,440 --> 00:33:00,320
star based schnorr signature with a very

947
00:33:00,320 --> 00:33:02,399
simple theater hash function and we

948
00:33:02,399 --> 00:33:04,000
don't know how to attack it

949
00:33:04,000 --> 00:33:06,240
um so it might be just a nice place to

950
00:33:06,240 --> 00:33:08,080
start um start thinking about what these

951
00:33:08,080 --> 00:33:11,039
results actually say for concrete groups

952
00:33:11,039 --> 00:33:13,200
but on intuitive level yeah it's just

953
00:33:13,200 --> 00:33:15,519
it's not clear if uh

954
00:33:15,519 --> 00:33:16,720
i mean i understand you have to be

955
00:33:16,720 --> 00:33:18,320
careful about non-uniform attacks but

956
00:33:18,320 --> 00:33:19,519
it's not clear which one would you

957
00:33:19,519 --> 00:33:21,919
recommend overall like your scheme or

958
00:33:21,919 --> 00:33:23,600
standard one standard one i guess has

959
00:33:23,600 --> 00:33:25,760
more confidence my intuition as a proof

960
00:33:25,760 --> 00:33:28,000
must be more complicated right those ggm

961
00:33:28,000 --> 00:33:29,279
proofs are a little bit more complicated

962
00:33:29,279 --> 00:33:31,519
than the random oracle proofs to me i'm

963
00:33:31,519 --> 00:33:32,880
hoping that because the proof is more

964
00:33:32,880 --> 00:33:34,640
complicated maybe it tells you more

965
00:33:34,640 --> 00:33:36,480
about security but i'm not sure

966
00:33:36,480 --> 00:33:37,760
yeah i don't think i would go that far

967
00:33:37,760 --> 00:33:39,600
to say that um

968
00:33:39,600 --> 00:33:40,559
uh

969
00:33:40,559 --> 00:33:43,440
yeah as for what the intuition here is i

970
00:33:43,440 --> 00:33:45,440
guess like just i mean the more

971
00:33:45,440 --> 00:33:46,559
confidence you have in the hardness of

972
00:33:46,559 --> 00:33:48,159
your group so maybe you might have more

973
00:33:48,159 --> 00:33:49,600
confidence in certain elliptic curve

974
00:33:49,600 --> 00:33:51,679
groups than you might over zp

975
00:33:51,679 --> 00:33:54,159
um but beyond that i'm not sure what

976
00:33:54,159 --> 00:33:55,200
else

977
00:33:55,200 --> 00:33:57,360
yeah i think so for for me the main like

978
00:33:57,360 --> 00:33:59,760
takeaway from this from this class of

979
00:33:59,760 --> 00:34:02,159
positive results is that it's possible

980
00:34:02,159 --> 00:34:04,399
to argue the soundness of a fiatromir

981
00:34:04,399 --> 00:34:05,600
protocol

982
00:34:05,600 --> 00:34:08,239
by making use of hardness properties

983
00:34:08,239 --> 00:34:09,679
that are really

984
00:34:09,679 --> 00:34:12,719
just about like the interactive protocol

985
00:34:12,719 --> 00:34:14,320
rather than the hash function so in the

986
00:34:14,320 --> 00:34:16,320
case of like schnoor the interactive

987
00:34:16,320 --> 00:34:18,719
protocol is about this group and it

988
00:34:18,719 --> 00:34:20,399
turns out that you can use hardness

989
00:34:20,399 --> 00:34:22,960
properties of the group itself to argue

990
00:34:22,960 --> 00:34:24,639
the soundness of the of the theatro

991
00:34:24,639 --> 00:34:25,918
mirrored version

992
00:34:25,918 --> 00:34:26,719
uh

993
00:34:26,719 --> 00:34:28,719
and so it's it's it's just a the

994
00:34:28,719 --> 00:34:30,719
hardness is coming from a different

995
00:34:30,719 --> 00:34:33,359
place than in the the random oracle

996
00:34:33,359 --> 00:34:37,679
model uh fiat mirror protocols

997
00:34:38,079 --> 00:34:39,359
yeah one thing you can imagine for

998
00:34:39,359 --> 00:34:41,040
instance is like making a really really

999
00:34:41,040 --> 00:34:43,359
like close to optimally hard group using

1000
00:34:43,359 --> 00:34:46,079
io and crazy things

1001
00:34:46,079 --> 00:34:48,000
like using prfs to generate the labels

1002
00:34:48,000 --> 00:34:49,599
of your group and then using io to

1003
00:34:49,599 --> 00:34:51,440
handle the group operations and you

1004
00:34:51,440 --> 00:34:52,960
could hope that maybe this approximates

1005
00:34:52,960 --> 00:34:56,000
a generic group in some way uh and um i

1006
00:34:56,000 --> 00:34:57,839
guess we might expect that our

1007
00:34:57,839 --> 00:34:59,119
our uh

1008
00:34:59,119 --> 00:35:00,400
our positive results might more

1009
00:35:00,400 --> 00:35:02,320
faithfully capture reality for this kind

1010
00:35:02,320 --> 00:35:04,720
of super super hard group versus a more

1011
00:35:04,720 --> 00:35:07,279
natural group

1012
00:35:09,119 --> 00:35:10,960
thank you guys yeah nice very nice

1013
00:35:10,960 --> 00:35:13,359
result

1014
00:35:14,720 --> 00:35:17,440
okay let's thank fermi and alex for

1015
00:35:17,440 --> 00:35:19,359
taking all the questions

1016
00:35:19,359 --> 00:35:20,880
um

1017
00:35:20,880 --> 00:35:23,760
yeah we will take

