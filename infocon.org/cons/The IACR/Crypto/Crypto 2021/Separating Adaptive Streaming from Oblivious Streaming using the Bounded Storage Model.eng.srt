1
00:00:01,360 --> 00:00:03,679
hi i'm woosh temer and this is a joint

2
00:00:03,679 --> 00:00:05,680
work with heim kaplan is shy mansour and

3
00:00:05,680 --> 00:00:08,320
kobunissim about separating the adaptive

4
00:00:08,320 --> 00:00:10,000
streaming model from the oblivious

5
00:00:10,000 --> 00:00:12,480
streaming model

6
00:00:12,480 --> 00:00:14,960
so first i want to start by comparing

7
00:00:14,960 --> 00:00:17,119
the classical or oblivious streaming

8
00:00:17,119 --> 00:00:20,160
model to the adaptive or adversarial

9
00:00:20,160 --> 00:00:21,920
streaming model that we will be talking

10
00:00:21,920 --> 00:00:23,439
about today

11
00:00:23,439 --> 00:00:25,680
in both cases we will consider a

12
00:00:25,680 --> 00:00:28,320
streaming algorithm that continuously

13
00:00:28,320 --> 00:00:31,199
reports estimation for the value of the

14
00:00:31,199 --> 00:00:33,280
function that it is tracking

15
00:00:33,280 --> 00:00:35,360
for example maybe we want our streaming

16
00:00:35,360 --> 00:00:37,680
algorithm algorithm to track

17
00:00:37,680 --> 00:00:40,399
or estimate the current number of

18
00:00:40,399 --> 00:00:42,239
distinct elements

19
00:00:42,239 --> 00:00:44,480
that we have seen in the stream at any

20
00:00:44,480 --> 00:00:47,280
given point throughout the stream

21
00:00:47,280 --> 00:00:49,360
okay so let's start with the oblivious

22
00:00:49,360 --> 00:00:52,559
or classical streaming model

23
00:00:52,559 --> 00:00:54,640
so we have a streaming algorithm

24
00:00:54,640 --> 00:00:57,600
and we have an input stream we don't

25
00:00:57,600 --> 00:00:59,760
know this entire input stream of course

26
00:00:59,760 --> 00:01:01,680
but we assume that it is fixed in

27
00:01:01,680 --> 00:01:02,719
advanced

28
00:01:02,719 --> 00:01:05,360
again unknown to the algorithm

29
00:01:05,360 --> 00:01:08,000
now on every time step our algorithm

30
00:01:08,000 --> 00:01:11,280
gets the next element or update from the

31
00:01:11,280 --> 00:01:13,760
stream and the algorithm needs to

32
00:01:13,760 --> 00:01:16,320
respond with its current estimation for

33
00:01:16,320 --> 00:01:18,000
the value of the function that it is

34
00:01:18,000 --> 00:01:19,520
tracking

35
00:01:19,520 --> 00:01:21,840
then the algorithm gets the next update

36
00:01:21,840 --> 00:01:24,159
in the stream

37
00:01:24,159 --> 00:01:26,960
responds with its next estimation for

38
00:01:26,960 --> 00:01:28,640
the value of the function

39
00:01:28,640 --> 00:01:30,479
and so on

40
00:01:30,479 --> 00:01:32,720
okay so that's fine

41
00:01:32,720 --> 00:01:34,479
what happens

42
00:01:34,479 --> 00:01:37,759
on the other side of the screen

43
00:01:37,759 --> 00:01:40,159
we still have our streaming algorithm

44
00:01:40,159 --> 00:01:42,960
but now the input stream is not fixed in

45
00:01:42,960 --> 00:01:44,320
advanced

46
00:01:44,320 --> 00:01:47,439
instead what happens is that there is

47
00:01:47,439 --> 00:01:50,479
some adversary in the background that

48
00:01:50,479 --> 00:01:52,880
chooses the updates in the stream one by

49
00:01:52,880 --> 00:01:56,000
one as time goes by

50
00:01:56,000 --> 00:01:56,880
so

51
00:01:56,880 --> 00:01:59,520
in the beginning the adversary chooses

52
00:01:59,520 --> 00:02:01,520
the first update in the stream the

53
00:02:01,520 --> 00:02:04,079
streaming algorithm gets this update and

54
00:02:04,079 --> 00:02:06,079
responds with

55
00:02:06,079 --> 00:02:07,840
its current estimation for the value of

56
00:02:07,840 --> 00:02:09,119
the function

57
00:02:09,119 --> 00:02:12,160
the adversary gets to see this response

58
00:02:12,160 --> 00:02:14,319
given by the streaming algorithm and

59
00:02:14,319 --> 00:02:16,800
based on based on that response

60
00:02:16,800 --> 00:02:19,599
the adversary chooses the next update in

61
00:02:19,599 --> 00:02:21,120
the stream

62
00:02:21,120 --> 00:02:23,360
our streaming algorithm responds with

63
00:02:23,360 --> 00:02:25,360
its current estimation for the function

64
00:02:25,360 --> 00:02:28,160
the adversary gets that response based

65
00:02:28,160 --> 00:02:30,160
on that chooses the next update in the

66
00:02:30,160 --> 00:02:32,959
stream and so on

67
00:02:33,120 --> 00:02:36,239
and as you can guess the difficulty now

68
00:02:36,239 --> 00:02:37,760
is that

69
00:02:37,760 --> 00:02:40,319
the choice for the elements in the

70
00:02:40,319 --> 00:02:42,160
stream depends

71
00:02:42,160 --> 00:02:43,200
on

72
00:02:43,200 --> 00:02:45,760
the estimations that we give out and as

73
00:02:45,760 --> 00:02:47,280
a result

74
00:02:47,280 --> 00:02:49,920
the inputs in the stream depend on the

75
00:02:49,920 --> 00:02:52,080
internal randomness of our streaming

76
00:02:52,080 --> 00:02:55,840
algorithm and that's a problem

77
00:02:55,840 --> 00:02:58,720
okay so let's

78
00:02:58,720 --> 00:03:00,800
see the a little bit more formally the

79
00:03:00,800 --> 00:03:03,040
definition of that the serial or

80
00:03:03,040 --> 00:03:05,360
adaptive streaming model

81
00:03:05,360 --> 00:03:07,680
so as we said

82
00:03:07,680 --> 00:03:10,480
first in the beginning we fix some

83
00:03:10,480 --> 00:03:12,879
underlying function g that we are

84
00:03:12,879 --> 00:03:15,200
interested in tracking its value

85
00:03:15,200 --> 00:03:16,640
throughout the stream

86
00:03:16,640 --> 00:03:19,599
and in this work we focus on

87
00:03:19,599 --> 00:03:22,800
functions g that takes a prefix of the

88
00:03:22,800 --> 00:03:25,920
stream and evaluate to a real number we

89
00:03:25,920 --> 00:03:28,319
want to track this value throughout the

90
00:03:28,319 --> 00:03:30,959
stream or estimate it

91
00:03:30,959 --> 00:03:33,920
and we will also use the parameter alpha

92
00:03:33,920 --> 00:03:36,640
to denote our approximation parameter

93
00:03:36,640 --> 00:03:38,560
so on every time step we would like to

94
00:03:38,560 --> 00:03:41,200
obtain a value which is a one plus alpha

95
00:03:41,200 --> 00:03:43,440
multiplicative approximation for the

96
00:03:43,440 --> 00:03:45,120
true value of the function g at that

97
00:03:45,120 --> 00:03:46,799
moment

98
00:03:46,799 --> 00:03:49,360
and as an example for a function g maybe

99
00:03:49,360 --> 00:03:52,560
the function g that we're interested is

100
00:03:52,560 --> 00:03:54,480
we try we want to count the number of

101
00:03:54,480 --> 00:03:57,200
distinct elements while the string

102
00:03:57,200 --> 00:03:59,760
okay now we consider a two-player game

103
00:03:59,760 --> 00:04:02,480
between a randomized streaming algorithm

104
00:04:02,480 --> 00:04:04,720
and an adversary

105
00:04:04,720 --> 00:04:07,840
on every round the adversary chooses the

106
00:04:07,840 --> 00:04:10,400
next the next update in the stream and

107
00:04:10,400 --> 00:04:12,080
this choice

108
00:04:12,080 --> 00:04:14,720
can be based on all previous

109
00:04:14,720 --> 00:04:18,000
stream updates and all previous outputs

110
00:04:18,000 --> 00:04:21,199
given by our streaming algorithm

111
00:04:21,199 --> 00:04:23,919
the streaming algorithm takes this

112
00:04:23,919 --> 00:04:27,040
current input in the stream and responds

113
00:04:27,040 --> 00:04:29,040
with its current estimation for the

114
00:04:29,040 --> 00:04:31,440
value of the function

115
00:04:31,440 --> 00:04:34,160
the goal of the adversary is to make the

116
00:04:34,160 --> 00:04:36,720
streaming algorithm air

117
00:04:36,720 --> 00:04:38,960
on at least one time step throughout the

118
00:04:38,960 --> 00:04:41,040
game this means that the goal of the

119
00:04:41,040 --> 00:04:43,600
adversary is to make

120
00:04:43,600 --> 00:04:45,520
the streaming algorithm

121
00:04:45,520 --> 00:04:46,720
return

122
00:04:46,720 --> 00:04:49,520
an n cell which fails to be a one plus

123
00:04:49,520 --> 00:04:52,320
alpha approximation for the true current

124
00:04:52,320 --> 00:04:55,600
value of the function g

125
00:04:55,600 --> 00:04:57,360
okay so that's the definition of that

126
00:04:57,360 --> 00:04:59,440
versailles streaming mode

127
00:04:59,440 --> 00:05:01,039
and when you

128
00:05:01,039 --> 00:05:03,199
see this definition for the first time

129
00:05:03,199 --> 00:05:04,800
you might think

130
00:05:04,800 --> 00:05:06,960
well okay i see the differences between

131
00:05:06,960 --> 00:05:10,560
that and the classical oblivious setting

132
00:05:10,560 --> 00:05:12,080
you added this adversary in the

133
00:05:12,080 --> 00:05:13,680
background that chooses the updates in

134
00:05:13,680 --> 00:05:15,520
the stream

135
00:05:15,520 --> 00:05:18,160
but maybe nothing changed really and

136
00:05:18,160 --> 00:05:21,440
maybe existing algorithms

137
00:05:21,440 --> 00:05:23,520
for the classical setting maybe they

138
00:05:23,520 --> 00:05:25,440
still work also in the adversarial

139
00:05:25,440 --> 00:05:27,520
setting

140
00:05:27,520 --> 00:05:29,280
and if your streaming algorithm is

141
00:05:29,280 --> 00:05:32,479
deterministic then you would be correct

142
00:05:32,479 --> 00:05:35,120
it's easy to show that deterministic

143
00:05:35,120 --> 00:05:37,600
streaming algorithms if they work well

144
00:05:37,600 --> 00:05:40,240
in the classical setting then they also

145
00:05:40,240 --> 00:05:43,680
work well in the adversarial setting

146
00:05:43,680 --> 00:05:45,600
however the issue is that

147
00:05:45,600 --> 00:05:47,840
we know that for many problems of

148
00:05:47,840 --> 00:05:50,160
interest your streaming problem your

149
00:05:50,160 --> 00:05:52,720
streaming algorithm must probably be

150
00:05:52,720 --> 00:05:54,240
randomized

151
00:05:54,240 --> 00:05:56,080
and then when your streaming algorithm

152
00:05:56,080 --> 00:05:58,400
is randomized you need to be careful

153
00:05:58,400 --> 00:06:01,280
because as time goes by the adversary

154
00:06:01,280 --> 00:06:02,240
might

155
00:06:02,240 --> 00:06:04,240
learn properties of your

156
00:06:04,240 --> 00:06:07,039
internal randomness and then you can't

157
00:06:07,039 --> 00:06:09,280
really make valid statistical claims

158
00:06:09,280 --> 00:06:12,000
about it anymore and you run the risk of

159
00:06:12,000 --> 00:06:15,759
the adversary causing you to fail

160
00:06:15,840 --> 00:06:17,280
and

161
00:06:17,280 --> 00:06:19,680
as it happens many of the existing

162
00:06:19,680 --> 00:06:21,840
randomized streaming algorithms they are

163
00:06:21,840 --> 00:06:25,120
not adversarially robust

164
00:06:25,120 --> 00:06:27,360
so the takeaway from this slide is that

165
00:06:27,360 --> 00:06:30,319
we don't want the adversary to learn our

166
00:06:30,319 --> 00:06:33,800
internal randomness

167
00:06:34,479 --> 00:06:36,160
okay

168
00:06:36,160 --> 00:06:38,000
so now let's uh

169
00:06:38,000 --> 00:06:39,360
see

170
00:06:39,360 --> 00:06:42,319
um what are the existing results in this

171
00:06:42,319 --> 00:06:45,600
context and what are our new results

172
00:06:45,600 --> 00:06:48,240
so first

173
00:06:48,400 --> 00:06:50,639
several papers presented several

174
00:06:50,639 --> 00:06:53,039
interesting positive results

175
00:06:53,039 --> 00:06:55,039
uh they showed

176
00:06:55,039 --> 00:06:57,599
they presented transformations that take

177
00:06:57,599 --> 00:06:59,840
an oblivious streaming algorithm and are

178
00:06:59,840 --> 00:07:01,599
able to transform it into an

179
00:07:01,599 --> 00:07:04,560
adversarially robust streaming algorithm

180
00:07:04,560 --> 00:07:06,639
and this transformation

181
00:07:06,639 --> 00:07:09,680
encore only a small space overhead

182
00:07:09,680 --> 00:07:12,400
relative to the oblivious algorithm that

183
00:07:12,400 --> 00:07:14,960
we start with

184
00:07:14,960 --> 00:07:17,360
and now the question is okay what do i

185
00:07:17,360 --> 00:07:20,080
mean by small space overhead

186
00:07:20,080 --> 00:07:21,680
and the answer

187
00:07:21,680 --> 00:07:22,800
is

188
00:07:22,800 --> 00:07:24,160
quantified

189
00:07:24,160 --> 00:07:26,960
using a parameter that was introduced by

190
00:07:26,960 --> 00:07:30,160
beneliezer jram woodwolf and you gave

191
00:07:30,160 --> 00:07:31,840
they call it the flip number of the

192
00:07:31,840 --> 00:07:33,520
stream

193
00:07:33,520 --> 00:07:35,360
so the flip number of the stream we

194
00:07:35,360 --> 00:07:37,520
denote it as lambda

195
00:07:37,520 --> 00:07:40,240
is the maximum number of times

196
00:07:40,240 --> 00:07:43,280
that the value of the true function g

197
00:07:43,280 --> 00:07:45,440
can change

198
00:07:45,440 --> 00:07:48,479
by a more than a one plus alpha

199
00:07:48,479 --> 00:07:52,000
factor throughout the string

200
00:07:52,000 --> 00:07:52,960
so

201
00:07:52,960 --> 00:07:54,960
let's think about an example maybe the

202
00:07:54,960 --> 00:07:57,039
function g that we are

203
00:07:57,039 --> 00:07:59,039
interested in counts the number of

204
00:07:59,039 --> 00:08:01,440
distinct elements and let's suppose that

205
00:08:01,440 --> 00:08:04,240
there are no deletions in the stream

206
00:08:04,240 --> 00:08:05,599
so if there are no deletions in the

207
00:08:05,599 --> 00:08:08,560
stream the number of distinct elements

208
00:08:08,560 --> 00:08:10,960
it's a monotonically increasing function

209
00:08:10,960 --> 00:08:13,919
and how many times throughout the stream

210
00:08:13,919 --> 00:08:15,919
of length m

211
00:08:15,919 --> 00:08:17,919
it can jump up this number how many

212
00:08:17,919 --> 00:08:19,680
times can this number jump up by a

213
00:08:19,680 --> 00:08:22,720
multiplicative factor of one plus alpha

214
00:08:22,720 --> 00:08:25,280
at most one over alpha

215
00:08:25,280 --> 00:08:26,560
times log

216
00:08:26,560 --> 00:08:29,440
the length of the string

217
00:08:29,440 --> 00:08:30,319
so

218
00:08:30,319 --> 00:08:32,000
in the insertion only model when there

219
00:08:32,000 --> 00:08:35,120
are no deletions the flip number of

220
00:08:35,120 --> 00:08:37,120
the function g that counts the number of

221
00:08:37,120 --> 00:08:39,200
distinct elements

222
00:08:39,200 --> 00:08:41,679
the flip number is small

223
00:08:41,679 --> 00:08:44,000
and that's good because

224
00:08:44,000 --> 00:08:46,560
all of the existing transformations from

225
00:08:46,560 --> 00:08:48,320
an oblivious streaming algorithm into an

226
00:08:48,320 --> 00:08:50,640
adversarially robust streaming algorithm

227
00:08:50,640 --> 00:08:51,920
they call

228
00:08:51,920 --> 00:08:55,519
space blow up that depends on the flip

229
00:08:55,519 --> 00:08:59,120
number so we have ideal

230
00:08:59,680 --> 00:09:01,519
blow up linear in lambda by

231
00:09:01,519 --> 00:09:04,560
benelizarital or root lambda by

232
00:09:04,560 --> 00:09:06,880
hasidimetal or

233
00:09:06,880 --> 00:09:09,839
alpha times lambda where alpha is the

234
00:09:09,839 --> 00:09:12,399
approximation parameter of the classical

235
00:09:12,399 --> 00:09:13,920
algorithm a

236
00:09:13,920 --> 00:09:15,920
by wood roof and

237
00:09:15,920 --> 00:09:16,880
zoo

238
00:09:16,880 --> 00:09:23,160
or we have root alpha lambda by a center

239
00:09:23,360 --> 00:09:26,800
okay so the existing transformations

240
00:09:26,800 --> 00:09:29,279
if lambda is small they produce an

241
00:09:29,279 --> 00:09:31,040
adversarially robust

242
00:09:31,040 --> 00:09:34,399
algorithm with small space complexity

243
00:09:34,399 --> 00:09:37,760
but what happens when lambda is large

244
00:09:37,760 --> 00:09:39,839
so let's see the negative results

245
00:09:39,839 --> 00:09:43,760
first in 2013 hart and woodruff

246
00:09:43,760 --> 00:09:46,080
showed informally

247
00:09:46,080 --> 00:09:48,800
negative results for

248
00:09:48,800 --> 00:09:51,440
lineal streaming algorithms for many

249
00:09:51,440 --> 00:09:53,760
problems of interest

250
00:09:53,760 --> 00:09:54,800
so

251
00:09:54,800 --> 00:09:56,640
as a negative result

252
00:09:56,640 --> 00:09:58,720
that's great

253
00:09:58,720 --> 00:10:01,040
but the negative result

254
00:10:01,040 --> 00:10:02,640
only holds

255
00:10:02,640 --> 00:10:04,880
for linear algorithms

256
00:10:04,880 --> 00:10:07,360
so like before our new result

257
00:10:07,360 --> 00:10:09,600
it was kind of open that

258
00:10:09,600 --> 00:10:10,959
maybe

259
00:10:10,959 --> 00:10:12,720
everything you can do in the classical

260
00:10:12,720 --> 00:10:13,760
setting

261
00:10:13,760 --> 00:10:15,360
you can also do

262
00:10:15,360 --> 00:10:16,399
in the

263
00:10:16,399 --> 00:10:18,959
adversarial setting but

264
00:10:18,959 --> 00:10:22,959
maybe just not using linear algorithms

265
00:10:22,959 --> 00:10:25,680
we show the first separation

266
00:10:25,680 --> 00:10:28,720
for between the adversarial setting and

267
00:10:28,720 --> 00:10:30,480
the oblivious setting

268
00:10:30,480 --> 00:10:33,279
specifically we present

269
00:10:33,279 --> 00:10:35,440
a streaming problem such that if you

270
00:10:35,440 --> 00:10:37,200
want to solve this streaming problem in

271
00:10:37,200 --> 00:10:39,519
the classical oblivious setting you can

272
00:10:39,519 --> 00:10:42,399
do it very cheaply using only

273
00:10:42,399 --> 00:10:45,600
a poly logarithmic space

274
00:10:45,600 --> 00:10:48,320
but if you want to solve this problem

275
00:10:48,320 --> 00:10:50,880
in that versailles setting

276
00:10:50,880 --> 00:10:53,920
you must probably use large polynomial

277
00:10:53,920 --> 00:10:55,440
space

278
00:10:55,440 --> 00:10:56,480
even

279
00:10:56,480 --> 00:10:58,320
if you're trying to use a non-linear

280
00:10:58,320 --> 00:10:59,519
algorithm

281
00:10:59,519 --> 00:11:02,880
so that's an exponential separation

282
00:11:02,880 --> 00:11:05,040
and

283
00:11:05,040 --> 00:11:06,720
in addition

284
00:11:06,720 --> 00:11:08,720
so i don't know if the flip number

285
00:11:08,720 --> 00:11:12,240
lambda is the correct parameter

286
00:11:12,240 --> 00:11:13,440
to look at

287
00:11:13,440 --> 00:11:16,000
but our result says that

288
00:11:16,000 --> 00:11:18,000
if you decided to use the flip number

289
00:11:18,000 --> 00:11:20,800
lambda as the parameter that controls

290
00:11:20,800 --> 00:11:22,240
the

291
00:11:22,240 --> 00:11:24,480
the blow-up of your uh algorithm the

292
00:11:24,480 --> 00:11:26,800
space blow-up of your algorithm

293
00:11:26,800 --> 00:11:29,839
then in general root lambda is the basic

294
00:11:29,839 --> 00:11:31,600
the best you can get because we have

295
00:11:31,600 --> 00:11:34,079
transformations that keep the blow up at

296
00:11:34,079 --> 00:11:35,920
most with lambda

297
00:11:35,920 --> 00:11:38,720
and in general a blow up of size root

298
00:11:38,720 --> 00:11:42,320
lambda is necessary

299
00:11:42,320 --> 00:11:45,680
okay so that's our result

300
00:11:45,680 --> 00:11:47,600
how do we get it

301
00:11:47,600 --> 00:11:48,959
we get it

302
00:11:48,959 --> 00:11:50,959
by

303
00:11:50,959 --> 00:11:53,600
formalizing a connection between

304
00:11:53,600 --> 00:11:56,399
the adversarial streaming model to the

305
00:11:56,399 --> 00:11:59,120
recent line of works on adaptive data

306
00:11:59,120 --> 00:12:00,240
analysis

307
00:12:00,240 --> 00:12:01,760
so before i'll tell you

308
00:12:01,760 --> 00:12:04,320
how do we get our results

309
00:12:04,320 --> 00:12:05,200
let's

310
00:12:05,200 --> 00:12:08,079
first recall what adaptive data analysis

311
00:12:08,079 --> 00:12:11,399
is all about

312
00:12:12,160 --> 00:12:14,560
and in order to remember what adaptive

313
00:12:14,560 --> 00:12:16,880
data analysis is all about let's start

314
00:12:16,880 --> 00:12:18,639
with the following

315
00:12:18,639 --> 00:12:21,519
warm-up let's call this warm-up simple

316
00:12:21,519 --> 00:12:24,079
problem number one so it's a very simple

317
00:12:24,079 --> 00:12:26,240
problem i'm sure we all know the

318
00:12:26,240 --> 00:12:28,480
answer to that problem

319
00:12:28,480 --> 00:12:30,720
we have an unknown underlying

320
00:12:30,720 --> 00:12:33,839
distribution d over a domain x

321
00:12:33,839 --> 00:12:36,880
and we also have a fixed

322
00:12:36,880 --> 00:12:39,680
known predicate mapping elements from

323
00:12:39,680 --> 00:12:43,040
the domain x to either 01 and we have

324
00:12:43,040 --> 00:12:45,680
some desired approximation parameter

325
00:12:45,680 --> 00:12:47,279
alpha

326
00:12:47,279 --> 00:12:51,920
our input is a sample s containing n iid

327
00:12:51,920 --> 00:12:54,160
samples from the underlying unknown

328
00:12:54,160 --> 00:12:56,240
distribution d

329
00:12:56,240 --> 00:12:58,000
our goal

330
00:12:58,000 --> 00:13:00,959
is to use this input sample in order to

331
00:13:00,959 --> 00:13:02,240
estimate

332
00:13:02,240 --> 00:13:04,720
the expected value of the given

333
00:13:04,720 --> 00:13:08,480
predicate h over the underlying unknown

334
00:13:08,480 --> 00:13:10,240
distribution d

335
00:13:10,240 --> 00:13:11,920
and the question is

336
00:13:11,920 --> 00:13:14,560
how should we compute our estimation

337
00:13:14,560 --> 00:13:16,800
and also

338
00:13:16,800 --> 00:13:18,079
what

339
00:13:18,079 --> 00:13:19,519
should n be

340
00:13:19,519 --> 00:13:22,000
how big should this input sample be in

341
00:13:22,000 --> 00:13:24,480
order for us to be able to guarantee

342
00:13:24,480 --> 00:13:27,760
small error with high probability

343
00:13:27,760 --> 00:13:29,360
okay so that's an easy question we all

344
00:13:29,360 --> 00:13:31,360
know the answer to that

345
00:13:31,360 --> 00:13:35,120
we just compute our estimation uh using

346
00:13:35,120 --> 00:13:35,920
the

347
00:13:35,920 --> 00:13:38,959
empirical average of the given predicate

348
00:13:38,959 --> 00:13:39,680
h

349
00:13:39,680 --> 00:13:42,320
over the given input sample and by the

350
00:13:42,320 --> 00:13:44,160
hovering bound

351
00:13:44,160 --> 00:13:45,519
as long as n

352
00:13:45,519 --> 00:13:47,680
the size of s is roughly 1 over alpha

353
00:13:47,680 --> 00:13:48,880
squared

354
00:13:48,880 --> 00:13:51,680
we should be fine

355
00:13:51,920 --> 00:13:54,160
okay so that's easy

356
00:13:54,160 --> 00:13:56,000
here is a little tweak to that problem

357
00:13:56,000 --> 00:13:57,839
nothing changes really

358
00:13:57,839 --> 00:13:59,519
let's call this problem simple problem

359
00:13:59,519 --> 00:14:01,839
number two

360
00:14:01,839 --> 00:14:03,920
we still have uh

361
00:14:03,920 --> 00:14:05,279
so everything is the same we have the

362
00:14:05,279 --> 00:14:08,160
underlying unknown distribution d

363
00:14:08,160 --> 00:14:11,680
uh we our input is a sample s containing

364
00:14:11,680 --> 00:14:14,480
n iid elements from this

365
00:14:14,480 --> 00:14:16,560
underlying unknown distribution d the

366
00:14:16,560 --> 00:14:18,480
only difference is that now instead of

367
00:14:18,480 --> 00:14:22,079
having only one predicate h we have k

368
00:14:22,079 --> 00:14:23,920
different predicates all fixed in

369
00:14:23,920 --> 00:14:25,760
advance all given to us all known a

370
00:14:25,760 --> 00:14:28,240
priori

371
00:14:28,240 --> 00:14:31,279
okay now we want to use our input sample

372
00:14:31,279 --> 00:14:33,920
s in order to approximate the expected

373
00:14:33,920 --> 00:14:36,240
value of each of these

374
00:14:36,240 --> 00:14:39,120
k predicates over the unknown underlying

375
00:14:39,120 --> 00:14:41,279
distribution d

376
00:14:41,279 --> 00:14:42,639
what should we do

377
00:14:42,639 --> 00:14:46,000
we should do exactly the same as before

378
00:14:46,000 --> 00:14:48,000
we estimate the empirical average of

379
00:14:48,000 --> 00:14:50,560
each we estimate the expected value of

380
00:14:50,560 --> 00:14:53,199
each of these predicates using its exact

381
00:14:53,199 --> 00:14:56,079
empirical average on the given sample s

382
00:14:56,079 --> 00:14:58,399
and still by the having bound maybe with

383
00:14:58,399 --> 00:15:00,160
the union bound

384
00:15:00,160 --> 00:15:02,160
as long as the size of our input sample

385
00:15:02,160 --> 00:15:05,600
is roughly one over alpha squared times

386
00:15:05,600 --> 00:15:07,519
logic log k

387
00:15:07,519 --> 00:15:10,320
we should be happy

388
00:15:10,480 --> 00:15:12,720
so okay that's easy

389
00:15:12,720 --> 00:15:14,000
but

390
00:15:14,000 --> 00:15:17,199
an important uh assumption we made here

391
00:15:17,199 --> 00:15:19,279
when we applied the hufting bound is

392
00:15:19,279 --> 00:15:21,519
that all of these k predicates were

393
00:15:21,519 --> 00:15:23,199
fixed in advance

394
00:15:23,199 --> 00:15:24,959
in particular in order to apply the

395
00:15:24,959 --> 00:15:26,560
holding bound

396
00:15:26,560 --> 00:15:28,639
we need

397
00:15:28,639 --> 00:15:31,519
the sample s to be independent of the

398
00:15:31,519 --> 00:15:33,839
choice of these

399
00:15:33,839 --> 00:15:36,639
k predicates

400
00:15:36,959 --> 00:15:38,240
okay

401
00:15:38,240 --> 00:15:41,440
so now here is the basic formulation

402
00:15:41,440 --> 00:15:44,639
of the problem that is considered in the

403
00:15:44,639 --> 00:15:47,279
line of work on adaptive data analysis

404
00:15:47,279 --> 00:15:51,279
let's call this problem the ada problem

405
00:15:51,279 --> 00:15:53,680
and what changes now is that the k

406
00:15:53,680 --> 00:15:56,320
predicates are not fixed in advance

407
00:15:56,320 --> 00:15:59,519
instead they are given to us one by one

408
00:15:59,519 --> 00:16:02,079
so we still have the underlying unknown

409
00:16:02,079 --> 00:16:03,600
distribution d

410
00:16:03,600 --> 00:16:05,759
our input is still a sample as

411
00:16:05,759 --> 00:16:08,000
containing n id elements from this

412
00:16:08,000 --> 00:16:10,560
underlying unknown distribution d

413
00:16:10,560 --> 00:16:11,920
but now

414
00:16:11,920 --> 00:16:13,920
we don't have the k predicates in

415
00:16:13,920 --> 00:16:16,240
advance instead

416
00:16:16,240 --> 00:16:19,519
4k rounds on every round we get the next

417
00:16:19,519 --> 00:16:21,839
predicate and we need to respond with

418
00:16:21,839 --> 00:16:24,800
the current approximation

419
00:16:24,800 --> 00:16:25,920
a i

420
00:16:25,920 --> 00:16:26,639
to

421
00:16:26,639 --> 00:16:28,480
the expected value of that given

422
00:16:28,480 --> 00:16:30,959
predicate over the unknown underlying

423
00:16:30,959 --> 00:16:33,279
distribution

424
00:16:33,279 --> 00:16:34,800
and as you can guess

425
00:16:34,800 --> 00:16:36,399
the difficulty now

426
00:16:36,399 --> 00:16:38,399
is that

427
00:16:38,399 --> 00:16:42,320
the choice of the predicates may depend

428
00:16:42,320 --> 00:16:43,440
on

429
00:16:43,440 --> 00:16:45,839
the previous answers that we gave out

430
00:16:45,839 --> 00:16:47,600
and as a result

431
00:16:47,600 --> 00:16:50,639
the choice of the predicates may depend

432
00:16:50,639 --> 00:16:52,880
on the sample s

433
00:16:52,880 --> 00:16:54,959
which would break our previous analysis

434
00:16:54,959 --> 00:16:57,439
completely

435
00:16:57,920 --> 00:16:59,920
okay i'm going to say exactly the same

436
00:16:59,920 --> 00:17:02,240
thing but with a picture

437
00:17:02,240 --> 00:17:05,439
so in the adaptive data analysis problem

438
00:17:05,439 --> 00:17:07,760
we want to design a mechanism m

439
00:17:07,760 --> 00:17:10,079
that in the beginning of the game gets a

440
00:17:10,079 --> 00:17:13,520
sample s containing n iid elements from

441
00:17:13,520 --> 00:17:16,400
some underlying unknown distribution d

442
00:17:16,400 --> 00:17:17,199
now

443
00:17:17,199 --> 00:17:19,760
for k lounge

444
00:17:19,760 --> 00:17:23,599
we get a predicate mapping the domain x

445
00:17:23,599 --> 00:17:25,520
to 0 1

446
00:17:25,520 --> 00:17:27,359
and we respond with our current

447
00:17:27,359 --> 00:17:29,039
estimation

448
00:17:29,039 --> 00:17:31,679
for the expected value of that predicate

449
00:17:31,679 --> 00:17:35,600
over the underlying unknown distribution

450
00:17:35,600 --> 00:17:37,280
then we get the next credit card we

451
00:17:37,280 --> 00:17:40,799
respond with our next approximation

452
00:17:40,799 --> 00:17:43,360
and so on

453
00:17:43,840 --> 00:17:45,200
and our goal

454
00:17:45,200 --> 00:17:47,440
when we design the mechanism m is to

455
00:17:47,440 --> 00:17:49,760
ensure that all of its answers are

456
00:17:49,760 --> 00:17:52,320
accurate with respect to the

457
00:17:52,320 --> 00:17:54,480
to the expected value of the given

458
00:17:54,480 --> 00:17:57,200
predicates over the unknown underlying

459
00:17:57,200 --> 00:17:58,799
distribution

460
00:17:58,799 --> 00:18:01,039
and the basic question in the ada

461
00:18:01,039 --> 00:18:02,559
literature

462
00:18:02,559 --> 00:18:05,039
is what should n be what should the size

463
00:18:05,039 --> 00:18:07,679
of the initial input sample be in order

464
00:18:07,679 --> 00:18:10,240
for us to be able to guarantee

465
00:18:10,240 --> 00:18:11,600
all of these good things with high

466
00:18:11,600 --> 00:18:14,000
probability

467
00:18:14,000 --> 00:18:15,840
and when you first see this problem for

468
00:18:15,840 --> 00:18:18,720
the first time you might think

469
00:18:18,720 --> 00:18:22,799
okay i understood why the analysis of

470
00:18:22,799 --> 00:18:24,960
basic problem number two why the

471
00:18:24,960 --> 00:18:26,559
analysis breaks

472
00:18:26,559 --> 00:18:28,880
when we apply the holding bound that i

473
00:18:28,880 --> 00:18:30,720
understand but maybe it's just the

474
00:18:30,720 --> 00:18:32,240
analysis that breaks

475
00:18:32,240 --> 00:18:34,240
maybe

476
00:18:34,240 --> 00:18:35,919
answering with the exact empirical

477
00:18:35,919 --> 00:18:38,640
average maybe that's still a good idea

478
00:18:38,640 --> 00:18:40,240
but if you think about it for a little

479
00:18:40,240 --> 00:18:42,080
while you will see that the answer is no

480
00:18:42,080 --> 00:18:43,120
that's

481
00:18:43,120 --> 00:18:44,960
in the adaptive setting that's a bad

482
00:18:44,960 --> 00:18:47,919
idea that can fail already in the second

483
00:18:47,919 --> 00:18:50,240
round

484
00:18:50,320 --> 00:18:51,360
okay

485
00:18:51,360 --> 00:18:54,400
but no worries we can do other stuff

486
00:18:54,400 --> 00:18:56,720
and here is a summary of the current

487
00:18:56,720 --> 00:18:59,440
known upper and lower bounds on the

488
00:18:59,440 --> 00:19:02,160
basic ada problem

489
00:19:02,160 --> 00:19:03,600
so first we

490
00:19:03,600 --> 00:19:04,559
know

491
00:19:04,559 --> 00:19:06,559
how to construct a computationally

492
00:19:06,559 --> 00:19:09,520
efficient mechanism that answers k

493
00:19:09,520 --> 00:19:12,559
adaptively chosen queries using a sample

494
00:19:12,559 --> 00:19:13,840
of size

495
00:19:13,840 --> 00:19:16,160
root k

496
00:19:16,160 --> 00:19:18,320
in addition we know

497
00:19:18,320 --> 00:19:19,360
that

498
00:19:19,360 --> 00:19:21,600
if you are interested in computationally

499
00:19:21,600 --> 00:19:23,520
efficient mechanisms

500
00:19:23,520 --> 00:19:25,760
then root k

501
00:19:25,760 --> 00:19:28,000
is what you get

502
00:19:28,000 --> 00:19:29,600
in other words

503
00:19:29,600 --> 00:19:31,600
assuming one way functions

504
00:19:31,600 --> 00:19:33,120
every computationally efficient

505
00:19:33,120 --> 00:19:34,640
mechanism

506
00:19:34,640 --> 00:19:36,720
for answering k adaptively chosen

507
00:19:36,720 --> 00:19:37,679
queries

508
00:19:37,679 --> 00:19:40,480
must use an initial sample of size at

509
00:19:40,480 --> 00:19:43,600
least root k

510
00:19:43,840 --> 00:19:46,320
but we also know that if you are okay

511
00:19:46,320 --> 00:19:48,080
with computationally inefficient

512
00:19:48,080 --> 00:19:50,480
mechanisms then you can do much much

513
00:19:50,480 --> 00:19:54,000
more suddenly the number of queries k

514
00:19:54,000 --> 00:19:56,960
you can answer can be exponential

515
00:19:56,960 --> 00:20:00,080
in the size of the input sample

516
00:20:00,080 --> 00:20:03,280
can be exponential in n

517
00:20:04,080 --> 00:20:06,080
okay so these are the current upper and

518
00:20:06,080 --> 00:20:07,280
lower bounds

519
00:20:07,280 --> 00:20:10,000
what's the connection between that and

520
00:20:10,000 --> 00:20:13,200
adversarial streaming

521
00:20:13,280 --> 00:20:14,559
so we show

522
00:20:14,559 --> 00:20:17,600
a reduction from the ada problem that we

523
00:20:17,600 --> 00:20:18,880
just mentioned

524
00:20:18,880 --> 00:20:19,600
to

525
00:20:19,600 --> 00:20:21,600
adversarial streaming and more

526
00:20:21,600 --> 00:20:23,919
specifically we design a specific

527
00:20:23,919 --> 00:20:25,360
streaming problem

528
00:20:25,360 --> 00:20:26,799
such that if you could solve this

529
00:20:26,799 --> 00:20:29,200
problem in the adversarial streaming

530
00:20:29,200 --> 00:20:31,760
model then you could take such an

531
00:20:31,760 --> 00:20:33,760
algorithm that solves this problem

532
00:20:33,760 --> 00:20:35,840
and use it in order to construct an

533
00:20:35,840 --> 00:20:38,240
algorithm that solves the ada problem

534
00:20:38,240 --> 00:20:40,400
with related parameters

535
00:20:40,400 --> 00:20:44,640
and once you have that then you can

536
00:20:44,640 --> 00:20:45,679
apply

537
00:20:45,679 --> 00:20:48,240
the negative results we mentioned for

538
00:20:48,240 --> 00:20:50,400
the ada problem to obtain negative

539
00:20:50,400 --> 00:20:54,159
results for adversarial stream

540
00:20:54,559 --> 00:20:56,720
and

541
00:20:56,720 --> 00:20:59,280
the streaming problem we present we call

542
00:20:59,280 --> 00:21:01,520
it the streaming adaptive data analysis

543
00:21:01,520 --> 00:21:04,559
problem or sata in short

544
00:21:04,559 --> 00:21:07,678
is defined as follows

545
00:21:07,919 --> 00:21:11,200
every update in the stream

546
00:21:11,360 --> 00:21:13,120
has one of two types

547
00:21:13,120 --> 00:21:16,640
either the ith update is a data point

548
00:21:16,640 --> 00:21:17,840
let's call it

549
00:21:17,840 --> 00:21:21,039
data point p i from the domain x

550
00:21:21,039 --> 00:21:23,919
or it is a function h i

551
00:21:23,919 --> 00:21:26,640
mapping elements from the domain x to

552
00:21:26,640 --> 00:21:28,799
either zero or one

553
00:21:28,799 --> 00:21:31,120
okay these are the updates in the stream

554
00:21:31,120 --> 00:21:32,240
what do we

555
00:21:32,240 --> 00:21:34,000
want to estimate

556
00:21:34,000 --> 00:21:36,960
our goal is on every time step i

557
00:21:36,960 --> 00:21:39,520
after obtaining the next update in the

558
00:21:39,520 --> 00:21:40,559
stream

559
00:21:40,559 --> 00:21:42,960
we want to approximate the average of

560
00:21:42,960 --> 00:21:45,919
the last given function in the stream

561
00:21:45,919 --> 00:21:48,559
over the multiset containing all of the

562
00:21:48,559 --> 00:21:50,960
data points that were given to us

563
00:21:50,960 --> 00:21:53,120
throughout the stream

564
00:21:53,120 --> 00:21:56,320
that's this other problem

565
00:21:56,400 --> 00:21:58,480
and intuitively why should that be a

566
00:21:58,480 --> 00:22:00,559
good problem to look at

567
00:22:00,559 --> 00:22:03,200
because first let's agree that in the

568
00:22:03,200 --> 00:22:06,080
classical oblivious setting we can solve

569
00:22:06,080 --> 00:22:08,320
this problem very cheaply

570
00:22:08,320 --> 00:22:10,720
in terms of memory because we don't need

571
00:22:10,720 --> 00:22:13,760
to store all of the potentially many

572
00:22:13,760 --> 00:22:16,240
many many data points that were given to

573
00:22:16,240 --> 00:22:18,400
us throughout the stream because we can

574
00:22:18,400 --> 00:22:19,840
use sampling

575
00:22:19,840 --> 00:22:21,360
we can just maintain a small

576
00:22:21,360 --> 00:22:23,440
representative sample

577
00:22:23,440 --> 00:22:24,880
out of all of these data points that

578
00:22:24,880 --> 00:22:27,679
were given to us throughout the stream

579
00:22:27,679 --> 00:22:30,480
and now whenever you give me

580
00:22:30,480 --> 00:22:33,520
a function i evaluate this function not

581
00:22:33,520 --> 00:22:35,600
over uh the

582
00:22:35,600 --> 00:22:38,720
many uh data points that were given

583
00:22:38,720 --> 00:22:41,360
throughout the stream i evaluate it only

584
00:22:41,360 --> 00:22:43,360
over the small representative sample

585
00:22:43,360 --> 00:22:45,440
that i'm maintaining and that's cheap

586
00:22:45,440 --> 00:22:48,240
memory wise

587
00:22:48,720 --> 00:22:51,600
on the other hand

588
00:22:51,679 --> 00:22:54,000
in the adversarial setting we don't have

589
00:22:54,000 --> 00:22:57,120
this trick of sampling

590
00:22:57,120 --> 00:22:58,960
in the adversarial setting if you want

591
00:22:58,960 --> 00:23:01,039
to answer many many

592
00:23:01,039 --> 00:23:03,440
adaptively chosen queries

593
00:23:03,440 --> 00:23:05,760
by the by the lower bounds for the ada

594
00:23:05,760 --> 00:23:07,840
problem if you want to answer many many

595
00:23:07,840 --> 00:23:09,919
adaptive queries your sample must be

596
00:23:09,919 --> 00:23:11,280
large

597
00:23:11,280 --> 00:23:13,840
your sample is large intuitively your

598
00:23:13,840 --> 00:23:15,280
memory is large

599
00:23:15,280 --> 00:23:18,320
you're not doing very well

600
00:23:18,400 --> 00:23:20,159
so that's the intuition

601
00:23:20,159 --> 00:23:23,760
and i just want to mention um that

602
00:23:23,760 --> 00:23:25,120
if you recall

603
00:23:25,120 --> 00:23:27,200
the negative results

604
00:23:27,200 --> 00:23:28,880
for the ada problem they were

605
00:23:28,880 --> 00:23:30,480
computational they assumed one-way

606
00:23:30,480 --> 00:23:32,480
functions

607
00:23:32,480 --> 00:23:33,919
while we are

608
00:23:33,919 --> 00:23:35,919
aiming for an information theoretic

609
00:23:35,919 --> 00:23:38,000
separation which means that we cannot

610
00:23:38,000 --> 00:23:40,400
plug and play the negative results for

611
00:23:40,400 --> 00:23:42,799
the ada problem as is we need to open

612
00:23:42,799 --> 00:23:45,360
them up and modify them

613
00:23:45,360 --> 00:23:47,279
and that we do using

614
00:23:47,279 --> 00:23:49,040
the bounded storage model

615
00:23:49,040 --> 00:23:51,279
[Music]

616
00:23:51,279 --> 00:23:52,720
using cryptographic tools from the

617
00:23:52,720 --> 00:23:55,679
bounded storage model

618
00:23:56,000 --> 00:23:58,000
okay

619
00:23:58,000 --> 00:23:59,919
so to summarize

620
00:23:59,919 --> 00:24:01,200
we establish

621
00:24:01,200 --> 00:24:03,360
a connection between

622
00:24:03,360 --> 00:24:05,360
adversarial streaming and adaptive data

623
00:24:05,360 --> 00:24:06,640
analysis

624
00:24:06,640 --> 00:24:09,600
use this connection in order to present

625
00:24:09,600 --> 00:24:11,760
a streaming problem that

626
00:24:11,760 --> 00:24:14,320
separates the adversarial setting from

627
00:24:14,320 --> 00:24:16,320
the classical setting and this is the

628
00:24:16,320 --> 00:24:19,279
first general separation between the

629
00:24:19,279 --> 00:24:22,000
capabilities of these two models

630
00:24:22,000 --> 00:24:25,360
and that's it thanks for

631
00:24:30,840 --> 00:24:34,000
listening you

