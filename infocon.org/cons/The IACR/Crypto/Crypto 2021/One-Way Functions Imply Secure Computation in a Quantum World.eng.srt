1
00:00:01,920 --> 00:00:03,679
okay i'll be discussing one-way

2
00:00:03,679 --> 00:00:05,680
functions imply secure computation in a

3
00:00:05,680 --> 00:00:07,520
quantum world uh which is joint work

4
00:00:07,520 --> 00:00:10,240
with andrea dakshita and for me

5
00:00:10,240 --> 00:00:12,000
okay so this talk is about secure

6
00:00:12,000 --> 00:00:14,160
multi-party computation uh which i will

7
00:00:14,160 --> 00:00:16,560
now define

8
00:00:16,560 --> 00:00:18,720
we consider multiple parties each with a

9
00:00:18,720 --> 00:00:20,960
private input x i uh that wish to

10
00:00:20,960 --> 00:00:22,720
compute some public circuit c over their

11
00:00:22,720 --> 00:00:25,039
private inputs okay so they'll do this

12
00:00:25,039 --> 00:00:26,720
by communicating and eventually all

13
00:00:26,720 --> 00:00:29,359
learning the output and for security we

14
00:00:29,359 --> 00:00:30,400
want to

15
00:00:30,400 --> 00:00:31,920
ensure that an adversary that corrupts

16
00:00:31,920 --> 00:00:33,840
any subset of these parties so here

17
00:00:33,840 --> 00:00:36,239
parties 2 and 3 won't learn anything

18
00:00:36,239 --> 00:00:38,480
about the honest party inputs x1 x4

19
00:00:38,480 --> 00:00:40,079
except for what it learns from the

20
00:00:40,079 --> 00:00:42,000
output of the functionality okay and

21
00:00:42,000 --> 00:00:42,960
this is a

22
00:00:42,960 --> 00:00:45,520
um a classic problem in crypto going

23
00:00:45,520 --> 00:00:48,879
back to uh dating back to the 80s okay

24
00:00:48,879 --> 00:00:50,399
so yeah to give a little bit of

25
00:00:50,399 --> 00:00:52,640
background on on what's known about npc

26
00:00:52,640 --> 00:00:54,399
in a classical world in which you know

27
00:00:54,399 --> 00:00:55,520
all parties are classical

28
00:00:55,520 --> 00:00:57,440
functionalities are classical

29
00:00:57,440 --> 00:00:58,960
we'll really have to look at the simple

30
00:00:58,960 --> 00:01:00,480
primitive of ot

31
00:01:00,480 --> 00:01:02,559
right which is

32
00:01:02,559 --> 00:01:05,119
a two-party functionality between center

33
00:01:05,119 --> 00:01:07,200
and receiver

34
00:01:07,200 --> 00:01:09,520
and what's known is

35
00:01:09,520 --> 00:01:10,880
is that actually

36
00:01:10,880 --> 00:01:13,920
ot a protocol for ot implies a protocol

37
00:01:13,920 --> 00:01:15,360
for

38
00:01:15,360 --> 00:01:17,840
multi-party computation of uh general

39
00:01:17,840 --> 00:01:19,360
functionalities arbitrary

40
00:01:19,360 --> 00:01:20,880
functionalities among arbitrary number

41
00:01:20,880 --> 00:01:23,439
of parties okay so if you're interested

42
00:01:23,439 --> 00:01:25,119
in obtaining feasibility results about

43
00:01:25,119 --> 00:01:26,400
mpc

44
00:01:26,400 --> 00:01:28,240
um you know you can really focus in on

45
00:01:28,240 --> 00:01:30,720
this very simple functionality of ot

46
00:01:30,720 --> 00:01:32,400
and indeed uh you know there's been been

47
00:01:32,400 --> 00:01:33,920
many works that studied ot and it's

48
00:01:33,920 --> 00:01:35,360
known from various standard

49
00:01:35,360 --> 00:01:37,119
cryptographic assumptions such as

50
00:01:37,119 --> 00:01:38,640
diffie-hellman style assumptions

51
00:01:38,640 --> 00:01:41,439
learning with errors etc

52
00:01:41,439 --> 00:01:44,240
however a major goal in in cryptography

53
00:01:44,240 --> 00:01:46,399
is to base your primitives or your

54
00:01:46,399 --> 00:01:49,920
constructions on as weak or as simple

55
00:01:49,920 --> 00:01:51,840
as assumptions as possible and one-way

56
00:01:51,840 --> 00:01:53,280
functions the existence of one-way

57
00:01:53,280 --> 00:01:55,119
functions is kind of the weakest

58
00:01:55,119 --> 00:01:56,719
possible assumption that's currently

59
00:01:56,719 --> 00:02:00,079
known to imply apply crypto right

60
00:02:00,079 --> 00:02:02,560
um it's a very generic assumption just

61
00:02:02,560 --> 00:02:03,520
saying that

62
00:02:03,520 --> 00:02:06,240
some some one-way function exists right

63
00:02:06,240 --> 00:02:08,720
unfortunately in in 89 in pogba azan

64
00:02:08,720 --> 00:02:10,720
ruditz showed that you probably cannot

65
00:02:10,720 --> 00:02:13,599
construct ot from black box usage of

66
00:02:13,599 --> 00:02:15,599
one-way functions thus showing like a

67
00:02:15,599 --> 00:02:18,080
black box separation between these

68
00:02:18,080 --> 00:02:20,959
and even to this day some 30 years later

69
00:02:20,959 --> 00:02:22,640
there are no really non-black box

70
00:02:22,640 --> 00:02:24,720
techniques uh known

71
00:02:24,720 --> 00:02:26,080
um so

72
00:02:26,080 --> 00:02:27,440
current state of affairs is that it's

73
00:02:27,440 --> 00:02:28,640
not known

74
00:02:28,640 --> 00:02:30,239
and there are barriers to constructing

75
00:02:30,239 --> 00:02:33,680
ot from one-way functions okay

76
00:02:33,680 --> 00:02:35,680
so you could also ask about

77
00:02:35,680 --> 00:02:36,400
you know

78
00:02:36,400 --> 00:02:38,400
what happens in a quantum world when you

79
00:02:38,400 --> 00:02:40,959
know parties and adversaries are quantum

80
00:02:40,959 --> 00:02:43,519
and they have potentially quantum inputs

81
00:02:43,519 --> 00:02:45,840
so it is still true that ot implies npc

82
00:02:45,840 --> 00:02:48,160
and indeed it even implies uh

83
00:02:48,160 --> 00:02:50,080
multi-party quantum computation as shown

84
00:02:50,080 --> 00:02:53,440
by these works of dns and dgjms

85
00:02:53,440 --> 00:02:55,840
um but quite interestingly

86
00:02:55,840 --> 00:02:58,800
um krapa and killian in 88

87
00:02:58,800 --> 00:03:00,560
showed a template

88
00:03:00,560 --> 00:03:03,360
for potent for constructing ot

89
00:03:03,360 --> 00:03:05,200
based on bit commitments they kind of

90
00:03:05,200 --> 00:03:07,760
just gave this template okay uh which is

91
00:03:07,760 --> 00:03:08,959
which is interesting because such a

92
00:03:08,959 --> 00:03:09,920
template

93
00:03:09,920 --> 00:03:11,840
is not known in the classical setting

94
00:03:11,840 --> 00:03:14,239
right and what really differentiates uh

95
00:03:14,239 --> 00:03:16,080
their protocol is that it makes inherent

96
00:03:16,080 --> 00:03:18,400
usage of quantum communication during

97
00:03:18,400 --> 00:03:20,480
the protocol okay

98
00:03:20,480 --> 00:03:21,519
so

99
00:03:21,519 --> 00:03:22,959
um

100
00:03:22,959 --> 00:03:24,159
like

101
00:03:24,159 --> 00:03:25,040
you know

102
00:03:25,040 --> 00:03:27,280
it wasn't until like many years later

103
00:03:27,280 --> 00:03:29,599
that that dflss actually like

104
00:03:29,599 --> 00:03:31,760
instantiated this template uh from a

105
00:03:31,760 --> 00:03:33,599
concrete assumption in particular they

106
00:03:33,599 --> 00:03:35,519
built a particular type of bit

107
00:03:35,519 --> 00:03:37,440
commitment from lwe

108
00:03:37,440 --> 00:03:39,519
but then allowed to prove the security

109
00:03:39,519 --> 00:03:42,239
of this ot protocol following this ck88

110
00:03:42,239 --> 00:03:43,920
approach okay

111
00:03:43,920 --> 00:03:45,760
however still there's nothing you know

112
00:03:45,760 --> 00:03:47,840
it's the end result is not new right

113
00:03:47,840 --> 00:03:50,000
because uh it was already known that lwe

114
00:03:50,000 --> 00:03:52,799
implied ot which implies npc

115
00:03:52,799 --> 00:03:53,840
right

116
00:03:53,840 --> 00:03:56,000
another interesting work however bf10

117
00:03:56,000 --> 00:03:57,920
showed that following this template you

118
00:03:57,920 --> 00:04:00,879
could actually obtain some weak form of

119
00:04:00,879 --> 00:04:02,080
ot

120
00:04:02,080 --> 00:04:03,599
which is like indistinguishability-based

121
00:04:03,599 --> 00:04:06,239
ot as opposed to simulation-based ot

122
00:04:06,239 --> 00:04:08,799
just from one-way functions okay and so

123
00:04:08,799 --> 00:04:10,319
this is super interesting and not known

124
00:04:10,319 --> 00:04:12,720
in the classical setting however

125
00:04:12,720 --> 00:04:14,799
this week like in-based ot is not known

126
00:04:14,799 --> 00:04:17,759
to imply uh full-fledged npc okay so

127
00:04:17,759 --> 00:04:20,238
there's still this gap right uh at least

128
00:04:20,238 --> 00:04:21,680
prior to our work it was not known

129
00:04:21,680 --> 00:04:22,880
whether one-way functions were

130
00:04:22,880 --> 00:04:25,199
sufficient for uh you know full-fledged

131
00:04:25,199 --> 00:04:27,520
npc and so kind of to recap what i have

132
00:04:27,520 --> 00:04:29,199
have just said and

133
00:04:29,199 --> 00:04:30,720
you know in the classical world we have

134
00:04:30,720 --> 00:04:32,639
this uh separation this black box

135
00:04:32,639 --> 00:04:34,320
separation between between ochi and

136
00:04:34,320 --> 00:04:36,960
one-way functions in a quantum world

137
00:04:36,960 --> 00:04:39,199
it uh you know the relationship was is a

138
00:04:39,199 --> 00:04:42,240
little bit less clear and so so our work

139
00:04:42,240 --> 00:04:45,040
uh shows that actually uh you know

140
00:04:45,040 --> 00:04:47,040
simulation secure ot that is sufficient

141
00:04:47,040 --> 00:04:49,360
for mpc can be built even from just

142
00:04:49,360 --> 00:04:52,240
black box usage of one-way functions

143
00:04:52,240 --> 00:04:54,639
um and again this result is in a quantum

144
00:04:54,639 --> 00:04:57,120
world and uses quantum communication

145
00:04:57,120 --> 00:04:59,280
but this establishes you know that

146
00:04:59,280 --> 00:05:00,560
you could actually build full-fledged

147
00:05:00,560 --> 00:05:02,960
npc for one-way functions

148
00:05:02,960 --> 00:05:04,479
in a quantum

149
00:05:04,479 --> 00:05:06,000
okay

150
00:05:06,000 --> 00:05:07,039
so

151
00:05:07,039 --> 00:05:09,600
so this is the result

152
00:05:09,600 --> 00:05:12,560
and i you know before getting in tech

153
00:05:12,560 --> 00:05:14,160
into techniques i'm going to have to

154
00:05:14,160 --> 00:05:15,360
share some

155
00:05:15,360 --> 00:05:17,840
background about how this cropon killian

156
00:05:17,840 --> 00:05:20,080
ot protocol works okay

157
00:05:20,080 --> 00:05:21,600
so here we have you know we have our

158
00:05:21,600 --> 00:05:24,000
sender with two strings a receiver with

159
00:05:24,000 --> 00:05:25,759
a bit b at the end of the protocol we

160
00:05:25,759 --> 00:05:28,160
want the receiver to output sub b okay

161
00:05:28,160 --> 00:05:30,560
but not learn anything about s1 minus b

162
00:05:30,560 --> 00:05:31,919
right

163
00:05:31,919 --> 00:05:34,800
so the protocol begins uh you know i

164
00:05:34,800 --> 00:05:35,840
guess

165
00:05:35,840 --> 00:05:37,680
uh similar to like a key exchange

166
00:05:37,680 --> 00:05:39,199
quantum key exchange protocol and that

167
00:05:39,199 --> 00:05:41,919
one party uh sends a bunch of so-called

168
00:05:41,919 --> 00:05:44,240
bb-84 states over

169
00:05:44,240 --> 00:05:46,160
over to the other party so the sender

170
00:05:46,160 --> 00:05:48,639
samples random bb-84 states which is

171
00:05:48,639 --> 00:05:50,160
which are basically

172
00:05:50,160 --> 00:05:53,120
uh consists of uh sampling two bits per

173
00:05:53,120 --> 00:05:56,479
per state um uh one bit uh determining

174
00:05:56,479 --> 00:05:58,800
what basis uh the state is going to be

175
00:05:58,800 --> 00:06:01,120
in the other bit determining you know uh

176
00:06:01,120 --> 00:06:02,960
which of the two possibilities of the

177
00:06:02,960 --> 00:06:04,800
state is in so

178
00:06:04,800 --> 00:06:06,639
um you know you have

179
00:06:06,639 --> 00:06:08,479
uh the head of our basis uh plus and

180
00:06:08,479 --> 00:06:10,160
minus and the standard base is zero and

181
00:06:10,160 --> 00:06:12,319
one okay and you and the sender just

182
00:06:12,319 --> 00:06:15,280
basically sends um

183
00:06:15,280 --> 00:06:16,160
uh

184
00:06:16,160 --> 00:06:18,840
yeah random bb-84 states to the receiver

185
00:06:18,840 --> 00:06:21,680
okay so the receiver at this point

186
00:06:21,680 --> 00:06:24,000
doesn't know what these states are what

187
00:06:24,000 --> 00:06:25,360
it's going to do is sample its own

188
00:06:25,360 --> 00:06:28,319
random sequence of bases and and measure

189
00:06:28,319 --> 00:06:29,280
uh

190
00:06:29,280 --> 00:06:32,720
these uh qubits um in its own basis data

191
00:06:32,720 --> 00:06:35,680
print okay and so roughly half the time

192
00:06:35,680 --> 00:06:37,600
it'll guess the right basis roughly half

193
00:06:37,600 --> 00:06:39,039
the time it'll guess the wrong basis and

194
00:06:39,039 --> 00:06:40,639
so in the positions where it gets wrong

195
00:06:40,639 --> 00:06:42,080
this x prime

196
00:06:42,080 --> 00:06:43,039
it obtains are just going to be

197
00:06:43,039 --> 00:06:44,880
uniformly random bits

198
00:06:44,880 --> 00:06:46,560
but in the positions that i guess right

199
00:06:46,560 --> 00:06:48,400
it will obtain the correct

200
00:06:48,400 --> 00:06:49,759
um

201
00:06:49,759 --> 00:06:50,479
or

202
00:06:50,479 --> 00:06:51,280
you know

203
00:06:51,280 --> 00:06:53,280
the values that get will match uh the

204
00:06:53,280 --> 00:06:55,039
values that the sender sampled so

205
00:06:55,039 --> 00:06:56,639
basically this is kind of establishing

206
00:06:56,639 --> 00:06:58,400
some channel where the sender is sending

207
00:06:58,400 --> 00:06:59,280
some

208
00:06:59,280 --> 00:07:01,680
classical information in the form of

209
00:07:01,680 --> 00:07:03,599
quantum states and the receiver is

210
00:07:03,599 --> 00:07:04,639
obtaining

211
00:07:04,639 --> 00:07:06,960
um some random like subset of this

212
00:07:06,960 --> 00:07:09,440
information okay so it's so some of the

213
00:07:09,440 --> 00:07:11,199
information essentially gets erased by

214
00:07:11,199 --> 00:07:12,479
the measurements that the receiver is

215
00:07:12,479 --> 00:07:14,400
performing okay

216
00:07:14,400 --> 00:07:16,479
and you know the sender doesn't know

217
00:07:16,479 --> 00:07:18,400
what the receiver got uh correctly and

218
00:07:18,400 --> 00:07:19,919
what it got incorrectly so it's kind of

219
00:07:19,919 --> 00:07:23,440
this eraser channel is happening here

220
00:07:23,440 --> 00:07:24,160
so

221
00:07:24,160 --> 00:07:25,280
um

222
00:07:25,280 --> 00:07:26,160
you know

223
00:07:26,160 --> 00:07:28,080
we can obtain an ot protocol eventually

224
00:07:28,080 --> 00:07:30,400
from this um by by next having the

225
00:07:30,400 --> 00:07:32,560
sender you know announce like okay these

226
00:07:32,560 --> 00:07:34,160
are actually the bases that my qubits

227
00:07:34,160 --> 00:07:36,080
are in which which gives the receiver

228
00:07:36,080 --> 00:07:38,319
the information about which uh parts of

229
00:07:38,319 --> 00:07:39,759
the string x prime were correct and

230
00:07:39,759 --> 00:07:43,120
which were which were random okay so

231
00:07:43,120 --> 00:07:44,879
the receiver is then going to partition

232
00:07:44,879 --> 00:07:46,879
the indices into these two sets one in

233
00:07:46,879 --> 00:07:48,479
which it was correct and one in which it

234
00:07:48,479 --> 00:07:49,759
was incorrect

235
00:07:49,759 --> 00:07:52,160
and send over this uh partition back to

236
00:07:52,160 --> 00:07:53,840
the sender

237
00:07:53,840 --> 00:07:56,080
okay

238
00:07:56,080 --> 00:07:57,919
you know and so what this you know the

239
00:07:57,919 --> 00:08:00,240
sender then partitions x according to

240
00:08:00,240 --> 00:08:01,759
these indices and so what this is really

241
00:08:01,759 --> 00:08:03,520
setting up is a situation where the

242
00:08:03,520 --> 00:08:06,560
receiver knows exactly xb

243
00:08:06,560 --> 00:08:08,800
um but doesn't know anything about x1

244
00:08:08,800 --> 00:08:10,879
minus b and so the sender can then

245
00:08:10,879 --> 00:08:12,720
encrypt their you know their zeroth

246
00:08:12,720 --> 00:08:14,479
string under x0 and their their one

247
00:08:14,479 --> 00:08:17,360
string under x1 okay

248
00:08:17,360 --> 00:08:18,720
um

249
00:08:18,720 --> 00:08:21,039
right so this this gives like a correct

250
00:08:21,039 --> 00:08:22,479
uh protocol

251
00:08:22,479 --> 00:08:23,280
and

252
00:08:23,280 --> 00:08:25,199
uh seems pretty secure if the receiver

253
00:08:25,199 --> 00:08:27,440
is like you know exactly following this

254
00:08:27,440 --> 00:08:28,639
this

255
00:08:28,639 --> 00:08:31,199
template right but there's a very easy

256
00:08:31,199 --> 00:08:33,519
attack that are receiving a cheating

257
00:08:33,519 --> 00:08:35,599
receiver can mount which is just to

258
00:08:35,599 --> 00:08:38,080
simply wait until the sender announces

259
00:08:38,080 --> 00:08:39,200
the bases

260
00:08:39,200 --> 00:08:41,839
to measure right so you know imagine the

261
00:08:41,839 --> 00:08:42,958
receiver just doesn't measure these

262
00:08:42,958 --> 00:08:45,440
qubits and then it eventually gets the

263
00:08:45,440 --> 00:08:47,519
sender's bases now it can measure all of

264
00:08:47,519 --> 00:08:49,680
these qubits in the correct basis

265
00:08:49,680 --> 00:08:52,560
and learn um you know the entire correct

266
00:08:52,560 --> 00:08:54,240
string x which allows it to break

267
00:08:54,240 --> 00:08:56,240
security right

268
00:08:56,240 --> 00:08:58,399
so in order to fix this uh you know the

269
00:08:58,399 --> 00:09:01,600
idea um uh from krapon killian was to

270
00:09:01,600 --> 00:09:03,200
insert

271
00:09:03,200 --> 00:09:05,200
this measurement check sub protocol

272
00:09:05,200 --> 00:09:08,399
which is basically there to

273
00:09:08,480 --> 00:09:10,320
for the sender

274
00:09:10,320 --> 00:09:12,480
to check that the receiver is honestly

275
00:09:12,480 --> 00:09:14,000
measuring the qubits that it sent in the

276
00:09:14,000 --> 00:09:16,240
first round right so what we're going to

277
00:09:16,240 --> 00:09:17,279
do now

278
00:09:17,279 --> 00:09:19,040
is after they save our measures they're

279
00:09:19,040 --> 00:09:20,480
actually going to send

280
00:09:20,480 --> 00:09:22,720
commitments so these these locked boxes

281
00:09:22,720 --> 00:09:24,880
represent cryptographic commitments

282
00:09:24,880 --> 00:09:28,240
uh to all of their uh basis choices and

283
00:09:28,240 --> 00:09:30,720
uh measurement results okay

284
00:09:30,720 --> 00:09:32,320
and then the sender will ask the

285
00:09:32,320 --> 00:09:34,160
receiver to open some random subset of

286
00:09:34,160 --> 00:09:36,640
them uh which it will do

287
00:09:36,640 --> 00:09:39,040
and the sender will will make sure that

288
00:09:39,040 --> 00:09:42,720
like like all of the um positions where

289
00:09:42,720 --> 00:09:45,440
the receiver guessed the basis right

290
00:09:45,440 --> 00:09:47,600
then it must have obtained the correct

291
00:09:47,600 --> 00:09:49,680
uh bit so on this you know on this

292
00:09:49,680 --> 00:09:51,200
fourth position the receiver guessed

293
00:09:51,200 --> 00:09:53,680
right therefore it must have um obtained

294
00:09:53,680 --> 00:09:55,279
the the bit zero

295
00:09:55,279 --> 00:09:56,800
and if the receiver is you know

296
00:09:56,800 --> 00:09:58,000
correctly

297
00:09:58,000 --> 00:09:58,800
you know

298
00:09:58,800 --> 00:10:00,800
correctly obtaining all of the all of

299
00:10:00,800 --> 00:10:02,720
the bits then the sender can be

300
00:10:02,720 --> 00:10:04,240
reasonably convinced that the receiver

301
00:10:04,240 --> 00:10:05,760
was you know honestly performing these

302
00:10:05,760 --> 00:10:06,800
measurements

303
00:10:06,800 --> 00:10:07,600
okay

304
00:10:07,600 --> 00:10:10,959
so this kind of like this kind of uh

305
00:10:10,959 --> 00:10:12,240
so then they're gonna have to discard

306
00:10:12,240 --> 00:10:14,240
some of the qubits that they use to test

307
00:10:14,240 --> 00:10:16,000
and then they uh proceed with the rest

308
00:10:16,000 --> 00:10:18,160
of with the rest of the protocol on the

309
00:10:18,160 --> 00:10:21,519
on the non-tested qubits right

310
00:10:21,519 --> 00:10:22,800
and again this is called this

311
00:10:22,800 --> 00:10:26,880
measurement jackson protocol okay

312
00:10:27,040 --> 00:10:28,000
so

313
00:10:28,000 --> 00:10:30,160
so right this is kind of the

314
00:10:30,160 --> 00:10:32,320
idea that was put forth by krypon

315
00:10:32,320 --> 00:10:34,240
killian

316
00:10:34,240 --> 00:10:36,240
and as i mentioned it was not until a

317
00:10:36,240 --> 00:10:38,959
while later at dflss that kind of

318
00:10:38,959 --> 00:10:40,880
security at least simulation security of

319
00:10:40,880 --> 00:10:43,760
this ot protocol was formally analyzed

320
00:10:43,760 --> 00:10:45,200
and what they showed

321
00:10:45,200 --> 00:10:47,200
in this paper is that

322
00:10:47,200 --> 00:10:48,640
if your

323
00:10:48,640 --> 00:10:51,200
bit commitment scheme satisfies certain

324
00:10:51,200 --> 00:10:53,040
special properties then you can indeed

325
00:10:53,040 --> 00:10:54,720
prove that this protocol is simulation's

326
00:10:54,720 --> 00:10:56,800
secure in particular if your commitment

327
00:10:56,800 --> 00:10:59,040
scheme is extractable then you can

328
00:10:59,040 --> 00:11:00,560
obtain security against a malicious

329
00:11:00,560 --> 00:11:01,600
receiver

330
00:11:01,600 --> 00:11:03,360
if your commitment scheme is equivocal

331
00:11:03,360 --> 00:11:04,800
you can obtain security against a

332
00:11:04,800 --> 00:11:06,160
malicious sender

333
00:11:06,160 --> 00:11:08,880
and so to see like intuitively why that

334
00:11:08,880 --> 00:11:10,800
is

335
00:11:10,800 --> 00:11:12,160
let's say you want security against a

336
00:11:12,160 --> 00:11:14,160
malicious receiver and in particular

337
00:11:14,160 --> 00:11:16,800
what that means is that the simulator

338
00:11:16,800 --> 00:11:18,240
is going to have to interact with this

339
00:11:18,240 --> 00:11:20,560
receiver and extract their effective

340
00:11:20,560 --> 00:11:22,000
choice bit b

341
00:11:22,000 --> 00:11:24,320
right and so what the simulator is going

342
00:11:24,320 --> 00:11:25,279
to do

343
00:11:25,279 --> 00:11:27,360
is you know first extract from the

344
00:11:27,360 --> 00:11:29,279
receiver's commitments

345
00:11:29,279 --> 00:11:30,320
which they can do assuming the

346
00:11:30,320 --> 00:11:32,399
commitment is extractable

347
00:11:32,399 --> 00:11:36,000
and you know now that they know all of

348
00:11:36,000 --> 00:11:38,079
you know theta prime x prime when the

349
00:11:38,079 --> 00:11:41,120
receiver sends over uh the indices i

350
00:11:41,120 --> 00:11:43,040
zero i1

351
00:11:43,040 --> 00:11:44,880
they know exactly which one which one's

352
00:11:44,880 --> 00:11:46,160
the receiver guessed right which one's

353
00:11:46,160 --> 00:11:48,240
the receiver guessed wrong which exactly

354
00:11:48,240 --> 00:11:50,160
indicates what the receiver's choice bit

355
00:11:50,160 --> 00:11:51,440
was okay

356
00:11:51,440 --> 00:11:54,399
so this is how how to perform extraction

357
00:11:54,399 --> 00:11:55,680
um

358
00:11:55,680 --> 00:11:56,639
right

359
00:11:56,639 --> 00:11:57,360
so

360
00:11:57,360 --> 00:12:00,079
uh on the other hand if we want security

361
00:12:00,079 --> 00:12:01,839
against the malicious sender uh it's the

362
00:12:01,839 --> 00:12:03,440
same deal we're gonna have to at least

363
00:12:03,440 --> 00:12:05,680
extract the sender's effective inputs

364
00:12:05,680 --> 00:12:09,040
from it which you know our s1 0 and s1

365
00:12:09,040 --> 00:12:11,760
so the strategy that the simulator is

366
00:12:11,760 --> 00:12:12,800
going to

367
00:12:12,800 --> 00:12:15,680
perform to do this is to basically carry

368
00:12:15,680 --> 00:12:17,600
out the receive malicious receivers

369
00:12:17,600 --> 00:12:19,519
attack i mentioned earlier which was

370
00:12:19,519 --> 00:12:21,920
basically to delay measurement of these

371
00:12:21,920 --> 00:12:23,839
qubits and the simulator is going to be

372
00:12:23,839 --> 00:12:25,839
able to do this because we require these

373
00:12:25,839 --> 00:12:27,920
commitments to be equivocal right so

374
00:12:27,920 --> 00:12:29,440
what's going to happen

375
00:12:29,440 --> 00:12:31,040
is the simulator

376
00:12:31,040 --> 00:12:32,959
interacting with a malicious sender is

377
00:12:32,959 --> 00:12:34,800
not going to measure initially it's

378
00:12:34,800 --> 00:12:36,000
first going to send some dummy

379
00:12:36,000 --> 00:12:37,200
commitments

380
00:12:37,200 --> 00:12:39,519
equivocal commitments and then once it

381
00:12:39,519 --> 00:12:41,680
receives the you know the challenge from

382
00:12:41,680 --> 00:12:43,920
the sender it will then only measure uh

383
00:12:43,920 --> 00:12:45,680
the qubits that it has to so two and

384
00:12:45,680 --> 00:12:47,519
four in this case

385
00:12:47,519 --> 00:12:49,519
so it can pass this check

386
00:12:49,519 --> 00:12:51,200
um and then later when the malicious

387
00:12:51,200 --> 00:12:54,000
sender sends over uh like their bases

388
00:12:54,000 --> 00:12:56,720
now now the simulator can measure all

389
00:12:56,720 --> 00:12:58,560
the rest of the qubits and learn all the

390
00:12:58,560 --> 00:13:01,600
information about x um allowing it to

391
00:13:01,600 --> 00:13:04,639
you know learn both of these um

392
00:13:04,639 --> 00:13:07,519
x0 and x1 and eventually learn both s0

393
00:13:07,519 --> 00:13:08,800
and s1

394
00:13:08,800 --> 00:13:09,839
right so

395
00:13:09,839 --> 00:13:12,079
we saw that you know if this commitment

396
00:13:12,079 --> 00:13:14,320
is extractable then you can extract the

397
00:13:14,320 --> 00:13:16,480
receiver's input if this command is

398
00:13:16,480 --> 00:13:18,240
equivocal you can extract the sender's

399
00:13:18,240 --> 00:13:19,920
input and this can be leveraged to

400
00:13:19,920 --> 00:13:22,079
obtain a full simulation security of

401
00:13:22,079 --> 00:13:24,480
this protocol okay

402
00:13:24,480 --> 00:13:26,959
so this was what was you know shown by

403
00:13:26,959 --> 00:13:29,760
dflss

404
00:13:29,920 --> 00:13:31,920
and this is also the starting point of

405
00:13:31,920 --> 00:13:33,519
our work

406
00:13:33,519 --> 00:13:36,639
so our goal now if we actually want

407
00:13:36,639 --> 00:13:37,920
the result

408
00:13:37,920 --> 00:13:40,959
ot from one way functions is to build an

409
00:13:40,959 --> 00:13:42,800
extractable and equivocal bit commitment

410
00:13:42,800 --> 00:13:45,360
from one-way functions right

411
00:13:45,360 --> 00:13:47,920
and so this is what what we do and we

412
00:13:47,920 --> 00:13:49,440
basically have two

413
00:13:49,440 --> 00:13:51,920
technical contributions in order to to

414
00:13:51,920 --> 00:13:53,120
do this

415
00:13:53,120 --> 00:13:55,279
uh one of them is

416
00:13:55,279 --> 00:13:58,240
a a black box equivocality compiler

417
00:13:58,240 --> 00:14:00,560
which basically takes any like any

418
00:14:00,560 --> 00:14:03,760
commitment scheme and turns it equivocal

419
00:14:03,760 --> 00:14:06,959
in a black box manner okay

420
00:14:06,959 --> 00:14:08,800
um and also in a post-quantum manner

421
00:14:08,800 --> 00:14:11,120
right all of this has to be post-quantum

422
00:14:11,120 --> 00:14:12,639
um

423
00:14:12,639 --> 00:14:14,720
and the second thing is just is taking

424
00:14:14,720 --> 00:14:16,959
any extractable or any equivocal

425
00:14:16,959 --> 00:14:18,399
commitment

426
00:14:18,399 --> 00:14:20,240
along with quantum communication and and

427
00:14:20,240 --> 00:14:22,320
making it an extractable equipment okay

428
00:14:22,320 --> 00:14:24,000
so you know we have these two

429
00:14:24,000 --> 00:14:25,360
ingredients

430
00:14:25,360 --> 00:14:28,160
um and in order to eventually obtain an

431
00:14:28,160 --> 00:14:29,920
extractable and equivocal commitment

432
00:14:29,920 --> 00:14:32,079
from them we proceed in three steps so

433
00:14:32,079 --> 00:14:34,959
basically start with a

434
00:14:34,959 --> 00:14:36,639
a regular commitment with no extra

435
00:14:36,639 --> 00:14:38,000
properties that's known from one way

436
00:14:38,000 --> 00:14:39,519
functions so for example an hour's

437
00:14:39,519 --> 00:14:41,440
commitment

438
00:14:41,440 --> 00:14:43,839
apply our equivocality compiler to that

439
00:14:43,839 --> 00:14:46,399
to turn it equivocal apply our you know

440
00:14:46,399 --> 00:14:48,720
our second step here to turn that

441
00:14:48,720 --> 00:14:50,560
equivocal commitment into an extractable

442
00:14:50,560 --> 00:14:52,240
equipment um

443
00:14:52,240 --> 00:14:53,839
but now it's no longer equivocal so we

444
00:14:53,839 --> 00:14:55,199
actually have to apply our first step

445
00:14:55,199 --> 00:14:56,079
again

446
00:14:56,079 --> 00:14:58,480
to um kind of in a black box way make

447
00:14:58,480 --> 00:15:00,800
this extractable commitment equivocal um

448
00:15:00,800 --> 00:15:02,480
and this preserves the extractability

449
00:15:02,480 --> 00:15:04,480
and and in the end we get what we wanted

450
00:15:04,480 --> 00:15:06,320
which is an extractable and equivalent

451
00:15:06,320 --> 00:15:07,920
commitment

452
00:15:07,920 --> 00:15:08,880
so

453
00:15:08,880 --> 00:15:11,040
yeah let me now say if a few words about

454
00:15:11,040 --> 00:15:12,320
each of these steps i'll actually start

455
00:15:12,320 --> 00:15:14,320
with the second one because it's uh it's

456
00:15:14,320 --> 00:15:16,639
a little bit more um immediate based on

457
00:15:16,639 --> 00:15:18,320
what i've already discussed

458
00:15:18,320 --> 00:15:20,560
and in fact it uses this like ck

459
00:15:20,560 --> 00:15:22,959
template it which is a template for ot

460
00:15:22,959 --> 00:15:24,399
and turns it into basically in a

461
00:15:24,399 --> 00:15:26,720
template for an extractable commitment

462
00:15:26,720 --> 00:15:29,199
okay so what i mean is that you know

463
00:15:29,199 --> 00:15:31,199
let's look at this ot protocol that i

464
00:15:31,199 --> 00:15:34,079
just had up a couple slides ago

465
00:15:34,079 --> 00:15:36,079
and recall that

466
00:15:36,079 --> 00:15:37,040
if this

467
00:15:37,040 --> 00:15:38,560
what i argued was that if this

468
00:15:38,560 --> 00:15:40,240
commitment is equivocal then there

469
00:15:40,240 --> 00:15:42,160
existed a simulator that could extract

470
00:15:42,160 --> 00:15:45,680
the sender's inputs from the sender s0s1

471
00:15:45,680 --> 00:15:48,000
so we're going to take the same strategy

472
00:15:48,000 --> 00:15:50,560
in order to uh you know come up with an

473
00:15:50,560 --> 00:15:52,800
equi with an extractable commitment

474
00:15:52,800 --> 00:15:55,199
right so let's view this sender no

475
00:15:55,199 --> 00:15:57,040
longer as being like an ot sender but

476
00:15:57,040 --> 00:15:58,720
actually a committer that would like to

477
00:15:58,720 --> 00:16:00,880
commit to a bit b okay

478
00:16:00,880 --> 00:16:02,560
so we're going to do the same very

479
00:16:02,560 --> 00:16:04,000
similar protocol

480
00:16:04,000 --> 00:16:05,040
except

481
00:16:05,040 --> 00:16:06,720
that you know this committer no longer

482
00:16:06,720 --> 00:16:08,240
has two strings it just has a single

483
00:16:08,240 --> 00:16:10,800
string that it's going to encrypt with x

484
00:16:10,800 --> 00:16:12,320
okay

485
00:16:12,320 --> 00:16:14,160
or really a single bit b that is going

486
00:16:14,160 --> 00:16:16,800
to encrypt with x and in order to

487
00:16:16,800 --> 00:16:18,800
extract this bit b we can equivocate

488
00:16:18,800 --> 00:16:20,959
these receiver components and extract in

489
00:16:20,959 --> 00:16:23,519
the same manner as i as i described in

490
00:16:23,519 --> 00:16:25,360
the ot protocol okay

491
00:16:25,360 --> 00:16:27,120
so this gives this kind of like second

492
00:16:27,120 --> 00:16:28,800
result is that you know again this is

493
00:16:28,800 --> 00:16:30,399
crucial using quantum communication

494
00:16:30,399 --> 00:16:32,160
right so if we have quantum

495
00:16:32,160 --> 00:16:34,160
communication and we have an equivocal

496
00:16:34,160 --> 00:16:36,480
bit commitment we can obtain like this

497
00:16:36,480 --> 00:16:40,880
post quantum extractable commitment okay

498
00:16:40,880 --> 00:16:43,040
right so this is uh

499
00:16:43,040 --> 00:16:45,759
this is the second step and now i can uh

500
00:16:45,759 --> 00:16:47,440
talk about this first step which is this

501
00:16:47,440 --> 00:16:50,079
black box equivocality compiler so again

502
00:16:50,079 --> 00:16:52,480
we're taking any commitment scheme com

503
00:16:52,480 --> 00:16:54,240
and turning it into an equivocal

504
00:16:54,240 --> 00:16:57,279
commitment scheme equifam okay

505
00:16:57,279 --> 00:17:00,399
and this proceeds as follows so

506
00:17:00,399 --> 00:17:03,120
in order to uh equivocally connect to a

507
00:17:03,120 --> 00:17:04,720
bit b

508
00:17:04,720 --> 00:17:06,160
we're going to have the committer first

509
00:17:06,160 --> 00:17:09,439
send four uh commitments okay

510
00:17:09,439 --> 00:17:12,400
so it's gonna sample two bits and like

511
00:17:12,400 --> 00:17:14,959
commit to each bit twice okay

512
00:17:14,959 --> 00:17:17,280
and the receiver is wants to be

513
00:17:17,280 --> 00:17:19,119
convinced basically that the committer

514
00:17:19,119 --> 00:17:21,760
was acting honestly um by committing to

515
00:17:21,760 --> 00:17:23,039
like like

516
00:17:23,039 --> 00:17:24,400
wants to know

517
00:17:24,400 --> 00:17:25,760
that the committer is really committing

518
00:17:25,760 --> 00:17:27,760
to the same bit in each of these in each

519
00:17:27,760 --> 00:17:30,000
of these rows right so it's going to

520
00:17:30,000 --> 00:17:32,559
check this by sampling a random bit c

521
00:17:32,559 --> 00:17:34,160
and for the purpose of the slide we'll

522
00:17:34,160 --> 00:17:36,960
assume c is equal to zero and asking the

523
00:17:36,960 --> 00:17:39,919
committer to open to like the zeroth row

524
00:17:39,919 --> 00:17:41,120
okay

525
00:17:41,120 --> 00:17:41,919
so

526
00:17:41,919 --> 00:17:43,760
the committer will indeed give openings

527
00:17:43,760 --> 00:17:46,080
to this to this row the receiver will

528
00:17:46,080 --> 00:17:48,000
check that indeed they both commit to

529
00:17:48,000 --> 00:17:49,200
the same bit

530
00:17:49,200 --> 00:17:52,320
okay and then uh the committer will also

531
00:17:52,320 --> 00:17:54,960
uh hide the bit that it wants to commit

532
00:17:54,960 --> 00:17:57,919
to by exiling it with with e1 which is

533
00:17:57,919 --> 00:18:00,480
the bit committed in the other row okay

534
00:18:00,480 --> 00:18:02,720
so

535
00:18:02,960 --> 00:18:05,120
yeah so now how is the committer going

536
00:18:05,120 --> 00:18:06,559
to open

537
00:18:06,559 --> 00:18:08,720
um well it'll simply give one of the

538
00:18:08,720 --> 00:18:10,640
commitment keys for you know one of

539
00:18:10,640 --> 00:18:12,960
these two bottom commits right and then

540
00:18:12,960 --> 00:18:15,520
the receiver can obtain u1 and strip u1

541
00:18:15,520 --> 00:18:18,000
off of this bit to obtain uh the bit b

542
00:18:18,000 --> 00:18:19,840
committed to by the computer

543
00:18:19,840 --> 00:18:22,080
okay

544
00:18:22,080 --> 00:18:23,440
right so

545
00:18:23,440 --> 00:18:24,400
um

546
00:18:24,400 --> 00:18:27,520
yeah so why is this equivocal first

547
00:18:27,520 --> 00:18:28,799
well

548
00:18:28,799 --> 00:18:30,880
um

549
00:18:30,880 --> 00:18:32,640
so what can a

550
00:18:32,640 --> 00:18:35,039
like you know equivocator do is it can

551
00:18:35,039 --> 00:18:38,080
basically cheat in how it forms these

552
00:18:38,080 --> 00:18:39,600
four commitments

553
00:18:39,600 --> 00:18:41,360
so in particular can choose one of the

554
00:18:41,360 --> 00:18:44,080
two rows to lie in and basically commit

555
00:18:44,080 --> 00:18:46,320
to different bits okay

556
00:18:46,320 --> 00:18:48,160
but of course for this committer to not

557
00:18:48,160 --> 00:18:49,360
be caught

558
00:18:49,360 --> 00:18:51,600
we need the receiver's challenge to be

559
00:18:51,600 --> 00:18:53,440
uh you know a particular bit like in

560
00:18:53,440 --> 00:18:54,320
this case we're going to need the

561
00:18:54,320 --> 00:18:56,240
receiver's challenge to be zero in order

562
00:18:56,240 --> 00:18:58,720
to ensure that this equivocal committer

563
00:18:58,720 --> 00:19:01,520
is not caught right and so

564
00:19:01,520 --> 00:19:03,840
what you can do as a simulator right is

565
00:19:03,840 --> 00:19:05,760
is basically rewind the receiver until

566
00:19:05,760 --> 00:19:07,200
you get the challenge that you want

567
00:19:07,200 --> 00:19:08,840
which in this case is

568
00:19:08,840 --> 00:19:12,320
zero and then yeah the the equivocal uh

569
00:19:12,320 --> 00:19:14,080
committer can like open the receiver

570
00:19:14,080 --> 00:19:16,480
will be happy and

571
00:19:16,480 --> 00:19:18,240
and they can just send like a random bit

572
00:19:18,240 --> 00:19:20,240
in place of uh a bit the bit they want

573
00:19:20,240 --> 00:19:21,440
to commit to

574
00:19:21,440 --> 00:19:23,360
and so this is equivocal because now in

575
00:19:23,360 --> 00:19:24,720
the open phase

576
00:19:24,720 --> 00:19:27,280
this committer can either open

577
00:19:27,280 --> 00:19:28,799
this first commitment or the second

578
00:19:28,799 --> 00:19:30,160
commitment and depending on which one

579
00:19:30,160 --> 00:19:31,200
they open

580
00:19:31,200 --> 00:19:32,559
determines like which bit they're

581
00:19:32,559 --> 00:19:34,480
actually opening so it's not even until

582
00:19:34,480 --> 00:19:36,000
this open phase that the committer

583
00:19:36,000 --> 00:19:37,600
really has to decide which bit to open

584
00:19:37,600 --> 00:19:38,480
to

585
00:19:38,480 --> 00:19:39,760
okay so

586
00:19:39,760 --> 00:19:42,400
right so if if we're if we're simulating

587
00:19:42,400 --> 00:19:44,400
a receiver and we have the ability to

588
00:19:44,400 --> 00:19:46,320
rewind them then basically

589
00:19:46,320 --> 00:19:49,440
we're able to equivocate this commitment

590
00:19:49,440 --> 00:19:50,240
um

591
00:19:50,240 --> 00:19:51,200
and

592
00:19:51,200 --> 00:19:53,280
again we're in the post-quantum setting

593
00:19:53,280 --> 00:19:55,440
where rewinding is not necessarily uh

594
00:19:55,440 --> 00:19:56,960
straightforward and in fact runs into

595
00:19:56,960 --> 00:19:59,200
many issues in many settings although we

596
00:19:59,200 --> 00:20:00,640
show that in this setting uh we can

597
00:20:00,640 --> 00:20:03,440
actually use watches rewinding dilemma

598
00:20:03,440 --> 00:20:05,840
to successfully rewind and simulate a

599
00:20:05,840 --> 00:20:07,120
receiver

600
00:20:07,120 --> 00:20:10,880
and also in the paper right to establish

601
00:20:10,880 --> 00:20:14,000
you know binding of this

602
00:20:14,000 --> 00:20:15,520
protocol against

603
00:20:15,520 --> 00:20:17,600
against a committer

604
00:20:17,600 --> 00:20:18,960
we're going to have to basically repeat

605
00:20:18,960 --> 00:20:21,919
this whole phase like multiple times and

606
00:20:21,919 --> 00:20:24,159
and so i will um

607
00:20:24,159 --> 00:20:26,000
let you look at the paper uh for those

608
00:20:26,000 --> 00:20:27,840
details but this is kind of the basic

609
00:20:27,840 --> 00:20:29,440
idea of how we

610
00:20:29,440 --> 00:20:31,919
um you know from any uh from any

611
00:20:31,919 --> 00:20:33,039
commitment scheme note that we didn't

612
00:20:33,039 --> 00:20:34,480
use any like special properties of this

613
00:20:34,480 --> 00:20:35,919
commitment scheme and we use it in a

614
00:20:35,919 --> 00:20:37,760
black box manner we can construct an

615
00:20:37,760 --> 00:20:39,679
equivalent commitment from it and so

616
00:20:39,679 --> 00:20:41,679
this kind of completes the technical

617
00:20:41,679 --> 00:20:44,320
contributions of our paper

618
00:20:44,320 --> 00:20:46,000
before ending i did want to mention that

619
00:20:46,000 --> 00:20:47,600
there is a

620
00:20:47,600 --> 00:20:50,240
concurrent and independent work uh gllsv

621
00:20:50,240 --> 00:20:54,080
that was at eurocrypt this year

622
00:20:54,080 --> 00:20:56,640
that also have has the same core result

623
00:20:56,640 --> 00:20:58,400
that one-way functions and quantum

624
00:20:58,400 --> 00:21:00,320
communication implies ot

625
00:21:00,320 --> 00:21:01,120
okay

626
00:21:01,120 --> 00:21:03,360
i'll just mention a couple differences

627
00:21:03,360 --> 00:21:04,159
um

628
00:21:04,159 --> 00:21:06,320
so i guess the main advantage of our of

629
00:21:06,320 --> 00:21:07,679
our work is that we actually use the

630
00:21:07,679 --> 00:21:09,280
one-way functions in a black box way

631
00:21:09,280 --> 00:21:10,880
which establishes like

632
00:21:10,880 --> 00:21:12,720
um a clear separation between the

633
00:21:12,720 --> 00:21:14,159
classical and quantum

634
00:21:14,159 --> 00:21:16,400
um settings

635
00:21:16,400 --> 00:21:18,640
and could be useful you know for you

636
00:21:18,640 --> 00:21:19,919
know maybe

637
00:21:19,919 --> 00:21:21,039
we obtain

638
00:21:21,039 --> 00:21:22,960
um you know commitments

639
00:21:22,960 --> 00:21:24,720
commitment schemes from like various

640
00:21:24,720 --> 00:21:26,080
other assumptions

641
00:21:26,080 --> 00:21:27,520
perhaps and you could just plug those

642
00:21:27,520 --> 00:21:30,080
into our our black box compilers and and

643
00:21:30,080 --> 00:21:31,840
and get the protocol to work whereas

644
00:21:31,840 --> 00:21:33,840
glsv you like use the one-way functions

645
00:21:33,840 --> 00:21:37,200
in a non-black box way okay

646
00:21:37,200 --> 00:21:39,360
um but they also

647
00:21:39,360 --> 00:21:41,760
uh you know they also study

648
00:21:41,760 --> 00:21:42,640
the

649
00:21:42,640 --> 00:21:44,559
ot and the crs model and give a cost

650
00:21:44,559 --> 00:21:45,919
around protocol

651
00:21:45,919 --> 00:21:46,880
um

652
00:21:46,880 --> 00:21:48,559
and then a couple other differences is

653
00:21:48,559 --> 00:21:51,200
actually our protocol has one uh cited

654
00:21:51,200 --> 00:21:52,799
statistical security so we get you know

655
00:21:52,799 --> 00:21:54,559
we get computational security against

656
00:21:54,559 --> 00:21:56,240
malicious sender statistical security

657
00:21:56,240 --> 00:21:58,240
against malicious receiver whereas glsv

658
00:21:58,240 --> 00:22:00,400
is both sides computational

659
00:22:00,400 --> 00:22:02,559
although one of their building blocks

660
00:22:02,559 --> 00:22:04,159
they show how to obtain a statistically

661
00:22:04,159 --> 00:22:07,280
binding extractual equipment

662
00:22:07,280 --> 00:22:08,640
you know with quantum communication and

663
00:22:08,640 --> 00:22:09,919
this is

664
00:22:09,919 --> 00:22:11,679
not something that we use as or that we

665
00:22:11,679 --> 00:22:14,000
construct as a building block so

666
00:22:14,000 --> 00:22:15,440
yeah i just wanted to say there's this

667
00:22:15,440 --> 00:22:16,400
uh

668
00:22:16,400 --> 00:22:19,280
um concurrent work with the same um

669
00:22:19,280 --> 00:22:21,280
uh main result and a few differences

670
00:22:21,280 --> 00:22:23,679
along the way so

671
00:22:23,679 --> 00:22:27,840
um and yeah that's it so so thank you

