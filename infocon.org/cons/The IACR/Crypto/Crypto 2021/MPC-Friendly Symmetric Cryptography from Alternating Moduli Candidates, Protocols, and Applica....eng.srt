1
00:00:00,410 --> 00:00:02,080
[Music]

2
00:00:02,080 --> 00:00:04,319
hi everyone i'm muhim nakalkar and i'm a

3
00:00:04,319 --> 00:00:06,640
phd student at cornell today i'll be

4
00:00:06,640 --> 00:00:08,960
talking about our paper on npc friendly

5
00:00:08,960 --> 00:00:11,040
symmetric cryptography from alternating

6
00:00:11,040 --> 00:00:12,080
moduli

7
00:00:12,080 --> 00:00:13,679
and this is joint work with several

8
00:00:13,679 --> 00:00:15,440
wonderful co-authors from all over the

9
00:00:15,440 --> 00:00:17,039
world

10
00:00:17,039 --> 00:00:19,119
so let me start with some motivation

11
00:00:19,119 --> 00:00:20,880
symmetric primitives have been used

12
00:00:20,880 --> 00:00:23,119
extensively throughout cryptography and

13
00:00:23,119 --> 00:00:25,039
computation was initially done by a

14
00:00:25,039 --> 00:00:27,519
single party but recent applications

15
00:00:27,519 --> 00:00:28,960
have required evaluation in a

16
00:00:28,960 --> 00:00:31,039
distributed setting where inputs and

17
00:00:31,039 --> 00:00:32,960
keys are secret shared among two or more

18
00:00:32,960 --> 00:00:34,160
parties

19
00:00:34,160 --> 00:00:36,000
this is somewhat non-ideal for standard

20
00:00:36,000 --> 00:00:38,320
constructions like aes and sha which

21
00:00:38,320 --> 00:00:39,680
were optimized for centralized

22
00:00:39,680 --> 00:00:41,680
evaluation and not designed with this

23
00:00:41,680 --> 00:00:44,559
distributed setting in mind so this kind

24
00:00:44,559 --> 00:00:46,960
of stimulates a natural area of research

25
00:00:46,960 --> 00:00:49,120
to design so-called mpc-friendly

26
00:00:49,120 --> 00:00:51,360
primitives from the ground up

27
00:00:51,360 --> 00:00:53,520
our work continues the exploration of

28
00:00:53,520 --> 00:00:55,520
this area

29
00:00:55,520 --> 00:00:57,360
so let's take a step back and try to

30
00:00:57,360 --> 00:00:59,600
understand what goals would be useful

31
00:00:59,600 --> 00:01:02,079
for mpc-friendly cryptography

32
00:01:02,079 --> 00:01:04,319
so to start the construction should have

33
00:01:04,319 --> 00:01:06,560
as little non-linearity as possible

34
00:01:06,560 --> 00:01:08,159
since nonlinear functions are more

35
00:01:08,159 --> 00:01:10,240
challenging to implement in mpc

36
00:01:10,240 --> 00:01:12,159
so concretely we want to minimize two

37
00:01:12,159 --> 00:01:14,880
parameters nonlinear depth which is the

38
00:01:14,880 --> 00:01:16,960
depth of the non-linear components and

39
00:01:16,960 --> 00:01:18,880
non-linear size which is the total

40
00:01:18,880 --> 00:01:20,880
number of nonlinear gates

41
00:01:20,880 --> 00:01:22,720
the type of nonlinear operation does

42
00:01:22,720 --> 00:01:24,240
matter but these should be good enough

43
00:01:24,240 --> 00:01:26,159
proxies

44
00:01:26,159 --> 00:01:28,240
our other design goals revolve around

45
00:01:28,240 --> 00:01:29,520
security

46
00:01:29,520 --> 00:01:31,200
the first is for these constructions to

47
00:01:31,200 --> 00:01:33,439
have a high algebraic degree which is

48
00:01:33,439 --> 00:01:35,520
beneficial for security

49
00:01:35,520 --> 00:01:37,759
and second we want simpler designs and

50
00:01:37,759 --> 00:01:40,000
simple conjectures of security because

51
00:01:40,000 --> 00:01:41,920
they're easier to implement with fewer

52
00:01:41,920 --> 00:01:44,320
errors and are also usually easier to

53
00:01:44,320 --> 00:01:47,600
reason about encrypt analyze

54
00:01:47,600 --> 00:01:49,920
so how is it that constraints like small

55
00:01:49,920 --> 00:01:52,560
nonlinear components and high algebraic

56
00:01:52,560 --> 00:01:55,759
degree can coexist at the same time

57
00:01:55,759 --> 00:01:57,680
so towards settling this apparent

58
00:01:57,680 --> 00:01:59,759
conflict a line of work started by

59
00:01:59,759 --> 00:02:02,560
bonnero and continued by chionero looked

60
00:02:02,560 --> 00:02:04,240
at a new paradigm for constructing

61
00:02:04,240 --> 00:02:05,360
primitives

62
00:02:05,360 --> 00:02:07,200
this was advertised as part of the

63
00:02:07,200 --> 00:02:09,520
so-called crypto dark matter which they

64
00:02:09,520 --> 00:02:11,760
defined as a large space of unexplored

65
00:02:11,760 --> 00:02:14,319
areas of cryptography focusing primarily

66
00:02:14,319 --> 00:02:16,080
on simple constructions and efficient

67
00:02:16,080 --> 00:02:19,040
protocols for practical applications

68
00:02:19,040 --> 00:02:20,879
their focus was on this alternating

69
00:02:20,879 --> 00:02:22,959
moduli paradigm where the high level

70
00:02:22,959 --> 00:02:24,640
idea is to have constructions that

71
00:02:24,640 --> 00:02:27,360
compose linear functions over different

72
00:02:27,360 --> 00:02:28,800
moduli

73
00:02:28,800 --> 00:02:30,239
and linear functions are easy to

74
00:02:30,239 --> 00:02:32,400
evaluate so these constructions will be

75
00:02:32,400 --> 00:02:34,560
quite efficient and since most of the

76
00:02:34,560 --> 00:02:37,040
computation is linear the nonlinear size

77
00:02:37,040 --> 00:02:39,040
should also be low

78
00:02:39,040 --> 00:02:40,640
the security argument for these

79
00:02:40,640 --> 00:02:42,239
constructions needs to be carefully

80
00:02:42,239 --> 00:02:44,560
analyzed and the two papers i mentioned

81
00:02:44,560 --> 00:02:45,760
initially

82
00:02:45,760 --> 00:02:49,518
started the study in this direction

83
00:02:49,599 --> 00:02:51,519
so before i describe the contributions

84
00:02:51,519 --> 00:02:53,680
of our work i'll set the stage with a

85
00:02:53,680 --> 00:02:55,920
candidate weak prf proposed by bonaire

86
00:02:55,920 --> 00:02:58,480
in this alternating moduli paradigm

87
00:02:58,480 --> 00:03:00,159
so just as a quick reminder a

88
00:03:00,159 --> 00:03:01,680
pseudorandom function is a keyed

89
00:03:01,680 --> 00:03:03,680
function that looks like a truly random

90
00:03:03,680 --> 00:03:04,480
function

91
00:03:04,480 --> 00:03:05,920
so basically it's difficult for a

92
00:03:05,920 --> 00:03:07,920
polytime adversary to distinguish

93
00:03:07,920 --> 00:03:10,080
between an oracle that uses a prf and an

94
00:03:10,080 --> 00:03:12,959
oracle that uses a truly random function

95
00:03:12,959 --> 00:03:14,879
and for a weak prf in particular there's

96
00:03:14,879 --> 00:03:16,720
an added restriction that inputs are

97
00:03:16,720 --> 00:03:19,360
chosen uniformly at random instead of

98
00:03:19,360 --> 00:03:22,800
allowing the adversary to pick them

99
00:03:23,040 --> 00:03:24,640
so the main candidate proposed by

100
00:03:24,640 --> 00:03:27,440
bonnero was the 2-3-week prf which

101
00:03:27,440 --> 00:03:29,680
composes linear functions mod 2 and mod

102
00:03:29,680 --> 00:03:30,480
3.

103
00:03:30,480 --> 00:03:32,560
this is parametrized by the length n of

104
00:03:32,560 --> 00:03:34,159
the input the length m of the

105
00:03:34,159 --> 00:03:36,480
intermediate vector and length t of the

106
00:03:36,480 --> 00:03:37,840
output

107
00:03:37,840 --> 00:03:40,400
and they also use a public z3 matrix b

108
00:03:40,400 --> 00:03:42,640
of size t by n

109
00:03:42,640 --> 00:03:44,799
so for the construction the key is a z2

110
00:03:44,799 --> 00:03:47,120
matrix of size m by n

111
00:03:47,120 --> 00:03:49,200
the input is an n bit vector and the

112
00:03:49,200 --> 00:03:52,400
output is t z3 elements

113
00:03:52,400 --> 00:03:55,360
so now the candidate works as follows

114
00:03:55,360 --> 00:03:56,959
first it multiplies the secret key

115
00:03:56,959 --> 00:03:58,840
matrix with the input and this is a

116
00:03:58,840 --> 00:04:01,120
non-compressive secret linear map over

117
00:04:01,120 --> 00:04:02,480
z2

118
00:04:02,480 --> 00:04:07,040
next w equals kx which is the z2 vector

119
00:04:07,040 --> 00:04:12,080
is reinterpreted as a 0 1 vector over z3

120
00:04:12,080 --> 00:04:14,319
and finally this is multiplied with a

121
00:04:14,319 --> 00:04:16,160
public matrix b

122
00:04:16,160 --> 00:04:19,839
over z3 to get the output y

123
00:04:19,839 --> 00:04:21,759
so in other words the modular mix by

124
00:04:21,759 --> 00:04:23,919
first taking a linear mapping over z2

125
00:04:23,919 --> 00:04:25,759
then converting the intermediate vector

126
00:04:25,759 --> 00:04:28,080
to z3 and then computing a linear map

127
00:04:28,080 --> 00:04:30,000
over c3

128
00:04:30,000 --> 00:04:32,560
so why is this conjecture to work

129
00:04:32,560 --> 00:04:35,199
so as it turns out

130
00:04:35,199 --> 00:04:37,919
a linear map over z2 is a high degree

131
00:04:37,919 --> 00:04:40,960
function over z3 and vice versa

132
00:04:40,960 --> 00:04:42,479
high degree isn't it it cannot be

133
00:04:42,479 --> 00:04:46,320
approximated by low degree polynomials

134
00:04:46,320 --> 00:04:48,560
another conjecture from bone at all

135
00:04:48,560 --> 00:04:51,919
implies hardness of learning for low

136
00:04:51,919 --> 00:04:53,520
complexity classes

137
00:04:53,520 --> 00:04:56,080
like depth to acc 0 and with three

138
00:04:56,080 --> 00:04:58,960
branching programs

139
00:04:59,199 --> 00:05:01,680
so this work continues the exploration

140
00:05:01,680 --> 00:05:03,680
of designing new candidate constructions

141
00:05:03,680 --> 00:05:06,160
in this alternating moduli paradigm

142
00:05:06,160 --> 00:05:08,000
so while bonnet at all only considered

143
00:05:08,000 --> 00:05:10,400
prfs we ask whether we can construct

144
00:05:10,400 --> 00:05:12,639
simple candidates for other primitives

145
00:05:12,639 --> 00:05:14,479
like one-way functions and pseudorandom

146
00:05:14,479 --> 00:05:15,600
generators

147
00:05:15,600 --> 00:05:17,440
so we'll also present a candidate weak

148
00:05:17,440 --> 00:05:19,919
prf where the key input and output are

149
00:05:19,919 --> 00:05:22,080
all over z2 so this is useful for

150
00:05:22,080 --> 00:05:24,000
settings where the output of the first

151
00:05:24,000 --> 00:05:26,479
prf evaluation is kept secret and fed in

152
00:05:26,479 --> 00:05:29,280
as input into the second evaluation

153
00:05:29,280 --> 00:05:31,520
so for all of our candidates we perform

154
00:05:31,520 --> 00:05:33,600
substantial cryptanalysis and use that

155
00:05:33,600 --> 00:05:36,080
to inform our parameter choices

156
00:05:36,080 --> 00:05:37,680
and later we'll give efficient

157
00:05:37,680 --> 00:05:39,360
distributed protocols for several

158
00:05:39,360 --> 00:05:42,240
settings with and without pre-processing

159
00:05:42,240 --> 00:05:44,080
and all the protocols will only consider

160
00:05:44,080 --> 00:05:46,320
semi-honest parties

161
00:05:46,320 --> 00:05:48,000
and finally we'll talk about some

162
00:05:48,000 --> 00:05:49,919
applications and two primary

163
00:05:49,919 --> 00:05:52,720
applications we considered are oprfs and

164
00:05:52,720 --> 00:05:55,360
signatures

165
00:05:55,520 --> 00:05:57,520
so i'll now proceed to introduce our

166
00:05:57,520 --> 00:06:00,639
candidate constructions

167
00:06:00,800 --> 00:06:02,479
the general structure of all of our

168
00:06:02,479 --> 00:06:04,560
candidates is quite similar

169
00:06:04,560 --> 00:06:07,840
we parametrized by n m and t as before

170
00:06:07,840 --> 00:06:10,160
and the core design now is to first map

171
00:06:10,160 --> 00:06:12,880
the input x to an intermediate w with

172
00:06:12,880 --> 00:06:15,120
non-compressive linear maps

173
00:06:15,120 --> 00:06:17,440
and then map w to the output y with

174
00:06:17,440 --> 00:06:19,600
compressive linear maps and these linear

175
00:06:19,600 --> 00:06:23,120
maps will be over different moduli

176
00:06:23,280 --> 00:06:25,280
the first construction i'll describe is

177
00:06:25,280 --> 00:06:26,560
our candidate

178
00:06:26,560 --> 00:06:28,240
one-way function

179
00:06:28,240 --> 00:06:29,919
so recall that a one-way function is an

180
00:06:29,919 --> 00:06:31,440
efficiently computable function that's

181
00:06:31,440 --> 00:06:33,360
hard to invert

182
00:06:33,360 --> 00:06:35,759
so given a random why it's difficult for

183
00:06:35,759 --> 00:06:37,680
an efficient adversary to compute the

184
00:06:37,680 --> 00:06:40,240
pre-image

185
00:06:40,560 --> 00:06:42,560
so now our candidate 2-3 one-way

186
00:06:42,560 --> 00:06:44,960
function has the same structure as the

187
00:06:44,960 --> 00:06:47,680
2-3 week prf candidate except now the

188
00:06:47,680 --> 00:06:51,199
key k is replaced with a public matrix a

189
00:06:51,199 --> 00:06:53,120
so now you have a public linear map over

190
00:06:53,120 --> 00:06:55,759
z2 which uses a and then a public linear

191
00:06:55,759 --> 00:06:59,360
map over z3 which uses b

192
00:06:59,680 --> 00:07:02,160
i'll briefly describe an interesting

193
00:07:02,160 --> 00:07:03,759
attack on the two three one-way function

194
00:07:03,759 --> 00:07:06,000
based on a reduction to subset sum so

195
00:07:06,000 --> 00:07:07,520
this is the only attack i'll describe in

196
00:07:07,520 --> 00:07:09,599
this talk a lot more cryptanalysis was

197
00:07:09,599 --> 00:07:11,120
done for this candidate as well as the

198
00:07:11,120 --> 00:07:12,960
other candidates i'll describe

199
00:07:12,960 --> 00:07:14,319
and all of this can be found in the full

200
00:07:14,319 --> 00:07:16,960
version of our paper

201
00:07:16,960 --> 00:07:18,800
so for the 2-3 one-way function the

202
00:07:18,800 --> 00:07:22,000
attacker is given a output y and

203
00:07:22,000 --> 00:07:25,039
attempts to invert it

204
00:07:26,240 --> 00:07:28,319
now given a vector w there exists a

205
00:07:28,319 --> 00:07:30,479
parity-check matrix p

206
00:07:30,479 --> 00:07:32,960
such that pw equals 0 if and only if

207
00:07:32,960 --> 00:07:36,160
there exists an x such that a times x is

208
00:07:36,160 --> 00:07:37,280
w

209
00:07:37,280 --> 00:07:39,520
so that is when there is an inverse x

210
00:07:39,520 --> 00:07:41,120
for a given y

211
00:07:41,120 --> 00:07:44,639
then p times w equals 0 and b w mod 3

212
00:07:44,639 --> 00:07:47,199
equals y

213
00:07:47,599 --> 00:07:49,919
so now this down basically boils down to

214
00:07:49,919 --> 00:07:52,400
finding the subset j of indices from 1

215
00:07:52,400 --> 00:07:55,919
to m such that the sum over j of p times

216
00:07:55,919 --> 00:08:00,560
e j mod 2 is zero and the sum of j a sum

217
00:08:00,560 --> 00:08:04,240
over j of b times e j mod 3 is y

218
00:08:04,240 --> 00:08:07,039
so here e j is the jth unit vector

219
00:08:07,039 --> 00:08:08,720
which is a vector with zeros everywhere

220
00:08:08,720 --> 00:08:11,120
except for the j entry which is one

221
00:08:11,120 --> 00:08:12,800
so it's easy now to see how this is

222
00:08:12,800 --> 00:08:15,280
basically the subset problem except

223
00:08:15,280 --> 00:08:18,080
now over z2 cross c3 instead of the

224
00:08:18,080 --> 00:08:19,280
integers

225
00:08:19,280 --> 00:08:20,800
and here the variables are the unit

226
00:08:20,800 --> 00:08:22,879
vectors

227
00:08:22,879 --> 00:08:24,800
so we choose our parameters to resist

228
00:08:24,800 --> 00:08:27,039
attacks based on advanced subset sum

229
00:08:27,039 --> 00:08:29,599
algorithms

230
00:08:31,520 --> 00:08:33,200
the second construction i'll introduce

231
00:08:33,200 --> 00:08:35,440
is our candidate weak prf where the key

232
00:08:35,440 --> 00:08:38,559
input and output all need to be over z2

233
00:08:38,559 --> 00:08:40,240
so for this candidate we'll multiply the

234
00:08:40,240 --> 00:08:43,599
key in the input both over z2 and z3 so

235
00:08:43,599 --> 00:08:45,920
more specifically we'll compute u equals

236
00:08:45,920 --> 00:08:49,440
kx mod 2 and then v equals kx mod 3 mod

237
00:08:49,440 --> 00:08:52,080
2 and now the intermediate vector w is

238
00:08:52,080 --> 00:08:53,200
taken as

239
00:08:53,200 --> 00:08:56,320
u plus v over z two

240
00:08:56,320 --> 00:08:58,000
so and finally as in the previous

241
00:08:58,000 --> 00:09:00,399
construction y is computed from w using

242
00:09:00,399 --> 00:09:02,080
the public matrix b

243
00:09:02,080 --> 00:09:03,760
the only difference here is that b is

244
00:09:03,760 --> 00:09:08,120
over z two rather than z three

245
00:09:08,160 --> 00:09:11,519
so for this construction our um each bit

246
00:09:11,519 --> 00:09:13,519
in w can be thought of as a

247
00:09:13,519 --> 00:09:16,320
deterministic lpn instance

248
00:09:16,320 --> 00:09:18,880
with noise rate one-third so this noise

249
00:09:18,880 --> 00:09:20,959
is provided by v and each bit of the

250
00:09:20,959 --> 00:09:22,959
noise can be thought of as based on the

251
00:09:22,959 --> 00:09:26,080
input x and a specific column of the key

252
00:09:26,080 --> 00:09:27,440
k

253
00:09:27,440 --> 00:09:29,040
so it turns out that this candidate is

254
00:09:29,040 --> 00:09:30,480
actually quite similar to the

255
00:09:30,480 --> 00:09:32,320
alternative weak prf candidate proposed

256
00:09:32,320 --> 00:09:34,480
by bonnet at all but with a couple key

257
00:09:34,480 --> 00:09:36,640
differences so for one their output was

258
00:09:36,640 --> 00:09:38,480
a single bit and basically was the

259
00:09:38,480 --> 00:09:40,640
intermediate vector and because second

260
00:09:40,640 --> 00:09:41,920
because of this

261
00:09:41,920 --> 00:09:44,160
uh they did not have this final

262
00:09:44,160 --> 00:09:47,200
linear compressive mapping using b

263
00:09:47,200 --> 00:09:49,040
so from a cryptanalysis standpoint

264
00:09:49,040 --> 00:09:50,959
having multiple output bits decreases

265
00:09:50,959 --> 00:09:52,080
security

266
00:09:52,080 --> 00:09:54,399
but from our analysis having the final

267
00:09:54,399 --> 00:09:58,560
compressive mapping offsets this loss

268
00:09:58,959 --> 00:10:00,640
and finally i'll briefly introduce our

269
00:10:00,640 --> 00:10:03,120
candidate lens doubling prg which needs

270
00:10:03,120 --> 00:10:04,959
to be able to generate 2n bit strings

271
00:10:04,959 --> 00:10:07,360
that look uniformly random

272
00:10:07,360 --> 00:10:09,040
so the prg has essentially the same

273
00:10:09,040 --> 00:10:11,760
structure as the lpn weak prf but now

274
00:10:11,760 --> 00:10:14,079
instead of using the tk we have a public

275
00:10:14,079 --> 00:10:16,160
matrix a over z2

276
00:10:16,160 --> 00:10:17,760
and for security we'll need to make sure

277
00:10:17,760 --> 00:10:19,360
that the intermediate vector is slightly

278
00:10:19,360 --> 00:10:21,760
longer

279
00:10:22,079 --> 00:10:24,560
so we performed extensive cryptanalysis

280
00:10:24,560 --> 00:10:26,240
on all of our candidates

281
00:10:26,240 --> 00:10:28,160
including the one from bonaire and used

282
00:10:28,160 --> 00:10:31,760
it to influence our parameter choices

283
00:10:31,760 --> 00:10:34,160
so in this work we primarily focus on

284
00:10:34,160 --> 00:10:36,079
combinatorial attacks and statistical

285
00:10:36,079 --> 00:10:37,440
tests

286
00:10:37,440 --> 00:10:39,680
for s bit security here's the parameter

287
00:10:39,680 --> 00:10:42,240
table for our candidates so we give both

288
00:10:42,240 --> 00:10:44,160
aggressive and conservative choices for

289
00:10:44,160 --> 00:10:47,360
our two three candidates and notably our

290
00:10:47,360 --> 00:10:49,200
one-way function and prg candidates have

291
00:10:49,200 --> 00:10:52,160
s bit inputs which is minimal for s-bit

292
00:10:52,160 --> 00:10:53,440
security

293
00:10:53,440 --> 00:10:55,360
and this is possible in principle for

294
00:10:55,360 --> 00:10:58,000
lpn weak prf as well but at the cost of

295
00:10:58,000 --> 00:11:00,240
other parameters which hurts npc

296
00:11:00,240 --> 00:11:02,240
friendliness

297
00:11:02,240 --> 00:11:03,760
one other thing to note here is that

298
00:11:03,760 --> 00:11:06,000
since our constructions are quite new

299
00:11:06,000 --> 00:11:07,839
it's not unlikely that even the

300
00:11:07,839 --> 00:11:10,480
conservative parameters could be broken

301
00:11:10,480 --> 00:11:11,760
so we definitely welcome more

302
00:11:11,760 --> 00:11:14,760
cryptanalysis

303
00:11:14,959 --> 00:11:16,480
i'll now move to describing efficient

304
00:11:16,480 --> 00:11:18,240
protocols to evaluate our candidate

305
00:11:18,240 --> 00:11:20,720
constructions

306
00:11:20,720 --> 00:11:22,640
as mentioned before we focus on the

307
00:11:22,640 --> 00:11:23,920
semi-honest setting and provide

308
00:11:23,920 --> 00:11:25,760
protocols for several distributed

309
00:11:25,760 --> 00:11:28,720
settings with and without pre-processing

310
00:11:28,720 --> 00:11:30,800
and all of our constructions use just

311
00:11:30,800 --> 00:11:33,920
five types of gates and protocols

312
00:11:33,920 --> 00:11:35,680
for these gates can be generically

313
00:11:35,680 --> 00:11:36,959
composed

314
00:11:36,959 --> 00:11:40,240
to evaluate any candidate

315
00:11:40,240 --> 00:11:41,680
so the five gates we use are pretty

316
00:11:41,680 --> 00:11:43,839
straightforward the first three are

317
00:11:43,839 --> 00:11:46,240
commonly used simple linear and additive

318
00:11:46,240 --> 00:11:48,880
gates and then we have two other modulus

319
00:11:48,880 --> 00:11:51,120
conversion gates to convert between

320
00:11:51,120 --> 00:11:53,760
shares in c2 and c3

321
00:11:53,760 --> 00:11:55,839
so the z2 and z3

322
00:11:55,839 --> 00:11:59,600
so the z2 to z3 gate converts shares of

323
00:11:59,600 --> 00:12:02,240
x over z2 to shares of the same x over

324
00:12:02,240 --> 00:12:03,279
z3

325
00:12:03,279 --> 00:12:06,160
and the z3 to z2 gate converts shares of

326
00:12:06,160 --> 00:12:10,480
x over z3 to shares of x mod 2 over z2

327
00:12:10,480 --> 00:12:12,079
and we'll provide efficient protocols

328
00:12:12,079 --> 00:12:15,680
for these modulus conversion gates

329
00:12:16,320 --> 00:12:18,160
so in terms of gate protocols the linear

330
00:12:18,160 --> 00:12:19,920
and addition gates can be computed

331
00:12:19,920 --> 00:12:22,000
locally and this directly follows from

332
00:12:22,000 --> 00:12:23,839
the linear homomorphism of additive

333
00:12:23,839 --> 00:12:25,760
secret sharing

334
00:12:25,760 --> 00:12:28,000
now for the bilinear gate where both the

335
00:12:28,000 --> 00:12:29,839
matrix and the input are secret shared

336
00:12:29,839 --> 00:12:31,120
either we can use standard

337
00:12:31,120 --> 00:12:33,040
multiplication triples or something like

338
00:12:33,040 --> 00:12:35,200
ole or vector oily correlations for

339
00:12:35,200 --> 00:12:37,279
unkeyed primitives or when the same key

340
00:12:37,279 --> 00:12:40,800
is used to evaluate multiple inputs

341
00:12:40,800 --> 00:12:42,560
for our modulus conversion gates we'll

342
00:12:42,560 --> 00:12:45,200
use a special type of pre-processing

343
00:12:45,200 --> 00:12:48,079
to convert from z2 to z3 we'll use a 2-3

344
00:12:48,079 --> 00:12:49,839
correlation which is a random bit that's

345
00:12:49,839 --> 00:12:52,720
shared both over z2 and c3

346
00:12:52,720 --> 00:12:55,440
and for the conversion from z3 to z2

347
00:12:55,440 --> 00:12:57,120
we'll use preprocessing of the following

348
00:12:57,120 --> 00:12:58,000
form

349
00:12:58,000 --> 00:13:00,800
a random r which is shared over z3

350
00:13:00,800 --> 00:13:03,600
r mod 2 which is shared over z2 and r

351
00:13:03,600 --> 00:13:05,920
plus 1 mod 3 mod 2 which is also shared

352
00:13:05,920 --> 00:13:07,360
over z2

353
00:13:07,360 --> 00:13:08,720
and given these correlations the

354
00:13:08,720 --> 00:13:11,360
protocols for evaluating

355
00:13:11,360 --> 00:13:12,880
the gates turns out to be quite

356
00:13:12,880 --> 00:13:14,800
straightforward so i won't go into

357
00:13:14,800 --> 00:13:15,760
detail

358
00:13:15,760 --> 00:13:16,639
here

359
00:13:16,639 --> 00:13:18,560
but later i'll also describe efficient

360
00:13:18,560 --> 00:13:20,399
techniques to generate the correlations

361
00:13:20,399 --> 00:13:23,040
that we require

362
00:13:23,440 --> 00:13:25,519
so these gate protocols can be easily

363
00:13:25,519 --> 00:13:26,880
composed

364
00:13:26,880 --> 00:13:29,600
to compute the overall protocol cost for

365
00:13:29,600 --> 00:13:31,040
our constructions

366
00:13:31,040 --> 00:13:33,120
and also for other similar constructions

367
00:13:33,120 --> 00:13:36,079
in this alternating moduli paradigm

368
00:13:36,079 --> 00:13:37,680
we can optimize some of the cost of

369
00:13:37,680 --> 00:13:39,920
pre-processing using standard techniques

370
00:13:39,920 --> 00:13:41,680
like using the same mask for the same

371
00:13:41,680 --> 00:13:44,240
input or compressing the pre-processing

372
00:13:44,240 --> 00:13:45,839
using a prg

373
00:13:45,839 --> 00:13:47,360
for our constructions in particular

374
00:13:47,360 --> 00:13:49,519
since the bilinear gate will often feed

375
00:13:49,519 --> 00:13:51,680
into the modulus conversion gate which

376
00:13:51,680 --> 00:13:53,519
requires reconstructing the mass input

377
00:13:53,519 --> 00:13:55,760
as its first step we can also reduce the

378
00:13:55,760 --> 00:13:57,760
pre-processing by masking the output

379
00:13:57,760 --> 00:14:01,360
within the bilinear gate itself

380
00:14:01,600 --> 00:14:03,199
another highlight is that all of our

381
00:14:03,199 --> 00:14:05,519
pre-processing is pcg-friendly

382
00:14:05,519 --> 00:14:07,120
in that the correlated randomness that

383
00:14:07,120 --> 00:14:08,320
we require

384
00:14:08,320 --> 00:14:10,560
uh can be generated with sublinear

385
00:14:10,560 --> 00:14:12,560
communication cost in good com

386
00:14:12,560 --> 00:14:14,880
computational efficiency for multiple

387
00:14:14,880 --> 00:14:18,160
instances at the same time

388
00:14:19,360 --> 00:14:21,120
so here's a table with the concrete

389
00:14:21,120 --> 00:14:23,360
costs for evaluating our candidates in

390
00:14:23,360 --> 00:14:24,639
different settings including the

391
00:14:24,639 --> 00:14:27,519
distributed to pc distributed through pc

392
00:14:27,519 --> 00:14:29,199
with replicated shares and no

393
00:14:29,199 --> 00:14:31,199
pre-processing and the public input to

394
00:14:31,199 --> 00:14:34,399
pc with pre-processing

395
00:14:34,399 --> 00:14:36,560
so online communication is given in bits

396
00:14:36,560 --> 00:14:38,160
number of messages and number of rounds

397
00:14:38,160 --> 00:14:40,240
and pre-processing is given both without

398
00:14:40,240 --> 00:14:43,639
and with compression

399
00:14:45,360 --> 00:14:46,959
now as i mentioned earlier i'll talk

400
00:14:46,959 --> 00:14:49,120
briefly about how we can distribute the

401
00:14:49,120 --> 00:14:51,360
dealer

402
00:14:51,360 --> 00:14:53,279
for the bilinear gate the pre-processing

403
00:14:53,279 --> 00:14:55,440
used can be easily compressed using

404
00:14:55,440 --> 00:14:58,480
existing pcgs for ole and vector oily

405
00:14:58,480 --> 00:14:59,920
and this results in getting k

406
00:14:59,920 --> 00:15:02,480
correlations with far fewer than k bits

407
00:15:02,480 --> 00:15:04,800
of communication

408
00:15:04,800 --> 00:15:07,199
for modulus conversion gates we show how

409
00:15:07,199 --> 00:15:08,880
to efficiently generate pre-processing

410
00:15:08,880 --> 00:15:10,639
from ot correlations

411
00:15:10,639 --> 00:15:12,800
and since ot correlations can be

412
00:15:12,800 --> 00:15:15,920
easily compressed with pcgs

413
00:15:15,920 --> 00:15:17,120
this implies that all of our

414
00:15:17,120 --> 00:15:18,639
pre-processing can be efficiently

415
00:15:18,639 --> 00:15:21,120
generated

416
00:15:21,519 --> 00:15:23,600
overall distributing the dealer does not

417
00:15:23,600 --> 00:15:26,399
actually add too much to the online cost

418
00:15:26,399 --> 00:15:28,399
so as a concrete example for the two pc

419
00:15:28,399 --> 00:15:30,639
setting with the two three week prf the

420
00:15:30,639 --> 00:15:35,600
total online cost is only 23 higher

421
00:15:35,839 --> 00:15:37,519
so now i'll talk briefly about how we

422
00:15:37,519 --> 00:15:40,399
generate our specific correlations so

423
00:15:40,399 --> 00:15:41,920
the functionality for the 2 3

424
00:15:41,920 --> 00:15:43,600
correlation is to generate shares for

425
00:15:43,600 --> 00:15:46,639
the same bit over c2 and c3

426
00:15:46,639 --> 00:15:48,720
and for this we'll use 1 out of 2 ot

427
00:15:48,720 --> 00:15:50,800
correlations over z3

428
00:15:50,800 --> 00:15:52,000
so here

429
00:15:52,000 --> 00:15:55,199
part 1 is given x0 and x1 and part 2 is

430
00:15:55,199 --> 00:15:58,639
given a bit b and the corresponding xb

431
00:15:58,639 --> 00:16:01,839
now when x0 and x1 are different

432
00:16:01,839 --> 00:16:03,440
the conversion between the ot

433
00:16:03,440 --> 00:16:05,519
correlation and the 2 3 correlation can

434
00:16:05,519 --> 00:16:07,199
be done locally

435
00:16:07,199 --> 00:16:09,759
so all that remains is for party one to

436
00:16:09,759 --> 00:16:11,920
communicate to party two

437
00:16:11,920 --> 00:16:13,600
which correlations

438
00:16:13,600 --> 00:16:15,440
it needs to throw out and this on

439
00:16:15,440 --> 00:16:17,839
expectation takes 1.3 bits of

440
00:16:17,839 --> 00:16:21,880
communication per instance

441
00:16:22,160 --> 00:16:24,079
now for the three two correlations that

442
00:16:24,079 --> 00:16:25,839
we require the functionality is to

443
00:16:25,839 --> 00:16:28,880
generate z2 shares of u and v and z

444
00:16:28,880 --> 00:16:30,240
three shares of r

445
00:16:30,240 --> 00:16:32,959
such that u equals r mod three and v

446
00:16:32,959 --> 00:16:35,600
equals r plus one mod three mod two

447
00:16:35,600 --> 00:16:37,120
and for this we'll use one out of three

448
00:16:37,120 --> 00:16:39,360
ot correlations where each entry is a

449
00:16:39,360 --> 00:16:41,759
two bit string

450
00:16:41,759 --> 00:16:44,079
now all of the

451
00:16:44,079 --> 00:16:45,759
now the parties in the

452
00:16:45,759 --> 00:16:47,440
uh protocol

453
00:16:47,440 --> 00:16:50,560
use these correlations in an ot protocol

454
00:16:50,560 --> 00:16:52,480
where party one's input is a random

455
00:16:52,480 --> 00:16:55,519
permutation of the z3 truth table for u

456
00:16:55,519 --> 00:16:56,720
and v

457
00:16:56,720 --> 00:16:58,720
so essentially we have two bits for each

458
00:16:58,720 --> 00:17:00,800
c3 value and a total of six bits of

459
00:17:00,800 --> 00:17:03,279
communication in one message from p1 to

460
00:17:03,279 --> 00:17:06,240
p2 per instance

461
00:17:07,199 --> 00:17:09,280
i'll now move on to talk briefly about

462
00:17:09,280 --> 00:17:12,240
our implementation and benchmarks

463
00:17:12,240 --> 00:17:15,119
so we implemented our two three week prf

464
00:17:15,119 --> 00:17:16,400
candidate and i'll first talk about the

465
00:17:16,400 --> 00:17:18,000
centralized implementation and mention

466
00:17:18,000 --> 00:17:21,280
the optimizations that we used

467
00:17:21,280 --> 00:17:23,520
so first we represent z2 vectors using

468
00:17:23,520 --> 00:17:26,160
64-bit machine words and operate on them

469
00:17:26,160 --> 00:17:28,720
in an simd manner

470
00:17:28,720 --> 00:17:30,559
next we used

471
00:17:30,559 --> 00:17:32,960
the z3 vector and represented it with

472
00:17:32,960 --> 00:17:34,799
two z2 vectors

473
00:17:34,799 --> 00:17:36,320
with the least significant bits and the

474
00:17:36,320 --> 00:17:39,039
most significant bits of the vector

475
00:17:39,039 --> 00:17:41,360
and third we use the lookup table for

476
00:17:41,360 --> 00:17:43,600
the public matrix multiplication

477
00:17:43,600 --> 00:17:45,600
so overall these optimizations make the

478
00:17:45,600 --> 00:17:47,760
implementation 25 times faster than the

479
00:17:47,760 --> 00:17:50,240
baseline

480
00:17:50,400 --> 00:17:52,320
we also implemented our two-party

481
00:17:52,320 --> 00:17:54,000
distributed evaluation protocol along

482
00:17:54,000 --> 00:17:56,080
with the original protocol from bonaire

483
00:17:56,080 --> 00:17:57,360
and for this we also used the

484
00:17:57,360 --> 00:17:58,960
optimizations i talked about in the

485
00:17:58,960 --> 00:18:00,960
previous slide

486
00:18:00,960 --> 00:18:02,320
so we found that our distributed

487
00:18:02,320 --> 00:18:04,080
protocol is about two to three times

488
00:18:04,080 --> 00:18:06,480
better than theirs on all fronts like

489
00:18:06,480 --> 00:18:08,080
pre-processing computation and

490
00:18:08,080 --> 00:18:09,600
communication

491
00:18:09,600 --> 00:18:10,960
the core reason for this is our

492
00:18:10,960 --> 00:18:12,559
efficient modulus conversion gates

493
00:18:12,559 --> 00:18:14,960
versus bone at all who used ot in their

494
00:18:14,960 --> 00:18:17,520
protocols

495
00:18:18,160 --> 00:18:20,000
i'll now briefly describe some of the

496
00:18:20,000 --> 00:18:22,720
applications that we considered

497
00:18:22,720 --> 00:18:24,400
the first application i'll talk about is

498
00:18:24,400 --> 00:18:26,880
oblivious evaluation for prfs

499
00:18:26,880 --> 00:18:29,039
so here there's two parties the server

500
00:18:29,039 --> 00:18:30,799
who has the prf key and the client who

501
00:18:30,799 --> 00:18:32,240
has the input

502
00:18:32,240 --> 00:18:33,919
and the goal of the protocol is for the

503
00:18:33,919 --> 00:18:36,240
client to learn only the output while

504
00:18:36,240 --> 00:18:37,919
the server learns nothing about the

505
00:18:37,919 --> 00:18:39,120
input

506
00:18:39,120 --> 00:18:40,400
and we'll provide two efficient

507
00:18:40,400 --> 00:18:42,960
protocols for the two three week prf to

508
00:18:42,960 --> 00:18:46,559
compute it in an oblivious manner

509
00:18:46,559 --> 00:18:49,360
so when the same key is used to evaluate

510
00:18:49,360 --> 00:18:51,520
multiple inputs we don't need to mask

511
00:18:51,520 --> 00:18:53,520
the key again so we'll pull this part

512
00:18:53,520 --> 00:18:56,720
out and put it into a key update phase

513
00:18:56,720 --> 00:18:58,559
and now this phase needs to be run only

514
00:18:58,559 --> 00:19:00,400
when the server

515
00:19:00,400 --> 00:19:03,679
wants the key to be changed

516
00:19:03,679 --> 00:19:05,520
for the actual input evaluation the

517
00:19:05,520 --> 00:19:07,280
overall protocol is quite similar to the

518
00:19:07,280 --> 00:19:09,039
distributed evaluation

519
00:19:09,039 --> 00:19:10,720
but now since the key has already been

520
00:19:10,720 --> 00:19:12,400
masked some of the messages can be

521
00:19:12,400 --> 00:19:15,120
combined and sent in earlier rounds

522
00:19:15,120 --> 00:19:16,720
so for the protocol the client will

523
00:19:16,720 --> 00:19:19,919
compute its mask input and its share of

524
00:19:19,919 --> 00:19:21,440
the masked intermediate vector and send

525
00:19:21,440 --> 00:19:23,600
both these to the server the server will

526
00:19:23,600 --> 00:19:25,360
now compute its own share and use this

527
00:19:25,360 --> 00:19:26,880
to reconstruct the mass intermediate

528
00:19:26,880 --> 00:19:28,000
vector

529
00:19:28,000 --> 00:19:30,720
and use this to compute the

530
00:19:30,720 --> 00:19:33,039
final output share of y

531
00:19:33,039 --> 00:19:36,240
and send both to the client

532
00:19:36,240 --> 00:19:37,840
so the client can use these now to

533
00:19:37,840 --> 00:19:40,640
compute its own share of y and then use

534
00:19:40,640 --> 00:19:42,640
the server's share to reconstruct the

535
00:19:42,640 --> 00:19:44,160
output locally

536
00:19:44,160 --> 00:19:46,000
so for the input evaluation know that

537
00:19:46,000 --> 00:19:48,480
the communication is optimal we only

538
00:19:48,480 --> 00:19:50,400
have one message from the client to the

539
00:19:50,400 --> 00:19:51,840
server and then one message from the

540
00:19:51,840 --> 00:19:54,000
server to the client

541
00:19:54,000 --> 00:19:56,480
our two protocols only differ in how the

542
00:19:56,480 --> 00:19:58,080
key gets masked

543
00:19:58,080 --> 00:19:59,760
so in the first protocol the mask is

544
00:19:59,760 --> 00:20:01,679
additive and in the second protocol the

545
00:20:01,679 --> 00:20:04,960
mask is multiplicative

546
00:20:05,440 --> 00:20:07,440
so we compared our two oprs to each

547
00:20:07,440 --> 00:20:09,679
other as well as to the standard ddh

548
00:20:09,679 --> 00:20:11,360
based oprf

549
00:20:11,360 --> 00:20:13,200
and the second oprf has a smaller

550
00:20:13,200 --> 00:20:15,039
evaluation cost

551
00:20:15,039 --> 00:20:16,960
both in terms of communication and

552
00:20:16,960 --> 00:20:19,440
computation but higher cost to update

553
00:20:19,440 --> 00:20:21,360
the key since it involves a matrix

554
00:20:21,360 --> 00:20:23,679
multiplication

555
00:20:23,679 --> 00:20:25,679
but still both of our constructions are

556
00:20:25,679 --> 00:20:28,559
much faster to compute than a ddh-based

557
00:20:28,559 --> 00:20:31,679
oprf they do require pre-processing and

558
00:20:31,679 --> 00:20:34,080
slightly more communication

559
00:20:34,080 --> 00:20:35,280
but in fact the highlight of our

560
00:20:35,280 --> 00:20:37,280
protocol is that they're faster than a

561
00:20:37,280 --> 00:20:39,360
single modular exponentiation or

562
00:20:39,360 --> 00:20:42,080
elliptic curve point multiplication

563
00:20:42,080 --> 00:20:43,679
plus there's still room for hardware

564
00:20:43,679 --> 00:20:46,240
based improvements so that the gain

565
00:20:46,240 --> 00:20:49,600
might be even higher

566
00:20:49,600 --> 00:20:51,520
our protocol is also two to three times

567
00:20:51,520 --> 00:20:53,600
better than the opf protocol from

568
00:20:53,600 --> 00:20:57,520
bonaire for the same two three week prf

569
00:20:57,520 --> 00:20:59,280
and from the table you can see for

570
00:20:59,280 --> 00:21:02,640
communication our protocols require 897

571
00:21:02,640 --> 00:21:06,080
and 641 bits respectively compared to

572
00:21:06,080 --> 00:21:08,559
512 for the ddh based

573
00:21:08,559 --> 00:21:10,000
so the communication cost is only

574
00:21:10,000 --> 00:21:11,440
slightly higher

575
00:21:11,440 --> 00:21:13,840
and even if no pre-processing is allowed

576
00:21:13,840 --> 00:21:16,720
our online cost is only about 30 to 39

577
00:21:16,720 --> 00:21:18,000
percent

578
00:21:18,000 --> 00:21:18,880
uh

579
00:21:18,880 --> 00:21:21,600
higher depending upon how frequently the

580
00:21:21,600 --> 00:21:24,719
key needs to be changed

581
00:21:25,600 --> 00:21:27,679
so further if we attempt to compare

582
00:21:27,679 --> 00:21:30,159
using communication and computation

583
00:21:30,159 --> 00:21:32,240
together at the same time

584
00:21:32,240 --> 00:21:35,760
given a six-ish mbps network our first

585
00:21:35,760 --> 00:21:37,039
protocol will be

586
00:21:37,039 --> 00:21:40,080
overall faster than the ddh-based oprf

587
00:21:40,080 --> 00:21:41,919
and for the second protocol this happens

588
00:21:41,919 --> 00:21:44,320
with a 2 mbps network which should be

589
00:21:44,320 --> 00:21:47,600
very reasonable in practice

590
00:21:48,559 --> 00:21:50,240
the other application i'll discuss is

591
00:21:50,240 --> 00:21:52,400
signature escapes

592
00:21:52,400 --> 00:21:54,000
so at a high level given a one-way

593
00:21:54,000 --> 00:21:55,919
function and a distributed protocol for

594
00:21:55,919 --> 00:21:58,640
computing it picnic provides a generic

595
00:21:58,640 --> 00:22:01,520
method to construct a signature scheme

596
00:22:01,520 --> 00:22:05,120
from this using mpc in the head

597
00:22:05,120 --> 00:22:08,000
so basically you run m instances of an n

598
00:22:08,000 --> 00:22:10,320
party protocol in your head

599
00:22:10,320 --> 00:22:12,400
which computes the one-way function

600
00:22:12,400 --> 00:22:14,799
and now you open tau of these instances

601
00:22:14,799 --> 00:22:16,880
and they can be checked by the verifier

602
00:22:16,880 --> 00:22:18,559
so opening here means that you reveal

603
00:22:18,559 --> 00:22:20,159
the transcripts of the parties in the

604
00:22:20,159 --> 00:22:22,720
npc and allow the verifier to check that

605
00:22:22,720 --> 00:22:25,039
they're consistent

606
00:22:25,039 --> 00:22:26,880
and finally you can use the fiat trimer

607
00:22:26,880 --> 00:22:29,039
transform to get non-interactivity in a

608
00:22:29,039 --> 00:22:30,960
standard way

609
00:22:30,960 --> 00:22:32,480
another thing to note here is that these

610
00:22:32,480 --> 00:22:34,720
signatures can be made post quantum

611
00:22:34,720 --> 00:22:38,080
using other transforms

612
00:22:38,159 --> 00:22:39,760
we compare the signature sizes when

613
00:22:39,760 --> 00:22:42,080
using our two three one-way function

614
00:22:42,080 --> 00:22:44,159
versus low mc which is used in standard

615
00:22:44,159 --> 00:22:45,120
picnic

616
00:22:45,120 --> 00:22:47,039
and for the same parameters we can see

617
00:22:47,039 --> 00:22:48,559
that the signature sizes are quite

618
00:22:48,559 --> 00:22:50,400
comparable in fact they're slightly

619
00:22:50,400 --> 00:22:52,400
smaller across the board using our

620
00:22:52,400 --> 00:22:54,559
one-way function so for example for

621
00:22:54,559 --> 00:22:56,640
128-bit security for the same picnic

622
00:22:56,640 --> 00:22:57,679
parameters

623
00:22:57,679 --> 00:22:59,200
our one-way function

624
00:22:59,200 --> 00:23:02,880
has signature size 10.66 kilobytes

625
00:23:02,880 --> 00:23:08,159
versus 12.36 kilobytes when using low mc

626
00:23:08,159 --> 00:23:10,000
another benefit is that using our

627
00:23:10,000 --> 00:23:11,760
one-way functions we could have

628
00:23:11,760 --> 00:23:14,000
potentially much better communication

629
00:23:14,000 --> 00:23:16,080
for distributed signal signature

630
00:23:16,080 --> 00:23:17,280
evaluation

631
00:23:17,280 --> 00:23:18,640
since now you have many different

632
00:23:18,640 --> 00:23:21,520
parties computing the signature jointly

633
00:23:21,520 --> 00:23:23,600
so here using low mc will result in a

634
00:23:23,600 --> 00:23:25,360
lot of rounds of communication since it

635
00:23:25,360 --> 00:23:26,799
has a high depth

636
00:23:26,799 --> 00:23:28,559
but our two three one-way function which

637
00:23:28,559 --> 00:23:32,799
will require much lesser communication

638
00:23:33,679 --> 00:23:35,679
i'll also briefly comment on other

639
00:23:35,679 --> 00:23:37,760
applications

640
00:23:37,760 --> 00:23:39,919
our biggest competitive advantage over

641
00:23:39,919 --> 00:23:42,080
other approaches is likely to be for the

642
00:23:42,080 --> 00:23:44,240
two and three party evaluation

643
00:23:44,240 --> 00:23:47,200
of prgs and the weak prf in the fully

644
00:23:47,200 --> 00:23:49,039
distributed setting so in particular

645
00:23:49,039 --> 00:23:51,039
current techniques like oprs don't work

646
00:23:51,039 --> 00:23:52,720
in this setting so for these kinds of

647
00:23:52,720 --> 00:23:54,400
applications

648
00:23:54,400 --> 00:23:58,080
our candidates will be suited best

649
00:23:58,799 --> 00:24:00,880
so for instance our fully distributed

650
00:24:00,880 --> 00:24:03,120
weak pair of protocols can be used for

651
00:24:03,120 --> 00:24:06,400
distributed searchable encryption

652
00:24:06,400 --> 00:24:09,039
also since our lpn weak prf has inputs

653
00:24:09,039 --> 00:24:11,840
and outputs over z2 it's natural to use

654
00:24:11,840 --> 00:24:13,760
this for applications like hierarchical

655
00:24:13,760 --> 00:24:16,000
key derivation where the output of one

656
00:24:16,000 --> 00:24:18,000
evaluation needs to be kept secret and

657
00:24:18,000 --> 00:24:21,600
fed in as input to the other evaluation

658
00:24:21,600 --> 00:24:23,360
another application is to use lens

659
00:24:23,360 --> 00:24:26,159
doubling prgs to securely compute keys

660
00:24:26,159 --> 00:24:26,880
for

661
00:24:26,880 --> 00:24:29,919
function secret sharing

662
00:24:30,720 --> 00:24:33,360
finally i'll conclude with some remarks

663
00:24:33,360 --> 00:24:35,520
the space of constructing symmetric

664
00:24:35,520 --> 00:24:37,520
primitives with simple designs is still

665
00:24:37,520 --> 00:24:39,600
very much unexplored and more

666
00:24:39,600 --> 00:24:41,919
cryptanalysis is definitely definitely

667
00:24:41,919 --> 00:24:43,360
needed

668
00:24:43,360 --> 00:24:45,440
and as for some open directions it would

669
00:24:45,440 --> 00:24:47,200
be interesting to have

670
00:24:47,200 --> 00:24:49,600
constructions for other primitives like

671
00:24:49,600 --> 00:24:53,200
block ciphers and hash functions

672
00:24:53,200 --> 00:24:54,799
it would also be

673
00:24:54,799 --> 00:24:57,120
nice to have efficient protocols

674
00:24:57,120 --> 00:24:59,039
that have malicious security which is a

675
00:24:59,039 --> 00:25:02,158
natural follow-up question

676
00:25:02,559 --> 00:25:05,720
thank you

