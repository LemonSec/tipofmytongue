1
00:00:00,080 --> 00:00:02,159
thank you for tuning in to this talk

2
00:00:02,159 --> 00:00:05,279
on the impossibility of quantum virtual

3
00:00:05,279 --> 00:00:07,440
black box obfuscation of classical

4
00:00:07,440 --> 00:00:09,200
circuits

5
00:00:09,200 --> 00:00:11,120
my goal today will be to argue that it's

6
00:00:11,120 --> 00:00:13,200
impossible to securely construct a

7
00:00:13,200 --> 00:00:15,280
certain cryptographic primitive

8
00:00:15,280 --> 00:00:17,119
and the primitive is some variant of the

9
00:00:17,119 --> 00:00:19,119
obfuscation primitive

10
00:00:19,119 --> 00:00:21,439
an obfuscation seems to be an extremely

11
00:00:21,439 --> 00:00:23,760
powerful primitive and so it has gotten

12
00:00:23,760 --> 00:00:25,279
a lot of attention already in the crypto

13
00:00:25,279 --> 00:00:27,359
community in the last years and you may

14
00:00:27,359 --> 00:00:29,119
have already heard about it many times

15
00:00:29,119 --> 00:00:30,640
but just in case you haven't i will give

16
00:00:30,640 --> 00:00:32,880
you some intuition

17
00:00:32,880 --> 00:00:35,680
informally the obfuscation of a program

18
00:00:35,680 --> 00:00:38,320
for example this hello world program

19
00:00:38,320 --> 00:00:40,800
is another program that does exactly the

20
00:00:40,800 --> 00:00:43,360
same thing but somehow it is less

21
00:00:43,360 --> 00:00:45,520
intelligible

22
00:00:45,520 --> 00:00:47,280
so if you run this long piece of code in

23
00:00:47,280 --> 00:00:50,000
blue you will also print the text hello

24
00:00:50,000 --> 00:00:50,960
world

25
00:00:50,960 --> 00:00:52,399
so it's functionally equivalent but

26
00:00:52,399 --> 00:00:54,559
that's very hard to tell just by looking

27
00:00:54,559 --> 00:00:55,920
at this code

28
00:00:55,920 --> 00:00:58,320
and a good obfuscation reveals nothing

29
00:00:58,320 --> 00:01:00,079
more about its functionality than what

30
00:01:00,079 --> 00:01:02,320
you can already learn from actually

31
00:01:02,320 --> 00:01:04,319
running it and just observing the input

32
00:01:04,319 --> 00:01:07,200
output behavior of the program

33
00:01:07,200 --> 00:01:08,880
one observation

34
00:01:08,880 --> 00:01:10,799
that will be crucial for today's talk is

35
00:01:10,799 --> 00:01:13,280
that the obfuscation of a program does

36
00:01:13,280 --> 00:01:15,520
not necessarily need to be a program

37
00:01:15,520 --> 00:01:17,040
itself

38
00:01:17,040 --> 00:01:19,280
there is no fundamental reason why it

39
00:01:19,280 --> 00:01:21,840
couldn't be say an image

40
00:01:21,840 --> 00:01:23,280
together with

41
00:01:23,280 --> 00:01:25,119
some public instructions on how to

42
00:01:25,119 --> 00:01:26,640
interpret that image how to run the

43
00:01:26,640 --> 00:01:29,439
program that's encoded by that image

44
00:01:29,439 --> 00:01:30,400
or

45
00:01:30,400 --> 00:01:33,520
why couldn't an obfuscation be a quantum

46
00:01:33,520 --> 00:01:35,119
state that you can interact with in

47
00:01:35,119 --> 00:01:37,200
order to execute your program

48
00:01:37,200 --> 00:01:39,439
so when i say obfuscation of a program

49
00:01:39,439 --> 00:01:40,960
or of a circuit

50
00:01:40,960 --> 00:01:43,360
i really mean it to be any

51
00:01:43,360 --> 00:01:46,320
possible object

52
00:01:48,240 --> 00:01:50,240
after this informal definition of

53
00:01:50,240 --> 00:01:52,000
obfuscation let's take a look at the

54
00:01:52,000 --> 00:01:53,439
plan for this talk

55
00:01:53,439 --> 00:01:55,920
i'll first formalize the definition of

56
00:01:55,920 --> 00:01:57,119
the type of obfuscation that we're

57
00:01:57,119 --> 00:01:58,799
looking at today the virtual black box

58
00:01:58,799 --> 00:02:00,960
observation

59
00:02:00,960 --> 00:02:02,479
then i will walk you through the ideas

60
00:02:02,479 --> 00:02:04,320
behind a famous proof which shows that

61
00:02:04,320 --> 00:02:06,399
it's impossible to obfuscate programs

62
00:02:06,399 --> 00:02:08,160
into classical objects according to this

63
00:02:08,160 --> 00:02:10,399
definition

64
00:02:10,399 --> 00:02:11,599
and then i will move on to our

65
00:02:11,599 --> 00:02:12,800
contribution

66
00:02:12,800 --> 00:02:15,280
which was adapting that classical proof

67
00:02:15,280 --> 00:02:16,800
to show that a wider notion of

68
00:02:16,800 --> 00:02:18,879
obfuscation is also impossible namely

69
00:02:18,879 --> 00:02:21,760
that we cannot even obfuscate classical

70
00:02:21,760 --> 00:02:24,640
programs into quantum objects

71
00:02:24,640 --> 00:02:26,720
and finally i will put our result into

72
00:02:26,720 --> 00:02:28,560
some context of previous and concurrent

73
00:02:28,560 --> 00:02:33,040
work and comment on some open questions

74
00:02:34,400 --> 00:02:35,280
okay

75
00:02:35,280 --> 00:02:37,360
the formalization of obfuscation that we

76
00:02:37,360 --> 00:02:38,959
will be interested in today is called

77
00:02:38,959 --> 00:02:41,680
virtual black box obfuscation and it is

78
00:02:41,680 --> 00:02:43,280
as follows

79
00:02:43,280 --> 00:02:45,519
an obfuscator o

80
00:02:45,519 --> 00:02:48,560
for some family of classical circuits f

81
00:02:48,560 --> 00:02:50,720
is an algorithm

82
00:02:50,720 --> 00:02:52,239
such that the following three things

83
00:02:52,239 --> 00:02:54,480
hold

84
00:02:54,879 --> 00:02:56,800
first the obfuscation of a circuit is

85
00:02:56,800 --> 00:02:58,000
not too big

86
00:02:58,000 --> 00:02:59,920
it's polynomially related to the size of

87
00:02:59,920 --> 00:03:01,760
the original circuit c

88
00:03:01,760 --> 00:03:05,840
we call this polynomial expansion

89
00:03:06,159 --> 00:03:08,480
second if the obfuscation is itself a

90
00:03:08,480 --> 00:03:09,840
circuit then that circuit is

91
00:03:09,840 --> 00:03:11,599
functionally equivalent to the original

92
00:03:11,599 --> 00:03:13,200
circuit c

93
00:03:13,200 --> 00:03:16,400
and we can generalize the second point

94
00:03:16,400 --> 00:03:17,440
whenever

95
00:03:17,440 --> 00:03:19,519
ofc is not a circuit but any other

96
00:03:19,519 --> 00:03:20,800
object

97
00:03:20,800 --> 00:03:23,040
then we need to add a publicly known

98
00:03:23,040 --> 00:03:26,239
interpreter j to the definition

99
00:03:26,239 --> 00:03:28,319
and j just contains instructions on how

100
00:03:28,319 --> 00:03:31,440
to use the obfuscation object

101
00:03:31,440 --> 00:03:33,599
functional equivalence then becomes

102
00:03:33,599 --> 00:03:35,599
if the interpreter is run on the

103
00:03:35,599 --> 00:03:38,560
obfuscation and an input x

104
00:03:38,560 --> 00:03:40,879
then it should use the correct outcome c

105
00:03:40,879 --> 00:03:42,400
of x

106
00:03:42,400 --> 00:03:45,040
and note that ofc can also be quantum

107
00:03:45,040 --> 00:03:46,959
state like i already mentioned and in

108
00:03:46,959 --> 00:03:48,400
that case this

109
00:03:48,400 --> 00:03:50,560
polynomial expansion property talks

110
00:03:50,560 --> 00:03:54,640
about the number of qubits in oc

111
00:03:55,519 --> 00:03:58,080
and third for security

112
00:03:58,080 --> 00:04:01,200
we use the virtual black box property or

113
00:04:01,200 --> 00:04:02,239
vbb

114
00:04:02,239 --> 00:04:04,720
which says that any efficient adversary

115
00:04:04,720 --> 00:04:07,840
that receives an obfuscation of c so ofc

116
00:04:07,840 --> 00:04:09,840
and outputs a single bit

117
00:04:09,840 --> 00:04:11,760
can be simulated by an efficient

118
00:04:11,760 --> 00:04:13,599
simulator that does not get the

119
00:04:13,599 --> 00:04:15,519
obfuscation at all only the size of the

120
00:04:15,519 --> 00:04:16,478
circuit

121
00:04:16,478 --> 00:04:18,000
but has oracle access to the

122
00:04:18,000 --> 00:04:20,079
functionality of the circuit

123
00:04:20,079 --> 00:04:21,839
so essentially anything you can learn

124
00:04:21,839 --> 00:04:24,320
about the circuit from the object of c

125
00:04:24,320 --> 00:04:26,160
can also be learned from querying the

126
00:04:26,160 --> 00:04:29,680
oracle for c polynomial number of times

127
00:04:29,680 --> 00:04:31,520
and if ofc is a quantum state then the

128
00:04:31,520 --> 00:04:33,280
adversary and simulator are also

129
00:04:33,280 --> 00:04:34,800
considered to be quantum algorithms of

130
00:04:34,800 --> 00:04:35,919
course

131
00:04:35,919 --> 00:04:38,320
and the simulator still interacts with a

132
00:04:38,320 --> 00:04:39,840
classical oracle because the

133
00:04:39,840 --> 00:04:41,919
functionality of c is still classical

134
00:04:41,919 --> 00:04:43,040
but it can then query it in

135
00:04:43,040 --> 00:04:44,560
superposition so that's something to

136
00:04:44,560 --> 00:04:47,120
keep in mind

137
00:04:47,280 --> 00:04:49,759
to get some intuition for how hard it is

138
00:04:49,759 --> 00:04:52,000
to satisfy its third property the vbv

139
00:04:52,000 --> 00:04:54,160
property let's consider the difference

140
00:04:54,160 --> 00:04:55,520
between getting

141
00:04:55,520 --> 00:04:56,960
o of c

142
00:04:56,960 --> 00:04:59,040
as an input or just interacting with an

143
00:04:59,040 --> 00:05:01,120
oracle for c

144
00:05:01,120 --> 00:05:01,919
and

145
00:05:01,919 --> 00:05:04,240
getting ofc as an input is quite

146
00:05:04,240 --> 00:05:05,759
significant because it allows the

147
00:05:05,759 --> 00:05:07,680
adversary to

148
00:05:07,680 --> 00:05:10,000
manipulate this object

149
00:05:10,000 --> 00:05:11,919
it can dissect it into pieces for

150
00:05:11,919 --> 00:05:13,360
example or

151
00:05:13,360 --> 00:05:15,280
it can make changes to it and and see

152
00:05:15,280 --> 00:05:16,479
what happens

153
00:05:16,479 --> 00:05:18,880
so as an example think again of this

154
00:05:18,880 --> 00:05:21,280
pictorial obfuscation from earlier

155
00:05:21,280 --> 00:05:23,039
you could try to see as an adversary

156
00:05:23,039 --> 00:05:24,479
what happens to the input output

157
00:05:24,479 --> 00:05:26,639
behavior if you change a red area into

158
00:05:26,639 --> 00:05:29,440
blue or if you run the interpreter on

159
00:05:29,440 --> 00:05:31,360
the upside down version of the image and

160
00:05:31,360 --> 00:05:32,639
so forth

161
00:05:32,639 --> 00:05:35,360
and the simulator on the other hand

162
00:05:35,360 --> 00:05:37,759
really only sees inputs and outputs and

163
00:05:37,759 --> 00:05:40,400
cannot do all of those things

164
00:05:40,400 --> 00:05:43,440
and for some function families

165
00:05:43,440 --> 00:05:45,199
like learnable functions the difference

166
00:05:45,199 --> 00:05:47,120
really doesn't matter

167
00:05:47,120 --> 00:05:49,120
those function families are obfuscatable

168
00:05:49,120 --> 00:05:51,360
in the vbb sense but for some more

169
00:05:51,360 --> 00:05:53,840
general function families the adversary

170
00:05:53,840 --> 00:05:56,639
can take advantage of having an object

171
00:05:56,639 --> 00:05:58,000
to manipulate

172
00:05:58,000 --> 00:05:59,280
and those

173
00:05:59,280 --> 00:06:02,240
function families are not obfuscatable

174
00:06:02,240 --> 00:06:04,960
in 2001 barakatuh showed the existence

175
00:06:04,960 --> 00:06:07,600
of such unobscurable function families

176
00:06:07,600 --> 00:06:10,240
and they did so by defining circuits

177
00:06:10,240 --> 00:06:11,840
where the adversary could really take

178
00:06:11,840 --> 00:06:13,280
advantage of the fact that they held

179
00:06:13,280 --> 00:06:15,680
this concrete obfuscation object in

180
00:06:15,680 --> 00:06:16,960
their hand and that they could break it

181
00:06:16,960 --> 00:06:19,440
up into individual parts or individual

182
00:06:19,440 --> 00:06:21,840
gates

183
00:06:22,080 --> 00:06:24,160
and since our result will be a

184
00:06:24,160 --> 00:06:25,759
generalization of this classical

185
00:06:25,759 --> 00:06:28,000
impossibility result i will explain some

186
00:06:28,000 --> 00:06:30,160
details of this unobscurable family that

187
00:06:30,160 --> 00:06:32,639
they defined

188
00:06:32,639 --> 00:06:36,639
it will be a family f of circuits

189
00:06:36,639 --> 00:06:40,000
parameterized by an alpha and a beta

190
00:06:40,000 --> 00:06:41,840
and

191
00:06:41,840 --> 00:06:43,440
the family will essentially consist of

192
00:06:43,440 --> 00:06:45,680
two types of circuits a type that we

193
00:06:45,680 --> 00:06:48,080
will call c alpha beta and a type that

194
00:06:48,080 --> 00:06:50,400
we will call z alpha beta

195
00:06:50,400 --> 00:06:52,400
in total this is still a subset of all

196
00:06:52,400 --> 00:06:55,199
polynomial size classical circuits but

197
00:06:55,199 --> 00:06:56,880
if one can show that

198
00:06:56,880 --> 00:06:58,319
this already this subset is

199
00:06:58,319 --> 00:07:00,800
unobfuscatable then certainly the set of

200
00:07:00,800 --> 00:07:03,360
all poly size classical circuits is also

201
00:07:03,360 --> 00:07:06,160
unobtruscatable

202
00:07:06,160 --> 00:07:10,160
and barracuda then define an algorithm a

203
00:07:10,160 --> 00:07:12,479
such that for all simulators s the

204
00:07:12,479 --> 00:07:15,280
following holds

205
00:07:15,520 --> 00:07:17,840
if the adversary receives an obfuscation

206
00:07:17,840 --> 00:07:20,639
of the first type of circuit c circuit

207
00:07:20,639 --> 00:07:23,919
it will almost always output one

208
00:07:23,919 --> 00:07:25,680
if it instead receives an obfuscation of

209
00:07:25,680 --> 00:07:28,080
the second type it will almost always up

210
00:07:28,080 --> 00:07:29,680
with zero

211
00:07:29,680 --> 00:07:32,319
so the adversary will almost always be

212
00:07:32,319 --> 00:07:34,400
able to tell the difference between a c

213
00:07:34,400 --> 00:07:36,639
and a z circuit

214
00:07:36,639 --> 00:07:38,319
and at the same time they show that with

215
00:07:38,319 --> 00:07:40,800
just oracle access

216
00:07:40,800 --> 00:07:42,560
it is impossible to tell the difference

217
00:07:42,560 --> 00:07:44,720
between the two types of circuits so no

218
00:07:44,720 --> 00:07:48,240
simulator can tell this difference

219
00:07:48,240 --> 00:07:50,400
and now towards this contradiction

220
00:07:50,400 --> 00:07:52,240
suppose that this entire class would be

221
00:07:52,240 --> 00:07:54,080
obfuscatable

222
00:07:54,080 --> 00:07:55,280
that would mean that there is a

223
00:07:55,280 --> 00:07:57,520
simulator that can always simulate the

224
00:07:57,520 --> 00:08:00,720
output of the adversary

225
00:08:00,720 --> 00:08:03,039
so both if the adversary got a c or a z

226
00:08:03,039 --> 00:08:04,479
circuit the simulator would be able to

227
00:08:04,479 --> 00:08:06,560
simulate its output

228
00:08:06,560 --> 00:08:08,960
but that leads it to a contradiction

229
00:08:08,960 --> 00:08:10,479
because

230
00:08:10,479 --> 00:08:12,400
no simulator could correctly output one

231
00:08:12,400 --> 00:08:14,240
whenever the adversary outputs a one on

232
00:08:14,240 --> 00:08:16,560
a c circuit and at the same time output

233
00:08:16,560 --> 00:08:18,160
is zero whenever the output center

234
00:08:18,160 --> 00:08:20,319
outputs a zero on the z circuit because

235
00:08:20,319 --> 00:08:21,680
that would mean that the simulator would

236
00:08:21,680 --> 00:08:23,680
be able to distinguish

237
00:08:23,680 --> 00:08:25,039
this is the general structure of the

238
00:08:25,039 --> 00:08:26,879
argument to show that this particular

239
00:08:26,879 --> 00:08:29,599
class f is unobscurable and now of

240
00:08:29,599 --> 00:08:31,520
course it just remains to find a

241
00:08:31,520 --> 00:08:33,839
definition of c and z so that the

242
00:08:33,839 --> 00:08:35,279
adversary can tell the difference but

243
00:08:35,279 --> 00:08:38,399
the simulator cannot

244
00:08:38,958 --> 00:08:40,880
and that's what i will do now so

245
00:08:40,880 --> 00:08:42,799
starting with c

246
00:08:42,799 --> 00:08:43,599
each

247
00:08:43,599 --> 00:08:46,399
circuit of this type is defined for the

248
00:08:46,399 --> 00:08:48,480
parameters alpha and beta and it's

249
00:08:48,480 --> 00:08:50,320
defined for three different cases

250
00:08:50,320 --> 00:08:52,080
determined by the first digit of the

251
00:08:52,080 --> 00:08:53,440
input

252
00:08:53,440 --> 00:08:56,080
so if you give it input one

253
00:08:56,080 --> 00:08:58,240
the function returns a fixed encryption

254
00:08:58,240 --> 00:08:59,920
of alpha

255
00:08:59,920 --> 00:09:01,680
and this encryption is

256
00:09:01,680 --> 00:09:04,640
homomorphic which means that anyone even

257
00:09:04,640 --> 00:09:06,560
if they don't know the secret key can

258
00:09:06,560 --> 00:09:09,200
turn the encryption of some value y

259
00:09:09,200 --> 00:09:11,519
into an encryption of f y for any f of

260
00:09:11,519 --> 00:09:13,040
their choice

261
00:09:13,040 --> 00:09:14,720
they don't they do need to know the

262
00:09:14,720 --> 00:09:16,560
public key for this

263
00:09:16,560 --> 00:09:18,480
which is why that is also returned upon

264
00:09:18,480 --> 00:09:20,839
input one that's the

265
00:09:20,839 --> 00:09:23,680
pk on inputs

266
00:09:23,680 --> 00:09:25,680
two comma x for sum x

267
00:09:25,680 --> 00:09:28,720
the function returns beta if and only if

268
00:09:28,720 --> 00:09:32,240
the other input x was equal to alpha

269
00:09:32,240 --> 00:09:34,080
this is called a point function it is

270
00:09:34,080 --> 00:09:35,920
zero everywhere except at the point

271
00:09:35,920 --> 00:09:39,519
alpha where it outputs beta

272
00:09:39,519 --> 00:09:42,480
and on input three comma x the function

273
00:09:42,480 --> 00:09:44,480
tests whether this other input x

274
00:09:44,480 --> 00:09:46,399
decrypts to beta

275
00:09:46,399 --> 00:09:48,399
if it does it returns one and otherwise

276
00:09:48,399 --> 00:09:51,440
it returns zero this type of function is

277
00:09:51,440 --> 00:09:54,880
known as a compute and compare function

278
00:09:54,880 --> 00:09:56,320
it computes a function of the input in

279
00:09:56,320 --> 00:09:58,320
this case the decryption function and it

280
00:09:58,320 --> 00:10:00,240
compares the result with a target value

281
00:10:00,240 --> 00:10:03,040
in this case beta

282
00:10:03,440 --> 00:10:05,920
now notice that if you have access to

283
00:10:05,920 --> 00:10:07,200
this functionality through an

284
00:10:07,200 --> 00:10:10,480
obfuscation of c alpha beta you could

285
00:10:10,480 --> 00:10:13,040
first request an encryption of alpha

286
00:10:13,040 --> 00:10:13,839
then

287
00:10:13,839 --> 00:10:16,160
turn that encryption of alpha into an

288
00:10:16,160 --> 00:10:18,640
encryption of beta by homomorphic

289
00:10:18,640 --> 00:10:22,399
evaluation of the second line of c

290
00:10:22,480 --> 00:10:23,440
and then

291
00:10:23,440 --> 00:10:25,600
input that resulting encryption

292
00:10:25,600 --> 00:10:27,279
into the third line

293
00:10:27,279 --> 00:10:29,760
to observe the output one

294
00:10:29,760 --> 00:10:31,600
and for the homomorphic evaluation it's

295
00:10:31,600 --> 00:10:33,279
crucial that you have access to the

296
00:10:33,279 --> 00:10:36,160
obfuscation for c not just an oracle

297
00:10:36,160 --> 00:10:38,000
because you want to run the homomorphic

298
00:10:38,000 --> 00:10:39,360
versions of each gate in that

299
00:10:39,360 --> 00:10:41,440
obfuscation so you need to be able to

300
00:10:41,440 --> 00:10:43,279
see those gates like break the

301
00:10:43,279 --> 00:10:45,519
obfuscation in up into its individual

302
00:10:45,519 --> 00:10:46,399
gates

303
00:10:46,399 --> 00:10:48,560
see those gates and run the homomorphic

304
00:10:48,560 --> 00:10:50,399
version of them

305
00:10:50,399 --> 00:10:52,000
and if you do this on this circuit c you

306
00:10:52,000 --> 00:10:56,720
will get output one out of the last line

307
00:10:57,519 --> 00:11:00,560
okay now for the second type of circuit

308
00:11:00,560 --> 00:11:01,760
z

309
00:11:01,760 --> 00:11:04,399
this circuit is identical to c except

310
00:11:04,399 --> 00:11:05,920
for the second line

311
00:11:05,920 --> 00:11:07,440
there instead of a point function it

312
00:11:07,440 --> 00:11:09,519
just always outputs zero

313
00:11:09,519 --> 00:11:11,120
and what this means in particular is

314
00:11:11,120 --> 00:11:13,120
that since there is no connection

315
00:11:13,120 --> 00:11:14,800
between the alpha and the beta anymore

316
00:11:14,800 --> 00:11:17,200
if you try the same tactic as before

317
00:11:17,200 --> 00:11:19,040
your third line will always end up in

318
00:11:19,040 --> 00:11:21,760
the otherwise case so outputting zero

319
00:11:21,760 --> 00:11:24,720
you will not be able to recover a valid

320
00:11:24,720 --> 00:11:28,560
encryption of beta if you have access to

321
00:11:28,560 --> 00:11:30,800
the z functionality not even if you have

322
00:11:30,800 --> 00:11:34,319
a physical obfuscation in your hand

323
00:11:34,560 --> 00:11:36,399
and what i've argued here is that an

324
00:11:36,399 --> 00:11:38,079
adversary given an obfuscation of either

325
00:11:38,079 --> 00:11:40,320
c or z can tell the difference there is

326
00:11:40,320 --> 00:11:42,079
a way to make the c circuit always

327
00:11:42,079 --> 00:11:44,000
output one and the z circuit always

328
00:11:44,000 --> 00:11:45,440
output zero

329
00:11:45,440 --> 00:11:46,959
and to complete the impossibility

330
00:11:46,959 --> 00:11:48,800
argument from the previous slide you

331
00:11:48,800 --> 00:11:49,760
would have to

332
00:11:49,760 --> 00:11:51,760
still argue that a simulator cannot tell

333
00:11:51,760 --> 00:11:53,200
the difference between these two types

334
00:11:53,200 --> 00:11:55,279
of circuits if they're given only oracle

335
00:11:55,279 --> 00:11:57,120
access to them

336
00:11:57,120 --> 00:11:59,360
i will not go into this during this talk

337
00:11:59,360 --> 00:12:00,959
but essentially you can argue that a

338
00:12:00,959 --> 00:12:02,560
simulator would have to guess the

339
00:12:02,560 --> 00:12:04,480
plaintext value of alpha

340
00:12:04,480 --> 00:12:06,560
and thereby it would have to break the

341
00:12:06,560 --> 00:12:08,399
encryption in order to tell the

342
00:12:08,399 --> 00:12:12,160
difference by querying the second line

343
00:12:12,320 --> 00:12:15,120
okay so we established that classical

344
00:12:15,120 --> 00:12:17,360
circuits cannot be obfuscated into

345
00:12:17,360 --> 00:12:20,000
classical circuits or you could even

346
00:12:20,000 --> 00:12:21,760
generalize these arguments to say that

347
00:12:21,760 --> 00:12:23,440
it can that they cannot be obfuscated

348
00:12:23,440 --> 00:12:26,000
into any classical objects

349
00:12:26,000 --> 00:12:27,839
but what about obfuscating classical

350
00:12:27,839 --> 00:12:30,399
circuits into quantum states

351
00:12:30,399 --> 00:12:32,079
this is a potential way around the

352
00:12:32,079 --> 00:12:34,720
impossibility result from 2001 and was

353
00:12:34,720 --> 00:12:36,959
already observed quite soon after that

354
00:12:36,959 --> 00:12:39,839
appeared and posed as one of the 10

355
00:12:39,839 --> 00:12:41,920
semi-grand challenges in quantum

356
00:12:41,920 --> 00:12:43,920
computing theory by scott aronson

357
00:12:43,920 --> 00:12:45,839
already in 2005.

358
00:12:45,839 --> 00:12:48,560
it was only in 2016 that a laggage and

359
00:12:48,560 --> 00:12:50,000
peppermint made some progress in

360
00:12:50,000 --> 00:12:52,320
adapting the classical proof and they

361
00:12:52,320 --> 00:12:53,760
were able to show that classical

362
00:12:53,760 --> 00:12:55,600
circuits could not be obfuscated into

363
00:12:55,600 --> 00:12:57,839
something they call reusable quantum

364
00:12:57,839 --> 00:13:01,519
objects such as quantum circuits

365
00:13:01,600 --> 00:13:03,360
but the full general result of quantum

366
00:13:03,360 --> 00:13:05,040
states turned out to require some tools

367
00:13:05,040 --> 00:13:07,200
that we didn't even have back then and

368
00:13:07,200 --> 00:13:09,200
in this talk i will complete their

369
00:13:09,200 --> 00:13:10,959
argument and show that obfuscating

370
00:13:10,959 --> 00:13:13,519
classical circuits

371
00:13:13,519 --> 00:13:16,720
into quantum states is also not possible

372
00:13:16,720 --> 00:13:18,639
our result generalizes this classical

373
00:13:18,639 --> 00:13:21,279
impossibility result but it only holds

374
00:13:21,279 --> 00:13:23,120
under the variant of the learning with

375
00:13:23,120 --> 00:13:25,839
error assumption

376
00:13:26,639 --> 00:13:28,560
the classical proof doesn't immediately

377
00:13:28,560 --> 00:13:30,639
work in the quantum setting anymore and

378
00:13:30,639 --> 00:13:33,600
that's mainly for two reasons

379
00:13:33,600 --> 00:13:34,720
first

380
00:13:34,720 --> 00:13:37,120
uh the homomorphic evaluation

381
00:13:37,120 --> 00:13:39,199
a quantum obfuscation would not be a

382
00:13:39,199 --> 00:13:41,120
classical circuit anymore so we cannot

383
00:13:41,120 --> 00:13:42,959
just straight straight forward we break

384
00:13:42,959 --> 00:13:44,639
it up into gates that we can

385
00:13:44,639 --> 00:13:46,480
homomorphically evaluate

386
00:13:46,480 --> 00:13:47,839
it's not even a quantum circuit

387
00:13:47,839 --> 00:13:49,600
necessary it can be a quantum state so

388
00:13:49,600 --> 00:13:51,120
how do you break it up into individual

389
00:13:51,120 --> 00:13:53,440
gates

390
00:13:53,680 --> 00:13:54,880
for this problem there's a pretty

391
00:13:54,880 --> 00:13:56,880
straightforward solution

392
00:13:56,880 --> 00:13:58,880
and the reason is that

393
00:13:58,880 --> 00:14:00,720
i already slightly

394
00:14:00,720 --> 00:14:02,480
adapted the classical impossibility

395
00:14:02,480 --> 00:14:04,000
proof when i presented it to you by

396
00:14:04,000 --> 00:14:05,519
assuming that fully homomorphic

397
00:14:05,519 --> 00:14:06,959
encryption exists

398
00:14:06,959 --> 00:14:08,320
at the time that the original proof

399
00:14:08,320 --> 00:14:10,399
appeared this was not just established

400
00:14:10,399 --> 00:14:12,639
so if you go and look at the original

401
00:14:12,639 --> 00:14:14,480
paper you will find that c and z were

402
00:14:14,480 --> 00:14:17,199
defined somewhat differently

403
00:14:17,199 --> 00:14:18,959
however with this current formulation we

404
00:14:18,959 --> 00:14:20,720
can simply say

405
00:14:20,720 --> 00:14:22,639
well the obfuscation may not be a

406
00:14:22,639 --> 00:14:24,399
circuit that we can run homomorphically

407
00:14:24,399 --> 00:14:27,360
but the interpreter algorithm is

408
00:14:27,360 --> 00:14:29,199
the interpreter may be a quantum circuit

409
00:14:29,199 --> 00:14:32,079
though so we do require quantum

410
00:14:32,079 --> 00:14:34,959
homomorphic encryption

411
00:14:34,959 --> 00:14:36,320
the second problem is a little bit

412
00:14:36,320 --> 00:14:39,279
bigger and we call it reusability so in

413
00:14:39,279 --> 00:14:40,880
the classical proof we run this

414
00:14:40,880 --> 00:14:43,360
obfuscated circuit several times first

415
00:14:43,360 --> 00:14:45,760
to retrieve an encryption of alpha then

416
00:14:45,760 --> 00:14:47,760
homomorphically and finally for the

417
00:14:47,760 --> 00:14:50,000
compute and compare decryption

418
00:14:50,000 --> 00:14:51,600
if the obfuscation is classical that's

419
00:14:51,600 --> 00:14:53,920
all fine but if the obfuscation is a

420
00:14:53,920 --> 00:14:55,360
quantum state it's not so clear that

421
00:14:55,360 --> 00:14:57,120
it's possible to just reuse it many

422
00:14:57,120 --> 00:14:59,600
times for example maybe the interpreter

423
00:14:59,600 --> 00:15:01,760
algorithm is supposed to measure

424
00:15:01,760 --> 00:15:04,399
the obfuscation state in some way

425
00:15:04,399 --> 00:15:06,160
or do other stuff that destroys this

426
00:15:06,160 --> 00:15:09,279
state during the computation

427
00:15:09,279 --> 00:15:13,199
and to solve this we do two things first

428
00:15:13,199 --> 00:15:15,440
we note that if the output of one of

429
00:15:15,440 --> 00:15:16,959
those steps is classical and

430
00:15:16,959 --> 00:15:18,240
deterministic

431
00:15:18,240 --> 00:15:20,000
we can just safely measure it without

432
00:15:20,000 --> 00:15:21,760
disturbing the state and then

433
00:15:21,760 --> 00:15:24,079
revert the interpreter to retrieve the

434
00:15:24,079 --> 00:15:26,320
original obfuscation which can then be

435
00:15:26,320 --> 00:15:27,920
used again

436
00:15:27,920 --> 00:15:30,000
so for example after we run the first

437
00:15:30,000 --> 00:15:31,759
line to obtain the encryption of alpha

438
00:15:31,759 --> 00:15:33,759
that's always just the same fixed

439
00:15:33,759 --> 00:15:36,480
encryption we can just measure it then

440
00:15:36,480 --> 00:15:38,480
reverse the computation and we will get

441
00:15:38,480 --> 00:15:40,720
our observation back and the same thing

442
00:15:40,720 --> 00:15:42,000
holds for the third line where the

443
00:15:42,000 --> 00:15:44,000
output is always deterministically zero

444
00:15:44,000 --> 00:15:46,240
or one depending on your input

445
00:15:46,240 --> 00:15:47,199
of course

446
00:15:47,199 --> 00:15:49,279
this doesn't work if the output is mixed

447
00:15:49,279 --> 00:15:50,959
which it could be after the homomorphic

448
00:15:50,959 --> 00:15:54,160
evaluation of line two because then the

449
00:15:54,160 --> 00:15:56,079
output may be a superposition of

450
00:15:56,079 --> 00:15:58,160
ciphertext maybe there

451
00:15:58,160 --> 00:16:00,079
there's a superposition of all for the

452
00:16:00,079 --> 00:16:01,600
same value beta

453
00:16:01,600 --> 00:16:03,279
but still measuring that ciphertext

454
00:16:03,279 --> 00:16:05,600
before reverting may collapse the

455
00:16:05,600 --> 00:16:06,959
superposition over the different

456
00:16:06,959 --> 00:16:08,880
ciphertexts and then disturb the

457
00:16:08,880 --> 00:16:11,040
obfuscation

458
00:16:11,040 --> 00:16:12,880
and to get around this problem we have

459
00:16:12,880 --> 00:16:15,680
to reshuffle the circuit c a bit to make

460
00:16:15,680 --> 00:16:18,240
the homomorphic evaluation step

461
00:16:18,240 --> 00:16:21,800
occur last

462
00:16:22,880 --> 00:16:25,120
the change to the circuits c and z that

463
00:16:25,120 --> 00:16:27,440
we make will be in the last line

464
00:16:27,440 --> 00:16:29,120
so instead of it being a computer

465
00:16:29,120 --> 00:16:31,680
compare function itself on the input x

466
00:16:31,680 --> 00:16:34,839
we let it return a fixed classical

467
00:16:34,839 --> 00:16:37,360
obfuscation of that compute and compare

468
00:16:37,360 --> 00:16:39,120
function

469
00:16:39,120 --> 00:16:40,720
so i haven't changed anything about the

470
00:16:40,720 --> 00:16:42,639
function within the brackets here it's

471
00:16:42,639 --> 00:16:44,399
just that the circuit c doesn't compute

472
00:16:44,399 --> 00:16:46,320
that function itself but it statically

473
00:16:46,320 --> 00:16:48,399
returns an obfuscation

474
00:16:48,399 --> 00:16:52,160
and this o sub cc stands for a classical

475
00:16:52,160 --> 00:16:54,240
obfuscator for the class of compute and

476
00:16:54,240 --> 00:16:56,639
compare functions this is a subclass for

477
00:16:56,639 --> 00:16:58,720
which application is not impossible and

478
00:16:58,720 --> 00:17:00,560
it does exist

479
00:17:00,560 --> 00:17:02,160
under some variant of the learning with

480
00:17:02,160 --> 00:17:04,400
errors assumption

481
00:17:04,400 --> 00:17:06,319
and it's secure as long as beta is

482
00:17:06,319 --> 00:17:09,199
sufficiently random

483
00:17:09,599 --> 00:17:11,679
and the adversary can do almost the same

484
00:17:11,679 --> 00:17:13,919
tactic now and still

485
00:17:13,919 --> 00:17:15,599
distinguish between

486
00:17:15,599 --> 00:17:17,359
an obfuscation of c where it will get

487
00:17:17,359 --> 00:17:19,520
output one and an obfuscation of z where

488
00:17:19,520 --> 00:17:21,199
it will get output zero

489
00:17:21,199 --> 00:17:22,720
the only thing is that the order in

490
00:17:22,720 --> 00:17:24,240
which the adversary has two things is

491
00:17:24,240 --> 00:17:26,079
slightly different

492
00:17:26,079 --> 00:17:27,599
so it starts again with running the

493
00:17:27,599 --> 00:17:29,280
first line to retrieve an encryption of

494
00:17:29,280 --> 00:17:30,240
one

495
00:17:30,240 --> 00:17:32,640
uh which is a deterministic action

496
00:17:32,640 --> 00:17:34,720
and then reverts and then instead of

497
00:17:34,720 --> 00:17:36,240
running the second line homomorphically

498
00:17:36,240 --> 00:17:37,840
which could destroy the obfuscation

499
00:17:37,840 --> 00:17:40,799
state it runs the third line to retrieve

500
00:17:40,799 --> 00:17:42,960
the obfuscation of the computer compare

501
00:17:42,960 --> 00:17:44,960
function which again yields a fixed

502
00:17:44,960 --> 00:17:46,480
deterministic result

503
00:17:46,480 --> 00:17:49,039
so that too can be just safely reverted

504
00:17:49,039 --> 00:17:51,280
and it just remembers the encryption of

505
00:17:51,280 --> 00:17:53,039
alpha and the obligation of this

506
00:17:53,039 --> 00:17:55,760
computer compare function

507
00:17:55,760 --> 00:17:58,160
and only then the adversary runs the

508
00:17:58,160 --> 00:18:00,160
second line to either get an encryption

509
00:18:00,160 --> 00:18:02,480
of beta if the obfuscation was of the

510
00:18:02,480 --> 00:18:04,640
circuit c or an encryption of zero if

511
00:18:04,640 --> 00:18:06,720
the obfuscation was of the other type of

512
00:18:06,720 --> 00:18:08,400
circuit z

513
00:18:08,400 --> 00:18:09,919
this action may destroy the state but

514
00:18:09,919 --> 00:18:11,280
that's okay

515
00:18:11,280 --> 00:18:13,120
because the only thing left to do now is

516
00:18:13,120 --> 00:18:15,039
to use the already retrieved information

517
00:18:15,039 --> 00:18:16,400
in the second step

518
00:18:16,400 --> 00:18:17,679
about the compute and compare

519
00:18:17,679 --> 00:18:20,240
obfuscation to distinguish between the

520
00:18:20,240 --> 00:18:22,320
two types of circuits

521
00:18:22,320 --> 00:18:23,840
and note that this small change to the

522
00:18:23,840 --> 00:18:25,200
circuits although it made a lot of

523
00:18:25,200 --> 00:18:26,559
difference for the visibility of the

524
00:18:26,559 --> 00:18:28,880
adversary strategy doesn't help the

525
00:18:28,880 --> 00:18:30,480
simulator at all

526
00:18:30,480 --> 00:18:32,480
a simulator would still not be able to

527
00:18:32,480 --> 00:18:34,720
tell the difference between a c or a z

528
00:18:34,720 --> 00:18:37,120
circuit

529
00:18:37,840 --> 00:18:39,840
all right so those were the two main

530
00:18:39,840 --> 00:18:43,039
changes we made to the classical proof

531
00:18:43,039 --> 00:18:43,919
running

532
00:18:43,919 --> 00:18:46,000
the interpreter homomorphically using

533
00:18:46,000 --> 00:18:48,160
quantum homomorphic encryption scheme

534
00:18:48,160 --> 00:18:50,480
and solving this reusability problem by

535
00:18:50,480 --> 00:18:52,880
introducing an obfuscation of a compute

536
00:18:52,880 --> 00:18:54,799
and compare functionality so that we

537
00:18:54,799 --> 00:18:56,640
could change the order in which the

538
00:18:56,640 --> 00:19:00,480
adversary run the circuit

539
00:19:00,720 --> 00:19:03,280
but if you're paying close attention you

540
00:19:03,280 --> 00:19:05,919
may have noticed some problem already in

541
00:19:05,919 --> 00:19:07,360
the way i presented the classical

542
00:19:07,360 --> 00:19:09,120
impossibility proof

543
00:19:09,120 --> 00:19:12,640
so recall that the first line of c

544
00:19:12,640 --> 00:19:14,400
it returns among other things the public

545
00:19:14,400 --> 00:19:17,679
evaluation key for the law of encryption

546
00:19:17,679 --> 00:19:20,799
of course if this key is longer the size

547
00:19:20,799 --> 00:19:23,440
of the total circuit c grows as well

548
00:19:23,440 --> 00:19:25,200
and since we need to

549
00:19:25,200 --> 00:19:27,360
evaluate c homomorphically in one of the

550
00:19:27,360 --> 00:19:29,440
steps that means that the depth of the

551
00:19:29,440 --> 00:19:31,600
evaluation also increases

552
00:19:31,600 --> 00:19:35,440
and that requires more key again

553
00:19:35,440 --> 00:19:36,240
and

554
00:19:36,240 --> 00:19:39,039
one solution to this kind of loop

555
00:19:39,039 --> 00:19:41,520
problem is to assume a circular security

556
00:19:41,520 --> 00:19:42,880
of the homomorphic encryption so that

557
00:19:42,880 --> 00:19:44,400
the length of the public key does not

558
00:19:44,400 --> 00:19:45,679
have to depend on the depth of the

559
00:19:45,679 --> 00:19:47,600
homomorphic evaluation then we can break

560
00:19:47,600 --> 00:19:48,720
this loop

561
00:19:48,720 --> 00:19:50,559
but we get around this problem in a

562
00:19:50,559 --> 00:19:52,559
different way namely by slightly

563
00:19:52,559 --> 00:19:56,160
adapting the circuit c again

564
00:19:57,039 --> 00:19:59,360
we define the notion of decomposable

565
00:19:59,360 --> 00:20:01,600
public keys and have the circuit c

566
00:20:01,600 --> 00:20:03,600
return small blocks of the decomposed

567
00:20:03,600 --> 00:20:06,080
key at a time

568
00:20:06,080 --> 00:20:07,440
these blocks can be generated

569
00:20:07,440 --> 00:20:09,600
efficiently and their size is

570
00:20:09,600 --> 00:20:12,720
independent of the evaluation depth

571
00:20:12,720 --> 00:20:15,280
a user can reassemble the blocks again

572
00:20:15,280 --> 00:20:16,159
into

573
00:20:16,159 --> 00:20:18,080
the original public key

574
00:20:18,080 --> 00:20:19,679
after requesting sufficiently many

575
00:20:19,679 --> 00:20:20,400
blocks

576
00:20:20,400 --> 00:20:22,559
and the blocks do not reveal any

577
00:20:22,559 --> 00:20:25,600
additional information

578
00:20:25,679 --> 00:20:26,720
and in the proof there are some

579
00:20:26,720 --> 00:20:28,400
subtleties to consider

580
00:20:28,400 --> 00:20:29,840
at the point in time where we have to

581
00:20:29,840 --> 00:20:32,080
fix the circuit class the size of the

582
00:20:32,080 --> 00:20:34,799
interpreter algorithm is not yet fixed

583
00:20:34,799 --> 00:20:36,720
so we don't know an upper bound to the

584
00:20:36,720 --> 00:20:39,360
number of blocks that we'll need

585
00:20:39,360 --> 00:20:40,400
and in the end we have to really

586
00:20:40,400 --> 00:20:42,320
carefully work around the quantifiers

587
00:20:42,320 --> 00:20:44,480
and construct a circuit class so that

588
00:20:44,480 --> 00:20:47,600
for any polysized interpreter there is

589
00:20:47,600 --> 00:20:49,600
some circuit in the class that reveals

590
00:20:49,600 --> 00:20:51,919
sufficiently many blocks

591
00:20:51,919 --> 00:20:54,080
this is still sufficient to show

592
00:20:54,080 --> 00:20:56,240
impossibility of quantum black box

593
00:20:56,240 --> 00:20:59,039
virtual black box obfuscation

594
00:20:59,039 --> 00:21:00,960
because there are circuits in the class

595
00:21:00,960 --> 00:21:02,720
for which the adversary will succeed but

596
00:21:02,720 --> 00:21:05,840
the simulator will not

597
00:21:06,880 --> 00:21:09,039
okay to just summarize it will compare a

598
00:21:09,039 --> 00:21:11,200
construction to the two earlier works on

599
00:21:11,200 --> 00:21:13,440
impossibility of obfuscating classical

600
00:21:13,440 --> 00:21:14,480
circuits

601
00:21:14,480 --> 00:21:17,120
the classical baroquetale result

602
00:21:17,120 --> 00:21:19,200
and the quantum obfuscation paper by a

603
00:21:19,200 --> 00:21:22,240
luggage and peppermint

604
00:21:23,039 --> 00:21:25,679
so the circuit class that we proved to

605
00:21:25,679 --> 00:21:28,320
be unobscurable is the class of

606
00:21:28,320 --> 00:21:30,400
classical circuits

607
00:21:30,400 --> 00:21:33,679
2016 results the circuit class contained

608
00:21:33,679 --> 00:21:36,320
a quantum homomorphic evaluation step

609
00:21:36,320 --> 00:21:39,039
making the unobscurable class quantum

610
00:21:39,039 --> 00:21:40,640
this is a broader class and therefore

611
00:21:40,640 --> 00:21:42,960
the resulting impossibility theorem was

612
00:21:42,960 --> 00:21:45,840
somewhat weaker

613
00:21:45,919 --> 00:21:47,600
the type of obfuscation that is shown to

614
00:21:47,600 --> 00:21:49,440
be impossible is improved from classical

615
00:21:49,440 --> 00:21:52,080
circuits or classical strings in 2001

616
00:21:52,080 --> 00:21:55,520
to reusable quantum states in 2016 and

617
00:21:55,520 --> 00:21:57,440
to the most general case of quantum

618
00:21:57,440 --> 00:22:00,720
states in our work

619
00:22:00,960 --> 00:22:02,720
and the compromise that we have to make

620
00:22:02,720 --> 00:22:04,320
for this is that our assumptions are

621
00:22:04,320 --> 00:22:07,600
stronger than what was needed before

622
00:22:07,600 --> 00:22:09,280
in the earlier works they only needed to

623
00:22:09,280 --> 00:22:11,760
assume that one-way functions exist or

624
00:22:11,760 --> 00:22:13,679
quantum secure one-way functions in the

625
00:22:13,679 --> 00:22:15,919
2016 paper

626
00:22:15,919 --> 00:22:17,840
whereas for our result we need

627
00:22:17,840 --> 00:22:20,400
a quantum fully homomorph encryption and

628
00:22:20,400 --> 00:22:22,000
on top of that we also need to compute

629
00:22:22,000 --> 00:22:23,840
and compare obfuscation

630
00:22:23,840 --> 00:22:26,080
for those two ingredients we require the

631
00:22:26,080 --> 00:22:27,280
assumption that a variant of the

632
00:22:27,280 --> 00:22:29,120
learning with errors problem is hard for

633
00:22:29,120 --> 00:22:31,600
quantum computers

634
00:22:31,600 --> 00:22:32,960
we were able to get rid of the

635
00:22:32,960 --> 00:22:34,799
additional assumption that homomorphic

636
00:22:34,799 --> 00:22:36,559
encryption would need to be circularly

637
00:22:36,559 --> 00:22:38,960
secure however

638
00:22:38,960 --> 00:22:40,400
so in summary we strengthen the

639
00:22:40,400 --> 00:22:42,000
impossibility result by showing that an

640
00:22:42,000 --> 00:22:44,400
even smaller class is unobscurable even

641
00:22:44,400 --> 00:22:46,320
if the obfuscation could be a quantum

642
00:22:46,320 --> 00:22:47,600
state

643
00:22:47,600 --> 00:22:49,840
but we do that as the expense at the

644
00:22:49,840 --> 00:22:52,080
expense of a stronger but still standard

645
00:22:52,080 --> 00:22:54,159
assumption

646
00:22:54,159 --> 00:22:55,840
i also want to mention some concurrent

647
00:22:55,840 --> 00:22:57,919
work by rolando and leblanca

648
00:22:57,919 --> 00:22:59,520
who made essentially the same

649
00:22:59,520 --> 00:23:01,360
construction as ours in the context of

650
00:23:01,360 --> 00:23:03,360
secure software leasing

651
00:23:03,360 --> 00:23:05,600
their goal is slightly harder because

652
00:23:05,600 --> 00:23:07,440
for secure software leasing they need to

653
00:23:07,440 --> 00:23:09,200
exhibit a circuit class where the

654
00:23:09,200 --> 00:23:10,720
adversary cannot just tell the

655
00:23:10,720 --> 00:23:12,960
difference between c and z but can

656
00:23:12,960 --> 00:23:14,720
extract some meaningful information from

657
00:23:14,720 --> 00:23:17,120
the obfuscation enough to produce a copy

658
00:23:17,120 --> 00:23:18,640
of the functionality

659
00:23:18,640 --> 00:23:20,320
so in that sense the result that they

660
00:23:20,320 --> 00:23:22,480
achieve is stronger and more general

661
00:23:22,480 --> 00:23:24,080
they do use a circular security

662
00:23:24,080 --> 00:23:25,600
assumption but

663
00:23:25,600 --> 00:23:27,039
we believe that it could be removed from

664
00:23:27,039 --> 00:23:30,640
their construction using our techniques

665
00:23:30,880 --> 00:23:33,039
and to end this talk i will give a bit

666
00:23:33,039 --> 00:23:36,559
of an outlook on possible future work um

667
00:23:36,559 --> 00:23:38,320
the first one is a bit fake but it may

668
00:23:38,320 --> 00:23:40,240
be possible actually to get rid of the

669
00:23:40,240 --> 00:23:42,960
lwe assumption that we based a result on

670
00:23:42,960 --> 00:23:43,679
and

671
00:23:43,679 --> 00:23:45,039
to do this

672
00:23:45,039 --> 00:23:46,480
you would have to do two things you

673
00:23:46,480 --> 00:23:48,159
would first have to find an alternative

674
00:23:48,159 --> 00:23:50,000
for the quantum fully homomorph

675
00:23:50,000 --> 00:23:51,120
encryption

676
00:23:51,120 --> 00:23:53,360
maybe moving some classical part of it

677
00:23:53,360 --> 00:23:55,120
back into the circuit so that it doesn't

678
00:23:55,120 --> 00:23:57,200
rely on the learning with errors

679
00:23:57,200 --> 00:23:59,200
assumption anymore and second you would

680
00:23:59,200 --> 00:24:00,720
also have to get rid of this compute and

681
00:24:00,720 --> 00:24:02,559
compare obfuscation finding a different

682
00:24:02,559 --> 00:24:04,080
solution for the fact that the

683
00:24:04,080 --> 00:24:06,159
obfuscated state may be destroyed after

684
00:24:06,159 --> 00:24:08,320
homomorph evaluation or showing that

685
00:24:08,320 --> 00:24:11,760
it's actually not really destroyed

686
00:24:12,960 --> 00:24:15,360
and on the possibility side a weaker

687
00:24:15,360 --> 00:24:16,960
notion of quantum obfuscation might

688
00:24:16,960 --> 00:24:18,880
still be possible so for example

689
00:24:18,880 --> 00:24:20,799
indistinguishability obfuscation is not

690
00:24:20,799 --> 00:24:23,520
ruled out for impossibility result

691
00:24:23,520 --> 00:24:25,039
and it is getting a lot of attention in

692
00:24:25,039 --> 00:24:27,039
the classical crypto world and lately

693
00:24:27,039 --> 00:24:29,039
also in the quantum crypto world

694
00:24:29,039 --> 00:24:31,679
so maybe possible to quantumly obfuscate

695
00:24:31,679 --> 00:24:33,919
classical or quantum functionalities in

696
00:24:33,919 --> 00:24:34,720
this

697
00:24:34,720 --> 00:24:37,440
weaker sense

698
00:24:37,440 --> 00:24:39,039
that's all for now i hope you enjoyed

699
00:24:39,039 --> 00:24:40,960
watching this video and i wish you a

700
00:24:40,960 --> 00:24:44,600
great rest of the conference

